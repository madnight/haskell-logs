00:03:18 <liste> xelxebar would EitherT or ErrorT be too heavyweight?
00:09:49 <xelxebar> liste: I need to learn about transformers. In the `parseConfig` function, I'm already using `ExceptT`, though that's basically a copy paste from the `Data.ConfigFile` docs. Only difference is that the `Data.ConfigFile` example was using `ErrorT` and I was seening deprecation warnings in favor of `ExceptT` so I did a drop in replace.
00:13:51 <xelxebar> Thank you for the suggestion. This seems like the direction I need to look. FPComplete even hase a 2013 article that seems really relevant! http://polr.me/3h0
00:13:52 <liste> you could also have "type ErrorMessage = Text" and "fetchReply :: MsgSpec -> IO (Maybe ErrorMessage)
00:15:25 <xelxebar> That seems algebraically to be what we're going for. Hmmm...
00:17:45 <EvanR> How is ExceptT different from EitherT
00:17:55 <liste> no Error class
00:18:03 <liste> oh, sorry
00:18:09 <liste> that's ErrorT vs EitherT
00:20:28 <liste> so I guess EitherT and ExceptT are similar
00:21:07 <EvanR> isomorphic?
00:21:32 <alexv19> How can I export everything from module except one data constructor?
00:22:24 <liste> alexv19 just list everything else, it's a good idea anyway, avoids unintended exports
00:22:43 <liste> that may lead to bugs
00:22:52 <liste> or at least confusion
00:23:10 <EvanR> its also annoying to forget to put something new in the export list
00:23:58 <alexv19> liste: I have like 100 TH-generated defenitions and I need to hide just one
00:24:48 * hackagebot language-qux 0.1.1.2 - Utilities for working with the Qux language  https://hackage.haskell.org/package/language-qux-0.1.1.2 (hjwylde)
00:26:21 <liste> no idea then :/
00:27:03 <EvanR> uh TH-generate the export list?
00:27:24 <liste> https://ghc.haskell.org/trac/ghc/ticket/1475 found this
00:27:28 <liste> but it's status is "new"
00:27:49 <EvanR> nutter
00:28:52 <EvanR> alexv19: the gl library is currently being autogenerated somehow, maybe look how they do it
00:29:08 <EvanR> its way more than 100 exports
00:40:09 <m4lvin> :t [0..]
00:40:10 <lambdabot> (Enum t, Num t) => [t]
00:40:15 <m4lvin> :t (..)
00:40:16 <lambdabot> parse error on input ‘..’
00:40:21 <m4lvin> ?
00:40:37 <EvanR> .. can't be used as an operator
00:40:43 <EvanR> :t (...)
00:40:45 <lambdabot> (Applicative f, Plated c) => LensLike f s t c c -> Over p f c c a b -> Over p f s t a b
00:40:54 <EvanR> oh my
00:40:59 <Lokathor> yikes
00:41:14 <m4lvin> wow
00:41:27 <m4lvin> so, what exactly is .. ?
00:41:34 <alexv19> :t fromEnumTo
00:41:35 <EvanR> syntax
00:41:36 <lambdabot>     Not in scope: ‘fromEnumTo’
00:41:36 <lambdabot>     Perhaps you meant ‘fromEnum’ (imported from Prelude)
00:42:04 <alexv19> :t enumFromTo
00:42:05 <lambdabot> Enum a => a -> a -> [a]
00:42:41 <EvanR> :t [toEnum 0 ..]
00:42:42 <lambdabot> Enum t => [t]
01:26:22 <jle`> it's syntax ;_;
01:27:11 <merijn> Ok, so now that I finally forced myself to use trifecta I can say "zomg! dat error highlighting!"
01:30:22 <bernalex> http://projects.haskell.org/gtk2hs/ that's not gerat
01:30:30 <bernalex> *great
01:33:00 <jle`> i wonder what the tri- in trifecta is
01:39:17 <cocreature> bernalex: I think gtk2hs has moved to github https://github.com/gtk2hs/gtk2hs
01:39:35 <bernalex> cocreature: worth fixing the wiki in that case.
01:39:48 <cocreature> yep
01:39:50 * hackagebot dequeue 0.1.8 - A typeclass and an implementation for double-ended queues.  https://hackage.haskell.org/package/dequeue-0.1.8 (HenryBucklow)
01:43:15 <merijn> hmmm, anyone know a nice and clean way to refactor: "map (second (abstractKeys namedDecls)) namedDecls" or should I just move part of it into a local definition?
01:44:26 <bernalex> map =<< second . abstractKeys
01:44:34 <bernalex> fsvo "nice and clean" :p
01:47:32 <jhrcek> What does this type context mean? Where can I read more about this?  (~) * a () => PrintfType (IO a)
01:47:42 <jhrcek> taken from http://hackage.haskell.org/package/base-4.8.1.0/docs/Text-Printf.html#t:PrintfType
01:47:44 <shachaf> It means type equality.
01:47:50 <shachaf> (a ~ ()) => ...
01:48:54 <merijn> shachaf: Oh, is this related to making type equality more suitable for other kinds? i.e., the kind getting passed explicitly?
01:49:33 <jhrcek> schachaf: cool, I found a page in ghc user manual based on this. Thanks
01:50:04 <shachaf> merijn: Yes, it's the typical PolyKinds nonsense, except harder to read because it's an infix operator.
01:50:18 <bernalex> lolwtf you can't build reactive-banana unless you're on Mac OS X now?
01:50:35 <merijn> bernalex: ?
01:50:48 <bernalex> or is import Distribution.MacOSX supposed to uh not crash
01:51:23 <bernalex> maybe that doesn't exist any longer, or something like that?
01:52:02 <merijn> bernalex: Hard to figure out without any error message...
01:52:14 <bernalex> merijn: "could not find module".
01:52:25 <merijn> bernalex: Sounds like wrong dependencies
01:52:45 <bernalex> maybe he uses mac os x and never encountered the error himself then
01:53:06 <merijn> bernalex: module is in cabal-macosx, which doesn't seem to be platform dependent (well, what it does is, obviously)
01:53:12 <bernalex> but it still sounds stupid that I should have to care about Mac OS X crap. even in C we would do something more useful.
01:53:23 <bernalex> I guess I'll just add the dep for now
01:53:43 <bernalex>     Note: You need to install the (platform independent)
01:53:49 <bernalex> why not just dep on it then? hm
01:54:02 <merijn> bernalex: Oh, I know
01:54:11 <merijn> bernalex: I'm willing to bet it's a build dependency
01:54:20 <merijn> bernalex: Cabal doesn't support build dependencies atm
01:54:22 <bernalex> merijn: hmm yes it is
01:54:23 <bernalex> haha
01:54:27 <bernalex> great
01:54:30 <bernalex> ok thanks
01:54:45 <merijn> bernalex: I think there's a branch that does have those but it's not in cabal proper yet
01:54:48 <bernalex> emerge cabal-macosx # to the rescue.
01:54:57 <merijn> bernalex: So you can get proper dependencies for your Setup.hs
01:56:34 <merijn> @ask edwardk So I rewrote my parser to trifecta (<3 the errors), one problem I'm running into is that, since "token" (and thus also ident) consume all whitespace after a token it becomes hard to write line delimited parsers...am I missing something obvious?
01:56:34 <lambdabot> Consider it noted.
02:00:20 <merijn> @ask edwardk Or am I supposed to newtype trifecta's Parser and write my own TokenParsing instance?
02:00:20 <lambdabot> Consider it noted.
02:13:28 <bartavelle> merijn, yes
02:13:40 <bartavelle> that's how you are supposed to do it
02:15:54 <bartavelle> merijn, same problem when trying to have other kind of comments. https://github.com/bartavelle/language-puppet/blob/master/Puppet/Parser.hs#L73-L94
02:22:40 <merijn> bartavelle: Thanks! That looks helpful
02:23:22 <merijn> Now I just need to figure out how I wanna do line continuation...
02:23:51 <merijn> I guess I can simply change the someSpace parser to only eat newlines when followed by an indent :)
02:26:06 <bartavelle> sounds like you'll need to keep track of the current indentation level and have some state then ?
02:26:28 <merijn> Maybe later when I make it more complex
02:26:37 <merijn> Currently I only allow top level definitions anyway :p
02:26:49 <bartavelle> heh
02:32:18 <merijn> bartavelle: I'm just implementing a proof-of-concept, useful syntax is optional ;)
02:34:53 * hackagebot webrtc-vad 0.1.0.0 - Easy voice activity detection  https://hackage.haskell.org/package/webrtc-vad-0.1.0.0 (PatrickChilton)
02:34:56 <tsahyt> How do I use type families with data kinds? I'm trying to adapt a gcd function on the type level (taken from the Fun with type functions paper) for use with GHC.TypeLits and the DataKinds extension. But now the compiler complains that the arguments to the type level functions are of the wrong kind.
02:37:02 <tsahyt> In particular I define the function with `type family GCD (d :: Nat) (m :: Nat) (n :: Nat)`, and then the first definition is `type instance GCD d 0 0 = d`, which throws the compiler error "The first argument of 'GCD' should have kind 'Nat' but 'd' has Kind '*'"
02:39:30 <merijn> tsahyt: Try "type instance GCD (d :: Nat) 0 0 = d"?
02:39:41 <merijn> tsahyt: Also, for GCD you almost certainly want to use closed type families
02:40:21 <tsahyt> merijn: "The signature specified kind 'Nat', but 'd' has kind '*'"
02:42:08 <tsahyt> I guess what I need is to explicitly express a constraint, like I would for an instance on the value level, but I can't find any documentation on how to do so
02:43:18 <merijn> tsahyt: Try using the closed type family syntax? https://gist.github.com/merijn/6130082
02:45:27 <tsahyt> merijn: So far that got rid of these particular errors, thanks. I'll have some other stuff to fix before I can say that it compiles with certainty
02:46:59 <tsahyt> On a related note, can I pattern match against a successor of a value with type literals like I would with the peano representation? Matching against (n + 1) doesn't work.
02:47:34 <merijn> tsahyt: I'm not sure you *can* do that in current GHC
02:48:02 <tsahyt> merijn: Okay, but at least I can do (n - 1) on the other side of the equation, so there's that. I might need to rearrange the equations though.
02:48:30 <merijn> tsahyt: I usually end up doing "data Nat = Zero | Succ Nat" atm
02:48:53 <merijn> tsahyt: There's work being done on a proper numerical solver in GHC, but that's probably in HEAD or maybe not even there yet...
02:51:15 <tsahyt> merijn: It seems to work now, thanks! It took some additional rearranging of the equations, and unfortunately I also had to enable UndecidableInstances.
02:51:33 <merijn> tsahyt: UndecidableInstances is fine
02:51:49 <merijn> tsahyt: Despite it's name it's not one of the "bad" extensions
02:51:56 <tsahyt> merijn: But, wouldn't I want to have my instances be decidable?
02:52:17 <merijn> tsahyt: UndecidableInstances means that instance checking is undecidable, i.e. your type checking may infinite loop
02:53:11 <tsahyt> merijn: That doesn't sound fine to me actually. I need to read up on this I think
02:53:16 <merijn> tsahyt: The only thing that can go wrong with UndecidableInstances is GHC hanging at compile time (in reality GHC gives up after some time X). But IF it compiles, there won't be a problem
02:53:50 <merijn> Unlike OverlappingInstances and friends, which means your compiled code can break in unexpected and brittle ways
02:53:54 <tsahyt> merijn: Are there "good", well-typed programs that cause such an infinite loop?
02:54:22 <merijn> tsahyt: Well, by definition, no. Because if GHC can't decide on a type, they are by definition not well-typed :p
02:55:06 <merijn> tsahyt: Well, imagine you typo your GCD recursion and you never hit a base case, so it infinite loops
02:55:48 <tsahyt> Okay that makes sense as to why I need those now. Interesting that it wasn't required with the version in the paper though.
02:56:11 <merijn> tsahyt: The problem is that, because of the halting problem, GHC uses an extremely conservative method too avoid loops like that in types. But it's TOO conservative, there are perfectly fine types, like GCD, that it can't prove will never loop, but will (obviously to us programmers) not loop
02:57:00 <tsahyt> So it's all because I'm asking it to do peano arithmetic at compile time basically, and there are undecidable functions in that system
03:00:53 <merijn> tsahyt: Right
03:01:17 <merijn> tsahyt: So as long as you don't f- up the peano functions you write ;)
03:02:45 <kqr> is there a way to tell stack to pull a package from github rather than stackage? (I want a newer version than whatever's up on stackage)
03:03:30 <tsahyt> kqr: If I remember correctly, you can just list the URL in packages in your stack.yaml
03:03:43 <liste> kqr https://github.com/commercialhaskell/stack/wiki/FAQ#i-need-to-use-a-package-or-version-of-a-package-that-is-not-available-on-hackage-what-should-i-do
03:04:19 <tsahyt> There's also an example at the top of https://github.com/commercialhaskell/stack/wiki/stack.yaml
03:05:06 <kqr> I've tried three different github URLs and none of them worked, so I was thinking I was misunderstanding something
03:05:20 <kqr> ah
03:05:23 <kqr> it needs -location stuff
03:06:56 <kqr> yup that seems to work
03:06:58 <kqr> cheers
03:09:54 * hackagebot dequeue 0.1.9 - A typeclass and an implementation for double-ended queues.  https://hackage.haskell.org/package/dequeue-0.1.9 (HenryBucklow)
03:13:17 <eguneys> how do I go from Parser a -> Parser [a] that is zeroOrMore characters
03:15:03 <liste> :t many -- eguneys you mean this?
03:15:05 <lambdabot> Alternative f => f a -> f [a]
03:15:46 <eguneys> how do I implement it?
03:16:15 <liste> it's already there
03:16:48 <liste> in Control.Applicative
03:20:24 <fractalsea> I’m having trouble defining our protocol in the type system: We have a series of commands along with data. The commands need associated metadata (there string representation, and binary representation). At the moment I have a sum type `data Command = Cmd1 | Cmd2 | …`, and functions to transorm them to the aformentioned representations. I also have a type to represent the message themselves. This looks like `data 
03:20:25 <fractalsea> Message = Cmd1Message Cmd1Data | Cmd2Message Cm2Data | …`. My problem with this is that these two types have to be manually kept in sync, and there is duplication. Is there any way around this problem? i.e. defining the Messages in terms of the Command type? Thanks
03:25:25 <pavonia> fractalsea: Why do you need two types? Can't you encode everything into a single data type?
03:26:04 <pavonia> Maybe an actual code example would help
03:27:56 <lpaste_> liste pasted “fractalsea would this help without being overkill?” at http://lpaste.net/140109
03:38:59 <fractalsea> liste, that might be something like what I’m after, although I’ve not used GADTs much before. I still don’t quite get what you are doing with the Tag types. Are they something like the “other representations of the commands” I was talking about, but at the type level?
03:39:15 <eube_> Hey ppl ! Any Proxychains user arround ? I want to setup a specific rule and don't know how ...
03:40:09 <lpaste_> fractalsea pasted “Protocol example” at http://lpaste.net/140110
03:40:36 <fractalsea> pavonia, ^ that’s essentially what I have currently
03:41:18 <fractalsea> Maybe it’s ok, I just don’t like the fact I need two types
03:42:09 <ttt_fff> in haskell, what is a library for being a REST _client_ ?
03:42:16 <ttt_fff> I need to to ahve haskell generate POST requests
03:42:19 <ttt_fff> (and GET requests)
03:42:24 <ttt_fff> haskell plays the role of client, not server
03:42:30 <Intolerable> @hackage api-builder
03:42:30 <lambdabot> http://hackage.haskell.org/package/api-builder
03:42:33 <Intolerable> shameless plug
03:43:33 <kqr> okay I'm sure I'm doing something very wrong when I'm trying to depend on a github version of a package. It complained about missing dependencies from that package, so I tried adding those to *my* projects cabal file, at which point they got installed. when I then tried to start ghci again it just throws a huge wall of C preprocessor errors at me
03:43:41 <liste> fractalsea basically just type level representations of the commands
03:44:09 <pavonia> fractalsea: Couldn't you map to ByteStrings/Byte directly from the Message?
03:44:40 <fractalsea> liste, hmm ok. I need to think about that some more
03:44:57 <EvanR> hmm ByteString quotient Byte type
03:45:55 <fractalsea> pavonia, No, because when I am deserialising a message, I need to know the ByteString representation of the command before I have actually constructed a Message value.
03:46:59 <ttt_fff> what is a good tutorial on how to write a haskell rest client ?
03:47:05 <liste> ttt_fff also wreq and http-client
03:47:27 <kqr> ah maybe specifying it in packages is the wrong thing to do, because it thinks it is a package I want to build and not just depend on
03:47:31 <ttt_fff> liste: what iis the answer before "also" ? (seems like you had an earlier part of your answer)
03:47:45 <pavonia> fractalsea: If I understand correctly, it's like a Read/Show for these Messages, so I don'T see why the parser functions needs a separate Command type
03:47:55 <Intolerable> ttt_fff: https://github.com/intolerable/api-builder/blob/master/README.md
03:48:21 <Intolerable> there's also a full package using api-builder here: https://github.com/intolerable/reddit
03:48:35 <liste> ttt_fff some examples of HTTP client libraries
03:48:39 <tsahyt> I've been wondering... I can have GHC produce LLVM code, and there are compilers from LLVM to JavaScript. Can I actually use this process to compile Haskell to JS?
03:48:55 <pavonia> fractalsea: Where does the Command value come from?
03:49:20 <fractalsea> pavonia, it’s not like read/show, in that it’s a representation of the command, and not of the entire message data
03:49:46 <pavonia> Let me paste my idea ...
03:50:01 <ttt_fff> Intolerable, liste: I don't get this yet, but let me look into these libraries
03:50:11 <fractalsea> pavonia, I’m not sure what you mean. There’s value constructors in the data daclaration for command
03:50:16 <fractalsea> pavonia, OK, thanks
03:50:38 <kqr> maybe valid-wanted: false is what I want
03:51:31 <pavonia> fractalsea: Hhm, wait, you said you need the Command value before you can construct the Message value. But where does the information about what Command value you have come from?
03:53:10 <merijn> tsahyt: Why bother going through LLVM? ghcjs compiles haskell directly to JS
03:53:29 <fractalsea> pavonia, the first byte I read off the wire represents the command, and determines which type I should decode the rest of the bytes into
03:53:31 <merijn> tsahyt: Including support for all GHC extensions, JS FFI and support for threading, STM, etc. :)
03:54:43 <merijn> fractalsea: You can't really have type level tags depending on input. I mean, you can with some nasty tricks, but it's not straightforward
03:55:04 <merijn> fractalsea: Because that would mean you have "types depending on terms", i.e., dependent types, which haskell doesn't have
03:55:32 <fractalsea> merijn, Ah I see
03:55:45 <merijn> fractalsea: You can fake it by having an existentially quantified wrapper around the tagged GADT and consuming it using a Rank2Type continuation function
03:55:51 <merijn> fractalsea: I might have some code for that, actually
03:55:58 <merijn> fractalsea: Not very pretty, though
03:56:01 <fractalsea> merijn, So do you think my current approach is as good as I can get in Haskell? I thought there may be a nicer way, but it sounds like there’ not
03:56:29 <merijn> fractalsea: https://github.com/merijn/SNet2.0/blob/master/SNet/Stream.hs
03:56:31 <fractalsea> merijn, Yeah that does not sound pretty. I’d rather just stick to a more naive/understandable approach
03:56:34 <ttt_fff> liste: wreq (http://www.serpentine.com/wreq/) looks awesome. Thanks!
03:56:41 <merijn> fractalsea: https://github.com/merijn/SNet2.0/blob/master/SNet/Types.hs#L32-L40
03:56:42 <tsahyt> merijn: Is GHCJS the preferred way to compile to solve the JS problem by now? Fay looked rather promising too.
03:56:53 <merijn> tsahyt: Fay is not really haskell
03:57:04 <chpatrick> is there an existing unsafeGeneralizeIO :: PrimMonad m => IO a -> m a that I've missed?
03:57:11 <merijn> tsahyt: i.e., all Fay code is valid haskell (afaik), but not all Haskell is valid Fay
03:57:22 <merijn> tsahyt: So it's more "a haskell-like language that compiles to JS"
03:57:29 <tsahyt> merijn: That's true, yes. Most of all I just want to avoid JS.
03:57:35 <merijn> tsahyt: Whereas ghcjs is "actual GHC haskell compiled to JS"
03:57:51 <liste> ttt_fff yw (:
03:57:55 <merijn> tsahyt: Which means that any library on hackage (well, except those using C/FFI, obviously) can be compiled using ghcjs
03:58:12 <tsahyt> merijn: Maybe it makes more sense to ask whether GHCJS is production ready by now.
03:58:22 <pavonia> fractalsea: That was my idea: http://lpaste.net/140113
03:58:25 <merijn> chpatrick: I don't think so, but you can unwrap IO and futz with it
03:58:39 <chpatrick> merijn: it's liftPrim . unsafeIOToST
03:58:43 <chpatrick> just wondering if it exists already
03:58:50 <merijn> tsahyt: Ask luite, he's in here a lot
03:59:05 <merijn> chpatrick: Probably not then, sounds like it's below the Fairbairn threshold :)
03:59:16 <fractalsea> merijn, Thank you
03:59:45 <Gurkenglas> Could one make length more efficient by a constant factor in the average case by knowing a probability distribution of the length in advance, thus being able to skip checks for [] when []'s probability is low enough, at the cost of having to backtrack in the improbable case? Or would one be unable to ever know one mistakenly assumed the (:) case once one went wrong, similarly to everything being over once one 
03:59:45 <Gurkenglas> inspects undefined?
03:59:58 <fractalsea> pavonia, Thank you. That’s similar to what I have. The Command was just a type around the bytes, that also bundled the byte representation with a string representation
04:00:19 <merijn> Gurkenglas: No, it would be WORSE than inspecting undefined
04:00:25 <merijn> Gurkenglas: That would be able to segfault
04:03:00 <chpatrick> actually it's unsafePrimToPrim
04:03:38 <fractalsea> Is there such thing as a generalised read/show that allows you to create an “isomorphism” between two types? E.g. Word8 and some type and some sum type? Or should I just use ad-hoc typeclasses for this (equivilant to read/show serialise/deserialise etc.)?
04:03:55 <merijn> fractalsea: lens has a notion of isomorphisms
04:03:58 <merijn> Iso a b
04:04:45 <merijn> fractalsea: And using that you can use all existing lens stuff too :)
04:06:12 <merijn> :t iso toEnum fromEnum
04:06:14 <lambdabot> (Enum a, Enum a1, Functor f, Profunctor p) => p a (f a1) -> p Int (f Int)
04:06:27 <stianhj> Anyone use haskell-mode in Emacs with stack? ghc-mod hangs at initializing because cabal can't find dependencies from .cabal-file.
04:07:11 <tsahyt> stianhj: I've had a similar problem using vim. ghc-mod cannot work with stack yet. There's a repository with a quick and dirty fix.
04:07:33 <tsahyt> stianhj: https://www.reddit.com/r/haskell/comments/3cf5yd/stack_ghcmod_work_in_progress/ See this thread
04:07:42 <chpatrick> is it kosher to throw exceptions in st?
04:08:12 <merijn> chpatrick: Sure, if you don't unsafe anything inside ST
04:08:32 <chpatrick> I mean from a usability standpoint
04:08:33 <merijn> You can't catch in ST, so you can't leak inconsistent state
04:08:59 <chpatrick> all of these exceptions mean you're doing something wrong though so I guess you'd never really want to catch them
04:09:01 <merijn> "It Depends™"
04:11:32 <stianhj> tsahyt: thanks
04:19:56 * hackagebot webrtc-vad 0.1.0.1 - Easy voice activity detection  https://hackage.haskell.org/package/webrtc-vad-0.1.0.1 (PatrickChilton)
04:20:19 <merijn> Style poll!
04:20:22 <lpaste_> merijn pasted “Style poll!” at http://lpaste.net/140115
04:20:33 <merijn> How would people wrap this to 80 chars?
04:20:40 <chpatrick> I would break before the <|>
04:20:45 <chpatrick> ie
04:20:47 <chpatrick> <|> foo
04:20:48 <chpatrick> <|> bar
04:21:06 <chpatrick> you could also put $ horizontalSpace on its own line to and align it
04:21:47 <chpatrick> or you could use asum [ ... ] and wrap it  like a list
04:22:03 <chpatrick> I think it should fuse to the same core
04:22:28 <merijn> I usually do the break before "<|>" but then I never know how far to indent to align nicely with the first thing
04:23:18 <pacak> :t choice
04:23:19 <lambdabot>     Not in scope: ‘choice’
04:23:19 <lambdabot>     Perhaps you meant ‘choose’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
04:23:28 <pacak> Hmmm...
04:23:36 <pacak> :t foldl1 (<|>)
04:23:37 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
04:23:39 <chpatrick> :t asum
04:23:41 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
04:24:20 <pacak> o_O
04:24:20 <pacak> nice,.
04:25:29 <pacak> But usually it's choice from attoparsec.
04:25:37 <ski> merijn : align the `$' with the `>'s (possibly also with the `=', if desired)
04:26:18 <fractalsea> merijn, thanks, I’ll look into that
04:26:45 <merijn> And entirely unrelated: Can I use patternguards in list comprehensions?
04:27:05 <chpatrick> merijn: do you need to?
04:27:13 <chpatrick> you can already let and filter
04:27:19 <chpatrick> I think it comes to the same thing
04:27:23 <tsahyt> merijn: I'd use skipMany $ choice [ ... ] and align the commas in the list with the [.
04:27:26 <merijn> chpatrick: Yes, because I wanna filter on a pattern match
04:27:36 <chpatrick> can you give an example of what you'd write?
04:27:51 <merijn> [c | c <- [minBound..maxBound], LineSeparator <- generalCategory c]
04:28:07 <merijn> hmm, I guess I can use ==
04:28:09 <chpatrick> that's just a regular comprehension :)
04:28:10 <ski> > [x | Left x <- [Left 0,Right "one",Left 2]]
04:28:12 <lambdabot>  [0,2]
04:28:25 <ski> merijn : `LineSeparator <- [generalCategory c]' ?
04:28:35 <chpatrick> actually no
04:28:35 <merijn> No
04:28:45 <chpatrick> it would be if you did [ generalCategory c ]
04:28:46 <merijn> The LineSeparator is supposed to be the pattern guard
04:28:49 <chpatrick> but I think == is simpler
04:28:56 <merijn> heh
04:29:14 <merijn> I don't understand why there's only one unicode character that is a LineSeparator
04:29:24 <merijn> And \n and \r are apparently "control" characters
04:29:41 <chpatrick> well they have an actual teletype meaning
04:29:47 <chpatrick> it's line feed and carriage return
04:29:51 <merijn> ski: The example with left only works if you don't want to indirectly match
04:30:04 <ski> merijn : hence the second suggestion
04:30:08 <chpatrick> they just happen to be line separators
04:30:18 <merijn> ski: That just makes it a nested comprehension
04:30:32 <ski> merijn : yes ?
04:30:42 <merijn> hmm, ok, apparently that would also work...
04:31:01 <merijn> Anyway...that makes it really annoying to write an "isSpace" function that doesn't match newlines...
04:32:13 <merijn> I guess I'll do "\c -> isSpace c && c /= '\n' && c /= '\r'"
04:32:30 <merijn> Wait!
04:32:39 <tsahyt> Is there such a thing as a totality checker for Haskell?
04:32:46 <merijn> :t isSpace <> (/='\n') <> (/='\r')
04:32:47 <lambdabot>     No instance for (Monoid Bool) arising from a use of ‘<>’
04:32:47 <lambdabot>     In the expression: isSpace <> (/= '\n') <> (/= '\r')
04:33:16 <merijn> ugh...
04:33:34 <ski> @type (`notElem` "\r\n")
04:33:35 <lambdabot> Char -> Bool
04:33:39 <merijn> :t All . isSpace <> All . (/='\n') <> All . (/='\r')
04:33:41 <lambdabot> Char -> All
04:43:20 <mazur> tsahyt: not sure, take a look here https://wiki.haskell.org/Catch (i know liquid haskell can do some)
04:58:18 <tsahyt> mazur: Unfortunately, the corresponding github repository states "Catch was part of my PhD. It is unmaintained, and unlikely to work."
05:00:53 <eguneys> How do I write a parser for this S :: atom | (S*)
05:01:11 <liste> tsahyt you could prove the totality ourself with coq
05:02:41 <chpatrick> eguneys: is that equivalent to some number of atoms?
05:03:17 <eguneys> atom is a parser it is either an atom or atom wrapped in parantheses
05:03:29 <chpatrick> ooh
05:03:40 <merijn> No
05:03:43 <chpatrick> wait
05:03:49 <merijn> It's an atom, or 0 or more atoms wrapped in parentheses
05:03:54 <chpatrick> it's an s expression right?
05:03:57 <eguneys> yes 
05:08:31 <eguneys> How do I write a parser for this S :: atom | (S*)
05:10:20 <frerich> eguneys: Wouldn't that just be 'many atom', i.e. matching zero or more atoms?
05:11:00 <eguneys> I want to know how can I parse something recursive 
05:13:08 <Sindriav_> atom = ident >> many atom ?
05:13:17 <frerich> eguneys: Does 'a | b' in your otation mean sequencing ('a then b') or alternatives ('a or b')?
05:13:27 <eguneys> a or b 
05:13:48 <Sindriav_> eguneys: … are you parsing S-expressions?
05:13:54 <eguneys> yes s expression
05:14:03 <eguneys> (2aklsdjf (something ) ) this
05:14:13 <Sindriav_> @where xyproblem
05:14:13 <lambdabot> I know nothing about xyproblem.
05:14:16 <Sindriav_> oh well.
05:14:26 <Sindriav_> eguneys: There's a book about writing a Scheme dialect in Haskell
05:14:40 <eguneys> send link please
05:14:53 <vinothkumar> ;
05:15:13 <Sindriav_> eguneys: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
05:15:20 <eguneys> ok thanks
05:15:24 <Sindriav_> eguneys: xyproblem.info
05:16:25 <merijn> frerich: Alternatives, looks like standard (E)BNF
05:17:11 <frerich> merijn: Ok, then the idea of 'many atom' isn't totally off (it only occurred to me that it could be sequencing as an afterthought...)
05:40:00 * hackagebot d-bus 0.1.3.1 - Permissively licensed D-Bus client library  https://hackage.haskell.org/package/d-bus-0.1.3.1 (PhilippBalzarek)
05:46:40 <ChristianS> is there an Arbitrary instance for Data.Text defined somewhere?
05:53:12 <chpatrick> @hackage quickcheck-instances
05:53:12 <lambdabot> http://hackage.haskell.org/package/quickcheck-instances
05:53:23 <chpatrick> ChristianS: google says ^
05:54:15 <ChristianS> chpatrick: ah, thanks
06:05:14 <bitonic> how can I unfold a `Rep` associated type?  I'm trying with `:kind!` with no success
06:06:07 <chpatrick> kind! should work
06:06:09 <chpatrick> what happens?
06:06:30 <chpatrick> Prelude GHC.Generics> :kind! Rep (Maybe Int)
06:06:30 <chpatrick> Rep (Maybe Int) :: * -> *
06:06:30 <chpatrick> = D1
06:06:30 <chpatrick>     GHC.Generics.D1Maybe
06:06:30 <chpatrick>     (C1 GHC.Generics.C1_0Maybe U1
06:06:30 <chpatrick>      :+: C1 GHC.Generics.C1_1Maybe (S1 NoSelector (Rec0 Int)))
06:23:29 <ah123> hey guys. I have a quick question. I'm going through the CIS 194 course and am currently on hw 7 http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures/07-folds-monoids.html. One example on there requires that we create a new type in which we derive an instance of Num like so: newType Sum a = Sum a deriving (Eq, Ord, Num, Show).  Unfortunately in doing so, I get an error that says that Num can't be derived. 
06:26:54 <chpatrick> ah123: try LANGUAGE GeneralizedNewtypeDeriving
06:28:38 <ah123> chpatrick: Thank you. That did the trick. 
06:38:40 <piping> hello
06:38:59 <clrnd> hi!
06:39:18 <piping> whats this channel for? 
06:39:36 <chpatrick1> haskell!
06:39:41 <piping> whats that haha
06:39:44 <clrnd> piping, it's for discussing and learning about haskell and derivates
06:39:48 <chpatrick1> programming language for nerds
06:40:01 <clrnd> a general purpose programming language 
06:40:02 * hackagebot webrtc-vad 0.1.0.2 - Easy voice activity detection  https://hackage.haskell.org/package/webrtc-vad-0.1.0.2 (PatrickChilton)
06:40:15 <clrnd> I'm not a nerd, hey
06:40:22 <piping> lol
06:41:24 <piping> have anyone of uall pass gcia exams?
06:41:41 <Ankhers> From the OSX dictionary. Nerd - a foolish or contemptible person who lacks social skills or is boringly studious
06:42:11 <chpatrick1> ,:)
06:42:15 <piping> wow
06:44:02 <piping> any security experts here?
06:44:46 <clrnd> I know md5
06:45:17 <mniip> rot13 is more secure I hear
06:45:34 <Ankhers> Please tell me you aren't using md5 for anything.
06:45:56 <clrnd> rot256 is far securer mate
06:45:58 <piping> should i learn haskell?
06:46:06 <liste> rot26 is where it's at
06:46:10 <CMCDragonkai> [liste] rot26 is where it's at
06:46:45 <chpatrick1> piping: yes
06:46:49 <chpatrick1> you'll be a wizard
06:47:12 <piping> ahhh okk.. 
06:47:26 <chpatrick1> no really it's awesome
06:47:34 <chpatrick1> it'll make you think better in everything else
06:48:03 <chpatrick1> and it'll ruin your programming career forever
06:48:05 <Ankhers> everything else?
06:48:12 <piping> lol
06:48:16 <Ankhers> That did happen.
06:48:22 <Ankhers> I used to love Ruby...
06:48:50 <piping> so chpatrick1  its a no?
06:49:06 <chpatrick1> it's a yes
06:49:07 <clrnd> piping, I'd say you should
06:49:09 <CMCDragonkai> [clrnd] piping, I'd say you should
06:49:15 <chpatrick1> but you'll be put off most languages
06:50:03 * hackagebot heyefi 1.0.0.0 - A server for Eye-Fi SD cards.  https://hackage.haskell.org/package/heyefi-1.0.0.0 (ryantm)
06:50:16 <piping> any tutorial page?
06:50:23 <Ankhers> @where LYAH
06:50:23 <lambdabot> http://www.learnyouahaskell.com/
06:50:33 <Ankhers> not so much a tutorial.
06:50:42 <clrnd> https://github.com/bitemyapp/learnhaskell
06:50:50 <Ankhers> You beat me to it.
06:51:08 <Ankhers> that GitHub repo may be better.
06:51:12 <piping> thanks guys
06:52:04 <RageYL> chpatrick1: i'm still new to haskell, i wanted to learn it because i wanted to 'think' differently as you stated. but for now i still can't see the beauty of the language. sure it's handy for some stuff (i love filtering and lazyness). do you have any idea about a project that can show how 'awesome' haskell is ?
06:53:06 <chpatrick1> RageYL: depends on what you're interested in
06:53:28 <RageYL> for now i don't really care, i just try to write everything that come to my mind in haskell
06:53:33 <clrnd> RageYL, I think it has to do with managing complexity for example, and correctness
06:53:41 <Ankhers> RageYL: One thing that I did was basically re-write the application I was building for work. 
06:53:54 <chpatrick1> RageYL: I'm hesitating to show this since I wrote it but I still think it's cool https://github.com/chpatrick/hchip/blob/master/HChip/Ops.hs
06:53:55 <Ankhers> Taught me a lot.
06:54:04 <nolrai66> RageYL: Something big enough that you will need to refactor it is my advice.
06:54:05 <chpatrick1> that's the instruction set of a processor in an emulator
06:54:24 <chpatrick1> it's typesafe and you can use the same table for emulation and disassembly
06:54:40 <chpatrick1> i 0x15 "RET" nullary (pop >>= jmp)
06:54:46 <chpatrick1> that's the whole implementation for the ret instruction
06:54:52 <clrnd> niceee
06:55:22 <RageYL> chpatrick1: i think you already paste this address because it is already in my todolist bookmarks :D
06:55:30 <chpatrick1> hehe
06:55:31 <RageYL> but ok i will try
06:55:46 <chpatrick1> I think the nice thing about haskell is how close code can get to the specification
06:55:48 <RageYL> thanks for your suggestion everybody
06:55:52 <chpatrick1> that op table really looks like an op table
06:56:01 <chpatrick1> if you write a monadic parser it really looks like the grammar
06:56:10 <chpatrick1> there's very little "procedural noise"
06:56:17 <clrnd> RageYL, oh yeah, I fell in love with haskell for the first time with Parsec
06:56:25 <chpatrick1> in most languages you get bogged down with how to do things
06:56:31 <RageYL> for my current newbie point of view haskell is clean: every function is small and easy to understand
06:56:32 <chpatrick1> and in haskell you can really focus on what you're trying to say
06:56:38 <clrnd> https://github.com/alvare/dson-parsec
06:56:53 <RageYL> but you have to create a gigant structure and pass it to all your function to keep a context
06:57:13 <RageYL> clrnd: almost all my project i've done so far use parsec, very handy ;)
06:57:15 <CMCDragonkai> [RageYL] clrnd: almost all my project i've done so far use parsec, very handy ;)
06:57:20 <clrnd> RageYL, not if you use State, and with lenses it get's powerful FAST
06:57:23 <chpatrick1> RageYL: in my experience you don't really need a mega context all the time
06:57:33 <clrnd> gets
06:57:38 <CMCDragonkai> [clrnd] gets
06:57:49 <chpatrick1> is that a bot? :D
06:58:09 <chpatrick1> I guess so unless he lives on AWS stret
06:58:26 <clrnd> RageYL, funcitons can be small in most languages, bot in haskell they can be correct and composable too
06:58:29 <clrnd> but*
06:58:34 <RageYL> i will continue to do some project and i think with experience i will apreciate even more the language ;)
06:59:30 <clrnd> RageYL, right now for example, I'm parsing some JSON in python and producing a value and all my error checking is with if's and returning tuples like (error, stuff) 
06:59:47 <clrnd> in haskell I'd go with Either and f'yeah!
06:59:58 <RageYL> :D
07:00:19 <clrnd> parseJSONStuff >>= lolNow >>= moreStuff
07:00:35 <Ankhers> In Go, I had to check to make sure almost every line didn't error in some way...
07:01:18 <chpatrick1> go is so disappointing
07:01:23 <clrnd> that too, the compiler will let me know when I emss up, here, to test this thing god, I have to send an SMS and see it go trough 3 different services
07:01:23 <chpatrick1> "these horse-drawn carriages are so slow"
07:01:26 <chpatrick1> "let's make a robot horse"
07:01:28 <CMCDragonkai> [chpatrick1 (guest)] "let's make a robot horse"
07:01:51 <MarcelineVQ> I think I love this robut.
07:02:02 <clrnd> the fear of refactoring is heavy in most languages
07:02:40 <Ankhers> Concurrency was really the only useful thing to me in Go.
07:02:55 <Ankhers> But the team I worked with didn't really understand concurrency properly.
07:03:07 <Ankhers> So it made it really hard to debug.
07:03:42 <ski> perhaps CMCDragonkai should be using NOTICEs ?
07:03:58 <clrnd> haskell's great for concurrency too
07:04:31 <Ankhers> clrnd: Indeed. Which is why I built a prototype in Haskell. Despite it being ~6x faster than the Go prototype, we went with Go because "it is easier to understand".
07:04:49 <chpatrick1> :(
07:04:52 <clrnd> Ankhers, that hurts
07:04:57 <Ankhers> It sure did
07:05:05 <chpatrick1> hey at least you can use go
07:05:05 <clrnd> I have a simillar anecdote, just 3x faster though
07:05:07 <Ankhers> Though, I'm still not great with Haskell.
07:05:07 <chpatrick1> android java here :D
07:05:30 <clrnd> general response was "yeah but what we have works nice"
07:05:31 <Ankhers> Which is probably why at least parts of it were not easy to understand.
07:05:44 <clrnd> (it doesn't)
07:05:56 <Ankhers> It never does.
07:06:01 <quchen> clrnd: Speed is just a small factor in the language debate. I'd happily trade speed for Haskell's refactorability. I added another value to a sum-ish type in Java two weeks ago, diffstat: +500 lines.
07:06:07 <quchen> Tests and all.
07:06:13 <Ankhers> I'm not working on a giant rails app. It is so hard to do anything.
07:06:31 <Ankhers> s/not/now
07:06:56 <MarcelineVQ> quchen: yegods
07:07:00 <clrnd> quchen, oh yeah of course! but speed is an easy argument everyone understands
07:07:47 <quchen> Money used for maintenance is surprisingly hard to count, yes :-|
07:08:04 <clrnd> I lost the debate about refactorability and correctness long ago, and just out of minority
07:08:09 <Ankhers> And often times people don't count maintenance.
07:08:26 <Ankhers> Maybe not often. But I've been in scenarios where maintenance wasn't cared about.
07:08:39 <clrnd> I live like that Ankhers, and then they complain!
07:09:29 <Ankhers> That Go project I mentioned, my manager wouldn't let me write tests. So when things inevitably broke, I would spend weeks - months searching for what happened and fix it.
07:09:49 <Ankhers> because writing tests takes too much time.
07:10:05 <echo-area> Hi.  Why do I have encode :: Binary a => a -> Data.ByteString.Lazy.Internal.ByteString, instead of Binary a => a -> Data.ByteString.Lazy.ByteString?
07:10:30 <echo-area> (after importing Data.Binary)
07:10:38 <chpatrick1> echo-area: ByteString is actually defined in Internal
07:10:45 <chpatrick1> the Data.ByteString.Lazy re-exports it
07:10:52 <quchen> Ankhers: Well, there is a point to not writing tests: short term it's certainly useful to omit them. Short term is usually 2-3 days, and then it begins to repeatedly cost you insane amounts of time.
07:11:34 <echo-area> chpatrick1: But I cannot compile `B.length $ encode "abc"`, for example
07:11:48 <echo-area> where B is Data.ByteString.Lazy
07:11:48 <chpatrick1> what does it say?
07:11:49 <quchen> So if all you care about is getting "this release" out then tests are probably not a good thing. It's scary that this exists.
07:12:05 <Ankhers> quchen: I agree. I was ~14 months into the project. I mentioned tests for stability. My manager said he would clear a week for me to write them...
07:12:32 <lpaste_> echo-area pasted “Binary” at http://lpaste.net/140118
07:12:44 <echo-area> chpatrick1: That's it
07:12:45 <quchen> I mean my natural way of developing things is writing code until I'm sufficiently happy with the design, then writing a sanity test to fix the major bumps, finish the feature, then write good tests.
07:13:05 <echo-area> Hmm
07:13:08 <echo-area> I made a mistake
07:13:10 <echo-area> Sorry
07:13:15 <quchen> The sanity test in "don't write tests" is clicking through the application a couple of times.
07:13:22 <chpatrick1> yeah B is strict  :D
07:13:43 <echo-area> I thought I imported Lazy :(
07:13:47 <MarcelineVQ> quchen: or sending a malformed input, to one of the 12 inputs
07:13:59 <nolrai66> Man, I can't remember the last time I actually wrote a big hunk of code as opposed to stabing the code in the dark with sticks.
07:14:15 <quchen> In Haskell the problem with tests is often that they're hard to write, since they're implemented in Haskell. The type system will often reject my tests because the faulty condition is not representable. :-D
07:14:42 <exio4> it is hard to write tests in haskell
07:14:49 <clrnd> yeah, I have to admit I rarely write tests in haskell
07:15:05 <quchen> It's even harder to write tests in Java. Mockmockmock oh hello static … dammit need bigger guns
07:15:08 <echo-area> chpatrick1: I also notice that the length of the encoded ByteString is 11, is it the size of the buffer?
07:15:11 <Ankhers> I thought hspec was pretty good. Admittedly, I haven't written anything big with them.
07:15:39 <exio4> it is just that what most people test is already being tested
07:16:05 <exio4> so you need to handle the actual corner cases
07:16:11 <chpatrick1> echo-area: it's the size in bytes
07:16:42 <chpatrick1> it's because the Binary instance for String prefixes the length
07:16:55 <echo-area> Oh, I see
07:17:02 <chpatrick1> how would you like to encode it?
07:17:33 <exio4> and sometimes you take the types too far and have encoded a lot of invariants on them :P
07:18:32 <clrnd> once I literally `cat /dev/urandom | theprogram`
07:18:45 <echo-area> chpatrick1: I thought it was like `\ s -> pack $ map (fromIntegral . ord) s`
07:19:01 <echo-area> I was looking for such a function
07:19:02 <quchen> It takes some practice to make good use of Haskell's types, and then some more practice to not make too good use.
07:19:03 <merijn> quchen: The term you're looking for is "smoke test(s)"
07:19:11 <quchen> merijn: I've never heard of that
07:19:15 <merijn> quchen: i.e. "turn it on and see if you see any smoke/fire"
07:19:23 <quchen> Hehe, alright
07:19:35 <merijn> "No smoke? Must be working right..."
07:20:05 <chpatrick1> echo-area: you can't decode that though
07:20:08 <quchen> It's not (not working) at least, merijn 
07:20:20 <chpatrick1> echo-area: if you just want ASCII you could use ByteString.Char8's pack
07:20:39 <chpatrick1> otherwise I would recommend using Data.Text.Encoding
07:20:41 <merijn> chpatrick1: You're making baby Jesus cry...
07:20:47 <merijn> It's Text.Encoding, btw
07:21:00 <chpatrick1> err
07:21:03 <chpatrick1> http://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Encoding.html
07:21:10 <echo-area> chpatrick1: I read from quchen's article that quoted from merijn, using Char8 is wrong
07:21:17 <chpatrick1> depends
07:21:24 <chpatrick1> if you know it's ascii it's not a big whoop
07:21:34 <merijn> chpatrick1: hmm, I was confused, it seems :)
07:22:38 <echo-area> chpatrick1: Anyway everything makes sense now.  Thank you :)
07:22:52 <chpatrick1> np
07:25:50 <quchen> If you just want ASCII you can still use Data.Text.Encoding
07:26:11 <chpatrick1> sure but it's an extra dep
07:26:25 <chpatrick1> what value does it add over BS8.pack?
07:26:38 <chpatrick1> assuming you have a String
07:26:58 <merijn> chpatrick1: Stop you from silently truncating data
07:27:45 <merijn> If you use BS8.pack I *will* find you and make you maintain spaghetti PHP code for the rest of your life...
07:28:05 <merijn> (I was gonna say stab, but that's not painful enough...)
07:28:14 <chpatrick1> wow serious business
07:28:23 <quchen> BS8 is a pretty wasteful way to deal with ASCII. We should invent BS7.
07:28:33 <chpatrick1> ok
07:28:37 <chpatrick1> assuming I have a String
07:28:38 <merijn> OverloadedStrings of BS is *barely* acceptable for dealing with string literals for ASCII protocols, anything else...
07:28:42 <chpatrick1> and I know it's ascii as a precondition
07:29:03 <chpatrick1> why should I add an extra dependency on text
07:29:09 <merijn> chpatrick1: Then don't use String >.> Why not ByteString directly
07:29:18 <chpatrick1> let's say I have a string
07:30:16 <chpatrick1> like someone sticks a gun to my head and says I have to use a string
07:30:29 <chpatrick1> or some old base library gives me a string
07:30:34 <chpatrick1> and I want an ascii bytestring
07:30:40 <minad> Hi. Can someone explain why it is bad to have an undecidable type system besides that it could loop? I am wondering why Haskell takes such a great care of it with undecidable-instances etc compared to type systems in other languages.
07:31:03 <merijn> minad: Because people prefer to now wait infinitely long for their compilation to finish :)
07:31:17 <minad> well, you can always cancel or set a max number of steps
07:31:25 <chpatrick1> I do think it's a bit weird that it's treated as the devil incarnate
07:31:33 <minad> I am specifically asking "besides that it could loop"
07:31:49 <merijn> chpatrick1: The number of times I've seen software break because "this could only be ascii" is uncountably large
07:32:02 <merijn> chpatrick1: All because someone somewhere thought "ah...what could it possibly hurt?"
07:32:17 <chpatrick1> ok so if I use text it'll give me an error and it still doesn't work if it's not ascii
07:32:23 <nshepperd> shouldn't it really be called ByteString.ASCII?
07:32:23 <chpatrick1> at least it doesn't fail silently I guess
07:32:34 <merijn> Silent failures are evil
07:32:36 <sm> chpatrick1: I think you haven't suffered enough from encoding issues yet
07:32:59 <merijn> chpatrick1: Out of curiosity, where do you live? :)
07:33:05 <chpatrick1> I'm from hungary
07:33:11 <nshepperd> map (fromIntegral . ord . assert isAscii) :: String -> [Word8]?
07:33:19 <chpatrick1> árvíztűrő tükörfúrógép
07:33:29 <merijn> chpatrick1: I'd expect you'd have run into these issues a ton of times already
07:33:45 <chpatrick1> not when I know the input is ASCII ;)
07:33:58 <chpatrick1> you still haven't said what's wrong with it when it's a precondition
07:34:21 <merijn> chpatrick1: Preconditions are brittle, people fuck up
07:34:29 <nshepperd> hmm, that's not quite how assert works, it seems
07:35:21 <nshepperd> let ensure f x = assert (f x) x in map (fromIntegral . ord . ensure isAscii)
07:35:54 <geekosaur> " All because someone somewhere thought " you assume someone thought...
07:36:04 <merijn> geekosaur: My bad :)
07:36:53 <nshepperd> well, you probably know more than 'it is ascii' because your protocol also excludes things like control codes
07:39:23 <chpatrick1> how do people feel about whether bytestring should becomes a newtype for Vector Word8
07:39:32 <chpatrick1> I think it'd be nice personally
07:40:03 <merijn> bartavelle: Turns out I didn't necessarily need to newtype my Parser. There's an Unlined newtype already in Trifecta...
07:40:05 * hackagebot log 0.3.0 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.3.0 (arybczak)
07:40:41 <sm> chpatrick1: you saw https://www.reddit.com/r/haskell/comments/3j3ypi/merging_bytestring_and_vector/ ?
07:40:59 <chpatrick1> sm: yeah that's why I was thinking about it
07:41:29 <chpatrick1> it'd be nice to have a flat array to rule them all
07:42:10 <jfischoff> is it possible to explicitly tell ghc the paths to interface files?
07:42:37 <jfischoff> so I could compile one src file with some collection of paths to the interface files it needs?
07:47:03 <echo-area> I need to go to sleep.  Good night all.
07:49:18 <Eelis> the "process <1.3" requirement in heist is giving me build problems. should i contact the heist guys to ask them to consciously review process-1.3 and make a new heist release that is compatible with it?
07:49:27 <Eelis> is that what these upper limits are for?
07:51:50 <Eelis> and is there a way to override it when invoking cabal install, to say "actually, let's assume heist /is/ compatible with process-1.3"?
07:52:31 <geekosaur> --allow-newer=process
07:52:41 <Eelis> oooh, sounds good
07:52:41 <Intolerable> if heist's test suite works w/ process 1.3, i'd just submit a pr to their github w/ an updated cabal file
07:52:56 <eguneys> why is this evaluating to ⊥ http://lpaste.net/140122
07:52:58 <Intolerable> and then use --allow-newer, yeah
07:54:43 <Eelis> Intolerable: yikes, what a hassle the heist guys want me to go through! i think i'll not respect their wishes and just use --allow-newer
07:55:30 <Eelis> geekosaur: thanks!
08:00:06 * hackagebot yi-fuzzy-open 0.1.0.1 - Fuzzy open plugin for Yi.  https://hackage.haskell.org/package/yi-fuzzy-open-0.1.0.1 (DmitryIvanov)
08:01:10 <hodapp> For generating unique names/symbols/whatever, is State the pretty standard way?
08:01:34 <hodapp> or is there some other more specific monad for doing this that's been standard for awhile and I just missed it?
08:01:43 <merijn> hodapp: Sure
08:01:51 <merijn> hodapp: Maybe an IORef if you wanna do it concurrently
08:02:14 <merijn> hodapp: Actually, I guess I wrote a transformer specifically for generating names...
08:02:23 <scshunt> Eelis: oh hey!
08:02:31 <scshunt> been a while
08:02:44 <Eelis> scshunt: sorry i always forget names, but hello biped!
08:03:04 <scshunt> Eelis: I am also known as coppro. We used to hang in ##c++ and #geordi :)
08:03:09 <Eelis> ahhh, that name i remember
08:03:28 <hodapp> merijn: no need for concurrency here
08:04:02 <ski> scshunt : oh
08:04:25 <merijn> hodapp: I wrote this some time ago for some other library, but work on that is on hiatus, so no clue if it's useful for you: https://hackage.haskell.org/package/transformers-supply
08:07:36 <hodapp> I'm also in the dubious situation where the most logical way to define something is like http://lpaste.net/4445724835682713600 (in terms of how one interprets what's inside the monad) but of course that goes against the order of the names
08:08:10 <hodapp> so I either have to find a creative way around that, or just reverse a,b,c,... and ignore it as being cosmetic
08:09:31 <nshepperd> could this be a real application for... the reverse state monad???
08:09:42 <merijn> :p
08:09:50 <Cale> hodapp: use MonadFix ;)
08:11:12 <merijn> Man, writing layout aware parsers is a pain :\
08:12:46 <hodapp> Cale: I'll have to take a look at this
08:15:07 <Cale> hodapp: Of course, that will tend to mean something different from the code which is ordered in another way. The effects happen in the order you write them still.
08:16:09 <Cale> hodapp: It's just that you're allowed to use results from the future in a circular way, as long as they're not observed immediately.
08:17:01 <Cale> hodapp: But you have to be careful, because of course it becomes easy to write infinite loops.
08:17:25 <bartavelle> merijn, ah that's good to know !
08:17:30 <bartavelle> (the Unlined type)
08:17:51 <hodapp> Cale: And in this case, it makes no difference what order the effects happen, so long as that they *do* happen - the only purpose is to establish unique names.
08:25:07 * hackagebot moesocks 0.1.2.10 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.2.10 (JinjingWang)
08:27:16 <hodapp> Cale: so, looks like you speak of RecursiveDo & mdo-notation?
08:27:33 <Cale> hodapp: yeah, and/or do-rec
08:27:51 <hodapp> Cale: looks like exactly what I need, thanks
08:31:47 <ner0x652> Hi guys!
08:31:56 <hodapp> hiya
08:32:03 <ner0x652> I'm a beginner in Haskell
08:32:22 <ner0x652> But I'm not hear o ask questions about some problem
08:32:29 <hodapp> go ahead
08:32:52 <ner0x652> I want to know if there is a good profiler for Haskell?
08:33:13 <nshepperd> profiling is in fact built into the compiler
08:33:41 <ner0x652> but what if I am interested in runtime profiling
08:33:51 <Intolerable> it's baked into the compiler
08:33:52 <chpatrick1> that's what it is
08:34:15 <Intolerable> http://book.realworldhaskell.org/read/profiling-and-optimization.html
08:34:21 <nshepperd> rruntime is what I mean, yes
08:34:30 <Intolerable> flags might be a little old, but it's a good start
08:34:45 <ner0x652> so there is no point in writing a haskell profiler
08:34:50 <ner0x652> ...
08:35:43 <Ankhers> https://github.com/bos/criterion can also be quite useful. Though, not quite what you are looking for.
08:35:44 <hodapp> I don't know about *no* point.
08:36:11 <hodapp> If you're writing one to learn, that's a plenty relevant point, albeit probably not too easy for a beginner.
08:36:34 <dolio> There are like three profilers built in, even. :)
08:36:39 <dolio> Or will be in 7.12.
08:36:56 <Ankhers> Is there an ETA for 7.12? 
08:37:10 <dolio> Dunno. Shouldn't be too much longer.
08:37:14 <hodapp> One of these days I'll have to use a profiler. For now, Haskell's run-time and compile-time performance is something I basically ignore because it's good enough and the real performance is in the C code that's generated in my build...
08:37:22 <Ankhers> 7.12 has some fixes for the record problem, right?
08:37:28 <ner0x652> can you please suggest a project that the Haskell community needs or would be great to have (for a beginner in Haskell)?
08:38:02 <dolio> If you could fix buddha to work with current GHC, that'd be great. I don't think that's a beginner project, though.
08:38:07 <Hafydd> The "for a beginner in Haskell" might be a bit of a tall order.
08:38:18 <Intolerable> how beginner are we talking?
08:38:30 <dolio> Or hat's support for buddha-like debugging.
08:38:32 <Ankhers> I think it would be better to find a problem that interests you.
08:38:59 <JuanDaugherty> beginner: hasn't read a monad tutorial yet
08:39:11 <hodapp> ner0x652: Just focus on learning the language for now, and I'm sure that along the way you'll run into things that you think need solving or improving.
08:39:33 <Hafydd> Ah, yes. We could do with a better Monad tutorial than the currently available ones.
08:39:44 <ner0x652> I followed some tutorials, (exactly wikibook https://en.wikibooks.org/wiki/Haskell)
08:39:46 <hodapp> Hafydd: You should write another.
08:39:59 <Ankhers> Hafydd: That right there, is why there are too many bad monad tutorials.
08:40:11 <hodapp> Ankhers: And it's also why I'm craving Chipotle right now.
08:41:09 <clrnd> and more yoneda tutorials?
08:41:20 <clrnd> ner0x652, https://github.com/bitemyapp/learnhaskell
08:41:22 <hodapp> yoneda?
08:41:29 <ski> more futamura projection tutorials
08:41:39 <Ankhers> I've heard the term recently. But I don't know what it is.
08:41:45 <ski> @quote enterprise.industry
08:41:45 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment. Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
08:41:53 <ski> hodapp ^
08:42:08 <hodapp> wut.
08:42:09 <clrnd> lol
08:42:17 <ner0x652> is a sentence generator program using Markov chains a difficult project? (I worked on that one in C++)
08:42:22 * hodapp goes to get a burrito
08:42:36 <clrnd> ner0x652, not at all! in haskell it should prove to be far easier also
08:42:38 <hodapp> ner0x652: I suspect not. Dissociated Press, for instance, is pretty easy to implement.
08:42:39 <Ankhers> From wikipedia - the Yoneda lemma is an abstract result on functors of the type morphisms into a fixed object.
08:42:59 * clrnd doesn't understand the yoneda lemma at all
08:43:38 * ski . o O ( <http://blog.sigfpe.com/2006/11/yoneda-lemma.html> )
08:43:52 <ner0x652> Ok, understood.
08:43:54 <Gurkenglas> clrnd, for any functor f, "forall x. (a -> x) -> f x" is isomorphic to "f a"
08:44:07 <ner0x652> Thank you guys for you time, help and support! :)
08:44:15 * Ankhers doesn't understand forall
08:44:19 <ski> ner0x652 : come back later
08:44:41 <mniip> Ankhers, it's really the same as in usual logic
08:44:42 <ner0x652> I'll stay connected, for sure there is a lot to ask and learn :) Thanks
08:44:45 <ski> Ankhers : it's the type-thing representing polymorphic values (commonly functions)
08:45:06 <Gurkenglas> Ankhers, "forall x. (a -> x) -> f x" is something that will turn any (a -> x) into an f x with the x given by the (a -> x)
08:45:11 <Ankhers> I didn't study logic either :(
08:45:22 <clrnd> Gurkenglas, ok, I can believe that (I guess it has a proof) but I don't see it's usefulness
08:45:33 <ski> clrnd : refactoring types
08:46:04 <Gurkenglas> (The proof is simple! apply id to get from left to right, apply "flip fmap" to get from right to left)
08:46:09 <clrnd> probably, I can believe the pattern is common
08:46:17 <mniip> Gurkenglas, that's not the entire proof
08:46:48 <mniip> Gurkenglas, good luck proving "($ id) . flip fmap" is identity
08:46:49 <clrnd> oh hey I got that
08:48:09 <mniip> Ankhers, for some a, there is a thing of that type, that works on all x you can come up with
08:48:11 <Gurkenglas> Yep I just noticed that that's the hard part between your last two lines, but intuitively it makes sense when one assumes "(a -> x) -> f x" can't do "structurally" different things for different x right
08:48:18 <mniip> read: it works for all x
08:48:24 <mniip> forall x
08:48:44 <mniip> forall x. (a -> x) -> f x
08:49:09 <Ankhers> In the given example, `forall. x (a -> x) -> f x', what is the difference if I just used `(a -> x) -> f x'?
08:49:30 <mniip> none
08:50:02 <mniip> just be sure to mention that a is given
08:50:23 <Ankhers> Is there ever a time (at least within Haskell) when you are required to state `forall ...'?
08:50:28 <nshepperd> I didn't understand the yoneda lemma, but now I do.
08:50:49 <Intolerable> data X = forall a. a?
08:51:31 <Ankhers> Intolerable: And what exactly does that do?
08:51:40 <Intolerable> nothing exciting
08:52:12 <nshepperd> assume you mean data X = forall a. X a
08:52:18 <Intolerable> derp, yeah
08:52:28 <nshepperd> that just puts a value in a box then forgets its type
08:52:48 <nshepperd> preeetty useless
08:53:03 <Intolerable> very useless
08:53:18 <Intolerable> but it won't even be useless without the forall.
08:53:50 <jle`> Ankhers: you need it for certain things...and the situations where you need it are called rank 2
08:54:03 <jle`> Ankhers: for example, consider this function: foo f x y = (f x, f y)
08:54:12 <jle`> or foo f = (f True, f "hello")
08:54:17 <chattered> Ankhers: If you're familiar with first-order logic, it's exactly a universal quantifier. Otherwise, you can think of forall as saying that the value takes a type as an argument. It's not actually there in the runtime, though.
08:54:38 <jle`> hm or foo f = (f [1,2,3], f [True,False]) would be a better example :)
08:55:05 <jle`> Ankhers: you might be tempted to say it's foo :: ([a] -> b) -> (b, b)
08:55:42 <jle`> Ankhers: but taht wouldn't work, because that type signature works if you give it an [Int] -> Bool, or a String -> Int
08:55:50 <chattered> Has anyone played much with bound?
08:55:52 <jle`> but neither of those are valid things to give to that function
08:55:58 <mariusmarius> does it say "Take an inhabited type; any inhabitant of the type can be put in this computation context f"
08:56:04 <jle`> because that f has to work on both [Int]s and [Bool]s
08:56:27 <jle`> Ankhers: what you'd have to write is foo :: (forall a. [a] -> b) -> (b, b)
08:56:39 <jle`> which is saying, the function it takes has to work for a list of *any* types, not just a list of one type
08:56:50 <jle`> er, not just one type of list
08:58:17 <Ankhers> jle`: Would ([a] -> b) -> (b, b) fail to compile?
08:58:40 <jle`> without the quantifier, as foo :: ([a] -> b) -> (b, b), it means that you can pass in things like sum, (ord . hard), etc.
08:59:10 <jle`> but those can't work on both [1,2,3] *and* [True, False]
08:59:48 <jle`> Ankhers: it would, because a type signature ([a] -> b) -> (b, b) can't really unify with f [1,2,3] and f [True, False]
08:59:50 <jle`> what would `a` be?
09:00:04 <jle`> `a` looks like it's supposed to be Int in one place, and Bool in another
09:00:08 * hackagebot vcache-trie 0.2.1 - patricia tries modeled above VCache  https://hackage.haskell.org/package/vcache-trie-0.2.1 (dmbarbour)
09:00:15 <jle`> so the normal type checker freaks out
09:00:56 <jle`> well...it actually freaks out for different reasons
09:01:03 <jle`> but that's one of the relevant reasons, heh
09:01:27 <Ankhers> Fair enough. I think I have a rough understanding. I think I will need to use it in order to truly understand though.
09:01:39 <Ankhers> jle`: Thanks!
09:01:46 <jle`> do you see why ([a] -> b) -> (b, b) doesn't work?
09:01:48 <jle`> no problem :)
09:03:06 <jle`> if you just had that signature, you could do things like foo sum :: (Int, Int), which would clearly not make sense when applying it to [True, False]
09:03:23 <Ankhers> Agreed.
09:04:23 <jle`> a slight diversion that might be interesting is to consider the only possible implementation of ([a] -> b) -> (b, b)
09:04:26 <jle`> heh
09:06:25 <Ankhers> foo f = \xs -> (f xs, f xs)?
09:06:26 <Intolerable> :t (,) <$> ($ []) <*> ($ [])
09:06:28 <lambdabot> ([t] -> a) -> (a, a)
09:06:49 <Intolerable> @pl (,) <$> ($ []) <*> ($ [])
09:06:49 <lambdabot> (,) <$> ($ []) <*> ($ [])
09:06:56 <Intolerable> aww i was hoping it would mangle it
09:07:14 <jle`> :t f xs -> (f xs, f xs)
09:07:15 <lambdabot> parse error on input ‘->’
09:07:19 <jle`> :t \f xs -> (f xs, f xs)
09:07:21 <lambdabot> (r -> t) -> r -> (t, t)
09:07:24 <jle`> Intolerable: it's already point free :p
09:07:38 <jle`> yeah, foo f = (f [], f []) is the only implementation
09:07:49 <Intolerable> yeah but it's not really "point free this", it's "mangle this"
09:07:57 <jle`> ha
09:07:58 <Intolerable> @pl \f xs -> (f xs, f xs)
09:07:58 <lambdabot> ap =<< ((,) .)
09:08:02 <Intolerable> hoho
09:08:08 <Intolerable> much better
09:08:15 <mariusmarius> beautiful
09:08:25 <Intolerable> @pl \f -> (f [], f [])
09:08:25 <lambdabot> liftM2 (,) ($ []) ($ [])
09:08:37 <Intolerable> not even close
09:08:37 <glguy> People who don't know better see that and they think it's how you write Haskell code and put it into actual source files
09:08:44 <Ankhers> What could the definition of `forall a. ([a] -> b) -> (b, b)' be?
09:08:52 <glguy> I hope you can live with that on your conscience
09:09:05 <jle`> Ankhers: what you wrote is basically ([a] -> b) -> (b, b)
09:09:10 <Intolerable> honestly i would actually write (,) <$> ($ []) <*> ($ [])
09:09:26 <glguy> see what I mean??
09:09:31 <jle`> Ankhers: you can think of ([a] -> b) -> (b, b) as "syntactic sugar" of sorts for forall a b. ([a] -> b) -> (b, b)
09:09:36 <Intolerable> it looks nice :)
09:09:48 <jle`> you can drop any foralls if they're just out there at the beginning and haskell will be ok
09:10:09 <pyon> What's the idiomatic way to implement lazy *effectful* computations? (That is, if you try to run them a second time, you just get a memoized result.)
09:10:10 <Ankhers> jle`: But only if all types are there, right?
09:10:21 <hodapp> hmm, Haskell does not like me trying to use StateT in a kind-polymorphic way
09:10:44 <jle`> Ankhers: i'm not totally sure, but maybe
09:10:57 <jle`> one way to find out :)
09:11:15 <clrnd> did you know, there is a strong correlation between haskell and cat eating corn?
09:11:18 <clrnd> http://www.google.com/trends/correlate/search?e=haskell&e=cat+eating+corn&t=monthly&p=us#default,20
09:11:38 <glguy> hodapp: That's probably good. The normal StateT definition isn't kind polymorphic
09:12:00 <jle`> i'm not sure how one could generalize StateT to be kind polymorphic
09:12:12 <Intolerable> im not sure why
09:12:29 <pyon> jle`: Perhaps use an existential type or GADT as the state type?
09:12:33 <pyon> No, wait.
09:12:34 <pyon> I misread.
09:12:45 * pyon missed that «kind».
09:16:02 <hodapp> glguy: Yeah... I've just tripped myself up a bit with trying to shoehorn some wtf-kinded Ivory stuff into State.
09:16:08 <hodapp> I think I figured it out.
09:22:33 <vlatkoB> Is there a tool/way to check the tests coverege of a project?
09:22:41 <Intolerable> hpc?
09:23:14 <vlatkoB> Can it show which funcs I didn't test?
09:23:54 <sgronblo> I still don't get how to work with this cabal crap, am I supposed to add a dependency to build-depends and then run cabal install --dependencies-only or what?
09:23:55 <Welkin> vlatkoB: look at tasty
09:24:30 <vlatkoB> I'll do. Thanks.
09:24:59 <Intolerable> sgronblo: you will usually get better responses if you don't start by calling what you're trying to use "this X crap"
09:26:53 <Welkin> sgronblo: cabal install --only-dependencies
09:28:39 <sgronblo> Welkin: apparently those two are synonyms
09:30:02 <sgronblo> Btw, do people mostly spike down the versions fully without using >= ?
09:30:27 <darenthis> is there a way of making Enums cyclic, so given an Enum type A | B | C, succ C -> A ?
09:30:39 <bitemyapp> sgronblo: you want to specify upper and lower bounds.
09:31:49 <Intolerable> darenthis: you just define the correct Enum instance?
09:31:53 <Ankhers> darenthis: Define succ for your Enum instance?
09:31:55 <Intolerable> and no Bounded
09:32:04 <Welkin> bitemyapp: I get lazy and don't specify any versions and instead use `cabal freeze` once I get all the dependencies resolved
09:33:08 <Welkin> darenthis: that question was asked recently and the answer is not without writing an instance manually
09:33:28 <sgronblo> so then you have to do: 1) add build-dep, 2) run cabal install --dependencies-only, 3) cabal freeze?
09:33:30 <darenthis> thanks guys
09:34:11 <Welkin> sgronblo: cabal freeze produces a cabal.config containing the exact versions of packages to install
09:34:20 <Welkin> it is what stackage is
09:34:30 <bitemyapp> Welkin: you're a bad person
09:34:35 <bitemyapp> Welkin: :P
09:34:46 <bitemyapp> Welkin: you mean for applications/executables right?
09:34:46 <Welkin> well, it produces a cabal.config with the exact versions of the packages that *are* installed currently
09:34:51 <bitemyapp> You're not pushing that into Hackage
09:35:00 <Welkin> bitemyapp: yes, for applications. I have no written any libraries yet
09:35:14 <Welkin> not*
09:37:57 <bitemyapp> Welkin: that's fine then, but you'll regret it later :)
09:38:06 <bitemyapp> well, if you need to upgrade deps.
09:38:13 <Welkin> bitemyapp: well, not for throwaway applications 
09:38:34 <vlatkoB> Welkin: Seems tasty is just a tests integrator. I have tests with hspec, just want to see which functions I tested and which I missed. Any idea?
09:40:06 <bennofs> vlatkoB: check out hpc program coverage
09:40:31 <bennofs> vlatkoB: https://wiki.haskell.org/Haskell_program_coverage
09:41:27 <vlatkoB> bennofs: I did, but not quite sure how to get the untested funcs out. I'll read it again.
09:42:08 <bitemyapp> Welkin: fair enough
09:42:12 <bennofs> vlatkoB: well, you'll run the tests with hpc enabled and then just check which functions weren't covered
09:48:58 <Intolerable> vlatkoB: cabal clean, cabal configure --enable-coverage, cabal build, cabal test
09:49:10 <Intolerable> is what i do to get hpc running 
09:49:22 <Intolerable> it dumps a nice coverage folder in your dist/hpc/ dir
09:50:00 <vlatkoB> I set -fhpc in .cabal for test-suite, run test, but got just three files in index.html (Main,some.hs and someSpec.hs). I must be missing something. 
09:50:51 <Intolerable> don't do that
09:51:00 <Intolerable> you don't need to add the -fhpc flags
09:51:35 <Intolerable> literally just run those four commands from your package directory 
09:51:58 <Intolerable> the -fhpc stuff is old, from when cabal didn't have in-built support for hpc
10:04:54 <vlatkoB> Intolerable: I followed your instructions exactly and now I have all the stuff in dist/hpc, but *.index shows only header, no files. Is there anything else to specify on command line or .cabal?
10:05:28 <Intolerable> lpaste your cabal file?
10:09:20 <darenthis> is there a way to mix Deriving with explicit instance declaration? I'd like to create an instance of Enum that inherits almost all the default methods, but override just succ and pred
10:09:31 <Intolerable> no
10:09:35 <Intolerable> unfortunately
10:09:57 <Intolerable> you can newtype it and define an almost-identical instance on the newtype
10:11:07 <darenthis> Intolerable: thanks
10:16:42 <vlatkoB> Intolerable: Think I nailed it. Deleted all files from other-modules and now the coverage is here. :-)
10:17:18 <vlatkoB> before I was testing with stack build and it suggested to add all files to other-modules
10:17:31 <Intolerable> what did you have in there?
10:17:38 <Intolerable> all your test modules?
10:19:26 <vlatkoB> yes, 'stack build' says: Warning: modules not listed in Test.cabal for 'test' component (add to other-modules): (all modules listed)
10:21:35 <Intolerable> odd
10:22:56 <vlatkoB> Yes, I did it and forgot about it. cabal wasn't complaining, and nor was stack.
10:23:00 <hodapp> w00t. RecursiveDo & mdo accomplished what I needed!
10:23:23 <vlatkoB> Intolerable: Forgot to thank you for help.
10:23:38 <Intolerable> np
10:23:56 <WeaponX> hi all, why is OverloadedStrings not working in this example? http://lpaste.net/140125
10:25:31 <aweinstock> WeaponX: probably the Monomorphism Restriction
10:25:39 <WeaponX> oh
10:26:05 <clrnd> WeaponX, yeah, it's giving it the String type when loaded
10:26:10 <aweinstock> try either {-# LANGUAGE NoMonomorphismRestriction #-}, or explicitly annotating rawJson :: IsString a => a
10:26:12 <WeaponX> so add the NoMonomorphismRestriction pragma?
10:26:16 <WeaponX> ok
10:27:14 <aweinstock> the monomorphism restriction is enabled by default to prevent a subtle performance bug (involving multiple evalution of computations that could otherwise be cached), if I understand correctly
10:28:16 <WeaponX> in which module is "IsString" defined?
10:28:24 <Intolerable> Data.String
10:28:28 <WeaponX> thanks
10:29:19 <WeaponX> nope, neither approach worked
10:29:33 <Intolerable> same issue?
10:29:49 <WeaponX> wait, I'll paste the new error message
10:30:51 <WeaponX> here: http://lpaste.net/140126
10:31:19 <Intolerable> give it an explicit signature
10:31:25 <Intolerable> decode rawJson :: Maybe Person
10:31:35 <WeaponX> ok, let me try it
10:31:55 <WeaponX> yes!!!!
10:31:58 <WeaponX> thanks
10:32:22 <Intolerable> i guess you've managed to import the aeson TH stuff without the instances
10:32:43 <Intolerable> which means that when GHCi tries to default, it can't, because it doesn't have a FromJSON () instance to default to
10:52:23 <obadz> Is there an equivalent to seq but that evaluates down to NF instead of WHNF ?
10:52:29 <Intolerable> deepseq?
10:52:38 <mauke> @hoogle deepSeq
10:52:40 <lambdabot> Control.DeepSeq module Control.DeepSeq
10:52:40 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
10:52:40 <lambdabot> package deepseq
10:53:54 <obadz> Intolerable / mauke - thx
10:55:13 <shachaf> It exists but it's not often the right answer.
11:12:42 <obadz> so ermm... why not?
11:12:53 <obadz> why is it the right thing to do for seq to stop at data constructors?
11:15:30 <S11001001> obadz: it is far more rare to require a full nf than to squash your thunks at a single position with seq
11:16:22 <S11001001> obadz: moreover, you can make deepseq with seq, but not the other way
11:28:24 <obadz> well foldl' breaks down when the accumulator is not a primitive data type
11:28:29 <obadz> which is a pretty annoying
11:28:31 <obadz> imho
11:28:54 <shachaf> deepSeq is definitely not the answer there.
11:28:58 <shachaf> It does way too much.
11:29:18 <obadz> is there answer to right `seq` this `seq` that ?
11:29:33 <obadz> or bang patterns..
11:29:34 <S11001001> obadz: it doesn't "break down", it does what you asked, and something that is more often useful.
11:30:29 <obadz> it does what I asked with an evaluation order that is often not useful as evidenced by the existence of the foldl' function..
11:31:12 <aweinstock> often not useful because foldl' exists? why not argue that strict evalution is often useless because foldr exists?
11:31:34 <obadz> strict evaluation is often useless..
11:31:35 <monochrom> what are we arguing over and why are we arguing?
11:31:50 <osa1> does anyone have any ideas on what is cabal trying to say here: "rejecting: gtk3-0.14.2 (conflict: gtk3 => gtk3==0.14.1)"
11:32:36 <obadz> monochrom: I'm not sure, but I was just wondering if there was better solution to the foldl/foldl' space leaks.. and if there isn't I was trying to internalize why.
11:32:52 <aweinstock> data StrictPair a b = StrictPair !a !b
11:33:37 <osa1> ahh it's talking about executables and stuff in the library...
11:33:40 <obadz> I was hoping for something that does not force me to redefine every data type..
11:33:47 <aweinstock> or using seq
11:34:43 <monochrom> obadz: is it foldl or is it foldl' ?
11:36:02 <obadz> monochrom: foldl' solves the problem partially
11:36:09 <aweinstock> > let average = uncurry (/) . foldl' (\(sum, len) x -> sum `seq` len `seq` (sum+x, len+1)) (0, 0) in average [1..10000]
11:36:11 <lambdabot>  5000.5
11:36:25 <aweinstock> > let average = uncurry (/) . foldl' (\(sum, len) x -> sum `seq` len `seq` (sum+x, len+1)) (0, 0) in average [1..100000]
11:36:27 <obadz> monochrom: I suppose you want to `seq` over the stuff that you apply a computation to, since that's where the thunks are piling up
11:36:29 <lambdabot>  50000.5
11:36:49 <monochrom> obadz: is it "the problem" or is it many different problems that feel "the same" to you but they should be considered different problems with different solutions?
11:38:07 <monochrom> in other words are you trying to find one size that fits all?
11:38:29 <obadz> or a general rule
11:38:35 <monochrom> in yet other words are you trying to defeat the tautology "the solution depends on the problem"?
11:38:43 <obadz> for instance, why does this stack overflows? => foldl (\(a, b) x -> a `seq` b `seq` (a + x, b + 2)) (0, 0) [1..10000000]
11:39:02 <obadz> I'm `seq`ing over all the arguments where thunks are building up
11:39:04 <monochrom> I thought you said foldl'
11:39:11 <obadz> but somehow I need to seq over the tuple too?
11:39:24 <obadz> use, foldl seqs over the tuple, but I don't understand why that's required
11:39:30 <obadz> foldl' sorry
11:40:21 <johnw> obadz: you are forcing evaluation of the tuple itself, but not its contents
11:40:27 <anohigisavay> how can i fully export a typeclass? (with its functions)?
11:40:38 <johnw> with the seq you should forcing the contents
11:40:43 <obadz> johnw: well doesn't a `seq` b `seq` .. force the evaluation of the contents?
11:40:52 <Sindriav_> anohigisavay: module Foo (Class (..) ) where …
11:41:04 <johnw> it doesn't actually force them, it merely sequences them
11:41:09 <johnw> you'd need foldl'
11:41:31 <shachaf> ?
11:41:34 <johnw> and "sequnces" isn't the right word
11:41:46 <johnw> yeah, sorry shachaf, I'm being unclear
11:41:52 <johnw> erase what I said, I'll work on this and get back to you
11:41:54 <monochrom> johnw: there may be a typo. foldl' is meant. perhaps. I am no longer sure.
11:41:58 <anohigisavay> Sindriav_: thanks. i wonder why it didn't work, and i realized i forgot (..) at import :D
11:42:17 * monochrom hates moving targets
11:42:22 <obadz> monochrom: no typo in the code
11:42:43 <obadz> I'm trying to understand why foldl (\(a, b) x -> a `seq` b `seq` (a + x, b + 2)) (0, 0) [1..10000000] leaks
11:42:49 <obadz> but the same code with foldl' doesn't
11:42:51 <dmj`> obadz: it creates an artificial dependency. Lot's of `seq`s can lead to unnecessary work being accomplished
11:42:55 <Sindriav_> anohigisavay: The .. exports everything. You can also name them individually to export only some.
11:43:01 <glguy> Because this expression isn't forced: (\(a, b) x -> a `seq` b `seq` (a + x, b + 2)) (0, 0)
11:43:01 <Gurkenglas> <obadz> foldl' sorry <- what about that?
11:43:10 <glguy> and that builds up
11:43:11 <dmj`> obadz: because you're not seq'ing the function application
11:43:18 <Gurkenglas> > foldl' (\(a, b) x -> a `seq` b `seq` (a + x, b + 2)) (0, 0) [1..10000000]
11:43:19 <obadz> Gurkenglas: it applied to the previous sentence only
11:43:22 <lambdabot>  mueval-core: Time limit exceeded
11:43:36 <ski> > foldl' (\(a,b) x -> a `seq` b `seq` (a + x, b + 2)) (0, 0) [1..1000000]
11:43:40 <lambdabot>  (500000500000,2000000)
11:43:41 <ski> > foldl (\(a,b) x -> a `seq` b `seq` (a + x, b + 2)) (0, 0) [1..1000000]
11:43:43 <dmj`> @src foldl
11:43:43 <lambdabot> foldl f z []     = z
11:43:43 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:43:43 <lambdabot>  *Exception: stack overflow
11:44:10 <monochrom> the foldl version simply builds up a huge and deep expression that contains unevaluated seqs inside.
11:44:15 <johnw> right
11:44:18 <johnw> that's what I was trying to say
11:44:25 <aweinstock> @src foldl'
11:44:25 <lambdabot> foldl' f a []     = a
11:44:25 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:44:39 <johnw> x `seq` y does not force x, it says that if y is forced, x is forced
11:44:44 <monochrom> recall that seq doesn't do anything if unevaluated.
11:44:56 <obadz> hmmm I get it
11:45:00 <monochrom> (this is not just seq. every expression doesn't do anything if unevaluated)
11:45:18 <shachaf> This sounds misleading still.
11:45:23 <ski>   foldl' f a (x:xs) = (foldl' f $! f a x) xs   -- alternate formulation
11:45:39 <obadz> actually maybe I don't get it
11:45:44 <johnw> shachaf: how would you put it?  I think you good grasp on the terminology
11:46:00 <shachaf> Well, seq is about strictness, not forcing, but that's only a small detail.
11:46:04 <shachaf> If z = (x `seq` y), then forcing z forces both x and y.
11:46:17 <lpaste_> glguy pasted “unfolding the fold” at http://lpaste.net/140127
11:46:21 <shachaf> seq x y certainly does force y
11:46:25 <shachaf> Er, x
11:46:28 <shachaf> Both of them.
11:46:48 <johnw> yes, but only if it itself is forced
11:46:56 <shachaf> Saying that it doesn't force x because it only forces x if it itself is forced is bizarre.
11:47:04 <johnw> hmm, ok
11:47:19 <johnw> could you say it's a thunk that forces x?
11:47:22 <shachaf> It's like saying that void f() { g(); } doesn't call g, because it only calls g if f itself is called
11:47:32 <johnw> ahh, good example
11:47:32 <shachaf> Nothing forces anything in a vacuum
11:47:42 <obadz> lol
11:48:40 <shachaf> "force" is a little too operational here.
11:48:44 <dmj`> shachaf: can you delineate the two for me? forcing deals with evaluation, strictness deals with order of evaluation, is that fair?
11:48:54 <monochrom> but we need to be operational here.
11:49:07 <shachaf> seq doesn't make much of an operational guarantee.
11:49:13 <obadz> so I guess we need one seq for (f z x) to be "dethunked" (that's the seq in foldl'), then other seqs to make sure that thunks don't build up in data structures returned by f
11:49:17 <shachaf> seq x y might not "force" x because it forces y first and crashes. Operationally.
11:49:27 <shachaf> But it's strict in x.
11:49:56 <monochrom> strictness deals with no order of evaluation. strictness deals with denotation only. meaning just "does it have an answer? if so, what is the answer?".  nothing on computer steps to get it.
11:50:15 <johnw> seq !_ y = y?
11:50:33 <obadz> so rule of thumb is => foldl' (\ { .. destructuring of possibly recursive data structure for parts a, b, c.. } -> a `seq` b `seq` c `seq` { ... rebuild recursive data structure as function of a, b, c... }
11:50:37 <obadz> is that right?
11:50:37 <monochrom> however, if you want to track memory use, you have to go operational. and IMO it's best to pretend that "seq" does some evaluation order for this.
11:53:13 <shachaf> If you want an operational discussion, use pseq, which has a simple operational meaning.
11:53:56 <monochrom> well yeah but foldl' doesn't use pseq. and foldl' was created to reduce memory use.
11:54:07 <shachaf> Fair enough.
11:54:20 <monochrom> at some point someone made the decision "seq is good enough"
11:54:51 <shachaf> seq is probably better. Just more complicated.
11:55:12 * ski idly wonders why obadz is talking about a (possibly) recursive data structure there
11:55:13 <obadz> monochrom: so to reduce memory use, should one just foldl' and `seq` over the parts of the data strucutre where thunks build up 
11:55:13 <shachaf> I prefer to think of seq as a sort of compiler hint rather than a function.
11:55:28 <johnw> @src seq
11:55:28 <lambdabot> Source not found. I feel much better now.
11:55:57 <monochrom> you know, my little bit of history forensic says that John Hughes thought so, and moreover, seq was originally operation, only made denotational later for a mild form of political correctness
11:56:50 <EvanR> obadz: depending on the data structure, use strict fields so thunks dont build up anyway
11:57:12 <obadz> EvanR: ok, but assuming I don't, will seqing over the parts do the trick?
11:57:49 <johnw> obadz: if you use BangPatterns, you can say: foldl' (\(!a, !b) -> ...)
11:58:03 <obadz> johnw: is that always sufficient to avoid space leaks?
11:58:12 <johnw> I'm not sure that anything is always sufficient
11:58:21 <johnw> sometimes, too much strictness will actually bite you
11:58:26 <EvanR> seq could cause leaks if used wrong
11:58:34 <obadz> EvanR: got an example?
11:58:36 <monochrom> obadz: to reduce memory use, one should understand the operational semantics, use it to find out the cause, then eliminate the cause (without changing answers, of course). one should not look for a "rule of thumb" that weasels one out of the duty to understand. therefore, I will not participate in any rule-of-thumb discussion.
11:59:39 <EvanR> and leaks is a weird thing in haskell, where its used to talk about "not as efficient as i would like"
11:59:58 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
12:00:00 <obadz> EvanR: I simply mean O(n) memory use when I'd expect constant space
12:00:18 * hackagebot postgresql-schema 0.1.4 - PostgreSQL Schema Management  https://hackage.haskell.org/package/postgresql-schema-0.1.4 (markfine)
12:00:48 <EvanR> where do you expect constant space
12:01:17 <obadz> monochrom: what you're saying is equivalent to "there are no classes of problems that can be thought of in the abstract and that each and every problem needs to be analyzed from first principle". I'm sorry but I'm not smart enough for that, I need to be able to build some abstraction..
12:01:43 <monochrom> I'm sorry too.
12:01:59 <obadz> EvanR: foldl f a l => where the NF of the accumulator a is always of the same size
12:02:05 <johnw> obadz: monochrom means that you can't find a general principle to fix your car every time it breaks; you have to understand why, and then apply the appropriate solution
12:02:49 <aweinstock> johnw: isn't understanding why a general principle?
12:03:08 <EvanR> obadz: alright, so NF is implying the accumulator even has a normal force. When it does you can use the NFData class to force full NF, which isnt what seq does
12:03:13 <johnw> there's a reason why a carpenter's toolbox has more in it than just a hammer
12:03:38 <obadz> EvanR: this conversation started when people told me that was not the right thing to do and I asked why.
12:03:51 <EvanR> because it might be less efficient
12:04:11 <EvanR> NF could be very large
12:04:34 <EvanR> in the case Int isnt not very large
12:04:44 <EvanR> its not*
12:04:47 <obadz> in the case of Int, WHNF = NF
12:04:53 <EvanR> right that too
12:05:48 <shachaf> Usually what you want to do isn't deepSeq your value, but construct it strictly in the first place.
12:06:13 <obadz> shachaf: you mean put bang patterns in the type declaration?
12:08:36 <aweinstock> obadz: yes (or seq or bangpatterns in the algorithm constructing it, if that applies)
12:08:48 <shachaf> Not necessarily.
12:09:02 <shachaf> Just construct the value strictly as you go.
12:10:28 <EvanR> you also should have an idea of when the compiler will do some of this work for you, so you dont have to
12:10:39 <EvanR> not that that is too clear to me
12:10:43 <monochrom> "rule of thumb" is not "abstraction". at least not by me.
12:11:08 <monochrom> "rule of thumb" is a bet.
12:11:18 <EvanR> lazy is a great default when its automatically elminated
12:11:26 <sm> it's a proto-abstraction. Better than nothing until you have an abstraction :)
12:11:49 <the_2nd> some ressource explaining combinators?
12:11:57 <monochrom> "abstraction" is a classification that, if I insisted on it, you could prove mathematically.
12:13:50 <bitemyapp> monochrom: how does one prove abstraction mathematically? Quantification over a set?
12:14:08 <monochrom> there are several things you have to prove.
12:14:32 <monochrom> actually, before even proving anything, you have to write down a mathematical definition of your abstraction.
12:15:03 <monochrom> (for example, writing down the axioms for monoids. that will be a definition of that abstraction called "monoid")
12:16:27 <monochrom> then one kind of things you need to prove is: every time you claim that the abstraction applies to a particular example, you could prove that the example satisfies the definition of the abstraction.
12:16:34 <aweinstock> the_2nd: "combinators" is a fancy word for things like map and foldr, common higher-order-functions
12:17:18 <EvanR> heres two more versions of "combinator" https://wiki.haskell.org/Combinator
12:17:18 <monochrom> another kind of things you need to prove is: just using the definition of the abstraction, you can solve the problem you claim it solves.
12:18:56 <xelxebar> Got a ghc error when compiling Data.Containers: ghc: internal error: evacuate: strange closure type 30052320
12:19:15 <xelxebar> Full `stack` error here: http://lpaste.net/140129
12:19:34 <obadz> shachaf: Don't understand why you mean by contruct the value strictly as you go
12:19:44 <obadz> shachaf: data MyRecord = { counter :: Int, otherCounter :: Int }
12:19:50 <obadz> shachaf: foldl' (\ (MyRecord x x') y -> x `seq` (MyRecord (x + y) x')) (MyRecord 0 0) [1..10000000]
12:19:56 <obadz> shachaf: this does not leak
12:20:05 <obadz> shachaf: would you say I've constructed the value strictly?
12:21:30 <EvanR> hmmm bang patterns seem saner
12:21:48 <EvanR> seq seems like a hack
12:22:00 <obadz> bah same thing, foldl' (\ (MyRecord !x x') y -> MyRecord (x + y) x')
12:22:22 <monochrom> here is an example. suppose someone asks: "I seem to notice  foldl op z xs = foldr op z xs  sometimes. What makes this true?"
12:23:08 <monochrom> if your answer is "foldl mappend mempty xs = foldr mappend mempty xs, if xs is a finite list", then it is not a rule of thumb, it is a theorem.
12:23:22 <monochrom> it is a theorem using abstractions.
12:23:27 <xelxebar> If it's really a ghc bug, I'd like to report it, but I'm really new to stack so not entirely sure how to sanity check as well as provide the relevant environment details.
12:24:33 <EvanR> obadz: a simple pair DS like that, you probably want strict fields in the record
12:24:44 <EvanR> pair of Int
12:25:14 <EvanR> but i wouldnt worry about it until it became a problem
12:25:46 <geekosaur> xelxebar, I think most commonly one sees that with an out of date .hi file?
12:26:11 <geekosaur> which would imply that some dependency of containers is messed up somehow
12:27:24 <xelxebar> geekosaur: This was on a global install of a package with `stack`. Noticed that I was using an older version, so currently updating.
12:27:56 <geekosaur> yes. I can't see stack being involved unless it is somehow finding a cache of .hi files not for your current ghc
12:28:16 <geekosaur> (same version but different build, and sadly this does matter :/ )
12:29:46 <xelxebar> geekosaur: I'm also on 7.10.1, I think? Should I make sure I'm compiling with 7.10.2 first?
12:30:18 <geekosaur> the error message says 7.10.2
12:30:26 <geekosaur> that would appear to be conclusive...
12:30:34 <xelxebar> Ah.
12:30:43 <xelxebar> Didn't notice that.
12:30:51 <xelxebar> So, report?
12:31:09 <geekosaur> also right at the top it says it's using (its own install of) 7.10.2
12:31:25 <geekosaur>   /home/x/.stack/programs/x86_64-linux/ghc-7.10.2/bin/runhaskell ...
12:31:37 <xelxebar> Right. Where it gives the full ghc command.
12:31:46 <geekosaur> (that's actually from the Setup.hs at the start of the process to configure it)
12:31:50 <xelxebar> Sorry. I'm being lazy cause it's 4:30 in the morning here.
12:32:09 <xelxebar> Thank you for you help
12:32:21 <geekosaur> otoh that suggests it might be stack after all, since stack should be managing its own stuff
12:32:40 <geekosaur> but I think a build with full verbose would be needed to diagnose it
12:32:45 <geekosaur> start with the stack folks, I think
12:33:28 <xelxebar> geekosaur: Thank you very much. I will migrate this over to them.
12:33:42 <geekosaur> (see, it's rather difficult to get ghc to produce that "strange closure" error in my experience; the two most likely causes are (a) memory corruption (b) bad .hi file, and the latter is FAR more common)
12:34:13 <geekosaur> (unless you're hacking on ghc's runtime and built a ghc using said hacked runtime, or whatever)
12:34:58 <xelxebar> geekosaur: That's a bit beyond what I'm doing at the moment. lol. Everything I'm running is fairly vanilla as far as I can tell.
12:35:19 * hackagebot Folly 0.2.0.0 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.2.0.0 (dillonhuff)
12:35:22 <geekosaur> yes, I figured :)
12:35:33 <geekosaur> and I don't imagine stack is experimenting with ghc's runtime behind your back :)
12:36:50 <geekosaur> there are other ways you can produce that error in end user programs / libraries, but ghc *itself* doesn't use any of them, so the possible causes are fairly limited
12:44:34 <jbalint> why can I print one but not the other ? http://pastebin.com/sW5pPxTU
12:45:00 <xelxebar> geekosaur: So this is a fairle arcane error then? Just asked over in #haskell-stack and bitemyapp advised me to go ahead and report this to the stack repo.
12:45:27 <geekosaur> pretty arcane, yes. but as I said, most likely in this case caused by a .hi file mismatch
12:45:41 <aweinstock> jbalint: Logic needs a Show instance
12:46:00 <jbalint> aweinstock: won't it instantiate m to Logic in lV5?
12:46:02 <geekosaur> which could be stack mismanaging its private compiler installs, or possibly something odd in ghc itself (the latter seems unlikely thoughj)
12:46:04 <jbalint> aweinstock: how is it shown there?
12:46:07 <aweinstock> jbalint: (ghci probably defaults the more general one to some MonadPlus that has a Show instance)
12:46:21 <monochrom> jbalint: ghci does much defaulting to type variables. it picks something for lv5's m. but I don't know which.
12:46:32 <jbalint> how can I check it...?
12:46:33 <ski> possibly `IO' ?
12:46:36 <aweinstock> what does (lv5 :: Logic Int) do?
12:46:46 <aweinstock> s/Int/Integer
12:46:57 <jbalint> No instance for (Show (Logic Integer))
12:48:24 <ski> jbalint> :t observe
12:48:40 <jbalint> observe :: Logic a -> a
12:48:52 <jbalint> yeah I'm screwing something up :X
12:48:54 <jbalint> sorry!
12:49:20 <ski> i'm not quite sure what this `Logic' is ..
12:49:27 <jbalint> Control.Monad.Logic
12:49:35 <ski> .. but i'm wondering what it is you want to accomplish with these two examples
12:49:53 <ski> (e.g., why two `return's in each ?)
12:49:58 <jbalint> ski, well nothing related to this :)
12:50:25 <jbalint> ski, I was just confused about the printing but I had two returns which was incorrect
12:50:54 <monochrom> ski has found a new way to turn people into bots
12:52:35 <ski> not really a new one
12:53:58 <ski> jbalint : confusion cleared up, then ?
12:54:45 <jbalint> ski, yes! thank you
12:54:59 <ski> ok. if you say so
12:55:05 <jbalint> now I am ready to serve as your bot
12:55:48 * ski suggests that bots are supposed to respond via NOTICEs
13:00:30 <sinelaw> hi
13:07:21 <xelxebar> geekosaur: Just to be thorough, I'm letting you know I went ahead and posted the issue over on the `stack` github tracker: https://github.com/commercialhaskell/stack/issues/906
13:07:46 <gero> Hi everyone! I'm currently having trouble installing cabal/ghc on linux following the instructions at https://www.haskell.org/downloads/linux. I hope this is the right place to ask for advice? :)
13:07:57 <xelxebar> Again, I appreciate your guidance and offering of your (quite formidable seeming) expertise.
13:08:27 <hexagoxel> gero: sure
13:08:44 <htebalaka> @hoogle Fix
13:08:46 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
13:08:46 <lambdabot> Data.Fixed module Data.Fixed
13:08:46 <lambdabot> Data.Fixed data Fixed a
13:09:03 <htebalaka> ... anyone know the most standard package that defines a Fix datatype?
13:09:31 <icicled> gero, what's the issue?
13:09:46 <EvanR> Data.Fixed is in base
13:10:38 <htebalaka> EvanR: that's for fixed precision arithmetic, not fixed points of functors (newtype Fix f = Fix (f (Fix f)))
13:10:56 <EvanR> oh
13:12:07 <htebalaka> it gets redefined a lot
13:12:37 <xcv_> style question
13:12:47 <xcv_> I have two modules, let's say Foo and Bar
13:13:18 <xcv_> both define abstract datatypes that are used internally: FooContext and BarContext
13:13:30 <gero> I tried it several ways, but currently it stops at 'cabal install alex happy', saying :'There are files missing in the ‘Cabal-1.22.4.0’ package', whiche the cabal version currently installed is: 1.20.0.3..
13:13:52 <gero> -whiche +while
13:14:00 <xcv_> I always use them qualified, so I wonder if it would be a good idea to rename them both to Context, resulting in Foo.Context and Bar.Context
13:14:05 <icicled> gero, which steps are you following?
13:14:09 <xcv_> is it a good idea or do you find it confusing?
13:14:27 <gero> https://www.haskell.org/downloads/linux Ubuntu
13:14:44 <icicled> ah ok
13:15:06 <EvanR> xcv_: nothing wrong with that but stylistically who knows what the names are
13:15:17 <EvanR> to have an opinion on
13:15:27 <lingxiao> hey ll
13:15:27 <lingxiao> hey all *
13:15:48 <xcv_> EvanR: which names?
13:15:55 <EvanR> Foo Bar Context
13:16:08 <lingxiao>  I'm looking for an "out of the box" csv parser that will parse csv data into some final algebraic datatype
13:16:11 <lingxiao> fast
13:16:18 <icicled> gero, I think that means that your cabal library version is different than the cabal executable version
13:16:34 <icicled> gero, might I suggest undoing those steps & performing the manual install
13:16:52 <xcv_> I have a toy language that I evaluate in two phases
13:16:55 <EvanR> xcv_: taken to the extreme, its kind of silly, you can always refer to the type exported by a module as MyModule.T
13:17:10 <EvanR> where the type is named T
13:17:14 <gero> icicled, thanks! How to I completly revert them? It's not my first attempt, so this might very well be caused by some relics..
13:17:38 <xcv_> those two phases are different monad transformers that use a BakerContext and an EvalContext respectively
13:18:00 <xcv_> the context is not the main export, but it's an important piece
13:18:07 <EvanR> do you need to put the word Context at all
13:18:20 <xcv_> I've found myself using Baker.BakerContext, Eval.EvalContext all over the place
13:18:26 <EvanR> Eval is a proper sounding monad
13:18:26 <xcv_> yes, because Baker and Eval are the monads
13:18:29 <icicled> gero, you can safely remove ~/.cabal & ~/.ghc
13:18:39 <xcv_> Baker contains a StateT BakerContext
13:18:41 <gero> icicled, ah, I missed... .ghc
13:19:06 <icicled> and then apt-get remove ...
13:19:10 <EvanR> if its internal to the module you can name it context or whatever is convenient
13:19:20 <EvanR> S
13:19:38 <xcv_> most use is internal, but I need to pass them around outside the module so I export them as abstract datatypes
13:19:42 <hexagoxel> gero: the error is probably caused by exactly that, i think
13:19:59 <hexagoxel> stuff in .ghc references (deleted) stuff in .cabal
13:20:15 <icicled> gero, download the ghc pre-built binaries - https://www.haskell.org/ghc/download_ghc_7_10_2#x86_64linux
13:20:21 <hexagoxel> gero: you might be able to retry the same approach after removing .ghc
13:21:37 <the_2nd> how can I have a script tag with src in blaze templates?
13:21:40 <gero> Ok, thank you icicled and hexagol, now I'm back to the start. I will give it another try!
13:22:40 <icicled> gero, if you do it manually just be sure to read all the README files :)
13:22:43 <hexagoxel> icicled: btw there is no problem with Cabal version != cabal-install version in general; am i missing something about this particular problem?
13:22:46 <icicled> they explain all the steps
13:23:32 <icicled> hexagoxel, I've seen issues in the past when those 2 are different versions
13:24:11 <geekosaur> it can happen but is fairly rare
13:24:48 <gero> icicled, Thanks for the reminder! ;) I thought I have been doing it the whole evening but ran into trouble left and right. But we'll see, I'll give it another try ;)
13:25:16 <hexagoxel> icicled: i have only seen issues when the Cabal that cabal-install was compiled with is different from the Cabal in the package db. which is different.
13:25:58 <icicled> gero, if you install ghc & cabal manually, install them as a user & not as root - this will give you a bit of flexibility & you can easily remove the software
13:27:02 <icicled> hexagoxel, that might've been what I experienced at one point...
13:28:07 <icicled> since then I've stayed away from distro provided ghc and any haskell packages
13:29:43 <ReinH> hexagoxel: There's a bug in cabal where cabal test will fail if the compiled version of Cabal is different from constraints in the package being tested.
13:30:05 <ReinH> or rather, if the constraints don't unify
13:30:22 <hexagoxel> ReinH: that's what i said, right?
13:30:52 <EvanR> lingxiao: cassava
13:30:53 <ReinH> I'm not sure.
13:32:42 <gero> Ah, it worked! Thanks :)
13:33:44 <hexagoxel> icicled: yeah that makes sense, and i have no experience with haskell on ubuntu. i just really hope that the instructions would work on a vanilla system :)
13:35:22 * hackagebot pcre-heavy 1.0.0 - A regexp library on top of pcre-light you can actually use.  https://hackage.haskell.org/package/pcre-heavy-1.0.0 (myfreeweb)
13:36:40 <geekosaur> not exactly the same thing, actually
13:41:02 <gero> Ok, now I got a new problem trying to install Leksah: https://github.com/leksah/leksah#building-on-linux: Building from Source Linux
13:43:36 <geekosaur> @paste full error / log ?
13:43:36 <lambdabot> Haskell pastebin: http://lpaste.net/
13:43:39 <geekosaur> ^ pastebin
13:44:58 <hexagoxel> ok, true, not the same thing. (but uh.. the constraints matter? which "compiled version of Cabal"?)
13:45:18 <gero> Thx, was thinking about it.
13:45:36 <linman32> is there a data structure similar to a sql based one? including indexing various columns for search.
13:45:50 <EvanR> theres ix-set
13:46:08 <EvanR> it has not much to do with sql, but has a similar use case
13:46:22 <EvanR> its a set with zero or more indexes on it
13:46:32 <geekosaur> one constraints issue is if the test section requires a newer Cabal library; things did change recently
13:46:42 <geekosaur> and Cabal library is what parses *.cabal files
13:46:58 <linman32> EvanR: thanks, will check it out
13:47:01 <gero> 'cabal install leksah' fails saying hashtables-1.2.0.2 is likely to be broken by a reinstall
13:51:39 <Welkin> how much of what is described in SPJ's 1993 paper "Imperative Functional Programming" is still true today?
13:51:42 <the_2nd> I have a function which requires a callback as parameter
13:51:58 <the_2nd> what shall I type to pass an empty callback? or an empty value?
13:52:00 <kadoban> linman32: Why not just use a database?
13:52:12 <Welkin> "The I􏰐O system sp eci􏰔ed for the Haskell language 􏰉Hudak et al􏰈 􏰗􏰂􏰃􏰃􏰄􏰘􏰊 is based on dialogues􏰀 also called lazy streams"
13:52:21 <EvanR> the_2nd: a no op?
13:52:34 <EvanR> return ()
13:53:08 <EvanR> Welkin: why did SPJ use aliens in that paper? intruiging
13:53:17 <linman32> kadoban: it is server/browser app setup. and data needs to be encrypted on server. browser decryption and search seems reasonable
13:53:38 <glguy> gero: Then you'll need to unregister hashtables and the things that depend on it in order to execute the install plan that cabal is trying for leksah
13:54:01 <jle`> the_2nd: what is the type signature of the function?
13:54:17 <linman32> kadoban: is it possible to use database on browser?
13:54:18 <glguy> gero: and likely you'll be able to reinstall hashtables afterward against the new versions of its dependencies
13:54:45 <kadoban> linman32: Are you doing ghcjs or something?
13:54:47 <Welkin> also, I find it funny that he mentions there being no way to use more than one monad at the same time
13:54:48 <the_2nd> jle`, nm I was wrong
13:54:55 <the_2nd> e.g. the function expects a string
13:54:55 <jle`> if it's a continuation-type call back, you can just use `id`, or `return` if it's monadic
13:54:58 <linman32> kadoban: Haste
13:54:59 <the_2nd> and I dont care about it
13:55:00 <Welkin> I suppose monad transformers were invented after 1993
13:55:13 <the_2nd> func a b c ("" :: String)
13:55:14 <the_2nd> ?
13:55:35 <gero> glguy: thanks! I found out about cabal sandbox, and am giving it a try 
13:55:36 <kadoban> linman32: Ah. Yeah I'm not sure if you can or not … I suspect it might not be great. I mean maybe you could do a sqlite3 database in memory? It doesn't sound great though probably.
13:55:44 <the_2nd> blaze requires the "script" to have inner html defined
13:55:49 <jle`> the_2nd: yeah, that works
13:55:54 <jle`> but also, "" should infer properly
13:56:05 <the_2nd> jle`, fails for type Html
13:56:08 <jle`> unless the function's type signature is generic over all IsString or something weird like that
13:56:10 <the_2nd> so I have
13:56:26 <the_2nd> script ! src "my_path" $ ("" :: Html)
13:56:37 <EvanR> kadoban: linman32 theres experimental in-browser databases in the works
13:56:52 <EvanR> along the lines of everything needs to be in the browser now
13:57:04 <jle`> in most contexts "" should infer properly unless the calling function is super weird, but if it doesn't then yeah, you can use the annotation too
13:57:18 <the_2nd> jle`, alright, thanks
13:57:36 <jle`> np
13:57:58 <linman32> kadoban EvanR ok thanks
13:58:03 <jle`> i wonder if i will return to blaze for my next web project
13:58:16 <jle`> i guess it's fast, so that's a big plus
13:58:39 <EvanR> see if you can avoid html for your next web project
13:59:11 <linman32> EvanR: you mean keep as much on server as possible?
13:59:29 <EvanR> no just use a saner replacemnt, and not a skin like haml
13:59:53 <jle`> a fair enough suggestion
14:00:05 <linman32> EvanR: Haste is good right?
14:00:41 <Welkin> is the IO system in Haskell still implemented as described in SPJ's paper I mentioned above?
14:01:01 <linman32> EvanR: oh, sorry. you were talking to jle` haha
14:01:35 <EvanR> Welkin: lazy streams? no
14:03:03 <jle`> i'm in way too deep with gadt's, data kinds, singletons...
14:03:13 <jle`> i hope at the end of this all i'll be able to at least write a good blog series
14:03:31 <jle`> maybe one day Extreme Type Safety will be a spectator sport
14:04:06 <EvanR> when extreme type safety attacks
14:04:08 <dmj`> jle`: I look forward to reading it :)
14:04:16 <Welkin> ~ is a data type?
14:04:18 <jle`> heh thanks
14:04:25 <arkeet> :k (~)
14:04:26 <lambdabot> k -> k -> Constraint
14:04:28 <EvanR> _ ~ _ is a constraint
14:05:23 <Welkin> https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/src/GHC-Types.html#IO
14:05:26 <Welkin> just below IO
14:05:29 <jle`> it used to be syntax, but turn on ConstraintKinds...and it becomes a normal type level function :O
14:06:08 <linman32> kadoban EvanR: is there a string based auto complete data structure?
14:06:18 <jle`> Welkin: that's using DataKinds
14:06:29 <jle`> excpt it's cheating a bit
14:06:30 <linman32> :k (->)
14:06:32 <lambdabot> * -> * -> *
14:06:42 <jle`> cause GHC does that sometimes
14:06:49 <arkeet> ghc has some special magic for (~)
14:07:03 <kadoban> linman32: Sounds vaguely like a trie, possibly?
14:07:04 <dmj`> jle`: are you messing with type level literals / lists at all
14:07:12 <jle`> yes lots of type level lists
14:07:31 <EvanR> Welkin: the low level implemetation of ~, a ~ b means a and b are the same
14:07:54 <Welkin> I don't like the explanation "it's magic/type hackery" because it tells me nothing
14:07:54 <EvanR> Eq# must be magic
14:08:04 <dmj`> jle`: nice, learning servant is opening my eyes to this stuff. I knew we could get stuff out of types via proxy, but I didn't know we could put stuff back in (value to type)
14:08:08 <bitemyapp> jle`: _please_ write that blog post :)
14:08:24 <bitemyapp> dmj`: well, the half-step to dependent types that we've got anyway :D
14:08:25 <dmj`> jle`: write it ! or else .......
14:08:30 <arkeet> Welkin: so what sort of explanation are you looking for?
14:08:32 <EvanR> Welkin: theres a definition for when two types are the same
14:08:39 <linman32> kadoban: yeah that should be good thanks
14:08:54 <jle`> bitemyapp: haha.  i intend to, once my am able to finally surface from this murk
14:08:59 <EvanR> or kinds, as the case may be
14:09:02 <jle`> every day working on this i feel like i'm swimming at the bottom of a swamp
14:09:13 <Welkin> arkeet: well, SPJ's papers are very helpful, although I know they are simplified from the actual (and especially today's) implementation
14:09:41 <jle`> maybe this is everyone's "learn haskell again from scratch a second time" experience
14:10:04 <arkeet> I'm not familiar with the actual implementation, but probably at least looking at relevant parts of ghc's source would help?
14:10:13 <arkeet> "So we define them as regular data types in GHC.Types, and do magic in TysWiredIn, inside GHC, to change the kind and type."
14:10:23 * hackagebot nats-queue 0.1.2.1 - Haskell API for NATS messaging system  https://hackage.haskell.org/package/nats-queue-0.1.2.1 (ondrap)
14:10:30 <Welkin> from what I know, many of the "magic hash" functions are ccall wrappers
14:10:44 <EvanR> Welkin: now IO is an abstract type for connecting primitive commands together, executed by the runtime
14:11:08 <EvanR> you could implement an IO yourself
14:14:00 <Welkin> EvanR: that is how it is explained in the paper
14:14:07 <EvanR> ah ok
14:14:13 <Welkin> and the subsequent paper, Lazy Functional State Threads
14:15:23 <lingxiao> EvanR thanks!
14:16:07 <dmj`> jle`: it's like monads all over again, type level monads
14:16:13 <dmj`> type level burritos
14:16:35 <jle`> :o
14:16:43 <jle`> singletons are just tacos
14:16:57 <EvanR> if values are like green sauce, types are like hot sauce, then kinds are like fire
14:17:10 <shachaf> Those jokes are not funny.
14:17:12 <Fylwind> can someone familiar with GHC's internals help me understand what 'foreign import safe' vs 'unsafe' does to the periodic RTS alarm signals?
14:17:57 <dmj`> shachaf: :)
14:18:46 <EvanR> is there at least a acme mexican food combinator lib yet
14:19:01 <EvanR> so we can just link to that instead of adlibbing
14:20:29 <Welkin> History of Haskell is my new bed-time reading material
14:20:55 <Welkin> it's like a novella
14:21:52 <shachaf> dmj`: I don't get it.
14:22:24 <dmj`> shachaf: what's wrong w/ burrito jokes
14:23:29 <kadoban> dmj`: They make me hungry, and there's few good burrito places around.
14:25:19 <dmj`> kadoban: hunger is an unintended side-effect
14:25:29 <kadoban> Haha
14:36:37 <KaneTW> dmj`: should use a better type system, duh
14:46:57 <jle`> sometimes i wish there was a way to write an a -> (exists b. blah) without making a new data type
14:47:12 <shachaf> There is.
14:47:14 <bitemyapp> @pl \j -> a j >> b j >> c j >> d j >> e j
14:47:15 <lambdabot> ap ((>>) . ap ((>>) . ap ((>>) . liftM2 (>>) a b) c) d) e
14:47:22 <bitemyapp> dammit.
14:47:27 <jle`> shachaf: oh, there is?  :O
14:47:38 <jle`> what's the syntax?
14:47:42 <shachaf> a -> (forall b. blah -> r) -> r
14:47:48 <mazur> does "datatype" have a specific meaning in type theory? or is it a loosely defined programming term?
14:48:20 <jle`> oh huh that's great
14:48:28 <bitemyapp> jle`: http://stackoverflow.com/questions/14491620/encoding-existentialquantification-with-rankntypes
14:48:29 <jle`> oh, i think they use that trick in reflections, right?
14:48:33 <bitemyapp> jle`: http://stackoverflow.com/questions/12589765/continuation-passing-style-representation-of-types
14:48:35 <shachaf> That trick is used everywhere.
14:48:46 <bitemyapp> jle`: https://hackage.haskell.org/package/exists-0.2/docs/Data-Exists-CPS.html
14:48:47 <jle`> my mind is opened
14:48:56 <shachaf> It's called currying.
14:49:08 <shachaf> (But even this specific instance of currying is used everywhere.)
14:49:17 <jle`> ty all
14:49:33 <dolio> It's not just currying.
14:49:40 <jle`> i wonder if there would be any value in bringing (exists b. ...) as syntactic sugar
14:49:56 <bitemyapp> jle`: then people would miss the relationship between forall and exists.
14:50:02 <shachaf> OK, that's true.
14:50:13 <glguy> But wait, there's more?
14:50:40 <bitemyapp> jle`: https://en.wikipedia.org/wiki/Universal_quantification#Negation
14:51:13 <bitemyapp> glguy: for the low low price of Codensity
14:51:39 <geekosaur> uhc has exists, doesn't it?
14:51:43 <geekosaur> (not that anyone uses it)
14:52:06 <shachaf> Yes.
14:52:15 <shachaf> Though not with class endowments.
14:52:17 <shachaf> Though that's OK.
14:52:38 <shachaf> ("endowment" is a word meaning "the dual of a constraint")
14:52:57 <geekosaur> that... sounds amusing
14:53:06 <geekosaur> as part of a type system
14:53:20 <jle`> ty bitemyapp 
14:53:27 <dolio> It's a significant complication to support.
14:53:48 <bitemyapp> jle`: doesn't usually stick until you kick it around.
14:53:55 <monochrom> "Completely useless existential datatypes holding evidence of no constraint on types" haha
14:59:00 <shachaf> Existential types are certainly useful without endowments.
14:59:11 <shachaf> (And endowments without existentials, too, though maybe a bit less.)
15:00:05 <shachaf> And they are more complicated. A value of an endowed type needs to be represented differently at runtime, probably.
15:00:34 <shachaf> What I don't like is when people write things like (exists a. Show a => a)
15:00:49 <shachaf> That's just nonsense.
15:02:36 <dolio> Well, it's not nonsense, it just means something else.
15:02:48 <Fylwind> how would one write endowments?
15:05:01 <dolio> *> is typical
15:06:25 <dolio> Although the > is a holdover from => being like implication, which *> isn't.
15:07:24 <shachaf> *> is directional, though.
15:07:36 <shachaf> Even though it's like a tuple.
15:08:00 <shachaf> dolio: OK, sure.
15:09:09 <monochrom> the assymetry is not so bad. you are looking at "constraint *> nonconstraint". it is assymetric to begin with.
15:09:32 <shachaf> Right, that's what I meant.
15:10:05 <shachaf> (Except is it truly a constraint?)
15:10:13 <shachaf> I suppose it has kind Constraint.
15:12:17 <dolio> Yeah, I guess that messes with your terminology.
15:16:11 <dolio> It's not 'constraint' which changes, but obligation vs. discharge.
15:18:07 <shachaf> "discharge" is suggestive terminology too.
15:20:35 <jle`> is there any way i can write '(,) a b in infix?
15:20:57 <jle`> ghc doesn't like (a ', b)...probably because (,) isn't a real operator
15:21:42 <arkeet> I'm gonna guess either '(a,b) or "no"
15:22:25 <jle`> arkeet: can confirm that that does work. thanks!
15:22:29 <arkeet> cool
15:26:53 <gorer> \list
15:31:48 <Lokathor> when a haskell project has C bindings, is "cbits" the standard directory for C files to go in?
15:32:05 <Lokathor> SDL2 and HSCurses both have such a directory
15:32:20 <verement> it seems to be a common choice
15:32:33 <emilypi> what are some fundamental haskell papers i should read?
15:34:21 <thatzissoulook> main
15:37:04 <Jello_Raptor> is there a more polymorphic version of Control.Lens's makeFields that doesn't just generate simple lenses
15:38:54 <ReinH> Jello_Raptor: what else would you want it to do?
15:39:40 <jle`> whre should I add the SingI constraint in: \(x :: Sing n) (y :: Sing m) -> (sing :: Sing (MyFamily n m)) ...?
15:39:54 <Jello_Raptor> ReinH: generate the appropriate polymorphic lenses and classes for "Foo a = { _fooVal :: a } 
15:40:25 <ReinH> But... it does do that?
15:41:01 <Jello_Raptor> nope, I just get "val :: Lens' (Foo a) a" instead of "val :: Lens (Foo a) (Foo b) a b" 
15:42:47 <ReinH> Then you must be doing something strange
15:42:59 <ReinH> The docs state that it should produce the Lens rather than the Lens' https://hackage.haskell.org/package/lens-4.12.3/docs/Control-Lens-TH.html
15:43:02 * Jello_Raptor is trying to figure out whether he can even define a useful "class hasVal s t a b | s -> a, s b -> t" 
15:43:17 <levi> Jello_Raptor: Lens' (Foo a) a is a type alias for Lens (Foo a) (Foo a) a a
15:44:33 <athan> Hey guys, what's a good way to do a natural transformation like `StateT s m a -> ReaderT s m a`?
15:44:45 <ReinH> Jello_Raptor: Maybe this is set to True? https://hackage.haskell.org/package/lens-4.12.3/docs/Control-Lens-TH.html#v:simpleLenses
15:44:52 <ReinH> Jello_Raptor: also, what version of lens?
15:45:12 <arkeet> athan: what do you mean by "do"
15:45:46 <Jello_Raptor> ReinH: ... i typed "lens >= 4.1.2" into my .cabal file instead of "lens >= 4.12" 
15:45:48 * Jello_Raptor facepalms 
15:46:12 <glguy> Jello_Raptor: Put some code on the pastebin that does something you didn't expect if you update and still need help with the template haskell generation of lenses
15:46:45 <Jello_Raptor> glguy: will do. 
15:46:57 <lord18> does anyone know a free VPN service?
15:47:31 <mac10688> What's the word for when you expect arguments to meet criteria before entering the function? Is it pre-condition?
15:47:36 <Jello_Raptor> ReinH: I'm looking at that but it looks like the structure of the "hasVal" class would have to change, which means more than just toggling the simpleLens flag. Though I honestly don't really understand template haskell yet. 
15:47:39 <athan> arkeet: Wait... hm
15:47:50 <athan> I could probably embed a reader computation in a stateful one
15:48:10 <athan> `stateWithReader :: StateT s m a -> ReaderT s m a -> StateT s m a`
15:48:26 <athan> hell idk
15:48:40 <ReinH> Jello_Raptor: what version of lens?
15:49:00 <Jello_Raptor> also the following fundep "a b -> c" means "for a unique tuple (a,b) there exists a single valid c" , no? 
15:50:25 <Jello_Raptor> ReinH: 4.12.3 now, still get the error. Working up a minimal working example. 
15:50:27 * hackagebot ifcxt 0.1.0.0 - put if statements within type constraints  https://hackage.haskell.org/package/ifcxt-0.1.0.0 (MikeIzbicki)
15:50:55 <levi> Jello_Raptor: I'm not sure why you're expecting something different than it's doing for the example you gave.
15:51:45 <levi> This could be due to a misunderstanding on my part, though.
15:53:00 <arkeet> athan: you can go StateT s m a -> ReaderT s m a by disregarding the new state
15:53:09 <arkeet> and you can go ReaderT s m a -> StateT s m a by returning an unchanged state
15:54:17 <arkeet> :t (fmap fst .) :: Monad m => (s -> m (a,s)) -> (s -> m a)
15:54:19 <lambdabot> Monad m => (s -> m (a, s)) -> s -> m a
15:54:43 <arkeet> :t (\f s -> fmap (,s) (f s)) :: Monad m => (s -> m a) -> (s -> m (a,s))
15:54:45 <lambdabot> Monad m => (s -> m a) -> s -> m (a, s)
15:55:09 <glguy> Jello_Raptor: I think that the makeFields code has always generated simple lenses
15:56:07 <Jello_Raptor> levi: ReinH: glguy: Here's the MWE and the error. Basically I want this to work :P http://lpaste.net/140134 (I'm pretty sure having "class HasVal s a | s -> a" instead of "class HasVal s t a b | s -> a, t -> b, s b -> t" is the problem)  
15:57:04 <Jello_Raptor> also are those fundeps on the second "HasVal" wrong or redundant in some way? 
15:57:18 * Jello_Raptor is still iffy on the intricacies of fundeps and TH 
15:57:25 <glguy> no, they look right
17:57:54 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
17:57:54 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
18:05:39 <i-amd3> 049182d78987y
18:10:35 * hackagebot sub-state 0.0.0.1 - Get the total, put a single element  https://hackage.haskell.org/package/sub-state-0.0.0.1 (athanclark)
19:11:19 <tmtwd> does haskell have a quote or ' like in clojure/lisp/scheme?
19:12:50 <slack1256> the quote is implicit and is everywhere
19:12:59 <slack1256> that is laziness for us
19:13:00 <ski> tmtwd : perhaps look into TH
19:13:12 <tmtwd> TH what?
19:13:17 <arkeet> template haskell
19:13:17 <ski> Template Haskell
19:13:33 <uniquenick> when I try to install servant it barfs on warp with the error: "Could not find module `Data.Hashable' It is a member of the hidden package `hashable-1.2.3.3'.  Perhaps you need to add `hashable' to the build-depends in your .cabal file"
19:13:52 <tmtwd> ah okay, will do
19:15:36 <uniquenick> that means warp heeds hashable in its deps right?
19:16:57 <arkeet> warp conditionall depends on hashable
19:16:58 <arkeet> what OS are you on?
19:17:49 <uniquenick> openbsd
19:17:54 <geekosaur> tmtwd, what are you doing that leads you to want lisp's readmacro quote?
19:20:30 <arkeet> uniquenick: hm, might be a bug in that package then??
19:21:05 <uniquenick> seems like it.  is there a way to tell cabal install to add a dep to something, or do I have to unpack it and edit the cabal file?
19:21:32 <arkeet> I think you have to edit the cabal file
19:22:24 <arkeet> I guess it blows up on Network.Wai.Handler.Warp.FdCache?
19:22:34 <arkeet> that's what imports Data.Hashable
19:22:46 <arkeet> and the .cabal file says to conditionally depend on hashable
19:22:49 <geekosaur> hashable is a dep only if it finds sendfile
19:22:49 <arkeet> if (os(linux) || os(freebsd) || os(darwin)) && flag(allow-sendfilefd)
19:22:55 <geekosaur> but the cabal file doesn't use the same check as the code
19:23:11 <arkeet> but openbsd isn't one of those, I think??
19:23:11 <geekosaur> (openbsd has sendfile)
19:23:26 <geekosaur> yes "the cabal file doesn't use the same check as the code"
19:23:30 <arkeet> yes
19:23:36 <geekosaur> the actual build found sendfile() and wants to use it
19:23:50 <geekosaur> the cabal file doesn't look for sendfile(), it has a list of OSes it knows has sendfile
19:24:19 <geekosaur> so openbsd leads to this because the cabal file didn't include hashable, but the build found sendfile() and wants to use it
19:24:43 <arkeet> well by the looks of things it wants to always use it except on windows https://github.com/yesodweb/wai/blob/master/warp/Network/Wai/Handler/Warp/FdCache.hs
19:24:51 <geekosaur> basically the cabal file has a buggy hardcoded dependency (...because cabal isn't really designed for this dep)
19:25:33 <geekosaur> hm. wonder if they chaned that recently, then, and didn't fix the cabal file to !os(windows) instead of the hardcoded positive list
19:25:50 <geekosaur> (file that as a bug against warp)
19:25:51 <arkeet> https://github.com/yesodweb/wai/commit/1c461e41909099498224d36a82284520c1c36034
19:26:04 <uniquenick> openbsd doesn't have sendfile, the code is wrong not the cabal file
19:26:12 <tmtwd> geekosaur ah just something silly -- trying to turn scheme code into haskell
19:27:19 <tmtwd> like parsing something basically
19:27:46 <srhb> tmtwd: You should probably aim for an idiomatic Haskell approach, if the goal is learning :-)
19:27:51 <geekosaur> huh, I didn't realize the nih field had penetrated that far, sigh.
19:27:51 <tmtwd> sure
19:28:33 <geekosaur> ok, file bug against warp that not all unix has sendfile
19:30:15 <uniquenick> I don't understand the nih field thing
19:32:00 <geekosaur> openbsd kernel folk don't like sendfile, from the messages I just scanned on their kernel mailing list
19:32:20 <glguy_> What's the latest GHC supported on OpenBSD?
19:32:29 <geekosaur> maybe it's more nimby than nih, there was some "we don't do performance" and some "it would uglify our pretty socket code"
19:35:44 <uniquenick> can't find anything about that, just checked and its just not there because nobody has written it
19:43:11 <glguy> There was a patch to add it back in 2007
19:43:42 <geekosaur> yep. they've had offers of code, they don't want it in their kernel
19:51:58 <fikse> i'm playing around with scotty, and trying to follow along with http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
19:53:03 <fikse> i created the .cabal file as instructed and ran `cabal sandbox init && cabal install` but i don't see the bin dir in .cabal-sandbox
19:55:34 <uniquenick> glguy: where?
19:56:21 <glguy> One of the first results when you search for openbsd sendfile, maybe on gmane
20:00:16 <parsnip> hi
20:00:28 <uniquenick> the patch that causes kernel panics?  where a developer says "I am sure very interested in having sendfile() indeed.
20:00:28 <uniquenick> "?  doesn't sound like it is being rejected because it is unwanted
20:12:57 <programo> Hi , the code compiled , but got an error which I could not figure out what.Could any body help  me with it ? http://lpaste.net/140144
20:14:36 <roboguy`> programo: you aren't giving trgenlist enough arguments. It takes 3 and you're giving it 2
20:14:40 <programo> I am sorry , I got the mistake which I have done. Sorry to post it here 
20:14:54 <programo> thanks roboguy`  :)
20:14:55 <roboguy`> programo: No problem at all!
20:20:12 <glguy> uniquenick: Could be. I opened a search on my phone, saw that there was a patch, mentioned that
20:20:41 * hackagebot ig 0.5.1 - Bindings to Instagram's API.  https://hackage.haskell.org/package/ig-0.5.1 (FelipeLessa)
20:52:49 <bz> @pl \f (a, b, c, d) -> f a b c d
20:52:49 <lambdabot> (line 1, column 11):
20:52:49 <lambdabot> unexpected "c"
20:52:49 <lambdabot> ambiguous use of a non associative operator
20:52:57 <bz> is there an uncurry for higher rarities?
20:53:10 <bz> arrities*
20:53:16 <shachaf> Not in base.
20:54:05 <fikse> `getLine >>= readFile "foo.txt" >>= putStrLn` -- Couldn't match expected type `String -> IO String' with actual type `IO String'
20:54:15 <fikse> In the return type of a call of `readFile'
20:54:50 <arkeet> what's that supposed to do?
20:56:09 <fikse> let read' = readFile "foo.txt" ==> (\str -> putStrLn str)
20:56:41 <fikse> arkeet: i was hoping it would output the file onto the screen
20:56:57 <arkeet> readFile "foo.txt" >>= putStrLn
20:57:00 <arkeet> will do that
20:57:03 <arkeet> but what's the getLine for?
20:57:05 <fikse> i meant to type >>= in the above instead of ==>
20:57:21 <arkeet> :t readFile
20:57:23 <lambdabot> FilePath -> IO String
20:57:24 <arkeet> :t putStrLn
20:57:25 <lambdabot> String -> IO ()
20:57:32 <fikse> arkeet: it's from http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
20:57:35 <arkeet> :t (>>=)
20:57:36 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:58:16 <arkeet> I see a getLine >>= readFile >>= putStrLn
20:58:19 <arkeet> this is not what you wrote.
21:03:24 <fikse> arkeet: do you know how that could actually be used?
21:04:10 <arkeet> hm?
21:04:12 <arkeet> :t getLine
21:04:13 <lambdabot> IO String
21:04:18 <arkeet> :t readFile -- note FilePath = String
21:04:19 <lambdabot> FilePath -> IO String
21:04:23 <fikse> i was thinking `let read; f = getLine >>= readFile f >>= putStrLn
21:05:03 <arkeet> :t getLine >>= readFile -- gets a line, passes it to readFile
21:05:05 <lambdabot> IO String
21:05:06 <Xnuk> getLine >>= readFile >>= putStrLn?
21:05:09 <arkeet> :t getLine >>= readFile >>= putStrLn
21:05:10 <lambdabot> IO ()
21:05:16 <fikse> let read' f = getLine >>= readFile f >>= putStrLn -- i mean this
21:05:23 <arkeet> that doesn't make sense.
21:05:30 <arkeet> when you write getLine >>= readFile
21:05:38 <arkeet> the argument to readFile is already used
21:05:41 <arkeet> as the output from getLine
21:05:51 <arkeet> you can't apply it to something else.
21:06:16 <arkeet> so again, what's it supposed to do?
21:06:39 <fikse> i guessed that `getLine >>= readFile >>= putStrLn` was supposed to read a file and output its contents to stdout
21:06:49 <arkeet> it does 3 things.
21:06:54 <arkeet> it reads a line from stdin
21:06:57 <arkeet> (that's the getLine)
21:07:12 <arkeet> passes that to readFile, so readFile reads from the filename it got from stdin
21:07:20 <arkeet> and then prints the contents
21:07:41 <arkeet> if you want to get your file name from somewhere else, don't write getLine >>= readFile
21:08:43 <arkeet> if I were to translate "getLine >>= readFile f >>= putStrLn" to do notation, it would look like this:
21:08:56 <arkeet> do { x <- getLine; y <- readFile f x; putStrLn y }
21:09:06 <arkeet> readFile f x makes no sense, because readFile can't take more than one argument.
21:09:48 <fikse> i finally figured out how to use it
21:10:05 <fikse> let read' = getLine >>= readFile >>= putStrLn
21:10:20 <fikse> execute `read'`
21:10:23 <fikse> type your filename
21:10:23 <lethjakman> what do I do if I need to unwrap multiple things in a do block, but they're not related?
21:10:42 <arkeet> lethjakman: not sure what you mean, do you have an example?
21:10:49 <lethjakman> arkeet: yeah, one moment
21:10:49 <fikse> arkeet: thanks for hanging in there with me and explaining some things along the way :)
21:12:08 <ski> fikse : `putStrLn =<< readFile =<< getLine' is an alternate way to write that ..
21:12:15 <lethjakman> arkeet: https://gist.github.com/lethjakman/047e9a19880fd7ed8df0
21:12:26 <lethjakman> I added the error in case I'm understanding incorrectly
21:13:00 <ski> (and `(putStrLn <=< readFile) =<< getLine' is yet another way. cf. `f (g x)' vs. `(f . g) x')
21:15:17 <arkeet> lethjakman: something is fixing the monad there to IO, while getYesod needs one with a MonadHandler instance
21:15:26 <arkeet> what's the type of getSESCredentials?
21:15:26 <lethjakman> arkeet: yeah
21:15:49 <arkeet> (I can't find it by searching, is it something you wrote?)
21:15:50 <lethjakman> IO SES
21:15:54 <arkeet> yeah, there you go
21:15:56 <lethjakman> arkeet: it is something I wrote
21:16:03 <Axman6> lethjakman: I told you the other day, you need to use liftIO getSESCredentials
21:16:09 <lethjakman> I figure dthat's what was causing the problem...but I need both of these things
21:16:13 <lethjakman> oh, that needs to be lifted as well?
21:16:18 <Axman6> yes
21:16:22 <arkeet> yeah, that sounds like the thing ot do
21:16:22 <lethjakman> Axman6: I lifted renderSendMail, this is a new issue
21:16:28 <arkeet> yes, you need to do both
21:16:37 <lethjakman> like this: h <- liftIO getYesod
21:16:44 <arkeet> no, probably that one is fine
21:16:45 <Axman6> you can't use IO within ReaderT <whatever it was> IO a without lifting the IO into the ReaderT
21:17:04 <Axman6> getYesod is already the right type
21:17:11 <arkeet> getYesod :: MonadHandler m => m (HandlerSite m)
21:19:42 <lethjakman> Axman6: what do you mean it's the right type?
21:20:52 <Axman6> getYesod will work within the ReaderT type you have, but you can't arbitrarilly run IO actions without lifting them into the ReaderT type
21:21:12 <lethjakman> oh
21:21:14 <lethjakman> OH
21:21:16 <lethjakman> ok
21:21:18 <lethjakman> gotcha
21:22:01 <lethjakman> sorry I'm still solidifying all of this in my head
21:22:03 <lethjakman> thank you for the help again
21:48:00 <parsnip> why the notation >>= ?
21:48:36 <slack1256> they had to choose something
21:52:06 <parsnip> seems like so much new notation in haskell
21:52:59 <chreekat> just different
21:55:42 <parsnip> are "->" called arrows? 
21:55:51 <slack1256> yep
21:56:14 <ski> it's supposed to depict an arrow, yes
21:56:35 <parsnip> what do i lookup to learn about them? 
21:56:52 <slack1256> there is not much to learn about them
21:57:02 <slack1256> the usage shows the intent
21:57:20 <slack1256> a -> b  mean a function from a to b
21:57:24 <glguy> They are "function arrows", so you can use "function" as the search term
21:57:32 <ski> `->' is used with different meaning in (a) types; (b) (lambda/function) abstraction expressions
21:57:36 <parsnip> okay, and b <- a is same? 
21:57:45 <arkeet> no
21:58:20 <arkeet> <- is used in list comprehensions and do notation
21:58:46 <parsnip> okay, thanks
21:58:53 <ski> `<-' is used in (a) list comprehensions; (b) `do'-expressions, with similar meaning. also used in (c) pattern guards (a language extension) with related meaning
21:59:11 <arkeet> (I knew I missed something.)
21:59:12 <ski> (`->' is also used in view patterns (a language extension))
22:00:02 <ski> you can ignore the extensions for now. except maybe to recall that there is some such thing
22:00:05 <parsnip> abuse of ascii notation if you ask me
22:00:52 <ski> with the unicode syntax extensions, i think you can use `→' instead, if you prefer
22:01:27 <kadoban> Forcing people to use weird character sets turns out to be problematic. Nobody wants to learn how to type weird characters just to use a language. But yeah it's an option if you really want.
22:02:19 <ski> the arrow notation in function types comes from math (category theory)
22:03:11 <kadoban> Despite it being a tiny bit overloaded, it's pretty clear in practice pretty quickly.
22:03:20 <gamegoblin> Lens question. I have two types, X { x :: Maybe Y }, and Y { y :: Int }. I have an X. I want to set its member variable to be a Just with the internal Int to a specific value. How do?
22:03:54 * ski would prefer `↦' being allowed in lambda abstractions, with unicode syntax
22:04:04 <gamegoblin> I want something like myX & x . y .~ 5
22:04:08 <gamegoblin> But the Maybe throws that off
22:04:09 <glguy> set xLens (Just (Y 1))
22:04:15 <parsnip> ski: nod
22:04:35 <parsnip> \mapsto
22:04:39 <gamegoblin> glguy: I guess imagine it was a much deeper nesting. Is there no way to avoid the explicit nature of that?
22:04:43 <parsnip> \in
22:04:52 <liste> gamegoblin throw a _Just in ?
22:05:00 <gamegoblin> liste: that might be way I want
22:05:02 <liste> :t _Just
22:05:04 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
22:05:24 <gamegoblin> liste: that worked, thanks, perfect
22:05:29 <liste> yw (:
22:05:39 <glguy> That only works when there was already a Just ther
22:05:49 <ski> > Nothing & _Just .~ 'a'
22:05:50 <lambdabot>  Nothing
22:05:52 <glguy> which isn't exactly what you asked for
22:07:44 <gamegoblin> oh
22:07:59 <gamegoblin> How can I just outright set it to Just
22:08:15 <glguy> set xLens (Just (Y 1))
22:08:59 <gamegoblin> Imagine Y is actually nested very deeply inside a structure, like 8 levels deep
22:09:10 <gamegoblin> so it seems kind of weird to do 
22:09:19 <glguy> You still have to split it into two steps
22:09:27 <glguy> you're doing two things
22:09:53 <gamegoblin> X & a . b . c . d . e . f . g .~ (Just (X & a . b . c . d . e . f . g . h .~ 5))
22:10:36 <Cale> uhhh
22:10:56 <Cale> You should be able to just use one lens, no?
22:11:15 <gamegoblin> Cale: that’s what I thought, but I don’t know lens well enough
22:11:21 <glguy> gamegoblin: your example doesn't make sense
22:11:26 <Cale> I don't understand what that example is supposed to mean
22:11:30 <Cale> yeah
22:11:36 <gamegoblin> yeah, ignore that
22:11:49 <gamegoblin> nevermind, I haven’t thought this through enough
22:12:02 <gamegoblin> just learning lens today
22:12:19 <Cale> The whole point of lenses is that you can compose many of them together to focus from a big data structure through many intermediate ones down to some tiny part of a substructure of a substructure.
22:12:21 <ski> perhaps you want to compute the `y' in `Just y' from the earlier `x' in `Just x', if any ?
22:12:59 <Cale> and when you do a set on such a lens, it replaces whatever tiny part you focused on
22:13:15 <ski> (iow, some kind of modification of the value, with a default value supplied, if none was present)
22:13:19 <glguy> You can use "non" to pretend like the Nothing was a default value
22:18:11 <parsnip> is haskell reasonable for a first language? it seems you could still learn a bit about how to look at coding in general. 
22:18:42 <parsnip> IO in general still intimidates me regardless the language. 
22:18:54 <slack1256> parsnip: It was my first language, it was Ok
22:19:25 <slack1256> I really like how I could just replace enough time and get the result by hand
22:19:35 <slack1256> *times
22:19:50 <parsnip> replace? 
22:20:22 <parsnip> oh, i'm guessing you're replacing statements with other statement. 
22:20:28 <slack1256> yep
22:20:29 <jle`> parsnip: from what i've heard, it's a good first language if you consider just the language, but there might not be as many hold-your-hand resources as for other languages
22:20:45 * hackagebot app-lens 0.1.0.1 - applicative (functional) bidirectional programming beyond composition chains  https://hackage.haskell.org/package/app-lens-0.1.0.1 (kztk)
22:20:56 <liste> is there something that turns a Prism into something like a Setter? something that would yield Nothing & ??? _Just .~ 'a' == Just 'a'
22:21:11 <arkeet> > _Just # 'a'
22:21:13 <lambdabot>  Just 'a'
22:21:32 <liste> thanks (:
22:21:51 <slack1256> is worth noting that the stream of blogpost from 2011 onwards has served me well with the hold-your-hand resources need
22:21:54 <parsnip> jle`: oh yeah, the issue of each language and it's set of resources. yeah, maybe i'll just play around with it. 
22:22:45 <parsnip> then, i'm also wondering how the libraries compare across languages, like seems that python has a lot of libraries/packges
22:22:57 <parsnip> (i'm "learning" python atm)
22:23:51 <Cale> parsnip: Also, feel free to ask lots of questions here
22:24:10 <parsnip> Cale: thank you :)
22:24:19 <jle`> i think that's like...python's killer app, if you're considering libraries and packages
22:24:29 <jle`> haskell, ruby, have a lot too
22:24:35 <slack1256> depends on the domain, but you are better off all-around with python
22:24:57 <dmj`> slack1256: wut
22:25:02 <jle`> but i think the sheer number of "learn python", "python tutorial" posts/resources are going to dwarf the number for haskell
22:25:18 <slack1256> dmj`: on package libraries ecosystem
22:25:37 <parsnip> "you can use monads for things other than IO" heh
22:25:59 <dmj`> slack1256: meh
22:26:04 <kadoban> Yes, but number isn't really that important. It would be better to have one perfect tutorial for a language than infinity crappy ones.
22:26:05 <pacak> parsnip: Monads are nice and fluffy.
22:26:11 <jle`> i think python as a language might not be harder or easier to learn than haskell (it's definitely harder to program good, maintainable python though, by a very very large margin), but it has a lot on the beginner's resources area
22:26:30 <jle`> kadoban: yeah, definitely
22:26:39 <jle`> but how can you meaningfully measure/compare in an objective way?
22:26:42 <kadoban> But the point still stands, there is better material for python than haskell I think.
22:26:49 <kadoban> Yeah, that is indeed hard.
22:26:59 <dmj`> slack1256: in the long run, maintaining a language w/o types isn't as fun as maintaining one w/ types, regardless of libs.
22:26:59 <jle`> and also, everyone learns differently...and if your learning style is esoteric, you might be more likely to find a like mind trying to learn haskell
22:27:05 <jle`> i mean, learn python
22:27:30 <slack1256> dmj`: yeah, but I am pretty convinced that sketching on a dynamic lang is easier than on a static one
22:27:34 <jle`> if all of the learning resources for haskell just aren't your style/your thing, then you have less options.  that's just the one reason i hesitate on saying haskell is the best "first language"
22:27:57 <kadoban> That's also true, there probably isn't one perfect way to learn for everyone. Hopefully there's a way that hits a large majority correctly though.
22:28:57 <jle`> i think this was one of the main complaints from one of those blog posts a few months ago about someone's experiences with haskell as a first language
22:29:18 <jle`> things like...knowing what a compiler is, navigating a command line...using a text editor
22:30:04 <jle`> but a lot of times in other languages, the "starter tutorials" will assume no knowledge
22:30:17 <ReinH> I'd rather "sketch" in a language with type inference.
22:30:26 <dmj`> slack1256: if you know the type system, type inference
22:30:31 <dmj`> ReinH: dang it, you beat me
22:30:48 <ReinH> and, you know, types
22:30:48 <jle`> yeah, i've had a lot more fun sketching in haskell than in dynamic languages.  and i get it done faster usually too
22:30:56 <ReinH> and it tends to actually work
22:31:24 <dmj`> slack1256: types are truth, 1 + "1" is acceptable until runtime in python
22:31:41 <dmj`> right?
22:31:47 <slack1256> hey, I like types as anyone else on here
22:31:55 <dmj`> well it is in js at least
22:32:07 * glguy just checked, Python passes that test
22:32:17 <dmj`> except its acceptable at runtime in js :)
22:32:33 <glguy> PHP considers that 2, though
22:32:40 <slack1256> yet I am not convinced that typing on when sketching or prototypes is better than unityped at that stage
22:32:53 <slack1256> even with type inference you don't have a clear idea of what you want
22:33:34 <Lokathor> my home version of lambdabot is unable to load the primitive package :(
22:33:48 <glguy> sadface indeed
22:33:56 <Lokathor> i think stack is to blame
22:34:12 <Lokathor> i don't have a real GHC + Cabal install, it's installed through stack, so lambdabot gets confused i bet
22:34:19 <Lokathor> no files are where they should be
22:34:29 <slack1256> so dynamism lets you be sloopier on your thinking and keep quiet until you got a more concrete idea
22:34:40 <chreekat> ...at which point it's too late :P
22:34:44 <kadoban> lambdabot has hardcoded paths in it then or something? That sounds funky.
22:34:54 <chreekat> jk, i think it's a question of individual style
22:35:02 <dmj`> glguy: python blew up for me
22:35:07 <slack1256> chreekat: definetly, but they already got you hooked then
22:35:26 <Lokathor> stack exec also might not have set the path correctly for something; stack is pretty new and i'm not sure many folks run their own lambdabot through it
22:35:54 <chreekat> for me, sketching/prototyping is equivalent to full-time refactoring, for which types are a godsend
22:36:18 <kadoban> Probably not many, but 'stack exec' should be pretty well used I'd think.
22:36:50 <Lokathor> stack works for other purposes on that machine, and some of lambdabot's features work
22:37:15 <Lokathor> send messages to "sunfirebot" if you wish to test it however
22:37:20 <chreekat> Lokathor: same problems whether or not you run lambdabot under 'stack exec'?
22:38:00 <glguy> Lokathor: If you want help with it you should paste the actual problems, possibly the error output you're seeing
22:38:16 <glguy> rather than guesses about what's wrong so that people don't have to guess themselves
22:38:19 <KrzyStar> o/
22:40:51 <lpaste_> Lokathor pasted “lambdabot error” at http://lpaste.net/140149
22:41:26 <Lokathor> i do not expect anyone can solve it from the error message given. but perhaps i'm wrong
22:41:42 <arkeet> doesn't look like the error is your fault.
22:41:45 <arkeet> ping int-e 
22:41:45 <agibiansky> Is anyone going to CUFP?
22:42:00 <arkeet> @let fibList = 1 : 2 : zipWith (+) fibList (drop 1 fibList)
22:42:01 <lambdabot>  Defined.
22:42:03 <arkeet> > take 10 fibList
22:42:05 <lambdabot>  [1,2,3,5,8,13,21,34,55,89]
22:42:09 <arkeet> oh wait.
22:42:13 <arkeet> this is *your* lambdabot.
22:42:19 <Lokathor> yes :P
22:42:26 <arkeet> no idea then.
22:42:26 <KrzyStar> I have a data sum type defined like this: A = X { (some record fields) } | Y { (record fields again) }
22:42:47 <KrzyStar> Is it possible to make X or Y a list of records without wrapping them in another constructor?
22:42:48 <Lokathor> i can recompile it using cabal instead some time, and then it will probably be more normal and work fine
22:43:21 <sinelaw> KrzyStar: what do you mean make them a list of records?
22:43:33 <KrzyStar> It would be something like this if it was allowed by syntax:
22:43:46 <KrzyStar> data A = X { (some record fields) } | [Y { (record fields again) }]
22:44:15 <liste> KrzyStar do X and Y have the same fields?
22:44:26 <KrzyStar> Nuh
22:45:06 <sinelaw> KrzyStar: what's the type of a list with a single Y in it?
22:45:30 <sinelaw> and why do you want this?
22:46:39 <ReinH> slack1256: I don't see "letting me be sloppier in my thinking" as a feature.
22:46:39 <KrzyStar> Erm, [Y] ? :p
22:46:45 <KrzyStar> I'd like to prevent introducing new constructors for that, it makes the code a lot less readable
22:47:02 <KrzyStar> But I can find another way round, just asking if there's some clean way to do that
22:47:15 <sinelaw> KrzyStar: I'm not sure what new constructors you're talking about
22:47:33 <sinelaw> if the fields of X and Y are different, you need both X and Y to tell the compiler which value you mean
22:47:54 <sinelaw> in any case the type of a single element would be A, and a list with a single element of either X or Y would be [A]
22:48:23 <sinelaw> value of type A are allowed to be either X's or Y's
22:48:26 <sinelaw> *values
22:48:30 <KrzyStar> Well I could do something like that: data X = {...}, data Y = {...}, data A = AX X | AY [Y]
22:48:31 <liste> is "data X = X {..}; data Y = Y {..}; data A = AX X | AYs [Y]" sufficient?
22:48:36 <KrzyStar> Haha
22:48:55 <sinelaw> KrzyStar: yip
22:48:55 <slack1256> ReinH: \(ºvº)/
22:49:17 <ReinH> slack1256: I'd rather not wait until runtime to learn I got the types wrong, whether prototyping or otherwise
22:49:29 <KrzyStar> Well, AX and AY make the code kinda dirty in this case
22:49:37 <KrzyStar> But I guess I can't make it cleaner then, thanks :P
22:49:56 <slack1256> if you are constantly running your program is not that bad actually
22:50:17 <slack1256> "oh, so that last change made something break"
22:50:30 <ReinH> Right, it's not so bad, but still worse than compile-time
22:51:20 <nitrix> KrzyStar: Those wouldn't be called algebraic data types otherwise.
22:51:29 <ReinH> And ofc you might not find the type error when you are developing the program. You might find it later, or your users might.
22:51:54 <nitrix> KrzyStar: The goal is precisely to combine (compose) other types into, e.g. product or sum types.
22:51:57 <jle`> hm, i wonder why my type families can't unify n ~ Min n (Plus n m)
22:51:58 <KrzyStar> nitrix: :)
22:52:10 <slack1256> I like errors at compile time because I don't control what or where the runtime will be. Yet if I am sketching/prototyping I control those
22:52:22 <slack1256> plus at runtime I can actually see the terms of the language
22:53:07 <ReinH> Besides, I use the types to guide the design of my program
22:53:13 <ReinH> so they are very useful when skething
22:54:57 <dmj`> slack1256: what do you mean the terms
22:55:14 <ski> jle` : would need induction to prove, perhaps ?
22:55:16 <slack1256> the values of the languages, as 2 is a term of Int
22:55:23 <dmj`> slack1256: ah
22:55:43 <slack1256> I can have a sort function from Ord a => [ a ] -> [ a ]
22:56:08 <slack1256> compile time won't tell me if I implemented it correctly, so still need the runtime
22:56:10 <jle`> ski: sounds plausible.  is there any way i can make GHC work with this?
22:56:47 <ski> dunno :/
22:57:12 <jle`> hm darn, i thought i had finally had it
22:58:17 <chreekat> Compile time type-checking doesn't preclude nor replace runtime experimentation, of course.
22:58:22 <ski> i suppose one could possibly manually prove `Equal n (Min n (Plus n m))' .. but possibly that defeats the point of what you're trying to do
23:00:13 <jle`> ghc seemed to magically be able to check my implementations of take :: Sing n -> Vec m a -> Vec (Min n m) a, but that's because my implementation more or less exactly matched the definiton of Min n m
23:00:24 <jle`> so, not magic
23:01:04 <sinelaw> anyone aware of a system where polymorphic rows (or sums) have a constraint that all fields (or constructors) must satisfy?
23:02:16 <jle`> time to import Unsafe.Coerce
23:03:04 <sinelaw> for example, only products where all fields are "Maybe a"
23:03:31 <ski> some kind of "map" for rows would be useful
23:04:48 <sinelaw> with polymorphic rows, I would write it as: { bar  :: Int | r (forall a. Maybe a) }
23:05:11 <sinelaw> the type of rows that have at least a bar :: Int field, plus arbitrary tail with Maybe fields
23:05:18 <glguy`> You can you GHC Generics to talk about types that are sums of products of Maybe _
23:06:47 <sinelaw> could be nice for optional arguments: call sites such as "foo 123" will infer "foo" to take a row of the type I mentioned above, so "foo" is allowed to expect an arbitrary number of optional arguments
23:06:52 <ski> i don't understand the `r (forall a. Maybe a)' part
23:07:24 <sinelaw> ski: yeah, made up notation
23:07:43 <ski> from your description, i would assume something like `{ bar :: Int | MapRow Maybe r }', rather
23:07:46 <sinelaw> ski: what I meant is a row where all fields are constrained to the type (forall a. Maybe a)
23:08:06 <ski> (iow, what does polymorphism (`forall a.') has to do with what you're talking about ?)
23:08:08 <sinelaw> what's MapRow?
23:08:22 <sinelaw> ski: the forall is there to allow fields to have different types
23:08:35 <sinelaw> it's a scheme that's supposed to match all fields
23:08:38 <ski> `MapRow' being an imaginary type function on rows
23:08:50 <sinelaw> ah
23:09:04 <ski> `MapRow :: (k0 -> k1) -> (Row k0 -> Row k1)' or somesuch
23:09:31 <ski> where `Row k' is a the kind of types (rows) where each identifier is associated with a type of kind `k'
23:09:33 <sinelaw> so the constraint on 'r' is applied in reverse
23:09:49 <slack1256> ReinH: Your last statement, I actually find it hard to rebutte it. Now I am re-asking myself what was it felt so different between elisp and haskell. But you are right, types as a design cue will hold ground
23:10:22 <sinelaw> ski: how would you check that?
23:10:32 <ski> check what ?
23:10:45 <sinelaw> given a row type r1, check that it can be un-MapRowed
23:10:59 <sinelaw> prove that r1 ~ MapRow Maybe r
23:13:36 <ski> if `r1' is `{x :: tau | r2}, then `tau' must unify with `Maybe sigma', and `r' with `{x :: sigma | r3}', where `r2' must unify with `MapRow Maybe r3'
23:14:02 <ski> (where `x' is any valid identifier in a row)
23:14:05 <sinelaw> ski: right, but would I implement that? MapRow would be something magical?
23:14:22 <ski> `MapRow' would be a type function
23:14:33 <sinelaw> that the type checker will have to know about
23:14:33 <ski> possibly magical
23:15:27 <sinelaw> i guess it's equivalent to saying it as a type-scheme based constraint, r (forall a. Maybe a)
23:15:42 <sinelaw> the type checker will still have to know about "magical row field constraints"
23:17:47 <sinelaw> except that for homogenuous rows, you will need "MapRow (Const A)" whereas the other way would be "r A"
23:20:00 <sinelaw> if all type functions have an inverse (known to type checker) then the magic isn't so bad
23:24:53 <sinelaw> apparently that's a thing: http://r.duckduckgo.com/l/?kh=-1&uddg=http%3A%2F%2Fics.p.lodz.pl%2F~stolarek%2F_media%2Fpl%3Aresearch%3Astolarek_peyton-jones_eisenberg_injectivity.pdf
23:27:12 <ski> sinelaw : `r (forall a. Maybe a)' means something completely unrelated, to me
23:27:37 <sinelaw> it looks like r has kind * -> *
23:27:55 <ski> rather `* -> Constraint'
23:28:04 <ski> er, no
23:28:11 <ski> `* -> Row'
23:28:52 <sinelaw> ski: what I mean by that notation is to place a constraint on fields
23:28:56 <ski> "if all type functions have an inverse" .. they don't, e.g. `Const c' where `type Const c _ = c'
23:29:20 <ski> sinelaw : i have no idea why you're using the polymorphism notation (`forall') to express that
23:29:48 <sinelaw> ski: to express the fact that different fields can have different types
23:29:52 <ski> do you intend that all fields of the corresponding record must be polymorphic, specifically of type `forall a. Maybe a' ?
23:29:58 <sinelaw> no
23:30:11 <sinelaw> { a : Maybe Int, b : Maybe Char } is what I mean
23:30:29 <ski> if you don't intend polymorphism, then i think it would be less confusing to use `forall', which is the type-construct corresponding to polymorphism (on the value level)
23:30:38 <sinelaw> ok
23:30:53 <ski> if you had said `\a -> Maybe a' in there, that would have been more understandable ..
23:31:26 <ski> (e.g. like `MapRow (\a -> Maybe a) r')
23:32:32 <ski> one could also consider something like `AllRow (\t -> exists a. t ~ Maybe a) r'
23:33:02 <ski> where `AllRow :: (k -> Constraint) -> (Row k -> Constraint)'
23:33:04 <ski> @type all
23:33:06 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
23:33:34 <sinelaw> You're right about injectivity of course... what we need is to know that the type is in the image of the function, not to know the actual inverse
23:34:11 <ski> so `{bar :: Int | r}' with `AllRow (\t -> exists a. t ~ Maybe a) r' as presupposition
23:34:46 <sinelaw> ski: nice
23:35:27 <ski> (i'm refraining from saying `AllRow (\t -> exists a. t ~ Maybe a) r => {bar :: Int | r}', since that's not quite what i mean)
23:35:43 <sinelaw> it isn't?
23:36:34 <ski> in `sort :: forall a. Ord a => [a] -> [a]; sort xs = ..xs..', the type of `xs' isn't `Ord a => [a]'. it is `[a]', where it is known ("by the side") that `Ord a'
23:37:24 <ski> if the type of `xs' would be `Ord a => [a]', then the type of sort would look like `sort :: (Ord a => [a]) -> ...' here, which isn't what we want
23:37:51 <sinelaw> ok
23:37:59 <ski> a value of type `Ord a => [a]' would be a value such that, if the *user* can provide an `Ord' instance for `a', *then* we've got a value of type `[a]'
23:38:42 <ski> instead, in the above `sort' case, we can say that the type of `xs' is `[a]', with `Ord a' as presupposition. meaning that we already have to assume `Ord a' here in order to get into this situation
23:40:39 <ski> do you see what i mean ?
23:41:22 <sinelaw> I think so, but would you then say that if the user can provide an 'Ord' instance for 'a' then we've got a value of type [a] -> [a] (about `sort`)?
23:42:51 <sinelaw> I mean, (Ord a => [a]) -> ... constraints the function so that it must be applied to values of a type [a] where `a` can be proved to be an `Ord` instance
23:43:06 <ski> if the user of `sort' can provide an `Ord' instance for `a', then that user has got a value of type `[a] -> [a]' (no `forall's in here, not even an implicit one), yes
23:43:11 <sinelaw> floating the constraints seems to have no effect?
23:44:01 <ski> s/floating/moving/, itym
23:44:19 <ski> ("floating" would to be suggest a (meaning-preserving) refactoring)
23:44:47 <sinelaw> because I'm not sure how the meaning if affected by moving it in/out
23:45:20 <ski> the difference is whose responsibility it is to make sure there is an instance
23:46:41 <ski> in the `sort :: forall a. Ord a => ..a..' case, it is the responsibility of the caller of `sort' to make sure there is an instance. in the case of the hypothetical `sort :: forall a. (Ord a => ..a..) -> ..a..', it is the responsibility of the callee `sort' itself) to provide the instance (while the caller still decides which type to pick for `a')
23:47:53 <Axman6> ahihi: so you are, heh =)
23:48:02 <ski> `give :: forall a r. a -> (Given a => r) -> r' at
23:48:07 <ski> @hackage reflection
23:48:07 <lambdabot> http://hackage.haskell.org/package/reflection
23:48:21 <ski> is an example of a "rank-2 constraint use"
23:50:24 <shachaf> But give is going to be deprecated or something.
23:50:26 <athan> In terms of folding, list conquers all, right? That's why Foldable has toList?
23:50:29 <sinelaw> ski: thanks
23:50:37 <shachaf> It has the same issue (and lets you do the same thing) as ImplicitParams.
23:51:07 <sinelaw> if you'd say: (forall a. Ord a => [a]) -> ... then I understand
23:52:12 <sinelaw> but I'm still not sure (from a type soundness perspective) what this means: forall a. (Ord a => [a]) -> ...
23:52:29 <ski> sinelaw : note that this is similar in spirit to `take :: forall a. a -> Given a *> ()' (imagine `give' being defined by `give a r = case take a of () => r', or alternatively `take' by `take a = give a ()')
23:53:55 <ski> a value of type `con => tau' expects the user to provide an instance for `con' before yielding a value of type `tau'
23:53:58 <ski> a value of type `con *> tau' would *provide* both an instance for `con', and a value of type `tau'
23:54:32 <shachaf> In the case of reflection, reify :: a -> (exists s. Reifies s a *> Proxy s)
23:54:54 <ski> yep
23:56:32 <ski> (Mercury can express both `exists' and `*>' in (return) types, btw ..)
23:56:52 <shachaf> In return types?
23:57:05 <sinelaw> so, from a type checking perspective, instead of being requiring constraint to be proven in order for "tau" to be valid, we say that the constraint is proven by tau?
23:59:12 <sinelaw> ski: if we have a value "foo bar" , and `bar :: con *> tau", then foo can be :: con => ...?
23:59:35 <sinelaw> the constraint 'con' being proven by 'bar's presence there?
