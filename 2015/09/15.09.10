00:07:55 <frerich> roelof: No
00:12:21 * hackagebot ansi-terminal 0.6.2.3 - Simple ANSI terminal support, with Windows compatibility  https://hackage.haskell.org/package/ansi-terminal-0.6.2.3 (RomanCheplyaka)
00:13:15 <roelof> frerich:  thanks again and wish you a good working day 
00:13:25 <frerich> roelof: Have fun!
00:15:02 <roelof> thanks, Im now trying to find out why quicktest fails where I think the function works well 
00:16:21 <nocturne777> when using aeson, do you guys usually use Generics ver TH?
00:20:46 <botter> Another question
00:20:51 <botter> How do I unbind a variable in the ghci prompt?
00:21:24 <frerich> nocturne777: I always used the TH support to generate instances for my types.
00:22:36 <nocturne777> frerich: TH seems to be faster than Generics in this case. But is it possible to make Generics as fast as TH by enabling some flags?
00:23:18 <frerich> botter: I only know about ':r' which basically reloads, but that removes all bindings...
00:23:26 <botter> ah
00:23:27 <frerich> nocturne777: No idea, sorry - I never used the Generics stuff.
00:23:29 <botter> that helps too
00:24:47 <zyla> botter: Not sure if that helps, but you can redefine a variable in ghci.
00:25:03 <zyla> without unbinding first
00:31:35 <botter> zyla: oops :( thats right
00:48:03 <Hijiri> botter: You can keep both ghci and your editor open
00:48:18 <zyla> nocturne777: why do you want to use Generics/buffer 21
00:48:22 <zyla> oops
00:48:38 <Hijiri> that's sort of what I do, except I use haskell-mode for emacs plus some other stuff to have haskell repl as an emacs window
00:48:53 <zyla> anyway, I always used TH, because it's more customizable
00:48:57 <botter> i was hoping for an ide experience 
00:49:04 <botter> but yea, this will do as well
00:49:04 <nocturne777> zyla: for aeson, it looks less boilerplate
00:49:40 <zyla> nocturne777: Looks like the same amount
00:50:17 <zyla> for Generics: instance ToJSON X
00:50:31 <zyla> TH: deriveToJSON ''X
00:51:26 <zyla> and with TH you can change field names when deriving, useful when you have name clashes
00:57:40 * hackagebot ansi-terminal 0.6.2.3 - Simple ANSI terminal support, with Windows compatibility  https://hackage.haskell.org/package/ansi-terminal-0.6.2.3 (RomanCheplyaka)
00:57:40 * hackagebot logging 3.0.0 - Simplified logging in IO for application writers.  https://hackage.haskell.org/package/logging-3.0.0 (aupiff)
01:12:23 <zipper> How can I write a function such that every time a page in the browser is reloaded the browser is updated with the new information.
01:12:33 <zipper> and not using websockets please.
01:14:40 <frerich> zipper: You could dispatch an XMLHTTPRequest
01:14:55 <frerich> zipper: E.g. via an onload JavaScript event handler.
01:16:36 <zipper> frerich: That's not very far removed from websockets.
01:16:50 <zipper> I was hoping something with maybe a hamlet file
01:18:06 <srhb> How does hamlet even relate to the issue of data transfer and "live reloading" ?
01:18:36 <frerich> zipper: Ah, I think I misunderstood your question then. So you're writing a web server (say, using Scotty) and want to serve different data for each request (even for the same URL)?
01:19:46 <zipper> frerich: Yes
01:20:29 <zipper> frerich: if you can I am familiar with yesod but any help is welcome.
01:24:37 <frerich> zipper: I'm not familiar with Yesod (I always used Scotty) but I imagine it too works by defining some routes to which you associate handlers which produce the data to be served when accessing some URL. In that handler, you could do anything, no?
01:24:51 <frerich> zipper: E.g. you could do IO (say: fetching the time of day) and yield that.
01:25:17 <frerich> zipper: If you have some existing code, I'd hope that it wouldn't be too hard to adjust it to produce dynamic (as in: different between any two requests) data.
01:57:56 <concept> hello
01:58:00 <liste> hello
01:58:08 <concept> I have a function msgToEvent :: [(B8.ByteString, B8.ByteString)] -> Maybe Event
01:58:29 <concept> and another one processCallsInQueue :: Event -> Maybe Int
01:58:46 <liste> sounds like a job for >>=
01:58:53 <concept> yup 100%
01:58:56 <concept> but
01:59:06 <concept> in order to compose them I used fmap because I am in the IO() monad
01:59:18 <concept> so what I did
01:59:35 <concept> return $ fmap processCallsInQueue event
01:59:51 <concept> how can I use >>= inside the IO monad, it didn't work so far ?
01:59:52 <liste> concept you're not in IO there
02:00:00 <liste> the thing right of return is not IO
02:00:25 <concept> yes, but I am using this inside an IO monad
02:00:38 <concept> so return should wrap the value inside IO
02:01:12 <liste> how about return (msgToEvent msg >>= processCallsInQueue) ?
02:01:36 <concept> liste : let me try it
02:03:13 <concept> liste : great it worked. I am still having problem desugaring the do notation
02:03:40 <liste> @do msgToEvent msg >>= processCallsInQueue
02:03:40 <lambdabot> do { a <- msgToEvent msg; processCallsInQueue a}
02:07:39 * hackagebot logging 3.0.1 - Simplified logging in IO for application writers.  https://hackage.haskell.org/package/logging-3.0.1 (aupiff)
02:07:44 <concept> liste: thanks
02:12:53 <liste> you're welcome (:
02:19:44 <boxmein> can/should I constrain a `data Mat4 a = [...]` to Num/Real
02:20:31 <Franciman> Hi all
02:20:37 <liste> boxmein constrain the functions (:
02:20:42 <merijn> boxmein: Can you? Not in Haskell2010, should you? No. It was such a bad idea the functionality was deleted from the language
02:20:55 <boxmein> I see :p
02:20:58 <bergmark> boxmein: putting constraints on data types is useless
02:21:01 <boxmein> liste: that's a good idea :D
02:21:19 <merijn> boxmein: Most people want that so they can avoid adding constraints on every function, but even that doesn't work since the functions *still* need constraints
02:21:19 <Franciman> I'm using trifecta parser combinators, just I don't understand what is Delta. For example I want to parse from a string, what is the Delta argument I must supply to parseString?
02:21:31 <merijn> Franciman: It's the offset in the file
02:21:34 <boxmein> sorry, I read lyah forever ago and sorta follow haskell, so I try to get into it every now and then
02:21:36 * frerich waits for merijn to kick in... ah :-)
02:21:38 <boxmein> making a row echelon calculator :P
02:21:44 <merijn> Franciman: The DeltaParsing class lets you query your file offset
02:22:19 <merijn> Franciman: https://github.com/merijn/lambda-except/blob/master/Main.hs#L22
02:23:21 <merijn> boxmein: Take a look at the Data.Set documentation for example, that has "singleton :: a -> Set a" and "insert :: Ord a => a -> Set a -> Set a", so you can really only build sets with Ord elements (except singleton sets...) due to that function :)
02:24:25 <merijn> Franciman: Text.Trifecta.Delta has things like "column :: HasDelta t => t -> Int64" that let you query the current column at the parser offset
02:25:17 <liste> @let data Mat4 a where Mat4 :: Num a => a -> Mat4 a -- boxmein you can kinda do that with GADTs
02:25:19 <lambdabot>  Defined.
02:25:52 <Franciman> merijn, so it's the position I want to start from when I parse?
02:25:55 <liste> :t f (Mat4 x) = (Mat4 2 * x)
02:25:56 <lambdabot> parse error on input ‘=’
02:26:18 <boxmein> liste: that's neat, but as this channel gives me it seems like a malpractice, so I'just constrain the functions :D
02:28:18 <merijn> Franciman: Well not the position to start from, but the position you are starting from. Consider that if you're not using parseFromFile/whatever, you probably (like me) parsing from stdin. I'm parsing a line at a time, so you may wanna say that the current line being parsed is line 8 of input
02:28:37 <merijn> Franciman: So you're telling it the start offset of the String your feeding it.
02:28:46 <Franciman> oh ok, Now I see
02:29:00 <Franciman> It's like with integrals in math
02:29:03 <Franciman> you have F + c
02:29:16 <merijn> I wish edwardk would specify the function of each field in Delta, though >.>
02:29:19 <Franciman> you have to tell him what it is c to give the correct diagnostic locations
02:29:34 <edwardk> merijn: what do you want to know about them?
02:29:44 <bezirg> hello, I am curious on what do you think is the best practice for installing cabal packages. I have my projects that I have cabal-sandbox'ed them. But I also have many Haskell-based general tools that I fetch from Hackage, like xmonad,pandoc,threadscope,etc.   All these tools I install them in user or global cabal but I find their dependencies sometimes interfere with my sandboxed projects. Where is the best place to install cabalized executables/g
02:29:51 * Franciman stops personificating things
02:30:10 <kaidelong> bezirg: at this point, I'd say a combination of "use stack" and "use git rather than cabal"
02:30:11 <edwardk> merijn: http://hackage.haskell.org/package/trifecta-1.5.1.3/docs/src/Text-Trifecta-Delta.html#Delta <- the source describes in a comment
02:30:18 <merijn> edwardk: "Directed !ByteString !Int64 !Int64 !Int64 !Int64" <- not the most helpful docs if I need to provide a starting value :)
02:30:32 <merijn> edwardk: Ah...I never checked the source, I assumed they'd be in the haddocks >.>
02:30:33 <kaidelong> stack installs stuff in ~/.local/bin
02:30:42 <kaidelong> so maybe put stuff there and put that on your path
02:30:51 <kaidelong> but
02:30:53 <edwardk> haddock can't show information on those. i could try to lift it out of line but its harder to talk about
02:30:57 <bergmark> bezirg: i use a sandbox per executable and copy them somewhere (like ~/.cabal/bin)
02:30:57 <kaidelong> cabal already uses its own bin directory
02:31:02 <bezirg> kaidelong: but what about the dependencies of these tools? they will not interfere with my projects using stack?
02:31:03 <kaidelong> so why not just put that in your path
02:31:44 <merijn> edwardk: You can have per constructor haddocks listing the fields in order, no? I'll see if I can patch it to be a little more descriptive
02:31:49 <bergmark> bezirg: with cabal (sandboxes) installing anything in the global or user package db is a bad idea
02:31:57 <kaidelong> bezirg: would you elaborate on how they interfere? If you have dependencies on tools, like harpy, you should build those in a separate sandbox, and then copy the binaries out of dist into some folder in your path
02:32:08 <kaidelong> IE, if you're using cabal, do a sandboxed build and install manually
02:32:13 <edwardk> merijn: i can document constructors but not fields IIRC
02:32:14 <kaidelong> don't rely on cabal-install
02:32:20 <merijn> I should probably write my cliff notes down and add those as a whole to trifecta
02:32:26 <bezirg> they interfere because I don't do sandbox for these general tools
02:32:28 <edwardk> go for it
02:32:34 <Franciman> merijn, by the way, thanks for your help
02:32:39 <bezirg> I use user/global ghc databases for them
02:32:42 <kaidelong> bezirg: right, you should really use sandbox for your tools
02:32:51 <kaidelong> it's a pain, but it saves pain in other places
02:32:56 <bergmark> kaidelong: why not? stack isn't so superior you can use it for anything
02:32:58 <bezirg> kaidelong: bergmark: so I use sandbox for everything in the end?
02:33:06 <kaidelong> use cabal unpack to get the sources
02:33:10 <kaidelong> set up a cabal sandbox
02:33:14 <kaidelong> do a sandboxed build
02:33:22 <kaidelong> copy the stuff out of dist to somewhere in your path
02:33:32 <bergmark> bezirg: yeah, that way you also have a place to go to upgrade the package
02:33:38 <bergmark> s/package/executable
02:33:48 <kaidelong> this is intended to be the default way cabal will work in the future AFAIK
02:33:51 <merijn> edwardk: One thing that's still a mystery is HasRendering. I'm assuming that is so I can generate my own fancy visualisations, but I don't really understand how. Where should I look in the source to find out how, say parseFromFile uses those?
02:33:53 <kaidelong> but it doesn't do that yet
02:34:00 <bezirg> I tried that, but I always forget to keep the built dir afterwards
02:34:18 <bezirg> because I remove it, packages like threadscope complain that they cannot find their data-dir
02:34:31 <kaidelong> you are going to have to put up with the pain of having to remember or you should switch to stackage so that you have no conflicts anymore
02:34:41 <bezirg> thank you people
02:34:43 <bergmark> lol
02:34:48 <bergmark> i have conflicts ALL THE TIME with stack
02:34:55 <bergmark> and they are much harder to debug
02:34:59 <bezirg> I go for now with cabal-sandbox everything and later maybe I try stack
02:35:19 <kaidelong> stack is really neat if you are working from a fresh install
02:35:27 <kaidelong> less neat if you already have haskell set up
02:36:00 <kaidelong> however stack isn't stackage
02:36:04 <kaidelong> you can use cabal + stackage
02:36:11 <kaidelong> stackage is just an alternative to hackage
02:36:14 <kadoban> kaidelong: Nuke your install then and start fresh. It took me like a day to have a cleaner setup with stack than I ever did with cabal sandbox fun.
02:37:05 <kaidelong> that is what I was suggesting, incidentally, not "switch to stack" but "you can get away with global installation with cabal more easily if you use stackage"
02:37:24 <bergmark> assuming the executables are part of a stackage distribution
02:37:44 <kadoban> That was my old setup, mostly using stackage and manually doing cabal sandboxes. It's pretty painful and tedious though.
02:38:43 <bergmark> i'm still using our old cabal-dev sandbox setup for most things, it puts all sandboxes in ~/.cabal-dev so i don't accidentally delete them if i delete a checkout
02:40:21 <fnord__> someone knows where the ghc haddocks went? when i hoogle for "+ghc getLoc" and follow the link to getLoc, I get a 404 error :(  https://www.haskell.org/hoogle/?hoogle=%2Bghc+getLoc
02:42:01 <srhb> fnord__: The docs are still there, but getLoc appears gone: http://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/GHC-SrcLoc.html
02:44:43 <fnord__> srhb: oh, i remember there was some mumbling about refactoring to allow better retranslation from AST to source code. I guess this may be related. Thanks for the link.
02:53:14 <fnord__> srhb: hmm, I'm not sure this is the problem. It fails to find also most other AST related types and modules, like HsType, HsExpr, Pat, etc.
02:55:44 <srhb> fnord__: I'm not sure either. :)
02:56:08 <fnord__> SrcLoc seems to be also included in the base package for some reason, which is where the documentation you've linked belongs to.
02:56:22 <fnord__> The link from hoogle to SrcLoc fails similarly
02:56:29 <fnord__> as the link to getLoc
02:56:37 <srhb> fnord__: I'm wondering if perhaps you should be looking at haskell-src
02:58:12 <fnord__> I'm currently working on an extension for Agda-like syntax highlighting in ghci-ng and something similar to structured haskell mode.
02:58:43 <fnord__> so I want/have to use the ghc-infrastructure
02:58:56 <zipper> I assume you guys know a little more JS than me.
02:59:01 <fnord__> haskell-src is a separate thing, if i remember correctly.
02:59:11 <zipper> Why can't the following websocket close `webSocket.onclose = function(e) {this.close(); location.reload(true);}`
02:59:50 <srhb> fnord__: OK. Sorry, I don't know enough about this to be of any help, I'm afraid.
03:00:04 <fnord__> srhb: no problem, thanks for your help anyway :)
03:04:39 <fnord__> The links from several wiki pages also yield 404: https://wiki.haskell.org/GHC/As_a_library
03:05:03 <fnord__> it seems for some reason the ghc haddocks are down or were relocated or something
03:05:40 <fnord__> The server is still up: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/
03:05:47 <fnord__> but the ghc subdirectory is no more.
03:06:01 <srhb> I think you're right.
03:07:32 <feeling> Hey guys! i have a very basic problem. i am getting started with my haskell course and installed haskell on my macbook. for trying i created a text file and wrote the following function in it: sq x = x*x . and for running the code i typed in hci in the terminal and than :load SqFile.hs (i saved it in desktop) but i get the following error : <no location info>: can't find file: SqFile.hs Failed, modules loaded: none. Prelude> 
03:08:37 <frerich> feeling: Maybe you created the source file in a different directory than the one within which you started ghci.
03:10:57 <feeling> thank you. how can i solve it? where should i save my source code? 
03:11:28 <feeling> or how do i start ghci in the directory i want?
03:11:54 <Yrarr> Well, under Linux you just cd to the dir you want
03:12:18 <liste> what's the preferred way to handle cleartext passwords in Haskell? mutable arrays?
03:12:20 <Yrarr> and then ghci loads the source from the dir you are.. but maybe the :load works a little bit differently
03:12:22 <dmwit> In ghci, you can :cd
03:12:41 <Yrarr> I always use ghci source.hs and I'm fine
03:15:22 <feeling> thank you a lot man. that solved my problem. 
03:15:35 <srhb> feeling: Also welcome to Haskell and feel free to hang around. :-)
03:16:10 <feeling> yeah, i ll be around for 3 months.for my functional programming course. thanks, have a nice day!
03:16:21 <agocorona> hi
03:16:41 <Profpatsch> Is Gtk2Hs generated automatically?
03:16:44 <liste> agocorona hello (:
03:16:56 <srhb> feeling: (Chalmers?)
03:17:30 <dmwit> Profpatsch: Not really, no.
03:17:34 <feeling> srhb: KTH
03:17:37 <srhb> feeling: Ah :)
03:17:44 <srhb> feeling: Well, good luck and have fun :)
03:17:50 <Profpatsch> dmwit: Mostly manual bindings?
03:17:50 <feeling> thank you :)
03:17:56 <Profpatsch> I found this https://github.com/gtk2hs/gtk2hs/blob/master/tools/callbackGen/HookGenerator.hs
03:18:49 <Profpatsch> dmwit: Because if I wanted to bind to a new widget (http://darcs.nomeata.de/screen-message/gtkzoom.h), how would I do it?
03:18:56 <Profpatsch> Mirror the Gtk bindings?
03:19:40 <Profpatsch> e.g. https://github.com/gtk2hs/gtk2hs/blob/master/gtk/Graphics/UI/Gtk/Buttons/Button.chs ?
03:20:06 <Profpatsch> dmwit: But this looks auto-generated: https://github.com/gtk2hs/gtk2hs/blob/master/gtk/Graphics/UI/Gtk/Buttons/CheckButton.chs#L37
03:20:12 <dmwit> I don't remember much of the details. If you've been looking into the source, you probably already know more than me about binding a new widget.
03:20:39 <dmwit> I believe the class hierarchy is generated, yes.
03:21:06 <Profpatsch> oh lol,  {# call unsafe check_button_new_with_label #}
03:21:15 <Profpatsch> Now I know how these bindings work internally.
03:21:39 <Profpatsch> So basically everything around that is not safe anymore.
03:21:56 <dmwit> That unsafe is probably not the unsafe you think it is.
03:22:13 <dmwit> It's the FFI unsafe.
03:22:35 <dmwit> Which is a declaration than check_button_new_with_label will not call back into Haskell-land.
03:23:29 <Profpatsch> dmwit: But if that function call crashes GTK (missing reference for example), it crashes my Haskell program, too.
03:25:17 <dmwit> um yes
03:25:24 <dmwit> that is true of any function ever
03:25:58 <Profpatsch> dmwit: hehe, right. But normally functions are total.
03:26:25 <dmwit> total or not has nothing to do with "unsafe FFI call" or not
03:27:10 <Profpatsch> If the C function can crash, can it be total?
03:27:21 <dmwit> No.
03:27:38 <dmwit> If the C function can crash, can it be called with a safe FFI call? yes.
03:28:04 <Profpatsch> How would I then guarantee my function is safe?
03:28:29 <dmwit> What do you mean by safe?
03:28:33 <Profpatsch> Especially with a beast like GTK under me, which highly depends on global state?
03:28:54 <dmwit> I can practically guarantee that what you mean by safe and what the FFI means by safe are not the same. That's kind of what I'm trying to tell you.
03:28:59 <dmwit> I don't know how to be more clear about this.
03:29:01 <Profpatsch> Ah, ok.
03:29:03 <Profpatsch> I see.
03:29:17 <dmwit> When that call says "unsafe", it doesn't mean "not total". It means "is not allowed to call back into Haskell". NOTHING more.
03:29:28 <Profpatsch> So FFI safe is related to garbage collection.
03:29:38 <Profpatsch> And dangling pointers.
03:29:39 <dmwit> When an FFI call is marked "safe", it *still* doesn't mean "total". It means "is allowed to call back into Haskell".
03:30:06 <dmwit> I'm not sure whether it's related to garbage collection. It is related to putting the RTS in a clean state before transitioning to C.
03:30:23 <dmwit> Possibly in part putting the garbage collector in a clean state, but I don't really know the details.
03:31:39 <Profpatsch> Apart from the FFI safe/unsafe, when I call into a beast library like GTK I basically lose most guarantees that Haskell gives me, right?
03:33:45 <alar> What is the best way to do pessimistic locking? When only one thread can work with my datastructure at any moment
03:34:02 <alar> MVar?
03:34:11 <Yrarr> Hey, I'd like to ask a question about DataKinds, KindSignatures and Nats. I'm wondering why do f2 and f3 functions do not work ? (I'd like to get f1 one to work too, but I guess type synonyms like these might have no information about Nat). http://lpaste.net/140597
03:34:48 <merijn> Yrarr: ScopedTypeVariables needs explicit forall to actually scope :)
03:35:06 <merijn> Yrarr: So: "f1 :: forall n . (KnownNat n) => MyType n a -> Integer"
03:35:08 <merijn> eh
03:35:15 <merijn> That wont compile due to missing 'a' :p
03:35:24 <merijn> "f1 :: forall n a . (KnownNat n) => MyType n a -> Integer"
03:36:29 <Yrarr> merijn: Thanks!
03:37:28 <Profpatsch> I give this A++ in graphic design: https://www.cse.unsw.edu.au/~chak/haskell/ffi/
03:37:30 <Profpatsch> :D
03:42:55 <frerich_> :-)
04:21:41 <Profpatsch> I cannot find where the {# … #} FFI syntax comes from: https://github.com/gtk2hs/gtk2hs/blob/master/gtk/Graphics/UI/Gtk/Buttons/CheckButton.chs#L70
04:21:57 <merijn> Profpatsch: It's not haskell
04:22:06 <Profpatsch> The hsc2hs docs don’t mention it.
04:22:07 <merijn> Profpatsch: chs gets preprocessed into haskell
04:22:13 <merijn> chs /= hsc
04:22:26 <merijn> hsc is something GHC understands
04:22:35 <Profpatsch> oh, nasty
04:22:37 <merijn> chs is something that gets run through chs2hsc or whatever it's called
04:23:32 <Profpatsch> c2hs
04:24:36 <dmwit> Gtk2Hs has its own fork of c2hs, though most of the docs for normal c2hs will be basically right.
04:31:50 <chpatrick> so many haskell FFI solutions :)
04:31:54 <chpatrick> inline-c takes the cake though
04:32:47 * hackagebot hspec-structured-formatter 0.1.0.2 -   https://hackage.haskell.org/package/hspec-structured-formatter-0.1.0.2 (flbulgarelli)
04:37:46 <Profpatsch> chpatrick: This is one use of TH I can approve.
04:38:28 <Profpatsch> As a type-checked pre-processor.
04:39:55 <chpatrick> it's the only ffi I know that's actually typesafe
04:42:09 <Profpatsch> Still not beautiful, but at least bearable. :P
04:42:43 <chpatrick> the only problem with it is that it can't infer the C types of haskell variables
04:42:50 <chpatrick> but that's because of a weakness of TH
04:42:54 <chpatrick> can't do much about it
04:44:50 <Profpatsch> chpatrick: But a function like sin(x) is pure, they still have to use CDouble -> IO CDouble
04:45:03 <Profpatsch> Is this necessary?
04:45:30 <liste> how could Haskell know sin(x) is pure?
04:45:40 <liste> or inline-c
04:45:58 <Profpatsch> liste: Well, I know.
04:46:10 <Profpatsch> Can I tell it that it is?
04:46:24 <liste> at least with unsafePerformIO
04:46:58 <Profpatsch> liste: You are right, I can wrap it afterwards.
04:47:01 <Profpatsch> Makes sense.
04:47:18 <Profpatsch> Then it’s a well known problem again.
04:58:34 <chpatrick> Profpatsch: http://hackage.haskell.org/package/inline-c-0.5.4.3/docs/Language-C-Inline.html#v:pure
04:59:25 <liste> chpatrick cool (:
05:27:51 <bernalex> gah. how did that whole lhs record syntax work again?
05:28:44 <bernalex> if you have data Foo = Fu { f :: A, g :: B, h :: C } -- you can lhs of a function bind e.g. g to a var or summat. how did that work?
05:29:14 <indiagreen> f Foo{f=f} = ...
05:29:15 <indiagreen> I think
05:29:21 <srhb> Correct.
05:29:22 <quicksilver> blah (Fu { f=ff, g=gg, h=hh} ) = show ff ++ show gg ++ show hh
05:29:39 <kaidelong> oh, inline C is neat
05:29:41 <quicksilver> I don't recommend 'f=f' because type incorrect puns make me queasy
05:29:43 <bernalex> the order (f=ff} always trips me up
05:29:44 <quicksilver> but YMMV
05:29:46 <kaidelong> support for FORTRAN too somewhere?
05:29:46 <indiagreen> well, yeah, sorry
05:30:07 <quicksilver> indiagreen: not your fault :) there is an extension
05:30:18 <quicksilver> which lets you write {f,g,h} as shorthand for {f=f,g=g,h=h}
05:30:25 <quicksilver> and really it's that I dislike
05:30:32 <bernalex>   LabelButton {label = b}  == LabelButton {label = c}  = b == c
05:30:35 <bergmark> and another one that's just {...} ...
05:30:37 <bernalex> that might be correct maybe
05:30:46 <indiagreen> the {..} one is ni-ice
05:30:47 <bergmark> i also dislike both because of shadowing
05:30:48 <quicksilver> bernalex: yup
05:31:01 <quicksilver> bernalex: it's not just the shadowing, is shadowing at a different type
05:31:07 <quicksilver> oops
05:31:08 <bernalex> you mean bergmark 
05:31:10 <bernalex> but I agree with you
05:31:15 <quicksilver> meant to direct that at bergmark :)
05:31:18 <indiagreen> isn't shadowing at the same type worse?
05:31:23 <bergmark> it's the only extension where variable names pop in out of seemingly nowhere
05:31:25 <indiagreen> silent mistakes and all that
05:31:35 <quicksilver> that's a valid point indiagreen ;)
05:31:41 <quicksilver> but somehow the type change bothers me more
05:31:53 <indiagreen> with shadowing at a different type at least the type checker will complain, while shadowing at the same type has caught me more than once
05:31:57 <bernalex> instance Eq Button where
05:31:59 <bernalex>   LabelButton  {label = b}        == LabelButton {label = c}        = b == c
05:32:01 <bernalex>   PromptButton {promptLabel = b}  == PromptButton {promptLabel = c} = b == c
05:32:03 <bernalex> compiles so must be correct
05:32:09 <quicksilver> if you do *lots* of record stuff it's worth learning some kind of lens library anyhow
05:32:18 <bernalex> (gief type-driven name resolution, PLS!)
05:32:28 <bergmark> some people really like name shadowing so they probably like NamedFieldPuns  + -fno-warn-name-shadowing
05:32:32 <bernalex> indiagreen: yes that's way worse IMO
05:33:14 <bernalex> and since we can't have non-recursive bindings in do-blocks, it bites a lot of people a lot of the time
05:34:10 <bernalex> or people just do let a' = f a, then forget to change a to a' further down, and wonder "why isn't my stuff working properly".
05:35:16 <quicksilver> I recommend avoid shadowing entirely :)
05:35:38 <quicksilver> perhaps the best thing about the state monad is it stops you either shadowing your state variable or appending loads of primes to it
05:35:44 <bernalex> quicksilver: honestly I really like type-driven name resolution
05:35:50 <quicksilver> and then accidentally the wrong one.
05:36:00 <quicksilver> bernalex: I forgive you.
05:36:12 <quicksilver> but one day you will repent.
05:36:13 <bernalex> I wish I could have twenty record fields named "label", and then I want type inference to just cut me some slack
05:36:57 <zipper> bernalex: What does that mean?
05:37:10 <bernalex> way too much game code ends up having e.g. some sort of entity that has maybe a value like "health" or "collision", and then people just end up with "fooHealth", "barHealth" and so on for their entities.
05:37:20 <quicksilver> we have a regimented way to do that using typeclasses
05:37:49 <quicksilver> when I thought about this carefully I concluded that the cases where typeclasses don't work / aren't convenient, TDNR is even worse :)
05:37:53 <bernalex> zipper: it means that I can have data Foo = Fu { a :: Int }, and data Bar = Baz { a :: Char }, and I can use 'a' throughout my program with the type inference working as I'd expect.
05:38:17 <indiagreen> quicksilver: could you elaborate on that? (so that I could save myself some thinking time)
05:38:49 <indiagreen> like, it feels that TDNR should work exactly where typeclasses don't (i.e. where types are *wildly* different)
05:39:17 <quicksilver> I can't elaborate on it because the train of thought was 2-3 years ago and I only recall my conclusion
05:39:20 <quicksilver> lazy thinking.
05:39:39 <quicksilver> I know that I'm quite attached to the notion that subexpressions (terms) have a principal type though.
05:39:59 <bernalex> you can achieve a lot of this without using (the frankly overused) typeclasses
05:40:23 <merijn> Profpatsch: I dunno if someone mentioned this afterwards, but you can still use the C sin function as pure. But you better be damn sure it *is* pure :p
05:40:44 <bernalex> e.g. in my above example, data HasA a. or data HasHitPoints a.
05:41:43 <ggole> Sounds like you want something like row polymorphism
05:42:02 <merijn> quicksilver: Not a fan of System F_ω ? :p
05:42:06 <merijn> ggole: Who doesn't? :D
05:42:52 <quicksilver> merijn: I have no distaste for it as a logical framework. Frameworks don't need a type inference property.
05:43:14 <quicksilver> type inference is the concern of a concise and efficient programming language. Different priorities.
05:43:20 <merijn> I'm becoming more and more ok with sacrificing type inference
05:43:29 <merijn> Since I end up explicitly writing more and more types anyway
05:43:43 <merijn> i.e. even most of my local definitions have type signatures now
05:44:29 <bernalex> I wouldn't say I'm OK with it, but I certainly don't mind it all too much.
05:45:02 <bernalex> row polymorphism is sexy. we'll have it in ghc 8, I trust.
05:45:53 <zipper> bernalex: But isn't that how haskell works?
05:46:25 <exio4> we already lost some bits of type inference
05:47:17 <merijn> exio4: We didn't lose bits, we just added stuff without it :)
05:47:45 <exio4> indeed :P, i am talking about haskell as a whole thing
05:47:51 * hackagebot libsystemd-journal 1.3.4 - Haskell bindings to libsystemd-journal  https://hackage.haskell.org/package/libsystemd-journal-1.3.4 (OliverCharles)
05:47:57 <quicksilver> losing principle types makes it hard to reason about code rewriting
05:47:58 <bernalex> zipper: in haskell you can't have two record fields with the same name.
05:48:23 <quicksilver> including just refactoring by hand
05:50:28 <zipper> bernalex: Oh in different types?
05:50:35 <zipper> bernalex: I have never noticed that
05:50:47 <zipper> Maybe because  I give overly descriptive names.
05:51:35 <Gurkenglas> "(a -> Bool) -> Traversal' [a] a -> Traversal' [a] a", please.
05:52:04 <Gurkenglas> Replace [a] with s, I guess
05:52:26 <bernalex> needing helper function like
05:52:27 <indiagreen> Gurkenglas: “filtered”, but beware of invalid traversals
05:52:28 <bernalex>         l LabelButton  {label       = l} = l
05:52:30 <bernalex>         l PromptButton {promptLabel = l} = l
05:52:32 <bernalex> is a bit ugh
05:54:03 <indiagreen> Gurkenglas: generally it's alright to use “filtered” in your code, just as long as you don't write traversals with it
05:54:27 <indiagreen> like, use it but don't export stuff like “evens = filtered even”
05:55:06 <quicksilver> bernalex: it's 'ugh' but it's "only" boilerplate. It can be solved at the boilerplate end rather than solving it by changing type resolution
05:55:09 <quicksilver> IMO.
05:55:21 <Gurkenglas> I see, thanks.
05:57:45 <bernalex> holy shit. I know I shouldn't be surprised any more when I make 200 lines changes that rewrites big pieces of my programs and it "just works".
05:57:56 <bernalex> feelsgood.jpeg still though
05:58:51 <indiagreen> Gurkenglas: on the other hand, if your predicate doesn't overlap with what you're checking, then it's alright again (for instance, if you have a list of names and ages, and you write a traversal like “agesOfFemales = each . filtered (even . view name) . age”)
05:59:12 <indiagreen> s/even/isFemaleName/
05:59:20 <Gurkenglas> Yep I just read the doc, my intended purpose preserves the predicate.
06:01:00 <untoldent> Hi. Anyone here from Norway?
06:01:32 <untoldent> i have a cultural, non-Haskell-related question.
06:01:47 <liste> untoldent #haskell-blah
06:01:53 <untoldent> thanks!
06:07:52 * hackagebot nix-paths 1 - Knowledge of Nix's installation directories.  https://hackage.haskell.org/package/nix-paths-1 (PeterSimons)
06:19:12 <certainty> nope doesn't look like it
07:02:04 <int-index> Why isn't Const poly-kinded?
07:02:06 <aznashwan> :i Monad
07:02:20 <aznashwan> >:i Monad
07:02:26 <merijn> int-index: No particular reason, I'm guessing
07:02:27 <Intolerable> @info Monad
07:02:28 <lambdabot> Monad
07:02:32 <Intolerable> thanks lambdabot
07:02:35 <Intolerable> really helpful
07:02:37 <merijn> There is no :info/@info in lambdabot
07:02:41 <aznashwan> Intolerable: thanks man :))
07:02:44 <merijn> @info autocorrect to echo
07:02:44 <lambdabot> autocorrect to echo
07:02:53 <Intolerable> rofl
07:03:02 <Intolerable> i wondered why that has literally never given any useful info
07:03:13 <merijn> :)
07:03:50 <merijn> int-index: By default types are inferred to be *, I think and I just don't think anyone bothered to generalise Const so far
07:04:28 <int-index> merijn: I'd like it to be in GHC 7.12, where should I write about it?
07:04:40 <int-index> GHC 8.0, to be more precise.
07:04:56 <phadej> int-index: polykinded in second argument_
07:04:59 <phadej> ?
07:05:04 <int-index> phadej: Yes, obviously.
07:05:09 <phadej> int-index: then it cannot be Functor etc.
07:05:16 <int-index> Why?
07:05:17 <phadej> as Functor is :: * -> Constraint
07:05:20 <int-index> So?
07:05:22 <phadej> (* -> *)
07:05:46 <phadej> or would it work. hmm.
07:06:12 <int-index> phadej: It would. Even `Proxy` is a `Functor`.
07:06:47 <xandaros> So... I'm writing an interpreter and I have built my AST. Now I want to annotate it. Since basically any entry can have a tag, my current solution would be to add a [Tag] parameter to every single constructor, but it _feels_ like there should be a better solution... Anyone got an idea?
07:07:07 <int-index> xandaros: cofree monad
07:07:36 <xandaros> that was quick o_O I'll have a look at that
07:07:41 <int-index> You basically define your AST as a functor `F` and then use `Cofree F`.
07:08:31 <xandaros> So I can have a funktor at the top-level, which keeps track of annotations deep in the tree?
07:08:42 <xandaros> *functor, accidentally german there
07:10:29 <merijn> int-index: libraries@ mailing list is the go to place for proposals. But if the patch is backwards compatible you could just make a ticket on Trac and attach a patch :)
07:10:34 <phadej> int-index: ah, yeah, so it would be Functor (Const * a), a bit like k ~ * => Functor (Const k a)
07:10:57 <merijn> int-index: Or go all the way and created a proper Phab diff if you can be arsed :)
07:11:12 <cocreature> xandaros: you might want to take a look at http://brianmckenna.org/blog/type_annotation_cofree
07:11:14 <int-index> merijn: Thanks. I'll try the Phab way.
07:11:20 <int-index> phadej: Yes.
07:11:31 <phadej> https://hackage.haskell.org/package/generics-sop-0.1.1.2/docs/Generics-SOP.html#t:K seems to be polykinded
07:11:38 <phadej> TIL
07:11:38 <merijn> int-index: See here for my Phab quickstart: https://gist.github.com/merijn/c01405e6c5a78a1c4ccb
07:11:48 <merijn> int-index: Still recommended to make a ticket too :)
07:12:53 <xandaros> cocreature: Looks like it's exactly what I'm looking for! Thanks :D (You also seem to have a fitting name, heh)
07:15:28 <int-index> merijn: https://ghc.haskell.org/trac/ghc/ticket/10865#ticket
07:17:11 <hodapp> hmmm. not sure if I should have monad Foo contain a State, or whether I should make another monad (that I'm trying to combine, sort of) a StateT over Foo
07:17:57 <int-index> hodapp: a bit of self-advertising here, instead of defining new monads/monad transformers, try tagged approach https://int-index.github.io/ether/
07:18:02 * hackagebot Taxonomy 1.0.1 - Libary for parsing, processing and vizualization of taxonomy data  https://hackage.haskell.org/package/Taxonomy-1.0.1 (FlorianEggenhofer)
07:19:52 <Gurkenglas> MaybeT's monad and alternative instances implement "and" and "or" respectively; how could one do "not"? (Implement m (Maybe a) -> m [a].)
07:20:22 <hodapp> int-index: hmm, I'll go look
07:21:02 <int-index> Gurkenglas: `fmap maybeToList`?
07:21:22 <hodapp> right now what I have is basically a free monad, just not written with Free, and I need to get some state into this
07:21:32 <hodapp> but just enough to generate unique names
07:21:45 <Gurkenglas> int-index, no and you know why
07:22:23 <int-index> Gurkenglas: I don't even know what you actually want, that was a wild guess.
07:23:10 <Gurkenglas> I'll include "such that the full power of the resulting datatype is used" once we have terminology to nail down that meaning :P
07:23:25 <int-index> hodapp: I used a tagged `StateT` to generate names in my translator, https://raw.githubusercontent.com/int-index/kalium/master/src/Control/Monad/Rename.hs
07:24:25 <int-index> Gurkenglas: what is the full power of []? an infinite list? try `maybe [] repeat`.
07:24:48 <Gurkenglas> int-index, nope, a list that isn't always infinite
07:25:22 <int-index> it's finite (empty) when you supply `Nothing`
07:25:39 <merijn> hodapp: No idea if it's helpful, but that sounds a little like what I wrote
07:25:44 <merijn> @hackage transformers-supply
07:25:45 <lambdabot> http://hackage.haskell.org/package/transformers-supply
07:25:46 <merijn> for
07:25:57 <breadmonster> Hello, merijn 
07:26:08 <merijn> Hey
07:26:16 <hodapp> merijn: thanks, I'll take a look
07:26:48 <hodapp> I have never used free monads before and I'm trying to figure out if (given that I basically have one, just implicitly) there's a point in explicitly making it one
07:26:49 <Gurkenglas> Oh wait dangit. hmm I guess I can get away with denying that one because you used fmap and thus didn't need the full power of the monad m
07:27:13 <hodapp> what came to mind is that it enforces a sort of AST that is 'interpreted' elsewhere - and this is a use case where being able to do other things with the AST may be very useful
07:27:18 <merijn> hmmm
07:27:44 <merijn> Why is inventing module names to use so hard? :\
07:27:45 <Gurkenglas> But then you start chopping together solutions that still "dont use the full power", but fit the criteria I said, which is why I initially went with "I'll be formal once I have the needed terminology"
07:27:57 <hodapp> merijn: because it's a subset of the hardest problem in CS
07:28:09 <merijn> I have an incredibly hacky question
07:28:10 <hodapp> my modules aren't put into namespaces and at some point I should probably do this
07:28:34 <merijn> Is there a way to specify a default implementation for a function using default signatures and ANOTHER more general default implementation?
07:28:36 <Intolerable> did someone say "incredibly hacky"?
07:29:08 <Gurkenglas> (But I guess I can help y'all out by saying it's https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:unfoldM :P. Can one use MaybeT to implement that?)
07:29:18 <merijn> I guess this "ifctxt" package could do it, but it'd be nicer if I could do it without dependencies
07:30:10 <hodapp> merijn: hmm, that's tricky, why do you need it?
07:30:42 <merijn> hodapp: Because I have a good and efficient implementation of my typeclass function IFF the type is an instance of Lift
07:30:55 <merijn> And there's a more general, but sucky/hacky version that always works
07:31:07 <merijn> So I want to use the one based on Lift whenever possible
07:31:08 <hodapp> hmmmmm
07:31:16 <nshepperd> `zipWithM :: Monad m => (a -> b -> b -> m d -> v a -> v c -> v a -> v b -> m a)` -- output of a neural network trained on the vector package sources. so close, yet so far
07:31:35 <merijn> But I don't wanna force people to reimplement the hacky version everytime they don't have a Lift instance
07:32:51 <merijn> Also, I think this library might have the biggest SLOC to usefulness ratio I've ever written...considering it comes in at a mere 21 lines of code >.>
07:36:20 <nshepperd> I didn't think it's possible to 'case match' on whether an instance for something exists
07:36:51 <hodapp> that'd seem to be problematic in general
07:36:54 <merijn> Well, it is, because I saw this ifctxt hack on reddit earlier, but I'd prefer something more...principled
07:37:10 <merijn> If you haven't seen it, prepare to be baffled: https://github.com/mikeizbicki/ifcxt#ifcxt
07:38:39 <merijn> I just realised I can cheat. New question: How can I check if a type is an instance of a certain class using TH?
07:38:46 <nshepperd> oh, OverlappingInstances
07:39:55 <nshepperd> is there anything wrong with providing a `slowFooDefault` function with your library and getting people to write 'instance Foo MyType where {foo = slowFooDefault}'?
07:42:24 <Hijiri> what makes it better than default instances
07:43:00 <merijn> Hijiri: what makes what better than default instances?
07:43:23 <Hijiri> nshepperd's thing
07:43:28 <Hijiri> and I don't know if I meant default instances
07:43:32 <Hijiri> default method implementations
07:43:48 <nshepperd> merijn: Language.Haskell.TH.isInstance looks like it
07:44:20 <Hijiri> oh this is TH related
07:44:22 <merijn> nshepperd: Yeah, I just need a way to create a Name, now :)
07:44:23 <Hijiri> I should have read back farther
07:44:31 <merijn> Hijiri: It wasn't initially :)
07:47:56 <nshepperd> I'm a bit wary of using template haskell here, because I don't know if there are any particular guarantees about when an instance will be considered 'in scope'
07:48:03 * hackagebot irc-fun-color 0.1.0.1 - Add color and style decorations to IRC messages.  https://hackage.haskell.org/package/irc-fun-color-0.1.0.1 (akrasner)
07:48:16 <nshepperd> it would be bad if changing an unrelated import made the performance mysteriously worse
07:49:11 <nshepperd> I guess that will only happen with orphan instances though?
07:58:04 * hackagebot yesod-routes-flow 2.0 - Generate Flow routes for Yesod  https://hackage.haskell.org/package/yesod-routes-flow-2.0 (FelipeLessa)
07:58:06 * hackagebot language-nix 2 - Data types and useful functions to represent and manipulate the Nix language.  https://hackage.haskell.org/package/language-nix-2 (PeterSimons)
07:58:08 * hackagebot cmaes 0.2.2.1 - CMA-ES wrapper in Haskell  https://hackage.haskell.org/package/cmaes-0.2.2.1 (TakayukiMuranushi)
08:07:54 <greymalkin> Hmm. I'm using bindings for SANE; defines '#num SANE_STATUS_GOOD' and some others, but I can't pattern match on them, the compiler complains about overlapping pattern matches.
08:08:24 <greymalkin> but c'SANE_STATUS_GOOD return 0, whereas c'SANE_STATUS_ACCESS_DENIED returns 11
08:08:54 <greymalkin> This is my first foray into code with FFI, so this is probably something everyone already knows, but I'm flummoxed.
08:10:33 <infandum> What is everyone's opinion on upper bounds for dependencies? I'm starting to get sick of updating packages just to bump dependencies...
08:10:55 <Clint> infandum: it's a controversial issue
08:11:18 <infandum> And if they ARE necessary, is the convension to do package > X.X && < X.X+1 or package > X.X && X+1.X
08:11:40 <infandum> I've been doing the former and I need to bump them every month it seems
08:12:05 <merijn> infandum: You know you can do those edits on Hackage itself no? :)
08:12:49 <infandum> Really? I didn't know that. But I also need to test that it builds because other dependency errors could arise.
08:13:12 <infandum> Also, I maintain the github packages as well, so yeah
08:15:42 <bennofs> infandum: cabal-bounds is a package that can automatically edit your cabal file to bump deps, so you can use that automate the process
08:15:46 <Cale> infandum: My opinion is that we shouldn't be trying to read the future
08:16:19 <bennofs> Cale: and that means? upper bounds or no upper bounds?
08:16:29 <infandum> sounds like no upper bounds
08:16:44 <infandum> I bring this up because I was looking into stack and they say NOT to use upper bounds
08:16:54 <Cale> I think the upper bound should always be an existing version number.
08:17:00 <infandum> so it's all very confusing for a little guy like me
08:17:21 <bennofs> infandum: for applications, that's ok. but I would definitely recommend upper bounds for hackage releases
08:17:42 <bennofs> Cale: uh, so not even allow newer minor versions?
08:17:46 <wedify> do we not trust our types?
08:17:50 <wedify> or our tests?
08:18:04 <bennofs> wedify: not everything can be tested/typed. We are not a theorem prover yet :=)
08:18:10 <merijn> wedify: Doesn't protect you against behaviour changes
08:18:11 <wedify> why not have upper bounds be determined automatically
08:18:21 <merijn> wedify: People are working on that, but it's HARD
08:18:27 <Cale> bennofs: If it doesn't work with that version, then we shouldn't expect it to work with newer ones
08:18:29 <merijn> wedify: How do you define "still works correctly"?
08:18:53 <bennofs> Cale: I mean if I test with 1.4.3, is it ok to put < 1.5 as upper bounds?
08:18:57 <Cale> no
08:18:58 <wedify> isn't haskells slogan "if it compiles it works"?
08:18:59 <geekosaur> sadly, it is not the case that something compiling == something working correctly
08:19:12 <Cale> If you test with 1.4.3 and it fails, you may put < 1.4.3
08:19:16 <geekosaur> wedify, you need full dependent types to truly approach that goal
08:19:18 * hodapp sadly walks up to sign on wall that says, "It's been __ hours since Hodapp forgot that State is just s -> (a, s)"...
08:19:29 <bennofs> Cale: and if I test with 1.4.3 and it works?
08:19:35 <infandum> For that matter, if we are avoiding upper bounds, is it better to use cabal or stack?
08:19:38 <bennofs> Cale: and 1.4.3 is latest?
08:19:40 <wedify> *gasp* i've been lied to
08:19:44 <Cale> Then no upper bound yet
08:19:47 <geekosaur> haskell is closer than many languages, but doesn't do full dependent types
08:19:50 <breadmonster> wedify: How?
08:20:03 <breadmonster> It's a shame.
08:20:15 <breadmonster> geekosaur: *doesn't do full dependent types yet
08:20:17 <breadmonster> FTFY
08:20:17 <geekosaur> and I suspect even full dependent types can't catch all semantic aspects of a program
08:20:56 <Cale> In principle, dependent types can capture all semantic aspects of a program
08:21:05 <geekosaur> (my suspicion is that it can come arbitrarily close, with accompanying explosion of type complexity, but that reality is a bit too flexible)
08:21:11 <Cale> But you wouldn't usually want them to, because that means duplicating your entire program at the type level
08:21:12 <breadmonster> geekosaur: Is there a way of turning off this annoying typeclass error?
08:21:21 <bennofs> Cale: but that requires that I'm an active maintainer and always test my libraries when new major versions appear at the very least
08:21:29 <breadmonster> > instance Nat a where toInteger :: Integer
08:21:31 <lambdabot>  <hint>:1:1: parse error on input ‘instance’
08:21:37 <breadmonster> > class Nat a where toInteger :: Integer
08:21:39 <lambdabot>  <hint>:1:1: parse error on input ‘class’
08:21:57 <geekosaur> how about use lpaste?
08:22:01 <Welkin> breadmonster: turn it off? it looks like it is just not working
08:22:03 <breadmonster> Okay, yeah, but like either way, toInteger needs to take a Nat a...
08:22:04 <Cale> bennofs: Well, I don't like constraints which are just fabricated out of thin air
08:22:21 <Cale> bennofs: If you have no evidence that there's an upper bound, don't put one
08:22:27 <bennofs> Cale: They are not exactly fabricated out of thin air though. You ocul
08:22:30 <breadmonster> Welkin: I want to create typeclasses that have instances that don't actually depend on the type.
08:22:51 <bennofs> Cale: it says: "i tested it with that major version". Cabal even has --allow-newer now to discard that information if you think you know better
08:22:56 <breadmonster> Can I make the type system a little bit more flexible?
08:23:03 <Welkin> breadmonster: that is the definition of a type class instance though
08:23:08 <Welkin> you crreate instances for specific types
08:23:17 <bennofs> Cale: and most applications probably just keep working between minor version changes
08:23:48 <Cale> I don't think version bounds are the correct place to put information about successful tests
08:24:16 <geekosaur> breadmonster, I think you may misunderstand typeclasses
08:24:17 <Cale> If we want to record additional information about which things were successful, that should be separate metadata
08:24:26 <geekosaur> if they have no relationship with the type, then they can't be used
08:24:58 <breadmonster> geekosaur: You can abstract away the type and ghc creates a dict at compile time with slots for relevant functions, and then passes the dict around?
08:25:20 <Cale> bennofs: I don't want to have to assume anything about the meaning of version numbers apart from that they are totally ordered.
08:25:29 <sunnymilk> is there an extension to let you have newlines in strings
08:25:46 <Welkin> sunnymilk: you mean string literals in source code?
08:25:47 <wedify> i'm glad that cabal has that option. i think upper bounds shouldn't be specified till a bug is found but im not going to win that fight
08:25:54 <sunnymilk> Welkin yes
08:26:07 <Welkin> sunnymilk: you can use a list of strings and then apply unlines over it
08:26:08 <sunnymilk> as in literally a newline character between "s
08:26:21 <merijn> sunnymilk: No, there isn't afaik
08:26:25 <Welkin> I think there may be a way to use a backslash to escape the lines too
08:26:33 <sunnymilk> lame :(
08:26:36 <merijn> sunnymilk: Might wanna use TH/QuasiQuotes to embed larger literal text
08:26:41 <geekosaur> breadmonster, the question is how ghc creates that dict when it has no idea what type is involved. you *might* be able to annotate every use with types (ugh) but if your usage is sufficiently dissociated with the types involved then even that is unlikely to work
08:26:50 <sunnymilk> ive been avoiding TH for years now
08:26:59 <breadmonster> geekosaur: Sure, I'll do that.
08:27:08 <Welkin> sunnymilk: I recently looking into it and it looks fun
08:27:15 <breadmonster> geekosaur: That's the flexibility that I want that the type system isn't giving me.
08:27:22 <sunnymilk> it looks really complicated
08:27:34 <Welkin> sunnymilk: it's pretty simple actually
08:27:43 <geekosaur> it also sounds a lot like abuse of typeclasses for something else
08:27:48 <sunnymilk> is there a good reason to not allow newlines in strings
08:27:52 <sunnymilk> Welkin really?
08:28:06 * hackagebot fasta 0.8.0.1 - A simple, mindless parser for fasta files.  https://hackage.haskell.org/package/fasta-0.8.0.1 (GregorySchwartz)
08:28:08 * hackagebot streaming-commons 0.1.13 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.13 (MichaelSnoyman)
08:28:10 * hackagebot http-client 0.4.22 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.22 (MichaelSnoyman)
08:28:15 <breadmonster> geekosaur: sure, I'll give you that.
08:28:23 <breadmonster> Is there a way of doing it though?
08:28:30 <Welkin> sunnymilk: there are some good resources here https://wiki.haskell.org/Template_Haskell
08:28:31 <merijn> The only polymorphic literals we have in haskell are: Num, Floating, IsString and IsList, right?
08:28:57 <merijn> Or are there any other literals that can produce polymorphic values
08:28:58 <geekosaur> sunnymilk, because if it's actually that you accidentally dropped a closing quote, part of your program "vanishes" and the subsequent errors can be rather painful to diagnose?
08:29:30 <geekosaur> merijn, I think that's it right now
08:29:33 <wedify> you can overload if syntax 
08:29:41 <merijn> That's not a literal
08:29:44 <breadmonster> merijn: I think we should have overloaded syntax on by default.
08:29:49 <breadmonster> And have a list type defined in the Prelude.
08:29:50 <merijn> I don't
08:29:58 <merijn> Horrible errors
08:30:04 <geekosaur> breadmonster, probably not
08:30:08 <merijn> Also, it makes things like my current library awful
08:30:23 <breadmonster> geekosaur: Fuck. Would have made for some interesting bending of the type system.
08:30:45 <breadmonster> geekosaur: Can I file a bug? There should be no reason why it can't be this way.
08:30:56 <merijn> Because now my neat MPTC typeclasses is producing defaulting warnings all over >.>
08:31:07 <geekosaur> ...why are you asking me that? I'm not a ghc dev, nor gatekeeper for the language spec
08:31:20 <merijn> geekosaur: Oh, it's Fractional, not Floating
08:31:23 <breadmonster> geekosaur: Oh sorry, I thought you were a ghc dev.
08:31:38 <hodapp> geekosaur: you can't hide in here, SPJ!
08:31:44 <geekosaur> I *follow* ghc development. I don't yet trust myself to actually *rtouch* the code >.>
08:32:24 <merijn> So I guess I need to cover Rational, Integer, String and lists as special cases to avoid ugly polymorphic messes
08:33:44 <sunnymilk> geekosaur i dont really like the thought of valuing convenience of fixing incorrect code over conciseness of correct code
08:33:44 <bennofs> Cale: well, I assume leaving out upper bounds is ok *if* your very responsive in case that the package really does break (example: my travis builds were recently failing because of missing upper bounds on "vector" in the "these" package. I know I can supply these manually, but I'd still like the problem to be resolved as fast as possible)
08:33:58 <sunnymilk> we should be optimizing for the latter, and optimizing the former only when it doesnt infinge on the latter
08:33:58 <wedify> merijn: are you just trying to make a multi-line string or something like a here-doc?
08:34:54 <Cale> bennofs: Adding an artificial upper bound is even worse if you're not responsive
08:35:12 <geekosaur> sunnymilk, there are ways to do it, via string gaps (most people are not fond of them) or quasiquoter hacks (e.g. http://hackage.haskell.org/package/here)
08:35:22 <Cale> bennofs: Because you're just setting things up to fail in the future when you don't upload a new version of the package with the bound increased / removed.
08:35:25 <bennofs> Cale: no. Because an artificial upper bounds is easy to circumvent with --allow-newer. Guessing upper bounds later and "manually" finding a build plan is harder
08:35:52 <wedify> merijn: you can use quasiquoting to get literal newlines into a string
08:36:05 <comerijn> And then my connection died :)
08:36:12 <wedify> https://wiki.haskell.org/Poor_man's_here_document
08:36:17 <wedify> at the bottom of the page
08:36:20 <infandum> oh god what have I started
08:36:27 <dolio> It also won't break with an artificial upper bound. It will just preclude people from using new things.
08:36:37 <paldepind> How do I get a unicode character from a number? Something like https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode
08:36:58 <bennofs> Cale: how do you propose to distinguish "minor" releases which aren't likely to break user code from "major" releases which change the core API?
08:37:05 <comerijn> wedify: Yeah, but why are you asking me? :)
08:37:07 <Welkin> > ord ∑
08:37:09 <bennofs> if you don't communicate these via version numbers
08:37:09 <lambdabot>  <hint>:1:6:
08:37:09 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:37:10 <Welkin> > ord '∑'
08:37:12 <lambdabot>  8721
08:37:19 <Welkin> > pretty 8721
08:37:21 <lambdabot>  Not in scope: ‘pretty’
08:37:29 <wedify> er, sunnymilk sorry
08:37:35 <Cale> bennofs: I propose not trying to make version numbers do this
08:37:36 <geekosaur> ord, or toEnum :: Int -> Char
08:37:48 <bennofs> Cale: what's the alternative?
08:38:01 <Cale> bennofs: There aren't enough bits in a typical version number to encode all the information you're trying to encode there
08:38:01 <srhb> > chr 8721 -- Welkin?
08:38:03 <lambdabot>  '\8721'
08:38:14 <Welkin> hm
08:38:18 <Welkin> no, I am trying to pretty print it
08:38:23 <Welkin> to show paldepind 
08:38:24 <srhb> Oh.
08:38:27 <Welkin> I forgot the function
08:38:28 <comerijn> Welkin: Use text
08:38:31 <Welkin> ah
08:38:40 <Welkin> > text 8721
08:38:42 <comerijn> > text (chr 8721:[])
08:38:42 <lambdabot>      No instance for (Num String) arising from the literal ‘8721’
08:38:42 <lambdabot>      In the first argument of ‘text’, namely ‘8721’
08:38:42 <lambdabot>      In the expression: text 8721
08:38:44 <lambdabot>  ∑
08:38:44 <geekosaur> > text $ char 8721
08:38:45 <lambdabot>      Couldn't match type ‘Doc’ with ‘[Char]’
08:38:45 <lambdabot>      Expected type: String
08:38:46 <lambdabot>        Actual type: Doc
08:38:47 <Welkin> > text '8721'
08:38:49 <lambdabot>  <hint>:1:7: parse error on input ‘8721’
08:38:52 <comerijn> nubs :)
08:38:53 <Welkin> haha
08:38:57 <comerijn> Mine was right
08:39:14 <geekosaur> > text '\8721'
08:39:16 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
08:39:16 <lambdabot>      Expected type: String
08:39:16 <lambdabot>        Actual type: Char
08:39:22 <geekosaur> whoops >.>
08:39:24 <Cale> bennofs: Just test things, set the version bounds when the build starts failing.
08:39:25 <geekosaur> first one more correct
08:39:29 <srhb> How many Haskellers does it take to print a unicode character?
08:39:30 <geekosaur> > text "\8721"
08:39:32 <lambdabot>  ∑
08:39:36 <srhb> \o/
08:39:39 <paldepind> It seems like chr in Data.Char will do it.
08:39:51 <geekosaur> but earlier I did > text $ char 8721
08:39:53 <srhb> paldepind: chr or toEnum as already stated :)
08:39:53 <wedify> srhb: none it takes an interpreter 
08:39:59 <srhb> wedify: :-)
08:40:00 <geekosaur> which worked but was intermixed with someone else's error
08:40:02 <Welkin> chr*
08:40:03 <paldepind> srhb, thank you.
08:40:58 <srhb> :t char
08:40:59 <lambdabot> Char -> Doc
08:41:05 <comerijn> ok, I'm taking naming suggestions for the module name of my library. I'm calling the entire thing "validated-literals" for (more easily) working with smart constructors applied to literals, but ValidatedLiterals seems an obnoxiously long name and I can't think of anything...
08:41:31 <srhb> comerijn: Validlits has a nice alliteration-like sound
08:41:43 <srhb> lidlid
08:41:49 <comerijn> Hmm, needs more camelcase, but that's not bad
08:42:39 <bennofs> Cale: So are you saying that the chance of my package breaking due to a major release of a dep is not high enough to warrant a preemptive upper bound?
08:42:44 <lpaste_> elperdut pasted “Am I functional?” at http://lpaste.net/140602
08:42:57 <bennofs> even if the costs of working around wrong upper bounds are not *that* high
08:43:11 <MarcelineVQ> comerijn: I wish more packages had obvious names, I don't mind wordy, a person can always import as a qualified name
08:43:34 <comerijn> MarcelineVQ: I'm not talking about the package name, but module name
08:43:42 <sunnymilk> MarcelineVQ its a shame the focus these days seems to be on making names "cool"
08:43:45 <comerijn> MarcelineVQ: "import ValidatedLiterals" is really obnoxious
08:44:00 <comerijn> MarcelineVQ: "ValidLits" less so, while still being relatively clear
08:44:03 <elperdut> hi all, can I ask for some general opinion as to whether the following is 'functional'? it feels very procedural to me with everything line by line in the do block: http://lpaste.net/140602
08:44:16 <bennofs> Cale: Of course, in the long term, it would be nice if we got a solver that produced a package plan based on "compilability", checking for example that at least each used identifier is defined in dependendencies, etc, but that sounds like quite a hard problem to solve to me
08:44:17 <Cale> bennofs: Right.
08:44:37 <srhb> elperdut: It is a very imperative program, so the style is unsurprising. 
08:45:20 <zipper> elperdut: Well some things have to be done one after the other.
08:45:28 <danza> comerijn, i would also prefer a longer but straightforward name, i don't see anything wrong in import "ValidatedLiterals". Relying on English is better than having to remember where or how the words were truncated
08:45:34 <srhb> elperdut: And it's sufficiently short as to not be able to give any real pointers for how to make it more functional-esque. I wouldn't worry about it for now :)
08:45:40 <zipper> The program will show that the program produces effects and their order
08:45:43 <srhb> as to make it hard to*
08:45:59 <elperdut> srhb, zipper: thanks for your input
08:46:18 <geekosaur> in principle you can phrase any imperative program in a functional way. in practice, things like FRP are still active research topics and it's still way easier to just write some things procedurally
08:47:28 <sm> comerijn: how about ValidLiterals
08:47:39 <Intolerable> valit
08:55:28 <hc> i'm trying out Text.XML.Cursor
08:56:00 <hc> when i write "cursor TCXML.$// (TCXML.attributeIs "id" "35")", i get a result, but when writing cursor TCXML.$// (TCXML.attributeIs "id" "35")  TCXML.$// (TCXML.attributeId "id" "35") I get an empty list
08:56:04 <hc> what am I doing wrong?
08:56:55 <hiptobecubic> hc,what do yo uexpect it to do?
08:56:59 <hiptobecubic> you expect*
08:57:21 <comerijn> What bounds should I specify for base?
08:57:24 <hc> well in this case i expect the first and the second line to return the same
08:58:49 <hc> ah i should be using >=> instead of &//
09:02:49 <knupfer> Is it currently possible to define a defaulting behaviour for constraints other than num?  I've read the wiki which says no, but it was the last time eddited before 9 years...
09:04:00 <geekosaur> knupfer, still no. there's been some discussion of how it would be done (because people would like it for IsString) but it turns out to be Difficult
09:04:37 <hc> i was trying for hours and got confused about the xml lib... now in my desperation i ask in this channel and all of a sudden i figure it out ;/
09:04:43 <hc> thanks anyway for helping :)
09:04:49 <geekosaur> rubber duck debugging strikes again >.>
09:05:03 <knupfer> geekosaur: Thanks.  Does there exist some sort of dirty hack to achieve the same?  Let's say with type-level stuff or unsafes.
09:06:54 <geekosaur> knupfer, not really at present
09:07:03 <geekosaur> it's a known pain point
09:07:17 <geekosaur> btu fixing it ... well, devs are aware of it, just not quite sure how to deal with it
09:08:34 <knupfer> geekosaur: ok, thank you!
09:10:15 <comerijn> Should I upload something to hackage if it isn't documented yet or wait until I finish documenting?
09:10:50 <Intolerable> i put stuff on hackage w/ crappy docs
09:10:50 <srhb> comerijn: Upload, upload! We can always yell at you here or on Github or something
09:11:02 <Gurkenglas> I say upload but only because I want to see it
09:11:11 <Intolerable> worst case scenario u can put the docs up as a patch
09:11:24 <Intolerable> and you can always just manually upload docs if you don't want to change the version
09:12:31 <sm> comerijn: wait, wait! Docs first!
09:13:10 <quicksilver> there are 'sort-of' work arounds to not being to add custom defaults
09:13:30 <quicksilver> like sticking all your static data into a big static tuple and wrapping it in the appropriate code
09:13:41 <quicksilver> or putting your static data in an actual file and reading it
09:14:09 <quicksilver> it depends exactly what you were trying to do with it - if you wanted to scatter overloaded constants all over your code, it doesn't help
09:14:35 <comerijn> sm: It's late, I'm going home, so you get to pick either no package or no docs before I go home :p
09:14:44 <sm> easy. no package
09:14:47 <Intolerable> package w/o docs
09:14:55 <sm> don't listen to those clowns :)
09:15:01 <Intolerable> people can look at it and u can always add docs later
09:15:01 <comerijn> You seem to be in the minority :p
09:15:43 <sm> you are just perpetuating Haskell's image problem (all obscure impractical apis and no docs)
09:15:58 <quicksilver> avoid success at all costs!
09:16:03 <knupfer> quicksilver: I've a foo :: (Constr1 a, Constr2 a) => Int -> m a 
09:16:29 <comerijn> sm: It has two examples, though!
09:16:30 <knupfer> the monad is actually a readerT
09:16:46 <comerijn> Actually Hackage doesn't seem to generate Haddocks for candidates anyway >.>
09:17:44 <comerijn> sm: It's hard to be obscure in 38 lines of code, but I tried ;)
09:17:54 <knupfer> so now, if i write: _ <- foo 4 it will complain about not knowing which instance to pick, but the output is discarded...
09:18:09 * hackagebot validated-literals 0.1.0 - Compile-time checking for partial smart-constructors  https://hackage.haskell.org/package/validated-literals-0.1.0 (MerijnVerstraaten)
09:18:12 <tulcod> comerijn: packages without *any* docs are useless. just API docs *can* be useful, but not always
09:18:17 <comerijn> Gurkenglas: https://github.com/merijn/validated-literals/blob/master/ValidLiterals.hs
09:18:26 <knupfer> so i have to write a foo_ which is used for side effects only
09:18:55 <comerijn> tulcod: Please look at the source and examples and tell me if there's anything still unclear ;)
09:19:15 <comerijn> The maint hing to document is some efficiency gotchas, but I can't be arsed right now
09:19:17 <Intolerable> hackySpliceValid is a good name
09:19:38 <knupfer> i would prefer if foo 4 would default to m () if not able to infer the instance
09:19:52 <tulcod> comerijn: well, there is example code, that's a good start
09:19:58 <comerijn> Intolerable: It's hacky because it's redoing the conversion at compile time and then fromJust'ing that...
09:20:11 <Intolerable> yeah i see what it does
09:20:16 <Intolerable> it's appropriately named
09:20:25 <comerijn> The default one using Lift is much nicer
09:20:30 <Welkin> oh, I forgot about that convention
09:20:40 <sm> comerijn: not even a synopsis ?? I'm sorry to tell you https://hackage.haskell.org/package/validated-literals-0.1.0 is a classic example of a useless package :)
09:20:47 <Welkin> I should use that more often when naming my functions of type m ()
09:20:54 <sm> package description, I mean
09:20:55 <comerijn> sm: Won't be once that Haddock type signatures are there
09:21:05 <hc> another question about the Text.XML.Cursor: Suppose I have many elements like this: <elem key="foo" value="bar"/> ; how can I return a list of tuples like this [("foo","bar")]?
09:21:08 <comerijn> Intolerable: Seems to have gotten it :)
09:21:33 <comerijn> sm: You can wait for the docs to appear tomorrow :p
09:21:39 <sm> oh fine
09:22:04 <chpatrick> hc: M.assocs . elementAttributes?
09:22:17 <comerijn> It's not that I don't intend to document it, but it's past 18 and I'm going home for dinner within 10 minutes to not miss my bus :p
09:22:20 <hc> chpatrick: thanks
09:22:22 <chpatrick> derp never mind
09:22:26 <chpatrick> that's incorrect
09:22:27 <zipper> hmmm I need you tube and linkedin to stop emailing me.
09:22:37 <Welkin> zipper: unsubscribe
09:22:46 <Welkin> zipper: otherwise, route them to spam
09:22:50 <comerijn> Intolerable: I think the Even example is a really cool simple thing :)
09:22:58 <sm> comerijn: nod, good luck :)
09:23:25 <paldepind> Can anyone recommend on how to refactor this: http://lpaste.net/140603. Notice how line 3 repeats line 9 and how line 4 repeats line 8.
09:24:04 <comerijn> Intolerable: I mostly came up with the thing because I was writing nice "safe" newtypes using smart constructors, but then hardcoding them means doing an annoying check for an error condition that shouldn't ever happen. And I can get best of both worlds, no failure checking code and static checking :D
09:24:19 <Intolerable> yeah i have a similar thing somewhere
09:24:25 <Gurkenglas> comerijn, have you looked at Prisms?
09:24:39 <Intolerable> i gave it up because i relied on Lift instances though, and nothing seems to have them
09:24:44 <comerijn> Gurkenglas: I know about prisms, but they're not useful for what I need :)
09:24:45 * geekosaur trawling the IsString discussion from 2013... which appears to be joining itself with the current Lift instance dev discussion. hmmm
09:24:56 <comerijn> Intolerable: 8.0 is getting auto-derived Lift according to the wiki :D
09:24:58 <Gurkenglas> (Sounded vaguely like what you said)
09:25:04 <Intolerable> halleloo
09:25:19 <Welkin> comerijn: Lift?
09:25:31 <Welkin> comerijn: Monad Transformers?
09:25:33 <comerijn> Welkin: TH class for embedding values
09:25:35 <Welkin> oh
09:25:38 <Intolerable> no, the TH Lift
09:25:42 <Intolerable> http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lift
09:26:13 <comerijn> Gurkenglas: https://github.com/merijn/validated-literals/blob/master/examples/Examples.hs changing line 9 to "39" results in compile time error
09:26:21 <comerijn> Gurkenglas: That's not something you can do with prisms :)
09:26:22 <hc> chpatrick: i'm doing it now like this: cursor TCXML.$// TCXML.element "myelem" TCXML.&| \subs -> (subs TCXML.$/ TCXML.attribute "key", subs TCXML.$.// TCXML.attribute "value")
09:26:27 <hc> chpatrick: feels a bit ugly though
09:26:35 <chpatrick> one sec
09:26:39 <chpatrick> I'll see how it is with xml-lens
09:26:44 <hc> :)
09:27:29 <comerijn> Gurkenglas: The problem I have is, for example, writing String with restrictions (due to a protocol or whatever) in my source. Clearly those should "always" be correct
09:27:55 <comerijn> Gurkenglas: And I never want to handle an "incorrect" case, incorrect cases should just be fixed in the source, not at runtime
09:27:57 <geekosaur> maybe I should just point to the 2013 thread instead of y'all rehashing it here >.>
09:28:16 <Intolerable> idk about anyone else
09:28:21 <Intolerable> but i've read that multiple times
09:28:26 <Intolerable> (assuming we're talking about the same thing)
09:28:28 <hodapp> what 2013 thread?
09:28:28 <geekosaur> https://mail.haskell.org/pipermail/glasgow-haskell-users/2012-April/022281.html
09:28:29 <comerijn> geekosaur: Was that mine? >.>
09:28:33 <geekosaur> er, 2012
09:28:44 <Intolerable> ah, that one
09:28:51 <Intolerable> no, that is not what i was thinking of
09:29:01 <geekosaur> confused because I looked at the 2013 one first which wasn't useful
09:29:06 <comerijn> Oh, I wrote a similar thing and GHC proposal for that too
09:29:24 <comerijn> Not much enthusiasm, so I figured roll it into a library, especially now that DerivingLift is coming :)
09:29:24 <Intolerable> what's the problem with (default IsString Text)? 
09:29:29 <comerijn> Anyhoo, time to run
09:29:40 <comerijn> Intolerable: Imagine "IsString HTML" where IsString is partial
09:30:08 <Intolerable> talking about the default problem now
09:30:14 <Intolerable> not the validation stuff
09:30:15 <geekosaur> there's ^^ and there's the implementation complication when you want the default to be String
09:30:22 <Intolerable> ah yeah
09:30:24 <Intolerable> nvm
09:30:31 <Intolerable> String is such a disaster
09:30:37 <chpatrick> hc:  \e -> e ^.. (entire . named "elem" . folding (\e -> (,) <$> e ^? attr "key" <*> e ^? attr "value"))
09:30:56 <chpatrick> with xml-lens
09:31:25 <chpatrick> the stuff after ^.. folds over the key value pairs you want
09:31:40 <chpatrick> the rest just applies it to e and turns it into a list
09:31:52 <hc> thank you
09:34:37 <hodapp> so if I have something like StateT over some free monad, where the state is used only for fairly simple/constrained things (e.g. getting unique names), it seems to me I don't *completely* change things; I can still get a useful AST out of it by supplying a starting state
09:34:54 <hodapp> and that structure is preserved, while the structure around the state isn't really structure that I care about
09:35:28 <hodapp> I just have to lift a bunch of things... I think
09:35:32 <Guest45709> Hi
09:35:40 <chpatrick> hodapp: it's also possible to embed the intermediate states in the tree
09:36:25 <hodapp> chpatrick: if I supply a starting state, am I not just exactly this?
09:36:37 <hodapp> not doing*
09:36:47 <JOHN_CENAS_MOTHE> Hello everyone
09:36:50 <chpatrick> with StateT you only get the final states in the leaves
09:37:04 <chpatrick> not in the intermediate nodes
09:37:19 <hodapp> chpatrick: I'm not sure what you mean
09:37:25 <JOHN_CENAS_MOTHE> Will haskell help my son defeat the undertaker THIS SUNDAY NIGHT
09:37:31 <Intolerable> ugh
09:37:42 <chpatrick> hodapp: this is probably irrelevant :D
09:38:01 <chpatrick> but I needed state over Free to have a nice way to implement the rules of chess
09:38:08 <hodapp> chpatrick: it's more relevant than certain other chatter in the channel
09:38:17 <chpatrick> I mean what I'm saying
09:38:29 <chpatrick> so I wanted to implement chess but with a nice way to have user input
09:39:10 <jle`> StateT s m is a cheap way to "add state input/output to m"
09:39:10 <chpatrick> so I used StateT over free but the problem then is that if you write something to play chess by traversing the tree then you don't know the game state, only at the end
09:39:24 <chpatrick> not in other parts of the tree
09:39:55 <chpatrick> you also need to transform the functor if you want state at the non-leaf nodes
09:40:41 <hodapp> the use of intermediate states here is going to be the unique names/IDs generated all throughout
09:41:10 <hodapp> trying to think if this applies at non-leaf nodes...
09:47:26 <hodapp> chpatrick: what did your free monad represent?
09:53:00 <Gurkenglas> paldepind, http://lpaste.net/140603 I would do something like this. Note that this is foldr-y, not foldl-y like yours, you can change that if you want. I would also go on to try for some eta expansion by shifting the delta arguments to the end, maybe use Endo somehow, stuff like that.
09:54:04 <Gurkenglas> (That means the semantics changed! int goes up from the other side etc)
09:56:37 <chpatrick> hodapp: a sequence of player interactions in chess
09:57:04 <chpatrick> so it was data ChessF a = MakeMove (Piece -> a) | Promote (Piece -> a) etc
09:57:40 <chpatrick> and there was a layer on top of this like this I think
09:57:52 <chpatrick> data StateF s f a = StateF s (f a)
09:57:54 <hodapp> chpatrick: okay, that makes sense
09:58:03 <chpatrick> you could use Compose ((,) s)
09:58:33 <chpatrick> and then it was StateT (Free (StateF ChessState ChessF))
09:58:35 <breadmonster> :t reverse
09:58:36 <lambdabot> [a] -> [a]
09:58:53 <chpatrick> with a custom MonadState instance
09:59:39 <chpatrick> then you could just implement your chess game in normal monadic style
09:59:49 <chpatrick> b <- gets board, p <- choosePiece etc
10:00:05 <chpatrick> and it builds up a game tree that you can walk in your GUI or AI or whatever
10:10:51 <dmj`> fg
10:30:20 <paldepind> Gurkenglas, thank you! That looks very good. It's very helpful to be able to compare my own noob-Haskell with your code :) Thanks a lot.
10:30:50 <paldepind> I was attempting a solution with guards myself but it got unwieldy.
10:53:14 * hackagebot irc-fun-messages 0.1.0.1 - Types and functions for working with the IRC protocol.  https://hackage.haskell.org/package/irc-fun-messages-0.1.0.1 (akrasner)
10:56:39 <kqr> edwardk, at the start of your lens presentation at CUFP you gave some intuition for where the getter and setter is "hiding" in the van laarhoven lens type signature... that was pretty great! never seen it that clearly before. cheers
10:57:18 <ttt_fff> https://developers.google.com/blockly/ <-- is there something like this, but implemented in haskell or with decent ghcjs bindings?
10:59:09 <Gurkenglas> (paldepind, actually my line 3 is already handled by 4/5 and thus unnecessary)
11:00:16 <muzzle> hi, is there a haskell library that i can use to visualize graphs (as in Node-Edge combinations) that does not use graphviz (i.e. not ghc-vis)
11:00:19 <muzzle> ?
11:02:03 <Gurkenglas> muzzle, googling haskell graph visualization gives http://hackage.haskell.org/package/Graphalyze
11:03:05 <Gurkenglas> (Oh, dang. Looking at it more closely, it interacts with GraphViz, sorry. Why not Graphviz?)
11:04:13 <muzzle> Gurkenglas i would just find it more convenient to be able to distribute a single binary without having to install graphviz for my program
11:04:33 <muzzle> plus i don't really like how graphviz graphs (both dot and neato) look like
11:21:33 <greymalkin> Is there a way in cabal to expose the "hidden packages" -- like in the case that I'm using happstack-lite, I think that's just there to aggregate the necessary packages, but do I then have to include 'happstack-server' directly in my cabal file to use it?
11:32:48 <ipuustin> how do I get from "Maybe (Type foo bar)" to "(Maybe foo, Maybe bar)". In other words, let record getters return Nothing if the main object was Nothing to begin with.
11:33:07 <ipuustin> This was maybe bit too vague question. :-)
11:34:16 <chpatrick> :t fmap -- ipuustin
11:34:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:34:53 <chpatrick> :t fmap fst :: Maybe a b -> Maybe a
11:34:57 <chpatrick> depr
11:35:01 <lambdabot>     ‘Maybe’ is applied to too many type arguments
11:35:01 <lambdabot>     In an expression type signature: Maybe a b -> Maybe a
11:35:01 <lambdabot>     In the expression: fmap fst :: Maybe a b -> Maybe a
11:35:08 <chpatrick> :t fmap fst :: Maybe ( a, b ) -> Maybe a
11:35:14 <lambdabot> Maybe (a, b) -> Maybe a
11:36:11 <ipuustin> hmm
11:36:16 <cocreature> :t fmap fst &&& fmap snd
11:36:23 <lambdabot> Functor f => f (b, b1) -> (f b, f b1)
11:36:43 <cocreature> ipuustin: replace fst and snd by what you want and I think it should work™
11:37:00 <ipuustin> ok, I'll experiment. Thanks!
11:38:17 * hackagebot sbp 0.50.3 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.50.3 (mookerji)
11:38:55 <Ankhers> :t (&&&)
11:38:59 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:40:51 <cocreature> Ankhers: in this case the arrow a is just the function instance
11:42:19 <Ankhers> cocreature: I still don't full understand Arrows.
11:42:27 <indiagreen> somewhat offtopic, but: what's the most interesting research happening in imperative languages currently?
11:42:29 <absence> is there a tool or something that can change the indent width of haskell source code indented with spaces?
11:42:46 <bernalex> Ankhers: what's the problem?
11:42:58 <Ankhers> absence: Stylish Haskell, I believe.
11:42:58 <kadoban> Ankhers: You don't particularly have to for this. You just have to know that functions are an instance of ARrow
11:43:18 <bernalex> absence: any regular regex?
11:43:20 <kadoban> Ankhers: So, replace 'a' with (->) in the above, and add some parens so it doesn't get confusing.
11:43:32 <Ankhers> I just saw the (&&&) function and didn't know what it did. I just wanted to get an idea.
11:44:01 <bernalex> Ankhers: then kadoban's advice is useful.
11:45:03 <Ankhers> Arrow (->) => (b -> c) -> (b -> c') -> (b -> (c, c')) -- ?
11:45:35 <kadoban> Ankhers: Yep. Except the constraint doesn't make sense anymore so you can drop it.
11:45:42 <absence> bernalex: is that safe?
11:45:49 <bernalex> absence: define safe?
11:46:09 <absence> bernalex: is there no risk of changing the meaning of the code?
11:46:49 <bernalex> absence: none that I can't think of right now.
11:46:52 <Ankhers> kadoban: Thanks.
11:47:39 <bernalex> absence: maybe some let stuff goes a bit too far to the left somehow, & consequently børks... but if that happens it's a syntax error & your code is rejected at compiletime. I can't think of any reason it would compile and act differently.
11:48:43 <absence> Ankhers: any idea if it can do only indent, and none of the other reformatting, like alignment etc?
11:49:59 <Ankhers> absence: No idea. I don't use it. What are you trying to accomplish with this?
11:51:10 <lpaste_> Pro9 pasted “Probably trivial: Parse error in pattern: r ” at http://lpaste.net/2628622055049789440
11:51:44 <Cale> Pro9: Perhaps you meant (Card r _) ?
11:52:01 <absence> Ankhers: well, change the indentation of haskell code ........
11:52:02 <Ankhers> Pro9: What is the definition you are using for Card?
11:52:17 <Ankhers> absence: While you are typing, or after at some point?
11:52:29 <Eve_> Hi guys, I'm just getting started with Haskell and I already got some problems, got time to help me?^^
11:52:33 <Cale> Add Card (r _) hand  would mean that you're applying Add to three arguments which are: Card, and then (r _) (which is invalid pattern syntax), and then hand
11:52:40 <absence> Ankhers: after
11:53:05 <srhb> Eve_: ask, and perhaps ye shall receive.
11:53:06 <Ankhers> absence: I don't know of any tools for that. I've never needed to change indentation after.
11:53:09 <Cale> Eve_: Feel free to ask any questions you might have here
11:53:53 <Pro9> Ankhers: The definition of card is: data Card = Card { rank :: Rank, suit :: Suit } deriving (Eq, Show)
11:53:58 <Eve_> thank you^^ I downloaded Haskell platform(as instructed by our tutor in university). There I used ghci and everything worked
11:53:59 <Pro9> Cale: I will try that
11:54:18 <Eve_> But multiple line programming kinda doesn't work(Only used eclipse before)
11:54:35 <Eve_> So I thought I should use ghc for that, but it crashes as soon as I open it
11:54:57 <Ankhers> Pro9: I believe Cale's answer should solve it.
11:55:32 <srhb> Eve_: ghc is a compiler. You run it on your source file (containing the code) to produce an executable, your program, that your machine can run
11:55:40 <srhb> Eve_: Is that how you are using it?
11:55:48 <srhb> Eve_: ie ghc yourprogram.hs
11:55:53 <Pro9> Ankhers: Cale: yes, it did the trick
11:56:10 <Eve_> Oh, sorry, kinda misunderstodd the program itself^^ (shame on me xD) 
11:56:17 <Eve_> Thanks, it kinda opened my eyes^^
11:56:27 <srhb> Eve_: Mind, you can also use ghci in the same fashion, except without compiling the program, ghci yourprogram.hs will load the source file into the interpreter
11:57:14 <srhb> Eve_: Also in ghci :r yourfile.hs will do the same thing. So either way you can use your favourite editor and then load it up. :)
11:57:25 <Eve_> OK, thanks, I'll try it^^
11:57:44 <srhb> Eve_: Sure thing.
12:00:36 <lpaste_> Pro9 pasted “If-then-else, guards or 3rd alternative?” at http://lpaste.net/2653649714246844416
12:01:54 <kadoban> Pro9: Use them in ... the opposite order of preference as you have them, generally. Use guards if you can't pattern match, use if/else if you can't use a guard.
12:01:57 <absence> Ankhers: think of it like changing the tab width in an editor :)
12:02:57 <Sonolin> is there any way to run a haskell script through ghci in "interpretive" mode (not compile)?
12:03:48 <Sindriava> Is there a way to do static asserts in Haskell?
12:04:00 <kadoban> Sonolin: I'm not sure what that would mean?
12:04:02 <Forgetaboutit> Is there an easier way to write `\f x -> x >>= (\y -> if (f y) then x else Nothing))`?
12:04:05 <Sindriava> e.g. make sure a function isn't called with negative numbers, for example
12:04:24 <Sindriava> @pl \f x -> x >>= (\y -> if (f y) then x else Nothing))
12:04:24 <lambdabot> (line 1, column 51):
12:04:24 <lambdabot> unexpected ')'
12:04:24 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
12:04:35 <Sindriava> @pl \f x -> x >>= (\y -> if (f y) then x else Nothing)
12:04:36 <lambdabot> ap (>>=) . flip flip Nothing . (flip .) . flip . (if' .)
12:04:43 <Sindriava> Well.
12:04:53 <Forgetaboutit> Sindriava: Not what I'm looking for =)
12:04:58 <Forgetaboutit> Sindriava: but it's something
12:05:14 <mpickering> Tomorrow I am going to visit utrecht and thus see the bike monitoring system implemented in haskell
12:05:17 <mpickering> life goals
12:05:18 <Sindriava> Forgetaboutit: You should start with what it's supposed to do, maybe there's an easier solution
12:05:31 <Sindriava> mpickering: Make pictures!
12:05:37 <Ankhers> Sonolin: ghci myFile.hs ?
12:05:51 <Pro9> kadoban: okay, just so I can understand it a little better, in what scenario would you be unable to use guards, but able to use if-then-else? would it be if you have nested if-statements, or can you write nested guards?
12:06:40 <Sonolin> Ankhers: almost but I just want it to load the module, run main, and exit (without ghci prompt)
12:06:48 <srhb> Sonolin: runhaskell?
12:06:48 <Sonolin> for things like one off bash scripts 
12:06:55 <kadoban> I don't know if I can think of a case offhand, Pro9
12:07:06 <kadoban> :t \f x -> x >>= (\y -> if (f y) then x else Nothing)
12:07:12 <Sindriava> Sonolin: #!/path/to/runghc
12:07:13 <lambdabot> (b -> Bool) -> Maybe b -> Maybe b
12:07:17 <kadoban> It does that ^
12:07:40 <Pro9> kadoban: okay, thanks
12:07:53 <Sonolin> Sindriava: perfect thanks :D
12:08:02 <kadoban> Pro9: Just if you're considering using either ... you should almost certainly just use a guard.
12:08:03 <Sonolin> actually quite fast
12:08:39 <kadoban> Actually not 100% sure on that, maybe there's some case where that's not true. You should definitely prefer pattern matching though, haha ... I'll shut up now.
12:09:23 <Pro9> kadoban: I will do my best to always use pattern matching > guards > if-then-else :)
12:09:28 <Sindriava> kadoban: You should prefer what's more readable
12:12:35 <Pro9> Sindriava: The problem with that for me is that I know java and C#, but I'm completly new to haskell and functional programming, and while I agree that pattern matching is probably easier to read than if-then-else and guards, I find if-then-else a lot easier to read than guards
12:13:17 <Sindriava> Pro9: Look. If is *only* readable in the case of "if this then that else foo"
12:13:35 <Sindriava> Pro9: You're constrained by `that` and `foo` being *forced* to have the same type
12:13:39 <Sonolin> Pro9: I think of guards as an better "switch/case", maybe that helps
12:14:06 <kadoban> Forgetaboutit: Ohh ohh oh, that's just mfilter
12:14:09 <kadoban> :t mfilter
12:14:12 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
12:14:14 <Sindriava> Pro9: Once you stop thinking of `if` as a control construct, you'll use it less and less
12:14:20 <Forgetaboutit> kadoban: I just found it myself :D
12:14:28 <kadoban> > mfilter odd (Just 4)
12:14:28 <Sindriava> kadoban + 1, I was looking for that and couldn't found it
12:14:32 <kadoban> Forgetaboutit: Ah, darn, heh.
12:14:34 <lambdabot>  mueval-core: Time limit exceeded
12:14:41 <kadoban> O.o
12:14:45 <Sindriava> Interesting.
12:14:46 <Forgetaboutit> kadoban, Sindriava: but thank you anyway
12:14:53 <Pro9> Sindriava: Sonolin: ye, I try to use guards as much as possible so I get used to them
12:14:57 <Sindriava> > mfilter (const True) (Just 4)
12:15:06 <lambdabot>  mueval-core: Time limit exceeded
12:15:52 <Sindriava> Pro9: The useful part is that guards let you pattern match, if doesn't, since we don't have if-let
12:15:56 <kadoban> Why is that TLEing? O.o
12:16:23 <Gurkenglas> > ()
12:16:28 <hexagoxel> lambdabot is overloaded since at least 40 minutes
12:16:35 <lambdabot>  mueval-core: Time limit exceeded
12:16:37 <hexagoxel> i got bad TLEs then
12:16:56 <kadoban> Oh
12:17:07 <kadoban> Okay, well at least that makes more sense than the specific call failing.
12:17:21 <hexagoxel> int-e: you were the right one to ping for such, right?
12:17:55 <Gurkenglas> Can you use MaybeT to implement unfoldM? https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:unfoldM
12:18:19 * hackagebot poly-arity 0.0.6 - Tools for working with functions of undetermined arity  https://hackage.haskell.org/package/poly-arity-0.0.6 (athanclark)
12:21:27 <bitemyapp> athan_: I see you're still carving runes into your grimoire :)
12:22:32 <athan_> bitemyapp: x_x
12:23:01 <int-e> hexagoxel: hmm, looks better now.
12:23:19 * hackagebot irc-fun-client 0.1.1.0 - Another library for writing IRC clients.  https://hackage.haskell.org/package/irc-fun-client-0.1.1.0 (akrasner)
12:23:33 <bitemyapp> athan_: 'tis a compliment m'wizard :)
12:24:29 <athan_> :U
12:24:48 <athan_> bitemyapp: My stomach is backwards atm
12:26:06 <bitemyapp> athan: :(
12:26:13 <athan> It's a good backwards, don't worry
12:26:21 <bitemyapp> good then :)
12:26:33 <athan> ...contravariant
12:26:35 <bitemyapp> athan: big release impending. So busy and tired -_-'
12:26:42 <bitemyapp> athan: contravariant.
12:27:03 <athan> bitemyapp: :\ I'm hitting a bug in my new gig that's making me... uneasy
12:27:08 <athan> s/in/at
12:28:21 <bitemyapp> athan: I know that feel. Especially in an unfamiliar codebase.
12:29:08 <athan> bitemyapp: No no, this is a familiar codebase
12:29:10 <athan> nested-routes
12:29:34 <athan> it's just a giant china store right now, and my fingers are the bull
12:29:36 <hexagoxel> int-e: thanks.
12:30:08 <athan> but I think there is hope, we have sedatives
12:31:10 <athan> I can't wait for GHC 8 :(
12:32:04 <mariusmarius> athan: is there something in GHC 8 that would resolve your nested-routes woes
12:32:18 <dmj`> athan: srsly
12:32:27 <athan> mariusmarius: Injective type families and dependent haskell >.>
12:32:38 <athan> also injective constraint kinded type families
12:32:46 <athan> and stuff
12:32:58 <dmj`> athan: have you check out servant, type level literals to routes
12:33:14 <athan> I literally had to bind from opposite directions with `~` just to get things to unify
12:33:20 * hackagebot tamper 0.4.2 - An HTML templating system similar to Blaze, implemented as a monad transformer of sorts  https://hackage.haskell.org/package/tamper-0.4.2 (TobiasDammers)
12:33:24 <sunnymilk> why does exception extend Typeable
12:33:27 <athan> dmj`: I haven't dug into it, but idk
12:33:29 <sunnymilk> ie class (Typeable e, Show e) => Exception e where
12:33:31 <athan> mine has parsers :\
12:33:54 <bitemyapp> athan: I bumped into something where I was helping someone with existential quantification
12:33:59 <dmj`> athan: servant has simple FromText / ToText typeclasses for variable capture
12:34:10 <bitemyapp> athan: and I had to pass in a bottom of the same type as one of the type variables to get it to unify.
12:34:27 <athan> that's actually really nice
12:34:46 <athan> :o
12:35:14 <athan> dmj`: That doesn't sound too bad, I'm looking at it now
12:35:32 <athan> bitemyapp: Do you know of `:kind!`, btw?
12:37:29 <athan> dmj`: Is authentication easy, also?
12:38:20 * hackagebot time-interval 0.1.0.0 - Use a time unit class, but hold a concrete time type.  https://hackage.haskell.org/package/time-interval-0.1.0.0 (akrasner)
12:38:53 <geekosaur> sunnymilk, I expect that fromException is actually cast from Typeable
12:39:26 <geekosaur> yep:    fromException (SomeException e) = cast e
12:39:39 <sunnymilk> eugh
12:39:40 <sunnymilk> why
12:40:12 <geekosaur> ?
12:41:16 <sunnymilk> theres nothing about exceptions that inherently requires the use of typeable
12:42:44 <geekosaur> extensible exceptions does
12:43:01 <geekosaur> maybe you'd be fine with a hardcoded list of possible exception types
12:47:44 <Gurkenglas> What's the shorthand for \f -> over . modify f?
12:47:54 <Gurkenglas> *\f -> modify . over f
12:48:14 <bitemyapp> athan: yes but I rarely use it
12:48:17 <bitemyapp> athan: why?
12:50:26 <mauris> Gurkenglas: do you need (%=), i'm too lazy to actually compare the types
12:50:36 <Gurkenglas> yep
12:51:13 <Sindriava> Gurkenglas: It's like %~, but it operates on state because of the `=`
12:51:15 <arkeet> l %= f = modify (over l f)
12:51:55 <dmj`> athan: yea
12:51:59 <athan> bitemyapp: I've had type families work lazily before
12:52:07 <dmj`> athan: I halved my code base in size when switching from snap to servant
12:52:19 <athan> dmj`: sold
12:52:28 <athan> thanks man :)
12:52:59 <dmj`> athan: it's really a thin type safe layer that compiles down to vanilla wai/warp
12:53:15 <athan> dmj`: That's perfect
12:54:58 <dmj`> athan: yea, it's neat, they let you use your own monad stack if you want, for your handlers, as long as your provide a natural transformation to get back to EitherT ServantErr IO a
12:55:17 <bitemyapp> natty transform
12:56:01 <dmj`> bitemyapp: word
12:56:35 <dmj`> athan: inside that function you can do all kinds of cool things like logging, or whatever you want per each request. You still have access to all wai middleware too
12:56:59 <athan> dmj`: Oh wow that's awesome!
12:57:16 <athan> holy beans
12:57:23 <athan> that's awesome
12:57:26 <dmj`> athan: I use the middleware for access logging (which arguably the load balancer could do), but then for db errors I have an internal logger that gets called on all handlers that return Left
12:57:38 <dmj`> inside the natty trans
12:59:16 <dmj`> athan: since your API is just a type def you can traverse it with Proxy (pull the type level literals into values), and then append to it with a type function, all at compile time.
13:00:11 <athan> wtfs, that's very interesting
13:00:29 <athan> OH
13:00:32 <athan> I GET IT
13:00:35 <athan> that's friggin amazing!!
13:01:48 <dmj`> athan: yea, you can get access to the types with Proxy, and then recursively call the typeclass which GHC will resolve to what instance you're referring to until the type def is traversed, while appending to the typedef with a type function, at least, I think that's how it works
13:06:43 <athan> dmj`: Yeah I think you're right, that's really really unique and awesome
13:24:09 <Andchat> hi
13:24:29 <dmj`> Andchat: hi
13:24:35 <Andchat> how do u do
13:24:45 <dmj`> Andchat: good, and you?
13:24:50 <Andchat> kool
13:25:13 <Andchat> do u have a xploit?
13:26:02 <Andchat> helo
13:26:29 <johnw> Andchat: I'm afraid that's not the subject of this channel
13:26:54 <johnw> we're here to discuss the Haskell programming language
13:29:46 <Guest40164> Hey guys, how do I turn a Data.ByteString.Lazy.Internal.ByteString to a ByteString? http://pastebin.com/QFB888un
13:30:25 <mauke> Guest40164: there are two types of byte strings, strict and lazy
13:30:25 <johnw> Guest40164: I think toChunks will give you back its list of strict chunks
13:30:29 <Guest40164> http://pastebin.com/XPDTgbLi
13:30:55 <dmj`> :t Data.ByteString.Lazy.toStrict
13:30:56 <lambdabot> BSLC.ByteString -> BSC.ByteString
13:31:06 <dmj`> :t Data.ByteString.Lazy.fromStrict
13:31:07 <lambdabot> BSC.ByteString -> BSLC.ByteString
13:31:24 <ralu> @type foldr (:) []
13:31:26 <lambdabot> Foldable t => t a -> [a]
13:34:11 <Andchat> anybody have Microsoft iis 8.0 exploit??
13:34:30 <johnw> Andchat: That's not an appproriate question for this channel
13:34:44 <Guest40164> johnw, thanks, that worked :-)
13:34:44 <Andchat> why
13:34:55 <johnw> Andchat: see our topic, we discuss Haskell here
13:35:01 <Andchat> I just want for some pentesting.....
13:35:26 <Andchat> *red*
13:35:27 <monochrom> does not matter. we stick to Haskell here.
13:36:41 <Guest40164> ah dmi, thanks, that saves me a concat toChunks
13:37:40 <johnw> Guest40164: if you can work with chunks, instead of the whole thing, it can save you some time; all depends on what you need with the data
13:38:26 <Guest40164> johnw, I'm just learning at this point, so KISS applies. I'm trying to do screen-scraping on a particular website
13:38:33 <Guest40164> but thanks :-)
13:38:36 <johnw> ah, good point
13:40:16 <Gurkenglas> How do I export all lenses made by makeLenses?
13:40:56 <johnw> Gurkenglas: use makeClassy, and export the class's members
13:41:10 <johnw> $(makeClassy 'Foo)  then, module MyFoo (HasFoo(..)) where....
13:43:23 * hackagebot settings 0.1.0.0 - Runtime-editable program settings.  https://hackage.haskell.org/package/settings-0.1.0.0 (akrasner)
13:43:26 * hackagebot irc-fun-bot 0.2.0.0 - Library for writing fun IRC bots.  https://hackage.haskell.org/package/irc-fun-bot-0.2.0.0 (akrasner)
13:51:49 <jle`> classy
13:53:21 <dmj`> jle`: thanks
13:54:17 <jle`> yw
14:13:25 * hackagebot feed-collect 0.1.0.0 - Watch RSS/Atom feeds (and do with them whatever you like).  https://hackage.haskell.org/package/feed-collect-0.1.0.0 (akrasner)
14:14:23 <flippant> @learn haskell
14:14:23 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
14:14:29 <flippant> @beginner
14:14:29 <lambdabot> Unknown command, try @list
14:14:31 <flippant> @list
14:14:31 <lambdabot> What module?  Try @listmodules for some ideas.
14:14:34 <flippant> :/
14:14:57 <flippant> @haskell learn
14:14:57 <lambdabot> http://www.haskellers.com/
14:15:06 <jle`> flippant: what are you looking for? :)
14:15:12 <monochrom> it's @where learnhaskell
14:15:19 <flippant> thank you
14:15:23 <flippant> @where learnhaskell
14:15:23 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:15:32 <monochrom> I don't know what @learn, @beginner, or @haskell do.
14:15:45 <flippant> that's what i was looking for
14:16:25 <jle`> there are humans in this channel you can ask too ;)
14:16:55 <flippant> :D
14:43:26 * hackagebot funbot 0.1.0.0 - IRC bot for fun, learning, creativity and collaboration.  https://hackage.haskell.org/package/funbot-0.1.0.0 (akrasner)
14:45:40 <Gurkenglas> Is there something like a "Lens' (Maybe a) a" that crashes when Nothing is encountered?
14:46:10 <indiagreen> singular _Just
14:46:16 <indiagreen> or you could just use ^?!
14:51:18 <Gurkenglas> Thanks. What's the modern version of http://hackage.haskell.org/package/lens-1.5/docs/Data-IntMap-Lens.html#v:traverseAt ?
14:52:39 <d-snp> hey guys, fun C compiler fact of the week, C has 'namespaces': http://pastie.org/10411017
14:53:41 <d-snp> structs by default are in the 'struct/union' namespace, which means they can exist at the same time with other types with the same name
14:54:10 <d-snp> implementing c compilers is so much fun :(
14:55:07 <indiagreen> Gurkenglas: just “at”
14:55:17 <indiagreen> no, “ix”
14:55:39 <arkeet> yes, ix
14:56:17 <arkeet> see http://hackage.haskell.org/package/lens-4.12.3/docs/Data-Map-Lens.html
14:57:13 <monochrom> d-snp: yes, "typedef struct x x;" happens a lot
14:57:57 <d-snp> yeah revealed I have no real world experience in C programming, my compiler went into an infinite loop at exactly that pattern
14:58:10 <monochrom> heh
14:58:42 <d-snp> so now I actually have to implement that extra namespace
14:59:25 <keko_> I don't usually see "typedef struct x x;", normally it's "typedef struct x_s x;" or something
14:59:33 <frerich> d-snp: There is no 'extra namespace'. The type is called 'struct x'.
14:59:34 <keko_> probably so it can be compiled with a C++ compiler
14:59:44 <d-snp> frerich: yeah that just crossed my mind
15:00:07 <keko_> d-snp: btw, there are also enums
15:00:12 <idnar> or: typedef struct { ... } x;
15:00:20 <keko_> yeah, that too
15:00:46 <keko_> if the struct isn't recursive
15:00:48 <d-snp> ok, so enums and unions both has the same thing, that the typetype is part of the name right?
15:00:55 <idnar> my kingdom for a javascript lens library that actually bothers to follow the laws
15:01:10 <osa1> is there a way to derive non-orphan Lift instances using deriveLift?
15:02:42 <osa1> ahh right, I was doing the syntax wrong.
15:03:36 <d-snp> I have a function that transforms one data type into another, it's rather unwieldy, would lenses make it more succinct? (its sortDeclarations) https://github.com/tinco/nanc/blob/c78f3c5ce37ed6beebbc0bdf477abb17ff35a5e0/Nanc/IR/CodeGen.hs
15:03:42 <levi> frerich: There are indeed several namespaces in C. That's what they're called in the C specification.
15:03:52 <d-snp> I think I sort of get the basics, but I've heard they're super powerful
15:05:31 <levi> Lenses are powerful and can make data manipulation code, especially with nested structures, much more concise. But it comes at the price of a lot of extra symbols to learn and some hard-to-interpret type errors when you make mistakes.
15:09:07 <frerich> levi: I suppose you can consider struct names (and I suppose the same holds for unions) as separate namespaces, true. However, since you can never address those names without fully qualifying them (i.e. I'm not aware of a way to make 'x' refer to 'struct x' without using a typedef) I always just thought of the 'struct' or 'union' to be part of the type name.
15:09:17 <levi> d-snp: The C identifier name spaces: label names, tags (names following struct, union, or enum), members (*each* structure or union has a separate name space), and ordinary identifiers.
15:09:25 <frerich> levi: Which also fits well with the 'typedef struct x x;' thing, it's nicely consistent.
15:10:00 <d-snp> levi: gcc complains when you compile union a; struct a; though
15:10:14 <levi> frerich: Disambiguation mechanisms are the reason you *can* have separate namespaces, though.
15:10:25 <levi> d-snp: Yes, those both belong to the 'tags' name space.
15:10:31 <d-snp> oh right
15:13:33 <frerich> levi: Ok, this is really offtopic but you made me read it up - and indeed, they are explicitly called 'name spaces'! I'm afraid I will never be able to shake this 'the type is called 'struct s'' mentality after all these years though. Still, now I will feel guilty when saying so.
15:14:28 <d-snp> :P
15:14:39 <levi> frerich: Well, the type *is* called that, so you're not wrong! It's just that the type name has two parts, and one of them is an identifier drawn from a different name space than some other identifiers are drawn from.
15:15:01 <frerich> Even better!
15:15:09 <levi> (It's marginally on-topic as it's related to the Haskell program d-snp is writing)
15:15:55 <levi> Plus, Haskell namespaces for structure members are a hot topic now that there's some work going on from changing how they work.
15:16:23 <frerich> levi: Due to me getting confused with clipboard contents, I just accidentally pasted your host name (which happened to be selected in my IRC client) into the browser instead of the actual URL I wanted to open. To my surprise, I got to see a cgit page.
15:17:06 <d-snp> I 'accidentily' stole all your source code ;)
15:17:07 <levi> frerich: Yup, there's even some haskell code there.
15:17:34 <levi> None of it meant to be private, or it wouldn't be there!
15:20:40 <d-snp> so I 'accidentily' went to your hostname, and then accidentily lookad at the css directory of your homepage
15:20:48 <d-snp> you actually write CSS in haskell? why? :P
15:20:54 <levi> Why not?
15:21:03 <d-snp> well.. less is super nice
15:21:58 <dmj`> d-snp: you can use haskell as a css preprocessor
15:22:01 <levi> Many tools are adequate.
15:22:12 <dmj`> d-snp: have you seen clay, http://fvisser.nl/clay/
15:22:24 <levi> dmj`: Indeed, he's asking why I used clay for the CSS of my homepage.
15:23:16 <dmj`> levi: ah
15:23:29 * hackagebot nationstates 0.3.0.1 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.3.0.1 (ChrisWong)
15:24:20 <d-snp> I guess it's not too bad, I'd be slightly annoyed with having to translate css properties to haskell
15:25:33 <Gurkenglas> Why is (Seq a) a Monoid?
15:26:19 <kadoban> Gurkenglas: Same reason [a] is ? (++) and []
15:27:18 <Gurkenglas> Yep, just noticed that. ._.
15:27:59 <Gurkenglas> It feels wrong that "every" Alternative is manually defined a Monoid, when Alternative f => Monoid (f a) would overlap with everything and Alt has exactly this purpose.
15:28:08 <levi> d-snp: They're mostly named the same, or you can use the CSS name in a string.
15:33:11 <levi> Gurkenglas: I believe the current policy is to provide instances for everything that it's reasonable to do so when a new type class is introduced. If instances are defined anywhere but with the class or the type being made an instance, then they're orphan instances, which are somewhat problematic.
15:36:02 <levi> I'd have to think what other instances that might be ruling out, but my brain's not up to it right now.
15:54:27 <yalapeno> module F1 where  -- Vad ska de andra funktionernas typsignaturer vara? fib :: Integer -> Integer fib n = 0 rovarsprak s = s karpsravor s = s medellangd s = 1.0 skyffla s = s why isn't this working. i am a beginner and the error says parse error (possibly incorrect indentation or mismatched brackets)
15:56:55 <shachaf> Go to hpaste.org and paste your full code and full error message.
15:58:30 * hackagebot DSA 1.0.1 - Implementation of DSA, based on the description of FIPS 186-4  https://hackage.haskell.org/package/DSA-1.0.1 (AdamWick)
15:58:32 * hackagebot riak-protobuf 0.20.0.0 - Haskell types for the Riak protocol buffer API  https://hackage.haskell.org/package/riak-protobuf-0.20.0.0 (lambda_foo)
16:03:31 * hackagebot riak 0.9.0.0 - A Haskell client for the Riak decentralized data store  https://hackage.haskell.org/package/riak-0.9.0.0 (lambda_foo)
16:22:25 <Gurkenglas> https://hackage.haskell.org/package/witherable-0.1.3/docs/Data-Witherable.html
16:22:38 <Gurkenglas> Damn wrong channel. Though one can never have enough wither
16:27:01 <ReinH> yalapeno: if it's an indentation error, we'll need to see how it's indented...
16:27:34 <hexagoxel> how to import `Alt` in ghc < 7.10 ?
16:28:40 <yalapeno> here it comes: http://lpaste.net/140626
16:29:11 <yalapeno> thanks for help btw. i am very new to these and getting stuck very often. 
16:31:30 <pavonia> Say I have a process that keeps a huge data structure in memory and modifies it regularily. What is the usual way to access this process/structure from another process?
16:32:29 <pavonia> I could write the whole strcuctre to a file or database but that would be a lot of overhead
16:33:43 <johnw> pavonia: you could offer some kind of service API for querying that large data set
16:33:55 <johnw> i.e., turn the main process into an in-memory database of sorts
16:34:23 <pavonia> But what interface would I use?
16:34:35 <johnw> REST, named pipes, sockets, etc.
16:34:44 <johnw> depends on a lot of factors
16:35:38 <pavonia> So you mean the process should be some kind of network server?
16:35:50 <johnw> network, or just local
16:35:55 <johnw> it's hard to answer with so little info though
16:38:26 <pavonia> johnw: It's just one process that hold a map of numbers in memory, and the other process should be able to ask for the value of a specific key or to update the value for that key
16:39:06 <pavonia> The second process would be called many times
16:39:28 <johnw> will it run on Linux only?
16:39:46 <pavonia> No, also on Windows
16:40:07 <johnw> you mean, both pairs will run on Linux and Windows?
16:40:17 <johnw> or just the "server" is on Linux, and multiple clients are on Linux and Windows?
16:40:40 <pavonia> Both should run on each system
16:40:42 <johnw> i mean, what you describe also sounds like what redis is for, so there are many possible answers to this question
16:42:23 <pavonia> Indeed
16:47:45 <ReinH> pavonia: do you want the data to be durable?
16:48:15 <ReinH> because it sounds a lot like you just want some sort of database
16:48:30 <pavonia> Yes, e.g. by writing them to disk at regular times
16:48:33 <ReinH> and unless you *want* to write a database in Haskell, I'd recommend not doing so.
16:49:06 <ReinH> because it's quite hard, and knowledgeable people have already spent person-decades building them for you
16:49:24 <pavonia> No, I don't want to write a whole database, just something simple. Like a command line tool that can hold it's data in memory
16:49:39 <ReinH> Right, that's the problem: expecting what you want to be simple.
16:50:05 <pavonia> Isn't it? :S
16:50:11 <ReinH> Nope.
16:50:27 <ReinH> Unless you're building some sort of toy where you don't really care about data loss, integrity, etc
16:50:40 <ReinH> You might try acid-state for starters
16:52:34 <pavonia> At the moment, it's just a proof of concept implementation. And as I've never done this kind of process communication I'd prefer something that doesn't rely on an external tool or package
16:54:00 <ReinH> Are you trying to learn how to do IPC or how to write a database?
16:54:44 <pavonia> What is IPC?
16:54:56 <ReinH> inter-process communication
16:55:18 <pavonia> Yeah, the former then
16:55:41 <ReinH> Then I'd recommend choosing your battles and don't try to do both at the same time
16:56:30 <Sonolin> just use redis, nice & simple and does what your asking for
16:56:32 * Sonolin shrugs
16:57:26 <pavonia> ReinH: Okay, so what do you suggest for IPC? I see there's a package with that name but it's deprecated
16:58:02 <ReinH> there are way too many options and use cases to offer a blanket suggestion
17:00:48 <pavonia> :(
17:01:30 <pavonia> Maybe I should read something more general about IPC first
17:17:19 <Mathnerd314> is there an implementation of http://www.unicode.org/reports/tr9/ in Haskell, besides http://www.google.com/patents/US7120900 ?
17:24:47 <slack1256> http://typeocaml.com <- awesome stuff right there
17:26:02 <haskellnoob> Has anyone used fixhs for their projects?
17:26:25 <haskellnoob> https://github.com/urv/fixhs ?
17:31:33 <haskellnoob> Would you recommend using it? I am still trying to understand the library, the last update was about 4 years old.
17:32:07 <haskellnoob> although, that should not mean much if the library can be used.
17:33:51 <haskellnoob> Any insight into this will greatly help.
17:38:39 <TheCrafter> Hello #haskell. I have a problem and I need some help. I'm trying to create my first program using monad transformers (the StateT). So I've created all my functions that use the transformer but know I have to call them from main. How can I do it? I want to do something like
17:38:41 <TheCrafter> main :: IO ()
17:38:41 <TheCrafter> main = do
17:38:41 <TheCrafter>   connectToServer
17:38:41 <TheCrafter>   ircConnect
17:38:42 <TheCrafter>   ircRecv
17:38:42 <haskellnoob> I guess not many have used the library. I would not want to write the parser if i could avoid it.
17:39:07 <TheCrafter> all functions have type: StateT MyData IO ()
17:39:26 <ReinH> TheCrafter: look at runStateT and such
17:40:33 <TheCrafter> ReinH: okay, I'll do that. thanks
17:49:54 <TheCrafter> Correct me if I'm wrong, but to use StateT I need some sort of initial state right?
17:51:11 <geekosaur> yes
17:58:55 <TheCrafter> any ideas how to do that when my data contains a socket? I mean.. how can I get a "default" value for socket.
17:59:38 <TheCrafter> calling mkSocket?
18:01:07 <Jello_Raptor> hmm, I'm having some trouble understanding the behavior of "unsafeInterleaveIO", specifically when I run "take 5 <$> mapM (\ a -> unsafeInterleaveIO (print ("foo" ++ show a) >> return a)) (iterate (+1) 1)" my ghci promp hangs without any output instead of what I expected (namely print "fooN" a few times and then returning the first few natural numbers 
18:02:36 <ReinH> TheCrafter: ReaderT would be more appropriate for a socket, or just passing it around
18:02:41 <ReinH> you don't really modify sockets very much
18:03:11 <TheCrafter> Yeah but I'm using state because in the future I'll need to carry around more than just a socket
18:03:29 <Jello_Raptor> with s/unsafeInterleaveIO/unsafePerformIO/ and s/mapM/map/ I get what I expect (the list printing and print operations interleaved) :/ 
18:04:09 <TheCrafter> ReinH: but I'm stuck with making the whole thing work. I do not understand how can I chain my StateT functions in main, which has type :: IO ()
18:04:18 <ReinH> :t runStateT
18:04:19 <lambdabot> StateT s m a -> s -> m (a, s)
18:04:55 <ReinH> you take a StateT s IO a computation and use runStateT startingState to turn it into IO (a, s)
18:06:03 <RageD> sorry if this got sent earlier (connection issues):
18:06:05 <RageD> Does anyone know the current state of Raft consensus implementations in Haskell? I've seen both: https://github.com/kfish/raft and https://github.com/NicolasT/kontiki, but both look untested and with unclear levels of support. Is anyone else using either of these or something similar?
18:06:49 <TheCrafter> ReinH: Yeah but runStateT's type is " StateT s m a -> s -> m (a, s) ". That means I need a StateT and a starting state right?
18:07:19 <ReinH> you need a StateT action and a starting state, yes
18:07:22 <TheCrafter> Sorry if my questions sound stupid. I'm really new at this. If you don't have time to help me, maybe you can point me to the right direction to study or something
18:07:27 <TheCrafter> oh okay
18:07:41 <Welkin> TheCrafter: https://wiki.haskell.org/Typeclassopedia#Monad_transformers
18:08:16 <TheCrafter> Thanks Welkin, I'll take a look soon.
18:08:39 <TheCrafter> so ReinH, I need something like runStateT action1 getStartingState
18:09:01 <ReinH> right
18:09:16 <ReinH> well, not "getStartingState", just a value of type s
18:09:38 <ReinH> for whichever s your state is
18:09:43 <TheCrafter> and to chain actions: runStateT (action1 >>= action2) valueOfTypeS
18:10:02 <ReinH> or do notation
18:10:08 <TheCrafter> yeah :D
18:10:20 <TheCrafter> well, that leaves me to the previous problem. How can I get a "default" socket? ..
18:11:13 <ReinH> You don't need a "default" socket. You need whatever socket you want to use.
18:11:30 <ReinH> And you would create it however you usually would
18:11:43 <Gurkenglas> What should I use for "Monad m => Maybe a -> (a -> m ()) -> m ()"?
18:11:51 <TheCrafter> Ooh! yeah I get it now.
18:13:17 <TheCrafter> thanks!
18:16:45 <Welkin> Gurkenglas: fromMaybe
18:17:10 <arkeet> :t forM_
18:17:11 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
18:17:19 <arkeet> Gurkenglas: ^
18:17:50 <Welkin> ah, I was thinking mapM_
18:17:55 <arkeet> same thing, just flipped
18:18:02 <Welkin> yeah :)
18:18:54 <Gurkenglas> Nice, thanks.
18:23:33 <l8star> hi
18:47:27 <chexxor> I did some googling, but I can't find any blogposts - I'm looking for posts on the topic of "building haskell projects without cabal"
18:47:52 <chexxor> like, I `git clone somerepo`, then I want to patch it
18:48:06 <chexxor> I'm curious about how feasible it is to do this w/o using cabal
18:48:29 <TheCrafter> well you can just build it with good old ghc
18:49:05 <chexxor> I tried that, but the project I tried this with failed to build
18:49:14 <chexxor> b/c the cabal file defined language extensions to use
18:49:47 <chexxor> so, instead of using cabal build, I'd have to build the use `ghc` with the correct options/flags?
18:49:57 <TheCrafter> well, cabal uses ghc anyway. You just have to find out WWCD (What Would Cabal Do) :P
18:50:05 <TheCrafter> yeah
18:50:13 <TheCrafter> But since the project has a cabal file already
18:50:17 <TheCrafter> why don't you just use cabal??
18:50:41 <chexxor> I don't understand cabal entirely, so I'd prefer to not use it
18:50:55 <chexxor> I've done lots of reading on it, but it still does sooo much stuff
18:51:16 <chexxor> thanks for the response though
18:51:27 <TheCrafter> sorry I can't help more.
18:51:37 <TheCrafter> I'm a new member of haskell world so I've only used cabal myself..
18:51:42 <chexxor> I might be happier by reading up on stack instead
18:52:07 <TheCrafter> Well, I'm 100% sure that with the right ghc flags you won't need cabal.
18:52:25 <TheCrafter> Just build the project again and again, solving problems on the way until you get it right.
18:52:59 <TheCrafter> I mean, that's the way to go in every language. I cannot count how many times I had to reverse engineer C/C++ code because the makefile was made by a monkey!
18:53:13 <chexxor> I'm not a fan of being forced to *not* use the compiler :-/
18:53:52 <chexxor> b/c the layer between you and the compiler can do anything - it doesn't have a well-defined set of responsibilities
18:54:14 <TheCrafter> First of all, I think you can configure cabal's behavior anyway.
18:54:27 <TheCrafter> And second, you can just find out how ghc works and make your own build system.
18:54:30 <TheCrafter> You can use https://hackage.haskell.org/package/shake
18:54:33 <TheCrafter> :D
18:54:43 <julianleviston> chexxor: stack uses cabal
18:54:59 <chexxor> yeah :)
18:55:05 <duobei> Senior Haskell developer roles at Standard Chartered [Singapore]  https://donsbot.wordpress.com/2015/09/10/senior-haskell-developer-roles-at-standard-chartered-singapore/
18:55:55 <hiptobecubic> How many "senior haskell developers" are really floating around out there?
18:56:19 <julianleviston> hiptobecubic: haha seniour means what 10+ years of software dev?
18:56:25 <julianleviston> hiptobecubic: so, loads of them?
18:56:31 <hiptobecubic> no
18:56:34 <julianleviston> no?
18:57:04 <julianleviston> hiptobecubic:  what does it mean?
18:57:19 <TheCrafter> I don't think there are many haskell developers out there anyway. Let alone seniors.. I've read a post about language usage average and Haskell had only 0.2% !!
18:57:20 <hiptobecubic> I don't think "Senior haskell developer" means "10 years of software dev and also you made a sudoku solver in haskell"
18:57:53 <julianleviston> hiptobecubic: what do you think it means?
18:58:03 <Alpha64> 10 years of sudoku
18:58:07 <johnw> perhaps they want a developer who is senior, and who knows Haskell
18:58:10 <hiptobecubic> yes
18:58:18 <hiptobecubic> senior w.r.t. haskell development
18:58:24 <julianleviston> well obviously.
18:58:27 <TheCrafter> julianleviston: Not crying versus Monads? :D
18:58:36 <julianleviston> lol
18:58:41 <Welkin> "The generic term "fold" is often used to refer to the more technical concept of catamorphism. Intuitively, given a way to summarize "one level of structure" (where recursive subterms have already been replaced with their summaries), a catamorphism can summarize an entire recursive structure. It is important to realize that Foldable does not correspond to catamorphisms, but to something weaker. In particular, Foldable allows observing only 
18:58:55 <Welkin> so foldr/foldl are not catamorphisms?
18:59:00 <Welkin> what?
18:59:55 <julianleviston> Welkin: where are you reading this?
19:00:18 <Welkin> typeclassopedia
19:00:35 <Welkin> https://wiki.haskell.org/Typeclassopedia#Foldable_actually_isn.27t
19:01:55 <glguy_> It is on lists but not other types in general
19:02:08 <julianleviston> ah ok
19:02:25 <Welkin> glguy_: what does this mean though?
19:02:32 <Welkin> "the actual structure itself"
19:02:35 <johnw> say you had a data type like: data Weird r = Weird r (r -> r)
19:02:50 <johnw> you can easily write Foldable for that, but not cata, since it can't be a Functor
19:02:52 <monochrom> foldr is list catamorphism
19:03:47 <Welkin> johnw: why can't it be a funtor?
19:03:50 <Welkin> functor*
19:03:55 <johnw> r appears in negative position
19:04:09 <Welkin> what does that mean?
19:04:33 <johnw> (r -> r) <-- fmap can't map over the first 'r'
19:04:48 <Welkin> I see
19:05:01 <Welkin> because fmap for functions is composition
19:05:15 <glguy_> Foldr in particular for lists
19:11:09 <hodapp> https://hackage.haskell.org/package/Chart wonder how this compares to matplotlib...
19:11:22 <hodapp> it'd be good if it has the features from matplotlib that don't make want to stab matplotlib
19:14:38 <julianleviston> So is there a catamorphism typeclass?
19:15:05 <julianleviston> Oh I guess that’s what this is? cata :: Functor f => Algebra f a -> Mu f -> a
19:15:26 <julianleviston> Don’s worry about answering this question. I need to study more. :)
19:25:22 <Big_G> Anyone here know how I might be able to add Either types to OO languages?
19:26:02 <julianleviston> Big_G: what are you trying to do?
19:26:23 <Big_G> julianleviston, Provid failure states for a method without exceptions
19:27:04 <julianleviston> Big_G: but libraries use exceptions...
19:27:30 <Big_G> julianleviston, Yes but I'd prefer they didn'
19:27:33 <julianleviston> Big_G: so at some point you’d have to have some kind of catch that translated into your Either type, right?
19:27:42 <Big_G> didn't. Makes it hard to tell when and what will happen
19:28:12 <Big_G> julianleviston, Yeah. It'd be similar but I've been having a lot of issues where the exceptions aren't handled well and I want to make that explicit
19:28:55 <kandinski> how can I partially apply all arguments to a function?
19:28:59 <julianleviston> Big_G: yeah, I don’t understand the shape of that problem domain well enough.
19:29:36 <kandinski> (ie make a parameterless thunk that has all arguments to a function in it, but is not the return value)
19:29:38 <julianleviston> kandinski: haha what does *that* mean? isn’t partially application by definition only supplying some of the arguments?
19:30:04 <kandinski> julianleviston: in other languages, you can have g = partial(add, 1, 2)
19:30:05 <julianleviston> kandinski: oh… isn’t that what happens normally with lazy evaluation?
19:30:18 <kandinski> and then do g() to get the value
19:30:21 <kandinski> yeah, hmmm
19:30:37 <julianleviston> kandinski: you can do the same thing in haskell, just say g = (+) 1 2
19:30:50 <kandinski> that's how you simulate lazy evaluation in other languages, I guess
19:30:52 <julianleviston> kandinski:  that’s unevaluated until you use it
19:30:58 <kandinski> right, thanks
19:31:08 <kandinski> let g = (+) 1 2
19:31:17 <kandinski> cheers!
19:34:13 <nitrix> Is (+) 1 2 normal form or it needs to be applicated?
19:34:27 <nitrix> applied*
19:34:37 <julianleviston> nitrix:  it’s not normal form
19:34:50 <julianleviston> nitrix: until you use it.
19:34:52 <geekosaur> I'm not understanding this... (+) 1 2 is identical to 1 + 2, it's just "spelled" in function rather than operator form
19:34:57 <nitrix> julianleviston: So that's weak head normal form?
19:35:07 <julianleviston> geekosaur:  yes… 1 + 2
19:35:46 <julianleviston> nitrix: um, no, I don’t think it’s WHNF either.
19:35:51 <geekosaur> either way, it is unevaluated until something forces (+) at which point it evaluates its parameters strictly... but only then; it's not "pre-evaluated" strictly
19:35:56 <julianleviston> nitrix: it’s a thunk
19:36:12 <kandinski> julianleviston: "type g" fails though
19:36:28 <julianleviston> kandinski: huh?
19:36:37 <kandinski> I'm new here
19:36:41 <KaneTW> nitrix: when you write 1 + 2 or (+) 1 2 or whatever it's a thunk until you actually require the result
19:36:43 <julianleviston> kandinski: what is “type g” ?
19:36:49 <kandinski> I was trying to figure out what g is
19:36:52 <geekosaur> suspect that assigning a type is being confused with evaluating it?
19:36:53 <julianleviston> kandinski: where?
19:36:56 <geekosaur> did yoiu mean :type ?
19:36:58 <kandinski> in ghci
19:37:05 <julianleviston> :type aha
19:37:06 <kandinski> yeah, thanks
19:37:07 <nitrix> KaneTW: I think you are confusing someone's question with mine.
19:37:17 <kandinski> cheers geekosaur too
19:37:30 <KaneTW> might be
19:37:31 <crocket> Is dependent typing available in haskell?
19:37:39 <julianleviston> GHCI is not a *great* place to get a good idea of evaluation symantics...
19:37:50 <kandinski> julianleviston: where is a better place?
19:38:01 <KaneTW> not yet, there's an ongoing project by goldfire though
19:38:11 <KaneTW> https://github.com/goldfirere/thesis
19:38:12 <nitrix> crocket: No, but you can simulate it.
19:38:16 <R0b0t1> It is possible to judge if an object is or is not a type theoretic object if and only if the type of all types exists.
19:38:16 <R0b0t1> The judgment *:1 decides if an object is or is not a type theoretic object; the type of all types exists and is equivalent to 1.
19:38:17 <R0b0t1> halp
19:38:19 <R0b0t1> what'd I do wrong
19:38:30 <julianleviston> this book is pretty good…. http://chimera.labs.oreilly.com/books/1230000000929/ch02.html#sec_par-eval-whnf
19:39:21 <crocket> ok
19:41:31 <julianleviston> kandinski: that book is about concurrency and parallel programming, but it has a pretty good explanation of how GHC evaluates thunks from a certain view…
19:41:49 <julianleviston> kandinski: sorry, not a certain view. Just “in reality” :)
19:42:42 <geekosaur> R0b0t1, I don't think anyone here has context for your question
19:42:51 <elbin> hi all - basic question - I'm having trouble getting cabal to do what I want: symlink on install to /home/elbin/bin. I have set symlink-bindir to /home/elbin/bin, but when I run "cabal install Cabal cabal-install" it doesn't create a symlink.
19:43:48 <R0b0t1> geekosaur: Well, the type of all types isn't supposed to exist for a similar reason the set of all sets doesn't.
19:43:51 <elbin> what could I be doing wrong?
19:44:01 <R0b0t1> I might have to find a mailing list
19:44:29 <julianleviston> R0b0t1: doesn’t that only apply to containers?
19:44:40 <julianleviston> R0b0t1: types aren’t containers, are they?
19:45:33 <geekosaur> type theory gives me a headache :) but IIRC a type is like a set of the possible values?
19:46:26 <geekosaur> R0b0t1, https://mail.haskell.org/mailman/listinfo/haskell-cafe ?
19:46:31 <kaidelong> well strictly speaking, types are like sets with one modification
19:46:43 <kandinski> julianleviston: thanks, I'll put it on my list
19:46:44 <kaidelong> they have an associated natural number called a rank
19:47:00 <kaidelong> they cannot hold a type with a rank equal or higher than themselves as an element
19:47:08 <kaidelong> but other than that I think they're just like sets
19:47:10 <julianleviston> kandinski: don’t do that, just read the first couple of pages I linked to - it give you a practical way to understand thunks in GHCI
19:47:21 <R0b0t1> julianleviston: hmm that's a good point
19:47:25 <kandinski> julianleviston: aha, thanks again, I'll do that
19:48:42 * hackagebot moesocks 1.0.0.0 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-1.0.0.0 (JinjingWang)
19:48:51 <R0b0t1> kaidelong: I have just read a book that makes me not so sure of that
19:48:53 <julianleviston> kaidelong: interesting!
19:48:54 <R0b0t1> thanks for link
19:49:10 <geekosaur> R0b0t1, HoTT?
19:49:37 <geekosaur> (homotopy type theory)
19:49:41 <mgsloan> kaidelong: Hmm, can't you still just treat them as sets?  I'd say that rank is just a property of the types, so could be a function from elements of the set to Nat.
19:50:14 <mgsloan> Err I mean from the set of types to Nat
19:50:48 <shachaf> I don't think rank exists at the same level as most properties of types.
19:50:58 <shachaf> It isn't preserved by isomorphism, for instance.
19:50:58 <nitrix> Hi, I have a question.
19:51:00 <nitrix>  [(a,b,c) | a <- [1..1000], b <- [1..1000], c <- [1..1000], (a^2)+(b^2) == (c^2)]
19:51:16 <R0b0t1> geekosaur: yeah
19:51:34 <nitrix> My first attempt were with values from [1..50] and would spit out tuples extremely quickly. This version from 1..1000 is super slow. I don't understand why.
19:51:55 <julianleviston> nitrix: combinations. there are 1000 * 1000 * 1000 combinations.
19:51:58 <R0b0t1> kaidelong: "A type A is a set if for all x, y: A and p, q: x = y it is true p = q."
19:52:00 <R0b0t1> so I mean
19:52:01 <R0b0t1> meh
19:52:03 <geekosaur> I haven't yet tried to read the book (see preceding comment about type theory >.> ) but it does have a different notion of types from the usual one
19:52:07 <c_wraith> nitrix: does O(n^3) mean anything to you?
19:52:18 <nitrix> The same values are output, but at a slower speed. I just expected the thing the take longer due to more _total_ combinations, but the first values are still super slow.
19:52:30 <c_wraith> nitrix: that's because you're going through them in a lame order
19:52:50 <julianleviston> nitrix: because it goes over 1000 of the first one before it even gets to 2 on the second.
19:52:53 <nitrix> How could I reduce it?
19:52:53 <c_wraith> nitrix: also, there's no point in iterating over c at all.  you might as well just calculate if it exists.
19:52:59 <julianleviston> nitrix:  whereas before it only had to do 50.
19:53:07 <c_wraith> nitrix: that change alone drops it to O(n^2)
19:53:15 <nitrix> c_wraith: Right.
19:53:35 <nitrix> Also, I'm doing pythagorean triplets so I could add `a < b < c` as well.
19:53:47 <c_wraith> that would also be a huge speedup
19:54:03 <KaneTW> just do a^2 < b^2 < a^2 + b^2
19:54:09 <nitrix> Sorry, translating problems to haskell is still very hard for me.
20:06:50 <octopuscabbage> hello, i'm currently in an independent study with some other people. I've been doing haskell for a while but the other three people haven't. They started haskell about 3 weeks ago (but are seniors in computer science) what's a project that would take them 3-4 hours to do?
20:06:54 <davidar> nitrix: calculate the bounds on b and use those instead of [1..1000]
20:07:19 <octopuscabbage> I want it to involve some basic IO and some possibly complicated functions
20:07:21 <davidar> like change of measure stuff in calculus :)
20:07:41 <dganti> Has anyone used fixhs for parsing/serializing fix messages?
20:08:50 <davidar> or refactoring nested for-loops
20:11:40 <KaneTW> octopuscabbage: uhm
20:11:50 <KaneTW> you could give them the coursework for cis194
20:12:03 <KaneTW> @where learnhaskell
20:12:03 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:12:15 <julianleviston> octopuscabbage: write a screen scraper for google results
20:12:57 <dganti> I am looking for some help with fixhs library..has anyone here used it?
20:13:59 <octopuscabbage> julianleviston: is there a screen scraping library?
20:14:08 <Coldblackice> ?
20:14:20 <dganti> https://github.com/urv/fixhs
20:15:28 <julianleviston> octopuscabbage: no… it’s pretty easy to write one… should take about 3 hours!
20:16:00 <julianleviston> octopuscabbage: sorry, I don’t know their haskell level really… if they’re super beginners, that might be too much?
20:16:35 <octopuscabbage> julianleviston, it's not a /bad/ idea but it is a bit much. like I said, they have really no FP experience outside of a small clojure project and 3 weeks of haskell
20:16:36 <julianleviston> octopuscabbage: but yeah… there’s https://hackage.haskell.org/package/tagsoup
20:17:00 <julianleviston> octopuscabbage: ah you didn’t actually say that… you said 3 weeks of haskell… Ok.
20:17:14 <octopuscabbage> julianleviston, yeah that was perhaps unclear
20:17:16 <julianleviston> octopuscabbage: so you want them to get a feel for how to write a program in FP then… cool
20:17:31 <octopuscabbage> julianleviston, correct, ideally it would show off some of the things haskell and FP are good at
20:18:22 <julianleviston> octopuscabbage: sudoku solver?
20:18:42 <julianleviston> octopuscabbage: that’d be about right, I think… the main idea you want to get across is functional composition.
20:18:42 <octopuscabbage> julianleviston, oh great idea. 
20:19:09 <julianleviston> octopuscabbage:  as in… divide and conquer through reusable pure functions.
20:20:14 <octopuscabbage> julianleviston, yeah that seems perfect
20:20:17 <julianleviston> octopuscabbage: or get them to write something that takes a CSV file and transposes cols for rows 
20:20:20 <julianleviston> octopuscabbage: ok. cool
20:22:56 <emilypi> I'm new to haskell. Why is http://codepad.org/FRzeOREd throwing this error? 
20:23:00 <emilypi> also hihi :)
20:23:26 <johnw> -| in the second position is expecting it to be a constructor, which it can't be
20:23:36 <Axman6> you can't pattern match on a function
20:23:54 <Axman6> (-|) is a function, not a constructor.
20:24:02 <emilypi> kk easy enough
20:24:06 <octopuscabbage> emilypi, becaause you're trying to use a function like a constructor. You would just want to match on (Cons a xs) instead of what you have
20:24:22 <Axman6> you can do what you're after with the Pattern Synonyms language extension
20:24:44 <emilypi> awesome, thanks everyone!
20:25:05 <octopuscabbage> Axman6, I don't mean to be an arse but shouldn't we avoid telling newbies about language extensions? 
20:25:32 <Axman6> I don't see why not, knowledge is power
20:26:24 <emilypi> anything is appreciated.
20:26:54 <Axman6> I don't think you'd be able to use exactly that syntax though, it'd probably have to be something like :-| instead of -|
20:27:01 <julianleviston> octopuscabbage: I think one of the nicest thing about the Haksell community is how we share everything, all the time :)
20:27:10 <emilypi> i'm not too invested in syntactic sugar it's k
20:27:13 <emilypi> but thanks Axman6
20:28:14 <octopuscabbage> julianleviston, I'm not saying we shouldn't tell /anyone/ just it leads to people solving their problems with language extensions instead of the idiomatic haskell way. I'm not saying it's necessarily a bad thing and upon thinking about it, it might actually be helpful simply because now I looked up that extension.
20:28:33 <julianleviston> octopuscabbage: lol :-) nice. :)
20:29:00 <octopuscabbage> julianleviston, I'm just saying it could be a bit confusing to newcomers if it's presented as a better way to solve a simple problem instead of the idiomatic way to solve it
20:29:22 <julianleviston> octopuscabbage: sure thing
20:30:18 <Axman6> octopuscabbage: we already give the simple solution, then additional information in case emilypi wanted to continue to use what she thought was sensible syntax, because it turns out it is
20:31:04 <julianleviston> octopuscabbage: I don’t think more information is bad…. ever. You’re always free to just let it pass and come back to it.
20:31:25 <emilypi> Mostly, it was just an exercise in reinventing the wheel for the haskell 99 problems
20:31:31 <emilypi> so meh?
20:31:34 <julianleviston> :S
20:31:34 <emilypi> :P
20:31:38 <julianleviston> :D
20:32:31 <Axman6> anyway, welcome to the fun that is learning Haskell! feel free to ask here about anything to do with haskell, there's heaps of people who can and will help =)
20:32:48 <emilypi> http://codepad.org/nbGoXPyZ
20:32:50 <emilypi> i'm learning!
20:32:52 <emilypi> first day, not bad
20:33:14 <emilypi> so far the lack of let rec's is so nice
20:33:36 * emilypi came from OCaML
20:33:40 <Axman6> used to OCaml?
20:33:40 <julianleviston> ahhh
20:33:41 <Axman6> heh
20:33:52 <octopuscabbage> emilypi, nice. i actually heard from a few ML people that they miss that because they accidentally wrote infinitely recursive functions
20:34:03 <emilypi> XD
20:34:14 <Axman6> you'll probably miss being able to do arbitrary IO inside any function, but you'll come to realise that's not really something you want anyway
20:34:19 <emilypi> too many lets make your eyes bug out
20:34:51 <emilypi> the lambda syntax is very nice
20:34:52 <Axman6> emilypi: your reversel function is pretty inefficient btw, it's O(n^2)
20:35:41 <octopuscabbage> emilypi, my favorite comment on the lambda syntax is that it looks like an actual lambda if you squint really hard
20:35:41 <julianleviston> Axman6: you might have to suggest a better one ;-)
20:35:56 <emilypi> octopuscabbage: exactly!
20:37:23 <emilypi> Axman6: i hear you can do it in terms of flip but i haven't implemented flip yet
20:37:34 <emilypi> so #yolo
20:37:56 <julianleviston> emilypi: you can use recursion, you know.
20:38:37 <emilypi> my friend said explicit recursion was the devil in haskell
20:38:53 <emilypi> and that ghc was optimized for foldr's
20:39:24 <octopuscabbage> emilypi, your friend is wrong. kind of. 
20:39:27 <emilypi> https://wiki.haskell.org/Correctness_of_short_cut_fusion#destroy.2Funfoldr
20:39:30 <emilypi> and sent this
20:40:07 <julianleviston> emilypi: look at how reverse is implemented: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#reverse
20:40:16 <octopuscabbage> emilypi, an O(n) algorithm is more important than fold fusion.
20:40:22 <emilypi> huh
20:40:24 <emilypi> tru
20:40:41 <octopuscabbage> emilypi, additionally, look at how a lot of stuff is implemented in prelude. a lot of it is explicit recursion 
20:40:51 <emilypi> i wonder why he's so convinced
20:41:01 <julianleviston> emilypi: because he wants a simple rule.
20:41:28 <kaidelong> fusion of folds can eliminate intermediate structures
20:41:44 <julianleviston> generally, there aren’t many simple rules.
20:41:48 <julianleviston> ;-)
20:42:06 <kaidelong> this can be a big deal with things like strict, unboxed vectors in the Data.Vector library
20:42:15 <kaidelong> where the lib optomizes away folds+unfolds
20:42:28 <emilypi> hmmm
20:42:32 <kaidelong> but lists can be GC'ed very easily if they are produced and consumed
20:42:48 <kaidelong> it isn't as good as an in place update, so you are still better off if the compiler fuses the list out
20:42:49 <emilypi> well i hope y'all don't mind me in here orienting myself by asking horribly mundane q's :)
20:43:00 <kaidelong> but it isn't as bad as allocating an entire array
20:43:04 <julianleviston> emilypi: please do
20:43:06 <emilypi> the goal is Galois Inc. 
20:43:08 <emilypi> :P
20:43:13 <emilypi> we're gonna get there.
20:43:19 <hunteriam> Is a group just a monoid with invert ability?
20:43:23 <julianleviston> emilypi: what is galois inc?
20:43:25 <emilypi> hunteriam: yes
20:43:30 <hunteriam> Awesome thanks guys
20:43:31 <emilypi> julianleviston: a haskell firm in portland
20:43:36 <julianleviston> ah
20:43:36 <kaidelong> US military contractor
20:43:38 <hunteriam> I'm about to take an algebraic structures class I'm so hyped
20:43:47 <emilypi> hunteriam: two sided identity, two sided inverse, associativity
20:44:04 <kaidelong> I guess that'd be a nice job, if I get a PhD or, through some cruel twist of fate, end up in the military and out of it again alive
20:44:04 <hunteriam> I'll have to google two sided identity
20:44:08 <hunteriam> And inverse
20:44:27 <Cale> emilypi: A really nice trick to remember whenever you're building up a list using many appends, since xs ++ ys takes O(length xs) steps to fully reduce, is to do the following
20:44:40 <emilypi> oh Cale
20:44:42 <emilypi> long time no talk
20:44:46 <Cale> emilypi: Instead of building a list of type [a], instead build a function of type [a] -> [a]
20:44:46 <emilypi> hi
20:44:49 <Cale> hi :)
20:44:58 <hunteriam> emilypi: I don't detect the difference between identity and two sided identity
20:45:03 <Cale> which will add elements to the beginning of whatever list it's given
20:45:03 <hunteriam> After having Google
20:45:14 <Cale> Instead of the empty list [], you then use the identity function id
20:45:27 <emilypi> hunteriam: you rarely deal with one sided inverses and id's
20:45:34 <emilypi> so don't worry bout it
20:45:34 <Cale> Instead of a singleton list [x], you use the function (x:) which adds x to the beginning of a list
20:45:49 <Cale> and, crucially, instead of (++), you get to use function composition (.)
20:45:51 <emilypi> Cale: interesting
20:45:59 <emilypi> i did think singleton was a bit much
20:46:04 <Pamelloes> If I have a function f :: m b -> m a and a function g :: m b -> m a, is there a way I can somehow put them together?
20:46:09 <Cale> Since composition is constant time, this improves the asymptotic performance
20:46:19 <octopuscabbage> Cale, is that just a difference list?
20:46:21 <Cale> and then once you're done constructing the function, you can apply it to an empty list
20:46:40 <emilypi> hmmm
20:46:41 <octopuscabbage> Pamelloes, is the m monad?
20:46:42 <Cale> octopuscabbage: Yeah, these functions are sometimes called "difference lists", though I don't really care for the name.
20:46:47 <Pamelloes> Yes
20:46:52 <octopuscabbage> Cale, I agree it's not a descriptive list
20:47:17 <Cale> emilypi: So for example, where you might have had:
20:47:21 <Cale> reverse [] = []
20:47:23 <octopuscabbage> Pamelloes, are the as and bs the same? beacuse I don't really think there's a way to put them together if they both take and produce as
20:47:30 <Cale> reverse (x:xs) = reverse xs ++ [x]
20:47:39 <Cale> You can instead construct a function like this:
20:47:44 <Cale> reverse' [] = id
20:47:51 <octopuscabbage> Pamelloes, I meant take bs and produces as
20:47:53 <Cale> reverse' (x:xs) = reverse' xs . (x:)
20:48:06 <Cale> and then define  reverse xs = reverse' xs []
20:48:22 <Cale> and that goes from O(n^2) to O(n)
20:48:24 <emilypi> Cale: you're going a little fast but i'll work on this tonight
20:48:27 <emilypi> that's really cool
20:48:36 <Pamelloes> Oh wait, I messed up. g :: m a -> m b. So that f . g :: m a -> m a
20:48:41 <Cale> Yeah, I just wanted to get it written down compactly :)
20:49:00 <Cale> because I think it's clearer if you can see all the code on the screen at once :)
20:49:09 <emilypi> ya i getcha
20:49:21 <emilypi> how's modding math these days?
20:49:25 <emilypi> haven't been in in a long time
20:49:31 <KaneTW> hunteriam: just wait for the coures, it's going to go through tbe basics
20:49:46 <octopuscabbage> Pamelloes, are you sure you didn't mean a -> m b b -> m c
20:50:00 <Cale> I try to keep an eye on ##math, but I often miss stuff.
20:50:02 <octopuscabbage> Pamelloes, (a -> m b) (b -> m c)
20:50:25 <emilypi> i left after i kept getting these creepy pm's from this one spammer every day
20:50:35 <octopuscabbage> Pamelloes wait if they're of matching types couldn't you just compose them with the dot operator
20:50:40 <emilypi> #thejoysofladydom
20:51:06 <Pamelloes> octopuscabbage: I want to fix them so that the output of one is the input for the other.
20:51:16 <Pamelloes> I wasn't very clear, sorry :(
20:52:01 <Pamelloes> Cale: Wow, that's really cool! 
20:52:52 <kaidelong> I don't see why you need to go to all this complication
20:52:54 <kaidelong> what's wrong with
20:52:55 <octopuscabbage> Pamelloes, could you give me the concrete example of your function, maybe i'm not getting it
20:53:01 <NeverDie> Anyone want a free invite to buy the oneplus two?
20:53:08 <kaidelong> reverse [] sx = sx
20:53:24 <kaidelong> reverse (x:xs) sx = reverse xs (x:sx)
20:53:29 <kaidelong> that's also O(n)
20:53:34 <kaidelong> and no building up a big function
20:54:16 <octopuscabbage> Pamelloes, because it seems like https://gist.github.com/octopuscabbage/522c2c8c22581df50ba3 should just work
20:54:18 <dganti> I will try one more time: i needed some comments about the fixhs library..how to use it has anyone used it, opinions etc.
20:54:20 <Pamelloes> octopuscabbage: Errr, I'm not quite sure on my types yet. But lets say a is Int and b is String, the types would be f :: m String -> m Int and g :: m Int -> m String. I want to use the output of g as the input for f and the output of f as the input of g
20:54:44 <octopuscabbage> Pamelloes, If the ms match up, you should just be able to use the compose operator
20:54:48 <emilypi> Cale: do you have a paper which gives more exmaples of the composition trick?
20:55:05 <octopuscabbage> emilypi, It's a well known trick, just look up difference lists
20:55:12 <emilypi> octopuscabbage: thx
20:55:26 <Welkin> emilypi: it is actually one of the assignments in cis194
20:55:33 <emilypi> que es eso
20:55:38 <Welkin> for implementing a text editor
20:55:50 <emilypi> i'm not CS trained i have no idea what these courses are >.>
20:55:53 <kaidelong> it's an introductory haskell court with hosting on github
20:55:57 <kaidelong> course*
20:55:58 <Welkin> @learnhaskell
20:55:58 <lambdabot> Unknown command, try @list
20:56:04 <Welkin> @where learnhaskell
20:56:04 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:56:08 <Welkin> there
20:56:21 <Welkin> cis194 is an introfuctory haskell course at UPenn
20:56:30 <emilypi> oo cool
20:56:31 <Welkin> introductory*
20:56:31 <Cale> There are some rather old papers, but I'm not sure how useful they are
20:56:31 <Pamelloes> octopuscabbage: The compose operator takes the output of g and puts it in f. But then I want to take the output of g and put it back in g. So that no input value is specified.
20:56:36 <Cale> I could give another example
20:57:01 <Cale> Here's a type for binary trees:  data Tree a = Tip | Branch (Tree a) a (Tree a)
20:57:03 <octopuscabbage> Pamelloes, wouldn't that just be g . f . g ?
20:57:11 <emilypi> mmhm
20:57:13 <Cale> Suppose we want to do an in-order traversal
20:57:13 <nitrix> julianleviston c_wraith KaneTW: Done! I solved euler problem 9 and it runs in 2 seconds! Pretty proud of myself :D  ->  https://github.com/nitrix/euler/blob/master/problem009.hs
20:57:19 <kaidelong> actually
20:57:21 <Cale> inorder Tip = []
20:57:31 <julianleviston> nitrix:  nice ;-) hi5
20:57:33 <Cale> inorder (Branch l x r) = inorder l ++ [x] ++ inorder r
20:57:40 <Welkin> Cale: wouldn't that be a tree with data only at the leaf nodes?
20:57:41 <kaidelong> isn't the . trick much worse here because you need to build up separate stack to represent the composition
20:57:41 <emilypi> right
20:57:47 <Welkin> I thought that is how difference lists were implemented
20:57:47 <kaidelong> so you do the work of traversing the list twice
20:57:56 <Pamelloes> octopuscabbage: No because that's still a function. I want it to be a value. something like let a = f (g a)
20:58:02 <kaidelong> compared to just building the thing directly using cons
20:58:03 <Cale> Welkin: These trees only have data at the branch nodes
20:58:19 <Pamelloes> (though that doesn't work)
20:58:21 <octopuscabbage> Pamelloes, okay then (g . f . g) a
20:58:24 <julianleviston> nitrix: wow. I find that code hard to follow
20:58:41 <nitrix> julianleviston: Actually, it might even be wrong, let me verify.
20:58:45 <octopuscabbage> Pamelloes, it should be noted that what you wrote is also a function, it just takes 0 parameters
20:58:46 <emilypi> lets keep it simple first
20:58:48 <julianleviston> nitrix: lol
20:58:48 <Cale> emilypi: So, the problem with this is that if the tree is very left leaning, i.e. the left subtrees are large, then we'll have a couple of long (++)'s to carry out on each step down the tree
20:58:58 <emilypi> right
20:59:02 <Welkin> nitrix: why are there no top-level type signatures?
20:59:31 <Cale> So, we can blindly apply that transformation I suggested: instead of implementing  inorder :: Tree a -> [a]  directly, we write
20:59:39 <Cale> inorder' :: Tree a -> ([a] -> [a])
20:59:45 <Cale> inorder' Tip = id
21:00:01 <Cale> inorder' (Branch l x r) = inorder' l . (x:) . inorder' r
21:00:27 <Pamelloes> octopuscabbage: What you wrote is linear though. I need the values to recurse. So that in let a = f (g a), the a's are the same. The value produced is used as the original value. Due to the way the functions are structured, this should be possible.
21:00:34 <Cale> and then to recover the function we really wanted, we apply the resulting function to an empty list:
21:00:38 <julianleviston> nitrix: what does isSquare do? It seems very complicated.
21:00:43 <Cale> inorder t = inorder' t []
21:01:11 <nitrix> julianleviston: Checks if number x is in the infinite list `squares`.
21:01:16 <julianleviston> nitrix:  by the way, \x -> x*x == (^2)
21:01:28 <nitrix> julianleviston: noted.
21:01:29 <emilypi> Cale: but that doesn't match teh type sig for inorder' ? 
21:01:37 <emilypi> or am i reading that wrong
21:01:45 <julianleviston> nitrix: isn’t that super inefficient?
21:01:46 <Cale> It does.  inorder' t []  means  (inorder' t) []
21:01:51 <emilypi> ah
21:01:52 <emilypi> kk
21:01:56 <Cale> In general in Haskell,  f x y  means (f x) y
21:02:05 <octopuscabbage> Pamelloes, do you want to infinitely apply (g . f . g) ?? I'm afraid i'm not quite getting what you're after
21:02:16 <Cale> and in types, whenever you see A -> B -> C, it means A -> (B -> C)
21:02:29 <nitrix> julianleviston: It doesn't reach big enough values to be a problem. It's actually an optimization in this case due to memoization.
21:02:30 <kaidelong> isSquare' n m = n*n == m || (n*n > m && isSquare' n (m-1)) 
21:02:43 <nitrix> julianleviston: From what I grasp.
21:02:49 <Pamelloes> octopuscabbage: I think I found what I'm looking for: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Function.html#v:fix
21:02:51 <kaidelong> isSquare n = isSquare' n (n `div` 2)
21:02:55 <kaidelong> this is what I've always done
21:03:00 <emilypi> right, right associativity ir emember kkk
21:03:07 <kaidelong> doesn't have to be complex
21:03:18 <octopuscabbage> Pamelloes, you know, that was what i was about to point you towards actually haha
21:03:19 <julianleviston> nitrix: ah ok.
21:03:30 <octopuscabbage> Pamelloes, seems like we both got there at the same time
21:03:38 <Pamelloes> :)
21:03:47 * hackagebot yesod-pnotify 1.1.0 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-1.1.0 (KatsutoshiItoh)
21:04:16 <emilypi> Cale: that's so nifty
21:04:19 <emilypi> it hurts
21:04:22 <nitrix> kaidelong: How is your isSquare' defined?
21:04:31 <nitrix> kaidelong: I see.
21:05:38 <Cale> emilypi: If you write in the extra function argument, and expand out the compositions, you'll see that this is really just the same as keeping an extra accumulating parameter, but I think it's much easier to think about how the transformation should go and what the time complexity is, if you think in terms of building functions.
21:05:57 <Cale> i.e. We could have written:
21:05:57 * emilypi nods
21:06:13 <Cale> inorder' Tip xs = xs
21:06:31 <Cale> inorder' (Branch l x r) xs = inorder' l (x : inorder' r xs)
21:07:28 <emilypi> hmmm
21:07:33 <hunteriam> Hey guys, I have a quickish question
21:07:48 <octopuscabbage> hunteriam, we have a long drawn out answer
21:07:51 <emilypi> sup
21:08:03 <Cale> A long, drawn out answer, repeated in triplicate ;)
21:08:15 <emilypi> i'll go full historical accuracy if it's a math question
21:08:17 <hunteriam> If I have a group G containing elements {g1...gn}, and g is some arbitrary element of that set, why is gG = Gg
21:08:24 <hunteriam> I'm told it has something to do with cancellation
21:08:33 <emilypi> hunteriam: only in the case that G is commutative
21:08:38 <emilypi> oh wait n/m
21:08:44 <Cale> hunteriam: That's not in general true
21:08:57 <Cale> er
21:09:04 <Cale> wait, the whole group G?
21:09:05 <nitrix> Is there a haskell function that composes two predicates?
21:09:10 <hunteriam> I should add
21:09:13 <octopuscabbage> ~CS People go quiet~
21:09:14 <hunteriam> G is a finite group
21:09:21 <emilypi> if g in G, since G is closed under products, gG is in G for all g' in G
21:09:21 <octopuscabbage> nitrix, and?
21:09:30 <nitrix> :t and
21:09:30 <emilypi> it's almost by definition
21:09:31 <lambdabot> Foldable t => t Bool -> Bool
21:09:31 <kaidelong> @hoogle (a -> Bool) -> (a -> Bool) -> (a -> Bool)
21:09:33 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
21:09:33 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
21:09:33 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
21:09:44 <Cale> hunteriam: gG = {g * a : a in G} = G, no matter which element g of G you choose
21:09:47 <octopuscabbage> nitrix, how do you want them composed? there's more than 1 way to compose them
21:10:03 <emilypi> hunteriam: the idea is that for any h in G you pick, the product gh is in G since g is in G under closure of G's binary operation
21:10:09 <Cale> hunteriam: Consider what happens when you multiply through by g^-1
21:10:14 <emilypi> since *:GxG -> G by definition
21:10:20 <kaidelong> mmm well you could use the monoid instance for ->, nitrix
21:10:25 <nitrix> octopuscabbage: As in, the result of both predicate has to be True for the final Bool to be True.
21:10:48 <hunteriam> Ah and so that means any transformations with members of the group and the group operation will always be equivalent to the original group?
21:10:53 <hunteriam> That's very cool
21:10:57 <emilypi> yis
21:11:12 <octopuscabbage> nitrix, there's not a built in (although that's not a bad idea) but you could just do f (.&&.) g = \a -> f a && f b
21:11:12 <kaidelong> @instances Monoid
21:11:14 <Cale> hunteriam: Yeah, the only coset of the whole group is the whole group itself.
21:11:15 <lambdabot> (), (a -> b), (a, b), All, Alt f a, Any, Const a b, Dual a, Expr, Maybe a, Ordering, Product a, Sequenced a m, Sum a
21:11:15 <hunteriam> Cale I'm not seeing the significance
21:11:20 <hunteriam> Cale of g inverse
21:11:34 <kaidelong> nitrix: so you have two ways to compose, All or Any
21:11:36 <emilypi> hunteriam: groups in general represent abstract symmetry. If * is the operation you're considering, it is only a group operation if it preserves the group laws. One of these is closure
21:11:57 <emilypi> in fact, for any algebra, * must maintain closure
21:12:09 <nitrix> kaidelong: I'm interested in `all true`.
21:12:11 <emilypi> what makes it a *-algebra is the set of laws it preserves
21:12:13 <hunteriam> Yes that's very cool but also seemingly makes groups a much smaller category than I thought
21:12:16 <Cale> hunteriam: Well, the function which sends each group element x to g*x has an inverse function, which sends each group element x to g^-1 * x
21:12:22 <emilypi> Group is a small cat, yes
21:12:36 <kaidelong> getAll (mconcat (map (All .) [p1,p2,p3, ...]))
21:12:42 <octopuscabbage> emilypi, group is a kitten, perse
21:12:46 <Cale> hunteriam: Functions which are invertible are bijections.
21:12:50 <emilypi> octopuscabbage: lol'd irl
21:12:51 <kaidelong> or you could use <> aka mappend
21:13:02 <kaidelong> but then you have to lift each of them into All explicitly
21:13:05 <hunteriam> Cale you are now beyond my grasp
21:13:17 <hunteriam> Cale I'll get to bijections some time in the distant future
21:13:19 <Cale> hunteriam: uh, come to #haskell-blah
21:13:21 <emilypi> what. bijections are just isomorphisms in SET :^)
21:13:22 <kaidelong> the lens library helps with this somehow, but I forgot how
21:13:30 <Cale> This isn't about #haskell, so I don't want to put a long explanation here
21:13:33 <hunteriam> Oh well I've never looked them up before
21:13:49 <Cale> You should probably know what bijections are before starting on group theory
21:13:55 <emilypi> ^
21:13:58 <kaidelong> the easiest solution is probably just to do this:
21:14:00 <emilypi> can't learn homos without bi's
21:14:09 <Welkin> :t all
21:14:11 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
21:14:18 <Cale> You probably mean isos
21:14:24 * Clint squints.
21:14:32 <emilypi> Cale: i was trying to make a joke, k? FINE.
21:14:36 <hunteriam> But as much as I want to learn this stuff, I don't really have time I have a lot to lea tonight
21:14:44 <kaidelong> (::.) p q x = p x && q x
21:14:48 <kaidelong> then just use ::.
21:14:49 <hunteriam> A lot of spirit stuff to study
21:14:52 <Welkin> Clint: who are you? Clint Eastwood? I think you have been reading too much LYAH!
21:14:56 <kaidelong> you don't have to export ::.
21:15:00 <kaidelong> you could just use it locally
21:15:15 <Cale> But also, there's another good reason: for any set A, the collection of bijections A -> A is an important example of a group, called the symmetric group on A, or Sym(A).
21:15:16 * Clint gestures ambiguously at Welkin
21:15:42 <hunteriam> Cale I think I will have to study that tonight but it is not yet time to
21:15:48 <Cale> (the group operation being composition of functions)
21:15:49 <hunteriam> Cale I'll be back though don't worry haha
21:15:51 <Cale> okay :)
21:16:14 <emilypi> Sym(A) just represents the set of permutations of a set A 
21:16:23 <hunteriam> Cale also one quick question, the promptly we just talked about where gG = G doesn't seem related to cancellation
21:16:27 <KaneTW> group is a small cat? shouldn't ob(Grp) be a proper class
21:16:27 <hunteriam> Property*
21:16:45 <hunteriam> But this document says it is a consequence of cancellation and the pigeon hole principle
21:17:04 <hunteriam> Surely it's not wrong?
21:17:17 <KaneTW> oh you're talking about a different type of category :v
21:17:34 <Cale> hunteriam: I don't think you need the pigeonhole principle. You kind of can use that in the finite group case, sure, but that's awkward when it works for infinite groups too.
21:17:44 <hunteriam> Sorry I don't remember my category theory/barely know any of it to begin with so I was probably incorrect talking about cats
21:18:16 <hunteriam> Cale, I don't even see how you would use it!
21:18:42 <hunteriam> And by the way thanks for being so helpful
21:18:47 <hunteriam> This community is really incredible
21:18:48 * hackagebot wai-request-spec 0.10.2.0 - Declarative request parsing  https://hackage.haskell.org/package/wai-request-spec-0.10.2.0 (alcabrera)
21:18:54 <emilypi> KaneTW: it is. Since every group admits a forgetful functor to Sets, and the set of homos between any two groups is a set
21:19:07 <emilypi> ya okay sorry missed your last post :P
21:19:08 <Cale> hunteriam: Please let's move this to #haskell-blah though, because this is pretty unrelated to Haskell.
21:19:16 <hunteriam> Ok sure sorry!
21:21:06 <emilypi> now i miss math :)
21:21:37 <emilypi> silly kids and their higher groupoids
21:21:44 <Welkin> emilypi: ##math
21:22:00 <emilypi> Welkin: nupe. won't go back. harassment by creepy members in pm and no bans.
21:22:21 <Welkin> happened to me too
21:22:24 <Welkin> I just ignored it
21:22:32 <Welkin> there seems to be a troll problem over there
21:22:42 <emilypi> did they ask you about your naked body? cuz i'd rather not deal with that on a daily basis
21:32:39 <montanonic> Hey all, I have a funky little problem with Yesod and Template Haskell that I can't just use types to debug! Yay! :(
21:32:50 <montanonic> So, suppose I have this route path
21:33:09 <montanonic>  /my-first-webpage/#Int
21:34:03 <montanonic> The idea being that for every new webpage I create, it goes in the next numbered slot, so my-second-webpage would be at the route address /my-first-webpage/2 (bear with me on the numbering/wording of this)
21:34:29 <montanonic> Every webpage will have a /different/ template source
21:34:42 <montanonic> which means ideally, I'd want my Handler code to be this:
21:35:07 <montanonic> getFirstWebpagesR int = defaultLayout $(widgetFile "my-first-webpage-" ++ show int)
21:35:30 <KaneTW> template haskell is a compile-time construct
21:35:32 <montanonic> the idea being I'd have a bunch of templates with different number suffixes
21:35:40 <Clint> so you do or don't want /my-first-webpage/2 and /my-second-webpage/1 to be valid pages
21:35:49 <montanonic> ^I Do
21:35:56 <KaneTW> you can't do show int there because the value of int isn't known at compile time
21:36:05 <montanonic> yes, exactly
21:36:09 <montanonic> GHC stage error
21:36:26 <montanonic> But unfortunately I don't know how to work around that... I'm a bit of a noob
21:37:09 <montanonic> Clint: sorry, I misread, I want /my-first-webpage and /my-first-webpage/(SOME NUMBER) to be valid
21:37:35 <montanonic> at least, valid for every number that I have a corresponding template to, and to redirect to /my-first-webpage otherwise
21:38:14 <montanonic> the route really ought to be pluralized; at least the route names are
21:38:45 <KaneTW> it's not possible using widgetFile at least because that compiles their html template language into the executable
21:38:57 <KaneTW> you'd have to open a file directly and return it
21:39:00 <montanonic> oh, dang
21:39:10 <KaneTW> if you want to stick to that
21:39:12 <montanonic> Do you know of a different way to implement something like this?
21:39:33 <montanonic> I don't need to, no. I'm just (1) trying to get a blog up, (2) teaching myself Yesod along the way
21:40:05 <KaneTW> create a datatype that stores a blog post
21:40:15 <KaneTW> persist that and just render it
21:40:40 <KaneTW> http://www.yesodweb.com/book/ 
21:40:44 <montanonic> Okay, I'll have to look into those more, but I'll try implementing them once I do
21:41:17 <montanonic> Yeah, I've been using the book, it just tends to be hard to understand more often than I'd like; nonetheless, I'll try to implement your method; thanks a bunch!
21:42:15 <KaneTW> just remember that my method is just a workaround for what you wanted to do originally
21:42:20 <KaneTW> it's not really the yesod way
21:42:57 <montanonic> KaneTW: Okay, I'll keep that in mind. Thanks nonetheless.
21:43:03 <KaneTW> np
22:37:31 <Axman6> anyone familliar with threadscope? I can't use it because it keeps crashing with "user error (out of memory)". I've tried giving it 12GB and it still crashes
22:38:52 * hackagebot ihaskell-diagrams 0.3.1.0 - IHaskell display instances for diagram types  https://hackage.haskell.org/package/ihaskell-diagrams-0.3.1.0 (gibiansky)
22:43:53 * hackagebot egison 3.5.10 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.5.10 (SatoshiEgi)
22:46:21 <KaneTW> that language looks rather ugly
22:47:36 <td123> is there a way to generate haskell at runtime and use it? not sure what that's called
22:48:01 <KaneTW> you'd have to use the GHC API
22:48:17 <td123> something like passing a string to a function at runtime "data Hello = Hello String deriving (Read); read someInput"
22:48:44 <julianleviston> td123: ah, you probably want Hint
22:48:53 <Axman6> it's usually called "eval". there are quite a few ways to do it. obviously GHCi does it
22:48:58 <julianleviston> https://hackage.haskell.org/package/hint
22:49:10 <Axman6> and lambdabot 
22:49:29 <td123> right, I'm not sure the proper name for that
22:49:38 <td123> julianleviston: thanks, I'll check it out
22:49:47 <julianleviston> td123: I’ve been interested in this for a while now too :) 
22:50:29 <KaneTW> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-7.10.2/HscMain.html
22:50:51 <td123> KaneTW: thanks, will also check that out
22:51:10 <td123> julianleviston: I've been interested in it also, but until now I haven't found a good use case for it
22:52:17 <td123> I want to generate types to allow end users generate their own validation rules for data
22:52:39 <julianleviston> td123: you might be better off using Parsec
22:52:43 <julianleviston> I don’t know, just saying.
22:53:19 <td123> but then I would have to reinvent ADTs
22:53:40 <julianleviston> wow…. those are some pretty complex validation rules!
22:54:37 <KaneTW> td123: imo just make your application into a library and have the users do something like main = yourMain [validation_rules...]
22:55:15 <julianleviston> td123: have you checked out the validation package?
22:56:42 <td123> julianleviston: I might have more plans for them in the future so I want to keep the types :)
22:56:48 <julianleviston> all good
22:57:16 <td123> I'm still experimenting so this might be complete overkill, but I think it's interesting by itself
22:57:52 <td123> if this is a stupid idea at least it'll give me an excuse to finally evaluate haskell code at runtime :)
23:11:36 <julianleviston> how does one pronounce <*> ?
23:11:49 <pacak> :t ap
23:11:50 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:11:55 <pacak> :t (<*>)
23:11:56 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:12:26 <pacak> julianleviston: Those two are more or less the same
23:12:37 <liste> http://stackoverflow.com/questions/3242361/haskell-how-is-pronounced
23:13:38 <julianleviston> thanks
23:13:47 <julianleviston> I really liked how (|.|) ends up being called banana
23:14:21 <julianleviston> reminds me a bit of Ruby’s <=> operator… which is called spaceship.
23:15:14 <julianleviston> sorry I should have googled that first
23:15:29 <liste> it's kinda hard to google
23:15:57 <pacak> liste: Not if you know how to pronounce it.
23:16:16 <julianleviston> https://www.google.com.au/search?client=safari&rls=en&q=how+do+you+pronounce+%22%3C*%3E%22+haskell&ie=UTF-8&oe=UTF-8&gfe_rd=cr&ei=gXHyVeW6LcLu8wfRnYG4Cg
23:16:54 <julianleviston> lol “<$>” is brackety-cash
23:17:15 <julianleviston> brackety-splat … that’s awesome
23:17:19 <julianleviston> <*>
23:17:59 <td123> julianleviston: wow hint is really easy to use; import Language.Haskell.Interpreter; runInterpreter $ setImports ["Prelude"] >> eval "head [True,False]"
23:18:09 <julianleviston> td123: yeah it’s great isn’t it.
23:18:54 <td123> really glad I asked cause I probably would have been playing with the ghc api
23:19:07 <td123> I'm guessing it wouldn't nearly be this easy
23:20:24 <julianleviston> Is this the best poem? http://poetry.about.com/od/poetryplay/l/blwakawaka.htm
23:25:14 <td123> nice
23:25:24 <td123> definitely... unique :)
23:30:19 <{AS}> Hi, does there exist a minimal core Haskell language? 
23:30:33 <{AS}> Something like Caml Light :)
23:30:44 <liste> AS there's GHC Core but it's not Haskell
23:30:54 <td123> hmm, do you know how "safe" hint is? is this something that could be used in a user facing application?
23:31:15 <{AS}> liste:  OK, thanks
23:31:23 <liste> but it's not really for writing code
23:31:34 <julianleviston> td123: I’m pretty sure it makes types dynamic… 
23:31:57 <td123> I mean safe in terms of security
23:32:41 <julianleviston> td123: you probably want https://hackage.haskell.org/package/mueval instead.
23:33:15 <julianleviston> it’s basically lambdabot without being lambdabot apparently.
23:33:24 <liste> {AS} what you do want to use the language for?
23:33:43 <{AS}> I want to look into the interpreter :)
23:34:09 <julianleviston> {AS}: what do you mean? 
23:34:22 <julianleviston> {AS}: GHC doesn’t have an interpreter. It compiles things.
23:34:45 <kadoban> GHCi ...
23:34:46 <julianleviston> {AS}: The haskell report is probably your best friend here, if you want to understand the low level of how haskell works...
23:34:49 <{AS}> Sorry (still morning), I meant the semantics of course
23:35:05 <{AS}> julianleviston: Ah, great
23:35:27 <julianleviston> {AS}: it’s actually fairly readable, mostly, too… 
23:35:30 <{AS}> I wanted something with more structure than System FC
23:35:58 <liste> {AS} check this out http://foswiki.cs.uu.nl/foswiki/Helium
23:36:00 <Hafydd> {AS}: if you want to read a (relatively) simple implementation of Haskell, you could look at Hugs.
23:36:29 <liste> Hugs is C though AFAIK?
23:36:37 <{AS}> Great, thanks guys/gals!
23:37:25 <julianleviston> {AS}: It’s possible that this might be really handy, too! : https://hackage.haskell.org/package/haskell-src-exts-1.16.0.1/docs/Language-Haskell-Exts.html
23:37:58 <julianleviston> which is basically the code version of the report.
23:38:14 <{AS}> julianleviston: thanks
23:38:17 <julianleviston> and happens also to be the core of how GHC works ;-)
23:39:03 <julianleviston> {AS}: if you load that up in GHCI, you can even get it to spit out AST for Haskell which is cool… :)
23:39:22 <{AS}> The haskell-src-exts package?
23:39:27 <julianleviston> yeah
23:40:17 <julianleviston> {AS}: :m Language.Haskell.Exts; parseExp "1+1”
23:40:21 <julianleviston> yields ParseOk (InfixApp (Lit (Int 1)) (QVarOp (UnQual (Symbol "+"))) (Lit (Int 1)))
23:41:48 <julianleviston> {AS}: then you can round-trip it (kinda) by prettyPrint ing it
23:42:06 <{AS}> I am assuming it is isomorphic modulo spacing and layout :)
23:42:25 <julianleviston> ooh I don’t know what that means! :)
23:42:35 <julianleviston> what’s modulo spacing?
23:42:53 <{AS}> I meant that we will get the same thing if we ignore spacing and layout 
23:42:59 <julianleviston> oh
23:43:04 <julianleviston> “sorta” :)
23:51:56 <daqo> exit
23:51:57 <daqo> exit
23:51:59 <daqo> exit
23:52:15 <julianleviston> daqo: you need a slash in front
23:52:44 <daqo> \q
23:55:19 <begriffs> Is this still the preferred way to call C functions from Haskell? http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
23:56:15 <liste> begriffs check out inline-c
23:58:16 <begriffs> liste: thank you!
