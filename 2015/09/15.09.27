00:00:01 <bollu> xD
00:00:08 <bollu> really? that would be awesome!
00:00:12 <Myrl> My first idea is to sepBy `> then the resultant elements will be parsed by sepBy `<
00:00:13 <bollu> I've always been intimidated
00:00:26 <athan> I hide usually
00:00:37 * athan feels the earth quake
00:00:41 <athan> O_O
00:00:44 <bollu> Myrl: use python?
00:00:47 <Myrl> So basically, "ab <` c `>" => "ab <` c", "`>" => "ab <`", "c", "`>"
00:01:02 <Myrl> But I'm not quite sure if that's the best way to do it. :(
00:01:12 <Myrl> bollu: Why Python?
00:01:22 <bollu> Myrl: because string manip is nice
00:01:31 <bollu> you can use str.split("<`")
00:01:39 <bollu> and then take the second part of it with [1]
00:01:48 <bollu> then split again with .split("`>")[0]
00:02:02 <bollu> str.split("<`")[1].split("`<")[0]
00:02:08 <bollu> will give you the haskell region
00:02:10 <athan> bollu: Early, I hear that's a good parser combinator lib
00:02:17 <bollu> um, gimme a sec
00:02:23 <bollu> lemme write a python script for you
00:02:27 <bollu> Myrl: can I have the source?
00:02:51 * cmccann recommends the "split" package if you want to do that kind of string mangling in Haskell
00:03:02 <athan> bollu: https://hackage.haskell.org/package/Earley
00:03:14 <johnw> cmccann: you're on IRC a lot more often recentl
00:03:14 <athan> After using {atto}parsec, I'd like to try this one
00:04:03 <cmccann> johnw: I come and go depending on my free time and tbh how burnt out I am from the day job
00:04:33 <johnw> well, it's nice to see you around more
00:04:47 <cmccann> thanks :]
00:05:01 <cmccann> bollu: btw, https://twitter.com/pigworker is Conor McBride
00:05:04 <bollu> input_str = input()
00:05:05 <bollu> while input_str != "":
00:05:05 <bollu>     haskell_part, input_str = input_str.split("<`")[1].find("`>")
00:05:05 <bollu>     print(haskell_part)
00:05:05 <bollu>     print("-------")
00:05:11 <bollu> yay to python's terseness :)
00:05:24 <Myrl> bollu: No source yet.
00:05:31 <botter> Has anyone here bought the 'Haskell Book' from haskellbook.com? How does it compare to free material online?
00:06:04 <Myrl> bollu: I can see what you're trying to do there, and that also seems to be how I plan to do it.
00:06:08 <athan> botter: It's a hand-tailored suite of beginner-level material (well, beginner through intermediate)
00:06:20 <athan> I wish I could, but I haven't purchased it yet
00:06:29 <bollu> wait, should be .split() again not .find()
00:06:36 <athan> getting you haskell-ready from the ground up
00:06:48 <botter> I'm wondering whether I should take the plunge and buy it or work through stuff like the cis194 courses first
00:06:53 <cmccann> > (splitOn "<") <=< (splitOn ">") $ "foo <bar> baz"
00:06:55 <lambdabot>  ["foo ","bar"," baz"]
00:07:10 <cmccann> botter: is that bitemyapp's book?
00:07:40 * hackagebot pandoc-citeproc-preamble 1.0.0 - Insert a preamble before pandoc-citeproc's bibliography  https://hackage.haskell.org/package/pandoc-citeproc-preamble-1.0.0 (spwhitton)
00:07:40 * hackagebot nested-routes 5.0.0 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-5.0.0 (athanclark)
00:07:44 <Myrl> cmccann: That seems nice.
00:07:48 <athan> cmccann: Yeah it is
00:08:11 <cmccann> Myrl: I think that function is from http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html 
00:08:22 <Myrl> > (splitOn "<`") <=< (splitOn "`>") "<html> <body> <` putStrLn =<< getContents `>"
00:08:23 <lambdabot>      Couldn't match expected type ‘a -> [[Char]]’
00:08:24 <lambdabot>                  with actual type ‘[[Char]]’
00:08:24 <lambdabot>      Possible cause: ‘splitOn’ is applied to too many arguments
00:08:27 <Myrl> Lol
00:08:36 <cmccann> you missed the $
00:08:45 <athan> woo hoo! My routing library finally uploaded! https://hackage.haskell.org/package/nested-routes-5.0.0/docs/Web-Routes-Nested.html
00:08:51 <Myrl> > (splitOn "<`") <=< (splitOn "`>") $ "<html> <body> <` putStrLn =<< getContents `> </body> </html>"
00:08:52 <lambdabot>  ["<html> <body> "," putStrLn =<< getContents "," </body> </html>"]
00:08:58 <jle`> congrats athan :)
00:09:00 <Myrl> Woah. That's perfect.
00:09:08 <bollu> ooh, nice
00:09:10 <Myrl> Well, not *that* perfect, but that's pretty good.
00:09:10 <cmccann> athan: hackagebot beat you to the announcement ;P
00:09:11 <athan> jle`: Thank you :)
00:09:18 <athan> :x
00:09:21 <bollu> wait, why does the monadic copmposition work?
00:09:34 <cmccann> bollu: why wouldn't it?
00:09:34 <Myrl> > (splitOn "<`") <=< (splitOn "`>") $ "<html> <body> <` putStrLn =<< getContents `> <` print 1 `> </body> </html>"
00:09:36 <lambdabot>  ["<html> <body> "," putStrLn =<< getContents "," "," print 1 "," </body> </h...
00:09:36 <athan> bollu: nondeterminism of lists
00:09:47 <cmccann> the monad is [] if that's what you're wondering
00:09:49 <athan> er - that's it's monad
00:09:59 <bollu> oh my god that is brilliant
00:10:02 <bollu> fuck
00:10:07 <Myrl> Lol, wow.
00:10:21 <Myrl> I agree, that's brilliant.
00:10:27 <bollu> that will take care of nesting as well, right?
00:10:36 <bollu> now I feel bad for my python code :(
00:10:44 <Myrl> There won't be nesting, but I do need to handle strings.
00:11:02 <Myrl> But for now, that's just perfect.
00:11:13 <cmccann> it splits on every occurance of the given string
00:11:38 <Myrl> cmccann: Do you have an idea how to do it in a Parsec way?
00:11:53 <athan> ughhs
00:12:17 <athan> Myrl: it's complicated
00:12:18 <cmccann> Myrl: it should be simple but my memory for parsec's API is not the best
00:12:42 <Myrl> athan: Even just the latter code?
00:12:45 <cmccann> Myrl: doing the exact same thing as the splitOn example should be trivial. anything smarter may or may not be easy
00:12:46 <Myrl> The former*
00:12:58 <Myrl> cmccann: I'm fine with the earlier* code.
00:13:18 <Myrl> I think I can manage after that.
00:13:32 <athan> Myrl: I am lying sorta, parsec can be pretty easy, it can just be a pain to see how characters are "consumed" by the parser
00:13:52 <cmccann> Myrl: what are you looking for again? <` and `>?
00:13:57 <Myrl> cmccann: Mhm.
00:14:07 <cmccann> and I assume that < and > alone can appear anywhere
00:14:18 <athan> you do things like `parser2Result <- parser1 *> parser2` often
00:14:54 <Myrl> cmccann: Mhm.
00:14:57 <bollu> equivalent python code:
00:14:58 <bollu> input_str = input()
00:14:59 <bollu> begin_splits = input_str.split("<`")
00:14:59 <bollu> for section in begin_splits:
00:14:59 <bollu>     section = section.split("`>")
00:14:59 <bollu>     if section and section[0].strip():
00:14:59 <bollu>         print(section)
00:15:11 <bollu> the list monad makes it much nicer, I agree
00:15:22 <cmccann> Myrl: you probably want to start with something like manyTill anyChar (try $ string "<`")
00:15:28 <bollu> you can probably list-comprehensify it for neatness
00:15:36 <cmccann> that should parse everything up to that string as one string
00:15:45 <Myrl> Yeah.
00:16:12 <cmccann> then same idea for '>, then something to read until EOF
00:16:36 <cmccann> you can probably also use between or whatever
00:17:17 <cmccann> Myrl: is that enough to start from?
00:17:21 <Myrl> cmccann: Mhm.
00:18:39 <Myrl> cmccann: Thanks.
00:18:57 <cmccann> bollu: fun fact, list comprehensions are basically monadic expressions 
00:19:01 <cmccann> Myrl: no prob
00:20:57 <bollu> cmccann: I know!
00:21:12 <bollu> cmccann: they're the equivalent of using do notation with lists, correct?
00:21:21 <bollu> I was blown away when I made that connection in my head
00:21:24 <cmccann> yes
00:23:22 <cmccann> bollu: in Haskell they even use the same <- as do blocks
00:23:30 <cmccann> python is "for foo in bar" or whatever
00:24:02 <athan> Guys, I need 2 people to download nested-routes
00:24:04 <athan> please do this
00:24:11 <bollu> cmccann: whoa, I'd never made that syntax connection
00:24:12 <athan> I'm 2 away from 1337
00:24:15 <bollu> athan: I'm your man
00:24:18 <bollu> how do I do that?
00:24:32 <bollu> cabal install?
00:24:37 <athan> bollu: `(stack | cabal) unpack nested-routes` :)
00:24:49 <cmccann> athan: since it's for a good cause I suppose I could help
00:24:56 <bollu> done
00:24:56 <athan> YES
00:24:56 <bollu> :D
00:24:59 <athan> thank you :D
00:25:03 <bollu> np!
00:26:18 <cmccann> athan: urgh or maybe not, it depends on like three dozen things I don't have installed
00:26:32 <athan> cmccann: I don't blame you :\
00:26:38 <athan> it's pretty heavy
00:26:50 <bollu> interesting, stack just pulled it
00:27:02 <bollu> I tried contributing to stack
00:27:07 <bollu> but I got lost i the source code >_>
00:27:08 <athan> bollu: Yep, that downloads the source code
00:27:17 <bitemyapp> athan: I'll install it.
00:27:18 <athan> :\
00:27:25 <athan> bitemyapp: :D!!
00:27:26 <bitemyapp> athan: wait, do I need to install it or cabal get it?
00:27:30 <bollu> athan: would be running unpack again work?
00:27:48 <athan> bitemyapp: Either should work :s
00:28:05 <athan> bollu: I don't think so - it would download to the same directory
00:28:08 <bollu> athan: check one?
00:28:11 <bollu> check once*
00:28:16 <bollu> I did unpack it right now, again
00:28:21 <bollu> deleted the old version
00:28:31 <athan> I think there's a lag on the download count :\
00:28:43 <bollu> hahaha, possibly
00:28:44 <athan> now it's going to spike to 1338. I'm not leeb
00:29:14 <bitemyapp> athan: I unpacked - i think the totals are calculated asynchronously as I faintly recall from my last unhappy plunging through Hackage's source.
00:29:43 <bollu> you gusy are so cool
00:29:49 <bollu> when I be as leet >_>
00:30:19 <athan> bitemyapp: That would make sense. Sorry to hear that though :\ what's your biggest gripe on it?
00:30:27 * athan is secretly plotting to revamp lots
00:30:50 <cmccann> edwardk: the nice thing about introducing a replacement for CPP is that even if it doesn't have universal support you can CPP around it for the people on old compilers
00:30:52 <cmccann> wait
00:30:55 <athan> bollu: :) glad to have you here
00:31:16 <bitemyapp> athan: Happstack, weird pure/IO logic split.
00:31:23 <bitemyapp> cmccann: LOL
00:31:32 <bitemyapp> cmccann: dude I am dying
00:31:44 <bollu> athan: ty :)
00:32:02 <cmccann> bitemyapp: it's funny because it's true
00:32:09 * athan gets fiendish
00:32:13 <bollu> oh my god how many submodules does GHC have?
00:32:24 <bollu> johnw: when will this neverending torrent of download stop? :P
00:32:27 <cmccann> bollu: a countable number
00:32:48 <athan> bollu: Did you add a `--max-depth`?
00:32:52 <bitemyapp> cmccann: CPP is evil but I love my -Wall clean builds too much.
00:32:52 <cmccann> also this seems relevant
00:32:53 <cmccann> @quote shachaf GHC
00:32:53 <lambdabot> shachaf says: I like to put all my application's modules under GHC.* That's because I use the GHC API, and I want them not to conflict.
00:33:21 <athan> sorry, --depth
00:33:24 <cocreature> cloning is still fairly fast if you compare it to the compile time
00:33:36 <cmccann> bitemyapp: for context there's a discussion on /r/haskell in the Haskell' post about replacing CPP
00:33:50 <bitemyapp> cmccann: I would love if it if we had our own CPP.
00:34:06 <cmccann> I just can't help but see the entire idea as hopelessly optimistic because if you can't rely on it it defeats the whole purpose
00:34:34 <bollu> athan: naw, I didn't want to do a shallow clone
00:34:37 <bitemyapp> cmccann: why wouldn't we be able to rely on our own CPP?
00:34:39 <bollu> mught as well have the history
00:34:47 <bitemyapp> cmccann: are you worried about post-release changes?
00:34:51 <cmccann> bitemyapp: in old GHCs?
00:34:59 <cocreature> afaik acowly has a pure haskell cpp that he uses
00:35:03 <cmccann> or whatever else
00:35:07 <bitemyapp> oh yeah there'd probably be an interdict.
00:35:12 <cmccann> I mean, if it's compatible enough with CPP that's fine
00:35:19 <bitemyapp> I can't see why it wouldn't.
00:35:19 <cmccann> but then it's also not really any nicer than CPP
00:35:27 <bitemyapp> I think the intent is not to make something "nicer"
00:35:29 <johnw> bollu: it challenges your devotion; this is but the first trial
00:35:37 <bitemyapp> but to smooth out minor differences in different CPP implementations and otherwise keep it compat.
00:35:47 <bollu> johnw: I've heard GHC has like 3 sub languages?
00:35:58 <cmccann> bitemyapp: that may be true
00:36:25 <bitemyapp> cmccann: I would strongly oppose any attempt to "enhance" CPP unless it somehow regularizes or makes it more predictable.
00:36:29 <cmccann> bitemyapp: but I'm afraid it might be like the record syntax issue; everyone agrees the current solution is bad, nobody can agree on exactly what to replace it with
00:36:36 <bollu> one that's a subset of haskell, one that's pure and stuff? Idk, I remember vaguely reading about it
00:36:41 <athan> bollu: The last step is really a (slightly funky) calculus implementation
00:36:45 <bitemyapp> cmccann: I just don't want spurious issues occurring between CPP on Win vs. BSD vs. GNU/*
00:36:47 <johnw> bollu: you mean, Core, Cmm, System FC, that kind of thing?
00:36:50 <bollu> athan: what calculus?
00:36:51 <athan> SystemFC_pro :)
00:36:53 <bollu> johnw: yes
00:37:00 <bollu> athan: which calculus*
00:37:07 <bitemyapp> bollu: the lambda one
00:37:09 <cmccann> bitemyapp: yeah, can't argue with that
00:37:12 <bollu> systemF being the second order logic one?
00:37:14 <bitemyapp> I think it has lambdas.
00:37:16 <bollu> bitemyapp: ah, right :)
00:37:16 <athan> bollu: One step under SystemF_omega
00:37:18 <bitemyapp> we're here for the lambdas right?
00:37:20 <athan> er kinda
00:37:23 <bitemyapp> I came here for the lambdas.
00:37:27 <bitemyapp> don't tell me I was lied to.
00:37:27 <athan> it's in a different league really
00:37:29 <cmccann> it's all about the lambdas
00:37:35 <athan> cause coercions
00:37:45 <bitemyapp> I'm all about the lambdas. and llamas. and dollas.
00:37:47 <bollu> athan: all I know about system F is that you can't implement unification for it :P
00:37:57 <johnw> bitemyapp: they all grow up to be sheepdas
00:38:02 <bitemyapp> johnw: llamas are bad ass.
00:38:23 <athan> bitemyapp: No, sorry no lambdas here
00:38:27 <athan> just Some Kode
00:38:36 <bollu> I don't remember whom, but someone with inifite patience explained HKT to me the first time. I am forever in their debt
00:38:40 <bollu> because I was sooo damn stupid
00:38:49 <cocreature> hkt?
00:38:50 <bollu> I took so so long to get what the was "higher kinded" about it
00:38:54 <bollu> higher kinded types
00:38:55 <athan> bollu: :) you'll get there
00:38:56 <cocreature> ah
00:39:01 <athan> search "prenex polymorphism"
00:39:08 <cmccann> bitemyapp: you can tell how important lambdas are to us since we're using a language named for a guy famous for inventing point-free style
00:39:20 <bollu> also, when I was trying to implement my language
00:39:21 <athan> bollu: Actually, read "Types and Programming Languages"
00:39:33 <bollu> I kept asking people for what algorithm haskell / rust uses
00:39:40 <bollu> everyone bloody says "modified HM"
00:39:42 <bitemyapp> athan: I mentioned prenex at LambdaConf to a Scala user asking if Haskell had some flaw it doesn't have and got looked at like I was crazy.
00:39:48 <bollu> what "modification"? no one has a reference ;_;
00:39:52 <bitemyapp> bollu: I could tell you
00:39:55 <bollu> I ended up bastardising it
00:39:57 <bitemyapp> bollu: but if you try to read the paper, you'll die
00:39:59 <bollu> bitemyapp: really?
00:40:03 <bitemyapp> bollu: It's Outside-In
00:40:08 <cmccann> oh no
00:40:16 <bollu> what does that mean?
00:40:17 <bitemyapp> cmccann: I thought it was Outside-In?
00:40:17 <athan> bollu: They use the Outside-In technique for unification, I think
00:40:23 <athan> instead of Alg. W or Bottom-Up
00:40:33 <cmccann> isn't Outside-In the thing that's so horrifying that nobody wants to standardize TFs 
00:40:39 <bitemyapp> bollu: it's Outside-In because it makes the inferencer do a better job in cases we care about in Haskell.
00:40:40 <bollu> athan: I know understand kinds. Didn't before.
00:40:44 <cmccann> because then they'd have to think about it
00:40:45 <bitemyapp> cmccann: yes, that's why I said "die"
00:40:48 <bollu> and what's wrong with outside in?
00:40:49 <bollu> what?
00:40:54 <bitemyapp> bollu: nothing's wrong with outside-in
00:41:00 <bitemyapp> bollu: it's just...pragmatic. lol.
00:41:09 <bollu> okay. run me through it?
00:41:15 <athan> :|
00:41:17 <bitemyapp> so people that would want a more formal story for it would have a challenge.
00:41:18 <cmccann> hahaha
00:41:24 <bitemyapp> bollu: run you through it?
00:41:33 <bollu> bitemyapp: the alorithm, Outside in
00:41:41 <bollu> gimme a pseudocode algorithmic explanation?
00:41:51 <athan> bollu: do you know how constraint solving works?
00:42:07 <athan> er... can, potentially work?
00:42:12 <bitemyapp> I don't think I'm qualified to explain OutsideIn
00:42:20 <bollu> athan: yes, vaguely. What type of constraints? (In general, I understand the theory) (Linear constraints I know the algorithm)
00:42:22 <bitemyapp> it's something you'd build up to
00:42:32 * athan sees a mountain that needs FLIPPING >:C
00:42:35 <bitemyapp> by implementing a basic HM type inferencer or something
00:42:43 <bollu> bitemyapp: I've written HM
00:42:51 <bitemyapp> bollu: well in that case
00:42:54 <athan> bollu: Not simplex, we talking straight SAT prollems up in this piece
00:43:03 <bitemyapp> bollu: https://wiki.haskell.org/Simonpj/Talk:OutsideIn http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf 
00:43:19 <cmccann> to switch to a somewhat less sophisticated topic, I think this is my new favorite ACME package: http://hackage.haskell.org/package/acme-flipping-tables-0/docs/Acme-Error.html
00:43:31 <bollu> bitemyapp: my god, as he says in numeral recipes, the quote is very representative of type theorists as well: "the acolytes of linear optimization lovingly care for their thicket of terminology"
00:44:22 <bitemyapp> cmccann: thanks, I needed a new way to make my coworkers hate me.
00:44:43 * bitemyapp tries to be net-negative in bottom count with the codebase
00:44:49 <bollu> "free", "bound", "abstraction", "generalization"
00:44:50 <cmccann> bitemyapp: the upsidedown text thing really elevates it from just kidna silly to true magnificence
00:45:02 <bollu> I wanted to cry at the end of reading the theory for the first time
00:45:20 <bitemyapp> cmccann: Acme.Trollin
00:45:25 <bollu> Cool, thanks for the paper!
00:46:04 <athan> bollu: :)
00:46:35 <bollu> oh, I also wanted to read, what was it? "the spineless tagless G machine"
00:46:39 <bollu> but I think it was paywalled
00:46:44 <bitemyapp> there's this weird problem
00:46:53 <bitemyapp> where the foundational material to Haskell is reasonably thorough
00:46:57 <bollu> yes?
00:47:00 <bitemyapp> (SPJ's book, for example)
00:47:06 <bitemyapp> but the "current" stuff is a diaspora of papers.
00:47:09 <bitemyapp> needs a reconsolidation
00:47:24 <bitemyapp> bollu: anyhoo, give this a shot: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
00:47:37 <bollu> whooaaaaaa
00:47:43 <bitemyapp> bollu: STG http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
00:47:55 <bollu> holy shit, that is awesome!
00:48:10 <bollu> I had no idea there was an entire book-like thing on implementing FP languages
00:48:18 <bollu> does it go into compilation and code gen as well?
00:48:30 <cmccann> @quote syntaxglitch papers
00:48:30 <lambdabot> syntaxglitch says: SPJ is actually an infinite list of papers, if you read all he has so far it'll force the next thunk and he'll have a new one
00:48:38 <bollu> (optimisations for FP languages specifically)
00:48:43 <bollu> lol
00:49:15 <bollu> I like how you can show the simple idea of thunking in scheme
00:49:20 <bollu> chapter 4 of SICP, I think
00:49:40 <bollu> I don't know if it's possible to encode it in Haskell?
00:49:44 <athan> Alright yall I'm hitting the hay. Goodnight!
00:49:48 <bollu> Thunk a :: () -> a
00:49:51 <bollu> is that possible?
00:50:07 <athan> bollu: There's implicit thunks every where. Also..
00:50:11 <athan> @hoogle force
00:50:12 <lambdabot> Control.DeepSeq force :: (NFData a) => a -> a
00:50:12 <lambdabot> package force-layout
00:50:12 <lambdabot> Graphics.UI.GLUT.DeviceControl forceJoystickCallback :: MonadIO m => m ()
00:50:13 <cmccann> generally, in Haskell you'd just have... the expression
00:50:16 <bollu> athan: yes, implicitly I know
00:50:35 <bollu> but, like, in scheme I can "create" a thunk by simply wrapping a lambda around it
00:50:43 <athan> bollu: Yep
00:50:43 <bollu> but I don't think that will typecheck in haskell
00:50:54 <bollu> hm, maybe a forall will work?
00:50:55 <athan> Well, you can make it typecheck :P
00:50:59 <athan> and do lazy pattern matching
00:51:01 <bollu> Think a :: forall x . x -> a?
00:51:02 <athan> :|
00:51:06 <bollu> no?
00:51:13 <athan> :v
00:51:20 <bollu> do I not understand forall? :(
00:51:32 <athan> bollu: may the source be with you
00:51:40 <bitemyapp> bollu: universal quantification
00:51:45 <bollu> bitemyapp: yes
00:51:52 <bollu> that seemed like a logical thing to do
00:51:57 <bitemyapp> bollu: the forall is implicit in Haskell types.
00:51:58 <bollu> the Thunk bit
00:52:08 <bollu> but only to the right of the arrow, right?
00:52:23 <bollu> not to the left?
00:52:30 <bitemyapp> oh you're saying it's going to return some a and you can't know the a?
00:52:37 <bollu> yupp
00:52:40 <bitemyapp> that doesn't seem inhabited without more type information.
00:52:50 <bollu> hm
00:52:51 <bollu> okay
00:52:53 <bitemyapp> a -> a   works because it you have the "any given a" in the negative position.
00:53:01 <bitemyapp> so it's just demanding the very thing it's going to spit back out
00:53:32 <bitemyapp> without some kind of witness or origin it's just going to be empty (save bottom)
00:53:42 <bollu> what about this, then?
00:53:43 <bollu> thunk :: a -> (forall x. x -> a) 
00:53:53 <bollu> thunk a = \_ -> a
00:54:02 <bollu> wait, you don't need the forall here
00:54:04 <bollu> that's just const
00:54:16 <bitemyapp> yeah that's not the same type you showed earlier
00:54:35 <bitemyapp> and yes it's const.
00:54:37 <bitemyapp> @ty const
00:54:38 <lambdabot> a -> b -> a
00:56:26 <bollu> johnw: do I enable stage1 or stage2?
00:56:34 <bollu> the instructions say stage2
00:56:37 <bollu> for the build flavor
00:56:48 <johnw> bollu: yes, follow the instructions
00:57:22 <bollu> what's "happy" ?
00:57:29 <bollu> ghc wants happy to compile
00:57:36 <johnw> it's the Haskell version of yacc
00:57:39 <cmccann> well it can't compile if it's sad
00:57:45 <johnw> cabal install happy on your system
00:57:47 <bollu> parser generator generator?
00:57:49 <johnw> yes
00:57:52 <johnw> and alex too, the lexer
00:58:01 <bollu> heh
00:59:02 <bollu> I'm terrified of cabal hell
00:59:10 <johnw> bollu: heading to sleep now, good luck; ask in #ghc if you have more questions
00:59:18 <bollu> thanks :)
00:59:20 <bollu> and night!
01:04:24 <Myrl> Hmmm
01:04:28 <Myrl> :t
01:04:31 <Myrl> >:t
01:04:39 <Myrl> @t between
01:04:39 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
01:04:47 <Myrl> @type between
01:04:48 <lambdabot> Not in scope: ‘between’
01:04:56 <Myrl> @type symbol
01:04:57 <lambdabot>     Not in scope: ‘symbol’
01:04:57 <lambdabot>     Perhaps you meant ‘isSymbol’ (imported from Data.Char)
01:05:03 <Myrl> @type Text.Parsec.Token.symbol
01:05:04 <lambdabot> Text.Parsec.Token.GenTokenParser s u m -> String -> Text.Parsec.Prim.ParsecT s u m String
01:05:09 <Myrl> What the fuck
01:05:37 <cmccann> Myrl: that is almost certainly not what you want, heh
01:06:13 <Myrl> cmccann: ikr? :(
01:06:17 <cmccann> what are you looking for?
01:06:26 <Myrl> At least "string" works.
01:06:47 <Myrl> between open close p parses open, followed by p and close. Returns the value returned by p.
01:06:50 <Myrl> > braces = between (symbol "{") (symbol "}") 
01:06:52 <lambdabot>  <hint>:1:8: parse error on input ‘=’
01:07:03 <Myrl> cmccann: That's from hoogle's description of "between"
01:07:21 <cmccann> ...that doesn't seem like very helpful documentation
01:07:56 <cmccann> anyway yeah, string should be fine for that
01:08:51 <Myrl> Hmmm....
01:09:08 <Myrl> Ugh.
01:09:20 <Myrl> I never thought that I'd hate greediness this much.
01:10:07 <cmccann> is it failing because a parser consumes some input?
01:10:23 <Myrl> Perhaps I should try parse (between (try string...) ?
01:11:23 <cmccann> I can't remember if string backtracks on its own, but yeah if it's finding half the string and then failing out "try" should fix it
01:11:39 <Myrl> cmccann: Strings dont' backtrack.
01:12:10 <cmccann> Myrl: if you look back at my initial suggestion with manyTil I think I used "try" there to be safe
01:12:19 <Myrl> Hmmm...
01:13:11 <cmccann> ah yes. I also asked you if < and > could appear on their own.
01:13:43 <cmccann> and now you know why! 
01:13:55 <Myrl> Even try $ manyTill wouldn't work.
01:15:11 <cmccann> using (try $ string "<`") or such doesn't work?
01:15:13 <Myrl> Hmmm...
01:16:02 <Myrl> Hmm...
01:16:17 <Myrl> Oh, I think I now know why.
01:17:04 <Myrl> Or not.
01:17:27 <Myrl> Hmmm...
01:17:30 <cmccann> if you lpaste your parser code I might be able to give better advice
01:17:48 <Myrl> I may have just found a use-case for monads.
01:18:06 <Myrl> I think I'll do this in a roundabout way.
01:18:32 <Myrl> Or not.
01:18:47 <Myrl> cmccann: The code I'm trying otu is "parse (between (char '<') (char '>') (many anyChar))"
01:19:48 <pavonia> anyChar consumes the '>', I guess
01:19:56 <cmccann> yeah
01:20:05 <Myrl> pavonia: That's what I'm thinking of too, but I tried it by itself.
01:20:15 <cmccann> (many anyChar) is gonna eat everything
01:20:29 <Myrl> > parse (manyTill anyChar (try $string "`>")) "" "<`lol`>"
01:20:30 <lambdabot>  Not in scope: ‘parse’Not in scope: ‘manyTill’Not in scope: ‘anyChar’    Not ...
01:20:31 <lambdabot>      Perhaps you meant one of these:
01:20:31 <lambdabot>        ‘storing’ (imported from Control.Lens),
01:20:34 <Myrl> ...
01:20:44 <cmccann> try using (many $ noneOf "<>") 
01:20:47 <Myrl> > parse (manyTill Text.Parsec.Char.anyChar (try $ Text.Parsec.string "`>")) "" "<`lol`>"
01:20:48 <cmccann> instead of anyChar
01:20:48 <lambdabot>  Not in scope: ‘parse’Not in scope: ‘manyTill’Not in scope: ‘Text.Parsec.Char...
01:21:06 <Myrl> cmccann: Hmmm, what's the noneOf equivalent for parsers?
01:21:59 <cmccann> I think notFollowedBy lets you do that?
01:22:10 <cmccann> e.g. notFollowedBy (p1 <|> p2)
01:22:10 <Myrl> Ah, right.
01:22:19 <cmccann> or something like that.
01:22:56 <Myrl> Also, I found some resource that may be able to help me.
01:22:59 <Myrl> http://book.realworldhaskell.org/read/using-parsec.html
01:23:09 <Myrl> I'm not talking about the book itself, but the example code.
01:23:15 <cmccann> might be slightly out of date
01:23:26 <Myrl> It shows how to handle things that are inside strings.
01:23:27 <cmccann> the content is good but I can't promise the example code will all work as-is
01:24:12 <cmccann> but yeah, otherwise that's a good place to start
01:24:24 <Myrl> Though, this uses Parsec as a monad.
01:27:25 <Myrl> Well, I'll go watch something for now.
01:27:48 <Myrl> When all else fails, watch something. :)
01:28:00 <cmccann> sounds like a plan
01:30:26 <Gurkenglas> What do you call a structure that has <*> but not fmap?
01:31:52 <tsahyt> Gurkenglas: Does it have pure?
01:32:01 <L8> off topic question: Irish people, should I visit Dublin on the weekend, or on the workweek?
01:32:18 <cmccann> if it has pure, you call it something that actually does have fmap
01:32:19 <julianleviston> L8:  dude.
01:32:31 <Gurkenglas> tsahyt, if it had pure and <*> it would have fmap so no :P
01:32:41 <tsahyt> Just wanted to make sure :)
01:32:43 <L8> I have no Irish friends :(
01:33:14 <pavonia> Gurkenglas: Oleg calls it SemiApplicative
01:33:42 <bollu> total noob here, but I think I saw it decomposed as Pointed + Apply?
01:34:00 <gamegoblin> Is there anything at all different (with regard to semantics, performance, laziness, etc) between "foo x y = bar (x+y)" vs. "foo x = \y -> bar (x+y)"
01:34:27 <Guest92> hi. is there any way to specify package from which to import from the code?
01:34:32 <jle`> gamegoblin: i believe that both desugar to foo = \x -> \y -> bar (x + y), except you might have some issues with the monomorphism restriction
01:35:06 <jle`> Guest92: -XPackageImports
01:35:13 <cocreature> Guest92: yes see 7.3.21 here https://downloads.haskell.org/~ghc/7.6.3/docs/html/users_guide/syntax-extns.html
01:35:38 <Guest92> thanks
01:35:50 <jle`> gamegoblin: with the monomorphism restriction on, GHC treats them differently for the purpose of type inference, i think
01:35:52 <Gurkenglas> The structure is "Queries to lambdabot", and represented by strings. Any Haskell value can be acquired by wrapping its code in a string and prepending @run, but "wrap your code in a string pls" is not an implementation of pure :I
01:36:01 <cocreature> eh those docs are ancient, but I don't think anything changed
01:36:04 <tsahyt> gamegoblin: Assuming explicit type signatures, they're definitely identical
01:36:49 <cocreature> hm I wonder if we could get links to specific sections in the ghc docs
01:37:27 <Gurkenglas> (It even has join!)
01:37:35 <Mattacker> http://pastebin.com/hmzjuLH8 <-- check this paste ! and help me out...
01:37:54 <cocreature> @ops
01:37:54 <lambdabot> Maybe you meant: pl oeis docs
01:38:14 <cocreature> @where ops
01:38:14 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
01:38:24 <cocreature> Mattacker is spamming
01:38:34 --- mode: ChanServ set +o Cale
01:38:44 --- mode: Cale set +b *!*@178-84-111-121.dynamic.upc.nl
01:38:44 --- kick: Mattacker was kicked by Cale (Mattacker)
01:39:01 <cocreature> thanks
01:39:16 <jle`> thank you cocreature , concerned citizen
01:39:49 <Gurkenglas> You could have put that into one line via: "@@ Mattacker is spamming @where ops"
01:40:07 <Cale> heh
01:40:13 --- mode: Cale set -o Cale
01:40:32 <cocreature> Gurkenglas: the problem is that next time I need this I will already have forgotten that syntax
01:41:03 <Guest92> cocreature can I specify -XPackageImports also from code? :)
01:42:10 <cocreature> Gurkenglas: yes put a language pragma at the top of your file: {-# LANGUAGE PackageImports #-}
01:42:22 <Gurkenglas> Thanks.
01:42:32 <cocreature> eh ^ alekspak 
01:43:20 <alekspak> thanks
02:03:14 <joco42_> is there a way to derive automatically the EQ Show instances ?
02:03:32 <joco42_> so that i don't have to write it out all the time ... deriving (Eq, Show)
02:03:36 <joco42_> is three something for that?
02:05:08 <joco42_> http://pasteboard.co/WSRufnk.png
02:05:15 <joco42_> for example there ?
02:06:39 <tsahyt> joco42_: You can't always derive Eq. For example newtype Fun a b = Fun (a -> b) doesn't have an Eq instance. And neither does it have a Show instance for that matter.
02:06:49 <joco42_> yes :)
02:06:59 <joco42_> tsahyt: i see, but when it is derivable
02:07:05 <joco42_> for simple stuff
02:07:13 <tsahyt> I guess you could hack something together with TemplateHaskell but I don't think it would be worth the effort
02:07:34 <joco42_> tsahyt: ok, good to know... i was thinking about this myself...
02:07:40 <tsahyt> In particular, it probably wouldn't aid readability.
02:07:41 <joco42_> but yeah...
02:07:48 <tsahyt> You could automate the task in vim though
02:08:10 <tsahyt> Abbreviations, snippets, etc. are all options for that
02:08:18 <tsahyt> That would at least spare you the typing
02:08:26 <joco42_> ok, that is an option... i goggle that...
02:09:48 <tsahyt> ":abbreviate dse deriving (Show, Eq)" will insert the deriving clause when you type "dse" in insert mode with a space after it. UltiSnips is a lot more sophisticated.
02:10:25 <joco42_> http://www.asayers.org/pages/haskellmode.html
02:10:34 <joco42_> nice
02:10:36 <joco42_> thanks
02:11:35 <joco42_> this goes into my vimrc :)
02:12:32 <tsahyt> Interesting that the haskell snippets in vim-snippets don't actually have a deriving clause anywhere
02:17:48 <joco42_> yeah
02:19:59 <cmccann> why is someone making nearly-unintelligible posts to /r/haskell every 10-15min
02:20:15 <tsahyt> Such as?
02:20:39 <cmccann> such as https://www.reddit.com/r/haskell/comments/3mk5k1/there_is_no_difference_between_using_rev_and_not/
02:20:58 <cmccann> like I think this person is trying to ask a question but... come on
02:21:17 <cmccann> kamatsu: sadly I am pretty sure that's not autogenerated
02:21:38 <tsahyt> The title sure looks like something generated with markov chains to me
02:21:44 <tsahyt> But you might be right
02:23:28 <cmccann> I hate removing posts that aren't off-topic/spam but these almost might as well be
02:23:49 <Gurkenglas> There should be a tool to check how likely something is to be generated by markov chains. It sounds like the sort of thing that should be theoretically possible
02:24:36 <cmccann> no, this is just someone trying to ask questions in a non-native language and also mangling the formatting
02:24:37 <Jinxit> difficult without having the source material
02:24:57 <Jinxit> if it was a long text based on short source material it might be possible, Gurkenglas 
02:25:17 <buggs> Gurkenglas, via which vector?
02:28:37 <cmccann> sigh. I sent the guy a message asking him to submit only one post and format it properly
02:30:07 <tsahyt> I love how there's a snippet in vim-snippets for do notation, which apparently just outputs do and a newline when expanded.
02:32:10 <tsahyt> Pretty much the same goes for the -> and <- snippets. You have to type the left and right side out anyway. You don't even save keystrokes on the spaces, because you have to C-j to the next component with the snippet.
02:47:08 <ttt_fff> what's a good tutorial on "how to impelment parsec in haskell from scratch" ?
02:48:34 <tsahyt> http://www.cs.nott.ac.uk/~pszgmh/pearl.pdf is a good start I think
02:55:44 <platzhirsch> Any idea how to generate these numbers a bit shorter rather than hard coding them? [0, 2, 2, 3, 3, 3, 3, 3, 3, 7] :/
02:56:04 <cocreature> platzhirsch: what's the pattern?
02:56:16 <julianleviston> cocreature: jinx!
02:56:22 <julianleviston> platzhirsch: replicate
02:56:31 <platzhirsch> it's given, no pattern, except that after 7 it keeps 7
02:56:51 <cocreature> you could use replicate, but if there is no pattern hardcoding them is probably the best way
02:57:33 <Gurkenglas> Infinite sevens is [0, 2, 2, 3, 3, 3, 3, 3, 3] ++ repeat 7 makes it keep being seven
02:57:38 <tsahyt> I don't know, the replicate version doesn't seem that much better to me.
02:57:41 <Gurkenglas> -"Infinite sevens is"
02:57:50 <julianleviston> platzhirsch: if you have pairs of (qty, val) you can put it to a list comprehension, then fold with (++)
02:58:00 <platzhirsch> yeah that makes sense
02:59:15 <arkeet> > [(1,0),(2,2),(6,3)] >>= uncurry replicate
02:59:17 <lambdabot>  [0,2,2,3,3,3,3,3,3]
02:59:25 <julianleviston> araujo: delicious ;-)
02:59:30 <arkeet> not any shorter though heh
03:01:53 <Gurkenglas> > (>>= uncurry genericReplicate) [(0,1), (2, 2), (6, 3), (infinity, 7)]
03:01:54 <lambdabot>  [2,2,3,3,3,3,3,3,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7...
03:02:10 <arkeet> :t infinity
03:02:11 <lambdabot> Natural
03:06:53 <julianleviston> why infinity?
03:07:01 <Gurkenglas> Because he said it keeps being seven
03:07:06 <julianleviston> did he?
03:07:14 <Gurkenglas> <platzhirsch> it's given, no pattern, except that after 7 it keeps 7
03:07:23 <julianleviston> oh, I didn’t realise that was what that means.
03:07:35 <platzhirsch> ah indeed
03:07:39 <julianleviston> well in that case it’s impossible to do manaully anyway.
03:07:55 <platzhirsch> nice
03:07:56 <julianleviston> depending on one’s definition of “hardcoded” ;-)
03:08:21 <julianleviston> (ie… hardcoded values, or non-genericized code)
03:14:48 <tsahyt> @src infinity
03:14:48 <lambdabot> Source not found. Just what do you think you're doing Dave?
03:19:23 <julianleviston> in newtype State s a = State { runState :: s -> (a,s) } why is it (a,s) rather than (s,a) ?
03:19:44 <julianleviston> is it because of functional application?
03:19:52 <quchen> julianleviston: No reason.
03:19:56 <quchen> It's like that.
03:19:57 <julianleviston> quchen: ok
03:20:02 <quchen> End. :-(
03:20:20 <julianleviston> seems a bit odd to flip their order for no reason then
03:21:08 <julianleviston> actually it makes sense to store them like that, and have them in the order they’re in in the type signature. All good.
03:22:42 * hackagebot libinfluxdb 0.0.1 - libinfluxdb  https://hackage.haskell.org/package/libinfluxdb-0.0.1 (wereHamster)
03:23:27 <quchen> :t runState
03:23:28 <lambdabot> State s a -> s -> (a, s)
03:23:32 <quchen> :t state
03:23:33 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
03:23:49 <quchen> You could easily flip them both.
03:24:02 <quchen> Writer makes the strange order more obvious even.
03:24:05 <quchen> :t runWriter
03:24:06 <lambdabot> Writer w a -> (a, w)
03:27:05 <julianleviston> quchen: tho now I thought about it for a second, it makes complete sense to have them in that “strange order”.
03:27:16 <quchen> julianleviston: Tell me
03:28:20 <julianleviston> quchen: w a (in this part, we’re interested in specifying the w mostly, for the typeclass to be “satiesfied” in the type. So we’de prefer to write Writer [] Int here (hopefully I’ve got the types and nomenclature correct - correct me if not)
03:28:48 <quchen> Sounds good so far.
03:29:05 <quchen> The choice of the parameter order in Writer is not arbitrary and makes sense (only) this way.
03:29:09 <julianleviston> but on the other side of it… the pair, it makes sense from the perpective of time to have the value first, then the accumulation second… because one is interested in putting things into them.
03:29:18 <quchen> Writer a w would not be a Monad for example. (Logically yes, but you couldn't write it.)
03:29:29 <julianleviston> yeah
03:29:45 <julianleviston> according to the syntax of Haskell
03:30:13 <quchen> I don't understand the tuple argument.
03:30:52 <julianleviston> quchen: (5, []) makes more sense than ([], 5) because it’s logically feeding in from the left into the right “object”.
03:30:54 <quchen> Tuples are perfectly symmetric, two-argument type constructors are not
03:31:04 <julianleviston> quchen: yes, but Haskell is read left to right.
03:31:10 <julianleviston> (by humans)
03:31:25 <quchen> Not by me. I read it in whatever order it makes sense to me.
03:31:45 <quchen> f . g . h -- right-to-left more than left-to-right, for example.
03:31:54 <julianleviston> quchen: tniop ruoy ees I
03:32:28 <quchen> Gets even funnier when >>= is involved, because then you have the ltr >>= mixed with the rtl .
03:33:26 <julianleviston> quchen: argument application order for currying/uncurrying makes it matter, though, right?
03:34:12 <quchen> Sure, but those are operations that have nothing to do with Writer.
03:34:18 <sphinxo> What editor has the best support for haskell?
03:34:26 <quchen> uncurry flipping the tuple would be equally weird.
03:34:30 <julianleviston> quchen: no, but the conventions do. Writer was simply an example.
03:34:44 <quchen> sphinxo: Most use Vim, Emacs, Sublime. Emacs has a reputation of having the best Haskell support.
03:34:59 <sphinxo> Thanks, quchen 
03:35:19 <sphinxo> I'll look into haskell-mode
03:35:32 <quchen> It's excellent and always makes me angry that I'm not using it.
03:35:40 <cocreature> atom seems to have be come fairly popular recently too
03:35:48 <sphinxo> For haskell?
03:35:52 <cocreature> yep
03:36:00 <sphinxo> Interesting
03:36:27 <cocreature> I don't have any data to back that claim up, it's just a feeling from seeing people talk about it
03:37:22 <sphinxo> Looks like there are some nice haskell plugins
03:37:29 <julianleviston> cocreature: I found the basic editor kind of infuriating in a lot of ways, though… the way it handles param-matching, for example.
03:38:11 <cocreature> sphinxo: to be honest, I would use whatever editor you're most familiar with. I don't think it's worth using a different editor just because it has slightly better haskell support
03:39:23 <sphinxo> You see the problem is cocreature is that i'm a bit familiar with all of the editors and a master of none
03:39:31 <cocreature> heh
03:39:49 <julianleviston> Do I have to create myself a newtype which has a stateT instance in order to just create a :: State [Int] Int value?
03:41:07 <cocreature> :t return 0 :: State [Int] Int
03:41:08 <lambdabot> State [Int] Int
03:41:22 <cocreature> that's in Control.Monad.State iirc
03:41:31 <julianleviston> cocreature:  hm… ok thanks. Yeah, I’m using Control.Monad.State
03:41:33 <cocreature> and State is just a type alias for StateT s Identity
03:42:00 <julianleviston> right
03:42:32 <julianleviston> but I can’t then use a data constructor State ?
03:43:07 <julianleviston> because there isn’t one?
03:43:07 <cocreature> yes, but you don't really need that since you interact using put/get with State
03:43:17 <julianleviston> hm
03:43:20 <cocreature> there is also the state function if you really need that
03:43:26 <julianleviston> trying to follow the LYAH thing
03:43:28 <cocreature> that's somewhere in mtl
03:43:46 <julianleviston> type Stack = [Int] ; pop = State $ \(x:xs) -> (x,xs)
03:43:54 <julianleviston> doesn’t seem to like that very much.
03:43:54 <cocreature> use the state function
03:43:57 <julianleviston> did things change?
03:43:58 <julianleviston> ah ok
03:43:59 <julianleviston> thanks
03:44:11 <julianleviston> cool works fine
03:44:18 <cocreature> or use get instead of using an explicit function
03:44:48 <julianleviston> ah looking at the type signature of state that makes complete sense
03:44:58 <julianleviston> this is post-monad-transformers State, I guess?
03:44:58 <Gurkenglas> Is anyone using atom on Windows?
03:47:04 <quchen> :t state -- julianleviston 
03:47:05 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
03:47:26 <julianleviston> quchen: yeah I looked it up.
03:47:54 <quchen> :t \x -> state (\stack -> ((), x:stack))
03:47:55 <lambdabot> MonadState [a] m => a -> m ()
03:48:16 <quchen> :t \x -> modify (x:)
03:48:17 <lambdabot> MonadState [a] m => a -> m ()
03:50:36 <julianleviston> ah this is actually confusing me more.
03:50:37 <julianleviston> sorry.
03:50:45 <julianleviston> it’s cool. I’ll work it out.
03:53:05 <quchen> What's confusing you?
03:53:15 <quchen> That was `push`.
03:53:26 <Gurkenglas> https://atom.io/packages/haskell-ghc-mod tells me I need to do "cabal install ghc-mod hlint". Doing that tells me stuff will be broken by reinstalls. I remember that "sandboxes" can be used to avert this problem. How?
03:53:50 <quchen> \state is your current state. That is turned into "no interesting result value" (), and a new stack, which is x ontop of the old stack.
03:53:56 <cocreature> Gurkenglas: make a new sandbox using cabal sandbox init and run the command there
03:55:41 <Gurkenglas> In a new naked directory, I'm guessing, not ~
03:55:45 <nullx002> do anybody use emacs  haskell mode?
03:55:50 <nullx002> with stack type?
03:55:59 <Cale> Gurkenglas: yeah
03:56:00 <cocreature> Gurkenglas: yeah
03:56:04 <nullx002> M-X customize-variable
03:56:13 <nullx002> haskell-process-type
03:56:18 <nullx002> hai Gurkenglas
03:56:25 <nullx002> i dont find stack listed there
03:56:29 <nullx002> i have installed stack
03:56:29 <cocreature> nullx002: your process type needs to be stack-ghci not stack
03:56:39 <nullx002> yes but it is not listed in menui
03:57:11 <cocreature> it is for me, you might need to update your haskell-mode
03:57:12 <nullx002> values i have are auto, ghci, cabel-ghci and cabel-repl
03:57:45 <nullx002> hum..
03:57:47 <nullx002> let me check
04:00:42 <nullx002> packages are upto date
04:01:01 <cocreature> where have you got haskell-mode from?
04:01:11 <nullx002> elpa melpa
04:02:18 <cocreature> hm, no idea then, the latest haskell-mode  definitely supports it so I'm pretty sure you have an old version
04:03:18 <nullx002> no it is last one
04:03:21 <nullx002>  Archive: melpa
04:03:21 <nullx002>     Version: 20150920.858
04:04:17 <julianleviston> Haskell is amazing.
04:04:42 <cocreature> nullx002: what does M-x haskell-version tell you?
04:04:55 <mniip> julianleviston, correct
04:04:59 <julianleviston> quchen: sorry, I just had to go and think about what it meant :) I’m still a bit unsure about things, but all good.
04:05:01 <julianleviston> mniip: :)
04:05:07 <mniip> but unfortunately mathematicians can't into package management and build systems
04:05:19 <nullx002> haskell-mode version 13.15-gi
04:05:25 <Cale> mniip: ?
04:05:27 <nullx002> haskell-mode version 13.15-git
04:05:43 <nullx002> /.emacs.d/elpa/haskell-mode-20150920.858
04:05:46 <julianleviston> mniip: it’s a fair bit more precise than mathematical nomenclature half the time, I feel.
04:05:51 <cocreature> hm weird
04:05:53 <mniip> Cale, cabal is a *bit* retarded
04:06:11 <Cale> I think it's doing a pretty good job of what it's trying to do.
04:06:17 <mniip> it "works"
04:06:31 <nullx002> did i made any mistake installing stack
04:06:45 <nullx002> it works well in terminal... commerical haskell but not in emacs
04:07:21 <Cale> Most of the limitations placed on cabal are due to GHC's limitations -- specifically the fact that GHC can't (or at least couldn't -- that's happening soon) handle more than one instance of the same package version.
04:07:55 <Cale> If it could, then cabal wouldn't have to screw things up so often.
04:08:16 <Cale> But at least it's pretty good at warning you when it's about to do so now.
04:11:11 <Cale> mniip: I suppose then there are the difficulties with solving version constraints, but a lot of the problems there are inherently difficult and/or made harder by people writing lies in their package dependencies.
04:11:47 <Cale> It does a very good job of finding solutions when they exist :P
04:12:26 <mniip> yes, but it cannot maintain a stable state when you ask to uninstall or reinstall packages
04:12:52 <Cale> It uninstalls packages?
04:13:12 <Cale> Cabal doesn't even try to uninstall packages for you.
04:13:19 <Cale> Or is that new?
04:13:56 <Cale> It would be reasonable for cabal-install to be able to do that.
04:16:37 <julianleviston> quchen: aw I’m so confused. How would I create a value whose type is Stack Int (given that type Stack = [Int]) ?
04:17:03 <julianleviston> quchen: sorry whose type is State Stack Int
04:18:18 <julianleviston> quchen: I assume I use the state function… whose type is MonadState s m => (s -> (a, s)) -> m a
04:19:07 <Cale> julianleviston: Typically not
04:19:24 <thiagofm> I want to buy a good, up to date, haskell book. What is a good one?
04:19:28 <julianleviston> Cale: sorry?
04:19:32 <quchen> julianleviston: put/get are the smallest operations you'll typically use
04:19:34 <Cale> julianleviston: The point of using the State monad is to avoid passing around the state manually, which the state function lets you do
04:19:39 <julianleviston> thiagofm: go get haskellbook.com IMHO
04:19:49 <julianleviston> quchen: ah put/get I wasn’t aware of them.
04:19:56 <julianleviston> Cale: yes, but how do you get it?
04:20:09 <mniip> :t do x <- get; put (x + 1)
04:20:10 <lambdabot> (Num s, MonadState s m) => m ()
04:20:19 <quchen> put x = state (\_ -> ((), x))  ;  get = state (\s -> (s,s))
04:20:25 <quchen> :t put
04:20:26 <quchen> :t get
04:20:26 <lambdabot> MonadState s m => s -> m ()
04:20:27 <lambdabot> MonadState s m => m s
04:20:32 <Cale> I mean, using the state function means you're writing the same old code as you would have without the State monad, just wrapped in an application of the state function.
04:20:36 <quchen> Put sets the state, get gets the state.
04:20:55 <Cale> So, yeah, usually you want to compose something using get and put and the monad operations (typically just do-notation)
04:21:11 <Cale> Let's look at an example... suppose we have this tree type:
04:21:18 <Cale> @undefine
04:21:18 <lambdabot> Undefined.
04:21:20 <julianleviston> quchen: I don’t understand how you create a value whose type is State Stack Int tho...
04:21:32 <julianleviston> quchen: do you just let haskell infer it?
04:21:36 <Cale> @let data BinTree a = Tip | Branch a (BinTree a) (BinTree a)
04:21:37 <lambdabot>  Defined.
04:22:03 <julianleviston> quchen: like then how would I use it in context of a program where I wanted to, say, put a number into a stack, then pull one out and print it out?
04:22:20 <quchen> :t put :: Int -> State Int ()
04:22:21 <lambdabot> Int -> State Int ()
04:22:25 <Cale> and suppose we want to write a function which will relabel a given tree with integers starting from 0, such that all the labels in the left subtree are less than the label at the root, and all the labels in the right subtree are greater
04:22:26 <julianleviston> quchen: given that main is :: IO ()
04:23:01 <Cale> If you try to do this just with plain recursion, you'll immediately run into a problem:
04:23:02 <julianleviston> quchen: ahhh...
04:23:15 <julianleviston> Cale: are you talking to me?
04:23:16 <quchen> > (`runState` 0) (do { put 1; put 2; put 3; x <- get; pure (x*100) })
04:23:17 <Cale> yes
04:23:18 <lambdabot>  (300,3)
04:23:34 <Cale> I'm going to give you an involved example of what the State monad is good for and how to use it
04:23:37 <julianleviston> Cale: that’s *way* too confusing an example, dude. Sorry. I don’t need a tutorial on the justification for its derivation.
04:23:51 <Cale> What's confusing?
04:24:09 <mniip> if you're trying to use `state`, it means you don't understand the reason for its use very well
04:24:09 <julianleviston> Cale: it’s just complex.
04:24:19 <julianleviston> mniip: <sigh> no it doesn't.
04:24:31 <Cale> julianleviston: uhh, the idea of replacing the labels on a tree?
04:24:33 <julianleviston> quchen: thanks man, that was what I was after.
04:24:49 <julianleviston> quchen: (or woman) ;-)
04:25:24 <Cale> So, for example, the function we want to write will take a tree like  Branch "here" (Branch "is" Tip Tip) (Branch "a" (Branch "tree" Tip Tip) Tip)
04:25:45 <julianleviston> Cale: Timeout!
04:25:59 <Cale> and produce  Branch 1 (Branch 0 Tip Tip) (Branch 3 (Branch 2 Tip Tip) Tip)
04:27:03 <breadmonster> Cale: Can you implement skip lists in Haskell?
04:27:21 <Cale> breadmonster: why not?
04:27:32 <breadmonster> Cale: I'd presume same problem with a doubly-linked list.
04:27:35 <breadmonster> need mutable state.
04:27:43 <Cale> You can implement doubly linked lists in Haskell
04:27:46 <cocreature> throw in some iorefs
04:27:52 <julianleviston> breadmonster: why do you need mutable state??
04:27:55 <Cale> and Haskell does have mutable references you can use
04:28:28 <breadmonster> Cale cocreature: I was trying to think of a purely functional version. Would be a nice(r) alternative to hash tables?
04:28:53 <Gurkenglas> Doubly linked lists are ok as long as you don't mind that changing any value will reconstruct the whole thing - like changing the value of the last element of a list
04:29:09 <Cale> breadmonster: See Map
04:29:15 <breadmonster> Gurkenglas: Yeah, that's what I realized yesterday, but that's no longer O(1).
04:29:24 <breadmonster> Cale: I'm trying to do better than Map :P
04:29:30 <Cale> good luck :P
04:29:42 <Cale> Well, IntMap does somewhat better
04:29:44 <breadmonster> Is Map really the asymptotic bound? :P
04:29:46 <cocreature> most of the time you can use a zipper instead of a doubly linked list
04:29:46 <Gurkenglas> breadmonster, can you rephrase what you said to me?
04:30:10 <breadmonster> Gurkenglas: Haskell style doubly linked lists don't have constant time append.
04:30:17 <Cale> edwardk's cache oblivious structures do somewhat better for certain operations
04:30:25 <Cale> But he had to struggle a lot to get them
04:30:34 <Cale> and still didn't beat Map on everything
04:30:40 <breadmonster> Cale: anything by edwardk does better, but that's not the point right now :P
04:31:53 <breadmonster> So I guess you can't do better than Map.
04:32:00 <breadmonster> That uses AVL trees internally, correct?
04:32:01 <Cale> Well, it's going to be a lot of work
04:32:04 <Cale> no
04:32:07 <Gurkenglas> Can you give us a complete specification of what operations you want with what runtimes?
04:32:23 <Cale> Map uses trees of bounded balance internally
04:32:46 <breadmonster> Gurkenglas: Ideally, I'd like to be able to implement hash tables.
04:33:12 <julianleviston> So, I have main, whose type is obviously IO ()… within a do block in that context, how can I make it a value whose type is an instance of State ?
04:33:17 <Gurkenglas> Then how did you come to doubly linked lists? o.o
04:33:18 <julianleviston> *has a State instance*
04:33:37 <Cale> There are hashtable structures you can use
04:33:40 <julianleviston> or at least… have a context where I can use state?
04:33:50 <Cale> If you *really* want to use hashing
04:34:01 <Cale> There's also unordered-containers which defines HashMap
04:34:18 <Cale> and is an almost drop-in replacement for Data.Map
04:34:36 <Cale> In my experience, it's a bit of a toss-up whether it'll end up being any faster
04:34:38 <Gurkenglas> julianleviston, you want "Something a -> State a b -> IO b"? If so, Something is IORef.
04:34:50 <Cale> usually I've found it's a bit slower, because computing hashes is not free
04:35:23 <julianleviston> Gurkenglas: I don’t know what I want, Haskell-wise. What I’d like to do is have a do block under main such that I can use set and get, but also putStrLn is that possible?
04:35:25 <Cale> (and depending on your key type, it may often be faster to do comparisons)
04:35:26 <breadmonster> Cale Gurkenglas: I was thinking of fast map structures, and I'd like to implement one myself.
04:36:01 <julianleviston> Gurkenglas: so that I could, say, getLine and store it in my stack, a few times, then do something with the items, then putStrLn them out
04:36:03 <Cale> julianleviston: IO is a completely separate datatype from State
04:36:09 <julianleviston> Cale: yeah, I know
04:36:20 <Cale> julianleviston: They both happen to implement the Monad abstraction, and that's about all they have in common
04:36:27 <julianleviston> Cale: yeah, I know.
04:36:49 <julianleviston> Cale: so I probably can’t do that?
04:37:07 <Cale> You could use  State [IO a]
04:37:17 <Cale> to perhaps compute an IO action
04:38:03 <Cale> But more likely you're thinking of StateT [String] IO a
04:38:57 <julianleviston> It’s cool. It’s obviously way more complicated than I’d thought it’d be. All good. I’ll just continue on. 
04:39:05 <julianleviston> Cale: thanks!
04:39:15 <Cale> which is a monad that's like the State monad, but where instead of functions of type s -> (a,s), you internally have functions that produce IO actions, like  s -> IO (a,s)
04:39:15 <cocreature> julianleviston: if you haven't fully grasped state yet try doing something without IO first
04:39:37 <julianleviston> cocreature: I’m pretty sure I’ve got a handle on it… 
04:39:40 <lpaste> Gurkenglas pasted “julianleviston, here.” at http://lpaste.net/141816
04:39:42 <julianleviston> cocreature: but maybe I don't.
04:40:16 <Cale> I should perhaps give an intro from the start
04:40:16 <julianleviston> Gurkenglas:  gosh.
04:40:40 <julianleviston> Gurkenglas:  that’s cool!
04:40:56 <lpaste> Gurkenglas revised “julianleviston, here.”: “No title” at http://lpaste.net/141816
04:41:07 <Cale> It's kind of cool, but it's sort of a waste of machinery given that in the IO monad, you could just create an IORef and use operations on it
04:41:09 <julianleviston> Gurkenglas: so you just wrap the state in the IO
04:41:22 <Jinxit> what are my chances of doing realtime (30 or preferably 60fps) visualizations with haskell?
04:41:24 <julianleviston> Cale: understood! :)
04:41:25 <Gurkenglas> (Because the last line was wrong)
04:41:30 <Cale> So, using StateT to transform IO doesn't really give you much more than you could already do
04:41:32 <Jinxit> drawing lines and stuff
04:41:35 <julianleviston> Cale: but much easier, if I want to keep simple :)
04:41:56 <Cale> No, that's my point, it's easier just to use the stuff which is available in IO directly :P
04:42:04 <julianleviston> Cale: by “simple” I mean conceptual simplicity for me :)
04:42:13 <julianleviston> Cale: how do you mean?
04:42:39 <Gurkenglas> I find that IORefs are less restricted than needed. Using StateT gurantees that no IO call I'm doing behind a liftIO is going to modify the state.
04:42:45 <julianleviston> Cale: I’d have to understand monad transformers to do that, tho, right?
04:43:08 <cocreature> Cale: well then you need to pass around the IORef to be able to read from it, at that point you could just as well pass the value around no?
04:43:26 <Cale> julianleviston: I'm suggesting *not* to use monad transformers, while the example presented did use the StateT monad transformer.
04:43:39 <Gurkenglas> Ssh, don't tell him!
04:43:58 <julianleviston> Cale: clearly, I need to just go practice more. Maybe in a year I’ll be able to use State and IO together :)
04:43:59 <Cale> cocreature: There's a big difference between passing around a mutable reference and passing around the current value
04:44:06 <Gurkenglas> We should have let him use this for three days and then tell him that he's been using them all along and it's not as hard as he thought
04:44:23 <cocreature> Cale: in which way?
04:44:27 <Cale> julianleviston: Probably you're just looking to use runState someStateComputationYouWrote initialState
04:44:37 <julianleviston> Cale: ahhhh
04:44:43 <Cale> which will result in the pair of result and final state
04:45:01 <Cale> So you might, say, apply 'print' to that to print those things out.
04:45:50 <julianleviston> Cale: ah, so I basically accumulate a bunch of IO () values, then put the result of the state into the main value, and bob’s my uncle.
04:45:51 <julianleviston> ok
04:46:02 <Cale> wait what?
04:46:03 <julianleviston> Cale: I think I can understand that pretty easily.
04:46:27 <julianleviston> Cale: sorry, precision of langauge.
04:46:51 <Cale> Uh, if you're accumulating IO actions as part of the result or state of the State computation you run, then you'll likely want to execute them after, rather than trying to print them out (since IO doesn't have a Show instance)
04:47:10 <julianleviston> Cale: ok I’m really confused.
04:47:28 <julianleviston> Cale: as I see it, I have ONE execution point. main.
04:47:51 <Cale> Yeah, main gets executed, and it in turn gets to execute other IO actions.
04:48:03 <julianleviston> Cale: I don’t like the term “action"
04:48:07 <Cale> why?
04:48:15 <julianleviston> Cale: it’s not true.
04:48:24 <Cale> How so?
04:48:30 <julianleviston> Cale: because… what’s an action?
04:48:46 <Cale> A value of type IO t is a description of something which could be done in order to produce a result of type t.
04:48:59 <julianleviston> Cale: what you really mean is a value whose type has an instance of Monad, right?
04:49:02 <Cale> (assuming that it terminates normally and doesn't throw an exception or take forever)
04:49:13 <julianleviston> actions are only IO now?
04:49:13 <Cale> not in this case
04:49:38 <Cale> Well, more generally, we can use the word "action" or "M-action" to refer to values of type M t
04:49:38 * julianleviston raises his eyebrows
04:49:43 <julianleviston> yep.
04:49:53 <julianleviston> values whose type has an instance of Monad.
04:49:54 <Cale> which is often appropriate for similar reasons to why it's appropriate for IO
04:49:55 <julianleviston> right?
04:50:19 <Cale> Sure, well, sort of.
04:50:30 <Gurkenglas> If we're gonna do this formally, "IO ()" doesn't have an instance of monad, "IO" does
04:50:30 <Cale> There's an instance of Monad M
04:50:51 <julianleviston> Gurkenglas: I’ve been very careful to say “value whose type has an instance of..."
04:51:10 <Gurkenglas> Right, and the value's type is IO (), not IO
04:51:14 <Cale> julianleviston: Whose type was constructed by the application of a type constructor which has an instance of Monad :)
04:51:23 <Cale> julianleviston: If we want to be really picky
04:51:34 <julianleviston> Cale: right.
04:51:51 <Cale> julianleviston: It's almost always appropriate to think of values like this as describing actions or computations of some sort.
04:51:59 <julianleviston> Cale: so to have a context which has the capacity to be stateful *and* be a value of the IO constructor… ?
04:52:08 <Cale> hm?
04:52:28 <Cale> IO is just one particular example of a monad, and the fact that it happens to be a monad isn't even all that important.
04:52:43 <Cale> What's more important is that IO actions are values at all.
04:52:46 <julianleviston> Cale: see, I don’t like that language.
04:52:55 <julianleviston> IO is not a Monad.
04:53:01 <Cale> IO *is* a monad.
04:53:06 <julianleviston> is it?
04:53:08 <Cale> ues
04:53:09 <Cale> yes*
04:53:23 <julianleviston> I was under the impression that IO has an instance of Monad.
04:53:26 <Cale> Just as Maybe is a monad, and State s is a monad for each type s.
04:53:46 <Cale> Yes, the type constructors T for which there is an instance Monad T are referred to as monads.
04:54:09 <julianleviston> Cale: see, this is part of why Haskell is “difficult".
04:54:13 <Cale> hm?
04:54:16 <julianleviston> the concept of “is-ness"
04:54:21 <julianleviston> Maybe is a Monad
04:54:23 <julianleviston> Maybe is a Functor
04:54:29 <julianleviston> Maybe is a Type constructor
04:54:38 <Cale> all true
04:54:47 <julianleviston> See why that might be confusing? (note: it’s not confusing to me)
04:54:51 <Cale> uh, no
04:55:11 <Jinxit> pancakes can be both breakfast or dessert, depending on the context
04:55:20 <Cale> Well, I can understand that someone might be confused about it, but only insofar as people can be confused about nearly anything.
04:55:21 <julianleviston> of course
04:55:24 <cocreature> Jinxit: I also eat them for dinner sometimes
04:55:30 <Jinxit> same
04:55:33 <Cale> 5 is a number
04:55:37 <julianleviston> we should say “Maybe is (also) a Monad” :-)
04:55:49 <Cale> Maybe happens to be a monad
04:55:58 <julianleviston> yah
04:56:02 <julianleviston> because “x is y” is usually (in computing) a descirption of complete identity.
04:56:05 <Cale> Note my use of case, by the way
04:56:08 <cocreature> ah so your problem is that it's not hierarchical?
04:56:17 <julianleviston> I don’t have a problem.
04:56:23 <Cale> Typically if I say "Monad" with an uppercase M, I'll be referring to the type class itself.
04:56:37 <julianleviston> other than not understanding how to create a value that has a context which is both stateful and capable of IO
04:57:22 <julianleviston> cocreature:  but I’ll figure it out :)
04:57:25 <Cale> Okay, so IO has built in some facilities for state already
04:57:46 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Data-IORef.html
04:57:48 <Cale> we have
04:57:51 <Cale> newIORef :: a -> IO (IORef a)
04:57:54 <Cale> readIORef :: IORef a -> IO a
04:57:58 <Cale> writeIORef :: IORef a -> a -> IO ()
04:58:06 <Cale> let's just look at these three things for now
04:58:49 <Cale> So, newIORef takes a value of type a, and produces an IO action, which when executed, will give you a value of type (IORef a), which is essentially a mutable cell whose contents are initialised to the given value
04:59:40 <Cale> readIORef takes a value of type (IORef a), and gives you an action which when executed will read the current value of the mutable cell, giving a result of type a
05:00:39 <Cale> writeIORef takes both a value of type (IORef a), and a value of type a, and gives an action which when executed, writes the value to the mutable cell (and produces an empty tuple as its result)
05:00:51 <julianleviston> Cale: sorry, this is beyond me. Better just let me get on with learning, I think. Thanks for the effort a lot. I really appreciate it.
05:01:07 <Cale> Can you tell me what's unclear?
05:01:18 <julianleviston> Cale: are you sure?
05:01:27 <Cale> I'm trying to help you with learning, so feel free to ask as many questions as you'd like
05:01:36 <julianleviston> Cale: uhhh ok
05:01:44 <julianleviston> Cale: I don’t want to annoy you or take up your time.
05:01:52 <julianleviston> Cale: including others’ attention.
05:01:57 <Jinxit> welcome to the evangelism of functional language communities
05:01:57 <Cale> It's okay, if I didn't want you to take my time, I'd just leave :P
05:02:11 <julianleviston> Jinxit: haha how do you mean?
05:02:15 <julianleviston> Cale: ok :)
05:02:18 <cocreature> julianleviston: people here are actually pretty nice and want other people to learn :)
05:02:24 <Jinxit> ^ essentially that
05:02:25 <julianleviston> cocreature:  oh I know that.
05:02:34 <julianleviston> Jinxit: gotcha
05:03:00 <Cale> So, for example, we can write:
05:03:10 <Cale> increment :: IORef Integer -> IO ()
05:03:23 <julianleviston> Cale: ok.. so I’m the kinda person who needs an accurate conceptual overview before I get into the detail, then pull each piece of detail up into the conceptual overview
05:03:24 <Cale> increment r = do v <- readIORef r; writeIORef r (v + 1)
05:03:37 <Cale> and then maybe we could write
05:03:41 <julianleviston> Cale: so I actually haven’t understood *any* of this IORef stuff yet, sadly.
05:03:57 <Cale> main = do r <- newIORef 0; increment r; increment r; v <- readIORef r; print v
05:04:10 <Cale> and this program should print 2
05:04:12 <julianleviston> Cale: hello?
05:04:16 <Cale> Okay
05:04:41 <Cale> So, what's the first thing you didn't understand? :)
05:04:45 <julianleviston> Cale: all of it. 
05:04:52 <julianleviston> Cale: you said “you can think of it like..."
05:04:57 <julianleviston> Cale: that bothers me a lot
05:05:03 <julianleviston> Cale: I actually want to know what’s going on.
05:05:16 <Cale> where?
05:05:28 <julianleviston> Cale: for example, the way I understood main :: IO () was when I realised that it’s just a value.
05:05:35 <Cale> sure
05:05:51 <julianleviston> Cale: that happens to be the point at which GHC grabs your code and starts executing.
05:05:52 <chpatrick1> julianleviston: in haskell you don't actually have side effects in the language, but you can manipulate values that represent side-effecting actions
05:05:54 <Cale> It's a value which is a description of a bunch of things to be done.
05:06:05 <julianleviston> chpatrick1: yeah, I know.
05:06:12 <julianleviston> Cale: yup ! :)
05:06:13 <chpatrick1> ok, so what do you think this means
05:06:15 <chpatrick1> :t readIORef
05:06:16 <lambdabot>     Not in scope: ‘readIORef’
05:06:16 <lambdabot>     Perhaps you meant ‘readSTRef’ (imported from Data.STRef)
05:06:23 <julianleviston> chpatrick1:  I have no idea.
05:06:24 <chpatrick1> derp
05:06:27 <Cale> readIORef :: IORef a -> IO a
05:06:28 <chpatrick1> IORef a -> IO a
05:06:36 <chpatrick1> what do you think this function does?
05:06:42 <Reshi> I am working with llvm-general: I want to call a foreign C's puts(const char*) to print my hello world string, I am making the parameter Constant.Array [n x i8], with the character values proper (ending with NUL), but the call is terminating by SIGSEGV (address bounday error). I am guessing I have to allocate memory and get pointer for the constant array instead of just directly passing it? 
05:06:43 <julianleviston> chpatrick1: ok… it’s a function
05:06:48 <chpatrick1> what does it take and return?
05:06:51 <julianleviston> chpatrick1: from a value to another value
05:06:57 <chpatrick1> what kind of value
05:07:14 <julianleviston> chpatrick1:  the first value is of some type that has an instance of IORef
05:07:20 <chpatrick1> no
05:07:24 <chpatrick1> it's literally an IORef
05:07:26 <julianleviston> chpatrick1: oh sorry
05:07:36 <chpatrick1> and what does it return?
05:07:37 <julianleviston> chpatrick1: it’s a value that is constructed by the IORef type constructor
05:07:46 <chpatrick1> sure I'll take that
05:07:57 <julianleviston> chpatrick1: and it returns a value of type created by the IO type constructor.
05:07:58 <Cale> Well, whose type is constructed by the IORef type constructor
05:08:04 <Cale> yeah
05:08:07 <julianleviston> cool
05:08:14 <chpatrick1> ok, so what do you think it does?
05:08:23 <chpatrick1> knowing what IO is
05:08:31 <chpatrick1> and that it's called readIORef
05:08:45 <julianleviston> chpatrick1: builds a value that can have effects.
05:08:51 <julianleviston> chpatrick1: “so to speak"
05:08:54 <Cale> Which effects?
05:08:55 <chpatrick1> well yeah because it returns IO
05:08:58 <chpatrick1> but what's the effect
05:09:02 <julianleviston> Cale: I don’t know.
05:09:05 <Cale> okay!
05:09:22 <chpatrick1> think of an IORef as a mutable box
05:09:23 <Cale> So, the idea is that a value of type  IORef a  represents a mutable cell whose contents have type a
05:09:24 <julianleviston> you can’t tell the effect can you?
05:09:30 <julianleviston> chpatrick1: what does THAT mean?
05:09:31 <chpatrick1> where you can swap out the values as an IO effect
05:09:38 <julianleviston> chpatrick1: please don’t use “think of… like…” with me!
05:09:44 <chpatrick1> well that's what it is
05:09:44 <jophish_> I have a function in C with the type double foo(double, double*) the second parameter is used as an extra return type. What's the neatest way of wrapping this up as a function of type CDouble -> (CDouble, CDouble)?
05:09:46 <chpatrick1> it's not an analogy
05:09:50 <Cale> i.e. a box of some sort which will always contain a value of type a, and which we can read and replace the value in it somehow
05:10:10 <julianleviston> chpatrick1:  what is a box?
05:10:20 <julianleviston> chpatrick1:  or a cell?
05:10:23 <Cale> julianleviston: A chunk of memory
05:10:26 <julianleviston> chpatrick1: I’ve never heard of these things
05:10:31 <chpatrick1> or a variable
05:10:31 <julianleviston> Cale: hm
05:10:40 <Cale> julianleviston: Have you used any other programming languages?
05:10:51 <Walther> hmm. http://lpaste.net/2894249654705192960
05:10:58 <julianleviston> chpatrick1: to me, in haskell, a variable is something that stands in for a definition
05:11:03 <julianleviston> Cale: many.
05:11:06 <Cale> Every variable in a language like C refers to such a thing.
05:11:09 <chpatrick1> ok, so it's not a variable in the haskells ense
05:11:16 <chpatrick1> it's more like a variable in the imperative sense
05:11:24 <chpatrick1> like in C you can do int foo = 4; foo = 5;
05:11:26 <julianleviston> chpatrick1: ok so a mutable variable
05:11:30 <chpatrick1> yes
05:11:37 <julianleviston> chpatrick1: some label for a mutable state
05:11:45 <chpatrick1> exactly
05:11:47 <julianleviston> chpatrick1: so a reference.
05:11:49 <chpatrick1> yes
05:11:50 <chpatrick1> hence Ref
05:11:53 <julianleviston> chpatrick1: hence the name, I guess. ;-)
05:12:05 <julianleviston> chpatrick1: is it STM?
05:12:06 <chpatrick1> and it's an IORef because reading and writing it is an IO action
05:12:13 <chpatrick1> it's not related to STM
05:12:17 <julianleviston> chpatrick1: ok
05:12:33 <julianleviston> chpatrick1: aha
05:12:36 <chpatrick1> so what do you think readIORef :: IORef a -> IO a does?
05:12:47 * hackagebot getopt-generics 0.11 - Create command line interfaces with ease  https://hackage.haskell.org/package/getopt-generics-0.11 (SoenkeHahn)
05:12:49 <julianleviston> chpatrick1: didn’t you just ask me this?
05:12:55 <chpatrick1> well do you know the answer now?
05:12:58 <Cale> Well, you have new information :)
05:12:58 <julianleviston> chpatrick1: I don’t have any more information than last time.
05:13:03 <julianleviston> Cale: oh?
05:13:11 <Cale> You know what a value of type IORef a is supposed to be
05:13:13 <chpatrick1> so you know it's a mutable reference
05:13:39 <julianleviston> chpatrick1: all kinds of things can happen in IO a
05:13:42 <Cale> (I also actually told you the answer to this question already before, but it probably went by too quickly)
05:13:43 <julianleviston> chpatrick1: so I have no idea
05:13:55 <Walther> Any help with non-terminating prime number check? :) http://lpaste.net/2894249654705192960
05:13:55 <chpatrick1> really can't tell what it does from the name.?
05:13:58 <Cale> Well, you also have the name of the thing which is a big hint
05:14:05 <julianleviston> chpatrick1: it could quite easily do nothing.
05:14:07 <jophish_> I think my only option here is to unsafePerformIO, but that feels jus awful
05:14:10 <jophish_> just*
05:14:33 <julianleviston> Cale: I don’t see how the type signature tells me what’s going to be in the function.
05:14:39 <mniip> [14:07:21] <chpatrick1> so what do you think readIORef :: IORef a -> IO a does?
05:14:39 <chpatrick1> no but the name does
05:14:40 <Cale> julianleviston: It actually kind of needs to do something as it produces a value of type a
05:14:45 * mniip knows the answer!
05:15:05 <julianleviston> Cale: why can’t it just be id ?
05:15:06 <chpatrick1> yeah it takes an IORef a and returns an IO a
05:15:15 <julianleviston> chpatrick1: but I already said that
05:15:22 <chpatrick1> ok, so why can't it be id?
05:15:24 <Cale> julianleviston: So unless it just hangs or throws an exception to avoid the need to get some value of type a from somewhere, it's got to actually look at what's in the IORef.
05:15:27 <julianleviston> chpatrick1: it can.
05:15:30 <bennofs> jophish_: I think unsafePerformIO was exactly introduced for FFI
05:15:30 <chpatrick1> can it?
05:15:39 <julianleviston> Cale: I don’t see why
05:15:43 <bennofs> jophish_: so you don't need to feel bad about using it in this case
05:15:46 <julianleviston> chpatrick1: I mean the a value.
05:15:53 <Cale> julianleviston: It can't be id because IORef a and IO a are different types
05:16:03 <julianleviston> Cale: I mean the a.
05:16:06 <Cale> What a?
05:16:16 <julianleviston> Cale:  IORef a <<<< this one?
05:16:21 <Cale> That a is just a type
05:16:24 <chpatrick1> jophish_: yeah I think this is a totally reasonable use for unsafePerformIO
05:16:25 <mniip> it's a type variable
05:16:28 <julianleviston> Cale: yeah, I know.
05:16:32 <chpatrick1> you can use alloca to get the second thing btw
05:16:32 <mniip> what does it have to do with id
05:16:33 <Cale> Having a value of type IORef a doesn't mean that we have a value of type a
05:16:39 <Cale> At least, not automatically
05:16:58 <Cale> But readIORef will produce an action that will get us one when it's executed.
05:17:06 <nullx002> hum... solved the stack-ghci problem...
05:17:20 <julianleviston> Cale: if you have IORef Int and IO Int then doesn’t that mean it could just take the Int out of the IORef, then pass it to return  (:: IO Int) ?
05:17:24 <nullx002> strange when i installed in manually it didn't work... just copied binaries to bin and it worked
05:17:32 <Cale> julianleviston: hm?
05:17:36 <julianleviston> Cale: yeah, but can’t the action do nothing?
05:17:43 <chpatrick1> julianleviston: taking the Int out of the IORef is an IO action
05:17:43 <mniip> julianleviston, you can only "just take the Int out" within IO
05:17:47 <jophish_> thanks, bennofs, chpatrick1, I'll let you know how it goes :)
05:17:49 <Cale> julianleviston: Well, reading the current contents of the IORef isn't nothing
05:17:51 <mniip> there is not an IORef a -> a
05:17:58 <barrucadu> julianleviston: Not all data constructors are exposed, so you can't just pattern match on it
05:18:12 <julianleviston> my god this is complex
05:18:13 <mniip> and IORef doesn't have a useful data constructor anyway
05:18:32 <chpatrick1> julianleviston: IORef a -> a would not make sense in the language
05:18:46 <Cale> julianleviston: It's not actually all that complex in the end, so if it seems complex, maybe it's just that we're being technical about how we describe things.
05:18:46 <julianleviston> chpatrick1: why?
05:18:48 <chpatrick1> since in haskell things should always evaluate to the same thing regardless of when they're executed
05:18:53 <mniip> julianleviston, referential transparency
05:18:56 <julianleviston> Cale: yes, as always, yes.
05:19:03 <chpatrick1> but here you would get a different value out depending on what's in it at the time
05:19:23 <chpatrick1> however, you can make a plan that gets the value out
05:19:27 <chpatrick1> that's what IO is for
05:19:33 <julianleviston> Cale: and twelve pages of text later, I’m not entirely sure what we’re talking about, or why
05:19:39 <Cale> heh
05:19:47 <julianleviston> Cale: I often have this trouble here :)
05:19:53 <julianleviston> Cale: but it’s fine.
05:19:58 <Cale> Well, the reason I brought this up was that you were interested in learning how to do stateful things in IO
05:20:05 <julianleviston> Cale: I am!
05:20:06 <Cale> and this is actually the simplest mechanism for that
05:20:13 <julianleviston> Cale: yeahp.
05:20:21 <Cale> You use newIORef to make a new mutable variable
05:20:34 <Cale> you write a new value to that variable with writeIORef
05:20:39 <julianleviston> Cale: I’m sure the mechanism is very simple (Just like most things in Haskell)… it’s just the explanations that make me cry :)
05:20:40 <Cale> and you read the current value with readIORef
05:20:45 <Cale> and that's really all there is to it :P
05:20:56 <julianleviston> Cale: ok !
05:21:11 <julianleviston> Cale: within the context of that IORef value?
05:21:17 <Cale> What context?
05:21:21 <Cale> What's a context?
05:21:34 <julianleviston> Cale: well all of this only makes sense within a value :: IORef a 
05:21:36 <julianleviston> right?
05:21:40 <Cale> Here, let me show you some example code:
05:21:58 <julianleviston> Cale: ahhh ok 
05:22:00 <Cale> do r <- newIORef 0; writeIORef r 6; v <- readIORef r; print v
05:22:08 <Cale> Try running that in ghci
05:22:18 <Cale> oh
05:22:18 <julianleviston> Cale: don’t you need {} ?
05:22:22 <Cale> import Data.IORef  first
05:22:27 <julianleviston> Cale: yep.
05:22:40 <Cale> You don't need the braces, they're optional
05:22:47 * hackagebot getopt-generics 0.11.0.1 - Create command line interfaces with ease  https://hackage.haskell.org/package/getopt-generics-0.11.0.1 (SoenkeHahn)
05:22:57 <julianleviston> Cale: I’ll just run it thru in my mind first
05:23:03 <jophish_> When was (<$>) added to the prelude, was it forever ago?
05:23:11 <chpatrick1> 7.10 I think
05:23:15 <julianleviston> Cale: perfect. 
05:23:27 <chpatrick1> as part of AMP I assume
05:23:34 <cocreature> yep 7.10
05:23:40 <Cale> julianleviston: Does it make sense what happens?
05:23:41 <jophish_> ah, so I should import Data.Functor((<$>)) if I want to support base >= 4 < 5
05:23:42 <julianleviston> Cale: yep!
05:23:45 <julianleviston> Cale: <3
05:23:55 <julianleviston> Cale: so, how can I hook that into main?
05:23:58 <cocreature> jophish_: or Control.Applicative((<$>)) :)
05:24:03 <Cale> That could very well just be main itself :)
05:24:06 <julianleviston> Cale: and what’s its type?
05:24:11 <Cale> That action has type  IO ()
05:24:14 <julianleviston> Cale: ahhh
05:24:16 <jophish_> cool stuff, thanks!
05:24:37 <Cale> No fancy monad transformers required :)
05:24:55 <julianleviston> Cale: well, except for the fact that IORef is built using them isn’t it?
05:25:03 <Cale> Monad transformers? No.
05:25:08 <Cale> IORef is built-in
05:25:16 <julianleviston> Cale: ooh
05:25:29 <jophish_> c_modf a = unsafePerformIO $ alloca (\i -> let f = c_modf_imp a i in (f,) <$> peek i) -- Looks ok? where c_modf_imp has type CDouble -> Ptr CDouble -> CDouble
05:26:19 <chpatrick1> jophish_: I would import c_modf_imp as returning IO
05:26:39 <chpatrick1> since it has the side effect of writing to the ptr
05:26:48 <Cale> julianleviston: I'm debating with myself whether to show you this next bit, but I might as well with the caveat that you shouldn't worry much if it seems too fancy for now
05:26:55 <julianleviston> Cale: cool, so the State monad is quite useful for doing stuff where the state useful to do computation across  some data, I guess?
05:27:04 <julianleviston> Cale: :)
05:27:23 <julianleviston> Cale: *where the state is useful to do some…*
05:27:24 <Cale> julianleviston: The State monad is honestly really rarely used
05:27:43 <julianleviston> Cale: Ah ok… I needed to learn it because I’m wanting to build a site with Snap.
05:27:44 <Cale> But there are cases where you're writing some function, and you find yourself passing around these extra values of the same type
05:27:54 <julianleviston> Cale: so I had to work out what was going on for it.
05:28:03 <jophish_> chpatrick1: good thinking. This should do, although it feels a little off peeking from i in the same line as writing to it! c_modf a = unsafePerformIO $ alloca (\i -> (,) <$> c_modf_imp a i <*> peek i)
05:28:32 <Cale> So, if you have a lot of functions that you're writing all taking an extra argument of type S, say, and producing pairs of some result along with a new value of type S
05:28:35 <julianleviston> Cale: … because I wanted to understand Lenses ;-)
05:28:46 <jophish_> odd*
05:28:47 <Cale> then you might want to use State or StateT to clean up the noise
05:28:47 <chpatrick1> that's kinda the deep end julian
05:29:02 <Cale> You might find yourself writing code like:
05:29:07 <chpatrick1> jophish_: seems ok to me
05:29:13 <julianleviston> chpatrick1:  :) yeah, I know. But I’m trying NOT to deep end myself.. that’s just my reason at the moment.
05:29:15 <chpatrick1> might write it with do notation just so it doesn't seem weird
05:29:21 <chpatrick1> but it's morally correct
05:29:32 <Cale> let (v,s') = f s; (w,s'') = g s' ... and so on
05:29:39 <julianleviston> Cale: this is so amusing… I was pretty much just trying to add an item into a list that I had stored in my Snaplet’s state 
05:29:39 <Cale> Where you're threading along this "state"
05:29:45 <Cale> by hand
05:29:50 <jophish_> every other function in this module is a one liner :)
05:29:56 <Cale> It's that pattern of code which the State monad exists to clean up
05:30:02 <julianleviston> Cale: yeah, that makes sense complely.
05:30:15 <julianleviston> Cale: coz you can just go “blam, do block… thread, done"
05:30:45 <Cale> Yeah, the do-notation helps thread the state along for you, and you don't have to mention the s's so much, or worry that you're threading them along correctly.
05:31:09 <Cale> Okay, so I wanted to mention something cool you can do with IORefs
05:31:13 <julianleviston> Cale: yeah, I’ve got a reasonable handle on what the do-notation is doing and how it translates between that and >>= and >>
05:31:18 <julianleviston> Cale: ok :)
05:31:29 <Cale> While you can just pass the IORef down to the places where you need it directly
05:31:46 <jophish_> oh, one more thing. the documentation for unsafePerformIO says to mark the function calling it as NOINLINE, but the underlying operation /is/ pure, so is this annotation still necessary?
05:31:58 <Cale> It's often a good idea to pre-apply readIORef and writeIORef, and pass the resulting values of type IO a and a -> IO () around instead.
05:32:15 <Cale> This does two cool things for you:
05:32:31 <Cale> 1) It lets you control which parts of the program have read or write access to that state
05:32:55 <julianleviston> Cale: sorry you’ve lost me again. :)
05:33:01 <julianleviston> Cale: it became non-concrete.
05:33:03 <Cale> 2) You can make the actions for reading / writing the state more elaborate later, for example, you can make your program log all the changes to the IORef
05:33:13 <Cale> I mean, for example...
05:33:21 <Cale> You might do something like:
05:33:37 <Cale> do r <- newIORef 0; foo r; bar r
05:34:06 <Cale> But maybe foo is really only supposed to write to r
05:34:21 <Cale> and maybe bar is only going to need to read from it
05:34:27 <Cale> That's a bit over-simplified
05:34:46 <Cale> But maybe you get the idea?
05:34:52 <julianleviston> Cale: I think I understand. It’s just like set up in a let expression (hope I got that word right)
05:35:13 <Cale> So, instead of passing the IORef r itself to foo and bar
05:35:21 <Cale> We can write:
05:35:28 <julianleviston> Cale: the expressions in your let block “priming” the definitions for the “in” part?
05:35:37 <Cale> do r <- newIORef 0; foo (writeIORef r); bar (readIORef r)
05:35:50 <Cale> (note that I've implicitly changed the types of foo and bar here)
05:35:58 <julianleviston> Cale: what does writeIORef do?
05:36:20 <julianleviston> Cale: nevermind, I looked it up
05:36:22 <Cale> writeIORef r v  is an IO action which updates the value stored in r, changing it to v
05:36:49 <julianleviston> Cale: hm? writeIORef :: IORef a -> a -> IO ()
05:36:51 <Cale> So, given the function (writeIORef r), foo will be allowed to write any value it likes to the IORef
05:37:09 <Cale> But it won't be able to read the contents of the IORef
05:37:34 <julianleviston> Cale: changing it to a v?
05:37:39 <julianleviston> Cale: I’m lost
05:37:51 <Cale> writeIORef r v <-- this v
05:38:17 <Cale> e.g. I used  writeIORef r 6  in that program from before
05:38:18 <julianleviston> Cale: but… that’s not the type signature of writeIORef
05:38:29 <Cale> hm?
05:38:31 <julianleviston> Cale: oh… that was a function call
05:38:33 <julianleviston> Cale: lol
05:39:12 <Cale> Yeah, the point here is that by partially applying writeIORef to r, we get a function that we can pass around which represents the mechanism for writing
05:39:16 <julianleviston> Cale: ah so (writeIORef r) is passing a partially applied function to foo?
05:39:22 <Cale> yeah
05:39:23 <julianleviston> right
05:39:32 <julianleviston> which you can then just call with a value and it’ll update the right thig
05:39:33 <julianleviston> thing*
05:39:35 <bennofs> hvr: Hey, I have a question about https://github.com/hvr/multi-ghc-travis/commit/79c546841abd54207f441b4edd1a8da3630ec057#diff-f910b3cb6d2f7a62718637d03e2492af. Why is the zcat needed there? It seems that the .tar.gz never exists before cabal update, since it's not removed before storing the cache?
05:39:49 <Cale> and then later if we're debugging and we want to see all the changes that are happening, we can adjust what we've passed down from the top level, like this:
05:40:00 <julianleviston> Cale: yup gotcha
05:40:21 <Cale> foo (\v -> do writeIORef r v; putStrLn $ "Updating r to " ++ show v)
05:40:45 <hpc> bennofs: that line is an odd way of writing gunzip too
05:40:56 <Cale> (or log to a file or something, just as easily)
05:41:08 <Cale> I've found this technique to be really helpful in the past
05:41:28 <julianleviston> Cale: printf debugging? ;-)
05:41:36 <julianleviston> Cale: it is quite helpful
05:41:52 <Cale> yeah, well, in one case, I was writing a game, and we wanted to be able to record test cases of user input
05:42:34 <Cale> So I captured all the changes to the state which were caused in one place by user inputs before those values got sent along to our essentially pure FRP system
05:42:46 <Cale> and wrote them to a file
05:43:13 <julianleviston> Cale: any hints for learning lenses? :)
05:43:13 <Cale> and then I was able to about as easily read the file back and make the same updates to state
05:43:29 <Cale> Well, hmm
05:43:45 <julianleviston> Cale: yeah… I’ve done that before. :) swap application state in and out, when in an FRP system - it’s very handy.
05:43:54 <Cale> I guess it depends on whether you're asking about the concept generally or the "lens" library specifically.
05:44:19 <julianleviston> Cale: http://haddock.stackage.org/lts-3.6/lens-4.12.3/
05:44:27 <julianleviston> Cale: I was thinking of that one, specifically :)
05:44:32 <Cale> yeah, lens has gotten huge
05:44:35 <Cale> and complicated
05:44:38 <julianleviston> Cale: good old EK :)
05:44:58 <Cale> You might want to start out with a simpler lens library first.
05:45:10 <julianleviston> Cale: the context is a snap application… and I’m in a handler (:: S.Handler HelloWorld HelloWorld)
05:45:18 <julianleviston> Cale: sadly I can’t. :)
05:45:23 <julianleviston> Cale: because I’m using Snap
05:45:30 <Cale> ah, if you're trying to work with code that uses lens already, sure, I guess you have to deal with it :)
05:45:41 <julianleviston> Cale: thing is, I understand the basics of lenses just fine.
05:45:49 <jophish_> chpatrick1: I'm going to use unsafeDupablePerformIO, I think that should be fine
05:45:51 <chpatrick1> what helped me a lot in lens is realizing that all of the types have the same shape and mainly only differ in the constraints on the functor
05:45:55 <julianleviston> Cale: I’ve done something similar with cursors in Clojure.
05:46:17 <bennofs> julianleviston: well, lens-family and microlens are both simpler libraries that build on the same concept as the lens library, so you can use those libraries to understand the concept 
05:46:25 <Cale> What's the code you're having trouble with?
05:46:34 <chpatrick1> jophish_: looks good to me
05:46:58 <jophish_> we'll see what edwardk says when I submit the pull request :)
05:47:10 <julianleviston> Cale: I’m having trouble knowing what context I’m in inside the handler… like… it seems to have an instance of State, which means I can do things like title L..= newTitle
05:47:41 <julianleviston> bennofs:  mostly it’s the sheer number of operators and inability to find them that’s a problem, I guess.
05:47:50 <julianleviston> bennofs: seems to span the entirety of haskell :)
05:48:25 <Cale> julianleviston: Yes, indeed, there's an instance of the MonadState type class for Handler
05:48:27 <julianleviston> Cale: but I have a thing called blogEntries (that’s a lens, constructed with the makeLenses TH thingie)… 
05:48:36 <bennofs> julianleviston: oh, you don't need to use the operators. But there's a system: for each operator, there are two versions: ~ works in the "reader" monad (for example, a +~
05:49:11 <bennofs> _1 +~ 2 can have type (Int, a) -> (Int, a)   
05:49:12 <julianleviston> Cale: so I’m not really sure how to 1. get the data out, and 2. set it back in
05:49:30 <bennofs> julianleviston: and the = versions work in the state monad.
05:49:37 <julianleviston> ah ok
05:50:30 <julianleviston> mostly the confusion comes from … when I type “inputBlogEntry” - what *is* that?
05:50:37 <julianleviston> It’s a lens?
05:50:44 <julianleviston> or is a function that gets data?
05:50:44 <Cale> julianleviston: Honestly, I recommend just using  gets (view blogEntries)  to read the blogEntries
05:50:46 <julianleviston> lol… I have no idea
05:50:56 <julianleviston> Cale: gets?
05:50:59 <julianleviston> Cale: what is gets?
05:51:12 <Cale> It's defined by the MonadState class
05:51:16 <julianleviston> Cale: oh… monadstate thingie.
05:51:45 <julianleviston> Cale: to get the state out? and it’ll work on the lens? what does view do? view gets the state out by lens, does it?
05:51:47 <Cale> uhhh, or it should be
05:52:02 <julianleviston> Cale: gets :: MonadState s m => (s -> a) -> m a yep?
05:52:03 <Cale> hang on a sec
05:52:05 <Cale> yes
05:52:11 <julianleviston> yp
05:52:40 <Cale> yeah, so (the action constructed by) gets applies a function to the current state, and produces the result of that function
05:53:16 <Cale> and whenever l is some lens and v is some big structure, then  view l v  will extract the part of the big structure which the lens l focuses on
05:53:19 <julianleviston> Cale: ok… and then I can… puts?
05:53:36 <julianleviston> Cale: it’ll extract it as? as the data?
05:53:39 <Cale> modify (set blogEntries newBlogEntries)
05:53:44 <julianleviston> Cale: ah modify
05:53:51 <julianleviston> Cale: does the dual of gets?
05:53:54 <Cale> kinda
05:53:55 <Cale> heh
05:53:57 <julianleviston> Cale: erm
05:54:06 <julianleviston> oh
05:54:14 <Cale> modify :: MonadState s m => (s -> s) -> m ()
05:54:18 <julianleviston> set transforms the data, but modify writes it back into the monad state?
05:54:25 <Cale> yeah
05:54:28 <julianleviston> confusing names.
05:54:35 <julianleviston> man naming really matters.
05:54:45 <julianleviston> ok cool
05:55:26 <Cale> Well, the names all make sense individually
05:55:34 <Cale> It's just you have to remember what goes with what
05:55:44 <julianleviston> Cale: yeah, they make sense, but “set” is not what it’s actually doing, is it
05:55:48 <bennofs> julianleviston: btw, lens already provides a function for that, 'assign': assign blogEntries newBlogEntries should do the same
05:55:51 <julianleviston> Cale: because it’s not mutating state.
05:56:06 <julianleviston> bennofs: function for what?
05:56:09 <Cale> Well, it's sort of mutating the structure in the only way that a function can :)
05:56:14 <bennofs> > set _1 2 (1,2)    -- sets _1 to 2 
05:56:16 <lambdabot>  (2,2)
05:56:27 <Cale> > set _1 6 (1,2)
05:56:29 <lambdabot>  (6,2)
05:56:39 <bennofs> julianleviston: assign l v = modify (set l v)
05:56:47 <julianleviston> ah ok
05:56:53 <Cale> > view _1 (1,2)
05:56:55 <lambdabot>  1
05:57:08 <julianleviston> furiously writing this down :)
05:57:14 <Cale> yeah, I always just forget that things like assign exist
05:57:46 <julianleviston> Cale: well, like you say, if I know how to do the atomic things, then I can always learn the composed things ltater.
05:57:48 <Cale> A big fraction of the point of working with a functional language is that we have higher order functions and can avoid giving things like that names. :)
05:57:49 * hackagebot libinfluxdb 0.0.2 - libinfluxdb  https://hackage.haskell.org/package/libinfluxdb-0.0.2 (wereHamster)
05:58:01 <julianleviston> Cale: yeah :)
05:58:30 <Cale> A big problem with lens for me is that it defines hundreds of things which I find a bit unnecessary
05:58:46 <Cale> But the core idea is good, and there are also lots of useful things.
05:59:24 <julianleviston> Cale: yeah, I’ve heard that a lot.
05:59:36 <Cale> If you use all of the stuff in Lens, you end up writing in a language which doesn't look like Haskell any more
05:59:52 <julianleviston> Cale: there really needs to be someone *other* than E.K. explains the absolute basics… 
06:00:08 <julianleviston> Cale: assuming “more accessiblilty” is the aim here.
06:00:21 <zomg> About naming things, I saw someone ask on another channel about best practices for naming partially applied functions... I think this was with regards to JavaScript rather than Haskell, but I immediately thought that someone here would probably have some ideas :P
06:00:36 <Cale> I should probably write a basic lens tutorial which is extremely opinionated about which parts are worth learning about :P
06:00:38 <julianleviston> zomg:  hehe… 
06:00:44 <julianleviston> Cale: yes. You should.
06:00:57 <julianleviston> Cale: and litter it with tiny tiny examples, like you were writing it to me.
06:01:02 <julianleviston> Cale: little steps.
06:01:10 <julianleviston> Cale: for Julian’s frightened brain :0
06:01:11 <julianleviston> lol
06:01:30 <bz> :t _1
06:01:31 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
06:01:45 <Cale> bz: Isn't that fun? :)
06:01:55 <julianleviston> hehe :) I love the lens types.
06:02:00 <julianleviston> poor EK.
06:02:05 <Cale> The Field1 stuff is just so that it'll work on any size tuple
06:02:10 <bennofs> julianleviston: idk, but how about https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial ?
06:02:16 <Cale> > view _1 (1,2,3,4,5,6)
06:02:19 <lambdabot>  1
06:02:22 <Cale> > view _3 (1,2,3,4,5,6)
06:02:24 <lambdabot>  3
06:02:34 <Cale> But who even uses tuples which are not pairs?
06:02:36 <bennofs> (where any size means: "any size as long as it's less than 9 or so")
06:02:39 <julianleviston> bennofs: that “tute” made me very, very, very sad.
06:02:50 <bz> and i'm guessing there are O(n^2) instance definitions
06:03:00 <julianleviston> bennofs: I’ve read it 5 times over the last 3 weeks… and it’s by no means simple , or accessible.
06:03:28 <bennofs> julianleviston: hmm ok, I can't really speak for this, as it's hard to judge learning material when you already know the concepts :p
06:03:30 <julianleviston> bennofs: anything that mentions prisms, traversals and Iso’s in the first para might not be for beginners :)
06:03:43 <julianleviston> bennofs: I don’t think so
06:04:09 <julianleviston> bennofs: just pretend you’re fresh and you know nothing
06:04:17 <Cale> Actually, one thing which I think is worth reading as a start are some blog posts by Twan van Laarhoven
06:04:23 <bennofs> julianleviston: that's not as easy as it sounds
06:04:23 <Cale> http://www.twanvl.nl/blog/haskell/overloading-functional-references
06:04:40 <julianleviston> bennofs: ah maybe I’m just good at it because I practice it ;-)
06:04:47 <Cale> http://www.twanvl.nl/blog/haskell/cps-functional-references
06:04:50 <julianleviston> or maybe I’m rubbish at it, and I just don’t know
06:05:24 <julianleviston> CPS? does he means CSP?
06:05:26 <bennofs> julianleviston: hmm... I think what really helped me to finally understand lenses was http://youtu.be/cefnmjtAolY?hd=1 ... if you've got the time
06:05:27 <Cale> no
06:05:31 <Cale> continuation passing style
06:05:37 <julianleviston> ahhh
06:05:50 <julianleviston> bennofs: yeah, I’ve watched that 4 times now
06:06:21 <julianleviston> bennofs: I understand them just fine, I’m pretty sure… it’s all the stuff in them and knowing which things do what… 
06:06:49 <bennofs> julianleviston: oh. so you do understand the forall f. Functor f => (a -> f b) -> s -> f t  representation of lenses?
06:06:51 <Cale> Part of the trouble here is that things moved very very quickly once the library got started, and if you weren't around at the beginning, it became hard to catch up
06:06:54 <julianleviston> bennofs: they’re just a way of grabbing a handle inside some data structure and manipulating the whole data structure using that handle
06:07:11 <julianleviston> bennofs: I don’t undertand forall, so no.
06:07:37 <Cale> julianleviston: Oh, that's just making explicit the fact that the thing has to work for any choice of functor f
06:07:49 * hackagebot publicsuffix 0.20150927 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20150927 (wereHamster)
06:07:58 <julianleviston> bennofs: part of the thing about haskell is I’m still learning it. So far, none of the actual concepts in it are new to me, though. They’re just the way things should be.
06:08:13 <Cale> In particular, the two functors that you care about are the constant functor and the identity functor
06:08:54 <Cale> But lenses really do work at other functor types as well...
06:09:27 <julianleviston> Cale: I don’t know what most of that stuff means. What’s the constant functor, and the identity functior?
06:09:29 <julianleviston> functor?
06:09:50 <bennofs> julianleviston: data Const c a = Const c. Try to implement functor for that (that's the constant functor)
06:09:53 <julianleviston> actually, you know what, don’t worry too much about that. I’m just trying to understand what you said.
06:10:17 <bennofs> julianleviston: identity functor is newtype Identity a = Identity a. You can also implement Functor for that
06:10:28 <Cale> So yeah, bennofs gave the definition of the constant functor -- Const c is a functor which for any type a will give you a type which is essentially the same as a
06:10:33 <Cale> er, c
06:10:36 <Cale> dang
06:10:36 <julianleviston> bennofs: no idea what you’re talking about. It’s ok tho :)
06:10:37 <Cale> So yeah, bennofs gave the definition of the constant functor -- Const c is a functor which for any type a will give you a type which is essentially the same as c
06:11:02 <bennofs> julianleviston: oh, so you haven't learned about the typeclass Functor yet?
06:11:03 <Cale> Just like the const function, but at the type level
06:11:09 <julianleviston> bennofs: no, I have
06:11:31 <Cale> So, let's implement Functor for these
06:11:36 <julianleviston> Cale: why?
06:11:38 <Cale> instance Functor (Const c) where
06:11:50 <Cale>   fmap f (Const x) = Const x
06:11:52 <julianleviston> fmap = id ?
06:12:03 <magneticduck> so, I spent a bit of time figuring out exactly what language extensions were being used in a project and putting them in the default-extensions field of the cabal file
06:12:09 <magneticduck> but for some reason it's not parsing
06:12:09 <julianleviston> <shrug> I have no idea what I’m talking about, clearly.
06:12:10 <magneticduck> https://gist.github.com/fcd1448f40ef23ab85d4
06:12:14 <Cale> Here,  fmap :: (a -> b) -> Const c a -> Const c b
06:12:22 <magneticduck> fails with a generic 'cannot parse field 'default-extensions''
06:12:37 <Cale> and notice that a value of type  Const c a  doesn't actually contain any values of type a for us to apply the function to
06:12:58 <julianleviston> Cale: what are we even talking about here?
06:13:04 <julianleviston> and why?
06:13:17 <hexagoxel> magneticduck: no "," separator for extensions
06:13:24 <marchdown> I'm confused about wrapping values. what do I put in place of ???
06:13:25 <marchdown> twelfe_random_interval_classes = replicateM 12 (randomIO :: IO Int)
06:13:25 <marchdown>                                  ??? (\xs -> map (\x -> x `mod` 12) xs)  
06:13:26 <marchdown>                                  >>= print
06:13:32 <Cale> We're talking about the implementation of the instance of Functor for this Const data type which bennofs gave the definition for
06:13:32 <magneticduck> hexagoxel: removed, still the same issue
06:13:35 <julianleviston> marchdown: use the pasiebin.
06:13:42 <julianleviston> Cale: but why?
06:14:00 <marchdown> julianleviston: Sure, thanks. Thought four lines would be ok here, but will use pastie in the future.
06:14:09 <Cale> and we're talking about it because it's critical to how the (a -> f b) -> (c -> f d) lenses work
06:14:17 <cocreature> marchdown: fmap or to be precise a flipped version of fmap
06:14:24 <hexagoxel> magneticduck: ah, and the parser is too stupid to recognize lines with an extension and a comment
06:14:43 <Cale> In particular, if we plug in  f = Const a
06:15:08 <hexagoxel> e.g. put `FlexibleContexts -- https://prime.haskell.org/wiki/FlexibleContexts` into two lines
06:15:11 <Cale> Then this type becomes  (a -> Const a b) -> (c -> Const a d)
06:15:23 <julianleviston> I am seriously SO confused
06:15:33 <magneticduck> darn
06:15:35 <magneticduck> hexagoxel: thanks
06:15:41 <Cale> Now, you can imagine that Const a b is essentially the same as a, as it's just a wrapper for a value of type a, right?
06:15:56 <Cale> So this type is more or less (a -> a) -> (c -> a)
06:16:13 <julianleviston> Cale: pretty much anytime I ask a question in here, I end up thinking I know nothing, and need to go back to the beginning and start again
06:16:19 <Cale> and if we plug in the obvious "a -> a" there, that is, the identity function, we get a function of type c -> a
06:16:26 <Cale> which is what view does
06:16:50 <Cale> hmm, is there a good monomorphic lens I can use as an example?
06:16:53 <hexagoxel> magneticduck: ah, and "," are allowed, but not mandatory.
06:17:11 <Cale> sigh, everything is so polymorphic
06:17:15 <marchdown> cocreature: ... could you be more specific? I replace map with fmap and glue it to replicateM and print... how exactly? Alternatively, what should I read up on?
06:17:17 <Cale> anyway
06:17:20 <Cale> :t _1
06:17:21 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
06:17:27 <Cale> :t view _1
06:17:28 <bennofs> @let _fst f (a,b) = (,b) <$> f a  -- Cale
06:17:28 <lambdabot> (MonadReader s m, Field1 s s b b) => m b
06:17:30 <lambdabot>  Defined.
06:17:35 <Cale> bennofs: ah, thanks!
06:17:39 <Cale> :t _fst
06:17:40 <lambdabot> Functor f => (t -> f a) -> (t, t1) -> f (a, t1)
06:17:49 <Cale> :t view _fst
06:17:50 <lambdabot> MonadReader (t, t1) m => m t
06:17:53 <julianleviston> argh the types
06:17:57 <Cale> ugh
06:18:00 <Cale> Even view
06:18:06 <Cale> is not the view I want
06:18:07 <Cale> hahaha
06:18:26 <Cale> anyway, pretend that says  view _fst :: (t, t1) -> t
06:18:31 <bennofs> :t view'  -- just defined it
06:18:32 <lambdabot> ((a1 -> Const a1 b1) -> a -> Const c b) -> a -> c
06:18:40 <bennofs> > view' _fst
06:18:41 <lambdabot>      No instance for (Typeable c0)
06:18:42 <lambdabot>        arising from a use of ‘show_M2212583015691300609482’
06:18:42 <lambdabot>      In the expression:
06:18:43 <bennofs> :t view' _fst
06:18:44 <lambdabot> (c, t1) -> c
06:18:47 <Cale> cool
06:21:11 <Cale> julianleviston: I wish it were a little easier to use colours on IRC, it might help make it clearer how the types line up here
06:21:34 <julianleviston> Cale: I’m not sure how to respond
06:22:02 <julianleviston> Cale: I don’t know any of lens’s syntax.
06:22:11 <julianleviston> Cale: and types confuse me at the best of times.
06:22:21 <julianleviston> Cale: so… Happy Birthday, Julian! :)
06:22:28 <Cale> Okay, so maybe we should start from the beginning of lenses
06:22:33 <Cale> Originally, it was quite simple
06:22:45 <julianleviston> Cale: maybe I just don’t know anything at all
06:22:48 <Cale> We had something like:
06:23:55 <Cale> data Lens s a = L { view :: s -> a, set :: a -> s -> s }
06:24:58 <Cale> So, the idea is that this lens describes two things for us: given some "big" structure of type s, how to extract a field of type a from it, and given a value of type a, and a structure of type s, how to replace the field, producing another structure of type s
06:25:05 <Cale> yes?
06:25:13 <Cale> I take it you get this idea already
06:25:17 <julianleviston> god I hate Haskell
06:25:22 <julianleviston> ok
06:25:23 <julianleviston> let’s go
06:25:32 <julianleviston> some big structure of type s
06:25:32 <Cale> What's there to hate about this part?
06:25:37 <julianleviston> Cale: the language
06:25:40 <Cale> This is pretty simple so far
06:25:44 <julianleviston> Cale: (ie the meta-language)
06:25:46 <julianleviston> haha is it?
06:25:56 <julianleviston> let me just rephrase it
06:26:21 <Cale> "structure" here isn't so much a technical term, I just mean any value
06:26:43 <julianleviston> “given a piece of data how do we get some part of it out”
06:26:45 * narendraj9 is quietly listening. Things make sense so far.
06:26:46 <Cale> But I intend to make you think of record types especially
06:26:50 <Cale> yeah
06:27:25 <julianleviston> I’m not sure why, but ok
06:27:53 <Cale> Well, record types are the most obvious types that have fields which we might want to extract and update
06:27:59 <julianleviston> “and how to create a new structure such that that field has different data in it"
06:28:06 <Cale> yep
06:28:09 <Cale> Okay
06:28:10 <julianleviston> precision of language
06:28:14 <julianleviston> also “get that data out” is wrong
06:28:27 <Cale> It's kinda right
06:28:35 <julianleviston> “create a copy of some smaller part of a bigger piece of data”
06:28:37 <julianleviston> ok
06:28:51 <Cale> You actually probably won't copy it
06:29:01 <Cale> Everything's made of pointers anyway :P
06:29:05 <julianleviston> Cale: structural sharing aside.
06:29:10 <Cale> So you'll be copying a pointer in most cases
06:29:19 <Cale> But not necessarily of course
06:29:20 <julianleviston> Cale: something representing it gets copied.
06:29:40 <julianleviston> Cale: otherwise there wouldn’t be anything different.
06:30:09 <Cale> But yeah, in fact, you might even have  Lens Integer Bool  or something
06:30:20 <Cale> which provides a view of a single bit in an Integer
06:30:36 <Cale> and then view and set will do some arithmetic :P
06:30:37 <julianleviston> or, put a different way… given {yay = {boo = “woo!”}} how do you get a copy of boo’s value out separtely from the whole value?
06:30:48 <Cale> yeah
06:30:56 <julianleviston> Cale: yep.
06:31:00 <Cale> Okay, so anyway
06:31:05 <julianleviston> Cale: concepts are super super simple.
06:31:54 <julianleviston> Cale: I’m not sure what your purpose is, here. Are you trying to explain how to derive lenses to me?
06:32:07 <julianleviston> Cale: because I probably don’t need to know that, do I?
06:32:29 <Cale> No, I'm just going right back to basics in the interest of showing how things changed over time
06:32:47 <Cale> So that the modern definition maybe has some hope of making sense?
06:32:49 <Cale> I dunno
06:32:52 <julianleviston> ah
06:32:54 <Cale> Maybe you're not interested in this
06:32:58 <julianleviston> lol
06:33:03 * julianleviston hugs Cale
06:33:28 <Cale> The thing which twanvl realised is that we can encode any lens which looks like this as just a single polymorphic function of type  (a -> f a) -> (s -> f s), where f is an arbitrary functor.
06:33:40 <Cale> By picking two different functors, we can recover view and set
06:34:04 <Cale> This alternate representation has some advantages
06:34:08 <julianleviston> looks like what?
06:34:19 <pie_> so im reading about funky stuff like this https://en.wikipedia.org/wiki/Graph_reduction_machine , i havent done any functional programming yet, but do "alternative" computation paradigms like that have practical applications?
06:34:32 <Cale> I mean of our Lens s a data type
06:34:32 <pie_> or rather can they compete with current stuf fin any way?
06:34:48 <Cale> We can replace  data Lens s a = L { view :: s -> a, set :: a -> s -> s }
06:34:55 <julianleviston> Cale: I’m still getting my head around types that have two parameters. Fun.
06:34:57 <Cale> with  Functor f => (a -> f a) -> (s -> f s)
06:35:37 <Cale> and the neat thing about this representation is that instead of having to define a separate function for composing two lenses
06:35:55 <Cale> compose :: Lens a b -> Lens s a -> Lens s b
06:36:03 <Cale> we get to use ordinary function composition instead
06:36:37 <julianleviston> oh because they’re both functors
06:36:39 <mniip> [15:28:48] <Cale> This alternate representation has some advantages
06:36:44 <mniip> it has disadvantages too
06:36:44 <geekosaur> pie_, it can do the same things that the evaluation you are used to can
06:36:48 <Cale> mniip: definitely
06:36:57 <mniip> it's not /any/ value of type (a -> f a) -> (s -> f s)
06:37:10 <mniip> you have restrictions
06:37:14 <mniip> lens laws in particular
06:37:18 <Cale> mniip: nor was it any value of type Lens s a :P
06:37:48 <Cale> I didn't really say anything about the lens laws
06:37:59 <julianleviston> I can’t seem to use “gets” - is that because It’s only in state? having not imported them or monad transformers.
06:38:06 <Cale> uh
06:38:21 <geekosaur> it's non-strict by default, which lets you write some things more naturally without losing performance (you can work with "infinite" values, you can compute things in a spreadsheet-like way, etc.)
06:38:25 <julianleviston> I wonder if it’s in Snap.
06:38:32 <geekosaur> you do have to think about programming a bit differently
06:38:35 <Cale> yeah, gets will only get you an action of monads which are an instance of MonadState
06:38:43 <julianleviston> hoogle on stackage.org wouldn’t search that would it
06:38:47 <Cale> so if you're writing an IO action or something, you can't use gets
06:39:02 <julianleviston> Cale: I’m not. I’m in a Snapllet
06:39:10 <Cale> okay, let me look that up :)
06:39:31 <julianleviston> Cale: which I’m pretty sure is a value whose type is an instance of monadstate 
06:39:53 <Cale> Snaplet s doesn't appear to even be a monad
06:40:23 <Cale> Handler is a monad though
06:40:43 <julianleviston> oh sorry. I’m tired
06:40:51 <julianleviston> Cale: yeah, I’m in a S.Handler (s = Snap)
06:40:56 <Cale> and there's an instance  MonadState v (Handler b v)
06:41:01 <julianleviston> yeah
06:41:06 <Cale> So you should be able to use gets
06:41:07 <Cale> :t gets
06:41:09 <lambdabot> MonadState s m => (s -> a) -> m a
06:41:13 <julianleviston> no I can’t 
06:41:18 <Cale> What error are you getting?
06:41:20 <julianleviston>  Not in scope: ‘gets’
06:41:26 <julianleviston> In ghci.
06:41:27 <Cale> oh, well, that's something :P
06:41:31 <julianleviston> yeah :)
06:41:45 <julianleviston> Perhaps you meant ‘L.sets’ (imported from Control.Lens)
06:41:47 <julianleviston> hehe :)
06:41:53 <Cale> import Control.Monad.State.Class
06:42:28 <Cale> If you get an error like that, it means the thing is literally not defined at all
06:42:44 <Cale> which if you think it should be, means that you're missing an import
06:42:45 <julianleviston> oh hand on I just have to add that to my packages
06:43:12 <Cale> If it existed and you were just using it incorrectly, you'd have gotten a type error
06:44:10 <julianleviston> Cale: that didn’t work too well. 
06:44:26 <Cale> Now what?
06:44:27 <julianleviston> Cale: No instance for (CMSC.MonadState HelloWorld m0)
06:44:34 <Cale> uhhh
06:44:45 <julianleviston> maybe a different function than gets?
06:44:57 <Cale> That indicates that you're trying to use gets as a value of type HelloWorld
06:45:00 <Cale> which it is not
06:45:05 <julianleviston> ohhh
06:45:21 <julianleviston> i have this : let newBlogEntry = CMSC.gets (L.view inputBlogEntry)
06:45:25 <julianleviston> is that completely bonkers?
06:45:31 <Cale> newBlogEntry <- CMSC.gets (L.view inputBlogEntry)
06:45:38 <julianleviston> hm
06:45:43 <Cale> You want to execute the computation which gets builds for you
06:45:44 <julianleviston> oh coz it’s state
06:45:46 <julianleviston> right
06:46:21 <julianleviston> I wish I understood what I was doing
06:46:26 <julianleviston> I clearly don't.
06:46:32 <Cale> Eventually you will :)
06:46:44 <Cale> Honestly, the best way is just to use this stuff
06:46:49 <julianleviston> Cale: yeah :)
06:47:28 <Cale> The moment you try to discuss it separately from the concrete examples, you have to live with abstract language.
06:47:47 <Cale> and eventually you'll get better at dealing with that too
06:47:49 <julianleviston> This seems like a lot of work to just append a string to a  list
06:47:55 <Cale> heh
06:48:01 <julianleviston> Cale: I find the language close to impossible.
06:48:11 <julianleviston> Cale: but I think I’m *slowly* getting a handle on some of it.
06:48:24 <Cale> Well, once you understand the concrete examples it's referring to
06:48:25 <julianleviston> Cale: it’s pretty funny considering most of my life I’ve been considered extremely pedantic.
06:48:29 <Cale> then it's not so abstract any more
06:48:33 <julianleviston> Cale: yeah.
06:48:56 <Cale> But if you understand zero examples of the abstraction, trying to understand the abstraction is hard
06:49:06 <julianleviston> Cale: yeah, I know :)
06:49:28 <julianleviston> Cale: I tried to build myself up from nothing by a series of tiny exercises… 
06:49:45 <julianleviston> I think it works quite well
06:50:10 <julianleviston> Cale: the trouble is, it goes meta-abstract very quickly at a certain point.
06:50:20 <Cale> julianleviston: The cool thing is that all this abstraction is actually *useful* in Haskell, and lets us really reuse code, rather than just talking about the hope of being able to reuse code and then never actually do it like some people.
06:50:21 <julianleviston> Cale: roughly around typeclasses
06:50:31 <julianleviston> Cale: yeah ! :) 
06:50:46 <julianleviston> Cale: I (hopefully) obviously appreciate and love Haskell
06:50:59 <julianleviston> Cale: when I said I hate Haskell before, I actually meant all the language that goes with it.
06:51:04 <Cale> But that's not to say that we don't get carried away
06:51:15 <julianleviston> Cale: :-) well we are humans :)
06:51:29 <Cale> Honestly, I think MonadState itself is just slightly overstepping things
06:52:03 <julianleviston> Cale: Looking at this code I have in front of me, I hope I’m not writing idiomatic Haskell
06:52:23 <Cale> and in the best cases, uses of MonadState would be better served by a more application-specific type class, and in the worst cases, just monomorphic operations would be fine
06:52:32 <julianleviston> Cale: “submit a form with one field on it” ;-) 
06:52:48 <julianleviston> Cale: what’s a monomorphic operation?
06:52:54 <Cale> the opposite of polymorphic
06:53:02 <julianleviston> Cale: a constant?
06:53:12 <julianleviston> 5 ?
06:53:18 <julianleviston> not the opposite, mind
06:53:20 <julianleviston> poly = many
06:53:22 <julianleviston> mono = one
06:53:26 <Cale> I mean, like operations which are not generalised to work in any monad which satisfies X condition
06:53:28 <julianleviston> the opposite of many = 0.
06:53:42 <julianleviston> ok
06:53:46 <Cale> but just work in the one monad you're actually using them in, and have simpler types which don't have variable monads in them
06:53:52 <julianleviston> Like… Num a ?
06:54:08 <julianleviston> lol ok.
06:54:10 <Cale> Yeah, (+) :: Num a => a -> a -> a  is polymorphic
06:54:20 <julianleviston> oh I thought it was monomorphic
06:54:21 <Cale> (+) :: Integer -> Integer -> Integer  would be monomorphic
06:54:26 <julianleviston> oh ok
06:54:42 <julianleviston> what do you call “having more than one type variable” ?
06:54:43 <julianleviston> just that?
06:54:46 <Cale> just that
06:54:50 <julianleviston> ok
06:54:53 <julianleviston> Just “that” :-)
06:54:58 <julianleviston> sigh
06:55:46 <Cale> There are also things in between which people rarely explore or consider enough
06:55:53 <Cale> and I'd kind of like to see that change
06:56:10 <julianleviston> waht do you mean?
06:56:18 <Cale> Like, if you want to ensure that a monad m supports certain operations
06:56:24 <julianleviston> oh
06:56:26 <julianleviston> yes
06:56:27 <Cale> You don't necessarily need to define a type class
06:56:36 <Cale> You could instead define a record data type
06:56:37 <julianleviston> just constraints improvement
06:56:40 <Cale> with fields for the operations
06:56:48 <Cale> and then just take a function parameter of that record type
06:57:09 <Cale> People often jump straight to type classes without considering whether it's really the right thing
06:57:29 <Cale> It's the right thing if there's guaranteed to be one "right" way to implement the operations
06:58:10 <Cale> if we wanted, we could have a data type:
06:58:43 <Cale> data StateOps s m = SO { get :: m s; put :: s -> m () }
06:59:50 <Cale> and then instead of something like MonadState s m => ... we could use StateOps s m -> ...
07:00:03 <Cale> Sure, there's an extra function parameter you pass around, that's a bit annoying sometimes
07:01:27 <Cale> But there are some pretty cool things you can do, for example
07:01:30 <Cale> refOps :: IORef s -> StateOps s IO
07:01:53 <Cale> refOps r = SO { get = readIORef r, put = writeIORef r }
07:02:14 <Cale> (btw, there was a semicolon in my definition of StateOps which should be a comma)
07:03:05 <julianleviston> Cale: wow. I added a thing to an array in my state :) hehe thanks. 
07:03:16 <julianleviston> GOSH that’s complicated. I’m sure I’m doing it wrongly
07:03:23 <Cale> What are you doing?
07:03:43 <julianleviston> Cale: I’ll pastie it
07:04:00 <lpaste> JulianLeviston pasted “my crappy code ” at http://lpaste.net/141824
07:04:48 <julianleviston> Cale: I figure I can probably use <>=, but I really have no idea about how to use it.
07:05:10 <Cale> That's not *so* horrible
07:05:20 <julianleviston> Cale: pulling the data out of the state context, and then putting it back in in 3 steps - I *know* that’s wrong.
07:05:55 <Cale> But I would tend to import things like gets unqualified (It's understandable you might be more comfortable leaving the module qualifiers in just for your own sake)
07:06:12 <Cale> and infix operators qualified look awful :)
07:06:22 <julianleviston> Cale: well given that in clojure I could write (swap! thing assoc :x new-val) I’m pretty sure it’s wrong.
07:06:39 <julianleviston> Cale: oh yeah, I realise… I prefer to know where things come from until I “just know” :)
07:07:25 <Cale> Also, (++) is necessarily linear time, so if you're doing this often and the list gets long, maybe it shouldn't be a list, or it should be stored in the opposite order
07:07:34 <julianleviston> Cale: yeah, I know.
07:07:44 <julianleviston> Cale: it was just to make it compile.
07:08:11 <julianleviston> Cale: should be using a different data structure most likely.
07:08:32 <Cale> So... there's probably shorthand for gets (view ...)
07:08:49 <julianleviston> Cale: can’t I just “lens update inside” the structure?
07:09:23 <julianleviston> Cale: given that they’re both in the structure.
07:09:56 <magneticduck> uh, can dividing code up into a few more module have dramatic influences on compile / linking time?
07:10:00 <magneticduck> >_>
07:10:05 <Cale> ah, it's "use"
07:10:11 <Cale> use l = State.gets (view l)
07:10:31 <julianleviston> Cale: ah
07:10:38 <julianleviston> magneticduck:  yes.
07:10:59 <julianleviston> magneticduck: only from wht I’ve heard, mind.
07:11:01 <magneticduck> what order / factors / nature?
07:11:29 <magneticduck> holy crap this is taking a long time
07:11:29 <Cale> magneticduck: It hopefully should decrease the time spent compiling, because changes to one module don't necessarily require recompiling everything else.
07:11:33 <julianleviston> magneticduck: pretty sure I’ve read that long modules can cause GHC to take a while to compile.
07:11:39 <magneticduck> Cale: that's true yeah
07:12:07 <Cale> and yeah, GHC can take a lot of memory compiling large modules, and if this causes your machine to start swapping, will tend to also make it take forever
07:12:13 <magneticduck> like I have this thing that is 500 lines of template haskell
07:12:16 <magneticduck> for some reason
07:12:21 <julianleviston> Cale: where does use come from?
07:12:23 <julianleviston> Cale: lens?
07:12:26 <magneticduck> a 500 line quasiquote
07:12:27 <magneticduck> kill me
07:12:54 <Cale> julianleviston: yeah
07:13:02 <julianleviston> TH… <shudder>
07:13:06 <Cale> http://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Getter.html#v:use
07:13:09 <julianleviston> why do I hate it so much
07:13:23 <julianleviston> no good reason, no doubt.
07:13:27 <Cale> TH is not that bad, if you understand the Haskell syntax pretty well.
07:13:42 <julianleviston> Cale: it’s like lisp macros… 
07:13:50 <Cale> yeah
07:14:28 <Cale> The evil thing is when you have TH definitions which define things that have names which don't appear anywhere in the source code
07:14:32 <Cale> making them ungreppable
07:14:51 <Cale> But that's also quite a powerful technique at the same time
07:15:09 <Cale> Yesod does too much of that for my liking
07:15:16 <julianleviston> Cale: agreed.
07:15:21 <julianleviston> Cale: so much magic.
07:15:34 <Cale> But I can't argue that they don't get a lot of benefit from it at the same time
07:15:35 <magneticduck> that's one of the issues I'm having right now
07:15:46 <magneticduck> people making huge weird TH stuff and having no actualy export list
07:16:23 <magneticduck> module HugeThingWithNoDocumentation where $(weirdTemplateHaskellThing [customQuasiQuote|five hundred freaking lines of quasiquote]) 
07:16:38 <Cale> hahaha
07:16:39 <Cale> yes
07:16:54 <Cale> did you know you can even do without the $(...) now?
07:17:00 <julianleviston> dark arcane magic!
07:17:10 <Cale> You can write expressions at top level and they'll be treated as splices
07:17:11 <magneticduck> yeah I see top-level function calls and I think I'm doing PHP or something
07:17:29 <Cale> It's actually pretty nice looking in many cases
07:17:44 <Cale> $(...) looks like bash :)
07:17:51 <magneticduck> at least it's explicit
07:17:54 <magneticduck> but sure
07:18:12 <Cale> There's nothing else that a top-level expression could be of course
07:18:27 <magneticduck> I'd probably rather write a huge service in PHP than bash anyway
07:18:39 <magneticduck> heh
07:19:02 <julianleviston> magneticduck:  lol I once tried to implement metaclasses in PHP 4 (before it has OOP). that was funny.
07:19:08 <julianleviston> had*
07:19:17 <Cale> julianleviston: anyway, you could always turn it into one line, but in this particular case, I probably wouldn't
07:19:19 <julianleviston> magneticduck: evals of evals of evals.
07:19:31 <julianleviston> Cale: yeah, I’d probably just extract a function, I think.
07:19:56 <magneticduck> haskell has good support for DSLs through flexible syntax and powerful semantics, but does it have eval()? nope, PHP wins again 
07:20:05 <julianleviston> lol
07:20:23 <julianleviston> magneticduck:  actually, in the parsers AST package it has eval ;-) shhh
07:20:35 <julianleviston> magneticduck: or is it called Hint? I think that’s it.
07:20:53 <julianleviston> magneticduck:  lol https://hackage.haskell.org/package/hint
07:21:00 <julianleviston> magneticduck: but I’m sure you knew that.
07:21:06 <geekosaur> if you like built-in security holes, C is the language to look at >.>
07:21:08 <magneticduck> speaking of which, I assume it's possible to fairly easily make a TH program that never compiles and bypasses all attempts at recursion cehcks
07:21:10 <magneticduck> checks*
07:21:21 <magneticduck> via recursive TH
07:21:30 <magneticduck> uh, or just non-terminating TH
07:21:40 <magneticduck> not sure if recursive TH is a thing, it totally should be
07:21:52 <magneticduck> you know, for all the obvious uses
07:22:35 <julianleviston> ok I gotta get some food. bbak
07:22:53 <julianleviston> just, you know, keeping you all informed… (sorry!)
07:23:05 <magneticduck> be sure to take a picture of it
07:23:11 <magneticduck> you know, for the information
07:26:35 <Cale> julianleviston: You could write this: (\xs x -> assign blogEntries (xs ++ [x])) <$> use blogEntries <*> use inputBlogEntry
07:26:52 <Cale> julianleviston: I'm not sure if that's better
07:27:19 <magneticduck> you know you're in haskell because people are trying to find the one-liner that 'looks the best'
07:27:21 <Cale> If you pulled  (\xs x -> assign blogEntries (xs ++ [x]))  out into its own definition like  addBlogEntry  or something
07:27:28 <magneticduck> in other languages we're pretty happy when we can get anything as a one-liner
07:27:37 <Cale> then maybe not so bad to write  addBlogEntry <$> use blogEntries <*> use inputBlogEntry
07:27:46 <Cale> Well, in this case the complaint was that it was a 3-liner
07:27:51 <Cale> and he wanted a 1-liner :)
07:28:18 <magneticduck> in #javascript everybody is like 'you want a one-liner? pipe to closure-compiler'
07:28:18 <Cale> I guess that shouldn't be called addBlogEntry
07:28:37 <Cale> meh, I dunno :)
07:29:28 <Cale> Oh, of course
07:29:39 <Cale> We shouldn't be using assign/use
07:30:39 <Cale> We should be using modify and %~ or their fused version %=
07:31:39 <Gurkenglas> (blogEntries <>=) . pure =<< use inputBlogEntry
07:32:23 <Cale> fmap (\x -> blogEntries %= (++ [x])) (use inputBlogEntry)
07:32:37 <Cale> you have that composite backwards
07:32:55 <Cale> pure . (blogEntries <>=) =<< use inputBlogEntry
07:33:11 <Cale> But of course  pure . f =<< x  is  fmap f x
07:33:23 <Cale> or  f <$> x
07:33:28 <Gurkenglas> Nope, we take the inputBlogEntry, wrap it in [] with pure, and then send it off to be added to the right of blogEntries
07:33:53 <Cale> uhhh
07:34:12 <Gurkenglas> Also your fmap thing ends up being twice monadic
07:34:15 <Cale> no, I'm certain that doesn't typecheck, what you wrote
07:34:25 <Cale> (I just tried it)
07:34:26 <Gurkenglas> :t (?blogEntries <>=) . pure =<< use ?inputBlogEntry
07:34:27 <lambdabot> (Applicative f, ?blogEntries::ASetter' s (f a), ?inputBlogEntry::Getting a s a, Monoid (f a), MonadState s m) => m ()
07:35:03 <Cale> Yeah, those constraints won't end up working
07:36:42 <Gurkenglas> @letlpaste 141826
07:36:44 <lambdabot>  Defined.
07:36:51 <Gurkenglas> :t (blogEntries <>=) . pure =<< use inputBlogEntry
07:36:52 <lambdabot> MonadState S m => m ()
07:37:09 <Gurkenglas> ( http://lpaste.net/141826 )
07:37:21 <Cale> :t fmap (\x -> ?blogEntries %= (++ [x])) (use ?inputBlogEntry)
07:37:22 <lambdabot> (?blogEntries::Setting (->) s s [a] [a], ?inputBlogEntry::Getting a s1 a, MonadState s m, MonadState s1 f) => f (m ())
07:37:30 <Cale> ^^ this is the type we want
07:38:29 <Cale> Er, I dunno
07:38:47 <Cale> Actually, maybe that does work :P
07:39:24 <Gurkenglas> :t fmap (\x -> blogEntries %= (++ [x])) (use inputBlogEntry)
07:39:25 <lambdabot> (MonadState S f, MonadState S m) => f (m ())
07:39:44 <Gurkenglas> :t (=<<) (\x -> blogEntries %= (++ [x])) (use inputBlogEntry)
07:39:44 <lambdabot> MonadState S m => m ()
07:40:03 <Gurkenglas> :t (=<<) (\x -> blogEntries <>= [x]) (use inputBlogEntry)
07:40:05 <lambdabot> MonadState S m => m ()
07:40:22 <Gurkenglas> :t (=<<) ((blogEntries <>=) . (\x -> [x])) (use inputBlogEntry)
07:40:23 <lambdabot> MonadState S m => m ()
07:40:37 <Cale> Ah, right, we definitely want =<< in there anyway
07:40:41 <Gurkenglas> :t (blogEntries <>=) . pure =<< use inputBlogEntry
07:40:43 <lambdabot> MonadState S m => m ()
07:40:45 <Gurkenglas> :P
07:41:00 <Cale> yeah
07:41:13 <Cale> I'm not sure I'd use pure rather than (:[])
07:41:18 <Cale> for that
07:41:29 <Cale> if I know it's of list type
07:41:46 <Gurkenglas> It makes :t tell us that we could use any applicative monoid instead of []
07:41:55 <Cale> yes
07:41:56 <Cale> heh
07:43:12 <Gurkenglas> I have the feeling it should be possible to write that without the =<< using some lens tomfoolery. Maybe one can even get the <>= top-level
07:43:20 <Cale> anyway, I think I'd usually prefer to just use modify explicitly
07:43:36 <Cale> and to separate out the use inputBlogEntry to another line
07:43:54 <Gurkenglas> but then we'd need to invent a name for it >:(
07:43:55 <Cale> No harm in naming the result of that, and it makes the rest clearer
07:44:13 <Cale> We could just use x
07:44:23 <Cale> since it's only going to be used on the very next line
07:44:36 <SK0> I'm getting '0.hs: <command line>: can't load .so/.DLL for: ' when running a script that uses my library
07:44:50 <Cale> and name lengths only need to be proportional to the size of the scope in which they're used
07:44:59 <SK0> undefined symbol: synthzu17aADrZZR96bCNf2u7YsNYV_SynthaxziFunctionziWindowziGaussian_gaussian_info)
07:45:02 <Cale> (or probably the log of the size ;)
07:45:05 <SK0> I tried a fresh reinstall
07:45:12 <SK0> but doesn't help
07:45:51 <SK0> my ghc version is 7.10.2
07:46:11 <Gurkenglas> accursedUnutterablePerformIO's usage extends to the outer realms
07:46:26 <Cale> heh
07:46:43 <tsahyt> SK0: Have you made sure that every relevant module is listed under other-modules in your libraries cabal file?
07:47:13 <SK0> tsahyt, heh, hm, eh. I think I might be missing something, brb
07:47:21 <Cale> Yeah, optimal name lengths are O(log(size of scope / number of uses)), since accursedUnutterablePerformIO is intended never to be used, its actual ideal name length is infinite
07:47:27 <tsahyt> SK0: Wait I think it should be exposed-modules
07:48:07 <SK0> tsahyt, yeah, but it was missing from there too, cheers!
07:48:31 <Gurkenglas> It's why all the actual unthinkable rituals require 6 minutes of chanting
07:48:46 <magneticduck> signs that your code is messy: ghc complains of recursive import loops with >5 nodes
07:56:27 <Gurkenglas> Should there be an f such that (f l %= x) = ((l %=) =<< use x) for all operators like %=?
07:57:59 <magneticduck> signs that your code is messy: there are >3 non-compatible definitions of symbols with the same name in 3 different files, held apart only by qualified imports
07:58:14 <magneticduck> >2 *
07:58:46 <Gurkenglas> >3 in 3 files would be messy indeed
07:58:59 <magneticduck> yeah I haven't crossed that line yet
07:59:24 <SK0> >1?
07:59:31 <magneticduck> SK0: no, >2
07:59:40 <magneticduck> I also am confused
07:59:58 <SK0> why >2?
08:00:24 <Gurkenglas> Why not just say 3?
08:00:54 <magneticduck> I'm writing these things as if they're some sort of fictional criteria for pronouncing some code 'messy'
08:01:58 <magneticduck> so you'd go through a checklist to see if your library should be refactored: 'do I have more than 1000 subsequent lines of top-level TH quasiquotes implying symbol definitions without documentation or any sort of listing? no, only 700, my code is okay' 
08:01:59 <Gurkenglas> But you say "3 different files" later on, so >2 can only mean 3, so you should say the simpler thing
08:02:26 <magneticduck> yeah true
08:04:25 <magneticduck> I guess the real answer to my question is 'The things I say are usually caused by hazy intuitive phenonemon than by actual rationality; most of the justification I apply to things I've said are a product of rationalization in hind-sight, hinging on a faith that I've taught myself to think in ways that are usually rational.'  
08:04:35 <magneticduck> s/to my question/to your question
08:06:26 <Gurkenglas> I obviously find that reply unacceptable, and would, if we knew that was your reason, instead have said "Just say 3.", but I gave you a chance to give a better reason by saying it as a question
08:07:22 <julianleviston> Gurkenglas: so much simpler! <pat>
08:10:02 <anon216> I wonder, what are the pros/cons of defining an interface (like in Go/Java) using type classes vs. data type containing functions?
08:10:09 <anon216> asking because I saw this: https://github.com/haskell-distributed/network-transport/blob/master/src/Network/Transport.hs#L75
08:10:35 <anon216> which uses a record of functions inside a data type declaration, and I thought the usual way in Haskell would be by a type class instead
08:11:04 <julianleviston> Cale: hey! you were just talking about this!
08:11:43 <anon216> also, the data type seems like there isn't a way to extend it with more operations
08:11:51 <Cale> anon216: Both are viable approaches in Haskell
08:12:26 <Cale> anon216: You use a type class for cases where there will be only one canonical implementation of the operations for any particular type
08:12:41 <Cale> In this case, the data type isn't even parametric
08:13:29 <anon216> I see, makes sense, it just I was thinking that type classes is always the way to go :)
08:13:35 <Cale> So if you wanted to use type classes, you'd have to have some dummy types so that you could write instances, and even then, it might not work out so well, because the instances have to be constructed at top level
08:13:53 <aweinstock> :t (<>=)
08:13:55 <lambdabot> (Monoid a, MonadState s m) => ASetter' s a -> a -> m ()
08:13:56 <Cale> (and these records look like things which might involve doing some I/O beforehand to construct)
08:14:27 <derdon> Is it a bad idea if I construct new typeclasses without introducing according laws? Should typeclasses always come with laws?
08:14:43 <Hafydd> anon216: what you have linked to is not a definition of an interface.
08:14:49 <Hafydd> (It's a concrete type.)
08:15:34 <geekosaur> typeclasses are only sometimes the way to go
08:15:46 <geekosaur> records are often the more correct solution
08:16:03 <anon216> ok, I see
08:16:38 <geekosaur> (wanting to use typeclasses instead of records is often, but not always, a symptom of trying to apply OOP to Haskell, which doesn't generally work out too well)
08:17:06 <anon216> Hafydd: I'm not a type theorist, but why do you say it isn't not a interface? Or something similar?
08:17:16 <Hafydd> If it were: data Connection a = Connection{ send :: a -> [ByteString] -> IO (Either (TransportError SendErrorCode) ()); close :: a -> IO () } then it might be called an interface.
08:17:33 <anon216> ok, fair enough
08:17:33 <Hafydd> anon216: it isn't parameterised by any type, so it's not possible to make an instance of it.
08:17:36 <Cale> derdon: well, it kind of depends
08:17:55 <exio4> derdon: there's no such thing as "always a bad idea" or "always a great idea", I would say
08:18:04 <anon216> I was now more puzzle about the type class vs. data, just thinking about how to define which operations a concrete implementation has to offer
08:18:05 <Hafydd> (And there isn't a type-class equivalent of it.)
08:18:14 <Cale> derdon: If your type class is application specific and you have a bunch of useful instances, don't worry about it
08:18:21 <derdon> exio4: then I rephrase to "may it be a bad idea if ..."
08:18:55 <Cale> derdon: It's always a good idea to some extent to think about the algebraic laws that your programs might satisfy, regardless of whether you're defining a type class or not.
08:19:09 <derdon> Cale: I guess it's better style to keep the typeclasses as small as possible, isn't it? I mean with as few operations as necessary
08:19:09 <phaazon> hey
08:19:17 <phaazon> is it RankNTypes to be able to write
08:19:18 <Cale> derdon: and no smaller ;)
08:19:27 <phaazon> data AFunction f = forall a b. AFunction (Expr f (a -> b))?
08:19:30 <derdon> Cale: good, got it :)
08:19:31 <phaazon> or ExistentialQuantification?
08:19:36 <phaazon> I guess the later
08:19:47 <Cale> derdon: The thing about laws is they kind of help you define exactly how small small is :)
08:20:16 <Cale> derdon: If you have some laws, then breaking the class into smaller classes might mean that you can no longer write down the laws for each one
08:20:24 <derdon> ah yes. If you see some properties, you might realize that some operations are superfluous
08:20:31 <Cale> Oh, that as well
08:20:51 <derdon> I see, thanks
08:20:53 <Cale> But moreso, that if there are important relationships between the operations, then maybe you don't want to break the class up into smaller pieces
08:21:06 <derdon> sure
08:21:15 <Cale> Maybe the operations are only *really* meaningful in the presence of one another
08:21:34 <Cale> Like, you could separate Monoid into two classes, one for mempty and one for mappend
08:21:40 <Cale> But what is mempty supposed to be?
08:21:57 <julianleviston> Cale: do you know of any good snap tutorials?
08:21:59 <Cale> If you know what mappend is, then you can decide.
08:22:02 <Hafydd> I prefer to use mfull and mhalffull.
08:22:20 <derdon> Cale: that is exactly the example I just thought of as well :D
08:22:23 <exio4> an identity element for mappend! I would actually like that separation, and it'd allow a nicer Monoid instance for Maybe by default, too
08:22:24 <Cale> julianleviston: I don't know, I just look at the Haddock documentation :P
08:22:29 <julianleviston> Cale: or rather, is there a “happy path” get to be able to do snap stuff? :)
08:23:05 <Cale> julianleviston: I've been programming in Haskell since around 2001, so I'm often okay getting by with just type signatures and names of functions :D
08:23:14 <julianleviston> Cale: sure. :)
08:23:22 <julianleviston> Cale: lucky! :P
08:24:05 <julianleviston> Cale: so I basically just have to spend 10 years?
08:24:08 <julianleviston> Cale: lol
08:24:09 <Cale> lol
08:24:24 <Cale> Well, it took me about a year or so to be comfortable.
08:24:46 <julianleviston> Cale: I don’t mind being uncomfortable, but I really need to build the thing I want to build :)
08:24:58 <Cale> http://snapframework.com/docs there's a bunch of stuff here
08:25:08 <julianleviston> Cale: I’ve seen all of that, I think.
08:25:31 <julianleviston> yeah. their tutorials are so tiny.
08:26:01 <julianleviston> Cale: the most helpful thing was ryan trinkle’s url shortner.
08:26:09 <julianleviston> Cale: but that’s a pretty tiny thing.
08:30:01 <julianleviston> I spose I should practice smaller things first.
08:30:45 <Cale> It can work just to build something from end to end and expand outward once you have it running
08:30:46 <julianleviston> Cale: though I don’t think that will help me to understand what happens when requests come in. 
08:31:20 <julianleviston> Cale: yeah, that’s how I taught myself smalltalk originally.
08:31:40 <julianleviston> in fact, that’s pretty much how I taught myself all the things I know.
08:35:03 <julianleviston> Cale: that’s why I like Ryan Trinkle’s example… it’s a set of accretive examples.
08:42:32 <RedNifre> Hi there.
08:44:31 <RedNifre> I'm currently trying to understand Monad Transformers. I'm playing with the REPL and have `loadMaybeString = return (Just "fine") :: IO (Maybe String)`, and I then I try `do fine <- MaybeT loadMaybeString ; ...` but how do I actually print the string? Something doesn't fit.
08:45:46 <heatsink> For monad transformsers, the naming convention is "run"
08:46:16 <heatsink> so to run a MaybeT IO in the IO monad, use runMaybeT :: MaybeT IO a -> IO (Maybe a)
08:46:41 <joco42_> how does ghc knows which directory the global registry is ?
08:46:51 <Cale> Also, note that you'll have  lift :: IO a -> MaybeT IO a
08:46:51 <joco42_> is it possible to reconfigure that directory ?
08:47:05 <RedNifre> I'm not sure I understand... 
08:47:37 <Cale> RedNifre: So lift gives you a way to take an ordinary IO action and turn it into a MaybeT IO action
08:47:49 <heatsink> In what context do you want to do the printing?  In the IO monad, or in the MaybeT IO monad?
08:47:50 <geekosaur> joco42_, on unix "ghc" and friends are shell scripts and you can change various paths in that shell script
08:47:50 <Guest59499> hi
08:47:55 <Cale> and runMaybeT gives you a way to turn a MaybeT IO action into an IO action producing a Maybe result
08:47:56 <geekosaur> dunno about windows
08:48:02 <Guest59499> hellooooo
08:48:07 <RedNifre> In my example above in the do notation, does "fine" actually bind to String, or is that wrong as well?
08:48:08 <joco42_> geekosaur: thanks, i have a look into that
08:48:28 <geekosaur> that said, changing the global package directory is not a very good idea, if only because you *must* have "base" in that library
08:48:37 <Cale> Guest59499: hello. There are > 1500 users here ;)
08:48:39 <geekosaur> and copying/moving a library requires some path editing
08:48:52 <Guest59499> yess
08:49:06 <RedNifre> Well, I'm not exactly sure what I want to achieve... I think I want to call the function that returns IO (Maybe String) and print the string without having to check isJust in a do-block of type IO... but my understanding is very hazy here.
08:49:14 <heatsink> Yes, fine has type String, and it would get the string "fine"
08:49:24 <RedNifre> okay, so far so good...
08:49:50 <Guest59499> benbangert b
08:49:55 <RedNifre> So the problem is that print returns IO ()?
08:50:04 <heatsink> Okay, you have print :: String -> IO ()
08:50:12 <RedNifre> ok
08:50:12 <heatsink> and you want printInMaybe :: String -> MaybeT IO ()
08:50:13 <geekosaur> joco42_, also note that you cannot reinstall "base", it's wired in
08:50:23 <RedNifre> hmkay
08:50:27 <Cale> print fine is an IO action. If you want a MaybeT IO action, apply lift to it
08:50:39 <RedNifre> so (lift print) fine ?
08:50:40 <joco42_> geekosaur: so base is in ghc binary itself?
08:50:47 <Cale> lift (print fine)
08:50:48 <heatsink> Actually, lift (print fine)
08:51:17 <geekosaur> not in the binary, but it comes with ghc and the compiler is very tightly tied to that (it contains the runtime) --- you cannot replace it without replacing ghc
08:51:55 <joco42_> geekosaur: ok, right, that is good to know
08:53:21 <julianleviston> Cale: the snaplets tutorial actually has info in it that I didn’t understand at all the first time around because I didn’t understand state. Your “IORef” tutorial from before was incredibly helpful for me, thank you :)
08:53:39 <Cale> great!
08:56:03 <RedNifre> ghci says the type is ambiguous, so I tried (lift (print fine) :: MaybeT IO String), but that doesn't match because print returns IO () I think. So, if the point of my do-block is to just print then I could change it to MaybeT IO () but I guess then I can no longer bind fine to a String?
08:57:07 <heatsink> MaybeT IO () is correct.  The () here is the return value produced after printing
08:57:35 <heatsink> Printing a string is an IO action that runs and returns ().
08:59:47 <heatsink> Return values in a do-block don't have to be the same.  You can have a MaybeT IO String and a MaybeT IO () in the same do-block.
08:59:49 <RedNifre> But why doesn't do { fine <- MaybeT loadMaybeString; lift (print fine) } work then? I see no printed output and it says that no instance for Show something something arises from print...
09:00:18 <RedNifre> With "return values" you mean things on the left side of a "<-"?
09:00:51 <heatsink> The "no instance for Show" means that you've created a value (of type MaybeT IO ()) that ghci can't display
09:01:54 <heatsink> yes, that's what I mean by return value in this situation.
09:02:00 <RedNifre> Hm. How can I prevent ghci from trying to display it and just see the printed output instead?
09:02:21 <heatsink> You need to run it in the IO monad, which is what runMaybeT does
09:03:01 <Cale> RedNifre: If you provide ghci with an IO action, it will automatically execute it, rather than just trying to evaluate and print it.
09:03:05 <RedNifre> ah, yes, adding "runMaybeT $ " to the beginning helps... but why exactly is that needed?
09:03:24 <Cale> GHCi doesn't know how to execute MaybeT IO actions
09:03:44 <RedNifre> oh, so ghci has a special feature that it can Handly IO any, but it doesn't have that special feature for other IO-like monads like MaybeT IO String?
09:03:52 <Cale> right
09:04:23 <Cale> and for most other such monads, it wouldn't even make sense
09:04:42 <Cale> MaybeT is a bit special in that there's no other information you need to provide to be able to run a MaybeT action.
09:04:57 <RedNifre> ...so runMaybeT deconstructs the transformer into regular nested monads? Is that only needed for ghci? Or do I only need it for my main function because the runtime only wants main :: IO something?
09:05:01 <Cale> But for example, runStateT will take the initial state as an additional argument
09:05:15 <Cale> No, you'll need to use that in your real program too
09:05:38 <Cale> MaybeT is only useful if you have a lot of things of type IO (Maybe a)
09:06:24 <Cale> because otherwise, you'd usually just case on the result
09:06:58 <RedNifre> So I use MaybeT IO Something only to make my code easier to handle but whenever I actually need to run something I have to turn it back into IO (Maybe Something)?
09:07:55 <Cale> yeah
09:08:22 <Cale> Well, supposing that you're trying to run it from an IO action, and not from another MaybeT IO action
09:08:59 <Cale> Eventually, main is an IO action, so you'll have to do it at some point
09:13:37 <RedNifre> okay, so lift turns a monadic value into a transformed monadic values that has any monad type I choose on the inside and the same monad type the original value has on the outside (sort of) and runSpecificT turns a specific transformed monadic value into a value that is nested inside the two monads that the transformer is about?
09:14:16 <Gurkenglas> I find "runMaybeT $ x >>= MaybeT . f" better than even one "do v <- x; case v of Nothing -> return Nothing; Just w -> f w"
09:14:41 <Gurkenglas> (Hmm. That first one looks like ala should be able to be applied)
09:16:02 <RedNifre> now, wait a second... what's the type signature of f in your example?
09:16:31 <RedNifre> I mean, if x is say IO (Maybe String), wouldn't you feed Maybe String into f?
09:16:47 <Gurkenglas> :t runMaybeT $ ?x >>= MaybeT . ?f
09:16:48 <lambdabot> (Monad m, ?f::a1 -> m (Maybe a), ?x::MaybeT m a1) => m (Maybe a)
09:17:38 <Gurkenglas> :t runMaybeT $ MaybeT ?x >>= MaybeT . ?f -- Oh, I guess it'd have to be this. Still better.
09:17:39 <lambdabot> (Monad m, ?f::a1 -> m (Maybe a), ?x::m (Maybe a1)) => m (Maybe a)
09:18:42 <fread2281> ollef, does Early have a primitive for "try a, if it fails do b"? I'm having trouble expressing mixfix operaotrs where parts of an operator can be used as an identifier but the operator will always be prefered and operators have arbitrary precedence relations a la Parsing Mixfix Operators
09:18:50 <RedNifre> that is equivalent to runMaybeT do { a <- x ; lift (f a) }, right?
09:19:42 <RedNifre> no, wait. In your example, f returns IO Maybe String while in mine it returns String, right?
09:19:42 <Gurkenglas> :t runMaybeT $ do { a <- ?x ; ?f a }
09:19:44 <lambdabot> (Monad m, ?f::t -> MaybeT m a, ?x::MaybeT m t) => m (Maybe a)
09:19:59 <RedNifre> okay, that makes more sense.
09:21:04 <RedNifre> Thank you both, it makes a lot more sense to me now.
09:23:11 <fread2281> ollef, https://gist.githubusercontent.com/fread2281/6ae0444911b9955e8f28/raw/956a094a3512b1d2dae47840cfeb604afd0520b2/MixfixEarly.hs is my code so far, f should be just the 3rd entry
09:24:20 <RedNifre> Just noticed liftM... is that the same as fmap?
09:26:09 <fread2281> RedNifre, yep, useful as a definition for fmap if you already have a Monad instance
09:26:13 <Gurkenglas> Yes. If you see it, the writer wanted to convey that he knows he's working with a monad, or he wrote that before the functor-applicative-monad proposal was implemented
09:32:06 <aweinstock> :t (?)
09:32:07 <lambdabot> Not in scope: ‘?’
09:32:12 <aweinstock> :t ?x
09:32:13 <lambdabot> (?x::t) => t
09:32:34 <aweinstock> what's this (?) syntax?
09:32:51 <aweinstock> is it lambdabot-specific?
09:32:56 * hackagebot turtle 1.2.2 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.2.2 (GabrielGonzalez)
09:33:02 <geekosaur> implicit parameters
09:33:14 <Luke> anyone use lucid over blaze? is it well supported?
09:33:51 <geekosaur> they're rather useful in lambdabot or ghci for creating a temporary name and asking what type it would get at the same time
09:33:57 <nshepperd> :t \x -> x + ?y
09:33:58 <lambdabot> (Num a, ?y::a) => a -> a
09:34:08 <nshepperd> huh
09:34:15 <aweinstock> :t (+?y)
09:34:17 <lambdabot>     Not in scope: ‘+?’
09:34:17 <lambdabot>     Perhaps you meant one of these:
09:34:17 <lambdabot>       ‘++’ (imported from Data.List), ‘+’ (imported from Prelude),
09:34:19 <aweinstock> :t (+ ?y)
09:34:21 <lambdabot> (Num a, ?y::a) => a -> a
09:35:02 <ryanpbrewster> I'm trying to make this code more typesafe: http://pastebin.com/2m9ZMAsS
09:35:56 <geekosaur> they have other uses; the upcoming exception stack trace stuff uses them under the covers
09:36:19 <ryanpbrewster> I have a bunch of enumerated Genres, and each Genre has a specific set of Items that go along with it. Is there some way of encoding the fact that each Item is associated with a Genre in the type itself?
09:36:22 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/other-type-extensions.html#implicit-parameters
09:36:44 <KaneTW> :t fmap ?f fmap
09:36:45 <lambdabot> (Functor f, ?f::(f a -> f b1) -> b) => (a -> b1) -> b
09:36:59 <ryanpbrewster> like items :: Genre g => g -> [Item g]
09:37:16 <Ywen> ryanpbrewster, the simplest solution would be to split your items between 2 types
09:37:25 <geekosaur> (you will note in the link I gave that some of the machinery is already there; the rest is scheduled for 8.0.1)
09:37:42 <Ywen> data Fruit = Tomato | Apple | Pear; data Vegetable = Carrot | ...
09:38:09 <ryanpbrewster> Ah, I think I see.
09:38:21 <Ywen> and have data Item = V Vegetable | F Fruit
09:38:33 <Andrej_T> hey everyone. i'm practicing haskell on codewars (http://www.codewars.com/) and i'm trying to submit this example: https://gist.github.com/whoeverest/d59ed556f7a21c9bec76
09:38:43 <KaneTW> you could also do
09:38:43 <ryanpbrewster> Okay, that makes sense. Thanks.
09:38:59 <Andrej_T> it works correctly, and on my machine it finishes pretty fast (0.04s for pattern 10000)
09:39:22 <Andrej_T> however, when i submit it there it times out, not completed in +6s
09:39:28 <Andrej_T> anything i might be missing?
09:39:39 <Ywen> ryanpbrewster, that's the simplest way, but it introduces a new hierarchical level. That might be inconvenient, depending on the rest of your code
09:40:10 <fread2281> is there a commin name for (#) f a = flip f a ?
09:40:13 <aweinstock> ryanpbrewster: with "deriving Enum" on all 3, [minBound..maxBound] will do the right thing (I think)
09:40:14 <KaneTW> enable DataKinds, make Item a GADT (like data Item (a :: Genre) where Apple :: Item Fruit etc.) and adjust the rest as appropraite
09:40:15 <fread2281> *common
09:40:25 <geekosaur> fread2281, no
09:40:35 <aweinstock> err, "deriving (Enum, Bounded)"
09:40:56 <ryanpbrewster> Hrm, I've heard of GADTs but haven't ever played with them.
09:41:49 <monochrom> "(#) f a = flip f a" looks like "(#) = flip". so I think a common name is "flip".
09:41:51 <KaneTW> https://www.youtube.com/watch?v=rhWMhTjQzsU
09:42:14 <fread2281> but as an operator :)
09:42:20 <geekosaur> or `flip` (in the `` to make it infix)
09:42:36 <Ywen> ryanpbrewster, yes, but they might be overkill for your example
09:42:36 <geekosaur> overuse of flip is frowned on, so I imagine there are few such things
09:42:57 * hackagebot userid 0.1.2.0 - A library which provides the UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.2.0 (DavidFox)
09:43:47 <the_2nd> Can I define compiler flags within a .cabal? Or are they called with build/install?
09:44:41 <lpaste> aweinstock pasted “Fruit example with deriving Enum” at http://lpaste.net/141830
09:44:47 <aweinstock> ryanpbrewster: ^
09:44:54 <Cale> Andrej_T: as far as performance is concerned, it looks like it ought to be reasonable to me
09:45:01 <fread2281> it's very useful for functions that take a function as their second arg: fmap `flip` [1,2,3] $ \x -> somelongfunction
09:45:24 <RedNifre> Hm, this line in the Monad instance of MaybeT is interesting: "return x = MaybeT (return (Just x))"... if I happen to need something like a Monad Transformer in Java, I wonder if that's even possible, given that in Haskell, it picks the right "return" to call based on the secondary types of MaybeT... bummer.
09:45:38 <ryanpbrewster> @aweinstock, that looks neat, but I'm mostly concerned about getting the type signatures correct.
09:45:38 <lambdabot> Unknown command, try @list
09:45:39 <Cale> Andrej_T: maybe you should avoid reverse
09:45:55 <Cale> Andrej_T: by using  listNums = map show [n, n-1 .. min]
09:46:10 <Andrej_T> Cale: oh, i didn't know that syntax :) let me try
09:46:12 <Hafydd> I like that in usage of `flip`, the occurrence of `flip` usually looks like it's a placeholder for the first parameter.
09:47:31 <Cale> Andrej_T: But usually the first time any one of those sites rejects my code for time when the program runs fine locally, I just go somewhere else. Often the problem is that they're setting draconian limits while compiling without optimisations.
09:49:05 <glguy> osa1: Why does @charescd match \?  ?
09:49:06 <Cale> (I don't know about that site though)
09:49:47 <Andrej_T> Cale: how can i force haskell to evaluate the result, without printing the humongous string to console?
09:50:06 <Andrej_T> Cale: i tried with head $ pattern 10000, but i doubt it's not evaluating the whole thing
09:50:17 <Cale> It's certainly not
09:50:38 <osa1> glguy: I don't remember, I need to look at the code but I'm working on something else right now...
09:50:42 <Cale> you might try computing the length of the String. The real answer is to use deepseq.
09:51:07 <glguy> osa1: Alright. I believe it's just a mistake. The current PR#27 implements unicode lexing and string escaping and unescaping
09:51:12 <julianleviston> Cale: length only evaluates to WNHF doesn’t it?
09:51:33 <Cale> julianleviston: It has to traverse the whole list at least
09:51:41 <julianleviston> Cale: sure
09:51:57 <Cale> It may not evaluate any of the actual elements of the list, but in Andrej_T's case, it will
09:52:45 <Cale> (since show applied to the numbers doesn't compute the number of digits separately from what the digits are in any respect)
09:53:07 <osa1> glguy: does it convert Lua strings to Haskell strings? e.g. if I have a unicode string in a Lua file it should map to same Haskell string after parsing. (not to a Haskell string with escaped bytes etc.)
09:53:28 <Andrej_T> Cale: well, i used length, now i know it's a problem with the code, not the site
09:53:34 <Andrej_T> pattern 10k == 20s
09:53:55 <Andrej_T> generates a string with length 199535504
09:54:06 <jophish_> I have a record: A = A{a :: Int} and a function foo :: Applicative m => Int -> m Int. Is there a fancy way with lens to do something like updateRecord :: Applicative m => A -> m A; updateRecord record = A{a = foo (a record)}
09:54:09 <Andrej_T> i have no idea with which number they're testing it, though
09:54:16 <Cale> That doesn't seem too unreasonable for a 200 megabyte string which requires a bunch of arithmetic to generate
09:54:18 <glguy> osa1: No, I guess what can do is check what you wrote was an encoding of a unicode codepoint and emit it as one in that case
09:54:28 <glguy> Lua doesn't have unicode strings, though
09:54:40 <Cale> Nevermind that it's not just 200 megabytes of allocation since you're using String
09:54:44 <jophish_> I've got something similar to this repeated on a bunch of lines, so I'm looking for a less cumbersome way of doing things, and I have a feeling there's probably some nifty lens combinator which does the trick
09:54:49 <Cale> It's more like 8 times that amount.
09:55:02 <exio4> if it is checked lazily... :p 
09:55:04 <Cale> Did you kill off the reverse at least?
09:55:21 <Cale> reverse will be quite brutal at those sizes
09:55:25 <Andrej_T> Cale: yep, i did
09:55:33 <jophish_> err, my example was wrong, it should have been: updateRecord record = do a' <- foo a record; pure (record{a = a'})
09:55:50 <jophish_> foo (a record)
09:56:05 <Cale> Andrej_T: I guess if you need it to be faster than that, you'll have to use Text or ByteString
09:56:16 <Cale> String is not a high performance data type
09:56:20 <glguy> osa1: Users should be careful to only put values with the range 0-0xff in the STringLiteral constructor
09:57:09 <glguy> Because it's possible to write string literals that don't correspond to valid utf-8
09:57:16 <mniip> [18:47:51] <osa1> glguy: does it convert Lua strings to Haskell strings? e.g. if I have a unicode string in a Lua file it should map to same Haskell string after parsing.
09:57:19 <glguy> so we can't just do a utf-8 encoding
09:57:19 <mniip> lua has no unicode strings
09:57:26 <mniip> lua strings ~ [Word8]
09:57:26 <glguy> [09:54] glguy: Lua doesn't have unicode strings, though 
09:57:33 <osa1> glguy: so arguably this was one of the mistakes we did in the past, but we decided to actually parse Lua strings so that they map to Haskell strings. e.g. escape characters vs. actually interpreted during the parsing.
09:57:57 <glguy> osa1: The previous decoding was also fine, this isn't a change in behavior
09:58:08 <glguy> at least until we added the \u escapes
09:58:10 <Andrej_T> Cale: okay, i'll try that now
09:58:17 <hiptobecubic> Any haskellers.com mods here? It's down :(
09:58:19 <exio4> maybe converting everything to difference lists might help? (showsPrec, foldr (.) id instead of concat, etc?) 
09:58:51 <Cale> exio4: Maybe. The uses of concat were associated in the right direction already though
09:58:57 <exio4> I mean, it would still not be a big difference, compared to using Data.Text or so 
09:59:14 <jophish_> an alternative to: updateRecord r = [r{a = a'} | a' <- foo (a r)] -- It seems as though the repetition of 'a' could be removed
09:59:16 <glguy> osa1: The string literal would be better if it was a ByteString than a String
09:59:25 <exio4> Cale: indeed
09:59:33 <osa1> glguy: agreed, I recently did that change in hslua
10:00:15 <geekosaur> jophish_, record syntax isn't first class
10:00:23 <geekosaur> this is more or less why lens was created
10:00:30 <osa1> glguy: I should read the manual and understand how does this new \u{} syntax work.
10:00:57 <jophish_> that's my thinking, geekosaur. If I had a lens for a this might be easier
10:01:00 <glguy> The UTF-8 encoding of a Unicode character can be inserted in a literal string with the escape sequence \u{XXX} (note the mandatory enclosing brackets), where XXX is a sequence of one or more hexadecimal digits representing the character code point.
10:01:10 <glguy> That's the whole thing :)
10:01:13 <jophish_> I've not used a huge amount of lens, and having foo return an applicative is throwing me a bit
10:01:21 <geekosaur> ghc8 will have an extension which enables lens-like stuff by default
10:01:35 <geekosaur> also there are simpler lens implementations (e.g. fclabels)
10:02:03 <jophish_> I've been looking at microlens
10:02:19 <julianleviston> geekosaur: I wonder if having first class vectors and hashmaps with STM and structural sharing trees, similarly to clojure, might not be a good idea. It’s kind of extremely elegant, as far as syntaxes go.
10:03:11 <julianleviston> geekosaur: and having almost contsant time append to list-like data structures *is* quite nice.
10:03:44 <osa1> glguy: uh ok. if we interpret that syntax pretty printer will again have problems.
10:04:03 <Cale> julianleviston: hashmaps: http://hackage.haskell.org/package/unordered-containers
10:04:18 <julianleviston> Cale: oh, I know haskell *has* them.
10:04:20 <glguy> osa1: So the behavior you want is that if a sequence of bytes in a string literal is valid UTF-8 it should be emitted as such?
10:04:35 <julianleviston> Cale: I just meant first-class syntax for them.
10:04:39 <Cale> julianleviston: But frequently Data.Map outperforms them, because hashing isn't free
10:04:52 <julianleviston> Cale: I didn’t actually mean hashmaps, sorry. I meant maps.
10:05:01 <julianleviston> Cale: so, Data.Map would be fine.
10:05:11 * geekosaur not really the person to talk to about that
10:05:12 <julianleviston> Cale: but first class syntax is the thing.
10:05:24 <osa1> glguy: the behavior I want is that if I (print . parse) a file it should print the same thing. (modulo indentation etc.)
10:05:39 <osa1> including string literals
10:06:10 <Cale> julianleviston: One thing we do in our codebase is to have (=:) = Map.singleton
10:06:10 <glguy> OK, then the only way to do that is the not interpret the string literals at all
10:06:19 <Cale> julianleviston: and then you can combine those maps with  <>
10:06:29 <glguy> and perhaps provide helper functions for interpreting them in case someone wants to know what they mean
10:06:32 <julianleviston> Cale: cool :)
10:06:38 <Cale> So you can write expressions like  ("foo" =: 5 <> "bar" =: 8)
10:06:43 <osa1> glguy: in that case we should probably use ByteString, otherwise it looks like we're actually interpreting
10:07:09 <RedNifre> IO String may yield a String later, or it may fail, right? So I was looking for a function IO (Maybe String) -> IO String, kinda like the inverse of the MaybeT constructor, so I could write a function that returns IO String, even though in that function I end up with a Maybe String. Is there a better way than if (isJust x) return x else (fail "x not found") ?
10:07:19 <julianleviston> Cale: I really like vectors being [1 2 3 4] and maps being {1 2 3 4}. It’s kind of… beautiful :)
10:07:25 <julianleviston> Cale: I miss that. 
10:07:43 <glguy> osa1: I don't think that'll be a good hint considering that bytestring is the correct type for an interpreted string literal
10:07:43 <julianleviston> Cale: especially when they’er “good ones” by default. 
10:07:48 <glguy> but I think it's the right type anyway
10:08:30 <osa1> glguy: what's wrong with String for interpreted literals?
10:08:32 <glguy> Having it be a String indicates that it's the uninterpreted thign from your source file
10:08:34 <geekosaur> I think both those syntaxes would be very difficult to do
10:08:40 <RedNifre> julianleviston what's your experience with clojure if I may ask?
10:08:46 <geekosaur> that is they will both have massive conflicts with existing stuff
10:08:49 <cmccann> RedNifre: you should probably throw a proper exception rather than whatever fail does
10:08:52 <julianleviston> RedNifre: I’ll message u.
10:09:16 <glguy> lua string literals are not unicode string literals, so when someone writes \xff in their string literal they mean the byte 0xff, not the codepoint 0xff which is two bytes when encoded as utf-8
10:09:18 <RedNifre> but I thought IO fail WAS a proper way to fail IO?
10:09:27 <cmccann> RedNifre: but what you have is probably the simplest way
10:09:38 <osa1> I know
10:09:41 <cmccann> well, it's a generic way to fail
10:09:56 <cmccann> I guess if you don't care about catching those exceptions specifically it doesn't matter
10:10:04 <glguy> so using a list of unicode code points to represent a list of bytes is not right
10:10:31 <glguy> which is what an interpreted string literal is. But if they are uninterpreted and meant to be source text, then a String makes sense
10:10:36 <cmccann> RedNifre: actually on second thought, you should do "Just x <- foo; return x"
10:10:47 <Cale> RedNifre: You could write  Just v <- x  where x :: IO (Maybe t)
10:11:13 <Cale> RedNifre: The advantage there is that if the pattern match fails, you get a nice message telling you where that match is in the source code.
10:11:33 <Cale> RedNifre: However, you usually don't want to do that
10:11:55 <glguy> at that point it makes sense to have unicode codepoints in them because they will be written to the correct utf-8 representation when written to file
10:12:05 <Cale> RedNifre: If something is a Maybe in the first place, it's probably because you're more likely than not going to want to handle the exceptional case
10:12:56 <Cale> RedNifre: You can use IO exceptions to do this, but if you're going to do that, it might be a good idea to define a new exception type, and catch only that type.
10:13:13 <Cale> I dunno.
10:13:50 <Cale> I suppose it depends on what you're doing. 99% of the time, my response to something of type IO (Maybe t) is just to execute it, and then case on the Maybe result immediately after.
10:14:16 <Cale> (i.e. pattern match)
10:14:30 <Cale> Well, maybe that's a bit high :)
10:14:42 <osa1> glguy: but that would mean encoding utf-8 code points as unicode chars, since Haskell String is a list of unicode chars, right?
10:15:02 <Cale> Sometimes I'll be collecting up a bunch of Maybe things from several IO actions and combining them using the Applicative or Monad instance for Maybe.
10:15:20 <Cale> (or something like msum instead, in some cases)
10:15:22 <glguy> Yeah, if you had a file that was encoded in utf-8 the utf-8 would be decoded when you read the file and you'd have unicode codepoitns in your parsed String literal
10:15:34 <glguy> and they'd be written back to utf-8 when you saved the pretty version of that to disk
10:16:00 <glguy> If you're reading a file as a unicode string it makes sense that the uninterpreted parts of it stay as strings
10:16:25 <Cale> RedNifre: It's very very rare in a real program that I just want to throw an exception in IO when the thing isn't Just.
10:16:33 <osa1> glguy: here I have an idea:
10:18:45 <osa1> glguy: make the AST parametric on string type. by default generate ByteString, which is just list of bytes read from the file. at this point we don't care about interpretation or encoding. provide an "interpret strings" function, which generates AST Text instead, with strings 1) decoded for unicode(encoding should be provided by the user) 2) escaped things are interpeted also(like we do right now). how does this sound?
10:19:04 <glguy> the bytes are already decoded by readFile
10:19:20 <glguy> or if the user calls parseText on a STring they are already decoded
10:19:38 <osa1> glguy: we need ByteString.readFile
10:19:40 <glguy> We'd need to have a separate parser that worked on bytestrings to leave them uninterpreted
10:20:17 <osa1> ouch, that wont' work. without decoding bytes you can't parse anything, right?
10:20:27 <glguy> The simplest solution seems like we leave them as uninterpreted String
10:20:35 <glguy> and provide a function decodeString :: String -> ByteString
10:20:41 <glguy> if someone cares about the meaning of the string literal
10:22:31 <osa1> glguy: decodeString needs an encoding argument, right?
10:22:43 <osa1> glguy: what about decodeString :: ByteString -> Encoding -> Text?
10:22:59 <osa1> well we already have that in text package I think
10:23:17 <osa1> decodeUtf8 etc.
10:27:01 <osa1> glguy: I'm need to go get something for lunch and then work on something else right now, I'll copy IRC logs to the github thread and then we can discuss further.
10:27:12 <glguy> ok, ttyl
10:27:52 <hpc> ttl?
10:28:05 <glguy> it's a great ttl
10:28:25 * Clint twitches.
10:28:41 <osa1> whoa, my #haskell log file is 1.1M lines long
10:29:10 <osa1> a 134M file
10:30:10 <osa1> :q!
10:30:16 <osa1> sry
10:30:18 <hpc> [sudo] password for osa1
10:30:26 <osa1> :p
10:30:42 <frerich>  /join 0
10:31:09 <aweinstock> I only have 68MB of haskell logs
10:31:31 <glguy> I only have 1.4G :(
10:31:57 <hpc> is it possible to stream to a gzipped file?
10:32:05 <glguy> yes
10:32:09 <jophish_> hpc: I think so
10:32:11 <glguy> c.f. zcat
10:32:18 <mniip> I have 164M of specifically #haskell
10:32:19 <hpc> zcat streams from
10:32:27 <mniip> 3.3G of logs total
10:32:29 <hpc> i was thinking log directly to a compressed file
10:32:33 <lispy> I have 5M lines and it's less than 350MB. I'm pretty sure that's because I aggressively filter out a lot of IRC noise like parts/joins.
10:32:36 <Xe> mniip: only 3.3GB?
10:32:37 <hpc> but then what happens if you restart your irc client
10:32:57 <mniip> Xe, well excuse me I'm only logging since 2013
10:33:00 <Xe> I have 13 GB apparently
10:33:01 <Xe> me too
10:33:19 <frerich> You guys aren't really comparing the sizes of your logs files, are you?
10:33:21 * frerich sighs
10:33:51 <monochrom> better than comparing finger lengths in public washrooms :)
10:33:53 <glguy> 1.4G is just the size of #haskell logs since 2001 or so
10:34:02 <voidzero> LOL
10:34:11 <mniip> I also have a log parsing program in C
10:34:17 <voidzero> better than comparing the other kind of logs
10:34:28 <voidzero> oh this isn't -blah
10:34:41 <Clint> it certainly isn't
10:34:44 * voidzero flushes his log
10:34:50 <monochrom> true, we should be comparing pointfree code length
10:36:11 <twanvl> Does anyone know how I can include cmm (C--) files in a cabal package? There is no cmm-sources field.
10:37:03 <johnw> twanvl: you want them both included and built as part of the package, yes?
10:37:13 <twanvl> johnw: yes
10:37:25 <johnw> you can use other-sources to include them, and then write a custom Setup.hs to build them
10:37:54 <mniip> Xe, look at how efficient are C string streams! https://gist.github.com/mniip/37ae9e58cbb6e0b625bf#file-logger-c-L324
10:38:08 <jophish_> twanvl: that's pretty unusual, do you mind if I ask why out of curiosity?
10:38:30 <twanvl> johnw: do you have any pointers/links/tips on writing a custom Setup.hs?
10:38:42 <johnw> twanvl: sure, one sec
10:38:57 <jophish_> mniip: hahahaha
10:39:20 <twanvl> jophish_: I am trying to play with foreign import prim
10:39:50 <twanvl> but apparently foreign import prim doesn't work with ghci 
10:39:57 <johnw> twanvl: https://github.com/jwiegley/notes/blob/master/misc/Setup.hs
10:40:06 <twanvl> so I am hoping it will work if it confined to a package
10:40:06 <johnw> in that example, I use cmake to build a library prior to running the configure step
10:40:19 <johnw> I had a better example that used shake to build C++ code, but that was a work project :(
10:40:56 <johnw> you can insert your build step anywhere you want, but overriding its hook (and calling the original hook before or after)
10:41:00 <johnw> s/but/by
10:42:23 <RedNifre> cmccann oh right, v <- getMaybe makes more sense... by the way, how to pronounce that line?
10:42:39 <tommd> v is bound to the result of getMaybe
10:42:56 <tommd> In some contexts I say "v draws from the expression ..." which is good for lists or sets.
10:44:25 <jophish_> You know what I'd really like: A shared calender with all the functional programming conferences and events happening
10:44:28 <jophish_> (nearby)
10:47:59 * hackagebot multiplate 0.0.3 - Lightweight generic library for mutually recursive data types.  https://hackage.haskell.org/package/multiplate-0.0.3 (RussellOConnor)
10:50:36 <biners> hello folks
10:50:49 <lispy> hiya biners 
10:51:39 <biners> I've got a question that I'm not really sure fits here
10:51:53 <biners> but I've got a friend that's always on here and says you guys are great
10:52:03 <Iceland_jack> hey biners 
10:52:28 <nolrai66> We can be, sometimes we get super busy.
10:53:24 <biners> but yeah, if you guys could even point me towards the right channel that would be great
10:53:33 <biners> it's a web security type question
10:53:36 <biners> any thoughts?
10:53:48 <hpc> perhaps just ask the question ;)
10:56:01 <cmccann> man, erik meijer is really good at trolling people
10:56:22 <biners> so the thing is, my local csec club is doing a wargame type thing
10:56:32 <biners> and we have to find a hidden text file on a website
10:56:45 <cocreature> cmccann: yeah, I thought everybody knew that by know, but looking at twitter and reddit that doesn't seem the case
10:57:56 <nolrai66> Who is erik meijer? And why does he say stupid things on twitter?
10:59:57 <cmccann> nolrai66: well, he's listed as one of the authors of the Haskell 98 report, for one thing
11:00:31 <cocreature> more recently he was involved in the rx stuff
11:00:35 <cmccann> he's a relatively well-known programming languages guy, he did a lot of work for C#
11:00:45 <cmccann> including LINQ
11:02:22 <bitemyapp> nolrai66: he's not saying what you think he's saying.
11:02:37 <bitemyapp> nolrai66: he's making the point that if you try to add Maybe/Option to Java or Scala, you're fighting uphill.
11:02:44 <cmccann> I think he was also the primary author of the bananas barbed wire whatever recursion schemes paper?
11:02:50 <bitemyapp> cmccann: yes
11:02:58 <bitemyapp> He does have some slightly odd opinions about Maybe and [] too, but that's not the point he's making in that tweet.
11:03:26 <cmccann> bitemyapp: to be precise, he's being intentionally unclear in order to be provocative. and also making that point.
11:03:36 <hpc> which tweet?
11:03:48 <bitemyapp> cmccann: yes.
11:03:53 <cmccann> hpc: a recent one, just look at his twitter
11:04:02 <cmccann> there's a /r/haskell post about it
11:04:48 <hpc> oh i see
11:05:05 <lispy> Rust has option types but (other than macros) it doesn't have abstractions like monads/applicatives/functors/etc to help you use them
11:05:18 <lispy> So it's really common to see code that just does .unwrap() on an option type
11:05:25 <cmccann> but the real point is that he does that kind of thing on a semi-regular basis, just infrequently enough that I guess people keep forgetting
11:05:42 <bollu> lispy: but that's considered bad rust style
11:05:44 <lispy> Based on that rust experience, I think he's right about adding Maybe to Java
11:05:58 <bollu> you usually either pattern match or use the tons of combinators rust provides for Optino
11:06:00 <bollu> Option*
11:06:09 <bitemyapp> lispy: jeez, what's the point then?
11:06:11 <bollu> opt.map(…) is pretty common
11:06:24 <bollu> as is bind (they call it something else, can't remember. been a while with Rust)
11:06:26 <monochrom> what does unwrap do? is it the same as fromJust?
11:06:36 <bitemyapp> monochrom: yeah. or .get()
11:06:57 <lispy> monochrom: for option types it's fromJust, but I think in the standard library unwrap is part of a trait (think typeclass)
11:07:03 <pleiosaur> unwrap is fromJust, yes, and it's heavily discouraged in library code
11:07:31 <nolrai66> bitemyapp: Ah, so there is context to what he says.
11:07:58 <bitemyapp> nolrai66: he'll say he meant something else if you catch him out.
11:08:24 <cmccann> I see on /r/haskell that at least augustss knows the drill here, heh
11:08:27 <monochrom> ok yeah, the language lacks pattern matching and good support for higher-order functions. this lacking makes algebraic data types unusable.
11:08:36 <nshepperd> is the point there supposed to be that people are still able to pass a 'Just null' or a 'null' :: Maybe a in java?
11:08:42 <nolrai66> Its a annoying but simi-valid form of advertising.
11:09:01 <lispy> monochrom: it has pattern matching and higher-order functions (with restrictions around ownership)
11:09:27 <nolrai66> nshepperd: I think the point is that without other features just having Maybe doesn't help.
11:09:32 <nshepperd> since the existence of null has already established the convention that a value of type 'a' may not actually contain a non-null value
11:09:50 <bitemyapp> cmccann: augustss is wise.
11:10:05 <bitemyapp> cmccann: dude trolls a lot. You'd think people would know better.
11:10:30 * cmccann shrugs
11:10:31 <monochrom> I taught an imperative data structure course. I used Java because it's the most static and strongly typed language the students know. (look, it's either python or java.) when it comes to for example dictionary's lookup, I decided to just throw an exception instead of a homebrew Maybe, precisely because Maybe is going to be annoying in Java.
11:11:10 <monochrom> (and of course, Python would not help in this aspect.)
11:11:49 <monochrom> but see my http://www.vex.net/~trebla/humour/Nightmare.java
11:11:53 <nshepperd> mmm, yeah, java doesn't even have first class functions so you can't even destructure things in CPS'd style
11:12:08 <lispy> And java has those statically known exceptions, which can make exceptions slightly less evil
11:12:33 <monochrom> yeah, if you can do higher-order functions easily, then you can always replace pattern matching by functions like maybe and either.
11:14:02 <lispy> pleiosaur: is that a standard library policy? I've (grumpily) run into lots of code from crates.io and books/blogs/tutorials that uses partial functions
11:14:06 <nshepperd> well, I suppose you could go full boilerplate. 'new Function<foo, bar> { public bar run(foo x) { ... } }' but that way lies utter insanity
11:14:50 <mr-> monochrom: it has gotten a little bit better with java8, though. Lambdas and a Optional<> with a .map()
11:15:03 <lispy> pleiosaur: I say grumpily, because I usually find out when it panics and gives me a source/line in the standard lib instead of the call site :)
11:17:01 <pleiosaur> lispy: definitely bad style. rust doesn't give you any real mechanism to catch panics, so if a dependency panics you're SOL. accepted style is to use Result instead for errors
11:17:19 <danilo2> Hello guys! How can I make a Type Family in Haskell that returns empty contraint? I was trying to do stung like : type family Foo a :: Constraint where Foo Int = ()   but I get error "... should have kind ‘Constraint’ but ‘()’ has kind ‘*’" 
11:17:30 <pleiosaur> (there is technically a way to stop a panic in its tracks, but that's only really for FFI, because unwinding across an FFI boundary is UB)
11:17:54 <lispy> pleiosaur: UB?
11:18:02 <Iceland_jack> danilo2: Works for me
11:18:02 <spicydonuts> undefined behavior
11:18:04 <pleiosaur> lispy: undefined behavior, in the C sense
11:18:26 <danilo2> Iceland_jack: seriously? hmmm, wait a moment
11:18:34 <pleiosaur> lispy: that said, unwrap is fine for application code, because if you get a crash then it's your own fault :P though generally it does just mean "TODO: ERROR HANDLING"
11:19:20 <danilo2> Iceland_jack: ha! You're the man! thanks! :D It works indeed - I was using inside the type - level expression another type family that bordered the constraint to * -.- sorry and thanks again! :)
11:19:31 <Iceland_jack> no problem
11:20:42 <jophish_> I just defined a function called (=~°!), what has become of me.
11:21:34 <nolrai66> ..
11:21:52 <monochrom> wait until you define 9 more versions of it for different levels of precedence :)
11:21:52 <julianleviston> jophish_: you’ve become AWESOME!
11:22:06 <jophish_> Previously defined in the same module is (=~) which is a fuzzy equality on reals, and a bunch of other comparison operators suffixed with '!' which do something else in addition to the comparison
11:22:27 <mniip> and the degree?
11:22:28 <danilo2> by the way, why PolyKinds are different than constraints? I mean, when I declare a type family like type family Foo (a :: k) :: k where Foo a = a it doesn't work with constraints. It would work only when explicitly typed instead of k
11:22:33 <monochrom> alright, but what does the ° stand for?
11:22:43 <julianleviston> degree
11:23:14 <mniip> @let type family Foo (a :: k) :: k where Foo a = a
11:23:15 <lambdabot>  Defined.
11:23:20 <mniip> :k Foo Show
11:23:21 <lambdabot> * -> Constraint
11:23:26 <mniip> :k Foo (Show Int)
11:23:27 <lambdabot> Constraint
11:23:42 <jophish_> mniip: It's equality on Angles, so modulo 2pi
11:23:51 <danilo2> :k (Foo () :: Constraint)
11:23:52 <lambdabot>     The signature specified kind ‘Constraint’,
11:23:53 <lambdabot>       but ‘Foo ()’ has kind ‘*’
11:23:53 <lambdabot>     In a type in a GHCi command: (Foo () :: Constraint)
11:24:05 <danilo2> mniip: ^^^
11:24:23 <monochrom> ah, heh
11:24:33 <mniip> () is not a constraint
11:25:10 <monochrom> you know, one day someone will ask you "why ° when using radians?" :)
11:25:30 <danilo2> mniip: it is, it is an empty contraint
11:25:31 <danilo2> :D
11:25:48 <jophish_> monochrom: I knew the digraph in vim for the degrees symbol, but not the one for superscript r :D
11:25:48 <mniip> :t undefined :: () => a
11:25:49 <lambdabot> a
11:26:05 <monochrom> @kind () => Int
11:26:06 <lambdabot> *
11:26:13 <mniip> danilo2, I suspect it's related to the fact that (a, b) is a huge hack in the ghc typechecker
11:26:14 <danilo2> mniip: @type Bar = (() :: Constraint)
11:26:18 <mniip> it.s not related to type inference
11:26:25 <mniip> or rather, kind inference
11:26:27 <danilo2> mniip: probably, ok thanks :)
11:58:02 * hackagebot sdl2-compositor 1.0.1 - image compositing with sdl2 - declarative style  https://hackage.haskell.org/package/sdl2-compositor-1.0.1 (seppeljordan)
12:05:36 <zipper> Hey humans, what do you think about this mergesort implementation http://lpaste.net/8317231248472801280
12:07:42 <c_wraith> who are you calling human? :(
12:08:00 <johnw> your merge sort just calls sort?
12:08:15 <c_wraith> Heh.  Fun typo. :)
12:08:39 <c_wraith> Haskell lists are not a good structure to use with a top-down merge sort, by the way
12:08:55 <c_wraith> You have to traverse them lots of extra times.
12:10:41 <zipper> c_wraith: Okay uh sorry for calling you humans :) what should I use instead of lists?
12:11:05 <c_wraith> Lists are fine, just go with a bottom-up merge sort instead
12:11:24 <c_wraith> Also, note johnw's remark.  You have a serious bug in the form of a pair of typos. :)
12:11:35 <zipper> johnw: Well according to what I read. When you are using/doing mergesort. You split the list into two. Sort them as you wish. Then the merging while sorting makes the mergesort.
12:12:02 <zipper> johnw: I'll write quicksort right now but this is just so that I could get things done quick.
12:12:25 <zipper> c_wraith: I have typos? Well this keyboard is new and I hate it.
12:12:44 <zipper> c_wraith: Which bottom up merge sort?
12:12:56 <c_wraith> zipper: the point is that what should be your recursive calls (to mergesort) are calls to sort instead
12:13:31 <lispy> You probabably meant: fList mergeSort fList'
12:13:45 <lispy> <sigh> with an equal sign in the right place :)
12:14:24 <c_wraith> zipper: and a bottom-up mergesort doesn't recursively split the list in half.  Instead, it starts by splitting the list into singletons, then recursively merging pairs of them until there's only one list left.
12:15:17 <zipper> Okay either my resource is wrong. But merge sort is like this. You take a list. Split it into two sort the two sublists or half lists however and then merge them as you sort them.
12:15:21 <zipper> Am I wrong?
12:15:22 <bz> not even the full power of ghc's type system will prevent utterly shitastic code organization
12:15:32 <Fuuzetsu> yet
12:15:43 <c_wraith> zipper: that's a top-down merge sort.  You start at the top, the full list, and repeatedly break it down.
12:16:09 <c_wraith> zipper: but you can write a bottom-up merge sort instead..  It starts at the bottom, with the list broken into singletons, and repeatedly builds it up.
12:16:20 <zipper> bz: WOW that's a harsh word to use to refer to my merge sort thingie.
12:16:39 <bz> zipper: my message was applicative
12:16:41 <c_wraith> zipper: it's the same algorithm in most ways, the bookkeeping is just a bit difference.
12:17:09 <c_wraith> zipper: and the bugs we're talking about are on lines 6 and 7.  You are calling sort instead of mergesort
12:17:46 <zipper> c_wraith: Calls to sort?
12:18:13 <c_wraith> zipper: read lines 6 and 7 of your paste very carefully.  Look for the sequence of letters "sort".  Note that they aren't "mergeSort"
12:18:49 <zipper> Because I thought it doesn't matter how one sorts the sublists.
12:19:03 <zipper> I didn't know one had to mergesort the sublists
12:19:05 <zipper> hmmmm
12:19:13 <c_wraith> zipper: it's only a mergesort if it works recursively
12:19:21 <zipper> Well maybe I am misunderstanding my resource.
12:20:58 <zipper> c_wraith: Okay, I got that. Now to grasp the bottom down part...
12:21:21 <bz> zipper: so i just saw your code. s# = sort# = mergeSort#g. also, idk how i feel about using lists for this. overall, gg.
12:22:58 <osa1> too bad `...` style infix applications are left associative, it doesn't work well with functions with type a -> b -> b.
12:23:09 <zipper> I swear you guys. I wish I could refer you to this video on coursera it implied that it doesn't matter how one sorts the sublists (so I thought I could get away with calling the sort from Data.List) . Now I know better. 
12:23:48 <glguy> osa1: welcome back.
12:24:10 <osa1> glguy: I'm still working on that something else :p
12:24:14 <zipper> bz: What does gg mean? and all the '#'?
12:24:29 <glguy> That's OK, I'm still working on the lexer. It doesn't blow up now on lexer failure
12:24:42 <glguy> you get a proper error in the final parse at the proper location
12:24:46 <osa1> glguy: yeah saw that, that's awesome. that was one of the things I was hoping to fix myself
12:25:21 <zipper> c_wraith: So if I break it up into singletons. I'll have n lists to put together. However my merge only wants to take two lists at a time so I'd have something like [[a]] that I am calling merge on.
12:25:37 <zipper> bz: What should I use instead of lists?
12:26:22 <c_wraith> zipper: work pairwise in the big list.  Merge each pair of adjacent lists together.  Then do it again, recursively, until there's only one list left.
12:29:10 <jophish_> Here's my problem. I have some calculations which involve a stack of transcendental functions and when the inputs get high, the results get much less precise. I'm currently testing these with quickcheck by doing something along the lines of "testFoo x = x =~ (foo . invFoo) x" where =~ is a fuzzy real equality operator. Is this a wise way to test these functions at all, and if it is what can people suggest for a comparison where the 
12:29:10 <jophish_> expected precision can change depending on the inputs (an issue with this is that I don't really have an idea of how the precision can change with these functions, I only know that it gets worse as the inputs get closer to the limits)?
12:32:53 <zipper> c_wraith: Okay, maybe I'm missing something. A singleton is [x] but how can I have a list of length >2 get split into two singletons? Maybe I should google this.
12:33:24 <c_wraith> > map (: []) "hello"
12:33:26 <lambdabot>  ["h","e","l","l","o"]
12:34:01 <c_wraith> zipper: then you write a function that grabs adjacent pairs of lists, merges them, and goes to the next pair.
12:34:10 <cocreature> jophish_: you might want to test the relative accuracy so divide by the value and then compare that to some epsilon
12:34:58 <jophish_> cocreature: sorry, could you elaborate on that, I don't quite understand what you mean by "divide by the value"
12:35:11 * geekosaur wonders if jophish_ has looked into http://hackage.haskell.org/package/HerbiePlugin
12:35:14 <jophish_> I don't have a function which returns the precision of foo given so output
12:35:22 <cocreature> jophish_: I assume your approximate equality is something like (x-y)<epsilon right?
12:35:24 <jophish_> geekosaur: I'm planning to try that out very soon!
12:35:32 <jophish_> cocreature: at the moment that's what it is
12:35:43 <cocreature> jophish_: allright, try (x-y)/x<epsilon
12:35:59 <zipper> c_wraith: Okay I see. But this list of lists. It's not sorted yet is it? So I'll have to be looking throughout the list I am making where this item should fit. That is very inefficient.
12:36:33 <jophish_> cocreature: so this is assuming that the precision drops off linearly with the input
12:37:17 <jophish_> I'll try it out, but I don't think it's quite right for this. The precision is already pretty poor even at x = 24, I might need a large epsilon :) 
12:37:37 <cocreature> if the precision is pretty poor for x = 24 something is wrong :)
12:38:05 <cocreature> meaning your algorithm is numerically unstable (assuming it's correct otherwise)
12:38:34 <jophish_> cocreature: it's just that foo 24 produces some huge value which can't be stored very precisely in a double
12:38:48 <jophish_> let me check what it is
12:39:30 <cocreature> well then dividing by the huge value could actually help
12:40:10 <jophish_> oh! you meant to divide by the intermediate value
12:40:21 <jophish_> the output of foo, not (invFoo . foo)
12:40:36 <cocreature> I'm confused, what is the huge value? I thought that was your output and 24 was your input
12:41:35 <jophish_> I'm testing the function foo by doing the following quickcheck property: forAll input (\x -> x =~ invFoo . foo x)
12:41:58 <jophish_> checking that a roundtrip through foo and its inverse returns the the original value
12:42:16 <jophish_> invFoo . foo $ x *
12:42:46 <jophish_> forAll input (\x -> x =~ (invFoo . foo) x) -- sorry
12:43:27 <glguy> invFoo (foo x) ノ( º _ ºノ) 
12:43:34 <RedNifre> Hey again.
12:44:02 <RedNifre> So I think I might maybe understand monad transformers... but this code still looks clumsy to me. Can this be done in a better way?: https://gist.github.com/RedNifre/4dbc33c1f8f642a5ed5b
12:44:13 <jophish_> thanks, glguy :/
12:44:43 <RedNifre> It seems that what I saved on the "match Just/Nothing" side is lost on the "write lift and MaybeT everywhere" side. :/
12:44:56 <jophish_> a better way of explainig would be that I'm checking that (invFoo . foo) == id
12:45:03 <glguy> Using MaybeT isn't usually a win in these small cases
12:46:46 <RedNifre> Do you have an example where MaybeT helps? How would you write my example code?
12:47:32 <RedNifre> Do you even declare  functions as "... IO (Maybe X)" or do you have them return "MaybeT IO X" to make it easier on the caller side?
12:47:40 <glguy> The only time I can imagine using it is when defining some newtype of a monad transformer stack
12:48:33 <RedNifre> Why isn't there something like the pseudo code at the end of my file? Couldn't a smarter do-notation allow mixing of different monad types?
12:53:58 <glguy> because it isn't obvious what it should do
12:54:12 <glguy> I pasted a version of your code that's probably close to as good as that gets
12:54:48 <glguy> It will help if you write your IO actions in terms of MonadIO class instead of directly as IO if you want to jump in and out of MaybeT contexts
12:55:41 * RedNifre looks at glyguy's code...
12:56:29 <Job314> hi there - I'm learning haskell and am getting a bug in a function that looks right - would you mind having a look? http://pastebin.com/cdxWrCxM
12:56:42 <Job314> there's a syntax error in there and I'm trying to figure out what's breaking things
12:57:17 <glguy> Job314: If you don't understand an error it will help if you paste the error with the code
12:57:34 <Job314> ah sorry I'll do that
12:57:47 <Gurkenglas> glguy, I think hoistMaybe should be generalized to (maybe mzero return :: MonadPlus m => Maybe a -> m a)
12:57:51 <glguy> In your case the problem is the missing leading 0 from your floating literals
12:58:05 <glguy> Gurkenglas: I think that's called "msum"
12:58:13 <Job314> I am an idiot
12:58:14 <Job314> thanks
12:58:21 <Gurkenglas> Ah, of course, I was looking for that
12:58:23 <glguy> err, close
12:58:30 <geekosaur> Job314, . means a lot of different things in Haskell and you generally need to be careful with it. so you can't write .1 it has to be 0.1
12:58:53 <geekosaur> or it thinks it's the composition operator or an illegal qualified name
12:58:54 <albertus1> you just "showed" me my own syntax error that i made yesterday and couldn't figure out :) [mine was omitting brackets in pattern matching on a list]
12:59:03 <glguy> Gurkenglas: I usually have a locally defined version of that when I need it: more like msum.fmap return
12:59:35 <Gurkenglas> Why fmap return?
13:00:07 <Gurkenglas> Oh, of course. Nevermind me
13:00:28 <RedNifre> glguy that's interesting... what exactly is MonadIO and why is it compatible with MaybeT IO? I thought e <- X would only work on MaybeT IO in a do block that returns MaybeT IO?
13:01:06 <glguy> RedNifre: http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-IO-Class.html
13:04:11 <RedNifre> Oh, wow. So MonadIO can be any monad transformer that has IO on the outside and it can also sort of be a regular IO monad thanks to MonadIO (Identity m) ?
13:04:39 <johnw> RedNifre: we'd normally say that IO is on the inside
13:04:59 <RedNifre> Why?
13:05:22 <c_wraith> zipper: No, you only ever merge lists.  No searching required.
13:05:30 <RedNifre> To me I'm waiting for some IO to complete and when that is over I'm left with a Maybe... so why would you say that the IO is inside?
13:05:43 <johnw> ReaderT env (WriterT w IO) a
13:05:52 <johnw> IO is on teh inside of the *transformers*
13:06:06 <johnw> even if it might, in some cases, be on the outside of the unwrapped type
13:06:14 <bitemyapp> RedNifre: do you put a coat on or do you put it in your stomach?
13:06:15 <johnw> here it would be: env -> IO (w, a)
13:06:17 <RedNifre> okay, that sounds fine.
13:06:19 <johnw> so IO is in the middle in this case
13:06:19 <zipper> c_wraith: Do you have a minute?
13:06:29 <c_wraith> sure
13:06:33 <zipper> We talk in a PM
13:06:35 <zipper> Okay
13:06:48 <glguy> Because we're talk relative to the instances of MonadIO, not the result of unwrapping that type
13:06:53 * voidzero eats bitemyapp's coat
13:07:01 <RedNifre> the coat would be on the outside. The coat can wrap different persons... I guess I don't understand the metaphor.
13:07:21 <Fuuzetsu> maybe if it was a spacesuit instead
13:07:23 <glguy> MaybeT is a coat, I think is the metaphor
13:07:26 <johnw> yeah, I didn't get that metaphor either
13:07:27 <voidzero> "juf fo proof a foinp"
13:07:33 * voidzero spits
13:07:38 <glguy> Or maybe it's just a lesson in not eating your clothing?
13:07:53 <kclancy> I am having a problem where  ghc is telling me that "No instance for (Default Config) arising from a use of def"
13:08:05 * hackagebot lambda2js 0.1.0.1 - Untyped Lambda calculus to JavaScript compiler  https://hackage.haskell.org/package/lambda2js-0.1.0.1 (MatejKollar)
13:08:10 <kclancy> I actually wrote an instance definition for Default Config, though
13:08:13 <johnw> kclancy: then either no such instance exists, or it's not in scope
13:08:24 <kclancy> johnw: it's probably not in scope
13:08:41 <glguy> kclancy: orphans *and* a use of Default class, double trouble!
13:08:44 <RedNifre> In glguy's example code, does ioString = return "Foo" :: MonadIO m => m String mean "just pick what works best when you need it"? That looks surprisingly dynamic to me.
13:09:12 <kclancy> johnw: but I don't understand why. The module that defines Config and the instance definition is being imported.
13:09:33 <kclancy> glguy: I am using default to help me write unit tests? Is Default bad?
13:09:42 <glguy> it's just sloppy
13:09:56 <glguy> One way that could be going wrong is if you have two versions of the thing installed
13:10:02 <johnw> Default is usually an unnecessary convenience
13:10:04 <glguy> and the instance is on the other version
13:10:25 <kclancy> glguy: okay. but I don't want to fill out each of the 20 fields of this type every time I write a unit test.
13:10:30 <glguy> an easy way to have two versions of the type is to have your tests and library in the same source directory
13:10:39 <glguy> kclancy: That's fine, you make a value called "defaultConfig"
13:10:42 <johnw> kclancy: write a function called newConfig
13:10:48 <johnw> or rather, a value
13:10:51 <kclancy> glguy: that sounds like a good idea. thanks for the advice.
13:11:19 <RedNifre> What's the best practice when dealing with transformers? Should I replace every IO with MonadIO and every IO (Maybe X) with MaybeT IO X? Or would that just shift the friction elsewhere?
13:11:29 <johnw> RedNifre: it really depends
13:11:43 <johnw> if you're providing a library that will be used in the context of other transformers, then MonadIO is greatly appreciated
13:11:52 <johnw> if you're writing an application, or code that only you will use, it's unnecessary work
13:11:58 <glguy> RedNifre: exposing MaybeT is going to generally be a burden for your users
13:12:06 <johnw> lots of real code doesn't use MaybeT
13:12:12 <johnw> and MaybeT I usually find to be unnecessarily annoying
13:12:17 <glguy> If you're defining an interface where failure is common MaybeT isn't even very descriptive
13:12:20 <johnw> there are some really basic functions missing from the MaybeT support
13:12:45 <glguy> MaybeT exists because it's something obvious that can exist
13:12:51 <glguy> Not because anyone needs to use it
13:12:56 <kclancy> hmm. I'm not sure about the two versions thing. There is another definition for a type called Config, but it's being hidden. Maybe the Config type itself is being hidden, but the instance declaration is not being hidden. If that's the case, it seems like a problem with GHC.
13:13:00 <johnw> like, if I have a pure function returning Maybe a, I have to use: MaybeT $ return x
13:13:09 <johnw> there's no pureMaybe or
13:13:23 <johnw> yeah
13:13:26 <glguy> kclancy: is the problem code on github? It's much more likely that you have a mistake somewhere than that GHC is wrong
13:13:38 <RedNifre> I guess that's why glguy added hoistMaybe = MaybeT . return to the example code.
13:13:40 <johnw> I bet it wouldn't be too hard to make MaybeT more useful, actually
13:13:46 <johnw> yeah, exactly
13:14:07 <RedNifre> Is "hoist" a standardized term for that? :)
13:14:15 <johnw> yes
13:14:33 <cocreature> RedNifre: see http://hoogle.haskell.org/?hoogle=hoist if you need a proof :)
13:14:41 <johnw> hoist is used like an fmap at the monad level in a general sense
13:14:47 <kclancy> glguy: I do not have the code on github.
13:14:50 <johnw> forall a. Maybe a -> MaybeT IO a
13:15:03 <johnw> actually, no
13:15:04 <kclancy> glguy: I'm just going to stop using Default. Seems like an easier solution.
13:15:09 <glguy> kclancy: Can you paste your cabal file?
13:15:10 <RedNifre> I thought liftM was fmap at the monad level
13:15:19 <johnw> hoist is usually used to map forall x. MaybeT m a -> MaybeT n a
13:15:23 <kclancy> I suppose I could paste the Cabal file
13:15:24 <johnw> grr, s/a/x/g
13:15:41 <albertus1> MxybeT? :P
13:15:46 <kclancy> which pasting site should I use?
13:15:51 <glguy> ?lpaste
13:15:51 <lambdabot> Haskell pastebin: http://lpaste.net/
13:15:51 <Fuuzetsu> @where lpaste
13:15:52 <lambdabot> http://lpaste.net/
13:15:53 <albertus1> watch your regexp :P
13:15:54 <awpr> that's the type of a monad morphism, the argument to hoist, isn't it?
13:16:08 <johnw> RedNifre: what's needed here is a shift from Maybe :-> MaybeT IO.  That's not called hoist used.  It's sometimes called transport.
13:16:19 <johnw> s/used/usually
13:16:24 <glguy> liftMaybe might have been better ... \o/
13:16:29 <johnw> hoist is used to reach under the outer type
13:16:40 <johnw> yeah, liftMaybe should be in the transformers library for sure
13:17:48 <kclancy> It's a pretty big cabal file. I'm modifying an existing project.
13:17:49 <kclancy> http://lpaste.net/141836
13:18:05 * hackagebot pandoc-crossref 0.1.5.1 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.5.1 (lierdakil)
13:18:48 <kclancy> I need to head off pretty soon actually
13:18:58 <glguy> The problem I was hoping for wasn't there
13:18:58 <kclancy> don't spend too much time scrutinizing the cabal file
13:19:03 <kclancy> okay, cool
13:19:09 <kclancy> well, thanks for the help
13:19:36 <RedNifre> Okay, so liftMaybe will just use MaybeT . return... I'm a bit confused why some functions can sometimes be "dynamic" and often not. E.g. the return in ioString = return "Foo" :: MonadIO m => m String somehow manages to pick the correct one to match the MaybeT IO, but why is there no generic "run", why do we need "runMaybeT"?
13:20:06 <glguy> Functions can be "dynamic" by being either written in terms of typeclass methods or being typeclass methods
13:20:51 <RedNifre> So why isn't "run" a function in the Monad Transformer class so that we can run every do block with "run" instead of runMaybeT?
13:20:52 <glguy> when you try to use liftIO at the type: IO a -> MaybeT IO a, first GHC finds this instance: MonadIO m => MonadIO (MaybeT m)
13:21:02 <glguy> Monadlib actually has that
13:21:07 <jmcarthur> RedNifre: it would need a different type each time
13:21:33 <glguy> http://hackage.haskell.org/package/monadLib-3.7.3/docs/MonadLib.html#v:runM
13:21:48 <jmcarthur> RedNifre: runStateT :: StateT s m a -> s -> m (a, s); runWriterT :: WriterT o m a -> m (o, a); etc.
13:22:09 <jmcarthur> that generic runM solves this problem using functional dependencies
13:22:16 <RedNifre> now, wait. is jmcarthur saying it's impossible and glguy posted an implementation?
13:22:18 <jmcarthur> However, I question its value.
13:22:26 <jmcarthur> RedNifre: I didn't say it was impossible
13:22:39 <RedNifre> What did you mean by "it would need a different type each time"?
13:22:58 <jmcarthur> RedNifre: Looks at the runStateT and runWriterT types I just showed you. They are quite different.
13:24:25 <jmcarthur> RedNifre: Anyway, what I'm really trying to work toward is that this has significant meaning, and hiding it with fundeps like the MonadLib package does has no real value as far as I can tell.
13:26:52 <glguy> The value is that it saves you from writing out runThis (runThat (runTheOther m) x) a b) c which doesn't add much over runM m x a b c
13:29:25 <RedNifre> I guess my problem is with the restrictions of the do-notation. I mean, I understand that it's just a different way to write >>= >>= >>= so I understand that the type needs to match. However, I don't necessarily NEED to have it mean a chain of ">>=". If you look at the not working pseudo code at the end of my example what I'd really want is "first, I perfom this IO action. When the String comes out of it I feed it to the maybeString funct
13:29:25 <RedNifre> ion. If that's Nothing I stop, if if's Just x I take the x. Then I call this function that gives me IO (Maybe String), so I wait, then I check the Maybe and take the y out of it. Then I print both."... I mean, if that's all I want to do, picking the right Monad Transformer for the do-Block and adding liftMaybe or MaybeT seems like a distraction. What is the benefit of requiring that? 
13:31:03 <fread2281> what parser libraries can I do mixfix operators in? Earley is out because operator parts can't be used as identifiers or it doesn't work
13:31:12 <RedNifre> And in the case where I want to drill two levels deep I'd be willing to type x <<- getIOMaybeString
13:32:38 <ryanpbrewster> Is there a way to do this (https://gist.github.com/ryanpbrewster/97da8715d809c80fa37b) in a more type-safe manner?
13:34:13 <ryanpbrewster> I think I want to create an explicitly enumerated type class. So something like data Adjective Comedy = Funny | Childish and data Adjective Horror = Scary | Boring
13:34:39 <ryanpbrewster> so that I can write a function with a signature :: Genre g => g -> Adjective g
13:34:46 <awpr> ryanpbrewster: sounds like data families, I think
13:37:10 <fread2281> ryanpbrewster, GADTs would work
13:37:40 <ryanpbrewster> fread2281, I've looked into those, but it isn't really clear to me how that would work.
13:37:43 <fread2281> oh no, they might not with Genre as a typeclass
13:38:11 <ryanpbrewster> I'm not locked into having Genre as a typeclass. Honestly, that doesn't really make sense to me.
13:38:26 <ryanpbrewster> But I don't even know how to write the type signature I'd want if I don't have them as a typeclass.
13:39:38 <ryanpbrewster> Basically I just want to set this up in such a way that [ (Movie "asdf" Horror, CA Funny) ] wouldn't compile.
13:40:17 <fread2281> what is CA?
13:42:07 <ryanpbrewster> "ComedyAdjective"
13:46:07 <awpr> you could use GADTs to get "f :: Movie g -> Adjective g" by tagging each Adjective constructor with its genre
13:46:31 <ryanpbrewster> Interesting. That sounds like exactly what I want.
13:48:42 <lemevi> I'm finding the CIS194 lecture notes to be way more betters than LYAH
13:48:49 <awpr> data Genre = Horror | Comedy; data Movie where { HorrorMovie :: String -> Movie Horror; ComedyMovie :: String -> Movie Comedy }; data Adjective where { Funny :: Adjective Comedy; Scary :: Adjective Horror }
13:49:10 <ryanpbrewster> Thanks! I'll look further into GADTs.
13:50:02 <awpr> that also requires the DataKinds extension, by the way
13:50:31 <ryanpbrewster> Okay, thanks again. This gives me a good place to start.
13:58:01 <info_is_good> I've added an executable file to a libraryp roject. How do I write the "build-depends" line - do I have to insert them manually, or can cabal guess it to me?
14:04:30 <submain> Is there a way to change ghc-mod's target? It can't find packages listed in the test-suite section of my cabal file.
14:05:12 <glguy> info_is_good: You write it manually, the only autogeneration is done with cabal init
14:12:32 <tabemann> why doesn't haskell-mode like th e following like (in a do block)?: let hints = S.defaultHints { addrFlags = [S.AI_CANONNAME, S.AI_NUMERICSERV] }
14:13:08 * hackagebot pandoc-crossref 0.1.5.2 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.5.2 (lierdakil)
14:13:24 <tabemann> I'm quite sure it's valid Haskell, but it's making editing a pain because haskell-mode refuses to reformat code beyond that point, giving a "Parse error"
14:13:46 <Fuuzetsu> not sure what you expect, it's a hand-written parser in elisp
14:14:10 <Fuuzetsu> my coworker switched to Yi because he couldn't even edit large part of our codebase with new haskell-mode anymore
14:15:11 <tabemann> but it's not even using any weird extensions or like - it's perfectly valid Haskell 98
14:15:43 <geekosaur> so?
14:15:44 <tabemann> dammit, I'll just try to use yi rather than hitting my head against the wall with this
14:15:53 <geekosaur> you seem to be assuming that emacs has a sane language parser setup
14:16:09 <Fuuzetsu> fastest way is probably to downgrade your haskell-mode
14:16:37 <tabemann> unfortunately apt doesn't really allow downgrading
14:18:37 <tabemann> okay, it works with yi
14:24:46 <SwashBuckla> I wonder how yi is coming along. It's been about 6 months since I last used it
14:24:56 <ralu> how can one provde multiple extra-include-dirs in cabal config. I mean what is syntax
14:25:41 <Fuuzetsu> I have been inactive with that project (and others) in last months so probably not much changed, I don't think ethercrow did much feature-wise either but it's probably best to ask in #yi
14:25:57 <tabemann> I was going to upgrade yi to see if it supported a GUI now, but cabal yelled at me that I would be breaking a pile of things when I tried to cabal install yi --upgrade-dependencies
14:26:20 <tabemann> and when I tried to do cabal install yi it *still* complained that I would be breaking a pile of things
14:26:23 <Fuuzetsu> what do you mean if it supported a GUI? It has for years
14:26:34 <Fuuzetsu> and well, cabal is cabal, can't really help you on that front…
14:26:48 <Fuuzetsu> you can run it from sandbox
14:26:59 <tabemann> hmm maybe something was wrong with the build that it failed to add GUI su pport
14:27:07 <Fuuzetsu> you have to ask for it with a flag
14:27:11 <Fuuzetsu> -fpango for example
14:28:08 * hackagebot crypto-enigma 0.0.1.4 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.1.4 (Orome)
14:30:54 <tabemann> what package is gtk2hsC2hs in?
14:31:15 <indiagreen> tabemann: gtk2hs-buildtools
14:31:37 <indiagreen> tabemann: you might also need to install happy and alex if building gtk2hs-buildtools fails
14:33:08 * hackagebot crypto-enigma 0.0.1.5 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.1.5 (Orome)
14:46:04 <radens> This is a really stupid question, but I can't get google to answer it: Where does the maybe monad live? If I import Control.Monad.Maybe ghci tells me it doesn't exist.
14:47:10 <indiagreen> radens: “Maybe” is just a type that lives in Prelude
14:47:10 <quchen> radens: Maybe lives in Prelude.
14:47:24 <radens> derp. I was putting Maybe everywhere instead of maybe
14:47:28 <radens> thanks
14:47:30 <deech> Hi all, how do I find out which GHC version introduced the CallStack implicit parameter?
14:47:49 <glguy> osa1: I'm adding the interpretStringLiteral :: String -> ByteString and I'll add some tests for its relationship to the escaping function
14:48:02 <quchen> radens: Well, the acutal definition is in GHC.Base, if that's what you're looking for.
14:48:06 <geekosaur> it was 7.10. I suspect you'd have to review change logs, or appropriate manual sections
14:48:13 <glguy> Going this route will help with your other ticket about preseving the uninterpreted string literals, too
14:48:17 <quchen> radens: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#Maybe
14:48:33 <glguy> we can just track what delimiters were used. " ' or [===[ like ones
14:48:41 <glguy> and then pretty-print back with the same ones
14:48:47 <rvxi_> hey
14:48:57 <quchen> radens: GHC.Base is a good start for most Prelude definitions, actually. Prelude is a module that reexports lots of things only.
14:53:52 <osa1> glguy: thanks, I'm leaving now, I'll have a look in a few hours.
14:58:09 * hackagebot funbot-git-hook 0.1 - Git hook which sends events to FunBot.  https://hackage.haskell.org/package/funbot-git-hook-0.1 (akrasner)
15:03:20 <tabemann> god damn you text-icu
15:04:08 <tabemann> it's saying I don't have libicu* installed, when I have libicu*.so.48*, libicu*.so.52*, and libicu*.so.55* installed
15:05:41 <geekosaur> tabemann, sounds like the runtime libraries to me
15:05:57 <geekosaur> it needs libicu<something>.so without the .version suffix
15:06:14 <geekosaur> it can't operate your package manager and install the appropriate dev package for you
15:06:54 <tabemann> okay, so the problem is that it doesn't like the libicu*.so.<suffix> names
15:06:59 <hiptobecubic> tabemann, no
15:07:05 <hiptobecubic> it doesn't know what they are
15:07:15 <geekosaur> tabemann, those are RUNTIME libraries
15:07:23 <geekosaur> you need DEVELOPMENT libraries
15:07:38 <tabemann> see Debian isn't providing me any development libraries
15:07:53 <geekosaur> I would expect libicu<something>-dev
15:08:02 <indiagreen> tabemann: https://packages.debian.org/sid/libicu-dev
15:08:03 <tabemann> oh it's just libicu-dev with no version
15:08:10 * hackagebot crypto-enigma 0.0.1.6 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.1.6 (Orome)
15:08:16 <geekosaur> yes
15:09:55 <glguy_> Now apologize to text-icu
15:10:22 <cmccann> sclv: I'm still not convinced that hackage building docs automatically is more than just a myth >_>
15:10:53 <sclv> I've seen it, i promise
15:10:58 <cmccann> heh
15:11:09 <cmccann> apparently there's something extra weird going on with these?
15:11:14 <sclv> It busted again tho with the 710 update
15:11:33 <sclv> We need to finish our rewrite of the builders
15:11:46 <cmccann> someone looked at the other day--I think it was johnw?--and it looked like it had built and created docs but nothing showed up. or something.
15:12:18 <cmccann> it's not even a big deal, I just hate not knowing whether I'm doing something wrong with the package that's causing it to fail :[
15:13:04 <tabemann> user error (The package 'yi' requires Cabal library version -any && >=1.20 but
15:13:04 <tabemann> no suitable version is installed.)
15:13:12 <tabemann> does this mean I need to upgrade cabal itself?
15:13:22 <sclv> Join #haskell-infrastructure and help? :-p
15:13:46 <cmccann> don't tempt me, I have too many projects already :T
15:13:49 <tommd> I didn't think we could have spaces in IRC channel names.
15:15:05 <radens> Is there an easy way to avoid nested case statements? I'm getting a lot of this: https://pastebin.osuosl.org/33841/
15:15:21 <radens> (see line 6)
15:16:13 <quchen> radens: You should avoid head/tail as well. https://github.com/quchen/articles/blob/master/fbut.md#head-tail-isjust-isnothing-fromjust-
15:16:40 <quchen> If you have no dependency of the scrutinee ("argument of case") on the pattern of another case, you can just merge them
15:17:38 <radens> Unfortunately I think I do, as the final result is built from the result of both case statements
15:18:32 <quchen> radens: http://lpaste.net/141840 Like this, a bit.
15:18:46 <quchen> The program is extremely stringly typed though, so it's hard to give definite advice.
15:19:43 <radens> Yeah I really should build a real tokenizer
15:20:05 <radens> but baby steps
15:21:33 <icbm> Wow, I just had my first Haskell program that compiles but does not work.
15:21:47 <Jeanne-Kamikaze> fix error
15:21:54 <Jeanne-Kamikaze> > fix error
15:21:56 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
15:22:04 <radens> My first non-trivial haskell program wound up in an infinite loop
15:22:14 <icbm> radens: Hey, that's what mine does!
15:22:19 <tabemann> hmm that's odd
15:22:25 <Jeanne-Kamikaze> did you forget a ' by mistake ?
15:22:30 <tabemann> cabal-install version 1.22.0.1
15:22:30 <tabemann> using version 1.22.1.1 of the Cabal library 
15:22:36 <icbm> A little trace magic later, and I kinda have an idea where it is fouling up.
15:23:00 <radens> icbm: you may have forgotten an otherwise somewhere
15:23:28 <icbm> radens: This is also my first time making a Monad instance, so yeah, lots of room for error.
15:23:28 <xolrup> radens, why not just remove the case statements?
15:24:39 <tabemann> why would cabal complain when building yi that "user error (The package 'yi' requires Cabal library version -any && >=1.20 but
15:24:39 <tabemann> no suitable version is installed.)" when the Cabal library is already >= 1.20?
15:25:01 <tabemann> what does "-any" mean here?
15:27:17 <eigenfunction> Hello everybody, haskell noob here; can anybody explain this line from the realworldhaskell to me? it is from the bloomfilter chapter http://lpaste.net/141841
15:28:39 <eigenfunction> I can't understand how `liftM`return the type ST s (MutBloom s a)
15:29:02 <icbm> Found my issue. I was writing my own wrapper for Alex, and made a wrong assumption about how it handles errors.
15:30:42 <icbm> If I want it to skip over errors, I gotta actually move the input stream ahead to the next char, or it will gladly keep on reporting errors about the same bad char.
15:30:44 <radens> xolrup: I think I need them to handle all the maybes
15:37:41 <awpr> radens: that looks like the Monad instance for Maybe to me.  each case statement should be replaceable by (>>=)
15:37:59 <awpr> well, the inner one would actually be fmap
15:40:37 <radens> awpr: can you show me?
15:40:46 <awpr> eigenfunction: liftM :: Monad m => (a -> b) -> m a -> m b; it's applied to a partially-applied constructor on the left and an ST s Something on the right.  So the Monad type variable is 'ST s', a is the 'Something', and b is MutBloom s a
15:41:25 <zipper> Say I have an algo that searches through two arrays each of size n. I want to search through them. The procedure to use is to search through the first and if I don't find the value I search through the second one. I say the running time of this is O(2n) but this class says it's O(n) (something close to because 2 is a constant factor and we're supressing it). In this case 2n and n are very different. What am I missing? Do I have this
15:41:26 <zipper> completely wrong?
15:42:00 <zipper> Is there a better place to ask these questions? I don't want to go on stack exchange because they're very beginner.
15:43:32 <eigenfunction> awpr:  MB hash `liftM` newArray (0,numBits-1) False ; tells me that (a->b) = MB hash. Correct?
15:44:59 <eigenfunction> awpr: `liftM` takes two parameter. How come newArray (x,y) Bool is ST s a?
15:45:47 <jmcarthur> zipper: O(2n) is not any more meaningful than O(n)
15:46:10 <awpr> eigenfunction: type parameters and function parameters are different things.  "ST s a" is just one type, that fits into the second parameter of liftM
15:46:17 <jmcarthur> zipper: O(2n) takes twice as long as... what, exactly?
15:46:20 <medicijnman> sorry didn't notice i left the room. does anyone know if my question is possible?
15:46:34 <jmcarthur> zipper: We don't even know how long O(n) takes. What could O(2n) mean?
15:46:49 <mniip> O(N) = O(2N)
15:46:52 <mniip> by definition of O
15:46:59 <arkeet> zipper: big O stuff is about asymptotics, ignoring constant factors. O(n) and O(2n) are the same.
15:47:21 <zipper> and a whole doubling is a constant factor?
15:47:25 <arkeet> 2 is a constant yes.
15:47:33 * geekosaur does not see a question from medicijnman in backscroll...
15:47:49 <zipper> I thought constants were the ones we'd ignore e.g 6n + n
15:47:58 <medicijnman> geekosaur:  is it possible to do e.g. where tree@(head:tail) = something ?
15:48:00 <geekosaur> zipper, n vs. 2n is rarely significant compared to (say) log n or n^2
15:48:02 <arkeet> O(n) means "smaller than k*n, for some positive constant k, and large enough n"
15:48:07 <radens> awpr: I suspect I could remove the case statements, but I'm not sure how. Could you show me how?
15:48:35 <medicijnman> geekosaur: somefunc tree@(head:tail) = something works, but where tree ... does not
15:48:35 <geekosaur> medicijnman, you can answer those kinds of questions by trying them in ghci. but yes, that should work
15:48:41 <zipper> jmcarthur: Thanks, haha I'm playing with these things getting ready.
15:48:47 <arkeet> for O(2n) you can just pick a different k to see that they're the same.
15:48:48 <geekosaur> but you may be using "where" in the wrong place
15:48:58 <geekosaur> it is part of definition syntax, not expression syntax
15:49:08 <awpr> radens: working on it, while also trying to babysit my mash at the right temperature for a Celebration Ale clone
15:49:14 <medicijnman> geekosaur: well ghci does not accept that, i'm looking up the error message...
15:49:27 <zipper> jmcarthur: I meant O(2n) takes twice as long as O(n)
15:49:32 <geekosaur> so you're just typing "where ..." at the prompt and expecting it to work?
15:49:39 <mniip> zipper, then don't use O
15:50:12 <zipper> mniip: No, I'm learning asymptotic analysis.
15:50:28 <mniip> then don't misuse O
15:50:31 <geekosaur> medicijnman, in ghci, a declaration starts with "let"
15:50:48 <geekosaur> let name = expr where ... -- is valid
15:51:11 <eigenfunction> awpr: I see what you mean. 
15:51:15 <geekosaur> at top level, name = expr where ... -- is valid
15:51:20 <lpaste> awpr pasted “Maybe monad” at http://lpaste.net/141842
15:51:22 <medicijnman> geekosaur: yes i know ;) ghci does accept it now
15:51:29 <cdk> zipper: big-O notation is just a shorthand to describe how the run time scales with the size of the input. O(n) and O(2n) both scale the same, linearly, even if one has a greater slope than the other.
15:51:48 <awpr> radens: see that paste ^  (I haven't actually tried to compile it, so it's probably broken, but it should give the general idea)
15:51:50 <zipper> cdk: Nice, thanks
15:52:01 <radens> awpr: awesome, just wanted to make sure you understood my terse statement.
15:52:20 <medicijnman> geekosaur: i have a rose tree that is defined like this: data Rose a = a :> [Rose a]. I want to calculate the maximum of a Rose Int
15:52:43 <awpr> radens: you've already got a "do" block for Maybe, so the left-arrow binding syntax is equivalent to one level of the case statements you had before
15:52:46 <medicijnman> geekosaur: for now i use a wrapper function that takes Rose Int and extracts an Int (i.e. Rose Int -> Int)
15:52:50 <radens> awpr: thanks!
15:53:36 <medicijnman> geekosaur: i use it like this maximum (map wrap tree) where tree = [(somefunc y) | y <- xs].
15:54:02 <geekosaur> that looks wrong, or at least incomplete
15:54:07 <geekosaur> @paste
15:54:07 <lambdabot> Haskell pastebin: http://lpaste.net/
15:54:16 <geekosaur> actual code to pastebin ^^
15:54:17 <medicijnman> geekosaur: xs is a parameter from a rose tree (x :> xs) in another function
15:58:35 <medicijnman> geekosaur: nvm. i solved it. i wrote 'warp' where i should have written 'wrap'
15:59:10 <medicijnman> geekosaur: i better rename those functions because i think i will make this mistake again
15:59:38 <radens> awpr: that doesn't seem to be working for me.
16:00:36 <tabemann> I asked about this earlier, but I'm going to ask again: what's going on here? when I try to build yi I get:
16:00:49 <radens> awpr: https://pastebin.osuosl.org/33846/
16:00:50 <tabemann> cabal: Error: some packages failed to install:
16:00:50 <tabemann> yi-0.12.2 failed during the configure step. The exception was:
16:00:50 <tabemann> user error (The package 'yi' requires Cabal library version -any && >=1.20 but
16:00:50 <tabemann> no suitable version is installed.)
16:01:00 <tabemann> but when I check my cabal version I get:
16:01:12 <tabemann> cabal-install version 1.22.0.1
16:01:12 <tabemann> using version 1.22.1.1 of the Cabal library 
16:01:13 <zipper> When the teacher is using loops and you've been writing haskell so long you can't remember clearly how loops work.
16:01:50 <geekosaur> tabemann, are you building yi in a sandbox?
16:01:58 <tabemann> geekosaur: no
16:02:08 <geekosaur> then: ghc-pkg list Cabal
16:02:42 <awpr> radens: is parseIdentifierList not returning Maybe?  if not, the original wouldn't have worked either.
16:03:00 <tabemann> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
16:03:00 <tabemann> /usr/local/lib/ghc-7.8.3/package.conf.d
16:03:00 <tabemann>    Cabal-1.18.1.3
16:03:00 <tabemann> /home/tabemann/.ghc/x86_64-linux-7.8.3/package.conf.d
16:03:02 <radens> awpr: yeah I'm kind of in the middle of a big refactor
16:03:29 <glguy_> cabal installs version only tells you want version that executable was compiled with
16:03:35 <geekosaur> that broken packages thing is worrisome. but you will note that the version of the Cabal library available is not the one you need
16:03:40 <glguy_> Not what you have installed as a library now
16:04:58 <glguy_> Avoid breaking your package database by not forcing reinstalls when warned about it
16:08:08 <lpaste> Gurkenglas annotated “Maybe monad” with “Maybe monad (annotation) awpr, how about this?” at http://lpaste.net/141842#a141843
16:08:11 <tabemann> but it seems that trying to upgrade things much of the time gives broken package warnings, as if the only way to upgrade much of the time is to wipe one's build environment and rebuild everything from scratch
16:08:59 <glguy_> Yeah, upgrading a package might require unregistering the things that depend on it first
16:10:00 <awpr> Gurkenglas: *shrug* that paste was trying to change as little as possible from the original https://pastebin.osuosl.org/33841/.
16:14:56 <tabemann> good - this version of yi doesn't replace normal syntax with random Unicode characters like the older version I was using did
16:43:14 * hackagebot slack-api 0.6 - Bindings to the Slack RTM API.  https://hackage.haskell.org/package/slack-api-0.6 (mpickering)
17:18:15 * hackagebot numeric-extras 0.1 - Useful tools from the C standard library  https://hackage.haskell.org/package/numeric-extras-0.1 (EricMertens)
17:18:57 <indiagreen> There's a typeclass called “Default”; if you have heard of it, please don't read further or at least don't answer my question. This typeclass defines a method, “def :: Default a => a”. If I typed “def :: [Int]”, what would you think it would return?
17:19:25 <crough> indiagreen: Probably []?
17:19:41 <crough> I know of it but I tend not to use it so I'll answer anyway :)
17:20:02 <indiagreen> crough: thanks for your response. Anybody else?
17:20:16 <indiagreen> I have... a point to make.
17:20:34 <crough> I mean, I actually hate `def` as a typeclass... I don't really understand the point of it.
17:20:41 <crough> So I'm really interested in the point
17:20:53 <awpr> indiagreen: let's go with [0] just for kicks
17:21:09 <awpr> since the instance is probably "Default a => Default [a]"
17:21:18 <awpr> or, could be that
17:21:57 <crough> awpr: The other instance, I would guess, is just `Default [a]`, because if it's `[]` that means that it's valid for all types.
17:22:26 <crough> for parity, I think the instance for Maybe is just def = Nothing
17:23:59 <awpr> crough: sure, that's what I'd actually expect, but repeating an answer that's already been said is boring
17:24:35 <crough> ha, absolutely agree... Most of these things tend to be pretty pragmatic... Anyway; what point are you trying to make, indiagreen?
17:26:02 <hardmath123> What's a "boot" script?
17:28:02 <crough> Guess we may never know... :)
17:30:21 <Gurkenglas> indiagreen, if it was [] you wouldn't be asking us, so probably [0]?
17:31:14 <indiagreen> crough: my points are several, actually. The biggest is “if you assume that all code you're relying on was designed by either aliens or actively malicious people, perhaps that's great in some cases and (who knows) perhaps you're even right, but *I* assume that code I'm relying on was written by human beings who think quite often in ways close to mine, and I'd like to enjoy the benefits of that”. Whether the benefits of that include being able to
17:31:14 <indiagreen> save some keystrokes using Default, I'm not yet certain.
17:31:28 <indiagreen> Gurkenglas: it's [].
17:31:57 <Gurkenglas> Welp. Were you playing on lvl 0 or 2?
17:32:33 <crough> Wait, then what would you expect `indiagreen`? I wasn't attacking, I'm just curious to what your problem with the implementation is...
17:32:42 <indiagreen> Gurkenglas: 0 (wasn't trying to trick anybody)
17:33:04 <crough> indiagreen: did you expect [0]?
17:33:11 <benzrf> foo :: Default a => ... is the same as foo :: a -> ...
17:33:14 <benzrf> tbqh
17:33:16 * hackagebot unique 0 - Fully concurrent unique identifiers  https://hackage.haskell.org/package/unique-0 (EdwardKmett)
17:33:29 <indiagreen> crough: I would expect [], and I have yet to meet a person who would expect otherwise. I decided to ask here just to find out whether I might be deadly wrong.
17:33:30 <Gurkenglas> I guess he expected [] and got it and his point is that sometimes you can trust people to be trustworthy?
17:33:48 <crough> Oh okay :)
17:33:55 <crough> Gurkenglas: At least the Haskell community, I guess
17:34:16 <awpr> the real lesson here is that you can't trust people to answer polls sanely
17:34:55 <Gurkenglas> The answer was boring, though. Shame on you for posing that poll!
17:35:35 <indiagreen> Gurkenglas: not even “trustworthy”, just not “random agents with indecipherable means”. For instance, some people like to claim that if a typeclass exports one function called “apply” and the typeclass doesn't have any associated laws, it's the same as if the function was called “dowhatever”.
17:35:42 <crough> I think a good parallel to this is `Maybe [Int]`... fmap only affects the Maybe and it doesn't go inside to the [] becuase typeclasses are *usually* parameterized as little as possible
17:35:44 <indiagreen> I vehemently disagree with that position.
17:36:45 <Gurkenglas> Hmmyes typeclasses without laws are bad but people shouldn't be making that kind of argument for why that is so
17:38:55 <hardmath123> I'm trying to compile something that uses Parsec with Haste, but it keeps saying it couldn't find the module (I installed it with haste-cabal install parsec).
17:43:04 <deech> Hi all, is there a way to configure a cabal file to conditionally compile based on the version of a package? Doing `if impl(base >= ...)` didn't work for me. 
17:47:03 <geekosaur> I think you have to do something like have flag blocks with the various dependencies in them and then test the flag?
17:48:03 <geekosaur> if you look at ancient versions of packages, you can find a "flag small-base" which was used that way
17:52:35 <deech> geekosaur: Ah, thanks.
17:53:42 <tabemann> dammit are there any good Haskell editors? haskell-mode breaks when fed trivial code... and yi feels overly minimal and spare and also does not format my code properly
18:03:17 * hackagebot morte 1.3.1 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.3.1 (GabrielGonzalez)
18:09:09 <davidar> Yay, morte, is Gabriel around here?
18:16:00 <hiptobecubic_> It's cloudy :(
18:27:17 <fread2281> what's the advantage of reflection over withDict :: C a -> (C a => r) -> r  ?
18:28:07 <arkeet> they're kind of opposite things
18:28:22 <fread2281> where C a at the value level is a record or so
18:28:23 <arkeet> withDict lets you explicitly pass a class dictionary
18:29:07 <arkeet> reflection exploits the typeclass mechanism to implicitly pass values around
18:29:10 <fread2281> arkeet, so does reflection, but without breaking global instance coherence
18:29:35 <fread2281> I mean, you can use reflection to do so
18:30:41 <kristof> How do I make non exhaustive patterns a compiler error?
18:30:59 <slack1256> -Werror
18:31:17 <kristof> That turns ALL warnings into errors, doesn't it?
18:31:40 <slack1256> there is also a specific option on the man page, i don't remember which it was
18:32:12 <slack1256> kristof: yeah, cool right? :-)
18:34:25 <fread2281> is there a good writeup on inplicit arguments vs typeclasses somewhere?
18:34:25 <fread2281> *implicit
18:36:09 <slack1256> fread2281: I think (somebody correct me) that is how scala does typeclasses, with implicits
18:36:18 <fread2281> or rather why coherence is important?
18:36:19 <slack1256> you could check their opinions on the matter
18:36:59 <fread2281> slack1256, yes
18:39:40 <kristof> fread2281: Why does the dictionary have to be implicit? Why can't users just pass the interface explicitly?
18:40:08 <kristof> If you're looking to free yourself from typeclasses, I mean.
18:40:18 <fread2281> kristof, it doesn't, but that defeats the point of typeclasses/implicits :)
18:40:37 <fread2281> imagine having to pass a dictionary every time you wanted to use +
18:43:30 <Pamelloes> Can someone give me an example using the lens function (~.)?
18:45:19 <levi> > (1, 2, 3) & _1 .~ "Foo"
18:45:21 <lambdabot>  ("Foo",2,3)
18:45:41 <levi> I guess that's not (~.), though... is there a (~.)?
18:45:45 <Pamelloes> Oh, I see! I was forgetting the & :)
18:46:03 <Pamelloes> I meant .~
18:46:10 <levi> OK, good. :)
18:46:13 <edwardk> you mean (.~)?
18:50:54 <kristof> fread2281: That's true, but a mix of the two is admissible.
18:51:49 <kristof> fread2281: If you want my opinion on the matter, implicit arguments go against the spirit of functional programming.
18:59:02 <radens> Does Debug.trace.trace print to a log file?
19:00:02 <Axman6> no, stdout
19:00:09 <Axman6> uh, std error perhaps
19:21:14 <erikd> any alex lexer experts here? have a problem : https://github.com/erikd/language-javascript/issues/44
19:24:37 <glguy> To parse properly nested things in Alex you'll need to make a custom state that tracks how deep in nested square brackets you are
19:25:27 <glguy> like you would for nested comments
19:25:31 * geekosaur reminded why he switched to writing lexers by hand
19:26:18 <nolraiU> hm.
19:26:39 <erikd> glguy: thanks. any examples you could point me at?
19:26:40 <glguy> erikd: Have you done states like that in alex before?
19:26:41 <glguy> sure
19:26:42 <glguy> https://github.com/glguy/config-value/tree/master/src/Config
19:26:53 <glguy> LexerUtils and Lexer
19:26:55 <erikd> glguy: awesome. thanks.
19:27:12 <glguy> I don't actually have a nested state there, but you can imagine adding a depth Int to the comment state
19:27:25 <glguy> I get programing on windows with F#, C#, MSVC++, Visual Basic, .Bat files
19:27:28 <glguy> hmm
19:27:33 <glguy> daughter scrolled mmouse wheel
19:27:39 <erikd> :-)
19:27:50 <glguy> and then when you see a ] you'll modechange down one
19:28:26 <glguy> In the code you'll see that I put all the stuff I could in LExerUtils that alex didn't need access to so that it's pages of warnings wouldn't cover up my hand written code
19:28:36 <glguy> but it's morally all one module
19:28:59 <erikd> glguy: thanks, will check it out
19:31:24 <erikd> geekosaur: do you have a hand written lexer you've written that you could point me at?
19:31:50 <geekosaur> not in haskell, no. haven't had to write any lexers in, umm, too many years
19:32:00 <erikd> ok, thanks
19:32:07 <geekosaur> mostly in C, where I gave up on "lex" early (flex didn't exist yet)
19:32:42 <erikd> wow, that is long ago. i rememeber using flex in the mid 1990s
19:34:24 <Pamelloes> Is there a way to make a Bytestring lowercase?
19:34:51 <geekosaur> I'm tempted to say there shouldn't be
19:35:02 <pacak> Pamelloes: use Text
19:35:06 <glguy> depends on the encoding
19:35:18 <erikd> Pamelloes: there is Data.Text.Lazy toLower :: Text -> Text
19:35:27 <erikd> also a strict version
19:35:28 <Gurkenglas> I installed atom and haskell-ide (and some baggage). I opened a .hs file, how do I use it as more than notepad?
19:35:45 <Pamelloes> mm
19:35:59 <pacak> Gurkenglas: Which command did you used? It should look like something "vim file.hs"
19:36:00 <Pamelloes> What about String?
19:36:08 <Pamelloes> do I just fmap toLower from Char?
19:36:09 <pacak> Pamelloes: map toLower
19:36:24 <Pamelloes> Ok :)
19:36:46 <nolraiU> Pamelloes: wont work on certain languages though.
19:36:46 <geekosaur> pacak, atom.io not vim
19:37:12 <Gurkenglas> pacak, I used no command. I am on Windows. I downloaded the atom installer, ran it, used the atom gui to install autocomplete haskell-ide and that backend, and told it the path to a sandbox with ghc-mod in it
19:37:13 <pacak> geekosaur: "more  than notepad" == "vim".
19:37:16 * geekosaur installed cvim, left it in the configurator for 2 days and it went all nonresponsive. wake me up when it's ready for prime time
19:37:17 <pacak> Or emacs
19:37:40 <geekosaur> sigh, ok, not actually being helpful then
19:37:47 <geekosaur> errr
19:37:53 <Pamelloes> nolraiU: Won't be an issue in this case, but thanks for the heads up.
19:37:58 <geekosaur> s/installed cvim/installed atom/
19:38:24 <geekosaur> if it can't handle being left open all the time it's not for serious use
19:39:17 <Gurkenglas> I tried vim/emacs, was scared away by the controls.
19:39:36 <geekosaur> sublime text+sublime haskell, then?
19:40:07 <Gurkenglas> I have that installed too, it doesn't find ghc-mod and I can't get the add-to-path setting to work
19:40:23 <Gurkenglas> If you can get that to work, works for me
19:40:57 * geekosaur hasn't tried; old-tyme emacs-er
19:41:19 <Gurkenglas> Hmm. There's probably a version of emacs with sane controls somewhere?
19:42:13 <Gurkenglas> Although that might be hard to get to work with any addon that doesn't support it I guess
19:45:41 <Gurkenglas> Oh hey, I just needed to install an atom package called language-haskell.
19:47:06 <nolraiU> I had to use vim for work, so I am a vim boy now.
19:52:26 <nitrix> Gurkenglas: Evil-emacs apparently.
20:00:31 <M-davidar> is it possible to redefine the guard function that monad comprehensions desugar into?
20:03:55 <M-davidar> i've tried hiding Prelude.guard and defining my own, but it still complains about type mismatch
20:05:14 <roconnor> M-davidar: There is some sort of "rebindable syntax" option somewhere
20:05:34 <roconnor> I forget the details
20:07:16 <M-davidar> roconnor (IRC): thanks, that looks promising, I'll give it a go
20:17:29 <M-davidar> roconnor (IRC): hmm, apparently it doesn't work with comprehensions (and is also making my program hang for some reason)
20:42:35 <nitrix> If I understand Weak-head normal form, foldr' isn't possible, right?
20:53:53 <shane_> Are restricted (constrained?) monads impossible in Haskell owing to a fault in the way monad libraries were defined in the first place or because of a weakness in typeclasses?
20:54:41 <Welkin> what is a restricted monad?
21:00:00 <shane_> We are forced to instantiate monads m a where a can be of _any_ type. But sometimes monads are formed for types belonging to certain typeclasses
21:00:57 <Welkin> oh
21:00:59 <shane_> This can be especially useful if the bind operation uses a polymorphic function which is defined for a particular typeclass
21:01:16 <Welkin> you mean like how Functor is a superclass of Monad
21:01:37 <Welkin> class Functor m => Monad m a where ...
21:01:44 <shane_> Welkin: not really, but take this example.
21:02:05 <shane_> There is a probability monad defined in the probability package
21:02:39 <shane_> now one would like to define this monad Distribution a not for all a but only for a belonging to the Ord class
21:03:08 <shane_> because then the bind can be defined in such a way that it normalizes the distribution too and thereby making it a lot more efficient
21:03:42 <shane_> the normalization function which will be used to define the bind, needs an ordering to be defined on a 
21:04:30 <geekosaur> there are various ways to define indexed monads, but they're more complex than the existing definition
21:04:44 <geekosaur> you can find various indexed monad packages on hackage
21:05:00 * hodapp jots down something on his to-do list about learning WTF an indexed monad is
21:05:16 <geekosaur> Welkin, the canonical example is that you can't have a Monad instance for Set because Set requires an Ord instance
21:05:47 * geekosaur not an expert on this by any stretch but was reading about them recently...
21:06:10 <Welkin> https://stackoverflow.com/questions/28690448/what-is-indexed-monad
21:06:10 <Welkin> :D
21:06:36 <shane_> geeokosaur: is this shortcoming in being unable to define restricted monads, owing to the way monads were defined or is it because of typeclasses....to give an example, if I were to do this using ML style modules, it seems the natural definition places no such restriction
21:06:52 <geekosaur> indexed monads are defined using typeclasses
21:07:12 <shane_> geekosaur: but if I understood you correctly the definition is a lot more complex
21:07:23 <geekosaur> it's still a typeclass
21:08:08 <shane_> geekosaur: what I mean is that in the ML module system, there is no added complexity needed, it seems...perhaps because in Haskell there is that implicit forall when defining the class..
21:08:47 <geekosaur> the Haskell standard definition of Monad is not able to handle it. there are alternative definitions which can; they require more machinery, because the standard one assumes that it can just use join to combine stuff and that's where an e.g. Ord instance would be lost
21:09:04 <Welkin> shane_: you can use an explicit forall
21:09:12 <Welkin> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#Monad
21:09:16 <Welkin> this is how Monad is defined
21:09:41 <Welkin> (>>=) :: forall a b. ma -> (a -> m b) -> m b
21:10:03 <geekosaur> shane_, I am mnot sure I believe that ML doesn't actually need additional stuff. it may hide the additional machinery behind a parameterised module, but in that case it still has the additional machinery to maintain additional constraints through join
21:10:05 <Welkin> you could put constraints on each member of the typeclass
21:11:34 <geekosaur> which I suspect is what you actually mean; the existing Monad typeclass can't carry additional constraints, a parameterised module could parameterise the Monad definition with the additional constraints
21:11:55 <geekosaur> I *think* the indexed monad direction is even more general than that, though
21:12:10 <geekosaur> you don't parameterise Monad, you are using a more general construct to start out with
21:12:42 <bitemyapp> I need help finding more formal language for characterizing something.
21:12:44 <geekosaur> (in effect creating a different Monad instance for each constraint, with the ML way; you can build them "on the fly" and combine them with the indexed monad machinery)
21:13:10 <bitemyapp> data Count a = Count Int a    is a Functor, Applicative, but not a Monad (right identity, defaulting the value isn't kosher)
21:13:25 <shane_> Welkin, geekosaur: i will look at indexed monad...why was that forall explicitly put before the bind function?
21:13:35 <bitemyapp> only characterization that I thought _might_ be related is representable functors but I'm not sure it fits.
21:14:06 <geekosaur> Welkin, note that your forall-ed (>>=) is the same as the normal one; all type variables are implicitly forall-ed at top level
21:14:23 <geekosaur> (which is why ScopedTypeVars can steal the explicit top level forall for its own use)
21:14:30 <crough> bitemyapp: isn't this actually related to semigroups somehow?
21:15:03 <shane_> geekosaur: is their anyway to over-ride the forall with something equivalent to "forany"?
21:15:09 <crough> bitemyapp: If the value in "Int" is a semigroup you get a functor and applicative; if it's a monoid you get a full monad because you can default it (??)
21:15:14 <crough> bitemyapp: talking well out of my ass
21:15:33 <bitemyapp> crough: no, that'd be Applicative
21:15:45 <bitemyapp> crough: Applicative needs "monoid of structure"
21:15:52 <geekosaur> shane_, forall / exists has the same relationship as and / or, you can use de Morgan's rule which gives you forall-ed things in inner scopes
21:15:59 <bitemyapp> crough: we have that here, we can just sum the int and make pure default to identtiy of summation (0)
21:16:08 <bitemyapp> crough: the problem is pure overriding the value on right identitt
21:16:10 <bitemyapp> identity
21:16:16 <geekosaur> however that leads into the morass of impredicative types, which ghc has never handled well
21:16:33 <bitemyapp> Count (-2) "lol" >>= return    ->    Count 0 "lol      <-- not kosher.
21:16:48 <bitemyapp> and not because the Monoid is invalid - it is. It has an identity and a mappend operation that behaves properly.
21:16:53 <bitemyapp> it is valid, that is.
21:17:09 <bitemyapp> crough: good thinking, but that it isn't about the monoid is why I'm having a hard time with this.
21:17:19 <crough> so the problem is that for `x <*> y`, x's value is being dropped?
21:17:25 <crough> If y is made from `pure`?
21:17:27 <bitemyapp> no, the Applicative is fine.
21:17:39 <bitemyapp> the only law broken is Monadic right identity
21:17:45 <crough> Oh, just the monad is fucky...
21:17:49 <bitemyapp> Yes.
21:17:55 <bitemyapp> It's a valid Functor and Applicative
21:18:02 <bitemyapp> the pure is a proper identity for the monoid of Applicative
21:18:05 <bitemyapp> it's fine there
21:18:09 <bitemyapp> but it "overrides" the value in the Monad
21:18:16 <bitemyapp> and I want the language for characterizing/talking about that.
21:18:18 <bitemyapp> paf31: any ideas?
21:18:27 <crough> Forgetful bind?
21:18:39 <crough> I see "forgetful" in this context a lot
21:18:50 <crough> i.e. the forgetful functors and comonads
21:19:17 <bitemyapp> crough: sounds promising. I'll poke around. I'd forgotten about forgetful *
21:19:30 <crough> bitemyapp: describing stuff is *haaaaarrrrd*
21:30:19 <johnw> bitemyapp: Count (-2) "lol" >>= return    ->    Count 0 "lol
21:30:27 <johnw> bitemyapp: why is your >>= defined this way?
21:31:01 <johnw> I would think you'd use (+) to merge the Int's from the two Counts, which would make the right identity work out
21:31:24 <johnw> or maybe I haven't understood the semantics you intend for Count...
21:31:34 <bitemyapp> johnw: I think you may have just figured it out. h/o
21:31:47 <M-davidar> roconnor (IRC): my mistake, looks like it should work with comprehensions, just need to work out what's causing it to hang now :/
21:32:32 <bitemyapp> johnw: sigh, fuck, that was it.
21:32:34 <bitemyapp> johnw: thank you.
21:32:36 <johnw> :)
21:33:09 <bitemyapp> johnw: there's a relief. Thank you: https://twitter.com/bitemyapp/status/648354598038601728
21:37:05 <wavewave> hi.
21:37:41 <luite> hello
21:37:44 <wavewave> nix-build-ghc-android now support cabal packages from hackage pretty well.
21:37:48 <wavewave> luite: hi!
21:38:09 <shachaf> wavewave: havehave
21:38:10 <wavewave> now I am building pandoc on android.
21:38:19 <wavewave> shachaf: hihi
21:38:40 <wavewave> luite: I think this all became possible thanks to ghcjs.
21:39:04 <luite> oh did it?
21:39:15 <luite> i mean of course it did!
21:39:21 <wavewave> That ghc and cabal work very well with ghcjs made ghc cross compiler on android too. 
21:39:25 <luite> :)
21:40:11 <wavewave> pretty surprising that everything can be well controlled by cabal flags and configure flags for ghc.
21:41:39 <wavewave> now if someone lands out-of-process-template-haskell on mainline binary ghc well.. then cross compiling game is over. :-)
21:41:51 <luite> yup
21:42:14 <wavewave> luite: does anyone work on this now/
21:42:15 <wavewave> ?
21:42:24 <luite> not as far as i know
21:42:48 <wavewave> luite: ok. 
21:42:56 <luite> and i didn't get much done today anyway, bus ride too bumpy :/
21:43:17 <wavewave> luite: where may I look at for start?
21:43:41 <luite> angerman did something, i'm not sure if he actually got code done
21:43:50 <wavewave> i see.
21:43:53 <luite> but you can override what runs TH by setting the runMeta hook in Hooks
21:44:06 <wavewave> runMeta.. ok.
21:45:08 <luite> that gets you the Core and you just have to run it, return some AST that GHC understands :)
21:45:41 <luite> it's that and the implementation of the Quasi monad
21:47:40 <wavewave> looking for that part now.. 
21:48:02 <luite> see the GHCJS implementation for an example of how to do it remotely
21:48:24 <wavewave> luite: is it in github.com/ghcjs/ghcjs ?
21:48:45 <luite> https://github.com/ghcjs/ghcjs/blob/master/lib/ghcjs-prim/GHCJS/Prim/TH/Eval.hs here it is
21:48:55 <wavewave> thanks!
21:49:04 <luite> instance TH.Quasi GHCJSQ where -- this :)
21:50:24 <luite> wavewave: i'll be a tad busy next week, flying to NL, then UK for a talk, but after Oct 10 or so I should be able to help more
21:50:35 <luite> especially if you come to the London hackathon :)
21:50:46 <wavewave> luite: sure. thanks. 
21:50:58 <wavewave> luite: unfortunately I can't. now I am in SF.
21:51:29 <wavewave> luite: but try to connect during London Hackathon time.
21:53:03 <luite> wavewave: well that's no excuse, I'm in Vancouver, Seattle tomorrow, so that's about as far from London as you ;)
21:53:54 <wavewave> luite: yeah. actual excuse is that now I need to save some money. ;-P
21:54:47 <wavewave> luite: will travel more next year..
21:55:46 <luite> to ICFP?
21:56:18 <luite> people keep telling me that Nara is a good place to go :)
21:56:44 <wavewave> luite: oh.. next year is in Japan. cool 
21:57:29 <luite> wavewave: yep I hope I can go :)
21:58:15 <wavewave> luite: found angerman's work on github: https://github.com/angerman/oopth
22:00:14 <wavewave> my pandoc build on android stopped due to lack of lua C library.
22:00:37 <wavewave> but it went quite far. cool
22:06:36 <Job314> Hi - I'm getting a weird compile error where haskell likes two statements separately, but hates them together: http://pastebin.com/wzFcrPrK
22:06:43 <Job314> any advice?
22:06:55 <shachaf> Add type signatures.
22:07:29 <Job314> I plan to, but can that fix the error?
22:07:38 <shachaf> That's not it in this case, actually.
22:07:45 <shachaf> Use parentheses instead of $
22:07:55 <wavewave> Job314: operator precedence. 
22:08:55 <wavewave> what you want is sum . (map (ord . toLower)) but  it is now (sum . map) (ord . toLower) 
22:09:01 <glguy> People would probably use parentheses more if we started calling them operators...
22:10:43 <Job314> it works
22:10:50 <Job314> why it works will take some thinking
22:10:57 <Job314> thanks
22:13:26 <Job314> I see. Ord to lower is being applied. then the composition jumps in. and tries to sum map and something. You can't sum map and something, so the whole thing goes to hell
22:34:09 <hunteriam> Can anyone help me with a group theory question in haskell-blah?
23:02:51 <kristof> Question about data kinds.
23:03:05 <kristof> data Maybe a = Some a | Nothing
23:03:21 <kristof> Does that mean I can make Nothing an instance of some class over kind *?
23:03:59 <johnw> Nothing becomes a type of kind Maybe a, whose only inhabitant is a singleton called 'Nothing
23:04:20 <johnw> or maybe the type is 'Nothing, and the singelton is unnamed, not sure
23:04:46 <glguy> I think that it's more likely that the answer is "no" than that you're doing something with -XDataKinds
23:05:53 <johnw> the use of the words class and instance really throw me in that question too
23:06:43 <glguy> kristof: Can you ask your question a different way?
23:07:31 <kristof> glguy: class c where ... -- Assume c has kind *
23:07:42 <kristof> oh, sorry.
23:07:53 <kristof> class C c where ...
23:08:19 <kristof> Now, is instance C Nothing where ... a valid instance?
23:08:22 <glguy> No
23:08:26 <johnw> no
23:08:29 <glguy> Nothing is a data constructor, it makes values
23:08:42 <kristof> I meant with datakinds.
23:08:43 <glguy> Maybe is the type constructor, it makes types and you make instances on types
23:08:46 <johnw> even lifted Nothing does not have kind *
23:08:59 <glguy> With DataKinds the lifted Nothing would have kind Maybe _
23:09:48 <kristof> Oh, I understand, now.
23:09:52 <kristof> Maybe _ is the kind.
23:23:30 * hackagebot quiver 1.0.2 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-1.0.2 (patrykz)
23:27:47 <bollu> how does one learn lens?
23:27:51 <bollu> I can use over and stuff
23:27:58 <bollu> but I don't understand any of the machinery
23:28:11 <bollu> whoops, sorry, I thought this was #haskell
23:28:21 <bollu> oh, this is #haskell :)
23:29:11 <kristof> I'm reading through the tutorial on Servant, and I have to say
23:29:24 <kristof> I feel like this is type level lambdas plus compiler magic ._.
23:30:01 <kristof> Just describing the type of your service and then letting the structure of the types admit a natural function definition. Crazy stuff, here.
23:32:44 <bitemyapp> kristof: it's nice.
23:34:39 <kristof> bitemyapp: It would be interesting to see this style of programming (type reification) be put to good use in other domains.
23:38:43 <tekkkz> Hello! I'm at cis194 tutorial, week 2, homework. They want me to make as first step a function parseMessage :: String -> LogMessage ... but how to do this function? i have no idea how to parse a string to a data field, and i read the lesson again and again, i didnt got it. can someone help me pls?
23:39:52 <johnw> kristof: types define a set of implementations (values); the more information the types convey re: your problem, the more meaningfully relevant the values become
23:41:26 <bollu> guys: pipes versus conduit, which one do I learn? :)
23:41:50 <johnw> bollu: what do you want to do with them?
23:42:08 <johnw> I'd suggest learning pipes
23:42:21 <johnw> in the end, they are more similar than they are dissimilar, so learning either one will serve you
23:42:45 <bollu> johnw: I'm writing a compiler, and readlines is too simple for my taste :P
23:42:51 <johnw> use pipes
23:43:03 <bollu> cool :)
23:43:05 <bollu> thanks
23:43:11 <johnw> pipes is the end product of wondering what happens when you turn the State monad into a DSL :)
23:43:44 <pavonia> tekkkz: What is this lesson about?
23:44:26 <johnw> tekkkz: it sounds like you will simply be calling a data constructor, using the input string as an argument to that constructor
23:44:56 <tekkkz> what? i have no clue what you are talking there :D
23:45:17 <shane_> Why does the Haskell typeclass forbid me from defining constraints in the instance? If I wish to instantiate a monad m a only for a belonging to a certain class, I know that it is impossible owing to the implicit forall in the bind....but why was bind chosen with this restriction?
23:45:27 <johnw> LogMessage is a type, and that type will be defined in terms of one or more data constructors
23:45:27 <shane_> and why can I not override it?
23:45:45 <tekkkz> johnw, yes. and now?
23:46:07 <johnw> tekkkz: those data constructors are functions; I'm guessing the one you want expects a String
23:46:09 <kristof> shane_: This is the "Set over ordered elements can't be a Functor" problem.
23:46:11 <johnw> shane_: can you show code?
23:46:42 <tekkkz> parseMessage "I 29 la la la"
23:46:42 <tekkkz> == LogMessage Info 29 "la la la"
23:46:47 <tekkkz> i need to reach this
23:46:57 <johnw> ahh, I see
23:47:02 <johnw> you're expecting to parse the string
23:47:18 <tekkkz> yap
23:47:19 <shane_> johnw: exactly what kristof is talking about...or to give another example which involves what I asked you about the other day, I cannot involve the normalization function when defining >>= for a probability distribution monad in order to make it more efficient
23:47:23 <shane_> I have to manually do it
23:47:24 <johnw> I'm not sure how the class expects you to do this
23:47:25 <tekkkz> and i have no diea how i should do this
23:47:33 <tekkkz> can you have a look pls?
23:48:06 <johnw> shane_: it sounds like you want a restricted monad
23:48:34 <johnw> which is a monad that is additionally parameterized on some provided constraitn
23:48:37 <kristof> shane_: Let's say you want to make a Functor instance for Set. Then when you go to write fmap, you have to make it generic over all types. But you cannot write fmap for it unless you had only Ord a. So you need to constrain fmap. But fmap's type signature is set, so what you really want is a way to pass in a constraint and let the instance figure things out.
23:48:49 <kristof> shane_: this is the "restricted monad" johnw is talking about.
23:49:13 <johnw> they are not hard at all to make, they just aren't "standard"
23:49:25 <johnw> however, there are ways to make them easy to use, i.e., RebindableSyntax
23:49:34 <johnw> but the question is, do you really need to go that route?
23:49:52 <shane_> johnw: but will a restricted monad also allow me to impose no restrictions in case I need to use an ordinary monad like I want to instantiate list of all a's?
23:50:26 <johnw> that would be a constraint satisfiable by any type... I wonder if there is already such a thing...
23:50:51 <johnw> probably Typeable, in 7.10
23:51:28 <johnw> but even still, I feel like this is an XY problem
23:51:36 <shane_> johnw: in my particular case, I did not need it, and I managed to work around it by carrying the normalize function with the Distribution data type...it might be dirty, but it worked
23:51:37 <johnw> that is, you're trying to solve something in a specific way
23:51:41 <johnw> which may not be necessary at all
23:52:01 <johnw> shane_: you could always use Codensity
23:52:15 <johnw> that will "collect" all >>= operations until the very end, and then you can apply your normalization there
23:52:20 <rhovland> tekkz: the "words" function will break a string into a list of strings
23:52:30 <shane_> johnw: will that not be inefficient?
23:52:42 <johnw> it won't perform the >>=
23:52:57 <johnw> well, it could be inefficient, it depends
23:53:24 <johnw> if the arguments to >>= holds lots of objects resident, it could be space inefficient
23:54:04 <johnw> but otherwise, Codensity is often used to speed up some monadic compositions
23:54:17 <kamatsu> if i am using doctests, how can i easily state what type I want the property variables to be, without polluting the documentation too much?
23:54:22 <Hijiri> is there a unit constraint
23:54:25 <Hijiri> like ()
23:54:34 <Hijiri> maybe in constraints package
23:54:39 <johnw> kamatsu: you could define the variable first at a specific type, then use it in the examples
23:54:52 <shane_> johnw: for instance, when one uses monads in ML/Ocaml using the module system, there is no restriction on the type a' in a' monad and one can use functors to implement bind if it uses only types that are ordered...I was wondering if Haskell has a solution that is as straightforward
23:54:57 <kamatsu> but these are arbitrary variables, from quickcheck properties
23:55:31 <johnw> shane_: yeah, we don't have that sort of generality
23:55:36 <johnw> shane_: the type of >>= is fixed
23:56:17 <Hijiri> maybe top
23:56:23 <johnw> I am certain there are other, better, ways to achieve efficient normalization the way that you need it, though
23:57:08 <johnw> you could newtype the probability monad's type, so that its >>= simply normalizes at each step, for example
23:57:19 <johnw> the way we with that fold
23:57:26 <johnw> we did*
23:58:21 <shane_> johnw: in the probability distribution case, I defined the distribution datatype to also carry a normalization function like Dis ([(a, Float)] -> [(a, Float)]) [(a,Float)]...and then defined my won data constructor which would take a list of pairs and make that into a Distribution by adding the canonical normalization function...is that what you are talking about? Is there a similar approach for sets?
23:58:50 <johnw> maybe , I'm not entirely clear
23:59:02 <shane_> so fromFreqs x = Dis norm x is the data constructor
23:59:04 <johnw> but this notion of "carrying a mutating function along with the data" has many analogs
23:59:48 <johnw> so, the newtype idea just makes this implicit over >>=
