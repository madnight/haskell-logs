00:02:11 <nitrix> https://github.com/nitrix/bfi/blob/master/src/Main.hs
00:02:19 <nitrix> Is there a better way to write this checkSyntax function?
00:05:06 <tempname11> I've just had a problem where GHC (7.10.1) gave me a "Not in scope" error for values that were defined in the top-level. What fixed it, was moving the definitions of those values _before_ their usage. And that perplexes me, because I thought the order of definitions was not important. Can anyone explain why this could happen?
00:05:37 <mniip> nitrix, recursive parsers
00:05:37 <jle`> nitrix: i'd probably do rankLoopInstr x i = case i of ..., but that's stylistic
00:06:02 <nitrix> jle`: I agree and I think I'll do that.
00:06:23 <jle`> nitrix: also boolean blindness is real; try returning the Int instead if it's meaningful
00:06:51 <ttt_fff> https://gist.github.com/anonymous/eaaf5b084b8e0ac9ddc1
00:07:09 <nitrix> jle`: The idea is merely counting [ and ] of a brainfuck program to make sure those are balanced.
00:07:38 * hackagebot hpc-coveralls 1.0.1 - Coveralls.io support for Haskell.  https://hackage.haskell.org/package/hpc-coveralls-1.0.1 (killy971)
00:07:38 * hackagebot woot 0.0.0.1 - Real time group editor without operational transform.  https://hackage.haskell.org/package/woot-0.0.0.1 (tgolson)
00:07:44 <nitrix> I'm totally fine with the output being a Bool, wether or not it passes syntax checks.
00:08:29 <Cale> tempname11: Are there Template Haskell splices?
00:08:37 <tempname11> Cale: yep
00:08:52 <jle`> mhm.  it's just that seeing a function return a Bool is often a red flag that you might usually be able to have it return something more meaningful
00:08:53 <Cale> tempname11: Template Haskell splices divide the compilation of the module into parts
00:09:15 <tempname11> Cale: oh, that explains it.
00:09:18 <jle`> instead of "squashing" the return space into two values.  but if you think about it and you know you'll never need the extra info, that's fine
00:09:31 <tempname11> thanks
00:09:36 <Cale> no problem
00:12:31 * hackagebot woot 0.0.0.2 - Real time group editor without operational transform.  https://hackage.haskell.org/package/woot-0.0.0.2 (tgolson)
00:22:56 <the_2nd> lookText converts String to mText
00:22:59 <the_2nd> http://hackage.haskell.org/package/happstack-server-6.5.6/docs/Happstack-Server-RqData.html
00:23:34 <the_2nd> http://pastebin.com/VaDxLpDt
00:23:43 <the_2nd> I dont understand, where the data is stored
00:23:48 <the_2nd> or referenced
00:23:55 <the_2nd> since "a" is only my search
00:24:09 <the_2nd> also, how would I just write the post data e.g. to file?
00:24:33 <the_2nd> without extracting parameter by parameter
00:24:53 <the_2nd> or write greeting to the console / a file
00:25:10 <lpaste_> mniip pasted ‚Äúbf‚Äù at http://lpaste.net/140306
00:25:13 <mniip> nitrix
00:32:07 <the_2nd> anyone?
00:35:42 <indiagreen> the_2nd: I'm seeing this library for the 1st time, but it looks like when you're in the server monad, you can use askRq to get the request out
00:35:59 <indiagreen> and then you can do stuff from http://hackage.haskell.org/package/happstack-server-7.4.4/docs/Happstack-Server-Internal-Types.html with that request
00:36:09 <indiagreen> including getting body, etc
00:36:19 <rhovland> so.. what stops haskell from being used as a scripting/interpreted language
00:36:38 <dramforever> rhovland: wrong question, haskell can be interpreted
00:36:44 <dramforever> check ghci/runghc
00:36:46 <indiagreen> rhovland: http://hackage.haskell.org/package/turtle
00:37:15 <indiagreen> technically nothing stops it
00:37:31 <dramforever> hmm...mine was an answer to the "interpreted" part, and indiagreen has one on the other part
00:37:49 <indiagreen> in reality, tho... it's just not convenient enough for me (so I can say why *I* don't use Haskell as a scripting language)
00:39:42 <rhovland> well, I'm just thinking like, putting #!ghci first line, then er.. haskell
00:39:57 <Arahael> #!/usr/bin/env ghci
00:40:12 <indiagreen> runhaskell, not ghci
00:40:41 <Arahael> The problem, though, are the libraries.  Cabal sandboxes don't really mix well with scripts, unless you hard-code the sandbox.
00:40:55 <dramforever> problem: #! messes with the haskell parser
00:41:09 <dramforever> you probably have to use lhs
00:41:15 <indiagreen> hm, does it? I thought GHC had this hardcoded
00:41:18 <dramforever> or is it no longer the case now?
00:41:50 * indiagreen checks
00:41:56 <indiagreen> yep, not a problem
00:42:33 * hackagebot woot 0.0.0.3 - Real time group editor without operational transform.  https://hackage.haskell.org/package/woot-0.0.0.3 (tgolson)
00:43:28 <rhovland> I suppose stuff in a script would have to be IO monad
00:44:46 <rhovland> I mean, say #!ghci, putStrLn $ getContents >>= sort  hmmm.. or something
00:45:01 <indiagreen> just do ‚Äúmain = do‚Äù
00:45:08 <indiagreen> and in there, whatever you want
00:46:20 <rhovland> hmm... yeah I guess ghci is an interpreter, and if I put #!ghci at the start of a file, things should work
00:46:36 <jle`> people do use haskell as a scripting/interpreted language
00:46:40 <jle`> nothing stops them
00:46:45 <jle`> :)
00:46:55 <indiagreen> and now why I don't use Haskell as a scripting language: I don't want a hundred imports in my script, I want an ‚Äúif‚Äù that can work with IO Bool instead of Bool, I want global state everywhere, I want variables, I want regexes (or parser combinators that could be used as regexes ‚Äì I'm currently not aware of those), I want all functions to work with Text without having to convert Text to String everywhere, I want better
00:46:56 <indiagreen> names for common things like putStrLn (ugh), I want more utilities in standard library without having to hunt for things like splitting or moving-a-sliding-window-over-the-list or whatever, and with all these complaints there's just no need to use Haskell instead of a more fitting language
00:47:09 <Arahael> indiagreen: The same is the case with python, though.
00:47:17 <rhovland> did you copy/paste that?
00:47:22 <indiagreen> did not
00:47:28 <Arahael> indiagreen: Liar! ;)
00:47:34 * indiagreen rolls eyes
00:47:47 <indiagreen> I just like ranting
00:47:55 <indiagreen> never pass the opportunity
00:47:56 <Arahael> But seriously, python has much of those same issues.
00:48:17 <Arahael> You can't even *exit* prematurely without doing an import, or raising an exception.
00:48:21 <rhovland> the import thing is a problem
00:49:56 <rhovland> I dunno, ruby handles the namespace stuff so much better
00:50:29 <Arahael> Ruby is probalbly better at scripting than even python is.
00:50:48 <rhovland> python doesn't... way too much namespace pollution
00:51:18 <Arahael> what do you mean?
00:52:02 <dramforever> rhovland: "exit built in prelude? why would I want that? my program doesn't even deal with those stuff because it's just a key-value map"
00:54:54 <rhovland> dramforever: what? I said that? you sure?
00:55:15 <Arahael> exit was just an example.
00:55:28 <dramforever> Arahael +1
00:55:35 <Arahael> A common practice in scripts is to check the args, and if invalid, output a helpful message and exit nicely.
00:56:29 <Arahael> Another thing both python and haskell do poorly ,though, is run external subprocesses.
00:57:14 <Arahael> map $ foo . lines . `ls -l`
00:57:17 <rhovland> dramforever: I guess I don't understand then
00:57:17 <Arahael> Or whatever.
00:57:35 <dramforever> screw it, let me explain that
01:01:33 <rhovland> bah, you know, I've written haskell scripts, so I'm not sure what I'm complaining about
01:01:54 * dramforever failed
01:03:45 <mniip> dramforever!
01:04:02 <dramforever> oh yep, I was away for a week
01:04:21 <Arahael> And came baack a failure. ;))
01:04:47 <dramforever> probably because I got a cold and is unable to think as well
01:04:52 <dramforever> as before
01:04:53 <mniip> dramforever, you missed the thing where I invented the algorithm we were looking for
01:04:56 <mniip> and wrote an article
01:04:59 <mniip> and a package
01:05:01 <mniip> and a reddit
01:05:19 <rhovland> a wiki?
01:05:29 <Arahael> I'm also sick, but wow. I umm...  Washed the dishes.
01:06:23 <rhovland> mniip: I think you meant you "discovered" the algorithm
01:06:24 <dramforever> mniip: oh I found the reddit post, reading
01:06:30 <indiagreen> link?
01:07:23 <mniip> rhovland, are you implying that it was known before
01:07:27 <dramforever> https://redd.it/3j9j66
01:09:16 <Hi-Angel> Why does ghci answers ´Infinityª to the ´5 / 0ª, when the type of the expression doesn't imply anything except of a number? Is it just a hack in ghci?
01:09:28 <indiagreen> ‚Äú/‚Äù implies a Fractional
01:09:38 <dramforever> mniip: great =P
01:09:39 <indiagreen> this defaults to Double or Float, don't know which
01:09:44 <jle`> Hi-Angel: ghci chooses default types
01:10:03 <dramforever> Double and Float can represent a value called Infinity
01:10:08 <mniip> Hi-Angel, it's called defaulting
01:10:18 <Hi-Angel> Ah, dramforever, thank you!
01:10:25 <dramforever> =)
01:10:35 <KrzyStar> Defaults to Double :p
01:10:48 <mniip> > let x = 1 in (typeOf x, x)
01:10:50 <lambdabot>  (Integer,1)
01:10:56 <mniip> > let x = 1 / 0 in (typeOf x, x)
01:10:58 <lambdabot>  (Double,Infinity)
01:11:33 <Hi-Angel> Interesting, I didn't know
01:11:41 <Zemyla> > 5 / 0 :: Rational
01:11:42 <lambdabot>  *Exception: Ratio has zero denominator
01:12:08 <mniip> hmm
01:12:25 <rhovland> mniip: yes, of course, algorithms exist, waiting to be discovered
01:12:55 <mniip> > let x = x in Const (typeOf x) <$ x
01:12:57 <lambdabot>      Could not deduce (Typeable a0) arising from a use of ‚ÄòtypeOf‚Äô
01:12:57 <lambdabot>      from the context (Functor f)
01:12:57 <lambdabot>        bound by the inferred type of
01:14:52 <mniip> hmm, too polymorphic
01:15:06 <mniip> oh there
01:15:09 <mniip> > toEnum 0
01:15:10 <lambdabot>  ()
01:16:00 <mniip> () is tried, then Integer, then Double
01:17:25 <julianleviston> Can a filter be expressed as a commutative monoid? (Interested because I‚Äôm interested in writing general computation units for an apache samza-like library called Hailstorm which takes compute units as commutative monoids)‚Ä¶ at first I thought not‚Ä¶ but?
01:19:06 <julianleviston> I know filter can be reexpressed as a fold pretty easily‚Ä¶ but a commutative monoid implies a two-argument function of the same types, doesn‚Äôt it? I guess if you wrote a map to single element arrays, then you could express the filter as a commutative monoid over the same types‚Ä¶?
01:19:58 <dramforever> @check (\f g xs -> (filter f . filter g) xs == (filter g . filter f) xs) :: (Int -> Int) -> (Int -> Int) -> [Int] -> Bool
01:20:00 <lambdabot>  Couldn't match type ‚ÄòInt‚Äô with ‚ÄòBool‚Äô
01:20:00 <lambdabot>  Expected type: Int -> Bool Actual type: Int -> Int In the first argument of ...
01:20:01 <julianleviston> (array = list)
01:20:14 <dramforever> @check (\f g xs -> (filter f . filter g) xs == (filter g . filter f) xs) :: (Int -> Bool) -> (Int -> Bool) -> [Int] -> Bool
01:20:16 <lambdabot>  +++ OK, passed 100 tests.
01:20:37 <rhovland> julianleviston: some simple examples?
01:20:41 <dramforever> julianleviston: I wonder if that makes it a commutative monoid
01:20:45 <julianleviston> dramforever:  nice!
01:20:53 <julianleviston> dramforever:  I assume so? 
01:21:30 <dramforever> julianleviston: maybe prove it before relying on it
01:22:47 <julianleviston> dramforever: yeah, I wonder if the identity element would be []
01:23:01 <dramforever> um...what about this
01:23:32 <dramforever> @check (\f g xs -> (filter f . filter g) xs == (filter (liftA2 (&&) f g)) xs) :: (Int -> Bool) -> (Int -> Bool) -> [Int] -> Bool
01:23:33 <lambdabot>  +++ OK, passed 100 tests.
01:23:54 <dramforever> and filter (const True) is the identity
01:23:58 <dramforever> so that makes it a monoid
01:24:10 <dramforever> and the previous one makes it a commutative monoid
01:24:17 <julianleviston> dramforever: :D
01:24:25 <ed-ilyin-lv> hello
01:24:51 <julianleviston> dramforever: I think it‚Äôll take me some time to fully understand this. :) thank you :)
01:25:01 <rhovland> 'lo
01:25:07 <dramforever> yw
01:25:34 <dramforever> btw I suck at explaining atm, so maybe ask here again if you have questions
01:25:35 <ed-ilyin-lv> why when i compile a programm where putStrLn comes before getLine, compiled programs asks for string before printing the message?
01:25:38 <jzp113> hi guy l'm now
01:26:10 <mniip> ed-ilyin-lv, concrete example?
01:30:03 <ed-ilyin-lv>   putStrLn "–ö–∞–∫ —Ç–µ–±—è –∑–æ–≤—É—Ç?"
01:30:06 <ed-ilyin-lv>   name <- getLine
01:30:08 <ed-ilyin-lv>   putStrLn ("–ü—Ä–∏–≤–µ—Ç " ++ name)
01:30:48 <ed-ilyin-lv> mniip: first message appears after I put the message in
01:31:08 <ed-ilyin-lv> in ghci all looks correct
01:31:24 <mniip> ed-ilyin-lv, could you paste the entire file to lpaste
01:31:26 <mniip> @where lpaste
01:31:27 <lambdabot> http://lpaste.net/
01:31:28 <rhovland> looks ok
01:32:41 <lpaste_> ed-ilyin-lv pasted ‚Äúwrong order‚Äù at http://lpaste.net/140310
01:32:47 <rhovland> although yeah, training people to use lpaste.. hm
01:32:50 <dramforever> looks like an output buffering
01:32:58 <dramforever> issue
01:33:18 <mniip> yeah that's what I thought of
01:33:21 <indiagreen> this is weird because isn't line buffering used by default?
01:33:36 <ed-ilyin-lv> and compile like this: ghc --make first
01:34:06 <mniip> ed-ilyin-lv, works fine over here
01:34:10 <mniip> what's your GHC version
01:35:01 <ed-ilyin-lv> The Glorious Glasgow Haskell Compilation System, version 7.10.2
01:35:11 <ed-ilyin-lv> under windows
01:35:19 <mniip> oh, windows
01:35:22 * mniip bails out
01:35:58 <rhovland> ed: isn't it supposed to ask for string before printing the message?
01:36:06 <indiagreen> ed-ilyin-lv: try to do ‚ÄúhSetBuffering stdout NoBuffering‚Äù just in case
01:36:22 <rhovland> ed: what is wrong with the current behavior?
01:36:56 <ed-ilyin-lv> rhovland: it first asks and then prints. I want the message first
01:37:12 <indiagreen> rhovland: it should print-ask-print, it asks-prints-prints
01:38:18 <ed-ilyin-lv> indiagreen:  NoBuffering helped
01:38:27 <indiagreen> ed-ilyin-lv: now try it with LineBuffering
01:38:31 <ed-ilyin-lv> indiagreen: thank you
01:38:56 <indiagreen> try it with LineBuffering anyway if you have time
01:39:28 <ed-ilyin-lv> indiagreen: with LineBuffering works too
01:39:30 <rhovland> ed: I guess maybe you could put seq or something to force the eval order?
01:39:51 <indiagreen> okay, then it should be LineBuffering and I wonder why isn't it LineBuffering by default but whatever
01:39:53 <rhovland> ed: I'd think it'd already be forced.. hm
01:40:25 <ed-ilyin-lv> thank you all
01:40:39 <ed-ilyin-lv> left to understand why this all
01:45:00 <rhovland> ed-ilyin-lv: why understand this all left?
01:47:29 <ed-ilyin-lv> rhovland: this is what is left for me in this particular case - it is understand what happens
01:48:16 <mniip> ed-ilyin-lv, IO on windows is a bunch of wibbley wobbley timey wimey stuff
01:48:34 <ed-ilyin-lv> :)
01:50:39 <ed-ilyin-lv> yeah, i see. now when i try tu run this my exe in the cmd i got wheird symbols instead of test: "√∞√ú√∞‚ñë√∞‚ïë √ê√©√∞√Å√∞‚ñí√ê√Ö √∞√Ä√∞¬•√∞‚ñì√ê√¢√ê√©?"
01:50:45 <ed-ilyin-lv> *text
01:51:04 <rhovland> ed-ilyin-lv: it can happen
01:53:06 <Phyx-> "a bunch of wibbley wobbley timey wimey stuff"
01:53:29 <mniip> ed-ilyin-lv, did you select the 866 codepage in autoexec.bat?
01:53:34 <mniip> (just kidding)
01:54:10 <mniip> am I actually kidding though...
01:54:23 <mniip> those box symbols and accented letters look like CP437
01:54:34 <ed-ilyin-lv> :)
01:55:08 <rhovland> last time I googled an emoticon it lead me to rat soup
01:55:51 <ed-ilyin-lv> running my exe in the emacs's eshell - looks good
01:56:28 <dramforever> I think cp65001 is unicode. doesn't seem to work, though
01:56:33 <dramforever> at least with Chinese text
01:56:40 <rhovland> racist
01:58:32 <mniip> dramforever, 65001 is a number microsoft assigned to UTF-8 for internal use
01:58:37 <mniip> CP65001 is identical to UTF-8
01:59:05 <dramforever> can I actually change to utf-8?
01:59:30 <mniip> UTF-8 is "called" 65001 in the windows codepage mess
02:02:06 <rhovland> this is why my fonts look fucked up
02:11:59 <ttt_fff> it's so amazingly hard to use another langauge afte rhaskell
02:12:09 <ttt_fff> for everything I look at,it's like "nope, your type system is too weak"
02:13:10 <APic> B-)
02:13:42 <APic> I just began studying ‚ÄûHaskell ‚Äî The Craft of functional Programming‚Äú, 2nd Edition, by Simon Thompson
02:13:53 <APic> And i am darn impressed even though i only read the first few Pages
02:14:17 <APic> I know several procedural/imperative Languages, also quite a few Machine-Languages
02:14:23 <APic> Haskell is my first functional one
02:14:26 <APic> And it really rocks
02:18:43 <julianleviston> ttt_fff:  hehe I was looking at OCaml the other day for a bit - has some really nice libs‚Ä¶ until I realised it doesn‚Äôt have typeclasses, and I was like‚Ä¶ oh‚Ä¶ um.
02:19:01 <ttt_fff> yeah
02:19:04 <ttt_fff> supposedly modules are nice
02:19:06 <ttt_fff> but I don't know how to use them
02:19:11 <ttt_fff> and supposedly ocaml supports monads
02:19:14 <ttt_fff> but it looked really ugly
02:19:28 <ttt_fff> and supposedly ocaml has a type system, but "Int -> Int" in ocaml can do "rm -rf /" during the computation
02:23:33 <echo-area> Can someone tell me why `instance D [a] b where ...` allows one particular choice of [a] to be associated with more than one choice for b, given `class D a b | a -> b`?
02:25:42 <mniip> echo-area, got an example?
02:26:25 <echo-area> mniip: No, it is from the paper /Type Classes with Functional Dependencies/, section 3.3
02:28:27 <mniip> echo-area, oh
02:28:49 <mniip> you mean literally 'instance forall b. D [a] b'
02:30:42 <mniip> echo-area, because your instance allows simultaneously 'D [A] B' and 'D [A] C'
02:30:47 <mniip> which ought not be allowed
02:31:28 <mniip> it mentions earlier, that 'a b c -> d' means "d is determined by a combination of a, b, c"
02:31:48 <mniip> forall a b, b is not determined by [a]
02:31:58 <mniip> if that makes sense
02:33:03 <echo-area> You mean b is determined by [a] and b, and not by a, b?
02:33:33 <echo-area> I don't understand forall either.
02:33:39 <zipper> Has anyone does something like "print to browser using websockets" ?
02:34:17 <mniip> echo-area, in 'class D x y | x -> y', given a concrete x you should be able to get a concrete y
02:34:52 <mniip> in your case, 'D [()] b' doesn't define 'b'
02:36:19 <echo-area> mniip: I understand the first part.  Why does 'D [()] b' not define b?
02:36:46 <echo-area> Does [()] define b?
02:36:52 <mniip> echo-area, instance D [a] b
02:36:54 <mniip> a ~ ()
02:36:59 <mniip> it tells us nothing about b
02:38:56 <echo-area> mniip: What does `a ~ ()` mean, and what are the rules here to deduce `a ~ ()`?
02:39:56 <zipper> How can I make a websocket client invoke the "running" of a HTML file?
02:40:41 <mniip> echo-area, ~ is type equivalence
02:41:10 <mniip> ugh
02:41:21 <mniip> echo-area, look, if we have 'instance D Int Bool'
02:41:34 <mniip> 'D Int b' defines a concrete b
02:41:44 <mniip> a ~ Int, and thus to the aforementioned instance, b ~ Bool
02:41:59 <mniip> likewise, 'instance D [a], (a, a)'
02:42:11 <mniip> 'D [Char] b' again defines a concrete b
02:42:26 <mniip> a ~ Char, therefore b ~ (Char, Char)
02:49:55 <echo-area> mniip: So there should not be "free type variables" on the right side
02:50:03 <echo-area> I mean "a -> b"
02:50:56 <echo-area> What is the jargon?
02:52:11 <echo-area> The right side should be bound by the left side, or a concrete type, right?
02:54:21 <chaosmasttter> echo-area: yes, on the right side should only be variables that are mentioned on the left side or concrete types
02:57:02 <echo-area> I see.  Thanks
03:11:08 <kuribas> Why is the type of ExceptT = ExceptT (m (Either e a)).  Wouldn't it be more logical as ExceptT (Either e (m a)), so the evaluation stops when an error is encountered?
03:12:26 <dramforever> kuribas: then you could no longer make the exception depend on a result from a monadic action
03:12:49 <dramforever> for example, what if you want to throw an exception if user typed "error"?
03:13:19 <kuribas> right...
03:16:45 <zipper> Oh my, I'm looking at code I wrote a few months ago and I'm not proud of it.
03:20:27 <cinimod> I am trying to use the Frames package (https://hackage.haskell.org/package/Frames)
03:21:01 <cinimod> Does anyone have a feel for how long it should take for it to read a 100M file with 24,000 columns?
03:21:56 <cinimod> I can read it with R (https://www.r-project.org) in about 30 seconds
03:22:41 * hackagebot hid 0.2.1.1 - Interface to hidapi library  https://hackage.haskell.org/package/hid-0.2.1.1 (DimitriSabadie)
03:22:43 <cinimod> So far ghc has been running for 5+ minutes
03:23:01 <sshine> cinimod, read it and do what?
03:23:11 <cinimod> Anything
03:23:17 <julianleviston> LOL
03:23:35 <cinimod> tableTypes "User" "clouds.csv"
03:23:47 <padre_angolano> anything should take 0 secs
03:23:49 <cinimod> It's still compiling
03:24:06 <julianleviston> why is it reading the data as it‚Äôs compiling?
03:24:07 <cinimod> I agree once compilation has finished
03:24:30 <cinimod> Maybe it isn't but then what is it doing?
03:24:49 <cinimod> Prelude> :load "/Users/dom/Dropbox/Private/Amgen/MyFrame.hs"
03:24:49 <cinimod> [1 of 1] Compiling Main             ( /Users/dom/Dropbox/Private/Amgen/MyFrame.hs, interpreted )
03:24:52 <sshine> cinimod, do { x <- readFile "100m.txt"; writeFile "output.txt" x } took about 7 seconds here.
03:24:53 <julianleviston> cinimod: um‚Ä¶ GHC compiles haskell programs‚Ä¶ right?
03:25:00 <julianleviston> cinimod: OHHHH GHCI
03:25:03 <cinimod> Apparently
03:25:20 <ttt_fff> ghcjs + erlang is amazing
03:25:26 <cinimod> Should I not use ghci
03:25:26 <sshine> cinimod, I assume most of this time is conversion to-from String.
03:25:37 <cinimod> ?
03:25:47 <cinimod> Compilation just finished
03:25:57 <cinimod> Spoke too soon
03:26:13 <cinimod> Ah now I have a prompt
03:26:50 <julianleviston> cinimod: keep in mind we don‚Äôt know what‚Äôs in your .hs file.
03:26:57 <cinimod> I am guessing it was doing template stuff
03:27:04 <cinimod> Ah but you do
03:27:18 <sshine> @undo do { y1 <- f x; y2 <- g x; return (y1 || y2) }
03:27:19 <lambdabot> f x >>= \ y1 -> g x >>= \ y2 -> return (y1 || y2)
03:27:34 <cinimod> tableTypes "User" "clouds.csv"
03:27:42 <cinimod> Is all that my file contains
03:27:52 <cinimod> Apart from imports
03:28:15 <julianleviston> cinimod: ah.
03:28:37 <sshine> (||) <$> f x <*> g x
03:28:37 <cinimod> I probably don't want to hit :r
03:29:08 * cinimod goes back to the frames tutorial
03:29:10 <julianleviston> cinimod: how many cols?
03:29:16 <cinimod> 24,000
03:29:21 <julianleviston> cinimod: tableTypes: generates a type synonym for each column
03:29:25 <cinimod> Well 24,001 actually
03:29:28 <julianleviston> cinimod:  24000 COLs?
03:29:33 <cinimod> Yep
03:29:38 <julianleviston> how many rows?
03:29:42 <cinimod> 1000
03:29:47 <julianleviston> that‚Äôs a hell of a lot of type synonyms
03:30:01 <cinimod> Actually I lie - only 173 rows
03:30:26 <cinimod> I only want certain columns - that's my next step
03:30:46 <cinimod> Maybe I will speak to the author of the code that produced the CSV file
03:31:07 <cinimod> Potentially the number of columns could go up by a factor of 10
03:31:20 <cinimod> Transposing would be better
03:31:57 <cinimod> Or maybe a slightly better structure than CSV
03:33:17 <cinimod> julianleviston: thanks - I guessed it might be something like that - dynamic languages don't have to do that
03:35:05 <cinimod> Doing :i User gives me almost the same as colnames() does in R
03:37:59 <dramforever> safety comes with a cost
03:48:06 <cinimod> Lol the type errors span 24,000+ lines
03:49:40 <cinimod> Context reduction stack overflow; size = 101
03:51:36 <cinimod> When I try let pfStream :: Producer User IO (); pfStream = readTableOpt userParser "clouds.csv"
03:52:21 <cinimod> Well it's been an interesting experiment but I think I am going to go back to R
04:02:10 <julianleviston> dramforever: semantic interpretation comes with a cost, more like‚Ä¶ you can easily interpret things in a simple way, if you like, right? just as basic types, I mean‚Ä¶ 
04:02:27 <Gurkenglas> Does some library provide a rose tree of all the values of a recursively defined type?
04:02:37 <julianleviston> dramforever: I‚Äôm not very familiar with CSV interpretation in HS
04:02:43 <dramforever> julianleviston +1
04:03:22 <dramforever> the cost is really meta, meaning that it's not the runtime/compile-time performance, it's cost for humans to understand and use well
04:03:40 <Gurkenglas> Ooh, what I want is basically "derive Memoizable" @letlpaste 1161099169583071232
04:03:44 <julianleviston> dramforever:  yeah‚Ä¶ which brings us back to the inital question - ‚Äúto do what?‚Äù ;-)
04:03:57 <Gurkenglas> I mean http://lpaste.net/1161099169583071232
04:04:17 <dramforever> julianleviston: also lucky you, I just came back from supper =P
04:05:12 <cinimod> julianleviston: if your question is directed to me, I want to select some of the columns by name and then produce a distribution from those names
04:05:33 <julianleviston> cinimod: the initial question was to you, yep.
04:05:54 <julianleviston> cinimod: in that case you probably don‚Äôt need type synonyms for every col.
04:06:04 <cinimod> I think I can still remain in Hasell land but without using Frames
04:06:19 <cinimod> Haskell
04:06:35 <cinimod> Probably Cassava is my friend
04:12:31 <jophish> Yo yo yo,
04:12:47 <jophish> What's units and dimension package are the cool kids using now?
04:15:47 <dramforever> jophish: https://github.com/adamgundry/uom-plugin maybe? I just heard of it but didn't try it
04:16:06 <jophish> dramforever: yeah, I'm just looking at that now, thanks!
04:16:14 <dramforever> yw
04:19:29 <jophish> I suppose the issue with using something new and swishy is that it might make it harder for others to use my library
04:19:57 <julianleviston> jophish:  only if the new swishy thing is hard to use, I guess.
04:29:51 <julianleviston> @dramforever I wonder, seeing as commutative monoids are so incredibly useful from a parallelization point of view, is there an expression library for ordinary higher-order functions all expressed as Monoid mappend? Or would that be dependant on the type of function? I guess you could generalise a higher order monoidal combinator in a similar way to the way you just did for filter, right? First, translate to a folding ki
04:29:51 <lambdabot> Unknown command, try @list
04:29:52 <julianleviston> of function combinator, then make it take the folding function as an argument. For example, what does map look like when it's expressed as mappend of a Monoid? one could then generalise to any re-expression of a folding function form? no/
04:31:19 <julianleviston> dramforever: tho I might be just causing myself more pain than necessary :)
04:31:53 <dramforever> julianleviston: I have no idea on that, sorry
04:32:20 <julianleviston> dramforever: hehe yeah, all good :)
04:56:17 <kuribas> why is liftIO seperate from lift?
04:56:50 <kuribas> Since I can just _lift_ a IO monad?
04:59:01 <eugene_> could someone tell me what I'm doing wrong here http://lpaste.net/140319
05:02:47 <kuribas> > let f = (\x (y,z) -> ((min x y), (max x z))) in f 4 (1,2)
05:02:49 <lambdabot>  (1,4)
05:02:56 <kuribas> eugene_: it seems to work here
05:05:14 <julianleviston> eugene_: works for me in GHCI too
05:05:19 <Gurkenglas> kuribas, liftIO allows you to lift IO actions from deep within a monad transformer stack without doing lift . lift . lift etc
05:05:21 <solarus> I'm the arguments to f got defaulted to unit
05:05:41 <solarus> eugene_: whats your ghc version?
05:06:17 <Gurkenglas> All the monad transformer's behavior for liftIO is "call liftIO on the guy under me and lift the result", until it lands on the IO monad which has the actual implementation (which is, of course, also trivial)
05:06:48 <Gurkenglas> It works the same way for the get, put, modify, state from MonadState, or ask from MonadReader
05:06:52 <kuribas> So I better have both for my transformer?
05:07:07 <solarus> got the same problem with f in ghc 7.4.1 btw
05:07:45 <eugene_> ah yea sorry, as a single statement it works for me as well, I'm trying to call the function separately though
05:08:06 <julianleviston> eugene_: I called the function separately - and it worked
05:08:13 <julianleviston> 7.4.10
05:08:31 <julianleviston> sorry 7.10.2
05:09:04 <julianleviston> solarus: I wonder what :t f yields for you?
05:09:19 <Gurkenglas> kuribas, your own transformers should by default pass MonadReader, MonadState, MonadWriter, MonadIO, etc. instances from their wrapped monads. (My information may be faulty... why is that not "automated"?)
05:09:27 <julianleviston> solarus: I get f :: Ord t => t -> (t, t) -> (t, t)
05:09:28 <solarus> julianleviston: in 7.4 it was something like f :: () -> (()... etc
05:09:34 <solarus> anyways this is probably the issue
05:09:36 <solarus> https://wiki.haskell.org/Monomorphism_restriction
05:09:37 <eugene_> f :: () -> ((), ()) -> ((), ())
05:09:44 <julianleviston> solarus: aha‚Ä¶ so typing it explicitly would fix.
05:09:47 <kuribas> Gurkenglas: yikes
05:10:17 <Gurkenglas> Of course, you can ignore that if you don't want people to be able to use get, asks, liftIO, etc.
05:10:28 <eugene_> what do you mean typing it explicitly?
05:10:43 <eugene_> 7.6.3 by the way
05:11:41 <solarus> eugene_: check the link above
05:11:51 <solarus> you can solve it in a number of ways
05:12:04 <julianleviston> eugene_:  let f = (\x (y,z) -> ((min x y), (max x z))) :: Ord t => t -> (t, t) -> (t, t)
05:12:14 <julianleviston> (I think)
05:13:45 <kuribas> Gurkenglas: I implemented my own monad transformer, but it is basicly state + except.  Should I use the transformer versions instead?  It seems to be less boilerplate.
05:13:50 <solarus> one of the solutions is simply to use a more modern version of ghc where this problem is not seen :)
05:14:27 <kuribas> Gurkenglas: But then, will performance suffer?
05:14:53 <Gurkenglas> kuribas, yep that's what I'd do. I would guess it shouldn't
05:15:14 <Gurkenglas> Sounds like the sort of thing that ghc should be able to optimize
05:16:05 <kuribas> Yes, ghc is getting pretty good at inlining and stuff.
05:17:20 <kuribas> I hope this takes off: https://www.youtube.com/watch?v=gkx-D-7Y1EU
05:17:31 <Gurkenglas> Also should be more readable if you use two standard transformers instead of a custom one doing the same thing
05:19:47 <kuribas> True
05:30:15 <gfixler> can I load code from a path into ghci?
05:30:35 <gfixler> e.g. :l "~/foo/foo.hs"
05:31:16 <martinvlk> @pl upper `flbindParser` (\r -> list lower `flbindParser` (\rs -> valueParser $ r :. rs))
05:31:16 <lambdabot> upper `flbindParser` ((list lower `flbindParser`) . (valueParser .) . (:.))
05:31:26 <kuribas> I have "newtype MFSolverT v n m a = MFSolver (StateT (Dependencies v n) (ExceptT (DepError v n) m) a)", how do I derive State?
05:32:45 <kuribas> for monadtrans I am getting: Can't make a derived instance of ‚ÄòMonadTrans (MFSolverT v n)‚Äô (even with cunning newtype deriving)
05:33:02 <martinvlk> @pl flbindParser upper (\r -> flbindParser (list lower) (\rs -> valueParser $ r :. rs))
05:33:02 <lambdabot> flbindParser upper (flbindParser (list lower) . (valueParser .) . (:.))
05:37:04 <Gurkenglas> kuribas, why not use type instead of newtype and get all the instances for free?
05:37:28 <kuribas> Gurkenglas: for hiding the implementation?
05:37:34 <Gurkenglas> But there's some NewtypeDeriving stuff that lets you get instances from the newtype stuff
05:37:45 <Gurkenglas> What do you mean, hiding the implementation
05:38:03 <Gurkenglas> *newtype'd type
05:38:21 <truber124> I'm looking for a monad composer that means that I don't have to type (f >>= \a -> g >>= \b -> h a b)
05:38:48 <Gurkenglas> :t liftA2
05:38:49 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
05:38:52 <truber124> E.g. something like (f >>= h) , but for the case when h takes 2 args not one.
05:40:45 <Gurkenglas> truber, is it actually return $ h a b?
05:41:08 <kuribas> Gurkenglas: Will the newtype instance get specialized and inlined?
05:41:39 <kuribas> Gurkenglas: that may be faster than a simple type, but I am not sure that's the case.
05:41:51 <paldepind> Is is possible to install a dependency with cabal and have cabal automatically add the dependency to my .cabal file?
05:42:40 <martinvlk> @pl (\rs -> valueParser $ r :. rs)
05:42:40 <lambdabot> valueParser . (r :.)
05:42:54 <truber124> Gurkenglas: in this case, h has type Applicative f => (a -> b -> f c) -> f a -> f b -> f c
05:43:00 <Gurkenglas> kuribas, afaik both type and newtype definitions are completely eliminated by the compiler once the whole typeclass/instance stuff is done
05:43:17 <truber124> Is there a combinator so that I don't have to type: (f >>= \a -> g >>= \b -> h a b)
05:43:39 <kuribas> Gurkenglas: but a newtype carries it's own dictionary.
05:43:53 <kuribas> Gurkenglas: AFAIK
05:44:30 <Gurkenglas> Yes, but all the typeclass and instances stuff is desugared away during compilation, and after that newtype goes away too
05:45:38 <Gurkenglas> :t \f a b -> join $ liftM2 f a b -- liftM2 is just liftA2 specialized to monads
05:45:39 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
05:46:06 <Gurkenglas> It's a relict from when applicative wasn't a superclass to monad, but I used it here because join implies monad anyway
05:49:30 <kuribas> Gurkenglas: a newtype can have a different typeclass instance from the containing type right?
05:50:59 <brotknust> Why does this list comprehension not terminate: [(x, y) | x <- [0..], x < 10, y <- [0..], y < 10]?
05:51:36 <brotknust> It hangs after [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9)
05:52:24 <julianleviston> brotknust: because it‚Äôs got infinite values producing‚Ä¶ but constantly filtering
05:52:43 <julianleviston> brotknust: in other words, both your generators have no upper bounds on the range.
05:52:55 <brotknust> Ah, so you can't do that?
05:53:13 <brotknust> Now that I think about it in terms of the list monad, it makes sense
05:53:15 <brotknust> Thanks :)
05:53:17 <julianleviston> brotknust: you can, it‚Äôs doing what you asked - an infinite upper bound generator with filtering going on
05:53:31 <julianleviston> brotknust: no problem
05:53:34 <kuribas> Gurkenglas: At least something must be different.
05:53:40 <Gurkenglas> kuribas, correct. NewtypeDeriving allows you to get the instances you want from the underlying type. type as opposed to newtype gets you all instances and saves you the manual wrapping/unwrapping
06:02:15 <kuribas> Gurkenglas: If I use a type, the user will have access to the underlying StateT, but I want to hide the implementation.
06:02:41 <Gurkenglas> kuribas, afaik you cannot hide constructors, they will be able to unwrap your type anyway.
06:02:44 <Gurkenglas> *newtype
06:03:11 <kuribas> Gurkenglas: I can if I don't export the contructor, only the type.
06:03:55 <Gurkenglas> I think the constructor comes with automatically, but I'm not sure. Someone jump in or test it?
06:04:40 <mauke> you can hide constructors. example: Data.Map
06:04:52 <mauke> also IO
06:05:55 <echo-area> Does GHC not generate short-circuiting code for (>>=) in any case?
06:16:27 <echo-area> E.g. optimize code like `foldl' (>>=) empty (map (const $ const Nothing) [1..100000000])`
06:24:19 <kuribas> :t Map
06:24:20 <lambdabot>     Not in scope: data constructor ‚ÄòMap‚Äô
06:24:20 <lambdabot>     Perhaps you meant one of these:
06:24:20 <lambdabot>       variable ‚Äòmap‚Äô (imported from Data.List),
06:24:37 <kuribas> :t undefined :: Map Int Int
06:24:39 <lambdabot>     Not in scope: type constructor or class ‚ÄòMap‚Äô
06:24:39 <lambdabot>     Perhaps you meant ‚ÄòM.Map‚Äô (imported from Data.Map)
06:24:45 <kuribas> :t undefined :: M.Map Int Int
06:24:47 <lambdabot> M.Map Int Int
06:24:51 <kuribas> :t M.Map
06:24:53 <lambdabot>     Not in scope: data constructor ‚ÄòM.Map‚Äô
06:24:53 <lambdabot>     Perhaps you meant variable ‚ÄòM.map‚Äô (imported from Data.Map)
06:25:23 <echo-area> Hmm, I think it is already optimized
06:25:41 <kuribas> echo-area: it does inlining and specialization.
06:26:06 <echo-area> I see
06:32:30 <kuribas> Gurkenglas: Strange that it cannot derive MonadTrans, but it can derive MonadIO and the rest.
06:33:39 <Gurkenglas> Probably something to do with the kind, though I can't imagine what would be so hard about deriving the instance in theory
06:35:50 <kuribas> I implemented it as "lift m = MFSolverT $ (lift.lift) m"
06:36:38 <Intolerable> @pl lift m = MFSolverT $ (lift.lift) m
06:36:39 <lambdabot> lift = fix ((MFSolverT .) . join (.))
06:36:54 <Intolerable> lol.
06:38:24 <kuribas> or MFSolverT . lift . lift
06:38:41 <Intolerable> yeah that's what i expected it to spit out
06:39:35 <exio4> it's different lifts
06:39:39 <mauke> @pl lift' m = MFSolverT $ (lift.lift) m
06:39:39 <lambdabot> lift' = MFSolverT . lift . lift
06:40:02 <exio4> @pl lift_mf m = MFSolverT $ (lift_a . lift_b) m 
06:40:02 <lambdabot> lift_mf = MFSolverT . lift_a . lift_b
06:42:28 <kuribas> does it matter?
06:42:51 * hackagebot mfsolve 0.3.0 - Equation solver and calculator ‡ la metafont  https://hackage.haskell.org/package/mfsolve-0.3.0 (KristofBastiaensen)
06:43:10 <exio4> @let \f -> let lift = f . lift . lift
06:43:10 <lambdabot>  Parse failed: Parse error: EOF
06:43:16 <exio4> @let \f -> let lift = f . lift . lift in lift
06:43:16 <lambdabot>  Parse failed: TemplateHaskell is not enabled
06:43:33 <exio4> <_< ignore me
06:54:38 <ddrone> Hi everyone, can someone explain how do I write equivalent of <script src="something" /> in lucid?
06:55:21 <ddrone> I'm trying script_ [src_ "something"] which fails to typecheck with type error I don't understand
06:59:05 <srhb> ddrone: What's the type error?
06:59:11 <srhb> ddrone: Psychic debugging is really hard
06:59:27 <MarcelineVQ> rewarding though
06:59:47 <ddrone> Give me one second
07:00:12 <ddrone> http://lpaste.net/140323
07:00:24 <ddrone> That comes from line "script_ [src_ "/script.js"]"
07:00:57 <MarcelineVQ> is / escaping " ?
07:01:44 <ddrone> Nope, I just put the code in quotes without escaping
07:02:04 <ddrone> script_ [src_ "/script.js"]
07:02:06 <ddrone> That's the code
07:02:33 <ddrone> Oh well I just noticed that error message contains that already
07:05:00 <mauke> it wants another argument
07:05:40 <mauke> try: script_ [src_ "/script.js"] ""
07:07:13 <ddrone> Ok that didn't work because of OverloadedStrings, but specializing "" to Text from Data.Text helped, thanks
07:09:12 <TheCrafter> hello, is anyone here who can help me with a little problem I have?
07:12:32 <geekosaur> just ask your question, if someone can answer they will
07:13:32 <TheCrafter> okay you're right. I am using emacs and ghc-mod but I run onto a strange problem. I have this ( http://lpaste.net/8102246149370413056 ) little piece of code.
07:13:50 <TheCrafter>  ghc-mod underlined the "Network" in line 2 and on GHC Error buffer I get this: " Warning: Could not find a component assignment, falling back to picking library
07:13:50 <TheCrafter>  component in cabal file. "
07:14:05 <TheCrafter> any ideas what the problem might be?
07:17:15 <TheCrafter> nevermind i found it. For some reason having this "base >=4.8 && <4.9" in my build-depends in foo.cabal file caused the problem. No idea why.
07:17:42 <TheCrafter> changed it to just "base" and everything works. Strange.
07:22:28 <darenthis> I have an Either a a, resulting from a call to race. Is there a shorter way to use the results than case winner of Left a -> foo a ... Right a -> foo a? I want to say 'call foo on whichever one comes back'
07:23:35 <mauke> foo (either id id winner)?
07:25:51 <darenthis> mauke: that works, thanks
07:28:07 <Intolerable> either foo foo
07:38:21 <Gurkenglas> I vote for "foo . either id id". Separate calculation from structure!
07:39:59 <tsahyt> Is there a way to get bindings into scope in ghci that are defined in the where clause of a function?
07:44:04 <glguy> > views both show (Left True)
07:44:06 <lambdabot>  "True"
07:44:12 <glguy> > views both show (Right False)
07:44:13 <lambdabot>  "False"
08:00:34 <mniip> bitemyapp, if I may ask... do you fork every haskell repository you see, and star *all* repositories you see?
08:02:27 <Gurkenglas> What order of length of time would it take a single computer to rebuild the packages on hackage?
08:03:02 <Gurkenglas> (Just the type checking, no assembly generation needed.)
08:03:54 <mniip> Gurkenglas, implying all of them would compile
08:07:26 <Gurkenglas> Ooh, geekosaur is here, who suggested it. How do I do that? I want to try that ((>>) :: IO () -> IO a -> IO a) thing.
08:11:21 <mpickering> Gurkenglas: The easiest way is to build stackage with a modified version of ghc
08:11:35 <mpickering> there are instructions on the stackage mailing list for i
08:21:42 <roboguy`> wow, this is kind of a mess from here down (at least): https://en.wikipedia.org/wiki/Haskell_98_features#Namespaces
08:22:15 <lingxiao> hey all
08:23:05 <lingxiao> I have the following datatypes
08:23:06 <lingxiao> http://lpaste.net/140324
08:27:57 <lingxiao> and I am wondering if it's possible to put them both in the same list?
08:28:03 <lingxiao> also a question here: http://stackoverflow.com/questions/32414751/how-can-you-put-these-two-datatypes-rowf-maybe-and-maybe-rowf-identity-in
08:29:01 <glguy> lingxiao: You can make a list of [Either (CSVRowF Maybe) CSVRow_]
08:29:31 <roboguy`> lingxiao: hmm, why do you want the both types in one list?
08:30:52 <lingxiao> I'm parsing a stream of csv strings
08:31:01 <lingxiao> and some of the rows have null types... but most do not
08:31:25 <lingxiao> so as an optimization trick I'd like to decrease how nested the structures are
08:31:41 <lingxiao> so having Either a b kind of increase the "nestedness" of it though?
08:32:10 <roboguy`> lingxiao: you can't transform one type into the other and just have a list of that type?
08:32:59 <roboguy`> actually, hmm what does CSVRow Maybe represent?
08:33:14 <roboguy`> oops, I mean Maybe CSVRow_
08:33:17 <lingxiao> Couldn't match expected type ‚ÄòMaybe CSVRow_‚Äô
08:33:17 <lingxiao>                 with actual type ‚ÄòCSVRowF Maybe‚Äô
08:33:24 <lingxiao> is the error I get
08:33:40 <roboguy`> yeah, those are two different types
08:33:42 <lingxiao> let Just r1''= r1'
08:33:45 <lingxiao> r1''
08:33:49 <lingxiao> oh shoot ..
08:34:13 <roboguy`> lingxiao: one type represents an entire row that may or may not exist and the other type is a row that might be missing /some/ of its columns
08:34:20 <lingxiao> yeah ..
08:34:32 <lingxiao> for my purpose I would like to put them into one list ..
08:34:47 <lingxiao> or even have them come out of one conduit producer (for example)
08:34:59 <lingxiao> so there's no type level trickery to make it possible?
08:35:18 <roboguy`> lingxiao: why not represent a row that doesn't exist as a row with no columns?
08:35:32 <roboguy`> (a row missing all its columns, I mean)
08:35:57 <lingxiao> oh I dont encounter rows that don't exists
08:35:58 <roboguy`> for storage in the list and then you could convert it later
08:36:08 <lingxiao> it either a row with some columns that have no value
08:36:16 -lingxiao(~lingxiao@c-71-230-109-11.hsd1.pa.comcast.net)- or a row with values in all columns
08:36:24 <roboguy`> lingxiao: oh, then why do you need Maybe CSVRow_?
08:37:11 <lingxiao> the original goal was to make the record as flat as possible .. I thought by writing paramterized type CSVRowF f allow me to put CSVRowF Maybe and CSVRow Identity into one list
08:37:15 <lingxiao> but it does not ...
08:37:53 <lingxiao> so the ansewr is i don't need Maybe CSVRow
08:38:02 <roboguy`> ah, I see
08:38:09 <Gurkenglas> lingxiao, you had left yesterday before I answered your request: http://lpaste.net/140275
08:38:11 <lingxiao> yeah ... :(
08:38:21 <ddrone> I have a silly question - is there a way to customize GHC Show deriving?
08:38:22 <Gurkenglas> (This reads like the sort of thing that a derive clause should be able to do.)
08:38:23 <lingxiao> yes! thank you! I was looking for it .. I had to run out in a  hurry
08:39:12 <ddrone> E.g. I have simple newtype wrapper which has one "record" field, and derived Show instance shows this field name, I would like to get rid of it
08:39:24 -benzrf(~benzrf@benzrf.com)- why did you use a notice
08:39:29 <roboguy`> lingxiao: you could use an existential wrapper
08:39:57 <glguy> ddrone: You'll just write your own Show instance and Read instance instead of using the derived ones
08:40:19 <glguy> Generally you'll want read and show to produce the Haskell syntax that constructs that value, though
08:40:28 <glguy> If you want to make a separate pretty printing function that's usually better
08:40:31 <roboguy`> lingxiao: but generally, this is the sort of thing that you would probably want dependent types for
08:40:40 <lingxiao> hmm .. I'm trying to understand Gurkenglas's bit .. I'm wondering thats what he is doing
08:40:55 <lingxiao> I thought haskell had dependent types right ? or er some sembleance of it?
08:41:00 <ddrone> glguy: so let's say I have newtype Simple = Simple { getSimple :: Int } deriving (Show)
08:41:04 <roboguy`> lingxiao: haskell doesn't really have actual dependent types
08:41:06 <Gurkenglas> Sure, but why would you need those for this
08:41:13 <Gurkenglas> I never used them
08:41:17 <ddrone> glguy: show (Simple 4) == "Simple { getSimple = 4 }"
08:41:31 <roboguy`> lingxiao: that's (part of) why idris exists, ha
08:41:32 <lingxiao> Gurkenglas I'm not sure .. just trying to learn haha .. unless you were talking to roboguy`
08:41:41 <ddrone> glguy: I would like to derive show such that show (Simple 4) = "Simple 4"
08:42:05 <lingxiao> where is liftA4 from?
08:42:08 <ddrone> glguy: and I would like to avoid writing my own instances because the case I have somewhat more complicated than that
08:42:09 <lingxiao> not Control.Applicative?
08:42:26 <lingxiao> or Monad
08:43:16 <glguy> ddrone: You can write your own Show instance in that case
08:43:30 <Gurkenglas> http://hayoo.fh-wedel.de/?query=liftA4 I didn't know it's nonstandard, I just thought "this looks like liftAn for n = 4"
08:43:47 <roboguy`> Gurkenglas: if the problem is type-safe heterogenous lists, dependent types could help. If we look at the broader issue at hand here, yeah dependent types aren't very necessary
08:43:49 <glguy> You can derive one generically using Data.Data's gshow and I think GHC.Generics has a generic Show, too
08:44:09 <ddrone> glguy: ok, I see, thanks
08:44:12 <roboguy`> lingxiao: you can replace that with a (<$>) application and some (<*>)s
08:44:30 <Cale> lingxiao: Haskell doesn't really have dependent types. By (ab)using some of the newer extensions, you can almost do programming in the style of dependently typed languages, but it's still pretty awkward.
08:44:53 <Gurkenglas> roboguy`, my accumulated readings say that you don't really need heterogenous lists about as often as you don't really need unsafePerformIO
08:45:17 <lingxiao> Cale ok thanks I wont play with fire haha
08:45:19 <hodapp> lingxiao: Read a paper called "Hasochism" to get a more full answer.
08:45:25 <roboguy`> Gurkenglas: I agree in general, but if you're using a lot of GADTs they can be handy to have
08:45:28 <lingxiao> hodapp greeat will do
08:45:40 <roboguy`> I ran into some issues with that not too long ago
08:46:09 <glguy> lingxiao: Not that you need it but if you just want one fewer levels of indirection you can make a new list type that has two separate cons constructors, one for each row type :)
08:46:44 <lingxiao> glguy HA! :D I know you're joking but actually I never thought of it before
08:46:44 <roboguy`> You can almost fake a dependent sum type in haskell though, which helps
08:46:50 <lingxiao> work with the container not the data
08:47:22 <hodapp> roboguy`: How does one fake a dependent sum type?
08:47:45 <roboguy`> hodapp: like this: http://hackage.haskell.org/package/dependent-sum-0.3.2.1/docs/Data-Dependent-Sum.html
08:48:03 <roboguy`> (looks like the docs need to be updated a bit)
08:48:22 <hodapp> oooh...
08:50:56 <tsahyt> So I've been having this infinite loop problem here. Turns out that x `elem` [10..] is a really stupid thing to evaluate. I should use my brain more often when coding
08:51:31 <mniip> is 10 an Int or Integer here? might be non-infinite :D
08:51:43 <lingxiao> Gurkenglas can I ask you why the type of f in hoistCSVRow f (CSVRowF ...) is (for all x. f x -> g x)?
08:52:20 <lingxiao> or er .. I guess my question is that f is a type right?
08:52:24 <tsahyt> mniip: Int. But checking 2^64 possibilites to determine whether x is at least 10 is still awful
08:52:35 <lingxiao> but it has a type signature? 
08:52:56 <tsahyt> mniip: It should terminate either way, since Integer is technically bounded too. I think GMP supports numbers up to 16GB long though. That could take a while.
08:53:06 <mniip> correction
08:53:12 <mniip> GMP supports up to 2^64 limbs
08:54:41 <mniip> which is, what, 2^72 *bits*
08:54:55 <Gurkenglas> lingxiao, I want something that can be applied to both f String and f Double, so I said that it must be able to be applied to any f x
08:55:24 <mniip> 512 exabytes
08:55:40 <mniip> though no widely used operating system can allocate more than 128 TB
08:55:43 <petercommand> hi, I am getting 404 when visiting this page: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc/index.html
08:55:58 <lingxiao> Gurkenglas but f is a type right? but it also have a type signature?
08:56:03 <petercommand> which is linked from https://wiki.haskell.org/GHC/As_a_library
08:56:04 <lingxiao> don't types have kind signatures though?
08:56:21 <hvr> petercommand: try https://downloads.haskell.org/~ghc/latest/docs/html/libraries/ghc-7.10.2/index.html
08:56:41 <petercommand> hvr: thx :)
08:56:48 <Gurkenglas> lingxiao, the namespaces of line 12 and 13 are separate. f in one is not f in the other. I could have replaced the 5 fs in line 13 with ls and it would work the same way
08:56:55 <tsahyt> mniip: I did not know that. I remember reading it was 16GB somewhere. Realistically though, I'd run out of memory anyway.
08:57:53 <petercommand> The wiki link should be fixed though
08:58:21 <lingxiao> ahh I see ok
08:58:37 <roboguy`> hodapp: unfortunately, I don't think that gets you *all* the way the to full dependent sums. But you can use it to write a type-safe filter function for a size-indexed vector type!
08:58:41 <lingxiao> but why did you define hoistCSVRowF if you never used it?
08:59:23 <lingxiao> Im still not clear on how you would put CSVRowF (Just ..) in the same list as (Just CSVRowF (...))?
08:59:26 <mniip> tsahyt, oh, an interesting consideration
09:00:00 <mniip> if there are 2^64 libs then there are at least 2^67 addressable bytes
09:00:18 <mniip> the CPU has to have 67 memory lanes
09:00:33 <mniip> which means the word size will probably be more than 67 bytes
09:00:51 <mniip> which means max limb amount is raised to 2^67
09:01:12 <mniip> i.e largest GMP number will never fit in your address space
09:01:13 <lingxiao> Gurkenglas
09:07:12 <voidzero> I wonder if there's a Dutch Haskell community..
09:07:16 <mniip> oh
09:07:28 <mniip> I didn't think of segment-offset addressing
09:07:45 <mniip> who knows, we might go back to that when 2^64 bytes of ram becomes not enough
09:08:05 <Welkin> mniip: bytes?
09:08:09 <Welkin> or bits?
09:08:30 <mniip> which occurence are you talking of
09:09:51 <Dillard> yeah, so if I learn lambda calculus I  can learn and understand haskell syntax easier?
09:10:22 <mauke> no, lambda calculus has very little syntax (and it's not the same as haskell)
09:10:30 <ww> but it's good to know
09:10:42 <Dillard> ok
09:11:06 <Welkin> Dillard: the important thing to learn about haskell is the type system
09:11:22 <Welkin> Dillard: you can always follow the types when you get confused about something
09:12:23 <adfrench> are the talks for cufp being streamed by chance?
09:17:13 <lingxiao> test
09:17:58 * hackagebot react-flux 0.9.2 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-0.9.2 (JohnLenz)
09:22:59 * hackagebot react-flux 0.9.3 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-0.9.3 (JohnLenz)
09:27:59 * hackagebot pretty-error 0.1.0.0 - Pretty error messages for runtime invariants  https://hackage.haskell.org/package/pretty-error-0.1.0.0 (jml)
09:30:48 <akegalj> hey. I am trying to find binary file that stack has build. Where is its location?
09:31:32 <vrdhn> , find . -name <expected-binary-name> helps ?
09:31:50 <akegalj> vrdhn: yes that could help. good point
09:31:52 <geekosaur> ~/.local/bin on unixlikes
09:32:11 <akegalj> geekosaur: its not there (i am on ubuntu)
09:34:32 <beatboxchad> this here FARM talk at ICFP is hella rad.
09:35:34 <tsahyt> I want an equational reasoning tool that can load existing source files and expand terms. Debugging would be so much easier.
09:40:59 <myfreeweb> just got a weird error when compiling shell-conduit: Illegal variable name: ‚Äòtype‚Äô When splicing a TH declaration: type = Data.Conduit.Shell.Variadic.variadicProcess "type"
09:42:31 <myfreeweb> I mean, it makes sense, but somehow this version is included in LTS Haskell, so it was compiled successfully by Stackage
09:48:05 <roboguy`> tsahyt: have you looked at HERMIT?
09:48:25 <myfreeweb> looks like that happens because I have a /usr/bin/type and this library uses TH to build functions for everything on my $PATH... apparently linux doesn't have it
09:49:32 <tsahyt> roboguy`: Not yet. Does it have an interactive interface?
09:50:01 <tsahyt> roboguy`: What I'm looking for is something that can read Haskell definition, jump somewhere with an example and lets me specify what to expand, step by step.
09:50:14 <roboguy`> tsahyt: Yep! It has a REPL
09:50:24 <tsahyt> roboguy`: Nice. I'll check it out, thanks!
09:50:34 <roboguy`> tsahyt: By "expand", do you mean inline the definition of a function, essentially?
09:51:00 <martinvlk> @pl (\f -> f c)
09:51:00 <lambdabot> ($ c)
09:51:28 <tsahyt> roboguy`: Yes, I want to substitute the definition. Say I have foo a b = a + b, and some other definition that uses foo 10 5, I want to substitute that for 10 + 5
09:51:40 <roboguy`> tsahyt: ah, yep it can do that. I'm part of the organization that develops HERMIT (among other projects) and I have worked on it some, so I'd be happy
09:51:50 <roboguy`> to answer questions (if I can)
09:54:06 <roboguy`> tsahyt: the 'unfold' command, in particular, does what you're describing
10:01:13 <hiptobecubic> Does anyone have experience working with Text.XML.Cursor? I can't seem to extract any content, even when I'm sure that it's there.
10:01:46 <tsahyt> roboguy`: I think it'll take a while until I can make good use of it, but it looks really interesting. It says on the hackage page that it does program transformation during GHC compilation. I'm not quite sure I understand what is meant by that. What's the goal of the project (other than the simple task that I want it to do of course)?
10:02:39 <roboguy`> tsahyt: The system lets you prove theorems about your code. It also lets you transform your code before the compilation is completed. A practical application of this would be to create your own custom optimizations
10:03:25 <roboguy`> tsahyt: HERMIT runs on the intermediate Core code GHC generates before it finishes compiling. After the HERMIT script/REPL commands are done, you resume it to finish compilation of the (possibly transformed) Core code
10:03:54 <roboguy`> GHC has a builtin plugin mechanism for this kinda thing, so HERMIT runs as a GHC plugin
10:05:56 <tsahyt> That's quite interesting actually. I might find another use case for this one day. Since I can prove theorems here, I assume that it makes use of a stronger system than the Haskell type system?
10:08:35 <roboguy`> tsahyt: it uses an (untyped) proof mode which allows you to perform different transformations to both sides of an equality, say, into the same thing
10:09:25 <roboguy`> tsahyt: there are quite a few examples in the examples directory of HERMIT. A lot of proof examples are in the examples/laws directory. https://github.com/ku-fpg/hermit/tree/master/examples
10:10:17 <tsahyt> I've also just found a paper on it. Looks like I'll have some reading to do.
10:10:46 <tsahyt> Which also reminds me of that other tool to convert papers into an e-reader friendly format that was on /r/haskell the other day. I like it when things come together like that.
10:10:55 <roboguy`> we are in the process of developing a new interface into HERMIT (with the new system, HERMIT scripts will be written in Haskell using an EDSL). It works pretty well, but the interface is still a bit unstable
10:11:59 <Alpha64> roboguy` what do you mean by proving theorems about your code?
10:12:10 <roboguy`> sort of as a side note, if you're interested in seeing the progress on that new interface, the github repo is https://github.com/ku-fpg/hermit-shell
10:12:27 <roboguy`> Alpha64: for instance, proving the monoid laws for something do in fact hold
10:13:11 <Alpha64> any examples i can see ?
10:13:29 <_UberLambda_> Where should I look if I'd like to learn about monads?
10:13:34 <akegalj> i am trying to build static binary. Does all my dependencies (packages) need to be build staticly too?
10:13:35 <_UberLambda_> from the bottom up
10:14:44 <roboguy`> Alpha64: Yeah. There are a lot of examples of proving theorems here https://github.com/ku-fpg/hermit/tree/master/examples/laws
10:14:58 <obadz> Does Debug.Trace.trace properly reflect memoization?
10:15:11 <roboguy`> Alpha64: the .hec and .her files are the HERMIT scripts that have the proofs and the .hs files are the code we're proving theorems about
10:15:26 <roboguy`> _UberLambda_: start with Functors
10:15:43 <_UberLambda_> roboguy`: thanks, I'll check them out
10:16:28 <roboguy`> _UberLambda_: after that, learn about Applicatives then Monads. There's a nice, natural progression. LYAH worked well for me
10:17:10 <_UberLambda_> roboguy`: I've left LYAH at something like 20%... I should probabily go on reading it
10:17:17 <roboguy`> _UberLambda_: but there are other good resources too. Try not to read too many tutorials that use crazy analogies for monads. That often makes it seem more mysterious than it is
10:17:31 <_UberLambda_> roboguy`: yeah, I noticed :/
10:17:44 <_UberLambda_> I've developed some kind of monad allergy it seems
10:17:57 <obadz> let x = (trace " !Yo!" (* 2)) 3 in (x, x) ==>> ( !Yo! 6, !Yo! 6)
10:18:03 <obadz> >> is (* 2) evaluated twice?
10:18:19 <Alpha64> thanks roboguy` 
10:18:37 <roboguy`> _UberLambda_: when I went into LYAH, I felt mostly comfortable with functional concepts so I skipped ahead to the section on Functors and referred back when I got something I didn't understand
10:18:41 <roboguy`> sure!
10:19:19 <_UberLambda_> roboguy`: I'm imperatively-minded :P
10:19:20 <roboguy`> obadz: you could replace (* 2) with another trace and see that way
10:19:57 <roboguy`> _UberLambda_: ahh, yeah things can take some getting used to then. It gets easier with more exposure though
10:20:12 <_UberLambda_> roboguy`: I hope so... thanks for the tips :)
10:20:29 <roboguy`> np! Feel free to ask if you have any more questions!
10:23:39 <tsahyt> roboguy`: Is there a documentation of the commands in the REPL except for the help command?
10:24:36 <Welkin> tsahyt: according to ghci, x is evaluated once
10:24:54 <Welkin> at least, when testing it using let bindings and :sprint
10:25:09 <obadz> roboguy`: not sure what you mean?
10:25:20 <Welkin> er, I meant that for obadz 
10:25:47 <roboguy`> tsahyt: unfortunately, that's pretty much it. There's also big list of command names organized by the module they're defined in (roughly grouped by what they do) here: https://github.com/ku-fpg/hermit-shell/wiki/HERMIT-to-HERMIT-Shell
10:26:08 <roboguy`> that was mainly for internal use for us to keep track of development progress though, so it's not super helpful
10:26:30 <obadz> Welkin: then trace doesn't do what I think it does?
10:27:04 <roboguy`> tsahyt: oh, also it uses the KURE library to traverse the Core AST, which has hackage docs. I think they are the same as the help docs for those particular commands though
10:27:49 <roboguy`> obadz: I mean something like let x = (trace " !You!" (trace "being evaluated" (* 2))) 3 in (x, x)
10:28:54 <Welkin> obadz: well, I used: let x = 1 + 2 :: Int; let y = (x,x) :: (Int,Int)
10:29:16 <obadz> Welkin: how did you find out it was evaluated once
10:29:23 <Welkin> using :sprint
10:29:25 <roboguy`> tsahyt: for the moment, the latest paper is probably the best documentation. Eventually, we're going to write up some actual documentation and maybe a tutorial though
10:29:48 <Welkin> :sprint x gives x = _
10:29:57 <Welkin> :sprint y gives y = (_,_)
10:30:01 <obadz> let x = (trace " !Yo!" (* 2)) (3 :: Int) in (x, x) => ( !Yo! 6, 6)
10:30:10 <obadz> looks like it's because of Num a => a..
10:30:11 <Welkin> then, evaluate x by using `x`
10:30:22 <tsahyt> roboguy`: http://www.ittc.ku.edu/csdl/fpg/files/Farmer-15-HERMIT-reasoning.pdf This one?
10:30:22 <Welkin> after that, :sprint y gives y = (3,3)
10:31:12 <roboguy`> tsahyt: yeah
10:31:38 <tsahyt> roboguy`: Okay thanks, I'll read that.
10:32:33 <roboguy`> tsahyt: Also I want to point out, for the particular use case you mentioned, you will likely get a lot of mileage out of "unfold" (that might help get you started)
10:38:51 <milk_base> https://www.youtube.com/watch?v=rLNYhWpdSOo <--- #chan
10:39:20 --- mode: ChanServ set +o monochrom
10:39:25 --- mode: monochrom set +b *!*@unaffiliated/turtlesauce
10:39:25 --- kick: milk_base was kicked by monochrom (milk_base)
10:40:34 --- mode: monochrom set -o monochrom
11:39:21 <daniel_adeyemo> Review book: The Haskell Road to Logic Maths and Programming
11:39:40 <daniel_adeyemo> what do you guys think about the books
11:39:44 <daniel_adeyemo> *book
11:46:09 <javjarfer> Hi there! Imagine i have the following definition of State, http://melpon.org/wandbox/permlink/EFjDOYqGnAVfputK, if you load the source from ghci, and do this, "let s = State (\s -> (2,s))", the compiler is able to infer that the "m a" of the monad that your are talking about is a State s Integer.
11:47:00 <javjarfer> Anyone figures out how that process works, and if it's totally done at compile time?
11:50:05 <srhb> daniel_adeyemo: I only know that the author manages to claim that Haskell is a Lisp, which it emphatically isn't. Not very encouraging, but the rest may be okay, no idea.
11:50:49 <daniel_adeyemo> srhb i was also bummed when he claimed haskell is a Lisp
11:51:22 <lingxiao> has anyone used cassava
11:52:02 <srhb> javjarfer: There's nothing monadic going on in let s = State (\s -> (2,s)) so I'm not sure what you mean.
11:52:30 <srhb> javjarfer: But yes, type inference happens at compile time. Types do not exist at runtime.
11:53:50 <drewbert> Does anyone here have experience using any of the extensible records proposals?
11:54:12 <javjarfer> srhb, yes, it wasn't a good example to show the point, sorry, so GHC basically infers the types while compiling building them while compiling? Well that is truly awesome
11:54:49 <srhb> javjarfer: That's correct. You can look up Hindley Milner and type inference if you want. :)
11:55:13 <hindsight> hey
11:55:19 <srhb> hindsight: Hello.
11:55:34 <hindsight> I am relatively new to Haskell
11:55:46 <hindsight> Was wondering if you can help with something specific
11:56:02 <srhb> hindsight: Pose your question and paste relevant code and errors on lpaste.net and someone might help you. :)
11:56:07 <lingxiao> how do I print a Vector a instance?
11:56:29 <srhb> lingxiao: What do you mean print an instance?
11:56:41 <lingxiao> so I should say convert to string
11:56:48 <hindsight> So I have this problem. Suppose I am writing an expression simplifying engine. I have different types of expressions, ofcourse
11:57:13 <hindsight> Something like data Expression = Plus Expression Expression | Minus Expression Expression | ...
11:57:26 <lingxiao> is vector a functor?
11:57:36 <lingxiao> yes .. nvm
11:57:39 <srhb> lingxiao: You mean print a Vector a? The confusing bit is because you said "instance" which i don't really thing makes sense. But there's a Show a => Show (Vector a) instance, so you can use show if your a has a Show instance.
11:57:47 <hindsight> Question: I want my expression simplifying engine to be modular. I want to add specific functionality on the fly
11:58:04 <hindsight> Like in C# I would add another class which inherits Expression in another assembly
11:58:15 <hindsight> How can I do such things in Haskell?
11:58:35 <monochrom> look for the paper "data types a la carte".
11:59:04 <javjarfer> srhb, thanks you! I'm working on functional style programming in other languages and a deeper understanding is needed in some point. But... from now, i haven't found nothing so powerfull as the type inference GHC has. I mean others are quite far from partially specializing things and passing them while compiling to construct the full type later.  
11:59:41 <srhb> javjarfer: I have little experience with other functional languages, but yes, the type system of Haskell doesn't get in your way much, quite the opposite. :)
12:01:15 <hindsight> wow thanks
12:01:22 <hindsight> it is precisely what I needed
12:01:30 <javjarfer> srhb, totally agree with that, and well counting that i'm talking about C++ template metaprogramming you can see now in what a mess I'm.
12:03:05 <Cale> Type inference is a lot easier when you don't sabotage yourself by having subtyping :)
12:04:25 <lingxiao> how do I convert a string to ByteString
12:04:49 <lingxiao> from data.bytestring.lazy 
12:05:19 <levi> I believe it's with 'pack'
12:05:26 <Peaker> Cale: structural subtyping (IIRC the terminology correctly) is fine though
12:05:27 <jle`> you have to pick an encoding, i think
12:05:43 <lingxiao> :t pack
12:05:45 <lambdabot>     Not in scope: ‚Äòpack‚Äô
12:05:45 <lambdabot>     Perhaps you meant one of these:
12:05:45 <lambdabot>       ‚ÄòBS.pack‚Äô (imported from Data.ByteString),
12:05:53 <Peaker> lingxiao: UTF8 encoding? Or just latin-1 assuming all code-points are <256 ?
12:06:00 <lingxiao> pack is [GHC.Word.Word8] -> BL.ByteString
12:06:12 <jle`> so you can convert it to Text and go from Text to ByteString by providing an encoding
12:06:30 <jle`> or you can use a serialization library like cereal or binary to handle serialization of your String for you
12:06:38 <jle`> in whatever format the library chose
12:06:54 <lingxiao> no sure :(
12:07:28 <drewbert> I think I will just use TH haskell to copy fields from other records into the current record.
12:07:29 <jle`> lingxiao: you can use the functions here to convert from a TExt to a ByteStrying if you know the encoding you want -- http://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Lazy-Encoding.html
12:07:30 <monochrom> if you're unsure, default to IBM's EBCDIC :)
12:07:58 <lingxiao> I'm using cassava ..
12:08:04 <lingxiao> but my input is in string ... if that helps at all
12:08:04 <drewbert> TH - for when it's easiest to grab the biggest hammer around.
12:08:24 <jle`> lingxiao: what is eventually going to consume your bytestring?
12:08:48 <jle`> lingxiao: the problem with a straight up String -> ByteString is that there's more than one way to encode a string as a bytestring...so if whatever reads your bytestring int he end expects another encoding, you're in trouble
12:10:02 <jle`> it looks like `cassava` is expecting UTF-8
12:10:05 <lingxiao> jle` i'm using the decodeByName function from cassava
12:10:32 <jle`> yeah, it looks like cassava's decoding functions expect UTF-8
12:10:41 <lingxiao> hmmm... so actually I'm not familiar with all these types .. 
12:11:22 <jle`> how are you getting your String?
12:11:25 <jle`> are you entering it as a literal?
12:11:43 <jle`> if so, you can use OverloadedStrings... i think that's compatible with utf-8 bytestrings, even though it might be a little bit hacky, heh
12:12:25 <levi> lingxiao: How are you reading your input? From a file?
12:12:26 <jle`> the safe way would be to turn your String into a Data.Text.Lazy Text using `pack`, and then use "encodeUtf8" from Data.Text.Lazy.Encoding
12:12:46 <jle`> so you can do stringToByteString = encodeUtf8 . pack
12:12:56 <lingxiao> the string is actually coming out of a generator
12:13:04 <lingxiao> but I'm not sure it necessarily have to generate a string actually ..
12:13:24 <levi> If it's a generator you wrote, then you might generate a ByteString directly.
12:13:33 <lingxiao> this is how I'm calling it 
12:13:33 <lingxiao> http://lpaste.net/140345
12:14:01 <jle`> lingxiao: the bytestring library has its own hGetContents that returns ByteString
12:14:33 <jle`> lingxiao: http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Lazy.html#v:hGetContents
12:15:37 <jle`> this just reads a raw bytestream, so you have to hope that whatever is providing you the bytes through the handle is sending in utf-8, though
12:18:13 <levi> Well, cassava *expects* a raw bytestream. 
12:19:59 <lingxiao> jle` great thanks!!
12:20:29 <jle`> levi: oh, you're right :)  i misread the instances
12:20:41 <jle`> it expects utf-8 for Char, Text fields, but the rest is fine with anything
12:23:29 <levi> Yeah, it all depends on what the parsers for the types in your records expect.
12:25:11 <levi> The RFC that cassava references says the default is US-ASCII encoding, but I kind of doubt that's actually true in the wild these days.
12:28:06 * hackagebot foldl-transduce 0.3.0.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.3.0.0 (DanielDiazCarrete)
12:28:51 <RandomStorage> hello
12:31:31 <NeedStoragePm_me> hey look at my name do it if u need it
12:32:24 <NeedStoragePm_me> hey look at my name do it if u need it anyone here
12:33:07 <koral> which library would you recommend to print tabular data to stdout ?
12:33:18 <NeedStoragePm_me> hey look at my name do it if u need it anyone here
12:34:28 <NeedStoragePm_me> hey look at my name do it if u need it anyone here
12:34:52 <koral> notably, do you know whether it can be done using wl-pprint-text ? I tried "colomn1 <+> colomn2" but it printed one above the other, with some horizontal shift for the 2nd column
12:34:56 <koral> s/colomn/column
12:36:23 <NeedStoragePm_me> hey look at my name do it if u need it anyone here hey 1489 users and none need online storage
12:37:05 --- mode: ChanServ set +o shachaf
12:37:09 --- mode: shachaf set +b *!*627d1ecd@*.com/ip.98.125.30.205
12:37:09 --- kick: NeedStoragePm_me was kicked by shachaf (NeedStoragePm_me)
12:37:16 --- mode: shachaf set -o shachaf
12:53:30 <sdlkfj> Why this doesn't work? http://lpaste.net/140348
12:54:11 <mniip> sdlkfj, ST is of kind * -> * -> *
12:54:14 <Arcaed0x> if you use a language pragma in a file, do you have to use it in the compile flags too ?
12:54:23 <mniip> i.e neither ST, nor (ST s) is a concrete type
12:54:25 <mniip> but (ST s a) is
12:55:07 <mniip> sdlkfj, it seems that ST is not the type you're looking for
12:55:08 <Peaker> sdlkfj: You're supposed to use STVector/IOVector, not MVector, I think
12:55:36 <Peaker> sdlkfj: STVector s, and not MVector (ST s), or STVector (ST s) 
12:56:04 <sdlkfj> STVector Int Int doesn't work too
12:56:40 <sdlkfj> that is too complicated
12:57:11 <mniip> sdlkfj, it appears that you don't understand how ST magic works
12:57:20 <Peaker> sdlkfj: "STVector s" where "s" is a phantom type tag that's meant to remain polymorphic (to protect the ST s invariants)
12:58:07 <sdlkfj> STVector s, STVector s Int, don't work too
13:03:07 <Peaker> sdlkfj: yes, because you try to thaw the vector into mutable state and then have that mutable state escape out the ST computation
13:03:14 <Peaker> sdlkfj: and you use "runState" when you probably mean "runST"
13:03:36 <monochrom> yikes
13:03:56 <sdlkfj> ok, it works now
13:04:33 <sdlkfj> what is the difference of runState and runST
13:05:01 <lpaste_> Peaker annotated ‚ÄúNo title‚Äù with ‚ÄúAvoid the unsafe stuff, type-checks, simpler.‚Äù at http://lpaste.net/140348#a140353
13:05:11 <monochrom> they are unrelated. so I don't know where to begin listing their differences
13:05:29 <Peaker> sdlkfj: The "State" type is just a newtype around (s -> (a, s)) and the idea of "threading" the "s" values between computations being chained together
13:05:38 <mauke> what is the difference between ponies and peanuts
13:06:11 <Peaker> sdlkfj: The "ST s" type is a "Single-threaded(ST)" computation that uses type-level trickery to guarantee that mutable state does not "escape" out of the ST computation (so it remains single-threaded)
13:06:47 <Peaker> sdlkfj: and due to this guarantee -- "ST" can provide destructive-mutability internally (with the nice performance benefits) while remaining completely determinstic and immutable on the outside (pure)
13:07:47 <Peaker> sdlkfj: In ST, you can create mutable variables, mutable vectors, mutate them willy-nilly, and at the end when you "runST" or do the Vector's "create", you end up with a pure result that hides all the mutation that was involved in creating it
13:08:21 <sdlkfj> that is cool
13:08:24 <sdlkfj> thanks
13:13:07 * hackagebot cron 0.3.2 - Cron datatypes and Attoparsec parser  https://hackage.haskell.org/package/cron-0.3.2 (MichaelXavier)
13:25:53 <serendependy> Anyone want to give me style advice? I have a short but dense function I'm not particularly proud of, hoping to get suggestions to make it more readable / maintainable
13:25:55 <serendependy> http://lpaste.net/140354
13:26:23 <serendependy> The problem is generating a guess for the game 'Mastermind' given some knowledge about the possible peg positions
13:28:25 <Gurkenglas> serendependy, head and fillWith c are interchangeable, and head . filter goodGuess can be replaced by find goodGuess
13:29:05 <serendependy> @type find
13:29:06 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
13:29:08 <Gurkenglas> (Well, of course on the left side of head, fillWith is gonna be one map poorer)
13:29:42 <serendependy> Gurkenglas, Thanks, that should help.
13:29:59 <serendependy> I'm mostly worried about "allGuesses" though
13:30:44 <Hafydd> ACHIEVEMENT UNLOCKED: triply nested lambdas.
13:30:51 <serendependy> yep
13:31:10 <serendependy> There's no way I could have written that without typed holes
13:31:23 <serendependy> They are a blessing and a curse!
13:31:43 <avp> i'm trying to use hdevtools in a cabal project and it can't find the files for any modules
13:34:46 <Gurkenglas> You'd think there would be IntMap a -> IntMap (Key, a) to decorate each value with its key.
13:35:19 <avp> this only happens when i'm using cabal with Setup.hs
13:38:30 <serendependy> Gurkenglas, Can you even understand how allGuesses works? Or is it completely unreadable
13:38:44 <tempname11> If I get a runtime exception (Vector index out of bounds), how can I view the call stack or otherwise understand where it comes from in my code?
13:38:53 <Hafydd> I'm still trying to understand it, but it was helpful to realise that you said above what the game was.
13:38:57 <Gurkenglas> I think I can, and I'm working on simplifying it
13:39:17 <Hafydd> (Unrelatedly, "generating a guess for the game" and "possible peg positions" have some nice alliteration.)
13:39:35 <serendependy> Hafydd, lol, didn't notice that
13:40:49 <mauke> tempname11: that's going to be hard because haskell doesn't have a call stack
13:40:49 <Hafydd> I don't know if "Possibility" is a good name for your type, or of "pos" is a good name for a variable of that type.
13:41:07 <mniip> lol
13:41:21 <mniip> today I tried implementing type-changing recursion in C++
13:41:24 <mniip> crashed g++
13:41:48 <serendependy> Hafydd, It makes more sense if you see the whole programm. A "Possibility" is not necessarily a valid maping of pegs to locations
13:41:57 <serendependy> type Knowledge = [Possibility]
13:43:14 <serendependy> And also, the [Int] value itself represents uncertainty. It's made for a version of the game where only one color peg is in one location, so as the solver progresses it steadily reduces the lengths of these lists
13:43:41 <serendependy> I can post the whole code if that helps, but it's kind of a mess
13:44:15 <parsnip> oh, so "y <- return x", the left arrow is an anolog to assignment? 
13:44:27 <parsnip> like x = 5
13:44:38 <lpaste_> serendependy pasted ‚ÄúMastermind‚Äù at http://lpaste.net/140355
13:45:13 <tempname11> mauke: a clever remark reminiscent of an answer is not, unfortunately, an answer
13:45:14 <serendependy> Hafydd, Gurkenglas: the full code, which you can compile and run yourself, if it helps
13:45:46 <mauke> tempname11: cool story
13:45:56 <serendependy> oh hold on
13:46:09 <lpaste_> serendependy revised ‚ÄúMastermind‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/140355
13:59:13 <lpaste_> Gurkenglas annotated ‚ÄúGenerate a guess for Mastermind‚Äù with ‚Äúserendependy, step 1‚Äù at http://lpaste.net/140354#a140357
13:59:21 <Guest47420> I am a computer science student wanting to learn a lisp-dialect or functional programming language like haskell.  After learning enough of the language, I'd like to write an interpreter or basic computer algebra system which would be implemented in that language.
13:59:49 <serendependy> @type foldlM
13:59:50 <lambdabot> (Monad m, Foldable t) => (b -> a -> m b) -> b -> t a -> m b
14:00:18 <Guest47420> Is haskell suitable for this, or should I choose a lisp-dialect like scheme?
14:00:40 <Rembane> Guest47420: Both are good for it.
14:01:20 <Guest47420> @Rembane, what benefits would Haskell have over another lisp-dialect?  Is haskell suitable for numeric computation as well as symbolic computations?
14:01:20 <lambdabot> Unknown command, try @list
14:01:32 <Cale> Haskell isn't a lisp dialect, btw.
14:01:39 <Rembane> Guest47420: What is a numeric computation in your context?
14:01:47 <Welkin> Cale: lol
14:03:45 <Guest47420> @Rembane, I've only read a little bit, but I thought that the difference between symbolic and numeric computations were that numeric computations actually performed the arithmetic to solve a problem, while symbolic computation manipulated symbols to show how the steps involved in a solution?
14:03:45 <lambdabot> Unknown command, try @list
14:04:03 <Gurkenglas> serendependy, I take it the order of folding doesn't matter? Are all the ls disjoint?
14:04:43 <Rembane> Guest47420: Seems reasonable. Haskell isn't supergood att numerical computing, on the other hand, it doesn't seem like you need the real heavy stuff, so I think Haskell can be a good fit.
14:04:45 <serendependy> Gurkenglas, They are not disjoint. It's possible to have, e.g:
14:05:00 <Cale> Guest47420: Haskell should be fine for both numerical and symbolic computation.
14:05:07 <serendependy> [Map.fromList [(White,[1,2,3]),(Black,[1,2,3])]]
14:05:19 <serendependy> er, drop the brackets
14:05:30 <serendependy> Map.fromList [(White,[1,2,3]),(Black,[1,2,3])]
14:06:21 <serendependy> Gurkenglas, Order does matter unfortunately. I want the Pegs that come 'earlier' in the ordering to pick the lower positions first, if those positions are possible
14:06:35 <Welkin> Rembane: what you mean is that the numeric libraries are not the best, but they are improving
14:06:41 <Welkin> there is a Numerical-Haskell group
14:07:32 <serendependy> So that possibility would generate a guess of [Yellow, White, Black, Yellow]
14:08:10 <Guest47420> Does anyone here have previous experience with other languages like common lisp, scheme, clojure, etc.?  I'm trying to weigh my options and decide on a language that I can learn alongside c++.  I don't want to make any decisions too fast because I intend on investing a lot of time learning this next language.
14:08:10 <Rembane> Welkin: Yes, exactly.
14:08:11 <Welkin> serendependy: a right fold using Cons will preserve the order
14:08:33 <Rembane> Guest47420: I'd say go for Haskell, you will learn the most that way.
14:08:36 <Guest47420> Besides you haskellers, what other lisp-related languages do you use or recommend learning?
14:08:40 <suppi> Guest47420, what are you looking for?
14:08:44 <Welkin> Guest47420: I tried clojure before haskell and didn't like it, then I tried haskell and loved it
14:09:10 <shachaf> Is there a package for bags that can have negative numbers if elements?
14:09:11 <Welkin> Guest47420: all of those lisps you mentioned are dynamically typed, so if you prefer static typing, like me, you will prefer haskell
14:09:25 <shachaf> I.e. (-> Integer)
14:09:29 <Welkin> there are many other reasons to like haskell, such as lazy evaluation and referential transparency
14:09:38 <rcyr> LISPs have nice concepts but always felt like sloppy languages to me (Dynamic typing...)
14:09:46 <parsnip> hmm, tricky to google for >> then operator
14:10:11 <Welkin> parsnip: search hoogle for (>>)
14:10:14 <serendependy> parsnip, Use Hoogle!
14:10:21 <suppi> there are statically typed lisps, like Shen
14:10:22 <rcyr> Guest47420: If you care, Haskell magically makes you a template metaprogramming genius :P
14:10:22 <Welkin> @hoogle (>>)
14:10:23 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
14:10:23 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
14:10:23 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
14:10:30 <rcyr> Guest47420: (For C++)
14:10:40 <cow_2001> is there a list of haskell programming related concepts organized in a dependency tree?
14:10:53 <Welkin> cow_2001: in the typeclassopedia :P
14:10:57 <suppi> cow_2001, that could be cool
14:11:00 <Welkin> that is for typeclasses only though
14:11:05 <serendependy> rcyr, Speaking of, have you seen IfCxt?
14:11:06 <cow_2001> suppi: IKR!
14:11:12 <suppi> right!
14:11:12 <mniip> rcyr, did you hear, I templately metaprocrashed g++ right now
14:11:18 <Guest47420> I'm looking for a language that can be used along side c++ and be useful for small projects I might want to work on like writing parsers, interpreters, possibly a small compiler, or a CAS.
14:11:19 <cow_2001> Welkin: yeah
14:11:33 <Welkin> Guest47420: haskell sounds perfect for you then
14:11:34 <rcyr> serendependy: No, sorry
14:11:34 <cow_2001> i wanna write something like that if none exists
14:11:36 <suppi> so... Haskell basically?
14:11:42 <rcyr> mniip: Hehe :P
14:11:43 <Welkin> Guest47420: haskell is the best when it comes to parsing, compilers, etc.
14:12:02 <Welkin> Guest47420: check out Parsec
14:12:11 <DanielDiaz> hi! any library to print big numbers like... 1000000 -> 1,000,000 >
14:12:14 <DanielDiaz> ?
14:12:15 <parsnip> Welkin: so should i say ma -> mb -> mb means, take the previous result, and perform identity on the next? 
14:12:24 <serendependy> rcyr, It basically gives you one of the best features of C++ templates, specializations that let you use more efficient versions of an algorithm based on the shape of the data
14:12:34 <serendependy> Except, it's over type-classes, not values
14:12:37 <Guest47420> Cool.  Thanks.  I think I might decide on haskell then.
14:12:38 <Welkin> parsnip: ignore the first value and produce the second
14:12:38 <rcyr> serendependy: Ha! Interesting
14:12:46 <suppi> ifCxt looks cool!
14:12:52 <mniip> DanielDiaz, you mean like reverse . intercalate ',' . chunksOf 3 . reverse . show
14:12:54 <parsnip> Welkin: okay, thanks
14:13:05 <serendependy> rcyr, https://github.com/mikeizbicki/ifcxt
14:13:05 <DanielDiaz> mniip: yeah, I'm not asking how to do it
14:13:07 <Welkin> DanielDiaz: pretty-print
14:13:15 <serendependy> It's stuff like that which makes me love Haskell
14:13:22 <parsnip> i guess it's infox
14:13:23 <DanielDiaz> Welkin: thanks! taking a look...
14:13:25 <parsnip> *infix
14:13:34 <suppi> should have given the guest a link to write you a scheme in 48 hours...
14:13:39 <Odd_Bloke> I have a list of things in Haskell, and I want to get a list of empty strings of the same length; how can I achieve this?  Currently I'm doing 'emptyString x = ""; ... map emptyString myList'.
14:13:44 <Welkin> parsnip: h >> k = h >>= \_ -> k
14:14:01 <suppi> Odd_Bloke, with replicate ?
14:14:05 <mniip> Odd_Bloke, <$ ""
14:14:24 <mniip> errr
14:14:25 <mniip> $>
14:14:42 <mniip> errrrrrrr
14:14:45 <mniip> "" <$
14:14:45 <DanielDiaz> Welkin: I can't find it?
14:14:50 <mniip> :t ("" <$)
14:14:51 <lambdabot> Functor f => f b -> f [Char]
14:14:52 <suppi> <3
14:15:14 <suppi> :t (<$)
14:15:15 <lambdabot> Functor f => a -> f b -> f a
14:15:18 <Welkin> DanielDiaz: https://hackage.haskell.org/package/pretty
14:15:22 <suppi> hmm
14:15:28 <Welkin> I haven't used it, but I think it does what you are looking for
14:15:37 <Welkin> there are also many other pretty-printing libraries on hackage
14:16:01 <DanielDiaz> Welkin: I don't think that is what I'm looking for
14:16:25 <DanielDiaz> Welkin: I'm not looking for a pretty-printing library anyway
14:16:28 <Welkin> you want to print 1000000 as 1,000,000, right?
14:16:36 <DanielDiaz> Welkin: yes, but I don't want to define the function
14:16:44 <DanielDiaz> Welkin: otherwise, I would just do what mniip said
14:17:00 <guest101> Last thing before I leave, could someone recommend whether I install the haskell platform or the compiler and base libraries from haskell.org?
14:17:26 <DanielDiaz> not sure if it works exactly like that, because I believe that would print commas when they aren't need
14:17:28 <DanielDiaz> ed
14:17:34 <DanielDiaz> just tired of writing that function over and over
14:18:21 <Welkin> guest101: ghc + cabal-install
14:19:01 <Hafydd> serendependy: excuse the late reply, but it seems like what you're doing (combining nondeterminstic values) is most elegantly represented using the [] monad, which is intended for that purpose. You could write a version of allGuesses that doesn't take an initial empty guess, like this: 
14:19:04 <lpaste_> Hafydd pasted ‚ÄúallGuesses‚Äù at http://lpaste.net/140358
14:19:21 <Welkin> guest101: there is also `stack` which I have not used
14:19:56 <Hafydd> serendependy: it might also be possible to eliminate the non "good" guesses at the same time, but I don't have an immediate idea for that.
14:20:40 <serendependy> Hafydd, Yeah, that was vaguely on my mind (using the non-determinism monad []) but I'm still new to Haskell, haven't quite internalized the abstractions
14:21:30 <serendependy> Hafydd, Did you see the foldlM suggestion by Gurkenglas?
14:21:43 <serendependy> Though I do think I might prefer using do-notation
14:21:45 <Odd_Bloke> I'm looking for a library that will let me nicely format tables so they look roughly like: http://paste.ubuntu.com/12288876/.  I've tried boxes, but it doesn't seem to do column/row delimiters for me, and I'm using tabular now, but it doesn't seem to let me have no column headers (i.e. I get http://paste.ubuntu.com/12288909/).
14:21:51 <Odd_Bloke> Can anyone recommend anything?
14:22:13 <Gurkenglas> serendependy, I would inline codeInit to make allGuesses a constant, and inline fillWith, but that's just my personal dislike of names
14:23:42 <Hafydd> Heh. is "mapWithKey (,)" another way of writing "Map.toList"?
14:24:05 <serendependy> Hafydd, Ooh I think so
14:24:42 <Welkin> lol
14:25:01 <serendependy> @type Data.Map.mapWithKey
14:25:02 <lambdabot> (k -> a -> b) -> M.Map k a -> M.Map k b
14:25:11 <Welkin> serendependy: many haskell libraries provide extremely nice APIs 
14:25:12 <Hafydd> Oh, no, I suppose not quite.
14:25:20 <Welkin> take a look through the docs on hackage
14:25:23 <Hafydd> But since you're using Map's traversable instance, it should be equivalent.
14:25:25 <Gurkenglas> Yep, those are the same. I didn't know the exact properties of IntMap so I went with as little change as possible. Also I wanted to make clear my dislike of IntMap missing foldlM except by using its Foldable instance
14:25:37 <Hafydd> *Traversable
14:25:41 <Gurkenglas> *Foldable
14:26:37 <Hafydd> Ah, yes.
14:26:45 <Sonderblade> since haskell's gc moves objects, how does it handle callbacks from c ffi code into haskell?
14:27:20 <Hafydd> serendependy: well, the foldM solution goes some way to making the nondeterminism more explicit, but IMO the way I presented it is clearer.
14:27:39 <Hafydd> (And is also more functional - it doesn't involve some iterative updating of state.)
14:27:50 <serendependy> Hafydd, Yeah
14:28:44 <serendependy> Gurkenglas, Hafydd: Both of you have given me a pretty good idea of what I should do - try to express some of these operations using the non-determinism monad [].
14:28:58 <serendependy> I think maybe I should try to do that myself, it would be a good exercise
14:29:12 <serendependy> You have been a big help, thanks :)
14:30:12 <Hafydd> Welcome.
14:30:14 <ralu> is there Class with method a -> Bool ?
14:30:50 <Welkin> ralu: that is too vague to answer
14:31:08 <ralu> i want to set my Data to be instance of this class
14:31:11 <Welkin> you can create a typeclass with a function :: a -> Bool if you would like
14:31:20 <ralu> something that can be converted to Bool
14:31:29 <Gurkenglas> ralu, what laws should this typeclass have?
14:31:40 <ralu> none
14:31:43 <Welkin> haha
14:32:02 <ralu> just method that yelds Bool
14:32:13 <ralu> a -> Bool
14:32:17 <serendependy> ralu, I think you want this instead: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Coerce.html
14:32:39 <Gurkenglas> nooooo
14:32:44 <Welkin> hahahaha
14:33:02 <Welkin> why do you want to make this a typeclass?
14:33:20 <Welkin> you can just pattern match on your a and produce a Bool inside the function that need it
14:33:31 <Welkin> or just define a function that takes your specific type you want to convert
14:34:01 <Welkin> converting anything to Bool doesn't make sense
14:34:14 <ralu> i a doing interface for Fpga, and i have Data that are Direction, Status and stuf like that and they need to be all converted to Bool at some point
14:34:43 <serendependy> ralu, Bool or [Bool] ?
14:34:43 <Gurkenglas> Are each of them isomorphic to Bool?
14:34:44 <Cale> ralu: That sounds like something you should just make your own application-specific class for
14:34:54 <ralu> ok, thanx
14:35:03 <ralu> yes they are
14:35:11 <Cale> ralu: If that -- you could probably just define functions separately for each type and have it work quite well.
14:35:38 <ralu> there si more that can be easer to generalise using typeclass
14:36:49 <Hafydd> Yes, there is a class T a with a method :: a -> Bool; for example, odd :: Integral a => a -> Bool.
14:37:02 <Gurkenglas> You could use "type" as opposed to newtype or data to define Direction and Status and that would make Direction and Status merely other names for the Bool type. (Of course, you lose the safety of being unable to put a Status into a Direction.)
14:37:06 <serendependy> ralu, Each of them are isomorphic to Bool you say?
14:37:11 <ralu> yes
14:37:15 <serendependy> type Status = Bool
14:37:22 <serendependy> type Direction = Bool
14:37:23 <serendependy> etc
14:37:26 <serendependy> done :D
14:37:44 <Welkin> or newtype wrapper
14:37:49 <ralu> so what is setDirection True ?
14:37:59 <Welkin> newtype Status = { unStatus :: Bool }
14:38:06 <serendependy> ralu, dunno, it's your problem domain
14:38:07 <Welkin> newtype Status = { unStatus :: Bool }
14:38:12 <Welkin> newtype Status = Status { unStatus :: Bool }
14:38:13 <Hafydd> ralu: what in FPGA requires them to be converted to Bool, specifically?
14:38:13 <Welkin> oops
14:38:56 <Welkin> setDirection :: Direction -> Direction
14:39:12 <Welkin> setDirection Up = True
14:39:19 <Welkin> er
14:39:26 <Welkin> using the newtype wrapper though
14:39:53 <Gurkenglas> Welkin, I think you need to put a constructor name in front of those {
14:40:00 <Welkin> yeah
14:40:27 <ralu> class ToBool b where toBool :: b -> Bool 
14:40:31 <serendependy> ralu, You have some code you can lpaste for us? I think that would help
14:40:32 <ralu> this is how i done
14:41:06 * serendependy doesn't know why people laughed when I suggested Data.Coerce
14:41:18 <serendependy> s/I/he/
14:42:29 <ralu> http://lpaste.net/140359
14:45:02 <Hafydd> ralu: it sounds like what you want is not semantically a conversion to "Bool" but rather a conversion to a single bit.
14:45:12 <Hafydd> So why not just make your type an instance of Bits?
14:46:37 <Hafydd> Er... well, maybe not quite Bits, but something to do with serialisation.
14:47:36 <Gurkenglas> ralu, if you derived MonadState FpgaState in line 81, you could use put and get in place of store and getState/getPtr. (At least I hope NewtypeDeriving allows that. Why do you use newtype instead of type in line 80 anyway?)
14:49:35 <Gurkenglas> (Oh and listen to HLint. though I'd call it cProtExec, not cPROTEXEC)
14:53:52 <Gurkenglas> (HLint stuff is at the bottom of your paste)
14:53:53 <ralu> i dont want that user can change or get State
14:55:25 <ralu> i think that if user need some sort of state she should build own StateT on top of this
14:57:12 <dominik> Anyone knows, why on my emacs upon trying to start haskell-mode, it always says "symbol's function definition is void: haskell-session-lookup" ??
14:57:43 <dominik> with ghc 7.6 it worked initially, but then I updated to ghc 7.8 and now I cannot open haskell-interactive-mode anymore
14:57:53 <dominik> does anyone know why?
14:58:04 <tmtwd_> how come this doesn't work? I get the error : *** Exception: first.hs:(7,1)-(10,36): Non-exhaustive patterns in function only_onions
14:58:06 <dominik> unfortunately, I'm an emacs n000b :-/
14:58:14 <tmtwd_> http://pastebin.com/js01kQTQ
15:00:51 <Fernandos> dominik: #emacs is probably a better place to start, good luck :)
15:00:53 <geekosaur> tmtwd_, one pattern you are not matching is Lamb (Lamb Skewer). if you did not intend that to be a valid value, then you need to reformulate your type
15:01:37 <geekosaur> would have to see more code to see why you got that error, which indicates that it got something you did not describe
15:01:47 <tmtwd_> right
15:02:45 <tmtwd_> that helped thanks
15:03:18 <tmtwd_> is haskell fairly similar to ml?
15:03:52 <geekosaur> similar yet different
15:04:03 <tmtwd_> interesting 
15:04:07 <tmtwd_> I'm  reading the little mler
15:04:44 <geekosaur> there are gross syntactic similarities to SMLNJ. a number of details are different (notably : vs. :: for type signatures)
15:05:15 <tmtwd_> thats just syntax though
15:05:42 <geekosaur> yes. semantics will be quite different because most ML-family languages are strict
15:06:05 <tmtwd_> oh
15:06:14 <dominik> Fernandos: thanks, I'll try that.
15:06:14 <geekosaur> and are not pure; for example you can use "ref" types (pointers, more or less) directly in data definitions
15:06:23 <geekosaur> in SMLNJ
15:08:05 <geekosaur> s/pointers/mutable pointers/
15:10:38 <Gurkenglas> tmtwd_, did you intend to have lines 9 and 10 say _ instead of Skewer? that would make the result false on all arguments constructed using Lamb.
15:10:43 <Gurkenglas> */Tomato
15:11:41 <Darwin226> Hey guys. I need a bit of help with type familieis
15:11:54 <Darwin226> I used to have an instance like this http://lpaste.net/140360
15:13:00 <Welkin> Gurkenglas: having fun with shiskebabs eh?
15:13:22 <Darwin226> Now, I've refactored my code and the Element type family doesn't exist anymore. Instead I use a new family, ExprType and "pattern match" on the result. So, when I used to have (t ~ Element c) in contexts, I now have (JArray t ~ ExprType c)
15:13:41 <Darwin226> But now I can't seem to write my instance, which should look like this http://lpaste.net/140361
15:13:46 * geekosaur was wondering about the -Kebar...
15:14:00 <Darwin226> I get the The RHS of an associated type declaration mentions `t1', `t2'   All such variables must be bound on the LHS error
15:15:17 <Darwin226> How can I fix this? I mean, sure, the t1 and t2 are not mentioned on the LHS, but they are direct results of the c1 and c2 which ARE mentioned on the LHS
15:18:40 <yashinbasement> HI I am just concerened about the order in where block , does it matter the order of varibale we define in where clause or it's smart enough to make this work
15:18:41 <yashinbasement> https://gist.github.com/ynarwal/445c63d5e33a091c6fb8
15:19:02 <shachaf> Order does not matter.
15:19:38 <shachaf> But surely you can run your code yourself to figure that out?
15:20:04 <yashinbasement> yeah I think it's running fine
15:20:15 <yashinbasement> but I was just confirming ..
15:20:44 <Welkin> yashinbasement: order never matters unless you are sequencing expressions such as in a do-block or explicitly using >>= or >>
15:21:33 <yashinbasement> sweet 
15:29:00 <shersh> Hello, everyone! I'm just wonder to know, why I can't write type "Maybe Maybe". I know, that kind of Maybe is * -> *, so when i'm trying to give * -> * while Maybe expecting * this lead to an error. But why? Is it compiler really distinguish * and * -> *? I mean, id :: a -> a, and I can pass to id objects or functions, "a" can be every type, so this is not the case for *? 
15:29:58 <Welkin> :t Just (Just 4)
15:30:00 <lambdabot> Num a => Maybe (Maybe a)
15:30:07 <Welkin> you can shersh 
15:30:12 <Welkin> you are just not doing it right
15:30:28 <sshine> I don't think shersh wants Maybe (Maybe a)?
15:30:45 <Welkin> :kind Maybe
15:30:50 <Welkin> @kind Maybe
15:30:52 <lambdabot> * -> *
15:31:13 <Welkin> shersh: do you know about `kinds`?
15:31:18 <shersh> I don't want to have Maybe of Maybes. Perhaps, "Maybe Maybe" could have some different usage
15:31:46 <Welkin> Maybe Maybe cannot work because it doesn't match the kind
15:31:48 <shersh> Welkin: I know about kinds. I write about them in my question :)
15:31:50 <sshine> shersh, you're thinking Maybe Maybe should have kind (* -> *) -> (* -> *)? :)
15:32:21 <shersh> So * and * -> * not equal?
15:32:38 <Welkin> of course not :)
15:33:39 <srhb> It's not necessarily that obvious, since as shersh pointed out, b can unify with a -> a, so yes, there's a difference on the kind level.
15:33:48 <shersh> Welkin: but i'm confusing. Function id has type a -> a, so a can be Int or (Int -> Int), or (a -> m a), and id turns to (a -> m a) -> (a -> m a). Why kinds cannot turn from * to * -> *
15:34:10 <ralu> what si difference between (*->*) and (a->b)
15:34:31 <srhb> ralu: * reads as "type" and is a kind signature, not a type signature.
15:34:36 <Welkin> ralu: * -> * is a kind
15:34:44 <Welkin> a kind is "the type of a type"
15:34:46 <sshine> srhb, yeah, it would seem logical that if the types 'a' and 'a -> a' can unify, why can't the kinds * and * -> *, too? but I suppose * isn't actually a variable kind.
15:35:05 <srhb> sshine: Indeed, it's not a variable, it's just "type"
15:35:09 <ralu> like Functor for example?
15:35:20 <Welkin> @kind Functor
15:35:21 <lambdabot> (* -> *) -> Constraint
15:35:47 <Welkin> @kind Maybe
15:35:48 <lambdabot> * -> *
15:35:51 <Welkin> so Maybe can be a Functor
15:36:17 <sshine> shersh, so it'd be similar to trying to unify Int with Int -> Int
15:36:52 <srhb> That's a good example. :)
15:37:02 <Welkin> I never thought about it that way before actually
15:37:03 <zipper> Hello, I have the following issue with a websocket server. It blocks on L30 as it waits for the other side to accept the connection or something. How do I avoid this? http://lpaste.net/5458545108389462016
15:37:18 <zipper> Is there a way I could call sendTextData the way I call print?
15:37:19 <Welkin> I just always assumed the kinds had to match exactly
15:37:32 <sshine> except of course Int is a well-defined set and * is at best a category?
15:37:35 <Welkin> zipper: WebSockets?
15:37:40 <shersh> So if * is primitive for types it makes sense :) If we could write some datatype like data Computation f a = C (f a) a which kind is (* -> *) -> * -> * but its real kind could be (k -> *) -> k -> * so if we can have type polymorphism, k can be * or * -> *
15:37:45 <zipper> Welkin: Yes websockets
15:37:56 <Welkin> zipper: what do you mean by the way you call print?
15:37:59 <shersh> srnb: Thanks for example with Int and Int -> Int
15:38:16 <ralu> Constartint  , is this fmap ?
15:38:29 <Welkin> zipper: you can send it to the client and print it out in the console in your browser
15:38:33 <shersh> I mean thanks sshine :) 
15:38:41 <zipper> Welkin: The way I can call print continously without worrying that the socket could be in use or something
15:38:57 <zipper> Welkin: I am unable to send it to the client
15:39:05 <zipper> It blocks at Line 30
15:39:17 <Welkin> zipper: I don't see your code
15:39:37 <srhb> shersh: You might want to play around with the PolyKinds extension, but it gets a bit involved fast :)
15:39:39 <zipper> Welkin: http://lpaste.net/5458545108389462016
15:40:15 <shersh> srnb: thanks for suggesting this extension! :)
15:40:37 <Welkin> zipper: write a tiny websockets client
15:40:59 <zipper> Welkin: I actually have one.
15:41:11 <zipper> Welkin: But the client means it won't get to the browser
15:42:05 <zipper> Welkin: There http://lpaste.net/5061453778188763136
15:42:09 <Welkin> zipper, well, you are already in IO
15:42:19 <Welkin> so you could just putStrLn the data
15:42:23 <zipper> but that client just prints the output to terminal
15:42:32 <zipper> I want it to go to the browser
15:42:48 <zipper> Yes I wish to do something like putStrLn to the browser.
15:42:52 <Welkin> okay, then you need to write a client in the browser
15:42:55 <zipper> Welkin: Any idea?
15:43:12 <Welkin> zipper: yes
15:43:14 <Welkin> var ws = new WebSocket("ws://localhost:8080/");
15:43:29 <Welkin> ws.onmessage = function (m) { console.log(m); }
15:43:38 <zipper> I do have a client in the browser. I don't know why it's failing to work. tbh. Let me show you.
15:43:49 <Welkin> open up firebug
15:46:32 <louise_sullivan> #haskell-beginners
15:47:13 <zipper> louise_sullivan: Me?
15:47:36 <Welkin> zipper: I think it was a mistriggered keystroke :P
15:47:57 <zipper> Welkin: Well it's taking too short time for me to inspect https://gist.github.com/urbanslug/aab64a1161eeaa25b443
15:48:03 <Welkin> zipper: I don't see acceptRequest in your function
15:48:15 <Welkin> that is what I use anyway
15:48:44 <zipper> Welkin: Because I have to keep reusing sendTextData I am creating using my own socket.
15:48:53 <zipper> Wait let me see what I'm doing wrong.
15:50:06 <zipper> OMFG wait I think I know what's up
15:50:37 <sshine> @pl \x -> not <$> f x
15:50:37 <lambdabot> (not <$>) . f
15:51:07 <zipper> Welkin: No no no I'm using acceptRequest here: https://gist.github.com/urbanslug/aab64a1161eeaa25b443#file-gistfile1-txt-L83
15:51:35 <Welkin> oh I see
15:51:42 <sshine> is there a neat way I can rewrite 'filterM f xs' in order to logically negate f?
15:51:57 <yashinbasement> is that thing main , that drives the program , and it has to be main:: IO (), is it
15:51:59 <zipper> Welkin: Do you think there's a way I can call sendTextData without all this headache?
15:52:41 <Welkin> zipper: did you see this? "Should be preceded by the call withSocketsDo."
15:52:59 <Welkin> https://hackage.haskell.org/package/websockets-0.9.5.0/docs/Network-WebSockets.html#g:9
15:53:25 <Welkin> yashinbasement: yes, main is the entry point into the program
15:53:43 <sshine> @pl \s -> "'" ++ s ++ "'"
15:53:43 <lambdabot> ("'" ++) . (++ "'")
15:53:53 <zipper> Welkin: No :(
15:55:26 <sshine> (fmap not . f) I guess.
15:55:39 <zipper> Welkin: That didn't help really. :(
15:55:55 <Welkin> zipper: so it is waiting for a connection that it never recieves?
15:56:02 <Welkin> receives*
15:56:03 <zipper> Welkin: Yes
15:56:15 <Welkin> then the problem may be with your client
15:56:19 <TheCrafter> :t >>=
15:56:21 <lambdabot> parse error on input ‚Äò>>=‚Äô
15:56:27 <Welkin> you are listening on 0.0.0.0:5000
15:56:27 <voidzero> :t (>>=)
15:56:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:56:34 <Welkin> is your client connecting to the same?
16:00:56 <zipper> Welkin: It probably is. I don't know whether the client is lisening.
16:01:02 <zipper> It should be.
16:01:17 <zipper> Isaw some proof a while ago in the console but I'm not sure.
16:02:05 <ReinH> I wish people wouldn't drive by and use lambdabot like that, but ofc they're gone before you can mention it :/
16:02:43 <Welkin> zipper: add this
16:03:22 <Welkin> zipper: ws.onopen = function(e) { console.log("Connected"); }
16:04:16 <zipper> Welkin: On it
16:05:02 <nolrai66> ReinH: Why not?
16:05:21 <nolrai66> Or I mean why do you dislike it?
16:07:24 <glguy> nolrai66: It's rude. Lambdabot is in channel for enhancing a discussion or explanation. Personal use belongs in /msg
16:07:57 <cow_2001> Welkin: hey hoy
16:08:04 <cow_2001> Welkin: wanna help me with something?
16:08:29 <Welkin> cow_2001: what
16:08:50 <shachaf> If I was setting it up, I would make it more difficult to use lambdabot in the channel.
16:08:52 <zipper> Welkin: Yes it connects. I changed up some of the code so that it works as it should and that the WS.Connection value is passed around in an IORef.
16:09:15 <cow_2001> Welkin: i'm thinking of writing some sort of an haskell knowledge dependency tree
16:09:16 <zipper> Welkin: let me show you.
16:09:27 <cow_2001> Welkin: do you think it's useful
16:09:35 <Welkin> cow_2001: sure
16:09:39 <cow_2001> Welkin: a tree with links to sources
16:09:48 <yashinbasement> Hi I have a main how to run that multiple times 
16:09:49 <Welkin> I find myself reading lots of papers I find on the wiki
16:10:05 <Welkin> having a table of contents would be nice
16:10:12 <Welkin> "read these papers first, then these ones"
16:10:29 <cow_2001> yeah
16:10:44 <Welkin> yashinbasement: main is executed exactly once when you run the binary
16:10:50 <xpinguin> hi! is it possible to hide instances declared in GHC.Base? specifically, Functor ((,) a)
16:11:00 <nolrai66> yashinbasement: "main = main_ >> main" will run main_ an infinite number of times.
16:11:04 <Welkin> xpinguin: it is not
16:11:40 <zipper> Welkin: Aha so I have something that kinda works here. http://lpaste.net/1334016524310020096
16:11:50 <yashinbasement> so can I import the module that contains main and run it there ?
16:12:00 <zipper> Welkin: It connects and logs the first call to sendTextData to the browser.
16:13:10 <zipper> However the issue is that the connection doesn't get written to the ioRef or it doesn't get used in the next call to printer.
16:13:22 <yashinbasement> nah all good I will do in main instead 
16:13:29 <xpinguin> Welkin: unfortunate :( i was playing around with Functor instaniation for various types
16:14:03 <Welkin> xpinguin: you can declare your own MyFunctor
16:14:08 <nolrai66> There is only one law abiding Functor instance for a given (* -> *), no?
16:14:28 <xpinguin> Welkin: yeah, i guess that is the way
16:15:25 <xpinguin> nevertheless, I thought, there is a way to disable all the base (like -nostdlib in gcc), keeping just "bare" haskell
16:16:16 <Welkin> NoImplicitPrelude
16:16:24 <yashinbasement> Hi what can be a base case for a function that does function :: list -> IO () 
16:16:28 <Welkin> you can try that xpinguin 
16:16:49 <xpinguin> Welkin: is GHC.Base declared in Prelude, I thought, those are different modules
16:16:51 <Welkin> yashinbasement: you mean [a] -> IO () ?
16:17:00 <yashinbasement> yeah
16:17:06 <Welkin> xpinguin: Prelude just re-exports many other modules
16:17:14 <Welkin> yashinbasement: what is the base case for a list?
16:17:31 <yashinbasement> []
16:17:40 <Welkin> you have your answer
16:18:18 <yashinbasement> so I don't know what should be IO for that like okay function [] = .. ?
16:18:26 <Welkin> zipper: I only made a simple program with websockets
16:18:32 <Welkin> I'm not usre what you are doing wrong there
16:18:44 <Welkin> but runServer followed by acceptRequest should work
16:18:49 <zipper> Welkin: Is what I'm doing really that complicated?
16:19:01 <zipper> Welkin: Well it does as a one off.
16:19:12 <zipper> but I want to keep sending data to the browser
16:19:29 <Welkin> zipper: the socket stays open once the connection is established
16:19:42 <Welkin> you don't need to do anything extra to send more data other than apply sendTextData
16:21:34 <zipper> Welkin: My problem is the first argument to sendTextData
16:21:54 <xpinguin> Welkin: that sort of works - in a way, that avoiding Prelude import results in no-importing of GHC.Base - thanks
16:22:08 <xpinguin> yet I see there is no way to import class without it's instances
16:23:08 <xpinguin> so just custom same class is the go
16:25:44 <yashinbasement> I don't know what should be in line 3 
16:25:45 <yashinbasement> https://gist.github.com/ynarwal/c90f3720cf226cc627e4
16:26:46 <Welkin> yashinbasement: that depends on what you are trying to do
16:26:56 <Welkin> also, you should separate your pure functions from IO
16:27:00 <yashinbasement> I don't want to print anything
16:27:04 <Welkin> that is bad form
16:27:21 <Welkin> have a function :: [[String]] -> Maybe String
16:27:33 <Welkin> then in your main :: IO (), evaluate the maybe to determine what to do
16:28:30 <Clint> yashinbasement: if you want to ignore Welkin's good advice, the answer is "return ()"
16:28:32 <yashinbasement> But I want to print to a file 
16:28:51 <yashinbasement> Maybe String will do ?
16:28:54 <Welkin> yashinbasement: you can do that while still keeping the IO separate from everything else
16:29:11 <yashinbasement> can you give example please
16:30:01 <Welkin> in main, you can read in your data (from a file, from stdin), then process the data, then write it to a file
16:32:01 <Welkin> zipper: did you try it with a single server with a global IORef rather than multiple using forkIO?
16:32:13 <Welkin> at least see if that works
16:32:42 <zipper> Welkin: When I don't use forkIO for the websocket server it blocks.
16:32:55 <zipper> Welkin: A server naturally runs forever.
16:33:09 <zipper> I guess I should close the server each time.
16:33:13 <zipper> Let me see.
16:33:41 <Welkin> I meant write a simpler version with a single runServer followed by acceptRequest
16:33:47 <Welkin> then make changes to it
16:35:07 <zipper> Welkin: I don't get what you mean exactly. runServer takes the server application as an argument. It in fact provides the argument the client needs to run i.e the PendingConnection
16:36:22 <Welkin> zipper: I mean get a single one running
16:36:29 <Welkin> then try running multiple
16:36:36 <Welkin> I m not sure what you are trying to do
16:36:50 <Welkin> why won't a single server work?
16:37:39 <zipper> Welkin: I am trying to call sendTextData severally. The problem is that I can't find a way to come up with the first argument which is of type WS.Connection
16:38:37 <lingxiao> hey all
16:38:50 <lingxiao> has anyone used cassava and know how to handle some corner casese?
16:39:04 <Welkin> zipper: what do you mean?
16:39:18 <Welkin> once a connection is established, you can call sendTextData as many times as you want
16:39:38 <zipper> Welkin: I want to call sendTextData with different text data values
16:40:05 <zipper> Welkin: sendTextData :: WebSocketsData a => Connection -> a -> IO ()
16:40:24 <zipper> The problem is coming up with the value of type "Connection".
16:41:12 <Welkin> zipper: I don't understand
16:41:20 <zipper> Welkin: Which part?
16:41:30 <Welkin> you are exactly describing sendTextData
16:41:54 <zipper> Yes I want to call sendTextData as I would print or putStrLn
16:42:04 <Welkin> okay
16:42:09 <Welkin> I don't see the problem
16:42:16 <Welkin> sendTextData conn someText
16:42:30 <zipper> Welkin: The first argument to sendTextData
16:42:33 <Welkin> once you have the connection, you can use it over and over
16:42:43 <zipper> Welkin: How will I get the connection?
16:42:49 <Welkin> acceptRequest
16:42:52 <lingxiao> for example some of the field might not have any values in it ... ie "col1,col2\r\nhello,world\r\nfoo,,"
16:43:09 <Welkin> lingxiao: it handles them fine
16:43:16 <zipper> Welkin: If you look at all my previous code manually creating a connection didn't work.
16:43:23 <Welkin> lingxiao: it gives Nothing
16:43:41 <Welkin> zipper: it will block until a connection is established
16:44:02 <zipper> Welkin: yes
16:45:18 <zipper> Welkin: Creating a connection manually isn't working. The only way that works seems to be through WS.runServer
16:46:13 <zipper> Welkin: Once we create a connection via runServer we can't "get it out"
16:47:11 <Welkin> yes
16:47:19 <Welkin> wait, what?
16:47:36 <lingxiao> Welkin I am encountering errors in the following cases:
16:47:48 <Welkin> acceptRequest :: PendingConnection -> IO Connection
16:47:53 <lingxiao> http://lpaste.net/140366
16:48:04 -lingxiao(~lingxiao@2601:47:4102:6b70:a901:20e2:84c5:a39d)- examples r3 and r4 give me problems
16:48:45 <lingxiao> while r2 is working
16:49:19 <zipper> Welkin: You see the value that acceptRequest takes can only reliably be created by calling WS.runServer
16:49:58 <zipper> Welkin: and so when we create it via runServer how do we get the connection out? I tried an ioRef and failed.
16:52:42 <lingxiao> another question ...
16:53:11 <lingxiao> running let Right (_,v) = decodeByName csv
16:53:16 * hackagebot ShellCheck 0.4.0 - Shell script analysis tool  https://hackage.haskell.org/package/ShellCheck-0.4.0 (vidarhol)
16:53:19 <lingxiao> gets me v :: FromNamedRecord a => V.Vector a
16:53:27 <lingxiao> how do I inspect elements of this v?
16:53:43 <lingxiao> I can't even find the length of v
16:53:49 <zipper> Is there a mailing list I can ask haskell websockets questions? maybe haskell-web might work. Am I right?
16:54:20 <Welkin> lingxiao: the vector api
16:54:38 <Welkin> lingxiao: https://hackage.haskell.org/package/vector
16:55:04 <lingxiao> Welkin i tried some functions ...
16:56:04 <lingxiao> for example let x = Data.Vector.length v
16:56:15 <lingxiao>  No instance for (FromNamedRecord a0) arising from a use of ‚Äòv‚Äô
16:56:16 <lingxiao>     The type variable ‚Äòa0‚Äô is ambiguous
16:56:35 <lingxiao> which is funny .. why does the a in Vector a matter when it comes to length?
16:56:53 <Welkin> Œª: Csv.decode Csv.NoHeader "hello,haskell\r\nfunctors,monads\r\n" :: Either String (Data.Vector.Vector (Data.Vector.Vector String))
16:56:56 <Welkin> Right (fromList [fromList ["hello","haskell"],fromList ["functors","monads"]])
16:58:42 <Welkin> lingxiao: you need to let it know that the `a` is Person
16:59:44 <lingxiao> ok so calling let x = head v
16:59:52 <lingxiao> I get x :: FromNamedRecord a => a ...
16:59:54 <yashinbasement> this is list of (list of string) and one needs to pick one list of string and tell what is the list the person chose , I have average 4.9 number of guesses in which I can tell the right pictch but want to cut it down around 4 , any suggestions
16:59:56 <yashinbasement> https://gist.github.com/ynarwal/390e38bdd9e8c821c00a
17:00:16 <lingxiao> I would think head a would just give back some Person
17:00:27 <lingxiao> so .. what's going on here?
17:00:42 <lingxiao> looking here .. https://hackage.haskell.org/package/cassava-0.2.0.0/docs/Data-Csv.html
17:00:49 <Welkin> lingxiao: add a type annotation
17:01:06 <Welkin> like I did above
17:03:15 <lingxiao> uhh ... writing let x = head v :: Person gives error
17:03:29 <lingxiao> Couldn't match expected type ‚Äò[Person]‚Äô
17:03:29 <lingxiao>                 with actual type ‚ÄòV.Vector a0‚Äô
17:03:49 <lingxiao> or sorry .. .wrong head
17:04:00 <lingxiao> ok nvm! D:
17:04:11 <jle`> :D
17:04:30 <kaidelong> so umm, I have a deeply imperative algorithm that I like a lot, a random metaheuristic
17:04:44 <kaidelong> I'm wondering what to do about it in terms of implementing it in Haskell
17:04:52 <Welkin> kaidelong: ST monad
17:05:06 <kaidelong> that's one option, but the thing is, that exposes a different interface
17:05:16 <kaidelong> I could either be extremely monomorphic and have it like
17:05:42 <kaidelong> "my internal representation must be an unboxed vector" or even "you must be able to accept an unboxed vector of ints"
17:05:44 <kaidelong> oh
17:06:24 <kaidelong> I might not even want to expose the representation
17:06:41 <kaidelong> but have the supplied fitness function take the form [Int] -> Double
17:12:05 <kaidelong> alright so my main design tradeoff is, do I support things other than Int, and do I support pure stepping or not
17:12:37 <nocturne777> what's the common way to convert a Bytestring to an Int ?
17:13:15 <lingxiao> Welkin not sure if you can answer this question .. but I think the problem is that
17:13:17 <shachaf> There is no way.
17:13:25 <nocturne777> I am currently doing something like this: readT . decodeUtf $ bStr
17:13:29 <lingxiao> cassava handles an empty field if it's of type string, 
17:13:37 <AaronFriel> Has anyone else played with Oleg's `Eff` / More Extensible Effects?
17:13:42 <nocturne777> do most people here do it this way?
17:13:43 <lingxiao> but if the field is a number and is empty then it throws error
17:13:51 <d-snp> hey guys, something weird happened, a line that used to compile suddenly doesn't compile anymore: http://lpaste.net/140372 it compiled just 10 minutes ago
17:14:00 <d-snp> I didn't change the line, only some imports
17:14:11 <lingxiao> I can hack this by making all fields strings ..
17:14:26 <lingxiao> but im wondering if thers a better solution
17:14:50 <d-snp> it says a data constructor of that name is available, afaik it used to just use that, why wouldn't it be able to now?
17:15:05 <lpaste_> AaronFriel pasted ‚ÄúPlaying with More Extensible Effects ‚Äù at http://lpaste.net/140373
17:15:12 <nocturne777> I wonder if I should just pull in a package for this => Attoparsec
17:16:18 <AaronFriel> d-snp: You aren't referencing the right line in yourcode
17:16:34 <AaronFriel> d-snp: The error says the bad reference is at column 14, but your CBinary is at column 21
17:17:13 <AaronFriel> d-snp: I'm guessing you have a type declaration somewhere that's off, where you have some type of the form "foo :: -> ... CBinary ... -> "
17:17:31 <AaronFriel> d-snp: That would cause the compiler to trigger the datakinds warning.
17:17:49 <d-snp> alright, thanks I'll go on the hunt
17:17:53 <Welkin> lingxiao: set the type to Maybe Person
17:18:06 <Welkin> lingxiao: a ~ Maybe Person
17:18:07 <AaronFriel> d-snp: Make sure you're finding the right line in your code that the compiler error is referencing!
17:19:23 <lingxiao> ahhh! X)
17:19:23 <d-snp> AaronFriel: ah I found the offending line, you were right I used CBinary somewhere else where it shouldve been CBinaryOp
17:19:27 <d-snp> thanks :)
17:19:29 <lingxiao> everything I wanted to begin with
17:19:34 <AaronFriel> d-snp: Happy to help.
17:19:39 <lingxiao> but for lack of documentation 
17:19:58 <AaronFriel> But seriously, girls and guys of #haskell, check out Oleg's "More Extensible Effects" paper (link on /r/Haskell)
17:20:16 * d-snp goes check it out
17:20:18 <AaronFriel> I'm having quite a time of playing with it and it seems to be the panacea for monad stacks we've all been waiting for
17:20:25 <MarcelineVQ> could you just link it :>
17:20:51 <MarcelineVQ> maybe you did *scrolls up*
17:20:59 <AaronFriel> MarcelineVQ: PDF warning: http://okmij.org/ftp/Haskell/extensible/more.pdf
17:21:02 <d-snp> http://okmij.org/ftp/Haskell/extensible/more.pdf <-
17:21:04 <daniel_adeyemo> https://bpaste.net/show/2105539d0206
17:21:05 <d-snp> ok :P
17:21:16 <daniel_adeyemo> when i :load myfunction.hs
17:21:20 <lingxiao> Welkin thanks a lot! :D
17:21:22 <AaronFriel> MarcelineVQ: Here's his source code: okmij.org/ftp/Haskell/extensible/Eff1.hs
17:21:24 <daniel_adeyemo> I get error: "parse error in let binding: missing required 'in'"
17:21:32 <daniel_adeyemo> what is wrong with the code?
17:21:50 <d-snp> hmm it's too late for reading scientific papers, I'll read it tomorrow morning :D
17:21:50 <AaronFriel> MarcelineVQ: And here's me just messing around with interleaving multiple readers and writers, demonstrating the separation between effects and interpreters.
17:21:55 <Welkin> daniel_adeyemo: the error says it all
17:22:10 <MarcelineVQ> that let doesn't need to be there at all
17:22:12 <Welkin> daniel_adeyemo: let x = 5 in x
17:22:15 <AaronFriel> http://lpaste.net/140373
17:22:41 <MarcelineVQ> the word let I mean
17:23:52 <daniel_adeyemo> I had to put let to get rid of an error in the first place
17:25:26 <MarcelineVQ> but rev is correct without let
17:25:56 <daniel_adeyemo> https://bpaste.net/show/6204ad720e02
17:26:08 <MarcelineVQ> was your error due to main? use putStr $ rev "Hello"
17:26:08 <daniel_adeyemo> when i run the above  i get:
17:26:17 <daniel_adeyemo>  Couldn't match expected type `IO t0' with actual type `[Char]'     In the expression: main     When checking the type of the IO action `main'
17:26:36 <daniel_adeyemo> okay
17:27:18 <lingxiao> is there a way to make a maybe field strict?
17:27:33 <lingxiao> like Foo { field1 :: !String, field2 :: !Maybe String}
17:27:35 <daniel_adeyemo> MarcelineVQ: Parse error: naked expression at top level     Perhaps you intended to use TemplateHaskell
17:27:41 <lingxiao> field2 does not work with the annotation
17:28:06 <MarcelineVQ> daniel_adeyemo: main = putStr $ rev "Hello"
17:28:26 <daniel_adeyemo> it worked!
17:28:37 <daniel_adeyemo> please explain what went right..
17:29:21 <kaidelong> oh you know I may not have to make the tradeoff, given the existence of IfCxt
17:29:42 <kaidelong> I could accept any arbitrary basis type for the matrix with supplied mutator functions
17:29:54 <kaidelong> but specialize in the base that the basis type happens to be unboxed
17:30:06 <kaidelong> in the case*
17:31:13 <daniel_adeyemo> MarcelineVQ: why did that work. please?
17:31:43 <MarcelineVQ> I'm not sure how to explain it to someonme entirely new to it :X
17:31:54 <MarcelineVQ> It's a little complicated, other people could explain it a lot better, to put it in a very basic way putStr takes any string rev gives it and puts it into a form the main is allowed to use.
17:32:14 <MarcelineVQ> in haskell operations which perform IO are kept seperate from 'pure' functions like rev
17:32:23 <MarcelineVQ> main is how IO is used
17:33:08 <daniel_adeyemo> you mean the type of main has to be IO()
17:33:22 <AaronFriel> daniel_adeyemo: Functions at the top level aren't called automatically.
17:33:35 <AaronFriel> daniel_adeyemo: And yes, the type of main is (usually) "IO ()"
17:34:04 <daniel_adeyemo> okay...
17:34:04 <AaronFriel> daniel_adeyemo: If you put in a Haskell program `putStrLn "foobar"` on its own line, not in a function, it is a "naked expression", that is, an expression occurring outside of a function
17:34:14 <MarcelineVQ> :t putStr
17:34:15 <lambdabot> String -> IO ()
17:34:27 <AaronFriel> daniel_adeyemo: This is unlike say, Python, where the interpreter runs the program by literally going line-by-line and running every expression
17:34:28 <MarcelineVQ> putStr takes the string rev mad and makes it IO () so main can use it
17:34:31 <MarcelineVQ> *rev made
17:34:51 <AaronFriel> daniel_adeyemo: Imagine you had a C program with a line in the file that looked like `cout << "foobar"`
17:35:13 <MarcelineVQ> notice what happens though if you give rev a list of Ints, like [1..10]
17:35:15 <AaronFriel> daniel_adeyemo: That would be wrong too, because in C, statements must occur inside functions.
17:35:37 <Welkin> haskell does not have statements
17:35:41 <Welkin> everything is an expression
17:35:53 <hpc> do-syntax has statements
17:35:56 <AaronFriel> Welkin: True, but I said "a C program"
17:36:03 <Welkin> hpc: sequenced expressions
17:36:05 <AaronFriel> Welkin: I'm explaining by analogy
17:36:12 <hpc> > x <- Nothing
17:36:13 <lambdabot>  <no location info>: not an expression: ‚Äòx <- Nothing‚Äô
17:36:13 <nocturne777> I wish I could get an answer to my question :(
17:36:42 <AaronFriel> nocturne777: If the thing you're reading is really complicated, and it requires rules to parse, then you should use Attoparsec
17:36:48 <Welkin> > Nothing >>= \x -> return x
17:36:50 <lambdabot>  Nothing
17:36:56 <AaronFriel> nocturne777: If the thing you're reading has a "Read" instance that is well behaved, then use that, that's fine.
17:36:58 <hpc> Welkin: that's not what i wrote though ;)
17:37:28 <daniel_adeyemo> I think i get it better now :)
17:37:33 <AaronFriel> hpc, Welkin: pedantry about statements isn't educational to newbies.
17:37:37 <MarcelineVQ> :t print
17:37:38 <lambdabot> Show a => a -> IO ()
17:38:13 <AaronFriel> daniel_adeyemo: So just remember, expressions in Haskell must occur in functions. .hs files aren't like Python scripts where every line gets executed line-by-line.
17:38:26 <daniel_adeyemo> in really dumbed down language, every function has to be referenced somewhere else for the program to compile??
17:38:39 <AaronFriel> daniel_adeyemo: In fact, the order in which declarations in Haskell occur is irrelevant.
17:39:13 <Alpha64> that happens in almost every non trivial compiler daniel_adeyemo 
17:39:16 <AaronFriel> daniel_adeyemo: Uhm, no - but the functions you use have to be referenced *inside* functions. "main = ..." is just another function, but one you're defining
17:40:15 <geekosaur> have you worked with any compiled languages before? c, c++, java, erlang?
17:40:37 <nocturne777> AaronFriel: I am parsing Ints. I wonder if in this case it is better to just `decodeUtf8` them to Text and `read` afterwards as opposing to converting them String and then `read`.  
17:40:52 <AaronFriel> nocturne777: What is your source type?
17:40:52 <geekosaur> everything is defined in functions and there is a certain function that the runtime looks for (by convention called "main", since that's what the C runtime uses) as the program entry point
17:41:14 <AaronFriel> nocturne777: ByteString? 
17:41:29 <nocturne777> AaronFriel: ByteString, coming from Snap parameter
17:41:40 <daniel_adeyemo> yeah java and python
17:42:09 <AaronFriel> nocturne777: Yeah, you may want to verify the thing you're parsing is actually UTF8, and does your "read" return a Maybe?
17:42:22 <Alpha64> well the java equivalent of what you are doing there would be "String foo = reverse("hello");", it doesn't do much
17:42:35 <geekosaur> so this will be closer to jaa, where everything has to be within a class and "public static void main() { ...}" is the entry point (Java has you specify the class to run and it must have that definition in it to tell the JRE where to start)
17:42:45 <AaronFriel> nocturne777: Because if you do `read . decodeUtf8 $ "Foo"` you're going to have a bad time.
17:43:00 <geekosaur> ...if you have worked with java mostly in browser environments, things are different there
17:43:19 <nocturne777> AaronFriel: Thanks for confirming my intuition. I was planning to write a util function to do exactly that :)
17:44:00 <AaronFriel> nocturne777: Great, then you're doing fine. Using attoparsec to read integers is a bit overkill, but of course you can do it. It may even perform better, but... is reading integers something that will slow down your program?
17:44:14 <daniel_adeyemo> geekosaur. with your explanation why should main = rev "hello" have issues
17:44:20 <AaronFriel> nocturne777: I would say for 99.9% of applications, converting a string to an int is the least likely performance issue
17:44:25 <MarcelineVQ> because rev has the wrong type
17:44:29 <MarcelineVQ> main expects IO ()
17:44:31 <geekosaur> because in Haskell "main" has a type IO a for some a
17:44:49 <geekosaur> because by definition a program uis started "from outside" and therefore from IO
17:45:02 <MarcelineVQ> so you use print or for strings, putStr to convert the type your function returns to IO ()
17:46:03 <daniel_adeyemo> hmmm...i get it now. thanks
17:46:04 <geekosaur> java doesn't have this distinction; in some ways, the "static" part of the definition of "main" comes close-ish because there is no instance of the class inside the program at start time, so main has to be a class method. but this isn;t really very close to what's going on, just sort of analogous
17:46:29 <Alpha64> daniel_adeyemo because you are not printing anything
17:47:13 <geekosaur> so, you need to start out in IO. one of the more confusing aspects of Haskell is "main :: IO a" but the "a" is never used, so if you want to produce a result you have to use print or putStrLn or whatever; if you just pass your value back as the result of the IO action, it vanishes. :/
17:47:27 <geekosaur> so main = return $ rev "hello" -- does nothing
17:47:38 <geekosaur> main = putStrLn $ rev "hello" -- now you get your result
17:49:45 <lingxiao> Foldl by Gabriel Gonzales does not fold over a Vector right?
17:49:48 <nocturne777> AaronFriel: I see. To be honest, I have been kind of worried about the performance implications of these types of conversions. It is a relief to know that they are efficient.
17:50:17 <lingxiao> is ther any solution other than convert my V.Vector a to some [a] ?
17:51:41 <Welkin> lingxiao: the vector api has everything the list api does
17:51:49 <Welkin> Vector.foldl/r
17:52:43 <lingxiao> oh isee hmm didnt work just now thats funny
17:52:54 <Welkin> > Data.Vector.foldl' (+) 0 $ Data.Vector.fromList [1,2,3]
17:52:56 <lambdabot>      Not in scope: ‚ÄòData.Vector.foldl'‚Äô
17:52:56 <lambdabot>      Perhaps you meant ‚ÄòData.List.foldl'‚Äô (imported from Data.List)Not in sco...
17:53:26 <narrative> I added a feature to someone else's library, but now I'm trying to actually use the library in my project. How can I go about using my newer version of the library instead of the one that's currently on hackage? I'm using stack if that changes anything.
17:56:34 <hiptobecubic> narrative, add the dir containing your modified version under "packages" in your stack.yaml i think
17:57:39 <hiptobecubic> or maybe it's extra-deps...  If you look on stack's github repo's wiki there's a whole page about stack.yaml and what it can do
17:57:41 <hiptobecubic> it should say
17:58:37 <Alpha64> geekosaur does rev in this case even get evaluated if the result will not be used ?
17:58:54 <geekosaur> probably not
17:59:15 <geekosaur> but I don't know what happens inside the runtime at that point
18:01:53 <narrative> thank you hiptobecubic.
18:02:48 <lingxiao> is there a version of fromListWith for vectors? from Data.Map.Strict?
18:02:53 <lingxiao> I cant seem to find it
18:04:43 <Welkin> lingxiao: you can use a fold to emulate fromListWith
18:04:55 <lingxiao> gotcha thanks@
18:04:59 <lingxiao> !*
18:05:15 <Welkin> or you could just convert the Vector to a list
18:05:15 <Welkin> :P
18:08:12 <narrative> hiptocubic: following up.. I put the path to my version of the library in the package section of stack.yaml and it worked perfectly. Thanks again.
18:33:32 <KaneTW>  /go 24
18:33:35 <KaneTW> oops
18:37:09 <rrradical> where does the name 'row polymorphism' come from? (what's a 'row' in this context?)
18:39:17 <Arahael> rrradical: You're asking a question withtout a context, and expect us to know the context?  Should we just google "row polymorphism" and assume that the first hit provides the context?
18:40:54 <MarcelineVQ> rrradical: In other words, where did you hear about row polymorphism?
18:41:18 <hiptobecubic> narrative, nice. It should also notice changes and rebuild as necessary
18:41:43 <MarcelineVQ> hiptobecubic: stack is pretty cool, I haven't made anything large enough to need it, but I plan to!
18:41:57 <hiptobecubic> I'm a big fan
18:42:09 <Arahael> MarcelineVQ: That's a much better way of expressing that. :)
18:42:11 <rrradical> There was some discussion about it in the new records proposal. I assumed if someone didn't know the context they wouldn't try to answer my question. No I'm not asking anyone to google for me
18:42:51 <Arahael> rrradical: Unless they were dealing with, for example, rows in an database table, and wrestling with inheritance.
18:42:52 <hiptobecubic> Although recently I wished for "--allow-newer" which cabal-install supports and stack doesn't (as far as I could tell...)
18:43:06 <Arahael> rrradical: (Postgresql allows inheritance of database tables)
18:47:18 <rrradical> Here's a presentation on rows: https://www.cs.cmu.edu/~neelk/rows.pdf It seems to be a term in type theory, but I can't find a definition for it.
18:57:19 <Welkin> rrradical: another paper here: https://www.cl.cam.ac.uk/teaching/1415/L28/rows.pdf
18:59:16 <Welkin> rrradical: http://brianmckenna.org/blog/row_polymorphism_isnt_subtyping
19:01:44 <rrradical> Yea, I saw those also. They kind of assume you know what a row is. But I guess a row is just a record (as in it has 'columns', i.e. the fields)
19:01:55 <Welkin> I think that is where it comes from
19:02:24 <rrradical> Ok thanks
19:22:44 <ReinH> Er. Row polymorphism is a pretty common term.
19:23:39 <ReinH> and yes, you can just google it and use the first hit to provide context
19:23:46 <shachaf> I prefer roly polymorphism.
19:24:05 <ReinH> and indeed the next 10 hits as well
19:26:29 <lingxiao> has anyone used criterion
19:26:46 <lingxiao> and know if there's a way to read a file from disk to be used for fucntions that are benchmarked
19:26:53 <lingxiao> but not bench mark the IO action?
19:27:51 <lingxiao> say i want to run function over a string thats 267632 long ...
19:28:04 <lingxiao> I cant just paste that string into the fiel directlhy
19:28:21 * hackagebot ShellCheck 0.4.1 - Shell script analysis tool  https://hackage.haskell.org/package/ShellCheck-0.4.1 (vidarhol)
19:30:58 <lingxiao> is there a way to copy the previous line in ghci?
19:32:30 <Welkin> press the up arrow
19:35:12 <glguy> lingxiao: http://hackage.haskell.org/package/criterion-1.1.0.0/docs/Criterion-Main.html talks about how to do that and more
19:43:45 <lingxiao> is there any way to round a Double?
19:43:53 <lingxiao> or do I have to convert to Data.Decimal first?
19:44:07 <Fuuzetsu> :t (floor, ceil)
19:44:09 <lambdabot> Not in scope: ‚Äòceil‚Äô
19:44:19 <Fuuzetsu> floor at least, forgot what the other one is
19:44:42 <Eduard_Munteanu> :t ceiling
19:44:43 <lambdabot> (Integral b, RealFrac a) => a -> b
19:44:51 <jmcarthur> :t truncate
19:44:52 <lambdabot> (Integral b, RealFrac a) => a -> b
19:44:53 <jmcarthur> also
19:45:01 <Eduard_Munteanu> :t round
19:45:02 <lambdabot> (Integral b, RealFrac a) => a -> b
19:45:06 <lingxiao> hm .. but to arb precision
19:45:15 <jmcarthur> :t round
19:45:16 <lambdabot> (Integral b, RealFrac a) => a -> b
19:45:19 <jmcarthur> four ways
19:46:58 <lingxiao> jmcarthur all of them round to nearest integer though
19:47:08 <lingxiao> I'm looking for 3 decimal places 
19:47:20 <jmcarthur> you can't exactly do that with a float anyway
19:47:26 <lingxiao> without you know .. multiplying by 1000 round then divide by 1000
19:47:43 <Alpha64> Fuuzetsu ceiling ?
19:47:43 <lingxiao> hmm ... so what's best representation?
19:47:56 <Welkin> lingxiao: it is best to keep it in some standard format, then modify it when you call `show`
19:48:02 <jmcarthur> if the number of decimal digits is important, i would just go with Data.Fixed or something
19:48:24 <lingxiao> expected: 199.36237687622332
19:48:24 <lingxiao>  but got: 199.36237687622324
19:48:27 <jmcarthur> it depends one why you want it to be rounded like this
19:48:27 <Welkin> there is the Scientific package for working with high-precision numbers
19:48:29 <lingxiao> it is kind of :( I'm failing my tests because --^
19:48:31 <jmcarthur> *on why
19:48:43 <Welkin> avoid floating point arithmetic when possible
19:49:00 <Welkin> lingxiao: you can use Scientific, or Ratio
19:49:45 <lingxiao> woa man so lots of options haha
19:50:12 <jmcarthur> all with tradeoffs, keep in mind
19:50:58 <Welkin> > ((4 % 7) / 1000 + ((3 % 7) / 1000)) * 1000
19:51:00 <lambdabot>  1 % 1
19:51:19 <lingxiao> yeah can't suse data.Scientific since I'm using casava
19:51:28 <lingxiao> csv parser
19:51:34 <lingxiao> so .. No instance for (FromField Scientific) arising from a use of ‚Äò.:‚Äô
19:51:36 <lingxiao> etc
19:51:38 <andronas> http://lpaste.net/140375 - My function by itself works, but when placed into this if expression, fails with "cannot construct the infinite type."  I'm new to HAskell.  Can anyone tell me why this is happening?
19:51:42 <jmcarthur> > (sin 7)^2 + (cos 7)^2 :: CReal
19:51:44 <lambdabot>  1.0
19:51:48 <jmcarthur> > (sin 7)^2 + (cos 7)^2 :: Double
19:51:50 <lambdabot>  0.9999999999999999
19:52:08 <jmcarthur> (but i'm not really suggesting to use CReal)
19:53:02 <Eduard_Munteanu> andronas, one branch returns an element, the other a list
19:53:11 <Welkin> andronas: always write type signatures for your top level functions
19:53:21 <Welkin> andronas: the types will guide you
19:53:29 <jmcarthur> andronas: what Eduard_Munteanu said. in this case, the type checker tries to unify those types, and that results in an infinite type
19:53:43 <Welkin> andronas: start with this material
19:53:46 <Welkin> @where learnhaskell
19:53:46 <lambdabot> https://github.com/bitemyapp/learnhaskell
19:54:44 <jmcarthur> andronas: it's like this. a needs to be the same as [a]. well, that means a must have be a list of something, so now the problem has been "reduced" to [a] needs to be the same as [[a]]. well, that means a must be a list of something, etc. etc. etc.
19:55:46 <andronas> Okay. >.>  I don't quite understand what you guys are saying.
19:56:16 <jmcarthur> andronas: and i agree with Welkin. this issue is easier to understand if you are writing an explicit type signature for your function. doing this helps you learn and keeps your code easier to read, and it's what the pros do anyway, so best to get in the habit now.
19:57:16 <Eduard_Munteanu> :t if true then 5 else [6, 7]
19:57:17 <lambdabot>     Not in scope: ‚Äòtrue‚Äô
19:57:17 <lambdabot>     Perhaps you meant data constructor ‚ÄòTrue‚Äô (imported from Data.Bool)
19:57:22 <Eduard_Munteanu> :t if True then 5 else [6, 7]
19:57:24 <lambdabot> (Num t, Num [t]) => [t]
19:57:53 <Hijiri> :t if True then 'a' else "aa
19:57:54 <lambdabot>     lexical error in string/character literal at end of input
19:57:58 <Hijiri> :t if True then 'a' else "aa"
19:57:59 <lambdabot>     Couldn't match expected type ‚ÄòChar‚Äô with actual type ‚Äò[Char]‚Äô
19:58:00 <lambdabot>     In the expression: "aa"
19:58:00 <lambdabot>     In the expression: if True then 'a' else "aa"
19:58:43 <Hijiri> :t \x -> if True then x else [x,x]
19:58:45 <lambdabot>     Occurs check: cannot construct the infinite type: t ~ [t]
19:58:45 <lambdabot>     Relevant bindings include x :: [t] (bound at <interactive>:1:2)
19:58:45 <lambdabot>     In the expression: x
19:59:11 <Hijiri> that works
19:59:21 <Hijiri> works in not working
19:59:44 <dramforever> failed successfully
20:03:25 <andronas> Why does Haskell require that both branches of an expression return the same type?
20:04:11 <shachaf> They don't return anything, they *have* the same type.
20:04:13 <glguy> So that it can statically know what type the if expression is going to have 
20:04:16 <andronas> Oh
20:04:18 <Fuuzetsu> well, what is the type of the expression if it didn't?
20:04:26 <shachaf> It doesn't make sense otherwise. If you write f (if b then x else y), what is f's type?
20:04:37 <shachaf> I guess I could just be asking that simpler question.
20:04:47 <glguy> shachaf: a dependent type?
20:05:15 <dramforever> a classical example of a type system rejecting an otherwise "well-typed" program
20:05:17 <glguy> If could always return an Either :)
20:05:19 <andronas> shachaf: i kinda fixed the problem by saying head xs, but it seems like i'm doing unnecessary work >.>
20:05:29 <andronas> or could have done it a better way
20:05:35 <shachaf> glguy: Doesn't even have to be dependent.
20:05:51 <shachaf> Just polymorphic.
20:05:55 <glguy> shachaf: Yeah, that was my second "helpful" idea
20:07:42 <shachaf> I wonder what Haskell with proper first-class existentials would be like.
20:07:44 <glguy> I,I    show (if x then 'a' else 42)
20:07:45 <shachaf> How would you even write it?
20:07:50 <shachaf> glguy: Right.
20:21:57 <polyaletheia> So everyone's all like Monad!, but Applicative is a hugely underrated class.
20:22:18 <n6|Clownpiece> Yes.
20:22:20 <Clint> it sure is
20:22:29 <n6|Clownpiece> Mostly because Applicative is newer.
20:22:56 <n6|Clownpiece> Does Applicative have a Category theory interpretation?
20:23:14 <dramforever> monoidal functors
20:23:19 <dramforever> (strong?)
20:25:19 <polyaletheia> Is ApplicativeDo going to be a thing?
20:25:32 <c_wraith> I believe it's been merged into ghc HEAD
20:25:33 <polyaletheia> Or some kind of syntax?
20:25:44 <polyaletheia> Will it be in 7.12?
20:26:03 <c_wraith> I believe it's likely to be 8.0, actually.
20:27:43 <polyaletheia> I haven't heard anything about 8.0 before. What are the plans? What's the big thing that causes the major version bump?
20:27:47 <c_wraith> But either way, if it's been merged into head, it'll be in the next big release.
20:28:38 <Fuuzetsu> it's planned for 7.12
20:28:45 <c_wraith> I believe the argument is that the next version of GHC is going to have real stack traces
20:28:56 <Fuuzetsu> also 7.12 last I heard
20:28:59 <c_wraith> And that's sufficiently big of a deal to be worth going to 8.0
20:28:59 <Fuuzetsu> DWARF traces
20:38:23 * hackagebot uri-bytestring 0.1.8 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.1.8 (MichaelXavier)
20:52:09 <ARR> hayoo and hoogle are the best documentation search options? I love hayoo but it loads very slow for me sometimes.
20:56:53 <gfixler> I use hoogle from the command line and Vim
21:02:20 <kadoban> I usually use the hoogle from stackage's website. For whatever reason, hackage's seems to not yield any results most of the time.
21:06:58 <dramforever> @hoogle ^.
21:06:58 <lambdabot> No results found
21:07:02 <dramforever> @hoogle ^. +lens
21:07:02 <lambdabot> Could not find some databases: lens
21:07:02 <lambdabot> Searching in:
21:07:02 <lambdabot>   .
21:07:14 <dramforever> wait ... this thing no longer works?
21:08:57 <junge> Hello
21:09:36 * lolisa meow
21:12:20 <junge> Hello everyone
21:12:45 <junge> Nobody birds me.
21:13:30 <wei2912> junge: do you mean bides?
21:13:57 <junge> It's chinese
21:14:09 <nolrai66> Is bide a transitive verb?
21:14:36 <junge> It means nobody respond me
21:15:09 <Pamelloes> I'm trying to write the expression do { i :: Int <- liftIO $ getStdRandom (randomR (1,1000)); ... }; but I'm being told that Int is an invalid type signature. What am I doing wrong?
21:15:26 <wei2912> junge: nobody pays attention to you*
21:15:30 <Pamelloes> I'm 90% sure I've used this exact syntax before and it's worked no problem.
21:15:55 <kadoban> Pamelloes: I'm rather sure that requires an extension. What's the actual error you're getting?
21:15:56 <junge> ^_^
21:16:02 <wei2912> junge: at least according to mdbg.net
21:16:13 <jmcarthur> junge: there are a lot of people here, and it would get annoying really fast if everybody said hello when they joined, so most of us don't respond to chatter like that
21:16:14 <wei2912> i'm not familiar with the usage myself
21:16:18 <johnw> you'd need (i :: Int) in that case
21:16:24 <johnw> or maybe you need ScopedTypeVariables, but I thought the error would say that
21:16:41 <wei2912> nolrai66: "Archaic. to endure; bear." -- 
21:16:45 <wei2912> nolrai66: http://www.thefreedictionary.com/bides
21:16:48 <Pamelloes> the error does suggest using ScopedTypeVariables, it just seems weird that I'd need to use that.
21:17:02 <Pamelloes> johnw: and using parentheses fails with the exact same situation.
21:17:09 <johnw> Pamelloes: ah, ok
21:17:27 <johnw> Pamelloes: I agree there are times when ScopedTypeVariables is needed, that really has nothing to do with scoping
21:17:39 <Pamelloes> Yep, worked fine once I enabled ScopedTypeVariables.
21:17:55 <Pamelloes> I never knew ScopedTypeVariables did that....
21:18:11 <johnw> it also does it for \(x :: Type) -> ...
21:18:20 <junge> I am sorry.
21:18:52 <Pamelloes> Interesting. I guess I've just already had STV enabled whenever I've used that syntax before.
21:39:17 <pq`> would you recommmend LYAH or Real World Haskell to a beginner?
21:40:00 <Clint> lyah
21:40:25 <glguy> I was going to say "no" :)
21:40:38 <Clint> you should do so
21:40:48 <pq`> why?
21:41:50 <dramforever> they are both somewhat outdated IMHO
21:42:17 <glguy> LYAH is too silly for my tastes and doesn't give the reader anything to do along the way and RWH is probably good to take a look at after you've done some
21:42:21 <glguy> more introductory material
21:42:55 <pq`> so what introductory material should I go with? is there something the equivalent or k&r for haskell?
21:43:04 <pq`> equivalent of*
21:43:16 <c_wraith> the equivalent of K&R would be the Haskell Report
21:44:29 <dramforever> k&r is introductory material?
21:45:03 <Fuuzetsu> I don't see how the report is anything comparable to K&R
21:45:07 <dramforever> I thought it was for already somewhat advanced programmers to learn C
21:45:18 <Fuuzetsu> the Haskell report compilers would probably find that rude ;P
21:45:18 <pq`> dramforever: that's what I consider introductory
21:45:51 <pq`> although that may not work with haskell as well as it did with C
21:45:58 <dramforever> pq`: then you have a problem here, because it's highly likely that almost none of your programming experience translates to haskell
21:46:22 <pq`> dramforever: I've spent quite some time with racket if that counts
21:46:38 <dramforever> well that could make it much easier, lucky you =P
21:46:53 <glguy> It's popular to say that knowing other languages makes it harder to learn Haskell, but that seems like nonesense
21:47:04 <glguy> Going from non-programmer to programmer is a big jump
21:47:11 <Xe> haskell is only as hard to learn as you make it
21:47:14 <echo-area> Not exporting a data constructor doesn't prevent it from being shown or read back, does it?
21:47:44 <glguy> correct
21:48:24 <nolrai66> glguy: I would say other languages help way less then people expect it too.
21:48:59 <dramforever> it's really confusing to newcomers, I have to say
21:49:03 <nolrai66> Like if you know C, then learn ..Objective C, or Java or even Java Script, knowing C helps a lot.
21:50:07 <pq`> Maybe a better question for me to ask is: How did you people go about learning it for the first time?
21:50:26 <nolrai66> Read lots of differnt short tutorials over the course of a summer.
21:50:36 <nolrai66> Played around with ghci a lot.
21:50:42 <dramforever> they say, "I know programming, and I don't want you to show me these features I don't understand. I want you to show me how can I do things like for-loops"
21:50:53 <echo-area> glguy: That sounds a little bit insecure
21:51:16 <dramforever> echo-area: don't derive Show and Read for your types, then
21:51:42 <nolrai66> forM [1..3] print
21:51:50 <nolrai66> Works and is a for loop.
21:51:55 <Pamelloes> Wait, really?
21:52:07 <Pamelloes> I have honestly never used that function.
21:52:14 <glguy> echo-area: Any function you write and export to construct that type will be able to construct it, including read
21:52:19 <dramforever> nolrai66: screw it....it was just an example
21:52:22 <nolrai66> Its just "flip mapM". 
21:52:34 <nolrai66> Yeah, sorry. I am pedantic.
21:52:43 <echo-area> glguy: Right, I just realized this.  This is unavoidable
21:52:59 <nolrai66> And using that everywehre you would use for in C++ would lead to very strange haskell code.
21:53:16 <Pamelloes> is mapM just sequence . fmap?
21:53:41 <dramforever> nolrai66: exactly
21:53:42 <Pamelloes> (well, not "." but hopefully you know what I mean :)
21:54:20 <dramforever> the haskell ecosystem in general is somewhat bad at marketing
21:56:06 <nolrai66> Pamelloes: I think modoulo some performance? Yes.
21:56:30 <Clint> Pamelloes: it used to be before FTP
21:56:39 <Pamelloes> FTP?
21:56:54 <Clint> mapM f as       =  sequence (map f as)
21:57:13 <dramforever> @src mapM_
21:57:14 <lambdabot> mapM_ f as = sequence_ (map f as)
21:57:24 <nitrix> @src mapM
21:57:24 <lambdabot> mapM f as = sequence (map f as)
21:57:38 <Clint> and now it's traverse
21:57:50 <tpsinnem> hey, i'm reading "Freer monads, more extensible effects" (http://dl.acm.org/citation.cfm?id=2804319) and it seems to have some code i'm not familiar with
21:58:17 <Pamelloes> so mapM = seqence "." traverse?
21:58:23 <Clint> no
21:58:36 <Clint> Pamelloes: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Traversable.html#mapM
21:58:39 <tpsinnem> on page 4 (or 97 depending on how you're counting), there's: "type FTCQueue (m :: ‚àó ‚Üí ‚àó ) a b"
21:58:55 <Pamelloes> Oh, I see.
21:58:55 <tpsinnem> but there's no right-hand-side to this
21:59:25 <nitrix> @pl sequence (map f as)
21:59:25 <lambdabot> sequence (map f as)
21:59:42 * nitrix shrugs.
21:59:47 <Pamelloes> nitrix: You could technically do ((.).(.) sequence fmap
21:59:49 <Clint> @pl \as -> sequence (map f as)
21:59:49 <lambdabot> sequence . map f
21:59:55 <Pamelloes> or that
22:00:07 <Pamelloes> And I forgot  a close paren :/
22:00:07 <pacak> nitrix: What kind of answer do you expect in this case?
22:00:08 <Pamelloes> )
22:00:17 <tpsinnem> ^ can anyone tell me what haskell feature that is?
22:00:35 <shachaf> tpsinnem: In a class declaration?
22:00:53 <shachaf> tpsinnem: That feature is called associated types.
22:01:27 <tpsinnem> shachaf: maybe it's supposed to be, but it seems to be omitted
22:01:39 <nitrix> pacak: I was wondering if it'd point-free expressions or give recommendations on which arguments to pick.
22:01:54 <nitrix> pacak: I see that isn't the case.
22:02:22 <shachaf> tpsinnem: Oh, that doesn't look like code at all.
22:02:46 <shachaf> tpsinnem: I mean that it looks like they're specifying an interface for humans to read.
22:04:08 <tpsinnem> shachaf: hmh, well, it's confusing
22:04:08 <tpsinnem> :)
22:28:01 <adarqui> hey, when using stack.. how do you add a local package, similar to how i do with cabal add-source? anyone know?
22:28:43 <jmcarthur> adarqui: list it in the packages section of your stack.yaml
22:29:24 <adarqui> eek, how did i miss that. thanks alot jmcarthur. trying stack build now, seems to be working so far
22:30:49 <adarqui> looks good!
22:37:10 <res0001> (absolute newbie here) why does the following not compile??
22:37:42 <res0001> lucky :: (Integral a) => a -> String
22:38:28 * hackagebot linearscan 0.11 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-0.11 (JohnWiegley)
22:38:30 * hackagebot linearscan-hoopl 0.11 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.11 (JohnWiegley)
22:38:37 <res0001> lucky 7 = "LUCKY NUMBER SEVEN!"
22:38:49 <res0001> lucky x = take x "abcd" 
22:38:54 <res0001> (end)
22:39:08 <kadoban> res0001: What's the error?
22:39:51 <res0001> The error is ...
22:39:52 <jmcarthur> res0001: the silly thing about take is it expects an Int
22:39:53 <res0001> test.hs:14:16:
22:39:53 <res0001>     Couldn't match expected type ‚ÄòInt‚Äô with actual type ‚Äòa‚Äô
22:39:53 <res0001>       ‚Äòa‚Äô is a rigid type variable bound by
22:39:53 <res0001>           the type signature for lucky :: Integral a => a -> String
22:39:53 <res0001>           at test.hs:12:10
22:39:54 <res0001>     Relevant bindings include
22:39:56 <res0001>       x :: a (bound at test.hs:14:7)
22:39:58 <res0001>       lucky :: a -> String (bound at test.hs:13:1)
22:40:00 <res0001>     In the first argument of ‚Äòtake‚Äô, namely ‚Äòx‚Äô
22:40:02 <res0001>     In the expression: take x "abcd"
22:40:06 <jmcarthur> res0001: but you are saying you want the function to be more polymorphic than that
22:40:33 <kadoban> Oh, right that. res0001, just for next time: Paste code/errors: http://lpaste.net/new/haskell
22:40:48 <jmcarthur> res0001: so you can either change your type signature to say Int instead of Integral a => a, or you can use fromIntegral to convert x to an Int when using take
22:41:22 <kadoban> You could use genericTake as well, I forget what module that comes from
22:42:26 <res0001> ok, let me try that ... and paste link noted ... thanx
22:42:49 * hackagebot linearscan 0.11 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-0.11 (JohnWiegley)
22:42:49 * hackagebot linearscan-hoopl 0.11 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.11 (JohnWiegley)
22:44:22 <jle`> res0001: yeah, the problem is that you told ghc that your function can take *any* instance of Integral...like Integer, for example...but you used x on `take`, but `take` only takes Int's
22:44:37 <jle`> it can't take Integer, etc.
22:46:31 <res0001> the simple change from Integral to Int didn't work ... see http://lpaste.net/140381
22:47:11 <kadoban> res0001: Int is a type, you'd have to do  lucky :: Int -> String             Integral is a typeclass, which is different.
22:50:30 <res0001> <kadoban> ok, that works now ... I'm literally trying haskell for the first time today, so I need to study this issue a bit.  Thanks again. 
23:17:24 * hackagebot linearscan 0.11 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-0.11 (JohnWiegley)
23:17:24 * hackagebot linearscan-hoopl 0.11 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.11 (JohnWiegley)
23:23:38 <junge> where is laowang?
23:26:43 <watsy> hello @junge
23:55:13 <adas> i have a weird error after installing hdevtools via stack "Cabal error: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times).
23:55:33 <adas> hdevtools is in PATH
23:57:03 <adas> i get that error when I do `stack exec hdevtools check src/Lib.hs
23:57:34 <adarqui> when using stack.. i have a project which references files locally, via some $(embedFile blah) template haskell function.. this is part of yesod. however, when running stack ghci in another library that depends on my yesod lib, it breaks due to being unable to find the files. anyone have an idea how to resolve that? i mean i can hack it up by symlinking etc.. but..
23:57:39 <adarqui> im searching, unable to find anything
23:58:27 <zyla> adas: hdevtools probably invokes cabal internally, and it doesn't play well with "stack exec"
