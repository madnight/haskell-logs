00:00:42 <adas> zyla: so there is no way to use hdevtools at the moment?
00:01:20 <adarqui> ok found an issue; https://github.com/commercialhaskell/stack/issues/674
00:01:22 <zyla> adas: I don't know, but I had a similar problem and just used a sandbox
00:03:28 <adarqui> the workaround in that issue works, for example: cd ../yesod && stack --stack-yaml ../notes/stack.yaml ghci yesod
00:03:30 <adarqui> cool, gn!
00:07:20 * hackagebot yesod-pnotify 0.6.0 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-0.6.0 (KatsutoshiItoh)
00:08:33 <Guest31> Textual has sent 44 messages since startup with a total of 3,274 messages received. The last message received on this connection occured 14 seconds ago. This all equals roughly 404 KB in and 688 bytes out worth of bandwidth.
00:11:08 <zyla> adas: It's a cabal issue, seems to be fixed in cabal-install-v1.22.2.0
00:12:26 <zyla> adas: https://github.com/haskell/cabal/commit/462d5057ddcf69aeaeb8e594fb5ba23816c34e0e
00:17:21 * hackagebot moesocks 0.1.2.20 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.2.20 (JinjingWang)
00:21:53 <adas> zyla: that fix was ages ago. surprised it might not be in stackage LTS 3.4
00:22:19 <gamegoblin> Is there a function that goes [Maybe a] -> Maybe a that extracts the first Just value or, if there are no Just, returns Nothing?
00:22:40 <gamegoblin> e.g. [Nothing, Just 1, Nothing, Just 2] == Just 1
00:22:58 <adas> gamegoblin: there is. can't remember the name though. hoogle is ur friend
00:23:05 <gamegoblin> adas: I tried, couldn‚Äôt find anything
00:23:22 <mauke> > msum [Nothing, Just 1, Nothing, Just 2]
00:23:24 <lambdabot>  Just 1
00:23:31 <gamegoblin> msum []
00:23:46 <gamegoblin> > msum ([] :: [Maybe Int])
00:23:47 <lambdabot>  Nothing
00:23:52 <gamegoblin> > msum [Nothing]
00:23:53 <lambdabot>  Nothing
00:23:54 <gamegoblin> Cool
00:23:56 <gamegoblin> Thans
00:30:54 <nshepperd> > foldMap First [Nothing, Just 1, Just 2]
00:30:56 <lambdabot>  First {getFirst = Just 1}
00:31:10 <nshepperd> > foldMap First []
00:31:12 <lambdabot>  First {getFirst = Nothing}
00:31:41 <nshepperd> does the same thing as msum, but a bit more obvious naming
00:35:16 <Xnuk> :t msum
00:35:17 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
00:37:09 <nshepperd> does the same thing as (msum :: t (Maybe a) -> Maybe a) I should say
01:28:14 <the_2nd> how can I write the result here to a file? http://pastebin.com/Rmrkw9tH
01:28:32 <the_2nd> without the let b, I get an error since an IO action is returned
01:30:08 <liste> the_2nd you need to convert the IO action to a ServerPart action
01:30:17 <liste> liftIO does that
01:30:57 <liste> :t liftIO
01:30:58 <lambdabot> MonadIO m => IO a -> m a
01:35:47 <the_2nd> liste, working, thanks
01:35:59 <the_2nd> any quick way to convert a json string to a yaml string?
01:36:37 <eatsfoobars> the_2nd: something like this http://jsontoyaml.com/#haskell
01:37:23 * hackagebot yaml 0.8.15.1 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.15.1 (MichaelSnoyman)
01:37:35 <the_2nd> json : [ {"name" : NAME, "value" : VALUE }, ...  ]   => NAME : VALUE
01:38:52 <liste> the_2nd 
01:38:58 <liste> json is already a subset of yaml
01:39:09 <liste> so you can feed json into yaml parser and it'll be happy
01:39:47 <liste> so `id' is a quick way to convert json string into yaml string :D
01:42:02 <liste> but to get the format you want you'd need something like http://hackage.haskell.org/package/yaml-0.8.14/docs/Data-Yaml.html
01:42:34 <liste> or even http://hackage.haskell.org/package/yaml-0.8.14/docs/Text-Libyaml.html
01:54:08 <paldepind> I'm doing this import "import Data.Text.Lazy (Text)" but still GHC tells me: "Not in scope: data constructor ëTextí". What am I missing? It seems like I'm doing an unqualified import of the constructor?
01:54:39 <liste> paldepind that only imports the type
01:54:55 <liste> Text(Text) imports the constructor too, but I'm not sure if it's exported
01:55:14 <liste> why would you use the data constructor?=
01:55:37 <paldepind> liste, Oh! That makes sense. It also explains why I had no trouble in another file that only used the type.
01:56:14 <paldepind> liste, I need to construct instances of the type?
01:56:45 <liste> paldepind that's what pack and fromString are for
01:57:18 <liste> :t T.pack
01:57:19 <lambdabot>     Not in scope: ‚ÄòT.pack‚Äô
01:57:20 <lambdabot>     Perhaps you meant ‚ÄòBS.pack‚Äô (imported from Data.ByteString)
01:57:27 <liste> :/ lambdabot can't Text
01:58:20 <paldepind> liste, I see. You're right. I shouldn't be using the data constructor.
01:59:32 <paldepind> Doing a closer look there actually is no data constructor called Text in the package.
01:59:56 <paldepind> I still get the type world and the data world mixed up :(
02:02:43 <paldepind> liste, Thank you!
02:03:04 <liste> you're welcome (:
02:11:24 <jle`> 1ch1j0j142
02:11:38 <jle`> oops, wrong window
02:13:02 <liste> better change it if it's a password
02:13:15 <breadmonster> How do monadic parser combinators work?
02:13:21 <breadmonster> jle`: lol cool password.
02:14:14 <breadmonster> I'm going to try to reimplement Parsec.
02:14:48 <jle`> not a passwd definitely :)
02:15:03 <breadmonster> Haha okay.
02:15:17 <jle`> breadmonster: there was a nice tutorial on the chalmers lesson series
02:15:42 <breadmonster> jle`: On use or implementation?
02:15:56 <jle`> i always liked this one http://www.cse.chalmers.se/edu/year/2010/course/TDA451_Functional_Programming/#toc10
02:15:58 <jle`> on implementation
02:16:06 <jle`> and subsequent use
02:18:08 <mniip> is there anything like Map.toListWith
02:18:19 <mniip> (k -> a -> r) -> Map k a -> [r]
02:19:05 <mniip> probably not
02:19:54 <jle`> uncurry f . toList, i suppose
02:20:51 <mniip> map (uncurry f)
02:20:54 <jle`> mhm
02:21:03 <mniip> that works, somewhat
02:21:33 <jle`> :t \f -> map (uncurry f) . M.toList
02:21:34 <lambdabot> (a -> b1 -> b) -> M.Map a b1 -> [b]
02:22:37 <jle`> :t \f -> M.elems . M.mapWithKey f
02:22:38 <lambdabot> (k -> a1 -> a) -> M.Map k a1 -> [a]
02:22:47 <jle`> that too mniip :)
02:29:51 <Gurkenglas> Bad idea, maps are strict in the keys.
02:30:52 <yrlnry> Thanks folks, you solved my problem!
02:33:44 <Gurkenglas> Will (i, l) = (init xs, last xs) be optimized?
02:52:26 * hackagebot mole 0.0.1 - A glorified string replacement tool  https://hackage.haskell.org/package/mole-0.0.1 (wereHamster)
02:52:28 * hackagebot mole 0.0.2 - A glorified string replacement tool  https://hackage.haskell.org/package/mole-0.0.2 (wereHamster)
02:53:09 <ChristianS> Gurkenglas: better use pattern maching: (i:l)
02:53:32 <Gurkenglas> ChristianS, init and last, not head and tail
02:53:44 <ChristianS> Gurkenglas: oops, with reserve then, maybe
02:53:49 <ChristianS> reverse*
02:54:14 <ChristianS> i don't think it'll be optimized otherwise
02:54:52 <Gurkenglas> Two reverses, you mean, unless you were giving general advice to have the list the other way round in general if I don't use head/tail? Not my code, I just saw someone calling init and last.
02:55:47 <ChristianS> case reverse ls of { (i, l) = ...; [] = --deal with the error }
02:56:21 <ChristianS> ok, you'd have to reverse l again, hmm
02:56:37 <ChristianS> it's complicated!
02:57:41 <Gurkenglas> :t uncons --All I ask for is unsnoc as a parallel to uncons :D
02:57:42 <lambdabot> [a] -> Maybe (a, [a])
02:59:17 <ChristianS> Gurkenglas: that actually exists, in Data.List.Extra (extra package)
03:00:02 <Gurkenglas> I guess I coulda went to hayoo myself ._.
03:02:48 <Gurkenglas> http://hackage.haskell.org/package/extra-1.4.1/docs/src/Data-List-Extra.html#unsnoc I think they should make that where an unrefutable pattern so init can be inspected before the list is traversed.
03:16:36 <jle`> Gurkenglas: you might benefit from using a data type that has O(1) uncons from the end, as well
03:16:41 <jle`> like Data.Seq
03:16:56 <jle`> er, Data.Sequence
03:17:07 <jle`> http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Sequence.html
03:19:12 <saulzar_> Does anyone know what the lifted [] is from singletons?  I presume it's not '[] because that's the lifted empty list.  Trying to  map a list of types   '[A, B, C] to  '[[A], [B], [C]]
03:22:34 <shachaf> What's the difficulty?
03:26:23 <saulzar_> It's probably easy, I just don't quite understand how function application works.. I understand how I can write a type class to do it, but not so much using 'Map'
03:27:06 <shachaf> type family V xs where { V '[] = '[]; V (x ': xs) = '[x] ': V xs }
03:32:27 * hackagebot haste-compiler 0.5.1.3 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.1.3 (AntonEkblad)
03:32:56 <liste> what's the difference between haste and ghcjs?
03:33:35 <saulzar_> shachaf, Thanks - that'll certainly do the trick. :)
03:40:12 <Darwin226> Hey guys. Is there any way to give integer literals a type level representation on top of the value level representation? So I could for example write `magic 1` and have it's type be `Magic '1`
03:40:49 <mniip> Darwin226, no, but you can have Magic 1 automatically turn into magic 1
03:41:09 <Darwin226> That's not really good enough...
03:41:19 <mniip> why not
03:41:32 <Darwin226> mniip: Well, it's the opposite of what I want.
03:41:45 <mniip> what do you want to do
03:42:24 <koral> Hello
03:42:26 <Darwin226> mniip: Ideally the magic function could just be skipped using something like rebindable syntax but I don't really see that happenning.
03:42:41 <liste> hello koral
03:42:55 <Darwin226> mniip: What I want to do is write code that looks as close as possible to regular haskell, but expose the structure to the type level
03:43:39 <Darwin226> mniip: I've managed to do that with everything so far up to the point of literals
03:43:41 <mniip> I'm afraid you're not getting that kind of stuff with literals
03:43:51 <mniip> zero/succ maybe
03:43:55 <mniip> but not literals
03:44:17 <Darwin226> mniip: So my only two options are TH or somethng like (m 1 :: M 1)
03:44:33 <koral> does a class exist to model types that have an inherent "null" value ? Basically, the "missing" part of semigroups that would make them monoids
03:44:37 <mniip> the third option is what I described
03:44:41 <mniip> (mkM :: M 1)
03:44:45 <Darwin226> mniip: Well, I only really care about the type level rep, so (m :: M 1)
03:44:52 <mniip> yes
03:45:25 <Darwin226> mniip: That will have to do then, thanks
03:45:31 <liste> koral Data.Default ?
03:46:04 <mniip> koral, uhh, Monoid?
03:46:04 <liste> @hackage default
03:46:04 <lambdabot> http://hackage.haskell.org/package/default
03:46:30 <liste> @hackage data-default -- sorry, this one
03:46:30 <lambdabot> http://hackage.haskell.org/package/data-default -- sorry, this one
03:46:39 <koral> mniip: monoid without the + operator
03:47:23 <mniip> if it's the value that makes a semigroup a monoid
03:47:28 <mniip> then surely it'll be a monoid?
03:47:52 <koral> liste: that would work, but semantically, I'm not sure Data.Default was meant to represent null values, rather a default valid one
03:48:07 <cocreature> without a monoid operation it's kinda meaningless because you can't give any laws
03:48:10 <Gurkenglas> Which lens function did this and how should I have figured that out?
03:48:11 <Gurkenglas> @type (flip id . (Identity .))
03:48:12 <lambdabot> (a -> a1) -> ((a -> Identity a1) -> c) -> c
03:48:42 <koral> mniip: I realize it doesn't make sense to talk about "zero" without talking about addition, but what I'm trying to model is the existence of a singularity, and a semantically null one
03:48:48 <Gurkenglas> Oh wait I guess I need to put runIdentity after that too...
03:49:52 <liste> without laws, what's the real difference between any arbitrary null/default value?
03:49:56 <koral> cocreature: I have at least a valid use case: Just myNullValue == Nothing should return True
03:50:32 <liste> @check \a -> Just a == Nothing
03:50:34 <lambdabot>  *** Failed! Falsifiable (after 1 test):
03:50:35 <lambdabot>  ()
03:51:06 <Gurkenglas> liste, you just proved that false for some case, not all cases.
03:51:19 <liste> yeah, I know
03:51:34 <liste> bit of a brain failure
03:52:30 <koral> liste: from `(Just myNullValue) == Nothing = True`, I can derive other useful facts
03:52:48 <koral> liste: [nullValue, nullValue, validValue] == [validValue] = True
03:52:53 <Gurkenglas> koral, why not make myNullValue Nothing and use join before comparing Just Nothing with Nothing?
03:53:41 <koral> Gurkenglas: because some existing types have inherent pathological null values (e.g. Text, ByteString) that I want to ignore
03:54:33 <koral> Gurkenglas: unless you show me the SemiGroup non monoidal equivalent of Text, I have to deal with "" since the type system can't prevent those values from happening
03:55:13 <koral> Gurkenglas: and in many cases, I want Just "" to behave exactly as Nothing
03:55:29 <koral> so I'm trying to build a generic solution to this issue
03:56:19 <liste> but Just "" /= Nothing unless you have your own equals
03:56:31 <Gurkenglas> :t (>>= (\s -> if s == "" then Nothing else Just s))
03:56:32 <lambdabot> Maybe [Char] -> Maybe [Char]
03:56:33 <Gurkenglas> How about this
03:57:05 <Gurkenglas> Make a function that turns all the values you don't want into Nothing
03:57:42 <koral> liste: hmm right, so maybe I just want a data type like Maybe with a distinct Eq instance
04:00:03 <koral> Gurkenglas: that's the manual and tedious solution to the problem
04:00:27 <koral> Gurkenglas: I'm looking for a solution where the type system does it for me
04:02:33 <liste> koral you mean something like this? data Present a = Present a | Absent; instance Eq (Present Text) where ...
04:03:35 <Gurkenglas> koral, do you also want (Present "" >>=) == const (Present "")?
04:04:19 <koral> liste: something like that I guess, let me think about it
04:05:45 <koral> Gurkenglas: I would say that the law I'm trying to model has no monadic interpretation, so no Monad instance
04:07:12 <koral> liste: maybe something like this instead: `class Invalid t where invalid t :: Bool; instance (Invalid t) => Eq (Present t) where ...`
04:07:58 <koral> liste: `Present a == Absent = invalid a`
04:09:37 <koral> Gurkenglas: now that I think about it, there would be a monadic interpretation indeed: (Present "" >>=) == const (Present "") would be False
04:10:09 <koral> hmmm, would be True actually
04:10:19 <koral> if I want to be consistent with the Maybe behavior
04:12:29 * hackagebot language-qux 0.1.1.3 - Utilities for working with the Qux language  https://hackage.haskell.org/package/language-qux-0.1.1.3 (hjwylde)
04:32:30 * hackagebot mole 0.0.3 - A glorified string replacement tool  https://hackage.haskell.org/package/mole-0.0.3 (wereHamster)
04:35:37 <sinelaw> hi! is there a type class with methods like: empty :: f a, singleton :: a -> f a, append :: f a -> f a -> f a
04:35:37 <sinelaw> ?
04:35:52 <sinelaw> like a Monoid with addition "singleton" method
04:35:53 <obadz> Monoid?
04:36:07 <sinelaw> and parameterized (* -> *)
04:36:10 <liste> sinelaw Alternative?
04:37:10 <liste> it has those plus <*>
04:37:45 <sinelaw> liste: right, I want without <*>
04:38:51 <sinelaw> and not (neccessarily) a functor
04:38:59 <sinelaw> so that things like Set will work too
04:42:30 * hackagebot graphviz 2999.18.0.0 - Bindings to Graphviz for graph visualisation.  https://hackage.haskell.org/package/graphviz-2999.18.0.0 (IvanMiljenovic)
04:47:22 <sinelaw> ReinH: maybe you know? looking for a non-functor/applicative "pointed monoid" (with kind * -> *), methods: empty :: f a, singleton :: a -> f a, append :: f a -> f a -> f a
04:48:04 <sinelaw> instance Foo [a] where empty = []; singleton = (:[]), append = (++)
04:51:41 <cocreature> sinelaw: can't you just require that it's an instance of monoid and an instance of pointed?
04:52:04 <cocreature> throw in some constraint kinds and you can give that an alias
04:53:47 <sinelaw> no, they have different kinds
04:54:03 <cocreature> oh right, damnit
04:54:09 <litb> hello all
04:54:17 <litb> is it valid for a lambda to start with a pattern?
04:54:22 <litb> i.e  \(a, b) ->
04:54:22 <sinelaw> yes
04:54:35 <litb> i have seen in some text on the internet that you need a case in the body instead
04:54:38 <litb> so i am not sure now
04:54:46 <litb> is it a recent haskell feature?
04:55:09 <sinelaw> nope
04:55:17 <liste> if you want multiple patterns then you need the case in body (unless you use XLambdaCase)
04:55:37 <sinelaw> litb: there's lambda case, which is "new" syntax
04:55:48 <sinelaw> \case -> Pat1 -> .. , Pat2 -> ...
04:56:02 <sinelaw> by , I mean ; or newline
04:56:10 <litb> ah nice
04:56:26 <sinelaw> litb: https://www.reddit.com/r/haskell/comments/wp70x/lambdacase_and_multiway_if_added_to_ghc_head_for/
04:56:27 <litb> i had no idea
04:57:02 <sinelaw> litb: but if it's a single pattern, then yes, you just use it at the lambda
04:57:52 <litb> ah, so the \(x, y) case is also new, and a shorthand for \case -> (x, y) ->
04:58:12 <litb> errm, the first case was meant to be english not haskell :p
04:59:23 <pertl> is the problem of name clashes in data records solved (besides prefixing the property names) ?
04:59:38 <pertl> I only found a type-class proposal
05:01:01 <R0b0t1> oh that bugged the crap out of me too
05:01:08 <R0b0t1> and no don't think so
05:01:17 <pertl> too bad :-(
05:02:47 <tempname11_> what do you guys use for vim syntax highlighting?
05:03:07 <liste> tempname11_ :syntax on
05:03:45 <tempname11_> liste: tried that, and it doesn't even highlight types differently for me.
05:07:30 <liste> doesn't for me either. never thought of that
05:09:45 <liste> found this http://www.vim.org/scripts/script.php?script_id=3034 and this https://github.com/travitch/hasksyn
05:12:13 <sinelaw> emacs has some nice support :)
05:12:31 * hackagebot sloane 4.1.0 - A command line interface to Sloane's OEIS.  https://hackage.haskell.org/package/sloane-4.1.0 (AndersClaesson)
05:17:29 <litb> hmm how can i set that a ADT constructor accepts an ad-hoc polymorphic type?
05:18:00 <litb> data E = AddE (Num a) (Num b)   doesn't work
05:21:59 <frerich> litb: Do you mean 'data (Num a, Num b) => E a b = AddE a b'? That would require the extension 'DatatypeContexts', which is generally considered to be a bad idea in the first place.
05:22:21 <litb> frerich: ah i see
05:22:32 <litb> yes I meant that. why is it be a bad idea?
05:22:47 <litb> it would constraint the types to be instances of NUm which seems to be a good idea
05:23:35 <ski> you would still need to add the constraints to type signatures
05:23:49 <ski> it would just make sure you can't avoid doing it
05:23:55 <frerich> litb: It means that *any* function operating on values of type 'E a b' would need those constraints - even if it doesn't need them. Consider e.g. a function for testing two 'E a b' values for equiality.
05:24:16 <litb> ah like   eval :: (Num a, Num b) => E a b -> V
05:24:19 <litb> i see
05:25:20 <litb> it would seem to me that the compiler could automatically infer those constraints from the definition of E
05:25:36 <frerich> litb: For instance, you couldn't even define 'getA :: E a b -> a'. It would have to be 'getA :: (Num a, Num b) => E a b -> a'
05:26:10 <litb> the compiler could infer the constraints for us
05:26:25 <frerich> litb: You might find https://ghc.haskell.org/trac/haskell-prime/wiki/NoDatatypeContexts interesting
05:26:58 <litb> thanks you've been a great help
05:27:13 <srhb> Mind that the page is a little old and the extension is considered deprecated. :)
05:27:19 <srhb> (So don't do it.)
05:29:52 <tempname11_> liste: thanks for the links, will try them out
05:33:04 <akegalj> I am trying statically link binary with "ghc -optl-static" but I got http://lpaste.net/140390 . Does this means libpg on my system is o different version then haskell bindings are expecting?
05:35:18 <tempname11_> liste: the hasksyn one looks great!
05:35:31 <tempname11_> just what I needed
05:46:52 <litb> is it possible to say  do { pattern <- someValue }  and if operating in the Maybe monad, have it yield Nothing if the pattern doesn't match ?
05:47:41 <the_2nd> http://pastebin.com/fddw0tUW
05:47:49 <the_2nd> how can I do what I wrote in comments there?
05:48:20 <litb> ahh "This operation is not part of the mathematical definition of a monad, but is invoked on pattern-match failure in a do expression" for fail.. i will try
05:52:12 <srhb> the_2nd: Take a look at System.Process
05:54:15 <ski> > do False <- return True; return ()  :: Maybe ()  -- litb ?
05:54:17 <lambdabot>  Nothing
05:56:23 <litb> hm
05:56:50 <the_2nd> srhb, got it
05:58:19 <litb> ski: hmm i tested it on   do { (a:as) <- [3]; return a }
05:58:44 <tempname11_> ski: wow, it took me a while to recognize that you used Bool pattern matching there... I suppose it uses 'fail' on a failed match?
05:58:55 <litb> my understanding is that list is a monad, and  (a:as) mattern matches on [3]. and a should be 3. and  return a  gives a listagain
05:58:58 <ski> > do a:as <- return [3]; return (a,as)  :: Maybe (Integer,[Integer])
05:59:00 <lambdabot>  Just (3,[])
05:59:08 <litb> but it complains that there is no instance for  Num [Int]
05:59:21 <ski> litb : because you're trying to use `3' as a list, in your case
05:59:32 <ski> tempname11_ : yes
05:59:39 <ski> @undo do False <- return True; return ()
05:59:39 <lambdabot> return True >>= \ a -> case a of { False -> return (); _ -> fail ""}
06:00:29 <litb> ah i understand now the pattern match is against the value within the monad, not the monad itself
06:00:46 <ski> > do let {!False = True}; return ()  :: Maybe ()  -- doesn't call `fail', though
06:00:48 <lambdabot>  *Exception: <interactive>:3:9-21: Non-exhaustive patterns in pattern binding
06:01:01 <ski> litb : s/monad/monadic action/
06:01:21 <ski> `Maybe' is the monad here. `return True' is a monadic action (a `Maybe'-action, more specifically)
06:01:36 <litb> ah i see
06:02:51 <ski> (perhaps it would be nice if `do ...; let {!... = ...}; ...' would call `fail' on pattern-match failure. however, that's not current behaviour)
06:03:10 <ttt_fff> so I'm using ghc and ghcjs
06:03:23 <ttt_fff> and I want to a way to have cabal run both ghc and ghcjs (on the same codebase)
06:03:39 <ttt_fff> I want to be able to use "cabal repl" (via ghci) to do type checking / type lookup, and then afterwards, do a compilation via "ghcjs"
06:03:54 <orion> Is there a way to have a cabal project file override the global constraints.
06:04:52 <tempname11_> ttt_fff: I'm not sure you can do that, since you either 'cabal configure' with the --ghcjs flag, or without it
06:05:01 <ttt_fff> gah
06:05:34 <ttt_fff> hmm, so I guess I have to cp my *.hs files around, have ghcjs comiple them (but then trigger extra recompiles since even unmodified files get a new timestamp)
06:05:48 <tempname11_> ttt_fff: I'm far from an expert in ghcjs, though. Maybe someone will suggest a solution
06:06:23 <tempname11_> ttt_fff: I'd suggest rsync to avoid stamp updates for unmodified files
06:06:30 <ttt_fff> hmm
06:06:36 <ttt_fff> so rsync two local directories ?
06:06:39 <ttt_fff> this is sorta cute
06:06:43 <tulcod> ttt_fff: maybe some kind of source code management can help organize your files
06:06:46 <R0b0t1> tempname11_: did you get a better syntax suggestion?
06:06:52 <R0b0t1> iirc I found a haskell specific one
06:06:54 <ttt_fff> wait wait
06:06:57 <ttt_fff> why not just git update ?
06:06:58 <tempname11_> R0b0t1: https://github.com/travitch/hasksyn
06:07:01 <ttt_fff> err, git pull I mean
06:07:15 <ttt_fff> git only updates modified files right?
06:07:25 <ttt_fff> so I have a git repo, which ig cabal/ghc + my *.hs files
06:07:25 <tulcod> ttt_fff: that sholud be right, yes
06:07:35 <ttt_fff> then I have another directory, which is cabal/ghcjs + continuously git pulls the other repo
06:07:35 <R0b0t1> Ooo nice. That's better than one I found a long time ago, haskellmode-vim
06:07:45 <ttt_fff> there's haskell vim now
06:07:49 <ttt_fff> haskell-vim-now, which is awesome
06:08:48 <tempname11_> ttt_fff: Well, git would require you to commit all (even temporary) changes, so rsync might still come in handy.
06:08:59 <ttt_fff> oh right
06:09:09 <ttt_fff> yeah; git would require i git commit on every :make
06:09:26 <ttt_fff> which I really don't wnat to do, since then I have lots of commit messages of the aform auto-year-month-day-hour-minute-second
06:10:28 <tulcod> ttt_fff: you can git commit --amend and git pull --force to overwirte the latest commit
06:10:32 <ttt_fff> hmm, can't I just tell cabal to use different config files and different locations to store cabal data ?
06:11:28 <ttt_fff> so there is cabal --config-file
06:11:34 <ttt_fff> which lets me ahve separate ghc / ghcjs config files
06:11:42 <ttt_fff> now, I just need a way to have the sandbox be at different locations
06:12:21 <tempname11_> ttt_fff: there is actually a --sandbox-config-file
06:12:33 * hackagebot foldl-transduce 0.4.0.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.4.0.0 (DanielDiazCarrete)
06:12:37 <ttt_fff> oh
06:12:39 <tempname11_> I'm not sure if it'll do what you want, but seems promising
06:12:46 <ttt_fff> and the --sandbox-config-file sets where the cabal sandbox is
06:12:48 <ttt_fff> this is totally what I wnat
06:12:52 <ttt_fff> we are the greatest
06:14:47 <tempname11_> ttt_fff: when you try it, could you tell me if it was a success? I kinda also need this for my project :)
06:15:41 <ttt_fff> tempnamel1_: I'm trying it right now
06:17:36 <ttt_fff> so I'm not supposed to touch cabal.sandbox.config
06:17:40 <ttt_fff> but it's supposed to pull stuff from cabal.config
06:21:22 <ttt_fff> nope
06:21:24 <ttt_fff> refuses to work :-(
06:25:53 <tempname11_> ttt_fff: what's the error message?
06:26:15 <ttt_fff> oh
06:26:18 <ttt_fff> cabal just furkcing ignores me
06:26:20 <ttt_fff> i'm going to rsync
06:26:24 <ttt_fff> if you get it to work, please letme know
06:31:10 <dagle> What is the prefered way to install haskell on osx? Haskell-platform? Even if I'm just going to use ghci and no libs (What I'm going to do on this machine is so far from fancy as it gets)
06:31:13 <litb> hmm, i have seen code like     instance Collection [] where ....    for a class Collection withfunctions size, hasElem and concatElem.  why not write that as   instance Collection [a] where ...
06:31:21 <litb> isn't that better?
06:31:55 <mauke> litb: it's different
06:32:15 <ttt_fff> brew install ghc
06:35:44 <tempname11_> dagle: I use https://ghcformacosx.github.io/
06:51:11 <indiagreen> hi, I'm trying to write a Parsec combinator that would limit a parser to some part of the input, but I'm having a problem with backtracking (I think) and I don't know how to solve it. Could anyone take a look at this paste (where my problem is explained in greater depth) and help? http://lpaste.net/140393
06:53:44 <ttt_fff> oh wait oh wait
06:53:55 <indiagreen> ttt_fff: hi
06:54:20 <ttt_fff> hmm
06:54:29 <ttt_fff> so oyu want to run a parser on just part of the input
06:54:32 <ttt_fff> instead of "rest of input"
06:54:46 <ttt_fff> which means, before you run the parser, you need a wya to determine how much of the input to consume
06:54:58 <ttt_fff> so why not run that algo, get a string representing the partial input to be consumed
06:55:03 <ttt_fff> and run a parsec inside of a parsec ?
06:55:16 <indiagreen> well, I'm getting the string in the paste
06:55:24 <indiagreen> ‚ÄúlineBlock <- try $ do ...‚Äù
06:55:46 <indiagreen> except that instead of using ‚Äúparse‚Äù on lineBlock I use setInput instead
07:02:53 <crocket> Can haskell be used in embedded devices that have little RAM?
07:03:27 <frerich> @faq
07:03:27 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
07:03:40 <frerich> He, what happened to my favorite response...
07:04:02 <srhb> frerich: Gone for several months. :)
07:04:37 <frerich> It's never been more obvious that even a fine type system won't save you from regressions.
07:04:50 <srhb> crocket: It might be hard to fit the RTS depending on your constraints. A lot of embedded stuff (especially soft and hard realtime) can instead be generated via EDSLs, such as Atom.
07:05:00 <srhb> frerich: It was intentional.
07:05:14 <crocket> EDSL?
07:05:15 <crocket> Atom?
07:05:21 <srhb> embedded domain specific language
07:05:30 <srhb> crocket: https://hackage.haskell.org/package/atom
07:05:59 <crocket> ok
07:06:11 <crocket> Can haskell be used to write a kernel? Is it a good idea to do so?
07:07:13 <srhb> crocket: "Sure" and "it depends" and "what are you really trying to do?" :-)
07:07:32 <indiagreen> maybe crocket is just curious
07:07:52 <indiagreen> crocket: JHC has been used to write parts of a NetBSD driver
07:07:53 <crocket> I'm just curious
07:07:59 <crocket> JHC?
07:08:15 <indiagreen> another Haskell compiler
07:08:53 <indiagreen> generates small executables, can be used for embedded stuff, does cross-compilation (only runs on Linux but can generate Windows executables AFAIK), etc
07:08:56 <crocket> Using haskell as a systems programming langauge would be a lot better than using C.
07:09:19 <indiagreen> why?
07:09:21 <crocket> Can a person use JHC for embedded devices, too?
07:09:34 <srhb> Maybe. It depends on your constraints. But again, with approaches such as Atom, you can use Haskell to generate safer code without having to embed the GHC runtime etc.
07:09:36 <crocket> embedded devices with 256MB of RAM.
07:09:43 <srhb> ie. essentially writing safer C.
07:09:55 <indiagreen> according to googling I just did
07:09:56 <crocket> I want C out of the way.
07:09:56 <indiagreen> > Kiwamu Okabe created a fork of jhc and used it to program a Cortex-M3 processor.
07:09:57 <lambdabot>  <hint>:1:29: parse error on input ‚Äòof‚Äô
07:10:01 <indiagreen> sorry lambdabot
07:10:11 <dramforever> I heard that GHC essentially compiles to an specialized interpreter...
07:10:23 <dramforever> crocket: wait wait 256MB is a *lot* of RAM!
07:10:27 <litb> hm what's wrong withthis    distinct lst = foldl (\(xs, last) x -> if x == last then (xs, last) else (x : xs, x)) ([head lst], head lst) $ tail lst
07:10:37 <crocket> How much RAM do embedded devices usually have?
07:11:01 <crocket> Isn't it 1GB nowadays?
07:11:04 <litb> i think it should type check but it complains
07:11:20 <litb> Couldn't match expected type ‚Äò(a, b0)‚Äô with actual type ‚Äò[Integer]‚Äô
07:11:45 <crocket> Does haskell suffer world-stopping GC?
07:12:28 <srhb> litb: There's no type error in what you wrote.
07:12:45 <litb> srhb: ah i'm using "let" in ghci.. perhapos that's the reason?
07:12:59 <srhb> litb: Yes, ghci does not allow top level definitions a la foo = bar
07:13:15 <srhb> Wait, what.
07:13:17 <dramforever> @let distinct lst = foldl (\(xs, last) x -> if x == last then (xs, last) else (x : xs, x)) ([head lst], head lst) $ tail lst
07:13:19 <lambdabot>  Defined.
07:13:24 <dramforever> :t distinct
07:13:26 <lambdabot> Eq a => [a] -> ([a], a)
07:13:29 <tulcod> crocket: all of the questions you're asking are valid, and unfortunately there is no easy answer. but there is no easy answer for *any* language for *any* of your questions.
07:13:42 <dramforever> litb: now we have a problem....
07:14:08 <litb> i did   let distinct lst = foldl (\(xs, last) x -> if x == last then (xs, last) else (x : xs, x)) ([head  lst], head lst) $ tail lst
07:14:14 <litb> and it complained
07:14:32 <litb> looks like with lambdabot it works
07:14:36 <tulcod> crocket: generally speaking, it's a tad more difficult to control resources when you're programming in haskell. however, it's also easier to control the amount of bugs in your program. so it's a bit of an exchange.
07:14:53 <litb> oh gosh sorry
07:14:57 <srhb> litb: Have you accidentally redefined one of those names earlier?
07:14:59 <dramforever> oh, must be because <del>some</del> the weird type system design problem
07:15:08 <dramforever> MonomorphismRestriction
07:15:09 <tulcod> crocket: most people in this channel would love to see some future form of haskell rule the world. but at this point it's not happening yet, for whatever reason.
07:15:33 <litb> when i checked the function i wrote  fst [1, 2, 2, 3] instead of distinct... not sure what happened
07:15:49 <dramforever> oh never mind =P
07:15:53 <tulcod> crocket: but haskell, even with its small community, has a *lot* to offer over a lot of more popular languages, for what it's worth
07:16:03 <crocket> yes
07:16:17 <crocket> I'm thinking of writing a general purpose AI in haskell.
07:16:32 <tulcod> crocket: welcome to the 70s
07:16:38 <crocket> 70s?
07:16:48 * dramforever feels superior when one of my friend says "python's list comps rock"
07:16:51 <dramforever> *friends
07:17:10 <tulcod> crocket: https://en.wikipedia.org/wiki/AI_winter
07:17:50 <tulcod> crocket: the big conclusion of the AI winter is that you shouldn't aim to write a general purpose AI system that is capable of doing everything ever
07:18:00 <tulcod> cause you'll inevitably fail
07:18:29 <crocket> tulcod, It is different now.
07:18:36 <crocket> I don't need external funding to make an AI.
07:18:45 <crocket> I need only my brain and time.
07:19:06 <crocket> And, I have some confidence that general AIs will emerge in the near future.
07:19:18 <tulcod> people have had that confidence for decades
07:19:27 <crocket> I found a potent approach to a general AI.
07:19:32 <tulcod> anyway, let me stop discouraging you
07:19:55 <crocket> I know you have your doubts.
07:19:58 <litb> make me a hubot plz 
07:20:01 <maerwald> yeah, I'd rather do it than just announce it
07:20:44 <crocket> Anyway, a competitor writes such an AI in C++, which is injustice.
07:21:30 <crocket> C++ shouldn't be the language of choice for AI programmers.
07:21:38 <maerwald> aha
07:22:47 <crocket> How compact can haskell programs be compared to C++ ones?
07:23:03 <crocket> Can haskell reduce the line of code by 90%?
07:23:07 <tulcod> crocket: source code wise? orders of magnitude
07:23:09 <tulcod> crocket: yes
07:23:13 <crocket> ok
07:23:16 <crocket> 140k -> 14k
07:23:19 <dagle> It depends.
07:23:20 <crocket> 14k is manageable.
07:23:28 <tulcod> it depends, but it's possible
07:23:38 <tulcod> i like the parsing examples
07:24:17 <maerwald> the question is just too broad to give a useful answer
07:24:28 <maerwald> there are things that need more code in haskell
07:25:27 <tulcod> crocket: one prime example of when haskell code is better in every sense than C code is this: http://newartisans.com/2012/08/parsing-with-haskell-and-attoparsec/
07:25:44 <crocket> tulcod, What about C++?
07:25:49 <crocket> C++ has classes and templates.
07:25:54 <tulcod> what about it?
07:26:10 <crocket> Concision in the small isn't concision in the large.
07:26:29 <tulcod> crocket: what are you trying to say?
07:26:44 <crocket> A programming language might come with syntactic sugars which do not help reduce the amount of code in a large program.
07:26:49 <maerwald> I feel like this is another fuzzy language comparison discussion
07:27:06 <crocket> Clojure's common abstractions save a lot of lines of code by maximizing code reuse.
07:27:11 <tulcod> crocket: there are very nice examples of when C++ is shorter and more efficient than C
07:27:32 <tulcod> again, the answers to your questions are relevant and never clear
07:28:08 <crocket> An AI doesn't have to run on embedded devices, so I am not interesting squeezing the last drop of performance.
07:28:35 <crocket> ouch
07:28:38 <tulcod> crocket: huh?
07:28:44 <crocket> An AI doesn't have to run on embedded devices, so I am not interested in squeezing the last drop of performance.
07:28:46 <tulcod> i have a device in my pocket that says otherwise
07:28:50 <crocket> English is not my primary language.
07:28:59 <crocket> I am so tired.
07:29:12 <crocket> A device in your pocket has at least 1GB of RAM.
07:29:18 <crocket> A smartphone
07:29:24 <crocket> It is quite powerful
07:29:53 <tulcod> i have another one lying on the table with 384MB
07:30:06 <tulcod> but yes the one in my pocket has 1.5GB
07:30:25 <tulcod> and no, the one on the table is most definitely not powerful
07:30:39 <crocket> By the time that I insert AIs in mobile devices, it'll have become a lot more powerful.
07:30:46 <crocket> probably 4GB of RAM
07:30:57 <tulcod> (that's true because it'll take a while ;) )
07:30:59 <crocket> But, I am not interested in running AIs in mobile devices, yet.
07:31:44 <crocket> The definition of a general AI is that it is capable of any type of language.
07:32:00 <crocket> body langauge, human language, and so on
07:32:16 <tulcod> (i think i've said enough in this discussion)
07:33:29 <crocket> going out
07:47:20 <Jinxit> if I have an "initialState :: State" and "nextStates :: State -> [State]", how would I create a lazy tree of all states?
07:48:47 <tulcod> Jinxit: start by defining a datatype for your tree
07:49:18 <tulcod> Jinxit: then recursively define the tree that you want
07:52:36 * hackagebot pusher-http-haskell 0.2.0.0 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-0.2.0.0 (willsewell)
07:54:19 <Jinxit> tulcod: does "data GameTree = GameTree [State] | Nil" sound correct?
07:54:37 <Jinxit> I'm familiar with recursive functions, but recursive data types throws me off
07:54:45 <tulcod> Jinxit: it doesn't sound correct to me
07:54:51 <tulcod> how would you say it represents a tree?
07:55:19 <Jinxit> either it has a list of children, or it's nothing
07:55:22 <tulcod> note that in your definition, the second "GameTree" is not a field, but just the name of the constructor (the other constructor being called Nil)
07:55:33 <Jinxit> I guess the Nil could just be an empty list
07:55:34 <tulcod> Jinxit: ah, but the children are supposed to be what?
07:55:42 <Jinxit> GameTrees?
07:56:14 <tulcod> Jinxit: well yes that would make sense
07:56:19 <Jinxit> I see
07:56:36 <Jinxit> so just "data GameTree = GameTree [GameTree]"?
07:56:43 <tulcod> okay, but now where did State go?
07:56:58 <tulcod> i mean yes, this is a tree. but you've completely forgotten about State
07:57:02 <Jinxit> ohh yeah
07:57:18 <Jinxit> "data GameTree = GameTree State [GameTree]"
07:57:25 <tulcod> Jinxit: that would make sense :)
07:57:25 <Jinxit> to keep the current node's state
07:57:41 <tulcod> Jinxit: (by the way, when you'll try to write this you'll find that State is a name already used by Prelude)
07:57:47 <jmcarthur> not by Prelude
07:57:52 <tulcod> oh oops ok
07:57:52 <jmcarthur> State is not even in base
07:57:58 <tulcod> wait seriously?
07:58:01 <jmcarthur> it lives in the transformers package
07:58:13 <tulcod> wow
07:58:21 <tulcod> okay, well it's pretty fundamental though :P
07:58:25 <jmcarthur> i disagree
07:58:32 <jmcarthur> it's overrated
07:58:34 <Jinxit> yeah I might prefix everything later, not sure
07:58:41 <tulcod> Jinxit: okay, point is, you might run into State again some time
07:58:46 <jmcarthur> :)
07:59:03 <tulcod> so either make sure you don't, or rename your State, or make sure you import the "real" State "qualified"
07:59:13 <tulcod> (google for qualified imports)
07:59:52 <tulcod> Jinxit: okay, so now how would you construct your tree?
08:02:17 <tulcod> Jinxit: by the way, compare your tree with a more "official" one: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Tree.html#t:Tree
08:02:36 <tulcod> Jinxit: (you have to follow some references here. "Forest a" just means "[a]", for example)
08:07:22 <Jinxit> tulcod: got it to work with "gameTree s = GameTree s (map gameTree $ nextStates s)" :)
08:07:38 <tulcod> Jinxit: looks good :)
08:07:43 <martinvlk> @pl (\c -> not (isControl c) && (c `notElem` "\"\\"))
08:07:43 <lambdabot> ap ((&&) . not . isControl) (`notElem` "\"\\")
08:07:43 <Jinxit> thanks for the help!
08:07:48 <tulcod> np
08:08:08 <tulcod> Jinxit: and yeah that's a nice oneliner
08:08:34 <Haskelldummie> helo
08:08:38 <Haskelldummie> hello
08:08:57 <Fuuzetsu> hi
08:09:25 <Haskelldummie> http://lpaste.net/140395
08:09:35 <Haskelldummie> can help me?
08:11:39 <Haskelldummie> someone can help me?
08:12:08 <Haskelldummie> there's only 5 minutes
08:12:21 <Clint> Haskelldummie: yes, that's an error message
08:12:36 <Haskelldummie> yes
08:12:40 <Haskelldummie> http://lpaste.net/140395
08:12:46 <Clint> it means that calculaTrue is not in scope
08:13:00 <Haskelldummie> how i can solve it?
08:13:28 <Jinxit> Haskelldummie: sounds awfully much like a test
08:13:33 <Jinxit> just saiyan
08:14:22 <Haskelldummie> test?
08:14:58 <Haskelldummie> i can put the code
08:16:37 <Haskelldummie> http://lpaste.net/4016341488924360704
08:16:42 <Haskelldummie> here is
08:17:45 <Clint> you can't do the wheres like that
08:18:31 <int-e> Haskelldummie: the definition of calculaTrue is indented to far, ending up with inside the 'where' clause auf sacaRestC instead of the one of creaNonograma where you need it
08:20:18 <res0001> (absolute newbie here)
08:20:42 <res0001> why does :t (1,1) not result simply in (Num,Num) ??
08:20:57 <res0001> http://lpaste.net/140396
08:21:30 <c_wraith> res0001: because Num isn't a type
08:21:58 <c_wraith> res0001: Num is a type class..  That is, it's a property that can hold true of any number of types
08:22:51 <c_wraith> res0001: try entering :info Num in ghci.  That will tell you about all the instances currently in scope...  But there can always be more.  You can define your own, or import them from other modules
08:23:48 <Haskelldummie> int-e how can i solve it?
08:25:36 <res0001> <c_wraith> I see ... I keep confusing type and type class ... thanx, I'll look at :info
08:25:47 <int-e> Haskelldummie: don't use so many where clauses: http://lpaste.net/8646862115765747712 (I didn't test this)
08:26:06 <c_wraith> res0001: actually, I just checked.  :info doesn't even tell you about all instances in scope.  Only instances in scope if the types are also in scope.  So :info Num doesn't tell you about the instance for Rational, because the Ratio type isn't in scope.
08:30:06 <ttt_fff> right now, I have a bunch of lines that look like this: 
08:30:07 <ttt_fff> tmux send-keys -t "ghci:0"   C-c C-c C-c tmux send-keys -t "ghci:0"   Enter C-l ":r" Enter tmux send-keys -t "ghci:0"   "T.Main.main" Enter tmux send-keys -t "ghci:0"   ":lookupInit" Enter
08:30:17 <ttt_fff> https://gist.github.com/anonymous/ad371176dd1c06771fa8
08:30:27 <ttt_fff> now, is there a way to say "only execute the rest of these lines IF THE RELOAD SUCCEEDED" ?
08:30:33 <ttt_fff> i.e. if the reload has a compile error, ignore the last two lines
08:30:38 <res0001> I don't understand why the two cases I posted at http://lpaste.net/140396 don't have the same *kind* of result. Is there nothing like Bool that could be used in the case of :t (1,1) ?
08:30:40 <ttt_fff> if the reload succeeds, then execute the following two lines as well
08:31:15 <res0001> i.e., why the need for (t,t1) ?
08:31:19 <ttt_fff> :t (let 1 = 1 in (1, 1))
08:31:20 <lambdabot> (Num t, Num t1) => (t, t1)
08:31:23 <ttt_fff> :t (let 1 = 1 in (x, x))
08:31:25 <lambdabot> (Expr, Expr)
08:31:30 <ttt_fff> :t (let x = 1 in (x, x))
08:31:31 <lambdabot> (Num t, Num t1) => (t, t1)
08:31:42 <ttt_fff> hmm
08:31:54 <ttt_fff> 1 :: Double
08:31:57 <ttt_fff> > 1 :: Double
08:31:58 <lambdabot>  1.0
08:32:08 <ttt_fff> I think the problem is that the 1 can be int, double, or float, or something else
08:32:17 <ttt_fff> so the type checker is like "for some num type t, t1", (1, 1) has type (t, t1)
08:34:04 <c_wraith> res0001: Numeric literals are a bit special in haskell
08:34:16 <c_wraith> res0001: they aren't tied to a specific type
08:34:43 <c_wraith> res0001: instead, they are compiled as if they were calls to either fromInteger or fromRational, depending on whether they have a . in them
08:34:49 <c_wraith> :t fromInteger
08:34:51 <lambdabot> Num a => Integer -> a
08:34:56 <c_wraith> :t fromRational
08:34:57 <lambdabot> Fractional a => Rational -> a
08:35:10 <geekosaur> res0001, any numeric literal gets fromInteger or fromRational wrapped around it automatically. nothing stops you from defining a Num instance for random things, and in fact that is occasionally useful, so the ocmpiler must leave oipen the [possibility rather than trying to insist on what "is allowe dto be Num"
08:35:39 <c_wraith> res0001: in contrast, True and False are constructors of the Bool type.  There's no flexibility - they can't be any other type.
08:35:43 <c_wraith> @src Bool
08:35:43 <lambdabot> data Bool = False | True deriving (Eq, Ord)
08:36:01 <c_wraith> res0001: (unlike most other languages, Bool is defined in a library in Haskell)
08:37:39 <ttt_fff> @src Bool
08:37:40 <lambdabot> data Bool = False | True deriving (Eq, Ord)
08:37:44 <ttt_fff> yep, how cute is that
08:38:20 <HaskellDumieSpai> thanks that is helping me
08:38:23 <Anak1n_> @src String
08:38:23 <lambdabot> type String = [Char]
08:38:31 <HaskellDumieSpai> but now is another error
08:38:32 <HaskellDumieSpai> http://lpaste.net/4016341488924360704
08:40:02 <res0001> ok, thanks everyone for your help ... I need to read up on everything you've mentioned, as it's all new to me
08:41:09 <geekosaur> error does not match the "error here". but does make sense if it's at calculaRest rather than sacaRestF
08:41:30 <geekosaur> did you forget to specify fila as the parameter of calculaRest (line 15)?
08:42:08 <geekosaur> or were you expecting it to somehow "inherit" it from calculaTrue? (it will not; you must pass it explicitly)
08:42:31 <HaskellDumieSpai> mmm
08:44:49 <HaskellDumieSpai> how i can do this?
08:44:59 <HaskellDumieSpai> pass ir explicily?
08:45:02 <HaskellDumieSpai> it
08:45:30 <tmtwd> can someone help with this? http://pastebin.com/SfXx2eH7
08:46:00 <tmtwd> I have 2 types deriving show, but when I compose them, it says the type doesn't derive show
08:46:54 <c_wraith> tmtwd: the problem is that you didn't compose them correctly. :)
08:47:03 <tmtwd> which means?
08:47:07 <lpaste_> geekosaur annotated ‚Äúerror‚Äù with ‚Äúerror (annotation) (annotation) (annotation)‚Äù at http://lpaste.net/4016341488924360704#a140403
08:47:23 <c_wraith> tmtwd: I think you wanted an expression more like Pepper Fork (Bottom Dagger)
08:47:39 <latermuse> @src Int
08:47:39 <lambdabot> data Int = I# Int#
08:48:05 <c_wraith> tmtwd: you left an argument out.  Because constructors are curried, that means (Pepper (Bottom Dagger)) is a function.
08:48:11 <latermuse> @src (<***>)
08:48:11 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:48:15 <c_wraith> tmtwd: and functions don't have a show instance
08:48:15 <tmtwd> oh
08:48:16 <latermuse> lol
08:48:18 <tmtwd> intersting
08:48:41 <c_wraith> tmtwd: the (->) in the error message more or less means "I don't know how to show functions"
08:49:03 <voidzero> lambdabot: you bag of bolts you
08:49:19 <tmtwd> oh
08:51:27 <tmtwd> c_wraith, oh Pepper is a type constructor in this case rather than a type?
08:51:37 <Thra11> If I have a large tree structure that I wish to be created lazily from data on disk, I assume that data should be stored in some sort of database (or a pseudo-database consisting of a filesystem directory heirarchy), such that having loaded one node, I can find the data to load its children without (re)parsing the whole data file. I don't really know much about databases. Can anyone point me to resources
08:51:39 <Thra11> about reading and storing tree structures for lazy loading, or anything related?
08:55:49 <c_wraith> tmtwd: no, it's a value constructor. 
09:01:22 <HaskellDumieSpai> http://lpaste.net/4016341488924360704
09:01:31 <HaskellDumieSpai> now the error is other
09:03:29 <geekosaur> oh right
09:08:44 <tmtwd> oh
09:12:35 <Rembane> I cannot make configurator read configuration values that are strings. It throws a KeyError-exception if I use the require-function. On integer values it behaves just fine.
09:12:46 <Rembane> How do I get around this?=
09:15:10 * geekosaur sigh, local notwork is making thinsg pretty impossible. (znc is hiding the irc disconnects...)
09:16:36 <glguy> geekosaur: Specifically in the buffered history when you reconnect?
09:17:48 <HaskellDumieSpai> no
09:18:04 <monochrom> "notwork" is a great word :)
09:18:49 <glguy> Rembane: throw some code on lpaste that doesn't work like you expected
09:21:27 <HaskellDumieSpai> someone can help a little more?
09:22:52 <d-snp> hey HaskellDumieSpai, your code is not in english :P
09:23:30 <HaskellDumieSpai> only the variables
09:24:04 <d-snp> no, also the data types and the functions..
09:24:07 * Phyx- never really gets the znc buffer playback.. 
09:24:31 <d-snp> the last error you get in that thing means that you expected an int
09:24:45 <d-snp> but you got a function that returns an int but takes a bool
09:24:54 <HaskellDumieSpai> yes
09:24:55 <d-snp> so you forgot to provide a bool to calculaRest
09:25:36 <d-snp> in errors like this to me it always helps to add more type annotations
09:26:10 <d-snp> calculaRest :: [Int] -> ..?
09:26:23 <d-snp> if you add that, the error will become more clear because the compiler knows your intentions
09:27:33 <Anak1n_> hello
09:27:50 <Anak1n_> is there any way i can take list and return t element by element
09:28:00 <geekosaur> glguy, no, just mentioning why you're not seeing me disconnect every couple minutes
09:28:54 <d-snp> Anak1n_: the id function does that ;)
09:29:08 <d-snp> if it does not, then you'll need to be a little bit more specific with your use case
09:29:12 <glguy> geekosaur: I don't think we're seeing you disconnect.
09:29:18 <geekosaur> exactly
09:29:20 <glguy> oh, "not"
09:29:39 <Anak1n_> ok thank you will try
09:29:46 <Rembane> glguy: When I made a minimal (not-)working example, it started working. So, thanks for your advice. :)
09:29:58 <glguy> Rembane: Anytime ;-)
09:31:02 <HaskellDumieSpai> what means ..?
09:31:34 <Anak1n_> i do not get id when i type id list i get output as list
09:31:59 <Anak1n_> i need for example i have list [1..20] and i want to dived lets say 5 with all the numebrs from list
09:32:10 <Anak1n_> to save time i coudl type 5/1, 5/2 and so on
09:32:18 <srhb> Anak1n_: Maybe you want map (5/)
09:32:26 <Anak1n_> trying to learn by example but it is different from evrything i saw
09:32:30 <Anak1n_> will try
09:33:13 <Anak1n_> if i know what i want i would google it :)
09:33:18 <srhb> Of course. :)
09:33:27 <srhb> map is a function that takes another function and applies it to every element in a list.
09:33:29 <srhb> :t map
09:33:30 <lambdabot> (a -> b) -> [a] -> [b]
09:33:35 <HaskellDumieSpai> better use case?
09:33:41 <Anak1n_> with for loop i know how to do it but trying to to get hsakell into my mind :D
09:34:34 <srhb> Anak1n_: map is sometimes known with the two first arguments flipped as for. for :: [a] -> (a -> b) -> [b] -- but yes, we don't really use loops (or even have them as primitives.)
09:34:44 <srhb> Recursive combinators are superior anyway :-)
09:41:01 <ski> > [ 5/n | n <- [1 .. 6] ]  -- Anak1n_, here's a list comprehension
09:41:03 <lambdabot>  [5.0,2.5,1.6666666666666667,1.25,1.0,0.8333333333333334]
09:41:13 <d-snp> Anak1n_: did you find out how? it's the beginning that's toughest in haskell, if you get this in your head you'll be an ace in no time :)
09:41:46 <Anak1n_> can i replace 5 with list?
09:41:49 <Anak1n_> also?
09:41:58 <ski> HaskellDumieSpai : `[1 .. 6]' means `enumFromTo 1 6'
09:42:04 <Anak1n_> yes i know that begining is hard that is why i move from readding to examples
09:42:36 <ski> > [ (x,y) | x <- [0,1],y <- [2 .. 4] ]
09:42:38 <lambdabot>  [(0,2),(0,3),(0,4),(1,2),(1,3),(1,4)]
09:42:40 <d-snp> Anak1n_: you want to divide every element in your list with values from another list?
09:42:57 <Anak1n_> so i can do something lie this [c/n | c<-[100..999], n<-[1..6], c `mod` n==0]
09:42:58 <ski> Anak1n_ : that generates all possibilities of selecting elements from the two lists
09:43:05 <ski> yes
09:43:09 <d-snp> right
09:43:24 <ski> also, you want  c `div` n  there, not  c/n
09:43:32 <ski> .. assuming you want integral division
09:43:32 <Anak1n_> one tricky part 
09:43:51 <d-snp> for some reason I almost never use list comprehensions in Haskell, do the pros use them much?
09:43:54 <Anak1n_> will it return value only if mod of dividing with all numbers is 0 or 
09:44:03 <ski> d-snp : sometimes it looks more neat
09:44:26 <ski> Anak1n_ : it will only generate those combinations which passes the test
09:45:56 <Anak1n_> yes i see it will be true for every number
09:46:27 <ski> HaskellDumieSpai : .. otoh, if you're talking about "<d-snp> calculaRest :: [Int] -> ..?", then presumably they meant that `calculaRest' is a function that takes a list of `Int's, and returns whatever (iow, `..' just means "you fill in the blanks")
09:46:55 <litb> hmm i wonder whether you can write a "removeDuplicates" for lists just in terms of foldr
09:47:17 <Anak1n_> my problem is i guess because i do not know shoortcut for [c/n | c<-[100..999], n<-[1..6], c `mod` 1==0 && c `mod` 2 ==0 && c `mod` 3 ==0] and so on
09:47:22 <litb> i didn't came up with one, i think it requires zipWith at least
09:47:38 <ski> litb : what should it do, exactly ?
09:47:43 <srhb> litb: Almost, you will at least need to discard some information after the fold.
09:48:21 <d-snp> Anak1n_: at that point I'd make it multiline function with a where clause that has something like dividableTest = c `mod` 1 ... etc
09:48:42 <d-snp> or are you trying to generate prime numbers?
09:48:44 <ski> > [c | c <- [100 .. 999],all (\d -> c `mod` d == 0) [1,2,3]]
09:48:46 <lambdabot>  [102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192,198,204,210...
09:48:50 <lingxiao> Im benchmarking some code that reads files form memory using criterion
09:48:52 <litb> ski: like uniq in unix
09:49:03 <lingxiao> and I'm getting error :  createProcess: runInteractiveProcess: pipe: resource exhausted (Too many open files)
09:49:37 <litb> given a sorted list, replace consecutive equal elements with only a single element in that group. the list can be infinitely long
09:49:43 <litb> perhaps i can use the group function
09:49:52 <bob_twinkles> how many files are you opening?
09:49:58 <lingxiao> which is funny because if I open the the file and then run some data analysis on it, it's fine
09:49:59 <ski> > foldr (\a as -> a : filter (a /=) as) [] "abacabad"  -- litb, like this ?
09:50:01 <lambdabot>  "abcd"
09:50:05 <athan> Lawd have mercy: https://github.com/commercialhaskell/stack-templates
09:50:12 <lingxiao> Im opening a generator that outputs 10k elements
09:50:14 <lingxiao> then parsing it
09:50:18 <lingxiao> this exhausts the resources
09:50:31 <lingxiao> but if i open it, parse it, then run some data analysis on it .. it's fine
09:51:26 <litb> ski: ah that's nice, thanks. I think it has quadratic time complexity, right?
09:51:48 <litb> but it's still elegant
09:51:54 <srhb> litb: Just FYI that function is usually called nub in Haskell.
09:52:15 <iampix> hi!
09:52:17 <bob_twinkles> lingxiao: can you throw your code on lpaste?
09:52:32 <bob_twinkles> probably just how you open/read the files to start with
09:53:17 <lingxiao> http://lpaste.net/140404
09:53:42 <lingxiao> calling mainAll is fine for up to 10million elements generated by generator
09:53:51 <lingxiao> but calling mainParse fails for even 100 elements
09:55:57 <lingxiao> the same thing happens if I just use the generator to output 100 elemes
09:59:04 <lingxiao> a better version: http://lpaste.net/140406
09:59:11 <HaskellDumieSpai> sorry but i cant i change a lot of but any solve it
09:59:20 <lingxiao> and I would call: 
09:59:22 <lingxiao> main :: IO ()
09:59:23 <lingxiao> main = defaultMain . pure . bench "generate 100"  . nfIO . mainGen $ 100
09:59:45 <lingxiao> which throws error: Main: ../../../file: createProcess: runInteractiveProcess: pipe: resource exhausted (Too many open files)
10:00:39 <HaskellDumieSpai> please take a look :_(  http://lpaste.net/4016341488924360704
10:01:51 <lingxiao> bob_twinkles posted 
10:02:26 <litb> hmm can someone explain please why  seq [1..] 2  terminates?
10:02:47 <litb> i thought that seq implies strict evaluation of its argument
10:03:44 <c_wraith> litb: to whnf
10:04:00 <c_wraith> litb: which more or less means "ensure the top constructor is evaluated"
10:04:02 <srhb> HaskellDumieSpai: The very last annotation? You're applying head to calculaRest, but calculaRest is a function, not a list.
10:04:18 <c_wraith> litb: and so it goes "ok, the top constructor is (:).  done!"
10:04:53 <litb> ah i see. the top constructor is  1:[2..] then finished. thanks
10:05:31 <brtmr> I am having trouble with lenses and compiler errors - can someone have a look at this paste and tell me what i am missing? http://pastebin.com/Pvyw97YU
10:05:39 <bob_twinkles> lingxiao: My guess is that lazy IO is biting you here and resources aren't getting collected the way you would expect, but I'm not 100% sure
10:05:41 <lingxiao> I suppose I should close the handle or terminate someprcoess? but im not sure how after rading this: hinese sprinter
10:06:17 <lingxiao> yeah ... but reading this tutorial: http://www.serpentine.com/criterion/tutorial.html
10:06:32 <lingxiao> Any time that lazy I/O is involved, use nfIO to avoid resource leaks.
10:06:56 <lingxiao> which I do use
10:07:11 <HaskellDumieSpai> srhb and what i can do?
10:07:24 <lingxiao> same thing if i use whnfIO for weak head normal form
10:07:55 <srhb> HaskellDumieSpai: Fix the type error. :-) You can't apply head to a function. You need to give it a list as its argument. If you mean something like head (calculaRest someList) -- then do that.
10:08:06 <srhb> brtmr: I think we need more context.
10:08:32 <srhb> brtmr: For instance, what is m, and how are you "compiling the expression"
10:08:34 <litb> c_wraith: is there a way to force evaluation to normal form?
10:08:48 <litb> i.e evaluate all subexpresions
10:09:00 <lingxiao> so if my main is now mainGen n = genCSV n >>= \x -> print x >> return ()
10:09:39 <c_wraith> litb: not completely.  There's no way to reduce under a lambda.  However, for everything but that, you can use rnf
10:09:42 <c_wraith> :t rnf
10:09:44 <lingxiao> that is to say I have some function that consumes the entire bytestring... it works at least for 100 ouptputs
10:09:44 <lambdabot> Not in scope: ‚Äòrnf‚Äô
10:09:52 <brtmr> srhb: m is a parameter to a function (of type Machine), and the expression is used as a guard to the function, as in function m | m^.m_pTotal == 0 =  ... some stuff ... 
10:10:06 <c_wraith> litb: which is in the deepseq package
10:10:22 <litb> ah nice thanks
10:10:58 <HaskellDumieSpai> sorry this is too heavy for me, I have to pay another year
10:11:23 <HaskellDumieSpai> I'll back 
10:11:47 <srhb> brtmr: By the way, was it a paste error that there's no data constructor for Machine?
10:11:49 <lingxiao> hey all
10:12:00 <lingxiao> if I have an IO action that outputs bytestring
10:12:13 <lingxiao> is there a way to interact with it as deeply as possible without printing the whole thing?
10:12:14 <brtmr> srhb: yes, i only noticed after submitting.
10:12:38 <brtmr> srhb: it should say data Machine = Machine {...}
10:12:52 <srhb> Right :)
10:13:35 <monochrom> lingxiao: what is "interact deeply"?
10:13:51 <lingxiao> evaluate it to normal form
10:14:41 <monochrom> possibly "evaluate . rnf". "evaluate" is from Control.Exception
10:14:58 <c_wraith> if it's a strict bytestring, rnf isn't even needed
10:15:07 <brtmr> srhb: those lenses work perfectly in the rest of the module, so i am really scratching my head at what is going on there.
10:15:20 <monochrom> "possibly" because I may be misremembering the exact names
10:15:35 <lingxiao> no it's lazy haha ... :(
10:15:58 <srhb> brtmr: The only thing I can think of offhand is that you don't really have a Machine, but maybe [Machine] or Maybe Machine, so the operator is trying to find mempty.
10:16:14 <lingxiao> sorry wher's rnf from?
10:16:17 <srhb> brtmr: I suggest pasting more context.
10:16:18 <c_wraith> deepseq
10:16:32 <monochrom> Control.DeepSeq
10:17:24 <brtmr> srhb: the function is type annoted as Machine -> Machine. I am gonna post the offending function.
10:17:42 * hackagebot commutative 0.0.1.4 - Commutative binary operations.  https://hackage.haskell.org/package/commutative-0.0.1.4 (athanclark)
10:18:29 <umib0zu> guys, when you use cabal sandboxes, what happens when you install a package in the same directory where you ran ‚Äúcabal sandbox init‚Äù and what happens when you install a package outside of that directory?
10:19:18 <c_wraith> umib0zu: try it with -v --dry-run and see
10:19:32 <monochrom> inside => only the sandbox sees it.  outside => every non-sandbox can see it, assuming you are the user. (other users still can't see it.)
10:20:10 <brtmr> srhb: here you go: http://pastebin.com/WDxHz5GC
10:21:19 <lingxiao> c_wraith i'm getting : No instance for (NFData BL.ByteString) arising from a use of ‚Äòrnf‚Äô
10:21:37 <srhb> brtmr: Notice that MachineState can also be PreMachine
10:21:52 <srhb> brtmr: In that case, what should the result of m ^. m_pTotal be? 
10:22:01 <c_wraith> lingxiao: interesting, because hackage lists an NFData instance in bytestring.  what version of bytestring do you have installed?
10:22:12 <srhb> brtmr: The answer to that is empty, and therefore there must be a Monoid instance.
10:22:40 <brtmr> srhb: Ah, of course.
10:22:56 <lingxiao> not sure.. but I have  ghc 7.10.2
10:23:01 <srhb> brtmr: The devil is in the detail, especially when the detail isn't pasted. :-)
10:23:04 <lingxiao> :-|
10:23:57 <lingxiao> btw im using  Data.ByteString.Lazy 
10:24:01 <umib0zu> c_wraith my bad. my question was more along the lines of ‚Äúwhere are my packages installed if I‚Äôve specified a sandbox‚Äù. I‚Äôm expecting a behavior like NPM where if you run ‚Äúcabal install‚Äù and it installs a local project instance in the same folder of your project and not a local user instance.
10:24:04 <monochrom> 7.10.2 here too. works for me.
10:25:15 <c_wraith> umib0zu: the -v flag to cabal tells you whether it's working in a sandbox or not when it runs
10:26:49 <monochrom> umib0zu: inside => local project instance. outside => local user instance
10:27:00 <umib0zu> c_wraith it appears to not be sandboxing. it only mentions versions.
10:27:38 <brtmr> srhb: thanks, i see. is there any way to tell the compiler which constructor i wanna use here? if i add a pattern match in the form of setMachineState m@MachineState{}, the error still occurs, even though i should have narrowed it down to the single constructor - I assume the monoid instance is dictated by the lens?
10:28:12 <lingxiao> monochrom ahhh ... not sure what's wrong then
10:28:24 <srhb> brtmr: You can wrap the MachineState in a different type and then initially case match to make sure you only have that.
10:28:41 <srhb> brtmr: Which is basically Either PreMachine MachineState
10:29:19 <umib0zu> I‚Äôm assuming cabal has support for a dependency file right? I‚Äôm new to haskell but the docs aren‚Äôt very clear with where deps are installed and whether or not some file is keeping track of the deps.
10:29:51 <brtmr> shrb: that would work. i think in this case i am just not gonna use the lenses, and use the default accessor functions. 
10:30:08 <srhb> brtmr: Sure. :)
10:30:14 <exio4> "Existential antipattern
10:30:18 <exio4> er, sorry
10:30:23 <lingxiao> monochrom this works on your machine? http://lpaste.net/140407
10:30:52 <hexagoxel> umib0zu: maybe see `ghc-pkg list` (outside sandbox) and `cabal exec ghc-pkg list` (sandbox)
10:31:05 <kalby> hello
10:31:05 <monochrom> I merely did: :m + Control.DeepSeq Data.ByteString.Lazy
10:31:13 <monochrom> rnf (Data.ByteString.Lazy.repeat 0)
10:31:29 <brtmr> shrb: i could have done that before asking, but i wanted to know what was going on here ;). so thanks
10:31:34 <monochrom> then enjoy the lock up such that only a kill -9 could kill it
10:31:42 <srhb> brtmr: Sure thing, have fun :)
10:31:59 <kalby> does anyone ever use metasploit?
10:32:26 <lingxiao> hmm ... when i do ` rnf (Data.ByteString.Lazy.repeat 0)`
10:32:33 <lingxiao> I get  No instance for (NFData BL.ByteString) arising from a use of ‚Äòrnf‚Äô again
10:32:43 <lingxiao> and I just did `cabal update` as well :(
10:33:30 <umib0zu> ok so I dug this up http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html. If I do sandbox init then install ‚Äîonly-dependencies, where are the dependencies specified? I‚Äôm used to a ‚Äúpackage.json‚Äù that explicitly states all the dependencies for my specific project. Does cabal use this if I have init-ed a sandbox?
10:33:36 <hexagoxel> umib0zu: note that without `cabal exec` ghc-pkg won't "see" the sandbox even if in a sandbox'ed directory
10:34:48 <geekosaur> umib0zu, it's in the cabal file in that directory (pkgname.cabal)
10:36:03 <umib0zu> geekosaur on a fresh project?
10:36:22 <geekosaur> the page you linked assumed you have an existing project
10:36:31 <umib0zu> I don‚Äôt have any {{package.name}}.cabal file. only a .cabal-sandbox and a cabal.sandbox.config.
10:36:33 <umib0zu> ahh
10:36:34 <umib0zu> ok
10:36:44 <geekosaur> if you don't, "cabal init" to create a new project, then edit the cabal file
10:37:18 <monochrom> it is always healthy to double-check: did you read the article you suggested me to read? :)
10:37:40 <umib0zu> geekosaur I did cabal sandbox init
10:37:48 <umib0zu> but what‚Äôs the cabal file?
10:37:48 <geekosaur> that creates a sandbox
10:37:55 <umib0zu> the sandbox.config?
10:38:08 <geekosaur> "cabal init" asks you some questions and creates a new cabal project, including the pkgname.cabal file
10:38:36 <brtmr> the cabal file contains the build instructions for your project. including the dependencies
10:38:40 <geekosaur> they are distinct operations
10:39:12 <geekosaur> monochrom, the page is not explicit, but does have a line about going to where your (existing) project is and creating a sandbox
10:39:14 <umib0zu> ahhhh
10:39:19 <umib0zu> ok
10:39:20 <brtmr> you rarely need to edit the sandbox.config
10:39:48 <umib0zu> that‚Äôs uh‚Ä¶ odd. I did not expect that
10:39:55 <umib0zu> super used to npm
10:40:46 <brtmr> after you set a *.cabal file using 'cabal init', you can add new dependencies in the build-depends: section
10:41:05 <brtmr> those will be installed by the cabal install --dependencies-only command
10:44:33 <hiptobecubic> Architecture question. I am writing something that is crawling search results and gathering up links. I currently have functions that can extract the links from each page of results and extract the link for the next page of results (retuning Nothing when exhausted). What's the best way to put them together?
10:47:39 <jmcarthur> considering not using stack just because haskell-mode doesn't work very well with it :(
10:52:26 <hiptobecubic> It sounds like an unfoldr, except that I need to determine whether to continue based on something other than the results that i'm collecting
10:53:39 <hiptobecubic> I suppose I could shift it over so that it's just unfolding batches of links and returns nothing if the previous batch didn't also come from a page with a 'next' link
10:54:01 <osa1> I wish we had a way to tell GHCi to print type errs in reversed order
10:54:08 <hiptobecubic> yes
10:54:19 <mniip> very much that
10:54:28 <mniip> actually all errors in reverse order
10:55:26 <Gurkenglas> Why?
10:56:56 <mniip> if the errors are larger than your screen
10:56:59 <mniip> you have to scroll
10:56:59 <jmcarthur> hiptobecubic: you could pair the next links with the results and then remove them in another pass
10:57:04 <mniip> and find the precise place
10:57:16 <mniip> where the previous GHC invocation finished
10:57:43 <hiptobecubic> jmcarthur, that's kind of what I have now, except that that clips off the last set of results, no?
10:57:51 <jmcarthur> :t unfoldr
10:57:52 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
10:58:22 <hiptobecubic> jmcarthur, right now i can start with a query, grab the page, from that page return (results, Maybe query)
10:58:24 <jmcarthur> hiptobecubic: actually, can't the next link just be put in the b place there?
10:58:51 <hiptobecubic> jmcarthur, .... yes. I apparnetly forgot how unfoldr works
10:58:53 <jmcarthur> hiptobecubic: where the initial b is a link to the first page
10:58:55 <hiptobecubic> apparently*
10:58:55 <jmcarthur> yeah
10:59:11 <jmcarthur> we all do from time to time :)
10:59:14 <hiptobecubic> Well at least what was only 20 minutes lost. Could be much worse :)
10:59:25 <ReinH> jmcarthur: haskell-mode works ok with stack though
10:59:31 <ReinH> you can set haskell-process-type
10:59:41 <ReinH> to stack-ghci iirc
10:59:46 <jmcarthur> hmm
10:59:57 <ReinH> it's in the list if you customize it
11:00:01 <jmcarthur> okay
11:00:03 <jmcarthur> i'll try it
11:00:05 <jmcarthur> thanks
11:00:08 <ReinH> np
11:00:24 <ReinH> It might be set to auto, which might not be picking stack over cabal repl
11:02:59 <hiptobecubic> @hoogle Monad m => (b -> m (Maybe (a, b))) -> b -> m [a]
11:03:00 <lambdabot> No results found
11:03:08 <hiptobecubic> Is there a monad unfoldr somewhere?
11:03:18 <Gurkenglas> mniip, couldn't you always treat all errors as if there were printed in reverse order (ie read them bottom-to-top)?
11:03:53 <mniip> no
11:04:12 <indiagreen> @hayoo unfoldrM
11:04:12 <lambdabot> Unknown command, try @list
11:04:15 <hiptobecubic> jmcarthur, also, now that I look at it, my `b` needs to be a `Maybe b`, right? Because on the final page there will be results that I need but no next link.
11:04:16 <Gurkenglas> hiptobecubic, there is Cofree, which works with any functor in place of Maybe, you can use the functor "MaybeT IO"
11:04:16 <mniip> the first error is the most important
11:04:31 <mniip> other errors are very often subproducts of it
11:04:37 <indiagreen> hiptobecubic: there's unfoldrM in monad-loops
11:04:46 <hiptobecubic> thanks
11:05:14 <jmcarthur> hiptobecubic: yup
11:07:00 <d-snp> woah, my C compiler for the first time actually emitted IR :D
11:07:17 <c_wraith> d-snp: nice
11:07:42 <d-snp> now I have to check if the IR actually compiles cleanly, but it took months to get at this point :P
11:09:54 <hiptobecubic> d-snp, congrats :)
11:17:20 <jmcarthur> ReinH: i think my issue is ghc-mod related, not (just) ghci-related
11:17:37 <jmcarthur> (ghc-mod doesn't make use of the ghci stuff in haskell-mode if i recall)
11:26:00 <lpaste_> nocturne777 pasted ‚Äúglobal constraint requires installed instance‚Äù at http://lpaste.net/140411
11:26:19 <nocturne777> I am using a sandbox, but I am still getting this error
11:29:12 <geekosaur> if you have a "constraint: transformers installed" in the global cabal config, it will still apply inside the sandbox
11:29:29 <geekosaur> I don't know offhand how to disable it inside the sandbox
11:30:04 <nocturne777> geekosaur: I am running this command:  cabal install -fdevelopment --constraint='transformers installed'
11:30:49 <geekosaur> so is transformers installed within the sandbox or in the global context?
11:31:17 <geekosaur> ...and is its installed version compatible with what the sandboxed install requires?
11:31:34 <monochrom> transformers comes with ghc since recently. GHC 7.8.3 comes with 0.3.0.0, GHC 7.10.2 comes with 0.4.2.0
11:31:40 <geekosaur> (adding "transformers installed" will not override a version constraint)
11:32:15 <geekosaur> "rejecting: transformers-0.3.0.0/installed-645... (conflict: foo3 => transformers>=0.4.1 && <0.5)"
11:32:33 <geekosaur> you cannot force it to use your version just by adding an installed constraint
11:32:52 <geekosaur> you must edit the cabal file to tell it to accept 0.3.0.0 even though it wants 0.4.1 or later
11:32:59 <geekosaur> ...and thne hope it works
11:33:47 <monochrom> oh, I see what you're saying. you are saying that there is no overriding, only logical and.
11:34:29 <d-snp> heh, the IR it generated is absolute garbage :P
11:35:17 <samba1> http://lpaste.net/6060079729443078144
11:35:33 <samba1> could anyone help with a datakinds / kindsignatures question, please?
11:35:49 <nocturne777> this used to work before
11:36:07 <uctcyc> What is the name of a data structure which satisfies a class modifying the contents of the data structure?
11:36:12 <nocturne777> everytime I make an update to the .cabal file, I deal with these stupid problems
11:36:48 <monochrom> samba1: is "data Zero :: Nat" valid syntax?
11:37:10 <nocturne777> geekosaur: I specify the transformer in the cabal file too
11:37:17 <hypoon> Hey guys, I need help: I have some code that involves reading a large file in segments. The large file is not seekable, so I have a function that is executed repeatedly to return each segment of the file. I'm trying to process the file as each segment is read, but no matter what I try, it appears as though the entire file is being read into memory at the beginning of the program (my function which returns a segment is called repeated
11:37:21 <monochrom> how do you even create a new kind, without DataKinds?
11:37:24 <uctcyc> What is the name of a data structure which instantiates a class by defining a function modifying the contents of the data structure?
11:37:56 <samba1> monochrom: it does not work for me, I hoped it would with KindSignatures but no
11:38:02 <mniip> monochrom, star-arrow kinds
11:38:02 <samba1> monochrom: maybe it's not possible
11:38:38 <mniip> there's an infinite family of kinds composed of just stars and arrows
11:38:56 <uctcyc> What is the name of a data structure which satisfies a class modifying the contents of the data structure? Anybody?
11:39:19 <uctcyc> (uctcyc) What is the name of a data structure which instantiates a class by defining a function modifying the contents of the data structure? Sorry...
11:39:53 <samba1> mniip: can you give me something to search to learn about what you're talking about so I can figure out my question?
11:40:08 <mniip> samba1, oh it's not a serious answer
11:40:24 <monochrom> I see, "data Zero :: (* -> *) -> *" is legal (with KindSignatures). So you need a way to introduce a new kind called "Nat". which probably requires DataKinds to begin with.
11:40:35 <mniip> just that without DataKinds you have got () :: *, Identity :: * -> *, IdentityT :: (* -> *) -> * -> *
11:41:08 <uctcyc> (uctcyc) What is the name of a data structure which instantiates a class by defining a function modifying the contents of both data structures depending on the contents of both data structures?
11:41:12 * monochrom has a cunning plan!
11:41:29 <mniip> uctcyc, what now
11:41:36 <uctcyc> That's the question I really want the answer to
11:41:38 <mniip> monochrom, encoding kinds in star-arrows?
11:41:59 <uctcyc> The answer to the other one is functor...
11:42:21 <mniip> uctcyc, Functor isn't a data structure
11:42:39 <uctcyc> This is kind of a double functor :-
11:42:54 <Gurkenglas> uctcyc, to your last question: You refer to "both data structures", where the part of the sentence before it only refers to one data structure.
11:42:58 <uctcyc> Yes a data structure can be a functor
11:43:29 <uctcyc> As it's just two of the same type of data structure
11:43:49 <mniip> :k Bifunctor
11:43:50 <lambdabot> (* -> * -> *) -> Constraint
11:43:55 <mniip> talking about this?
11:43:58 <uctcyc> So both should read "two of such"
11:44:25 <monochrom> my cunning plan fails
11:44:55 <uctcyc> Perhaps it is a bifunctor, I can't tell with your kind definition if it does this
11:45:13 <mniip> :k bimap
11:45:14 <srhb> Or maybe it's data Both a = Both (One a) (Two a) and (Functor One, Functor Two) => ...
11:45:14 <lambdabot> Not in scope: type variable ‚Äòbimap‚Äô
11:45:15 <monochrom> my cunning plan was: use DataKinds for "data Nat" so now you get the kind Nat. then "data Zero :: Nat". but GHC rejects it.
11:45:15 <mniip> errr
11:45:17 <mniip> :t bimap
11:45:19 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
11:45:19 <geekosaur> nocturne777, apparently you are not doing so properly
11:45:19 <Gurkenglas> "instantiates a class by defines" <- how do these words, as opposed to "defines",  change the question?
11:45:33 <mniip> uctcyc, bimap is the core of Bifunctor
11:46:05 <uctcyc> So I make both a bifunctor?
11:46:11 <uctcyc> Both
11:46:23 <mniip> huh
11:46:28 <srhb> No, that would be a Functor. I'm also unclear on the question, so just fishing.
11:46:50 <Gurkenglas> Might help to write down a class definition where us giving an instance would answer your question
11:46:53 <uctcyc> Also no it's not a bifunctor..
11:46:54 <srhb> It may be that mniip understood you correctly :-)
11:46:56 <mniip> uctcyc, okay, you seem unfamiliar with the right terminology, so let's just ask,
11:47:02 <mniip> what are you really trying to do
11:47:05 <uctcyc> I'll try to write a class definition
11:47:53 <nocturne777> geekosaur: I modified the .cabal file to force it to use 0.3.0.0. it works now
11:48:09 <monochrom> hypoon: you need to put a self-containing demo on lpaste.net
11:48:58 <samba1> there a datakind keyword, but I can't really figure out what it does
11:49:09 <monochrom> there is?!
11:49:13 <mniip> samba1, DataKinds is an extension
11:49:16 <mniip> not a keyword
11:49:49 <hypoon> monochrom: that's not easy, but I'll work on it.
11:50:19 <samba1> mniip: there is a datakind keyword, though
11:50:38 <samba1> datakind Foo = Bar
11:50:48 <samba1> is valid syntax, with DataKinds enabled and Foo and Bar in scope
11:50:55 <samba1> but I can't see what it does
11:51:00 <mauke> looks like a function definition to me
11:51:12 <mniip> what he said
11:51:29 <samba1> oh, maybe
11:51:30 <mauke> > let datakind x = x * 2 in datakind 21
11:51:32 <lambdabot>  42
11:51:32 <samba1> people use that syntax online
11:51:40 <mniip> samba1, link?
11:51:42 <samba1> but yes
11:51:43 <osa1> what's the possibilty of haskell-src-exts being a malware that uses users' CPUs while compiling it, using TemplateHaskell?
11:51:50 <samba1> it was in a stackoverflow question, I lost it now
11:51:55 <samba1> that's how I started using it
11:51:59 <mniip> osa1, 1.0
11:52:08 <monochrom> people on stackoverflow can also be wrong, you know
11:52:27 <samba1> yeah, I got that thanks
11:52:36 <uctcyc> Class Functor f => Mybifunctor f where mybimap :: (a -> b -> c) -> f a -> f b -> f c
11:53:02 <Gurkenglas> Anyone know any Haskell streamers?
11:53:25 <serendependy> Does anyone know of a library of APL-inspired functions?
11:53:26 <srhb> uctcyc: Looks like you want something like Applicative
11:54:18 <serendependy> If not I know what my next project is...
11:54:32 <uctcyc> What is an applicative Functor?
11:54:40 <Gurkenglas> uctcyc, lists with mybimap = zipWith?
11:55:08 <monochrom> serendependy: Data.List is a good start
11:55:20 <hiptobecubic> CurryWurst, there's a few things on the youtubes, but I don't know if any regular /r/watchpeoplecode types
11:55:27 <uctcyc> No it's far more general, I think it might be applicative
11:55:37 <serendependy> monochrom, I'm aware, but it unfortunately doesn't have quite what I'm looking for
11:55:55 <srhb> uctcyc: it looks like something a la yourfunc abc fa fb = fmap ($abc) fa <*> fb 
11:56:13 <srhb> woops. got application messed up there
11:56:26 <Gurkenglas> uctcyc, you spoke of "a data structure" so I thought you wanted a single instance :P. ZipList is the newtype wrapper of [] which has its Applicative instance use zipWith.
11:57:14 <uctcyc> A Functor is a container with a modifier, an Applicative Functor I'd one which can be modified with an associative operation partially applied to another Functor
11:57:46 <mniip> [20:48:31] <uctcyc> Class Functor f => Mybifunctor f where mybimap :: (a -> b -> c) -> f a -> f b -> f c
11:57:49 <mniip> that's Applicative
11:57:53 <mniip> :t liftA2
11:57:54 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:58:13 <uctcyc> Ziplist sounds good, but I require arbitrary representation as it is where I will place my optimisation
11:58:35 <Gurkenglas> uctcyc, Applicative also has pure :: a -> f a.
11:58:46 <uctcyc> Cool it's closed! Thanks for your help
11:58:54 <mniip> uctcyc, also your definition is wrong
11:59:06 <mniip> Functor is something that you can lift functions into
11:59:14 <mniip> Applicative is something you can lift N-ary functions into
11:59:18 <mniip> (including 0-ary)
12:00:01 <uctcyc> Hmm
12:01:46 <mniip> :t liftA3
12:01:47 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
12:01:48 <mniip> :t liftA2
12:01:50 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:01:59 <mniip> :t liftA -- that's liftA1
12:02:00 <lambdabot> Applicative f => (a -> b) -> f a -> f b
12:02:05 <mniip> :t pure -- that's liftA0
12:02:06 <lambdabot> Applicative f => a -> f a
12:02:14 <uctcyc> A Functor is a container for data which can be modified
12:02:24 <mniip> well some people say calling it a container is wrong
12:02:39 <mniip> uctcyc, does ((->) e) look like a container to you
12:02:49 <uctcyc> No
12:02:58 <mniip> well it is a functor
12:03:08 <anders0> does anyone know if the "GADTs meet their match" business will be able to check pattern synonyms' exhaustiveness?
12:03:18 <uctcyc> What's it's fmap?
12:03:23 <mniip> .
12:03:25 <jmcarthur> uctcyc: (.)
12:03:40 <jmcarthur> :t fmap `asTypeOf` (.)
12:03:41 <lambdabot> (a -> b) -> (a1 -> a) -> a1 -> b
12:03:44 <monochrom> when one says "a functor is/isnot a container", you should treat that "container" as a subjective feeling, not mathematically defined.
12:03:47 <anders0> (iirc it wasn't mentioned in the paper, but still, it might do, right?)
12:04:04 <mniip> monochrom, exactly
12:04:05 <voidzero> i'm more used to reading about 'context' than 'container'
12:04:09 <jmcarthur> let's just define "container" to mean "functor"
12:04:14 <mauke> ((->) e) looks like a container to me. specifically a map, represented by its lookup function
12:04:18 <mniip> I can stretch my mind to interpret ((->) e) as a container
12:04:29 <mniip> which is why I can, for myself, call functors containers
12:04:38 <monochrom> for example, many people do not feel IO to be a container
12:04:38 <mniip> not for everyone else though
12:04:56 <voidzero> context
12:04:59 <mniip> monochrom, Cont :P
12:05:05 <shachaf> When you tell someone "functors are containers", the mind in question isn't your mind but their mind.
12:05:06 <uctcyc> A Functor is a function taking an argument which can be modified?
12:05:17 <jmcarthur> but IO String obviously contains a String </joke>
12:05:36 <uctcyc> IO is a monad
12:05:42 <mniip> IO is a functor too
12:05:53 <mniip> it wouldn't be a monad without being functor
12:06:02 <uctcyc> What else is a monad whiz a Functor is not?
12:06:06 <Gurkenglas> monochrom, how about "container := representable functor that memoizes its contents?"
12:06:17 <mniip> uctcyc, there are no unfunctoral monads
12:06:36 <mniip> Gurkenglas, is Cont representable
12:06:58 <monochrom> Gurkenglas: has that definition been in wide use?
12:07:15 <Gurkenglas> No, I just thought it up, it seemed fitting
12:07:36 <jmcarthur> is "representable" redundant in that definition?
12:07:36 <shachaf> There is a paper by Abbott that has a definition for "container".
12:07:37 <monochrom> and if not, how much effort do you think is needed to get it into wide use?
12:08:16 <Gurkenglas> Assuming no one can find a problem with it, not that much. It'd take time is all
12:08:28 <uctcyc> (uctcyc) What else is a monad which a Functor is not?
12:08:30 <monochrom> and is it actually beneficial to get everyone, absolutely everyone, to adopt the same definition?
12:08:45 <shachaf> http://www.cs.nott.ac.uk/~txa/publ/fossacs03.pdf
12:08:46 <srhb> uctcyc: It has bind and return (which is pure, from Applicative)
12:08:51 <jmcarthur> i think Foldable is a fine definition for "container," personally
12:09:09 <uctcyc> Both bind and return are the same function pure?
12:09:12 <mniip> shachaf, a container is either an Identity, a sum of containers, a product of containers, a composition of containers, or a function returning a container
12:09:12 <monochrom> FWIW it doesn't even seem beneficial to inflict one single definition for "computation" on absolutely everyone
12:09:19 <srhb> uctcyc: No, just return is pure.
12:09:30 <srhb> uctcyc: bind is unique to monads.
12:10:07 <shachaf> Container is a bad word because it's suggestive of the wrong things. So best not to use it.
12:10:17 <sinelaw> Hey! Is there a type class for something like a parameterized "pointed monoid", i.e. non-functor/applicative class with: empty :: f a, singleton :: a -> f a, append :: f a -> f a -> f a ?
12:10:20 <jmcarthur> bindings have scope in natural languages just like in programming languages. it's fine for a word to have context-dependent meaning as long as you are explicit about it. what stinks is when there are words that people tend to make different assumptions about
12:10:29 <sinelaw> with the usual rules
12:10:34 <sinelaw> (laws)
12:10:44 <srhb> uctcyc: Functor gives you fmap, on top of that Applicative gives you pure and <*>, and on top of that Monad gives you bind
12:10:52 <monochrom> shachaf: I have a feeling that they should call it "categories of data structures" instead
12:10:58 <srhb> uctcyc: bind is (>>=) by the way
12:11:06 <jmcarthur> sinelaw: i'm surprised it's not a functor if it's pointed. i see how it's possible, but it's weird.
12:11:15 <sinelaw> jmcarthur: consider Set
12:11:34 <Gurkenglas> Great, now we're all primed :D
12:11:38 <jmcarthur> sinelaw: yeah
12:11:46 <shachaf> Set doesn't have parametric append, though.
12:11:57 <jmcarthur> sinelaw: anyway, i think there is a name for something like this. hold on, let me try to remember
12:11:58 <shachaf> There's a package reducers which might be close to what you want.
12:12:05 <uctcyc> jmcarthur not general enough... For instance, something which has the notion of adjacency or a boundary or four which no folding function exists but only a mapping
12:13:05 <uctcyc> How is bind not <*>
12:13:10 <uctcyc> ?
12:13:14 <voidzero> <*> is Applicative
12:13:28 <sinelaw> jmcarthur: excuse my algebra, isn't this a semigroup with a single element?
12:13:31 <voidzero> :t (<*>)
12:13:33 <sinelaw> err wait.
12:13:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:13:45 <uctcyc> :t(=>>)
12:13:47 <sinelaw> singleton takes a parameter
12:13:49 <sinelaw> so no.
12:13:59 <uctcyc> :t (=>>)
12:14:01 <lambdabot>     Not in scope: ‚Äò=>>‚Äô
12:14:01 <lambdabot>     Perhaps you meant one of these:
12:14:01 <lambdabot>       ‚Äò>>‚Äô (imported from Control.Monad.Writer),
12:14:06 <voidzero> you mean
12:14:09 <voidzero> :t (>>=)
12:14:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
12:14:19 <uctcyc> Thanks
12:14:48 <jmcarthur> sinelaw: ah, no, i was thinking something else. i don't have a name for this. i second the recommendation to look at reducers, though
12:15:12 <uctcyc> So it's like pure and <*> together?
12:15:21 <voidzero> pure and <*> are Applicative
12:15:36 <voidzero> Applicative does not know about >>=
12:15:40 <voidzero> Monad does
12:15:49 <uctcyc> But I could define bind in terms of pure and <*>
12:15:58 <srhb> uctcyc: It has to do with sequencing and the laws.
12:16:10 <srhb> uctcyc: Bind cannot be constructed in terms of pure and (<*>)
12:16:42 <voidzero> :t pure
12:16:44 <lambdabot> Applicative f => a -> f a
12:17:15 <sinelaw> there should be something like this for which all (reasonable) containers are instances
12:17:43 <sinelaw> lists, sets, heaps, queues, etc. 
12:17:46 <voidzero> i'm going to follow shachaf's advice, and try to avoid the word 'container'
12:17:55 <sinelaw> data structures then
12:18:03 <Fuuzetsu> too broad
12:18:09 <sinelaw> with kind * -> *
12:18:22 <sinelaw> and with the operations I mentioned :)
12:18:51 <sinelaw> well, yeah, of course they could be other things altogether
12:18:56 <monochrom> no, "data structure" is not too broad. you will find that most people's "data structure" does not exceed most people's "container", and vice versa.
12:18:59 <sinelaw> especially since the interface doesn't include a way to read the data
12:19:11 <jmcarthur> sinelaw: http://hackage.haskell.org/package/reducers-3.11/docs/Data-Semigroup-Reducer.html
12:19:15 <gingitsune> If a package wont compile with --allow-never whats the next step? is there a way to get an older base?
12:19:41 <srhb> uctcyc: Here's a good rundown: http://stackoverflow.com/questions/23342184/difference-between-monad-and-applicative-in-haskell
12:19:45 <voidzero> i don't see the need for a class that broad though
12:19:46 <uctcyc> isnt it about the language handeling kinds?
12:20:01 <dmwit> gingitsune: Install an older GHC.
12:20:02 <sinelaw> jmcarthur: thanks! has no "empty" though
12:20:06 <dmwit> gingitsune: (sorry about that)
12:20:07 <monochrom> sinelaw: look for the "edison" library
12:20:12 <Tuplanolla> I hope that flag doesn't actually exist gingitsune.
12:20:17 <jmcarthur> sinelaw: yeah, Monoid is just Semigroup with mempty
12:20:31 <dmwit> Tuplanolla: Probably a typo for --allow-newer.
12:20:38 <Tuplanolla> It's still funny.
12:20:44 <dmwit> yeah =)
12:21:12 <gingitsune> ^^"
12:21:15 <gingitsune> Ups
12:21:17 <sinelaw> monochrom: I didn't know Okasaki was a hackage contributor! :)
12:21:22 <gingitsune> Sorry about what though?
12:21:38 <dmwit> gingitsune: It's a bit frustrating that base and GHC are tied together so closely.
12:21:48 <dmwit> Perhaps someday that will change, though don't hold your breath.
12:22:15 <sinelaw> dmwit: +1
12:22:26 <dmwit> gingitsune: And of course the other route is to understand what changed between when the package was written and now, and update it. ;-)
12:22:34 <monochrom> monochrom's 2nd law: everything you wish for has been implemented and then fallen out of fashion
12:22:58 <voidzero> except for world peace
12:23:03 <dmwit> I'm not sure I wish for it, actually. I understand there were some hard decisions made to arrive where we are.
12:23:09 <dmwit> But it is frustrating whether I wish for it or not.
12:23:17 <dmwit> s/it/it's opposite/
12:23:19 <monochrom> ("2nd" because I'm sure I had a "1st law" but I can't remember what it says)
12:23:27 <dmwit> ?quote monochrom law
12:23:27 <lambdabot> monochrom says: The Three Laws of Types. (1) Must protect programmer. (2) Must obey programmer, when not in conflict with (1). (3) Must protect computer, when not in conflict with (1) or (2).
12:23:51 <gingitsune> Well sadly I know no Haskell, so GHC it is :p
12:23:54 <Gurkenglas> "monochrom's 1st law: I must forget monochrom's 1st law."
12:30:16 <osa1> does anyone know why this isn't a functor: http://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Generics.html#t::.:
12:31:46 <osa1> ha, found better one https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Data-Functor-Compose.html
12:33:18 <hypoon> OK, this is greatly simplified from my actual code (but it's still kinda messy, sorry! I didn't want to simplify away something that's important to my issue): http://lpaste.net/8112366505364029440 The problem is that the entire file is being read into memory before being processed. By adding some trace/putStrLn, I got it to stop doing that, but it's still consuming far too much memory for what it's doing. Sorry for the embarrassing c
12:34:41 <Gurkenglas> hypoon, if you simplify something important to the issue, mission accomplished, you know what causes the issue.
12:36:58 <hypoon> Gurkenglas: By "simplify" I mean "delete a ton of code and replace it with a dummy function". There's a lot of different ways to code what I'm trying to do, but I don't know how to do it the "smart" way.
12:38:04 <Gurkenglas> Ya, I meant if you keep testing after each change and find a deletion of a ton of code that makes the issue go away you've gained information
12:39:08 <hypoon> Gurkenglas: right, yeah. I suppose I'm trying to say: I've deleted most of the irrelevant code. I've left behind what causes the problem. Now how to do it better?
12:43:38 <ThugNasty_3434> new beginner here
12:43:40 <ThugNasty_3434> learnin
12:43:46 <monochrom> hypoon: when you have to add deepseq's and printing to reduce memory, then it cannot be a case of reading too early too much, because deepseq's and printing can only cause even earlier reading. instead, the cause is building up unevaluated expressions.
12:44:51 <monochrom> deepseq's and printing cause subexpressions to be evaluated earlier, therefore escaping a build up.
12:45:29 <monochrom> you can use Control.Exception.evaluate to replace printing, when in IO
12:46:00 <hypoon> monochrom: the deepseqs are being used to get the computational parts to happen while it's reading the file. It's obviously better to do it the other way: encourage it not to read the file until it needs the data.
12:46:38 <hypoon> monochrom: what I don't understand is why (when the deepseqs, traces, printing, etc... are removed) the file is being read in its entirety in the beginning.
12:47:36 <hypoon> monochrom: Control.Exception.evaluate might be fine for debugging, but I feel like forcing it is ruining the point of laziness in Haskell.
12:48:01 <monochrom> for example, you had: let {result = force $ ...}; putStrLn $ result `deepseq` "msg"; return (force result)
12:48:13 <qmm> is there a way to remove the parens from: (read "1") + 1
12:48:16 <monochrom> that can be replaced by: let {result = force $ ...}; evaluate result
12:48:34 <monochrom> evaluate is not for debugging. far from it.
12:49:04 <shachaf> qmm: You can usually use the arrow keys and backspace key.
12:49:30 <qmm> shachaf: heh, i didn't realize it would work without the parens :)
12:49:48 <qmm> i was scratching my head looking for something that would work with (+1)
12:49:53 <monochrom> I also contest the diagnosis of "the file is being read in its entirety in the beginning".
12:50:36 <hypoon> monochrom: that makes sense (regarding evaluate), but it's still what I'm trying to avoid. I'd rather it delay reading the file until relevant.
12:51:38 <hypoon> monochrom: I deduce that diagnosis from traces and 'putStrLn "message"', and watching the memory skyrocket repeatedly.
12:52:02 <monochrom> memory skyrocketting admits more than one hypothesis.
12:52:39 <monochrom> what have you done to eliminated mine, "instead it is unevaluated expressions building up"
12:53:38 <hypoon> would unevaluated expressions build up to five, six, seven gigabytes?
12:53:43 <monochrom> yes
12:55:32 <hypoon> ok, so what should I try to diagnose the situation properly?
12:56:13 <monochrom> you already did half of it. you added deepseq.
12:56:47 <monochrom> you just have to draw the correct conclusion. the deepseq's you added reduces buildup of unevaluated expressions
12:56:59 <hypoon> As posted, the code still consumes a lot of memory and runs relatively slowly.
12:57:05 <monochrom> and no amount of deepseq can possibly delay reading
12:57:42 <hypoon> The issue now is that instead of consuming a ton of memory up front, it distributes it over the course of running the program.
12:59:49 <hypoon> deepseq *can* delay reading by forcing computationally intense functions to evaluate before other reading takes place.
13:00:35 <Welkin> you can also stream the data, if necessary, using pipes
13:01:31 <monochrom> ok, when you know to say "forcing computationally intense functions to evaluate before other reading takes place" you really understand the issue.
13:03:41 <lpaste_> serendependy revised ‚ÄúGenerate a guess for Mastermind‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/140354
13:03:55 <serendependy> Gurkenglas, Hafydd: slightly better?
13:05:16 <monochrom> deepseq also destroys lazy lists. if you ask for a list of 1000000 items, deepseq will see to it that the whole 1000000-item list is entirely present in memory.
13:05:23 <Gurkenglas> Slightly, yes. Why the ' in guess'? Use https://hackage.haskell.org/package/safe-0.3.9/docs/Safe-Foldable.html#v:findJust
13:05:51 <monochrom> a list of 1000000 items takes at least 16000000 bytes.
13:06:02 <glguy> return $ force x  -- probably isn't what you meant
13:06:08 <monochrom> (this only counts the spine)
13:06:14 <glguy> it doesn't force x at that point
13:06:29 <Gurkenglas> (Or better, findJustNote. How are you so certain of justice?)
13:07:08 <hypoon> monochrom: deepseq doesn't solve the more important issue: the test file I'm using is about 500 megs. This file is read in 1 meg chunks. After each chunk is read, it can be processed and combined with the previous result. It should go, read chunk 1 (1m in memory), process chunk 1 (1m result in memory), read chunk 2 (2m in memory, process chunk 2 (2m in memory), combine results (1m in memory), read chunk 3 (2m in memory)... etc...
13:07:11 <monochrom> eventually you're going to ask "how should I write this properly" and my answer will be the broad "understand laziness properly first"
13:07:14 <Gurkenglas> (*serendependy x2)
13:07:34 <serendependy> Gurkenglas, What does "findJustNote" do exactly? Error out?
13:07:50 <Gurkenglas> yep, *Note lets you choose your own error message
13:08:55 <serendependy> Gurkenglas, I'm not sure of justice (cute way to express it). But if this part fails I want the whole program to crash, because it means my mental model of the solver is totally wrong
13:09:39 <hypoon> monochrom: each chunk of the test file is actually a list with 80k elements, each element containing three floats, each float of four bytes. 80k*3*4b=960kb~1mb
13:09:45 <serendependy> findJustNote is pretty cool though, will use it
13:09:46 <Gurkenglas> Yep, that's a case for findJustNote :D I was afraid some programming challenges site gave you an interface that doesn't include Maybe or something
13:10:14 <Gurkenglas> goodGuess is elem Nothing, isn't it
13:11:06 <Gurkenglas> *not of course
13:11:18 <hypoon> monochrom: if that chunk is stored larger in haskell, I don't really care, but the key issue is that the memory shouldn't ever need to increase beyond the memory footprint necessary to process two chunks. (Fine, maybe slightly, but it should never reach the memory footprint of 10 chunks)
13:11:33 <hypoon> monochrom: it's like a running average.
13:12:37 <hypoon> monochrom: the memory requirements to compute a running average of a list stored on-disk shouldn't depend on the length of the list. The processing time should be linearly related to the length of the list.
13:13:02 <serendependy> Gurkenglas, Completely my own initiative, no limitations
13:14:13 <serendependy> Gurkenglas, not quite. A good guess may indeed have "Nothing" in it, before it's filled with the current peg
13:15:06 <serendependy> The only requirement is that a guess mentions every peg that we know exists in the code
13:15:54 <hypoon> monochrom: honestly, I believe I understand laziness, though I fully admit I don't really understand "force", "deepseq", etc... and how they impact the laziness.
13:17:09 <Gurkenglas> Okay, so the actual problem you're trying to solve is "given a list of sets, choose a value from each set such that the chosen values are pairwise different"
13:18:08 <Gurkenglas> Sounds NP-hard and a job for a SAT solver :D
13:18:12 <serendependy> Gurkenglas, That *sounds* right, but I'm not sure
13:18:31 <serendependy> Gurkenglas, Fortunately for me, the problem size is tiny! ;)
13:18:41 <serendependy> NP = P for small enough N
13:18:55 <Gurkenglas> For small enough nondeterminisms? Fair enough.
13:19:43 <serendependy> Gurkenglas, 8 possible pegs, 4 possible positions. Pretty tractable
13:20:12 <serendependy> Especially without repeats
13:20:20 <Gurkenglas> length (Map.keys pos) <=4?
13:20:30 <serendependy> Gurkenglas, Yes
13:21:25 <Gurkenglas> Why not just check all permutations of take 4 $ map Just (elems pos) ++ repeat Nothing?
13:21:27 <int-e> Gurkenglas: what you described is a matching problem in a bipartite graph (with nodes for the sets and the objects)
13:21:29 <serendependy> and max . map length $ Map.values ps <= 4
13:21:42 <int-e> (so in P)those are in P.
13:21:53 <hypoon> How would one write a command to perform a running average of data as read from a file?
13:22:01 <hypoon> s/command/function/
13:22:05 <dmj`> I wish SPJ used a mic for that ICFP presentation on ghc
13:22:56 <dmj`> hypoon: you can create a stream in IO that that processes the file and writes the result to an IORef
13:22:57 <serendependy> Gurkenglas, hmm, let me check that
13:23:58 <Gurkenglas> Huh. Didn't think about it much, it just looked vaguely like a bunch of clauses.
13:25:25 <serendependy> Gurkenglas, Sorry, I'd need a code snippet to better understand what your suggesting. I didn't get anything useful from testing the `take 4 ...`
13:30:00 <glguy> hypoon: You just need to make sure that whatever value it is that you're accumulating per chunk doesn't depend on the previous block before you load the next blook
13:30:16 <glguy> but based on the way you were using force in your last example you have a little more to learn about laziness still
13:31:20 <hypoon> glguy: I started inserting "force"s all over the place in a last-ditch attempt to make it do what I want... but it didn't work, lol. (nor did I really expect it to)
13:34:00 <hypoon> glguy: an earlier attempt looked like this: someVar <- foldl1 (liftM2 (addProcessedData)) $ map (liftM (processData)) $ replicate 500 (getNextChunkFromFile)
13:35:03 <hypoon> glguy: and I was kinda surprised when that didn't work. I expected everything to be done lazily, and then when it needed someVar, I expected it to recurse through the foldl1 and only evaluate the getNextChunkFromFile as needed.
13:35:24 <Welkin> hypoon: it sounds like you want pipes
13:35:48 <monochrom> no, I don't think pipes makes a difference
13:36:27 <hypoon> Welkin: while I'll admit upfront that I know nothing about pipes, I suspect it may be an issue that I'm locked into using a function that gets the data one chunk at a time.
13:37:01 <hypoon> Welkin: although it may be possible to write a wrapper around that function to make it behave like a lazy list that gets evaluated as necessary, I suppose. I don't know how to do that, though.
13:37:23 <monochrom> the current code is already coded to be exactly: "read a block, process it (or at least build an unevaluated expression that processes it), repeat". pipes will only make it look nice.
13:37:55 <hypoon> monochrom: which current code? the lpaste or the line I posted a few minutes ago?
13:38:10 <monochrom> yes
13:38:24 <lpaste_> Gurkenglas annotated ‚ÄúGenerate a guess for Mastermind‚Äù with ‚Äúserendependy, here's your snippet‚Äù at http://lpaste.net/140354#a140416
13:39:31 <serendependy> Gurkenglas, Thanks, testing out now
13:41:13 <serendependy> Gurkenglas, type Code = [Peg]. This snippet seems to think it's [Int] ?
13:41:47 <lpaste_> serendependy annotated ‚ÄúGenerate a guess for Mastermind‚Äù with ‚Äúserendependy, here's your snippet (annotation)‚Äù at http://lpaste.net/140354#a140417
13:41:58 <hypoon> monochrom: by "yes" do you mean that both are doing the same thing?
13:42:21 <monochrom> you have essentially just one piece of code. what is "both"?
13:43:28 <lpaste_> Gurkenglas annotated ‚ÄúGenerate a guess for Mastermind‚Äù with ‚Äúserendependy, I mean keys of course. Weird that the error didn't already complain about the (++).‚Äù at http://lpaste.net/140354#a140418
13:43:32 <monochrom> sorry, not the line posted a minute ago.
13:43:46 <qmm> is the `(x,y)` section of `import Mod (x,y)` called an explicit import list?
13:43:47 <serendependy> Gurkenglas, yeah, just noticed that
13:43:55 <monochrom> you know what, the line posted a minute ago is no different.
13:45:17 <monochrom> qmm: does the Haskell 2010 Report give it a name?
13:45:39 <monochrom> it says "export list"
13:45:57 <serendependy> Gurkenglas, It seems to work. I'll have to study it to 1) understand it 2) make sure it's the same
13:46:01 <serendependy> But thanks a bunch :)
13:46:05 <monochrom> you can throw in "explicit" for your personal emphasis if you like
13:46:23 <hypoon> monochrom: can you explain how the laziness of the line I posted is not as I expected?
13:47:07 <monochrom> err, I guess it's "import list" for the import case. I was reading the export section
13:47:55 <qmm> monochrom: https://wiki.haskell.org/Import_modules_properly#Counter-arguments_to_explicit_import_lists
13:48:57 <qmm> i figured the `(x,y)` seciton of `import Mod (x,y)` was the explicit import list referred to in that wiki article
13:49:08 <monochrom> I wouldn't consider the wiki to be of the same calibre as the Haskell 2010 Report
13:49:14 <Welkin> I typically import qualified, or unqualified if I know there are no conflicts
13:49:32 <qmm> monochrom: but it's from the ghc dev team right?
13:49:42 <monochrom> how do you know?
13:49:55 <Welkin> If I know I only need a couple functions/Constructors, I may use an import list
13:50:26 <gingitsune> So I'm still fighting the fighting the ghc with the old base. After not having a clue what to do with the older GHC binaries I tried to go with stack.
13:50:28 <qmm> monochrom: i guess i don't. that part was put in by https://wiki.haskell.org/User:Lemming
13:50:55 <Welkin> gingitsune: you cannot upgrade base since it comes with ghc
13:51:06 <Welkin> you need to remove the old ghc and install a new one to upgrade base
13:51:06 <samba1> https://www.reddit.com/r/haskell/comments/3j3by9/applying_typelevel_and_generic_programming_in/cusrqtu
13:51:20 <samba1> Does anyone know why I'd get this error when compiling or running but not in ghci?
13:51:45 <Sindriav_> samba1: Monomorphism restriction?
13:51:47 <qmm> monochrom: i'm trying to figure out the names of different import strategies listed at https://wiki.haskell.org/Import
13:51:54 <serendependy> Gurkenglas, generateGuess (Map.fromList [(White,[1,3]), (Black,[2,3]), (Yellow,[1,2])]) Orange
13:51:55 <serendependy> [Orange,Yellow,Black,White]
13:52:03 <serendependy> It even works on the tricky case :)
13:52:16 <gingitsune> It's giving me a warning message of certain doom with any GHC bellow 7.8
13:52:40 <gingitsune> Welkin: I'd like to downgrade it if possible :)
13:52:43 <samba1> Sindriav_: how so? and adding a NoMonomorphismRestriction doesn't change anything
13:53:00 <merlin2> where are & (flipped $) and <&> (flipped <$>) defined?
13:53:18 <merlin2> & (flipped $)
13:53:19 <Sindriav_> merlin2: I'd guess Data.Function
13:53:39 <Sindriav_> merlin2: At least that's where (&) is IIRC
13:53:49 <Sindriav_> samba1: I was just guessing. It's one of the more usual cases of things working in GHCi and not when compiled
13:54:06 <glguy> samba1: and you're sure all those commands use the same version of GHC?
13:54:11 <merlin2> I don't have & there. I am using 7.8.4
13:54:45 <samba1> glguy: yes, all 7.8.3 which is all I have installed
13:55:22 <Sindriav_> merlin2: Also, I've never seen "<&>"‚Ä¶
13:55:25 <Sindriav_> :t flip (<$>)
13:55:27 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:56:10 <int-e> hmm, is there an IOCCC entry that *only* uses setjmp and longjmp for control flow? http://www.ioccc.org/2004/burley.c looks good at first glance but actually uses ?:, && and || as well.
13:56:24 <int-e> s/control flow/flow control/
13:56:30 <Sindriav_> int-e: Are you sure this is the right channel?
13:56:38 <int-e> Sindriav_: it's not. sorry
13:56:46 <Sindriav_> int-e: No prob ^^
13:56:54 <samba1> if I make it into a cabalized project it's the same, cabal repl works fine, cabal run gives me the error
13:57:14 <Sindriav_> I'm still getting nowhere useful with my TypeMap x_x That shit melts my brain still
13:57:26 <merlin2> oh <&> is part of lens
13:57:30 <Sindriav_> samba1: Can you paste the error?
13:57:38 <merlin2> http://hayoo.fh-wedel.de/?query=%3C%26%3E
13:57:41 <samba1> https://www.reddit.com/r/haskell/comments/3j3by9/applying_typelevel_and_generic_programming_in/cusrqtu
13:57:43 <merlin2> hayoo found it, hoogle didn't
13:58:13 <Sindriav_> merlin2: You have to specify packages for Hoogle. https://www.haskell.org/hoogle/?hoogle=%28%3C%26%3E%29%20%2Blens
13:59:07 <ReinH> which sort of defeat the purpose of using hoogle to look up things
13:59:09 <kadoban> Sindriav_: Which isn't terrifically useful, since you're usually not sure what package it's in, if you're hoogleing.
13:59:13 <ReinH> *defeats
13:59:37 <Sindriav_> By all means.
14:00:02 <kadoban> stackage's hoogle is better in that regard, though it doesn't have all of hackage in it. Hayoo seems better too, though I don't really like the interface as much.
14:00:33 <monochrom> hypoon: I'm going to use the much simpler example foldl1 (liftM2 (+)) (map (liftM ord) (replicate 500 getChar))
14:00:33 <Sindriav_> I don't like the name.
14:00:45 <monochrom> (feed /dev/zero to it for good measure)
14:00:54 <monochrom> it does the following operationally:
14:01:50 <Sindriav_> monochrom: Maybe (map ord (replicateM 500 getChar)) would be faster?
14:02:11 <broma0> What are your thoughts on vty vs ncurses for building a terminal app in haskell?
14:02:37 <sm> "vty is awesome" ?
14:02:54 <sm> "and has brick"
14:02:55 <monochrom> 1. build up a huge expression consisting of 500 "liftM ord getChar"'s connected up by the "liftM2 (+)"s. that is, no I/O yet
14:03:42 <broma0> sm: I've had a similar experience with it, but I've never used ncurses before and I'm considering trying it out. Have any experience with ncurses?
14:04:20 <sm> broma0: not really. I have the impression it would be harder for end-users to install on some platforms, but that might be wrong
14:05:45 <Sindriav_> broma0: As far as C goes, ncurses are old and dumb. I couldn't get them to handle unicode consistently.
14:05:53 <monochrom> 2. loop over this: execute one getChar (now this actually reads one Char), build up "ord <that Char>" (no evaluation), later join it into part of a huge expression totally 500 "ord <some Char here>" connected up by +'s
14:06:00 <sm> yes that is wrong, since vty doesn't work on windows. Hopefully will soon though
14:06:10 <monochrom> 3. lastly, evaluate those +'s
14:07:11 <Sindriav_> Is there someone skilled in typesystem magicks, who could help me implement my TypeMap?
14:07:25 <mniip> monochrom, you
14:07:29 <mniip> 're doing it wrong
14:07:32 <broma0> sm: maybe ill mess around with brick for this next project then.. im just afraid itll make too many decisions for me. plain old vty might do the trick too
14:07:35 <broma0> thanks
14:07:36 <monochrom> actually, 3 may or may not happen, and you don't know what time it happens until you know the user
14:07:49 <lpaste_> mniip pasted ‚Äúthe right way to do it‚Äù at http://lpaste.net/140419
14:08:50 <sm> broma0: good luck.. I just learned it so feel free to ping me
14:09:04 <sm> s/learned/built an app with/
14:09:14 <broma0> sm: ok, if i run into trouble i just might!
14:09:19 <broma0> sm: thank you for the offer
14:09:51 <monochrom> mniip: you may be making a good joke, but you're using up a lot of someone else's resource to make it.
14:12:28 <samba1> UGH
14:12:32 <samba1> it was the lack of scoped type variables
14:12:36 <monochrom> also, your code looks more like foldr1 than foldl1
14:12:48 <samba1> as I thought, the n in the signature for sNat was unrelated to the n in the signature of the function
14:13:06 <Jinxit> is there a nice mathematical function to describe all 8 directions in a 2D tiled space? (north, northwest, west, etc)
14:13:06 <samba1> but it took me a bit to figure out that scopedtypevariables would help that
14:13:12 <Jinxit> excluding the center tile
14:13:46 <monochrom> must it be a function? can it not be a list?
14:14:00 <Jinxit> of course I could just write them down
14:14:00 <samba1> it worked in GHCi because I have :set -XScopedTypeVariables in my ghci.conf and it must apply that downwards into the files as it loads them
14:14:08 <Jinxit> but I was thinking if there's anything prettier
14:14:11 <monochrom> because if it must be a function, I know a very simple way
14:14:29 <hypoon> Jinxit: direction(n) = (cos(2*n*pi/8),sin(2*n*pi/8))
14:14:52 <Jinxit> does that discretize correctly to tiles?
14:15:09 <hypoon> Jinxit: ah, misunderstood that part.
14:15:12 <koala_man> I botched a hackage upload. Can I have it deleted or something? 
14:15:35 <sm> [(x,y) | x<-[-1..1], y<-[-1..1], not (x==0 && y==0)]
14:15:48 <Jinxit> I like that
14:15:49 <indiagreen> koala_man: you can have the specific version deprecated
14:15:54 <Jinxit> thanks
14:16:16 <hypoon> Jinxit: sm: the order may not be obvious from that though. It won't be simply clockwise or counterclockwise.
14:16:18 <koala_man> indiagreen: how do I do that?
14:16:34 <hypoon> Jinxit: sm: (which may be fine, depending on application)
14:16:40 <sm> nod. yours looks way cooler.
14:17:11 <indiagreen> koala_man: http://hackage.haskell.org/package/<your package name>/preferred/edit
14:17:12 <arkeet> why not: x /= 0 || y /= 0
14:17:18 <hypoon> sm: but, as Jinxit pointed out, it doesn't discretize properly.
14:17:34 <sm> (but I'm not sure what it does :)
14:17:47 <monochrom> arkeet: should it matter?
14:17:51 <arkeet> no
14:17:52 <arkeet> :)
14:18:11 <monochrom> why is everyone being a context-free just-wanna-be-different code rewriter?
14:18:15 <koala_man> indiagreen: great, thanks!
14:18:18 <Jinxit> arkeet: that would exclude north, south, east, and west
14:18:32 <hypoon> Jinxit: direction(n) = (round( cos(2*n*pi/8) )  ,  round( sin(2*n*pi/8) ))
14:18:44 <indiagreen> monochrom: 'cause rewriting Haskell code is fun
14:19:11 <monochrom> it is not fun to me
14:19:24 <indiagreen> it is fun to me, so maybe we're just different
14:19:31 <hypoon> on the diagonals, it used to yield 0.707 for x and y values. simply round them up to 1 :-D
14:19:38 <Pamelloes> Are there any good libraries for converting an svg or an eps file to png?
14:19:56 <indiagreen> I mean, whenever any of my friends writes Haskell code my 1st urge is to see how I can rewrite it better, and I'm pretty sure it's not because I want to show that I'm smart or something
14:19:59 <monochrom> it is no fun to read. and it distracts from the main point.
14:20:05 <indiagreen> true
14:20:16 <indiagreen> I didn't say it was productive or good or anything
14:20:19 <Jinxit> hypoon: neat, it actually works
14:20:25 <d-snp> jay, Segmentation fault (core dumped)
14:20:26 <Jinxit> but I think the other one is clearer in intent
14:20:51 <monochrom> it makes #haskell all the more unproductive, unpleasant, pedantic trivial-pursuit place
14:21:04 <L8D> > [(x,y) | x<-[-1..1], y<-[-1..1], not (x==0 && y==0)]
14:21:05 <lambdabot>  [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
14:21:09 <indiagreen> which is one of the reasons why I'm trying not to be doing it so much anymore
14:21:26 <Welkin> When I see haskell functions that are 50-100 lines long with several levels of indentation for lambdas and case expressions, I get lost
14:21:32 <indiagreen> but this requires, y'know, actually noticing that it makes #haskell an unproductive/unpleasant/trivial-pursuit place
14:21:35 <Jinxit> is it wrong to want to write nice code?
14:21:39 <Jinxit> I don't see the problem
14:21:44 <sm> bah monochrom. spoilsport
14:21:49 <indiagreen> ah so
14:21:50 <Welkin> if it is fro some tutorial I am following, I rewrite it as multiple smaller functions
14:21:52 <indiagreen> monochrom++
14:22:31 <monochrom> Jinxit, it is wrong to want to do a good thing and then fail to do it
14:22:47 <hypoon> Jinxit: what my suggestion does is literally rotate around the unit-circle, starting from the x-axis and working counter clockwise in steps of 2*pi/8 radians (45 degrees). Without rounding, you could simply change the 8 to whatever number you please to get that many equally-spaced subdivisions.
14:22:52 <monochrom> or rather, it is wrong to want to do a good thing and then end up doing a bad thing
14:23:34 <levi> If you're familiar with the relationship of sin/cos and the unit circle, the one based on sin/cos is perhaps even more descriptive than the one that directly enumerates direction vectors.
14:23:45 <monochrom> if there is a piece of code and it is really important to rewrite, then sure, rewrite.
14:23:54 <Jinxit> hypoon: oh I know how sin and cos works, I just think [-1..1] is clearer in how the rounding works out
14:24:03 <Jinxit> (since there is none)
14:24:17 <levi> Like a lot of things, the clarity of a particular approach depends on your background and the context.
14:24:19 <monochrom> but in this case we're looking at "not (a && b)" vs "(not a) || (not b)" which is not worth it
14:24:40 <indiagreen> monochrom: I wish there were more blog posts/PSAs/etc about... how do I call them... social issues, maybe?
14:25:00 <indiagreen> ‚Äúhere's how you might've been spoiling #haskell without even knowing it‚Äù
14:25:20 <indiagreen> somehow I never end up writing about those things even tho I want to
14:25:25 <hypoon> Jinxit: oh yeah, I do agree in that regard. The *only* reason not to do it that way, in my opinion, is if you want a clear order. If pressing a key is going to cycle through the directions, you wouldn't normally want them to jump around.
14:26:19 <hypoon> monochrom: mniip: regarding your explanations, is there a variant of fold that does not build the entire expression before beginning to evaluate?
14:26:28 <Jinxit> yeah I agree, levi
14:26:29 <Jinxit> I will definitely keep that trig snippet in my back pocket
14:26:42 <Welkin> hypoon: strict fold
14:26:51 <Welkin> hypoon: specifically, foldl'
14:27:05 <mniip> hypoon, foldr?
14:27:40 <mniip> > foldr (||) $ True:undefined
14:27:41 <lambdabot>      Couldn't match expected type ‚ÄòBool‚Äô with actual type ‚Äò[Bool]‚Äô
14:27:42 <lambdabot>      In the second argument of ‚Äò($)‚Äô, namely ‚ÄòTrue : undefined‚Äô
14:27:42 <lambdabot>      In the expression: foldr (||) $ True : undefined
14:27:47 <mniip> > foldr (||) False $ True:undefined
14:27:48 <lambdabot>  True
14:28:05 <hypoon> Jinxit: That generates evenly spaced directions in a two-dimensional plane. If you want a real thought experiment, try to generate n evenly spaced directions on the unit sphere in three dimensions, for any parameter n. As far as I'm aware, it's not possible.
14:28:52 <Jinxit> you would need two subdivisions, wouldn't you?
14:29:03 <monochrom> hypoon: none of foldr, foldl' will help this particular case. (again, other people are being context-free knee-jerk-effect)
14:29:04 <Jinxit> as in, one for each dimension in spherical coordinates
14:29:17 <monochrom> foldM helps, but you will have to use it right
14:30:34 <hypoon> Jinxit: it's not so simple, because the normal definitions of azimuth and zenith angles will cause the lateral spacing to change as you change the zenith angle (but hold the azimuth angle constant).
14:31:12 <hypoon> monochrom: That's kinda what I figured, which is how I ended up with what I posted in lpaste.
14:31:14 <monochrom> hypoon: foldM op 0 (map (liftM ord) (replicate 500 getChar))
14:31:30 <monochrom> where op x m = do { y <- m; evaluate (x+y) }
14:32:41 <Jinxit> oh
14:32:44 <Jinxit> yeah I see what you mean
14:33:13 <Jinxit> it would have to be a hexagonal pattern then?
14:33:21 <Jinxit> meaning not all numbers are valid
14:33:41 <Jinxit> I guess triangles work too
14:33:46 <eikke> anyone (very) familiar with typelits and operations on them? hvr?
14:34:25 <hvr> eikke: there's people more familiar with them than me :)
14:34:49 <orion> http://chrisdone.com/posts/haskellers
14:34:55 <hvr> eikke: ...what's your question?
14:34:58 <JagaJaga> @pl take 5 $ fix (((<$>) <$> ( : ) <*> ((=<<) <$> (return <$>) <$> ( *) <$> join (+))) 1)
14:34:58 <lambdabot> take 5 (fix (((<$>) <$> (:) <*> ((=<<) <$> (return <$>) <$> (*) <$> join (+))) 1))
14:35:51 <JagaJaga> > take 5 $ fix (((<$>) <$> ( : ) <*> ((=<<) <$> (return <$>) <$> ( *) <$> join (+))) 1)
14:35:53 <lambdabot>  [1,2,4,8,16]
14:36:08 <hypoon> Jinxit: You're picturing the vertices of platonic solids. See https://en.wikipedia.org/wiki/Platonic_solid. Archimedean solids sorta work, depending on the strict definition of "evenly spaced". (https://en.wikipedia.org/wiki/Archimedean_solid)
14:36:23 <eikke> hvr: if I have a 'newtype T (n :: Nat)', and a function 'f :: (KnownNat n1, KnownNat n2, CmpNat n1 n2 ~ 'LT) => T n1 -> T n2 -> T (n2 - n1)', is there a way to tell GHC there should be a KnownNat instance for (n2 - n1)?
14:36:57 <eikke> hvr: sorry, I was looking for Richard actually, been confusing names... but anyway :)
14:37:11 <hvr> eikke: does GHC like if you added 'KnownNat (n2 - n1)' to the constraints?
14:37:14 <hvr> +it
14:38:10 <eikke> hvr: hmh, excellent point... will try (although that could be inferred, right?)
14:38:11 * hvr takes it as a compliment to be confused for Richard
14:38:59 <eikke> hvr: beats me, that does the trick indeed. Sweet!
14:39:12 <hvr> eikke: well, GHC is still a bit weak in inferring all it could infer 
14:39:31 <Jinxit> is there something in prelude which applies a function repeatedly to a value with different arguments? so "fun (*) 2 [5, 2, 3]" would yield 60
14:39:39 <eikke> hvr: I do have the ghc-typelits-natnormalise plugin enabled as well, mayybe that has some influence as well
14:40:16 <Welkin> Jinxit: foldr
14:40:19 <JagaJaga> Who can tell me how this works? :) `take 5 $ fix (((<$>) <$> ( : ) <*> ((=<<) <$> (return <$>) <$> ( *) <$> join (+))) 1)`
14:40:22 <Tuplanolla> Are we racing to become Idris before Idris does?
14:40:26 <hypoon> monochrom: that makes a lot of sense (referring to foldM and all), and I thought I tried something similar.
14:40:30 <Welkin> > foldr (*) 2 [5,2,3]
14:40:31 <lambdabot>  60
14:40:31 <hiptobecubic> Jinxit, that is exactly a fold.
14:40:35 <Jinxit> derp
14:40:37 <hiptobecubic> oh, Welkin wins :)
14:40:49 <Jinxit> getting woozy
14:41:04 <Welkin> JagaJaga: that is a mess
14:41:15 <Welkin> JagaJaga: I doubt anyone wants to decipher it
14:41:31 <hiptobecubic> unpl?
14:41:36 <Welkin> JagaJaga: do you have a non-point-free version?
14:41:48 <Jinxit> if I don't care for the order and all elements are needed, should I do foldr or foldl? perhaps with a '?
14:42:12 <Welkin> Jinxit: foldl'
14:42:20 <Jinxit> alright, thanks
14:42:24 <hypoon> Jinxit: "applying a function repeatedly to a value with different arguments" sounds like a map to me: map (2*) [5,2,3] -> [10,4,6], but I suppose that's not what you meant.
14:42:27 <Tuplanolla> Probably foldr or sometimes foldl'. Read the Wiki article about it Jinxit.
14:42:33 <Welkin> Jinxit: it uses less memory and runs faster for functions strict in both arguments, like (*)
14:42:53 <Welkin> Jinxit: also, you described `product`
14:43:15 <Welkin> > foldl1 max [1..1000000]
14:43:17 <lambdabot>  *Exception: stack overflow
14:43:24 <Welkin> > foldl1' max [1..1000000] -- Jinxit 
14:43:26 <lambdabot>  1000000
14:43:36 <JagaJaga> Welkin: no :(
14:44:01 <Welkin> @unpl take 5 $ fix (((<$>) <$> ( : ) <*> ((=<<) <$> (return <$>) <$> ( *) <$> join (+))) 1)`
14:44:01 <lambdabot> <unknown>.hs: 1: 87:Parse error: EOF
14:44:06 <Welkin> @unpl take 5 $ fix (((<$>) <$> ( : ) <*> ((=<<) <$> (return <$>) <$> ( *) <$> join (+))) 1)
14:44:06 <lambdabot> (take 5 (fix ((((<$>) <$> ((:))) <*> ((((\ e f -> f >>= e) <$> \ a -> return <$> a) <$> (*)) <$> ((+) >>= \ g -> g))) 1)))
14:44:18 <Welkin> well that didn't help much
14:45:15 <Jinxit> yeah I wanted a fold, and the (*) was just a toy example
14:47:23 <res0001> (absolute newbie here) How is Fractional supposed to be used in the proposed fix of my code posted at http://lpaste.net/140420 ??
14:48:11 <kadoban> res0001: You don't want that fix. You probably want `div` instead of /
14:48:16 <kadoban> :t div
14:48:17 <lambdabot> Integral a => a -> a -> a
14:48:33 <kadoban> > 3 `div` 2
14:48:34 <lambdabot>  1
14:49:05 <Tuplanolla> You most likely want `quot`.
14:49:25 <Tuplanolla> > -3 `div` 2
14:49:26 <lambdabot>  -1
14:49:48 <res0001> kadoban, Yep, `div` did the trick -- thx
14:50:42 <Tuplanolla> Duh, wrong example.
14:50:59 <Tuplanolla> > (5 `div` (-2), 5 `quot` (-2))
14:51:01 <lambdabot>  (-3,-2)
14:51:56 <kadoban> His divisor is 2, it's not going to matter.
14:51:59 <res0001> my inputs are always nonnegative, so I suppose then there's no diff between div and quot ??
14:52:23 <monochrom> right
14:52:38 <monochrom> for Int, quot is faster :)
14:53:28 <monochrom> but people rightly object to it. div gives more desirable answers when negative
14:53:48 * monochrom has a cunning plan!
14:54:08 <monochrom> use quotMod or divRem for both better answers and better speed :)
14:55:30 <Tuplanolla> You mean divMod or quotRem.
14:56:16 <monochrom> no, it's a joke, it crosses the worst of both worlds
14:56:34 <res0001> btw ... is lambdabot some kind of bot ? (sorry if really a person :)
14:56:41 <monochrom> yes
14:57:04 <res0001> what does it do?
14:58:29 <monochrom> it can evaluate Haskell expressions, call quickcheck, take notes, remember quotes
14:58:55 <monochrom> seq can help you distinguish lambdabot from bot
14:59:15 <res0001> does it just evaluate all expressions in all posts, or is there some control?
14:59:41 <monochrom> you have to say "> 3+4" to get the evaluation
15:00:00 <Tuplanolla> ?quote monochrom now
15:00:00 <lambdabot> monochrom says: at a crossroad you meet an angel (always tells the truth) or demon (always lies). the crossroad gives you two choices of roads, one to heaven, one to hell, and only the angel or demon knows which is which. if you ask "how would you answer if I asked 'what is a monad?'", what will happen?
15:00:09 <monochrom> even cutting out the space there will spoil it
15:02:52 * hackagebot irc-core 1.1.2 - An IRC client library and text client  https://hackage.haskell.org/package/irc-core-1.1.2 (EricMertens)
15:05:03 <Jinxit> actually, regarding my earlier question, I have a function ":: Bar -> Foo -> Bar", and I want to start with a base Bar and apply several Foo to it, that's not quite a fold is it?
15:05:36 <Rembane> :t foldr
15:05:37 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
15:05:40 <monochrom> it is quite a fold
15:05:45 <Rembane> It is indeed.
15:07:22 <monochrom> @type (&)
15:07:23 <lambdabot> a -> (a -> b) -> b
15:10:36 <Jinxit> ok yeah, seems I had my arguments in a tricky order
15:10:45 <jle`> Jinxit: sounds like as much of a fold as it gets :)
15:15:22 <dmwit> monochrom: Your "seq" joke took me a minute, but I enjoyed it a lot.
15:18:13 <monochrom> hehe
15:20:55 <hypoon> monochrom: thank you for your help and your patience, I'm a few more steps in the right direction now. Time to walk away for a bit though.
15:21:16 <monochrom> you're welcome
15:37:05 <slack1256> on emacs, is there something like C-x C-e that instead of eval a sexp evals haskell code? I am sure I saw edk doing that on a presentation
15:37:35 <Sindriav_> slack1256: Look in the documentation of the plugins you are using.
15:37:55 <hvr> slack1256: there was a way to send a selection of haskell code to the REPL iirc
15:40:21 <hvr> s/selection/region/
15:40:54 <Sindriav_> Are there some papers etc. on Entity Component Systems in Haskell?
15:41:12 <Sindriav_> I've got *something* going, but I'd like to make it less messy and more static, if possible
15:41:12 <Sindriav_> http://lpaste.net/6181961241922109440
15:45:38 <boyscared> slack1256: if you figure that out, i'd like to know that too :)
15:46:00 <slack1256> boyscared: ;-)
15:47:03 <slack1256> even so, It doesn't seem to difficult to write, I am I can grab the region on emacs and pass it to the REPL of ghci on emacs (assuming haskell-mode) enclosed on :{ and :}
15:47:21 <slack1256> *I mean I can grab
15:48:46 <Welkin> boyscared: what are you scared of?
15:49:05 <Sindriav_> slack1256: Not everything you can write in a file you can write in ghci
15:49:43 <slack1256> yep, but this is the overview
15:49:53 <Sindriav_> slack1256: Instead, why not eval your file and then drop into ghci?
15:50:03 <Sindriav_> C-c C-l should do that.
15:50:08 <slack1256> I want a good setup for tidal
15:51:21 <Sindriav_> Then why didn't you ask about tidal?
15:51:42 <geekosaur> maybe c-x c-d?
15:51:52 * geekosaur has a somewhat old haskell-mode though
15:52:11 <slack1256> because the tidal part is OK, I just want to do it inside of emacs for the highlighting
15:52:16 <Welkin> what is tidal?
15:52:29 <slack1256> (this also useful on other context though)
15:52:40 <Sindriav_> slack1256: The tidal part is apparently not ok.
15:52:43 <Sindriav_> @where xyproblem
15:52:43 <lambdabot> xyproblem.info
15:52:57 <Sindriav_> slack1256: I recall using C-c C-c with tidal, does that not do what you want?
15:53:37 <slack1256> C-c C-c toggle check command? doesn't that just typechecks?
15:53:53 <Sindriav_> slack1256: Not what the tidal docs say: https://github.com/tidalcycles/Tidal/blob/master/doc/tidal.md
15:54:07 <Sindriav_> "To run the code, use Ctrl-C then Ctrl-C."
15:54:41 * slack1256 goes reading
15:54:42 <Sindriav_> slack1256: Did you setup emacs for Tidal? (as per the installation guide)
15:55:05 <slack1256> nah, I just launched a nix-shell with tidal and dirt
15:55:14 <slack1256> I will launch a emacs instance inside
15:56:00 <Sindriav_> slack1256: Tidal provides additional el code especially for live coding with Tidal, IIRC
15:56:18 <Sindriav_> Welkin: Tidal is a haskell library for live music coding
15:57:24 <slack1256> oh so it is on tidal.el. nice
15:58:15 <Sindriav_> slack1256: Hence the importance of asking about your problem (Tidal) and not about your attempted solution (sending regions to ghci)
15:58:41 <slack1256> I still want to do the latter
15:59:03 <Sindriav_> You really don't. It might seem like a good idea, but it doesn't make sense 90% of the time.
15:59:04 <slack1256> but I guess I will check out how does tidal.el does it and translate it to general haskell code
15:59:15 <Sindriav_> If you *really* want to do it, it's rather easy to write a custom function for it.
15:59:16 <slack1256> I believe I do
15:59:59 <Sindriav_> You do realize that a *lot* of haskell code is invalid in GHCi, right?
16:00:04 <Sindriav_> "id x = x" doesn't work
16:00:22 <Sindriav_> For example.
16:00:24 <slack1256> I put holes here and there on modules, so I sometimes I want to check the terms of the functions I've already written
16:00:36 <slack1256> yes I know
16:00:51 <slack1256> still think is doable and useful
16:01:30 <Sindriav_> Well, whatever floats your boat.
16:01:36 <slack1256> :-)
16:01:55 <Sindriav_> Anyways, if only Vim and Emacs could have a love child, with configurability of Emacs and UI of Vim
16:02:03 <slack1256> spacemacs?
16:02:07 <slack1256> that is what I am using
16:02:54 * hackagebot hops 0.0.2 - Hackable Operations on Power Series  https://hackage.haskell.org/package/hops-0.0.2 (AndersClaesson)
16:03:13 <Sindriav_> Anything that's "X and Vim" isn't ever either X, nor Vim.
16:03:30 <Sindriav_> I've put my hopes on Neovim, anyways.
16:03:45 <slack1256> yeah, but vim as a modal editor isn't as good as it could be
16:04:39 <Sindriav_> >>= #haskell-blah
16:10:55 <jmcarthur> Sindriav_: i started trying spacemacs last night, and it kind of rocks
16:11:44 <Sindriav_> jmcarthur: Well, I'll look into it. But I've got very specific ideas about what an editor should do, so I'm not sure I'll like it.
16:12:42 <dmwit> slack1256: -fdefer-type-errors
16:12:42 <jmcarthur> spacemacs is pretty opinionated, so it might be a matter of just love it or hate it, but it's still emacs, so you can still configure it however much you are willing to work for
16:12:57 <levi> JagaJaga: I worked out roughly how your crazy function works.
16:13:15 <dmwit> slack1256: ...will let you check the types of functions in partially-completed/partially-correct modules.
16:13:16 <Sindriav_> jmcarthur: I'm learning Clojure at the moment, so I'm using pretty much pure emacs (since the book I'm reading uses it), so maybe if I like emacs enough, I'll look into Spacemacs
16:13:37 <Sindriav_> jmcarthur: If nothing else, I like the modeline, so I'd like to rip that off into my personal config :)
16:13:54 <slack1256> dmwit: I *knew* there was a ghc option that could help. Yes -defer-type-errors will let me load the whole module
16:14:15 <levi> JagaJaga: Where'd you get it from?
16:16:31 <levi> Is there a way to get ghci to annotate type class methods with the instances they're using in an expression?
16:17:06 <dmwit> levi: -ddump-core produces completely explicit code
16:17:18 <dmwit> sometimes too explicit to read comfortably
16:26:54 <sm> Jinxit: I just had to refactor: [(x,y) | x<-[-1..1], y<-[-1..1], (x,y) /= (0,0)]
16:27:21 <sm> (shh, don't tell m o n o c h r o m)
16:30:24 <boyscared> Welkin: dynamic typing
16:30:55 <Welkin> boyscared: isn't everyone?
16:32:42 <cow_2001> i'm reading the typeclassopedia and there's an exercise about writing a (Functor f) and a (Monad f) for a free monad
16:32:46 <cow_2001> what is a free monad?
16:34:07 <levi> That's a good question, and a bit difficult to answer precisely without some category theory stuff.
16:35:23 <glguy> cow_2001: This might help: https://wiki.haskell.org/Free_structure
16:35:36 <slack1256> cow_2001: well apart of what levi said, you could take the usual data type that represents a free monad and try to do the required instances
16:35:51 <slack1256> (better yet, use type holes and derive the instances interactively)
16:36:11 <levi> A 'free' structure, generally, is the form of that structure that is in some sense the most basic form, i.e. it has no extra structure/follows no extra laws other than those required by the structure it's a 'free' instance of.
16:37:26 <Jinxit> sm: neat
16:37:29 <dmwit> sm: http://stackoverflow.com/q/21321372/791604
16:38:20 <cow_2001> i don't know how to pattern match it
16:38:48 <indiagreen> is there a good reason why there's no instance MonadWriter (ParsecT ... (Writer w))?
16:38:57 <levi> If you think of a monad in terms of how its 'join' works, you'll see that a lot of them do some kind of summarization or something specific to what kind of monad they are. But the free monad keeps track of everything that gets collapsed when the m (m a) turns into a m a.
16:40:13 <dmwit> indiagreen: Perhaps ParsecT's backtracking doesn't play well with the naive instance.
16:40:42 <TheCrafter> I have this --> data Foo a = Foo { foo :: FooData -> (FooData, a) }
16:40:42 <TheCrafter> and I want to write a function like this -> goo :: Foo a -> a
16:40:42 <TheCrafter> How can I do it?
16:41:13 <dmwit> indiagreen: I believe a similar argument explains why the MonadState instance does not delegate to an underlying State(T).
16:42:40 <glguy> TheCrafter: Which part is confusing you?
16:42:41 <dmwit> TheCrafter: Unwrap your Foo a to get a FooData -> (FooData, a), then pass in an initial value of type FooData.
16:43:40 <Welkin> cow_2001: lol, I just recently found Gabriel's free monad essay again and have been meaning to read it
16:44:00 <levi> cow_2001: If you think in terms of Monoids, there are a lot of Monoids that lose information about the structure that they were constructed in; the Sum monoid, for instance, forgets about which specific numbers were mappended into it. But the list, which is a form of the free Monoid, keeps track of the individual elements that were mappended into it.
16:44:07 <TheCrafter> glguy, everything. I've been trying to understand monads for the past 10 hours. I'm confused with everything!
16:44:15 <TheCrafter> dmwit, let me try it
16:44:27 <cow_2001> I have: fmap f (Node _) = Node _ which i do not know how to.. anything with it
16:44:42 <dmwit> TheCrafter: Do show us what you end up with, even if it doesn't work quite right!
16:45:00 <cow_2001> levi: hmm
16:45:26 <TheCrafter> dmwit, okay then maybe I should show you my original code, without foo and goo. I think I am headed in the wrong direction!
16:45:40 <dmwit> ?where paste
16:45:40 <lambdabot> Haskell pastebin: http://lpaste.net/
16:45:48 <Welkin> TheCrafter: it takes time to understand, but you will get used to it :)
16:46:00 <Welkin> TheCrafter: soon you will develop an intuition for how they work
16:46:09 <Welkin> by just using them
16:46:16 <sm> dmwit: very nice! I was wondering about some of those variants
16:46:18 <TheCrafter> Welkin, yeah I just need to keep trying!
16:46:26 <dmj`> TheCrafter: how do you feel about typeclasses
16:47:38 <glguy> Writing the "goo" function isn't so much about typeclasses or Monad instances
16:47:50 <glguy> It's just about learning Haskell
16:48:03 <cow_2001> Welkin: gabriel's whatnow?
16:48:35 <levi> cow_2001: Probably this: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
16:50:06 <TheCrafter> ok sorry for the delay. I want to say that, over the last hours I believe I've understood the monads as a general concept. I just have no clue how to use them.
16:50:12 <TheCrafter> here: http://lpaste.net/5053654594320596992
16:50:22 <Welkin> TheCrafter: to chain together operations
16:50:45 <nitrix> Hi, how do I build something equivalent to a top-level mutable list?
16:50:57 <Welkin> nitrix: top-level?
16:50:59 <jle`> the best part about haskell is that rush of adrenaline when something compiles
16:51:00 <TheCrafter> Welkin, yeah I figured as much. My problem is how? Do you have a small example or something?
16:51:08 <TheCrafter> jle`, haha
16:51:14 <nitrix> Various functions needs to performs checks on it, mutate it and also, import and export that runtime list to a file.
16:51:39 <Welkin> nitrix: there are no mutable lists that I know of
16:51:44 <glguy> nitrix: Generally you don't have a top-level mutable list
16:51:46 <Welkin> nitrix: you can use a MVector inside ST
16:51:55 <johnw> TheCrafter: 'a' is your >>= definition is a function, so it'll need a state to return a value and a new state.  Then, that value can be passed to f, which returns a Bot, that is also a wrapper to a function, and needs the next state
16:52:03 <nitrix> Let's give you a context. IRC bot, list of trusted users along ACL levels.
16:52:12 <johnw> So the definition begins: Bot a >>= f = Bot $ \s -> let (s', x) = a s in .....
16:52:28 <jmcarthur> nitrix: you mean you want a global?
16:52:30 <jle`> nitrix: if you're in an IRC bot then your modules probably should be able to access an IORef or something somewhere
16:52:38 <jle`> or MVar
16:52:42 <jmcarthur> nitrix: resist!
16:52:48 <glguy> nitrix: For that case you'd have some BotState record that you'd pass around (or possibly tuck away inside a State-like monad API)
16:52:56 * hackagebot fwgl 0.1.4.0 - Game engine  https://hackage.haskell.org/package/fwgl-0.1.4.0 (ZioCrocifisso)
16:53:00 <nitrix> jle`: Yeah, almost everything is within IO.
16:53:13 <jle`> yeah, so just pass them the IORef when you initialize them?
16:53:17 <nitrix> I cannnot really pass anything around due the the library I'm using.
16:53:27 <nitrix> It has an event system and the types aren't very flexible.
16:53:51 <TheCrafter> johnw, ok let me try to understand that. I'll be back in a few minutes.
16:53:51 <jle`> what's the library?
16:53:54 <jmcarthur> nitrix: (if you actually need global mutatable state for a really good reason, you can use unsafePerformIO to create a mutable array. you have to make sure to NOINLINE it though, because ghc is really used to being able to optimize code as though it's pure. but really... don't do this please)
16:54:12 <johnw> TheCrafter: k; it's the exact same as the State monad, so cracking this nut will go a long way toward future Monad comprehension
16:54:14 <dmwit> TheCrafter: Generally, your implementation idea ("implement `m a -> a` and use it to implement `m a -> (a -> m b) -> m b`") is a bad one: the point of the `Monad` interface is that it allows binding operations without necessarily offering a sensible `m a -> a` operation.
16:54:17 <nitrix> jmcarthur: Then what is the proper solution?
16:54:18 <jmcarthur> nitrix: even when using libraries with annoying interfaces, you can often get away without doing this
16:54:51 <nitrix> I'm using https://hackage.haskell.org/package/simpleirc-0.3.1, if it helps.
16:54:52 <jmcarthur> nitrix: does you event system allow you to at least register callbacks or something?
16:54:57 <levi> nitrix: It depends somewhat on how the library you're using is constructed.
16:55:00 <jmcarthur> i'll look
16:55:03 <dmwit> TheCrafter: So I encourage you to have a crack at implementing `>>=` directly. You may find it easier to write than your "extract a value from the monad" operation.
16:55:50 <TheCrafter> dmwit, that is what I was trying to do at first. But then I found myself lost in a sea of "let"s and lambdas.
16:56:16 <dmwit> It can be difficult your first couple of hundred times. =)
16:56:17 <jmcarthur> nitrix: ah, annoying, you can't even change the set of callbacks once registered. still workable though!
16:56:38 <jmcarthur> nitrix: you can create the mutable state in IO and then construct all the callbacks you want to register with that in scope
16:56:39 <nitrix> jmcarthur: I'm used to the typical mutable state so this is new for me.
16:56:40 <serendependy> If a monad has an `m a -> a` operation, doesn't that also make it a comonad?
16:56:57 <dmwit> TheCrafter: If you get stuck in the direct implementation, show us what you've tried in that direction and we can give some hints, for sure.
16:57:09 <TheCrafter> serendependy, wow. what is a comonad? I wanna cry..
16:57:14 <serendependy> And if m :: * -> * is both a monad and a comonad, can it be anything other than the Identity functor (if it obeys both laws)?
16:57:21 <TheCrafter> seems that i have some research to do
16:57:32 <serendependy> TheCrafter, Nothing you need to worry about *yet* I'm sure ;)
16:57:40 <dmwit> serendependy: I think `m a -> a` alone is not enough to guarantee comonad. There are almost certainly some laws needed.
16:57:44 <jmcarthur> nitrix: for example, here is a bit of code that constructs a function that has access to an IORef:     do { ref <- newIORef 0; return (\new -> do { old <- readIORef ref; writeIORef ref new; return old }) }
16:57:50 <TheCrafter> oh ok :P
16:57:55 <dmwit> serendependy: e.g. there's a perfectly good operation of type `State Int a -> a` that doesn't obey many laws.
16:57:56 * hackagebot fwgl-glfw 0.1.1.1 - FWGL GLFW backend  https://hackage.haskell.org/package/fwgl-glfw-0.1.1.1 (ZioCrocifisso)
16:57:58 * hackagebot fwgl-javascript 0.1.1.1 - FWGL GHCJS backend  https://hackage.haskell.org/package/fwgl-javascript-0.1.1.1 (ZioCrocifisso)
16:58:01 <johnw> I have a feeling that all TheCrafter really wants was a way to unwrap is type wrapper, not anything fancy
16:58:10 <dmwit> serendependy: (namely `runState 0`)
16:58:18 <kazagistar> TheCrafter: "co" prefix means you turn around the arrows in functions and laws
16:58:28 <cow_2001> i am terribly confused
16:58:33 <glguy> The co- means you can ignore it for a couple of years
16:58:35 <dmwit> johnw: What TheCrafter professes to want is a Monad instance, in the service of understanding how to use monads.
16:58:40 <serendependy> TheCrafter, They're things from which you can extract, whereas a monad you rather 'plumb through'
16:58:43 * serendependy handwaves
16:58:48 <TheCrafter> johnw, to be honest, even I don't know exactly what I want to do. The ultimate goal is to try to understand how to use monads
16:59:04 <johnw> TheCrafter: working through how to implement your >>=, and why it works that way, is a good road to trod along then
16:59:05 <serendependy> dmwit, Ah good point
16:59:10 <montanonic> Hey #haskell! I have a question about documentation. GHC base libraries have this very sexy interlinked doc system where you can click on any defined function/type/etc... and be taken to its implementation. As seen here: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#
16:59:24 <levi> TheCrafter: The difficult thing about 'how to use monads' is that they all do different things.
16:59:40 <Welkin> montanonic: I think you can enable that feature when you generate the haddocks for your package
16:59:43 <montanonic> Might anyone know how that's done, and if there's a library that would do that? 
16:59:52 <jmcarthur> montanonic: all new hackage packages have docs built this way. it can be done with haddock.
16:59:56 <johnw> dmwit: true
17:00:03 <kazagistar> TheCrafter: learn to use a few types via the monadic interfaces, like list and io and maybe and parsers and continuations and whatnot
17:00:04 <jmcarthur> montanonic: i forget the exact invocation necessary
17:00:29 <montanonic> Welkinm, jmcarthur : excellent! thanks a ton; I'll look into it
17:00:29 <serendependy> glguy, lol!
17:00:30 <Welkin> TheCrafter: Parsers are a very good one
17:00:36 <Welkin> although applicatives work better for that
17:00:40 <jmcarthur> nitrix: does my example make sense?
17:00:44 <Welkin> TheCrafter: I recommend you go through the upenn haskell course
17:00:47 <levi> TheCrafter: Monads in haskell are a diverse family of types that happen to implement a certain interface (return, >>=, etc.) that lets you combine them easily.
17:00:49 <Welkin> @where learnhaskell
17:00:49 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:00:51 <TheCrafter> kazagistar, my problem is how to make my own monads and use them. Not using the ones that already exist.
17:00:54 <Welkin> TheCrafter ^
17:01:01 <Welkin> it explains much of this
17:01:08 <Welkin> and gives you exercises to help learn
17:01:12 <dmwit> ?wiki Monad_tutorials
17:01:12 <lambdabot> http://www.haskell.org/haskellwiki/Monad_tutorials
17:01:26 <TheCrafter> okay thanks!
17:02:20 <nitrix> jmcarthur: reading
17:02:39 <cow_2001> how do i pattern match the (Node (f (Free f a))) part of (Free f a)?
17:02:54 <jmcarthur> nitrix: note that you could construct multiple functions that close over the same IORef
17:03:00 <dmwit> hrm
17:03:03 <levi> TheCrafter: Mostly people don't implement wholly new monads, they largely combine existing ones via 'monad transformers' and then wrap the 'monad transformer stack' with some domain-specific functions.
17:03:12 <johnw> TheCrafter: to get a feel for the Monad typeclass, it helps to implement on your own the instances for Identity, Reader, Writer, and State.  A pattern should emerge.
17:03:17 <dmwit> There used to be a wiki page linking to lots of tutorials, with commentary about which tutorials would be good for which audiences.
17:03:20 <dmwit> But I can't find it now.
17:03:32 <dmwit> Closest seems to be https://wiki.haskell.org/Monad_tutorials_timeline
17:03:36 <Welkin> also, Maybe, List, Either :)
17:03:56 <dmj`> All about monads was good, https://wiki.haskell.org/All_About_Monads
17:04:16 <Welkin> TheCrafter: the NICTA course offer exercises for implementing your own functor, applicative, and mond instances, and more
17:04:41 <cow_2001> where is the taco one?
17:04:57 <Welkin> cow_2001: lol
17:04:58 <dmwit> https://wiki.haskell.org/Learning_Haskell#Monads Lists all the ones I consider excellent and few others.
17:05:00 <Welkin> the burrito one?
17:05:10 <TheCrafter> Welkin, this one? https://github.com/NICTA/course
17:05:13 <cow_2001> burrito
17:05:16 <Welkin> TheCrafter: yes
17:05:22 <cow_2001> it's not in the timeline
17:05:34 <TheCrafter> okay. Thanks guys. I'll go back to studying I guess and then try again!
17:06:07 <cow_2001> i'm crazy frustrated with this exercise :|
17:06:19 <TheCrafter> oh one quick question. To make an instance of Monad do I need to make instance for Applicative as well?
17:06:31 <Welkin> TheCrafter: not below ghc 7.10
17:06:35 <cow_2001> Welkin: did you go through the typeclassopedia thing?
17:06:40 <jmcarthur> TheCrafter: it depends on how new your ghc is
17:06:41 <levi> TheCrafter: For recent GHC, you do.
17:06:46 <Welkin> but, yes, all monads should be applicatives as well
17:06:56 <TheCrafter> oh. yeah my ghc is brand new :D
17:06:57 <nitrix> jmcarthur: Don't mind the string uglyness, I just wanted it to typecheck.   http://lpaste.net/140421
17:07:02 <Welkin> cow_2001: yes, I read through most of it and did most of the exercises
17:07:08 <Welkin> I never did the free monad one :P
17:07:09 <TheCrafter> 7.10.2
17:07:13 <Welkin> I have yet to read about free monads
17:07:16 <cow_2001> Welkin: could you help me... ding. :|
17:07:16 <nitrix> jmcarthur: See, the problem is now that I create this IORef, it cannot be in scope of `freenode` nor `events` :/
17:07:44 <cow_2001> Welkin: i just have no clue how to pattern match that thing in the second fmap definition! it's driving me nuts! D:<
17:07:58 <dibblego> The NICTA course is in Sydney next week, let me know if you want to go. It's free.
17:08:12 <cow_2001> Welkin: i need a squeeze ball or something. maybe a wall to punch.
17:08:20 <MarcelineVQ> walls resist punches
17:08:29 <cow_2001> MarcelineVQ: that is true.
17:08:41 <TheCrafter> Thanks dibblego but I live in Greece so.. I think I'll just stick to the github version.
17:08:54 <dibblego> TheCrafter: ok, there is also #nicta-course for people doing it on their own.
17:08:59 <Jinxit> I'm running ((take 10) . levels) on a recursive infinite tree, how do I make it use all cores?
17:09:01 <TheCrafter> anyway guys, I'm off to study I guess! Thank you everyone for your help.
17:09:02 <Welkin> dibblego: you only seem to show up when someone mentions nicta
17:09:03 <jmcarthur> nitrix: that's right. you will have to construct a closure dynamically. if you want to have these as top level definitions like you do right now, you will want to make them accept the IORef (or whatever mutable it is) as an argument, and then you will apply them to an IORef that you construct dynamically as you create the config
17:09:05 <TheCrafter> ok dibblego thanks
17:09:15 <dibblego> Welkin: I work for (formerly) NICTA.
17:09:35 <cow_2001> data Free f a = Var a | Node (f (Free f a)); fmap f (Var a) = Var $ f a; fmap f (Node ?!) = Node ?!
17:09:36 <Axman6> (currently) NICTA + other names
17:09:46 <dibblego> yeah that
17:09:59 <serendependy> Purely out of curiosity, can I write filter with do notation? If so, how?
17:10:08 <cow_2001> where "?!" is my brain converting into marshmallows
17:10:24 <c_wraith> looks like a lens thing
17:10:28 <c_wraith> :t (?!)
17:10:30 <lambdabot>     Not in scope: ‚Äò?!‚Äô
17:10:30 <lambdabot>     Perhaps you meant one of these:
17:10:30 <lambdabot>       ‚Äò$!‚Äô (imported from Prelude), ‚Äò!!‚Äô (imported from Data.List),
17:10:33 <c_wraith> nope!
17:10:34 <cow_2001> noooo no lenses!
17:10:49 <cow_2001> help me not go bonkers
17:10:54 <jmcarthur> nitrix: is what i'm saying making sense?
17:11:04 <c_wraith> I dunno.  Check what packages you have exposed and modules imported from
17:11:22 <levi> nitrix: If you define the handler functions *within* the function that makes the IORef and fills out the IrcConfig, then they'll be in scope within the handlers.
17:12:10 <nitrix> jmcarthur: levi: Let me see if I got this right.
17:12:35 <levi> nitrix: You can also make handler-constructing functions that take the IORef as a parameter and return a handler function with the IORef in scope.
17:12:39 <lolisa> serendependy, I'd think you could do it by returning the list with single element if it satisfy, and return empty list otherwise
17:13:23 <Welkin> cow_2001: Gabriel explains the answers in his essay http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
17:13:32 <Welkin> which I only skimmed just now, but need to read
17:13:36 <Welkin> perhaps I'll read it now
17:13:40 <serendependy> lolisa, Yes was thinking about that, just have to make sure [[a]] -> [a] happens
17:13:52 <indiagreen> serendependy: ‚Äúdo x <- list; guard (even x); return x‚Äù
17:14:16 <johnw> Welkin: free monads are pretty fun
17:14:23 <johnw> Welkin: I find myself using them more and more
17:14:38 <serendependy> indiagreen, Just spotted guard, trying to figure out how it works but that looks perfect
17:14:47 * lolisa procastinate, probably will "read it now" someday
17:14:53 <lpaste_> cow_2001 pasted ‚Äúfree functor‚Äù at http://lpaste.net/1532377772104613888
17:15:13 <cow_2001> this is what i've got right now :|
17:15:19 <cow_2001> more or less
17:15:22 <johnw> cow_2001: recurse your fmap, and make Functor f a consraint on your instance
17:15:38 <indiagreen> serendependy: it works like ‚Äúdo x <- list; _ <- if even x then [()] else []; ...‚Äù
17:15:40 <johnw> fmap f (Node x) = Node (fmap f x)
17:15:47 <cow_2001> err
17:15:54 <nitrix> jmcarthur: levi: Like that?  http://lpaste.net/140421
17:16:15 <indiagreen> serendependy: and after that you just need to look at the definition of >>= for []
17:16:44 <dmwit> serendependy: Without guard, filter f xs = [x | x <- xs, f x] = xs >>= \x -> [x | f x] = xs >>= \x -> if f x then [] else [x]
17:16:45 <cow_2001> johnw: recurse my fmap?
17:16:54 <serendependy> @type (>>=) []
17:16:56 <lambdabot> (a -> [b]) -> [b]
17:17:06 <johnw> your implementation of fmap for Free must use the fmap for f, which will call the fmap for Free
17:17:21 <Jinxit> can I use Data.Tree levels with multiple cores?
17:17:34 <nitrix> jmcarthur: levi: For some reason, that looks unmaintainable. I assume more complex applications group all their IORefs into some aggregate type?
17:17:51 <Axman6> Jinxit: what do you mean?
17:18:04 <Axman6> the answer is yes, but the question is unclear =)
17:18:40 <Jinxit> I'm calling ((take 10) . levels) on a recursive tree
17:18:40 <jmcarthur> nitrix: it's much more maintainable than global mutable state :)
17:18:50 <Jinxit> and it's only using 1 core
17:19:01 <cow_2001> johnw: how do i use the fmap for f?
17:19:09 <jmcarthur> nitrix: most applications don't require *that* much mutation
17:19:11 <johnw> cow_2001: fmap f (Node x) = Node (fmap f x)
17:19:13 <Axman6> Jinxit: how could that use more than one core efficiently?
17:19:29 <jmcarthur> nitrix: part of the problem here is that the library has a constraining interface.
17:19:38 <Jinxit> a worker pool could handle branches in parallel
17:19:53 <nitrix> jmcarthur: I don't either. Probably a list of users, their permissions, word ban list, few things like that. You think I could just group them until a type for what's "global" and it wouldn't be too bad?
17:19:55 <cow_2001> oh wow
17:19:58 <Jinxit> since they only depend on their immediate parent
17:20:04 <dmwit> Jinxit: You might like Simon Marlow's excellent book, Parallel and Concurrent Programming in Haskell.
17:20:14 <nitrix> under*
17:20:14 <jmcarthur> nitrix: in this case, you could just have a single IORef that contains the entire state
17:20:19 <cow_2001> no, still doesn't compile
17:20:33 <johnw> cow_2001: you need to add the Functor f constraint to your instance
17:20:35 <nitrix> jmcarthur: Oh, the state being a record?
17:20:37 <jmcarthur> yeah
17:20:42 <nitrix> jmcarthur: Gotcha.
17:20:46 <johnw> instance Functor f => Free f where ...
17:21:31 <johnw> cow_2001: note that there is another formulation of Free, entirely equivalent, that does not require that constraint...
17:21:41 <MarcelineVQ> Jinxit: http://chimera.labs.oreilly.com/books/1230000000929/index.html it's not a straightforward answer for your question but it's far more useful
17:22:13 <Jinxit> I'll take a look
17:22:32 <MarcelineVQ> The straightforward answer for your question is, it depends :>
17:22:46 <johnw> cow_2001: oh, it may need to be Node (fmap (fmap f) x)
17:23:27 <nitrix> jmcarthur: Okay. Because, otherwise, if the API wasn't so restricting (e.g. written entirely by me), I could've taken stateful operations into account with some monads or whatever?
17:23:58 <nitrix> State monad, I think?
17:24:21 <jmcarthur> nitrix: the State monad is overrated. it's not so bad to just pass things around. that said, yes, you could "just" use the state monad here.
17:24:35 <jmcarthur> nitrix: in fact, you still could make a sort of monad to give you roughly the same interface
17:25:04 <jmcarthur> nitrix: something like:    ReaderT (IORef AppState) IO
17:25:13 * nitrix shivers.
17:25:18 <cow_2001> i don't know what just happened in here :|
17:25:42 <jmcarthur> nitrix: it's that bad?
17:26:21 <cow_2001> i'd have to think hard about this free thing.
17:27:03 <nitrix> jmcarthur: I just don't know enough of this to risk dipping my toes. But it'll come, I'm sure.
17:27:04 <jmcarthur> nitrix: what seems unmaintainable about it?
17:28:40 <platz>  /q lambdabot
17:28:58 <Welkin> nitrix: using ReaderT, you can simply use `asks readIORef` anywhere inside your function to grab the AppState
17:29:29 <johnw> cow_2001: please ask questions if you have any in mind
17:32:01 <jle`> nitrix: ReaderT r IO is just like IO, except you have an extra action, "ask" :)
17:32:03 <jle`> that gives you an r
17:32:19 <jle`> so you have putStrLn, getLine, etc., all your normal IO actions
17:32:30 <jle`> but you have another action too, `ask`, that gives you a global `r` wherever you are
17:33:27 <nitrix> I'll look into it.
17:33:55 <Welkin> nitrix: monad transformers are a way of using multiple monads at the same time
17:34:00 <Welkin> in this case, Reader + IO
17:35:36 <dmj`> ReaderT IO all the things
17:36:26 <hackrilege> hio
17:36:31 <hackrilege> (<*>)¬†is special compared to¬†(>>=)¬†as it's allowed to "open up" the future and the past in parallel instead of necessarily needing results from "the past" in order to compute "the future".
17:36:32 <Welkin> the joy of ReaderT
17:36:58 <dmj`> we should write an ebook, just on ReaderT
17:37:09 <levi> The joy of ((->) r) :P
17:37:12 <Welkin> hackrilege: <*> cannot branch based on the result of any computation, it relentlessly marches forward
17:37:32 <Welkin> levi: oh god, I see ((->) r) show up everywhere
17:37:40 <hackrilege> "branc"?
17:37:43 <Welkin> branch*
17:38:02 <hackrilege> "branch"?
17:38:20 <Welkin> hackrilege: if a then b else c
17:38:50 <hackrilege> What is happening when we do this?
17:39:16 <Welkin> because >>= takes a function as the second parameter
17:39:19 <levi> Welkin: It's one of the few Monad instances that's always around.
17:39:29 <jle`> hackrilege: (<*>) is nice because the second "action" can't depend on the result of the first
17:39:42 <rhaps0dy> hackrilege, awesome nick
17:39:50 <hackrilege> Thanks!
17:40:07 <levi> There's Either e, Maybe, IO, [], and ((->) r)
17:40:11 <jle`> hackrilege: we're talking about action in an abstract sense, meaning an "m a"...but this is easier to understand if you specialize to concerete instances
17:40:16 <hackrilege> :t lift2a
17:40:17 <lambdabot>     Not in scope: ‚Äòlift2a‚Äô
17:40:17 <lambdabot>     Perhaps you meant one of these:
17:40:17 <lambdabot>       ‚ÄòliftM‚Äô (imported from Control.Monad.Writer),
17:40:30 <hackrilege> :t lift2A
17:40:32 <lambdabot>     Not in scope: ‚Äòlift2A‚Äô
17:40:32 <lambdabot>     Perhaps you meant one of these:
17:40:32 <lambdabot>       ‚ÄòliftA‚Äô (imported from Control.Applicative),
17:40:42 <hackrilege> sorry
17:40:47 <Welkin> :t liftA2 -- hackrilege 
17:40:48 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:40:52 <jle`> hackrilege: you can always test things out in lambdabot pm, too :)
17:41:52 <hackrilege> i should
17:42:49 <hackrilege> this depends on
17:43:23 <hackrilege> both results.. Sorry I'm on a phone it's bad
17:43:31 <levi> Welkin: Lots of crazy pointfree things abuse ((->) r), like 'join (+)' from JagaJaga's earlier mess of a function.
17:43:56 * indiagreen facepalms
17:44:09 <indiagreen> problem: the program I'm writing is becoming a horrible unreadable mess
17:44:26 <indiagreen> solution: I somehow completely forgot that modules *exist*
17:44:32 <hackrilege> Abstract the design patterns
17:45:05 <Welkin> levi: lol, I have gotten into trouble with that before too
17:45:06 <kadoban> indiagreen: Lol
17:45:18 <Welkin> accidentally using the ((->) r) monad when I didn't mean to
17:45:20 <jmcarthur> indiagreen: a common problem. haskell modules are kind of awkward because you have to use separate files just to use modules, so it tends to be underused in haskell programs. :(
17:46:17 <kadoban> That's true in like, every language I can think of.
17:46:44 <kadoban> Never really seemed awkward to me, in general. Maybe once in a great while.
17:46:56 <indiagreen> okay, um, also another Parsec question: does anyone know of a nice way to add warnings to parsers? not ‚Äúfail‚Äù, just warnings generated as parsing goes
17:47:26 <hackrilege> Is liftA2 behaving more life a monad because we can observe both f a and f b when we apply our function?
17:48:00 <Welkin> indiagreen: I thought parsec already did that
17:48:01 <kadoban> hackrilege: More like a Monad than what? It's only Applicative ‚Ä¶ so not really?
17:48:12 <indiagreen> Welkin: hm?
17:48:48 <jle`> hackrilege: the second action in the first and second actions can't depend on eachothers' results
17:48:56 <jmcarthur> kadoban: ML gets it right
17:48:58 <jle`> hackrilege: liftA2 (+) f g, f and g can't depend on eachothers' results
17:49:05 <levi> Welkin: Also, fmap for ((->) r) is . so you can throw in <$>s and fmaps to compose your r -> a functions for added confusion!
17:49:07 <kadoban> hackrilege: The key that makes Monad different than Applicative is :: m a -> (a -> m b) -> m b  , which doesn't have a lot (anything?) to do with liftA2
17:49:14 <jmcarthur> kadoban: OCaml at least. I'm not as familiar with SML's module system as with OCaml's.
17:49:26 <kadoban> Ah, yeah I haven't really used those languages much at all.
17:49:27 <hackrilege> I'm confused about what is being said about computations either side of bind in that they are supposedly unable to be know at the same time?
17:49:33 <Welkin> indiagreen: runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a 
17:49:38 <levi> jmcarthur: They're pretty similar these days, I believe.
17:49:47 <jmcarthur> levi: no, they are drifting further apart
17:49:57 <Welkin> indiagreen: it produces an Either
17:50:01 <jle`> hackrilege: you can't know "what computation to do" on the the rhs of bind until you know the result of the lhs
17:50:14 <jmcarthur> levi: OCaml has been evolving while SML is happily sitting on its nice formal spec.
17:50:21 <jle`> hackrilege: for the case of liftA2 (+) x y, both x and y are already-known computations
17:50:34 <jle`> hackrilege: x and y don't depend on eachother, and you don't need to know the result of x to know what y should be
17:50:36 <levi> jmcarthur: Well, OCaml is changing, but part of that change was to add the sort of functors that SML had and OCaml didn't.
17:50:58 <hackrilege> Known computations, apparently unlike conditional statements
17:51:01 <jmcarthur> levi: OCaml has both kinds now!
17:51:04 <jle`> hackrilege: for example, liftA2 (+) (Just 3) (Just 2).  Note that the `Just 2` can't really depend on the result of Just 3
17:51:11 <jmcarthur> levi: SML only has one
17:51:18 <kadoban> hackrilege: Since you can decide what 'm' you want, based on the 'a', that's more powerful than Applicative. You can do ‚Ä¶ if x == 5 then Nothing else Just 2 , where in Applicative you have to decide if you want Nothing or Just /without/ looking at 'x' there.
17:51:18 <jle`> you can't have the second thing be like, "okay, so if the result was even, then i'm Nothing, or if it's odd, then i'm Just 10"
17:51:40 <levi> jmcarthur: Well, I guess I ought to have said that OCaml's can express what SML's can these days.
17:51:46 <hackrilege> Jle' that was great thanks
17:51:50 <jmcarthur> levi: OCaml also has GADTs. It's probably getting module implicits (kind of like type classes) and along with it a nicer way to use higher kinded polymorphism. Etc.
17:52:03 <indiagreen> Welkin: yeah, Either <error> <result>
17:52:04 <jle`> hackrilege: and also, `liftA2 (++) getLine anotherIOAction`.  the anotherIOAction can't be decided based on the string returned
17:52:09 <jmcarthur> *modular implicits
17:52:18 <levi> (I have been following OCaml's development lately)
17:52:20 <jle`> hackrilege: it has to be an action that you know.  a solid `IO a`
17:52:23 <indiagreen> Welkin: and I need warnings that could accompany the result
17:52:25 <jmcarthur> levi: OCaml has first class modules and local module definitions.
17:52:30 <jle`> it can't be, like, a `b -> IO a`, or a `String -> IO a`
17:52:31 <jmcarthur> levi: tons of stuff SML lacks
17:52:34 <jle`> it has to actually *be* an IO a
17:52:44 <jle`> one that you supply
17:52:57 <jle`> and the `IO a` that you supply can't depend on the String that getLine gets
17:53:11 <levi> jmcarthur: You just spent about 20 lines telling me things I already know. My original statement was poorly phrased.
17:53:14 <hackrilege> But it could on a monad?
17:53:15 <jmcarthur> :)
17:53:16 <jmcarthur> okay
17:53:20 <jle`> hackrilege: yes
17:53:38 <jle`> hackrilege: for example, let's say you want to get a line from stdin with getLine, and then print it out again with putStrLn
17:54:10 <jle`> hackrilege: remember that `putStrLn` isn't an IO action.  `putStrLn "hello"` is an IO action
17:54:20 <jle`> putStrLn "hello world" is an IO action that prints out "hello world"
17:54:39 <hackrilege> Yeh
17:54:44 <jle`> so to get a line, and then print it out, you have to get a string and then *use that string* to make an IO action using putStrLn
17:54:53 <jle`> getLine >>= \x -> putStrLn x
17:55:09 <jle`> the actual IO action that "happens next" depends on the result of the previous action
17:55:18 <jle`> "happens next" might be a bad word
17:55:30 <jle`> but the "putStrLn x" action necessarily depends on the result of getLine
17:55:31 <hackrilege> It's fine
17:55:37 <hackrilege> It's a sequence
17:55:50 <hackrilege> Next is well defined
17:56:00 <jle`> yeah, a sequence...but the `IO a` that is sequenced next has to be constructed from the result of the previous sequence
17:56:19 <jle`> whereas, putStrLn "hello" *> putStrLn "world", that's just two IO ()'s one after the other, and they don't need the result of the other to be constructed.  because they're already IO ()'s
17:57:01 <hackrilege> But we know it should return a string and require a string, there is none of this branching going on...
17:57:10 <jle`> the action doesn't require a string
17:57:15 <jle`> the action is just an `IO ()`
17:57:40 <nitrix> Is there a convenient syntax for "mutating records" by copying an older one and specifying some fields of the new one?
17:57:41 <jle`> putStrLn isn't an action that requires a String.  it's a function that takes a String and returns an action
17:57:54 <hackrilege> It's a function which takes a string
17:58:06 <indiagreen> nitrix: x {field = value}
17:58:08 <Welkin> nitrix: yes :P
17:58:13 <Welkin> what indiagreen said
17:58:28 <jmcarthur> nitrix: existingRecord { fieldToUpdate1 = value1, fieldToUpdate2 = value2 }
17:58:35 <jle`> "branching" is a bit abstract of a word because we're trying to use vocabulary to describe the behavior of all monads
17:59:00 <nitrix> Clever! I'm liking this :D
17:59:03 <jle`> it's nice for sort of hand-wavy explanations when you already understand what's going on
17:59:17 <jle`> but when we're trying to figure how things really work, it doesn't really add anything, heh.  it's circular in that way
17:59:24 <jle`> it explains it perfectly to the people who already understand
17:59:33 <jmcarthur> nitrix: the general consensus is that haskell records aren't all that great, but they are convenient enough most of the time.
17:59:42 <Axman6> nitrix: if you need to do anything more complex than what jmcarthur has shown, lenses are the way to do it - you can use them to apply functions to values inwise a record to 'mutate' them
17:59:52 <jmcarthur> nitrix: there is some upcoming ghc extension to make them nicer though
18:00:36 <Welkin> I heard lens was being added to haskell to replace record syntax
18:00:37 <jmcarthur> nitrix: there's also stuff like lenses, as Axman6 pointed out... i feel funny when recommending them, though, as i think they are a really heavyweight way to do really lightweight things, both syntactically and conceptually.
18:00:41 <Welkin> what happened with that?
18:00:49 <jmcarthur> Welkin: it's not really quite that
18:01:11 <jmcarthur> Welkin: we're getting more of a row typing thing instead, and type disambiguating accessors
18:01:27 <jmcarthur> Welkin: and frankly i'm happier this way
18:01:27 <hackrilege> :: IO String -> (String -> IO ()) -> IO ()
18:01:31 <Axman6> jmcarthur: they feel very lightweight to me, both conceptually and syntactically
18:01:35 <seafood> Hey all, for those of you who use Emacs on Mac OS X, which particular app or version of Emacs do you use?
18:01:52 <Welkin> seafood: standard emacs version 24
18:01:52 <jmcarthur> Axman6: i like using lenses the way i use traverse
18:01:58 <Welkin> or whatever the newest one is
18:02:01 <Exio4> > (1,2,3) ^. _1 %~ (*2)
18:02:02 <Welkin> there is nothing special :P
18:02:03 <lambdabot>      Could not deduce (Num b0)
18:02:03 <lambdabot>      from the context (Num b, Num (Setting (->) s t b b))
18:02:03 <lambdabot>        bound by the inferred type for ‚Äòe_112312‚Äô:
18:02:03 <seafood> Welkin:Why do you prefer that version?
18:02:12 <Welkin> seafood: it's the latest
18:02:25 <levi> Lenses are wonderful, but they can lead to confusing type errors. :P
18:02:27 <Axman6> Exio4: s/^./$
18:02:27 <Exio4> ... nvm
18:02:27 <Welkin> 24 has proper theme support
18:02:30 <Axman6> uh, &
18:02:43 <Exio4> oh, right
18:03:10 <hackrilege> Applicative f => (a -> b -> c) -> f a -> f b -> f c
18:03:17 <Exio4> ^. is view, <.<
18:03:41 <jmcarthur> > (1,2,3) & _1 %~ (*2)
18:03:43 <lambdabot>  (2,2,3)
18:04:15 <jmcarthur> > _1 (pure . (*2)) (1,2,3)
18:04:16 <lambdabot>      No instance for (Show (f0 (b0, t0, t1)))
18:04:16 <lambdabot>        arising from a use of ‚Äòshow_M659138075024606539413505‚Äô
18:04:16 <lambdabot>      The type variables ‚Äòb0‚Äô, ‚Äòf0‚Äô, ‚Äòt0‚Äô, ‚Äòt1‚Äô are ambiguous
18:04:17 <glguy> Don't forget to use _2' to avoid hanging onto the old tuple 
18:04:25 <jmcarthur> ah woops
18:04:47 <jmcarthur> okay, using it as a traverse for this particular purpose is awkward of course.
18:04:52 <jmcarthur> > runIdentity (_1 (pure . (*2)) (1,2,3))
18:04:53 <lambdabot>  (2,2,3)
18:04:58 <hackrilege> so a monad seems to be able to "run an action", such as getting a string... Applicative Functors cannot do this? what is the monad up to?
18:05:10 <levi> > (1,2,3) & _2 .~ "Foo"
18:05:12 <lambdabot>  (1,"Foo",3)
18:05:26 <johnw> hackrilege: that's really not a good characterization
18:05:36 <hackrilege> :t getLine
18:05:37 <lambdabot> IO String
18:05:41 <hackrilege> ??
18:05:42 <johnw> that's IO
18:05:44 <johnw> that's not "monads"
18:05:51 <hackrilege> ahhh
18:05:53 <c_wraith> hackrilege: IO is an Applicative, too
18:06:05 <jmcarthur> @quote shortened
18:06:05 <lambdabot> jmcarthur says: my "monad tutorial" has shortened to "look at the type signatures and the laws" :\
18:06:24 <hackrilege> ...
18:06:34 <c_wraith> jmcarthur: the problem is convincing people there isn't a secret trick.
18:06:40 <jmcarthur> yeah :(
18:06:51 <Pamelloes> Are there any good libraries for reading svg or eps files and then rendering them as a png? A cursory google search doesn't really turn up anything too promising.
18:06:52 <Axman6> one way to think about it is that Monad is about ordering of effects, Applicative is about combination of effects 
18:06:55 <jmcarthur> it's mostly just undoing damage done by monad tutorials
18:07:07 <hackrilege> nice axeman
18:07:11 <glguy> > over _2' (*2) (1,2,3) -- wasn't joking about _2'
18:07:12 <lambdabot>  (1,4,3)
18:07:25 <Welkin> hackrilege: following the types and looking at the definition of the Monad typeclass (and accompanying laws) is really all you need to understand it
18:07:32 <Welkin> it is not magic
18:07:38 <Axman6> Monad can do everything Applicative can, so it's also about combination, but it also enforces order, for some notion of ordering which is instance dependant
18:07:46 <Welkin> and you don't need to study category theory to get it either
18:07:50 <hackrilege> i am attempting to understand those things
18:07:56 <Welkin> Monad is strictly more powerful than Applicative
18:07:58 * hackagebot linearscan-hoopl 0.11.1 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.11.1 (JohnWiegley)
18:09:15 <jmcarthur> Though this is more of an insight for people who already kind of understand than for beginners, the important operations from Functor, Applicative, and Monad are fmap :: (a -> b) -> (F a -> F b), both :: (F a, F b) -> F (a, b), and join :: F (F a) -> F a, respectively. I wish it was worthwhile to actually teach it this way, but I don't know how to make it stick at such a high level.
18:09:26 <Axman6> the Haxl library does a good job of showing how they';re different and why that's useful: using Applicative they can make each request to a remote service concurrently, and then combine them, but if they could only use monadic code, then each request would have to be sequentially (or explicitly concurrently using something like forkIO etc)
18:09:45 <johnw> jmcarthur: you really have to include "pure" too
18:09:54 <jmcarthur> johnw: not really. i don't think it's that important
18:10:00 <hackrilege> its simply an investigation of the difference between ((a->b->c)->f a->f b->f c) and (m a->(a -> m b)->m b)
18:10:06 <jmcarthur> johnw: it's there, and it's useful, but it's not fundamental to understand it
18:10:17 <johnw> the notion of some kind of "default" structure is kind of crucial to what monads do
18:10:17 <Exio4> you need unit :: f ()
18:10:22 <johnw> and applicatives
18:10:27 <hackrilege> :t (<*>)
18:10:28 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:10:31 <Pamelloes> What's both? I don't think I've ever used that.
18:10:31 <Exio4> (which gives you pure thru fmap)
18:11:16 <Pamelloes> Well I guess the type signature is pretty self explanatory, but why is both more important than <*>?
18:11:22 <jmcarthur> johnw: Yeah, you're right. I guess I'd have to include unit.
18:11:54 <jmcarthur> Pamelloes: not more important, but i think makes it a bit easier to see exactly what the power of Applicative is that isn't in Functor.
18:12:12 <indiagreen> for me it was ‚Äúa lot‚Äù and not ‚Äúa bit‚Äù
18:12:23 <jmcarthur> Pamelloes: it allows you to combine the Fs and put the a and b together where they are can manipulated with fmap
18:12:40 <jmcarthur> s/they are/they/
18:13:10 <Exio4> Pamelloes: it's closer to the definition of a "lax monoidal functor" than the current definition
18:13:24 <hackrilege> natural paralellism is achieved by using applicative over monad where possible?
18:13:46 <TheArtist> Hello!
18:13:47 <Exio4> Pamelloes: (as the definition of monad which includes join is also closer to the definition of a monad in CT)
18:13:50 <Axman6> depending on the implementation, yes
18:14:03 <Pamelloes> interesting.
18:14:12 <johnw> jmcarthur: the slightly weaker (a, f b) -> f (a, b) is "functorial strength"
18:14:16 <Pamelloes> Can <*> be written in terms of both and vice versa?
18:14:19 <hackrilege> jmcarthur as i understand it Applicative allows functors to interact
18:14:20 <jmcarthur> Pamelloes: I'll try to summarize. Functor gives you the ability to manipulate something modified by F. Applicative gives you the ability to merge two Fs and manipulate the modified somethings together. Monad gives you the ability to merge two Fs where one was modifed by the other.
18:14:39 <jmcarthur> johnw: Ah! That fits in.
18:14:49 <TheArtist> I wanted to make a simple Counter monad for my first attempt writting one, so i made this:
18:14:52 <TheArtist> http://lpaste.net/4999952827217346560
18:14:59 <TheArtist> Is it right?
18:15:01 <jmcarthur> johnw: It kind of looks like   Id*F -> F
18:15:04 <TheArtist> Any suggestions?
18:15:29 <hackrilege> hang on how is F modifying anything i thought it was just a container?
18:15:40 <jmcarthur> hackrilege: F is modifying a type, not a value
18:16:09 <jmcarthur> hackrilege: It's a type constructor. It takes a type as an argument, and the result is a type.
18:16:23 <hackrilege> ok
18:16:34 <hackrilege> it has kind * -> *
18:16:36 <johnw> TheArtist: looks right
18:16:44 <jmcarthur> hackrilege: I think my phrasing for Monad above was the worst
18:16:50 <hackrilege> it is the best
18:16:54 <hackrilege> so far
18:17:02 <jmcarthur> okay cool!
18:17:03 <TheArtist> Sure? Perfectt! I made my first monad :)
18:17:17 <jmcarthur> I'll count this as a datapoint that this approach to teaching it can be helpful.
18:17:17 <johnw> TheArtist: yeah, you made the State monad, in fact :)
18:17:27 <TheArtist> Any suggestions on how i should provide the initial State?
18:17:41 <TheArtist> through a constructor how i do it?
18:17:43 <jmcarthur> I need to work on the wording though. It's not as precise as I would like.
18:17:59 <Exio4> with runCounter 
18:18:03 <hackrilege> but "merge" two F's seems misleading as it sounds like you are composing functions, as you say F is modifying...
18:18:04 <Pamelloes> Is this a valid definition of <*>? a <*> b = fmap (\(a,b) -> a b) $ both (a,b)
18:18:08 <johnw> TheArtist: runCounter action initialState
18:18:44 <johnw> Pamelloes: yep
18:18:45 <jmcarthur> hackrilege: I think my use of the word "merge" is reasonable enough. I am, in fact, composing two Fs (to create a single F) in some way.
18:18:50 <Exio4> Pamelloes: yes, that's how you recover ap from both, fmap (uncurry ($)) . both 
18:18:55 <TheArtist> Nice thanks!
18:19:23 <jmcarthur> hackrilege: but it's not to be thought of as though F is a Haskell value or something. It is important to view it as a type constructor.
18:19:30 <Pamelloes> Cool! :)
18:19:45 <Exio4> @let both :: Applicative f => (a,b) -> f (a,b) ; both = liftA2 (,) in fmap (uncurry ($)) . both
18:19:46 <lambdabot>  Parse failed: Parse error: in
18:19:55 <Exio4> @type let both :: Applicative f => (a,b) -> f (a,b) ; both = liftA2 (,) in fmap (uncurry ($)) . both
18:19:56 <hackrilege> but F (F a) /= F a
18:19:57 <lambdabot>     Couldn't match type ‚Äòb1‚Äô with ‚Äò(b1, b0)‚Äô
18:19:57 <lambdabot>       ‚Äòb1‚Äô is a rigid type variable bound by
18:19:57 <lambdabot>            the type signature for
18:20:12 <Exio4> I should check my code in pm first
18:20:14 <jmcarthur> hackrilege: that's right. join is a forgetful transformation.
18:20:26 <hackrilege> :t both
18:20:27 <Welkin> (f a, f b) -- Exio4 
18:20:27 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => (a -> f b) -> r a a -> f (r b b)
18:20:32 <jmcarthur> ha
18:20:38 <jmcarthur> :t liftA2 both
18:20:39 <lambdabot> (Applicative f, Applicative f1, Data.Bitraversable.Bitraversable r) => f (a -> f1 b) -> f (r a a) -> f (f1 (r b b))
18:20:42 <johnw> jmcarthur: it's as much merge as mappend is merge, I can understand it just fine, though with Maybe it's harder to explain mappend as merging, rather than choosing...
18:20:44 <jmcarthur> bah what am i doing
18:20:47 <Exio4> oh, right Welkin 
18:20:49 <jmcarthur> :t liftA2 (,)
18:20:50 <lambdabot> Applicative f => f a -> f b -> f (a, b)
18:21:03 <jmcarthur> @let both = liftA2 (,)
18:21:04 <Exio4> uncurry (liftA2 (,)) :p
18:21:05 <lambdabot>  Defined.
18:21:12 <jmcarthur> of course
18:21:15 <jmcarthur> @undef
18:21:15 <lambdabot> Undefined.
18:21:20 <jmcarthur> @let both = (uncurry.liftA2) (,)
18:21:21 <lambdabot>  Defined.
18:21:27 <hackrilege> lol
18:21:32 <Exio4> @type both 
18:21:34 <lambdabot>     Ambiguous occurrence ‚Äòboth‚Äô
18:21:34 <lambdabot>     It could refer to either ‚ÄòL.both‚Äô,
18:21:34 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:145:1
18:21:38 <Exio4> @type L.both
18:21:39 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
18:21:42 <jmcarthur> aw man that's annoying
18:21:52 <Exio4> @type fmap (uncurry ($)) . L.both
18:21:53 <lambdabot> Applicative f => (f (a -> b), f a) -> f b
18:21:58 <jmcarthur> johnw: did you mean to say that to hackrilege?
18:22:07 <Exio4> @type uncurry (<*>)
18:22:08 <lambdabot> Applicative f => (f (a -> b), f a) -> f b
18:22:16 <johnw> 18:18 <jmcarthur> hackrilege: I think my use of the word "merge" is reasonable enough. I am, in fact, composing two Fs (to create a single F) in some way.
18:22:21 <hackrilege> :t mappend
18:22:22 <lambdabot> Monoid a => a -> a -> a
18:22:34 <hackrilege> interesting
18:22:36 <jmcarthur> yes, i was thinking of bring up mappend
18:22:53 <jmcarthur> the unit i left out of my explanation of Applicative is the other method of Monoid that matters
18:22:55 <jmcarthur> :t mempty
18:22:56 <lambdabot> Monoid a => a
18:23:00 <jmcarthur> unit :: f ()
18:23:58 <jmcarthur> hackrilege: the Monoid laws are:    mempty `mappend` a = a    a `mappend` mempty = a    (a `mappend` b) `mappend` c = a `mappend` (b `mappend` c)
18:24:00 <hackrilege> what is it mean, "a monad modifies a value"
18:24:03 <Pamelloes> I love how even after months of using Functors, Applicatives, etc. I can still learn new ways to think about them :)
18:24:11 <jmcarthur> hackrilege: the Applicative laws are the same, just using unit and both instead of mempty and mappend
18:24:28 <jmcarthur> hackrilege: context?
18:24:30 <dmwit> edwardk: Is there (plans for) a data structure like Map, but with O(n) runtime for all the interesting operations?
18:24:30 <Welkin> hackrilege: the "monad" doesn't do anything
18:24:32 <johnw> Pamelloes: oh, and there are more! :)
18:24:41 <Welkin> hackrilege: Monad is just a typeclass
18:24:44 <Pamelloes> I don't doubt it :D
18:25:00 <Welkin> hackrilege: I think you mean bind (>>=)
18:25:08 <Pamelloes> In other news, ghc takes forever to compile....
18:25:11 <dmwit> edwardk: I don't really need one, so read this as curiosity rather than peer pressure.
18:25:21 <Pamelloes> I'm not sure which is worse: ghc or llvm.
18:25:24 <lpaste_> phunehehe pasted ‚ÄúViewPatterns Pattern match(es) are non-exhaustive‚Äù at http://lpaste.net/140423
18:25:26 <hackrilege> nono as in F modifies a type
18:25:39 <phunehehe> hi
18:25:45 <hackrilege> and confused via getLine :: IO String
18:25:47 <phunehehe> (wow I didn't know lpaste posts here directly)
18:25:47 <Pamelloes> Hi!
18:25:55 <jmcarthur> hackrilege: I think "modifies" was a bad word choice. I only meant that it creates a type having accepted a type as an argument.
18:26:04 <jmcarthur> hackrilege: in the sense that Maybe Int is a different type from Int
18:26:05 <c_wraith> phunehehe: only if you set the "channel" field
18:26:13 <Welkin> hackrilege: one way of thinking about it is "functors/monads as containers"
18:26:21 <hackrilege> so just say it has kind * -> *
18:26:32 <phunehehe> so I'm playing with ViewPatterns, and seems like it's failing to check for exhaustiveness in a very simple case (in the paste)
18:26:44 <jmcarthur> hackrilege: yeah, but i wanted to talk about the type it's applied to, and badly chose the word "modified"
18:27:00 <phunehehe> am I doing it wrong, or is this the sign of some bug?
18:27:03 <Pamelloes> phunehehe: Is ViewPatterns what's creating the funky -> syntax?
18:27:06 <jmcarthur> hackrilege: and i wanted to be careful to avoid saying something about values
18:27:24 <edwardk> dmwit: you can use discrimination to build an existing Data.Map in O(n)
18:27:40 <phunehehe> Pamelloes: yeah, though it's me who created that :"> ViewPatterns make it possible
18:27:51 <dmwit> edwardk: Yup. But it seems like there ought to be a number of other operations that can be done in O(n) as well.
18:27:54 <edwardk> http://ekmett.github.io/discrimination/Data-Discrimination.html#v:toMap
18:27:55 <dmwit> edwardk: e.g. lookup at least
18:28:03 <edwardk> lookup is better than O(n) now ;)
18:28:23 <dmwit> ?slap dmwit
18:28:24 * lambdabot secretly deletes dmwit's source code
18:28:30 <jmcarthur> hackrilege: anyway, i have to go. good luck with monads! and don't feel like you have to understand everything!
18:28:37 <phunehehe> there is a note about exhaustiveness in the wiki, so I thought that might be it https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns#Compilation
18:28:48 <dmwit> edwardk: And I guess the trick for the others (like union/intersection) is to go via lists, huh?
18:29:03 <Welkin> lookup on Map is O(log n) I thought
18:29:11 <johnw> edwardk: already back in Boston?
18:29:13 <Welkin> it is a binary tree
18:29:20 <johnw> edwardk: you're fast
18:29:37 <hackrilege> "Maybe Int is not Int" but at the same time, the Int does not change, so it is not modified in this sense, it is a modification on the type only... so a Functor gives you the ability to manipulate the argument to a type variable which takes a type variable as an argument...
18:29:41 <dmwit> Welkin: It's not a binary tree, but you're correct that it's O(log n) and therefore sublinear and therefore I'm an idiot.
18:30:03 <hackrilege> thanks jmcarthur
18:30:04 <dmwit> I guess union and intersection are also already linear.
18:30:10 <Welkin> what is it then if not a binary tree?
18:30:13 <Welkin> some other kind of tree?
18:30:21 <dmwit> So, gosh, maybe fromList is the only one that needs discrimination.
18:30:24 <dmwit> Welkin: yes
18:30:30 <Welkin> what kind of tree?
18:30:44 <Axman6> edwardk: could you use https://github.com/mikeizbicki/ifcxt#ifcxt to always choose the most optimal descrimination function for your descrimination work?
18:30:54 <dmwit> Welkin: ...binary
18:30:57 <dmwit> wow I am on point today
18:31:19 <dmwit> http://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Map-Base.html#Map
18:31:53 <dmj`> edwardk: O(n) nub, nice.... mutVar looks interesting
18:33:04 <Exio4> edwardk: how.. how does this work? any paper to read about this? :P
18:33:06 <edwardk> Axman6: the ifcxt thing requires someone to religiously build an instance for every other instance in their system
18:33:14 <edwardk> Exio4: basically it is radix sort on steroids
18:33:17 <dmwit> Exio4: See the top-level Hackage page, which has links to papers and talks.
18:33:38 <dmwit> ifcxt is kind of neat
18:33:44 <edwardk> johnw: back home, hacking on stuff. trying to get some rcu code to work
18:33:50 <edwardk> based on ted cooper's poster presentation
18:33:56 <edwardk> i think i can make a nice api around it
18:33:57 <Exio4> oh, thanks
18:34:07 <Axman6> edwardk: well, there are certain classes which allow you to make better decisions, like Integral, Generic, Ord and Eq in the worst case, right?
18:34:17 <johnw> edwardk: I'm using Lenses to make Hoopl bearable
18:34:25 <edwardk> Axman6: the issue is that IfCxt isn't an easily implemented solution
18:34:45 <Axman6> edwardk: Can I give you an hour, and you'll have a better one? :P
18:34:50 <edwardk> Axman6: it requires e.g. if you define a new instance of Show that you define a new instance of IfCxt Show for that concrete type
18:35:07 <edwardk> Axman6: no. it is fundamentally against the open world assumption, so i don't believe in ifcxt as a solution ;)
18:35:22 <Axman6> heh ok =)
18:35:51 <hackrilege> thanks TheArtist
18:37:18 <Axman6> it looked like you could write something like: superSort :: Ord a => [a] -> [a]; suprtSort = ifCtx (Proxy :: Proxy (Integral a)) intSort (ifCtx Proxt :: Proxy (Generic a)) genSort sort
18:37:38 <Axman6> )
18:37:41 <Axman6> >_>
18:37:45 <dmwit> I don't understand how IfCxt works.
18:39:42 <dmwit> Time for -ddump-splices, I think.
18:40:21 <dmwit> Oh, this is terrible.
18:42:43 <dmwit> ifcxt needs to go in the Acme namespace
18:44:54 <edwardk> dmwit: overlapping instances and template haskell to generate an instance for every instance of the other class
18:45:08 <edwardk> which is great right up until you need to do it twice
18:45:18 <edwardk> it doesn't scale
18:45:21 <Axman6> that sounds like it'll have excellent compile times...
18:45:54 <edwardk> Axman6: compile times are fine, its the problem that you'll be using TH to generate necessarily-orphan instances and i'm pretty sure the TH doesn't know how to filter out things that are already instances of IfCxt
18:46:06 <dmwit> edwardk: Yeah, -ddump-splices exposed all.
18:46:10 <edwardk> so in the end its basically an incredibly easily broken toy solution
18:46:15 <Axman6> gross
18:46:42 <dmwit> And it doesn't even do what it says on the tin, because you don't get any guarantees that your TH runs with all the right instances in scope.
18:47:17 <thebuccaneersden> Fresh install of cabal from apt repo. Trying to: ‚Äúcabal install cabal-install‚Äú, but I get the following error:
18:47:30 <dmwit> ?paste
18:47:31 <lambdabot> Haskell pastebin: http://lpaste.net/
18:47:38 <Welkin> thebuccaneersden: don't use anything from apt
18:47:41 <dmwit> Don't paste things longer than a line or two in-channel.
18:47:44 <thebuccaneersden> kk
18:47:58 <Welkin> thebuccaneersden: it's better to just install ghc + cabal-install directly
18:48:05 <Exio4> I thought it did some GHC magic in the sense that it exploited some behavior when a contrainst didn't match at first :P 
18:48:06 <Welkin> it is very easy to do now
18:48:06 <Axman6> or use stack
18:48:28 <thebuccaneersden> I might try that but this seems to be a trivial issue so far, I just lack experience with cabal
18:48:32 <thebuccaneersden> pastie ~~> http://lpaste.net/140424
18:48:52 <Welkin> thebuccaneersden: your version of ghc is too old
18:48:54 <Welkin> :P
18:49:01 <hackrilege> can you cabal install ghc?
18:49:01 <Welkin> so the issue is you are using the version from apt
18:49:06 <Welkin> go get the newer release
18:49:16 <dmwit> hackrilege: No, not really.
18:49:23 <hackrilege> ok
18:49:31 <Welkin> or use stack
18:49:33 <Axman6> you can use dtack to install ghc though
18:49:36 <Axman6> stack*
18:49:48 <Welkin> thebuccaneersden: https://www.haskell.org/ghc/
18:49:49 <dmwit> thebuccaneersden: You could consider `cabal install cabal-install --constraint 'base installed'`.
18:50:08 <hackrilege> im stuck on an android phone, does anyone know a way i can develop packages for hackage online?
18:50:18 <dmwit> thebuccaneersden: Which should help cabal figure out how to pick a version of cabal-install that works with your current base, rather than the latest cabal-install.
18:50:20 <thebuccaneersden> http://lpaste.net/140425
18:50:27 <dmwit> thebuccaneersden: But upgrading GHC is probably the better way long-term.
18:50:39 <thebuccaneersden> dmwit ~~> ^
18:50:49 <thebuccaneersden> so would that mean installing ghc outside of apt or cabal?
18:51:04 <hackrilege> nothing
18:51:06 <dmwit> thebuccaneersden: Yes, it would mean getting a copy from the official GHC download site.
18:51:20 <dmwit> ?where ghc
18:51:20 <lambdabot> http://haskell.org/ghc
18:51:26 <thebuccaneersden> i‚Äôll try it
18:51:59 <dmwit> https://www.haskell.org/ghc/download_ghc_7_10_2 for the direct link to the current latest version
18:52:13 <Pamelloes> What does the notation <<ghc: .... :ghc>> mean, when compiling ghc?
18:52:16 <geekosaur> should someone mention hvr's ppa?
18:52:36 <hackrilege> can i use stack to install ghci on android?
18:52:40 <dmwit> hackrilege: I think FP complete has an online IDE. Never used it, though, so I can't really vouch for or against it.
18:53:08 <hackrilege> thanks dimwit
18:53:33 <thebuccaneersden> downloading ghc ~~> eta 87m 51s
18:53:46 <dmwit> hackrilege: Installing GHC on an android is going to be rough going. It's almost certainly ARM, to begin with, so you'll need to make a cross-compiling GHC just to get bootstrapped. And as I recall there's some serious voodoo needed to make even an ARM-capable cross compiler work well with android.
18:53:50 <thebuccaneersden> yikes, it only a 135M file. servers must be slow
18:54:27 <hackrilege> i think actually neurocyte has a working arm ghc cross compiler
18:54:44 <johnw> I think erikd has been as well
18:54:49 <Pamelloes> thebuccaneersden: You /could/ fetch the source from github in under 5 minutes. But then it will take 2-3 hours to compile. :P
18:54:51 <dmwit> hackrilege: See https://github.com/neurocyte/ghc-android if you want to go down that route. I believe some of those patches need updating for the newest GHC.
18:55:23 <hackrilege> its a few years old and might be out of date, and the compilation requires debootstrap which i cant get to work on android...
18:55:25 <thebuccaneersden> lol
18:55:33 <lingxiao> is this considered idiomatic?
18:55:34 <lingxiao> http://lpaste.net/140426
18:55:44 <thebuccaneersden> it sped up now. 73 seconds now
18:55:47 <lingxiao> a student asked this and I honestly have no idea
18:55:56 <dmwit> lingxiao: modulo posible incompleteness, that looks fine to me
18:55:59 <johnw> lingxiao: I don't see anything wrong with it
18:56:07 <johnw> besides what dmwit suggested
18:56:12 <lingxiao> he's asking if it's "pretty" to mix guards and pattern mathcing
18:56:19 <johnw> sure
18:56:27 <dmwit> Often that's just what the doctor ordered.
18:56:30 <johnw> throw in some view patterns while he's at it
18:56:36 <lingxiao> ok ..I'm waiting for one more opinion before generalizing to the whole haskell community :)
18:57:04 <johnw> cool, my opinion is 1/3 of the whole haskell community
18:57:20 <dmwit> johnw: Nah, I'm 3/4 and you're 1/8. ;-)
18:57:20 <lingxiao> ha .. didn't say it was uniform weight :)>
18:57:28 <johnw> drat
18:57:28 <lingxiao> dmwit has the right spirit
18:57:32 <hackrilege> would anyone be up for helping me revisit the neurocyte cross compiler? it would be pretty fruitful for the comunity to document the steps taken in producing such a tool if it needs constant upgrading by noobs
18:58:19 <dmwit> hackrilege: Making those patches robust enough to include in GHC mainline would be fantastic, but is also a pretty big undertaking. I was on a project to do that for a little while, but funding got cut.
18:58:32 <lingxiao> hey guys
18:58:37 <hackrilege> hmmm funding
18:58:39 <Pamelloes> Hi!
18:58:43 * Pamelloes is a guy.
18:58:44 <hackrilege> hi
18:58:44 <lingxiao> i recall reading this funny article about what your haskell style say about you
18:58:53 <lingxiao> like if you write point free.. then you must be ...
18:58:58 <hackrilege> lol
18:58:59 <lingxiao> this is all with the fib function
18:59:02 <Exio4> lingxiao: well, you can also mix guards and patterns in the same guard
18:59:08 <lingxiao> anyone know the link of the top of their head
18:59:17 <lingxiao> Exio4 if you saw that would you cringe?
18:59:20 <johnw> http://www.willamette.edu/~fruehr/haskell/evolution.html
18:59:23 <lingxiao> say you're in a pendantic mode
18:59:26 <lingxiao> mood*
18:59:30 <johnw> lingxiao: ^^
18:59:38 <lingxiao> great exactly that
18:59:50 <hackrilege> i can still only understand half of that evolution post...
19:00:05 <johnw> that's why it's called evolution
19:00:17 <Exio4> lingxiao: I wouldn't, I mean, it depends on the conditions may be or whatever, I just go with whatever makes the code look good 
19:00:26 <Welkin> lol
19:00:29 <Welkin> I love that page
19:00:43 <Welkin> post-doc
19:00:44 <Welkin> hahaha
19:00:45 <lingxiao> see in lecture the prof says if you can use guard, you should since it's most beautifl
19:00:51 <Welkin> jle`: which one are you? :P
19:00:52 <lingxiao> and Im stting there like really? I never use guards
19:00:57 <hackrilege> dmwit, its a shame its  big undertaking because it needs to be done, like or i have to buy a new computer or get a virtual private server...
19:01:05 <lingxiao> maybe im not beautiful :(
19:01:07 <Welkin> lingxiao: guards are very useful
19:01:14 <lingxiao> I love case 
19:01:17 <jle`> Welkin: did i miss some context?
19:01:19 <jle`> oh heh
19:01:21 <Welkin> you use them in place of `if ... then ... else`
19:01:27 <Welkin> otherwise you need nested if's
19:01:31 <Welkin> and if is not idiomatic haskell
19:01:36 <MarcelineVQ> guards are akin to if, case is akin to pattern matching, iirc
19:01:44 <Welkin> jle`: http://www.willamette.edu/~fruehr/haskell/evolution.html
19:02:14 <hiptobecubic> MarcelineVQ, yes, although you can do use guards with case as well
19:02:16 <Exio4> lingxiao: I normally prefer pattern matching if possible
19:02:30 <hiptobecubic> MarcelineVQ, case _ of | expr1 -> whatever; expr2 -> whatever;
19:02:42 <Welkin> pattern matching is not the same as pattern guards though
19:02:43 <lingxiao> yeah I think since the prof says guards the most beautfil, all the students are tripping over each other using guards if possible
19:02:44 <hiptobecubic> err... with correct syntax
19:03:01 <jle`> every time i read that page i understand more of it, haha
19:03:01 <Welkin> for example
19:03:02 <Exio4> Welkin: well, you are doing pattern matching there
19:03:19 <hiptobecubic> case () of () | expr1 -> ... | expr2 -> ...;
19:03:19 <Welkin> someFunc f = f > 5 = ...
19:03:24 <MarcelineVQ> I use if anytime it would have fit on one line anyway
19:03:32 <Welkin> someFunc (Just a) = a > 5 = ...
19:03:34 <Welkin> better example
19:03:37 <hackrilege> i would have thought it would be trivial to wrap a main routien into a c shared library and import that into an android java file as a form of compilation...
19:03:42 <Welkin> er
19:03:46 <Exio4> Welkin: s/=/|/ ? 
19:03:46 <Welkin> someFunc (Just a) | a > 5 = ...
19:04:31 <hackrilege> as writing for android on android requires aide, which only compiles android c and android java...
19:04:33 <Exio4> yes, but pattern guards are also nice for things like someFunc x | Just v <- f x , condition v = ... , I prefer to use Maybe a over "bool" + something that may fail or so
19:05:04 <Exio4> (as you also avoid the `double` check!)
19:05:04 <johnw> Exio4: or, someFunc (f -> Just v)
19:05:18 <hackrilege> applications targeting arm and apps which run on android are not the same thing i think
19:05:33 <Exio4> johnw: that was silly, but you might want the x in some example, or anything
19:05:41 <Exio4> (that was silly = my example was silly)
19:06:03 <johnw> yeah, good point about capturing the x for later use
19:06:17 <hackrilege> the problem is twofold, arm compilation only satisfies the hardware, not the opperating system, you would still basically need to root your phon or use proot which i cant see stable anywhere...
19:06:19 <Exio4> someFunc x@(f -> Just v) works, though
19:06:21 <Exio4> doesn't it?
19:06:30 <johnw> it captures the result of f
19:06:37 <Exio4> oh
19:07:44 <Welkin> ViewPAtterns
19:08:00 * hackagebot pinboard 0.7.5 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.7.5 (jonschoning)
19:08:05 <hackrilege> so really it looks like FFI is the way to go rather than cross-compilation, for reasons about how hard it is to run linux in android
19:08:15 <Welkin> actually, thanks for reminded me about a <- f a in pattern guards
19:08:24 <Welkin> reminding*
19:08:43 <johnw> yeah, same here
19:08:44 <dmwit> > let f x@(Just -> Just y) = x in f 3
19:08:45 <lambdabot>  3
19:08:56 <dmwit> It doesn't capture the result of the view at all.
19:09:10 <johnw> oh, huh
19:09:12 <johnw> good to know!
19:09:23 <johnw> I should have tried it in lambdabot
19:13:38 <AaronFriel> Riddle me this: a deterministic finite* automoton/finite state machine with states whose values are tagged with an integer that can be incremented and decremented is actually a... (and the * is because we're no longer talking about finite automatons)
19:14:03 <lingxiao> great thanks guys!
19:14:14 <Gurkenglas> Why isn't there Monoid m => Monad ((,) m)?
19:15:26 <hackrilege> isnt there?
19:15:35 <Gurkenglas> I know, right?
19:15:37 <AaronFriel> I'm guessing as long as the states are limited to increment and decrement, it's not going to be turing-complete (if we add arbitrary arithmetic, it becomes turing complete)
19:15:40 <johnw> there's Writer, but not an instance for (,) m
19:15:43 <Axman6> isn't that basically Writer?
19:16:28 <Gurkenglas> Okay so is anyone gonna throw sand in my face for using that as an orphan instance in my application
19:16:33 <hackrilege> what is Writer?
19:17:00 <hackrilege> no if you start using it maybe it will become a thing
19:17:27 <hackrilege> all patterns should be canonically recorded
19:17:34 <Gurkenglas> I dunno it was kinda one of the three primary examples from that "mother of all papers" back then that introduced monads
19:17:39 <Gurkenglas> If it hasn't caught on by now...
19:17:57 <hackrilege> then people havnt read enough...
19:18:11 <hackrilege> link?
19:18:14 <AaronFriel> So what I'm wondering is - if I constrain a finite state machine to operating on types and type-level-naturals as states
19:18:31 <AaronFriel> Do I get something more powerful than a DFA? Yes, I think so, because I can write a balanced-pair parser with that.
19:18:38 <AaronFriel> Infinite regress isn't a problem
19:19:05 <Gurkenglas> hackrilege, http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
19:19:11 <hackrilege> thanks
19:19:38 <AaronFriel> But if I constrain my operations on the integer states to *just* increment/decrement, do I get something more powerful than a DFA but not turing complete, and for which I can still treat it as a graph? I think so, but I can't find anyone who's done this.
19:22:56 <hackrilege> wow, is that basically the whole of haskell?
19:23:56 <Gurkenglas> That's 1992 for ya
19:24:25 <hackrilege> its pre haskell?
19:24:37 <hackrilege> or a complete motivation for it?
19:25:51 <hackrilege> im not sure how to interpret what im seeing here... its not a complete haskell specification but im not sure, it looks like it might be something like one
19:26:23 <AaronFriel> hackrilege: It is not, although IRC appears to be splitting a bunch so I am not sure if I'm missing message
19:26:23 <Gurkenglas> It mentions Haskell in the introduction
19:26:40 <hackrilege> did wadeler give another paper which is more complete? or is that just the haskell prelude?
19:27:00 <AaronFriel> hackrilege: The idea of using Monads was added to Haskell, they weren't initially in the prelude / base system
19:27:12 <hackrilege> thats the information i needed thanks
19:27:28 <hackrilege> haskell can exist without monads... but not as we know it...
19:27:51 <hackrilege> they would need it for IO no?
19:27:56 <AaronFriel> Nope
19:28:00 <hackrilege> hmmm
19:28:03 <AaronFriel> But you leak lazy IO everywhere
19:28:04 <hackrilege> cool
19:28:15 <AaronFriel> The original Haskell used lazy lists for everything, and didn't encapsulate off IO
19:28:18 <hackrilege> leak lazy io?
19:28:21 <levi> Haskell was around quite a while pre-Monad.
19:28:50 <AaronFriel> So for example, if you want to read a file, in modern Haskell you might have some function of type IO [ByteString] which returns a list of lines
19:28:52 <hackrilege> what is wrong for lazy lists for everyhting?
19:29:00 <AaronFriel> In early Haskell, you would have just [ByteString]
19:29:05 <levi> Initially you couldn't write Monad because type classes didn't support types of kind * -> *
19:29:14 <hackrilege> right
19:29:24 <hackrilege> but then mapping is more unified
19:29:31 <AaronFriel> hackrilege: Lazy lists aren't bad except these were lazy lists that had a dark secret: in order to evaluate them, they had to perform IO
19:29:37 <hackrilege> no functor instance required...
19:29:41 <AaronFriel> hackrilege: Which meant you could "sneak in" IO values anywhere
19:29:41 <hackrilege> but no nice trees...
19:30:07 <AaronFriel> hackrilege: e.g.: You could have a lazy list of integers which, when you evaluate the 42nd integer, it "FiresTheMissiles"
19:30:22 <AaronFriel> hackrilege: Now you can do that in Haskell today, but at some point you have to do IO, or unsafePerformIO
19:30:34 <hackrilege> right
19:30:42 <AaronFriel> hackrilege: Lazy lists make it very hard to reason about the sequence of IO actions as well
19:30:48 <hackrilege> im getting what is meant by unsafe finally
19:31:29 <hackrilege> but isnt the idea that by using lazy evaluation you control the order of evaluation in a nice way so its fine...
19:32:03 <hackrilege> i mean lazy evaluation is deterministic right?
19:32:08 <AaronFriel> No
19:32:14 <hackrilege> argh, how?
19:32:14 <AaronFriel> Not with lazy IO
19:32:18 <hackrilege> hmmm
19:32:46 <AaronFriel> hackrilege: Here just read this: http://stackoverflow.com/questions/5892653/whats-so-bad-about-lazy-i-o
19:33:00 <AaronFriel> hackrilege: I'm not saying something is wrong with lazy lists, just lazy IO.
19:33:00 <hackrilege> how would the fiering of missiles screw up my order of evaluation?
19:33:58 <AaronFriel> hackrilege: How about True == False returning True?
19:34:07 <AaronFriel> hackrilege: Does that sound bad?
19:34:08 <hackrilege> ah because these missile fiering opperations may ask for parts we thought would not be evaluated to be evaluated... ok
19:34:23 <AaronFriel> hackrilege, read this: https://mail.haskell.org/pipermail/haskell-cafe/2013-April/107547.html
19:35:06 <MarcelineVQ> o-oh
19:35:27 <AaronFriel> hackrilege: Specifically, you can construct a boolean pair such that (x == y) returns false 
19:35:32 <AaronFriel> hackrilege, and (y == x) returns true
19:35:39 <AaronFriel> Which seems bad.
19:35:47 <hackrilege> yes thats bad
19:36:16 <AaronFriel> hackrilege: And that's why lazy IO is evil, is because it can do anything at all, include change the results of other lazy IO values
19:38:18 <Alpha64> where can i read about chunked IO ? 
19:38:40 <Alpha64> it sounds like back pressure in pipes
19:39:49 <johnw> when contemplating the evilness of lazy I/O, please also read http://comonad.com/reader/2015/on-the-unsafety-of-interleaved-io/
19:40:25 <hackrilege> ok
19:41:36 <hackrilege> so im still not sure if my candidate datastructure is applicative or a monad...
19:42:22 <hackrilege> can i have a simple test which a non monad applicative would fail
19:42:24 <AaronFriel> Well if it's a monad, it's definitely an applicative functor.
19:42:42 <hackrilege> but is it a monad?
19:43:34 <AaronFriel> I don't know, what's your data type?
19:43:40 <AaronFriel> Alpha64: What do you mean by "chunked IO"?
19:43:46 <hackrilege> can i define monad instances just in terms of operations that are the instances of applicative functors
19:43:54 <johnw> hackrilege: no
19:44:00 <Alpha64> the thing hinted in the SO link AaronFriel 
19:44:06 <hackrilege> obviously
19:44:24 <hackrilege> but i cant see where i will fail..
19:44:48 <AaronFriel> Alpha64: Chunked IO is used by pipes IO, conduit IO, et al.
19:45:26 <AaronFriel> Alpha64: Basically, consume large-ish chunks of a file or an input stream, where large-ish strikes some balance between the latency of reads/writes and how efficiently the chunk can be operated on
19:45:53 <AaronFriel> Alpha64: Reading a 100GB file is a bad idea if you try to do it "all at once", and so most IO libraries utilize chunked IO where you get a [ByteString] instead of a ByteString
19:45:54 <samba1> What's the easiest way to make a [Bool] a thousand elements long, all False except a few that I specify. So, I'll randomly generate n integers between 0 and 999 and the elements at those indexes should be true. It's the "setting" of the list that's hard.
19:46:04 <AaronFriel> Alpha64: Alternatively, how would you read all of /dev/urandom into memory?
19:46:19 <hackrilege> basically atoms are position modifying functions with associated possitions. this could also be seen as a function taking two positions and returning two positions and a position...
19:47:09 <hackrilege> a postion and a function*
19:47:11 <AaronFriel> hackrilege: Without seeing the types it's hard for me to say, but it doesn't sound like you have a monad.
19:47:24 <hackrilege> its sounding applicative though?
19:47:32 <AaronFriel> hackrilege: And I don't know what making it a monad would give you. Applicative might be right.
19:47:55 <AaronFriel> hackrilege: But why is what you're doing a functor at all? What are you applying to the contents of your atoms?
19:48:10 <AaronFriel> for example
19:48:17 <AaronFriel> > fmap (+5) [1,2,3]
19:48:19 <lambdabot>  [6,7,8]
19:48:22 <hackrilege> atoms are functors of postitions, but they also attract so they are applicative... i think thats how it works
19:48:28 <AaronFriel> See, I applied a function to the contents of the list
19:48:48 <AaronFriel> what would `fmap f atom` mean?
19:49:32 <hackrilege> atoms apparently can also be functions on positions or positions, this allows you to apply an atom which is a function to an atom which is a position... seems unintuitive...
19:49:46 <AaronFriel> ... yeah that seems strange.
19:50:04 <hackrilege> maping over an atom would change its poition i guess if it was an atom of a position
19:50:20 <hackrilege> fmap translate atom
19:51:45 <hackrilege> but i can also fmap (translate a) b
19:52:51 <hackrilege> no thats not right.. sorry
19:53:37 <hackrilege> fmap (+) (a::Atom Double)
19:53:38 <hiptobecubic> "Functional Programming" as a search query is becoming useless. It's too trendy now. You find things like this: "Experience with functional programming languages (Scala, Go)"
19:53:49 <hiptobecubic> Go? Go.
19:54:20 <hiptobecubic> Go, which apparently does not even support the most basic parametric polymorphism?
19:55:24 <slack1256> it's good that is trendy
19:55:31 <slack1256> unless you google stuff
19:56:24 <hackrilege> so it seems that though atoms are a viable candidate for applicative functors, as we would like that atoms are already supplied a type, its kind as a functor is strange
19:56:34 <hiptobecubic> It's good in that it indicates favorable climate. It's not good in that it's becoming diluted to the point where it loses meaning. "Functional Programming" now means "programming involving any of the cool new languages of the last five years or so"
19:57:02 <hackrilege> :t liftA2
19:57:03 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:57:08 <hiptobecubic> So you start seeing job postings for Swift and Go
19:57:13 <sshine> Monad m => (a -> m b) -> Set a -> m (Set b)
19:57:19 <sshine> @hoogle Monad m => (a -> m b) -> Set a -> m (Set b)
19:57:20 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
19:57:20 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
19:57:20 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
19:57:43 <sshine> neat.
20:00:17 <hackrilege> AronFriel, does evey binary function not motivate an applicative instance to some datatype?
20:00:35 <slack1256> hiptobecubic: but functional programming was already a diluted term
20:00:49 <slack1256> atleast by harper
20:01:01 <hackrilege> pure functional recovers the desired scope
20:01:06 <slack1256> pure functional programming is mostly synonimous with haskell :-P
20:01:31 <hackrilege> good,its where the theory lies most routed
20:01:54 <hackrilege> scala has for loops?
20:02:13 <hackrilege> nvm
20:02:33 <dmwit> samba1: did you get an answer?
20:05:00 <hackrilege> i guess the question is more, why would i make an instance of applicative if i could just apply the function to data not stored in a datatype of kind (* -> *)
20:06:13 <hackrilege> similarly, when applying a function to one argument, when mapping over some datastructure, when is it appropriate to define a functor?
20:06:54 <slack1256> if you can derive automatically go for it
20:07:07 <hackrilege> well you always can thats the point
20:07:10 <glguy> You make an Applicative instance when you want to make use of the functions that are defined in terms of Applicative constraints
20:07:25 <glguy> And you can't always make a Functor instance, but when you can they're handy to have
20:07:26 <hackrilege> but you get this clumps paramatrised type, why? why do that ever?
20:07:32 <hackrilege> clumsy*
20:08:14 <hackrilege> if i have (a->b) why could i not have (f a -> f b)?
20:08:15 <glguy> If it's clumsy then don't do it, but typically it's handy to be able to change the type in a structure
20:08:32 <hackrilege> "handy"
20:08:46 <glguy> makes code better, allows more reuse
20:10:06 <glguy> the parameterized type saves you from duplicating that structure once for every type you need it use it at
20:10:10 <hackrilege> i hit this because i have an atom in a molecule, so the molecule is a coolection of atoms, so i should map over it, so its a functor, so the atoms have to be functors so they can take both functions and values so i can use functions stored as atoms to modify positions stored as atoms, the only clumsyness is that now atoms are functions and i just broke chemistry
20:10:26 <StackFlagsToCaba> I'm using stack for the first time and need to pass a whole bunch of flags to cabal to build a dependency on my mac. Can anyone please point me to a stack.yaml files that shows how to do this?
20:11:37 <slack1256> hackrilege: wait, why the atoms have to be functors
20:11:55 <glguy> hackrilege: It sounds like it'd be better if you had a parameterized Collection type and a non-parameterized Atom type
20:12:05 <slack1256> I kind of understand the molecule case (unless you have more constrains apart of just being a collection of atoms)
20:12:33 <hackrilege> because for the molecules to be able to use the thing they are storing to modify the things they are storing.. sorry thats obtuse
20:12:40 <glguy> But having molecule be parameterized by its atom type makes it possible to extend that later
20:13:30 <glguy> You can do things like decided that type MoleculePattern = Moleclue (Maybe Atom) -- or whatever
20:13:31 <hackrilege> now i can have molecules of functions, and modify molecules of atoms, hopefully the traversal will be the same, and this actually gives advantages...
20:14:16 <hackrilege> but really atoms are Atom (Double,Double,Double)
20:14:23 <hackrilege> in everyones mind
20:15:13 <hackrilege> so really i should just make my molecules lists of atoms or something more transparent, which puts all the phrasing in terms of simple functions on tuples
20:16:04 <glguy> Why is an atom 3 Doubles?
20:16:07 <hackrilege> and then i wonder why ever i would want these functors... both representations are equivalent after all... so why suffer the syntactic overhead of all the instances?
20:16:16 <hackrilege> its a point in cartesian space
20:16:51 <dmwit> hackrilege: It sounds to me like your complaint boils down to "it doesn't make sense to parametrize Atom". So don't.
20:16:59 <hackrilege> it has asociated mass, but this is not what we map over as it is constant, and asside from the dynamics
20:17:00 <glguy> You should just write the code however makes it easier for you to use
20:17:19 <hackrilege> but mollecules are applicative functors
20:17:33 <hackrilege> and that was the point of my investigation
20:17:46 <glguy> If you're never going to change the type of the Atoms in your Molecules then it probably shouldn't be a parameter
20:17:57 <dmwit> hackrilege: Also, to answer one of your early questions directly: the canonical operation that Monads can do that Applicatives can't is `join :: m (m a) -> m a`.
20:18:17 <hackrilege> molecule implicitly stores functions in the atom functors for its applicative instance (if i understand correctly)
20:18:40 <hackrilege> join, awesome
20:18:59 <hackrilege> is that close to what lens does with fix fmap?
20:19:15 <edwardk> :t fix fmap
20:19:16 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ f a
20:19:16 <lambdabot>     Expected type: (f a -> f b) -> f a -> f b
20:19:16 <lambdabot>       Actual type: (a -> b) -> f a -> f b
20:19:55 <hackrilege> :t \f-> fix (fmap f)
20:19:56 <lambdabot> Functor f => (a -> a) -> f a
20:20:04 <edwardk> :t fix . fmap
20:20:05 <lambdabot> Functor f => (a -> a) -> f a
20:20:09 <hackrilege> ok
20:20:11 <edwardk> ah
20:20:35 <dmwit> I don't think that's terribly related to join.
20:20:42 <edwardk> yeah, its its own thing
20:20:42 <glguy> What does lens do with fix . fmap?
20:20:47 <edwardk> glguy: nothing
20:20:52 <glguy> yet?
20:20:55 <edwardk> =)
20:20:57 <slack1256> heheh
20:21:14 <glguy> Hey, since you're talking to me, set me up on github?
20:21:22 <edwardk> that reminds me, after kenny foner's talk at the haskell symposium about his fixed point i should rename it loeb.
20:21:26 <hackrilege> um, its prgressing through layers of nested encapsulation...
20:21:28 <edwardk> sure, which repo?
20:21:34 <dmwit> fix . fmap seems like it would need a very special Functor instance to do something reasonable.
20:21:35 <glguy> prelude-extras
20:21:42 <edwardk> dmwit: it could work for lazy ones
20:21:48 <glguy> and parsers while you're there, someone needs to advance the base-orphans story
20:21:49 <dmwit> > fix . fmap $ (0:) :: Identity [Int]
20:21:51 <lambdabot>  Identity [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
20:21:52 <hackrilege> im talking about (fix $ fmap)
20:22:07 <edwardk> you have repo access now
20:22:10 <dmwit> `fix $ fmap` does not typecheck, as edwardk demonstrated above.
20:22:13 <glguy> thnx
20:22:19 <hackrilege> :t \f-> fix (fmap f)
20:22:20 <lambdabot> Functor f => (a -> a) -> f a
20:22:33 <edwardk> parsers too
20:22:39 <edwardk> do you need hackage access?
20:22:41 <glguy> can you do prelude-extras on hackage?
20:22:49 <glguy> you could do both, but that's the one i'll need shortly
20:22:50 <dmwit> `\f -> fix (fmap f)` is not equal to `fix $ fmap`.
20:22:58 <hackrilege> apparently...
20:23:25 <dmwit> It is equal to `fix . fmap`.
20:23:33 <edwardk> glguy: added you to both
20:23:41 <glguy> You're the best!
20:23:42 <hackrilege> :t fix . fmap
20:23:43 <lambdabot> Functor f => (a -> a) -> f a
20:23:45 <hackrilege> :t \f-> fix (fmap f)
20:23:47 <lambdabot> Functor f => (a -> a) -> f a
20:23:54 <hackrilege> oh soory
20:24:02 <dmwit> edwardk: Is there a canonical non-Identity Functor that this makes sense for?
20:24:04 <edwardk> glguy: your efforts are very very much appreciated. =) I waxed mildly effusive about them to iavor
20:24:06 <dmwit> Const, I guess.
20:24:17 <hackrilege> ok, so as i understood lens ==== fix . fmap
20:24:37 <edwardk> dmwit: data Pair a = Pair a a; instance Functor Pair where fmap f ~(Pair a b) = Pair (f a) (f b)
20:24:48 <edwardk> hackrilege: you've misunderstood lens
20:24:59 <dmwit> edwardk: aaaah, too cute
20:25:09 <hackrilege> your fault for slides containing too many fmap . fmap . fmap...
20:25:32 <edwardk> hackrilege: those are each separate 'semantic editor combinators' -- it never achieves a fixed point
20:25:33 <hackrilege> i understood it was your primary motivation
20:25:43 <hackrilege> ohh im abusing fix sorry
20:25:59 <hackrilege> recurse . fmap
20:26:00 <edwardk> hackrilege: it was mostly to show that existing combinators 'already compose that way'
20:26:07 <edwardk> :t fmap . fmap
20:26:08 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:26:22 <edwardk> :t traverse . both
20:26:23 <lambdabot>     Ambiguous occurrence ‚Äòboth‚Äô
20:26:23 <lambdabot>     It could refer to either ‚ÄòL.both‚Äô,
20:26:23 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:145:1
20:26:26 <edwardk> :t traverse . L.both
20:26:28 <lambdabot> (Traversable t, Monoid a1) => (a -> a1, a -> b) -> t a -> (a1, t b)
20:26:29 <edwardk> etc.
20:26:33 <hackrilege> lol we hit this earlier
20:26:41 <glguy> edwardk: Are the instances I added for prelude-extras:*1 could to collide with any of your packages or I can call this a super-minor version bump?
20:26:44 <edwardk> @undefine
20:26:44 <lambdabot> Undefined.
20:26:49 <edwardk> :t traverse . both
20:26:50 <lambdabot> (Applicative f, Traversable t, Data.Bitraversable.Bitraversable r) => (a -> f b) -> t (r a a) -> f (t (r b b))
20:27:02 <edwardk> glguy: lemme look
20:27:29 <edwardk> glguy: a minor bump is fine
20:27:38 <glguy> zoot
20:27:38 <hackrilege> so you just intersperse and fold with dots...
20:28:05 <edwardk> hackrilege: you use _different_ lenses each time and you don't go forever
20:28:30 <hackrilege> :t foldl (.) id $ repeat fmap
20:28:31 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ f0 a
20:28:31 <lambdabot>     Expected type: (a -> b) -> a -> b
20:28:31 <lambdabot>       Actual type: (a -> b) -> f0 a -> f0 b
20:28:33 <edwardk> foo ^.. key "n". nth 2 . _Object . traverse
20:28:42 <edwardk> that sort of thing is what happens in practice
20:28:47 <hackrilege> rrrg, how to terminate...
20:29:04 <edwardk> even when you use 'fmap' you use it on different functors typically, so the fixed point you are seeking doesn't work
20:29:05 <hackrilege> put unary function at end of recursion opperation please
20:29:56 <hackrilege> if it was i lie algebra it would need only the same functor many times...
20:30:06 <hackrilege> your welcome
20:30:25 <Axman6> @hoogle Applicative f => (a -> f b) -> [a] -> f [b]
20:30:26 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
20:30:26 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
20:30:26 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:30:28 <hackrilege> is this known?
20:30:51 <Axman6> oh that is just travserse?
20:30:55 <Axman6> hmmm
20:31:57 <hackrilege> i think its not know...
20:33:03 * hackagebot prelude-extras 0.4.0.1 - Higher order versions of Prelude classes  https://hackage.haskell.org/package/prelude-extras-0.4.0.1 (EricMertens)
20:33:25 <hackrilege> fix . fmap as a lie algebra. but i need to put a unary function at the terminus, is there no way to do this?
20:34:18 <hackrilege> something like hylo?
20:37:41 <hackrilege> :t hylo
20:37:42 <lambdabot> Not in scope: ‚Äòhylo‚Äô
20:37:47 <hackrilege> :t hilo
20:37:48 <lambdabot> Not in scope: ‚Äòhilo‚Äô
20:37:51 <hackrilege> rrg
20:38:04 <hackrilege> help?
20:39:48 <hackrilege> hylo¬†::¬†Functor¬†f => (f b -> b) -> (a -> f a) -> a -> b
20:42:58 <hackrilege> :t Data.Fix.hylo
20:43:00 <lambdabot> Not in scope: ‚ÄòData.Fix.hylo‚Äô
20:44:45 <Shockk> hello, I'm trying to configure my cabal project right now and I have a library and an executable defined in my cabal file
20:45:02 <hackrilege> ok
20:45:08 <Shockk> I'm getting an undefined reference linker error when I try and build the executable though,
20:45:20 <hackrilege> can we see the error?
20:45:27 <Shockk> yep, one moment
20:46:16 <Shockk> undefined reference to `polarzu7N3VHw207P9LxeH8SpeDlD_PolarziTypesziLenses_zdfHasStartupEngineZMZNzuzdcstartup_closure'
20:46:58 <glguy> Initial guess is that you left some modules out of exposed-modules or other-modules in yoru library
20:46:59 <Shockk> I get another error like that except for Polar.Types.Engine.defaultEngine.closure as far as I can tell
20:48:00 <Shockk> hmm, I've got Polar.Types in my exposed-modules but not Polar.Types.Engine or Polar.Types.Lenses, although I import them and export those from Polar.Types
20:48:13 <Shockk> but do I need to add those to other-modules?
20:48:13 <glguy> Every module in the library has to be listed in the cabal file
20:48:15 <glguy> yes
20:48:20 <Shockk> ahhh I see
20:49:11 <Shockk> hmm okay, is there no way to do that automatically in some way for modules imported by modules that are in the cabal file?
20:55:37 <dmwit> There isn't really tooling for that, no.
20:55:52 <Shockk> ahh, okay, thanks
20:56:15 <dmwit> I think cabal init has some analysis that can do it, but it won't do an in-place modification of your cabal file -- just replace it with a fresh one.
20:56:17 <Shockk> glad I understand how it works now, though
20:57:44 <drewbert> Does anybody else find dealing with time in haskell to be really tedious?
20:58:34 <Shockk> I haven't personally dealt with it much (not yet, soon though)
20:58:47 <dolio> I think dealing with time is tedious.
20:58:50 <c_wraith> drewbert: I find haskell's time library to be the only one that doesn't get it 100% wrong.
20:58:51 <dolio> If you do it properly.
20:59:13 <drewbert> in most cases 100% wrong is good enough
21:01:38 <dmj`> drewbert: http://two-wrongs.com/haskell-time-library-tutorial
21:02:09 <dmwit> Haskell has historically consciously chosen to avoid "quick and dirty" in favor of "robust and correct".
21:02:34 <dmwit> Even when this costs programmer and CPU time.
21:02:55 <dmwit> But I think these choices have paid off in the long-term and will continue to do so.
21:03:24 <dmwit> Because there is a hidden cost to "quick and dirty" that, when it must be paid, can be quite hefty indeed.
21:05:16 <drewbert> dmj`: thanks for the link.  Definitely nicer than reading the documentation.
21:07:21 <dmj`> drewbert: yea, I feel your pain. I store most things in UTCTime, then just use Data.Time.Clock.POSIX to go to to/from epoch
21:23:05 * hackagebot Feval 1.0.0.0 - Evaluation using F-Algebras  https://hackage.haskell.org/package/Feval-1.0.0.0 (burz)
21:27:10 <montanonic> suppose I have a .hs file with `import PACKAGE` at the top, and use 3 different functions and 1 typeclass from PACKAGE in the body
21:27:50 <montanonic> is there a method to take the functions that I'm using and automatically declare them as explicit imports from PACKAGE?
21:28:05 * hackagebot binary-orphans 0.1.0.0 - Orphan instances for binary  https://hackage.haskell.org/package/binary-orphans-0.1.0.0 (phadej)
21:28:37 <montanonic> in other words, run some program or library or ghci command, and make it so that at the top of the file I now see `import PACKAGE (func1, func2, func3, class (..))`
21:28:58 <montanonic> The idea being to make it easier to follow the good practice of declaring one's imports
21:40:53 <latermuse> yes
21:42:10 <latermuse> > import qualified Data.Text as T (pack)
21:42:11 <lambdabot>  <hint>:1:1: parse error on input ‚Äòimport‚Äô
21:42:46 <latermuse> montanonic: import PACKAGE (func1, func2)
21:43:05 * hackagebot Feval 1.0.0.1 - Evaluation using F-Algebras  https://hackage.haskell.org/package/Feval-1.0.0.1 (burz)
21:43:35 <montanonic> uh, I'm unfortunately not clear on what you mean 
21:45:25 <mauke> montanonic: I don't know of a way to do that
21:45:58 <montanonic> mauke: okay, good to know; I didn't expect there to be a solution. Thank you,
21:46:49 <drewbert> how do I direct which cabal to use for stack?
21:47:19 <drewbert> Oh wait... I'm being dumb. 
21:48:41 <pyon> What exactly is an ¬´ideal monad¬ª?
21:49:30 <dmj`> pyon: in what context?
21:50:35 <pyon> The `bound` library's documentation: ¬´We represent the target language itself as an ideal monad supplied by the user...¬ª
21:51:05 <pyon> https://hackage.haskell.org/package/bound
21:54:45 <gamegoblin> Can anyone think of any clever names for a web framework
21:54:49 <gamegoblin> need ideas
21:56:17 <pyon> dmj`: What I've noticed is that user-supplied monads only differ from free monads in the handling of bound variables. Is this what the notion of ¬´ideal monad¬ª tries to capture?
21:59:22 <banacorn> is it possible to "promote" a `String` to a type-level `Symbol` at runtime?
21:59:34 <KaneTW> no, there are no types at runtime
22:00:53 <gamegoblin> banacorn: GHC uses type erasure. types only exist at compile time.
22:01:17 <banacorn> the phase distinction is ever blurring, seems it's possible to "downgrade" a Symbol to a String at runtime, but not the other way around
22:02:33 <banacorn> basically what I want to do is, move the semantics checking part of a DSL, from runtime to compile-time
22:02:34 <dolio> You've been able to generate code based on types for a very long time. That's what type classes do.
22:02:50 <nshepperd> banacorn: you mean the GHC.TypeLits stuff?
22:03:01 <banacorn> nshepperd: yes
22:03:41 <nshepperd> banacorn: the function you're looking for is probably someSymbolVal :: String -> SomeSymbol
22:04:16 <nshepperd> SomeSymbol being here a type-level Symbol wrapped in an existential
22:04:43 <banacorn> "Convert a string into an unknown type-level symbol." what does it means by "unknown"
22:05:25 <banacorn> what can I do with it and how does it relates to the String I passed in?
22:05:29 <nshepperd> being wrapped in the existential box
22:06:09 <nshepperd> essentially, data SomeSymbol = SomeSymbol (exists n. KnownSymbol n => Proxy n)
22:06:44 <nshepperd> the only useful thing you can really do with this is unpack it and feed it into a polymorphic function
22:07:26 <banacorn> and the string n has to be decided statically at compile-time?
22:07:46 <nshepperd> no, it can be decided at runtime
22:08:21 <nshepperd> that's why it's 'unknown', because the *compiler* doesn't know what symbol n is at compile time
22:08:41 <banacorn> oh I get it!
22:08:49 <banacorn> thank you <3 <3 <3
22:09:30 <nshepperd> :)
22:09:42 <banacorn> that's a bit devastating for what I'm trying to do though :P
22:11:26 <nshepperd> in the cases that I've used this sort of thing, I had a function `foo :: (KnownSymbol n) => Proxy n -> r` that works for any symbol, and would do 'case someSymbolVal "thing" of { SomeSymbol (proxy) -> foo proxy }'
22:12:30 <banacorn> thanks, I'll give it a try
22:16:49 <nitrix> Can I use {} as the second argument of modifyIORef to modify a record?
22:17:06 <nitrix> I think I just had a genious idea :D
22:17:37 <liste> nitrix at least (\rec -> rec { foo = bar }) works
22:17:42 <mauke> inb4 lens
22:18:41 <nshepperd> when I say 'works for any symbol' though, that can include failing if the symbol isn't in some expected set, by getting the value with `symbolVal` or case matching against some known symbols with `sameSymbol`
22:27:01 <geluomi> i love haskell ,can anyone have a discuss?
22:30:52 <Axman6> geluomi: there's over 1000 people in here, many willing to discuss Haskell. but you'll have to start
22:32:39 <geluomi> i feel haskell has the ability to construct DSL,eg embed c or java?
22:32:55 <mauke> c and java are not DSLs
22:33:43 <geluomi> yeah,maybe haskell's foreign language module,achieved c import
22:34:59 <geluomi> can it achieved ruby embed
22:38:08 * hackagebot yesod-static 1.5.0.3 - Static file serving subsite for Yesod Web Framework.  https://hackage.haskell.org/package/yesod-static-1.5.0.3 (MichaelSnoyman)
22:39:26 <geluomi> what can yesod do ?the difference with rails?
22:42:14 <Lingo_> @geluomi you mean https://en.wikipedia.org/wiki/Domain-specific_language ?
22:42:15 <lambdabot> Unknown command, try @list
22:42:33 <pacak> Lingo_: Don't use @
22:43:06 <Lingo_> sorry..
22:48:08 * hackagebot polar-shader 0.1.0.0 - High-level shader compiler for Polar Game Engine  https://hackage.haskell.org/package/polar-shader-0.1.0.0 (Shockk)
22:49:37 * Arahael always wonders how the whole @ thing started.
22:50:03 <kadoban> Arahael: twitter
22:50:04 <MarcelineVQ> well, email, but if you mean to refer to people, twitter
22:50:27 <Arahael> Doens't twitter use #'s?
22:50:28 <MarcelineVQ> @ = at
22:50:40 <Arahael> MarcelineVQ: Email's @ refers to the host, not the user.
22:50:43 <MarcelineVQ> #'s are a different thing
22:50:51 <kadoban> Arahael: Both. # is for "this is the topic of my post" @ is to direct a tweet at someone in particular
22:50:56 <Arahael> I see.
22:51:19 <Arahael> Because slack uses it too, and I'm forever forgetting to apply the '@' - just seems weird.
22:53:36 <nitrix> Why does atomicModifyIORef takes a function (a -> (a,b)) instead of (a -> a) like modifyIORef ?
22:54:17 <nitrix> Is it suddently important that it doesn't evaluate to an `IO ()` to the point of making it `IO b` ?
22:55:19 <liste> that way you can yield results atomically
22:55:40 <nitrix> Oh the result is part of what's atomic?
22:55:49 <nitrix> Interesting.
22:56:31 <liste> if you modified it and then read it to yield a result it could'be been modified in-between
23:02:38 <mbrock> Arahael: slightly interesting: @ on Twitter emerged from use, only became actual feature later. Same with #
23:03:01 <Arahael> mbrock: That _is_ interesting!
23:05:38 <krack> Lol
23:08:13 * hackagebot cabal-helper 0.6.0.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.6.0.0 (DanielG)
23:18:52 <lpaste_> Lynn pasted ‚Äúdumb type hack‚Äù at http://lpaste.net/140428
23:18:59 <Lynn> i'm trying to do some evil type hackery and i don't know how to make it work ;-;
23:19:44 <Lynn> (i maybe should've put that comment starting at line 22 at the top of the paste)
23:33:36 <Axman6> geluomi: Sorry, please keep discussions in the channel. It looks like you have picked a quiet time in #haskell (the americans are asleep!)
23:35:39 <Arahael> Inconsiderate americans(!)
23:52:15 <glguy_> Lynn, those types will be ambiguous and won't work without annotations
23:52:35 <glguy_> Also ghci needs the extension separately from the file
23:54:57 <rui> My Ihaskell notebook doesn't seem to find the packages installed in the user db
23:55:08 <rui> Any ideas on how to diagnose/fix it?
23:56:15 <Arahael> rui: Isn't that still experimental?  To help debug it, I might ask you: "Whatpackages? What user db?"
23:58:00 <rui> Arahael: not sure but I had been using it slightly without much problem, until reinstalling today to try some stuff. I mean the packages in the db in ~/.ghc/x86_64
23:58:52 <Arahael> rui: Frankly, if I was running ihaskell in production, today, I'd probably keep it in a *very* carefully controlled docker image or something.
23:59:09 <Arahael> rui: Which reminds me.  It does have a docker image download available, doesn't it?  Why not keep usign that?
