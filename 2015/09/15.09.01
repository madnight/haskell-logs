00:07:39 * hackagebot language-qux 0.1.0.0 - Utilities for working with the Qux language  https://hackage.haskell.org/package/language-qux-0.1.0.0 (hjwylde)
00:07:39 * hackagebot qux 0.1.0.0 - Command line binary for working with the Qux language  https://hackage.haskell.org/package/qux-0.1.0.0 (hjwylde)
00:52:55 <makalu> is there a nub for vector anywhere?
00:56:22 <makalu> huh even sort is missing
01:29:44 <jle`> makalu: yeah, they're in a different package i guess
01:29:46 <jle`> http://hackage.haskell.org/package/vector-algorithms
01:31:15 <noodles1> I wrote short definitions for: polymorphism(in functional languages), currying, partial application, and lambda expressions. I've likely made a mistake somewhere, let me know where please? http://lpaste.net/140016
01:34:13 <Hafydd> noodles1: your first mistake is that "the ability to handle values uniformly without depending on their type" doesn't define parametric polymorphism, or indeed anything.
01:35:09 <tdammers> would be nicer if it were limited to 80 columns
01:35:44 <tdammers> anyway
01:35:53 <tdammers> Integral /= integers
01:35:55 <Hafydd> If you want to define "polymorphism," it's useful to think about what "poly" and "morph" separately mean.
01:36:05 <tdammers> ^ yes
01:36:22 <noodles1> tdammers: sorry :( my editor wraps without newline
01:37:35 <merijn> Quick question, how do I instantiate the following classes using minimal code? Functor, Applicative, Monad, Foldable, Traversable. Foldable can be done using "foldMap = foldMapDefault", Applicative using "pure = return; (<*>) = ap" (or are those the default implementations already?) can I cut out more code?
01:37:42 <tdammers> anyway; "Integral" doesn't mean "integer", it means "supporting integer division and conversion to Integer"
01:38:02 <noodles1> ok, thanks I'll work on the column polymorphism definition and Integral.
01:38:04 <edwardk> {-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}
01:38:40 <merijn> edwardk: Can't derive due to parameter appearing in wrong position
01:38:43 <edwardk> then use deriving (Functor, Foldable, Traversable)
01:38:58 <edwardk> merijn: what is the example?
01:39:01 <tdammers> :t curry -- noodles: note that it only accepts pairs, not arbitrary tuples
01:39:02 <lambdabot> ((a, b) -> c) -> a -> b -> c
01:39:05 <merijn> edwardk: i.e. it's all your fault due to "Name" from Bound screwing up my AST :p
01:39:30 <edwardk> merijn: you can work without it if you like ;)
01:40:31 <merijn> edwardk: i.e., "data Expr a = Lambda Location Type (Scope (Name a ()) Expr a", but that means manually defining the instance. And since I don't care about efficiency I want to reduce the number of times I have to match the entire AST in my code to the minimum
01:40:32 <tdammers> noodles1: c) could use some clarification in the context of Haskell; "partial application" is strictly not a thing in Haskell, because all functions are unary, so you can either provide the argument or not
01:40:40 <Hafydd> noodles1: furthermore, I don't think "lambda expression allow the definition of functions inside of any expression" is a definition of what a lambda expression is, either. That just says what they allow, but it doesn't say anything about what their syntax is.
01:41:05 <Hafydd> (And I think you can't avoid defining the syntax when talking about something as concrete as a lambda expression.)
01:41:13 <merijn> Also, you can definie functions inside expressions without lambda too
01:41:35 <merijn> > 1 + let foo x = x + 1 in foo 3
01:41:38 <lambdabot>  5
01:41:47 <merijn> No sweat
01:41:52 <noodles1> Hafydd: ok, did you see the haskell example below
01:42:01 <Hafydd> noodles1: yes, I did.
01:42:08 <merijn> noodles1: See above :)
01:42:22 <tdammers> lambda expressions are one of several ways of creating anonymous functions
01:42:41 * hackagebot json-stream 0.3.2.0 - Incremental applicative JSON parser  https://hackage.haskell.org/package/json-stream-0.3.2.0 (ondrap)
01:42:42 <Hafydd> noodles1: by the common meaning of "definition," giving one example isn't sufficient.
01:42:42 <edwardk> merijn: you're stuck with a manual instance then, yeah
01:43:10 <edwardk> merijn: you can write a one-pass 'mangle' combinator that combines traverse and (>>=) in a way
01:43:11 <tdammers> in fact, whenever you call a "n-ary" function in Haskell, you are introducing an anonymous function
01:43:14 <edwardk> then you can get most things from that
01:43:21 <edwardk> merijn: if you really want to minimize code
01:43:27 <tdammers> foo x y == (foo x) y; where (foo x) is an anonymous function
01:44:23 <tdammers> I'd start with the syntax, and define what it does
01:45:37 <Hafydd> noodles1: finally, the description of currying is perhaps a bit unclear, because you say it "results in" n functions; it's true that a sequence of n functions is obtained when you give arguments to a curried function, but that isn't part of currying. I'd say it just produces an n-order function.
01:45:53 <edwardk> you can use -- mangle :: (Applicative f, Monad t, Traversable t) =>  (a -> f (t c)) -> t a -> f (t c); -- mangle f c = join <$> traverse f c
01:46:01 <Hafydd> (Or a function of order at least n, strictly.)
01:46:10 <noodles1> tdammers: So it would be incorrect to say "sum120 (+120) is definded by the partial application of the the first parameter of the function (+)." ?
01:46:15 <edwardk> the definition there is how it defines in terms of traverse and join, but you can use it to implement both
01:46:48 <noodles1> ps, I'm not ignoring anyone, just a lot to digest and respond to at once
01:47:09 <edwardk> anyways it isn't appreciably different than writing (>>=) code wise, but gives you traverse and foldMap too
01:47:41 <edwardk> of course with the 'a's there i don't know how to read your data Expr a thing correctly as a traversable or foldable thing
01:47:44 <edwardk> so YMMV
01:47:55 <edwardk> or a monad
01:48:28 <edwardk> (due to the use of Name sharing the output 'a' type rather than a separate parameter)
01:48:37 <merijn> edwardk: The same as it would be with "Scope () Expr a", no?
01:48:38 <edwardk> with them fused i think you are stuck
01:48:51 <edwardk> merijn: except Name is a tuple
01:48:56 <edwardk> so you get stuck
01:49:36 <merijn> Then I don't really understand how you're possibly supposed to use Name if you wanna be able to find the original names again...
01:49:47 <edwardk> data Expr x a = Lambda Location Type (Scope (Name x ()) Expr a -- can be instantiated to Expr a a when you want to fix them to be the same
01:49:51 <merijn> s/don't really/really don't
01:49:53 <edwardk> but in the meantime it is a monad, etc.
01:50:07 <edwardk> er with (Expr x) in the right places
01:50:18 <edwardk> data Expr x a = Lambda Location Type (Scope (Name x ()) (Expr x) a
01:50:46 <edwardk> now it is (Functor, Foldable, Traversable, Applicative, Monad), etc.
01:50:52 <merijn> Ah, and then use "type Expr' a = Expr a a"? in the rest of the code?
01:51:03 <edwardk> hen you want to lock the type parameters down
01:51:14 <edwardk> i wouldn't say 'in the rest of the code' just when they need to match
01:51:21 <edwardk> which i think over time you'll find is less and less
01:52:11 <merijn> When I get it working I'll add a pull request to add an example to the current bound examples
01:52:21 <edwardk> more likely would be to use type Expr' = Expr Name  -- for whatever your fixed name type is
01:52:24 <tdammers> noodles1: I've found that Haskell is easiest to understand by following the formal transformation rules, i.e., substituting things for equivalent things etc.
01:52:38 <merijn> edwardk: I mostly plan to stick to String :p
01:52:42 <edwardk> hen when you have an Expr' Name you can copy them out
01:52:50 <edwardk> then fix it to string until you do something else
01:52:59 <edwardk> and if you ever change then parameterize
01:52:59 <tdammers> noodles1: stuff like, let foo x = x + 1 <=> let foo = \x -> x + 1
01:53:04 <edwardk> we 'hint' that way in ermine
01:53:51 <edwardk> merijn: but i don't bother to hint the variables
01:53:56 <edwardk> i hint the definition site
01:53:57 <edwardk> https://github.com/ekmett/ermine/blob/master/src/Ermine/Syntax/Type.hs#L231
01:54:25 <edwardk> where a Hint is basically just a Maybe Text
01:54:40 <edwardk> hinting to the pretty printer what name to show
01:55:10 <noodles1> tdammers: yes, the problem and granted it's getting better in the ~1 year since I first tried to learn haskell is theres no one book, like k&r for C. The previous example I gave is verbatim (sans typos) from a book I have
01:55:33 <merijn> Sadly my AST seems to becomes uglier and uglier over time xD
01:56:17 <edwardk> merijn: data Expr a = Lambda Location String Type (Scope () Expr a)
01:56:24 <edwardk> ^- shove the name in the Lambda itself
01:56:28 <edwardk> rather than in each occurrence
01:56:34 <ggVGc> wish I could somehoe convince my client to let me write some tools for us in haskell...
01:56:49 <edwardk> merijn: data Expr a = Lambda Location Hint Type (Scope () Expr a)
01:56:52 <ggVGc> has anyone of you managed to get to use haskell at work, without the company originaly using it_
01:56:55 <ggVGc> ?
01:57:12 <ggVGc> the technical debt of a language like haskell is unfortunately huge..
01:57:24 <merijn> edwardk: Right, but that leads me back to the original point of not being sure why Name exists at all :)
01:57:37 <edwardk> you can also factor Location out into a separate constructor if you like, e.g. https://github.com/ekmett/ermine/blob/master/src/Ermine/Syntax/Type.hs#L232 then you don't have to pay for it when you synthesize one and it has no location
01:57:50 <edwardk> name exists because a handful of people insist on writing crap that way
01:57:53 <edwardk> i still think its a bad idea
01:58:22 <merijn> edwardk: Right, so back to explicitly naming it is, then
01:58:27 <edwardk> it is a bit too generic, and a bit too awkward using it
01:58:52 <merijn> edwardk: Might wanna put a slight warning in the module, then :)
01:58:59 <edwardk> the 'string' there gives a hint, and it still leaves bound to deal with name capture
01:59:15 <merijn> Before gullible people like me think it's supposed to be used ;)
01:59:22 <edwardk> merijn: it is 2am, and i've had a long day, my crankiness right now isn't something i'm going to base big warning labels on ;)
01:59:34 <mniip> edwardk!
01:59:53 <edwardk> heya mniip
02:00:06 <quchen> edwardk!
02:00:28 <mniip> edwardk, would you care to read my article? :o
02:00:31 * edwardk looks up and sees 1450 other people in the channel and realizes this may take a while
02:00:54 <edwardk> mniip: at the moment, i'd care to read the insides of my eyelids and get some sleep before morning comes and folks drag me back to icfp
02:01:07 <quchen> for_ users \user -> print (user <> ": hello edwardk!")
02:01:09 <mniip> :(
02:01:21 <quchen> Oh, ICFP is right now?
02:01:27 <edwardk> mniip: sorry. was just realizing when talking to merijn quite how tired i am
02:01:42 <mniip> okay I understand
02:01:48 <quchen> mniip: Post it on Reddit and you'll have your proofread! :-þ
02:02:05 <srhb> Agreed. Also puts less pressure on one person. :-)
02:02:06 <merijn> edwardk: One last question, then
02:02:24 <edwardk> merijn: sure
02:02:52 <merijn> edwardk: Would you say that declartions should be done "[(String, Scope Int Expr a)]"? i.e. storing the name in a tuple with the scope of it's definition?
02:03:26 <merijn> edwardk: I used to have "[Scope (Name String Int) Expr a]", but if I ditch Name I need some way to bring back names there...
02:04:32 <mniip> quchen, I'll work on the formal proof f first
02:05:14 <edwardk> i use something like https://github.com/ekmett/ermine/blob/master/src/Ermine/Builtin/Term.hs#L75 to produce bindings where my bindings look like https://github.com/ekmett/ermine/blob/master/src/Ermine/Syntax/Term.hs#L164
02:05:32 <edwardk> then let builds a binding: https://github.com/ekmett/ermine/blob/master/src/Ermine/Syntax/Term.hs#L187
02:05:59 <quchen> I have some mutually recursive types that I'd like to annotate with a value, e.g. this one: http://lpaste.net/140018 The nice "cata :: ..." approach won't work for mutual recursion. What are my options? I've tried multiple things, but they get increasingly ugly, such as here at the bottom: http://lpaste.net/140019
02:07:21 <edwardk> so in something like https://github.com/ekmett/bound/blob/master/examples/Deriving.hs#L18  i'd probably use  Let {-# UNPACK #-} !Int [(Hint,Scope Int Exp a)] (Scope Int Exp a) -- with Hint = something like Maybe Text
02:07:30 <merijn> edwardk: Right, so that's mostly equivalent :)
02:07:47 <edwardk> yeah, except for using Maybe String instead of a String
02:08:03 <edwardk> just to make it easier for the compiler to generate them without a bunch of state about strings
02:08:18 <merijn> edwardk: I moved a list of declarations into it's own type, so my module can consist of just declarations and Let becomes "Let Decls (Scope Int Expr a)"
02:08:18 <edwardk> and since you are using them for informative reasons / pretty printing
02:08:32 <edwardk> makes sense
02:08:39 <merijn> ok, back to work, then
02:08:46 <merijn> And you should probably go to bed :p
02:10:25 <edwardk> we break binding groups up pretty quickly when we typecheck: https://github.com/ekmett/ermine/blob/master/src/Ermine/Inference/Type.hs#L163
02:10:34 <edwardk> and yeah. going there now. night =)
02:12:05 <quchen> Hah, and he *does* sleep after all.
02:12:32 <merijn> quchen: He just NOPs :)
02:12:34 <quchen> I was doubtful of his wife when she told me this happens, but I think I was proven wrong
02:12:40 <quchen> merijn: You mean he ids?
02:13:14 <merijn> quchen: Why all the extra datatypes in your initial example?
02:13:55 <quchen> merijn: It's a minimal example. Imagine all of them having multiple constructors.
02:14:28 <quchen> "I have an AST consisting of multiple mutually recursive types and I want to annotate that"
02:14:33 <quchen> That's the problem in a sentence.
02:14:51 <quchen> And I've seen a couple of solutions online, but I was wondering whether anyone here had any experience.
02:15:05 <quchen> Edward Yang's post for example is quite a helpful primer: http://blog.ezyang.com/2013/05/the-ast-typing-problem/
02:15:22 <merijn> quchen: My experience is: I tried some stuff and gave up and went with manually annotated and straightforward :p
02:15:50 <quchen> merijn: Were you able to be parametric in the annotation type? I had to throw that out for some of my attempts
02:16:15 <merijn> quchen: I have an explicit Location annotation now
02:16:26 <quchen> Hm, like GHC's L* types?
02:16:32 <merijn> No idea? :)
02:16:42 <quchen> LPat = Located Pat = SrcLoc Loc Pat
02:16:45 <quchen> Or something along those lines
02:17:25 <quchen> How do you fold your tree? Manually for each new operation?
02:17:30 <merijn> My AST nodes always carry a Loc, but it's "Undefined"
02:17:48 <merijn> quchen: Not there yet, but so far mostly using the monad instance
02:17:59 <quchen> Monad instance?
02:18:04 <quchen> Of your tree?
02:18:07 <merijn> Yeah
02:18:14 <quchen> Huh? How does that wok
02:18:35 <quchen> Is it minimal-example-able?
02:18:36 <quchen> :-)
02:18:45 <merijn> quchen: The minimal example isn't done yet :p
02:19:12 <ggole> One possibility is to construct "corresponding" trees that carry your annotation
02:19:31 <quchen> ggole: You mean building an identically shaped tree?
02:19:39 <quchen> And then looking at (data, annotations) tuples?
02:19:40 <ggole> You can use GADTs to capture the shape of the tree, which allows the dispatch to be elided
02:19:58 <ggole> I even have an example, but it is in OCaml
02:20:10 <ggole> (I'm not much of a Haskell programmer yet.)
02:20:37 <quchen> I don't know OCaml, but from what I've seen it's not that far from Haskell in terms of data representation
02:21:09 <ggole> Similar in some ways, yes
02:21:26 <ggole> https://gist.github.com/d5798470dfc1289c9aa5
02:22:17 <ggole> Bit ugly :/
02:23:26 <quchen> Hard to read for me at least. But so was Haskell when I wasn't used to the syntax.
02:23:48 <ggole> OCaml ain't pretty even after you get used to it
02:25:03 <quchen> I'll happily try to read the example anyway! :-)
02:25:22 <ggole> I'm not all that sure how it would work out in a real compiler
02:25:33 <ggole> Transforming trees in parallel might be a bit of a dog
02:25:50 <merijn> OCaml is pretty easy, just ugly :)
02:26:01 <merijn> Modules are neat, though. So I have high hopes for backpack
02:26:47 <merijn> ggole: At least as an ocaml programmer you can dive into the interesting bits quickly, since all the basics of ADTs and how to code are (mostly similar)
02:27:23 <ggole> Yeah, it's basically a variant of SML
02:27:38 <ggole> With some significant chunks of machinery bolted on that you can pretty much ignore (like objects)
02:27:38 <merijn> ggole: Although you might wanna read up on the details of lazy evaluation (https://hackhands.com/guide-lazy-evaluation-haskell/) since it changes how you write efficient code :)
02:27:50 <ggole> Oh, you meant Haskell. Right.
02:28:26 <merijn> i.e. the "naive" implementation of map "map f (x:xs) = f x : map f xs" is actually the fast/good one, instead of the tail-recursive one you'd have to write in ocaml :)
02:29:56 <ggole> There's talk of adding TRMC, so that would be the good version in OCaml as well
02:30:09 <ggole> But of course this doesn't cover all the benefits of lazy lists
02:30:16 <merijn> Is there a safe version of !! ?
02:30:25 <merijn> @hoogle Int -> [a] -> Maybe a
02:30:30 <lambdabot> Prelude (!!) :: [a] -> Int -> a
02:30:30 <lambdabot> Data.List (!!) :: [a] -> Int -> a
02:30:30 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
02:30:33 <merijn> :\
02:32:08 <mauke> listToMaybe .: drop
02:32:41 <merijn> mauke: Yeah, I already wrote that just now, just seems odd it's missing :)
02:36:45 <Albert> Hi to all, I've just installed HaskellPlatform-7.10.2-a-x86_64-setup.exe, after removed the previous. In WinGHCi i can no more load any of the previous haskell file (.hs). I try also a new one, void and with "f = 5+3" only, but the interpreter always respond with this message:  .....hs:1:1: lexical error at character '\65279'
02:38:09 <pavonia> Albert: Does you file have a BOM by chance?
02:38:40 <Albert> What means BOM? I use Notepad++ to edit hs file.
02:39:14 <pavonia> Byte order mark
02:39:24 <quchen> "Byte Order Mark". It's a special symbol designed to annoy people.
02:39:25 <srhb> It would appear that Alex barfs on BOM.
02:39:34 <pavonia> In Notepad++ you can choose between UTF-8 with or without BOM
02:40:01 <Albert> Pavonia: so what I've to do?
02:40:18 <Intolerable> save it without a BOM
02:41:13 <Albert> Intolerable: Ok, thank you
02:41:24 <srhb> Interestingly, this ticket seems to imply that BOM should simply be skipped from 7.10
02:41:25 <srhb> https://ghc.haskell.org/trac/ghc/ticket/6016
02:41:36 <srhb> Are you sure you have the right GHC version?
02:41:45 <srhb> And not some older one lying around
02:41:58 <srhb> ie try ghc --version
02:42:08 <Albert> srhb: I've the GHC 7.10.2 version
02:42:21 <srhb> Albert: Is that what ghc --version says as well?
02:42:45 <Albert> srhb: sure
02:42:55 <srhb> Okay. Maybe it only works for interpreted mode.
02:43:03 <merijn> The person that came up with UTF-8 having a byte BOM is insane
02:43:16 <Albert> GHCi, version 7.10.2: http://www.haskell.org/ghc/  :? for help
02:43:24 <srhb> merijn: Yes.
02:43:46 <srhb> Still I can understand the rationale for working around it on Windows.
02:43:57 <srhb> I'm a bit curious why it doesn't work, considering that patch.
02:45:55 <Albert> to all: problem solved, thanks to all.
02:46:21 <mikusp> Hi. I have a question about passing polymorphic functions as arguments. In Accelerate, there's a function matchPreOpenAcc, that's only ever called with two specific functions as arguments - matchOpenAcc and hashOpenAcc, as can be seen here - https://github.com/AccelerateHS/accelerate/blob/4d0754d22a5662703e4ad4c262ec9d9a1edc06a0/Data/Array/Accelerate/Analysis/Match.hs#L77 .
02:47:10 <mikusp> Why it's a type error to drop these two arguments from matchPreOpenAcc signature and simply define them in where clause, as simply matchAcc = matchOpenAcc and similarly for hashOpenAcc?
02:50:17 <pavonia> mikusp: What error do you get?
02:52:28 <mikusp> If I drop only matchAcc argument and define matchAcc :: MatchAcc acc; matchAcc = matchOpenAcc I get this: http://lpaste.net/140021
02:54:22 <mikusp> or rather this, cause the previous one was not really valid code: http://lpaste.net/140022
02:54:48 <merijn> mikusp: Are you writing type signatures in the where clause?
02:55:24 <mikusp> yes
02:55:37 <pavonia> The two accs don't match, they are not the same type
02:55:45 <merijn> mikusp: Using type variables also appearing in the top level?
02:56:15 <mikusp> exactly, I typed matchAcc as 'MatchAcc acc'
02:56:27 * merijn is betting €10 on "assumed the ScopedTypeVariables by default"
02:57:04 <abbe> Hi
02:57:22 <liste> hi
02:57:49 * hackagebot moesocks 0.1.2.0 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.2.0 (JinjingWang)
02:57:52 <merijn> mikusp: Try the following, add "{-# LANGUAGE ScopedTypeVariables #-}" at the top of the file and change the top level type signature from "foo :: Bar x y -> Baz z" to "foo :: forall x y z . Bar x y -> Bar z" (i.e. add "forall <all type varaibles> ." in front of the type signature)
02:59:23 <iElectric> is there an existing admin (CRUD) interface with persistent?
03:00:39 <mikusp> ScopedTypeVariables is already enabled. With matchAcc :: forall acc. MatchAcc acc; matchAcc = matchOpenAcc defined at the top level I get this: http://lpaste.net/140023
03:01:48 <abbe> So if I evaluate "let testfunc = return $ trace "Beginning trace" ()" on ghci, and then do "testfunc" I don't see any "Beginning trace" message. Could someone explain how this relates to laziness, thanks much.
03:02:49 * hackagebot reverse-geocoding 0.2.2.2 - Simple reverse geocoding using OpenStreeMap  https://hackage.haskell.org/package/reverse-geocoding-0.2.2.2 (jcristovao)
03:03:03 <mauke> if you don't use the result, it's not going to be evaluated
03:03:20 <mauke> I suspect you'll get different results if you change () to "hello", for example
03:03:33 <abbe> yes, I get the message in that case
03:04:12 <mauke> if your expression has type IO (), ghci will execute the IO but it won't print the result (because () is not interesting)
03:04:34 <mauke> for all other types, it will print the result
03:05:12 <abbe> okay, but what about the trace, I thought that's some built-in unsafe thing, the way it works
03:05:41 <abbe> like you can output without being in IO monad
03:05:42 <_di> its pretty safe for debug
03:06:07 <Gurkenglas> Unsafe yes, builtin no. https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Debug.Trace.html#trace
03:06:37 <abbe> okay
03:06:51 <abbe> thanks!
03:10:34 <mauke> hmm. what would change if we had trace string expr = unsafePerformIO (traceIO string) `seq` expr
03:32:34 <mikusp> merijn: do you know why it's behaving this way? For me it seems strange that function having type 'OpenAcc a s -> OpenAcc a t -> _' can be passed to a function expecting 'forall acc a s t. acc a s -> acc a t -> _'
04:17:56 * hackagebot hgrib 0.1.0.0 - Unofficial bindings for GRIB API  https://hackage.haskell.org/package/hgrib-0.1.0.0 (mjakob)
04:19:24 <mauris> why can't i sequence infinitely many random actions using MonadRandom?
04:19:46 <mauris> https://gist.github.com/ijt/1258156 <-- `sequence (replicate n die)` works
04:20:07 <mauris> but `sequence (repeat die)` will not make a stream of die rolls
04:20:27 <mauris> (i know getRandomRs exists, but i can't use it in my case)
04:22:34 <tdammers> :t replicate
04:22:35 <lambdabot> Int -> a -> [a]
04:22:40 <tdammers> :t repeat
04:22:41 <lambdabot> a -> [a]
04:22:45 <tdammers> :t sequence
04:22:46 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
04:23:09 <tdammers> note that in order to execute, sequence must get to the last element of its argument
04:23:35 <Maxdamantus> That'll probably work using something other than evalRandIO.
04:23:45 <tdammers> > sequence . map print $ [1..10]
04:23:47 <lambdabot>  <IO [()]>
04:23:51 <tdammers> > sequence . map print $ [1..]
04:23:53 <lambdabot>  <IO [()]>
04:24:02 <tdammers> hrmph, not very illustrative
04:24:21 <mauris> Maxdamantus: really? whoa. how would i test it?
04:24:28 <mauke> @src sequence
04:24:29 <lambdabot> sequence []     = return []
04:24:29 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:24:29 <lambdabot> --OR
04:24:29 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
04:24:36 <mauke> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:24:45 <mauke> can't return before the inner call to sequence finishes
04:24:59 <Gurkenglas> > evalState (sequence $ repeat $ modify (+1)) 1
04:25:01 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
04:25:48 <phaazon> hey, I just read somewhere that we can defined instances for “general cases”
04:25:51 <phaazon> like 
04:25:56 <phaazon> instance (Foo a) => Bar a where …
04:26:15 <phaazon> is it possible because of latest GHC releases?
04:26:26 <phaazon> I’ve always heard that if we do that
04:26:31 <phaazon> we can only have that instance
04:26:38 <phaazon> and we cannot write specific instances later on
04:26:51 <mauke> where did you read that?
04:27:01 <phaazon> I guess it was in JuicyPixels, wait
04:27:33 <mauke> also, that looks Undecideable
04:27:47 <mauris> anyway, on a higher level... is it "cheating" to make a infinite list of cards and throw it into my card game's state object?
04:27:52 <phaazon> http://hackage.haskell.org/package/JuicyPixels-3.2.6.1/docs/Codec-Picture-Types.html#t:ColorConvertible
04:27:55 <phaazon> look at the first instance
04:28:55 <Gurkenglas> tdammers, my example doesn't.
04:29:17 <mauris> to draw cards from it i just splitAt n and put back the rest. it feels like i'm escaping some kind of monad! but i guess i'm not, because whatever sets that list up will be in a MonadRandom.
04:29:25 <mauke> huh
04:29:58 <tdammers> Gurkenglas: that's because you're accumulating state lazily, and never use it
04:30:19 <phaazon> mauke: there’s no UndecideableInstances extension enabled
04:30:29 <phaazon> http://hackage.haskell.org/package/JuicyPixels-3.2.6.1/docs/src/Codec-Picture-Types.html
04:30:41 <phaazon> I guess that’s a new feature of GHC?
04:30:47 <Gurkenglas> tdammers, so then shouldn't the pasted code start printing rolls because the generator yielded after that infinite list is never used?
04:30:54 <phaazon> a new way to perform instances resolution?
04:30:56 <nshepperd> > evalState (sequence $ repeat $ modify (+1) >> get) 1
04:30:58 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
04:31:05 <Gurkenglas> Random is just State with an rng in the state after all
04:31:30 <nshepperd> you just have to use a lazy state type
04:32:09 <Sindriav_> Is there a stateful lens view?
04:32:25 <phaazon> Sindriav_: uses
04:32:28 <phaazon> :t uses
04:32:29 <lambdabot> (Profunctor p, MonadState s m) => Over' p (Const r) s a -> p a r -> m r
04:32:39 <Sindriav_> Huh
04:32:43 <phaazon> or use, I guess
04:32:44 <phaazon> :t use
04:32:46 <lambdabot> MonadState s m => Getting a s a -> m a
04:32:48 <phaazon> yeah.
04:33:16 <Sindriav_> Is there an operator for it?
04:33:18 <Maxdamantus> Gurkenglas: but it's getting its entropy from IO.
04:34:06 <phaazon> Sindriav_: an operator for uses?
04:34:36 <Sindriav_> Yup
04:34:42 <phaazon> I don’t think so
04:35:00 <phaazon> > evalState (uses _1 length) ("hello","world")
04:35:01 <lambdabot>  5
04:35:15 <phaazon> > evalState (use _2) ("hello","world")
04:35:17 <lambdabot>  "world"
04:35:18 <nshepperd> Maxdamantus: you don't have to use IO
04:35:20 <Maxdamantus> evalRand (sequence (repeat die)) (mkStdGen 42)
04:35:28 <Sindriav_> something like `f ^$ v = f =<< use v`
04:35:55 <Maxdamantus> That one works, because it's not run under the IO monad.
04:36:13 <Gurkenglas> Oh so it's using strict state, ok. Anyway what you want is https://hackage.haskell.org/package/MonadRandom-0.4/docs/Control-Monad-Random-Class.html#v:getRandomRs
04:36:42 <Sindriav_> The applicative MonadRandom is really nice to use
04:37:10 <mauris> well like i said earlier, i know getRandomRs exists, but i can't use it in my case
04:37:13 <Sindriav_> phaazon: it seems weird that a library with over a 100 operators would have one for this, it seems like a really common use-case O.o
04:37:29 <mauris> what Maxdamantus said looks good though
04:37:50 <Sindriav_> phaazon: "retrieve a stateful value with this lens and apply it to a function"
04:38:03 <Maxdamantus> You can get an StdGen under using `getStdGen` if you want.
04:38:03 <phaazon> yeah, that’s uses
04:38:10 <Maxdamantus> under IO*
04:38:32 <phaazon> uses apply the lens to the state to get the value, and you can pass a function around to apply afterwards
04:38:47 <phaazon> however, you can also do something like
04:39:19 <phaazon> > evalState (_2 %= (++"!")) ("hello","world")
04:39:20 <lambdabot>  ()
04:39:21 <nshepperd> you should use 'getSplit' in IO
04:39:24 <phaazon> oops :D
04:39:37 <phaazon> > execState (_2 %= (++"!")) ("hello","world")
04:39:38 <lambdabot>  ("hello","world!")
04:39:46 <phaazon> maybe you needed that, Sindriav_ 
04:39:55 <nshepperd> getSplit >>= (\gen -> .... evalRand (sequence (repeat die)) gen ...)
04:39:55 <mauris> Maxdamantus: hum, that seems to be what evalRandIO is doing https://hackage.haskell.org/package/MonadRandom-0.4/docs/src/Control-Monad-Random.html#evalRandIO
04:40:06 <phaazon> you can derive all the basic lens operators you know
04:40:14 <phaazon> like .~, %~, +~, <>~…
04:40:19 <phaazon> and change the ~ for =
04:40:19 <Sindriav_> phaazon: Well, look. "something.attr += 10" is an operator
04:40:28 <nshepperd> that way the infinite sequence is independent of future randomness calls in IO
04:40:30 <phaazon> and you have the MonadState version
04:40:40 <Sindriav_> phaazon: Why not "trace *** something.attr" ?
04:40:55 <Maxdamantus> mauris: I suspect `newStdGen` is different.
04:40:57 <Sindriav_> where *** would be the stateful view operator
04:41:07 <Maxdamantus> Hm, actually, maybe not, dunno.
04:41:24 <Sindriav_> phaazon: And don't say that's not a common thing to want to do, when you can do "+="
04:41:39 <phaazon> well, ask edwardk 
04:41:45 <phaazon> I’m not the one who wrote lens :)
04:42:00 <phaazon> and I kinda keep far away from using lens anyways
04:42:14 <Maxdamantus> Okay, it is pretty much the same .. so the original code you gave seems to do what you said it didn't.
04:42:55 <Sindriav_> phaazon: Well, for writing stateful stuff, nothing's sweeter I guess
04:43:11 <phaazon> Sindriav_: I don’t like stateful :P
04:43:12 <Sindriav_> phaazon: `modify` and record update syntax doesn't exactly add up to the most elegant code
04:43:41 <phaazon> Sindriav_: well, if you split up your code in small functions
04:43:41 <Sindriav_> phaazon: That's irrelevant. I never said anything about stateful, only that lenses are good for stateful code.
04:43:43 <phaazon> that’s actually ok
04:44:00 <phaazon> Sindriav_: well
04:44:02 <phaazon> I disagree
04:44:06 <phaazon> lens is not about stateful
04:44:13 <nshepperd> hmm, looks like evalRandIO should work for an infinite list
04:44:16 <phaazon> it’s about merging getters and setters
04:44:33 <Maxdamantus> Indeed. And it seems to work when I try it.
04:44:33 <phaazon> so that we partially modify structures without having to use record syntax
04:44:41 <Maxdamantus> Prelude Control.Monad.Random> do{ rolls <- evalRandIO $ sequence (repeat die); print rolls }
04:46:28 <tdammers> lens has a bunch of stateful operators, but they're more of a convenience thing
04:46:28 <Maxdamantus> mauris: are you looking at it through something that does line buffering or something?
04:46:53 <Maxdamantus> mauris: because the code you should be trying should never print a newline.
04:47:04 <lpaste_> mauris pasted “MonadRandom in ghci” at http://lpaste.net/140029
04:47:06 <Maxdamantus> it should just keep printing an infinite list.
04:48:07 <nshepperd> mauris: the first doesn't work because it's an infinite sequence of IO actions
04:48:17 <mauris_> ohh, evalRandIO does work, but not specifying anything hangs forever... so what is it trying to do in the first case?
04:48:22 <mauris_> ah
04:48:39 <nshepperd> which have to be executed strictly in order before producing any value
04:49:06 <nshepperd> try evalRandIO $ sequence (repeat (getRandomR (1,2)))
04:49:42 <mauris_> yeah, that does the trick
04:49:46 <mauris_> ok, thanks!
04:51:31 <Sindriav_> phaazon: Honestly, did you even read what I wrote? "lens is not about stateful" I have *never* said that
04:52:26 <Sindriav_> phaazon: All I said was "when doing stateful computations, lenses are useful"
04:52:49 <Sindriav_> phaazon: Do notation is also useful for stateful computations, yet "do notation is not about stateful"
04:55:09 <phaazon> ok Sindriav_ :)
05:03:02 * hackagebot language-qux 0.1.0.1 - Utilities for working with the Qux language  https://hackage.haskell.org/package/language-qux-0.1.0.1 (hjwylde)
05:08:03 * hackagebot language-qux 0.1.1.0 - Utilities for working with the Qux language  https://hackage.haskell.org/package/language-qux-0.1.1.0 (hjwylde)
05:13:03 * hackagebot quickwebapp 2.1.1.0 - A quick webapp generator for any file processing tool  https://hackage.haskell.org/package/quickwebapp-2.1.1.0 (jtanguy)
05:29:23 <the_2nd> does (x1:x2:xs) match the two element case?
05:29:33 <merijn> the_2nd: 2 and more
05:29:54 <the_2nd> merijn, wanted to make sure, that xs can be non-existant
05:29:59 <merijn> > let (x1:x2:xs) = [1,2] in (x1, x2, xs)
05:30:01 <lambdabot>  (1,2,[])
05:30:02 <the_2nd> *e
05:30:20 <merijn> the_2nd: xs can't be non-existent, but a two element list is "1:(2:[])"
05:31:16 <the_2nd> merijn, thanks
05:39:36 <the_2nd> http://pastebin.com/BpKAEWPc
05:39:44 <the_2nd> I get a wrong intendation error here
05:39:46 <the_2nd> no idea why
05:40:09 <the_2nd> on the second data line
05:40:14 <the_2nd> so the first with a comma in front
05:41:38 <merijn> the_2nd: Needs to be indentd further than the 'z' in zahn
05:41:55 <merijn> the_2nd: For details I recommend reading: https://en.wikibooks.org/wiki/Haskell/Indentation
05:42:14 <the_2nd> merijn, easy fix, thanks
05:42:25 <the_2nd> so its not a "one tab more"
05:42:31 <the_2nd> but actually behind it?
05:42:44 <merijn> the_2nd: The whitespace algorithm is pretty simple, but some corner cases are intuitive
05:43:06 <merijn> the_2nd: I recommend reading the wikibook, it explains the algorithm and then you should never be confused by layout again :)
05:43:16 <the_2nd> sure, will do
05:48:07 * hackagebot smallcheck-series 0.5.1 - Extra SmallCheck series and utilities  https://hackage.haskell.org/package/smallcheck-series-0.5.1 (jdnavarro)
05:48:23 <RageYL> i would like to have some advices: i'm trying to create a program that colorize ls output. what's the way you would do that ? i've created a data 'Component' containing all part (date, size, name, permissions...). i use parsec to get a [Component] and then i apply a function that take a component en return a String. is that a good way ?
05:48:47 <srhb> That sounds like a great way, yes. :)
05:48:54 <bz> ls
05:49:04 <mauke> parsing ls output sounds like a bad idea, though
05:49:08 <srhb> Agreed. 
05:49:17 <srhb> Well, mostly Really Damn Hard. :-)
05:49:40 <RageYL> yep i know, but i have a python script that parse ls and work exactly how i want for 2 years now ;) so it's ok for my need ;)
05:49:49 <RageYL> and here it's just a way to practice haskell ;)
05:50:13 <merijn> RageYL: Program design wise it sounds fine to me
05:50:35 <srhb> Implementing ls would probably be way easier. :-)
05:50:41 <RageYL> :D
05:54:44 <the_2nd> has anyone used blaze html?
06:02:00 <quchen> Yes, I know someone who has.
06:02:28 <the_2nd> I can do H.ul "something"
06:02:41 <the_2nd> how can I have H.ul ["a", "b", ...]
06:02:48 <the_2nd> Tried map etc. without success
06:03:18 <mauke> is that monadic? if so, mapM_
06:03:19 <slack1256> maybe mapM
06:04:20 <Intolerable> try sequence
06:04:35 <quchen> <ul> can't contain data, you need <li> on the inside
06:07:25 <the_2nd> mapM_ worked
06:08:00 <slack1256> @type mapM
06:08:01 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
06:13:05 <Gurkenglas> Does some library provide something like "unify :: Type -> Type -> Type"?
06:13:48 <merijn> Gurkenglas: Probably not as that tends to be a bit specific for your definition of Type
06:14:44 <Gurkenglas> The types as defined for Hask aren't specific enough?
06:15:12 <merijn> Gurkenglas: Well, what is "Type" in that signature?
06:16:34 <Gurkenglas> Something isomorphic to all the things that don't lead to a parse error when written to the right of "::"?
06:16:49 <merijn> Gurkenglas: In Haskell?
06:17:12 <Gurkenglas> That's not implied by "Hask"?
06:18:07 <merijn> Gurkenglas: If you say "unify :: Type -> Type -> Type" I start thinking of implementing unification for your own typechecker. When you say "in Hask" I have no clue what you want/expect this function to do?
06:18:16 <orbifx> hey merijn, did you get my paste the other day?
06:18:27 <merijn> orbifx: Yes, no, maybe? :)
06:18:29 <Gurkenglas> How about "unify :: Hask -> Hask -> Hask" :D?
06:19:26 <Axman6> fix (join unify)
06:20:08 <orbifx> merijn: http://lpaste.net/1670829852527165440
06:20:47 <merijn> orbifx: All the uses of fromJust/head make me sad :(
06:20:52 <orbifx> merijn: part of this: https://github.com/orbifx/hacronyms/blob/master/src/main.hs
06:21:25 <orbifx> merijn: it was my intend, obviously :P
06:21:56 <orbifx> how can I do it better?
06:22:56 <Gurkenglas> But yes, this conversation clarified what I want. Is there some library that concerns itself with the Hask category?
06:24:30 <orbifx> merijn: how can I do it better?
06:26:37 <Axman6> orbifx: pattern matching is almost always better
06:27:40 <orbifx> Axman6: example of using pattern matchin for Maybe values?
06:27:58 <Axman6> case mx of Just x -> ... Nothing -> ... :\
06:29:25 <Axman6> > unwords ""
06:29:26 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
06:29:26 <lambdabot>      Expected type: [String]
06:29:26 <lambdabot>        Actual type: [Char]
06:29:53 <Axman6> > unwords []
06:29:55 <lambdabot>  ""
06:31:45 <lpaste_> merijn annotated “Capitalise” with “Capitalise (annotation)” at http://lpaste.net/1670829852527165440#a140032
06:31:59 <merijn> orbifx: You can clean it up a lot more still
06:32:10 <merijn> orbifx: But this is the quickest refactor I can come up with
06:32:16 <merijn> Axman6: Needs more pattern guards :p
06:32:19 <Axman6> yeah it's very hard to follow
06:32:22 <lpaste_> Gurkenglas annotated “Capitalise” with “Dangit I was ninja'd” at http://lpaste.net/1670829852527165440#a140033
06:32:40 <merijn> Gurkenglas: Also needs more pattern guards!
06:32:44 <mitu> My program behaves unexpectedly when I run it with "cabal run" but running the binary produced by "cabal install" has no surprises. Are there any common gotchas between these modes of running haskell programs? Any good place to start debugging?
06:34:39 <orbifx> merijn: yeah and I prefer guards
06:35:28 <merijn> orbifx: "x == []" is a pretty bad pattern, btw
06:35:42 <merijn> orbifx: It's better to use "null" or pattern matching
06:35:57 <merijn> Because "x == []" only works for list that have Eq elements
06:36:03 <merijn> @define data Foo = Foo | Bar
06:36:05 <lambdabot>  Defined.
06:36:44 <orbifx> I did, lpaster brought it up too, but it there was ambigiouty between Prelude and another module.. Learned my lesson for next time, but had to push it and wrap this miny project. 
06:36:56 <merijn> > let foo x | x == [] = "Whoo!"; foo _ = "Boo!" in foo [1]
06:36:58 <lambdabot>  "Boo!"
06:37:04 <merijn> > let foo x | x == [] = "Whoo!"; foo _ = "Boo!" in foo []
06:37:06 <lambdabot>  "Whoo!"
06:37:14 <merijn> > let foo x | x == [] = "Whoo!"; foo _ = "Boo!" in foo ([] :: [Foo])
06:37:15 <lambdabot>      No instance for (Eq Foo) arising from a use of ‘foo’
06:37:15 <lambdabot>      In the expression: foo ([] :: [Foo])
06:37:15 <lambdabot>      In the expression:
06:37:28 <merijn> > let foo x | null x = "Whoo!"; foo _ = "Boo!" in foo ([] :: [Foo])
06:37:31 <lambdabot>  "Whoo!"
06:40:40 <orbifx> thanks merijn 
06:49:53 <quchen> "null x" is also not a good guard.
06:50:11 <quchen> When you want to handle other cases, use pattern matching.
06:50:29 <quchen> You will not get exhaustiveness checks for guarding with null.
06:51:21 <quchen> map f xs | null xs = xs | otherwise = f (head xs) : map f (tail xs) -- don't do this, neither parts nor as a whole
06:52:07 <quchen> orbifx: ^
06:52:25 <Intolerable> (also don't compare the length of lists)
06:52:49 <StoneToad> but! it's such an awesome way to make your program slower!
06:53:22 <Intolerable> > if length (repeat 5) > length [1] then "yay!" else "rip"
06:53:27 <lambdabot>  mueval: ExitFailure 1
06:54:32 <quchen> > let sameLength (x:xs) (y:ys) = sameLength xs ys; sameLength [] [] = True; sameLength _ _ = False in sameLength (repeat 1) [3]
06:54:34 <lambdabot>  False
06:55:01 <Intolerable> i think i have longerThan and shorterThan defined somewhere
06:55:28 <clrnd> just overload __gt__
06:56:00 <Intolerable> is there a Length newtype somewhere
06:56:04 <Axman6> excuse me?
06:56:07 <Intolerable> w/ Ord / Eq instances?
06:56:15 <quchen> What would that type be for?
06:56:20 <Axman6> overload? eye gouging underscores? D:
06:56:45 <Intolerable> Length (repeat 5) > Length [5]
06:56:49 <Intolerable> do that kind of thing
06:57:04 <Axman6> oh cool, that's handeh!
06:57:12 <peti> How can I make Emacs' haskell-mode use "stack-repl" in Stack projects? "haskell-process-type" is set to "auto", but that doesn't seem to work well.
06:57:23 <quchen> Intolerable: It's basically a specialized version of lazy nats
06:57:30 <quchen> I don't think it exists in that form
06:57:32 <clrnd> Intolerable, I'd use that
06:57:50 <clrnd> with instances for containers and stuff
06:58:15 * hackagebot json-stream 0.3.2.1 - Incremental applicative JSON parser  https://hackage.haskell.org/package/json-stream-0.3.2.1 (ondrap)
06:58:30 <Intolerable> would it be Length a = [a] or Length = forall a. [a] though
07:06:33 <quchen> I don't think that type would be very useful in a standard library.
07:06:56 <quchen> I certainly don't need it much, and it is in the middle between Haskell lists and dependently typed vectors.
07:07:00 <Gurkenglas> When should null be used?
07:07:06 <quchen> filter null
07:07:09 <quchen> Stuff like that.
07:07:15 <quchen> Or not null, better.
07:07:52 <quchen> It's in the same corner as head/tail/... Not as bad, but most of the time to be avoided.
07:08:19 <Gurkenglas> When should null be used when not null isn't handier?
07:08:19 <fractalsea> Does anyone know why an exception in one thread may cause other threads in the program to hang (the program does not except with an exception from the main thread)?
07:08:36 <Gurkenglas> *and/where... "when" didn't fit there
07:09:26 <quchen> fractalsea: Exceptions thrown in other threads leave the main thread (and other threads) unaffected, but terminate the thread in which it was thrown. When that thread should fill an MVar some other thread waits for, your program might hang.
07:09:39 <Intolerable> fractalsea: because the other threads are waiting for something that the main thread can no longer ever provide?
07:09:48 <quchen> The async library is almost always preferrable to direct threading with forkIO.
07:09:59 <quchen> For example, it handles exceptions properly.
07:10:43 <merijn> quchen: Well, you might WANT exceptions to only kill their own thread :)
07:11:03 <quchen> merijn: Async allows ignoring exceptions as well, but you have to make it explicit.
07:11:43 <fractalsea> thank you
07:12:11 <fractalsea> quchen: The thread that crashes only reads from MVars though. Could that still cause other threads to hang?
07:12:31 <quchen> fractalsea: Sure. A full MVar that is never read from blocks other threads that attempt to write to it.
07:12:43 <fractalsea> quchen: thanks for the async library suggestion
07:12:52 <quchen> putMVar m "hello" >> putMVar m "world" -- hangs if nobody reads m
07:13:22 <fractalsea> quchen: Ah interesting. I never realised that
07:13:34 <Axman6> that's the entire reason MVars exist =)
07:13:37 <quchen> fractalsea: Marlow's book is excellent, I suggest you give it a read
07:13:51 <quchen> fractalsea: It covers this, and many other concurrency solutions
07:14:11 <quchen> But the Async documentation is also fairly good so you can just tinker around with it
07:14:17 <Axman6> yeah, can't recommend that book highly enough. so easy to read and incredibly clear, while still giving quite deep details on implementation of primitives
07:14:33 <fractalsea> quechen: sounds great
07:14:38 <quchen> Marlow is *full* of tiny details that would be very hard to figure out yourself
07:14:56 <quchen> And it's very well written, so you don't need to be an expert
07:15:05 <quchen> Can't praise it enough, I was very pleasantly surprised by it!
07:15:06 <fractalsea> suits me  then :)
07:18:11 <nkaretnikov`> is there a way to install old-time without touching mingw/cygwin?
07:18:16 <StoneToad> lastlog marlow
07:18:20 <StoneToad> woops
07:18:37 <StoneToad> quchen: what is the title of that book?
07:18:44 <quchen> StoneToad: Marlow is JaffaCake on IRC, but I don't think he's been in this channel lately.
07:18:56 <quchen> ?google marlow book
07:18:58 <lambdabot> https://en.wikipedia.org/wiki/Heart_of_Darkness
07:19:02 <quchen> Hm.
07:19:03 <Intolerable> Parallel and Concurrent Programming in Haskell
07:19:09 <StoneToad> wrong marlow, lol
07:19:24 <quchen> ?google marlow haskell book
07:19:25 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
07:19:25 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
07:19:27 <clrnd> great PSX game too
07:19:28 <quchen> Better
07:19:37 <StoneToad> ohh you can read it online
07:19:40 <quchen> Yes! :-)
07:20:03 <quchen> I'm not sure how planned that was, on release he said "it'll be online for roughly a month after release and then I don't know"
07:20:22 <StoneToad> oreilly seems to be fairly generous with their books
07:20:38 <StoneToad> well, I'm sure I'm not the only one that tends to buy hardcopies if I reference the book much
07:21:06 <quchen> Nope. Got the book within an arm's reach as well :-)
07:21:25 <StoneToad> and they don't run out of batteries when you're waiting for your oil to get changed, heh
07:22:48 <nkaretnikov`> so is it possible to install a library that uses a configure script without cygwin/mingw?
07:25:26 <sshine`> nkaretnikov`, sounds hard.
07:26:05 <sshine`> hiptobecubic, reminds me of the Pulp Fiction scene; "Don't be... [square]."
07:39:12 <juanpaucar> Does anybody know if there's something like aeson but for XML
07:39:22 <obadz> re 1HaskellADay, in "You have Functor-instance R a, declared R (a,a,a)", what does "declared R (a,a,a)" mean?
07:39:24 <juanpaucar> i know there's that for YAML
07:40:49 <quchen> obadz: It's unusual terminology. I would guess it means that you have "newtype R a = R (a,a,a)" and a Functor instance for that.
07:40:49 <bergmark> juanpaucar: we use hxt picklers for xml serialization
07:41:17 <bergmark> juanpaucar: http://hackage.haskell.org/package/hxt-pickle-utils http://hackage.haskell.org/package/generic-xmlpickler
07:41:35 <obadz> quchen: do you mean newtype or do you mean data?
07:41:49 <quchen> obadz: Doesn't really matter here.
07:41:53 <juanpaucar> bergmark: I have that for a XML file, but i wanted to omit all those instances for the signature of an XML
07:42:17 <juanpaucar> so i have a `a XmlTree XmlTree` and i want to append it to the record i have instaces for
07:42:26 <quchen> obadz: If you're unfamiliar with "newtype" then this might be a primer: https://github.com/quchen/articles/blob/master/fbut.md#data-newtype-type
07:42:30 <juanpaucar> for i would be way easier if there would be somehting like aeson
07:42:42 <obadz> quchen: R is essentially just a homogenous 3-tuple?
07:42:53 <quchen> Yes.
07:43:05 <quchen> You can write fmap :: (a -> b) -> (a,a,a) -> (b,b,b).
07:43:07 <Gurkenglas> Who else wants findId f = find f . Identity?
07:43:22 <quchen> That won't typecheck.
07:43:44 <Gurkenglas> :t \f -> find f . Identity -- Sure does
07:43:46 <lambdabot> (a -> Bool) -> a -> Maybe a
07:44:16 <obadz> quchen: thx
07:44:20 <quchen> Oh, I missed the parameter.
07:44:23 <quchen> Apologies.
07:44:50 <quchen> No, I didn't miss the parameter, I missed find being generalized now.
07:45:13 <quchen> Now that I understand that, no, I do not want findId.
07:48:02 <quchen> Maybe as "toMaybe". But even then it's a very small function.
07:48:18 * hackagebot couch-simple 0.0.1.0 - A modern, lightweight, complete client for CouchDB  https://hackage.haskell.org/package/couch-simple-0.0.1.0 (mdorman)
07:53:09 <Gurkenglas> Well of course it shouldn't have that name. I'm bad at naming.
07:53:19 * hackagebot json-stream 0.3.2.2 - Incremental applicative JSON parser  https://hackage.haskell.org/package/json-stream-0.3.2.2 (ondrap)
07:55:55 <supki> :t \f -> maybe empty pure . find f . Identity
07:55:57 <lambdabot> Alternative f => (a -> Bool) -> a -> f a
07:56:00 <supki> I want this
07:58:20 <ph88> can anyone tell me why i run this i get an exception saying "negative exponent" ?  http://pastebin.com/RQGMLG5k
07:59:04 <ph88> hhmm strange after i removed the import all was fine
07:59:13 <ph88> i guess that forced some recompiling
08:00:48 <ph88> question about the same code (http://pastebin.com/RQGMLG5k) i was trying to make the haskell version of this code http://pastebin.com/ePQBHEzw haskell version returns 558720.2 C version returns 18720 where did i make a mistake ?
08:02:11 <merijn> ph88: C version is truncating by casting to int, haskell is not
08:02:43 <clrnd> ph88, I see some casting (int) in the C version, are you sre that doesn't change some semantics? The haskell version uses `div`
08:03:52 <merijn> Oh
08:03:53 <merijn> Duh
08:03:58 <merijn> There's a far more crucial error
08:04:22 <merijn> "for (int i = 0; i < 8; i++)" vs "sum . map f [1..8]"
08:04:27 <clrnd> oh yeah
08:04:36 <merijn> Should be [1..7]
08:05:35 <geekosaur> 0..7?
08:05:45 <merijn> geekosaur: No, original loop has "int i = 1"
08:05:49 <geekosaur> oh, you typed wrong here
08:05:51 <merijn> But I was lazy and didn't check :)
08:06:07 <geekosaur> yeh, I looked at your copy here and only after checked the paste
08:08:21 * hackagebot resolve-trivial-conflicts 0.3.1 - Remove trivial conflict markers in a git repository  https://hackage.haskell.org/package/resolve-trivial-conflicts-0.3.1 (EyalLotem)
08:08:43 <ph88> oh ok that makes sense
08:08:43 <ph88> thx
08:10:10 <ph88> now its 558720.2 for haskell and 558720 for C
08:10:20 <merijn> See my first remark about casting to int
08:10:42 <obadz> https://twitter.com/obadzz/status/638727671673933824 <= is there a better way?
08:11:18 <ph88> merijn: when i change `div` to / i get http://pastebin.com/EZ6SkAy6
08:12:03 <merijn> ph88: C casts the result of "pow" to int, you do not
08:12:14 <ph88> so the `div` was good ?
08:13:21 * hackagebot resolve-trivial-conflicts 0.3.1.1 - Remove trivial conflict markers in a git repository  https://hackage.haskell.org/package/resolve-trivial-conflicts-0.3.1.1 (EyalLotem)
08:13:24 <merijn> Yeah, but you need to truncate the result of ^^
08:13:41 <merijn> Ugh...parsers doesn't have a way to get the position in the source text :\
08:13:41 <ph88> toInteger ?
08:13:47 <merijn> :t truncate
08:13:49 <lambdabot> (Integral b, RealFrac a) => a -> b
08:13:56 <merijn> > truncate 2.50988
08:13:59 <lambdabot>  2
08:14:18 <ph88> does that do coercien too ?
08:23:50 <the_2nd> how can I parse a "VAL1 : 12.3 \n VAL2 : 13.3" file into some sort of map? where map["VAL1"] == 12.3 map["NOT_EXISTING"] = Nothing
08:24:50 <clrnd> the_2nd, there are several ways, ranging from super hacky and weak to a streaming parallel parser
08:25:29 <zipper> Hello
08:25:40 <Intolerable> hello
08:25:41 <clrnd> lines will give you "VALx : n" for an easy example https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-String.html#v:lines
08:25:43 <the_2nd> clrnd, the input comes from me, so currently I can assume that it's 100% fine
08:25:52 <Intolerable> use yaml
08:26:00 <Intolerable> if it all looks like that, it's a valid YAML file
08:26:14 <zipper> So I have a server with 1G RAM and 24G HDD. When I try installing ghc via stack I get the error: "Cannot write: No space left on device"
08:26:21 <zipper> at the unpacking ghc stage
08:26:30 <zipper> "unpacking ghc" stage
08:27:05 <zipper> Why would unpacking ghc take up lots of space then when I check disk space after this has failed I found that no space has been used
08:27:17 <mauke> check both df -h and df -i
08:27:30 <geekosaur> unpacking to a /tmp in tmpfs, and it cleans up after?
08:27:35 <clrnd> the_2nd, then you can split the [Char] at " : ", like in python, all this folding over a Map String Float
08:28:06 <zipper> mauke: Both show that I have space
08:28:31 <the_2nd> clrnd, is there some dictionary class or something similar? or how to provide access later on?
08:28:44 <zipper> geekosaur: Like this for example: `/usr/bin/tar: ghc-7.10.2/docs/users_guide/ghc.mk: Cannot write: No space left on device`
08:28:47 <clrnd> the_2nd, yeah, https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map.html
08:28:58 <Intolerable> the_2nd: just use decodeFile from yaml
08:29:00 <Intolerable> @hackage yaml
08:29:01 <lambdabot> http://hackage.haskell.org/package/yaml
08:29:14 <geekosaur> yes, I don't see what filesystem it's writing to there, just a relative path from the tarball
08:29:29 <Intolerable> decodeFile filename :: IO (Maybe (Map Text Int))
08:29:31 <Intolerable> should work
08:29:39 <zipper> geekosaur: I'm doing everything in my ~/
08:29:44 <geekosaur> what is the free space in /tmp and /usr/tmp (they may be separate filesystems) and is either one tmpfs?
08:29:46 <jle`> is there an implementation of hindley milner with polymorphic type constructors like Identity, Maybe, []?
08:29:47 <zipper> geekosaur: I haven't created any partitions
08:29:51 <jle`> that i can look at
08:30:02 <clrnd> > let m = M.fromList [("VAL1", 12.5), ("VAL2", 4.5)] in M.lookup "VAL1" m
08:30:04 <lambdabot>  Just 12.5
08:30:10 <clrnd> the_2nd, ^
08:30:37 <clrnd> oh lol, the yaml solution seems easy too :P
08:30:56 <zipper> geekosaur: My df -h output http://lpaste.net/2573573983202967552
08:31:11 <geekosaur> right, /tmp is tmpfs
08:31:15 <geekosaur> and separate
08:31:24 <geekosaur> and ~ 500M
08:31:28 <geekosaur> except it's tmpfs
08:31:32 <zipper> geekosaur: So that's the issue. I should uh increase it
08:31:33 <Intolerable> i mean if it's all in the correct format, why write something that just duplicates it
08:31:46 <geekosaur> which means the actual size is approximately that of available swap space
08:31:48 <Intolerable> aeson already has a FromJSON a => Map Text a instance
08:31:53 <the_2nd> Intolerable, clrnd examples for yaml usage?
08:31:59 <Intolerable> decodeFile filename :: IO (Maybe (Map Text Int))
08:32:13 <zipper> geekosaur: I have a number of those tmpfs partitions it seems
08:32:17 <geekosaur> yes
08:32:21 <Intolerable> if it's a string and not a file, just use decode string :: Maybe (Map Text Int)
08:32:41 <zipper> geekosaur: Should I uh increase swap? Make them one? 
08:32:49 <geekosaur> most of them, it makes sense. /tmp, I almost always make a real partition for it because tmpfs is asking for trouble
08:33:15 <clrnd> geekosaur, stack should have an options to specify where to store temp files, maybe
08:33:54 <geekosaur> sensible programs obey $TMPDIR. I don;t know if stack does
08:33:56 <zipper> geekosaur: So the issue is that my /tmp is in a partition called tmpfs and that keeps failing on me?
08:34:23 <geekosaur> well, the main problem is that it's a separate small partition. the tmpfs part just means it's hard to figure out how much space is *actually* available in it
08:34:34 <geekosaur> because it depends on how much memory + swap is in use
08:35:02 <zipper> geekosaur: I have 1G and 250MB swap.
08:35:03 <geekosaur> (tmpfs basically is a "ram"disk based out of your memory+swap)
08:35:23 <geekosaur> 250M swap seems rather low
08:35:26 <zipper> I mean 256MB swap
08:35:46 <zipper> So what I'm running out of is swap
08:35:54 <geekosaur> https://wiki.archlinux.org/index.php/Tmpfs if you want the details
08:36:01 <geekosaur> yes
08:36:12 <geekosaur> and you'll probably run out later too when you try to link stuff...
08:36:24 <zipper> I guess the reason they chose /tmp to be RAM is because it hardly ever gets rebooted.
08:36:49 <geekosaur> well, tmpfs is faster if you have the memory available
08:37:01 <geekosaur> since it's a smart ramdisk, essentially
08:37:03 <zipper> I definitely do not. :)
08:37:18 <zipper> geekosaur: I guess the better question is how to make this use a /tmp on my disk?
08:37:25 <lpaste_> Pr pasted “Simple haskell list length” at http://lpaste.net/1308843085333004288
08:38:32 <lpaste_> Pro9 pasted “list length problem, expects Integer, actual type Int” at http://lpaste.net/3684241633911504896
08:38:48 <xandaros> Is there a name for "type constructors"? (Int, Maybe, Either, Bool, etc)
08:38:57 <srhb> Pro9: Check the type of length
08:39:03 <Ankhers> :t length
08:39:05 <lambdabot> Foldable t => t a -> Int
08:39:05 <geekosaur> how to do it "properly" depends on the distribution. create a disk partition for it, mkswap the partition, edit /etc/fstab to point swap to that partition, reboot, hope there isn't some magic somewhere overriding (apparently systemd likes to do that).
08:39:15 <srhb> Ankhers: Relevant bit here is Int, not Integer
08:39:25 <clrnd> Pro9, fromIntegral
08:39:38 <Ankhers> srhb: I know. It isn't my question. I was just showing the type.
08:39:56 <srhb> Sorry, I misnamed :P
08:40:04 <Ankhers> srhb: No worries.
08:40:26 <ReinH> xandaros: "type constructor" is a name
08:40:36 <xandaros> alright, thanks
08:40:43 <xandaros> was hoping for a single word :D
08:40:51 <ReinH> "type"
08:41:12 <xandaros> unfortunately I am going to use that for a full type (ala Int -> [Maybe Boo])
08:41:49 <Pro9> Ahha, I get an int from the length fucntion.. that was a little silly, and I thought there was some issue with the list being int's when they should be integers
08:41:59 <Ankhers> I believe `Just' and `Nothing' are the type constructors. While `Maybe' is the type.
08:42:08 <Ankhers> Or am I wrong?
08:42:15 <Pro9> But thanks for helping me out
08:42:34 <xandaros> They are constructors, yes, but I do mean "Maybe", which is used to construct a type (instead of a value)
08:42:38 <clrnd> glad I could help
08:42:40 <srhb> Pro9: If you use lengt and actually need Integer, you're going to have a bad time. :-)
08:42:43 <srhb> That would be one long list...
08:43:19 <Pro9> srhb: true :)
08:43:30 <Intolerable> https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Lazy.html#v:length
08:43:41 <Intolerable> not quite integer
08:44:12 <srhb> :t genericLength
08:44:13 <lambdabot> Num i => [a] -> i
08:44:14 <srhb> If really needed
08:44:30 <Intolerable> i was about to ask if there was a [a] -> Int64 function
08:44:38 <Intolerable> but of course there is it's genericLength
08:44:42 <srhb> :)
08:44:52 <Intolerable> :t (,) genericLength length
08:44:54 <lambdabot> (Num i, Foldable t) => ([a] -> i, t a1 -> Int)
08:45:15 <srhb> It's more generic in one way and less in another!
08:45:18 <srhb> What more can you ask for.
08:45:19 <clrnd> ha!
08:45:20 <srhb> >_>
08:45:25 <Intolerable> hmmm
08:45:31 <clrnd> :t genericGenericLenght
08:45:33 <lambdabot> Not in scope: ‘genericGenericLenght’
08:45:42 <Ankhers> @pl \x -> (genericLength x, length x)
08:45:42 <lambdabot> liftM2 (,) genericLength length
08:45:47 <TheCrafter> Is there a way to create zip,rar or 7zip archives in haskell?
08:46:10 <Intolerable> :t reallyGenericLength
08:46:12 <lambdabot> Not in scope: ‘reallyGenericLength’
08:46:28 <Intolerable> @hackage zip-archive
08:46:28 <lambdabot> http://hackage.haskell.org/package/zip-archive
08:47:36 <TheCrafter> Intolerable, thanks. I feel stupid I miseed that -.- I should've searched better.
08:48:12 <clrnd> @let genericGenericLenght = foldr (\x y -> y + 1) 0
08:48:14 <lambdabot>  Defined.
08:48:23 <clrnd> :t genericGenericLenght
08:48:24 * hackagebot stackage-sandbox 0.1.6 - Work with shared stackage sandboxes  https://hackage.haskell.org/package/stackage-sandbox-0.1.6 (DanBurton)
08:48:26 <lambdabot> (Num b, Foldable t) => t a -> b
08:48:26 * hackagebot Folly 0.1.5.0 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.1.5.0 (dillonhuff)
08:48:35 <TheCrafter> :t genericLength
08:48:37 <lambdabot> Num i => [a] -> i
08:48:46 <Intolerable> > reallyGenericLenght [1,2,3] :: Float
08:48:48 <lambdabot>  Not in scope: ‘reallyGenericLenght’
08:48:54 <Intolerable> > genericGenericLenght [1,2,3] :: Float
08:48:57 <lambdabot>  3.0
08:49:13 <Intolerable> really handy for when i want the square root of a list
08:49:50 <clrnd> > genericGenericLenght (M.fromList [(1, "a"),(2,"b")]) :: Int
08:49:53 <lambdabot>  2
08:50:01 <Ankhers> @let showLenght = length . show
08:50:04 <lambdabot>  Defined.
08:50:13 <zipper> geekosaur: Using arch :)
08:50:22 * clrnd should get back to work
08:50:25 <Intolerable> @let reallyGenericLength = foldr (const (+1) 0
08:50:25 <lambdabot>  Parse failed: Parse error: EOF
08:50:32 <Intolerable> @let reallyGenericLength = foldr (const (+1)) 0
08:50:35 <geekosaur> ok you want to read that wiki page I pointed to, then. special attention to the remark about systemd
08:50:35 <lambdabot>  Defined.
08:51:01 <Intolerable> @let reallyGenericLength = foldr (const (+1)) 0; reallyGenericLength :: (Foldable t, Integral b) => t a -> b
08:51:02 <lambdabot>  .L.hs:155:1:
08:51:02 <lambdabot>      Multiple declarations of ‘reallyGenericLength’
08:51:02 <lambdabot>      Declared at: .L.hs:154:1
08:51:07 <Intolerable> @undefine
08:51:07 <lambdabot> Undefined.
08:51:09 <Ankhers> > showLenght [1,2,3]
08:51:10 <Intolerable> @let reallyGenericLength = foldr (const (+1)) 0; reallyGenericLength :: (Foldable t, Integral b) => t a -> b
08:51:11 <lambdabot>  Not in scope: ‘showLenght’
08:51:12 <lambdabot>  Defined.
08:51:23 <Intolerable> > reallyGenericLength [1,2,3,4]
08:51:27 <lambdabot>  4
08:51:36 <Ankhers> > showLenght [1,2,3]
08:51:38 <lambdabot>  Not in scope: ‘showLenght’
08:51:44 <Intolerable> (i undefined it)
08:51:50 <Ankhers> @let showLenght = length . show
08:51:53 <lambdabot>  Defined.
08:51:55 <Ankhers> > showLenght [1,2,3]
08:51:57 <lambdabot>  7
08:52:18 <zipper> geekosaur: WOW this is painful.
08:53:03 <Jello_Raptor> Is there's any notion of monad transformers with multiple children? something like "FooT m mt" that threads the base monad and the child monad transformer through the computation in different ways?  
08:54:34 <clrnd> hopefully no
08:56:31 <merijn> Jello_Raptor: I don't see how that could possibly make sense?
08:57:39 <zipper> geekosaur: Doesn't seem to be the swap per se. I increaed it to 10G and it still failed with that disk full issue.
08:58:25 * hackagebot Folly 0.1.5.1 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.1.5.1 (dillonhuff)
08:58:27 * hackagebot Folly 0.1.5.2 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.1.5.2 (dillonhuff)
08:59:25 <lamefun> > reallyGenericLength (replicate 600 1) :: Word8
08:59:27 <lambdabot>  88
08:59:33 <the_2nd> thoughts on https://github.com/I3ck/H2D ?
08:59:41 <zipper> geekosaur: Setting TMPDIR has allowed it to build.
08:59:48 <lamefun> not generic...
08:59:52 <zipper> However the underlying issue remains
09:00:19 <Intolerable> we need to go to superReallyGenericLength
09:00:29 <Intolerable> php naming schemes ft
09:00:30 <Intolerable> *ftw
09:01:26 <xandaros> wouldn't that be super_really_extra_generic_length, though?
09:01:45 <Intolerable> no, superReally_extra_RealgenericLength
09:02:16 <Intolerable> and it would be (Foldable t, Integral b) => t a -> c -> b
09:02:46 <Intolerable> (the c does nothing unless a is Int)
09:05:43 <xandaros> acme-php is doing this stuff pretty well
09:06:00 <Intolerable> data Bool = TRUE | FALSE | FILE_NOT_FOUND
09:06:02 <quchen> PHP it would be super_reallyGeneric_length, and take [Int] as argument.
09:06:29 <Intolerable> and if you pass it a specific but still finite sequence it never terminates
09:07:04 <quchen> And it would map to String.
09:11:07 <Jello_Raptor> merijn: basically I've got a heavily modified ListT, and I want to thread state through it in a few different ways. 
09:13:50 <the_2nd> is there any way to allow upper case for constant names?
09:13:56 <geekosaur> no
09:14:04 <glguy> kind of...
09:14:21 <glguy> PatternSynonyms get used for that
09:14:44 <geekosaur> well. you can declare them as types and then provide a Storable instance, if it's a constant intended for C / FFI use
09:14:45 <glguy> handy when you're dealing with C FFI
09:16:03 <glguy> Random example: http://hackage.haskell.org/package/gl-0.7.7/docs/src/Graphics-GL-Ext-AMD-BlendMinmaxFactor.html#GL_FACTOR_MAX_AMD
09:16:17 <seanparsons> wired.com writing about Haskell...
09:16:23 <the_2nd> glguy, thing is I want to use the same names as in the norm
09:16:30 * seanparsons reads the story and walks away.
09:16:31 <the_2nd> and theres a, a_d, A_d ....
09:17:22 <lamefun> @let x !+ y = if maxBound - x >= y then x + y else error "integer overflow"
09:17:23 <lambdabot>  Defined.
09:17:32 <lamefun> > 200 + 80 :: Word8
09:17:34 <lambdabot>  24
09:17:38 <lamefun> > 200 !+ 80 :: Word8
09:17:40 <lambdabot>  *Exception: integer overflow
09:18:05 <Intolerable> > 200 !+ (-80) :: Word8
09:18:07 <lambdabot>  *Exception: integer overflow
09:26:40 <fr33domlover> is there a version of !! that returns a Maybe instead of throwing?
09:26:48 <fr33domlover> (if not, why?)
09:26:53 <merijn> fr33domlover: For list?
09:26:58 <Intolerable> because indexing a list is slow
09:26:59 <merijn> fr33domlover: No, but it's easy to make
09:27:11 <merijn> fr33domlover: "listToMaybe . drop i"
09:27:13 <fr33domlover> Intolerable, what would you use then?
09:27:21 <Intolerable> vector / array
09:27:31 <Intolerable> lists are not very good if you're doing random access
09:27:48 <Intolerable> since you have to go all the way down the list to find what you want
09:27:57 <fr33domlover> Intolerable, yeah i know that :P but my lists are small so I went for the simple approach
09:28:10 <Intolerable> fair enough
09:28:16 <fr33domlover> (list of memos left for IRC users... cant go big)
09:28:18 <Intolerable> i'd just define a !? then
09:29:35 <lpaste_> Pro9 pasted “How to use a variable that changes in a recursive if clause” at http://lpaste.net/3672894274480898048
09:31:02 <glguy> Pro9: You can use:   let t = testcases !! (l-1) in theRestOfYourExpressionHere
09:32:15 <Pro9> glguy: Thanks, worked great (y)
09:32:48 <fr33domlover> Intolerable, merijn, thanks
09:37:57 <athan> Hi everyone. Is there a benchmark organization library, like tasty is for tests? Or is this a bad idea?
09:38:28 <Peaker> athan: criterion has benchmark groupings I think
09:39:06 <AaronFriel_> There are a number of articles on the net about implementing free monads, free applicatives in the case of parsing, and implementing interpreters, and they often allude to the potential performance win of compiling these parsers. But I can't find a single article about actually taking a free (monad/applicative) parser graph and compiling it.
09:39:19 <athan> Peaker: Ahh okay, thank you!
09:39:48 <bitemyapp> athan: that's about all there is. Not as many packages on Hackage use criterion as you'd think.
09:39:58 <merijn> AaronFriel_: The performance gain from Free is when interpreting the AST directly
09:40:17 <merijn> AaronFriel_: If you compiling to some other format (LLVM, other IR, machine code) it offers no benefit
09:40:24 <Peaker> I'd really like an Applicative parser framework that actually compiles the grammar to an efficient table representation
09:40:31 <Peaker> (efficient DFA)
09:41:32 <AaronFriel_> merijn: I'm referring to what Peaker is. We can optimize the AST and this is referred to, but many articles refer to running the free parser as an interpreter and then allude to potentially compiling it
09:42:06 <Peaker> AaronFriel_: it doesn't necessarily have to use the free applicative - but it has to be at least similar
09:42:19 <athan> hmm. Thanks bitemyapp
09:42:44 <bitemyapp> athan: mostly because programmers are lazy wastrels.
09:42:49 <bitemyapp> but I repeat myself :P
09:43:02 <phadej> Peaker: PEG parsers have that property
09:43:31 <merijn> What's a good name for a parser for types (since "type" is a reserved keyword)?
09:43:57 <bitemyapp> athan: to be fair, I'm kinda bad about this. I don't use benchmarks as a regression preventative but typically when I'm ricing something (cf. Blacktip)
09:44:04 <Intolerable> type_
09:44:05 <AaronFriel_> Peaker: Right, it doesn't have to be applicative, but that's a pretty good base to start from (applicative+alternative)
09:44:13 <bitemyapp> merijn: pype
09:44:22 <Intolerable> tipe
09:44:32 <bitemyapp> merijn: tarser
09:44:34 <AaronFriel_> typduit
09:44:41 <AaronFriel_> condype
09:44:48 <phadej> Peaker: i was once pointed to https://hackage.haskell.org/package/frisby-0.2
09:44:50 <AaronFriel_> Machype
09:44:51 <bitemyapp> merijn: tarsier: https://upload.wikimedia.org/wikipedia/commons/7/7e/Bohol_Tarsier.jpg
09:44:55 <bitemyapp> merijn: pikachu
09:44:56 <Intolerable> skype
09:46:56 <AaronFriel_> So is there any lit out there on compiling parsers?
09:47:17 <AaronFriel_> I found the Peggy library, not quite what I want but it might be a good place to start
09:48:46 <joehillen> Quote from my coworker: "haskell is complex because programming truly is complex, not because it loves obscure jargon"
10:00:42 <WeaponX> @pl swipeBoardLeft gameState = map swipeRowLeft gameState
10:00:42 <lambdabot> swipeBoardLeft = map swipeRowLeft
10:08:51 <ski> merijn : `pType'
10:09:04 <ski> merijn : or `typ'
10:10:55 <athan> Where does cabal-install usually put executables for Benchmarks, when compiled (with --enable-benchmarks) in a sandbox?
10:12:19 <Peaker> athan: dist/build/bench-name/bench-name I presume?
10:12:25 <athan> hm
10:13:19 <phadej> athan: AFAIK cabal doesn't install them anywhere
10:13:27 <phadej> for your package, they live in dist/
10:13:34 * hackagebot shake-language-c 0.8.1 - Utilities for cross-compiling with Shake  https://hackage.haskell.org/package/shake-language-c-0.8.1 (StefanKersten)
10:19:53 <ForeignKeys> anyone know how to use cabal with the latest OS X El Capitan beta?
10:20:03 <ForeignKeys> running into this issue: https://github.com/haskell/cabal/issues/2653
10:20:04 * merijn sighs
10:20:22 <merijn> Futzing with grammars is so annoying
10:21:55 <phadej> ForeignKeys: short story: use 7.10
10:22:53 <phadej> ah, weren't fast enough :(
10:24:38 <schell> how do i enable linked source in my hackage docs?
10:26:05 <phadej> schell: you have to upload the docs manually
10:26:07 <glguy> schell: Do you mean in your local haddock docs or do you mean in the automatically built hackage docs?
10:26:41 <schell> phadej,glguy: i guess i mean in my local haddock, since i have to upload manually! :) 
10:27:02 <glguy> schell: If you're uploading to hackage you can use my script: it has the flags all set up
10:27:04 <glguy> https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
10:27:06 <phadej> schell: locally you should just have recent enough haddock (i.e. latest)
10:27:27 <glguy> Oh, you mean the fancy new source
10:27:30 <schell> okay, cool, then i guess i’m covered - i updated haddock last night
10:27:49 <glguy> You had to use a slightly different flag
10:27:54 <schell> glguy: yeah - looks like it has a solarized light theme and all functions are linked
10:28:02 <glguy> --haddock-option=--hyperlinked-source or something
10:28:05 <schell> i wish vim would do that for me too :)
10:28:07 <glguy> so that haddock does it instead of cabal
10:28:22 <schell> great! thanks!
10:31:25 <phaazon> hey
10:31:32 <phaazon> I’d like to use a cabal flag to make implementation vary
10:31:48 <phaazon> I guess I have to use CPP, #if / #else / #endif and cpp-options, right?
10:31:57 <phaazon> I pass -DTHE_DEFINE to cpp-options
10:32:06 <phaazon> but it sounds like it’s not taken into account
10:32:20 <glguy> schell: --hyperlinked-source (I missed the -ed prefix before)
10:32:33 <phaazon> cabal configure -f the-flag
10:32:44 <schell> glguy: ahhhh - that’s what i’m doing wrong
10:34:25 <glguy> schell: and the git repository has at number of packages contained within it, so you have to make sure to install all of them
10:34:46 <glguy> or you'll get what I got the first time which was a haddock binary without the new functionality
10:35:17 <AaronFriel> So, I'll repeat what I said earlier: There are a lot of articles about the benefits of free monad and applicatives, and producing interpreters for such.  
10:35:48 <phaazon> or I guess I need to put the manual: True statement
10:36:23 <AaronFriel> What is the literature on producing *compilers*, or taking say, a parser produced from free applicatives and optimizing it and *not* using an interpreter, but compiling it. 
10:36:30 <phaazon> yeah, that was that…
10:37:27 <Adeon> should C debugging info be available if I compile C code from cabal with -g
10:37:41 <Adeon> despite me doing so, gdb shows no names for a stacktrace even though I crash in C code
10:37:55 <AaronFriel> I get that a free applicative parser lets me inspect consecutive states, and I believe it would let me create a graph of parsing states and optimize that, but is there any lit on producing something that gets rid of the interpreter machinery?
10:39:19 <ReinH> AaronFriel: what would you compile it into?
10:39:46 <AaronFriel> So, let's take a simple parser that reads an input stream and outputs an output stream
10:40:29 <AaronFriel> Really dumb example: an HTML parser that reads and emits the identity. It reads (one or more) characters, and emits a "Token HtmlTokenizationState [characters]"
10:41:01 <AaronFriel> If it always reads in and emits the identity (and the applicative is expressive enough to state this is the case)
10:41:16 <AaronFriel> Then we can optimize this to the identity
10:42:11 <AaronFriel> "htmlParser :: ByteString -> Bytestring; htmlParser = id". 
10:42:31 <AaronFriel> I'm assuming that at the end we collapse all tokens down to their stored "output" stream
10:42:48 <phaazon> is there a way to know the current scope through CPP or TemplateHaskell to print debug information?
10:43:11 <phaazon> traceStack?
10:44:05 <AaronFriel> ReinH: So now we can imagine we have a parser that layers on top of this parser, it parsers a stream of tokens. This parser *is not* the identity parser, but when it encounters certain streams of tokens, it emits a *different* output. And again, the free applicative is expressive enough to differentiate a read-and-emit-identity from a read-and-emit-substitution
10:44:07 <codedmart> I am trying to install xmonad on Ubuntu 15.04 with cabal. I get this error http://lpaste.net/140045
10:44:10 <codedmart> Any ideas?
10:44:44 <AaronFriel> ReinH: So now, we have a directed graph of computational states, but we can simplify the *complex* HTML tokenization state to a minimal set of states, e.g.:
10:45:56 <AaronFriel> htmlParserSubstitutingHref = takeWhile1 (/= something) ... check if we need to substitute and `mappend` that ... and recurse 
10:46:26 <AaronFriel> ReinH: In particular, I'm interested in producing the minimal DFA for parsers-of-parsers
10:47:19 <phaazon> hm, location :: Q Loc
10:47:21 <phaazon> I guess I need that
10:47:22 <AaronFriel> ReinH: And if that turns out to be the identity, or simply reading in and leaving unchanged a number of bytes, then I'd like to compile that to Haskell that performs the equivalent operation without interpretation
10:48:13 <bitemyapp> codedmart: http://unix.stackexchange.com/questions/146402/configure-error-c-compiler-cannot-create-executables
10:49:25 <glguy> schell: I've updated the script to use fancier source when you have it: http://git.io/vGwHx
10:50:03 <AaronFriel> ReinH: does that make sense? I want to compile streaming parsers which may have complex state machines to minimal DFAs, because "takeWhile1" is much faster than "satisfy *> satisfy *> ..."
10:50:42 <schell> glguy: thanks, that helps a lot :)
10:53:02 <schell> glguy: now that i’m browsing the lens repo - how do you get the hackage version pic in the readme?
10:53:26 <schell> glguy: nvm! i found it
10:53:29 <schell> seems pretty easy
10:54:18 <codedmart> bitemyapp: I am not sure how that helps yet, Thanks!
10:55:05 <geekosaur> codedmart, without seeing the config.log nobody can do anything but guess
10:56:17 <landaire> this is a question that's been asked quite a bit but I can't seem to find an answer. running ghc-mod spits out "/Library/Frameworks/GHC.framework/Versions/7.8.3-x86_64/usr/lib/ghc-7.8.3/settings: openFile: does not exist (No such file or directory)" while 7.10.2 is the installed version. I installed via haskell platform
10:57:36 <crobbins> landaire, ghc-mod might be looking for `ghc` in the PATH
10:58:44 <landaire> crobbins: if the `ghc` in my path (/usr/bin/ghc) is 7.10.2 then there shouldn't be any issue right?
10:59:53 <crobbins> landaire, maybe try: ghc --print-libdir
10:59:54 <landaire> I'm fairly certain I nuked my entire haskell platform install and reinstalled everything
10:59:59 <codedmart> geekosaur: Maybe I am dumb but I can't seem to find a config.log :|
11:00:10 <crobbins> landaire, i always install ghc-mod in its own sandbox
11:02:58 <geekosaur> oh, it cleaned up after itself, you'll need to "cabal get X11", go into the unpacked source dir, and "cabal install" (with no package name)
11:05:22 <landaire> crobbins: hmm. well ghc --print-libdir prints out the correct version as well. i'm new to the language so maybe I took an incorrect turn when upgrading
11:06:03 <SK0> Is there a zipWith-like function for Vector whose result === the length of the longest vector?
11:06:08 <crobbins> landaire, you can also try `ghc-mod debug`
11:06:26 <crobbins> might give you some clues as to what is going on
11:07:07 <SK0> whose result's length*
11:07:56 <Peaker> What's an efficient way to walk a ByteString byte by byte and advance some state machine? drop 1 repeatedly?
11:08:09 <Peaker> or unpack the ByteString constructor and use the foreign ptr underneath and advance that?
11:08:11 <landaire> crobbins hah, nothing. might just try nuking it /really/ hard again
11:08:20 <geekosaur> SK0, what does it give to the zipping function when the shorter ones run out?
11:08:35 <Peaker> or BS.foldl' ?
11:08:39 * hackagebot tiempo 0.0.1.1 - Specify time intervals in different units (secs, mins, hours, etc.)  https://hackage.haskell.org/package/tiempo-0.0.1.1 (RomanGonzalez)
11:09:12 <SK0> geeko, the values of the longer array
11:09:52 <SK0> instead of [] xs = [], it would be [] xs = xs
11:12:36 <SK0> or, for (*) pad shorter one with 1's, and for (+) pad with 0's
11:12:42 <Peaker> Hmm.. I can't use ByteString's standard folds because I want to be able to terminate the foldl' :(
11:13:24 <landaire> crobbins I think it may be a botched install. running "strings `which ghc-mod` | grep /Library" shows that the 7.8.3 path is hardcoded into the binary
11:13:39 * hackagebot varying 0.1.2.0 - Automaton based varying values, event streams and tweening.  https://hackage.haskell.org/package/varying-0.1.2.0 (SchellScivally)
11:13:40 <SK0> I was doing some audio programming and changed [] to Vector, so now need to change a couple of functions
11:15:09 <schell> glguy: you help worked! thanks :)
11:18:39 * hackagebot subhask 0.1.1.0 - Type safe interface for programming in subcategories of Hask  https://hackage.haskell.org/package/subhask-0.1.1.0 (MikeIzbicki)
11:28:40 * hackagebot nagios-check 0.3.2 - Package for writing monitoring plugins  https://hackage.haskell.org/package/nagios-check-0.3.2 (fractalcat)
11:36:33 <pie_> any social network software written in haskell?
11:38:22 <narrative> Haskell is being used at facebook.
11:38:34 <pie_> *open source social networking software
11:42:15 <Ankhers> pie_: Haskellers is written in Haskell
11:42:30 <Ankhers> I don't know if you consider that "social networking software" though.
11:43:08 * pie_ checks it out
11:43:38 <capybara> pie_: There is yesod for web apps 
11:43:42 * hackagebot opaleye 0.4.1.0 - An SQL-generating DSL targeting PostgreSQL  https://hackage.haskell.org/package/opaleye-0.4.1.0 (tomjaguarpaw)
11:43:44 * hackagebot pontarius-xmpp 0.4.3 - An XMPP client library  https://hackage.haskell.org/package/pontarius-xmpp-0.4.3 (PhilippBalzarek)
11:43:47 <pie_> im thinking or running a small private social network and since im interested in haskell but dont know any yet i thought id ask
11:49:04 <athan> Can someone remind me how to pass-through options through cabal-install, while invoking a command with `cabal exec foo` or `cabal bench` ?
11:50:26 <bitemyapp> athan: which options?
11:50:59 <athan> bitemyapp: something like `cabal bench --opts="--output profile.html"`
11:51:19 <athan> to send options to the executable with Main
11:52:11 <athan> for instance, `cabal exec foo --opts="--output foo.html"` would be similar to `foo --output foo.html` if `foo` were in the PATH
11:53:31 <bitemyapp> athan: could build the bench target and run it with the arguments
11:53:40 <bitemyapp> athan: also --PROG-option=OPT / --PROG-options=OPTS
11:54:30 <athan> bitemyapp: I don't know where to find the executable, pretty sure cabal obfuscates `Benchmark`s
11:54:38 <athan> but I'll try the latter
12:06:35 * ankitk slaps lambdabot around a bit with a large fishbot
12:07:29 <ankitk> hi, I am doing a course in Functional Programming and have to implement a Project in Haskell, any ideas ?
12:10:18 <doomlord> convert LLVM IR to C source
12:10:54 <L8D> ankitk: write a LISP interpreter
12:10:58 <clrnd> ankitk, a fibonacci function
12:11:10 <clrnd> we are so original, fuck yeah
12:11:17 <ankitk> :)
12:11:52 <ankitk> I have already read and implemented lisp interpreter from the book, (48 hours)
12:12:15 <hodapp> ankitk: did you do Write Yourself a Scheme in 48 Hours?
12:12:27 <ankitk> yeah done that already
12:12:40 <ankitk> was looking for something new to implement, probably some EDSL
12:12:48 <clrnd> ankitk, do it again, with non strict semantics now
12:14:10 <ankitk> clrnd you mean to say implement it as lazy lisp interpreter ?
12:14:33 <clrnd> ankitk, yeah why not, SICP follows that excersice
12:15:08 <ankitk> ok, haven't read SICP yet, but seems like a good idea
12:15:20 <athan> What's a good way to generate random data for benchmarks? Something like quickcheck, maybe?
12:15:31 <ankitk> what will be the effort required ? I have 2 months from now to complete the project
12:15:42 <hodapp> clrnd: SICP does a lazy Lisp interpreter?
12:16:29 <clrnd> hodapp, https://mitpress.mit.edu/sicp/full-text/book/book-Z-H-27.html#%_sec_4.2
12:16:42 <hodapp> neat!
12:16:50 <hodapp> this book's been on my list to read for awhile
12:16:51 <clrnd> it's very simple though
12:18:46 * hackagebot clafer 0.4.1 - Compiles Clafer models to other formats: Alloy, JavaScript, JSON, HTML, Dot.  https://hackage.haskell.org/package/clafer-0.4.1 (mantkiew)
12:19:15 <ankitk> clrnd nice, do you have any more such ideas, which may not be implemented already ?
12:23:10 <clrnd> ankitk, ehm ..... no
12:23:33 <clrnd> :P
12:24:01 <ankitk> :) ok cool, will try this out, Thanks :)
12:24:14 <clrnd> a brainfuck interpreter
12:24:22 <clrnd> with optimizations
12:24:27 <clrnd> with an LLVM backend
12:24:39 <ankitk> brainf done, but no optimizations
12:24:45 <ankitk> what optimizations ?
12:24:58 <ankitk> ohk
12:26:23 <clrnd> ankitk, all of them :D
12:26:44 <ankitk> clrnd but wouldn't that become a C++ project ?
12:26:45 <clrnd> sorry I'm not a good computer scientist
12:27:02 <clrnd> ankitk, oh no! haskell is super nice for this
12:27:32 <ankitk> I where can I learn more about LLVM backend implementation in haskell ?
12:27:36 <ankitk> clrnd
12:28:04 <clrnd> ankitk, http://www.stephendiehl.com/llvm/#chapter-1-introduction
12:28:14 <clrnd> that's some freakin' good guide
12:28:35 <ankitk> Thanks clrnd :)
12:28:47 * hackagebot claferIG 0.4.1 - claferIG is an interactive tool that generates instances of Clafer models.  https://hackage.haskell.org/package/claferIG-0.4.1 (mantkiew)
12:28:49 * hackagebot yesod-bootstrap 0.2 - Bootstrap widgets for yesod  https://hackage.haskell.org/package/yesod-bootstrap-0.2 (andrewthad)
12:38:48 * hackagebot claferwiki 0.4.1 - A wiki-based IDE for literate modeling with Clafer  https://hackage.haskell.org/package/claferwiki-0.4.1 (mantkiew)
12:38:50 * hackagebot GPipe-GLFW 1.0 - GLFW OpenGL context creation for GPipe  https://hackage.haskell.org/package/GPipe-GLFW-1.0 (plredmond)
12:38:52 * hackagebot haste-compiler 0.5.1.0 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.1.0 (AntonEkblad)
12:47:25 <nitrix> Is <- really called "draw from" ?
12:48:03 <nitrix> I always considered it closely related to >>=, and named it "bind".
12:49:27 <opqdonut> nitrix: in my head I call it "gets" or something like that
12:52:04 <MarcelineVQ> you can call it draw from in comprehensions, and bind in do, if you want a distinction
12:58:50 <lingxiao> hey all
12:59:04 <lingxiao> suppose I have a program that's taking a long time torun in one instance of ghci
12:59:13 <danharaj> :t unionWith
12:59:15 <lambdabot>     Not in scope: ‘unionWith’
12:59:15 <lambdabot>     Perhaps you meant one of these:
12:59:15 <lambdabot>       ‘IM.unionWith’ (imported from Data.IntMap),
12:59:19 <lingxiao> does closing the terminal tab kill all processes?
12:59:33 <lingxiao> because it seems liek it's not doing that ...
12:59:49 <danharaj> :t Data.Map.unionWith
12:59:50 <lambdabot> Ord k => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
12:59:51 <MarcelineVQ> depends how they're opened, what OS are you on?
12:59:58 <kadoban> lingxiao: It depends on what terminal-ish thing you're using probably? Usually it will.
13:00:31 <lingxiao> I have a mac
13:00:50 <lingxiao> so how would I stop a program without closing teh terminal?
13:01:02 <MarcelineVQ> idk in mac
13:01:14 <kadoban> lingxiao: Should be just ctrl+c I'd think.
13:01:26 <MarcelineVQ> if you're within ghci you can use ctrl+c or ctrl+d
13:01:38 <kadoban> lingxiao: Also … don't run things in ghci, by the way. IIUC ghci basically runs with no optimizations at all, so it could perform terribly.
13:01:39 <MarcelineVQ> but if it's frozen that's not going to work
13:01:56 <geekosaur> control-c
13:02:06 <lingxiao> oh I see .. so I should compile it into an executable first?
13:02:20 <MarcelineVQ> ghci will run things you type in it with no optimization, but it uses comiled modules and iirc it compiles files you load into it
13:02:20 <kadoban> lingxiao: Yes
13:02:31 <lingxiao> MarcelineVQ I think that's what happend here .. why is that the case though?
13:02:31 <MarcelineVQ> *compiled
13:02:50 <geekosaur> it compiles to unoptimized bytecode
13:02:52 <MarcelineVQ> lingxiao: you are probably trying to compute something infinite
13:02:55 <kadoban> Does it compile with optimizations though or anything? I don't think so
13:03:08 <ralu> hello i am doing lib for accessing FPGA registers. And now i am writing bunch of functions that has prototype of Handler -> IO a. What would be better monad since each function takes same handler
13:03:14 <lingxiao> MarcelineVQ no it's a really long list, 100 000 000 items
13:03:28 <geekosaur> it can call into compiled modules but what you feed it as source is compiled unoptimized to bytecode, which has a not very smart interpreter
13:03:31 <lingxiao> and i closed the window almost immeidately 
13:05:11 <mniip> woohoo
13:05:14 <mniip> formal proof done
13:05:35 <MarcelineVQ> I'm guessing in this case that closing a window will only kill a program that will listen, and since it's locked up you'll have to tell the OS to close it instead, using another terminal or your system's process manager
13:05:43 <clrnd> mniip, bet your axioms are inconsistent
13:06:12 <lingxiao> MarcelineVQ hmm i see thanks
13:06:14 <geekosaur> closing a window sends SIGHUP to everything running within it, that should normally be sufficient
13:06:49 <MarcelineVQ> I've had similair cases where ghci runs after I close the window but not consistently enough for me to be able to say why
13:08:30 <geekosaur> ps -fu$USER | grep ghc
13:09:18 <ShadowVixen> :)
13:10:01 <nkaretnikov> so glad that minghc exists, seems to work perfectly!
13:10:07 <mniip> clrnd, aw
13:12:10 <Gurkenglas> Why isn't there a command to compile and run immediately, not even bothering to keep a compiled file? I find myself alternating between the compile command and the run command when doing quick tests
13:12:42 <kadoban> Gurkenglas: 'runhaskell' ?
13:12:44 <MarcelineVQ> runghc ?
13:13:03 <Gurkenglas> That's with optimizations? Nevermind my last line then :D
13:13:09 <geekosaur> that doesn't really compile in that sense
13:13:23 <MarcelineVQ> you could make a shellscript that does it tho
13:13:24 <clrnd> stack run?
13:13:47 <geekosaur> btu then, most other compiled languages also don't provide such a thing. closest I can think of is ctcr which did that for C... after essentially inserting a printf() on every source line
13:14:42 <Gurkenglas> Why not? It sounds trivial to implement and cuts the needed guitime down to half
13:15:14 <Ankhers> halive
13:15:24 <ChristianS> "trivial to implement" <- famous last words
13:15:29 <Ankhers> https://github.com/lukexi/halive
13:15:54 <geekosaur> it's easy enough to do just that, but then the scope creeps as you realize that that bug needs you to be able to get at the compiled form...
13:16:47 <Ankhers> I haven't used halive myself, but sounds interesting.
13:18:42 <athan> Anyone here use Arbitrary for benchmark data generation?
13:20:09 <codedmart> geekosaur bitemyapp Here is the error I get after `cabal get X11` `cabal install` http://lpaste.net/140060
13:20:11 <bitemyapp> athan: sounds noisy.
13:20:47 <Ankhers> athan: I'm not sure if that is really a good idea. The point of a benchmark is to do the exact same thing to measure different things. If you aren't doing it on the exact same data, you will get different metrics.
13:20:55 <athan> bitemyapp: Meh, I could use the perspective
13:21:01 <Ankhers> I use 'thing' too much.
13:21:16 <codedmart> Looks like maybe my nix stuff is messing with it.
13:21:28 <athan> Ankhers: I agree, I think it might help to have multiple tests of _nearly_ the same stuff though
13:21:46 <athan> idk
13:21:50 <athan> I'm going for it
13:21:56 <bitemyapp> athan: no, just make some test data and use that.
13:21:57 <Ankhers> If they are for benchmarks, I could explicitly create the different tests that are _nearly_ the same.
13:21:58 <athan> maybe I can make some good graphs for ADTs, too
13:22:07 <geekosaur> codedmart: "/home/bmartin/.nix-profile/bin/ld: this linker was not configured to use sysroots"
13:22:22 <Ankhers> Using QuickCheck to verify an algorithm is great.
13:22:36 <codedmart> geekosaur: Yeah I have some stuff installed with nix. Obviously need to handle that. Thanks!
13:22:39 <geekosaur> but I also see you're using nix, so you may need to get help from the nix folks
13:23:40 <mniip> into the reddit it goed!
13:23:41 <mniip> goes*
13:23:44 <codedmart> geekosaur: Thanks again!
13:23:54 <geekosaur> might just have to swap the nix stuff out of the way if you aren't using nix-pkgs for this
13:24:00 <geekosaur> (presumably a PATH change)
13:24:58 <codedmart> geekosaur: Yeah, but really I just need to change what I have installed with nix. I am using a config I use with OSX, but since I am doing this on linux I can remove/uninstall some of those packages.
13:25:00 * mniip shamelessly advertises https://www.reddit.com/r/haskell/comments/3j9j66
13:27:51 <clrnd> mniip, congrats, looks promising
13:27:56 <clrnd> :)
13:27:58 <mada> Upvoted because #haskell
13:28:19 <bitemyapp> mniip: looks exciting :)
13:28:43 <mada> Article looks interesting, thanks for sharing mniip 
13:30:03 <clrnd> mniip, what about space usage?
13:30:17 <mniip> same, O(M+N)
13:30:23 <mniip> everything is shared
13:30:51 <mniip> well, you know, GHC closures are huge, so there's quite a bit of a coefficient
13:31:02 <mniip> but the asymptotic is good
13:32:56 <athan> bitemyapp: If I were able to keep track of which variables were changed, we could get much more interactive graphs for the performance of a function depending on /all/ the variables of the size of data computed on
13:35:46 <TheCrafter> I have a problem with cabal sandboxes. When I install a package in a sandbox it gets installed in the sand box AND ALSO globally in my .cabal (I use Windows). Any ideas what's going on?
13:45:08 <cocreature> TheCrafter: are you installing a binary?
13:47:00 <TheCrafter> cocreature, no I am installing directory package
13:47:20 <mniip> bitemyapp, mada clrnd any commenrts on the article?
13:47:35 <cocreature> TheCrafter: what exactly makes you think that it's installing globally aka which file in .cabal?
13:47:56 <cocreature> global packages are installed into ~/.ghc not into ~/.cabal
13:49:23 <mada> mniip: will read it in a few and give you a noobster's perspective. Sorry, got caught up in something else.
13:50:09 <TheCrafter> cocreature, at some point I deleted everything except my source (including sandbox and everything generated). When I run again "cabal init" I forgot creating a sandbox and/or installing the dependencies.
13:50:25 <TheCrafter> But my project compiled without errors.
13:50:35 <Ankhers> `cabal init' won't install anything.
13:51:07 <TheCrafter> Ankhers, I know. That's the problem. The dependecies where already there.
13:51:08 <Ankhers> I believe it just creates a foo.cabal file for you.
13:51:15 <TheCrafter> Yeah and the Setup.hs
13:51:42 <cocreature> maybe they were installed from something else? I can hardly imagine that installing into a sandbox also installs it globally
13:52:02 <cocreature> ah no the directory package is packaged with ghc
13:52:22 <TheCrafter> the directory package is just an example. Same thing happened with less commong packages
13:52:37 <cocreature> so it's nearly always installed globally
13:52:42 <TheCrafter> like this http://hackage.haskell.org/package/argparser
13:53:03 <cocreature> ghc-pkg list allows you to see where and which your packages are installed
13:55:24 <TheCrafter> okay allow me to test it again. I will try to install something in a sandbox and see if ghc-pkg list changes.
14:01:21 <TheCrafter> cocreature, it appears there is not problem now. I suspect this happened: When I tried to run my program without installing the dependencies, cabal read the foo.cabal file and downloaded them globally for me. Or something like that.
14:02:02 <TheCrafter> cocreature, sorry for bothering you. false alarm.
14:02:27 <hexagoxel> TheCrafter: (you can `require-sandbox: True` in .cabal/config)
14:02:34 <bitemyapp> mniip: not as yet, seems well-explained, but I'd have to dig in deeper to offer much feedback
14:02:43 <bitemyapp> mniip: I was familiar with KMP but Z-function is new to me.
14:03:16 <TheCrafter> hexagoxel, what does this option do? preventing me from running a project without a sandbox?
14:03:49 <clrnd> mniip, I just read about the Z function, seems understandable, now regarding your article
14:04:02 <clrnd> S: a b c a b d a b c a b = Z: 0 0 0 1 2 0 1 2 3 4 5
14:04:11 <hexagoxel> TheCrafter: pretty much. run/install/update/.. all complain if not in sandbox.
14:04:34 <clrnd> shouldn't it be Z: 0 0 0 2 1 0 5 4 3 2 1 ?
14:04:36 <hexagoxel> ("update" should not, but that is/was a minor bug)
14:05:26 <TheCrafter> hexagoxel, okay I will use that option. Thank you.
14:05:28 <mniip> clrnd, that's prefix function
14:05:33 <mniip> not Z
14:06:17 <clrnd> mniip, I'm basing my knowledge on http://e-maxx-eng.github.io/string/z-function.html
14:06:25 <clrnd> but ok, I understand
14:06:45 <mniip> huh
14:07:18 <mniip> did I use the wrong name this entire time...
14:08:13 <clrnd> :P
14:08:58 <mniip> oh
14:09:16 <mniip> that's the prefix function...
14:09:20 <mniip> crap
14:12:02 <lwm> > putStrLn "testing ..."
14:12:04 <lambdabot>  <IO ()>
14:12:22 <lwm> > liftIO $ putStrLn "testing ..."
14:12:24 <lambdabot>      No instance for (Show (m0 ()))
14:12:24 <lambdabot>        arising from a use of ‘show_M206612525521225341924825’
14:12:24 <lambdabot>      The type variable ‘m0’ is ambiguous
14:13:33 <lwm> > import Control.Monad
14:13:35 <lambdabot>  <hint>:1:1: parse error on input ‘import’
14:14:45 <mpickering> Please can you test lambdabot in private messages
14:16:32 <lwm> sure, ok
14:17:08 <lwm> lambdabot can't run certain things ... what if I wanted to be able to run all of Haskell
14:17:20 <glguy> You'd install it on your computer
14:17:41 <andriusbartulis> ^ true story
14:18:28 <hodapp> one of Haskell's chief innovations is that it does *not* require an IRC bot in order to write programs
14:18:29 <Iceland_jack> This is why Haskell will never become mainstream
14:18:37 <clrnd> mniip, I can't follow the proof yet, so I can't say much about it, but I tried the package and it works
14:18:45 <clrnd> so I could believe it
14:18:54 <clrnd> (I'm easy, call me)
14:19:03 <MarcelineVQ> it's a trap!
14:21:25 <lwm> I am brainstorming an app and I want to be able to send Haskell strings, maybe even full programs somewhere to be run. Like tryhaskell.org
14:21:34 <lwm> but I don't know if it is possible
14:21:45 <slack1256> @hackage hint
14:21:45 <lambdabot> http://hackage.haskell.org/package/hint
14:21:52 <slack1256> seems useful to your case
14:22:06 <lwm> I read that mueval uses this ...
14:22:23 <lwm> oh, right, that does seem useful
14:23:07 <quchen> lwm: Static pointers, shipped with GHC 7.10, are a step in that direction.
14:23:44 <quchen> You can't send programs, but you can talk about arbitrary parts of programs that are alike.
14:24:42 <lwm> thanks, I'll look into it
14:25:28 <lwm> Is there some super light-weight docker style container that I could build and blow up after running a program and get some output from it
14:25:38 <lwm> that seems like a lot of work just to test if a program compiles or not ...
14:28:38 <athan> Anyone here get an "impossible" error when trying to -XDeriveGeneric on a simple ADT?
14:30:00 <quchen> What's the code, what's the error?
14:31:17 <athan> quchen: http://lpaste.net/140068
14:31:45 <athan> I'm wondering if it's a low-level issue. Currently trying to reinstall in a fresh env
14:33:38 <quchen> Oh, that's called GHC panic, not "impossible error" :-)
14:33:45 <quchen> That's a whole different beast
14:34:02 <athan> oop
14:34:29 <quchen> panic is used in GHC to tie off loose ends, e.g. when reaching a pattern that should never be reached
14:34:59 <quchen> Panics are always bugs in the compiler, it's an illegal internal state
14:35:47 <eacameron> Does anyone know if it's possible to represent an cyclic enumeration? I.e. DayOfWeek = Sunday ...| Saturday where succ Sunday = Monday
14:35:51 <quchen> Maybe you should ask in #ghc to find out whether someone knows the issue already, athan 
14:36:08 <eacameron> sorry: succ Saturday = Sunday
14:36:21 <quchen> The first day of the week is Monday. :-C
14:36:31 <eacameron> quchen: depends on where you live ;)
14:37:02 <geekosaur> you can write your own Enum instance but I suspect the enum* functions would require special handling
14:37:02 <slack1256> can't you do that with a custom Enum instance?
14:37:06 <quchen> ISO 8601 is location independent
14:37:35 <slack1256> only where ISO applies
14:37:43 <eacameron> quchen: Regardless, my calendar shows Sunday first...
14:37:53 <eacameron> but that's the beside the point. I could pick Tuesday for all I care
14:37:59 <eacameron> it's cyclic after all!
14:38:52 <eacameron> so fromEnum would be fromEnum int = actualFromEnum $ int `mod` 7 
14:39:04 * hackagebot zalgo 0.2.0.0 - Z-algorithm implemented on haskell's built-in cons-cell-based lists.  https://hackage.haskell.org/package/zalgo-0.2.0.0 (mniip)
14:39:11 <bitemyapp> athan: get in -blah so I can bug you about pedagogy
14:39:44 <ryantm> Has someone made a tool for generating Persistent entities from a DB schema?
14:45:10 <Sindriav_> Can i turn Int into Word8?
14:45:16 <Sindriav_> Or better even, a Char?
14:45:26 <nolrai66> :t ord
14:45:28 <lambdabot> Char -> Int
14:45:32 <glguy> Data.Char.chr :: Int -> Char
14:45:36 <Sindriav_> e.g. Char -> Word8
14:45:49 <nolrai66> Ohh.
14:45:50 <nolrai66> hmm.
14:45:57 <glguy> You can go between Int and Word8 with fromIntegral
14:46:00 <cow_2001> Cale: how do you keep and change state in reflex?
14:46:18 <nolrai66> I think fromIntegral should work on Char, no?
14:46:43 <glguy> no
14:46:43 <bitemyapp> nolrai66: wut
14:46:45 <cow_2001> i'm trying to grok the examples on the frp zoo, but i'm too stupid
14:46:52 <bitemyapp> @ty fromIntegral
14:46:54 <lambdabot> (Integral a, Num b) => a -> b
14:46:59 <bitemyapp> no
14:47:15 <nolrai66> Char isn't Integral?
14:47:21 <nolrai66> Huh.
14:48:22 <nolrai66> > fromIntegral 'a' 
14:48:25 <lambdabot>      Could not deduce (Integral Char)
14:48:25 <lambdabot>        arising from a use of ‘fromIntegral’
14:48:25 <lambdabot>      from the context (Num b)
14:48:37 <geekosaur> this isn't C, char is not a small int
14:49:03 <nolrai66> Hmm.
14:49:17 <nolrai66> I guess I never ran into that before.
14:49:34 <geekosaur> but chr/ord or toEnum/fromEnum work fine
14:50:23 <nolrai66> So is there a data type for a single unicode code point?
14:50:28 <arkeet> that's Char
14:50:51 <nolrai66> ..but isn't char only 16 bits?
14:50:53 <arkeet> no
14:50:54 <geekosaur> problem is, treating unicode code points as something you can do math on is ... highly dubious
14:50:57 <geekosaur> no
14:51:12 <geekosaur> > fromEnum (maxBound :: Char)
14:51:14 <lambdabot>  1114111
14:51:18 <arkeet> > chr 0x10ffff
14:51:20 <lambdabot>  '\1114111'
14:51:28 <nolrai66> Okay.
14:51:59 <d-snp> U+00D7 * U+00D7 = $$$
14:52:02 <d-snp> ;)
14:52:14 <arkeet> > chr (2 * 0xd7)
14:52:16 <lambdabot>  '\430'
14:52:18 <arkeet> oh.
14:52:23 <arkeet> > text [chr (2 * 0xd7)]
14:52:25 <lambdabot>  Ʈ
14:52:34 <nolrai66> Thats good. I had thought Haskell had gotten stuck with utf-16 encoding as its sort of native.
14:52:50 <arkeet> not really "haskell".
14:52:52 <d-snp> I don't get why people object to utf-16 so much
14:52:58 <arkeet> Text uses utf-16 as its representation of strings
14:53:27 <arkeet> but text is just a library
14:53:59 <Sindriav_> > let { f = fromIntegral . fromEnum } in f 'A' :: Word8
14:54:00 <lambdabot>  65
14:54:07 <Sindriav_> well
14:54:31 <Sindriav_> I'd expect Int -> Word8 to be truncate, but that's for floating only
14:54:32 <arkeet> > (fromIntegral . fromEnum) 'あ' :: Word8
14:54:34 <lambdabot>  66
14:54:53 <Sindriav_> :t truncate
14:54:54 <lambdabot> (Integral b, RealFrac a) => a -> b
14:55:07 <arkeet> > fromIntegral (12345 :: Int) :: Word8
14:55:09 <lambdabot>  57
14:55:19 <arkeet> different kind of truncation. ;)
14:57:30 <quchen> The Report says "The character type Char is an enumeration whose values represent Unicode".
14:57:56 <quchen> That's all. It can be UTF-33 behind the scenes as long as the implementation is correct.
14:58:54 <arkeet> Unicode characters, it says.
14:59:53 <arkeet> > chr 0xD800
14:59:54 <lambdabot>  '\55296'
15:00:55 <Gurkenglas> How viable an undertaking is it to get use ghc or ghc sourcecode to get something that unifies my run-time haskell type objects for me?
15:04:06 * hackagebot target 0.2.0.1 - Generate test-suites from refinement types.  https://hackage.haskell.org/package/target-0.2.0.1 (EricSeidel)
15:09:37 <jle`> Gurkenglas: you have types that have valus that represent types?
15:09:42 <jle`> what kind  of overall function do you want?
15:09:48 <jle`> MyTypes -> ???
15:10:44 <Gurkenglas> unify :: MyTypes -> MyTypes -> MyTypes possibly
15:11:40 <Gurkenglas> Im not sure whether I need more information that just the least common upper bound of specialization
15:13:36 <batimania> Hallo , is there anyone here currently studying in Germany .I would like to ask something :)
15:14:08 * hackagebot haste-compiler 0.5.1.1 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.1.1 (AntonEkblad)
15:17:28 <kadoban> batimania: You just asked something … it's just probably not the question you actually want an answer to, unless you're taking a survey. Maybe just skip to your actual question.
15:19:09 * hackagebot varying 0.1.3.0 - Automaton based varying values, event streams and tweening.  https://hackage.haskell.org/package/varying-0.1.3.0 (SchellScivally)
15:19:43 <m1dnight1> Im following the book write you a scheme in 48 hours. The book relies heavily on parsec. I am currently wondering which functions swallows the spaces.
15:20:00 <m1dnight1> http://paste.ubuntu.com/12249032/
15:20:16 <m1dnight1> This is the code I have so far and it indeed parses "     1" as a number, yet I cant seem to find where it swallows the spaces.
15:20:31 <Peaker> Toyed with efficient Applicative/Alternative parsing.. ended up with a simple trie that has Applicative/Alternative instances. very simple! Now I wonder how difficult adding recursive/context-free support would be...
15:22:11 <glguy> m1dnight1: That code doesn't parse "    1" as a number
15:22:16 <glguy> you get a parse error
15:22:33 <m1dnight1> huh
15:22:41 <m1dnight1> dino :: ~/vcs/wyas % ghc main.hs && ./main            123                           
15:22:43 <m1dnight1> Found value: 123
15:22:54 <glguy> m1dnight1: That's your shell that ate the spaces
15:23:02 <m1dnight1> *derp*
15:23:15 <m1dnight1> okay that makes sense then.
15:24:04 <m1dnight1> thanks glguy
15:24:08 <glguy> yw ^_^
15:26:03 <batimania> kadoban why so rude and sarcastic dude ? It not survey related anyway apperantly noone 
15:27:44 <glguy> batimania: He said that because it's better to ask the question you're actually interested in. People typically won't commit to answering your initial question who might otherwise have been able to answer
15:27:53 <kadoban> batimania: It wasn't rude or all that sarcastic, just general IRC advice. Take it or not … but questions like that typically don't get an answer.
15:28:07 <Peaker> https://github.com/Peaker/fastparse/blob/master/fastparse.hs#L60-L71 <-- is there any package that already does this?
15:28:26 <Peaker> (build a parser-trie based on Applicative/Alternative instances?)
15:29:23 <Peaker> I'm thinking of trying to extend this approach to support recursive grammars too, and then I think it should be much faster than any of the parsing frameworks (except perhaps alex, which I found to be very painful)
15:31:00 <batimania> kadoban well i am kinda new in irc , so thanx for the advice.
15:31:07 <Peaker> I'm assuming walking a trie via input chars can be far faster than, say, attoparsec and backtracking, while also being more modular/nicer since you define the parser without factoring out common parser prefixes
15:31:54 <kadoban> batimania: Any time, sorry if it came off rude (really wasn't intended to be).
15:34:09 * hackagebot haste-compiler 0.5.1.2 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.1.2 (AntonEkblad)
15:39:22 <vik123> Is there any way I can specify to include a data declaration within a type class?
15:40:23 <mgsloan> vik123: https://wiki.haskell.org/GHC/Type_families#Associated_family_declarations
15:43:53 <Algebr> I am doing this in ocaml but figured its work asking here as well, when writing an API, what are the guidelines on when you should provide a monadic interface?
15:48:03 <tulcod> Algebr: when you can
15:48:16 <tulcod> (in a nontrivial way)
15:48:45 <Algebr> that didn't really say much.
15:58:26 <Algebr> Also surprised that ghc is still 7.6 on debian's apt-get.
15:59:06 <glguy> Isn't slow adoption of change one of Debian's features?
15:59:21 <ackthet> ^ im not surprised at all
15:59:22 <Clint> Algebr: only in stable
15:59:38 <quchen> mniip: You posted it! Congratulations :-)
15:59:40 <Clint> it's 7.8 in stretch and 7.10 in experimental
16:01:37 <aweinstock> Clint: experimental = sid?
16:02:42 <Clint> aweinstock: no
16:02:52 <Clint> aweinstock: sid's being delayed by the gcc5 transition
16:05:37 <refried_> i'm struggling to pass a function over a universally quantified type
16:05:43 <refried_> is there a version of this that isn't wrong? https://gist.github.com/refried/38ae6530b8ee276b7c29
16:05:58 <Hijiri> experimental is unofficial distro that's more unstable than sid
16:06:47 <shachaf> refried_: What's the issue with the things you commented out?
16:07:13 <lpaste_> glguy pasted “for refried_” at http://lpaste.net/140079
16:07:28 <refried_> shachaf: i put them in because i thought it would bring me closer to a successful compilation, but it didn't that i could tell
16:07:29 <glguy> refried_: The problem is type inference of []
16:07:46 <glguy> refried_: Also the extension of choice for that these days is RankNTypes
16:07:50 <refried_> oh no kidding
16:08:29 <shachaf> I don't have a Haskell compiler here, so it would've been tricky for me to figure that out without the error. :-)
16:08:42 <refried_> glguy: oh ok so you're ascribing an empty list of () ?
16:09:06 <refried_> shachaf: *nod* it was No instance for (Show a0) arising from a use of 'show'
16:09:17 <refried_> which I guess makes sense now
16:09:27 <shachaf> That's not a complete GHC error.
16:09:41 <shachaf> A complete GHC error always includes a line number, which is frequently the most useful part of the error.
16:10:02 <refried_> shachaf: thanks, good point
16:10:17 <shachaf> Anyway when you ask a question you should just include the error. Good habit.
16:11:11 <refried_> or even read the error carefully a few times
16:11:40 <refried_> even if it is half a page long
16:12:18 <glguy> Half of the error message is it telling you exactly where to look
16:12:28 <glguy> and the other half is it telling exactly what the problem is
16:12:33 <refried_> heh *nod*
16:12:45 <refried_> thanks
16:13:04 <Peaker> Annoying that the most useful part of the error (for me) saying where the error is "in first argument of foo, namely (bar baz)" was thrown all the way down by the much less useful "this and that were in scope with type A and B"
16:13:33 <TheCrafter> :t show
16:13:34 <glguy> People'd probably read them if they were colored
16:13:34 <lambdabot> Show a => a -> String
16:13:47 <glguy> That was a big feature of clang
16:13:51 <Peaker> the error should start with the raw details   line number, subexpression id, type mismatch, larger type mismatch,  <put the 'useful hints' here!>
16:21:16 <noodles1> Anyone have any experience with stackage? I'm new to Mac OS X and apparently for 10.9 ghci isnt supported (no gcc).
16:37:54 <fosterite> is there a package for relations more recent than "relation"
16:38:52 <fosterite> hackage only turns up that one and a previous version on a search
16:39:11 <glguy> noodles1: Have you tried stack yet? It seems to solve most problems
16:44:15 * hackagebot irc-core 1.1.1.1 - An IRC client library and text client  https://hackage.haskell.org/package/irc-core-1.1.1.1 (EricMertens)
16:47:24 <pyon> Just wondering... Why isn't divMod's fixity the same as div and mod's?
16:47:42 <pyon> I'd find it useful to say «x `div` y `divMod` z».
16:49:07 <pyon> Errr, «x `mod` y `divMod` z».
16:53:56 <ttt_fff> https://gist.github.com/anonymous/c7890f4b28c6b4259cd7
16:53:58 <ttt_fff> how do I get more info
16:54:05 <ttt_fff> it seems like the only reported functions are in cowboy
16:54:10 <ttt_fff> and not any actual functions that I have wrote
16:55:50 <ttt_fff> wrong channel
16:56:05 <xrisk> Hey guys, I was just installing Haskell for the first time today, and I noticed that the binaries weren't symlinked into /usr/local/bin as I thought they would be :/
16:56:07 <TabAtkins> Random question about MonadTransformer, Traversable, and my intuitions about these datatypes:
16:56:44 <TabAtkins> MonadTransformer seems to generally be a way to make specific, composition-friendly, monads compose with other arbitrary monads.
16:57:05 <TabAtkins> Traversable also seems to enable this - as long as at least the inner monad is also Traversable, composition "just works".
16:57:29 <TabAtkins> I haven't seen it stated in as many words yet, but is Traversable basically a better, more generalized, less hacky version of what MonadTransformer was originally trying to do?
16:57:30 <glguy> xrisk: What did you install (there's no one "install Haskell")? Why did you think it would add to /usr/local/bin?
16:58:42 <xrisk> glguy: http://i.imgur.com/00XFnf5
16:58:53 <xrisk> I had to symlink them myself.
16:59:28 <glguy> That says they were symlinked into /usr/bin rather than /usr/local/bin. Did you look there?
16:59:48 <xrisk> glguy: Yes they weren't there, neither were they available from my bash.
16:59:57 <glguy> Ah, OK.
17:00:01 <glguy> and it works now?
17:00:19 <xrisk> Yeah, they were there in /Library/Frameworks/GHC.framework  as mentioned.
17:00:56 <glguy> Which version of OS X was that?
17:01:25 <xrisk> 10.11 beta
17:01:51 <xrisk> Is it because of the beta, or is it a problem with the installer?
17:02:05 <xrisk> btw, I was using the dmg installer and not MacPorts.
17:02:16 <glguy> 10.11 isn't supported yet (it's not out) a possible problem is that 10.11 has some new feature called "rootless" and doesn't allow stuff to write to /usr/bin
17:02:49 <xrisk> glguy: Yes, /usr/bin is not writable without root permissions.
17:04:34 <srhb> xrisk: It's not writable even then with rootless, correct?
17:04:57 <glguy> http://arstechnica.com/apple/2015/06/preview-os-x-el-capitans-first-beta-is-a-promising-heap-of-refinements/4/
17:05:06 <xrisk> srhb: Umm, I'm not too sure. Let me have a try.
17:05:32 <tommd> I've not seen glguy's link but this one is interesting to me wrt rootless: https://www.quora.com/Can-someone-elaborate-on-the-OS-X-10-11-feature-called-Rootless?share=1
17:05:48 <xrisk> Ahh, yes, I can't write even with sudo
17:08:56 <refried_> glguy / shachaf how about this one? i figured (f b -> f b) would work for ([b] -> [b])   https://gist.github.com/refried/7abd9b7414110ea798e5
17:09:49 <refried_> or... maybe i understand why that won't work
17:09:55 <glguy> refried_: f isn't general enough
17:10:07 <glguy> it only works on types where the 'a' is a Show instance
17:10:25 <glguy> err, 'f a' is
17:10:31 <refried_> oh wait, it's not a Show-related problem, is it?
17:11:09 <refried_> i think it's because the argument is polymorphic in f (set by the argument), but i'm trying to call it with [] which may not match
17:16:36 <glguy> Yeah, that's right
17:43:30 <pyon> There's no way to catch exceptions in pure code, right
17:43:31 <pyon> ?
17:43:42 <pyon> I mean, outside of IO.
17:44:13 <kaidelong> pyon: hopefully yes
17:44:22 <arkeet> not without unsafePerformIO or the like
17:58:14 <pyon> Is there any function that takes an array (yes, array) and an index, and returns Nothing or Just the array element at the given index?
17:58:25 <pyon> Something like the `safe` package, but for arrays.
18:00:08 <glguy_> preview . ix    From lens does that for one
18:00:37 <pyon> Ah!
18:00:39 <pyon> Thanks!
18:04:03 <pyon> glguyWhere is `ix` defined?
18:04:06 <pyon> glguy_: *
18:06:27 <glguy_> Lens package. If you aren't already using it it's probably not worth starting for this
18:07:44 <pyon> I just want to locate the definitions so that I can read them.
18:09:24 * hackagebot scalpel 0.2.1.1 - A high level web scraping library for Haskell.  https://hackage.haskell.org/package/scalpel-0.2.1.1 (fimad)
18:12:36 <pyon> Ah... I see that the `Ixed` instance for `Array` itself checks whether the index is within bounds. :-|
18:13:26 <arkeet> yes
18:13:39 <arkeet> Data.Array doesn't provide any bounds checking
18:13:44 <Madd_> Why does ['A'..] spit out a seemingly infinite list?
18:13:47 <arkeet> well, it does in the form of throwing an error on out of bounds
18:13:56 <arkeet> Madd_: it's not infinite, it stops at the last character
18:14:04 <arkeet> it's just that there are a lot of characters.
18:14:13 <arkeet> > length ['A'..]
18:14:15 <lambdabot>  1114047
18:14:22 <Madd_> Ah, thanks!
18:14:44 <pyon> arkeet: Well, I guess Data.Array has to perform bounds checking, otherwise arrays would be memory-unsafe. :-|
18:14:49 <arkeet> exactly.
18:15:04 <pyon> It's just that, once the bounds check is performed, the result is thrown away. :-|
18:16:23 <pyon> > [250..] :: [Word8]
18:16:24 <lambdabot>  [250,251,252,253,254,255]
18:16:49 <pyon> Mmm. Interesting. So `[x..]` is more than just syntactic sugar for `enumFrom`. :-|
18:17:39 <Hafydd> How so?
18:17:44 <arkeet> no it's not.
18:17:45 <Hafydd> > enumFrom 250 :: [Word8]
18:17:47 <lambdabot>  [250,251,252,253,254,255]
18:17:59 <pyon> Ah.
18:18:15 <pyon> How does it «know where to stop»? :-|
18:18:22 <arkeet> the Enum instance for Word8 does.
18:19:36 <pyon> Oh, `enumFrom` is a part of the instance itself. I thought `Enum` only had `succ` and `pred` as its members, and everything else was derived from that. :-|
18:19:59 <arkeet> if you track down the definition, it ends up looking like
18:20:00 <Hafydd> https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#dx13-131001
18:20:19 <arkeet> > map toEnum [fromEnum (250 :: Word8) .. fromEnum (maxBound :: Word8)] :: [Word8]
18:20:20 <Hafydd> "For any type that is an instance of class Bounded as well as Enum, the following should hold: [...] enumFrom and enumFromThen should be defined with an implicit bound, thus: [...]"
18:20:20 <lambdabot>  [250,251,252,253,254,255]
18:21:55 <Enigmagic> narySplit(<function1>,Map(false -> -9223372036854775808),Map(false -> -9223372036854775806)))
18:22:09 <Enigmagic> derp
18:22:28 <Hafydd> That looks horrible, whatever it is.
18:22:48 <Enigmagic> yes, yes it does.
18:25:27 <drduck> Does cabal come with installing haskell, out of the box?
18:26:26 <arkeet> what is "installing haskell"?
18:27:03 <arkeet> GHC comes with Cabal-the-library, but not cabal-the-program (aka cabal-install)
18:27:12 <arkeet> the haskell platform comes with cabal-install
18:27:43 <drduck> Ahh alright. I needed the latter.
18:35:35 <Welkin> the Lazy Functional State Thread paper by SPJ is amazing
18:35:47 <Welkin> it explains so much more than ST
18:36:01 <Welkin> IO is actually ST!
18:38:52 <Axman6> yup
18:38:53 <Welkin> although what exactly is State#?
18:39:21 <Enigmagic> iirc it is: data State#
18:39:23 <Welkin> looking at Base right now
18:39:27 <Enigmagic> similar to Void
18:39:45 <shachaf> data State# a?
18:39:56 <Enigmagic> yeah that
18:40:13 <Welkin> I thought types with # on the end were C orimitives
18:40:15 <Welkin> Int#
18:40:20 <Welkin> primitives*
18:40:24 <Axman6> nah, pretty sure State# s a = State# s -> (#a,s#)
18:40:30 <geekosaur> that is a convention but not mandatory
18:40:35 <Enigmagic> errp i was thinking of RealWorld#
18:40:36 <Enigmagic> :)
18:40:40 <Axman6> even State# s a = State# (s -> (#a,s#))
18:40:44 <geekosaur> it just means "internal, only accessible with -XMagicHash"
18:40:52 <Welkin> okay
18:40:54 <Enigmagic> brain is mushy
18:41:27 <Welkin> so State# is just an internal version of State?
18:42:07 <geekosaur> in some sense. the difference between State# and State is that State is a normal tuple, State# is an unboxed tuple
18:42:12 <geekosaur> (the (# #)
18:42:28 <Welkin> I see
18:43:02 <geekosaur> (s/is/has/ for both)
18:43:20 <lpaste_> rdesfo pasted “countFrac” at http://lpaste.net/140088
18:43:50 <geekosaur> and IO indeed involves an unboxed tuple, with one element a "phantom" (the infamous "RealWorld#", which has no actual representation)
18:44:15 <Fay>  http://paperswelove.org/2015/video/michael-bernstein-propositions-as-types/
18:44:20 <Welkin> where can I see the data declaration for IO?
18:44:55 <geekosaur> it should be in GHC.IO
18:45:07 <Welkin> in the paper is it: type IO a = ST RealWorld a
18:45:12 <Welkin> it is*
18:45:43 <geekosaur> it's not actually written that way, because it's "expanded"
18:46:00 <geekosaur> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
18:46:20 <Welkin> geekosaur: https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/src/GHC-Types.html#IO
18:46:27 <Welkin> GHC.Types
18:47:11 <geekosaur> yeh
18:48:06 <Welkin> are there any other papers like this that anyone recommends for learning about fundamental hsakell/ghc concepts?
18:48:14 <Welkin> I already found several on SPJ's website
18:48:26 <Welkin> I think the next one I will read is "Imperative Functional Programming"
18:48:40 <Welkin> the prequel to the ST paper
18:52:24 <Welkin> any other papers in that style (tutorial for programmers)?
18:57:58 <average> did anyone here ever use fenwick trees(binary indexed trees) in a RDBMS ? and if so, what was it for, and were you able to get a performance boost from it, or were the RDBMS's already implemented features enough ?
19:17:48 <eguneys> how do I solve this: -> b, String) -> String -> Maybe (a, String)
19:17:48 <eguneys>   -- -> String -> Maybe (b, String)
19:17:54 <eguneys> sorry *   -- String -> Maybe (a -> b, String) -> String -> Maybe (a, String)
19:17:54 <eguneys>   -- -> String -> Maybe (b, String)
19:18:08 <eguneys> String -> Maybe (a -> b, String) -> String -> Maybe (a, String) -> String -> Maybe (b, String)
19:18:17 <eguneys> the last one
19:18:50 <shachaf> \_ _ _ _ _ -> Nothing
19:19:38 <eguneys> this http://lpaste.net/140090
19:19:44 <echo-area> Haha
19:20:47 <pacak> eguneys: const . const . const . const . const Nothing should do the trick.
19:20:50 <Welkin> eguneys: that si not enough information
19:20:54 <eguneys> I need to go Functor f => f ((a -> b), String) -> f (a, String) -> f (b, String)
19:21:01 <Welkin> shachaf's solution is technically correct
19:21:49 <shachaf> Impossible.
19:22:04 <eguneys> For example this is what applicative solves right
19:22:15 <eguneys> f (a -> b) -> f a -> f b
19:23:24 <Welkin> eguneys: is this a homework assignment? because it looks like a mess
19:23:45 <nshepperd> eguneys: use do notation, and then do the obvious
19:23:53 <eguneys> ye its this http://www.seas.upenn.edu/~cis194/spring13/hw/10-applicative.pdf second one applicative for a parser
19:24:29 * hackagebot persistent-mysql 2.3 - Backend for the persistent library using MySQL database server.  https://hackage.haskell.org/package/persistent-mysql-2.3 (MaxGabriel)
19:24:34 <Welkin> eguneys: eh? I completed all of those upenn exercises and I do not remember anything with that type
19:24:55 <eguneys> Parser (a -> b) -> Parser a -> Parser b
19:25:14 <Welkin> it is actually :: Parser (a -> b) -> Parser a -> Parser b
19:25:15 <eguneys> this is applicative signature isn't it
19:25:27 <Welkin> yes, but expanded out like that it is too messy
19:25:38 <eguneys> how do I think then?
19:25:44 <Welkin> at a higher level
19:26:05 <eguneys> whats the solution
19:26:21 <Welkin> eguneys: that is for you to write
19:26:31 <Welkin> you have all the tools
19:26:32 <eguneys> please help 
19:27:15 <eguneys> what does it mean higher level think
19:28:05 <Welkin> well, you know that you need to get the (a -> b) from the first parser and apply it to the `a` from the second parser
19:28:27 <eguneys> how do I get (a -> b) from Parser (a -> b) can I pattern match
19:28:41 <Welkin> you can, but it is better to use `runParser`
19:29:06 <pyon> What's the idiomatic way to do (flip (-) k) as a section?
19:29:16 <Welkin> pyon: subtract
19:29:26 <Welkin> > subtract 1 3
19:29:28 <lambdabot>  2
19:29:41 <pyon> Thanks!
19:29:49 <pyon> @src subtract
19:29:49 <lambdabot> subtract x y = y - x
19:35:21 <eguneys> I don't understand runParser just converts a parser to a function how do I get a -> b inside that maybe pair
19:36:24 <Welkin> look at the resulting type of <*>
19:36:31 <Welkin> it is Parser b
19:36:40 <eguneys> so
19:36:42 <Welkin> so you need to construct a new Parser
19:36:48 <Welkin> how do you do that?
19:37:05 <eguneys> \xs -> Maybe (b, String)
19:37:25 <Welkin> ?
19:37:43 <Welkin> you are mixing types and values
19:37:52 <Welkin> Matbe and String are types
19:37:53 <eguneys> Parser (\xs -> Maybe (b, String))
19:38:05 <Welkin> no
19:38:17 <Welkin> close
19:38:33 <Welkin> how did you define `pure`?
19:38:48 <eguneys> Parser (\xs -> Just (a, xs))
19:38:53 <eguneys> oh ok
19:38:58 <eguneys> Parser (\xs -> Just (b, String))
19:41:05 <eguneys> so what do i do?
19:42:47 <Welkin> no
19:43:02 <Welkin> Srting is a typw
19:43:05 <Welkin> type*
19:43:10 <eguneys> Parser (\xs -> Just (b, xs))
19:43:16 <Welkin> yes :)
19:43:20 <eguneys> then what
19:43:36 <Welkin> okay, so you want to construct a new Parser
19:43:43 <eguneys> yes but I dont have b
19:43:52 <eguneys> its inside maybe pair
19:43:53 <Welkin> well, take it one step at a time
19:44:01 <Welkin> start to construct the new Parser with what you have
19:44:35 <Welkin> all Parser must accept a String as input, correct?
19:44:42 <eguneys> yes
19:44:50 <Welkin> so you start by constructing that part of the new parser
19:45:27 <Welkin> Parser (\s -> ... )
19:45:37 <Welkin> the ... is then rest of your function definition
19:45:50 <Welkin> which must ultimately have type Maybe (b, String)
19:46:11 <eguneys> Yes I already wrote  Parser (\xs -> Just (b, xs))
19:46:23 <Welkin> that is not what I mean
19:46:32 <Welkin> you have Parser (a -> b) and Parser a
19:46:44 <eguneys> ok
19:46:45 <Welkin> you need to process those to obtain your Maybe (b, String)
19:46:59 <Welkin> which is wrapped in the new Parser
19:47:42 <eguneys> runParser Parser (a -> b) doesnt do anything
19:47:44 <Welkin> so when you use runParser on the first Parser, you have your String to apply it over
19:48:25 <Welkin> fab <*> fa = Parser $ \s -> ...
19:48:42 <eguneys> fab <*> fa = Parser $ \s -> runParser s ?
19:48:44 <Welkin> `s` is your String
19:48:52 <Welkin> no
19:48:57 <eguneys> fab <*> fa = Parser $ \s -> runParser fab s ?
19:49:08 <Welkin> think about what you want to do
19:49:26 <Welkin> extract the (a -> b) from the first parser and apply it over the second
19:49:40 <Welkin> result of the second parser*
19:49:41 <eguneys> I want to get Maybe (b -> String) out of Maybe (a -> b, String)
19:50:15 <eguneys> how do I extract a -> b out of Maybe (a -> b, String)
19:50:17 <Welkin> use runParser
19:50:42 <Welkin> and pattern match on the result
19:51:01 <eguneys> ok thanks
19:51:18 <eguneys> with case right
19:51:21 <Welkin> yes
19:55:24 <eguneys> do I pattern match on both fab and fa as a pair case (fab, fa)
19:58:36 <Welkin> what?
19:58:48 <Welkin> fab and fa in my example are the Parsers
19:59:02 <eguneys> I can get a -> b via pattern match how do I get a 
19:59:05 <Welkin> you don't pattern match on them, you use runParser on each
19:59:19 <eguneys> ok ok case (runParser fab xs)
19:59:32 <Welkin> what are the cases?
19:59:42 <eguneys> Nothing and Just (f, s) 
19:59:46 <Welkin> okay
19:59:48 <eguneys> so I have a -> b
19:59:55 <eguneys> how do I extract a from second parser
20:00:03 <Welkin> the exact same way
20:00:07 <eguneys> pattern match again nested
20:00:13 <Welkin> yes
20:00:15 <eguneys> ok thanks
20:07:21 <echo-area> How is ghc's binary tarball made?  I am wanting to create one myself
20:09:18 <SrPx> How do I print numbers from 0 to 10 using Control.Monad.Loop? 
20:09:35 <SrPx> "do { i <- for 0 (< 10) (+ 1); return i}" <- now what?
20:11:55 <jasonkuhrt> I'm reading Haskell Programming First Principals (early release) and I'm confused by some simple wording that may be a typo/error in the book
20:12:03 <jasonkuhrt> This expression: λz1.z((λx.a)(z1))
20:12:13 <jasonkuhrt> is described as "z is now being applied to ((x.a)(z1))."
20:12:46 <jasonkuhrt> However "applying" would actually mean: λz1.((λx.a)(z1))z
20:12:47 <jasonkuhrt> no?
20:12:59 <arkeet> no
20:13:16 <arkeet> a function is applied to its argument.
20:15:22 <jasonkuhrt> arkeet: I'm confsued because for example we write : `(λz.z)a` to say "apply a to ..." not `a(λz.z)`
20:15:29 <arkeet> we do?
20:15:33 <arkeet> I don't.
20:15:35 <jasonkuhrt> haha guess not!
20:16:08 <jasonkuhrt> Ok thanks, I guess its simple as that
20:16:19 <jasonkuhrt> arguments are applied right side of the function
20:16:26 <arkeet> you apply functions.
20:16:29 <arkeet> so functions get applied.
20:16:34 <arkeet> to things.
20:17:07 <jasonkuhrt> right, rather than "passing things to functions"
20:17:26 <arkeet> yeah
20:17:55 <lpaste_> wizao pasted “Lens Breadcrumbs” at http://lpaste.net/140093
20:18:07 <jasonkuhrt> arkeet: but at some point, between this lambda calculus and haskell syntax it flips
20:18:19 <jasonkuhrt> `map foo xs`
20:18:20 <jasonkuhrt> etc.
20:18:36 <jasonkuhrt> That's an accurate statement no?
20:18:49 <arkeet> what's flipped about that?
20:19:18 <jasonkuhrt> seems like it would be `foo xs map`
20:19:23 <arkeet> ??
20:19:53 <jasonkuhrt> take `id` instead
20:19:59 <arkeet> a function is written on the left side of its argument.
20:20:05 <arkeet> this is the same in both haskell and in lambda calculus
20:20:37 <jasonkuhrt> Then going back to my original question ...
20:20:37 <pyon> @hoogle (a,b) -> (b,a)
20:20:38 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
20:20:38 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:20:38 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
20:21:02 <jasonkuhrt> ah.
20:21:33 <jasonkuhrt> arkeet: `z` is a function that accepts the value dervied from expression: `((λx.a)(z1))`
20:21:40 <arkeet> yes.
20:22:09 <jasonkuhrt> All all good now. Phew.
20:22:13 <arkeet> okay :-)
20:22:14 <jasonkuhrt> arkeet: Thanks!
20:22:55 <arkeet> occasionally I see some mathematics where function application is written backwards from what is common, like (x)f
20:23:06 <arkeet> it weirds me out every time.
20:23:09 <jasonkuhrt> hehe
20:23:14 <glguy`> Wizao: the aeson lenses aren't going to find breadcrumbs
20:23:50 <wizao> Can I use the control.lens.zipper library to get something the lens?
20:23:55 <jasonkuhrt> arkeet: Another quick question
20:24:04 <jasonkuhrt> `(λxyz.xz(yz))(λx.z)(λx.a)` == `(λxyz.xzyz)(λx.z)(λx.a)`?
20:24:12 <arkeet> no
20:24:22 <arkeet> xz(yz) = (xz)(yz)
20:24:25 <arkeet> xzyz = ((xz)y)z
20:25:07 <glguy`> The zipper library is too typed to be very useful for this case
20:25:19 <jasonkuhrt> arkeet: Right, its the order of operations that are affected
20:25:24 <jasonkuhrt> Ok makes sense
20:25:30 <jasonkuhrt> Thanks again
20:25:36 <arkeet> any time :)
20:25:58 <SrPx> okay just, how do I get a monad that is IO + lists? A simple example? ` do { x <- [0..10]; print x }` how can this work? I know it must be a matter of adding some lifts...
20:26:19 <wizao> glguy`: Can i use the lens zipper on aseson values because they are biplates/plate/uniplate
20:26:53 <wizao> just started lens, so I'm really lost on the types
20:26:58 <echo-area> Oh, it's documented at https://ghc.haskell.org/trac/ghc/wiki/Building/StandardTargets
20:27:58 <glguy`> You can use it to implement your own bread crumb tracker but it isn't really going to make it easier. The zippers library tracks your path in its types , which isn't great if you don't know where you're going
20:29:04 <wizao> That's what I figured intuitively, but as a lens beginner I wanted to ask
20:29:17 <wizao> Thank's for the help
20:29:37 <geekosaur> SrPx: there is ListT, with some caveats
20:29:53 <geekosaur> list itself is not a transformer and you can't lift / liftIO / etc
20:31:52 <narrative> SrPx: not sure if this is what you're looking for, but `do {let x = [0..10];mapM_ print x}`
20:32:20 <geekosaur> narrative, that's not the same thing
20:33:26 <arkeet> see https://wiki.haskell.org/ListT_done_right
20:34:02 <SrPx> not really :( I'm like 20 mins trying to figure out how do I use https://hackage.haskell.org/package/loops-0.2.0.2 to print from 0 to 10
20:34:24 <SrPx> I asked for lists because I assumed it would be the same logic
20:35:26 <SrPx> The example on the site is: "main = print $ toList $ loop $ do { i <- for 0 (<= 10) (+ 1); return (i, j) }", but I don't want to print a list, I just want to repeat an IO action 10 times
20:37:03 <eguneys> how do I parse all letters from a character parser Char -> Parser Char
20:37:10 <arkeet> if all you want to do is print the numbers from 0 to 10
20:37:14 <arkeet> I would mapM_ print [0..10]
20:38:34 <SrPx> arkeet: using forM_ for nested loops is making it slower than javascript to merely write data to a mutable vector
20:39:11 <glguy> SrPx: exec_ (do a <- for 0 (<10) (+1); liftIO (print a))
20:40:01 <SrPx> forM_ [0..h] $ \ y -> forM_ [0..w] $ \ x -> do { write vec (y*w+x) 1 } ... <- 4x slower than JS, I guess because it is not being compiled to a tight loop as it should :(
20:40:02 <glguy> To repeat an action 10 times you'd do: replicateM_ 10 action
20:40:04 <SrPx> glguy: ty
20:40:18 <SrPx> glguy: but that has the same slowness problem
20:40:33 <SrPx> (the replicateM_*)
20:40:38 <glguy> Using that loops library probably isn't going to help your slowness problem
20:40:48 <glguy> You're probably doing something slow in your loop body itself
20:40:57 <SrPx> no, I'm just writing data, nothing else
20:41:31 <glguy> There are different ways to write data, so that doesn't tell us that it isn't the problem
20:41:53 <nitrix> That's already more involved than looping. I'd bet you'll find your bottleneck somewhere in there.
20:42:13 <nitrix> The real answer being of course a profiler.
20:43:58 <SrPx> weeelll....
20:44:44 <SrPx> There you go. Just replacing `forM_ [0..n-1] $ \ i -> do forM_ [ay..by] $ \ y -> do forM_ [ax..bx] $ \ x -> do MUV.write mutBuffer (y*32+x) pix`
20:44:55 <SrPx> by `exec_ $ do n <- for 0 (<n-1) (+1) y <- for 0 (<(by-ay)) (+1) x <- for 0 (<(bx-ax)) (+1) liftIO (MUV.write mutBuffer (y*32+x) (rgba 1 1 1 1))`
20:45:03 <SrPx> made it 5 times faster
20:45:28 <SrPx> told ya <3
20:59:36 <SrPx> I just want to say I'm not purposely being snarky, I'm just not used to be so serious and perhaps it is a matter of culture... yet, I want you to know this channel is one of the things I'm more grateful for on my life. I know I can a bit annoying sometimes and please let me know when I do, but...
21:01:21 <SrPx> please be assured anytime I sound like I'm being snarky with an answer I receive is absolutely a wrong impression of what I actually think. :(
21:03:02 <illiux> anyone here familiar with netwire 5? I had difficulty using holdFor with a fractional value using the default clock session, and ended up having to wrap it to making a fractional clock session. Wondering if a better way exists.
21:09:39 * hackagebot ihaskell 0.7.1.0 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.7.1.0 (gibiansky)
21:09:41 * hackagebot ipython-kernel 0.8.0.0 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.8.0.0 (gibiansky)
21:09:44 * hackagebot hpack 0.7.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.7.0 (qoelet)
21:23:03 <ramadoka> is xmonad only usefull if I use multiple windows?
21:23:44 <glguy> SrPx: That's neat that writing it with loops enabled GHC to generate fast code for that loop
21:35:34 <pacak> ramadoka: You can still manage your only window. To move it around and to scale.
21:35:55 <glguy> It'll be full screened saving you that click
21:41:24 <SrPx> glguy: uh-huh. The library claims that as the use-case, writing for loops that are guaranteed by the type system to fuse into a tight loop - which forM_ isn't always.
21:41:55 <SrPx> It looks promising, but not many people are using it so I still suspect I'm doing something wrong.
21:50:48 <lpaste_> glguy pasted “writing the loop without "loops"” at http://lpaste.net/140101
21:51:04 <glguy> SrPx: Could you try that version to see how much slower it is?
21:52:07 <glguy> Oh, and I had removed the rgb 1 1 1 1 argument from the write
21:52:30 <glguy> so I could type check it without installing whatever that came from
22:00:14 <SrPx> glguy: oh I'll post on s.o. in a few secs
22:00:20 <SrPx> but I guess it is too late now
22:07:52 <glguy> SrPx: A version of what I pasted there ran on a test input in 111μs compared to the loops version that ran in 91μs in criterion
22:10:17 <glguy> So slower but not a ton. I imagine that's the main reason people might not be using that package. They prefer the slightly slower but 4-line helper function to a dependency (or they just don't know about the package)
22:15:00 <glguy> Also for this particular case you can use vector's set :: (PrimMonad m, MVector v a) => v (PrimState m) a -> a -> m ()
22:15:07 <glguy> (which is just as fast as the loops version)
22:16:37 <glguy> (Oh, but yours was a subregion of the vector, so nevermind)
22:16:56 <SrPx> glguy: Interesting. I actually tested almost the same thing before and it was slower. Maybe I screwed something on the recursion... let me try again.
22:18:32 <SrPx> glguy: just for knowledge sake, I guess I know how to make your loop work on ST, but I couldn't use the Control.Monad.Loop with ST
22:19:03 <SrPx> It seemed logic so I looked for a "liftST" function but seems like there is no such a thing... how would you port "exec_ (do a <- for 0 (<10) (+1); liftIO (print a))" to st?
22:19:13 <SrPx> I'm sorry it has been some time since I last used transformers
22:19:15 <glguy> Oh, it would work with ST
22:19:20 <glguy> you'd use "lift"
22:22:30 <lpaste_> glguy annotated “writing the loop without "loops"” with “works in IO and ST s now” at http://lpaste.net/140101#a140103
22:24:34 <SrPx> glguy: oh it works, thanks
22:34:43 * hackagebot postgrest 0.2.11.1 - REST API for any Postgres database  https://hackage.haskell.org/package/postgrest-0.2.11.1 (begriffs)
22:38:08 <Reshi> I am trying to install happy (https://www.haskell.org/happy) with `cabal install happy`
22:38:23 <Reshi> This succeeeds, but how do I get the executable for happy?
22:38:37 <Reshi> Am I missing something on my path?
22:39:05 <slack1256> the executables are usually on .cabal/bin
22:39:14 <Reshi> I should add .cabal/bin/ to my path.. yeah
22:39:22 <Reshi> slack1256: thanks!
22:42:19 <lpaste_> xelxebar pasted “xmppcat” at http://lpaste.net/140104
22:42:56 <lolisa> Folks, I dont know if it is helpful or not, but I finded SPJ's talk on lens fantastic: https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
22:43:58 <xelxebar> So, I hacked together a cli wrapper around the pontarius-xmpp library to send oneoff messages over xmpp, wait for a reply and echo it back to stdout.
22:44:27 <slack1256> socat!
22:49:05 <xelxebar> As a complete beginner, I really had no idea what I was doing. My error handling code is scattered everywhere and feels ugly. Also, I'd like to know if there's a better way to handle interfacing a library that uses `String` with one that uses`Data.Text`.
22:49:44 * hackagebot language-qux 0.1.1.1 - Utilities for working with the Qux language  https://hackage.haskell.org/package/language-qux-0.1.1.1 (hjwylde)
22:49:58 <xelxebar> If anyone has the time and gumption to review about 150 lines of code, I'd be much obliged to hear your input!
22:50:29 <xelxebar> slack1256: Doesn't `socat` just give us a raw socket?
22:53:01 <jackdare> QUIT
22:53:04 <jackdare> QUIT
22:53:10 <slack1256> sockets, files, pipes, unix domain sockets, almost anything on unix. I guess you can combine it with some xml cli formatter and have a lightweight xmpp client
22:53:59 <slack1256> this has nothing to do with haskell though, I was just thinking of how make processes discover each others unix domain sockets without dbus or hardfixed /tmp
22:54:08 * slack1256 will shut up
22:54:56 <kristof> lolisa: What did you like about it?
22:56:04 <xelxebar> slack1256: I like the way you think...
22:57:21 <lolisa> krisof, I say it is very practical and very easy to grasp, as you know, well, I am a Coq programmer who dont really know much about haskell, and my cat theory ability is very limited
22:58:36 <lolisa> So if it's easy for an outsider, it must be piece of cake for anyone else...
23:01:25 <kristof> Not a big fan of category theory.
23:01:52 <kristof> Never found any use for free theorems, homomorphisms, or equational reasoning, although the latter is probably useful.
23:02:44 <lolisa> Yes, I am just saying that, even though I know basically nil cat theory, I still get what SPJ is talking about...
23:03:41 <kristof> That's good! :)
23:03:49 <kristof> I've bookmarked it, will watch maybe tomorrow
23:29:49 <jle`> xelxebar: just post it :)
23:30:05 <jle`> the people who would say they would read it will read it, and the people who would read it but not say anything will read it too
23:30:08 <jle`> it's win-win
23:30:08 <xelxebar> Oh, sorry. It's in the lpaste above.
23:30:23 <xelxebar> http://lpaste.net/140104 
23:30:41 <xelxebar> Also, thanks! Didn't realize that was unclear.
23:38:15 <cocreature> xelxebar: error is a bit nasty since it crashes your program. imho you should only use it for debugging or for cases that should never occur at runtime. Those cases seem like they can arise, so I would just print an error message and exit cleanly
23:40:49 <xelxebar> cocreature: Noted. Thanks.
23:43:47 <xelxebar> cocreature: Looking at `System.Exit`. So replacing with something like `die "Error message here"` is what you're talking about?
23:46:13 <xelxebar> Overall though, scattering `die` throughout the code seems like the wrong way to do error handling to me. Is there some exception library or something in this regard that I should know about?
23:46:26 <xelxebar> Appreciate you guys taking the time.
