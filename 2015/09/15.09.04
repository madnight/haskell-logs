00:12:50 <athan> What's the monoid instance for Maybe where `Just x <> Just y ~ Just (x <> y)`?
00:12:59 <athan> or is that any functor?
00:13:11 <athan> er applicative
00:13:50 <athan> er monad
00:14:06 <knupfer> If I want a monad, which takes a MVar and runs on it all its computations, would that be a reader with the mvar as environment?
00:14:56 <knupfer> Or would that be state?
00:15:33 <athan> knupfer: I often use a reader for stuff like that
00:15:34 <mauris_> athan: that's the instance `Monoid a => Monoid (Maybe a)`
00:15:36 <athan> like STRefs
00:15:57 <athan> mauris_: It is? Oh shoot
00:16:59 <knupfer> athan: ok thanks, i was sceptical because the docs speak only of a "read only" environment
00:19:05 <Axman6> knupfer: if the MVar you're referring to never changes, then Reader makes sense
00:19:09 <athan> knupfer: Well, if it's a reference to a variable, you wouldn't be changing the variable name while coding, for instance
00:19:18 <Axman6> the "pointer" never changes
00:22:57 <knupfer> Ok.  Propably it makes sense that the second parameter of the reader is in the io monad, or?
00:23:52 <mauke> do you mean a type of the form 'IO ...'?
00:24:15 <knupfer> Reader (MVar String) (IO a)
00:24:31 <mauke> ReaderT (MVar String) IO a?
00:24:45 <latermuse> I want to modify an instance that is set in a module that cabal installed for me. How can I go about doing this?
00:25:04 <latermuse> Do I need to download the source code, modify it, then include that?
00:25:06 <knupfer> mauke: i've never used a transformer, would that be preferable in this context?
00:25:17 <latermuse> Or can I just hide the previous instance, and redefine it myself from scratch?
00:25:42 <zipper> Hello, I have the following websockets code. I want to send data from the server to the client. However I am having issues creating a value of type Network.WebSockets.Connection. http://lpaste.net/3386343127462707200
00:25:44 <mauke> knupfer: it might be
00:26:16 <zipper> According to the examples it seems as if the connection just exists on its own. How is that?
00:26:18 <Saizan> latermuse: either modify the source code or use a newtype
00:26:20 <mauke> of course ReaderT (MVar String) IO a is equivalent to MVar String -> IO a, so you could also just do that manually
00:26:39 <latermuse> Saizan: newtype can override the old instance?
00:26:52 <mauke> newtype creates a new type, which has no instances initially
00:28:17 <latermuse> ah so then I need to change my old definitions to point at the new type. Will the new type be compatible with the code in the imported module still?
00:28:22 <knupfer> mauke: my use case is a monad, which sends with every <- some string to a server and takes a MVar which will be filled by that server and returns it on the left hand side.  In the whole monad, it should be the same server and the same MVar.
00:28:45 <mauke> latermuse: no, you'd have to manually convert
00:28:49 <latermuse> okay
00:28:57 <latermuse> thanks mauke, thanks saizan
00:29:10 <mauke> zipper: the server creates a connection with acceptRequest, the client creates a connection in runClient
00:30:04 <zipper> mauke: But I did that, didn't I? I used both acceptRequest and runClient.
00:30:26 <mauke> yes
00:30:27 <zipper> mauke: L23 and L33
00:30:34 <mauke> what's your question?
00:31:22 <zipper> mauke: Okay my error is: `Expecting one more argument to ‚ÄòWS.ClientApp‚Äô` so it seems it still wants me to pass a connection.
00:32:04 <mauke> zipper: app :: WS.ClientApp ()
00:32:19 <mauke> you have a malformed type signature
00:32:39 <zipper> mauke: Arrggghhhhhhhh
00:33:38 <zipper> mauke: Have you worked with websockets before?
00:33:50 <zipper> mauke: Do you think what I'm trying is feasible?
00:33:59 <mauke> no, I haven't :-)
00:34:04 <mauke> sorry
00:34:04 <latermuse> Ive worked a lot with websockets
00:34:13 <latermuse> made my own haskell websocket server too ;D
00:34:44 <athan> @djinn (a -> f b) -> f (a -> b)
00:34:44 <lambdabot> -- f cannot be realized.
00:35:03 <zipper> latermuse: Awesome.
00:35:20 <latermuse> checking out your code now, un momento
00:35:45 <zipper> latermuse: Can you help me with: http://lpaste.net/3386343127462707200
00:35:50 <zipper> latermuse: I've updated it
00:36:06 <latermuse> whats the problem?
00:36:14 <latermuse> type signature looks incorrect: `serverApp :: WS.ServerApp`
00:36:19 <latermuse> `serverApp pending`
00:36:29 <zipper> latermuse: I've updated the code
00:36:38 <zipper> latermuse: Reload in browser.
00:36:50 <latermuse> didnt change
00:38:00 <latermuse> your types are wrong
00:38:18 <zipper> latermuse: Isn't that the correct type for serverApp? `type ServerApp = PendingConnection -> IO ()`
00:39:11 <latermuse> WS.runServer "0.0.0.0" 4000 serverApp
00:39:15 <latermuse> then you have: `serverApp :: WS.ServerApp`
00:39:23 <latermuse> and finally `serverApp pending = do`
00:39:33 <latermuse> so you need something here: `serverApp :: a -> WS.ServerApp`
00:40:06 <latermuse> oh hm..
00:40:13 <latermuse> mine looks like this:
00:40:16 <latermuse>   WS.runServer "0.0.0.0" 4242 $ application state
00:40:21 <latermuse> application :: State -> WS.ServerApp
00:40:25 <latermuse> application state pending = do
00:40:30 <latermuse> so the same I guess
00:40:46 <zipper> latermuse: Yeah I can't see anything wrong with the types.
00:40:52 <latermuse> whats the error
00:40:56 <zipper> Since I am not using state
00:40:59 <latermuse> yep
00:42:08 <zipper> latermuse: I am calling them like so: _ <- runS; _ <- client to run the client first then the server.
00:42:19 <zipper> The error I get in my terminal is `ConnectionClosed`
00:42:23 <latermuse> need to run server first
00:42:26 <zipper> Nothing shows up in the browser
00:42:42 <zipper> Yes I am running the server first.
00:43:28 <zipper> I'm calling runS then in a new line of a do block I call cleint which should be renamed to runClient.
00:43:37 <zipper> or runC
00:45:07 <latermuse> when I try to compile your code, i get this error:     No instance for (WS.WebSocketsData T.Text)
00:45:16 <latermuse>       arising from a use of ‚ÄòWS.sendClose‚Äô
00:46:01 <latermuse> maybe different version of WS
00:46:08 <zipper> latermuse: Overloaded string is on?
00:46:11 <latermuse> yep
00:48:14 <latermuse> sorry hard to debug when we are using different versions ;)
00:48:23 <zipper> latermuse: You can fix that with: "WS.sendClose conn ("Bye!" :: BS.ByteString)"
00:48:31 <zipper> latermuse: `WS.sendClose conn ("Bye!" :: BS.ByteString)`
00:48:35 <latermuse> ok
00:48:52 <latermuse> ok worked
00:49:25 <latermuse> works fine for me
00:49:35 <latermuse> it says "Connected." when I use the server and client
00:49:48 <zipper> Please paste your code on lpaste
00:50:04 <latermuse> http://i.imgur.com/meXERm2.png
00:50:30 <lpaste_> latermuse pasted ‚Äúworks for me‚Äù at http://lpaste.net/140245
00:52:03 <zipper> latermuse: I'm using websockets 0.9.5.0. What about you?
00:52:07 <latermuse> same
00:52:15 <latermuse> ill post the list of my packages one set
00:52:16 <latermuse> one sec
00:53:01 <lpaste_> latermuse pasted ‚Äúpackages‚Äù at http://lpaste.net/140246
00:53:11 <latermuse> these are the packages I used to build this and have it work correctly
00:53:26 <latermuse> you can modify your .cabal file to be similar and it should work
00:53:29 <zipper> I don't think the issue is packages but how I called my server and client.
00:53:47 <latermuse> that could be it too
00:53:53 <latermuse> I used two GHCI instances to do it
00:53:56 <latermuse> one for server, one for client
00:54:23 <zipper> hmm maybe I should use forkIO for the server then for the client.
00:54:57 <latermuse> why not two instances of GHCI?
00:55:35 <zipper> latermuse: For some reason ghci is failing on me.
00:55:45 <zipper> I'm using stack and everything is being weird.
00:55:47 <latermuse> how so?
00:55:50 <latermuse> ah stack
00:56:00 <latermuse> I havent started using stack yet, im going to wait a few more months until its matured a bit more
00:56:24 <latermuse> im still using cabal sandboxes ;D
00:56:26 <zipper> Also it's a whole project not just a toy thing. I want to stream data to the browser using web sockets.
00:56:43 <zipper> latermuse: No cabal sandboxes are painful
00:56:48 <zipper> *websockets
00:58:03 <zipper> latermuse: it worked when I used forkIO but then I assume it called sendClose right after because then it says connection closed.
00:58:47 <zipper> latermuse: Let me reboot. I changed a few things with my packages.
00:58:55 <latermuse> ok
00:59:05 <latermuse> why are cabal sandboxes painful? theyw ork fine for me
00:59:40 <zipper> latermuse: the point was to print 2Test data" to the browser.
00:59:43 <zipper> ah
01:00:01 <zipper> latermuse: the point was to print "Test data" to the browser so I still haven't actually achieved my objective.
01:00:26 <zipper> latermuse: Uh cabal sandboxes didn't work for me all the time when pulling dependencies from github.
01:00:39 <latermuse> ah ok
01:05:54 <zipper> hello latermuse 
01:07:09 <latermuse> hi
01:10:59 <m4lvin> someone has a link to that article with the "the ghc base libraries are full of lies" punchline?
01:28:20 <Vyn> How do you go through a list till you get two adjacent elements equal (without recursion)?
01:28:30 <Vyn> [And return the element]
01:29:20 <Vyn> Cale: You there?
01:30:03 <bartavelle> Vyn, a classic trick is to work ok (zip l (tail l)) on nonempty lists
01:30:18 <bartavelle> to work on
01:32:43 <Vyn> bartavelle: Right, but without using zip (effectively using a different copy of the list), but just doing something like a terminating fold?
01:33:05 <bartavelle> there is no such thing as a different copy ?
01:33:10 <bartavelle> oh
01:33:24 <bartavelle> except if you need to construct the part that's after the consecutive elements
01:33:38 <Vyn> No, we only care about the element
01:33:42 <Vyn> that repeats.
01:34:25 <bartavelle> well then you won't get a "different copy", as tail don't produce a new list, just the reference to the next element of the list ?
01:35:11 <bartavelle> (also I don't know what a terminating fold is, so I might be out of my depth here, just saw your list 3 lines)
01:43:45 * hackagebot smallcheck-laws 0.2 - SmallCheck properties for common laws  https://hackage.haskell.org/package/smallcheck-laws-0.2 (jdnavarro)
01:43:59 <Rurik> hello
02:09:29 <athan> Anyone have ideas I should add into this? https://github.com/athanclark/listvsgeneric
02:09:53 <lpaste_> latermuse pasted ‚ÄúAny idea why this doesnt work?‚Äù at http://lpaste.net/140251
02:10:18 <latermuse> im having a bit of trouble getting 'read' to work with this code. can anybody figure out why?
02:10:34 <lpaste_> latermuse pasted ‚ÄúAny idea why this doesnt work?‚Äù at http://lpaste.net/140252
02:10:43 <latermuse> second one (the first one is bugged?)
02:11:34 <latermuse> prelude's read is pretty terrible actually
02:12:16 <Cale> latermuse: You didn't post the code
02:12:37 <aznashwan> latermuse: you made Transaction derive Read, right?
02:12:44 <latermuse> yes transaction derives read
02:12:49 <latermuse> and everything in transaction also derives read
02:12:51 <latermuse> show instances also
02:13:40 <mauris> you should add the rest of the program so others can poke at it easily!
02:13:59 <latermuse> okay, it will take me a bit to format it for lpaste though
02:14:00 <Cale> Yeah, there's no way to figure out what's going on from your ghci session there
02:14:06 <latermuse> un momento
02:14:24 <aznashwan> latermuse: only real thing out of the ordinary I see is you have underscores in some record field names; but that shouldn't break read so easily
02:16:42 <aznashwan> latermuse: also, I'm pretty sure you copied the ghci session wrong; else you have and extra pair of quotes at the beginning which should not be there
02:18:01 <aznashwan> latermuse: (at b)
02:19:26 <latermuse> I didnt copy it wrong
02:19:33 <latermuse> not sure why those quotes are there
02:19:47 <Cale> hm?
02:20:02 <Cale> You mean at the start of line 12?
02:20:12 <Cale> It's because b is a String
02:21:09 <aznashwan> Cale: yeah; but there are no closing quotes at the end there...
02:21:21 <Cale> right
02:21:26 <Cale> There ought to be
02:22:50 <aznashwan> latermuse: tried to guess how you're data structure looks, derived Show and Read standardly and tried out a show and read in ghci and it worked fine for me
02:23:17 <aznashwan> latermuse: GHCi 7.10.1 on Arch Linux
02:23:22 <Cale> oh, that is interesting
02:23:23 <latermuse> it works fine for me when I remove the '\' in the 'b' string
02:23:36 <Cale> The read instance is bad.
02:24:02 <Cale> I bet it is the initial underscore in the field name
02:24:21 <aznashwan> Cale: my initial guess as well...
02:24:42 <aznashwan> latermuse: the backslashes should not bother read in any way really
02:25:03 <latermuse> yeah
02:25:05 <Cale> er
02:25:14 <Cale> actually, no, that doesn't happen for me here
02:25:18 <latermuse> just accidentally came across this:     ‚Äòday‚Äô is not a (visible) constructor field name
02:25:20 <Cale> I forgot a type signature
02:25:23 <latermuse> maybe some of my types arent being exported correctly
02:25:46 <Cale> That shouldn't be causing runtime errors
02:25:57 <Cale> Well, hmm
02:26:05 <Cale> Do you have multiple types called Transaction?
02:26:24 <kuribas> Is semver (http://semver.org/) recommended for cabal packages?
02:26:38 <latermuse> no only one transaction
02:26:39 <Cale> If testTransaction produces something of a different type than Transaction, it would make sense
02:27:36 <Cale> kuribas: https://wiki.haskell.org/Package_versioning_policy
02:27:46 <bitonic> how can I set a lower bound to a library based on the version of another library?
02:28:15 <bitonic> specifically, I need to set a lower bound in `attoparsec` if the version of `aeson` is `>= 0.7.0.0`
02:28:19 <latermuse> testTransaction :: IO Transaction
02:28:39 <Cale> latermuse: Can I have a copy of your code?
02:28:46 <Cale> I'll see if the same thing happens on my machine
02:28:46 <fractalsea> Could anyone give some feedback on the interface of the first Haskell library I have written? https://github.com/pusher-community/pusher-http-haskell/blob/master/src/Network/Pusher.hs I‚Äôm concerned about two things: 1. I return values in a MonadReader so that the config to call the API does not need to be passed in on every call by the client. This is useful if the client needs to make multiple requests, but I suspec
02:28:46 <fractalsea> they will often only need to make 1. Do you think I should have two versions of these functions: one in the reader monad, and one that takes the config as an argument? 2. I‚Äôm not sure how to lay out the monad/typeclasses and data declarations. At the moment they are in Control.Monad.Pusher and Data.Pusher, but should all the library be under the single module Network.Pusher? Let me know if you have any other comments
02:28:47 <fractalsea> Thanks!
02:28:51 <kuribas> Cale: thanks
02:30:46 <latermuse> is there any way to get `read` to dump where in the parse it failed?
02:33:25 <lpaste_> latermuse pasted ‚Äútrace brings nothing to the table‚Äù at http://lpaste.net/140253
02:33:47 <Cale> fractalsea: I'd probably just take it as an argument -- if the user happens to be in such a reader monad, it's not hard to use a plain function.
02:33:51 <latermuse> but when I copy/paste that output from trace into its own variable, it works correctly
02:34:26 <Cale> fractalsea: But I have a rather extreme bias against using ReaderT or StateT over IO in most cases.
02:34:53 <fractalsea> Cale, thanks for the suggestion
02:35:40 <fractalsea> Cale, It probably would make the interface more simple/easy to understand
02:37:07 <Cale> latermuse: I kind of think that the MonadReader and MonadState type classes are always not quite the thing you want. Usually you'd be better served by more application-specific type classes that abstract over how things are implemented.
02:37:26 <Cale> Or almost always, anyway
02:38:48 * hackagebot cabal-sort 0.0.5.2 - Topologically sort cabal packages  https://hackage.haskell.org/package/cabal-sort-0.0.5.2 (HenningThielemann)
02:38:56 <mettekou> Does anyone know of a way to print Haskell code with syntax highlighting? Print as in on paper, not on screen.
02:39:16 <mettekou> Neither Atom nor Sublime Text seem to support printing any code.
02:39:45 <srhb> mettekou: The LaTeX listings package can do that.
02:40:06 <Cale> mettekou: There's http://hackage.haskell.org/package/lhs2tex
02:40:17 <Cale> which might be useful
02:40:46 <mettekou> Cale: Does that work for Literate Haskell only?
02:40:51 <Cale> I think so
02:41:05 <mettekou> Damn.
02:41:18 <latermuse> im writing my own read function now
02:41:29 <latermuse> going to get to the bottom of this
02:41:39 <mettekou> I'll quickly whip up the LaTeX myself then.
02:41:43 <Cale> The idea is that you use the LaTeXish Literate Haskell, and it does a bunch of stuff to the code sections to make them pretty
02:42:21 <Cale> Oh, you said *syntax highlighting* and I totally didn't read that :)
02:42:29 <Cale> hmm
02:42:58 <kuribas> or enscript?
02:43:02 <mettekou> Cale: Yeah, but I don't need any fancy stuff, just need to print some code for a school project. Yeah, the professor actually requires a printed copy for the defence, even though I'll be there with my laptop and the whole thing up and running on screen.
02:43:06 <kuribas> It's not that pretty though.
02:43:08 <Cale> http://hackage.haskell.org/package/hscolour supports lots of output formats
02:43:36 <athan> > let (<~$>) f x = ($ x) <$> f in Just (+1) <~$> 4
02:43:37 <mettekou> Cale: That seems nice.
02:43:38 <lambdabot>  Just 5
02:43:48 * hackagebot tasty-laws 0.2 - Test common laws  https://hackage.haskell.org/package/tasty-laws-0.2 (jdnavarro)
02:44:04 <athan> Has anyone come in contact with something similar ^?
02:44:40 <athan> > let (<~$>) f x = f <*> pure x in   Just (+1) <~$> 4
02:44:41 <lambdabot>  Just 5
02:44:44 <Cale> athan: that's the same thing as  f <*> pure x
02:44:46 <Cale> yes
02:45:02 <athan> :\ hm
02:45:06 <athan> thanks Cale
02:46:00 <athan> well
02:46:25 <athan> > \x f -> ($ x) <$> f :: Functor f => f (a -> b) -> a -> f b
02:46:26 <lambdabot>      Couldn't match expected type ‚Äòf1 (a2 -> b1) -> a1 -> a2 -> f1 b1‚Äô
02:46:26 <lambdabot>                  with actual type ‚Äòr‚Äô
02:46:26 <lambdabot>        because type variables ‚Äòf1‚Äô, ‚Äòa2‚Äô, ‚Äòb1‚Äô would escape their scope
02:46:34 <athan> :type \x f -> ($ x) <$> f :: Functor f => f (a -> b) -> a -> f b
02:46:43 <athan> :type \f x -> ($ x) <$> f :: Functor f => f (a -> b) -> a -> f b
02:46:46 <athan> ><
02:46:55 <athan> :t \f x -> ($ x) <$> f :: Functor f => f (a -> b) -> a -> f b
02:46:57 <lambdabot>     Couldn't match expected type ‚Äòf1 (a2 -> b1) -> a1 -> a2 -> f1 b1‚Äô
02:46:57 <lambdabot>                 with actual type ‚Äòr‚Äô
02:46:57 <lambdabot>       because type variables ‚Äòf1‚Äô, ‚Äòa2‚Äô, ‚Äòb1‚Äô would escape their scope
02:47:05 <Cale> Right, it has a more general type
02:47:33 <Cale> I would probably just write  fmap ($ x) f
02:47:48 <Cale> Unless there was a bunch of Applicative stuff nearby
02:47:51 <athan> I feel like this would be useful
02:48:08 <athan> Cale: I have a lot of that going on right now, a single replacement for <$> would be ideal
02:48:23 <Cale> Define one locally!
02:48:25 <athan> meh
02:48:48 * hackagebot mfsolve 0.2.0 - Equation solver and calculator ‡ la metafont  https://hackage.haskell.org/package/mfsolve-0.2.0 (KristofBastiaensen)
02:49:03 <athan> @djinn Functor f => f (a -> b) -> a -> f b
02:49:03 <lambdabot> Error: Class not found: Functor
02:49:12 <athan> hrm
02:49:30 <kuribas> @djinn f (a -> b) -> a -> f b
02:49:30 <lambdabot> -- f cannot be realized.
02:50:28 <mettekou> Damn, HsColour does not break long lines.
02:52:08 <kuribas> mettekou: try enscript?
02:52:29 <kuribas> http://www.gnu.org/software/enscript/
02:53:59 <mettekou> kuribas: Error no default destination available. Weird.
02:54:19 <mauris> :t liftA2 (&)
02:54:20 <lambdabot> Applicative f => f a -> f (a -> c) -> f c
02:54:25 <kuribas> mettekou: it opens for me...
02:54:29 <mettekou> Hadn't installed my printer yet, apparently. Never needed it.
02:54:37 <mettekou> kuribas: Not the link, the command. :P
02:54:42 <kuribas> ah :)
02:55:10 <kuribas> it does write directly to the printer.  Better use the "-o file" flag
02:55:22 <kuribas> It will write a postscript file.
03:16:37 <vozz> I had a job interview recently, and I got stumped by a question in Haskell about traversing trees. I had to write a tree data type and then traverse it, and I ended up with something similar to this: http://lpaste.net/140254 They didn't like the (++) and wanted me to write it in such a way that you construct the list with (:) only so that it is more efficient, and I'm not appending to the end of a list. How
03:16:39 <vozz> would I do that?
03:17:30 <vozz> I find myself using (++) a lot and I think it's quite a bad habit I've picked up
03:18:33 <Walpurgisnacht> redundant brackets mang
03:18:56 <Walpurgisnacht> I don't see a problem with the (++) 
03:19:43 <Walpurgisnacht> more efficient?
03:20:39 <yuokl> hello, "[a | u<-[2..999999], if (listPrime (circles u) == True) then let a = 1 else let a = 0]" what is wrong about this code? i wrote circles, listPrime functions. The errors is "<interactive>:57:62:     parse error in let binding: missing required 'in'"
03:21:36 <kuribas> vozz: https://hackage.haskell.org/package/dlist-0.5/docs/Data-DList.html
03:21:51 <kuribas> vozz: it's not always bad, but you must be careful.
03:22:43 <vozz> You have to append a list to another list which is O(n), they were thinking of a way that you returned a function that took an element and added it to the list that isn't evaluated yet using (:). I'm explaining it badly. 
03:22:54 <vozz> and then the list would be fully constructed all in one go
03:23:01 <vozz> at the end
03:23:20 <kuribas> vozz: that's what DList does
03:23:28 <vozz> ah
03:23:50 * hackagebot smallcaps 0.6.0.1 - Flatten camel case text in LaTeX files  https://hackage.haskell.org/package/smallcaps-0.6.0.1 (StefanBerthold)
03:24:06 <kuribas> vozz: append is just composition
03:24:21 <kuribas> https://hackage.haskell.org/package/dlist-0.5/docs/src/Data-DList.html#append
03:25:19 <vozz> interesting
03:26:38 <vozz> Yeah I think they were expecting me to implement difference lists... Thanks a lot! I'll give it a read.
03:28:14 <kuribas> That's because (++) will walk each element several times, while composition evaluates each argument just once.
03:29:05 <kuribas> vozz: out of curiosity, what other questions did they ask?
03:29:52 <kuribas> Would they expect you to know ghc extensions like type families, GADTS, etc for a job interview?
03:32:51 <vozz> They wanted me to write a function that returns a list of fibonacci numbers up to n, I was panicky and wrote an inefficient one, I think it was O(n^2), then they wanted me to write an infinite lazy list of fibonacci numbers. It wasn't a haskell specific interview, but I completed the programming task in Haskell because that was what I was most comfortable with and had an environment on my computer I knew
03:32:53 <vozz> worked (I wasn't expecting to have to program on my computer) and so for the next section they brought in some ruthless haskell guy who was faster at pointing out mistakes than ghc :) 
03:33:46 <_d0t> ohai
03:33:51 * hackagebot contravariant 1.3.3 - Contravariant functors  https://hackage.haskell.org/package/contravariant-1.3.3 (EdwardKmett)
03:34:12 <_d0t> i got this piece of code using lifted-async and monad-control I'm trying to get to work https://bpaste.net/show/12f7f4a45372
03:34:24 <_d0t> but I'm getting a error message I don't know how to tackle
03:34:25 <_d0t> https://bpaste.net/show/6ee05bb5e5a5
03:35:35 <kuribas> vozz: an infinite lazy list is going to be much easier in haskell that in any other language.
03:35:45 <_d0t> StM is a type from MonadBaseControl typeclass
03:36:12 <vozz> kuribas: They asked that as a follow up to the fibonacci question I believe soley because I used haskell, they wouldnt have asked it otherwise
03:36:25 <kuribas> vozz: ah, I see :)
03:36:46 <kuribas> vozz: it's not a really good question, since that example is used all the time.
03:37:05 <vozz> I completely choked though :( I think had I stuck to more run-of-the-mill languages I would have done fine, despite having used haskell more than anything else
03:37:39 <kuribas> > let fibs = 1:zipWith (+) fibs (fail fibs) in take 20 fibs
03:37:41 <lambdabot>      No instance for (Num Char) arising from the literal ‚Äò1‚Äô
03:37:41 <lambdabot>      In the first argument of ‚Äò(:)‚Äô, namely ‚Äò1‚Äô
03:37:41 <lambdabot>      In the expression: 1 : zipWith (+) fibs (fail fibs)
03:38:00 <yuokl> I'm reposting it sorry about that :( "[a | u<-[2..999999], if (listPrime (circles u) == True) then let a = 1 else let a = 0]" what is wrong about this code? i wrote circles, listPrime functions. The errors is "<interactive>:57:62:     parse error in let binding: missing required 'in'"
03:38:02 <kuribas> > let fibs = 1:zipWith (+) fibs (tail fibs) in take 20 fibs
03:38:06 <lambdabot>  mueval-core: Time limit exceeded
03:38:13 <kuribas> vozz: nerves probably
03:38:21 <vozz> I got to fibs = 0:1: then got stuck as to how I could make the next bit a function of the last two
03:38:39 <vozz> Didn't think of using a zipWith with the tail
03:38:54 <kuribas> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in take 20 fibs
03:38:55 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
03:40:17 <srhb> yuokl: That form of let declaration is now allowed like that. Perhaps you meant let a = if (listPrime (circles u)) then 1 else 0
03:41:00 <srhb> And there's a redundant parens there.
03:41:18 <yuokl> srhb thank you very much <3 i love you
03:41:26 <srhb> yuokl: Also I took the liberty of shortening if foo == True to if foo, since that's always equivalent.
03:41:44 <kuribas> vozz: asking for fibonacci or primes doesn't really show skill, since it's very likely that someone has already seen the exmample.
03:43:51 * hackagebot composition-extra 1.2.0 - Combinators for unorthodox structure composition  https://hackage.haskell.org/package/composition-extra-1.2.0 (athanclark)
03:45:02 <vozz> Yeah... the first thing they got me to do was leave me alone to program something in any language. They wanted me to do monte carlo simulations of a golf tournament, where performance of each player is distributed normally (and they were fine with rounding to a number). I was doing fine on that but took a bit too long I think. Then two guys came in, one asking me questions I had to write answers to on paper
03:45:04 <vozz> (the fibonnaci and the tree thing), and another asking me stuff about unix commands.  
03:47:35 <yuokl> @srhb, i changed my code to this [1 | u<-[2..999999], listPrime (circles u)] because i only need the sum of the list. so 0 are not necessary. I think it's good looking. what you think? :)
03:47:36 <lambdabot> Unknown command, try @list
03:47:44 <vozz> This was the way I was wanting to solve the fibonnaci infinite list: http://lpaste.net/140257 I couldn't think how the syntax actually worked though
03:54:18 <justatech> What is the difference between port forwarding and open port 
04:02:53 <zipper> Hello is there a way I can call L25 in the below code http://lpaste.net/3386343127462707200#line25
04:03:01 <justatech> Open port is safe or port forwarding 
04:03:24 <zipper> but line 25 only with a different bytstring value each time.
04:04:13 <srhb> zipper: call a line? What do you mean?
04:04:38 <srhb> zipper: Your server function can take the bytestring as an argument, or you can create another function which does that.
04:04:54 <zipper> I mean call the function WS.sendTextData conn many times with a different bytestring value
04:05:04 <srhb> zipper: What different value do you want?
04:05:13 <zipper> srhb: I don't know beforehand
04:05:18 <srhb> Well, where do you get it from?
04:05:37 <zipper> I want to replace this with `print`
04:05:48 <zipper> I have a function that repeatedly calls print
04:06:47 <zipper> I want to replace it with e.g a way to call runS with the required ByteString but not to have it try create the server and everything again.
04:06:59 <zipper> srhb: Am I making sense? :(
04:07:55 <srhb> zipper: Not completely, but I think what you want to do is replace line 25 with forever (or until some event..) $ do { WS.sendTextData ... } but it's unclear exactly where you get the bytestring to send from.
04:08:52 <zipper> srhb: Let me show you better
04:08:54 <srhb> zipper: If for instance you said you have a list of bytestrings, I'd say mapM_ (sendTextData conn) yourListOfByteStrings, but again, I don't know where they come from.
04:10:06 <srhb> zipper: or maybe you want something like loop conn = do { msg <- thingTogetByteString; if msg /= "quit" then sendTextData conn msg >> loop else return () -- or something similar.
04:10:27 <zipper> srhb: Here the last argument https://hackage.haskell.org/package/ide-backend-0.10.0/docs/IdeSession.html#v:updateSession
04:11:46 <srhb> zipper: Sorry, I have to leave now, if I didn't get you started perhaps someone else can take over. :)
04:11:57 <zipper> srhb: Okay
04:20:00 <jmcarthur> zipper: so you want to use sendTextData repeatedly with the same connection?
04:20:09 <zipper> jmcarthur: Yes
04:20:31 <zipper> but different text data
04:20:53 <zipper> I'm starting to wonder whether websockets were the right tool for this job.
04:21:27 <jmcarthur> zipper: is something preventing you from creating a connection and holding on to it for a while?
04:22:42 <zipper> Yes my attempts to manually create one fail at the socket. There isn't a clear way to create a connection. Let me demonstrate.
04:23:14 <jmcarthur> zipper: isn't that what acceptRequest does?
04:23:41 <zipper> jmcarthur: It fails. Let me demonstrate. Just a minute. It compiles but fails at runtime.
04:23:58 <jmcarthur> the program as it currently is written fails?
04:24:10 <jmcarthur> or do you mean when you try to use acceptRequest in a different way?
04:24:16 <jmcarthur> okay
04:24:21 <zipper> When I try it in a different way
04:24:23 <jmcarthur> brb
04:29:51 <jmcarthur> back
04:30:05 <zipper> jmcarthur: Okay so this is the code http://lpaste.net/3386343127462707200 the error is: `recv: invalid argument (Transport endpoint is not connected)`
04:30:12 <zipper> jmcarthur: Just in time
04:32:41 <zipper> jmcarthur: Wait, no I fixed it
04:32:45 <zipper> I think so far.
04:32:55 <zipper> `(sock, _) <- accept sock'`
04:33:23 <zipper> But the main objective still hasn't been achieved. I can however work with my manually created connection
04:34:08 <jmcarthur> well now that you have a connection you can just use it more than once, can't you?
04:34:53 <zipper> jmcarthur: Yeah but there's an issue in the order in which I will call the server and client. Let me work on it some more and see.
04:37:03 <Rurik> are all function compositions monoids?
04:37:11 <Rurik> speaking from a math point of view
04:37:52 <chpatrick> Rurik: . and id form a monoid right?
04:38:00 <kqr> sounds about right
04:38:17 <Rurik> chpatrick, no idea
04:38:26 <dramforever> Rurik: check Endo
04:38:36 <Rurik> Endo?
04:38:44 <chpatrick> dramforever: that's only for a -> a though
04:39:05 <dramforever> yep
04:39:11 <chpatrick> Rurik: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Category.html
04:39:31 <pavonia> When you have several types of the form "data Foo = FooNone | FooA A | FooB B", is it better to rewrite this to "data Foo = FooA A | FooB B" and use "Maybe Foo" instead of the original type?
04:39:51 <kqr> i'd say that depends on your domain and what you are modelling
04:39:55 <kqr> functionally, they are equivalent
04:40:06 <eikke> pavonia: depends. if FooNone has a distinct meaning in the domain, that deserves a constructor
04:40:08 <dramforever> http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html#t:Endo
04:40:51 <dramforever> pavonia: if you find yourself writing functions that can't work with FooNone, then the Maybe one is probably better
04:41:01 <pavonia> kqr, eikke: It has no special meaning beside the non-presence of a Foo value
04:41:19 <kqr> then maybe sounds great
04:41:25 <eikke> pavonia: when I use Maybe in some design, Nothing is mostly saying there's no value in the domain, whilst 'no value' could be acceptable inside the domain
04:41:26 <chpatrick> pavonia: I think I would personally
04:41:30 <eikke> pavonia: then go maybe :)
04:41:33 <chpatrick> that means you can use any existing Maybe combinator
04:42:13 <pavonia> Okay, thanks
04:44:21 <kqr> you could think of it this way: if you had a list of foo values, would you create a list of FooNone values or would it just be an empty list
04:44:29 <kqr> if the latter, then Maybe is probably also the right fit
04:46:04 <pavonia> Yeah, I'm going through the types and there are actually some types where I want the None constructors
04:48:54 <tero-> can I turn .cabal-wide LANGUAGE pragmas off for individual modules? e.g. disable OverloadedStrings for one module
04:50:56 <dramforever> tero-: try NoOverloadedStrings
04:53:29 <tero-> dramforever: great, thanks
04:53:46 <dramforever> yw
04:54:00 <kqr> dramforever, what does your nick mean? i've always associated it with whisky
04:57:30 <dramforever> kqr: nothing much, just something that isn't taken
04:57:38 <dramforever> *wasn't
04:57:54 <kqr> okay
05:07:16 <tero-> I thought you like DRAM memory chips
05:19:30 <latermuse> woah
05:19:38 <latermuse> im still debugging that problem with the 'Read' instance from earlier
05:19:42 <latermuse> and ive gotten GHC to panic over it
05:19:45 <latermuse> ghc: panic! (the 'impossible' happened)
05:19:54 <latermuse> maybe found a compiler bug ;D
05:44:14 <Sindriav_> tero- + 1, I also thought that :D
05:46:25 <Sindriav_> Aren't monads supposed to be monoids?
05:48:33 <Sindriav_> Why doesn't `Monad a => IO a <> IO a` work?
05:48:38 <Sindriav_> *Monoid a
05:48:57 * hackagebot ini 0.3.2 - Quick and easy configuration files in the INI format.  https://hackage.haskell.org/package/ini-0.3.2 (ChrisDone)
05:49:08 <ski> what would you prefer it to do ?
05:49:14 <ski> what would the neutral element be ?
05:49:16 <dramforever> :t liftA2 (<>)
05:49:17 <lambdabot> (Applicative f, Monoid c) => f c -> f c -> f c
05:49:24 <dramforever> this maybe?
05:51:03 <ski> hm, perhaps
05:57:07 <tsani> What are the performance penalties of using liftIO in a MonadIO rather than directly performing IO in the IO monad ?
05:58:19 <tsani> I'm interested in the both the cases where MonadIO m has m ~ IO and the cases where the monad is a newtype wrapper over a transformer stack over IO
06:00:12 <sshine``> tsani, http://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-IO-Class.html
06:00:39 <tsani> haha
06:00:47 <tsani> Well that explains the m ~ IO case ! 
06:00:51 <ski> considering `MonadIO m', when `m = IO', `liftIO = id'. for `m's built on `IO', `liftIO' will need to basically do the same as `return', except using the supplied `IO'-action instead of `return' for `IO'
06:01:12 <sshine``> what ski says!
06:01:13 <ski> (note that `liftIO . return = return' is a law of `MonadIO')
06:02:30 <sshine``> ski, can't both k and i be expressed in terms of s?
06:02:46 <tsani> ski: and `lift . return = return` is a general law for transformers right ?
06:03:30 <ski> if you're deriving `MonadIO' for a `newtype' using `GeneralizedNewtypeDeriving', then operationally `liftIO' for the new type should be the same as the one for the wrapped type
06:03:35 <ski> sshine`` : yes
06:03:37 <sshine``> isn't lifting generally free?
06:03:50 <ski> tsani : ues
06:03:57 <ski> sshine`` : no
06:04:12 <aweinstock> sshine``: I thought {S,K} was the minimal set (w.r.t. the SKI calculus)
06:04:21 <sshine``> aweinstock, so did I until about a year ago.
06:04:57 <tsani> ski: thanks :)
06:05:04 <ski> (also, what do you mean by "lifting generally" ? `lift :: forall t m a. (MonadTrans t,Monad m) -> m a -> t m a' specifically ? also (instead ?) including some other operation(s) ?)
06:05:24 <ski> sshine``,aweinstock : er, sorry. i misread
06:05:27 <sshine``> aweinstock, I guess "The S-calculus" wasn't a good name. I tried persuading my uni skiing club to change their name from "DIKU SKI" to "DIKU SK" or "DIKU S", but they don't appreciate the humour or the conciseness.
06:05:46 <ski> using only `s' (and application), you can't express `k'
06:06:02 <sshine``> ski, oh. isn't there a single-combinator calculus, then?
06:06:31 <aweinstock> I seem to remember reading about a single-combinator calculus, I'm trying to find it now
06:06:54 <ski> `s' embodies contraction. `k' weakening/thinning
06:07:07 <ski> (there's also a third term for the latter, but it eludes me atm)
06:07:23 <ski> sshine`` : it's sometimes called `x'
06:07:25 <dramforever> here we go https://en.wikipedia.org/wiki/Combinatory_logic#One-point_basis
06:07:30 <aweinstock> https://en.wikipedia.org/wiki/Iota_and_Jot
06:07:54 <humanoyd> I have a data constructor "Something String String" and the relevant strings in a tuple myTuple = (String, String). Is there a better way than "Something (fst myTuple) (snd myTuple)"?
06:08:32 <ski>   uncurry Something myTuple
06:08:35 <sshine``> I like how `=^{Œ∑Œ≤}` must be pronounced.
06:08:40 <ski>   Something `uncurry` myTuple  -- or
06:08:44 <ski> humanoyd ^
06:08:52 <sshine``> dramforever, thanks.
06:08:53 <aweinstock> "is equivalent modulo eta and beta reduction"?
06:08:55 <dramforever> =)
06:09:23 <humanoyd> ski: Thanks!
06:09:29 <ski> aweinstock : yes ?
06:09:33 <sshine``> aweinstock, or "eta-beta-equivalent" ;P
06:12:40 <ski> aweinstock : "are related by the finest equivalence relation generated by eta- and beta- reduction"
06:34:11 <guiraldelli> hi, guys! I have a question concerning stack. I have ghc 7.10 installed and I want to install ghc-mod, which is not allowed because it isn't listed in the Stackage repo (LTS 3.*). By the other hand, LTS 2.22, which requires ghc 7.8.4, has ghc-mod. What have I tried? `stack setup 7.8` to set my environment and then `stack install ghc-mod` (and `stack install ghc-mod-5.2.1.2`), which has failed. Do you guys have an idea of how I can globally 
06:34:11 <guiraldelli> install ghc-mod-5.2.1.2 and force stack to use the ghc 7.8.4 to build it?
06:35:20 <clrnd> guiraldelli, I think there is no concept of "globally" for stack, I'd clone the repo and install it from there
06:35:51 <clrnd> or init an empty dir, maybe? with an empty project. shitty answer I know
06:36:08 <guiraldelli> `stack install [package name]` works as `cabal install [package name]`. That is what I call as "global".
06:36:42 <clrnd> yeah but what resolver does it use? isn't that specified in stack.yaml?
06:36:46 <dexterph> i thought there was a concept of globally, if i run stack outside of a project directory i get 'run from outside a project, using implicit global config'
06:36:46 <blair`> :bn
06:36:53 <clrnd> oh
06:37:01 <dexterph> it's in ~/.stack/global/stack.yaml
06:37:08 <guiraldelli> dexterph, you're totally right.
06:37:15 <clrnd> there it is! Using resolver: lts-2.18 from global config file: /home/alvarez/.stack/global/stack.yaml
06:38:03 <guiraldelli> when I tried to use the resolver lts-2.22, stack complained my ghc is 7.10, not 7.8.
06:38:17 <dexterph> did you try stack setup
06:38:25 <guiraldelli> that's the reason I went for `stack setup 7.8`.
06:38:43 <dexterph> ah okay, missed that, my fault
06:39:12 <guiraldelli> in this second, I am trying `stack ghc --package ghc-mod --resolver lts-2.22`: let us see if it solved the problem.
06:41:12 <dexterph> oh, i think there's a stack channel, #haskell-stack
06:43:31 <ricardoguiraldel> Well, it seems that my approach has worked! :)
06:43:59 <dexterph> great
06:46:44 * dramforever is cold, so he goes to install lens (yes literally and not joking)
06:47:55 <dramforever> but looks like the download is going to take a while...
06:48:07 <guiraldelli> thank you, guys. The approach has worked. :)
06:49:57 <clrnd> guiraldelli, then, `stack ghc` installed it?
06:50:11 <clrnd> oh yeah, I remember that installing is just 'copy-files'
06:51:15 <guiraldelli> Actually, it hasn't, because ghc complained it hasn't received any parameter. Then I tried again `stack install ghc-mod --resolver lts-2.22` and it successfully worked.
06:52:51 <hodapp> I'm so smart I just invented a brilliant new combinator to help me chain things together in my fancy new monad.
06:53:02 <hodapp> then I realized I had just invented (=<<).
06:53:08 <guiraldelli> So as I could understand, I have the default MinGHC 7.10 installed, which seems to be the one stack is using by default, and then I have the MinGHC 7.8 which was installed through `stack setup 7.8` for installing things from stack --resolver lts-2.22
06:53:38 <clrnd> I'd like itf GHC had a warning for "this already exists, silly you"
06:53:47 <sm> guiraldelli: the snapshot you select (eg with --resolver) determines the GHC version used
06:53:51 <clrnd> itf? lol there it is, a new combinator
06:54:09 <clrnd> -Wall -Wkmett
06:54:20 <geekosaur> more like -Whoogle >.>
06:54:50 <sm> clrnd: +1, it already does this for names inscope, why not function type signatures in hoogle
06:54:58 <guiraldelli> sm, I notice that. Since the default resolver is lts-3.*, stack uses that when needed. Very insteresting approach, I must say.
06:56:38 <guiraldelli> Since my first use of stack last night, I went from extremelly disappointed to "wow!" moments. I am impressed by this tool, in this moment. Kudos for the maintainers. :)
06:57:22 <sm> what disappointed you ?
06:57:35 <hodapp> but, hey, now I guess I see why (=<<) can be more useful than (>>=) in certain circumstances
06:58:06 <hodapp> I had a <- foo1 b; b <- foo2 c; c <- foo2 d; and so on (with Recursive Do & mdo) and I saw this and thought that there must be a way to abstract out this 'chaining'
07:00:52 <nshepperd> (=<<) = flip (>>=)?
07:00:54 <zipper> Been working with websockets and just now I see that I have no idea how to make that info show up in the browser. 
07:01:08 <zipper> guiraldelli: Stack is a win
07:01:36 <hodapp> nshepperd: probably
07:02:11 <nshepperd> I think it needs a MonadFix constraint if it wants to make the effects happen in the opposite order
07:02:17 <guiraldelli> sm, last night, when I tried to build my project, I got problems with a package that isn't in Stackage. I tried to configure the extra-deps, but I haven't had success so far.
07:02:30 <guiraldelli> Actually, I am trying it right now to see if it works.
07:03:32 <sm> guiraldelli: often, it will suggest the line(s) to add to your extra-deps
07:03:52 <zipper> Who came up with websockets? Why do I know so little about them? Why is there almost no time to learn anything. :(
07:04:09 <mariusmarius> zipper: when you come up with an answer to the third question, tell me
07:05:51 <guiraldelli> It suggests, but haven't worked so far. But I was asleep and haven't had patience to see in depth the problems. I will take a look in a moment and, certainly, I will come back here.
07:06:16 <hodapp> nshepperd: MonadFix was already established with RecursiveDo & mdo
07:06:17 <zipper> guiraldelli: You're having problems with stack?
07:06:24 <zipper> guiraldelli: Maybe I can help.
07:06:33 <hodapp> nshepperd: the stuff I wrote will not build without that, I don't think
07:07:10 <zipper> guiraldelli: Show me your stack.yaml
07:07:44 * Intolerable "show me your stack.yaml" *winks*
07:08:14 * hodapp thwaps Intolerable
07:08:24 <thewormkill> guys, I'm experiencing a weird problem: When I pass some input to my program via a command-line argument, an URI is built from it (and some other data) and everything works fine. As soon as I make my program read the same data from a file via readFile, parseURI returns nothing, although I am completely sure that it gets the same input
07:08:51 <Intolerable> trailing spaces / newlines?
07:08:53 <geekosaur> thewormkill: can you show your code for both cases?
07:08:58 <mariusmarius> thewormkill: have you checked for 
07:09:04 <mariusmarius> thewormkill: \n \t etc
07:09:24 <thewormkill> the trailing newlines could be the culprit, I'll check
07:09:49 <mariusmarius> thewormkill: they won't be present in the command line argument, but they will be in the file
07:10:32 <thewormkill> yeah, there is a newline. I just didn't assume it is there when passing an arg like so:
07:10:46 <thewormkill> ".... -a $(cat file) ....
07:11:02 <thewormkill> thanks everybody :)
07:11:04 <geekosaur> $() removes the last newline automatically
07:11:18 <geekosaur> also that can be $(<file)
07:11:21 <mariusmarius> :)
07:11:28 <thewormkill> oh. another thing I didn't know
07:11:31 <sm> ooh, handy
07:11:33 <thewormkill> ^
07:11:56 <guiraldelli> zipper, I will return to you very, very soon...
07:12:05 <mariusmarius> geekosaur: that is bash syntax right
07:12:22 <geekosaur> from ksh originally
07:12:35 <geekosaur> not sure if it's still in POSIX (they removed a lot of ksh-isms recently)
07:12:36 <mariusmarius> ok, very handy
07:12:38 <guiraldelli> Now I am in a middle of a situation, but I will come back to it. :) In advance, thank you for your interest in my problem. :)
07:13:17 <sm> thewormkill: sticking traceShowId in front of your data is sometimes helpful to see what's in it
07:16:31 <nshepperd> interesting, it's possible to write 'instance MonadFix m => Monad (Backwards m)'
07:16:37 <nshepperd> I wonder if that's lawful though
07:16:41 <geekosaur> yeh, it looks like that was removed from the latest POSIX spec, but it was in POSIX for long enough that most POSIX compliant shells still support it. (and the way the bash devs seem to think, it might conceivably be removed from bash as a result!)
07:17:41 <mariusmarius> geekosaur: for some reason I thought POSIX only had accretions‚Ä¶I didn't know things were ever removed
07:18:03 <geekosaur> I'm still rather annoyed with them for ripping out most of the stuff they added from ksh
07:18:14 <geekosaur> POSIX is no longer a standard, it's just a marketing stunt
07:18:22 <thewormkill> sm: okay, I'll look into that. I just put a putStrLn in my main to look at it and didn't see any additional newlines, only a show revealed them
07:18:35 <thewormkill> that's why I became confused
07:18:38 <mariusmarius> geekosaur: I am curious to learn more‚Ä¶I'll ask in #haskell-blah
07:22:54 <sm> thewormkill: yes, putStr interprets control characters, so either use one of the trace functions or putStr . show
07:23:02 <sm> (to see those)
07:23:49 <thewormkill> yeah, I assumed that putStrLn would reveal a trailing newline, since two newlines would be prnted in total
07:25:43 <sshine``> sm, rather, the terminal interprets those.
07:26:47 <sm> sshine``: right. putStr does not quote them with \.
07:54:24 <zipper> Hello, I have a small issue with understanding websockets in haskell.
07:54:38 <clrnd> zipper, ok
07:54:44 <zipper> How does one invoke a hamlet file?
07:55:00 <clrnd> zipper, how is that related to websockets?
07:55:27 <zipper> clrnd: I want to stream data to a browser.
07:55:38 <zipper> clrnd: I think it's very much a websockets thing.
07:55:52 <clrnd> afaik websockets just recieve a string
07:56:35 <zipper> clrnd: Well yeah but say I want this string to show up in my browser.
07:57:00 <geekosaur> the point might more be that hamlet is a yesod specific thing. websockets are not a yesod specific thing
07:57:14 <geekosaur> and you didn't say which of the various web frameworks you were using
07:57:30 <zipper> Okay say I just want to use simply html then
07:57:44 <zipper> geekosaur: ^
07:58:04 <geekosaur> not sure that helps. you have a yesod question, you might look for a yesod venue
07:58:14 <clrnd> using renderHtml ?
07:58:37 <clrnd> are you using yesod-websockets?
07:58:42 <zipper> No
07:58:55 <zipper> geekosaur: No I don't have a specific yesod question
07:59:24 <zipper> I just want to make data show up in my browser for now.
07:59:39 <zipper> Looking at this: https://github.com/jaspervdj/websockets/tree/master/example
07:59:41 <geekosaur> ... hamlet is now not part of yesod then?
07:59:53 <zipper> geekosaur: I don't have to use hamlet.
08:01:15 <zipper> I just want to use websockets to stream data to my browser.
08:01:18 <clrnd> zipper, then is your question how to send a string over websocket?
08:01:21 <clrnd> right, let's see
08:01:24 <geekosaur> in any case, I thought the point of websockets was to support non-html data. so you want to do html with it. are you sure you want websockets?
08:01:56 <zipper> I'm not sure I want websockets. I just want to stream data to my browser really.
08:02:33 <zipper> BUt I've invested so much effort in websockets leaving it now would suck.
08:02:33 <geekosaur> and "stream data to your browser" is ... rather under-defined
08:02:44 <clrnd> WS.sendTextData
08:02:55 <clrnd> does that jaspervdj example work?
08:03:33 <geekosaur> I suggest you want to leave it unless you want to run a javascript applet in the browser receiving websocket data and somehow interpreting html in it (which mnay well require either browser specific hacks or reimplementing html rendering in javascript!)
08:04:04 * hackagebot pusher-http-haskell 0.1.0.0 - Haskell client library for the Pusher HTTP API  https://hackage.haskell.org/package/pusher-http-haskell-0.1.0.0 (willsewell)
08:04:13 <zipper> clrnd: Yes it works.
08:04:36 <zipper> but when I send text data the client recieving it is also written in haskell.
08:04:54 <geekosaur> ?
08:04:54 <zipper> So I am for now just making the client print to the terminal
08:05:16 <geekosaur> you really do need to provide some mroe detail, I think
08:05:38 <clrnd> zipper, mmmm so it works! what do you wanna do then?
08:05:53 <clrnd> (I assumed it did print something)
08:06:23 <zipper> clrnd: No I just want it to have that data show up on the browser and not the terminal
08:06:25 <geekosaur> I mean, the way you normally "stream data to the browser" is it connects to your web server using http, which sends it html
08:06:28 <zipper> Yes it works
08:06:49 <zipper> geekosaur: What if you want to append html to the currently existing html?
08:06:54 <clrnd> zipper, wait wait, the browser only knows javascript, you need to compile haskell to javascript if you want to program in haskell
08:07:10 <clrnd> that repository contains an example of that
08:07:14 <zipper> clrnd: I have no problem writing JS
08:07:18 <clrnd> of js I mean
08:07:26 <geekosaur> zipper: Domain Object Model
08:07:49 <clrnd> zipper, great! then, what's the problem with the solution in that repository?
08:08:15 <zipper> clrnd: I don't know how to invoke the html file from my haskell code.
08:08:32 <geekosaur> so, maybe you do want websockets in this case and a small js thing that appends to document.body for the current window (or, perhaps better, a frame/iframe within the window)
08:08:48 <clrnd> zipper, right, I think that, in client.hs, you need to invoke sendTextData with the xtml as a string
08:08:50 <zipper> geekosaur: Yes I do :)
08:09:06 <geekosaur> you might want to study how DOM manipulation works in general before worrying about the Haskell side; you will then have some idea of what the Haskell side looks like
08:09:26 <zipper> geekosaur: I have the haskell side up and running already.
08:09:34 <geekosaur> s/Domain/Document/ sorry
08:09:43 <geekosaur> not if it doesn't speak what the browser needs, you don't
08:09:52 <geekosaur> and for that part you need the DOM
08:19:05 * hackagebot haskore 0.2.0.6 - The Haskore Computer Music System  https://hackage.haskell.org/package/haskore-0.2.0.6 (HenningThielemann)
08:22:46 <obadz> Is liftA2 (.) not an operator out there?
08:23:21 <Intolerable> :t liftA2 (.)
08:23:23 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
08:24:39 <Nik05> just use fmap
08:25:09 <_d0t> speaking of, why isnt map generalized?
08:25:14 <_d0t> like map = fmap
08:25:19 <chpatrick> history
08:25:20 <Ankhers> > liftA2 (.) (Just (+2)) (Just (*4)) (Just 5)
08:25:21 <obadz> _d0t: educational
08:25:22 <lambdabot>      Couldn't match expected type ‚ÄòMaybe Integer -> t‚Äô
08:25:22 <lambdabot>                  with actual type ‚ÄòMaybe (Integer -> Integer)‚Äô
08:25:22 <lambdabot>      The function ‚ÄòliftA2‚Äô is applied to four arguments,
08:25:29 <chpatrick> :i Static
08:27:10 <obadz> I guess my question is, how do you write this points-free: \ x -> getCompose $ (+ 1) <$> Compose x
08:27:17 <obadz> without liftA2 (.)
08:27:19 <greenrd> edwardk: is there a way of stopping a machine early, other than by returning a Left to deconstruct?
08:27:49 <Ankhers> @pl \x -> getCompose $ (+ 1) <$> Compose x
08:27:50 <lambdabot> getCompose . ((1 +) <$>) . Compose
08:28:15 <shachaf> i,i under (_Compose . mapped) (+1)
08:28:45 <obadz> grrr that seems too easy
08:28:52 <chpatrick> :t fmap (fmap (+1))
08:28:54 <lambdabot> (Functor f, Functor f1, Num b) => f (f1 b) -> f (f1 b)
08:28:54 <obadz> @pl \ (a, b) 
08:28:54 <lambdabot> (line 1, column 10):
08:28:54 <lambdabot> unexpected end of input
08:28:54 <lambdabot> expecting operator, pattern or "->"
08:29:06 <obadz> @pl \ (a, b) \ (c, d) -> (b, d)
08:29:06 <lambdabot> (line 1, column 10):
08:29:06 <lambdabot> unexpected "\\"
08:29:06 <lambdabot> expecting operator, pattern or "->"
08:29:14 <obadz> @pl \ (a, b) -> \ (c, d) -> (b, d)
08:29:14 <lambdabot> (. snd) . (,) . snd
08:29:15 <Ankhers> @pl (a, b)
08:29:16 <lambdabot> (a, b)
08:29:17 <obadz> (sorry for spam)
08:29:30 <Ankhers> The '\' is for a lambda function.
08:29:34 <shachaf> Better than spam + apology is using /msg.
08:29:59 <chpatrick> obadz: fmap (fmap (+1))
08:30:01 <obadz> well spam + apology is still better than spam :)
08:31:07 <shachaf> Unclear.
08:37:36 <obadz> so the pointsfree tool comes up with (`ap` snd) . (. fst) . const . (,) . snd for the same expression
08:44:06 * hackagebot log-domain 0.10.2.1 - Log-domain arithmetic  https://hackage.haskell.org/package/log-domain-0.10.2.1 (EricMertens)
08:44:08 * hackagebot test-framework-hunit 0.3.0.2 - HUnit support for the test-framework package.  https://hackage.haskell.org/package/test-framework-hunit-0.3.0.2 (EricMertens)
08:49:06 * hackagebot HPDF 1.4.8 - Generation of PDF documents  https://hackage.haskell.org/package/HPDF-1.4.8 (alpheccar)
08:50:21 <Xnuk> @pl 
08:50:21 <lambdabot> (line 1, column 1):
08:50:21 <lambdabot> unexpected end of input
08:50:21 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:50:51 <Xnuk> @pl \x -> f x ++ g x ++ h x
08:50:51 <lambdabot> liftM2 (++) f (liftM2 (++) g h)
08:51:18 <Twey> Is there a way to get GHC to go back to naming fresh type variables ‚Äòa b c d‚Äô instead of ‚Äòt1 t2 t3 t4‚Äô?
08:51:49 <Twey> I've tried to like it, but I find it really hurts readability of type signatures.
08:54:06 * hackagebot github-webhook-handler 0.0.4 - GitHub WebHook Handler  https://hackage.haskell.org/package/github-webhook-handler-0.0.4 (wereHamster)
08:54:08 * hackagebot github-webhook-handler-snap 0.0.4 - GitHub WebHook Handler implementation for Snap  https://hackage.haskell.org/package/github-webhook-handler-snap-0.0.4 (wereHamster)
08:56:14 <Twey> Xnuk: liftA3 ((++) .: (++)) f g h ?
08:56:28 <Cale> Twey: I don't know, but I think when it unifies type variables, it prefers names that were explicitly given
08:56:36 <Xnuk> :t .O
08:56:38 <lambdabot> parse error on input ‚Äò.‚Äô
08:56:40 <Xnuk> :t .:
08:56:42 <lambdabot> parse error on input ‚Äò.:‚Äô
08:56:42 <Twey> (++) .: (++) <$> f <*> g <*> h  ?
08:56:48 <Cale> Twey: So adding type signatures which mention variables explicitly may help
08:56:50 <Twey> Xnuk: (.:) = (.) . (.)
08:57:20 <Xnuk> It seems like emoji
08:57:23 <Twey> Cale: I mostly run into it when I want to use :t to check the type of an expression
08:57:27 <Xnuk> (.) . (.)
08:58:01 <Twey> Xnuk: https://wiki.haskell.org/Pointfree#Combinator_discoveries :√æ
08:58:48 <Twey> Cale: (i.e. many of the type variables are fresh)
08:59:07 * hackagebot quickwebapp 3.0.0.1 - A quick webapp generator for any file processing tool  https://hackage.haskell.org/package/quickwebapp-3.0.0.1 (jtanguy)
08:59:42 <Twey> If they're already mentioned elsewhere, usually I just care that it types at all; if I'm trying to read the type, it usually means I don't have names for them yet
09:01:14 <athan> Hey guys, I'm trying to collect a few benchmark ideas for comparing generic computations vs. list-oriented ones - anyone have one off the top of their head?
09:01:21 <athan> The repo is being held here: https://github.com/athanclark/listvsgeneric
09:01:33 <athan> right now I only have a basic example - key generation
09:04:07 * hackagebot haskore 0.2.0.7 - The Haskore Computer Music System  https://hackage.haskell.org/package/haskore-0.2.0.7 (HenningThielemann)
09:14:07 * hackagebot quickwebapp 3.0.0.2 - A quick webapp generator for any file processing tool  https://hackage.haskell.org/package/quickwebapp-3.0.0.2 (jtanguy)
09:14:09 * hackagebot linearscan 0.10.2 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-0.10.2 (JohnWiegley)
09:15:38 <lambdadoodle> > sequence [[1],[2]]
09:15:40 <lambdabot>  [[1,2]]
09:16:04 <dmj`> as a percentage, what is hackage's uptime / availability? 99.9%? 80%? 
09:17:27 <glguy> Hackage strives for 8 8s of reliability :)
09:17:38 <geekosaur> might ask in #hackage or #haskell-infrastructure?
09:17:49 <dmj`> glguy: :P
09:17:49 <dmj`> geekosaur: ah thnx
09:18:07 <zachk> I have only seen it down once over many years
09:18:17 <geekosaur> same, fwiw
09:18:18 * jeltsch wonders whether there is a new quickwebapp release every other day. ;-)
09:18:51 <bitemyapp> glguy: lol
09:18:56 <geekosaur> well, not entirely true, toward the end of when it was iirc hosted at yale it became fairly unreliable. that was why we got the current infrastructure team
09:19:08 * hackagebot linearscan-hoopl 0.10.2 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.10.2 (JohnWiegley)
09:19:20 <geekosaur> instead of it being part-time managed by a random prof (or, more likely, grad student thereof)
09:24:08 * hackagebot twitter-feed 0.2.0.3 - Client for fetching Twitter timeline via Oauth  https://hackage.haskell.org/package/twitter-feed-0.2.0.3 (jpvillaisaza)
09:29:40 <athan> What's a good way to generate (with Arbitrary) rose trees under a maximum depth?
09:31:52 <sm> hackage could use a pingdom report like darcs hub's
09:32:30 <sm> now that Enterprise has noticed it
09:33:37 <Gurkenglas> athan, you can define a dependent newtype TreeCutoff i = TreeCutoff {runTreeCutoff :: Tree} and a custom Arbitrary instance
09:33:51 <Gurkenglas> (Well, I'd hope you can. Not sure about all that dependent type stuff.)
09:34:00 <athan> Gurkenglas: That might actually work
09:34:05 <athan> reification would be fun
09:34:19 <dmj`> athan: use (==>) might be able to make a predicate on depth
09:34:29 <athan> dmj`: Well that's the funny part
09:34:48 <dmj`> athan: oh wait, that's not for generation sry
09:34:49 <athan> if you say "I need children will less depth than 10", you still need to generate the children
09:35:05 <nshepperd> doesn't Arbitrary have a size parameter for generation?
09:35:08 <athan> I was thinking about stapling a parameter in a `go` function, probably should do it
09:35:15 <dmj`> athan: yea... you have to get sneaky with the way you generate stuff
09:35:19 <athan> nshepperd: :s idk
09:35:19 <nshepperd> you could just interpret that as maxdepth
09:35:32 <athan> dmj`: I've found the hard way ._.
09:35:47 <athan> nshepperd: Hmm, I'll look into it, thanks for the tip
09:36:04 <athan> ST + Foldable has decent key enumeration, btw: https://htmlpreview.github.io/?https://github.com/athanclark/listvsgeneric/blob/master/profile.html
09:36:05 <recursion-ninja> Is there a Haskell package that has a TimeSpan type. Some thing with functions similar to getTimeSpan :: Time -> Time -> TimeSpan and minutes :: TimeSpan -> Integer
09:36:20 <athan> still not as fast as [0..] `zip` xs, though
09:36:57 <athan> recursion-ninja: There has to be, somewhere
09:37:17 <glguy> recursion-ninja: the "time" package does the first with: diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
09:37:37 <nshepperd> ah yes, QuickCheck.Gen.sized
09:37:49 <recursion-ninja> athan: I Know I just couldn't find anything...
09:38:21 <recursion-ninja> glguy: does that NominalDiffTime have record accessory like the `minutes` function I described?
09:38:28 <athan> nshepperd: Oh wow that's really cool
09:38:39 <glguy> recursion-ninja: No, but you can do that with:
09:38:43 <glguy> 07let minutes 07:: NominalDiffTime 07-> Double; minutes ndt 07= realToFrac ndt 07/ 0460
09:38:56 <nshepperd> and QuickCheck.Gen.resize when you want to call it recursively for the subtrees
09:39:00 <geekosaur> sm, you know about https://status.haskell.org/ ?
09:39:20 <nshepperd> or, well, you could just call the function directly I guess
09:39:23 <athan> nshepperd: :O! Awesome, okay!
09:39:30 <recursion-ninja> Hmm‚Ä¶ I really want to be dealing with Integral time unites of Days, Hours, Minutes‚Ä¶
09:39:53 <geekosaur> ..although "updated a month ago"...
09:39:54 <recursion-ninja> I feel like there should exists something like that and I shouldn't be "rolling" my own
09:40:04 <geekosaur> #haskell-infrastructures question I think
09:40:13 <glguy> recursion-ninja: If you want to round you can
09:40:13 <geekosaur> (may just mean no outages in the past month)
09:40:14 <glguy>  let minutes :: NominalDiffTime -> Integer; minutes ndt = truncate ndt `div` 60
09:40:22 <sm> geekosaur: I forgot about it, but it doesn't show uptime 
09:40:46 <sm> heh, yes and that
09:41:00 <sm> that's quite funny
09:41:23 <recursion-ninja> I would need an integral constructor too‚Ä¶ even if the constructor require conversation to nanoseconds or something
09:41:43 <athan> nshepperd: Do you happen to know if it's ever 0? or is there a bound on the Int?
09:41:49 <athan> It would be strange to have negative size
09:41:51 <recursion-ninja> I'll see if NominalDiffTime will work, but it might not be what I need
09:43:20 <nshepperd> athan: humm, the size parameter doesn't have any really fixed interpretation, but I think it's normally not less than 0
09:45:07 <nshepperd> but if you're going to recurse to be safe I would clamp it to >= 0, or >= 1, like (max 0 size)
09:45:53 <recursion-ninja> I *hate* to reference PHP but I was looking for some datatype like this in Haskell: http://php.net/manual/en/class.dateinterval.php
09:46:32 <recursion-ninja> I'll make my own if I have too, but it would be better if I could use an existing library
09:47:02 <quchen> Before PHP 5.4.20/5.5.4 instead of FALSE you will receive -99999 upon accessing the property. 
09:47:06 <quchen> No, Haskell doesn't have that
09:47:21 <athan> nshepperd: Thank you :)
09:47:53 <recursion-ninja> quchen: Are you sure?
09:48:23 <recursion-ninja> quchen: seems like a reasonable way to work with "timespan" data
09:48:25 <nshepperd> athan: you might also want to play around with using the size parameter to somehow affect the size of the subtree list, if you care about the width as well as the depth of your tree
09:48:28 <quchen> I've heard great things about thyme in Haskell, but other than that there is only the standard lib I assume.
09:48:49 <sm> recursion-ninja: sounds a bit like https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Clock.html#t:NominalDiffTime
09:49:01 <recursion-ninja> quchen: Thanks for the thyme reference, I'll see if that has what I am looking for!
09:49:09 * hackagebot feed-translator 0.1.0.2 - Translate syndication feeds  https://hackage.haskell.org/package/feed-translator-0.1.0.2 (hongminhee)
09:52:28 <recursion-ninja> quchen: the `thyme` package has a DiffTime datatype that is an instance of the typeclass TimeDiff which fines the integral time components I am looking for!
09:52:35 <recursion-ninja> quchen: Thanks so much!
09:53:38 <quchen> recursion-ninja: I've had some trouble working with timestamps and the standard Date.Time as well, had to resort to some dirty hacking.
09:54:02 <quchen> I wish I had known thyme back then. (Maybe it didn't exist yet)
09:54:15 <Sean_> maybe it just wasn't thyme
09:54:17 <Sean_> im sorry
09:54:18 <Sean_> no im not
09:54:33 <sm> quchen: check out the recent good time tutorial on reddit
10:00:59 <athan> nshepperd: works like a charm :) Thank you!
10:09:00 <ZGravitas> I'm going through the h-99 problems and want to put a little more structure around them, is HUnit widely used for defining explicit test cases?
10:10:06 <quchen> I think so.
10:10:29 <quchen> I use Tasty as the framework and then include Quickcheck, Smallcheck, and HUnit tests.
10:10:34 <Ankhers> I have seen both HUnit and HSpec used.
10:15:29 <ZGravitas> Cool, I'll have a little browse through HSpec and Tasty
10:19:01 <mazur> do limits and colimits of the diagram A -> B have any special meaning in Cat Thy?
10:19:11 * hackagebot feed 0.3.10.1 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  https://hackage.haskell.org/package/feed-0.3.10.1 (AdamBergmark)
10:20:27 <mazur> i guess for Hom(A,B) a limit is equalizer
10:21:00 <shachaf> mazur: You mean a diagram with two objects and one (non-identity) arrow?
10:21:12 <mazur> shachaf: yes
10:21:18 <shachaf> Limits and colimits are both boring.
10:21:48 <mazur> shachaf: in this case or in general? :D
10:22:07 <the_2nd> http://pastebin.com/zwqJ682W parse error in pattern method
10:22:23 <the_2nd> I follow the happstack-lite tutorial
10:22:27 <the_2nd> and cant figure this one out
10:22:39 <the_2nd> http://www.happstack.com/page/view-page-slug/9/happstack-lite-tutorial#/forms
10:22:44 <shachaf> In general, limits of a diagram that has an initial object, or colimits of a diagram that has a terminal object, are that object.
10:23:23 <quchen> the_2nd: Too much indentation in the do block's non-first lines
10:24:11 <mazur> shachaf: i see. it looked to me like A and B would both be limits (assuming cones can be objects already in the diagram)
10:24:42 <shachaf> I might be misunderstanding the question.
10:26:06 <mazur> shachaf: going by the definition of limit is a terminal object in the cone category
10:26:12 <dgpratt> choices choices
10:26:16 <dgpratt> so many choices
10:27:00 <dgpratt> I'm trying to decide if "no-reinstall Cabal" will be worth the trouble vs. what I've been trying to use, which is stack
10:27:11 <shachaf> mazur: Well, there's an obvious cone with A as the object, and it's easy to show that it's universal.
10:27:18 <shachaf> mazur: I don't know what cone you have in mind with B as the object.
10:27:35 <dgpratt> stack seems to work, but I'm very anxious for the tooling to catch up
10:28:23 <mazur> shachaf: oh i see, i would be assuming an arrow from B to A to make B a cone, but that's just an assumption, doesn't have to be that way
10:28:30 <dgpratt> does anyone care to venture an opinion on how useful/necessary stack will be if "no-reinstall cabal" achieves its goals?
10:28:46 <shachaf> mazur: There's certainly no obvious way to produce that arrow.
10:30:02 <athan> Is there a good substitute for right-sectioned subtraction?
10:30:06 <athan> :t (-1)
10:30:08 <lambdabot> Num a => a
10:30:16 <athan> @pl (\x -> x-1)
10:30:16 <lambdabot> subtract 1
10:30:21 <athan> oh
10:35:47 <Welkin> athan: lol, someone else asked the same thing the other day
10:35:54 <Welkin> I told them the same answer: subtract
10:36:53 <quchen> athan: Careful with using subtract in backticks though.
10:37:00 <Welkin> haha
10:37:04 <quchen> > 1 `subtract` 2
10:37:06 <lambdabot>  1
10:37:26 <Welkin> it is subtractFirstFromSecond
10:49:08 <Welkin> @list
10:49:08 <lambdabot> What module?  Try @listmodules for some ideas.
10:49:10 <Welkin> @listmodules
10:49:11 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
10:49:50 <Welkin> @spell lol
10:49:51 <lambdabot> Plugin `spell' failed with: aspell: readCreateProcessWithExitCode: runInteractiveProcess: exec: does not exist (No such file or directory)
10:49:57 <Welkin> D:
10:50:13 <Welkin> it's broken
10:52:54 <clrnd> you broke it!
10:54:13 * hackagebot fclabels 2.0.2.3 - First class accessor labels implemented as lenses.  https://hackage.haskell.org/package/fclabels-2.0.2.3 (AdamBergmark)
10:56:54 <the_2nd> http://www.happstack.com/page/view-page-slug/9/happstack-lite-tutorial#/forms  are all the "do"s overused?
10:57:05 <the_2nd> shouldnt this be possible without the "do"s?
10:58:06 <Iceland_jack> the_2nd: Some of the do's aren't needed, but they use it for consistency 
10:58:06 <Cale> the_2nd: I don't think any of the occurrences of do there are spurious.
10:58:12 <Cale> er
10:58:26 <Cale> oh, there's one
10:58:40 <Iceland_jack>     H.head $ do
10:58:40 <Iceland_jack>       H.title (toHtml title)
10:58:40 <Iceland_jack> could be written as
10:58:40 <Iceland_jack>     H.head $
10:58:43 <Iceland_jack>       H.title (toHtml title) 
10:58:51 <Cale> most of the do's have more than one statement in them at least :)
10:59:04 <Cale> I see one more
10:59:08 <the_2nd> is there no other way of grouping?
10:59:14 <the_2nd> i thought do was for IO
10:59:24 <Cale> Not only for IO, but for any monad.
10:59:29 <Iceland_jack> do-notation works for a lot of things
10:59:53 <Cale> In the case of Blaze, it's a little silly, since none of the Blaze actions have any results
11:00:10 <Cale> The ServerPart stuff is less trivial though, iirc.
11:00:33 <Cale> Blaze just uses it because you don't have to write explicit separators
11:01:02 <Cale> Like, if they did something else, you'd have some operator symbol you'd have to use to concatenate HTML documents or something.
11:01:38 <clrnd> do is just syntax sugar for >>= and >>
11:02:10 <Iceland_jack> @undo do print 1; print True; print pi
11:02:10 <lambdabot> print 1 >> print True >> print pi
11:02:33 <Cale> @undo do x <- getLine; putStrLn (reverse x)
11:02:34 <lambdabot> getLine >>= \ x -> putStrLn (reverse x)
11:02:44 <clrnd> undo is nice
11:02:50 <mrcuriosity> hello
11:02:54 <clrnd> hi
11:03:14 <mrcuriosity> can anyone resolve me a dude?
11:04:37 <clrnd> lol, I am straight, but I could try
11:21:58 <berraiten> :t Int
11:21:59 <lambdabot>     Not in scope: data constructor ‚ÄòInt‚Äô
11:21:59 <lambdabot>     Perhaps you meant one of these:
11:21:59 <lambdabot>       ‚ÄòIn‚Äô (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
11:23:01 <Gurkenglas> "Mathematically", it feels like the "idiomatic version" of mapM putStrLn [show 1, show True, show pi] should already have the type IO () (as opposed to IO [()]), without the need to resort to helpers like mapM_. (Seeing as one uses the structure-invariant mapM and the value-invariant (), resulting in only one possible output value.)
11:25:17 <joco42_> anyone tried this http://thrift.apache.org/ ? to interop Haskell with other languages?
11:25:47 <joco42_> any opinions?
11:25:57 <Gurkenglas> Maybe mapM_ should have been originally written to have the type (a -> IO ()) -> [a] -> IO (), to explicitly witness that fact. How often do you people use "_"-functions on "non-()" inputs?
11:26:06 <luite> source code for my Haskell Symposium 2015 slides (lightning talk yesterday, reveal.js slides with inline interactive Haskell code blocks) is available now here: https://github.com/luite/hs15-talk
11:26:10 <Cale> Gurkenglas: hm?
11:26:32 <Cale> Gurkenglas: Maybe you just don't care about the results
11:27:35 <Cale> Gurkenglas: I don't understand what you mean by "Mathematically" there
11:27:42 <Gurkenglas> I don't remember ever not caring about non-() results in my code, the only place I might imagine that is the thread id returned by forkIO. That sounds rare enough to be made explicit with void when needed
11:28:35 <lingxiao> hey all 
11:28:39 <lingxiao> Im trying to use overlapping instances
11:28:49 <lingxiao> but I get error: "-XOverlappingInstances is deprecated: instead use per-instance pragmas OVERLAPPING/OVERLAPPABLE/OVERLAPS "
11:28:56 <lingxiao> which should be self explanatory ..
11:29:02 <Cale> Gurkenglas: I prefer that everything we don't care about in positive position be () and in negative position be polymorphic
11:29:02 <monochrom> Gurkenglas: Mathematically, mapM's type is (a -> m b) -> [a] -> m [b], not (a -> m ()) -> [a] -> m (). And mathematically, parameteric polymorphism forbids mapM from "knowing" the special case b=() and doing something different for it.
11:29:10 <Gurkenglas> '"Mathematically", i feel' ~= 'If Haskell had been crafted with my current opinion in mind'
11:29:19 <lingxiao> but actually I don't know the syntax to insert those per-instance pragmas
11:29:28 <Cale> That's a weird way to say that :)
11:29:58 <glguy> lingxiao: Hopefully you don't need overlaping instances, but if you do: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#instance-overlap
11:30:25 <Gurkenglas> monochrom, that second type i said should have been given to mapM_, not mapM
11:30:29 <Alpha64> the examples look interesting luite , although i'm a noob with haskell, are you doing frp behind the scenes or just evaluating the whole program on changes ?
11:30:36 <Cale> Gurkenglas: If I tell you that a function has type b -> Integer, you know that its result doesn't depend on the value of its argument.
11:31:14 <Gurkenglas> Cale, I used it in hope of it being more clear that I am speaking from the point of "mathematical idealism"
11:31:48 <Cale> Gurkenglas: That case is pretty trivial of course, but for instance, if we have something like  IO a -> IO ThreadId  (like the one true type of forkIO we'll eventually get back to someday)
11:31:48 <lingxiao> glguy uh still can't get it to work
11:31:52 <lingxiao> ...
11:31:52 <lingxiao> http://lpaste.net/140273
11:31:58 <monochrom> Gurkenglas, I agree to disagree.
11:32:12 <Gurkenglas> Cale, if a function has type () -> Integer, (ignore triviality), that suggests it doesn't throw away any information
11:32:13 <Cale> Then we know that the result of the parameter action doesn't matter by construction.
11:32:34 <lingxiao> so I'm not doing instance show {#- OVERLAPPABLE #-} CsvRow_ where ... ?
11:33:23 <glguy> lingxiao: It's not a good idea to use your Show instances as prettyprinters
11:33:37 <glguy> They should be generating Haskell syntax (which is what the default instances do)
11:33:56 <Gurkenglas> IO a -> IO b, we know that the information from a is not used. IO () -> IO b, we know that there wasn't any information in the first place
11:33:59 <lingxiao> hmm.. ok then I wont do it 
11:34:26 <Cale> Gurkenglas: If we had something of type IO a -> IO b, I would prefer  IO a -> IO ()  usually
11:34:28 <glguy> You can still write a separate pretty-printing function if you want to display the data to a user or yourself
11:34:38 <Denommus> I have a dream
11:34:40 <Gurkenglas> Cale, I would prefer IO a -> IO Void
11:34:45 <Denommus> a MonadPlus-based database library
11:34:49 <Gurkenglas> *IO () -> IO Void ofc
11:34:57 <Denommus> I've been looking for it, and it seems it does not exist
11:35:00 <Cale> Why do you hate polymorphism?
11:35:16 <glguy> I'm sure some of his best friends are polymorphic
11:35:24 <Cale> Well, okay, if it has type  IO b  that might mean that it doesn't terminate
11:35:25 <Denommus> but I have no idea how to start :-(
11:35:32 <Denommus> anyone has any pointers to me?
11:35:43 <lingxiao> thanks!
11:35:45 <Cale> If it does terminate, it terminates with an error as its result.
11:36:08 <Cale> In the case that it doesn't terminate, then producing IO b is fine.
11:36:12 <monochrom> Gurkenglas: I want to write "mapM_ forkIO [a, b, c]" to fork 3 threads (and not care about their ThreadId's.)  You are saying you forbid that.
11:36:47 <Cale> :t throwIO
11:36:48 <lambdabot> Exception e => e -> IO a
11:36:53 <Cale> ^^ yeah, like that
11:36:57 <monochrom> you are saying you force me to write "mapM_ (\x -> forkIO x >> return ()) [a, b, c]"
11:36:58 <Gurkenglas> monochrom, I am saying that you need to explicitly say that you don't care about the ThreadId's using "mapM_ (void . forkIO) [a, b, c]"
11:37:10 <Cale> I really really hate the change to forkIO
11:37:31 <monochrom> no, the "mapM_" part already says that.
11:37:35 <shlevy> Is there any reason STM can't export atomicallyWithRetryHandler :: STM a -> IO (Maybe a) -> IO a? Where the second argument is run on every retry, and if it's not Nothing it aborts?
11:38:05 <Cale> forkIO used to have type  IO a -> IO ThreadId  and I wish it had stayed that way
11:38:05 <Gurkenglas> monochrom, that and that I wished it otherwise was already common knowledge between the two of us, I thought.
11:38:31 <monochrom> and overall you are hijacking "mathematically" for your subjective personal opinion, which pisses me off.
11:38:49 <shlevy> Cale: why did they move away from that??
11:38:50 <monochrom> then again, mathematics is subjectively invented not objectively discovered, why am I complaining
11:39:03 <Gurkenglas> Which is why I said '"mathematically"', not 'mathematically'
11:39:04 <Cale> shlevy: People who don't like polymorphism or something
11:39:07 <lingxiao> as a followup question
11:39:18 <lingxiao> if I have some `data Row f = ...`
11:39:21 <Cale> shlevy: The new type forces you to be explicit about discarding results
11:39:28 <lingxiao> sorry ... `data RowF f = ...`
11:39:29 <Cale> by adding >> return ()
11:39:37 <shlevy> Cale: Yeah, that just seems wasteful
11:39:39 <Gurkenglas> Cale, don't pretend void doesn't exist :D
11:39:41 <glguy> lingxiao: I'm writing up some code for how to make this a Show instance
11:39:48 <shlevy> Would the same people want to chainge Main too if they could?
11:39:51 <lingxiao> then some `type Row = RowF Identity`
11:39:52 <Cale> Gurkenglas: void shouldn't exist either, it's dumb.
11:39:53 <lingxiao> glguy thanks!
11:42:00 <monochrom> Gurkenglas: did you know: main's type can be "IO Int", "IO Bool", generally "IO a", not necessarily "IO ()". you should take your crusade there first.
11:42:07 <Gurkenglas> Cale, do you see how one might appreciate not having to look at "fooM_"s first argument to know that it has return type ()?
11:42:58 <Cale> Gurkenglas: huh?
11:43:11 <monochrom> yeah, I don't understand what to appreciate there.
11:43:12 <Cale> Gurkenglas: I don't understand why you'd care
11:43:29 <Cale> You're explicitly discarding that information, why do you need to know that it's ()?
11:43:58 <Cale> You shouldn't care that it's anything in particular, because you're not using it.
11:44:07 <Gurkenglas> You'd know that no information was thrown away. It's like I like when a 100-line-function has its first word to the right of its top-level = being "unfoldr", it fixes a lot of the program's structure
11:44:09 <lpaste_> glguy annotated ‚ÄúNo title‚Äù with ‚Äúshow instances‚Äù at http://lpaste.net/140273#a140274
11:44:13 <glguy> lingxiao: ^
11:44:25 <monochrom> instead, do you see how I appreciate not having to force a () in fooM_'s first argument
11:44:29 <Gurkenglas> "fixes" = "affixes in place"
11:44:50 <Cale> Information might still be thrown away
11:44:55 * Jello_Raptor sighs
11:44:56 <glguy> lingxiao: Different choices need different extensions (choice 3 doesn't need any)
11:45:11 <Cale> You still need to actually look at the definition of that argument in order to ensure it isn't discarding anything.
11:45:19 <Gurkenglas> I do! You like less syntax. <passive-aggressive> Dynamically typed languages are also appreciated by some. </passive-agressive>
11:45:21 <Cale> This isn't reversible computing or something
11:45:40 <KaneTW> i don't understand the argument
11:46:32 <Cale> Haskell programs, and most programs in general throw away tons of information. That's sort of why processors heat up. :)
11:46:35 <Jello_Raptor> glguy: since you're a Control.Lens contributor, is there a style guide somewhere? esp for TH related stuff? I'm coding up that replacement for "makeFields" that makes it more polymorphic, and my code feels like it'd be unreadable to someone who didn't write it. 
11:47:02 <monochrom> I don't know why you liken this to dynamic typing.
11:47:06 <makalu> have any research papers been written about reactive banana?
11:47:09 <Cale> It's not always a bad thing when a result is discarded.
11:47:23 <monochrom> parameteric polymorphism does something very opposite to dynamic typing polymorphism.
11:47:24 <KaneTW> :t mapM_
11:47:25 <lambdabot> (Monad m, Foldable t) => (a -> m b) -> t a -> m ()
11:47:43 <Jello_Raptor> Cale: doesn't laziness give a lie to that? (at least partially)
11:47:56 <monochrom> at the surface they look like in perfect agreement to skin-deep people. "w00t, any type is allowed"
11:48:00 <KaneTW> :t void . mapM
11:48:00 <glguy> Jello_Raptor: The style guide is that it should look like the rest of the code in that module. I don't think we have anything explicit
11:48:01 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> ()
11:48:25 <KaneTW> huh
11:48:27 <KaneTW> :t void
11:48:28 <lambdabot> Functor f => f a -> f ()
11:49:08 <Cale> Jello_Raptor: hm?
11:49:15 <monochrom> the truth is that parameteric polymorphism further says "but the function cannot know which type you choose", whereas dynamic typing polymorphism is the opposite, "the function can see which type you choose, moreover can do a case analysis on that"
11:49:29 <Cale> Jello_Raptor: heh, with lazy evaluation, we can throw away infinite amounts of stuff :D
11:49:35 <Jello_Raptor> glguy: mmm :/ fair enough. Would you mind if I ping you when I have something working for further advice? 
11:49:53 <glguy> sue
11:49:54 <glguy> sure*
11:50:22 <Cale> @let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes)
11:50:23 <lambdabot>  .L.hs:155:1:
11:50:23 <lambdabot>      Multiple declarations of ‚Äòprimes‚Äô
11:50:23 <lambdabot>      Declared at: .L.hs:151:1
11:50:26 <Cale> heh
11:50:28 <Cale> already defined
11:50:39 <Jello_Raptor> Cale: well, the stuff that you never look at look at never existed, no? (wow, i didn't realize haskell was such a solopsistic language)
11:50:41 <Cale> Is that program bad because it's throwing away the numbers which aren't prime?
11:50:53 <Cale> It's discarding information
11:50:54 <Jello_Raptor> Cale: but both are perfectly valid ways of phrasing it :P 
11:50:58 <monochrom> specifically for mapM_, "a -> m b" with b unmentioned in the rest, perfectly clearly tells me how mapM_ is not going to depend on the b.
11:51:07 <Cale> about composite odd numbers
11:51:10 <Gurkenglas> monochrom, I likened the two situations because of the preceived-by-me tradeoff between code brevity and gurantees the code makes
11:51:45 <monochrom> no trade-off is necessary. mapM_'s "a -> m b" is already the best of both worlds.
11:52:08 <monochrom> it both tells me a guarantee, and it lessens my code
11:52:11 <Gurkenglas> monochrom, "a -> m ()" in "a -> m b"s place would further tell me that no information was even generated.
11:52:53 <monochrom> no, that is not a "tell me". that is the opposite of "tell me". i.e., that is "forces me"
11:52:54 <KaneTW> that's not what i want mapM_ for though
11:53:19 <KaneTW> if that was the type i couldn't write quite a lot of functions where i want to/could use mapM_ for
11:54:01 <KaneTW> i'd have to explicitly make them return () and that's unneccessary and silly
11:54:06 <monochrom> you don't seem to understand the difference between "(a -> m ()) -> XXX" vs "XXX -> (a -> m ())"
11:54:37 <monochrom> "XXX -> (a -> m ())" would be a case of "tells me no information is generated", yes.
11:54:45 <Gurkenglas> Cales lines tell me that throwing away information is the essence of cpu heatup. Therefore, all instances of throwing away information should be made as explicit as possible. For example, make it (>>) :: IO () -> IO b -> IO b. (Including the impliciations for do notation)
11:54:54 <shlevy> Ended up creating an issue for my previous question (got disconnected if anyone answered it in the mean time)
11:54:57 <shlevy> https://ghc.haskell.org/trac/ghc/ticket/10841
11:55:34 <KaneTW> :t (>>)
11:55:35 <lambdabot> Monad m => m a -> m b -> m b
11:55:42 <KaneTW> again
11:55:49 <monochrom> "(a -> m b) -> XXX" already tells me explicitly of throwing away information
11:55:51 <Gurkenglas> monochrom, it "forces" the writer and "tells" the reader. As with the dynamic vs static parallel.
11:56:40 <Gurkenglas> It doesn't when it's mostly used on (a -> IO ())-type functions anyway. We should be explicit both in when information is thrown away and when it isn't, of course.
11:57:01 <monochrom> and yeah, what KaneTW says. how about taking your crusade to (>>)?  why don't you propose (>>) => Monad m => m () -> m b -> m b ?
11:57:20 <monochrom> no, "mostly" is false for me
11:57:27 <Cale> Gurkenglas: I couldn't disagree more. A lot of information is discarded all the time, because we're only interested in certain things.
11:57:35 <KaneTW> ^
11:57:45 <Gurkenglas> I did just before he said ":t (>>)", which he probably did because I mentioned it :D
11:57:46 <Cale> Gurkenglas: Making that explicit will just clutter everything and not help.
11:58:07 <monochrom> yes okay good.
11:58:34 <KaneTW> :t \p -> putStr p >> getLine >>= putStrLn
11:58:36 <lambdabot> String -> IO ()
11:59:04 <monochrom> take your crusade to (>>) first. see how far you get. (hint: not very far. you will make most programs basically impractical.)
11:59:45 <KaneTW> it'd just be a ton of >> return ()
12:00:12 <KaneTW> you could take it at absurdum and demand that
12:00:15 <KaneTW> :t (>> return ())
12:00:16 <lambdabot> Monad m => m a -> m ()
12:00:31 <KaneTW> has type Monad m => m () -> m ()
12:00:34 <KaneTW> ad absurdum*
12:00:46 <Gurkenglas> Indeed! Its place would be taken by void, which already fulfills that function
12:00:47 <monochrom> KaneTW: it's worse. suppose (>>) :: Monad m => m () -> m b -> m b.  is "getLine >> return ()" even typeable?
12:00:47 <Gurkenglas> :t void
12:00:49 <lambdabot> Functor f => f a -> f ()
12:01:35 <KaneTW> haha
12:01:43 <KaneTW> i didn't even realize
12:02:02 <monochrom> this is why I wrote "(hint: not very far.)
12:02:42 <Gurkenglas> And I figure that most lines would remain unchanged. When is information actually being thrown away? If it's on the order of 10% of the time, I would like to have it explicit. Of course I realize that at this point this will "never" become standard. How feasible would it be to get a language extension that implements these restrictions?
12:03:03 <KaneTW> types already tell us a lot; forall a b. a -> b -> b can only be inhabited by const, forall a b. a -> b is uninhabited (barring unsafeCoerce and the like)
12:03:49 <monochrom> basically, if history began with "(>>) :: Monad m => m () -> m b -> m b", then no one would use it (it's useless). and furthermore, someone would invent "(>>>) :: Monad m => m a -> m b -> m b", bringing us back to how things should be.
12:04:51 <monochrom> if history began with "mapM_ :: ... (a -> m ()) ...", someone would invent "mapM__ :: ... (a -> m b) ...", bringing us back to how things should be.
12:05:02 <qmm> what's the story around introspection for haskell services in deployment?
12:05:11 <Gurkenglas> How hard would it be to get numbers on what portion of the time m () is passed as the first argument to (>>)?
12:05:13 <lingxiao> hey all 
12:05:15 <lingxiao> silly question
12:05:42 <lingxiao> suppose i have a top level directory with Main.hs
12:05:46 <geekosaur> ghc, now with social logging >.>
12:05:55 <zachk> geekosaur: ?
12:05:55 <qmm> http://www.erlang.org/doc/apps/observer/observer_ug.html is useful
12:06:02 <qmm> i'm curious if there's anything like this for haskell
12:06:08 <lingxiao> and a directory in it call Stuff, and I'd like to import file Foo.hs from directory Stuff
12:06:12 <lingxiao> how would I do it from Main?
12:07:05 <geekosaur> zachk, snark related to Gurkenglas' query
12:07:12 <lingxiao> I can't do import Stuff.Foo
12:08:12 <geekosaur> you can but only if Foo.hs starts with "module Stuff.Foo where"
12:08:26 <geekosaur> if it's just "mnodule Foo where" then you want: ghc -iStuff ...
12:08:47 <Gurkenglas> geekosaur, theoretically (as in thats way too much effort probably but it should be possible) one could typecheck all the programs from open-source github projects and check. Is there a feasible alternative?
12:09:17 <geekosaur> actually, there are harnesses to test things like that against all of hackage
12:09:17 * hackagebot diagrams-contrib 1.3.0.5 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.3.0.5 (BrentYorgey)
12:09:39 <geekosaur> they're used to, for example, assess the breakage from the AMP and BBP for 7.10, before relase
12:09:43 <geekosaur> ... where is my typing today
12:09:46 <lingxiao> hey all in this case here ...
12:09:47 <lingxiao> http://lpaste.net/140275
12:10:26 <lingxiao> would it be possible to put `Maybe CSVRow_` and `CSVRowF Maybe` into the same list?
12:10:34 <lingxiao> perhapse by redefining the data types
12:12:51 <ptcek> anyone connecting to Oracle DB? Anyone Takusen?
12:13:20 <joco42_> is there something like https://hackage.haskell.org/package/turtle-1.2.1/docs/Turtle-Tutorial.html but for python ? i wanna use numpy from haskell, i wanna use haskell to script numpy/scipy...
12:13:29 <Gurkenglas> lingxiao, I would use a function of type (forall x. f x -> g x) -> CSVRowF f -> CSVRowF g, and apply that one of your two to have a homogenous list
12:13:38 <joco42_> anyone doing that?
12:13:57 <lingxiao> Gurkenglas could you expand on that ? perhapse in an lpaste :) :D
12:14:09 <lingxiao> I'm not quite sure how to implement that function
12:16:14 <athan> joco42_: There's probably bindings, one sec
12:16:28 <Jello_Raptor> glguy: oh, before I forget. When you have a datatype with multiple constructors (like "Foo = FooA { _bar Bool } | FooB") and I want to create a total lens for a field that doesn't exist everywhere (in this case "bar") what would be an appropriate type for that lens? I'm considering "Lens s t (Maybe a) (Maybe b)" and "Lens s t a (Maybe b)". The former seems like it fits the "Lens' s (Maybe a)" suggested by the Control.Lens.At 
12:16:28 <Jello_Raptor> interface, but I'm not really sure. 
12:16:57 <arkeet> the latter cannot be a lawful lens.
12:17:04 <joco42_> athan: i tried to compile this https://john-millikin.com/articles/ride-the-snake/ ... did not work...
12:17:13 <athan> joco42_: So it looks like there aren't bindings, but there's some leads for other tools: https://www.reddit.com/r/haskell/comments/2dd2um/what_are_some_haskell_alternatives_to_pandasnumpy/
12:17:14 <arkeet> I don't think you can have a lawful lens for that actually?
12:17:28 <Jello_Raptor> arkeet: that answers that question, but I'm not sure I understand why? 
12:17:59 <exio4> Jello_Raptor: you want a Prism, probably
12:18:02 <athan> joco42_: I take it you're not used to haskell?
12:18:33 <joco42_> athan: yeah, well, maybe i just https://thrift.apache.org/ ?
12:19:03 <joco42_> athan: well, i wrote a few hundred lines so far... and read a few books... thats all
12:19:09 <joco42_> not much indeed
12:20:12 <joco42_> i try to increase it by using haskell at work...
12:20:32 <joco42_> so that i could somehow write part of the stuff in haskell and part in python
12:21:10 <joco42_> and somehow make interop the two worlds
12:21:46 <athan> joco42_: That's a good approach, it does take a while before you can work through errors on your own
12:21:50 <athan> What kind of error is going on?
12:22:30 <joco42_> i wanna be able to write in ghci : python "plot(x)" and then i have a plot on the screen
12:22:40 <joco42_> or smtg like that
12:23:26 <joco42_> athan: well, it was something version problem with python... the usual stuff...
12:23:53 <joco42_> it just does not really work out of the box...
12:24:18 <joco42_> i wonder which is the least painless way to interop with python...
12:24:29 <joco42_> perhaps thrift
12:24:51 * athan > mfix shrug
12:25:01 <joco42_> yes
12:25:46 <monochrom> in ghci: :! python "plot(x)"
12:26:55 <Jello_Raptor> exio4: I'm not sure I understand prisms then :/ hell I don't see how a traversal and prism could unify, unless `Choice (->)` is a valid instance and that doesn't make sense since you can't reverse a function automatically :/ 
12:28:11 <lpaste_> Gurkenglas revised ‚ÄúNo title‚Äù: ‚Äúhoist lingxiao's CSVRowF‚Äù at http://lpaste.net/140275
12:28:28 <Gurkenglas> This reads like the sort of thing that a derive clause should be able to do.
12:28:37 <shachaf> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
12:29:02 <shachaf> type Prism s t a b = forall p f. Applicative f => p a (f b) -> p s (f t)
12:29:36 <shachaf> The only way to make those unify is p ~ (->)
12:29:44 <shachaf> Choice (->) is certainly valid.
12:30:21 <Jello_Raptor> shachaf: then i certainly don't understand what "Choice" and "Prism" are actually meant to do
12:30:23 <shachaf> Choice requires right :: p a b -> p (Either e a) (Either e b)
12:31:46 <shachaf> Prism means "isomorphic to a sum", like lens means "isomorphic to a product".
12:33:24 <Gurkenglas> Aww, lingxiao left.
12:34:22 <clrnd> :t (~.)
12:34:23 <lambdabot>     Not in scope: ‚Äò~.‚Äô
12:34:23 <lambdabot>     Perhaps you meant one of these:
12:34:23 <lambdabot>       ‚Äò.‚Äô (imported from Data.Function),
12:35:05 <clrnd> I like how I can use lens pragmatically, yet have absolutely no idea about their types, nor can read them at all
12:35:42 <dgpratt> getting an error running cabal update: cabal.exe: <socket: 652>: already exists
12:35:50 <dgpratt> has anyone seen that before?
12:35:58 <dgpratt> this is running on Windows, btw
12:36:05 <dgpratt> as admin
12:36:12 <Jello_Raptor> shachaf: you've lost me, sorry :( . Do you mean that in the ADT sense? where a lens is a reference to a subcomponent of a product type (i.e. the subelement will always exist) and the prism is a reference to a subelement of a sum type (the subelement might not exist in the larger type) ? 
12:36:51 <shachaf> That is one property of a sum type, yes.
12:38:53 <dgpratt> huh
12:38:58 <dgpratt> third time's a charm, I guess
12:39:14 <athan> What's a good way to have small-scale parallelism & concurrency? I'm looking for a concurrent `getFirst . foldMap First`, if that makes sense
12:39:40 <bitemyapp> athan: sparks
12:39:55 <Cale> You probably want parallelism and not concurrency?
12:39:57 <athan> bitemyapp: Well, yeah, but howwww
12:39:57 <bitemyapp> more parallelism than concurrency tho
12:40:02 <bitemyapp> yeah what Cale said.
12:40:03 <athan> Cale: That's what I was thinking
12:40:11 <athan> I don't need to evaluate the whole list, though
12:40:17 <athan> maybe operate in groups of 4 or something?
12:40:19 <bitemyapp> I already linked you that one library.
12:40:21 <Jello_Raptor> okay, let's start a little lower: I don't see why `Choice p` requires `Profunctor p` rather than `Bifunctor p`. Choice seems to imply two parrelel computation which can be chosen between depending on the runtime state rather than a computation that enters a context does something and leaves that context :/ 
12:40:24 <bitemyapp> make a strategy that does what you want
12:40:33 <athan> bitemyapp: Hrm. Trying atm
12:40:37 <bitemyapp> not that hard to just chunk the existing perMap implementation.
12:40:50 <bitemyapp> [a] -> [[a]], each sublist is the chunk size you spark on
12:40:52 <bitemyapp> parMap the chunk
12:40:52 <athan> bitemyapp: chunk?
12:40:57 <athan> oh!
12:40:58 <bitemyapp> nobody succeeded? next chunk.
12:41:02 <bitemyapp> ez pz
12:41:07 <athan> haha
12:41:10 <Jello_Raptor> shachaf: sorry meant to ping you with that last line of mine. 
12:41:14 <shachaf> If you don't like the name Choice, you can use a different name.
12:41:16 <athan> thanks bitemyapp
12:41:19 <bitemyapp> this sort of thing where we use lists as control structures I think is partly why Cale is fond of them
12:41:26 <bitemyapp> athan: np
12:41:34 <shachaf> But it isn't implying any of those things. I don't even know what those things would mean.
12:46:52 <Jello_Raptor> shachaf: the name doesn't matter really. And I'm thinking of Choice as a generalization of Either, with "bimap :: (a -> b) -> (c -> d) -> Either a c -> Either b d" and "Profunctor" with the pariticular instance "dimap :: (a -> b) -> (c -> d) -> ((->) b c) -> ((->) a d)" 
12:47:18 <Jello_Raptor> shachaf: there's something I'm missing here, and I have no clue what it is >_< 
12:51:48 <Jello_Raptor> I see no way to connect my model of "Choice" to my model for "Profunctors", which probably means my model for "Choice" is wrong
12:54:20 * hackagebot microlens 0.3.4.1 - A tiny part of the lens library with no dependencies  https://hackage.haskell.org/package/microlens-0.3.4.1 (Artyom)
12:54:32 <indiagreen> johnw: look, no ambiguity now
12:57:01 <shachaf> Jello_Raptor: That is not Profunctor.
12:59:11 <qmm> `stack install wreq && ghci` ... Prelude> import Network.Wreq -- Could not find module ‚ÄòNetwork.Wreq‚Äô
12:59:15 <indiagreen> Jello_Raptor: I think that if you see a Profunctor as a black box which has input and output ‚Äì but you can't influence what's going on inside that box ‚Äì then a Choice is a box which can be modified to pass some values thru unchanged (by tagging them with e.g. Left)
12:59:19 <shachaf> Jello_Raptor: Maybe Strong won't have as many red herrings for you.
13:01:06 <geekosaur> qmm: stack installs into sandboxes by default. "stack ghci"
13:01:37 <qmm> geekosaur: thank you
13:07:18 <Jello_Raptor> indiagreen: ahh okay, that works better for understanding both Strong and Choice 
13:08:08 <indiagreen> shachaf: is my analogy actually correct? 'cause I'm not really sure about it
13:16:26 * hackagebot dicom 0.2.0.0 - A library for reading and writing DICOM files in the Explicit VR Little Endian transfer syntax.  https://hackage.haskell.org/package/dicom-0.2.0.0 (PhilFreeman)
13:23:23 <glguy> Jello_Raptor: The answer to your Maybe/total lens question was "no, you can't do that"
13:24:53 <glguy> Imagine: data Ex = L Int Char | R. If you tried: set intField (Just 0) R you'd have to materialize a Char value
13:25:24 <glguy> and if your choice was to ignore the set you've violate the lens law that says: view intField (set intField (Just 0) r) == Just 0
13:25:33 <Jello_Raptor> glguy: mhmm
13:26:51 <Darwin226> Hey guys. Can someone tell me why this doesn't work? http://lpaste.net/140278
13:27:15 <Darwin226> this is the error http://lpaste.net/140279
13:28:30 <glguy> Darwin226: There's no way to determine what n1 or n2 are when using that constructor (without a functional dependency in the Collection type class)
13:28:50 <Darwin226> So if I make the n depend on the c in the class, it will work?
13:29:11 <Darwin226> Yeah, it does
13:29:30 <Darwin226> glguy: Am I losing something obvious by doing that?
13:29:52 <Darwin226> glguy: Other than the fact that n might no depend on c. Haven't decided on that yet
13:29:59 <glguy> Darwin226: You're losing the ability for n to vary independently from c in the instances of your class
13:30:36 <Darwin226> glguy: Currently I'm thinking this wont matter because the c will aways be a type that has it's own n as a type parameter
13:30:47 <Darwin226> glguy: Does this sound like an obviously bad idea?
13:31:03 <glguy> Darwin226: I don't know what Collection is, so I don't know if it's a bad idea
13:31:36 <Darwin226> glguy: We'll see then.
13:31:51 <shachaf> indiagreen: I'm not sure, I hadn't thought of that perspective.
13:32:16 <shachaf> indiagreen: I guess you could say a similar thing about Strong.
13:44:57 <athan> bitemyapp: What chunk size would you use?
13:45:15 <athan> (for <> over Maybe Int, for example)
16:04:26 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
16:04:26 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
16:04:36 <glguy> Not really, but just check out: http://hackage.haskell.org/package/base-4.8.1.0/docs/System-Console-GetOpt.html
16:05:46 <indiagreen> I wonder whether Fernandos's actual question is ‚ÄúI wonder how would I solve this problem in Haskell elegantly‚Äù (which would explain why ‚Äúuse a library‚Äù isn't a solution)
16:06:01 <Fernandos> I can't think of an alternative that solves that... maybe there is a mathematical theory like set theory, combinatorics or yoneda lemma etc. that would be a natural fit to that type of "structure"
16:06:24 <Fernandos> indiagreen: Thank you :) That's what I meant!
16:06:53 <glguy> It'd be more obvious what you were trying to avoid doing if you made an example that did it
16:08:36 <glguy> or just identified what existing libraries were doing that was going disqualified
16:08:37 <Fernandos> glguy: I think there is an infinite way of solving the issue of order "independent, rule based combinable fuzzy option parsing". Think --compile -h is allowed, but ie. --compile --compile isn't
16:09:43 <Fernandos> Maybe I'll show you some random C option parsing code to get a feel of why I feel this an issue I'm eager to find an elegant Haskell solution for.
16:10:10 <glguy> I'm more interested in how the existing Haskell libraries for this are insufficient than how the C code is, at least
16:10:24 <glguy> but maybe the problem is the same
16:11:58 <indiagreen> Fernandos: I think it's an interesting problem but in reality everyone just special-cases stuff anyway. Take optparse-applicative, for example ‚Äì it doesn't handle ‚Äú-h‚Äù generically but stores help text for each command and option in a structure called OptProperties
16:13:29 <indiagreen> Fernandos: so I guess just having a tree of options/suboptions/subsuboptions/etc + a few special cases like ‚Äú-h‚Äù suffices for 98% of real world cases and nobody bothers with the rest
16:14:29 <Fernandos> indiagreen: I was thinking that option parsing is a problam that appears so frequently and appears to be solved but is in realy just hiding away the fact that the options are a definable "data-structure" which just seeks the proper encoding/decoding algorithm
16:14:38 <Fernandos> it deserves
16:15:06 <indiagreen> that's what both optparse-applicative and cmdargs do, actually
16:15:20 <indiagreen> you define a data structure, you define how options are parsed into it
16:17:31 <Fernandos> Oh I see it defines a kind of DSL for that..
16:17:41 <indiagreen> and there's a number of predefined parsers for common cases, like ‚Äúthis is a switch and it corresponds to a Bool‚Äù, ‚Äúthis is an optional thingy and it corresponds to a Maybe‚Äù, etc
16:17:50 <indiagreen> yeah, a kind of DSL
16:18:16 <indiagreen> on one hand, it's convenient because then it can generate help text and overview of flags and whatever for you
16:19:15 <indiagreen> on another hand, if you want for some reason to have e.g. an infinity of options going like ‚Äú--1‚Äù, ‚Äú--2‚Äù, ‚Äú--3‚Äù, etc, I think you'll be out of luck
16:19:26 <indiagreen> (I think)
16:20:08 <indiagreen> on the 3rd hand, it also generates bash autocompletion automatically so I guess I can live without weird stuff I might or might not want
16:21:11 <indiagreen> on the 4th hand, creating the most extensible, universal, and convenient option parser at once would be an interesting challenge worthy of a blog post or ma-aybe even a research paper, who knows
16:21:21 <indiagreen> on the 5th hand, there are more interesting things to do anyway
16:21:24 <Fernandos> In commander (popular C opt-parser) you define the interface to the options like this: https://github.com/clibs/commander/blob/master/test.c#L21 and really it's what all libraries I know also do, but using different implementations. This hides away the nested conditionals that were used to provide the interface 
16:22:59 <Fernandos> indiagreen: I have nothing better to do :) Have been writing up the backend/frontend for a startup the whole week and was knee deep in model driven development last month
16:23:10 <indiagreen> well, it looks like our libraries are more feature-complete than commander
16:23:30 <Fernandos> definitely!
16:23:52 <indiagreen> https://github.com/clibs/commander/issues/19
16:23:58 <indiagreen> and they also can be built on Linux!
16:25:28 <Fernandos> guess that's irony.. the poor guy passed the wrong "options" via the makefile to the compiler
16:25:48 <indiagreen> Fernandos: well, if you have nothing better to do then you can look at cmdargs and optparse-applicative, identify what they can't do easily (or at all), and try your hand at a design that would be better
16:26:15 <indiagreen> that would be pretty cool to read about
16:29:22 <Fernandos> I'm thinking too C like.. maybe creating jumptables that encode the matrix of options then output the correct order of functions to jump into. That's why I thought you surely have better ideas, ie. some mathematical theory that I've not heard about that could be used to encode the structure more naturally
16:30:36 <Fernandos> I could use graph structures, a simple neuronal network, or create a dsl that utilizes a combinatorics library
16:31:02 <indiagreen> I'm not sure how a neural net would help here
16:32:22 <indiagreen> also it sounds like you haven't looked at already existing libraries before, and I think you should
16:32:46 <Fernandos> http://cs.stanford.edu/~danqi/papers/emnlp2014.pdf for example a simple dependency parser. I mean nn's can be used for finding regressions or parsing language
16:33:27 <Fernandos> indiagreen: I usually use pure haskell haven't used any libraries yet :) am still a novice in Haskell =)
16:34:59 <Polarina> You're doing great!
16:35:18 <Fernandos> I find that most libraries in Haskell lack the documentation and the last time I tried I didn't understand howto use it. Then when I found out, it didn't compile because of dependencies which I couldn't solve after spending 12hours compiling and figuring things out
16:36:40 <indiagreen> Fernandos: first of all, I admit that I don't understand how the paper is related (it looks like it's about somewhat-accurate parsing of natural languages, and I definitely want stronger guarantees for parsing command-line options)
16:37:41 <indiagreen> second‚Äî nah, I don't have a second
16:38:44 <Fernandos> That was just an example that illustrates how a dependency parser can be used to follow rules. You could also solve that using a combinatorics library 
16:39:51 <Fernandos> Is there a finite-state machine based PEG parser in haskell? I could use that to define a maybe more natural language for option parsing
16:40:18 <Fernandos> that way you can backtrack ie. and solve dependencies too
16:41:59 <Fernandos> ie. Red is using a FSM PEG parser called PARSE ( http://www.red-lang.org/2013/11/041-introducing-parse.html ) 
16:43:20 <levi> I think there's a PEG parser or two in hackage, but I don't know much about them.
16:45:28 <Fernandos> Thank you levi. I looked and found pounder and peggy.. I am probably too noob to use ponder. The whole description page reads: "Ponder is PEG parser combinator. This Library is experimental."
16:46:29 <Fernandos> https://github.com/chrisdone/frisby a little looks more promising
16:47:43 <Fernandos> I think an option parser made using frisby would be really awesome. 
16:49:07 <levi> I don't think any of the PEG parsers are actively maintained. Hopefully you'll be able to get them to work for you, though.
16:50:27 <rewrite_> Did anybody experience the error "cabal: tests: inappropriate type" while using "cabal sdist" to create a tar-ball for hackage?
17:05:43 <indiagreen> hm, a rather interesting thing is that cabal code doesn't seem to mention ‚Äúinappropriate type‚Äù anywhere
17:07:19 <glguy> InappropriateType is a GHC IOError constructor
17:07:55 <indiagreen> okay, didn't know about that
17:08:35 <glguy> rewrite_: Maybe your directory structure is funny or your CWD is a directory that you deleted or...
17:08:41 <Fernandos> worth sharing http://2015.icse-conferences.org/program/main-conference
17:08:58 <rewrite_> hm :( 
17:10:17 <rewrite_> I tried to follow tutorials and looked at the lens library for the directory structure + .cabal file
17:10:53 <rewrite_> if somebody would mind to look it up - http://github.com/cirquit/UTFTConverter
17:11:29 <rewrite_> another interesting thing, if I comment the test suite, rebuilt it, the error is still there
17:13:08 <glguy> rewrite_: I don't think it's the current problem, but your executable should not be in the same directory as your library source
17:13:09 <Fernandos> rewrite_: whenever I fail to compile a library required by something I try to use it on fpcomplete.com
17:13:24 <Fernandos> or stack, their cabal alternative
17:14:16 <rewrite_> glguy: i'll try to move it, thank you
17:14:20 <Fernandos> I've heard many good things about using NixOs with Haskell, because it keeps all libraries hashed in /nix/appName-<hash>, therefore leading to much less recompilaiton
17:14:44 <Fernandos> maybe that works without using NixOs and just their package manager called "nix"
17:15:40 <glguy> rewrite_: Found it:
17:15:46 <glguy> remove tests from extra-source-files
17:16:05 <Fernandos> weird bug..
17:16:17 <glguy> It tried to copy "tests" into the tarball as a file
17:16:25 <glguy> but you can't open a directory as a file
17:16:33 <Fernandos> why would tests cause the pkg to fail compilation
17:16:53 <glguy> Fernandos: "cabal sdist" is a command that creates a tarball of your project for release
17:17:05 <Fernandos> cool didn't know that!
17:17:05 <refefer> glguy: how python-y
17:17:23 <glguy> python can't open directories as files, either?
17:17:31 <rewrite_> glguy: wow, you are my saviour, it worked!
17:17:32 <Fernandos> refefer: how is that related to python, can you create a tarball of your python app with pip??
17:18:08 <rewrite_> if you want, you can answer this question on stack overflow - http://stackoverflow.com/questions/32343301/cabal-sdist-tests-inappropriate-type
17:18:53 <glguy> There you go
17:19:21 <rewrite_> Thank you very much for your help!
17:19:35 <glguy> quite welcome ^_^
17:22:03 <rewrite_> glguy: related question - how did you know this was the error?
17:22:36 <glguy> Inappropriate type has to do with using files/directories as directories/files
17:22:51 <glguy> then I read through the cabal file and considered how to apply that error to each line of the file
17:23:05 <glguy> If the file name wasn't "tests" it would have been less confusing
17:23:12 <glguy> err, directory name :)
17:23:59 <glguy> I didn't know that inappropriate type meant that at first, so I Goggled: site:hackage.haskell.org "inappropriate type"
17:24:29 <glguy> once I learned that it was the InappropriateType exception I regoogled that constructor and found it showing up in the directory package all over
17:25:18 <rewrite_> that might be a good thing to remember. I just googled the error message and got nothing, so I didn't know where to start. Thank you for the explanation
17:25:28 <tomberek_> is something like this possible in Template Haskell:   rewriteRule = \ [quasi| id . f |] -> [| f |]     I can do: [quasi| id . id |] -> [| id |] but the binding for "f" doesn't seem to work as the TH documentation indicates
17:25:54 <tomberek_> from GHC docs "A pattern quasiquoter may generate binders that scope over the right-hand side of a definition because these binders are in scope lexically."
17:40:43 <bitemyapp> athan: optimal chunk size can be measured
17:40:47 <bitemyapp> athan: so measure it :P
17:44:35 * hackagebot UTFTConverter 0.1.0.0 - Processing popular picture formats into .c or .raw format in RGB565  https://hackage.haskell.org/package/UTFTConverter-0.1.0.0 (cirquit)
18:53:40 <athan> Hrm. My code is running much slower when providing `+RTS -N -RTS` to my -threaded executable. What gives?
18:54:12 <athan> I also tried using some parallel strategy stuff to help this out, but the act of breaking up my list into manageable chunks made it worse
18:56:26 <athan> Does ST benefit from -N?
18:56:45 <enolan> not if you don't use par
18:57:32 <enolan> it's possible sparks are completely ignored when you run your program with only one thread
18:57:38 <enolan> I don't know that area well
18:57:46 <athan> enolan: Hm, okay
18:57:50 <athan> thanks :)
18:57:59 <enolan> but each spark has an overhead, so too many = slow program
19:03:17 <athan> Is Float the Integer equivalent for Double?
19:03:25 <athan> Or is it a 32 bit encoding or something?
19:05:10 <athan> wait cool got it :)
19:05:22 <dfranke> athan: Float is an IEEE754 single-precision floating point. For exact arithmetic you want Rational.
19:07:18 <Arahael> But yes, float is a 32-bit encoding. :)
19:07:46 <Arahael> After a fashion.  IEEE754  is complicated.
19:10:46 <geekosaur> CReal is available on Hackage. Note that you will get an infinite loop if you hand it a transcendental number
19:11:36 <shachaf> geekosaur: If you hand what a transcendental number?
19:12:12 <geekosaur> do I need to be ultrapedantic to answer you?
19:12:29 <geekosaur> CReal math is known to fail in the presence of transcendental numbers because their representation is infinite
19:12:31 <shachaf> No, I'm not sure I understand what you mean.
19:12:46 <geekosaur> this is, IIRC, documented
19:13:05 <shachaf> That sounds strange. Certainly CReal has no issue with some transcendental numbers.
19:13:15 <geekosaur> (although I do wonder how you do it given that, if the starting type is Double, it is by definition a finite approximation)
19:14:48 <shachaf> I've never heard this. What's the documentation you're talking about?
19:16:14 <nshepperd> are you talking about == for CReal being partial?
19:16:37 <shachaf> I'm having a hard time thinking what the issue with transcendental numbers in particular would be. Unless you just mean that almost all numbers are transcendental, in which case, sure, but you might as well say "irrational".
19:17:41 <athan> Would STM be a decent replacement for ST?
19:17:51 <athan> so I can automate some of the multithreading? :\
19:18:11 <hodapp> not only transcendental, but uncomputable.
19:19:27 <shachaf> (==) for CReal is partial, but that's true even for numbers like 0.
19:19:41 <dmj`> athan: you can use mutable arrays with stm
19:19:54 <shachaf> nshepperd: Actually it's not true, because (==) only compares 40 digits.
19:20:17 <athan> dmj`: Ahh okay, so there's some specialized use cases
19:20:33 <athan> I'm currently using ST to generate index numbers for anything Foldable, if that makes sense
19:20:43 <athan> Wondering if there might be any benefit :\
19:23:11 <emmanuel_erc> hello there everyone
19:23:17 <dmj`> athan: why not generate index numbers lazily from a list
19:26:28 <athan> dmj`: I'm comparing benchmarks :)
19:31:25 <emmanuel_erc> Just thought  I would ask if you guys think there are any good reasons (besides, getting thebest performance possible) to not use Haskell?
19:31:53 <kadoban> emmanuel_erc: real-time computing probably?
19:32:17 <kadoban> Most kinds of embedded I'd suspect.
19:32:20 <emmanuel_erc> I am actually using haskell to do numerical computations for image processing/computer vision.
19:32:56 <emmanuel_erc> I see, for your second point, would that be because of the constrained resources?
19:33:31 <dmj`> athan: let me know what you find
19:33:40 * hodapp is using Haskell for embedded at his day job.
19:35:16 * dfranke considers uploading an acme-russells-paradox package to hackage, with a dependency on acme-everything.
19:35:24 <kadoban> hodapp: Is there like special compilers and special RTS for it or something, out of curiosity?
19:36:49 <hodapp> emmanuel_erc: Performance can be a bit of a red herring. A language that can make it vastly easier to see what your algorithm is actually doing at a high level, and lets you parallelize it fairly effortlessly across multiple cores or multiple hosts, can make something scale vastly better and quickly surpass the constant-factor speedup that a low-level implementation may give you.
19:36:49 <dmj`> emmanuel_erc: what libraries are you using? Just curious
19:37:12 <hodapp> kadoban: I'm using Ivory and another library, Ion, of my own making (but which was based an Atom)
19:37:46 <emmanuel_erc> For right now, I am using Data.Vector and Hmatrix
19:37:46 <emmanuel_erc>  
19:37:55 <emmanuel_erc> Sorry for the extra line. My bad
19:38:18 <emmanuel_erc> Do you use streams hodapp?
19:38:20 <hodapp> kadoban: to be clear, I'm not running Haskell *on* the target. I'm using Haskell to generated code for the target.
19:38:34 <kadoban> Ahhh
19:38:42 <hodapp> but, one still reaps a lot of benefits that way
19:38:53 <hodapp> emmanuel_erc: On my embedded code, no
19:38:55 <emmanuel_erc> I am going to be honest, I still have a lot to learn about Haskell.
19:39:24 <hodapp> So do most of us here!
19:39:26 <emmanuel_erc> So please understand that there may be unfilled holes in my knowledge base.
19:42:14 <hodapp> emmanuel_erc: but, I'd say that people who have no interest in learning about static typing, purity, or how to work with immutable objects likely will find nothing but trouble in Haskell.
19:43:43 <emmanuel_erc> I find these concepts very interesting. But, I've recently learned how it's possible to enforce strictness in haskell, but I still don't really have a grasp (at I don't think I do) on how to use laziness effectively.
19:43:55 <emmanuel_erc> I haven't been able to find any good sources for this.
19:44:10 <emmanuel_erc> Or at least very compelling examples IMO.
19:44:30 <hodapp> one standard way is working with infinite structures.
19:45:09 <hodapp> and, rather than relying on explicit generators or something to that effect, just generating the entire infinite structure and getting what you need out of it
19:46:40 <scshunt> or the infamous fibonacci example
19:46:44 <hodapp> Most guides you'll find on Haskell will deal with laziness, but they won't spend much time singling it out.
19:47:30 <scshunt> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
19:47:55 <scshunt> > :let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
19:47:57 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
19:47:59 <scshunt> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
19:48:00 <lambdabot>  <no location info>:
19:48:01 <lambdabot>      not an expression: ‚Äòlet fibs = 0 : 1 : zipWith (+) fibs (tail fibs)‚Äô
19:48:09 <emmanuel_erc> lol
19:48:11 <scshunt> bleh, I forget how to let :)
19:48:14 <scshunt> anyway
19:48:21 <emmanuel_erc> that exists.
19:48:25 <scshunt> the function can't be evaluated strictly, as it produces an infinite list
19:48:30 <dmj`> emmanuel_erc: understanding the compilation pipeline of ghc, and each of the intermediate steps (core, stg, asm) can help understand performance
19:48:38 <dmj`> emmanuel_erc: http://lambda.jstolarek.com/2013/04/haskell-as-fast-as-c-a-case-study/
19:48:46 <glguy> My whole day at work was just one fibonacci sequence after another. Thanks Haskell
19:49:52 <Alpha64> don't get me started on factorials
19:51:04 <emmanuel_erc> Should I use the state monad to implement the fibonacci sequence?
19:51:11 <emmanuel_erc> <srs question>
19:51:17 <glguy> no
19:51:25 <scshunt> emmanuel_erc: you could. But I can't imagine why you would.
19:51:41 <Clint> you shouldn't implement the fibonacci sequence
19:52:52 <dmj`> > take 10 fibs
19:52:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
19:53:33 <emmanuel_erc> > take 20 fibs
19:53:35 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
19:55:57 <scshunt> > fibs
19:55:58 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
19:56:26 <emmanuel_erc> k
19:56:38 <kadoban> > drop 1000 fibs
19:56:40 <lambdabot>  [434665576869374564356885276750406258025646605173717804024817290895365554179...
20:02:47 <athan> dmj`: https://htmlpreview.github.io/?https://github.com/athanclark/listvsgeneric/blob/master/profile.html
20:02:54 <athan> when I run it with -N1
20:03:17 <athan> STM is the seventh one down, I think
20:03:26 <athan> sixth
20:04:48 <dmj`> athan: the mustard color
20:09:15 <athan> dmj`: djonn
20:11:16 <athan> dmj`: And here's with -N: https://htmlpreview.github.io/?https://github.com/athanclark/listvsgeneric/blob/master/profile2.html
20:11:24 <athan> again, the 'stard color
20:11:31 <athan> gettin' 'stard, brah?
20:14:05 <athan> Interesting is that it's like a more-uniform version of the [Int] case
20:14:08 <athan> STM, I mean
20:14:27 <athan> the lists are faster, but sparatic (i guess ._.)
20:25:00 <bitemyapp> athan: sporadic?
20:26:02 <dfeuer> Are there any libraries with length-indexed sequences?
20:26:34 <jle`> dfeuer: sequences in what sense?
20:26:52 <bitemyapp> athan: lists are faster in what case?
20:27:07 <bitemyapp> oh than STM?
20:27:19 <bitemyapp> I suppose so. ST Strict looks like the overall winner?
20:27:20 <dfeuer> jle`, I was being vague, but I was thinking something more flexible than dependent vectors; more like Data.Sequence but with  Seqn 5 x being a sequence with 5 elements.
20:27:24 <bitemyapp> barely better than list tho.
20:28:15 <dfeuer> jle`, I've spent a bit of time today faking it with a wrapper over Data.Sequence, but I wonder if anyone's worked a bit harder on it and made a nice interface and all.
20:33:12 <bitemyapp> Anybody here into NLP?
20:33:41 <scshunt> I've dabbled
20:33:41 <dfeuer> bitemyapp, what's that?
20:33:47 <scshunt> natural language processing
20:34:12 <dfeuer> Sounds hard.
20:34:30 <bitemyapp> dfeuer: yeah, fun though.
20:34:54 <dfeuer> How's it work?
20:35:03 <scshunt> in many ways!
20:35:38 <scshunt> the bit that I have some experience with is trying to develop code to take a structural description of English and take the words and inflect and relate them into a sentence
20:36:11 <dfeuer> So the "unparsing" side?
20:36:18 <bitemyapp> scshunt: best I'm aware of is: http://hackage.haskell.org/package/chatter
20:36:35 <bitemyapp> scshunt: you know of any other NLP kit? I was thinking of trying to build up to something more shake-n-bake like spaCy/NLTK
20:36:40 <scshunt> I don't
20:36:44 <scshunt> I was working in C
20:36:45 <bitemyapp> dfeuer: it's what Google pays a boatload of people to do.
20:36:49 <scshunt> dfeuer: yeah
20:37:01 <bitemyapp> scshunt: ah right. You look at Senna?
20:37:18 <scshunt> bitemyapp: no
20:37:32 <bitemyapp> scshunt: possibly of use to you": http://ml.nec-labs.com/senna/
20:37:53 <scshunt> most of what I saw in NLP was in terms of starting with language and trying to analyze it, not the reverse
20:38:20 <Reasoning> Anyone know what other channels redwire visits?
20:38:22 <scshunt> senna appears to be the same
20:39:20 <davidar> bitemyapp: nltk on Haskell would be great
20:43:04 <davidar> bitemyapp: what kind of nlp in particular?
20:50:23 <bitemyapp> davidar: _shrug_
20:50:34 <bitemyapp> I'm still learning.
20:52:08 <davidar> bitemyapp: I know a little bit of nlp if that helps :)
20:52:10 <bitemyapp> davidar: I still need to review your IPFS Haskell code don't I?
20:52:22 <bitemyapp> davidar: if so, link it please.
20:52:23 <davidar> mostly in the context of statistical models
20:52:45 <bitemyapp> davidar: if you have books/resources you would suggest, I'd really appreciate recommendations.
20:53:19 <bitemyapp> https://github.com/davidar/hs-ipfs-api here right?
20:53:43 <davidar> bitemyapp: yeah
20:54:09 <bitemyapp> on it.
20:54:30 <davidar> OK, I'll dig up some nlp stuff in a minute
20:56:32 <mniip> how would I run a BFS over an Eq a => Set (a, a)
21:00:22 <bitemyapp> davidar: danke
21:03:52 <jle`> dfeuer: there's V in linear, and a coule of other packages if you searched for fixed vectors on hackage.  or did you mean the underlying implementation is using Seq?
21:04:12 <dfeuer> jle`, that's not necessarily critical.
21:04:21 <dfeuer> But
21:04:25 <dfeuer> hmm
21:04:57 <dfeuer> jle`, where this started was wanting to come up with a vectory sort of Representable instance.
21:05:00 <jle`> in linear you have `V 5 a` to be a vector with 5 elements containing a's
21:05:37 <dfeuer> So I wanted something with a good `index` and `tabulate`.
21:05:54 <bitemyapp> davidar: how does the protobuf stuff work?
21:06:02 <dfeuer> There are a lot of good options for `index`, but fewer for `tabulate`.
21:07:01 <davidar> bitemyapp https://hackage.haskell.org/package/hprotoc
21:07:46 <dfeuer> But now I seem to be a bit stuck, because I don't see a way to do arithmetic with SNats...  Is there a function somewhere like  add :: SNat m -> SNat n -> SNat (m :+ n) ?
21:07:52 <davidar> Couldn't work out how to run it with cabal so just put it in a makefile
21:08:25 <bitemyapp> davidar: hahahaha, my coworker maintains that.
21:08:32 <bitemyapp> hokay then.
21:21:26 <dfeuer> Does anyone know of a way to do arithmetic on SNat, without unsafeCoerce?
21:21:57 <dfeuer> I can't seem to find the right tools ...
21:22:09 <dfeuer> bitemyapp?
21:38:32 <mniip> dfeuer, %+
21:38:38 <mniip> (%+) :: SNat n -> SNat m -> SNat (n :+: m)
21:41:36 <dfeuer> mniip, how the bleepity bleep was I ever supposed to find that?
21:41:46 <dfeuer> Also, where are the rest of them?
21:41:59 <mniip> dfeuer, I just googled SNat
21:42:06 <mniip> found Data.Type.Natural
21:42:07 <glguy> I Googled for "SNat" and found that on the first result
21:42:17 <glguy> and then assumed that that must not be what you were asking about because it would have been too obvious
21:43:32 <mniip> dfeuer, also never take an unsafeCoerce to type-witnessing GADTs
21:43:37 <dfeuer> o.O
21:43:49 <mniip> you basically take all their power, all their purpose, and throw it to the trashbin
21:44:25 <dfeuer> mniip, well ... it's not ideal ... but libraries do that.
21:45:07 <dfeuer> mniip, glguy, I was just digging digging digging through the singletons package, and not finding the right things; I also looked into GHC type literals. I didn't think to look elsewhere altogether.
21:45:34 <mniip> type literals have nothing to do with SNat
21:47:00 <dfeuer> mniip, now you're really confusing me.
21:47:08 <dfeuer> oh.
21:47:11 <dfeuer> Well, not directly.
21:47:16 <dfeuer> But type literals are KnownNat.
21:47:34 <mniip> that's a typeclass
21:47:39 <dfeuer> Yes.
21:47:47 <dfeuer> And SNat is a witness to it.
21:50:24 <dfeuer> This is my first time playing with singletons, so I hope you'll excuse my ignorance.
21:50:33 <dfeuer> They're a bit crazy.
21:51:46 <athan> bitemyapp: the first link was with -N1, but the second was with -N, for arbitrary number of system threads (right?)
21:54:22 <lethjakman> should .stack-work be commited to git?
21:54:58 <kadoban> lethjakman: ‚Ä¶ no
21:55:27 <lethjakman> kadoban: that's kinda what I thought. thanks :)
21:55:47 <kadoban> Basically anything generated should never be
21:55:57 <kadoban> (unless sometimes you can't avoid it)
21:56:23 <lethjakman> kadoban: that's a fair way to put it
21:56:33 <lethjakman> I just wasn't sure if user commands could alter it in a way that configuration couldn't
21:57:45 <dfeuer> er ... mniip, this is confusing.  Data.Type.Natural and Data.Singletons.TypeLits define a bunch of different things with the same names. What am I supposed to do?
21:59:28 <exio4> I am guessing it's the same thing working in different levels
21:59:36 <exio4> (type level, value level, ...)
21:59:40 <mniip> dfeuer, use only one package?
22:00:09 <dfeuer> exio4, it appears that it is two radically different sorts of "naturals", one with GHC type literals and the other with Peano arithmetic.
22:00:24 <exio4> I thought you were talking about the same module, sorry
22:08:23 <dfeuer> exio4, it's ... ugh. Not fun. I'm kind of thinking the thing to do under the circumstances is to use unsafeCoerce to define some basic functions, and then do the right thing from there. But I can't help thinking someone's probably put together just the library I want.
22:11:01 <dfeuer> Using Peano arithmetic will never get me the asymptotic performance characteristics I'm after.
22:11:34 <mniip> dfeuer, what are you trying to do
22:11:41 <mniip> something's telling me you don't want singletons
22:12:24 <dfeuer> mniip, for the heck of it, I decided it would be fun to figure out a way to make a vectory sort of Representable instance.
22:12:55 <dfeuer> So I need something akin to a length-indexed vector,
22:13:01 <dfeuer> and something akin to a Fin.
22:13:13 <mniip> then you don't want singletons
22:13:20 <mniip> you want regular type-level arithmetic
22:13:32 <mniip> be it SNat or TypeLits
22:13:44 <dfeuer> Sure.
22:13:46 <dfeuer> OK.
22:14:15 <dfeuer> But the singletons package has tools for doing basic things with TypeLits.
22:14:23 <dfeuer> That I can't seem to find elsewhere.
22:14:29 <dfeuer> Which doesn't mean they're not elsewhere.
22:14:45 <mniip> data Vector a n where Fin :: Vector a Ze; Cons :: a -> Vector a s -> Vector a (Su s)
22:14:58 <mniip> data Vector a n where Fin :: Vector a 0; Cons :: a -> Vector a n -> Vector a (1 + n)
22:15:17 <dfeuer> mniip, yes, that's just fine if O(n) access is acceptable :P
22:15:18 <mniip> + comes from GHC.TypeLits
22:15:52 <dfeuer> I want tabulate to construct its result lazily, with logarithmic access :)
22:16:24 <mniip> data Vector a n = Vector (forall s. MutableByteArray# s)
22:16:37 <dfeuer> Now you're getting into low-level scary stuff.
22:16:54 <dfeuer> Which is okay, I suppose.
22:17:03 <exio4> you want some kind of safe-interface over normal vectors?
22:17:20 <dfeuer> I dunno; just playing with ideas right now.
22:17:21 <davidar> bitemyapp: here's some links (not sure how helpful they'll be :) https://gist.github.com/davidar/f729ea14fa0ca7404110
22:18:39 <dfeuer> mniip, that sort of mutable vector trickery requires some way to determine what's already been memoized, right?
22:18:55 <mniip> memoized?
22:19:03 <dfeuer> Er...
22:19:41 <dfeuer> I mean, you presumably have to check the vector on index to see if the result has been stored at that index, and if not calculate and store, right?
22:21:47 <mniip> no?
22:21:58 <mniip> you just store a bunch of pointers to closures
22:22:09 <mniip> on a second thought you better use MutableArray# s
22:22:18 <mniip> it has proper garbage collection handling
22:22:26 <dfeuer> Hmmmm...
22:23:10 <dfeuer> That's an option; an interesting one even.
22:23:49 <mniip> or if you're into purity, Array#
22:23:58 <rprije> Hey, I have a question far you helpful Haskell community members :)  I defined a class with a method. You can think of the class as resembling/building upon on monad transformers. I have a type which is an instance of that class. The implementation of the class method happens to require that the wrapped monad is also a functor. How can I harmonise this method implementation without demanding that every instance of the class also constrains i
22:23:58 <rprije> ts wrapped types as functors? I'm currently getting "Could not deduce (Functor t)" errors because my implementation function has the Functor constraint, but my class method type does not have the same constraint.
22:24:04 <mniip> for functions to operate on them see GHC.Prim
22:24:55 <mniip> rprije, you can't
22:25:18 <mniip> rprije, if you don't mention t in the instance head, you can't place any constraints on it
22:26:10 <dfeuer> Thanks, mniip.
22:27:06 <rprije> Well, I can put the constraints in the method type declaration. I'm just not happy about constraining all instances as a result.
22:27:09 <mniip> rprije, you *could* make use of MPTC and ConstraintKind to pass a constraint to the instance, but that's such a wrong thing to do
22:27:11 <dfeuer> rprije, in base 4.8 (GHC 7.10) and later, Functor is a superclass of Monad.
22:27:22 <mniip> rprije, wait
22:27:30 <mniip> are you aware of liftM
22:27:34 <mniip> :t liftM
22:27:35 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
22:27:37 <rprije> Yeah I am
22:27:48 <dfeuer> fmap in disguise! *barf*
22:28:33 <mniip> :k WrappedMonad
22:28:34 <lambdabot> (* -> *) -> * -> *
22:28:53 <rprije> Heheh. I'm giving this specific example partly to see if there's a more general principle I can learn from it. Yeah, I can find Monad specific ways to get around Functor. But the specifics of which actual constraints I'm dealing with here are not quite the question I'm trying to ask.
22:29:46 <exio4> I don't understand the problem, you want a default implementation of a typeclass given that the type follows some constraint?
22:30:11 <mniip> rprije, in general, you can do this but it's ugly and everyone would disapprove
22:31:23 <rprije> It seems my class definitions are just necessarily going to constrain what sort of things I can do in my implementation. So I guess I have to either constrain my method types or find ways to not constrain my implementations.
22:32:25 <mniip> rprije, that's kinda the idea of typeclasses
22:32:32 <mniip> Set is not a Functor
22:32:45 <mniip> because its 'fmap' places an extra Ord constraint on the contained type
22:33:02 <nitrix> I'm looking for a function that'd look something like :: (b -> Bool) -> a -> b -> Either a b
22:33:45 <nitrix> Where given a check predicate, a Either is constructed with the sucessfully checked value or an error message.
22:33:45 <mniip> \p l r -> if p r then Right r else Left l ?
22:34:26 <nitrix> mniip: I was just wondering if I didn't miss on a Prelude function or point-free giberrish that'd achieve the same.
22:34:43 <mniip> I can produce pointfree gibberish
22:34:48 <rprije> mniip, k, thanks for the help :)
22:35:17 <Zemyla> You'd need an if' function: if' b t f = if b then t else f
22:35:25 <mniip> there is one
22:35:33 <Zemyla> In Prelude?
22:35:38 <mniip> in base
22:37:04 <mniip> :t (. ($ Right) . liftA2 . flip bool . Left)) . flip id
22:37:06 <lambdabot> parse error on input ‚Äò)‚Äô
22:37:12 <mniip> :t (. ($ Right) . liftA2 . flip bool . Left) . flip id
22:37:13 <lambdabot> (b -> Bool) -> a -> b -> Either a b
22:37:45 <Zemyla> :t bool
22:37:46 <lambdabot> a -> a -> Bool -> a
22:38:03 <mniip> it's a fold on booleans
22:39:49 <nitrix> :t flip head
22:39:51 <lambdabot> b -> [b -> c] -> c
22:39:51 * hackagebot hpc-coveralls 1.0.1 - Coveralls.io support for Haskell.  https://hackage.haskell.org/package/hpc-coveralls-1.0.1 (killy971)
22:40:00 <nitrix> What the heck is flip head?
22:40:18 <shachaf> @unpl flip head
22:40:19 <lambdabot> (\ b c -> head c b)
22:40:53 <nitrix> Head only has one argument though.
22:41:02 <mniip> nitrix, all functions only have one argument
22:41:18 <nitrix> Because of currying, I know that.
22:41:42 <mniip> so why do you think head cannot take a second argument?
22:42:20 <nitrix> What will it do, apply this to b? So it'd need to be a list of functions?
22:42:38 <mniip> yes, as you can see in the signature
22:43:48 <mniip> this is more interesting however
22:43:50 <mniip> :t flip read
22:43:51 <lambdabot> Read (b -> c) => b -> String -> c
22:43:54 <nitrix> It takes a b, a bunch of functions from b to c, and yields a c. So, by doing head on those, applying the first function... yeah that actually makes sense.
22:44:07 <nitrix> I'm just... impressed that this is even possible.
22:44:27 <bitemyapp> davidar: thank you
22:45:02 <bitemyapp> davidar: looks like an awesome list :)
22:45:04 <nitrix> mniip: Oh god.
22:46:02 <nitrix> I have never seen a constraint like that.
22:47:40 <davidar> bitemyapp: cool, ping me if you have any questions :)
22:48:13 <Zemyla> nitrix: Theoretically, read on functions is possible, even if show isn't.
22:48:40 <mniip> :t id + negate
22:48:41 <lambdabot> Num a => a -> a
22:48:46 <mniip> > (id + negate) 123
22:48:48 <lambdabot>  0
22:50:00 <latermuse> zemyla: can you make an example for read on functions?
22:51:39 <Zemyla> It'd basically be a Haskell parser, with an additional Typeable constraint on a and b to make sure types match.
22:52:12 <mniip> :t (sin ** 2 + cos ** 2)
22:52:13 <lambdabot> Floating a => a -> a
22:52:24 <mniip> > (sin ** 2 + cos ** 2) 1.25
22:52:26 <lambdabot>  0.9999999999999999
22:54:20 <nitrix> Black magic.
22:55:10 <mniip> nitrix, + takes 2 arguments right
22:55:55 <mniip> > (+) 1 2 3 4 5 6
22:55:57 <lambdabot>  3
22:56:10 <mniip> hmm that's slightly boring
22:57:06 <nitrix> Yeah, of type `a`, and you're tricking this `a` into `(a -> a)`, making `((a -> a) -> (a -> a))`.
22:57:47 <nitrix> I'm sure there's a term but it's still black magic at that point.
22:57:59 <nitrix> What happens if you read a function?
22:59:36 <ReinH> pretty sure the universe implodes
22:59:46 <nitrix> This thing :: Read (b -> c) => b -> String -> c
22:59:58 <davidar> huh, didn't know (sin ** 2 + cos ** 2) actually worked in haskell
23:01:19 <jle`> davidar: pretty much everything in that expression is overloaded, heh
23:01:27 <jle`> sin is overloaded, cos is overloaded, ** is overloaded, + is overloaded, and 2 is overloaded
23:01:39 <jle`> so you could really define that to be literally anything heh
23:02:29 <jle`> but the definitions for sin/cos/+/** that would make that work don't come with haskell normally, you'd have to define them
23:02:37 <jle`> and...i think the 2, as well
23:03:15 <davidar> jle`: ah, right, was pretty sure it didn't work out of the box last time i tried :)
23:03:32 <jle`> it's a cute party trick :)
23:04:22 <davidar> jle`: any libraries that actually let you do it properly?
23:04:28 <mniip> > (+) 1 2 3 4 5 6
23:04:29 <lambdabot>  1080
23:04:35 <mniip> now this is more interesting, because
23:04:36 <mniip> > 2 3
23:04:37 <lambdabot>  6
23:05:17 <jle`> davidar: there's this -- http://hackage.haskell.org/package/NumInstances
23:06:13 <jle`> :t 2 `asAppliedTo` 3
23:06:15 <lambdabot> (Integral a, Num b) => a -> b
23:06:16 <davidar> jle`: thanks
23:06:53 <jle`> np.  not that it's a good idea to actually use it, heh
23:08:18 <Zemyla> > flip 2 3 4
23:08:20 <lambdabot>  24
23:09:26 <Arahael> What?
23:09:35 <Arahael> > :t flip
23:09:36 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
23:10:03 * Arahael demands elaboration.
23:10:24 <ttt_fff> given that haskell's type checker is more complicated than Idris's; what are examples of code that Haskell can type check but Idris can not
23:10:27 <Arahael> :t flip
23:10:28 <lambdabot> (a -> b -> c) -> b -> a -> c
23:11:20 <kadoban> Arahael: I think someone made a Num instance for (a -> b -> c)
23:11:34 <mniip> [08:02:18] <lambdabot> (Integral a, Num b) => a -> b
23:11:50 <mniip> Num a => Num (a -> b)
23:11:52 <mniip> err
23:11:55 <mniip> Num b => Num (a -> b)
23:11:57 <mniip> it's an induction
23:12:05 <dfeuer> ttt_fff, most anything to do with Van Laarhoven lenses, unless you want a *lot* of type signatures.
23:13:08 <Arahael> kadoban: Ah, and in addition to that, lambdabot dosen't evaluate each query in a sandbox?
23:13:54 <kadoban> No, it doesn't. You can define long-running things. I'm ‚Ä¶ not sure how you implement typeclasses actually though.
23:14:01 <Zemyla> @undef
23:14:01 <lambdabot> Undefined.
23:14:08 <Zemyla> :t flip 2
23:14:09 <lambdabot> Num (a -> b -> c) => b -> a -> c
23:14:34 <mniip> kadoban, @let instance
23:14:43 <kadoban> Ah
23:14:49 <mniip> along with @let data, @let class
23:18:45 <Arahael> Curious domainname.
23:19:59 <Zemyla> Arahael: It doesn't exist. Don't ask why I checked.
23:21:02 <mniip> Arahael, Zemyla, yes it does
23:21:15 <kadoban> O.o what domain name?
23:21:19 <mniip> no-panties.org
23:21:26 <kadoban> Oh
23:21:36 <kadoban> I'd be shocked if that didn't exist, haha.
23:22:52 <Zemyla> It's not a webserver though.
23:23:20 <Arahael> Zemyla: There's more to the web than http. ;)
23:24:12 <Zemyla> What kind of service would no-panties.org offer?
23:24:28 <KaneTW> nopanti.es
23:26:24 <Arahael> Zemyla: Dunno. I assume they sell barbie dolls that are easy to dress.
23:26:29 <jle`> kadoban: lambdabot imports a file named L.hs, and we can add things to L.hs using @let
23:26:31 * Arahael has absolutely no imagination, thank goodness.
23:27:28 <kadoban> Oh is that all that @let does, just adds lines to the file? Funny
23:31:06 <jle`> yeah
23:31:23 <jle`> well, it also "tests" the file to make sure it doesn't raise any red flags
23:31:45 <jle`> if the new line is detected to cause trouble (like syntax error or something) then it won't add it
23:31:53 <jle`> it's also smart with ordering lines for imports
23:31:53 <kadoban> Ah yeah I guess it'd have to. Thanks though, that ‚Ä¶ makes @let a lot more understandable. I thought it had way more magic to it.
23:32:05 <shachaf> It has more magic to it.
23:32:25 <shachaf> Well, I guess not more magic than jle` just said.
23:32:48 <kadoban> Well ‚Ä¶ I thought each thing had special syntax, so I never really bothered trying to figure out how they worked because ‚Ä¶ ya.
23:44:55 * hackagebot woot 0.0.0.1 - Real time group editor without operational transform.  https://hackage.haskell.org/package/woot-0.0.0.1 (tgolson)
23:46:35 <Cale> Is it weird that I thought this package had something to do with mathematical groups?
23:47:01 <jle`> Cale: i was trying to interpret it in that light too
23:48:21 <KaneTW> same
