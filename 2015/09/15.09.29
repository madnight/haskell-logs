00:00:17 <Cale> (maybe you should take that as a challenge ;)
00:00:36 <Cale> But if your goal is to get things done, you at least don't *directly* want a type class here.
00:00:56 <Cale> Because the interface is going to be constructed using I/O operations at runtime.
00:01:30 <Cale> liste: here's another example...
00:02:29 <Cale> data GameObject = GO { timeStep :: DeltaTime -> [GameObject], display :: GameObject -> Drawing, handleEvent :: GameEvent -> [GameObject] }
00:02:52 <bollu> how would you represent a DFA / NFA in Haskell?
00:03:06 <bollu> in python I can use a dictionary of dictionaries or something cute like that
00:03:14 <bollu> what will be "natural" in haskell?
00:03:54 <bollu> 	Cale: why timeStep:: DeltaTime -> [GameObject[ ? why [] 
00:03:54 <bollu> ?
00:04:00 <jle`> bollu: you can represent it using a Map
00:04:27 <Cale> It's not strictly necessary actually
00:04:31 <jle`> you can simulate it using something like (a -> State s a)'s or Auto's
00:04:33 <bollu> jle`: oh, neat :)
00:04:39 <Cale> But the idea is to allow objects to fracture into many, or delete themselves
00:04:58 <bollu> Cale: oh, wow, that's a really cool way to model it. I'd never considered that [] == deleting
00:05:09 <Cale> However, just producing a GameObject is enough really, because you can write functions on GameObjects which represent composites
00:05:09 <bollu> Cale: damn.
00:05:12 <jle`> well, you can also just use plain old functions too
00:05:15 <jle`> instead of a Map
00:05:19 <bollu> jle`: how ?
00:05:54 <jle`> your transition function is just a PossibleState -> Input -> PossibleState
00:06:33 <Cale> rocket x v a = GO { .. } where timeStep dt = rocket (x + dt * v + (dt/2)^2 * a) (v + dt * a) a; ...
00:06:36 <bollu> jle`: hm, but, what if I want to manipulate the NFA? (like, I want to implement NFA -> DFA)
00:06:36 <jle`> i'm looking at https://en.wikipedia.org/wiki/Deterministic_finite_automaton#Formal_definition
00:06:42 <Cale> er, that's without the list :)
00:06:51 <bollu> Cale: bad person :P RK4, never Euler
00:06:57 <jle`> luckily haskell functions are first-class :)  so you can manipulate them like normal values
00:07:02 <Cale> bollu: huh?
00:07:13 <Cale> oh
00:07:15 <Cale> yeah, sure
00:07:17 <bollu> Cale: you're euler integrating :) don't
00:07:32 <Cale> I'm not writing you RK4 in a one liner, sorry
00:07:38 <mniip> woooow
00:07:38 * hackagebot composition 1.0.2 - Combinators for unorthodox function composition  https://hackage.haskell.org/package/composition-1.0.2 (DanBurton)
00:07:38 * hackagebot warp 3.1.4 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.4 (KazuYamamoto)
00:07:49 <mniip> wire diagrams are actually isomorphic to functions
00:07:54 <Cale> But you get the idea
00:08:04 <mniip> you just have to choose a certain thing to make hask a monoidal category over
00:08:06 <Cale> mniip: Are you referring to the proof machine site?
00:08:07 <bollu> Cale: yeah,  geddit :) it's neat
00:08:08 <lamefun> With eg. data ReadableFile = { read :: ... } and data ReadableWritableFile = { readableInterface :: ReadableFile }  won't I have to use read (readableInterface myCompositeFileRecord) all the time?
00:08:26 <mniip> Cale, graphical linalg
00:08:48 <jle`> bollu: for Ord a where you can enumerate all the values, you can turn any (a -> b) into a Map a b.  And for any Ord a you can turn a Map a b -> (a -> b), which is total if the Map has all possible a's
00:08:48 <Cale> lamefun: You can define composite functions
00:09:05 <jle`> so you don't really get too much from picking Map over (->), I think, except you restrict your input to be Ord
00:09:08 <Cale> also, your parens seem off
00:09:27 <bollu> jle`: I think I can see that construction - you go over every a (by using ord) and fill up the Map by calling b, right?
00:09:40 <bollu> by calling (a -> b)*
00:09:43 <Cale> er, no, sorry
00:09:45 <Cale> they're not
00:09:50 <jle`> you can't use Ord to enumerate it, you have to invent your own scheme if you know the type `a` you care about
00:10:04 <jle`> ironically you can't even do this with Enum/Bounded
00:10:07 <bollu> jle`: oh
00:10:16 <Cale> lamefun: But I mean, you can define a read' = read . readableInterface
00:10:19 <bollu> jle`: really? What's the problem with Enum/Bounded?
00:10:39 <jle`> if i had data States = A | B | C | D, then you can make sure your Map includes A, B, C, and D
00:10:51 <jle`> bollu: it's not in the laws that [minBound .. maxBound] is the entire universe
00:10:55 <jle`> and for many types, it's not
00:11:03 <bollu> jle`: oh
00:11:17 <Cale> lamefun: When I mentioned you might want to make classes for the operations, this is what I meant -- if you start bundling the operations into different record structures, you might want a class for how to extract them from the nested records.
00:11:22 <jle`> yeah, "Enum" doesn't really mean "Enumerable", i guess.  v.v
00:11:31 <jle`> unfortunate naming choice
00:11:39 <bollu> jle`: so, something called as, maybe, class Creatable a where create :: [a] ? 
00:11:48 <jle`> there's a typeclass somewhere, they call it Universe
00:11:48 <Cale> lamefun: Just so you always get to apply read to the structure you've got, and not have to remember the type-specific name
00:11:54 <lamefun> Cale, why not just use existential types then?
00:12:04 <Cale> lamefun: Existentials are completely different
00:12:17 <Cale> lamefun: and I don't even see how they apply to something like this really.
00:12:45 <jle`> bollu: but yes, that's the idea that a lot of people go down
00:13:34 <Cale> lamefun: Can you explain how you were planning to use existentials? I don't see how they avoid the problem at all.
00:13:35 <bollu> jle`: interesting. I should do the encoding once
00:13:37 <jle`> i think in most cases though using a plain ol' function is preferred, unless your keys/possible states are only a subset of the type, i guess
00:13:41 <bollu> is "do"" the right verb?
00:13:55 <jle`> write, maybe? heh, not sure
00:14:37 <jle`> :t (M.!)
00:14:38 <lambdabot> Ord k => M.Map k a -> k -> a
00:14:50 <jle`> oh, accidentally gave away one of the directions :|
00:15:25 <Cale> lamefun: But yeah, start with records, define type classes when the operations on those records end up having similar names and essentially identical function and you want to abstract over it.
00:15:53 <Cale> You can't really start with type classes without any types to make instances
00:16:15 <jle`> bollu: but yeah, if you look at https://en.wikipedia.org/wiki/Deterministic_finite_automaton#Formal_definition , you can see that the five things end up being represented nicely in haskell as types and functions
00:16:21 <jle`> our favorite things as haskellers, of course
00:17:04 <Cale> and while you could make existentials (perhaps which manipulate a handle of an unknown type) instead of record types, I don't really see the point of it, unless there are going to be multiple handles in one record.
00:17:43 <Cale> I'm off to sleep
00:17:46 <Cale> g'night!
00:17:51 <jle`> good night Cale 
00:20:25 <Cale> oh, and one more thing: try not to use names that are awkwardly long for things which you're going to use frequently -- especially if they are bound locally. Your memory for what they are will be good when they show up all the time.
00:21:35 <Cale> Also, if the binding site of a variable is within easy viewing distance of all its usage sites, you can usually get away with a short name.
00:22:22 <jle`> i have a source code formatter that goes through my code and renames all variables in proportion to the log of how many times they are used
00:22:41 <jle`> *to a length in proportion to
00:23:09 <lpaste> mniip pasted “wire diagrams” at http://lpaste.net/141927
00:23:11 <mniip> Cale, ^
00:23:33 <lamefun> Can't I just do something like: data SomeRWFile m = forall a. (ReadableFile m a, WritableFile m a) => SomeRWFile a ?
00:23:38 <mniip> oh hm, forgot something
00:31:16 <jle`> is there anything interesting about monoid theory?
00:31:24 <kristof> Hi, I'm having a little bit of trouble with Haskell mode.
00:31:28 <kristof> (In emacs)
00:31:30 <jle`> it seems like monoids seem to only be a useful or interesting concept when applied to computation
00:31:56 <bollu> jle`: nope, not as far as I know (too little structure to them)
00:32:28 <bollu> jle`: I actually know more monoids from haskell than from math (excluding every group is a monoid hurr durr)
00:32:34 * hackagebot uulib 0.9.21 - Haskell Utrecht Tools Library  https://hackage.haskell.org/package/uulib-0.9.21 (AtzeDijkstra)
00:32:40 <kristof> C-c C-t is returning "Cannot determine types" for pretty much everything.
00:33:16 <shachaf> Monoids are the easy version of categories.
00:33:47 <kristof> Oh, it seems emacs can't find ghc-mod, even though the binary is in my $PATH
00:34:11 <bollu> kristof: try and invoke emacs from the command line once?
00:34:31 <tdammers> I think the most useful property of monoids *is* how easy they are
00:34:54 <bollu> tdammers: but, but, my cool group theory theorems :)
00:35:05 <kristof> bollu: Still can't find it.
00:39:53 <kristof> (file-error "Setting current directory" "no such file or directory" "\"ghc-mod\" not found/")
00:41:05 <bollu> kristof: why are your slashes backward? are you on windows?
00:41:29 <liste> bollu it's escaping "
00:41:46 <bollu> ohh
00:41:50 <bollu> right. makes sense
00:42:49 <kristof> I'm not sure why it can't find it. M-! ghc-mod stuff works
00:43:27 <bollu> kristof: wild try - do you have Projectile or something? I've found that it messes with $PATH
00:43:39 <kristof> bollu: No, I don't even know what that is.
00:43:53 <bollu> kristof: ah, nvm them
00:44:19 <ReinH> Probably M-! uses $PATH and the other uses exec-path or something
00:46:01 <ttt_fff> in parsec, how do I say "in" followed by a non-letter, but do NOT consume the non-letter
00:46:08 <ttt_fff> i.e. it should fail on "index"
00:46:22 <ttt_fff> and on "in languages", it should consume "in", and leave " languges" on the input
00:46:28 <ttt_fff> but it should peek at the " " to make sure it's a non letter
00:47:30 <ttt_fff> ttt_fff: notFollowedBy
00:47:31 <frerich> ttt_fff: IIIRC lookAhead can be used for that.
00:47:36 <ttt_fff> ttt_fff: http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Combinator.html
00:47:52 <ttt_fff> frerich: I think http://hackage.haskell.org/package/parsec-3.1.9/docs/src/Text-Parsec-Combinator.html#notFollowedBy is closer
00:50:23 <ttt_fff> yeah, got notFollowedBy to work :-)
01:02:11 <tomus> after googling just a little bit about GUIs in haskell, there seems to be reports floating that a) it's hard b) it's imperative. this a tiny bit off putting. but how difficult is it really?
01:05:26 <frerich> tomus: My GUIs were always only web based actually. I.e. I have a Haskell program which serves fancy JavaScript magic via HTTP.
01:07:28 <tdammers> tomus: what I've gathered so far is, re b) some are imperative, some are declarative, and reactive is all the hype, particularly FRP; re a) it's not hard, except that installing the required libraries is all but straightforward
01:08:23 <tdammers> in general, I believe the GUI problem is unsolved for *any* programming language, but Haskell is having a particularly hard time because we insist on doing things right rather than take what we have and just roll with it
01:10:29 <tomus> heh, what I am trying to accomplish is a tiny application (just one window) and a bunc of images, buttons and actions. I wrote some backendy stuff in haskell already and then went for PyQT (python) to create the gui cuz it looked easy. I am already missing the haskell's type system though.
01:11:17 <jle`> how can I let GHC know that if I had KnownNat n, then I also have KnownNat (n * 2), KnownNat (n + 4), etc.?
01:11:28 <tomus> so the real que would be, is there a (hassle) free to make a simple gui in haskell? and what lib should I go for. I prefer documentation and examples over philosphy
01:11:34 <jle`> s/had/have the constraint
01:11:51 <liste> tomus what kind of gui? game/simulation? form?
01:11:56 <tomus> just a form
01:12:05 <tomus> form + images + buttons
01:12:10 <tomus> that's all
01:12:35 <jle`> tomus: is HTML5 an ok platform for you?
01:13:10 <tdammers> AFAIK, web interface is the safest way to go with this
01:13:21 <tomus> yes
01:13:23 <tdammers> there's threepenny-gui, for example
01:13:23 <tomus> it's fine
01:13:37 <tomus> ok, I ll chekc it out
01:13:57 <jle`> gloss is nice too, for non-html5
01:13:59 <tomus> but does that mean that most of my code will be in JS
01:14:10 <tomus> front end code
01:14:13 <liste> tomus no
01:14:52 <jle`> it will be haskell
01:16:50 <tomus> prelimenary looks at the code of examples looks nice
01:19:08 <athan> Does WriterT really have /that/ much space leak?
01:19:59 <jle`> from what i hear it's pretty much unusable for any serious application
01:20:25 <jle`> at least the one from transformers
01:20:36 <athan> jle`: that is unfortunate. Is it from right-appending?
01:20:40 <athan> ie - lazy?
01:21:46 <chattered> Are you specifically talking about WriterT []?
01:22:09 <tdammers> my guess would be that it depends on the instance, but I could be wrong
01:22:39 <tdammers> I think the core problem is that the accumulated "output" isn't evaluated until you leave the WriterT monad
01:22:46 <tdammers> i.e., outside of runWriter
01:25:10 <bollu> can I message nickserv from anywhere?
01:26:45 <jle`> if you can get internet access and your ISP doesn't block freenode
01:27:28 <bollu> yay, registered my nick 
01:27:29 <bollu> finally
01:28:03 <jle`> congrats!
01:28:07 <bollu> :)
01:28:08 <jle`> was just about to steal it from you too.  just in time.
01:28:25 <bollu> wonder how IRC works. should read sometime
01:29:46 <erikd> can anyone recommend a type level programming tutorial? i think i need type level lists of int and functions like sum on those type level lists.
01:30:51 <merijn> erikd: I don't think there's any real tutorials. You could try the Hasochism paper, but not sure how accessible that is
01:31:18 <erikd> merijn: ah yes, that may be a place to start.
01:32:36 * hackagebot bit-array 0.1.0.1 - A bit array (aka bitset, bitmap, bit vector) API for numeric types  https://hackage.haskell.org/package/bit-array-0.1.0.1 (NikitaVolkov)
01:32:58 <bollu> is there an IRC for assembly / mips programming?
01:33:02 <bollu> IRC channel*
01:33:33 <merijn> erikd: Although to be honest, there is not much to learn. Type families are basically just pure functions that are limited to inductive recursion
01:34:46 <cocreature> and prepend ' to stuff :)
01:34:59 <lamefun> How do I un-promote types?
01:35:17 <merijn> lamefun: With *a lot* of painful effort
01:35:35 <cocreature> isn't that what singletons are for?
01:35:52 <bollu> is there something called Functor f => Lowerable where lower :: f a -> a?
01:35:55 <merijn> Yes, but it's still painful
01:36:05 <merijn> :t extract
01:36:06 <lambdabot> Not in scope: ‘extract’
01:36:16 <cocreature> yeah, I just wanted to make sure my brain is not completely broken
01:36:21 <merijn> bollu: You're probably thinking of "extract :: Comonad w => w a -> a"?
01:36:35 <bollu> merijn: is that w (w a) -> w a?
01:36:38 <jophish_> http://hoogle.haskell.org/?hoogle=extract
01:36:40 <bollu> isn't that*
01:36:49 <merijn> bollu: "class Functor w => Comonad w where extract :: w a -> a; extend :: w a -> w (w a)"
01:36:55 <bollu> oh
01:36:57 <bollu> interesting
01:37:00 <merijn> bollu: No, "w (w a) -> w a" is join from Monad
01:37:09 <bollu> ah, right
01:37:26 <bollu> (>>=) = join . fmap is still crazy >_>
01:37:55 <jle`> it would be crazier if it were true
01:37:57 <jle`> hehe
01:38:04 <bollu> fmap . join? :)
01:38:13 <bollu> :t fmap . join
01:38:14 <lambdabot> Functor f => (a -> a -> b) -> f a -> f b
01:38:27 <jle`> :t 
01:38:29 <lambdabot> <no location info>: not an expression: ‘’
01:38:31 <bollu> :t join . fmap
01:38:32 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a1)
01:38:32 <lambdabot>     Expected type: (a1 -> a) -> f a1 -> f a1 -> a
01:38:32 <lambdabot>       Actual type: (a1 -> a) -> f a1 -> f a
01:38:38 <bollu> wait, what am I missing?
01:38:39 <bollu> >_<
01:38:51 <jle`> :t \x f -> join (fmap f x)
01:38:52 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
01:39:41 <lamefun> Eg. I have data K = ...; data V (n :: K); fn :: forall n. V n -> ... -- now how do I get normal value of K from type n?
01:39:53 <cocreature> bollu: the problem is that you need to pass both arguments to fmap first
01:39:59 <merijn> lamefun: singletons + pain
01:40:06 <bollu> cocreature: ah, thanks. That would have taken me five more minutes to see :)
01:40:55 <cocreature> :t ((.) . (.)) join fmap
01:40:57 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
01:41:00 <cocreature> but please don't use that
01:41:32 <cocreature> also I got it wrong …
01:41:49 <cocreature> :t ((.) . (.)) join (flip fmap)
01:41:50 <lambdabot> Monad m => m a1 -> (a1 -> m a) -> m a
01:46:01 <Fuuzetsu> @pl foo x f = join (fmap f x)
01:46:01 <lambdabot> foo = (join .) . flip fmap
01:46:19 <lamefun> Uhm...
01:46:26 <lamefun> So far Haskell feels really poorly made...
01:46:38 <tdammers> lamefun: how so?
01:46:54 <lamefun> I mean.
01:47:32 <lamefun> It's disappointment after a disappointment.
01:47:45 <tdammers> what did you expect?
01:48:16 <merijn> "I want to use features that are state of the art in modern research languages and haskell doesn't even implement them, what a let down!"
01:50:25 <jophish_> wait, isn't this just a job for singletons?
01:51:16 <srhb> jophish_: That was already pointed out. :)
01:54:59 <jophish_> oh, yes. of course :)
01:58:39 <tomus> hm, so threepenny creates dom elements and binds them to events underneath?
01:59:02 <tomus> so all my haskell gui code is converted into JS?
02:01:48 <liste> tomus no, the code is run in a local "server" program which the UI connects to
02:01:59 <liste> https://github.com/HeinrichApfelmus/threepenny-gui#technical-overview
02:02:19 <jle`> lamefun: promoted types aren't even a part of Haskell :P
02:02:47 <jle`> that's like saying that an airplane is poorly made because it doesn't have a good elevator
02:03:17 <tomus> liste: but the browser ought to evaluate document.createElement somewhere somehow for my button to appear
02:04:16 <liste> tomus threepenny handles the "client" side
02:04:56 <liste> it has the necessary javascript
02:06:20 <tomus> my browser just refreshes onClick
02:06:23 <tomus> ?
02:06:32 <tomus> ok, got it
02:07:29 <tomus> so technically it doesn't have to use JS at all
02:11:59 <lamefun> jle`, they aren't?
02:12:37 <jle`> no
02:12:53 <jle`> they're highly experimental non-haskell extensions of GHC
02:13:11 <lamefun> and Template Haskell?
02:13:16 <jle`> ghc likes to add things that aren't a part of haskell, for some reason
02:13:44 <jle`> same
02:14:08 <tsahyt> That aren't a part of Haskell *yet*
02:14:19 <lamefun> FlexibleContexts?
02:14:45 <jle`> if it's an extension, it's by definition not a part of haskell :P
02:14:51 <tsahyt> of course there are also extensions that turn out to be unfit to go into the standard
02:15:08 <ChristianS> jle`: not part of standard haskell, you mean
02:15:23 <tsahyt> I really think of it as GHC Haskell, which is like a dialect
02:15:30 <tsahyt> And also a testbed for the next standard
02:15:46 <jle`> ChristianS: "Haskell", as defined by the authoratative text on what haskell is
02:16:19 <ChristianS> jle`: i'd call that "haskell 2010"
02:16:49 <ChristianS> tsahyt: extensions aren't really ghc-specific, some of them are implemented by other compilers too
02:17:05 <ChristianS> (not that other compilers matter in practice, but hey)
02:18:18 <jle`> you're welcome to define haskell as whatever you want...words are meaningless, after all. but there is an accepted language standard that gives its own definition
02:19:47 <frerich> Argh, now I have 'words don't come easy to me' in my mind.
02:21:26 <tsahyt> Are any of the other compilers actually used?
02:21:45 <merijn> tsahyt: There's 3ish compilers in actual use, I'm aware of
02:22:07 <merijn> GHC, UHC, and Mu (but that's proprietary and internal to Standard Chartered only)
02:24:03 <bitonic> is there a package with binary instances for the types in `transformers`?  e.g. `Sum` and `Product`
02:29:34 <tsahyt> So UHC has a JVM backend and a JS backend. Might be worth looking into it.
02:34:58 <hc> hi
02:35:10 <hc> a google search for haskell soap shows few results...
02:35:25 <hc> is writing a soap server in haskell a bad idea atm, unless you develop your own soap library?
02:35:50 <liste> I don't see why it would be a bad idea
02:35:56 <cocreature> does any of them actually respect the haskell standard? mu is strict afaik, ghc has amp & ftp
02:36:25 <quicksilver> hc: https://hackage.haskell.org/package/soap
02:36:33 <quicksilver> hc: is relatively recently updated
02:36:40 <quicksilver> but I have no idea how well it works
02:36:47 <liste> that's client tools though :(
02:36:56 <hc> quicksilver: looks like that's only for writing soap clients though
02:37:12 <liste> can't find any soap server libraries :<
02:37:29 <quicksilver> ah, sorry
02:37:40 <quicksilver> well the hard work of SOAP is independent of client/server
02:37:48 <quicksilver> so if you're prepared to get your hands dirty and dive in
02:37:52 <quicksilver> I expect most of the pieces are there
02:38:26 <quicksilver> but clearly that's more work than other ecosystems with a 'press this button and generate a SOAP server' facility :)
02:38:38 <hc> fair enough
02:38:47 <hc> :-)
02:40:00 <hc> oh dear, I don't feel up to implementing WS-Security though ;-) https://en.wikipedia.org/wiki/WS-Security
02:40:02 <jaconwil> is there a type safe alternative of printf? I just spent 10 minutes hunting down all the printfs because some data type changed from String to Int, and I don't want to go through that again
02:40:06 <hc> signatures inside an XML document
02:40:13 <cocreature> @hackage formatting
02:40:13 <lambdabot> http://hackage.haskell.org/package/formatting
02:40:16 <cocreature> ^ jaconwil
02:40:17 <liste> cocreature++
02:40:24 <liste> awesome package
02:41:54 <tsahyt> Is there a package that implements the type-safe printf from the Fun with type functions paper?
02:43:16 <merijn> cocreature: Oh, nice...that doesn't even need TH, why didn't I think of that approach?
02:43:58 <cocreature> merijn: the good thing is that enough smart people use haskell so that you don't need to come up with clever approaches yourself :)
02:44:03 <bernalex> edwardk: ... wat? @yr backwards tweet
02:46:23 <jaconwil> cocreature thanks
02:47:13 <cocreature> bernalex: neat stuff :)
02:47:45 <tdammers> do people even write SOAP servers anymore these days?
02:48:14 <tdammers> I mean, outside of big-corp/gov't stuck-in-early-2000s-methodology deep-in-the-Java-trenches situations?
02:48:43 <jaconwil> just found this too, but I don't know what "more typesafe" means. http://hackage.haskell.org/package/safe-printf
02:50:05 <jaconwil> wasn't there a template haskell version of printf too? I can't seem to find it
02:50:28 <merijn> jaconwil: Probably, but imo that first library looks nice
02:50:28 <jaconwil> that parses format string at compile type and then reports type mismatch, if any
02:50:59 <cocreature> jaconwil: safe-printf seems to be template haskell
02:51:44 <cocreature> hm no maybe not, I think the quasi quoter is only for convenience
02:54:26 <quicksilver> tdammers: I write SOAP servers to provide mocks (for testing) of real SOAP servers I have to connect to :)
02:54:57 <bernalex> tdammers: academia stuck-in-early-2000s-methodology deep-in-the-Java-trenches situations.
02:55:58 <tdammers> quicksilver: aren't there shitty tools for that? idk, I believe there's this java things, whatchamacallit...
02:56:13 <tdammers> bernalex: academia uses SOAP? oh god
02:56:23 <bernalex> tdammers: and tomcat.
02:56:33 <bollu> bernalex: what's wrong with tomcat?
02:56:50 <bollu> bernalex: I mean, it's no great solution. But.
02:57:06 <quicksilver> tdammers: there are tools, certainly.
02:57:28 <quicksilver> tdammers: SOAP is still the default server protocol for many .NET places
02:57:37 <tdammers> right, .NET
02:57:42 <bernalex> bollu: the last time I had to use tomcat it was for a *game*. as you might imagine, it was not optimal.
02:57:58 <quicksilver> most newer places are using most lightweight, JSON based APIs
02:58:01 <quicksilver> but it's not all good news
02:58:11 <quicksilver> there is no schema definition, no machine-readable API def
02:58:18 <quicksilver> (in many cases)
02:58:22 <quicksilver> which is a step back as well as forwar
02:58:23 <quicksilver> d
03:00:12 <frerich> So it's like Riverdance!
03:07:40 * hackagebot distributed-process-tests 0.4.3.1 - Tests and test support tools for distributed-process.  https://hackage.haskell.org/package/distributed-process-tests-0.4.3.1 (AlexanderVershilov)
03:15:41 <pavonia> When installing a library via runhaskell Setup.hs, is there a way to set the default --prefix path to use?
03:16:59 <nobos> Hi there, I have a beginner question: is it possible to get rid of the "maybeErr" helper in a coincise way? http://pastie.org/10449866
03:18:09 <nobos> I tried all kinds of things like "maybe (throwE err404) (return . liftIO . findProject tId)"
03:18:33 <nobos> but I'm probably having problems with the liftIO thingy
03:18:38 <pavonia> maybeErr x = liftIO x >>= maybe throwErr return
03:18:40 <pavonia> I think
03:18:46 <jophish_> nobos: you might like this: http://hoogle.haskell.org/?hoogle=maybeToEither
03:20:00 <jophish_> wowza, that's part of a huge library
03:20:16 <bollu> jophish_: I think Tekmo has a package for Maybe <—> Either. I'm fond of "shush"
03:21:14 <jophish_> nobos: as a matter of style, maybeErr doesn't seem to be specific to `projectServer` so might be better being a top level function instead of in a where clause
03:21:15 <nobos> is it possible using standard haskell constructs?
03:21:59 <jophish_> nobos: what's non-standard in maybeErr?
03:21:59 <nobos> ok, ty
03:24:26 <nobos> jopish_: no idea, as I'm a beginner I was just wondering if you guys would do anything different here, using constructs like return . liftIO etc
03:25:09 <nobos> f.e. it feels dirty the liftIO is inside
03:25:15 <nobos> shouldn't IO be outside?
03:25:51 <nobos> jopish_: like this: maybeErr ::  (MonadIO m) => a -> Maybe b -> ExceptT a m b
03:27:18 <pavonia> runhaskell chooses a default path for --prefix that isn't my GHC installation directory, so I'm wondering where it's getting that from
03:28:21 <pavonia> For runhaskell Setup.hs configure, that is
03:28:36 <jophish_> nobos: your intuition is right, there's no need to have IO in there
03:29:15 <jophish_> This might be something to get inspiration from https://hackage.haskell.org/package/MissingH-1.3.0.1/docs/src/Data-Either-Utils.html#maybeToEither
03:29:36 <nobos> jophish_: I tried this f.e. maybe (throwE err404) . return . liftIO . findProject tId
03:30:40 <nullx002> hi..
03:30:51 <nullx002> why ghci outputs [0O00000000..0O00002222] in decimal and not in octat
03:31:02 <pavonia> nobos: liftIO should already bring you to the right monad, so you probably don't need the return
03:31:24 <jophish_> and you'll want to fmap (maybe (throwE err404)) in there instead of composing
03:32:05 <tulcod> nullx002: because internally, the lists that you construct are the same
03:32:19 <nullx002> what if i want output list in octat?
03:32:21 <tulcod> nullx002: if you want to print octal numbers, you have to do so explicitly
03:32:41 * hackagebot distributed-process 0.5.5.1 - Cloud Haskell: Erlang-style concurrency in Haskell  https://hackage.haskell.org/package/distributed-process-0.5.5.1 (AlexanderVershilov)
03:33:05 <tulcod> nullx002: see the Numeric lib in the base package
03:33:11 <tulcod> nullx002: https://hackage.haskell.org/package/base-4.7.0.2/docs/Numeric.html
03:33:15 <nullx002> yes... i had a look at that
03:37:42 * hackagebot distributed-process-extras 0.2.1.1 - Cloud Haskell Extras  https://hackage.haskell.org/package/distributed-process-extras-0.2.1.1 (AlexanderVershilov)
03:37:44 * hackagebot sdl2-ttf 0.2.2 - Binding to libSDL2-ttf  https://hackage.haskell.org/package/sdl2-ttf-0.2.2 (schalmers)
03:40:28 <nullx002> putStrLn $ showOct 12 ""
03:40:34 <nullx002> it works well on single octat
03:40:38 <nullx002> how to print a list using that
03:40:51 <nullx002> showOct, will it work on lists?
03:40:59 <liste> nullx002 you need to map it
03:41:04 <nullx002> yes i tried
03:41:33 <nullx002> but throws decimal instead of octat as output
03:42:06 <pavonia> Show us the code
03:42:42 * hackagebot distributed-process-execution 0.1.2.1 - Execution Framework for The Cloud Haskell Application Platform  https://hackage.haskell.org/package/distributed-process-execution-0.1.2.1 (AlexanderVershilov)
03:42:44 * hackagebot distributed-process-client-server 0.1.3.1 - The Cloud Haskell Application Platform  https://hackage.haskell.org/package/distributed-process-client-server-0.1.3.1 (AlexanderVershilov)
03:42:50 <tsahyt> > map (flip showOct "") [8,9,10]
03:42:52 <lambdabot>  ["10","11","12"]
03:43:14 <nullx002> on infinite list?
03:43:20 <tsahyt> > map (flip showOct "") [8..]
03:43:22 <lambdabot>  ["10","11","12","13","14","15","16","17","20","21","22","23","24","25","26",...
03:43:49 <tsahyt> Note that the literals in the list are written in decimal though
03:45:06 <nullx002> yes
03:45:15 <nullx002> anyway to get octat input and octat output
03:45:18 <nullx002> using mapping
03:45:57 <tsahyt> You can roll that with readOct and showOct. You could also wrap it up in a type implementing Num, so you can use octal literals
03:46:27 <tsahyt> I don't know if something like this already exists, but it should be straight forward to write
03:47:23 <pavonia> nullx002: What do you mean by octat ouput if not the list tsahyt showed?
03:47:42 * hackagebot distributed-process-registry 0.1.0.1 - Cloud Haskell Extended Process Registry  https://hackage.haskell.org/package/distributed-process-registry-0.1.0.1 (AlexanderVershilov)
03:50:06 <nobos> jophish_: Figured something out: http://pastie.org/10449924
03:51:36 <jophish_> nobos: what's the type of insertProject?
03:52:00 <aweinstock> > (foldr (.) id $ map showOct [0..]) ""
03:52:02 <lambdabot>  "012345671011121314151617202122232425262730313233343536374041424344454647505...
03:52:21 <aweinstock> > (foldr (.) id . intersperse (' ':) $ map showOct [0..]) ""
03:52:23 <lambdabot>  "0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27 30 31 32 33...
03:52:42 * hackagebot distributed-process-task 0.1.2.1 - Task Framework for The Cloud Haskell Application Platform  https://hackage.haskell.org/package/distributed-process-task-0.1.2.1 (AlexanderVershilov)
03:53:02 <aweinstock> :t [foldr (.) id, getEndo . mconcat . map Endo]
03:53:04 <lambdabot> Not in scope: ‘getEndo’
03:53:08 <nobos> jophish_: Domain.Models.Project -> IO (Maybe Domain.Models.Project)
03:54:34 <jophish_> nobos: I don't think that your solution will work, maybeToExceptT err404 expects the next argument to be of type Maybe t, so the return before it will just wrap up the IO (Maybe Domain.Models.Project) in another maybe
03:55:18 <aweinstock> :t [foldr (.) id, (\(Endo f) -> f) . mconcat . map Endo]
03:55:18 <jophish_> so as you have it, the call to maybeToExceptT has type: e -> Maybe (IO (Maybe Domain.Models.Project)) -> Except e m a
03:55:19 <lambdabot> [[b -> b] -> b -> b]
03:55:34 <aweinstock> ^ The above have the same type, do they do the same thing?
03:55:41 <nobos> can I somehow lift the maybeToExceptT ?
03:55:53 <nobos> jophish_:  can I somehow lift the maybeToExceptT ?
03:55:54 <jophish_> I think that maybeToExceptT should also have the type signature :: Monad m => e -> Maybe t -> ExceptT e m t
03:57:08 <nobos> jophish_: good catch!
03:58:34 <Gurkenglas> :t ala Endo foldMap -- aweinstock
03:58:35 <lambdabot> Foldable t => t (a -> a) -> a -> a
03:59:01 <jophish_> nobos: how does this work: fmap (maybeToErrorT err404) . insertProject
03:59:20 <nobos> jophish_: I have example code without the IO monad input here: http://pastie.org/10449945
03:59:23 <Fuuzetsu> :t Just (_ :: ())
03:59:24 <lambdabot>     Found hole ‘_’ with type: ()
03:59:25 <lambdabot>     In the first argument of ‘Just’, namely ‘(_ :: ())’
03:59:25 <lambdabot>     In the expression: Just (_ :: ())
03:59:41 <Fuuzetsu> :t let f (Just (_ :: ())) = () in f
03:59:44 <lambdabot> Maybe () -> ()
03:59:46 <jophish_> fmap (maybeToErrorT err404) has type: Functor f => f (Maybe t) -> f (ErrorT e m y)
04:01:05 <nobos> jophish_: I get a "could not deduce Maybe  arising from use of liftIO
04:01:31 <jophish_> fmap (foo) (someInputInsideAFunctor) will apply the function foo to the value which is wrapped in the functor. In your case, you want to change the Maybe value in the Functor into an Except value
04:01:53 <nobos> jophish_: one sec, might be an error from my part
04:02:06 <nobos> jophish_: I'll try again
04:02:21 <jophish_> what's the type of (:<|>)
04:02:43 * hackagebot distributed-process-supervisor 0.1.3.1 - Supervisors for The Cloud Haskell Application Platform  https://hackage.haskell.org/package/distributed-process-supervisor-0.1.3.1 (AlexanderVershilov)
04:03:01 <nobos> jophish_: it's a servant project
04:03:15 <nobos> jophish_: https://github.com/haskell-servant/servant
04:04:44 <aweinstock> :t ala
04:04:45 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
04:05:06 <jophish_> (:<|>) :: a -> b -> (:<|>) a b
04:05:08 <jophish_> very useful
04:05:21 <liste> jophish_ it's a constructor
04:05:28 <nobos> jophish_: it's a type to compose routes
04:05:49 <nobos> jophish_: for a webserver
04:06:02 <alpounet> data a :<|> b = a :<|> b, this is isomorphic to a pair, but that you can chain nicely
04:06:02 <nobos> jophish_: so first you compose the routes
04:06:15 <alpounet> (when you want to stick more than 2 things together
04:06:16 <nobos> jophish_: and than you implement the route handlers
04:06:18 <alpounet> )
04:06:23 <jophish_> ok, I see
04:06:43 <alpounet> we use it in servant to stick endpoint descriptions and request handler implementations together
04:06:59 <jophish_> nobos: how did fmapping maybeToErrorT work?
04:07:02 <nobos> jophish_: ^^ what alpounet said
04:07:24 <sunnymilk> you can chain pairs nicely
04:07:32 <sunnymilk> (a, (b, (c, ()))
04:07:43 * hackagebot monad-logger 0.3.14 - A class of monads which can log messages.  https://hackage.haskell.org/package/monad-logger-0.3.14 (MichaelSnoyman)
04:08:04 <jaconwil> given Day 2015-1-1 how do I get 2014-12-1? year and month are arbitrary, day is always 1
04:08:36 <nobos> jophish_: I get a "couldn't match 'ExceptT ServantErr IO Project' with 'ExceptT ServantErr m1 Project'"
04:09:06 <liste> jaconwil addGregorianMonthsClip?
04:09:30 <nobos> jophish_: so I should probably name my monad in my maybeToExceptT
04:09:34 <nobos> jophish_: ?
04:10:14 <nobos> jophish_: tried it, didn't work: maybeToExceptT :: MonadIO m => e -> Maybe t -> ExceptT e m t
04:10:24 <jaconwil> liste thanks! 
04:10:32 <jophish_> nobos: there's nothing in maybeToErrorT which depends on IO, so putting MonadIO shouldn't be necessary
04:10:39 <jophish_> What's the code
04:10:46 <jophish_> sorry to get you to keep pasting it
04:12:01 <nobos> jophish_: http://pastie.org/10449979
04:12:43 * hackagebot aeson-extra 0.1.0.0 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.1.0.0 (phadej)
04:13:21 <sopvop> So, #haskell. I have a datatype for accumulating Haxl requests, it is 15 field record currently. I'm thinking about switching to a record of STRefs as an optimization, so it does not update whole record while folding over request list.
04:13:59 <sopvop> But I'll need to read these STRefs later, outside of gathering ST monad. How expensive is runST (readSTRef) ?
04:13:59 <alpounet> nobos: what if you force m to be IO in maybeToExceptT's type?
04:15:35 <nshepperd> sopvop: you can't return a STRef out of the original runST call
04:15:41 <sopvop> oh
04:15:42 <sopvop> :(
04:16:08 <nshepperd> sopvop: if you want to use ST while folding, just return a normal pure record at the end of the fold
04:16:54 <jophish_> nobos: ah, you might need a call to liftIO before fmap
04:16:56 <nobos> alpounet: I'll try
04:17:18 <nshepperd> sopvop: ie. don't change your datatype, just have a set of "temporary" STRefs during the fold
04:17:29 <sopvop> Hm, I can do like  data MyRecord f = MyRecord { foo :: f Something }, and type FoldingRecord s = MyRecord (STRef s) 
04:17:51 <sopvop> then switch to Identity...
04:18:16 <sopvop> Yeah, your idea is better.
04:18:18 <nobos> jophish_: could you post an example?
04:18:18 <nshepperd> sure
04:18:40 <jophish_> nobos: http://pastie.org/10449992
04:23:07 <lpaste> merijn pasted “variations” at http://lpaste.net/141931
04:23:15 <merijn> nobos: Or one of those variations
04:23:24 <nobos> alpounet: the idea was to get IO out of there
04:24:17 <nobos> merijn: taking a look
04:26:23 <nobos> merijn: the second variation is the one I'd love to use, as it factors out IO of the function
04:27:22 <nobos> merijn: however, I get "couln't match type 'IO Project' with 'Maybe t' "
04:27:56 <Gurkenglas> For each of those, I would replace "act = lift act >>=" with "= lift >=>"
04:28:08 <merijn> Gurkenglas: Sure
04:28:13 <merijn> Gurkenglas: But I wanted to keep it simple
04:31:23 <Gurkenglas> (Also the whole case match with "maybe (throwE errorval) return", of course, and that might have an alias somewhere
04:31:27 <Gurkenglas> *)
04:33:06 <dave34> is it ok to create an empty typeclass just so I can pass different types to a function?
04:33:32 <Gurkenglas> dave34, why not make the function completely polymorphic so you can pass anything to it?
04:34:17 <dave34> can I do that? if I try it gives me right type variable error
04:34:33 <Gurkenglas> Paste it/your code on lpaste?
04:34:48 <dave34> *rigid
04:35:38 <merijn> What datatype do I want for compact (i.e. low memory) representation of sequences with fast indexing?
04:35:49 <merijn> Seq?
04:36:04 <arkeet> arrays?
04:36:28 <merijn> Oh, I guess I should've said that I expect to append a lot, too :p
04:36:39 <arkeet> I dunno.
04:37:16 <chpatrick> merijn: do they need to be persistent?
04:37:19 <merijn> Arrays might be possible, since they probably will only be several 100 elements each, but I'm worried about the cost of copying for appending
04:37:25 <merijn> chpatrick: You mean immutable?
04:37:35 <chpatrick> if you like
04:37:38 <merijn> chpatrick: I plan to keep old copies, so mutating I'd still have to copy
04:37:45 <chpatrick> hmm
04:38:01 <chpatrick> I mean the ideal structure is an exponentially growing MVector
04:38:07 <chpatrick> if you can mutate
04:38:32 <dave34> Gurkenglas: tried to make minimal expel http://lpaste.net/141932
04:38:39 <dave34> *example
04:38:52 <chpatrick> I wouldn't worry too much about copying if it's only a 100 elements
04:38:55 <chpatrick> computers are fast
04:39:16 <merijn> chpatrick: Yeah, but I also plan to generate several million of them :)
04:39:20 <tdammers> aight
04:39:28 <chpatrick> ok, so how about MVector and copy when you want to keep it for later?
04:39:37 <chpatrick> or just freeze really
04:39:56 <merijn> I'll have a look at vector
04:41:14 <Gurkenglas> dave, define two separate functions. (An empty typeclass wouldn't even allow you to do that.) If you mean to generate strings that could be used as Haskell code (not prettyprinting!), consider defining Show instances. (Or just put deriving Show after the definitions to have it done for you)
04:41:55 <Gurkenglas> *after the data definitions
04:42:44 <dave34> I'm trying to get the same value out of different types, do I need a different function for each type?
04:43:20 <chpatrick> dave34: if the functions have the same shape you could consider making a typeclass
04:43:33 <chpatrick> class HasFoo a where getFoo :: a -> Foo
04:44:40 <dave34> chpatrick, thanks I think I'll do that.
04:45:28 <chpatrick> :t cont $ \cc -> cc $ Right (cc . Left)
04:45:30 <lambdabot> Cont c (Either a (a -> c))
04:45:35 <chpatrick> I love this
05:00:58 <mniip> Cale, so I found 3 operations that hask is a bimonoidal category over
05:01:37 <mniip> (,) Either and These
05:01:43 <mniip> I don't think any other exists
05:02:58 <quicksilver> mniip: what is 'These' ?
05:03:17 <mniip> @hackage these
05:03:17 <lambdabot> http://hackage.haskell.org/package/these
05:04:08 <bollu> mniip: ELI(undestand algebraic structures - what's a bimonoidal category?
05:04:15 <bollu> )
05:04:30 <quicksilver> cute data type. Thanks mniip 
05:05:06 <mniip> oops
05:05:11 <mniip> commutative bimonoidal category
05:05:49 <quicksilver> dont you need 2 operations to make a bimonoidal structure mniip?
05:06:03 <mniip> bollu, when you have an operation, and a cooperation, and laws of commutativity, cocommutativity, associativity and coassicitativity, a unit and a counit that are identity of the operation and coidentity of the cooperation
05:06:27 <printline> how can I set a variable in a do block using case? case readMaybe line of Just x -> foo <- x doesn't work
05:06:45 <mniip> operation and cooperation are distributive in some weird law, unit distributes over cooperation, and counit codistributes over operation
05:06:46 <mniip> and unit and counit annihilate
05:06:51 <bollu> mniip: what makes a "co operation" differnt form an operation
05:06:51 <bollu> oh
05:07:04 <mniip> bollu, it's prefectly symmetric
05:07:05 <quicksilver> printline: x <- case readMaybe line of Just x -> foo
05:07:10 <bollu> mniip: anhillate to give you .. ?
05:07:10 <quicksilver> printline: probably?
05:07:14 <mniip> nothing
05:07:19 <quicksilver> printline: not entirely sure what you were saying :)
05:07:50 <bollu> mniip: no, you're in an algebraic structure, there can't be "nothing", right? (closure). is "nothing" some anhilation identity or some such?
05:08:46 <mniip> bollu, consider the category of matrices, where 2 multipliable matrices are connected with a morphism
05:08:52 <printline> quicksilver: it should unwrap the Maybe if the parsing was sucessfull, actually more like case readMaybe line :: Maybe Float of ...
05:09:29 <mniip> oh and you have a total sum defined too
05:09:49 <printline> quicksilver: there is a second case in which Nothing is matched, in which an error message should appear
05:09:56 <srhb> printline: do { x <- readMaybe line; let unwrapped = case x of ...
05:10:03 <srhb> printline: Is that what you want?
05:10:05 <quicksilver> printline: can you paste some code?
05:10:17 <quicksilver> srhb: I don't think printline is working in the Maybe monad
05:10:19 <quicksilver> although Im' not sure
05:10:21 <bollu> mniip: what… kind of a morphism?
05:10:25 <srhb> Oh, is that what we're doing.
05:10:32 <srhb> No, then a transformer would be necessary.
05:10:55 <srhb> And some liftIO. :)
05:10:59 <printline> quicksilver: it's IO, or Control, not sure
05:11:41 <printline> (the example didn't have a type def. for main, but it imported Control.Monad)
05:12:05 <srhb> printline: main is IO a -- usually IO ()
05:12:15 <printline> srhb: ok
05:12:39 <bollu> srhb: why wasn't main thought to be IO Int?
05:12:40 <printline> unless is perhaps from Control.Monad?
05:12:50 <printline> `unless`
05:13:10 <srhb> bollu: Because emitting an exit value is an action itself?
05:13:17 <bollu> srhb: ah
05:13:31 <bollu> srhb: hm, but, like, isn't that the "last action" you can ever do?
05:13:40 <srhb> bollu: main can recurse over itself.
05:13:50 <srhb> bollu: Reusing whatever value it "produces"
05:13:52 <bollu> srhb: oh, right. Hadn't considered that
05:14:23 <srhb> Arguably it would be a bit clearer if main was always IO (), but meh. Such a minor thing. :)
05:14:54 <srhb> printline: The fact that it's from Control.Monad has nothing to do with the monad you're in. It's polymorphic over m:
05:14:57 <srhb> :t unless
05:14:58 <lambdabot> Applicative f => Bool -> f () -> f ()
05:15:02 <srhb> ... f, then :P
05:15:20 <printline> srhb: ah ok
05:16:29 <pavonia> What is "runhaskell Setup.lhs confiugre" trying to tell me by "Setup.lhs: does not exist" if I add --ld-options=-lmysqlclient to the configure options? It works fine if I leave out this option
05:18:14 <bernalex> how did you use infix stuff qualified again?
05:18:35 <opqdonut> > 1 Prelude.+ 2
05:18:37 <lambdabot>  3
05:18:58 <bernalex> opqdonut: should have been more clear: I want to *use it* prefix
05:19:03 <bernalex> > Prelude.(+) 1 2
05:19:05 <lambdabot>  Not in scope: data constructor ‘Prelude’
05:19:14 <opqdonut> > (Prelude.+) 1 2
05:19:15 <bernalex> that's the error I got, yeah. so not like that. :]
05:19:16 <lambdabot>  3
05:19:20 <bernalex> oh. derp. thanks.
05:19:25 <opqdonut> it's not pretty
05:19:48 <phadej> it's even more confusing when your operators starts with dot
05:19:59 <opqdonut> > (Prelude..) (+1) (+2) 0 -- my favourite
05:20:00 <lambdabot>  3
05:20:06 <phadej> ^ that
05:21:03 <bernalex> beautiful...
05:21:37 <bernalex> do someone more clever than me know how to write short property tests for peano numbers stuff?
05:21:46 <bernalex> like a property test for
05:21:48 <bernalex> Zero + b     = b
05:21:50 <bernalex> (Succ a) + b = Succ (a + b)
05:22:36 <opqdonut> bernalex: those are the properties already
05:22:40 <opqdonut> just use == instead of = :)
05:22:52 <frerich_> opqdonut: That's nice. It reminds me of a nice quirk in the Haskell syntax: given 'data Color = Red | Green | Blue deriving (,Enum)', the expression [Red..Blue] yields a syntax error :-}
05:23:01 <bernalex> opqdonut: oh. hm. true!
05:23:16 <opqdonut> @scheck \b -> 0 + b == b
05:23:18 <lambdabot>  +++ OK, passed 100 tests.
05:23:28 <mniip> bollu, basically, http://graphicallinearalgebra.net
05:23:31 <opqdonut> @scheck \a b -> (succ a) + b == succ (a + b)
05:23:32 <frerich> opqdonut: [Red ..Blue] however works :-) 
05:23:33 <lambdabot>  +++ OK, passed 100 tests.
05:23:38 <opqdonut> frerich: cool
05:24:16 <bollu> mniip: oh, that is interesting
05:26:41 <bernalex> opqdonut: need instances for Arbitrary though
05:27:07 <opqdonut> bernalex: sure
05:27:19 <opqdonut> bernalex: those are easy if you have a fromIntegral though :)
05:28:21 <bernalex> they are?
05:29:05 <opqdonut> bernalex: generate an arbitrary positive integer, transform it to Peano
05:30:55 <fractalsea> Is there a way I can choose where GHC writes the myprogram.prof file when profiling? I’m running it through upstart on our staging cluster, and I don’t think it is getting written anywhere…
05:31:39 <beaky> hello
05:31:44 <beaky> how do i refactor this haskell clone dates@[orig, new] = rsql $ rawExecute "insert into log select null as id, ? as date, exercise, sets, reps, duration, weight, current_timestamp as tt from log where date = ?" $ toPersistValue . (read :: String -> Day) <$> reverse dates
05:31:44 <bernalex> opqdonut: I don't remember the arbitrary stuff very well
05:31:50 <bernalex> but
05:31:52 <bernalex>     where toNat 0 = B.Zero
05:31:54 <bernalex>           toNat n = B.Succ (B.Succ (n - 1))
05:32:12 <bernalex> and then something with arbitrary :: Int and toNat in the instance Arbitrary B.nat where arbitrary = ...
05:32:17 <nullx002> opq
05:32:42 <bollu> mniip: the diagrams are encoding math; I'd much rather see the math :)
05:33:16 <opqdonut> bernalex: "arbitrary = fmap (toNat.abs) arbitrary" is one solution
05:33:59 <ocramz> hi all
05:34:05 <bollu> hey
05:34:07 <ocramz> any FFI experts in the house?
05:34:07 <bernalex> opqdonut: I have just about that, but type errors aplenty
05:34:08 <opqdonut> bernalex: or perhaps "arbitrary = fmap toNat arbitrarySizedNatural" is clearest
05:34:12 <bernalex> instance Arbitrary B.Nat where
05:34:14 <bernalex>   arbitrary = toNat . abs <$> arbitrary
05:34:16 <bernalex> toNat :: Integral a => a -> B.Nat
05:34:18 <bernalex> toNat 0 = B.Zero
05:34:20 <bernalex> toNat n = B.Succ (B.Succ (n - 1))
05:34:34 <opqdonut> bernalex: I didn't test any of this so yeah there might be some type errors :P
05:35:53 <bernalex> oh btw toNat should have 
05:35:56 <bernalex> toNat n = B.Succ (B.Succ (toNat (n - 1)))
05:36:11 <opqdonut> doesn't that double the nat?
05:36:30 <opqdonut> should be Succ (toNat (n-1))
05:36:48 <bernalex> erm derp yes
05:37:00 <bernalex> what's the actual property now then?
05:37:18 <bernalex>       property $ (B.+) == natAdd
05:37:20 <bernalex> ?
05:37:33 <bernalex> where natAdd
05:37:35 <bernalex> natAdd B.Zero b     = b
05:37:37 <bernalex> natAdd (B.Succ a) b = B.Succ (natAdd a b)
05:38:14 <opqdonut> bernalex: I was thinking of just "\a b -> natAdd (Succ a) b == Succ (natAdd a b)"
05:38:16 <bernalex> or uh yeah that but proper :p
05:38:29 <opqdonut> i.e. just type out the law you mentioned earlier
05:38:42 <bernalex> yes
05:38:53 <bernalex> I just happened to have it defined there as natAdd as well
05:39:00 <bernalex> so property $ \x y -> (B.+) x y == natAdd x y
05:39:06 <ocramz> FFI question: say I have a pair of wrapped functions `createA :: IO (Ptr A)` and `destroyA :: Ptr A -> IO ()`; A is a `newtype A = A (Ptr A)`, representing a C array; what's the best way to dereference the pointer on Hs side, manipulate a copy of the data and filling the C array with the result? wrap A in a ForeignPtr and use `withForeignPtr` on it?
05:39:08 <bernalex> but it's simpler to just inline it
05:39:30 <opqdonut> bernalex: I have no idea what you're talking about. what's B.+?
05:39:38 <bernalex> opqdonut: that's what I'm testing
05:39:45 <opqdonut> what's natAdd?
05:40:03 <bernalex> the exact same :p
05:40:05 <ocramz> also, what's the difference in terms of garbage collection of wrapping the allocation/dealloca pair in a `bracket` from Control.Exception, versus letting `withForeignPtr` deal with it?
05:40:07 <bernalex> B.+ will be = undefined
05:40:13 <bernalex> natAdd is in the solutions module
05:40:31 <opqdonut> bernalex: sure if you have two implementations you can just test them against each other
05:40:31 <hyv> @help
05:40:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:40:36 <opqdonut> bernalex: then you don't need to think about the laws
05:40:45 <bernalex> opqdonut: going the law route anyway
05:41:15 <opqdonut> of course in this case the laws are so close to the implementation that testing is a bit dumb, but for an example / exercise ok
05:43:19 <bernalex> going with
05:43:21 <bernalex>       property $ \x y -> (B.+) (B.Succ x) y == B.Succ ((B.+) x y)
05:44:23 <phadej> bernalex: why not $ \x y -> B.succ x B.+ y == B.Succ (x B.+ y) ?
05:44:57 <bernalex> phadej: no particular reason.
05:45:27 <nobos> For anyone who tried to help me out; I kept the IO in the helper function in the end: https://github.com/arealities/simplestore/blob/master/src/App/ProjectServer.hs#L35-L36
05:45:32 <nobos> Thanks for the help guys!
05:45:41 <phadej> yet, that looks like definition, not a property one would like to test :)
05:50:29 <aweinstock> :t (Foreign.Marshal.peekArray, Foreign.Marshal.pokeArray)
05:50:31 <lambdabot> (Foreign.Storable.Storable a, Foreign.Storable.Storable a1) => (Int -> GHC.Ptr.Ptr a -> IO [a], GHC.Ptr.Ptr a1 -> [a1] -> IO ())
05:50:34 <aweinstock> ocramz: ^
05:51:12 <aweinstock> (peekArray copies the array into an intermediate list, pokeArray writes the haskell list into a C array)
05:52:47 * hackagebot lentil 0.1.5.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.5.0 (fffaaa)
05:53:16 <davidreis> h
05:53:52 <aweinstock> ocramz: there's also Data.Vector.Storable.Mutable.unsafeFromForeignPtr, which will let you work on the C array in-place
05:54:01 <hyv> ls
05:54:03 <hyv> ls
05:54:22 <ocramz> aweinstock: thanks!
05:54:32 <aweinstock> (the "unsafe" refers to the aliasing, since a C thread could be poking the data at the same time)
05:55:00 <ocramz> so there might be a need of wrapping the ForeignPtr in an MVar
05:55:35 <ocramz> dons does this in the implementation of Judy arrays
05:57:38 <aweinstock> it looks like Foreign.ForeignPtr.newForeignPtr will let you package your pointer and destroyA together, such that the GC handles freeing it properly
05:58:06 <c_wraith> note that foreign finalizers aren't guaranteed to run before program termination, though
05:58:10 <aweinstock> (if haskell shouldn't be responsible for freeing it, you want a no-op as the foreignPtr finalizer)
05:58:36 <c_wraith> So if it's something important to do no matter what, don't put it in a finalizer
05:59:41 <c_wraith> for instance, freeing system resources that don't belong to a specific process, like shared memory
05:59:43 <ocramz> no I definitely want Haskell to GC; I was using `bracket` which also collects exceptions (I collect C integer error codes and throw exceptions accordingly); does the finalizer run deterministically in this case? 
05:59:58 <c_wraith> finalizers never run deterministically
06:00:22 <ocramz> hmm
06:03:45 <ocramz> c_wraith: so there's no strict way to reclaim memory in this wonderful language?
06:04:04 <benzrf> ocramz: there's also no goto!
06:04:06 <benzrf> sorry
06:04:07 <c_wraith> ocramz: you can always manage it manually.
06:04:18 <c_wraith> ocramz: ResourceT, for instance
06:04:28 <aweinstock> benzrf: haskell has goto's (kinda)
06:04:34 <aweinstock> @src Cont
06:04:34 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
06:04:38 <benzrf> aweinstock: not natively :]
06:04:46 <ocramz> continuations hmm
06:04:57 <aweinstock> :t callCC
06:04:59 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
06:05:20 <ocramz> which looks like the monadic version of runCont
06:06:18 <c_wraith> ocramz: what you don't get is automatic exact resource management for free.  ResourceT gives you automatic exact resource management, but you have to pay the price of using it.
06:06:19 <ocramz> :t runResourceT
06:06:21 <lambdabot> Not in scope: ‘runResourceT’
06:08:09 <bernalex> opqdonut: so uh what's wrong with this then:       property $ \x y -> B.times (B.Succ x) y == B.plus (B.Succ x) (B.times x y) -- ?
06:08:15 <bernalex> I guess I'm doing goofd.
06:08:15 <ravi_ss> hi
06:08:20 <ravi_ss> hi
06:08:41 <ravi_ss> i have question on building haskell 
06:08:43 <IcyFoxy> c_wraith: "for free" "but you have to pay the price for using it"
06:08:48 <opqdonut> bernalex: looks fine tome
06:09:00 <bernalex> maybe the problem is here then?
06:09:02 <bernalex> Zero `times` b     = Zero
06:09:04 <bernalex> (Succ a) `times` b = a `plus` (a `times` b)
06:09:07 <c_wraith> IcyFoxy: yes, I said "you don't get it for free".
06:09:08 <IcyFoxy> Free as in it is cheap in your code; but expensive because ... expensive?
06:09:17 <ravi_ss> how to test the haskell after build
06:09:19 <IcyFoxy> Oh
06:09:28 <c_wraith> IcyFoxy: it's expensive because you have to distort your code somewhat to use it
06:09:57 <ravi_ss> how to test the haskell after build
06:10:07 <ravi_ss> can any urgently reply
06:10:11 <IcyFoxy> c_wraith: Noted
06:10:20 <opqdonut> bernalex: ah, no law is "(a+1) * b = b + (a * b)"
06:10:24 * IcyFoxy hasn't written any Haskell in... several months, maybe over a year :O
06:10:41 <opqdonut> bernalex: you got it wrong in both the test and the impl :)
06:10:45 <ravi_ss> how to test the haskell after build urgently answer please
06:10:45 <geekosaur> ravi_ss, would you like to expand your question?
06:10:54 <geekosaur> or just repeat it and hope we can make some sense of it
06:11:03 <geekosaur> ghc has a test suite. or did you mean your own haskell program?
06:11:17 <ravi_ss> sure.. i have installed haskell-platform
06:11:29 <opqdonut> bernalex: (your test is "(x+1) * y = (x+1) + x*y", your impl is "(a+1) * b = a + (a*b)")
06:12:37 <ravi_ss>  i have installed haskell-platform.. i want to check whether it is installed currently.. if i wanted to do test how can i do that
06:13:08 <ravi_ss> i wanted some default test cases to be run against it
06:13:41 <ravi_ss> i have installed haskell-platform.. i want to check whether it is installed currently.. i wanted some default test cases to be run against it.. how to do that? can any please answer
06:14:03 <bollu> ravi_ss: can you invoke ghci? ghc? cabal?
06:14:06 <ravi_ss> @geekosaur
06:14:06 <lambdabot> Unknown command, try @list
06:14:16 <ocramz> c_wraith: instead, what's a good way to make a `peek .. fmap .. poke` block "atomic", as in, make  sure a single process can overwrite an array at any one time? 
06:14:25 <ravi_ss> @bollu ghc
06:14:25 <lambdabot> unexpected "g": expecting number, "d" or "("
06:14:42 <bollu> ravi_ss: you can @mention on IRC. You can however, auto complete people
06:14:42 <c_wraith> ocramz: you'll need to synchronize that at a higher level.
06:14:53 <bollu> ravi_ss: you can auto complete names with a TAV
06:14:54 <bollu> TAB*
06:14:59 <bollu> ravi_ss: that will ping them
06:14:59 <IcyFoxy> ravi_ss: Please avoid @ with the bot. geek<tab> for tab completion
06:15:04 <ravi_ss> i have installed haskell-platform.. i want to check whether it is installed currently.. i wanted some default test cases to be run against it.. how to do that? can any please answer
06:15:06 <merijn> Is there a convenient way to unpack all arguments of a constructor?
06:15:15 <c_wraith> ocramz: that is, protect access to the native resource with an MVar or something
06:15:19 <bollu> ravi_ss: yeah, so, do you how to go to the command prompt / terminal?
06:15:25 <bollu> ravi_ss: what OS are you on?
06:15:26 <c_wraith> merijn: -XRecordWildcards ?
06:15:37 <ravi_ss> command prompt
06:15:50 <ravi_ss> terminal
06:15:52 <IcyFoxy> Command Prompt as in Microsoft Windows?
06:16:01 <merijn> c_wraith: I Meant as in {-# UNPACK #-}
06:16:08 <ravi_ss> what's the difference command prompt/ terminal
06:16:14 <merijn> c_wraith: i.e. I want all fields to be strict + unpacked
06:16:16 <IcyFoxy> Huge
06:16:31 <c_wraith> merijn: oh, there are some examples of using GHC plugins to do that per-module
06:16:34 <ravi_ss> i have installed haskell-platform.. i want to check whether it is installed currently.. i wanted some default test cases to be run against it.. how to do that? can any please answer
06:16:38 <bollu> ravi_ss: which operating system are you using? And they're just 2 names for the same thing (windows calls it command prompt. UNIX people call it terminal). Which was why I asked, which OS are you on?
06:16:51 <c_wraith> merijn: I think GHC 8 is also going to have an extension for that
06:16:52 <bollu> ravi_ss: dude, I'm trying to answer. Don't spam the channel :)
06:17:00 <ravi_ss> ubuntu vivid terminal
06:17:03 <merijn> c_wraith: That doesn't help me now, though ;)
06:17:39 <bollu> ravi_ss: okay, cool. So, can you startup the terminal for me? The shortcut is ctrl+alt+T
06:17:40 <tdammers> once the time travel patch in GHC 9 hits, you can just go back to 5 minutes ago and solve your problem
06:17:43 <bernalex> opqdonut: oops. implementation one was just a typo (a instead of b first) but test is very broken, yeah
06:18:20 <bollu> ravi_ss: did you manage to get the terminal running?
06:18:28 <ravi_ss> i have terminal open.. i
06:18:34 <bollu> ravi_ss: okay, cool
06:18:41 <ravi_ss> if i type ghc --version
06:18:51 <bollu> yeah, what does it say?
06:18:55 <ravi_ss> i get the answer
06:19:17 <bernalex> opqdonut: fixed! thanks! heh
06:19:19 <bollu> ravi_ss: cool. Can you try "cabal —help" as well?
06:19:24 <bollu> —help*
06:19:41 <bollu> argh, that should be double "-"
06:19:47 <bollu> idk, mac is autocorrecting it
06:20:14 <ravi_ss> i need  the testcases to tell that the ghc is working in all commands
06:20:34 <ocramz> ravi_ss : why shouldn't it?
06:20:36 <bollu> ravi_ss: If you have ghc installed, chances are it'll work.
06:20:58 <bollu> ravi_ss: if you don't trust the package maintainers, then you'll have to build from source, I'm afraid
06:21:08 <ravi_ss> someting like after you build package u run the testcases to tell that build is successfull.. similar think i want
06:21:50 <bollu> ravi_ss: most toolchains don't come with tests like that - because they will be tested *before* the packaging
06:22:16 <ravi_ss> i am new for haskell can any pls share me the git source so that i can build
06:22:42 <ravi_ss> i am new for haskell can any pls share me the git source for haskell-platform so that i can build
06:22:43 <ocramz> ravi_ss : haskell.org?
06:23:00 <ravi_ss> i don't see the haskell repo their
06:24:41 <merijn> Man...I really need a convenient Haskell-C++ interace :\
06:24:55 <bollu> ravi_ss: git://github.com/ghc/ghc
06:25:00 <ravi_ss> Can any please share me the haskel-platform repo for build
06:25:15 <bollu> ravi_ss: https://github.com/ghc/ghc
06:25:31 <hodapp> merijn: good luck finding a convenient anything-to-C++ interface
06:25:39 <merijn> I keep running into problems where half of my problem is a pain to do in Haskell and the other is a pain to do in C++ :\
06:25:51 <bollu> ravi_ss: why do you want to build form source?
06:25:51 <ocramz> ravi_ss: here, have fun: https://ghc.haskell.org/trac/ghc/wiki/Building 
06:25:54 <doomlord> the interface is called C
06:25:56 <bollu> ravi_ss: like, what's the point?
06:25:59 <ravi_ss> git://github.com/ghc/ghc i have seen it it is for ghc not for haskell-platform
06:26:00 <hodapp> the options available seemed to be "write a C wrapper" or "go bang your head into a wall for 9 hours"
06:26:05 <merijn> doomlord: Well, I did specify *convenient* :p
06:26:11 <doomlord> oh
06:26:31 <nullx002> doomlord: hi
06:26:34 <KaneTW> ravi_ss: generally you don't build the haskell platform for personal use, but ghc instead and install all the packages that you need
06:26:36 <doomlord> greetings
06:26:43 <ravi_ss> i have to build from source and run test cases to show that build is successfull
06:27:02 <KaneTW> if you need the haskell platform specifically, see https://github.com/haskell/haskell-platform
06:27:17 <bollu> doomlord: hey, you used to hang out in the Rust forums, right?
06:27:23 <KaneTW> but imo if you're going that far just build ghc/cabal-install and deploy that
06:27:26 <bollu> ravi_ss: show to whom?
06:27:31 <doomlord> yes i was into rust for a while
06:27:33 <KaneTW> then install the packages that you need with cabal individually
06:27:41 <doomlord> haven't touched it in months, i should take a look again 
06:27:53 <hodapp> are there any other standardized calling conventions than that of C/FORTRAN?
06:27:54 <bollu> doomlord: haha, yeah, same boat. You were into gamedev IIRC
06:28:01 <doomlord> yes
06:28:23 <bollu> did you manage to write anything non-trivial in rust? Lifetimes always got the best of me :P
06:28:26 <ravi_ss> show to client sure
06:29:07 <doomlord> i wrote something to present rust source as linked html
06:29:13 <doomlord> did some 3d stuff on android
06:29:29 <doomlord> but its' all bitrotted by now, it was pre 1.0
06:29:38 <bjz> bollu: you mean in type signatures, or in actual code?
06:29:49 <ravi_ss> http://askubuntu.com/questions/677913/error-while-installing-haskell/679323#679323 can you people give your solution here
06:30:08 <bollu> bjz: actual code
06:30:22 <bollu> bjz: I was writing interpreters, and I couldn't write phases on the AST structure
06:30:29 <bjz> bollu: you internalise the rules over time
06:30:38 <ravi_ss> bollu: i have tried with ghc ended in error can you see http://askubuntu.com/questions/677913/error-while-installing-haskell/679323#679323
06:30:46 <bollu> bjz: because I kept running into lifetime interactions with closures + structures
06:30:47 <muzzle> Hi, does anyone here know how to use HaskellR, because i have a Problem with it on OS X
06:30:57 <bjz> bollu: post 1.0?
06:30:58 <muzzle> ?
06:31:04 <bollu> bjz: I asked huon for help too loads of times, and they were always intractable
06:31:12 <bollu> bjz: no, I was around during beta.
06:31:18 <bjz> bollu: returning closures at the moment is a pain
06:31:31 <bollu> bjz: I wanted closures to maintain AST state.
06:31:37 <bjz> yeah
06:31:40 <bollu> bjz: yeah, like, I _love_ rust
06:31:47 <bollu> bjz: but I want it to be less painful
06:31:50 <bjz> that's kind of hard in current Rust
06:32:49 * hackagebot polynomials-bernstein 1.1.2 - A solver for systems of polynomial equations in bernstein form  https://hackage.haskell.org/package/polynomials-bernstein-1.1.2 (JeanPhilippeBernardy)
06:32:50 <muzzle> This is my example program http://lpaste.net/141933 and this is the error at runtime http://lpaste.net/141934
06:33:59 <bollu> johnw: remember the linker thing you asked me to check out? Is that still alive?
06:34:14 <osa1> am I doing this wrong or is there no way to use `where` in pattern guard RHSs?
06:34:52 <RaceCondition> when using ide-backend from Emacs, does it make sense to keep ghc-mod installed?
06:36:03 <bjz> bollu: you would probably have to take a more imperative mindset, unfortunately, with a context struct. or `impl Fn` on a structure that represents your closure. Hopefully that kind of stuff will improve in the future, but it is certainly at the frontier of making lifetimes ergonomic. GCs still win out there, on the more functional, higher order stuff.
06:36:43 <geekosaur> muzzle, that's nto an error that anyone here can help with, most likely. I do not see Language.R anywhere on hackage, suggest you contact its maintainer/author
06:36:54 <bollu> bjz: yeah, I suppose so. I lost interest at some point, and moved the codebase to C
06:37:22 <muzzle> geekosaur it's from http://hackage.haskell.org/package/inline-r
06:37:48 <geekosaur> odd that hayoo did not see Language.R module anywhere
06:38:03 <ocramz> muzzle: it looks like memory usage exploded, but haven't used the Language.R yet
06:38:26 <geekosaur> that's an awfully simple program for memory usage to explode on
06:38:49 <muzzle> it shouldn't, it's their example program… http://tweag.github.io/HaskellR/docs/differences-repl-source.html
06:38:53 <ocramz> geekosaur: yes, I'm stumped as well :/
06:38:55 <muzzle> (with minimal modifications)
06:39:19 <geekosaur> seriuously, I think you need to email m@tweag.io (address from the project page)
06:39:29 <muzzle> ok, i'll try that
06:39:36 <muzzle> thx
06:42:53 <merijn> Do we have a library for high-quality + high-performance random numbers?
06:43:06 <bernalex> opqdonut: got an idea how to quickcheck power of but not uh crash everyone's computers?
06:43:10 <bernalex>       property $ \b e -> B.powerOf b (B.S e) == B.times b (B.powerOf b e)
06:43:13 <bernalex> >computer stalls
06:43:20 <bernalex> OK guess I got it right then!
06:43:22 <bernalex> erm.
06:44:12 <tsahyt> merijn: What about mwc-random?
06:44:29 <opqdonut> bernalex: limit the size of b and e
06:44:43 <bernalex> opqdonut: yeah but is there some super easy way to do that?
06:44:57 <opqdonut> with e.g. sized or choose
06:44:58 <merijn> tsahyt: Ah, that looks good :)
06:47:36 <bernalex> opqdonut: yeah but what I don't remember is what goes where. :] i.e. where should I use sized?
06:49:24 <nullx002> hi
06:49:30 <nullx002> how do i output a list in hex
06:49:46 <nullx002> like first 100 hex numerals in a list
06:50:21 <frerich> nullx002: What kind of 'list' would that be, and what output do you expect -- can you give a sample invocation?
06:51:00 <nullx002> showHex 20 ""
06:51:07 <nullx002> it gives output 14
06:51:09 <tsahyt> > showHex 20 ""
06:51:11 <lambdabot>  "14"
06:51:27 <nullx002> now i want a list in hex output
06:51:37 <tsahyt> :t concatMap
06:51:38 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
06:51:44 <nullx002> starting from x ... infinite
06:51:46 <frerich> nullx002: A list of integers, you mean?
06:51:54 <nullx002> output in hex
06:51:58 <nullx002> not decimal
06:52:28 <bernalex> opqdonut: I guess I could just use arbitrary = B.toNat <$> choose (some numbers) -- it's not like I need to test anything big.
06:52:41 <tsahyt> nullx002: Apply showHex to each, concatenate the result.
06:52:49 <frerich> nullx002: You could just map '\n -> showHex n ""' over an infinite list, no?
06:53:09 <nullx002> what is the syntax
06:53:11 <tsahyt> Or to put it all in one, use concatMap
06:53:48 <nullx002> concatMap how that works?
06:53:59 <ARM9> > map (\x -> putStr $ showHex x "") [1..10]
06:54:01 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO...
06:54:04 <bernalex> opqdonut: but uh powerOf stalls even with choose (0, 10) lol
06:55:14 <Guest33947> what doyou think of lenses ?
06:55:14 <tsahyt> nullx002: Look at the type.
06:55:14 <tsahyt> :t concatMap
06:55:14 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
06:55:14 <tsahyt> It takes a function that converts an a to a list, and some foldable container of a's and then returns a concatenated list of the results of each function application
06:55:35 <tsahyt> :t \f -> concat . map f
06:55:36 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
06:55:48 <sunnymilk> um when i run my program it just prints "<<loop>>" and dies?
06:55:53 <tsahyt> For list it's the same as this. Apply function f to each element in the list and then concatenate the results.
06:55:55 <sunnymilk> but when i interpret it in ghci it runs fine
06:55:59 <sunnymilk> can someone explain
06:56:14 <exio4> sunnymilk: code, which ghc version too
06:56:27 <sunnymilk> 7.10.2
06:56:47 <nullx002> not working
06:56:48 <sunnymilk> one sec for code
06:57:18 <sunnymilk> http://lpaste.net/141938
06:57:24 <nshepperd> bernalex: property $ \b (Small e) -> ...
06:57:43 <nshepperd> and add a custom Arbitrary instance for Small
06:57:57 <nshepperd> actually that might already exist
06:57:58 <bernalex> nshepperd: oh. that's neat. thanks!
06:57:59 <sunnymilk> its supposed to find the Omega combinator
06:58:12 <sunnymilk> by searching through a big list of every lambda term
06:58:27 <tsahyt> > map (flip showHex "") [1..]
06:58:29 <lambdabot>  ["1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","10","11","12",...
06:59:06 <nullx002> wht  is wrong with this: take 10 ( map '\n -> putStr $ showHex n "")  [1..]
06:59:15 <nshepperd> bernalex: or maybe make your own type and use `\(Small b e) -> ...` if you want to control the ranges of b and e together
06:59:52 <tsahyt> nullx002: What does the compiler say?
07:00:19 <nullx002> error
07:00:22 <nullx002> print error
07:00:28 <magamig> hey
07:00:40 <bernalex> nullx002: wait not instance Small B.Nat? how does this Small thing work then?
07:00:51 <nullx002> lexical error in string/character literal at character ' '
07:00:54 <tsahyt> nullx002: Well yeah, I got that far. The exact error message tells you something where you went wrong
07:01:10 <tsahyt> For starters, the ' in there doesn't belong. That's the first thing it complains about
07:01:11 <magamig> i am having some trouble in ghci in fish! when I run a command in ghci the terminal goes one line up
07:01:16 <magamig> (pic here: http://imgur.com/a/N36yD)
07:01:20 <bernalex> right it's a newtype
07:02:06 <nshepperd> bernalex: right, the one in Test.QuickCheck has instance Integral a => Arbitrary (Small a)
07:02:22 <nullx002> tsahyt: λ >> take 10 ( map '\n -> putStr $ showHex n "")  [1..]
07:02:23 <nullx002>  
07:02:23 <nullx002> <interactive>:50:18:
07:02:26 <nullx002>     lexical error in string/character literal at character ' '
07:02:29 <nullx002>  
07:02:47 <bernalex> nshepperd: given that I do   arbitrary = B.toNat <$> arbitrarySizedNatural
07:02:51 <tsahyt> nullx002: Why did you put the single quote in there? It's syntactically wrong
07:02:56 <sunnymilk> oh
07:02:58 <bernalex> woh wait right
07:03:05 <sunnymilk> i was using foldl instead of foldr
07:03:06 <bernalex> s/w//
07:03:24 <tsahyt> nullx002: take 10 (map (\n -> putStr $ showHex n "") [1..])
07:03:33 <tsahyt> That cleans up the syntax problems.
07:03:45 <nullx002> still same error
07:03:52 <tsahyt> > take 10 (map (\n -> putStr $ showHex n "") [1..])
07:03:54 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO...
07:03:56 <tsahyt> Nope
07:04:02 <ARM9> drop the inner putStr perhaps
07:04:17 <nullx002> it gives: parse error (possibly incorrect indentation or mismatched brackets)
07:04:23 <sunnymilk> well now it works but i run out of memory in about 10 seconds
07:04:31 <tsahyt> nullx002: Did you mix tabs and spaces perhaps?
07:04:38 <sunnymilk> i dont understand why, im only working with one element of the list at a time
07:04:40 <nullx002> dont know
07:04:44 <nullx002> let me check
07:04:49 <nullx002> i checked it before
07:05:13 <magamig> "when I run a command in ghci the terminal goes one line up" (http://imgur.com/a/N36yD)
07:05:20 <magamig> any suggestions
07:05:21 <magamig> ?
07:05:28 <exio4> sunnymilk: hm, can't look much atm but I thought it might have been a bug I got in the past, so nvm :P
07:05:34 <nullx002> tsahyt: λ >> take 10 (map (\n -> putStr $ showHex n "") [1..])
07:05:34 <nullx002>  
07:05:34 <nullx002> <interactive>:53:1:
07:05:34 <nullx002>     No instance for (Show (IO ())) arising from a use of ‘print’
07:05:37 <nullx002>     In a stmt of an interactive GHCi command: print it
07:05:40 <nullx002>  
07:05:55 <tsahyt> Look at the type of what you just constructed.
07:05:58 <tsahyt> :t take 10 (map (\n -> putStr $ showHex n "") [1..])
07:06:00 <lambdabot> [IO ()]
07:06:12 <tsahyt> The error tells you that you cannot show an IO (), which is true.
07:06:44 <tsahyt> The IO () type comes from the inner putStr. Essentially you've built a list of print commands
07:07:30 <nullx002> so how can i show it?
07:07:35 <ocramz> aweinstock: Re: foreign pointers, what did you mean by "no-op instead of the finalizer" in newForeignPtr
07:07:46 <nullx002> this works well: take 25 (map (flip showOct "") [1..])
07:08:00 <tsahyt> nullx002: Well look at the difference between the two expressions
07:08:11 <kras> ?src intersperse
07:08:12 <lambdabot> intersperse _   []     = []
07:08:12 <lambdabot> intersperse _   [x]    = [x]
07:08:12 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
07:08:14 <ocramz> aweinstock: something like `FunPtr (\_ -> IO ())` ?
07:09:28 <nullx002> tsahyt: what is the difference?
07:09:29 <tsahyt> You end up with different types. In the oct example, you get a list of strings. In the hex example you've built a [IO ()] because of the putStr
07:09:51 <nullx002> tsahyt: what if i remove putStr
07:10:02 <tsahyt> Try it out
07:10:05 <nullx002> will it get the same output 
07:10:05 <tsahyt> No
07:10:14 <tsahyt> The result will be of a different type
07:10:38 <tsahyt> :t map (flip showHex "") [1..]
07:10:39 <lambdabot> [String]
07:10:48 <nullx002> ding! 
07:10:58 <nullx002> it works
07:11:13 <nullx002> take 10 (map (\n -> showHex n "") [1..])
07:11:33 <tsahyt> You'll probably want to read LYAH or a similar introductory text
07:11:44 <tsahyt> http://learnyouahaskell.com/
07:11:58 <nullx002> yes i am on tuples right now
07:12:11 <ocramz> high on tuples
07:12:14 <nullx002> but mixing things with some advance stuff too...
07:12:15 <ocramz> have fun!
07:12:23 <nullx002> LOL
07:12:29 <tsahyt> When writing haskell, let the types guide you
07:12:39 <nullx002> tulips may be... ;)
07:12:55 <tsahyt> Using :set +t in ghci helps. If the type isn't what you expect it to be, you're probably on the wrong path
07:13:37 <nullx002> i like haskell, if it outputs mostly it is right, if it is wrong it doesn;'t output anyting but errors
07:14:37 <nullx002> tsahyt: how long should i work on LYAH
07:15:40 <ocramz> nullx002: when SPJ starts talking in your dreams, you'll know you're ready
07:16:17 <nullx002> so may be in a month
07:16:24 <Gurkenglas> There should be [MaybeT m a] -> ListT m a. (Or [m (Maybe a)] -> m [a]?)
07:16:31 <Gurkenglas> Who was maintaining monad-loops?
07:18:37 <Gurkenglas> (like, takeWhile, not like catMaybes :I)
07:18:41 <Gurkenglas> -,
07:19:00 <tsahyt> nullx002: Reading error messages takes some experience, but they can be really informative. Work on LYAH until you understand everything in there.
07:20:33 <nullx002> tsahyt: λ >> take 15 (concatMap (\n -> showHex n "") [1..])
07:20:33 <nullx002> "123456789abcdef"
07:20:33 <nullx002>  
07:20:48 <nullx002> no comma separated list...
07:20:55 <nullx002> with concatMap ?
07:21:11 <ARM9> :t concatMap
07:21:12 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
07:21:18 <ARM9> > take 18 (concatMap (flip showHex " ") [1..])
07:21:20 <lambdabot>  "1 2 3 4 5 6 7 8 9 "
07:21:46 <nullx002> ok
07:21:57 <ARM9> and it gets worse
07:22:11 <ARM9> > take 18 (concatMap (flip showHex "") [1..])
07:22:13 <lambdabot>  "123456789abcdef101"
07:23:00 <nullx002> strange output: λ >> take 15 (concatMap (\n -> showHex n ",") [1..])
07:23:00 <nullx002> "1,2,3,4,5,6,7,8"
07:23:00 <nullx002>  
07:23:01 <tsahyt> > intercalate "," $ map (flip showHex "") [100..]
07:23:01 <astynax> Hello! I have a question about haddock. What I need to do, if I want to document the exported field getters, but not want to export the constructor?
07:23:02 <lambdabot>  "64,65,66,67,68,69,6a,6b,6c,6d,6e,6f,70,71,72,73,74,75,76,77,78,79,7a,7b,7c,...
07:23:17 <bernalex> nshepperd: I might be stupid but I don't really understand how I'm supposed to use Small on my Arbitrary B.Nat type
07:23:35 <tsahyt> nullx002: The take here works on the characters of the string created in the parentheses. You take 15 characters.
07:23:40 <ARM9> nullx002 consider what take does to a String
07:24:51 <tsahyt> astynax: Field getters as in functions created by record syntax? I think you can just export those separately and the docs should match up with that
07:25:37 <astynax> Hmm... I'll try. Thanks!
07:25:51 <bernalex> nshepperd: am I supposed to derive Integral and use the Integral a instance for Small?
07:26:02 <nullx002> tsahyt: hum... init(take 30 (concatMap (\n -> showHex n ",") [1..]))
07:26:29 <tsahyt> nullx002: What about it?
07:26:31 <nullx002> "1,2,3,4,5,6,7,8,9,a,b,c,d,e,f"
07:26:43 <lpaste> lunaris pasted “Monad controlled folds” at http://lpaste.net/141939
07:26:49 <astynax> @tsahyt it work! Thanks a lot!
07:26:50 <lambdabot> Unknown command, try @list
07:26:52 <nshepperd> bernalex: you could implement Integral B.Nat yeah
07:27:02 <astynax> tsahyt: thanks!
07:27:05 <nullx002> as desired
07:27:11 <lunaris> Hey all; don't suppose anyone familiar with monad-control can help me with my paste (http://lpaste.net/141939)?
07:27:37 <lunaris> Basically I'm trying to lower a foldM-like operation through a monad stack.
07:27:45 <nullx002> can this be replaced with anything mroe optimal: init(take 30 (concatMap (\n -> showHex n ",") [1..]))
07:28:00 <nshepperd> bernalex: or skip using Test.QuickCheck.Small entirely, and define your own 'newtype MySmall = MySmall B.Nat' and make your own Arbitrary instance for that
07:28:06 <tsahyt> What are you trying to do?
07:28:23 <bernalex> nshepperd: that seems to be the internetpopular solution
07:28:28 <nullx002> get output : "1,2,3,4,5,6,7,8,9,a,b,c,d,e,f"
07:28:47 <nullx002> from an infinite list
07:28:48 <nshepperd> bernalex: you might want to do the latter anyway, since you get more control over the range of values that way
07:28:54 <nullx002> hex output from an infinite list
07:29:19 <tsahyt> > intercalate "," . take 15 .  map (flip showHex "") [1..]
07:29:20 <nshepperd> I don't relly know what sort of distribution Test.QuickCheck.Small uses
07:29:20 <lambdabot>      Couldn't match expected type ‘a -> [[Char]]’
07:29:20 <lambdabot>                  with actual type ‘[String]’
07:29:20 <lambdabot>      Possible cause: ‘map’ is applied to too many arguments
07:29:22 <tsahyt> > intercalate "," . take 15 .  map (flip showHex "") $ [1..]
07:29:24 <lambdabot>  "1,2,3,4,5,6,7,8,9,a,b,c,d,e,f"
07:29:43 <Gurkenglas> lunaris, what are you passing the int through for? It doesn't seem to be used anywhere
07:29:47 <glguy_> Lunaris , you almost never want an instance that is that general
07:30:02 <glguy_> It will overlap with nearly everything
07:30:13 <lunaris> Gurkenglas: It's just an example of an argument that's not polymorphic, in case that complicates things.
07:30:18 <lunaris> glguy_: It's not, in practice.
07:30:31 <nullx002> need to add any library for intercalat @tsahyt
07:30:33 <bernalex> nshepperd: works well. thank you. now I just have to look up how what's the most sensible way to specify my range. arbitrary = return $ Small B.Z isn't very useful. :]
07:30:37 <tsahyt> nullx002: It's in Data.List
07:30:39 <lunaris> I've got some other machinery to prevent that (peano numerals, ala monad-classes).
07:30:51 <lunaris> But I'm trying to keep my example simple in the hope that someone can help me get it working.
07:35:08 <nullx002> tshayt: λ >> intercalate "," . take 15 .  map (flip showHex "") $ [1..]
07:35:08 <nullx002> "1,2,3,4,5,6,7,8,9,a,b,c,d,e,f"
07:35:08 <nullx002> λ >> init(take 30 (concatMap (\n -> showHex n ",") [1..]))
07:35:08 <nullx002> "1,2,3,4,5,6,7,8,9,a,b,c,d,e,f"
07:35:21 <nullx002> so why intercalate is better than what i come up with?
07:35:33 <nullx002> any specific speed or other issues?
07:35:36 <ARM9> the problem is that map and concatMap do different things
07:35:47 <ARM9> and the way take works on the respective data types
07:35:50 <ARM9> [String] vs String
07:37:13 <bernalex> nshepperd: instance Arbitrary (SmallNats) where
07:37:15 <bernalex>   arbitrary = Small . B.toNat <$> choose (0, 4)
07:37:25 <ARM9> also note that your later example breaks even more when you start reaching multiple digits (10,11,12..)
07:37:27 <chpatrick> :t hex
07:37:29 <lambdabot> (Integral a, Applicative f, Choice p) => p a (f a) -> p String (f String)
07:37:31 <bernalex> nshepperd: that takes less than ten seconds. good enough. :p
07:37:36 <jgertm> is there a way to make my warp server only react to http2 requests?
07:37:43 <nshepperd> bernalex: nice!
07:39:34 <nullx002> ARM9: no it is not breaking
07:39:40 <glguy_> > foldr (\x -> showHex x . showChar ',') "" [1..]
07:39:41 <nullx002> it gives perfect output
07:39:42 <lambdabot>  "1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,10,11,12,13,14,15,16,17,18,19,1a,1b,1c,1d,1e,...
07:40:10 <bernalex> nshepperd: now to evaluate whether beginner's to functional programming will even be able to implement peano number functions lol. I thought I'd give them the ADT and have them do the functions. then do functions on lists where they make their own List a.
07:40:20 <glguy_> That one does the least list appending
07:40:30 <ARM9> nullx002 try it yourself if you don't trust me, init(take 32 (concatMap (\n -> showHex n ",") [1..]))
07:41:08 <recursion-ninja> I have a stack question, how do I make stack download an older version of GHC so that an older version of base meets the build dependecies requirments?
07:41:33 <lyxia> lunaris: You have f :: a -> r -> t m a and to use the C m constraint you probably need to turn it into something of type a -> r -> m a, that doesn't look possible.
07:42:11 <lunaris> lyxia: I'm fiddling with it now. I am fully prepared to accept that it may not be possible :)
07:43:59 <slacko1256> foldr const undefined [041007..045]
07:44:09 <geekosaur> ...shouldn't stack be detecting the compatible version of base and selecting an appropriate ghc?
07:44:24 <geekosaur> > [10..5]
07:44:26 <lambdabot>  []
07:44:31 <geekosaur> perhaps you meant
07:44:37 <geekosaur> > [10,9..5]
07:44:38 <lambdabot>  [10,9,8,7,6,5]
07:45:00 <geekosaur> actually that just looks wrong, come to think of it
07:45:05 <slacko1256> geekosaur: when I sent that command, did it have extra characters?
07:45:06 <geekosaur> missing parens
07:45:22 <slacko1256> I am trying the /hs command fron irc-core
07:45:28 <geekosaur> oh
07:45:44 <geekosaur> it colorized the range
07:45:52 <slacko1256> (obviously, the client that shows it correctly)
07:45:55 <slacko1256> Mmmm
07:46:16 <geekosaur> if a client doesn't support mIRC color protocol then you will see extra characters
07:46:28 <slacko1256> 07let Just x 07= return 0419
07:46:52 <slacko1256> bah, you're right
07:47:32 <geekosaur> the color codes will look like a control-C (\x03), one or more digits, optionally comma and one or more digits for background color
07:47:44 <slacko1256> I guess then is more useful when you are on /msg with somebody, not with general channels
07:47:50 <glguy_> Which isn't many clients. They usually support it enough to at least step the control codes is the don't do color
07:48:15 <geekosaur> yeh, I was thinking that if this is an irc bot and it's logging its own output, it may have them literally
07:49:21 <slacko1256> glguy_: btw, great work with irc-core. Definetly my default client now :-)
07:49:58 <geekosaur> ah
07:50:06 <glguy_> Oh, thanks :)
07:50:12 * geekosaur did not look at what irc-core was, assumed some kind of bot architecture since they seem to be common
07:50:41 <slacko1256> I guess you could use a subset of the library to implement bots on top
07:50:42 <glguy_> It's the irc library core of the client
07:51:26 <slacko1256> but the vty interface is really nice. Takes full advantage of color support
07:51:41 * geekosaur has hackage page loaded now, yeh
07:59:19 <nullx002> yes ARM9: last digit breaks
08:04:46 <hunteriam> If I'm making a map of 173000 elements, it's going to ~800000 time
08:04:54 <hunteriam> Since insert is O log n
08:05:02 <hunteriam> So maybe map is a bad choice for me?
08:06:15 <slacko1256> > logBase 2 173000
08:06:17 <lambdabot>  17.40041251229881
08:09:21 <hunteriam> That's for one insertion
08:09:29 <hunteriam> I have to do 173000 insertions to build the list
08:09:46 <hunteriam> So it's sum from 1 to 173000 of log I
08:09:55 <chpatrick> hunteriam: what are you going to do with it when it's done?
08:10:06 <hunteriam> Search it
08:10:12 <hunteriam> And then convert it to a graph
08:10:20 <chpatrick> search in what sense?
08:10:46 <hunteriam> For each n I'm going to search 27 things to see if they're in the graph
08:10:49 <lpaste> lunaris revised “Monad controlled folds”: “No title” at http://lpaste.net/141939
08:11:01 <hunteriam> So I guess that's n^2 on a list
08:11:07 <hunteriam> So maybe it is faster for data.map
08:11:31 <lunaris> Gurkenglas / glguy_ / lyxia: This paste typechecks; seeing if it actually works now. Be interested to hear your thoughts :)
08:11:33 <chpatrick> hunteriam: if your keys are sorted you can make the map in O(n) with fromAscList and co
08:11:48 <hunteriam> Ah good I think they are thanks
08:13:32 <chpatrick> hunteriam: might be worth looking at unordered-containers though...
08:13:50 <chpatrick> although Data.HashMap doesn't have fromAscList
08:14:14 <glguy_> You never need to use fromAscList anymore. fromList is fast on sorted lists
08:14:27 <chpatrick> ah seeet
08:14:32 <chpatrick> *sweet
08:15:53 <glguy_> At least on Map. Sorting doesn't matter to a hash map
08:16:00 <chpatrick> of course
08:16:18 <chpatrick> I think hashmap would be healthier for so many elements
08:17:24 <magamig> "Not in scope: ‘chunksOf’"
08:17:27 <magamig> any help?
08:18:08 <glguy> http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html#v:chunksOf
08:18:31 <glguy> If that's not it you'll have to give us more info
08:19:29 <magamig> that is it but how do I "import" it to ghci?
08:19:37 <chpatrick> :m +Data.List.Split
08:19:45 <chpatrick> or just "import Data.List.Split"
08:20:24 <magamig> "Could not find module ‘Data.List.Split’
08:20:24 <magamig>     It is not a module in the current program, or in any known package."
08:20:29 <magamig> tried that...
08:20:31 <chpatrick> then you need to install it from cabal
08:20:36 <chpatrick> preferably into a sandbox
08:21:07 <magamig> cabal install Data.List.Split?
08:21:13 <chpatrick> cabal install split
08:22:04 <magamig> thank you :)
08:23:54 <magamig> how to separate an "int" by commas and put it in a list?
08:24:13 <glguy> > splitOn "," "1,2,3"
08:24:15 <lambdabot>  ["1","2","3"]
08:24:46 <glguy> If you look through the docs for that package you'll see lots of ways to split things http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html 
08:25:11 <magamig> and about an integer? like this
08:25:12 <magamig> 1234
08:25:16 <magamig> to 
08:25:20 <magamig> ["1","2","3","4"]
08:25:33 <chpatrick> show 1234
08:26:09 <chpatrick> > map (:[]) . show $ 1234
08:26:10 <lambdabot>  ["1","2","3","4"]
08:26:25 <magamig> sorry for this "stupid" questions but i am starting to learn haskel, thank you all
08:27:50 <glguy> You don't even need to learn two operators to do it:  map (:[]) (show 1234)
08:28:11 <glguy> [ [x] | x <- show 1234 ]
08:28:34 <lyxia> lunaris: nice. I'd like to know if that works :)
08:28:50 <lunaris> lyxia: Just hacking in the base instance now.
08:28:59 <lunaris> Which is also quite fiddly.
08:29:41 <magamig> glguy thank you, I will try to understand both answers, i am starting so I am trying to catch the most I can
08:30:21 <glguy> magamig: One thing to know is that a normal Haskell String is a list of Char: type String = [Char]
08:30:41 <glguy> So the string "1" is the list ['1']
08:32:19 <Bez_> what does the $ in your example do chpatrick?
08:32:51 <c_wraith> @src $
08:32:51 <lambdabot> f $ x = f x
08:33:21 <c_wraith> It's just a really simple combinator defined in the standard library 
08:33:40 <magamig> Bez_ here: https://www.haskell.org/hoogle/?hoogle=%24
08:33:52 <magamig> hoogle is really helpful :)
08:33:59 <Gurkenglas> Bez_, it has very low precedence and thus act slike (map (:[]) . show) (1234), because without the brackets it would mean (map (:[])) . (show 1234), which doesn't typecheck.
08:35:02 <bollu> Bez_: I prefer to a different combinator: let (|>) = flip ($). So, then, it becomes x |> f (take x, chuck it into f)
08:35:14 <Gurkenglas> :t (&)
08:35:15 <lambdabot> a -> (a -> b) -> b
08:35:31 <bollu> Gurkenglas: & doesn't really show flow direction. (|>) does
08:35:55 <Bez_> :t (|>)
08:35:56 <lambdabot> Snoc s s a a => s -> a -> s
08:36:03 <glguy> |> kind of confuses the flow direction, with lazy evaluation in ' f (g (h x)) ', evaluation starts with f
08:36:05 <bollu> Bez_: no, you have to define it
08:36:07 <clrnd> didn't we discuss this exactly like this yesterday? re: infix |>
08:36:20 <bollu> @let (|>) = flip $
08:36:20 <lambdabot>  Parse failed: Parse error in expression: flip $
08:36:27 <bollu> @let (|>) = flip ($)
08:36:28 <lambdabot>  Defined.
08:36:31 <bollu> :t (|>)
08:36:32 <lambdabot>     Ambiguous occurrence ‘|>’
08:36:32 <lambdabot>     It could refer to either ‘L.|>’,
08:36:32 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:147:1
08:36:37 <bollu> egg
08:36:39 <bollu> ehh*
08:36:42 <Bez_> xD
08:36:54 <clrnd> @let (|>) = error "stop it"
08:36:55 <lambdabot>  .L.hs:148:1:
08:36:55 <lambdabot>      Multiple declarations of ‘|>’
08:36:55 <lambdabot>      Declared at: .L.hs:147:1
08:37:05 <clrnd> :P
08:37:11 <bollu> clrnd: :) YOU CAN'T STOP IT ANYMORE.  muHWAHWAHWA
08:37:18 <clrnd> damn it
08:37:25 <bollu> but c'mon people. Love the |>
08:38:16 <Bez_> well thanks guys
08:38:49 <clrnd> bollu, I've already added it to my workshop's repo, it's a cute idea
08:39:00 <bollu> clrnd: yayy! :D
08:39:01 <clrnd> also no $money jokes
08:39:16 <bollu> clrnd: I love showing people (|>) for two reasons 
08:39:20 <clrnd> and also they come form clojure/F# and they have that there
08:39:23 <bollu> 1) defining it involves flip
08:39:38 <bollu> so it brings in the whole "higher order functions are cool" thing
08:39:41 <chreekat> $, |> and & seem to get discussed a lot now. I'm with Chris Done and Gabriel Gonzales though... just use parentheses. :) I feel like they end up being easier to read, refactor, and obviously easier to explain
08:39:45 <bollu> 2) it makes list transformation very natural
08:40:05 <bollu> chreekat: true, but (|>) is a great parlour tick that ($) can't really claim to be
08:40:18 <clrnd> chreekat, this is a follow up of yesterday's discusison which concluded that yeah, using parenthesis for begginners is okay
08:40:18 <bollu> chreekat: or maybe I have stockholm syndrome.
08:40:22 <bollu> I can't tell anymore
08:40:39 <glguy> clrnd: They're for advanced users, too
08:41:01 <chreekat> bollu: I feel ya.. i was about to say "(.) is also a cool trick" but it could also be stockholm syndrome. just because it's "like math composition" doesn't make it better, since composition alwaysfelt backwards to me in math classes
08:41:15 <clrnd> the thing is, my workshop is for super begginners, so I'm going full parenthesis, except for one bit that has to operate on a list, where I'll use |> for a cheap "wow"
08:41:16 <glguy> There's a fascination phase to get through
08:41:39 <clrnd> glguy, not implying it isn't :D
08:42:06 <bollu> clrnd: yeah, I know. "." "seems natural" because we've seen it over and over and over. But.. well, is it "good" notation? idk. I don't think so
08:42:38 <clrnd> I honestly think it comes down to taste, just like in mathematics
08:42:51 <bollu> clrnd: yep. like row v/s column vectors
08:43:05 <bollu> I'm in the row vectors camp if you couldn't tell :)
08:43:10 <clrnd> some authors define their symbols, other reuse existing ones, I would like if all of them followed my personal taste, but adapting is not that complicated
08:43:12 <bollu> vec * op1 * op2 is SOO much saner
08:43:50 <bollu> clrnd: yeah. Although, current notation isn't half-bad :)
08:44:04 <clrnd> yeah, it's not important I guess for getting into a discussion, anyway I sometimes read better edwardk's lens-full programs than my own
08:44:11 <clrnd> :P
08:44:12 <bollu> xD
08:44:33 <bollu> I wish I could encode weird math syntax sometimes. v|v> and stuff would make working with vectors nicer 
08:46:29 <srhb> bollu: Quasiquoters!
08:46:55 <bollu> srhb: what?
08:47:29 <srhb> bollu: You can use QQ to create your own syntax. :)
08:47:34 <bollu> Quasiquoting allows programmers to use custom, domain-specific syntax to construct fragments of their program
08:47:37 <bollu> jaw meet floor
08:47:38 <clrnd> LANGUAGE QuasiQuoters
08:47:44 <bollu> what the FUCK, I can encode group theory
08:47:49 <clrnd> template haskell
08:47:50 <srhb> bollu: Then you'll have [yourQuoter| your syntax goes here]
08:47:52 <bollu> hooooly crap I love haskell
08:48:03 <bollu> whoa, now I have a legit reason to learn TH
08:48:14 <srhb> bollu: "There's an extension for that!"
08:48:16 <srhb> :-)
08:48:16 * clrnd wants to say "it's a LISP thing!" but meh
08:48:18 <bollu> srhb: :)
08:48:32 <bollu> clrnd: well, the LISP way would be have macros act on this, no?
08:48:48 <clrnd> bollu, what do you think QQ are? ;)
08:48:56 <srhb> Yeah, the difference is that they're compile time here.
08:48:56 <bollu> clrnd: fair :)
08:49:38 <bollu> :t Typeable
08:49:39 <lambdabot> Not in scope: data constructor ‘Typeable’
08:49:41 <bollu> :t Data
08:49:42 <lambdabot>     Not in scope: data constructor ‘Data’
08:49:42 <lambdabot>     Perhaps you meant variable ‘cata’ (line 150)
08:49:52 <bollu> :info Typeable
08:49:58 <srhb> bollu: lambdabot doesn't have info.
08:50:22 <bollu> oh
08:50:42 <clrnd> @google Data.Typeable
08:50:43 <lambdabot> https://hackage.haskell.org/package/base/docs/Data-Typeable.html
08:50:47 <clrnd> meh
08:51:03 <bollu> hell, if I can write <r| r^2> and have that parse and generate the group I'll go mad with joy
08:51:16 <bollu> how come no one's encoded group theory in TH?
08:51:44 <clrnd> ¯\_(ツ)_/¯
08:51:53 <bollu> xD
08:52:30 <Bez_> just a stupid question of mine: what do you guys mean with TH?
08:52:33 <bollu> hobby-prog ls
08:52:33 <bollu> clojure-koans           cpp-achilles            hask-continuations      ion                     lovecraft               project-euler
08:52:34 <bollu> codemeet                gen-griz                hask-lisp-interp        jupyter-rust-kernel     mips-learning           template-haskell-groups
08:52:40 <bollu> that tells such a sad story
08:52:48 <srhb> Bez_: Template Haskell.
08:52:53 <Bez_> Ah thx
08:53:00 <srhb> Bez_: It's a meta-programming facility for generating Haskell at compile time.
08:53:17 <Bez_> I'm pretty now to Haskell so I'm sorry for any stupid questions :p
08:53:28 <srhb> Don't be. :) They are welcome in this channel. :)
08:53:52 <Bez_> Ah come on, more to look at, and I don't have that much time 
08:54:12 <srhb> Bez_: Haskell has a very, very deep well of things to look at. :-)
08:54:14 <Bez_> thx then
08:54:22 <magamig> 123 ------ [1,2,3]
08:54:28 <magamig> i have managed to do:
08:54:37 <magamig> 123 ------ ["1","2","3"]
08:54:48 <magamig> but and without being a string
08:54:49 <magamig> ?
08:54:49 <Bez_> srhb: Yeah I found out that already. there was a lecture about lens I visited just recently
08:55:05 <srhb> magamig: You can use read to turn each String back into an Integer
08:55:13 <Bez_> srhb: but it seems to go waaaay deeper than I could have imagined
08:55:17 <srhb> magamig: You'll probably need to annotate some types, since what to read it into may be ambiguous.
08:55:28 <srhb> Bez_: It's nice. Never get bored. :-)
08:55:48 <Bez_> see you later guys
08:56:11 <tulcod> > map (read . (:[])) . show 123
08:56:13 <lambdabot>      Couldn't match type ‘[Char]’ with ‘a -> [Char]’
08:56:13 <lambdabot>      Expected type: a -> [Char]
08:56:13 <lambdabot>        Actual type: String
08:56:36 <tulcod> > map (read . (:[])) . show $ 123
08:56:37 <lambdabot>  [*Exception: Prelude.read: no parse
08:56:44 <tulcod> :(
08:57:11 <magamig> :/ 
08:57:12 <magamig> xD
08:57:20 <magamig> more tips?
08:57:21 <glguy> > [ digitToInt x | x <- show 1234 ]
08:57:22 <lambdabot>  [1,2,3,4]
08:57:49 <srhb> > (map (read . (:[])) . show $ 123) :: Integer
08:57:49 <tulcod> glguy: yeah but that's cheating
08:57:50 <lambdabot>      Couldn't match expected type ‘Integer’ with actual type ‘[b0]’
08:57:50 <lambdabot>      In the expression: (map (read . (: [])) . show $ 123) :: Integer
08:57:52 <glguy> > ($) id . id $ [ digitToInt x | x <- show 1234 ]
08:57:53 <srhb> Oh really.
08:57:53 <lambdabot>  [1,2,3,4]
08:57:55 <glguy> better?
08:58:18 <srhb> Er
08:58:19 <kras> HI, I am passing 0 to a function, but I want to pass 0::Num to it, how do I do that?
08:58:21 <srhb> Forgot the list.
08:58:27 <srhb> kras: Num is not a type. You cannot.
08:58:45 <srhb> kras: You can however pass a Num a => a to it, if it is sufficiently polymorphic.
08:59:04 <kras> this function I have is in "where"
08:59:10 <tulcod> > map (read . (:[])) . show $ 123 :: [Int]
08:59:12 <lambdabot>  [1,2,3]
08:59:13 <byorgey> kras: by default  0  has type   Num a => a   so there's nothing you need to do.
08:59:17 <tulcod> ^ terrible
08:59:36 <kras> ok probably I didn't understand the GHCi warning correctly
08:59:37 <byorgey> kras: perhaps the real problem is that the inferred type of your function is not polymorphic enough?
08:59:37 <magamig> a bit confusing 
08:59:53 <kras> where do I post code snippet?
09:00:00 <kras> sorry new here
09:00:06 <orion> Does cabal automatically disable profiling when invoked as "cabal install"?
09:00:10 <byorgey> kras: no worries.  Try lpaste.net
09:01:05 <tulcod> magamig: but using ints for this is a bit dirty imo. should be able to do it with some arithmetic
09:01:38 <kras> umm it is down for maintenance
09:01:43 <kras> anyways here it is: http://codepad.org/9jPfd1MZ
09:02:56 <kras> GHCi complains that " Defaulting the following constraint(s) to type ‘Integer’"
09:03:35 <kras> then it displays class constaints for Eq, Num and Show
09:03:47 <Fuuzetsu> kras: does not look down to me
09:03:47 <kras> In the expression: showHelper 0 arr
09:04:08 <magamig> tulcod How so?
09:04:23 <tulcod> magamig: err... using strings* for this is a bit dirty imo
09:04:50 <chpatrick> kras: it doesn't know what type those numbers should be
09:04:54 <chpatrick> so it assumes Integer
09:05:05 <tulcod> magamig: the list that's easier to construct from this is 123 -----> [3,2,1]
09:05:06 <kras> yeah right
09:05:15 <kras> how do I remove that warning?
09:05:18 <tulcod> magamig: or actually [3,2,1,0,0,0,0,...]
09:05:25 <chpatrick> kras: give showHelper a type signature
09:05:39 <chpatrick> or write l == (0 :: Int) for example
09:05:48 <kras> if I define this func seperately I would have given the class constarinrs of (Num a, Eq a, Show a)
09:05:56 <kras> how do I do that in where?
09:05:59 <tulcod> let listify n = n `rem` 10 : listify (n quot 10) in listify 123
09:06:01 <tulcod> > let listify n = n `rem` 10 : listify (n quot 10) in listify 123
09:06:03 <lambdabot>      Occurs check: cannot construct the infinite type:
09:06:03 <lambdabot>        t1 ~ (a2 -> a2 -> a2) -> a3 -> t1
09:06:03 <lambdabot>      Relevant bindings include
09:06:06 <geekosaur> same way you would at the top level?
09:06:07 <chpatrick> kras: same as usual, just put it above
09:06:13 <tulcod> let listify n = n `rem` 10 : listify (n `quot` 10) in listify 123
09:06:23 <tulcod> > let listify n = n `rem` 10 : listify (n `quot` 10) in listify 123
09:06:24 <lambdabot>  [3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:07:02 <tulcod> and then you can do some checks to actually truncate that at the last nonzero digit, and then revert it to get what you want
09:09:34 <kras> awesome, this is working http://codepad.org/KV95B5xg
09:09:37 <kras> thanks guys
09:09:55 <kras> I underestimated 'where' :-)
09:10:46 <shiona> > let f 0 = Nothing; f x = Just . swap $ divMod x 10 in unfoldr f 123
09:10:47 <lambdabot>  [3,2,1]
09:13:35 <magamig>  let f 0 = Nothing; f x = Just . swap $ divMod x 10 in unfoldr f 123412
09:13:55 <tulcod> magamig: (prefix >)
09:14:07 <magamig> > let f 0 = Nothing; f x = Just . swap $ divMod x 10 in unfoldr f 123412
09:14:08 <lambdabot>  [2,1,4,3,2,1]
09:14:14 <magamig> oh ok :)
09:14:40 <magamig> reverse $ let f 0 = Nothing; f x = Just . swap $ divMod x 10 in unfoldr f 123412
09:14:45 <shiona> I've used that in quite a few small puzzles
09:14:50 <magamig> > reverse $ let f 0 = Nothing; f x = Just . swap $ divMod x 10 in unfoldr f 123412
09:14:52 <lambdabot>  [1,2,3,4,1,2]
09:19:25 <fr33domlover> bergmark: i sent a patch to haskell-cafe
09:20:17 <ReinH> tulcod: no, you can't do a check to truncate at the last nonzero digit
09:20:29 <tulcod> ReinH: no i mean, during the generation of the list
09:20:29 <ReinH> There is no last nonzero digit
09:21:26 <printline> so, I made a type MyType = Array Int Float, and I want to implement a custom show function for that: instance Show MyType where; show i = "test", but that doesn't work :/ 
09:21:38 <tulcod> ReinH: well, since you're being pedantic, there is a last nonzero digit, you just can't compute where it is
09:21:51 <ReinH> tulcod: no, there isn't.
09:22:19 <printline> "All instance type must be of the form (T t1 .. tn)
09:22:40 <ReinH> I don't think it's pedantic to point out that an infinite list is infinite when it is relevant
09:22:47 <tulcod> ????
09:22:48 <tulcod> nonzero
09:23:50 <ReinH> tulcod: Ok. Yes, there is.
09:26:33 <Fuuzetsu> what is this even
09:26:34 * Fuuzetsu reads up
09:27:20 <Fuuzetsu> ReinH: takeWhile (/= 0) ?
09:28:08 <tulcod> Fuuzetsu: that fails on 101
09:28:18 <Fuuzetsu> I mean on yoru result list
09:36:27 <magamig> I have created a 2-line function that is quicker than the standard "max" function 
09:36:49 <magamig> quicker and uses half of the memory
09:37:12 <magamig> (mine is only for the max between 2 elements)
09:37:21 <printline> so, I made a type MyType = Array Int Float, and I want to implement a custom show function for that: instance Show MyType where; show _ = "test", but that doesn't work, anyone?
09:37:37 <Fuuzetsu> magamig: why not post it to ghc-devs and suggest inclusion? it should get some review that way
09:37:38 <ReinH> :t max
09:37:41 <ReinH> magamig: this function?
09:37:45 <ReinH> :)
09:37:48 <ReinH> er
09:37:51 <lambdabot> Ord a => a -> a -> a
09:37:52 <ReinH> @type max
09:37:53 <lambdabot> Ord a => a -> a -> a
09:37:55 <ReinH> ok thanks lambdabot
09:38:04 <magamig> max2 :: Integer -> Integer -> Integer
09:38:05 <magamig> max2 a b = if a>b then a else b
09:38:17 <Fuuzetsu> @src max
09:38:17 <lambdabot> max x y = if x <= y then y else x
09:38:23 <magamig> I mean... it was just for learning purposes..
09:38:51 <chpatrick> looks the same as the stock one to me
09:39:01 <Fuuzetsu> probably GHC is optimising something differently
09:39:07 <Fuuzetsu> and/or he's timing it wrong ;)
09:39:15 <magamig> i will post it on imgur wait
09:40:03 <ReinH> magamig: how are you benchmarking these functions?
09:40:08 <magamig> if they are the same what is causing this difference
09:40:12 <Fuuzetsu> or maybe his base is not optimised, or many otherthings!
09:40:23 <magamig> i entered ":set +s"
09:40:28 <ReinH> Yeah
09:40:30 <magamig> to measure the time...
09:40:34 <ReinH> That won't be reliable
09:40:45 <magamig> http://i.imgur.com/WMFVA8A.png
09:40:45 <chpatrick> criterion or it didn't happen
09:40:50 <ReinH> you've benchmarking something that takes nanoseconds
09:41:14 <ReinH> With something with, what, hundredth-second accuracy
09:41:22 <magamig> and the memory??
09:41:35 <magamig> ReinH
09:41:46 <joco42_> any idea where this strange error might come from http://pasteboard.co/10pmhtaQ.png ?
09:41:47 <magamig> it is half...
09:41:55 <chpatrick> I don't think max takes 2 megabytes
09:42:01 <ReinH> magamig: I don't believe your result
09:42:10 <camm1> Hi everyone. Do you know how can I get the month from a ZonedTime?  I know I can use something like this: (toGregorian . localDay . zonedTimeToLocalTime) and I get a tuple: (yy, mm, dd). However, the tuple is of type (Integer, Int, Int), and I need the name of the month. 
09:42:20 <begriffs> Is there a way to conditionally import based on GHC version? One of my files won't compile without `import Data.Functor ((<$>))` in GHC 7.8 but in 7.10 this import is redundant. 
09:42:28 <ReinH> You are measuring something, but you are not measuring exactly max
09:42:39 <Fuuzetsu> begriffs: CPP macro
09:42:47 <magamig> Rein H?
09:42:49 <chpatrick> I think CPP would be worse than a redundant import personally
09:43:00 <chpatrick> magamig: I think it's measurement error
09:43:12 <Fuuzetsu> yes, I would not bother with CPP if only thing you have is redundant import
09:43:16 <chpatrick> http://hackage.haskell.org/package/criterion <- if you benchmark it with this I'll believe you
09:43:19 <ReinH> I am not sure exactly what :set +s is measuring, but there is no way that result is accurate for evaluating max
09:43:40 <Hafydd> Ah, great, a piece of software by someone who spells their name with an @. This should be good.
09:43:55 <Fuuzetsu> Hafydd: what software?
09:43:59 <chpatrick> wat
09:44:01 <ReinH> Which takes on the order of nanoseconds and bytes, not hundredth-seconds and megabytes
09:44:08 <magamig> chpatrick will try it
09:44:09 <Cale> camm1: As a String? You should use  formatTime defaultTimeLocale "%m" zt
09:44:14 <Hafydd> Fuuzetsu: http://pasteboard.co/
09:44:14 <joco42_> here is another snapshot http://pasteboard.co/10pxlqtd.png
09:44:21 <begriffs> Fuuzetsu: chpatrick: k, thanks for the tips
09:44:48 <Cale> er, sorry, detp
09:45:04 <Cale> %B
09:45:07 <Fuuzetsu> Hafydd: isn't that a link to his twitter
09:45:11 <camm1> Thanks Cale
09:45:11 <Cale> not %m
09:45:16 <camm1> I'll try it.
09:45:20 <Jinxit> Hafydd: how is having a twitter account an indicator of software quality?
09:45:27 <Cale> %b if you want the short form of the month name, like Jan
09:45:33 <Fuuzetsu> Hafydd: I love how there is no ‘upload’ button…
09:45:47 <Hafydd> Jinxit: it isn't, but spelling your name with an @ is an indicator of being an arsehole.
09:45:56 <Jinxit> what
09:46:04 <joco42_> strange is that this compiles http://pasteboard.co/10pF2LDy.png
09:46:11 <Jinxit> it's a way of getting in touch with the developer
09:46:17 <Jinxit> do you also hate email?
09:46:30 <Hafydd> Ah, yes, Twitter is the perfect medium with which to discuss software.
09:46:38 <Hafydd> No, only Twitter.
09:46:40 <chpatrick> would you be offended if it said by hafydd@hotmail.co.uk?
09:46:56 <Hafydd> chpatrick: considering the "hotmail" part, yes.
09:47:05 <Jinxit> I think "yo there's no upload button on pasteboard" fits into 140
09:47:06 <geekosaur> and because everyone who matters is obviously on twitter
09:47:20 <joco42_> and this compiles too http://pasteboard.co/10pKed0I.png
09:47:39 <joco42_> but if i try to combine the two... then it does not compile ... strange...
09:47:59 <ReinH> Jinxit, Hafydd: so does "How can I contact you with a question about pasteboard".
09:48:02 <joco42_> i cannot really figure out this mystery
09:48:44 <Hafydd> ReinH: that's a bit indirect, wouldn't you think? Why not link to a ticket management system like GitHub?
09:49:11 <ReinH> Hafydd: True, but I don't think including your twitter makes it *worse* than not including it. Anyway, this is off topic.
09:49:22 <Hafydd> That's where we disagree, then.
09:50:17 <bollu> joco42: why no love for powerline fonts? you're clearly using vim-airline anyway!
09:50:56 <joco42_> bollu: yeah...
09:51:05 <joco42_> i should set it up soon :)
09:51:18 <pixelfog>  From ghci, there are commands like "import Data.Char" and ":load myfile.hs", which retrieve code from somewhere on disk, and load them into your ghci session. If you have a combination of operating system packages and cabal and stack on your computer, it can be unclear where ghci is getting these files. Is there a way to ask ghci what the full path is of a module it has loaded?
09:52:05 <joco42_> i just try -XNoMonomorphismRestriction and see if it helps... no idea what it does ...
09:52:58 <ReinH> pixelfog: not afaik
09:53:40 <geekosaur> why are those images
09:54:58 <jle`> Hafydd: i'm going to give my children names with @'s in front of them
09:55:01 <jle`> like any decent modern parent
09:55:24 <Jinxit> "what do you mean you haven't reserved twitter handles for your children?"
09:55:41 <Hafydd> jle`: here are some ideas: http://4.bp.blogspot.com/-PfB-r3f7ejk/TyWiVMFaejI/AAAAAAAAC78/wu32a70AeXI/s1600/015.JPG
09:55:43 <hexagoxel> pixelfog: `:show modules` does contain that information.
09:56:02 <Cale> Try :set -v
09:56:40 <joco42_> holy cow
09:56:44 <joco42_> it was the NoMonomorphismRestriction
09:56:52 <hexagoxel> pixelfog: oh, sorry, disregard that
09:56:58 <joco42_> somebody tell me how did i know this :)
09:57:08 <joco42_> coz i really have no idea...
09:57:49 <jle`> half of the haskell questions on stack overflow are due to the monomorphism restriction
09:57:54 <Hafydd> When the monomorphism restriction bites you, you learn to consider it.
09:57:58 * hackagebot diagrams-lib 1.3.0.6 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.0.6 (BrentYorgey)
09:58:06 <Hafydd> A good first point of context is the Haskell Report, where it's defined.
09:58:19 <joco42_> no compiler warning... nothing
09:58:26 <joco42_> just something really strange...
09:58:29 <jle`> it's generally not advised to actually use NoMonomorphismRestriction in your source code, though
09:58:44 <joco42_> something that should be polymorphic is not polymorphic...
09:58:46 <jle`> giving explicit type signatures would make it go away
09:58:58 <joco42_> aham...
09:59:04 <srhb> joco42_: That is what the MonomorphismRestriction does, after all.
09:59:04 <jle`> joco42_: it's defined/expected behavior, and it's for performance benefits
09:59:10 <Hafydd> joco42_: it's part of the language, so it's reasonable to assume that a programmer knows the language.
09:59:14 <jle`> it's just not typically taught when haskell is taught, though
09:59:24 <jle`> so it ends up surprising a lot of people
09:59:37 <joco42_> yeah... nobody tought me about it
09:59:47 <jle`> but yeah, you shouldn't ever really need to disable the monomorphism restriction in your code...adding explicit type signatures is ok, too
09:59:54 <joco42_> like lyhfgg
10:00:04 <joco42_> well
10:00:06 <joco42_> yeahh
10:00:12 <joco42_> i need to figure it out how to do tha
10:00:13 <joco42_> t
10:00:24 <Hafydd> It's a good idea to put a signature for all top-level bindings (except main), anyway, for readability at the very least.
10:00:27 <jle`> joco42_: just add a type signature to your polymorphic thing, and GHC would use it
10:00:35 <Fuuzetsu> why except main?
10:00:36 <jle`> and not auto monomorphisize it
10:01:00 <Hafydd> Fuuzetsu: the type of main is always (effectively) IO ().
10:01:09 <Fuuzetsu> amain :: IO a works
10:01:12 <jle`> actually you can accidentally give a main that is IO anything
10:01:14 <Fuuzetsu> main :: IO a
10:01:14 <joco42_> jle`: but where ? when i call it ?
10:01:19 <jle`> joco42_: when you declare it
10:01:43 <jle`> having main :: IO () means that the compiler will stop you if you accidentally give an IO Int or something
10:02:00 <Hafydd> Hmm... perhaps.
10:02:04 <Fuuzetsu> :)
10:02:07 <jle`> also hlint warns me
10:02:08 <Hafydd> But you might often want to do that, anyway.
10:02:27 <jle`> you might...in which case, it might be nice to have main :: IO Int to let people/yourself know you know what you're doing
10:02:44 <dolio> Clearly you should have `main :: IO Void`.
10:02:46 <srhb> IO a is useful for avoiding that one extra layer of indirection in a simple repl.
10:02:49 <srhb> :-)
10:02:50 <Hafydd> Heh.
10:02:55 <dolio> If not, you must not be calling exitSuccess.
10:02:58 * hackagebot diagrams-cairo 1.3.0.5 - Cairo backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-cairo-1.3.0.5 (BrentYorgey)
10:03:08 <joco42_> jle`: http://pasteboard.co/10pKed0I.png here Transformable can be scaled and translated
10:03:15 <jle`> dolio: is it too late to add that to ghc 8.0?
10:03:24 <dolio> Add what?
10:03:30 <jle`> main :: IO Void
10:03:38 <joco42_> jle`: in the instance declarations ?
10:03:47 <jle`> then people coming from C will be right at home
10:04:01 <srhb> Just like with return :: a -> m a !
10:04:09 <srhb> >_>
10:04:20 <jle`> joco42_: where is your error?
10:05:21 <joco42_> jle`: if i uncomment line 54 in Svg/IO.hs
10:05:27 <dolio> jle`: I think it's too late for you to convince enough people that it should be required.
10:05:54 <dolio> It probably wouldn't be that hard to change.
10:05:56 <jle`> joco42_: let nt :: Transformable c => c -> c
10:06:07 <jle`> joco42_:     nt = getNormalizingTransformation fi
10:06:30 <benzrf> without warmup, any kind of execution of ghc or ghci at all incurs like 3 seconds of hanging
10:06:35 <jle`> the problem with how it is now is that it's nt = (getNormalizingTransformation fi :: Transformable c => c -> c), which doesn't tell anything new to the compiler.
10:06:48 <joco42_> jle`: interesting
10:06:50 <joco42_> i try that
10:06:52 <jle`> it'll bind that polymorphic value to `nt`, which it will make monomorphic
10:07:58 * hackagebot diagrams-html5 1.3.0.4 - HTML5 canvas backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-html5-1.3.0.4 (BrentYorgey)
10:08:00 * hackagebot uniform-pair 0.1.9 - Uniform pairs with class instances  https://hackage.haskell.org/package/uniform-pair-0.1.9 (ConalElliott)
10:08:02 * hackagebot hgrev 0.1.4 - Compile Mercurial (hg) version info into Haskell code  https://hackage.haskell.org/package/hgrev-0.1.4 (LukeHoersten)
10:08:04 * hackagebot diagrams-pgf 0.1.0.3 - PGF backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-pgf-0.1.0.3 (BrentYorgey)
10:08:32 <joco42_> jle`: it worked ! yeah !
10:08:37 <joco42_> jle`: thanks
10:08:42 <jle`> i have heard some people argue that it's better to turn DMR off and then manually annotate your monomorphic cases
10:08:52 <joco42_> i've leard something new today :)
10:08:55 <joco42_> thanks
10:08:59 <jle`> but i feel like that has a lot of potential to silently give you headaches and unexpected behavior
10:09:11 <jle`> whereas leaving it on and annotating polymorphism will always fail noisly
10:09:12 <bollu1> can someone tell me how I can kill my old session?
10:09:13 <jle`> joco42_: np!
10:09:19 <bollu1> I lost power for a while and now idk what to do
10:09:36 <voidzero> bollu1, wait it out
10:10:06 <Fuuzetsu> release it if you are registered
10:10:11 <Fuuzetsu> message nickserv for help
10:10:15 <bollu1> Fuuzetsu: oh, ty
10:10:48 <bollu> yayy!
10:10:51 <bollu> thanks guys :)
10:11:14 <eikke> little thought exercise: which of these 2 functions is the 'fastest'? (check README afterwards and try for yourself): https://gist.github.com/NicolasT/02a5f3b9280f4048ccbd#file-xorme-hs
10:12:58 * hackagebot diagrams-rasterific 1.3.1.5 - Rasterific backend for diagrams.  https://hackage.haskell.org/package/diagrams-rasterific-1.3.1.5 (BrentYorgey)
10:15:39 <exio4> eikke: maybe first? I would say this depends a lot on ghc version, and what you do with every function? and which optimizations fired, which is a hard question
10:16:30 <eikke> exio4: 7.10.something, whatever stackage lts now ships. benchmark is passing a 3*1MB vector to the function (its contained in the gist)
10:17:10 <eikke> exio4: it's all about optimizations, of course. though the difference (on my system) is huge (4-5x)
10:17:59 * hackagebot diagrams-svg 1.3.1.6 - SVG backend for diagrams drawing EDSL.  https://hackage.haskell.org/package/diagrams-svg-1.3.1.6 (BrentYorgey)
10:18:01 * hackagebot cgrep 6.5.6 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.6 (NicolaBonelli)
10:18:09 <eikke> exio4: basically, it's an example which shows that high-level is not necessarily worse performing than more-low-level. I first wrote the zipWith version, then figured the other might improve upon that, but was happily surprised
10:20:12 <NeverDie> I'm debating at the moment whether to learn Haskell or Lisp. Could anyone help me sway either way?
10:20:28 <hodapp> learn both
10:20:45 <eikke> learn haskell and write a lisp interpreter ;)
10:20:47 <srhb> NeverDie: This channel is really good at convincing you to learn Haskell, usually. :-)
10:20:47 <hodapp> what languages do you currently know?
10:21:07 <ew0> hello world
10:21:12 <srhb> Hello.
10:21:12 <NeverDie> I only know JavaScript (I know) ):
10:21:20 <ew0> any advice on how to reinstall everything with profile support?
10:21:37 <ew0> can stack do it?
10:21:40 <hodapp> well, Lisp is closer to JavaScript than either to Haskell
10:21:45 <srhb> NeverDie: Well, either experience will be vastly different from what you've tried, then. But Haskell introduces you to a very strong type system. This will not be the case for most (any?) lisps.
10:22:05 <NeverDie> srhb: Yeah that's what I've read so far.
10:22:25 <NeverDie> But then again I just came across this article by Paul Graham praising the power of macros, so it's made me indecisive as to which I should pick first.
10:22:34 <srhb> Macros are pretty cool.
10:22:36 <NeverDie> I do want to learn both, I'm just debating which I should devote my time to first.
10:22:59 * hackagebot amazonka 1.3.2.1 - Comprehensive Amazon Web Services SDK.  https://hackage.haskell.org/package/amazonka-1.3.2.1 (BrendanHay)
10:23:11 <NeverDie> srhb: How come?
10:23:17 <srhb> NeverDie: How come they're cool?
10:23:33 <NeverDie> srhb: Yeah, could you please elaborate?
10:24:14 <srhb> NeverDie: Not particularly. I only really use an emacs lisp, and rarely have to write macros. I probably don't use their full power, but grab at them when I need to metaprogramming ability.
10:24:33 <srhb> NeverDie: But I suppose metaprogramming is the answer :)
10:24:38 <Fuuzetsu> which is not that often if you have a powerful language in the first place…
10:25:02 <srhb> Indeed.
10:25:26 <srhb> NeverDie: But as I hinted at, I obviously prefer Haskell for basically everything. Especially because I get a really great type system.
10:25:40 <srhb> Not having one feels almost crippling now.
10:25:52 <info_is_good> How can I add an inline pragma to a function inside a let? "(let foo a b = a + b in ... I want foo to be inlined when called here ...)" 
10:26:00 <Fuuzetsu> I don't want to language bash but I really don't want to badly implement features in untyped language for each prograam when I can already use those well-tried features in Haskell or whatever…
10:26:11 <albertus1> Is there, after all, a difference between accomplishing something via meta-programming and via features of a strong language? isn't a macro preprocessor or something "equivalent" as long as the result is the same? :-)
10:26:32 <srhb> I suppose so. The amount of hoops you have to jump through may be different though.
10:26:39 <Fuuzetsu> albertus1: the difference is that in one of those you don't waste your time re-implementing the stuff
10:28:34 <youngwolf>  
10:31:52 <frerich> albertus1: The 'result' is not the executable program though, it's the source code - which is also subject to metrics such as 'maintainability'.
10:33:04 <homesitter> hi
10:33:07 <srhb> homesitter: Hi.
10:33:34 <homesitter> this is the wrong channel, but the guys in #physics are non-talkative
10:34:05 <homesitter> interested in my theory, haskellers might be interested
10:34:06 <srhb> There's various off-topic channels, like #haskell-blah, if you need them.
10:34:13 <homesitter> cool
10:43:13 <root> hi
10:49:59 <ReinH> alpounet: All turing complete languages are "equivalent", which isn't a very useful property for humans.
10:50:14 <ReinH> I wouldn't want to write my programs in brainfuck.
10:51:08 <clrnd> most people would though, re: nodejs
10:52:38 <printline> weird, I have a data type MyType with two fields; however
10:53:00 * hackagebot aeson-extra 0.2.0.0 - Extra goodies for aeson  https://hackage.haskell.org/package/aeson-extra-0.2.0.0 (phadej)
10:53:20 <printline> I somehow can't match it this way: foo :: MyType -> Int; foo _ _ = 1
10:53:40 <Fuuzetsu> printline: why is that weird at all?
10:53:54 <printline> Fuuzetsu: how can I match it then?
10:54:01 <Fuuzetsu> you match on the constructor
10:54:08 <printline> Fuuzetsu: ooooh
10:54:09 <Fuuzetsu> foo (MyTypeConstructor _ _) = …
10:55:32 <Fuuzetsu> or just ‘foo _ = 1’ if you don't care for it
10:55:56 <printline> I see, thanks
11:03:16 <akegalj> example from RWH http://book.realworldhaskell.org/read/profiling-and-optimization.html is showing `mean xs = sum xs / fromIntegral (length xs)` example. It says that GHC is summing values and keeping evaluated xs in memory so that length can compute it's length. This couses leak. Can we somehow order evaluation in a way "Compute length first. (evaluating only spine of a list) Second, compute sum."
11:03:49 <akegalj> This way values of xs wont be held in memory. Can I somehow order these two operations?
11:04:38 <akegalj> in a way: let n = length xs in n `seq` sum xs / n ?
11:04:54 <Gurkenglas> Wouldn't it be even better to sum the xs and count the length in a single pass?
11:05:27 <akegalj> Gurkenglas: yes, RWH does exactly that. But its kind of too low level
11:05:49 <akegalj> I would like to stay high enough in apstraction
11:06:26 <akegalj> Gurkenglas: and that doesn't compose at all. I have to reimplement sum and length functionality on my own
11:06:59 <Gurkenglas> exactly that would be... import numinstances, then do uncurry (/) . sum . map (,1)
11:08:01 * hackagebot android 0.0.1 - Android methods exposed to Haskell  https://hackage.haskell.org/package/android-0.0.1 (IvanPerez)
11:08:24 <akegalj> Gurkenglas: oh, I didn't think of that one. Its more elegant then what RWH gives as solution
11:08:44 <Feuerbach> is it possible to splice TH-generated declarations in ghci?
11:12:42 <Fuuzetsu> Feuerbach: did you try and see?
11:13:27 <Feuerbach> Fuuzetsu: I tried $(foo), but it gives a type error because it expects an ExpQ
11:13:47 <Feuerbach> perhaps there's some alternative syntax to make it accept [DecQ]
11:16:26 <Fuuzetsu> oh, now I see what your problem is
11:16:49 <ReinH> akegalj: For a cool generic approach, see https://hackage.haskell.org/package/foldl-1.1.2/docs/Control-Foldl.html
11:17:03 <Fuuzetsu> I don't think you can do what you want
11:17:35 <Fuuzetsu> your best try is probably doing something with LetE and getting an Exp that way
11:18:01 * hackagebot csound-expression-dynamic 0.1.5 - dynamic core for csound-expression library  https://hackage.haskell.org/package/csound-expression-dynamic-0.1.5 (AntonKholomiov)
11:18:27 * geekosaur wonders if that can work without a ghci redesign...
11:18:54 <geekosaur> the "let" in ghci is not the "let" in haskell
11:19:12 <Feuerbach> well, ghci accepts all sorts of declarations
11:19:52 <Feuerbach> and it certainly accepts statements, but I can't even use LetS because of the same issue
11:20:49 <Fuuzetsu> geekosaur: so would something like $(foo >>= \ds -> LetE ds (Var $ mkName "varFromDs")) not work?
11:21:23 <Fuuzetsu> VarE*
11:22:29 <geekosaur> can try it, but I am under the impression "let" in ghci acts more like a ghci-specific command rather than something that you could splice TH-generated bindings into directly
11:23:02 * hackagebot csound-expression-typed 0.0.8 - typed core for the library csound-expression  https://hackage.haskell.org/package/csound-expression-typed-0.0.8 (AntonKholomiov)
11:23:04 * hackagebot csound-expression 4.8.4 - library to make electronic music  https://hackage.haskell.org/package/csound-expression-4.8.4 (AntonKholomiov)
11:25:09 <Fuuzetsu> Prelude Language.Haskell.TH> $(sequence foo >>= \ds -> return $ LetE ds (VarE $ mkName "pi"))
11:25:09 <Fuuzetsu> 3.141592653589793
11:25:17 <Fuuzetsu> where foo = []
11:26:10 <akegalj> ReinH: thanks, I'll look into it
11:26:34 <ew0> so I'm trying to put a State Monad inside a StateT
11:26:41 <ew0> any hints?
11:27:05 <akegalj> Rw
11:27:17 <ew0> type SimpleState a = State [Int] a
11:27:27 <Fuuzetsu> Prelude Language.Haskell.TH> let foo :: [DecQ]; foo = [return $ ValD (VarP (mkName "test")) (NormalB (LitE (IntegerL 7))) []]
11:27:27 <Fuuzetsu> Prelude Language.Haskell.TH> $(sequence foo >>= \ds -> return $ LetE ds (VarE $ mkName "test"))
11:27:27 <Fuuzetsu> 7
11:27:28 <Cale> Fuuzetsu: $(return $ LetE [] (VarE $ mkName "pi")) would be simpler
11:27:29 <akegalj> ReinH: yes, that looks ok from Control.Foldl
11:27:40 <ew0> type ComplexState a = StateT Int SimpleState a
11:27:42 <ew0> won't compile
11:27:59 <ew0> The second argument of ‘StateT’ should have kind ‘* -> *’
11:28:01 <Cale> Oh, I guess it was just an example anyway :P
11:28:04 <Fuuzetsu> Cale: right, but I wanted to see if I can use bind inside too etc.
11:28:37 <Fuuzetsu> geekosaur: so it seems you can do it in GHCi
11:29:02 <Fuuzetsu> I mean I don't think it really matters, in the end it just spits out text and if it happens to look good to GHCi then it works, no?
11:32:11 <Feuerbach> of course (if by "text" you mean AST)
11:39:11 <akegalj> Gurkenglas: that solution of yours: import numinstances, then do uncurry (/) . sum . map (,1) . How can I force stricness here? Sum seems to be too lazy here (probably because of tuple constructor)
11:39:44 <Gurkenglas> Hmm. define your own num instance for tuples? :/
11:40:52 <akegalj> Gurkenglas: yes, I was going to. I cannot somehow do it outsite?   like  uncury (/) . (\(!a,!b) -> sum (a,b)) . map (,1) ?
11:41:23 <akegalj> s/outsite/outside
11:41:40 <Gurkenglas> (or, like, replace sum with foldl' (\(x, a) y -> let s = x + y, b = a + 1 in seq s $ seq b (s, b))
11:41:50 <Gurkenglas> *)
11:43:12 <akegalj> Gurkenglas: yes, thats what I was looking for (that example of mine doesn't make sense at all, cause sum will be lazy with tuples)
11:43:17 <akegalj> Gurkenglas: thanks
11:47:20 <athan> > data Please = Don'tDoThis
11:47:20 <lambdabot>  <hint>:1:1: parse error on input ‘data’
11:47:27 <athan> :o?
11:47:38 <Gurkenglas> @let data Please = Don'tDoThis
11:47:39 <lambdabot>  Defined.
11:47:45 <athan> thanks Gurkenglas
11:47:59 <athan> @unset
11:47:59 <lambdabot> Unknown command, try @list
11:48:02 <athan> :|
11:48:04 <Gurkenglas> @undefine
11:48:05 <lambdabot> Undefined.
11:48:06 <Gurkenglas> lololo
11:55:00 <Valectar> Hello, I have a Haskell question I could use some help with.
11:55:12 <kaidelong> don't ask to ask, ask
11:56:41 <Valectar> Alright, I'm getting an error I'm having trouble with in this code:
11:56:42 <Valectar> http://pastebin.com/REkb3S41
11:56:53 <Valectar> The error is at the end of the paste bin.
11:57:48 <Valectar> I think I'm misunderstanding something about do notation, but I'm not exactly sure what it is.
11:57:50 <Cale> Valectar: initPermutation is a number
11:58:05 <Cale> Valectar: it's selected as one of the elements of the list [3,5,2,...]
11:58:32 <Cale> and since you're executing a list as an action in your do-block, the entire do-expression is itself a list
11:58:35 <Cale> (not a pair)
11:58:42 <kaidelong> well there's another problem still, the type of that do block is inferred to be ([Bool], [Bool])
11:59:09 <kaidelong> but it looks like it is intended to be [(Bool,Bool)]
11:59:15 <lpaste> glguy pasted “for valectar” at http://lpaste.net/141945
11:59:29 <glguy> do notation is different than normal where and let for binding variables
11:59:29 <Cale> It's specified to be ([Bool],[Bool]), while it's inferred to be [[Int]]
11:59:57 <glguy> you can't use them interchangably because they don't mean the same thing
11:59:58 <Valectar> It's intended to return a pair of lists of bools, which are two sub keys in an SDES implementation.
12:00:06 <NeverDie> Could anyone take a look at this please? http://ideone.com/5kcIWA
12:00:17 <NeverDie> It's not running and I can't wrap my head around it.
12:00:35 <Cale> Valectar: In general, inside a do-block, if you write  v <- x  it means "execute the action x, and call its result v". If x :: M t, then v :: t
12:00:57 <Cale> Valectar: When M t = [t], "executing" the list x means selecting an element from it in all possible ways.
12:01:09 <Valectar> Ah, that would explain my problems.
12:01:30 <geekosaur> NeverDie, define "not running"
12:01:32 <Cale> Valectar: The do-block as a whole will have some type M s for some s (the type of the do-block will match the type of the last line)
12:01:37 <kaidelong> '
12:01:41 <NeverDie> geekosaur: It's not running at all lol.
12:01:55 <NeverDie> I saved it in a file and did runhaskell file.hs 
12:02:00 <geekosaur> well, ideone is clearly trying to run it but as you did not give it any stdin it is failing
12:02:19 <Valectar> I suppose it still executes the list when I set tmp to the result of a permute call?
12:02:22 <kaidelong> yes, we can see it printing to STDOUT in the paste you gave
12:02:29 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7]; return (x,y,z)
12:02:31 <lambdabot>  [(1,4,6),(1,4,7),(1,5,6),(1,5,7),(2,4,6),(2,4,7),(2,5,6),(2,5,7),(3,4,6),(3,...
12:03:06 <Cale> You probably just want to use let or where like glguy's code suggests
12:03:21 <Cale> let initPermutation = [3, 5, 2, 7, 4, 10, 1, 9, 8, 6]
12:03:30 <Cale>     tmp = permute key initPermutation
12:03:35 <Cale> etc. etc.
12:03:40 <NeverDie> geekosaur: I mean it's not running on my computer.
12:03:40 <Cale>  in (k1, k2)
12:03:51 <Valectar> Yeah, that would prevent the intermediate results from changing the type of the do block.
12:04:01 <Cale> Valectar: Well, there would be no do-block
12:04:13 <geekosaur> NeverDie, it seems to work here
12:04:13 <Cale> You don't really intend to use the list monad instance here
12:04:19 <Cale> (it seems, at least)
12:04:23 <NeverDie> geekosaur: Work where?
12:04:33 <Valectar> Would I need successively embedded lets or could some of the bindings reference previous bindings of the let block?
12:04:36 <geekosaur> make sure your runhaskell is the one you expect and is pointing to the right place (it may be a symlink)?
12:04:52 <Cale> A single let can define as many things as you want
12:05:02 <Cale> You just have to make sure all the definitions start in the same column
12:05:14 <Valectar> Yes, but can definitions reference previous definitions?
12:05:21 <geekosaur> I downloaded the source, inspected it, did "runhaskell ideone_5kcIWA.hs" (that being how it downloaded), asked it to generate two 14-character passwords
12:05:22 <Valectar> And possibly override them?
12:05:25 <geekosaur> it did
12:05:30 <printline> can I somehow tell which function gets executed when I call sum on an Array?
12:05:57 <nullx002> is there a good book for detailed lambda calculus study?
12:05:58 <NeverDie> geekosaur: Hmm, weird.
12:06:01 <albertus1> @src sum
12:06:01 <lambdabot> sum = foldl (+) 0
12:06:16 <Valectar> Or are the definitions in an undefined order?
12:06:22 <Cale> Valectar: They can reference all definitions in the let
12:06:31 <Cale> You can write mutually recursive definitions even
12:06:31 <dmj`> @package lcs
12:06:33 <lambdabot> http://hackage.haskell.org/package/lcs
12:06:33 <NeverDie> geekosaur: I get Could not find module ‘System.Random’
12:07:01 <printline> albertus1: thx.
12:07:09 <Valectar> Ok, I can rename / collapse things to avoid unintentional recursion.
12:07:16 <Cale> yeah
12:07:42 <Cale> Looking at this, there's some confusing stuff, like where you bind k1 twice in a row in independent ways...
12:08:24 <Cale> Maybe you intended to permute the previous k1 instead of key
12:08:25 <Valectar> Yeah, that wasn't meant to be independent, used key instead of k1.
12:08:29 <Cale> yeah
12:09:39 <lpaste> Cale pasted “so like this” at http://lpaste.net/141946
12:09:50 <Cale> oops
12:10:00 <lpaste> Cale revised “so like this”: “No title” at http://lpaste.net/141946
12:10:04 <Cale> there :)
12:10:11 <Cale> (I'd left in some arrows)
12:10:52 <kaidelong> NeverDie: that would be part of base. Either you have a cabalized project and you didn't explicitly depend on base, or something is very broken in your haskell install
12:11:13 <kaidelong> but cabal init should have set up your base dependency for you
12:11:16 <Valectar> Ok, now I just need to rewrite the rest of my functions to use let instead of do.
12:11:17 <kaidelong> so I'm going to lean to the latter
12:11:23 <Valectar> Thanks for the help Cale!
12:13:49 <printline> can I get the current index in a fold?
12:14:09 <Jinxit> you can keep track of it in your accumulator
12:14:20 <printline> Jinxit: in a tuple?
12:14:42 <Jinxit> yes
12:14:58 <printline> isn't this a common thing to do that one would expect it to be in prelude?
12:15:18 <nullx002> take 30 ( map (flip showIntAtBase 2 intToDigit"") [1..])
12:15:24 <nullx002> not working
12:15:45 <nullx002> while take 30 ( map (flip showOct "") [1..]) works well
12:16:17 <jle`> printline: not quite too common actually, but another thing you can do is zip with [0..]
12:16:25 <dmj`> jle`: +1
12:16:32 <jle`> > zip [0..] "hello world"
12:16:34 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o'),(5,' '),(6,'w'),(7,'o'),(8,'r'),(9,...
12:16:57 <nullx002> take 30 ( map (flip showOct "") [1..])
12:17:29 <printline> jle`: oh right, good idea
12:21:26 <dmj`> zipWith vulcanMindMeld jle` dmj` 
12:22:25 <jle`> i am not a list :o
12:22:49 <bitemyapp> jle`: you are the product of your parts.
12:26:44 <dmj`> let jle` = jleThoughts in jle` $$ dmj`
12:36:14 <athan> How would I go about making a `Word32 -> (Word8,Word8,Word8,Word8)` function? :s
12:36:50 <dolio> Shift, mask, fromIntegral.
12:37:04 <athan> ! thank you dolio
12:37:44 <ralu> is there any webframework for haskell that crosscompiles?
12:40:11 <athan> lolwut?
12:47:07 <Ankhers> ralu: I'm going to assume you are asking if any of them CAN be cross compiled. 
12:47:07 <ralu> yes
12:47:07 <ralu> so it should compile with stage1 compiler
12:47:07 <ReinH> dolio: (I guess masking is optional since fromIntegral will truncate for you)
12:47:08 <ReinH> Also I think there's a bytes traversal in lens if you're into that sort of thing
12:47:08 <Ankhers> ralu: If I'm not mistaken, TH doesn't work with stage 1 compilers right now. So that rules out Yesod. I'm not sure about any of the other ones.
12:47:08 <dolio> ReinH: Yeah, I guess.
12:47:08 <ralu> i have tried 4 of them
12:47:08 <ralu> snap, yesod,  happstack-lite
12:47:09 <ralu> i should probably set up qemu for building 
12:47:09 <ralu> bat that is horribly slow
12:52:46 <orion> I am doing some debugging, and when I print a WAI Request, the body reads: 
12:52:50 <orion> requestBody = <IO ByteString>
12:53:11 <orion> Is there a way to do a "deep" print so that the requestBody can be contained in the output as well?
12:53:19 <athan> orion: Check out strictRequestBody
12:53:25 <athan> er yeah
13:01:14 <printline> is there a better way to create a string of hash characters of a certain length than this? foldl (\s _ -> s ++ "#") "" [1..n] 
13:01:41 <Ankhers> > take 5 $ repeat '#'
13:01:42 <tommd> printline: How about 'replicate'?
13:01:42 <lambdabot>  "#####"
13:01:44 <dmj`> > replicate 5 '#' 
13:01:45 <lambdabot>  "#####"
13:01:51 <Ankhers> replicate. That's the one.
13:02:01 <printline> ah :)
13:02:16 <lemevi> is there a list operation that sums all nums in a list or do I just fold
13:02:28 <lemevi> looks like fold (+) list is what I need
13:02:55 <Ankhers> >sum [1,2,3]
13:03:00 <Ankhers> > sum [1,2,3]
13:03:01 <lambdabot>  6
13:03:06 * hackagebot turing 0.1.0 - A simple simulator for Turing machines  https://hackage.haskell.org/package/turing-0.1.0 (SebastianPoeplau)
13:03:33 <lemevi> oh
13:03:39 <lemevi> ty
13:04:21 <jle`> > '#' <$ [1..5] -- printline 
13:04:23 <lambdabot>  "#####"
13:04:26 <tommd> The better way to do this is `getSum . mconcat . map Sum`
13:05:14 <Gurkenglas> :t [getSum . mconcat . map Sum, ala Sum foldMap]
13:05:16 <lambdabot> Num b => [[b] -> b]
13:05:32 <jle`> mconcat . map f = foldMap f
13:05:59 <Gurkenglas> mconcat = fold anyway, and fold is more general
13:05:59 <lemevi> that's better than sum? I haven't made it to monads yet
13:06:12 <jle`> i'm pretty sure `sum` is preferred in almost every situation...
13:06:13 <tommd> lemevi: I'm joking around, `sum` is fine.
13:06:28 <jle`> lemevi: also, this is unrelated to monads :D
13:06:38 <lemevi> yeah I'm still very ignorant
13:06:42 <tommd> Now monoids, those are where it's at.
13:06:45 <lemevi> but haskell is so different, it's fun
13:07:13 <jle`> :D
13:08:24 <jle`> :t length . concatMap replicate
13:08:25 <lambdabot>     Couldn't match type ‘a1 -> [a1]’ with ‘[a0]’
13:08:25 <lambdabot>     Expected type: Int -> [a0]
13:08:25 <lambdabot>       Actual type: Int -> a1 -> [a1]
13:09:02 <Ankhers> :t concatMap
13:09:03 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
13:09:28 <jle`> :t length . concatMap (`replicate` ())
13:09:29 <lambdabot> Foldable t => t Int -> Int
13:10:13 <Ankhers> :t length . concatMap . flip replicate ()
13:10:14 <lambdabot>     Couldn't match type ‘[()]’ with ‘a0 -> [b0]’
13:10:14 <lambdabot>     Expected type: Int -> () -> a0 -> [b0]
13:10:14 <lambdabot>       Actual type: Int -> () -> [()]
13:10:25 <nullx002> > sum [1,2,3
13:10:27 <lambdabot>  <hint>:1:11:
13:10:27 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:10:38 <nullx002> > sum [1,2,3]
13:10:39 <lambdabot>  6
13:21:22 <greg> anyone use gloss? specifically can anyone tell me why when i render an animation its sooooo slow?
13:22:24 <lemevi> alright guys, this is my first haskell code ever, first solution for hw1 csi194: https://gist.github.com/btipling/4742be1a794fec5c6a8c
13:22:28 <lemevi> it works!
13:22:47 <lemevi> I put in my cc number into isValidCCNum and it worked and it doesn't work for invalid numbers :)
13:22:58 <jle`> congrats :)
13:23:02 <lemevi> :D
13:23:07 <lemevi> haskell is pretty sweet
13:23:42 <jle`> it's the best :o
13:23:46 <lemevi> I'm probably doing stuff wrong out of ignorance
13:23:49 <lemevi> idk
13:23:59 <lemevi> the online documentation and finding answers for haskell is pretty sweet though
13:24:11 <lemevi> plus you guys are super helpful ty
13:24:44 <lemevi> I also like the intellij plugin for haskell, that + terminal I can do everything just inside intellij
13:24:57 <lemevi> much faster than vim and terminal although I like vim
13:25:13 <cocreature> lemevi: instead of guarding against the length, you could pattern match on []
13:25:15 <lemevi> I meant using the intellij terminal
13:25:24 <lemevi> ohhh nice cocreature thank you
13:25:48 <cocreature> lemevi: also you don't need to guard at all if you only have an otherwise
13:25:55 <cocreature> after all it's always true :)
13:26:01 <lemevi> but how do I reference the the variable
13:26:09 <lemevi> like the signature doesn't have a variable
13:26:13 <lemevi> that's why I do that
13:26:17 <lemevi> so I can get a variable
13:26:26 <cocreature> lemevi: f n = n + 1
13:26:35 <lemevi> oh
13:26:35 <cocreature> you put it before the equal sign
13:26:38 <lemevi> :O
13:26:38 <cocreature> like you've done now
13:26:42 <lemevi> kk 
13:26:49 <cocreature> e.g. isValidCCNum ints …
13:26:52 <cocreature> the ints is the variable name
13:26:55 <lemevi> ya
13:26:59 <lemevi> thanks!
13:27:19 <cocreature> or the argument name if you want to be precise since variables are a bit strange in haskell, but that's a different story
13:27:29 <cocreature> yw
13:28:57 <dmj`> anyone know Ian Lynagh's IRC handle?
13:29:08 <dmj`> the lcs package author
13:29:32 <Fuuzetsu> dmj`: Igloo
13:30:10 <bitemyapp> where's Data.Vector.catMaybes?
13:30:35 <bitemyapp> is it just slow?
13:32:23 <Gurkenglas> zippy and witherable don't mix
13:32:54 <Hafydd> bitemyapp: would Data.Vector.catMaybes return a vector or a list?
13:34:09 <dmj`> Fuuzetsu: thanks !!
13:34:20 <Hafydd> If it fuses well enough, Data.Vector.fromList . foldMap maybeToList might work well enough.
13:34:53 <Hafydd> -1"well enough"
13:40:14 <bitemyapp> Hafydd: I ended up folding a vector into a list, then used fromList.
13:41:23 <Hafydd> bitemyapp: hmm... well, the above might be one less intermediate structure, depending on fusion.
13:42:33 <Hafydd> Well, I forget myself! Whatever's simplest is probably best, unless there's a performance problem.
13:43:11 <hexagoxel> has Data.List.Vector a sufficiently efficient fromList? storable-vector's fromList (called pack) calculates the length of the list first..
13:43:33 <hexagoxel> which seems to counter any streaming benefits
13:44:54 <chpatrick1> hexagoxel: there's fromListN
13:45:04 <hexagoxel> and packN, i know
13:45:14 <hexagoxel> not applicable for the catMaybes use-case
13:46:23 <hexagoxel> well, i guess you could count the number of Just's in a first traversal..
13:48:08 * hackagebot android 0.0.2 - Android methods exposed to Haskell  https://hackage.haskell.org/package/android-0.0.2 (IvanPerez)
13:49:44 <magbo> Hey, how would you suggest calling pinentry from Haskell land?
13:50:02 <magbo> And getting the phrase that user inputs afterwards. :S
13:52:34 <ReinH> magbo: Does it use stdin/stdout?
13:52:36 <magbo> I'm lurking https://github.com/search?l=Haskell&q=pinentry&type=Code&utf8=✓ now in hopes to find someone doing that :)
13:52:52 <ReinH> (the curses version)
13:53:29 <ReinH> Although, without knowing how pinentry works, it seems unlikely that you can just get the phrase the user enters.
13:54:10 <magbo> ReinH: I'm only guessing how it should work (don't know for sure). IMHO, it does it on a low-level — stores phrase in memory then erases it when the caller gets it.
13:54:16 <magbo> At least it should be done like this in C
13:54:45 <tomus> To pull values from a shape, use the Z and :. constructors :
13:54:46 <tomus> Z :. h :. w = size
13:54:52 <tomus> hm, I can't parse this
13:55:17 <magbo> Basically what I want to accomplish is to remove keyslot and keyfile for an encrypted root partition and let the user enter a phrase, saving it to a keyslot
13:55:45 <magbo> Obviously, I'd much rather rely on pinentry than reinvent the wheel here.
13:56:46 <tomus> ... let (Z :. h :. w) = I.shape img in ... is that how I get h and w?
13:57:36 <magbo> Yeah, I don't think I can get data from pinentry.
13:57:48 <magbo> I think that it's meant to only work with GPG.
13:58:58 <magbo> And gpg-agent, that is. So my next question — if you would need to manipulate (change a passphrase on, remove old passphrase, remove keyfile) a luks-partition from Haskell land, how would you do that?
14:03:09 * hackagebot VKHS 0.5.6 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-0.5.6 (SergeyMironov)
14:03:22 <frerich> Is there a popular stance on the ImplicitParams extension? I only now noticed it and after reading up on it, it seems useful and I can't wait to use it on the next occasion - OTOH, that's often my reflex with language extensions. So I wonder whether there's some experience which says when to use (or avoid) it. :o]
14:03:55 <frerich> I could imagine it for passing global flags like a 'debug mode' or 'developer mode' flag around or so.
14:05:05 <frerich> So far, I always used the Reader monad for this kind of thing, but maybe this extension has some nice advantages...
14:06:23 <ReinH> frerich: fwiw I haven't seen it used very much in the code on hackage I've looked at
14:06:54 <ReinH> I think people prefer explicit params to implicit params, excepting of course with typeclasses, where at least the constraint is explicit.
14:07:16 <ReinH> That doesn't necessarily mean it's a bad extension, though
14:07:20 <frerich> ReinH: I think an 'implicit parameter' is somehow dubious (but I can't exactly nail why it makes me feel uneasy) but for things like a 'debug' mode or so, global, program-wide flags -- maybe that's a nice way to do it.
14:07:26 <frerich> With little syntactic overhead.
14:07:43 <ReinH> It does make me feel a little uneasy as well tbh
14:08:09 * hackagebot VKHS 0.5.7 - Provides access to Vkontakte social network via public API  https://hackage.haskell.org/package/VKHS-0.5.7 (SergeyMironov)
14:14:58 <danilo2> Hello! :) I would like to ask you if is it "safE" to use unsafePerformIO to create a list of weak references from a list of objects? I don't see any reasons why it should not work if the function is not inlined. I know this is ugly and very ugly, but this is just a theoretical question
14:18:59 <aweinstock> I'm using Conduit for the first time, and keep making mistakes involving left-to-right vs right-to-left (I'm used to function composition), does Conduit have an RTL composition operator?
14:19:38 <aweinstock> danilo2: I think the key to reasoning about unsafePerformIO is "would this action be correct if performed more than once depending on evaluation order"
14:20:29 <danilo2> aweinstock: that's a good point. If this is the correct way of thinking, than my question would have answer that it is safe I think
14:21:29 <aweinstock> danilo2: try it, run some tests, provisionally accept it (if the tests pass), but worry about it at the back of your mind
14:22:35 <danilo2> aweinstock: I've got a funny use case here which could profit from such design and Ido exactly as you describe. But I feel safer (worrying about it at the back of my mind) asking here to confirm my thoughts :D Thank you :)
14:23:11 <chpatrick1> aweinstock: LTR is standard for applicative and monad though
14:23:22 <aweinstock> :t (<=<)
14:23:23 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
14:23:27 <chpatrick1> yeah it exists
14:23:32 <chpatrick1> but >>= is in the logo ;)
14:23:40 <aweinstock> I guess so ;)
14:23:50 <nkaretnikov> how do i simplify a type family like it's possible with a class?
14:24:07 <nkaretnikov> i defined And at the type level with kind Bool
14:24:09 <nkaretnikov> like so
14:24:30 <nkaretnikov> type family And x y :: Bool where And True True = True; And x y = False
14:24:52 <nkaretnikov> if i test it in ghci, like this: :t undefined :: Proxy (And True False)
14:25:04 <nkaretnikov> i see the type as i specified it
14:25:08 <nkaretnikov> but i want to see False
14:25:24 <nkaretnikov> Enigmagic: any ideas?  (you suggested to use proxy yesterday)
14:25:45 <nkaretnikov> i know that it's possible with type classes and functional deps
14:25:53 <nkaretnikov> not sure about type families
14:26:12 <Enigmagic> nkaretnikov: :kind! And True True
14:26:43 <nkaretnikov> Enigmagic: what does the bang mean?
14:27:05 <danilo2> nkaretnikov: Don't test it in GHCI - GHCi very often displays full type even if Haskell knows that it is False
14:27:09 <Enigmagic> nkaretnikov: forces the evaluation of the kind? i don't know
14:27:10 <danilo2> nkaretnikov: do this way
14:27:19 <nkaretnikov> Enigmagic: neat, it works!
14:27:22 <nkaretnikov> til
14:28:07 <Enigmagic> nkaretnikov: i use it frequently when dealing with generics... since it's the only way to get ghci to reliably print out types and kinds when type families are involved
14:28:24 <nkaretnikov> good to know
14:28:37 <danilo2> nkaretnikov: test it in GHC, using something like normal equality - I mean : print ((Proxy :: Proxy True) == (Proxy :: Proxy (And True False)) - It will only compile if it was evaluated correctly - this is the most brutal way of checking it, but if everything else fails, go with it
14:29:12 <nkaretnikov> danilo2: didn't know about this either.  thanks, i'll probably use it.
14:29:12 <Enigmagic> danilo2: or just use> Refl :: Refl (And True True :~: True)
14:29:15 <danilo2> Enigmagic: i didn't know about this one. Its a life saver
14:29:33 <danilo2> Enigmagic: right
14:29:41 <nkaretnikov> Enigmagic: all this makes me appreciate coq so much
14:29:43 <nkaretnikov> and its repl
14:30:59 <tomus> > @let add (a, b) (c, d) = (a + b, c + d)
14:31:00 <lambdabot>  <hint>:1:1: parse error on input ‘@’
14:31:21 <tomus> @let add (a, b) (c, d) = (a + b, c + d)
14:31:22 <lambdabot>  Defined.
14:31:38 <tomus> > replicate 4 (4, 10)) `zipWith add` [(1, 1), (1, -1), (-1, 1), (-1, -1)
14:31:40 <lambdabot>  <hint>:1:20: parse error on input ‘)’
14:31:43 <tomus> > replicate 4 (4, 10)) `zipWith add` [(1, 1), (1, -1), (-1, 1), (-1, -1)]
14:31:44 <lambdabot>  <hint>:1:20: parse error on input ‘)’
14:32:13 <tomus> > replicate 4 (4, 10) `zipWith add` [(1, 1), (1, -1), (-1, 1), (-1, -1)]
14:32:15 <lambdabot>  <hint>:1:30: parse error on input ‘add’
14:32:32 <tomus> that one^^ why can't I do `zipWith add`?
14:32:41 <geekosaur> `` doesn't permit expressions, only names
14:33:33 <jophish_> If you only had ten minutes to teach another programmer (non haskell) about a cool aspect of haskell what would you talk about?
14:34:05 <jophish_> not necessarily a sales pitch, just something interesting
14:34:09 <johnw> types that communicate enough about the implementation to be able to know something really meaningful just by reading them
14:34:35 <johnw> a C function int f(int) is really anything in the world
14:35:05 <frerich> jophish_: I'd talk about purity (which somewhat overlaps with what johnw mentioned) and maybe lazyness
14:35:50 <frerich> jophish_: ...since purity opens the door to all kinds of other interesting things, like refactoring, concurrency, testing.
14:35:53 <johnw> sadly, I can't even sell laziness to all Haskell programmers
14:36:19 <jophish_> johnw: worse is the function void f()
14:37:00 <tomus> depends on the audience
14:37:04 <johnw> Haskell also strongly encourages understanding the difference between evaluation and execution
14:37:43 <frerich> jophish_: What I do *not* try (at least when talking about Haskell to colleagues) is to describe Haskell as a 'Getthing Sh*t Done' thing. It's more like a glimpse into the future which may never become reality, but knowing the future may well change how you write code today, in whatever language you (have to) use.
14:37:58 <jophish_> tomus: smart, technical people who spend lots of time in C++
14:37:59 <frerich> jophish_: I.e. I explain that knowin Haskell will make you a better C++ or Java or whatever programmer.
14:38:23 <jophish_> frerich: Haskell is my "Getting shit done" language
14:38:33 <frerich> jophish_: That's great! :-)
14:38:47 <jophish_> Whenever I have to go back to anything else, I die a little inside
14:39:08 <jophish_> Haskell has ruined programming other languages for me :/
14:39:32 <printline> I want to update an Data.Array in a recursive IO function (that takes user input), how can I manage the state of this array? I've added this argument for now, but I can't get the types right and I'm not sure whether it's the correct approach: foo :: Array -> IO
14:39:57 <frerich> jophish_: I work (well worked) as a software engineer for the last decade and as it turns out the 'programming' part is only a small part of it (and there's not all that much freedom). I deal with customers using ancienst RHEL systems or Visual Studio 6 or QNX or so. ;-)
14:40:23 <frerich> I.e. I end up using whatever works best ("When in rome, do as the romans do")
14:40:51 <frerich> but I *still* benefit from knowing some Haskell!
14:41:06 <frerich> Much more so than knowing about, say, Ruby.
14:41:49 <jophish_> frerich: I know exactly what you mean :D
14:41:50 <printline> so its this: foo arr = do {..; foo arr1}, but how do I use within the do-block? I tried binding it to a variable like this, but the types won't match: arr1 <- bar arr
14:43:20 <frerich> jophish_: So to my colleagues, anything related to debugging, refactoring, maintenance is a nice bonus. And purity is awesome for that.
14:45:47 <Cale> printline: What's the type of bar?
14:46:04 <nkaretnikov> Enigmagic: wait, how's refl defined?
14:46:28 <printline> Cale: MyType -> MyType
14:46:32 <Enigmagic> nkaretnikov: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Type-Equality.html
14:46:58 <nkaretnikov> Enigmagic: yeah, found it already :\
14:47:02 <Enigmagic> so i was wrong, sorry :) > Refl :: And True True :~: True
14:47:17 <nkaretnikov> thought, i can give a self-contained example besides proxy
14:47:33 <shachaf> i,i Dict :: Dict (And True True ~ True)
14:47:34 <Cale> printline: Inside a do-block for IO, when you write  v <- x  it means "execute the action x, and call its result v", so if x :: IO t, then v :: t, and the do-block as a whole will itself be an IO action of the same type as the last line in it.
14:47:59 <Cale> printline: If you just wanted to define v to be the same thing as x, you would write  let v = x  instead
14:48:15 <Enigmagic> nkaretnikov: yes... here's an example: https://github.com/alphaHeavy/llvm-general-typed/blob/master/llvm-general-typed-pure/test/Test.hs#L27
14:48:23 <GLM> Is there a way to zip two lists together where the values match by some function?
14:48:33 <Cale> GLM: Are you thinking of zipWith?
14:48:51 <Cale> > zipWith (+) [1,2,3] [40,50,60]
14:48:52 <lambdabot>  [41,52,63]
14:49:27 <printline> Cale: ah, that explains a lot
14:49:54 <GLM> Cale:Close but no. We have two lists that need to match the values with the values in the second list but they may not be in the same order
14:50:10 <GLM> > zipWith (,) [1,2,3] [40,50,60]
14:50:12 <lambdabot>  [(1,40),(2,50),(3,60)]
14:50:14 <Cale> GLM: I'm not sure what you mean
14:51:50 <GLM> I want it to go through each value in the first list and see if there is a matching value in the second list. For example, you'd pass in the function \x y -> True. This function would return the paired values but ignore any values that couldn't find matches
14:52:30 <GLM> Cale:Does that explain it?
14:52:57 <Enigmagic> GLM: take a look at Data.Map.intersectionWith
14:53:11 * hackagebot opaleye-trans 0.1.0 - A monad transformer for Opaleye  https://hackage.haskell.org/package/opaleye-trans-0.1.0 (wraithm)
14:53:18 <Cale> Yeah, intersectionWith might be useful
14:53:24 <Cale> I dunno
14:54:15 <Cale> Another function which might be useful if you're going to go searching by hand would be
14:54:35 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
14:54:37 <lambdabot>  Defined.
14:54:41 <Cale> > select [1,2,3,4]
14:54:45 <lambdabot>  [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
14:54:48 <athan_> Couldn't there be a monoid newtype `Bounded a => Min a` and `Max a`, respectively?
14:54:55 <athan_> monoid newtypes*
14:55:31 <athan> er (Bounded a, Ord a) =>*
14:57:53 <nkaretnikov> Enigmagic: so i defined https://github.com/alphaHeavy/llvm-general-typed/blob/master/llvm-general-typed-pure/test/Test.hs#L27
14:57:58 <nkaretnikov> oops 
14:58:01 <nkaretnikov> i meant
14:58:07 <lpaste> grandpascorpion pasted “Simple concurrency” at http://lpaste.net/141948
14:58:08 <nkaretnikov> And True False :~: True
14:58:11 <nkaretnikov> but it typechecks
14:58:16 <quicksilver> athan has gone?
14:58:27 <quicksilver> shame bcause the answer is yes :)
14:58:36 <grandpascorpion> Hello, I'm a bit of a newbie and I had a question about concurrency.  I posted something here :   http://lpaste.net/141948
14:58:46 <kristof> How do I get haskell mode to display type information next to the type and not in the mini buffer?
14:58:49 <nkaretnikov> i want the typechecker to warn me
14:58:57 <grandpascorpion> Any insight would be appreciated.  I have tried Marlow's book as well as StackOverflow
14:59:12 <grandpascorpion> but must be missing something elementary.  Thanks in advance
14:59:13 <Cale> @let pairings p [] ys = [[]]; pairings p (x:xs) ys = do (y,ys') <- select ys; guard (p x y); ps <- pairings p xs ys'; return ((x,y):ps)
14:59:14 <lambdabot>  Defined.
14:59:22 <Cale> > pairings (\x y -> True) [1,2,3] [4,5,6]
14:59:24 <lambdabot>  [[(1,4),(2,5),(3,6)],[(1,4),(2,6),(3,5)],[(1,5),(2,4),(3,6)],[(1,5),(2,6),(3...
14:59:31 <quicksilver> grandpascorpion: you can't avoid IO. Timeouts are intrinsically an IO effect.
14:59:46 <kristof> Surely other people must find it annoying to have their eyes scroll up and down the page
15:00:20 <Cale> > pairings (\x y -> even x /= even y) [1,2,3] [4,5,6]
15:00:21 <lambdabot>  [[(1,4),(2,5),(3,6)],[(1,6),(2,5),(3,4)]]
15:00:43 <Cale> GLM: ^^ is that the sort of thing you're looking for?
15:00:48 <Enigmagic> nkaretnikov: https://gist.github.com/NathanHowell/754472dc72edddfdb0f1
15:01:23 <tommd> @info pairings
15:01:24 <lambdabot> pairings
15:01:28 <tommd> thanks
15:01:44 <nha_> how come there is no call/cc in Control.Eff monad?
15:01:46 <Cale> tommd: What were you expecting? :)
15:02:13 <Cale> tommd: I just defined the function
15:02:19 <tommd> Cale: I hadn't seen pairings before and I didn't remember if lambdabot's @info told me a Haskell module, type or some other info.
15:02:21 <nkaretnikov> Enigmagic: i'm trying to define a top level thing, does it matter?
15:03:12 * hackagebot GPipe 2.1.1 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.1.1 (TobiasBexelius)
15:03:26 <nkaretnikov> Enigmagic: would foo :: And True False :~: True; foo = undefined typecheck for you?
15:03:38 <Enigmagic> nkaretnikov: foo = Refl
15:04:06 <Enigmagic> nkaretnikov: i updated the gist... fails for me.
15:04:10 <grandpascorpion> Thanks, quicksilver.  
15:04:12 <Cale> > pairings (\x y -> even x == even y) [1,2,3] [4,5,6]
15:04:13 <lambdabot>  []
15:04:16 <Cale> > pairings (\x y -> even x == even y) [1,2,3] [4,5,6,7]
15:04:17 <Enigmagic> definitely need to use Refl and not bottom :)
15:04:18 <lambdabot>  [[(1,5),(2,4),(3,7)],[(1,5),(2,6),(3,7)],[(1,7),(2,4),(3,5)],[(1,7),(2,6),(3...
15:04:25 <nkaretnikov> Enigmagic: okay, with Refl it fails too
15:04:50 <grandpascorpion> ... ah of course, because the clock time is necessarily state
15:04:52 <Enigmagic> nkaretnikov: does my example fail to typecheck for you?
15:04:55 <grandpascorpion> +ful
15:05:02 <nkaretnikov> Enigmagic: thanks so much for guiding me through this wild territory
15:05:32 <nkaretnikov> Enigmagic: i have a similar one locally, it does fail to typecheck
15:05:40 <Enigmagic> k sweet :)
15:05:40 <nkaretnikov> which is good :)
15:09:56 <printline> (how) can I declare a variable in a do block to assign a value to it later in a case block? 
15:10:25 <johnw> printline: that really doesn't make sense in the context of Haskell
15:10:51 <johnw> values are bound to names, but there aren't variable as cells for mutation, not in the way you find common in imperative languages
15:10:56 <quicksilver> printline: what you do instead is make the variable's value the return value of the case expression
15:11:14 <quicksilver> foo <- case ... potentially long case expression ...
15:11:16 <johnw> (I mean, we do have such a thing, but I don't think that's what you're asking for )
15:11:35 <quicksilver> if you need more than one then you make the case return a tuple
15:11:35 <athan> Is there a `Monoid a => Const b a` monoid, or really a `Monoid a => Snd (b, a)` monoid?
15:11:56 <quicksilver> athan your Bounded Min instance is in the semigroups package btw.
15:12:03 <athan> agh sorry, I feel like I screwed those up
15:12:11 <athan> quicksilver: Sorry x_x I just saw too
15:12:17 <athan> word for word lol
15:12:22 <johnw> athan: Monoid a => Const b a would be pretty trivial
15:12:36 <exio4> for whic definition of Const?
15:12:43 <athan> That's my question too
15:12:48 <quicksilver> what would mempty :: Const b a be?
15:12:48 <johnw> data Const b a = Const b
15:12:53 <johnw> is there another Const?
15:12:54 <athan> with the latter, I keep the information of both, but only use the second
15:13:12 * hackagebot language-c-quote 0.11.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.1 (GeoffreyMainland)
15:13:19 <exio4> johnw: I meant in his example P
15:13:26 <exio4> :P * 
15:13:28 <johnw> quicksilver: oh, right
15:13:49 <johnw> quicksilver: sorry, Monoid b => Const b a then :(
15:13:50 <quicksilver> Monoid b => Monoid (Const b a) perhaps?
15:13:52 * quicksilver nods
15:13:57 <printline> quicksilver: ah that makes sense in terms of the plumbing-metaphor which seems to fit functional programming pretty well
15:13:57 <athan> Snd a b ~ (a, b), but all features on the second
15:14:02 <Gurkenglas> @instances Monoid
15:14:04 <lambdabot> (), (a -> b), (a, b), All, Alt f a, Any, Const a b, Dual a, Expr, Maybe a, Ordering, Product a, Sequenced a m, Sum a
15:15:54 <athan> Do you think `Snd a b = Snd {getSnd :: (a,b)}` would be useful? If all instances were using the second term `b`?
15:16:01 <athan> or is there a more general solution?
15:17:22 <printline> quicksilver: though, now I want to use the value that comes from the case-block as argument for the recursive call: foo = do newVal <- case {..; return xy;}; foo newVal, however the type of foo is MyType -> IO, should I change it to IO MyType -> IO then?
15:19:04 <athan> as a semigroup* - there's no way to have enough info to make an mempty
15:20:44 <quicksilver> printline: no
15:21:06 <quicksilver> printline: you have bound 'newVal' with the monadic <- notation
15:21:27 <quicksilver> printline: so, newVal will not have an IO type. It will be plain 'MyType' and passing it to foo should be fine
15:23:13 * hackagebot CoreDump 0.1.0.1 - A GHC plugin for printing GHC's internal Core data structures.  https://hackage.haskell.org/package/CoreDump-0.1.0.1 (OmerAgacan)
15:23:15 * hackagebot linear 1.20.2 - Linear Algebra  https://hackage.haskell.org/package/linear-1.20.2 (EdwardKmett)
15:26:42 <boxdot1> Hi
15:27:03 <boxdot1> What happens if I use getChar and stdin is already in EOF?
15:27:10 <nkaretnikov> Enigmagic: https://github.com/nkaretnikov/triangle-inequality/blob/master/Main.hs
15:28:41 <nkaretnikov> Enigmagic: can i do better (for some def'n of the word better)?
15:29:09 <nkaretnikov> undecidable instances extension makes me uneasy
15:29:23 <nkaretnikov> but it's required for my definition of triangle
15:29:28 <Enigmagic> undecidable instances is okay
15:29:42 <Enigmagic> doesn't affect runtime at all
15:31:16 <Enigmagic> nkaretnikov: you can define Triangle as a type alias, doesn't need to be a type family.. otherwise it seems okay to me
15:31:24 <printline> quicksilver: the linter says that it coulnd't match MyType with actual type () though
15:32:11 <exio4> linter.. ?
15:32:15 <Enigmagic> nkaretnikov: you could use a promoted Nat data kind
15:33:30 <printline> exio4: I mean the compiler
15:33:38 <akegalj> it says that seq evaluates to whnf (until first constructor). Why then if I type   let z = Just (Just 5) :: Maybe (Maybe Int)    and then :sprint z, it evaluates whole z (outer and inner constructor)
15:35:22 <akegalj> :sprint t
15:36:05 <printline> oh, sorry, made a huge mistake
15:38:13 * hackagebot mainland-pretty 0.4.1.1 - Pretty printing designed for printing source code.  https://hackage.haskell.org/package/mainland-pretty-0.4.1.1 (GeoffreyMainland)
15:42:10 <akegalj> ignore my question, it works as expected. I have been runing seq z z   (where ghci forces the rest to be evaluated) in ghci instead of seq z () .
15:43:00 <shachaf> seq z z = z
15:45:13 <quicksilver> akegalj: Just (Just 5) is already fully evaluated anyway
15:47:38 <quicksilver> not that :print and :sprint work reliably for me anyway :/
15:49:34 <shachaf> !list
15:49:34 <monochrom> shachaf: http://okmij.org/ftp
15:49:52 <shachaf> jackpot
15:51:35 * geekosaur had been intending to test that from some "off" accounts...
15:53:36 <Hakerteam> samp.bmhp.net:7777
15:53:42 <Hakerteam> hack please
15:53:54 <Hakerteam> and ddos please
15:54:13 <broma0> Any idea how I'd write the FromJSON instance for 'Map Tag String' where 'data Tag = Tag String String'?
15:54:39 <broma0> Also the ToJSON instance..
15:56:43 <pavonia> broma0: Do you have these instances for Tag already?
15:57:29 <broma0> pavonia: no
15:57:45 <indiagreen> broma0: what do you want your JSON to actually look like? it's not clear at all
15:57:53 <Cale> Hakerteam: What was it that made you think that this was an appropriate place to ask for that?
15:58:28 <broma0> indiagreen: it doesnt matter so much, whatever allows me to serialize that map. Now that I say that, I'm thinking I might as well just use a different serialization mechanism
15:59:04 <Cale> Hakerteam: I'm curious, because we get that kind of request every once in a while, and it always makes me wonder how someone could get so confused about what this channel is about.
15:59:11 <broma0> my applications state contains the aforementioned map. I need to save that map to disk, so I figured in serialize it to and from JSON
15:59:34 <johnw> Cale: Maybe people think we're Hackskell
15:59:45 <indiagreen> broma0: if “whatever allows”, then you can just convert your map to a list of key–value pairs and then you'll have your serialisation for free (well, you'll also have to write an instance for Tag, but it can be derived automatically)
16:00:25 <pavonia> Cale: We have the word "Hackage" in the topic
16:00:42 <broma0> indiagreen: duh! thank you. 
16:00:43 <Cale> pavonia: heh, I suppose that's a good point
16:01:38 <Fuuzetsu> Cale: more than likely it's some kid looking for personal army…
16:01:40 <Welkin> what is a good way to control the flow of execution without nesting case expressions?
16:01:54 <Welkin> something from Control.Monad.Loop?
16:02:11 <pavonia> Continuations perhaps
16:02:12 <Fuuzetsu> Welkin: or just Monad?
16:02:33 <Welkin> uh
16:02:39 <Welkin> inside of a Handler in yesod
16:02:40 <Cale> Fuuzetsu: Well, yeah, that's what it is, I'm just curious what makes people think #haskell is an appropriate place to look for one.
16:02:43 <Welkin> is the specific use case
16:02:58 <Welkin> all kinds of data transformation and error checking, database accesses
16:02:59 <Fuuzetsu> Cale: oh, I just assumed they joined the most popular channels or something
16:03:09 <Cale> Maybe.
16:03:12 <Welkin> but I want to short-circuit and send them to a 404 or 403 page when necessary
16:03:46 <Welkin> or return a form with errors, etc
16:05:42 <akegalj> quicksilver: Yes, thnx. pure (pure 5) :: Maybe (Maybe Int) wont be evaluated so I am testing with these
16:08:50 <sleblanc> Hmm, ghc: panic! (the 'impossible' happened)
16:09:24 <sleblanc> While installing the comonad package
16:13:55 <Hafydd> I'm hearing about the "impossible" happening quite a lot, these days.
16:16:22 <lamefun> Are there some easy to use and understand type-level data types that I can convert to normal data types?
16:16:55 <hpc> lamefun: type-level data types?
16:21:48 <lamefun> Like data, but types.
16:23:52 <Enigmagic> lamefun: what do you mean by 'convert' ?
16:24:54 <lamefun> Like natVal, i.e. typeToData (Proxy :: Proxy TypeLevelType) :: NormalType
16:25:30 <Enigmagic> lamefun: have you looked at the singletons package?
16:25:49 <lamefun> Yes, it's incomprehensible.
16:26:18 <Enigmagic> well
16:26:26 <exio4> it is haskell faking depedent types though
16:27:00 <exio4> dependent* so unless we get dependent types soon.. :)
16:38:58 <pavonia> What is the proper way to link in an additional C lib from GHC? When I just use --make with -L/-l, I get the following linker erros: http://lpaste.net/2256629478639796224
16:39:33 <pavonia> It looks like --make loses its effect when an addtional library is added
17:38:24 <lamefun> Can I make Haddock add prefixes to names? Eg. I have MyProgram.Package with data Name, MyProgram.Key with data Name, can I make Haddock to display their names as eg. Key.Name?
17:39:17 <info_is_good> Is this the right channel to ask about type theory? If simple type theory can't express subtraction, why is it considered so important? Isn't the system too inexpressible to be useful?
17:40:48 <hpc> there's a tradeoff between "i can do X" vs "i can know Y"
17:41:59 <pavonia> So passing -optl -lmysql builds the program, but then I get a segmentation fault when running the code :S
17:42:39 <hpc> info_is_good: it's important for being a step up from first-order logic
17:44:01 <hpc> i don't know what you really gain by not having polymorphism though
17:48:20 * hackagebot opaleye-trans 0.1.1 - A monad transformer for Opaleye  https://hackage.haskell.org/package/opaleye-trans-0.1.1 (wraithm)
17:49:06 <anohigisavay> hello
17:49:20 <anohigisavay> i saw something in paper like this:
17:49:34 <anohigisavay> data Expr f = In (f (Expr f))
17:49:50 <anohigisavay> i'm totally lost
17:49:58 <Cale> That's also often called Mu instead of Expr (just as a side note)
17:50:15 <Cale> The first thing you should examine perhaps is what happens when f = Maybe
17:50:41 <anohigisavay> how does something fit then inner (Expr f) part?
17:50:49 <anohigisavay> forexample, data Val e = Val Int
17:50:57 <hpc> it's just a recursive data type
17:50:58 <anohigisavay> how does In (Val 3) work?
17:51:04 <hpc> similar to how lists work
17:51:49 <hpc> anohigisavay: it works just like that, and you've stumbled on what (Expr (Const Int)) does
17:51:59 <info_is_good> hpc: okay
17:52:08 <hpc> anohigisavay: take the definition for (Expr f) and substitute in Maybe
17:52:19 <info_is_good> Is there any library for high order unification? 
17:52:32 <hpc> In (Maybe (Expr Maybe))
17:52:43 <hpc> beta-reduce the Maybe
17:53:13 <hpc> data NewExpr = Nothing | Just NewExpr
17:53:42 <hpc> and do some particularly pointed renaming to get
17:53:49 <hpc> data Nat = Zero | Succ Nat
17:55:41 <hpc> in general, if you encounter some confusing function and you want to understand it as applied to a particular thing
17:55:45 <hpc> substitute and reduce
17:56:02 <hpc> repeat until makes sense
17:56:05 <anohigisavay> yea thanks, it might take me some time to digest it
17:57:07 <hpc> once you understand Maybe, a good test of your understanding would be to try Either, then (,)
17:58:57 <hpc> anohigisavay: oh, and get good at mentally erasing data constructors when convenient
17:59:07 <hpc> that was a skill it took me too long to realize i needed to learn
18:00:32 <Gurkenglas> Cale, don't you mean Fix instead of Mu?
18:00:43 <Cale> Gurkenglas: That's yet another name for it.
18:01:03 <hpc> we are the knights who say Nu!
18:01:11 <johnw> Cale: he's thinking of the Mu that's a final encoding of Fix
18:01:55 <Gurkenglas> (I'm just seeing that https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#t:Mu has another definition. Are those equivalent via Yoneda or something?)
18:02:30 <johnw> yes, that's the final encoding of Fix
18:05:43 <Gurkenglas> "newtype Mu f = Mu (forall a. (f a -> a) -> a)" is equivalent to "newtype Mu f = Mu (f Void)", right?
18:09:12 <johnw> I would say, not at all
18:18:27 <Gurkenglas> My reasoning goes: To produce an a, we only have (f a -> a), thus we need exactly one f a, so "newtype Mu f = Mu (forall a. (f a -> a) -> a)" is equivalent to "newtype Mu f = Mu (forall a. f a)". I now realize using Void for a doesn't work, since we don't have the Functor instance required to turn f Void back into f a.
18:19:46 <johnw> Mu is giving you a function that takes a function, and will give that function an f a for any a
18:20:03 <johnw> so the 'forall a. f a' is inside the closure represented by the Mu value
18:20:49 <johnw> you pick 'a' to be Int, and your function will get an f Int, so long as it can use that to offer an Int
18:26:17 <nolraiU> Void has a functor instance if you want it too.
18:30:32 <Gurkenglas> nolraiU, f needs the functor instance, and Void doesn't even have the right kind
18:32:13 <Radvendii> Is there some known problem with 'happy' version numbers? I'm trying to install Agda, and it keeps saying it can't determine the version of happy
18:32:52 <pavonia> Is happy on your path?
18:33:30 <Radvendii> yep
18:33:38 <Radvendii> and it has the right version
18:33:54 <Radvendii> i can run 'happy' from the command line
18:34:15 <Radvendii> it's also not complaining that it can't find happy. It knows where it is. it's just complaining that it can't determine the version
18:37:26 <dibblego> put it on the PATH
18:37:45 <dibblego> PATH=$HOME/.cabal/bin:$PATH
18:38:31 <Radvendii> but it is on the PATH
18:38:35 <Radvendii> i can run happy
18:38:42 <Radvendii> it's finding it fine
18:39:29 <Radvendii> or is there something I'm missing?
18:47:56 <pavonia> Radvendii: Could you paste the full build log?
18:48:22 * hackagebot haskell-src-meta 0.6.0.11 - Parse source to template-haskell abstract syntax.  https://hackage.haskell.org/package/haskell-src-meta-0.6.0.11 (GeoffreyMainland)
18:49:52 <Radvendii> https://gist.github.com/Radvendii/063583c4088dfd473b19
18:49:55 <Radvendii> is that what you're looking for?
18:51:22 <pavonia> I think so
18:55:46 <pavonia> Radvendii: Are you sure the happy binary is present in the directory the error shows?
18:56:49 <Radvendii> hmm
18:56:50 <Radvendii> lemme check
18:57:10 <kazagistar> I have to transfer a bunch of fairly simple tasks that database people do into automation code. My thought is a DSL that lets you have simple, native sql strings with basic variables that can be passed around, any minimal syntax, and my first thought was this would be a reasonable place to use haskell. Any suggestions what libraries to look at to evaluate this option?
18:58:06 <Radvendii> It is there
18:58:15 <Radvendii> if I run it, i get "segmentation fault 11"
18:59:14 <pavonia> That.. doesn't sound right
18:59:29 <Radvendii> agreed
18:59:44 <Radvendii> not sure what to do about it though, stack automatically installed it there
19:01:01 <pavonia> No idea, sorry. Fighting with segmentation fauls myself atm :/
19:01:12 <Radvendii> ah, thanks anyways
19:01:56 <Radvendii> good luck
19:03:39 <pavonia> Heh, thanks
19:26:25 <tabemann> is there any IRC channel for yi?
19:26:52 <tabemann> oh #yi duh
20:22:28 <anohigisavay> http://lpaste.net/141955
20:23:07 <awpr> anohigisavay: delete the word "do".  Do you have "-werror" enabled?
20:23:31 <awpr> oh, I bet you weren't asking about the lpaste error annotation
20:23:55 <anohigisavay> awpr: that thing is only a warning
20:24:42 <anohigisavay> i'm playing with type families, and i declared the default type at line 6
20:25:11 <anohigisavay> if i move line 9 to the instances of class Battle it works
20:25:44 <anohigisavay> is it not possible to give a default pickWinner definition in my class?
20:28:27 <julianleviston> anohigisavay: aren’t you missing a close paren?
20:28:47 <julianleviston> anohigisavay: oh nevermind, I found it! :) sorry
20:28:54 <anohigisavay> xD
20:29:14 <julianleviston> the strang indentation was throwing me
20:29:34 <julianleviston> strange*
20:29:57 <glguy> anohigisavay: You can give a default implementation but it has to typecheck
20:30:18 <glguy> and it can't assume that the default type family was used
20:31:09 <anohigisavay> yea the pokemon, foe in the  type declaration is not the same as in the class type
20:31:22 <anohigisavay> maybe ScopedTypeVariables can help?
20:32:29 <awpr> anohigisavay: there can be an instance where "type Winner pokemon foe = foe", so it can't unify the default definition.  if you move it to the instance, then it's for a particular type, so it knows the actual type Winner pokemon foe, and it can
20:32:39 <echo-area> Is ~ necessary in type annotations only when a value is used, or inferred as, two or more types, and they are actually the same?
20:33:29 <awpr> i.e. the default definition of battle only works when the associated type family Winner is *also* the default, which isn't necessarily true
20:36:09 <anohigisavay> awpr: but for instances that overload pickWinner to return foe it also has to overload type Winner
20:36:51 <glguy_> You can do this using DefaultSignatures though
20:37:09 <kamatsu> should my Eq instances signify equality or equivalence?
20:37:56 <bitemyapp> kamatsu: equality, as i understand it.
20:38:58 <nshepperd> observable equality, anyway
20:38:59 <kamatsu> OK, I'll define my own ~~ operator then or something
20:39:12 <anohigisavay> thanks guys
20:39:48 <nshepperd> Data.Set hides the implementation, and so Eq deems sets that are mathematically the same to be Equal
20:39:56 <nshepperd> regardless of their tree structure
20:40:06 <kamatsu> right, but what I'm working on is a library for patches
20:40:24 <kamatsu> you could consider a patch p equivalent to p' if applying it to any document has the same effect.
20:40:51 <kamatsu> but they are observably different
20:41:43 <kamatsu> (e.g there are two different replace/insert patches to go from "a" to "bc")
21:08:28 * hackagebot mainland-pretty 0.4.1.2 - Pretty printing designed for printing source code.  https://hackage.haskell.org/package/mainland-pretty-0.4.1.2 (GeoffreyMainland)
21:10:52 <neptune_34444665> hello
21:11:07 <neptune_34444665> is anyone alive in here?
21:11:23 <jle`> maybe :)
21:11:31 <gfixler> nope
21:11:44 <neptune_34444665> that's a shame
21:11:47 <dmj`> neptune_34444665: derp
21:11:56 <gfixler> I am just a morphism
21:12:11 <neptune_34444665> im new to irc
21:12:25 <gfixler> we all are
21:12:26 <jle`> welcome! :D
21:12:27 <gfixler> irc is brand new
21:12:58 <neptune_34444665> tank you
21:13:58 <neptune_34444665> i heard haskell was the place to be
21:14:27 <jle`> some have said so
21:14:47 <gfixler> that was me
21:14:49 <gfixler> I said that
21:16:07 <neptune_34444665> is there a python channel? 
21:16:22 <gfixler> yep
21:16:36 <neptune_34444665> or a crypto channel
21:16:47 <gfixler> maybe
21:17:04 <neptune_34444665> rather than asking multiple times, what's  the best way for me to search out channels?
21:17:05 <gfixler> the real crypto channel is nearly impossible to get into
21:17:17 <neptune_34444665> what's the "real" crypto channel?
21:17:20 <gfixler> I just make up things and try them, but you can also google
21:17:26 <dolio> This isn't an IRC tutorial channel.
21:17:39 <gfixler> is there an IRC tutorial channel?
21:18:45 <neptune_34444665> there are a few, I believe, but I thought it would be useful to jump in
21:18:56 <kras> >max $ length [1,2,3] length [1,2]
21:19:08 <kras> whats wrong here?
21:19:10 <neptune_34444665> the main challenge is connecting, which i've accomplished
21:19:15 <kras> SHould I use parens?
21:19:22 <neptune_34444665> next is to find a place to talk about ecc
21:19:43 <dolio> kras: Yes, you should use parens.
21:20:21 <kras> ?max $ (length [1,2,3]) (length [1,2])
21:20:21 <lambdabot> Maybe you meant: thx msg faq
21:20:55 <shachaf> Forget $. $ is a shortcut for advanced users of Haskell syntax.
21:20:56 <dolio> The $ should not be there, either.
21:21:08 <gfixler> kras: function application is left-associative
21:21:13 <glguy> If it helps you can count all your parentheses toward your operator count
21:21:22 <kras> >max  (length [1,2,3]) (length [1,2])
21:21:25 <neptune_34444665> gfixler: what did you mean by the real crypto channel?
21:21:27 <shachaf> Write things out without $ first, and then you can add $ if you want.
21:21:34 <gfixler> neptune_34444665: that was a joke
21:21:38 <dolio> neptune_34444665: You are off topic.
21:21:59 <kras> oh got it
21:22:05 <kras> $ is not necessary here
21:22:11 <kras> yeah $ is confusing
21:22:24 <mniip> $ is just a regular operator
21:22:25 <kras> but it helps in readability sometimes
21:22:28 <neptune_34444665> thanks gfixler++
21:22:29 <mniip> that does the same as `id`
21:22:47 <neptune_34444665> im off to browsing
21:22:55 <mniip> a b $ c d  ->   a b `id` c d  ->  id (a b) (c d)
21:22:57 <gfixler> $ is just apply - function on left to value on right
21:23:03 <gfixler> but with the lowest precedence
21:23:27 <kras> I am just trying to understand GHCi message here
21:23:31 <kras> when I type max $ (length [1,2,3]) (length [1,2])
21:23:41 <noonan> I have a design question that I can't quite nail down.  I have a data type which represents some kind of AST, and I want to perform a bunch of different recursive operations over them (e.g. infer types, check types, perform simplifications / rewrites...)
21:23:43 <kras> it says "The function ‘length’ is applied to two arguments,"
21:24:07 <shachaf> One way to understand that message is to try adding parentheses until you get the same message.
21:25:05 <noonan> How should I structure it so that the various traversals / manipulations of the ASTs eliminate as much boilerplate as possible?  I want to abstract out the recursive AST traversal from the "local" operations happening around an AST node.
21:25:58 <nshepperd> noonan: recursion-schemes!
21:26:26 <noonan> sounds promising :)
21:26:57 <mniip> kras, like I said
21:27:06 <mniip> max $ (length [1,2,3]) (length [1,2])
21:27:10 <mniip> max `id` (length [1,2,3]) (length [1,2])
21:27:19 <mniip> id max ((length [1,2,3]) (length [1,2]))
21:27:25 <mniip> max (length [1,2,3] (length [1,2]))
21:27:38 <noonan> I guess I should have grepped hackage for ekmett first
21:27:46 <levi> Heh.
21:28:02 <nshepperd> noonan: what you're describing is a catamorphism, most likely
21:28:29 * hackagebot language-c-quote 0.11.2 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.2 (GeoffreyMainland)
21:28:55 <mniip> nshepperd, the fact that edwardk is the terminal object of hackage?
21:29:21 <kras> mniip: I understand till id max ((length [1,2,3]) (length [1,2]))
21:29:23 <nshepperd> haha
21:29:47 <mniip> kras, a + b  ->  (+) a b
21:29:49 <kras> I stop there since thats final isn't it?
21:29:57 <noonan> nshepperd: yeah, I think you're right about the cata connection
21:30:50 <mniip> kras, no, you apply the 'id' function
21:35:15 <levi> When you see a '$', first look on the left hand side. This should be a function. The operation of '$' is to apply the function that is its left operand to the *entire expression* on its right. Normal function application, on the other hand, will apply to just the single next value to its right.
21:37:00 <kras> so the right expression should be evaluated first, isn't it?
21:37:10 <mniip> this has nothing to do with evaluation
21:37:47 <levi> So in 'id max ...', you start from the left and find a function, 'id'. So it is applied to the thing *immediately* to its right, which is just 'max'. And 'id max' is just 'max'.
21:38:17 <jle`> hm, i don't think you have to go to `id`, you can just go straight from the deinfition of ($)
21:38:21 <jle`> @src ($)
21:38:21 <lambdabot> f $ x = f x
21:38:40 <jle`> max $ (length [1,2,3]) (length [1,2]) = max ( (length [1,2,3]) (length [1,2]) )
21:38:54 <mniip> jle`, well that can give the false idea that you can just paste them together
21:38:54 <levi> But with 'max $ ...', this means you're applying 'max' to everything to the right of $, not just the first thing to its right. It is, in effect, parenthesizing the expression to the right of the $.
21:39:04 <mniip> like 'a b $ c d' -> 'a b c d' which is false
21:39:16 <jle`> well, you have to identify what f and x are
21:39:28 <jle`> in this case, f is max, and x is (length [1,2,3]) (length [1,2])
21:39:40 <jle`> in that case, f is a b, and x is c d
21:40:06 <jle`> i guess that might be not intuitive if you aren't used to function application being so strong
21:41:24 <levi> $, and infix operators in general, split an expression into two sub-expressions. Functions normally applied don't do that, they 'eagerly' take the next expression in the text as their argument.
21:41:57 <mniip> not really
21:42:00 <mniip> thing is
21:42:11 <mniip> a b c
21:42:23 <mniip> the rightmost application is split first
21:42:28 <mniip> a b | c
21:42:36 <mniip> and then the left
21:42:40 <mniip> (a | b) | c
21:43:31 <kras> so if I have f2 f1 a b
21:43:42 <kras> it is like f2 (f1 a) b
21:43:42 <kras> ?
21:43:45 <levi> True, I should not have said 'in general'; it really comes down the the precedence and associativity rules.
21:44:08 <gfixler> > id id id (*2) $ id id id 3
21:44:10 <lambdabot>  6
21:44:22 <mniip> kras, no
21:44:35 <mniip> f2 f1 a b  -> (f2 f1 a) (b)
21:44:45 <mniip> -> ((f2 f1) (a)) (b)
21:45:03 <gfixler> function application is left associative
21:45:30 <gfixler> f g h x is (((f g) h) x)
21:46:13 <kras> so you break this associativity with $
21:46:25 <levi> $ is low-precedence and right-associative.
21:46:27 <gfixler> yes
21:46:37 <kras> so now if I have f $ g h x 
21:46:41 <gfixler> kras: function application has the highest precedence in haskell; $ the lowest
21:46:59 <gfixler> kras: both sides of the $ fully evaluate, *then* the left side is applied to the right side
21:47:26 <gfixler> so f $ g h x = f ((g h) x)
21:47:32 <kras> f $ g h x -> f ((g h) x)
21:47:33 <dolio> $ does not change evaluation.
21:50:03 <levi> It's about changing the grouping, not evaluation order.
21:50:48 <levi> Keep in mind that haskell doesn't evaluate the parameters of a function before the function itself as a strict/eagerly evaluated language does.
21:51:21 <gfixler> grouping does change evaluation order
21:51:32 <gfixler> > succ 3 * 2
21:51:33 <lambdabot>  8
21:51:36 <gfixler> > succ $ 3 * 2
21:51:38 <lambdabot>  7
21:52:22 <levi> That's grouping of operations.
21:52:24 <dolio> That is not a difference in evaluation order. It is just two different expressions.
21:53:26 <levi> I know what you're trying to say, but if you use 'evaluation order' to mean that, it makes it confusing to talk about lazy vs. eager evaluation.
21:53:48 <gfixler> I just think of evaluation as reducing terms
21:54:18 <jle`> unfortunately the term evaluation already has a well-established meaning in haskell
21:54:24 <levi> Yes, but it's the *grouping* that's the important distinction here.
21:54:40 <gfixler> jle`: unfortunate for me?
21:55:21 <kras> I guess I need to think about it more :-)
21:55:24 <jle`> or people who want to use "evaluation" to refer to things that aren't the actual haskell definition of "evaluation"
21:55:31 <kras> for now I will stick to parens
21:55:37 <levi> The point is to disambiguate some operations. You can either disambiguate via the associativity and precedence rules or via parentheses.
21:55:37 <Clint> good plan
21:55:40 <kras> thanks for the patience guys
21:55:47 * gfixler doesn't know which side of the line jle` is on
21:56:17 <jle`> i think using the word "evaluation" to refer to things that are different than the actual established haskell definition of "evaluation" can only lead to confusion and ambiguity in language
21:56:24 <jle`> that is the road you walk down
21:56:38 <jle`> there is value in having technical words have only one unambiguous definition
21:56:54 <gfixler> jle` is trolling me now
21:57:01 <cmccann> jle`: e-valuation, it's like regular valuation but electronic
21:57:08 <jle`> :|
21:57:14 <cmccann> mystery solved
21:57:36 <jle`> grouping doesn't change evaluation order, as evaluation order is defined as in haskell
21:57:57 <gfixler> jle`: thanks for the clarification
21:58:02 <levi> Indeed the evaluation order is changed, but it's because one builds a *different expression tree* than the other does, so of course the order is different. But we often need to talk about evaluation order of the *same* expression tree via eager or lazy evaluation strategies.
21:58:27 <gfixler> levi: yeah, I get it - I'll adjust my language accordingly
22:04:51 <levi> I mean, normally we do refer to precedence issues as 'order of operation' issues. I try to not be fundamentalist about the meanings of terms, as even technical terms tend to have multiple definitions. I just wanted to add some clarity to the different meanings in play at the moment.
22:06:41 <gfixler> I appreciate it
22:14:58 <lolisa> What does "the advantages of theft over honest toil" mean? I got it from http://lambda-the-ultimate.org/node/5196#comment-87755
22:15:07 <darkstalker> how do i apply a value to a list of functions? .. got a [a -> b], i pass a single "a" and want a [b]
22:15:43 <gfixler> darkstalker: map with $
22:15:58 <gfixler> > map ($3) [id, const 4, (*2)]
22:15:59 <lambdabot>  [3,4,6]
22:16:27 <gfixler> or fold with it
22:16:28 <darkstalker> thanks
22:18:43 <jle`> > [id, const 4, (*2)] <*> [3]
22:18:45 <lambdabot>  [3,4,6]
22:19:02 <gfixler> nice
22:19:56 <liste> lolisa I suppose chapter VII of http://people.umass.edu/klement/imp/imp.html could clarify it a bit
22:21:00 <lolisa> liste, thx
22:21:25 <gfixler> > foldr ((:) . ($3)) [] [id, const 4, (*2)]
22:21:26 <lambdabot>  [3,4,6]
22:33:32 * hackagebot chatter 0.8.0.0 - A library of simple NLP algorithms.  https://hackage.haskell.org/package/chatter-0.8.0.0 (RoganCreswick)
23:01:29 <davidar> anybody here whose brain I can pick about implementing DSLs in haskell?
23:02:34 <neuroserpens> davidar: and not return errors? xD
23:03:26 <davidar> neuroserpens (IRC): haha, ideally yes
23:03:53 <davidar> I already have something running, but there's some bits that are quite ugly and a bit buggy
23:08:48 <lolisa> Hi, when does sum and product in foldable get override? I cant think of a case where I should do so, so I want to see an example...
23:09:24 <shachaf> For example, you might have a right-biased list or a left-biased list, where you'd want foldl' or foldr' respectively.
23:09:45 <shachaf> I should say, cons list or snoc list.
23:10:23 <lolisa> Oh, I get it, thx
23:11:33 <lolisa> I was thinking of something like "AST tree of calculator" and think it is just too specific...
23:12:14 <lolisa> Nah nvrmind, that wont work
23:12:41 <Hafydd> An AST tree is also known as an ASF (Abstract Syntax Forest).
23:13:14 <bollu> if free monad ~ AST, free comonad ~ ?
23:13:26 <shachaf> Cofree comonad?
23:13:52 <bollu> oh, is that what it is called?
23:13:57 <bollu> what does "cofree" mean?
23:14:00 <bollu> free = minimal structure
23:15:27 <shachaf> It means right-adjoint to the forgetful functor.
23:15:45 <shachaf> Cofree f a = (a, f (Cofree f a))
23:17:41 <bollu> shachaf: I don't know cat theory. So "right adjoint" is lost on me
23:18:15 <bollu> shachaf: isn't that an infinite type?
23:18:24 <shachaf> Yes.
23:18:38 <shachaf> data Cofree f a = a :< f (Cofree f a)
23:18:56 <bollu> shachaf: so, you can instantiate it?
23:19:16 * lolisa wonder whether there is other funny name like dog theory or something... hot theory sounds good :)
23:19:56 <shachaf> Instantiate?
23:20:12 <bollu> shachaf: Like, I can actually create something of type "Free" because it's not infite
23:20:22 <bollu> shachaf: or even "Fix"
23:20:24 <shachaf> It depends on your choice of f, of course.
23:20:32 <bollu> shachaf: oh, right
23:20:34 <shachaf> Cofree is no more infinite than Fix is (in Haskell).
23:20:38 <bollu> (a [])
23:20:50 <shachaf> And of course infinite values are allowed in Haskell.
23:20:50 <bollu> (1, []) <- cofree?
23:20:54 <echo-area> What is :< there?
23:21:03 <shachaf> (Cofree is really codata, if you want to be picky.)
23:21:05 <shachaf> A constructor.
23:21:07 <bollu> echo-area: conjuction / parallel to (:) I'd imagine
23:21:13 <shachaf> Let's see. "right adjoint" here means that, for any functor F and comonad W, natural transformations : W ~> F are in natural correspondence with comonad homomorphisms : W ~> Cofree F
23:21:51 <shachaf> Just like, for any functor F and monad M, natural transformation : F ~> M are in natural correspondence with monad homomorphisms : Free F ~> M
23:22:01 <bollu> shachaf: is the defintion with :< legal Haskell?
23:22:12 <bollu> :k Cofree
23:22:13 <lambdabot> Not in scope: type constructor or class ‘Cofree’
23:22:17 <bollu> hm
23:22:22 <bollu> @hackage Cofree
23:22:22 <lambdabot> http://hackage.haskell.org/package/Cofree
23:22:22 <shachaf> ghci tells me that it is.
23:24:39 <echo-area> Oh, I didn't know this kind of data constructor is allowed
23:24:45 <bollu> neither did !
23:24:52 <bollu> that you can create custom syntax
23:25:15 <Hafydd> @let data UnhappyCouple a b = a :< b
23:25:17 <lambdabot>  Defined.
23:25:22 <bollu> lol
23:25:28 <bollu> :t 1 :< 3
23:25:29 <lambdabot> (Num a, Num b) => UnhappyCouple a b
23:28:23 <bollu> :t 1 :< 3 :< 5
23:28:25 <lambdabot> (Num b, Num a, Num b1) => UnhappyCouple (UnhappyCouple a b1) b
23:28:30 <bollu> hm
23:29:10 <Guest81728> 0
23:29:55 <gfixler> > let 2 + 2 = 5 in 2 + 2
23:29:56 <lambdabot>  5
23:30:24 <bollu> gfixler: all bow to the pattern-match gods
23:31:06 <gfixler> does :< exist, or only in that data type?
23:31:07 <Hafydd> bollu: that could be changed with an infixl or infixr declaration.
23:31:13 <bollu> :t (:<)
23:31:14 <lambdabot> a -> b -> UnhappyCouple a b
23:31:22 <lolisa> :t True
23:31:23 <lambdabot> Bool
23:31:48 <bollu> lolisa: what were you hoping to find? :)
23:32:02 <gfixler> "foo" :< True
23:32:05 <gfixler> > "foo" :< True
23:32:06 <lambdabot>      No instance for (Show (UnhappyCouple [Char] Bool))
23:32:06 <lambdabot>        arising from a use of ‘show_M8924172312823920466852’
23:32:06 <lambdabot>      In the expression:
23:32:14 <lolisa> > let True = False in True  || True
23:32:14 <bollu> @let Cont a r = (a -> r) -> r
23:32:14 <lambdabot>  Parse failed: Parse error in expression: a -> r
23:32:15 <lambdabot>  True
23:32:38 <bollu> @data Cont a r = Cont { cont :: (a -> r) -> r }
23:32:38 <lambdabot> Unknown command, try @list
23:32:39 <lolisa> bollu, as a Coq programmer, I have no idea whether it is true or True in haskell...
23:32:45 <bollu> lolisa
23:32:48 <bollu> ah :)
23:32:49 <bollu> well
23:33:05 <bollu> is there any structure with more "power" than Monad?
23:33:11 <bollu> also, I still don't get callcc
23:33:13 <bollu> :t callcc
23:33:14 <lambdabot>     Not in scope: ‘callcc’
23:33:14 <lambdabot>     Perhaps you meant ‘callCC’ (imported from Control.Monad.Cont)
23:33:21 <bollu> :t callCC
23:33:22 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
23:33:25 <bollu> like, what is that?!
23:33:28 <gfixler> I thought arrow was more powerful
23:33:37 <bollu> gfixler: I think Applicative < Arrow < Monad
23:33:43 <gfixler> bollu: ah
23:33:55 <bollu> because Arrow can parse some context sentitive grammar while Monad can parse all of it IIRC
23:34:03 <bollu> applicative can only parse context-free
23:34:07 <gfixler> right
23:34:12 <gfixler> I've played a bit at the low end
23:34:18 <gfixler> I made a bowling scorer as an applicative parser
23:34:33 <lolisa> (Ord a, Monad a) is more powerful than Monad a for sure :) seriously I dont know too
23:34:43 <gfixler> strike <*> spare <*> open <*> etc
23:36:05 <bollu> geekosaur, Cale, johnw, could anyone explain callCC to me?
23:36:13 <bollu> other than "let the types flow through you"
23:36:16 <bollu> :)
23:36:32 <lolisa> > let True || True = False in True  || True
23:36:33 <lambdabot>  False
23:36:54 <lolisa> > let True || True = False in True || False
23:36:55 <lambdabot>  *Exception: <interactive>:3:5-24: Non-exhaustive patterns in function ||
23:37:05 <lolisa> Oh it make sense now
23:39:59 <sudeep> hi
23:40:01 <sudeep> guys
23:40:15 <sudeep> ihave done haskell for a year
23:40:35 <sudeep> i want to organize workshop on functional programming with haskell
23:40:44 <sudeep> can i get some reference for it
23:40:48 <bollu> sudeep: cool, what do you wanna show?
23:41:10 <sudeep> bollu: i want to give basic idea about haskell
23:41:48 <sudeep> bollu: i am thinking of including things like basic functions, typeclasses etc
23:41:58 <bollu> sudeep: IIRC, I think chpatrick was orgainizing a meetup, so you guys could swap notes
23:42:02 <sudeep> bollu: where are you from?
23:42:06 <bollu> sudeep: um, India
23:42:15 <sudeep> bollu: i am from Nepal
23:42:22 <bollu> sudeep: cool :)
23:42:30 <bollu> sudeep: I think typeclasses maybe a bit heavy initally
23:42:40 <sudeep> bollu: just a touch
23:42:41 <bollu> sudeep: maybe go through LYAH, and try and pick up a similar style?
23:43:05 <bollu> If I were you, I would show some of the "cool parts" like inifinite lists and higher order functions
23:43:09 <sudeep> bollu: what is the workshop of haskell without the taste of type class :D 
23:43:37 <sudeep> bollu: cool parts for begineers who just have a programming knowledge will be insane?
23:43:50 <bollu> sudeep: lists, infinite types, lambda calculus, stuff like ($) and (|>) and (.), 
23:43:59 <sudeep> bollu: so do you have some twitter or any other social media we can connect togther
23:44:12 <bollu> sudeep: um, you could have my e-mail id
23:44:21 <sudeep> bollu: ok
23:44:29 <bollu> ask nickserv for my info
23:44:43 <bollu> message nickerv like this: "/msg nickserv info bollu"
23:44:47 <bollu> It'll give you info :)
23:45:06 <bollu> sudeep: I'm no  haskell expert, though
23:45:07 <sudeep> hehe i know that but yours is hidden
23:45:12 <bollu> really? 
23:45:13 <bollu> oh, oka
23:45:23 <sudeep> bollu: me too i am just tasting this language 
23:45:29 <sudeep> bollu: what others do you do?
23:45:46 <bollu> sudeep: language wise?
23:46:13 <bollu> um, some C, C++, Python and Rust
23:46:20 <bollu> I mess about with others as well, but, yeah
23:46:48 <Guest78> when should I use lenses
23:47:12 <bollu> geekosaur: ping?
23:47:31 <srhb> Guest78: You needn't. But it's really nice especially for diving into nested records.
23:47:44 <bollu> srhb: do you understand how callCC works?
23:47:50 <bollu> cause i really need some help grokking it
23:48:38 <Guest78> srhb:  ok, so is it just a convenient setter/getter
23:48:56 <jle`> that's one application
23:48:57 <srhb> Guest78: It does provide very convenient getters and setters, yes. :)
23:49:11 <jle`> there are other applications, but that's just one that gets mentioned the most :)
23:49:17 <echo-area> bollu: Maybe you could first read https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
23:49:27 <bollu> echo-area: thanks :)
23:50:54 <lolisa> bollu: Cool, I like indian, I have befriends with some indian for time. Do you have a github?
23:51:14 <bollu> lolisa: yeah. 	https://github.com/bollu/
23:51:20 <Guest78> srhb: another question, I am writing a server with multiple tables of connected clients, this is a global state somehow, I managed to handle one table using StateT, how can I add other states and is lenses useful here
23:52:11 <jle`> Guest78: if you have a bunch of StateT s's with different s's, StateT s, StateT t, StateT u, etc., then you can "merge them together" and sequence them under one big fatty state with lenses
23:53:01 <jle`> so you can write all of your stateful code just worrying about the state they need to worry about
23:53:16 <jle`> and then merge/sequence them all as if they worked on a big fatty state containing everything
23:54:01 <jle`> a concrete example...if my state was (Int, Bool), but sometimes I want to only work on the Int, and sometimes I only want to work on the Bool
23:54:10 <bollu> question about monad transformers: How do I write a -> Either (a, s) err v/s a -> (Either a err, s) using monad transformers? I'm not clear on the order of composition
23:54:21 <jle`> then I can write those parts as State Int, and those other parts as State Bool, and not care about the "other part of the tuple"
23:54:39 <jle`> and then use zoom _1 :: State Int a -> State (Int, Bool) a, zoom _2 :: State Bool a -> State (Int, Bool) a
23:54:49 <jle`> and now you can use them together :O
23:55:10 <jle`> bollu: you probably meant to switch your order of your Either arguments, right?
23:55:16 <bollu> jle`: ah, right
23:55:25 <Guest78> jle' : in your example you use a tuple and lenses to access them , is this the best way to manage multiple states (using tuples) ?
23:55:45 <bollu> jle`: but, well, what would the monad transformer stack look like for both?
23:55:51 <Guest78> jle` : in your example you use a tuple and lenses to access them , is this the best way to manage multiple states (using tuples) ?
23:55:59 <jle`> bollu: StateT s m a = s -> m (a, s)
23:56:09 <jle`> so StateT s (Either e) a = s -> Either e (a, s)
23:56:13 <srhb> Guest78: Substitute in your own custom record. :)
23:56:22 <Guest78> OK I see
23:56:27 <jle`> bollu: EitherT e m a = m (Either e a)
23:56:28 <srhb> Guest78: Tuples are just handy for the explanation because they don't require predefinition.
23:56:45 <bollu> jle`: ahh. I see. So they apply outside-in
23:57:23 <jle`> bollu: so EitherT e (State s) a = State s (Either e a) = s -> (Either e a, s)   (if you take State s a = s -> (a, s))
23:57:36 <jle`> bollu: i don't think "outside-in" is a useful rule to keep track of
23:57:43 <jle`> the best way is just to manually expand the type synonyms
23:58:01 <jle`> StateT s m a is literally just a newtype wrapper over s -> Either e (a, s)
23:58:03 <bollu> jle`: oh, alright. It's just that it gets kinda ugly
23:58:06 <jle`> so they're identical at runtime
23:58:15 <Guest78> in this link there is also the netwire solution http://stackoverflow.com/questions/13915923/combining-multiple-states-in-statet, and I think Gabriel Gonzalez is using a simple lense solution
23:58:15 <jle`> er, StateT s (Either e) a
23:58:27 <jle`> Guest78: I think that's the best way if you are using State
23:58:35 <jle`> i don't think using State is the best way to work with state in general
23:58:51 <jle`> but if you *have* to use State, using lenses with zoom is probably the best way to manage it reasonably
23:59:00 <bollu> what's the diff between monoid and category?
23:59:15 <bollu> monoid is assoc, id
23:59:21 <bollu> category is..?
23:59:23 <liste> bollu look at the types
23:59:28 <jle`> a monoid can be considered a category whose set of objects has only one object
23:59:30 <Guest78> bollu: monoid is a single object category
23:59:46 <echo-area> jle`: Could you elaborate on the point of the best way to work with state?  Thanks
23:59:54 <bollu> Guest11352: ah, right. I was shown the construction
