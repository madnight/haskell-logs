00:04:34 <julianleviston> Can I import Data.Map in such a way that I can use the constructor by itself (ie Map Int Int) as well as having a qualified name for the functions (such as Map.elems or Map.empty) ?
00:04:37 * hackagebot peyotls-codec 0.3.1.0 - Codec parts of Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-codec-0.3.1.0 (YoshikuniJujo)
00:05:09 <liste> julianleviston import qualified Data.Map as Map; import Data.Map (Map)
00:05:19 <julianleviston> the imports page in haskell.org isn‚Äôt particulaly helpful https://wiki.haskell.org/Import
00:05:21 <julianleviston> ah ok thanks
00:05:26 <liste> actually import Data.Map (Map(Map))
00:05:32 <liste> if the value constructor is visible
00:05:33 <julianleviston> I just missed the last line.
00:05:35 <liste> which I doubt
00:05:51 <julianleviston> um‚Ä¶ not sure what that means, sorry.
00:06:07 <julianleviston> what‚Äôs a value constructor? is that a data constructor?
00:06:10 <liste> the word "constructor" can mean either type or value constructors"
00:06:23 <julianleviston> oh I thought that was called a data constructor. Ok. Gotcha
00:06:38 <liste> Map Int Int is a type constructor (Map) applied to two Ints
00:06:52 <julianleviston> liste: what‚Äôs going on when you write import Data.Map (Map(Map))
00:06:59 <julianleviston> I don‚Äôt understand (Map(Map))
00:07:11 <julianleviston> does that mean ‚Äúthe value constructor‚Äù?
00:07:21 <liste> it imports the type constructor Map and a value constructor Map
00:07:31 <srhb> The inner one being the value/data constructor
00:07:38 * hackagebot flowdock-rest 0.1.0.0 - Flowdock REST API  https://hackage.haskell.org/package/flowdock-rest-0.1.0.0 (phadej)
00:07:38 * hackagebot peyotls-codec 0.3.1.0 - Codec parts of Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-codec-0.3.1.0 (YoshikuniJujo)
00:07:52 <srhb> Also you could get this by just one line: import Data.Map as Map if you don't mind polluting your namespace.
00:07:52 <julianleviston> cool
00:08:00 <srhb> It would import all of it both qualified and unqualified
00:08:13 <julianleviston> ah ok
00:08:32 <julianleviston> I‚Äôd like it unpolluted, so ‚Ä¶ cool :) thanks for the option tho‚Ä¶ now I know a bit more about what qualified does.
00:08:57 <julianleviston> Oh.. I got Module ‚ÄòData.Map‚Äô does not export ‚ÄòMap(Map)‚Äô
00:09:12 <srhb> Because the value constructor isn't actually called Map afaik
00:09:20 <julianleviston> Ah
00:09:24 <liste> you shouldn't use the value constructor
00:09:26 <srhb> (You never construct a Map via that anyway)
00:09:33 <liste> use the functions
00:10:25 <julianleviston> the code has this data Server = Server { clients :: TVar (Map ClientName Client) }
00:10:38 <julianleviston> that‚Äôs not the value constructor it‚Äôs the type consrtuctor, right?
00:10:50 <julianleviston> so I can just write import Data.Map (Map) ?
00:11:13 <julianleviston> err  I mean import Data.Map (Map())
00:11:47 <srhb> Correct
00:12:22 <anohigisavay> hi. i never really understand the idea what `forall` means. i got most of the sense from https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
00:12:24 <julianleviston> cool :) 
00:12:35 <julianleviston> anohigisavay:  oh gosh‚Ä¶ 
00:12:44 <julianleviston> anohigisavay: there‚Äôs a REALLY good answer on SO about this‚Ä¶
00:12:45 <liste> btw does newtype introduce data constructors?
00:12:53 <julianleviston> anohigisavay: I was just reading it. Let me find it for you
00:12:57 <liste> never really got the hang of that term...
00:13:15 <anohigisavay> julianleviston: :) many thanks
00:13:29 <julianleviston> anohigisavay: don‚Äôt just read the first answer‚Ä¶ http://stackoverflow.com/questions/3071136/what-does-the-forall-keyword-in-haskell-ghc-do
00:13:47 <julianleviston> anohigisavay:  I recommend the answer that starts with No. (Well, maybe Don Stewart can.)
00:14:04 <anohigisavay> julianleviston: coool
00:14:06 <julianleviston> he enumerates the things forall is used for
00:14:47 <julianleviston> one of which involves reading and understanding System F and higher rank types and the runST paper by Peyton-Jones
00:15:52 <julianleviston> anohigisavay: but others will probably have better answers, so don‚Äôt by any means treat my answer as the best one
00:17:06 <liste> there's a forall in every type signature, but it's just implicit
00:17:20 <liste> id :: a -> a is really id :: forall a. a -> a
00:17:57 <thatzissouface> --tutbot
00:18:10 <julianleviston> liste I never really understood what the dot was there wor ‚Äúforall a.‚Äù <-
00:18:18 <julianleviston> wor = for*
00:19:42 <liste> it just tells when the forall ends
00:19:48 <liste> it's borrowed directly from math
00:21:42 <liste> ‚àÄx. x ‚à® x => forall x. Either x x
00:24:31 <julianleviston> ah ok.
00:25:49 <liste> also forall can have multiple variables: forall a b. a -> b -> a
00:26:32 <julianleviston> liste: if this is for me, no need. It‚Äôs just noise unfortunately.
00:26:38 <julianleviston> liste:  (for me)
00:26:48 <julianleviston> if it‚Äôs for others, sweet :)
00:27:29 <julianleviston> does a pattern match on something like server@Server{..} mean ‚Äúget only the server record out of the passed in Server ?
00:27:55 <julianleviston> or does it also bind all the rest? Just wondering what the @ synax does.
00:28:02 <liste> it binds all the rest too
00:28:07 <liste> with RecordWildCards
00:28:08 <opqdonut> julianleviston: no, it means "pattern match against Server, disregard the fields, call the whole thing server"
00:28:16 <opqdonut> liste: oh right, forgot about those
00:28:19 <julianleviston> ahhhh
00:28:27 <opqdonut> julianleviston: anyway, the @ syntax gives you an alias for the whole thing
00:28:28 <liste> server@Server{} would just take the whole record
00:28:29 <julianleviston> why wouldn‚Äôt they just write server
00:28:39 <opqdonut> e.g. "theWholeList@(x:xs))"
00:28:55 <opqdonut> julianleviston: record wild cards, {..} binds the variable "foo" to the field "foo", for all fields
00:29:07 <julianleviston> yeah, but why server@Server{..} why not server@Server{} or server
00:29:07 <julianleviston> opqdonut oh of course
00:29:08 <julianleviston> gotcha
00:29:12 <opqdonut> (see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html)
00:29:26 <julianleviston> so ‚Äúmatch every single one, and call the whole thing server‚Äù sweet. I should have known that
00:31:01 <liste> also foo@Bar is useful because it only matches one constructor of a sum type
00:31:08 <julianleviston> also I keep seeing atomically $ do ‚Ä¶ why is there a $ needed there? what‚Äôs taking place?
00:31:37 <opqdonut> julianleviston: otherwise parens would be needed
00:31:39 <liste> julianleviston it's equivalent to atomically (do ...)
00:32:02 <julianleviston> liste:  yeah, that‚Äôs my question - why is it needed? why can‚Äôt you just say atomically do ...
00:32:07 <liste> precedence rules
00:32:11 <julianleviston> the do is a whole block, afterall, right?
00:32:13 <opqdonut> julianleviston: it's a syntax error, unfortunately
00:32:23 <opqdonut> yeah, it could work, but that's not how the spec was written
00:32:23 <srhb> julianleviston: atomically do tries to apply atomically to do
00:32:26 <liste> how would you tell when the do ends?
00:32:31 <srhb> Well
00:32:32 <julianleviston> AHH ok
00:32:32 <opqdonut> liste: indentation
00:32:33 <srhb> That's not quite true
00:32:34 <merlin2> how can I add one month to UTCTime?
00:32:40 <srhb> It _would_ mean that, but it's a syntax error :-)
00:32:41 <julianleviston> liste using layout rules, I‚Äôd assumed
00:32:55 <srhb> julianleviston: There's actually a proposal for that extension in the wild currently.
00:33:01 <julianleviston> ah ok sweet
00:33:25 <srhb> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/118056
00:33:41 <athan> Hrm, is MaybeT intended to follow the same monadic logic as Maybe?
00:33:53 <srhb> athan: MaybeT SomeMonad is
00:34:15 <athan> It seems as though lifting values forces them to have an embedded Maybe result
00:34:29 <athan> MaybeT m a ~ m (Maybe a)
00:34:31 <Ana_Ng> hi
00:34:44 <liste> Ana_Ng hi
00:34:53 <julianleviston> Why don‚Äôt I need it ($) around an else branch then?
00:35:02 <Ana_Ng> what is up homeslice
00:35:14 <merlin2> given an arbitrary UTCTime that is set to first day of the month how can I get 1st day of the following month?
00:35:23 <echo-area> 6 (1 bound, 5 peak workers (5 total), using -N2)  Is this normal?
00:35:58 <echo-area> I checked with threadscope and see that one worker was almost idle
00:36:05 <echo-area> *saw
00:36:31 <echo-area> SPARKS: 15 (0 converted, 0 overflowed, 0 dud, 15 GC'd, 0 fizzled)
00:36:50 <athan> srhb: So for something like `mxs :: Maybe [a]`, how would you write the analogue of `xs <- mxs; return $ length xs` with MaybeT?
00:36:51 <echo-area> This is obviously not normal since none was converted
00:37:05 <echo-area> I still cannot figure out why.
00:37:33 <liste> merlin2 addGregorianMonthsClip ?
00:39:43 <liste> > (\utc -> utc {utctDay = addGregorianMonthsClip 1 (utctDay utc)}) 0
00:39:45 <lambdabot>      ‚ÄòutctDay‚Äô is not a (visible) constructor field nameNot in scope: ‚ÄòaddGre...
00:40:09 <liste> @let import Data.Time
00:40:10 <lambdabot>  .L.hs:113:1:
00:40:10 <lambdabot>      Data.Time: Can't be safely imported!
00:40:10 <lambdabot>      The package (time-1.5.0.1) the module resides in isn't trusted.
00:40:11 <merlin2> > addGregorianMonthsClip 1 (fromGregorian 2013 12 1) 
00:40:12 <lambdabot>  Not in scope: ‚ÄòaddGregorianMonthsClip‚ÄôNot in scope: ‚ÄòfromGregorian‚Äô
00:40:18 <merlin2> it works cheers
00:40:20 <athan> merrrrrr
00:40:22 <liste> yw (:
00:41:08 <liste> I always forget lambdabot can't Data.Time :(
00:42:35 * hackagebot tasty-expected-failure 0.11 - Mark tasty tests as failure expected  https://hackage.haskell.org/package/tasty-expected-failure-0.11 (JoachimBreitner)
00:48:28 <merlin2> why can't Date.Time be safely imported?
00:49:01 <shachaf> The next line tells you the reason.
00:49:41 <merlin2> it doesn't tell me why it isn't trusted
01:01:02 <Cale> merlin2: because nobody set a flag on it saying that it was
01:08:17 <jle`> athan: well
01:08:28 <jle`> athan: data MaybeT m a = MaybeT m (Maybe a)
01:09:00 <jle`> athan: so MaybeT m a is literally identical to m (Maybe a), except for typechecker things and typeclass resolution
01:09:07 <jle`> er, MaybeT (m (Maybe a))
01:09:46 <jle`> the only reason MaybeT exists is the same reason that Sum, Product, First, Last, Endo, etc. exist
01:09:52 <jle`> newtype hacks to give different instances :)
01:22:37 * hackagebot yesod-pnotify 1.0.2 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-1.0.2 (KatsutoshiItoh)
01:53:09 * nshepperd_ used mergesort to sort a pile of books today
01:54:40 <nshepperd_> Immutability. It works!
01:55:00 <srhb> I bet you mutated your home.
01:55:06 <nshepperd_> But my evaluation strategy was eager, I guess
01:57:22 <arkeet> nshepperd: I like radix sort for sorting books and the like.
01:57:39 * hackagebot yesod-auth-kerberos 1.4.3 - Kerberos Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-kerberos-1.4.3 (ArashRouhani)
01:59:25 <Peaker> jle`: I wouldn't say MaybeT is like Sum -- Sum is to choose a Monoid instance where no "default" one makes sense.  "MaybeT" is to replace the default instance (of the outer type constructor) with the one for the composition
01:59:36 <Peaker> so a bit similar, but different :)
02:01:06 <jle`> Peaker: to me they're both just hacks to deal with quirks of an imperfect typeclass system, heh
02:02:43 <Peaker> jle`: I disagree -- you'd have to choose an instance in these cases anyway. Choosing it this way or with some explicit dictionary parameter is pretty much equivalent
02:02:57 <Peaker> (so it seems quite optimal to me)
02:05:11 <jle`> i don't know what the ideal way would be; this way has a lot of syntactic overhead that may or may not be more than dictionary-passing in different situations
02:05:30 <jle`> newtypes to choose instances always felt like a hacky solution to me anyways
02:05:50 <jle`> there's a lot of syntactic overhead involved to just use MaybeT in any useful way
02:05:53 <Peaker> I think with the right combinators usually the syntactic overhead is pretty minimal
02:06:12 <nshepperd__> Radix sort huh. I guess that would be better with a larger number of books
02:06:37 <jle`> runMaybeT . asum . map MaybeT, instead of just `asum` ?
02:06:38 <Peaker> if you have mtl-lifted actions, then you just have to throw a runMaybeT somewhere, and use the maybeT construction functions
02:06:52 <jle`> the wrapping/unwrapping functions are exactly what I mean
02:07:03 <jle`> i'd love to be able to do asum [m (Maybe a)] -> m (Maybe a)
02:07:36 <jle`> or use any of the convenient instances on m (Maybe a)'s, without going through the overhead of adding the MaybeT wrapper, and then removing it
02:07:41 <Peaker> you will always have to disambiguate the two possible instances
02:07:53 <Peaker> so you'll have to mention the MaybeT (or equivalent info) at least once
02:08:55 <jle`> yeah, but the wrapping/unwrapping, should i map this, should i not? etc. feels kind of an awkward "solution"
02:09:24 <jle`> same for Endo, Sum, etc. in most cases, but there are at least those generic combinators that cover some specific situations
02:09:40 <Peaker> you could have asumAla MaybeT
02:10:18 <jle`> yeah, that's what i was referring to; but they still tend to be things for specific situations
02:10:34 <Peaker> or something more general than that, but you could say the packing/unpacking are not really redundant (vs. just mentioning once) because they delimit the instance choice over a range of code
02:10:53 <Peaker> instead of explicitly choosing the instance in every function 
02:11:24 <jle`> dictionary passing doesn't seem like a very nice way of doing things either though heh
02:11:53 <jle`> i guess i can't really offer any better "solution", just the sense that using newtypes in this way is an abuse of their original intent in an unsatisfying way
02:11:59 <jle`> but it could be that it's the best we got
02:12:44 <Peaker> instance selection is a must, there's true ambiguity here.. either you select it via "range" (from here to there) [newtypes] or you select it at each operation, but the solution sounds optimal to me (range is no worse in general case, even if slightly worse for singular functions)
02:12:54 <jle`> maybe if we had a graphical editor we can just draw circles delimiting which ones we want on our source code :O
02:13:04 <jle`> weren't some people working on that
02:13:23 <Peaker> I'm working on Lamdu, which is non-textual but also non-graphical
02:13:29 <Peaker> (it's just structural)
02:13:54 <jle`> my joke definitely missed the mark then ;_;
02:14:11 <Peaker> sounds realistic to me :)
02:14:38 <r4nd0m> made my morning @jle`
02:14:39 <jle`> maybe thinking of newtype wrappers/unwrappers as "brackets" would make it seem nicer
02:15:28 <jle`> r4nd0m: :D
02:25:22 <marcvreuls> 
02:25:24 <marcvreuls> quit
02:34:15 <yashinbasement> HI there , I want a unique list of list where no (element of list) gets reapeated in whole list of list , for example if i do [["C2", "D2",] ["C2", "E2"]] so I want unique [["C2,"D2"]] 
02:35:17 <yashinbasement> https://gist.github.com/ynarwal/6d03234fd6b73c90022d
02:36:04 <yashinbasement> it gives me binding problem I don't know what's wrong
02:36:38 <frerich> yashinbasement: In your example, why isn't the result ["C2", "E2"] ?
02:37:07 <srhb> :t nubBy (comparing fst)
02:37:09 <lambdabot>     Couldn't match type ‚ÄòOrdering‚Äô with ‚ÄòBool‚Äô
02:37:09 <lambdabot>     Expected type: (a, b) -> (a, b) -> Bool
02:37:09 <lambdabot>       Actual type: (a, b) -> (a, b) -> Ordering
02:37:16 <srhb> Oh right
02:37:40 * hackagebot tasty-expected-failure 0.11.0.1 - Mark tasty tests as failure expected  https://hackage.haskell.org/package/tasty-expected-failure-0.11.0.1 (JoachimBreitner)
02:38:07 <srhb> Also those were lists. Derp
02:38:08 <yashinbasement> as long as gives me unique it's fine it was just exampple
02:38:46 <srhb> yashinbasement: Well, you could do it with nubBy, but maybe a different datatype would be suitable.
02:39:10 <srhb> It sounds like multimap may be useful.
02:41:21 <Gurkenglas> What is to asum as foldMap is to fold?
02:41:54 <liste> :t asum . map
02:41:58 <lambdabot> Foldable ((->) [a1]) => (a1 -> a) -> [a]
02:42:28 <liste> oh
02:43:56 <Gurkenglas> @let asumMap f = asum . fmap f -- meh
02:43:58 <lambdabot>  Defined.
02:44:34 <Gurkenglas> :t ala MaybeT asumMap -- jle`
02:44:37 <lambdabot> (Monad n, Functor t, Foldable t) => t (n (Maybe b)) -> n (Maybe b)
02:52:41 * hackagebot jobqueue 0.1.6 - A job queue library  https://hackage.haskell.org/package/jobqueue-0.1.6 (ikehara)
02:54:17 <Gurkenglas> How do I find all the "Simple Iso"s Data.Lens provides?
02:58:30 <Gurkenglas> :t _sum
02:58:32 <lambdabot>     Found hole ‚Äò_sum‚Äô with type: t
02:58:32 <lambdabot>     Where: ‚Äòt‚Äô is a rigid type variable bound by
02:58:32 <lambdabot>                the inferred type of it :: t at <interactive>:1:1
02:58:45 <Gurkenglas> Why isn't this the Isomorphism for Sum from Data.Monoid.Lens?
03:02:24 <Gurkenglas> :t (ala MaybeT . alaf Alt) foldMap -- Aha! jle`
03:02:26 <lambdabot> (Monad n, Foldable t) => t (n (Maybe b)) -> n (Maybe b)
03:04:45 <Gurkenglas> Should all the low-level libraries be rewritten using the high-level libraries?
04:03:36 <tsahyt> I'm implementing an algorithm that basically has type [Int] -> [[Int]] (where those ints are reference numbers) but can discard elements of the input list depending on the results of previous elements. Is there an abstraction that encapsulates this? I guess I can build it from a fold of course, but I was curious whether this particular pattern already exists somewhere
04:06:56 <merijn> Is there a way to find wiki pages you authored on the GHC wiki? I forgot the name of one of my proposals :p
04:07:37 <merijn> tsahyt: looks like a scanl/scanr type dealio
04:10:57 <tsahyt> merijn: I guess it's possible to implement it in terms of scan too, if only for last (scanl f z xs) == foldl f z xs, but I don't think it's particularly clean in this case. I want to be able to inspect results for all k - 1 processed elements when I'm processing element k.
04:12:48 <tsahyt> I guess the type would be something like (History -> a -> b) -> [a] -> [b], where History is the list of bs so far.
04:14:27 <tsahyt> With that I could build my "history aware map", (a -> [b] -> Bool) -> (a -> b) -> [a] -> [b], which discards an 'a' if the 'b's so far satisfy some property, and otherwise applies the function to it.
04:22:39 <tsahyt> \p f -> foldr (\x hist -> (if p x hist then f x : hist else hist)) []
04:22:52 <tsahyt> This satisfies the type at least, and I think it should do what I want it to do.
04:27:46 * hackagebot tasty-ant-xml 1.0.2 - Render tasty output to XML for Jenkins  https://hackage.haskell.org/package/tasty-ant-xml-1.0.2 (OliverCharles)
04:27:48 * hackagebot tasty-rerun 1.1.5 - Run tests by filtering the test tree depending on the result of previous test  runs  https://hackage.haskell.org/package/tasty-rerun-1.1.5 (OliverCharles)
04:37:46 * hackagebot amazonka-core 1.3.1 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.3.1 (BrendanHay)
04:37:48 * hackagebot amazonka 1.3.1 - Comprehensive Amazon Web Services SDK  https://hackage.haskell.org/package/amazonka-1.3.1 (BrendanHay)
04:37:50 * hackagebot amazonka-test 1.3.1 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.3.1 (BrendanHay)
04:37:52 * hackagebot amazonka-config 1.3.1 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.3.1 (BrendanHay)
04:37:54 * hackagebot amazonka-sns 1.3.1 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.3.1 (BrendanHay)
04:38:25 <liste> it's amazonka time again!
04:41:51 <Saizan> oh boy!
04:42:54 <Gurkenglas> Is there a when for monoid rather than applicatives?
04:42:56 * hackagebot amazonka-sqs 1.3.1 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.3.1 (BrendanHay)
04:42:58 * hackagebot amazonka-glacier 1.3.1 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.3.1 (BrendanHay)
04:43:00 * hackagebot amazonka-cloudhsm 1.3.1 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.3.1 (BrendanHay)
04:43:02 * hackagebot amazonka-datapipeline 1.3.1 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.3.1 (BrendanHay)
04:43:04 * hackagebot amazonka-iam 1.3.1 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.3.1 (BrendanHay)
04:44:53 <merijn> Gurkenglas: Not really
04:45:08 <merijn> Gurkenglas: What did you want to do?
04:45:42 <Gurkenglas> merijn, use Endo to simplify (\x hist -> (if p x hist then f x : hist else hist))
04:47:40 <merijn> I don't understand immedaitely how that would work :)
04:48:06 * hackagebot amazonka-route53-domains 1.3.1 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.3.1 (BrendanHay)
04:48:08 * hackagebot amazonka-directconnect 1.3.1 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.3.1 (BrendanHay)
04:48:10 * hackagebot amazonka-devicefarm 1.3.1 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.3.1 (BrendanHay)
04:48:12 * hackagebot amazonka-cognito-sync 1.3.1 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.3.1 (BrendanHay)
04:48:14 * hackagebot amazonka-elb 1.3.1 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.3.1 (BrendanHay)
04:48:16 <merijn> But I doubt you can do it, since you can't know whether a value is mempty unless you have an Eq instance
04:51:18 <Gurkenglas> merijn, I mean something like "whenm (p x hist) $ Endo (f x :)"
04:53:16 * hackagebot amazonka-cloudformation 1.3.1 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.3.1 (BrendanHay)
04:53:18 * hackagebot amazonka-sts 1.3.1 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.3.1 (BrendanHay)
04:53:20 * hackagebot amazonka-kinesis 1.3.1 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.3.1 (BrendanHay)
04:53:22 * hackagebot amazonka-cloudsearch-domains 1.3.1 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.3.1 (BrendanHay)
04:53:24 * hackagebot amazonka-cloudwatch 1.3.1 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.3.1 (BrendanHay)
04:55:45 <roelof> Im learning Haskell by the craft book. Now in a exercise is stated : make your own definitions of the build in && and || . Do I have to make a sort of table with true && true or 
04:56:05 <roelof> do I have to do somethinge else. I find this exercise not clear written 
04:56:30 <tdammers> roelof: the task should be pretty clear
04:56:42 <tdammers> write a function (&&) that behaves exactly like the built-in one
04:56:47 <tdammers> :t (&&)
04:56:48 <lambdabot> Bool -> Bool -> Bool
04:56:56 <tdammers> that's the type signature
04:57:18 <liste> so you may need to import Prelude hiding ((&&))
04:57:21 <roelof> oke, so I have to do something like this : && true true = true  
04:57:31 <tdammers> it's True, not true
04:57:40 <roelof> sorry, typo 
04:58:02 <tdammers> also, if you want to use it prefix style, you need to parenthesize it
04:58:07 <tdammers> > (&&) True True
04:58:09 <lambdabot>  True
04:58:27 * hackagebot amazonka-cloudtrail 1.3.1 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.3.1 (BrendanHay)
04:58:29 * hackagebot amazonka-elasticache 1.3.1 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.3.1 (BrendanHay)
04:58:31 * hackagebot amazonka-importexport 1.3.1 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.3.1 (BrendanHay)
04:58:33 * hackagebot amazonka-s3 1.3.1 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.3.1 (BrendanHay)
04:58:35 * hackagebot amazonka-swf 1.3.1 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.3.1 (BrendanHay)
04:58:36 <tdammers> other than that, you're on the right track
04:58:52 <merijn> Man...can we filter specific people/packages from hackagebot updates? >.>
04:58:59 <merijn> I'm getting kinda sick of amazonka
04:59:06 <bernalex> merijn: /ignore
04:59:12 <tdammers> bernalex: too coarse
04:59:31 <bernalex> tdammers: how is /ignore-ing lambdabot's "/me hackagebot amazonka-*" too coarse?
04:59:44 <bernalex> sounds like exactly what he wants.
04:59:59 <tdammers> I assumed just "/ignore hackagebot"
05:00:13 <bernalex> eh s/lambda/hackage/
05:00:24 <mniip> I wonder how well does hackagebot handle extra long descriptions
05:00:26 <bernalex> and s/hackagebot //
05:00:32 <bernalex> idk how I thought it was lambdabot saying /me hackagebot, lol.
05:01:36 * mniip hackagebot base 5.0.0.0 - https://hackage.haskell.org/package/base (ghc)
05:02:02 <Gurkenglas> tsahyt, https://hackage.haskell.org/package/witherable-0.1.3/docs/Data-Witherable.html sounds related
05:03:32 <ski> roelof : `True && True = True' would also work
05:03:37 * hackagebot amazonka-sdb 1.3.1 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.3.1 (BrendanHay)
05:03:39 * hackagebot amazonka-codecommit 1.3.1 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.3.1 (BrendanHay)
05:03:41 * hackagebot amazonka-codedeploy 1.3.1 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.3.1 (BrendanHay)
05:03:43 * hackagebot amazonka-cloudfront 1.3.1 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.3.1 (BrendanHay)
05:03:45 * hackagebot amazonka-efs 1.3.1 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.3.1 (BrendanHay)
05:03:53 <ski> roelof : and .. you don't have to write a full truth table (but you can, if you want to)
05:05:45 <roelof> oke, I have this (http://lpaste.net/140525) so far. I hope it's all good Haskell 
05:06:19 <merijn> roelof: It's valid haskell, but you can simplify a little bit
05:06:25 <merijn> roelof: By using wildcard patterns
05:06:57 <mniip> roelof, counterexample
05:07:08 <roelof> merijn: thanks, can you give a example what you mean 
05:07:11 <mniip> > False && undefined
05:07:13 <lambdabot>  False
05:07:13 <merijn> roelof: For example, currently you've written all possible combinations for &&, but you can simplify this by realising that "True && True = True" is the only case producing True
05:07:51 <merijn> roelof: All others are false, so you can skip defining those and simply write "True && True = True; _ && _ = False"
05:08:19 <mniip> merijn, but short circuiting
05:08:27 <Axman6> True && x = x; _ && _ = False
05:08:34 <roelof> oke, In the book there is no mentioned about _ . I have seen it on other languages 
05:08:38 <merijn> Axman6: Not much added value
05:08:42 <tsahyt> roelof: You can also implement xor in terms of && and ||.
05:08:47 * hackagebot amazonka-codepipeline 1.3.1 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.3.1 (BrendanHay)
05:08:49 * hackagebot amazonka-elasticbeanstalk 1.3.1 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.3.1 (BrendanHay)
05:08:51 * hackagebot amazonka-autoscaling 1.3.1 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.3.1 (BrendanHay)
05:08:53 * hackagebot amazonka-ses 1.3.1 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.3.1 (BrendanHay)
05:08:55 * hackagebot amazonka-support 1.3.1 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.3.1 (BrendanHay)
05:09:14 <merijn> > let test True True = True; test _ _ = False in test False undefined
05:09:16 <lambdabot>  False
05:09:17 <Axman6> merijn: yeah, I was thinking "we can avoid evaluating an argument" but clearly I'm an idiot and should go to bed =)
05:09:25 <roelof> tsahyt:  can you give me a example of that 
05:09:37 <merijn> Axman6: If the first match fails it never matches the second and avoids evaluating it anyway :)
05:10:05 <Axman6> yeah
05:10:24 <merijn> oh, I see what you mean, but I don't think it matters? Not sure
05:10:38 <mniip> I just realised
05:10:48 <tsahyt> roelof: Well you need "not" as well, but those three things are functionally complete. You can implement *any* function Bool -> Bool -> Bool with just those three. For example, a `xor` b = (a || b) && not (a && b).
05:11:00 <mniip> most of these amazonka updates are just dependency bumps
05:11:10 <ski> roelof : you could use variable names like `x',`y' instead of the "anonymous variable"/wildcard `_'
05:12:15 <roelof> tsahyt:  thanks, that sound more complicated and you are also using not 
05:12:35 <Axman6> mniip: are you responsible for amazonka?
05:12:40 <mniip> no
05:12:59 <Axman6> shame, it's really impressive. been looking for an opportunity to use it
05:13:11 <Gurkenglas> If that's just dependency dumps, does that mean they use the upper bound <=1.3.1 instead of <1.4?
05:13:29 <mniip> 1.3.1-* or something
05:13:35 <tsahyt> roelof: Yeah, maybe, but I thought you should see it regardless. It's a lot easier for a => b though (where => is "implies"). You could try that as an exercise.
05:13:36 <mniip> overly specific
05:13:57 * hackagebot amazonka-dynamodb-streams 1.3.1 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.3.1 (BrendanHay)
05:13:59 * hackagebot amazonka-redshift 1.3.1 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.3.1 (BrendanHay)
05:14:01 * hackagebot amazonka-opsworks 1.3.1 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.3.1 (BrendanHay)
05:14:03 * hackagebot amazonka-emr 1.3.1 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.3.1 (BrendanHay)
05:14:05 * hackagebot amazonka-cognito-identity 1.3.1 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.3.1 (BrendanHay)
05:15:40 <roelof> merijn : so in xor the answer is false when the both arguments are the same. How can I make this work with wildcard patterns ?
05:16:04 <mniip> you can't really
05:16:25 <mniip> without having defined == first
05:16:57 <Gurkenglas> tsahyt, you only need one of && and || if you allow not.
05:17:13 * mniip mumbles some crazy stuff about ==# dataToTag#
05:17:55 <tdammers> in a nutshell, the straightforward way of implementing binary boolean operators using no typeclass instances on Bool is to pattern-match on a pair
05:19:07 * hackagebot amazonka-ssm 1.3.1 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.3.1 (BrendanHay)
05:19:09 <tsahyt> Gurkenglas: Right. In fact, NAND xor NOR suffices.
05:19:09 * hackagebot amazonka-ml 1.3.1 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.3.1 (BrendanHay)
05:19:11 * hackagebot amazonka-workspaces 1.3.1 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.3.1 (BrendanHay)
05:19:13 * hackagebot amazonka-dynamodb 1.3.1 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.3.1 (BrendanHay)
05:19:15 * hackagebot amazonka-rds 1.3.1 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.3.1 (BrendanHay)
05:19:30 <Gurkenglas> tsahyt, ah, but that is not pareto-better
05:19:35 * mniip laughs hysterically: x && y = tagToEnum# (dataToTag# x *# dataToTag# y)
05:20:21 <merijn> mniip: ...
05:20:43 <mauke> not lazy enough
05:21:49 <merijn> If anyone's bored, help me simplify this to look nicer: http://lpaste.net/140526
05:22:02 <roelof> merijn : this one better : http://lpaste.net/140527
05:22:48 <mniip> merijn, do you really need the special case
05:23:02 <merijn> mniip: Which one?
05:23:15 <merijn> roelof: The dashes in && should be underscores, but looks fine, yeah
05:23:38 <mniip> merijn, nulls
05:24:04 <merijn> Yes, because
05:24:12 <merijn> > mconcat [] :: Maybe [()]
05:24:13 <lambdabot>  Nothing
05:24:15 <roelof> oke, thanks all. Now I have to make quicktests to test it all. So back to the books and manual 
05:24:17 * hackagebot amazonka-ds 1.3.1 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.3.1 (BrendanHay)
05:24:19 * hackagebot amazonka-cloudwatch-logs 1.3.1 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.3.1 (BrendanHay)
05:24:20 <merijn> And not "Just []"
05:24:21 * hackagebot amazonka-route53 1.3.1 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.3.1 (BrendanHay)
05:24:23 * hackagebot amazonka-cloudsearch 1.3.1 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.3.1 (BrendanHay)
05:24:25 * hackagebot amazonka-storagegateway 1.3.1 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.3.1 (BrendanHay)
05:24:52 <ski> roelof : you do know that you could write `True && True = True', yes ?
05:25:14 <roelof> yes, I know 
05:26:25 <merijn> mniip: And if I don't use null I have to duplicate the pattern several times
05:26:47 <Gurkenglas> Ah shit clicked on edit instead of annotate.
05:27:17 <Gurkenglas> merijn, http://lpaste.net/140526 . Are you sure you want Nothing if pats is null, but args isn't?
05:27:41 <tsahyt> roelof: http://lpaste.net/893110858333290496 This is how I would implement a variety of logical connectives. I think it should become apparent why defining most of them through their equivalences to more basic ones can be preferable. All those definitions are just taken straight from Wikipedia. I haven't tested them though, so there might be an error somewhere
05:27:46 <merijn> Gurkenglas: Yes
05:28:23 <merijn> Gurkenglas: A pattern match of a constructor with 0 fields matching with a constructor that has non-zero fields is wrong :)
05:29:05 <frerich> merijn: Maybe http://lpaste.net/140526#a140529 -- but I think Gurkenglas' monadic version is kinda nice, too
05:29:08 <Gurkenglas> merijn, then shouldn't you check for the length being equal rather than both being null?
05:29:19 <merijn> Gurkenglas: mconcat already deals with that
05:29:27 * hackagebot amazonka-ec2 1.3.1 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.3.1 (BrendanHay)
05:29:29 * hackagebot amazonka-kms 1.3.1 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.3.1 (BrendanHay)
05:29:31 * hackagebot amazonka-elastictranscoder 1.3.1 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.3.1 (BrendanHay)
05:29:33 * hackagebot amazonka-lambda 1.3.1 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.3.1 (BrendanHay)
05:29:35 * hackagebot amazonka-ecs 1.3.1 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.3.1 (BrendanHay)
05:29:36 <merijn> Gurkenglas: Oh, actually I guess my zipWith is wrong
05:29:53 <roelof> Thanks all, First dinner
05:29:55 <merijn> Should be like zipWithDefault or whatever :)
05:30:05 <Gurkenglas> Oh wait you zip using go, dang. Time to refactor out the recursion
05:32:18 <Gurkenglas> > mconcat $ zipWith const [Just [], Nothing, Just [2]] (repeat Nothing) -- merijn, these aren't equally sized and Nothing doesn't result
05:32:20 <lambdabot>  Just [2]
05:32:40 <merijn> Gurkenglas: Like I said, the zipWith is wrong
05:32:48 <Gurkenglas> Ah, missed that
05:34:37 <lpaste_> Gurkenglas revised ‚ÄúSimplify‚Äù: ‚Äúmerijn, here, though the recursion remains‚Äù at http://lpaste.net/140526
05:34:37 * hackagebot rest-core 0.36.0.6 - Rest API library.  https://hackage.haskell.org/package/rest-core-0.36.0.6 (ErikHesselink)
05:34:39 * hackagebot ginger 0.1.0.0 - An implementation of the Jinja2 template language in Haskell  https://hackage.haskell.org/package/ginger-0.1.0.0 (TobiasDammers)
05:34:41 * hackagebot lackey 0.1.0 - A library for generating Ruby consumers of Servant APIs.  https://hackage.haskell.org/package/lackey-0.1.0 (fozworth)
05:34:42 <lpaste_> merijn pasted ‚ÄúzipWithDef‚Äù at http://lpaste.net/140532
05:34:48 <merijn> I should use something like that
05:35:16 <merijn> At which point I might as well not use zipWith and do it with manual recursion
05:35:24 <Gurkenglas> merijn, way ahead of you :P
05:37:22 <mniip> merijn, xs >> Nothing
05:37:24 <Gurkenglas> (Oh wait you mentioned "zipWithDefault" before i pasted <.<)
05:37:37 <mniip> instead of go'ing, in zipWithDef
05:38:51 <tsahyt> Does anyone know of a vim colorscheme that is like solarized light but isn't solarized? I'm getting kinda tired of it sometimes.
05:38:51 <mniip> oh wait
05:38:57 <mniip> needs some return
05:39:18 <mniip> 'Nothing <$ xs' then
05:39:28 <lpaste_> merijn annotated ‚ÄúzipWithDef‚Äù with ‚ÄúzipWithDef (annotation)‚Äù at http://lpaste.net/140532#a140533
05:39:40 <merijn> This one is more direct
05:40:01 <Gurkenglas> merijn noooo use the libraries
05:40:10 <merijn> Gurkenglas: Like which one?
05:40:11 <Axman6> tsahyt: I use one called Tomorrow Night on OS X
05:40:28 <Gurkenglas> merijn, I think you mean xs *> Nothing?
05:40:30 <Gurkenglas> Argh
05:40:43 <mniip> :t (<$)
05:40:44 <lambdabot> Functor f => a -> f b -> f a
05:40:49 <Gurkenglas> merijn, <lpaste_> Gurkenglas revised ìSimplifyî: ìmerijn, here, though the recursion remainsî at http://lpaste.net/140526
05:40:50 <mniip> I mean that
05:41:19 <merijn> I don't see the point of adding another dependency for 3 lines
05:41:21 <Gurkenglas> That last "merijn," line before the Argh was a "ctrl-v into enter" that followed a failed copy
05:41:45 <merijn> Actually I find that one wildly more confusing
05:42:18 <tsahyt> Axman6: Thanks, the light version is pretty good. I'd actually prefer using a dark color scheme, but during the day the sun hits my glossy screen at an awful angle and I see mostly myself instead of the code.
05:42:23 <Gurkenglas> It's worth an import if it makes you separate the control parts from the meat parts
05:43:28 <Gurkenglas> (Currently grumbling that there is no ZipListExact)
05:44:20 <haskell961> someone here?
05:44:31 <Gurkenglas> only about 1492 people
05:44:44 <srhb> Some of which may actually be bots.
05:44:55 <haskell961> someone have time to help me with some haskel?
05:45:01 <Intolerable> hello
05:45:03 <srhb> haskell961: Pose your question and someone might help you :)
05:45:54 <Gurkenglas> In the interest of future generations, reduce the number of times these preliminary 4 lines occur
05:46:05 <haskell961> http://lpaste.net/140534
05:46:17 <haskell961> im stuck at (<+) 
05:46:26 <lpaste_> guibou pasted ‚ÄúNo title‚Äù at http://lpaste.net/140535
05:47:20 <guillaum2> anyone can have a look at my paste (it's an histogram computation) and explain to me why the approach using ST and boxed vector is slow and space leaks ?
05:47:31 <srhb> haskell961: What is it supposed to do?
05:47:40 <haskell961> I need some help. I get two arguments which will be 2 hands and from these to hands i want to create one hand. First argument should be on the top 
05:48:00 <srhb> haskell961: How do you combine them?
05:48:40 <tsahyt> haskell961: How is the Hand type defined?
05:48:43 <haskell961> http://lpaste.net/140536
05:48:54 <haskell961> a Hand = Add Card Hand
05:49:10 <tsahyt> haskell961: So it's basically a list of cards?
05:49:13 <haskell961> Hand = Add Card hand | Empty
05:49:16 <haskell961> yea
05:49:34 <haskell961> so im stuck because here
05:49:34 <haskell961> (<+) (Add c1 h1) (Add c2 h2)  = (Add c1 (Add (returnCard h1) (Add c2 h2)))
05:49:44 <tsahyt> If I understand you correctly, you're trying to reimplement (++), but for your own type, which is isomorphic to [Card]
05:49:47 <srhb> haskell961: Have you considered a recursive call?
05:49:52 <haskell961> yes
05:49:58 <Gurkenglas> haskell961, on line 94, you take the first card of h1 (which is the second card of the first argument) and put it onto the second argument. The third card and so on of the first argument are discarded. You will not be able to add two hands of a 100 cards each together without recursively calling <+.
05:50:30 <tsahyt> haskell961: Here's the implementation of (++). You should be able to adapt this to the Hand type: http://haddock.stackage.org/lts-3.4/base-4.8.1.0/src/GHC-Base.html#++
05:51:12 <Axman6> guillaum2: the VUM.modify is probably building up a big thunk in each cell, which gets evaluated more slowly than the strict version using unboxed vectore (since computations are forced when creating the Int# which is stored in the vector)
05:51:31 <Axman6> s/VUM/VM
05:51:37 <tsahyt> haskell961: Alternatively, you might just do newtype Hand = Hand [Card], and define (Hand a) <+ (Hand b) = Hand (a ++ b)
05:51:37 <ski> tsahyt : possibly better to think it through without looking at other code
05:51:38 <Gurkenglas> tsahyt, that doesn't link to the correct line for me. Try https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#%2B%2B
05:52:33 <tsahyt> Gurkenglas: Oh, thanks. It works for me with Firefox, but I guess some browsers need to escape the +'s first
05:53:01 <tsahyt> ski: I guess, yeah, but I think it's also important to realize when you're reinventing the wheel, or the list in this case.
05:53:07 <Axman6> guillaum2: basically you're building up potentially huge thunks of (1 + (1 + (1 + ...)))
05:53:47 <haskell961> im not so sure how to implement this as a recursive call
05:54:28 <Axman6> guillaum2: you could try reading each element after writing it and forcing it
05:54:34 * Axman6 must head to bed
05:54:38 <srhb> haskell961: So consider .. = Add c1 (...)
05:54:39 <jameseb> haskell961: is there a reason you're making your own type and reimplementing the operations on it?
05:54:52 <srhb> jameseb: Looks like homework :)
05:54:58 <haskell961> its a homework
05:55:01 <haskell961> just started this course
05:55:07 <guillaum2> Axman6: interesting, I'll have a look
05:55:08 <haskell961> new to functional programming
05:55:26 <haskell961> i get that
05:55:33 <srhb> haskell961: Conceptually, then, (...) should be the combination of h1 and Add c2 h2
05:55:44 <srhb> haskell961: Can you express that combination?
05:55:59 <haskell961> but i need to get the rest of the cards from h1
05:56:06 <haskell961> and i im not sure how to get them
05:56:10 <srhb> haskell961: You have those. They are h1
05:56:33 <haskell961> yes but i cant write (Add c1 h1)
05:56:49 <srhb> No, but you can combine h1 with (Add c2 h2)
05:57:20 <srhb> haskell961: Remember, you have a function that takes two hands and gives you a combined hand
05:57:24 <srhb> h1 is a hand
05:57:27 <srhb> Add c2 h2 is a hand
05:57:35 <haskell961> yea i get that
05:57:41 <srhb> So how do you combine those two?
05:59:00 <haskell961> (Add c1 <+ h1 h2)?
05:59:01 <srhb> haskell961: I think perhaps this would be easier to see if you change the left hand side to (<+) (Add c1 h1) h2
05:59:14 <srhb> Add c1 is not a Hand
05:59:20 <srhb> So it cannot be the left argument to <+
05:59:22 <haskell961> no but its a card
05:59:27 <haskell961> oh
05:59:31 <srhb> Right, but <+ does not take a Card as argument
05:59:39 <haskell961> (Add c1 (h1 <+ h2))
05:59:47 <srhb> Hey presto
05:59:49 <srhb> :)
06:00:00 <haskell961> is it like that?
06:00:04 <srhb> Try it out.
06:00:06 <haskell961> thanks
06:00:09 <srhb> The outer parens is superfluous
06:00:25 <Gurkenglas> Is there something like MaybeApplicative whose <*> is f (a -> b) -> f a -> Maybe (f b)?
06:00:58 <Gurkenglas> (How is <*> pronounced?)
06:01:01 <Intolerable> ap
06:01:27 <Intolerable> you could use Compose Maybe f
06:01:29 <merijn> I never really pronounced it
06:02:03 <srhb> haskell961: Consider if you feel it is true that the combination of two hands is the combination of the first card in the first hand with the rest of the first hand and the second hand. If that sounds true to you, you're probably right!
06:02:33 <srhb> haskell961: There's also another way to think of it. Since Hand is essentially a singly linked list, you have to WALK that entire list to replace the last Empty with the second hand.
06:02:45 <srhb> haskell961: Hopefully that's marginally englightening. :)
06:03:05 <haskell961> but doesn't work like i want to
06:03:28 <haskell961> (<+) (Add c1 h1) (Add c2 h2)  = (Add c1 (h1 <+ h2))
06:03:36 <srhb> haskell961: Ah, you didn't change the left hand side as I suggested
06:03:40 <srhb> So you're dropping the c2
06:03:43 <haskell961> i entered 2 hands. It gave me all cards from the first want 
06:03:44 <haskell961> but not c2
06:04:07 <srhb> Well, you can replace h2 with (Add c2 h2)
06:04:11 <srhb> On the right hand side
06:04:14 <haskell961> got it
06:04:19 <srhb> Or you can replace Add c2 h2 with h2 on the left hand side
06:04:20 <Gurkenglas> Intolerable, that would mean f (a -> b) = (Compose Maybe g) (a -> b) ~= Maybe (g (a -> b)) would have to decide whether it contains some g (a -> b) regardless of the nature of the f a
06:04:27 <srhb> I feel the latter is clearer because it shows that you never need to touch c2
06:04:31 <srhb> Or "walk past it"
06:04:44 <haskell961> works now
06:04:48 <srhb> As soon as you have traversed the left hand side fully, your Empty h2 case kicks in :)
06:04:54 <srhb> the first hand*
06:05:08 <haskell961> thanks a lot
06:05:12 <srhb> Welcome, have fun :)
06:05:13 <Intolerable> oh, i see what you mean
06:05:16 <Intolerable> nvm then
06:08:25 <guillaum2> Axman6: I tried to replace VM.modify v (f value) offset by {r <- VM.read v offset; let newVal = f r value; VM.write v offset (seq newVal newVal)} and no ;(
06:08:34 <tsahyt> Is there a pointfree way to define this function in one equation? let f (a:_:xs) = a : f xs; f [a] = [a]; f [] = []
06:08:57 <tsahyt> I.e. a function that skips every other element of a list
06:10:03 <merijn> Ok, I've asked before, but the difference between predicative and impredicative type systems is still hazy for me.
06:10:13 <srhb> tsahyt: That version is quite clear, but you could zipWith cycle [Just,const Nothing] and collect the Justs afterwards.
06:10:17 <srhb> tsahyt: I don't think it's worth it
06:10:25 <merijn> Any helpful explanations?
06:10:49 <merijn> tsahyt: What's the reason for wanting it to be pointfree?
06:10:58 <guillaum2> Axman6: ok, i got it using VM.write v offset $! newVal
06:11:12 <tsahyt> merijn: It's just a small helper function and I'd like to pass it anonymously
06:11:23 <tsahyt> merijn: Technically doesn't have to be pointfree
06:11:23 <merijn> tsahyt: Just define it in a let/where?
06:11:53 <tsahyt> merijn: I guess that's what I'm gonna do.
06:12:37 <guillaum2> Axman6: and that's funny, but Boxed vector are now quicker than unboxed ones...
06:13:09 <srhb> > catMaybes . zipWith ($) (cycle [Just, const Nothing]) $ [1..11] -- tsahyt
06:13:10 <lambdabot>  [1,3,5,7,9,11]
06:13:26 <srhb> So it's not that impressive.
06:13:43 <Gurkenglas> (Oh wait ZipListExact doesn't have an instance of ApplicativeMaybe because repeat doesn't work for pure since that doesn't fit exactly onto all ZipListExacts like it is with ZipList. Only SemigroupoidMaybe then, I guess.)
06:14:38 <tsahyt> srhb: Thanks. I'll just throw the simple version into a let binding as merijn suggested. This way I'll see at a glance what it does if I should ever need to revise anything.
06:14:42 <srhb> :)
06:14:47 <srhb> Good call.
06:15:08 <tsahyt> Haskell always inspires me to be clever about things, only to realize that I'll not be as clever a few months in the future.
06:15:34 <merijn> Is it basically that impredicative types cannot be inferred whereas predicative types can be?
06:15:42 <Gurkenglas> tsahyt, you may be interested in https://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html#v:chunksOf
06:15:45 <merijn> Due to impredicative types not having a single most general type?
06:16:49 <tsahyt> Gurkenglas: So, "head . chunksOf 2"? It doesn't seem worth it to add a dependency just for one helper function that I use once.
06:17:20 <Gurkenglas> map head, and it was possible your entire codebase is made unnecessary by that library or something.
06:17:27 * merijn mumbles something about "Fairbairn-threshold"
06:18:36 <tsahyt> Gurkenglas: right, map. That's unlikely. It's part of a triangulation procedure for boundary cells in a quadtree during finite element mesh generation using a spatial decomposition approach. It's really just a helper function.
06:19:04 <tsahyt> I've used this package before though, specifically for chunksOf, but I feel like it's overkill here.
06:19:59 <merijn> tsahyt: That's what I meant by Fairbairn-threshold :) It's the threshold below which rembering a function exists somewhere becomes more effort than just reimplementing it when you need it :)
06:20:38 <Gurkenglas> You make it sound like the mind is a container to be filled rather than a fire to be fed
06:20:59 <srhb> What, you stick things in and they disappear forever in entropy?
06:21:03 <srhb> ... that's actually accurate, given enough time.
06:21:35 <merijn> Gurkenglas: My working set of memory is limited
06:22:10 <merijn> If a function can be defined in <3 lines and I can't immediately remember the name of it/package that has it, why bother searching?
06:22:53 <Gurkenglas> Because it lead the way to further refactoring.
06:22:56 <Gurkenglas> *might
06:24:26 <Gurkenglas> The second is what turns the first into the third http://lpaste.net/revision/138244
06:25:34 <Gurkenglas> (Though the third was with a little more extra refactoring into the same direction which goes back down the elegance curve and might undermine my point)
06:28:37 <guillaum2> Axman6: ok, I got it, the unboxed version is as fast as the boxed one because my array is small (10 items). The difference appears when I put more items in it.
06:33:05 <pofix> Is anyone here proficient with shake build?
06:36:39 <indiagreen> I have a project with a library and an executable. When I try to load the executable source file (Main.hs) in Emacs, haskell-mode invokes cabal wrongly and complains about dependencies not present (even tho those dependencies are listed in the executable section of the .cabal). Does anyone recognise this issue / is there a workaround?
06:44:13 <Gurkenglas> (Also a fourth now that goes yet further. :D)
06:47:57 <bernalex> what's that awful record syntax I always forget again? for updating a nested record. m { joinButton = (joinButton m { active  = True })} is apparently wrong.
06:48:11 <bernalex> I have an m, whose joinButton's active I want to set to True.
06:48:52 <Intolerable> m { joinButton = (joinButton m) { active ¬†= True }}
06:48:53 <Intolerable> ?
06:49:16 <bernalex> oh derp
06:49:28 <bernalex> yep. thanks, Intolerable.
06:49:33 <Intolerable> enjoy
06:50:42 <divVerent> we need to go deeper
06:51:29 <phaazon> hey, is there a way to declare ¬´ package ¬ª exports in the export-lists?
06:51:41 <phaazon> so that I¬†can export a symbol I¬†can see in the whole package 
06:51:41 <divVerent> m { joinButton = (joinButton m) { active = (active $ joinButton m) { status = True, lastChange = now } } }
06:51:45 <phaazon> but invisible to other packages?
06:51:54 <Intolerable> mmmmm
06:51:57 <Intolerable> record update syntax
06:51:59 <Intolerable> my favorite
06:52:00 <phaazon> an extension or something like that
06:52:40 <divVerent> Intolerable: more seriously, I gave up even thinking about nested record updates... I prefer using separate functions for each layer.
06:53:23 <divVerent> i.e. m { joinButton = activateButton $ joinButton m } where activateButton b = b { active = True }
06:54:02 <phaazon> m & joinButton . active .~ True
06:54:05 <divVerent> phaazon: I don't think there is such a way
06:54:10 <divVerent> phaazon: that's cheating :)
06:54:16 <phaazon> :)
06:54:16 <Intolerable> lenses are magic
06:54:22 <phaazon> nope
06:54:26 <phaazon> they're just profunctors :)
06:54:42 <divVerent> but all this is even more fun if there's multiple records with an "active" field
06:54:55 <Intolerable> wheres that "indistinguishable from magic" quote
06:55:03 <divVerent> IIRC that breaks those lenses, while the extensions for these record cases keep working
06:55:36 <Intolerable> yeah because they can only type change one at a time
06:55:38 <divVerent> Intolerable: "Any expression with sufficiently many parenthesized composition operators is indistinguishable from magic"
06:55:55 <bernalex> divVerent: Intolerable: I wish we had idris's sophistication when it comes to records.
06:56:10 <phaazon> what is idris' sophistication?
06:56:19 <bernalex> it doesn't suck
06:56:34 <phaazon> haha
06:56:40 <divVerent> phaazon: first of all, the update syntax itself is more logical from what I read now
06:56:42 <divVerent> i.e.
06:56:43 <merijn> I wish we had lazy Idris :\
06:56:46 <bernalex> some of this will suck less in ghc 8 though. we'll e.g. have type-driven resolution. that will be awesome.
06:56:54 <divVerent> record { fieldName = value } is a function RecordType -> RecordType
06:56:59 <divVerent> (where record is a keyword, though)
06:57:05 <bernalex> merijn: it's very possible atm. everything is there and ready for someone to just write a non-strict implementation.
06:57:09 <merijn> bernalex: Not type-driven, but typeclass style accessors
06:57:30 <bernalex> merijn: wait, what? we're not getting proper type-driven resolution with the overlappablerecords-stuff?
06:57:49 <bernalex> then I'm not nearly as excited about it
06:57:53 <merijn> You get polymorphic accessors
06:57:57 <bernalex> blah
06:58:01 <bernalex> that's OK I guess
06:58:07 <divVerent> merijn: link to the spec?
06:58:14 <merijn> bernalex: Are you sure you're not confusing what you want with type-driven
06:58:18 <divVerent> as I know there's multiple, so which one are we going to get?
06:58:30 <phaazon> divVerent: lenses are functions as well
06:58:33 <merijn> divVerent: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
06:58:42 <phaazon> set field value record
06:58:46 <bernalex> merijn: in idris I can write five functions with the same name if I want
06:58:53 <phaazon> record & set field value
06:59:01 <bernalex> merijn: then type-driven resolution figures out which one I meant to use
06:59:10 <phaazon> > (1,"foo") & set _2 "bar"
06:59:11 <lambdabot>  (1,"bar")
06:59:16 <merijn> bernalex: I actually think that's a bad idea
06:59:25 <phaazon> > (1,"foo") & _2 .~ "bar"
06:59:27 <lambdabot>  (1,"bar")
06:59:37 <merijn> The current one will have "HasFoo" style accessors like you can generate with lens
07:00:00 <bernalex> merijn: I think it has trade-offs like most things, but in practice I've come to like it. I haven't worked on huge idris projects with *other people* though. "other people" tend to fuck shit up. :)
07:00:06 <phaazon> > (1,"foo") & _2 . mapped %~ succ
07:00:07 <lambdabot>  (1,"gpp")
07:00:18 <bernalex> merijn: those are usually useful IME. especially for databases.
07:00:48 <divVerent> merijn: thanks... reading now
07:01:07 <phaazon> the record syntax is just set
07:01:08 <phaazon> :t set
07:01:11 <lambdabot> ASetter s t a b -> b -> s -> t
07:01:18 * bernalex goes back to hacking
07:01:18 <phaazon> see how it's a function as well
07:02:06 <phaazon> @let data Foo = Foo { fooA :: Int, fooB ::¬†String } deriving (Eq,Show)
07:02:09 <lambdabot>  Defined.
07:02:28 <phaazon> ah we might not have TH
07:02:36 <phaazon> @let makeLenses ''Foo
07:02:37 <lambdabot>  Parse failed: Parse error: '
07:02:43 <phaazon> > makeLenses ''Foo
07:02:45 <lambdabot>      Syntax error on ''Foo
07:02:45 <lambdabot>      Perhaps you intended to use TemplateHaskell
07:02:45 <lambdabot>      In the Template Haskell quotation ''Foo
07:02:47 <phaazon> nope
07:04:17 <elperdut> hello all. I am trying to determine (via google/hoogle) how one can convert a POSIXTime IO type to a String (for the purpose of writing to a file). How would one go about figuring this out? For example, I start with:
07:04:17 <elperdut> let t = getPOSIXTime :: IO POSIXTime
07:04:17 <elperdut> and would like to do something like `t' = convertToString t`
07:04:36 <indiagreen> :t formatTime
07:04:37 <lambdabot> Not in scope: ‚ÄòformatTime‚Äô
07:04:48 <geekosaur> are you sure you didn't want t <- getPOSIXTime ?
07:06:15 <indiagreen> elperdut: is your question ‚Äúhow to do it‚Äù or ‚Äúhow would one figure it out if one didn't know the answer already‚Äù?
07:07:31 <elperdut> the latter - this is my first time trying to use Hoogle
07:09:12 <elperdut> geekosaur: I see your point, the <- "unwraps" the type from IO right?
07:09:55 <elperdut> so i guess i am down to searching for something like POSIXTime -> String, and I suspect there is an intermediary type involved here
07:10:25 <divVerent> merijn: hm... this OverloadedRecordFields looks interesting... but one thing is "missing"
07:10:34 <divVerent> it already uses a Symbol type to represent the field names
07:10:45 <divVerent> so why not go the full way and add the capability of runtime reflection?
07:10:46 <indiagreen> elperdut: I admit that I don't know how to figure it out with Hoogle/Hayoo (I just tried). If you know that showing time is usually called ‚Äúformatting‚Äù, you can google ‚Äúhaskell format time‚Äù and quickly arrive at https://hackage.haskell.org/package/time-1.5.0.1/docs/Data-Time-Format.html
07:10:54 <divVerent> it seems like not much is missing for it
07:11:08 <merijn> divVerent: Except for the fact that there is no type information at runtime :po
07:11:20 <merijn> divVerent: Which makes that impossible :)
07:11:42 <divVerent> merijn: well... not yet
07:11:47 <merijn> I don't suppose there's a way to export a certain constructor only to a single module
07:11:50 <divVerent> but the typeclasses basically add this
07:12:06 <divVerent> or rather, typeclasses are "somewhat like" runtime type information
07:12:15 <indiagreen> elperdut: but ‚Äúhaskell show time‚Äù won't lead you anywhere; in this case you could just look at all modules in the time package and see whether there's anything that fits the bill
07:12:22 <merijn> Well, yes, that's why we have Typeable
07:12:27 <divVerent> as in it becomes a runtime dispatch already
07:12:32 <divVerent> what's missing is a name lookup for it
07:12:35 <nshepperd> (KnownSymbol s) is basically just a String in a box
07:12:42 <merijn> But I don't think we should make Typeable mandatory for everything is bad
07:12:50 <merijn> divVerent: Eh, that's not necessarily true
07:13:05 <merijn> divVerent: In *many* cases typeclass dispatch ends up being static dispatch, not dynamic
07:13:21 <divVerent> merijn: I'd rather say in *few* :)
07:13:25 <divVerent> of course if the type is known...
07:13:35 <divVerent> the compiler can freely do a static dispatch
07:13:36 <indiagreen> elperdut: finally, you can google ‚Äúhaskell time tutorial‚Äù; the first relevant result is the 5th one (at least for me), and that's http://two-wrongs.com/haskell-time-library-tutorial (which does describe how to format time)
07:14:03 <divVerent> and I know there's also some ways to implement typeclasses entirely with static dispatch
07:14:16 <divVerent> (C++ templates, same trick - essentially recompile the code for all types there can be)
07:14:27 <merijn> Not if you want to keep polymorphic recursion there isn't, afaik
07:14:29 <divVerent> well, almost entirely
07:14:42 <nshepperd> that works for some typeclasses, not for irregular data structures
07:14:47 <divVerent> right, e.g. in case of a polymorphic collection it'd rbeak down
07:15:03 <merijn> divVerent: Not polymorphic collection, polymorphic recursion
07:15:12 <indiagreen> elperdut: finally finally, don't disregard IRC ‚Äì if you've spent 10m looking for something and you can't find it, chances are that it's simply an issue of bad documentation, and if you ask on IRC someone might help you in as little as 10s
07:15:32 <divVerent> merijn: well, I'd say both, or not?
07:15:37 <divVerent> different instances of the same problemn
07:16:18 <divVerent> wait, no, I see... right, polymorphic containers are Typeable territory again :)
07:16:43 <divVerent> so polymorphic recursion is the less "insane" case here
07:17:03 <nshepperd> data FingerTree a = Empty | Single a | Deep [a] (FingerTree (Node a)) [a]  -- this requires polymorphic recursion
07:17:27 <merijn> nshepperd: Why?
07:18:10 <bernalex> ugh
07:18:30 <bernalex> I have an IO [a], I have a function that takes [a]->a, I want IO a. how?
07:18:47 <merijn> bernalex: uh...fmap?
07:18:57 <bernalex> yeah but ugh io ugh list
07:19:43 <bernalex> it turns it into [[a]] instead of IO a
07:19:52 <Intolerable> ?
07:20:02 <indiagreen> fmap yourfunction yourio
07:20:14 <Intolerable> > fmap sum (return [1,2,3,4] :: IO [Int])
07:20:15 <lambdabot>  <IO Int>
07:20:17 <bernalex> indiagreen: oh, right I have [myio, myotherio]
07:20:26 <bernalex> I miswrote
07:20:36 <nshepperd> er, oh, you need polymorphic recursion to do the measure stuff
07:20:41 <bernalex> [IO a] not IO [a]
07:20:50 <indiagreen> you can use sequence to turn [IO a] into IO [a]
07:21:14 <guillaum2> I have a stupid question, but do you have a mnemonic or something to remember which one of "runState/evalState/execState" is the one you want?
07:21:16 <Intolerable> sequence . fmap f 
07:21:19 <Intolerable> er
07:21:24 <Intolerable> fmap f . sequence
07:21:25 <Intolerable> rather
07:21:42 <bernalex> ahhh yes ofc
07:21:51 <bernalex> I need a break lol
07:21:53 <bernalex> thanks Intolerable!
07:21:53 <nshepperd> the obvious definition of `measure :: (Measurable v a) -> FingerTree a -> v` involves a recursive call with a (Measurable v (Node a)) constraint
07:21:55 <bernalex> again
07:22:41 <indiagreen> guillaum2: there doesn't seem to be one that sticks, because I just found out that I forgot all the ones I had learned a couple of months ago
07:22:55 * hackagebot should-not-typecheck 2.0.1 - A HUnit/hspec assertion library to verify that an expression does not typecheck  https://hackage.haskell.org/package/should-not-typecheck-2.0.1 (CRogers)
07:22:56 <nshepperd> divVerent: what sort of runtime reflect were you thinking of, anyway? like getting a list of fields?
07:23:04 * tdammers wonders if there is an actual viable implementation of FRP for client-side scripting
07:23:18 <indiagreen> guillaum2: I guess you could try to remember that evaluation is about result of the action and execution is about side effects of the action (changing state, in this case)
07:23:54 <bennofs> tdammers: reflex / reflex-dom ?
07:26:24 <tdammers> that's ghcjs isn't it
07:26:34 <guillaum2> indiagreen: that may do the job, until the next time I'll have to write a state monad ;) Thank you ;)
07:27:56 * hackagebot prelude-extras 0.4.0.2 - Higher order versions of Prelude classes  https://hackage.haskell.org/package/prelude-extras-0.4.0.2 (EricMertens)
07:28:18 <bennofs> tdammers: yes
07:38:08 <xikuuky> Could someone tell me what it is like to come from Python to Haskell? I know they are different pardigms and what not, but I really just want to know what to expect.
07:38:23 <gganley> if functions have implicit unviersal quantification, then what is the explicit quantification useful for?
07:39:36 <elperdut> indiagreen: thanks for the time tutorial link. i recall i had seen that on reddit recently!
07:39:45 <merijn> gganley: RankNTypes and ScopedTypeVariables
07:40:02 <merijn> gganley: Explicit quantification lets you scope type variables over local definitions
07:40:09 <merijn> gganley: (Using STV)
07:40:20 <merijn> And RankN lets you add explicit quantification in new places
07:40:50 <merijn> xikuuky: Expect to be learning like you've never learned programming
07:41:21 <Ankhers> xikuuky: I mainly came from Ruby, PHP, Javascript, and a little Python. Haskell is very different from Python. It may seem intimidating and hard, but if you stick with it, it can be quite enjoyable.
07:41:21 <merijn> xikuuky: The type system encourages a different way of writing programs, the style of code in haskell is wildly different from python
07:41:23 <frerich> xikuuky: To paraphrase, coming from Python (i.e. a primarily imperative, dynamically typed language) to Haskell will basically have an effect on your brain similiar to "having your brains smashed in by a slice of lemon wrapped round a large gold brick".
07:41:37 <merijn> @quote conveniently.gloss
07:41:37 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
07:42:54 <xikuuky> Ankhers: Thanks! I was really hoping to here that. :D
07:43:21 <Ankhers> @where learnhaskell
07:43:21 <lambdabot> https://github.com/bitemyapp/learnhaskell
07:43:28 <merijn> I came from Python, a long, long time ago, but tbh I haven't touched python in years by now
07:43:34 <Ankhers> xikuuky: That is a good place to start if you haven't already.
07:43:36 <funk> exploding heads, right!!
07:44:34 <xikuuky> merijn: I like new type systems(I went from Python, to CoffeeScript, to C#, to C). I think it would be good for me to branch out to new pardigms(while my brain can still handle change)
07:45:04 <xikuuky> frerich: :D
07:45:21 <frerich> xikuuky: I still write C++ and Python almost every day, and Haskell actually made me appreciate how much nicer Python can be than C++ because it really lends itself to many functional paradigms without the syntactic noise.
07:45:28 <Ankhers> xikuuky: Haskell definitely has a different type system from those languages. 
07:46:02 <funk> btw: i am planning to change a legacy wxpython gui app step by step to haskell. Did anyone use wxhaskell within python? especially, is it possible to call wxhaskell via ffi from python. Even more special: is it possible to give a wx.DC to haskell for painting on it? 
07:46:40 <Ankhers> I had a hard enough time trying to compile wxHaskell when I first tried using it.
07:47:30 <tdammers> frerich: really? I've found Python's FP features annoyingly limited
07:47:41 <frerich> tdammers: In comparison to C++
07:47:44 <frerich> ?
07:48:18 <lpaste_> dfrey pasted ‚ÄúSplit list based on adjacent values‚Äù at http://lpaste.net/140545
07:48:24 <xikuuky> Thanks everyone! I can't wait to start learning. Ankhers, I'll check that out. It looks like a good tutorial. frerich: Yay! merijn: How long?
07:48:26 <tdammers> frerich: maybe it's because "static type checks" and "controlled effects" are bigger deals for me than "first-class functions"
07:49:00 <dfrey> I'm wondering if there is any standard library function to do what I pasted above.  Also I'm wondering if there is a more elegant way to express this function (ie in terms of folds)
07:49:04 <frerich> tdammers: Python also has generators which makes wholemeal programming much more viable.
07:49:37 <Ankhers> dfrey: Isn't there something like that in Data.List?
07:49:51 <merijn> xikuuky: How long what? :)
07:49:52 <dfrey> Ankhers: I looked and couldn't find it.
07:49:54 <funk> xikuuky: real world haskell book is also great to start out. doing the same as you right now.
07:50:01 <Ankhers> Data.List.Split
07:50:14 <merijn> Real World Haskell is ok, but not a very good starting point, imo
07:50:16 <tdammers> frerich: Python's scoping rules and lack of static type checks make it difficult to program as boldly as I would in Haskell; the FP features that are there feel kind of dangerous
07:50:17 <dgpratt> I'm experiencing a problem with cabal where it seems to get hung up downloading packages
07:50:32 <dgpratt> is anything going on with hackage, or is the problem likely local?
07:50:55 <tdammers> frerich: C++, by contrast, has a somewhat reasonable type checker, sane scope, and at least controlled mutability
07:51:30 <dfrey> Ankhers: I don't see Data.List.Split in the library index
07:51:54 <nshepperd> Data.List.Split.chop is a magical combinator
07:51:55 <Ankhers> dfrey: https://hackage.haskell.org/package/split apparently it a separate package.
07:52:24 <Ankhers> I swear there was something like that in base though.
07:52:34 <divVerent> nshepperd: getting a list of field, and accessing fields by name and "guessed type"
07:52:50 <divVerent> possibly even using a field as instance of a typeclass without knowing the actual type
07:52:50 <dfrey> Ankhers: groupBy has the same type signature, but doesn't do the same thing
07:53:03 <divVerent> imagine e.g. implementing a generic "show" for arbitrary types
07:53:14 <divVerent> just with XML output or the like
07:53:28 <lingxiao> has hanyone plaed with cassava
07:53:51 <lingxiao> and know how i can interatct with Header data type
07:53:55 <Ankhers> dfrey: Maybe that was what I was thinking. It looks like the split package has what you want though
07:54:00 <lingxiao> for example if t = ["a","b"] :: Header
07:54:11 <lingxiao> I'd like to inspect "a" 
07:55:49 <Ankhers> lingxiao: a Header is a Vector
07:56:04 <lingxiao> ahh greatthanks
07:57:11 <Ankhers> So something like `t ! 1' would give you an element.
07:57:20 <tpsinnem> i'm reading http://stackoverflow.com/questions/17281556/whats-the-conceptual-difference-between-machines-and-conduits-or-other-similar and there's a thing i didn't understand about the quantifier explanation. what would happen if instead of "forall t . Await (t -> r) (k t) r" you just had "Await (t -> r) (k t) r"?
07:59:36 <lingxiao> does anyone know how to convert string to Data.ByteString.Internal.ByteString
08:00:16 <pmade> Data.ByteString.pack ?
08:00:18 <mniip> lingxiao, depends on what do you want to do with high unicode entries
08:00:55 <mniip> what would correspond to "\256" for example
08:01:26 <mniip> there's 3 equally correct answers: "", "\xC3\x80", bottom
08:01:58 <lingxiao> my sepcific case is just "row1 (blah)"
08:02:03 <lingxiao> and it's the only case
08:04:24 <mniip> lingxiao, Data.ByteString.Char8.pack
08:06:35 <lingxiao> mniip thanks!
08:23:08 <lingxiao> does conduit have a function  that just awaits a value and yields it?
08:28:04 <merijn> Control.Category.id? ;) Or is conduit not an instance of Category
08:28:56 <merijn> lingxiao: Don't listen to mniip's lies >.<
08:29:24 <merijn> lingxiao: The correct way to turn it into a ByteString is Data.Text.pack :: String -> Text and then using Data.Text.Encoding to go "Text -> ByteString"
08:29:25 <mniip> merijn, well they mentioned not caring about that stuff :v
08:29:26 <CMCDragonkai> [merijn, irc.freenode.net] lingxiao: The correct way to turn it into a ByteString is Data.Text.pack :: String -> Text and then using Data.Text.Encoding to go "Text -> ByteString"
08:29:40 <mniip> nice bot
08:29:46 <mniip> ...
08:30:51 <merijn> tpsinnem: That wouldn't compile, you need to introduce the 't' variable somewhere in scope :)
08:31:08 <merijn> tpsinnem: Normally you do it on the lefthand side of the = "data Foo t = ..."
08:31:23 <merijn> tpsinnem: This example is using RankNTypes
08:31:49 <lingxiao> :(
08:31:54 <merijn> tpsinnem: It's saying that it's working for "all types 't'" by explicitly bringing 't' into scope
08:31:57 <lingxiao> so many things for strings
08:32:21 <mniip> lingxiao, C has equivalently many things for strings
08:32:34 <merijn> tpsinnem: I don't have time to explain a lot, but maybe this example use of RankNTypes clarifies things a little bit: https://gist.github.com/merijn/77e3fa9757658e59b01d
08:32:34 <mniip> except people don't know about them and mess up everytime due to this
08:32:35 <lingxiao> bleeehhh
08:32:38 <tpsinnem> merijn: ok, many thanks!
08:33:19 <merijn> tpsinnem: There's an explanation by me somewhere in the #haskell logs, if you search a bit for "merijn" and "rankn" you might find it
08:36:57 <lingxiao> merijn I am getting an error here: 
08:36:59 <lingxiao> m :: Bool -> Conduit String IO String
08:37:00 <lingxiao> m b = id b
08:37:10 <lingxiao>  Couldn't match type ‚ÄòBool‚Äô with ‚ÄòConduitM String String IO ()‚Äô
08:37:10 <lingxiao>     Expected type: Conduit String IO String
08:37:10 <lingxiao>       Actual type: Bool
08:37:31 <Ankhers> :t id
08:37:33 <lambdabot> a -> a
08:37:37 <Ankhers> > id true
08:37:39 <lambdabot>      Not in scope: ‚Äòtrue‚Äô
08:37:39 <lambdabot>      Perhaps you meant data constructor ‚ÄòTrue‚Äô (imported from Data.Bool)
08:37:44 <Ankhers> > id True
08:37:44 <mniip> :t Control.Category.id -- perhaps?
08:37:46 <lambdabot>  True
08:37:46 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k). Category cat => cat a a
08:38:00 * hackagebot syntactic 1.16.1 - Generic abstract syntax, and utilities for embedded languages  https://hackage.haskell.org/package/syntactic-1.16.1 (AndersPersson)
08:43:31 <osa1> any ideas why stack install is failing with "Preparing to download ghc-7.8.4 ...FailedConnectionException "www.haskell.org" 443" haskell.org seems online
08:46:19 <liste> osa1 can you surf to https://www.haskell.org/
08:46:24 <liste> notice the https
08:46:47 <osa1> liste: yep, it works fine
08:48:11 <Gurkenglas> There should be a place for people to post code they want refactored and others to refactor it. One finds some here and on the subreddit, but here I'm sometimes not there when requests are posted, and encouraging people to post such requests might be good.
08:49:03 <Ankhers> Gurkenglas: People don't do it for you, but there is http://codereview.stackexchange.com/
08:49:20 <tpsinnem> does anyone happen to know if anyone has been implementing http servers or other network servers using the 'machines' library?
08:49:25 <Ankhers> (I don't know how big the Haskell community is there)
08:50:54 <liste> at least Haskell is big in StackOverflow
08:51:17 <xandaros> Is it possible to have ghci treat holes like undefined, so I can test the functions I have already finished writing?
08:51:51 <xandaros> (or parts of functions I haven't)
08:52:37 <Cale> -fdefer-type-errors
08:54:03 <xandaros> Cale: Awesome, thanks! :D
08:54:20 <mariusmarius> what is the name of the haskell channel other than #haskell-blah‚Ä¶it is for technical/theoretic discussions‚Ä¶I believe its #haskell-something-something
08:54:55 <Alpha64> use the search feature of your irc client ?
08:54:56 <geekosaur> #haskell-in-depth?
08:55:06 <mariusmarius> geekosaur: thats it; thank you
08:55:16 <geekosaur> but yes, makes sense to put #haskell into channel search and see what falls out
08:55:47 <mariusmarius> This is embarrassing, but I only just realized that you could do that at all.
08:56:02 <Cale> mariusmarius: Usually it's only used as a place to move discussions from #haskell if they're going to be long and there's too much noise though
08:56:23 <geekosaur> I thought that was #haskell-overflow
08:56:25 <mariusmarius> It was always by some mysterious process that I learned of new channels.
08:56:48 <geekosaur> that said, there's not a lot of consistency (and I've not seen much in either of those channels tbh)
08:57:27 <Cale> Yeah, there's #haskell-overflow too :P
08:57:29 <mariusmarius> geekosaur: I'll keep that in mind. I had just forgotten what the name was and wanted to add it to my config file before I had forgot.
08:57:35 <Cale> They're both pretty quiet
08:57:36 <mariusmarius> Cale: added that one too! :)
09:05:07 <catgocat> Hello people can anyone tell me how the force of lazy evaluation in this example works? `lazyFunc ~() = ()`
09:07:21 * geekosaur does not understand the question, quite
09:07:42 <geekosaur> in that case it is never forced. the pattern is not matched since it's not used in the value
09:08:08 <geekosaur> > let lazyFunc ~() = () in lazyFunc (error "nope")
09:08:10 <lambdabot>  ()
09:08:15 <geekosaur> > let lazyFunc () = () in lazyFunc (error "nope")
09:08:17 <lambdabot>  *Exception: nope
09:08:48 <funk> what ides are you folks using, if any? thx for recommendation
09:09:07 <Cale> funk: My favourite text editor alongside ghci
09:09:25 <Cale> funk: and terminals to compile stuff / search through code etc.
09:09:26 <osa1> uhhh stack doesn't work no matter which GHC version choose
09:09:31 <osa1> do we have an IRC channel for stack?
09:09:51 <geekosaur> define "doesn't work"
09:10:06 <osa1> I already defined above. "...FailedConnectionException "www.haskell.org" 443"
09:10:14 <sinelaw> Cale: is there a 'thing' with empty, singleton, and append? empty :: f a, singleton: a -> f a, append :: f a -> f a -> f a
09:10:20 <sinelaw> and not a functor
09:10:25 <Cale> osa1: There is #haskell-stack though questions about it aren't unwelcome here
09:10:48 <geekosaur> I gather SO is used more for stack questions
09:11:08 <geekosaur> but I am tempted to say that if you can;t connect with stack but a browser works then you may need to deal with a proxy
09:11:13 <Cale> sinelaw: hm? There are lots of things with empty, singleton and append
09:11:22 <geekosaur> browsers can do proxy autoconfig; it's a bit harder for normal programs]
09:11:22 <sinelaw> Cale: a class
09:11:28 <osa1> yeah browser works
09:11:40 <sinelaw> Cale: a class
09:11:41 <geekosaur> (mostly because it requires JavaScript in the general case)
09:11:44 <Cale> Oh, uh, I don't think so
09:12:01 * sinelaw accidentally up+enter-ed
09:12:35 <sinelaw> it could be, called "Unfoldable"
09:12:41 <sinelaw> things that can be built from a list.
09:15:02 <barrucadu> I was wondering about an "unfoldable" class a while back, but came to the conclusion that it probably wouldn't be very useful. Because for many structures, the shape is important, not just the contents - and you can't really express shape-altering functions in a generic way.
09:15:59 <jophish> .
09:17:06 <Gurkenglas> barrucadu, https://hackage.haskell.org/package/free-4.12.1/docs/Control-Comonad-Cofree.html#v:unfold :D
09:17:15 <sinelaw> barrucadu: you could use it to build Sets and other things 
09:18:35 <catgocat> geekosaur: can you give me an example where ~ would make sense?
09:18:39 <catgocat> a very simple example, geekosaur
09:19:02 <Gurkenglas> barrucadu, also https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#v:unfold . Before you've grasped the jargon of that library, you can look at https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html#v:refold . Bask in the glory of its type signature!
09:21:30 <geekosaur> catgocat, I'm not sure there are any good "simple" examples.
09:22:14 <MarcelineVQ> I'd like to see one as well if you find something appropriate geekosaur
09:22:30 <catgocat> let lazyFunc ~(x:xs) = (); lazyFunc undefined
09:22:34 <catgocat> this is a simple example
09:22:35 <catgocat> :)
09:22:53 <monochrom> but it is not good
09:23:01 <catgocat> of course it is
09:23:25 <geekosaur> right, I provided an example in lambdabot earlier, but it doesn't really show *why* you would do it
09:23:43 <indiagreen> set1st x ~(a,b) = (x,b)
09:23:45 <Welkin> why would you want lazy pattern matching?
09:23:48 <Welkin> is that the question? :P
09:23:52 <monochrom> it also doesn't count as making sense.
09:23:53 <geekosaur> usually you are doing it to provide a lazier implementation (provide early results immediately instead of having to e.g. consume an entire list first)
09:24:19 <catgocat> I was just asking for an example of lazy pattern mathcing
09:24:22 <catgocat> but now I found it
09:24:28 <mniip> @src span
09:24:29 <lambdabot> span _ xs@[]                  = (xs, xs)
09:24:29 <lambdabot> span p xs@(x:xs') | p x       = let (ys,zs) = span p xs' in (x:ys,zs)
09:24:29 <lambdabot>                   | otherwise = ([],xs)
09:24:34 <indiagreen> catgocat: without ~, the law going like ‚Äúfst (set1st x tuple) == x‚Äù wouldn't hold
09:24:37 <mniip> wait what, that's not the source for span
09:24:44 <monochrom> no, you asked for more than that. need I quote your own words?
09:24:46 <mniip> that let should be lazy
09:25:01 <mniip> ah correct, let is irrefutable anyway
09:25:23 <Welkin> indiagreen: why is this?
09:25:40 <catgocat> mniip it's not
09:25:46 <indiagreen> Welkin: because then ‚Äúset1st x undefined‚Äù would be undefined
09:25:50 <catgocat> try let func (x:xs) = ();  func undefined
09:25:52 <indiagreen> and now it's (x, undefined)
09:26:01 <indiagreen> this is used in lenses
09:26:08 <catgocat> > let func (x:xs) = () in func undefined
09:26:11 <lambdabot>  *Exception: Prelude.undefined
09:26:11 <Welkin> indiagreen: wait, so a law won't hold if the value is undefined?
09:26:12 <mniip> catgocat, I was commenting on the strictness properties of this 'span' definition
09:26:14 <Welkin> then no laws would ever hold
09:26:14 <catgocat> > let func ~(x:xs) = () in func undefined
09:26:17 <lambdabot>  ()
09:26:19 <mniip> not whether it's a copypaste of code from base
09:26:19 <indiagreen> > set _1 1 . set _2 2 $ undefined
09:26:21 <lambdabot>      Could not deduce (Num b0)
09:26:21 <lambdabot>      from the context (Num b, Num b1, Field2 r s a2 b1, Field1 s c a b)
09:26:21 <lambdabot>        bound by the inferred type for ‚Äòe_11122‚Äô:
09:26:32 <indiagreen> > (set _1 1 . set _2 2 $ undefined) :: (Int, Int)
09:26:34 <lambdabot>  (1,2)
09:26:40 <bennofs> The state monad is also a famous example:
09:26:43 <bennofs> > flip Control.Monad.State.Strict.evalState 4 $ forever (put 3) >> return 4
09:26:46 <elperdut> indiagreen: fwiw, the intermediary conversion was to bring POSIXTime to time-1.4.0.1:Data.Time.Clock.UTC.UTCTime, via posixSecondsToUTCTime
09:26:47 <lambdabot>  mueval-core: Time limit exceeded
09:26:47 <bennofs> > flip Control.Monad.State.Lazy.evalState 4 $ forever (put 3) >> return 4
09:26:50 <lambdabot>  4
09:26:50 <geekosaur> https://wiki.haskell.org/Lazy_pattern_match section 2 has an example of when you want a lazy pattern match
09:27:04 <MarcelineVQ> geekosaur: thank you
09:27:13 <geekosaur> so you don;t have to eat an entire list (think: from e.g. getContents) to return the first result
09:27:24 <bennofs> the difference between the lazy/strict state monad is precisely that the lazy one uses a lazy pattern match for the pair, while the strict one doesn't
09:27:29 <MarcelineVQ> indiagreen: that's quite interesting
09:27:54 <tpsinnem> does anyone happen to know if anyone has been implementing a http server or other protocol servers using the 'machines' library?
09:28:03 * hackagebot ebnf-bff 0.1.0.0 - Parser combinators & EBNF, BFFs!  https://hackage.haskell.org/package/ebnf-bff-0.1.0.0 (Lokidottir)
09:28:05 * hackagebot vcache-trie 0.2.2 - patricia tries modeled above VCache  https://hackage.haskell.org/package/vcache-trie-0.2.2 (dmbarbour)
09:28:32 <codedmart> anyone use newrelic with a wai framework ie (scotty, yesod, etc)?
09:29:16 <Welkin> indiagreen: that still doesn't make sense to me that saying a law doesn't hold because it doesn't hold for undefined
09:29:30 <dmj`> codedmart: you mean helics?
09:29:39 <dmj`> @package helics
09:29:39 <lambdabot> http://hackage.haskell.org/package/helics
09:29:44 <MarcelineVQ> Welkin: is it more correct so say the equality won't hold, rather thant he law won't hold?
09:29:47 <MarcelineVQ> *to say
09:29:54 <indiagreen> no, the law wouldn't hold
09:30:33 <stianhj> I have an ordered list of data A = A { a :: Int, b :: String }, how can I takeWhile a < something?
09:30:41 <Welkin> indiagreen: why?
09:30:54 <Welkin> indiagreen: why is undefined considered a valid value?
09:31:12 <Welkin> I thought the definition of it is that it is invalid?
09:31:17 <mniip> stianhj, takeWhile ((< something) . a)
09:31:58 <indiagreen> Welkin: if it was that simple, you could say that length of [undefined, undefined, undefined] was ‚Äúinvalid‚Äù or something
09:32:08 <Cale> Or just use a lambda:  takeWhile (\x -> a x < something)
09:32:15 <indiagreen> you can only pretend that undefined isn't a value if you're using fast and loose reasoning
09:32:34 <Welkin> indiagreen: but that will only match to WHNF
09:32:40 <Welkin> so you don't know the undefined is undefine
09:32:59 <stianhj> mniip: thanks
09:33:02 <bennofs> Welkin: would you consider it ok if you do a refactoring and it turned a previously defined value into an undefined value, even though you applied a "law" to do the refactoring?
09:33:27 <Welkin> I am confused by this statement
09:33:36 <Welkin> 12:25 < indiagreen> Welkin: because then ‚Äúset1st x undefined‚Äù would be undefined
09:33:43 <Welkin> of course this would be undefined
09:33:57 <Cale> There are cases where you only want laws to hold for defined values.
09:34:24 <Cale> For example, usually we don't care about the monad laws holding for partially defined values.
09:34:48 <Welkin> 12:24 < indiagreen> catgocat: without ~, the law going like ‚Äúfst (set1st x tuple) == x‚Äù wouldn't hold
09:34:51 <seeg_> hello
09:35:11 <monochrom> some applications are better served by "fst (set1st x undefined) = undefined". and some other applications are better served by "fst (set1st x undefined) = x". is that a problem?
09:35:15 <Welkin> I don't see how that makes sense
09:35:27 <seeg_> I have a parser written using Data.Binary.Get and I want to read some sequence of bytes in a loop until some byte is set to 0, how should I do it ? :)
09:35:27 <Cale> But if you want to reason about code equationally, and not just in terms of inequalities on the definedness ordering, it really helps for your equations to hold for all values of a type and not just the totally defined ones.
09:35:37 <seeg_> I'm a bit lost in this monad world :)
09:35:58 <MarcelineVQ> seeg_: Welcome, it's a fun kind of world still
09:36:29 <Fuuzetsu> I'm having a hell off a time (the bad kind) of trying to move to vector 0.11 fusion interface, from 0.10‚Ä¶ Anyone did this already?
09:36:59 <Welkin> I don't understand how set1st x undefined would even be valid
09:37:10 <mniip> seeg_, unfoldM (/= 0) get
09:37:16 <mniip> :t unfoldM
09:37:17 <lambdabot>     Not in scope: ‚ÄòunfoldM‚Äô
09:37:17 <lambdabot>     Perhaps you meant one of these:
09:37:17 <lambdabot>       ‚ÄòBS.unfoldr‚Äô (imported from Data.ByteString),
09:37:21 <mniip> >:(
09:37:23 <indiagreen> Welkin: compare with ‚Äúhead (1 : undefined) == 1‚Äù
09:37:25 <Welkin> the x will get lost
09:37:40 <indiagreen> Welkin: does it make sense to you that head of (1:x) should be 1 for any x?
09:37:41 <Welkin> yes, but (x:undefined) is not the same as undefined
09:37:46 <Welkin> indiagreen: yes
09:38:01 <Welkin> because you can match on the constructor plus the first value
09:38:03 * hackagebot publicsuffix 0.20150909 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20150909 (wereHamster)
09:38:05 <mniip> seeg_, either write the loop by hand, or https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:unfoldM
09:38:23 <monochrom> seeg_: does it look like this?  loop = do { x <- getWord8; if x==0 then return () else loop }
09:38:27 <indiagreen> Welkin: (:) doesn't have to be a constructor here
09:38:38 <indiagreen> Welkin: it could perfectly be a smart constructor or something
09:38:46 <indiagreen> i.e. a function
09:38:47 <Welkin> lazy pattern matching only defers the matching
09:38:54 <seeg_> mniip, thanks, but it's not exactly like this: I read byte, if it's 0 stop, otherwise read some sequence of bytes and after this fixed-size sequence is finished, read byte -- if 0 stop, otherwise read again
09:38:59 <Welkin> a tuple cannot be matched with undefined
09:39:19 <mniip> seeg_, then loop by hand
09:39:24 <seeg_> and I need to collect the results in the meantime :)
09:39:29 <mniip> Welkin, it can be lazily matched
09:39:45 <mniip> so that if you end up never using the bound variables, you're good
09:40:01 <Welkin> but that doesn't explain how fts (set1st x undefined) would even work
09:40:04 <Welkin> er
09:40:16 <Welkin> but that doesn't explain how `fst (set1st x undefined) == x` would even work
09:40:22 <Welkin> the x will be lost
09:40:27 <Welkin> fst only works on a tuple
09:40:29 <mniip> not really no
09:40:30 <Welkin> undefined is not a tuple
09:40:35 <mniip> set1st always returns a tuple
09:40:45 <mniip> before even evaluating the second argument
09:41:07 <indiagreen> Welkin: set1st x t = (x, snd t)
09:41:10 <Welkin> 12:23 < indiagreen> set1st x ~(a,b) = (x,b)
09:41:11 <indiagreen> does this make sense?
09:41:12 <mniip> Welkin, I'm not sure whether you are asking how pattern matching works or why is it useful
09:41:17 <Welkin> you can't match on b because it doesn't exist
09:41:33 <indiagreen> Welkin: look at my 2nd definition and say whether it looks okay to you or not
09:41:37 <seeg_> ah, ok, loop by hand was a good hint :)
09:41:43 <Welkin> indiagreen: where was that?
09:41:48 <indiagreen> 19:40 <indiagreen> Welkin: set1st x t = (x, snd t)
09:42:25 <catgocat> Why doesn't this work: http://lpaste.net/140551 It gives "conflicting definition error"
09:43:02 <Welkin> indiagreen: okay, that look valid, since snd t will not be evaluated
09:43:21 <indiagreen> and the trick is, the definitions are exactly the same
09:43:29 <indiagreen> thanks to the magic of ~
09:45:02 <indiagreen> ‚Äúf ~(a, b) = ...‚Äù is, like, literally equivalent to ‚Äúf t = let a = fst t; b = snd t; in ...‚Äù
09:45:29 <lingxiao> what's a hof that allows me to map different functions onto cases of Maybe 
09:45:30 <Welkin> okay, I see now
09:45:43 <indiagreen> lingxiao: maybe
09:45:44 <lingxiao> the function may be monadic
09:45:45 <indiagreen> :t maybe
09:45:46 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:45:54 <Welkin> what is a hof?
09:45:58 <lingxiao> higher order function
09:46:22 <Welkin> I have never heard someone abbreviate it to that before
09:46:33 <Welkin> :t fromMaybe
09:46:35 <lambdabot> a -> Maybe a -> a
09:46:53 <Welkin> I don't think I ever used fromMaybe
09:46:59 <Welkin> pretty much always use maybe
09:47:03 <lingxiao> is there a verson of maybe thats monadic?
09:47:13 <monochrom> lingxiao: in "b -> (a -> b) -> Maybe a -> b", you can make b = IO () for example
09:47:21 <bennofs> lingxiao: what type signature do you expect of that version?
09:49:48 <lingxiao> hmm .. I'm working with this: go rs = maybe (return rs) (\r -> go $ rs ++ [r])
09:49:58 <dmj`> lingxiao: you can write generic monadic code that Maybe can use
09:50:11 <roelof> Hello, I have this challenge (now give a defenition of fourEqual which uses the function threeEqual in it's defenition.
09:50:28 <dmj`> lingxiao: in that case I'd use MonadPlus, do a gaurd on that condition
09:50:33 <lingxiao> http://lpaste.net/140552
09:50:37 <roelof> So I did this : fourDifferent2 :: threeDifferent -> threeDifferent -> Bool  
09:50:51 <newsham> ?type maybe (readFile "/etc/opt") (sort <$>) (getEnv "OPT")
09:50:53 <lambdabot>     Not in scope: ‚ÄògetEnv‚Äô
09:50:53 <lambdabot>     Perhaps you meant ‚ÄògetAny‚Äô (imported from Data.Monoid)
09:51:18 <roelof> but now I see this error message : The type signature for ‚ÄòfourDifferent2‚Äô       lacks an accompanying binding
09:51:24 <roelof> how to solve this one ? 
09:51:35 <mniip> roelof, you provided a type signature
09:51:36 <lingxiao> dmj` could you be more spefici?
09:51:38 <mniip> where's the definition?
09:52:01 <lingxiao> see maybe (return "0") (\a -> print . show $ a * a) Just 12 works
09:52:34 <dmj`> lingxiao: that could won't compile, maybe takes 3 arguments
09:52:40 <mniip> lingxiao, sounds wrong
09:52:47 <mniip> print returns IO ()
09:52:54 <mniip> return "0" :: IO String
09:53:01 <dmj`> lingxiao: maybe I'm missing something
09:53:05 <roelof> mniip:  here the whole function : http://lpaste.net/140553
09:53:06 <lingxiao> sorry I meant maybe (print "ok") ( ... ) Just 1
09:53:21 <dmj`> lingxiao: where's the base case
09:53:59 <Welkin> that seems odd to mix IO with matching on Maybe
09:54:08 <Welkin> why not use catMaybes?
09:54:11 <Welkin> :t catMaybes
09:54:12 <lambdabot> [Maybe a] -> [a]
09:54:20 <mniip> roelof, well first of all that's not how type signatures work
09:54:21 <Welkin> then you can mapM_ over it
09:54:24 <lingxiao> g = maybe (print "ok") (\a -> print . show $ a * a) 
09:54:39 <mniip> roelof, other than that the paste should compile
09:54:39 <lingxiao> so here's what I actually want to write:
09:54:50 <lingxiao> http://lpaste.net/140554
09:54:55 <roelof> mniip: then I will hit the book craft  what I have done wrong 
09:55:15 <Welkin> oh I see, it's not a list :P
09:55:29 <lingxiao> nvm got it!
09:55:42 <mniip> roelof, 'threeDifferent' is a type variable in your type signature
09:55:46 <lingxiao> did not await in my code 
09:55:52 <mniip> it's not related in any way to the threeDifferent function
09:56:25 <roelof> mniip:  or is the type signaturre of both fourDifferent so integer -> integer -> integer -> integer -> bool 
09:56:41 <lingxiao> thanks all!
09:56:49 <mniip> roelof, yes, except it's Integer and Bool
09:56:56 <mniip> lowercase names mean type variables
09:58:05 * hackagebot yesod-routes-flow 1.1.1 - Generate Flow routes for Yesod  https://hackage.haskell.org/package/yesod-routes-flow-1.1.1 (FelipeLessa)
09:58:41 <roelof> mniip:  wierd that the challenge says I have to use threedifferent in the definition. I thought that they mean in the type signature 
10:00:22 <roelof> mniip:  got it working. Now hits the books how I can make quicktest on threeDifferent and fourDifferent 
10:00:27 <mirpa> should I prefere Data.Text.upack instead of 'show'?
10:00:43 <mniip> roelof, definition = implementation
10:00:49 <mniip> type signature is a type signature
10:00:54 <ChristianS> mirpa: show will add quotes and escape non-ascii chars.
10:01:11 <roelof> mniip:  oke, thanks for the explanation 
10:01:22 <mirpa> ChristianS: ah, thank you
10:03:05 * hackagebot sbp 0.49.0 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.49.0 (mookerji)
10:06:09 <osa1> so I switched to another network and suddenly stack setup is working
10:07:14 <Cale> osa1: Makes sense
10:08:05 * hackagebot pred-trie 0.2.1 - Predicative tries  https://hackage.haskell.org/package/pred-trie-0.2.1 (athanclark)
10:08:09 <greymalkin> Is there a library that is good for manipulating interactive programs (e.g. libexpect, but has not been updated in a while and will not build for me)
10:08:28 <greymalkin> I'm wondering if there is a more pure-haskell solution.
10:10:31 <Cale> http://hackage.haskell.org/package/process-1.3.0.0/docs/System-Process.html has a bunch of primitive stuff which would likely be useful, but I don't know of anything higher level off hand
10:15:21 <tommd> glguy: Oh nos, irc-core pinging didn't keep me on freenode over the last POD.
10:18:15 <codedmart> dmj`: Have you used helics?
10:19:38 <geekosaur> greymalkin, there is posix-pty but it's still pretty low level compared to e.g. expect
10:22:39 <dmj`> codedmart: not yet, but I'm going to try it
10:23:06 * hackagebot sbp 0.50.2 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.50.2 (mookerji)
10:23:52 <dmj`> codedmart: seems legit
10:24:27 <adarqui> anyone ever use shellac? also shellac-haskline? i can't figure out how to remove the requirement than commands are prefixed with ':'
10:24:34 <adarqui> ie :quit :help etc
10:25:42 <codedmart> dmj`: Thanks!
10:26:12 <adarqui> ./src/System/Console/Shell.hs:       , commandStyle       = CharPrefixCommands ':'
10:26:15 <adarqui> ahh
10:34:47 <Fuuzetsu> can I escape CPP inside .chs files?
10:39:27 <kristof> I looked up the definition of the monad instance for Either and was shocked
10:39:33 <kristof> There is no monad instance for Either
10:40:12 <kristof> But there is a monad instance for (Either e). So then it clicked that you can only have monads for kinds * -> *.
10:40:35 <kristof> Someone out there is laughing, because they think it's obvious.
10:41:23 <kadoban> Hehe, yeah it's not exactly clear at first why that should be ... until it is and then it's obvious.
10:41:23 <kristof> Anyway. Got me wondering if there is a generalization of functor over kinds with more than one parameter.
10:41:37 <kristof> And then I discovered multifunctors!
10:41:43 <Ankhers> BiFunctor
10:41:47 <kristof> Why did no one tell me about multifunctors?!
10:42:03 <kadoban> Well, there's Bifunctor, yeah. Are there more? 2 is as far up as I've gone so far.
10:42:23 <Ankhers> :t bimap
10:42:25 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
10:42:59 <kristof> mfmap :: (a -> b) -> (c -> d) -> (mf a b -> mf c d)
10:43:32 <kadoban> That looks like the same, except I've never heard of mfmap ?
10:43:47 <kristof> kadoban: for every parameter c, the higher order fmap needs another function c1 -> c2
10:44:03 <kristof> I made up mfmap. Should be called mfmap2, sorry.
10:44:13 <kadoban> Oh
10:44:36 <Ankhers> The types are wrong though.
10:44:52 <osa1_> kristof: where is it defined?
10:45:12 <kristof> Multifunctors lift a product of morphisms from categories C1, C2... Cn into some morphism in set D
10:45:16 <jle`> why not putStrLn . maybe "ok" (\x -> show (x*x))
10:45:18 <kristof> osa1_ nowhere
10:45:35 <jle`> oh i was scrolled way back up, sorry
10:46:07 <kristof> So you can define a functor instance for Either by calling mfmap f id
10:46:31 <kristof> I do not think Haskell is general enough to describe a class for a kind of arbitrary parameters.
10:46:45 <kristof> That's fine though :)
10:47:01 <kristof> You can get away with an associated type and uncurrying. Maybe.
10:48:05 <kadoban> That kinda sounds like one of those things that even if you could do it, wouldn't really be that useful most of the time.
10:48:06 <kristof> kadoban: Hope that makes sense. Anyway, now I'm wondering how to generalize Applicative to multiapplicative. And monad to... Multimonad?!
10:48:07 <Ankhers> > bimap (2,"hello") (+1) (++"!")
10:48:09 <lambdabot>      Couldn't match expected type ‚Äò[Char] -> b‚Äô
10:48:09 <lambdabot>                  with actual type ‚Äò(Integer, [Char])‚Äô
10:48:09 <lambdabot>      In the first argument of ‚Äòbimap‚Äô, namely ‚Äò(2, "hello")‚Äô
10:49:08 <kristof> kadoban: Super useful. What if you error conversion functions? And you're in an Either monad but you want to change your error between computations? You need mfmap
10:49:21 <kristof> Fmap keeps error fixed
10:49:30 <kadoban> kristof: That's bimap, which already exists Bifunctor
10:49:41 <kadoban> kristof: I'm saying the general version doesn't sound like you need it very often.
10:49:41 <Fuuzetsu> I need to put a cabal-generated macro of the MIN_VERSION_foo(1,2,3) kind in a .chs file but I get ‚Äòc2hs: Error during preprocessing custom header file‚Äô, anyone dealt with this before? 
10:50:03 <kristof> kadoban: I know it does. But by saying bifunctor exists and is useful, you admit mfmap is useful by proxy :P
10:50:18 <kristof> I'm not saying mfmap should be a single general purpose function. Just the concept
10:50:19 <Ankhers> mfmap IS bimap
10:50:22 <CMCDragonkai> [Ankhers, irc.freenode.net] mfmap IS bimap
10:50:31 <Ankhers> I don't get that bot...
10:50:36 <clrnd> I love it though
10:50:47 <Ankhers> It just seems random on what it echoes
10:51:58 <liste> there's a whole lot of functors
10:52:08 <liste> Profunctor and Contravariant too
10:52:31 <kristof> Ankhers: mfmap2 is. But mfmap3 :: (a1 -> b1) -> (a2 ->b2) -> (a3->b3) -> (mf a1 a2 a3 -> mf a1 a2 a3
10:52:34 <kristof> )
10:53:07 * hackagebot th-desugar 1.5.4.1 - Functions to desugar Template Haskell  https://hackage.haskell.org/package/th-desugar-1.5.4.1 (RichardEisenberg)
10:54:29 <Ankhers> kristof: You don't need the brackets around the last part.
10:55:45 <kristof> I always add them for clarity
10:56:05 <Ankhers> kristof: and when do you stop defining mfmapN?
10:56:06 <kristof> Denotes intention to return a function
10:56:13 <liste> kristof check this out: https://www.reddit.com/r/haskell/comments/31gcqd/degenerate_bifunctor_functor/cq1xm0k
10:56:19 <kristof> Ankhers: in another language, you wouldn't have to...
10:57:18 <liste> gotta love Conor's style
10:57:52 <kristof> Ah, that's an interesting read...
10:58:45 <catgocat_> Gurkenglas: nice
10:59:52 <Prey-x> anyones here using Linux OS?
11:00:24 <Ankhers> Not at the moment, but yes.
11:00:26 <CMCDragonkai> [Ankhers, irc.freenode.net] Not at the moment, but yes.
11:00:35 <Ankhers> I really don't get it.
11:00:45 <indiagreen> CMCDragonkai: reveal your mystery
11:00:57 <liste> who made it?
11:01:07 <Ankhers> I also find it weird how it disconnects and reconnects on echo.
11:01:37 <Ankhers> nobody made it. Can't you read its ident?
11:02:02 <liste> good point :D
11:02:35 <Prey-x> who want to have some funs 
11:03:04 <Ankhers> Define funs
11:03:13 <liste> Prey-x OCaml users probably
11:03:15 <Gurkenglas> catgocat_, ooh didn't even notice it was you :D. I've discovered ala not too long ago myself and been lapping it up to the point that I find myself trying to bring other functions into a wrapping/unwrapping form that allows me to use ala.
11:03:15 <liste> we have \s
11:05:17 <Prey-x> Cyberfun 
11:09:27 <tpsinnem> does anyone happen to know if anyone has been implementing a http server or other protocol servers using the 'machines' library?
11:14:14 <eikke> > {-,-}
11:14:16 <lambdabot>  <no location info>: not an expression: ‚Äò{-,-}‚Äô
11:16:43 <enamex> {- , -}
11:16:48 <enamex> > {- , -}
11:16:50 <lambdabot>  <no location info>: not an expression: ‚Äò{- , -}‚Äô
11:17:12 <enamex> > {- -} let v = 0.0 in v
11:17:14 <lambdabot>  0.0
11:27:49 <indiagreen> how can I cache cabal-installed executables with Travis? I tried to do it like this ‚Äì https://github.com/aelve/bob/blob/master/.travis.yml#L4 ‚Äì but then my check for installed gtk2hs-buildtools at #L28 fails
11:31:47 <clrnd> what will happen with lenses once OverloadedRecordFields arrive?
11:32:11 <glguy> Nothing, overloaded records are a small part of what lens is for
11:32:52 <clrnd> I guess some work will need to be done right? or my TH lenses will clash
11:36:31 <jle`> it'd be nice if there was somehow a polymorphic absurd that worked over any types that were uninhabited
11:36:53 <jle`> it'd probably have to be a part of syntax
11:36:56 <glguy> clrnd: You can configure lens to use a different lens naming pattern if there's a collision you need to avoid
11:37:20 <glguy> makeLensesWith and makeLensesFor allow you to either change the naming rule or manually provide a list of names you want to use
11:37:28 <clrnd> glguy, I don't want to avoid the collision, I want it work like OverloadedRecordFields
11:39:03 <koomi> jle`: idris has a class Uninhabited
11:39:46 <jle`> oh that's nice
11:39:58 <jle`> does any popularish haskell library have that?
11:40:11 <Gurkenglas> Whom do I have to pay how much money to get a lambdabot on here that trusts all the packages on hackage?
11:40:39 <jle`> Gurkenglas: potentially a lot, because cabal/hackage packages can execute arbitrary IO on compilation
11:40:46 <koomi> jle`: I've never seen it
11:41:25 <dgpratt> curious: does lambdabot know how to decode base 64?
11:41:28 <clrnd> a VPS costs like 8USD, arbitrary IO is not so awful :P
11:41:44 <jle`> i guess that's fine then, heh
11:42:00 <Gurkenglas> How about all the packages that currently exist on hackage? Because I doubt someone's forseen this and already hackage'd a compile-crasher package for the lulz
11:42:24 <Gurkenglas> (Of course, saying that kicked off the race)
11:42:41 <jle`> dgpratt: i think a base 64 decoding function is in base
11:42:58 <kadoban> Haha
11:43:20 <jle`> :t showIntAtBase
11:43:21 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
11:43:59 <jle`> > showIntAtBase 64 (['a'..]!!) 7583432 ""
11:44:01 <lambdabot>  "}\156|i"
11:44:11 <jle`> you have to provide the character set for the digits though heh
11:44:15 <dgpratt> :)
11:44:34 <dgpratt> that's clever, though, thanks jle` :)
11:45:16 <jle`> i think there's also a lens for that
11:45:18 <geekosaur> Gurkenglas, http://hackage.haskell.org/package/hackager ?
11:45:41 <geekosaur> "Hackager is a program for compiling the entirety of Hackage as a way of testing a Haskell compiler."
11:45:46 <Gurkenglas> Ohh thanks.
11:46:14 <NemesisD> so this is weird: cabal --version tells me i'm using version 1.23.0.0 of the Cabal library. if load up ghci say with cabal repl and import anything from Cabal's namespace it uses the global Cabal version: 1.18.1.5
11:46:17 <geekosaur> I think I had mentioned that to you earlier but didn't have the packge name on hand, just that I knew the ghc folks used something to test ghc changes for hackagew breakages
11:46:25 <Gurkenglas> ayup
11:46:46 <geekosaur> NemesisD, presumably you built cabal-install in a sandbox with a later Cabal version
11:46:57 <Gurkenglas> Now what remains is how to figure out how to tell it that (>>) is IO () -> IO a -> IO a now, so I can find out how many errors that produces
11:47:13 <NemesisD> geekosaur: probably, i'm sure i just did whatever the git repo says
11:47:29 <NemesisD> geekosaur: but is it not safe to install the later version of the library?
11:47:44 <geekosaur> at one point, doing so could break template-haskell
11:47:50 <NemesisD> yikes
11:47:51 <geekosaur> dunno if that's still true
11:48:04 <geekosaur> it's *supposed* to be true, but...
11:48:07 <NemesisD> maybe ill just backport the thing i'm trying to do. i need to strip my executables
11:48:14 <geekosaur> I mean, it's supoosed to be replaceable/upgradeable
11:48:36 <geekosaur> but template-haskell is known to "leak" some internally used packages in fragile ways
11:48:49 <NemesisD> cabal seems to only strip executables when installing or running cabal copy. my executables are not meant to go into some global/user cabal bin directory though
11:48:50 <Gurkenglas> If I want to make a change that affects two packages, should I make a pull request for the depended-upon one first, and then on the depending on once the first one has updated, or both at the same time?
11:48:50 <geekosaur> they're trying to eliminate that
11:49:17 <NemesisD> and it seems like cabal copy --destdir=/some/specific/dir creates this insane directory structure at your destination
11:50:01 <Gurkenglas> (Specifically, I want to add modifyT and getsT as inverses of execStateT and evalStateT, analogously to modify and gets being inverses of execState and evalState.)
11:50:04 <geekosaur> I think cabal copy is not intended for anything but integration with other packaging
11:50:14 <geekosaur> looks to me like it's DESTDIR support
11:50:45 <geekosaur> so yes, it creates a directory tree at the destination, exactly as DESTDIR is expected to
11:50:46 <NemesisD> geekosaur: i'm forced to reproduce its stripping logic (including an alternate branch for how strip works on OSX)
11:51:22 <NemesisD> i wonder if i could try using cabal install with a specific bindir
11:51:33 <geekosaur> sounds like the right idea to me
11:55:44 <indiagreen> (just in case anyone is interested: answered my own Travis question by realising I had forgotten to add .cabal/bin to PATH)
11:58:09 <Welkin> does anyone know what this is about?
11:58:13 <Welkin> "~/ghc-7.8.4/lib/ghc-7.8.4/settings: openFile: does not exist (No such file or directory)"
11:58:33 <Welkin> I don't know why it is looking in my home directory for ghc...
11:58:41 <Welkin> I only had it in there for testing purposes
11:58:53 <Welkin> it is installed in /usr/local/lib and /user/local/bin
11:59:03 <kristof> Okay
11:59:10 <kristof> I've got a good definition for BiMonad
11:59:19 <kristof> But I have NO idea what a good use would even be
12:00:02 <kristof> I'm even having a hard time coming up with types of kind (* -> * -> *) besides Either
12:00:13 <wedify> I'm having trouble with building ghc. autoreconf fails in directory integer-gmp with it not finding aclocal
12:00:16 <wedify> any hints?
12:00:26 <kristof> Anyone know of any good ones?
12:00:39 <kristof> Oh! I guess there's ,
12:00:41 <kadoban> kristof: (,) ?
12:00:43 <bitemyapp> kristof: (->)
12:00:47 <bitemyapp> :k (->)
12:00:48 <lambdabot> * -> * -> *
12:00:54 <emilypi> what's a good intro to kinds
12:01:00 <Ankhers> Anyone have ops to timeout WSergio?
12:01:23 <kristof> bitemyapp: lame
12:01:32 <dmj`> emilypi: lyah has a section, http://learnyouahaskell.com/making-our-own-types-and-typeclasses#kinds-and-some-type-foo
12:01:39 <bitemyapp> kristof: MaybeT
12:01:44 <emilypi> o? i didn't know
12:01:47 <emilypi> kristof, thx bby
12:01:47 <kadoban> :k M.Map
12:01:49 <lambdabot> * -> * -> *
12:01:52 <pleiosaur> under what circumstances does haskell prevent infinite loops?
12:01:53 <kristof> bitemyapp: Ooooh transformers in general :o
12:02:08 <bitemyapp> some transformers are  * -> * -> * -> *
12:02:21 <kristof> bitemyapp: I'm really talking about MultiFunctors in general
12:02:34 <kristof> Wanted to start with BiFunctors
12:02:35 <bitemyapp> kristof: http://hackage.haskell.org/package/bloodhound-0.7.0.1/docs/src/Database-Bloodhound-Types.html#BH is * -> * -> *
12:02:50 <bitemyapp> dat deriving clause
12:03:02 <wedify> nevermind, i thought i had automake installed but i don't
12:03:31 <dmj`> :k State
12:03:32 <lambdabot> * -> * -> *
12:04:04 <kristof> dmj`: The state monad is used over one state type. When would one want to change from one state to another?
12:04:26 <kristof> Thank you for bringing my attention to transformers, though
12:04:41 <Welkin> does anyone know what could be wrong?
12:04:55 <dmj`> kristof: whenever you want, the 's' can't change, but the return type 'a' can
12:04:59 <bitemyapp> Welkin: how'd you install GHC?
12:05:03 <Welkin> I have everything in a sandbox for yesod (except the compiler)
12:05:09 <Welkin> ghc works fine 
12:05:13 <kristof> bitemyapp: So I think it's obvious that you cannot compose two monads to make a monad but you can compose to monads to make a multimonad, which might be useful?
12:05:16 <Welkin> it is just for this sandbox that it doesn't work anymore
12:05:23 <bitemyapp> kristof: you can compose two monads to make a monad.
12:05:31 <bitemyapp> kristof: [Maybe a] is a Monad.
12:05:53 <bitemyapp> kristof: you can't compose two _arbitrary_ monads about which you know nothing other than that they have a Monad instance and have a Monad.
12:06:02 <kristof> bitemyapp: the latter is what I meant
12:07:19 <Welkin> I deleted the sandbox
12:07:29 <Welkin> now recompiling, so it should take 45-60 minutes
12:07:37 --- mode: ChanServ set +o geekosaur
12:08:56 <bitemyapp> Welkin: you should use Stack :P
12:11:33 --- mode: geekosaur set -o geekosaur
12:12:12 <Welkin> well, I don't know how it happened
12:12:29 <Welkin> I thnk I created it before I had it all set up properly maybe?
12:12:40 <Welkin> I recently thought "why do I have ghc in my home directory"?
12:12:42 <Welkin> and deleted it
12:13:46 <Welkin> and all this for a stupid chrome issue
12:13:47 <Welkin> god damn
12:14:23 <Welkin> because chrome blows up on some javascript name that no other browser has a problem with :P
12:14:34 <Welkin> and broke tons of libraries
12:15:48 <clrnd> stack is wonderful, I say it once a day at least
12:19:36 --- mode: ChanServ set +o geekosaur
12:20:10 --- mode: geekosaur set +b *!~WSergio@disruptive.academy$##fix_your_connection
12:20:49 <elperdut> hi all, I have a silly question. What typeclass would i need to derive in order to be able to use my type with the ++ operator? e.g., my type is simply data People = person1 | person2 | person3. I'd like to be able to take some variable p :: People and add it to another String, e.g. something like `p ++ "is a person`.
12:21:16 <Rembane> elperdut: Show
12:21:25 <shachaf> You can't.
12:21:36 <Rembane> elperdut: But then you could use the show-function which converts your datatype to a string.
12:21:51 <Rembane> elperdut: So the short answer is what shachaf said.
12:22:33 <elperdut> hmm
12:22:58 <shachaf> A slightly longer answer is that you need to specify your question better.
12:23:08 <argent0> hi, Is it possible to write an Instance of Applicative for a GADT fixed-lenght list?
12:23:20 <argent0> here is what I have got: http://lpaste.net/revision/140559
12:23:21 <shachaf> argent0: Should be.
12:23:42 <argent0> I don't know know what to write for the definition of pure
12:24:13 <breadmonster> argent0: What are you trying to turn into an Applicative?
12:24:20 <shachaf> There's only one option.
12:24:46 <breadmonster> argent0: Try filling it with len such copies.
12:24:58 <shachaf> Well, this is a more complicated Vect type than I usually see.
12:25:16 <elperdut> i'm using a sumtype as a sort of list, e.g. data People = Person1 | Person2 | Person3. 
12:25:16 <elperdut> I use a randomization to select one of the constructors. (let selectedPerson = (randoms g :: [People]) !! 0)
12:25:17 <elperdut> I would then like to make this into a String such as selectedPerson ++ " has been selected", so that I can print this string to a file
12:25:18 <shachaf> What's this Repeat thing about?
12:25:42 <shachaf> OK. In that case, you can derive Show, and then show :: People -> String
12:25:50 <argent0> breadmonster: I know I should return n copies. but how?
12:26:32 <argent0> shachaf: Repeat is build a vector of n identical elements. I could remove it
12:26:43 <breadmonster> argent0: I have a feeling there's some incredibly complicated type hackery required.
12:26:49 <shachaf> It makes your data type into some complicated tree.
12:26:56 <Welkin> fuck!
12:26:59 <shachaf> Rather than a simple tree. :-)
12:27:00 <Welkin> what is going on?
12:27:05 <Welkin> it still gives me the same error
12:27:11 <Welkin> it is an error from yesod
12:27:28 <elperdut> shachaf: excellent! thank you
12:28:04 <argent0> shachaf, breadmonster: ok, how could pure be writen if this accursed "Repeat" constructor weren't there?
12:28:44 <Welkin> yesod: openFile: does not exist (No such file or directory)
12:28:59 <Welkin> wait, I remeber getting this error before with cabal a while back
12:29:16 <Welkin> still, this worked perfectly until today
12:29:40 <Welkin> yesod: ~/ghc-7.8.4/lib/ghc-7.8.4/settings: openFile: does not exist (No such file or directory)
12:29:47 <Welkin> why is it looking in that directory?
12:29:52 <Welkin> of course nothing exists there
12:30:13 <shachaf> @google haskell replicate gadt vector
12:30:15 <lambdabot> https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
12:30:19 <shachaf> Maybe something like that.
12:30:23 <hackrilege_> Anyone know what to call a caramorphism which calls a hyolymorphism at each recursive call?
12:30:37 * geekosaur wonders at that ~
12:30:46 <Welkin> geekosaur: well, I added that
12:30:53 <Welkin> it is just my home directory
12:31:17 <Welkin> but ghc is in /usr/local/bin and /usr/local/lib
12:31:18 <shachaf> Or e.g. https://typesandkinds.wordpress.com/2013/12/17/singletons-v0-9-released/
12:32:00 <hackrilege_> Something must have changed since yesterday welkin
12:33:15 <hackrilege_> Is edwardk or any other fixed point enthusiasts around?
12:33:55 <Peaker> hackrilege_: who isn't a fixed-point enthusiast? :)
12:34:10 <hackrilege_> Great stuff!
12:34:24 <clrnd> i'm not
12:34:34 <hackrilege_> :(
12:35:33 <argent0> shachaf: ok, I'll check it, Thanks!
12:35:56 <shachaf> Haskell fixed points are the greatest.
12:36:07 <shachaf> Well, not all of them.
12:36:13 <monochrom> wait, is that a pun?
12:36:14 <bennofs> Aren't they the least as well?
12:36:39 <dolio> Yes.
12:36:41 <shachaf> The least of Haskell fixed points are the greatest.
12:36:45 <monochrom> :)
12:36:51 <shachaf> But some fixed points might be neither least nor greatest.
12:37:29 <Welkin> okay
12:37:33 <Welkin> it is a problem with yesod-bin
12:37:44 <shachaf> I guess "least" and "greatest" aren't the best terms here, because this couldn't happen in a preorder.
12:37:54 <hackrilege_> Ok so as I understand it a hylomorphism is the generation of a set by infinite recursive calls to a function followed by a fold on that set, which must converge to some datatype altering fixed point in order to short circuit and return a value... Where this fixed point is kind odd like a base case
12:37:55 <dolio> Every type is a fixed point of Id, but most aren't the least or greatest such fixed points.
12:37:57 <shachaf> But "least" is a good initial term.
12:38:20 <shachaf> dolio: That would have been my example if someone had asked.
12:40:04 <hackrilege_> How bad is my description of a hylomorphism above?
12:44:03 <hackrilege_> I guess the problem I have is understanding the normal example of a hylomorphism defined in terms of either or just with a recursive definition of some function on left or just bit which terminates recursion on right or nothing.
12:44:17 <hackrilege_> But
12:49:56 <johnw> hackrilege_: I wonder if what you're getting at is: fix f = hylo (\(Cons f x) -> f x) (\f -> Cons f f)
12:50:34 <johnw> I didn't fully understand what you wrote, though
12:50:56 <johnw> I'm getting this definition from http://www.cs.nott.ac.uk/~gmh/bananas.pdf
12:51:21 <johnw> see also http://www.cs.ox.ac.uk/research/pdt/ap/dgp/workshop2004/cunha.pdf, perhaps
12:51:29 <d-snp> is there a nice way to separate a list into 3 lists based on some property?
12:53:10 <d-snp> oh hm maybe groupWith
12:57:11 --- mode: ChanServ set +o geekosaur
12:57:20 --- mode: geekosaur set -b *!~WSergio@disruptive.academy$##fix_your_connection
12:57:29 --- mode: geekosaur set -o geekosaur
12:57:56 <geekosaur> probably have to reinstitute it though...
12:58:07 <geekosaur> well, maybe
13:00:38 <md54short> What are real world example applicatoins for Haskell?
13:01:09 <Peaker> md54short: writing small and large programs :)
13:01:11 <bitemyapp> md54short: software, I think.
13:01:31 <Cale> md54short: Essentially everything which isn't programming microcontrollers. Also metaprogramming microcontrollers.
13:01:32 <geekosaur> xmonad, pandoc, git-annex, yesod
13:01:42 <mariusmarius> sigma at facebook
13:02:50 <Cale> md54short: Right now, I'm working at a company called Obsidian Systems and we're doing a rewrite of lanehoney.com's web application in Haskell. We're using Haskell both on the backend to serve data, and on the frontend, compiled to Javascript to generate the UI.
13:03:42 <Cale> md54short: It's pretty nice getting to use the same datastructures for both the backend and frontend, and share code between them :)
13:04:31 <md54short> Cale, are you using a haskell framework?
13:05:58 <Cale> md54short: Snap on the backend, and Reflex-dom on the frontend.
13:06:07 <clrnd> md54short, CS research is a real world example too
13:06:11 <Cale> Groundhog for database stuff
13:06:11 <johnw> Cale: I just heard about this from Ryan, congrats
13:07:53 <Cale> johnw: Yeah, it's pretty fun :)
13:11:20 <Welkin> okay
13:11:22 <Welkin> god damn
13:11:31 <Welkin> I don't often have this many issues with yesod
13:11:33 <Welkin> but wtf
13:11:46 <md54short> Peeking at snap, the writeBS made me chuckle.
13:11:54 <Welkin> it recognized changes in my template, and recompiles them
13:12:03 <Welkin> but the changes never show up!
13:12:13 <Welkin> it is showing the old templates in the browser somehow
13:12:39 <Cale> md54short: heh, yeah, that stands for ByteString
13:13:06 <d-snp> Welkin: cache?
13:13:15 <Welkin> d-snp: I cleared the cache using cabal clean
13:13:22 <d-snp> no I mean browser cache
13:13:47 <Welkin> I'll try it
13:13:51 <Welkin> god I hate browsers
13:13:54 <d-snp> yeah, they suck
13:14:07 <d-snp> if you're on chrome, try incognito (ctrl+shift+n I think)
13:15:33 <mightybyte> md54short: What are real world applications for C++?
13:16:11 <dmj`> Cale: congrats ! 
13:16:56 <Welkin> d-snp: still the same
13:17:24 <d-snp> then I don't know :D
13:17:36 <clrnd> template metaprogramming
13:19:51 <monochrom> mightybyte: too late :)
13:20:12 <mightybyte> monochrom: Darn...I love that response.
13:20:29 <d-snp> :P
13:20:31 <monochrom> I am cynical. I think they don't care.
13:22:52 <Welkin> well
13:23:04 <Welkin> it looks like it just doesn't update for this single template
13:23:08 <Welkin> others work
13:23:10 <Welkin> wtf
13:23:24 <d-snp> Welkin: there's a rule for that
13:23:30 <d-snp> step one was "notice you are confused"
13:23:46 <d-snp> step two is "realize something you know isn't what you think it is"
13:24:15 <monochrom> is there a step three?
13:24:55 <Welkin> I don't know what could possibly be the issue
13:25:06 <Welkin> I edit the template and it recompiles because it notices the change
13:25:12 <Welkin> but the change never shows up in the browser
13:25:41 <d-snp> monochrom: it queues to an action scene then where you see the protagonist feverishly working out his plan
13:26:06 <monochrom> sometimes I bypass the browser and just get at the raw HTML myself. (if there is a web server on the way, I telnet to the web server myself)
13:27:27 <yashinbasement> HI can anyone suggest for better alternative for deleteFirstsBy 
13:28:28 <monochrom> what do you need a better alternative for? what is better for your purpose, and what is your purpose?
13:29:41 <d-snp> Welkin: usually it's because what you changed is not really what you're looking at, but I have no idea about your project
13:30:05 <d-snp> perhaps a route changed, or you've got a typo somewhere
13:30:29 <Welkin> no, everything runs correctly
13:30:32 <yashinbasement> okay first of all I don't quite understand what it does
13:30:34 <Welkin> it notices the changes and recompiles
13:30:49 <Welkin> but is somehow using a version of the template that no longer exists
13:31:12 <d-snp> The deleteFirstsBy function takes a predicate and two lists and returns the first list with the first occurrence of each element of the second list removed.
13:31:49 <d-snp> heh
13:31:57 <d-snp> well that's a mind bender
13:32:21 <yashinbasement> haha
13:32:24 <d-snp> Welkin: if it really doesn't exist, you should be able to git clone your project somewhere else, run the server there, and have it be changed
13:32:39 <monochrom> yashinbasement: ok, but do you understand what you want to do?
13:33:19 <yashinbasement> I want to override the deleteFirstsBy ,
13:34:09 <d-snp> :D
13:34:18 <monochrom> ok I don't understand your logic. you want to override something you don't know?
13:34:26 <srhb> yashinbasement: If you're just back about your earlier request, you disappeared before you read several responses. Among others: nubBy (\xs -> or . map (flip elem xs))
13:34:28 <d-snp> I like your attitude :P
13:34:41 <srhb> But otherwise, yeah, better explain what you need now.
13:39:35 <yashinbasement> my main problem is https://gist.github.com/ynarwal/ec4bad36f4b374c24271
13:40:42 <srhb> yashinbasement: I think I suggested that you split this up in a data type with notes and octaves separate the other day. Did you do that?
13:41:02 <runeks> Let's say I have a file containing an array of 1 billion Word64's and I want to read these words, one by one, and fold them into a result using some function of my choice, and print that result. How would I go about doing that?
13:41:49 <d-snp> runeks: you could write that in 1 line of haskell I think
13:41:51 <yashinbasement> My whole program is using strings , so I rather stick that that, m afaid
13:41:53 <srhb> runeks: The properties of your function of choice becomes important, so it's hard to answer.
13:41:55 <d-snp> wouldn't even be a long line :P
13:41:59 <srhb> yashinbasement: OK, that's a bad idea. But good luck :)
13:42:25 <yashinbasement> :d-snap , one line ?
13:42:30 <yashinbasement> really
13:42:43 <srhb> It's just a fold over some IO action after all.
13:43:02 <runeks> srhb: let's say it is (\x y -> x 'mod' y)
13:43:04 <d-snp> yeah, you open the file, read a word, fold it into your function, print the result of the fold
13:43:22 <srhb> runeks: So the function is strict in its right argument, that becomes important for picking the fold.
13:43:50 <runeks> srhb: can you elaborate on that please?
13:43:59 <srhb> runeks: You know how foldr sum is bad?
13:44:11 <runeks> No
13:44:17 <srhb> runeks: or foldl sum without strictness on the accumulator bad in a different way?
13:44:38 <srhb> er, foldr/l (+) I meant.
13:44:53 <srhb> Point being, you need to adapt the fold you wish to use based on the properties of your accumulating function :)
13:45:14 <runeks> What's makes my function strict in its right argument?
13:45:40 <d-snp> srhb: does haskell just crash? or does it 'gc' the thunks somehow? (in the foldl)
13:45:51 <srhb> d-snp: https://wiki.haskell.org/Stack_overflow
13:46:28 <runeks> d-snp: I hereby challenge you to write that in one line of Haskell :)
13:46:43 <tsahyt> I've been playing around with GADTs, and I've been trying to implement a tree type which stores the number of contained elements as a type parameter. I can build those trees in ghci, but I'm stuck trying to implement a function that returns one of the child nodes. Can anyone point me in the right direction?
13:47:08 <MarcelineVQ> paste what you got
13:47:17 <MarcelineVQ> @lpaste
13:47:17 <lambdabot> Haskell pastebin: http://lpaste.net/
13:47:36 <tsahyt> http://lpaste.net/8800701870008958976
13:48:21 <srhb> runeks: readFile "yourfilewithanumberperline" >>= \f -> print . foldl' yourAccumulatingfunction baseacc . map read . lines
13:48:35 <srhb> runeks: Eeep, I ended up not needing the lambda.
13:48:40 <srhb> Disregard that :)
13:48:46 <srhb> runeks: But something to that extent.
13:53:07 <d-snp> runeks: what srhb said ;)
13:53:24 <d-snp> alright 3 minutes left to finish my awful function
13:59:52 <monochrom> tsahyt: what error message does your code get? I feel that it says something useful
14:01:55 <tsahyt> monochrom: "Couldn't match expected type 't' with actual type 'ElemTree n t2' because type variable 'n' would escape its scope"
14:03:04 <monochrom> can you give a type sig to leftChild?
14:03:34 <srhb> runeks: I don't know if you became silent due to thinking, but if you want to just try it out you can do readFile "numbers" >>= print . foldl' (+) 0 . map read . lines -- for a summing example.
14:03:41 <tsahyt> monochrom: I've tried and that changes the error message, but I've found no sig that makes it compile
14:04:52 <monochrom> I don't think this is meant to be allowed altogether
14:05:48 <tsahyt> I find it kind of strange that I can put something of type ElemTree n a into a branch but I can't get it out again
14:06:49 <monochrom> that would be strange if you didn't burden it with Nat types
14:07:11 <tsahyt> monochrom: I could try it with hand rolled peano naturals, but I need some kind of numbers either way
14:07:16 <monochrom> instead, the ability to go "X (n+m) -> X n" is strange.
14:08:12 <monochrom> for example, if I have a tree of type ElemTree 5 (). should leftChild give me ElemTree 0 ()? ElemTree 1 ()? ElemTree 2 ()?
14:10:35 <monochrom> and if you understand the forall in "leftChild :: forall (n : Nat) (m : Nat) . ElemTree (n + m) -> ElemTree n a", its absurdity becomes even more acute.
14:10:55 <monochrom> forall means: the user chooses. the implementer does not get to choose.
14:11:27 <broma0> Hello, I'm havining a bit of trouble generalizing some functions using mtl's classy(Lenses|Prisms). For some reason, my 'loadSource' function fails 'Could not deduce MonadError BootError m arising from use of throwError'. If anyone could point me in the right direction it'd be much appreciated!
14:11:31 <tsahyt> monochrom: I see the problem yes. I think I need something more expressive there that keeps track of the subtrees.
14:11:32 <broma0> https://github.com/broma0/hascal/blob/master/src/Main.hs
14:12:05 <tsahyt> I'll try something else tomorrow then, for now I gotta go. Thanks for the help!
14:13:21 <byorgey> broma00: the problem seems to be simply that (throwError NoSourceFile) is specifically throwing a BootError, but you have promised that loadSource can throw any type of error   (MonadError e m)
14:13:31 <byorgey> broma00: just change  MonadError e m  to   MonadError BootError m
14:13:59 <broma0> byorgey: i'd rather not use flexiblecontexts :/
14:14:01 <byorgey> Hmm, though I see you have  'AsBootError e'
14:14:15 <byorgey> broma0: FlexibleContexts is entirely harmless
14:14:42 <broma0> byorgey: i know.. but the purist in my wants to solve it without it, and then clean it up with the extension if need be
14:14:43 <byorgey> I'm not familiar with 'AsBootError' etc., maybe you need to wrap  NoSourceFile  in something to convert it to the type  e
14:15:26 <aupiff> curious to know if people here prefer lucid to blaze for html templating?
14:15:42 <broma0> aupiff: been looking for an opinion on that as well..
14:15:56 <byorgey> broma0: what is AsBootError?  Is it something you wrote yourself?
14:16:09 <broma0> generated using makeClassyPrisms from lens
14:16:33 <Sindriava> Oh hey, I haven't seen byorgey in the main channel yet! Hi! o/
14:16:52 <byorgey> hi Sindriava!
14:16:54 <broma0> if you're not familiar is basically just a class that provides the _BootError prism. I'm saying that I may be able to get the BootError out of 'e' using _BootError
14:16:54 <hackrilege_> Welkin: did you fix it? I think iv had this issue with yesod
14:17:00 <byorgey> I am always here, but I don't often chat
14:17:25 <byorgey> broma0: aha, that's it then.  If it's a prism you can also use  _BootError to construct an e
14:17:56 <broma0> byorgey: trying to take that aha moment and understand the solution....
14:18:12 <broma0> using review?
14:19:14 <byorgey> broma0: yes, or its infix version #
14:19:39 <byorgey> so in place of  throwError NoSourceFile   you want   throwError (_BootError # NoSourceFile)
14:19:57 <broma0> byorgey: got it!
14:19:59 <broma0> nice
14:20:02 <broma0> thank you!
14:20:05 <byorgey> sure!
14:26:41 <ph88> is that normal haskell files processed with CPP ??
14:27:05 <monochrom> I don't understand the question. could you reword it?
14:27:47 <ph88> https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/pragmas.html  -- For example, to enable the FFI and preprocessing with CPP
14:28:15 <byorgey> ph88: it is common for Haskell programs to be preprocessed with CPP.
14:28:22 <barrucadu> CPP crops up a lot when maintaining backwards compatibility, yes
14:28:24 <barrucadu> Sadly
14:28:27 <monochrom> if you need FFI, you enable FFI. if you don't need FFI, you don't enable FFI.
14:28:44 <monochrom> if you need CPP, you enable CPP. if you don't need CPP, you don't enable CPP.
14:29:20 <monochrom> that user guide section is telling you about the syntax of LANGUAGE pragmas, not what is normal.
14:30:45 <wedify> welp i built ghc. besides missing some tools it was really easy
14:31:34 <ph88> so why did they go for CPP and haskell does not have its own preprocessor ?
14:31:46 <Welkin> hackrilege_: I fixed it
14:31:54 <ph88> or maybe not even a preprocessor but another solution
14:32:03 <Welkin> after all that, it ended up being a stupid error on my part
14:32:11 <monochrom> economics. insufficient supply.
14:32:15 <Welkin> I was updating the wrong template
14:32:18 <wedify> ph88: yeah i vote for partial evaluation support
14:32:19 <Welkin> addForm vs editForm
14:32:19 <ph88> oh ok
14:32:19 <int-e> ph88: because cpp was already there.
14:33:00 <ph88> wedify: ye maybe some values can be supplied up front
14:33:53 <monochrom> no one wants to implement a solution. everyone wants someone else to implement a solution.
14:34:08 <int-e> monochrom: please implement the solution
14:34:36 <monochrom> essentially everyone who asks "why doesn't it exist" belongs to the latter category
14:34:46 <Peaker> A solution is something everyone wants to have implemented, but noone wants to implement
14:34:54 <monochrom> and yes this is a moral judgment.
14:35:13 <Peaker> monochrom: unless the expected answer is: "because this and that solve this problem better"
14:35:27 <geekosaur> not quite that simple; there is hscpp, after all, and the experience from that was "it's much harder than it looks"
14:35:48 <wedify> monochrom: well i would provide the solution but i don't know how to derive implementations from types
14:35:53 <geekosaur> (hscpp would also be the answer, were commercial users not allergic to GPL variants)
14:36:14 <Fuuzetsu> I thought hscpp is going to ship by default or something, used by default on OSX or whatever
14:36:16 <Fuuzetsu> I forget
14:36:48 <wedify> i will add partial evaluation support to ghc. how hard could it be?
14:37:50 <wedify> actually couldn't we use higher-order functions to simulate partial evaluation?
14:37:55 <monochrom> yeah, just build on partial application. (joke.)
14:38:27 <wedify> ie have an program which does feature testing and then composes the functions to give a new program
15:12:34 <Pamelloes> Does an export of MyType (..) include all of the record syntax generated functions?
15:12:58 <MedDev> Pamelloes, it should
15:13:12 <Pamelloes> awesome :)
15:29:07 <wedify> in Data.Binary in ghc source i get warnings about trustworthy and inferred safe
15:29:15 <wedify> should i unmark them?
16:00:36 <catgocat> What do people do when they create data structures and want to map over a certain field?
16:00:50 <catgocat> Let's say I have a field = Option String Int Bool
16:01:06 <catgocat> what is a general way of mapping through an arbitrary field?
16:04:33 <KaneTW> general way? probably lens
16:07:35 <wavewave> hi
16:07:41 <KaneTW> hi
16:12:56 <ReinH> catgocat: yes, lens
16:13:09 <edwardk> heya wavewave
16:13:23 <catgocat> why everybody's answer to everything complicated is lens
16:13:56 <ReinH> catgocat: you're literally asking for something lens was designed to do
16:13:58 <MarcelineVQ> Reinventing the wheel is rough, I guess
16:14:03 <geekosaur> because lens is probably the easiest generics library to use
16:14:26 <geekosaur> and if you're looking for something generic over any field rather than specific, you want generics...
16:21:05 <wavewave> KaneTW, edwardk: hey!
16:21:19 <wavewave> I am now in SF. 
16:21:46 <KaneTW> catgocat: lens is complicated, but that's what exactly what you want
16:22:07 <KaneTW> you can use one of the simpler lens derivates if you want
16:22:48 <wavewave> I am wondering the status of making ghc as a cross compiler in HEAD.
16:23:05 <catgocat> I have never triedl ens
16:23:06 <catgocat> lens *
16:23:13 <Adeon> are there lots of haskellers in SF
16:23:35 <glguy> catgocat: lens is going to be your best bet for trying lens
16:24:18 <geekosaur> lens is big and scary looking, but not really as scary as it looks (unless you peek under the covers)
16:24:42 <joehillen> Adeon: http://www.meetup.com/Bay-Area-Haskell-Users-Group/
16:24:56 <wavewave> ok. now I got this link : https://github.com/ku-fpg/raspberry-pi/wiki/GHC-Cross-Compiler-for-Raspberry-Pi
16:25:01 <joehillen> Adeon: it's one of the more active haskell meetups
16:25:17 <Adeon> ooh
16:25:19 <hodapp> one of these days, I will remember that State is just a wrapper over s -> (a,s).
16:25:29 <Adeon> I moved to SF about two months ago so I might hit up some of these
16:38:19 <tomberek> i'd like to express something like:   forall b c. Arrow a => TExp (a b c) -> Q (TExp (a b c)). I don't care about b and c, they can be pairs or ints, or anything. I only care that a is an Arrow and that b and c are identical in the function. can I express this somehow so i can collect multiple morphisms into a list [ Morphism a]?
16:38:53 <tomberek> haven't had much luck with "forall" yet
16:40:29 <tomberek> hm, nvm, looks like it works
16:46:02 <Welkin> tomberek: all haskell functions declarations have an implicit forall
16:46:33 <tomberek> yeah, but i want to pack them into a collection: data ValidRule a ctx = forall b c. ctx a => V (TExp (a b c) -> Q (TExp (a b c)) ) 
16:47:11 <Welkin> adding constraints to data types is discouraged
16:47:30 <Welkin> I know that it can be done though
16:47:36 <tomberek> yes, but somehow it seems to work out here.... what's the better way?
16:47:56 <Welkin> add the constraints to your functions
16:54:11 <tomberek> Welkin: how can I group the functions together into a list? b may be instantiated to (Int,Char) or Bool for different rules. so [ValidRule a b c ctx] won't unify
17:02:01 <catgocat> In my program I have something like: putStr "pass: "; p <- getLine;     -- but I don't want the user to see the password, is there any way I can hide it like most unix command line apps?
17:03:25 <voidzero> maybe with a handle to redirect output? (hGetLine)
17:03:47 <monochrom> hSetEcho
17:03:50 <Welkin> catgocat: I think you may eed to use a terminal library
17:03:54 <catgocat> e_e
17:03:58 <Welkin> oh, that is simple monochrom 
17:03:59 <Welkin> haha
17:04:01 <catgocat> what is a solution guys?
17:04:16 <Welkin> try what monochrom suggested
17:04:18 <Welkin> it sounds right
17:04:36 <catgocat> I dont understand
17:04:37 <catgocat> how?
17:04:45 <Welkin> :t hSetEcho
17:04:47 <lambdabot> Not in scope: ‚ÄòhSetEcho‚Äô
17:04:48 <catgocat> hSetEcho stdout False?
17:05:00 <Welkin> https://hackage.haskell.org/package/base-4.8.1.0/docs/System-IO.html#v:hSetEcho
17:05:08 <Welkin> yes
17:05:42 <monochrom> stdin
17:05:46 <ReinH> I think https://hackage.haskell.org/package/haskeline can do it
17:05:55 <kasabian> hi guys, do you know how GADTs are implemented in Haskell? I'll appreciate if you can refer me to the code or some paper... thanks
17:06:45 <Welkin> kasabian: http://dev.stephendiehl.com/hask/#gadts
17:07:14 <Cale> kasabian: http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf
17:07:57 <catgocat> Here is what I ended up with: http://lpaste.net/140565
17:07:59 <kasabian> Welkin Cale thank you so much ! :)
17:08:00 <catgocat> any suggestions?
17:09:18 <Welkin> catgocat: stdin
17:09:26 <Welkin> you echo stdin
17:09:35 <Welkin> monochrom said it above
17:10:52 <catgocat> stdout is working fine
17:11:39 <Welkin> catgocat: okay
17:11:49 <ReinH> I mean, it's being echoed *to* stdout
17:11:56 <ReinH> so that makes sense
17:12:24 <monochrom> no, I think it's a coincidental happy ending due to implementation details
17:12:33 <ReinH> ah
17:12:47 <catgocat> it also works if I replace the stdout with stdin
17:12:49 <catgocat> so.............. ?
17:12:53 <ReinH> Hmm, actually it shouldn't work at all
17:13:18 <Welkin> lol
17:13:40 <monochrom> for example, on unix-like systems, you tell a terminal device, not a file descriptor, to stop echoing.
17:13:54 <ReinH> monochrom: right, and it checks if it's a terminal device
17:14:16 <Welkin> yeah, I see that in the definition of hSetEcho
17:14:29 <monochrom> but in terms of haskell API (even C API) you want to just expose "tell a file handle to stop echoing"
17:15:14 <monochrom> so you use this implementation detail: given file handle, ask for its file descriptor. then given its file descriptor, ask for its device. tell that device to stop echoing.
17:15:30 <ReinH> ah
17:15:36 <monochrom> clearly, stdin and stdout usually both points to the same terminal device
17:16:09 <monochrom> you know what, when I was typing out the above, I was so tempted to s/stop echoing/shut up/ :)
17:16:22 <ReinH> :p
17:16:22 <monochrom> "tell the terminal to shut up" :)
17:23:40 * hackagebot pred-trie 0.2.3 - Predicative tries  https://hackage.haskell.org/package/pred-trie-0.2.3 (athanclark)
17:36:26 <indiagreen> how can I fork a thread and don't let it die when the main thread is killed?
17:36:55 <indiagreen> nevermind, it's all in the docs
17:39:28 <monochrom> forkFinally helps. rather recent.
18:08:39 <ph88> is it a good idea to run   cabal install cabal-install    to get the latest cabal ?
18:08:53 <Welkin> ph88: there is no need
18:08:58 <Welkin> what verson do you have?
18:09:04 <Welkin> cabal --v
18:09:26 <ph88> well none at the moment ...
18:09:34 <Welkin> what?
18:09:44 <ph88> no cabal installed because im reinstalling the VM
18:09:45 <Welkin> cabal-install is `cabal`
18:09:54 <ph88> yes but i dont have the VM ready
18:10:08 <ph88> but i was wondering if it was good practice such as doing apt-get upgrade
18:10:44 <Welkin> it doesn't matter
18:10:47 <Welkin> as long as it works for you
18:10:56 <Welkin> and is at least version 1.18 or higher
18:10:57 <dolio> If it has some feature you want, then you could do it.
18:11:55 <ph88> well is there any harm in doing it ?
18:13:42 * hackagebot streaming 0.1.0.16 - a free monad transformer optimized for streaming applications  https://hackage.haskell.org/package/streaming-0.1.0.16 (MichaelThompson)
18:13:44 * hackagebot streaming-bytestring 0.1.0.5 - effectful byte steams, or: lazy bytestring done right  https://hackage.haskell.org/package/streaming-bytestring-0.1.0.5 (MichaelThompson)
18:13:57 <dolio> I don't think it's ever caused me problems.
18:17:51 <shachaf> cabal recommends that you cabal install cabal-install
18:19:54 <ph88> thx guys
18:20:45 <wedify> if inlinePerformIO is deprecated what should i use in its place?
18:21:02 <wedify> i'm going through and fixing warnings in ghc head
18:23:16 <Cale> wedify: Probably unsafePerformIO
18:23:23 <wedify> accursedUnutterablePerformIO sounds like a candidate
18:24:43 <Cale> Or perhaps unsafeDupablePerformIO
18:24:58 <Cale> Since if someone was using inlinePerformIO, they probably don't care about the extra check.
18:26:31 <Cale> wedify: Ah, hmm
18:26:37 <Cale> wedify: Are you looking at ByteString?
18:26:58 <KaneTW> accursedUnutterablePerformIO is what you use if you *really* want inlinePerformIO
18:27:40 <Cale> wedify: I think that deprecation warning is more aimed at people who are inexplicably importing Data.ByteString's internals, not at the developers of Data.ByteString
18:27:55 <Cale> wedify: You can just leave that alone
18:29:57 <dolio> Why leave a bunch of warnings in the code, though?
18:31:23 <wedify> looking at this page https://gitter.im/CommBank/Haskell/archives/2015/04/19 it seems accursedUnutterable is actually the candidate
18:38:43 * hackagebot number 0.1.1.0 - A library for real numbers  https://hackage.haskell.org/package/number-0.1.1.0 (rnhmjoj)
18:40:20 <Cale> dolio: A lot of warnings that GHC reports, especially with -Wall, are pretty spurious
18:40:36 <Cale> dolio: If you consistently fix all the -Wall warnings, you'll end up writing weird Haskell code
18:41:36 <dolio> This is a specific case of deprecation warnings that are easily fixed by using the non-deprecated definition.
18:41:53 <dolio> That are just noising up the build.
18:42:27 <dolio> Deprecation warnings from the package defining the deprecated function.
18:44:29 <dolio> Either fix the warnings, or turn them off. But turning off deprecation warnings is probably a bad idea.
18:45:02 <dolio> I'm not a big fan of -Wall either.
18:46:06 <jfischoff> dolio: in all situations?
18:46:15 * jfischoff likes -Wall
18:46:16 <dolio> What in all situations?
18:46:41 <dolio> I agree with Cale, -Wall has too much junk in it. Some of it is okay, some of it isn't.
18:47:46 <jfischoff> what do you consider junk? warn-unused-bind?
18:47:53 <dolio> I don't see a point in turning on -Wall and then not fixing the warnings you don't agree with, though. Just turn them back off so it doesn't obscure the things you actually want to see.
18:48:18 <dolio> Yeah, that's one, I think.
18:49:00 <jfischoff> I‚Äôm not sure I care much about defaulting either
18:49:22 <jfischoff> but in general I agree with -Wall
18:49:35 <dolio> The one that warns when you don't do '_ <- m' is the one I like least, I think.
18:49:47 <jfischoff> yeah -fno-unused-bind
18:49:59 <jfischoff> is the flag to disable it
18:50:29 <jfischoff> That is only one I wish was just removed from GHC
18:51:16 <wedify> i don't like the shadowing warning and the one that tells me a void has been discarded in a monad
18:51:25 <jfischoff> I like shadowing
18:51:53 <kadoban> The shadowing warning is good, that can lead to some big confusion.
18:51:59 <jfischoff> not having shadowing makes refactoring much safer
18:52:13 <jfischoff> I like that warning
18:52:25 <Cale> But yeah, maybe that deprecation warning should be removed
18:52:30 <Cale> I have no idea
18:52:31 <dolio> It also makes it easy to use old values that you shouldn't be using anymore.
18:52:34 <dolio> So it's a tradeoff.
18:52:56 <jfischoff> dolio: because of ‚Äúpriming‚Äù
18:53:01 <jfischoff> ?
18:53:10 * mgsloan has wanted a way to mark an identifier as an "expected shadowing"
18:53:17 <jfischoff> haha
18:53:18 <mgsloan> If it doesn't shadow something, it's an error
18:53:25 <dolio> Yeah, using the old variable name instead of the new one accidentally.
18:54:08 <mgsloan> Yeah, avoiding shadowing has avoided more bugs than it's caused, but in the case you know something *really* shouldn't be used after a point, shadowing is nice
18:54:53 <shachaf> dolio: There's an annoying asymmetry in Haskell between Monad and comonad. When I use (>>=) :: m a -> (a -> m b) -> m b, the argument to (>>=) only has one a in scope, so it's obvious what value to use just from the types.
18:54:53 <kadoban> mgsloan: That would be ... interesting. It'd have to be like syntax though, and that's kinda ... rare to allocate syntax for.
18:54:55 <dolio> Stuff like state monad internals.
18:55:09 <shachaf> When I use (=>>) :: w a -> (w a -> b) -> w b, there are two "w a" values in scope.
18:55:16 <shachaf> What's that all about?
18:55:16 <dolio> Putting increasing numbers of primes is kind of senseless.
18:55:45 <shachaf> The other side of that is that I have two different things returning "m b", but I don't really see how that could lead to wrong code.
18:55:57 <shachaf> This is probably not really related to what you were talking about.
18:56:25 <mgsloan> kadoban: I think once I had it, I'd use it quite a bit.  Agreed though, I can't think of a good syntax for it, which is the main reason I haven't proposed such a thing
18:56:46 <dolio> shachaf: Whose scope?
18:56:59 <mgsloan> We're kinda running out of syntactic real estate :/
18:57:12 <kadoban> I could actually see myself using that if it did exist though, heh. Rarely, but sometimes.
18:57:47 <mgsloan> kadoban: Honestly, most of the Haskell I write is imperative, it crops up a lot in that context
18:57:50 <dolio> shachaf: Maybe you should write in STG, where you have to explicitly declare free variables.
18:58:44 * hackagebot cartel 0.14.2.8 - Specify Cabal files in Haskell  https://hackage.haskell.org/package/cartel-0.14.2.8 (OmariNorman)
18:58:46 * hackagebot multiarg 0.30.0.10 - Command lines for options that take multiple arguments  https://hackage.haskell.org/package/multiarg-0.30.0.10 (OmariNorman)
18:58:56 <kadoban> Ahh, hmm. Yeah I'm not very prolific in haskell yet, and most of what I've done is little more than toys, so I probably don't have a very representative picture of haskell code anyway.
19:03:45 * hackagebot prednote 0.36.0.4 - Evaluate and display trees of predicates  https://hackage.haskell.org/package/prednote-0.36.0.4 (OmariNorman)
19:06:24 * mgsloan inspects each symbol key on his keyboard for likely "explicit shadowing" candidates
19:08:10 <KaneTW> jfischoff: defaulting is a warning you really should care about
19:08:39 <jfischoff> jfischoff: it can cause problems
19:08:45 <jfischoff> ha
19:08:45 * hackagebot breve 0.4.3.0 - a url shortener  https://hackage.haskell.org/package/breve-0.4.3.0 (rnhmjoj)
19:08:47 * hackagebot hsilop 0.1.2.0 - RPN calculator  https://hackage.haskell.org/package/hsilop-0.1.2.0 (rnhmjoj)
19:08:49 <mgsloan> Only almost-decent thing I can think of is "@@ident", but @@ is indeed used as an identifier in 7 different packages on stackage
19:08:49 * hackagebot shelly 1.6.3.4 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.3.4 (GregWeber)
19:08:51 <Welkin> to use a specific version of ghc with cabal, do I need to include the -w flag and path to the compiler every time I invoke a command?
19:08:55 <jfischoff> KaneTW: it can cause problems
19:08:59 <KaneTW> yeah
19:09:01 <Welkin> or can I just put that in the cabal.sandbox.config?
19:09:10 <KaneTW> if defaulting rules are ever changed your code might break in a way you don't expect
19:10:00 <kadoban> Are the defaulting rules specified in the report?
19:10:09 <jfischoff> KaneTW: true, and I‚Äôve seen pick [] when it really should not have 
19:10:50 <jfischoff> kadoban: Some but not ExtendedDefaultRules 
19:11:14 <KaneTW> default (Integer, Double) is what's written in the H2010 report
19:11:17 <kadoban> Ah
19:11:33 <KaneTW> with rules for when defaulting can apply
19:11:39 <KaneTW> 4.3.4
19:11:53 <KaneTW> those rules are relaxed when using ExtendedDefaultRules
19:11:55 <kadoban> I really dislike the warning for defaulting to Integer sometimes ... mostly just because fixing it requires a type annotation usually in the middle of something that would otherwise be nice and concise.
19:12:15 <geekosaur> Welkin, I think you can use cabal.sandbox.config
19:12:15 <kadoban> But I guess it's kinda important to get right.
19:12:34 <jfischoff> kadoban: I share this sentiment
19:12:41 <KaneTW> yeah
19:12:55 <Welkin> geekosaur: do you know the setting?
19:13:45 * hackagebot rosa 0.2.2.0 - Query the namecoin blockchain  https://hackage.haskell.org/package/rosa-0.2.2.0 (rnhmjoj)
19:14:03 <geekosaur> should be same as in ~/.cabal/config (compiler: /path/to/ghc-version)
19:14:14 <geekosaur> erm with-compiler
19:14:21 <geekosaur> and maybe with-hc-pkg
19:16:59 <Welkin> geekosaur: in the cabal.sandbox.config or cabal.config?
19:17:10 <geekosaur> they should be the same syntax
19:17:20 <geekosaur> and same settings in general, as I understand it
19:17:29 <Welkin> well, it could be a .cabal file too
19:17:44 <Welkin> there is a difference between project.cabal and cabal.config
19:18:43 <Welkin> in terms of where you can place settings
19:19:11 <echo-area> What is `v` in `Bundle v a`?  Vector?
19:19:31 <echo-area> It seems to be useless
19:20:07 <echo-area> (Data.Vector.Fusion.Bundle)
19:20:18 <glguy> it's the kind of vector the bundle is associated with
19:20:22 <glguy> fromVector :: Vector v a => v a -> Bundle v a
19:20:59 <glguy> http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Fusion-Bundle-Monadic.html#t:Bundle
19:21:09 <glguy> You can see that it's used in the fields of the record
19:21:45 <echo-area> Ah, I see, thanks
19:31:13 <wedify> whats the policy regarding updating the libraries included with ghc to the versions available on hackage?
19:31:35 <wedify> the Data.Binary on hackage already has most of the warnings fixed
19:31:42 <pseudomeme> hello everyone. Is there a function that puts a (>>=) between all of the elements of a list? I was trying to use mapM for the task but then realized it actually doesn't do that
19:32:00 <wedify> so should i just update ghc's head to use that?
19:32:14 <wedify> intercalate i think
19:32:21 <pseudomeme> it would be like `foldl1 (>>=)` but that wouldn't actually work, I think
19:33:31 <mauris> pseudomeme: you have a list of (a -> m b)?
19:33:41 <kadoban> :t foldr (=<<) -- pseudomeme
19:33:42 <lambdabot> (Monad m, Foldable t) => m a -> t (a -> m a) -> m a
19:33:42 <wedify> nevermind it's not intercalate
19:33:46 <kadoban> That? ^
19:34:09 <mauris> err, a -> m a
19:34:20 <pseudomeme> mauris: wait....it IS a list of (a -> m b). I misinterpreted the type
19:34:48 <lamefun> I have this instance `instance ListLike a Char => Predicate SingleLine a where ...' - it requires UndecidableInstances... is there another way that doesn't require it?
19:35:04 <pseudomeme> well that makes sense then, haha. Thanks! But I should use foldr, you think?
19:35:12 <mauris> pseudomeme: what do you want out of it? a big (a -> m a) that chains all the actions in the list?
19:35:46 <pseudomeme> I have a bunch of tests in hspec, but they're in a list. I want to run each one as if they were chained in a 'do'
19:37:02 <kadoban> Hmm, I'm not sure if that should be foldr or not. Maybe foldl' (>>=)  ?  Not sure.
19:37:13 <mauris> ok, so you're going from  [f, g, h]  to  f x >>= g >>= h  i guess?
19:38:56 <pseudomeme> one thing I'm unsure of is what the starting value is for the fold should be, which is why I thought foldl1 (>>=)
19:38:59 <dmj`> :t foldr (>>) 
19:39:01 <lambdabot> (Monad m, Foldable t) => m b -> t (m a) -> m b
19:39:11 <pseudomeme> or rather foldl1 (>>)
19:39:16 <dmj`> @src sequence_
19:39:17 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
19:39:35 <mauris> well, if you have [a -> m a], there are no "a" values in your list
19:39:49 <mauris> so you are forced to pass your own, fold*1 can't help you
19:39:55 <pseudomeme> theeeeeeeeeeere we go. Sequence is what I need
19:40:18 <pseudomeme> wow, okay, I was being silly. I just tried using mapM but I needed mapM_
19:40:30 <mauris> ah :) then you have [m ()], not [a -> m a]
19:40:35 <dmj`> pseudomeme: the underscore means the values get discarded
19:40:36 <kadoban> I thought you had a list of (a -> m b) :-/
19:40:44 <dmj`> :t mapM (>>=) 
19:40:45 <lambdabot> (Monad m, Traversable t) => t (m a) -> (a -> m b) -> t (m b)
19:40:49 <dmj`> if you has a list of (a -> m b)
19:40:52 <dmj`> s/has/had
19:40:58 <pseudomeme> it's not entirely clear what is in the list, but the do notation would use (>>)
19:41:13 <mauris> :t foldr (>=>) return
19:41:14 <pseudomeme> it's a bunch of `shouldBe` calls
19:41:15 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
19:41:32 <pseudomeme> so they'd chain using (>>) I realize now
19:41:43 <kadoban> Ah, I think those are IO ()
19:41:58 <kadoban> Or some type synonym thereof.
19:41:59 <dmj`> pseudomeme: can you paste your code so we're not blindly guessing
19:42:27 <pseudomeme> ha ha! mapM_ did it
19:42:35 <slack1256> ...
19:42:55 <pseudomeme> well, sequence_, but wrapped in that mapM_
19:43:22 <dmj`> @src mapM_ 
19:43:22 <lambdabot> Source not found. I am sorry.
19:43:35 <pseudomeme> that's odd ^
19:43:35 <dmj`> @src forM_
19:43:36 <lambdabot> forM_ = flip mapM_
19:44:06 <kadoban> pseudomeme: Not really. @src is just some hand-written database that lambdabot queries. So it's sometimes funky and sometimes missing a lot.
19:44:13 <pseudomeme> oh
19:51:01 <Welkin> geekosaur: that did it :)
19:51:10 <Welkin> with-compiler: path/to/ghc
19:51:35 <kristof> Do hylomorphisms translate well into strict languages?
19:54:07 <slack1256> maybe if fusion can be applied on the strict language too ( but that needs purity?)
19:55:54 <tennix> does ghc installation contain standard library source code?
19:56:29 <Welkin> tennix: yes
19:56:34 <Welkin> tennix: base is included with ghc
19:56:59 <Welkin> that also means that the base library is tied to specific versions of ghc
19:57:13 <erikd> but if you download pre-compiled binaries, the source code to base is not included, only the binaries
19:57:16 <Welkin> so if you want a different version of base, you need a different version of ghc
19:57:27 <tennix> where is it, i only find .hi libraries
19:57:55 <erikd> tennix: if you installed pre-compiled binaries, you will not have the source code
19:58:14 <tennix> in /usr/lib/ghc-version/base_
19:58:36 <platz> CUFP recordings https://www.youtube.com/playlist?list=PLnqUlCo055hXArE00SkORNiK9fk54de2a
19:58:37 <tennix> i installed with system package manager
19:59:03 <erikd> tennix: which linux distro? you probably only have binaries
19:59:13 <tennix> archlinux
19:59:32 <erikd> i run debian. the binary packages do not contain source
20:01:11 <tennix> if it contains, which directory is source code usually in
20:01:57 <erikd> tennix: on debian there is a command to list the installed contents of a package. does arch have the same?
20:02:16 <slack1256> pacman -Ql <package>
20:02:30 <erikd> tennix: ^^^^^
20:02:51 <geekosaur> ghc installation does not normally include source code
20:02:51 <tennix> yes
20:03:26 <slack1256> but If i remember correctly they included html haddock docs with source
20:03:34 <slack1256> which is what you probably want anyways
20:04:47 <tennix> btw is it a good way to learn haskell by reading the library source code?
20:05:35 <slack1256> no, but reading a book and also source code to go along with it is a sure plan
20:05:55 <slack1256> the same way having a dictionary with a novel of foreign language
20:06:28 <slack1256> (or more commonly, google translate and movies with english subtitles...)
20:06:56 <tennix> i've read learn-you-a-haskell-for-a-great-good, but stuck with monad chapter
20:07:48 <mauris> tennix: #haskell is very helpful about explaining stuff, if you're stuck on anything in specific
20:09:12 <geekosaur> I suspect the source code in the library part of the Haskell Language Report would be better; the ghc source would make significant use of optimization tricks that are for more advanced users
20:09:34 <slack1256> tennix: It also happened to me, start LYAH, get stuck on the monad chapter. start doing project euler stuff etc
20:09:35 <c_wraith> Also, lots of GHC's optimizations are ghc-specific.
20:09:40 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009 https://www.haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II
20:10:06 <tennix> ok, but i'm not an english native speaker, so maybe not quite catch up with the talks
20:13:31 <mauris> tennix: i, for one, like rambling about what monads are to people in private chats!
20:14:54 <slack1256> I also like to tell them that they are hask endomonads and losing sight of the end goal
20:14:55 <lambdadoodle> does it make sense to call monads control structures?
20:15:09 <geekosaur> not really
20:15:12 <kadoban> lambdadoodle: I don't think so.
20:15:21 <slack1256> lambdadoodle: if you consider Cont then yes
20:15:38 <lambdadoodle> no , consider the Maybe monad
20:15:43 <arkeet> because Cont is monads.
20:15:52 <slack1256> the mother of
20:16:14 <lambdadoodle> is it essentially not a long ladder of if else , zipped implicitly with every statement in the monad?
20:16:36 <slack1256> (like I said, I like losing sight of the goal :-) )
20:16:36 <geekosaur> can you explain thelist monad in that way?
20:16:53 <arkeet> or Reader, or State...
20:17:08 <arkeet> or ST
20:17:47 <geekosaur> come to think of it, list is not the best example there
20:18:04 <lambdadoodle> geekosaur: the non-determinism entailed by list is basically all enumeration in a loop yes ?
20:18:24 <lambdadoodle> arkeet: i admit ,i am at a loss for reader ,writer,st
20:18:49 * hackagebot warp-tls 3.1.3 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.1.3 (KazuYamamoto)
20:18:51 <geekosaur> Reader is in some ways the simplest monad: it's just a value passed automatically to a function
20:19:07 <scshunt> geekosaur: how about Identity? that's pretty simple
20:19:23 <geekosaur> ok, simplest one that isn't trivial >.>
20:19:36 <scshunt> Cont is pretty much the last monad you should study
20:19:42 <geekosaur> I don't think Identity helps you to figure out what Monad is though :)
20:20:00 <lambdadoodle> geekosaur: it is , but i have not understood why it is there , considering how similar it is to state monad
20:20:21 <arkeet> slack1256: "endomonad" doesn't really make sense, btw. a monad is by definition an endofunctor
20:20:26 <arkeet> (with extra stuff)
20:20:39 <geekosaur> it's "similar" in one view, significantly different in another
20:21:01 <scshunt> lambdadoodle: reader and writer are conceptually special cases of State, with write-only or read-only state
20:21:06 <tennix> so haskell2010 is like RnRs in scheme?
20:21:13 <geekosaur> Reader passes an argument to functions. State does that *and also captures part of the function's return value*
20:21:13 <scshunt> but Reader is actually implemented in a simpler fashion
20:21:29 <slack1256> arkeet: yep
20:21:31 <geekosaur> and Writer is just the latter part
20:21:34 <lambdadoodle> aah
20:22:13 <barrucadu> tennix: It's the standard, yes
20:23:49 * hackagebot open-symbology 0.1 -   https://hackage.haskell.org/package/open-symbology-0.1 (sseveran)
20:24:25 <scshunt> the ST monad is like State, except it is implemented with compiler help
20:24:48 <scshunt> it has an extra type parameter which gives it some weird properties
20:25:40 <kadoban> ST is more like IO than State, I thought.
20:25:50 <dmj`> IO is ST I thought :)
20:26:04 <lambdadoodle> kadoban: it does seem so!
20:26:32 <scshunt> ST is indeed like IO in that it has side effects
20:26:35 <jmcarthur> ST is not really like state
20:26:46 <dmj`> state threads let you escape temporarily into the imperative, w/o sacrificing referential transparency
20:27:01 <dmj`> er, into the strict? 
20:27:11 <jmcarthur> unless you are talking about state with a heterogeneous map maybe
20:27:34 <scshunt> but ST only allows it to work inside a contained box, meaning you can go back into referential transparency safely
20:27:37 <scshunt> jmcarthur: yeah
20:28:01 <scshunt> anything you can do with ST you can do with State. ST is just more specialized and likely faster, at the cost of being a headache.
20:28:04 <jmcarthur> even then it's not quite the same because it's safe to snapshot or replace the state in State. you get persistence and everything
20:28:37 <geekosaur> btw, I would mention also that what actually captures the notion of control structures is not Monad, but laziness
20:28:39 <jmcarthur> yeah, ST is less expressive but way more efficient (and which one is more convenient just depends on what you're doing)
20:28:51 <kadoban> scshunt: Kinda, but the way it works is more like IOrefs
20:29:37 <scshunt> kadoban: yeah
20:29:54 <geekosaur> although one thing Monad can capture (but it is not essential to do so!) is sequencing: do this thing THEN do that thing THEN do ...
20:29:58 <lambdadoodle> scshunt: i dont belive you can perform in-place mutation in state
20:30:12 <lambdadoodle> scshunt: u need ST for that
20:30:34 <scshunt> lambdadoodle: exactly
20:30:43 <scshunt> lambdadoodle: but I mean from a conceptual point of view
20:30:50 <scshunt> you could write a "StateRef" type
20:31:26 <lambdadoodle> scshunt: aah
20:31:37 <scshunt> possibly with some extra requirement like Typeable
20:40:01 <wilo> Hi everyone , i am python programmer, what is the first steps for programming in haskell
20:40:51 <wilo> because i think is a beautiful and productive language
20:40:58 <boyscared> first, find a computer
20:41:07 <jmcarthur> and electricity
20:41:26 <Crabbie> AFAIK, there is no paper-only python programmer, so we can consider the first two steps done
20:41:47 <jmcarthur> i am a whiteboard-only python programmer
20:41:50 <slack1256> you would be surprised
20:42:02 <wilo> boyscared: Lol sorry for my bad english
20:42:05 <jmcarthur> only when i'm interviewing somebody who knows python
20:42:32 <Crabbie> er, in that case you would be a whiteboard-only python intepreter, not programmer
20:42:43 <jmcarthur> but i write python on the whiteboard too
20:42:51 <Crabbie> because it's the inteviewee who will do the programming, right?
20:42:51 <Crabbie> oh
20:42:52 <KaneTW> i'm programming python using pythons
20:42:59 <jmcarthur> maybe i'm just a whiteboard python code generator
20:43:39 <platz> i can't say i'm very fond of the kwargs stuff in python
20:44:05 <platz> it's like every function takes a Map of args
20:44:39 <Crabbie> anyway, after getting electricity and computer, get an internet connection, go read any of the haskell books and..
20:44:46 <jmcarthur> profit
20:45:03 <Crabbie> er, what is the current endorsed way to use ghc anyway? cabal? stack? nix?
20:45:20 <slack1256> stack
20:45:27 <kadoban> Crabbie: stack is really nice
20:45:29 <jmcarthur> Crabbie: i'm starting to be tempted to recommend stack, but i haven't tried to do a "fresh" setup with it
20:45:37 <wilo> umm im reading begining haskell but http://www.apress.com/9781430262503, wonder if in case any document that could recommend me to continue learning
20:45:42 <jmcarthur> so i don't know how hard it actually is for a beginner
20:46:09 <Crabbie> I tried stack, got complains for some dependencies that aren't in stack yet, so I still go with "minimal ghc installation + sandbox"
20:46:20 <jmcarthur> i don't even know what to recommend for reading material anymore. lyah and rwh have fallen out of fashion, i know
20:46:39 <Welkin> jmcarthur: learnhaskell
20:46:42 <kadoban> Crabbie: stack can use dependencies outside of stackage. They're not synonymous.
20:46:43 <arkeet> @where learnhaskell -- I thought this is what we recommend
20:46:43 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:46:46 <Welkin> there is no single book
20:46:47 <slack1256> the current options is that course ƒÜIS I don't know what number in github
20:46:47 <jmcarthur> @where learnhaskell
20:46:48 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:46:53 <jmcarthur> bah okay
20:46:59 <slack1256> @where CIS
20:46:59 <lambdabot> I know nothing about cis.
20:47:16 <Welkin> LYAH, RWH, ParConc, Typeclassopedia, the Wiki, many papers, and blog articles are all good resources
20:47:29 <Crabbie> as for haskell materials, I say try all of them, if there is anything hard to understand, try reading about it in other sources too
20:47:30 <tennix> wilo: i wrote python before, also new to haskell
20:47:56 <Welkin> many good papers are on Simon P Jones' web page
20:47:57 <wilo> yes tennix 
20:47:59 <dmj`> typeclassopedia always wins 
20:48:08 <tennix> reading learn-you-haskell-for-a-great-good helps you get started
20:48:48 <Welkin> http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html#monads
20:48:55 <wilo> thanks tennix 
20:49:20 <Welkin> I recommend "Imperative Functional Programming" and "Lazy Functional State Threads" for learning about the foundation of monads
20:49:29 <Welkin> plus much more about the language in general
20:49:33 <Welkin> they offer great insight
20:50:08 <Welkin> I still have "Tackling the Awkward Squad" on my reading list :P
20:50:54 <jmcarthur> i distilled an overview of the expressivity of the monad hierarchy down to a tweet on my commute home from work today.     [E]ffects and [ij]nformation. Functor has i √ó E j -> E (i √ó j). Applicative adds E i √ó E j -> E (i √ó j) and E (). Monad adds E (E i) -> E i.
20:51:12 <wilo> thanks Welkin 
20:54:12 <arkeet> ijnformation?
20:54:26 <jmcarthur> the first sentence is kind of legend
20:54:32 <arkeet> I know
20:54:33 <arkeet> :p
20:54:58 <jmcarthur> just don't look at it too long
20:55:01 <kadoban> It's a travel-size burrito.
21:01:19 <Welkin> join m = m >>= id, fmap k m = m >>= return . k, m >>= k = join (fmap k m)
21:01:22 <nshepperd> does 'i √ó E j -> E (i √ó j)' really work?
21:01:23 <Welkin> I think  did that right
21:01:48 <arkeet> :t fmap . (,)
21:01:49 <nshepperd> I guess it's similar but it doesn't capture that the original j is thrown away
21:01:49 <lambdabot> Functor f => a1 -> f a -> f (a1, a)
21:03:07 <nshepperd> arkeet: quite, but you can't go the other way from (fmap . (,)) to fmap without some sort of lifted application operator
21:03:25 <arkeet> indeed
21:04:04 <benzrf> god dammit
21:04:07 <benzrf> why did nobody tell me about isinfixof
21:04:09 <benzrf> ;-;
21:06:00 <arkeet> did you ask?
21:06:02 <arkeet> :p
21:08:52 * hackagebot nationstates 0.2.0.3 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.2.0.3 (ChrisWong)
21:09:14 <jmcarthur> nshepperd: the idea is that you can add information from the outside to the information on the inside
21:09:37 <jmcarthur> nshepperd: so the j is not thrown away in general
21:09:56 <jmcarthur> nshepperd: note that i'm not trying to capture that you can drop information. i'm just showing where the information can move
21:12:49 <jmcarthur> we have isPrefixOf, isInfixOf, and isSuffixOf, but we only have stripPrefix and not stripInfix or stripSuffix
21:12:57 <jmcarthur> makes me sad
21:14:52 <jmcarthur> nshepperd: anyway, "advanced" interpretations can replace the √ó in the result with some combining function
21:16:31 <mauris> :t stripPrefix
21:16:32 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
21:17:15 <nshepperd> yeah fair enough
21:23:40 <lamefun> Is there a general procedure for getting rid of UndecidableInstances?
21:33:19 <dmwit> No. That's pretty much literally what "undecidable" means -- no general procedure.
21:35:14 <dmwit> Well, that's not really fair. I'm sorry I said it.
21:35:19 <dmwit> But my answer is still "no". =P
21:38:06 <lamefun> Well, I have this instance: `instance ListLike a Char => Predicate SingleLine a where ...' - what can I do about it?
21:38:54 * hackagebot robin 0.1.0.0 - A build daemon for Haskell development  https://hackage.haskell.org/package/robin-0.1.0.0 (KarlVoelker)
21:40:35 <dmwit> If you want help, you will need at the very least a minimal working example.
21:40:37 <dmwit> ?paste
21:40:37 <lambdabot> Haskell pastebin: http://lpaste.net/
21:50:25 <shachaf> dolio: I guess "whose scope" is the right answer, but who has a scope that can mix up those two things?
21:50:41 <shachaf> dolio: Maybe what you're getting at is that if I was writing in CPS, I could mix up the two continuations?
22:01:23 * iii slaps ChanServ around a bit with a large fishbot
22:07:06 <lamefun> dmwit, http://lpaste.net/8359526381301792768
22:11:52 <lamefun> (RankNTypes is there by mistake)
22:44:24 <dolio> shachaf: I meant that in 'e =>> f' depending on where you define f, e is not in scope in its definition. Of course if it's just something you're writing inline, it is.
22:44:58 <shachaf> Oh, I thought you were talking about some duality thing.
22:47:22 * hackagebot nationstates 0.2.0.3 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.2.0.3 (ChrisWong)
22:47:22 * hackagebot robin 0.1.0.0 - A build daemon for Haskell development  https://hackage.haskell.org/package/robin-0.1.0.0 (KarlVoelker)
22:51:05 <nocturne777> when using DB client libraries such as postgresql simple, if you want to return a list of something, do you guys actually use the Haskell list([]) or Vector ?
22:52:55 <glguy> lamefun: Do you understand why what you have requires undecidable instances and the question is just if you can rewrite it not to need them?
22:55:01 <liste> nocturne777 depends on the case, I'd use folds or something like pipes-postgresql-simple
22:55:18 <nocturne777> liste: in my case the collection is to be traversed completely as it is going to be serialized to json array
22:56:21 <liste> in that case I'd just use []
22:57:19 <nocturne777> liste: but isn't Haskell list is quite slow actually?
22:57:30 <nocturne777> it is essentially a linked list 
22:57:48 <liste> nocturne777 actually in that case it's a generator/iterator
22:57:50 <arkeet> depends on how you use it
22:58:13 <arkeet> it's no good for random access but fine for streaming
22:58:27 <xikuuky> Hey y'all!
22:58:31 <nocturne777> arkeet: how how about memory usage?
22:58:41 <nocturne777> would it not use more memory in comparison to vector ?
22:59:20 <arkeet> sure, it has to keep some per-node pointers and such.
22:59:36 <arkeet> assuming the entire thing has to be held in memory at once.
22:59:51 <liste> nocturne777 when streaming you only need to keep one element in memory at a time
22:59:59 <liste> so it's O(1) memory usage
23:00:09 <liste> xikuuky hello (:;
23:01:42 <nocturne777> liste: I am kind of streaming then when aeason serializes it to a JSON array and my snap handler simply returns the result
23:05:28 <KaneTW> lamefun: make your ListLike a StringLike, that should reduce the assertion size
23:06:10 <lamefun> KaneTW, then I can't re-use this: https://hackage.haskell.org/package/ListLike-4.2.0
23:06:57 <KaneTW> you're missing the fundep then
23:07:04 <KaneTW> should work with that
23:08:43 <nocturne777> liste: could you elaborate a bit more? I wonder if I need to use an additional library to achieve this streaming
23:09:52 <lamefun> KaneTW, it doesn't
23:10:39 <KaneTW> add it to Predicate too
23:10:46 <liste> nocturne777 you shouldn't need another libraray
23:11:12 <liste> just make sure to access only one element at a time
23:11:46 <KaneTW> y
23:11:51 <KaneTW> oops
23:11:52 <lamefun> KaneTW, can't (I want eg. SingleLine to work with both String and Text)
23:12:16 <liste> nocturne777 are you familiar with laziness?
23:12:24 <nocturne777> liste: sure
23:12:29 <KaneTW> lamefun:  sec
23:13:12 <nocturne777> liste: in my case, while serializing, aeson is probably going to traverse the list sequentially. so it will access one element at a time, I think
23:13:14 <KaneTW> http://lpaste.net/8359526381301792768
23:13:18 <KaneTW> that compiles
23:15:12 <nocturne777> liste: am I correct in my assumption?
23:16:43 <liste> nocturne777 that would make sense, but you can check with profiling tools
23:18:05 <SrPx> > fmap fst . listToMaybe . readP_to_S (many1 (satisfy isDigit)) $ "8090"
23:18:07 <lambdabot>  Not in scope: ‚ÄòreadP_to_S‚Äô    Not in scope: ‚Äòmany1‚Äô
23:18:07 <lambdabot>      Perhaps you meant ‚Äòmany‚Äô (imported from Control.Applicative)Not in scope...
23:18:23 <lamefun> KaneTW, so does: ListLike a Char => Predicate SingleLine a ()
23:18:34 <lamefun> or any other type instead of Char
23:18:36 <SrPx> Okay, it returns "8" because many1 generates many different parses. Can I make it return "8090"?
23:20:09 <lamefun> And Refined is not just for containers, it's for eg. Int as well (eg. Refined (FromTo 1 20) Int)
23:20:30 <KaneTW> hm
23:21:33 <KaneTW> well i'm gonna sleep for now but look up instance conditions in the ghc user guide and see what you can do to make them match those conditions
23:23:55 <nocturne777> liste: I def. need to do some profiling. The thing that bothers me the most  is that referential locality of linked lists is not so good. 
23:25:46 <roelof> some one a idea here (https://www.reddit.com/r/haskellquestions/comments/3k9s53/how_to_test_this_with_quicktest/ ) ?
23:31:23 <lamefun> I came up with this: http://lpaste.net/4508134945331347456
23:35:44 <botter> Hi, I'm following LYAH and I find the process of editing a file, then quitting, opening GHCI, testing to see if it works, quitting it and going back to the file, pretty cumbersome
23:35:54 <botter> Is there a more streamlined process of development I can follow?
23:36:08 <botter> for development*
23:36:26 <frerich> roelof: If you want to test that 'threeDifferent' function, you should think up about how to verify that it works correctly. For instance, you could say that threeDifferent should always yield the same result as 'x == y && y == z'. So you could do
23:36:41 <frerich> ?check \x y z -> (x == y) && (y == z) && (x == z) == (x == y && y == z)
23:36:42 <lambdabot>  +++ OK, passed 100 tests.
23:38:13 <frerich> roelof: Or to untangle it a bit and show your own function, you could write
23:38:29 <frerich> ?check \a b c -> let threeDifferent x y z = ( x == y ) && ( y == z) && ( x == z) in threeDifferent a b c == (a == b && b == c)
23:38:32 <lambdabot>  +++ OK, passed 100 tests.
23:38:49 <frerich> roelof: The 'threeDifferent a b c == (a == b && b == c)' is the property which quickcheck verifies.
23:40:50 <roelof> frerich:  so I can also write this :  threeDifferent x y z = (( x == y ) && ( y == z) && ( x == z)) == (( x ==y) && ( x = z) && (y ==z)) ? 
23:41:24 <roelof> that looks more how the examples on chapter 3 looks like. The in is not mentioned in chapter 3 of craft 
23:42:20 * hackagebot foldl-transduce 0.4.0.1 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.4.0.1 (DanielDiazCarrete)
23:42:43 <frerich> roelof: The 'in' belongs to the 'let' I wrote. Maybe the text you're reading didn't introduce 'let ... in ...' expressions yet.
23:43:31 <roelof> frerich:  nope , the text did not introduce it as far as I know. 
23:44:39 <frerich> roelof: I just used the let/in to make it all fit into one line. :-) You could also spell it out, as in http://paste.froglogic.com/?4215
23:45:11 <frerich> roelof: If you load this into ghci, you should be able to run 'quickCheck myTest' and then it'll call myTest with different numbers and see whether the property holds, i.e. calling 'threeDifferent x y z' is always equivalent to '(x == y) && (y == z)'
23:46:14 <roelof> frerich:  the url you pasted could not be found 
23:46:35 <frerich> roelof: It seems to work for me when I click it.
23:47:32 <roelof> wierd, when I click on http://paste.froglogic.com/?4215 I see a server not found error message
23:49:56 <zipper> LOL some official in the government angrily called some data centre guys telling them he wants his server back threatening to end their jobs when he got a server not found. He thought they'd stolen "his" sever or sold it.
23:50:36 <frerich> roelof: Err sorry
23:50:46 <frerich> roelof: I used the paste server of the company I work at heh.
23:50:48 <frerich> :-}
23:50:59 <roelof> NP 
23:51:14 <frerich> roelof: http://lpaste.net/140581 should be accessible though.
23:53:10 <roelof> frerich:  sorry for so much questions but as far as I see quickcheck only checks if a boolean is returned not if the right boolean is returned. 
23:53:27 <roelof> what is then the use of this test ? 
23:53:44 <frerich> roelof: That's right. The test itself is supposed to verify that the correct value is returned.
23:54:26 <frerich> roelof: This test attempts to find values a/b/c for which 'threeDifferent a b c' yields a different result than '(a == b && b == c)'
23:55:21 <frerich> roelof: If 'myTest' yields False, it means the test failed and QuickCheck will print the values it called myTest with.
23:55:49 <roelof> oke, I see it.  threeDifferent a b c can returned true or false  and (a == b) && ( b == c) must return the same outcome 
23:56:03 <frerich> Right
23:56:26 <roelof> oke, I think I understand it now 
23:57:26 <frerich> roelof: So quickcheck attempts to find cases where some invariant does not hold. Another case may be a function like "yell s = s ++ "!"' and then you could write a test 'myTest s = length s + 1 == length (yell s)'
23:57:32 <roelof> Haskell is not a easy language to learn at the beginning 
23:58:43 <roelof> frerich:  at work do yoy also work with Haskell ? 
