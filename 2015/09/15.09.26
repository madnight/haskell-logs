00:00:06 <Enigmagic> latermuse: hint is an easy way of loading haskell files at runtime
00:00:10 <Enigmagic> @hackage hint
00:00:10 <lambdabot> http://hackage.haskell.org/package/hint
00:05:50 <lamefun> How does Haskell cope with multiple instances? I'm using refined library and I want "instance (FromJSON a, Predicate p a) => FromJSON (Refined p a) where ...", is it an OK thing to do?
00:09:46 <latermuse> enigmagic: thanks!
00:10:51 <latermuse> looks like hint has way more functionality than I need
00:11:04 <latermuse> maybe ill just write my own library to do exactly what I need. cheers
00:12:54 <latermuse> :q
00:13:01 <latermuse> woops haha
00:13:34 * hackagebot stm-firehose 0.3.0 - Conduits and STM operations for fire hoses.  https://hackage.haskell.org/package/stm-firehose-0.3.0 (SimonMarechal)
00:33:35 * hackagebot hslogstash 0.4.2 - A library to work with, or as, a logstash server  https://hackage.haskell.org/package/hslogstash-0.4.2 (SimonMarechal)
00:35:41 <fr33domlover> bergmark, ping
00:43:19 <ttt_fff> is there a way in haskell to (1) get a list of all fonts installed on the system and (2) produce a pdf renderin of a-z A-Z oe each font? (I'm on OSX)
00:46:18 <nitrix> That sounds extremely problem specific. I don't think Haskell is aimed to be so centric about things like this, even as a library.
00:48:10 <nitrix> But nothing prevents you from writing your own tool that checks specific directories. I think on windows you'll have to look at the registry too.
00:48:38 <Hafydd> You'll probably want to engage the OS X API for that.
00:49:19 <Axman6> ttt_fff: any reason you can't just open Font Book.app and take a look? or do you need them programatically?
00:49:42 <Axman6> /Applications/Font\ Book.app if you weren't aware of it
00:49:50 <ttt_fff> I need access programmatiicaly
00:49:55 <ttt_fff> to render arbitrary words of my choice into png
00:50:20 <Axman6> why not use Diagrams? or do you need a lot of control of which fonts to use?
00:51:58 <Axman6> Diagrams+SVGFonts works fairly well
00:58:00 <fr33domlover> ttt_fff, take an existing font viewer and look at the source
00:58:11 <fr33domlover> e.g. iirc GNOME has a font viewer application
00:58:23 <fr33domlover> either way it's not a Haskell specific problem
00:58:38 <fr33domlover> so even if that app is written in C, you'll get there all the info you need :P
00:59:36 <jack_> I have a problem with QuickCheck. I might have encountered a compiler bug, but I'm not really sure. Can anyone reproduce this please?
00:59:47 <jack_> I am trying the following: sample ( arbitrary :: Gen [Int])
01:00:02 <jack_> This runs without any problems.
01:00:11 <jack_> [-3,-2,4,3]
01:00:11 <jack_> [-5,4,-6]
01:00:11 <jack_> [0,-5,-4,-1,-5]
01:00:13 <jack_> [10,-8,3,-3,1,-8,0]
01:00:15 <jack_> [6,6,11,8,4,-9]
01:00:17 <jack_> [14,-1]
01:00:19 <jack_> [-8]
01:00:21 <jack_> [16,-15,-10,-10,-14,6,-1,16,-6,16,9,-17,-18,18,-13,-1,-5,-2]
01:00:23 <jack_> [-9,0]
01:00:34 <montanonic>  use lpaste
01:00:46 <jack_> Yeah sure, I'm sorry.
01:00:49 <montanonic> np
01:01:54 <jack_> http://lpaste.net/141734 The compiler is hanging on the last command..
01:02:10 <jack_> Sometimes ghci crashes and sometimes it will keep hanging..
01:02:47 <jack_> I'm not sure if this is intended behaviour, but it seems normal to me to generate a list of tuples.
01:05:08 <dmwit> WFM
01:05:16 <dmwit> What compiler, QuickCheck version? What's in Main?
01:07:31 <jack_> Moment. I'm checking, but I'm not really sure how to..
01:07:45 <dmwit> ghc --version; ghc-pkg list QuickCheck
01:07:48 <Axman6> sample ( arbitrary :: Gen [(Int)]) === sample ( arbitrary :: Gen [Int])
01:08:19 <jack_> The Glorious Glasgow Haskell Compilation System, version 7.10.2
01:08:19 <jack_> /Library/Frameworks/GHC.framework/Versions/7.10.2-x86_64/usr/lib/ghc-7.10.2/package.conf.d
01:08:19 <jack_>    QuickCheck-2.8.1
01:08:51 <jack_> Axman6: I know, silly example.
01:15:31 <dmwit> I only have 7.10.1 installed.
01:15:59 <jack_> dmwit: And does the example I provided run as expected?
01:16:01 <dmwit> yes
01:16:23 <jack_> Interesting..
01:18:16 <jack_> Thanks for the feedback. I'm going to install another version then and try again.
01:32:13 <georgy-> hi. besides hxt what other html parsers are usually recommended?
01:32:16 <georgy-> for web scraping
01:32:33 <dmwit> tagsoup
01:32:37 <cocreature> georgy-: html-conduit
01:33:31 <georgy-> thanks. do either support Text? one of the reasons I want to switch is because I am getting high memory usage with hxt when scraping a lot of pages in parallel. hxt only supports String
01:34:01 <cocreature> iirc html-conduit reads a bytestring and when you access the xml via xml-conduit you get Text
02:29:48 <ZucchiniZe> I think I am going to learn haskell soon, any pointers?
02:31:34 <pavonia> Is there a way to convert any Num to a Real, Fractional, or CReal?
02:31:48 <pavonia> Or do I need a new typeclass for that?
02:32:02 <zyla_prati> @where learnhaskell
02:32:02 <lambdabot> https://github.com/bitemyapp/learnhaskell
02:33:15 <ZucchiniZe> ty zyla_prati 
02:34:34 <Phyx-> :t mapM
02:34:35 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
02:34:41 <Phyx-> :t sequence
02:34:42 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
02:35:06 <phaazon> :t traverse
02:35:08 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
02:35:09 <phaazon> :t sequenceA
02:35:10 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
02:36:46 <pavonia> Never mind, Num is already a superclass of those :S
02:52:23 <Gurkenglas> You know how I said yesterday or so that lambdabot should have a command to find a permutation of arguments that produces the shortest @pl result?
02:52:30 <lpaste> Gurkenglas pasted ‚ÄúLambdabot utilities‚Äù at http://lpaste.net/141763
02:53:00 <Gurkenglas> @letlpaste 141763
02:53:02 <lambdabot>  Defined.
02:53:08 <Gurkenglas> @@ @@ @run permutepl @show \a b c -> b a c
02:53:09 <lambdabot> Plugin `compose' failed with: Missing ')' in nested command
02:53:41 * hackagebot luminance-samples 0.2.0.1 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.2.0.1 (DimitriSabadie)
02:54:36 <Gurkenglas> Wha? It works in my query. Maybe it's because lambdabot trims results in #haskell...
02:54:57 <knupfer> Why does OverloadedLists work with T.length ['a'..'c'], but doesn't with T.length "abc"?
03:05:18 <fr33domlover> knupfer, maybe because the latter is meant to be done with OverloadedStrings
03:08:05 <knupfer> fr33domlover: that allows the user to check programatically for syntax sugar...
03:08:45 <knupfer> it seems to me inconsistent, "abc" is a list
03:16:56 <knupfer> Is there some hope that TH will loose the stage restriction, or is this fundamentally impossible?  Just thinking at elisp macros...
03:23:35 <Wizek> Hello, http://stackoverflow.com/questions/32796116/is-there-a-haskell-2d-opengl-ui-library-that-supports-getting-dimensions-of-comp
03:25:56 <frankier> So I've installed some packages using and want to find where a symbol is defined. My ~/.cabal doesn't contain any .hs files. How do I get cabal to pull in them too?
03:26:18 <saulzar_> Wizek, You've probably discovered diagrams - but it's not quite a substitute to gloss. Answer to 2. is almost - I believe the text is problematic.
03:29:03 <frankier> Ideally I'd would have jump to definition in vim for everything pulled in using cabal, but I guess I need to get cabal so it automatically extracts source packages first. Anyone got anything like this working before?
03:33:36 <saulzar_> Wizek, I'm fairly sure they're using glut for the drawing .. so apparently there is a function to calculate it 'glutStrokeWidth'
03:35:17 <saulzar_> Wizek, The only issue is that it's currently an 'IO' operation ... e.g. https://hackage.haskell.org/package/GLUT-2.7.0.2/docs/Graphics-UI-GLUT-Fonts.html
03:53:42 <pavonia> I'm trying to use type families in type classes to give different argument types to different instance functions. However, the following doesn't seem to work http://lpaste.net/141765  How to resolve this?
04:00:40 <lyxia> pavonia: Where does it locate the error? It seems to compile fine here.
04:05:35 <pavonia> lyxia: You're right, the problem is not in the instance but in another function. I misread the error message, sorry :S
04:07:33 <_di> hi there! how can I combine these two digestive-functors forms: adtForm :: AdtEnum -> Form Text m Adt and adtTypeForm :: Form Text m AdtEnum in order to get adtCombinedForm :: Form Text m Adt?
04:07:52 <_di> I know Form is not monad, so no >>= 
04:09:26 <mrkgnao> uh, I have a typeclass BasicIsom, and three datatypes as instances of that class (Trs, Rot and Ref).
04:09:57 <mrkgnao> I also have a sum type, data Isom = Isom Trs Rot Ref.
04:10:16 <mrkgnao> how do I make a fromBasicIsom function with the signature BasicIsom a => a -> Isom?
04:10:37 <mrkgnao> owait.
04:10:41 <mrkgnao> I've solved it.
04:17:20 <Ongy> is it possible to create a data Type in a TemplateHaskell that is supposed to be used outside of the splice? I want to write a (templateHaskell) function that takes a list of names and types and creates a data constructor and some utility functions for that data type
04:22:36 <phaazon> hey
04:22:59 <phaazon> how would you represent a function in a descriptive and observable way for an imperative language?
04:23:06 <phaazon> something like, a list of instructions?
04:23:18 <phaazon> plus the signature and arguments name
04:23:18 <phaazon> ?
04:24:49 <phaazon> or I guess I could represent the ‚Äúbody‚Äù as a single instruction if I enable let expressions
04:24:59 <phaazon> a bit like in Haskell
04:38:16 <ttt_fff> https://gist.github.com/anonymous/d50a624141946caa3431
04:38:18 <ttt_fff> how is this code valid
04:38:28 <ttt_fff> how does th eindentation work?
04:38:51 <xolrup> Why would it not be valid?
04:39:33 <xolrup> If you indent the first function or top level binding, then all other top level bindings will be taken from that indentation level afaik. (or something like that)
04:41:47 <ttt_fff> so the arguments of the function don't have to be "more indented" than the 'f' ?
04:41:50 <ttt_fff> err, than the "func" ?
04:42:39 <xolrup> what arguments? 'func' takes no arguments
04:43:23 <pavonia> ttt_fff: They need to be indented more than "f"
04:44:37 <jack_> Can somebody help me with this: http://lpaste.net/141768
04:44:53 <jack_> I need to limit the range in which QuickCheck generates tuples.
04:45:14 <ttt_fff> pavonia: weren't you helping me earlier ih #latex with lualatex ?
04:45:19 <jack_> So, say for instance, that I don't want any negative numbers. Or I would like tuples to contain numbers from 1 to 10.
04:45:54 <pavonia> ttt_fff: Indeed :)
04:46:09 <ttt_fff> https://gist.github.com/anonymous/38efab993ba3f85512c7
04:46:11 <ttt_fff> man, this is weird
04:46:16 <ttt_fff> I can't belive taht code parses
04:46:40 <ttt_fff> so basilly, the important thing is "where does the statement start"
04:46:44 <ttt_fff> and not "where is the '=' sign"
04:47:54 <ttt_fff> wtf -- https://gist.github.com/anonymous/d4d17565e0af4173af34 also type checks
04:47:57 <ttt_fff> err, compiles
04:49:09 <ttt_fff> wow .... https://gist.github.com/anonymous/981e8fafe079942b29c2 type checks too
04:49:17 <ttt_fff> indentation rules are much "looser" than I had thought
04:52:06 <pavonia> You don't need to give each number literal a type annotation, btw
04:53:29 <Ongy> ok, I found it myself, template haskell is a little confusig to start with
04:54:10 <scshunt> pavonia: but it might help in some cases
04:54:54 <xolrup> In what case would it help?
04:55:19 <xolrup> wouldn't it automaticaly type them to Int due to the type of the function?
04:55:41 <pavonia> Yes, it's not necessary in this case
04:56:40 <magneticduck> haskell fun fact of the day that I did not know: the 'default' keyword exists
04:58:07 <ttt_fff> pavonia: I have redefined (+)
04:58:23 <ttt_fff> if I don't write :: Int, haskell is confused if it's Int, Float, or Double
05:24:28 <statusfailed> Are there any URL packages that can parse ByteStrings or Text ?
05:28:17 <mrkgnao> how do I printf a CReal? I'm out of ideas here.
05:28:20 <mrkgnao> anyone?
05:29:03 <statusfailed> mrkgnao: CReal from what package?
05:29:11 <phaazon> arf dammit
05:29:21 <phaazon> any people used to PolyKinds, DataKinds and GADTs?
05:29:30 <phaazon> I‚Äôd like to be able to tag singleton types
05:29:31 <Axman6> :t showCReal
05:29:32 <lambdabot> Int -> CReal -> String
05:29:47 <Axman6> > showCReal 100 pi
05:29:48 <mrkgnao> statusfailed: Data.Number.
05:29:48 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
05:30:03 <mrkgnao> Axman6, I want truncated output.
05:30:13 <mrkgnao> something like
05:30:19 <mrkgnao> printf "%.2f" pi
05:30:22 <Axman6> > showCReal 10 pi
05:30:25 <lambdabot>  "3.1415926536"
05:30:25 <phaazon> oh nevermind
05:30:28 <phaazon> I made it through :D
05:30:30 <mrkgnao> > printf "%.2f" pi
05:30:31 <lambdabot>      No instance for (Show a0)
05:30:31 <lambdabot>        arising from a use of ‚Äòshow_M613298961346397315519395‚Äô
05:30:31 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
05:30:41 <mrkgnao> > printf "%.2f" (pi :: Float)
05:30:41 <Jinxit> :|
05:30:42 <lambdabot>      No instance for (Show a0)
05:30:43 <lambdabot>        arising from a use of ‚Äòshow_M556080514387254002419407‚Äô
05:30:43 <lambdabot>      The type variable ‚Äòa0‚Äô is ambiguous
05:30:51 <phaazon> (though it‚Äôs boring I have to tick promoted ctor to types)
05:31:10 <Jinxit> > showCReal 2 pi
05:31:12 <lambdabot>  "3.14"
05:31:18 <mrkgnao> ooh
05:31:22 <mrkgnao> thanks!
05:31:37 <Jinxit> you already got the answer two times before me btw
05:34:32 <mrkgnao> :/
05:34:51 <mrkgnao> I'm not attentive enough. Gotta work on that.
05:35:00 <mrkgnao> Anyway, thanks everyone. :)
05:37:58 <jophish_> hmm, I've got a bunch of overlapping instances, but when I remove the one I've defined the overlapping one fails to compile!
05:38:23 <jophish_> one of the instances has the constraing (Num a), but the type I'm defining the instance for doesn't instance Num!
05:38:31 <jophish_> constraint*
05:39:14 <jophish_> I think what's happening here, is that the instance overlaps, but fails later on after it's been chosen
05:44:18 <jophish_> ah, fixed it. Haskell's so nice in that if one's doing something daft then the compiler tries really hard to stop one doing that
05:44:51 <phaazon> that‚Äôs the spirit, yeah
05:46:53 <jophish_> This was for some hacky test code though, just so nobody thinks me a complete idiot :)
05:47:11 <r0xtedy> hello
05:47:33 <jophish_> bennofs: would it be possible to have issues enabled on tasty-th's github page?
05:47:58 <bennofs> jophish_: oh, they're disabled? I'll enabled it
05:48:02 <jophish_> or here's fine: It would be (one click) more convenient to have a little usage example in the readme for tasty-th
05:48:07 <Fay> aloha
05:50:28 <jophish_> obviously nothing too important :)
05:50:38 <bennofs> jophish_: ok, issues enabled. I'll add an example
05:50:43 <jophish_> thanks!
05:52:19 <bennofs> jophish_: if you're looking how to use it, there's also an example on http://hackage.haskell.org/package/tasty-th-0.1.3/docs/Test-Tasty-TH.html
05:52:44 <jophish_> thanks, bennofs
05:53:49 * hackagebot brainfuck-monad 0.5.0 - BrainFuck monad  https://hackage.haskell.org/package/brainfuck-monad-0.5.0 (JoeyHess)
05:54:43 <bennofs> jophish_: hmm, I just noticed that the haddocks also contain some errors. I'll fix them as well (mostly imports + formatting)
05:57:37 <jophish_> hmm, while we're at it I've got defaultMainGenerator generating invalid code, ghc is complaining that `prop_EllipticEccentricFromTrueRange‚Äô isn't in scope.
05:57:53 <jophish_> I think this is probably something wacky I've done
05:57:58 <bennofs> jophish_: can you paste the file?
05:58:13 <jophish_> sure, it's a mess at the moment, i'll get a minimum case
05:58:45 <bennofs> jophish_: is the call to the defaultMainGenerator at the end of the file? you might be hitting the stage restriction
05:59:01 <jophish_> right at the beginning
05:59:19 <jophish_> ah, thanks again
05:59:43 <bennofs> jophish_: ah, you have to place it at the end, because TH only sees what's defined up to the point of the TH call (this is called GHC staging restriction). I should probably say this somewhere
05:59:53 <Ongy> How can I get the Type of '()' in Template haskell, to build types like 'IO ()' ?
05:59:54 <exo__> good morning meat-like-units !
06:00:15 <jophish_> bennofs: the example here could do with changing too then: http://hackage.haskell.org/package/tasty-th-0.1.3/docs/Test-Tasty-TH.html
06:00:35 <bennofs> oh, right
06:01:10 <bennofs> the package needs some polish :D
06:10:48 <brtmr> hello, i am writing an academic thesis about a program which was partially developed in haskell, and i would like to give proper references to some of the popular libraries that i have used (like attoparsec, lens, scotty, postgresql-simple...) however, some of these have do not even have a website except the hackage and github repos - do i quote those when introducing the library?
06:12:05 <jophish_> brtmr: I just referenced the hackage pages when there wasn't anything more appropriate
06:12:49 <brtmr> jophish_: i think i am gonna do the same. what did you do for authorship?
06:13:56 <brtmr> jophish_: most libraries have a main author, like edwardk for lens, but scotty only hast a list of ~50 contributors
06:16:30 <jophish_> I never had that issue. I'd probably find the principle contributer and add "et al"
06:17:30 <jophish_> at the end of the day, a link to the hackage page or similar will be enough
06:19:43 <brtmr> jophish_: Okay, thanks. I will go with the hackage links.
06:22:39 <bollu> Are there libraries for group theory and graph theory in Haskell? I was curious if I could do some algebraic graph theory
06:27:57 <hexagoxel> is there TH magic around that collects all top-level-defined-stuff with a specific type into a list?
06:32:34 <magneticduck> so this project has like, 10 lines of language pragma declarations per file
06:32:58 <Fuuzetsu> only 10?
06:32:59 <magneticduck> are these any disadvantages to just merging all of these extensions into the cabal extensions option?
06:33:08 <magneticduck> Fuuzetsu: actually a bit more
06:33:14 <magneticduck> like 14
06:33:22 <Fuuzetsu> an example disadvantage is that you can't easily load it into GHCi anymore
06:33:22 <magneticduck> the thing is, not all the files use the same pragmas
06:33:30 <magneticduck> eh why would I do that
06:33:34 <magneticduck> when cabal repl is a thing
06:33:55 <Fuuzetsu> because you might not want to use cabal repl
06:34:09 <magneticduck> why not?
06:34:18 <magneticduck> also, this is in a sandbox
06:34:35 <magneticduck> uh I guess ghc figures out that it's in a sandbox
06:35:18 <Fuuzetsu> you might not even have cabal-install in that project and just using Setup
06:35:18 <hexagoxel> ghc does not do that
06:35:32 <magneticduck> Fuuzetsu: uh
06:35:34 <pikajude> Fuuzetsu: you can still use setup repl
06:35:42 <Fuuzetsu> shrug
06:35:47 <magneticduck> uhhh
06:35:47 <Fuuzetsu> I like to use vanilla GHCi when I can
06:37:55 <magneticduck> but seriously, are there disadvantages to having language pragmas that are not used enabled?
06:38:05 <magneticduck> like, across a project, where not every language pragma is not used in every file
06:38:23 <magneticduck> having a bunch of weird text telling me things I already know in every single file seems weird
06:39:54 <bennofs> magneticduck: one example is OverloadedStrings. It makes type inference much worse in some cases
06:39:59 <hexagoxel> magneticduck: a random reader might be confused, if he/she had not read the cabal file carefully beforehand.
06:40:51 <magneticduck> hexagoxel: actually, anybody who doesn't know the language pragmas in question well would be confused
06:40:59 <mniip> instance IsString Int
06:41:16 <magneticduck> where I'm stating that I'm using them is kind of a non-issue in my mind
06:42:51 <magneticduck> bennofs: hmm
06:42:53 <hexagoxel> magneticduck: but knowing what extensions are enabled /= knowing the extensions
06:43:16 <hexagoxel> and the former is easier to figure out with in-file pragmas
06:43:38 <hexagoxel> but it is a weak argument imo
06:45:21 <hexagoxel> magneticduck: e.g. if you miss that MonadComprehensions is enabled, you might be really confused for some time.
06:47:37 <hpc> i try and keep it all in the source file
06:47:47 <hpc> you shouldn't need flags in the cabal file to make it possible to ghci a file
06:48:06 <hpc> even before the readability argument
06:48:52 * hackagebot Agda 2.4.2.4 - A dependently typed functional programming language and proof assistant  https://hackage.haskell.org/package/Agda-2.4.2.4 (AndresSicardRamirez)
06:57:15 <magneticduck> DoRec: (deprecated) Allow recursive bindings in do blocks, using the rec keyword. See also RecursiveDo.
06:57:17 <magneticduck> RecursiveDo: Allow recursive bindings using mdo, a variant of do. DoRec provides a different, preferred syntax.
06:57:22 <magneticduck> from https://downloads.haskell.org/~ghc/latest/docs/html/libraries/Cabal-1.22.4.0/Language-Haskell-Extension.htm
06:57:46 <magneticduck> anybody else feel a bit twisted by that?
06:57:48 <magneticduck> ^^
06:58:40 <hexagoxel> magneticduck: link ++ "l"
06:59:29 <magneticduck> -
07:00:22 <geekosaur> magneticduck, I think those were intended to link to the descriptions of the extensions in the ghc manual?
07:00:43 <humanoyd> What libraries should I look into if I want to perform a search over a list of words that is typo-tolerant (i.e. food should still kind of match football) and performs stemming (i.e. sings still matches singer)?
07:00:57 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#recursive-do-notation
07:01:17 <geekosaur> (2 subsections, one for the current form and one for the deprecated old one)
07:02:02 <magneticduck> yeah, but I was commenting on how RecursiveDo says it's preferred against in favour of DoRec, and DoRec says it's deprecated
07:03:23 <geekosaur> oh
07:03:47 <geekosaur> really those should not exist at all :/ it should link to the ghc manual section on extensions
07:04:01 <magneticduck> yeah
07:05:12 <geekosaur> "The options here are documented at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/flag-reference.html#idp14550592" (or probably correctly "the Language options" section of the manual for your version of ghc")
07:05:45 <geekosaur> html doesn't do version-polymorphic links >.>
07:06:04 <magneticduck> that's PHP's job, great language
07:08:52 * hackagebot HPi 0.5.1 - GPIO, I2C and SPI functions for the Raspberry Pi.  https://hackage.haskell.org/package/HPi-0.5.1 (WJWH)
07:10:13 <shirt> how do i perform a list of [IO ()] concurrently, and wait for them all to complete?
07:14:42 <magneticduck> shirt: https://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Concurrent.html
07:14:48 <fabian__> I have a really wierd problem with IxSet. I have an IxSet as one of the fields of the state in a State monad. If I add and then remove multiple items over and over again, the memory consumption just keeps growing. If I replace IxSet.delete with just setting the IxSet to empty, there is no leak
07:15:10 <fabian__> shirt: You use MVar and forkIO
07:15:32 <fabian__> shirt: or  Chan, depending on the situation
07:15:36 <shirt> i'm wondering if there's an existing library function, without having to manually deal with forkIO and MVars
07:16:54 <magneticduck> shirt: mapConcurrently
07:17:11 <magneticduck> @hoogle mapConcurrently
07:17:13 <lambdabot> No results found
07:17:26 <magneticduck> https://hackage.haskell.org/package/async-2.0.2/docs/src/Control-Concurrent-Async.html#mapConcurrently
07:17:50 <magneticduck> oh cool, also the Concurrently Monad
07:17:58 <magneticduck> anyway, go crazy
07:20:00 <fabian__> Any response on IxSet?
07:20:41 <magneticduck> fabian__: something something lazy
07:20:56 <magneticduck> something something something I don't know IxSet
07:21:06 <magneticduck> :/
07:21:06 <shirt> thanks
07:37:00 <statusfailed> Is anyone using nixos? I can't get it to install ghc 7.10.2- it tries to build every version of ghc since 7.4 instead
07:37:10 <statusfailed> which is not ideal
07:42:38 <magneticduck> statusfailed: #nixos
07:42:45 <magneticduck> I am
07:43:37 <magneticduck> statusfailed: I'm using ghc 7.10; just 'sudo nix-channel --update; nix-env -iA nixos.ghc'
07:45:28 <statusfailed> magneticduck: tried there- when I run that it starts installing ghc 7.4
07:45:47 <statusfailed> it also tries to install 7.6, 7.8, and 7.10 later
07:45:52 <statusfailed> so not sure what's going on there
07:46:11 <magneticduck> statusfailed: uh, actually I don't think you tried that, 'ghc' actually isn't in the top-level nixpkgs
07:46:17 * magneticduck messed up
07:46:22 <magneticduck> nixos.haskellPackages.ghc
07:46:37 <statusfailed> well I had -f ~/nixpkgs and -iA haskellPackages.ghc
07:46:38 <statusfailed> but yeah :p
07:46:56 <magneticduck> q_Q
07:47:03 <magneticduck> uhhh
07:47:07 <magneticduck> well #nixos is active, go there
07:47:07 <statusfailed> what did I do...
07:47:16 <magneticduck> no, your problem is just weird
07:47:18 <statusfailed> oh haha
07:47:50 <tomjaguarpaw> Hello, I'm struggling with the Hackage API.  Can I get a machine-readable dump of every "package version page", i.e. all (or most of) the data on pages like http://hackage.haskell.org/package/opaleye-0.4.0.0 ?
07:48:04 <statusfailed> I tried #nixos already. Anyway, using the direct link from hydra seems to help. I had to add some key to my configuration.nix too, not sure why tho
07:48:26 <magneticduck> that's messed up
07:48:37 <magneticduck> full output?
07:49:01 <magneticduck> unless hydra is actually corrupt, the way hydra responds to requests shouldn't influence what you're installing on your system
07:51:37 <statusfailed> magneticduck: the one-click link worked (although the cabal2nix/nix-shell dance is now trying to compile bison)
07:51:47 <statusfailed> I've definitely broken something
07:52:18 * magneticduck blinks
07:52:33 <magneticduck> your computer is possessed
07:53:07 <magneticduck> http://www.dban.org/download 
07:53:28 <statusfailed> ahaha
07:53:31 <statusfailed> I think so
07:53:33 <statusfailed> now it's compiling perl
07:53:34 <statusfailed> wtf
07:53:42 <statusfailed> I didn't ask for this ;_;
07:53:53 <statusfailed> I just wanted some haskell
07:53:59 <statusfailed> is that too much to ask
07:57:55 <fabian__> Ok either there is something Im missing or there is a space leak in IxSet
07:58:17 <fabian__> If i check for the size of the IxSet and replace it with empty if its 0, then no space leak
07:58:47 <fabian__> but if i insert in the 0-size set the memory just keeps growing
07:59:35 <tomjaguarpaw> fabian__: Paste your code?
08:01:05 <fabian__> tomjaguarpaw: Its quite much code. But its just so wierd. shouldn't a 0-size IxSet be equal to IxSet.empty? or is there some cache in the background?
08:02:35 <tomjaguarpaw> I don't know anything about IxSet.
08:02:47 <tomjaguarpaw> If you think you have a space leak you should be able to demonstrate it with a small amount of code.
08:02:55 <tomjaguarpaw> At least show us the diff between the two versions.
08:03:25 <fabian__> tomjaguarpaw: I think I need someone with IxSet familiarities. It's a quite strange library :)
08:03:30 <stephenmac7> Hello, I'm thinking about writing a CLI application, but want to be able to distribute the binaries without any ghc drama for the end user.
08:04:55 <stephenmac7> Does GHC produce binaries that work for most systems as long as they are similar to the one it was compiled on (such as Linux x86_64, Linux i686, or Windows x86_64)?
08:06:20 <ChristianS> stephenmac7: that should be the case
08:06:52 <geekosaur> if ghc (default) and libraries (configurable in ~/.cabal/config or cabal.sandbox.config) are built statically then the only problem that usually comes up is gmp
08:07:20 <geekosaur> (ro windows equivalents but you may also have to beware of mingw vs. cygwin vs. neither)
08:08:15 <hexagoxel> is there TH magic around that collects all top-level-defined-stuff with a specific type into a list?
08:08:39 <hexagoxel> alternatively, is it possible to write that?
08:08:45 <stephenmac7> geekosaur: I'm guessing gmp isn't on windows by default. Is there a way to statically build it in?
08:09:00 <geekosaur> I don't know :(
08:09:19 <geekosaur> not really a windows user/dev, just know of (some) things people have run into
08:09:39 <stephenmac7> I haven't used windows in years, but the target user base is likely mostly windows users
08:10:08 <stephenmac7> I might have better luck with something like F#, but then I'll have to settle for Mono on Linux/Mac
08:10:38 <stephenmac7> Okay, thanks for the information. I'll have to investigate further.
08:14:50 <fabian__> geekosaur: you aren't  familiar with IxSet?
08:14:57 <geekosaur> no, sorry
08:16:01 <bollu> if I have Cont r a, should I be able to get a "sane" functor instance? Functor (Cont r) ?
08:16:10 <bollu> I want to derive the laws for the continuation monad on my own
08:16:32 <bollu> I'm able to get the "other direction functor" (contravariant I think its called?)
08:16:37 <bollu> but not the actual functor
08:16:41 <hpc> @unmtl Cont r a
08:16:42 <lambdabot> (a -> r) -> r
08:16:44 <hpc> :t fmap
08:16:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:17:06 <bollu> right.. I'll try type munging. Thanks :)
08:17:09 <hpc> @djinn (a - b) -> ((a -> r) -> r) -> ((b -> r) -> r)
08:17:09 <lambdabot> Cannot parse command
08:17:15 <hpc> djinn nooooooo
08:17:26 <hpc> @djinn (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
08:17:26 <lambdabot> f a b c = b (\ d -> c (a d))
08:17:37 <hpc> oh, spoilers
08:17:43 <hpc> but yeah, use the types
08:18:08 <hpc> there's a unique definition for fmap
08:18:15 <hpc> iirc
08:21:25 <bollu> @hpc: cool, thanks!
08:21:26 <lambdabot> Unknown command, try @list
08:23:57 <athan> Hi everybody. Does anyone here use hindent?
08:24:23 <athan> I'm just wondering if it takes the code in from stdin, or you provide it as an argument. Not much CLI documentation :\
08:30:49 <lrocksmashtime1> Do people still use pipes 2.3.0 over pipes 3.0.0 ? Looking for examples on these libraries is likely to land you on the documentation for both of these libraries.
08:31:02 <johnw> they use pipes 4
08:31:37 <lrocksmashtime1> dammit
08:32:30 <lrocksmashtime1> guess it's time to look at 4 then. thanks
08:35:25 <magneticduck> lrocksmashtime1: but if you don't want your code to be immediately legacy, you should use pipes 5
08:35:28 <magneticduck> you know how these things work
08:36:04 <magneticduck> it doesn't exist yet but you can specify the dependency and make a good guess at its API and bam -- immediate future compatibility
08:36:44 <lrocksmashtime1> I just want to make sense of one of these libraries 
08:47:00 <cocreature> athan: I use hindent, but I only use the emacs mode so I have to admit I can't help you much. judging from the source it takes it's input via stdin https://github.com/chrisdone/hindent/blob/master/src/main/Main.hs#L36 . the emacs mode also seems to pass it via stdin
08:47:38 <cocreature> lrocksmashtime1: the pipes tutorial in the Tutorial is really good at helping make sense of pipes
08:48:04 <athan> cocreature: I found that out just now, but it's weird - it doesn't handle language pragmas or imports well, I'm guessing the plugin only takes what you have highlighted. Thanks though :)
08:48:20 <cocreature> athan: you usually don't call it on a file but on a single declaration
08:48:38 <cocreature> so handling language pragmas and imports is not really an issue since you simply don't call it on that
08:50:22 <td123> does anyone know about any articles about representing algebraic data types in json?
08:51:14 <cocreature> td123: let aeson derive the representation for you :) (sorry)
08:51:42 <td123> the way aeson encodes a structure loses information about the type though
08:52:06 <johnw> pipes lifts the State monad into a DSL, so that get/put from one action can be linked to the get/put from another action
08:52:25 <td123> would be nice to also preserve the name of the data constructor so that we can easily represent sum types
08:53:01 <johnw> td123: you could do it with tags, couldn't you?
08:53:14 <johnw> that's how set theory represents sums
08:54:31 <RyanGlScott> td123: I'm also confused by you what you mean. AFAIK, aeson does in fact preserve the constructor names.
08:54:38 <augur> there should be an optional compiler flag that will check for unnecessarily non-polymorphic types
08:54:52 <RyanGlScott> If you don't believe me, try running $(deriveJSON defaultOptions ''TypeName) with -ddump-splices on
08:55:29 <td123> johnw: ya, i think tags would work
08:55:37 <td123> RyanGlScott: hmm maybe i'm mistaken
09:07:39 <sphinxo> What is the difference between ^+^ and <+>?
09:08:03 <johnw> hard to know without knowing what package they're from
09:08:13 <sphinxo> Just in general
09:08:27 <johnw> whatever their difference is defined to be, then?
09:08:33 <sphinxo> I'm looking into overloading operators in my Vector datatype
09:08:57 * hackagebot foldl 1.1.2 - Composable, streaming, and efficient left folds  https://hackage.haskell.org/package/foldl-1.1.2 (GabrielGonzalez)
09:09:01 <shirt> what happened to realworldhaskell.org? http://downforeveryoneorjustme.com/realworldhaskell.org
09:09:11 <sphinxo> Should I do "instance Num Vector where"
09:09:46 <td123> johnw: RyanGlScott: hmm so played a bit with aeson and it looks like it does include tags for types with more than one data constructor, that's why I was thinking it didn't support sum types
09:09:52 <xolrup> shirt, book.realworldhaskell.org still works
09:10:22 <td123> the other issue I see is that it prevents you from having a tag field in your type, otherwise it will lose the data name
09:10:47 <FireFly> sphinxo: operators are just arbitrary operator-looking identifiers.
09:11:11 <RyanGlScott> td123: By tag name, do you mean something like data Proxy a = Proxy?
09:11:16 <sphinxo> What is the difference in this? http://lpaste.net/141770
09:11:17 <shirt> xolrup: weird, doesn't work for me
09:11:22 <FireFly> So there's no inherent semantics attached to any of them, and you could define your own as well
09:11:42 <xolrup> shirt, http://downforeveryoneorjustme.com/book.realworldhaskell.org
09:11:59 <xolrup> shirt, maybe you have some internet problems or DNS issues?
09:12:30 <sphinxo> What do they mean in that context?
09:12:53 <RyanGlScott> td123: Or a GADT like data Indexed a where IntCon :: Int -> Indexed Int?
09:13:29 <td123> RyanGlScott: data Person = Foo { tag :: String } | Bar { tag :: String } - the tag will match the contents of the data, not Foo or Bar
09:14:36 <td123> that's a minor gotcha though, this gets me 99% there anyways which might be "good enough" for now :)
09:14:58 <RyanGlScott> td123: In that case, I'm not really sure what your issue is. What isn't sufficient about the way deriveJSON does things?
09:15:30 <td123> RyanGlScott: for me nothing, but I'm planning on exposing this to users and thats where anything could happen
09:16:05 <RyanGlScott> td123: What's the worst that could happen?
09:16:42 <td123> I just need to make sure I handle that case and that's it
09:17:05 <td123> if I don't then I could lose information on what sum type it was
09:17:49 <RyanGlScott> Again, I'm not sure what you mean by "lose information". deriveJSON deliberately encodes as much info as is needed to recover the original value from a JSON object.
09:18:06 <td123> maybe an example
09:20:49 <sphinxo> What is the difference between the operators ^+^ and <+> in when used like so here http://lpaste.net/141770 ?
09:22:54 <td123> RyanGlScott: http://lpaste.net/141771 will output: {"tag":"Two"}
09:23:41 <td123> RyanGlScott: this will lead to a misclassification of the sum type
09:24:25 <td123> so I just need to make sure to put some kind of validation that prevents people from putting a tag in their type
09:24:33 <td123> custom tag*
09:25:54 <td123> ideally the tag would live outside of the object, maybe another object that contained this object to workaround this problem
09:26:48 <td123> it introduces complexity to fix that small edge case
09:26:55 <td123> so dunno if it's worth it
09:30:18 <RyanGlScott> td123: Hm, that definitely seems strange, since the way Data.Aeson.TH would do it would yield {"tag": "One", "tag": "Two"} as the encoded value
09:30:39 <RyanGlScott> (where "tag" has two meanings, one for the constructor and one for the record selector)
09:30:59 <td123> RyanGlScott: then it becomes ambiguous
09:31:11 <td123> i also don't think that's valid json right?
09:32:02 <sphinxo> Which of these three should I be doing? http://lpaste.net/141772
09:32:08 <RyanGlScott> td123: Oh, now I see what you mean. You're totally right, that isn't valid JSON.
09:32:44 <RyanGlScott> td123: I can see that by running toJSON (One "Two") instead, which does yield {"tag", "Two"}
09:32:56 <RyanGlScott> So it looks like you uncovered a latent bug :)
09:33:32 <td123> Oh boy! /s
09:34:08 <zomg> { "tag": "foo", "tag": "bar" } is technically valid JSON
09:34:32 <zomg> but in practice you have the same property being assigned two values which may result in unexpected behavior on parsing
09:35:00 <RyanGlScott> There is an easy workaround, though: you can pass an Options value with a fieldLabelModifier
09:35:35 <RyanGlScott> Something like $(deriveJSON defaultOptions{ fieldLabelModifier = ('_':) } ''Number) would be sufficient, I think
09:36:02 <sphinxo> Can anyone answer my question?
09:37:45 <Ywen> hi, does someone know the simplest way to enumerate the words of a file using conduits?
09:40:21 <lyxia> sphinxo: they don't have the same type
09:40:27 <RyanGlScott> sphinxo: Your question is a little confusing because you're using two different encoding as a Vector: one that's triple-based, and one that's list-based
09:41:03 <RyanGlScott> Assuming the triple-based approach is the one you want, the Num instance looks perfectly fine.
09:41:15 <RyanGlScott> In fact, that's how the linear library does it: http://hackage.haskell.org/package/linear-1.20.1/docs/Linear-V3.html
09:41:45 <RyanGlScott> You could also include the add, sub, and mul combinators to make it easier for users to discover that functionality, but that's up to you
09:42:38 <sphinxo> Thanks, RyanGlScott and lyxia what do you mean by combinators?
09:43:53 <RyanGlScott> sphinxo: I'm referring to the second definition of combinator on the Haskell wiki ( https://wiki.haskell.org/Combinator )
09:44:01 <RyanGlScott> That is, a way to combine things
09:44:27 <RyanGlScott> add, sub, and mul do the exact same things that the Num instance does is the point I wanted to highlight
09:45:11 <sphinxo> ahh ok
09:48:07 <Gurkenglas> I can implement <*> for my (* -> *), but not pure. What ((* -> *) -> Constraint) do I have?
09:48:58 * hackagebot withdependencies 0.2.2 - Run computations that depend on one or more elements in a stream.  https://hackage.haskell.org/package/withdependencies-0.2.2 (SimonMarechal)
09:50:50 <Gurkenglas> I even have join. Not fmap, though.
09:52:53 <exio4> I would think that of a weird structure, which functions do you have on them? which laws do they follow?
09:53:59 * hackagebot ja-base-extra 0.2.1.0 - Extra functions I require in base  https://hackage.haskell.org/package/ja-base-extra-0.2.1.0 (justus)
09:54:15 <Gurkenglas> I do have both unit and zip, maybe I should work with that version of Applicative instead
09:54:40 <exio4> well, do you have any paste? :p
09:54:41 <Gurkenglas> Want me to spoil what it is or should I try figuring out some laws?
09:55:27 <exio4> Gurkenglas: I don't really know what structure it is, wanted some extra details for trying to figuring out what it is!
09:56:03 <Gurkenglas> zip is associative, as associative as zip gets anyway
09:56:51 <exio4> Gurkenglas: which ADT is this?
09:57:05 <Gurkenglas> data Lambdabot a = Query String
09:57:35 <johnw> Gurkenglas: I think pure would be: const (Query ""), no?
09:58:05 <Gurkenglas> johnw, Query "" isn't Lambdabot a
09:58:16 <exio4> that's Const String
09:58:18 <johnw> according to that ADT it is, no?
09:58:47 <Gurkenglas> Uhh Query is a hidden constructor, and the constructors are gonna be stuff like...
09:58:59 * hackagebot withdependencies 0.2.2.1 - Run computations that depend on one or more elements in a stream.  https://hackage.haskell.org/package/withdependencies-0.2.2.1 (SimonMarechal)
09:59:10 <Gurkenglas> type :: String -> Lambdabot String
09:59:40 <Gurkenglas> "unsafeEval :: String -> Lambdabot a". Dammit.
10:00:43 <Gurkenglas> Query "@run 2 + 2" is supposed to be Num a => Lambdabot a
10:01:23 <lpaste> Gurkenglas revised ‚ÄúLambdabot utilities‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/141763
10:02:12 <Gurkenglas> I noticed that there's a problem with intermediate queries being too long, but putting things into @let memory would let me offset that, only doing that makes everything insane, so I thought I'd add some abstractions
10:03:33 <Gurkenglas> @@ @run permutepl @show \a b c -> b a c
10:03:35 <lambdabot>  @run minimumBy (comparing $ length . snd) [("a b c",(@show @pl \a b c-> b a ...
10:04:13 <Gurkenglas> There's the problem: Adding the @@ in front that would execute that gets the truncated version displayed here. (It works in a query.)
10:05:31 <Gurkenglas> (Boy did I have egg on my face earlier today when I found it doesn't work as it does in my query while showing off what I did.)
10:06:27 <bollu> :info permutepl
10:06:37 <bollu> oh, okay, How do I get info? >_<
10:06:59 <Gurkenglas> No info, I'm afraid. I implemented it myself today: http://lpaste.net/141763
10:07:20 <bollu> hahaha, alright
10:08:03 <Gurkenglas> Yay for Turing completeness and accessible memory, you suddenly don't have to have repository access to add your own tools
10:08:31 <bollu> haskell has "permutations"?
10:08:38 <Gurkenglas> Lambdabot does
10:08:40 <bollu> what does it give you, k permutations of n?
10:08:43 <bollu> ahh
10:08:48 <Gurkenglas> > permutations [5,2,3]
10:08:50 <lambdabot>  [[5,2,3],[2,5,3],[3,2,5],[2,3,5],[3,5,2],[5,3,2]]
10:08:56 <bollu> come to think of it, I don't know how to implement sub-permutations
10:09:04 <Gurkenglas> @src permutations
10:09:04 <lambdabot> Source not found. It can only be attributed to human error.
10:09:09 <bollu> how would you implement, say, 3P5?
10:09:25 <Gurkenglas> 3P5?
10:09:39 <Gurkenglas> Oh hey, permutations is in base. http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#v:permutations
10:09:44 <bollu> find all 3 subset permutations of a set with 5 elements, P(n, k) basically
10:10:00 <bollu> [a] -> Int -> [[a]]
10:10:09 <Gurkenglas> Hmm.
10:10:41 <Gurkenglas> > filter ((==3) . length . nub) . replicateM 3 $ "abcde"
10:10:41 <bollu> I think clever use of Applicative
10:10:42 <lambdabot>  ["abc","abd","abe","acb","acd","ace","adb","adc","ade","aeb","aec","aed","ba...
10:11:00 <bollu> what the hell is "nub"
10:11:08 <derdon> no duplicates
10:11:11 <Gurkenglas> > nub [1,2,3,2,4]
10:11:13 <lambdabot>  [1,2,3,4]
10:11:27 <Gurkenglas> Quadratic runtime, beware.
10:11:37 <bollu> ohh
10:11:42 <bollu> why's it called "nub" ?
10:11:53 <breadmonster> Gurkenglas: Is there a faster algorithm than quadratic runtime I wonder?
10:12:03 <bollu> It does the naive thing, I'm guessing? to eliminate duplicates
10:12:05 <Gurkenglas> breadmonster, not for nub :: Eq a => [a] -> [a]
10:12:13 <johnw> nub means "the crux or central point of a matter"
10:12:26 <bollu> oh, wow. "nub of a pencil" ?
10:12:28 <johnw> in this case, the core elements of the list
10:12:44 <breadmonster> Gurkenglas: Oh fuck, if it was Ord we could have achieved subquadratic time.
10:12:44 <bollu> this is why I like having english as my second language :P I like learning new word
10:13:32 <bollu> breadmonster: can't quicksort + eliminate repitions work?
10:13:34 <bollu> oh, hence Ord
10:13:37 <Gurkenglas> > ala S.fromList id [1,2,6,3,4,2,3]
10:13:39 <lambdabot>  [1,2,3,4,6]
10:13:49 <bollu> ala?
10:13:51 <breadmonster> :t ala
10:13:52 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
10:14:01 <breadmonster> @src ala
10:14:01 <lambdabot> Source not found. You speak an infinite deal of nothing.
10:14:03 <johnw> Gurkenglas: nice use of "ala" there
10:14:06 <breadmonster> Ouch.
10:14:08 <bollu> what _is_ that?
10:14:15 <breadmonster> Gurkenglas: where is this defined?
10:14:20 <johnw> ala is originally from http://hackage.haskell.org/package/newtype
10:14:28 <johnw> this is the new and improved lens version
10:14:32 <Gurkenglas> https://hackage.haskell.org/package/lens-2.9/docs/Control-Lens-Iso.html#v:ala
10:14:36 <bollu> no, like, what does that even represent? why "ala"?
10:14:44 <johnw> it says "wrap the data in N, then apply a function, then unwrap"
10:14:57 <bollu> Conor McBride is the dude with the Jokers on the left‚Ä¶ ?
10:15:19 <hpc> i thought it was clowns to the left and jokers to the right ;)
10:15:33 <bollu> ah, right :)
10:15:46 <johnw> I'm guessing it's "ala" as in "pie ala mode".  That is, something presented in a specific context 
10:15:59 <breadmonster> johnw: That is correct.
10:16:04 <breadmonster> Also, who runs lambdabot?
10:16:22 <bollu> :( A third of haskell is weird english puns
10:16:28 <johnw> haha
10:16:34 <johnw> there is rather a bit of truth to that, bollu
10:16:42 <johnw> especially once Conor is involved
10:16:48 <Gurkenglas> My mnemonic is ‡ la, meaning much the same
10:17:07 <breadmonster> bollu: Is English not your first language?
10:17:23 <Gurkenglas> Oh hey, that doc page also mentions it on the next entry (the one for auf)
10:17:26 <breadmonster> I like it actually. Haskell is the only programming language with some small amount of literary flair.
10:17:48 <bollu> breadmonster: Nope
10:17:51 <bollu> that makes it harder
10:17:57 <bollu> although I'm decently fluent
10:18:19 <breadmonster> Ah okay.
10:18:26 <Gurkenglas> Oh and hey my link doesn't point to what lambdabot's using, and nobody noticed
10:18:26 <Gurkenglas> https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Wrapped.html#v:ala
10:19:00 * hackagebot wai-middleware-verbs 0.0.3 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.0.3 (athanclark)
10:20:18 <Gurkenglas> I've got to start doing this misinformation on purpose and steering towards hilarity
10:20:50 <programo> Can anybody suggest good books for Haskell , other than LYAH
10:20:53 <breadmonster> Gurkenglas: I did.
10:21:00 <breadmonster> programo: Real World Haskell.
10:21:12 <breadmonster> though it's a bit dated, I wish bos came out with another one.
10:22:40 <sphinxo> Current recommended testing framework for Haskell?
10:22:47 <johnw> sphinxo: I like hspec
10:22:47 <programo> okay thanks!
10:23:06 <johnw> hspec + hspec-expectations, actually
10:23:19 <sphinxo> Thanks, johnw 
10:23:58 <johnw> some people like tasty, but I don't see what it adds
10:24:39 <Gurkenglas> (I am intensely annoyed by the line "auf = coerce" in the lens code :D)
10:24:45 <sphinxo> johnw: is that hspec-expectations-lens or hspec-expectations-lifted or hspec-expectations-pretty?
10:25:20 <johnw> just hspec-expectations
10:25:24 <sphinxo> Oh ok
10:25:25 <johnw> never heard of the those three
10:25:58 <sphinxo> Found it, they where just on the extension page on hackage
10:26:05 <sphinxo> for hspec
10:27:40 <sphinxo> What is the difference between unit tests and property tests?
10:27:54 <johnw> a unit test is just exercising some behavior and checking an expectation
10:28:04 <johnw> a property test searches for counter-example to a stated property
10:28:08 <johnw> in an intelligent, randomized way
10:28:16 <sphinxo> Oh nice
10:28:39 <johnw> so, if you say that foo x == bar x, then it will automagically determine candidate values for x, and check that that expression evaluates to True for all of them
10:29:04 <johnw> it's pretty amazing, actually; the idea has been replicated in many languages by now
10:29:11 <sphinxo> Wow, i've never seen that kind of testing before
10:29:23 <johnw> it's called QuickCheck
10:29:29 <sphinxo> Cool
10:29:39 <Gurkenglas> @check \x -> x+x == 2*x
10:29:41 <lambdabot>  +++ OK, passed 100 tests.
10:30:22 <Gurkenglas> @check \x -> x /= 5
10:30:26 <lambdabot>  *** Failed! Falsifiable (after 6 tests):
10:30:26 <lambdabot>  5
10:30:42 <sphinxo> I'm kinda blown away, that's awesome
10:30:58 <johnw> it's even cooler that what we've said
10:31:02 <lyxia> @check \x -> x /= 1000000
10:31:04 <lambdabot>  +++ OK, passed 100 tests.
10:31:08 <lyxia> :D
10:31:10 <bollu> O_O
10:31:11 <johnw> when it find a failing test case, it further will search for the simplest counter-example that falisfies the property
10:31:15 <bollu> that is so friggin cool
10:31:30 <bollu> what's the theory behind this thing
10:31:34 <sphinxo> Well haskell has done it again
10:31:41 <bollu> *name math I've never heard about* :)
10:31:48 <johnw> it does require an instance of Aribtrary for every type whose values you want to do property testing on
10:32:00 <johnw> and sometimes writing a good Arbitrary instance takes some thought
10:32:17 <johnw> but for all the basic stuff, such instances already exist, like lists, numbers, strings, etc.
10:32:57 <tsahyt> Writing good Arbitrary instances can be surprisingly hard in some cases
10:33:11 <johnw> especially efficient ones
10:33:36 <tsahyt> That too, but being random, you can often miss edge cases
10:33:57 <johnw> yeah, it's not proof
10:34:08 <johnw> but it's way more awesome than not having it :)
10:34:30 <bollu> hm
10:34:36 <bollu> and this runs during every build?
10:34:45 <bollu> so it's some kind of pseudo-CI, right?
10:35:05 <tsahyt> I've been debugging/partially rewriting a quad tree based mesh generator this summer. The amount of weird edge cases that don't get caught by the naive Arbitrary instance for leaf nodes in the tree is mind boggling. Just when you've thought you got everything, another case pops up that is stochastically almost impossible to reproduce randomly, but somehow occurs frequently in the real world.
10:35:20 <johnw> bollu: yeah, every build
10:35:40 <johnw> bollu: I recently had a QuickCheck test that two 2 million cases to find a counter example.  So it's not complete assurance of any kind.
10:35:52 <johnw> but it's a great sanity check
10:36:27 <mniip> johnw, 2 two?
10:36:49 <johnw> actually, 1.8 million
10:36:54 <johnw> oh, hehe
10:36:57 <johnw> my typing is flaky today
10:37:12 <tsahyt> I like it for debugging actually. Often when I look through code I'll be like "assuming that invariant X holds, this should do Y". QuickCheck gives me a good indication whether X holds by simply typing X out in the repl and making it an ad-hoc property
10:37:53 <johnw> we even have a QuickCheck analog in Coq
10:38:03 <Gurkenglas> tsahyt, try having QuickSpec doing the "looking through code" part for you!
10:38:04 <johnw> where you write a theorem and you're like, "I don't want to prove this just yet, but make sure I'm not insane"
10:38:13 <bennofs> it's also nice that you can write haskell code to help you to find minimal counter examples :)
10:39:02 <tsahyt> Gurkenglas: I stumbled across it when browsing Hackage the other day, and it kinda looks like voodoo to me. I haven't tried it yet though.
10:39:53 <Gurkenglas> When I tried it I was discouraged by the customization I had to do to apply it to a module.
10:40:42 <Gurkenglas> There's a global power multiplier lying on the ground for the first person to automate applying it to a module, so we can just run it across hackage or integrate it into ghc-mod or something
10:40:49 <johnw> QuickCheck can also be used to just generate random yet syntactically valid data samples.  I use it to generate fake assembly programs that are nonethless real (but stupid) assembly programs
10:41:12 <tsahyt> johnw: What's the use case for real but stupid assembly programs?
10:41:29 <johnw> tsahyt: testing whether a register allocator succeeds at allocating registers for any assembly program
10:42:04 <johnw> Gurkenglas: do you mean just using GHC Generics to make Arbitrary instances?
10:42:38 <sphinxo> Where should I put my tests in a haskell project?
10:42:47 <johnw> in a directory called "test" works nicely
10:42:52 <johnw> I'll show you an example
10:42:56 <johnw> http://hackage.haskell.org/package/linearscan-hoopl
10:43:01 <johnw> see how I structure my .cabal and test/ directories
10:43:33 <sphinxo> Oh thanks johnw 
10:43:43 <tsahyt> Gurkenglas: So if I understand this correctly, QuickSpec basically generates all possible laws and then quickchecks them?
10:43:48 <Gurkenglas> Yes.
10:43:51 <johnw> ohh
10:43:55 <johnw> you mean, discovering *properties*
10:44:01 <johnw> if you can figure that out, I have a job for you
10:44:11 <Gurkenglas> "conjectures", I thought of it
10:44:11 <matsuura> Hey, I'm looking for a CAS-like package. I give you a string "sin(x^2)+a*b*cos(c)+45*sin(x)^2" and I want a short-form reduction of the string. Anyone know of a package that already handles this kind of computation?
10:44:20 <tsahyt> conjectures is a better word, yes
10:44:40 <johnw> Gurkenglas: yeah, if you can generate a set of all possible conjectures, and then use QuickCheck to narrow that to a list of candidate properties, that would be awesome
10:44:55 <Gurkenglas> I wanted to make a program to do that to run it across hackage. Then I found out Quickspec already exists, and nobody had run it across hackage. Then I gave up :P
10:45:22 <tsahyt> I think running it across any nontrivial amount of code will quickly exhaust all your computational resources
10:45:37 <Gurkenglas> Currently pursuing another global power multiplier.
10:46:08 <tsahyt> It explicitly requires you to specify which functions to use in law generation, because otherwise you'd suffer from combinatorial explosion.
10:46:29 <tsahyt> Unless they made some incredible discovery how to speed up uninformed search
10:46:34 <Gurkenglas> tsahyt, it is enough if it finds stuff like "modify is the inverse of execState.". Finding that one triggered me to go looking for a way to bruteforce those.
10:47:13 <tsahyt> You still have to supply it with what it should consider though.
10:48:12 <Gurkenglas> Even if we give it an exponential space to search, it can reach the three layers deep to find inverses of each other
10:48:21 <tsahyt> I'm not saying that the generate everything and then filter approach is bad. It's the best we can do as far as I know. It's just disappointing that we still don't know of a better approach
10:49:01 * hackagebot hgrev 0.1.2 - Compile Mercurial (hg) version info into Haskell code  https://hackage.haskell.org/package/hgrev-0.1.2 (LukeHoersten)
10:49:53 <tsahyt> I wonder if it's even possible to come up with some sort of heuristic for that
10:51:51 <tsahyt> Actually, since the search needs to be exhaustive, that doesn't matter. But a way to prune the search tree could help a lot. Something like "this conjecture turned out to be wrong, so all of these are wrong too". But I don't see how this would be possible for general functions.
10:53:04 <Gurkenglas> I think QuickSpec already does "We already failed to disprove these two to be equal, so we don't need to formulate larger conjectures using one when we already have one with the other."
10:53:11 <Luke> can anyone tell why is my package description not rendering correctly?: https://hackage.haskell.org/package/hgrev
10:54:01 * hackagebot pcre-utils 0.1.7 - Perl-like substitute and split for PCRE regexps.  https://hackage.haskell.org/package/pcre-utils-0.1.7 (SimonMarechal)
10:54:34 <tsahyt> Gurkenglas: Oh right, a conjecture can be a corollary of another conjecture of course. Indeed you can have whole subtrees of such conjectures, which would all turn out to be false if the parent is false. Maybe I should actually look at the package.
10:56:05 <johnw> there's been research into conjecture discovery in other areas, like geometric tiling
10:56:14 <Gurkenglas> That one is only done afterwards, I think: It'll try to deduce the conjectures it found from each other and only output a minimal set that it can deduce the rest from
10:57:02 <johnw> but how would you ever, for example, infer an associativity property by looking at the implementation of even a trivial operator?
10:57:17 <johnw> or do we just "try it out" for every operator
10:57:26 <tsahyt> johnw: Well in this case, you don't. It's generate and test.
10:57:29 <Luke> anyone know if something's broken w/ hackage doc generation atm?
10:57:31 <johnw> yeah
11:01:23 <tsahyt> johnw: To be honest, that's part of what I do by hand too though. Before attempting a proof, I'll try a few examples and see if it holds. The difference is that humans are somehow better at generating conjectures.
11:01:36 <aweinstock> with Control.Monad.ST.Strict, if I'm producing output by with (modifySTRef acc (x:)), will the output list only be available all-at-once? if so, will changing to Control.Monad.ST.Lazy make it available element-at-a-time?
11:05:04 <tsahyt> aweinstock: According to the docs, modifySTRef doesn't apply the function strictly, even in Data.STRef.Strict
11:05:15 <tsahyt> aweinstock: There's modifySTRef' for that.
11:05:38 <tsahyt> (since 4.6.0.0)
11:06:08 <aweinstock> tsahyt: I'm aware of that, but I don't think that's quite what I'm asking?
11:07:37 <lpaste> aweinstock pasted ‚ÄúST filterPermutationsWithReplacement‚Äù at http://lpaste.net/141775
11:07:49 <aweinstock> ^ that's the code I'm asking about
11:08:28 <akagr> Hey all! I am trying to build https://github.com/BJTerry/mailchimp with stack. Doing 'stack init' keeps telling me it can't find the dependency versions in snapshots it's searching
11:09:01 <aweinstock> I want the mapM at the bottom to print output as it's computed, but it's taking more than 3x as long as the equivalent C program (https://github.com/aweinstock314/aweinstock-ctf-writeups/blob/master/csaw_quals_2015/re300_ftp_hasher.c)
11:09:44 <tsahyt> aweinstock: I might have misunderstood. I thought it was about whether the list in acc was fully evaluated or not.
11:10:09 <akagr> how can I search for the snapshot having that version or is there another way to make it work?
11:10:24 <aweinstock> my current hypothesis is that this is because it's too strict, and is waiting to reach the end of the search space before printing out the result (which is towards the beginning)
11:10:59 <orion> Hi. Does anyone know why I am unable to create an instance here on line 23?: http://lpaste.net/2656316429376159744#line23
11:11:22 <orion> The error I get is: "Illegal instance declaration for ‚ÄòShow a‚Äô"
11:11:23 <johnw> aweinstock: I missed the paste when you had the mapM
11:11:25 <aweinstock> tsahyt: it is (I want it to not be fully evaluated)
11:12:02 <aweinstock> < lpaste> aweinstock pasted ‚ÄúST filterPermutationsWithReplacement‚Äù at http://lpaste.net/141775
11:12:28 <mniip> orion, that instance is inconsistent
11:12:51 <orion> How so?
11:13:14 <mniip> orion, what if there was for example 'GenericMessage String'
11:13:25 <mniip> there would be 2 candidates for Show String
11:13:38 <orion> Oh, hmm.
11:14:05 <orion> Indeed.
11:14:16 <mniip> you can /force/ ghc to ignore such inconsistent instances, but you totally don't want this
11:14:46 <orion> Right, how would you resolve this?
11:14:55 <mniip> what you should do instead, is write a genericMessageShow :: GenericMessage a => a -> String
11:14:57 <mniip> and then
11:14:58 <Gurkenglas> The usual solution for this is "instance GenericMessage a => Show (MyNewType a) where"
11:15:11 <mniip> instance Show Post where show = genericMessageShow
11:15:15 <mniip> instance Show Comment where show = genericMessageShow
11:15:32 <mniip> also note, Show is not intended to be used for pretty-printing
11:15:36 <mniip> Show should output haskell code
11:16:01 <Shockk> oh; today I learned
11:16:04 <joco42_> if i have 2 ghc binaries installed on my system, say ghc 7.10.2 and 7.8.4 and i want to switch from 7.10.2 to 7.8.4 then what is the best way to do that ? is it enough to just put the one i want to use onto the path ?
11:16:04 <orion> I see. Gurkenglas, how is your solution different compared to mniip?
11:16:09 <joco42_> and remove the other?
11:16:22 <mniip> orion, he's suggesting to wrap Post and Command in a newtype
11:16:30 <orion> ah
11:16:32 <mniip> Wrapped Post, Wrapped Commend
11:16:33 <joco42_> or do i have to also fiddle with the central ghc registry?
11:16:39 <mniip> then declare an instance for Wrapped
11:17:14 <Gurkenglas> (And an instance of Wrapped Wrapped, hyuk hyuk. Nevermind me.)
11:17:30 <tsahyt> What's the use case for the GenericMessage class by the way?
11:18:44 <kaidelong> akagr: I'm going to guess the problem is that you need a different snapshot than lts-3 or the packages this depends on simply aren't in stackage
11:20:47 <kaidelong> you could try making a stack.yaml
11:21:30 <kaidelong> https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md
11:21:58 <kaidelong> the thing is though, stack is already supposed to choose the right snapshot
11:22:19 <kaidelong> it tries the latest lts but will try newer snapshots if the latest lts does not work
11:22:28 <kaidelong> (or older ones if the newest doesn't work)
11:22:55 <kaidelong> at least this is what the docs say it does, but at this point stack should perhaps be considered to be an undocumented alpha
11:29:08 <danilo2> Hello guys! How can I generate using TemplateHaskell an OVERLAPPABLE instance? Is there a new syntax for it? Whats interesting both `runQ [d| instance {-# OVERLAPPABLE #-} A |]` and `runQ [d| instance A |]` give the same output
11:30:09 <tulcod> danilo2: pretty sure you can't even generate inline stuff
11:30:57 <danilo2> tulcod: Ok, but starting with GHC 7.12 (as far as I know) we would not be able to use module-global Overlapping pragma, so there would be absolutly no possibility to generate overlapping instances from within TH ?
11:30:59 <tulcod> danilo2: and yeah, that's a pretty reliable test: if runQ [..|...|] doesn't work, then TH probably doesn't support it at all
11:31:23 <tulcod> danilo2: unless TH adds such functionality in 7.12, that sounds correct
11:31:59 <akagr> kaidelong: yeah that seems like it. problem is, even the oldest stackage snapshot has a new version than required... I am trying to build the project after updating the dependency versions in cabal file
11:32:03 <danilo2> tulcod: right. Thank you :)
11:32:42 <tulcod> danilo2: (note that there's also typed TH. not relevant to your question, but you might be interested in it)
11:40:36 <danilo2> tulcod: yes, I've hard about it, yet I didn't have chance to test it. Thank you for notifying about it! :)
12:04:47 <acro> hi
12:11:39 <aweinstock> are there any spine-lazy FIFO datastructures?
12:13:04 <aweinstock> (such that (head (runST do { some computation involving modifySTRef acc (`snoc` output) })) doesn't wait for the whole computation)
12:14:53 <submain> is there a trick to convert a [Maybe a] to Maybe [a]?
12:15:07 <Xnuk> :t sequence
12:15:08 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
12:15:10 <mniip> catMaybes
12:15:15 <mniip> er, nevermind
12:15:29 <Xnuk> :t catMaybes
12:15:30 <lambdabot> [Maybe a] -> [a]
12:15:32 <mniip> sequence, sequenceA
12:15:41 <submain> nice, thanks a lot! that was quick
12:16:08 <rcyr> @hoogle [Maybe a] -> Maybe[a]
12:16:08 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
12:16:08 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
12:16:08 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
12:16:32 <mniip> > sequenceA [Just 3, Nothing, Just 2]
12:16:34 <lambdabot>  Nothing
12:16:36 <submain> I need to get better at hoogling, seriously
12:16:37 <mniip> > sequenceA [Just 3, Just 5, Just 2]
12:16:39 <lambdabot>  Just [3,5,2]
12:16:49 <mniip> that's the idea behind sequence/sequenceA
12:16:54 <submain> gotcha
12:17:02 <Xnuk> > catMaybe [Nothing]
12:17:03 <lambdabot>      Not in scope: ‚ÄòcatMaybe‚Äô
12:17:03 <lambdabot>      Perhaps you meant one of these:
12:17:03 <lambdabot>        ‚ÄòcatMaybes‚Äô (imported from Data.Maybe),
12:17:10 <Xnuk> > catMaybes [Nothing]
12:17:11 <lambdabot>  []
12:18:44 <acro> i need some help
12:19:05 <ReinH> acro: what is your question?
12:19:21 <acro> how coul i define the (++) function with recursion
12:20:31 <acro> im just trying to add 2 lists
12:20:33 <hpc> @src (++)
12:20:33 <lambdabot> []     ++ ys = ys
12:20:33 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:20:33 <lambdabot> -- OR
12:20:33 <lambdabot> xs ++ ys = foldr (:) ys xs
12:20:35 <ReinH> acro: what have you tried?
12:20:44 <ReinH> welp
12:20:47 <acro> i tried this 
12:20:49 <acro> addlist (x:xs) (y:ys) = (x,xs):addlist  y ys
12:21:03 <ReinH> acro: why (x,xs)?
12:21:34 <acro> dont really know
12:21:47 <acro> was just trying since : failed
12:22:32 <Shockk> hmm I actually have a relevant question; would it not be more efficient to ++ the two lists by building up a computation for the first list of (a : b : c : d :) excluding the final [] and then applying that to the second list?
12:22:45 <ReinH> Shockk: that is exactly what happens
12:22:53 <Shockk> oh
12:23:09 <mniip> ReinH, eh?
12:23:14 <mniip> is it not better done in a lazy way?
12:23:25 <ReinH> mniip: what do you mean?
12:23:41 <mniip> like what lambdabot outputted above
12:23:43 <Shockk> oh I see
12:23:54 <acro> so how could i use that code from lambdabot 
12:24:12 <ReinH> acro: why are you trying to define (++) instead of just using it?
12:24:17 <Shockk> because (xs ++ ys) evaluates to (x' : (xs' ++ ys')) right?
12:24:19 <Shockk> and etc
12:24:39 <mniip> Shockk, if you try to evaluate a ++ thunk, you will get a spine
12:24:44 <acro> its a problem to solve from a tutorial to learn recursion 
12:24:44 <ReinH> (x:xs) ++ ys = x : (xs ++ ys), yes
12:24:59 <ReinH> hpc: Please don't give answers to exercises. It defeats the purpose.
12:25:26 <jmcarthur> Shockk: (++) works that way kind of implicitly. difference lists work that way explicitly.
12:25:50 <Shockk> ahh
12:25:54 <ReinH> acro: The way to work with data structures in Haskell is to pattern match on their constructors. Lists have two constructors: (:) and []
12:26:09 <jmcarthur> Shockk: https://hackage.haskell.org/package/dlist-0.7.1.2/docs/src/Data-DList.html
12:26:18 <acro> so i can define by
12:26:38 <jmcarthur> Shockk: in particular,  newtype DList a = DL { unDL :: [a] -> [a] }  and  append xs ys = DL (unDL xs . unDL ys)
12:27:08 <jmcarthur> Shockk: and i guess it's important that   fromList = DL . (++)
12:27:39 <ReinH> acro: [1,2] ++ ys = 1:2:[] ++ ys. What we want to do is replace the [] with ys, giving 1:2:ys
12:27:41 <deavmi2> Check out my brother's art on¬†newgrounds.com~¬†http://zeglo.newgrounds.com/¬†#zeglo
12:28:00 <oldnemo> Hey guy's :)
12:28:03 <acro> addlists (x:xs) (y:ys) = ?
12:28:05 <Shockk> hmm, if unDL :: [a] -> [a], how does unDL xs . unDL ys work?
12:28:21 <ReinH> acro: Well, we only want to deal with ys, not y:ys.
12:28:25 <Shockk> oh wait
12:28:40 <Shockk> okay I see, I misread it
12:28:54 <acro> so i can add the y to the 1st list then add the ys?
12:28:57 <ReinH> Shockk: ("foo"++) . ("bar"++) $ ""
12:29:06 <ReinH> acro: why would you add y to the first list?
12:29:20 <acro> because i want to add 2 lists
12:29:34 <ReinH> Again, we want to replace 1:2:[] ++ ys with 1:2:ys
12:29:36 <acro> for exemple
12:29:38 <radens> Can someone help me with the state monad? This is kind of what I want, but I'm getting all sorts of errors: https://pastebin.osuosl.org/33826/
12:29:49 <radens> the errors: https://pastebin.osuosl.org/33831/
12:29:53 <ReinH> we want to replace [] with ys
12:29:58 <ReinH> We don't need to pattern match on ys
12:30:01 <ReinH> we want to use the whole list
12:30:06 <acro> adlit [1,2,3] [1,2] returns [1,2,3,1,2]
12:30:40 <mniip> radens, what are you trying to do
12:30:44 <mniip> that type signature makes no sense
12:30:53 <radens> mniip: Yeah I know
12:31:03 <ReinH> acro: Ok, let's start with something simpler.
12:31:11 <ReinH> How do I write [] ++ ys?
12:31:17 <ReinH> How do I add an empty list to a list?
12:31:24 <mniip> radens, do you want to produce an Ast node and modify your list of strings along the way?
12:31:29 <radens> yes
12:31:32 <radens> exactly
12:31:32 <ReinH> [] ++ ys = ???
12:31:34 <mniip> that's
12:31:37 <acro> ys
12:31:37 <mniip> State [String] Ast
12:31:55 <ReinH> radens: are you doing anything other than appending new strings?
12:32:11 <mniip> ReinH, from what I can see they're doing the opposite
12:32:12 <radens> ReinH: poping strings from the stack, but no.
12:32:17 <ReinH> ok
12:32:23 <mniip> it's not a Writer
12:32:30 <ReinH> Just checking
12:32:43 <ReinH> acro: Ok, so that's half of the function: [] ++ ys = ys
12:32:47 <mniip> radens, since it's a State monad, you don't get to explicitly pattern match on the input
12:32:51 <mniip> instead you use 'get'
12:32:55 <ReinH> acro: Now we need the other half: (x:xs) ++ ys = ???
12:33:07 <mniip> which is a monadic action returning the current state
12:33:07 <ReinH> acro: Imagine we had [x] ++ ys, so (x:[]) ++ ys
12:33:18 <ReinH> acro: what would you do to add ys to [x]?
12:33:25 <ReinH> (x:[]) ++ ys = ???
12:33:36 <acro> x:ys
12:33:39 <ReinH> Right
12:33:56 <radens> mniip: I'll consider using get, but I changed my signature to parse_identifier :: State [String] Ast -> Ast  and it's still giving me grief
12:34:11 <ReinH> acro: Now what about [x,x'] ++ ys? (x:x':[]) ++ ys = ???
12:34:59 <acro> [(x,x'):ys] ?
12:35:04 <ReinH> acro: Close.
12:35:07 <ReinH> x:x':ys
12:35:12 <acro> why?
12:35:28 <acro> shouldnt it be a pair?
12:35:32 <ReinH> Why would it be a pair?
12:35:37 <Shockk> radens: I don't know if that signature is what you intend but it reads from left to right like this:
12:35:40 <ReinH> lists don't have any pairs in them
12:35:49 <ReinH> lists are constructed from (:) and []
12:35:59 <acro> its what i read [x,x'] its a pair normally
12:36:05 <ReinH> [x,x'] is not a pair
12:36:07 <ReinH> (x,x
12:36:14 <ReinH> (x,x') is a pair
12:36:18 <acro> ah
12:36:19 <ReinH> [x,x'] = x:x':[]
12:36:36 <acro> oh ok now makes more sense
12:36:37 <Shockk> radens: parse_identifier takes a value of type State [String] Ast (i.e. a state computation on [String] that return an Ast), 
12:36:43 <Shockk> and returns an Ast itself
12:37:01 <ReinH> acro: so x:x':[] ++ ys = x:x':ys. We are again just replacing [] with ys.
12:37:12 <acro> yes
12:37:40 <acro> when we achive the empty list we add the other
12:37:41 <ReinH> But remember, we already know that x':[] ++ ys = x':ys
12:38:21 <ReinH> so we have x:x':[] ++ ys = x: (x' ++ ys) by substitition.
12:38:29 <radens> The Ast it's returning is still 'carrying the state with it' right?
12:38:40 <radens> Shockk: ^^
12:38:43 <acro> yes
12:38:44 <mniip> radens, you don't need the arrow
12:38:53 <acro> the head plus the rest
12:39:01 <mniip> just 'State [String] Ast'
12:39:07 <ReinH> and we also have x:[] ++ ys = x : ([] ++ ys) by substitution.
12:39:08 <radens> Okay
12:39:08 <ReinH> Right?
12:39:11 <radens> that makes sens
12:39:13 <mniip> @src State
12:39:13 <lambdabot> Source not found.
12:39:14 <radens> e
12:39:23 <mniip> data State s a = State (s -> (s, a))
12:39:33 <ReinH> acro: does that make sense?
12:39:39 <mniip> the datatype already includes the arrow
12:39:46 <acro> yes by substitution
12:40:02 <ReinH> acro: So for (x:xs) ++ ys, whatever xs is, we can substitute: x : (xs ++ ys)
12:40:19 <acro> yes
12:40:27 <ReinH> acro: So we have our two cases:
12:40:30 <ReinH> [] ++ ys = ys
12:40:37 <ReinH> (x:xs) ++ ys = x : (xs ++ ys)
12:40:41 <ReinH> and that's our definition of (++)
12:41:34 <acro> what i dont understand is how is that recursion? and how i can use it
12:42:00 <ReinH> acro: Do you know what recursion is?
12:42:08 <ReinH> And as to how you can use it, it's a definition you can put in a haskell file.
12:42:15 <acro> but your explanation as very usefull to better understand lists
12:42:51 <acro> one function calling itself
12:42:59 <Shockk> the definition of ++, when the first list input matches (x:xs), recursively calls ++ again 
12:43:03 <mniip> that's right, ++ is calling itself
12:43:06 <ReinH> Right, specifically we have a *base case*, and another case that reduces towards the base case.
12:43:08 <radens> mniip: thanks for your help, I've almost got it. Here is what I have: https://pastebin.osuosl.org/33836/
12:43:17 <radens> it doesn't like line 10
12:43:41 <mniip> radens, 'state'
12:43:48 <mniip> why is that an argument
12:44:00 <ReinH> acro: (x:xs) ++ ys = x : (xs ++ ys) is a definition of ++ in terms of itself. We can also prove that it eventually calls the [] ++ ys = ys case (if xs is finite).
12:44:12 <radens> mniip: I need a reference to it, right?
12:44:17 <mniip> no
12:44:26 <mniip> the monadic do-block is a reference to it
12:44:30 <radens> oh!
12:44:39 <acro> but how can i name it?
12:44:41 <radens> sweet
12:44:46 <ReinH> acro: (++) is the name.
12:44:48 <mniip> get takes no arguments
12:44:51 <radens> thanks mniip  and Shockk 
12:44:56 <mniip> just like parse_identifier doesn't
12:44:59 <acro> like adlst a b = 
12:45:33 <Shockk> and apologies radens, I had gone afk when you pinged me before
12:45:43 <ReinH> acro: adlst [] ys = ys; adlst (x:xs) ys = x : adlst xs ys
12:46:27 <radens> Shockk: no problem, mniip was ablt to set me straight
12:47:09 <acro> oh
12:48:14 <acro> so what we are doing is letting the function call itself untill it gets an empty list and stops
12:48:57 <ReinH> yes
12:49:14 <acro> we start at x go until de end of xs and add ys because we enter the first scenerio with empty list
12:49:26 <ReinH> yes
12:49:36 <acro> makes sense
12:49:43 <acro> will continue
12:49:56 <ReinH> acro: Are you familiar with the way addition is defined for the natural numbers?
12:50:45 <ReinH> we have data Nat = Z | S Nat and Z + n = n; (S n) + m = s (n + m). Notice a similarity?
12:51:19 <ReinH> We either have zero plus a number, which is that number, (one more than a number) plus another number, which is one more than (a number plus another munber)
12:51:26 <ReinH> (that should be S (n + m))
12:52:34 <ReinH> That is structurally the same as ++ for lists.
12:52:53 <acro> i can define the addition of natural numbers?
12:53:07 <ReinH> Sure. I just did.
12:54:09 <ReinH> With lists we either have an empty list plus a list, which is that list; or (an element and the rest of the list) plus a list, which is an element plus (the rest of the list plus a list).
12:54:33 <acro> add 0 n = n; add n m = n add m?
12:54:44 <ReinH> acro: No. I defined it above.
12:55:05 <ReinH> add 0 n = n; add (n + 1) m = 1 + (n + m)
12:55:09 <ReinH> er
12:55:24 <ReinH> = add (add n m) 1
12:56:29 <ReinH> Earlier versions of Haskell actually had n + k patterns, so 0 + n = n; (n + 1) + m = 1 + (n + m) would have been a valid definition.
12:56:44 <tsahyt> They can still be enabled in GHC
12:56:47 <ReinH> True.
12:56:54 <mniip> ReinH, 1 + ... ?
12:56:56 <mniip> :P
12:57:12 <mniip> gotta have a primitive increment
12:57:39 <ReinH> no, n + m will still reduce to a normal form eventually. :p
12:57:43 <aweinstock> @src Cont
12:57:43 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
12:57:59 <ReinH> BUt fine, (n + 1) + m = (n + m) + 1
12:58:22 <acro> didnt understand it clearly
12:58:35 <ReinH> mniip: Actually, my version is superior because it is lazier.
12:58:55 <mniip> ReinH, version of what
12:58:58 <ReinH> mniip: +
12:59:01 <acro> arent i commuting the numbers or is that the point?
12:59:07 <mniip> ReinH, as opposed to what
12:59:19 <ReinH> mniip: "gotta have a primitive increment", what do you mean?
12:59:34 <mniip> add (n + 1) m = 1 + (n + m)
12:59:47 <mniip> you're implementing + in terms of adding one
13:00:01 <mniip> but you're adding one using your own addition implementation
13:00:13 <mniip> as opposed to a more primitive implementation of incrementation
13:00:25 <ReinH> mniip: ah right, so (n + 1) m = succ (n + m)
13:00:30 <mniip> touche
13:00:47 <Ongy> is it possible to use a type defined in a template haskell splice (DataD) inside the same splice for SigD?
13:01:46 <ReinH> mniip: alternatively, we define the 1 + n case ;)
13:02:10 <mniip> Ongy, have you tried? seems like it should just work
13:02:39 <Ongy> mniip: yeah i failed, I tried to use the name lookup, but I can just use the name instead
13:09:07 * hackagebot shelly 1.6.4 - shell-like (systems) programming in Haskell  https://hackage.haskell.org/package/shelly-1.6.4 (GregWeber)
13:25:18 <radens> Can I pattern match in a do block as a way of avoiding an if statement?
13:28:03 <xolrup> I'm pretty sure you can
13:28:04 <tsahyt> radens: You can pattern match using case in do blocks
13:29:11 <radens> tsahyt: thanks
13:29:24 <tsahyt> Other than that, there's T a b <- foo, but that's irrefutable pattern. If you're sure that the pattern match will never fail you can do that
13:33:27 <ReinH> No, that is not an irrefutable pattern. An irrefutable pattern is something else.
13:33:49 <ReinH> Pattern matching in a do block uses the monad's fail implementation on pattern match failure
13:34:08 * hackagebot foldl-transduce 0.4.4.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.4.4.0 (DanielDiazCarrete)
13:35:57 <ReinH> A lazy pattern (of the form ~pat) is irrefutable
13:36:33 <tsahyt> Oh right, I was thinking of something in the error message I thought it produces, but apparently it doesn't actually say that either.
13:36:54 <ReinH> No, pattern match failure in do blocks does not produce an error unless the fail implementation does.
13:37:20 <ReinH> In which case the error is defined by the fail implementation, and is not something GHC provides.
13:40:54 <lpaste> aweinstock annotated ‚ÄúST filterPermutationsWithReplacement‚Äù with ‚ÄúST filterPermutationsWithReplacement (annotation)‚Äù at http://lpaste.net/141775#a141780
13:41:18 <Mapleshade35> er
13:41:27 <Mapleshade35> anyone here?
13:41:49 <tsahyt> About 1500 people
13:41:54 <tsahyt> And some bots
13:42:05 <aweinstock> I've changed the accumulator type to some fancy datastructure called "Allison queues", and I've verified that it's correctly lazy (e.g. (take 5 $ runQueue (forever (enQ 1))) works)
13:42:46 <aweinstock> but the "main" function still gets longer and longer delays for extracting the head of the list, indicating that some "extra" work is still being done
13:42:55 <aweinstock> any advice? what should I try next?
13:43:24 <Mapleshade35> Oh phew
13:43:52 <Mapleshade35> Literally every chat I joined had nobody in it.
13:44:18 <aweinstock> Mapleshade35: do you have a specific question? if so, ask it :)
13:44:30 <Mapleshade35> Meh not really.
13:48:12 <zipper> Hey, say I have `instance (Functor Tree, Foldable Tree) => Traversable Tree where` and I haven't yet written the Tree instanaces for that. What can I use as a placeholder there?
13:49:10 <tommd> Why do you want constraints without any type variables on your instance?
13:49:58 <zipper> tommd: They are coming I just want to write the Foldable instance first.
13:50:41 <tommd> That isn't an answer.  Why do you want the _constraints_?   Why do you have (Functor Tree, Foldable Tree) ?  Usually constraints include a type variable, not just a type.
13:52:04 <zipper> tommd: That's how it is defined https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Traversable.html#t:Traversable
13:52:33 <jmcarthur> zipper: the constraints are imposed on you by the compiler. you don't have to impose them on yourself.
13:52:34 <zipper> Like the way Functor and Applicative relate.
13:52:48 <chpatrick1> zipper: that means that Tree needs to have those instances too
13:53:02 <chpatrick1> but instance Foo a => Bar a means a is a Bar if it's a Foo
13:53:15 <chpatrick1> but in this case Tree is definitely a Traversabl
13:53:16 <chpatrick1> e
13:53:21 <chpatrick1> you don't need the instance constraint
13:54:00 <Shockk> you don't need to constrain by (Functor Tree, Foldable Tree) because you can only create an instance of Traversable for Tree if Tree is already an instance of both Functor and Foldable
13:54:11 <zipper> jmcarthur: Hello, uh btw I've got that interview on Monday and I'm kinda afraid because first interview ever. Know which algos and data structures I should look at in preparation?
13:54:12 <Shockk> that's what the constraints on the Traversable typeclass mean
13:55:12 <tommd> zipper: It sounds like you want to write a traversable instance without having a foldable or functor instance.  You seem to realize this is incorrect as traverisable promises there also exists functor and foldable instances.
13:55:19 <zipper> So if the compiler imposes these constraints doesn't it make my code easier to understand when I have that explicitly stated in the instnce?
13:55:32 <tommd> zipper: So you can make empty declarations `instance Functor Tree where`
13:55:57 <tommd> zipper: No, it makes your code more verbose and incorrect.
13:56:05 <zipper> tommd: No you don't get what I mean let me show you.
13:56:14 <lpaste> aweinstock annotated ‚ÄúST filterPermutationsWithReplacement‚Äù with ‚ÄúST filterPermutationsWithReplacement (annotation)‚Äù at http://lpaste.net/141775#a141781
13:56:15 <tommd> That is likely
13:56:16 <zipper> Really, incorrect?
13:56:23 <Shockk> if you want a placeholder before actually writing your intended instances of Foldable and Functor, you could use the GHC extensions which allow you to derive each of them
13:56:45 <aweinstock> I switched to using ST.Lazy and STRef.Lazy, still doesn't do what I want, then I found this: http://stackoverflow.com/questions/24072934/haskell-how-lazy-is-the-lazy-control-monad-st-lazy-monad
13:57:14 <aweinstock> Is it possible to output a lazy list using an ST intermediate? how do I go about doing that?
13:57:34 <tommd> zipper: Yes, incorrect v the Haskell 2010 language definition.
13:57:39 <zipper> tommd: Here is the code I have so far http://lpaste.net/1810216990279729152
13:58:00 <jmcarthur> zipper: https://blogs.janestreet.com/interviewing-at-jane-street/
13:58:32 <jmcarthur> zipper: I can confirm the accuracy of that blog post.
13:59:43 <dmj`> anyone use inline-c on OSX ?
13:59:59 <zipper> Okay let me be humble. What should I do. I don't see what I did wrong. To me it seems that the compiler will still expect Functor and Foldable instances for Tree
14:00:22 <tommd> zipper: So do you have a question at this point?  You delete the constraints, fix your definition of `foldMap`, and finish the Traversable instance.
14:00:31 <tommd> `instance Traversable Tree where ... `
14:00:43 <tommd> and `foldMap = something not just fmap`
14:00:45 <dmj`> unsure why I'm getting undefined symbols w/ inline-c, http://lpaste.net/141783
14:00:57 <zipper> tommd: I somehow got disconnected
14:01:10 <tommd> zipper: So do you have a question at this point?  You delete the constraints, fix your definition of `foldMap`, and finish the Traversable instance.
14:01:11 <chpatrick1> zipper: instance A t => B t means if A t then B t
14:01:12 <tommd> `instance Traversable Tree where ... `
14:01:13 <tommd> and `foldMap = something not just fmap`
14:01:20 <chpatrick1> but class constraints are non-negotiable
14:01:36 <chpatrick1> so it's a given that they hold, otherwise you can't have your subclass instance
14:01:47 <zipper> What should I do. I don't see what I did wrong. To me it seems that the compiler will still expect Functor and Foldable instances for Tree
14:01:51 <jmcarthur> zipper: In fact, not only is that blog post accurate, it's *very* direct. You do not need to read between the lines; take it at face value.
14:01:59 <zipper> I went offline
14:02:04 <chpatrick1> zipper: it will expect it but you shouldn't put them in the instance constraint
14:03:04 <zipper> chpatrick1: But wouldn't putting that there be better for the reader? I honestly see nothing wrong except for added verbosty.
14:03:19 <chpatrick1> zipper: it would just be line noise
14:03:20 <tommd> Zipper: And it won't compile, that's the othe rissue.
14:03:42 <chpatrick1> it's required that the superclass constraint holds so there's no need to say so at the instance declaration
14:03:47 <jmcarthur> I think it's confusing for the reader. If I saw that, I would wonder why the author went through the trouble of writing it and probably get hung up on that detail.
14:03:57 <zipper> *changing keyboards*
14:06:28 <tsahyt> If I see a Traversable instance, I automatically assume that those other instances are there, because it's required. If I'm wondering about what instances are defined for a type, I'll use :i in ghci.
14:07:35 <tommd> But should't I put the body of a function at the call site?  I see nothing wrong except for added verbosity.
14:08:27 <tommd> Snark aside, it might seem sensible when the class heirarchy is foreign to you, but after much use this sort of excess noise / duplicity is generally a bad thing.
14:08:32 <zipper> tommd: hahaha well that's a little differnt.
14:09:05 <tommd> What would it mean if the programmer omitted the constraints?  They are still required, so the lack of the constraints appearing in the instance still tells the programmer nothing about their availability.
14:09:06 <nurupo> how do i tell haskell to print "\x88" as it is, not as "\136"?
14:09:08 <tsahyt> To me it's a bit like writing "foo = (+1) -- add one". It's redundant.
14:09:09 * hackagebot persistent-template 2.1.3.6 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.1.3.6 (GregWeber)
14:09:14 <zipper> tommd: I see. I shall stick to best practice if that avoids redundancy that's good.
14:09:28 <zipper> I thought more is better to some degree.
14:09:30 <nurupo> > take 10 $ repeat "\x88"
14:09:32 <lambdabot>  ["\136","\136","\136","\136","\136","\136","\136","\136","\136","\136"]
14:09:38 <tsahyt> nurupo: Escape the \?
14:09:40 <nurupo> > take 10 $ repeat "\\x88"
14:09:41 <lambdabot>  ["\\x88","\\x88","\\x88","\\x88","\\x88","\\x88","\\x88","\\x88","\\x88","\\...
14:09:45 <tsahyt> Oh
14:09:59 <nurupo> now it prints double \\
14:10:30 <tsahyt> > putStrLn "\\x88"
14:10:32 <lambdabot>  <IO ()>
14:10:34 <zipper> tommd: I still haven't gotten an answer to the original question though. :)
14:10:37 <tsahyt> Well that was helpful
14:11:14 <tsahyt> nurupo: The string "\\x88" is actually what you want. The REPL just displays the escaped backslash.
14:11:32 <zipper> A way to stub out the implementation of the typeclass.
14:11:41 <tsahyt> > length "\\x88"
14:11:41 <nurupo> tsahyt: any way i can tell it to not display it escaped?
14:11:42 <lambdabot>  4
14:13:06 <tsahyt> I don't think so, but I'm not sure
14:13:54 <geekosaur> > text "\\x88"
14:13:55 <lambdabot>  \x88
14:13:59 <tsahyt> :t text
14:14:00 <lambdabot> String -> Doc
14:14:47 <tsahyt> :info Doc
14:14:58 <geekosaur> no :info
14:15:02 <geekosaur> nor @info
14:15:17 <tsahyt> Considering the size of the possible output that's understandable. Where is Doc from?
14:15:44 <geekosaur> it doesn't appear to have any documentation but it looks like http://hackage.haskell.org/package/template-haskell/docs/Language-Haskell-TH-PprLib.html#v:text
14:16:08 <geekosaur> or some other prettyprinter library perhaps
14:16:15 <nurupo> > putStrLn $ concat $ take 10 $ repeat "\\x88"
14:16:17 <lambdabot>  <IO ()>
14:16:19 <tsahyt> There's a text :: String -> Doc in the GHC API too
14:16:35 <geekosaur> ah, I bet http://hackage.haskell.org/package/pretty/docs/Text-PrettyPrint.html#v:text
14:17:04 <geekosaur> most of the prettyprinter libs including ghc-api's/TH's use similar types and primitives
14:17:34 <geekosaur> in any case I imagine show on a prettyprinter Doc type is literal instead of escaping
14:19:10 * hackagebot poly-arity 0.0.7 - Tools for working with functions of undetermined arity  https://hackage.haskell.org/package/poly-arity-0.0.7 (athanclark)
14:39:30 <Yuras> is it a Monoid? https://gist.github.com/Yuras/396b1ff665fb07e17772
14:41:03 <Yuras> from geometrical reasoning it should be, but I can't prove it using algebra...
14:47:11 <Walther> Hmm. I'm trying to write a elegant-looking / natural-"sounding" solution to Euler problem 7 (find the 10001th prime number) and running into some issues http://lpaste.net/8925873778408292352
14:48:12 <Walther> this is not the first time i'm trying to get around needing currying in the condition, but i can't remember how that was done
14:50:14 <Yuras> Walther: probably ((== 0) . (x `mod`))
14:51:00 <jophish_> I feel daft not being able to find this, but is there a function to get the integer part of a floating point number with type Real a => a -> a
14:51:11 <jophish_> all the functions I've seen want to return an Integral b
14:52:17 <Yuras> jophish_: use fromIntegral to convert
14:55:32 <geekosaur> ummm
14:55:39 <geekosaur> Integer is an instance of Integral
14:55:47 <geekosaur> so is Int
14:56:09 <geekosaur> which means all the functions you've seen will produce either of those
14:56:47 <geekosaur> no conversion needed
14:56:47 <rhovland> fromIntegral produces a Num
14:57:16 <geekosaur> if you want to get it *as a floating point number* then yes, you go through fromIntegral
15:02:21 <aweinstock> :t fromIntegral . floor
15:02:21 <lambdabot> (Num c, RealFrac a) => a -> c
15:02:21 <Walther> hmm... now it's non-terminating http://lpaste.net/8925873778408292352
15:04:00 <quchen> √ºr
15:06:30 <rhovland> Walther: it's that "primes" on both sides, I think
15:06:36 <jophish_> ok, so there's no way to keep it at the same precision the whole way through?>
15:07:04 <jophish_> A Float can represent integral values far larger than any fixed precision integer types in haskell
15:07:24 <Walther> rhovland: hmm, but I've seen the same list being fed into itself in e.g. generating fibonacci
15:07:28 <Walther> it should be possible
15:07:48 <jophish_> so it would have to go though (a perhaps expensive) Integer coversion
15:07:49 <Walther> and my checkPrime should have the edge condition of takeWhile(<x)
15:08:13 <rhovland> Walther: yeah, but in this case, it's going to take "x=2", then checkprime x [ "take x=2, then checkPrime x ...
15:08:30 <jophish_> compare this to the 'floor' function in C http://en.cppreference.com/w/cpp/numeric/math/floor
15:09:18 <geekosaur> Walther, the trick is laziness. the ones that feed the same list are careful to not request so much as to force additional evaluation, which would lead to the entire list of primes being generated
15:09:50 <rhovland> jophish: hm. so you don't need an exact integer anyway
15:10:28 <jophish_> rhovland: sorry, I don't understand
15:11:12 <Walther> hmm... what way should i look at this then. I want to write a readable, clean-looking solution that is readable
15:11:14 <geekosaur> jophish_, I think you're being bitten here by an attempt to enforce the "no fractional part" in the type system. you might actually need to FFI to C's floor
15:11:48 <Walther> basically, "a prime is a number that isn't divisible by any previous prime, in a list where the first prime is 2"
15:12:17 <jophish_> yeah, annoyingly cmath isn't in stackage!
15:13:11 <rhovland> Walther: you could probably pass a "prevPrimes" around to get what you want
15:13:47 <Walther> rhovland: and how exactly would i define prevPrimes :|
15:13:57 <Walther> in such a way that it wouldn't be evaluated as primes as well
15:14:15 <Walther> I tried moving the takeWhile to the primes definition instead of checkprime, didn't help
15:18:55 <statusfailed> How can I get "cabal repl" to import the imports from a particular file (and not just Main.hs)?
15:20:28 <hexagoxel> statusfailed: iirc it loads the first from the exposed-modules list (but you can :l / :m / import as usual
15:22:21 <lpaste> aweinstock annotated ‚ÄúST filterPermutationsWithReplacement‚Äù with ‚ÄúST filterPermutationsWithReplacement (annotation)‚Äù at http://lpaste.net/141775#a141791
15:22:44 <athan_> Hmm.. making type aliases for contexts will not have the same behavior in terms of variable population / binding.
15:22:59 <Walther> hrmpf, can't seem to make this terminate http://lpaste.net/8925873778408292352
15:23:01 <statusfailed> hexagoxel: import MyModule doesn't get the modules which that module imports though right?
15:23:08 <rhovland> Walther: hm I think http://lpaste.net/141792 is more like what you're trying to do
15:24:15 <Walther> rhovland: I have no idea what's going on in there with the foldl'
15:24:36 <rhovland> walther: starts with an empty list, and adds numbers to it as they pass the prime check
15:25:24 <athan_> cheq it: http://lpaste.net/141793
15:25:26 <aweinstock> I've implemented a combination of filter and (replicateM specialized to []) that runs in space proportional to filter's output, but isn't properly lazy: http://lpaste.net/141791
15:26:10 <aweinstock> There's a delay before printing the head of the output, which indicates that the full list is being calculated (which shouldn't be needed)
15:26:50 <lpaste> athan revised ‚Äútype alias context variable binding‚Äù: ‚ÄúNo title‚Äù at http://lpaste.net/141793
15:29:03 <tomus> how does one compile a static executable from using .cabal file?
15:30:34 <Welkin> tomus: cabal build
15:30:59 <Welkin> the executable will be located in dist/build/
15:31:15 <tomus> static?
15:31:20 <Welkin> yes
15:31:28 <Welkin> that is by default
15:31:51 <greg> hi im trying to do a project using gloss
15:31:51 <greg> but cabal cant seem to find gloss
15:32:06 <Welkin> greg: add it to your build-depends in your .cabal
15:33:21 <hexagoxel> statusfailed: uh, it loads them; but those are not equivalent i guess? i don't know more, sorry.
15:35:04 <tomus> Welkin: moved file to a different computer and: shared libraries: libIL.so.1
15:35:10 <tomus> (not found)
15:35:29 <tomus> mb I not communicating correctly
15:35:48 <Welkin> I know there is a way to link outside libraries
15:35:56 <Welkin> I don't know what it is though
15:36:58 * geekosaur suspects that for external libs you need (a) ghc-options: -optl-static (b) make sure all dependencies are also built with that
15:38:15 <geekosaur> (that is admittedly a bit of a Big Hammer and there may be better ways)
15:39:09 <Welkin> the only answer I found was this
15:39:11 <Welkin> -static -optl-pthread -optl-static
15:39:41 <tomus> yeah, how to do it from the sandbox?
15:39:59 <geekosaur> put that in the ghc-options: stanza in cabal.sandbox.config ?
15:44:17 <tomus> ghc now blows up with http://pastebin.com/75SjcnJF
15:44:32 <tomus> heh, mb I'll give up and end up recompiling it on a target computer...
15:45:09 <geekosaur> right, that means you need to install static versions of those libraries
15:45:25 <geekosaur> ghc can't produce them magically for you
15:45:33 <geekosaur> (neither can anything else)
15:46:06 <tomus> oh? didn't know that...
15:46:13 <tomus> hm...
15:46:30 <geekosaur> static libraries are libsomething.a
15:46:44 <geekosaur> dynamic may be .dll, .so, .dylib depending on platform
15:46:51 <geekosaur> they are built differently
15:46:58 <tomus> fair enough
15:47:29 <tomus> I think recompiling on the target is just easier for me
15:47:39 <geekosaur> often package managers install the dynamlic libs by default and have a separate package for static libs. and sadly, some packages don't provide static libs at all
15:48:03 <geekosaur> (note all the glibc wartnings in that output; glibc really does not like static linking at all)
15:49:13 * hackagebot wai-middleware-verbs 0.0.4 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.0.4 (athanclark)
15:49:15 * hackagebot wai-middleware-content-type 0.0.2 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.0.2 (athanclark)
15:49:48 <tomus> geekosaur: thank you for explanations
15:53:15 <geekosaur> there are actually a bunch of annoying caveats to statis linking, so in fact all the major platforms (linux, windows, os x) strongly deprecate it
15:53:24 <geekosaur> especially on 64-bit
15:53:43 <tomus> this is turning into a slight madness given that what I am really trying ot compile is 80 lines long. this is sheer curiousity rather than a troll: but how would this work on windows? why moving files from one win to another doesn't cause that many issues? cuz all dll's are the same and in the same positions? or is my premise wrong and it does cause issues?
15:54:04 <geekosaur> because windows (and os x) want you to ship all your dlls with the app
15:54:57 <geekosaur> and many distributable linux binaries do the same thing, include all their .so-s in a private lib directory
15:55:54 <geekosaur> before the ship-all-your-dlls-with-it became standard on windows, there were all sorts of nightmares when you installed apps that wanted, say, different versions of MSVCRT.DLL
15:58:47 <tomus> ah ok
15:59:28 <tomus> makes sense
16:00:01 <geekosaur> (that's the visual C runtime library, so pretty much everything wants it...)
16:00:02 <tomus> right, I installed an exernal C library and my executable started working (libIL.so.1)
16:01:13 <tomus> so it all worked out well in the end
16:09:04 <osa1> does anyone know a library for printing show outputs indented and using multiple lines etc?
16:09:25 <hpc> like pretty printing?
16:09:41 <osa1> yeah except I don't want to define pretty printing instances, it should use Show instance
16:09:52 <osa1> (assume GHC-derived Show instance)
16:10:36 <osa1> I have Pretty instances for my types already, but I want to print constructors etc. for debugging purposes, but as the values get bigger they become impossible to read.
16:10:40 <hpc> so like, an auto-indenter
16:11:10 <osa1> ha http://hackage.haskell.org/package/groom
16:11:31 <hpc> oh hey, http://hackage.haskell.org/package/groom
16:11:32 <hpc> lol
16:12:20 <hpc> it's a tiny package too
16:12:21 <hpc> groomString :: String -> String
16:12:22 <hpc> groomString s = case parseExp s of ParseOk x -> prettyPrint x ParseFailed{} -> s
16:12:33 <hpc> gee thanks for merging those lines irssi
16:13:33 <osa1> normally I wouldn't use it because it uses haskell-src-exts but I'm already using it so it's ok :)
16:14:01 <glguy> osa1: Are you interested in language-lua getting updated to 5.3.1 syntax, it's backward compatible, adds some new operators and unicode escapes to strings
16:14:24 <osa1> glguy: yes! I've been meaning to do that for a while now.
16:14:33 <glguy> OK, I'm about done, I'll send a PR today
16:14:35 <osa1> glguy: I just always have some other stuff that get in the way
16:14:40 <osa1> glguy: wow, awesome!
16:15:01 <osa1> glguy: could you also add tests from Lua? like we currently have for Lua 5.2.
16:15:35 <lpaste> tabemann pasted ‚ÄúParse error?‚Äù at http://lpaste.net/141796
16:15:37 <glguy> Oh, already done :)
16:16:01 <glguy> I'm finishing up the unicode escapes and I'll send it along
16:16:19 <tabemann> I'm having an issue with haskell-mode where it keeps on saying I have a "Parse error" yet from looking at the code I cannot find any such issue
16:18:02 <tabemann> anyone have any ideas as to what's going on here?
16:18:19 <athan> tabemann: Sorry I didn't see it, what was it?
16:18:29 <tabemann> <lpaste> tabemann pasted ìParse error?î at http://lpaste.net/141796
16:22:02 <tabemann> specifically there's something wrong with the line:
16:22:03 <tabemann> <lpaste> tabemann pasted ìParse error?î at http://lpaste.net/141796
16:22:05 <tabemann> whoops
16:22:37 <tabemann>   let hints = S.defaultHints { addrFlags = [S.AI_CANONNAME, S.AI_NUMERICSERV] }
16:23:21 <tabemann> (mind you this is under a "do", and Network.Socket is qualified as S)
16:25:15 <glguy> osa1: Do you know if it's new in Lua 5.3 that you can have a # comment on the first line?
16:25:29 <glguy> presumably to support a #!/usr/bin/env lua
16:29:22 <osa1> glguy: I don't know about 5.3 specifically but that was valid in 5.2. assuming backwards compatibility it should be valid.
16:29:36 <osa1> I don't remember if we support that though, I think I had removed those lines in test programs.
16:29:37 <glguy> OK, it looks like language-lua doesn't know about it, though
16:29:42 <osa1> yeah
16:29:44 <glguy> I'm just adding that to the lexer if that's OK
16:29:57 <osa1> sure, that'd be great.
16:29:57 <glguy> it's specifically if it's the first character of the file
16:30:03 <osa1> awesome
16:31:50 <glguy> The tests appear to be saved in latin1 format, should I convert them to utf8 or change the test program to use latin1 encoding?
16:33:06 <hpc> glguy: you should be mercilessly unicode
16:34:17 <tabemann> there is no good reason why not to use utf-8, compatibility with legacy libraries that use utf-16 aside... and even then one should just convert to utf-16 at the interface with such libraries
16:34:38 <osa1> glguy: I manually converted all of them to utf8 before, I think alex had some problems with latin1 or maybe I had some other problem
16:41:15 <athan> Is there an easy way to see if you're depending on packages needlessly?
16:42:41 <tommd> athan: Good question.  Not that I know of.  You can perform the O(N) manual search, but blech!
16:45:08 <monochrom> you can start with the empty dependency, then have GHC yell at you, then add the dependencies it guesses. this takes O(n) time, where n is the minimal number of dependencies, whereas N is the current number of dependencies you have. n <= N.
16:46:12 <tommd> Re-building a cabal package via cabal init would be an O(1) step I guess.
16:46:44 <info_is_good> What datatype is isomorphic to integers? "data Int = Succ Int | Pred Int | Zero" is bigger...
16:46:48 <monochrom> ah, that's better
16:47:39 <hpc> info_is_good: integers are implemented in ghc as bytestrings storing libgmp memory
16:47:46 <monochrom> but mind that cabal init uses version constraints like "== 3.4.*" throughout. you may have to edit them to your real constraints.
16:47:55 <info_is_good> Sorry, I mean mathematical integer.
16:48:03 <hpc> oh i see
16:48:12 <tommd> info_is_good: You can use peano numbers.  There is away to represent negatives with them (conceptually). Not sure how that is done though.
16:48:16 <hexagoxel> tabemann: last statement in do-block must not be a bind. try adding an `undefined` or `_` in the next line.
16:48:20 <monochrom> this takes O(l) time, where l is the number of version constraints you actually want to customize. l <= n <= N.
16:48:21 <info_is_good> I.e., a datatype with an one-to-one correspondence with the set [... -3, -2, -1, 0, 1, 2, 3 ...]
16:48:27 <hpc> i think if you make it strict, that removes a couple of bottoms as well as œâ
16:48:44 <Welkin> the way I cam up with to represent negative and positive peano numbers is this
16:48:56 <glguy> osa1: The lexer isn't going to pass the utf8.lua tests without some serious overhaul afaict
16:49:00 <Welkin> data Nat = Succ | Pred | Z
16:49:10 <monochrom> info_is_good: the standard type "Integer" is isomorphic to mathematical integers.
16:49:13 <Welkin> Pred (Pred Z) is 2 :D
16:49:15 <Welkin> er
16:49:17 <Welkin> Pred (Pred Z) is -2 :D
16:49:23 <hpc> oh, here's a way
16:49:31 <hpc> data Nat = One | Succ Nat
16:49:36 <tommd> info_is_good: Perhaps cleaner is data I = Zero | Negative NonZero ; data NonZero = One | Succ NonZero.  (cleaner conceptually, not in code obviously)
16:49:40 <Welkin> er, yes, I forgot the Nat
16:49:44 <hpc> data Int = Zero | NonZero Bool Nat -- Bool is the sign
16:49:46 <glguy> osa1: but everything else seems to work
16:49:59 <ReinH> The point is to eliminate redundant constructions like P (S Z) = Z
16:49:59 <glguy> check("Ê±âÂ≠ó\x80", #("Ê±âÂ≠ó") + 1) -- not working yet
16:50:11 <int-e> Welkin: what's Succ (Pred Z)? working with quotients can be annoying...
16:50:29 <osa1> glguy: did you convert the file to utf-8? what's the error?
16:50:42 <ReinH> hpc: only for nats > 0
16:50:47 <Welkin> int-e: 0
16:50:48 <glguy> osa1: Exception: lexical error near line: 120 col: 47 at char "
16:50:55 <glguy> osa1: Yeah, it's saved in UTF-8
16:50:56 <hpc> ReinH: i defined non-zero Nat on the line above
16:51:02 <ReinH> hpc: ah yes
16:51:31 <Welkin> haha
16:51:39 <hpc> ReinH: (the icky version of Nat)
16:51:41 <Welkin> Nat is by definition non-negative
16:52:02 <info_is_good> tommd: did you miss a "| Positive NonZero" ctor?
16:52:11 <tommd> info_is_good: Yes
16:52:11 <monochrom> there should be a way to prove that the integers cannot be an algebraic data type.
16:52:27 <glguy> osa1: I had to go through some extra steps to deal with unicode in my last alex lexer: https://github.com/glguy/config-value/blob/master/src/Config/Lexer.x
16:52:32 <johnw> monochrom: they can't be?
16:52:53 <ReinH> hpc: Actually, since [0..] and [1..] have the same cardinality, you can use the regular version of Nat too
16:52:55 <osa1> glguy: it seems like that's not lexed by current lexer too, so I guess it's OK. we can create a ticket for it.
16:53:09 <hpc> ReinH: no, that would admit plus and minus zero
16:53:10 <info_is_good> Cool. Both tommd and hpc's representations are isomorphic to integers.
16:53:14 <ReinH> hpc: No, it wouldn't
16:53:22 <tabemann> hexagoxel: that's just because I haven't added anything after that yet
16:53:28 <ReinH> Zero in the nats doesn't need to represent zero in the integers. It can represent 1 instead.
16:53:50 <hpc> that's just bad code
16:53:52 <ReinH> If all that is required is equal cardinalities, it doesn't matter what names things have.
16:53:56 <ReinH> hpc: this isn't code, this is math :p
16:54:14 <hpc> well then it's very good math because i don't understand why you wouldn't do it the more readable way ;)
16:54:29 <ReinH> hpc: I'm just correcting myself.
16:54:35 <hpc> just being silly
16:54:56 <hpc> info_is_good: do you care about œâ being a valid value as well?
16:54:58 <ReinH> You can also use Maybe (Either Nat Nat) if you want to introduce as few new data types as possible
16:55:02 <hexagoxel> tabemann: but.. until then its a syntax error (?)
16:55:10 <hpc> ReinH: ooh, that's good
16:55:25 <monochrom> ok, here is how the integers can be an algebraic data type. you build up an infinite countable algebraic data type you like. then of course it is in bijection with the integers. however...
16:55:29 <hpc> ReinH: Nat needs to be a free type though ;)
16:55:54 <monochrom> however, that's the best you can do. as soon as you inflict requirements on the bijection, e.g., "preserves order", you're screwed.
16:56:02 <ReinH> hpc: fine, Maybe (Either Natural Natural) from Numeric.Natural
16:56:53 <ReinH> btw, the real answer is
16:56:58 <ReinH> Nat is already in bijection with the integers
16:57:03 <ReinH> since both are countable infinities
16:57:08 <osa1> glguy:does it work if we add $unilower etc. from your lexer to https://github.com/osa1/language-lua/blob/master/src/Language/Lua/Annotated/Lexer.x#L30 ?
16:57:23 <hpc> ReinH: i was thinking something silly like Free Maybe ()
16:59:17 * hackagebot ed25519 0.0.3.0 - ed25519 cryptographic signatures  https://hackage.haskell.org/package/ed25519-0.0.3.0 (AustinSeipp)
17:00:13 <Clint> thoughtpolice: woot!
17:00:27 <thoughtpolice> *cough*
17:00:32 <monochrom> more carefully, if your algebraic data type uses "deriving (Eq, Ord)" for its order, then it cannot be order-isomorphic with the integers.
17:00:33 <glguy> osa1: Note that $unilower doesn't work on its own, you have to update the lexer to map things to that code
17:00:38 <glguy> https://github.com/glguy/config-value/blob/master/src/Config/LexerUtils.hs : byteForChar
17:00:39 <thoughtpolice> Yeah, that only took me two years to do an actual new release.
17:00:45 <glguy> Once we do that it will start working
17:01:06 <monochrom> the "deriving (Eq, Ord)" order for algebraic data types is well-founded. the order for the integers is not.
17:01:10 <glguy> osa1: the trick is that you don't tell alex about the non-ascii stuff, you just tell it which character class it was in
17:01:22 <thoughtpolice> I'm beginning to acquire Duncan/Bryan levels of response latency.
17:01:44 <tabemann> hexagoxel: yes
17:01:54 <monochrom> the only way you can fix that is to write your own Ord instance to do the same thing as the integers, which feels like begging the question.
17:01:57 <osa1> glguy: where do you do that in your code?
17:02:09 <glguy> osa1: in alexGetByte
17:02:20 <glguy> line 40 of the utils file
17:02:21 <monochrom> i.e., your Ord instance code is going to say: convert to integer, compare.
17:02:46 <glguy> osa1: I actually drive alex with a Text in that code rather than a STring
17:02:48 <glguy> but it's the same idea
17:04:59 <johnw> monochrom: how is the Ord for integers not well-founded?
17:05:40 <osa1> glguy: so you have a custom wrapper, right? where do you tell Alex that you have a custom wrapper? I don't see %wrapper command in .x file
17:06:04 <monochrom> many non-empty subsets of integers have no minimum.
17:06:09 <glguy> osa1: You tell it that you have a custom wrapper by not having a %wrapper iirc
17:06:09 <osa1> (I really great at forgetting this Alex stuff...)
17:07:43 <glguy> ghc taught me how
17:09:28 <osa1> instead of doing this hack in every single Alex program maybe we should add proper unicode character handling to Alex :) glguy: do you know why Alex can't do it? is it just laziness?
17:09:54 <glguy> Because it needs to be able to make a table that it can index with each input byte
17:10:00 <glguy> and putting utf8 into that table is a mess
17:10:20 <glguy> Moving my Text wrapper into actual alex would be nice, though
17:11:29 <osa1> you can index the table using multiple bytes but I guess you need a fixed length for efficiency?
17:12:26 <glguy> I think having alex know about file encodings is probably the wrong directly
17:12:54 <glguy> driving it by Char with a Text seems better, but you still have the issue of not wanting a table with 0x10ffff long rows
17:14:00 <osa1> makes sense
17:16:00 <glguy> I think that collapsing non-ascii characters down to their character class is a pretty reasonable compromise
17:20:02 <osa1> glguy: in your code, you're returning one byte for unicode characters but you're skipping actual bytes for the character? how does it work?
17:21:04 <osa1> in byteForChar :: Char -> Word8, and also alexMove :: Position -> Char -> Position increases column by one when returning that Word8
17:21:06 <glguy> Each Char I get from Text.uncons is an actual unicode codepoint, not a utf-8 byte
17:21:20 <osa1> yeah
17:21:33 <glguy> so I always advance by one
17:22:27 <osa1> but for example if you have a character represented by 2 bytes, how do you add that to the generated Atom? as far as I can see you just add a byte for it's category(uniupper, unilower etc.)
17:22:52 <Hafydd> its
17:22:53 <glguy> I give both the Char and the Word8 to alex
17:23:27 <glguy> The Word8 advances the state machine and the Char is used for making the Atom
17:23:32 <Home> hello
17:24:41 <stutonk> Hello, everyone
17:25:30 <johnw> stutonk: hi
17:25:56 <stutonk> How would one create a function that extends another function? Say you have type Fn = String -> Int, how would you then implement a function of type Fn -> String -> Int -> Fn?
17:26:27 <osa1> glguy: do you give actualy bytes using Position type? I'm confused becuase if you look at this line https://github.com/glguy/config-value/blob/master/src/Config/LexerUtils.hs#L38 as far as I can see c is not passed to Alex
17:26:40 <osa1> s/actualy/actual
17:27:09 <glguy> alexMove :: Position -> Char -> Position
17:27:35 <glguy> andthen... let's see
17:28:36 <glguy>         case act (fmap (Text.take len) inp) st of
17:28:49 <Home> what is this channel actually for?
17:28:50 <glguy> It uses the match length over here to get the matched Text
17:28:56 <glguy> Line 125 of Lexer.x
17:29:24 <glguy> Home: Discussion about the Haskell programming language
17:30:23 <osa1> glguy: how did you jump from alexMove to scanTokens :)
17:31:36 <osa1> "It uses the match length over here to get the matched Text" OK I guess that explains
17:32:08 <glguy> I haven't touched this code since March. I have to page stuff in :)
17:32:45 <osa1> haha yeah that happens to me all the time, I'm never comfortable with Alex because I give long breaks after each update.
17:33:04 <osa1> I'm creating a ticket
17:34:05 <osa1> oh awesome, just saw the PR
17:35:07 <glguy> I'll do the alex fix for unicode later if you want
17:35:25 <glguy> I'm guessing you'd prefer it working on Strings to Text?
17:38:45 <osa1> glguy: hm.. let's leave it as String for now..
17:39:18 * hackagebot wai-middleware-content-type 0.0.3 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.0.3 (athanclark)
17:42:39 <lamefun> stutonk, like this? ext :: Fn -> String -> Int -> Fn; ext func string number = \arg -> func (arg ++ string ++ show number)?
17:46:54 <lamefun> Is that what you mean?
17:50:41 <stutonk> That compiles, but if I try to use it, it complains about non-exhaustive patterns. But I don't really understand exactly what your code means
17:50:56 <lamefun> @let ext func string number = \arg -> func (arg ++ string ++ show number)
17:50:57 <lambdabot>  Defined.
17:51:27 <lamefun> > ext length "ab" 24 "c"
17:51:29 <lambdabot>  5
17:52:41 <lamefun> or even
17:52:51 <lamefun> > ext (\x -> x) "ab" 24 "c"
17:52:52 <lambdabot>  "cab24"
17:53:07 <lamefun> This: (\x y z -> x * y + z) creates nameless functions.
17:54:36 <stutonk> It's the rhs I don't follow
17:54:46 <stutonk> Of the anonymous function
17:55:49 <flexfit> I'm trying to do a level order traversal of a tree, but I'm currently stuck. My current plan is to extract the value of the node, extract the value of the 2 subtrees of the node, then traverse the subtrees without reprinting what I already printed. I'm stuck trying to figure out how to do the last bit.
17:56:08 <lamefun> stutonk, It appends "string ++ show number" to its argument and calls Func.
17:56:12 <lamefun> *func
17:56:29 <lamefun> show converts values to strings, eg.
17:56:49 <lamefun> > show 25
17:56:51 <lambdabot>  "25"
17:57:06 <pavonia> flexfit: Are you traversing the tree multiple times from its root?
17:58:05 <roconnor> flexfit: levelOrder (Node x l r) = http://en.wikipedia.org/wiki/Special:Search?go=Go&search=x++zipWith (++) (levelOrder l) (levelOrder r)
17:58:10 <roconnor> ugh
17:58:15 <roconnor> flexfit: levelOrder (Node x l r) = [ [x] ]++zipWith (++) (levelOrder l) (levelOrder r)
17:58:55 <pavonia> :(
17:59:56 <flexfit> reconnor: Can you explain why you put [[x]], wouldn't that be a list of a list?
18:00:37 <Welkin> roconnor: what a strange function definition :P
18:00:38 <roconnor> flexfit: yeah, you need to helper function after the recursion to flatten the list of lest
18:00:56 <roconnor> *list of lists
18:01:33 <glguy> If you're playing with breadth first traversals, this is a good read http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/icfp00bfn.pdf
18:01:44 <glguy> Breadth-First Numbering:
18:01:49 <glguy> Lessons from a Small Exercise in Algorithm Design by Chris Okasaki
18:03:30 <flexfit> glguy: Thanks! This looks really interesting, I'll take a look at it. This article is in Haskell right?
18:05:24 <Welkin> flexfit: it's in english
18:07:42 <nchambers> does haskell able to interact with python through ffi's or would I need to glue it together with C?
18:07:55 <flexfit> This was my current solution. http://pastebin.com/DcUANmiU
18:08:02 <Welkin> nchambers: you need to use C
18:08:05 <Welkin> the C FFI
18:08:23 <nchambers> Welkin: yeah I figured. Haskell -> python seems pretty exotic
18:08:29 <Welkin> nchambers: unless you compile your haskell program to a binary and call it from the python using the command line utility
18:09:00 <Welkin> or the other way around
18:09:11 <nchambers> yeah
18:11:15 <roconnor> > ("x",(+1)) <*> ("y",2)
18:11:18 <lambdabot>  ("xy",3)
18:12:39 <nchambers> > let swap' :: (a,b); let swap' (first,second) = (second, first); swap' ('abcd', 123_
18:12:41 <lambdabot>  <hint>:1:84:
18:12:41 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:12:44 <nchambers> damn
18:12:52 <nchambers> > let swap' :: (a,b); let swap' (first,second) = (second, first); swap' ('abcd', 123)
18:12:54 <lambdabot>  <hint>:1:84:
18:12:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
18:13:04 * tabemann 'd hate to actually work with Python from within Haskell, or any language at all, due to its thoroughly unfriendly FFI
18:13:45 <nchambers> haskell has the unfriendly ffi?
18:14:04 <tabemann> nchambers: Python has an unfriendly FFI
18:14:16 <nchambers> tabemann: there cffi now
18:14:24 <nchambers> You don't have to use <Python.h> anymore
18:14:41 <glguy> The original #haskell pastebin used to do syntax highlighting via Python's C FFI via Pygments
18:15:09 <tabemann> the big problem with the Python FFI is memory management
18:15:24 <nchambers> eh I don't care about that so much
18:15:45 <nchambers> I've got a lexer written in python and I want to write a parser for it in haskell
18:16:24 <tabemann> reference counting is not fun
18:18:13 * tabemann remembers working with the Lua 5.2 FFI after having worked with the Python 2 FFI... the difference was quite marked, with the Lua 5.2 FFI being much nicer to work with
18:19:27 <glguy> Makes sense considering that it's 3.2 more
18:19:52 <tabemann> lol
18:20:16 <stutonk> lamefun++
18:22:24 <tabemann> Python is a good example of why you, if implementing a language, want garbage collection, even if reference counting may seem easier to implement, and even if you add special mechanisms for doing cycle detection
18:23:03 <Clownpiece> tabemann: What happens?
18:23:47 <tabemann> Clownpiece: reference counting infects your FFI, and every single piece of C code that wants to interact with your code has to manage references for you
18:24:34 <lamefun> ??karma lamefun
18:25:17 <tabemann> and manually managing references is, well, error-prone
18:25:20 <awpr> well, Haskell FFI interacts with GC too -- in that no garbage collected object is safe to hand over to C
18:25:23 <Welkin> @karma lamefun 
18:25:23 <lambdabot> lamefun has a karma of 1
18:25:49 <lamefun> Didn't know that #haskell had karma...
18:27:28 <tabemann> awpr: well yes, that's why when writing code to interact with C code in Haskell you have to convert everything over into C-friendly formats that can be used by C
18:28:13 <awpr> tabemann: yeah, and in theory Python could do the same thing, but they don't have to because it's possible for C code to handle Python objects correctly
18:28:18 <tabemann> in OCaml, which I've used the FFI of in the past, it seems to do something like turn off the GC while in C code, but I'm not certain per se
18:30:13 <tabemann> I like how Lua does things better, such that one *can* manipulate Lua objects from within C... but the Lua objects exist in a Lua world that can only be manipulated through Lua calls and cannot be manipulated directly
18:30:20 <tabemann> *Lua FFI calls
18:31:06 <tabemann> e.g. there is a Lua stack machine as C code sees it* that one manipulates so as to act on Lua objects
18:31:27 <tabemann> * apparently Lua actually is a register machine, but it uses a stack paradigm for interacting with C code
18:34:21 <Welkin> a register machine?
18:35:10 <glguy> Lua uses a stack internally as well
18:35:33 <glguy> it's "registers" are just offsets from the current stack base
18:36:16 <geekosaur> tms9900 / ki10 style arch?
18:36:42 <awpr> I think a 'foreign import ccall unsafe' FFI call has a similar effect to the OCaml behavior you described, in that it doesn't release the Capability, so a GC can't proceed while it's running.  could be mistaken, though
18:38:30 <awpr> it would also be interesting to have C functions capable of manipulating Haskell objects, along with some GC magic to make a pointer-sized block of pinned memory that counts as a reference when its pointee gets moved
18:40:10 <awpr> I guess these C functions would have to acquire a Capability to avoid racing with collections
18:42:31 <tabemann> awpr: the difference is that in OCaml you actually have references to OCaml objects that you can manipulate from within C, unlike foreign import ccall unsafe
18:50:54 <awpr> tabemann: indeed, that's what I was talking about in the following two messages.  but there is at least one case where you can hand a pointer to a Haskell object to C: ByteArray#
18:54:13 <glguy> osa1: Still around?
18:54:21 * hackagebot language-lua 0.7.0 - Lua parser and pretty-printer  https://hackage.haskell.org/package/language-lua-0.7.0 (OmerAgacan)
18:54:28 <osa1> glguy: yes
18:54:43 <glguy> next PR <_<
18:56:55 <osa1> glguy: interesting, so none of the tests included an integer divison?
18:57:04 <glguy> No, they did, but we don't evaluate the expressions
18:57:19 <glguy> so the fact that they parsed as shiftl (I believe) was oK
18:58:14 <glguy> Once I connect language-lua to my lua-bc (bytecode reader/writer) which is connected to my bytecode interpreter we can check that the tests actually work, not just parse :)
18:58:32 <osa1> glguy: I'm confused, how can you parse // as shiftl?
18:58:54 <glguy> -    <0> "//"  { tok LTokDGT }
18:59:02 <glguy> shiftr, actually
18:59:05 <osa1> ahhh
19:00:43 <osa1> this sucks, I just pushed new version to hackage :p
19:00:45 <osa1> whatever
19:00:49 <glguy> sorry!
19:05:32 <fread2281> how do I debug Earley parsers?
19:06:01 <fread2281> (besides allParses)
19:09:22 * hackagebot language-lua 0.7.1 - Lua parser and pretty-printer  https://hackage.haskell.org/package/language-lua-0.7.1 (OmerAgacan)
19:10:15 <osa1> do I get hyperlinked source pages now?
19:10:39 <glguy> You will eventually, or you can use the script I have in the lens repo to do them yourself if you have the git versin of haddock
19:11:07 <osa1> that sounds like too much work.
19:22:54 <flexfit> I'm getting a non-exhaustive pattern exception on line 7 of this code, and I'm not sure how to fix it. I've tried to have it return an empty list when I get an empty tree, but then the program doesn't even compile?
19:23:18 <Fylwind> ‚Ä¶ hrm apparently INLINABLE can make GHC less likely to inline? o.o
19:24:38 <geekosaur> Fylwind, inlining the wrong thing can make it decide it's too expensive to inline something else
19:24:44 <geekosaur> iirc
19:28:19 <fread2281> flexfit, code?
19:28:41 <flexfit> fread2281: oops, I thought I posted it.
19:28:50 <flexfit> http://pastebin.com/fBMCitVj
19:31:15 <fread2281> :t (>>=)
19:31:17 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:31:55 <fread2281> flexfit, use (xs >>= element) and return a 1 element list on line 7
19:32:29 <fread2281> that will make the Nil = [] case compile
19:32:46 <flexfit> What does >>= do exactly?
19:33:26 <fread2281> flexfit, it's concatMap for [], you can use that too
19:33:46 <fread2281> ?src concatMap
19:33:46 <lambdabot> concatMap f = foldr ((++) . f) []
19:33:52 <fread2281> :(
19:34:03 <fread2281> concatMap f = concat $ map f
19:34:42 <exio4> concatMap f = concat . map f -- you mean?
19:34:56 <exio4> @type \f -> concat $ map f
19:34:57 <lambdabot> Foldable ((->) [a1]) => (a1 -> a) -> [a]
19:35:03 <exio4> @type \f -> concat . map f
19:35:04 <lambdabot> (a1 -> [a]) -> [a1] -> [a]
19:35:11 <flexfit> ah. I see. I'm not sure what you mean by using (xs >>= element) to return a 1 element list. 
19:35:44 <flexfit> I tried doing something element Nil = [], element (Node x _ _ ) = [x], but it wasn't compiling
19:36:41 <fread2281> flexfit, you need to change how you call element to do that, so do (concat (map element xs)) instead of (map element xs)
19:37:01 <fread2281> (xs >>= element) == (concat (map element xs))
19:39:03 <fread2281> flexfit, you can do stratify in one pattern match though
19:39:17 <flexfit> fread2281: How so?
19:40:24 <fread2281> > let {stratify (Node x a b) = [x] ++ stratify a ++ stratify b; stratify Nil = []} in stratify (Node 1 (Node 2 Nil Nil) Nil)
19:40:26 <lambdabot>  Not in scope: data constructor ‚ÄòNil‚ÄôNot in scope: data constructor ‚ÄòNil‚ÄôNot ...
19:43:08 <flexfit> fread2281: Doesn't that just give the preorder traversal?
19:44:43 <fread2281> yep, sorry
19:46:19 <flexfit> Is there a more elegant way to do a level order traversal? Mine seems so inelegant
19:47:56 <athan> \o/ nested-routes is now generalized for any WAI middleware! wew hew
19:51:26 <flexfit> The dollar sign in haskell are used in place of parens right?
19:51:44 <arw_> flexfit: sometimes.
19:52:29 <flexfit> arw_: Are they used for something else? From what I read in the tutorial, that really seems to be the only used for them.
19:52:30 <fread2281> yes
19:52:30 <fread2281> ?src ($)
19:52:30 <lambdabot> f $ x = f x
19:52:32 <fread2281> f $ a = f a
19:52:40 <arw_> flexfit: $ is used like "put a parens here and one at the end of the line"
19:53:07 <athan> flexfit: You can see it as a "catch-all" in that expression's scope
19:53:13 <arw_> flexfit: well, strictly speaking, $ is an operator, () is not.
19:53:19 <athan> things get complicated when you wrap _those_ in parens too, though
19:53:23 <fread2281> > map ($ 2) [(+1),(*2)]
19:53:25 <lambdabot>  [3,4]
19:53:44 <athan> > ((+) $ ((+1) $ 4)) 5
19:53:46 <lambdabot>  10
19:54:17 <flexfit> When I try to replace the parens on line 5 of my code with $. I  get complains from the compiler. Why is that?
19:54:18 <flexfit> http://pastebin.com/ezf7WRvu
19:55:25 <geekosaur> because "concatMap element xs ++ levelOrder $ concatMap subTree xs" means "(concatMap element xs ++ levelOrder) (concatMap subTree xs)"
19:57:42 <flexfit> Ah, That makes sense. Where would I need to put the $ in order to get rid of the parens then? Would it go after the ++?
19:57:56 <geekosaur> you can't, in that expression
19:58:16 <geekosaur> $ is not magical, it's just very low precedence application
19:58:40 <flexfit> Ah, I thought $ would be used to get rid of all parens
19:58:42 <geekosaur> there is no place you could stick two pairs of parentheses like that and have it make sense
19:59:44 <geekosaur> `a $ b' acts like `(a) (b)' where a and b both extend as far as they possibly can, because $ has lowest precedence
20:00:10 <arw_> flexfit: there is no contest to get rid of all parens, imho they are left out far too often.
20:03:10 <jmcarthur> I wish ($) wasn't a thing.
20:03:57 <jmcarthur> I do use it, but basically just in front of lambdas or do blocks, and even then I feel dirty
20:04:06 <flexfit> jmcarthur: Does it ruin readability of code that much?
20:04:43 <jmcarthur> Ruin? No. But it's so unnecessary and ugly, and it confuses beginners.
20:05:45 <jmcarthur> Oh, and sometimes people use it in such a way that they use (.) less, but I think (.) is *under*used, so that's another reason for me to hate on ($).
20:06:07 <flexfit> (.) is the composition function right?
20:06:11 <jmcarthur> right
20:07:30 <jmcarthur> flexfit: there are indeed some pretty neat ways of doing level-order traversals (just saw your question from earlier)
20:07:42 <jmcarthur> flexfit: what's wrong with your version?
20:08:45 <flexfit> jmcarthur: The one that I just posted works fine now. I was just trying to get rid of the parens earlier.
20:09:08 <jmcarthur> ah
20:09:39 <flexfit> someone else mentioned earlier that it was possible to do the level order traversal with just one pattern matching, instead of the 4ish that I have.
20:09:47 <jmcarthur> yup
20:11:13 <flexfit> I would like to make my function shorter if I can. 
20:11:51 <jmcarthur> It can also be done without (++), which takes O(n), which makes your function O(n^2), but that's more of an algorithm thing than a Haskell thing.
20:13:09 <flexfit> the (:) is generally faster than (++) right?
20:13:30 <jmcarthur> Actually, your explicit use of (++) isn't the problem, because its left argument has at most one element, but the concatMap in the right argument could be expensive.
20:13:53 <jmcarthur> Yes, (:) takes O(1).
20:14:45 <jmcarthur> (Plus an allocation, which may actually be a nontrivial cost, due to the GC, but that's context dependent, and usually not a problem.)
20:14:53 <flexfit> So if I wanted a better runtime, I would have to use something other than concatMap? 
20:15:13 <jmcarthur> (I only bothered to say that at all because (++) doesn't have to allocate when the first argument is [].)
20:15:50 <jmcarthur> Well, more like if you *do* use concatMap you need to use it differently. Right now there is no bound on the sizes of the lists you are reconstructing.
20:16:24 <jmcarthur> I'm giving you detail overload, by the way. You probably don't care about any of this.
20:16:42 <jmcarthur> s/don't/shouldn't/
20:16:57 <lemevi> haskell requires a bit of work to learn 
20:17:01 <lemevi> tbh
20:17:11 <lemevi> pretty different from any PL I know already
20:17:22 <flexfit> I thought I was pretty good by going through most of the LYAH tutorial, but I guess not
20:17:26 <jmcarthur> It depends on your background.
20:17:36 <lemevi> imperative languages
20:17:43 <jmcarthur> Used to Python? Yeah, Haskell going to be weird.
20:17:49 <flexfit> It's a different way of thinking for sure.
20:17:59 <geekosaur> LYAH tends to be good at teaching reading Haskell code but many people seem to have trouble *writing* Haskell just from LYAH
20:18:20 <jmcarthur> I am unhappy with our learning materials.
20:18:27 <lemevi> I'm going through LYAH right now
20:18:34 <lemevi> I see it more as an overview
20:18:38 <flexfit> I've heard some good things about Real World Haskell, would that work?
20:19:21 <lemevi> once I'm through LYAH I'm going to just think of a project and try to write it in haskell and solve each problem as I run into it
20:19:22 <jmcarthur> The problem with RWH is that it was written during a time that many pragmatic aspects of Haskell were changing rapidly, and its age started showing quickly.
20:19:28 <lemevi> usually I start with an irc bot
20:19:29 <geekosaur> it's less good as an introduction, although it has some introductory stuff
20:19:39 <jmcarthur> It's still good, but not great, especially for beginners.
20:19:48 <geekosaur> it's more of an intermediate text, plus what jmcarthur said about stuff changing out from under it
20:20:03 <geekosaur> IIRC the exception stuff changed right around when it was published
20:20:26 <lemevi> is haskell pretty stable?
20:20:37 <geekosaur> ...not as stable as some would like
20:20:50 <flexfit> Do you guys have any thoughts on Haskell: The Craft of Functional Programming?
20:21:19 <geekosaur> haskell is trying to at the same time be a research/theory language and a practical language
20:21:41 <flexfit> From what I understand, Haskell is meant more as an academic language.
20:21:48 <geekosaur> there has been a growing movement toward replacing various things based in practice with ones based mroe in theory
20:22:31 <geekosaur> so ghc 7.10.1 came with changes to a bunch of stuff to make it more theoretically sound, and there are more such changes slated for ghc 8.0.1
20:23:23 <lemevi> I guess better to pull that bandaid off now
20:24:12 <glguy_> Some of that theory is about supporting practice like the monad changes to help enable applicativedo
20:24:12 <dolio> I don't really recall it being intended as introductory, per se.
20:24:17 <jmcarthur> I don't think Haskell is as academic as its reputation might suggest, but there are definitely a lot of super experimental features that a pragmatic programmer might want to leave disabled most of the time.
20:24:27 <jmcarthur> *of ghc
20:24:31 <geekosaur> when it's all done, a lot of things will work better and fit together better, but the transition period can be fairly painful
20:24:55 <jokester> I bought the book, haven't started
20:25:03 <geekosaur> not just ApplicativeDo although that's certainly in the set of "will work better and fit together better"
20:25:26 <jmcarthur> Most breaking changes are related to real-world concerns, not some grad school experiment they are including despite protests or something.
20:25:36 <geekosaur> right
20:25:47 <geekosaur> iit's not theory for theory's sake either
20:25:59 <jokester> From the contents I guess it's more about engineering rather than math/academic
20:26:05 <flexfit> Is Haskell widely used in the software industry?
20:26:08 <geekosaur> a lot of the current thrashing is because Applicative *didn't exist* when Monad was formalized
20:26:26 <flexfit> The only thing I've heard was that Facebook was using Haskell to detect spam or something like that
20:26:37 <dolio> But Functor did, and they got that wrong.
20:26:38 <geekosaur> and it turns out there's a lot of practical stuff that you can't do readily without it, as it has been developed and better understood
20:27:14 <geekosaur> I think that was because with Applicative missing, Functor was less obviously a missing major piece
20:27:59 <jmcarthur> flexfit: Haskell is pretty rarely used in industry, but slowly growing in popularity.
20:28:24 <geekosaur> it really did need someone to recognize Applicative trying to peek through Arrows for the real importance of Functor with respect to Monad to show through
20:29:02 <geekosaur> it was more of a "that's nice. and?" before that
20:29:24 <dolio> I don't really understand that argument.
20:29:32 <jmcarthur> Me either. I was about to ask.
20:29:46 <pyon> Just wondering... With the upcoming -XStrictData extension, will the order of declarations matter as in ML?
20:30:00 <flexfit> jmcarthur: What is it mainly used for then?
20:30:01 <geekosaur> I'm trying to say that Functor was *recognized* as a precondition, but not really as a *necessary* one, more as an adjunct
20:30:09 <dolio> They're clearly related, and they decided not to put them in a hierarchy anyway. I don't know why they wouldn't have done the same thing even if Applicative were around.
20:30:09 <geekosaur> which is why they figured they could get away with liftM
20:30:34 <geekosaur> with Applicative in place, it becomes much more obvious that it's more than just an adjunct
20:30:39 <botter> Hi. Could anyone tell me whats wrong with this? createTuple :: (Num a) (Char b) => a -> b -> (a, b)
20:30:47 <jmcarthur> flexfit: Hobby projects and mind expansion, I'd say.
20:30:48 <botter> I'm on chapter 4 of LYAH
20:30:57 <geekosaur> (Num a, Char b) =>
20:31:02 <botter> Ohh
20:31:15 <jmcarthur> flexfit: That said, Haskell is my absolute favorite language and is the first one I reach for when given the choice.
20:31:19 <geekosaur> (I suspect this also relates to the fact that they based Monad on (>>=) instead of join)
20:31:24 <botter> Ah nope. Char is applied to too many type arguments
20:31:25 <jmcarthur> flexfit: Even for "real world" problems.
20:31:28 <lemevi> botter: me too
20:31:30 <geekosaur> iohm right
20:31:31 <geekosaur> er
20:31:33 <geekosaur> oh, right
20:31:34 <pyon> botter: Char isn't a type class.
20:31:37 <geekosaur> Char is not a typeclass
20:31:42 <geekosaur> Num is a typeclass
20:31:46 <geekosaur> Int is not a typeclass
20:31:52 <pyon> botter: (Num a) => a -> Char -> (a, Char)
20:32:00 <geekosaur> it is a member of various typeclasses including Num and Integral among others
20:32:18 <botter> But in the book they do: addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
20:32:18 <geekosaur> Char is also a member of several typeclasses but it's not clear that you care here
20:32:21 <geekosaur> yes
20:32:24 <geekosaur> Num is a typeclass
20:32:28 <dolio> The only thing I can think of that makes the Applicative-Monad connection more compelling is pure/return.
20:32:34 <jmcarthur> Int :: *; Num :: * -> Constraint; Num Int :: Constraint
20:32:54 <jmcarthur> (,) :: Constraint -> Constraint -> Constraint
20:32:56 <geekosaur> and that type signature says: given some type a that is a member of typeclass Num, I have a function (a,a) -> (a,a) -> (a,a) --- all the same single type
20:33:10 <geekosaur> but it weill work for any single type that is an instance of Num
20:33:34 <jmcarthur> (,) is so overloaded.
20:34:07 <geekosaur> put otherwise, Char is a concrete type, (Num a) is a constraint on what type "a" is allowed to be
20:34:17 <dolio> I feel like (,) should be used as an example of why type-directed name resolution is a bad idea.
20:34:17 <botter> Ohh
20:34:40 <botter> Is there another book that explains fundamentals better?
20:35:00 <geekosaur> several
20:35:05 <jmcarthur> (=>) :: Constraint -> * -> *   -- not sure if this is actually a reasonable thing to say
20:35:18 * geekosaur was just raning that LYAH is good at teaching people to read Haskell but not so good at teaching people to write it...
20:35:18 <jmcarthur> I think it is?
20:35:30 <geekosaur> @where learnhaskell
20:35:31 <lambdabot> https://github.com/bitemyapp/learnhaskell
20:35:36 <geekosaur> ^ collection fo resources
20:35:44 <dolio> Is (=>) first-class? I'm unsure.
20:36:15 <geekosaur> LYAH is one of those resources, but best used along with something else
20:36:21 <dolio> If it were, it'd have that kind.
20:36:23 <jmcarthur> I know it can appear in type subexpressions, but I don't think I've ever seen it used as, say, an argument to anything.
20:36:28 <botter> LYAH glosses over a lot of things
20:36:44 <botter> which screws me over when I try to code something
20:36:49 <jmcarthur> In ghci, :k (=>) is a syntax error
20:38:06 <geekosaur> it's not *currently* first class. in theory it could be, but I'm not sure that made sense before the recent type/kind level stuff
20:38:17 <geekosaur> at least it looks ot me like it could be
20:38:31 <geekosaur> there was also that bug some time back that allowed you to have multiple =>
20:38:53 <jmcarthur> I think you still can, no?
20:38:57 <lemevi> oh there's a #haskell-beginners
20:38:58 <lemevi> :O
20:39:02 <geekosaur> hm, haven't checked
20:39:04 <lemevi> I should probably be in there
20:39:26 <jmcarthur> :t (5, 6) :: Num a => Num b => (a, b)
20:39:27 <lambdabot> (Num b, Num a) => (a, b)
20:39:28 <geekosaur> lemevi, #haskell-beginners tends to be used more for walkthroughs and collective learning, I think?
20:39:46 <lemevi> oh
20:40:18 <jmcarthur> You can also use it in the types of arguments of higher order functions, but I think it implies some higher rank type then.
20:40:20 <ReinH> geekosaur: I think to some extent they're using bos's lecture notes as well.
20:40:26 <ReinH> (which are pretty good)
20:40:32 <geekosaur> this isn't a bad channel for beginner stuff, just a somewhat noisy one when you want to focus
20:41:36 * geekosaur should probably go to bed before he becomes completely incoherent >.>
20:41:55 <jmcarthur> When I was first learning, I found #haskell kind of... inspiring? Lots of people casually throwing around all these cool, foreign (to me) concepts. I was jealous. I wanted to learn. I felt like there was a hole in my CS knowledge.
20:42:23 <jmcarthur> All that to say, I appreciated the "background noise" a lot.
20:42:57 <botter> I should lurk here more
20:43:16 <botter> I have less than 6 months to learn this and its all going over my head right now
20:45:03 <exio4> geekosaur: why would that be a bug?
20:45:15 <exio4> geekosaur: (allowing multiples =>)
20:47:19 <ReinH> botter: I would think that you should lurk here less.
20:47:44 <geekosaur> exio4, because the Haskell Report says only one allowed
20:48:50 <botter> ReinH what
20:48:54 <geekosaur> (this might be another place where it is the Report that should be updated, but ghc generally tries to hew to the Report and hide differences behind LANGUAGE pragmas)
20:49:26 <geekosaur> (Language part of the report, at least; it's far more willing to take liberties with the Libraries part)
20:49:34 <ReinH> botter: I don't think lurking is an efficient way to learn something. I would say that you should either participate here or go do something more active.
20:49:40 <jmcarthur> I just found my old IRC logs. The first thing anybody in #haskell said to me was that I may need to shoot my teacher. That's not what I expected to find!
20:49:55 <exio4> jmcarthur: a friendly channel indeed! 
20:50:08 <jmcarthur> exio4: Well, they were right, but still...
20:50:30 <hodapp> hmm, I don't recall the first thing #haskell said to me.
20:50:39 <exio4> geekosaur: makes sense, most usages of multiples => were rank-n-types for me 
20:50:43 <geekosaur> there've been a few "wait wtf is this idiot teacher teaching you?!" moments in here
20:51:05 <hodapp> I do recall some of the first things #java and ##c told me.
20:51:13 <ReinH> heh
20:51:26 <hodapp> but it's best to leave that in the past.
20:52:12 <botter> I'm going to try the cis194 courses instead.
20:52:19 <ReinH> botter: good plan
20:52:20 <geekosaur> (there was one a week or so ago in fact; it may have been intended in a lies-to-children sense but it was really the wrong way to go about it)
20:52:37 <geekosaur> (what the teacher was doing, I mean)
20:52:55 <ReinH> geekosaur: Wittgenstein's ladder is of shoddy construction at best...
20:53:09 <jmcarthur> The teacher in question had us writing in C with a few... constraints. He wanted us to index our arrays starting at 1 (yes, allocating more memory than necessary to achieve it). He wanted us to add "@@@" to the beginning of every line of comments just to "make them stand out more". He required use to define some constants, but when I used int const instead of #define, he knocked out points for not using
20:53:11 <jmcarthur> constants *and* knocked out more points for using variables.
20:53:46 * geekosaur smells a repurposed FORTRAN programmer
20:54:25 <ReinH> jmcarthur: maybe not shoot, but definitely the rest of the world should be protected from that teacher.
20:54:27 <hodapp> jmcarthur: wowwww.
20:54:40 <geekosaur> ...who had picked up K&R C somewhere, but not ANSI C
20:55:23 <exio4> jmcarthur: I like that teacher, maybe him and my oop teacher can get along
20:55:24 * geekosaur specifically recalls that @@@ on comments in a Fortran context. WATFIV learning materials?\
20:56:05 <geekosaur> because it was too easy to miss something in the comment column
20:58:48 <geekosaur> and because the compiler would barf on it instead of interpreting it in a decidedly unexpected way
20:59:37 <jmcarthur> The wild west days.
21:01:57 <IcyFoxy> Hello world. I've been out of Haskell for a little while now. What does ! in front of a type mean? I.e. !UUID -> ... ?
21:02:34 <geekosaur> strict
21:02:59 <IcyFoxy> What's strict about it?
21:04:12 <IcyFoxy> Oh. Cannot be lazy, must be expanded ?
21:04:52 <geekosaur> the topmost constructor must be resolved. deeper ones might not be (so for a list, it will force it as far as _:_ and no farther)
21:05:16 <geekosaur> doesn't even force the first item in the list to be fully evaluated
21:05:28 <geekosaur> just the first list constructor
21:05:43 <geekosaur> that can be enough for a lot of things, though
21:06:47 <glguy>  hodapp: I just checked, your first messages in #haskell back in 2013 aren't too scandalous :)
21:07:49 <IcyFoxy> geekosaur: Thanks
21:10:54 <cmccann> glguy: I changed nicks at some point early on, so I'd already gone native the first time I said anything here under this name
21:11:20 <cmccann> to be precise, I was making a dumb recursion joke
21:12:18 <cmccann> ...I searched for my old nick on ircbrowse and almost the whole first page of results is shachaf making lambdabot quote me :[
21:12:29 <shachaf> It is?
21:12:39 <shachaf> What cmccann quotes would I be looking for?
21:13:03 <cmccann> shachaf: no, my old nick: http://ircbrowse.net/browse/haskell?q=syntaxglitch
21:13:09 <cmccann> also it's only like half the page I guess
21:13:20 <shachaf> Oh, syntaxglitch.
21:13:30 <glguy> ./2011/11.05.27:19:57:59 <cmccann> Once I knew someone who was good with mutual recursion, any time I had a problem I just asked him, and when he had a problem he asked me
21:13:41 <cmccann> glguy: yep
21:17:23 <hodapp> glguy: If I guessed that they said something like "HERP DERP. How do I Haskell?", how far off would I be?
21:17:36 <hodapp> (since that's pretty much what I say half the time I walk in here still)
21:18:30 <cmccann> hodapp: the second thing you ever said: http://ircbrowse.net/browse/haskell?id=15795818&timestamp=1370007405#t1370007405
21:19:06 <hodapp> cmccann: well that was certainly prophetic, wouldn't you agree?
21:20:15 <cmccann> there are no stupid questions, only stupid jokes, and I've got that part pretty well under control.
21:20:46 <hodapp> version control?
21:23:31 <athan> Does HSpec re-parse haskell code, and toss `;` everywhere?
21:23:41 <athan> (in `do` statements anyway)
21:27:07 <bollu> can someone show me the fmap types for Cont r a?
21:27:14 <bollu> I'm trying to derive the rules by mysel
21:27:16 <bollu> myself*
21:27:30 <bollu> for me, Cont r a ~ (a -> r) -> r
21:27:32 <bollu> is that right?
21:27:43 <bollu> then, fmap :: (a -> b) -> Cont r a -> Cont r b?
21:28:07 <bollu> I can get this: cofmap :: (a -> b) -> Cont r b -> Cont r a
21:28:26 <bollu> but not fmap. I don't know what I'm doing wrong, so could someone just tell me the types? :)
21:28:28 <cmccann> :t flip (.) . flip (.)
21:28:29 <lambdabot> (a -> b) -> ((a -> c1) -> c) -> (b -> c1) -> c
21:28:58 <bollu> @cmcann: that's fmap for Cont r a?
21:28:58 <lambdabot> Unknown command, try @list
21:29:01 <cmccann> anyway, I'm not sure how you got that "cofmap".
21:29:24 <bollu> hm, maybe my order of types for Cont is wrong?
21:29:26 <tomberek> is there a notion in lens for a rank2 setter?  forall f. Settable f => (forall a. a -> f b) -> s -> f t        or in my case:   Applicative f => (forall a -> f a) -> b -> f b
21:29:35 <cmccann> bollu: eh, it's a possible implementation with a more general type, I was being unnecessarily cryptic
21:29:47 <bollu> Cont r a ~ (a -> r) -> r is the way I defined may. Maybe I need Cont a r ~ (a -> r) -> r
21:29:53 <cmccann> bollu: it should be (a -> b) -> ((a -> r) -> r) -> ((b -> r) -> r)
21:29:57 <bollu> so that the fmap applies (Cont a) first?
21:30:00 <bollu> hm
21:30:04 <bollu> I'll play around
21:31:51 <cmccann> bollu: anyway, your cofmap is a contravariant fmap which definitely isn't possible for (Cont r a) so if you can define it either your function diverges or your definition of Cont is wrong.
21:32:28 <bollu> cmccann: okay, um, lemme show you how I thought about it
21:33:35 <bollu> oh, wait
21:33:44 <bollu> back to the drawing board - you're right
21:33:44 <bollu> :)
21:33:49 <cmccann> hahaha
21:34:57 <cmccann> bollu: after you get fmap right, are you going to try writing call-cc?
21:35:56 <exio4> the idea is that you're supposed to write down the types and let djinn infer the code! :P 
21:36:23 <cmccann> which actually works in this case, afaik
21:38:35 <bollu> cmccann: I was hoping to write Applicative and Monad
21:38:46 <bollu> and then have call-cc drop from the heavens as some algebraic structure :)
21:39:16 <bollu> cmccann: does this seem right? http://codepad.org/6LLbOBsL
21:39:27 * hackagebot streaming-commons 0.1.14.2 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.14.2 (MichaelSnoyman)
21:39:34 <bollu> (|>) = flip ($) BTW
21:39:43 <cmccann> I figured as much
21:40:25 <bollu> wait, does that typecheck?
21:40:25 <cmccann> speaking of which, take a look at the type of (|>) and think about it for a moment as far as Cont goes
21:40:52 <bollu> yeah, that's why I was using it in the first place :) Cont is just partially applied (|>) with laws, right?
21:41:27 <cmccann> anyway, looks right to me though I'm not sure I care for the coding style there :P
21:41:43 <bollu> xD
21:41:47 <bollu> how would you write it?
21:41:50 <bollu> I'm a haskell n00b
21:42:10 <bollu> but I couldn't find nice names for something as abstract as that
21:43:56 <cmccann> :t \f m k -> m $ k . f
21:43:58 <lambdabot> (a -> b) -> ((a -> c) -> r) -> (b -> c) -> r
21:44:02 <cmccann> give or take
21:44:17 <cmccann> generally you'd have some newtypes to wrap/unwrap in there
21:45:47 <bollu> cmccann: how is the f m k thing enlighenting?
21:45:57 <bollu> I don't even get how the hell that works
21:46:38 <cmccann> tbh in this case it doesn't need to be, if it type checks it's correct
21:46:56 <cmccann> but naming conventions are that a "f" is a function that you're doing something with
21:47:01 <bollu> and‚Ä¶ m and k?
21:47:05 <cmccann> and "k" is a continuation
21:47:15 <bollu> ohh
21:47:17 <bollu> TIL
21:47:36 <bollu> and m?
21:47:44 <bollu> m is usually monad right?
21:48:30 <cmccann> m is kinda terrible, I dunno what to call that argument here. that's the one that would need unwrapping or whatever else for an actual Cont type
21:49:04 <cmccann> just calling it "x" would also work, I dunno. functions like this are too abstract to give anything meaningful names, generally
21:49:09 <bollu> hm, right. Well, I'll try and get how your definition works
21:49:10 <kqr> what's the actual difference between Data.Monoid and Control.Category?
21:49:17 <cmccann> :k Monoid
21:49:18 <lambdabot> * -> Constraint
21:49:20 <cmccann> :k Category
21:49:21 <lambdabot> (k -> k -> *) -> Constraint
21:49:27 <cmccann> well, there's one difference :P
21:49:45 <bollu> kqr: aren't the two very different?
21:50:03 <bollu> Category is for things that can be composed, right? Monoid is associative + identity?
21:50:09 <cmccann> bollu: it's actually the same as your definition, just condensed
21:50:45 <bollu> cmccann: I suppose so
21:51:12 <kqr> bollu, they both support one binary operator and one identity value. the operator and identity value in Control.Category must form a monoid
21:51:49 <kqr> so I'm guessing there are monoids that are not categories, but not vice versa
21:51:52 <cmccann> kqr: a category is a sort of type-indexed monoid, yes
21:51:53 <bollu> kqr: ohh
21:51:54 <kqr> although I'm fuzzy on the detail
21:52:05 <bollu> that's interesting
21:52:09 <bollu> cmccann: type-indexed?
21:52:17 <cmccann> kqr: a category with only one object is exactly a monoid
21:52:57 <kqr> what does one object mean in this case?
21:53:02 <cmccann> type
21:53:02 <bollu> cmccann: example? say, Integers - how is it with "one object"  ?
21:53:07 <bollu> oh
21:53:08 <bollu> what?
21:53:30 <bollu> cmccann: how would I translate the monoid over integers into a category with one object?
21:54:04 <kqr> "the" monoid over integers?
21:54:30 <bollu> kqr: (Z, 0, +) :) fine, "the" was wrong
21:54:39 <cmccann> bollu: the integers correspond to the morphisms in the category. it's a rather artificial-seeming construction, but they are equivalent afaik
21:55:09 <bollu> cmccann: is it a one-object category?
21:55:11 <cmccann> the sole object is basically content-free, the elements of the set are the morphisms, the identity value is the identity morphism on the one object
21:55:36 <cmccann> the monoid operation is morphism composition, etc.
21:56:02 <bollu> cmccann: how many objects are there in the category?
21:56:06 <cmccann> one
21:56:17 <bollu> ooh, wait, so, like, 3 -> (+3)
21:56:18 <mazur> if C^op x C -> is a "covariant bifunctor", what does a "contravariant" bifunctor look like? C x C^op -> C ?
21:56:30 <bollu> so 3 = 1 + 2 || (+3) -> (+1) . (+ 2) ?
21:57:04 <mazur> (sorry, not to confuse, looks like you all are also discussing about Cat Thy, but my question was not related to the discussion)
21:57:10 <cmccann> bollu: just to be clear, this notion of monoids as single-object categories isn't a haskell thing
21:57:42 <bollu> cmccann: I think I've seen it in ring theory somewhere?
21:57:59 <mazur> oops, first functor was C^op x C -> C
21:58:03 <Hijiri> it doesn't have too much to do with treating the numbers as functions
21:58:14 <Hijiri> except that it lets you map it onto category of sets?
21:58:18 <Hijiri> maybe
21:58:19 <bollu> cmccann: that was the "intuitive" reason why negative x negative is positive. They map the ring to morphisms of the real line, then show that negative numbers map to morphisms that "flip" the real line
21:58:20 <Hijiri> idk
21:58:20 <cmccann> bollu: as I understand it, the morphisms in this monoid-as-category aren't functions in any sense
21:58:32 <bollu> cmccann: hm, really?
21:58:37 <bollu> So, well, in that case, what are they?
21:58:43 <Hijiri> numbers
21:58:44 <cmccann> bollu: integers :P
21:59:17 <bollu> cmccann: "isomorphic to" v/s "is" :)
21:59:42 <Hijiri> they're literally integers
21:59:50 <cmccann> the arrows of a category can be anything as long as they relate objects in the appropriate way
21:59:56 <cmccann> when you have one object, that's trivial to satisfy
22:00:07 <bollu> what? really?
22:00:23 <Reshi> Does anyone some experience with llvm-general: I want to use string constants as operands. I making it a 'ConstantOperand C.Array i8 ..', and I want to use a C foreign function to call printf on char*, I am supposed to use Constant.GetElementPtr on the string constant I created and pass the pointer as the argument to printf right? How do I use GetElementPtr (what paramaters)?
22:00:24 <cmccann> so you can associate arrows with anything you like as long as there's a way to "compose" them
22:00:32 <bollu> cmccann: okay, um, can you construct this from the beginning?
22:00:47 <jle`> bollu: they're just anything, they don't have to mean anything.  all they need to have is a source, a target, and closed under composition
22:01:02 <jle`> the word "arrow"/"morphism" might be misleading in this sense
22:01:14 <cmccann> bollu: you might have more luck looking it up on nlab or something, if you know enough to talk about ring theory you should be able to decipher nlab pages :P
22:01:17 <jle`> source/targets are nothing more than arbitrary labels
22:01:21 <mazur> bollu: composition of morphisms is already associative
22:01:22 <bollu> jle': but you need to define what "composition" is if they can be "anything" right?
22:01:44 <jle`> composition can be completely arbitrary too as long as they follow the laws/axioms
22:01:48 <cmccann> bollu: yes, and for this example composition is being defined as "addition"
22:01:51 <bollu> mazur: that's assuming they're morphisms. But if they're literally "anything", then you'd need to define "compose" too, rigt?
22:02:06 <bollu> cmccann: so in that case, what is the single object for?
22:02:14 <mazur> bollu: we're talking about a category with a single object? the category laws give composition of morphisms
22:02:15 <bollu> oh, to act as the source and target?
22:02:34 <bollu> cmccann: what's nlab
22:02:47 <cmccann> http://ncatlab.org/nlab/show/HomePage
22:03:11 <tomberek> is there a notion in lens for a rank2 setter?  forall f. Settable f => (forall a. a -> f b) -> s -> f t
22:03:15 <cmccann> bollu: more specifically, http://ncatlab.org/nlab/show/monoid#as_a_oneobject_category
22:03:16 <bollu> mazur: Ahh. Okay, so there's one object that's the source and destination of all "integers" in the category. Composition is just addition, and it is guarenteed to be closed since we just have one object? 
22:03:25 <cmccann> bollu: yes
22:03:35 <bollu> that's _weird_
22:03:40 <cmccann> it's category theory
22:03:43 <cmccann> that goes without saying
22:03:44 <cmccann> :P
22:03:46 <jle`> not closed because we have one object, but because integers are closed under addition
22:03:50 <bollu> so, how do you distinguish between two integers / arrows?
22:04:33 <bollu> like, if I give you a function from {a} -> {a}. then there is technically only "one" function
22:04:43 <bollu> but.. here different arrows can be labelled?
22:04:51 <bollu> even though they're to and from the same object?
22:05:08 <jle`> i mean, there are even a bunch of arrows in Set from Bool to Bool, or Int to Int
22:05:21 <hftf> I'm trying to set up a dev env for pandoc alongside a stable version. Last time I was able to name the dev build as pandoc-1.15 to not clash with the pandoc name, but I can't remember how. Is there a cabal option to do this?
22:05:21 <jle`> there can be a bunch of arrows with the same source and target...
22:05:43 <cmccann> kqr: I feel like your initial question got lost in the tangent about monoids-as-categories
22:06:17 <bollu> jle': that's because the set Int is countably infinite. So I can lots of functions. But here, I literally just have one "element", right? That was what confused me
22:06:37 <jle`> bollu: even if your category had only Int as its object, you still have a bunch of Int -> Int functions
22:06:47 <jle`> remember that in Set, the objects are sets, not items inside sets
22:06:58 <jle`> "the set of integers" is an object in the category Set
22:07:01 <bollu> ah, crap. Right.
22:07:02 <cmccann> kqr: has all this clarified anything for you, or just confused things further?
22:07:28 <bollu> jle`: so, well, Int -> Int are functions from "the set of integers" to "the set of integers" ?
22:07:53 <jle`> in this context, yes; and there are several of them
22:08:02 <johnw> it is a set of set functions
22:08:06 <johnw> such
22:08:16 <bollu> jle`: can you show me some of them?
22:08:24 <johnw> (+1) (+2) (+3), etc...
22:08:24 <bollu> jle`: some of the functions, that is?
22:08:26 <jle`> (\x -> x + 1)
22:08:33 <jle`> (\x -> x + 2), (\x -> -x), etc.
22:08:43 <jle`> there are bunches
22:08:48 <bollu> ah, okay. So we're allowed to peek into the structure when defining them
22:08:58 <johnw> hmm?
22:09:05 <johnw> what do you mean by "peek into the structure"?
22:09:14 <bollu> like, you're using the structure of the integers (+, -, whatnot)
22:09:32 <bollu> and not thinking of Int = {set of symbols 1, 2, 3, ‚Ä¶} with no additional structure
22:09:37 <jle`> technically i am talking about the function that maps 0 to 1, 1 to 2, 2 to 3, etc.
22:10:09 <cmccann> johnw: oh, I decided to actually try reusing that parsing stuff from the other day. it turns out to actually be less of a disaster than I remembered.
22:10:16 <johnw> cmccann: nice!
22:10:21 <bollu> jle`: so our category has one object, that is Int?
22:10:33 <jle`> um, it depends on what category you are talking about
22:10:39 <cmccann> johnw: though I've already found a couple pain points and obvious limitations it has because of the original project
22:10:53 <bollu> the one with the conversion of Integers to a one-object category
22:10:58 <jle`> but, you can have a category whose only object is the set of integers, and whose morphisms are functions from integers to integers
22:11:18 <jle`> and there are a bunch of such morphisms... one that maps each integer to the next, one that maps each integer to its negation, etc.
22:11:30 <cmccann> johnw: in particular there's no sane way to work with nested structures without losing lots of detail
22:11:30 <jle`> so all of those functions are a part of the set of morphisms in our category
22:11:42 <bollu> jle`: Like, I was thinking of it this way: keep the one-object in the category to be I. map every integer i to \x -> x + i
22:11:55 <bollu> where \x -> x + i is a function from I to I
22:11:59 <bollu> so that would be the arrows
22:12:06 <cmccann> johnw: and the hex output gets confused if "structs" overlap
22:12:06 <bollu> with just one object (the entire set of integers)
22:12:08 <bollu> does that work?
22:12:13 <jle`> what is I?
22:12:19 <bollu> I is the set of integers
22:12:21 <bollu> should have used Z
22:12:36 <bollu> but, anyway. I = Z = set of integers :)
22:12:54 <jle`> are you talking about transforming the monoid of addition on integers to a category with one object?
22:13:00 <bollu> yep!
22:13:03 <cmccann> bollu: why not ‚Ñ§? ;]
22:13:22 <hftf> Any ideas?
22:13:23 <bollu> cmccann: how'd you type that? :)
22:13:28 <jle`> ah, then yes.  Every number n is mapped to a morphism in your category, in particular (+n).
22:13:48 <cmccann> bollu: I can't type it, it is a type. maybe a kind instead? 
22:13:58 <cmccann> jle`: this whole conversation started because kqr was asking about the relationship between Monoid and Category
22:13:59 <mazur> bollu: i think that's right, but in category theory you can be more agnostic about the elements of an object, the morphisms should give you the full picture
22:14:15 <jle`> ah
22:14:19 <bollu> mazur: Hm. this should be easy to define for any monoid
22:14:20 <jle`> i remember kqr asking about that on the reddit
22:14:23 <cmccann> jle`: and I asserted that monoids can be seen as one-object categories, &c &c
22:14:26 <johnw> cmccann: hmm
22:14:26 <bollu> lemme try. Take a monoid (M, 0, +)
22:14:29 * hackagebot pandoc-citeproc-preamble 1.0.0 - Insert a preamble before pandoc-citeproc's bibliography  https://hackage.haskell.org/package/pandoc-citeproc-preamble-1.0.0 (spwhitton)
22:14:35 <bollu> construct a category with one object M
22:14:49 <bollu> map every m belongs to M to an arrow (\x -> x + m)
22:14:51 <bollu> boom, done
22:14:53 <bollu> right?
22:15:09 <bollu> composition follows from the fact that (+) is associative
22:15:10 <lethjakman> Is there any way to see what template haskell would compile?
22:15:20 <cmccann> lethjakman: you mean the generated code?
22:15:21 <lethjakman> Like an intermediate file?
22:15:23 <lethjakman> Yes
22:15:25 <cmccann> there's a GHC option to dump splices
22:15:28 <cmccann> I forget what it is
22:15:29 <jle`> looks right to me
22:15:31 <cmccann> check the GHC user guide
22:15:44 <lethjakman> That helps, thank you. 
22:16:09 <bollu> yay! awesome :) Thanks for the insight, guys
22:16:30 <bollu> does this relate to the yoneda lemma somehow? >_<
22:16:38 <bollu> I've never understood yoneda
22:16:47 <cmccann> bollu: doesn't everything relate to that somehow?
22:17:05 <johnw> bollu: Yoneda says that any object is equivalent to the hom-set of functions to or from that object, since those sets of functions are all that can ever be known about an object
22:17:20 <mazur> bollu: the yoneda lemma can give you an isomorphism with an object in terms of natural transformations (at least, an isomorphism with the image of the object under a functor), but i wouldn't say i completely understand the whole picture :)
22:17:24 <johnw> object have no information
22:17:26 <johnw> objects*
22:17:39 <johnw> they serve as addresses to identify morphisms only
22:17:46 <bollu> johnw: what is the Hom-set?
22:17:53 <johnw> Int -> Int is a hom set
22:18:02 <johnw> it's a set of morphisms from one object to another
22:18:11 <bollu> so the set of symmetries?
22:18:20 <johnw> whatever morphism means for a given category
22:18:44 <lethjakman> Hmmm, I guess the next question is if there's a way to make persistent or yesod dump splices...
22:19:01 <bollu> so, any object is equivalent to the hom-SET?
22:19:11 <cmccann> lethjakman: I can't really help you there, sorry
22:19:14 <bollu> one object maps to the entire set?
22:19:15 <johnw> every hom-set FROM or every hom-set TO
22:19:31 <lethjakman> cmccann: it's cool, just asking in case anyone knows. Google doesn't seem to be returning anything useful. 
22:19:31 <johnw> not any one hom-set
22:19:56 <shane_> johnw: I figured out the "space leak" that I asked you about around a day ago...it was actually not a leak at all but just that I misinterpreted what the bind operation was doing for the probability monad...it was not normalizing it like I thought...once I did it manually my original fold' worked
22:20:05 <bollu> so object == { f | f :: object -> * } ?
22:20:10 <johnw> shane_: yep, you just needed 'norm'
22:20:19 <shane_> johnw: right
22:20:20 <johnw> shane_: I was reading the documentation for probability and saw that
22:20:25 <shane_> same here
22:20:34 <shane_> when I tried to mimic it then I realized
22:21:21 <bollu> johnw: does this make sense? object == { f | f :: object -> * } ?
22:21:32 <johnw> bollu: so, let's generalize this.  instead of just object, let's say Functor f => f a.  We can always choose f to be identity to get just 'a'
22:22:06 <shane_> johnw: on a related note...is it not possible to add the norm to the bind operation itself?  I know that the problem is that you cannot constrain monad to say the Ord class (which norm is defined on), but is there no GHC extension to allow you to do that?
22:22:16 <bollu> johnw: alright. Identity being Indentity functor, right?
22:22:20 <johnw> yes
22:22:34 <cmccann> shane_: not really
22:22:37 <johnw> so the lemma is: f a ‚âÖ Nat(Hom(-,a), f), or f a ‚âÖ Nat(Hom(a,-), f)
22:22:43 <johnw> I just realize now how long it's going to take to explain that
22:23:00 <johnw> it's not equivalent to just a hom set
22:23:20 <johnw> but the natural transformation from that set of hom sets to the functor
22:23:21 <cmccann> shane_: it's something that comes up on a regular basis. the usual poster child is wanting a Monad instance for Data.Set
22:23:27 <johnw> so, maybe this isn't the time
22:23:47 <bollu> johnw: what's the Hom(-, a) ?
22:24:04 <johnw> Hom(-,a) is the functor that maps any object X to a hom-set X -> a
22:24:27 <johnw> Nat(f,g) is, in Haskell, a polymorphic mapping that looks like forall x. f x -> g x
22:24:33 <shane_> cmccann: and there is no way to get around that?
22:24:40 <jle`> shane_: the most modern way to do this is to use associated types/type families
22:24:53 <cmccann> shane_: the cures tend to be worse than the disease
22:24:59 <cmccann> for a variety of reasons
22:25:23 <shane_> jle`: thanks I will try that
22:25:35 <johnw> bollu: i'd suggest reading up on hom-sets, functors, and natural transformations, before approaching Yoneda
22:26:01 <bollu> johnw: the hom-set X -> a is the set of all functions of the form (x -> a)?
22:26:03 <jle`> shane_: the idea is that every instance of a typeclass also gets to provide a type associated with that instance...like, a Monad typeclass might say, "give me an implementation of return, (>>=), and also a type Foo for that instance"
22:26:07 <bollu> johnw: will do :) what's a good reference?
22:26:09 <johnw> bollu: yes
22:26:31 <johnw> nlab can be good, if you're patient; Awodey's book on category theory is available online somewhere too
22:26:40 <mazur> bollu: bartosz miliewski's blog has a recent series of posts up to yoneda lemma
22:26:57 <johnw> oh yeah, and absolutely that
22:27:16 <johnw> thanks, mazur
22:27:17 <shane_> cmccann: is the cure worse than the disease even using associated types/type families that jile` is suggesting?
22:27:25 <mazur> bollu: i have used awodey's book as well, though it says it's not for "mathemeticians", it expects a lot of the proofs to be provided by the reader
22:27:26 <jle`> shane_: where that type is of kind * -> Constraint, like Ord, Eq, etc.
22:27:50 <cmccann> shane_: yes
22:27:50 <shane_> jile`: I see...I will try and read up more on this...does this turn out to be quite a good work around?
22:27:52 <jle`> so now the new definition is (>>=) :: TheAssociatedConstraint b => m a -> (a -> m b) -> m b
22:27:56 <bollu> johnw: from what you've told me so far, it feels like a generalization of group theory or something. Hom-set feels like the symmetry group of an object
22:27:58 <mazur> bollu: and it's going to bombard you with a lot of examples from mathematics :D
22:28:22 <jle`> shane_: the idea is that every instance you write will be able to give its own "TheAssociatedConstraint" for that typeclass.  so for Set's instance, you'll give Ord
22:28:35 <jle`> s/typeclass/instance
22:28:53 <cmccann> bollu: http://blog.sigfpe.com/2006/11/yoneda-lemma.html is another good one
22:29:04 <bollu> ty!
22:29:23 <johnw> yoneda is incredibly useful, though, despite how abstract it is
22:29:30 <johnw> I've used it in anger in at least three times settings
22:29:31 <bollu> https://www.youtube.com/watch?v=BF6kHD1DAeU <- these work?
22:29:51 <johnw> s/times/different
22:30:05 <bollu> johnw: in programming or math?
22:30:12 <johnw> programming; I'm not a mathematician
22:30:41 <jle`> be careful of wearing it out
22:31:28 <shane_> jile`: so for instance, I will be able to associate Ord with the Monad  instance, so that I can use it to make the bind operation more efficient?
22:31:31 <zzing> Is the 'csv' package the best way to parse csv?
22:32:03 <johnw> zzing: I use cassava, but I really have no idea which is best these days
22:32:21 <cmccann> johnw: anyway, I've been thinking a bit on how to make this parsing stuff more generally useful. you mentioned having a few ideas on how you might use it, anything concrete enough to be a use case data point for me?
22:32:31 <jle`> shane_: if you can write a more efficient bind with an Ord constraint, then yes...but now youc an only bind things with the Ord constraint
22:32:48 <shane_> jile`: right that is what I want
22:33:13 <shane_> the monad that I am usingis only a container for values that can be ordered anyway
22:33:35 <johnw> cmccann: I've had need of it in the past.  I would have liked to use it for protocol analysis, the way that "scapy" does for Python, for example
22:33:48 <bollu> "free category" lol. a category with no structure should be.. interesting
22:33:51 <jle`> mhm.  just be careful that whatever instance you have obeys the monad laws in a reasonable way
22:34:04 <zzing> I told this thing to load my csv file and it said VirtualAlloc MEM_COMMIT failed: The paging file is too small for this operation to complete. That was just after I saw it eating about 5GB of ram.
22:34:13 <johnw> bollu: it has the structure of the laws, just nothing else
22:34:34 <johnw> same way that the free monoid has the structure of a monoid, but no other semantics
22:34:35 <shane_> jle`: right, in this case it is the probability monad, which I think does repsect the laws
22:34:41 <bollu> johnw: yeah, but, a category has so little structure of its own :) I was wondering what it would look like
22:34:53 <glguy> zzing: cassava has a streaming interface that might be good if you're using that much memory (and your use of the csv file is amenable to streaming)
22:34:59 <bollu> johnw: Like, a free group or something is atleast.. visualisable.
22:35:00 <johnw> bollu: have you heard of type-directed lists?
22:35:06 <bollu> johnw: nope. Tell me?
22:35:15 <mazur> bollu: about the awodey lectures, they are pretty similar to the book, i would also seek out robert harpers lectures on type theory from the same seminar; it tied type theory and category theory together nicely for me
22:35:19 <johnw> so, in the free monoid, you can collect elements into a list, like [a]
22:35:23 <jle`> shane_: i don't know if there is a package out there that provides such an associated-types based constrained monad, i usually read about it in blog posts
22:35:37 <bollu> right, makes sense
22:35:46 <bollu> you use (+) to collect, I'm guessing
22:35:49 <bollu> with id being []
22:35:51 <zzing> glguy, I think it is. I have done some parsing with this stuff in python using an iterative interface, it isn't working out there so I think this one might work better.
22:35:51 <bollu> right?
22:35:55 <johnw> with a category, you can collect the arguments to composition
22:36:00 <johnw> but composition only works if the type lines up
22:36:13 <cmccann> johnw: I'm not familiar with scapy, but it sounds like that would be more stream-oriented? the current code pretty much assumes having everything in memory at once and that position has no special relevance
22:36:14 <johnw> so it's a much more restricted kind of list
22:36:16 <bollu> "collect the arguments _to_ composition"?
22:36:20 <bollu> what does the _to_ mean?
22:36:26 <johnw> a free category has (.), but no semantics
22:36:39 <johnw> so if I say f . g . h....
22:37:01 <johnw> the only thing it can do is allow the composition, but it can't do anything else with those arguments but collect them
22:37:14 <shane_> jle`: So I need a separate "associated -types based constrained monad"? I cannot use the existing monad class and define an instance with these constraints?
22:37:21 <johnw> so it's roughly monoidal (similar laws), but the lists are type-aligned
22:37:32 <bollu> johnw: so, you can look at it like building \x -> x  |> f |> g |> h |> ‚Ä¶. ? 
22:37:42 <johnw> yep
22:37:54 <johnw> where f, g and h are just morphisms, and morphisms can be whatever you want :)
22:38:02 <bollu> hm. so the type of x has to match f. and the type of g has to align with the output of f and so on
22:38:03 <bollu> cool
22:38:04 <johnw> so long as everything lines up
22:38:07 <jle`> shane_: the syntax is class Functor f where type Constr f; fmap :: Constr f b => (a -> b) -> f a -> f b
22:38:10 <johnw> exactly
22:38:13 <jle`> shane_: yes, you can't use the existing Monad class
22:38:16 <cmccann> shane_: and that's one of the reasons the cure is worse than the disease
22:38:18 <johnw> so, it can actually be quite useful
22:38:26 <jle`> but you can use RebindableSyntax if you want to use (>>=) still
22:38:31 <johnw> there was a paper at the last ICFP that made really good use of type-aligned lists (also called "paths" in some papers)
22:38:33 <jle`> i mean, use do notation still
22:38:47 <johnw> the structure that gives rise to path is essentially the free category
22:38:57 <cmccann> fun fact: with rebindable syntax you can rebind (>>=) in the middle of a do block
22:39:09 <bollu> johnw: yeah, that makes sense I guess
22:39:23 <shane_> jle`, cmccann: I see....and I suppose this is the sort of thing that an ML module / Functor would be able to handle quite well?
22:39:32 <bollu> heh, that is actually pretty awesome :)
22:39:46 <bollu> slightly related: free monad ~ AST building. Free functor ~ ??
22:39:53 <johnw> there is no free functor
22:40:01 <bollu> because..?
22:40:08 <jle`> shane_: so you can have instance Functor Set where type Constr Set = Ord; fmap = Set.map
22:40:08 <johnw> freeness is an attribute of functors
22:40:11 <johnw> (or not)
22:40:16 <jle`> ...i think that's the syntax
22:40:17 <johnw> it's not a separate structure you can apply to a functor
22:40:18 <bollu> what does that mean?
22:40:44 <jle`> shane_: i'm not sure if that would help, but i am not super familiar with them :)
22:40:44 <johnw> a functor is said to be free if it enriches an object with structure of some kind; it is forgetful if it takes it away
22:40:54 <bollu> wait, free just means "follows nothing except the laws", right?
22:40:57 <johnw> yes
22:41:00 <bollu> Oh, okay. So the laws are so minimal
22:41:09 <bollu> that the "free functor" would simply layer some structure 
22:41:20 <bollu> which is what every functor does? is that it?
22:41:30 <johnw> some functors are forgetful
22:41:35 <johnw> just none of the ones you find in Haskell
22:41:45 <johnw> http://ncatlab.org/nlab/show/free+functor
22:42:03 <johnw> "free monad" enriches a functor 'f' with monadic structure
22:42:12 <shane_> jle`: but will rebindable syntax also allow me to use the other functions like filterM etc that come for free when you define a monad instance?
22:42:17 <johnw> the free monad being itself a functor
22:42:21 <cmccann> shane_: no
22:42:36 <jle`> shane_: no, because filterM is defined under Control.Monad.Monad's Monad
22:42:41 <jle`> or wherever Monad is defined, heh
22:42:45 <bollu> ooh. so "free x" needs to have a pre-structure to enrich?
22:43:21 <jle`> RebindableSyntax means that do notation will desugar to use whatever (>>=) is in scope
22:43:27 <johnw> freeness in this case is structure that arises "for free" from some algebraic signature
22:43:28 <jle`> it doesn't mean that it'll rewrite/recompile existing functions
22:43:36 <johnw> it is also "free" of semantics
22:44:00 <johnw> like, you define what a monoid is, and boom, you get lists
22:44:04 <johnw> you didn't set out to define lists
22:44:07 <johnw> you got that structure fro free
22:44:21 <shane_> jle`: I get it....thanks 
22:44:22 <johnw> it comes with the algebra
22:44:31 <bollu> ah
22:44:38 <bollu> that is a nicer way to look at it, I suppose
22:44:50 <shane_> jle`, cmccann: thanks for everything :)
22:44:55 <bollu> is there any other structure without a "free" version?
22:45:01 <jle`> np!
22:45:04 <johnw> as a functor, if you enrich a set to a monoid, you add this free structure over the existing set
22:45:56 <johnw> bollu: hmm
22:45:59 <cmccann> I don't think there's any such thing as a "free set".
22:46:11 <johnw> well, and functors themselves
22:46:14 <cmccann> for similar reasons
22:46:28 <johnw> the free functor would enrich a functor to become a functor
22:46:42 <bollu> cmccann: a set doesn't have any more structure than cardinality, right? so, well, what is a "free set"? :)
22:46:50 <bollu> and inclusion, ofc
22:46:58 <johnw> a free set would be a structure arising from the mere definition of sets
22:47:27 <johnw> but I think that sets themselves are already that structure
22:47:31 <bollu> yeah
22:47:34 <johnw> ah
22:47:44 <johnw> a free set would be a set you could arrive at by defining some algebra
22:47:45 <jle`> not the structure we deserve.  but the structure we need
22:47:51 <cmccann> heh
22:48:04 <johnw> but since defining an algebra needs a carrier set...
22:48:49 <bollu> maybe you can arrive at a set by starting with a category or something? >_<
22:49:02 <bollu> stupid idea, I don't know
22:49:10 <johnw> not stupid if you try it out
22:49:14 <johnw> even failing in the attempt will be worthwhile
22:49:24 <bollu> :) Time to read category theory and try it out :P
22:49:31 <bollu> awodey is nice!
22:49:32 <johnw> I find category theory beautiful
22:50:01 <cmccann> is there a category whose objects are free functors?
22:50:18 <johnw> cmccann: what are the objects, and what are the morphisms :)
22:50:42 <johnw> identity natural transformations, and natural transformations between free functors
22:51:13 <cmccann> "what morphisms could such a category have" is basically what I was asking, heh
22:51:19 <johnw> is it just a sub-category of the arrow category of Cat?
22:51:35 <mazur> johnw: what about sets and the powerset operation? doesn't that give some kind of free poset category?
22:51:47 <mazur> or lattice more likely
22:51:52 <johnw> mazur: work it out!
22:51:58 <johnw> exercises for everyone
22:52:04 <bollu> mazur: lattice under inclusion
22:52:13 <johnw> bollu: are you a mathematician?
22:52:33 <bollu> johnw: naww, I wish, Just a comp sci student who likes reading math :
22:52:51 <johnw> well, I'd never even heard of a symmetry group, so you're doing OK :)
22:53:35 <bollu> hahaha. Yeah, I try and take some math electives here and there :P
23:18:39 <cmccann> blah, feels like chasing type synonyms to figure out what something really is is almost as bad in GHC as it is in lens
23:18:57 <bollu> Oh yeah, I've been meaning to ask
23:18:59 <cmccann> and seems like half the time it's just a FastString
23:19:09 <bollu> how much haskell does one need to know to contribute to GHC?
23:19:15 <bollu> Could someone as lowly as me help out? :P
23:19:22 <bollu> I'd love the bragging rights ;)
23:19:28 <johnw> I have a way for you to contribute if you only know C
23:19:41 <cmccann> I don't think you need a terrible amount of sophistication in Haskell to work on GHC
23:20:12 <johnw> bollu: there's a file that I need extracted to its own library, with the GHC build changed to depend on this library
23:20:13 <bollu> johnw: yep, I know C
23:20:27 <bollu> ooh
23:20:29 <bollu> sounds fun
23:20:35 <bollu> wait, where do I get GHC sources from?
23:20:39 <johnw> ok, so if you're interested, this is a project several people are interested in
23:20:46 <bollu> yes! definitely
23:21:12 <johnw> git clone git://git.haskell.org/ghc.git
23:21:20 <cmccann> bollu: also, https://ghc.haskell.org/trac/ghc/ if you haven't found that already
23:22:17 <johnw> extract the file rts/Linker.c, and anything else you need for it to compile standalone, and create a separate project that builds that module into a library
23:22:29 <johnw> then, modify GHC to depend on this library, and get GHC working against with it
23:22:34 <johnw> that alone would be more help than you know
23:23:04 <bollu> awesome :) I'll give it a shot
23:23:29 <bollu> um, what's the hoop to jump through to sign up for GHC trac? :)
23:23:36 <johnw> if you can extract the dynamic linker-related tests, such that they can run in the standalone build, that would be like super-awesome
23:23:58 <johnw> I don't remember what needs to be done for that, it should be on the GHC Wiki
23:24:25 <bollu> holy crap I'm soo excited ^_^
23:24:50 <cmccann> bollu: also, I think you said you're a comp sci student? if you're aiming for a career in software development, speaking as someone who's worked in industry for a while I'd consider contributing to GHC to be excellent experience for anyone
23:25:35 <bollu> Yes, I am a comps sci student
23:25:53 <bollu> I've wanted to work on a real compiler for a while - been writing interpreters and stuff on-and-off
23:26:07 <bollu> so I understand the theory (tokenization, parsing, codegen kinda)
23:29:01 <cmccann> I'm more talking in general. contributing to a mature non-toy project with a lot of smart, competent people working on it should, I would hope, look good on a resume to almost anyone.
23:29:08 <bollu> ah, yeah :)
23:29:15 <bollu> does anyone know if homebrew has arcanist?
23:29:20 <cmccann> though sadly I suspect a fair number of people in industry would still dismiss Haskell as "too academic" or whatever :T
23:29:47 <bollu> :) well, there's always that danger :P
23:29:52 <johnw> compsci students have the luxury on working on academic things :)
23:30:00 <johnw> no one need count that against you, I'd hope
23:30:08 <cmccann> yeah
23:30:48 <cmccann> on a random note, I wonder if that type checker bug I filed will ever get fixed
23:31:37 <bollu> oh, I was writing this a while back
23:31:47 <bollu> can someone condense the definition of "fix" ?
23:31:48 <bollu> https://gist.github.com/bollu/bb477116f7d2b39302e6
23:33:46 <cmccann> bollu: I'm very suspicious that you've reinvented at least two functions in the standard library there
23:34:47 <bollu> cmccann: which ones?
23:34:56 <bollu> oh, that
23:35:02 <bollu> I was writing fix to demonstrate to someone
23:35:06 <cmccann> bollu: iterate?
23:35:19 <bollu> cmccann: yep, that too
23:35:28 <bollu> cmccann: I wanted to build fix from the "ground up"
23:35:40 <bollu> he's a math prof at my college who is interested in Haskell
23:35:43 <cmccann> the way you're doing it seems needlessly complicated, though?
23:35:53 <bollu> cmccann: hm. How would you define it?
23:36:36 <cmccann> bollu: if I'm reading that correctly, you want a list made by applying a function to a seed 1 times, 2 times, 3 times, etc., right?
23:36:41 <bollu> yep
23:36:59 <bollu> cmccann: I think you can define it (co?)inductively
23:37:02 <bollu> with the tail trick
23:37:02 <bollu> ?
23:37:03 <cmccann> bollu: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#iterate
23:37:46 <bollu> nice
23:37:55 <cmccann> simple and clear
23:38:12 <bollu> *sigh* writing idiomatic haskell takes practice
23:38:18 <bollu> I dunno, mine is so.. "operational"
23:38:21 <cmccann> now, aside from that, it looks like you're searching the list for two adjacent elements that are equal, right?
23:38:35 <Kristler> bollu: It comes with time :)
23:39:32 * hackagebot nested-routes 5.0.0 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-5.0.0 (athanclark)
23:40:19 <cmccann> bollu: personally I'd probably just write the equality check part with explicit recursion rather than juggling tuples and all that
23:40:26 <cmccann> unless I was trying to be terse for some reason
23:41:04 <bollu> cmccann: eh, the prof wanted to write it "without explicitly recursing"
23:41:14 <cmccann> ha, ok
23:41:24 <cmccann> in that case what you've got is probably reasonable
23:42:36 <cmccann> I can't immediately think of any nicer way to write it using the standard libraries and not using explicit recursion
23:43:40 <bollu> yeah. It would be cool if there was a way to construct "fold with explicit quitting"
23:43:58 <bollu> I know a Traversable would have worked, but that would have added an extra Maybe onto the result
23:44:08 <bollu> extra Either*
23:44:29 <bollu> I tried for a while but couldn't get something nead
23:44:30 <athan> bollu: Like a traverse of Alternative constrained to Maybe?
23:44:31 <bollu> neat*
23:44:35 <bollu> yes
23:44:48 <johnw> a fold with "explicit quitting" is just a foldr where you don't use the "rest" argument, no?
23:44:57 <johnw> this is lazy, so the remainder of the fold won't happen
23:45:00 <athan> foldM can do that! :P
23:45:16 <bollu> athan: like I said, that would add an extra monadic context :)
23:45:19 <bollu> I want to do it "pure"
23:45:32 <bollu> he found "paramorphism" which seemed close
23:45:34 <athan> ohhh okay :)
23:45:55 <cmccann> your function is already partial, adding Maybe or Either is hardly less pure than something which can already fail even worse
23:46:21 <johnw> monads are pure too, that's why we love them
23:47:09 <bollu> cmccann: xD that's fair
23:47:09 <cmccann> and yes, I think a paramorphism is what you'd want if you're after the most cryptic, abstract, and stereotypically "Haskell" way to do it
23:48:08 <cmccann> though I've completely forgotten what all the various recursion schemes mean at this point
23:48:08 <bollu> cmccann: We couldn't find a haskell definition of paramorphism though
23:48:20 <bollu> what are "recursion schemes" ?
23:48:29 <johnw> anamorphism, paramorphism and catamorphism do not relate in the same way that analyze, paralyze, and catalyze do.  Discuss.
23:48:30 <cmccann> bollu: http://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html
23:48:31 <cmccann> have fun
23:48:40 <bollu> the prof came up with this: http://codepad.org/zILorQvl
23:48:40 <athan> I wonder if mzero could just be the accumulator, and (`tensor` accumulator) could be `return`
23:48:59 <bollu> tensor = what, the math outer product tensor? ;_
23:49:27 <bollu> "Generalized bananas, lenses and barbed wire" lolwut?
23:49:30 <athan> bollu: Just the... thing, that does it :|
23:49:35 <athan> yes
23:49:44 <athan> I just read that today actually :)
23:49:49 <bollu> I love you haskell peeps
23:49:58 <bollu> you guys have the silliest names :D
23:50:08 <cmccann> bollu: I think the general consensus is that fancy abstract recursion schemes are a very deep rabbit hole that leads nowhere interesting
23:50:17 <bollu> hmm
23:50:27 <bollu> so stick to the few we have and be happy?..
23:50:58 <athan> bollu: Until you get bored*
23:51:21 <cmccann> that said, the bananas lenses and barbed wire paper is a good read
23:51:41 <cmccann> athan: got a link to it?
23:51:42 <johnw> cata and ana are arguably very good ones to know, and maybe para and hylo
23:51:44 <johnw> but beyond that...
23:51:53 <cmccann> yeah
23:52:01 <athan> cmccann: It was on paper :\ there must be a link
23:52:21 <bollu> *sigh*
23:52:28 <johnw> some people have been very productive with these recursion schemes, but it needs to suit the problem
23:52:31 <bollu> I have webdev to do, and I'm here discussing morphisms :)
23:52:47 <athan> http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf
23:52:49 <cmccann> bollu: http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf
23:52:51 <athan> yayyyuh
23:52:52 <cmccann> whoops
23:52:54 <cmccann> too slow
23:52:56 <johnw> morphisms are where it's at
23:52:59 <athan> >:C
23:53:07 <athan> this is my swamp
23:53:12 <cmccann> anyway
23:53:43 <bollu> I love the fact that I have a folder called "Haskell papers" :P
23:53:46 <athan> johnw: Not where it's going?
23:53:55 <cmccann> bollu: read that paper, then you should understand the library I linked to well enough to be properly confused by it
23:53:58 <athan> :)___)
23:54:04 <bollu> the only other haskell paper I've read is the parser one
23:54:06 <johnw> nah, the destination is meaningless :)
23:54:10 <bollu> success to a list of failures
23:54:12 <bollu> that one was cool
23:54:29 <bollu> Though I disagree with kemett. I think pratt parsers are the most elegant parsers
23:55:05 <bollu> johnw: ghc is cloning BTW
23:55:07 <bollu> it's pretty large
23:55:13 <cmccann> heh
23:55:15 <johnw> yeah, and it will clone submodules too
23:55:35 <johnw> the build will take a while as well
23:55:43 <bollu> johnw: I've never had a super pleasant experience with submodule
23:55:52 <bollu> they break in _weird_ ways, man
23:56:07 <bollu> programs similar in contents but very dissimilar in appearance (like many Australian animals) 
23:56:14 <bollu> this is gonna be a good read :)
23:56:25 <athan> bollu: I.... I stick with the `git ..` enriched commands :|
23:56:52 <cmccann> bollu: here, add this to your folder: http://strictlypositive.org/diff.pdf
23:56:56 <Myrl> Guys, I have an HTML file with Haskell embedded in it; the Haskell code is enclosed in <` and `>. The problem is, I don't know how to write a parser for it, any idea on how to do this?
23:57:12 <cmccann> Myrl: parser for the html, or for the haskell?
23:57:18 <bollu> Myrl: you want to parse HTML or haskell?
23:57:25 <bollu> if HTML, use python (beautifulsoup)
23:57:31 <Myrl> cmccann: To capture the Haskell enclsoed in <` and `>.
23:57:37 <Myrl> So basically, neither.
23:57:40 <bollu> hey, that one I read yesterday! frikkin type calculus
23:57:43 <cmccann> ah
23:57:56 <athan> Myrl: but what if the haskell code uses `>`?
23:57:58 <bollu> who is conor mc bride
23:57:59 <bollu> ?
23:58:02 <Myrl> athan: It can't.
23:58:05 <athan> the man ^
23:58:10 <bollu> he has a lot of weird things named after his papers, right?
23:58:14 <bollu> Myrl: you're conor?
23:58:15 <cmccann> bollu: himself, probably, but don't quote me on that.
23:58:15 <bollu> :O
23:58:16 <Myrl> athan: The only time <` and `> is possible, is when it's inside strings.
23:58:21 <Myrl> bollu: Who's conor?
23:58:31 <athan> Myrl: wh... why? :|
23:58:31 <cmccann> bollu: he's not on IRC afaik if that's what you're asking
23:58:37 <bollu> Myrl: I know him because of the jokers and clowns paper
23:58:39 <Myrl> athan: Because <` and `> will parse error.
23:58:40 <athan> bollu: No no, he's the man
23:58:41 <johnw> he's on twitter
23:58:44 <bollu> ahh. 
23:58:45 <athan> that's who he is :|
23:58:46 <bollu> that way
23:58:48 <bollu> "the man"
23:58:49 <cmccann> he's also on Stack Overflow
23:58:55 <Myrl> athan: I tried it out just to make sure.
23:59:01 <athan> like imagine it in a very ambiguous way
23:59:08 <cmccann> and 90% of the time I can recognize his writing style before I see who posted the answer
23:59:17 <bollu> I want to know enough haskell / cat theory / black magic to understand an Edward Kemett post one day :P
23:59:33 <johnw> bollu: that's an achievable goal
23:59:38 <Myrl> So, guys, how should I plan to go through this?
23:59:38 <athan> bollu: You will :)
23:59:41 <johnw> keeping up with him as he writes new ones, that's harder
23:59:51 <athan> Myrl: haskell-src-exts?
23:59:52 <cmccann> that's easier, just find him on IRC when he isn't doing at least three other things and he'll explain until one of you runs out of time
