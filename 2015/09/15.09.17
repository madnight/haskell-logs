00:07:41 * hackagebot DAV 1.1 - RFC 4918 WebDAV support  https://hackage.haskell.org/package/DAV-1.1 (ClintAdams)
00:07:41 * hackagebot hmatrix-gsl-stats 0.4.1.1 - GSL Statistics interface  https://hackage.haskell.org/package/hmatrix-gsl-stats-0.4.1.1 (VivianMcPhail)
00:12:35 * hackagebot relational-query 0.5.2.0 - Typeful, Modular, Relational, algebraic query engine  https://hackage.haskell.org/package/relational-query-0.5.2.0 (KeiHibino)
00:18:12 <fr33domlover> Hello, anyone tried building gitlib recently? I'm getting this for gitlib 3.1.0.1: http://paste.rel4tion.org/53
00:20:53 <fr33domlover> nvm, I updated the version and it works now
00:20:57 <pacak> >  ';' == ';'
00:20:59 <lambdabot>  False
00:22:19 <fr33domlover> pacak, how did that happen?
00:23:01 <pacak> > ';' == ';'
00:23:03 <lambdabot>  True
00:23:10 <pacak> fr33domlover: it can't decide.
00:23:57 <fr33domlover> pacak, why? I mean, should the result not always be True?
00:24:21 <fr33domlover> >  ';' == ';'
00:24:22 <lambdabot>  False
00:24:30 <fr33domlover> >  '.' == '.'
00:24:32 <lambdabot>  True
00:24:42 <pacak> > map ord ";;"
00:24:44 <lambdabot>  [59,894]
00:25:42 <ThreeOfEight> Greek Question Mark.
00:25:54 <ThreeOfEight> Old trick to annoy C/C++/Java programmers.
00:27:47 <pacak> > let a = 1 ; b = 2 in a + b
00:27:49 <lambdabot>  <hint>:1:15: parse error on input ‘=’
00:28:29 <pacak> ghc is not that happy either.
00:32:40 <fr33domlover> ThreeOfEight, cute, never saw that before
00:57:22 <breadmonster> Hello.
01:01:47 <pacak> breadmonster: o/
01:02:12 <breadmonster> What's up?
01:05:09 <pacak> breadmonster: Forest fires at Sumatra. Do you have any questions about our Lord and Saviour - Haskell?
01:05:33 <breadmonster> Not particularly.
01:10:31 <breadmonster> I wonder if there are any good tutorials on monad transformers.
01:11:33 <montanonic> https://wiki.haskell.org/Meta-tutorial, 2.5 are two tutorials. You be the judge.
01:12:12 <levi> The Wikibook entry on monad transformers isn't bad. I also see 'Monad Transformers Step By Step' recommended often.
01:12:33 <jhrcek> breadmonster: I recently read haskell wikibook, which has nice basic slow paced intro to transformers: https://en.wikibooks.org/wiki/Haskell/Monad_transformers
01:13:03 <ruslantalpa> Is there a nicer way to update a field off a record besides creating a custom function for that.  I don't have the pure value of the field, it's wrapped in a Maybe so i need to use applicative on it somehow. (Thank you)
01:13:20 <breadmonster> @src liftM
01:13:20 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
01:13:32 <breadmonster> Is there a reason why the return isn't strict?
01:13:42 <breadmonster> I've read somewhere that it's a good idea to make it a strict return.
01:13:53 <breadmonster> ie. `return $! f x1`
01:14:34 <levi> ruslantalpa: You can always fmap the record accessor function.
01:15:18 <ruslantalpa> levi: got it, thank you, i'll try that
01:15:26 <ReinH> levi: to update it?
01:15:42 <levi> Oh, sorry, didn't read the question well enough.
01:15:58 <ReinH> something like \x -> fmap (\foo -> foo { thing = x }), or lens
01:17:08 <ruslantalpa> that's even longer then a custom fn, how would lens look?
01:17:37 <levi> If you want short, lens is your friend. Except for the error messages when you make a mistake. :)
01:18:05 <ruslantalpa> ok, i'll go look at lenses for a bit :)
01:18:09 <ruslantalpa> thank you
01:18:55 <levi> My brain is too tired to summon the correct lens incantation for that from memory right now, but I'm fairly sure it's reasonably short.
01:20:24 <ReinH> > Just (1,2) & _Just . _2 .~ "foo"
01:20:26 <lambdabot>  Just (1,"foo")
01:20:57 <breadmonster> levi: Incantation lol
01:21:47 <breadmonster> ReinH: Holy shit it's magic.
01:21:56 <levi> Yeah, it turns out my fuzzy memory was working okay, but it took me a moment to try it out to verify.
01:22:13 <levi> Thus 'incantation' :)
01:23:02 <levi> lens is wonderful for digging into deeply nested data, especially after a bit of practice.
01:26:27 <levi> ruslantalpa: The (_Just . _2 .~ "foo") part is building the setter function; the & just applies the function on the right to the value on the left.
01:28:22 <levi> ruslantalpa: And the (_Just . _2) part is the actual lens, the .~ operator uses the 'setter' part of the lens along with the value on the right to build the setter function to replace the value where the lens is focused.
01:29:29 <ruslantalpa> thank you, but it seems too much complexity for my case (no nesting, just a single record), i guess i'll write the small update function and use applicative on that
01:30:36 <levi> ruslantalpa: The lens library implementation gets hairy in places and it's got a huge surface area in order to maximize its usefulness across a variety of usages, but it's built around a few fairly simple ideas re-combined in various ways.
01:32:20 <ReinH> ruslantalpa: (functor, not applicative)
01:33:03 <ruslantalpa> I get that it's not that complicated but it seems overkill to include a new lib (and modify the record declaration) when i need this only in one place and it's solved by one fn
01:33:04 <ReinH> technically also applicative, but you only need fmap
01:33:54 <ThreeOfEight> It's also a good library to include in winter, because if you compile your project with lens as a dependency, it'll get nice and warm.
01:33:55 <levi> Sure, that's a reasonable call to make. But keep lens in mind for other situations.
01:34:28 <ruslantalpa> ReinH: Not sure exactly what you mean but i rather like the "updateField record <$> maybeField" notation
01:34:48 <levi> ReinH: That reminds me of, 'that's a square, not a rectangle'
01:35:18 <ReinH> <$> is fmap
01:36:58 <ruslantalpa> yes, but when you have more parameters then you need <$> and <*> so i kind of use applicative everywhere even when you only need <$> (fmap), makes it easy to remember
01:37:33 <ruslantalpa> (probably just because i am a beginner :))
01:39:39 <levi> IIRC, you used to have to import <$> from Control.Applicative, even though it only had a Functor constraint.
01:39:59 <ReinH> yep
01:40:32 <ReinH> I just wanted to be clear that you don't need <*>
01:47:28 <montanonic> Was Data.Sequence turned into Data.Traversable?
01:48:13 <montanonic> Some older tutorials make reference of the former but I don't see it in Haskell base
01:49:21 <keko_> there it is, at least https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Sequence.html
01:49:53 <ReinH> No, those are different.
01:50:00 <ReinH> Sequence isn't in base.
01:51:34 <montanonic> well, in any case, it's what I was looking for; thank you keko_ 
02:17:51 <montanonic> I know with other languages the way one implements recursion matters for performance. Haskell is however well-optimized as a functional language, so I was wondering: is foldr' comperable to foldl' with regards to performance?
02:18:20 <montanonic> (People generally never use foldl, the unstrict version, so I opted to only compare the strict instances)
02:19:21 <montanonic> It seems that tail-recursion is quicker in other languages; I guess maybe this is a better question to ask: if Haskell benefits performance-wise from tail-recursion.
02:20:23 <levi> Tail-recursion is not as much of a thing in a non-strict language. It's a complicated topic and tends to bring out differing viewpoints on how one ought to talk about them.
02:22:05 <levi> At the low levels of the ghc implementation, quite a bit of code is generated in a tail-calling manner, but the concept of the stack is a bit different.
02:22:37 <montanonic> levi: okay, I think that gives me enough to know that I probably can just stick to standard recursion and not have to worry about it
02:25:02 <quicksilver> left folds if you are producing an atomic summary value
02:25:07 <levi> The mechanism of evaluating a haskell program follows more of a graph pattern than the typical stack pattern of eagerly-evaluating languages.
02:25:12 <quicksilver> right folds if you want to lazily traverse a list and lazily consume it
02:25:23 <quicksilver> > sum [1..9] -- left fold
02:25:25 <lambdabot>  45
02:25:33 <quicksilver> > map (+1) [1..9] -- right fold
02:25:35 <lambdabot>  [2,3,4,5,6,7,8,9,10]
02:26:44 <levi> Data structures provide a *control flow* mechanism in haskell, as pattern matching on constructors is the basic primitive for forcing evaluation.
02:27:10 <anohigis`> levi:
02:27:17 <anohigis`> Chinese?
02:27:18 <montanonic> quicksilver: thank you for that
02:27:32 <montanonic> quicksilver: that makes sense
02:27:50 <levi> anohigis`: I'm not sure what you're asking, but probably no?
02:28:38 <montanonic> levi: wow, I never thought about pattern matching that way; very cool; Haskell is really frikken' interesting.
02:28:43 <anohigis`> levi: Haskell函数式编程
02:29:05 <anohigis`> levi: sorry nvm. your name appears to be identical to a guy in our Haskell group
02:32:23 <wuwu`> Hello
02:32:25 <levi> anohigis`: I visited China once. But I am not the person you know.
02:33:03 <wuwu`> Hello, I'm wuwu.
02:36:58 <frerich> wuwu`: hi
02:37:28 <anohigis`> levi: alright i'm sorry :)
02:38:35 <anohigisavay> msg NickServ ghost anohigisavay
02:48:45 <ski> montanonic : tail recursion is bulky. guarded recursion can be incremental
03:18:06 <cheater> hello, is there a good library for creating animations, which can do similar stuff that diagrams can?
03:19:34 <cheater> oh, i guess diagrams is getting some sort of animation support. I didn't realize.
03:21:08 <montanonic> cheater: oh cool! good to know; I was just looking at the Diagrams library, looked very interesting
03:21:17 <cheater> can diagrams be used on linux without opengl support?
03:23:39 <cheater> i guess via cairo
03:24:02 <danilo2> Hello guys! :) I've got a question regarding one of the most ugly thing in Haskell. I often face a wall when I'm declaring some type synonyms, because I would like to use the ~ equality symbol to create named type aliases, but we are not allowedd to do so, so we have to manually expand them making the code ugly and cluttered. What I mean, we are not able to write for example: type Foo a = (x ~ Bar a, y ~ Baz x a, z ~ Baw x y) => T z
03:24:32 <danilo2> "Foo a = T (Baw (Bar a) (Baz (Bar a) a))", which is ugly and with bigger examples compeltely unreadable. The question is if there is any solution for this, that I don't know about ?
03:24:57 <cheater> why would you expect ~ to do that?
03:26:27 <cheater> sounds to me like you'd like something similar to @
03:26:47 <cheater> but given the amount of code located in a single type declaration this is just overengineering
03:29:26 <danilo2> cheater, look at this code example:http://lpaste.net/141177 I know it is too big (the Types are not cleaned yet, but I'm not able to create type synonym for the context unless I expand everything
03:30:24 <quchen> That type looks a bit huge.
03:31:34 * frerich is reminded of 'f :: ErrorSource p e b k a c => ...' 
03:31:53 <MasseR> frerich: :D
03:31:53 <danilo2> quchen: I know it, but is it a problem? Every piece of this type has a reason and it is completely logical. If you'll expand lens types you will get bigger ones. Of course we can make type synonyms and it will be smaller, still making the type synonyms is hard a little bit
03:32:18 <frerich> ("No, it won't fix your error but it will greatly help other Haskell programmers you might consult figuring out the cause of the issue")
03:34:02 <quchen> danilo2: It's an enormous type that says "I'm a god function". Using that type signature is completely impossible so you might as well just use whatever type GHC infers.
03:35:36 <danilo2> quchen: That type is a context of an instance and is guaranteed to simplify when use to simple type. In fact when using the wrapped by the instance type you will never be inferred by GHC with type bigger than a single premise. Still this onset answer my question :(
03:35:48 <quicksilver> danilo2: you can declare it in parts, no?
03:36:39 <quicksilver> type BzBr a = Baz (Bar a) a
03:36:42 <danilo2> quicksilver: no, I can't. You are not allowed to declare type synonyms using the "~" equality operator in Haskell. I can declare it in parts but expanding every "~", which makes it really huge, and thats the problem
03:37:20 <quicksilver> then T (Baw  (Bar a) (BzBr a)) is a little better
03:37:43 <cheater> why do you care that it's so big?
03:37:56 <cheater> it doesn't matter
03:38:12 <danilo2> quicksilver: I know it - I'm doing it all the time. Still I would prefer to use something like ~ in type synonyms and the only question I asked was if there is something like that that I dint know about :D
03:38:13 <cheater> it's big, that's fine, it's not like every function in your program is like this
03:38:20 <cheater> you've found an unusual case, that's nice
03:38:36 <cheater> don't invent complicated tools for just one use
03:39:29 <quicksilver> I'm pretty sure ~ isn't an equality operator.
03:40:04 <nshepperd> it might just be me, but 'type Foo a = (x ~ Bar a, y ~ Baz x a, z ~ Baw x y) => T z' seems less readable than the fully expanded
03:40:19 <danilo2> quicksilver: I know, I was asking if there is something allowing to use like equality operator. I don't want to reinvent things, I'm just looking for the most beautiull way to do it :)
03:40:56 <nshepperd> maybe that's just because the names are meaningless though
03:41:16 <quicksilver> but if your basic point is that as we learn new tricks with the type system our abstraction tools always fall behind
03:41:23 <quicksilver> then yes, absolutely
03:41:39 <quicksilver> then we learn better ways of doing it and/or add abstraction tools to the language
03:42:06 <nshepperd> ~ is type equality
03:42:09 <quicksilver> take a look at the type signatures here :
03:42:11 <quicksilver> https://hackage.haskell.org/package/sessions-2008.7.18/docs/Control-Concurrent-Session.html
03:42:15 <nshepperd> it doesn't work in that way though
03:42:20 <quicksilver> nshepperd: but it's a constraint, not an operator
03:42:31 <quicksilver> I'm not just trying to split hairs
03:42:41 <quicksilver> my point is it's not "active" or "constructive"
03:42:50 <quicksilver> it just affects the constraint resolution phase.
03:43:33 <nshepperd> yes, that's why it doesn't work
03:43:57 <nshepperd> 'type BzBr a = Baz (Bar a) a' seems like the most sensible thing here
03:44:56 <nshepperd>  /url 1
03:45:00 <nshepperd> beh
03:45:31 <nshepperd> O_O those type sigs
03:46:50 <bz> reminds me of reflex's sigs
03:47:19 <quicksilver> it was a research project
03:47:37 <quicksilver> but it's an interesting example of "haskell's type class system is capable of this, but we don't know how to manage the abstraction"
03:47:47 <quicksilver> not sure if matthew comes here any more
03:49:15 <ironChicken> anyone up for an HXT question? <http://stackoverflow.com/questions/32597014/hxt-xpickle-deserialising-between-attribute-values-and-value-constructors>
03:49:40 <frerich> When I see the type signatures in Control.Concurrent.Session - http://i.imgur.com/4Kycy.gif
03:50:04 <montanonic> ^hah, yeah
03:52:42 <quicksilver> s/manage the abstraction/find the right abstraction to manage the complexity/;
03:52:54 <quicksilver> 5 minute later I reread my sentence and it made no sense :P
03:54:22 <danilo2> quicksilver, nshepperd : yea, but I think we would need something like that in the future of Haskell. The type system is getting more and more powerful and such types make great sense sometimes. I will release a library for containers in a few days that works really great because of type system tricks and i straigthforward to sue. Still, I have to make magic to make the types simple and understandable
03:55:18 <quicksilver> ironChicken: I think you're using the types wrong
03:55:36 <quicksilver> the pickler things don't 'return' stuff like Property 
03:55:51 <quicksilver> the return type is like an auxiliary thing to the main business of pickling/unpickling
03:56:22 <danilo2> frerich: that was great :D
03:56:51 <quicksilver> but I've never used it :(
03:57:47 <quicksilver> ironChicken: actually the return type should be the name of the 'haskell' type
04:04:03 <quicksilver> ironChicken: you want xpAddFixedAttr "property" "a"
04:04:08 <quicksilver> resp. "b" in the other branch.
04:05:12 <quicksilver> ah no ignore that
04:07:25 <quicksilver> fmap (const A) xpTextAttr "a"
04:10:21 <Rurik> why doesn't x = 5 work in GHC
04:10:52 <Rurik> GHCi
04:10:52 <quicksilver> because GHCi is an interactive environment it's "not like" a haskell fil
04:10:58 <quicksilver> you can use let x = 5
04:11:06 <quicksilver> or you can type declarations into a file and load them
04:11:06 <Rurik> ah, gotcha
04:17:27 <quicksilver> since ironChicken doesn't seem to be here I remembered how to log in to SO and replied there :P
04:17:45 <ironChicken> quicksilver: sorry, i was just looking
04:18:15 <ironChicken> thanks for your answer :-)
04:24:48 <quicksilver> welcome. I hope it's right!
05:02:49 * hackagebot hreader 1.0.0 - Generalization of MonadReader and ReaderT using hset  https://hackage.haskell.org/package/hreader-1.0.0 (AlekseyUymanov)
05:05:08 <indiagreen> have we got an autogrowing vector type?
05:09:44 <ironChicken> quicksilver: trying your suggestion with HXT: it seems that there's no Functor instance for PU
05:11:03 <ironChicken> so when you try and apply (<$) as :: a -> PU b -> PU a
05:11:20 <ironChicken> you get "No instance for (Functor PU) arising from a use of ‘<$’"
05:26:29 <chrzyki> Using Data.Data and getting an Int constructor using gmapQi, is there an easy way to interpret the result (e.g. 255 :: Constr) as an Int?
05:34:56 <quicksilver> ironChicken: oh that's odd
05:36:43 <quicksilver> ironChicken: ah you need xpWrap
05:36:50 <quicksilver> because it needs forward and back arrows
05:37:29 <quicksilver> ironChicken: xpWrap (const A) (const "a")
05:37:56 <quicksilver> xpWrap (const A) (const "a") $ xpTextAttr "a"
05:38:10 <quicksilver> there ought to be a shortcut for xpWrap with consts I'd think
05:56:23 <quchen> indiagreen: Not sure what you mean with that.
05:56:40 <quchen> indiagreen: "Growing" a vector is a mutable thing. Is that what you mean?
05:56:46 <humanoyd> Is there a function that builds a lens out of a record field accessor function?
05:57:12 <fryguybob> cheater: You can use Cairo or the pure Haskell Rasterific backend for raster images.  Animations support is ok, but is still something we want to work on more.
05:57:23 <quicksilver> humanoyd: no, that's not really possible
05:57:40 <quicksilver> humanoyd: there is a TH function which builds it from the type itself though
05:58:03 <quchen> humanoyd: "lens" lets you do something like that: give it a getter and a setter, and you'll get a lens.
05:58:08 <quchen> http://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Lens.html#v:lens
05:58:49 <quchen> indiagreen: Pure vectors have something in the opposite direction: free shrinking.
05:59:09 <indiagreen> quchen: not necessarily a mutable thing (it might be happening behind the scenes). Autogrowing means that when I try to assign a value to an out-of-bounds element, the vector grows to accomodate it; my usecase is basically “I need an IntMap but I know in advance that it won't have any gaps so I'd like it to be faster”
05:59:25 <indiagreen> of course, mutable will do too
05:59:45 <quicksilver> you first mistake is thinking that Vector is faster than IntMap
06:00:05 <humanoyd> quicksilver: do you know what that function is called?
06:00:11 <quicksilver> humanoyd: makeLenses
06:00:13 <humanoyd> quchen: Thanks, will look into that
06:00:26 <quicksilver> humanoyd: data MyType = { ...} ; makeLenses ''MyType
06:00:30 <humanoyd> quicksilver: doesnt that require "_" in front of the name?
06:00:41 <quicksilver> humanoyd: yes it does in its default configuration
06:00:45 <quicksilver> you can customise that if you wish
06:00:48 <indiagreen> quicksilver: (unfortunately) for me it seems to be faster
06:01:08 <humanoyd> quicksilver: ah, okay, didn't know that, thx
06:01:42 <indiagreen> at least in my scenario (lots and lots and lots of mutation, only one copy of vector exists at any given time)
06:04:00 <bz> oh cool sandboxes are relocatable now
06:06:19 <quicksilver> indiagreen: *nod*. No, I don't think anyone's written an autogrowing MVector for that kind of use case
06:06:25 <cheater> fryguybob: could i msg you?
06:06:42 <quicksilver> or I should rephrase that. I imagine 10s or 100s of people have. But i don't think it's in the main lib.
06:06:57 <quicksilver> just set a scale factor and remember to grow exponentially!
06:07:07 * quicksilver is sure he's written that code at leasr once.
06:07:52 * hackagebot json-state 0.1.0.0 - Keep program state in JSON files.  https://hackage.haskell.org/package/json-state-0.1.0.0 (akrasner)
06:07:54 * hackagebot smsaero 0.3 - SMSAero API and HTTP client based on servant library.  https://hackage.haskell.org/package/smsaero-0.3 (NickolayKudasov)
06:09:42 <fryguybob> cheater: Sure, there is also the #diagrams channel
06:10:00 <cheater> let me go there then
06:10:14 <jkaye> Banging my head against a wall here. I've recently upgraded my version of cabal to 1.22.4. I haven't used cabal in a long time, so my packages list is quite old. When I try to install something, I get a warning about the package list being over 300 days out of date. Then, when trying to cabal update, it tells me  Skipping download: Local and remote files match.
06:10:33 <jkaye> However, the versions that it knows about locally are not the latest versions (or even close)
06:10:55 <jkaye> Is there a way for me to blow away everything cabal knows about and start fresh? I've already tried reinstalling and removing .cabal
06:11:00 <Intolerable> does cabal --version say what you think it should?
06:11:09 <clrnd> jkaye, probaly cabal installe ditself somewhere not in your PATH
06:11:16 <jkaye> Here is the output
06:11:16 <jkaye> cabal-install version 1.22.6.0
06:11:16 <jkaye> using version 1.22.4.0 of the Cabal library
06:11:22 <clrnd> ok lol
06:12:11 <geekosaur> [17 13:10] <jkaye> Is there a way for me to blow away everything cabal knows about and start fresh? I've already tried reinstalling and removing .cabal
06:12:15 <geekosaur> you need to remove ~/.ghc
06:12:36 <geekosaur> you re3moved everything *cabal* knew about. nothing that *ghc* knows about
06:12:52 <geekosaur> (well, probably blew half of it away leaving a bunch of broken ghc package entries)
06:12:53 * hackagebot postgresql-query 2.1.0 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  https://hackage.haskell.org/package/postgresql-query-2.1.0 (AlekseyUymanov)
06:12:54 <jkaye> geekosaur: Looks like that did it! Thank you very much
06:13:08 <jkaye> I guess I don't really understand the interact between cabal and ghc
06:13:19 <jkaye> I was assuming they were not so related
06:13:20 <geekosaur> cabal installs stuff for ghc
06:13:36 <geekosaur> (or possibly other compilers although currently only ghc is relevant)
06:13:52 <geekosaur> but the end result is that ghc has new packages registered within it
06:14:08 <jkaye> I see
06:14:11 <geekosaur> just as pip is not python
06:14:28 <geekosaur> but a program that adds packages to a python installation
06:14:50 <geekosaur> if you remove pip, any installed python libraries are still there
06:15:38 <jkaye> That all makes sense. I'm still a bit confused about what was sticking aroung in that .ghc directory to cause cabal to be unable to update at all?
06:16:38 <geekosaur> package entries pointing to packages that you had removed, so cabal was asking ghc-pkg about installed packages and getting a list back and then breaking when it tried to use them
06:17:37 <geekosaur> because the actual library files are installed under ~/.cabal (because ~/.ghc belongs to ghc) but the package database is under ~/.ghc. (and cabal uses ghc-pkg to read or modify that package database)
06:17:51 <jkaye> Ahh okay
06:17:53 * hackagebot settings 0.2.0.0 - Runtime-editable program settings.  https://hackage.haskell.org/package/settings-0.2.0.0 (akrasner)
06:26:10 <jkaye> Thanks everyone. Everything is working properly!
06:33:39 <fjordrunner> please, can anybody help me with following? I'm trying to use persist.sqlite to IO my DB,..but in all tutorials is that first I have to migrate and insert data. Only after that I can do the select. But what if I want to do only select over existing data?
06:39:57 <meretrix> I'm getting a large space leak from repeatedly updating State using lens. Where is the appropriate place to add strictness?
06:40:00 <meretrix> Example:
06:40:20 <quchen> Waaaait.
06:40:21 <meretrix> cache . ix akey %= (take 100 . (newValue :))
06:40:22 <chpatrick> are class instances not exported from other-modules?
06:40:35 <quchen> If it's a longer paste please don't paste it here.
06:40:39 <phadej> chpatrick: they are re-exported automatically
06:40:39 <quchen> ?paste
06:40:40 <lambdabot> Haskell pastebin: http://lpaste.net/
06:40:46 <meretrix> That's it.. one line
06:40:49 <chpatrick> phadej: I'm not seeing them in the haddock though
06:41:00 <chpatrick> I have some instances defined in Foo.Internal.Bar
06:41:02 <quchen> meretrix: Oh, sorry then. When I see "Example:" my alarm bells start ringing :-)
06:41:06 <chpatrick> and the type is re-exported from Foo.Bar
06:41:09 <geekosaur> that's a haddock shortcoming, I think
06:41:13 <meretrix> quchen: Fair enough :)
06:41:19 <chpatrick> but haddock doesn't list those instances
06:41:38 <phadej> chpatrick: what haddock shows for Foo.Internal.Bar
06:41:49 <geekosaur> we've seen other examples recently where haddock did not list instances that are known to exist (and work in ghc)
06:41:52 <quchen> meretrix: Where are you using state repeatedly? I looks like like you're just doing a single assignment.
06:42:10 <meretrix> quchen: Yes, but I'm calling that statement every 100ms
06:42:23 <quchen> Looks like you're modelling a queue.
06:42:24 <meretrix> So I end up eating memory over time
06:42:37 <chpatrick> wait that's weird
06:42:44 <chpatrick> it does show it for some other types
06:42:47 <phadej> chpatrick: and to clarify, haddock shows some instances, but not the ones defined in Foo.Internal.Bar?
06:42:52 <geekosaur> yep, that was part of it
06:43:05 <chpatrick> yes
06:43:09 <phadej> chpatrick: try to re-export the typeclass from the "public" module too
06:43:11 <phadej> or import it.
06:43:15 <chpatrick> how do I do that?
06:43:16 <geekosaur> this came up with CDouble the other day
06:43:18 <phadej> *just
06:43:19 <chpatrick> I mean it's Eq
06:43:43 <phadej> You don't omit Prelude?
06:43:45 <geekosaur> the instance exists and is exported but haddock didn't list it; other instances, it did list properly
06:43:52 <meretrix> quchen: Yes, it's a cache of recent values measured with 100 snapshots.
06:43:57 <chpatrick> yeah
06:43:59 <chpatrick> haddock bug?
06:44:04 <KaneTW> meretrix: i think when you do take 100 without evaluating the last thunk in those 100 elements you get a leak
06:44:04 <geekosaur> seems like, yes
06:44:15 <quchen> meretrix: A ring buffer might be a better solution for your needs. But let's think about why this leaks anyway. :-)
06:44:27 <geekosaur> lemme check log, I think someone pointed to a bug report even
06:44:37 <meretrix> Yes, agreed, there are better data structures to use.
06:44:38 <quchen> Are you ever forcing the buffer? I could imagine the "take N" to be a thunk that's not evaluated enough to find out that old elements are kicked out.
06:45:05 <KaneTW> since when you don't seq anything the cons cell for newValue points to the old list, which is then never gc'd
06:45:23 <quchen> meretrix: A simple better N-element buffer might be Data.Seq from containers, which allows you to push and pop from both ends.
06:45:47 <quchen> The repeated takes are probably very inefficient by themselves.
06:45:47 <geekosaur> https://github.com/haskell/haddock/issues/444
06:46:04 <quchen> meretrix: Imagine you run your action 50 times, that gives you a chain of 50 nested takes.
06:46:07 <geekosaur> which is a dup of https://github.com/haskell/haddock/issues/372
06:46:23 <quchen> The performance of that is 50*take 100, which is probably abysmal.
06:46:27 <KaneTW> that too
06:46:53 <quchen> meretrix: You see I'm venturing away from solving the leak to avoiding it in the first place by using another data structure. Hopefully.
06:46:57 <suppi_> how do I do automated testing in Haskell? do I use cabal install?
06:47:02 <quchen> I'm doing that because I'm clueless ;-)
06:47:04 <suppi_> cabal test*
06:47:19 <KaneTW> quchen: well it's not the wrong decision
06:47:28 <geekosaur> (whihc in turn suggests that it's something going wrong in ghc-api...)
06:47:28 <KaneTW> because doing a deepseq every time you do a take 100 is a lot of useless work
06:47:50 <quchen> KaneTW: You don't need to deepseq, forcing the spine would be enough. But also too much work.
06:47:58 <quchen> Lists are not the right data structure for this kind of work.
06:48:38 <athan> suppi_: Yep, usually you've got to `cabal install --enable-tests` beforehand, too
06:48:48 <KaneTW> as long the take gets evaluated it should work but yeah
06:49:17 <suppi_> athan, is there a guide to explain how to do that? how to write tests and how to make them work?
06:49:28 <athan> suppi_: I
06:49:33 <athan> I'm not sure, but it's pretty easy
06:49:43 <suppi_> definitely not easy
06:49:55 <athan> suppi_: Check out my template for a quick tasty suite - https://github.com/athanclark/hi-quickcheck-lib
06:50:04 <KaneTW> also stack
06:50:20 <athan> You just need to setup a `Main` module for your test suite, and include your modules
06:50:39 <athan> KaneTW: Yeah, I need to add my templates to their collection >.>
06:51:09 <quchen> meretrix: Another thing you could use is a simple Map Int Payload. Deleting the minimum is fast, adding a new element to the end as well.
06:51:19 <quchen> But Data.Seq is probably more suitable.
06:51:35 <quchen> My next step after that would be using mutable structures.
06:51:36 <athan> Cale: ^ hmm....
06:51:37 <suppi_> athan, so I should use tasty?
06:51:50 <athan> suppi_: I prefer it - it seems to have the best support
06:52:02 <suppi_> athan, I was trying to use hunit but I keep getting false successes
06:52:07 <athan> you can include HUnit, HSpec, QuickCheck, SmallCheck, etc.
06:52:23 <KaneTW> quchen: if you do Map Int you might as well do an IntMap
06:52:25 <athan> suppi_: o_o not sure about that
06:52:37 <Intolerable> doesn't hspec work with everything?
06:53:08 <suppi_> athan, I will try again using tasty. thanks
06:54:29 <athan> np :)
06:57:01 <Mh___> how can I use this type 
06:57:03 <Mh___> newtype Handler = Handler { runHandler :: Event -> IO Handler }
06:57:53 <Intolerable> how do you mean?
06:58:08 <Mh___> How can I define my own handlers
06:58:09 <athan> Mh___: skillz
06:58:13 <athan> :P
06:58:41 <athan> Mh___: If you already have a `foo :: Event -> IO Handler`, just put a `Handler foo` around it
06:58:41 <Intolerable> it's a type that takes an Event, does something (in IO), then returns a new Handler that can then do something with another event (ad infinitum)
06:59:25 <Mh___> Intolerable: I understand this, but if I have  Events I want every event to have it's own handler, how can I define this ?
06:59:49 <meretrix> quchen: Thanks, I'll check out Seq. I'm still curious how to solve the leak with a basic list.  Do you think I would need to modify the lens function or just add some well placed "$!"?
07:00:51 <Mh___> Intolerable: In non-pure languages  I would build a dictionary of handlers for every events .. 
07:01:02 <Intolerable> Mh___: you can probably combine handlers in some way
07:01:10 <Intolerable> where's Handler defined?
07:01:17 <Intolerable> or is it something you've built?
07:01:20 <quchen> meretrix: Try forcing the spine via `forceSpine xs = foldr seq xs xs`
07:01:20 <athan> Maybe `Map Event (IO Handler)` ?
07:01:43 <quchen> meretrix: Around the "take", that is
07:01:56 <Intolerable> you can also just keep a list of Handlers, attach filters to each one, and then feed each Event to every Handler
07:02:34 <quchen> meretrix: Wait, that forces more than just the spine. Do it anyway. :>
07:02:35 <linus__> Hey guys! I'm working through UPenn's cis194 course, but I'm getting kind of stuck on the last exercise of the 4th homework assignment. I'm supposed to implement a Differentiable typeclass, but I can't seem to get the types right.. See http://pastebin.com/fZWvFDML
07:04:53 <Mh___> Intolerable: they are custom functions/actions
07:05:27 <opqdonut> linus__: what's the error?
07:05:39 <linus__>     Couldn't match type ‘a1’ with ‘b’
07:05:39 <linus__>       ‘a1’ is a rigid type variable bound by
07:05:39 <linus__>            the type signature for go :: Enum b => [a1] -> [b] at HW04.hs:98:19
07:05:39 <linus__>       ‘b’ is a rigid type variable bound by
07:05:39 <linus__>           the type signature for go :: Enum b => [a1] -> [b] at HW04.hs:98:19
07:05:42 <linus__>     Expected type: [b]
07:05:44 <linus__>       Actual type: [a1]
07:05:47 <linus__>     Relevant bindings include
07:05:49 <linus__>       as :: [a1] (bound at HW04.hs:100:19)
07:05:52 <linus__>       a :: a1 (bound at HW04.hs:100:17)
07:05:54 <linus__>       go :: [a1] -> [b] (bound at HW04.hs:99:13)
07:05:57 <linus__>     In the expression: map multTup $ zip as [1 .. ]
07:05:59 <linus__>     In an equation for ‘go’: go (a : as) = map multTup $ zip as [1 .. ]
07:05:59 <geekosaur> don't paste into the channel
07:06:02 <linus__>     In an equation for ‘deriv’:
07:06:04 <linus__>         deriv p1
07:06:07 <linus__>           = P $ go (getList p1)
07:06:09 <linus__>           where
07:06:10 --- mode: ChanServ set +o geekosaur
07:06:12 <linus__>               go :: Enum b => [a] -> [b]
07:06:14 <linus__>               go [] = []
07:06:17 <linus__>               go (a : as) = map multTup $ zip as [1 .. ]
07:06:18 --- kick: linus__ was kicked by geekosaur (linus__)
07:06:50 --- mode: geekosaur set -o geekosaur
07:07:42 <meretrix> quchen: hmm.. still eating memory.  Maybe it's because the "newValue" I'm adding to the list is actually a Map lookup..
07:08:38 <geekosaur> ...they quit
07:09:44 <opqdonut> geekosaur: hmph
07:09:47 <opqdonut> oh well
07:09:59 <geekosaur> oh there you are
07:10:05 <geekosaur> please don't paste directly into the channel
07:10:08 <geekosaur> @paste
07:10:08 <lambdabot> Haskell pastebin: http://lpaste.net/
07:10:13 <geekosaur> ^ pastebin
07:10:23 <linus__> I'm sorry, it won't happen again :(
07:10:30 <geekosaur> (I always immediately /invite back after a flood kick)
07:10:46 <geekosaur> (and /msg but they were gone by then)
07:10:49 <opqdonut> linus__: so first of all the Enum b => line is unnecessary
07:10:54 <linus__> Ah, alright. I'm not very experienced with irc, so I probably missed that
07:11:08 <fabian___> In a ExceptT () (StateT S IO) B monad, how do I run a ExceptT () Identity () action? 
07:11:10 <opqdonut> linus__: but the true error message does complain about a missing Enum instance, and I'm not sure why that is
07:11:17 <athan> hm. Should I be skeptical when writing a monoid instance for some `[Foo a]`? Wouldn't this overlap?
07:11:29 <opqdonut> athan: yes, it will overlap with the [a] instance
07:11:35 <opqdonut> athan: I recommend a newtype
07:11:37 <athan> poo
07:11:41 <athan> thanks opqdonut
07:12:32 <opqdonut> linus__: ah, type a needs to have Enum in order for [1..] to work
07:12:52 <opqdonut> linus__: you could work around this with something like (map fromIntegral [1..])
07:12:55 * hackagebot protocol-buffers 2.1.7 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.1.7 (k_bx)
07:12:57 * hackagebot protocol-buffers-descriptor 2.1.7 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.7 (k_bx)
07:12:59 * hackagebot hprotoc 2.1.7 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.1.7 (k_bx)
07:12:59 <linus__> Ah, but I'd like to avoid that, as my Poly type should be more flexible than that
07:13:01 * hackagebot plotfont 0.1.0.1 - Plotter-like fonts i.e. a series of straight lines which make letter shapes.  https://hackage.haskell.org/package/plotfont-0.1.0.1 (mjoldfield)
07:13:02 <linus__> ah!
07:13:03 <OutlawStar> so I need some help understanding some GC stuff. I have a socket that I create which I then read from using conduits, Eventually reading from the conduit get sent to a separate thread. When it goes to the separate thread, within seconds the conduit fails because it can't read socket. I fairly certain my socket is being GC'd, since if I add an explicit reference to the socket in the other thread, things work fine. Any ideas, can show 
07:13:04 <OutlawStar> code.
07:13:20 <opqdonut> linus__: or you could just use an explicit counter argument in go
07:13:31 <opqdonut> linus__: (and make go recursive)
07:13:33 <suppi_> athan, would you mind taking a look at this? http://lpaste.net/2727817919638536192
07:13:42 <geekosaur> I think we'd need to see code. also, is this Windows and if so what version of the network package?
07:13:57 <opqdonut> linus__: also, "map f $ zip as bs" is better written as "zipWith f as bs"
07:14:11 <OutlawStar> line 101 is were i fork: https://github.com/jm4games/lightstreamer/blob/master/src/Lightstreamer/Http.hs 
07:14:17 <linus__> ah, yes, that makes sense!
07:14:22 <OutlawStar> that class has most of the code u will need
07:14:25 <opqdonut> linus__: but in "zipWith f as bs", f needs to take two arguments (instead of a tuple)
07:15:22 <OutlawStar> geekosaur: network pkg 2.6.2.1
07:16:13 <OutlawStar> on line 101, if i were to add a try catch around that conduit piece and say print the socket state in err scenario, the socket seems to stay alive.
07:20:46 <geekosaur> OutlawStar, socketConnection does lazy I/O. "sock" is invalid afterward; the socket is being managed internally at that point
07:21:37 <suppi> can anyone help me with unit testing? http://lpaste.net/2727817919638536192
07:21:43 <suppi> I'm getting false successes
07:21:44 <geekosaur> you shouldn't pass it around, close it, etc.; just drop it on the floor (in newHttpConnection)
07:22:11 <OutlawStar> geekosaur: i can't close it can i, i'm streaming from it?
07:22:26 <geekosaur> you must not close it
07:22:31 <geekosaur> you also must not do *anything else* with it
07:22:55 <OutlawStar> geekosaur: oh, but whey then does it get GC'd? 
07:23:03 <OutlawStar> and only when i keep ref that it doesn't
07:24:04 * quicksilver would not recommend interleaved IO with network connections
07:24:09 <geekosaur> you should not be reading fromt he socket. you have a lazy ByteString from socketConnection
07:24:13 <quicksilver> well I wouldn't recommend it for anything, ever.
07:24:25 <quicksilver> but network connections are argubaly even worse than files on disk.
07:24:29 <geekosaur> that has a "secret" copy of the socket, and if the conduit is also trying to use the socket then yes, things will fail badly
07:24:42 <OutlawStar> quicksilver, its not interleaved, it starts on one thread and finishes on other. Completed controlled
07:24:47 <geekosaur> it is interleaved
07:25:05 <geekosaur> not by something you are doing except insofar as you use socketConnection
07:25:13 <geekosaur> which uses a bit of evil called unsafeInterleaveIO
07:25:23 <geekosaur> once that happens, *you must not touch the socket at all*
07:25:24 <linus__> opqdonut, I got it :)  "go (_:as) = zipWith (curry multTup) as (map fromInteger [1..])" did the trick!
07:25:37 <opqdonut> linus__: yeah
07:26:01 <opqdonut> linus__: and now you can simplify it further as "go (_:as) = zipWith (*) as (map fromInteger [1..])" :)
07:26:01 <athan> Hey guys, why isn't the default monoid / semigroup instance for Data.Map something like `(<>) = Map.unionWith (<>)`?
07:26:08 <geekosaur> don't give it to conduit, don't do anything with it, forget it exists. the lazy ByteString (HandleStream) *is* the "socket" form that point on
07:26:16 <OutlawStar> geekosoar: ah ok, so I guess conduit will handle streamw will clean up?
07:26:21 <OutlawStar> k good
07:26:23 <opqdonut> athan: because that only works when the value type is Data.Map
07:26:37 <athan> ?
07:26:44 <opqdonut> gah
07:26:49 <opqdonut> ... is Monoid
07:26:54 <athan> opqdonut: How? It would just be `Monoid a => Monoid (Map k a)`
07:26:56 <linus__> opqdonut, haha, yes, you're right!
07:27:03 <athan> well yeah
07:27:05 <OutlawStar> geekosaur: just for ref, this is the exact error: invalid argument (Bad file descriptor)
07:27:06 <athan> but it's more correct
07:27:09 <athan> and is more general
07:27:18 <athan> we could have a newtype `FirstMap` like First for Maybe
07:27:27 <opqdonut> athan: yeah and there are other Monoid a => Monoid (Something a) instances too
07:27:30 <opqdonut> athan: so you have a good point
07:27:35 <Intolerable> there are so many Monoid Map instances
07:27:58 <athan> good point Intolerable
07:28:07 <geekosaur> in fact you have a real problem here because youre trying to use the socket for send and receive (this is sensible) *but* whyen you use socketConnection to get a HandleStream, *you can't send*
07:28:12 <opqdonut> there's only like 3 I think
07:28:16 <geekosaur> which may be the source of your error
07:28:19 <opqdonut> (prefer left, prefer right, combine)
07:28:36 <athan> union, intersection, symmetric difference actually
07:28:45 <athan> as far as *With functions go :x
07:28:52 <geekosaur> you need to rethink this. if you're using conduit, you probably do not want to use HandleStream (lazy I/O) at all; conduit replaces that
07:28:59 <opqdonut> hmm ok
07:29:00 <athan> wait
07:29:02 <athan> not intersection
07:29:09 <athan> there's no total element
07:29:10 <opqdonut> yeah identity is hard
07:29:10 <nshepperd> map intersection doesn't have a legal unit
07:29:16 <OutlawStar> geekosaur: what should i be using instead?
07:29:25 <opqdonut> so it's {union,symmetric difference}x{left,right,combine}
07:29:35 <athan> yep!
07:29:43 <athan> we could use newtypes for left & right, though
07:29:48 <athan> egad...
07:29:55 <opqdonut> that would make sense
07:29:56 <opqdonut> just like Endo
07:30:00 <opqdonut> and friends
07:30:20 <Intolerable> where's my Applicative Map variant
07:30:21 <opqdonut> and I don't think anyone actually wants the symmetric difference instance :P
07:30:36 <opqdonut> or if they do they can make their own newtype
07:31:00 <geekosaur> OutlawStar, http://hackage.haskell.org/package/http-conduit is likely what you are after, unless you need to reimplement that for some reason
07:31:19 <geekosaur> in which case you may want to inspect the source to http-conduit to see how to do it
07:31:24 <athan> Is there a Const newtype? s.t. `getConst $ Const x <> Const y` = y? :\
07:31:25 <Intolerable> isnt it http-client now unless you need the conduit stuff?
07:31:26 <OutlawStar> geekosaur: I looked at that, and unless I missed something. I can't handle individual chunks
07:31:33 <athan> and CoConst or something?
07:31:34 <Intolerable> athan yes
07:31:34 <nshepperd> I think symmetric difference might not actually work as a monoid either
07:31:35 <Intolerable> somewhere
07:31:46 <athan> Intolerable: I'll get my shovel :)
07:31:49 <nshepperd> it's not associative
07:31:58 <athan> nshepperd: How isn't it?
07:32:09 <athan> oh!
07:32:35 <Intolerable> athan Control.Applicative?
07:32:37 <athan> wait, no it should be, shouldn't it?
07:32:50 <Intolerable> oh no that's not it
07:32:51 <Intolerable> derp
07:32:56 <athan> :O
07:32:56 <nshepperd> if key k exist in three maps (x <> y) <> z must choose the value from z, while x <> (y <> z) takes the value from x
07:33:18 <OutlawStar> geekosaur: initially I was basing alot of my code of of HTTP-4000, which is where i got the handlestream stuff
07:33:26 <geekosaur> OutlawStar, if you need chunks then I'm not sure you should be using conduit at all... conduit is about streams.
07:33:27 <nshepperd> because (x <> y) and (y <> z) have the key k removed
07:33:36 <Intolerable> athan it's Last, no?
07:33:40 <athan> well, it's really `x <> y` = `x union y - x intersect y`, right?
07:33:50 <geekosaur> you could do a stream of chunks I guess, but you probably get to design that one yourself with conduit primitives
07:33:50 <athan> Intolerable: That's for Maybe types
07:34:03 <athan> I think you got it right in Control.Applicative :)
07:34:18 <athan> Wait nvm
07:34:18 <Intolerable> do you want Const x <> Const y = Const y?
07:34:20 <OutlawStar> geekosaur: I thought i did have a stream of chunks right now, thats atleast what i am going for.
07:34:25 <geekosaur> thing is, conduit and lazy I/O are teo approaches to the same problem and therefore will conflict with each other
07:34:25 <athan> not the right semantics I'm thinking
07:34:29 <geekosaur> *two approaches
07:34:55 <Intolerable> athan: Last from semigroups, not from base
07:34:58 <geekosaur> well, no, because lazy I/O also gives you a stream, not really chunks
07:35:01 <Intolerable> :t Last
07:35:02 <lambdabot> Maybe a -> Last a
07:35:16 <Intolerable> @import Data.Semigroup
07:35:16 <lambdabot> Unknown command, try @list
07:35:18 <nshepperd> same reason symmetric difference doesn't work as a monoid for 'Maybe a'
07:35:19 <geekosaur> hGetBufNonBlocking would be for chunks
07:35:21 <Intolerable> @let import Data.Semigroup
07:35:22 <lambdabot>  Defined.
07:35:31 <OutlawStar> geekosaur: Ok, i guess that big thing that i was missing was that HandleStream was lazy IO
07:35:34 <geekosaur> (and is the sort of thiung you would use with conduit)
07:35:35 <Intolerable> :t Data.Semigroup.Last
07:35:36 <lambdabot> a -> Data.Semigroup.Last a
07:35:43 <athan> :O
07:35:47 <athan> thanks Intolerable
07:35:54 <Intolerable> > Data.Semigroup.Last 5 <> Data.Semigroup.Last 4
07:35:56 <lambdabot>      Ambiguous occurrence ‘<>’
07:35:56 <lambdabot>      It could refer to either ‘Data.Monoid.<>’,
07:35:56 <lambdabot>                               imported from ‘Data.Monoid’ at /tmp/mueval17345...
07:36:00 <Intolerable> blegh
07:36:04 <clrnd> wth you can import now!
07:36:09 <Intolerable> > Data.Semigroup.Last 5 Data.Semigroup.<> Data.Semigroup.Last 4
07:36:11 <lambdabot>  Last {getLast = 4}
07:36:13 <OutlawStar> geekosaur: I look into the http-conduit package instead then. You have been alot of help, thanks. Still new at this :)
07:36:27 <Intolerable> clrnd: only some things
07:36:34 <Intolerable> @let import Data.Text as Text
07:36:35 <lambdabot>  .L.hs:154:11:
07:36:35 <lambdabot>      Ambiguous occurrence ‘foldl’
07:36:35 <lambdabot>      It could refer to either ‘Data.List.foldl’,
07:36:42 <Intolerable> @let import Data.Text
07:36:43 <lambdabot>  .L.hs:154:11:
07:36:43 <lambdabot>      Ambiguous occurrence ‘foldl’
07:36:43 <lambdabot>      It could refer to either ‘Data.List.foldl’,
07:36:45 <Intolerable> wat
07:36:54 <clrnd> @let import qualified Data.Csv as Csv
07:36:54 <lambdabot>  .L.hs:76:1:
07:36:54 <lambdabot>      Failed to load interface for ‘Data.Csv’
07:36:54 <lambdabot>      Use -v to see a list of the files searched for.
07:37:05 <Intolerable> it doesn't have everything, either
07:37:25 <clrnd> @let import Lambdabot.IRC
07:37:26 <lambdabot>  .L.hs:124:1:
07:37:27 <lambdabot>      Lambdabot.IRC: Can't be safely imported!
07:37:27 <lambdabot>      The module itself isn't safe.
07:37:30 <clrnd> je
07:37:37 <Intolerable> "has to be safe" is one of the restrictions
07:38:05 <jgertm> ive written a custom monad by composing transformers and wrapping it in a newtype. base is IO, and every transformer (so far only ResourceT and AWST) implements derivation of MonadBaseControl. however, ghc fails to derive an instance. example: newtype Stack a = Stack { popPop :: AWST (ResourceT IO) a }. error message reports that derivation is impossible due to the typeclass having associated types. do i
07:38:07 <jgertm> need to enable some extension? i dont understand why its not working. any help is much appreciated
07:38:59 <Xnuk> @let import qualified Data.Text as ByteString
07:38:59 <lambdabot>  .L.hs:113:1:
07:39:00 <lambdabot>      Data.Text: Can't be safely imported!
07:39:00 <lambdabot>      The package (text-1.2.1.3) the module resides in isn't trusted.
07:39:45 <Xnuk> @let import Prelude hiding (map, filter)
07:39:46 <lambdabot>  Defined.
07:40:18 <Xnuk> >> map (+1) [1..5]
07:40:23 <Xnuk> > map (+1) [1..5]
07:40:25 <lambdabot>  [2,3,4,5,6]
07:40:42 <geekosaur> Prelude is already imported so I doubt that actually did anything
07:44:06 <Xnuk> @let import Data.List hiding (map, filter)
07:44:07 <lambdabot>  Defined.
07:44:20 <Xnuk> > map (+1) [2..4]
07:44:21 <lambdabot>  [3,4,5]
07:46:42 <clrnd> @let map a b = reverse b
07:46:43 <lambdabot>  Defined.
07:47:25 <chpatrick> > map id [ 5,4..1]
07:47:26 <lambdabot>      Ambiguous occurrence ‘map’
07:47:26 <lambdabot>      It could refer to either ‘L.map’,
07:47:26 <lambdabot>                               defined at /tmp/mueval17345751981973594324.hs:1...
07:47:45 <chpatrick> > L.map id [ 5,4..1]
07:47:47 <lambdabot>  [1,2,3,4,5]
07:48:23 <clrnd> > L.map succ [1..5]
07:48:24 <lambdabot>      Could not deduce (Enum a0) arising from a use of ‘succ’
07:48:24 <lambdabot>      from the context (Enum a, Num a)
07:48:24 <lambdabot>        bound by the inferred type of it :: (Enum a, Num a) => [a]
07:49:37 <athan> > L.map succ ([1..5] :: [Int])
07:49:39 <lambdabot>      No instance for (Enum a0) arising from a use of ‘succ’
07:49:39 <lambdabot>      The type variable ‘a0’ is ambiguous
07:49:39 <lambdabot>      Note: there are several potential instances:
07:49:50 <athan> :U
07:50:35 <clrnd> at
07:50:37 <clrnd> w
07:50:51 <UberLambda> > "Does prefixing code with" ++ "> this evaluate it?"
07:50:53 <lambdabot>  "Does prefixing code with> this evaluate it?"
07:50:59 <UberLambda> ok seems like so :P
07:51:07 * geekosaur imagines it can't type the unused parameter
07:51:16 <clrnd> > L.map (*7) [1..5]
07:51:18 <lambdabot>  [5,4,3,2,1]
07:52:07 <Intolerable> > newtype S = S String
07:52:08 <jameseb> :t L.map
07:52:09 <lambdabot>  <hint>:1:1: parse error on input ‘newtype’
07:52:09 <lambdabot> t -> [a] -> [a]
07:52:15 <Intolerable> @let newtype S = S String
07:52:16 <lambdabot>  Defined.
07:52:18 <geekosaur> heh
07:52:25 <Intolerable> @let instance Show S where show = id
07:52:26 <lambdabot>  .L.hs:156:16:
07:52:26 <lambdabot>      Couldn't match type ‘S’ with ‘[Char]’
07:52:26 <lambdabot>      Expected type: S -> String
07:52:35 <Intolerable> @let instance Show S where show (S x) = x
07:52:36 <lambdabot>  Defined.
07:52:42 <Intolerable> > S "hello"
07:52:43 <lambdabot>  hello
07:52:44 <clrnd> > S "lol:
07:52:45 <lambdabot>  <hint>:1:8:
07:52:45 <lambdabot>      lexical error in string/character literal at end of input
07:52:58 <Intolerable> > S "> S \"string\""
07:53:00 <lambdabot>  > S "string"
07:53:05 <Intolerable> lambdabot pls
07:53:11 <jameseb> :t L.map `asAppliedTo` succ
07:53:12 <lambdabot> Enum a1 => (a1 -> a1) -> [a] -> [a]
07:53:38 <clrnd> @let instance Show S where show (S x) = reverse x
07:53:40 <lambdabot>  .L.hs:155:10:
07:53:40 <lambdabot>      Duplicate instance declarations:
07:53:40 <lambdabot>        instance [safe] Show S -- Defined at .L.hs:155:10
07:53:44 <clrnd> >:|
07:53:48 <Intolerable> nice try
07:58:02 <clrnd> @let instance Eq S where (S x) == (S x') = length x == 7
07:58:04 <lambdabot>  Defined.
07:58:14 <clrnd> > S "a" == S "a"
07:58:15 <lambdabot>  False
07:58:33 <Intolerable> awful
07:58:35 <clrnd> lovely
07:58:36 <Intolerable> @undefine
07:58:36 <lambdabot> Undefined.
07:58:50 <Intolerable> @let newtype S = S String deriving (Read, Eq, Ord)
07:58:52 <lambdabot>  Defined.
07:58:55 <Intolerable> @let instance Show S where show (S x) = x
07:58:57 <lambdabot>  Defined.
07:59:00 <Intolerable> :)
08:00:07 <Big_G> > S "1234567"
08:00:08 <lambdabot>  1234567
08:00:20 <Big_G> > S "1234567" == S "1234567"
08:00:21 <lambdabot>  True
08:00:31 <Intolerable> > S "1234567" == S "12345"
08:00:33 <lambdabot>  False
08:01:23 <Intolerable> > S "haskell sucks
08:01:25 <lambdabot>  <hint>:1:17:
08:01:25 <lambdabot>      lexical error in string/character literal at end of input
08:01:26 <Intolerable> > S "haskell sucks"
08:01:27 <lambdabot>  haskell sucks
08:01:34 <Intolerable> wow, strong words from lambdabot
08:02:06 <lep_> mmhh i always type :r in my bash prompt
08:02:12 <lep_> but i cant get it aliased to !! :<
08:02:57 * hackagebot hashable-time 0.2 - Hashable instances for Data.Time  https://hackage.haskell.org/package/hashable-time-0.2 (alkar)
08:03:20 <Intolerable> constantly find myself typing "return ()" when i'm writing c++
08:05:28 <ss_> Can someone tell me the idiomatic way to do this? http://lpaste.net/3761149689135628288
08:05:50 <ss_> Can i write this in a single line?
08:06:19 <chpatrick> (map read . words) <$> getLine
08:06:37 <Intolerable> ^
08:06:52 <chpatrick> you shouldn't need to specify the type of read when you actually use arr somewhere
08:07:29 <ss_> ok. thanks
08:07:46 <ss_> is there a name for <$>
08:07:49 <chpatrick> fmap
08:07:50 <Intolerable> fmap
08:07:53 <Intolerable> ...
08:07:55 <chpatrick> :P
08:08:05 <ss_> ok
08:08:22 <mniip> fmap liftA liftM
08:08:41 <Intolerable> :t (fmap, liftA, liftM)
08:08:42 <lambdabot> (Monad m, Functor f, Applicative f1) => ((a -> b) -> f a -> f b, (a1 -> b1) -> f1 a1 -> f1 b1, (a2 -> r) -> m a2 -> m r)
08:08:50 <Intolerable> nice
08:09:11 <Intolerable> :t fmap `asTypeOf` liftA `asTypeOf` liftM
08:09:12 <lambdabot> Monad f => (a -> b) -> f a -> f b
08:09:30 <ss_> do i need to import something?
08:09:37 <arielsanflo> hello
08:09:48 <arielsanflo> help 
08:09:48 <Intolerable> maybe import Control.Applicative
08:09:54 <Intolerable> if you're on an old version of GHC
08:10:00 <Intolerable> arielsanflo: hello
08:10:06 <arielsanflo> ejercicios resueltos en haskell
08:10:21 <arielsanflo> recursive
08:10:25 <arielsanflo> function
08:10:29 <arielsanflo> please
08:10:40 <arielsanflo> my english is so so
08:10:48 <arielsanflo> i am from colombia
08:11:56 <mniip> oh look
08:11:58 <mniip> :t (runIdentity .) . traverse . (Identity .)
08:11:59 <lambdabot> Traversable t => (a -> b) -> t a -> t b
08:12:02 <mniip> also fmap
08:12:20 <chpatrick> :t T.fmapDefault
08:12:22 <lambdabot> Traversable t => (a -> b) -> t a -> t b
08:12:22 <Intolerable> what isnt fmap really
08:12:47 <Intolerable> (inb4 ">>=")
08:12:50 <mniip> :t id
08:12:51 <lambdabot> a -> a
08:12:52 <mniip> not fmap ^
08:13:42 <mniip> oh look
08:13:45 <mniip> here's a shorter name
08:13:46 <mniip> :t over traverse
08:13:47 <lambdabot> Traversable t => (a -> b) -> t a -> t b
08:13:48 <Intolerable> > getConst . fmap undefined . Const
08:13:50 <lambdabot>      No instance for (Typeable c0)
08:13:50 <lambdabot>        arising from a use of ‘show_M14780947948478003831652’
08:13:50 <lambdabot>      In the expression:
08:13:53 <Intolerable> :t getConst . fmap undefined . Const
08:13:54 <lambdabot> c -> c
08:13:59 <Intolerable> everything is just fmap
08:14:44 <mniip> that's the inverse
08:14:52 <mniip> "fmap is everything"
08:14:57 <mniip> not "everything is fmap"
08:15:00 <Intolerable> fmap is love
08:15:07 <Clint> ♥
08:15:12 <Intolerable> fmap is life
08:15:52 <mniip> okay now let's count the names for id!
08:16:17 <Intolerable> ok easy
08:16:22 <chpatrick> :t ($)
08:16:22 <boodllebat> hi , i want to know what is best application of haskell scala and other functional languages , definitely not System Programming cause we already have C and other there , i'm just curious i've read at many places but still not clear
08:16:23 <lambdabot> (a -> b) -> a -> b
08:16:24 <Intolerable> > fix id :: Int
08:16:28 <lambdabot>  mueval-core: Time limit exceeded
08:16:35 <Intolerable> lambdabot you need to try harder
08:16:57 <mniip> > fix error
08:16:59 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
08:17:07 <boodllebat> Intolerable: that is sherk right ?
08:17:15 <Intolerable> no, it's fmap
08:17:21 <Intolerable> shrek is an instance of fmap
08:17:27 <chpatrick> boodllebat: haskell is currently best at server-side stuff and nice abstract things like compilers
08:17:28 <Intolerable> everything comes back to fmap
08:17:31 <chpatrick> but you can use it for anything
08:17:35 <chpatrick> I made an art installation with it
08:18:29 <ss_> so, what is the difference between fmap, liftA, liftM
08:18:36 <mniip> typeclass involved
08:18:36 <boodllebat> chpatrick: but i don't think its best choice for server-side for person X , if its not that case that person X loves to programme in haskell
08:18:42 <Intolerable> functionally, nothing
08:18:50 <Intolerable> but they all have different constraints
08:18:54 <mniip> Intolerable, ExceptT?
08:18:57 <chpatrick> boodllebat: it has a lot of objectively good things though
08:19:00 <chpatrick> like a very strong type system
08:19:08 <boodllebat> Intolerable: no they did not mention fmap here (https://www.youtube.com/watch?v=auEA9Ay6G0o)
08:19:09 <chpatrick> just plain makes your thing crash less
08:19:31 <Intolerable> boodllebat: they did, you just have to look closer
08:19:31 <chpatrick> and you can express a lot more really nicely than in say java
08:19:54 <chpatrick> it's the Ogre instance
08:20:00 <Intolerable> heh
08:20:11 <clrnd> > let love = Just "" ; is = const "♥" in fmap is love
08:20:12 <lambdabot>  Just "\9829"
08:20:20 <clrnd> >.>
08:20:34 <chpatrick> let isItOgre = false
08:20:36 <Intolerable> > let love = Just "" ; is = const (S "♥") in fmap is love
08:20:37 <lambdabot>  Just ♥
08:20:41 <Intolerable> :)
08:20:42 <hunteriam> 🌮
08:21:18 <boodllebat> chpatrick: no but i would still like to be sticked to my point , that is it not the best for server-side ,  is there any highlighted field in which only functional like Haskell can perform better or best ? ( Sorry if this question sounds mean cause i asked it again)
08:21:41 <chpatrick> boodllebat: check this out https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
08:21:52 <athan> boodllebat: programming :|
08:21:53 <chpatrick> it's a summary of how haskell is doing in different fields
08:21:59 <clrnd> f you
08:22:04 <athan> sry :(
08:22:10 <clrnd> not you!
08:22:12 <Intolerable> your question is very vague and subjective, too
08:22:20 <Intolerable> who are we f youing at
08:22:50 <boodllebat> clrnd: was that for me ?
08:22:54 <athan> :U
08:23:08 <clrnd> boodllebat, no, never mind
08:25:14 <geekosaur> boodllebat, I don't think that's a very sensible question. choice of paradigm (procedural, OO, FP, etc.) isn't really relevant to a given field
08:25:22 <geekosaur> it may be relevant to very specific problems
08:25:48 <chpatrick> I'm not 100% sure about that
08:25:50 <boodllebat> chpatrick: oh ! great article there , i'll read it today and come back to you tommorow :)
08:25:59 <hodapp> or in the case of OOP, irrelevant for most problems
08:26:12 <chpatrick> I think OOP is definitely overused but it does have some uses
08:26:31 <chpatrick> it's just that Java forced everyone to use it even when it's inappropriate
08:27:04 <mniip> I might have broken lambdabot :v
08:27:07 <hodapp> Java did that, and C++ also told them it was the greatest thing since sliced bread
08:27:23 <Intolerable> i miss smalltalk
08:27:40 <hodapp> I've never really used Smalltalk
08:27:42 <davidfetter> it's still around
08:27:45 <hodapp> but I found Alan Kay's work to be pretty brilliant
08:27:53 <hodapp> and also basically unrelated to "modern" OOP
08:28:00 <Intolerable> i like the "erlang is the epitome of oop" brigade too
08:28:05 <geekosaur> one can argue that C++ is dubiously OOP, but more a procedural/OO hybrid
08:28:24 <hodapp> geekosaur: it's certainly more "OOP" than it is OOP
08:28:30 <hodapp> Intolerable: that's a brigade that exists?
08:28:33 <geekosaur> (likewise perl5, python2)
08:28:55 <hodapp> someday, I'll learn Perl
08:28:58 <hodapp> wait... no, I probably won't
08:29:02 <Intolerable> hodapp: i've seen plenty of people argue that the actor system is exactly what OOP should be
08:29:04 <chpatrick> don't bother :P
08:29:20 <Intolerable> "mutable" state by actors, message passing
08:29:21 <hodapp> Intolerable: does Erlang count as actor model?
08:29:34 <suppi> can anyone help? running cabal test gives me false successes
08:29:35 <chpatrick> I don't really know smalltalk but I wonder if it'd be possible to embed a nice oop system into haskell
08:29:45 <Intolerable> possible? most likely
08:29:48 <suppi> this is my test code + cabal file + output: http://lpaste.net/2727817919638536192
08:29:51 <hodapp> chpatrick: I had thought Cloud Haskell was basically this
08:29:51 <mniip> :t fmap is love
08:29:52 <lambdabot> Fmap is Life
08:29:54 <geekosaur> define "nice"
08:29:55 <Intolerable> pleasant tho?
08:30:14 <chpatrick> nice as in at least as easy as in a language that supports it
08:30:21 <chpatrick> convenient subclassing etc
08:30:22 <athan> Wow
08:30:40 <boodllebat> sorry internet problem
08:30:43 <Intolerable> hodapp: i'd say that erlang supports the actor model
08:30:50 <geekosaur> I think it's not really possible to do it "nicely" now, but it will become possible with OverloadedRecordFields (ghc8)
08:30:56 <geekosaur> (at least, I think ghc8)
08:30:58 <chpatrick> it's not just records though
08:31:05 <chpatrick> it's also self-contained state
08:31:10 <chpatrick> and subclassing
08:31:21 <Intolerable> it's not always subclassing, though
08:31:28 <boodllebat> Intolerable: how can a question be vague and subjective at same time its bit contradictory :) 
08:31:42 <Intolerable> subclassing might be something you want, but its not necessary
08:31:48 <boodllebat> chpatrick: great article there , i'll read it today and discuss it with you tommorow
08:31:51 <hodapp> boodllebat: how are vague and subjective contradictory?
08:32:03 <chpatrick> one way I was thinking of modeling it is having interfaces as records of functions
08:32:07 <boodllebat> hodapp: vague means unclear or ambigious
08:32:15 <hodapp> boodllebat: go on.
08:32:17 <geekosaur> what's needed is not merely records, but extensible records. which (to be "nice") needs some type machinery which may not land in ghc8.1 but is in development
08:32:21 <boodllebat> hodapp: while subjective means clear cut
08:32:21 <chpatrick> if you implement an interface then you have an instance of it in your record
08:32:27 <geekosaur> at least, I think it is, since this seems to actually be a goal
08:32:29 <Intolerable> vague and subjective: asking an opinion-based question very broadly
08:32:33 <hodapp> boodllebat: no, subjective means it changes based on the observer.
08:32:43 <Alpha64> hodapp perl is quite fun
08:32:45 <hodapp> boodllebat: it rather emphatically does *not* mean clear-cut.
08:32:56 <chpatrick> perl was my second language after pascal
08:33:01 <chpatrick> but I wouldn't learn it now
08:33:05 <chpatrick> it's an artifact of its time
08:33:13 * hodapp mentally makes a note that chpatrick is freaking old
08:33:15 <boodllebat> hodapp: oh sorry there i mapped a wrong meaning there with *subjective*
08:33:24 <chpatrick> I'm 24 mate ;D
08:33:33 <boodllebat> Intolerable: my bad :)
08:33:33 <Intolerable> positively ancient
08:33:33 <Clint> pascal was my second language after basic, but i wouldn't learn it now :P
08:33:35 <hodapp> chpatrick: why did you learn Pascal first >_<
08:33:41 <chpatrick> first time I pulled an all-nighter was when I learnt perl at 12
08:33:42 <Alpha64> probably college
08:33:43 <athan> This is my swamp
08:33:46 <chpatrick> no, primary school
08:33:48 <hunteriam> :t and
08:33:49 <lambdabot> Foldable t => t Bool -> Bool
08:34:03 <boodllebat> lambdabot: hi
08:34:08 <indiagreen> hodapp: I learned Pascal first too
08:34:13 <Intolerable> chpatrick: i did the same but with ruby
08:34:13 <hunteriam> @src and
08:34:14 <lambdabot> and  = foldr (&&) True
08:34:15 <indiagreen> 19
08:34:16 <hodapp> I learned BASIC... I think
08:34:29 <Intolerable> chpatrick: probably about the same time too
08:34:32 <boodllebat> ok bye fellas
08:34:39 <boodllebat> thanks for great discussion
08:37:51 * geekosaur *eyeroll*
08:38:11 * geekosaur wonders if he can even remember exact order of languages learned...
08:38:40 <chpatrick> C# prepared me for haskell
08:38:42 <athan> BabyTalk?
08:38:55 <chpatrick> I got really into LINQ and functional style
08:39:08 <hodapp> athan: bah?
08:39:20 <chpatrick> then haskell was the first language at college and everything was so much cleaner
08:39:27 <Intolerable> i thought c# just prepared you for a lifetime of torment
08:39:32 <chpatrick> it's not so bad
08:39:34 <chpatrick> it's just a mishmash
08:39:45 <Intolerable> yeah it seems very unfocused
08:39:51 <hodapp> chpatrick: after spending time at the last job helping out with basically what became an ORM system written by people who were certain that ORM systems were stupid and unnecessary, I started to see the appeal of LINQ
08:39:57 <chpatrick> I think the only reason ms employs spj is so they can steal the features
08:40:10 <chpatrick> LINQ isn't just databases though
08:40:21 <chpatrick> it has a full Data.List implementation
08:40:23 <clrnd> BASIC was my first too, lovely language, way better than python
08:40:25 <athan> hodapp: Sometimes. Last Tuesday was a good episode.
08:40:32 <Intolerable> muh "computation expressions"
08:40:39 <Intolerable> is that what they're called now?
08:40:40 <chpatrick> and it can also take your AST and compile them to SQL which is cool
08:40:55 <chpatrick> I made a lib that did that with berkeley packet filter bytecode
08:41:02 <hodapp> athan: what?
08:41:08 <chpatrick> so you could say .Filter(p => p.Protocol == TCP) or whatever and it would get filtered on the network card
08:41:19 <exio4> but you can't abstract over it or so
08:41:42 <hodapp> I vaguely remember being like 10 or 11, using BASIC, and wondering why - if I could have an if/then over a value - why I couldn't have an if/then that just produced a function
08:42:17 <Intolerable> yeah abstracting over things like that is nice
08:42:19 <clrnd> hodapp, lol you were an early functional boomer :P
08:42:25 <Alpha64> i remember being angry because objects in c++ were not concurrent
08:42:28 <Intolerable> i'd be more inclined to use rust if it had HTKS
08:42:30 <athan> inb4 it was cool
08:42:35 <clrnd> I just though it was nice it had predefined colours and that functions where a thing
08:42:40 <Alpha64> i was convinced that OOP was what i now know as actors
08:42:54 <hodapp> Alpha64: that's because that's how Alan Kay defined it when he made the term
08:42:59 * hackagebot twitter-types 0.7.1 - Twitter JSON parser and types  https://hackage.haskell.org/package/twitter-types-0.7.1 (TakahiroHimura)
08:43:01 * hackagebot twitter-types-lens 0.7.1 - Twitter JSON types (lens powered)  https://hackage.haskell.org/package/twitter-types-lens-0.7.1 (TakahiroHimura)
08:43:21 <hodapp> HTKS = Higher... Tinded... Kypes something?
08:43:36 <Intolerable> you know what i mean
08:43:41 <hodapp> I don't >_>
08:43:58 <suppi> asking again: can anyone help? running cabal test gives me false successes. this is my test code + cabal file + output: http://lpaste.net/2727817919638536192
08:44:00 <Alpha64> hot trending kickstarters?
08:44:03 <clrnd> Higher Tinder Knifes
08:44:26 <Intolerable> Help The Kremlin
08:44:44 <athan> HTKS The KS System
08:44:45 <suppi> I'm using tasty and tasty-hunit
08:45:06 <clrnd> Hokuto no Ken
08:45:28 <mniip> High Tech Knowledge Systems
08:46:00 * athan 's internal audiance goes "ooooohhhhhhh"
08:46:57 <mniip> Hazardous Totalitarian Kampf Selbstfaulafetten
08:47:12 <athan> +_+
08:47:23 <Alpha64> Homotopical Kleisi Semigroup
08:47:40 <athan> :O
08:48:10 <mniip> How To Kick Someone
08:48:47 <Intolerable> Hey Thanks, Kill Stealer
08:48:59 <hexagoxel> suppi: and what is in the log?
08:49:55 <mniip> HyperText Kernel Server
08:50:12 <clrnd> suppi, what test should fail?
08:50:37 <clrnd> oh the LEft undefined
08:50:48 <suppi> all
08:50:56 <suppi> hexagoxel, http://lpaste.net/5870124857928187904
08:52:30 <fr33domlover> Is there a way to use bytestring I/O with \r\n being considered a newline instead of just \n ?
08:52:54 <bz> suppi: is this yesterday's 1==2 again?
08:53:06 <fr33domlover> System.IO can set the NewLineMode, but bytestring is hardcoded to use \n and nothing else
08:53:59 <suppi> bz, yes, though I tried switching to tasty
08:54:41 <hpc> fr33domlover: it sounds like you answered your own question
08:54:59 <fr33domlover> hpc, just making sure in case I missed something :P
08:55:04 <hpc> honestly, if anything i would have expected bytestring IO to be hard-coded to block buffering
08:55:11 <GLM> bz: Since when does 1 == 2?
08:55:43 <hpc> fr33domlover: are you looking at the .Char8 modules or just the regular versions?
08:55:50 <fr33domlover> hpc, it does hFlush after every hPut, so no buffering I guess
08:56:06 <fr33domlover> hpc, both
08:56:14 <clrnd>  -- @define Eq Int where ...
08:56:30 <hpc> yeah, i think you're stuck then
08:56:39 <bz> suppi: tasty's still using hunit underneath. are you still able to replicate 1 == 2?
08:59:07 <suppi> bz, i think so
09:00:15 <suppi> bz, I added another case to the list: testCase "1=2" $ 1 @?= 2
09:00:17 <bz> suppi: mind pasting your test code, cli invocations, and output?
09:00:26 <suppi> getting the exact same output
09:00:50 <suppi> bz, test code + cabal file + output: http://lpaste.net/2727817919638536192
09:05:41 <CpnStumpy> urgh I just installed spacemacs and it seems absolutely awesome - but it's so different I feel like the bindings I know aren't going to work
09:05:55 <CpnStumpy> or are going to do weird and crazy things
09:06:21 <CpnStumpy> ReinH: Thanks for the suggestion all the same, just for the file browser alone it's spectacular. Everything else I'm sure I'll figure out
09:06:22 <glguy> It's pretty close, but it's not vim keybindings
09:06:25 <glguy> they change stuff
09:06:37 <CpnStumpy> close to what?
09:06:46 <glguy> to vim
09:06:58 <CpnStumpy> blech, I'm used to emacs, this just doesn't seem like emacs anymore though
09:07:12 <CpnStumpy> much more
09:07:36 <CpnStumpy> granted I used pretty vanilla emacs
09:07:37 <geekosaur> Warning: output was redirected with -o, but no output will be generated because there is no Main module.
09:07:44 * geekosaur wonders if that is a symptom
09:07:57 <geekosaur> (perhaps the test suite is not running what you expect)
09:08:57 <suppi> wish spacemacs worked on my comp
09:09:10 <CpnStumpy> oh well, I was able to get here with m-x irc and c-x c-f brought up a nifty file browser so it looks like things are going to work similarly..
09:11:16 <suppi> geekosaur, perhaps, but what does it run?
09:12:11 <geekosaur> I have no idea check $PATH for a test-chip8 hiding somewhere?
09:12:14 <suppi> geekosaur, do you understand what that even means?
09:12:18 <bz> suppi: so i can't replicate your test, but
09:12:31 <geekosaur> it means that ghc didn't do final linking because it didn't find the entry point
09:12:45 <geekosaur> which may mean that the main-is: is wrong or incomplete/insufficient
09:12:48 <suppi> which test-chip8: test-chip8 not found
09:13:02 <bz> suppi: s#module Tests#module Main#
09:13:19 <geekosaur> yes, that seems likely
09:13:52 <bz> so it's possible that you haven't been running the droids you seek
09:13:57 <geekosaur> I think you might be able to tell it to do the right thing in main-is: (I know you can with ghc's -main-is but cabal's main-is: is somewhat different)
09:13:58 <bz> tests*
09:14:19 <suppi> bz - this seems to work
09:14:27 <bz> yay
09:14:35 <geekosaur> yeh, the question is wtf tests is it running if it's not running that?
09:14:39 <bz> next time cabal clean
09:14:40 <suppi> thank you!
09:14:45 <suppi> geekosaur, exactly!
09:14:51 <suppi> bz, ok, i'll remember that
09:14:52 <bz> geekosaur: old tests that passed
09:15:02 <geekosaur> ohhh, yeh, would have been under dist somewhere I bet
09:15:40 <suppi> bz, geekosaur, thank you so, so much.
09:16:50 <Sonolin> I wonder 
09:16:58 <Sonolin> has anybody ever tried to implement a kernel in haskell?
09:17:01 <geekosaur> ok, main-is: doesn't let you specify a module. might be able to hide a -main-is ghc parameter in there but it would probably conflict with the one generated by cabal's main-is:
09:17:12 <geekosaur> Sonolin, house
09:17:56 <Sonolin> nice!
09:17:57 <suppi> and now my tests pass~
09:18:02 <chpatrick> I'm surprised no one's done anything since
09:18:15 <Sonolin> I just saw www.flingos.co.uk and that's the first thing I thought of
09:18:17 <glguy> Sonolin: The HaLVM project uses the GHC RTS *as* a kernel
09:19:10 <geekosaur> suppi, I'd report that as a cabal-install bug, and possibly a ghc bug/infelicity; it should have determined that a new test executable was not built and failed at that point
09:19:13 <bz> meh cabal
09:19:31 <Sonolin> hmm interesting 
09:19:37 <geekosaur> I think ghc might be more at fault here; that warning should really have been an error
09:19:43 <suppi> geekosaur, can you point me in the right direction? where should I submit it?
09:19:44 <Sonolin> I think house is more what I'm looking for but HaLVM does look cool 
09:19:46 <Sonolin> inspiration :)
09:20:25 * voidzero waves
09:20:28 <voidzero> hi!!!
09:20:30 <bz> suppi: github.com/haskell/cabal/issues
09:20:37 <voidzero> darn
09:20:40 <voidzero> wrong channel
09:20:51 <geekosaur> basically "oh I'm ignoring your attempt to build a program and succeeding because I didn't find Main.main" seems Bad
09:20:54 <quicksilver> nonethesless, hi voidzero :)
09:21:03 <voidzero> haha hiya!
09:21:09 <clrnd> voidzero, hi
09:21:18 <clrnd> now you gotta learn haskal
09:21:20 <geekosaur> which was ghc's fault; cabal-install trusted ghc to have done the right thing, and it didn't
09:21:22 * voidzero does a funky dance
09:21:26 <nshepperd> unsound build systems are bad >_>
09:21:57 <geekosaur> I would expect stack to have the same problem if ghc is falsely reporting success
09:22:06 <bz> geekosaur: i think it's more likely that cabal ignores the output of the ghc build and runs the computed path of the test executable unconditionally
09:22:20 * nshepperd loves tup, for its excess of safety checks
09:22:43 <clrnd> geekosaur, suppi so, what was it? just curious
09:23:07 <geekosaur> clrnd, the test program had module Tests where, ghc expected module Main where and emitted a warning (not error!)
09:23:16 <clrnd> oh! nasty
09:23:19 <suppi> clrnd, I changed the name of the module in Tests.hs from Tests to Main and then it worked
09:23:26 <geekosaur> and did not rebuild the test program, so an old version udner dist/ was being run
09:24:00 <suppi> geekosaur, yesterday I tried doing the same thing HUnit and with a module named Main and still got the same results
09:25:09 <suppi> geekosaur, http://lpaste.net/141153
09:25:52 <suppi> I think I didn't run cabal install --enable-tests though
09:26:04 <geekosaur> that I can't help with
09:26:34 <suppi> geekosaur, yeah, that doesn't matter for me anymore, but do you think this is the same problem still?
09:26:58 <geekosaur> no, because the ghc warning isn't there
09:27:05 <suppi> hmm :\
09:27:11 <geekosaur> and it said it did the link
09:27:29 <geekosaur> you might inspect the test log
09:28:07 <geekosaur> (of course it's probably too late to do that)
09:28:58 <suppi> If I remember correctly, what was written in the log is the same thing that is written in the output
09:29:25 <suppi> I'll just submit the two cases to the issues bz linked me
09:29:42 <geekosaur> hm. if I understand hspec documentation correctly, it should have said it was running the test labeled "1" and shown the expected and actual values
09:29:51 <geekosaur> in the log
09:30:23 <CpnStumpy> anybody here know spacemacs? The #spacemacs channel has like 7 people
09:30:25 <suppi> should this also apply for hunit?
09:30:55 <geekosaur> oh, sorry, I meant hunit (I looked up assertEqual and misremembered the module it was found in)
09:31:15 <geekosaur> "Asserts that the specified actual value is equal to the expected value. The output message will contain the prefix, the expected value, and the actual value." http://hackage.haskell.org/package/HUnit-1.3.0.0/docs/Test-HUnit-Base.html#v:assertEqual
09:31:38 <geekosaur> but, no output message?\
09:32:18 <suppi> geekosaur, nope
09:32:35 <suppi> I even change the main function to be putStrLn "hello"
09:32:39 <suppi> and got the same output
09:32:41 <suppi> weird
09:34:42 <geekosaur> no idea then :/
09:35:13 <suppi> geekosaur, thanks :)
09:40:40 <meretrix> > length $ foldr (\x -> seq x x) [1,undefined,3]
09:40:41 <lambdabot>      No instance for (Foldable ((->) (t0 ([t1] -> [t1]))))
09:40:41 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
09:40:41 <lambdabot>        arising from a use of ‘length’
09:41:21 <Intolerable> > length $ foldr (\x -> seq x x) 0 [1,undefined,3]
09:41:21 <meretrix> > length $ map (\x -> seq x x) [1,undefined,3]
09:41:22 <lambdabot>      No instance for (Foldable t0) arising from a use of ‘length’
09:41:22 <lambdabot>      The type variable ‘t0’ is ambiguous
09:41:22 <lambdabot>      Note: there are several potential instances:
09:41:22 <dfeuer> Data.Traversable.mapAccumR is really something.
09:41:22 <lambdabot>  3
09:41:48 <meretrix> > length $ (\x -> foldr seq x x) [1,undefined,3]
09:41:49 <lambdabot>  *Exception: Prelude.undefined
09:42:12 <meretrix> Why does mapping seq over the list not produce the same result?
09:42:45 <Intolerable> because you don't evaluate the other part
09:42:54 <exio4> seq x x is just id
09:43:08 <dfeuer> I accidentally reimplemented most of it because I forgot it existed; it seems, essentially, to combine the features of Data.Functor.Reverse with Control.Monad.Trans.State.Lazy to do a sort of time travel.
09:43:40 <dfeuer> seq is subtle.
09:43:56 <meretrix> but foldr seq x x is not id?
09:44:10 <edwardk> @tell humanoyd "Is there a function that builds a lens out of a record field accessor function?" => Yes. Data.Data.Lens.upon will work.. but it has huge caveats. As part of the new record field stuff we should be able to give you a combinator for that that is more sane.
09:44:10 <lambdabot> Consider it noted.
09:44:56 <dfeuer> foldr seq x x  is a very strange thing to write.
09:45:10 <Intolerable> :t \x -> foldr seq x x
09:45:11 <lambdabot> Foldable t => t a -> t a
09:46:01 <dfeuer> :t \x -> foldr seq [] x
09:46:02 <lambdabot> Foldable t => t a -> [t1]
09:46:05 <dfeuer> er..
09:46:10 <dfeuer> silly me.
09:46:19 <monochrom> "foldr seq x x" requires x to be a list
09:46:21 <dfeuer> Yech.
09:46:32 <meretrix> :t map (\x -> seq x x)
09:46:33 <lambdabot> [b] -> [b]
09:46:37 <dfeuer> monochrom, no, waht I said does....
09:46:47 <dfeuer> foldr seq x x does not; but it's ugly.
09:47:50 <delYsid`> I worked out an algorithm to compute ambiguous braille music note/rest values in C++.  I worked on that implementation for a long time actually, starting at 2m runtime for the worst case I know, and ending up with ~1s runtime for the same input.  I ended up using continuation-passing style to implement the nested recursion to avoid a lot of useless copying.  I am interested to port this algorithm to Haskell, to make it easier to reason
09:47:50 <delYsid`> about it (I have roughly 1.5k LOC of C++), and also to see if Haskell can match the performance I ended up getting from carefully crafted C++.  I am rather new to Haskell and have no experience with runtime of more complex algorithms.  Should I use CPS in Haskell as well, or is there anything I really should avoid doing?
09:48:27 <dfeuer> Maybe not that ugly though.
09:48:31 <dfeuer> So weird.
09:49:40 <ss_> @pl: \(a, b) -> a == '1' || b == '1'
09:49:40 <lambdabot> uncurry ((. ('1' ==)) . (||) . ('1' ==))
09:49:47 <dfeuer> edwardk, you mentioned "eval" on the phone. You were talking about eval/apply, right?
09:50:45 <monochrom> delYsid`: that is a pretty general question. so I have only a pretty broad answer for now. avoid using C++ intuition for execution model on Haskell
09:50:57 <dfeuer> I changed my mind. foldr seq x x might well be the best way to do that, short of just using deepseq and force.
09:51:52 <exio4> foldr seq x x is not like deepseq though
09:52:02 <exio4> > foldr seq x x [Just undefined, Nothing]
09:52:03 <lambdabot>      Couldn't match expected type ‘[Maybe a1] -> t’
09:52:03 <lambdabot>                  with actual type ‘Expr’
09:52:03 <lambdabot>      In the second argument of ‘foldr’, namely ‘x’
09:52:12 <exio4> > (\x -> foldr seq x x) [Just undefined, Nothing]
09:52:14 <lambdabot>  [Just *Exception: Prelude.undefined
09:52:34 <dfeuer> delYsid`, since you're new to Haskell, here's what I'd suggest: write the code in the clearest, most logical way you can think of, without thinking about efficiency. Then test it, profile it, and ask for help making it fast.
09:53:28 <dfeuer> exio4, ah yes, because it's only one level down. Someone whose name I can't remember has a "bounded-depth deepseq" somewhere....
09:54:47 <exio4> I don't really understand how it is evaluating more than one-level down though
09:55:06 <exio4> > join (foldr seq) [Just (Just [undefined])]
09:55:07 <lambdabot>  [Just (Just [*Exception: Prelude.undefined
09:55:23 <monochrom> deepseq for list is along the line of "foldr deepseq y x" instead of "foldr seq y x"
09:56:22 <dfeuer> monochrom, yeah, so it's "bounded deepseq" with itself.
09:56:36 <dfeuer> exio4, you don't understand how what is what?
09:57:21 <edwardk> dfeuer: Yes, the eval/apply functions in GRIN correspond to the eval/apply from the "Making a Fast Curry" paper: http://community.haskell.org/~simonmar/papers/evalapplyjfp06.pdf
09:57:36 <Intolerable> > join (foldr seq) [Just (Just [undefined])] `seq` ()
09:57:37 <lambdabot>  ()
09:57:54 <Intolerable> exio4: it isn't evaluating it until it tries to print it?
09:57:55 <exio4> oh, I.. nevermind
09:58:11 <exio4> thanks Intolerable 
09:58:55 <dfeuer> edwardk, okay, cool, I'm reading the fast curry right now. I'm wondering how badly the GC stuff you pointed me to is tied up in patents. Will there be stupid issues?
09:59:01 <GLM> Is there a way to swap arguments for a function that takes more than two?
09:59:36 <dfeuer> GLM, yes. But these ways tend to get harder and harder to read as the number goes up.
09:59:52 <GLM> dfeuer:Example?
10:00:28 <dfeuer> @pl \f x y z -> f y z x  -- GLM
10:00:28 <lambdabot> flip . (flip .)
10:01:11 <dfeuer> So  (flip . (flip .)) f x y z = f y z x, but you've made your code horrible.
10:01:25 <MarcelineVQ> Just give it a nice name
10:01:48 <delYsid`> monochrom: Yeah, I already guessed that :-)  That is sort of why I asked... In essnece, every ambiguous value can have two meanings, wOr16=[1 % 1,1 % 16], hOr32=[1 % 2, 1 % 32], qOr64=[1 % 4, 1 % 64], eOr128=[1 % 8, 1 % 128].  Given a list of such undecided values, and a maximum sum (the time signature), figure out all possible combinations that do not exceed the maximum sum.  disambiguate :: Rational v => [Undecided] -> [[v]].
10:01:48 <geekosaur> (flip . (flip .)) is a hanging offense >.>
10:02:08 <dfeuer> Sure, you could  rotate3, unrotate3, blah blah, and now you're writing FORTH instead of Haskell.
10:03:35 <dfeuer> The only times I've found this sort of weird point-free code actually useful is when I've really wanted to use #. or .# 
10:03:42 <dfeuer> *are
10:05:08 <dfeuer> I guess it's probably more generally useful when translating code dealing with functions to code dealing with general Profunctors or Categories.
10:05:31 <dfeuer> But only certain things will work in that context anyway.
10:05:55 <Apocalisp> If the Free/Forget adjunction is witnessed by `liftF` and `retract`, what witnesses the Forget/Cofree adjunction?
10:06:59 <delYsid`> dfeuer: makes sense, I guess there is no shortcut.
10:11:18 <suppi> omg it's happening again
10:12:00 <suppi> this is totally unreliable.
10:13:56 * voidzero just nods
10:19:29 <Apocalisp> https://gist.github.com/runarorama/aeff7d899241b5e84c70
10:20:33 <Apocalisp> I'm not sure how to proceed with `rightAdjunct` here
10:21:31 <shachaf> Apocalisp: The direct answer is probably "lower" and "section" or something.
10:21:42 <shachaf> Though lower's type is less general, I guess.
10:22:11 <Apocalisp> I can immediately get a `Cofree g a`, but does that help?
10:22:39 <shachaf> But I'm not sure those things are witnessing the adjunction in the sense you said?
10:24:07 <shachaf> Let's see. The Free adjunction says that monad homomorphisms : (Free F ~> M) are naturally isomorphic to natural transformations : (F ~> UM)
10:24:27 <Apocalisp> I'd expect the Forget.Cofree composite to form a comonad in an endofunctor category, which would allow me to go from Cofree f -> f, for any f
10:24:38 <shachaf> You mean a comonoid?
10:24:52 <Apocalisp> no I think I mean comonad
10:25:05 <Apocalisp> like in the sense that Free is a monad
10:25:17 <shachaf> Oh, OK, sure.
10:25:53 <Apocalisp> (forall b. f b -> Free g b) -> Free f a -> Free g a
10:26:30 <Apocalisp> OK, so I guess I need to figure out how to write...
10:26:50 <Apocalisp> (forall b. Cofree f b -> g b) -> Cofree f a -> Cofree g a
10:27:43 <Apocalisp> and Cofree f a -> f a
10:29:57 <Apocalisp> edwardk would know :)
10:30:16 * edwardk waves hello.
10:30:35 <edwardk> did you read http://comonad.com/reader/2015/categories-of-structures-in-haskell/ ?
10:30:58 <edwardk> that is for a different Free and Cofree though
10:31:13 <Apocalisp> I haven't read that yet, no
10:31:19 <Apocalisp> I will do that presently 
10:31:22 <edwardk> you might want to start there
10:31:27 <Apocalisp> ok awesome
10:31:35 <Apocalisp> Thanks, ed
10:31:39 <edwardk> np
10:36:05 <GLM> Has anyone had success using Haxl?
10:37:13 <edwardk> i hear facebook is getting some use out of it ;)
10:37:38 <GLM> edwardk:I saw that there was a talk last night but it didn't get recorded
10:39:13 <GLM> edwardk:Anything of particular interest that they said? I'm trying to find a way to use it if it is justified
10:41:05 <medicijnman> what is best practice if you want to filter on multiple elements? i have an [[String]] and want to keep the elements that are positioned at indices that [Int] holds.
10:42:24 <shachaf> Apocalisp: Let's see. You have eta :: Comonad w => w a -> Cofree w a, and eps :: Functor f => Cofree f a -> f a, right?
10:42:36 <shachaf> You should be able to make everything you need from those.
10:43:52 <medicijnman> e.g.: myfilter :: [String] -> [[String]] -> [[String]]
10:43:52 <medicijnman> myfilter columns table = table !! [3,2] obviously won't work
10:43:52 <medicijnman> what is the best way to do this?
10:44:26 <Cale> medicijnman: If you're doing random accesses, lists are kind of the wrong structure. I'd probably first build a Data.Map or Data.IntMap like  Map.fromList (zip [0..] xs), and then do lookups in that Map
10:45:07 <Apocalisp> eps = extract . unwrap ?
10:45:29 <shachaf> fmap extract . unwrap, I think
10:45:42 <Apocalisp> right, ok
10:45:43 <medicijnman> Cale: my implementation is like a projection of a table. unfortunately, the code i want to combine requires it to be [[String]] and using Data.Map means i need to convert the code i want to use
10:46:13 <shachaf> Well, you probably also need fmap for the appropriate functors, e.g. hoistCofree or something along those lines.
10:46:20 <Cale> You can do:  map (\k -> Map.lookup k (Map.fromList (zip [0..] xs))) ixs
10:46:47 <Cale> which will get you a list of Maybe values, depending on whether each lookup succeeded or not
10:47:11 <Cale> You could also not use the intermediate Map
10:47:23 <Cale> If all the indices are tiny, it might be fine to use lookup
10:47:26 <Cale> :t lookup
10:47:28 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
10:47:54 <Cale> > lookup 3 (zip [0..] (words "here are some words to look through"))
10:47:56 <lambdabot>  Just "words"
10:48:14 <suppi> ok, so stack test gives me the output I wanted.
10:48:23 <Cale> > map (\k -> lookup k (zip [0..] (words "here are some words to look through"))) [3,3,2,6,12]
10:48:25 <lambdabot>  [Just "words",Just "words",Just "some",Just "through",Nothing]
10:48:30 <suppi> guess I'm moving to stack then.
10:49:06 <Cale> From there, you might want to use either catMaybes or sequence, depending on how much you care about failures
10:49:18 <Cale> > catMaybes . map (\k -> lookup k (zip [0..] (words "here are some words to look through"))) $ [3,3,2,6,12]
10:49:19 <lambdabot>  ["words","words","some","through"]
10:49:27 <Cale> ^^ drop the failures
10:49:31 <Cale> > sequence . map (\k -> lookup k (zip [0..] (words "here are some words to look through"))) $ [3,3,2,6,12]
10:49:33 <lambdabot>  Nothing
10:49:40 <Cale> ^^ fail completely if there are any failures
10:49:42 <Cale> > sequence . map (\k -> lookup k (zip [0..] (words "here are some words to look through"))) $ [3,3,2,6]
10:49:44 <lambdabot>  Just ["words","words","some","through"]
10:49:53 <Cale> ^^ succeed with list of successes otherwise
10:49:54 <shachaf> Apocalisp: let foo :: Functor g => (forall b. f b -> Cofree g b) -> f a -> g a; foo k = eps . k
10:50:29 <medicijnman> Cale: okay. i'm not very familiar with Data.Map. Let's say we have tbl_proj = [["first","second"],["alice","allen"],["bob","allen"]]. I have written myfind :: Row -> Row -> [Int] which will give me the indices of the elements in tbl_proj !! 0 that need to be projected.
10:50:38 <shachaf> Apocalisp: I.e. rightAdjunct f = fmap extract . unwrap . f
10:50:42 <medicijnman> Row = [String]
10:50:53 <Apocalisp> shachaf: Yeah, that's it
10:50:55 <shachaf> Apocalisp: (And it needs a functor constraint, which is fine because it's giving you a natural transformation.)
10:51:01 <Apocalisp> right on
10:51:03 <Cale> medicijnman: However, the list-based lookup function is O(n), so it's quite expensive to do many lookups in general, and this is something to consider if you care about performance later.
10:51:21 <shachaf> This is slowly coming back to me. :-)
10:51:36 <Cale> medicijnman: In general !! is also something to be avoided
10:51:48 <Apocalisp> shachaf: For some reason I want to do (=>> unwrap) instead of just unwrap
10:51:57 <Cale> For similar reasons, but for the additional reason that it handles failure by killing your program.
10:51:59 <medicijnman> Cale: because it is also O(n)? this is the definition of myfind
10:51:59 <medicijnman> myfind needle haystack = mapMaybe (`elemIndex` haystack) needle
10:52:19 <shachaf> Apocalisp: let bar :: Comonad f => (forall b. f b -> g b) -> f a -> Cofree g a; bar k = hoistCofree k 
10:52:22 <shachaf> . eta
10:52:44 <Cale> Lists are basically loops waiting to happen. If you don't plan on iterating over the elements of your list in order, then those things don't belong in a list.
10:53:20 <Apocalisp> awesome. Thanks, shachaf
10:53:27 <Cale> (but iteration is important, and so lists become important)
10:54:19 <Cale> However, if you're just starting out in the language, you can sort of ignore this and use lists more heavily than you normally ought to, and it's okay.
10:54:41 <Cale> But you should be aware that there are better data structures for random access, such as arrays and maps.
10:55:29 <medicijnman> Cale: but still it is important to know that Map.Lookup is 'faster' than O(n) so with large input this will take significantly more computation time
10:55:48 <Cale> yeah
10:57:05 <Apocalisp> follow-up question: is Yoneda left or right adjoint to a forgetful functor?
10:58:01 <shachaf> A forgetful functor to what?
10:58:08 <medicijnman> so lets say we have: tbl_test = [["first","second"],["alice","allen"],["bob","allen"]]
10:58:08 <medicijnman> and in ghci we type: myfind ["second","first"] (tbl_test !! 0) this will yield [1,0]
10:58:13 <Cale> If you build a Map, the lookups will be O(log n) time, and so the whole thing will take O((m + n) log n) time, where m is the number of indices you're looking up, and n is the number of elements in the list. You could even make this O((m log n) + n) time if you want to use fromAscList
10:58:47 <glguy> Data.Map's fromList is smart and runs fast on sorted lsits
10:59:06 <Cale> Oh, interesting
10:59:33 <medicijnman> so in this case i just want to swap the two columns by projecting them in reversed order
10:59:38 <Apocalisp> shachaf: Coyoneda takes any f and constructs the free functor Coyoneda f. So it's definitely left-adjoint to the functor Forget: (* -> *, Functor) ~> *
10:59:54 <Apocalisp> sorry (* -> *, Functor) ~> (* -> *)
11:00:36 <Apocalisp> I am wondering whether Yoneda is the right adjoint
11:00:56 <medicijnman> i think a simple (but probably inefficient) way to project it would be to transpose the table, keep indices [1,0] in that order and tranpose it again
11:01:11 <shachaf> Apocalisp: I don't follow the notation there.
11:01:40 <shachaf> You mean a functor from the category of endofunctors to the category of type constructors?
11:01:45 <medicijnman> something like (transpose (transpose table) !! [1,0]) but this obviously won't work
11:03:27 <ReinH> medicijnman: this all sounds like a lot of work to avoid using the right data structure :p
11:04:03 <medicijnman> ReinH: yeah i would really like to use a better data structure but they won't allow me :(
11:04:43 <Apocalisp> shachaf: yes
11:04:53 <ReinH> medicijnman: Ah, "they". Darn "them".
11:05:20 <medicijnman> ReinH: darn co-workers :p
11:05:25 <shachaf> Apocalisp: What's the latter category? Arrows are functions :: forall a. f a -> g a or something?
11:05:40 <Cale> medicijnman: Oh, are you working at a place that's using Haskell?
11:06:08 <GLM> Are there anything like the memoize anotation in Python in Haskell?
11:06:39 <medicijnman> Cale: yes :) but unfortunately my co-workers are not very helpful because i really thought they could help me out
11:07:12 <drewbert> let's say I have an expression e with type [m1 m2 a0] and I need to expose the a0 in my do block.  I can do "v <- fmap sequence $ sequence $ e" to get the m2 [a0] and then v1 <- v to get the [a0].  Is there a way to do this on a single line in DO syntax?
11:07:15 <Cale> medicijnman: Cool! I am too (working for Obsidian Systems).
11:07:18 <Ankhers> GLM: https://wiki.haskell.org/Memoization
11:08:13 <Cale> medicijnman: You can of course do the super-cheesy thing and just map (xs !!) over the list of indices
11:08:41 <indiagreen> profiling suddenly stopped working – compiled executable says “invalid heap profile option: -hy”
11:08:50 <indiagreen> just -h works
11:08:54 <Cale> medicijnman: It's inefficient and might cause a runtime error, but you might be okay with it if you're just trying to get something done.
11:08:55 <indiagreen> what could be wrong?
11:08:59 <ReinH> medicijnman: Wait, your coworkers are preventing you from making your software faster and easier to understand?
11:09:11 <ReinH> (and potentially safer)
11:09:15 <medicijnman> ReinH: apparently yes xD
11:09:20 <ReinH> Well, don't let them :p
11:09:38 <medicijnman> Cale: yeah i think that is for the best. it's a shame they don't care much about performance
11:09:54 <Cale> medicijnman: avoiding !! isn't just about performance though
11:09:56 <geekosaur> drewbert, each <- becomes a >>=
11:10:05 <Cale> It's also about correctness in dealing with failure.
11:10:11 <Cale> [1,2,3] !! 8
11:10:13 <Cale> > [1,2,3] !! 8
11:10:14 <lambdabot>  *Exception: Prelude.!!: index too large
11:10:26 <Cale> ^^ this message is brutal to debug if you use !! everywhere
11:10:37 <indiagreen> answer: I forgot about -prof
11:10:38 <indiagreen> nevermind
11:10:41 <medicijnman> Cale: so you mean it's also bad practise?
11:10:43 <Cale> yes
11:11:02 <Cale> You should avoid using !! unless you're *really* *really* sure that it'll never fail
11:11:14 <delYsid`> How do I add a guard to sequence?
11:11:18 <Cale> and even then, it performs badly
11:11:31 <ReinH> medicijnman: partial functions incur a proof burden on the programmer to show that they are used in a total way
11:11:35 <Cale> (well it performs as best it can)
11:11:40 <medicijnman> Cale: seems legit. i've started learning haskell two weeks ago and i think it is really awesome
11:12:00 <ReinH> e.g., there are cases where head is totally safe, but it's up to you to prove that your use is one of them
11:12:11 <ReinH> (or to not prove it if you like to live dangerously)
11:12:50 <medicijnman> i have too many years spent debugging in imperative languages and i loathe some of them. haskell is very pure and simple. the compiler gives you better diagnostics if something goes wrong
11:13:06 <delYsid`> i.e, an efficient version of filter f $ sequence s
11:13:07 * hackagebot diagrams-core 1.3.0.3 - Core libraries for diagrams EDSL  https://hackage.haskell.org/package/diagrams-core-1.3.0.3 (BrentYorgey)
11:13:08 <ReinH> well, sort of
11:13:28 <ReinH> :t sequence
11:13:29 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:13:33 <geekosaur> drewbert, so (assuming you don't want "v <- ...;v1 <- v", you would need to use >>=; you can't combine them "in do syntax"
11:13:51 <ReinH> delYsid`: so your m is []?
11:14:03 <drewbert> geekosaur: yes, you appear to be correct. I had a misunderstanding.
11:14:11 <delYsid`> ReinH: exactly.
11:14:34 <drewbert> drewbert: even splitting up the lines it does not work.  They monads are not compatible.
11:14:37 <drewbert> the*
11:14:39 <ReinH> delYsid`: are you sure that filter f . sequence is inefficient?
11:14:50 <geekosaur> note that you can say v <- ... >>= ...
11:15:03 <geekosaur> it's not even especially uncommon
11:16:25 <delYsid`> ReinH: ahhhh, lazyness might win me a lot here I guess :-)  Thanks for the hint.
11:17:01 <shachaf> Apocalisp: OK, I just worked through the adjunctions and the answer is yes.
11:17:09 <shachaf> Apocalisp: That's pretty neat.
11:17:23 <ReinH> delYsid`: I'm not sure. It might be.
11:17:32 <Apocalisp> shachaf: oooh show me?
11:17:38 <ReinH> Best not to assume.
11:18:18 <JackSierkstra> Good evening everyone
11:18:19 <shachaf> Apocalisp: Maybe "worked through" is an overstatement here. :-)
11:18:26 <Apocalisp> :)
11:18:42 <Apocalisp> shachaf: Fair enough
11:20:05 <shachaf> Apocalisp: But for a forgetful functor U and Coyoneda F, you have a natural transformation eps : FUf -> f, and a polymorphic function eta : c -> UFc
11:20:27 <shachaf> So "lowering" requires a Functor constraint and "lifting" doesn't.
11:20:51 <shachaf> And you can show that you have the appropriate triangles.
11:22:03 <shachaf> And for forgetful U and Yoneda G, you have a polymorphic function eps : UGc -> c, and a natural transformation eta : f -> GUf
11:22:17 <shachaf> So "lifting" requires a Functor constraint and "lowering" doesn't.
11:22:26 <Apocalisp> so lifting requires Functor but lowering does not
11:22:29 <shachaf> And you can show the same thing.
11:22:40 <Apocalisp> yeah ok
11:22:50 <shachaf> Which I guess in Haskell you would just express as eps . eta = id, eta . eps = id
11:24:45 <JackSierkstra> Can somebody help me with a little problem I got? : http://lpaste.net/8604061486760853504
11:25:34 <shachaf> Apocalisp: This gives a justification to the names.
11:26:04 <shachaf> Apocalisp: Since you have Coyoneda -| U -| Yoneda, so they really are dual to each other in the usual sense.
11:27:41 <JackSierkstra> The explanation is in the paste as well.
11:29:00 <Apocalisp> shachaf: Very cool
11:32:20 <jhrcek> What does it mean when the name of some type has # appended to it? I just need to know how it's called so I can google it :)
11:33:20 <`^_^v> google unboxed types
11:33:50 <jhrcek> `^_^v: thanks
11:34:23 <dmj`> jhrcek: https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/primitives.html
11:35:21 <shachaf> jhrcek: MagicHash is the extension
11:35:58 <monochrom> they are usually GHC's internal types and operations.
11:38:04 <nolrai666> Hmm. Is it possible to express nilpotentcy with linear types?
11:39:46 <drewbert> geekosaur: turns out what I needed was what you had said plus liftIO i.e. v <- ... >>= liftIO . sequence,
11:40:06 <drewbert> I was fortunate that the zip monad I was working in was an instance of MonadIO
11:42:53 <Apocalisp> one more follow-up: Which adjunction forms the Reader monad?
11:43:44 <Apocalisp> I am assuming that when you compose those adjoints the other way you get the Coreader comonad
11:44:00 <shachaf> Apocalisp: Lots of adjunctions do.
11:44:04 <delYsid`> Is there a function that works like map, but passes the remaining list to f?
11:44:18 <Apocalisp> shachaf: How do you mean?
11:44:31 <GLM> delYsid`:Can you give an example?
11:44:37 <shachaf> For any monad, there are a whole bunch of adjunctions that compose to make it.
11:44:52 <Apocalisp> delYsid`: You want =>> for the non-empty list comonad :)
11:45:16 <johnw> delYsid`: a paramorphism for lists would do that
11:45:40 <johnw> http://stackoverflow.com/questions/13317242/what-are-paramorphisms
11:45:52 <johnw> you could implement one using foldr
11:46:10 <shachaf> Apocalisp: Whatever comonad you get from composing them the other way will be in the other category, though, not in Hask.
11:46:27 <shachaf> Apocalisp: State/Store is a special adjunction because it's : Hask -> Hask, but it's the only such adjunction.
11:46:50 <drewbert> Not sure why haskell has adopted >>= as the default. Most of haskell reads right-to-left so =<< is clearly superior unless you're breaking onto a newline
11:46:54 <Apocalisp> shachaf: ah, ok, I suspected as much. But what is that other category?
11:48:21 <shachaf> Apocalisp: There are a whole bunch of other categories to go with the whole bunch of adjunctions. :-)
11:48:40 <suppi> drewbert, I guess so it will translate to do notation more easily
11:48:48 <Apocalisp> shachaf: Do you know of an example?
11:48:58 <drewbert> suppi: that's a good point.
11:49:29 <shachaf> Apocalisp: Kleisli and Eilenberg-Moore are the two classic examples.
11:50:16 <monochrom> I think >>= is the default because it is in the same order as do-notation
11:50:17 <suppi> like: pure 2 >>= \a -> pure 5 >>= \b >>= pure (a + b) == do { a <- pure 2; b <- pure 5; pure (2 + 5); }
11:50:32 <monochrom> err I'm late
11:50:43 <delYsid`> @t para
11:50:43 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
11:51:03 <monochrom> @you
11:51:04 <lambdabot> JAPAN is a WONDERFUL planet -- I wonder if we'll ever reach their level
11:51:04 <lambdabot> of COMPARATIVE SHOPPING ...
11:51:23 * Clint twitches.
11:51:40 <monochrom> I suppose I'm supposed to use "@thank you" instead of "@you"
11:51:43 <monochrom> @thank you
11:51:43 <lambdabot> Maybe you meant: thank you thanks
11:52:06 <monochrom> the plot thickens
11:52:11 <clrnd> @thanks
11:52:11 <lambdabot> you are welcome
11:52:13 <Apocalisp> shachaf: So Reader has a right adjoint which goes from the Kleisli category to the category of Reader-algebras
11:52:28 <suppi> monochrom, you made me remember a song
11:54:14 <Apocalisp> shachaf: That right-adjoint is just Coreader though
11:54:38 <sedeki> what does it mean when the compiler says Expected type: M Int; Actual type: M (M Int) <-- the M (M Int) part
11:55:04 <sedeki> did it wrap my Int twice?
11:55:05 <Apocalisp> I guess I'm confusing the right adjoint of Reader with a given adjoint pair that composes to form Reader
11:55:26 <monochrom> sedeki: yes probably
11:55:32 <delYsid`> ugh, this stuff is confusing me.
11:55:49 <johnw> delYsid`: what's up?
11:55:57 <monochrom> or rather, you wrapped your Int twice.
11:57:50 <delYsid`> paramap f [] = []; paramap f (x:xs) = f (x:xs) : paramap f xs
11:58:04 <delYsid`> thats actually what I want I think.
11:58:29 <johnw> ah
11:58:34 <aphocus> I can't get vector-algorithms to sort my dataType, getting instance issues, but haven't a clue why.
11:58:38 <johnw> map f (tails xs)
11:58:48 <delYsid`> oh
11:58:53 <johnw> this will pass "the rest of the list" to f for every cons cell
11:59:14 <delYsid`> :t tails
11:59:14 <lambdabot> [a] -> [[a]]
11:59:21 <johnw> > tails [1,2,3,4]
11:59:23 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
11:59:24 <delYsid`> ok, that sig doesnt help :-)
11:59:26 <lpaste_> sedeki pasted “Trying to reproduce results from a tutorial...” at http://lpaste.net/141196
11:59:34 <sedeki> monochrom hehe. true. although I'm following a tutorial on monads (which I'm trying to learn).
11:59:41 <delYsid`> > tails [1,2,3]
11:59:42 <lambdabot>  [[1,2,3],[2,3],[3],[]]
11:59:52 <delYsid`> *thats* it!
12:00:10 <johnw> delYsid`: getting a feel for all the functions available in the standard libraries takes some time
12:00:34 <delYsid`> actually, the last [] is too much...
12:00:52 <delYsid`> johnw: yeah, I know.
12:01:02 <johnw> > init (tails [1,2,3])
12:01:03 <lambdabot>  [[1,2,3],[2,3],[3]]
12:01:24 <johnw> but be careful though...
12:01:26 <johnw> > init []
12:01:27 <lambdabot>  *Exception: Prelude.init: empty list
12:01:43 <delYsid`> damn
12:01:44 <sedeki> can anyone check my paste (above)? I'm getting that error but not sure how to fix this the tutorial way.
12:01:45 <monochrom> sedeki: you have essentially "unit ( ... unit ...)"
12:01:57 <sedeki> okay
12:01:58 <sedeki> let me see
12:02:05 <delYsid`> > tails []
12:02:07 <lambdabot>  [[]]
12:02:08 <monochrom> you don't need the outer unit
12:02:16 <delYsid`> ok, thats fine I guess :-)
12:02:37 <johnw> delYsid`: it's better to give 'f' a behavior at the base case of [] anyway
12:02:41 <delYsid`> map f . init . tails -- it is then, thanks johnw!
12:02:48 <monochrom> \b -> if b==0 then raise "dbz" else unit (a `myDiv` b)
12:02:53 <sedeki> monochrom yeah it compiles now
12:03:09 * hackagebot invariant 0.2.2 - Haskell 98 invariant functors  https://hackage.haskell.org/package/invariant-0.2.2 (ryanglscott)
12:03:11 * hackagebot Updater 0.3 - Monadic FRP library based on stm  https://hackage.haskell.org/package/Updater-0.3 (yokto)
12:03:56 <delYsid`> I've just replaced roughly 200 lines of C++ with "filter f . sequence . map g . init . tails" :-)
12:04:29 <johnw> delYsid`: sequence . map g is the same as "traverse g" nowadays
12:04:47 <johnw> (in 7.10)
12:04:49 <delYsid`> even better!
12:05:42 <sedeki> monochrom hmm. why are a,b of type Int and not M Int ?
12:05:46 <sedeki> in `eval`
12:06:00 <Ankhers> :t eval
12:06:01 <lambdabot>     Not in scope: ‘eval’
12:06:01 <lambdabot>     Perhaps you meant ‘ival’ (imported from Data.Number.Interval)
12:06:02 <monochrom> because of the type of x
12:06:13 <monochrom> Ankhers: it's in http://lpaste.net/141196
12:07:00 <monochrom> x's type says "... (a -> M b) ..." not "... (M a -> M b) ..."
12:07:49 <drewbert> Dang, does anybody have recommendation for processing nested zip files?
12:08:30 <sedeki> monochrom yeah but eval (Con N) return a M Int
12:08:58 <monochrom> also, you would really prefer a,b to be Int rather than M Int, so that you can immediately get things done such as "b==0", as opposed to running around circles wondering "I have M Int, but not Int, how can I examine it?"
12:09:08 <drewbert> Codec.Archive.Zip complains about the format of the zip files generated by my computer, and LibZip cannot process a zip from within a zip without first writing the contents of said nested zip to a new file.
12:09:28 <sedeki> monochrom yes, i understand that. it's great. i'm just trying to understand the code as is
12:10:00 <sedeki> ah i see now
12:10:06 <sedeki> in `x`
12:10:11 <drewbert> The whole "withArchive" only taking a filepath was a bit of an oversight, though I understand they may have done so to satisy the constraints of the FFI.
12:10:14 <sedeki> as you mentioned
12:10:47 <monochrom> x has internal-investigation power
12:18:51 <medicijnman> I tried to fix my problem but I still can't get it right. Lets say we want to want to extract the columns of a table (i.e. [[String]]) using indices specified by [Int]. The closest I get is map (!! [1,0]) table but that doesn't work.
12:19:47 <monochrom> is your table row-major or is it column-major?
12:20:13 <medicijnman> monochrom: row-major
12:20:19 <Welkin> > [[1,2,3],[4,5,6]] !! 1 !! 0
12:20:20 <lambdabot>  4
12:20:52 <monochrom> then use "transpose" to get a column-major version. then you can ask for the nth column.
12:20:52 <chpatrick> :t map (\r -> [ r !! 1, r !! 0 ])
12:20:53 <lambdabot> [[t]] -> [[t]]
12:21:31 <medicijnman> i want to do something like: project ["last","first"] table. project should list only columns "last" and "first"
12:21:36 <monochrom> for example "transpose mytable !! 2" gets the 3rd column. (or the 2nd, if you start from 0st)
12:21:41 <sunnymilk> is there a ni ceway to modify the show instance of a large "record" type
12:21:47 <sunnymilk> it prints this huge string
12:21:59 <Welkin> sunnymilk: define your own Show
12:22:01 <aphocus> can someone help me figure out why this I can't sort Vectors? http://lpaste.net/141197
12:22:02 <sunnymilk> i would like to print all parts of the type except that one field
12:22:02 <chpatrick> sunnymilk: write your own instead of deriving?
12:22:10 <sunnymilk> well, its not my type
12:22:15 <sunnymilk> it already derives show i think
12:22:16 <monochrom> I haven't learned how to index columns (or any coordinate) by strings.
12:22:34 <chpatrick> and the problem is that it spams your ghci?
12:22:36 <Welkin> sunnymilk: then there is nothing you can do except write your own function myShow and apply it directly
12:23:07 <Welkin> sunnymilk: or you could modify the library
12:23:10 * hackagebot yesod-auth-account-fork 2.0.2 - An account authentication plugin for Yesod  https://hackage.haskell.org/package/yesod-auth-account-fork-2.0.2 (FelipeLessa)
12:23:25 <medicijnman> i use myfind ["last","first"] (tbl_proj !! 0) which yields [1,0]. i want to use [1,0] to construct a new table
12:23:48 <medicijnman> myfind is declared as myfind :: Row -> Row -> [Int]
12:23:48 <medicijnman> Row = [String]
12:24:18 <chpatrick> aphocus: where does sort come from?
12:24:58 <aphocus> chpatrick, Data.Vector.Algo...Merge
12:25:50 <aphocus> sorry heap, but I tried both, both same error.
12:27:30 <kaidelong> is "(Monad f) => Free f a -> m a" possible?
12:27:43 <kaidelong> it seems like it should be, but it's not obvious to me how to implement it
12:28:51 <mniip> kaidelong, m?
12:28:52 <exio4> kaidelong: Free 4f a -> 4m a? 
12:29:32 <kaidelong> I meant Free f a -> f a
12:29:32 <kaidelong> sorry
12:29:54 <kaidelong> "fix \self -> case x of { Free a -> return a; Roll (f a) -> fmap self a }"
12:29:59 <kaidelong> is the closest I've come to
12:30:06 <kaidelong> but that Roll case is wrong
12:30:18 <kaidelong> oh, should be "Roll a"
12:30:25 <kaidelong> but I mean, it's wrong other than just that
12:30:37 <kaidelong> join (fmap self a) ?
12:32:14 <exio4> join (fmap f x) = f =<< x 
12:32:21 <exio4> just saying :)
12:32:50 <medicijnman> so is it possible to pass [1,0] and extract the 1-th and 0-th element in [[String]]?
12:33:07 <kaidelong> oh I guess that's true
12:33:21 <kaidelong> Free f a -> f a could be considered a kleisli arrow
12:33:26 <kaidelong> I didn't realize that at first
12:33:39 <kaidelong> because it looks more like a co-kleisli arrow at first sight
12:34:00 <kaidelong> so we get
12:34:17 <kaidelong> "fix \self -> case x of { Free a -> return a; Roll a -> a >>= self }"
12:34:25 <kaidelong> looks good to me
12:34:42 <kaidelong> @type fix \self -> case x of { Free a -> return a; Roll a -> a >>= self }
12:34:43 <lambdabot> parse error on input ‘\’
12:34:49 <kaidelong> @type fix $ \self -> case x of { Free a -> return a; Roll a -> a >>= self }
12:34:50 <lambdabot> Not in scope: data constructor ‘Free’
12:34:50 <lambdabot> Not in scope: data constructor ‘Roll’
12:35:34 <kaidelong> @type fix $ \self -> case x of { Pure a -> return a; Free a -> a >>= self }
12:35:35 <lambdabot>     Not in scope: data constructor ‘Pure’
12:35:35 <lambdabot>     Perhaps you meant variable ‘pure’ (imported from Control.Applicative)
12:35:35 <lambdabot> Not in scope: data constructor ‘Free’
12:36:00 <kaidelong> I guess I better right this down correctly
12:39:53 <byorgey> kaidelong: yes, it is possible.  Think of  Free f a   as building some abstract syntax where the leaves are playing the role of 'return' and the nodes are playing the role of 'join'
12:40:15 <byorgey> kaidelong: so the nicest way to write that function is to first write a function   foldFree :: Functor f => (a -> r) -> (f r -> r) -> Free f a -> r
12:40:22 <byorgey> and then your function is just   foldFree return join
12:45:28 <aphocus> chpatrick, my only conclusion is one of the packages is broken.
12:47:55 <frerich> Hm, is there a common english word for a 3-tuple of statistics where each tuple element is the statistic for some time in the past? Like, (t0,t1,t2) where t0 is the statistic over the last 6 months, t1 over the last 12 months and t2 over all time?
12:48:21 <frerich> Histogram is something different, I guess...
12:49:52 <frerich> E.g. as in 'data X a = X { recent :: a, past :: a, allTime :: a ' -- the part I'm missing is a good name for 'X'. :-}
12:50:56 <chpatrick> history?
12:51:13 <frerich> Hm, history...
12:51:47 <kaidelong> okay well, when I tried that, it would not let me use >>= for that
12:52:00 <kaidelong> "unification would give infinite type"
12:53:31 <Peaker> Hey, "stack install" seems to install the shared/data files into the project's .stack-work, and not ~/.local or some more sensible location. Is there any way to get better "stack install" behavior?
12:53:59 <Peaker> I'm referring to files mentioned in the "data-files:" section in .cabal
12:54:22 <hodapp> might have to take that up with #haskell-stack
12:59:13 <delYsid`> argh, "sequence . map g . init . tails" is only almost what I need.  I need a way to handle arbitrarily long chunks at once, instead of only generating n possibilities for each single list item... hm
12:59:52 <johnw> delYsid`: I don't exactly follow?
13:01:18 <refried_> i'm trying to learn how to use Control.Exception.catch;  I'm getting this error https://gist.github.com/refried/76ca2d8eb6f45285ca48 and don't understand what it's telling me, or how to fix
13:01:31 <delYsid`> right now, for each element of the input list, I generate a list of possibilities.  seuqnece does the magic for me, generating the list of all concatenated possibilities.
13:01:33 <delYsid`> thats what I have.
13:01:53 <delYsid`> but I will need to be able to "lookahead", i.e., consume and produce arbitrarily long choices.
13:02:25 <delYsid`> note, the structure of the list is never changed, only the length of the choice should be possibly something else then 1
13:03:15 <clrnd> refried_, catch is polymorphic, you need to choose an Exception type
13:03:33 <refried_> clrnd, this is gonna sound even dumber, but: how do I do that?
13:03:43 <clrnd> refried_, it's not dumb at all
13:03:49 <clrnd> you can say it like this
13:04:05 <clrnd> > read "5" :: Int
13:04:07 <lambdabot>  5
13:04:11 <clrnd> > read "5" :: Float
13:04:13 <lambdabot>  5.0
13:04:19 <clrnd> in your case
13:04:36 <refried_> i guess my example isn't great because there's nothing to catch
13:04:46 <refried_> I was going to pair it with a call to `error` someplace
13:05:22 <clrnd> E.catch (println 3) (\x -> println x :: SomeException -> IO ())
13:05:38 <refried_> but the exception type for `error` isn't in its type signature.  i can look up the source
13:06:05 <delYsid`> johnw: Does that make *any* sense?
13:06:10 <clrnd> error is ErrorCall
13:06:15 <refried_> oh
13:06:30 <refried_> that makes sense 
13:06:41 <refried_> Thanks for the help
13:07:53 <sgeisenh> > read "5"
13:07:55 <lambdabot>  *Exception: Prelude.read: no parse
13:08:07 <Ankhers> > read "5" :: Int
13:08:09 <lambdabot>  5
13:08:12 * hackagebot diagrams-lib 1.3.0.4 - Embedded domain-specific language for declarative graphics  https://hackage.haskell.org/package/diagrams-lib-1.3.0.4 (BrentYorgey)
13:09:56 <clrnd> > read "5" :: Char
13:09:58 <lambdabot>  *Exception: Prelude.read: no parse
13:11:23 <clrnd> btw that doesn't work, it needs extra parens
13:11:29 <clrnd> E.catch (println 3) ((\x -> println x) :: SomeException -> IO ())
13:12:03 <kaidelong> byorgey: do I not need (forall r. f r -> r)?
13:12:10 <kaidelong> instead of (f r -> r)?
13:12:21 <Peaker> println 3 `E.catch` \x@E.SomeException {} -> println x
13:13:27 <kaidelong> I'm getting stuck on the second case for foldFree
13:14:01 <kaidelong> we have an (a -> r), a (f r -> r), and a (f (Free f a))
13:15:04 <kaidelong> I need a way to go from (a -> r) to (FreeMonad f a -> r)?
13:15:20 <kaidelong> but how would that work...
13:15:53 <clrnd> that too, nice one
13:18:21 <byorgey> kaidelong: no, just  f r -> r.
13:19:02 <byorgey> kaidelong: right, you have an  (a -> r), an  (f r -> r), and an  (f (Free f a)) and you need to produce an r
13:19:37 <kaidelong> and we know Free is a functor and monad and that f is a functor
13:19:51 <byorgey> good point, that's important too
13:20:19 <exio4> well, foing from "f (Free f a)" to "f r" probably helps, doesn't it? 
13:20:26 <kaidelong> going by the hole-driven approach I got as far as
13:20:29 <kaidelong> g _
13:20:34 <kaidelong> where g is the f r -> r
13:20:34 <byorgey> exio4: it sure does
13:20:45 <byorgey> kaidelong: good, that's on the right track
13:20:49 <kaidelong> oh, I guess I can't really do that either, f _ works too
13:20:53 <kaidelong> both return r
13:21:05 <byorgey> yes, but f is not going to be very helpful here
13:21:28 <byorgey> the idea is that you use the (a -> r) function to process the leaves and the  (f r -> r) function to process the branch nodes
13:22:34 <kaidelong> I really need an interactive haskell environment
13:24:55 <kaidelong> oh right, I have foldFree, too
13:24:59 <Cale> kaidelong: Yeah, it would be really cool if GHC had some kind of interactive mode where you could put in expressions and have them evaluated
13:26:27 <kaidelong> foldFree f g :: Functor f => Free f a -> r
13:26:50 <kaidelong> g (foldFree f g x)
13:27:43 <kaidelong> oh right, I can't do that
13:27:47 <kaidelong> but I can do
13:27:58 <kaidelong> g (foldFree f g <$> x)
13:28:13 * hackagebot diagrams-cairo 1.3.0.4 - Cairo backend for diagrams drawing EDSL  https://hackage.haskell.org/package/diagrams-cairo-1.3.0.4 (BrentYorgey)
13:29:53 <ReinH> Does this function exist anywhere? consume n = fmap (splitAt n) get >>= \(xs,ys) -> put ys >> return xs  ? It consumes and returns the first n elements from a list in a state monad.
13:30:44 <Cale> Haskell-Clippy: It sounds like you're trying to write a parser combinator library, would you like some help?
13:30:53 <ReinH> Cale: :)
13:31:16 <ReinH> In fact I'm trying to not incur a dependency on a parser combinator library since this is the only thing I need to do.
13:31:21 <ReinH> that is parser-y
13:31:45 <byorgey> ReinH: there is the 'supplies' function from http://hackage.haskell.org/package/monad-supply-0.6/docs/Control-Monad-Supply.html  which is similar
13:31:47 <ReinH> So I suppose based on that rationale that I should just write the function.
13:32:05 <Cale> Yeah, I don't know if it has a name elsewhere.
13:32:24 <byorgey> but that's specifically using a new Supply monad instead of State
13:32:42 <byorgey> but if that's the only way you ever interact with your state you could just use Supply instead of State
13:32:52 <ReinH> byorgey: Right, although SupplyT is just a newtype'd state :)
13:32:58 <byorgey> of course =)
13:33:12 <kaidelong> so this thing is basically saying
13:33:13 * hackagebot active 0.2.0.6 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.6 (BrentYorgey)
13:33:25 <kaidelong> mmm
13:33:33 <kaidelong> is (f r -> r) a co-algebra?
13:33:36 <kaidelong> it looks kind of like it
13:33:36 <byorgey> ReinH: but the constructor is not exported
13:33:39 <ReinH> byorgey: I'm basically doing parseHeader = evalState (Header <$> consume 100 <*> consume 8 <*> ...)
13:33:43 <byorgey> kaidelong: no, it is an f-algebra
13:33:45 <kaidelong> but that would be (forall r. f r -> r)
13:33:49 <monochrom> kaidelong: thank you for the "Monad f => Free f a -> f a" question. (I call it "down".) it inspires me to define liftIO :: IO a -> Free IO a, then watch how down happily undoes liftIO.
13:34:07 <byorgey> kaidelong: an f-coalgebra would be  r -> f r
13:34:09 <ReinH> byorgey: So yes, supply would absolutely work, but I think I'll just write the one-liner :)
13:34:17 <ReinH> thanks though!
13:34:20 <byorgey> ReinH: you have judged correctly =)
13:34:41 <ReinH> :D
13:34:41 <monochrom> byorgey: thank you for the foldFree answer. it inspires me to simply define "fmap h = foldFree (Free . h) Roll" and "x >>= k = foldFree k Roll x"
13:34:47 <byorgey> kaidelong: no, an f-algebra is a particular choice of a concrete type r and a function  f r -> r.  it is emphatically not  (forall r. f r -> r)
13:35:06 <byorgey> monochrom: yep, nice =)
13:35:17 <kaidelong> byorgey: that was just an error in terms of timing, I meant that to have a coalgebra you'd need that, so it was something else
13:35:32 <monochrom> in fact, it inspires me to simply attempt "fmap h = foldFree _ _" and "x >>= k = foldFree _ _ x" and ask GHC for guidance.
13:35:33 <kaidelong> I've not read up on F-algebras yet
13:35:38 <byorgey> ok.
13:35:43 <kaidelong> that's what I was doing now
13:36:03 <byorgey> monochrom: hehe, that probably works too
13:36:32 <shachaf> monochrom: It has many names. I called it "monad" once. I think the package calls it "retract".
13:37:04 <shachaf> You can have class Functor m => Monad m where retract :: Free m a -> m a
13:38:15 <refried_> if I import Debug.Hood.Observe, shouldn't     observe "foo" (*) 1 2    print more to my screen than just "2" ?
13:38:26 <refried_> (i'm a newbie)
13:38:43 <refried_> s/screen/console   i'm running this in ghci
13:38:52 <refried_> 7.10.2
13:40:09 <kaidelong> wikipedia definition of F-algebra seems to be exactly "(r, f r -> r)"
13:40:49 <kaidelong> and apparently these form a category
13:41:19 <ReinH> kaidelong: Be careful, the tuple mixes what in Haskell are type and value level expressions
13:41:52 <ReinH> Wait no, that's not true
13:41:56 <kaidelong> oh, so r is not the type "r" here, but a specific element of r?
13:42:11 <ReinH> objects are types, so (r, f r -> r) is an f-algebra for some concrete r
13:42:27 <ReinH> or rather, types are objects
13:42:30 <ReinH> kaidelong: sorry
13:42:32 <ReinH> ignore me
13:42:36 <kaidelong> what would a morphism be in the category of F-algebras?
13:43:45 <byorgey> kaidelong: a morphism   from (f r -> r)   to  (f s -> s)   is a morphism  r -> s  in the underlying category which makes the relevant square commute
13:44:03 <kaidelong> is this category expressible in Haskell?
13:44:21 <byorgey> feel free to ask if you are not sure which square I mean, I didn't want to draw a commuting square in IRC =)
13:44:41 <kaidelong> I think wikipedia has that square
13:44:46 <byorgey> kaidelong: it depends what you mean by "expressible", but sure
13:44:47 <kaidelong> so I'm looking at it right now
13:44:51 <byorgey> fair enough =)
13:44:54 <kaidelong> anyway I think I see how it works
13:45:23 <kaidelong> if you have (a -> b) you can just compose that covariantly into (f a -> a) to get (f a -> b)
13:45:29 <byorgey> ReinH: you were right about mixing type & value level
13:45:33 <ReinH> kaidelong: What I meant was that you're using a tuple value to store types. Sorry for confusing you.
13:45:48 <byorgey> an f-algebra is a choice of a *type* r  and a  *value* of type   f r -> r
13:45:49 <ReinH> Think of it as type Algebra f r = f r -> r
13:45:50 <kaidelong> ReinH: well, it was meant to be a tuple type
13:45:57 <ReinH> the carrier, r, is known from the type
13:46:29 <ReinH> byorgey: That's what I get for doubting myself. I'll make sure I never do that again.
13:46:33 <byorgey> hehe
13:46:59 <kaidelong> actually
13:47:09 <kaidelong> why would this work with a covariant functor
13:47:22 <kaidelong> how do you get f b -> b from f a -> a and a -> b
13:47:23 <emmanuel_erc> hello there! Has anyone worked with the hmatrix library before?
13:47:28 <kaidelong> unless f is a contravariant functor
13:48:47 <ReinH> kaidelong: you have f a -> a, f b -> b, a -> b. f is a functor, so you can get an f a -> f b from the a -> b by applying f
13:48:59 <ReinH> so you can either go f a -> f b -> b, or f a -> a -> b
13:49:05 <ReinH> and that square commutes
13:49:57 <emmanuel_erc> The hmatrix library permits an inclusion of numeric literals in type signatures, primarily, for explicitly stating a matrix's dimensions.
13:50:26 <mniip> emmanuel_erc, it's not the library
13:50:31 <mniip> it's the TypeLits extension
13:50:48 <emmanuel_erc> Yeah, I should have said that the right way.
13:50:52 <mniip> :k 1
13:50:54 <lambdabot> GHC.TypeLits.Nat
13:51:08 <emmanuel_erc> mniip: It is possible to evaluate an expression in the type signature?
13:51:15 <mniip> yes
13:51:32 <kaidelong> categories are transitively closed, by composition, right?
13:51:37 <emmanuel_erc> My love for haskell is increasing?
13:51:41 <mniip> :t GHC.TypeLits.natVal
13:51:41 <emmanuel_erc> ? --> !
13:51:42 <lambdabot> GHC.TypeLits.KnownNat n => proxy n -> Integer
13:51:54 <emmanuel_erc> wow
13:52:00 <emmanuel_erc> I am going to try this out.
13:52:03 <kaidelong> since the morphisms of this category are just (a -> b) I imagine all the relevant laws follow from those for Set
13:52:36 <ReinH> kaidelong: composition of f and g  gives a new arrow f . g
13:52:40 <mniip> emmanuel_erc, are you familiar with Proxy
13:52:44 <ReinH> so you have more than transitive closure
13:53:14 * hackagebot force-layout 0.4.0.3 - Simple force-directed layout  https://hackage.haskell.org/package/force-layout-0.4.0.3 (BrentYorgey)
13:53:23 <ReinH> every object in the transitive closure of A also has an arrow with domain a and codomain of that object
13:53:29 <emmanuel_erc> mniip: I am not 
13:53:30 <ReinH> s/domain a/domain A
13:54:12 <mniip> emmanuel_erc, Proxy is a dummy value tagged with some type entity (doesn't have to be a concrete type)
13:54:18 <mniip> for example,
13:54:22 <ReinH> kaidelong: btw here's the commutative square for f-algebras that I described https://upload.wikimedia.org/wikipedia/commons/3/3a/F_algebra.svg
13:54:29 <mniip> :t Proxy :: (Proxy Int)
13:54:30 <lambdabot> Proxy Int
13:54:36 <mniip> :t Proxy :: (Proxy Functor)
13:54:38 <lambdabot> Proxy Functor
13:54:41 <mniip> :t Proxy :: (Proxy 1)
13:54:42 <lambdabot> Proxy 1
13:54:42 <kaidelong> ReinH: yup, that's the one
13:55:26 <ReinH> byorgey: we need some modern chat room technology that lets us easily draw diagrams
13:55:35 <mniip> emmanuel_erc, natVal takes such object
13:55:41 <emmanuel_erc> mniip: I see. So the 'proxy' is a dummy value for the compiler to evaluate at runtime?
13:55:42 <hodapp> ReinH: has Slack this ability?
13:55:50 <mniip> emmanuel_erc, not at runtime
13:55:53 <ReinH> hodapp: well, it has more ability to show things inline
13:55:56 <shachaf> Something like https://twitter.com/copumpkin/status/302960443067101185
13:56:01 <ReinH> hodapp: so you could probably work something up
13:56:03 <mniip> at runtime, Proxy is identical to ()
13:56:06 <hodapp> of course I've not logged into Slack in... months
13:56:10 <mniip> it's the compile time that matters
13:56:14 <mniip> typechecking specifically
13:56:23 <ReinH> lol
13:56:42 <ReinH> hodapp: there's a functional programmning slack group
13:56:56 <exio4> mniip: well, Proxy# doesn't even exist at runtime :p 
13:57:01 <emmanuel_erc> hmm... I want to write my program (involving matrix manipulation, obviously) so that I can avoid writing a numeric literal and still be certain operations are consistent.
13:57:18 <mniip> exio4, sshhh
13:57:18 <byorgey> kaidelong: you can't actually get an  f b -> b  from an  f a -> a  and an  a -> b.
13:57:33 <emmanuel_erc> exio4: I guess that would make sense.
13:57:35 <Sonolin> what's the functional slack group?
13:57:40 <hodapp> ReinH: I'm on 'Becoming Functional' - different one?
13:57:51 <byorgey> kaidelong: but no one said the definition of a morphism in a category has to correspond to a function that lets you compute the target object from the source object.
13:57:58 <byorgey> it is just expressing a compositional relationship.
13:57:59 <kaidelong> byorgey: yeah, I just realized that
13:58:03 <kaidelong> you don't need it either
13:58:08 <byorgey> right
13:58:15 <mniip> exio4, but unbox kind
13:58:18 <kaidelong> you get the transitivity and associativity from the fact that (a -> b) exhibits that
13:58:25 <emmanuel_erc> by the way, is GHC.TypeLits.natVal supposed to be included with  GHC, I can't seem to find it.
13:58:27 <byorgey> ReinH: if only we had a way to easily and concisely describe diagrams using text
13:58:40 <ReinH> byorgey: if only
13:58:44 <ReinH> hodapp: functionalprogramming.slack.com
13:58:45 <mniip> emmanuel_erc, it is, you have to import GHC.TypeLits first
13:59:05 <ReinH> byorgey: SDL-based irc client that renders diagrams code inline pls
14:00:15 <hodapp> ReinH: thanks!
14:03:22 <byorgey> ReinH: I'll get one of my students right on that
14:04:28 <bitemyapp> byorgey: are you still at UPenn? Where did you go after finishing your PhD?
14:04:46 <thimoteus> sometimes if i make a change to my code and run `stack build` `stack exec myProject` the changes aren't compiled; sometimes they are. am i missing something obvious?
14:05:29 <ReinH> byorgey: Yes subject them to your wims.
14:05:40 <kaidelong> are the morphisms on F-coalgebra also (a -> b)?
14:05:51 <ReinH> *whims
14:06:11 <ReinH> kaidelong: You tell me.
14:06:46 <kaidelong> well you can do A -> F(A) -> F(B) and A -> B -> F(B)
14:06:49 <kaidelong> so I would think you could
14:06:59 <ReinH> Yep.
14:07:19 <ReinH> that's the square for f-coalgebras
14:07:52 <kaidelong> just to make a complete guess here
14:08:11 <kaidelong> would the equivalent transformation for cofree comonads take an F-coalgebra as a parameter?
14:08:14 * hackagebot diagrams-contrib 1.3.0.6 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.3.0.6 (BrentYorgey)
14:08:39 <byorgey> bitemyapp: I was at  http://www.williams.edu  for a year, now I have just moved to Arkansas to start a tenure-track position at http://www.hendrix.edu
14:09:22 <ReinH> :t coiter
14:09:23 <lambdabot>     Not in scope: ‘coiter’
14:09:23 <lambdabot>     Perhaps you meant ‘writer’ (imported from Control.Monad.Writer)
14:09:25 <zaquest>  hi, could you please help me with cmdargs package http://lpaste.net/141206 can not figure out how to get rid of --showfails name for a flag. i think `explicit` annotation should do that and it works for one of flags, but not for --showfails
14:09:36 <ReinH> kaidelong: equivalent to what?
14:09:43 <bitemyapp> byorgey: awesome, congrats and good luck :)
14:09:43 <ReinH> kaidelong: I'm late to the party, sorry
14:09:48 <byorgey> bitemyapp: thanks =)
14:09:56 <ReinH> byorgey: congrats btw!
14:10:00 <byorgey> thanks ReinH!
14:10:02 <bitemyapp> byorgey: oh, could I ping you in query?
14:10:18 <byorgey> bitemyapp: of course
14:12:16 <kaidelong> ReinH: (Functor f) => (a -> r) -> (f r -> r) -> FreeMonad f a -> r
14:12:19 <kaidelong> dual to that
14:12:26 <kaidelong> I'm wondering if you might get something like
14:12:50 <ReinH> zaquest: as an aside, sums of records might eventually pose a problem for you. showEmpty becomes a partial function, for instance.
14:13:19 <kaidelong> (Functor f) => (a -> r) -> (r -> f r) -> a -> Cofree f r
14:13:25 <kaidelong> that doesn't look right
14:14:23 <kaidelong> mmm well
14:14:50 <zaquest> ReinH, ok, i'll remember that
14:15:10 <ReinH> kaidelong: something like this? coiter :: Functor f => (a -> f a) -> a -> Cofree f a
14:15:24 <kaidelong> build f g x = Cofree (f x, fmap (build f g) (g (f x))
14:16:29 <kaidelong> huh, that looks like an unfold
14:16:45 <kaidelong> I guess that's not a surprise, byorgey called the first thing he showed me foldFree
14:16:47 <ReinH> Yes. A co-fold. ;)
14:16:51 <kaidelong> so I guess this could be called unfoldCofree
14:16:58 <ReinH> for your cofree comonad.
14:17:22 <ReinH> build f g = fmap f . coiter g ?
14:17:35 <kaidelong> @src coiter
14:17:35 <lambdabot> Source not found. You untyped fool!
14:17:43 <ReinH> lambdabot doesn't know about free
14:17:52 <exio4> I remember reading "cofree comonad" when I was starting Haskell and thinking it was a joke, sometimes it feels that way 
14:17:55 <ReinH> wait
14:17:58 <ReinH> a -> r and r -> f r
14:18:06 <ReinH> so you need to apply a -> r in contravariant position
14:18:18 <byorgey> you need  r -> a
14:18:22 <byorgey> not a -> r
14:18:22 <ReinH> yeah
14:18:47 <byorgey> also, it should be   r -> Cofree f r
14:19:05 <kaidelong> mmm, what should the type look like?
14:19:11 <byorgey> so   Functor f => (r -> a) -> (r -> f r) -> r -> Cofree f a
14:19:44 <byorgey> hmm, actually, you don't need the  (r -> a)  at all
14:20:05 <ReinH> byorgey: coiter :: Functor f => (a -> f a) -> a -> Cofree f a :)
14:20:28 <carrotlord> that emoticon is not part of the code
14:20:30 <refried_> i'm trying to learn about stack overflows in haskell, but i haven't been able to achieve a stack overflow
14:20:59 <refried_> foldr (+) 0 [1..100000000] (from wiki.haskell.org/Stack_overflow) doesn't overflow for me
14:21:15 <kaidelong> refried_: try using foldl? although GHC should be smart enough not to let that overflow either
14:21:15 <refried_> neither does my naive foldRight implementation
14:21:15 <byorgey> refried_: try foldl instead of foldr
14:22:02 <refried_> foldl is supposed to be the solution to foldr's stack overflow potential;  it doesn't overflow for me either
14:22:15 <kaidelong> > foldl (&&) (replicate 1000000 True)
14:22:16 <lambdabot>      Couldn't match expected type ‘Bool’ with actual type ‘[Bool]’
14:22:16 <lambdabot>      In the second argument of ‘foldl’, namely
14:22:16 <lambdabot>        ‘(replicate 1000000 True)’
14:22:27 <kaidelong> > foldl (&&) True (replicate 1000000 True)
14:22:28 <lambdabot>  *Exception: stack overflow
14:22:32 <kaidelong> there we go
14:22:32 <refried_> i thought i'd use my own foldRight in case there was something special about Prelude.foldr, but all i get is the right answer
14:22:44 <ReinH> didn't ghc recently change the was the stack size is handled?
14:22:44 <monochrom> refried_: much has changed since then. these days GHC gives you very high stack limit or no limit. you need a bigger number to hit it.
14:22:50 <kaidelong> refried_: foldr in Haskell is weird and is often more efficient than foldl
14:22:51 <ReinH> yep
14:23:03 <ReinH> Well, foldl is almost never the right choice.
14:23:15 * hackagebot cqrs 0.9.1 - Command-Query Responsibility Segregation  https://hackage.haskell.org/package/cqrs-0.9.1 (BardurArantsson)
14:23:17 * hackagebot cqrs-types 0.9.1 - Command-Query Responsibility Segregation. Modules for the basic types.  https://hackage.haskell.org/package/cqrs-types-0.9.1 (BardurArantsson)
14:23:18 <drewbert> Don't let anyone tell you file encoding comes for free in haskell.
14:23:30 <kaidelong> > foldr (&&) True (replicate 1000000 True)
14:23:31 <lambdabot>  True
14:23:32 <ReinH> drewbert: why would anyone say that?
14:23:41 <refried_> kaidelong: no luck with foldl (&&) True (replicate 1000000 True) either ;-)
14:23:47 <kaidelong> there foldl blows the stack but foldr doesn't
14:24:19 <exio4> the easiest way to achieve a stack overflow is to put an insane limit on it when starting your program ./program +RTS -K2M or so 
14:24:20 <drewbert> kaidelong: ain't lazy evaluation interesting?
14:24:27 <exio4> refried_: you have too much ram available
14:24:33 <refried_> exio4 drat
14:25:16 <drewbert> ReinH: I've had people tell me things similar to that.  e.g. That the unicode situation in haskell was much better than in python.
14:25:26 <exio4> refried_: if you want to learn more about how GHC evaluates Haskell or so, I would recommend the fews papers on the STG and what not
14:26:11 <kaidelong> essentially the foldr case goes like True && foldr (&&) True [True,..] -> foldr (&&) True [True,..] -> True && foldr (&&) True [True,..] because it can use the definition of && to avoid buildign anything
14:26:26 <ReinH> drewbert: The unicode situation in Haskell is pretty good. I don't see how that implies that file encoding is free.
14:26:27 <kaidelong> in the case of foldl, it needs to build up the whole expression in an accumulating parameter
14:26:48 <ReinH> @where lazy
14:26:48 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
14:26:55 <ReinH> Suggest you just read that
14:26:59 <drewbert> ReinH: exactly
14:27:08 <kaidelong> foldl' avoids this problem by forcing the accumulating parameter so that it doesn't build up and that's also why left folds are usually used in other languages to avoid blowing the stack
14:27:22 <kaidelong> Haskell just does this backward and you generally use right folds to avoid blowing the stack
14:27:27 <ReinH> kaidelong: That doesn't make sense.
14:27:38 <ReinH> The stacks in Haskell and other languages are very different
14:28:06 <ReinH> Strict languages don't have the problem of building up chains of thunks because they don't have thunks.
14:28:07 <refried_> well, foldl' is certainly faster than foldl
14:28:41 <exio4> kaidelong: foldr (+) 0 isn't as nice as you are making it be though
14:28:41 <refried_> are there any standard debug functions for timing an evaluation?
14:28:57 <kaidelong> exio4: well, (+) is strict in both arguments
14:29:02 <aweinstock> ReinH: but in a strict scheme dialect, foldl uses tail recursion, and foldr doesn't
14:29:05 <kaidelong> I was using && as the example for that reason
14:29:19 <kaidelong> also (+) is problematic because the GHC optomizer can generally deal with it
14:29:33 <ReinH> aweinstock: Yes, the usual implementation of foldl is tail-recursive
14:29:48 <refried_> kaidelong: how can you tell whether a function is strict in its arguments?
14:29:55 <ReinH> aweinstock: but "other languages avoid blowing the stack by forcing the accumulator" doesn't make sense
14:30:03 <drewbert> fun fact: foldl' is implemented using foldr
14:30:04 <ReinH> other (strict) languages always force accumulators.
14:30:24 <ReinH> If there's a benefit to foldl in strict languages, it's probably due to TCO
14:30:28 <kaidelong> ReinH: wasn't that what I said..?
14:30:37 <refried_> ReinH right
14:30:51 <ReinH> kaidelong: The point is that left and right folds behave the same regarding forcing things in languages that always force things
14:30:55 <aweinstock> kaidelong: probably, but with some important yet subtle distinctions drawn
14:31:11 <ttt_fff> Does anyone have bindings for Haskell <-> Torch (LuaJit) ?
14:31:25 <kaidelong> well I was trying to say that left folds tend to be more efficient in languages that force things by default
14:31:26 <ReinH> So that's not a reason to prefer left folds
14:31:34 <kaidelong> but haskell is not such a language
14:31:41 <kaidelong> but there is foldl' which works as if it were
14:31:46 <monochrom> to add to your violent agreement:
14:32:09 <kaidelong> and yes, the reason would be because foldl is tail recursive
14:32:10 <aweinstock> kaidelong: but you have to be careful, since foldl' doesn't deeply force the accumulator, only evaluates to WHNF
14:32:12 <ReinH> In runtimes that don't perform TCO I wouldn't expect there to be uch difference.
14:32:15 <ReinH> *much
14:32:50 <kaidelong> well, in runtimes without TCO you could still implement foldl using GOTO
14:32:53 <monochrom> both sml and haskell define foldl by syntactically identical code
14:32:58 <kaidelong> or whatever GOTO equivalent there is
14:33:02 <aweinstock> (e.g. average = uncurry (/) . foldl' (\(sum, count) x -> (sum+x, count+1)) (0,0))
14:33:11 <kaidelong> just manually do the TCO
14:33:18 <monochrom> but that syntactic identicalness is highly deceiving. they have almost opposite semantics.
14:33:24 <aweinstock> TCO isn't a runtime thing, it's a compile-time thing
14:33:43 <kaidelong> aweinstock: that's why people perjoratively talk about "hand-compiling"
14:33:51 <sedeki> what happens if your haskell file is named Something.hs and you write "module AnotherThing where" in it? can you still load it?
14:33:54 <ReinH> aweinstock: yep, mental typo :(
14:34:04 <monochrom> sedeki: to a large extent no
14:34:10 <kaidelong> I didn't see it as a typo
14:34:17 <kaidelong> Java Runtime makes TCO almost impossible to actually do
14:34:20 <monochrom> most compilers insist filename to match module name
14:34:22 <ReinH> aweinstock: there's a TCO in GHC that is performed by the RTS
14:34:26 <drewbert> I stick foldl all over my code because lazy evaluation hurts my brain.
14:34:42 <sedeki> monochrom ok!
14:34:42 <kaidelong> which is why Scala has the unique distinction of being a "functional language" with no TCO
14:34:50 <aweinstock> kaidelong: because the JVM doesn't have cross-procedure jump instructions
14:35:15 <bitemyapp> drewbert: ???
14:35:17 <kaidelong> drewbert: why not foldl' then?
14:35:21 <aweinstock> if x86 had the same restriction, that wouldn't make it a runtime property (I think?)
14:35:29 <drewbert> kaidelong: foldl' where possible!
14:35:38 <Cale> I find it weird to call something TCO when there is no call stack
14:35:41 <monochrom> foldl is not going to suppress lazy evaluation
14:35:50 <ReinH> kaidelong: In one sense, so does GHC, since either no TCO is performed or everything is a tail call and all calls are optimized, depending on how you want to look at it. ;)
14:36:04 <aweinstock> Cale: I think we were digressing to how things like scheme are implemented
14:36:08 <Cale> I see
14:36:11 <exio4> GHC uses stacks in a different sense 
14:36:43 <Cale> Yeah, GHC's stack is perhaps better referred to as a pattern match stack, or evaluation stack
14:36:43 <ReinH> It definitely doesn't do TCO in the way you might expect for from implementations with a call stack.
14:36:47 <ReinH> s/for from/from
14:36:55 <drewbert> kaidelong: do you know of a foldlM' ?
14:37:15 <ReinH> drewbert: I want to say that that's not possible, but idk
14:37:29 <aweinstock> @src foldlM
14:37:29 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
14:37:35 <aweinstock> @src foldM
14:37:35 <lambdabot> foldM _ a []     = return a
14:37:35 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
14:37:36 <kaidelong> @type traverse
14:37:37 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:38:13 <aweinstock> @src foldM'
14:38:13 <lambdabot> Source not found.
14:38:13 <monochrom> if lazy evaluation hurts your brain, then either you should stay ignorantly bliss and not care, or use sml if you care.
14:38:14 <ReinH> Cale: Yeah, but then you have a bunch of people like dons and simonm who talk about TCO and tail-recursion in things like published books.
14:38:16 <ReinH> :/
14:38:27 <drewbert> foldlM is defined in Data.Foldable
14:38:48 <aweinstock> monochrom: any reason why sml in preference to ocaml?
14:39:11 <kaidelong> nicer syntax and stdlibs
14:39:12 <monochrom> it is closer to haskell. ocaml has extra stuff and so further from haskell
14:39:14 <ReinH> Cale: So most of the time when I say "GHC doesn't do anything special for tail recursion" I get someone quoting RWH at me.
14:39:26 <monochrom> furthermore sml has a well-defined operational semantics
14:39:58 <kaidelong> the way I think of haskell evaluation is in-place replacement of expressions with equivalent expressions
14:40:04 <kaidelong> based on function definitions
14:40:06 <monochrom> so for example "haskell does lazy evaluation" is in principle a wrong statement but "sml does eager evaluation" is a true statement without even knowing which compiler (because all compilers are required to)
14:40:08 <exio4> ReinH: and thus, you link to some of the papers explaining the STG?
14:40:20 <kaidelong> I'm not sure how closely related this is to TCO, but this is how I generally think of TCO, too
14:40:29 <aweinstock> "haskell does non-strict evaluation" is always true?
14:40:36 <exio4> aweinstock: it is
14:40:51 <monochrom> yes but I wouldn't use the word "evaluation" at the level of non-strictness.
14:41:21 <ReinH> exio4: I usually link to the fast curry paper
14:41:26 <kaidelong> aweinstock: GHC will use strict evaluation if it can prove that the lazy version is indistinguishable from the strict one
14:41:36 <emmanuel_erc> hey mniip, are you still there?
14:41:39 <kaidelong> and it also decides that this would be an optomization
14:41:52 <kaidelong> it's not always better to make functions eager even if they are strict
14:42:09 <mniip> hi
14:42:24 <kaidelong> also GHC will use strict evaluation if you explicitly tell it to
14:43:14 <emmanuel_erc> I think I understand how Data.Proxy works now, but the thing is the value of the expression I want to evaluate may only be known at runtime. To be concrete, no pun intended, I want to know a matrix's size and use it without explicit knowledge of it (if that makes sense).
14:43:51 <mniip> impossible
14:44:09 <ReinH> kaidelong: basically, GHC performs normal-order evaluation which means redexes are always in "tail position", so it's kind of a red herring to talk about "tail recursion" as if something special were happening then the redex being reduced is a recursion
14:44:09 <mniip> wellllll singletons
14:44:14 <emmanuel_erc> Well, that clears up that confusion.
14:44:22 <mniip> but you're going to have "fun"
14:44:26 <mniip> if you try singletons
14:44:37 <emmanuel_erc> Do you mind I message you privately?
14:45:29 <voidzero> anyone here who has worked with Text.Toml ?
14:45:31 <emmanuel_erc> I'll look up singletons.
14:46:15 <emmanuel_erc> In the hmatrix library suite, there is a library that let's you perform matrix computations without explicit stating a matrix's dimensions.
14:46:28 <ReinH> s/then the/when the
14:47:28 <emmanuel_erc> Here's an example:
14:47:28 <emmanuel_erc> average :: (KnownNat n, 1<=n) => R n -> "the symbol for a real number"
14:47:28 <emmanuel_erc> average = (<.> (1/dim))
14:48:57 <emmanuel_erc> I want to do something similar to this. Now that I think of it, I may just email the libary maintainer.
14:49:03 <monochrom> if you want to talk of TCO, it's best done this way: "after GHC generates Cmm code, does that Cmm code look like someone did TCO on it?" (the answer is "yes")
14:49:27 <mniip> emmanuel_erc, oh you can do that
14:49:28 <monochrom> this brings us to the novel notion of "observationally TCOed"
14:49:43 <mniip> average knows the matrix size at compile time
14:49:47 <mniip> through n
14:49:56 <emmanuel_erc> yes...
14:50:10 <jet> Hi! Total noob here, so please bear with me. I thought that to play around in ghci, I'd like to get a sha256 hash of a string, so I found the Codec.Digest.SHA.Monad module. Now I'm a bit confused as to how can I get the digest from a string such as "hello"
14:50:29 <monochrom> this is clearly an empirical view, rather than going through GHC source code and finding a typical TCO algorithm there. no, things are not going to be as simple as that. this is the real world.
14:50:36 <emmanuel_erc> I don't think it nows the exact value for n, but the structural dependencies are resolved at compile time... that is if I am understanding things correctly.
14:50:51 <monochrom> or perhaps s/simple/clear cut/
14:51:27 <jet> It looks like the right function would be runSHA, which has a signature like this: 
14:51:37 <jet> Length -> (forall s. SHA s a) -> (a, ByteString)
14:52:25 <mniip> emmanuel_erc, what exactly does your function's type signature look like
14:52:33 <monochrom> approximately half of what you know about optimizing imperative code can go out of the window when you look at Haskell or GHC
14:52:39 <emmanuel_erc> mniip: There are four main branches in hmatrix: Data, Devel, HMatrix, and Static. It is that last one that has static type checking on matrix dimensions.
14:52:48 <emmanuel_erc> Ok, give me one second.
14:53:40 <jet> So what I did in ghci was 
14:54:08 <ReinH> jet: Try https://hackage.haskell.org/package/cryptohash-0.11.6/docs/Crypto-Hash-SHA256.html
14:54:14 <mniip> emmanuel_erc, either you know the matrix size at compile time, or you know it at runtime, not both
14:54:16 <ReinH> with hash or hashlazy, depending
14:54:33 <jet> Cool, I'll check that out. Thanks ReinH 
14:54:34 <emmanuel_erc> sorry, I am coming with the information.
14:54:47 <emmanuel_erc> Ultimately, the matrix's size will be determined at runtime.
14:55:01 <ReinH> jet: provides an easy-to-use pure implementation
14:55:08 <exio4> mniip: well, you can use exisential types and constraints for this 
14:55:15 <mniip> ew
14:55:31 <monochrom> that is more runtime and less statictime
14:56:48 <exio4> withInt :: Int -> (forall n. (KnownNat n, 1 <= n) => GNat n -> r) -> r -> r or whatever
14:56:52 <monochrom> indeed my brief playing with KnownNat says that it downgrades statictime to runtime. not the other way round.
14:56:55 <emmanuel_erc> Matrix.Double -> Matrix Double (unimpressive, I know). Essentially, I want to compute the mean of the rows, and compute the outer product of that vector with the ones vector
14:57:09 <mniip> emmanuel_erc, then you can use size'
14:57:18 <mniip> no need for type magic
14:57:25 <emmanuel_erc> I am silly...
14:58:42 <prkc> hmm, if I do []==[] in ghci I get True, but if try to compile f::Bool  f= []==[] I get a compile error
14:58:50 <emmanuel_erc> I am sorry for making things more complicated than necessary.
14:59:01 <emmanuel_erc> but thank you for answering my laborious questions.
14:59:03 <prkc> I don't really understand why there is a difference
14:59:09 <monochrom> in ghci, you get silent defaulting to the type [()], which allows ==
14:59:36 <prkc> monochrom: oh ok, thanks
14:59:39 <monochrom> when compiling, there is no such defautling, [] has type [a] with "a" unknown. no one knows how to do ==
15:00:38 <jet> This doesn't look like a usual hash, though: ",\242M\186_\176\163\SO&\232;*\197\185\226\158\ESC\SYN\RS\\\US\167B^s\EOT3b\147\139\152$"
15:01:44 <monochrom> it looks like using "show" on a ByteString that contains a hash
15:02:39 <ReinH> jet: the hex string is a display of the hash, not the hash itself
15:02:50 <ReinH> (that you usually see with, e.g., git)
15:02:57 <monochrom> Bytestring's Show instance tries to give you String notation rather than number notation
15:03:50 <jet> So how'd I get a regular git ish hash from it?
15:03:59 <monochrom> oh, you were expecting "98aeffcghb0011"? yeah, that's a whole new level of WYSI not WYG.
15:05:19 <ReinH> https://hackage.haskell.org/package/base16-bytestring-0.1.1.6/docs/Data-ByteString-Base16.html
15:05:41 <ReinH> the hex string is a base16 encoding of the hash
15:05:56 <ReinH> λ> encode ",\242M\186_\176\163\SO&\232;*\197\185\226\158\ESC\SYN\RS\\\US\167B^s\EOT3b\147\139\152$"
15:06:04 <ReinH> "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
15:06:13 <monochrom> that is huge :)
15:06:20 <ReinH> SHA256 eh
15:06:31 <monochrom> I see
15:07:27 <ReinH> monochrom: just double checked, it's correct
15:07:52 <jet> Cool... a bit of work just to hash "hello"!
15:09:25 <sedeki> are types first class objects in haskell? like, can you pass a type to a function?
15:09:41 <dario> sedeki: mostly no
15:09:53 <sedeki> i'm thinking about how parametrized type constructors work
15:10:18 <jet> That'd be Idris, right?
15:10:32 <monochrom> that can work by you imagining "pass a type to a function". but the computer doesn't have to actually do that.
15:10:54 <monochrom> the computer does, in practice, "forget the type altogether"
15:11:03 <sedeki> yeah
15:11:20 <ReinH> Which works because right before that it does "prove that it can forget the type altogether"
15:11:29 <benzrf> sedeki: there's kind of a value system at the type level independent of the normal value system
15:11:45 <monochrom> yeah, the type-checking phase checks consistency. afterwards, can throw away types
15:11:45 <ReinH> benzrf: I think we call that the "type system"?
15:11:46 <sedeki> so in a regular function (name?) you have to fully specify/pass all arguments to type constructors
15:11:51 <benzrf> ReinH: :)
15:12:03 <sedeki> ok
15:12:05 <benzrf> sedeki: what do you mean by that
15:12:30 <ReinH> benzrf: we also have a sort of type system at the kind level... ;)
15:13:17 * hackagebot wai-predicates 0.8.5 - WAI request predicates  https://hackage.haskell.org/package/wai-predicates-0.8.5 (ToralfWittner)
15:14:18 <monochrom> it is legitimate to think of "Just True" as "Just Bool True". you can do it, it is one mental model. you don't have to do it, it is not the only mental model.
15:14:36 <monochrom> guess what, look up "System F", it does that.
15:14:44 <benzrf> ReinH: ah, but the type system's type system is dependent
15:15:27 <sedeki> benzrf sorry, i'm just saying stupid stuff. i'm new to haskell
15:15:34 <monochrom> GHC has some intermediate phase that does it too. however, it is not exposed to you, you can't do the same your own Haskell code.
15:15:35 <sedeki> surprise
15:16:17 <monochrom> and it is only an intermediate phase. in later phases, like I said, those types are thrown away, in preparation for real code generation
15:17:06 <monochrom> i.e., "Just Bool True" becomes "Just True" again.
15:17:46 <monochrom> or rather, two machine words. the 1st machine word points to something standing for "Just", the second machine word points to something standing for "True".
15:18:02 <monochrom> (no machine word points to types)
15:20:15 <monochrom> furthermore, the thing that stands for "Just" is reused by all occurences of "Just". for example, if you have both "Just True" and "Just 4", both point to the same "Just".
15:21:00 <monochrom> so it is type erasure in the strongest sense
15:21:52 <monochrom> the goal of a compiler for a typed lambda calculus is to check your types and then compile to an untyped lambda calculus :)
15:22:42 <nolrai666> Isn't it actually just one machine word, a tagged pointer?
15:22:55 <nolrai666> Or am I confused..
15:23:17 <monochrom> you are confused.
15:23:18 * hackagebot composition-extra 2.0.0 - Combinators for unorthodox structure composition  https://hackage.haskell.org/package/composition-extra-2.0.0 (athanclark)
15:24:09 <nolrai666> Hmm. Then what does tagging do?
15:25:25 <athan> bitemyapp: i'm pushing a new version for composition-extra, it doesn't add anything new, I just forgot there were breaking changes in 1.3
15:25:30 <athan> just fyi :)
15:26:36 <Iceland_jack> <monochrom> oh, you were expecting "98aeffcghb0011"? yeah, that's a whole new level of WYSI not WYG.
15:26:36 <Iceland_jack> That is basically what cryptohash does, the show instance is a hex encoding of the digest
15:27:02 <monochrom> that's convenient
15:27:08 <Iceland_jack> ghci> hash "hi" ∷ Digest SHA1
15:27:09 <Iceland_jack> c22b5f9178342609428d6f51b2c5af4c0bde6a42
15:27:23 <Iceland_jack> Agreed
15:28:07 <Iceland_jack> Then you have
15:28:07 <Iceland_jack>     digestToBytestring    :: Digest a -> ByteString
15:28:07 <Iceland_jack>     digestToHexBytestring :: Digest a -> ByteString
15:28:18 <ezrios1> what is the hip extensible records library nowadays?
15:28:39 <athan> vinyl?
15:29:45 <hackrilege> does anyone know what a coherent sheaf is in the context of the krull dimension related to the decomposition of automa on monoids?
15:29:58 <ezrios> athan: how does it compare to Data.Extensible?
15:30:16 <athan> idk :\ never used either actually
15:30:22 <ezrios> ah
15:30:35 <ezrios> I just grew frustated with Data.Extensible after wrestling with type level programming too much
15:32:13 <athan> ezrios: I can't say I have had a use for the methodology. It's like HList, but with subtyping integrated, right?
15:32:20 <athan> or is there any ordering to the records :s
15:37:30 <Bruuuuuuuno> Hi, is the C++ const considered a monad?
15:43:37 <johnw> Bruuuuuuuno: in an almost completely useless sense, I think it is
15:44:33 <johnw> in that, it's monadic nature has no runtime behavior at all, so you're not getting anything out of thinking of it as a monad
15:45:06 <johnw> and the function a -> const a, and const (const a) -> const a, are trivially simplified by the compiler during type-checking
15:46:39 <Bruuuuuuuno> I was explaining the c# async to a coworker today and he said "oh it's like the c++ const keyword", I was speechless hahaha
15:46:45 <monochrom> sounds like Free Identity
15:47:08 <johnw> monochrom: or even just newtype'd Identity, since everything in Haskell is already immutable
16:00:13 <kaidelong> what does C# async have to do with C++ const
16:00:33 <kaidelong> also which of the umpteenth "const"s was he talking about
16:00:39 <kaidelong> C++ uses that keyword for everything
16:01:18 <Bruuuuuuuno> c# async is a monad
16:01:26 <ReinH> kaidelong: umpteenth is an ordinal number, not a cardinal number :p
16:02:38 <Bruuuuuuuno> like if we return a value from a const function, it become a const value, and the bind seems to work too, So I was wondering if it was a monad
16:02:53 <kaidelong> C# async is implemented via continuation passing
16:03:10 <kaidelong> continuations are a kind of monad
16:03:14 <kaidelong> well
16:03:15 <kaidelong> they form one
16:03:31 <kaidelong> C# language doesn't have any way to express the concept of "Monad"
16:03:34 <ReinH> Identity is a monad, therefore everything is a monad.
16:03:40 <kaidelong> except maybe by doing weird type coercions
16:03:49 <ReinH> function application is a monad.
16:04:23 <kaidelong> it's kinda pointless to talk about things that are monads or not in languages that don't allow things like "forM_"
16:04:46 <kaidelong> except in the case of using Haskell-style syntax hooks, perhaps
16:04:53 <kaidelong> C# does have one of those, query expressions
16:05:06 <voidzero> but only today you will all find a monad under your chair !!!
16:05:15 <voidzero> \☺/
16:05:33 <ReinH> voidzero: <3
16:05:50 <voidzero> wahooo
16:05:59 <voidzero> ReinH :)
16:06:04 <Sonolin> is there any point to programming with monads in a non functional language though?
16:06:19 <Sonolin> from what little I understand it seems very centric to functional programming
16:06:21 <kaidelong> C++ lets you write things akin to "forM_"
16:06:36 <kaidelong> also pure functional and function are orthogonal, you might use monads in a purely functional language that isn't functional
16:06:44 <kaidelong> but AFAIK no one does this
16:07:17 <ReinH> ...
16:07:22 <kaidelong> haskell approach makes fine grained effects unpleasant to deal with
16:07:38 <kaidelong> imperative langs want fine grained effects if they want to go for the pure functional approach
16:08:43 <voidzero> it's all about the granularity, baby
16:08:45 <ReinH> imperative langs don't have first class effects of any grain size
16:09:01 <kaidelong> Koka, Disciple
16:09:53 <sedeki> is there a way in ghci to see type class hierarchy?
16:10:02 <sedeki> also, how do I run code in this channel?
16:10:07 <sedeki> via the bot
16:10:11 <kaidelong> prefix with >
16:10:23 <kaidelong> bot can also help you with the typeclasses, use @instances
16:10:37 <kaidelong> hierarchy is modelled by (Superclass t) => Subclass t
16:10:47 <kaidelong> so you'll look for "@instances Subclass"
16:10:52 <kaidelong> and see if you see something like that
16:11:02 <kaidelong> it's not a hierarchical system though
16:11:06 <geekosaur> typeclass hierarchy isn't really visualizeable... and also is less useful than you might hope, if you're expecting something really OOish
16:11:10 <kaidelong> so it's kind of iffy to use that word
16:11:16 <geekosaur> @where typeclassopedia
16:11:16 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
16:11:34 <geekosaur> ^ probably the best reference for typeclasses
16:11:40 <kaidelong> also it can go in both directions
16:12:45 <kaidelong> someone might say "class (Foo f) => Bar f" to mean "for something to be a Bar it has to be a Foo" or "instance (Foo f) => Bar f" to mean "if something is a Bar then it is also a Foo"
16:13:19 <kaidelong> err
16:13:25 <kaidelong> if something is a Foo then it is also a Bar
16:13:27 <kaidelong> I meant
16:14:16 <refried_> is there a shorter way to say (\a -> a+1) ?
16:14:21 <ReinH> refried_: (+1)
16:14:30 <ReinH> @google haskell sections
16:14:30 <lambdabot> https://wiki.haskell.org/Section_of_an_infix_operator
16:14:56 <refried_> ReinH: sorry, thanks — i had tried that but I also had an unrelated error, so I thought it wasn't working
16:25:13 <Cooler> what exactly does the $ operator do?
16:25:21 <kaidelong> nothing
16:25:32 <kaidelong> however
16:25:40 <kaidelong> it is useful syntactically because of its low precedence
16:26:18 <geekosaur> @src ($)
16:26:18 <lambdabot> f $ x = f x
16:26:28 <kaidelong> basically it wraps the stuff on the left and right in implicit parenthesis so that instead of (foo bar) (baz quux) you can do foo bar $ baz quux
16:26:34 <geekosaur> but lowest precedence, so it kinda acts like backwards parentheses
16:26:50 <ReinH> Cooler: f $ x means (f) (x).
16:27:06 <ReinH> This is ofc more useful when f and x are more complex expressions.
16:27:24 <ReinH> e.g., a b $ c d = (a b) (c d)
16:27:52 <Cooler> without the $ what would it look like?
16:28:02 <kaidelong> (a b) (c d)
16:28:07 <Cooler> (((a b) c) d)?
16:28:41 <Cooler> i mean what would it evaluate as normally
16:28:56 <kaidelong> oh as in
16:28:58 <Cooler> if you just did
16:29:01 <Cooler> a b c d
16:29:02 <kaidelong> what does "a b c d" become
16:29:09 <kaidelong> function application associates left
16:29:13 <kaidelong> so exactly what you thought, yes
16:29:19 <kaidelong> ((a b) c) d
16:29:37 <Cooler> i am not sure what (a b) c means though
16:29:56 <kaidelong> there is some contention on which direction implication in logic and function implication in lambda calculus should associate
16:30:12 <kaidelong> but in Haskell it is to the left
16:30:19 <Cooler> does that mean c is a function that takes a function (a b) as a input?
16:30:22 <kaidelong> function application*
16:30:34 <kaidelong> no, that means (a b) is a function that takes c as an input
16:30:51 <kaidelong> a is a function that takes b as an input and produces a function that takes c as an input
16:31:02 <Cooler> what if a doesn
16:31:09 <Cooler> what if a doesn't return a function
16:31:21 <Cooler> what if it returns an integer or bool
16:31:45 <ReinH> Cooler: then it would be a type error
16:33:17 <geekosaur> > sin 4 5
16:33:18 <lambdabot>      Could not deduce (Floating (a0 -> t))
16:33:19 <lambdabot>      from the context (Floating (a -> t), Num a)
16:33:19 <lambdabot>        bound by the inferred type for ‘e_145’:
16:33:44 <geekosaur> > chr 'a' 'b'
16:33:45 <lambdabot>      Couldn't match expected type ‘Char -> t’ with actual type ‘Char’
16:33:45 <lambdabot>      The function ‘chr’ is applied to two arguments,
16:33:45 <lambdabot>      but its type ‘Int -> Char’ has only one
16:34:01 <geekosaur> two type errors you might get for too many parameters
16:34:49 <geekosaur> on the other hand, supplying fewer is quite useful; it's called partial application and it gives you another function you can use elsewhere
16:35:38 <kaidelong> > iterate (+5) 1
16:35:40 <lambdabot>  [1,6,11,16,21,26,31,36,41,46,51,56,61,66,71,76,81,86,91,96,101,106,111,116,1...
16:36:49 <geekosaur> > let lc = map toLower in lc "HELLO"
16:36:50 <lambdabot>  "hello"
16:38:22 * hackagebot b9 0.5.13 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.13 (SvenHeyll)
16:40:46 <geekosaur> (and then there's Text.Printf.printf which uses typeclasses to take the number of parameters specified in the format string. it's moderately evil)
16:41:41 <ReinH> On a scale from 0 to GeneralizedNewtypeDeriving, how evil?
16:42:55 <geekosaur> hm. I think GND still has holes you can derive unsafeCoerce through, so nowhere near that evil. just a bit mind-boggling
16:44:06 <geekosaur> otoh if you want real evil, try to figure out how to partially apply printf. :)
16:44:11 <kaidelong> does Comonad imply Applicative? I would think it would...
16:44:58 <kaidelong> @type extend
16:44:59 <lambdabot> Not in scope: ‘extend’
16:45:07 <kaidelong> @type (<*>)
16:45:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:46:24 <kaidelong> fmap . extract  ?
16:47:28 <kaidelong> @type let extract = (undefined :: w a -> a) in fmap . extract
16:47:29 <lambdabot> Functor f => w (a -> b) -> f a -> f b
16:47:47 <kaidelong> that unifies
16:47:52 <exio4> geekosaur: just give it a type signature :p 
16:47:54 <ReinH> kaidelong: does it satify the laws?
16:48:01 <kaidelong> what were the laws again?
16:48:12 <RageD> hi guys-- does anyone have some insight into haskell loggers? I see both fast-logger and hslogger-- any thoughts?
16:48:38 <johnw> kaidelong: Comonad doesn't have "pure"
16:49:08 <johnw> RageD: logging is a dead simple front-end to fast-logger, if you just want application level logging in IO
16:49:10 <ReinH> well there's that
16:49:14 <dicioccio1> i was happy with hslogger in laborantin-hs RageD 
16:49:14 <johnw> http://hackage.haskell.org/package/logging
16:49:34 <kaidelong> johnw: oh, of course
16:51:33 <kaidelong> should Functor superclass Comonad?
16:51:33 <edwardk> class Functor f => Comonad f -- it already does
16:51:33 <kaidelong> I'll take that as a yes
16:51:33 <RageD> I'm mostly considering it for library use. Ideally, I'm looking for something like slf4j; a generic logging interface with priorities that the user can then use any logging impl that they want.
16:51:36 <johnw> RageD: that's pretty much what monad-logger is about
16:51:57 <RageD> johnw: ah, great. I'll take a look :)
16:52:01 <RageD> thanks
16:52:55 <johnw> one nice feature of monad-logger is that if your user chooses to executing the logging-enabled code using runNoLoggingT, it will compile out any logging calls in the final executable code
16:56:17 <refried_> Is there any shorter way to write \a b -> a + b + 1 ?
16:56:41 <johnw> @pl \a b -> a + b + 1
16:56:41 <lambdabot> flip flip 1 . ((+) .) . (+)
16:56:45 <johnw> not really
16:57:00 <refried_> hehe thanks anyway
16:57:11 <johnw> even (succ .) . (+1) is less than clear
16:57:19 <johnw> sorry, (succ .) . (+)
16:57:35 <refried_> yeah, I was trying to get something like that
16:57:39 <refried_> but you're right, i'll just stick with the original
16:57:41 <ReinH> You can take advantage of commutativity
16:57:46 <ReinH> @pl \a b -> 1 + a + b
16:57:46 <lambdabot> (+) . (1 +)
16:57:52 <refried_> oh hey
16:57:56 <ReinH> but it isn't better than \a b -> a + b + 2
16:58:00 <ReinH> or + 1, whichever
16:58:17 <refried_> yeah I was banging my head on (1+) . (+) but that doesn't work obviously
16:58:25 <ReinH> pointfree isn't automatically better than pointful
16:58:28 <refried_> *nod*
16:58:34 <ReinH> pointfree is better when you want to reason about composition
16:59:01 <ReinH> but \a b -> a + b + 1 isn't really using composition
16:59:29 <ReinH> I mean, it is, but it's mostly just application
17:00:04 <refried_> in Scala you can say (_ + _ + 1) but it's no big deal
17:00:15 <refried_> well, Scala would complain that it doesn't know how to do type inference on that
17:00:30 <refried_> unless it was already expecting the appropriate type
17:01:00 <ReinH> heh
17:07:16 <medicijnman> i am trying to rewrite a function to use foldr but i can't get it right. this is the declaration
17:07:16 <medicijnman> printLine :: [Int] -> String
17:07:32 <medicijnman> and this is the definition:
17:07:32 <medicijnman> printLine x = '+' : concatMap (\n -> replicate n '-' ++ "+") x
17:08:09 <medicijnman> typing printLine [5,6] yields "+-----+------+"
17:09:08 <johnw> why rewrite that to use foldr?
17:09:19 <Axman6> looks pretty clear to me
17:09:27 <Axman6> you coudl rewrite it to use >>= thought >_>
17:11:37 <medicijnman> johnw: because foldr is more efficient with large input?
17:11:52 <Welkin> does anyone in here use opaleye?
17:11:57 <johnw> medicijnman: I'm pretty sure that in this case, no list will necessarily exist at runtime
17:12:23 <Welkin> how do I actually connect to the database? The tutorial only covers how to define schema and run queries
17:12:39 <ReinH> medicijnman: I'd be more worried about ++ "+"
17:12:46 <Axman6> medicijnman: what makes you say that?
17:12:55 <Axman6> medicijnman: hint, you're already using foldr
17:13:35 <Axman6> @src concatMap
17:13:35 <lambdabot> concatMap f = foldr ((++) . f) []
17:13:40 <Axman6> D:
17:14:04 <medicijnman> Axman6: i just read https://wiki.haskell.org/Foldr_Foldl_Foldl' and looked up foldr in hoogle. i think it is better to use foldr
17:14:24 <Axman6> you are
17:14:28 <Axman6> see above
17:15:11 <kaidelong> byorgey: do you actually need the (a -> r) in foldFree?
17:15:17 <ReinH> (be aware that @source often lies)
17:15:21 <kaidelong> it doesn't seem like it
17:15:23 <ReinH> er @src
17:15:33 <medicijnman> Axman6: thanks. i'm going to try to rewrite the concatMap and use foldr
17:16:02 <Axman6> but... you already are :\
17:16:12 <johnw> medicijnman: I think what Axman6 is pointing out is that there will be no qualitative gain in doing so
17:16:19 <johnw> medicijnman: in fact, your use of concatMap is clearer about your intent
17:17:14 <medicijnman> johnw: maybe i should ask my co-workers what they think is better
17:17:16 <torvic> I've ran "ghc -threaded --make Setup;./Setup configure --user;./Setup build;./Setup install" seemingly with no errors, but the "cabal" command is still not recognized. Why?
17:17:41 <ReinH> > (++ "+") . ('+' :) . intercalate "+" . map (flip replicate '-') $ [1,2,3
17:17:42 <lambdabot>  <hint>:1:73:
17:17:42 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
17:17:46 <ReinH> > (++ "+") . ('+' :) . intercalate "+" . map (flip replicate '-') $ [1,2,3]
17:17:48 <lambdabot>  "+-+--+---+"
17:18:21 <medicijnman> if i think about it, concatMap is more elegant in this case. but i would like to keep it really simple if possible. i think in this case using foldr would make it more complicated
17:18:45 <ReinH> medicijnman: Ok, if you want to use foldr then inline the definition of concatMap. No idea why you would want to though.
17:20:07 <medicijnman> ReinH: mmm, i will keep it as it is then. you guys already told me multiple times it is clear what it does and it doesn't need to be 'fixed'
17:21:34 <ReinH> > (++ "+") . concatMap (\n -> '+' : replicate n '-') $ [1,2,3]
17:21:35 <lambdabot>  "+-+--+---+"
17:21:51 <ReinH> Should be faster than your version since it only (++ "+") once.
17:23:30 <medicijnman> ReinH: ah nice. it also looks better
17:24:35 <medicijnman> ReinH & johnw: thanks for your help.
17:31:11 <Cooler> how do you get the 2nd last element of a list?
17:31:23 <Cooler> last xs !! -1 ?
17:32:06 <medicijnman> one more question: i have another function declared like [(Int, String)] -> String which prints a row like "|column0|column1|"
17:32:37 <medicijnman> i have written another function that uncurries the tuple, but i want to combine both functions into one
17:33:21 <medicijnman> wrap :: (Int, String) -> String
17:33:21 <medicijnman> wrap z = uncurry print z ++ "|"
17:33:21 <medicijnman> print will justify it but that function is not important for my problem
17:34:08 <medicijnman> dumpRow :: [(Int,String)] -> String
17:34:09 <medicijnman> dumpRow r = '|' : concatMap wrap x
17:34:35 <medicijnman> i want to insert wrap into dumpRow to make it one function
17:36:29 <Axman6> Cooler: if you need than, don't use lists, because indexing into lists is O(n)
17:37:00 <Axman6> that*
17:37:07 <geekosaur> Cooler: lists are singly linked lists, not vectors/arrays
17:37:19 <geekosaur> think of them as loops waiting to happen
17:37:21 <Eduard_Munteanu> Cooler, surely not that way
17:38:04 <Eduard_Munteanu> > let xs = [1,2,3,4] in xs !! (length xs - 2)
17:38:06 <lambdabot>  3
17:39:47 <Eduard_Munteanu> > let secondToLast (a:_:[]) = a; secondToLast (x:xs) = secondToLast xs in secondToLast [1,2,3,4]
17:39:48 <lambdabot>  3
17:40:34 <johnw> > intercalate "+" . map (flip replicate '-') $ [1,2,3]
17:40:35 <lambdabot>  "-+--+---"
17:40:39 <johnw> medicijnman: ^^
17:40:50 <johnw> oh, guess he's gone
17:41:30 <Eduard_Munteanu> > fmap viewr . viewr . Seq.fromList $ [1,2,3,4]
17:41:31 <lambdabot>      Not in scope: ‘viewr’
17:41:32 <lambdabot>      Perhaps you meant one of these:
17:41:32 <lambdabot>        ‘Seq.viewr’ (imported from Data.Sequence),
17:41:38 <Eduard_Munteanu> > fmap Seq.viewr . Seq.viewr . Seq.fromList $ [1,2,3,4]
17:41:40 <lambdabot>      No instance for (Show a0)
17:41:40 <lambdabot>        arising from a use of ‘show_M687270567181131619711085’
17:41:40 <lambdabot>      The type variable ‘a0’ is ambiguous
17:52:51 <Cooler> what exactly does the <- arrow do?
17:53:05 <Cooler> is it a alternative to =?
17:54:15 <geekosaur> x <- v         translates to:     v >>= \x ->
17:54:30 <geekosaur> (note that that is incomplete and must be followed by something else)
17:55:18 <Cale> Cooler: inside of a do-block,  r <- x  means "execute the action x, and call its result r", while  "let r = x" by contrast will define r to be the same action as x (provided that x is an action)
17:55:41 <Cale> heh, sorry about my inconsistent use of quotation marks
17:55:58 <Cale> So, for example, with x being getLine
17:56:42 <Cale> You might write  do x <- getLine; putStrLn x, in which x will be the String result of executing getLine :: IO String, which is the line of text entered by the user
17:57:13 <Cooler> what about when its not inside a do block
17:57:15 <Cooler> ?
17:57:28 <Cale> <- also occurs in the syntax of list comprehensions
17:57:59 <Cale> where v <- xs means "pick an element v from the list xs in all possible ways"
17:58:08 <geekosaur> <- is special syntax used in list comprehensions, do blocks, and pattern guards (which can be thought of a special case of a list comprehension)
17:58:16 <Cale> > [(a,b,c) | a <- [1,2,3], b <- [4,5], c <- [6,7,8]]
17:58:17 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
17:58:19 <infandum> I want to put Network.MPD.Value in a set, but the author never derived Ord. How can I do that without defining a new type, just tack on Ord to Value?
17:58:21 <geekosaur> in other contexts it is an error
17:59:13 <Cale> infandum: instance Ord Value where compare x y = ...
17:59:43 <Cale> Or with the StandaloneDeriving extension, you should be able to write   deriving instance Ord Value
17:59:48 <Cooler> i am trying to make a list of fibonacci numbers
17:59:52 <cmccann> > do { a <- [1,2,3]; b <- [4,5]; c <- [6,7,8]; return (a,b,c)} -- do block, list comprehension, same diff
17:59:53 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
17:59:55 <Cooler> fibonacci = 0 : 1 : [(xs !! 1) + (xs !! 2) | xs <- take 2 (reverse fibonacci)]
18:00:00 <infandum> Cale: Great, thanks
18:00:08 <Cooler> shouldn't that work?
18:00:13 <Cale> uh, no
18:00:24 <Cale> How long should your list of fibonacci numbers be?
18:00:25 <MarcelineVQ> reverse fibonacci seems like a bad time
18:00:36 <Cooler> its an infinite list
18:00:45 <Cale> What's the last element of an infinite list?
18:00:56 <Cale> (which is the first thing you'd need to find if you were trying to reverse one)
18:01:01 <exio4> reverse fibonacci would be the list of fibonacci numbers in reverse order
18:01:05 <Cooler> well to print it out i thought you could do take 100 fibonacci
18:01:55 <Cale> Cooler: The problem isn't with the concept of an infinite list of fibonacci numbers, it's with what you're doing in your implementation here, which is taking xs to be an element of take 2 (reverse fibonacci)
18:01:56 <Cooler> doesn't it reverse the current list?
18:02:07 <Cale> which means that xs is going to be one of the last two fibonacci numbers
18:02:08 <MarcelineVQ> You can taker 100 fibonacci, but taking 100 reverse fibboancci means to take the last 100, and it's endless
18:02:14 <Cooler> so reverse [0, 1] the first time it runs
18:02:15 <Cale> but there are no last two fibonacci numbers
18:02:20 <Cale> If your definition is correct
18:02:24 <Cale> then this will take forever
18:02:32 <Cale> (so your definition can't be correct)
18:03:03 <Cooler> well reverse reverses the current list right?
18:03:07 <Cale> fibonacci is supposed to be the list of *all* fibonacci numbers
18:03:17 <Cale> This is the case regardless of where it appears
18:03:18 <Cooler> so it reverses [0, 1] to [1, 0]
18:03:31 <Cale> Since when are 0 and 1 the last two fibonacci numbers?
18:03:36 <MarcelineVQ> Do you want to take 2 fibonacci then reverse the two you took?
18:03:42 <Cale> There are many Fibonacci numbers which occur after those
18:04:05 <Cooler> no i am trying to get just the last 2 numbers in the current list to add them together and put it in the list
18:04:17 <Cale> In particular, 1, 2, 3, 5, 8, 13, ... occur after 0 and 1
18:04:27 <Cale> Cooler: There is no "current list"
18:04:36 <Cale> There is only the list you are defining, which is the whole list, all at once
18:05:19 <Cooler> ok so what does fibonacci look like?
18:05:29 <Cale> Well, there are lots of ways to do it
18:05:38 <infandum> Cale: So that actually doesn't work because "Value" constructor is not found because the author put it in a hidden module. So I can't do instance Ord Value where; compare (Value x) (Value y) etc.
18:05:46 <Cale> I could show you this one:
18:05:57 <infandum> Cale: It complains that the data constructor is not in scope
18:05:57 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
18:05:59 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:06:16 <Cale> However, that's a bit hard to understand at first, so let's look at something which I think is a bit easier to follow
18:07:00 <Cale> Instead of going after the Fibonacci numbers directly, recall that the n,m-Lucas numbers are defined just like the Fibonacci numbers, but where the first two elements are n and m rather than 0 and 1
18:07:05 <ari``> Hi...for AI, what is more suitable? a language like HAskell or perhaps Prolog?
18:07:38 <Cale> It requires a bit less cleverness to define a function which constructs the list of Lucas numbers:
18:07:56 <Cale> @let lucas n m = n : lucas m (n+m)
18:07:57 <lambdabot>  Defined.
18:08:09 <ari``> @lucas 2 3
18:08:09 <lambdabot> Unknown command, try @list
18:08:27 <Cale> i.e. we start off with n, and then follow that up with the list of Lucas numbers starting with m and proceeding with (n+m)
18:08:35 <Cale> > lucas 2 3
18:08:37 <lambdabot>  [2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,...
18:08:39 <Cale> > lucas 0 1
18:08:41 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:08:47 <ari``> > lucas 2 4
18:08:49 <lambdabot>  [2,4,6,10,16,26,42,68,110,178,288,466,754,1220,1974,3194,5168,8362,13530,218...
18:08:51 <Cale> ^^ and there's your sequence of Fibonacci numbers
18:09:00 <Cale> Well, the one starting with 0 and 1 ;)
18:09:16 <ari``> ah lucas numbers are generalized fibonacci numbers?
18:09:19 <Cale> yeah
18:09:24 <ari``> ok
18:10:01 <Cale> infandum: Then you're out of luck, and just need to get hold of the module which defines Value
18:10:22 <Cale> infandum: If constructors aren't exported, there is likely no way to externally define an Ord instance.
18:10:25 <unknownloner> conduits question: I want to take X inputs from a source, feed each one throught different conduit, then combine the X outputs to a single stream again. How might I do that? Something like this http://i.imgur.com/zpcNHJk.png
18:11:12 <infandum> Cale: Wow...that stinks.
18:11:18 <infandum> Cale: Thanks for your help
18:11:44 <Cale> infandum: Well, it's also a good thing in general, which allows module authors to abstract over the implementation details which they know might change in the future.
18:13:54 <cmccann> infandum: just implement Ord as compare x y = compare (show x) (show y). this may or may not be somewhat inefficient.
18:15:03 <cmccann> (it's also an ugly hack, no 'may or may not' there)
18:16:03 <ReinH> cmccann: I believe this is known a "observable equality"...
18:16:12 <ReinH> ;)
18:16:38 <cmccann> ReinH: no, the type infandum wants to be Ord already has an Eq instance :P
18:16:48 <byorgey> kaidelong: yes, you do need the (a -> r) in foldFree
18:16:56 <byorgey> kaidelong: what would you do with a leaf otherwise?
18:17:07 <cmccann> (I shudder to think what will happen if "equal" values don't always show as equal strings...)
18:17:46 <ReinH> cmccann: it was just a bad joke
18:17:50 <cmccann> byorgey: if you soak leafs in hot water you can make tea, that does not require a function
18:18:00 <cmccann> ReinH: I know. I was trying to make it worse.
18:18:04 <cmccann> ;]
18:18:04 <ReinH> cmccann: ah
18:18:05 <kaidelong> byorgey: couldn't you just inline id by hand as your (a -> r) and get "foldFree :: FAlgebra f a -> FAlgebra (FreeMonad f) a"
18:18:13 <byorgey> cmccann: haha, good point
18:18:14 <Cale> unknownloner: hmm, maybe something involving takeE?
18:18:21 <infandum> cmccan: I'll try
18:18:37 <kaidelong> actually, I know you can do that, because I've just done that
18:18:49 <kaidelong> right now I'm trying to figure out unfoldCofree
18:18:51 <byorgey> kaidelong: sure, but that is not as expressive as foldFree
18:19:02 <byorgey> I mean as the original one I gave
18:19:12 <kaidelong> I called that one "mapFoldFree" however I don't know why there would be an expression loss
18:19:15 <ReinH> kaidelong: isn't it just coiter?
18:19:17 <shachaf> > compare n (-n)
18:19:19 <lambdabot>  LT
18:19:20 <shachaf> > compare o (-o)
18:19:21 <lambdabot>  GT
18:19:35 <shachaf> cmccann: Do you like this world?
18:19:36 <kaidelong> ReinH: it is, I'm trying to implement "mapUnfoldCofree" actually
18:19:46 <kaidelong> so that I can do "unfoldCofree = mapUnfoldCofree id"
18:20:00 <Cale> unknownloner: Oh, or perhaps conduitVector could be of use to get hold of a vector of each n successive elements.
18:20:06 <kaidelong> foldFree gets you an "a"
18:20:10 <cmccann> shachaf: a world that contains the Enum instance for floats can't get much worse
18:20:16 <kaidelong> you can use a function (a -> r) to end up with an r anyway
18:20:25 <byorgey> kaidelong: oh, sure, I see now, if you do an fmap with your (a -> r) function first and then use your foldFree
18:20:28 <cmccann> infandum: anyway I can't promise the instance will behave sensibly, but you can write an instance that way. it might be worth checking for equality first before doing the show-and-compare
18:20:30 <kaidelong> so I'm not sure what mapFoldFree gains
18:20:35 <kaidelong> or that, yes
18:20:37 <byorgey> kaidelong: you have to do the (a -> r) first though
18:20:47 <byorgey> because you may not actually be able to write an algebra of type  f a -> a
18:20:48 <kaidelong> oh, those things don't commute?
18:20:51 <kaidelong> oh I see
18:21:06 <unknownloner> Cale Right, though I'm not sure what the best way to run those values through the different conduits would be
18:21:54 <byorgey> kaidelong: or because  a  might have less information than r.   For example suppose  r = Int  and we want to compute the number of leaves of a  FreeMonad f ()
18:22:04 <unknownloner> Making a singleton source and connecting the conduit to that sounds like it'd either not work at all or be ineffecient
18:22:06 <byorgey> if you fold the whole thing to  ()  first you cannot recover the size =)
18:22:11 <unknownloner> and I'm not sure what else I could do
18:22:21 <byorgey> you have to map all the () to  1 :: Int  first, and then do a fold where you add the sizes
18:22:57 <kaidelong> byorgey: I guess I can see that
18:23:08 <kaidelong> well, that's just another part of wanting a particular F-Algebra
18:23:13 <kaidelong> that might not support all types
18:24:13 <Cale> unknownloner: I guess you need to do something like map yield over the elements, getting a bunch of conduits which are each producing one element, and then fuse each of those to the corresponding conduits you have
18:24:24 <Cale> unknownloner: This is a highly unnatural operation on conduits, I feel.
18:24:32 <byorgey> kaidelong: right
18:24:33 <Cale> I don't use Conduit much though
18:24:46 <kaidelong> wouldn't you want (r -> a) for the comonad case for the same reason?
18:24:51 <kaidelong> even if you do not need it to implement it
18:25:23 <byorgey> kaidelong: no, that is different, because you actually never call it in the implementation =)
18:25:32 <byorgey> assuming that the unfold generates an infinite Cofree structure
18:26:08 <byorgey> if you want it to generate a finite Cofree structure then you need to add some extra bells and whistles (involving Maybe, etc.) so that the unfolding knows when to stop
18:26:23 <kaidelong> byorgey: wait, wouldn't you always call it in the implementation?
18:26:51 <kaidelong> you need to do something with that r in your CofreeComonad f r
18:27:01 <byorgey> kaidelong: we are talking about   (r -> a) -> (r -> f r) -> r -> Cofree f a,  right?
18:27:11 <kaidelong> yes
18:27:16 <byorgey> kaidelong: how would you implement it?
18:27:28 <kaidelong> I'm still trying to figure that out
18:28:14 <byorgey> oh, wait, sorry, I was confused about Cofree
18:28:21 <byorgey> you do need the (r -> a)
18:28:25 <kaidelong> gotten as far as  "mapUnfoldCofree f coalg x = Cofree (f x) (coalg _)"
18:28:31 <byorgey> anyway, implementing it is still a good exercise =)
18:29:12 <byorgey> not quite,  coalg _  will generate an  f r  but you need and   f (Cofree f a)
18:29:32 <unknownloner> Cale: I posted the question to /r/haskell, to see if anyone there has some ideas. It does seem like this wouldn't be commonly done...
18:30:58 <kaidelong> oh, actually I have this
18:31:12 <kaidelong> "fmap f (coalg x)"
18:31:15 <kaidelong> but that's wrong too
18:32:18 <byorgey> closer
18:33:05 <kaidelong> mapUnfoldCofree f coalg x = fmap f (Cofree x (fmap (mapUnfoldCofree f coalg) (coalg x))) -- ???
18:33:09 <byorgey> fmap _ (coalg x)  is right
18:33:42 <byorgey> yes, I think that works, but you should just inline the f
18:33:46 <byorgey> ie.  Cofree (f x) ...
18:34:01 <kaidelong> ah, right
18:34:10 <kaidelong> that is a type error anyway
18:34:34 <kaidelong> which the inlining fixes
18:34:46 <byorgey> oh, yes, you're right
18:36:46 <kaidelong> now I can finally solve problem 7 in 99 haskell problems!
18:38:38 <kaidelong> http://pastebin.com/AHFMg8Mb
18:38:46 <kaidelong> I'm just worried about my applicative instance, honestly
18:39:41 <kaidelong> oh wait
18:39:46 <kaidelong> I forgot to build it first
18:39:55 <byorgey> kaidelong: since you already have a Monad instance, you can give an Applicative instance with just  pure = return, (<*>) = ap
18:40:03 <c_wraith> kaidelong: you could just write that as (<*>) = ap
18:40:08 <c_wraith> ...  I'm slow
18:40:11 <edwardk> i just want to say that parallel concurrent generational mark-compact carbage collection is hard.
18:40:15 <byorgey> your definition is correct though
18:40:15 <kaidelong> ah, good to know
18:40:22 <c_wraith> @src ap
18:40:22 <lambdabot> ap = liftM2 id
18:40:25 <kaidelong> but not of mapUnfoldCofree
18:40:31 <kaidelong> GHC is still whining about that one
18:40:40 <kaidelong> so gotta think a bit more
18:40:42 <c_wraith> I've been playing with Cofree on the train the last couple days.
18:41:02 <byorgey> edwardk: does each adjective multiply the hardness by a factor of 2 or something?
18:41:21 <edwardk> byorgey: i think it is more of a compound exponential
18:41:27 <byorgey> hehe, yikes
18:41:41 <byorgey> that does sound hard
18:42:00 <edwardk> er s/carbage/garbage/
18:42:09 <c_wraith> I've discovered that it's incredibly flexible.  Cofree ((->) s) a is a Moore machine, for instance.
18:43:01 <kaidelong> I'm actually curious if people have gone into the philosophical perspective of things like Monads
18:43:15 <edwardk> kaidelong: Leibniz's monads and our monads are not the same
18:43:17 <kaidelong> logic folks don't seem to have explored them too much that I saw
18:43:27 <kaidelong> edwardk: yeah, I know that much
18:43:40 <kaidelong> ad-hoc overloading of the term on that front
18:43:45 <edwardk> as for logic, there is a whole discipline of playing with different modalities
18:43:46 <kaidelong> but our monad might have some meaning in logic
18:44:28 <kaidelong> if modal logic turns out to be an alternative way of talking about things like functors and monads I'd be really surprised
18:44:34 <kaidelong> pleasantly, but still very surprised
18:44:56 <kaidelong> I think if anything it'd probably have to have something to do with predicate logic
18:45:17 <kaidelong> however I can see the modal logic connection in that subcategories could be seen as "possible worlds"
18:45:23 <byorgey> kaidelong: well, get ready to be surprised =)
18:45:24 <ReinH> c_wraith: yes!
18:45:39 <edwardk> kaidelong: take a look at the axioms of s4. http://plato.stanford.edu/entries/logic-modal/ M is 'extract', 4 is 'duplicate'
18:46:00 <kaidelong> ah, I studied S4 and K4, I'll take a look, thank you
18:46:36 <edwardk> the distribution axiom of K is '(<@>)' in ComonadApply
18:46:40 <edwardk> etc.
18:47:02 <edwardk> if you have a SemicomonadSemiapplicative with modal fixed points you can use loeb's theorem  =)
18:47:19 <edwardk> ComonadApply would work for that too, but you don't need extract
18:47:28 <edwardk> :t Control.Comonad.kfix
18:47:29 <lambdabot> Control.Comonad.ComonadApply w => w (w a -> a) -> w a
18:47:42 <edwardk> that is loeb's theorem executed in the style of the original proof of loeb's theorem
18:48:38 <edwardk> anyways if you look at modal necessity and modal possibility you'll find a comonad and monad, if you look at the ! modality of linear logic it acts as a comonad
18:49:05 <edwardk> not _every_ modality corresponds to a nice category theory structure that we bother to name, but many many many of them do
18:49:29 <kaidelong> mmm, could the fact that you can be parametric in the comonad with these things be associated with many-worlds semantics?
18:49:51 <kaidelong> IE, the proofs associative to polymorphic programs because they're about things in many possible worlds, not just one
18:49:55 <edwardk> its more like letting us classify some theorems as working over any modality that has certain axioms associated with it
18:49:59 <kaidelong> IOW*
18:50:29 <edwardk> you can also get nice structure for linear temporal logic, iirc.
18:50:51 <ReinH> edwardk: go on
18:52:44 <edwardk> looking for a reference for you
18:53:10 <ReinH> ty
18:53:31 <edwardk> http://www.cs.ox.ac.uk/ralf.hinze/WG2.8/33/slides/Steve.pdf
18:53:40 <edwardk> the box modality there is a comonad
18:53:51 <edwardk> the diamond modality there is a monad
18:54:28 * hodapp blinks
18:54:37 <hodapp> Curry-Howard for GUIs?
18:54:49 <edwardk> then you start playing games with 'eventually always' and you start composing adjoints IIRC
18:55:25 <edwardk> it is morally the 'state' monad if you think of them in terms of functions from time, and a pair of a time and when something is true
18:55:34 <edwardk> er a pair of a time when something is true and the thing
18:55:37 <byorgey> hodapp: oh yes =)
18:56:36 <edwardk> the fun part about all of this stuff is how it all fits together. you learn something basic in one area and then you start seeing it pop up over and over through the curry-howard-lambek-de bruijn-whomever lens somewhere else
18:56:37 <hodapp> whatever the hell these slides are about
18:56:43 <hodapp> yes, let's replace OOP with this
18:57:11 <hodapp> I am going to read these later, when I'm not supposed to be doing computer vision homework
18:57:12 <edwardk> hodapp: the presentation was a lot clearer than thr slides
18:57:22 <hodapp> edwardk: thanks, I'll have to check that out too
18:57:30 <edwardk> sadly the presentation wasn't recorded
18:57:31 <hodapp> eventually. always.
18:57:34 <hodapp> NOOOOO!
18:57:36 <edwardk> maybe he's done it at another venue
18:58:00 <edwardk> but this was basically a bunch of PL researchers piled into a room
18:58:04 <hodapp> hah
18:58:52 <edwardk> i did enjoy the format though. basically kathleen fisher sat there with a chess clock, and gave the audience half the time and the speaker the other half, then when questions interrupted it ate audience time, etc.
18:59:18 <edwardk> really encouraged questions without completely derailing the presentation
18:59:24 <edwardk> i'd like to see that more often elsewhere
19:00:10 <hodapp> huh
19:00:49 <hodapp> I have been curious with agocorona's work too with the use of Haskell for GUI stuff but I've never really understood it
19:07:21 <Shockk> I'm considering two possible designs for something in Haskell and I'm wondering which would be the most efficient, specifically which would perform the fastest at say 60 times per second;
19:09:09 <Shockk> I've got a renderer module that exposes a startup function and an engine module which I pass a bunch of startup functions to, to start a game engine loop,
19:11:12 <Shockk> basically the renderer's tick function runs continuously in this loop, and I'd like to have some sort of state specific to the renderer, specifically what things it should be drawing every time its tick function is called
19:12:22 <Shockk> some other part of the engine, like another startup function or anything, should be able to add a renderable thing, and the two ways I'm thinking of are:
19:13:41 <Shockk> 1. have some list or map or whatever of components, to which renderable components as well as other types of component would be added
19:13:59 <Shockk> (as part of the data structure used under State)
19:15:21 <Shockk> 2. notify the renderer when a component is added and have it add specifically renderable components to its own list, which as far as I can think would have to be done using something like an IORef
19:18:09 <Shockk> both approaches would involve passing the component using Typeable / Dynamic; the first would be under State but would require the renderer to do something like fromDynamic every frame for all the renderable components (I could use a multimap or bimap or something to be able to get only the ones typed as renderables though)
19:19:09 <Shockk> and the second approach would already have a typed list of renderable components but would require using an IORef
19:19:43 <Shockk> so I don't know if using State would give a performance boost over an IORef, considering that typing stuff
19:25:17 <Big_G> .03
19:27:34 <kaidelong> okay so playing around more I can see now that while you can, for any monad f, take the free monad formed and collapse it to the monad f
19:27:45 <kaidelong> comonad does not do that, rather it does the opposite
19:27:55 <kaidelong> for any comonad f, you can get the cofree comonad out of it
19:28:18 <kaidelong> not sure how useful this is, since I'd think you could do this anyway
19:28:27 <johnw> the free package calls these two things 'retract' and 'section'
19:37:51 <Shockk> anyone got any insight as to which approach might be best>
19:40:25 <johnw> Shockk: I'd formulate that as an SO question
19:40:58 <Shockk> ahh, that sounds like a good idea
19:41:12 <Shockk> johnw: are there any tags that should be used for haskell questions?
19:43:09 <ReinH> Shockk: sounds like something you should profile
19:43:33 <johnw> Shockk: just #haskell is a good one :)
19:43:36 <ReinH> Shockk: 'haskell', at least
19:43:41 <Shockk> that's also true
19:43:44 <johnw> but for IRC, it's a bit involved of a question, without knowing the problem as well as you do
19:46:06 <Shockk> I guess it should be easy to switch between the two later on (since it's going to be hard to profile something like that this early in development)
19:48:24 <Cale> Shockk: Here's another one: provide a way to combine renderable things so that you only really need one renderable thing
19:49:34 <Cale> (which will in turn be built up from all the smaller ones produced by the game)
19:50:31 <Shockk> hmm... that's maybe another possibility; just have like a scene graph or something 
19:50:34 <Cale> Shockk: As a very simple representation, a "renderable thing" might be some sort of function from a bunch of appropriate graphics context information (depending on what sort of libraries you're using for that), to an IO action to be performed using that
19:51:17 <Cale> It's easy to combine such representations simply by performing one after the other.
19:51:36 <Cale> (and distributing the same context to both)
19:51:46 <Cale> That might be rather naive though
19:53:31 <Shockk> something that I'd like would be to associate components with some unique id though; so like a renderable component would be lookupable (this needs to be a word) from an object id, as well as other components for that object id
19:53:43 <Shockk> so I don't know how possible that would be with that approach
19:56:18 <Shockk> (my main reason for that would be to be able to remove all of an object's components at once to get rid of the object)
19:56:21 <Cale> Shockk: Right, so it might have to be more complicated then, because once you start arbitrarily composing these renderable things, it's perhaps tricky to systematically construct IDs
19:56:43 <Shockk> mhm
19:57:18 <Cale> On the other hand, you could do something like:
19:58:10 <Cale> data RenderableComponent = RC { handleMessage :: Message -> IO RenderableComponent; render :: GraphicsContext -> IO () }
19:58:43 <Cale> and then combined renderable components can respond to messages by passing the message along to each of their children
19:59:30 <Cale> Well, okay, there I had the result be an IO RenderableComponent, so each child would produce a replacement for itself in response
19:59:41 <Shockk> hmmm, when I say a renderable component, I was thinking something more along the lines of, like: 
19:59:42 <Cale> However, you could also just go with IO (), given that this is in IO
19:59:53 <Cale> Or you could go with a pure  RenderableComponent
20:00:14 <Cale> which would mean that the manner in which these components respond to messages can't depend on or perform I/O
20:00:30 <Cale> But might change what I/O they perform when rendered
20:00:44 <Shockk> data RenderableComponent = RC { triangles = [Triangle], normals = [Vertex] } or whatever
20:01:05 <Cale> Yeah, that kind of representation can work
20:01:18 <Shockk> simply a data structure with the actual processing of said data being done by the renderer tick function I mentioned before
20:08:41 <octopuscabbage> how do i make a state monad whos return type is a Maybe something
20:09:08 <octopuscabbage> but i don't really want it to be a monad transformer because there are other functions which a state value
20:11:48 <jasonkuhrt> What is showList for and the type ShowS
20:11:49 <slack1256> State s (Maybe a) as a type signature?
20:13:17 <pavonia> jasonkuhrt: showList is a separete function for showing lists
20:13:46 <octopuscabbage> slack1256, ghci doesn't like that
20:13:49 <octopuscabbage> err ghc
20:13:49 <jasonkuhrt> it returns a ShowS
20:13:51 <jasonkuhrt> what is that?
20:14:26 <pavonia> A type for effeciently showing values
20:14:46 <c_wraith> :t shows
20:14:47 <lambdabot> Show a => a -> ShowS
20:15:13 <c_wraith> automatically-derived Show implementations are in terms of shows, rather than show
20:15:18 <c_wraith> Because shows is more efficient
20:16:10 <slack1256> > :t (return (Just 5)) :: State String (Maybe Int)
20:16:11 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:16:25 <saulzar> octopuscabbage, StateT YourState Maybe might be what you're looking for?
20:16:30 <slack1256> > :t (return (Just 5) :: State String (Maybe Int))
20:16:31 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:16:44 <slack1256> > :t ((return (Just 5)) :: State String (Maybe Int))
20:16:45 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:16:46 <pavonia> slack1256: Either > or :t, not both
20:16:54 <slack1256> :t ((return (Just 5)) :: State String (Maybe Int))
20:16:55 <lambdabot> State String (Maybe Int)
20:17:02 <slack1256> thanks pavonia
20:17:13 <slack1256> octopuscabbage: well it seems to work on lambdabot
20:17:51 <octopuscabbage> slack1256, i just wasn't reading the error right, i had the arguments to evalState flipped .-.
20:19:01 * hackagebot brick 0.2.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.2.1 (JonathanDaugherty)
20:19:46 <slack1256> octopuscabbage: haha it still happens to me also
20:22:57 <stapler> can someone help a supernoob out?
20:23:03 <stapler> let me paste stuff real quick
20:23:33 <Shockk> @unpl StateT . (return .) . runState
20:23:33 <lambdabot> (\ d -> (StateT) (\ j -> return (runState d j)))
20:24:10 <stapler> Shockk: ah, hello again :)
20:24:11 <Shockk> that's.. is that just StateT (return (runState ..))?
20:24:17 <Shockk> hello again
20:24:51 <stapler> i know what im doing wrong but im not exactly sure how to correct it...
20:24:52 <stapler> here
20:25:07 <stapler> http://lpaste.net/7984928911521742848
20:25:57 <Cale> Shockk: Where did you find that?
20:26:23 <Cale> Shockk: it looks like a really stupid way to write the identity function...
20:26:41 <Shockk> Cale: I used that in some code I was writing like a year or two ago, I didn't know what it did at the time lol
20:27:12 <Cale> oh!
20:27:13 <Cale> I see
20:27:24 <Cale> It's not quite the identity function, because that's StateT vs. runState
20:27:27 <Cale> not runStateT
20:27:49 <Shockk> but for my current thing I've got everything under StateT Engine IO right now, but I want to put most of it under simply State Engine
20:27:51 <Cale> So it's turning a pure State s a action into a  StateT s m a  action
20:27:59 <Shockk> yep
20:29:20 <Shockk> so I'm just trying to decipher that point free notation
20:29:40 <Cale> (f .) . g is another way of writing (\x y -> f (g x y))
20:30:20 <Shockk> ahh right
20:31:06 <Cale> (maybe a little too clever for its own good)
20:32:46 <stapler> actually no i dont know what ive done wrong
20:32:47 <stapler> heh
20:34:12 <Cale> stapler: You're using newMVar
20:34:25 <Cale> :t Control.Concurrent.MVar.newMVar
20:34:26 <lambdabot> a -> IO (GHC.MVar.MVar a)
20:34:46 <Cale> As you can see, it produces an IO action, not an ActionT action
20:35:42 <stapler> i know i probably shouldnt be mixing the two monads, right?
20:35:44 <Cale> (Or ScottyT rather)
20:35:53 <stapler> but i'm not totally sure what i would do otherwise..
20:36:05 <Cale> You probably just want to apply liftIO to turn the IO action into an action of the appropriate monad in each case.
20:36:20 <Cale> i.e. nameM <- liftIO (newMVar "")
20:36:52 <stapler> thats a thing?!
20:37:06 <Shockk> that's like the inverse of what I'm doing, going from IO to ActionT Text IO as opposed to going from State Engine to StateT Engine IO lol
20:37:38 <Shockk> s/the inverse/similar
20:38:53 <Shockk> Cale: is (f .) . g  the same as  f . g x  ?
20:39:30 <Cale> ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
20:40:06 <Shockk> ahh ah thanks
20:52:47 <kaidelong> http://codepad.org/tQs5vAIK#line-64 this works on modern GHC
20:52:55 <kaidelong> but apparently not in what codepad uses
20:53:03 <kaidelong> I've never seen that compiler error before
20:53:24 <Cale> kaidelong: Functor only recently became a superclass of Monad
20:53:27 <kaidelong> is this just that I need to eta-expand?
20:53:37 <kaidelong> oh, so explicit functor dep?
20:53:40 <Shockk> kaidelong: if I had to guess, I'd say it's because a Monad isn't necessarily a Functor
20:53:43 <Cale> kaidelong: No, you either need to use liftM instead of fmap, or you need an explicit Functor constraint
20:53:46 <Shockk> until GHC 7.10
20:54:55 <kaidelong> http://codepad.org/hIsJMtE2
20:56:22 <kaidelong> now on to problem 8
20:58:22 <montanonic> kaidelong: problems from what, if I may?
20:58:39 <kaidelong> https://wiki.haskell.org/99_questions/1_to_10
20:59:12 <montanonic> oh cool, ty
20:59:16 <kaidelong> I might be prematurely generalizing here
20:59:29 <kaidelong> but if you're going to do easy exercises, might as well have fun with them
20:59:45 <montanonic> ^ that's how I'm treating CIS194 right now 
21:00:42 <kaidelong> I'm actually somewhat surprised that GHC cannot derive instances for CofreeComonad and FreeMonad
21:00:57 <montanonic> why is that? 
21:01:20 <kaidelong> I am guessing that higher rank types make things undecidable so GHC just gives up, but I don't know
21:01:45 <montanonic> I should actually, probably, not care about the answer to that until I move on to understanding Arrows and other higher level topics :)
21:01:58 <kaidelong> who still uses arrows these days?
21:02:04 <kaidelong> I thought CCCs were taking over
21:02:08 <MarcelineVQ> montanonic: FreeMonad is kinda cool
21:02:44 <montanonic> I don't know. I just thought I needed to learn them. And that they were more complex than Monads (where complex here means, so broadly applicable, that they can be difficult to understand).
21:02:44 <MarcelineVQ> free monads are neato
21:02:47 <montanonic> What are CCC's?
21:02:58 <montanonic> MarcelineVQ: when's the appropriate time to learn about them?
21:03:01 <kaidelong> well, I should say BiCCCs shouldn't I?
21:03:06 <kaidelong> cartesian closed categories
21:03:14 <montanonic> I'm still trying to get super comfortable with Functors, Monoids, Monads, and the like.
21:03:16 <kaidelong> basically the problem with arrows is that they mandate "proc"
21:03:23 <kaidelong> which severely limits their usefulness
21:03:30 <MarcelineVQ> montanonic: anytime you know about monads and functors
21:04:01 <montanonic> MarcelineVQ: okay, I'll look into it soon then.
21:10:33 <ReinH> kaidelong: I think the bigger problem with arrows is "arr"
21:11:01 <c_wraith> You end up with the equivalent of "arr" as soon as you combine category + functor
21:11:29 <c_wraith> So if you want to not have "arr", you need less power in one of those dimensions
21:11:39 <kaidelong> ReinH: that's what I meant
21:11:43 <kaidelong> thanks for the catch
21:11:55 <ReinH> c_wraith: how?
21:12:21 <nshepperd> arr f = fmap f id
21:12:31 <exio4> @type \f -> fmap f Control.Category.id
21:12:32 <lambdabot> (Functor (cat a), Category cat) => (a -> b) -> cat a b
21:12:52 <c_wraith> :t \f -> fmap f Control.Category.id -- ReinH 
21:12:53 <lambdabot> (Functor (cat a), Category cat) => (a -> b) -> cat a b
21:13:45 <c_wraith> Heh.  Answers in triplicate
21:13:52 <ReinH> Ok I got it thanks
21:13:59 <ReinH> @quote fugue
21:13:59 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
21:14:18 <c_wraith> Anyway.  To avoid arr, you need to sacrifice fmap, really.
21:14:40 <c_wraith> Since it's what allows embedding arbitrary functions
21:16:43 <stapler> Cale: not quite sure how to decipher this http://lpaste.net/1803405502860754944
21:17:11 <Cale> okay, let me check something
21:17:56 <Cale> Aha, the message is indeed correct, ScottyT is not an instance of MonadIO
21:18:02 <Cale> So you can't use liftIO
21:18:08 <stapler> :O
21:18:10 <c_wraith> I'm a little suspicious that version numbers are showing up in that error message
21:18:31 <Cale> Despite its misleading name, it is not even a monad transformer
21:18:41 <stapler> Cale: perhaps i should learn what MonadIO is vs Monad
21:18:46 <stapler> typeclass-wise
21:19:12 <Cale> MonadIO is the type class of monads m for which there is a function liftIO :: IO a -> m a
21:19:12 <Shockk> very quick question; if I have a list like x : y : z : [], if I map over that list which order will it map in?
21:19:36 <Cale> map f (x : y : z : []) = f x : f y : f z : []
21:19:41 <Shockk> or more specifically, if I use 'sequence' on it
21:19:58 <Cale> sequence [] = return []
21:20:10 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:20:23 <Cale> i.e. it executes each of the actions in the list in the order that they occur
21:20:30 <Shockk> ahh great
21:20:35 <stapler> Cale: so it takes an io action and instead turns it into the monad or something like that
21:20:50 <Cale> stapler: Yeah, it turns it into an action of the given monad
21:21:26 <Hafydd> "IO action"s have nothing to do with it, generally.
21:21:33 <stapler> Cale: so if scottyt is not an instance of monadio
21:21:39 <stapler> what should i be doing instead?
21:21:54 <Cale> Well, let's have a look at what your program is actually trying to do, I suppose.
21:21:59 <Hafydd> Oh, I thought you were still talking about sequence. Never mind.
21:22:32 <stapler> should i paste what ive tried to slap together
21:22:42 <Cale> stapler: yeah
21:23:01 <Axman6> > sequence ["abc","123"]
21:23:02 <lambdabot>  ["a1","a2","a3","b1","b2","b3","c1","c2","c3"]
21:23:03 <Cale> stapler: Sorry I gave you bad advice before, I haven't really used Scotty before, and ScottyT is poorly named.
21:23:12 <stapler> Cale: not an issue
21:23:22 <stapler> thank you for lending a hand though c:
21:23:35 <stapler> i figured its time to sotp reading about monads and stuff and start making stuff
21:23:42 <stapler> s/sotp/stop/
21:23:44 <stapler> http://lpaste.net/2010058970999291904
21:24:41 <rrand> what is the .: operator?
21:24:50 <rrand> I'm seeing it in aeson docs
21:25:28 <Lokathor> do people debug their haskell that often?
21:25:29 <Cale> stapler: okay, yeah, in this case, I think you just want to move the liftIO outside of the application of scotty
21:25:33 <c_wraith> rrand: it's defined in aeson
21:25:35 <Lokathor> like, in the stepping and checking values sense?
21:25:41 <mniip> rrand, https://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson.html#v:.:
21:25:48 <rrand> thanks!
21:25:59 <Cale> er, not liftIO, but the newMVar
21:26:16 <stapler> oh, right
21:26:22 <lpaste_> Cale annotated “No title” with “No title (annotation)” at http://lpaste.net/2010058970999291904#a141227
21:28:57 <stapler> Cale: it builds now however whenever i access my /set/name/ route it just hangs
21:29:44 <Cale> stapler: hmmm
21:30:03 <Cale> stapler: sure you didn't access that route more than once?
21:30:16 <stapler> definitely sure
21:30:16 <Cale> oh, no, of course it hangs
21:30:22 <Cale> Your MVar starts out filled
21:30:31 <Cale> because you're using newMVar "" and not newEmptyMVar
21:30:43 <Cale> So writing to the MVar will block
21:30:48 <Cale> until it becomes empty
21:31:21 <Cale> and you have no takeMVar, so it'll never become empty
21:31:38 <Cale> Perhaps you just wanted to use an IORef
21:31:51 <stapler> oh, haha
21:31:58 <stapler> well then..
21:32:24 <stapler> Cale: heres a question
21:32:43 <stapler> how does placing the newMVar work out type-wise?
21:32:54 <stapler> do desugars into >>= right?
21:33:05 <Cale> Well, main is an IO action
21:33:07 <Cale> always
21:33:31 <stapler> and its type is m a -> (a -> m b) -> m b
21:33:41 <Cale> and scotty :: Port -> ScottyM () -> IO ()
21:33:47 <stapler> oh.
21:33:50 <Cale> So scotty is also producing an IO action
21:33:52 <stapler> would you look at that.
21:34:01 <MarcelineVQ> stapler: it desugars into nested lambdas of >>=
21:34:18 <stapler> MarcelineVQ: sure but that doesnt effect the result type
21:34:24 <stapler> affect*
21:34:44 <MarcelineVQ> Right
21:35:19 <dmj`> stapler: 'do' can be used outside of monad blocks
21:35:26 <dmj`> > do do do 1
21:35:28 <lambdabot>  1
21:35:32 <stapler> dmj`: i know
21:35:35 <stapler> just uses then operator
21:35:41 <Cale> It can, but that's sort of misleading
21:36:18 <Cale> It's only non-monadic if there's only one non-let statement in the do-block, in which case there's no point in using do at all.
21:36:41 <c_wraith> > do ()
21:36:42 <lambdabot>  ()
21:38:20 <dmj`> > do let { x = 4; }; x 
21:38:22 <lambdabot>  4
21:38:47 <dmj`> @typ \y -> do let { x = 4; }; x + y
21:38:48 <lambdabot> Num a => a -> a
21:39:18 <dmj`> let's w/o in's are more pleasant IMO
21:39:39 <dmj`> Cale: regardless
21:39:52 <Cale> why?
21:40:05 <Cale> It's not even fewer characters
21:40:36 <Cale> do let <decls> ; <expr>  is somehow better than  let <decls> in <expr> ?
21:41:53 <stapler> Cale: i switched it to iorefs and it works fabulously!
21:42:01 <Cale> stapler: cool
21:42:15 <stapler> feels a bit uh.. hacked in though.
21:44:05 <dmj`> Cale: here, I'll paste, seems like 'in' isn't even valid, in the presence of 'do' in this one example
21:44:10 <dmj`> Cale: http://lpaste.net/141228
21:44:18 <dmj`> I like 'j' over 'k'
21:44:53 <Cale> uh, move the 'in' one space deeper
21:45:04 <Cale> I don't really like any of these layouts though
21:45:44 <dmj`> Cale: also, here, the code isn't symmetrical anymore, because 'let' is 3 characters and 'in' is 2. By hanging 'do' off the beginning its easier on the eyes IMO, http://lpaste.net/141229
21:46:36 <lpaste_> Cale annotated “No title” with “No title (annotation)” at http://lpaste.net/141228#a141230
21:46:49 <Cale> I would always use one of those four
21:47:49 <xpilot> does anyone understand how edwardk's ad package works with functions like sin?
21:48:35 <c_wraith> xpilot: the types it uses have definitions for those functions
21:48:40 <dmj`> Cale: I like the last one, never thought of spacing 'in' to the right, and yes I forgot to space the 'in' in my previous example :P
21:49:05 * hackagebot tries 0.0.1 - Various trie implementations in Haskell  https://hackage.haskell.org/package/tries-0.0.1 (athanclark)
21:49:14 <xpilot> c_wraith: but sin isn't a method of any typeclass...
21:49:22 <Cale> xpilot: are you sure about that?
21:49:24 <Cale> :t sin
21:49:25 <lambdabot> Floating a => a -> a
21:49:33 <Cale> :t pi
21:49:35 <lambdabot> Floating a => a
21:49:37 <xpilot> :i Floating
21:49:45 <glguy> xpilot: You can see that it is by typing ":i sin" in your GHCi
21:49:46 <Cale> Can't :i with the bot
21:50:10 <xpilot> d'oh
21:50:22 <xpilot> Cale: I am not so sure about that anymore...
21:50:32 <Cale> (it's a method of Floating)
21:50:41 <Cale> and that's how ad works
21:51:23 <Cale> > showCReal 200 (sin pi)
21:51:24 <lambdabot>  "0.0"
21:51:25 <c_wraith> I really like how the ability to make ad work with so little syntactic overhead is almost an accidental consequence of the way Haskell chose to overload numeric functions
21:51:40 <Cale> > showCReal 200 pi
21:51:42 <lambdabot>  "3.1415926535897932384626433832795028841971693993751058209749445923078164062...
21:51:53 <xpilot> yup - for some reason I assumed that sin wasn't a class method
21:52:07 <xpilot> it strikes me as a bit of an odd decision
21:52:20 <Cale> > sin (0 :+ 1)
21:52:21 <lambdabot>  0.0 :+ 1.1752011936438014
21:52:33 <Cale> Complex numbers might be important to some people
21:52:44 <c_wraith> > sin (0 :+ pi)
21:52:46 <lambdabot>  0.0 :+ 11.548739357257748
21:52:51 <Cale> and of course, if you have complex numbers you're going to want trig functions on them
21:53:12 <xpilot> ok, that makes sense
21:53:13 <Cale> So, might as well make all the trig functions class methods to begin with so that you can use the same numerical code
21:53:40 <c_wraith> Don't even need that much forethought, though.  Making them work on Float and Double was enough to introduce the class
21:53:59 <c_wraith> Then other types get to join the party for free
21:53:59 <Cale> Yeah, it sucks to have like, sinf and sind
21:54:33 <xpilot> would it be possible to add functions whose derivatives are similarly special-cased by ad?
21:54:56 <xpilot> I assume ad's sin just adds a tag saying that the function is sin
21:56:01 <c_wraith> no, that would be symbolic differentiation
21:56:08 <c_wraith> automatic differention is slicker than that
21:56:18 <c_wraith> .. *differentiation
21:56:45 <ReinH> so slick that some of the letters fell off
21:56:46 <c_wraith> A fair bit has been written about how it works.  It's not symbolic or numeric.  It's somewhere in between
21:57:10 <Cale> xpilot: ad works with "numbers" which are sequences of derivatives
21:57:12 <ReinH> c_wraith: A fair bit, but the TL;DR is "magic". ;)
21:57:30 <ReinH> Or possibly magnets.
21:58:10 <Cale> xpilot: as a simple example, consider storing just pairs of number and derivative
21:58:49 <Cale> xpilot: you can then compute the product like (x,x') * (y,y') = (x*y, x*y' + x'*y)
21:59:32 <xpilot> Cale: I think I understand that part of ad
22:00:38 <nshepperd> sin (x, x') = (sin x, x' * cos x) -- I guess then?
22:00:43 <c_wraith> The best part of automatic differentiation is that it can be poor-man's symbolic when combined with an Expr type
22:01:10 <Cale> nshepperd: yep
22:01:11 <nshepperd> so maybe you can add your own special functions, assuming you can get at that internal representations
22:01:13 <c_wraith> It all just sort of works right.
22:01:14 <Cale> It's just the chain rule
22:02:14 <xpilot> yeah I'm trying to figure out what the right internal representation is
22:02:41 <xpilot> something like AD s (Forward a)?
22:03:00 <xpilot> at least that's what diff uses
22:04:30 <xpilot> I wonder if ad already does the right thing with linear algebra
22:27:44 <adas> it seems easy to make functions that take one argument point free. but functions that take more than one argument .. how to make them point free?
22:28:40 <slack1256> you don't
22:28:58 <slack1256> you won't gain anything and will make it less readable
22:29:34 <ReinH>  you can use half measures though: \x y -> foo (bar x y) = \x -> foo . bar x
22:31:35 <adas> slack1256: oh.. i always thought point free is something to strive for.
22:31:41 <ReinH> adas: absolutely not
22:31:50 <ReinH> Remove point when they are superfluous.
22:31:56 <ReinH> points*
22:32:02 <ReinH> keep them when they aid readbility
22:32:28 <ReinH> adas: one way to look it is that pointfree helps you reason about function composition:
22:32:47 <slack1256> I think the emphasis on how they make the composition clear is lost when you use more than 2 parameters
22:32:47 <ReinH> filter p . map f rather than \xs -> filter p (map f xs)
22:33:11 <slack1256> you can do curry/uncurry but there is better ways to make the pipeline clearer
22:33:18 <ReinH> slack1256: absolutely
22:33:49 <ReinH> Pointfree is composition-oriented. pointful is application-oriented. Sometimes one is better, sometimes the other.
22:34:06 <adas> ReinH: what is pointful? how would that look like?
22:34:10 <ReinH> not point free
22:34:21 <slack1256> let var = f x
22:34:26 <slack1256> then do something with var like
22:34:28 <slack1256> g var
22:34:32 <ReinH> no
22:34:34 <ReinH> just
22:34:44 <ReinH> @unpl filter p . map f
22:34:44 <lambdabot> (\ c -> filter p (map f c))
22:34:51 <MarcelineVQ> foo x = x*2 --pointful
22:35:12 <MarcelineVQ> foo = (*2) --point free
22:35:15 <adas> oh.. its just the opposite
22:35:19 <ReinH> yep
22:35:35 <slack1256> oh right, you can also play with the @pl of lambdabot to see where it doesn't look nice
22:35:47 <ReinH> @pl \x y -> foo . bar x y -- ugly
22:35:48 <lambdabot> ((foo .) .) . bar
22:36:18 <nitrix> :t ((.).(.))
22:36:19 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
22:36:26 <slack1256> also remember you can also define you own composition operators
22:36:29 <ReinH> :t fmap fmap fmap
22:36:30 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:36:34 <ReinH> :t fmap `fmap` fmap
22:36:35 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
22:36:35 <slack1256> pipes does this... 5 different times!
22:37:15 <nitrix> Could someone explain me the purpose of ((.).(.)), as well as the type?
22:37:17 <adas> to me it seems like every program however big or small is just a big pipeline of structure transformations. or atleast most programs that don't do any interactivity. so i thought that being the case, pointfree everywhere would help readability especially if the program is not interaction based
22:37:32 <nitrix> I've seen it a couple times already and can't wrap my head around it.
22:37:49 <ReinH> adas: you could look at Richard Bird's stuff to see examples of elegant use of pointfree style
22:37:55 <ReinH> @google richard bird sudoku pdf
22:37:57 <lambdabot> http://www.willamette.edu/~fruehr/154/files/Sudoku.hs
22:38:51 <liste> nitrix it composes a 1-arg function with a 2-arg (curried) function
22:38:54 <ReinH> Ah, http://ipaper.googlecode.com/git-history/d56c604033447bc92c777994e571a1eb36439099/Miscs/Richard-Bird/sudoku.pdf
22:38:54 <slack1256> adas:  usually (.) pipelines don't suffice, you need customs composition operators (>=>) of kleiski monads is one of them
22:39:08 * hackagebot CoreErlang 0.0.3 - Manipulating Core Erlang source code  https://hackage.haskell.org/package/CoreErlang-0.0.3 (AlexKropivny)
22:39:27 <adas> thanks for the refernces
22:39:41 <ReinH> nitrix: its purpose is to be deployed during these conversations to appear smart.
22:39:57 <slack1256> actually you can see haskell as a gigant effort on defining good composition operators
22:40:14 <slack1256> (if you are an idealist :-) )
22:40:41 <ReinH> nitrix: but if you expand it using the definition of (.), you get
22:40:46 <ReinH> @unpl ((.).(.))
22:40:46 <lambdabot> (\ i b c f -> i (b c f))
22:41:21 <ReinH> @src (.)
22:41:21 <lambdabot> (f . g) x = f (g x)
22:44:34 <Cooler> can someone explain the fibonacci list function that uses zip?
22:45:16 <ReinH> Cooler: do you understand zipWith?
22:45:24 <Cooler> fib = 0 : 1 : [ a + b | (a, b) <- zip fib (tail fib)]
22:46:04 <ReinH> fibs = 0 : 1 : zipWith (+) fibs (tail fibs) is a bit more direct
22:47:36 <Cooler> zip returns a list of pairs right?
22:48:11 <Cooler> does it give (a, b) the first element of that list?
22:48:26 <slack1256> @type zip
22:48:27 <lambdabot> [a] -> [b] -> [(a, b)]
22:48:34 <slack1256> @type zipWith
22:48:35 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
22:48:51 <ReinH> Cooler: ok, in ``zip fib (tail fib)'', what is fib?
22:49:52 <Cooler> the entire list?
22:50:18 <ReinH> What does it start with?
22:50:53 <Cooler> 0 and 1
22:51:55 <ReinH> well, it starts with 0
22:52:00 <ReinH> what does tail fib start with?
22:52:41 <Cooler> 1
22:53:18 <juhp> anyone have travis container infra working for the haskell hvr-ghc ppa?
22:53:51 <ReinH> Cooler: so that's the next value.
22:55:21 <Cooler> is there a way to see the actual code the compiler generates? with the for loops and such?
22:55:57 <Cooler> its not exactly clear what its doing in the current form
22:56:39 <levi> It wouldn't translate into just for loops, and probably wouldn't be very clear to you in low-level form either.
22:56:49 <liste> Cooler you mean the assembly output?
22:57:09 <MarcelineVQ> Is there a way to not show the result of my function in ghci? I'm just timing with +s and I don't need to see the list it's building.
22:57:36 <ReinH> You can generate the core language that GHC usees
22:57:48 <slack1256> MarcelineVQ: seq list () ?
22:57:55 <slack1256> or deepseq
22:58:11 <exio4> foldr seq () xs :p 
22:58:21 <exio4> @type seq () 
22:58:22 <lambdabot> b -> b
22:58:30 <exio4> @type foldr seq () 
22:58:31 <lambdabot> Foldable t => t a -> ()
22:58:59 <juhp> (okay sorry hvr ppa containers seems already documented)
22:59:28 <nitrix> > take 10 $ zipWith fib (tail fib)
22:59:29 <lambdabot>      Not in scope: ‘fib’
22:59:29 <lambdabot>      Perhaps you meant ‘fix’ (imported from Data.Function)    Not in scope: ‘...
22:59:29 <lambdabot>      Perhaps you meant ‘fix’ (imported from Data.Function)
22:59:39 <MarcelineVQ> That seems to just makes it instant, I want to know the time it took, I just don't want the print
22:59:57 <nitrix> @let fib = 0 : 1 : [ a + b | (a, b) <- zip fib (tail fib)]
22:59:58 <lambdabot>  Defined.
23:00:02 <nitrix> > take 10 $ zipWith fib (tail fib)
23:00:03 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘[b0] -> [c0]’
23:00:04 <lambdabot>      Probable cause: ‘zipWith’ is applied to too few arguments
23:00:04 <lambdabot>      In the second argument of ‘($)’, namely ‘zipWith fib (tail fib)’
23:00:16 <nitrix> Oh I see.
23:00:33 <nitrix> > take 10 $ zipWith (+) fib (tail fib)
23:00:35 <lambdabot>  [1,2,3,5,8,13,21,34,55,89]
23:00:37 <nitrix> Cooler: ^
23:00:59 <Cooler> ?
23:01:07 <nitrix> Wrong example, one sec.
23:01:13 <nitrix> > take 10 $ zip fib (tail fib)
23:01:15 <lambdabot>  [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55)]
23:01:22 <nitrix> There, that should help you break it down.
23:01:54 <slack1256> that actually helps
23:02:49 <Cooler> why does it do that?
23:03:51 <nitrix> I'm sure you're familiar with the zippers on a jacket?
23:03:56 <ReinH> Cooler: let's start with: fibs = let x = zipWith (+) fibs (tail fibs) in 0 : 1 : x
23:04:18 <Cooler> i mean it only has 0 and 1 as the starting values
23:04:32 <ReinH> so what is the first value of x?
23:04:49 <ReinH> it's the first value of fibs plus the second value of fibs
23:04:51 <ReinH> so it's 1
23:05:07 <ReinH> so we have fibs = let x = zipWith (+) fibs (tail fibs) in 0 : 1 : : 1 : x
23:05:13 <ReinH> now what's the first value of x?
23:05:16 <Cooler> i mean shouldn't zip work like
23:05:22 <ReinH> it's the second value of fibs plus the third value of fibs
23:05:26 <ReinH> so it's 1 + 1
23:05:30 <Cooler> zip [0, 1] and [1]
23:05:31 <ReinH> so it's 2
23:05:38 <Cooler> = [(1, 1)]
23:05:40 <ReinH> so now we have fibs = let x = zipWith (+) fibs (tail fibs) in 0 : 1 : 1 : 2 : x
23:05:42 <ReinH> and so on
23:05:51 <Cooler> then prepend that to fib
23:06:02 <Cooler> then start over from the beginning?
23:06:19 <nitrix> Cooler: It's using a little trick. It's not zipping two identical list, the second list is actually offset by one element.
23:06:43 <nitrix> Thus, you can compute the past number + the current number to get the next number.
23:06:45 <Gurkenglas> @src zip
23:06:45 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
23:06:45 <lambdabot> zip _      _      = []
23:06:52 <Cooler> so zip [0, 1, 1] and [1, 1] = [(0,1), (1, 1)]
23:06:59 <Cooler> the 2nd time through
23:07:34 <ReinH> > zip [0,1] [1]
23:07:35 <lambdabot>  [(0,1)]
23:07:42 <ReinH> so that's the third value of fibs
23:07:50 <ReinH> (0 + 1) is
23:08:00 <ReinH> > zip [0,1, 1] [1, 1]
23:08:02 <lambdabot>  [(0,1),(1,1)]
23:08:18 <nitrix> [1, 2]
23:08:19 <ReinH> so the third value is 1 and the fourth is 2
23:08:27 <ReinH> > zip [0,1,1,2] [1,1,2]
23:08:29 <lambdabot>  [(0,1),(1,1),(1,2)]
23:08:33 <ReinH> now the fifth value is 3
23:08:35 <nitrix> [1,2,3]
23:08:40 <ReinH> > zip [0,1,1,2,3] [1,1,2,3]
23:08:42 <lambdabot>  [(0,1),(1,1),(1,2),(2,3)]
23:08:46 <nitrix> [1,2,3,5]
23:08:51 <ReinH> now the 6th value is 5, and so on
23:08:52 <Cooler> its like it only takes the last element of the list returned from zip and assigns it to (ab )
23:09:10 <Cooler> even though zip returns an entire list with each iteration
23:09:23 <ReinH> it's easier to use zipWith
23:09:32 <Cooler> it just ignores everything but the last element
23:09:36 <ReinH> > zipWith (+) [a,b] [b]
23:09:37 <lambdabot>  [a + b]
23:09:38 <MarcelineVQ> zip returns as many pairs as the shortest list you give it
23:09:42 <ReinH> so the third value is (a + b)
23:09:52 <ReinH> > zipWith (+) [a,b, a + b] [b, a + b]
23:09:53 <lambdabot>  [a + b,b + (a + b)]
23:10:03 <ReinH> and so on
23:10:54 <nitrix> ReinH: Wow that's crazy. What extension makes this possible?
23:11:13 <ReinH> nitrix: simple-reflect
23:11:16 <Cooler> is that how the <- operator works? just ignore everything but the last element when trying to assign a list to a tuple?
23:11:17 <ReinH> no extension
23:11:23 <ReinH> Cooler: <- is part of list comprehension syntax
23:11:27 <MarcelineVQ> Cooler: no
23:11:29 <ReinH> Cooler: it has nothing to do with ignoring anything
23:11:55 <nitrix> Cooler: It's using a little trick. It's not zipping two identical list, the second list is actually offset by one element (because of tail).
23:12:01 <nitrix> Thus, you can compute the past number + the current number to get the next number.
23:12:07 <ReinH> [ a + b | (a,b) <- zip [1,2] [1,2]]
23:12:11 <Cooler> then why is (a, b) only getting assigned the last element in the ever growing lists returned from zip with each iteration?
23:12:46 <ReinH> Cooler: fibs = 0 : 1 : zipWith (+) fibs (tail fibs) is evaluated like this
23:12:50 <ReinH> 0 : 1 : ???
23:13:07 <nitrix> Oh I see where he's getting at.
23:13:08 <ReinH> to figure out ???, zipWith (+) fibs (tail fibs) is evaluated
23:13:30 <mniip> hmm
23:13:31 <ReinH> @src zipWith
23:13:32 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:13:32 <lambdabot> zipWith _ _      _      = []
23:14:09 * hackagebot ansi-pretty 0.1.0.0 - AnsiPretty for ansi-wl-pprint  https://hackage.haskell.org/package/ansi-pretty-0.1.0.0 (phadej)
23:14:10 <ReinH> so we have
23:14:20 <mniip> > let f = a : scanl (+) b f in f
23:14:21 <lambdabot>  [a,b,b + a,b + a + b,b + a + b + (b + a),b + a + b + (b + a) + (b + a + b),b...
23:14:31 <ReinH> Cooler: fibs is 0 : 1 : ???
23:14:34 <ReinH> right?
23:14:38 <ReinH> and we're figuring out ???
23:14:47 <Cooler> yeah
23:14:59 <ReinH> so zipWith does pattern matching on (a:as)
23:15:09 <ReinH> so we have a = 0 and as = 1 : ???
23:15:11 <ReinH> right?
23:15:15 <Cooler> is zipWith the same as zip?
23:15:47 <ReinH> Cooler: zip combines two lists by using (,) element-wise
23:15:53 <Shockk> zipWith is like a generalization of zip; 'zip' zips by taking a and b and returning (a,b)
23:15:56 <ReinH> > zip [a,b,c] [d,e,f]
23:15:57 <lambdabot>  [(a,d),(b,e),(c,f)]
23:15:59 <Shockk> zipWith takes a and b and returns f a b
23:16:03 <ReinH> ok, one at a tim eplease
23:16:07 <ReinH> Cooler: right?
23:17:24 <Cooler> ReinH, i was looking at the documentation
23:17:48 <ReinH> Cooler: so you undertand zip?
23:17:58 <Cooler> yeah i got what zipWith does
23:17:59 <ReinH> *understand
23:18:05 <ReinH> zipWith lets you plug something else in instead of (,)
23:18:09 <ReinH> so zip = zipWith (,)
23:18:44 <ReinH> Ok, so, we have 0 : 1 : zipWith (+) fibs (tail fibs)
23:18:50 <ReinH> and @src zipWith
23:18:57 <ReinH> @src zipWith
23:18:57 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:18:57 <lambdabot> zipWith _ _      _      = []
23:19:16 <ReinH> so we want to evaluate zipWith (+) fibs (tail fibs)
23:19:22 <ReinH> so that we can provide the next element of the list
23:19:35 <ReinH> so we pattern match (a:as) = fibs
23:19:41 <ReinH> and we pattern match (b:bs) = tail fibs
23:20:12 <ReinH> fibs = 0 : 1 : ??? and tail fibs = 1 : ???
23:20:14 <Cooler> ReinH, i understand the part of using the tail fib
23:20:21 <ReinH> so we have a = 0 and b = 1
23:20:28 <Cooler> the question was slightly different
23:20:32 <ReinH> ok
23:21:21 <Cooler> in this example
23:21:22 <Cooler> fib = 0 : 1 : [ a + b | (a, b) <- zip fib (tail fib)]
23:21:26 <ReinH> [a + b | (a,b) <- zip fib (tail fib)] is equivalent to zipWith (+) fib (tail fib)
23:21:31 <Cooler> why is (a, b) only getting assigned the last element in the ever growing lists returned from zip with each iteration?
23:21:37 <ReinH> That's what I'm explaining.
23:22:15 <Cooler> i understand you use tail fib to line up the elements
23:22:20 <ReinH> right
23:22:27 <ReinH> but *what* elements are being lined up?
23:22:29 <Cooler> this has nothing to do with that
23:22:41 <ReinH> What does it have to do with then?
23:23:01 <Cooler> well the expression is evaluated in iterations correct?
23:23:12 <ReinH> What does "evaluated in iterations" mean?
23:23:34 <Cooler> means it can't generate the whole list in one go
23:23:50 <levi> I think that maybe the list comprehension syntax sugar is making this a little less clear.
23:23:57 <ReinH> levi: that's why I'm using zipWith
23:24:11 <Cooler> it has to generate n-2 and n-1th elements before generating the nth element of the list
23:24:21 <ReinH> right
23:25:07 <Cooler> with each iteration fib is growing large3r right?
23:25:11 <Cooler> larger*
23:25:41 <ReinH> sure
23:25:56 <nitrix> I guess his question is when nth element is being generated, why isn't the head and tail of the whole `fibs` list used instead of nth-1 and nth-2.
23:26:03 <Cooler> so zip is being called with larger and larger lists on each iteration
23:26:12 <ReinH> no.
23:26:14 <Cooler> and its returning larger and larger lists each time
23:26:18 <ReinH> no.
23:26:30 <ReinH> This is what I'm trying to explain.
23:26:45 <MarcelineVQ> Ah, it's recursive though not iterative
23:26:49 <ReinH> The list comprehension version is unnecessarily complex because explaining it involves desugaring it into do notation and then into applicatinos of concatMap
23:26:58 <ReinH> So let's use the zipWith version, which is equivalent.
23:27:34 <ReinH> so fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
23:27:36 <ReinH> @src fibs
23:27:36 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:27:42 <ReinH> @src zipWith
23:27:42 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:27:42 <lambdabot> zipWith _ _      _      = []
23:28:09 <ReinH> if you ask for, e.g., fibs !! 2, the third element has to be evaluated.
23:28:26 <ReinH> so the definition of zipWith is pattern matched against
23:28:31 <Cooler> why does that matter? zipWith is being called with ever growing lists just like zip
23:28:39 <ReinH> Cooler: What do you mean why does it matter?
23:28:42 <ReinH> Why does what matter?
23:28:49 <MarcelineVQ> I think he was asking me
23:28:52 <Cooler> using zipWith vs zip
23:29:00 <MarcelineVQ> oh nvm lol
23:29:02 <ReinH> it's zipWith versus list comprehensions
23:29:04 <MarcelineVQ> Keep at it Cooler, ReinH and you are both doing well, it'll click
23:29:11 <ReinH> when I don't need to explain to explain this function
23:29:14 <ReinH> s/when/which
23:29:37 <ReinH> the important thing is tracing the way haskell evaluates the expression
23:29:57 <Cooler> which is why it would be helpful to see it broken down into loops
23:30:00 <levi> Cooler: Look a bit more closely at exactly what the expressions are that get passed to zipWith.
23:30:02 <ReinH> There are no loops.
23:30:24 <ReinH> I'm trying to explain how this works.
23:30:25 <Cooler> or the exact recursive calls that are happening
23:30:38 <ReinH> I am explaining exactly how it is evaluated.
23:30:55 <levi> With zipWith, you're seeing exactly what's going on. There's no weird sugar there.
23:31:05 <ReinH> in the most clear and direct way possible
23:31:10 <ReinH> at least, possible for me
23:31:26 <slack1256> ReinH: you probably should explain whnf
23:31:31 <ReinH> No, no I shouldn't.
23:31:44 <levi> This is really the core principle of Haskell evaluation; taking the time to think through this carefully will pay off big.
23:31:45 <Cooler> by list comprehension are you talking about a + b | (a, b) <-
23:31:54 <ReinH> Cooler: with [], yes
23:32:01 <Cooler> ok
23:32:04 <ReinH> that version is a more complex version of the the one I am using
23:32:15 <ReinH> They are equivalent, and there's no point in introducing unnecessary complexity
23:32:40 <nitrix> slack1256: I'm actually all up for it. Now that Cooler brang the question, I realise that I can't explain the evaluation of fibs.
23:33:05 <ReinH> it isn't neessary to explain WHNF.
23:33:21 <ReinH> and doing so doesn't improve the explanation
23:33:34 <nitrix> Like why isn't `tail fibs` always `1 : ...`
23:33:45 <slack1256> nitrix: I could explain in poorly on IRC, but the tutorials on the web are better
23:33:50 <ReinH> Well, I'm trying to explain that.
23:34:01 <ReinH> So
23:34:15 <ReinH> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
23:34:18 <ReinH> @src zipWith
23:34:18 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:34:18 <lambdabot> zipWith _ _      _      = []
23:34:25 <slack1256> it has to do how you evaluate the outer constructors first and how you can stop there if that is all you need
23:34:34 <Cooler> btw i am calling fibs like this take 100 fibs
23:34:36 <levi> nitrix: It has to do with the expressions that the names are bound to in the recursive expansion.
23:34:37 <ReinH> slack1256: Pattern matching explains that
23:34:55 <slack1256> but ReinH is right, it isn't necessary here
23:34:59 <ReinH> let's say we're evaluating fibs !! 2
23:35:03 <ReinH> @src (!!)
23:35:03 <lambdabot> xs     !! n | n < 0 = undefined
23:35:03 <lambdabot> []     !! _         = undefined
23:35:03 <lambdabot> (x:_)  !! 0         = x
23:35:03 <lambdabot> (_:xs) !! n         = xs !! (n-1)
23:35:36 <ReinH>  so we have (0 : 1 : zipWith ...) !! 2
23:35:54 <ReinH> so the definition of !! is used and a mathing pattern is found
23:35:59 <ReinH> that's the fourth case
23:36:05 <nitrix> I'm following.
23:36:08 <ReinH> so we have (1 : zipWith ...) !! 1
23:36:10 <ReinH> and again
23:36:17 <ReinH> so we have (zipWith ...) !! 0
23:36:20 <ReinH> now the third case is uses
23:36:23 <ReinH> or rather
23:36:25 <ReinH> we don't know which case is used
23:36:32 <ReinH> so we have to evaluate zipWith ...
23:36:40 <ReinH> as much as is required to find a matching pattern
23:36:54 <ReinH> so evaluation of zipWith (+) fibs (tail fibs) begins
23:37:38 <ReinH> so the definition of zipWith is used
23:37:40 <ReinH> @src zipWith
23:37:40 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
23:37:40 <lambdabot> zipWith _ _      _      = []
23:37:47 <ReinH> as is fibs
23:37:49 <ReinH> bs is tail fibs
23:37:51 <ReinH> sorry
23:37:59 <nitrix> I actually see a big correspondance with WHNF here, but I'll ignore it. Please continue, it's enlightning.
23:38:05 <ReinH> we need to pattern match fibs and tail fibs
23:38:10 <ReinH> fibs is (0 : 1 : ...)
23:38:13 <ReinH> tail fibs is (1 : ...)
23:38:17 <ReinH> so both match the first pattern
23:38:32 <ReinH> nitrix: There is, but explaining WHNF doesn't explain this. This explains WHNF.
23:38:48 <ReinH> Ok, so we agree that the first pattern is matched?
23:39:07 <nitrix> I see. So far so good, the two patterns makes sense.
23:39:17 <ReinH> So we have some things bound now
23:39:19 <ReinH> f = (+)
23:39:22 <ReinH> a = 0
23:39:26 <ReinH> as = (1 : ...)
23:39:28 <ReinH> b = 1
23:39:35 <ReinH> bs = ...
23:39:38 <ReinH> right?
23:39:41 <ReinH> so we can plug those on
23:39:41 <nitrix> correct.
23:39:54 <ReinH> 0 + 1 : zipWith (+) (1 : ...) (...)
23:40:07 <ReinH> or, in fact, 0 + 1 : <thunk>
23:40:18 <ReinH> because, remember
23:40:21 <ReinH> @src (!!)
23:40:21 <lambdabot> xs     !! n | n < 0 = undefined
23:40:21 <lambdabot> []     !! _         = undefined
23:40:21 <lambdabot> (x:_)  !! 0         = x
23:40:21 <lambdabot> (_:xs) !! n         = xs !! (n-1)
23:40:22 <levi> This is what I meant about the bindings in the recursive expansion.
23:40:27 <ReinH> the rhs of the (:) isn't evaluated
23:40:36 <ReinH> so we evaluate 0 + 1 and we're done, the answer is 1
23:41:00 <ReinH> now, what happens if we ask for fibs !! 3?
23:41:06 <nitrix> ReinH: What if it was !! 3?
23:41:16 <nitrix> Ah, glad we're on the same page.
23:41:27 <ReinH> so we have 0 : 1 : <thunk>
23:41:48 <ReinH> so we need to force the thunk
23:41:58 <ReinH> but when do we force the thunk? That might be surprising.
23:41:58 <nitrix> Which we did earlier and got 1.
23:42:08 <ReinH> No.
23:42:10 <levi> Note that the name 'fib' doesn't appear in '0 + 1 : zipWith (+) (1 : ...) (...)'
23:42:18 <nitrix> Actually we got `1 : <thunk>`
23:42:21 <ReinH> Well, let's start over to make this clear
23:42:33 <ReinH> let's start again with nothing forced
23:42:37 <MarcelineVQ> > let fib = a : b : zipWith (+) fib (tail fib) in take 7 fib --what if we asked for 7?
23:42:38 <lambdabot>  [a,b,a + b,b + (a + b),a + b + (b + (a + b)),b + (a + b) + (a + b + (b + (a ...
23:42:46 <bakibour> hiho
23:43:00 <ReinH> Maybe we should move this to #haskell-in-depth?
23:43:21 <nitrix> Joined.
23:49:56 <amicuscuriae> hey
23:50:03 <amicuscuriae> Is haskell beginner friendly lang?
23:50:18 <amicuscuriae> for a complete noob esp. if one aims to develop simple GUI applications?
23:50:25 <earthy> amicuscuriae: yes.
23:50:43 <slack1256> amicuscuriae: it was my first lang, yet I don't know if friendly
23:50:55 <earthy> amicuscuriae: better to be a *complete* noob than to have misconceptions already planted from other programming
23:50:56 <slack1256> probably for GUI you are better of with another lang
23:51:10 <Lokathor> Monad law 2, "m >>= return ≡ m", seems to just be restating Monad law 1, "return a >>= f ≡ f a" in a points free way
23:51:22 <Lokathor> is there a subtle difference i'm missing?
23:51:47 <amicuscuriae> slack1256, so GUI is not possible?
23:51:49 <slack1256> Lokathor: I am told that monad laws are you category laws on kleiski composition
23:52:09 <srhb> amicuscuriae: GUI is absolutely possible.
23:52:16 <slack1256> amicuscuriae: it is possible, but it feel the same as writing python or C
23:52:22 <Lokathor> perhaps i'll never understand monads
23:52:35 <Lokathor> perhaps i'll simply use them and fumble in the dark while doing so
23:52:35 <slack1256> because the toolkit (GTK,Qt) underlying language is C and Qml
23:53:10 <slack1256> Lokathor: never bothered with laws, still use monads correctly
23:53:29 <slack1256> laws are just there not to learn, but for referene when you already know
23:53:35 <slack1256> *reference
23:54:08 <Lokathor> yeah anyone who talks about monad laws or other typeclass laws often seems really bad at talking to people who don't yet already know them
23:54:35 <slack1256> because they are reference documentation, not beginner one
23:54:45 <amicuscuriae> slack1256, ok
23:54:46 <slack1256> it requires actually know how things work to make sense of them
23:54:47 <srhb> Lokathor: I don't understand how you can consider them the same.
23:54:47 <amicuscuriae> srhb, ok
23:55:02 <srhb> How is one pointfree of the other?
23:55:24 <amicuscuriae> What if I am talking about cli interactive programs? like something that does calculations based on user inputs and various other arguments
23:55:29 <slack1256> there exist two types of documentation, the reference one and the beginner one. People usually don't differenciate between the two
23:55:34 <amicuscuriae> also how would haskell package it?
23:55:40 <Lokathor> srhb, i could totally be reading it wrong at 1am
23:55:49 <slack1256> (lens drama over the graph on haddock, is a perfect example of this)
23:56:09 <srhb> Lokathor: No idea, I don't know how you're even reading it that way. It seems completely non-obvious to me.
23:56:20 <amicuscuriae> hey when I was in school, I used Turbo C++ to develop .exe for Windows, don't we have something like that? which compiles it to executable binary for Linux?
23:56:52 <Lokathor> oh the ordering tripped me up
23:56:56 <Lokathor> okay
23:57:10 <liste> amicuscuriae in Haskell? GHC.
23:57:27 <srhb> amicuscuriae: Those things are usually called "compilers" -- transforming your program to a system compatible executable.
23:57:52 <amicuscuriae> srhb, ok, does haskell have it for gnu+linux?
23:57:59 <srhb> amicuscuriae: ghc is cross-platform.
23:58:05 <amicuscuriae> liste, GHC ok
23:58:13 <amicuscuriae> so it would compile to a binary?
23:58:25 <amicuscuriae> what would work for a given platform it has been compiled to?
23:58:27 <amicuscuriae> really?
23:58:42 <srhb> GHC on Windows produces binaries for Windows.
23:58:45 <amicuscuriae> would it be GUI based? like a box with program running or like cli based?
23:58:49 <srhb> GHC on Linux produces binaries for Linux, etc...
23:59:00 <srhb> Would what be GUI-based?
23:59:07 <amicuscuriae> i don't know
23:59:14 <Lokathor> amicuscuriae, there is no GUI based compiler for haskell currently that I know of
23:59:15 <srhb> Well, then I can't help you. :P
23:59:36 <Lokathor> there are command line based compilation systems that can produce programs that make a GUI though
23:59:39 <slack1256> maybe VS or eclipseFP will call ghc for you
23:59:40 <MarcelineVQ> You can make your program CLI or GUI
23:59:42 <amicuscuriae> srhb, Can you please provide me with a binary compiled in haskell? That gets two numbers from me and adds them and puts it on screen?
23:59:47 <MarcelineVQ> That's independant of compiling
23:59:58 <amicuscuriae> ok
