00:03:52 <srhb> amicuscuriae: What's up?
00:06:35 <greg> hello ive added hmatrix to my yaml file , but it still says dependencies are missing , can anyone help?
00:06:45 <greg> not sure what to do im pretty new to stack
00:08:41 <srhb> greg: Start by pasting the output you get on lpaste.net, that will allow people to actually try to figure out what's going on.
00:11:20 <greg> ok
00:13:37 <greg> http://lpaste.net/141355 here is the output when i run stack build
00:15:39 <greg> my cabal file is here , http://lpaste.net/141356
00:16:41 <kadoban> greg: And your stack.yaml?
00:16:48 <greg> coming right up
00:17:17 <greg> http://lpaste.net/141358
00:17:22 <greg> stack.yaml
00:17:46 <greg> not sure why its saying theres a problem
00:17:55 <kadoban> greg: There's no hmatrix in there?
00:18:16 <greg> i didnt think i needed hmatrix in stack.yaml
00:18:27 <greg> i thought i only need in my cabal file
00:18:33 <greg> am i wrong?
00:18:48 <kadoban> Oh hmm, hmatrix is in stackage, that should be provided by the resolver then.
00:19:49 <kadoban> greg: That's really the output of 'stack build' ? It looks ‚Ä¶ funny or something.
00:19:59 <levi> I had something build via stack with hmatrix just a few days ago.
00:20:58 <greg> os sorry thats the output of my ghc-mod when i try to build
00:21:26 <greg> stack build works fine
00:21:35 <kadoban> greg: Oh. I don't know that ghc-mod has support for stack specifically.
00:21:59 <kadoban> greg: You'd probably have to get it to run as something like 'stack exec ghc-mod <whatever>', I think? Maybe?
00:22:18 <greg> thanks will try that and report back
00:24:17 <kadoban> greg: If you search around you might find some info about ghc-mod supporting or not supporting stack, and possibly more solid info on how to get it to work if it's not supposed to out-of-the-box. I know the ghc-mod author has at least looked into stack support.
00:24:45 <kadoban> So maybe the github ghc-mod issues and branches would be a decent place to start looking, if that helps.
00:25:08 <greg> yes i thought he put it in recently, is it possible to start ghci from stack? I just want to inspect some types
00:26:05 <greg> ah stack ghci
00:26:09 <greg> :-\
00:30:31 <amicuscuriae> Anyone using Komodo Edit here?
00:33:04 <amicuscuriae> Can anyone suggest me an out of box Haskell Editor with auto completion?
00:37:58 <Cooler> these picture tutorials are great, why aren't they listed on the main haskell page?
00:38:01 <Cooler> http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
00:49:06 <petercommand> http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf
00:49:37 <petercommand> In page 21, I don't understand why the SP data type is defined recursively
00:49:48 <petercommand> arrow stream process
00:50:24 <petercommand> data SP a b = Put b (SP a b) | Get (a -> SP a b)
00:52:03 <petercommand> I am trying to understand what it is trying to achieve
00:56:36 <Hipe9> Hello!
01:01:24 <petercommand> it seems to be something like the state monad
01:02:36 <Hipe9> I am a new haskellite (is that the word?), and I come from a Lisp background (specifically, Scheme, and even more specifically, Racket) and so I was wondering, what are the differences
01:02:47 <Hipe9> and similarities between the two.
01:02:57 <ChristianS> Hipe9: compile-type type checking
01:03:47 <Hipe9> (Input field getting too big.)
01:04:01 <jle`> petercommand: the SP fields are the "next action"
01:04:16 <jle`> petercommand: Put x sp' is "put x, then do sp' next"
01:04:34 <jle`> petercommand: Get (\x -> next sp with x)
01:05:24 <jle`> Hipe9: i think you can say that a lot of the strength of lisp comes from his homoiconicity, powerful metaprogramming and reflection capabilities and idioms
01:05:47 <jle`> whereas the strength of haskell comes from its expressive static type system and safety
01:06:00 <jle`> if we're talking about what distinguishes them from just simply "functional"
01:06:20 <jle`> in practice, writing lisp and writing haskell are very different because you pull from different philosophies and possibilities at every turn
01:12:01 <ReinH> lisp and haskell are both functional languages in the same sense that English and Japanese are both natural languages
01:13:25 <ReinH> which is to say that they are in the same general category but they disagree on a lot of specifics
01:13:57 * hackagebot yesod-content-pdf 0.1.0.0 - PDF Content Type for Yesod  https://hackage.haskell.org/package/yesod-content-pdf-0.1.0.0 (alexkyllo)
01:18:58 * hackagebot streaming-commons 0.1.14 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.14 (MichaelSnoyman)
01:19:30 <Hipe9> OK, that is very helpful.
01:19:51 <Hipe9> Thanks!
01:20:18 <ReinH> Ok, good talk. ;)
01:27:47 <Cooler> are typeclasses basically java interfaces?
01:29:32 <dramforever> only Cooler =P
01:30:19 <srhb> They share some properties, but not all.
01:30:57 <dramforever> Cooler: I would say that it mostly contains the good parts of interfaces and overloading
01:33:00 <srhb> And they are more powerful.
01:34:21 <breadmonster> srhb: Does dons still hang around here?
01:34:55 <srhb> breadmonster: I don't think so, but I don't know them, so I'm probably not the right person to ask. :)
01:34:59 <petercommand> jle`: is there a simple application of the stream processor?
01:35:07 <breadmonster> srhb: It's a him :P
01:35:08 <breadmonster> but okay.
01:35:11 <srhb> breadmonster: OK :)
01:36:36 <petercommand> jle`: I don't quite get the fibs example in the article.. (page 22)
01:37:53 <breadmonster> What does scanl do?
01:37:58 <breadmonster> @src scanl
01:37:59 <lambdabot> scanl f q ls = q : case ls of
01:37:59 <lambdabot>     []   -> []
01:37:59 <lambdabot>     x:xs -> scanl f (f q x) xs
01:38:15 <breadmonster> Ah.
01:38:34 <breadmonster> @src scanr
01:38:34 <lambdabot> scanr _ q0 []     =  [q0]
01:38:34 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
01:38:34 <lambdabot>     where qs@(q:_) = scanr f q0 xs
01:39:37 <dramforever> > scanl (\x y -> "f "++ x ++ " (" ++ show y ++ ")") "x" [1..]
01:39:38 <lambdabot>  ["x","f x (1)","f f x (1) (2)","f f f x (1) (2) (3)","f f f f x (1) (2) (3) ...
01:39:48 <dramforever> ouch, it's off by a bit
01:39:56 <dramforever> > scanl (\x y -> "f("++ x ++ ", " ++ show y ++ ")") "x" [1..]
01:39:58 <lambdabot>  ["x","f(x, 1)","f(f(x, 1), 2)","f(f(f(x, 1), 2), 3)","f(f(f(f(x, 1), 2), 3),...
01:40:46 <petercommand> breadmonster: each entry in the list depends solely on the previous entry
01:46:27 <srhb> petercommand: You can think of scans sort of like folds that make every intermediate value available.
01:47:57 <petercommand> srhb: yep
01:53:33 <Hi-Angel> I couldn't figure out, how do I enable with ¬´cabal¬ª a build option from the ¬´.cabal¬ª file? I.e. there is ¬´ghc-prof-options: -prof -auto-all -rtsopts¬ª, and I'm trying to run something like ¬´cabal build ghc-prof-options¬ª, but it doesn't work.
01:55:22 <Hi-Angel> I also tried to search a description of ¬´.cabal¬ª file, but end up with an answer on StackOverflow that the only description is the parser itself.
01:55:36 <jle`> > scanl f x [1..]
01:55:38 <lambdabot>  [x,f x 1,f (f x 1) 2,f (f (f x 1) 2) 3,f (f (f (f x 1) 2) 3) 4,f (f (f (f (f...
01:55:55 <jle`> -- ^ dramforeve, petercommand 
01:56:01 <jle`> * dramforever 
01:56:39 <dramforever> jle`: oh yes yes yes, forgot about those simplereflect things
01:59:49 <Cooler> how do you look at the type of monad?
01:59:55 <Cooler> :t gives an error
01:59:56 <lambdabot> Not in scope: ‚Äògives‚Äô
01:59:57 <lambdabot>     Not in scope: ‚Äòan‚Äô
01:59:57 <lambdabot>     Perhaps you meant one of these:
02:00:04 <Cooler> :t monad
02:00:05 <lambdabot> Not in scope: ‚Äòmonad‚Äô
02:01:39 <dramforever> Cooler: Monad isn't a value, so it doesn't have a type. on the other hand, if you really wanted the lower case monad then I don't know what it is
02:02:00 <dramforever> Monad is a typeclass
02:02:22 <Cooler> look at its definition i mean
02:02:34 <Hi-Angel> Cooler, but you can get some info of a monad with ¬´:i Monad¬ª
02:03:43 <dramforever> Cooler: check the docs/source code. if you are having trouble finding them try these
02:03:46 <dramforever> @hoogle
02:03:48 <lambdabot> No query entered
02:03:48 <lambdabot> Try --help for command line options
02:03:51 <dramforever> @where hoogle
02:03:52 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle ‚Äì See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
02:06:33 <v_g> --help
02:11:36 <amicuscuriae> why don't someone just strip Leksah and make into a Editor only version, it looks like an awesome editor but I don't or understand what else does it do or even if it works
02:24:45 <beaky> hello
02:25:02 <beaky> how do i parse a line into different tokens
02:25:09 <beaky> with regex
02:27:02 <ChristianS> beaky: it depends on what exactly you're trying to do, but regexes are rarely the best solution in haskell
02:28:39 <beaky> ah i see
02:29:10 <beaky> i just want to parse simple cli arguments
02:29:23 <beaky> that is a regular grammar
02:29:29 <Walther> beaky: i have a short example of regex in haskell at http://walther.guru/one-hour-haskell
02:29:32 <beaky> but i coud be mistaken
02:29:44 <dramforever> @hackage optparse-applicative -- maybe?
02:29:44 <lambdabot> http://hackage.haskell.org/package/optparse-applicative -- maybe?
02:30:09 <beaky> thanks ll vheck those out
02:31:48 <beaky> i love writing parsers 
02:58:17 <pavonia> What's the best way to hide a global state using the Bot type from http://hackage.haskell.org/package/fastirc-0.2.0/docs/Network-FastIRC-Session.html that can be used from within all of the event handlers of onEvent? I could probably wrap an extra ReaderT around that stores an MVar, but maybe there's another/better way?
02:59:04 * hackagebot cndict 0.6.2 - Chinese/Mandarin <-> English dictionary, Chinese lexer.  https://hackage.haskell.org/package/cndict-0.6.2 (DavidHimmelstrup)
03:04:06 <Heffalump> is there any "obvious winner" around nowadays if I want a library for indexed monads?
03:09:04 * hackagebot resolve-trivial-conflicts 0.3.1.2 - Remove trivial conflict markers in a git repository  https://hackage.haskell.org/package/resolve-trivial-conflicts-0.3.1.2 (EyalLotem)
03:14:04 * hackagebot mandrill 0.4.1.0 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.4.1.0 (AlfredoDiNapoli)
03:24:26 <notdan> Hi
03:24:38 <beaky> hello notdan
03:25:32 <notdan> I would like to take this opportunity to advertise my blogpost about directed types in Darcs: https://parenz.wordpress.com/2015/09/20/darcs-directed-types/
03:25:43 <notdan> finished during the ongoing Darcs sprint in Paris
03:41:05 <labbe> > pl 1
03:41:06 <lambdabot>      Not in scope: ‚Äòpl‚Äô
03:41:07 <lambdabot>      Perhaps you meant one of these:
03:41:07 <lambdabot>        ‚Äòpi‚Äô (imported from Prelude),
03:41:27 <hexagoxel> are there hooks into the rts for stuff like memory/heap usage, gc counts, etc.?
03:41:28 <labbe> > pl
03:41:30 <lambdabot>      Not in scope: ‚Äòpl‚Äô
03:41:30 <lambdabot>      Perhaps you meant one of these:
03:41:30 <lambdabot>        ‚Äòpi‚Äô (imported from Prelude),
03:41:31 <labbe> > unpl
03:41:33 <lambdabot>  Not in scope: ‚Äòunpl‚Äô
03:42:45 <hexagoxel> labbe: are you looking for @pl and @unpl ?
03:43:07 <labbe> Yeah
03:43:54 <labbe> It's not working for me?
03:45:03 <slack1256> @pl \x -> x
03:45:03 <lambdabot> id
03:45:15 <slack1256> he doesn't like you :-)
03:45:55 <hexagoxel> it only does not like you if you use @src :D
03:45:55 <slack1256> > id "> is for evaluate code"
03:45:57 <lambdabot>  "> is for evaluate code"
03:46:13 <slack1256> yeah, don't remember me lol
03:48:49 <slack1256> *remind me
03:49:09 <slack1256> "remember me" is only valid if you are doing some kind of pop song
03:54:14 <labbe> Haha okay thanks
03:54:32 <labbe> Can I whisper it somehow? I don't want to clog the chat
03:55:23 <labbe> @pl \c a b -> if c then a else b
03:55:23 <lambdabot> if'
03:55:56 <labbe> > if'
03:55:57 <lambdabot>      Not in scope: ‚Äòif'‚Äô
03:55:58 <lambdabot>      Perhaps you meant ‚Äòf'‚Äô (imported from Debug.SimpleReflect)
03:56:01 <tomus> my syntastic spits out "/usr/lib/ghc-7.8.3/settings: openFile: does not exist", but the ghc is 7.10.1!
03:56:12 <lamefun> Parsec uses UndecidableInstances? Does that mean they aren't things to avoid all the time?
03:57:14 <labbe> > [1, 2, 3] !! 0
03:57:16 <lambdabot>  1
03:59:16 <labbe> @pl \i a -> if i >= 0 && i < length a then Just (a !! i) else Nothing
03:59:16 <lambdabot> flip flip Nothing . ap (ap . (if' .) . ap ((.) . (&&) . (>= 0)) ((. length) . (<))) ((Just .) . flip (!!))
03:59:26 <labbe> Oh shit
03:59:36 <amicuscuriae> hey whhat Haskell editor do you use?
04:00:29 <amicuscuriae> I need GUI + Auto completion
04:00:45 <slack1256> no kidding I used nano for a year
04:01:01 <amicuscuriae> slack1256, nano has autocompletion?
04:01:02 <slack1256> I didn't know what grep was and what autocomplete was
04:01:02 <amicuscuriae> :)
04:01:14 <slack1256> I can't say I am more productive now
04:01:27 <tomus> I think I got both ghc in ~/.cabal and in /usr/lib
04:03:15 <Franciman> Hello
04:03:47 <Franciman> I'd want to write a TUI for my program. What library would you suggest me for this purpose?
04:04:06 * hackagebot arbtt 0.9.0.6 - Automatic Rule-Based Time Tracker  https://hackage.haskell.org/package/arbtt-0.9.0.6 (JoachimBreitner)
04:04:45 <labbe> @unpl flip flip Nothing . ap (ap . (if' .) . ap ((.) . (&&) . (>= 0)) ((. length) . (<))) ((Just .) . flip (!!))
04:04:45 <lambdabot> (\ s f -> return ((\ ab ag g -> (ag >>= \ ac -> return ((\ bg -> if' (return ((\ au i j -> (au >= 0) && (i j)) ab ((\ ba bj -> ba < (length bj)) ab)) ab bg)) g ac)) g) s ((\ bd bm -> (Just) (bm !! bd)) s)) s f Nothing)
04:08:50 <slack1256> labbe: you can also /msg lambdabot and issue you commands
04:13:45 <beaky> hah obfuscated haskell
04:14:07 * hackagebot spdx 0.2.1.0 - SPDX license expression language  https://hackage.haskell.org/package/spdx-0.2.1.0 (phadej)
04:14:09 * hackagebot tttool 1.4.0.5 - Working with files for the TiptoiÆ pen  https://hackage.haskell.org/package/tttool-1.4.0.5 (JoachimBreitner)
04:19:07 * hackagebot singleton-nats 0.3.1.0 - Unary natural numbers relying on the singletons infrastructure.  https://hackage.haskell.org/package/singleton-nats-0.3.1.0 (AndrasKovacs)
04:20:34 <Walther> Hmm. I'm writing a simple tutorial for haskell, trying to have a bit of an IO example in it but I get "file locked"
04:20:43 <Walther> here's a paste http://walther.guru/temp/haskell-simple-io/
04:21:56 <amicuscuriae> Guys I need a simple GUI Editor for Haskell with Auto completion and all, Atom don't seem to work?
04:22:14 <ChristianS> Walther: haskell is lazy, therefore you're trying to read and write a file at the same time, which won't work
04:22:16 <beaky> emacs?
04:22:31 <beaky> emacs has auto complete
04:25:52 <Walther> ChristianS: right. What would be the simplest way to go around it, in a beginner-friendly way (again, in the context of writing a tutorial)
04:26:02 <slack1256> there isn't a good out-of-the-box haskell editor apart from atom or fpcomplete editor
04:26:30 <slack1256> but once you know either sublime, emacs or vim you can set them up easily for haskell
04:26:54 <slack1256> (otherwise, use haskell-mode on emacs and use the CUA mode for normal keybindings)
04:27:21 <Walther> ChristianS: for context, http://walther.guru/one-hour-haskell
04:29:19 <ChristianS> Walther: not sure if there is a beginner-friendly way. you could read file a, write file b, delete a, rename b to a.
04:29:33 <indiagreen> or you could print length of context
04:29:47 <indiagreen> * content
04:30:15 <indiagreen> this would force the file to be read completely and then closed
04:31:13 <indiagreen> if you do it, you should add a comment explaining that ‚Äúactual reading happens only now because blah blah laziness‚Äù and maybe mention the ‚Äúfile locked‚Äù error too
04:53:23 <beaky> can haskell be used for shell scripting
04:53:51 <beaky> a la python and ruby 
04:54:11 <indiagreen> beaky: yeah
04:54:12 <MarcelineVQ> you bet, especailly with the Turtle package, https://hackage.haskell.org/package/turtle
04:54:36 <beaky> wow turtle looks incredible
04:54:37 <indiagreen> see the tutorial here: https://hackage.haskell.org/package/turtle-1.2.1/docs/Turtle-Tutorial.html
04:55:02 <beaky> is it like ipython for haskell
04:56:09 <MarcelineVQ> dunno
04:56:57 <Guest67442> hey guys what are you talking about
05:01:33 <tomus> I'd be happy to advocate vim if it didn't break today with: usr/lib/ghc-7.8.3/settings (syntastic complaining)
05:10:29 <beaky> is stack like npm for haskell
05:17:17 <tekkkz> Hello! I'm doing CIS 194 tutorial ATM. On Lesson 1, at the homework (http://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf) I did excercise 1 already: http://ix.io/kVH -> WORKS! But I tried exc. 2, was wrong, have no idea, can someone help me pls?
05:17:29 <Walther> hmm. Trying out Turtle by the tutorial, with the simple helloworld I get an additional line in stdout saying "Using resolver: lts-3.5 from global config file: /home/walther/.stack/global/stack.yaml"
05:18:27 <cocreature> Walther: that's coming from stack, if you compile it instead of using 'stack runghc' or something like that, that line won't be there
05:18:43 <quchen> tekkkz: What's doubleEveryOther []? doubleEveryOther [x]?
05:18:58 <quchen> tekkkz: Hint: compile with -W and see what the compiler says :-)
05:19:04 <Walther> hm, any other ways to hide it? Compiling into an executable kind of defeats the purpose of 'shell scripting in haskell'
05:19:34 <quchen> Wait, you've got -Wall enabled already. The compiler should warn you about the forgotten cases already.
05:19:41 <tekkkz> ya
05:19:42 <tekkkz> i see
05:19:46 <tekkkz> let me have a look
05:19:47 <hodapp> Walther: you're trying to shell script in Haskell too?
05:19:50 <tekkkz> ahh, let me try to fix it
05:20:14 <Walther> hodapp: saw the comment in the channel a couple rows up, thought "that could be amazing" :)
05:20:24 <tekkkz> uhh, btw, could someone check if i did exc. corect? i mean it works but just check pls?
05:20:32 <hodapp> Walther: I wasn't here a couple rows up
05:20:38 <cocreature> I don't think there is another way, you could open an issue on the stack repo
05:20:51 <Walther> 14:53:50 < MarcelineVQ> you bet, especailly with the Turtle package, https://hackage.haskell.org/package/turtle
05:21:55 <hodapp> Walther: someone here had some interesting in reviving Hugs for a purpose like this
05:21:56 <quchen> tekkkz: What's toDigits 100000?
05:22:01 <hodapp> scripting and also embedding
05:22:30 <tekkkz> ugg
05:22:33 <tekkkz> its wrong ...
05:22:46 <tekkkz> man, im so bad i already loose at the first homework ...
05:22:54 <tekkkz> quchen, could you help me pls?
05:23:30 <quchen> tekkkz: You can recursively define your "toDigits" function, then it works for any number. The base case is "what's the last digit of a single-digit number?"
05:23:37 <quchen> Can you write that one?
05:24:12 <tekkkz> hm what do you mean now?
05:24:57 <quchen> What is the last digit of a single-digit integer? Implement that.
05:25:34 <quchen> How do you check whether a number has only one digit?
05:27:01 <beaky> maybe if its string length is 1?
05:27:08 <quchen> No.
05:27:14 <quchen> I mean that's correct, but terrible.
05:27:27 <quchen> You never want to convert to String, and you never want to use length, if you can avoid it.
05:27:29 <beaky> :D
05:27:33 <MarcelineVQ> good thinking but not ideal for this case
05:27:48 <MarcelineVQ> tekkkz: Integer math deals in whole numbers, so you can tell using integer division.
05:27:55 <MarcelineVQ> > 7 `div` 10
05:27:57 <lambdabot>  0
05:27:58 <MarcelineVQ> > 11 `div` 10
05:28:00 <lambdabot>  1
05:28:00 <saep> one digit in base 10
05:28:23 <beaky> yes divide by the radix
05:29:10 * hackagebot gipeda 0.2 - Git Performance Dashboard  https://hackage.haskell.org/package/gipeda-0.2 (JoachimBreitner)
05:29:48 <ss_> @pl: readLn >>= ((flip replicateM_) $ getLine >>= print . sum . map read . words)
05:29:48 <lambdabot> flip replicateM_ (print . sum . map read . words =<< getLine) =<< readLn
05:31:45 <hodapp> Walther: sivteck was interested in something similar, but he didn't have much time to pursue it
05:31:54 <hodapp> not around but is sometimes
05:32:52 <Walther> Bahahaha https://github.com/chrisdone/hell - "A haskell shell. Welcome to Hell!"
05:34:33 <tekkkz> MarcelineVQ, quchen and what should i do with it now?
05:35:23 <kaidelong> is there any intellij plugin that supports stack?
05:35:38 <kaidelong> also, is "stack ide" actually documented anywhere?
05:35:53 <kaidelong> I'm getting the impression that it is a half-baked feature whose only documentation is "read the source code"
05:36:07 <hodapp> what *is* 'stack ide'?
05:36:08 <kaidelong> and you're still supposed to use ghc-mod
05:36:48 <kaidelong> hodapp: it sends JSON objects representing information as a helper for an IDE
05:36:57 <MarcelineVQ> tekkkz: determine what to do for 2 digits, and 3, and then determine that is similar between them you might be able to write in a more general way, like a recursive function. week1 can be a tough start so don't feel discouraged, be sure to check out the related reading from the lecture page
05:37:10 <MarcelineVQ> *determine what is similar
05:37:11 <quchen> tekkkz: I was trying to get you to write the correct toDigits function in very small steps.
05:37:14 <kaidelong> I think it can be run both as a server and via invocations as a command line tool
05:39:11 <quchen> tekkkz: This would work a lot better if you talked to us about what you're trying or doing :-\
05:40:13 <MarcelineVQ> as in showing your work, http://lpaste.net/ is quite good for that
05:40:46 <hodapp> kaidelong: sounds like more of a ghc-mod wrapper than an IDE
05:45:45 <hpc> http://lpaste.net/6701826106359545856 -- i am getting this error when trying to use aeson and acid-state in the same project
05:45:54 <hpc> time to start over with my cabal database?
05:46:26 <delYsid`> Given a StateT String [] a, how do I get the list of all possible complete paths [[a]]?  I sort of reinvented this pattern with rec (a,s)  = p s >>= fmap (a ++) . rec where p :: StateT String [] a, but I think there should be a more generic way to do that?
05:47:57 <delYsid`> er, StateT String [] [a]
05:48:19 <amicuscuriae> hey guys is there a way to like pre-compile or test the program you wrote before actually compiling a binary?
05:48:42 <kaidelong> hodapp: it's meant as a tool for adding haskell support to an ide, stack is not an ide in any way shape or form definitely
05:49:15 <tekkkz> quchen, sur
05:49:16 <tekkkz> e
05:49:20 <dramforever> amicuscuriae: ghci can load your code and allow you to play with it, if that's what you want
05:49:21 <srhb> amicuscuriae: You can skip various parts of the compiling process, like code generation so you're only really doing type checking, which is arguably a kind of testing.
05:49:22 <tekkkz> i was afk, now i try to do sth
05:49:42 <srhb> amicuscuriae: If you try to tell us what you want to achieve, perhaps we can help you better.
05:49:46 <amicuscuriae> dramforever, ok
05:49:49 <amicuscuriae> I did it
05:50:14 <amicuscuriae> srhb, I want to know how my program would be when it is finally compiled?
05:50:19 <amicuscuriae> is what i want basically
05:50:26 <amicuscuriae> is there any other way?
05:50:30 <srhb> amicuscuriae: Right, but why do you NOT want to compile it?
05:50:32 <dramforever> amicuscuriae:  it's not clear why you can't do that without compiling
05:50:38 <Axman6> amicuscuriae: are you using ghci?
05:50:43 <dramforever> *with compiled binary
05:50:52 <amicuscuriae> srhb, I would not a problem :] 
05:50:57 <amicuscuriae> dramforever, I would then
05:51:08 <dramforever> amicuscuriae: it seems that you are having some problems with ghci...
05:51:26 <amicuscuriae> Axman6, I am using ghc/ghci both I am complete newbie trying to rejuvenate programming zeal in me
05:51:51 <Axman6> well, ghci lets you use your code without compiling it into a binary
05:52:01 <beaky> btw what is the difference between using clang and gcc to build haskell 
05:52:02 <amicuscuriae> dramforever, 1) I cannot ever exit it, 2) if the program is just suppose to print a string for example how can ghci help me?
05:52:08 <beaky> and which should i use
05:52:12 <amicuscuriae> gcc
05:52:14 <amicuscuriae> GNUuuuuuuuuuu
05:52:33 <quchen> You should just donwload a binary GHC release.
05:52:49 <bennofs> beaky: you mean between LLVM and the native codegen? (compiling via GCC is not supported in normal GHC builds afaik)
05:52:50 <quchen> Compiling yourself is really only useful if you're working on the compiler.
05:52:52 <beaky> yes
05:52:56 <dramforever> amicuscuriae: 1) :q (short for :quit) will exit it, 2) how can compiling stop you?
05:52:56 <Axman6> beaky: you shouldn't have to care, let ghc choose
05:53:00 <beaky> right
05:53:21 <amicuscuriae> dramforever, What do you mean compiling stop me?
05:53:24 <amicuscuriae> I don't follow me
05:53:28 <amicuscuriae> you*
05:53:28 <amicuscuriae> lol
05:53:28 <Axman6> oh, right, yeah I wouldn't recommend compiling GHC, use a standard release
05:53:51 <Axman6> amicuscuriae: we don't know what you want
05:54:01 <amicuscuriae> Axman6, nvm
05:54:03 <dramforever> amicuscuriae: are you worried about compilation speed?
05:54:03 <amicuscuriae> Sorry
05:54:16 <MarcelineVQ> amicuscuriae: he's saying you can type :q in ghci to exit it. you can use runhaskell or runghc to run your program without doing any manual compilation steps. You can also load it in ghci though and use the `:main` command inside of ghci to do the same thing. The benefit to using ghci for it is you can look at things that aren't working right. type :h or :help in ghci to see what commands it has
05:54:17 <bennofs> beaky: I've heard that llvm is better at lowlevel optimizations, while the native codegen does better at more haskell-specific "high-level" optimizations (not really high-level, since the real high-level Core-to-Core passes are applied in both cases)
05:54:42 <quchen> LLVM is good with loops.
05:54:54 <amicuscuriae> MarcelineVQ, Awesome :)
05:55:03 <bennofs> amicuscuriae: why is it NOT possible for you to compile the program and test it?
05:55:05 <amicuscuriae> dramforever, no I am not worried at al
05:55:06 <MarcelineVQ> and don't be afriad to google things that confuse you
05:55:15 <amicuscuriae> bennofs, please stop I just asked you
05:55:52 <amicuscuriae> I don't use google sorry
05:55:55 <dramforever> amicuscuriae: oh you must be finding alternative ways to run haskell code, but your original question is really weird, you know
05:56:00 <amicuscuriae> hey can Haskell access internet directly?
05:56:10 <maerwald> ??
05:56:18 <Axman6> of course it can :\
05:56:24 <amicuscuriae> I mean I would like to create a program that gets something from Internet asnd print it
05:56:28 <tekkkz> quchen, so i found out now hot to do it for 0,1,2 digit numbers
05:56:30 <amicuscuriae> ok
05:56:34 * dramforever needs the original @faq of lambdabot...
05:56:37 <tekkkz> quchen, now i should find out how for three
05:56:40 <MarcelineVQ> google is a verb now, it just means to search for things on the internet, I don't care if you use google`, I'm just saying you can use a search engine to answer simple questions faster than people can answer them much of the time
05:56:44 <Axman6> people write full web servers in Haskell all the time
05:56:48 <tekkkz> and then find the similars between 2 and 3?
05:56:49 <quchen> tekkkz: And then for four, five, six, seven, and tenthousand.
05:56:49 <Axman6> and web clients
05:56:57 <tekkkz> quchen, okay
05:56:58 <amicuscuriae> ok
05:57:11 <maerwald> MarcelineVQ: it's a common troll attempt to say "I don't use google" ;)
05:57:25 <amicuscuriae> Axman6, Can you suggest me a simple thing to look into at very beginner stage? Something with Internet?
05:57:48 <quchen> tekkkz: My avice is still to first write the base case, a function that maps an integer of a single digit to a list of all its digits.
05:58:06 <dramforever> amicuscuriae: are you already somewhat familiar with haskell? what about sockets?
05:58:09 <Axman6> I don't know what that means, but you probably want: https://hackage.haskell.org/package/http-streams-0.8.3.3/docs/Network-Http-Client.html
05:58:09 <MarcelineVQ> maerwald: I've had a similair outlook for days on that particular subject, but you don't want to be wrong in case someone's just a little odd, there might be a haskell programmer hidden inside.
05:58:27 <amicuscuriae> dramforever, ok I would look into it
05:58:40 <tekkkz> quchen, what do you mean ? i didnt understand
05:59:03 <quchen> What digits does the integer 3 consist of?
05:59:05 <quchen> What digits does the integer 5 consist of?
06:02:11 <jophish_> Hi all
06:02:16 <dramforever> MarcelineVQ: I don't use google because f*** whatever part of the Chinese government which is responsible for this crappy Great Firewall thing...
06:02:31 <MarcelineVQ> idc
06:02:41 <tekkkz> quchen, ?
06:02:43 <MarcelineVQ> sry :>
06:03:25 <dramforever> MarcelineVQ: just trying to say you are wrong...but just realized that maybe you are actually right
06:03:53 <dramforever> anyway let's stop this
06:04:09 <quchen> tekkkz: Write a function "toDigit :: Integer -> [Integer]", that given a single-digit integer, maps it to the list of its digits. (We'll worry about bigger numbers later.)
06:07:30 <quchen> I'll just end this one-sided conversation here and go cycling instead.
06:07:38 <tekkkz> quchen, no
06:07:44 <tekkkz> quchen, im trying atm
06:08:04 <tekkkz> here
06:08:20 <tekkkz> quchen, you mean something like this: http://ix.io/kVI
06:08:20 <tekkkz>  ?
06:10:13 <bennofs> tekkkz: that looks good. You can even write it much simpler: for what numbers is toDigits number = [number] ?
06:10:43 <tekkkz> for number lower than 10
06:11:16 <tekkkz> bennofs,  | n < 10          = [n] or what?
06:11:20 <bennofs> tekkkz: right :)
06:11:48 <bennofs> tekkkz: so, we've covered the cases that n <= 0 or n < 10. So we still need to deal with the case that n >= 10
06:11:58 <tekkkz> yes
06:12:03 <tekkkz> how should i go on now?
06:12:08 <tekkkz> case for <100?
06:12:15 <bennofs> tekkkz: you will never finish then. 
06:12:23 <tekkkz> true
06:12:27 <tekkkz> hm, how then?
06:13:02 <bennofs> tekkkz: so, let me tell you that we can handle all other numbers with one case. So, let's just add another case:  | otherwise = ... (replace your third case, which looks bogus to me)
06:13:41 <bennofs> (using otherwise instead of n >= 10 here signals to the compiler that we covered all cases.)
06:13:51 <tekkkz> ahh ya
06:13:54 <tekkkz> i read about it yet
06:14:16 <tekkkz> *already
06:14:54 <MarcelineVQ> otherwise is a synonym for True, as the name suggests it just means if nothing above it matches then match it
06:15:14 <bennofs> tekkkz: so, the critical step now is this: can you devise of a way to implement the case for n < 100 by reusing the case for n < 10 ?
06:15:41 <tekkkz> let me have a thought now, wait a bit
06:16:11 <amicuscuriae> I cannot understand the complex equation of List Comprehension
06:16:42 <Gothmog_> Is there any common lifting function serving the purpose of (.).(.) ? I'd like to get \x y -> fromInteger $ (f `on` g) x y pointfree, but I find (fromInteger .) . (f `on` g) slightly unreadable.
06:16:57 <MarcelineVQ> amicuscuriae: it's pretty straightforward
06:16:59 <MarcelineVQ> > [x | x<-[1..10], even x]
06:17:01 <lambdabot>  [2,4,6,8,10]
06:17:30 <MarcelineVQ> That says, I want to make a list where each elemen is x, I'll draw from a list of 1 to 10, I want only even numbers
06:17:32 <bennofs> Gothmog_: i personally prefer fmap fromInteger . (f `on` g), although some find that even more unreadable. There's also (.:) for this operation in some libraries, let me look it up
06:17:51 <tekkkz> bennofs, i dont get it, what do you mean?
06:18:24 <Peaker> Gothmog_: why does it have to be point-free?
06:18:43 <amicuscuriae> MarcelineVQ, omg :) So simple thanks Are yo a teacher? Awesome man
06:19:03 <bennofs> tekkkz: ok. let's call the function we've written so far toDigits10: it works for all numbers n < 10
06:19:14 <Gothmog_> It doesn't, of course. And if there isn't a common function I'll rather write it pointful.
06:22:20 <Gothmog_> But I'm curious, as I stumbled upon needing (.).(.) (or even (.).(.).(.) ...) more than once.
06:23:26 <jophish_> Where would be a good place to file a fewature request for hackage?
06:24:00 <bennofs> jophish_: https://github.com/haskell/hackage-server I believe
06:24:16 <jophish_> super! thanks, bennofs
06:25:01 <jophish_> ah, there's already a bug filed for exactly what I want
06:25:20 <amicuscuriae> how do we share source code here?
06:25:22 <amicuscuriae> for help?
06:25:29 <MarcelineVQ> @where lpaste
06:25:29 <lambdabot> http://lpaste.net/
06:25:43 <amicuscuriae> Can we use our own?
06:25:49 <amicuscuriae> ok it works
06:25:50 <amicuscuriae> thanks
06:27:46 <ralu> I am unable to install/build clash with ghc 7.10.2. I cant figure out if it is even compatible with this version. It suppose to work with 7.10.1, but i dont have it
06:33:51 <amicuscuriae> MarcelineVQ, I am writing a program that would take your first name and would provide you with a list having your similar names with Full name and age and address
06:34:04 <amicuscuriae> but it is not as easy as it looks 
06:34:05 <amicuscuriae> :)
06:52:29 <kaidelong> so I mentioned that church tuples are nice because they let you make nermele-style holes into first class values
06:52:31 <kaidelong> however
06:52:47 <kaidelong> are there arguments for using church booleans and church numerals, too?
06:53:31 <kaidelong> I imagine the numeral case is unlikely, but I imagine church booleans might have some interesting use cases
06:53:34 <dramforever> um...what's a nermele-style hole?
06:53:36 <kaidelong> that I didn't think of
06:53:49 <kaidelong> dramforever: f(x,_,y,z,_,w)
06:53:58 <kaidelong> to curry specific arguments to f
06:55:13 <kaidelong> if you treat tuples as functions that apply values to functions then you have a representation of something like (x,_,y,z,_,w) you can pass around
06:55:25 <kaidelong> it's first class
06:56:03 <dramforever> ok I get it
06:57:32 <kaidelong> http://nemerle.org/About#ID0ERH
06:57:56 <ManateeLazyCat> Hi guys.
06:58:02 <kaidelong> this kind of partial application is one of the reasons I really prefer tupled syntax to "foo bar baz quux"
06:58:33 <kaidelong> also, you are less likely to accidentally forget some argument
06:58:43 <kaidelong> the compiler can tell you you have an arity error
06:58:50 <srhb> Yikes. :P
06:59:18 <kaidelong> anyway what I was thinking originally was
06:59:28 <kaidelong> "this is probably the only church encoding I could actually get behind"
06:59:44 <kaidelong> but I'm wondering if church booleans have some neat uses with things like <*> I don't know about
07:00:09 <kaidelong> I guess you could just use "bool" though
07:00:11 <kaidelong> @type bool
07:00:13 <lambdabot> a -> a -> Bool -> a
07:00:17 <dramforever> "forget some arguments" hmm...I thought polymorphism and currying would make people forget about those arity things to some extent
07:00:18 <kaidelong> oh, it has the wrong type
07:00:41 <dramforever> for example, question: how many arguments are passed into the first "id" in...
07:00:44 <dramforever> :t id id id id id id
07:00:45 <lambdabot> a -> a
07:01:34 <kaidelong> just one, and it's a function
07:01:35 <srhb> dramforever: One. 
07:01:43 <kaidelong> I'm sure you could mix the styles though
07:01:54 <kaidelong> "id id id id id" makes sense but "(+) 2 3" doesn't as much
07:01:58 <dramforever> srhb, kaidelong: exactly
07:02:02 <kaidelong> compared to (+)(2,3)
07:02:21 <tomus> ghci: import Vision.Image; :hoogle Image -> Image. Warning: Unknown type Image
07:02:26 <kaidelong> I don't usually use the "id id id id" style as that is less readable usually
07:02:33 <srhb> I really dislike the tupled style. What's the chance of your program actually being well-typed if you manage to forgot one or more arguments to some function?
07:02:36 <kaidelong> so that syntax more often gets in the way than helps
07:02:45 <srhb> _less_ readable?
07:03:07 <kaidelong> yes, it's like you're reading lisp
07:03:09 <srhb> I guess there's no accounting for taste. :P
07:03:31 <kaidelong> one thing I have to hand Java is that . chaining is actually syntactically pleasant
07:03:34 <kaidelong> and works well with tools
07:03:39 <srhb> But you are the very first person I've heard of who prefers tupled style and thinks it more readable.
07:03:44 <srhb> Assuming you're not just trolling.
07:03:46 <srhb> :P
07:03:51 <kaidelong> I'm not
07:03:56 <srhb> OK. Color me surprised.
07:04:05 <kaidelong> besides, you miss out on partial application of arbitrary arguments with this
07:04:08 <kaidelong> also
07:04:21 <kaidelong> I'm not speaking in general, if you're doing actual "id id id id"
07:04:27 <kaidelong> the un-tupled style is in fact nicer
07:04:45 <kaidelong> when you're actually wanting that left associativity
07:04:53 <kaidelong> but with things like (+) the left association doesn't really matter
07:04:59 <kaidelong> and those things are more common
07:05:23 <kaidelong> tupled style means you don't need as many parens
07:05:40 <kaidelong> comma separated expressions instead
07:05:59 <kaidelong> well, at least if you can freely mix the two
07:06:31 <kaidelong> which would be the point of taking the approach "all functions are curried and tuples just apply arguments to curried functions"
07:06:50 <kaidelong> the underlying syntax is "f x y z" and tuples essentially "de-sugar" to that
07:07:26 <kaidelong> now you don't need to wrap functions all the time and church tuples can still be used in the same way
07:11:38 <clinton> The 'hoogle' hackage page here: https://hackage.haskell.org/package/hoogle seems to imply one can search the whole of hackage, but I'm unsure how. I'm happy to use the command line version if required.
07:12:53 <MarcelineVQ> if you just want easy checking you can integrate it into ghci like so www.stephendiehl.com/posts/vim_haskell.html
07:13:44 <MarcelineVQ> you'll need to run `hoogle data` on the cli after you build it with cabal
07:14:24 <MarcelineVQ> you can also just use https://www.haskell.org/hoogle/ if you want a simple interface to it
07:14:55 <clinton> I've run "hoogle data" bit it's not searching all packages
07:15:24 <MarcelineVQ> hoogle deals mostly with standard libs afaik
07:15:33 <clinton> presumably it's using the default behaviour and only searching packages in the platform
07:16:02 <clinton> but it's hackage page seems to imply it can search the lot
07:18:05 <srhb> You might also want to use the fpcomplete version of Hoogle.
07:19:25 <clinton> yep I gave that a go also no luck
07:21:50 <MarcelineVQ> hmm seems like you run, `hoogle data all` to nab everything
07:23:18 <MarcelineVQ> which eats some ram, ye gods
07:23:50 <amicuscuriae> What is command for getting a input from usr?
07:26:04 <KaneTW> http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html
07:26:21 <KaneTW> getLine probably
07:26:28 <KaneTW> is probably what you want*
07:31:03 <amicuscuriae> yep getLine
07:31:18 <lamefun> I'm curious, are list and monad hardwired?
07:31:34 <KaneTW> i don't think they are
07:31:57 <KaneTW> you should check though
07:31:57 <lamefun> I mean, is it possible to make a replacement package for base?
07:33:14 <KaneTW> you'd have to compile ghc against it
07:35:52 <bennofs> lamefun: Monad is hardwired for do notation, although -XRebindableSyntax allows you to redefine (>>=) and (>>) and use that for do syntax
07:36:07 <clinton> MarcelineVQ: Thanks! But I've only got 8gig on this box so it may not end well
07:41:01 <jmcarthur> 8gig is enough to compile ghc... or do you mean filesystem, not ram?
07:41:19 <clinton> lamefun: "import Prelude ()" 
07:41:23 <jmcarthur> if filesystem... i have no idea if it's enough, but i think it should be?
07:41:40 <clinton> there's quite a few replacement prelude's out there already
07:45:27 <amicuscuriae> http://lpaste.net/141365
07:45:32 <amicuscuriae> What is wrong with you?
07:45:36 <amicuscuriae> with it*
07:46:16 <glguy> It looks like you forgot to paste the error message
07:47:09 <glguy> printStrLn should be putStrLn
07:47:26 <amicuscuriae> oh 
07:47:28 <amicuscuriae> :/
07:49:37 <amicuscuriae> it won't work with putStrLn even i think the program is flawed
07:51:01 <glguy> You'll have to share what you expected it to do and what it did
07:52:21 <amicuscuriae> print a Char from user input and quit or user just hit return without any char it must ask him to enter again
07:53:18 <glguy> Your version loops in the case where it prints the char
07:53:34 <glguy> and just pressing enter doesn't return a ' ', it returns a '\n'
07:54:32 <glguy> putChar doesn't put a newline, so when it prints the char it's on the same line as the next prompt
07:55:14 <MarcelineVQ> It doesn't quite work right, but if you just want it to compile your main problem is that  `putStrLn "Enter a Char:"` isn't indented
07:55:45 <amicuscuriae> ok
07:55:47 <glguy> Actually, that indentation is fine
07:56:02 <MarcelineVQ> oh? it didn't compile for me unless I indented putStrLine
07:56:32 <glguy> It's funny because there's a tab on that line
07:56:46 <glguy> so your editor might be messed up or your browser
07:58:05 <MarcelineVQ> I've remade it with spaces, and it wants putStrLine to be indented ^^; http://lpaste.net/141366
07:58:30 <exio4> wha's putStrLine?
07:58:32 <glguy> yeah, the version that amicuscuriae pasted was indented
07:58:36 <jophish_> I'm writing a haskell library which deals with physics where a term is often referred to as Œ© (an upper case omega). I've seen other bits of code which in order to use an upper case letter at the start of an identifier prefix it with an underscore. I've seen others which use an acronym of the full term. What would /you/ consider more idiomatic? longitudeOfAscendingNode = Œ© or longitudeOfAscendingNode = lan
07:58:47 <glguy> MarcelineVQ: something's wrong with either your browser or editor
07:58:48 <jophish_> err, I mean _Œ©
07:59:09 <MarcelineVQ> glguy: Oh I see what you're saying
07:59:12 <amicuscuriae> glguy, I think second main should not be there right?
07:59:31 <glguy> amicuscuriae: The second main causes the program to repeat
07:59:43 <glguy> so it should only be there if that's what you wanted it to do
08:04:14 <amicuscuriae> glguy, but what I want it to do is "print char and quit if one char is enter" but if only return is enter it should ask again until a char is entered
08:04:46 <glguy> OK, then put the use of 'main' in the else branch of your if-expression
08:04:56 <amicuscuriae> glguy, I just did
08:05:00 <amicuscuriae> but it won't work
08:05:52 <amicuscuriae> glguy, http://lpaste.net/141367
08:06:20 <lpaste_> glguy annotated ‚ÄúNo title‚Äù with ‚Äúamicuscuriae‚Äù at http://lpaste.net/141366#a141368
08:06:43 <glguy> amicuscuriae: ' ' means "space" rather than "nothing"
08:06:53 <amicuscuriae> lol
08:06:54 <glguy> '\n' means "new line" aka "return"
08:07:06 <amicuscuriae> ok
08:08:29 <amicuscuriae> glguy, Ok then how can I make it such that uhmm until we have a lowercase char it would repeat or unit it has a char from a-d whether Upper or lower
08:09:23 <Fuco> Im using this to create a named pipe: tryJust (guard . isAlreadyExistsError) (createNamedPipe "/tmp/mypipe" namedPipeMode) ...  but when I then try to `openFile` it tells me it doesn't exist.  When I look in the system it does exist... so I think that function doesn't block until tje pipe is created? How can I make it block
08:09:55 <glguy> \x -> Data.Char.isLower x || 'A' <= x && x <= 'D'
08:10:04 <glguy> Is how I understood what you wrote
08:10:51 <glguy> Fuco: You can't make openFile block until the file exists
08:11:29 <Fuco> glguy: why not? And I actually ment createNamedPipe should block until it creates the file
08:12:20 <glguy> Fuco: I don't know about createNamedPipe, I was only talking about openFile
08:12:36 <Fuco> right
08:13:35 <Fuco> actually seems like in unix you can't write to a pipe unless something reads it? :O Because when I cat the file I can open it just fine
08:13:39 <Fuco> but without that I can't
08:14:18 * hackagebot geom2d 0.2.1 - package for geometry in euklidean 2d space  https://hackage.haskell.org/package/geom2d-0.2.1 (seppeljordan)
08:18:50 <amicuscuriae> glguy, how slow should i go with programming (learning) .. I am forgetting everything .. I have to compare c with each element of the lists I have but it just won't work
08:21:55 <glguy> amicuscuriae: For learning I'd just encourage you to practice writing small programs. I'm not sure what to recommend there :) I don't understand your second statement. Maybe you could structure it as a question with an example?
08:22:33 <glguy> "How do I compare a character for membership in a list of characters? E.g. is E in ABCDEFG?"
08:24:03 <amicuscuriae> yepp
08:24:16 <amicuscuriae> glguy, have you used Cryptohash before?
08:24:21 <glguy> > elem 'e' "abcdefg"
08:24:23 <lambdabot>  True
08:24:28 <amicuscuriae> omg
08:24:29 <glguy> > elem 'z' "abcdefg"
08:24:30 <amicuscuriae> I forget elem
08:24:31 <lambdabot>  False
08:24:31 <amicuscuriae> :/
08:24:42 <amicuscuriae> I am going too fast
08:25:12 <glguy> I don't know if I've used "Cryptohash" but if you have a question about it you should just ask it. Maybe I figure it out, maybe someone else does.
08:27:21 <beaky> hello
08:27:36 <beaky> what do you use for decimal numbers (for e.g. currency) in haskell
08:28:14 <amicuscuriae> glguy, I want to do SHA-3 hash for user inputs and store it for processing ... Well I am trying to develop a Pass Gen .. 
08:28:21 <glguy> beaky: Data.Fixed.Centi might be what you want
08:28:35 <amicuscuriae> glguy, store as in only temporarily as long as program runs
08:29:29 <Clint> amicuscuriae: you may want cryptonite instead
08:29:37 <amicuscuriae> glguy, I would make it more complex with the output thing .. but only later on.. 
08:29:44 <amicuscuriae> ok
08:29:50 <amicuscuriae> Clint, Can you tell me the syntax?
08:30:00 <beaky> wow thanks illt ry cenit
08:30:23 <Clint> amicuscuriae: https://hackage.haskell.org/package/cryptonite-0.7/docs/Crypto-Hash.html
08:31:47 <Welkin> beaky: no one should ever store currency in a floating point format, ever!
08:32:10 <Welkin> beaky: you store the currency as an integer (e.g. $1 USD is 100)
08:32:33 <jophish_> beaky: There's almost certainly some library to deal with those
08:33:05 <glguy> Right, Data.Fixed.Centi
08:33:22 <amicuscuriae> Clint, I cannot understand I am already reading it, the syntax is not clear for anything what is :: 
08:34:20 <Clint> amicuscuriae: are you unfamiliar with type signatures?
08:35:51 <amicuscuriae> Clint, Sorry I am a complete beginnner tryin to be over smart but I really wanted to develop it right away :) I have it all in bash 
08:36:03 <amicuscuriae> Clint, I am sorry to trouble you so much :)
08:36:28 <Clint> amicuscuriae: that's okay, i have to go make breakfast
08:36:49 <amicuscuriae> Clint, Ok 
08:36:56 <amicuscuriae> Get me some if you like ..
08:39:02 <beaky> ghci
08:39:06 <beaky> oops wrong window
08:42:58 <sinelaw> Prelude> 
08:44:13 <mniip> sinelaw: import GHC.Prim
08:44:49 <exio4> Prelude GHC.Prim> 
08:46:05 <mniip> exio4, :set -XMagicHash
08:47:14 <exio4> mniip: Prelude GHC.Prim> 
08:48:23 <mniip> exio4, case indexIntOffAddr# nullAddr# 0# of 0# -> ()
08:48:51 <exio4> mniip: Segmentation fault
08:49:56 <mniip> who's at the tty then
08:50:37 <amicuscuriae> mniip, Can you help me with Crypto hash function? I want a SHA-3 512 Hash of a user input
08:52:51 <osa1> interesting. it seems like TH's reify function sometimes works on definition in the same module but sometimes doesn't?
09:07:47 <cbaatz> I'm using runIO in TH and would like to make sure that module is always recompiled (since it can't know the result of the runIO) - does anyone know how I achieve that?
09:12:07 <quchen> cbaatz: There's -fforce-recomp, maybe you can specify it on the module level via {-# OPTIONS_GHC -fforce-recomp #-}?
09:13:02 <geekosaur> I suspect not, it would have already made the decision to compile or not by the time it saw it
09:13:27 <cbaatz> quchen: That doesn't seem to work I'm afraid.
09:13:51 <geekosaur> (more precisely, if it has already decided it hasn't changed, it wouldn't look to see if the module had that pragma in it)
09:14:23 <quchen> geekosaur: I was hoping the compiled files had some flags stored in them, such as fforce-recomp
09:14:55 <cbaatz> It seems like it should be possible because TH has the addDependentFile function, which does seem to work. So always forcing recompilation should be a subset of that functionality.
09:15:22 <cbaatz> I tried adding addDependentFile "dev/urandom", but it wasn't lazy..
09:15:51 <quchen> I was about to suggest that. :-D
09:16:52 <quchen> What do you mean with "not lazy"? Did it attempt to read all of it?
09:17:13 <quchen> Then you could just write a wrapper script for "head /dev/urandom" and use that as your dep
09:17:37 <cbaatz> quchen: Yes.. I guess I could hack it and do something like /proc/stat or /proc/uptime..
09:18:07 <cbaatz> I'm just a bit surprised runIO doesn't automatically mark the file for recompilation since the infrastructure seems to be there to achieve it.
09:19:54 <quchen> cbaatz: I'm not sure that would be desirable. runIO is also useful for reentrant IO computations, such as pasting in config files.
09:20:07 <quchen> But I agree that a "recompile this module" action is missing here.
09:20:25 <cbaatz> quchen: Fair.
09:21:20 <quchen> cbaatz: What about addModFinalizer? Could you use that to modify a dummy file, and add that file as a dependency?
09:21:40 <quchen> Certainly not pretty, but it's what the API offers us :-|
09:22:34 <quchen> Heh, or you could even runQ (touch self)
09:22:52 <quchen> ‚Ä¶ if file modification times are what makes GHC decide whether to recompile, that is
09:25:34 <quchen> Hm, "The dependency is based on file content, not a modification time" for addDependentFile. I guess you'll have to use the stranger method.
09:29:25 <cbaatz> quchen: Hm, yes. It seems the /proc/uptime is the simplest for now, even if that breaks portability..
09:31:36 <quchen> cbaatz: You should get portability by writing to a file in your compilation directory and then checking that.
09:32:03 <quchen> Increment its contents via runIO and depend on it.
09:32:45 <cbaatz> quchen: Yeah, that's a better solution, I'll do that.
09:32:57 <cbaatz> quchen: Thanks for your help!
09:33:27 <quchen> I'll let you know if I find anything. It's probably worth a patch if we can come up with something.
09:34:22 * hackagebot primitive 0.6.1.0 - Primitive memory-related operations  https://hackage.haskell.org/package/primitive-0.6.1.0 (DanDoel)
09:42:29 <humanoyd> Is there a function `Bool -> a -> b -> Either a b` that returns Left a for False and Right b for True?
09:43:38 <bennofs> humanoyd: I don't know of such a function
09:43:51 <Jinxit> hoogle it
09:44:23 * hackagebot smoothie 0.4.2 - Smooth curves via several interpolation modes  https://hackage.haskell.org/package/smoothie-0.4.2 (DimitriSabadie)
09:44:59 <hodapp> humanoyd: you could build it quite easily
09:45:05 <humanoyd> Jinxit: hoogle didn't find anything...
09:45:19 <Jinxit> then you'll have to write it
09:45:26 <humanoyd> hodapp: yes, I have...but I thought this might be available somewhere
09:48:49 <sinelaw> is there an IRC support for stack?
09:49:03 <sinelaw> ...channel...
09:49:56 <sinelaw> never mind.
09:53:05 <Welkin> how would you go about storing IP addresses in a relational database?
09:53:25 <Welkin> I can't just assume it is IPv4 and store a Word32
09:53:41 <Welkin> if it is IPv4, then I need a Word128
09:53:45 <Welkin> er
09:53:49 <Welkin> if it is IPv6, then I need a Word128
09:54:20 <Welkin> but I don't want to have two fields for IPv4 and IPv6, where only one will have a value and the other is null
09:54:54 <Welkin> are IPv4 addresses a subset of IPv6?
09:55:07 <Welkin> if so, could I just store everything as IPv6?
09:55:39 <opqdonut> yes, they are
09:57:26 <opqdonut> Welkin: https://tools.ietf.org/html/rfc6052#section-2.2
10:02:36 <Welkin> hm
10:02:40 <Welkin> there is no word128 though
10:03:12 <Welkin> what would be the best way of representing this in haskell so that is also works with a sql database?
10:03:43 <Welkin> Bigint in postgres is only 64 bits
10:05:49 <Welkin> oh, I see
10:05:57 <Welkin> postgres has a special type for ip addresses
10:11:23 <quchen> cbaatz: From looking at GHC's source, it seems like it handles file-not-found errors via simply recompiling instead of throwing. Have you tried just adding a nonsense dependency?
10:12:13 <quchen> MkIface.hs:1440 is where the recompilation seems to be decided (based on hashes, which explains the eagerness)
10:12:38 <cbaatz> quchen: Yes, the compilation exits with error if the file is missing.
10:12:56 <quchen> Strange.
10:13:25 <cbaatz> quchen: I think it uses http://haddock.stackage.org/lts-3.5/base-4.8.1.0/System-IO.html#v:openBinaryFile
10:14:23 <quchen> cbaatz: Yes, but there's an explicit catchall block around the operation with a handler "\_ -> return recomp". I guess I'm missing something then.
10:14:57 <cbaatz> quchen: The error I got was: /proc/uptimed: openBinaryFile: does not exist (No such file or directory)
10:16:57 <DanielDiaz> hi! I have a bytestring and I would like to upload it to an FTP server. Found this (http://hackage.haskell.org/package/ftp-conduit) but dependencies are outdated. The ftphs library uses String, and converting my binary data to String doesn't seem like a great idea. Is there another option? Maybe I'm missing something very obvious? thanks!
10:18:31 <cbaatz> quchen: I guess what I'd like is something like forceRecompile :: IO Bool -> Q () addDependentFile and similar could then be written in terms of that.
10:20:24 <tomus> optparse-applicative: use 'argument str (metavar "FILE")' for an argument. hm... how to actually get the value?
10:20:27 <kaidelong> what's this about the next cabal being planned to end cabal hell
10:22:15 <monochrom> tomus: I have an elaborate example of using optparse-applicative at https://github.com/treblacy/random-read
10:23:01 <Cybermorpher> Hello!
10:23:17 <amicuscuriae> Cybermorpher, hey what's up
10:24:06 <geekosaur> kaidelong, once the ghc side is fixed at least
10:24:10 <Cybermorpher> Hey, been looking on google, for a place or any channel about android stuff,  i went to the ANdroid channel on here but nobody is really helping at the moment, so i saw on some other place ppl mentioning this channel.
10:24:15 <geekosaur> http://blog.ezyang.com/2015/09/is-no-reinstall-cabal-coming-to-ghc-8/
10:24:39 <Cybermorpher> I wanted to ask something about Android stuff so i dont know if this is the proper place although at least in here ppl are responding lol.
10:25:11 <glguy> The topic of this channel is the Haskell programming language
10:25:24 <Cybermorpher> I know but maybe someone know something about it.
10:25:32 <tomus> monochrom: cheers, I ll try to get the value of a position argument using your example
10:25:36 <Cybermorpher> I wanted to ask about data throttleing.
10:27:43 <jmcarthur> Cybermorpher: You are unlikely to find much help here. I don't know who directed you here, but this is not a good place to ask about Android.
10:28:41 <Cybermorpher> kay :) Android Channel isnt much help either :(
10:28:47 <geekosaur> there is sometimes discussion about ghc haskell on android. it's not going to be very helpful to you
10:29:15 <Cybermorpher> Yup i know nothing about haskell, probably c++ or java most like old stuff but nothing bout haskell.
10:29:45 <sm> Cybermorpher: https://gist.github.com/simonmichael/6161ed4a2bba71f9a247 shows all the android channels on Freenode, one of them will probablyyyelp
10:30:02 <Cybermorpher> thats helpfull
10:30:28 <Cybermorpher> see :) you guys managed to help me
10:30:32 <Cybermorpher> thanks a lot guys
10:32:23 <Cybermorpher> So how does haskell work on android if i may ask and maybe learn a lil if its ok to ask just for curiosity?
10:34:36 <sm> the wiki page is a good starting point
10:46:45 <sinelaw> what's a monoid without an empty?
10:46:53 <glguy> Semigroup
10:46:56 <sinelaw> semigroup?
10:47:00 <sinelaw> ah
10:47:09 <sinelaw> k
10:47:27 <sinelaw> why don't we have Semigroup => Monoid
10:47:47 <glguy> Because Monoid is in base and Semigroup isn't
10:47:53 <sinelaw> right right, but why
10:47:54 <monochrom> not enough demand
10:48:04 <sinelaw> I demand!
10:48:11 <sinelaw> now enough?
10:48:17 <monochrom> even Monoid sees only sufficient demand in recent years
10:48:21 <glguy> Sure, I just pushed the commit
10:48:33 <sinelaw> can you split base from compiler releases too?
10:48:38 <glguy> done
10:48:47 <sinelaw> +1
10:48:58 <monochrom> you can, but it does nothing
10:49:09 <sinelaw> it does?
10:49:19 <sinelaw> you can then release backported bases
10:49:38 <monochrom> you can release a version of base that no GHC version adopts
10:49:39 <glguy> backporting fixes is another thing
10:49:39 <sinelaw> instead of having to CPP or fallback to base-compat everywhere
10:49:56 <monochrom> but no GHC user can actually use it
10:50:48 <joneshf-laptop> someone set me straight, is `const` a higher order function?
10:50:50 <monochrom> when building GHC, GHC has to hardwire itself to one instance of base, and stick to it
10:50:57 <sinelaw> joneshf-laptop, 
10:50:58 <sinelaw> :t const
10:51:00 <lambdabot> a -> b -> a
10:51:07 <joneshf-laptop> according to wikipedia it is since it returns a function
10:51:19 <joneshf-laptop> according to TaPL it is for the same reason.
10:51:26 <monochrom> another way of saying this is that "cabal install base" is not going to change your base
10:51:38 <sinelaw> monochrom, but does it really? only a small portion of base is hardwired to ghc stuff (prim, etc.)
10:51:42 <glguy> joneshf-laptop: It needs to take a function as an *argument*
10:51:49 <joneshf-laptop> at least, as far as i understand the explanation in ß5.2
10:52:01 <kadoban> joneshf-laptop: Sure, I suppose so. Nobody really kind of calls out higher-order functions in haskell because it's like, most of them.
10:52:15 <kadoban> glguy: Traditionally functions that return functions are also higher order.
10:52:30 <geekosaur> sinelaw, base *contains* the runtime and primitives
10:52:43 <joneshf-laptop> kadoban, thats' the part that's sitting uneasy with me.
10:52:43 <sinelaw> it could contain only the minimum 
10:52:50 <sinelaw> not "everything you want in prelude"
10:52:50 <geekosaur> you might be able to rewire things so that it doesn't, but IIRC that has been investigated and found difficult
10:52:54 <kadoban> joneshf-laptop: Why?
10:52:54 <monochrom> prim infests Int. Int infests length. etc.
10:53:02 <geekosaur> there was an effort some years back to do it
10:53:15 <joneshf-laptop> kadoban, I've always thought it needed a function as an argument.
10:53:24 <sinelaw> ok, then we can at least have backports? :)
10:53:48 <kadoban> joneshf-laptop: Not how I learned it (though function arguments tends to be much more common, so that's the usual examples you'd see in other languages)
10:53:49 <geekosaur> to some extent
10:54:35 <joneshf-laptop> kadoban, do you know of a reputable definition for hof?
10:55:32 <kadoban> joneshf-laptop: I'm sure I have a textbook around here somewhere that defines it, but I doubt it's very authoritative.
10:55:36 <tekkkz> Hello! I'm at the homework 1 of CIS 194 week 1 (http://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf) and have a problem with Exercise 2: DoubleEveryOther ... http://ix.io/kW2 It works for numbers with digit-length 1,2,4 .. but everything else, yes, also 3, contains errors (e.g. that the double from right is not correct starting etc.) so maybe someone can give me my fault?
10:56:47 <glguy> It seems like it matters less what the "official" definition is and more about what you're trying to do/analyze/discuss
10:57:16 <joneshf-laptop> tekkkz, does it really work for lists of length 1?
10:57:41 <tekkkz> ya
10:58:10 <MarcelineVQ> But a 1 item list doesn't have an 'other' to double
10:58:40 <kadoban> tekkkz: I believe it wants you to double from the right, but you're doubling starting with the left.
10:58:46 <tekkkz> ªdoubleEveryOther [1]´ -> [2]
10:58:56 <tekkkz> kadoban, no, not rly
10:59:12 <nolrai66> tekkkz: so 111 should result in 212, or 121?
10:59:22 <tekkkz> 121
10:59:46 <kadoban> tekkkz: No, really. You are.
11:00:14 <tekkkz> kadoban, when i have 4 digits, its all correct
11:00:23 <joneshf-laptop> kadoban, glguy hmm, that fills me with unease.
11:00:39 <tekkkz> doubleEveryOther (toDigits 8765)    ->    [16,7,12,5]      => correct
11:00:40 <monochrom> I would add two "reverse"s so I can code up start-from-left and still obtain start-from-right
11:00:41 <kadoban> tekkkz: Yes, it'll be correct when you have an even number of elements.
11:00:53 <kadoban> tekkkz: Otherwise it's not.
11:01:01 <tekkkz> ahh ya
11:01:05 <tekkkz> so how to fix this?
11:01:39 <kadoban> tekkkz: The easy way is to rename that: revDoubleEveryOther, then write doubleEveryOther in terms of that using 'reverse' twice.
11:01:57 <frerich> You could also just drop the first element instead of reversing.
11:02:10 <kadoban> frerich: Huh?
11:02:21 <pikajude> so I can't rely on the runtime throwing NonTermination, right?
11:02:25 <MarcelineVQ> frerich: you're doubling from the right though
11:02:35 <joneshf-laptop> frerich, for an odd length you mean, right?
11:02:37 <kadoban> frerich: How would you know to drop the first element or not before getting to the end?
11:02:39 <tekkkz> hm kadoban your solution seems good for me, ill try this
11:02:44 <joneshf-laptop> frerich, and then add it back on
11:02:47 <frerich> joneshf-laptop: Right
11:03:03 <nolrai66> kadoban: How will reversing twice change 212 into 121? 
11:03:07 * nolrai66 is confused.
11:03:27 <kadoban> nolrai66: Reverse it, do the doubling thing, reverse it back.
11:03:29 <MarcelineVQ> nolrai66: if you work from the left but reverse first, you're working from the right, once it's done you reverse again and it's correct
11:03:32 <athan> What would be a good data structure for /deleting/ quickly based on the order of one key (like UTCTime), while /inserting and lookups/ are done with another key (an identifier, like Integer)?
11:03:54 <geekosaur> athan, priority search queue?
11:03:58 <frerich> kadoban: Well you check the length of the list. If it's an even number of elements, you can double the first element, the third etc.. For an odd number of elements, you can drop the first, then process the (now even-numbered) list, then add the first element again.
11:04:01 <sinelaw> Is there a "ToList" generalization for list comprehensions? like OverloadedStrings
11:04:07 <athan> geekosaur: hmm, okay I'll give it a shot
11:04:28 <joneshf-laptop> sinelaw, OverloadedLists
11:04:34 <sinelaw> thanks
11:04:38 <kadoban> frerich: Ah, then yes you can do that, but it sounds slightly more tedious to me.
11:05:08 <monochrom> but OverloadedLists is not for list comprehension
11:05:29 <monochrom> I don't understand the question. it contains internal conflicts.
11:05:34 <joneshf-laptop> 6 of one
11:05:40 <nkaretnikov> wrengr_away: really enjoying your replies to the num class thread
11:05:48 <nolrai66> I think maybe he wants MonadComprehensions?
11:05:50 <joneshf-laptop> monochrom, oh, hmm
11:06:09 <geekosaur> hard to say, I'd like a little more explanation of what they want
11:06:21 <monochrom> and MonadComprehension doesn't give "ToList" and is not "like OverloadedStrings"
11:06:32 <monochrom> see? the question is full of internal contradictions
11:07:16 <tekkkz> kadoban, i dont get it, can you help me more
11:07:44 <kadoban> tekkkz: Sure, what are you trying and what's going wrong?
11:09:38 <tekkkz> so, still i have no idea what yo meant with reversing, i interpretet it wrong, so explain again your solution?
11:10:00 <kadoban> :t reverse
11:10:01 <lambdabot> [a] -> [a]
11:10:03 <sinelaw> monochrom, ok. I want: \x -> [ y   | y <-  x ]  to have type: Foldable t => t a -> [a]
11:10:07 <kadoban> > reverse [1,2,3,4]
11:10:09 <lambdabot>  [4,3,2,1]
11:10:37 <sinelaw> or instead of Foldable, something that doesn't actually require collapsing into a list. (whatever that can be)
11:10:49 <kadoban> tekkkz: So your function, let's call it 'f' because I'm too laze to type: it's doubling starting from the /left/, correct?
11:10:52 <geekosaur> sinelaw, I don't think you can do that yet
11:11:06 <geekosaur> MOnadComprehensions is currently the only generalization at that level
11:11:12 <monochrom> MonadComprehension gives you Monad m => m a -> m a
11:11:27 <tekkkz> kadoban, wait a moment please
11:11:28 <kadoban> tekkkz: So if you /reverse/ the list first, then run your function, it has the correct numbers doubled (since the right became the left), but then the elements of the list are in the "wrong" order.
11:11:34 <kadoban> tekkkz: So you just reverse it back.
11:11:56 <monochrom> and yeah, there is currently nothing else
11:12:53 <kadoban> > reverse ((\(x:xs) -> x * 4 : xs) (reverse [1,2,3,4]))
11:12:55 <lambdabot>  [1,2,3,16]
11:13:05 <kadoban> Note how that changes the /last/ element in the list ^
11:14:01 <kadoban> > reverse . (\(x:xs) -> x * 4 : xs) . reverse $ [1,2,3,4] -- this is written more idiomatically, by the way. The above has more parens than are really pleasant.
11:14:02 <lambdabot>  [1,2,3,16]
11:14:31 <tekkkz> wow
11:14:34 <tekkkz> i dont look att it
11:14:38 <tekkkz> i need to get it at my own
11:14:54 <kadoban> Well, it's not exactly what you need to do anyway, just an example. Though it is close to what you need.
11:15:17 <Cybermorpher> WoW this looks complicated hehe.
11:15:54 <monochrom> tekkkz, kadoban's code is showing you how to "multiply the last item by 4" without tears
11:16:07 <joneshf-laptop> tekkkz, maybe try frerich 's suggestion first, and come back to kadoban 's after you understand the problem more?
11:16:22 <tekkkz> whats frerich solution?
11:16:28 <joneshf-laptop> tekkkz, sometimes it helps to look at a problem after you've already solved it, you get different insights that way.
11:16:44 <joneshf-laptop> tekkkz, also, sometimes another perpsective is more in line with how you think.
11:18:15 <tekkkz> okay
11:18:20 <tekkkz> double from left works now
11:18:45 <tekkkz> should i call this function ...Rev and the normal calls it and reverse it? or can i reverse inside the function ?
11:18:58 <Cale> So what thing is asking you to double the last element of a list?
11:19:12 <Cale> Is this just something that you need to do as part of whatever program you're writing?
11:19:33 <tekkkz> its homework from cis194 tutorial
11:19:39 <Cale> hmm
11:19:47 <tekkkz> but i got it working already
11:20:21 <Cale> Yeah, I'm just curious, because this is an example of an operation which you should never want to have to perform on lists.
11:21:01 <kadoban> It's for that kinda-badly formulated exercise for cis194 :-/
11:21:16 <srhb> Yes, people always end up having a lot of questions about it. Which is good, I guess, because it is weird.
11:21:42 <srhb> I wonder if the motivation was to show "lists are bad at this"
11:21:49 <kadoban> I don't think they're very useful questions though, IMO. They tend to just be "ugh, this sucks" questions, and since it's /really/ early on the way it's used ‚Ä¶
11:22:05 <delYsid`> How do I sum a list of Maybes?
11:22:22 <tekkkz> i got it, afk now, cu
11:22:46 <kadoban> :t mconcat -- this maybe, delYsid` ?
11:22:48 <lambdabot> Monoid a => [a] -> a
11:23:04 <srhb> kadoban: Yeah, you're probably right.
11:23:33 <kadoban> Plus, there's just no reason to specify that the lists have to be ordered that way. If you just conceptually reverse all of the lists, the exercise becomes much more natural.
11:24:02 <kadoban> So yeah, I'm not sure why it's done that way. I suspect it would be different with a class and ‚Ä¶ more preparation by the time the student gets to that point.
11:35:50 <delYsid`> > asum [Just 1, Just 2]
11:35:52 <lambdabot>  Just 1
11:35:58 <delYsid`> > msum [Just 1, Just 2]
11:36:00 <lambdabot>  Just 1
11:36:04 <delYsid`> why?
11:37:24 <kadoban> > mconcat [Just 1, Just 2] :: Maybe (Sum Integer)
11:37:28 <lambdabot>  Just (Sum {getSum = 3})
11:38:10 <kadoban> delYsid`: Because that's what asum and msum do. Check the types, it's Alternative and MonadPlus. It's essentially taking the first one that "succeeds", whatever that means. For Maybe, it's the first Just
11:39:25 <MarcelineVQ> > sum $ catMaybes [Just 1, Just 4, Nothing, Just 3]
11:39:27 <lambdabot>  8
11:40:24 <delYsid`> > catMaybes [Just 1, Nothing]
11:40:29 <lambdabot>  [1]
11:40:53 <dagle> Tried to show some haskell to 13 year olds, I think I lost them.
11:41:09 <delYsid`> I need something that preserves the error.
11:41:09 <supki> > ala Sum (foldMap.foldMap) [Just 2, Nothing, Just 3]
11:41:11 <lambdabot>  5
11:42:12 <kadoban> delYsid`: I am not sure what you're trying to do then. Describe?
11:42:37 <delYsid`> f [Just 1, Nothing, Just3] = Nothing
11:42:53 <delYsid`> f [Just 1, Just 2] = Just 3
11:42:54 <joneshf-laptop> wait whoa, what happened there?
11:43:01 <joneshf-laptop> :i Sum
11:43:06 <joneshf-laptop> erm..
11:43:23 <joneshf-laptop> ah
11:43:29 <joneshf-laptop> kadoban, clever :)
11:44:02 <kadoban> > foldl' (liftA2 (+)) (pure 0) [Just 1, Just 2]
11:44:03 <lambdabot>  Just 3
11:44:05 <kadoban> joneshf-laptop: Hehe :)
11:44:09 <kadoban> > foldl' (liftA2 (+)) (pure 0) [Just 1, Just 2, Nothing]
11:44:11 <lambdabot>  Nothing
11:45:21 <kadoban> delYsid`: ^ that? Seems kinda like there should be a more concise way, but I dunno. That's all that comes to mind.
11:45:40 <delYsid`> thats it, thanks!
11:45:46 <kadoban> 'welcome
11:46:33 <hexagoxel> :t fmap sum . sequenceA
11:46:34 <lambdabot> (Num b, Applicative f, Traversable t) => t (f b) -> f b
11:47:46 <hexagoxel> delYsid`: ^
11:47:49 <kadoban> Oh nice, that's a good idea.
11:49:25 <Clarice> cmccann: I thought you of all people would know of the alternative monad definition over []
11:49:28 * hackagebot ebnf-bff 0.1.1.0 - Parser combinators & EBNF, BFFs!  https://hackage.haskell.org/package/ebnf-bff-0.1.1.0 (Lokidottir)
11:49:28 <Clarice> whoops
11:49:38 <greg> whats a neat way to produce a list of length x with everything set to 0 except  the nth element which is set to 1
11:50:14 <glguy> take x (replicate (n-1) 0 : 1 : repeat 0)
11:50:43 <greg> glguy: thanks
11:50:47 <Clarice> My nick is unavailable? ._.
11:51:10 <exio4> replicate (n-1) 0 : 1 : repeat 0 isn't going to typecheck
11:51:14 <kristof> that is better...
11:51:35 <greg> exio4: why not?
11:51:41 <exio4> @type \x n -> take x (replicate (n-1) 0 ++ (1:repeat 0))
11:51:42 <lambdabot> Num a => Int -> Int -> [a]
11:51:49 <MarcelineVQ> cause the first bit is a list
11:51:50 <exio4> greg: replicate returns a list
11:52:08 <exio4> well, it would typecheck, but would find an instance that's a bit insane :) 
11:52:13 <exio4> s/find/need
11:53:18 <greg> ah i think you could use the ++ or do some kinda  reversal 
11:53:23 <greg> but i get the principle
11:53:26 <glguy> The orignal was untested, this one works better: replicate n 0 ++ 1 : replicate (x-n-1) 0
11:53:41 <cmccann> kristof: do I want to ask why me "of all people" >_>
11:53:44 <glguy> but assumes that x is long enough
11:54:19 <greg> cool thanks
11:54:28 * hackagebot hsexif 0.6.0.6 - EXIF handling library in pure Haskell  https://hackage.haskell.org/package/hsexif-0.6.0.6 (EmmanuelTouzery)
11:56:37 <kristof> cmccann: can't remember
11:57:26 <tomus> should I resort to regex for converting "(1, 2, 3)" (string) into a tupple or is there a better way
11:57:58 <cmccann> that does remind me though, I should start answering questions on Stack Overflow again. last time I logged in it had a little thing showing how close I'd be to getting the silver [monad] tag badge :T
11:58:19 <kadoban> > read "(1, 2, 3)" :: (Int, Int, Int) -- though it's not very pretty when it goes wrong
11:58:21 <lambdabot>  (1,2,3)
11:58:43 <kadoban> tomus: I'd use that or Parsec, depending.
11:58:49 <kadoban> regex are fugly
12:00:42 <kadoban> Or you could use ReadS to make the 'read' thing behave better in the presence of bad input.
12:03:09 <greg> strange error when starting the latest ghci 7.10.2 : please see http://lpaste.net/141378 
12:03:25 <greg> i just typed ghci at the prompt any ideas?
12:03:39 <kadoban> greg: Look at .ghci file, it probably has nonsense in it.
12:03:46 <greg> thanks
12:04:29 <greg> yeah some old config
12:07:21 <tomus> > reads "(1, 2, 3)"
12:07:23 <lambdabot>  []
12:07:41 <cmccann> :t reads "(1, 2, 3)"
12:07:43 <lambdabot> Read a => [(a, String)]
12:08:07 <cmccann> > reads "(1, 2, 3)" :: [(Int, String)]
12:08:09 <lambdabot>  []
12:08:15 <cmccann> > reads "(1, 2, 3)" :: [((Int, Int, Int), String)]
12:08:16 <lambdabot>  [((1,2,3),"")]
12:08:24 <tomus> :)
12:08:44 <kadoban> Yeah, I assume that happens because it defaults to some weird type, probably ()
12:08:49 <cmccann> > reads "()"
12:08:51 <lambdabot>  [((),"")]
12:08:53 <cmccann> yep
12:09:05 <kadoban> It doesn't have any way to guess what type you want, though in a real program it probably could based on context.
12:11:38 <MarcelineVQ> kadoban: I've noticed in a simple function it can deduce the read type by the type declaration
12:12:18 <MarcelineVQ> like: toDigitsRead :: Integer -> [Integer]  toDigitsRead = map (read . flip (:)[]) . show
12:12:35 <kadoban> Yeah, you either have to specify or context has to tell it. If you're using the value for something monomorphic it should be able to tell usually.
12:13:25 <tomjaguarpaw> Welkin: Did you get an answer to your Opaleye question?
12:18:02 <tomjaguarpaw> Welkin: If you need any more help please email me at the email address in the Opaleye README.
12:19:29 * hackagebot exinst-hashable 0.1.0.1 - Derive instances for the `hashable` library for your existential types.  https://hackage.haskell.org/package/exinst-hashable-0.1.0.1 (RenzoCarbonara)
12:19:31 * hackagebot exinst-bytes 0.1.0.1 - Derive instances for the `bytes` library for your existential types.  https://hackage.haskell.org/package/exinst-bytes-0.1.0.1 (RenzoCarbonara)
12:19:33 * hackagebot exinst-aeson 0.1.0.1 - Derive instances for the `aeson` library for your existential types.  https://hackage.haskell.org/package/exinst-aeson-0.1.0.1 (RenzoCarbonara)
12:19:35 * hackagebot exinst 0.1.1 - Derive instances for your existential types.  https://hackage.haskell.org/package/exinst-0.1.1 (RenzoCarbonara)
12:24:29 * hackagebot singletons 2.0.0.1 - A framework for generating singleton types  https://hackage.haskell.org/package/singletons-2.0.0.1 (RichardEisenberg)
12:25:35 <hexagoxel> @pl f x >> g
12:25:36 <lambdabot> f x >> g
12:25:39 <hexagoxel> @pl f () >> g
12:25:39 <lambdabot> (line 1, column 5):
12:25:39 <lambdabot> unexpected ' '
12:25:39 <lambdabot> expecting variable, "(", operator or end of input
12:26:10 <hexagoxel> that error does not make sense, does it?
12:26:51 <hexagoxel> @pl (f ()) >> g
12:26:51 <lambdabot> f () >> g
12:27:43 <pikajude> can i use a ghc flag or ghc-pkg or something to show the documentation path of a given module?
12:29:01 <geekosaur> ghc doesn't know about documentation. cabal-install does but I don't think it has such an option
12:29:12 <pikajude> ok
12:29:47 <pikajude> does anyone have a good workflow for browsing module docs inside a nix-shell?
12:30:19 <geekosaur> cabal info seems to show it
12:34:51 <greg> to get emacs working well with stack i had to manually cabal init sandbox
12:35:31 <gregnwosu> then i manually cabal installed hmatrix into the sandbox
12:40:15 <knupfer> What books are recommended after the wikibook, "learn you a haskell" and "real world haskell"?
12:40:26 <Saizan> is there a library to encode/decode [Char] to ByteString's in utf8?
12:41:50 <MarcelineVQ> knupfer: have you done cis194? https://www.seas.upenn.edu/~cis194/fall14/spring13/
12:42:12 <MarcelineVQ> I gotta say though if you've done the wikibook you should be ready to do your own thing
12:42:16 <exio4> Saizan: going to Text and then to ByteString, maybe?
12:42:19 <pikajude> Saizan: https://hackage.haskell.org/package/chunked-data-0.2.0/docs/Data-Textual-Encoding.html
12:42:21 <knupfer> MarcelineVQ: No, thank you for the pointer.
12:42:31 <exio4> oh, ok, nevermind then
12:42:38 <gregnwosu> knupfer : imo i think its time to start hacking when you finish those two books, there are great blogs like 100 days of hackage, adit.io, 20 intermediate haskell problems  but i think you probably have enough to start
12:42:48 <MarcelineVQ> knupfer: check out http://chimera.labs.oreilly.com/books/1230000000929/index.html too, it's full of interesting things
12:43:10 <knupfer> MarcelineVQ: I've already read that one :)
12:43:14 <Welkin> knupfer: several papers and blog articles
12:43:35 <Welkin> knupfer: haskellforall.com, SPJ's papers, etc.
12:43:44 <MarcelineVQ> knupfer: then‚Äã I'd say, start coding a project for own use :>
12:43:55 <knupfer> Welkin: I've read a whole bunch of papers but thought that there is perhaps something more systematically pedagogic.
12:44:05 <Welkin> knupfer: this too http://dev.stephendiehl.com/hask/
12:44:08 <gregnwosu> oh what i wish i knew when starting haskell is great 
12:44:21 <gregnwosu> and the typeclassopedia also v good
12:44:31 <MarcelineVQ> wiwik http://www.stephendiehl.com/what/
12:44:37 <MarcelineVQ> oh woops
12:44:40 <MarcelineVQ> you literlaly just linked it
12:45:15 <knupfer> It's a joy having people which are happy to help others to learn.
12:47:11 <knupfer> Actually I've already written some toy stuff, if someone has time to make stylistic suggestions: https://github.com/knupfer/haskell-emacs
12:47:58 <knupfer> I've learned only from the internet and don't know if it's actually a sensible style etc.
12:49:13 <MarcelineVQ> One option, style-wise, is to look at the source for popular libs
12:49:30 * hackagebot pandoc-types 1.12.4.6 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.12.4.6 (JohnMacFarlane)
12:51:02 <ReinH> pikajude, Saizan: the text plackage already has Data.Text.Encoding for that
12:51:06 <ReinH> *package
12:51:15 <pikajude> i thought it did bytestring <-> text
12:51:19 <pikajude> not String
12:51:23 <ReinH> ah
12:51:34 <knupfer> MarcelineVQ: I've read a bit the source of base, but was put off because all the specialize and inline pragmas. 
12:51:35 <ReinH> well, bytestring doesn't know anything about encodings
12:51:51 <exio4> ReinH: he specified utf8 :) 
12:52:02 <ReinH> Yes, but bytestring doesn't know about utf8
12:52:06 <ReinH> it just stores bytes
12:52:32 <MarcelineVQ> knupfer: yeah there's plenty of that, I was thinking more along the lines of popular hackage items
12:52:36 <knupfer> [Char] is already utf8, so you could just use B.pack
12:52:52 <glguy> No, [Char] isn't already utf8
12:53:26 <ReinH> ...
12:53:31 <knupfer> What is it if not utf8? At least I can write non-ascii.
12:53:50 <glguy> It's a unicode codepoint
12:54:08 <glguy> utf8 is a particular byte-level representation that Char doesn't use
12:54:24 <exio4> knupfer: B.pack takes [Word8], Data.ByteString.Char8 takes Char but overflows on past-255 values
12:54:30 * hackagebot yesod-content-pdf 0.1.0.1 - PDF Content Type for Yesod  https://hackage.haskell.org/package/yesod-content-pdf-0.1.0.1 (alexkyllo)
12:55:09 <ReinH> my point is that you should probably use Text
12:55:38 <glguy> The Handle IO functions in base can decode UTF-8, but by the time you get a Char that's already handled
12:56:07 <knupfer> ok
13:03:40 <knupfer> Is there current work for improving optimization of ghc? On the road-map for ghc8 is nothing about it.
13:03:44 <ReinH> you can store utf-8 encoded text in a bytestring but you won't be able to, e.g., treat it as a series of characters
13:08:33 <Saizan> ReinH: i just need a good roundtrip from [Char] to ByteString, ByteString does pointer equality and Text does not, it might matter for my use case
13:19:13 <JagaJaga> @pl foldr (\s rest -> rest + length s) 0 ["aaa", "bbb", "s"]
13:19:13 <lambdabot> 7
13:19:23 <JagaJaga> @pl foldr (\s rest -> rest + length s) 0
13:19:23 <lambdabot> foldr ((+) . length) 0
13:19:39 <Peaker> 7 is indeed point-free!
13:21:19 <Peaker> pl knows + is commutative, it's wise
13:22:07 <athan> How should I use flags to conditionally compile executable examples - Can I wrap an entire `Executable:...` stanza in a `if (someflag)`?
13:23:45 <JagaJaga> @source on
13:23:45 <lambdabot> Unknown command, try @list
13:24:48 <exio4> I laughed so hard at that, did pl just evaluate code? 
13:24:59 <geekosaur> athan: no, but you could specify "buildable: false" in a conditional
13:27:18 <sinelaw> heh
13:29:12 <kristof> Hi, largish question
13:30:15 <kristof> Is there any treatment out there where functions have linear types?
13:30:28 <kristof> Meaning, if I call f, I can't call it again.
13:30:53 <tekkkz> kadoban,  http://ix.io/kWb is working up to 5 digits, but not at 6 anymore .. ;(
13:30:54 <kristof> I think usually, the functions are not assumed to be linear, but their arguments and return types are.
13:31:18 <kristof> But I have run into the problem where closures over linear types are essentially functions of a linear type.
13:32:52 <kadoban> tekkkz: You seem to have ignored all advice, mine and everyone else's ‚Ä¶
13:33:33 <sinelaw> kristof, while you're at it, is there an accessible intro to linear types? been meaning to learn more about them for a while...
13:34:21 <hodapp> I'm doing a lot of linear... typing... right now. In that, I'm doing a lot of typing to bang out linear-algebra code in Python.
13:34:39 <kristof> Not quite what I had in mind :)
13:34:53 <hodapp> Think this is what I had in mind either?
13:35:01 <hodapp> :P
13:35:25 <kristof> sinelaw: http://www.mbsd.cs.ru.nl/papers/cleanbook/CleanBookI.pdf
13:35:27 <hodapp> I haven't looked much into linear types, but they're on my list of things to learn
13:35:33 <kristof> page 49 is the introduction to "uniqueness types"
13:35:38 <hodapp> .cs.ru.nl?
13:36:05 <sinelaw> kristof, thanks!
13:36:45 <Peaker> sinelaw: The Bob Harper intro to HoTT talks explain it a bit ("substructural rules")
13:37:04 <kristof> hodapp: ru is a university in the NetherLands
13:37:09 <kristof> cs is the cs department there
13:37:19 <hodapp> kristof: ohhhh I thought it was like .ru as in russia o_O
13:37:26 <kristof> nope.
13:37:53 <hodapp> I've never seen any other university write hostnames like that.
13:38:12 <kadoban> Like what?
13:38:24 <hodapp> wait... nevermind.
13:38:39 <kristof> sinelaw: Meant page 99
13:39:08 <hpc> hodapp: i see it all the time
13:41:54 <tekkkz> kadoban, which advice did i ignored!??
13:45:02 <hodapp> hpc: I was just thinking of it wrong; I do too
13:45:20 <hodapp> www.blahblahblah.libraries.derpiversity.edu in the US and such
13:49:01 <tekkkz> kadoban, c'mon, what do you mean?
13:53:44 <tekkkz> kadoban, im sorry, but what did i ignored???
13:55:03 <Cale> I'm not sure kadoban is here any more
13:56:06 <tekkkz> shit
13:56:12 <tekkkz> Cale, can you help me?
13:56:25 <Cale> maybe
13:56:33 <Cale> What's the question?
13:56:38 <tekkkz> okay, let me type
13:58:44 <tekkkz> im doing cis194 tutorials atm, im at week1 homework. I solved already the toDigits exercise, and now i cant get the doubleother working (excercise 2 of the first homework) so here is my code: http://ix.io/kWc and the doubleother should begin at the right of a list and double every second argument. this , like i have it, works up to 5 arguments, if i have 6, it fails. what did i wrong?
13:59:30 <Welkin> has anyone used specialized types in postgres or another database before?
13:59:33 * hackagebot haxr 3000.11.1.2 - XML-RPC client and server library.  https://hackage.haskell.org/package/haxr-3000.11.1.2 (BrentYorgey)
13:59:43 <Welkin> I would like to store an IP address as `inet` in postgres
13:59:50 <Welkin> but how can I make this work with haskell types?
14:00:02 <hpc> i wish aeson gave location info
14:00:08 <Welkin> I want it to be converted to SockAddr (or something similar) when I pull it out
14:00:18 <Welkin> and converted from SockAddr to inet when I write to the database
14:00:33 <hpc> i have to dig through 12 megs of data to figure out where it failed, and the error message is that it found an 'o' it wasn't expecting, so no help there
14:00:49 <Welkin> I did find FromField and ToField in postgresql-simple, but I have no idea how to use them or where to define the instances
14:02:23 <hpc> i might have to do it again with 160 megs too...
14:02:49 <dmj`> hpc: line number of a file containing json ?
14:03:06 <Welkin> dmj`: do you know anything about this?
14:03:12 <dmj`> Welkin: FromField / ToField ?
14:03:18 <hpc> dmj`: it's all on one line
14:03:21 <Welkin> well, I think that is what I need
14:03:30 <hpc> fortunately it's a top-level list so i can just split it into lines of items
14:03:32 <Welkin> SockAddr in haskell, and inet in postgres
14:03:37 <hpc> but it's taking forever to do the file modification
14:03:46 <hpc> my linux box is a $600 laptop from 2007
14:04:45 <dmj`> hpc: all one-line :/ 
14:04:53 <hpc> well, it's from a web api
14:04:57 <tekkkz> Cale, any ideas?
14:05:00 <Welkin> I thoguht about giving up on it and storing IP addresses as numeric(39), but that seems stupid, given that postgres provides special types made for this situation
14:05:23 <Cale> tekkkz: oh, sorry, one sec, I have work things
14:05:37 <tekkkz> Cale, sure, ok
14:05:39 <knupfer> tekkkz: what's wrong with it? It looks cryptic but it seems to work.
14:07:20 <tekkkz> knupfer, no, not at digits-amount > 5, e.g. doubleEveryOther (toDigits 123456) should produce [2,2,6,4,10,6] but it does [1,4,3,8,10,6]
14:07:48 <athan> Is there a proper way to turn a random ByteString into a nice Ascii string or something?
14:07:54 <athan> Maybe hexadecimal? :s
14:08:16 <RageD> anyone using Network.Socket.ByteString ever experience an issue recv'ing all the data? I have recv in a loop and can receive all but my final 2 bytes of data. In wireshark, it appears that all the data was appropriately sent
14:08:22 <Welkin> athan: I have written my own conversion function toHexString before to do that
14:08:23 <knupfer> tekkz: but that's fine, no? it multiplys every other number with 2 beginning from the right
14:08:57 <tekkkz> but it is doing wrong: [1,4,3,8,10,6] thats not from 123456 the correct calculation
14:08:57 <athan> :(
14:09:14 <Welkin> athan: maybe something in lens? or a pretty library?
14:10:11 <Cale> tekkkz: If there are 2 elements in the list, it doubles the first. If there are more elements in the list, it always doubles the second.
14:10:27 <Cale> tekkkz: (and not the first)
14:10:36 <tekkkz> oh, wait
14:10:51 <jle`> athan: i use base64 from that one library
14:10:56 <jle`> for my own purposes
14:11:34 <athan> thanks jle`
14:11:42 <dmj`> Welkin: I'd ask lpsmith in #snapframework
14:11:59 <dmj`> Welkin: or in here..
14:12:31 <jle`> athan: http://hackage.haskell.org/package/base64-bytestring ... but not that it's like, a "standard" choice.  i don't think there's a standard :)
14:13:01 <tekkkz> [x,2*y] works for all up to 3 and all number which cant be divided by 2 without rest (3,5,7)
14:13:10 <jle`> hex is ok but a bit verbose if you just want to "see" different bytestrings as unique things...i think hex makes more sense if you care about the actual binary underneath
14:13:15 <tekkkz> and when i doule first element, it works for all 2 4 6
14:13:28 <RageD> well, if anyone has any ideas let me know. Basically, I'm currently only receiving 8/10 bytes. What was received: "\NUL\STX9\ENQ\SOH\NUL\NUL\DEL" vs what was sent ""\NUL\NUL\NUL\STX9\ENQ\SOH\NUL\NUL\DEL"
14:13:29 <jle`> from a human standpoint at least
14:13:38 <tekkkz> no
14:13:41 <tekkkz> not for 6
14:13:42 <tekkkz> idk
14:13:49 <tekkkz> bit this is the problem point
14:13:53 <tekkkz> can you help?
14:13:59 <RageD> as you can see, I'm dropping two null bytes somewhere
14:14:26 <Welkin> parsing this could be tricky http://www.postgresql.org/docs/9.4/static/datatype-net-types.html
14:14:37 <Welkin> I wonder if that is how it stores it?
14:14:40 <Cale> tekkkz: Consider reversing the list beforehand, so that the pattern of which elements you need to double doesn't depend on whether the ultimate number of elements in the list is even or odd.
14:14:48 <wedify> i'm playing around with writing refactoring tools. currently my only idea is translating types to newtypes, and then inserting the appropriate handling at every use
14:14:52 <Cale> (and then reversing the result again afterward)
14:15:05 <tekkkz> Cale, i dont understand what you mean
14:15:15 <Cale> tekkkz: Well, let's consider a few lists
14:15:20 <tekkkz> y
14:15:22 <wedify> what other refactorings would people like to have exist
14:15:22 <Cale> If you're applying this function to
14:15:29 <Cale> [1,1,1,1,1,1,1]
14:15:43 <Cale> [1,1,1,1,1,1,1,1]
14:15:52 <Cale> what are the intended results in each case?
14:16:27 <Welkin> athan: sure, you could use Data.ByteString.Char8.pack, similar to what jle` suggests
14:16:54 <jle`> Welkin: i don't think that gives a printable string in most cases
14:17:04 <tekkkz> [1,1,1,1,1,1,1] -> [1,2,1,2,1,2,1]; [1,1,1,1,1,1,1,1] -> [2,1,2,1,2,1,2,1]; wih the 7 diggits my program works
14:17:11 <m_> hello, I have what is probably not a very great question regarding monad transformers/lifting/reuse ... is there anything I should read before I bother people here?
14:17:26 <Rembane> m_: Is that the question?
14:17:49 <jle`> m_: that's probably the most vague request i've heard all day.  just ask your question :)
14:17:57 <knupfer> tekkz: and with 8 as well
14:18:05 <dmj`> hpc: which library are you using for stream parsing w/ aeson ?
14:18:05 <jle`> it's probably impossible to give a meaningful recommendation if you don't even say what you're asking, heh
14:18:10 <Cale> tekkkz: So in the first case, you have the elements with odd indices being doubled, and in the second case, you have the elements with even indices from the start
14:18:11 <knupfer> only with 2 it's buggy
14:18:11 <dmj`> hpc: just curious
14:18:27 <tekkkz> ya
14:18:29 <Cale> tekkkz: and it's not possible to know which of these two results you want to produce until you've seen the end of the list
14:18:40 <Cale> tekkkz: because it depends on where the list stops
14:18:44 <tekkkz> ya
14:19:09 <Cale> tekkkz: If you reversed the list first, you could apply a function to the reversed list which didn't depend on the number of elements, and then reverse the result
14:19:21 <dmj`> m_: a question about monad transformers is not bothersome
14:19:23 <m_> ha, ok ... I have a simple stack of monad transformers ... StateT Stack (State Stack) ... I want to do things like "pop" from both of these stacks, but I'm having a difficult time doing this in a "reusable" way
14:19:32 <tekkkz> Cale, and what a function?
14:19:41 <Cale> i.e. you'd always be doubling the elements which have odd indices then
14:20:00 <tekkkz> wait, odd is 2,4,6?
14:20:09 <Cale> odd is 1,3,5
14:20:15 <Cale> (and I count indices starting at 0)
14:20:15 <tekkkz> ok
14:20:19 <tekkkz> ok
14:20:19 <knupfer> > odd 1
14:20:21 <lambdabot>  True
14:20:52 <tekkkz> Cale, isnt my function doing this already?
14:20:56 <Cale> A clever solution might use zipWith and cycle
14:21:10 <tekkkz> hm?
14:21:28 <Cale> > zipWith ($) (cycle [id,(*2)]) [1,2,3,4,5,6,7]
14:21:29 <dmj`> m_: mtl exposes typeclasses like 'MonadState' which you can derive, to make your stacks more 'reusable' example: newtype MyStack a = MyStack { runStack :: StateT Stack (State Stack) a } deriving (MonadState, Monad, Applicative, Functor)
14:21:29 <lambdabot>  [1,4,3,8,5,12,7]
14:21:49 <Cale> this doubles every other element starting from the beginning
14:21:59 <magneticduck> https://gist.github.com/5b3aeeead75f755342eb
14:22:03 <tekkkz> no, i just should use possibilities i learned in week1
14:22:03 <magneticduck> ugh I forgot how to do the haskell
14:22:06 <Cale> to do it from the end, we can reverse first, and then reverse the result afterward:
14:22:16 <Cale> > reverse . zipWith ($) (cycle [id,(*2)]) . reverse $ [1,2,3,4,5,6,7]
14:22:17 <lambdabot>  [1,4,3,8,5,12,7]
14:22:19 <dmj`> m_: well, since State and StateT are instances of MonadState there might be some functions constrained by MonadState which can be used on both types
14:22:21 <Cale> > reverse . zipWith ($) (cycle [id,(*2)]) . reverse $ [1,2,3,4,5,6,7,8]
14:22:22 <lambdabot>  [2,2,6,4,10,6,14,8]
14:22:24 <magneticduck> I'm trying to use a large let expression in a do block but it's not working, some parse error
14:22:36 <Cale> Of course, if you want, you can just write that bit recursively
14:22:42 <Cale> the middle bit there
14:22:45 <tekkkz> i shouldnt use them. btw, look at my functions result: [1,2,1,2,2,1,2,1] why ?
14:22:52 <m_> dmj`: ok, I will try that
14:23:29 <dmj`> hpc: the System.IO.Streams.Attoparsec.parseFromStream Data.Aeson.Parser.json' (inputStream -- maybe make this from a handle), might be faster... won't help w/ errors though
14:23:30 <magneticduck> tekkkz: it's pretty hard to black box a line of haskell, what's your code?
14:23:51 <tekkkz> http://ix.io/kWf
14:24:03 <dmj`> hpc: json' avoids thunk build up
14:24:40 <dmj`> m_: enable the {-# GeneralizedNewtypeDeriving #-} extension too
14:25:17 <dmj`> m_: also, the Grabmueller paper on transformers mentions a lot of this too. It helped me, http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
14:25:42 <lpsmith> Welkin, you can define the instances anywhere.  It's better to avoid orphans in publically released libraries,  but for your own private libraries or your own applications,  orphans are fine.
14:25:51 <tekkkz> oh
14:25:55 <tekkkz> i maybe found mistake
14:26:04 <m_> dmj`: this paper looks great, reading now, I appreciate the help
14:26:07 <jle`> m_: what are you doing right now?
14:26:16 <jle`> and what are its shortcomings?
14:26:22 <lpsmith> Welkin, on the other hand,  I would be interested in adopting quality support for the inet/cidr types into vanilla postgresql-simple.
14:26:34 <Cale> tekkkz: you definitely don't want the special case for 2 element lists
14:26:59 <dmj`> m_: yea, pasting code would help too (lpaste.net)
14:27:14 <jle`> m_: one thing people like to do with using multiple states is write everything using just the "part of the state" that they care about, and then use lens to have that `State s a` operate on a `State t a`
14:27:28 <Cale> also, you're switching between doubleEveryOther and doubleEveryOtherRev
14:27:31 <Cale> on each iteration
14:27:32 <tekkkz> i changed my code: (i removed 2 case and i changed recrusion to doubleEveryOtherREV
14:27:37 <Cale> which is superconfusing
14:27:38 <tekkkz> now look the result
14:27:46 <jle`> so if you have a `State (s, t) a`, then you can write a `State s a`, and then use `zoom _1` as a State s a -> State (t, s) a
14:27:57 <tekkkz> doubleEveryOtherRev (toDigits 1111111) -> [1,2,1,2,1,2,1]
14:27:59 <dmj`> Welkin: maybe use a newtype around SockAddr to avoid orphans..
14:28:00 <tekkkz> correct, right?
14:28:03 <Cale> yeah
14:28:05 <m_> dmj`: jle`: let me put together a very simple example, will paste shortly
14:28:08 <tekkkz> but
14:28:14 <jle`> so you can write all your code as if you only had "s"...and then use it in a big State (t, s)thing
14:28:32 <jle`> using zoom _2 :: State s a -> State (t, s) a
14:28:45 <tekkkz> oh
14:28:47 <magneticduck> jle`: I'm trying to start using lenses deep in my design patterns for reasons like this
14:28:48 <tekkkz> it works now
14:28:53 <magneticduck> scalability over arbitrary states
14:28:58 <tekkkz> it was just the mistake by using not rev in recursion
14:29:00 <dmj`> jle`: I guess m_ doesn't need a newtype deriving MonadState since State and StateT are instances... but he'll need mtl to use MonadState
14:29:06 <tekkkz> it was my typing mistake
14:29:07 <tekkkz> ...
14:29:08 <magneticduck> I usually ended up hand rolling some sort of structure
14:29:13 <tekkkz> thanks @all guyss
14:29:13 <JagaJaga> Hi! For example I have data A = A { a :: Int, b :: Int}. I can do `let g = A 1 2` and `g { b = 3 }`. How can I pass just `{ b = 3 }`? Or it's impossible?
14:29:27 <tekkkz> have a good night, cu , byebye
14:29:48 <magneticduck> JagaJaga: \x -> x {b = 3} is a function that sets the b field to 3
14:29:53 <jle`> magneticduck: it's a common pattern people advise for making State a little more nice to use...and if lens didn't have it, it'd be a good idea anyways.  you'd just have to re-implement it yourself, heh.  however i don't really think it's truly scalable
14:30:06 <magneticduck> also, haskell record syntax is uh, it's not JSON or anything
14:30:07 <knupfer> ciao tekkkz
14:30:20 <jle`> you still need to actually instantiate a "big fat state" type in the end
14:30:40 <jle`> even though the actual code/logic you write doesn't necessarily have to deal with it
14:30:53 <magneticduck> to reiterate a question that got cast by a few minutes ago
14:31:01 <magneticduck> https://gist.github.com/5b3aeeead75f755342eb
14:31:02 <dmj`> {-# HaskellJSONSyntax #-}
14:31:12 <JagaJaga> magneticduck: thank you!
14:31:15 <magneticduck> ^ parsing fails at first character of 'case event'
14:31:36 <magneticduck> dmj`: I half believe that
14:31:40 <m_> dmj`: jle`: https://gist.github.com/michaelavila/3dd6b207a4afadb6ecc8
14:31:55 <m_> jle`: I think this illustrates what I'm trying to achieve
14:32:09 <magneticduck> {-# HaskellGADTsJSON #-}
14:32:22 <jle`> m_: i balk a little bit at nested States like that
14:32:30 <jle`> how about just State (Stack, Stack)
14:32:32 <m_> I am open to ALL feedback
14:32:38 <jle`> and you can define pop1 and pop2
14:32:44 <jle`> or, define pop on State Stack
14:32:55 <jle`> and then use zoom _1 pop to pop from the first, and zoom _2 pop to pop from the second
14:32:58 <dmj`> magneticduck: :)
14:33:46 <m_> jle`: is there some heuristic you use when determing which things to layer?
14:33:54 <magneticduck> bah, guys, my let expression doesn't parse
14:34:25 <jle`> i don't think there are hard rules
14:34:27 <magneticduck> can't I use 'let x = \n <indent> <codecodecodecode>' in a do expression?
14:34:31 <dmj`> m_: so, why do you have 2 decks? Why not flatten your structure State (Stack, Stack) a
14:34:44 <dmj`> m_: what card game is this
14:35:07 <geekosaur> magneticduck, I think you need to indent the case beyond the start of mutateEvent
14:35:17 <geekosaur> i.e. add one more space in front of each line
14:35:18 <jle`> if you're willing to require `lens`, then you can use `zoom _1 :: State Stack Card -> State (Stack, Stack) Card`.  if you're not, you can write your own "onFirst" and "onSecond"
14:35:32 <jle`> onFirst :: State s a -> State (s, t) a, onSecond :: State t a -> State (s, t) a
14:35:34 <Cale> magneticduck: make sure that the code starts in a deeper column than the x on the previous line
14:35:36 <magneticduck> geekosaur: oh god that is horrifying
14:35:40 <m_> dmj`: that's what jle` pointed out, which I did start with, but I went down this path as an experiment (because this is somewhat new to me) thinking that it would help with what I felt was duplication
14:35:41 <geekosaur> otherwise it's taking it as the start of another variable
14:35:42 <magneticduck> I forgot how haskell is with spaces
14:35:44 <jle`> and then onFIrst pop is popping from the first one, and onSecond pop is popping from the second
14:35:44 <magneticduck> xD
14:35:56 <m_> dmj`: it's War (about as simple of a game as can be modeled)
14:35:59 <magneticduck> we do that variable-width indentation thing
14:36:03 <geekosaur> you do realize that it can set more than one variable?
14:36:07 <jle`> people usually don't nest the same transformer like that typically
14:36:16 <magneticduck> geekosaur: but not like 'let x = let b = asdf'
14:36:18 <m_> jle`: ok
14:36:22 <Cale> magneticduck: The first non-whitespace character following "let", "do", "of" or "where" sets the indentation level
14:36:33 <geekosaur> let x = y\n    z = w
14:36:59 <dmj`> m_: type War = RWST Players [String] (Deck, Deck, StdGen) IO ()
14:37:12 <magneticduck> geekosaur: huh okay
14:37:17 <magneticduck> yeah that's right
14:37:26 <Cale> magneticduck: Lines which start in the same column implicitly have a semicolon inserted before them. Lines indented to a shallower column close the block.
14:37:31 <magneticduck> I guess I usually just put an indentation right after let
14:37:42 <jle`> m_: if you did that, you can use mtl to make pop :: MonadState Stack s => s Card, so you write `pop` once, and it works for both StateT Stack m a, and State Stack a.  and then you can instantiate it on the layer you want using type signatures
14:38:40 <m_> jle`: I'm looking into this right now, this is the second time (different situation) that I've been told to take a look at lens
14:38:40 <jle`> actually type annotations might not be able to do it for you, nvm
14:39:15 <jle`> lens is nice here not because it's lens, but because it offers a very nice tool to mix State s a's of different State types, so you can write a State s for one state, and have it work for another
14:39:30 <jle`> it turns out that the machinery of lens gives you this "for free"
14:39:32 <jle`> which is nice
14:40:05 <m_> dmj`: admittedly this is my first time seeing RWST, I'm looking into this as well
14:40:10 <dmj`> m_: a wrote a game of War, if you want the code I can give it to you
14:40:24 <m_> jle`: I'll keep that in mind as I'm working through this
14:40:49 <m_> dmj`: I've actually got the game working a few different ways
14:41:08 <m_> it's sort of my playground for working out new ideas ... a program that's small enough and I know well enough to actually try stuff out
14:41:09 <dmj`> draw :: MonadState m => m (Card, Card); draw = get >>= \(x:xs, y:ys) >> return (x,y)... just be sure it add these two the winning deck
14:41:11 <jle`> honestly, for me, using State and doing this dance of mixing different state types using lenses and other machinery never really resounded with me as an elegant/particularly satisfying solution
14:41:32 <jle`> but if I had to use State and integrate many components of state, i'd use lens
14:42:00 <m_> jle`: I basically just need to maintain two stacks of cards
14:42:32 <jle`> mhm. and if you are going to write your code in an imperative manner, State (Stack, Stack) is the way to go, i think
14:42:45 <jle`> or at least one dominant way to go
14:42:46 <dmj`> m_: MonadState (Card, Card) m => m ..
14:43:12 <Cale> Something even nicer than using lens would be just to define your own class rather than using MonadState at all
14:43:28 <Cale> (well, you might still use lens behind the scenes)
14:43:30 <m_> jle`: do you have an alternative suggestion? I'm not trying to achieve anything other than learning right now
14:43:55 <Cale> But it tends to be nicer to have operations which are more descriptive than "get" and "put" when you have lots of state
14:43:57 <jle`> breaking free from imperative programming is my alternative suggestion :)
14:44:09 <SmartPrime> hey im trying to learn some new blackhat tips any one wanna help me out 
14:44:10 <dmj`> m_: I'd have a data Decks = Decks { playerOne :: P1Deck, playerTwo :: P2Deck }, newtype P1Deck = P1Deck Deck .. etc. newtype everything for safety
14:44:37 <m_> ok
14:44:37 <edwardk> SmartPrime: wrong channel
14:44:46 <m_> Cale: that makes sense to me
14:45:02 <m_> jle`: that makes sense to me too, and it's what I'm trying to do ... I'm sort of stuck in my own dimensions I guess right now
14:45:24 <jle`> if you're using State you're going to have at least a part of your algorithm/logic being imperative, and that's ok
14:45:27 <jle`> it's not a big sin
14:45:35 <Cale> I don't know whether I'd go so far as to newtype each player's deck given that the two players in the game are so symmetrical
14:45:49 <Cale> You can probably exploit the symmetry of the players
14:46:02 <Cale> by swapping them on each half-turn for instance
14:46:18 <dmj`> m_: I have a good suggestion for you, use QuickCheck to generate shuffled decks.
14:47:04 <dmj`> m_: then you could just do `generate arbitrary :: IO [Card]`
14:47:11 <dmj`> to get a fresh deck
14:47:17 <m_> Cale: that's an interesting idea, I could have State (Stack,Stack) ... and then all of the methods operate on fst and I just do the swapping back and forth as I need?
14:47:36 <m_> dmj`: I'm using random-shuffle to generate new decks, it seems to be working
14:47:59 <Cale> m_: Yeah, just have an action which swaps the two players
14:48:16 <Cale> (i.e. ends the current player's turn)
14:48:23 <m_> so I have a list of things to try, I really appreciat the help from all of the people
15:02:46 <hardmath123> I'm trying to figure out which imports I need to use parsec. Various tutorials have different imports, like Text.Parsec, Text.ParserCombinators.Parsec, Text.Parsec.Char, ...
15:03:38 <geekosaur> the first is the "generic" one. the second is an obsolete equivalent (parsec2 backward compatibility)
15:03:58 <geekosaur> depending on what you are doing, you may want multiple imports
15:04:29 <geekosaur> .Char is basic character parsing
15:04:57 <geekosaur> Text.Parsec imports that and a number of other things for you automatically
15:06:53 <hardmath123> ah, thanks. so Text.Parsec should be all i really need?
15:06:59 <geekosaur> yes
15:07:47 <geekosaur> later on if you want to use some of the "canned" parsers, you may want Text.Parsec.Expr and maybe Text.Parsec.Language
15:24:55 <hardmath123> how about Text.Parsec.String? does that not get auto-imported?
15:43:10 <geekosaur> hardmath123, http://lambda.haskell.org/platform/doc/current/packages/parsec-3.1.3/doc/html/Text-Parsec.html
15:43:32 <geekosaur> shows 6 modules that it imports for you, including Text.Parsec.String
16:07:54 <jle`> Control.Foldl is great
16:10:28 <slack1256> are clojure transducer equivalent to Control.Foldl?
16:10:44 <slack1256> I've seen that repeated somewhere modulo some impurities
16:11:26 <Axman6> Foldl also has a final transformation function
16:14:14 <jvm> In set theory, are the following statements true or false (i) 1 ‚àà 1 (ii) 1 ‚äÜ 1 ?
16:14:39 * hackagebot pipes-csv 1.4.2 - Fast, streaming csv parser  https://hackage.haskell.org/package/pipes-csv-1.4.2 (WilliamCasarin)
16:15:42 <slack1256> let's see. number are usually written like this in set theory, ( o  being the empty set)
16:16:12 <slack1256> eh, i don't remember i was something like this. 1 = {{o},o}
16:16:51 <slack1256> the thing is that when you translate the numbers on that notation, you can answer your question
16:17:11 <slack1256> there were other method of writing number with pure sets
16:17:54 <jvm> thanks for your answer :slack1256. not sure I follow though
16:19:05 <dolio> slack1256: I've been told they're more like `a -> [b]` but written as `forall r. (b -> r -> r) -> (a -> r -> r)`.
16:22:38 <hardmath123> wow, Parsec is so cool
16:22:46 <hardmath123> everything just works
16:28:51 <slack1256> jvm: yeah, I am also not that clear myself. That is what I got from a friend that studied foundational set theory. I just remember translating numbers to set of certain "form"
16:29:36 <gamegoblin> compiling all the dependencies for hlint jesus christ so many
16:29:53 <gamegoblin> src/Language/Haskell/Exts/Annotated/Syntax.hs took years to compile
16:31:19 <slack1256> same here, that module was the main culprit of my sandbox compilation times
16:31:33 <slack1256> eventually made go with nix and its binary caching
16:59:01 <thimoteus> jvm: the traditional way of constructing the naturals is to set the empty set as 0, then to set n as the set of all numbers that came before. so 0 = {}, 1 = {{}}, 2 = {{}, {{}}}, etc
16:59:50 <knite> I'm learning about lenses and the wreq library. I'm wondering why I can't do the following: get "http://httpbin.org/get" >>= (^. responseHeader "content-type"). no reply on #haskell-beginners
17:00:17 <thimoteus> then the epsilon relation is the same as the usual ordering
17:01:24 <glguy> knite: Try:    fmap (^. responseHeader "content-type") (get "http://httpbin.org/get")
17:02:32 <knite> glguy: that works, but I don't understand why the former doesn't. I'm still a Haskell rookie, but AFAIK in the former the >>= means "evaluate the first thing and pass it to the second thing" and the ^. is a lens getter.
17:02:34 <geekosaur> knite, the short version is that (>>=) requires the result to be in the monad. (^.) does not do that, itself
17:02:52 <glguy> :t (>>=)
17:02:53 <glguy> :t fmap
17:02:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:02:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:03:16 <glguy> assuming that   get :: IO Response
17:03:18 <geekosaur> so you can fmap it, or you can use `return` to put the result back in the monad, but you can't just apply it like that
17:03:29 <glguy> and (^. responseHeader "content-type") :: Response -> Header
17:03:43 <glguy> You can see how for >>= to work you'd have need a :: Response -> IO Header
17:04:11 <knite> hm...so let me work this through...
17:06:24 <knite> :t get String -> IO Response, so I have an IO Monad...so this would only work if responseHeader returned an IO Header...?
17:06:27 <lambdabot> parse error on input ‚Äò->‚Äô
17:07:20 <knite> I can do this with multiple lines in a do block. is there a more correct way to do it with a different operator than >>=?
17:08:12 <glguy> The do-notation is probably the most clear, the operator version of fmap is <$>
17:11:36 <phckopper> Hey
17:12:31 <knite> glguy: is there an operator that keeps the visual order correct? with <$> I would need to swap the responseHeader and the get.
17:14:12 <zaquest> :t (<&>)
17:14:12 <kadoban> knite: There's a (<&>) that's a flipped version of <$>
17:14:13 <lambdabot> Functor f => f a -> (a -> b) -> f b
17:14:24 <glguy> but not in bae
17:14:25 <glguy> base
17:14:34 <knite> AKA best not to use it?
17:14:35 <kadoban> knite: It's from lens I think, but you can just define it yourself if you don't want that dependency.
17:15:48 <kadoban> Or just, use <$> *shrug*
17:16:09 <glguy> knite: <&> isn't necessarily the "correct" visual order
17:16:15 <glguy> but of course it might be the one you wanted
17:16:42 <kadoban> It kinda seems like in haskell you generally need to get used to reading in either direction, depending on context.
17:20:06 <hodapp> left-to-right, right-to-left, inside-to-outside, outside-to-inside, or... middle-to-somewhere?
17:21:52 <DigitalKiwi> glguy !
17:22:01 <glguy> Hello
17:35:53 <lpaste_> tesrty pasted ‚Äúthinking the wrong way‚Äù at http://lpaste.net/2714285955157590016
17:36:37 <tesrty> So I'm clearly thinking of it in too much of an imperative sense. But I'm stuck trying to find the right way to look at this.
17:37:21 <tesrty> Before I go off typing more, is this even the right channel to ask about the 'correct way of thinking' for some haskell problem.
17:37:37 <tesrty> And I don't mean problem of the technical kind. Just the I'm bad with haskell kind.
17:38:58 <tesrty> in case it is, the [[String]] is representing a table that has a header, and rows. The idea is to pick a field from the header, and if present, show only those rows that match a certain value thats passed to 'select'
17:39:35 <tesrty> and please, don't supply me with code. It's an assignment and I'm trying to find the right way of thinking of this.
17:40:04 <adas> there is a fucntion called `fix` in Data.Function. what does it do? I tried `fix (+3)` but it just hangs there.
17:41:49 <slack1256> adas: do `take 7 $ fix (1:)' :-)
17:41:53 <geekosaur> adasit finds a least fixed point for a function. for (+3) the least fixed point is _|_ ("bottom" aka undefined)
17:42:28 <geekosaur> if a function can produce output before evaluating its parameter, then it can do something useful. (+3) is strict for most numeric types, so won't produce output
17:43:29 <geekosaur> this relies on laziness; in a strict language, it would always hang
17:43:57 <exio4> > (fix $ \fact n -> if n < 1 then 1 else n * fact (n-1)) 4 
17:43:59 <lambdabot>  24
17:44:07 <exio4> it's basically abstracting recursion
17:44:27 <MarcelineVQ> amazing
17:44:30 <geekosaur> as a practical thing, yeh; it's a way to have an anonymous function invoke itself recursively
17:45:23 <exio4> fix $ \loop -> do { ... ; ... ; ... loop ... ; ... }
17:46:27 <Cale> tesrty: I'm not totally sure what you're asking... but I see !! in your paste. Usually !! is something to be avoided as much as possible.
17:47:01 <Cale> tesrty: What are you hoping to look for with the filter?
17:47:45 <tesrty> I need to compare to a value thats in a certain position in an array
17:47:58 <tesrty> filter is however going over the array of arrays
17:47:59 <Cale> tesrty: Ah, I see, I suppose in this case it's quite hard to avoid using !!
17:48:12 <Cale> Really you mean lists, lists are not arrays
17:48:22 <tesrty> Sorry, lists
17:48:27 <geekosaur> it's not an array, actually. lists are singly linked lists, which are kinda loops waiting to happen
17:48:32 <tesrty> I think I've got it however. Wrote a helper function.
17:48:37 <Cale> okay
17:48:42 <tesrty> Can I update the pasta?
17:48:43 <geekosaur> you iterate over them, you dont generally index them. Vector is more like what you're thinking of
17:48:45 <Cale> sure
17:49:17 <adas> so its only purpose is to allow anonymous functions to recurse?
17:49:34 <Cale> adas: fsvo "only"
17:49:39 <lpaste_> tesrty revised ‚Äúthinking the wrong way‚Äù: ‚Äúthis seems more clear‚Äù at http://lpaste.net/2714285955157590016
17:50:10 <Cale> Homer: Hmm!  
17:50:10 <Cale> Frink: I take it from that little impressed noise that you are interested in purchasing that matter transporter, sir  
17:50:10 <Cale> Homer: Emm.. two bucks..'n ..it only transports matter ..um .... well ah..I'll give you thirty five cents  
17:50:51 <geekosaur> adas, there are other uses but you might find them esoteric or incomprehensible...
17:51:13 <adas> i thought fsvo was a typo. but that does not seem to be the case.
17:51:16 <tesrty> Cale: haha. good point. with haskell thats becoming very clear.
17:51:34 <geekosaur> "for some value of"
17:51:36 <adas> geekosaur: yup. fix is esoteric. 
17:51:59 <geekosaur> https://wiki.haskell.org/Tying_the_Knot if you want to get a sense of the possibilities (and probably blow your mind a bit_)
17:52:16 <Cale> > fix ((0:) . map (+1))
17:52:17 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:52:32 <Shockk> oh, whoever was telling me stuff about DataKinds yesterday
17:52:50 <Shockk> I looked into them a bit more today and it seems interesting :D
17:52:55 <adas> im ready for a mind fuck. thanksf or the link
17:53:01 <Cale> ^^ it can find fixed points which don't happen to be functions
17:53:16 <Cale> adas: In some sense, most recursion can be expressed in terms of fix
17:53:36 <Cale> adas: Some language implementations translate all recursion into uses of fix, and then implement fix.
17:54:11 <Cale> I say "most" rather than "all" recursion, because fix doesn't manage what's known as polymorphic recursion
17:54:29 <exio4> what'd be a primitive for that?
17:54:42 <Cale> where the type of the argument in the recursive use is different from the type of the parameter
17:54:47 <Cale> I don't know
17:55:17 <tesrty> I'm real happy. this:  select "gender" "male" [["first","gender"],["Alice","female"],["Bob","male"]]. works now. and only returns the table with the bob row.
17:55:22 <tesrty> Thanks for the help guys!
17:55:44 <adas> geekosaur: getting ones mind blown from time to time is a sane thing in haskell. it's abnormal only if it doesn't happen as often
17:55:57 <adas> tying the knot has a nice example with the list
17:56:00 <Shockk> I had my mind blown today when I realized how data kinds work
17:56:12 <geekosaur> sure, but some people prefer prior warning :)
17:56:16 <Pamelloes> Can fix be used to find a solution to a polynomial?
17:56:24 <exio4> Shockk: dependent types are hella nicer :) 
17:56:40 <Pamelloes> Actually, that doesn't make much sense.
17:56:49 <geekosaur> Pamelloes, probably, but I think there are easier variants.
17:56:54 <geekosaur> @google loeb and moeb
17:56:55 <lambdabot> https://github.com/quchen/articles/blob/master/loeb-moeb.md
17:56:57 <Cale> > let foo :: Show a => a -> Integer -> String; foo x 0 = show x; foo x n = foo (x,x) (n-1) in map (foo 'x') [0..]
17:56:59 <lambdabot>  ["'x'","('x','x')","(('x','x'),('x','x'))","((('x','x'),('x','x')),(('x','x'...
17:57:15 <Cale> ^^ this uses show at infinitely many types
17:57:23 <Shockk> exio4: hmm does Haskell have dependent typing?
17:57:30 <Cale> Shockk: not really
17:57:35 <geekosaur> not yet
17:57:53 <Cale> "yet" is presuming quite a bit :)
17:58:12 <Shockk> hmmm
17:58:18 <geekosaur> well, I'm presuming that the chatter in #ghc of late is somewhat accurate
17:58:19 <Cale> But yeah, many of us would like to see a lazy dependently typed functional language anyway
17:58:20 <exio4> Shockk: it doesn't! just saying a language with true dependent types makes that `type hackery` nice to work with, in Haskell it's a bit cumbersome and verbose and far more complex 
17:58:28 <geekosaur> that is, there are people working on it but there is no ETA as yet
17:58:38 <Shockk> exio4: ahhh right
17:58:58 <hodapp> certain folks certainly think it'll happen
17:59:04 <hodapp> and that we've made big steps to get there
17:59:19 <geekosaur> some of the pieces may get into 8.0.1, but may not be useful at that point (as with exception stack traces, where some of the pieces are in 7.10.x but not usable yet)
17:59:33 <Cale> From what I understand, it isn't really well-understood how to combine lazy evaluation (or non-strict semantics) with the sort of evaluation which must take place at the type level, and requires reducing expressions that have free variables in them.
17:59:57 <exio4> Cale: doing it like Idris may be `cool` for the type-level though 
18:00:02 <dolio> I don't think the pieces that are implemented yet look anything like dependent types.
18:00:19 <dolio> Except possibly stuff in Richard's personal repository that no one really looks at.
18:00:32 <Cale> If you put together all the recent GHC extensions, you can sometimes approximate the style of dependently typed programming.
18:00:46 <Cale> Even if you're not really programming in a dependently typed language.
18:00:51 <hodapp> that is what https://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf refers to
18:01:03 <exio4> basically only allowing total functions to be reduced at the type-level
18:02:16 <Pamelloes> geekosaur: These are exciting functions‚Äîby which I mean I basically have no idea what's going on! Which is exciting! :D
18:02:16 <hodapp> dolio: that paper explains how existing pieces do indeed can like dependent types
18:02:25 <dolio> Not to me.
18:02:43 <hodapp> dolio: you've read it?
18:03:12 <MarcelineVQ> this fix thing is cool. every single day something new is introduced here, how can there be so many things in one language that all seem useful
18:04:19 <geekosaur> the best part is that they're not really "in the language". they can be written in the language; they don't need to be baked in.
18:04:53 <geekosaur> like, the single most mind-blowing thing to me about Cont is that in every other language it has to be provided as a primitive. in Haskell you can implement it using pieces that look nothing like call/cc
18:05:02 <Cale> uhhh
18:05:14 <Cale> You can implement Cont in most functional languages
18:05:24 <Cale> If not all of them
18:05:44 <MarcelineVQ> Cont
18:05:46 <MarcelineVQ> woops
18:05:50 <Cale> People just don't
18:06:13 <Cale> (to be fair, how often does anyone really use Cont/ContT)
18:06:54 <dolio> hodapp: I haven't read the paper in detail, but I'm plenty familiar with using indexed types and whatnot.
18:09:45 * hackagebot nested-routes 4.0.0 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-4.0.0 (athanclark)
18:11:47 <dolio> And beyond my not really considering them adequate replacements in general, in Haskell there are non-trivial differences to how actual dependent types would act, if they were implemented.
18:12:33 <dolio> For instance, the type level is expected to be total. So if you take a Haskell type, promote it, and index by that, you may actually end up with a different type.
18:13:06 <hodapp> can you give an example?
18:13:21 <dolio> data Nat = Zero | Succ Nat
18:13:30 <dolio> That has 'inf = Succ inf'
18:14:05 <dolio> data INat (n :: Nat) where Z :: INat Zero ; S :: INat n -> INat (Succ n)
18:14:09 <Pamelloes> Aw, fix \x -> x * 30 doesn't equal 0 :(
18:14:24 <dolio> `iinf = S iinf` is not well typed.
18:14:30 <btipling> what is init short for
18:14:44 <Pamelloes> btipling: initilaization?
18:14:49 <btipling> but that's weird
18:14:55 <btipling> I mean the list function
18:15:08 <btipling> init gives you all but the last element in a list
18:15:16 <btipling> I just don't understand why that's called "init"
18:15:22 <Pamelloes> initial
18:15:43 <Shockk> I thought initial too
18:15:47 <Pamelloes> head:tail; initial:last;
18:16:08 <btipling> I see
18:17:56 <hodapp> dolio: is the latter what the former would be promoted to?
18:18:40 <Shockk> I can't wrap my head around how I should implement polymaps using the [*] kind 
18:19:16 <dolio> It's the singleton type family indexed by the original type.
18:20:05 <dolio> Even if you existentially quantify around the Nat, you can't create an analogue of 'inf = Succ inf', because it will be bottom instead.
18:20:46 <dolio> And that's necessary because I don't think infinite Nats exist in the promoted type.
18:21:00 <dolio> Just like infinite types don't.
18:47:48 <kurokuriboh> hi there!
18:48:02 <byorgey> hi kurokuriboh!
18:48:03 <kurokuriboh> anyone here?
18:48:09 <kurokuriboh> Hi byorgey!
18:48:38 <kurokuriboh> I just started learning Haskell. I have some questions about it. Would you be able to help me?
18:49:39 * ackthet recommends #haskell-beginners but there are no rules against asking here i think
18:49:43 <Cale> kurokuriboh: Ask away!
18:49:58 <Cale> ackthet: #haskell is for beginners too!
18:49:58 <byorgey> kurokuriboh: sure, just ask your questions and someone will be able to help you, whether it's me or someone else
18:50:28 <Cale> If I could, I would rename #haskell-beginners because it gives the wrong idea
18:50:39 <ackthet> Cale: snr is better there, i find
18:50:49 <btipling> learn you a good haskell is kind of too wordy, anyone recommend like a more succinct book?
18:50:52 <kurokuriboh> So I have this type called Move: " type Move = (String, String) " and i want to use it in a function
18:51:05 <btipling> I good fall back to a good haskell if there was something I didn't understand
18:51:05 <YellowOnion> Whats peoples preferred method for serialising floats?
18:51:08 <Cale> btipling: Perhaps Graham Hutton's book?
18:51:22 <kurokuriboh> "foo :: String -> String -> Move
18:51:38 <btipling> ty Cale 
18:51:42 <Cale> kurokuriboh: sure
18:51:42 <btipling> that's kind of expensive though :P
18:52:28 <Pamelloes> kurokuriboh: Take a look at the uncurry function, it should do what you want :)
18:52:35 <Pamelloes> :t uncurry
18:52:36 <lambdabot> (a -> b -> c) -> (a, b) -> c
18:52:36 <kurokuriboh> when I try to return Move like " foo a b = Move (a,b) " and compile the program, it said not in scope
18:53:17 <Pamelloes> Oh, nevermind. You're asking something completely different. My nsf.
18:53:18 <Pamelloes> *bad
18:53:21 <kurokuriboh> yeah
18:53:39 <dmj`> btipling: I recommend all content written by byorgey, typeclassopedia or cis-194
18:53:46 <byorgey> kurokuriboh: type  Move = (String, String)  says that the type Move is just a synonym for the type (String, String)
18:53:46 <btipling> kk
18:53:48 <kurokuriboh> the problem is i dont know how to use the Move type inside the function
18:53:50 <btipling> thanks dmj` 
18:53:55 <kurokuriboh> okay
18:53:56 <byorgey> kurokuriboh: so  String -> String -> Move   is the same as   String -> String -> (String,String)
18:54:06 <dmj`> btipling: https://wiki.haskell.org/Typeclassopedia
18:54:24 <btipling> I have been using that, but not reading through it like a book, thanks!
18:54:26 <foobuzz> is there something like a generic Either of arbitrary arity? something using DataKinds like "HEither :: [*] -> *"? with some sort of tag or index based pattern matching?  
18:54:42 <kurokuriboh> so i do not have to return Move ? but i can return (String, String) instead?
18:55:07 <Pamelloes> kurokuriboh: Move isn't a type, it's a type synonym. Move literally means (String, String)
18:55:27 <kurokuriboh> okay
18:55:42 <Cale> kurokuriboh: You can have the function result in something like ("hello","world"), for example
18:56:07 <Cale> If you'd written  newtype Move = Move (String, String)
18:56:17 <Cale> then you'd have to use the Move data constructor
18:56:27 <Cale> Well, just for clarity, let's name them differently:
18:56:33 <Cale> If you'd written  newtype Move = MkMove (String, String)
18:56:52 <Cale> Then you'd write   foo x y = MkMove (x,y)
18:57:17 <Cale> and now Move is not the same type as (String,String) any more
18:57:36 <kurokuriboh> okay
18:57:42 <kurokuriboh> Thanks everyone!
19:15:15 <dmj`> jle`: bro
19:15:42 <Shockk> I have a weird question
19:16:07 <lpaste_> Shockk pasted ‚ÄúPolyMap.hs‚Äù at http://lpaste.net/141398
19:16:30 <Shockk> I want to write a Show instance for PolyMap but I don't have a clue how to
19:17:31 <mniip> well first you wanna map Show along the elements of [*], and collect them, just for the sake of the instance constraint
19:18:05 <Shockk> hmm, map Show along them?
19:19:45 <Shockk> I mean, I know what mapping is, although I don't know about the specifics of doing that with a typeclass over [*]
19:25:58 <Cale> Shockk: My solution would be just to pass around a list of String values instead :P
19:26:43 <Shockk> :(
19:27:51 <nolrai66> Why do they use Show as in example in this sort of thing?
19:29:11 <Shockk> I mean, I figured I might as well start somewhere by writing a Show instance to get a String representation of the polymap
19:32:26 <eatingthenight> can anyone explain this function type def to me? digs :: Integral x => x -> [x]
19:33:13 <eatingthenight> mostly difference between => and ->, Integral, and how you can use variables in it. I am use to seeing something :: Int -> Int -> Int
19:33:38 <Cale> The => separates class constraints, which constrain the types that type variables range over, from the rest of the type
19:34:05 <Cale> Integral x is such a class constraint, and says that whatever type x may be, it must be an instance of the type class Integral
19:34:20 <Cale> which is a class that has various numerical operations on integer-like types in it
19:34:44 <Cale> so, x may be something like Integer, Int, Word8, Int64, etc.
19:35:11 <Cale> x -> [x]  means that digs is a function which takes a value of type x, and produces a list of values of type x
19:36:25 <Cale> eatingthenight: is that clear?
19:37:36 <Cale> eatingthenight: So, for instance, you may use digs as a function of type  Integer -> [Integer], or Int -> [Int], or Word32 -> [Word32] and so on.
19:38:28 <eatingthenight> Cale: ok that makes it clear 
19:38:51 <eatingthenight> so for my case i just want it for ints so i could just do digs :: Int -> [Int]
19:39:16 <Cale> yeah, you can just apply digs to something which happens to be an Int and it will work and produce a list of Int values
19:39:30 <Cale> You don't even have to explicitly say which type you want, usually.
19:39:42 <Cale> (so long as something somewhere in your program determines it)
19:40:35 <Shockk> hm, mniip, I've got this right now as well as the simpler instance for PolyMap '[]
19:40:39 <Shockk> instance Show a => Show (PolyMap (a ': as)) where show (xs :<->: pm) = show xs ++ " :<->: " ++ show pm
19:40:47 <eatingthenight> I am curious why Integral -> [Integral] is not valid to use as the type then
19:41:32 <Cale> eatingthenight: Well, what exactly does that mean? The more natural way to interpret that, if it were valid syntax, would perhaps be  (Integral a, Integral b) => a -> [b]
19:41:33 <Shockk> when I try and build though, it can't deduce Show (PolyMap as), which I'd expect of course but I don't know how to help it to deduce that
19:42:01 <Cale> eatingthenight: (Integral a) => a -> [a] tells you that the type of the elements in the resulting list is the same as the type of the argument
19:42:22 <Shockk> like, I've got Show a as a constraint on a, but I don't know how to / if it's possible to put a constraint on all the types in that list kind 
19:42:26 <Cale> eatingthenight: and of course, all the elements of the list must have the same type
19:43:28 <eatingthenight> Cale: ok that makes sense, I'm going to read more about Integral but i think I have a good understanding for learning more about it now.
19:43:36 <eatingthenight> Thanks you!
19:43:58 <Cale> Yeah, I didn't mention exactly what the operations were
19:44:20 <Cale> But they mostly relate to integer division
19:44:26 <Cale> :t quot
19:44:29 <lambdabot> Integral a => a -> a -> a
19:44:31 <Cale> :t rem
19:44:32 <lambdabot> Integral a => a -> a -> a
19:44:35 <Cale> :t div
19:44:37 <Cale> :t mod
19:44:37 <lambdabot> Integral a => a -> a -> a
19:44:39 <lambdabot> Integral a => a -> a -> a
19:45:25 <Cale> (two different conventions for integer division -- quot/rem is usually what's implemented in hardware, div/mod is usually what programmers actually want)
19:48:34 <Cale> In addition to that, Num is a superclass of Integral, so you get the usual (+), (*), negate, fromInteger, and some other stuff
20:06:12 <tesrty> So I have a list that holds Integers. Each integer corrosponds to the nth element in another list. I'd like to filter this last list so that only the elements I know the position of remain.
20:07:30 <Shockk> whoo, I figured it out, it was simpler than I was thinking
20:07:31 <Gurkenglas> tesrty, should we optimize for performance or elegance or a mixture? (Is the list long?)
20:07:42 <rhovland> tesrty: I think that'll be much easier if that first list is sorted
20:07:55 <Shockk> I just changed my constraints on the instance from (Show a) to (Show a, Show (Polymap as))
20:08:24 <tesrty> Gurkenglas: performance is no point at all. the list of indices is maybe <10 long.
20:09:22 <tesrty> The list is not sorted, and should not be. Because the elements from the second list we want to filter need to be taken out not in order of their list, but in order of the list holding their indices.
20:09:31 <Gurkenglas> :t \indices values -> map (values!!) indices
20:09:33 <lambdabot> [Int] -> [b] -> [b]
20:09:45 <Gurkenglas> (How long is the list of values?)
20:09:51 <rhovland> tesrty: [values!!i|i<-indices]?
20:10:05 <tesrty> lower than the list we select from. So also <10
20:10:27 <Gurkenglas> tesrty, I mean the list we select from
20:12:30 <tesrty> Yea, so the scenario is [3, 2, 5] ["a","f","D","j"]. The first list can be any length, but always shorter than the second. The second will be <10
20:13:13 <tesrty> Correction second list should be ["a","f","D","j","B"]
20:13:32 <tesrty> the result im looking for should be ["D","f","B"]
20:13:40 <rkv> Can an undirected graph with 2 vertices and and an edge between them be Hamiltonian? All characterizations that I read require that there be at least 3 vertices.
20:13:52 <Gurkenglas> tesrty, what I or rhovland said, then, but you'll want to reduce the indices by one
20:13:55 <rhovland> [values!!(i-1)|i<-indices]
20:14:01 <Gurkenglas> > [1..] !! 3
20:14:02 <lambdabot>  4
20:14:21 <tesrty> Thanks, ill look up everything about the code you wrote I don't understand / kept me from writing it myself.
20:14:27 <tesrty> Wait. Haskell is zero indexed?
20:14:34 <rhovland> !! is zero indexed
20:14:38 <tesrty> Ah.
20:14:42 <tesrty> Thanks!
20:15:40 <Shockk> http://lpaste.net/3107735732911865856
20:15:59 <Shockk> this is kind of some of the weirdest Haskell code I've ever written
20:16:05 <Shockk> I guess that's just because it's completely new to me
20:25:41 <Axman6> Shockk: thats pretty cool, nice work
20:26:14 <Axman6> Shockk: does deriving Show work?
20:26:27 <Shockk> oh hmm
20:27:24 <Shockk> it might work for '[] (for EmptyPolyMap)
20:29:27 <Axman6> ikt seems like it should be possible for it derive Show for :<->: too
20:29:29 <Shockk> aha, it does work Axman6 
20:29:37 <Shockk> with the correct type constraints
20:29:51 * hackagebot hasql-postgres 0.10.6 - A "PostgreSQL" backend for the "hasql" library  https://hackage.haskell.org/package/hasql-postgres-0.10.6 (NikitaVolkov)
20:29:58 <tesrty> I understand lambda expressions now after reading about them and trying, but wasn't wholly sure how to apply it in my case. However the 'draw from' way of doing it is amazing! Managed to apply it. Thanks for teaching me something new to the both of you Gurkenglas and rhovland !!
20:29:59 <Gurkenglas> (Compare the Show/Eq etc. instances on https://hackage.haskell.org/package/free-4.12.1/docs/src/Control-Comonad-Cofree.html )
20:30:04 <Shockk> it wasn't working before, when I didn't know how to constrain properly, but it does with the right ones
20:33:14 <nitrix> What would be the safest way to generate unique filenames?
20:34:57 <Axman6> nitrix: perhaps something in https://hackage.haskell.org/package/temporary-1.2.0.3/docs/System-IO-Temp.html ?
20:37:02 <nitrix> Mhhh, they aren't temporary though plus the guarantees are minimal. The documentation only says a random number is added to the filename.
20:37:06 <nitrix> Maybe UUID?
20:38:09 <Welkin> I just prepend/append the posix time
20:38:11 <Axman6> sure, that should work well
20:38:14 <Welkin> it works quite well
20:38:25 <MarcelineVQ> you could name it its md5sum :>
20:38:37 <glguy> nitrix: The files you get back from System.IO.Temp are unique
20:39:39 <nitrix> Oh, openTempFile actually match what I want.
20:40:15 <nitrix> glguy: Appreciated.
20:53:13 <wavewave> hi
20:53:31 <wavewave> I've succeeded in making ghc a cross-compiler for android using nix.
20:53:57 <wavewave> see http://github.com/wavewave/nix-build-ghc-android
20:55:11 <gamegoblin> Is there any way I can make a newtype coerce to its wrapped type automatically? e.g. if I have "newtype Name = Name String" and I have a function "isStringLongerThan5 :: String -> Bool", is there a way I can make it so I can call "isStringLongerThan5 myNameObject" and have it coerce automatically? 
20:56:01 <Hijiri> I don't think so
20:56:04 <gamegoblin> I didn‚Äôt think there was, but wanted to check
20:56:12 <Hijiri> if isStringLongerThan5 is a class method, you could use GeneralizedNewtypeDeriving
20:56:33 <Hijiri> or at least I think that's the extension name
20:57:13 <gamegoblin> I‚Äôm familiar with that extension, but yeah, doesn‚Äôt really help me unless I want to do some class nonsense
21:17:20 <lpsmith> Hmm, has anybody looked into how GHC's Handles work on Unix Datagram Sockets?
21:18:13 <nitrix> Is it safe to close a Handle twice?
21:18:26 <nitrix> Also, is there such thing as withHandle ?
21:18:33 <lpsmith> nitrix, yes and yes
21:18:57 <nitrix> lpsmith: https://www.haskell.org/hoogle/?hoogle=withHandle  :(
21:20:02 <lpsmith> nitrix, since there are a multitude of ways of creating handles,  such as opening a file,  converting a socket to a handle,  etc...
21:20:16 <lpsmith> (and presumably,  several available in 3rd party libraries)
21:21:00 <lpsmith> either the library will provide such a withFile combinator,  or you can create your own using 'bracket' and friends in Control.Exception 
21:21:00 <nitrix> I'm using openBinaryTempFile.
21:21:45 <nitrix> Oh, I love that bracket thing.
21:23:00 <lpsmith> ahh,  well,  since openBinaryTempFile is creating a lasting side effect on the filesystem,  it's impossible to guarantee that the temp file will be deleted,  because your process itself could be killed at an inopportune moment.
21:23:24 <lpsmith> But yeah,  I assume you want to delete the file when you are done?
21:23:46 <lpsmith> bracket will work most of the time,  assuming your process isn't killed or (gasp) crash.
21:24:04 <lpsmith> (it does happen on occasion, even with Haskell ;-)
21:24:39 <nitrix> Surprisingly, no. I want to open a file, write to it, close it. In the even that any of those fails, it's best to leave it the way it is.
21:24:52 <nitrix> Considering this is a unit test for a file system.
21:25:19 <lpsmith> Ok,  yeah,  then bracket will work 100% for what you want
21:25:25 <lpsmith> well, should work 100%
21:25:56 <nitrix> The only thing I don't like is that now I need to combine bracket with tryIOError
21:26:22 <nitrix> I'm transforming the whole thing into a Maybe in the end.
21:27:41 <lpsmith> well,  tryIOError catches the exception,  bracket makes sure that a cleanup action happens.
21:28:47 <lpsmith> (Although,  my understanding is with recent enough linux kernels,  at least with some filesystems,  you can create an inode without linking it in the filesystem.   That way you can create large files atomically,  by linking it at the end,  and if your process dies before it's linked,  then it gets deleted.)
21:29:01 <lpsmith> I don't think there's standard libraries and interfaces for doing that though.
21:29:57 <geekosaur> ...or install openafs and use its kernel module to do it...
21:31:45 <geekosaur> (actually I don't think you get its iopen on linux)
21:34:01 <lpsmith> never looked into AFS much, but that does sound interesting
21:35:56 <geekosaur> actually I'm pretty sure iopen is not on linux; it would have to track too many ever-changing filesystem internals
21:36:25 <geekosaur> solaris and other commercial oses get the iopen stuff, and a speedup but needing a special fsck program to avoid all your volumes being moved to /lost+found :)
21:49:11 <stoopkid> hello
21:49:21 <stoopkid> does anybody have experience using coroutines in haskell?
21:49:50 <stoopkid> i'm curious how this would benchmark for speed relative to other languages
21:54:41 <exio4> stoopkid: "coroutines"? 
21:55:10 <stoopkid> https://hackage.haskell.org/package/monad-coroutine-0.9.0.1/docs/Control-Monad-Coroutine.html
22:02:42 <wavewave> stoopkid: I am using coroutine as basis of my program hoodle 
22:03:15 <stoopkid> wavewave: got a link?
22:03:24 <wavewave> GUI framework / business logic as server/client system.
22:03:32 <wavewave> http://www.github.com/wavewave/hoodle
22:03:45 <wavewave> or http://ianwookim.org/hoodle
22:03:54 <stoopkid> this one? http://ianwookim.org/hoodle/
22:04:11 <wavewave> stoopkid: yes. :-)
22:04:15 <stoopkid> :)
22:04:53 <stoopkid> do you know anything about the benchmarking of haskell's coroutines relative to coroutines in other languages? i've been working with a project that's using coroutines as the basis of the software, but it's in C++
22:04:54 <wavewave> coroutine is a very good abstraction. Not as fancy as FRP, but still better than callback spaghetti.
22:05:19 <stoopkid> frp?
22:05:30 <wavewave> stoopkid: well, I haven't measured it, but it should be fast enough
22:05:39 <wavewave> Functional Reactive Programming.
22:05:43 <stoopkid> ah yes
22:06:01 <wavewave> you can also look up pipes / conduit library.
22:06:05 <exio4> anyway, what do you want to do?
22:06:44 <exio4> when I see coroutines in other languages I see green threads normally :)
22:06:46 <wavewave> the pipe abstraction is more general than coroutin.
22:07:01 <wavewave> exio4: it's true.
22:07:02 <exio4> indeed it is
22:07:33 <wavewave> exio4: the reason why I am using coroutine is because GUI is often not thread-safe.
22:08:09 <wavewave> need to make a program in a server/client way, like X server.
22:08:11 <stoopkid> ah well, we have a C++ implementation of a reasoner software called Euler, and we're basically using the coroutines to turn the rules in the knowledge-base into lambda-closures, and combining the lambda-closure coroutines together in such a way that it executes backward-chaining reasoning over the rule-base
22:08:28 <stoopkid> and this is basically to make a JIT-compiled version of what we already have
22:08:34 <wavewave> stoopkid: You may be interested in free monad. 
22:09:50 <wavewave> stoopkid: anyway... I can tell that coroutine/pipes/conduit are very good for performance. 
22:10:15 <wavewave> warp is haskell web server which is very fast based on conduit library.
22:11:00 <wavewave> ah.. wait.
22:11:27 <ReinH> wavewave: warp isn't based on conduit, is it?
22:12:05 <wavewave> before version 3, it was.
22:12:37 <wavewave> now it depends on streaming-commons.
22:12:38 <ReinH> ah
22:13:17 <wavewave> it's a kind of interface against pipes-, conduit-like library. 
22:13:34 <wavewave> I need to check it. For some time, I haven't followed the progress.
22:14:11 <ReinH> I know streaming-commons
22:14:19 <bitemyapp> ReinH: biblically?
22:14:29 <ReinH> bitemyapp: I mean
22:14:56 <wavewave> maybe I do not understand streaming-commons well. anyway.. warp-2.0 was also very performant.
22:30:15 <Cooler> can someone give some code on how to implement fmap?
22:30:34 <Cooler> i am trying to instance Functor for a custom data type
22:42:26 <liste> Cooler the implementation depends on the type
22:42:31 <liste> @src Functor Maybe
22:42:31 <lambdabot> Source not found. Wrong!  You cheating scum!
22:44:41 <liste> Cooler: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-629 <-- check this out
22:48:36 <maaku> Cooler: http://learnyouahaskell.com/functors-applicative-functors-and-monoids
22:55:57 <mitochon> hi, trying to do => 1/ (length [1,2]) on ghci but getting error "No instance for (Fractional Int) arising from a use of ‚Äò/‚Äô"
22:56:25 <tekkkz> Hi! Can someone help me with CIS 194 Homework "towers of hannoi" of week 1 ? I have no idea how to start, so maybe just some steps spoiler?
22:57:41 <glguy> tekkkz: The exercise tells you exactly the 3 steps
22:57:51 <glguy> on page 5
22:58:39 <liste> mitochon `length' returns an Int, so you need to convert it to a fractional type
22:58:53 <liste> e.g. with fromIntegral
22:58:59 <tekkkz> glguy, there are sjut 4 pages?
22:59:11 <glguy> https://www.seas.upenn.edu/~cis194/hw/01-intro.pdf
23:00:14 <glguy> There are 5 pages. The rest of exercise 6 and exercise 7 are on page 5
23:00:19 <tekkkz> ahh, i had used this: http://www.seas.upenn.edu/~cis194/spring13/hw/01-intro.pdf where did you found yours?
23:00:52 <glguy> Google
23:01:20 <glguy> tekacs: On yours the 3 steps are on page 3
23:01:37 <tekkkz> yap ^^ now i realize them :D
23:01:39 <tekkkz> sorry
23:01:53 <glguy> Oh, no problem
23:02:13 <liste> mitochon or you could use genericLength
23:03:44 <tekkkz> wow
23:03:46 <tekkkz> i solved it
23:03:50 <tekkkz> it was absolutely easy
23:03:51 <tekkkz> :D
23:04:27 <glguy> Good to hear :)
23:04:54 <tekkkz> hehe
23:25:53 <Fonzy> Hi there sorry for newbie questions
23:26:45 <Fonzy> Hi rekasoft
23:27:19 <glguy> Fonzy: Feel free to ask your question.
23:27:25 <Cale> Fonzy: Newbie questions are always welcome here
23:27:32 <Cale> Feel free to ask lots!
23:28:26 <Fonzy> Thanx i want Experiment Witz my raspberry pi which means a lot of io stuff
23:29:41 <Fonzy>  For this beginning I wanted to do this:
23:30:01 <Fonzy> main = do
23:30:34 <Fonzy>    putStrLn "hello"
23:30:58 <Fonzy>    delay 1000
23:30:59 <srenatus> hello
23:31:10 <cocreature> hey srenatus 
23:31:11 <glguy> Fonzy: If you have code to share you can paste it on http://lpaste.net
23:31:20 <Fonzy> putStrLn "world"
23:31:52 <Cale> Fonzy: You're probably looking for threadDelay from Control.Concurrent https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Control-Concurrent.html#v:threadDelay
23:32:05 <Fonzy> But the compiled program does not wait between the two outputs. What am I missing?
23:32:17 <Cale> Where did you get delay from?
23:32:40 <Fonzy> I am using Thread.Delay but it does not seem to work 
23:33:10 <cocreature> which package is that from?
23:33:11 <Fonzy> cabal install concurrent-extra
23:33:12 <Cale> https://hackage.haskell.org/package/concurrent-extra-0.5/docs/Control-Concurrent-Thread-Delay.html
23:33:15 <Cale> I see
23:33:21 <Cale> Well, the argument is in microseconds
23:33:21 <glguy> Fonzy: What units of time does your delay function take?
23:33:26 <Cale> 1000 microseconds is not a long time
23:33:33 <Cale> Maybe try 10^6
23:34:14 <Fonzy> OK, layer8 problem, I c , I mixed microseconds with milliseconds
23:36:25 <Fonzy> Thanx a lot, that was the problem...:)
23:42:19 <Cooler> http://pastebin.com/C0eyk0ed
23:42:44 <Cooler> i am getting an error when trying to implement fmap
23:43:19 <Cale> Cooler: Test isn't even the right kind in order to be an instance of Functor
23:43:32 <Cale> Cooler: It needs a type parameter first of all
23:43:38 <Cale> :k Functor
23:43:39 <lambdabot> (* -> *) -> Constraint
23:43:42 <Cale> :k Maybe
23:43:43 <lambdabot> * -> *
23:43:46 <Cale> :k Integer
23:43:47 <lambdabot> *
23:43:51 <Cale> :k Maybe Integer
23:43:52 <lambdabot> *
23:43:55 <Cale> :k IO
23:43:56 <lambdabot> * -> *
23:44:26 <Cooler> wait why?
23:44:41 <Cale> Because that's part of what a functor is
23:45:22 <Cale> A functor is like a function f from types to types, together with a mapping (that we call fmap) which given a function (a -> b) will turn it into a function (f a -> f b)
23:46:34 <Cale> Moreover, to be a valid functor, it's required (though the Haskell compiler won't enforce this), that fmap id = id, and that fmap (f . g) = fmap f . fmap g, whenever f and g are functions for which that typechecks.
23:47:12 <Cale> (however, it is a result about Haskell's type system that it's enough to check that fmap id = id, i.e. that for all x, you have fmap id x = x)
23:47:44 <shachaf> ...Assuming f is a functor.
23:48:30 <Cale> shachaf: Ah, assuming there is some instance at all, you mean?
23:48:42 <Cale> Yeah, that makes sense
23:48:50 <shachaf> At least, every proof I've ever seen has used the free theorem that assumed there existed some $map_F
23:49:38 <shachaf> So if you don't know whether F is a functor, being able to write some foo :: (a -> b) -> F a -> F b such that foo id = id might not be enough, if there's no instance at all.
23:49:58 <Cale> It would be really interesting to come up with something that's not a functor and a definition of fmap such that fmap id = id, but find some f and g so that fmap (f . g) is not equal to fmap f . fmap g
23:49:59 <shachaf> But I can't think of any counterexample and I kind of doubt one exists in GHC.
23:50:48 <Cale> It's generally pretty challenging to define interesting functions of fmap's type at all if the thing isn't a functor to begin with.
23:51:13 <shachaf> Yes.
23:52:32 <shachaf> I can think of some examples, but none where foo id = id
23:52:51 <Cale> Cooler: anyway, even if that conversation might not make sense, the idea of most of the functors we care about in Haskell is roughly that they capture two fuzzy classes of types (which overlap a bit):
23:53:33 <Cale> 1) Type constructors which are like types of containers i.e. values of type T a are thought of as containers holding zero or more values of type a
23:53:59 <Cale> 2) Type constructors which are like types of computations i.e. values of type T a are thought of as programs having results of type a when run
23:54:43 <Cale> If you have a container full of values of type a, and you have a function of type (a -> b), then it might to be possible to apply the function to all the elements of the container, obtaining a container full of values of type b
23:54:52 <Cale> i.e. fmap :: (a -> b) -> T a -> T b
23:55:49 <Cale> similarly, if you have a program whose results have type a, and you have a function of type (a -> b), then it might be possible to construct a program whose results have type b, which will first run the given program, and apply the function to its result
23:56:02 <Cale> i.e. again  fmap :: (a -> b) -> T a -> T b
23:56:11 <Cale> the difference being how you think about "T a"
23:56:16 <shachaf> I would say something like that if F is a (covariant) functor, a value :: F a "produces" values :: a.
23:56:46 <shachaf> (And for a contravariant functor, it "consumes" them.)
23:57:02 <Cale> Yeah, for some sufficiently vague notion of "produce" and "consume"
23:57:17 <shachaf> Yes, well, all these notions are pretty vague.
23:57:29 <Cale> right
23:57:31 <shachaf> If you want a non-vague notion, you can just say "covariant".
23:58:04 <Cale> Cooler was originally talking about the Functor type class, so I didn't think to introduce contravariant functors, but yes, they're a thing as well:
23:58:11 <Cale> class Cofunctor f where
23:58:21 <Cale>   cofmap :: (a -> b) -> f b -> f a
23:58:25 <shachaf> Well, I didn't mean to introduce them in the context of the original question.
23:58:32 <Cooler> what
23:58:41 <Cale> :)
23:58:43 <Cooler> what's the type of f in class Functor f where
23:58:43 <shachaf> Just that they make the "produce" vocabulary make more sense.
23:58:54 <shachaf> I might not be very helpful here.
23:58:57 <Cale> Cooler: f is a type variable of kind * -> *
23:59:11 <Cale> where * is the kind of all ordinary types which have values in them
23:59:29 <Cale> like Integer, String, Maybe Double, etc. all have kind *
23:59:43 <Cale> * -> * is the kind of type constructors which take a type as an argument
23:59:53 <Cooler> why does it need that f?
