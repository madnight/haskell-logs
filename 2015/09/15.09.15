00:01:59 <roelof> oke, so this function takes first a then b and then c  and compare it to the 3 * x > a + b + c part 
00:07:38 * hackagebot quiver 1.0.1 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-1.0.1 (patrykz)
00:07:38 * hackagebot gll 0.3.0.1 - GLL parser with simple combinator interface  https://hackage.haskell.org/package/gll-0.3.0.1 (ltvanbinsbergen)
00:08:08 <roelof> arkeet so x is first the value of a , then b and then c ?? 
00:08:23 <LazyJay> yes, and f returns 0 or 1 
00:10:01 <roelof> oke, then I think I understand how things are working. I can use this one for the function and my old idea for testing with quickCheck 
00:14:50 <georgy-> is it possible to change date in haskell program only for testing purposes, without affecting system date?
00:16:02 <frerich> georgy-: No, but a good approach would be to not query the system date in the middle of your code but rather on the 'outermost' layer (e.g. in 'main') and then pass a plain, pure, date value around. You could then test your code by simply passing a different date.
00:20:11 <georgy-> frerich true enough.. but that allows me just to individual pure functions, and not the program as a whole
00:20:20 <georgy-> to just test*
00:22:45 <RayNbow> hmm, which package'd be the easiest to use for reading (and only reading) JPG files? I tried JuicyPixels, but cabal install fails (Haskell Platform 7.10.2-a Win64)
00:23:05 <roelof> any feedback about this code : http://lpaste.net/141019
00:23:51 <delYsid> OK, I read about semantic editor combinators and am rather fascinated.  This stuff is over my head, especially the Arrow thingy.  But composing a unary function with a binary function has me fascinated.  Can someone help me to understand what is actually going on in this expr: ((.).(.)) not
00:24:15 <delYsid> I get (.) not, but why do two composed dot operators produce something that takes two args and return one?
00:25:22 <delYsid> :t ((.).(.))
00:25:23 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
00:26:07 <liste> delYsid maybe begin with (foo .) . bar
00:26:26 <liste> :t (negate .) . (+)
00:26:28 <lambdabot> Num c => c -> c -> c
00:27:29 <delYsid> liste: Thats "simple" since (+) is a binary function...
00:27:32 <Qndel> hey
00:27:33 <RayNbow> hmm, never mind... apparently cabal install JuicyPixels for a 2nd time worked fine...
00:27:45 <delYsid> so it sort of follows that the resulting function will have two args since (+) is the last in the composition chain...
00:28:36 <delYsid> ahh
00:28:41 <frerich> delYsid: The reason is that a type variable in a signature can expand to a function type, too! It may be easier to consider a simpler case, a common example being:
00:28:43 <frerich> :t id
00:28:44 <lambdabot> a -> a
00:28:44 <delYsid> that applies to . as well I guess :-)
00:28:45 <frerich> :t flip id
00:28:46 <lambdabot> b -> (b -> c) -> c
00:28:57 <bitemyapp> @pl zed' a b c = return (a, b, c)
00:28:58 <lambdabot> zed' = ((return .) .) . (,,)
00:29:03 <bitemyapp> well, no.
00:32:09 <merijn> delYsid: The usual example is that the 'b' in "map :: (a -> b) -> [a] -> [b]" can easily be a function 'c -> d', as shown by
00:32:15 <merijn> :t map (+) [1..10]
00:32:17 <lambdabot> (Enum a, Num a) => [a -> a]
00:32:40 <merijn> hmm, I should start using elem as function since it has three different arguments...
00:32:45 <merijn> :t map elem [1..10]
00:32:46 <lambdabot> (Enum a, Eq a, Num a, Foldable t) => [t a -> Bool]
00:32:59 <merijn> or not...that's not more readable :p
00:34:27 <Qndel> what does @ do?
00:35:25 <Hijiri> in a pattern match?
00:35:53 <delYsid> merijn: Oh my, thats even weirder :-)
00:36:16 <delYsid> or not, the haskell smiley ((.).(.)) is just a crazy thing as well
00:36:18 <Qndel> http://lpaste.net/141022
00:36:34 <Qndel> I have @ here
00:36:35 <delYsid> I wish I had an intuition for this.  I guess it all relates to currying.
00:38:37 <Hijiri> Qndel:    thing@pat is a pattern that matches the "pat" pattern, but additionally binds the whole thing to thing. For example, the pattern match    maybething@(Just innerValue)  would match a "Just" constructor, binding the inner value to "innerValue" and the whole thing (Just innerValue) to maybething
00:38:47 <Axman6> ((.).(.)) = (\x -> (.) ((.) x)) = (\x -> (.) (. x)) = (\x f -> (.) f (. x))
00:39:07 <Hijiri> > case Just 'a' of wholeThing@(Just character) -> (wholeThing, character)
00:39:08 <lambdabot>  (Just 'a','a')
00:39:46 <merijn> delYsid: Is it really weird? Remember that "a -> b -> c" parses as "a -> (b -> c)" (arrow is right associative)
00:39:46 <Hijiri> this is useful if you want to get a name for the whole thing at the same time as matching the inside
00:40:18 <Hijiri> Qndel: in your paste, coord@(x,y) will match a pair, binding the first value to x and the second value to y
00:40:20 <merijn> delYsid: So it's a function that takes an 'a' and returns a function 'b -> c', so obviously mapping it over a list of a's will return a list of 'b -> c' functions :)
00:40:23 <Hijiri> then the whole pair is bound to coord
00:41:53 <Hijiri> Qndel: did that make sense
00:42:00 <frerich> delYsid: You can just puzzle with the type signatures. For instance, consider 'const :: a -> b -> a' and '(==) :: a -> a -> Bool'.
00:42:07 <delYsid> merijn: Yah, I think I sort of get the map example now...
00:42:11 <delYsid> :t map (+) [1..10] <*> [1..3]
00:42:12 <lambdabot> (Enum b, Num b) => [b]
00:42:37 <frerich> delYsid: If you now think about 'const (==)' you just replace the 'a' in the 'const' type with 'a -> a -> Bool' so you get 'const (==) :: Eq a => b -> (a -> a -> Bool)'
00:43:07 <frerich> delYsid: ...and since -> in type signatures is right associative, you can drop the parentheses (parenthesis?)
00:45:44 <Qndel> ok thanks
00:45:56 <merijn> frerich: parenthesis is singular, so parentheses :)
00:45:58 <delYsid> frerich: So now I have a version of == with three arguments, while the first argument is ignored?
00:46:02 <Qndel>  if length $ filter(==pPos2) ePos2 > 0 then
00:46:26 <Qndel> why doesn't it work? pPos2 is a tuple of floats, ePos2 is a list of these tuples
00:46:33 <frerich> Qndel: Another way to write that is (pPos2 `elem` ePos2)
00:46:57 <frerich> merijn: I wish I could memorize that :-(
00:47:21 <frerich> Maybe I'll remember that most people write just one thesis, not multiple theses.
00:47:41 <delYsid> frerich: :-)
00:49:14 <Hijiri> Qndel: that parses as if length $ ((filter (==pPos2) ePos2) > 0) because $ has lower precedence than >
00:49:27 <Hijiri> then what's happening is you are trying to see if a list is greater than 0
00:49:32 <Hijiri> which is a type error
00:51:29 <Hijiri> one way to fix it would be to use explicit parentheses instead of $, like length (filter (== pPos2) ePos2) > 0
00:52:13 <delYsid> So, I get map (+) [1..10] and const (==), but am still in awe about ((.).(.))
00:52:31 <Qndel> could somebody tell me how to use writeIORef?
00:52:54 <Cale> delYsid: It might be easier to understand  fmap . fmap
00:53:13 <Hijiri> Qndel: writeIORef ioref value  puts value into ioref
00:53:18 <Cale> delYsid: and then understand why (.) is a specialisation of fmap :)
00:53:22 <delYsid> Cale: Thats from the semantic editor combinators thingy as well, so why not :-)
00:54:08 <delYsid> Cale: oh, that reminds my of what I've read in typeclassopedia yesterday, something about ((->) e) being an instance of Functor I think?
00:54:13 <Cale> yes
00:54:25 <Qndel> yeah I know
00:54:31 <Qndel> but i've been using it like this
00:54:42 <Qndel> points <- writeIORef 10
00:54:48 <Qndel> instead of writeIORef points 10
00:54:48 <Cale> So, if you take fmap :: (Functor f) => (a -> b) -> f a -> f b, and you plug in  f t = e -> t
00:54:52 <Qndel> anyway
00:54:56 <Qndel> my game is almost done!
00:54:57 <Cale> You get  fmap :: (a -> b) -> (e -> a) -> (e -> b)
00:55:03 <Cale> which is exactly the type of (.)
00:55:06 <Qndel> now i only have to make the labirynth a bit more dense
00:57:59 <Cale> and if f and g are both functors, we can have  fmap :: (a -> b) -> (g a -> g b), as well as fmap :: (g a -> g b) -> (f (g a) -> f (g b))
00:58:21 <Cale> So  fmap . fmap :: (a -> b) -> (f (g a) -> f (g b))
00:58:32 <Cale> :t fmap . fmap
00:58:33 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
00:59:06 <Cale> now, if we plug in some instances for functions, we get
00:59:25 <Cale> fmap . fmap :: (a -> b) -> (e -> e' -> a) -> (e -> e' -> b)
00:59:47 <Cale> which is the type of (.) . (.)
00:59:52 <Cale> :t (.) . (.)
00:59:53 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:07:43 <tr_istan> Question on parsec, how to switch from String to Text (sample code with string here works http://lpaste.net/141024) Thank you
01:16:01 <delYsid> Cale: Thanks!  I am still not quit there yet, but this explanation helped me along.
01:22:03 <merijn> tr_istan: Important Text.Parsec.Text and use the "Parser" type defined there
01:27:18 <tr_istan> merijn: i tried that http://lpaste.net/141025
01:28:28 <quicksilver> strange there isn't a 'fromRight' in Data.Either
01:30:52 <tr_istan> quicksilver: you need either :: (a -> c) -> (b -> c) -> Either a b -> c
01:31:53 <quicksilver> no, I don't.
01:32:06 <quicksilver> I need fromRight :: (Either a b) -> b
01:32:15 <quicksilver> but it's OK, it's not hard to write :)
01:32:27 <merijn> quicksilver: Someone proposed adding it on the list, but there was a lot of opposition to adding it
01:32:36 * hackagebot freenect 1.2.1 - Interface to the Kinect device.  https://hackage.haskell.org/package/freenect-1.2.1 (ChrisDone)
01:32:37 <quicksilver> :t either fail id
01:32:37 <merijn> On account of it encouraging bad things
01:32:38 <lambdabot> Monad m => Either String (m a) -> m a
01:32:56 <quicksilver> :t either (const (fail "fromRight")) id
01:32:57 <lambdabot> Monad m => Either b (m a) -> m a
01:33:03 <quicksilver> bah
01:33:10 <shachaf> You might be thinking of error.
01:33:10 <quicksilver> :t either error id
01:33:11 <lambdabot> Either [Char] c -> c
01:33:16 <quicksilver> I was perhaps
01:33:24 <quicksilver> :t either (const (error "fromRight")) id
01:33:25 <lambdabot> Either b c -> c
01:33:34 <shachaf> :t (^?! _Right)
01:33:35 <quicksilver> merijn: we have fromJust tho, don't we?
01:33:35 <lambdabot> Either c a -> a
01:33:41 <shachaf> :t (^? _Right)
01:33:42 <lambdabot> Either c a -> Maybe a
01:33:52 <merijn> quicksilver: Which many people also consider bad and would like to see gone :)
01:33:57 * quicksilver nods
01:34:06 <merijn> Backwards compatibility is stopping that from happening, but still
01:34:12 <quicksilver> it's most for interactive use I guess
01:34:20 <shachaf> You can often write e.g. let Right x = y in ...
01:34:35 <quicksilver> having just evaluated a complex expression and demonstrated it is actually of the form 'Right x'
01:34:45 <quicksilver> I then want to apply something (an IO action, as it happens) to the value in the x
01:34:49 <quicksilver> at the ghci prompt
01:35:01 <quicksilver> I just added (\(Right x) -> x) to the pipeline
01:35:16 <quicksilver> in an actual program I wouldn't do it that way
01:35:25 <quicksilver> but in an actual program I'd have a way to handle the Left case
01:35:35 <quicksilver> for interactive exploration it's just a pain
01:36:26 <quicksilver> the lens way is the best way. lens'ifying my code is on the list
01:36:44 <quicksilver> shachaf: which lens package do I want to install?
01:36:54 <shachaf> lens
01:37:36 <quicksilver> hmm that's a hard name to remember
01:37:39 <quicksilver> :P:
01:37:45 <merijn> tr_istan: Oh, you made a mistake :)
01:37:58 <shachaf> quicksilver: If it helps, that package isn't really about lenses.
01:38:01 <merijn> tr_istan: You changed all the types of your parsers to "Parser Text"
01:38:27 <quicksilver> shachaf: it isn't?
01:38:29 <merijn> tr_istan: But running 'many (oneOf " \t")' on Text still produces a String
01:38:38 <quicksilver> shachaf: what is it about?
01:38:42 <quicksilver> :t (^?)
01:38:43 <lambdabot> s -> Getting (First a) s a -> Maybe a
01:38:49 <merijn> tr_istan: Because "oneOf :: [Char] -> Parser Char" and "many :: Parser a -> Parser [a]"
01:39:04 <shachaf> Optics, I guess. Lenses happen to be one type of optic, but you can get them from any lens package.
01:39:12 <merijn> tr_istan: So you end up with "many (oneOf " \t") :: Parser [Char]" i.e., Parser String
01:39:15 <shachaf> (Though for some reason almost no one else supports type-changing lenses.)
01:39:37 <shachaf> But lens gives you e.g. traversals (lenses onto zero or more things), isomorphisms, all sorts of things.
01:40:09 <tr_istan> merijn: so i can not use oneOf and many to work on text?  it should be something else?
01:40:27 <merijn> tr_istan: It works on Text
01:40:31 <shachaf> Colenses (called prisms), read-only optics, equality witnesses...
01:40:55 <merijn> tr_istan: The Text in "Parser Text" is the type of the parsed *result*, not of the *input*
01:41:11 <shachaf> And all of them are composable such that if you compose two things you get a type which is the lub of the types you composed.
01:41:22 <merijn> tr_istan: Text.Parsec.Text defines "type Parser = Parsec Text ()"
01:42:05 <tr_istan> merijn: thank you, i'll try to look at it a bit more
01:42:10 <merijn> tr_istan: the type Parsec is "Parsec <input> <state> <result>"
01:42:28 <merijn> tr_istan: So "Parsec Text () a" is a parser that parses Text and returns a
01:42:44 <shachaf> If I used the word "maximum" in a lattice rather than a total order, to mean the same thing as "lub"/"join"/"sup", would people understand what I meant?
01:42:52 <merijn> So in your code "Parser Text" expands to "Parsec Text () Text" a parser that takes a text as input and parses a text
01:43:34 <merijn> tr_istan: However, your use of combinators (many/oneOf) means your parser is actually "Parsec Text () String" it parses Text and produces a String, which after importing Text.Parsec.Text is equial to "Parser String"
01:44:19 <merijn> This is what is causing it to complain
01:44:50 <merijn> The solutions are 1) change the type to "Parser String" or 2) "fmap Data.Text.pack :: Parser String -> Parser Text" :)
01:46:14 <merijn> shachaf: I would parse the maximum of a lattice as "top"
01:46:32 <shachaf> The maximum of two elements.
01:46:32 <merijn> shachaf: Unless you make clear in context that it's a binary operation/relation
01:46:38 <shachaf> Or of a set, I guess.
01:46:47 <merijn> shachaf: Should be fine
01:46:53 <tr_istan> thank you, so the general idea is that it's easier to work with String in parsec because when you need many/oneOf you inevitably get String in the mix?
01:47:28 <merijn> tr_istan: Yes, Parsec isn't very good at efficiently grabbing chunks of ByteString/Text from a Text input
01:48:08 <merijn> tr_istan: Whether that matters depends on what you're doing
01:48:44 <georgy-> what is utctDay's equivalent of ZonedTime?    ZonedTime -> Day
01:49:03 <tr_istan> merijin: thank you, i was trying to decide between String and Text since i am using Hasql.Postgres and it likes Text but it seems Parsec likes String, i guess i'll use String since it's easier to cast it for hasql
01:49:07 <merijn> tr_istan: Attoparsec was designed to be faster than parsec/better for doing low-level (as in protocols, etc.) parsing so it has more efficient combinators, like "takeWhile :: (Char -> Bool) -> Parser Text" which copies dense blobs of Text
01:49:52 <tr_istan> i am basically parsing urls so no need for Attoparsec
01:50:07 <merijn> tr_istan: Downside of attoparsec is that it's parse errors are less human friendly. But if this is somewhere deep in an application (instead of, say, parsing human source code as input and reporting errors) attoparsec should be fine
01:50:52 <merijn> @hackage network-uri -- tr_istan 
01:50:52 <lambdabot> http://hackage.haskell.org/package/network-uri -- tr_istan
01:51:48 <tr_istan> i know about that, it's not that case, i am parsing parameter values (not the complete uri)
01:53:55 <merijn> tr_istan: Anyway, you might still wanna look at attoparsec, it's support for producing Text results is a bit better :) And it's almost a drop-in replacement for parsec, so should be easy to switch
01:53:58 <merijn> Hell, if you use
01:54:00 <merijn> @hackage parsers
01:54:00 <lambdabot> http://hackage.haskell.org/package/parsers
01:54:11 <merijn> You can write parsing library agnostic parsers :p
01:55:17 <tr_istan> probably in a year or so when i get more exp. :)
01:57:38 * hackagebot bcrypt 0.0.7 - Haskell bindings to the bcrypt password hash  https://hackage.haskell.org/package/bcrypt-0.0.7 (AndrewMiller)
01:57:40 * hackagebot moesocks 1.0.0.10 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-1.0.0.10 (JinjingWang)
02:14:38 <merijn> hmmm, I have an annoying problem. I have a couple of key value mappings where I want to enforce uniqueness of keys. So I simply defined a UniqMap that ensures this, but not I find myself having a recursive "Pat a" datatype, where I want to enforce the uniqueness of a's, but can't turn it into a UniqMap, since the structure of Pat is important...does anyone have any suggestions?
02:16:19 <merijn> I can simply traverse it and check every key is unique, but I'd like to prevent me from wrongly modifying the structure in the first place
02:22:39 * hackagebot hslogger-reader 1.0.0 - Parsing hslogger-produced logs.  https://hackage.haskell.org/package/hslogger-reader-1.0.0 (alex_bates)
02:30:40 <quicksilver> make the type abstract and implement it as a pair of UniqMap and Pat?
02:31:54 * quicksilver doesn't actually know what a UniqMap is so he is probably talking out of turn. Found a lpaste...
02:32:17 <merijn> quicksilver: newtype around Map that fails if a key is present :p
02:33:05 <merijn> I thought about this, but that makes dealing with patterns really annoying since I want/need to pattern match on their structure a lot
02:33:12 <quicksilver> why can't you just impose that similar restriction on all combinators which build new Pats?
02:33:48 <quicksilver> you can abstract your pattern matching code with Prisms and stuff but that might be a pain.
02:34:00 <merijn> quicksilver: It works for UniqMap since I hide the constructor, but that would be way annoying for Pats.
02:34:43 <merijn> quicksilver: Actually, I just realised I could define "read-only" patterns using PatternSynonyms
02:34:44 <slack1256> or ViewPatterns
02:34:56 <merijn> ViewPatterns doesn't really help here
02:35:22 <slack1256> I wanted to say PatternSynonyms, but I got confused :-)
02:35:54 <quicksilver> you can also define prisms for all your constructors 
02:35:57 <quicksilver> but I've never done it
02:36:04 <quicksilver> dunno if it's a painful way to program
02:36:09 <quicksilver> sounds like a shachaf question
02:36:11 <merijn> Oh, wait, no then it'd still be obnoxious to construct the patterns...
02:36:22 <merijn> blah
02:36:53 <merijn> I need to check after construction and then somehow ensure I don't break them after that
02:37:43 <merijn> hmm, I think this is just not possible and I should just take the "don't screw it up" approach :p
02:37:47 <slack1256> template haskell? Maybe it doesn't help with Patterns
02:47:29 <Lynn> <merijn> :t map elem [1..10]  <lambdabot> (Enum a, Eq a, Num a, Foldable t) => [t a -> Bool]  <merijn> or not...that's not more readable :p
02:48:10 <Lynn> ^ Y'know, I can't actually think of a function a -> b -> c that has clear, simple types in place of a, b, and c, that are all different
02:48:23 <merijn> elem was, before it was generalised :)
02:48:40 <Lynn> Haha, yes
02:49:23 <merijn> :t map findWithDefault
02:49:24 <lambdabot>     Not in scope: ‘findWithDefault’
02:49:24 <lambdabot>     Perhaps you meant one of these:
02:49:24 <lambdabot>       ‘IM.findWithDefault’ (imported from Data.IntMap),
02:49:29 <merijn> :t map M.findWithDefault
02:49:30 <lambdabot> Ord k => [a] -> [k -> M.Map k a -> a]
02:49:45 <merijn> mwah, still a bit messy
02:50:12 <Lynn> :t (!!)
02:50:13 <lambdabot> [a] -> Int -> a
02:50:18 <merijn> oh, good one
02:50:21 <Lynn> That would do the trick
02:50:34 <Lynn> :t replicate
02:50:36 <lambdabot> Int -> a -> [a]
02:50:58 <Lynn> And that one's even all nice and total... ish? I actually forget.
02:51:02 <Lynn> > replicate (-1) 'a'
02:51:04 <lambdabot>  ""
02:52:40 * hackagebot language-vhdl 0.1.1.0 - VHDL AST and pretty printer in Haskell  https://hackage.haskell.org/package/language-vhdl-0.1.1.0 (mararon)
02:54:05 <georgy-> what is utctDay's equivalent of ZonedTime?    ZonedTime -> Day
02:54:08 <quicksilver> Lynn: "either"? depends what you mean by clear and simple
02:54:12 <georgy-> @hoogle ZonedTime -> Day
02:54:14 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
02:54:14 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
02:54:14 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
02:54:22 <quicksilver> Lynn: (.) springs to mind as well
02:56:12 <Lynn> Well, having arrows in there can be a little confusing :<
02:56:47 <Lynn> That is, if the signatures for a, b, and c are all "arrow-free", you can very easily tell which type went where at a glance in an example
02:59:43 <Lynn> I mean you could really say the same thing about [] though... But I think (!!) is as good as it gets within Prelude
03:02:29 <mrkgnao> so I wrote a little program today morning. it's full of what I think are a bunch of places where you're supposed to use monadic techniques, but I haven't studied monads yet.
03:02:47 <mrkgnao> anyone up to critique my code or offer improvements?
03:03:04 <mrkgnao> http://lpaste.net/141028
03:05:52 <Intolerable> i had a look at it when you posted it on reddit
03:06:19 <Intolerable> "parseList" can just be defined as "mapMaybe parse"
03:06:23 <Intolerable> :t mapMaybe
03:06:25 <lambdabot> (a -> Maybe b) -> [a] -> [b]
03:06:39 <georgy-> module Main where is not needed. it is implicit if you don't specify module name
03:06:46 <Intolerable> something that might be helpful would be to separate it into two modules 
03:07:09 <Intolerable> one for the stack implementation, then only export the type (not the constructor) and the push / pop etc
03:07:27 <Intolerable> in the other, you'd have the RPN calc implementation
03:07:57 <mrkgnao> ah, thank you.
03:08:08 <mrkgnao> what about the explicit Vector access?
03:08:28 <mrkgnao> I'm having a hard time understanding how to play with the Maybes pop is returning.
03:08:52 <Intolerable> case pop stack of... ?
03:09:16 <mrkgnao> oh.
03:09:21 <mrkgnao> yes, that could work.
03:09:28 <mrkgnao> any reinventing the wheel spotted?
03:09:59 <mrkgnao> I think some kind of liftM thing is supposed to be done in the "liftedOp" bits of the RPN calculator.
03:10:10 <Intolerable> pop should be Stack a -> (Maybe a, Stack a)
03:10:25 <mrkgnao> okay.
03:10:32 <Intolerable> :t state
03:10:34 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
03:10:57 <Intolerable> usually if you're returning a result and a modified structure, you want the structure to be the second component of the tuple
03:11:05 <Intolerable> since then you can use state to manipulate it
03:11:13 <Intolerable> (without having to swap the tuple contents)
03:11:19 <mrkgnao> okay.
03:11:27 <mrkgnao> so I could use this to make the code cleaner?
03:11:51 <mrkgnao> what about the operator lifting?
03:12:14 <mrkgnao> (lines 155 on.)
03:13:50 <Intolerable> push should probably have some way of signaling that the Stack is full
03:13:58 <Intolerable> rather than silently dropping the additional element
03:14:20 <anohigisavay> hi. i have problem in understanding some concept of category theory
03:14:25 <anohigisavay> https://en.wikibooks.org/wiki/Haskell/Category_theory
03:14:56 <anohigisavay> The main category we'll be concerning ourselves with in this article is Hask, which treats Haskell types as objects and Haskell functions as morphisms and uses (.) for composition: a function f :: A -> B for types A and B is a morphism in Hask. 
03:15:31 <anohigisavay> if i have f :: A -> B and g :: B -> C
03:15:58 <anohigisavay> (g . f) is not necessarily id
03:16:17 <dutchie> why should it be id?
03:16:37 <anohigisavay> also stated in this article: So which is the morphism f \circ g? The only option is \mathit{id}_A.
03:17:35 <dutchie> anohigisavay: that's in that specific given category
03:17:49 <dutchie> with two objects and the 4 shown morphism
03:17:50 <dutchie> s
03:19:08 <anohigisavay> if that makes sense, then i don't understand Exercise 2
03:19:18 <anohigisavay> (Harder.) If we add another morphism to the above example, it fails to be a category. Why? Hint: think about associativity of the composition operation.
03:20:02 <anohigisavay> i was thinking that according to associative law: (f . g . h) == (f . idB)
03:20:25 <anohigisavay> also (f . g . h) == ((f . g) . h) == (idA . h) = h
03:20:48 <anohigisavay> so f IS h
03:21:16 <dutchie> exactly, but we assumed f isn't h when we "added another morphism"
03:21:48 <mrkgnao> Intolerable: any idea how that could be done?
03:22:25 <Intolerable> push :: a -> Stack a -> Maybe (Stack a)
03:22:36 <Intolerable> ?
03:23:06 <mrkgnao> I did that at first.
03:23:17 <mrkgnao> It made doing everything else quite hard.
03:23:29 <delYsid> Is there a command-line tool to print the source of a certain Haskell entity, without me having to use a web browser and find it manually in hackage?  Something like "hsrc Functor" or "hsrc (<$>)"?
03:23:36 <anohigisavay> dutchie: how is the example different from categories in general?
03:23:43 <mrkgnao> Besides that, is there anything else where I should be using some monadic technique?
03:24:15 <mrkgnao> That parse function looks like it should use >>=.
03:24:20 <mrkgnao> I have no idea how.
03:24:28 <Intolerable> does it?
03:24:33 <Intolerable> looks fine to me
03:24:46 <Intolerable> oh wait there's more under the [x] case
03:25:39 <mrkgnao> I used to know a little about monads once, and this looks like the kind of code they make easier to understand.
03:25:44 <mrkgnao> I need to read LYAH again.
03:25:48 <Intolerable> you're missing cases on parse as well
03:26:07 <Intolerable> oh wait you're not
03:26:14 <Intolerable> im really not awake this morning
03:26:28 <mrkgnao> haha, you're being really helpful actually :)
03:28:26 <dutchie> anohigisavay: i'm not an expert in category theory exactly, my my guess is that with only two objects, there isn't enough "room" for much structure
03:28:27 <Intolerable> http://lpaste.net/4677130123038687232 ?
03:28:35 <Intolerable> that make sense?
03:28:37 <dutchie> by analogy with groups
03:29:22 <mrkgnao> anohigisavay: I might be able to help.
03:29:27 <mrkgnao> what's your question?
03:29:38 <anohigisavay> dutchie: thanks man :)
03:29:47 <mrkgnao> ah, thank you, Intolerable. 
03:29:59 <anohigisavay> mrkgnao: https://en.wikibooks.org/wiki/Haskell/Category_theory
03:30:08 <mrkgnao> yes.
03:30:11 <mrkgnao> what of it?
03:30:20 <Intolerable> the first thing i would do is split it into two modules though
03:30:33 <mrkgnao> yeah
03:30:33 <Intolerable> and then fix the "needs to know about the internals of Stack" thing
03:30:37 <anohigisavay> mrkgnao: umm let me see if i can clearly illustrate my question
03:30:52 <mrkgnao> uh huh, right.
03:30:54 <mrkgnao> thank you.
03:31:01 <mrkgnao> you've helped me a ton.
03:31:14 <mrkgnao> I gotta read about monads.
03:31:25 <Sindriava> When the hell did `ToBool` become a thing??
03:31:25 <anohigisavay> mrkgnao: k. it says Hask treats Haskell types as objects and Haskell functions as morphisms
03:31:32 <mrkgnao> k.
03:31:44 <mrkgnao> :t toBool
03:31:47 <lambdabot> Not in scope: ‘toBool’
03:32:35 <anohigisavay> mrkgnao: morphisms should be a mapping between these types, not between values under these types, no?
03:32:43 <mrkgnao> depends.
03:33:06 <mrkgnao> the morphisms can be anything you like in a category, as long as they satisfy the rules.
03:33:18 <mrkgnao> associativity, identity etc.
03:33:27 <anohigisavay> mrkgnao: in the graph f is a morphism from B to A, and g the other way around
03:33:39 <mrkgnao> yeah.
03:34:16 <mrkgnao> which diagram? the one under "Category laws"?
03:34:24 <anohigisavay> mrkgnao: yes
03:34:35 <mrkgnao> ok.
03:34:48 <mrkgnao> are you confused about why g . f = id?
03:34:52 <anohigisavay> mrkgnao: `So which is the morphism (f . g)? The only option is idA
03:34:57 <anohigisavay> mrkgnao: yes exactly
03:35:00 <mrkgnao> oh.
03:35:04 <mrkgnao> see.
03:35:54 <mrkgnao> do you know the definition of a category?
03:36:22 <anohigisavay> well this is the only article i ever read about category
03:36:34 <mrkgnao> allow me.
03:36:50 <mrkgnao> a category C is defined by a set of objects, and a set of "morphisms" between pairs of objects.
03:37:30 <anohigisavay> ok i think i can follow this
03:37:35 <mrkgnao> the set of objects is denoted ob(C), and the set of morphisms from an object A to an object B is denoted hom(A,B) or mor(A,B).
03:37:39 <mrkgnao> ok?
03:37:45 <anohigisavay> uh no sorry xD
03:37:54 <mrkgnao> that's just notation.
03:38:00 <mrkgnao> so, for instance:
03:38:07 <mrkgnao> in that category in the diagram,
03:38:13 <mrkgnao> ob(C) = {A, B}
03:38:21 <mrkgnao> mor(A,A) = idA
03:38:32 <mrkgnao> sorry.
03:39:09 <anohigisavay> yes
03:39:10 <mrkgnao> mor(A,A)= {idA}, mor(A,B) = {f}, mor(B,A) = {g}, mor(B,B) = {idB}.
03:39:17 <mrkgnao> makes sense?
03:39:25 <mrkgnao> they're just sets of morphisms.
03:39:56 <mrkgnao> the only conditions that these must satisfy are: 
03:40:43 <anohigisavay> mrkgnao: by {} do you mean there can be many morphisms from A to B?
03:40:51 <mrkgnao> yup
03:41:01 <mrkgnao> for instance, look at Hask.
03:41:23 <mrkgnao> two objects in this category are Int and String, right?
03:41:27 <mrkgnao> they're types.
03:41:33 <anohigisavay> yes
03:41:45 <mrkgnao> now there are a lot of functions Int -> String, right?
03:42:36 <anohigisavay> i don't understand this: if i have arbitrary functions: f :: Int -> String and g :: String -> Int
03:42:42 <anohigisavay> mrkgnao:yes
03:42:45 <mrkgnao> they are morphisms in Hask.
03:42:57 <mrkgnao> no, just follow it with me.
03:43:14 <mrkgnao> now, the category shown in the diagram just has too few morphisms.
03:43:18 <anohigisavay> mrkgnao: ok :D
03:43:27 <quicksilver> shachaf: can optic combinators build things like 'mapMaybe' (in particular Data.Map.mapMaybe) ?
03:43:41 <mrkgnao> so, what is the type of g?
03:44:07 <anohigisavay> A -> B
03:44:13 <mrkgnao> right
03:44:48 <mrkgnao> in math, you'd write g ϵ Mor(A,B).
03:44:52 <mrkgnao> not important.
03:45:00 <mrkgnao> what is the type of f?
03:45:13 <anohigisavay> B -> A
03:45:17 <mrkgnao> right.
03:45:28 <mrkgnao> so what must the type of g . f be?
03:45:58 <anohigisavay> B -> B
03:46:03 <mrkgnao> good.
03:46:26 <mrkgnao> now, do you see that all the morphisms in that category are represented by arrows?
03:46:33 <anohigisavay> yes
03:46:47 <mrkgnao> how many morphisms are there with type B -> B?
03:46:51 <mrkgnao> in that category?
03:46:58 <anohigisavay> one
03:47:05 <mrkgnao> so it has to be g . f
03:47:08 <mrkgnao> done!
03:47:21 <anohigisavay> uuhh...
03:47:34 <mrkgnao> tell me.
03:47:39 <mrkgnao> what didn't you get?
03:48:01 <anohigisavay> um...
03:48:13 <mrkgnao> it's part of the definition of a category that for any object A there has to be at least one morphism A -> A.
03:48:16 <mrkgnao> do you understand this?
03:48:21 <mrkgnao> that's just the definition.
03:48:28 <anohigisavay> yes i understand
03:48:55 <mrkgnao> so one of these A -> A morphisms is called the identity.
03:49:03 <mrkgnao> this is usually a "special" one.
03:49:07 <mrkgnao> it changes nothing.
03:49:12 <mrkgnao> for instance,
03:49:17 <mrkgnao> id :: String -> String
03:49:22 <mrkgnao> id str = str
03:50:01 <mrkgnao> that does not mean that, if f :: Int -> String and g :: String -> Int, then g . f = d.
03:50:06 <mrkgnao> id*, sorry.
03:50:15 <mrkgnao> was that your problem?
03:50:20 <anohigisavay> yes
03:50:39 <mrkgnao> it just means that, **in that specific category**, g . f = idA.
03:50:55 <mrkgnao> usually, f . g = id if they are "inverses".
03:51:15 <mrkgnao> for example, I think read . show = id.
03:51:38 <anohigisavay> the diagram doesn't say f g are inverses
03:51:52 <mrkgnao> there is no option for them but to be inverses.
03:52:38 <anohigisavay> sorry brb
03:52:45 <mrkgnao> oh, sure
03:54:26 <anohigisavay> mrkgnao: are you still there?
03:55:23 <anohigisavay> ._. ahhhh missed my chance
03:56:14 <anohigisavay> mrkgnao: thank you anyway 
04:02:40 <wunki> I was looking at the Airship library and I wondered why they decided to implement all functions in a record type. My first hunch being to do it in a type class. See: https://github.com/helium/airship/blob/master/src/Airship/Resource.hs#L34-L106
04:02:57 <wunki> anyone any ideas why they decided to go this route?
04:03:14 <merijn> wunki: Because it's more flexible
04:03:34 <merijn> wunki: The typeclass approach doesn't really get you any extra flexibility and this makes lots of things nice
04:03:53 <merijn> wunki: i.e. it becomes easy to have a heterogeneous list/collection of Resources
04:04:11 <merijn> wunki: If you have a typeclass you can't mix different types that are instances of it in the same collection
04:04:51 <wunki> merijn: when would you prefer a type class over the above?
04:06:09 <merijn> wunki: When it makes sense to write general code. i.e. when the typeclass 1) has laws so you can reason about what generalised code does and 2) the operations are sufficiently general
04:06:43 <aweinstock> wunki: https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
04:06:45 <afonso> In gloss, what does "simulation steps per second of real time" mean?
04:06:51 <afonso> It's an argument of playIO
04:07:07 <merijn> wunki: tbh, I almost never write new typeclasses (unless I'm doing type-level hackery), mostly I just instance existing ones
04:07:23 <merijn> afonso: The number of steps per second? :p
04:07:24 <saulzar> afonso, It's the number of times the state update (and render) get called each second
04:07:28 <merijn> afonso: Think "frame rate"
04:07:40 <merijn> afonso: 60 FPS -> 60 simulation steps per second
04:07:41 <afonso> merijn: but what are "steps" ?
04:07:47 <afonso> it's not frame rate, it cant be
04:08:08 <wunki> merijn: bedankt! :) Starting to understand, going to read that post as well.
04:08:23 <saulzar> afonso, Howcome?
04:08:49 <saulzar> afonso, The last argument of playIO is a 'step' function
04:08:51 <merijn> Most simulations have two notions of frames
04:09:02 <merijn> "frame" as in "rendered picture"
04:09:16 <merijn> and "frame" as in "the state of my simulation"
04:09:38 <merijn> i.e. where are objects in the world, whatever
04:09:59 <quicksilver> as a general rule, the time to write a new type class is when you are implementing a new overloaded operation
04:10:05 <quicksilver> (like the way (+) works)
04:10:18 <quicksilver> it's not a general purpose abstraction and it doesn't replace 'class' in OO design, certainly
04:14:58 <merijn> If you want an OO style class the "record of functions" approach used by airship works fairly well
04:15:19 <merijn> I've used it a couple of times and it's very flexible and straightforward :)
04:16:03 <roelof> hello, I have a challenge with this type signature : smallerRoot, largerRoot : : Float -> Float -> Float -> Float 
04:16:24 <roelof> Can a function has a name with a . in it. or must I make two functions
04:16:47 <liste> roelof no .'s in any identifier names
04:16:54 <Hakim> roelof i dot think so...
04:17:10 <roelof> sorry I mean a , like the type signature I gave 
04:17:20 <Hakim> only maybe to some extent in terms of infix operators
04:17:26 <liste> that means two functions that both have that sig
04:17:47 <liste> > let {a, b :: Int; a = 1; b = 2} in a + b
04:17:49 <lambdabot>  3
04:18:12 <roelof> oke, I thought so. Sometimes Craft has a very confusing way to describe exercises 
04:27:47 * hackagebot hmatrix 0.17.0.1 - Numeric Linear Algebra  https://hackage.haskell.org/package/hmatrix-0.17.0.1 (AlbertoRuiz)
04:27:49 * hackagebot hmatrix-gsl 0.17.0.0 - Numerical computation  https://hackage.haskell.org/package/hmatrix-gsl-0.17.0.0 (AlbertoRuiz)
04:27:51 * hackagebot hmatrix-special 0.4.0.0 - Interface to GSL special functions  https://hackage.haskell.org/package/hmatrix-special-0.4.0.0 (AlbertoRuiz)
04:27:53 * hackagebot hmatrix-tests 0.5.0.0 - Tests for hmatrix  https://hackage.haskell.org/package/hmatrix-tests-0.5.0.0 (AlbertoRuiz)
04:27:55 * hackagebot hmatrix-glpk 0.5.0.0 - Linear Programming based on GLPK  https://hackage.haskell.org/package/hmatrix-glpk-0.5.0.0 (AlbertoRuiz)
04:30:03 <merijn> @pl (\(cons, x) -> map (second (,x)) cons)
04:30:04 <lambdabot> (line 1, column 30):
04:30:04 <lambdabot> unexpected ','
04:30:04 <lambdabot> expecting expression
04:30:10 <merijn> hmmm
04:30:23 <quicksilver> @pl doesn't understand ,-sections
04:30:23 <lambdabot> (line 1, column 20):
04:30:23 <lambdabot> unexpected ','
04:30:23 <lambdabot> expecting variable, "(", operator or end of input
04:30:32 <merijn> quicksilver: Ah
04:30:47 <merijn> @pl (\(cons, x) -> map (second (flip (,) x)) cons)
04:30:47 <lambdabot> uncurry (flip (map . second . flip (,)))
04:31:00 <merijn> not very enlightening :p
04:32:47 * hackagebot hTensor 0.9.0 - Multidimensional arrays and simple tensor computations.  https://hackage.haskell.org/package/hTensor-0.9.0 (AlbertoRuiz)
04:32:48 <roelof> liste : then this is the last solution to chapter 3 : http://lpaste.net/141034 . Any remarks ?? 
04:34:57 <merijn> Man, I hate it when I have tuple munging code and I have no idea how to name the individual parts
04:35:55 <liste> roelof if it's supposed to be 0 when there's no roots
04:37:47 * hackagebot RepLib 0.5.3.5 - Generic programming library with representation types  https://hackage.haskell.org/package/RepLib-0.5.3.5 (sweirich)
04:38:15 <roelof> liste : yes, the exercise is stated this :  In the case that  the equation has no real roots or has all values as roots you should return zero  as the result of each of the functions. 
04:38:53 <lpaste_> merijn pasted “How do you name stuff like this?!” at http://lpaste.net/141036
04:40:00 <merijn> roelof: You can improve upon the assignment by making it return "Maybe Float" and returning Nothing if the number of roots is 0 :)
04:41:07 <roelof> Merijn : I could do that but things like Maybe are not explained. The Maybe would make life much easier 
04:46:22 <pplorins> did you ever encounter any wrong descriptions in learnyouhaskell.com
04:46:24 <pplorins> ?
04:46:44 <roelof> oke no remarks, Then time to goto chapter 4 Desinging a programm in Chraft's book 
04:46:52 <pplorins> just literal mistake , not concept mistake , I mean
04:47:17 <roelof> pplorins:  sorry I never used that book 
04:47:33 <pplorins> okay , doesn’t matter
04:47:48 <merijn> pplorins: There's some small pieces that aren't so much mistakes as outdated
04:48:05 <merijn> pplorins: i.e. the transformers section mentions the State constructor, but that no longer exists
04:48:27 <pplorins> got it
04:49:12 <merijn> pplorins: But most (say, like 90-95%) is completely unchanged so, barring some small typos I don't think there's any mistakes in there
04:49:13 <roelof> merijn:  are there any updated books then. I use a book from 2011 / 2012 Craft 3 edition 
04:49:19 <DEA7TH_> I have data Node = Intermediary Int | Final; How can I make a function which takes a Intermediary node, not just any Node?
04:49:26 <merijn> roelof: State was changed before then
04:49:38 <merijn> DEA7TH_: You can't
04:50:04 <DEA7TH_> :(
04:50:11 <roelof> merijn : oke, then I will contineu with my book 
04:50:15 <merijn> DEA7TH_: Well, the long answer is "you could change the code and enforce that, but it requires a bunch of extensions and beginner wizardry levels"
04:50:21 <liste> DEA7TH_ why would you want that?
04:50:38 <liste> tell us the context (:
04:50:43 <merijn> lpaste_: Oh, I can think of plenty of reasons, i.e. things like a safe version of "head" :)
04:50:49 <merijn> s/lpaste_/liste
04:51:19 <merijn> DEA7TH_: I can link you some neat tricks, but they might just be needlessly confusing if you're just beginning :)
04:51:26 <DEA7TH_> This is why I want it: https://gist.github.com/VelizarHristov/21fd8dec6a96a0d51f1e
04:51:28 <DEA7TH_> (line 12)
04:51:31 <liste> yeah, I often need that and use something like GADTs
04:51:46 <DEA7TH_> I'm solving the second problem from here: http://learnyouahaskell.com/functionally-solving-problems
04:52:34 <DEA7TH_> and implementing state-space exploration to solve it. Any intermediate state will always be at a Stop, rather than Node
04:53:34 <DEA7TH_> merijn: could the tricks solve that? I'm willing to try it
04:54:21 <DEA7TH_> (yeah I know I could model the problem better, but I've done it that way already)
04:55:33 <merijn> DEA7TH_: Yes, but if you're still working through LYAH I suspect it will just be needlessly confusing for you
04:55:38 <quicksilver> I haven't used haskell for a few years, installed haskell platform the other day, it works fine but I can't cabal install
04:56:06 <DEA7TH_> merijn: I can do it after I learn monads
04:56:12 <merijn> quicksilver: Dumb question: Is cabal in your path? :p
04:56:14 <DEA7TH_> or any other prerequisite it may have
04:56:15 <lpaste_> quicksilver pasted “cabal-install error (haskell platform 7.10.2 OSX)” at http://lpaste.net/141038
04:56:32 <quicksilver> merijn: I was just pasting the error :) ^^
04:56:45 <merijn> quicksilver: Which version of OSX?
04:56:50 <quicksilver> mavericks
04:56:58 <merijn> I need a number :p
04:57:04 <quicksilver> 10.9.5
04:57:12 <merijn> Ah...odd...
04:57:19 <quicksilver> I googled a bit and I do see people having this error
04:57:29 <quicksilver> but they mostly claim it was in earlier versions of GHC etc :(
04:57:38 <merijn> Oh, wait this is prelude-extras that's failing to install...
04:57:46 <merijn> Try -v3 and see where the error comes from
04:57:48 * hackagebot cayley-client 0.1.4.0 - A Haskell client for the Cayley graph database  https://hackage.haskell.org/package/cayley-client-0.1.4.0 (MichelBoucey)
04:57:51 <quicksilver> yeah but the same error with any module which involves the C compiler I guess
04:57:55 <quicksilver> certainly that error with plenty of modules
04:57:58 * quicksilver tries that
04:58:47 <merijn> quicksilver: Also what's does "cc -v" say?
04:59:04 <quicksilver> Apple LLVM version 4.2 (clang-425.0.24) (based on LLVM 3.2svn)
04:59:12 <merijn> Ah
04:59:17 <merijn> A suspect!
04:59:38 <merijn> quicksilver: XCode version?
05:01:27 <quicksilver> merijn: 4.6 it seems
05:01:42 <quicksilver> want me to paste the -v3 output for a package? it's kinda long
05:01:44 <merijn> quicksilver: I'm guessing the issue is that your commandline tools are out of date
05:02:10 <merijn> quicksilver: I'm on XCode 6, so presumably the flags accepted by clang changed at some point
05:02:21 <quicksilver> Aha. I did migrate from an older mac
05:02:26 <quicksilver> think it migrated the old tools or something?
05:02:41 <merijn> And GHCs preprocessing call is generating flags clang doesn't know how to deal with
05:03:09 <merijn> Hence why cc1 is whining about flags, instead of GHC. Which is why basically every package using CPP would be broken
05:03:27 <quicksilver> ls: /Library/Developer/CommandLineTools/: No such file or directory
05:04:01 <quicksilver> merijn: what do I do? upgrade XCode?
05:04:47 <merijn> You should check the AppStore for XCode updates
05:04:49 <merijn> Yeah
05:05:01 <quicksilver> trying that, thanks
05:05:47 <merijn> And after that you may need to run "xcode-select --install" in the terminal to fetch the latest commandline tools
05:07:03 <roelof> all mac fans here or also people who are using linux for haskell 
05:07:33 <merijn> roelof: I'd say the majority is an equal split between OSX/linux and a minority of windows users
05:08:20 <roelof> oke, I use Linux on a cloud enviroment (Nitriuos.io). I have only a Win10 computer 
05:10:18 <quicksilver> merijn: "The current version requires 10.10 but you can download an older version"
05:10:27 <quicksilver> or words ot that effect. We'll see what it does.
05:12:22 <quicksilver> argh 2.6G download :(
05:17:46 <chpatrick> DEA7TH_: take an Int instead
05:18:10 <quicksilver> merijn: now I have 6.2
05:18:33 <quicksilver> "Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo"
05:18:36 <quicksilver> haha
05:18:54 <chpatrick> DEA7TH_: data Tree = Intermediate NodeId | Final
05:19:03 <chpatrick> operateOnIntermediateOnly :: NodeId -> ...
05:19:10 <chpatrick> or whatever
05:19:19 <chpatrick> no need for crazy dependent stuff
05:20:39 <quicksilver> merijn: prelude-extras installed fine! thanks! Now trying lens :)
05:28:04 * hackagebot yesod-auth-account-fork 2.0.1 - An account authentication plugin for Yesod  https://hackage.haskell.org/package/yesod-auth-account-fork-2.0.1 (FelipeLessa)
05:29:43 <quicksilver> merijn: and.. lens installed fine. thanks again.
05:29:50 <merijn> Isn't "strength" defined anywhere? :\
05:29:57 <merijn> This is like the umpteenth time I need it...
05:31:23 <xandaros> So, I have a bunch of constructors and want to store them in a list-ish type of thing. No constructor may appear more than once and I couldn't care less about the order. Sounds like a set to me, but these constructors can carry data. I'm not very keen on using an Eq that just matches the constructor, so... any recommendations?
05:32:12 <quicksilver> I would make an auxiliary data type which has only the constructors
05:32:17 <merijn> xandaros: Derive Enum and Bounded and use "[minBound..maxBound]"?
05:32:26 <quicksilver> and I'd store it in a Map where the keyType is the constructor-only thingy
05:32:30 <quicksilver> and the value type is the full type
05:32:32 <quicksilver> not very elegant.
05:32:45 <merijn> xandaros: Oh wait, you want to extract all values with a certain constructor from a list?
05:33:09 <xandaros> merijn: No, there will (or should) only ever be one
05:33:34 <xandaros> Not necessarily talking about a list. I'd like to avoid using a list, to be honest
05:33:36 <merijn> Not really a nice way I can think of
05:38:49 <Reshi> Is undefined the equivalent to pass in python?
05:39:26 <ent> undefined throws an error at runtime
05:39:39 <frerich> Reshi: No, 'pass' is not a value in Python.
05:39:55 <liste> return () would be roughly equivalent to pass
05:40:04 <Reshi> frerich: what can I use if I have not yet decided the implementation of the function
05:40:11 <cocreature> xandaros: you might be able to get away with Constr from Data.Data
05:40:13 <ent> undefined is usually used for that
05:40:15 <frerich> Reshi: In Haskell? 'undefined'.
05:40:20 <merijn> Reshi: If you have GHC 7.10 use typed holes
05:40:20 <ent> it is kind of used in the same way as passed
05:40:22 <Reshi> frerich: but want to suppress errors 
05:40:24 * merijn smacks everyone
05:40:27 <merijn> undefined is stupid
05:40:38 <ent> what's wrong with undefined?
05:40:39 <merijn> Reshi: Use "_"
05:40:44 <frerich> Reshi: merijn will point out how you can use typeh oldes, and how they can be turned into warnings soon
05:40:46 <merijn> ent: Trivial to forget to fix all of them
05:40:47 <xandaros> holes ftw
05:41:04 <merijn> ent: Typed holes produce a compile time error so you can't forget them
05:41:24 <ent> oo, that sounds nice
05:41:31 <merijn> Use -fdefer-typed-holes to compile and run code without filling in the holes and -fno-warn-typed-holes to silence their warnings
05:42:00 <merijn> Basically, -fdefer-typed-holes is -fdefer-type-errors but for holes only
05:42:14 <xandaros> I like to use defer-typed-holes, but suppressing the warnings seems like a bad idea
05:42:31 <merijn> xandaros: Depends, I use syntastic to highlight warnings in vim
05:42:47 <merijn> Obviously I don't want syntastic to highlight every hole in my file
05:42:50 <Reshi> merijn: sounds good, I wanted to actually suppress ghc-mod errors for the time being, before compilation
05:43:12 <xandaros> merijn: Fair enough, although I like the highlighting of holes in emacs
05:43:14 <merijn> This is only in 7.8 (or maybe even 7.10)
05:43:17 <merijn> But yes :)
05:43:49 <merijn> Reshi: Any identifier that 1) starts with an underscore and 2) is not in scope is automatically considered a typed hole, see the GHC manual for details
05:44:57 <Reshi> merijn: thanks! Looking at it now
05:48:52 <Reshi> xandaros: yeah you are right, holes do look different than underscores. Quite nice!
05:50:24 <xandaros> Discovering holes was a revelation to me. You can do proper top-down development without having undefined everywhere. And by deferring them, you actually test the branches you already wrote and leave the rest as a hole.
05:50:51 <merijn> xandaros: Deferred holes are the best thing since sliced bread, no? :D
05:51:07 <quicksilver> I shuld try them but I'm quite used now to alternating top-down/bottom-up
05:51:09 <xandaros> best thing since dependent types :P
05:51:40 <xandaros> (Even if we don't have those properly yet)
05:52:06 <merijn> I wonder which handsome fellow added those to GHC... >.>
05:53:32 <UberLambda> Is the "standard way" to create games using a pure functional language cramming all game state in a variable that gets passed to all functions?
05:53:53 <merijn> UberLambda: "It Depends"
05:54:10 <merijn> The purely functional way would be Functional Reactive Programming, but I dunno if there's a good FRP engine library yet
05:54:34 <quicksilver> the answer to UberLambda's question is still 'No'
05:54:38 <quicksilver> with or without FRP
05:54:51 <quicksilver> you still want to only pass to functions that state which is actually releavnt to them
05:54:53 <UberLambda> merijn: yeah, I've seen Elm... but it also seems to want you to accumulate all of your game state in a single structure
05:55:04 <quicksilver> you may have a structure which stores it all, for sure
05:55:08 <quicksilver> but you dont' pass that structure to everything
05:55:09 <UberLambda> quicksilver: but, say that I need to do some pathfinding 
05:55:17 <xandaros> UberLambda: I recommend -game for that. And yeah, do take a look at FRP. It seems to be the most popular way to do games atm
05:55:36 <quicksilver> UberLambda: that's easy for me to say
05:55:41 <quicksilver> UberLambda: I just wrote a path-finding algorithm.
05:55:49 <UberLambda> quicksilver: oh :P
05:56:01 <UberLambda> quicksilver: I meant more of a full AI solution
05:56:02 <xandaros> An alternative approach is to have a gamestate structure in a state monad. It is questionable how "functional" that is, though
05:56:46 <UberLambda> imagine an AI that needs pretty much everything about the world... entity positions, map for collision / pathfinding, etc.
05:57:28 <quicksilver> the AI "as a whole" needs the whole state
05:57:30 <UberLambda> what do you do? split it up in as many tiny functions as possible? but there would still be some kind of uberfunction at the top
05:57:40 <quicksilver> but the AI will be broken down into functions which do different bits
05:57:46 <quicksilver> and those bits take just the bit they need
05:57:57 * frerich waits for UberLambda to push Network.AI.Skynet
05:57:58 <quicksilver> as a general piece of advice this applies to imperative programming too..
05:58:06 <quicksilver> minimise the footprint of each module.
05:58:20 <UberLambda> frerich: is Network.AI.Shodan enough?
05:58:37 <frerich> That sounds familiar somehow...
05:58:40 <SHODAN> look at you, hacker..
05:58:54 <UberLambda> a mere creature of flesh and bone
05:58:56 <xandaros> UberLambda: You always have an "uber function": main. You need something to glue everything together. But making tiny functions to minimise coupling IS a valid strategy :)
05:59:11 <UberLambda> or blood? I don't remember
05:59:40 <nullx002> hi
05:59:51 <srhb> nullx002: Hi.
05:59:53 <UberLambda> xandaros: oh, alright :D
06:00:07 <nullx002> how can i convert a floating point number to real number?
06:00:24 <nullx002> like removing .223432 from 12.223432
06:00:46 <UberLambda> Also... how do you make sure that actions are effectively completed in time?
06:00:57 <srhb> nullx002: That's usually not called a "real" number but an integer.
06:01:04 <nullx002> yes i know int
06:01:05 <srhb> nullx002: floor, ceiling and co. may help you
06:01:09 <capisce> UberLambda: "in time"?
06:01:20 <quicksilver> UberLambda: that's a hard problem.
06:01:26 <nullx002> i googled but no real solution
06:01:34 <srhb> > floor 12.42
06:01:37 <lambdabot>  12
06:01:37 <UberLambda> capisce: suppose that I need x FPS... maybe because I need to implement some sort of lockstep 
06:01:42 <nullx002> ok
06:01:50 <nullx002> will search for it... thanks a lot
06:01:52 <quicksilver> haskell's pure computations cannot be interrupted to give partial results
06:02:09 <UberLambda> quicksilver: exactly... do I have to do everything in a monad?
06:02:14 <quicksilver> so if you have time constraints you'll have to break down into small enough chunks that you're sure they won't break the time limit
06:02:28 <quicksilver> and then have a good strategy for stopping when you're nearly out of time.
06:02:48 <tero-> can multithreading help here?
06:02:52 <quicksilver> "doing everything in a monad" isn't really what it sounds like.
06:02:54 <capisce> yep
06:03:05 <UberLambda> also... one (last?) question
06:03:06 <quicksilver> tero-: multithreading can be part of the solution but it doesn't change the basic fact
06:03:15 <quicksilver> that if you interrupt a pure computation you throw it all way
06:03:21 <ARM9> speaking of, any good libraries for realtime graphics? SDL2/opengl wrappers perhaps or is there something better?
06:03:27 <quicksilver> so if you want to design interruptable computations you have to plan for it.
06:03:31 <xandaros> coupling the smartness of your AI to framerate might not be a good idea, though. Maybe have a difficulty setting and just take the framerate hit if need be
06:03:37 <quicksilver> there are indeed opengl and sdl wrappers ARM9
06:03:46 <UberLambda> I usually log a lot of stuff for debugging... but doing so in Haskell would require impurity, right? So, what If I wanted to log stuff in a "normal" function?
06:03:56 <srhb> ARM9: Some new sdl2 bindings were announced recently.
06:04:01 <xandaros> UberLambda: For debugging, look at Debug.Trace
06:04:17 <quicksilver> I have actually trained myself to program in a way which 'never' needs Debug.Trace
06:04:19 <srhb> ARM9: https://ocharles.org.uk/blog/posts/2015-09-07-announcing-sdl2.html
06:04:22 <quicksilver> but it's nice to know it's there.
06:04:40 <xandaros> I rarely use trace, but it can be handy if you don't know what is going on
06:04:43 <capisce> quicksilver: which way is that?
06:05:07 <UberLambda> xandaros: how does that even work? :O
06:05:08 <exio4> srhb: oh, I was waiting for those bindings! thanks, I didn't know they were released 
06:05:23 <srhb> exio4: :)
06:05:35 <UberLambda> xandaros: it seems to me that it's using a normal function do do impure work... right?
06:05:45 <quicksilver> capisce: mostly bottom-up, testing small pure functions interactively to debug
06:05:51 <UberLambda> xandaros: I'm referring to trace :: String -> a -> a
06:05:58 <quicksilver> UberLambda: yes it "cheats"
06:06:01 <xandaros> UberLambda: It's magic. Just take it :P
06:06:02 <quicksilver> but it can be handy
06:06:05 <srhb> UberLambda: unsafePerformIO :-)
06:06:14 <UberLambda> so it's a compiler feature?
06:06:16 <quicksilver> it can also be confusing because the message might not appear when you expect
06:06:28 <quicksilver> because the expression might get evaluated at a different time to what you're expecting
06:06:50 <xandaros> quicksilver: Don't they have some pragmas to prevent that? noinline and such
06:07:03 <exio4> trace str x = unsafePerformIO (putStrLn str >> return x) 
06:07:07 <exio4> @src trace
06:07:07 <lambdabot> trace string expr = unsafePerformIO $ do
06:07:07 <lambdabot>     hPutStrLn stderr string
06:07:07 <lambdabot>     return expr
06:07:11 <geekosaur> that does not help with, say, laziness
06:07:26 <xandaros> true. but that's the whole point of trace, isn't it?
06:07:37 <geekosaur> (otoh often laziness or lack thereof is what you're trying to ferret out...)
06:07:39 <UberLambda> srhb: so this can be used to, say, wrap a pure C function to make it pure from Haskell's perspective?
06:07:56 <xandaros> UberLambda: Exactly
06:08:05 * hackagebot scalp-webhooks 0.1.0.0 - Test webhooks locally  https://hackage.haskell.org/package/scalp-webhooks-0.1.0.0 (boblong)
06:08:09 <merijn> UberLambda: Note the following, though
06:08:11 <geekosaur> actually a variant is used for that
06:08:16 <merijn> @quote Lemmih not.a.bug
06:08:16 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
06:08:36 <srhb> UberLambda: There are other ways to do that which are preferable. :)
06:08:38 <DEA7TH_> chpatrick: my nodes aren't represented as ints internally
06:08:39 <geekosaur> because you don't need to lock the I/O system itself against multiple threads modifying I/O buffer state or whatever
06:08:46 <DEA7TH_> I'll want to refactor once it works, though
06:09:34 <UberLambda> hm... I wonder if allowing explicit "purity" in impure functions would be harmful
06:09:38 <xandaros> UberLambda: I have only once actually used unsafePerformIO directly. It's nice for the trace functions and such, but you shouldn't use it if you can help it
06:10:04 <UberLambda> If I know that a function is actually impure, but it doesn't matter where/when it's executed... isn't it sort of pure?
06:10:31 <UberLambda> srhb, xandaros: got it
06:10:41 <geekosaur> UberLambda, that would be the idea behind ST
06:10:45 <merijn> UberLambda: Does it matter if it's executed 0, one or more times?
06:11:11 <UberLambda> merijn: that should matter
06:11:19 <geekosaur> which gives you local mutable state and protects against the mutability "leaking out"
06:11:24 <UberLambda> geekosaur: ST?
06:11:44 <geekosaur> https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/base-4.8.1.0/Control-Monad-ST.html
06:11:54 <geekosaur> (IO is actually a special case of ST)
06:12:10 <merijn> UberLambda: ghc is allowed to any of those three for pure functions, so if it matters how often it is called, it's not pure
06:12:28 <UberLambda> merijn: oh
06:12:38 <UberLambda> geekosaur: interesting
06:12:43 <srhb> UberLambda: It's really nice to not have to care about synchronization when you're doing multiple threads, for instance.
06:12:56 <srhb> (From a runtime viewpoint)
06:13:03 <UberLambda> srhb: yeah, but you lose some functionality
06:13:08 <UberLambda> atleast it seems like so to me
06:13:17 <srhb> Yes, your functions must be pure :-)
06:13:33 <xandaros> You lose mutability. That's kind of the whole point of functional programming :P
06:13:43 <UberLambda> yeah, but I'm still an imperative person :P
06:13:47 * srhb nods
06:14:09 <UberLambda> I'm still not sure of a lot of things about program structure
06:14:32 <trc> Hi guys, I am trying to write a bit about why functional programming is suited for concurrency. So far I have written about race conditions and locks. I am only writing about 6 lines, it does not need to be anything huge. Any of you guys got a couple of points?
06:15:19 <frerich> trc: I think it's important to emphasize that *pure* functional programming is well-suited for concurrent programs.
06:16:21 <Geekingfrog> I have a bunch of Data types instance of FromJSON. But the payloads I get from server is of the form: {ok: true/false, error: "filled if ok is false", <key>: "the actual response"}. I want to have a generic way to handle the logic "check if there is any error" without having to write an aeson parser every time.
06:16:23 <trc> frerich: good point. However I am forced to write in Scala, so I am trying to make it fit somewhat to scala.
06:17:52 <UberLambda> another example... suppose that I have to modify a 3D texture(maybe a voxel chunk). With mutability, I would simply modify what I need to modify in the 3D texture and be done there.
06:18:06 * hackagebot scalp-webhooks 0.1.1.0 - Test webhooks locally  https://hackage.haskell.org/package/scalp-webhooks-0.1.1.0 (boblong)
06:18:19 <UberLambda> But without it... would I need to stream the whole texture everytime? that's not performant enough
06:18:40 <UberLambda> say that I have ~2GB or so of voxel data
06:19:42 <exio4> Geekingfrog: you can make a record that'd be data ServerPayload a = Error !Text | Payload !a and write a custom instance for itt hat basically does that and then passes thru the parsing to the parameter
06:19:58 <hodapp> UberLambda: the point of Haskell isn't to completely eliminate mutability, it's to restrict mutability to where it's actually needed.
06:20:16 <hodapp> UberLambda: streaming the whole texture every time would *also* be a form of mutability.
06:20:33 <UberLambda> hodapp: yeah, but by permitting mutability... would I need to wrap the whole modification code in a monad?
06:20:46 <Geekingfrog> exio4, thanks, I'll try that
06:21:07 <UberLambda> hodapp: because I have a feeling that this mutability would in fact "infect" higher-level computations, too
06:21:30 <exio4> parseJSON (Object v) = do { ok <- v .: "ok"; if ok then Payload <$> v .: "key" else Error <$> v .: "error"; } or something like this would make it
06:21:34 <hodapp> UberLambda: just how many computations do you have that need to mutate things directly?
06:23:15 <UberLambda> hodapp: well... it could probabily mutate tens of thousands of voxels for each frame (where optimal FPS = 60ish)
06:23:34 <UberLambda> hodapp: I can't afford to copy stuff due to both memory and processing limitations
06:25:07 <hodapp> UberLambda: I don't think anyone is suggesting that you copy stuff.
06:25:21 <exio4> UberLambda: the idea is that if you want to have mutable data you can have it, it's just that you don't use it for everywhere 
06:25:44 <fjordrunner> please, can somebody help me with following (http://lpaste.net/141045)? I'm having a bit hard time to define types for 2 functions,
06:25:45 <UberLambda> hodapp, exio4: but it would seem to me that most computations would require to actually modify a block
06:26:29 <UberLambda> say, during world generation... every single voxel would be probabily modified and I can't think of a place where mutability wouldn't be needed
06:26:39 <fjordrunner> currently it does not do anything,..I'm just trying to define properly the types,..
06:27:02 <hodapp> UberLambda: The general pattern is that the modification code will be in some monad, and that will make use of a variety of other functions, likely most of them pure functions.
06:27:07 <fjordrunner> layer1 function will have DB IO,..
06:27:39 <UberLambda> hodapp: yeah, I think the monad would be huge compared to the other functions
06:27:47 <exio4> UberLambda: during the world generation, I wouldn't have mutation but maybe some kind of function that generates maybe chunks of the world purely
06:28:32 <UberLambda> exio4: that would be a solution... but it's quite expensive in terms of memory (and also I would have to copy each finished chunk to a persistent storage)
06:28:46 <UberLambda> while with mutability I would generate in-place
06:28:52 <exio4> UberLambda: which copying?
06:29:15 <UberLambda> exio4: once I have the finished chunk, how do I make sure that its memory is aligned with the other ones?
06:29:33 <exio4> ah, you want some specific memory alignment
06:29:44 <UberLambda> exio4: yeah, for faster storage on-disk
06:30:41 <exio4> what about using lazyness? :P 
06:31:04 <UberLambda> ?
06:31:10 <UberLambda> as in... programmer lazyness? :P
06:31:19 <UberLambda> or you mean lazy evaluation
06:31:38 <exio4> you would have a lazy structure, which would be cheap to create (because it'll never exist completely), and where the world generation is basically just applying that function to elements in a vector or so
06:31:54 <exio4> no idea, I am just thinking out loud :)
06:33:22 <UberLambda> exio4: but it would be a nightmare if it suddenly needed to generate thousands of blocks at once
06:33:41 <UberLambda> exio4: maybe the player reached an area he never visited before
06:34:02 <clrnd> fjordrunner, does this compile?
06:34:11 <fjordrunner> no,..
06:34:31 <clrnd> what is the error?
06:34:33 <hodapp> UberLambda: why would that be a nightmare?
06:34:46 <clrnd> oh wait
06:34:55 <fjordrunner> clrnd: http://lpaste.net/141046
06:35:05 <clrnd> fjordrunner, `queryLayer1 xs` is type IO [maybe a]
06:35:13 <clrnd> you can't apply `++` to that
06:35:24 <UberLambda> hodapp: having lazy evaluation suddenly having to process a big chunk of new data... that would turn in a massive frame drop. Worst case scenario I'm thinking of, maybe even a couple of seconds of halting :/
06:35:26 <aweinstock> UberLambda: initially write the program in an imperative style with ST/IO, and then refactor parts of it to pure code with benchmarking?
06:35:42 <exio4> that would work, too
06:35:47 <clrnd> fjordrunner, you need to `etc <- queryLayer1 xs ; return $ res ++ etc`
06:35:56 <UberLambda> yeah, but I would basically use the language as an imperative one :P
06:36:07 <UberLambda> and lose all of the parallelism inbetween...
06:36:19 <hodapp> UberLambda: You're making quite a lot of supposition here on code that doesn't even exist.
06:36:27 <UberLambda> hodapp: true
06:36:37 <clrnd> fjordrunner, (the error says exactly that, "I can't match IO [Maybe a] with [Maybe a]", you need to "get rid" of IO with the "<-"
06:37:01 <hodapp> UberLambda: If it takes *seconds* to generate a few thousand blocks, then you have a lot else to worry about than the paradigm you're programming in.
06:37:10 <UberLambda> hodapp: but I just can't seem to write it.... TBH my goal is creating a new toy language 
06:37:17 <UberLambda> hodapp: noise computation is expensive
06:38:02 <UberLambda> I'd like to create a toy language... and I thought "why not testing it with a game"
06:38:07 * hackagebot scalp-webhooks 0.1.2.0 - Test webhooks locally  https://hackage.haskell.org/package/scalp-webhooks-0.1.2.0 (boblong)
06:38:19 <UberLambda> but so far I'm seeing too many approaches to programming all too specialized
06:38:25 <aweinstock> UberLambda: shouldn't that only be the case if you using a CSPRNG? (or is it a different sense of noise?)
06:38:28 <kuribas> UberLambda: You can always write it first, and rewrite the slow bits using mutation, tight loops, etc...
06:38:57 <UberLambda> aweinstock: Perlin, Symplex that would be needed pretty much everywhere
06:39:29 <fjordrunner> clrnd: many thanks!!!
06:39:35 <clrnd> not at all :D
06:39:43 <UberLambda> so... the reason why I'm writing this is that I'd like to create a toy languge and I'm considering the "pure functional + monads" approach
06:40:44 <UberLambda> but I don't know if it would be better than a less restrictive approach...
06:40:47 <exio4> get :: GameData -> Position -> IO Chunk // get :: Position -> Game Chunk ; do { x <- get (P 1 2 3); ...; } 
06:41:05 <merijn> UberLambda: I always recommend people learn how to implement their own languages :)
06:41:33 <kuribas> UberLambda: Why worry about performance if it is a toy language?
06:41:38 <UberLambda> merijn: so far I have a python compiler that sort of works... but no idea about nor syntax nor semantics. 
06:41:54 <UberLambda> kuribas: because if I can replace C++ for my games, I win :P
06:42:01 <kuribas> UberLambda: You are not going to beat any existing compilers.
06:42:05 <merijn> I recommend getting a copy of Types and Programming Languages by Pierce
06:42:12 <merijn> @where tapl
06:42:12 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
06:42:24 <exio4> maybe after a few years of engineering and research, like 20 kuribas? :p 
06:42:34 <kuribas> exio4: right :)
06:42:39 <UberLambda> kuribas: I know... but even if it's, say, 3x slower than the C3
06:42:41 <merijn> Additionally, Software Foundations might provide a good basis for learning to reason about program semantics
06:42:44 <merijn> @where sf
06:42:44 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
06:42:44 <lambdabot> assistant."
06:42:55 <UberLambda> *C++ equivalent, I wouldn't care... as long as it's easier to parallelize
06:43:02 <clrnd> that's more a Coq book than anything, I'd say
06:43:29 <merijn> UberLambda: A better argument is that, if you implement your own language. Even if you fail at every goal you have you still learn a ton of valuable stuff that makes your very hirable :)
06:43:34 <UberLambda> merijn: noted :D
06:44:20 <UberLambda> merijn: also that... but I'm still at high school, so I don't really need to care about being hired right now :P
06:44:35 <hodapp> UberLambda: well, I'd highly encourage you to actually try implementing something, instead of doing the sort of pre-pre-premature optimization that often comes along with C++.
06:44:57 <merijn> UberLambda: Just ponting out that creating your own language is worthwhile doing even if you (likely) fail every goal you set :)
06:45:08 <kuribas> UberLambda: It will be a good learning exercise, but will not compete with existing languages.
06:45:12 <UberLambda> hodapp: yeah, but everytime I do implement something I end up hating C++ more
06:45:25 <hodapp> UberLambda: that's normal.
06:45:30 <hodapp> UberLambda: I didn't say to implement it in C++.
06:45:33 <merijn> I'm going to have to say that I agree that you're not going to beat any existing language
06:45:44 <UberLambda> yeah, I know
06:45:55 <UberLambda> I'd just like to beat it in syntax/simplicity
06:46:10 <clrnd> that's quite a goal
06:46:11 <UberLambda> and... come on, C++ doesn't even have a freakin' module system
06:46:23 <UberLambda> clrnd: anything would be better than C
06:46:26 <UberLambda> *C++ IMHO
06:46:31 <kuribas> Why not use haskell?  
06:46:33 <UberLambda> C is not that bad, but still
06:46:34 <hodapp> UberLambda: why don't you try making an EDSL in Haskell?
06:46:51 <UberLambda> kuribas, hodapp: because I'm interested in compiler construction
06:46:57 <exio4> hodapp: Haskell is not dependently typed!
06:47:26 <UberLambda> also, is dependent typing any good? It would seem nice, but I've never used it
06:47:28 <hodapp> UberLambda: you can compile all you want to from your EDSL.
06:47:40 <hodapp> UberLambda: it just depends on what you're intending to get out of it.
06:48:08 <UberLambda> hodapp: I'd like to make it "from scratch"... e.g. the usual lex -> parse -> codegen cycle as a whole
06:48:16 <UberLambda> using a DSL would feel like cheating to me :P
06:49:09 <sgeisenh> dependent typing is excellent, you can get many compile-time guarantees that are either impossible or very difficult to express without them
06:49:16 <xandaros> UberLambda: Dependent types are fun to play with, but imo a little too clumsy for production code atm. That might change in the future, though
06:49:20 <hodapp> UberLambda: you're using a pre-built CPU, probably a pre-built assembler and linker, an existing hardware architecture, a standard library that's provided, and an operating system. That's already cheating.
06:49:37 <hodapp> UberLambda: There is no question you're "cheating". The question is what arbitrary abstraction you want to start it.
06:49:59 <sgeisenh> unfortunately, for most dependent type systems, type inference isn't feasible
06:50:09 <UberLambda> hodapp: so - I'd like to start from the OS and an existing language and end up with another language that can produce standalone executables
06:50:22 <UberLambda> *with a compiler that can compile standalone executables
06:50:42 <UberLambda> e.g. I'd probabily set the floor to x86 assembly or LLVM
06:50:43 <xandaros> sgeisenh: On the other hand, program inference IS feasible :P
06:51:07 <merijn> ugh
06:51:15 <merijn> I wish Validation had a join :\
06:51:23 <xandaros> granted, can't do it for every possible program, but the compiler can take a pretty good guess
06:51:34 <Intolerable> merijn: but then ap wouldn't be <*> ?
06:52:14 <quicksilver> merijn: just define it and don't call it join?
06:52:43 <merijn> Intolerable: My problem is that I have "Validation x a", "Validation x b" and "a -> b -> Validation x c" and no non-annoying way to call it
06:52:49 <sgeisenh> xandaros: yeah, especially when you just need a witness, the ability to come up with a term so quickly is pretty cool
06:53:07 * hackagebot rest-gen 0.17.1.3 - Documentation and client generation from rest definition.  https://hackage.haskell.org/package/rest-gen-0.17.1.3 (ErikHesselink)
06:53:22 <hodapp> UberLambda: perhaps start with: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
06:53:43 <cocreature> or http://www.stephendiehl.com/llvm/
06:53:48 <quicksilver> merijn: liftA2?
06:53:48 <hodapp> UberLambda: you have always the options of going one abstraction layer deeper than what you started
06:54:00 <Intolerable> quicksilver: liftA2 is wrong
06:54:05 <merijn> quicksilver: No, because then you still end up with a nested Validation :)
06:54:09 <UberLambda> hodapp: I'm alreading reading it, and also I wish "Make You a Haskell" was ready :/
06:54:11 <Intolerable> you get Applicative t => t (t a)
06:54:18 <Intolerable> merijn: where is Validation from?
06:54:24 <merijn> @hackage either
06:54:24 <lambdabot> http://hackage.haskell.org/package/either
06:54:25 <xandaros> There's also "Write you a haskell", which is quite nice
06:54:27 <Intolerable> @hackage Validation
06:54:27 <lambdabot> http://hackage.haskell.org/package/Validation
06:54:27 <Intolerable> ?
06:54:38 <merijn> No, Validation seems stupidly convoluted
06:54:49 <UberLambda> hodapp: yeah, but I do have a working python interpreter for which is in fact a DSL
06:54:51 <merijn> The one in either seems less confusing
06:55:01 <Intolerable> yeah, either is the better one imo
06:55:04 <UberLambda> hodapp: now I'd like to tackle the whole codegen phase
06:55:17 <clrnd> hey, on a simillar topic, what would be a nice language/architecture to write a compiler/emulator for a meetup-like workshop?
06:55:20 <quicksilver> merijn: I say again, write it by hand and don't call it join?
06:55:23 <Intolerable> literally the best idea is to just define something that throws it into Either, joins it there, and then brings it back to Validation
06:55:32 <hodapp> clrnd: that is, what target should you compile to & emulate?
06:55:39 <Intolerable> but it definitely isn't a Monad and shouldn't be
06:55:44 <quicksilver> splat Failure (Failure e) = Failure e
06:55:58 <quicksilver> that's not what I meant :P
06:56:06 <quicksilver> splat Success (Failure e) = Failure e
06:56:12 <quicksilver> etc.
06:56:12 <clrnd> hodapp, nono, I mean it can be a language like brainfuck or an architecture like chip-8
06:56:34 <Intolerable> splat Failure (Success _) = Failure mempty
06:56:36 <Intolerable> nice and handy there
06:56:47 <cocreature> clrnd: depends on what you expect your audience to be
06:56:49 <clrnd> something with a specification to follow, basically
06:56:53 <quicksilver> that case won't happen Intolerable 
06:57:05 <quicksilver> he doesn't have validation nested in the Failure side
06:57:11 <Intolerable> ah ofc
06:57:24 <clrnd> they are utter n00bs
06:57:28 <clrnd> (me too anyway)
06:58:07 * hackagebot libsystemd-journal 1.4.0 - Haskell bindings to libsystemd-journal  https://hackage.haskell.org/package/libsystemd-journal-1.4.0 (OliverCharles)
06:58:36 <cocreature> clrnd: then something  brainfuck like is probably not a bad idea, osr something lispy. I'd probably go for an interpreter first instead of a compiler since I find it easier to wrap my hands around those
06:58:52 <clrnd> cocreature, oh yeah, I meant interpreter
06:59:29 <greg`> anyone know how to add symbols to haskell fontlock in emacs?
07:00:19 <mariusmarius> greg` divorce yourself from these petty aesthetic pleasantries…be fulfilled with the humble \
07:00:31 <clrnd> any other idea besides BF?
07:00:44 <fetter_oml> do you know how i can get the haskell platform in older version?
07:01:15 <hodapp> clrnd: you could do a basic Scheme or lambda calculus?
07:01:20 <greg`> fetter_oml:  i think you can download different versions from the website
07:01:35 <fetter_oml> only the ghc is available back to 0.29, but i dont see where the haskell platform allows for older builds
07:01:41 <geekosaur> IIRC the old version links were accidentally removed
07:02:03 <clrnd> I'd rather not do lisp, I've done that twice already in other times and places and would feel bored
07:02:14 <mariusmarius> fetter_oml if you're using debian http://snapshot.debian.org/
07:02:17 * geekosaur has done forth a few times
07:02:18 <hodapp> clrnd: oh, okay
07:02:25 <hodapp> yeah, Forth could be a good one
07:02:25 <mbrock> clrnd: Forth is also fun, and something lots of people don't even know about
07:02:35 <mbrock> hah.
07:02:41 <clrnd> Forth?? lets see
07:02:49 <geekosaur> (or variations therof, i.e. one time I made it more like postscript by adding block support)
07:03:09 <fetter_oml> mariusmarius: mhm, i think as a last resort i could get it out of those debs, thank you
07:03:24 <clrnd> forth looks good, thanks!
07:03:51 <mbrock> it's less of a spec-following exercise, and the basics are ridiculously simple... but you can do neat things like "compiler words" (macros)
07:04:44 <mbrock> or if you get ambitious, some simple type inference :)
07:07:21 <mariusmarius> fetter_oml you're very welcome…might be faster…compiled binaries and all that
07:08:23 <fetter_oml> compiling old haskell code (2011, the detexify backend) is much more of an adventure than one could ever dream of
07:08:45 <geekosaur> if you're doing it with 7.10, I can well imagine
07:08:54 <geekosaur> (we burned the bridges...)
07:09:25 <fetter_oml> thats ok from time to time
07:10:06 <fetter_oml> but i interpret that right that it is possible that a version of ghc requires the base-lib-version to be in some range?
07:10:13 <geekosaur> haskell is trying to serve too many masters. it's a research language and at the same time a production language. which often leads to ... fun ... at upgrade time :/
07:10:28 <geekosaur> ghc kinda defines the base library, since it's wired into it
07:10:40 <geekosaur> so a given versionof base is in practice a ghc version dependency
07:11:35 <fetter_oml> ok, than at least im going the right direction (im very new to this, first time im compiling not my own code with cabal)
07:12:14 <quicksilver> geekosaur: which bridges did 7.10 burn?
07:12:29 <quicksilver> speaking as a haskeller from years gone by who mostly used 6.6
07:12:34 <dutchie> i assume mostly AMP
07:12:41 <geekosaur> "bridge-burning proposal" was the original name of the foldable/traversable changes
07:13:00 <quicksilver> ah
07:14:14 <sm> also many common libraries changed APIs, ghc type inferencing rules changed, language pragmas spelling/requirements changed
07:14:17 <fetter_oml> do you know if there were huge changes between ghc 7.6 and  7.2 or might I try 7.6 and reasonably have hope?
07:14:35 <fetter_oml> (7.6 is still in the archlinux AUR, which would be rather comfortable)
07:15:15 <geekosaur> mm, relatively few changes iirc. there were some ghci bugs in 7.2 and 7.4 had an rts bug, but relatively few actual API changes
07:17:25 * UberLambda is starting to love FRP
07:23:09 * hackagebot cubicbezier 0.4.0.2 - Efficient manipulating of 2D cubic bezier curves.  https://hackage.haskell.org/package/cubicbezier-0.4.0.2 (KristofBastiaensen)
07:23:53 <tennix> Hi, i'm reading LYAH and find that GHC is different from the book. GHC Functor has two function and Applicative has four function, while the book only has 1 and 2 functions
07:25:11 <glguy_> Classes can have methods with default implementations
07:25:30 <fetter_oml> geekosaur: well, thanks a lot, maybe detexify will compile with those
07:25:35 <tennix> is this GHC specific?
07:25:44 <glguy_> You can focus on the ones mentioned in the book
07:25:56 <dzhus> Is there anything like Unix `nice(1)`, but for Haskell RTS?
07:26:11 <fetter_oml> althoug im unsure if fixing the code so that it may run with new versions of packages wont be easier (it probably wont)
07:27:48 <delYsid> (/=) = (fmap.fmap) not (==) -- how neat is this!
07:29:00 <quicksilver> tennix: changes were made after that was written
07:29:13 <quicksilver> in fact these changes were made this year, so very recent
07:29:13 <glguy_> Tennix: the extra fmap method and the Applicative class are additions beyond the Haskell standard
07:29:23 <geekosaur> and nobody can find the author to encourage him to update it
07:29:36 <quicksilver> however they are all just stubs to allow more efficient implementation
07:29:45 <quicksilver> they have default implementations in terms of the other primitives
07:38:59 <tennix> is there up to date easy to read documentation?
07:41:38 <quicksilver> for what, tennix?
07:42:10 <tennix> i'm just learning haskell
07:42:29 <quchen> tennix: LYAH leaves away a couple of details, but you don't have to be concerned about the ones you mentioned.
07:42:34 <quicksilver> well you don't need to worry about that difference you've spotted in the typeclasses
07:42:44 <quicksilver> <$ was always a function
07:42:50 <quicksilver> (well, for a long time)
07:42:51 <quchen> <$ and <* and *> don't addanything new to Functor/Applicative.
07:42:56 <quchen> They're there for performance reasons.
07:42:57 <quicksilver> its promition to method doesn't change how you use it
07:43:16 <glguy_> The library documentation for base http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor 
07:43:18 <quicksilver> but the answer to your question is that the up-to-date docs is on the haskell website
07:43:22 <quicksilver> glguy beat me to the link
07:43:32 <quicksilver> and possibly on your own machine depending how you installed haskell
07:44:10 <quicksilver> personally I have this file : file:///Library/Frameworks/GHC.framework/Versions/7.10.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.8.1.0/Data-Functor.html
07:44:19 <quicksilver> you may have something similar if you installed the platform.
07:45:53 <quicksilver> of course I always forget where the local copy is and end up browsing the web version. What a waste of bandwidth I am.
07:45:55 <tennix> wow, you're so warm-hearted, thanks
07:46:17 <quicksilver> also, wow, glguy is still here :)
07:47:31 <tennix> i installed ghc from homebrew, so it's in /usr/local/Cellar/ghc
07:49:10 <tennix> ok, i'll focus on the book until i finished it
07:50:22 <tulcod> quicksilver: here, quickly don't watch this youtube video to offset your waste of bandwidth for this year: https://www.youtube.com/watch?v=dQw4w9WgXcQ
07:50:46 * quicksilver obediently doesn't watch it
07:51:20 <tulcod> msg me in a year for further help
07:54:31 <tennix> i use web browser history a lot. when i type a keyword which i navigated before, the browser always point me to the right location
07:57:29 <quicksilver> yes me too tennix 
07:57:34 <tennix> BTW does these symbols like <$ *> <* used frequently in normal programs
07:57:35 <quicksilver> makes me very lazy about bookmarking :)
07:57:50 <quicksilver> <$> and <*> are used as part of a very common idiom
07:58:11 * hackagebot feed-collect 0.1.0.1 - Watch RSS/Atom feeds (and do with them whatever you like).  https://hackage.haskell.org/package/feed-collect-0.1.0.1 (akrasner)
07:58:14 <quicksilver> *> and <* are especially common with parser combinators
07:58:21 <voidzero> and with Either
07:58:27 <voidzero> iirc
07:58:56 <tennix> i'm firefox fan and use pentadactyl a lot
07:59:06 <quchen> tennix: I'd say there are roughly 10 cryptic function names like that in everyday use, and their names start to make sense when you understand them. But it's not like everything is special character infix operators.
07:59:40 <quchen> >>=  <*>  <*  *>  <|>  $  :  =<<  -- That's probably most of them
08:00:04 <dutchie> maybe (!!) too
08:00:06 <tulcod> quchen: is "--" part of that list for you? :P
08:00:10 <dutchie> but that's not so common
08:00:10 <quchen> No
08:00:10 <tennix> these symbols look a little strange at first time
08:00:22 <ricochet1k> until you import Control.Lens...
08:00:25 <dutchie> (>>)
08:00:41 <quicksilver> tennix: yes, they do.
08:00:51 <delYsid> Why is it that omitted record field initialisation results in a runtime error?  It seems like it would be simple for the compiler to catch that.
08:00:56 <quicksilver> tennix: it's something to learn, but when you learn them they are easier to read than spelled out fully.
08:01:01 <exio4> delYsid: it is a warning
08:01:10 <quicksilver> delYsid: it's a feature. It's considered you might want to miss some out.
08:01:19 <quicksilver> delYsid: (I personally consider it a mis-feature)
08:01:19 <tulcod> tennix: they start to make sense once you start translating do syntax to monad operators while coding
08:01:35 <johnw>  delYsid: hello!
08:01:38 <delYsid> quicksilver: I am on your side.
08:01:51 <delYsid> johnw: hi!!! ltns
08:01:56 <quicksilver> delYsid: it lets you write composable code like
08:01:56 <quchen> Only >>= and =<< above were monadic.
08:02:11 <quicksilver> (setBar 4) . (setBaz 5) $ (Foo {})
08:02:24 <tulcod> quchen: well yes, i'm not saying there's a mathematical relation between the two
08:02:32 <quicksilver> delYsid: ... does that make sense? where you start with an 'empty' record and chain functions which initialise parts of it
08:02:45 <quchen> Foo {} is an expression? Oh.
08:02:49 <quchen> I only knew it in patterns.
08:02:59 <quicksilver> it constructs a record with 'errors' in all the fields
08:03:00 <quicksilver> quchen: 
08:03:30 <tulcod> quicksilver: is there a language extension to turn this behavior off?
08:03:43 <quicksilver> no, but thre is a warning flag
08:03:47 <delYsid> quicksilver: well, yeah, but why not Foo { setBar = 4, setBaz 5}  then :-)
08:03:50 <quicksilver> and you could couple that with making warnings fatal
08:04:03 <quicksilver> delYsid: persumably the real example is more complex than just assignments :)
08:04:04 <tulcod> quicksilver: thanks :)
08:04:12 <delYsid> tulcod: I was also hoping to be able to upgrade the warning
08:05:01 <delYsid> sounds like quite a hole in such a strongly typed language.
08:05:50 <quicksilver> the ability to put 'error' anywhere is a hole in a strongly typed language
08:05:56 <quicksilver> the price we pay for turing completeness etc.
08:06:04 <delYsid> quicksilver: well, I can imagine scenarios of chained partial initialisation that sort of make sense, but still, I would be quite worried about maintaining such code...
08:06:08 <geekosaur> sadly there is no way to turn an individual warning into an error
08:06:19 <quicksilver> delYsid: I agree entirely. And don't use that feature.
08:08:05 <delYsid> johnw: I've already noticed you emersed yourself in the world of Haskell since quite a while.  Did a bit of github spying once, and didn't get a single line of code :-)
08:09:01 <tennix> do you guys write haskell code at work or just for fun?
08:09:11 <johnw> delYsid: it's been quite a lot of fun :)
08:09:14 <johnw> tennix: both
08:09:19 <mmachenry> tennix: I do both.
08:09:47 <delYsid> fun, although I plan to hack some on Propellor and use that for work.
08:10:05 <quicksilver> can lambdabot tell you which module an identifier (that it has in scope) lives in?
08:11:46 <tennix> in what areas?
08:11:58 <delYsid> I read some GHC libraries code recently and wasattacked by quite a number of # characters.  What does that suffix mean, actually?
08:12:16 <johnw> delYsid: those are unboxed constructions, for efficiency
08:12:36 <johnw> delYsid: almost never used in user code, although it is used in some high performance libraries
08:12:53 <tennix> i googled and find haskell job mostly in finance
08:13:08 <delYsid> tennix: Right now, Parsing and System orchestration
08:14:16 <Cale> tennix: I'm writing Haskell code for work right now.
08:14:36 <Cale> tennix: I'm working for Obsidian Systems, rewriting lanehoney.com's web application in Haskell.
08:14:44 <delYsid> johnw: I was guessing it had something to do with efficiency, but what are unboxed constructions, actually?
08:15:24 <doctorrockso_> Hey guys, I'm using haskell-mode in emacs, and when I press enter I'm seeing "Illegal token: value"
08:15:27 <doctorrockso_> what's going on?
08:15:29 <Cale> tennix: We're using Haskell for both the frontend and backend of the service. The frontend uses reflex-dom and is compiled to Javascript using GHCJS. The backend uses Snap and is compiled to native code.
08:15:47 <chpatrick> Cale: how's ghcjs working out?
08:15:54 <Cale> chpatrick: Great!
08:16:12 <chpatrick> is there an ecosystem for it at all?
08:16:18 <chpatrick> meaning handy libraries for client-side
08:16:27 <quicksilver> delYsid, johnw : actually it's just a symbol to indicate it's a GHC internal function. Many of them do indeed refer to unboxed constructs tho.
08:16:42 <johnw> delYsid: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/primitives.html
08:16:55 <quicksilver> delYsid: 'unboxed' means stored as a direct value rather than a pointer to a closure
08:17:05 <johnw> and also see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#magic-hash
08:17:14 <Cale> chpatrick: Well, we have a lot more stuff in-house built up using reflex-dom than has been released to the public yet. But you can generally pull most things off of Hackage and have them work in the browser.
08:17:58 <delYsid> quicksilver: oh, now I remember the concept, thanks.
08:18:11 * hackagebot blaze-shields 0.1.1.11 - create svg by Haskell  https://hackage.haskell.org/package/blaze-shields-0.1.1.11 (Qinka)
08:18:24 <delYsid> sort of like lisp handles ints...
08:18:30 <Cale> chpatrick: Even on its own, reflex-dom is pretty nice to use.
08:19:22 <delYsid> johnw: Thanks, I will have a look.
08:20:26 <tennix> i heard snap has very high performance, but i just checked your website and find the server is nginx + phusion passenger
08:22:21 <tennix> doctorrockso_: i'm using emacs + haskell-mode too. do you have more detailed error info
08:22:36 <tennix> maybe in *Message* buffer
08:23:01 <florian> hello
08:23:12 * hackagebot shelduck 0.1.2.0 - Test webhooks locally  https://hackage.haskell.org/package/shelduck-0.1.2.0 (boblong)
08:28:12 * hackagebot pipes-binary 0.4.0.5 - Encode and decode binary streams using the pipes and binary libraries.  https://hackage.haskell.org/package/pipes-binary-0.4.0.5 (RenzoCarbonara)
08:32:38 <hackrilege> I want to play pacman, where is qndel?
08:34:03 <hackrilege> Came can you point me toward a resource explaining how to write blas in obsodian?
08:34:22 <hackrilege> Cale^
08:36:12 <delYsid> Heh, Haskell code is full of smilies.
08:36:13 <delYsid> (ls :)
08:36:34 <hackrilege> obsidian systems is something different isnt it? Nvm
08:37:37 <ryantrinkle> hackrilege: Obsidian Systems is my company, which does haskell-based web work
08:37:43 <shachaf> quicksilver: That depends on what constitutes things like mapMaybe.
08:38:00 <ryantrinkle> our frontend code is mostly FRP written with reflex
08:38:23 <shachaf> quicksilver: Ah, you gave an example.
08:38:27 <hackrilege> I'm depressed because iv been learning algebra and category theory to try and understand Haskell and my prof says I'm wasting time and maybe I agree with this...
08:38:39 <shachaf> quicksilver: Not really, I think -- a Traversal can't change the shape of a structure.
08:38:50 <exio4> hackrilege: learning is never a waste of time :)
08:39:27 <hackrilege> Ryantrinkel do you have some nicer interface to web socket strands than yesod or conduit?
08:39:41 <ryantrinkle> we use websockets-snap on the backend
08:40:04 <ryantrinkle> and on the frontend we have a small (not yet public) wrapper around the standard DOM interface
08:40:42 <ryantrinkle> basically, the messages come out as Event occurrences, and you send Event occurrences into it to send them to the server
08:40:45 <ryantrinkle> it ends up being pretty clean
08:40:52 <quicksilver> shachaf: yeah a Traversal can't do it
08:41:01 <quicksilver> shachaf: but 'At' has 'sans'
08:41:04 <hackrilege> Exio4 he believes funding my learning in things he cannot understand our see relevant applications of is not ok.
08:41:23 <quicksilver> shachaf: but as far as I can see no combinators to extend sans particularly
08:41:32 <ryantrinkle> hackrilege: well, what sort of applications are you/he interested in pursuing?
08:41:39 <shachaf> quicksilver: You can use (^..) to write regular mapMaybe, but that's not really what you're going for here, I think.
08:42:16 <quicksilver> ryantrinkle: I'm glad you're still haskelling :) I took a look at reflex but didn't feel like watching the videos; I don't suppose there are any examples just to show the kind of things it can do
08:43:20 <hackrilege> I'm trying to write an efficient anamorphic, and an efficient traversal of the resulting structure, specifically growing a polymer in a solvent
08:43:21 <Luke> anyone using structured-haskell-mode here?
08:43:27 <Luke> is it still alive/working?
08:43:33 <hackrilege> Anamorphism*
08:43:36 <tulcod> Luke: yes, and it's working for me
08:43:47 <Luke> tulcod: what version of emacs are you on?
08:43:49 <tulcod> Luke: sometimes its behavior is not /quite/ what i'd like, but generally it's ery helpful
08:44:00 <dutchie> i use shm also, it works for me
08:44:10 <Luke> tulcod: any good guides for using it besides the home page? I can't seem to get it working
08:44:11 <dutchie> i have emacs 24.3.1
08:44:19 <quicksilver> I was thinking of trying SHM but I forgot its name
08:44:20 <Luke> do you know if it's supposed to work on emacs 25?
08:44:22 <tulcod> Luke: 24.5
08:44:26 <quicksilver> where can I get it from? :)
08:44:32 <Luke> https://github.com/chrisdone/structured-haskell-mode
08:44:39 <tulcod> Luke: for using it or for getting it to work?
08:44:41 <quicksilver> thanks
08:44:51 <Luke> actually i'm on emacs 24.5.1 so it should work for me I guess
08:45:18 <Intolerable> what's the best way of doing OCR in haskell?
08:45:20 <hackrilege> The project is to develop some code for use in modeling molecular imprinting of polymers
08:45:28 <Luke> i'm in a do block and create a let xs = [a] and then try to add an element to the list with C-j and it just causes parse errors (SHM!) instead of doing [a, b]
08:45:50 <ryantrinkle> quicksilver: imalsogreg has some cool stuff up here: http://web.mit.edu/greghale/Public/my-reflex-recipes/index.html
08:45:53 <icbm> <-- Haskell noob.  When I want to work with lazy sequences (like IEnumerable<T> in C#) is [T] the best type?  I ask because I've seen discussion that [T] suffers from the usual inefficiencies of linked lists.
08:46:20 <srhb> icbm: [a] is a linked list indeed.
08:46:25 <quicksilver> ryantrinkle: exactly what I wanted! thanks :)
08:46:27 <quchen> icbm: If you just want to enumerate a number of things, lists are often appropriate.
08:46:55 <tulcod> hackrilege: well... i mean, yeah, haskell is in some sense about category theory. and yeah, knowing ct will help with programming. but i also understand if your prof complains that reading up on natural transformations and functor categories isn't helping you write numerical simulations.
08:46:58 <ryantrinkle> hackrilege: sounds like very interesting stuff! i wish i knew more about it
08:47:03 <quchen> icbm: Depends on other factors though. If you'd like cache locality for example, then Vector is a better choice. But those are fixed size.
08:47:32 <tulcod> icbm: if your sequence is lazy but not a linked list, what is it?
08:47:45 <Luke> hmm yeah SHM is just not working. seems like something else is hijacking or something
08:48:03 <quicksilver> ryantrinkle: (although if I'm going to leave that page open in the background to read on the train I wish Safari had a 'pause javascript in this tab' button :P)
08:48:22 <ryantrinkle> quicksilver: haha yeah, that'd be nice
08:48:29 <icbm> quchen: I'm thinking for lazy sequences, like say a lexer. A stream of characters goes in, and a sequence of Token comes out.  There's no need for the entire input or output to be present in memory at the same time.
08:49:00 <quicksilver> icbm: that's precisely the use case of lists, yes
08:49:15 <quicksilver> none of the disadvantages of linked lists stop that working well :)
08:49:30 <quchen> icbm: Since you called yourself a Haskell noob, I'll go ahead and just say that lists are fine for the time being. But we have pretty cool abstractions that you should also consider when you find the time for them, namely the pipes/conduit packages.
08:49:31 <icbm> So if it's defined lazily Haskell will know what to do, and won't go building linked lists all over the place?
08:49:46 <tulcod> icbm: it won't fetch data it doesn't need
08:49:50 <tulcod> (usually)
08:49:53 <quicksilver> linked lists are bad when you (1) want the whole list in memory at once and (2) keep randomly accessing up and down the list
08:50:06 <quicksilver> lists do the right thing if your needs are simple
08:50:15 <quicksilver> pipes and conduits take it up to the next level and give you a lot more control
08:50:26 <quicksilver> at the cost of some more initial brain explosions
08:50:28 <hackrilege> Yeh it's nice, growing a polymer in the presence of some chemical results in a material which shows selective binding affinity for that substance, though the choice of monomer can not yet be used to prefix this behavior. Interestingly it may be one of the most sensitive molecular measuring devices possible, kind of like taste buds, and so the inaccuracies in current simulation motivate a fundamental re-representation of chemistry, which I
08:50:36 <tulcod> icbm: i think that when starting out with haskell, don't worry about performance and stuff. just write code that works, and see if it performs reasonably without memory leaks. when you have leaks, use profilers and all kinds of tricks to solve that afterwards.
08:51:10 <tulcod> hackrilege: (message capped at ", which I")
08:51:35 <icbm> Normally that's the way I would go, but I get the feeling that idiomatic Haskell is far from what the tutorials teach.
08:51:52 <tulcod> icbm: well... it's kind of subtle
08:52:12 <tulcod> icbm: if you know what you're doing, minute changes suffice to vastly improve performance, reduce memory leaks, etc
08:52:16 <hodapp> hmm, if I made a library that only works in conjunction with Ivory, I wonder how kosher it is to stick it all at the module path Ivory.Language.Ion
08:52:26 <tulcod> so it's kind of hard to show what does the trick unless you know some internals
08:53:00 <hackrilege> Which I think should be with Haskell syntax and category theory
08:53:21 <tulcod> icbm: if you're working with relatively small sets of data (<megabytes) and short-running programs (<1 minute), you probably won't go wrong so easily
08:53:24 <hodapp> I had thought hackage had almost no 'rules' on this but I wanted to be courteous about it
08:54:04 <icbm> Okey doke. I'm doing a toy lexer / parser exercise in both Haskell and Rust to compare the experiences.  I'm experienced with neither language.
08:54:13 <quchen> Maybe someone should throw this hackrilege spambot out.
08:54:24 <Qndel> thanks a lot guys
08:54:25 <hackrilege> I have a decent reformulation for entropy and temperature in category theory terminology.
08:54:30 <Qndel> I've passed haskell at school!
08:54:32 <tulcod> icbm: haskell has parsing libraries that are magic from the point of view of other languages
08:54:35 <johnw> Qndel: congrats
08:54:42 <johnw> Qndel: now, have you passed it here? :)
08:54:55 <tulcod> icbm: they can be crazy fast, and can be *MUCH* shorter than equivalent, say, C programs
08:54:55 <Intolerable> you never pass haskell on irc
08:54:57 <Qndel> they were laughing at my game for like 30 minutes but they were merciful
08:54:58 <johnw> I want to know if you were able to glimpse the joy of Haskell at any point
08:55:01 <icbm> tulcod: Oh sure, but I'm doing it from scratch for learning opportunity.
08:55:10 <exio4> are you going to properly learn haskell now? :D
08:55:14 <quchen> Quick, what's the difference between "data Data a = Data !a" and "newtype Newtype a = Newtype a"? ;-)
08:55:14 <Qndel> no :D
08:55:26 <hackrilege> Qndel, I want to play pacman...
08:55:29 <hodapp> Intolerable: of course, no living soul in existence has passed C on IRC
08:55:30 <johnw> but you came back, so that must mean something
08:55:32 <Qndel> do you?
08:55:34 <Qndel> My game is ready!
08:55:45 <Qndel> As a curiosity, it's probably the poorest game ever made
08:55:50 <tulcod> quchen: the Newtype constructor doesn't evaluate a at construction time?
08:56:04 <Qndel> they ensured that I know that I don't know haskell before they gave me the grade
08:56:07 <Qndel> xD
08:56:11 <quchen> Newtypes are strict in their arguments, tulcod.
08:56:11 <exio4> Qndel: upload it to github!
08:56:12 <hackrilege> Quchen, sorry?
08:56:22 <tulcod> quchen: oh really? thanks :)
08:56:41 <johnw> tulcod: that doesn't mean it evaluates it when you wrap Newtype around the argument though
08:56:43 <quchen> tulcod: You get an error if you write "Foo !a" in a newtype even
08:56:55 <tulcod> yeah that's what i'd guess
08:56:56 <johnw> tulcod: it means it evaluates it anytime the Newtype is evaluated
08:57:05 <Gurkenglas> Qndel: upload it to somewhere we can see it!
08:57:10 <tulcod> johnw: yeah
08:57:15 <quchen> johnw: That's the same for the Data type up there though, note the !
08:57:20 <tulcod> okay so i don't know. i failed the quiz.
08:57:25 <Qndel> ok
08:57:29 <Qndel> uploading to github 
08:57:30 <johnw> quchen: sure
08:57:34 <hackrilege> Yay!
08:57:34 <Qndel> 1 question
08:57:39 <Qndel> do I need git to upload to github? xD
08:57:52 <johnw> you can use their web GUI for pretty much everything, I think
08:57:52 <tulcod> -_-
08:58:29 <exio4> quchen: I would go with "nothing" unless you start playing with the memory layout? :P 
08:59:01 <hackrilege> Do you know your grade or did they just give you a minimal pass? Are you sure your prof was not on the ice over the last few days!?
08:59:15 <Qndel> minimal pass
08:59:16 <quchen> exio4: No, there's a denotational difference between them. Pattern matching has special cases for newtypes, and those act slightly different.
08:59:38 <Qndel> everybody else got highest possible grade xD
08:59:43 <Qndel> I was the only one they had to give the lowest :D
08:59:52 <exio4> quchen: which kind of differences?
08:59:56 <tulcod> quchen: can you elaborate?
08:59:59 <hackrilege> Bahaha
09:00:18 <quchen> exio4: In a sense, the "!" means that the data constructor you get is strict, but once your data is in the Data, it's treated as an ordinary "data" type.
09:00:31 <quchen> So pattern matching is the ordinary matching against a "data" type.
09:00:49 <quchen> "Newtype" constructors are known to the compiler on the other hand, and the constructors are basically ignored by special rules.
09:01:02 <quicksilver> the constructors generate no code
09:01:04 <quchen> In data types, you still have to check whether your (one) data constructor matches the pattern.
09:01:11 <quicksilver> to be precise about what 'basically ignored' means
09:01:22 <quchen> quicksilver: That's for the compiler to decide.
09:01:27 <tulcod> quicksilver: re: pausing javascript. i think chromium assigns much less CPU time to unfocused tabs.
09:01:37 <Miko_> Hi. Cabal is in a strange state. When I run `cabal list` I get "warning: Thea package list for "hackage.haskell.org" does not exist. Run "cabal update" to download it`
09:01:39 <quicksilver> quchen: that argument isn't very clear when it comes to newtypes
09:01:39 <quchen> I don't think you *have* to ignore newtypes in code generation.
09:01:54 <exio4> yes, but is there any function you can write that will show that difference?
09:01:57 <quicksilver> newtypes are much more operationally than semantically defined
09:02:01 <tennix> is there a bot in this channel that can execute haskell code
09:02:05 <quicksilver> they're a bit strange in this respect
09:02:07 <hackrilege> My chrome browser reloads tabs that were inactive
09:02:07 <Miko_> But when I run `cabal update` I get "Skipping download: Local and remote files match"
09:02:11 <quchen> quicksilver: Well, pattern matching semantics say "ignore newtypes", but the rest of Haskell doesn't, as far as I'm aware.
09:02:12 <exio4> > 2 + 2
09:02:14 <quicksilver> > "hi " ++ "tennix"
09:02:14 <Intolerable> > Just "hello!"
09:02:14 <lambdabot>  4
09:02:16 <lambdabot>  "hi tennix"
09:02:16 <lambdabot>  Just "hello!"
09:02:19 <Intolerable> lmao
09:02:33 <exio4> poor lambdabot :P
09:02:43 <Intolerable> he's so friendly
09:03:01 <tennix> > pure (+) <*> Just 2 <*> Just 3 <*> Just 4
09:03:01 <quicksilver> quchen: the main reasons you would choose to use newtypes at all are (1) understanding this implementation choice or (2) wishing to use GeneralisedNewtypeDeriving
09:03:02 <lambdabot>      Could not deduce (Num a0)
09:03:02 <lambdabot>      from the context (Num a, Num (a -> b))
09:03:02 <lambdabot>        bound by the inferred type for ‘e_1234’:
09:03:09 <Qndel> [1..99999]
09:03:12 <quicksilver> quchen: so it seems reasonable to discuss the implementaiton choice
09:03:19 <Intolerable> :t (+)
09:03:20 <lambdabot> Num a => a -> a -> a
09:03:21 <Intolerable> :t pure
09:03:22 <lambdabot> Applicative f => a -> f a
09:03:26 <Qndel> [1..10]
09:03:32 <Qndel> lambda y u no work
09:03:33 <Qndel> :D
09:03:36 <quicksilver> tennix: welcome to haskell's unfriendly error messages :(
09:03:38 <Intolerable> > [1..10]
09:03:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
09:03:47 <Qndel> what will happen if I say
09:03:51 <Qndel> > [1..99999]
09:03:51 <quicksilver> tennix: that error is because (+) takes two paramters and you've given it three.
09:03:52 <hackrilege> :t <$>
09:03:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:03:54 <lambdabot> parse error on input ‘<$>’
09:04:01 <Intolerable> :t (<$>)
09:04:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:04:30 <tennix> is this applicative style?
09:04:34 <Intolerable> yes
09:04:47 <nshepperd> quicksilver, quchen: iirc, according to the haskell report newtype construction/destruction should be translated to a coercion
09:05:04 <hackrilege> > (+) <$> 2 <*> 3
09:05:06 <lambdabot>      No instance for (Show (f0 b0))
09:05:06 <lambdabot>        arising from a use of ‘show_M303298167666435187819234’
09:05:06 <lambdabot>      The type variables ‘f0’, ‘b0’ are ambiguous
09:05:16 <quchen> nshepperd: Hm. Okay, that goes onto my report reading queue.
09:05:19 <hackrilege> doh
09:05:28 <Intolerable> > (+) <$> pure 4 <*> pure 5 :: Just Int
09:05:30 <lambdabot>      Expected a type, but ‘Just Int’ has kind ‘Maybe *’
09:05:31 <lambdabot>      In an expression type signature: Just Int
09:05:31 <lambdabot>      In the expression: (+) <$> pure 4 <*> pure 5 :: Just Int
09:05:36 <tennix> LYAH book says this can make a normal function accept any number of arguments
09:05:38 <Intolerable> lmao
09:05:42 <Qndel> I don't know how to upload to github without git xD
09:05:44 <nshepperd> so there really is no code generated
09:05:45 <Miko_> Hi. Cabal is in a strange state. When I run `cabal list` I get "warning: Thea package list for "hackage.haskell.org" does not exist. Run "cabal update" to download it`. But when I run `cabal update` I get "Skipping download: Local and remote files match"
09:05:45 <Miko_> I did nuke the .cabal dir, changes nothing
09:05:47 <Qndel> and I'm not installing git for sure
09:05:49 <Intolerable> > (+) <$> pure 4 <*> pure 5 :: Maybe Int
09:05:51 <lambdabot>  Just 9
09:05:53 <Qndel> won't a zip file on a hosting website do?
09:06:08 <Intolerable> why on earth don't you have git installed?
09:06:11 <tennix> it's step by step
09:06:13 <Qndel> on windows?
09:06:16 <Qndel> Why would I?
09:06:20 <tulcod> Qndel: if you put it on git, people might want to look at it
09:06:23 <nshepperd> but of course something like 'map getSum' will still traverse a list and be slow, unless compiler magic :>
09:06:29 <Intolerable> do you not have any version control at all?
09:06:32 <Qndel> no
09:06:34 <Qndel>  :D
09:06:34 <hackrilege> Qndel, why? Scared it will make you a more well rounded programmer with a public portfolio?
09:06:39 <Intolerable> terrifying
09:06:46 <tulcod> Qndel: also, i don't know who you are or what you're doing, but if you know some haskell but are unwilling to use git, you're doing something wrong
09:07:35 <tulcod> Qndel: there's a GUI version of git
09:07:37 <hackrilege> Haha this guys values are repeatedly followed by this irc
09:07:37 <tulcod> for windows
09:07:45 <hackrilege> Disallowed...
09:08:12 <Qndel> ok uploading it to git
09:08:26 <hackrilege> Git on android couldn't be easier
09:08:46 <julianleviston> Does anyone have any helpful websites or pointers on understanding how ((->) r) is a Monad?
09:09:04 <shachaf> Implement the monad instance and prove the monad laws.
09:09:05 <julianleviston> return is pretty easy, but >>= is doing my head in…  h >>= f = \w -> f (h w) w 
09:09:09 <tennix> `The function can take as many parameters as we want, because it's always partially applied step by step between occurences of <*>.`
09:09:28 <tennix> that's from LYAH
09:09:39 <julianleviston> LYAH is what confused me
09:09:42 <tennix> applicative style
09:09:49 <shachaf> OK, looks like you've done the first part. The second part is also pretty easy.
09:10:17 <julianleviston> shachaf: actually that’s the part I am having massive trouble understanding.
09:10:22 <tulcod> julianleviston: it's the exponential functor from category theory, so it's just the left adjoint to the binary product functor. but that probably doesn't help.
09:10:26 <Qndel> okay nvm
09:10:32 <tennix> julianleviston: what you call learn you a haskell for a great good for short
09:10:34 <Qndel> I'm not going waste my time on git right now
09:10:35 <quicksilver> tennix: he means, that <$><*> notation works for functions with any number of parameters.
09:10:45 <julianleviston> tennix:  LYAH
09:10:49 <hackrilege> Isn't there a monad instance for that thing on the monad source?
09:10:51 <tulcod> Qndel: it's the second most useful thing you can learn
09:10:53 <Qndel> Here's a speedyshare link if you want to laugh
09:10:54 <Qndel> http://www.speedyshare.com/4us8m/Haskell4.zip
09:10:58 <Qndel> I've already worked with git
09:11:27 <quicksilver> tennix: you'll still get an error if the number of parameters you give doesn't work.
09:11:27 <julianleviston> hackrilege:  yeah
09:12:00 <Gurkenglas> Can lens turn this into a oneliner? http://lpaste.net/252645262139326464
09:12:27 <tennix> ah, i see
09:12:46 <hackrilege> So what's the problem? It seems like your telling me you have the answer already..
09:13:04 <julianleviston> hackrilege: the problem is I don’t understand how it works.
09:13:12 <nshepperd> julianleviston: you could try figuring out join and fmap
09:13:13 <hackrilege> Oh
09:14:00 <julianleviston> nshepperd: yeah, I might not understand fmap properly. I thought I had a bit of a handle on it, but I probably should go back to the beginning again.
09:14:56 <hackrilege> Fmap is super simple, it just applied a function to the stuff inside a Functor
09:15:07 <julianleviston> nshepperd: fmap just applies a function inside a Functor… 
09:15:08 <julianleviston> yep.
09:15:20 <julianleviston> but there’s some odd things about it IIRC
09:15:32 <shachaf> Well, there's no "inside".
09:15:35 <nshepperd> so in this case fmap is applying that function to the 'return value' of the (r -> a)
09:16:21 <julianleviston> in which case?
09:16:34 <julianleviston> nshepperd:  >>= isn’t using fmap, is it?
09:16:43 <nshepperd> in the case of ((->) r)
09:16:44 <hackrilege> If I have Just 2 its Werth top say the 2 is inside the Just?
09:16:55 <hackrilege> Wrong to...
09:17:11 <julianleviston> hackrilege: well technically it’s a Num a => Maybe a, I think.
09:17:21 <julianleviston> that’s the actual type of it, right?
09:17:42 <julianleviston> hackrilege: so his point is that a type has no inside or outside...
09:17:43 <nshepperd> julianleviston: well you can define >>= directly, but it is always true that (h >>= f) = join (fmap f h)
09:18:01 <julianleviston> nshepperd:  oh THAT is what you meant about join and fmap. I didn’t know that. Gosh
09:18:24 <julianleviston> nshepperd: I feel like I might need to start at the beginning again… right back at typeclasses
09:18:53 <julianleviston> an algebraic data types
09:18:55 <julianleviston> and*
09:19:17 <L8D> join = (>>= id)
09:19:19 <nshepperd> do you know join?
09:19:26 <CpnStumpy> Typeclassopedia: Because when your soul get's swallowed, you get to enjoy that hollow feeling inside.
09:19:27 <julianleviston> nshepperd: I don’t feel like I know anything
09:19:31 <julianleviston> nshepperd:  but not really
09:19:33 <nshepperd> hehe
09:19:42 <julianleviston> nshepperd:  :) 
09:19:58 <julianleviston> nshepperd:  the feeling is that there’s a limitless expanse
09:20:18 <julianleviston> nshepperd:  watching one of Ed K’s talks just before didn’t help that feeling too much ;-)
09:20:45 <julianleviston> nshepperd: I sat down trying to understand the State Moad tonight… 
09:20:48 <julianleviston> monad*
09:21:10 <Luke> do you guys use SHM with electric-indent-mode turned on or off?
09:21:14 <Luke> the `C-j` behavior depends on it
09:21:15 <shachaf> No expanses spared.
09:21:34 <shachaf> julianleviston: Did you see the FAQ entry on this?
09:21:56 <julianleviston> shachaf: I’m not sure I follow, so… No, I don’t think I did. What is “this”? :)
09:21:57 <shachaf> https://wiki.haskell.org/FAQ#What_should_I_know_before_trying_to_understand_monads.3F
09:22:03 <CpnStumpy> I've so far learned: If you need to derive a monad from behaviours you understand and desire? Usually not too hard. If you want to understand a monad however, don't start with the derivation - start with the behaviours. The actual implementation always takes longer when I don't know the whole semantics yet.
09:22:03 <julianleviston> ah ok
09:22:19 <CpnStumpy> err takes longer to understand rather
09:22:33 <julianleviston> CpnStumpy: yeah, I’m starting to think the best way to approach Haskell is Concrete backwards…
09:22:52 <julianleviston> CpnStumpy:  I guess my trouble is I’m trying to use things that use Lenses, so… yeah :)
09:22:58 <julianleviston> probably stupid of me.
09:23:22 <recursion-ninja> I have a Parsec question
09:23:51 <julianleviston> shachaf: haha it’s funny, but that bullet point is actually a list of my difficulties with Haskell over the past three months, sequentially :-) I *sort of* get most of it.
09:24:13 <nshepperd> I'm starting to understand lenses, it makes me feel happy
09:24:45 <shachaf> What about lenses?
09:24:51 <julianleviston> nshepperd:  when you say understand do you mean their innards?
09:24:52 <dutchie> nshepperd: same! i watched the ed k talk the other day and i think i understood 90% of it
09:24:57 <UberLambda> Is software transactional memory efficient?
09:25:09 <quicksilver> yes.
09:25:14 <recursion-ninja> I have a scenario where I would like to add multiple Messages to the ParseError of the Parsec monad, but I can't figure out how to add multiple Messages. The `fail` function will only add one message and cease the parser context. Is it possible to add multiple Messages somehow?
09:25:25 <UberLambda> but it restarts computations continuosly... right?
09:25:28 <Gurkenglas> Whenever I use something from out of scope, I compile, find out it wasn't used yet in that file, google the identifier and haskell, see what module it's from, and assemble an import statement to be added to the top of my file. Is there a quicker way?
09:25:48 <breadmonster> Hey everyone.
09:25:49 <quicksilver> UberLambda: only in the case of conflicts
09:25:50 <nshepperd> julianleviston: innards and outards!
09:25:51 <julianleviston> UberLambda: only on collisions
09:25:59 <julianleviston> nshepperd:  lol :)
09:26:06 <quicksilver> UberLambda: certainly you can find programs which perform badly because they keep conflicting, but a large class of programs don't.
09:26:11 <UberLambda> quicksilver, julianleviston: but aren't collisions fairly common?
09:26:20 <quicksilver> impossible to generalise IMO
09:26:26 <quicksilver> depends what you are doing in why
09:26:38 <quicksilver> that's like saying "isn't postgresql inefficient because it uses locking?"
09:26:40 <julianleviston> UberLambda: less than the issues you’d have with locks if not using STM on concurrent system
09:26:45 <julianleviston> systems*
09:27:23 <UberLambda> julianleviston: what about actors?
09:27:30 <julianleviston> UberLambda: if you want a great explanation of how awesome STM is, watch one of Rich Hickey’s talks about them.
09:27:38 <julianleviston> UberLambda: what do actors have to do with STM?
09:27:41 <UberLambda> julianleviston: will do
09:27:59 <UberLambda> julianleviston: nothing, just tinkering around different approaches to multithreading
09:28:14 <UberLambda> so far I've seen plain ol' mutex, STM and actor model
09:28:14 * hackagebot active 0.2.0.5 - Abstractions for animation  https://hackage.haskell.org/package/active-0.2.0.5 (BrentYorgey)
09:28:15 <julianleviston> UberLambda: Don’t get parallelism confused with concurrency
09:28:30 <UberLambda> julianleviston: wrong word, yeah
09:29:38 <hackrilege> Does anyone know where I can find a version of typclosdopedia with minimal syntax?
09:29:39 <nshepperd> UberLambda: if by continuously you mean repeating the same thing over and over again, iirc normally we are able to block until we know we can proceed through some magic i don't know
09:29:50 <nshepperd> apparently it's quite efficient
09:29:58 <breadmonster> I still haven't figured out how STM works.
09:30:04 <UberLambda> nshepperd: wait, a mutex?
09:30:09 <shachaf> Well, if no input has changed, you'll get the same output if you retry the transaction.
09:30:15 <UberLambda> breadmonster: we're two then :P
09:30:19 <julianleviston> breadmonster: the book on concurrency is AMAZINGLY good at explaining it
09:30:50 <breadmonster> julianleviston: I mean, I get the abstraction, I'm talking about stuff under the hood.
09:31:41 <quicksilver> nshepperd: yes the STM runtime won't retry a transaction which failed unless one of the TVars it depended on has changed
09:31:44 <quicksilver> (is that what you meant?)
09:32:01 <nshepperd> I think that must be what I'm talking about
09:32:13 <julianleviston> breadmonster: you should take a look at that concurrency book… it explains “under the hood” quite a bit.
09:32:28 <hackrilege> Would anyone be interested in a minimal rewrite of typeclassopedia?
09:32:38 <breadmonster> hackrilege: How minimal?
09:32:40 <nshepperd> I suppose that's not actually relevant to conflicts but either way
09:32:54 <hackrilege> As minimal as possible?
09:33:08 <breadmonster> julianleviston: What is this magic concurrency book?
09:33:33 <julianleviston> breadmonster: http://chimera.labs.oreilly.com/books/1230000000929
09:33:37 <julianleviston> Parallel and Concurrent Programming in Haskell
09:33:56 <julianleviston> it’s by Simon Marlow - one of the guys who wrote a large portion of the concurrency mechanisms in GHC, I think.
09:34:09 <breadmonster> Yay free book!
09:34:18 <julianleviston> Besides being an amazingly well written book, it explains stuff under the hood really well.
09:34:27 <julianleviston> yeah, nice of them to make it available.
09:35:34 <julianleviston> If you want an amusing watch (even though it’s on Clojure, and Clojure has a less good version of STM than Haskell), this video is pretty great - as an explanation of why immutability and STM is great when compared to something like Java or other mutable non-functional programming languages.
09:35:35 <julianleviston> https://www.youtube.com/watch?v=dGVqrGmwOAw
09:36:08 <hackrilege> Thanks
09:36:26 <breadmonster> hackrilege: Tell me what's up?
09:36:52 <hackrilege> Too many words... Lots of superfluous discussion
09:37:18 <hackrilege> I'd say the class definitions and axioms would be sufficient
09:38:25 <breadmonster> julianleviston: Umm, do you mind if I PM?
09:38:33 <julianleviston> breadmonster: sure...
09:38:34 <lodin_> julianleviston: How does the STM in Clojure and Haskell differ (such that Clojure's is worse)?
09:38:44 <hackrilege> E.g. What is a Functor? A kind * -> * datatype with a definition of fmap
09:39:06 <exio4> is it superflous? 
09:39:10 <julianleviston> lodin_:  I don’t know.
09:39:23 <julianleviston> lodin_:  I’d have to find where I read that.
09:39:38 <hackrilege> no, that's my attempt at a minimal definition
09:39:49 <julianleviston> lodin_:  oh here you go : http://www.thattommyhall.com/2013/02/15/stm-clj-vs-haskell/
09:40:30 <julianleviston> lodin_:  Simon Peyton-Jones explains it in his paper for “beautiful code” - that’s what I read (that article links to the paper)
09:41:44 <hackrilege> Does anyone know of a resource detailing t the standard Haskell classes without reams of additional discussion?
09:42:20 <hackrilege> If not, would anybody be interested in one if i were to try and compile it?
09:43:12 <ricochet1k> Like Typeclassopedia?
09:43:27 <hackrilege> Exactly, but minimal
09:43:54 <ricochet1k> I would certainly like to see something like that.
09:43:55 <hackrilege> Probably just the class definitions and the rules
09:44:11 <julianleviston> hackrilege: I’ve often wished for a lot of examples.
09:46:24 <julianleviston> Ok so if I were to just quickly take a stroll through the Monad requirements (https://wiki.haskell.org/FAQ#What_should_I_know_before_trying_to_understand_monads.3F) first class functions are a no-brainer… map uses them. Easy.
09:46:40 <hackrilege> But they cloud progress.. I mean you tire from reading examples of Functor and applicative before getting to monad for example. I don't see why it needs to be such a behemoth, the class definition and rules are sufficient for understanding what is inherited by a subclass, and the examples are often tricky
09:46:43 <julianleviston> type constructors… well data Blam = Blam | Whap is an example of one, right?
09:48:20 <roelof> hello, when ai have some condition then I want to run two other functions. How do I do this? This is not working    | otherwise               = smallerRoots a b c ; largerRoots a b x 
09:48:32 <roelof> I see then a naked expression is found 
09:49:25 <breadmonster_> roelof: What do you mean you want to "run two other functions"?
09:49:25 <julianleviston> roelof roelof what do you mean by “run”? 
09:49:28 <hackrilege> Yes each newline needs a conditional
09:49:30 <julianleviston> type class polymorphism is this, right? [] :: [x]
09:49:54 <julianleviston> roelof:  do you want to join them together?
09:50:05 <hackrilege> You are missing | after the ;
09:50:12 <breadmonster_> roelof: Could we see the whole code?
09:50:16 <breadmonster_> hackrilege: No, I think that's intentional.
09:50:22 <hackrilege> Oh
09:50:22 <EvanR> julianleviston: no
09:50:28 <julianleviston> EvanR: no to?
09:50:34 <roelof> breadmonster:  yes, here you are : http://lpaste.net/141051
09:50:36 <hackrilege> Just no
09:50:37 <EvanR> julianleviston: thats regular polymorphism
09:50:40 <julianleviston> lol
09:50:48 <julianleviston> EvanR:  ah!
09:51:11 <julianleviston> EvanR: then how about Nothing :: Maybe x 
09:51:15 <EvanR> same thing
09:51:18 <julianleviston> Really?
09:51:21 <EvanR> yes
09:51:22 <breadmonster> roelof: You've got it wrong.
09:51:23 <julianleviston> Oh...
09:51:30 <exio4> Eq a => [a] -> Bool
09:51:33 <EvanR> Maybe is a list with at most one element
09:51:36 <breadmonster> julianleviston: None of those involve typeclasses.
09:51:41 <roelof> breadmonster:  I know. But I do not know how to make it right 
09:51:48 <julianleviston> breadmonster: erm.. Maybe is a typeclass isn’t it?
09:51:55 <EvanR> Maybe is not a typeclass
09:51:58 <julianleviston> ah
09:51:59 <breadmonster> julianleviston: No?
09:52:02 <julianleviston> Eq is a typeclass
09:52:06 <breadmonster> @info Maybe
09:52:06 <lambdabot> Maybe
09:52:24 <exio4> roelof: "Maybe Float" can have only zero or one values of type Float
09:52:24 <julianleviston> oh right it’s a polymorphic type.
09:52:25 <breadmonster> That was pointless...
09:52:34 <hackrilege> After the ; is a new line so the stuff after it is basically the start of a new function definition which is not what you have.
09:52:48 <exio4> roelof: if you want to represent "0, 1 or more", you might want a list instead
09:52:53 <breadmonster> roelof: You can wrap them in a list.
09:53:13 <breadmonster> julianleviston: data Maybe a = Just a | Nothing
09:53:18 <Gurkenglas> julianleviston, consider "data ZeroToTwo a = Zero | One a | Two a a". The last two constructors will specify the a, the first one doesn't need to. No typeclasses :D
09:53:20 <roelof> exio4:  oke, so I cannot take care that nothing, 1 solution or 2 solutions are displayed 
09:53:39 <julianleviston> Gurkenglas: ok… it’s polymorphic values… ?
09:53:41 <breadmonster> roelof: Also, you need to stick a `Just` in there.
09:54:00 <julianleviston> no it’s polymorphic types. ok.
09:54:04 <hackrilege> You could return a list
09:54:05 <roelof> breadmonster:  I saw that and changed that already 
09:54:09 <Gurkenglas> @let data ZeroToTwo a = Zero | One a | Two a a
09:54:11 <lambdabot>  Defined.
09:54:17 <Gurkenglas> :t Two 1 2
09:54:18 <lambdabot> Num a => ZeroToTwo a
09:54:28 <Gurkenglas> :t One "asd"
09:54:28 <EvanR> julianleviston: the type of an express may be a particular concrete type or involve variables to stand for some type
09:54:29 <lambdabot> ZeroToTwo [Char]
09:54:30 <Gurkenglas> :t Zero
09:54:31 <lambdabot> ZeroToTwo a
09:54:44 <roelof> or maybe use a tuple 
09:54:59 <exio4> Either (a,a) (Either a ()) ? :D
09:55:04 <EvanR> julianleviston: so you say the type of the expression can be polymorphic
09:55:07 <roelof> Sorry I have to leave for a moment. Dinner is ready 
09:55:08 <breadmonster> roelof: No, I don't think that will work here, unless it's (Maybe Float, Maybe Float)
09:55:19 <hackrilege> (Nothing, Just root)
09:55:32 <Gurkenglas> "Two 1 2" only says about the a that it has a Num instance, since anything with a num instance defines 1, 2, etc.. "Zero" says nothing, thus we know nothing about the type and :t Zero can only say ZeroToTwo a.
09:55:32 <breadmonster> exio4: lol
09:56:27 <hackrilege> The good thing with gurkenglas solution is that you can pattern match depending on how many roots were returned
09:56:40 <julianleviston> So I have no idea what typeclass polymorphism is the
09:56:41 <julianleviston> then*
09:57:02 <Gurkenglas> Me neither. I seldom bother with such terminology.
09:57:05 <hackrilege> Rather than having to examine each element of a type or checking the length of a list.
09:57:15 <EvanR> i havent heard of "typeclass polymorphism" exactly
09:57:31 <julianleviston> Is it like Writer w a ?
09:57:36 <julianleviston> I’m guessing so.
09:57:41 <EvanR> no
09:57:46 <julianleviston> you sure?
09:57:57 <EvanR> Writer w a is some type with no class implications
09:58:16 * hackagebot kure 2.16.12 - Combinators for Strategic Programming  https://hackage.haskell.org/package/kure-2.16.12 (NeilSculthorpe)
09:58:20 <Gurkenglas> If we're gonna speculate, maybe it's something that works for any typeclass, or any typeclass with a given number of parameters
09:58:28 <hackrilege> Did you understand roelof?
09:58:36 <EvanR> Gurkenglas: cool, how do you do that? ;)
09:59:03 <Gurkenglas> I did theorize about something like that once, umm
10:00:12 <Gurkenglas> To make it simple, how about "(* -> Constraint) -> (* -> Constraint)", which takes a one-parameter typeclass and adds, say, "default :: a" to its requirements?
10:00:30 <Gurkenglas> (Where a is the parameter type)
10:00:37 <delYsid> Can anyone suggest a music notation library?  I am writing code to deal with braille music, and before I invent a complete vocabulary for music notation, I'd rather look how experienced people did it, and maybe reuse some of the already existing datatypes.
10:00:44 <EvanR> nice like a row types for classes
10:00:46 <hodapp> gah, this isn't good... getting an "undefined symbol: ionzm0zi3zi0zi0_IvoryziLanguageziIonziSchedule_schedPeriod_info" error when doing a build in stack
10:00:59 <julianleviston> how is this not typeclass polymorphism? class (Monoid w, Monad m) => MonadWriter w m | m -> w where
10:00:59 <hodapp> 'stack clean' didn't remedy anything, nor nuking .stack-work directory
10:01:15 <julianleviston> what does MonadWriter w m mean there?
10:01:29 <ion> julianleviston: The name of the class that is being defined.
10:01:31 <EvanR> julianleviston: MonadWriter is a class
10:01:47 <julianleviston> yeah but m w ? what are they?
10:02:12 <EvanR> class (Monoid w, Monad m) => MonadWriter w m | m -> w where
10:02:21 <EvanR> this is a multiparameter type class with a functional dependency
10:02:29 <julianleviston> ok
10:02:32 <EvanR> and some constraints in the context
10:02:55 <EvanR> Monoid and Monad are other classes
10:02:56 <breadmonster> hodapp: HASKELL HAS BUGS? :O
10:02:58 <ion> julianleviston: They are together parameters corresponding to an instance of the class. The “| m -> w” means that the parameter “m” uniquely determines the “w”.
10:03:13 <Gurkenglas> Oh and here http://lpaste.net/137894 I don't know whether that's complete, it surely doesn't work with that syntax, and it was to make something that allows you to wrap a monad transformer, specifying for each class whether you want to use the instance from the underlying monad or from the transformer
10:03:25 <hodapp> breadmonster: don't know if this is a Haskell bug, a Cabal bug, or a stack bug
10:03:45 <julianleviston> that list at https://wiki.haskell.org/FAQ#What_should_I_know_before_trying_to_understand_monads.3F is a bit cryptic, then
10:03:55 <Gurkenglas> And that one would be an example of nonpolymorphism since you'd have to manually specify the bools for each relevant typeclass
10:04:17 <EvanR> non-polymorphism sounds like a cool feature
10:04:28 <Gurkenglas> It already exists in type families
10:04:31 <geekosaur> doublecheck that that module is listed in either the exported or extra modules in the cabal file?
10:04:47 <Gurkenglas> It's kinda partial functions on the kind level
10:05:01 <ion> julianleviston: What about it do you find cryptic?
10:05:01 <breadmonster> I wonder if compilers can be parallel.
10:05:02 <EvanR> i think were losing julianleviston
10:05:15 <breadmonster> Like while processing the same file. It's an extremely interesting idea.
10:05:21 <julianleviston> EvanR:  nah, I’m beyond being lost. :) 
10:05:37 <EvanR> you should start with some simpler examples while learning haskell
10:05:43 <geekosaur> in some ways it's like zen: bveing confused/lost is the first step to enlightenment >.>
10:05:46 <EvanR> and not jump directly to MPTC
10:05:50 <julianleviston> ion: well, we just had a 5 minutes discussion about parametric typeclasses and no one seems to know what they are, for example :)
10:06:19 <Gurkenglas> breadmonster, sure why not? If you mean parsing, indentiation rules would allow you to do stuff like group the file into top-level definitions by indentation, then parse each in parallel
10:06:32 <julianleviston> EvanR: I have been :)
10:06:36 <julianleviston> EvanR: what’s MPTC?
10:06:42 <exio4> multi param type classes
10:06:46 <julianleviston> oh
10:06:54 <ion> What is the difference between a parametric type class and a type class? Are they not all parametric?
10:07:12 <julianleviston> ion: don’t ask me :)
10:07:18 <EvanR> "parametric typeclass" is not common jargon
10:07:19 <julianleviston> ion:  every time I think I know, someone corrects me
10:07:25 <ion> Oh, it seems a zero-parameter type class is possible.
10:07:27 <julianleviston> EvanR:  and yet, it’s on that site...
10:07:27 <breadmonster> Gurkenglas: I mean optimization.
10:07:46 <EvanR> julianleviston: where?
10:07:52 <julianleviston> EvanR:  https://wiki.haskell.org/FAQ#What_should_I_know_before_trying_to_understand_monads.3F
10:07:58 <EvanR> i dont see it
10:08:01 <julianleviston> EvanR:  that thing we’ve been talking about :)
10:08:06 <julianleviston> EvanR:  type class polymorphism
10:08:20 <EvanR> ok just making sure "parametric typeclass" is not
10:08:22 <julianleviston> EvanR: 3rd bullet point down
10:09:05 <breadmonster> ?info bind
10:09:05 <lambdabot> bind
10:09:25 <EvanR> these bullet points are confusing
10:09:27 <julianleviston> breadmonster: :i (>>=)
10:09:36 <julianleviston> EvanR:  thanks :)
10:09:43 <EvanR> dont try to understand them ;)
10:09:48 <julianleviston> EvanR: lol funny.
10:10:02 <julianleviston> EvanR: someone else just told me I should understand all those things before starting monad.
10:10:05 <julianleviston> monads*
10:10:07 <EvanR> even the title of the section, ignore that
10:10:23 <breadmonster> ?info do { c <- many1 digit; dot <- char '.'; rest <- many1 digit; return . read (c ++ [dot] ++ rest) }
10:10:23 <lambdabot> many1 digit >>= \ c -> char '.' >>= \ dot -> many1 digit >>= \ rest -> return . read (c ++ [dot] ++ rest)
10:10:33 <breadmonster> IT WORKS CHARLIE!
10:10:36 <simon> in quickcheck, even though I have 'quickCheck (within 500000 someProp)', running tests will still sometimes hang at "(0 tests)". is there a way to skip individual tests? neither ^C nor ^D seem to do what I want.
10:10:40 <EvanR> julianleviston: what you need to know is algebraic data types, then you need to know type classes
10:10:55 <julianleviston> EvanR:  I think I have a reasonable handle on those things.
10:10:57 <EvanR> so data Maybe a = Nothing | Just a
10:11:01 <julianleviston> EvanR: but maybe I don't.
10:11:11 <breadmonster> I prefer using combinators instead of do notation.
10:11:22 <EvanR> and class Eq a where
10:11:30 <julianleviston> EvanR: yeah, typeclasses.
10:11:33 <EvanR> (==) :: a -> a -> Bool
10:12:05 <EvanR> before doing Monads you might want to check out Functors first because that is simpler and involves a type of kind * -> *, unless Eq
10:12:08 <EvanR> unlike Eq
10:12:12 <julianleviston> EvanR: I’m even relatively across monads, to at least a small degree… but understanding how ((->) r) is one is beyond me.
10:12:36 <EvanR> do you understand the ((->) r) Functor?
10:12:38 <julianleviston> EvanR: yeah, I’ve looked at Functors about 10 times, Applicative Functors many times… 
10:12:47 <simon> julianleviston, ((->) r) means "functions that take the type r as an argument"... is that complex?
10:12:50 <julianleviston> EvanR: isn’t it just partially applied (->) ?
10:13:03 <julianleviston> simon: no. It’s not complex. 
10:13:06 <roelof>  im back. maybe better use the manuals how to add things to a list
10:13:16 <EvanR> what does fmap do for (r ->)
10:13:20 <simon> julianleviston, i.e. foo :: r -> ...
10:13:28 <julianleviston> simon: but I don’t understand how (>>=) as an instance of Monad on ((->) r) works at all.
10:13:47 <julianleviston> EvanR:  I have no idea what fmap does for ((->) r)
10:13:55 <EvanR> check it out ;)
10:13:58 <julianleviston> EvanR: I probably don’t really even understand what ((->) r) means.
10:14:07 <EvanR> its means r -> _
10:14:15 <julianleviston> EvanR: what is it? Is it a value? no. Is it a type? yes?
10:14:19 <EvanR> its a type
10:14:38 <EvanR> well a type constructor
10:14:46 <EvanR> like Maybe
10:14:49 <julianleviston> frigging nomenclature.
10:14:56 <EvanR> the jargon here is iffy
10:14:56 <julianleviston> ok.
10:15:05 <breadmonster> jargon anywhere is iffy.
10:15:11 <roelof> breadmonster:  can yoiu give a example how I can add the outcome to both functions to a list . I can do smallerroots a b c : outcome but that list does not exist yet 
10:15:13 <julianleviston> I wish I could nail it down.
10:15:23 <EvanR> Maybe Int is a type, Maybe is waiting to be applied to a type to get a type
10:15:32 <EvanR> same with ((->) r)
10:15:36 <julianleviston> EvanR: yeah, But Mabye a is a type.
10:15:40 <EvanR> r -> s is a complete type
10:15:44 <julianleviston> EvanR: it just happens to be parametric, right?
10:15:49 <ion> let “f = (->) r” in “fmap :: (a -> b) -> f a -> f b”: “fmap :: (a -> b) -> (->) r a -> (->) r b”
10:15:50 <julianleviston> EvanR: or “polymorphic".
10:15:52 <EvanR> yes
10:15:56 <EvanR> forall r s . r -> s
10:15:58 <ion> (->) r a = (r -> a)
10:16:13 <breadmonster> roelof: f1 x : f2 x : []
10:16:29 <simon> julianleviston, ((->) r) is confusing for two reasons at least: -> is normally infix, and usually also fully applied. e.g. you never write a function with the type ((->) r), always ((->) r t), where normal people would write that as 'r -> t'
10:16:53 <julianleviston> simon: yeah, I’m good with the infix problem… 
10:17:03 <julianleviston> simon: and the partial application isn’t a problem, either.
10:17:13 <simon> julianleviston, do you mean the fact that it needs to be written nonfix because it's partially applied?
10:17:15 <julianleviston> simon: I just see it as a section, but a polymorphic one.
10:17:21 <simon> julianleviston, so it's just the Monad instance.
10:17:24 <julianleviston> jud: yes.
10:17:28 <julianleviston> simon: yes*
10:17:30 <EvanR> julianleviston: so when you write a Monad or Functor instance you always specify it for a type constructor, one that takes one type argument (not two like (->))
10:17:35 <julianleviston> simon: huh? the Monad instance?
10:17:42 <julianleviston> simon: oh… the thing I’m having problems with. Yeah
10:17:48 <EvanR> so thats why its being specified for ((->) r)
10:17:54 <EvanR> or Maybe, or List
10:17:56 <julianleviston> EvanR:  No idea what you just said, sorry.
10:17:57 <breadmonster> > let x = x in x
10:18:01 <lambdabot>  mueval-core: Time limit exceeded
10:18:02 <breadmonster> What on earth is that?
10:18:03 <simon> julianleviston, you said how (>>=) is defined for ((->) r). that's part of the Monad instance for that type.
10:18:17 <julianleviston> simon: it is.
10:18:17 <breadmonster> How is that in all the GHC libraries?
10:18:20 <breadmonster> o.O
10:19:02 <EvanR> julianleviston: im giving you some ground to stand on, before you have a Monad you have to have something like Maybe or r ->
10:19:05 <Cale> breadmonster: What on earth is what?
10:19:16 <julianleviston> the problem I’m having, if I can be explicit, is that I don’t understand how the definition of (>>=) works… that is, I begin to try to think through what it’s doing, and I get stuck… flummoxed and confused.
10:19:27 <Cale> julianleviston: For which type?
10:19:35 <julianleviston> Cale: huh?
10:19:42 <Cale> julianleviston: (>>=) is defined separately for each choice of monad m
10:19:51 <julianleviston> Cale: have you just arrived?
10:19:53 <roelof> breadmonster:  thanks, this code looks to work : http://lpaste.net/141053
10:19:54 <Cale> So its definition for Maybe is different from its definition for lists
10:19:57 <Cale> julianleviston: yes
10:20:00 <julianleviston> Cale: ((->) r)
10:20:04 <Cale> Ah, okay
10:20:48 <simon> julianleviston, >>= for ((->) r) composes functions that take an extra r as argument.
10:20:48 <Cale> julianleviston: So, you get the idea that in general  x >>= f  should essentially "run" x (whatever that means), getting some result v, and then "run" (f v), yeah?
10:21:20 <Cale> julianleviston: In this monad, "running" a function means applying it to the argument to which the whole function has been applied:
10:21:20 <julianleviston> Cale: yep.
10:21:33 <julianleviston> Cale: your language just confused me
10:21:35 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
10:21:37 <lambdabot>  ("hello","olleh","HELLO")
10:21:47 <julianleviston> simon: also no idea what that means
10:21:56 <EvanR> just doing >>= on the console a few times is probably a good way to get a feel for the instance
10:21:57 <Cale> So, here, y gets bound to  reverse "hello"  for instance.
10:22:14 <julianleviston> Cale: do notation confuses me, too
10:22:16 <julianleviston> Cale: sadly
10:22:32 <Cale> julianleviston: Well, don't try to pick apart what the do notation means in terms of (>>=) yet
10:22:34 <julianleviston> Cale: because I have to translate it into >>= and return in my head, and I get confused.
10:22:47 <julianleviston> Cale: but I don’t have any idea what do means!
10:22:51 <Cale> julianleviston: Just stare at that line and the result and see if you can see why the result is what it is
10:22:54 <julianleviston> Cale: like… where can I use it?
10:23:02 <EvanR> @undo do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)
10:23:02 <lambdabot> id >>= \ x -> reverse >>= \ y -> map toUpper >>= \ z -> return (x, y, z)
10:23:08 <simon> julianleviston, if there were no extra r, 'f >>= k = \x -> f (k x)', or 'f >>= k = f . k', or '(>>=) = (.)'. but there is, alas, apply them with r, too.
10:23:10 <Cale> ^^ this is counterproductive
10:23:12 <julianleviston> Cale: what does do… do?
10:23:27 <Cale> julianleviston: I just want you to see what this monad does, before we go on to implement it
10:23:33 <julianleviston> Cale: like… if sub something in for do, what type or value would that thing be?
10:23:36 <breadmonster> julianleviston: Is Haskell your first programming language?
10:23:48 <julianleviston> breadmonster: no. it’s my like… 10th or something
10:23:56 <EvanR> julianleviston: the type of a do block is the type of the last statement
10:24:03 <breadmonster> For me, it was easiest to think of do like writing Python code in Haskell.
10:24:04 <Cale> julianleviston: do-notation is syntax, it translates in terms of a chain of (>>=)'s
10:24:09 <breadmonster> With the last line being the return.
10:24:20 <julianleviston> Cale: why the last statement then?
10:24:30 <Cale> Which?
10:24:30 <EvanR> thats what getting "returned"
10:24:58 <julianleviston> EvanR: oh yeah, but doesn’t the context imply the monadic value it gets injected back into?
10:25:04 <julianleviston> EvanR: that’s the bit that always confuses me
10:25:07 <EvanR> nope
10:25:10 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello" -- I really just want you to stare at this and the result and just vaguely understand what this code means to start with
10:25:12 <lambdabot>  ("hello","olleh","HELLO")
10:25:23 <Cale> Don't worry about *why* it means that yet
10:25:32 <julianleviston> Cale: yeah, it’s a 3-tuple
10:25:39 <simon> julianleviston, a more verbose version for ((->) r) would be 'f >>= k = \r x -> k (f r) r x'
10:25:39 <julianleviston> Cale: i get it.
10:25:44 <Cale> But you get that each of the functions we're "running" is being applied to the string "hello"
10:25:58 <Cale> and that this   (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z))  is somehow a function
10:25:59 <hodapp> humm... I'm not sure if what I found counts as a GHC bug, even though GHC told me it is
10:26:07 <julianleviston> Cale: yeah but I have no idea why
10:26:09 <hodapp> I had a sorta malformed .cabal file
10:26:12 <Cale> Good
10:26:18 <EvanR> hodapp: unless GHC's ability to identify its own bugs is bugged
10:26:25 <makalu> is there only one set of supported packages in stackage? What if I want to use GHC <7.10?
10:26:42 <EvanR> who debugs the debugger
10:26:44 <joco42_> any idea what might cause this error message ? https://github.com/travisbrown/haskell-cpython/issues/1 - it says ghc panic, report bug
10:26:47 <Xe> EvanR: what if the fact that the compiler works at all is the result of a bug?
10:26:47 <Cale> So, I suppose I could interject a discussion of how the do-notation is translated into (>>=) here
10:26:53 <hodapp> I had left out a module in the .cabal file that needed to be built, but other modules were depending on it
10:26:54 <julianleviston> Cale: I don’t understand how it’s somehow a function, but I guess it has to be… because otherwise we couldn’t pass “hello” to it
10:26:59 <Cale> Well, right
10:27:04 <EvanR> Xe: life is a bug
10:27:17 <hodapp> so was getting things like "undefined symbol: ionzuBJjzzkIj8Jql1J0qInYfxYD_IvoryziLanguageziIonziSchedule_defaultSchedule3_closure" referring to that module
10:27:30 <Cale> Its type must be  String -> a  for some type a because we're applying it to a String, and this lets us infer that the monad in use must be (->) String
10:27:36 <julianleviston> Cale: I assume do notation is basically return with a bunch of >>=’s tacked on
10:27:45 <Cale> Here's how it works:
10:27:49 <julianleviston> Cale: ok. Inference.
10:27:57 <EvanR> hodapp: thats a linker error, maybe your modules were compiled in an incompatible separate way, and redoing the whole process will fix it
10:28:03 <Cale> do { v <- x; <stmts> } = x >>= (\v -> do { <stmts> })
10:28:09 <julianleviston> Cale: that didn’t follow for me though… that it was (->) String
10:28:13 <Cale> do { x; <stmts> } = x >> do { <stmts> }
10:28:14 <hodapp> EvanR: I redid the whole process over and over and over and it didn't fix anything
10:28:19 <EvanR> :(
10:28:23 * geekosaur actually mentioned the missing-module-in-cabal-file thing
10:28:27 <hodapp> geekosaur: wha?
10:28:32 <hodapp> EvanR: did not build until I realized the error in the .cabal file
10:28:32 <julianleviston> Cale: yeah I’ve seen that said about 50 times now… it never sinks in.
10:28:36 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
10:28:41 <geekosaur> [15 17:04] <geekosaur> doublecheck that that module is listed in either the exported or extra modules in the cabal file?
10:28:44 <Cale> do { x } = x -- base case
10:29:00 <hodapp> geekosaur: hah, I see it now
10:29:05 <geekosaur> unfortunately today is calls day so am not especially focused on irc
10:29:13 <hodapp> geekosaur: apparently I'm not either
10:29:31 <Cale> julianleviston: Okay, so the idea is that   x >>= (\v -> f v)   and  do { v <- x; f v }  mean the same thing
10:29:33 <afonso> How do I get the width of a window in gloss?
10:29:38 <afonso> So I can adjust the graphics?
10:30:12 <julianleviston> Cale: Oh god. I always wondered where the x came from in the do. So it’s just basically that the first var on the right of <- can be ANY old thing?
10:30:28 <julianleviston> so do is a function.
10:30:31 <Cale> julianleviston: Well, syntactically, it can be any expression.
10:30:35 <Cale> do is syntax
10:30:51 <julianleviston> Cale: do is :: ((->) r)
10:30:55 <julianleviston> Cale: right?
10:30:59 <Cale> uh, what?
10:31:06 <Cale> do is a keyword
10:31:12 <julianleviston> Cale: what’s the type of do { return x } ?
10:31:15 <julianleviston> oh I’ll find out
10:31:22 <EvanR> its m 
10:31:32 <Cale> If x :: t, then  do { return x } :: m t
10:31:32 <monochrom> do { return x } = return x. type is m a.
10:31:34 <geekosaur> @undo do { return x }
10:31:34 <lambdabot> return x
10:31:46 <julianleviston> man I’m so confused.
10:31:55 <geekosaur> @undo do { x <- v; return x }
10:31:55 <lambdabot> v >>= \ x -> return x
10:31:56 <EvanR> dont listen to me
10:32:00 <monochrom> do is a reserved word not a value. no type.
10:32:19 <geekosaur> :t do 5
10:32:20 <lambdabot> Num a => a
10:32:20 <julianleviston> ok.
10:32:24 <julianleviston> so do is an expression
10:32:31 <julianleviston> it wraps a block called a do block
10:32:32 <EvanR> :t do
10:32:34 <lambdabot> Empty 'do' block
10:32:41 <monochrom> no, that is wrong
10:32:43 <Cale> Yeah, it's an expression form which translates away in terms of (>>=)
10:32:49 <julianleviston> so do { 1 } is 1
10:32:53 <Cale> yes
10:33:13 <Cale> It's a bit of a degenerate case to use do-notation without involving any monad, but yes.
10:33:24 <chreekat> julianleviston: do has no meaning. it is another way of writing some stuff using (>>=) and that's it. It might be helpful to read the section of the report that talks about how to mechanically change a do-block into a big expression interspersed with (>>=)
10:33:45 <exio4> > do { let { x = 42 ; } ; let { y = -42; }; x+y; } 
10:33:46 <lambdabot>  0
10:34:14 <elperdut> julianleviston: this is a great article that gradually introduces do notation - http://slpopejoy.github.io/posts/Effectful01.html
10:34:14 <Cale> heh, that semicolon at the end also isn't needed, but is allowed
10:34:29 <Cale> I'm trying to explain things here though guys
10:34:45 <exio4> Cale: I didn't know :P 
10:34:47 <julianleviston> elperdut:  I’ve read that. Thanks.
10:34:49 * chreekat nods
10:34:56 <julianleviston> I’m not actually a noob. I know it seems like it.
10:35:04 <Cale> julianleviston: Okay, so let's have a look at what (>>=) ought to do in this function monad
10:35:26 <zyxoas> helloness!
10:35:26 <Cale> First of all, what's its type?
10:35:30 <Cale> In general, we have
10:35:40 <zyxoas> :: IO ()
10:35:41 <Cale> (>>=) :: Monad m => m a -> (a -> m b) -> m b
10:35:42 <julianleviston> maybe I should just go re-learn what >>= means in general.
10:35:47 <julianleviston> It’s so freaking annoying.
10:35:53 <Cale> So, if we have m t = e -> t
10:35:56 <geekosaur> it means whatver the monad says it means
10:35:58 <geekosaur> it means
10:35:59 <julianleviston> and I always have a hard time trying to work out WHY I would want to use it...
10:35:59 <Cale> Then in this instance
10:36:01 <geekosaur> :t (>>=)
10:36:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:36:10 <Cale> (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
10:36:11 <julianleviston> yeah. that’s what it means.
10:36:14 <Cale> yes?
10:36:43 <julianleviston> a function that takes a monadic value, a function from normal value to monadic value of a different type and returns a monadic value of the second type… right?
10:36:45 <Cale> Does that type make sense?
10:36:55 <julianleviston> yeah I think so…
10:36:55 <Cale> yes
10:37:40 <simon> what's a more idiomatic way to do '(((==) x) <$> ex) == Right True'?
10:37:52 <dprt> Is there a recommended reasonably efficient and lightweight SAT solver (or bindings to a SAT solver) in Haskell?
10:37:57 <Cale> Now, you could stare at that type carefully enough, and just write out what the definition *has* to be
10:38:25 <Cale> Let's remove some extraneous parens first:
10:38:32 <julianleviston> Cale: I don’t see how to.
10:38:33 <Cale> (>>=) :: (e -> a) -> (a -> e -> b) -> e -> b
10:38:48 <Cale> So, let's say we're given
10:38:51 <Cale> f :: e -> a
10:38:52 <julianleviston> probably because I don’t know what ((->) r) actually means.
10:38:56 <Cale> g :: a -> e -> b
10:38:59 <Cale> x :: e
10:39:08 <Cale> How do we get a result of type b?
10:39:14 <julianleviston> what on earth?
10:39:34 <julianleviston> Cale: ok
10:39:35 <Cale> What's confusing?
10:39:37 <simon> julianleviston, it means 'r -> ?'
10:39:58 <Cale> (->) r is a partial application of the function type constructor (->)
10:40:07 <Cale> (->) r t is the same thing as r -> t
10:40:21 <EvanR> we covered that and julianleviston insisted he got that much
10:40:22 <Cale> So when m = (->) r, we have m t = r -> t
10:40:24 <julianleviston> Cale: no… ((->) 5) is a partial application!
10:40:32 <Cale> what?
10:40:38 <Cale> 5 is not usually a type
10:40:39 <simon> julianleviston, 5 is not a type.
10:40:44 <monochrom> you need a type instead of a value like 5
10:40:50 <julianleviston> oh…. we’re in TYPE land. god
10:40:54 <simon> julianleviston, partial application works for types, too. you probably mostly think of partial application in terms of values.
10:40:55 <Cale> r might be something like String
10:40:59 <julianleviston> seriously haskell syntax is so terrible
10:41:02 <Cale> hm?
10:41:05 <EvanR> -> is the function type
10:41:07 <monochrom> I agree
10:41:20 <julianleviston> I’m not sure how it could be better… but yeh.
10:41:33 <EvanR> i would be ok with (r ->) being syntax
10:41:34 <julianleviston> Cale: anyway
10:41:35 <ARM9> needs more parens
10:41:37 <Cale> yeah
10:41:38 <Cale> anyway
10:41:45 <Cale> f :: e -> a
10:41:50 <Cale> g :: a -> e -> b
10:41:52 <Cale> x :: e
10:42:05 <Cale> If you have those things, how do you get a result of type b?
10:42:16 <Cale> Well, you clearly need to use g
10:42:31 <Cale> and it's asking for a value of type a first
10:42:50 <Cale> So to get a value of type a, we can use f, which is asking for a value of type e
10:42:57 <julianleviston> Cale: just give me a second
10:43:01 <Cale> Thankfully, we have a value x of type e
10:43:06 <julianleviston> Cale: this is really hard
10:43:39 <simon> after 10 languages you'd think applying arguments to functions would be standard :D
10:43:43 <Cale> Eventually this sort of exercise should become automatic for you, so if it's hard, definitely it's a good exercise to do.
10:44:06 <dbushenko> hi all!
10:44:16 <dbushenko> does anyone use latest ghc-mod with stack?
10:44:24 <dbushenko> how to make ghc-mod using it?
10:45:18 <Cale> dbushenko: What kind of interaction between ghc-mod and stack could there possibly be?
10:46:27 <Cale> Oh, it does look like ghc-mod interacts with cabal to some extent, huh.
10:46:29 <julianleviston> Cale: ok...
10:46:30 <julianleviston> Cale: we want ::b, so we need to use g, and we want to apply g to ::a and ::e, (ie g ::a ::e), so, let's get an ::a. We don't have a thing that has an ::a, we have an ::e in x... so I can sub that in (g ::a ::e), becomes (g ::a x), then to get an ::a, we can use f on ::e which is x again. so (g (f x) x)
10:46:50 <mniip> g :: a :: e makes no sense
10:47:01 <Cale> Weird notation, but I understand what you meant.
10:47:03 <julianleviston> simon: that’s not very nice.
10:47:14 <julianleviston> mniip: sorry.
10:47:14 <Cale> mniip: He's using ::a to mean "some value of type a"
10:47:21 <mniip> ah
10:47:24 <mniip> _::a
10:47:25 <julianleviston> mniip: how would you write that?
10:47:35 <mniip> with approriate parenthesing
10:47:46 <julianleviston> simon: the problem I have is with the non-concretization of everything. Function application isn’t hard. The nomenclature is, though.
10:47:50 <Cale> julianleviston: and yes, that is correct
10:47:56 <mniip> > (_ :: moo)
10:47:56 <Cale> julianleviston: So, what is this doing?
10:47:57 <lambdabot>      Found hole ‘_’ with type: moo1
10:47:58 <lambdabot>      Where: ‘moo1’ is a rigid type variable bound by
10:47:58 <lambdabot>                    an expression type signature: moo1 at <interactive>:1:2
10:48:03 <julianleviston> Cale: the trouble is, I don’t understand what any of it means.
10:48:13 <EvanR> julianleviston: f g and x are the terms, a e and b are the types
10:48:15 <julianleviston> Cale: I just mechanically subbed all those values in because you asked me to
10:48:31 <Cale> julianleviston: Yes, that's part of my point, it's unnecessary to understand it in order to calculate :)
10:48:31 <EvanR> just being alphabetic doesn't help keeping them straight but there you are
10:48:32 <julianleviston> EvanR: yeah, but I have to hold all that crap in my brain all the time. It seems stupid.
10:48:43 <Cale> However, let's go back and try to understand the result now
10:48:49 <julianleviston> Cale: okey dokey
10:48:59 <Cale> So, (f >>= g) x = g (f x) x
10:49:11 <julianleviston> Cale: if we made this concrete, I’d understand in a second.
10:49:40 <Cale> In general, (f >>= g) means something like "run f, getting some result v, then run g v, producing its result as the result of the overall computation"
10:49:42 <julianleviston> Cale: yeah, you say that… and I’ve read it a billion times, and worked it out in my head, but I don’t *know* it, or understand what it means.
10:49:49 <aweinstock> > let {f = (+5); g x y = show x ++ " " ++ show y} in (f >>= g) 5
10:49:50 <lambdabot>  "10 5"
10:49:55 <Cale> So, in this case, "run f" means "apply f to x"
10:50:18 <Cale> So we apply f to x, getting some result (f x)
10:50:27 <julianleviston> Cale: where does x come from?
10:50:30 <Cale> then we run g (f x), i.e. we apply that to x
10:50:52 <julianleviston> Cale: yeah, I get it. g (f x) = g . f $ x
10:51:17 <Cale> So it becomes g (f x) x
10:51:18 <aweinstock> julianleviston: (f >>= g) doesn't have the x, it's still a function
10:51:22 <julianleviston> Cale: I know function application.
10:51:31 <aweinstock> :t let {f = (+5); g x y = show x ++ " " ++ show y} in (f >>= g)
10:51:32 <lambdabot> (Num a, Show a) => a -> [Char]
10:51:34 <EvanR> x is the function parameter introduced temporarily as in f x = x + 1
10:51:39 <julianleviston> Cale: what becomes that?
10:51:40 <julianleviston> lol
10:51:42 <julianleviston> I’m so lost
10:52:09 <Cale> The point isn't so much understanding function application, it's understanding that "running" a computation in this monad, i.e. a function, means applying it to the argument to which the whole function has been applied. 
10:52:38 <humanoyd> If I have a list of variables [var1, var2, var3], is there an easy way in aeson to convert that into an js object {var1 : valueVar1, var2 : valueVar2, var3 : valueVar3}?
10:52:41 <julianleviston> Cale: appling what to which argument?
10:53:03 <julianleviston> Cale: the thing I get confused about is knowing what what is.
10:53:06 <Cale> applying the function that we are running, to the parameter of the function we are constructing
10:53:17 <julianleviston> Cale: that’s so abstract
10:53:31 <EvanR> humanoyd: if you have valueVarx in a list, you can just zipWith
10:53:40 <julianleviston> I’m just going to get my tea.
10:53:43 <Cale> Well, it occurs multiple times... so it has to be abstract
10:54:07 <EvanR> julianleviston: theres were several concrete examples of this >>= given
10:54:08 <monochrom> no, it is not abstract, it is just tautological.
10:54:38 <julianleviston> EvanR:  it’s ok. I’m just stupid.
10:54:50 <julianleviston> I’m not going to give up tho.
10:55:06 <EvanR> i would understand the examples first before going on to try to understand it in full generality
10:55:21 <julianleviston> EvanR: what does f x y n mean? just out of interest?
10:55:51 <Cale> Does it help to say that  f x y n  means  ((f x) y) n ?
10:56:19 <julianleviston> Cale: no, that’s just the associativity and currying explicitly stated.
10:56:21 <humanoyd> EvanR: No, I don't have that...I guess a solution to my problem would need to involve TH?
10:56:35 <Cale> julianleviston: Then I don't know what you're asking :)
10:56:46 <julianleviston> Cale: where?
10:56:47 <EvanR> humanoyd: ah the variables are literally the source code variables, yeah no
10:56:50 <julianleviston> Cale: sorry.
10:57:10 <julianleviston> Cale: oh… the question I asked EvanR 
10:57:14 <EvanR> humanoyd: you can of course write it out yourself
10:57:54 <Cale> julianleviston: yeah
10:58:11 <lpaste_> zyxoas pasted “Quipper GHC 7.10 error” at http://lpaste.net/141063
10:58:17 <EvanR> did f x y n pertain to a previous example or something?
10:59:08 <julianleviston> EvanR: no. nevermind.
10:59:51 <zyxoas> Peeps, I'm trying to compile Quipper on GHC 7.10.2. Yes, I know it is not officially supported on GHC 7.10, but I want to see how to fix that (and maybe Cabal-ise it, as well). The error in this paste does not happen on GHC 7.8.* : http://lpaste.net/141063
10:59:51 <breadmonster> Anyone know a good intro to fundeps?
11:00:16 <mattby> Hi, is there a typeclass defining things that can be zipped? Something with a function of the following signature `(a -> b -> c) -> f a -> f b -> f c`, this is obviously the signature of liftA2, but Applicative doesn't have the behaviour of zipping
11:00:25 <zyxoas> Does anyone know fromt he top of their head what changed between 7.8.* and 7.10.* which suddenly causes GHC to emit this error?
11:00:45 <EvanR> mattby: isn't that Foldable?
11:01:23 <mattby> EvanR: why Foldable? :/
11:01:49 <EvanR> can be zipped, I can only imagine that the result is a list, and youd zip by traversing the two arguments list-like
11:02:24 <mattby> EvanR: what about a tree? Trees can be zipped too
11:02:40 <mattby> That's actually where I'm coming from
11:02:41 <EvanR> hmm
11:02:43 <julianleviston> I guess I should do this for Maybe again first, and then try to understand what ((->) r) is
11:03:10 <EvanR> ((->) r) is a type constructor, functions of r
11:03:19 * hackagebot glue-common 0.4.2 - Make better services and clients.  https://hackage.haskell.org/package/glue-common-0.4.2 (seanparsons)
11:03:21 * hackagebot glue-core 0.4.2 - Make better services and clients.  https://hackage.haskell.org/package/glue-core-0.4.2 (seanparsons)
11:03:23 * hackagebot glue-ekg 0.4.2 - Make better services and clients.  https://hackage.haskell.org/package/glue-ekg-0.4.2 (seanparsons)
11:03:25 * hackagebot glue-example 0.4.2 - Make better services and clients.  https://hackage.haskell.org/package/glue-example-0.4.2 (seanparsons)
11:03:26 <EvanR> mattby: traversible?
11:03:32 <mattby> Maybes can be zipped too:  zip Nothing _ = Nothing \ zip _ Nothing = Nothing \ zip (Just a) (Just b) = Just (a, b)
11:03:35 <exio4> MonadZip? :p 
11:03:47 * exio4 hides
11:04:02 <exio4> I have never seen MonadZip being used, either
11:04:05 <EvanR> (a -> b -> c) -> (f a -> f b -> f c) by itself looks like a 2nd order Functor
11:04:12 <julianleviston> I guess mostly I have no idea why I would want to use these things.
11:04:14 <EvanR> 2 arg Functor
11:04:20 <exio4> functor? uh?
11:04:39 <mattby> exio4: that's exactly it!
11:04:50 <exio4> mattby: it doesn't have a lot of instances though
11:04:51 <EvanR> but you can do this with liftA2
11:05:06 <monochrom> I seldom use >>= for ((->) r), too.
11:05:41 <dprt> Is there a good library (implementation or bindings) for SAT solving in Haskell? Google turns up some stuff, but nothing resembling a consensus.
11:06:09 <EvanR> julianleviston: the function monad is good for code golf
11:06:15 <mattby> EvanR: no, liftM2 on lists will apply each fn to each x, I want to match each fn to the x at the same position in the list
11:06:26 <julianleviston> EvanR:  what is code golf?
11:06:29 <EvanR> mattby: use a different instance?
11:06:37 <mattby> EvanR: but this can be extended to any data structure
11:06:52 <mattby> EvanR: I'm not sure the zip-ish instance would respect the applicative laws
11:06:56 <EvanR> julianleviston: getting it as small as possible
11:06:57 <mattby> I'd have to check :)
11:07:18 <julianleviston> jud: getting what as small as possible? 
11:07:21 <Cale> julianleviston: The point of Monad is the same as the point of any abstraction: reuse. There are a fairly large number of things which it is possible to write using just return and (>>=)
11:07:23 <EvanR> well then a class that simply lacks the applicative laws ... ;)
11:07:28 <julianleviston> EvanR: getting what as small as possible?
11:07:33 <EvanR> the code
11:07:40 <julianleviston> EvanR: what/
11:07:49 <Cale> julianleviston: and by abstracting over the definition and behaviour of those two things, we get to reuse all those definitions with any library which defines a monad
11:07:53 <julianleviston> EvanR: the function monad is good for getting “the code” as small as possible?
11:07:55 <EvanR> code golf is an exercise in getting the code to be as small as possible
11:07:57 <julianleviston> EvanR: which code?
11:07:58 <Cale> julianleviston: Consider for example sequence
11:08:07 <Cale> sequence :: (Monad m) => [m a] -> m [a]
11:08:31 <julianleviston> Cale: yeah, I see the point of monads, but I find it difficlt finding a concrete application for them, is what I meant, sorry.
11:08:39 <EvanR> julianleviston: code involving function application in this case... pretty common
11:08:40 <Cale> sequence takes a list of actions in some monad, and somehow glues them together, producing an action whose result is a list of the result of the actions.
11:08:41 <julianleviston> Cale: and I learn only by concrete applications.
11:08:53 <julianleviston> EvanR: sorry I don’t really know what you mean,
11:09:02 <krakrjak> dprt: does z3 fit the bill for you? (hackage package name and open source SMT engine)
11:09:17 <mattby> julianleviston: the function monad (or Reader) is usually used to pass some configuration around
11:09:27 <Cale> So, in the IO monad, this does what you'd expect: give it a list of IO actions, and it acts as a primordial loop of sorts, giving you an IO action which will run each of them in turn, collecting a list of the results.
11:09:34 <EvanR> julianleviston: the function monad >>= is just one of many "combinators" for rewriting expressions in terms of reusable components, you can see many others in the data-aviary package
11:09:43 <mattby> julianleviston: So it's basically a context in which you have always access to some configuration
11:09:47 <EvanR> whether you want to do this in real life is another question
11:09:48 <Cale> In a parsing monad, it will concatenate a sequence of parsers
11:10:17 <julianleviston> mattby: apologies. I know the types of monads and what they’re used for usually...
11:10:29 <Cale> In the list monad, "running" a list means picking an element from it in all possible ways, so it'll take a list of lists, and pick one element from each of them, in all possible ways, collecting the lists of resulting selections:
11:10:35 <julianleviston> mattby:  but the examples people use to teach them are so abstract that I find it very difficult to understand...
11:10:36 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
11:10:38 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
11:11:10 <julianleviston> EvanR: oh… it’s just a combinator? I love combinators
11:11:14 <Cale> In the function monad, "running" a function means applying it to the argument of the whole function, so it will take a list of functions, and turn them into a function whose result is a list:
11:11:23 <EvanR> julianleviston: since you already understand it, then just ignore peoples examples now
11:11:25 <julianleviston> EvanR:  I’ve never encountered them in haskell before tho
11:11:28 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
11:11:31 <lambdabot>  [5,7,10,25,32]
11:11:41 <julianleviston> EvanR: <sigh> man… 
11:11:50 <Cale> julianleviston: Do my examples help?
11:12:08 <Cale> julianleviston: The whole point of monads is that we only have to implement sequence once, and it does all these things
11:12:15 <julianleviston> Cale: sorry not much.
11:12:26 <Cale> julianleviston: Exactly what sequence does will depend on the definition of (>>=) and return for the monad in question
11:12:27 <julianleviston> Cale: yeah, I know the point of monads :)
11:12:36 <julianleviston> Cale: yeah, I get it.
11:12:38 <mattby> julianleviston: so what's the question?
11:12:41 <julianleviston> Cale: the trouble is the application.
11:12:43 <dprt> krakrjak: Z3 looks like it will work (and it has documentation!). Thanks for the recommendation.
11:12:50 <Cale> Well, these are pretty good applications no?
11:12:55 <julianleviston> Cale: no.
11:13:00 <julianleviston> Cale: they’re toy examples.
11:13:09 <krakrjak> dprt: anytime. it just became available as open source this year!
11:13:11 <mattby> julianleviston: the example I gave you is used in every haskell web app
11:13:13 <Cale> If you were solving a puzzle (say, in an AI for a game)
11:13:18 <chpatrick> dprt: check out sbv
11:13:21 <chpatrick> it's really awesome
11:13:34 <chpatrick> you can just pretend you're writing operations on regular values pretty much
11:13:34 <Cale> You might want to try all possibilities for selecting cards from certain piles, say
11:13:38 <julianleviston> Cale: sorting a list of names is an example of a non-toy example of the function sortBy.
11:13:40 <Cale> So sequence in the list monad might be useful
11:13:40 <mattby> julianleviston: you usually have a monad transformer stack including some ReaderT that gives access to some configuration to the whole app
11:13:43 <chpatrick> and then it'll find the ones that satisfy it
11:13:44 <monochrom> every 1-million-line real world project consists of 1 million toy examples.
11:13:53 <julianleviston> mattby:  ok at this point, you’ve done too complex.
11:14:01 * monochrom is a reductionist!
11:14:05 <julianleviston> mattby: I’m trying to be simple! :)
11:14:19 <mattby> I'm not sure whether you're trolling or not
11:14:23 <julianleviston> monochrom: I probably am, too!
11:14:26 <julianleviston> mattby:  I am not.
11:14:27 <EvanR> mattby: I'm pretty sure
11:14:39 <julianleviston> mattby:  but it’s ok. 
11:14:51 <dprt> chpatrick: Thanks. Looking at the page on hackage now...
11:14:54 <julianleviston> apologies for crappying you off if I have.
11:15:12 <julianleviston> I’m honestly just trying to find a simple way to learn all of this stuff so I can rebuild my app using Haskell.
11:15:25 <julianleviston> (because I can’t get there in the current language)
11:15:31 <mattby> julianleviston: give me an example of a practical use of functions that is at the same level as the example of monads you expect?
11:15:36 <julianleviston> (“there” being my intended destination)
11:15:41 <EvanR> what is your current language
11:15:52 <julianleviston> EvanR:  god. don’t ask
11:16:02 <julianleviston> EvanR: rails on the backend, clojurescript on the front end.
11:16:02 <monochrom> I don't think there is a simple way to learn anything.
11:16:10 <julianleviston> monochrom: you’re probably right
11:16:20 <julianleviston> mattby: sure
11:16:24 <julianleviston> mattby: take maybe...
11:16:52 <monochrom> the most efficient way of learning known to our civilization so far is the scientific method, and it is still a lot of work and so fairly slow
11:16:54 <EvanR> rails+clojurescript is very different from haskell so its going to take some work to rethinking things
11:16:55 <julianleviston> mattby:  give me one sec
11:17:02 <julianleviston> EvanR: yes, I know this.
11:17:06 <julianleviston> EvanR: :) thanks :)
11:17:16 <julianleviston> EvanR: I’m not afraid of wosk.
11:17:16 <monochrom> it is also counterintuitive to most people.
11:17:19 <julianleviston> EvanR: work*
11:19:53 <Cale> julianleviston: But you might have a point that sequence isn't that commonly used directly. What is more common is forM, which is effectively a for-each loop (generalised to any monad)
11:21:01 <Cale> julianleviston: forM :: (Monad m) => [a] -> (a -> m b) -> m [b] takes a list of values of type a to iterate over, and a function from values of type a to actions producing results of type b (i.e. a loop body), and it builds an action having as its result a list of the results of each iteration of the loop.
11:21:12 <Cale> julianleviston: and we can build it easily using sequence and map
11:21:37 <Cale> i.e.  forM xs body = sequence (map body xs)
11:22:31 <Cale> julianleviston: For example, in the IO monad, you might write something like   forM [1..5] $ \n -> do print n; x <- getLine; return (n,x)
11:22:51 <julianleviston> mattby: maybe is great because you can encapsulate the idea of a set of values where some of them might not be there. So, say there is a list of pets, and each one has a favourite food. Perhaps one of your pets doesn’t have a favourite food. If you want to see if all of the pets have a favourite food, you can simply monadically chain them together using >>= and the function return, by using sequence_ on the list of May
11:23:13 <Cale> julianleviston: sure
11:23:14 <julianleviston> assuming I’ve got that correct.
11:23:27 <julianleviston> that’s the kind of example I mean.
11:23:29 <Cale> julianleviston: and if you use sequence rather than sequence_, you'll get the list of favourite foods
11:23:56 <EvanR> julianleviston: if you just want to apply a function to a list of Maybe Pet then you can use Functor instead
11:24:00 <julianleviston> you will?
11:24:10 <julianleviston> EvanR: sure. But the example is the point.
11:24:17 <Cale> > sequence [Just 1, Just 2, Just 3]
11:24:18 <lambdabot>  Just [1,2,3]
11:24:24 <Cale> > sequence [Just 1, Just 2, Nothing, Just 3]
11:24:25 <lambdabot>  Nothing
11:24:29 <EvanR> i thought the point was how/why to use monads in general
11:24:32 <julianleviston> EvanR: given that I’m the one learning this, it’s the examples that I don’t have to know what the best use-cases are for each of these things.
11:24:34 <julianleviston> lol
11:24:45 <mattby> julianleviston: that's a good example for Maybe, but each monad instance is to be used in a different situation, so no one will be able to give you the 1 perfect example of why monads are nice
11:24:50 <julianleviston> EvanR: yes, it is… but like I keep saying, I learn best in concrete situations.
11:24:54 <Jakamoko> j
11:25:11 <julianleviston> mattby:  I don’t need one. I just need a few so that I can abstract the semantics.
11:25:27 <julianleviston> mattby:  I realise there’s no one thing that’s good for a general thing. 
11:25:33 <Cale> julianleviston: The trouble with asking questions about monads is that there are too many examples of monads to be very concrete about things. Perhaps you should find examples of monads and ask questions about those.
11:25:49 <Cale> julianleviston: Of course, this function monad is one such concrete instance.
11:25:59 <Cale> But maybe functions are themselves abstract to a degree
11:26:32 <julianleviston> Cale: it’s ok. There’s nothing that says you guys have to help me out in the way I want. :)
11:26:53 <julianleviston> Cale: I was just wondering if there was a good explanation of ((->) r) as a Monad. That’s all! :) lol.
11:26:56 <Cale> Well, we'd like to help you
11:26:58 <julianleviston> that was what I started with :)
11:27:04 <julianleviston> I know
11:27:08 <julianleviston> you guys are lovely
11:27:10 <Cale> You already managed to implement the (>>=) for ((->) r) yourself :)
11:27:19 <Cale> All that's left is return
11:27:22 <julianleviston> Cale: yeah, but I didn’t understand what i was doing :)
11:27:32 <Cale> (and maybe checking the monad laws if you're really keen)
11:27:35 <julianleviston> return is thunk isn’t it?
11:27:40 <Cale> return is const
11:27:44 <julianleviston> oh :(
11:27:49 <julianleviston> hand on
11:27:51 <julianleviston> hang on*
11:27:54 <julianleviston> isn’t const thunk?
11:28:10 <Cale> Thunks are a low level implementation detail of Haskell, and you generally shouldn't be concerned with them -- they're the runtime representation for expressions.
11:28:38 <julianleviston> Cale: a thunk is a function that simply wraps a value.
11:28:45 <Cale> Usually I find that it's better just to think about expressions as being around at runtime and getting rewritten by evaluation though, since it's usually equivalent to the more detailed story about thunks.
11:28:55 <Cale> That's not how we normally use the term here.
11:28:56 <EvanR> julianleviston: if your entire program is using IO, and you want to always have some "global" variables available, for example catCount, dogOutputChannel, and unicornEmailAddress, then you can pass the (IORef Int, Chan Dog, IORef String) around using the function monad to all your functions
11:29:08 <julianleviston> Cale: but nevertheless, that’s what a thunk *is*
11:29:12 <Cale> hm?
11:29:23 <breadmonster> How do I implement the lambda calculus in Haskell?
11:29:47 <Cale> julianleviston: I disagree, simply because that's not the definition which I subscribe to when talking about Haskell.
11:29:47 <EvanR> data Lambda = Lambda :-> Lambda
11:30:27 <geekosaur> julianleviston, in Haskell (almost) any expression involves a thunk, that is how laziness is implemented. the thunk gets replaced with the actual value once that has been forced. so, you kinda have to be careful about defining something as "a thunk" because everything is :)
11:30:30 <Cale> julianleviston: A thunk is not a function at all. It's a pointer to code.
11:30:33 <Cale> At least in GHC
11:30:34 <delYsid> what is :->?
11:30:44 <julianleviston> Cale: ok “value wrapping function” - is that better?
11:30:46 <EvanR> an infix data constructor
11:30:49 <geekosaur> delYsid: user-defined constructor
11:30:54 <Cale> There are a number of possible data structures one could use as thunks.
11:30:57 <mattby> delYsid: What kind of answer are you expecting? Your question s rather broad
11:31:09 <julianleviston> geekosaur: yeah, I know. fair enough.
11:31:13 <Cale> But "function" is quite inappropriate generally, because there's no parameter to be had.
11:31:31 <julianleviston> Cale: ok
11:31:35 <julianleviston> Cale: I give up
11:31:36 <julianleviston> lol
11:31:39 <julianleviston> nothing I say is right.
11:31:48 <julianleviston> it’s all slightly off :)
11:31:48 <DEA7TH_> import Data.Heap tells me that it doesn't exist. Is that normal for the latest Haskell, do I have to use Cabal?
11:32:09 <delYsid> oh, I think I get it.
11:32:16 <julianleviston> what is const?
11:32:23 <EvanR> @src const
11:32:23 <lambdabot> const x _ = x
11:32:37 <julianleviston> const is a function that takes two values, and returns the first one all the time
11:32:37 <breadmonster> DEA7TH_: is this the heap package?
11:32:39 <julianleviston> how about that?
11:32:48 <EvanR> const x _ = x is shorter ;)
11:32:49 <DEA7TH_> breadmonster: yes, according to this https://hackage.haskell.org/package/heap
11:32:52 <Cale> julianleviston: In GHC, thunks are pointers to code which, the first time the code is entered, will compute some value before rewriting the pointer to point at a shorter piece of code which immediately returns the already-computed value.
11:33:04 <julianleviston> Cale: yeah, it’s cool. I know what they are. Thanks.
11:33:13 <geekosaur> DEA7TH_, ghc comes with onbly the libraries it needs directly. if you install haskell-platform or stackage lts then you get a bunch more libraries
11:33:13 <breadmonster> DEA7TH_: `import Data.Graph.Inductive.Internal.Heap`
11:33:16 <breadmonster> That should fix it.
11:33:19 <delYsid> Oh, @src!!! Do I get that for GHCi as well?
11:33:36 <DEA7TH_> Could not find module ‘Data.Graph.Inductive.Internal.Heap’
11:33:37 <geekosaur> only with goa
11:33:44 <DEA7TH_> ah ok, I'll use cabal then
11:34:04 <julianleviston> Cale: at least, I have an intuition of what they are, I should say.
11:34:11 <geekosaur> ("ghci on acid", which hooks a local lambdabot into ghci. also note that @src is a hand-built database, incomplete, and occasionally lies)
11:34:15 <EvanR> julianleviston: something youll probably pick up doing haskell is thinking about and describing things with excruciating precision ;)
11:34:17 <breadmonster> DEA7TH_: Yeah, first run `cabal install heap`
11:34:30 <breadmonster> DEA7TH_: You also got the module import wrong.
11:34:31 <julianleviston> EvanR: it makes getting anywhere a long and arduous process some times :)
11:34:45 <EvanR> if you spell it all out in english yeah
11:34:52 <julianleviston> EvanR: I’d *like* to be able to be correct about things, but a lot of the time, Haskellers themselves can’t seem to agree on things.
11:35:01 <EvanR> good
11:35:06 <EvanR> i hate it when everyone agrees
11:35:14 <julianleviston> EvanR: I don’t! :0
11:35:19 <julianleviston> EvanR: just kidding, I do, too ;-)
11:35:33 <delYsid> geekosaur: ah, I see, thanks.  I was sort of hoping the platform could do that, sort of what Emacs does with elisp.
11:36:04 <delYsid> I'd *really* like to have a simple way to jump to definitions of things outside of my own project.
11:36:12 <fryguybob> breadmonster: If you have questions about Haskell's STM implementation I'm happy to dive into the details.
11:38:07 <geekosaur> delYsid, you can generate or install documentation for things and use a local hoogle to jump to docuemntation; IIRC haskell-mode and the various vim, sublime text, etc. extensions for haskell know how to use a local hoogle
11:38:20 <julianleviston> I keep seeing, alternatingly, people saying IO is a Monad and “IO is not a Monad!”
11:38:31 <EvanR> IO has a monad instance
11:38:35 <julianleviston> Would I be right in saying “IO forms Monad”?
11:38:37 <EvanR> and a functor instance
11:38:39 <EvanR> among others
11:38:42 <julianleviston> has...
11:38:47 <julianleviston> why has?
11:38:50 <geekosaur> IO is a monad. what people are saying is that the Monad-ness of IO is not what makes IO IO
11:39:02 <DEA7TH_> cabal solved my problems
11:39:03 <geekosaur> which is a common misunderstanding
11:39:12 <julianleviston> IO instantiates the Monad typeclass… could I say that?
11:39:12 <breadmonster> fryguybob: Can I PM?
11:39:24 <julianleviston> geekosaur: ah, ok. cool :)
11:39:29 <fryguybob> breadmonster: Sure
11:39:51 <Sonolin> geekosaur: what does make IO IO? Lots of forking of external side effects? :)
11:39:52 <dolio> geekosaur: The monad-ness is what makes IO IO, though, instead of an unparameterized IO type which would make more sense as a closed, top-level program. :)
11:39:55 <julianleviston> geekosaur: IO is just IO because that’s what it’s tagged as, isn’t it? If it was tagged as “BLERG” we’d all be tagging our prints with that.
11:40:34 <julianleviston> dolio:  I thought the monad-ness was what allowed IO to be sequenceable and composable?
11:40:39 <EvanR> IO is an abstract type for building programs to interact with the runtime system
11:41:21 <EvanR> you can do the building with >>= or <*> or fmap or...
11:41:25 <ReinH> julianleviston: the monad-ness gives an interface for IO's sequenceability and composability.
11:41:47 <julianleviston> ReinH: yeah, just what I said, isn’t it?
11:41:50 <ReinH> If (>>=) were replaced with a function then :: IO a -> (a -> IO b) -> IO b, it would still suffice
11:41:58 <geekosaur> you can accomplish both without the monad. the monad *is* used for sequencing, as a convenience, but does not have to be. the isolation of impurity is not particularly related to its Monad instance
11:42:00 <ReinH> julianleviston: No, subtly different from what you said in an iportant way
11:42:04 <ReinH> *important
11:42:07 <julianleviston> ReinH: how?
11:42:19 <ReinH> julianleviston: The monad-ness doesnt "allow it. It would still be composable.
11:42:37 <ReinH> The monad-ness is what we use to provide an interface, the composability is built into IO
11:42:39 <julianleviston> ReinH:  oh? how?
11:42:59 <ReinH> a function then :: IO a -> (a -> IO b) -> IO b would work just as well, and not require Monad
11:43:16 <dolio> julianleviston: Monads are expression trees with variables that you can substitute into. But there is no reason for the top-level IO description to be run for a program to have open variables. You only need the variables when you are building up programs out of components nicely.
11:43:21 * hackagebot errors 2.0.1 - Simplified error-handling  https://hackage.haskell.org/package/errors-2.0.1 (GabrielGonzalez)
11:43:29 <geekosaur> unfortunately I suspect this discussion is making julianleviston's point...
11:44:04 <julianleviston> geekosaur: I’m not bound to my point, really.
11:44:14 <EvanR> i like dolios de-railment ;)
11:44:16 <julianleviston> geekosaur: I’m not so sure it’s a problem that there’s no agreement.
11:44:40 <geekosaur> well, much of this is just varying levels of pedanticism
11:44:48 <julianleviston> dolio: so you’re saying it’d be composable, but you just couldn’t compose things with it, because there’d be no interface to it? lol
11:44:53 <julianleviston> geekosaur: true.
11:45:03 <ReinH> geekosaur: I think it's an important point
11:45:14 <julianleviston> geekosaur: which is probably why I have such a tricky time of it - because I’m so frigging pedantic
11:45:22 <geekosaur> julianleviston, it would provide its own interfrace instead of reusing Monad for it
11:45:33 <julianleviston> geekosaur: ahhhh gotcha!
11:45:43 <julianleviston> geekosaur: so it’d be non-generally composable
11:45:47 <geekosaur> in fact early Haskell I/O worked that way, proividing a list-based interface
11:45:48 <julianleviston> geekosaur: :D
11:45:56 <julianleviston> geekosaur: that’s cool :)
11:45:58 <ReinH> julianleviston: Right, and having a general interface for this sort of thing is why Monad exists.
11:46:06 <julianleviston> geekosaur: I mean cool that we have Monads in IO
11:46:12 <ReinH> otherwize you'd have thenIO, thenMaybe, thenState, etc
11:46:14 <julianleviston> and that IO has a monadic interface.
11:46:16 <dolio> julianleviston: I'm saying that having 'getChar :: IO Char' and '(>>=) :: IO a -> (a -> IO b) -> IO b' is a nicer interface for composing things than 'getChar :: (Char -> IO) -> IO' and whatnot
11:46:19 <kadoban> julianleviston: I think the thing you're probably talking about above is pushback against calling it "the IO Monad" at every point in time. Some people tend to call it that even when discussing IO without any regard at all to Monad or the Monadic interface, which comes off to others as a little weird.
11:46:46 <julianleviston> kadoban: ah right.
11:46:54 <julianleviston> kadoban: yeah, it seems to be that there’s a lot of misunderstanding
11:47:06 <julianleviston> kadoban: but there probably needent be.
11:47:28 <dolio> But IO is a monad precisely because of this, and not because I/O is a monad. IO is a monadic type of open I/O expressions that is more convenient to use than closed I/O expressions.
11:47:31 <ReinH> julianleviston: There's a lot of miscommunication about monads, much of it from people who learned about monads yesterday and wrote a tutorial today.
11:47:35 <julianleviston> dolio:  yep!
11:47:45 <julianleviston> ReinH: yeah...
11:48:08 <julianleviston> ReinH: they’re very simple. Just a tuple of return, >>= and a constructor, right?
11:48:11 <EvanR> julianleviston therefore I'm looking forward to your monad tutorial
11:48:15 <ReinH> julianleviston: and they often use imprecise or confusing ways of talking about monads, so there's something of a reaction towards more precision (and pedantry).
11:48:17 <julianleviston> ReinH: it’s all the ramifications that make them tricky, I guess
11:48:23 <exio4> you're missing the axioms/laws
11:48:24 <julianleviston> EvanR: haha I’ve already written one
11:48:28 <julianleviston> EvanR: it’s for myself.
11:48:30 <EvanR> nice
11:48:34 <julianleviston> EvanR: no way I’m showing that to ANYONE
11:48:36 <julianleviston> EvanR: lol
11:49:04 <julianleviston> EvanR: but I haven’t even gotten to Monads yet. It turned into a general set of notes about Haskell for myself.
11:49:19 <broma0> I have a function 'f :: M a'. How can I lift(?) it so that the following
11:49:20 <broma0> works: 'g :: P (N (M a)), g = transform f' where transform does the lifting?
11:49:22 <julianleviston> EvanR: It was part of how I realised I don’t really understand what they mean
11:49:32 <simon> is there a way for quickCheck to skip a test manually?
11:49:33 <ReinH> broma0: What are P, N, and M?
11:49:43 <monochrom> in fact I explain IO by putting back getChar and >>= together. I only explain one single piece (getChar >>=), not getChar and >>= separately.
11:49:58 <broma0> ReinH: well M is a parser i wrote, N is StateT and P is ExceptT
11:50:11 <monochrom> http://www.vex.net/~trebla/haskell/IO.xhtml
11:50:21 <ReinH> broma0: Sounds like you want lift.
11:50:31 <broma0> ReinH: newtype MyParser a = ExceptT ParseError (StateT ParseState BasicParser) a
11:50:44 <ReinH> You should make MyParser an instance of MonadTrans
11:50:47 <broma0> and I need to call a 'BasicParser a' inside my stack
11:50:48 <GLM> What is the best way to combine two seperate types?
11:50:59 <broma0> ReinH: that's what i figured..
11:51:04 <ReinH> I think you can do so with GeneralizedNewtypeDeriving
11:51:15 <broma0> ReinH: Ill try.. 
11:51:19 <ReinH> which will also let you make MonadError and MonadState instances
11:51:23 <ReinH> which may be useful
11:52:10 <broma0> ReinH: a MonadTrans  of what though? 
11:52:16 <broma0> ReinH: MonadTrans (StateT ..)?
11:52:43 <julianleviston> Ok thanks for your patience everyone… ! bye.
11:52:51 <broma0> GLM: Product type? data A = { aB :: B, aC :: C} ?
11:52:51 <julianleviston> talk to you soon :)
11:53:07 <ReinH> broma0: of MyParser
11:53:15 <broma0> GLM: data A = A { aB :: B, aC :: C} rather
11:53:56 <GLM> broma0:No. I want something that combines all the possible values of two Types. For example, I have IOErr and RESTErr which I want to combine into ReallyBadErr
11:54:02 <broma0> ReinH: huh? newtype MyParser a = MyParser { ... } deriving (MonadTrans MyParser)?
11:54:10 <ReinH> deriving MonadTrans
11:54:27 <ReinH> if you can't drive it, the instance is lift = MyParser . lift . lift
11:54:29 <ReinH> *derive
11:54:33 <EvanR> GLM: so Enum instances for both
11:54:58 <broma0> ReinH: cannot derive well kinded instance of form 'MonadTrans (MyParser ...)'
11:55:00 <GLM> EvanR:What would the syntax for that be like?
11:55:12 <TheRedPepper> hello
11:55:14 <ReinH> broma0: Ok, just write it yourself then
11:55:55 <kristof> Hi, I've got a serious question performance and compilation.
11:56:17 <broma0> ReinH: never written a MonadTrans instance before.. Ill see if i can figure it out, thanks.
11:56:19 <EvanR> > [(x,y) | x <- [toEnum 0 ..], y <- [toEnum 0 ..]] :: [(Char, Bool)]
11:56:21 <lambdabot>  [('\NUL',False),('\NUL',True),('\SOH',False),('\SOH',True),('\STX',False),('...
11:56:26 <kristof> I think it's very fair for people to look at immutable semantics and go "wouldn't mutability be faster?"
11:56:38 <ReinH> broma0: it's literally just what I said
11:56:48 <ReinH> instane MonadTrans MyParser where lift = MyParser . lift . lift
11:57:04 <broma0> :r
11:57:10 <broma0> ha, not ghci :
11:57:15 <kristof> But my understanding is that, at least on LLVM and many advanced compilers, the AST is always converted to some kind of SSA or continuation passing style anyway, so in essence even mutable, imperative languages are being translated to a purely functional programming language.
11:57:30 <ReinH> *instance
11:57:47 <kristof> And because that form is so easy to analyze, the compiler can go around and do optimizations and make things mutable where it makes sense and make them immutable where it does not
11:57:55 <EvanR> did GLM leave
11:58:25 <kristof> So my question is, is my analysis correct? Is mutability really, purely semantic, and the compiler doesn't give two shits either way?
11:58:51 <broma0> ReinH: I can't write that instance.. MyParser is 'newtype MyParser = MyParser { unParser :: ExceptT E (StateT S BasicParser) a }'
11:58:55 <chpatrick> kristof: I would agree
11:58:58 <broma0> ReinH: do you mean write the instance for BasicParser?
11:59:02 <chpatrick> on the machine level registers are mutable
11:59:17 <ReinH> broma0: No, your monad is MyParser. Why can't you write the instance?
11:59:20 <chpatrick> but even in C the relationship between variables and registers/memory is vague
11:59:23 <EvanR> registers are being mutated consantly by haskell programs, impure!
11:59:33 <ReinH> your monad transformer is MyParser, rather
11:59:43 <broma0> ReinH: so my stack is backwards..
11:59:46 <chpatrick> every language runs on some semantic machine
11:59:53 <chpatrick> apart from assembly :)
11:59:55 <broma0> ReinH: the error i'm getting is as follows
11:59:56 <broma0> The first argument of ‘MonadTrans’
11:59:56 <broma0>       should have kind ‘(* -> *) -> * -> *’,
11:59:56 <broma0>       but ‘Parser’ has kind ‘* -> *’
11:59:56 <broma0>     In the instance declaration for ‘MonadTrans Parser’
11:59:57 <ReinH> broma0: why?
12:00:00 <kristof> chpatrick: Right, but in Haskell when I write op :: Data -> Data, I'm creating a "new value"
12:00:02 <EvanR> chpatrick: even assembly, even machine code
12:00:07 <chpatrick> yeah true
12:00:12 <chpatrick> there's microcode in the cpu
12:00:28 <EvanR> no such thing as bare metal anymore
12:00:28 <kristof> chpatrick: But only semantically. If I really only change a field and nobody holds a reference to the first value, it will mutate the bits in place
12:00:34 <EvanR> its semantics all the way down
12:00:34 <chpatrick> so in a sense you never have direct control over mutating the hardware
12:00:39 <chpatrick> it's always up to the compiler
12:00:45 <ReinH> broma0: Oh. The probem is that your monad transformer is monomorphic
12:00:50 <chpatrick> or some part of the abstraction stack
12:00:57 <ReinH> So you can't write an instance for MonadTrans. You would need to write your own lift function.
12:01:05 <ReinH> It's still MyParser . lift . lift though
12:01:15 <chpatrick> kristof: I don't know when haskell is smart enough to do that tbh
12:01:24 <chpatrick> I don't even know if it has that optimization
12:01:39 <EvanR> kristof: a records fields will never get mutated in place
12:01:44 <chpatrick> it's probably more on some lower-level
12:01:53 <chpatrick> once the haskell gets compiled down
12:02:02 <ReinH> broma0: you have a fixed base monad, so your newtype has the wrong kind.
12:02:26 <kristof> EvarNever?
12:02:39 <kristof> EvanR: Never?
12:02:53 <EvanR> kristof: when a record is updated, a new slab of memory is allocated and the program scribbles the proper data into it
12:03:10 <kristof> :/
12:03:12 <EvanR> allocation is haskell is efficient
12:03:15 <EvanR> its not like malloc
12:03:22 <chpatrick> EvanR: I was wondering about that actually
12:03:23 <kristof> Right, because of arenas and gc and all that
12:03:30 <broma0> ReinH: got it. Thank you! Think I should opt for the more general solution and get rid of the fixed base monad?
12:03:40 <chpatrick> why is it so much more efficient?
12:03:48 <EvanR> you have to worry more about gc than allocation
12:03:56 <EvanR> or have infinite memory
12:04:25 <kristof> EvanR: Right, so if I have a pipeline that bangs on a piece of data a lot, I'll be creating a lot of garbage?
12:04:33 <EvanR> not necessarily
12:04:36 <hodapp> hummmm... does something exist which somehow turns function composition into something monadic?  I have a bunch of things that have to look like "foo $ bar $ baz $ quux ..." after some changes I've made
12:04:40 <hodapp> embedded inside another monad
12:04:42 <chpatrick> EvanR: is newPinnedByteArray better than malloc?
12:04:56 <EvanR> kristof: very emphemeral data you keep banging on will be collected in the first generation
12:05:04 <kristof> Ah, right, generational.
12:05:05 <EvanR> as long as its small enough
12:05:43 <ReinH> broma0: I would.
12:06:01 <ReinH> broma0: you can use a type synonym to fix the base monad
12:06:11 <ReinH> but this lets you write a bunch of instances for useful things
12:06:59 <kristof> If I have a very large structure that I want to tweak slightly, then it is probably better to use ST then, yeah?
12:07:05 <EvanR> chpatrick: no idea, but your warm cuddling types like Int, Bool, records won't be pinned
12:07:20 <monochrom> GHC's heap allocation is merely one arithmetic comparison and one pointer increase, if the heap still has space.
12:07:27 <chpatrick> EvanR: I ask because I'm writing bindings to a library that uses pass by value
12:07:40 <chpatrick> and currently I'm copying things onto the heap to pass into haskell
12:07:58 <chpatrick> would it better to pass in a pointer to a mutablebytearray allocated in haskell?
12:08:05 <EvanR> kristof: so very large records are probably bad, and splitting it into levels will make it more efficient, ST wont save you from the scribbling behavior i described
12:08:08 <kristof> monochrom: ...I don't know much about garbage collectors but I'm wondering how fragmentation is handled.
12:08:12 <monochrom> of course, the complexity is shoved to garbage collection instead, who is now obliged to do compaction.
12:08:23 <kristof> ah, ok
12:08:28 <broma0> ReinH: would it just be 'newtype Parser a = Parser (ExceptT E (StateT S m)) a'?
12:08:51 <EvanR> chpatrick: depending on the needs of the bindings, it will be simpler and safer to copy it back and forth
12:09:01 <monochrom> this brings us to newPinnedByteArray. over-use of pinned memory is clearly harmful to this scheme.
12:09:05 <fvgvxmpv1> broma0: what is this 'm', you speak of?
12:09:08 <EvanR> but theres ways to speed it up at the expense of headache
12:09:15 <chpatrick> well that's the thing, it's very easy to just copy stuff on the heap in C and manage it with a foreignptr in haskell
12:09:17 <ReinH> broma0: Parser m a
12:09:17 <frerich> Does anybody have experience with performing multiple SQL queries in parallel via a single connection -- does that work? E.g. via async + mysql-simple? I don't even know whether the database can handle that.
12:09:27 <chpatrick> I don't want to write a storable instance since the types are opaque
12:09:38 <EvanR> chpatrick: if haskell isnt looking at it all then yeah
12:09:47 <broma0> ReinH: i see, and following idiomatic naming i should call it ParserT m a 
12:09:47 <chpatrick> but would it be better to put them on the haskell heap instead
12:09:49 <chpatrick> rather than malloc
12:09:53 <jle`> EvanR: i feel like that kind of behavior isn't a part of haskell...it might be an implementation detail
12:09:55 <ReinH> broma0: Probably.
12:09:55 <jle`> of the compiler/runtime environment
12:09:57 <L8D> frerich: with a library like Hasql, you can do pooling very easily
12:10:07 <EvanR> jle`: yeah
12:10:09 <broma0> fvgvxmpv1: ReinH answered, it hsould have been PArser m a
12:10:28 <ReinH> frerich: Well, if you only have one connection...
12:10:29 <L8D> frerich: if there is one connection, then it forms a queue when multiple transactions/queries are run concurrently
12:10:35 <EvanR> chpatrick: for opaque objects that matter only to the C lib, keep it in C
12:10:53 <jle`> haskell compilers can definitely re-write record fields in-place during evaluation as long as it gives the same semantics
12:11:05 <monochrom> therefore, if you trust your presumption and use pinned memory "just for speed" (as opposed to legitimate uses such as shared memory between C and Haskell), you will be disappointed. it is harmful to speed.
12:11:14 <jle`> hodapp: how do you mean 'turn function composition into something monadic'?
12:11:17 <ReinH> Haskell compilers *can* do anything they want as long as it gives the same semantics :p
12:11:33 <jle`> my point :)
12:11:36 <monochrom> all presumptions you obtained from most C compilers are going to be wrong. GHC does pretty opposite things.
12:11:37 <EvanR> jle`: yeah but its good to know how it will happen in real life in case it matters ;)
12:11:49 <jle`> there are real haskell compilers that re-write record fields
12:12:06 <EvanR> like who
12:12:09 <kristof> ReinH: But not bang on ephemeral, large records mutably.
12:12:10 <jle`> i can imagine a human haskell compiler+runtime environment that keeps memory on paper and pencil
12:12:12 <monochrom> for example, most C compilers shove all complexity to malloc, while making free trivial
12:12:28 <hodapp> jle`: I'm trying to figure it out exactly - but I'd like, for instance, if I could turn that given thing to foo >> bar >> baz >> quux
12:12:28 <jle`> and they use an eraser to erase and rewrite memory if they deem that the old memory is not needed anymore
12:12:40 <monochrom> (I would do that too, for C.)
12:12:57 <hodapp> jle`: and I'm trying to think through whether this would be idiotic and nonsensical, and whether it's already implemented
12:13:02 <kristof> Something like Clojure's "transients". "If a mutation falls on a value and nobody is around to see it, is it really mutable?"
12:13:06 <monochrom> (since C doesn't allow anyone to do meaningful garbage collection anyway)
12:13:09 <EvanR> jle`: good points, not that anyone would want to evaluate haskell that way on paper
12:13:27 <jle`> they're allowed to ^^
12:13:37 <jle`> but it's probably very useful to talk about GHC and how GHC does things
12:13:55 <hodapp> something tells me this is basically State in some form.
12:14:22 <EvanR> kristof: right, this is ST in haskell
12:14:25 <jle`> you can use State, but then it only works on monomorphic values
12:14:27 <EvanR> (GHC!!!)
12:14:31 <jle`> so your functions can't change the type
12:14:41 <jle`> you can also use Writer with Endo, but...still your functions can't change the type
12:14:53 <EvanR> jle`: theres the indexed monads
12:14:56 <hodapp> jle`: that I don't think is an issue
12:15:44 <jle`> > let tell' = tell . Endo in execWriter (tell' (+2) >> tell' (*3) >> tell' (^2)) 5
12:15:45 <lambdabot>      Couldn't match type ‘a1 -> t’ with ‘Endo a0’
12:15:46 <lambdabot>      arising from a functional dependency between:
12:15:46 <lambdabot>        constraint ‘MonadWriter (Endo a0) (WriterT (a1 -> t) Identity)’
12:15:55 <jle`> :(
12:16:02 <jle`> oh
12:16:35 <jle`> > let tell' = tell . Endo in appEndo (execWriter (tell' (+2) >> tell' (*3) >> tell' (^2))) 5
12:16:37 <lambdabot>  77
12:16:54 <hodapp> jle`: hm, so Endo would let me string together composition as a monoid, and then Writer wold turn that mappend to >>?
12:16:59 <jle`> yeah
12:17:07 <jle`> this is definitely an abuse of monads though
12:17:13 <jle`> because you can just use <> instead of >>
12:17:30 <EvanR> it makes sense to use writer for this
12:17:33 <jle`> but it allows you too abuse do notation.  this trick is used in a lot of libraries...like blaze
12:17:37 <Welkin> something I found amusing in SQL is that <> mean /=
12:17:42 <Welkin> means*
12:17:46 <hodapp> jle`: yeah, abuse of 'do' notation is an aim here
12:17:59 <hodapp> and I'm already using Writer so perhaps I could just shoehorn it in there if I could do it responsibly..
12:18:09 <monochrom> jle`: a few days ago I read an article mentioning "you could use paper for memory. but then if you do this for ackermann, that will put stress on the forestry industry"
12:18:11 <jle`> yeah, the trick of using Writer to let you replace <> with newlines is fairly common, but it's definitely frowned upon by many
12:18:33 <jle`> monochrom: was it the IRP eso language that was posted in this channel the other day? :)
12:18:52 <monochrom> yes
12:19:03 <jle`> hodapp: after all if you are willing to just use <>, then might as well just use ., heh
12:19:16 <jle`> you can have something very do-block like with (.)'s preceding each line
12:19:37 <EvanR> jle`: what, you mean execWriter is abuse, otherwise you cant return a value or use monad utilities to decide what to append
12:20:03 <monochrom> Welkin: it is also in BASIC. and I bet Fortran. I think Pascal too.
12:20:09 <jle`> EvanR: using Writer when you only have tell's is an abuse of monad, because you're basically just chaning (a,()) -> (a,())'s
12:20:11 <EvanR> the usual writer of [LogLine] isn't abuse
12:20:17 <jle`> in which case you can just use `<>`
12:20:26 <monochrom> basically most 1970 languages, and so SQL too
12:20:36 <EvanR> nothing but tells doesnt make too much sense
12:20:39 <jle`> any Writer where you basically just tell tell tell and never use any return values is just <>'s, except badly associated
12:20:56 <jle`> EvanR: it doesn't; but that's exactly what is being proposed to hodapp , heh
12:21:01 <jle`> and it's also what libraries like blaze, etc. do
12:21:07 <jle`> it's a very common usage pattern for Writer
12:21:12 <EvanR> o_O
12:21:33 <m_rad> Hello everyone I have a question, in haskell when I do 1:2:3:4:...:n:[] how many operations are done, cause this seems to me as O(n^2) but somehow it works very fast
12:21:44 <jle`> the basic motivation is that it lets you replace <>'s with newlines in a do block
12:21:59 <EvanR> you replace <> with \ntell
12:22:04 <chpatrick> m_rad: traversing the whole list is O(n)
12:22:27 <m_rad> but well I am talking about the insertions
12:22:27 <chpatrick> why would that be O(n^2)
12:22:28 <EvanR> m_rad: just 1:2:3:4:[] isnt any operations, thats already the answer
12:22:31 <jle`> mhm.  but for libraries like blaze, the tell is absorbed...that is, instead of offering the w's they offer the (w, ())'s
12:22:33 <chpatrick> it's not inserting though
12:22:47 <chpatrick> (:) constructs an object that points to a value and the rest of the list
12:22:51 <EvanR> m_rad: to print it out, you traverse the list and output a char for each node
12:22:53 <chpatrick> that's O(1)
12:22:59 <monochrom> m_rad: it is at most O(n).
12:23:01 <jle`> m_rad: if you're allocationg 1:2:3:[], first it allocates []. then it allocates a 3 cell, which has a pointer to the already-alocated []
12:23:09 <m_rad> ahaa
12:23:14 <jle`> m_rad: then it allocates the 2 cell, which points to the already-allocated 3
12:23:17 <m_rad> too bad I was assuming it's an array
12:23:18 <EvanR> wat
12:23:20 <monochrom> 1 : (2 : (3 : []))
12:23:21 <ReinH> jle`: eh?
12:23:24 <jle`> then it allocates a 1-cell, which points to an already-allocated 2 cell
12:23:34 <chpatrick> well not exactly right?
12:23:35 <EvanR> no no no
12:23:39 <ReinH> 1 : 2 : 3 : [] creates a thunk.
12:23:39 <chpatrick> it allocates 1 : <thunk>
12:23:42 <m_rad> yeah it's a linkedlist somehow
12:23:49 <m_rad> awesome
12:23:51 <chpatrick> where the thunk will allocate the rest
12:23:52 <jle`> ah, yes
12:23:55 <jle`> sorry ><
12:24:07 <m_rad> but this also means that list !! x is O(n)
12:24:11 <chpatrick> yep
12:24:13 <ReinH> m_rad: Yes
12:24:17 <m_rad> thank you very much guys
12:24:19 <ReinH> lists are not for random access
12:24:20 <chpatrick> check out Data.Vector for O(1)
12:24:27 <monochrom> "at most O" is, of course, redundant. "O" already subsumes "at most"
12:25:25 <monochrom> I do not buy the notion that 1:2:3:[] creates 1:<thunk>
12:25:33 <chpatrick> why not?
12:25:38 <frerich> Hrrr, in 'bracket (acquirePool bkndStngs poolStngs) (releasePool) $ \pool -> do' -- guess what those arguments to 'acquirePool' could be.
12:25:39 <monochrom> there are two cases
12:25:49 <chpatrick> it's <thunk> : <thunk> really
12:25:54 <frerich> It's apparently fashionable to abbreviate words by just dropping all vowels.
12:26:01 <EvanR> its not even just <thunk> 
12:26:07 <chpatrick> depends on whether you look at it
12:26:10 <EvanR> until theres some context
12:26:26 <monochrom> first case: you write the list literal in source code. "x = 1 : 2 : 3 : []". the compiled code has the whole list completely evaluated in memory. no thunk. no suspension.
12:26:33 <ReinH> frerich: stings?
12:27:08 <frerich> ReinH: Not quite :-)
12:27:18 <jle`> drop vowels and drop r's
12:27:24 <chpatrick> well to be super pedantic it's equivalent to a function (\f x -> 1 `f` 2 `f` 3 `f` x)
12:27:24 <monochrom> second case: you don't write that list literal, you write an expression that could generate that list, e.g., "[1..3]". then the thunk is "[1..3]" itself. no cons cells.
12:27:25 <chpatrick> afaik
12:27:32 <frerich> ReinH: It's "backgroundSettings" and "poolSettings" (why the latter isn't "plStngs" is beyond me)
12:27:50 <EvanR> also (\_ -> 1:2:3:[])
12:27:55 <frerich> ReinH: Sorry, 'backendSettings'
12:27:55 <EvanR> which literally has the expression in the code
12:28:55 <jle`> literally has the literal
12:29:09 <EvanR> funny that 1:2:3:[] would be called a literal ;)
12:29:16 <EvanR> the whole program is literally literal!
12:29:19 <jle`> well you use number literals ^^
12:29:27 <EvanR> its a constant expression
12:29:32 <monochrom> and : literals. and the [] literal.
12:29:34 <EvanR> or CAF
12:29:47 <monochrom> CAF's are not always literals.
12:30:03 <EvanR> wait yall are serious, 1:2:3:[] is a literal?
12:30:05 <monochrom> "x = [1..3]" gives you a CAF. but not too much literal.
12:30:29 <EvanR> 1:(1+1):3:[] is a literal?
12:30:42 <monochrom> the + there is not a literal
12:31:03 <monochrom> but : is somewhat different from functions
12:31:16 <monochrom> generally, data constructors are somewhat different from functions
12:31:29 <L8D> > (:) 1 ((:) 2 ((:) 3 []))
12:31:31 <lambdabot>  [1,2,3]
12:32:02 <L8D> EvanR: 1:2:3:[] is a literal in the same way (Just 1) is a literal
12:32:17 <EvanR> yes i get that
12:32:22 <britt> Anyone here who maintains the OSX installer?
12:32:38 <L8D> britt: for Haskell?
12:32:45 <britt> L8D: Yes.
12:32:49 <EvanR> i now feel like never using the word literal again
12:33:04 <kadoban> EvanR: Literally?
12:33:17 <britt> I just ran it and noticed no binaries were symlinked. Did a bit of digging and think it may be due to https://en.wikipedia.org/wiki/System_Integrity_Protection
12:33:32 <L8D> britt: there are multiple 'installers', to which do you refer?
12:33:53 <britt> Which protects /bin and /usr from being written to.
12:34:09 <ReinH> It shouldn't be instaalling anything in /bin
12:34:21 <britt> L8D: https://www.haskell.org/platform/mac.html
12:34:47 <Welkin> it should install in /usr/local/bin
12:35:11 <Welkin> both for the GHC bindist and the Platform
12:36:32 <britt> Hrm. Docs say "Executables are symlinked in /usr/bin and should be available in any shell."
12:36:43 <britt> Don't see symlinks there or in /usr/local/bin
12:37:03 <Welkin> that is what I was told with regard to the HP
12:37:08 <Welkin> I use the bindist myself
12:37:21 <kristof> I wouldn't consider constructors literals. ._.
12:38:01 <geekosaur> britt, are you running the el capitan prerelease then? it would not have symlinked and has not been updated for el capitan support yet
12:38:03 <monochrom> ok, I am willing to go with that.
12:38:21 <EvanR> theres literals in the context of concrete syntax
12:38:28 <monochrom> but "x = 1 : 2 : 3 : []" is not going to get compiled to "1 : <thunk>" or "<thunk> : <thunk>"
12:38:31 <britt> geekosaur: I am. On GM right now.
12:39:04 <breadmonster> What is subtyping?
12:39:08 <geekosaur> ok, that's probably rootless causing your problem then. I don't know what the plans are for HP vs. El Capitan
12:39:21 <Welkin> apple sure likes to piss off their users
12:39:28 <breadmonster> Welkin: Aren't you an Apple boy?
12:39:29 <EvanR> breadmonster: ask #scala
12:39:42 <Welkin> breadmonster: no, I think apple is a terrible company
12:39:44 <britt> geekosaur: That's what I thought.
12:39:45 <breadmonster> EvanR: I meant Haskell subtyping :P
12:39:50 <Welkin> even though I am currently using a macbook
12:39:52 <EvanR> DNE
12:40:40 <exio4> breadmonster: Haskell doesn't have subtyping, what do you mean? 
12:42:11 <geekosaur> I wouldn't call a data constructor a literal. I might call a data constructor with no parameters a "constant", although in Haskell that is ... dubiously helpful, so I just call it a data constructor
12:42:22 <breadmonster> exio4: Is (Int -> Char -> c) a subtype of (Int -> a -> c)?
12:42:37 <monochrom> no
12:42:43 <EvanR> breadmonster: no, its an instance of forall a c . Int -> a -> c
12:42:50 <monochrom> a special case. not a subtype.
12:42:51 <hodapp> jle`: yeah, I'm just taking this as a harbinger that I need to design things in a way that they *don't* require that level of function composition
12:43:01 <geekosaur> specialization, perhaps
12:43:04 <breadmonster> monochrom: What's the difference?
12:43:25 <geekosaur> (the opposite being generalization)
12:43:30 <EvanR> a subtype would be like my function is Float -> Float, but i pass it a Int and everything works*
12:43:59 <breadmonster> EvanR: it seems to be the same thing...
12:44:03 <kristof> I'm, uh, doing something funny with threads.
12:44:07 <monochrom> the type rules do not have a "subtype" judgment.
12:44:12 <EvanR> its not, in haskell Float and Int are two different types period
12:44:25 <EvanR> and in polymorphic type signatures the variables stand for "any type"
12:44:31 <kristof> I am looking at the signature of catch to find out how to write my own functions like this.
12:44:35 <geekosaur> subtype is when you can define a type as a subset of another type. for example, Int can be seen as a subtype of Double where the fractional part is always zero
12:44:55 <EvanR> thats the subset interpretation of subtypes
12:44:58 <kristof> What the heck is "catch#"?
12:45:06 <athan> If I have an open type family `Foo :: * -> *`, how can I make a context `HasFooInstance :: * -> Constraint`? Encoding type-level proof of kind inhabitance?
12:45:42 <monochrom> more precisely, the type rules have neither subtype introduction nor subtype elimination
12:45:42 <EvanR> if you have an injective mapping from A to B you could think of A being a subset of B
12:45:42 <geekosaur> one difference is that this is at the value level, whereas specialization/generalization of types is at the type level (specializing forall a. a -> a as Int -> Int, for example)
12:45:50 <kristof> I agree with EvanR.
12:45:57 <EvanR> but some subtyping situations arent injective like that
12:45:58 <kristof> Especially with the injective defintion.
12:46:04 <EvanR> for instance when you forget part of an interface
12:46:23 <EvanR> then its more like a quotient
12:46:45 <ReinH> Even in type systems with subtyping, Char would not be a subtype of forall a. a because forall a. a is not a type.
12:47:08 <kristof> That doubles and ints can be used interchangeably where a double is expected should be interpreted as the existence of some typeclass that can treat the two types under some canonical representation.
12:47:39 <EvanR> being able to be used interchangable is not implied by the injection
12:47:44 <athan> ReinH: How is `forall a. a` not a type? In your wording, would that just be a type "scheme", leaving the nomenclature of a "type" to be monomorphic?
12:47:50 <ReinH> It's a type variable.
12:48:02 <athan> okey :)
12:48:08 <EvanR> and so subset is not really a good way to think of subtypes
12:48:35 <exio4> i want to see some type system which combined dependent types, linear types and subtyping all together 
12:48:42 <exio4> is there any? (this is offtopic though)
12:49:18 <kristof> exio4: Idris might be able to represent subtyping with dependent types.
12:49:20 <monochrom> I only know combining dependent types and subtypes. PVS.
12:49:51 <Iceland_jack> I'm missing context but it seems like you're discussing subsumption, rather than subtyping
12:50:40 <kristof> Speaking of linear types, I was actually looking at "mechanically" translating monad instances to comonoadic instances and I found that if you use linear types...
12:51:12 <kristof> Well, if you try to write out the state instance, then you need to introduce a function called dup a -> (a, a)
12:51:48 <monochrom> yes, State can dup, linear state cannot
12:52:04 <kristof> And then it follows very cleanly that the Env comonad has cobind as the inverse of state's bind, where the inverse of dup is mappend
12:52:15 <kristof> So it's quite natural
12:52:18 <monochrom> nice
12:52:50 <kristof> Same thing happens with Reader and Traced although it was a hell of a lot harder. :P
12:53:40 <monochrom> is there a comonad cocomprehension? :)
12:53:57 <kristof> um, isn't that just an anamorphism?
12:54:18 <monochrom> I don't know anamorphism
12:54:37 <kristof> unfold?
12:54:38 <sinelaw> monochrom, you mean a comand mprehension ;)
12:55:10 <ReinH> monochrom: sure just flip the arrows around
12:55:13 <monochrom> is monad comprehension fold? catamorphism?
12:55:17 <kristof> Anyway I actually have no idea how to use Traced in practice
12:56:34 <kristof> The best intuition I have is that any function (e -> a) -> b MUST have some e and (a -> b) stored away in its guts somewhere...
12:56:44 <ReinH> kristof: Which is why it has a Comonoid constraint, except that this constraint is everywhere satisfied so it can be elided.
12:57:13 <kristof> ReinH: So is Comonoid's comappend my dup?
12:57:33 <suppi> I'm having trouble with my emulator :(
12:57:34 <kristof> I don't know anything about Comonoids.
12:57:36 <ReinH> yep, comappend :: a -> (a,a) and comempty :: a -> ()
12:57:56 <suppi> everybody are like "yeah, chip-8 is so easy, like a weekend project"
12:57:59 <ReinH> luckily Hask has enough structure to make this trivial
12:58:28 <suppi> this makes me feel stupid and incompetent :\
12:58:42 <ReinH> suppi: Ok, try not feeling that way instead.
12:59:00 <srhb> ReinH: Impenetrable wisdom right there. :-)
12:59:07 <ReinH> chip-8 is easy if you know how to write emulators.
12:59:11 <ReinH> Easy things are easy.
12:59:20 <kristof> Knowing how to write emulators is hard.
12:59:22 <kristof> ._.
12:59:27 <ReinH> Right.
12:59:41 <ReinH> People who say "X is easy" are really saying "I already know how to X"
12:59:56 <kristof> ReinH: Glad I stumbled upon comonoids and linear lambda calculus on my own without knowing what those were :P
13:00:09 <suppi> thanks ReinH 
13:00:11 <kristof> "Wow! Look at this neat thing I discovered!" Meanwhile, old results.
13:00:19 <ReinH> kristof: :) monoidal categories are fun.
13:00:31 <shachaf> I already know how to monoids.
13:01:05 <kristof> In all seriousness I am glad that these ideas actually arise naturally upon investigation. "Oh, this state has been duplicated. Is that allowed? Maybe I should introduce linear types here."
13:01:11 <ReinH> kristof: especially with string diagrams http://graphicallinearalgebra.net/
13:01:16 <suppi> It would have been easier if any rom I tried to run wouldn't get stuck in infinite jump and actually display something on the screen
13:01:19 <monochrom> I am a first-cause kind of person. or almost-first-cause. so, sure, some person already know how to X. how did they get there?
13:01:25 <suppi> but... sigh.
13:01:42 <FPstudent> Hi, i'm a 2nd year uni-CS student looking for some hints for my next assignment. I think I'm not that good at writing functions yet. 
13:01:59 <kristof> And it was very fun teasing out the mechanical definitions of comonad instances of functors just by looking at their monad instances.
13:02:10 <kristof> ...and boy, are there some really useless comonads.
13:02:17 <ReinH> heh
13:03:16 <kristof> I think it is rather surprising that programming actually involves mostly producing context, not consuming it. Even configuration, which is literally context sensitive, is better described by some reader comonad.
13:03:20 <kristof> *reader monad.
13:03:59 <suppi> FPstudent, do you have any specific question?
13:04:10 <kristof> And any place that comonads are obvious are probably simpler expressed as traversals and folds.
13:04:26 <ReinH> kristof: dunno about that
13:04:53 <ReinH> I think our preference for "producing context" has a significant cultural component.
13:05:28 <ReinH> based on the designs of the languages we use, etc
13:05:35 <kristof> ReinH: Disagree. Programming has had enough time for revolutions and people generally gravitate back toward context production, not consumption.
13:05:44 <ReinH> We figured out how to use monads for programming decades before comonads
13:06:13 <kristof> ReinH: But we have had at least a decade of comonads being in-the-wild.
13:06:13 <ReinH> kristof: "enough time for revolutions"? Monads are decades old and almost universally unused.
13:06:24 <monochrom> what is context production? what is context consumption?
13:06:43 <ReinH> monochrom: I'm treating those as "what monads do" and "what comonads do"
13:06:50 <ReinH> Which might be wrong
13:07:08 <ReinH> Kleisli arrows "produce a context", coKleisli arrows "consume a context".
13:07:12 <kristof> monochrom: computations M a -> b and a -> M b, there's no need for pedagoguery
13:07:35 <britt> Welp, got it working by disabling SIS.
13:07:45 <monochrom> thank you
13:07:59 <ReinH> britt: it really seems odd that you would have to do that. Are you trying to install as root or something?
13:08:44 <ReinH> The platform shouldn't be installing things into locations that involve SIS
13:08:45 <kristof> ReinH: The best I've seen are stream processing algorithms and neighbor-aware algorithms. And those are cool, let me tell you. I've used comonads in analysis of directed graphs and it was so simple.
13:09:25 <ReinH> kristof: This is also related to our preference for data over codata, induction over coinduction.
13:09:26 <britt> ReinH: The package from Haskell.org tries to write to /usr/bin which is no longer writable. Looks like Apple is encouraging people to use /usr/local
13:09:32 <ReinH> I still think the cultural aspect is significant.
13:09:41 <ReinH> britt: Well, they should be using /usr/local.
13:09:50 <ReinH> If the platform tries to write to /usr/bin, I would call that a bug.
13:10:10 <kristof> I don't disagree. But even if the cultural aspect was reduced I don't think we'd find many more useful abstractions hiding around there.
13:10:28 <ReinH> kristof: Well, I'm interested to see what the next 20 years of programming with comonads yields ;)
13:10:40 <kristof> ReinH: Psh, why, so we can all use comonad transformers?
13:10:54 <kristof> ReinH: I'm holding my breath for fast algebraic effects
13:10:56 <kristof> structuring be gone
13:11:03 <ReinH> hah, that sounds unhealthy
13:11:15 <kristof> ...probably
13:11:28 <kristof> Now where is that paper on the "freer" monad based on effects...
13:11:33 <srhb> who britt 
13:11:49 <srhb> britt: Are you Brittany Tate?
13:12:40 <ReinH> britt: You might actually prefer to install stack and then let it install the ghcs and packages you need. I'm beginning to prefer this method of bootstrapping.
13:12:48 <ReinH> It seems to Just Work more often.
13:14:34 <afonso> Does anyone know how to fix the window size with gloss?
13:14:40 <afonso> Or if it's even possible.
13:14:42 <britt> ReinH: I agree re: bug. Where to file? Should I bring it up on the listserv?
13:15:32 <britt> I'll check out stack and see where that installs to.
13:15:37 <britt> srhb: Nope.
13:15:43 <srhb> britt: Ah, ok. :)
13:16:09 <afonso> How to listen for window size?
13:17:02 <ReinH> britt: somewhere in ~, I believe.
13:17:27 <ReinH> I wonder...
13:17:29 <ReinH> @where stack
13:17:29 <lambdabot> I know nothing about stack.
13:17:37 <ReinH> Oh well. https://www.stackage.org
13:17:57 <btipling> that's an alternative to hackage?
13:18:14 <Clint> not exactly
13:19:15 <btipling> https://wiki.haskell.org/Stackage
13:19:16 <btipling> ah
13:19:17 <btipling> ok
13:20:38 <natalie_> afonso: What do you mean by "fix the window size" -- set it initially, or force it to be a static size?
13:22:13 <ReinH> btipling: stack is an aternative to cabal-install, stackage is a curated alternative to hackage.
13:22:26 <btipling> ah thanks ReinH 
13:22:38 <btipling> I think hackage works for me right now :/
13:23:03 <btipling> just learning the language, I guess stackage is for real world software
13:23:04 <bitemyapp> btipling: nothing wrong with that. stuff working is good :)
13:23:10 <btipling> yup
13:23:26 * hackagebot concurrent-machines 0.1.0.2 - Concurrent networked stream transducers  https://hackage.haskell.org/package/concurrent-machines-0.1.0.2 (AnthonyCowley)
13:30:07 <julianleviston> Haha I couldn’t stay away :)
13:31:19 <julianleviston> So I’ve got a bit of a weird question… rather than (>>=) :: Monad m => m a -> (a -> m b) -> m b isn’t t more useful to have (>>>=) :: Monad m => m a -> (a -> b) -> m b
13:31:22 <ReinH> btipling: stackage is for avoiding dependency hell, which affects fake world software too ;)
13:31:33 <btipling> yes
13:31:35 <julianleviston> I “made up” >>>= here… no idea if that actually exists
13:31:43 <aweinstock> julianleviston: that's (flip fmap), and it's less general
13:31:51 <julianleviston> oh!
13:31:52 <julianleviston> ok
13:31:57 <aweinstock> :t flip fmap
13:31:57 <ReinH> btipling: actually I think a beginner would have an easier experience on stackage. Dependency hell is a very real place.
13:31:58 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:32:14 <aweinstock> (every Monad is a Functor, but not vice-versa)
13:32:34 <julianleviston> nah it’s not the same thing
13:32:42 <btipling> ReinH: oh really? hrm, dependency hell is like when you want to distribute code to someone else and they have to fight getting dependencies and having version conflicts right
13:32:48 <ReinH> julianleviston: yes it is
13:32:50 <julianleviston> fmap (>>>= (*2)) [Just 1, Just 2] creates [Just 2, Just 4]
13:32:55 <aweinstock> :t flip fmap :: Monad m => m a -> (a -> b) -> m b
13:32:57 <lambdabot> Monad m => m a -> (a -> b) -> m b
13:33:14 <ReinH> julianleviston: what is your definition of (>>>=)?
13:33:22 <julianleviston> x >>>= f = x >>= (doit f)
13:33:25 <mniip> ReinH, it's more appropriate to call it dependency war
13:33:26 <ReinH> what is doit?
13:33:27 <julianleviston> doit :: Monad m => (a -> b) -> a -> m b
13:33:29 <julianleviston> doit f = return . f
13:33:31 <mniip> there are no innocent bystanders in hell
13:33:36 <ReinH> Taht's fmap.
13:33:39 <ReinH> *that
13:33:41 <julianleviston> oh lol
13:33:42 <btipling> you specify version in your cabel
13:33:45 <julianleviston> yay I’ve invented fmap
13:33:48 <btipling> what kind of dependency hell do you end up in?
13:33:51 <btipling> cabal*
13:33:52 <julianleviston> ok cool
13:33:57 <ReinH> julianleviston: >>= is structly more powerful than >>>=
13:34:01 <ReinH> :t (>>=)
13:34:02 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:34:03 <mniip> @src liftM
13:34:03 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:34:04 <ReinH> :t flip fmap
13:34:05 <lambdabot> Functor f => f a -> (a -> b) -> f b
13:34:10 <julianleviston> so therefore ...
13:34:44 <julianleviston> > fmap ((flip fmap) (*2)) [Just 1, Just 2]
13:34:46 <lambdabot>  <hint>:1:13: lexical error at character '\FS'
13:34:49 <julianleviston> hm
13:34:53 <ReinH> julianleviston: (a -> m b) arrows can *choose* an m based on the value of a. For example, Just True >>= \x -> if x then Nothing else Just "foobar"
13:34:57 <julianleviston> where did I go wrong?
13:35:28 <ReinH> fmap can't do that
13:35:38 <julianleviston> but >>>= can
13:35:44 <julianleviston> (my operator)
13:35:44 <ReinH> No, it can't, because >>>= is fmap
13:35:47 <nolrai666> Nope.
13:35:52 <julianleviston> well I just did it
13:35:55 <julianleviston> I wonder how
13:35:57 <ReinH> Show me
13:36:00 <ReinH> Because it's impossible
13:36:03 <ReinH> The type forbids it
13:36:19 <julianleviston> not sure how to do it in here
13:36:22 <julianleviston> I did it in Ghci
13:36:26 <ReinH> I don't believe you.
13:36:37 <ReinH> You can lpaste a transcript from ghci
13:36:39 <julianleviston> how do I show you?
13:36:40 <julianleviston> ok
13:36:45 <uiop> > (ap(++)show)"(ap(++)show)"
13:36:48 <lambdabot>  "(ap(++)show)\"(ap(++)show)\""
13:36:50 <aweinstock> ReinH: it might be possible if you poke the ghc runtime right with unsafePerformIO and Foreign.Marshal, but that's abhorrent
13:36:56 <uiop> the best quine evar
13:37:03 <ReinH> aweinstock: I prefer to live in a sane world.
13:37:13 <ReinH> yes, if you cheat you can cheat.
13:37:28 <julianleviston> ReinH: http://lpaste.net/141072
13:37:37 <julianleviston> I don’t think I’m cheating!
13:37:50 <julianleviston> the top part is the file I’m loading with :r
13:37:59 <mniip> uiop, redundant parens
13:37:59 <julianleviston> well it’s in that file.
13:38:02 <ReinH> julianleviston: that doesn't do what you are claiming though
13:38:08 <ReinH> the constructors are unchanged
13:38:14 <nolrai666> And that is what fmap does.
13:38:19 <julianleviston> but I can’t do that by using flip fmap can I?
13:38:22 <mniip> uiop, otherwise p nice
13:38:25 <julianleviston> or is it just fmap fmap?
13:38:29 <ReinH> julianleviston: you aren't doing anything I claimed you can't do
13:38:34 <exio4> > fmap (flip fmap (*2)) [Just 2, Just 3]
13:38:35 <lambdabot>      Couldn't match expected type ‘a -> b’
13:38:35 <lambdabot>                  with actual type ‘Maybe Integer’
13:38:35 <lambdabot>      Possible cause: ‘Just’ is applied to too many arguments
13:38:35 <julianleviston> > fmap (fmap (*2)) [Just 1, Just 2]
13:38:37 <lambdabot>  [Just 2,Just 4]
13:38:55 <ReinH> all you're doing is fmapping twice.
13:39:01 <ReinH> once for [], once for Just
13:39:06 <julianleviston> ah ok
13:39:09 <julianleviston> cool then :)
13:39:22 <exio4> functors compose pretty well
13:39:33 <julianleviston> I’d find it quite useful to have that functin.
13:39:43 <ReinH> which function?
13:39:46 <julianleviston> more useful than >>= most of the time, I think. 
13:39:54 <ReinH> Well, you have it. It's called fmap.
13:39:57 <ReinH> It's also called <$>
13:40:01 <julianleviston> (>>>=) :: Monad m => m a -> (a -> b) -> m b
13:40:03 <aweinstock> map (>>= \x -> if x > 1 then Just x else Nothing) [Just 1, Just 0, Nothing]
13:40:06 <aweinstock> > map (>>= \x -> if x > 1 then Just x else Nothing) [Just 1, Just 0, Nothing]
13:40:07 <julianleviston> ap? ok
13:40:10 <ReinH> With a Monad constraint, it's called liftM, but that's unnecessary now
13:40:11 <lambdabot>  [Nothing,Nothing,Nothing]
13:40:16 <nolrai666> And it is super useful.
13:40:17 <ReinH> because all Monad instances are also Functor instances.
13:40:18 <aweinstock> > map (>>= \x -> if x > 1 then Just x else Nothing) [Just 2, Just 0, Nothing]
13:40:20 <lambdabot>  [Just 2,Nothing,Nothing]
13:40:31 <ldlework> nolrai666: xu do jbopre
13:40:32 <ReinH> :t liftM
13:40:34 <ReinH> :t fmap
13:40:34 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
13:40:34 <aweinstock> julianleviston: fmap can't do that
13:40:36 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:40:53 <exio4> ReinH: well, it can be used for implementing a def fmap, so it does have some uses :P
13:41:30 <ReinH> exio4: No, it can't.
13:41:36 <ReinH> Because you already need a Functor instance
13:41:39 <ReinH> if you want to make a Monad
13:41:40 <aweinstock> :t (>>= (return .))
13:41:41 <lambdabot> Monad m => (a -> a -> a1) -> a -> m a1
13:41:42 <afonso> Hello, how would I spawn haskell processes and interact between them? What is that even called ?
13:41:46 <nolrai666> Idlework: my lojban is rusted shut.
13:42:04 <ldlework> nolrai666: just checking :D
13:42:12 <exio4> ReinH: ?
13:42:21 <ldlework> nolrai666: we have a #lojban, just fyi
13:42:21 <julianleviston> Just 1 >>>= (*2) to get Just 2 seems much easier to me than Just 1 >>= \x -> return $ x * 2
13:42:26 <ReinH> exio4: instance Functor f => Applicative f and instance Applicative f => Monad f
13:42:35 <ReinH> You can't write a Monad instance without already having fmap
13:42:41 <aweinstock> > fmap (*2) (Just 1) -- julianleviston 
13:42:43 <lambdabot>  Just 2
13:42:46 <nolrai666> I should start learning languages again..
13:42:49 <exio4> ReinH: instance Functor M where fmap = liftM ; instance Applicative M where pure = return; (<*>) = ap; instance Monad M where return = ... ; (>>=) = ...
13:42:58 <ReinH> exio4: you can't write that.
13:43:03 <uiop> whats that one fib one with scanl and fix again?
13:43:08 <afonso> Can anyone please help me?
13:43:09 <ReinH> Because you can't have liftM unless you already have fmap.
13:43:10 <afonso> ??????????'
13:43:15 <exio4> ReinH: do we bet? :P 
13:43:15 <ReinH> Because Monad depends on Functor now.
13:43:22 <julianleviston> aweinstock: ah now I understand
13:43:24 <uiop> > scanl (+) 1 $ fix (1:) -- something like this
13:43:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
13:43:26 <ReinH> exio4: I'm talking about 7.10
13:43:29 <julianleviston> aweinstock:  thanks.
13:43:32 <uiop> but thats not fib
13:43:39 <julianleviston> aweinstock: it’s just flip fmap! :)
13:43:48 <julianleviston> ok… bedtime now. Thanks everyone! :)
13:43:53 <ldlework> nolrai666: and I should learn more functional programming :)
13:44:11 <afonso> Can anyone help me here please?
13:44:17 <afonso> :/
13:44:24 <nolrai666> What was the question?
13:44:43 <ldlework> how to communicate between processes
13:44:43 <ReinH> afonso: Do you want to spawn processes or threads?
13:44:49 <monochrom> afonso: System.Process has many tools for that. (many because there are variations.)
13:44:55 <afonso> I am asking what is the way in Haskell to spawn haskell programs
13:44:58 <afonso> and interact between them
13:44:59 <exio4> ReinH: well, even with GHC 7.8 
13:45:09 <suppi> afonso, http://chimera.labs.oreilly.com/books/1230000000929/ch07.html
13:45:12 <exio4> ReinH: Functor f => Applicative f in the class definition
13:45:18 <ReinH> afonso: Yes, read that book
13:45:23 <afonso> and if you need to compute a large value, is spawning a separate haskell process alright for this case?
13:45:23 <ReinH> exio4: but not Monad
13:45:28 <ReinH> (in 7.8)
13:45:46 <ReinH> That's the big change the AMP made
13:45:59 <ReinH> Monad now depends on Applicative and so transitively depends on Functor
13:46:10 <aweinstock> afonso: why do you need process-level seperation? why isn't forkIO and Data.MVar sufficient?
13:46:17 <exio4> yes, I am saying a default implementation of Functor using Applicative works, in GHC 7.8
13:46:20 <aweinstock> (or was it Control.Concurrent.MVar?)
13:46:26 <nolrai666> afonso: fork i think. Search for concurrency in hackage.
13:46:28 <ReinH> afonso: You should consider threads first.
13:46:36 <monochrom> Control.Concurrent.MVar :)
13:46:38 <ew0> GHC 7.10 FTW!
13:46:42 <ChristianS> afonso: there is also Control.Concurrent.Async
13:46:46 <ReinH> afonso: and you should read that book. It's an entire book devoted to answering your question, for free.
13:47:02 <afonso> awinstock: Say I want to get a factorial of some number, and I can't stop in the middle of the program to do that. How would I call a separate haskell program and have it return the result?
13:47:09 <afonso> In Javascript, I would use asynchronous functions.
13:47:12 <ReinH> afonso: You would use a thread for that.
13:47:17 <ReinH> Not a separate program.
13:47:32 <ReinH> There's no reason to incur the overhead and complexity of a separate process.
13:47:39 <afonso> And what is this called? Parallelism or Concurrency ?
13:47:45 <ReinH> afonso: concurrency
13:47:52 <ReinH> Well, I think this is actually parallelism.
13:47:56 <prinsen_> Im writing a backend serving TCP connections in Haskell. Two questions. 1. Is there a better solution/library then the naive accept/forkIO loop? 2. If each client are managed by a separate thread, how do I maintain a thread-safe state that all clients can update/query?
13:48:02 <ReinH> You don't have separate threads of control, you just have calculations happening in parallel.
13:48:05 <uiop> > fix (scanl (+) 0 . (1:))
13:48:07 <afonso> What is the difference anyways?
13:48:07 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:48:10 <uiop> wooo
13:48:12 <exio4> @letlpaste 604796554225647616
13:48:14 <lambdabot>  Defined.
13:48:18 <ReinH> afonso: but seriously, just read the book.
13:48:18 <exio4> @type Id 
13:48:19 <lambdabot> a -> Id a
13:48:25 <ReinH> afonso: The book defines the difference.
13:48:27 * hackagebot yaml-light-lens 0.3.3.1 - Lens interface to yaml-light.  https://hackage.haskell.org/package/yaml-light-lens-0.3.3.1 (AnthonyCowley)
13:48:30 <uiop> :pl \x -> x
13:48:32 <exio4> ReinH: http://lpaste.net/604796554225647616 works in lambdabot 
13:48:36 <uiop> @pl \x -> x
13:48:36 <lambdabot> id
13:48:39 <afonso> ReinH do I need to know advance haskell stuff to read that book?
13:48:43 <ReinH> afonso: no
13:48:52 <aweinstock> afonso: do { resultBox <- newEmptyMVar; forkIO (putMVar resultBox (factorial 20)); takeMVar resultBox}
13:48:56 <uiop> @pl fix (scanl (+) 0 . (1:))
13:48:56 <lambdabot> fix (scanl (+) 0 . (1 :))
13:49:15 <exio4> > do { x <- Id 2; y <- Id 3; Id (x+y) } 
13:49:16 <lambdabot>      No instance for (Show (Id b0))
13:49:17 <lambdabot>        arising from a use of ‘show_M316862773905203789524115’
13:49:17 <lambdabot>      In the expression:
13:49:25 <afonso> ReinH isn't that outdated?
13:49:28 <exio4> well, nearly :p but it type checked, it's there :) 
13:49:28 <ReinH> afonso: No.
13:49:37 <ReinH> Wait, which book were you linked?
13:49:53 <uiop> > unsafePerformId $ do { x <- Id 2; y <- Id 3; Id (x+y) } 
13:49:55 <lambdabot>  Not in scope: ‘unsafePerformId’
13:50:02 <mniip> @let instance Show a => Show (Id a) where showsPrec d (Id x) = showParen (d > 9) $ showString "Id " . showsPrec 10 x
13:50:03 <ReinH> No, Simon's book is not outdated. It's quite fresh.
13:50:04 <lambdabot>  Defined.
13:50:13 <aweinstock> :t runIdentity
13:50:14 <uiop> :m + System.Id.Unsafe
13:50:14 <lambdabot> Identity a -> a
13:50:14 <monochrom> I think only Marlow's book is linked.
13:50:26 <ReinH> afonso: I don't know how many more ways I can say this: read that book and you will learn what you want to know.
13:50:35 <prinsen_> Anyone?
13:50:46 <ReinH> (And lots of other stuff too)
13:50:46 <monochrom> I agree.
13:50:58 <nolrai666> prinsen_: for 2) STM is what you want probably.
13:51:02 <monochrom> (perhaps more people to say it, rather than more ways, is needed)
13:51:08 <ReinH> monochrom: perhaps.
13:51:16 <afonso> ReinH ok thanks
13:51:25 <aweinstock> prinsen_: MVars do shared locked mutable structures, but might be a tad low-level
13:51:28 <ElMoloko> hey #haskell.  what's the best way to make a ioctl call?  well, least stupid.  should i write an FFI?  I found this[0] but i would i get the request code on a device-independent basis?  I'm specifically trying to make a TIOCSTI call... [0] https://hackage.haskell.org/package/ioctl-0.0.1/docs/System-Posix-IOCtl.html
13:51:49 <prinsen_> I have read about STM, and it sounds really cool
13:51:53 <ElMoloko> I it doesn't have to run on a non-posix system...
13:52:06 <ReinH> aweinstock: I'm not sure what flavor of parallelism or concurrency they need, but I know the book will include it. :)
13:52:14 <ReinH> Maybe they just need par.
13:52:17 <prinsen_> but how do I run multiple threads in the same "state"
13:52:41 <ReinH> prinsen_: by sharing the state with each.
13:52:48 <exio4> I just realized I implement fmap with pure/<*>, here it is with liftM directly :p http://lpaste.net/7322688453907316736
13:53:01 <exio4> ReinH: ^
13:53:13 <ReinH> exio4: which ghc version?
13:53:19 <exio4> lambdabot's version :) 
13:53:19 <Cale> prinsen_: Threads explicitly share information with each other using TVar and other mutable structures.
13:53:38 <exio4> which is GHC 7.10.x for some x I don't know 
13:53:39 <Cale> prinsen_: There's no global state, you have what you have.
13:53:42 <ReinH> exio4: huh.
13:54:13 <exio4> ReinH: just like (==) can be defined using compare, or fmap could be defined using pure/(<*>), it can be implemented this way
13:55:04 <Cale> prinsen_: (presumably, the TVars which are shared between the threads were created by their parent thread, but these things are higher order, so it's possible, if a bit rare, to obtain a TVar in some other way)
13:55:24 <monochrom> exio4: you are using liftM to get fmap, not pure+<*> to get fmap
13:55:30 <Cale> (e.g. it's possible to have a TVar (TVar a), which would allow one thread to tell another which TVar it needs to write to.
13:55:35 <ReinH> exio4: fair enough
13:55:36 <Cale> )
13:55:56 <exio4> monochrom: I did in a previous paste, and I was giving _another_ example 
13:56:19 <aweinstock> :t \f -> (pure f <*>)
13:56:21 <lambdabot> Applicative f => (a -> b) -> f a -> f b
13:56:28 <monochrom> I see. nevermind
14:01:10 <prinsen_> Cale: so I would create some TVars, as fine grained as possible in the main thread, and all forked threads can run transactions using those TVars? 
14:03:19 <nolrai66> prinsen_: afaiu, yes.
14:06:38 <ReinH> We need a flowchart. [ Is your question about parallelism or concurrency? ] -- yes --> [ Read SimonM's book ]
14:08:07 <monochrom> prinsen_: I would replace "as possible" by "as really needed or sensible"
14:08:33 <monochrom> TChan actually shows a great example of the difference.
14:09:21 <bitemyapp> hrm.
14:09:25 <bitemyapp> @where parallel
14:09:26 <lambdabot> http://www.haskell.org/haskellwiki/Parallel
14:09:29 <bitemyapp> @where conc
14:09:29 <lambdabot> I know nothing about conc.
14:09:31 <bitemyapp> @where concurrency
14:09:31 <lambdabot> I know nothing about concurrency.
14:09:36 <bitemyapp> need to fix that.
14:09:36 <monochrom> "as possible" would be a list of TVar cons cells, like Chan is.
14:10:02 <suppi> ReinH, yes!
14:10:26 <monochrom> but TChan foresakes that. it is only two TVar's. Each TVar points to an immutable list. (two lists make a queue. common trick.)
14:10:45 <monochrom> so TChan does "as needed" rather than "as sensible"
14:11:10 <monochrom> or maybe it's even just one TVar for an immutable pair of two immutable lists. I forgot.
14:11:50 <monochrom> anyway it is totally not like Chan's fine-grained every-bit-is-mutable mutable list
14:13:14 <pavonia> Is there a way to have a CPP conditional for "base version < 4.5"?
14:13:42 <monochrom> yes. it's somewhere in the cabal user guide
14:14:03 <monochrom> https://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
14:14:27 <monochrom> wait, that's >=. but you can use the #else branch hehe
14:14:59 <pavonia> Excellent, thank you
14:15:10 <ReinH> bitemyapp: +1
14:15:36 <ReinH> bitemyapp: I also made a flowchart for understanding fixed points https://twitter.com/ReinH/status/643895454111952896
14:16:02 <monochrom> does that flowchart contain a loop? (ok I'll go find out)
14:16:12 <ReinH> monochrom: I don't know what you expected. :p
14:16:14 <monochrom> darn you, it does
14:16:32 <t7> ReinH: epic joke bro
14:16:39 <sinelaw> hi! Question about ST: I've an AST that contains STRefs inside. when I'm done computing stuff, I want to runST and return a value (must be without STRefs, then) which I'm trying to achieve by parameterizing over the "storage cell" type and replacing it from STRef with something pure when I'm done. does this make any sense?
14:16:53 <monochrom> did you know the easter egg about googling for recursion? :)
14:17:06 <sinelaw> using fixed-point data types to replace the STRef with a different storage type
14:17:10 <ReinH> monochrom: nice.
14:17:14 <monochrom> hehe
14:17:15 <ReinH> t7: :D
14:18:18 <t7> > let fix f = f (fix f) in fix ("The ride never ends. " ++)
14:18:20 <lambdabot>  "The ride never ends. The ride never ends. The ride never ends. The ride nev...
14:18:32 <monochrom> sinelaw: is there a short example?
14:18:39 <sinelaw> monochrom, i'll make one
14:18:47 <t7> @hoogle [a] -> [[a]]
14:18:49 <lambdabot> Data.List inits :: [a] -> [[a]]
14:18:49 <lambdabot> Data.List permutations :: [a] -> [[a]]
14:18:49 <lambdabot> Data.List subsequences :: [a] -> [[a]]
14:20:21 <bitemyapp> ReinH: jfc lol
14:20:25 <ReinH> bitemyapp: <3
14:20:41 <bitemyapp> ReinH: think we're releasing monoid/functor/applicative/monad tonight.
14:20:47 <ReinH> bitemyapp: nice!
14:21:12 <bitemyapp> it'll put us over 750 pages in the current release.
14:21:15 <kadoban> bitemyapp: Ooo, that's exciting.
14:21:44 <bitemyapp> The content is good, but we have more planned for these chapters that'll come in a later release.
14:22:21 <sinelaw> monochrom, http://lpaste.net/141078
14:22:41 <nolrai66> What bitemyapp publishing?
14:22:46 <nolrai66> *is
14:23:39 <monochrom> yikes, you have TVar too?
14:23:50 <monochrom> err nevermind, not that TVar
14:23:51 <bitemyapp> nolrai66: http://haskellbook.com/
14:24:05 <sinelaw> oh that's not the TVar
14:24:07 <bitemyapp> nolrai66: it's not done, still in early access, but it's also over 600 pages long so depending on your definition of "done" it might be suitable or not.
14:24:12 <sinelaw> monochrom, it's just a name of a constructor
14:24:17 <monochrom> yeah hehe
14:24:26 <bitemyapp> nolrai66: progress page lists what's in the current release and what's planned for the next releases.
14:25:06 <sinelaw> monochrom, doSomething should probably be doSomething :: (forall s. ST s (Type s)) -> PureType
14:25:15 <monochrom> yeah
14:29:23 <shersh> Hello, everyone! I'm trying to implement simple functions which finds sum of length of all strings in list of strings. I come up with two versions: 1 foldr (\s acc -> acc + length s) 0 ["aaa", "bbb", "s"]
14:29:43 <shersh> 2. foldr (+) 0 $ map length ["aaa", "bbb", "s"]
14:29:55 <shersh> And my question is why second functions is faster?
14:30:25 <quchen> :t foldr (\x rest -> length x + rest) 0
14:30:26 <lambdabot> (Foldable t, Foldable t1) => t (t1 a) -> Int
14:30:28 <Cale> How did you measure?
14:30:49 <sinelaw> monochrom, my question is whether this is the usual way of un-STing a data structure that hash STRefs inside?
14:30:58 <sinelaw> s/hash/has/
14:31:03 <shersh> let sl = replicate 1000000 ["abcdefabcded"] and run on this function in ghci with :set +s
14:31:14 <Cale> hmm
14:31:23 <quchen> shersh: foldr doesn't accumulate something, so it's not really accurate to call the parameter "acc". Just a nitpick, but lots of people run into dead ends thinking about foldr this way.
14:32:03 <ReinH> shersh: I suspect with optimization turned on they should be virtually identical
14:32:18 <ReinH> In any case, sum . map length should be more efficient.
14:32:19 <shersh> quchen: thanks for advice :)
14:32:20 <quchen> shersh: As for "which is faster", it's hard to say here. map and foldr are typically optimized well by GHC.
14:32:30 <quchen> So I'll go with ReinH on that issue.
14:33:00 <ReinH> (1) is what (2) should fuse into, after all
14:33:30 <ReinH> but foldr is not efficient for this, you want foldl'
14:33:36 <quchen> shersh: "fusion" is an optimization technique that allows the compilier to combine "foldr-based stuff" into single folding operations, in a nutshell.
14:33:52 <shersh> I know about fusion. But I don't use Data.List.Stream here
14:34:00 <quchen> Stream fusion is one form of fusion.
14:34:07 <quchen> Standard lists use what's called fold/build fusion.
14:34:11 <ReinH> shersh: fusion happens under the hood as a compiler optimization based on rules pragmas
14:34:16 <kaidelong> is foldl' subject to fusion?
14:34:17 <ReinH> You don't need to use Stream
14:34:28 <ReinH> kaidelong: foldl' is a consumer, iirc
14:34:35 <ReinH> foldr is both a producer and a consumer
14:34:44 <kaidelong> alright, then I don't see how he could lose with foldl' here
14:34:50 <kaidelong> seems like the winner
14:34:55 <ReinH> even if it weren't, it should still be faster
14:35:13 <kaidelong> what about length . concat?
14:35:15 <Cale> shersh: Try changing it to foldr (\s acc -> length s + acc) 0
14:35:27 <Cale> shersh: I get pretty identical timings then.
14:35:45 <ReinH> kaidelong: Or that.
14:35:46 <quchen> And then change it to foldl' (\acc s -> acc + length s) 0 and see what happens.
14:35:49 <monochrom> sinelaw: at present I only know to write a loop by hand to traverse the STRef list and translate to the pure list, cell by cell. I don't know of a general way.
14:35:50 <Cale> yes
14:36:07 <monochrom> I have to go so I can't write that code now.
14:36:17 <Cale> (foldl should do just as well as foldl' if you have optimisations on, GHC is pretty clever)
14:36:25 <ReinH> bitemyapp: is the font you're using the final font or temporary?
14:36:36 <ReinH> I assume you haven't messed with it yet
14:36:37 <quchen> ReinH: "yes" :-þ
14:36:52 <shersh> In my ghci foldl' is slower then foldr (+) $ map length, buy length . concat is faster :0
14:36:53 <shersh> :)
14:37:01 <quchen> GHCi won't optimize your code
14:37:03 <ReinH> quchen: :p
14:37:17 <quchen> GHCi is optimized for loading code quickly, not running it quickly.
14:37:20 <ReinH> shersh: timings in ghci are basically a lie
14:37:33 <ReinH> performance in GHC often depends heavily on optimizations
14:37:39 <kaidelong> ReinH: GHC will use an object file if it exists, right?
14:37:52 <kaidelong> so why couldn't he just compile it AOT and then enter GHCi and time it?
14:38:04 <ReinH> kaidelong: if I'm making a blanket statement, I'll err on the side of caution :)
14:39:07 <shersh> Does anyone know a good way to measure time execution of haskell program? Of some functions at least
14:39:10 <kaidelong> shersh: if you are on a UNIXey system there is a tool called "time" which you can use to run the compiled and optomized binary rather than using GHCi if you want
14:39:14 * quchen once had a problem that he thinks was because GHCi didn't load .o correctly, but he's not sure anymore. If doubtful anecdotical arguments are your cup of tea, that is.
14:39:29 <quchen> shersh: Criterion!
14:39:32 <tulcod> shersh: for more complicated benchmarks you could try e.g. "criterion"
14:39:45 <quchen> And for simple benchmarks as well. :-)
14:39:59 <bitemyapp> ReinH: I have messed with it, and which one?
14:40:04 <bitemyapp> ReinH: the body font or the code font?
14:40:06 <tulcod> quchen: well it's probably overkill for a single function
14:40:32 <quchen> bitemyapp: Don't let ReinH tell you anything! Computer Modern is all we'll ever need! :-D
14:40:37 <ReinH> bitemyapp: body font
14:40:41 <bitemyapp> quchen: only the code is Computer Modern.
14:40:41 <dmj`> jle`: question, about to release a lib
14:40:47 <bitemyapp> quchen: the body is Baskerville
14:40:55 <bitemyapp> ReinH: okay, do you not like Baskerville? What's wrong with it?
14:41:02 <ReinH> baskerville isn't a great screen font
14:41:33 <bitemyapp> ReinH: what do you prefer?
14:41:49 <kaidelong> IIRC GHC profiling made your program slower and even changed asymptotic bounds, does Criteron sidestep +RTS?
14:41:55 <bitemyapp> my only hard requirements are that the code font really has to stay CMUTT unless something really compelling comes along. Body is more flexible.
14:42:16 <ReinH> The subtle line widths really don't render well, even on OS X.
14:42:21 <quchen> kaidelong: Criterion doesn't need to be run with RTS enabled, does it?
14:42:25 <ReinH> *line width variations
14:42:29 <kaidelong> that's what I am asking
14:42:42 <kaidelong> GHC's built in profiler, is, to my knowledge, somewhat useless due to the above
14:42:55 <kaidelong> if Criteron just wraps that it would have the same problems
14:43:04 <bitemyapp> ReinH: do you have an alternative in mind?
14:43:44 <quchen> Computer Modern? :>
14:43:55 <FPstudent> is there a bot to msg someone when he comes online?
14:44:05 <quchen> FPstudent: Lambdabot has ?tell.
14:44:13 <bitemyapp> quchen: people complained. I would've been fine with it, but w/e.
14:44:19 <quchen> FPstudent: Lambdabot messages that person when he comes online.
14:44:23 <bitemyapp> quchen: I think it looks unprofessional to some? Like it's not a real book?
14:44:28 <quchen> ?tell FPStudent test
14:44:29 <lambdabot> Consider it noted.
14:44:30 <exio4> FPstudent: you can use memoserv too
14:44:39 <quchen> … quit
14:44:48 <tulcod> kaidelong: criterion is not a profiler
14:44:49 <quchen> Oh, nevermind. Case-sensitive completion.
14:45:36 <quchen> kaidelong: I wouldn't say GHC's profiler is useless. Even given the skewed time taken, you still get a good metric for e.g. times a certain value is evaluated.
14:45:53 <quchen> kaidelong: It's an excellent first-order approximation.
14:46:05 <kaidelong> I do remember that it never does *better* than code without profiling hooks
14:46:15 <kaidelong> so I guess you can consider it a pessimistic upper bound
14:47:33 <kaidelong> actually, maybe that isn't true once you start comparing two pieces of code to see which one is faster, which is what you want the profiler for
14:48:13 <arw_> one perhaps might be able to construct a faster case through weird alignment changes. but that would be a very weird thing to occur in reality
14:48:17 <ReinH> bitemyapp: tbh Georgia works very well on screens.
14:48:33 <ReinH> bitemyapp: are you using LaTeX? Charter is pretty reasonable.
14:48:44 <kaidelong> it's enough to slow down two examples unequally using +RTS
14:49:24 <Welkin> Noticia Text is my favorite
14:49:25 <Welkin> http://www.fontsquirrel.com/fonts/noticia-text
14:49:26 <bitemyapp> ReinH: yep, all LaTeX.
14:49:28 <Welkin> try it out
14:49:35 <bitemyapp> ReinH: Georgia and Charter -- I'll give them a whirl. Thank you!
14:49:51 <FPstudent> test
14:49:55 <Welkin> it has a high x-height and is easy to read at smaller sizes too
14:50:01 <ReinH> Welkin: that looks nice
14:50:10 <dmwit_> cmccann: What do you think of generalizing `dictate` to `(MonadChronicle c m, Default a) => c -> m a`?
14:50:27 <bitemyapp> Welkin: I'll add that to the list, tahnk you.
14:50:40 <dmwit> cmccann: For almost all "non-fatal error" situations, that's what you want.
14:51:06 <ReinH> bitemyapp: if you're considering sans serif, give open sans a try
14:51:38 <FPstudent> ?tell suppi thanks for the help: i figured it out! printLine (xs) = "+" ++ intercalate "+" (map(\xs -> replicate xs '-') xs) ++ "+"
14:51:38 <lambdabot> Consider it noted.
14:52:22 <quchen> FPstudent: The parentheses around the "xs" and the "map" are redundant.
14:52:28 <cmccann> dmwit: I'm not really sure what that accomplishes tbh
14:52:57 <ReinH> bitemyapp: I believe there's also a package for Minion Pro, which is nice
14:53:56 <ReinH> bitemyapp: If you need a combination of serif and sans-serif, bistream charter and bitstream vera are great together
14:54:17 <ReinH> Arev is a Vera clone that is available for latex
14:54:32 <cmccann> dmwit: unless I'm misunderstanding something, the only thing it could possibly be is the existing dictate followed by 'return default'
14:54:34 <ReinH> Anyway, this is off topic, sorry
14:54:43 * sinelaw has the rank n types, inference blues
14:54:51 <sinelaw> ST is tricky to compile
14:55:15 <dmwit> cmccann: correct
14:55:35 <dmwit> cmccann: or the existing dictate with () replaced by def, for simplicity
14:55:57 <quchen> ST is only rank-2.
14:56:09 <quchen> The blues gets heavier with increasing rank.
14:56:32 <dmwit> cmccann: It's not fundamentally different. But it's quite convenient: in almost every non-fatal error condition, you're in some branch of a case statement where you're supposed to return something of the same type as the no-error-fatal-or-otherwise branch.
14:56:39 <cmccann> dmwit: what's the point of "foo <- dictate bar" when you always know what value foo will have?
14:56:43 <quchen> > ($) runST (return ()) -- my favourite
14:56:44 <lambdabot>      Couldn't match type ‘m0 ()’ with ‘forall s. ST s a’
14:56:45 <lambdabot>      Expected type: m0 () -> a
14:56:45 <lambdabot>        Actual type: (forall s. ST s a) -> a
14:56:50 <cmccann> ahh, I see now
14:57:39 <cmccann> I'm still not really a fan of the Default class as a whole though
14:58:04 <dmwit> hum =)
14:58:22 <cmccann> dmwit: also, that'd be adding a dependency to these for that one thing
14:59:47 <dmwit> It would, yes.
14:59:57 <dmwit> data-default-class is a pretty light dependency, though.
15:00:21 <dmwit> Literally five lines of code.
15:00:37 <quchen> Matches its utility :-|
15:00:43 <dmwit> (And no transitive dependencies other than base.)
15:01:37 <tulcod> cmccann, dmwit: the Default class is evil, please find a solution instead
15:01:46 <cmccann> dmwit: ehhhhh
15:02:32 <kadoban> Really? What's wrong with Default ?
15:02:51 <tulcod> kadoban: e.g. http://phaazon.blogspot.com/2015/07/dont-use-default.html
15:03:03 <quchen> It follows no laws, so it abstracts over nothing worth abstracting, except the name of its members.
15:04:04 <cmccann> dmwit: it's not something I'd ever want but I could be persuaded if multiple people think it would be an improvement
15:04:04 <quchen> Type classes unify common behaviour. No laws mean no common behaviour (keep in mind that some useful classes have their free laws though). Default has no laws, and something of type "a" has no nontrivial free laws as well.
15:04:33 <cmccann> unfortunately I'm not sure "multiple" people even use that class
15:05:03 <quchen> Even the universally hated Pointed class is somewhat better in that respect, since it can be given laws when combined with other classes.
15:05:43 <tulcod> cmccann: http://packdeps.haskellers.com/reverse/data-default
15:06:12 <cmccann> tulcod: I meant people using MonadChronicle, not Default
15:06:16 <tulcod> oops ok :)
15:06:30 <cmccann> tulcod: http://hackage.haskell.org/package/these-0.4.2/docs/Control-Monad-Chronicle-Class.html
15:06:55 <cmccann> tulcod: dmwit was suggesting that the "dictate" function should return a default value instead of ()
15:07:37 <kadoban> So … why can't I used 'def' to mean an empty Data.Map.Map k v, for instance? It's obvious what it /has/ to be, and seems nice? Also Data.Map isn't an instance of Alternative or Monoid or anything AFAIK, is it? So that other advice doesn't apply.
15:07:59 <phaazon> kadoban: why is it obvious?
15:08:21 <nolrai666> It should be a member of monoid.
15:08:25 <cmccann> kadoban: map has a Monoid instance
15:08:25 <kadoban> phaazon: Because there's nothing else that the instance could guess at?
15:08:29 <kadoban> Oh it is a Monoid …
15:08:31 <phaazon> it is.
15:08:40 <phaazon> kadoban: nope
15:08:49 <quchen> Map is a Monoid with empty and left-biased union.
15:08:50 <phaazon> you think it’s obvious because you think of something else
15:09:00 <phaazon> you think of empty + union
15:09:07 <cmccann> also, the only reason an empty map is an "obvious" default is BECAUSE it's also mempty
15:09:09 <phaazon> so that’s the mempty one you want
15:09:10 <phaazon> not def
15:09:14 <lpaste_> drewbert pasted “mergefold” at http://lpaste.net/141081
15:09:20 <kadoban> Yeah I guess that makes sense.
15:09:44 <quchen> The empty Map is the only thing you could have as a default. For Integer, the default is much harder to justify.
15:09:54 <drewbert> Could people take a look at that and suggest some ways to make it less ugly?
15:10:07 <drewbert> Also, there has to be a library function somewhere that does the same thing.
15:10:39 <quchen> I don't understand the code. It would be less ugly if I could understand it by looking at it.
15:10:48 <ReinH> drewbert: what does it do?
15:11:07 <drewbert> what could I do to make it more understandable?
15:11:20 <cmccann> I think the default for Float and Double should be NaN on the grounds that NaN has very uniform interaction with all other float values
15:11:46 <ReinH> cmccann: heh
15:11:49 <tulcod> drewbert: what is it, if not some variant on fold{l,r}[1]['] ?
15:11:57 <cmccann> I further contend that the above is a better-supported argument than defaulting to 0 or 1
15:12:02 <ReinH> It looks like some sort of tree fold
15:12:10 <phaazon> the correct answer is: there shouldn’t be such a thing as a defalut value
15:12:13 <phaazon> that doesn’t make any sense
15:12:14 <ReinH> but it's hard to say
15:12:15 <Welkin> what does a "default" even mean in terms of a numeric value?
15:12:22 <phaazon> a value with a laws does
15:12:28 <phaazon> like (<>) and mempty
15:12:31 <kadoban> Yeah, it doesn't seems like Default instances should even exist for numbers and such.
15:12:32 <Welkin> yeah
15:12:41 <phaazon> for nothing at all
15:12:52 <phaazon> we don’t use values out of nothing
15:12:57 <phaazon> we compute things over them
15:13:01 <phaazon> so we actually associate them
15:13:05 <quchen> Maybe it's a law for Default that def is not ⊥. :-)
15:13:06 <phaazon> hence, laws
15:13:20 <phaazon> what a useful law :D
15:13:32 <cmccann> quchen: oh good point, that has even MORE uniform interaction with other values than NaN
15:13:35 <drewbert> I merges a list in the same manner as merge sort.  e.g. [a, b, c, d] becomes a `merge` b : mergefold [c, d] becomes (a`merge` b) `merge` (c `merge` d) 
15:13:41 <cmccann> quchen: and it works for all types!
15:13:49 <quchen> cmccann: BRB pull request
15:13:59 <quchen> class Bottom a where bot :: a; instance Bottom a where bot = bot
15:14:08 <ReinH> drewbert: You don't need to do all that
15:14:12 <ReinH> mergesort forms a monoid
15:14:19 <cmccann> quchen: looks good, ship it
15:14:29 <ReinH> so you just need a tree-shaped fold and the monoidal crush
15:14:31 <phaazon> quchen: I saw something similar in the void package
15:14:32 <phaazon> like
15:14:35 <phaazon> the absurd implementation
15:14:37 <quchen> cmccann: Needs some unit tests first
15:14:53 <quchen> phaazon: absurd has a sensible implementation.
15:14:54 <phaazon> but it’s trickier
15:14:57 <phaazon> yeah
15:15:05 <quchen> > absurd (error "foo")
15:15:06 <lambdabot>  Not in scope: ‘absurd’
15:15:10 <quchen> …
15:15:16 <phaazon> @let import Data.Void
15:15:17 <tulcod> ReinH: might this be more parallellizable?
15:15:18 <lambdabot>  Defined.
15:15:18 <cmccann> quchen: nah. empirically speaking, based on my experience as a software developer in industry, the default unit test is none at all
15:15:24 <phaazon> :t absurd
15:15:27 <lambdabot> Void -> a
15:15:32 <ReinH> tulcod: no.
15:15:45 <quchen> cmccann: didn't you know, ∃ ⇒ ∀?
15:15:53 <quchen> "Worked when I checked"
15:15:56 <tulcod> ReinH: why not?
15:16:02 <phaazon> I’ve always failed to understand how the typechecker doesn’t fire on such a function
15:16:08 <cmccann> quchen: sounds good to me
15:16:14 <phaazon> like, the EmptyCase extension sounds so silly 
15:16:21 <ReinH> tulcod: why would it be?
15:16:32 <tulcod> ReinH: because it has a lower call stack
15:16:48 <tulcod> ReinH: you can compute a`merge`b and c`merge`d simultaneously
15:17:17 <quchen> EmptyCase is useful to cure Void Blindness.
15:17:28 <phaazon> quchen: I just don’t get its use cases
15:17:28 <phaazon> like
15:17:31 <phaazon> case a of {}
15:17:43 <phaazon> what is the interaction of that with the type system?
15:17:44 <phaazon> I mean
15:17:46 <quchen> absurd a = case a of {}
15:17:53 <phaazon> case a of {} doesn’t even have a return value
15:17:57 <drewbert> ReinH: foldt?
15:18:49 <cmccann> phaazon: and if "a :: Void" then that case expression is exhaustive
15:18:57 <ReinH> drewbert: a tree-shaped fold, so foldt1 (+) [a,b,c,d] = (a + b) + (c + d) (using a non-empty version for simplicity
15:18:59 <ReinH> )
15:19:17 <tulcod> phaazon: doesn't it have a return value of type b?
15:19:27 <cmccann> phaazon: that's certainly no worse than being able to have non-exhaustive patterns matching on other types
15:19:27 <phaazon> tulcod: what is the sense of that?
15:19:33 <tulcod> phaazon: garbage in, garbage out
15:19:42 <phaazon> Void is no garbage
15:19:51 <tulcod> a value of type Void is garbage
15:19:54 <phaazon> no
15:19:58 <phaazon> because there’s no such value
15:20:04 <tulcod> undefined :: Void
15:20:12 <phaazon> ok
15:20:14 <phaazon> there’s bottom.
15:20:17 <phaazon> but that’s all
15:20:32 <tulcod> so mathematically this is all sane
15:20:56 <cmccann> phaazon: right, there's no values so you have no patterns in the case. seems sensible to me?
15:20:57 <tulcod> and it's perfectly acceptable for functions to output undefined on input undefined
15:21:01 <ReinH> drewbert: and you have the monoid for sorted lists, newtype Merge a = Merge [a], and instance Monoid (Merge a) where mappend = Merge []; Merge as <> Merge bs = Merge (merge as bs), where merge merges two sorted lists
15:21:15 <ReinH> (which is linear)
15:21:37 <quchen> phaazon: The GHC manual gives a very short motivating example. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html
15:21:38 <ReinH> drewbert: now, foldMap (Merge . pure) is insertion sort.
15:21:45 <phaazon> thanks quchen 
15:21:49 <ReinH> becaue at each point it merges a list with a singleton of the next element.
15:22:09 <quchen> phaazon: EmptyCase without other extensions is good for having custom empty data types. With other extensions it becomes more useful, because you can express "this has to be uninhabited" with it.
15:22:17 <ReinH> drewbert: a tree-shaped version is merge sort
15:22:31 <phaazon> quchen: that makes sense then
15:22:40 <drewbert> ReinH: I'm not necessarily sorting a list.  It's just a join operation for lists, prioritizing minimizing use of the join operator, for cases where joining is expensive.
15:23:14 <ReinH> drewbert: ok so you're actually trying to implement foldt
15:23:32 <ReinH> @google haskell tree-like folds
15:23:33 <lambdabot> https://wiki.haskell.org/Fold
15:23:57 <phaazon> ok, off to bed
15:23:59 <phaazon> see you later
15:24:05 <ReinH> drewbert: which uses log n merge operations, the minimum
15:24:16 <drewbert> ReinH: I read that as soon as you said tree-like folds earlier. :-)
15:24:21 <ReinH> drewbert: ok :)
15:24:31 <tulcod> ReinH: i'm pretty sure it uses n merge operations
15:24:36 <tulcod> or n-1 or whatever
15:25:03 <tulcod> but i guess you could say it has a "merge complexity" of log n?
15:25:06 <ReinH> tulcod: you're right. It has log n steps.
15:25:19 <ReinH> well, that's poorly worded too.
15:25:23 <tulcod> merge "depth"?
15:25:31 <ReinH> the tree of merge operations has height log n
15:25:38 <tulcod> :)
15:26:38 <hackrilege> Simulations are often repeated operations on an object which is seen as progressing the system through many timesteps. In representing this operation as a monad I can deduce that  such operation must implement join, and if it need not then it is just an Applicative Functor. How can I interpret join in this context?
15:27:30 <hackrilege> And doors that question make sense?
15:27:35 <hackrilege> Does
15:27:44 <ReinH> hackrilege: start by interpreting the operation as a semigroup action.
15:27:47 <cmccann> hackrilege: that depends on what kind of monad representation you have in mind
15:27:53 <ReinH> And see if you're missing anything.
15:28:10 <hackrilege> Ok brb
15:28:58 <cmccann> hackrilege: does the value you're applying join to represent a progression of values over time which are each an independent progression of values over time?
15:29:24 <ReinH> (discrete timesteps can also be represented as a function from the nats)
15:29:44 <ReinH> :t iterate
15:29:45 <lambdabot> (a -> a) -> a -> [a]
15:29:57 <cmccann> if so then the monad instance is basically taking the diagonal and is horribly inefficient while being no more expressive than Applicative if you're computing each step iteratively
15:30:05 <hackrilege> Cmccan I'm not sure what you mean. You mean how I implement join? I mean rather, what does it mean that a monad must implement join as a class of computation more complex than an Applicative Functor
15:30:43 <ReinH> one interpretation is that iterate takes a semigroup action and gives the sequence of results that approach the fixed point.
15:31:05 <ReinH> I think there's another name for "sequence of results that approach the fixed point" but I can't remember it off hand
15:31:16 <cmccann> hackrilege: mostly it means I'm not sure what your monad is
15:31:18 <hackrilege> Great, so that's enough, we don't even need fmap
15:31:23 <ReinH> and, since [a] is isomorphic to Nat - > a, both representations are isomorphic
15:32:52 <Welkin> is there a nice way to slice up a Word32 into 4 Word8?
15:33:04 <Welkin> besides the obvious bitshift and mask operations
15:33:08 <drewbert> I wish it would stop blowing my mind that foldl' is implemented using foldr
15:34:14 <cmccann> Welkin: serialize it to ByteString using Data.Binary or whatever and then unpack that into a list of Word8s? :P
15:34:18 <hackrilege> We can always implement a class's functionality without instantiating that class, but it would be helpful to if we got some nice lemmas or corolries or intuition for free by instantiating which classes we trivially can
15:34:33 <cmccann> Welkin: disclaimer: the above method may not qualify as 'nice'
15:34:41 <dmwit> cmccann: Sorry, was AFK for a bit. I doubt I will find another person who wants this. I doubt I will find another person who uses Chronicle.
15:34:52 <ReinH> cmccann: I was about to say "for some version of nice"
15:35:11 <dmwit> cmccann: But until it's available, I will continue defining dictate' c = def <$ dictate c in the projects that use Chroncile. =)
15:35:23 <tulcod> Welkin, cmccann: if you're going for that route, think about endianness
15:35:29 <pavonia> How do you tell cabal to skip building the exectuables defined in the cabal file?
15:36:15 <dmwit> I don't buy the "no laws, therefore 100% not useful" argument.
15:36:23 <cmccann> tulcod: most reasons for splitting a Word32 into bytes are going to need to worry about endianness anyway
15:36:28 <dmwit> Sometimes you want a value, and you don't care what it is. Boom, Default is useful.
15:36:48 <quchen> Why not bottom?
15:36:49 <kadoban> dmwit: If you really don't care what it is, why not 'undefined' ?
15:36:57 <tulcod> dmwit: what about the "orphan instances" argument?
15:37:08 <dmwit> kadoban: Because I may still do computation on it (though I don't care what computation is done).
15:37:20 <cmccann> dmwit: which is true, but I can't remember the last time I didn't even care enough to pick my own arbitrary value :P
15:37:41 <quchen> You can do computations on bottom as well.
15:37:47 <quchen> Such as ignoring it. :-þ
15:38:19 <drewbert> Why not zoidberg?
15:38:20 <dmwit> tulcod: What about it? Just because data-default currently uses orphan instances to avoid having a million dependencies doesn't mean that's a fundamental fact about the Default class.
15:38:38 <kadoban> dmwit: I don't think I know why you'd ever do that.
15:38:44 <tulcod> dmwit: i would call it a pretty fundamental fact about the Default class
15:38:47 <dmwit> tulcod: The original data-default had no orphan instances. Are you going to claim that one sucked, too? Because I don't think it did, and the new one makes a tough but practical tradeoff.
15:38:52 <kadoban> You're using computing and using a result you don't care about? :-/
15:39:25 <tulcod> dmwit: "had" versus "invites"
15:39:40 <dmwit> kadoban: Yes. For example, I'm doing some possibly-error-ful computation on a big tree. I'd like to report all the errors I can rather than just the first. One convenient way to do that is to return a value even in error cases and continue the transformation; then at the end throw away the result but keep the errors.
15:40:13 <dmwit> tulcod: Default doesn't obviously invite orphan instances more than Monoid does, say.
15:40:14 <drewbert> foldt is useful for joining HashMaps
15:40:44 <tulcod> dmwit: why don't you add the def field to your class instead? so you don't need the data-default dep, you won't invite hatred, and reduce any orphanness
15:40:51 <dmwit> kadoban: But what value should I return in error cases? Well, it doesn't really matter except that it has to be something of the right type, so the rest of the computation can proceed.
15:40:52 <hexagoxel> pavonia: you can `cabal build $component`; so if you `cabal build $library-name` it will only build the library. often, the cabal file will also have flags to enable what is "buildable" at configure-time. then, after configuring (once) with the appropriate flags, you can simply `cabal build`.
15:40:54 <chpatrick1> dmwit: the problem with Default is that it's totally arbitrary
15:41:02 <chpatrick1> "def is some value of type a"
15:41:32 <chpatrick1> also it has instances for a bajillion things so it's easy to make a mistake
15:41:33 <dmwit> tulcod: Why duplicate code? Why write the same instance over and over for tons of different classes, when Default already does it?
15:42:12 <drewbert> Also it is useful for multiplying large "Integer"s (not "Int"s)
15:42:14 <hackrilege> Semigroups omg
15:42:22 <numberten> ReinH: [a] is isomorphic to Nat -> a.. never thought of that before
15:42:22 <tulcod> dmwit: because i won't touch instances of Default with a 10 foot stick
15:42:35 <tulcod> (though that might not matter to you)
15:42:47 <tulcod> (especially since, like you said, I probably won't use Chronicle)
15:43:15 <dmwit> You're right, "what tulcod would do" doesn't matter to me right up until the moment tulcod is sitting next to me on a project.
15:43:16 <numberten> specializing for unit is obvious, less intuitive for |a| > 1, but I think I see it
15:43:22 <dmwit> "Why tulcod would not do it" *might* matter to me.
15:43:28 <drewbert> let !a = foldl' (*) 1 [1000000,999999..1] takes for fraggin' ever.  foldt does not.
15:44:15 <pavonia> Sorry, got disconnected. How do you tell cabal to skip building the exectuables defined in the cabal file?
15:44:16 <tulcod> dmwit: well, I guess that in a strict sense, what you're proposing is a solution
15:44:39 <tulcod> dmwit: so if you really just want *any* value, and have a good reason for passing that on, i mean yeah, given those facts, of course Default is relevant
15:44:50 <tulcod> it's just that in most cases, you don't /really/ want that
15:45:00 <tulcod> so i guess that's why we're being careful in saying "OK yeah do that"
15:45:52 * cmccann thinks all the "Default is evil" stuff is a little overblown tbh, but doesn't think instances for types like Integer or Bool make sense
15:45:59 <tulcod> and now in the case that you don't /really/ want that, users of your lib are stuck to this decision
15:46:08 <tulcod> and they have to provide a default value even if they don't want to
15:46:12 <hexagoxel> pavonia: http://tunes.org/~nef/logs/haskell/15.09.15
15:47:06 <dmwit> cmccann: Yeah, I'm not sure. It's a tough call; though I have to say I'd rather there be a single canonical weird instance than lots of different weird orphan instances spread around in lots of different packages. =P
15:47:39 <chpatrick1> why have one at all?
15:47:41 <dmwit> tulcod: There's no stuck. Users of the lib can choose `dictate :: c -> m ()`, the current type, because `()` is an instance of `Default`.
15:47:47 <pavonia> hexagoxel: Thanks, trying that
15:47:52 <chpatrick1> when having a default doesn't make sense
15:47:55 <chpatrick1> like with Bool
15:47:56 <tulcod> dmwit: ah right, because you're defining dictate'
15:48:01 <cmccann> like, say you have a "frobnicate :: FrobnicationOptions -> a -> b" where frobnicate takes a record of fiddly details controlling how it behaves. if you're providing frobnicate in a library you really should also provide a set of sensible default options to use
15:48:05 <tulcod> dmwit: but then why can't users define dictate' themselves?
15:48:15 <cmccann> for which having a Default instance actually is meaningful
15:48:25 <dmwit> tulcod: They can. But the point of libraries is to share code so that people don't have to reimplement everything every time.
15:48:41 <tulcod> dmwit: okay but this is a very short oneliner
15:48:50 <tulcod> that might avoid big debates like these
15:48:58 <dmwit> tulcod: The Prelude is full of very short oneliners.
15:49:07 <dmwit> So are many other libraries.
15:49:11 <dmwit> That doesn't make them unuseful.
15:49:18 <tulcod> if people think Default is evil, they don't write the oneliner. if they think it isn't, they add it and move on with their lives
15:49:36 <tulcod> anyway, i think i said enough
15:49:41 <dmwit> Good advice. I plan to move on with my life.
15:51:40 <cmccann> meanwhile, I'm still considering the merits. needing an arbitrary but non-bottom value does actually make a lot of sense for the intended use of "dictate".
15:52:04 <dmwit> What is the intended use of "dictate"?
15:52:17 <dmwit> I can tell you my actual use, if that matters. (I actually described it briefly above.)
15:52:18 <cmccann> pretty much what you described earlier
15:52:35 <cmccann> give or take
15:54:41 <cmccann> particularly in that using e.g. Maybe is counterproductive because the whole point of collecting non-fatal errors is to keep chugging and Maybe will shortcircuit any remaining logic based on earlier stuff
15:56:11 <cmccann> like, the vague use case I had in mind for this was parsing semi-garbage data where you want to extract as much as you can and throw out the rest
15:56:30 <cmccann> and turning false negatives into non-fatal errors is better than having no false positives and blowing up
15:56:36 <cmccann> er, no false negatives
15:57:11 <dmwit> We have a homebrew analog of Chronicle (I didn't know about Chronicle yet). There are 30 calls to our Default-polymorphic analog of dictate, and 8 of them are at () type.
15:57:24 <dmwit> So... yeah, () is the minority use.
15:57:41 <ReinH> dmwit: what's chronicle?
15:57:45 <dmwit> ?hackage these
15:57:45 <lambdabot> http://hackage.haskell.org/package/these
15:57:52 <nitrix> :k StateT
15:57:53 <lambdabot> * -> (* -> *) -> * -> *
15:58:17 * cmccann wonders incidentally why there's no documentation built for that
15:58:51 <ReinH> neat
15:58:56 <cmccann> does hackage not do that automatically anymore or something?
15:58:57 <dmwit> cmccann: Okay, our use case is a bit different: if it's garbage, we throw out the result entirely.
15:59:06 <ReinH> cmccann: might be in a queue
15:59:15 <dmwit> cmccann: So generating some garbage output on garbage input is *totally* fine.
15:59:47 <ReinH> cmccann: "retcon", awesome
16:00:18 <cmccann> dmwit: similar in spirit though, in that garbage output is to some extent expected
16:00:25 <dmwit> right
16:01:00 <cmccann> ReinH: when I wrote that module I was feeling ESPECIALLY fond of cute names at the time
16:01:22 <ReinH> indeed :)
16:03:07 <cmccann> dmwit: and of course saying garbage output is somewhat expected tends to undermine the complaint that "default" is meaningless in this case, heh
16:04:00 <nolrai666> Hmm. Feels like there should be a type class for things that interact like intersect and union.
16:05:06 <exio4> ring? semiring? rng? 
16:06:08 <nolrai666> I think just rig.
16:06:37 <shachaf> distributive lattice?
16:07:27 <cmccann> dmwit: I'm still not really feeling the whole "change the type of dictate" thing, both because it's already there and because I'd like to keep a direct analog of 'tell'.
16:09:34 <afonso> can anyone help me?
16:09:39 <afonso> with a gloss related question
16:11:14 <pavonia> afonso: We cannot tell for sure without knowing the question
16:12:23 <afonso> pavonia: you're right
16:12:27 <Welkin> hmm
16:12:30 <Welkin> this turns out to be tricky
16:12:35 <Welkin> I have a Word32
16:12:45 <afonso> so in gloss (the graphics library) how can I set a fixed size for the window?
16:12:47 <Welkin> and I want to mask off the lowest 8 bits to create a Word8
16:12:50 <afonso> I see no option for this
16:12:56 <Welkin> but .&. :: a -> a -> a
16:13:00 <Welkin> so that won't unify
16:13:10 <Welkin> Word32 -> Word8 -> Word8
16:13:25 <monochrom> I think fromIntegral will give you the lowest 8 bits.
16:13:48 <ReinH> Yep.
16:14:30 <Welkin> > (fromIntegral (0xff0a :: Word32)) .&. (fromIntegral (0xff :: Word8)) :: Word8
16:14:32 <lambdabot>  10
16:14:35 <Welkin> huh
16:14:52 <Welkin> I keep forgetting that Word8/32 is Integral
16:14:52 <monochrom> no, you can skip the .&.
16:14:57 <ReinH> > fromIntegral (0xFF01 :: Word32) :: Word8
16:14:58 <Welkin> what?
16:14:59 <lambdabot>  1
16:15:02 <ReinH> That.
16:15:05 <ReinH> It truncates.
16:15:08 <Welkin> that is strange
16:15:10 <Welkin> why?
16:15:14 <ReinH> What else would it do?
16:15:24 <Welkin> oh
16:15:26 <Welkin> I see
16:15:35 <Welkin> you provided the type Word8
16:15:39 <ReinH> yep
16:16:05 <Welkin> well that makes it easy
16:16:17 <Welkin> I was going to pull out all the bit shifting and masking operations
16:17:26 <cmccann> Welkin: on the off chance you're already using lens in that program, there's also http://hackage.haskell.org/package/lens-4.13/docs/Data-Bits-Lens.html#v:byteAt
16:17:45 <monochrom> interesting
16:17:59 <cmccann> or "bytewise" which is probably what you'd actually want
16:18:49 <cmccann> > (0x12345678 :: Word32)^..bytewise
16:18:50 <lambdabot>  [120,86,52,18]
16:19:02 <ReinH> nice
16:19:12 <ReinH> worth it just for that
16:19:16 <cmccann> totally
16:19:22 <monochrom> haha
16:19:24 <cmccann> justifies the entire lens package
16:19:32 <ReinH> not even joking
16:20:16 <monochrom> oh, I could use it for converting IPv4 addresses between Word32 and dot notation
16:24:07 <Welkin> wow that is really cool cmccann 
16:24:36 <Welkin> monochrom: that is what I am doing right now, haha
16:24:43 <monochrom> heh
16:24:46 <Welkin> although I am not using lens
16:24:58 <cmccann> Welkin: maybe you should be!
16:25:07 <arkeet> everyone should use lens.
16:25:41 <cmccann> seriously, stuff like bytewise is probably why the lens package is so massive but, y'know, when it's what you need it's really handy
16:26:33 <arkeet> > (0 :: Word32) & bytewise +~ 1
16:26:35 <lambdabot>  16843009
16:26:46 <quchen> Everyone who needs lenses should use lens.
16:26:48 <arkeet> > (0 :: Word32) & bytewise .~ -1
16:26:50 <lambdabot>  4294967295
16:26:53 <quchen> Everyone else should not.
16:26:54 <arkeet> meh.
16:28:29 <quchen> I don't think you should use it lightheartedly, because it raises the "required haskell level" for programmers quite a bit.
16:28:51 <quchen> For large projects the benefits outweigh the drawbacks though.
16:30:51 <cmccann> I only use lens solemnly, with a heavy heart and weary soul
16:31:16 <monochrom> this is a huge gray area
16:31:33 <edwardk> i'm even conflicted about recommending lenses to newcomers myself, fwiw.
16:31:42 <sm> what about microlens
16:32:01 <edwardk> i like to show off the power of haskell with them, but then i usually encourage folks to go use other abstractions for a while and come back when they have a sense of when lenses are appropriate
16:32:15 <edwardk> sm: it'd be great if prisms didn't exist
16:32:20 <edwardk> and if i wanted orphans for everything
16:32:37 * sm takes note
16:32:51 <sm> I'm getting close to lensifying my things
16:33:14 <quchen> Maybe the Lens and Prism types should become household names for Haskellers, but you can't require that for the entire lens synonym zoo.
16:33:14 <edwardk> so for a one-off project that isn't a library that nobody has to interoperate with that never needs to use anything that looks like a prism and doesn't need indexing? you could probably get away with it
16:33:26 <sm> it looks like microlens will meet my simple needs without preventing me from jumping to lens later
16:33:40 <quchen> There are functions like "view" and friends that should also be universal.
16:33:47 <edwardk> quchen: *shrugs* the benefit of the lens formalism is you don't need to know all the properties of the intermediate levels
16:33:50 <edwardk> they just work
16:34:07 <edwardk> but when you absolutely need the distinctions they are there for you
16:34:46 <quchen> edwardk: Sure, but sometimes you have an Optical something and you need a Lens' and then it's a journey to finding out whether those match, and whether the typechecker complains because of that mismatch or some other type error.
16:34:59 <johnw> edwardk: is there any construction that takes a list of prisms, and uses the first that matches?  I.e., foo & [ _Left._1 , _Right._2 ] .~ 0, assuming they address the same underlying type?
16:35:04 <quchen> I frequently run into that issue, for example.
16:35:05 <cmccann> the basic idea of composing traversals seems like something worth exposing people to, independently of lens or anything that sounds lens-related
16:35:15 <edwardk> quchen: and yet i have no option there. if i don't leak all those details into the type, then lens doesn't work
16:35:17 <sm> relatedly, after learning a bit about the k and j languages, I suddenly am finding lens operators much more approachable
16:35:28 <cmccann> the fact that anything in vaguely the same shape as a traversal probably works with lens to some extent is another matter
16:35:28 <edwardk> johnw: hrmm
16:35:36 <quchen> edwardk: I'm not blaming you by any means!
16:35:40 <shachaf> cmccann: Well, traversals are probably the main point of lens.
16:36:25 <edwardk> johnw: you can use 'preview' to turn each into a Maybe, then go find the first Just  -- would give you the ability read, but you want to write
16:36:30 <edwardk> i'm not sure if that is sound yet =)
16:36:38 <johnw> edwardk: i'll play around and get back to you on that one then
16:36:49 <edwardk> if i had it to rename all over i probably would have called the package 'traversals'
16:36:54 <johnw> I sort of what to have a "lens case", where the "patterns" are prisms
16:36:58 <johnw> want*
16:37:02 <edwardk> johnw: makes sense
16:37:09 <edwardk> you only need a fold to match
16:37:11 <arkeet> :t _Left <> _Right
16:37:29 <arkeet> ?
16:37:35 <edwardk> so change your viewpoint to look for that =)
16:37:54 <arkeet> anyway folds form a monoid
16:38:01 <arkeet> and prisms are folds
16:38:09 <edwardk> ^?(_Left <> _Right) will get the first match
16:38:12 <shachaf> I think "traversals" would be a good name for lens 3.0 or so.
16:38:42 <edwardk> but you can't write back to it
16:38:45 <arkeet> right.
16:39:47 <arkeet> but if you want to pick out the prism that matches then I dunno.
16:40:30 <edwardk> :t failing
16:40:36 <edwardk> you can probably use that
16:41:17 <edwardk> :t foldr failing ignored
16:41:22 <arkeet> lambdabot is ogne
16:41:22 <edwardk> oh, lambdabot is dead
16:41:25 <edwardk> anyways
16:41:26 <edwardk> that
16:41:49 <edwardk> ignored will act as a unit and failing will fall over to the second thing if the former has no matches
16:43:35 <edwardk> >>> Right (1,2) ^? foldr failing ignored [_Left, _Right._2]    ==> Just 2
16:43:49 <edwardk> johnw: that fit the bill?
16:43:55 <johnw> trying it in ghci
16:46:33 <Axman6> :t _Left <> _Right
16:46:50 <Axman6> lambdabot D:
16:47:16 <NemesisD> is there a good pattern for Monad m => [m (Maybe a)] -> m (Maybe a), i.e. try several monadic actions and returning the first success  (probably via Alternative?)
16:47:56 <edwardk> NemesisD: you can use msum or asum for MaybeT m
16:48:11 <edwardk> but you need to convert m (Maybe a) to MaybeT m a first, then msum it
16:49:07 <NemesisD> ah ok so like runMaybeT . msum . map MaybeT
16:49:10 <NemesisD> thanks!
16:49:31 <johnw> edwardk: yeah, that works perfectly
16:49:36 <johnw> > [Left (0,1),Right (1,2)] & traverse.failing (_Left._2) (_Right._2) .~ 5
16:49:39 <johnw> [Left (0,5),Right (1,5)]
16:49:52 <johnw> with the foldr to make it a list, of course
16:50:02 <edwardk> yep
16:50:05 <johnw> thanks!
16:50:14 <edwardk> ignored acts as a unit for failing
16:50:23 <edwardk> there is some sort of social commentary there
16:50:49 <johnw> haha
16:55:27 <quchen> And failing is associative?
16:55:36 <edwardk> yeah
16:56:20 <quchen> Maybe I should present failure as a practical example of monoids in my next Haskell workshop then.
16:56:25 <simon> edwardk, why make a language like Ermine? can row types do things that Haskell's types can't?
16:56:29 <quchen> It sure has practical, everyday relevance.
16:56:54 <edwardk> simon: better inference for sql types
16:59:32 <edwardk> join :: (a <- (d,e), b <- (e,f), c <- (d,e,f)) => Rel d -> Rel e -> Rel f -- gives an example of a type in ermine that is 'just a bit' outside of  what we can say with haskell. there it says that we can partition the fields each of the relations into various sets, d, e and f and that we can stich the result together out of them. this lets us infer some
16:59:32 <edwardk> information both forward about the output as well as backwards towards the inputs from the combination of another input and the output, etc.
17:08:06 <simon> edwardk, mhm. I'll have to read up on those. are they commonly known as row types? I can find something on row polymorphism.
17:08:22 <edwardk> simon: the form i use in ermine is a bit exotic
17:08:51 <edwardk> pchiusano had a random idea about how to unify 'has' and 'lacks' constraints into a single 'can be partitioned into' constraint, and we ran with it
17:09:49 <pchiusano> in retrospect, I'm not sure it was such a hot idea
17:10:54 <Welkin> lazy bytestrings are a massive pain
17:11:14 <Welkin> it seems only logical to convert lazy bytestring to strict as soon as possible
17:11:28 <Welkin> and then only convert them back to lazy bytestrings when you need to send them out on the network
17:39:01 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
17:39:01 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:24 2015]
18:05:09 <dan> haskell beginner here, so sorry for the basic questions
18:06:11 <rcyr_> dan: I know you haven't asked your questions yet but just so you know, you can also ask your questions on #haskell-beginner , people there are also awesome :)
18:06:14 <dan> i have a list of lists of ints, where i know each inner list is only 3 long, which I want to pass through a filter. how do i access those elements correctly if i have a function that takes [Int] ?
18:06:39 <dan> ohh, didnt know there was a beginner chatroom too!
18:06:52 <rcyr_> Err, my bad
18:06:58 <rcyr_> It's #Haskell-Beginners
18:07:01 <rcyr_> With a s
18:07:06 <exio4> dan: this channel is perfectly fine for beginners questions too
18:07:43 <dan> thanks
18:08:20 <rcyr_> dan: What does that function do?
18:08:55 <dan> so, I have my function type as isPythagorean :: [Int] -> Bool, and then I wanted to say something like isPythagorean (x:y:z) = x**2+y**2 == z**2
18:08:58 <Gurkenglas> dan, map (\[x, y, z] -> stuff)
18:09:54 <Shockk> dan, if you writing that definition, you'd do 'isPythagorean [x,y,z] = ...' 
18:10:26 <dan> le sigh, this is why I need the beginners chatroom. I get confused on when to put in type information and when to put in variables. 
18:10:38 <Shockk> : is used to put an element onto a list, not put two elements together 
18:10:38 <Gurkenglas> (*filter, of course)
18:10:44 <dan> meaning, I tried isPythagorean [Int, Int, Int] -> Bool which it didn't like
18:11:04 <dan> yeah, the cons operator, I realized that after I said it, sorry
18:11:12 <Shockk> cons, that's the name yep
18:11:16 <Shockk> I forgot it
18:11:32 <dan> i only know cause i also have Learn You as Haskell open :)
18:11:40 <exio4> note that the code you wrote happens to be pretty unsafe in the sense that it crashes on wrong inputs
18:11:41 <dan> a Haskell*
18:11:50 <exio4> so if you want 3 elements, maybe a tuple is better
18:11:58 <exio4> or.. just three parameters
18:12:05 <exio4> oh, it's inside a list, so a tuple
18:12:43 <dan> yeah, that's what I thought at first, but then the *other* side of the problem (projecteuler #9) is where i sum the lements, and that understandably doesnt work on tuples, since they can be of mixed types
18:13:15 <exio4> you can implement a function sumtuple :: Num a => (a,a,a) -> a
18:13:43 <dan> that sounds simple and straight forward enough :)
18:14:09 <wkoszek> Hello folks.
18:14:16 <exio4> hi wkoszek!
18:14:34 <wkoszek> I picked up Real World Haskell recently and started playing with exercises.
18:16:09 <wkoszek> For the sake of seeing if Haskell is "stable", I checked it in here: https://travis-ci.org/wkoszek/book-real-world-haskell/builds/80375440
18:16:48 <wkoszek> The fix I had to apply to get what you see in Travis is this:
18:16:49 <wkoszek> https://github.com/wkoszek/book-real-world-haskell/commit/4b67a49298a8a4a34e7f3dbc886248172931836c
18:17:01 <geekosaur> if you like stable API(s you may have come to the wrong place
18:17:02 <Axman6> RWH is pretty out of date at this point
18:17:21 <wkoszek> Question: did --# comments get deprecated?
18:17:44 <geekosaur> I mean, the most recent ghc release featured two major breakages (applicative-monad and foldable/traversable)
18:17:55 <geekosaur> exceptions changed a couple months after RWH was published
18:18:01 <Axman6> wkoszek: --# isn't a comment, it's a valid operator
18:18:07 <Axman6> -- # should work
18:18:28 <wkoszek> Axman6: RWH had that in their source code, but it wasn't working.
18:18:36 <Axman6> > let a --# b = a + b in 4 --# 7
18:18:48 <Axman6> bah, lambdabot!
18:18:52 <geekosaur> the haskell report states that -- starts a comment *and* that it must be a single token; if it is follwoed by valid operator characters then it will not be a comment
18:19:00 <Welkin> maybe you are thinking of pragmas? {-# LANGAUAGE DataKinds #-}
18:19:00 <wkoszek> Basically here's what ghci was giving me:
18:19:01 <wkoszek> https://travis-ci.org/wkoszek/book-real-world-haskell/builds/79693586
18:19:07 <Axman6> Cale: are you still responsible for lambdabot? if so, she's taking a nap
18:19:11 <geekosaur> so --#, --|, etc. are operators, not comments
18:19:16 <geekosaur> I think int-e runs lb
18:19:19 <Welkin> Axman6: isn't that int-e?
18:19:20 <Cale> no
18:19:27 <geekosaur> and I think the netsplits a while back did it in
18:19:33 <Cale> Right, int-e is running lambdabot
18:19:34 <Axman6> could be, it's been a while since I've needed to know. sorry Cale =)
18:19:36 <wkoszek> So I was getting: <interactive>:8:1: parse error on input `--#'
18:20:34 <dan> ok, still stuck here. I tried with tuples and now it doesn't want to let me do math on the tuple items, because i don't know how to tell it the types
18:20:55 <dan> isPythag :: (a, a, a) -> Bool
18:21:26 <Axman6> dan: I haven't seen your earlier comments, but you probably need a class constraint on a
18:21:32 <Cale> dan: You probably want at least (Num a, Eq a) => (a, a, a) -> Bool
18:21:35 <Axman6> so, something like Num a => (a,a,a) -> Bool
18:21:54 <Shockk> dan: ** is defined in the typeclass Floating
18:22:00 <dan> I tried doing Int a, is that wrong?
18:22:07 <dan> ahhh, Int != Floating
18:22:13 <Shockk> so if you're using ** as you did earlier, you would use a type constraint of Floating a =>
18:22:15 <geekosaur> Int is not a typeclass
18:22:23 <geekosaur> if you wanted Int then you would say Int instead of a
18:22:43 <dan> @geekosaur, that would probably be one of my main problems then
18:22:44 <geekosaur> but if you're using (**) then you don;t want Int (or maybe you want (^) or (^^) instead of (**), depending)
18:22:54 <wkoszek> So is there any better more up-to-date book than RWH ?
18:23:21 <cmccann> dmwit: https://github.com/isomorphism/these/issues/35
18:23:23 <wkoszek> My repo is showing more failures, and I'm pondering whether to filter through those, or whether I should pick a different book.
18:24:19 <dan> ah, I think I want ^, which may be getting me closer
18:24:23 <Axman6> wkoszek: you might check http://stackoverflow.com/a/23733494/19872
18:24:48 <Shockk> a typeclass is a set of definitions that an instance of that typeclass must implement, more or less, so for example ** is defined in the typeclass Floating, which has an Float instance as well as a Double instance
18:24:52 <Shockk> (late)
18:25:33 <Shockk> dan: in that case, you can find out which type constraints you need like so
18:25:39 <Shockk> :t (^)
18:25:53 <Shockk> oh I forgot the part where lambdabot was down :(
18:26:06 <Shockk> <lambdabot> (^) :: (Num a, Integral b) => a -> b -> a
18:26:10 <geekosaur> bots and netsplits don't mix :/
18:27:42 <wkoszek> Axman6: So sounds like that up until chapter 14 I'm fine?
18:29:40 <arkeet> ping int-e please rescue lambdabot
18:31:58 <Edison1984> ?src toUpper
18:33:39 <wkoszek> Is LearnYouAHaskell > RWC at this point?
18:34:44 <KaneTW> @where learnhaskell
18:34:48 <KaneTW> oh right
18:34:50 <KaneTW> rip lambdabot
18:34:55 <arkeet> https://github.com/bitemyapp/learnhaskell
18:35:04 <KaneTW> ty
18:36:52 <cmccann> I still think the best thing about these is that sentences are really confusing if you don't know I'm talking about a package named "these"
18:37:03 <cmccann> 100% justifies the name imo
18:37:13 <Guest66011> @help
18:37:15 <arkeet> :-)
18:37:20 <arkeet> I love these.
18:38:16 <Guest66011> Could anybody tell me why "@help" do not work as specified in https://wiki.haskell.org/IRC_channel Section 6.1?
18:39:24 <cmccann> Guest66011: probably because lambdabot is AWOL right now
18:40:31 <Guest66011> @help
18:40:44 <Guest66011> @help
18:41:05 <cmccann> that's not gonna work until lambdabot is back online
18:41:27 <bitemyapp> cmccann: these are really cool
18:41:27 <Guest66011> so where is 'it'?
18:41:50 <cmccann> Guest66011: offline because of network issues
18:42:33 <cmccann> bitemyapp: tbh though I think I need to advertise Data.Align more
18:42:49 <cmccann> since "zip with padding" is probably the most common use case for a type like These
18:43:15 <Guest66011> cmccann: Thanks. I'm a newbie ERC user....
18:43:52 <cmccann> Guest66011: no worries, just unlucky timing. lambdabot is usually pretty reliable.
18:44:35 <rrand> I'm new to haskell and confused by `liftIO` (from Control.Monad.IO.Class). The type signature is `liftIO :: IO a -> m a` which sounds to me like you're lifting `a` out of `IO` and into another monad. Is that right? based on how I've ssen it used in other peoples code, I'd expect it to be something like `liftIO :: IO a -> m IO a `
18:45:00 <geekosaur> that's not the type signature
18:45:09 <cmccann> rrand: instances of MonadIO are monads built on top of IO
18:45:27 <geekosaur> the type signature is: MonadIO m => IO a -> m a
18:45:31 <nullx002> hi
18:45:37 <geekosaur> the MonadIO part is important; it's how liftIO works
18:45:39 <cmccann> so it's not lifting something out of IO, it's wrapping something else around IO
18:45:47 <nullx002> how do i convert -1.12 to + 1.12
18:46:02 <geekosaur> basically, it ensures that you have an "m" that has an IO at the bottom
18:46:20 <Guest66011> λ> - (-1.12)
18:46:20 <Guest66011> 1.12
18:46:20 <Guest66011> λ> 
18:46:25 <geekosaur> and that every level knows how to reach the next level with an IO action, so that a chain can be built to the IO at the bottom of the monad stackl
18:46:32 <nullx002> no it is part of output
18:46:42 <rrand> geekosaur: interesting. so something like StateT has an IO under it?
18:46:43 <geekosaur> ?
18:46:50 <geekosaur> it can
18:47:42 <Guest66011> λ> abs (-1.12)
18:47:42 <Guest66011> 1.12
18:47:42 <Guest66011> λ> 
18:47:45 <geekosaur> the MonadIO instance for StateT looks something like: instance (MonadTrans t, MonadIO t) => MonadIO (StateT s t)
18:48:01 <rrand> yeah, its:
18:48:02 <geekosaur> so t has to be MonadTrans, and it has to have a MonadIO instance
18:48:05 <rrand> instance (MonadIO m) => MonadIO (StateT s m) where
18:48:05 <rrand>     liftIO = lift . liftIO
18:48:31 <geekosaur> (MonadTrans is how you can pass stuff down a Monad transformer stack)
18:48:39 <nullx002> does that apply to variable too?
18:48:50 <nullx002> like abs (-s1) ??
18:49:16 <Guest66011> λ> let x = -20
18:49:16 <Guest66011> λ> abs(-x)
18:49:16 <Guest66011> 20
18:49:16 <Guest66011> λ> 
18:49:24 <Guest66011> i just checked in my REPL
18:49:32 <geekosaur> (and IO has a dummy MonadIO instance: instance MonadIO IO where liftIO = id)
18:49:43 <rrand> oh, I see
18:49:50 <nullx002> does it work this way::  let n11 = abs (-n1) ??
18:50:37 <rrand> geekosaur: that makes a lot more sense. thanks!
18:50:50 <Guest66011> in GHCi, I think so
18:51:12 <nullx002> it throws an error: lexical error in string/character literal at character '\n'
18:51:19 <geekosaur> errrrr
18:51:27 <geekosaur> what exactly are you doing?
18:51:40 <geekosaur> if you are using abs then you do not have a string or character literal, one hopes
18:51:56 <nullx002> small code
18:51:59 <nullx002> let me paste it here
18:52:16 <nullx002> ouyput of n1 is always negative
18:52:23 <nullx002> so just want to convert it to +
18:52:31 <nullx002> code here:     main = do
18:52:32 <nullx002>  
18:52:32 <nullx002>         putStrLn "thickness of the paper in mm:"
18:52:32 <nullx002>         t <- readLn
18:52:35 <nullx002>         let n1 = (2 *  t * sqrt 3.1415) - (3/2)
18:52:38 <nullx002>  
18:52:41 <nullx002>         putStrLn ("n1: " ++ show n1)
18:52:44 <nullx002>  
18:52:47 <nullx002>         let n11 = abs (-n1)
18:52:51 <nullx002>  
18:52:52 <nullx002>         putStrLn ("n11: ++ show n11)
18:52:54 --- mode: ChanServ set +o geekosaur
18:52:55 <arkeet> please don't paste it here.
18:53:00 --- kick: nullx002 was kicked by geekosaur (nullx002)
18:53:01 <arkeet> next time use http://lpaste.net
18:53:03 <arkeet> lol
18:53:26 <geekosaur> if it's more than 2 lines, use a pastebin
18:53:28 <nullx002> sorry
18:53:30 <nullx002> was kicked off
18:53:31 <arkeet> use http://lpaste.net
18:53:37 <geekosaur> yes, I kicked you for flooding the channel
18:53:38 <nullx002> ok sorry for that
18:53:39 <geekosaur> if it's more than 2 lines, use a pastebin
18:53:50 --- mode: geekosaur set -o geekosaur
18:54:49 <nullx002> ok here it is: http://pastebin.com/j1tEPdn8
18:55:18 <geekosaur> so that code has an obvious problem that is not abs
18:55:30 <geekosaur> it is a missing close quote on line 11 (check the highlighting)
18:55:38 <geekosaur> *that* would lead to the error you claimed
18:56:15 <nullx002> oh sorry
18:56:31 <nullx002> stupid me
18:56:34 <nullx002> worked well
18:56:35 <nullx002> thanks
18:56:41 <Guest66011> pastebin.com is banned in our country.....
18:56:57 <nullx002> even when syntex highlighting is on :(
18:57:33 <pavonia> Guest66011: May I ask in what country you live?
18:57:39 <Guest66011> China
18:57:46 <EvilMachine> Hey… why do we say that functions are not data structures? (Or am I wrong in assuming that?)
18:58:02 <Guest66011> lpaste.net is ok, though i have never used it.
19:00:18 <cmccann> EvilMachine: because they're not defined with "data", I imagine
19:00:44 <Guest66011> does anybody use ERC? how can i fast type somebody's nickname in front of the message I want to give?
19:00:51 <cmccann> that seems like a matter of definitions, not objective classification
19:00:53 <EvilMachine> cmccann: Sorry, I just thought in a more abstract mathematical way…
19:01:03 <Lynn> Functions are data, I'd say... "Data structure" doesn't really mean much on a theoretical level
19:01:35 <ReinH> EvilMachine: I don't think it's a mathematic statement
19:01:44 <ReinH> *mathematical
19:01:50 <Lynn> Yeah, it doesn't have any mathematical meaning
19:02:06 <cmccann> yeah, I don't think "data structure" is meaningful outside the context of a broad family of programming languages
19:02:10 <bitemyapp> cmccann: squinting at the lax monoidal bit.
19:03:10 <bitemyapp> cmccann: there's been at least once or twice I could've used Data.Align if I'd know it existed.
19:03:11 <cmccann> bitemyapp: as you might guess from the "this insight is due to rwbarton" bit that was pretty much copy+paste from what he said on IRC
19:03:18 <Lynn> cmccann: I don't even think it's that. Like, I would call "data Bool = False | True" a data type, but I'm less sure about calling Bool a "data structure".
19:03:18 <geekosaur> Guest66011, http://www.emacswiki.org/emacs/ErcCompletion
19:03:26 <cmccann> bitemyapp: IOW don't ask me to explain that part ;]
19:03:59 <bitemyapp> cmccann: fair enough. squinty understanding is all I expect rn anyway.
19:04:13 <bitemyapp> cmccann: releasing 4 new chapters for the book tonight, incidentally includes applicative (lax monoidal functor lol)
19:04:24 <Lynn> It means a very specific... OOP-y thing, doesn't it? Where a data structure is specified by some abstract collection of data with operations you can perform on it, that can have any number of implementations?
19:04:26 <ReinH> bitemyapp: applicative is a closed functor :p
19:04:27 <Guest66011> 3ks
19:04:36 <bitemyapp> ReinH: yer closed
19:04:45 <ReinH> the strong lax monoidal functor stuff is unnececssaarily roundabout
19:05:05 <bitemyapp> ReinH: we take a middle position there.
19:05:24 <ReinH> there are no middle positions, only my positions and wrong ones
19:05:27 <cmccann> Lynn: fair enough. like I said, it's a matter of definitions. i.e., is it helpful to define something as a data structure or not
19:05:28 <bitemyapp> ReinH: try to provide some of the monoidal functor intuition, but don't go deep on the fuller representation.
19:05:45 <EvilMachine> cmccann: I found that all the problems mathematicians have with Gödel’s incompleteness theorem, infinity, zero, etc, comes from them always wanting to see everything as if it existed at the same step in the sequence. (Aka, they want the function to return and have a final value.) But for some things, the processing is part of the mathematical object, and you can’t name its “end result”, just like a endlessly r
19:05:46 <EvilMachine> ecursive function will never return. Infinity is such an example.
19:06:19 <ReinH> I don't think that's a good way to think about infinity or Godel
19:06:36 <cmccann> bitemyapp: I contend that nearly all practical intuition for using Applicative is based on interpreting it in terms of closed functors, not monoidal ;]
19:06:57 <ReinH> cmccann: exactly
19:07:20 * EvilMachine fully expects purely emotion-based reactions. :)
19:07:55 <bitemyapp> cmccann: well, when you write your book I'll get to learn about it
19:08:03 <bitemyapp> I can only offer the intuitions I myself have.
19:08:27 <bitemyapp> and I'm generally uncomfortable teaching something I've only just grasped as I've seen it lead to a lot of confusion.
19:09:41 <bitemyapp> now I'm trying to understand the ncatlab article on closed functor. I do not have time for this :P
19:10:07 <EvilMachine> bitemyapp: Understanding something, and understanding how to explain something, are two very different skill sets. :)
19:10:30 <EvilMachine> bitemyapp: People forget that all too often. I’m happy you don’t.
19:10:47 <cmccann> bitemyapp: http://cstheory.stackexchange.com/a/16264/53 contrasts the two in context of what a "dual" to Applicative would be
19:11:45 <bitemyapp> cmccann: ty ty ty
19:12:22 <bitemyapp> EvilMachine: just cautious. Try not to treat learners like petri dishes for something I just figured out the week before :P
19:12:24 <cmccann> bitemyapp: as a roundabout way of answering why "Monad : Applicative :: Comonad : ??" doesn't work as an analogy
19:13:07 <pdxleif> bitemyapp: When I was a math tutor, I was (apparently) able to explain something I had just learned the day before, and then the next day when I had the *exact* same question myself on a quiz, I drew a blank... :/
19:13:37 <bitemyapp> pdxleif: I've had that happen in Haskell too, but it's not a reliable process and learners, if they're curious, can exhaust your shallow well quickly.
19:13:59 <bitemyapp> cmccann: the issues highlighted in this SO question are why we only said "monoidal functor" and not the longer sentence.
19:14:15 <pdxleif> Yeah; I think I was only able to help them set up the problem and guide them in the right direction.
19:14:18 <bitemyapp> I'd actually read this ~1 year ago, but the reminder is good.
19:14:35 <bitemyapp> cmccann: I am usually very happy when you've answered something I'm googling :)
19:14:42 <EvilMachine> bitemyapp: :DD petri is my favorite dish! It makes me see amazing channels and the greatest colors on my TV. ;)
19:14:47 <cmccann> bitemyapp: thanks :]
19:15:25 <bitemyapp> I wasn't happy with the "strong lax MF" explanation for other reasons that might be related to what you explain the SO thread.
19:15:43 <bitemyapp> I just don't think the concepts map well, but I'm very green in all that anyway.
19:15:59 <ReinH> it's correct, but it's a bit of a stretch
19:16:07 <ReinH> when closed functor is a direct interpretation
19:16:21 <cmccann> bitemyapp: my main issue with the strong lax blah blah stuff is that it's got a very poor jargon-to-insight ratio for Haskell programming
19:16:41 <bitemyapp> cmccann: yes, that's a good metric.
19:17:17 <ReinH> I mean, we're already in a low density insight-to-jargon area to begin with
19:17:35 <cmccann> especially since Applicative is usually discussed in relation to Monad, which only makes sense in Haskell
19:17:45 <cmccann> for the reasons outlined in that answer
19:20:36 <cmccann> bitemyapp: the jargon basically boils down to "monoidal functor" meaning that you can lift (,) and "closed functor" meaning that you can lift (->)
19:21:06 <bitemyapp> cmccann: "can lift (,)" ~ strength?
19:21:22 <cmccann> no, strength means we can always go in the other direction
19:21:25 <cmccann> with any Functor instance
19:21:26 <bitemyapp> ah okay
19:21:34 <ReinH> strength is boring in haskell
19:21:54 <cmccann> I think
19:22:12 <cmccann> it's been a while, don't quote me on this without a sanity check :P
19:22:39 <ReinH> strength :: Functor f => f a -> b -> f (a,b) iirc
19:22:50 <cmccann> actually I think I'm misremembering, ReinH is correct
19:23:00 <cmccann> in any case it's something that sounds trivial in Haskell, because it is
19:23:08 <ReinH> which is just fmap (,b)
19:23:25 <cmccann> lax monoidal blah blah means (f a, f b) can become f (a, b)
19:23:30 <ReinH> right
19:23:55 <cmccann> (and that there's a f () corresponding to ())
19:24:59 <exio4> cmccann: strong means you can go from f (a,b) to (f a, f b), right?
19:25:34 <cmccann> no, I think I was wrong about that
19:25:37 <cmccann> I'd have to look it up
19:25:46 <ReinH> there's two kinds of strength here
19:26:03 <ReinH> with strong vs lax, the strong version is an isomorphism iirc
19:26:23 <ReinH> rather than just a homomorphism
19:26:40 <ReinH> there's "strong" and "with a strength".
19:26:48 <ReinH> Everything in Haskell is "with a strength".
19:26:51 <ReinH> at least iirc
19:27:08 <ReinH> another reason I prefer closed functor. None of this ridiculousness to remember.
19:29:26 <cmccann> bitemyapp: in any case, the type of (<*>) matches exactly half of the definition of a closed functor, while the type of pure doesn't really match anything exactly
19:30:49 <shachaf> cmccann: The type of pure matches the unit for a monoid in the category of endofunctors (with (:*:) as the product).
19:31:33 <cmccann> shachaf: ok fine, it doesn't match anything in the definitions of the stuff we were talking about
19:34:21 <noonan> I have a concurrency question..
19:34:49 <noonan> I have this program which needs to execute a large number of subtasks, each of which can be computed entirely in isolation
19:35:29 <noonan> Once a subtask completes, it causes the GUI to update.
19:35:30 <nullx002> hi
19:35:33 <nullx002> http://pastebin.com/Ya5hZ6kp
19:35:48 <nullx002> ths works well with value of thickness 0.115
19:35:53 <nullx002> but not with .115
19:35:57 <nullx002> it throws error
19:36:04 <noonan> I started with mapM_-ing forkIO over the subtasks
19:36:08 <nullx002> user error (Prelude.readIO: no parse)
19:36:42 <nullx002> http://pastebin.com/Ya5hZ6kp
19:37:01 <noonan> ..but then they all finish at roughly the same time.  What I'd really like is for the first few to execute to completion, then as each of those completes a new subtask is queued up.  That way, I'd be seeing progressive updates in the GUI.
19:37:42 <pavonia> nullx002: ".115" is not legal Haskell syntax for floating point numbers
19:37:50 <noonan> I didn't have much luck finding anything in Control.Concurrent that seemed like it would help.  Any ideas?
19:37:52 <nullx002> for user input?
19:37:58 <nullx002> users are suppose to enter it that way
19:38:03 <nullx002> anyway to convert it to 0.115
19:38:17 <cmccann> noonan: I feel like there's a library that does what you want but I can't recall what it was :T
19:38:18 <pdxleif> Maybe putting a thread sleep in them or something?
19:38:26 <pavonia> > read "0.115" :: Double
19:38:43 <pavonia> Oh, no bot
19:38:44 <pdxleif> Or you want the concurrency bounded by some pool?
19:38:44 <nullx002> but it is output of a function
19:39:02 <pavonia> nullx002: I don't thnk read will accept this syntax
19:39:09 <pavonia> or readLn
19:39:23 <nullx002> anyway to accept it?
19:39:31 <noonan> pdxleif: I'm not sure what you mean by pool here, can you clarify?
19:39:39 <nullx002> getline?? may be
19:39:42 <pavonia> You'd have to write you own parser
19:40:00 <nullx002> that is too much for such a simple code
19:40:01 <pavonia> Or in that case prepending the string with "0" should work too
19:40:17 <nullx002> just counting number of folds possible for paper of thickness t and length l
19:40:41 <pavonia> I won't work for negative numbers but you don't want them here anyway
19:40:57 <nullx002> no negative inputs 
19:41:30 <nullx002> as thickness can't be negative practically for a piece of paper
19:43:12 <pavonia> Try "t <- getLine >>= readIO . ('0' : )"
19:43:43 <pdxleif> noonan: I was thinking of a count shared between threads that each would decrement, and then re-increment as they completed; succesive threads would wait for that counter to be nonzero before continuing?
19:43:46 <broma0> Anyone know of any documentation on best practices regarding sum type & record accessor naming conventions? Your own opinions are welcome as well
19:43:56 <pdxleif> Maybe implemented in terms of an MVar or LVar or something?
19:44:08 <pdxleif> limiting the number of threads "in-flight" at any given time.
19:44:40 <noonan> Ah, I see. That seems like it might work well!
19:45:11 <noonan> Presumably I should set the count to something like getNumCapabilities? 
19:45:12 <pdxleif> noonan: Something like this, maybe? http://stackoverflow.com/a/18898822
19:46:20 <nullx002> let me check if it works
19:48:06 <nullx002> thanks :pavonia 
19:48:09 <nullx002> it worked
19:48:55 <slack__> broma0: the very best (but sighly heavyweight) practice is using lens' Prisms
19:49:53 <slack__> but for normal records and sum types, well more than dicipline in avoid name collision can get you far
19:50:23 <nullx002> pavonia thanks for the code, can you explain syntax, it would be helpful to me
19:51:10 <pdxleif> I wanna read through this book sometime: http://chimera.labs.oreilly.com/books/1230000000929/ch13.html
19:51:37 <pavonia> nullx002: "act1 >>= act2" is short for "do x <- act1; act2 x", it's called the bind function for monads
19:52:29 <pavonia> Actually, do-block are just syntactic sugar for monad functions
19:52:53 <nullx002> ok i will read it on wiki
19:53:14 <nullx002> one more thing,, sometimes tab doesn't work with code while spaces work
19:53:22 <nullx002> on emacs... why so?
19:53:32 <nullx002> i have haskell-indent-mode enabled
19:54:49 <pavonia> Tabs in Haskell code are replaced by the compiler with 8 spaces, so if you mix tabs with fewer spaces you may run into indentation errors
19:54:52 <pdxleif> I think they're going to disallow tabs in a future GHC version.
19:55:47 <KaneTW> are considered by the compiler to be 8 spaces
19:55:53 <nullx002> when i compile exec files become extremely large for such a small code
19:56:04 <nullx002> 300 bytes -> exec is 1.1 M
19:56:06 <KaneTW> runtime system is linked into each ahskell executable
19:56:24 <nullx002> that is binary file, right?
19:57:02 <KaneTW> binary containing garbage collector, scheduler, all that stuff
19:57:20 <nullx002> is it editable using hexedit or something similar?
19:57:20 <dolio> Tabs aren't 8 spaces. They are advances to the next tab stop, which occur every 8 columns.
19:57:46 <KaneTW> no
19:57:55 <nullx002> ELF editor ?
19:58:10 <KaneTW> why do you need small executables
19:58:29 <nullx002> nothing, never mind
19:58:31 <nullx002> just asking
19:58:54 <nullx002> just noticed that... big size
20:02:01 <pdxleif> Idris makes smaller executables...
20:02:19 <pdxleif> And has a much less advanced RTS.
20:07:11 <noonan> pdxleif: Thanks, using mapConcurrently along with wrapping the action by waitQSem / signalQSem works just right.
20:08:43 <pdxleif> nice!
20:09:09 <joseph07> I'm moving a project over to stack, but stack setup is complaining that there's no space left on the device, but there are 38G available
20:10:20 <pdxleif> There's QSem, MSem...
20:11:22 <pdxleif> MSem is supposed to be exception safe (unlike QSem)? https://wiki.haskell.org/SafeConcurrent
20:11:28 <mgsloan> joseph07: That's odd, that message definitely comes from some program "stack setup" invokes rather than from stack setup itself.  What OS are you using?
20:12:52 <joseph07> mgsloan: archlinux
20:13:43 <joseph07> mgsloan: that program is tar
20:14:43 <mgsloan> It's using "withSystemTempDirectory" - maybe your system temp directory is on a different partition?
20:14:58 <joseph07> ooooh that could be a problem
20:15:07 <joseph07> mgsloan: Yep that's exactly correct
20:15:33 <pdxleif>  /tmp is tmpfs, i.e. RAM by default on Arch
20:15:48 <joseph07> mgsloan: Bummer... I do not know how to go about making this work
20:15:51 <pdxleif> So it's easy to fill up if you use more than available system memory on it.
20:15:59 <mgsloan> Maybe we shouldn't use the temp directory for this
20:16:14 <pdxleif> I think /var/tmp would typically have more room.
20:16:35 <joseph07> mgsloan: pdxleif my temp partition appears to just half a gig, but ghc expanded is a little more than 1G I thing
20:17:00 * mgsloan creates an issue on the stack issue tracker
20:17:24 <pdxleif> There's some related thread in the Arch forums: https://bbs.archlinux.org/viewtopic.php?id=133988
20:17:30 <joseph07> mgsloan: link the issue?
20:18:23 <pdxleif> joseph07: They say you can change your tmpfs size: https://wiki.archlinux.org/index.php/Tmpfs#Examples
20:20:28 <joseph07> pdxleif: oh awesome. I didn't actually set this machine up myself so I didn't even know about tmpfs
20:21:12 <joseph07> pdxleif: Do you know whether 2G is sufficient?
20:21:55 <joseph07> pdxleif: It's a server and I just got an upgrade to 2G of ram, but that's it
20:22:02 <joseph07> pdxleif: guess I'll find out
20:22:30 <exio4> I wouldn't use a ram tmpfs there
20:31:32 <mgsloan> joseph07: https://github.com/commercialhaskell/stack/issues/996
20:33:53 <pdxleif> joseph07: I have't really used stack, sorry. :/
20:41:50 <mgsloan> joseph07: One approach would be to do the install yourself.  Something like https://gist.github.com/mgsloan/0c2b3cfefc3eb86508e2
20:54:07 * hackagebot hpack 0.7.1 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.7.1 (SimonHengel)
20:54:28 <haskell277> lambdabot is down?
20:54:49 <haskell277> \msg lambdabot id
20:55:59 <pdxleif> @type 5
20:57:34 <haskell277> @pl id
20:59:07 * hackagebot sbp 0.50.4 - SwiftNav's SBP Library  https://hackage.haskell.org/package/sbp-0.50.4 (markfine)
21:09:08 * hackagebot conduit-audio 0.2.0.1 - Combinators to efficiently slice and dice audio streams  https://hackage.haskell.org/package/conduit-audio-0.2.0.1 (mtolly)
21:09:10 * hackagebot conduit-audio-lame 0.1.0.1 - conduit-audio interface to the LAME MP3 library  https://hackage.haskell.org/package/conduit-audio-lame-0.1.0.1 (mtolly)
21:09:12 * hackagebot conduit-audio-samplerate 0.1.0.1 - conduit-audio interface to the libsamplerate resampling library  https://hackage.haskell.org/package/conduit-audio-samplerate-0.1.0.1 (mtolly)
21:20:45 <td123> how would i go about explicitly importing an infix type constructor along with its data constructors?
21:20:47 <td123> http://hackage.haskell.org/package/servant-0.4.4.2/docs/Servant-API-Alternative.html#t::-60--124--62-
21:21:09 <nitrix> Does a ++ b require the traversal of a and/or b?
21:21:41 <td123> import import Servant (((:<|>)(..))) gives me a parse error on input (
21:23:18 <td123> import Servant ((:<|>)) works but only imports the type constructor
21:25:03 <dmj`> td123: import           Servant.API ((:<|>)(..))
21:25:30 <dmj`> td123: one too many parens
21:28:15 <td123> dmj`: that worked, thanks
21:34:16 <Big_G> What is the best way to agregate errors?
21:35:12 <dmj`> Big_G: I've seen people use a Writer monad to `tell` all the errors into a list. Just an idea, there might be better ways
21:35:38 <Big_G> dmj`, Would that allow to have the "Happy path" value as well?
21:36:27 <dmj`> Big_G: if you have a default value in the case of failure, hard to say w/o knowing more of your situation
21:36:48 <Big_G> dmj`, :et
21:37:35 <Big_G> dmj`, Let's say I have a multiple DB calls that can each fail in different ways. I want to know if there was a failure but still get the query results if they exist 
21:41:22 <mrkgnao> :t fmap fmap fmap
21:41:50 <mrkgnao> wait.
21:41:57 <mrkgnao> where's lambdabot?
21:42:27 <nitrix> fmap fmap fmap :: (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:42:46 <Welkin> :t fap fap fap
21:43:26 <dmj`> Big_G: in that case I'd spawn all 3 at once (assuming all queries can be issued independendently) using async. Then waitCatch all of them, log the Left's, return the Right's. If all Left, fail gracefully
21:43:41 <dmj`> independently*
21:44:58 <nitrix> a ++ b, is a or be traversed?
21:45:09 <nitrix> s/be/b/
21:45:41 <Welkin> a
21:46:18 <Welkin> "has" ++ "kell" == 'h':'a':'s':"kell"
21:56:17 <tennix> > "has" ++ "kell" == 'h':'a':'s':"kell"
21:56:45 <Xnuk> > "has" ++ "kell" == 'h':'a':'s':"kell"
21:58:19 <Welkin> they are, of course, equal
21:58:25 <Welkin> I was showing how it is evaluated
21:58:52 <tennix> the bot died?
21:58:55 <Welkin> for now
21:59:11 * hackagebot envy 0.3.0.1 - An environmentally friendly way to deal with environment variables  https://hackage.haskell.org/package/envy-0.3.0.1 (DavidJohnson)
21:59:13 * hackagebot gc 0 - Poor Richard's Memory Manager  https://hackage.haskell.org/package/gc-0 (EdwardKmett)
22:00:04 <Welkin> dmj`: do you have a built-in way to perform auth using API keys in servant?
22:00:20 <Axman6> not yet, I think it's coming
22:01:47 <dmj`> Welkin: I store my auth settings in a JWT that lives in an HTTP header
22:02:01 <Welkin> Justice Warrior Tribe?
22:02:15 <dmj`> Welkin: there is a big auth pull request in the pipe for servant
22:02:27 <dmj`> Welkin: ha, http://jwt.io
22:02:54 <Welkin> oh, nice
22:03:00 <Welkin> I was looking for a way to do that
22:05:40 <dmj`> Welkin: yea, I'd use headers w/ servant, and the jwt pkg
22:05:44 <dmj`> @package jwt
22:06:05 <dmj`> https://hackage.haskell.org/package/jwt
22:06:36 <dmj`> Welkin: unless you plan on using it w/ a web browser. Then I'd store the jwt in a cookie and make it HttpOnly
22:07:14 <dmj`> brb
22:11:11 <kadoban> Doh, where are you lambdabot :(
22:17:24 * edwardk just emailed the poor richard's folks to let them know their paper makes an interesting little haskell library
22:22:34 <glguy> Hopefully people can start working on memory recycling, reduction, and reuse. Garbage collection seems less green
22:24:00 <glguy> Allocators could use a "free range" instead of a restrictive free list
22:31:31 <Axman6> glguy: what about a free tree, that's extra green
22:33:58 <glguy> locally-sourced memory might be useful?
22:34:19 <glguy> Axman6: Are you thinking of "fair trade"?
22:36:41 <edwardk> glguy: single stream recycling is where its at. throw it all in the rubbish bin and let them sort it out because we humans sorting at our houses suck.
22:37:15 <edwardk> but i could see running my processes with fair trade, free range, locally sourced bits.
22:38:11 <glguy> I wouldn't want to have to call different free procedures depending on if I got food on some memory or if it was particular large or something
22:38:31 <edwardk> exactly
22:38:45 <edwardk> now, the thc garbage collector so far is definitely not looking single stream
22:39:12 * hackagebot ghc-mod 5.4.0.0 - Happy Haskell Programming  https://hackage.haskell.org/package/ghc-mod-5.4.0.0 (DanielG)
22:39:23 <glguy> what about locally sourced?
22:39:34 <glguy> weren't you doing something we could relate to that?
22:39:44 <glguy> so that you could avoid stopping the world
22:40:38 <edwardk> that one is a mess, I now have to deal with different compaction schemes for letting unique items forward themselves, data constructors compact nicely,  closures need a form of semispace copying, etc.
22:41:02 <edwardk> local sourcing sounds a bit like letting us have a local space before we hand something out to the global space
22:46:24 <ttt_fff> is https://wiki.haskell.org/Parsing_expressions_and_statements what people mean by "Parsing Expressions" and if so, is it supposed to make it as easy to parse infix expressions (with operator precedence) as easy as parsing regex?
23:10:27 <julianleviston> Where would I find “where” in the haskell report (https://www.haskell.org/onlinereport/haskell2010/)
23:10:55 <julianleviston> under expressions? I’ll look there
23:11:58 <glguy> https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-620004
23:12:04 <glguy> It's part of declarations, not expressions
23:12:07 <julianleviston> oh.. it’s a case expression?
23:12:18 <srhb> No.
23:12:19 <julianleviston> oh.. ok
23:12:24 <glguy> let ... in ... is part of expressions, where is part of declarations
23:12:30 <srhb> Or do you mean it desugars to it?
23:13:00 <glguy> (at least generally)
23:13:14 <julianleviston> Um.. I don’t know
23:13:27 <julianleviston> so there are two “where”'s?
23:13:31 <srhb> There are more.
23:13:35 <julianleviston> oh
23:13:38 <srhb> module Main where, instance Foo a where, ...
23:13:43 <srhb> They are similar though.
23:13:46 <julianleviston> I guess I’m talking about let expressions
23:14:27 <julianleviston> trying to get a handle on that because I realised I can’t pull something apart because I don’t really know how to use let expressions properly. Haphazard way that I’m learning!
23:14:41 <srhb> There's let x = y in z and in do notation there's let a = b; ... which becomes let a = b in do expr
23:14:45 <srhb> Roughly
23:15:55 <julianleviston> so where does “where” come into it?
23:16:03 <julianleviston> i mean outside of do expressions
23:16:23 <srhb> foo = x where x = y for instance
23:16:34 <srhb> It's a locally scoped declaration.
23:16:35 <julianleviston> ok
23:16:46 <julianleviston> so where would I find a good explanation of that kind of let / where expressions?
23:16:56 <julianleviston> Like I really don’t understand what this means particularly: let x = 5 in x + 5
23:16:59 <julianleviston> I know that it works
23:17:10 <srhb> It's an expression, x+5, where you have set x = 5
23:17:14 <julianleviston> I can guess it means “evaluate x + 5 with the binding of x to be 5"
23:17:18 <srhb> It's all in the language report.
23:17:34 <julianleviston> srhb: cool - so where is it?
23:17:42 <julianleviston> in let expressions? does that include “where” ?
23:18:07 <srhb> Let expressions are 3.12, and no, that does not include "where"
23:18:10 <julianleviston> where seems to be in case expressions also
23:18:14 <julianleviston> ah
23:18:17 <julianleviston> so where is where?
23:18:25 <julianleviston> is it this thing in case expressions?
23:18:28 <julianleviston> 3.1
23:18:30 <julianleviston> 3.13
23:18:53 <srhb> "where" is under declarations, in 4.
23:18:56 <julianleviston> could i re-express let x = 5 in x + 5 as a where clause?
23:19:15 <srhb> no, where makes declarations, not expressions.
23:19:33 <srhb> Consider the difference between
23:19:35 <julianleviston> ah
23:20:02 <julianleviston> is x = 5 a declaration?
23:20:10 <julianleviston> 5 + 5 is an expression right?
23:20:10 <srhb> `foo = let x = 5 in x + 5` vs foo = x + 5 where x = 5
23:20:22 <srhb> 5+5 is an expression, yes. 
23:20:25 <julianleviston> oh sweet. that’s exactly what I wanted to know
23:20:29 <julianleviston> so they’re equiv?
23:20:42 <srhb> "they" ?
23:20:50 <srhb> foo?
23:20:58 <julianleviston> the let and where declarations you did above
23:21:09 <srhb> let and where are not equivalent. The two foos are both 10, yes.
23:21:28 <julianleviston> srhb: I meant the declarations, not where and let
23:21:37 <julianleviston> srhb: cool.
23:21:40 <julianleviston> srhb: thanks.
23:24:45 <julianleviston> > foo = x 5 where x = \x -> 5 + x
23:24:54 <julianleviston> how come that doesn’t work?
23:25:14 <julianleviston> > let foo = x 5 where x = \x -> 5 + x
23:25:41 <julianleviston> oh it does. nevermind
23:25:42 <srhb> It does work
23:25:46 <srhb> Heh. :)
23:25:55 <julianleviston> is lambdabot dead?
23:25:58 <srhb> Yeah.
23:27:29 <julianleviston> and this will work too… then foo = let x = \x -> 5 + x in x 5
23:27:32 <julianleviston> ok cool
23:28:00 <julianleviston> so these two uses, can they be thought of as equivalent? the let in and the  expression where ?
23:28:09 <julianleviston> just flipped around?
23:28:22 <liste> julianleviston let..in.. is an expression, where isn't
23:28:36 <liste> but yeah, they do the same thing
23:28:39 <julianleviston> no “expression… where” versus “let.. in"
23:29:27 <julianleviston> cool
23:29:47 <liste> where is associated with a pattern, let is standalone
23:30:17 <julianleviston> I keep wanting to write this… let x = 5 where x = (+ 1)
23:30:39 <liste> ... (+1) = 5 ?
23:30:40 <srhb> Even if that worked, it would be a type error :P
23:30:57 <julianleviston> sorry
23:30:59 <julianleviston> :S
23:31:44 <liste> and there's no such thing as "expression... where..."
23:31:49 <liste> just "pattern... where..."
23:31:52 <julianleviston> x = 5 in (x + 1) is fine then…?
23:32:03 <srhb> Missing a let.
23:32:05 <liste> let x = 5 in (x + 1) *
23:32:06 <julianleviston> liste: isn’t a pattern an expression? sorry
23:32:09 <srhb> There's no "in"
23:32:12 <liste> julianleviston no
23:32:25 <julianleviston> liste: here we go again
23:32:33 <julianleviston> liste:  thanks for your clarification
23:33:05 <julianleviston> when I said expression, I didn’t mean what you mean by expression, though.
23:33:14 <julianleviston> apologies for my imprecise language.
23:33:32 <julianleviston> I should have said “something where"
23:33:42 <liste> pattern is of form "foo a b c = expr"
23:33:46 <srhb> No need to be sorry, but the precision is really necessary when talking about this. It takes a while to learn :-)
23:33:51 <liste> where expr is an expresison
23:34:04 <srhb> liste: That foo is perhaps a bit confusing
23:34:08 <liste> yeah
23:34:11 <rola> hi!  how can i use hoogle to search for data constructors that have certain instances, such as Functor a, Monoid (f a)) => f a
23:34:17 <srhb> > let Just x = Just 2 in x
23:34:21 <srhb> Dammit, no lambdabot.
23:34:42 <srhb> rola: I don't think Hoogle supports that.
23:34:47 <julianleviston> srhb: it doesn’t help much that GHCi is in an implicit do block.
23:35:13 <srhb> julianleviston: I like it, it makes all ghci's behaviour consistent. But yes, it means you need to think about it differently from the top level. :)
23:35:24 <rola> how about hayoo?
23:35:25 <julianleviston> srhb: I like it too :)
23:35:33 <srhb> rola: I don't know. I don't think so.
23:37:06 <liste> hayoo just searches by name
23:38:35 <julianleviston> So.. in the expression “x = 5 where x = (+ 1)”, where is forming a locally scoped definition?
23:38:58 <glguy> That's not an expression
23:39:02 <julianleviston> what is it?
23:39:13 <kadoban> A declaration?
23:39:13 <julianleviston> a declaration?
23:39:16 * hackagebot lambda-options 0.9.0.0 - A modern command-line parser for Haskell.  https://hackage.haskell.org/package/lambda-options-0.9.0.0 (ThomasEding)
23:40:48 <julianleviston> and it doesn’t make sens.
23:40:50 <julianleviston> sense
23:40:51 <julianleviston> god
23:41:01 <srhb> And if that were a top level declaration, x from where would not be visible in the body of the top level x
23:41:23 <julianleviston> is this an expression ? x + 5 where x = 2
23:41:27 <srhb> Nope.
23:41:30 <julianleviston> what is it?
23:41:33 <srhb> Nothing
23:41:35 <srhb> Illegal.
23:41:43 <julianleviston> what why?
23:41:50 <srhb> Because expr where decls is not legal
23:42:34 <kadoban> let x = 2 in x + 5    is an expression, and legal though.
23:43:06 <glguy> julianleviston: The syntax for expressions is here: https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-220003
23:43:15 <julianleviston> glguy: yeah I’m reading it
23:43:21 <julianleviston> glguy: it’s pretty opaque.
23:43:25 <julianleviston> (to me)
23:43:32 <srhb> It's actually one of the most readable language definitions I've ever seen.
23:43:32 <julianleviston> apparently like all of this stuff
23:43:38 <julianleviston> srhb: same! :)
23:43:46 <srhb> But if I can make a small aside, I think you're getting hung up on some strange details.
23:43:55 <julianleviston> srhb: most of them I wouldn’t even try to undrestand
23:44:02 <julianleviston> you can.
23:44:16 * hackagebot friday-juicypixels 0.1.0.2 - Converts between the Friday and JuicyPixels image types  https://hackage.haskell.org/package/friday-juicypixels-0.1.0.2 (ThomasDuBuisson)
23:44:30 <julianleviston> srhb: I don’t know - every time I try to use the language I get super confused and can’t do super simple things
23:44:36 <julianleviston> it’s pretty annoying
23:44:42 <srhb> But you can do super simple things
23:44:43 <julianleviston> so I thought I’d revisit let and where
23:44:59 <julianleviston> srhb: they’re not useful simple things, though.
23:45:03 <srhb> Hm.
23:45:04 <ttt_fff> is there a way to get the power of prolog via just LogicT, or do I need to actually use prolog?
23:45:05 <julianleviston> srhb: x = 5 isn’t that userful
23:45:29 <julianleviston> srhb: like… say I want to create a list of cats and dogs
23:45:44 <julianleviston> I decided to do this: data AnimalDetails = AnimalDetails { animalName :: String } deriving (Show)
23:45:51 <julianleviston> srhb: data Animal = Cat AnimalDetails | Dog AnimalDetails deriving (Show)
23:46:00 <julianleviston> I thought hey…. that should be pretty easy to use!
23:46:06 <srhb> julianleviston: Yes.. :)
23:46:21 <julianleviston> first thing I try to do is … in ghci, create a cat called George...
23:46:24 <srhb> as = [Cat "Murphy", Dog "Loser"]
23:46:43 <srhb> Well, needs a let in ghci
23:46:52 <srhb> Maybe you should consider working more in a module and less directly in ghci
23:46:55 <srhb> As it can be confusing.
23:46:56 <glguy> and "Murphy" is a String, not an AnimalDetails
23:47:02 <srhb> glguy Oops, sorry
23:47:06 <julianleviston> so I did this let g = Cat (AnimalDetails { animalName = "George" })
23:47:15 <julianleviston> pretty simple, right!
23:47:20 <srhb> Yes.
23:47:27 <julianleviston> now I’m like… ok so I want to get g’s name… how do I do that
23:47:36 <julianleviston> BLAM can’t do it. Brain breaks. Realise I can’t do lets or wheres
23:47:48 <srhb> Right, ok. You do need to destructure that constructor from Animal
23:47:55 <julianleviston> srhb: yeah… 
23:48:04 <julianleviston> so I don’t know how to use where or let
23:48:04 <kadoban> julianleviston: Why not data Details = Details { name :: String }   data Type = Cat | Dog   data Animal = Animal Type Details
23:48:06 <julianleviston> properly
23:48:25 <julianleviston> kadoban: because I dn’t kow what that means
23:48:34 <srhb> kadoban is right that your structure is a bit weird, because you'd be forced to do...
23:48:50 <julianleviston> kadoban: ok let me look at that and try to refactor
23:48:54 <glguy> Changing the structure is a different issue
23:48:56 <srhb> name (Cat c) = animalName c; name (Dog d) = animalName d
23:48:59 <julianleviston> (see what I mean about simple being hard for me, tho?!?!)
23:49:07 <glguy> maybe worth thinking about later, once you understood how to work with the first one
23:49:12 <kadoban> But yes, changing the structure is not really important right now.
23:49:16 <julianleviston> true
23:49:17 * hackagebot half 0.2.2.1 - Half-precision floating-point  https://hackage.haskell.org/package/half-0.2.2.1 (EdwardKmett)
23:49:45 <julianleviston> so I have no idea how to get the name out
23:49:49 <julianleviston> i tried
23:50:05 <julianleviston> animalName n ; where (Animal (AnimalDetails {animalName = n})) = g
23:50:11 <julianleviston> but that doesn’t work of course
23:50:25 <srhb> You can't pattern match on type constructors
23:50:28 <srhb> That's not how pattern matching works.
23:50:30 <julianleviston> oh?
23:50:34 <Hafydd> julianleviston: a solution was given above.
23:50:39 <julianleviston> it was?
23:50:46 <Hafydd> Two solutions, one better than the other, in fact.
23:50:52 <Hafydd> Try reading more carefully.
23:50:59 <julianleviston> sorry there was so much other stuff I wasn’t sure what was about the refactoring and what wasn't.
23:51:12 <julianleviston> let me look again
23:51:15 <srhb> julianleviston: I gave a name function which works on your current structure.
23:51:21 <srhb> (The bad solution)
23:51:33 <srhb> But good in the sense that it teaches you what your wrong assumptions were. :)
23:51:36 <Hafydd> The other solution is the one you call "refactoring".
23:53:13 <julianleviston> ok that’s a function
23:53:18 <julianleviston> but I don’t want a function.
23:53:34 <julianleviston> I want a single thing (can’t call it expression, apparently) that I can type in to GHCi that will spit out a name
23:53:37 <julianleviston> is that possible?
23:53:49 <srhb> No.
23:53:50 <Hafydd> animalName $ case animal of { Cat d -> d; Dog d -> d }
23:53:51 <julianleviston> or do I have to define a function?
23:53:52 <julianleviston> ah
23:54:00 <julianleviston> Hafydd: perfection!
23:54:18 <julianleviston> Hafydd: and I can’t do one with where or let? I’d thought it was possible
23:55:05 <Hafydd> julianleviston: not unless your where or let defines a function or uses a case expression to pattern match on the structure.
23:55:16 <srhb> But the function will actually just desugar to that case expression
23:55:20 <julianleviston> Hafydd: I’m happy for it to do anything, really
23:55:22 <julianleviston> srhb: aha!
23:55:42 <srhb> That's how pattern matches work.
23:56:19 <julianleviston> this won’t work will it? name g where name (Cat c) = animalName c; name (Dog d) = animalName d
23:56:36 <srhb> No, the second name will not be visible within the scope of the top level name
23:56:54 <srhb> Also I don't know what name g means
23:57:11 <srhb> Remember, where attaches to declarations
23:57:14 <julianleviston> ah 
23:57:15 <julianleviston> g
23:57:16 <srhb> so foo = bar where baz
23:57:21 <julianleviston> g is my cat named george
23:57:28 <Hafydd> That will work; it's defining a function called name.
23:57:35 <srhb> Huh
23:57:44 <julianleviston> it says parse error on ‘where’ in ghci tho
23:57:57 <Hafydd> Well, it would have to be in the right context.
23:58:11 <julianleviston> Hafydd: the context is typing things into ghci
23:58:11 <glguy> You should be testing this stuff in files before you try to learn what GHCi is doing
23:58:17 <Hafydd> For just an expression, it would need to be: let name (Cat c) = animalName c; name (Dog d) = animalName d in name g
23:58:21 <srhb> I agree. use modules, and :r liberally.
23:58:40 <julianleviston> Hafydd: ah ok.. and I couldn’t re-express that as a where clause?
23:58:46 <julianleviston> Hafydd: sorry - using “where” ?
23:59:21 <Hafydd> julianleviston: a where clause is only allowed in a case expression or when defining a binding. Why do you want to use one, in particular?
23:59:29 <srhb> I have a different suggestion
23:59:35 <srhb> How about NOT using let and where for now? :P
23:59:44 <julianleviston> Hafydd: um… I’m just trying to get a handle on where and let so I can use them. I guess :)
23:59:45 <srhb> Whenever you use a where, you could have used a separate top level definition
23:59:50 <srhb> The only cost is polluting the namespace.
