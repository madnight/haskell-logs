00:00:09 <shane_> does carrying it around compromise much on the efficiency ?
00:00:19 <johnw> that really dependes
00:00:44 <johnw> you have to try it out and profile it to be sure
00:01:01 <shane_> if the function is the same all the time, the laziness should prevent it to from being redefined each time right?
00:01:14 <johnw> if it's the same all the time, why does it need to be there?
00:01:31 <johnw> we already know "norm" by name
00:01:49 <johnw> so, here's the best way to do this
00:01:51 <johnw> ignore efficiency
00:02:00 <johnw> write the correct solution in the simplest, dumbest way possible
00:02:06 <johnw> then come back here, and we'll find a way to make it sexy
00:02:18 <shane_> johnw: :)
00:02:28 <johnw> I have to sleep now, but I'll be back tomorrow
00:02:28 <shane_> johnw: sure, I will try that
00:02:41 <shane_> johnw: thanks a lot :) Goodnight.
00:02:42 <johnw> there are many ways to approach this, but I'll need to see real code and a running example to know which road to go down
00:03:16 <johnw> good night!
00:03:19 <shane_> johnw: Right, tomorrow, I will show you the code that i have written
00:16:45 <zipper> Hello, why do hakellers prefer using lists to arrays and other data structures given that most people say lists arent
00:16:53 <zipper> *aren't good
00:17:01 <zipper> For most purposes.
00:18:06 <frerich> zipper: I think the premise that Haskellers prefer using lists is flawed. In Haskell, a list is as much a control flow structure as it is a data structure. As a data structure however, it is often somewhat inefficient (significant per-element overhead, for instance). It just happens that there's a lot of API available by default for dealing with lists.
00:19:06 <zipper> frerich: Thanks, I thought it had something to do with the operations out of the box allowed for lists.
00:19:16 <zipper> frerich: I see it in hackage all the time.
00:19:18 <frerich> zipper: Lists are *very* good for things where you want to traverse something from start to end, i.e. use cases where you'd use a loop in an imperative language.
00:19:33 <zipper> Lists are what's used almost everywhere I go.
00:20:01 <zipper> Oh and arrays are bad for traversal but good for random access am I right?
00:20:10 <ReinH> Well, so is the premise taht "most people say lists aren't good"
00:20:44 <ReinH> lists are surprisingly good data structures that are often used in surprisingly bad ways
00:21:34 <ent> zipper: arrays are not bad for traversal but lists can be thought of as (potentially unending) streams of items
00:21:41 <ent> which doesn't really work with arrays
00:21:54 <zipper> ReinH: I am taking an online course on data structures and algos and I always get told that the example code I ask for opinions on should e.g I wouldn't use a list for this.
00:21:55 <zipper> etc
00:22:08 <ReinH> If you want to see why we like lists so much, look at Richard Bird's Pearls of Functional Algorithm Design
00:22:24 <ReinH> Well, there are plenty of things lists aren't good at.
00:22:45 <ReinH> And plenty of ways to use them poorly
00:22:48 <zipper> There's a book for data structures and algos in haskell wow
00:22:49 <zipper> Let me see
00:23:43 <frerich> zipper: Lists are ubiquitious because in functional programming you often do 'wholemeal programming'; i.e. you often deal with functions which don't process one element at a time but rather an entire stream of them (e.g. 'apply function to every element' or 'count all elements' or so) and a list is a plausible way to model a stream of items which is processed consecutively
00:24:10 <ReinH> For data structures, see Okasaki
00:24:17 <ReinH> Which also uses lists a perhaps surprising amount
00:30:18 <tdammers> it helps to think of lists not primarily as data structures, but as first-class one-way traversals
00:30:33 <tdammers> "generators", if you like
00:30:56 <tdammers> > [0..10]
00:30:58 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
00:31:18 <tdammers> you can look at that and say "it's a list containing the numbers 0 through 10"
00:31:37 <tdammers> but you can also say, "it's a generator that produces the numbers 0 through 10 sequentially"
00:35:35 <bollu> I keep forgetting, how do I define "iterate" as a one liner?
00:37:39 <frerich> bollu: You could just have "iterate' f x = x : iterate f (f x)"
00:38:45 <bollu> frerich: thank you :) that method of defining a list inductively always escapes me
01:18:35 * hackagebot ekg-bosun 1.0.5 - Send ekg metrics to a Bosun instance  https://hackage.haskell.org/package/ekg-bosun-1.0.5 (OliverCharles)
01:23:50 <vev> i m looking for people who have spare time to help me on our project / Je cherche des gens qui ont du temps pour m'aider sur notre projet - /contact me on #libreidea
01:25:04 <tdammers> vev: you'll have better success if you provide a bit more info - what kind of project is it, how much have you implemented already, is there going to be money in it, etc.
01:25:40 <vev> #libreidea is a collection of research questions and ideas
01:26:03 <vev> our dev is programming in haskell
01:26:35 <bollu> vev: what are the research topics?
01:26:39 <vev> cause our second part is to create tools to create ideas
01:26:55 <vev> anything that make sense to you
01:27:00 <vev> sens*
01:27:33 <vev> for now there is no rules
01:27:33 <vburakovs> sans*
01:27:44 <vev> sense*?
01:28:06 <bollu> vev: um, "anything that makes sense", so, like, what field? Math? programming?
01:30:25 <vev> all
01:30:26 <jle`> after erik meijer's tweet i have been super disheartened about how useful Optional will be in Java :/
01:30:53 <merijn> jle`: It was never going to be all that useful
01:31:01 <merijn> jle`: On the bright side, Swift is saner :p
01:31:13 <jle`> :\
01:31:17 <jle`> a part of me wanted to believe
01:31:19 <vev> research questions just help for people to get ideas
01:31:26 <merijn> Time to start programming iOS :p
01:32:38 <jle`> hopefully any languages invented from this point onwards will just not have null pointers
01:32:55 <jle`> in the long terms the ones with null pointers will fade away
01:33:00 <bollu> jle`: One can dream :)
01:33:09 <tdammers> null pointers are fine, as long as we're explicit about them and don't just allow them anywhere
01:33:13 <cocreature> ed just gave us null pointer exception in haskell
01:33:19 <Hijiri> what about low level languages where the "denotation" for a pointer is literally a memory location
01:33:26 <ttt_fff> on osx what is the eawiest way to setup a gui
01:33:38 <merijn> Hijiri: You just need references, not pointers
01:33:38 <bollu> jle`: although, I don't think that's true even now. crystal has nullable types and is really new
01:33:43 <jle`> mhm, i meant null pointer as an inhabitant of all types
01:33:46 <Hijiri> well I mean, when you're dealing with memory locations
01:33:50 <cocreature> ttt_fff: qt should work so something like hsqml
01:33:56 <frerich> merijn: Contrary to 'null' however, Optional is explicit in the type signature - and you need to do a bit more work to get the actual value out of it (i.e. it's not as easy to forget the possibility of there being no value). SO it's not that bad IMHO.
01:33:57 <Hijiri> like for device drivers or something
01:34:06 <merijn> Hijiri: Even then, you can have checked dereferences and disallow pointer arithmetic
01:34:20 <jle`> or well, at least, nulls where the language idioms encourage you to use null as an actual value
01:34:27 <merijn> frerich: Except that null is a valid Optional...
01:34:29 <bollu> merijn: you can't have arrays without pointer arithmetic
01:34:58 <frerich> merijn: Right, but isn't that just like undefined being a valid Maybe?
01:35:18 <merijn> bollu: Sure you can
01:35:26 <merijn> bollu: What kind of silly thing is that to say...
01:35:30 <jle`> haskell has them :O
01:35:34 <merijn> Many languages have arrays without pointer arithmetic...
01:35:45 <bollu> merijn: in the context of embedded systems?
01:36:02 <bollu> merijn: an "array" is just a relative offset adressing mode, right? (in one way or another)
01:36:15 <bollu> merijn: so, like, at some level you are "pointer arithmetic"ing
01:36:18 <merijn> bollu: What does embedded or not have to do with it?
01:36:30 <bollu> merijn: um, level of abstraction
01:36:31 <merijn> bollu: At some level we're just perturbing electrons
01:36:43 <bollu> merijn: :)
01:36:52 <jle`> i can imagine an embedded language with arrays that doesn't offer arbitrary pointer arithmetic
01:37:02 <merijn> bollu: A dependently typed language on embedded can easily have arrays without pointer arithmetic
01:37:05 <jle`> it's simple...just don't allow pointer arithmetic
01:37:08 <jle`> ta dah
01:37:10 <jle`> :D
01:37:29 <jle`> well, i skipped (1) have arrays
01:37:33 <merijn> I'm willing to bet Ada has safe arrays without pointer arithmetic
01:37:41 <bollu> merijn: oh, yeah. I hadn't thought of dependant typing
01:37:43 <bollu> jle`: :P
01:38:17 <tdammers> "embedded" doesn't exclude "compile-time type checker that performs bounds checks on arrays"
01:39:18 <cocreature> jle`: wow how did you come up with that?
01:39:42 <jle`> category theory of course
01:40:03 <cocreature> heh
01:40:04 <ggole> Ada isn't dependently typed afaik
01:40:30 <jle`> i should make a language called Adga
01:40:49 <quicksilver> would that be dependently typoed, jle?
01:40:56 <jle`> so ada people would think i'm mispelling ada and agda people would think i'm mispelling agda
01:41:23 <ggole> So the answer to whether it was dependently typed would, erm, depend?
01:41:32 <bollu> jle`: and you'll make googling all of them 2x harder :)
01:41:35 <tdammers> jle`: wait until I release my Aga programming language
01:41:53 <jle`> :o
01:42:04 <tdammers> I'll make it independently untyped
01:44:19 <merijn> ggole: Ada has limited dependent typing, afaik
01:44:36 <bollu> guys, guys, aren't macros just finding the fixed point over the source text?
01:44:43 <merijn> ggole: I think it lets you do things like depend on sizes of data structures?
01:44:43 <bollu> macro expansion*
01:45:58 <bollu> so, like, can you model macros as finding the fixed point of text?
01:46:02 <bollu> does that make sense
01:46:05 <bollu> s/text/token stream
01:46:16 <ggole> merijn: hmm, not sure
01:46:22 <bollu> that would be nice for the lisp I'm writing in my spare time if it is that nice )
01:46:38 <ggole> Lisp macros are (traditionally) arbitrary Lisp functions
01:46:54 <ggole> In the body of a macro you can email the programmer to ask them for the implementation if you like.
01:47:00 <bollu> ggole: then how do they make sure they have sane macros?
01:47:32 <lieven> bollu: they don't
01:47:35 <ggole> In Lisp there isn't much making sure.
01:47:47 <bollu> ggole: um, what about scheme?
01:47:56 <lieven> bollu: look at the little booklet Let over Lambda for some interesting examples of CL macros
01:49:07 <ggole> Scheme is different, you have a special syntax manipulation facility
01:49:12 <ggole> Or usually, several
01:49:45 <bollu> ggole: really? I didn't know that!
01:50:47 <ggole> I'm not much of a scheme programmer, so you'd probably be better off asking about syntax-rules and friends in #scheme.
01:53:19 <bollu> is there a nice python bridge from haskell?
01:57:38 <merijn> bollu: C FFI on both sides
02:00:09 <tdammers> that, or do what I usually do - separate processes, connect them with pipes (or go fancy with zmq or something)
02:03:45 <quicksilver> connect them with TCP+HTTP+SOAP! What could go wrong?
02:03:46 <quicksilver> :)
02:04:02 <tdammers> TCP+HTTP, maybe. SOAP, hell no.
02:04:25 <merijn> Good luck doing HTTP without TCP >.>
02:04:58 <quicksilver> well, you can certainly do HTTP over a pipe
02:05:13 <quicksilver> but this is not a helpful conversation :)
02:10:42 <bollu> tdammers: ZMQ sounds nice :)
02:20:34 <ttt_fff> are there any nice libraries for _OUTPUTTING JAVASCRIPT_ ? I'm not asking about GHCJS/Haste. I want a haskell library which helps me output JS code
02:21:24 <indiagreen> ttt_fff: https://hackage.haskell.org/package/language-javascript-0.5.14.2/docs/Language-JavaScript-Pretty-Printer.html
02:21:50 <ttt_fff> indiagreen: I want to output javascript
02:21:53 <ttt_fff> that looks like a JS parser
02:22:04 <indiagreen> the linked module is a JS pretty-printer
02:22:05 <ttt_fff> language-javascript-0.5.14.2: Parser for JavaScript
02:22:11 <ttt_fff> hmm
02:22:43 <indiagreen> ttt_fff: there's also https://wiki.haskell.org/Jmacro
02:22:50 <indiagreen> depends on what you need it all for
02:23:07 <ttt_fff> I may just go and read the Fay source code.
02:25:49 <indiagreen> ttt_fff: https://github.com/faylang/fay/blob/master/src/Fay/Compiler/Print.hs
02:25:59 <indiagreen> (in case you haven't found it already)
02:28:37 <bollu> wow, that is some seriously neat haskell code
02:38:31 <ttt_fff> bollu: what's so magical about said code?
02:38:37 <ttt_fff> I skimmed it and found nothing impressive
02:38:56 <bollu> ttt_fff: I found it very neat :) I struggle to write neat haskell code
02:39:30 <indiagreen> ttt_fff: it's not that it's magical, it's that it's not a horrible non-understandable thing like Haskell code sometimes – often? – can be
02:39:48 <bollu> I either one-letter or write overly descriptive names. The linked code was just pleasant to read
02:39:56 <ttt_fff> I see
02:44:38 <arnabold> @pl \_ s -> 1 + s
02:44:39 <lambdabot> const (1 +)
02:45:10 <bollu> :t const
02:45:11 <lambdabot> a -> b -> a
02:45:49 <bollu> :info Const
02:46:12 <bollu> I remember reading something about Monoid a <==> Applicative (Const a) or something?
02:46:15 <bollu> what's that about?
02:47:48 <indiagreen> bollu: “Const x a” carries a value of type x in it
02:48:08 <indiagreen> bollu: Applicative gives you a method class called “empty”
02:48:14 <indiagreen> ouch
02:48:15 <indiagreen> “pure”
02:48:25 <bollu> indiagreen: pure is like "lift" right?
02:48:26 <merijn> Empty is alternative
02:48:30 <indiagreen> merijn: yeah, right
02:48:36 <indiagreen> pure :: Applicative f => a -> f a
02:48:38 * hackagebot blaze-markup 0.7.0.3 - A blazingly fast markup combinator library for Haskell  https://hackage.haskell.org/package/blaze-markup-0.7.0.3 (JasperVanDerJeugt)
02:48:40 * hackagebot blaze-html 0.8.1.1 - A blazingly fast HTML combinator library for Haskell  https://hackage.haskell.org/package/blaze-html-0.8.1.1 (JasperVanDerJeugt)
02:48:42 <merijn> monoidal applicative == Alternative
02:48:50 <jophish_> glguy: What are your thoughts on this issue: https://github.com/ekmett/numeric-extras/issues/1
02:49:02 <indiagreen> bollu: now, if you specialise that to Const, you get “pure :: a -> Const x a”
02:49:04 <jophish_> (Not being able to use numeric-extras in ghci on windows)
02:49:09 <merijn> "class Alternative f where empty :: f a; (<|>) :: f a -> f a -> f a"
02:49:13 <bollu> okay, right
02:49:24 <indiagreen> bollu: so you have to get “x” out of somewhere
02:50:00 <bollu> indiagreen: um, right. but it can be "anything", right?
02:50:14 <indiagreen> what's “anything”?
02:50:30 <merijn> bollu: No "pure 'c' :: Const Int Char" has to somehow create an Int
02:50:51 <bollu> indiagreen: no, like, our Applicative will be (Const x) right?
02:50:57 <indiagreen> right
02:51:02 <bollu> because Applicative is of kind (* -> *) -> *
02:51:07 <bollu> so it gets the "x" from the Applicative?
02:51:20 <indiagreen> then I wasn't clear, sorry
02:51:30 <indiagreen> I meant that “pure” has to somehow get a value of type “x”
02:51:54 <jophish_> :k Applicative
02:51:56 <lambdabot> (* -> *) -> Constraint
02:52:23 <bollu> indiagreen: oh, right. when you call pure, it needs to figure out what type of "x" to pick is what you're asking?
02:52:43 <indiagreen> bollu: no
02:52:52 <indiagreen> bollu: if you can, please try to open the editor right now and write an instance for Applicative (Const x)
02:52:55 <indiagreen> it could help
02:53:18 <bollu> indiagreen: gimme 10? I'm trying to explain something to someone on #math
02:53:19 <bollu> :)
02:53:38 * hackagebot digestive-functors 0.8.0.1 - A practical formlet library  https://hackage.haskell.org/package/digestive-functors-0.8.0.1 (JasperVanDerJeugt)
02:53:53 <Gurkenglas> How's this structure called? I have <*>, but not fmap. Nevertheless, for any f, there is fmap f.
02:55:26 <jophish_> Gurkenglas: fmap == (<*>) . pure
02:55:30 <jophish_> :t fmap
02:55:31 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:55:36 <indiagreen> Gurkenglas: if you just have <*>, that's Apply
02:55:38 <jophish_> :t (<*>) . pure
02:55:39 <lambdabot> Applicative f => (a -> b) -> f a -> f b
02:55:40 <bollu> indiagreen: where is "Const a b" defined?
02:55:49 <Gurkenglas> no pure either, although for any x there is pure x
02:55:50 <indiagreen> but I don't understand what “for any f, there is fmap f” means
02:56:00 <cocreature> bollu: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Control.Applicative.html#Const
02:57:04 <bollu> cocreature: thanks!
02:57:37 <Gurkenglas> If I can define a name whose type is (a -> b), I can define a name whose type is (f a -> f b), such that the functor laws "hold"
02:58:34 <Gurkenglas> They "hold" in the sense that the internal representation of the structure doesn't respect the functor laws, but the behaviour resulting from the only use of the structure is identical
02:58:38 * hackagebot hakyll 4.7.3.0 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.7.3.0 (JasperVanDerJeugt)
02:59:01 <jophish_> Gurkenglas: have you got an example?
02:59:34 <Gurkenglas> I was thinking I would give y'all as many properties as I can without priming you, but if you want I'll say what it actually is
03:00:32 <jophish_> It just seems a little odd to be able to define (<*>) and not pure
03:00:40 <Gurkenglas> Indeed :P
03:03:39 * hackagebot stylish-haskell 0.5.14.3 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.5.14.3 (JasperVanDerJeugt)
03:07:55 <bollu> indiagreen: Const a b ignores b?
03:08:30 <indiagreen> bollu: yeah
03:08:39 * hackagebot websockets 0.9.6.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  https://hackage.haskell.org/package/websockets-0.9.6.0 (JasperVanDerJeugt)
03:08:41 <mniip> I wrote the most useful function ever!
03:08:51 <mniip> I made type-level naturals not useless!
03:09:05 <mniip> induce :: KnownNat k => p 0 -> (forall n. p n -> p (n + 1)) -> p k
03:11:30 <mniip> example: data Ny (n :: Nat) where Zy :: Ny 0; Sy :: Ny n -> Ny (n + 1)
03:11:30 <cocreature> induce = undefined -- I never knew induction was that easy
03:11:30 <mniip> induce Zy Sy :: Ny n
03:11:30 <mniip> cocreature, actually it's much worse
03:11:30 <cocreature> how so?
03:11:30 <lpaste> mniip pasted “Induce” at http://lpaste.net/141864
03:11:40 * indiagreen expected inlinePerformIO for some reason
03:11:41 <mniip> you absolutely can't do it without unsafeCoerce
03:12:28 <Fuuzetsu> can I get hunit to run a test with sudo?
03:13:18 <jophish_> Fuuzetsu: You'd probably best having a separate test executable which has to be run with sudo
03:14:04 <Fuuzetsu> lame but that's what I feared
03:14:59 <jophish_> Fuuzetsu: you could try some sneaky calls to 'su'
03:15:50 <haskell999> Hey guys. Need help with Data.Cache.LRU.IO, I'm trying to call newAtomicLRU, and getting 'No instance for (Ord key0)'. Type signature is Ord key => Maybe Integer -> IO (AtomicLRU key val). I can get the fromList method to work, but not sure how to call newAtomicLRU.
03:16:33 <Fuuzetsu> jophish_: right, my question was more along the lines of ‘is there a better way’
03:18:07 <liste> haskell999 what key type do you want to use?
03:18:23 <haskell999> Int or Integer, preferably
03:19:23 <mniip> where is edwardk when you need him
03:20:02 <liste> haskell999 a) try adding a type signature for the function calling newAtomicLRU b) if that doesn't work, paste your code on lpaste
03:20:09 <liste> and show it to us
03:20:16 <haskell999> ok
03:21:07 <visof> hi guys
03:22:14 <liste> hello
03:24:03 <visof> if i have this constructor data Foo a = Foo [a] a , and then data Bar a = Bar (Foo (Foo a)) , can anybody help me to understand the second statement
03:24:08 <visof> with simple example
03:24:19 <jophish_> Fuuzetsu: if you end up with an elevateIO :: IO a -> IO a, which prompts the user for their password let me know!
03:24:33 <hpc> @let data Foo a = Foo [a] a deriving (Show)
03:24:34 <lambdabot>  .L.hs:163:1:
03:24:34 <lambdabot>      Multiple declarations of ‘Foo’
03:24:34 <lambdabot>      Declared at: .L.hs:157:1
03:24:38 <hpc> @undefine
03:24:38 <lambdabot> Undefined.
03:24:39 <hpc> @let data Foo a = Foo [a] a deriving (Show)
03:24:41 <lambdabot>  Defined.
03:24:49 <hpc> @let data Bar a = Bar (Foo (Foo a)) deriving (Show)
03:24:50 <lambdabot>  Defined.
03:25:05 <mniip> jophish_, just gotta serialize the IO value and load it with suid
03:25:13 <Fuuzetsu> jophish_: well, I don't want it interactive, if I did I'd just run it with sudo by myself (like I am now)
03:25:15 <hpc> > Bar (Foo [Foo [] 5] 10) :: Bar Int
03:25:16 <lambdabot>      No instance for (Num (Foo Int)) arising from the literal ‘10’
03:25:17 <lambdabot>      In the second argument of ‘Foo’, namely ‘10’
03:25:17 <lambdabot>      In the first argument of ‘Bar’, namely ‘(Foo [Foo [] 5] 10)’
03:25:28 <Fuuzetsu> test should run in passwordless sudo env
03:25:35 <hpc> > Bar (Foo [Foo [] 5] (Foo [] 10)) :: Bar Int -- visof
03:25:37 <lambdabot>  Bar (Foo [Foo [] 5] (Foo [] 10))
03:26:11 <hpc> visof: the thing Bar takes is (Foo (Foo a))
03:26:26 <hpc> visof: so take the definition of Foo and mentally replace 'a' with 'Foo a'
03:26:36 <haskell999> Type signature on function solved my issue. Was part of main do block, so I moved it to it's own function with signature :: IO (AtomicLRU Integer int), and that seems to be working.
03:27:01 <visof> hpc: ah okay and a is consists of two values which is list and a
03:27:48 <hpc> basically just do the expansion similarly to how you would look at function application
03:28:02 <visof> hpc: so outer Foo should take two instances of Foo the first as list and other as value, right?
03:28:13 <hpc> yep
03:28:17 <hpc> or however long the list is
03:28:21 <visof> hpc: thanks man
03:28:35 <hpc> you picked a particularly ugly example though ;)
03:32:04 <indiagreen> Gurkenglas: so-o, what was your thing?
03:33:29 <Gurkenglas> indiagreen, strings representing haskell code. pure [1, 2, 3] = "[1, 2, 3]" but you can't implement pure
03:34:21 <Gurkenglas> (Actually it's strings representing queries to lambdabot but the distinction is moot except that that also nets you join)
03:40:16 <jophish_> Gurkenglas: so you want something like pure = show?
03:40:43 <Gurkenglas> jophish_, pure fmap = "fmap"
03:41:08 <mniip> nothing is impossible
03:41:14 <mniip> don't let your dreams be dreams
03:41:37 <Gurkenglas> Don't you dare tell me there's unsafeShow which does that
03:41:53 <mniip> actually, that is impossible, universally quantified polymorphism is not observable by typeclasses
03:41:56 <jophish_> Gurkenglas: you want pure to be :: a -> String for any a
03:42:07 <Gurkenglas> jophish_, yup
03:42:27 <Gurkenglas> I _thought_ it was impossible, but your first few lines were too suggestive
03:42:28 <jophish_> That's not going to happen I'm afraid
03:42:50 <Gurkenglas> Well yes I originally said that I don't have pure, and was asking what the remaining structure is called
03:42:51 <mniip> actually
03:42:59 <mniip> you can write such a show
03:43:04 <jophish_> ah yes, of course, my mistake
03:43:19 <mniip> but it would require so many hacks
03:43:29 <mniip> including cmm code
03:43:33 <Gurkenglas> Put it in an lpaste!
03:43:37 <mniip> and ghc api
03:43:47 <Gurkenglas> So we can letlpaste it
03:43:48 <jophish_> Gurkenglas: how are you implementing <*>?
03:44:04 <Gurkenglas> You're gonna laugh. concat.
03:44:17 <Gurkenglas> (Well actually there are some brackets involved I guess)
03:44:17 <jophish_> hahahah
03:44:27 <quicksilver> it's not impossible, but it *does* fail referentially transparent
03:44:33 <bollu> indiagreen: I see what you were trying to say
03:44:33 <quicksilver> so it's unsound (in a technical sense)
03:44:37 <bollu> I can't write pure at all
03:44:40 <bollu> for Const
03:44:48 <quicksilver> there is a blog post showing how to fish out the function names from the symbol table
03:44:51 <quicksilver> I'll try to find it
03:44:51 <bollu> because I need a value of "a" but I don't know where to get "a" from
03:45:08 <bollu> because pure :: b -> Const a b for Applicative(Const a)
03:45:21 <bollu> the problem is that I can't even "get" an a
03:45:24 <bollu> indiagreen: so what's the solution?
03:45:50 <jophish_> bollu: pure :: b -> Const b a
03:46:03 <jophish_> err, ignore me
03:46:17 <bollu> jophish_: :)
03:46:27 <bollu> indiagreen: um, are you around? :)
03:47:56 <quicksilver> bah cant find it
03:48:00 <Gurkenglas> (Well actually I'm probably gonna need to do some @let stuff to note have my lines trimmed by the maximum lambdabot output length)
03:48:08 <Gurkenglas> -note+not
03:49:21 <bollu> 	um, could someone explain to me the Monoid m <==> Applicative (Const m) ?
03:49:36 <bollu> actually, first of all, how do I even write pure for Applicative(Const m)?
03:49:58 <Gurkenglas> bollu, Monoid m means you suddenly have a way to conjure an m from nothing
03:50:01 <quicksilver> bollu: the two answers are entangled
03:50:12 <quicksilver> bollu: it is precisely the Monoid which answers the question you asked before
03:50:18 <quicksilver> bollu: ""I can't even 'get' an a"
03:50:24 <bollu> quicksilver: right
03:50:37 <Hafydd> bollu: the Applicative instance for Const m just appends its values together.
03:50:38 <bollu> Gurkenglas: cause identity?
03:51:05 <bollu> quicksilver: soo, like, don't I need an extra restriction to write the Applicative (Const a)
03:51:19 <bollu> won't it be Monoid a => Applicative(Const a)
03:51:19 <bollu> ?
03:51:26 <quicksilver> you do. You need Monoid m so you can write pure a = Const mempty
03:51:30 <bollu> ah
03:51:34 <quicksilver> yes exactly
03:51:46 <quicksilver> there is no sensible Applicative instance without Monoid a
03:51:56 <bollu> quicksilver: actually, anything with identity. So we could have some typeclass like Identifed a { id:: a }
03:52:00 <quicksilver> no
03:52:09 <quicksilver> because you'll need mappend to write <*> :0
03:52:14 <bollu> because I'll find I need mappend when I write <*>
03:52:15 <bollu> ah
03:52:27 <quicksilver> Pointed (as it is traditionally called) is enough for writing 'pure' certainly.
03:53:14 <quicksilver> or erm, maybe Pointed is the traditional name for the type-constructor version
03:53:23 <bollu> quicksilver: Pointed is a -> f a right?
03:53:26 <quicksilver> yeah
03:53:29 <quicksilver> I was wrong with my names.
03:53:51 <bollu> um, what's haskell syntax to say "I need Monoid a to implement Applicative (Const a)"
03:54:00 <bollu> instance ???? Applicative(Const' a)
03:54:57 <phadej> bollu: Monoid a => Applicative (Const a)
03:55:15 <bollu> no instance?
03:55:34 <phadej> bollu: instance Monoid a => Applicative (Const a) where pure ...
03:55:34 <liste> bollu also, there's a difference between "class Monoid a => Applicative (Const a)" and "instance Monoid a => Applicative (Const a)"
03:55:58 <bollu> liste: class is defining a typeclass, right?
03:56:04 <liste> though the first one doesn't make sense in this case
03:56:05 <bollu> Instance is creating an instance of that typeclass?
03:56:08 <liste> yeah
03:56:22 <liste> but "class Monoid a => MyClass a" would
03:56:23 <bollu> phadej: Not in scope: ‘a’ o_O
03:56:55 <bollu> oh, fixed :)
03:56:59 <bollu> whitespaces as usual bite me
03:57:19 <phadej> bollu: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Control.Applicative.html#line-84
03:58:59 <bollu> where is the really nice (<>) defined for mappend?
03:59:09 <phadej> bollu: Data.Monoid
04:00:03 <bollu> phadej: thanks!
04:01:20 <bollu> um, I can't separate multiple typeclass requirements behind the => with "," ?
04:01:31 <bollu> like, I'm writing a monad instance
04:01:40 <bollu> instance (Monoid a), Applicative(Const' a) => Monad (Const' a) where
04:01:42 <bollu> doesn't work
04:01:58 <liste> (Monoid a, Applicative (Const' a))
04:02:02 <liste> it's like a tuple
04:02:05 <bollu> ohh thanks
04:02:20 <bollu> liste: one could argue the grammar should deal with that :)
04:02:56 <bollu>     Non type-variable argument
04:02:57 <bollu>       in the constraint: Applicative (Const' a)
04:02:57 <bollu>     (Use FlexibleContexts to permit this)
04:03:01 <bollu> what does that mean?
04:03:15 <liste> that you mean {-# LANGUAGE FlexibleContexts #-}
04:03:21 <liste> or -XFlexibleContexts
04:03:24 <bollu> no, why do I need it
04:03:57 <bollu> like, what's the error message mean?
04:03:59 <quicksilver> because history
04:04:02 <bollu> and what does FlexibleContexts do
04:04:07 <bollu> quicksilver: lol
04:04:26 <quicksilver> haskell had originally some very strict limitations on the form of class instances
04:04:29 <quicksilver> (and other things)
04:04:42 <quicksilver> GHC has gradually relaxed them and people have discovered all kinds of neat ways of using the relaxed rules
04:04:46 <quicksilver> but it still defaults to the standard.
04:04:49 <merijn> You can't make Const a Monad
04:04:56 <merijn> Not even with a Monoid constraint
04:04:58 <bollu> merijn: I'm trying :P
04:05:09 <bollu> quicksilver: ahh, cool
04:05:15 <quicksilver> some context here - https://prime.haskell.org/wiki/FlexibleContexts
04:05:19 <quicksilver> although maybe not enough to make it clear.
04:05:22 <bollu> so the histrory behind FlexibleContexts?
04:05:25 <bollu> oh, okay
04:05:26 <bollu> ice
04:05:27 <bollu> nice
04:08:03 <bollu> "g :: (C [a], D (a -> b)) => [a] -> b" yeah I have no idea what they're trying to say
04:08:47 <bollu>     Constraint is no smaller than the instance head
04:08:48 <bollu>       in the constraint: Applicative (Const' a)
04:08:48 <bollu>     (Use UndecidableInstances to permit this)
04:08:48 <bollu>     In the instance declaration for ‘Monad (Const' a)’
04:09:06 <bollu> do I need UndecidableInstances?
04:09:12 <bollu> "Undecidable" doesn't sound plesant
04:10:24 <phadej> bollu in '(Monoid a, Applicative (Const' a)) => Monad (Const' a), you don't need the `Applicative`
04:10:47 <phadej> it can be `instance Monoid a => Monad (Const' a) where ...`
04:10:57 <bollu> phadej: um, but, AMP and all that?
04:11:19 <bollu> phadej: okay, but, why is it giving me the error?
04:12:34 <phadej> because `Applicative (Const a)` isn't general enough constraint. But you don't need it, so better to omit and not enable extensions just because GHC proposes them :)
04:13:07 <phadej> bollu: for AMP you need to have Applicative (Const a) to exist, if you want to define Monad (Const a)
04:13:38 <phadej> and to define Applicative (Const a) you need Monoid a, and that you give in the constraints: `Monoid a => Monad (Const a)`
04:14:04 <phadej> try for example: `instance Monad (Const' a) where ...` and check the error GHC gives you
04:14:12 <bollu> ahh
04:14:14 <bollu> cool :)
04:14:20 <phadej> probably will say that it cannot find `Monoid a` for `Applicative (Const a)`
04:14:26 <bollu> merijn:     (>>=) c1 _ = Const' { val = val c1 } <- works, right?
04:14:27 <phadej> from empty context
04:14:49 <bollu> phadej: yep, you're right
04:14:53 <bollu> it asks for Applicative
04:15:23 <bollu> merijn: does that (>>=) definition not follow the laws?
04:18:12 <merijn> bollu: It doesn't
04:18:24 <merijn> Because you're not calling the function
04:18:43 <merijn> You have to call 'f' in "x >>= f" to obey the laws
04:19:14 <merijn> Remember that "return x >>= f" has to be identical to "f x" which yours is not
04:19:32 <merijn> because "return x >>= f" is equaly to "return x", not "f x"
04:19:56 <bollu> ahh, right
04:19:58 <bollu> hm
04:20:09 <bollu> I wonder what extra structure you need to make const work? or is it unworkable?
04:20:58 <merijn> Const can't work, because you can never call the function without an input argument
04:21:21 <merijn> "data Proxy a = Proxy" is a Monad, though, can you see why?
04:21:58 <bollu> merijn: because f Proxy = <unworkable> ? so return >>= f will also be as vacuous?
04:22:57 <bollu> merijn: that is one weird type
04:23:04 <bollu> merijn: what's it even for..?
04:23:40 <FireFly> I think  f Proxy  would work just fine
04:23:45 <bollu> wait, lemme try and explore this
04:25:00 <phadej> bollu: `Proxy a` ~ (), the phantom type tag varies, but no one cares
04:25:06 <bollu> instance Monad Proxy where
04:25:07 <bollu>     --return a -> Proxy a
04:25:07 <bollu>     return _ = Proxy
04:25:07 <bollu>     --(>>=) :: Proxy a -> a -> Proxy b -> Proxy b
04:25:07 <bollu>     (>>=) a f = Proxy
04:25:39 <merijn> bollu: Right, because "f a" can only return Proxy, which is identical to not calling 'f' and returning Proxy :)
04:25:43 <phadej> `Proxy a` doesn't carry any value, `Const c a` carries `c`
04:25:46 <bollu> so, because f x = Proxy (since Proxy a has only one "inhabitant"), return x >>= f ==Proxy
04:25:56 <phadej> yes
04:26:07 <FireFly> Hmm
04:26:09 <bollu> ahh
04:26:21 <bollu> haskell is cool :)
04:27:44 <bollu> now if only I understood Continuations
04:28:36 <FireFly> Where is Const defined?
04:28:54 <hpc> @hoogle Const
04:28:56 <lambdabot> Control.Applicative Const :: a -> Const a b
04:28:56 <lambdabot> Control.Applicative newtype Const a b
04:28:56 <lambdabot> Data.Data data Constr
04:29:02 <FireFly> Ah, right
04:29:16 <hpc> i don't know how you would ever remember that :P
04:29:44 <FireFly> I treid to tab-complete Data.Const :P
04:29:49 <FireFly> tried*
04:29:57 <bollu> what happens if you change Const a b to store b?
04:30:08 <bollu> like, that's something that's bugged me
04:30:21 <bollu> when you define typeclasses, how do you know what parameter to keep first?
04:30:35 <bollu> because it'll affect the order of partial application
04:30:44 <FireFly> Well, the type of Const mirrors that of the const function
04:31:02 <FireFly> it wouldn't really be a constant function if the order was the other way around
04:31:17 <FireFly> (or create a constant function when partially applied, I mean)
04:32:46 <bollu> okay, take Either for that matter
04:33:04 <bollu> the (>>=) working (propogating errors) depends on the fact that in Either a b, a is the error
04:33:42 * hackagebot composition-tree 0.1.0.0 - Composition trees for arbitrary monoids.  https://hackage.haskell.org/package/composition-tree-0.1.0.0 (LiamOConnorDavis)
04:33:44 * hackagebot HerbiePlugin 0.2.0.0 - automatically improve your code's numeric stability  https://hackage.haskell.org/package/HerbiePlugin-0.2.0.0 (MikeIzbicki)
04:33:58 <kamatsu> how often does the hackage buildbot run?
04:41:39 <geekosaur> kamatsu, try asking in #haskage or #haskell-infrastructure
04:41:58 <geekosaur> err #hackage
04:42:03 <bollu> does anyone have an intuitive way to write (>>=) for the Cont monad?
04:42:11 <bollu> I can write it, but I need to stare at the types
04:42:27 * geekosaur sees it's going to be a looong day...
04:42:43 <bollu> geekosaur: :) what's that for?
04:42:46 <merijn> bollu: Everyone has to stare at the types to implement >>= for Cont :p
04:42:57 <bollu> merijn: xD
04:42:58 <bollu> aww
04:43:10 <bollu> I was hoping for some awesome insight to blow my mind with awesome
04:43:14 <geekosaur> previous typo unrelated to your query, also that I typoed that /me pretty badly the first attempt
04:43:22 * geekosaur pretty much did not sleep last night
04:43:24 <bollu> merijn: what about call/cc ? I haven't tried writing that yet
04:44:33 <bollu> so, the Cont monad is just.. unintuitive by nature?
04:45:29 <chpatrick> bollu: it's not so bad
04:45:51 <merijn> bollu: Well, after doing it the first time it's less bad, but still pretty confusing (to me, at least)
04:45:58 <chpatrick> just think of it as a function that takes another function to pass the result to
04:46:47 <chpatrick> and the whole shebang returns an r at the end
04:47:08 <bollu> chpatrick: still, confusing :(
04:47:34 <chpatrick> and ContT is just (>>=) with the left argument partially applied
04:47:39 <bollu> chpatrick: confession: I can't even write the type of Cont. I have to think of it as "partially applied flip ($)"
04:48:17 <chpatrick> well think about it this way
04:48:22 <chpatrick> it's a computation that produces an a
04:48:31 <bollu> okay, so __ -> a
04:48:43 * hackagebot composition-tree 0.1.0.1 - Composition trees for arbitrary monoids.  https://hackage.haskell.org/package/composition-tree-0.1.0.1 (LiamOConnorDavis)
04:48:46 <chpatrick> but instead of returning it, it takes a function and passes it as a parameter
04:49:07 <bollu> (a -> ___) -> a ?
04:49:11 <chpatrick> indeed!
04:49:18 <chpatrick> where ___ is some result
04:49:21 <bollu> so it returns it and passes it along?
04:49:25 <chpatrick> yep
04:49:28 <bollu> ohh
04:49:29 <chpatrick> wait
04:49:32 <chpatrick> it's not -> a though
04:49:51 <chpatrick> you're almost there
04:49:54 <bollu> okay, wait. traditional function:
04:49:58 <bollu> a -> r
04:50:03 <chpatrick> yep
04:50:07 <bollu> we take a function to give the output to, later
04:50:10 <bollu> so that would be
04:50:16 <bollu> a -> (r -> r1) -> r1 ?
04:50:29 <chpatrick> not exactly
04:50:35 <JagaJaga> :t (..)
04:50:37 <lambdabot> parse error on input ‘..’
04:50:44 <chpatrick> you just pass it the "result" of the computation
04:50:46 <JagaJaga> What type does (..) have? Or it's just a syntax sugar?
04:50:48 <chpatrick> and then return what it returns
04:50:53 <chpatrick> JagaJaga: it doesn't exist
04:51:33 <liste> JagaJaga you mean in [a..b] or [a..] ?
04:51:35 <chpatrick> bollu: so instead of just returning the result, you pass the result into the continuation which will produce the eventual result
04:51:40 <bollu> chpatrick: you could probably write it though? Traversable t, Ranged a => a -> a -> Traversable t a ?
04:51:48 <chpatrick> :t enumFromTo
04:51:49 <lambdabot> Enum a => a -> a -> [a]
04:51:53 <bollu> aww
04:51:57 <bollu> okay, anyway
04:52:00 <liste> JagaJaga [a..b] desugars to enumFromTo and [a..] to enumFrom
04:52:02 <bollu> chpatrick: 
04:52:13 <bollu> that was why I wrote the a -> (r -> r1) -> r1
04:52:19 <bollu> because we know how to produce r from a
04:52:23 <JagaJaga> liste: thank you.
04:52:25 <bollu> so we hand the r to th1 (r -> r1)
04:52:30 <bollu> and then return the r1
04:52:31 <bollu> no?
04:52:34 <merijn> JagaJaga: See ":i Enum" in ghci for more possible functions
04:52:35 <bollu> where did I go wrong?
04:52:37 <chpatrick> it's simpler than that though
04:52:52 <chpatrick> there's no a to take
04:53:13 <bollu> chpatrick: how to we kick it off, then?
04:53:24 <bollu> then it'll just be (r -> r1) -> r1
04:53:31 <chpatrick> indeed
04:53:35 <bollu> which like, doesn't even make sense
04:53:38 <chpatrick> why not?
04:53:39 <bollu> that's not possible
04:53:48 <chpatrick> well just call r a instead
04:53:48 <bollu> I need a "r" now to produce an r1
04:53:54 <bollu> no, like
04:54:00 <bollu> okay
04:54:05 <bollu> let's say I have my type
04:54:16 <bollu> type cont r a= (a -> r) -> r
04:54:27 <bollu> now how would I use it? I still need a seed "a"
04:54:32 <bollu> it's useless the way it is right now, right?
04:54:36 <chpatrick> nope!
04:54:42 <chpatrick> could you define return for that?
04:54:52 <bollu> chpatrick: what kind of return? monad return?
04:54:54 <chpatrick> yep
04:54:58 <chpatrick> or pure, as you like it
04:55:22 <bollu> so, that would be,what, pure :: a -> Cont r a
04:55:26 <chpatrick> yep
04:56:00 <bollu> pure val = \f -> f val
04:56:10 <chpatrick> there you go
04:56:24 <bollu> okay, but I still don't see what it gets me
04:56:31 <bollu> fine, I can lift something to continuation land
04:56:36 <bollu> but I can't use it, can I ?
04:56:40 <chpatrick> the powerful thing is that f represents "the rest of the computation"
04:56:57 <bollu> chpatrick: meaning..?
04:57:01 <chpatrick> so every Cont "know the future"
04:57:06 <chpatrick> and can decide to ignore it for example
04:57:17 <bollu> just return val without callling g?
04:57:18 <chpatrick> or run the rest of the computation multiple times
04:57:18 <bollu> calling*
04:57:22 <chpatrick> yeah
04:57:40 <chpatrick> so you can break out of a computation like you can in imperative languages
04:57:41 <bollu> but to run it multiple times I'd need a Monoid or something to smash the multiple run values together
04:57:49 <chpatrick> which is fine right?
04:57:56 <bollu> yeah, that works
04:58:05 <chpatrick> so there's a lot of crazy stuff you can do with Cont
04:58:05 <bollu> I'm not "wowed" though :)
04:58:20 <chpatrick> it can turn an eager parses into a lazy one
04:58:21 <bollu> hmm
04:58:23 <chpatrick> *parser
04:58:42 <chpatrick> what blew my mind is that it's isomorphic to double-not elimination in formal logic
04:58:47 <bollu> chpatrick: but how does this relate to the actual continuation passing style or even yield / callcc?
04:58:59 <bollu> chpatrick: what? wait, what's double-not elimination?
04:59:03 <bollu> this should be cool :D
04:59:19 <chpatrick> so in logic not (not a) -> a right?
04:59:23 <bollu> yep!
04:59:43 <chpatrick> well in haskell you can represent most logical formulae as programs
05:00:05 <chpatrick> gimme a sec
05:00:16 <bollu> sure
05:00:32 <chpatrick> so you can say a value is a proof of a formula represented by its type
05:00:44 <chpatrick> so you can say if I have some value :: Foo, then I know Foo
05:00:48 <int-e> chpatrick: double negation elimination is a rule in classical logic, but the type system, as a logic, is intuitionistic
05:00:58 <chpatrick> yes
05:01:07 <bollu> int-e: intuitionistic == ?
05:01:09 <chpatrick> so that's the one thing you need to add in
05:01:13 <johnv> hey, i'm currently writing a small haskell function and I encountered that I get different result with the same input when I use a type signature or not. Any ideas why this happens? This is my code: http://pastebin.com/mshjc3ay
05:01:15 <bollu> intuitionistic*
05:01:35 <chpatrick> you want to say Not (Not a)) -> Known a
05:01:40 <chpatrick> where Known is a monad
05:01:41 <bollu> okay
05:01:46 <bollu> ohkay...
05:01:54 <bollu> why should it be a monad
05:01:55 <bollu> ?
05:01:55 <chpatrick> sorry I'm getting ahead of myself
05:02:06 <chpatrick> so if you encode formulae as types and proofs as values then some things emerge
05:02:15 <chpatrick> truth is () because you can always just construct it
05:02:23 <chpatrick> falsity is Void because you can never prove it
05:02:33 <Hafydd> johnv: without the type signature, the type of coins defaults to [Double] -> Double -> [Double].
05:02:34 <bollu> what's Void?
05:02:37 <chpatrick> data Void
05:02:39 <chpatrick> no constructors
05:02:48 <bollu> that's a legal haskell type?
05:02:50 <chpatrick> yep!
05:03:04 <Hafydd> johnv: that is, as it is instantiated in main.
05:03:07 <bollu> wow, okay
05:03:12 <bollu> I just tried it out
05:03:14 <liste> needs a {-# LANGUAGE EmptyDataDecls #-} though
05:03:15 <bollu> okay, continue
05:03:17 <chpatrick> so it can represent falsity because you can never make a proof
05:03:26 <chpatrick> and is (,)
05:03:26 <bollu> liste: worked without..
05:03:28 <chpatrick> :t (,)
05:03:29 <lambdabot> a -> b -> (a, b)
05:03:39 <chpatrick> if you know a and b, you know both
05:03:42 <geekosaur> haskell98 needs EmptyDataDecls, they're standard as of H2010 IIRC
05:03:43 <bollu> chpatrick: and or will be using a sum type
05:03:44 <chpatrick> or is Either
05:03:48 <Hafydd> johnv: it might be more accurate to say that the type of your numeric literals default to Double, that causes the above type to be inferred for coins.
05:03:49 <chpatrick> :t Either
05:03:50 <lambdabot>     Not in scope: data constructor ‘Either’
05:03:50 <lambdabot>     Perhaps you meant variable ‘either’ (imported from Data.Either)
05:03:50 <bollu> oh, okay
05:03:53 <chpatrick> derp
05:03:53 <chpatrick> :t either
05:03:55 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
05:03:57 <merijn> johnv: FYI, if you use -Wall GHC will warn about defaulting
05:03:58 <bollu> chpatrick: why not a | b
05:04:05 <chpatrick> same thing
05:04:11 <bollu> alright
05:04:15 <chpatrick> haskell ADTs are composes of sums and products
05:04:18 <chpatrick> so ANDs and ORs
05:04:24 <bollu> yep, that I know of
05:04:30 <chpatrick> so how do you represent Not a?
05:04:38 <chpatrick> you can say a -> Void
05:05:04 <bollu> chpatrick: why would that be Not?
05:05:07 <chpatrick> as in, it's impossible to prove a because then we would be able to construct this uninhabited type, which is impossible
05:05:07 <bollu> Not () =  Void, and Not Void = ()
05:05:22 <johnv> Hafydd: Thanks for the clarification. But I don't understand, why the 1 Cent coin is missing, when using Double instead of float?
05:05:35 <bollu> chpatrick: but, then, how would Not Void be true
05:05:36 <bollu> ?
05:05:55 <bollu> chpatrick: you're saying Not :: a -> Void?
05:05:55 <chpatrick> it doesn't have to be exactly the same as ()
05:06:02 <merijn> > 0.01 :: Float
05:06:04 <lambdabot>  1.0e-2
05:06:07 <merijn> > 0.01 :: Double
05:06:08 <chpatrick> bollu: yes
05:06:08 <lambdabot>  1.0e-2
05:06:13 <chpatrick> because if you have a function (a -> Void)
05:06:21 <chpatrick> then you know that it's impossible to have a value of a
05:06:22 <tdammers> johnv: floating-point numbers are also known as an "inexact numeric type", which should kind of be a hint why they're not a good fit for representing money
05:06:24 <chpatrick> because then you could produce Void
05:06:26 <chpatrick> which is impossible
05:06:36 <bollu> chpatrick: but if I have a Void..?
05:06:38 <merijn> johnv: Note that Float and Double are IEEE754 floating point and not all numeric values are representable
05:06:48 <chpatrick> bollu: how can you have a Void?
05:06:50 <bollu> I don't see how it inverts falsity to truth
05:07:00 <chpatrick> ok, so there's the problem
05:07:00 <bollu> chpatrick: okay, I can;
05:07:01 <merijn> tdammers: They're pretty exact, just not the way people naively think :)
05:07:01 <Hafydd> johnv: it happens because of your usage of <=.
05:07:12 <chpatrick> we can represent almost everything this way
05:07:18 <chpatrick> except for the double negation rule
05:07:23 <chpatrick> Not (Not a) -> a
05:07:29 <chpatrick> because there's no way to make an a magically appear
05:07:33 <chpatrick> from (a -> Not) -> Not
05:07:34 <bollu> chpatrick: you still didn't tell me how Nor False -> True
05:07:34 <Hafydd> (So, yes, I'd recommend representing currency as an Integer.)
05:07:46 <merijn> johnv: For many you should be using https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Fixed.html#t:Centi
05:07:47 <chpatrick> one moment
05:07:59 <bollu> alright :)
05:08:32 <merijn> s/many/money
05:09:08 <hodapp> merijn: Er, well, they're exact in the sense that they comply exactly with a spec which specifies their inexactness...
05:09:09 <chpatrick> ok, so I'm getting there
05:09:17 <bollu> alright :)
05:09:25 <chpatrick> what you want is Not (Not True) -> True right?
05:09:35 <johnv> cool, thank you for your help :)
05:09:39 <bollu> what I want is Not (False) -> True first :)
05:09:55 <bollu> but yes, the Not (Not True) -> False as well
05:10:02 <merijn> hodapp: They're exact in the sense that you know precisely the values you get for a given computation and are guaranteed to always get the same value
05:10:22 <hodapp> merijn: That's deterministic, not exact.
05:10:54 <merijn> You're also guaranteed to get the closest representable value to the mathematical ideal
05:10:55 <bollu> chpatrick: continue? :D
05:11:02 <chpatrick> bollu: so the difference here is that truth isn't a special thing
05:11:10 <bollu> okay
05:11:14 <chpatrick> something holds if there's a proof of it
05:11:31 <chpatrick> if you have type Truth = ()
05:11:34 <merijn> johnv: If you're lucky you can just change the type of coins to "[Centi] -> [Centi] -> [Centi]" after "import Data.Fixed" and it will Just Work
05:11:35 <chpatrick> then you can always prove it
05:11:35 <bollu> ah, and in this case proof == "instantiable" ?
05:11:38 <chpatrick> yes
05:11:45 <bollu> alright, that makes sense
05:11:50 <chpatrick> so Not (Not False) -> True is just const ()
05:12:07 <merijn> eh, "[Centi] -> Centi -> [Centi]" I mean
05:12:10 <bollu> :t const
05:12:12 <lambdabot> a -> b -> a
05:12:18 <bollu> right..
05:12:23 <chpatrick> but as I said the tricky part is Not (Not a) -> a
05:12:26 <chpatrick> because if you unroll it
05:12:29 <johnv> merijn: thanks!
05:12:40 <chpatrick> ((a -> Void) -> Void) -> a
05:12:50 <chpatrick> doesn't look like something you can write in haskell because where would the a come from?
05:13:00 <bollu> yeah, true
05:13:06 <chpatrick> so
05:13:12 <chpatrick> for this one logical step
05:13:20 <chpatrick> you need to make a Monad that gives you this for free
05:13:36 <merijn> johnv: Style comment: I would change 'y' on line 9 to '_' (_ is the wildcard pattern for when you don't care about the value, so it explicitly tells readers to ignore a function argument)
05:13:37 <chpatrick> as a monadic operation so to speak
05:13:41 <bollu> chpatrick: o_O
05:13:46 <chpatrick> doubleNot :: Not (Not a) -> Magic a
05:13:47 <bollu> chpatrick: right, I'm with you
05:14:03 <bollu> lol
05:14:04 <chpatrick> and then you can prove everything
05:14:08 <chpatrick> inside the Magic monad
05:14:22 <bollu> how do you know "monad" is the right level of power?
05:14:42 <chpatrick> because you need to depend on previous proofs
05:15:03 <chpatrick> Magic a -> (a -> Magic b) -> Magic b right?
05:15:11 <bollu> ahh
05:15:12 <bollu> okay
05:15:13 <bollu> right
05:15:16 <kriztw> chpatrick: so being in the Cont monad corresponds to assuming the law of excluded middle?
05:15:26 <chpatrick> spoilers :D
05:15:35 <chpatrick> :t cont
05:15:36 <kriztw> sorry, I was following on the sidelines :D
05:15:37 <lambdabot> ((a -> r) -> r) -> Cont r a
05:15:53 <chpatrick> so type Magic = Cont Void
05:15:57 <kriztw> it helped me too, even though I have more of a logic background
05:16:15 <bollu> what the fuuuck
05:16:20 <bollu> that is ridiculous
05:16:25 <merijn> johnv: Also, the "do" in main is redundant :) Just "main = print $ coins ..." works
05:16:47 <chpatrick> if instead of Cont void you say that falsity is just "r"
05:16:53 <chpatrick> then these proofs are actual computations
05:17:04 <bollu> hm
05:17:13 <chpatrick> but I can't figure out what they mean yet :D
05:17:22 <chpatrick> you can actually produce values using these proofs but they seem to be bogus
05:17:49 <chpatrick> tl;dr Cont is crazy
05:19:18 <chpatrick> gonna get lunch :D
05:37:36 <icbm> So much mind being blown before even having coffee this morning. O_o
05:38:46 <icbm> chpatrick: <-- applause
05:53:45 * hackagebot ghc-exactprint 0.4.0.0 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.4.0.0 (mpickering)
05:59:53 <johnv> I have a list of integers [100, 50, 10, 5] representing money (in cents). I want to print the list like this: 1, 0.5, 0.1, 0.05. I understand that I have to "map (div 100)" over the list but before that I have to convert the values to a float (or something similar). How can I do that?
06:00:47 <liste> johnv why not divMod?
06:00:52 <liste> :t divMod
06:00:54 <lambdabot> Integral a => a -> a -> (a, a)
06:01:08 <liste> that way you get both the euros and the cents
06:01:24 <enolan> divMod might be what you actually want, but fromIntegral is the tool for converting ints to floats and the like
06:01:27 <enolan> :t fromIntegral
06:01:28 <lambdabot> (Integral a, Num b) => a -> b
06:01:39 <liste> > map (divMod 100) [100, 50, 10, 5]
06:01:40 <lambdabot>  [(1,0),(2,0),(10,0),(20,0)]
06:01:49 <liste> > map (divMod 10) [100, 50, 10, 5]
06:01:50 <lambdabot>  [(0,10),(0,10),(1,0),(2,0)]
06:02:10 <liste> oh, wrong order
06:02:24 <liste> > map (`divMod` 100) [200, 100, 50, 10, 5]
06:02:25 <lambdabot>  [(2,0),(1,0),(0,50),(0,10),(0,5)]
06:03:02 <EvilMachine> What’s the name of a typeclass that only has (>>) [and something to run it), but not (return) or (>>=)?
06:03:32 <johnv> liste: cool, but shouldn't the last one be 0,05?
06:03:46 <chpatrick> EvilMachine: Apply?
06:04:04 <chpatrick> https://hackage.haskell.org/package/semigroupoids-5.0.0.3/docs/Data-Functor-Apply.html#t:Apply
06:04:29 <chpatrick> can I ask what it's for?
06:04:32 <EvilMachine> chpatrick: Felt like it! But I wasn’t sure. Thanks. :)
06:05:33 <EvilMachine> chpatrick: I’m writing a small set of drawing functions that should be combinable in a serial fashion (>>) and renderable to a surface (run).
06:05:47 <chpatrick> EvilMachine: maybe a Monoid or Semigroup?
06:06:05 <liste> johnv take care of that when outputting
06:06:21 <EvilMachine> chpatrick: The order of drawing is important. That’s why Monoid felt like not enough. (<> versus >>)
06:06:38 <chpatrick> Monoids don't say anything about order though
06:06:45 <chpatrick> just associativity
06:06:49 <liste> johnv with something analogous to printf's "%2d"
06:06:57 <chpatrick> "foo" <> "bar" is still ordered
06:06:59 <EvilMachine> chpatrick: Exactly. I wanted something that does. Explicitely.
06:07:02 <liste> or "%02d", something like that
06:07:06 <chpatrick> ok but Apply doesn't either
06:07:18 <EvilMachine> chpatrick: Monad does, doesn’t it?
06:07:20 <bollu> chpatrick: ooh, I enjoy "hunt the algebraic structure"
06:07:21 <chpatrick> not really
06:07:23 <bollu> what are we looking for? :d
06:07:25 <bollu> :D
06:07:30 <EvilMachine> chpatrick: Damn. I knew it.
06:07:43 <aweinstock> > map (uncurry (printf "%d.%02d €") . divMod 100) [100, 50, 10, 5]
06:07:45 <lambdabot>      No instance for (Show b0)
06:07:45 <lambdabot>        arising from a use of ‘show_M28734550957950889031250’
06:07:45 <lambdabot>      The type variable ‘b0’ is ambiguous
06:07:49 <chpatrick> EvilMachine: only in certain monads
06:07:50 <EvilMachine> bollu: Look up there, I already described it. 
06:07:58 <chpatrick> I think Monoid is what you want
06:08:10 <aweinstock> :t printf
06:08:11 <lambdabot> PrintfType r => String -> r
06:08:30 <aweinstock> :t printf "%d%d" :: String -> Int -> Int -> String
06:08:31 <EvilMachine> There isn’t really any structure that makes order explicit, is there? Monad just happens to look like it due to the >>
06:08:31 <lambdabot> String -> Int -> Int -> String
06:08:42 <bollu> EvilMachine: [] ?
06:08:45 <chpatrick> not that I know of
06:08:45 <aweinstock> > map (uncurry (printf "%d.%02d €" :: String -> Int -> Int -> String) . divMod 100) [100, 50, 10, 5]
06:08:47 <lambdabot>      Couldn't match type ‘[Char]’ with ‘Int’
06:08:47 <lambdabot>      Expected type: String -> (String, Int)
06:08:47 <lambdabot>        Actual type: String -> (String, String)
06:08:53 <chpatrick> I mean some instances are ordered, like IO
06:08:55 <chpatrick> or []
06:08:57 <aweinstock> > map (uncurry (printf "%d.%02d €" :: Int -> Int -> String) . divMod 100) [100, 50, 10, 5]
06:08:59 <lambdabot>  ["1.00 \8364","2.00 \8364","10.00 \8364","20.00 \8364"]
06:09:01 <EvilMachine> chpatrick: I’m currently using Monoid. :)
06:09:01 <chpatrick> but it's not from the algebraic structure
06:09:13 <chpatrick> to my knowledge
06:09:26 <EvilMachine> chpatrick: And some instances of Monoid probably are too.
06:09:44 <merijn> chpatrick: Not only that, the laws aren't sufficient to guarantee an ordering either :)
06:09:45 <bollu> EvilMachine: semigroup
06:09:46 <bollu> ?
06:09:48 <chpatrick> yep, like anything list-like
06:09:56 <merijn> I mean they guarantee *an* ordering, but you can't tell which
06:10:01 <EvilMachine> bollu: Monoids are prettier to use, with their combinators, though. :)
06:10:07 <EvilMachine> merijn: :D
06:10:15 <merijn> For example, we have "time travelling state" where the order of state updates is reversed
06:10:25 <chpatrick> I mean it makes sense to me to have a no-op drawing thing
06:10:28 <EvilMachine> bollu: I haven’t yet looked into semigroup. What does it offer?
06:10:33 <chpatrick> it's monoid without mempty
06:10:37 <bollu> EvilMachine: so, want something that can be composed to yield a new drawable but still have the composition operator?
06:10:43 <merijn> https://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
06:10:52 <bollu> merijn: isn't it called "Tardis" ?
06:11:01 <chpatrick> tardis is bidirectional!
06:11:04 <EvilMachine> bollu: :D I love that one.
06:11:12 <shapr> @quote
06:11:12 <lambdabot> merijm says: A comonad is like a burrito. It's hard to keep things inside.
06:11:29 <merijn> Bah
06:11:33 <shapr> wat?
06:11:35 <merijn> Someone butchered my name
06:11:40 <shapr> oh, soryr
06:11:45 <merijn> :p
06:11:49 <EvilMachine> bollu: especially in combination with arrows. where you can use a value *before* it got caluclated, *based* on its not-yet-defined self.
06:11:57 <chpatrick> is a monad a coburrito?
06:12:15 <bollu> EvilMachine: *sigh* I wish I knew enough Haskell to comprehend it
06:12:42 <bollu> EvilMachine: why not just keep a list?
06:12:45 <EvilMachine> bollu: Arrows are much easier than I thought though. 
06:13:03 <chpatrick> I would use a DList or Endo []
06:13:11 <merijn> chpatrick: A monad is a strong monad in the monoidal category of food
06:13:11 <bollu> EvilMachine: I understand arrows (at least, to the level of "what they do") but I've never had a reason to use them
06:13:14 <bollu> What endo? 
06:13:17 <EvilMachine> bollu: because „Fezes^Wcombinators are cool“ 
06:13:18 <bollu> enomorphis,?
06:13:21 <merijn> *symmetric monoidal category of food
06:13:32 <merijn> chpatrick: Consult page 49 of http://sigbovik.org/2015/proceedings.pdf :p
06:13:44 <bollu> chpatrick: what's Endo?
06:13:50 <chpatrick> it's cont for monoids :D
06:13:58 <bollu> chpatrick: if it's an Endomorphism, what does it mean in the haskell setting?
06:14:01 <bollu> chpatrick: plz. explain
06:14:02 <merijn> bollu: "newtype Enda a = Endo (a -> a)"
06:14:19 <merijn> bollu: "mempty = id; mappend f g = f . g" (or g.f, I forget)
06:14:22 <merijn> eh
06:14:29 <merijn> "mempty = Endo id", but you get the idea
06:14:45 <bollu> oh, so it has a monoidal structure?
06:15:03 <bollu> wait, that's just… silly
06:15:04 <merijn> It's the monoid for function composition
06:15:17 <bollu> I can't think of it cropping up often
06:15:22 <EvilMachine> :D
06:15:24 <merijn> Because the default Monoid for functions is more useful
06:15:35 <merijn> "instance Monoid b => Monoid (a -> b)"
06:15:38 <EvilMachine> Does it mean you can just replace (.) by (<>) ? :D
06:15:45 <merijn> EvilMachine: Yes
06:15:55 <exio4> let's generalize it to Category c => Monoid (Endo c a) :p 
06:15:56 <c_wraith> EvilMachine: Not by itself, because of newtype constructors.
06:16:01 <merijn> EvilMachine: Well, if you wrap every function with Endo
06:16:05 <bollu> merijn: functions have a monoid? how do you guarentee that functions work?
06:16:10 <bollu> function composition works**
06:16:11 <EvilMachine> how about the *monad* of function composition? :))
06:16:21 <merijn> bollu: The default monoid is not composition
06:16:22 <c_wraith> EvilMachine: also, it doesn't work when the types change in the (.)
06:16:47 <bollu> EvilMachine: that's silly; function composition has no order
06:17:01 <merijn> "instance Monoid b => Monoid (a -> b) where mempty = \_ -> mempty; mappend f g = \x -> f x <> g x"
06:17:06 <exio4> "monad of function composition"? what would that mean? 
06:17:09 <EvilMachine> bollu: The silliness was my point. :D
06:17:56 <bollu> merijn: holy shit I needed that structure like a month ago, when writing parser combinators. I could have used it to compose Token boundaries together as a monoid ~_~
06:17:58 <EvilMachine> btw: The only reason I’m not using function composition, is so I can limit the type they’re stringed together with. (Because I need to render it later)
06:18:08 <bollu> why do I always find this stuff so much later
06:18:13 <merijn> :t comparing length <> compare 
06:18:14 <lambdabot> (Ord (t a), Foldable t) => t a -> t a -> Ordering
06:18:53 <EvilMachine> bollu: Because they are so much harder? :)
06:18:59 <merijn> bollu: It's a neat trick when writing compound comparisons too, since Ordering is a Monoid
06:19:04 <merijn> > LT <> EQ
06:19:05 <lambdabot>  LT
06:19:09 <merijn> > LT <> GT
06:19:10 <bollu> merijn: hm? what?
06:19:11 <lambdabot>  LT
06:19:28 <bollu> > EQ <> GT
06:19:30 <lambdabot>  GT
06:19:34 <bollu> wait, what?
06:19:39 <merijn> bollu: Take a list of comparison functions (in order of importance), mconcat them together and the result is a proper ordering
06:19:40 <exio4> EQ is the identity
06:19:54 <bollu> > LT <> GT
06:19:55 <lambdabot>  LT
06:20:03 <merijn> bollu: It's left-biased
06:20:05 <EvilMachine> merijn: *which* proper ordering?
06:20:08 <bollu> merijn: yeah
06:20:14 <bollu> merijn: it's more like an Alternative
06:20:19 <merijn> EvilMachine: first Ordering is more important
06:20:19 <bollu> LT <|> _ = LT
06:20:31 <bollu> and so on
06:20:42 <nullx002> hi
06:20:44 <nullx002> λ >>  [0.1, 0.3 .. 0.9]
06:20:44 <nullx002> [0.1,0.3,0.5,0.7,0.8999999999999999]
06:20:44 <nullx002>  
06:20:45 <bollu> hey :)
06:20:51 <nullx002> why do it get 0.89999999999 
06:20:56 <nullx002> and not 0.9
06:20:57 <EvilMachine> merijn: Ah, nice. I always love when software uses tables where you can order by multiple columns and it does that.
06:21:01 <bollu> because floating point
06:21:09 <nullx002> but why?
06:21:09 <merijn> EvilMachine: e.g., suppose we do "mconcat [f,g,h]" where f, g, and h produce Ordering then we use the left-most non EQ value as resultant order
06:21:15 <nullx002> what is the limitation?
06:21:20 <nullx002> is it ghci ?
06:21:30 <bollu> nullx002: as far as I understand it, the next value would have been 0.900000001
06:21:33 <chpatrick> wait
06:21:41 <bollu> but you restricted it to 0.9
06:21:43 <liste> nullx002 you can't represent 0,9 exactly with floats
06:21:43 <bollu> so it stops
06:21:52 <merijn> Enum for Float is evil
06:21:53 <enolan> > 0.7 + 0.2
06:21:54 <lambdabot>  0.8999999999999999
06:21:54 <merijn> Don't use it
06:21:56 <nullx002> ok but it should have stoped a value before
06:21:57 <bollu> nullx002: no, it's floating point inaccuracy
06:22:00 <EvilMachine> nullx002: You need to read up about hardware representation of floating point numbers. It has a few traps.
06:22:05 <chpatrick> no one mentioned that the point of Endo is that it makes appending efficient
06:22:15 <nullx002> λ >>  [0.1, 0.3 .. 0.91]
06:22:16 <nullx002> [0.1,0.3,0.5,0.7,0.8999999999999999]
06:22:16 <nullx002>  
06:22:21 <nullx002> it gives the same outpu
06:22:22 <merijn> chpatrick: That's just the CPS/DList/codensity trick
06:22:24 <exio4> chpatrick: it's not Endo itself, either, I would say
06:22:25 <bollu> chpatrick: Endo seems nice for function composition, that's about it
06:22:26 <chpatrick> well it's not the point but it's the main us eI've sene
06:22:33 <chpatrick> *main use I've seen
06:22:38 <bollu> >0.8999999999999999 + 0.1
06:22:47 <chpatrick> I know it is, but that's why I brought it up
06:22:52 <bollu> > 0.8999999999999999 + 0.1
06:22:54 <exio4> chpatrick: (++ xs) and you have thrown any `efficient appending` to the trash :p 
06:22:54 <lambdabot>  0.9999999999999999
06:22:55 <chpatrick> it's DList without the dependency
06:22:57 <nullx002> so it is common in all functional programming or all programming languages?
06:23:01 <merijn> EvilMachine: Beyond floating point traps the Enum instance of Float is utterly evil
06:23:30 <merijn> nullx002: Use Rational and/or Fixed for exact precision arithmetic
06:23:31 <bollu> nullx002: common in most languages. Most languages don't try too hard to hide the fact that we're running in finite space
06:23:33 <EvilMachine> merijn: <grumpy-evil-machine>GOOD</grumpy-evil-machine> :D
06:23:45 <bollu> nullx002: but some languages to provide infinite precisio
06:23:52 <nullx002> yes but hardware limitations are not there....
06:23:57 <bollu> nullx002: racket and.. Python(?)
06:24:02 <nullx002> do all compilers give same results?
06:24:08 <nullx002> pyton?
06:24:20 <merijn> bollu: We do have infinite precision Rationals in Haskell, but not infinite precision Reals (well, actually we might? I think CReal is arbitrary precision?)
06:24:23 <bollu> nullx002: there is a standard called as the IEEE-747 floating point standard
06:24:24 <liste> nullx002 yep
06:24:25 <nullx002> it gave me .9 almsot always
06:24:32 <exio4> `almost always`
06:24:33 <EvilMachine> nullx002: it is common to all IEE[forgotthenumber] floating point implementations
06:24:34 <carrotlord> symbolic irrationals?
06:24:35 <liste> nullx002 that's the output rounding
06:24:36 <bollu> nullx002: and most languages follow that specification
06:24:43 <liste> nullx002 try repr(0.9)
06:24:45 <merijn> nullx002: Python lies and attempts to "guess" how you want to round it
06:24:53 <merijn> EvilMachine: IEEE754
06:24:57 <carrotlord> union of truncated reals & sym irrats
06:24:58 <enolan> 747 is the plane :)
06:25:01 <bollu> whoops, sorry
06:25:02 <bollu> xD
06:25:11 <exio4> >>> 0.7 + 0.2
06:25:13 <exio4> 0.8999999999999999
06:25:18 <exio4> in python2.7.9 
06:25:22 <merijn> > 0.7 :: Ratio Int
06:25:23 <lambdabot>  7 % 10
06:25:25 <carrotlord> >>> 100.0 / 3.0
06:25:32 <merijn> > 0.7 :: Ratio Int + 0.2
06:25:33 <lambdabot>  <hint>:1:20: parse error on input ‘0.2’
06:25:39 <merijn> > (0.7 :: Ratio Int) + 0.2
06:25:40 <lambdabot>  9 % 10
06:25:46 <nullx002> so pen and paper is better for precise arithmetic ? :D
06:25:59 <merijn> <3 Ratio
06:26:00 <bollu> nullx002: or, you use a library that gives you infinite precision
06:26:09 <bollu> very rarely do you need infinite preicsion
06:26:15 <bollu> like, the ratio between an atom
06:26:17 <nullx002> infinite precision only theoritically
06:26:25 <nullx002> what baout hardware... any limitations there?
06:26:41 <bollu> nullx002: you represent numbers as fractions
06:26:42 <nullx002> why IEEE have such standard for floating points?
06:26:49 <EvilMachine> nullx002: I can’t find that guide on the hardware limitations of IEEE754 floating point numbern right now. :/
06:26:51 <carrotlord> the hardware for floats is very complicated
06:26:52 <bollu> nullx002: that gives you a compact, but still "infinite precision"
06:26:57 <carrotlord> for ints, it is much simpler
06:26:58 <bollu> nullx002: but that is slow
06:27:16 <bollu> nullx002: the "infinite precison" way of doing things is MUCH slower than the lossy IEEE eay
06:27:28 <bollu> nullx002: and for most things, we prefer speed over precision
06:27:31 <nullx002> so it still is possible
06:27:39 <geekosaur> sort of
06:27:40 <bollu> nullx002: however, a lot of fields (like banking) can't use "lossy" numbers
06:27:45 <nullx002> yes for programming languages not math i hope
06:28:02 <bollu> nullx002: it is possible for most "practical" purposes (inifite precision that is)
06:28:06 <bollu> like, 0.33333…. == 1/3
06:28:12 <nullx002> i thnk we cna use it for banks
06:28:22 <geekosaur> you kinda have to clamp the precision at some point for transcendentals
06:28:22 <bollu> so 1/3 is the "inifinite preicion" way of representing 0.3333
06:28:28 <bollu> I think you get the idea
06:28:33 <nullx002> they are not that precise
06:28:39 <nullx002> yes... got it
06:28:41 <bollu> nullx002: what are "they" ?
06:28:55 <nullx002> who design software for banking industry ??
06:29:00 <nullx002> or ..
06:29:10 <carrotlord> COBOL is for banking
06:29:15 <Lycurgus> is not
06:29:16 <carrotlord> actually today, maybe Java
06:29:18 <bollu> nullx002: people use Java for banking (AFAIK), and Java has a lot of infinite precision libraries
06:29:20 <geekosaur> banking industry generally uses high-precision integers (such as Haskell's Integer or Fixed types)
06:29:22 <carrotlord> old languages
06:29:31 <carrotlord> vs newer
06:29:34 <nullx002> lol cobol
06:29:36 <bollu> http://docs.oracle.com/javase/7/docs/api/java/math/class-use/BigInteger.html
06:29:53 <EvilMachine> nullx002: Just know that values can only be stored with limited precision (because it’s only a limited number of bits), and sometimes there are numbers that require more precision. So if it matters, use special (slow!) types. Maybe Double already gives enough precision. And if it’s not that important of an error, just leave it.
06:29:55 <bollu> nullx002: you'd be surprised at how much COBOL we still have. FORTRAN as well
06:30:01 <exio4> isn't one of the biggest Haskell (or really-close-to Haskell) codebases written for a bank?
06:30:07 <Lycurgus> that's different from new development
06:30:25 <merijn> exio4: Several banks have substantial haskell codebases, yes
06:30:25 <bollu> nullx002: have you heard of python's numpy? (it's a python library for number crunching). It still uses FORTAN at the end of the day
06:30:29 <Lycurgus> also FORTRAN is quite different from COBOL
06:30:48 <bollu> Lycurgus: yeah, I know, I was just making a poit about legacy
06:30:49 <nullx002> yes numpy
06:30:58 <Lycurgus> FORTRAN persists in many vital numeric applications
06:31:01 <merijn> exio4: The biggest I know of is 1.5 million LOC (2.5 million if you include their in house "not quite haskell")
06:31:03 <nullx002> know it by some prime number calculations 
06:31:11 <liste> also many banks have their own Haskell dialects afaik?
06:31:11 <Lycurgus> COBOL is the opposite of vital
06:31:18 <exio4> merijn: indeed, I was talking about that, specifically
06:31:24 <merijn> liste: If by many you mean "1" :)
06:31:30 <exio4> (Mu, that was the name, wasn't it?) 
06:31:31 <Lycurgus> although there is still activity in it
06:31:46 <liste> there was that one Haskell-inspired language named after a small mammal
06:31:53 <liste> or do I remember wrong
06:32:03 <EvilMachine> bollu: using python for number crunching sounds so wrong, considering its “speed”…
06:32:04 <nullx002> dont know if it is going to change sooner because of hardware implimentation problems
06:32:07 <merijn> Lycurgus: Hah, tell that to my colleague/friend getting paid to decompile OS360 assembler into cobol and recompile it for new machines :p
06:32:24 <nullx002> once IEEE standard is out it remains unupdated for ages
06:32:25 <geekosaur> liste, Ermine?
06:32:47 <Lycurgus> i take it you mean decompile COBOL to BAL
06:32:55 <liste> geekosaur that one
06:33:02 <liste> though it isn't a Haskell dialect
06:33:05 <merijn> Lycurgus: No, they lost the source, so they just have the compiled OS360 binaries
06:33:10 <Lycurgus> y
06:33:18 <geekosaur> and that is unfortunately rather common
06:33:20 <Lycurgus> that's actually fairly common
06:33:42 <Lycurgus> and stupid shops try to recover the sources
06:33:51 <Lycurgus> instead of replacing the app
06:34:00 <nullx002> si this floating point output is predictable in anyway?
06:34:01 <geekosaur> oh the source is right over he... uh, somewhere in this dust that used to be a magtape
06:34:06 <EvilMachine> merijn: They should decompile the cobol-based assembler straight it into Haskell instead.
06:34:07 <Lycurgus> they were fugly stupid in the first place to loose the sources
06:34:08 <nullx002> like when it will appear for sure....
06:34:09 <EvilMachine> -it
06:34:15 <Lycurgus> the biggest known case to me
06:34:21 <Lycurgus> is ABC TV
06:34:25 <Lycurgus> in the snakes
06:34:50 <enolan> nullx002: the point of the standard is to make it predictable
06:35:01 <nullx002> ok
06:35:11 <enolan> it'll act weird in exactly the same way across machines that implement it correctly
06:35:25 <nullx002> enolan if that is the point than  we asssume that there are no hardware related problems
06:35:26 <Lycurgus> there are doubtless tools to reconstruct COBOL from BAL for that reason (99%)
06:35:37 <EvilMachine> enolan: Beautiful description! :)
06:35:54 <Lycurgus> CA probably has at least one and maybe more than one
06:35:57 <EvilMachine> nullx002: yes
06:36:02 <enolan> they try _very_ hard to produce correct processors these days
06:36:30 <nullx002> so if we hvae enough processing power and storage we can get more precise result and can store it...
06:36:53 <bollu> nullx002: yes, but the "processing power" is a certain _kind_ of processing power
06:37:02 <exio4> merijn: that sounds like some kind of torture, decompiling assembler for writing COBOL 
06:37:05 <bollu> which is why, you'd, say, have a graphics card for mucking pixels
06:37:06 <nullx002> and that kind of precision is not requried for banking ... i am sure... for astronomy may be...
06:37:19 <bollu> nullx002: they would lose millions every day
06:37:25 <EvilMachine> Lycurgus: I hate it when stupid people have too much money for ther own good, because they also happened to be asses surrounded by pussies that they abused. (aka banking. :)
06:37:42 * Lycurgus high 5s EvilMachine 
06:37:48 <EvilMachine> Lycurgus: or management in for-profit machines in general
06:38:01 <nullx002> and can use that same graphic card for number crunching and bruteforcing
06:38:05 <EvilMachine> Lycurgus: for-profit *organizations* i meant
06:38:06 <geekosaur> nullx002, I assure you banking does not want to lose precision in money calculations
06:38:10 <bollu> nullx002: http://stackoverflow.com/questions/3840793/rounding-standards-financial-calculations
06:38:11 <geekosaur> at all
06:38:32 <bollu> nullx002: not true. Code that would be very fast on your processor could be very slow on your graphics card and vice versa
06:38:39 <EvilMachine> enolan: they *try*. just look at the errata for modern cpus.
06:38:42 <Lycurgus> EvilMachine, or irritating blithering "don't be evil" evil bitches
06:38:47 <bollu> example: any code with a lot of if conditions will be very slow on your graphics card
06:38:50 <nullx002> i used it for brute forcing
06:38:59 <nullx002> cracked some hash using graphic cards
06:39:09 <bollu> nullx002: yes, using rainbow tables
06:39:14 <nullx002> that is kind of number crunching
06:39:20 <bollu> nullx002: the fact is that there are certain *classes* of number crunching
06:39:25 <nullx002> not rainbow tables.. but pure guessing
06:39:25 <bollu> that will be fast on a graphics card
06:39:29 <nullx002> like number crunching
06:39:41 <bollu> (namely, anything that is purely parallizable) will be fast
06:39:55 <nullx002> just for testing i used 1 gb graphic card and it works better than my i3
06:39:56 <enolan> EvilMachine: have there been floating point bugs since the P5?
06:39:57 <bollu> the reason being that a graphics card excels at parllel computation
06:40:10 <bollu> that is: computing the values of all pixels in one shot / multiplying numbers in one shot / whatever
06:40:17 <bollu> (the precise term for this is SIMD)
06:40:36 <EvilMachine> nullx002: graphics cards are very bad at code that requires the result from other code before it can continue. if it isn’t parallelizable, a cpu is better.
06:40:37 <bollu> but if you have something where the previous step depends on the next every time (i.e, a lot of if conditions)
06:40:44 <bollu> then your traditional CPU will be much faster
06:40:57 <EvilMachine> nullx002: but if it *is* parallelizable, … or boy! :D
06:41:04 <bollu> nullx002: http://stackoverflow.com/questions/3840793/rounding-standards-financial-calculations
06:41:08 <EvilMachine> Lycurgus: :D
06:41:11 <nullx002> i think hash cracking doesn't depend on any external input
06:41:19 <nullx002> once it is on it just start guessing games
06:41:24 <nullx002> no external inputs
06:41:30 <nullx002> just crunching
06:41:45 <bollu> nullx002: yes, probably, which is why it was fast
06:42:06 <EvilMachine> Lycurgus: You know, I have my nickname exactly because I was always surrounded by evil, but *wasn’t* evil, and wished I could be, so I wouldn’t be abused. (luckily I found a better solution now)
06:43:29 <Lycurgus> well by "Evil" i mean simple minded profit seeking layered over with towering hypocrisy
06:43:41 <nullx002> so haskell is better for number crunching on graphic cards??
06:44:05 <nullx002> is it anyway faster than C ?
06:44:26 <nullx002> most of those programs are in C 
06:44:29 <Lycurgus> nothing is faster than C
06:44:33 <radens> nullx002: I think the whole 'faster than C thing' is kind of a fallacy
06:44:36 <chpatrick> that's not strictly true
06:44:39 <EvilMachine> Lycurgus: I think it usually is a form of psychopathy or sociopathy… partially because people can’t feel empathy for people they don’t have to look in the eyes.
06:44:42 <chpatrick> haskell can inline more than C
06:44:49 <Lycurgus> nothing machine independent
06:45:05 <nullx002> number crunchign is kind of inline
06:45:18 <radens> If you write a shitty C program a good haskell program can outpace it
06:45:19 <nullx002> comparing one at a time...
06:45:23 <chpatrick> nullx002: I wouldn't say haskell on GPU is really there yet...
06:45:23 <nullx002> hashing
06:45:30 <chpatrick> there's accelerate but I don't know if it's really ready
06:45:33 <EvilMachine> Lycurgus: Imagine if every banker and manager and politician and lobbyist and talking head and internet commentator had to fear the punches of everyone he’s influencing or talking to. ^^
06:45:34 <Lycurgus> hs certainly isn't it's performance in contrived situations notwithstanding
06:45:35 <geekosaur> Lycurgus, are we talking "generic" code or something that a good C compiler can optimize or hand-tuned code?
06:45:53 <chpatrick> Lycurgus: idiomatic haskell can beat idiomatic C in some cases
06:46:02 <chpatrick> with big emphasis on "some" :)
06:46:14 <Lycurgus> right that's what I said, contrived cases
06:46:14 <chpatrick> mainly because of inlining
06:46:15 <radens> mostly because GHC is magic
06:46:21 <chpatrick> why contrived?
06:46:29 <tdammers> a more interesting metric is "how much developer time does it cost in either language to develop code that meets the requirements wrt. features, performance, quality, and reliability"
06:46:31 <nullx002> ok 
06:46:38 <chpatrick> Lycurgus: http://www.serpentine.com/blog/2014/05/31/attoparsec/
06:47:07 <exio4> chpatrick: there are some optimizations that basically float out things you might have not realized that would have been evaluated twice in other languages :p 
06:47:08 <Lycurgus> C is essentailly the machine lang of this time
06:47:13 <EvilMachine> radens: GHC is amazing. especially with a LLVM backend.
06:47:25 <chpatrick> exio4: that's what I'm saying
06:47:34 <radens> tdammers: I feel like haskell will kill C with that metric, but so will everything. However Ihave a hunch haskell won't come out on top either.
06:47:57 <tdammers> radens: the point is, it depends on how you weight those requiremnts
06:48:04 <Lycurgus> EvilMachine, you mean a literal punch in the face? 
06:48:20 <exio4> attoparsec is also a nice example of `fast-as-hell` library written in Haskell (given that you use the proper combinators)
06:48:38 <EvilMachine> tdammers: Thanks. People always obsess over runtime optimization and forget development time optimization. So much so, that faster written code would still be done before the optimized one.
06:48:39 <tdammers> if runtime performance is critical, but the others can be sacrificed in order to meet that goal, then C probably outperforms Haskell by a good bit
06:48:41 <Lycurgus> people are fed up with the old order, that's for sure
06:48:53 <EvilMachine> Lycurgus: yes
06:49:26 <tdammers> and, conversely, if correctness is an important property, then Haskell would probably win by a fair margin from most of the alternatives
06:49:26 <merijn> EvilMachine: Plus, a lot of people obsessing over runtime have never actually looked into what sort of optimisation you do to make that fast :p
06:49:28 <bergmark> old school cleverness! case () of { _ | stub d -> ("deleted", "Deletion") ; [...]; _ -> ("modified", "Modification") }
06:49:36 <merijn> tdammers: Probably C++ would be better than C
06:49:51 <merijn> bergmark: So...-XMultiWayIf ? :p
06:49:57 <tdammers> merijn: could be, yes... I guess it'd depend on the problem at hand...
06:50:16 <merijn> tdammers: I don't think so, there's not many problems where C is more suited than C++, imo
06:50:18 <EvilMachine> Lycurgus: C the machine lang? Psh! When I was young, we still stuck wires onto the bus and tapped in bits with our own ten fingers! and our bytes had ten bits! ;)
06:50:36 <Lycurgus> when I began programming machine lang was common, even in banks and the like
06:50:48 <EvilMachine> Lycurgus: (actually: ditto)
06:50:48 <Lycurgus> now it's virtually never used
06:50:56 <tdammers> merijn: yeah, hmm, maybe "portable library" would fit C's bill
06:51:12 <Lycurgus> small stretches in C in a device driver or something
06:51:14 <merijn> tdammers: But C++ can expose backwards compatible C interfaces anyway
06:51:20 <EvilMachine> Lycurgus: It’s still used in game development, to squeeze out more frames in those tight loops)
06:51:33 <merijn> EvilMachine: Even there it's rare nowadays
06:51:34 <nullx002> writing assembly for 8084 is easy and not so for 4 core processors
06:51:39 <bollu> EvilMachine: really? I haven't seen that in a long time
06:51:48 <bollu> EvilMachine: like, it's there in Quake code
06:51:50 <nullx002> that is why may be machine languages died
06:51:55 <bollu> EvilMachine: but I don't think source has it
06:52:03 <Lycurgus> yeah there's some game that was originally coded in z80 or 8080 or motorola assembler
06:52:13 <tdammers> machine languages aren't dead, we've just mostly automated their use away
06:52:15 <merijn> You can check Unreal and see, the source is available now :)
06:52:17 <Lycurgus> but I looked into it and they had converted everything to HOL
06:52:29 <tdammers> compilers are smart enough these days to produce better machine code than humans most of the time
06:52:30 <nullx002> yes dead in sense of direct interaction
06:52:33 <merijn> Hell, all of the next Unreal Tournament's source is visible :>
06:52:40 <nullx002> like animal in humans is not dead and yet you can say it is dead
06:52:42 <tdammers> oh, also, cross-platform and all that
06:52:47 <merijn> I think it's even proper open source?
06:53:09 <exio4> tdammers: "machines are too complicated nowadays" :P 
06:53:09 <tdammers> it's just way more convenient to use an architecture-agnostic language and have the compiler sort things out, even if that means you won't get 100% optimized code
06:53:09 <Lycurgus> the Ground Based Shuttle software for example which I worked with was entirely BAL
06:53:46 <Lycurgus> based on a special build of MVS
06:53:50 <tdammers> people still write machine code btw... there's this whole "4096 byte demo" scene where they fit crazy stuff into 4 kB binaries
06:53:51 <EvilMachine> merijn: it’s more rare in game development because everyone’s using ready-made game engines and GPU shaders nowadays.
06:54:07 <chpatrick> tdammers: those are frequently generated with a tool though
06:54:19 <tdammers> yeah
06:54:22 <nullx002> hl used to create those binaries
06:54:48 <nullx002> nobody goes to hardware lab to write on assemblers anymore :D
06:55:02 <nullx002> may be academics
06:55:13 <Lycurgus> lol, especially not them
06:55:24 <EvilMachine> Lycurgus: you can bet that they still look at the resulting machine code though. They just tweak the high-level code to get what they want. Or the compiler if necessary. It’s writing-assembler-by-proxy. :)
06:55:30 <geekosaur> ...and was there ever a lot of grousing from hardcore gamers when the game devs switched away from assembler "games will be too slow!!!1!!eleventyone"
06:55:47 <tdammers> it's not uncommon in academia to write code that isn't intended to be compiled at all, let alone run
06:55:59 <nullx002> lol
06:56:16 <Lycurgus> oh yeah, looking at generated code, working with llvm yeah, but that's way different from the main dev lang being a macro assembler
06:56:27 <tdammers> but yes, just because you've stopped writing assembly by hand doesn't mean it's now irrelevant
06:56:36 <nullx002> writing machine code for unreal from scratch may take 10 years
06:56:54 <tdammers> just like understanding filesystems isn't irrelevant just because you've learned how to use find and rsync and such
06:57:09 <EvilMachine> nullx002: Uuum, “animal in humans”… humans are utterly animalistic. and that’s not a bad thing either. i am very happy we’re not (by definition psychopathic) robot Spocks. :)
06:58:03 <nullx002> EvilMachine ... but some day we wil
06:58:15 <nullx002> it is future
06:58:24 <geekosaur> doubt it
06:58:39 <nullx002> transfering consciousness to more stable storage system
06:58:48 <nullx002> or whatever you call it
06:58:56 <tdammers> crystal ball and all that
06:58:59 <tdammers> also, -blah material
06:59:04 <nullx002> lol
06:59:07 <Lycurgus> down/upload it's generally called
06:59:13 <nullx002> yes...
06:59:20 <Lycurgus> (of consciousness)
06:59:22 <nullx002> brain uploading
06:59:33 <nullx002> lot of researching is being done on that
06:59:46 <nullx002> cloaking devices created for testing
06:59:53 <nullx002> is it possible 100
06:59:55 <nullx002> %
06:59:58 <nullx002> ??
07:00:10 <Clint> ...
07:00:11 <nullx002> to transfer my brain to another body ? using programming techniques?
07:00:20 <tdammers> again, #haskell-blah
07:00:26 <geekosaur> ...and it will have to emulate animal behaviors; most people simply do not understand how deeply integrated and utterly necessary our animal "selves" our
07:00:29 <geekosaur> *are
07:00:30 <EvilMachine> tdammers: Wat? I can’t stand those idiots who think a search-based interface in acceptable, let alone intuitive. The whole point of the menu was, that the user cannot know what to pick, when he doesn’t know what’s available. A directory is kinda a menu. Find is searching. You can’t find anything, unless you already know what’s there. Which you don’t, most of the time.
07:00:56 <tdammers> EvilMachine: that's not what I meant at all
07:00:57 <EvilMachine> tdammers: And I don’t want my file management to become a game show where I have to guess the most likely name people give things… ^^
07:01:04 <EvilMachine> tdammers: Oh, then sorry…
07:01:08 <EvilMachine> tdammers: :/
07:01:26 <geekosaur> EvilMachine, hatre to say it but you just described an awfully large chunk of front-line tech support >.>
07:01:37 <bollu> EvilMachine: you can take fuzzy file searching from my cold dead hands
07:01:48 <bollu> you trawl through a git project with 100,000+ files
07:02:01 <tdammers> what I meant is that just because you have learned to automate your interactions with the file system, e.g. using tools like rsync or find, doesn't mean you can completely forget how things work, even though you don't use cp or even ls directly at all
07:02:31 <EvilMachine> geekosaur: :D
07:02:57 <EvilMachine> bollu: You misunderstood me. 
07:03:16 <bollu> EvilMachine: oh?
07:03:58 <EvilMachine> bollu: I did not say searching should be abolished. I’m saying file management cannot be abolished. Searching is just a nice last resort if the one managing the file/data structure failed. hard.
07:04:20 <bollu> EvilMachine: ah, I suppose.
07:04:42 <bollu> EvilMachine: I'm personally partial to the "files have enough semantic information to come to me when I want them". A man can dream
07:04:53 <EvilMachine> tdammers: nobody doesn’t use cp or ls (assuming we’re talking about command-line usage)
07:05:24 <indiagreen> EvilMachine: I think a search-based interface is acceptable and some form of it (possibly one that hasn't been implemented yet) is vastly preferrable to file management as we know it.
07:05:49 <EvilMachine> bollu: I had that dream too. I made it real. It sucked. Because I had to input so much semantic structure, that I did hardly anyting else. It’s simply not worth the maintenance.
07:06:08 <tdammers> indiagreen: the best UX is when you have a consistent data model and an open ecosystem of tools that users can mix, match and configure to their likings, with sensible defaults
07:06:14 <bollu> EvilMachine: heh, which is why NLP is important
07:06:22 <bollu> tdammers: that's never gonna happen
07:06:23 <geekosaur> AI-complete >.>
07:06:23 <tdammers> indiagreen: generally speaking, what we get is a "pick two" situation at best though
07:07:00 <tdammers> i.e., we can have "consistent data model" and "open ecosystem", but then we give up "sensible defaults"
07:07:14 <tdammers> (that's GNU/Linux/Unix)
07:07:29 <bollu> mac would be giving up "open ecosystem" ?
07:07:35 <tdammers> pretty much
07:07:46 <tdammers> and windows, idk, ... give up everything?
07:07:57 <bollu> I'd pick give up open ecosystem
07:08:03 <EvilMachine> indiagreen: No. Never. file management is already a “search”. the only difference is that you get to actually see what you can get before being asked to pick. and that directories (should) limit the amount of things you can pick to a human-manageable amount. searching is just dumping everything into a big bucket, stirring, putting a black sheet on top, and then telling you “pick what you want”… GAAAH! How can I 
07:08:03 <EvilMachine> know when I can’t see???
07:08:03 <bollu> over give up sensible defaults
07:08:24 <tdammers> bollu: sensible defaults are something that benefits you during the first few months, or even years, of use
07:08:43 <tdammers> bollu: open ecosystem is something that starts becoming useful later, but stays with you for a lifetime
07:09:20 <EvilMachine> bollu: natural language is a horrible mess, and should never be used. ever. it’s only used because it’s already used (circular logic, aka legacy). ^^
07:09:31 <bollu> tdammers: debatable, when you have a semi-open ecosystem
07:09:43 <tdammers> bollu: define "semi-open"
07:09:48 <EvilMachine> bollu: Give me a natural language that can even be defined in EBNF. :)
07:09:59 <bollu> EvilMachine: sanskrit :)
07:10:13 <tdammers> bollu: wanna take a bet on the sanskrit thing?
07:10:20 <bollu> tdammers: "afaik" :P
07:10:23 <bollu> tdammers: but.. sure
07:10:28 <bollu> tdammers: how many monies?
07:10:44 <tdammers> the thing with natural languages is that they encode much more than just objective meaning
07:10:56 <EvilMachine> bollu: There is no such thing as sensible defaults. Because you end up with the lowest common denominator, and then people degenerate to that. Which is exactly what we’re seeing with iTards.
07:11:18 <EvilMachine> gotta go. GF. HAND!
07:11:22 <bollu> EvilMachine: no, you can have a set of minimal defaults that admit change
07:11:41 <tdammers> the whole point of having defaults is so you can deviate from them
07:11:45 <bollu> tdammers: http://www.infinityfoundation.com/mandala/t_es/t_es_rao-t_syntax.htm
07:11:57 <bollu> tdammers: yes, but deviating from the defaults should not be a difficult process
07:12:01 <bollu> tdammers: see, emacs
07:12:07 <bollu> tdammers: so many defaults are so "baked in"
07:12:21 <bollu> tdammers: that you start breaking things that shouldn't break when you start changing the defaults
07:12:33 <bollu> tdammers: that's what I meant by "admit change"
07:13:24 <ski> bollu : (re baked in) possibly because people start (inadvertently) depending on the defaults
07:13:29 <dodo_> what is this room?
07:13:38 <bollu> ski: good pont
07:13:45 <bollu> dodo_: It's about the Haskell programming language
07:13:51 <dodo_> ok thank
07:13:54 <dodo_> goodbye
07:14:42 <tdammers> bollu: interesting read, though I can't help but wonder whether that Sanskrit grammar is actually accurate and complete
07:15:15 <ski> bollu : "The Robustness Principle Reconsidered - Seeking a middle ground" by Eric Allman in 2011-06-22 at <http://queue.acm.org/detail.cfm?id=1999945> is a bit related, i think
07:16:04 <bollu> tdammers: dad is a computer scientist and knows sanskrit, he says it is
07:16:14 <bollu> tdammers: there are rules for word building as well
07:16:20 <bollu> tdammers: and sentences and ...
07:16:30 <bollu> tdammers: apparently poetry is also very strict
07:16:42 <tdammers> what about neologisms?
07:17:09 <tdammers> what about people exploring the edges of the rule space, creating new rules by bending the old?
07:17:16 <bollu> tdammers: you can only form words under certain rules. So you're free to create new words, but they're always combinatorial
07:17:21 <bollu> no rule bending allowed
07:17:27 <tdammers> allowed by whom?
07:18:53 <bollu> tdammers: allowed by the grammar
07:19:03 <bollu> tdammers: if you agree on the language "sanskrit"
07:19:15 <bollu> then you're only allowed to construct new words that are formed from the old ones
07:19:17 <tdammers> dead language, then
07:19:23 <bollu> tdammers: yes, very much so
07:19:36 <bollu> tdammers: one of the reasons it died was because the tradition was oral
07:19:45 <bollu> tdammers: plus it was "guarded" by the brahmins
07:19:56 <bollu> tdammers: like, they didn't teach the language to everyone and whatnot
07:19:59 <tdammers> once you start guarding a language, it becomes artificial though
07:20:14 <tdammers> natural languages are in constant flux
07:20:17 <bollu> tdammers: eh, it was the same way much of math discourse happened in french
07:20:24 <bollu> tdammers: yes, but the 
07:20:41 <bollu> tdammers: yeah, but the "beauty" of sanskrit was the the flux was guarded by its own rules
07:21:16 <tdammers> ...which, once the rules are sufficiently agreed upon, makes it an artificial language
07:21:57 <bollu> tdammers: we can argue over "artificial"
07:22:03 <bollu> it survived for a thousand years or more
07:22:08 <bollu> and is still "alive"
07:22:16 <bollu> in the sense that priests still learn the language
07:22:22 <bollu> cause a lot of our rituals are _in_ sanskrit
07:22:57 <bollu> tdammers: *sigh* India is weird.
07:23:13 <tdammers> I'd say the breaking point for "artificial" is when language use follows formalized rules more than the other way around
07:23:31 <tdammers> also, using a dead language for rituals isn't all that weird
07:23:44 <tdammers> catholic church used latin until fairly recently, and they still do on some occasions
07:23:49 <bollu> tdammers: what _is_ weird is there are kid competitions to memorising the Bhagvad Gita
07:24:04 <bollu> tdammers: which is pretty frikkin huge and is all in sanskrit
07:24:09 <tdammers> vOv
07:24:13 <bollu> tdammers: plus you have to recite it according to meter
07:24:21 <bollu> tdammers: like I said, strict rules for poetry
07:24:27 <tdammers> so? an intellectual sport...
07:24:49 <bollu> tdammers: sure, but there's no real point
07:24:55 <bollu> tdammers: I'd much rather you teach kids math or sometin
07:24:59 <bollu> something*
07:25:22 <tdammers> you mean, because Math has less formal rules and concerns itself with the real world?
07:25:24 <tdammers> :P
07:26:20 * ski . o O ( "The Dream of a Perfect Language" (Part IV) by Umberto Eco in 1996-11-26 at <http://www.aymara.org/biblio/html/dream4.html> )
07:30:06 <bollu> tdammers: :) That, or it teaches people some cool things need to have zero practical use in life
07:30:35 <tdammers> but then memorizing epic sanskrit poetry might have the same effect. q.e.d. :D
07:30:44 <bollu> xD
07:37:49 <nullx002> [2,'a'..'y']
07:37:53 <nullx002> throws error
07:37:59 <geekosaur> yes?
07:38:09 <nullx002> while [2,1..10] works
07:38:12 <geekosaur> what were you expecting? they're not the same types
07:38:31 <nullx002> ['a'..'y'] works
07:38:48 <geekosaur> also... "works" I think for that second one? it would be "infinite"
07:38:53 <nullx002> so what shuold be code for a,c,e,g,i,k
07:39:04 <merijn> geekosaur: Not for a finite type :)
07:39:19 <geekosaur> see scare quotes on "infinite"
07:39:31 <quicksilver> > [2,1..10]
07:39:32 <ski> > ['a','c' .. 'k']
07:39:33 <lambdabot>  []
07:39:33 <lambdabot>  "acegik"
07:39:45 <geekosaur> oh, it checks that, ok
07:39:46 <nullx002> λ >> [b,'a'..'y']
07:39:47 <nullx002>  
07:39:47 <nullx002> <interactive>:29:2: Not in scope: ‘b’
07:39:48 <quicksilver> not infinite, it checks if the step is in the wrong direction
07:40:03 <geekosaur> nullx002, I thoink you misunderstand that syntax
07:40:10 <geekosaur> it expands to enumFromThenTo
07:40:46 <Ankhers> [base, step..max]
07:40:50 <geekosaur> no
07:40:58 <geekosaur> [base, next..max]
07:41:25 <byorgey> > [1, 4 .. 10]   -- here step == 3
07:41:26 <Ankhers> Right, step is incorrect...
07:41:27 <lambdabot>  [1,4,7,10]
07:41:42 <nullx002> try  ['a','c' .. 'k']
07:41:48 <nullx002> infinite loop of a
07:41:56 <byorgey> > ['a', 'c' .. 'k']
07:41:58 <lambdabot>  "acegik"
07:42:03 <nullx002> ['a','a'..'y']
07:42:21 <byorgey> yes, ['a', 'a' .. 'y'] is an infinite string of a's
07:42:23 <geekosaur> that would be an infinite loop of 'a', yes
07:42:35 * ski . o O ( `FOR I = base TO max STEP step' )
07:42:36 <geekosaur> you told it a, then a, then ..., then y
07:42:48 <geekosaur> so it never manages to get away from the a
07:42:57 <ski> nullx002 : you need an initial `> ' (or `@run ') for lambdabot to interpret it as an expression to evaluate
07:43:00 <nullx002> so [1,1..10]
07:43:15 <tdammers> > [1,1..10]
07:43:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:43:18 <nullx002> would return infintie 1s ?
07:43:22 <byorgey> yep
07:43:22 <tdammers> yes
07:43:37 <nullx002> strange
07:43:45 <tdammers> generally, [a,b..c] means "start at a, add (b - a) until you reach c
07:43:52 <tdammers> (except it's not literally -)
07:44:00 <nullx002> why not [1..10] == [1,1..10] 
07:44:17 <ski> why add strange exceptions ?
07:44:32 <tdammers> because, again [a,b..c] specifies the step size by giving the first two list elements
07:44:35 <nullx002> logically it should
07:44:42 <tdammers> no, it should not
07:44:52 <tdammers> the logic is, derive a list from the first two elements and an upper limit
07:45:15 <tdammers> if the first two elements are equal, the limit will never be reached, so logically the list must be infinite
07:45:27 <bollu> > [10, 9, ..1]
07:45:29 <lambdabot>  <hint>:1:9: parse error on input ‘..’
07:45:30 <bollu> maybe that will help
07:45:38 <tdammers> > [10,9..1]
07:45:39 <nullx002> yes nothing in reverse
07:45:39 <bollu> > [10, 9..1]
07:45:39 <geekosaur> if you type it properly...
07:45:42 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
07:45:42 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
07:45:55 <tdammers> > [10,9..11]
07:45:59 <lambdabot>  []
07:46:22 <tdammers> that doesn't quite illustrate my point does it
07:46:34 * zaquest is surprised about [s..e] != [s, succ s, succ (succ s) .. e = succ (... (succ s))]
07:46:52 <geekosaur> zaquest, it's supposed to be. some instances break that
07:47:26 <geekosaur> because for numbers it's often more convenient for it to be some notional (+1) instead of succ.
07:47:33 <geekosaur> ...and yes, this is often debated
07:47:59 <bollu> I'm surprised that it doesn't work for any monoid
07:48:08 <geekosaur> (basically, Enum/Bounded really need to be reworked completely; ranges and enumerations should not be conflated)
07:48:08 <bollu> well, any group, actually
07:48:18 <bollu> you'd need a group to find the distance between 2 and 1
07:48:18 <nullx002> ok was confused about syntax
07:48:20 <nullx002> now it is more clear
07:48:41 <bollu> actually, what do you need? you'd just need (+, -)
07:48:47 <bollu> so, identity, op, inverse
07:48:49 <bollu> yeah, group
07:48:52 <indiagreen> a stupid idea for a GHC extension: {-# LANGUAGE UseOEIS #-} queries OEIS whenever it sees [a,b,c..x] and substitutes the query result for the actual thing (for bonus points, it can also download Haskell code that is often present in OEIS descriptions, and inline it)
07:48:54 <nullx002> wonder how this range can be useful in practical applications...
07:49:02 <byorgey> bollu: that would work for  [a, b .. c]  but not for  [a .. b]
07:49:23 <byorgey> @oeis  1,2,4,8
07:49:39 <lambdabot> Plugin `oeis' failed with: <<timeout>>
07:49:44 <byorgey> =(
07:49:46 <ski> indiagreen : polynomial extension might be more reasonable
07:49:57 <indiagreen> hm-m
07:49:58 <bollu> indiagreen: ambiguous as hell :P
07:50:02 <ski> @oeis 1 2 4 8
07:50:03 <lambdabot>  Powers of 2: a(n) = 2^n.[1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16...
07:50:10 <byorgey> ah, thanks ski =)
07:50:21 <bollu> @oeis 1 3 3 7
07:50:28 <chpatrick> indiagreen: sounds like a good use case for a quasiquoter
07:50:31 <bollu> aww
07:50:37 <chpatrick> well
07:50:39 <chpatrick> "good"
07:50:44 <lambdabot> Plugin `oeis' failed with: <<timeout>>
07:50:46 <nchambers> whats a good object in haskell to represent a parse tree/ast?
07:50:58 <ski> @oeis 0
07:50:58 <lambdabot>  []
07:51:02 <byorgey> nchambers: an algebraic data type
07:51:08 <chpatrick> or Free
07:51:08 <quicksilver> geekosaur: actually succ is also broken
07:51:14 <quicksilver> > succ 1.0
07:51:16 <lambdabot>  2.0
07:51:28 <quicksilver> the whole range notation has caused far more pain than good :)
07:51:29 <nchambers> byorgey: what would that look like? (sorry I'm not too good at math)
07:51:38 <quicksilver> although it's nice to be able to say [1..9] for sure.
07:51:43 <geekosaur> quicksilver, yes, that was implicit in the conflating ranges and enums bit
07:51:47 <ski> nchambers : depends on the grammar in question
07:52:06 <nchambers> ski: fair enough
07:52:12 <byorgey> nchambers: for example,  data MyAST = Var String | Plus MyAST MyAST | Times MyAST MyAST
07:52:25 <geekosaur> actually, given the newfound willingness to change stuff, maybe I should dig up that old thread where we worked out a proper hierarchy for this stuff
07:52:25 <byorgey> could represent parses of things like  ((x+y) * z)
07:52:30 <quicksilver> geekosaur: well it wasn't clear in your answer to zaquest, that's why I said it. They suggested s, (succ s), (succ (succ s)) - and that is pretty close in fact.
07:52:48 <nchambers> hmm ok byorgey thanks, that makes sense
07:52:49 <bollu> @oeis 1 2 3 5
07:52:55 <bollu> @oeis 2 3 5 7
07:53:02 <geekosaur> yes, but when people say that they often mean that you should get the next-in-bit-order Double, not (+1)
07:53:09 <bollu> it would be so cool if it gives me the primes
07:53:09 <quicksilver> yes indeed
07:53:12 <lambdabot> Plugin `oeis' failed with: <<timeout>>
07:53:15 <bollu> :(
07:53:22 <quicksilver> bollu: it would if it wasn't broken.
07:53:31 <quicksilver> maybe the site is down
07:53:46 <byorgey> it just worked for ski above
07:53:53 <quicksilver> geekosaur: I think I'd be quite happy if the range notation was restricted to integer-like types
07:53:56 <byorgey> @oeis 2 3 5 7
07:54:02 <geekosaur> or the vvhost lb is on is overloaded or has a bad network connection...
07:54:07 <geekosaur> *vhost
07:54:12 <bollu> geekosaur: I want range to work with any group
07:54:14 <byorgey> that sounds more likely
07:54:14 <lambdabot> Plugin `oeis' failed with: <<timeout>>
07:54:29 <geekosaur> bollu, first you have to get groups added
07:54:32 <quicksilver> geekosaur: it's no great hardship IMO to type doublerange = map fromIntegral [1..9] if you need that.
07:54:39 <bollu> geekosaur: because you can find step = 2nd - 1st, term(n) = begin + step  * (n - 1)
07:54:47 <bollu> geekosaur: fair  :P
07:54:54 <bollu> geekosaur: how would we go about doing that? -_^
07:54:57 <bollu> I have no idea
07:55:13 <geekosaur> not sure if they're even getting Semigroup into base somewhere in the 8.x series...
07:55:13 <quicksilver> bollu: you need more than groups. You need groups with an identified notion of 'one'.
07:55:44 <geekosaur> unfortunately this is a longstanding annoyance, and as soon as you drag in groups and rings, you land in the whole Num-hierarchy-redesign mess
07:55:59 <geekosaur> which regularly argues itself to a standstill without accomplishing anything
07:56:09 <bollu> quicksilver: well
07:56:18 <bollu> quicksilver: if you supply 2 terms
07:56:23 <bollu> quicksilver: then you don't need that
07:56:31 <bollu> quicksilver: since you can get the step size
07:56:37 <quicksilver> bollu: but the most common usage of this notation is just start..finish
07:56:49 <bollu> quicksilver: true. Maybe we could specialize
07:57:16 <zaquest> geekosaur, the worst is that default implementation breakes it :|
07:57:43 <bollu> geekosaur: how do you get redesign passed?
07:58:25 <zaquest> for enum
07:58:53 <geekosaur> first you convince the community that it's needed (there's a voting process). Num hierarchy redesign-related stuff never manages to reach that point... the arguing that starts up when it's raised makes it clear that there is no consensus
07:59:29 <bollu> geekosaur: why the debate on numbers?
07:59:46 <bollu> geekosaur: but, well, I don't think Haskell's type system is powerful enough right now anyway
07:59:56 <bollu> cause, like, you'd have 2 groups over reals
08:00:05 <bollu> (R, +, 0) and (R, *, 1)
08:00:10 <bollu> which also form a ring
08:00:10 <bollu> soo
08:00:11 <bollu> idk
08:00:45 <bollu> geekosaur: what's the standard solution?
08:01:12 <geekosaur> newtypes.
08:01:21 <geekosaur> see for example Sum and Product newtypes for Monoid
08:01:25 <bollu> geekosaur: um, could you elaborate? I'm curious
08:02:07 * geekosaur currently looking to see if there's a decent summary of the Num redesign stuff or of you get to read the mailing list archives --- shouldn;t be too hard, it recurs fairly often >.>
08:02:16 <bollu> oh, so I misspoke about type system power?
08:02:23 <bollu> or would it be fugly with the newtyping?
08:02:30 <geekosaur> it's fugly
08:02:48 <geekosaur> > getSum (Sum 2 <> Sum 4)
08:02:49 <lambdabot>  6
08:03:56 <bollu> geekosaur: oh. hardly neat
08:03:58 <quicksilver> > ala Sum foldMap [2,3,4]
08:04:00 <lambdabot>  9
08:04:10 <quicksilver> we have various ways of sorting out but....
08:04:27 <quicksilver> typeclasses are not the best tools when you have a million possible instances around.
08:04:57 <quicksilver> they're well suited when you want to overload some operations over the obvious, best, or only instance per type
08:05:19 <bollu> geekosaur: is there a "solution" to this type theoretically?
08:05:37 <bollu> I'm writing my own functional language (like everyone else :) ) and I'd like to have a proper numeral hierarchy
08:06:25 <FreeFull> :t ala
08:06:26 <lambdabot> (Rewrapped s t, Rewrapped t s) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
08:06:42 <tdammers> I just keep writing template engines, but they all end up being complete programming languages
08:06:58 <geekosaur> I think all I can say is "think about it" --- somehow it has to know which one you intend. there's "ala" as shown by quicksilver, there's something like ML's "open" to bring one of them specifically into local scope...
08:08:49 <quicksilver> tdammers: I keep writing HTML parsers in regexp and they keep turning into elder gods and eating my mind :/
08:09:30 <bollu> quicksilver: you're using the wrong tools ;)
08:10:28 <bollu> geekosaur: so no one has a fool proof solution? damn :/
08:10:59 <geekosaur> the more general you get, the harder it becomes to pick a specific one automatically
08:11:07 <tdammers> quicksilver: bigger hammer principle suggests you're not using enough regular expressions
08:11:21 <bollu> tdammers: lol. Have you seen the email regex?
08:12:18 <tdammers> bollu: there are many, but yes, I've seen a lot of them, including ones that implement all of the relevant RFC's
08:13:23 <tdammers> and then still all you get is well-formedness, you still don't know whether the mail server exists, whether it will accept mail from you, whether the recipient address is known on the server, whether anyone actually looks at that mailbox, whether they can read...
08:13:41 <geekosaur> ...judging by how many sites reject perfectly valid addresses, I imagine the latter are mostly used to frighten children
08:13:50 * hackagebot persistent 2.2.1 - Type-safe, multi-backend data serialization.  https://hackage.haskell.org/package/persistent-2.2.1 (GregWeber)
08:15:15 <pyon> Is there any way to consult Haddock documentation without a web browser?
08:15:31 <pyon> Or at least without a GUI web browser.
08:15:46 <Ankhers> You should be able to generate it locally
08:15:53 <Ankhers> Wait
08:15:58 <Lycurgus> you mean generate char oriented documentation
08:16:03 <pyon> Yeah.
08:16:27 <pyon> In order to read it, say, within Emacs.
08:16:32 <Lycurgus> prolly not if it's TeX based
08:17:02 <quicksilver> it's not TeX based. It's just haskell comments -> html
08:17:06 <shapr> pyon: you could always use the web browser(s) inside emacs, but I do also wish haddock had text-only output
08:17:18 <quicksilver> but I don't think it has any non-html b ackends
08:17:54 <pyon> Mmm...
08:18:08 <Lycurgus> in principle HTML could work in lynx/links/etc
08:18:28 * geekosaur wonders what pandoc would do with the html
08:18:33 <Lycurgus> i.e if it were coded for that
08:18:39 <Lycurgus> would work fine
08:19:00 <lispy> It's time for another round of 'hask anything' https://www.reddit.com/r/haskell/comments/3mpip2/hask_anything_the_thread_where_you_ask_and_we_try/
08:19:24 <Ankhers> There are probably html to markdown programs.
08:19:36 <Ankhers> Not necessarily ideal, but it could work.
08:19:38 <quicksilver> chrisdone had some kind of limited haddock view in emacs
08:19:48 <quicksilver> https://www.fpcomplete.com/content-proxy?src=http%3A%2F%2Fchrisdone.com%2Ffpco%2Fhaddocks.png
08:19:56 <quicksilver> (frmo https://www.fpcomplete.com/blog/2013/12/api-emacs )
08:20:20 <pyon> quicksilver: Wow, looks cute. :-)
08:20:22 <bollu> what's hask anything?
08:20:35 <bollu> ooh, cool!
08:20:38 <bollu> Q&A session :)
08:21:40 <magneticduck> https://gist.github.com/2529b4859d1eae71c3d7
08:21:42 <magneticduck> https://gist.github.com/2529b4859d1eae71c3d7
08:21:48 <magneticduck> so I thought this would work ^ but it doesn't, apparently
08:21:54 <lispy> bollu: yup
08:22:03 <magneticduck> how do I export all symbols from a module, save a few?
08:22:42 <lispy> magneticduck: There isn't a wild card trick or anything. You have to name the exported ones and not name the non-exported.
08:23:08 <magneticduck> lispy: there are a *lot* of symbols coming from that module
08:23:15 <magneticduck> like a *lot*
08:23:27 <geekosaur> there is no export equivalent to "hiding"
08:23:28 <exio4> may I suggest a nice trick of having ModuleX.Internal or whatever, and ModuleX importing ModuleX.Internal hiding (a,b,c)? :p
08:23:56 <lispy> Yeah, if you're willing to reexport, then you have more options
08:24:11 <magneticduck> geekosaur: 'importing'?
08:24:17 <magneticduck> that looks promising
08:25:03 <magneticduck> uh, s/geekosaur/exio4 
08:25:08 <magneticduck> exio4: how exactly does that work?
08:25:38 <magneticduck> so I have a module with a whole bunch of symbols, call it DB, and I want to use a symbol internally but not export it via a higher level module
08:26:25 <exio4> module M.Internal where data A ; data B ; f :: A -> B ; g :: B -> A ; module M (module M.Internal) where import M.Internal hiding (f,g) ? 
08:26:45 <magneticduck> exio4: I'm trying that, but it doesn't work
08:26:46 <exio4> (I am not sure if this works, though, maybe module bypasses the hiding clause, worth a try, though)
08:26:47 <geekosaur> put that symbol in an Internals module, import it qualified? I think then it would only be exported if you named it explicitly?
08:27:10 <magneticduck> exio4: yeah, the latter happens
08:27:10 <exio4> magneticduck: nevermind then, sorry :) 
08:31:53 <magneticduck> well this gives me an opportunity to document 50 symbols
08:32:15 <geekosaur> magneticduck, did you try my suggestion
08:32:16 <geekosaur> ?
08:32:17 <NightRa> How can I get this sort of quality annotated source locally? http://hackage.haskell.org/package/Cabal-1.22.4.0/docs/src/Distribution.Text.html#Text
08:32:49 <geekosaur> I am pretty sure that if you import it qualified, the only way it gets re-exported is exporting that qualified symbol explciitly or exporting its module
08:33:26 <magneticduck> geekosaur: I know how to only export symbols I name explicitly
08:33:30 <Clint> NightRa: apt-get install ghc-doc
08:33:38 <magneticduck> I need to not exports symbols I name explicitly, that would otherwise be exported
08:33:41 <geekosaur> sigh, ok, you did not understand
08:33:44 <magneticduck> oh
08:33:51 <geekosaur> import qualified MyModule.Internal as I
08:33:59 <geekosaur> now those symbols are not default-exported
08:34:17 <geekosaur> they will only be exported if you list them or list their module in the export list
08:34:26 <geekosaur> *unqualified* symbols are default-exported
08:34:56 <NightRa> Clint: I mean, generate it locally,  with the source of a local package & all of it's dependencies
08:35:17 <geekosaur> (actually I think even just importing shouldn't re-export it, or pretty much every module would be exporting Prelude...
08:35:27 <magneticduck> geekosaur: yeah
08:35:41 <magneticduck> whether it's qualified or not, you have to export explicitly, either symbols from the module or 'module Module'
08:35:46 <eikke> is there any way to add a calculated value to criterion reports?
08:36:11 <geekosaur> so just put the symbols you don't want to reexport in another module, possibly by having that module import just those symbols and re-export them explicitly
08:36:13 <magneticduck> but in this case, what I"m trying to avoid doing is listing all the symbols I want to export, while at the same time not exporting a few of them
08:36:22 <geekosaur> hm, wait
08:36:40 <magneticduck> oh I see what you mean
08:36:48 <magneticduck> it would be nice if that could work
08:37:01 <geekosaur> mmm, I think I was about to siggest what we already found didn't work :/
08:37:09 <geekosaur> bleh
08:37:26 <magneticduck> mailing list time?
08:37:42 <geekosaur> probably. or SO
08:37:44 <magneticduck> in the meanwhile I will manually read through a 500 line quasiquote and list every symbol in question
08:37:51 <magneticduck> yaay
08:37:56 <geekosaur> ...I'd script that...
08:38:17 <magneticduck> well it's 500 lines, but only 5 percent of the lines are symbols
08:38:26 <magneticduck> uh, or something that's not so staggeringly huge
08:38:27 <geekosaur> NightRa, what "annotation"? the colored source?
08:38:57 <geekosaur> I think if you have hscolour installed it does it automatically?
08:38:57 <NightRa> geekosaur: Colored + jump to definition
08:39:40 <geekosaur> cabal haddock --hyperlink-source?
08:39:48 <osa1> it's good to see that HUnit is maintained
08:41:14 <NightRa> geekosaur: cool. Can I generate the haddocks for all dependencies + prelude too, such that I'll have hyperlinking between everything at the same time?
08:42:03 <fractalsea> We’re trying to write a low-latency messaging system. The problem is we are getting a lot of latency spikes. See this image: http://i.imgur.com/GZ0Ek98.png (yellow to red is the 90th percentile). I have tried to eliminate the problem by removing parts of the system that I suspected to be expensive, but the spikes are still there. I’m now thinking that it’s the GC. As you can see in this output from 
08:42:03 <fractalsea> ghc-events-analyze, work on the GC thread (red) seems to be blocking work on the main program thread (green) http://i.imgur.com/4YO5q4U.png. Do you think this is the most likely culprit? Is there anything I can do to confirm this hypothesis? If it is the GC, then is there anything that can be done about it? Thanks!
08:42:24 <geekosaur> not easily, I'm afraid. and not for Prelude or other modules in base; my understanding is that making the docs means rebuilding the library, as it is currently implemented
08:42:51 <geekosaur> so you can't build docs for base except as part of a ghc build, and you'd have to reinstall every other library :/
08:43:43 <geekosaur> you could try it with a recent cabal-install to see if it will work without doing cabal build first...
08:43:44 <NightRa> I'd be ok with reinstalling all the libraries for that..
08:44:07 <geekosaur> right, but you don't get to rebuild or reinstall base
08:44:11 <geekosaur> meaning Prelude and friends
08:46:33 <davd_> any pointers on invoking a process with binary stdout? seems ridiculously hard to achieve with CreateProcess { std_out = CreatePipe}....
08:47:20 <davd_> that's in the process package
08:48:38 <geekosaur> hm? hSetBinaryMode on the returned pipe. if you mean in the program you are launching, you cannot do that from outside unless the program you are running provides a way
08:49:27 <davd_> but that means I have to fetch data from pipes while checking if the program has terminated
08:49:31 <geekosaur> even if you found a way to stick a hSetBinaryMode on its side of the pipe, *it would be ignored* because Haskell never uses it
08:49:44 <geekosaur> threads
08:49:56 <geekosaur> haskell expects you to use threads
08:50:34 <davd_> I'm running clang with -o/dev/stdout
08:51:05 <quicksilver> fractalsea: yes, it's probably GC. GC has many parameters you can tune which will effect the latency.
08:51:18 <davd_> I mean.. if it was ascii output there's simply readProcessWithExitCode
08:51:32 <quicksilver> fractalsea: I'm no expert, you might try the glasgow-haskell-users mailing list if you don't find good answers here.
08:54:00 <fractalsea> quicksilver, Thanks. I have tried tuning the -H vlues with values: -H8m -H512m H1024m. All of which performaned worse than the default. I also tried -A2048m (because the docs say either set it to the L2 cache size (which I also tried), or make it very large). Again, that also performed worse.
08:54:07 <fractalsea> I’ll try the mailing list
08:55:12 <quicksilver> fractalsea: nice visualisation btw :)
08:58:01 <fractalsea> quicksilver, Thanks, yeah we have some good benchmarking tools
08:59:52 <chpatrick> :t cont $ \cc -> cc $ Right (cc . Left)
08:59:53 <lambdabot> Cont c (Either a (a -> c))
09:08:39 <davd_> is it safe to do proc <- createProcess (stdin = pipe); cont <- getContents pipe; waitForTermination proc ? and always read the entire buffer?
09:10:04 <Hafydd> davd_: that will likely result in a deadlock when writing to the pipe blocks.
09:10:32 <Hafydd> Wait... stdin?
09:10:41 <davd_> stdout*
09:10:50 <Hafydd> Okay, then I maintain the above.
09:11:27 <davd_> aha.. I see
09:11:35 <Hafydd> ...oh, wait, I somehow read your statements above in the wrong order.
09:11:57 <Hafydd> Well, it will not result in a deadlock as long as the subprocess doesn't wait for anything else when writing to stdout.
09:12:24 <Hafydd> In particular, I think that it will inherit the current process's stderr by default, so you want to be sure that behaves as you expect.
09:12:49 <davd_> sure, but will getContents make sure that writer is never blocked? it's really unclear to me how it works
09:13:37 <Hafydd> getContents will read until an end-of-file condition is reached, which isn't necessarily when the pipe is closed, nor when the process is going to terminate; but the protocol is that it usually is.
09:14:37 <clrnd> so I'm working on a workshop for a meetup, we are gonna show how to scrap websites in simple "vanilla haskell" (no $, no pointfree, etc)
09:14:59 <clrnd> which HTML parsing lib would you suggest? 'taggy' seems nice
09:15:17 <sunnymilk> $ isnt vanilla haskell?
09:15:19 <clrnd> I've used hexpat but that's far from simple
09:15:33 <bollu> sunnymilk: it confuses the fuck out of people
09:15:41 <bollu> sunnymilk: people get hung up on $
09:15:42 <sunnymilk> also for all my xml/html extraction needs i use hxt-xpath
09:15:46 <bollu> sunnymilk: and (.) actually
09:15:53 <sunnymilk> bollu but its literally just identity
09:16:08 <clrnd> sunnymilk, bollu yeah, for people obvlivious to haskell and custom infix operators, it can be bothering
09:16:17 <athan> @src ($)
09:16:17 <lambdabot> f $ x = f x
09:16:22 <bollu> sunnymilk: it's intimidating, and the only other semi-mainstream language that uses it is PHP, perl and APL
09:16:31 <bollu> do you really wanna associate Haskell with any of those? :P
09:16:33 <eikke> Qbasic had it!
09:16:35 <clrnd> most people have problems separating application from composition in real life, not everyone studies CS or likes SML
09:16:36 <sunnymilk> "this is the $ operator, its the identity function, its only purpose is to let you avoid writing parentheses"
09:16:42 <johnw> bollu: I've come to love the $
09:16:59 <eikke> sunnymilk: it also allows for some pretty nice source code alignment, compared to brackets
09:17:08 <bollu> sunnymilk: ($), (.), function application with no brackets, everything-is-an-expression, main :: IO ()
09:17:14 <clrnd> ok we are diverging form my question :P
09:17:15 <bollu> sunnymilk: it all adds up
09:17:20 <johnw> I especially use $ to divide "semantic domains".  For example: when x $ do ...
09:17:31 <athan> But! ` ` isn't defined metacircularly (I asked on SO once)
09:17:34 <johnw> even though both are argument to when, one relates more to when, and one relates to what I want done
09:17:35 <sunnymilk> eikke yeah
09:18:18 <clrnd> sunnymilk, hxt uses arrows, I'm looking for something simpler
09:18:31 <eikke> take 10 $ drop 50 $ map f $ filter g myList, but now imagine every partim is longer, and line-split before the $ except for the first and indent all $s underneath eachh other
09:18:34 <sunnymilk> you dont need arrows
09:18:46 <sunnymilk> just parseHtmlDocument or whatever its called, and then getXPath
09:18:47 <bollu> eikke: let (|>) = flip ($)
09:19:00 <bollu> myList |> filter g |> map f |> drop 50 |> take 10
09:19:04 <bollu> ahh, the beauty :)
09:19:15 <eikke> bollu: doesnt make any difference, in fact, except for the order
09:19:29 <bollu> eikke: flows left-to-right, easier to imagine semantically.
09:19:30 <sunnymilk> eikke what i like to do when ive got a function thats just a map (and maybe some things after that) is flip the map and put the function to map over it as the "body" of the function
09:19:32 <eikke> bollu: unless you think "|>" is more obvious than "$" for some-Java-guy
09:19:47 <johnw> bollu: easier unless you're used to thinking in terms of mathematical composition
09:19:47 <bollu> eikke: naww. I just think the idea of "streaming" left-to-right is nicer to show newbies
09:19:52 <sunnymilk> eg f xs = (flip mapM) xs $ do\n thing; otherthing; return whatever
09:19:53 <eikke> sunnymilk: your mapped function isn't always locally defined
09:20:07 <sunnymilk> so $ is really useful for that
09:20:08 <bollu> johnw: you usually never mathematically compose long chains like you do while programming
09:20:21 <bollu> johnw: so left to right reads more naturally than inside to outside
09:21:16 <johnw> "more naturally" is a matter of perception
09:21:23 <bollu> johnw: that's fair :)
09:21:27 <davd_> Hafydd: great, thanks for the explanation! :)
09:21:38 <clrnd> any alternative to hxt?
09:21:59 <bollu> johnw: but in my experience, while introducing people to the cult of haskell
09:22:04 <johnw> I've had many humorous arguments with people about code formatting who insisted that their preference was obviously more correct.  Isn't it obvious??? :)
09:22:06 <bollu> johnw: I usually define (|>)
09:22:14 <bollu> johnw:  :P
09:22:19 <johnw> bollu: the lens library call |> by the name &
09:22:31 <johnw> in the sense of "and do this..."
09:22:32 <bollu> johnw: & got added into GHC right?
09:22:36 <johnw> I think so
09:22:39 <bollu> into Prelude**
09:22:43 <Hafydd> davd_: I forgot about lazy IO. hGetContents will in fact cause the pipe to block until you evaluate all the items in the list 'cont' (or call hClose). There is a package with System.IO.Strict.hGetContents which does read the whole file strictly, implemented like this: hGetContents h = IO.hGetContents h >>= \s -> length s `seq` return s.
09:22:46 <bollu> but they're basically the same thing at this point...
09:22:48 <indiagreen> bollu: no, into Data.Function
09:22:49 <johnw> don't know about Prelude
09:22:54 <bollu> johnw: oh, TIL
09:23:04 <geekosaur> @index (&)
09:23:04 <lambdabot> Data.Function
09:23:27 <exio4> the only thing (|>) might have of easier is that it looks like an arrow, not the order itself I would say
09:23:39 <bollu> > [1..10] & map (+ 1) & filter(> 5) 
09:23:41 <lambdabot>  [6,7,8,9,10,11]
09:23:41 <exio4> either way, I found that idiomatic F# code useS (|>) for type-inference reasons
09:23:43 <eikke> > let (<|) = ($)
09:23:43 <bollu> neat
09:23:44 <johnw> there's also >>> for composition
09:23:45 <lambdabot>  <no location info>: not an expression: ‘let (<|) = ($)’
09:23:51 <johnw> which will means using $ one time to provide the argument
09:23:54 <johnw> (or &)
09:23:55 <bollu> exio4: yeah, for unification
09:24:21 <eikke> exio4: is that because the inference engine is one-way?
09:24:50 <exio4> eikke: it "infers type as it goes thru the code" and doesn't apply future knowledge to infer stuff read previous or something like that, I haven't read a lot on this
09:24:51 <Hafydd> davd_: but to achieve what you seem to be writing, it may be better to use System.Process.readProcess.
09:24:54 <bollu> eikke: IIRC its because when they unify types, they need to know the RHS, while $ delays function binding
09:25:04 <bollu> like, $ needs the right hand side for the type
09:25:05 <bollu> :t ($_
09:25:07 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:25:09 <bollu> :t ($)
09:25:10 <eikke> exio4: that's what I meant, indeed :)
09:25:11 <lambdabot> (a -> b) -> a -> b
09:25:33 <bollu> :t flip ($)
09:25:34 <lambdabot> a -> (a -> c) -> c
09:26:13 <bollu> exio4: so the argument that I understood was thaw with $, you need to decide on exactly what "a" to use, while with (|>), since you have the concrete "a", the inference works right
09:26:53 <davd_> Hafydd: ouch... the problem is that readProcess doesn't allow any operations on the handles (e.g. binary mode).. hence why I'm stuck with this problem
09:27:00 <eikke> bollu: GHCs inference engine works different than the F# one
09:27:20 <bollu> eikke: yes, I know :) I was trying to describe the problem with F#
09:27:42 <Hafydd> davd_: then either use lower-level (non-lazy) read operations, or make sure you consume the entire list before waiting for the process to close.
09:29:08 <davd_> Hafydd: okay. guess I need threading to make sure it works with stderr and stdout, or do some incremental reading approach
09:29:20 <exio4> anyway, composition is different to function application
09:29:31 <Hafydd> davd_: also, is it not possible to create your own pipes with the relevant modes pre-set, then pass them to readCreateProcess?
09:29:33 <exio4> (.) is associative, and it's easier to factor out 
09:30:36 <davd_> Hafydd: no, it explicitly overwrites them, haha
09:31:06 <Hafydd> davd_: it overwrites the modes on the other ends of the pipes?
09:32:43 <davd_> Hafydd: it accepts a configuration record but the stdin/stderr/stdout fields are overwritten
09:33:14 <clrnd> coming down from the ($)/(.) discussion, what would you recommend as a HTML parsing lib for noobs?
09:33:49 <Hafydd> Oh.
09:34:07 <Hafydd> Right.
09:34:31 <davd_> this is a mess
09:36:21 <Hafydd> davd_: what is the problem with fully evaluating the output list?
09:37:27 <davd_> Hafydd: I think the producer can be blocked when writing to stderr if the consumer is fully evaluating stdout
09:38:24 <Hafydd> davd_: if you're doing it like that, your process's stderr is connected to a terminal, I wouldn't think that would happen.
09:38:39 <Hafydd> But if you're doing something more unusual with the stderr, that might be a concern (and then using threads would be a good idea).
09:39:53 <davd_> right.. will write up a solution using async
09:40:17 <Hafydd> davd_: you might want to refer to the implementation of readCreateProcessWithExitCode: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/process-1.2.3.0/src/System-Process.html#readCreateProcessWithExitCode
09:41:14 <Hafydd> (But the way it's implemented there seems a bit dirty. I think there's a cleaner implementation.)
09:42:02 <G40ST> Why haskell, because its fun?
09:48:55 * hackagebot th-lift-instances 0.1.6 - Lift instances for template-haskell for common data types.  https://hackage.haskell.org/package/th-lift-instances-0.1.6 (BennoFuenfstueck)
09:53:56 * hackagebot quickcheck-property-monad 0.2.4 - A monad for generating QuickCheck properties without Arbitrary instances.  https://hackage.haskell.org/package/quickcheck-property-monad-0.2.4 (BennoFuenfstueck)
09:54:49 <bollu> (a,s) -> (b,s) is isomorphic to a -> s -> (b, s) which is a -> State s b | that is so cool
09:55:19 <Denommus> how do I ignore whitespace characters in parsec/megaparsec?
09:55:31 <Denommus> I usually do that in the lexer level
09:55:51 <Ralith_> you could write a lexer by hand, then feed its output to parsec
09:55:55 <chpatrick> Denommus: Parsec.Token?
09:56:08 <Hafydd> (Shouldn't the opposite of attoparsec be called "exaparsec"?)
09:56:48 <Denommus> I'm actually using megaparsec, not the classic parsec
09:57:10 <indiagreen> Denommus: http://lpaste.net/141873
09:57:11 <Denommus> ah, there's a Text.Megaparsec.Lexer
09:58:22 <indiagreen> Denommus: another example: http://lpaste.net/141874
09:58:22 <Denommus> indiagreen: thank you
10:07:41 <kaol> My haskell is rusty. How do I conditionally perform something in IO if a value of type Maybe a is Just? Using when and isJust works but I feel that I'm missing something.
10:08:12 <indiagreen> kaol: people have been asking about that for quite some time
10:08:18 <indiagreen> kaol: one option: use “traverse_”
10:08:25 <indiagreen> (or “for_”)
10:08:26 <Fuuzetsu> nothing wrong with isJust and when or good old pattern match
10:08:35 <indiagreen> another option is using “case”, yeah
10:08:50 <shachaf> Certainly something is wrong with isJust.
10:08:57 <chpatrick> any idea if Kotlin has newtype?
10:09:01 <Fuuzetsu> oh, shachaf is certainly right
10:09:23 <dmj`> kaol: forM_ 
10:09:24 <chpatrick> kaol: I would case it
10:09:27 <Fuuzetsu> use ‘maybe’ instead &c
10:09:30 <dmj`> @typ Data.Foldable.forM_
10:09:31 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
10:09:46 <Fuuzetsu> I don't actually remember the last time I used isJust
10:09:46 <chpatrick> actually forM_ is better
10:09:46 <dmj`> :t forM_ (Just "foo") print
10:09:47 <lambdabot> IO ()
10:10:04 <Welkin> forM_ feels quite imperative
10:10:07 <shachaf> for_ is probably best.
10:10:14 <Welkin> anywhere you use forM_ for can use mapM_
10:10:17 <Welkin> I prefer the latter
10:10:26 <indiagreen> Welkin: so-o it's imperative only because the order is flipped?
10:10:29 <dmj`> :t for
10:10:31 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
10:10:35 <dmj`> :t for_
10:10:36 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
10:10:44 <Welkin> indiagreen: well, it models an imperative for-loop
10:10:46 <dmj`> @typ for_ (Just 3) print
10:10:48 <lambdabot> IO ()
10:10:50 <chpatrick> so does mapM
10:10:58 <chpatrick> I prefer for because usually the processing function is usually longer than the Foldable
10:11:03 <Welkin> I mean syntactically
10:11:12 <chpatrick> and with for you can use $ and don't have to bracke
10:11:13 <chpatrick> t
10:11:14 <Welkin> of course, I just said mapM_ is the same as forM_
10:11:15 <dmj`> is for in base?
10:11:26 <geekosaur> @index for
10:11:26 <lambdabot> Data.Traversable
10:12:40 <dmj`> geekosaur: didn't know about @index, nice
10:13:27 <bennofs> dmj`: it's actually just a hardcoded database though afaik, so not always useful :(
10:13:30 <bennofs> @index view
10:13:30 <lambdabot> bzzt
10:13:50 <Jinxit> good error message
10:22:32 <nullx002> hai
10:23:39 <Marino2730> ciao
10:23:48 <Marino2730> !lista
10:23:48 <monochrom> Marino2730: http://lpaste.net/browse
10:23:52 <NemesisD> i'm using a cabal build-type of Custom. my Setup.hs needs to include some haskell modules in my src/ dir. how do i get -isrc/ into the cabal custom build type?
10:27:15 <NemesisD> looks like i'm not the first one http://stackoverflow.com/questions/28414549/cabal-custom-build-include-dir
10:27:42 <bennofs> NemesisD: there is no way to pass flags for the compilation of Setup.hs in cabal
10:28:11 <NemesisD> well, thats a bummer :(
10:28:15 <nitrix> Am I right thinking weak-head normal form makes the implementation of a foldr' impossible?
10:28:32 <NemesisD> i guess i have to symlink the files i need into the project root, which is pretty silly
10:42:26 <henk> hi, I defined and redefined a function in ghci. How can I print the current definition?
10:43:37 <dmj`> henk: you can only display its type
10:43:58 * hackagebot plot-gtk-ui 0.2.0.0 - A quick way to use Mathematica like Manipulation abilities  https://hackage.haskell.org/package/plot-gtk-ui-0.2.0.0 (sumitsahrawat)
10:44:03 <henk> dmj`: ok, thank you
10:44:05 <dmj`> henk: Ctrl + p should let you see your previous commands though
10:44:49 <henk> dmj`: ack, cursor up also works for that, thank you (:
10:45:37 <bollu> dmj': I remember someone showing me how to get Show instances for functions?
10:45:41 <bollu> It's apparently a huge hack
10:46:02 <dmj`> henk: ah, cool
10:47:29 <dmj`> bollu: ah, well, you can always do, instance Show (a -> b) where show _ = "<function>" or some non sense like that
10:47:47 <dmj`> @def instance Show (a -> b) where show _ = "<function>"
10:47:48 <lambdabot>  .L.hs:158:10:
10:47:48 <lambdabot>      Duplicate instance declarations:
10:47:48 <lambdabot>        instance [safe] Show (a -> b) -- Defined at .L.hs:158:10
10:47:51 <dmj`> > show id
10:47:52 <lambdabot>      No instance for (Typeable a0) arising from a use of ‘show’
10:47:52 <lambdabot>      In the expression: show id
10:56:33 <dmj`> anyone use inline-c on osx?
11:00:55 <tommd> dmj`: I saw your question the other day and could reproduce your problem.  That is all.
11:01:48 <dmj`> tommd: ah ok ! cool, wasn't sure if it was something obvious I missing
11:03:07 <nolraiU> Hmm. So if I wanted to write something like the web UI of "theIncredibleProofMachine" in a haskell like language would Elm be a reasonable choice?
11:03:40 <paldepind> nolraiU, you could also look at GHCJS and Reflex.
11:03:47 <paldepind> Or PureScript.
11:04:05 <nolraiU> Thanks!
11:06:57 <srhb> nolraiU: I feel Elm is actually one of the least Haskelly approaches, considering its strict-by-default nature
11:11:02 <nullx002> what is the library to interact with OS
11:11:35 <ReinH> nullx002: "with OS"?
11:11:45 <nullx002> link import OS
11:11:51 <ReinH> What?
11:11:52 <nullx002> like
11:12:04 <ReinH> What are you trying to do?
11:12:05 <nullx002> interacting with linux or bsd processes
11:12:22 <dmj`> System.Process in base, or shelly... 
11:12:30 <nullx002> write code to shutdown machine if wrong a condition is nnot met 
11:12:36 <dmj`> @package process
11:12:36 <lambdabot> http://hackage.haskell.org/package/process
11:12:41 <dmj`> not in base...
11:12:53 <dmj`> @package shelly
11:12:53 <nullx002> do that import all processes?
11:12:53 <lambdabot> http://hackage.haskell.org/package/shelly
11:13:03 <ReinH> What does "import all processes" mean?
11:13:10 <nullx002> do i need root privilage to access ?
11:13:15 <nullx002> or that depends upon host machine?
11:13:27 <ReinH> To access what?
11:13:30 <nullx002> i mean all process types
11:13:34 <nullx002> and levels
11:13:39 <nullx002> init 0 to init 5
11:13:44 <ReinH> What?
11:13:53 <ReinH> What would it mean to "import" process types and levels?
11:13:58 <ReinH> What are process types?
11:14:00 <nullx002> say a process is already running in root
11:14:00 * hackagebot ghc-exactprint 0.4.1.0 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.4.1.0 (mpickering)
11:14:39 <nullx002> say i want to call a small sh script using process library
11:14:42 <nullx002> is it possible
11:14:49 <nolraiU> If I want to contribute to GHC is it worth learning Docker?
11:14:52 <nullx002> that sh script ultimately interacts with machine
11:15:02 <ReinH> Sure, you can run a shell script.
11:15:11 <srhb> nullx002: The haskell program launching some shell script will need whatever privileges that shell script would need. 
11:15:24 <srhb> nullx002: This is all OS stuff. Nothing fancy.
11:15:40 <nullx002> i pack a haskell binary code that calls sh now do i need to have root rights to execute it or it depends upon host machine?
11:15:56 <srhb> nullx002: If you need root privileges to run the shell script, then so does your haskell program.
11:15:57 <ReinH> You need whatever privileges the shell script needs.
11:16:15 <nullx002> is there a way to circumwent this?
11:16:21 <ReinH> Of course not
11:16:29 <srhb> Short of finding a bug in the OS and exploiting it, no.
11:16:39 <srhb> That's the point of privilege systems.
11:16:58 <nullx002> so process library works with linux or with other OSes too ?
11:17:37 <ReinH> It appears to work on windows as well, although I have not tried it
11:18:26 <nullx002> so how user priileges works on windows
11:18:33 <ReinH> No idea.
11:18:40 <geekosaur> I... wow. trying to write sysadmin stuff without even knowing what it is?
11:19:00 * hackagebot calculator 0.4.0.0 - A calculator repl, with variables, functions & Mathematica like dynamic plots.  https://hackage.haskell.org/package/calculator-0.4.0.0 (sumitsahrawat)
11:19:04 <dmj`> nullx002: It works on windows
11:19:20 <nullx002> strange
11:20:10 <nullx002> dmj`: how does that wokr?
11:20:19 <dmj`> @package Win32
11:20:19 <lambdabot> http://hackage.haskell.org/package/Win32
11:20:25 <ReinH> It uses the Win32 API
11:20:52 <geekosaur> the process package provides the subset of process creation and management APIs that is valid on both Windows and POSIX
11:21:16 <ReinH> For posix-specific things like signals, there is the unix library
11:21:34 <nullx002> so i hvae to write 2 seperate code for both os?
11:21:53 <ReinH> It depends on what you're doing.
11:21:57 <nullx002> or can include both libraries in same code
11:21:57 <monochrom> nullx002, I don't think anyone understands your program specification
11:22:01 <dmj`> nullx002: you can emulate POSIX compliance w/ cygwin 
11:22:01 <ReinH> But at some level, probably
11:22:37 <nullx002> ok
11:22:38 <nullx002> got it
11:22:42 <nullx002> thanks
11:23:19 <dmj`> nullx002: what are you trying to do? Just curious
11:23:28 <geekosaur> you could have different dependencies on different systems. you can't simply use both because the unix library isn't on windows and the win32 library isn't on POSIXish systems, and they don't even use the same executable and library formats
11:23:52 <nullx002> yes got it
11:24:09 <nullx002> and one mroe thing
11:24:17 <nullx002> how to generate list of complex numbers?
11:24:31 <nullx002> 1:+1, 2:+1, ..
11:24:32 <bollu> nullx002: like, all complex numbers?
11:24:34 <geekosaur> (cygwin can emulate windows up to a point. the stuff you are talking about doing is beyond that point)
11:24:39 <nullx002> no can use take 10
11:24:48 <athan> nullx002: If you can enumerate them, then you can for free
11:24:56 <athan> that is, if they're an instance of `Enum`
11:25:07 <dmj`> geekosaur: you mean emulate linux?
11:25:21 <geekosaur> yes, sorry
11:25:21 <bollu> athan: you can't enumerate, C ~ R x R, R is uncountabe
11:25:23 <bollu> uncountable*
11:25:41 <athan> bollu: :)
11:26:02 <athan> how about this, enumberate `Int`, then append complex data?
11:26:10 <athan> enumerateify*
11:26:27 <nullx002> i have tried few things
11:26:29 <nullx002> nothign worked
11:26:34 <nullx002> 1:+1, 2:+1, .. 
11:26:37 <nullx002> not working
11:26:45 <nullx002> say upto 10 values
11:27:07 <lpaste> gganley pasted “Sat solver” at http://lpaste.net/141876
11:27:37 <srhb> nullx002: You just want the imaginary part to be the same for each number? And increase the real part by one?
11:27:42 <gganley> I'm trying to write a rewrite rule in Control.Lens.Plated where i Have a ADT "data Sat = Or Sat Sat | And Sat Sat | Not Sat | Var String | Val String". funciton f takes the list of replacements that is a tuple of a var and the bool that will replace it and return ing th expression with the replaced terms. f :: [(Sat, Bool)] -> Sat -> Sat. but when i write the function that i just pasted it just doesnt work right. al
11:27:42 <gganley> l my repo is up at https://github.com/gganley/dpll
11:27:45 <dmj`> > zipWith mkPolar [(1::Double)] [(1::Double)]
11:27:46 <lambdabot>  [0.5403023058681398 :+ 0.8414709848078965]
11:28:20 <srhb> > zipWith (:+) [1..] (repeat 1)
11:28:22 <lambdabot>  [1 :+ 1,2 :+ 1,3 :+ 1,4 :+ 1,5 :+ 1,6 :+ 1,7 :+ 1,8 :+ 1,9 :+ 1,10 :+ 1,11 :...
11:28:27 <nullx002> yes srhb
11:28:43 <indiagreen> > map (:+ 1) [1..]
11:28:44 <lambdabot>  [1 :+ 1,2 :+ 1,3 :+ 1,4 :+ 1,5 :+ 1,6 :+ 1,7 :+ 1,8 :+ 1,9 :+ 1,10 :+ 1,11 :...
11:28:51 <srhb> indiagreen: Ah yes, of course.
11:29:05 <mniip> > [(1:+1),(1:+2)..]
11:29:06 <lambdabot>      No instance for (Show a0)
11:29:07 <lambdabot>        arising from a use of ‘show_M11314167549230002114016’
11:29:07 <lambdabot>      The type variable ‘a0’ is ambiguous
11:29:08 <gganley> I know I've been posting here for a while but my function that uses the `transform` function it just doesnt work right
11:29:13 <mniip> aw
11:29:21 <mniip> no instance, is there
11:29:31 <bollu> >  zipWith (:+) ((,) <$> [1..10] <*> [1..10])
11:29:33 <lambdabot>  <[(Integer,Integer)] -> [Complex (Integer,Integer)]>
11:29:37 <bollu> what?
11:29:38 <gganley> I think my knowlage of the Plated library is the issue here
11:29:42 <bollu> that should not have happened
11:29:50 <bollu> :t zipWith
11:29:51 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:29:53 <nullx002> it si not workign indiagreen
11:29:58 <bollu> oh
11:29:59 <nullx002> though zipWith is working 
11:30:02 <bollu> :t curry
11:30:04 <lambdabot> ((a, b) -> c) -> a -> b -> c
11:30:09 <indiagreen> then srhb wins
11:30:13 <indiagreen> somehow
11:30:20 <bollu> map (uncurry (:+)) ((,) <$> [1..10] <*> [1..10])
11:30:21 <srhb> I don't understand it either. :-)
11:30:25 <bollu> > map (uncurry (:+)) ((,) <$> [1..10] <*> [1..10])
11:30:28 <lambdabot>  [1 :+ 1,1 :+ 2,1 :+ 3,1 :+ 4,1 :+ 5,1 :+ 6,1 :+ 7,1 :+ 8,1 :+ 9,1 :+ 10,2 :+...
11:30:30 <bollu> yess!
11:30:33 <athan> > zipWith (:+) [1..10] [1..10]
11:30:36 <lambdabot>  [1 :+ 1,2 :+ 2,3 :+ 3,4 :+ 4,5 :+ 5,6 :+ 6,7 :+ 7,8 :+ 8,9 :+ 9,10 :+ 10]
11:30:39 <athan> :P
11:30:45 <bollu> athan: nope, you won't get all combinations :P
11:30:49 <athan> oop
11:30:52 <athan> my bad :|
11:30:52 <bollu> athan: I use the list monad to get all combinations :D
11:30:56 <arkeet> > liftA2 (:+) [1..3] [1..3]
11:30:58 <lambdabot>  [1 :+ 1,1 :+ 2,1 :+ 3,2 :+ 1,2 :+ 2,2 :+ 3,3 :+ 1,3 :+ 2,3 :+ 3]
11:31:02 <bollu> holy shit I'm so happy that I can write stupid code like that
11:31:05 <athan> atta haskeller :)
11:31:09 <bollu> arkeet: heat
11:31:10 <bollu> neat*
11:31:41 <bollu> oh, right
11:31:57 <bollu> > (:+) <$> [1..10] <*> [1..10]
11:31:58 <lambdabot>  [1 :+ 1,1 :+ 2,1 :+ 3,1 :+ 4,1 :+ 5,1 :+ 6,1 :+ 7,1 :+ 8,1 :+ 9,1 :+ 10,2 :+...
11:32:06 <bollu> I can't believe I reached for uncurry first >_<
11:32:40 <nullx002> so can increment both parts on left and right that way..
11:32:41 <nullx002> thanks
11:33:17 <athan> bollu: I feel your pain ._. I always think of application and zipping as separate constructs for building more constructs.
11:33:18 <bollu> nullx002: um, I'd recommend understanding how it works
11:34:00 <bollu> I can't wait to be the haskeller who shows someone else (.) . (.) or (fmap . fmap)
11:34:09 <athan> bollu: Check this out
11:34:13 <athan> @hackage composition-extra
11:34:13 <lambdabot> http://hackage.haskell.org/package/composition-extra
11:34:35 <bollu> xD
11:34:52 <bollu> (<->) is actually neat
11:35:16 <athan> bollu: I use `<$~>` and `**.` fairly often
11:35:16 <dmj`> :t fmap `fmap` fmap
11:35:18 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:35:30 <lemevi_> do I really have to write out the function names multiple times 
11:35:40 <nullx002> me new to haskell
11:35:52 <nullx002> so still learning from simple tuts and books
11:36:02 <nullx002> still community support is good here
11:36:03 <nullx002> thanks all
11:36:04 <indiagreen> bollu: a data point: I understand “fmap.fmap” but I can't easily wrap my head around “(.).(.)”
11:36:05 <dmj`> lemevi_: hm ?
11:36:08 <bollu> :t f `f` f where f = fmap
11:36:10 <lambdabot> parse error on input ‘where’
11:36:14 <indiagreen> bollu: I wonder whether I'm alone in this
11:36:14 <athan> lemevi_: Well, you can only have one definition, but type signatures help to restrain type conflicts
11:36:30 <lemevi_> dmj`: each line during pattern matching requires the function name again yeah?
11:36:39 <athan> bollu: You saw `<$$$>` and friends, right?
11:36:49 <lemevi_> I'd prefer braces or python whitespace or something to this
11:37:13 <bollu> yep, I did :P
11:37:16 <dmj`> lemevi_: that's one way to do it, you could also foo x = case x of { 1 -> ..; 2 -> ... }
11:37:23 <bollu> :t (.) . (.)
11:37:24 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:37:25 <dmj`> lemevi_: but yea foo 1 = ...; foo 2 = ... ;
11:37:30 <lemevi_> I see
11:37:46 <lemevi_> what's a good editor for haskell, I've been using vim
11:37:53 * lemevi_ checks for an intellij plugin
11:37:56 <dmj`> lemevi_: vim is good, I use emacs
11:38:21 <dmj`> lemevi_: you could rename the function if it has a longish name, foobarbaz = go where go 1 = ... go 2 ... 
11:38:39 <lemevi_> oh interesting
11:38:53 <bollu> dmj`: I like sublime text as well
11:39:04 <dmj`> bollu: yes sublime is cool, I've heard good things about atom
11:39:17 <lemevi_> oh intellij has a haskell plugin
11:39:20 <lemevi_> I wonder if it's any good
11:39:33 <bollu> indiagreen: if you understand fmap . fmap, then just recite (function = ((->) a)) in your head while thinking about fmap . fmap :P
11:39:38 <bollu> functor**
11:40:10 <indiagreen> no, I mean, I know what fmap.fmap does to functions
11:40:40 <arkeet> :t fmap.fmap
11:40:41 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:40:50 <arkeet> it does the only thing something of this type could do.
11:40:57 <indiagreen> but I don't know what (.).(.) does to functions
11:41:03 <arkeet> :t (.).(.)
11:41:04 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:41:08 <arkeet> it does the only thing something of this type could do.
11:41:15 * indiagreen rolls eyes a bit
11:41:29 <indiagreen> s/know/remember/
11:41:37 <arkeet> @djinn (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:41:37 <lambdabot> f a b c d = a (b c d)
11:41:38 <indiagreen> and with fmap I don't even have to remember
11:41:49 <arkeet> you can remember that (.) = fmap
11:42:41 <athan> bollu: Now I need to make the same stuff for Kleisli composition ._.
11:42:44 <indiagreen> this is certainly what I'll end up doing if people keep using (.).(.)
11:42:58 <bollu> athan: plz, make it acme
11:43:28 <arkeet> :t (=<<).(=<<)
11:43:29 <lambdabot> Monad m => (a -> m b) -> m (m a) -> m b
11:43:44 <dmj`> :t (.) :: (b -> c) -> (a -> b) -> a -> c ... (.).(.) :: (c -> d) -> ( a -> b -> c ) -> a -> b -> d
11:43:45 <lambdabot> parse error on input ‘.’
11:43:46 <arkeet> :t (<=<).(<=<)
11:43:47 <lambdabot> Monad m => (b -> m c) -> (a -> a1 -> a1 -> m b) -> a -> a1 -> m c
11:43:51 <arkeet> heh.
11:43:59 <arkeet> :t (=<<).(<=<)
11:44:00 <lambdabot> Monad m => (b -> m c) -> (a -> a -> m b) -> a -> m c
11:44:05 <arkeet> :t (<=<).(=<<)
11:44:06 <lambdabot> Monad m => (a1 -> m c) -> (a -> m (m a1)) -> a -> m c
11:44:15 <athan> bollu: I use them in production :)
11:44:15 <bollu> arkeet: no, plz
11:44:20 <arkeet> I'm done.
11:44:20 <arkeet> bye
11:44:21 <athan> arkeet: !!!!!!
11:44:22 <bollu> athan: really? o_O
11:45:04 <athan> bollu: Well, which looks better: `($ x) <$> mx` or `mx <$~> x`
11:45:10 <athan> it's for maintainability
11:45:32 <dmj`> athan: <$$> ? 
11:45:35 <arkeet> I know what the first one does.
11:45:38 <arkeet> but not the second.
11:45:56 <arkeet> lens calls it (??)
11:45:57 <athan> dmj`: double depth
11:46:13 <athan> arkeet: They're the same
11:46:25 <arkeet> perhaps, but I've never seen <$~>
11:46:31 <athan> arkeet: I made it :\
11:46:33 <arkeet> which is my point.
11:46:44 <monochrom> "mx <$~> x" looks better, but I don't want to memorize <$~>
11:46:47 <athan> communication of language through language use ftw
11:46:58 <athan> :L
11:47:07 <monochrom> I need to tell you a true story.
11:47:19 <jle`> maintainability is also about being able to read your code after a few months, or other people being able to read your code without being confused :)
11:47:20 <bollu> monochrom: is this about Lens and the bazillion combinators?
11:48:00 <bollu> I should take the time to actually learn lens
11:48:06 <ReinH> athan: I think fmap ($ x) looks better
11:48:13 <athan> :\
11:48:20 <jle`> bollu: no need to learn it all at once, just pick it up as you need it :)
11:48:28 <hexagoxel> mx <*> pure x (need Applicative..)
11:48:41 <monochrom> a friend of mine was sent to a small office to install new software on their PCs. the people in the small office then asked him, "is this new software compatible with 1048?"
11:49:00 <monochrom> do you want to guess what "1048" means?
11:49:13 <Fuuzetsu> is this the one about monitor sizes
11:49:15 <Bez_> there was a lecture about lens in our local curry-club a few weeks ago :)
11:49:18 <monochrom> yes
11:49:47 <Fuuzetsu> I'm amazed I remembered that
11:49:53 <monochrom> :)
11:50:28 <nullx002> i have a simple code to generate first N primes and print them here: http://lpaste.net/141879
11:50:29 <athan> monochrom: But composition-extra doesn't force people to use it :\
11:50:42 <nullx002> how do i combine last 2 print lines?
11:50:45 <nullx002> in 1
11:51:05 <arkeet> just ++ them together?
11:51:08 <nullx002> ++ show is not working twice inside one line
11:51:23 <jle`> hm, you can do mapM_ putStrLn [string1, string2]
11:51:23 <arkeet> putStrLn ("list of first " ++ show x ++ " prime numbers are: " ++ show p1)
11:51:43 <nullx002> compiler throws error at that
11:51:45 <nullx002>  The function `show' is applied to two arguments,
11:51:46 <nullx002>     but its type `Int -> String' has only one
11:51:46 <nullx002>  
11:51:46 <arkeet> it shouldn't.
11:51:54 <jle`> hm, paste your code?
11:51:54 <arkeet> you probably did something else.
11:52:05 <nolraiU> Yeah, sounds like a typo to me.
11:52:06 <nullx002> no code is same as it is
11:52:14 <arkeet> try it again.
11:52:18 <jle`> paste the code?
11:52:19 <nullx002> and i used arkeet line before
11:52:19 <arkeet> or paste your code
11:52:32 <arkeet> because I definitely didn't apply show to 2 arguments.
11:52:45 <monochrom> nullx002: you should put your code verbatim on lpaste.net
11:52:53 <jle`> maybe you forgot a (++)
11:53:00 <monochrom> ah, you did it already
11:53:00 <jle`> but without code, it's hard to tell :)
11:54:09 <nullx002> monochrom what does that mean?
11:54:26 <monochrom> it means I misread
11:55:08 <nullx002> i just copy pasted it
11:55:28 <nullx002> so it is verbatim i think
11:55:29 <jle`> paste the version that's giving the error
11:55:47 <bollu> null x002 along with the error message here, please?
11:55:54 <nullx002> ok got the error
11:55:57 <nullx002> corrected
11:56:14 <bollu> :t traverse
11:56:15 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:56:30 <jle`> nullx002: congrats :)
11:56:45 <bollu> > traverse (\a -> Right (a + 1)) [1..10]
11:56:46 <lambdabot>  Right [2,3,4,5,6,7,8,9,10,11]
11:56:49 <nullx002> :D
11:56:55 <nullx002> stupid mistakes :D
11:58:09 <bollu> :t foldMap
11:58:10 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
11:58:45 <bollu> > foldMap (\x -> length x)  Right "b"
11:58:46 <lambdabot>      Couldn't match expected type ‘[Char] -> t’ with actual type ‘Int’
11:58:46 <lambdabot>      Possible cause: ‘length’ is applied to too many arguments
11:58:46 <lambdabot>      In the expression: length x
11:59:04 <bollu> isn't Maybe foldable?
11:59:14 <jle`> where is Maybe involved here?
11:59:19 <bollu> > foldMap (\x -> length x)  ["b"]
11:59:20 <lambdabot>      No instance for (Monoid Int) arising from a use of ‘foldMap’
11:59:21 <lambdabot>      In the expression: foldMap (\ x -> length x) ["b"]
11:59:23 <bollu> jle`: er, Either
11:59:32 <bollu> Int as no monoid? o_O
11:59:35 <bollu> has*
11:59:39 <jle`> yeah, it's ambiguous as to what it should be
11:59:49 <bollu> foldMap id "bad"
11:59:55 <bollu> > foldMap id "bad"
11:59:57 <lambdabot>      No instance for (Monoid Char) arising from a use of ‘foldMap’
11:59:57 <lambdabot>      In the expression: foldMap id "bad"
12:00:09 <bollu> > foldMap id ["bad", "lambdabot"]
12:00:11 <lambdabot>  "badlambdabot"
12:00:38 <bollu> > foldMap id (Some 5)
12:00:40 <lambdabot>      Not in scope: data constructor ‘Some’
12:00:40 <lambdabot>      Perhaps you meant variable ‘some’ (imported from Control.Applicative)
12:00:54 <monochrom> Some? Just?
12:00:56 <bollu> what has foldable? [] and..?
12:01:15 <bollu> monochrom: right., Just. Rust calls it Some(x) | None
12:01:44 <bollu> I was hoping there would be foldable for Monoid a => Foldable(Maybe a)
12:01:58 <dmj`> bollu: [], Maybe, Either a ((,) a), Const m
12:02:13 <bollu> > foldMap id (Just 5)
12:02:14 <lambdabot>      No instance for (Show a0)
12:02:14 <lambdabot>        arising from a use of ‘show_M58850811214192767084704’
12:02:14 <lambdabot>      The type variable ‘a0’ is ambiguous
12:02:25 <monochrom> "Foldable (Maybe a)" is a kind error.
12:02:27 <bollu> > foldMap id (Just 5) :: Int
12:02:28 <lambdabot>      No instance for (Monoid Int) arising from a use of ‘foldMap’
12:02:29 <lambdabot>      In the expression: foldMap id (Just 5) :: Int
12:02:43 <bollu> > foldMap id (Just "a") :: String
12:02:45 <lambdabot>  "a"
12:02:52 <bollu> > foldMap id None :: String
12:02:53 <lambdabot>      Not in scope: data constructor ‘None’
12:02:54 <lambdabot>      Perhaps you meant one of these:
12:02:54 <lambdabot>        ‘Node’ (imported from Data.Tree),
12:02:59 <bollu> nothing
12:03:00 <bollu> damnit
12:03:01 <monochrom> you should use pm
12:03:06 <bollu> monochrom: oh?
12:03:13 <bollu> whoa, you can pm lambdabot
12:03:15 <bollu> that is cool!
12:03:23 <bollu> sorry for spamming the channel
12:04:02 * hackagebot Dist 0.4.0.0 - A Haskell library for probability distributions  https://hackage.haskell.org/package/Dist-0.4.0.0 (wyager)
12:04:22 <mitochon_> is there a common idiom for doing arr[i]++ (incrementing elements of an integer array)
12:06:08 <monochrom> no
12:06:30 <Cale> mitochon: What type of array?
12:06:48 <mniip> :t at 5 += 1
12:06:50 <lambdabot> (Num (Index s), Num (Maybe (IxValue s)), At s, MonadState s m) => m ()
12:07:04 <Cale> Yeah, lens has some "fun" operators like that
12:07:13 <quchen> mitochon: Data.Vector.Mutable.modify (+1)
12:07:28 <quchen> Plus some parameters
12:07:37 <Cale> and yeah, depending on array type, there are various higher order functions and such you might use
12:08:11 <mniip> err sorry, ix not at
12:08:13 <mniip> :t ix 5 += 1
12:08:15 <lambdabot> (Num (IxValue s), Num (Index s), Ixed s, MonadState s m) => m ()
12:08:24 <mniip> :t ix 5 += 1 :: State [Int] ()
12:08:25 <lambdabot> State [Int] ()
12:09:15 <Cale> If you meant to say "list" rather than "array", then this isn't an operation you typically want to be performing on a list, so there isn't a common way to do it as far as I know, apart from using splitAt
12:10:06 <bollu> mitochon: motivation?
12:10:12 <bollu> mitochon: for wanting to (+1) ?
12:11:15 <mitochon> bollu: trying to keep counter based on array location
12:11:18 <bollu> Cale: how long will Lens take to learn?
12:11:32 <Cale> bollu: Depends on how much of it you care to learn
12:11:45 <bollu> Cale: enough to be productive?
12:11:48 <Cale> bollu: There are lots of things in lens that I'm still unfamiliar with
12:11:53 <mniip> bollu, decades
12:11:59 <Cale> not decades :P
12:12:12 <bollu> mniip:  ._.
12:12:17 <bollu> Cale: years, then? :P
12:12:19 <Cale> It didn't take decades to write in the first place
12:12:29 <bollu> Cale: cause ekemett
12:12:31 <Cale> You should be able to get started in a few hours
12:12:42 <bollu> Cale: really?
12:12:47 <bollu> Cale: can I haz coursE?
12:13:17 <mniip> well, in a few hours you could figure out that 'view', 'review', and 'get' are magical, and so is (.)
12:13:35 <mniip> but to understand how (a -> f b) -> s -> f t works you'll need much more time
12:14:23 <bollu> mniip: :(
12:14:34 <bollu> mniip: what's the restriction on f, first of all?
12:14:50 <monochrom> f is a Functor instance
12:15:21 <mniip> Functor for lens
12:15:26 <mniip> Applicative for traversal
12:15:39 <mniip> no wai
12:15:46 <mniip> applicative for fold?
12:16:01 <mniip> yeah, traversal
12:16:14 <mniip> fold is also gettable and always simple
12:16:30 <bennofs> mniip: Applicative for traversal. "Contravariant f, Functor f" is Getter, "Contravariant, Applicative f" is Fold
12:17:14 <Cale> Well, how well do you understand functors?
12:17:30 <frerich> bollu: It really only takes an afternoon or so of playing with one of the lens packages to be able to get something useful out of them. http://stackoverflow.com/a/5769285/91757 has a brief overview - I'd recommend starting with the 'fclabels' package, I thought it was really easy to 'grok'.
12:17:52 <Cale> If you understand Functor, then understanding the Identity and Const a functors should not be hard
12:18:11 <mniip> from what I can see, Gettable = Co+Contravariant
12:18:15 <bollu> Cale: identity functor is pointless. Const a functor is.. what, useless?
12:18:21 <Cale> and then plugging those into the definition of the Lens type and simplifying, you'll see how set and view fall out
12:18:34 <Cale> bollu: They are not pointless or useless :D
12:18:43 <Cale> bollu: Simple things are often the most useful
12:18:48 <mniip> they contribute to the abstraction
12:19:06 <bollu> Cale: hm, so you're saying, when confused by a Functor, throw Identity at it?
12:19:06 <mniip> just like monad transformers would be useless without Identity
12:19:12 <bollu> mniip: heh, fair
12:19:52 <mniip> bollu, well consider you have forall f. (a -> f b) -> s -> f t
12:20:05 <mniip> you as the user of the value get to choose the f, and you choose f ~ Identity
12:20:16 <mniip> (a -> Identity b) -> s -> Identity t
12:20:19 <mniip> boom, you have '
12:20:20 <mniip> over'
12:20:28 <nolraiU> bollu: No when confused by something using a functor, Const a, and Idenity are useful to throw at it.
12:20:48 <nolraiU> They are like the 1 and 0 of Functors.
12:21:01 <Cale> Actually, to start with, you should choose b = a and t = s
12:21:14 <mniip> nolraiU, I thought Mu and Either are 0 and 1 of Functors?
12:21:21 <lemevi_> how do I iterate over a list and get both the value and index at each iteration?
12:21:26 <Cale> It's easier to understand if you consider lenses where the types of things are not changing when you replace a field
12:21:27 <bollu> ahh
12:21:33 <Cale> So okay
12:21:38 <bollu> Cale: what are a, b, t s?
12:21:40 <mniip> lemevi_, for one, you can zip your list with [0..]
12:21:45 <mniip> s t a b
12:22:10 <lemevi_> mniip: oh right thanks
12:22:16 <Cale> Okay, so a lens in this style is a way of converting a (functorial) transformation on part of the structure into a transformation on the whole structure.
12:22:39 <bollu> oh, so it lifts smallTransform -> bigTransform?
12:22:42 <Cale> yeah
12:22:52 <mniip> bollu, 'Simple Lens s a' is some 's' that contains one of 'a'
12:23:00 <mniip> for some value of "contains"
12:23:07 <bollu> mniip: s is the larger structure?
12:23:10 <mniip> yes
12:23:13 <Cale> So let's look at this
12:23:23 <Cale> (a -> f a) -> (s -> f s)
12:23:29 <bollu> mniip: so "s" is  functor?(In the sense of "functorful of stuff"?)
12:23:37 <Cale> If we plug in the Identity functor for f
12:23:44 <feryll> Why does list indexing (and brethren like take, drop...) have a type of [a] -> Int -> a instead of allowing all integral values? If you had a list with some 2^31 or more lazy values, how would you access them?
12:23:55 <Cale> we get (a -> Identity a) -> (s -> Identity s)
12:23:55 <mniip> bollu, Lens (Ratio Integer) Integer
12:24:00 <mniip> Simple*
12:24:02 <printline> can I define a list type of a certain length?
12:24:03 <jle`> feryll: mostly for efficiency reasons, i believe
12:24:05 <Cale> which is *pretty much* the same thing as
12:24:09 <Cale> (a -> a) -> (s -> s)
12:24:12 <bollu> Cale: right
12:24:34 <Cale> So it turns a transformation on the field into a transformation on the whole structure in the obvious way. By plugging in a constant function, we can set the field.
12:24:35 <bollu> which is what? a and s aren't related at all
12:24:47 <bollu> Cale: what? that's just id
12:24:48 <Cale> a is the type of the field, s is the type of the big structure it's in
12:24:48 <bollu> :t id
12:24:49 <lambdabot> a -> a
12:24:52 <mniip> feryll, genericIndex
12:24:55 <bollu> oh, no
12:24:58 <bollu> Cale: right, go on
12:24:59 <Cale> It doesn't need to be the identity function
12:25:00 <mniip> which is frowned upon
12:25:06 <Cale> There are lots of functions of type Integer -> Integer for example
12:25:11 <mniip> because having 2^31 cons cells is a hint of bad design
12:25:12 <Cale> when we go to use the thing
12:25:17 <jle`> feryll: if you care about values in your list past the 2^31th value, you probably have a lot bigger problems than the type of your indexor
12:25:26 <bollu> Cale: so, a and s have _no relation_ (at the typeclass level)
12:25:26 <bollu> ?
12:25:38 <mniip> typeclass?
12:25:42 <bollu> it's forall a. forall s. (a -> a) -> (s -> s) ?
12:25:46 <mniip> no
12:25:52 <Cale> Well, apart from the fact that a is going to be the type of some sort of field inside s
12:26:00 <bollu> Cale: right, okay.
12:26:05 <feryll> jle` How's that? I'm needing to work with a list of values in the hundreds of millions, which isn't otherwise presenting me any problems.
12:26:06 <printline> like a list with 20 floats, type MyList = [Float][20], something like that,  anyone?
12:26:18 <feryll> mniip Thanks, those are the functions I expected to exist somewhere.
12:26:19 <mniip> printline, lists are unsized in haskell
12:26:23 <Cale> bollu: Okay, so let's remind ourselves what the constant functor is
12:26:51 <Cale> newtype Const a b = Const { getConst :: a }
12:27:03 <mniip> printline, you could try something like a vector instead, but typesystem-level lengths are ugly to work with
12:27:06 <Cale> instance Functor (Const a) where
12:27:09 <bollu> Cale: it's something that doesn't use the fmap function, but just.. uses the value you pass to it and returns back that value
12:27:11 <Cale>   fmap f (Const x) = Const x
12:27:14 <bollu> right
12:27:57 <Cale> So we saw how to transform the field and set it, but now we'd like to be able to implement view, i.e. extract the field
12:28:12 <Cale> What happens if we put in Const a for f?
12:28:27 <Cale> Well, (a -> Const a a) -> (s -> Const a s)
12:28:37 <Cale> is pretty much like  (a -> a) -> (s -> a)
12:28:46 <monochrom> feryll: if you truly has a list of n items, all in memory (as opposed to a lazy list), then you are at least spending 24n bytes of memory. this only counts the list spine itself, not even actual content.
12:28:47 <bollu> right
12:28:54 <printline> mniip: so best pracatice would be to define a global magic number: myListTypeLength = 20?
12:28:55 <Cale> and we can plug in the identity function now to get a function s -> a
12:28:59 <bollu> ohh
12:29:08 <bollu> but how it know "where" to index s?
12:29:20 <bollu> if s :: [Int], a :: Int
12:29:20 <feryll> monochrom: I don't, though, it's lazy brute force.
12:29:21 <mniip> printline, what exactly are you trying to do?
12:29:25 <bollu> what will it choose to view?
12:29:30 <Cale> That's encoded by the particular value of type Functor f => (a -> f a) -> (s -> f s)  we started with
12:30:00 <mniip> bollu, there are multiple lenses from [Int] to Int
12:30:19 <bollu> mniip: oh, thats.. interesting
12:30:23 <mniip> (actually there are none, but imagine our lists are always the expected size)
12:30:37 <printline> mniip: I'm very new to hs., trying to write a simple MAP estimator, and I want to define a type for descrete PDFs
12:30:44 <bollu> Cale: um, okay, continue
12:30:59 <arkeet> it's the same way there are multiple functions [Int] -> Int
12:31:15 <mniip> printline, Portable Document Format?
12:31:26 <printline> mniip: probability density functions
12:31:30 <bollu> arkeet: for each index?
12:31:38 <arkeet> yeah
12:31:39 <mniip> bollu, a better example, there are 2 lenses from Rational to Integer
12:31:49 <arkeet> mniip: there are?
12:31:53 <bollu> mniip: ah, numerator and denom?
12:31:57 <mniip> :|
12:31:58 * arkeet believes those aren't lawful.
12:32:00 <delYsid`> I am looking for the source code of Text.Pandoc.Definition, but I can't find it in the github repo, is that auto-generated somehow?
12:32:01 <mniip> from Complex Integer to Integer
12:32:05 <arkeet> better
12:32:26 <mniip> bollu, that's what I had in mind, but they aren't exactly lawful thanks to reduction
12:33:01 <bollu> mniip: hm, right, cause you have _1 and _2, and Complex is isomorphic to (Real, Real)
12:33:18 <Cale> bollu: Okay, so now we can generalise a bit more I suppose
12:33:21 <printline> mniip: so?
12:33:21 <mniip> that's the idea
12:33:37 <bollu> printline: what's the type of a PDF?
12:33:44 <bollu> printline: like, what's its input and output?
12:33:44 <mniip> printline, uhhh, maybe try Array?
12:33:49 <bollu> Cale: alright
12:33:52 <printline> bollu: [Float]
12:34:08 <mniip> they don't have compile-time annotated lengths, but still have O(1) access
12:34:10 <Cale> bollu: So the idea with the fully general (Functor f) => (a -> f b) -> (s -> f t) is that we have a potentially-type-changing transformation on the field, which may change the type of the overall structure
12:34:43 <bollu> ah
12:34:55 <bollu> Cale: the functor is to denote the getting/setting action?
12:34:57 <mniip> bollu, basically we're saying that if 'a' in 's' would be changed to 'b', the 's' itself would turn into a 't'
12:35:05 <Cale> bollu: e.g. firstL :: (a -> f b) -> ((a,x) -> f (b,x))
12:35:25 <bollu> Cale: no idea what that does
12:35:31 <Cale> (er, obviously there should be a Functor f constraint there)
12:35:42 <Cale> This is the type of the lens from a pair to its first component
12:36:07 <bollu> ohh
12:36:09 <bollu> okay
12:36:27 <bollu> so you're changing a -> b, so the entire tuple will go from (a, x) to (b, x)
12:36:32 <bollu> with the f around it for the functor stuff
12:36:41 <lemevi_> otherwise = map show str  <--- why does that not work when in ghci map show str works fine
12:36:42 <johnw> the 'f' means it's not always a changing operation
12:36:44 <lemevi_> str is a string
12:36:51 <monochrom> if you set f=Identity, you get a setter for "1st"
12:36:53 <lemevi_> [Char]
12:37:13 <mniip> lemevi_, define "does not work"
12:37:13 <lemevi_> String -> String is the signature for this function
12:37:15 <bollu> johnw: right, and f=Const gives you viewing, right?
12:37:35 <lemevi_> mniip: Couldn't match type ‘[Char]’ with ‘Char’
12:37:39 <johnw> bollu: yes, very sharp
12:37:46 <bollu> johnw: "sharp" ?
12:37:53 <Cale> bollu: right
12:37:56 <johnw> that you saw that so quickly
12:37:56 <lemevi_> map takes a function and a list right and a string is a list of chars
12:37:58 <mniip> :t map show ?str
12:38:00 <lambdabot> (Show a, ?str::[a]) => [String]
12:38:05 <bollu> johnw: Cale had shown it  :)
12:38:05 <mniip> it returns a list of strings
12:38:38 <lemevi_> what does ? do in what you wrote
12:38:39 <bollu> Cale: okay, what next?
12:39:12 <mniip> lemevi_, it's a type parameter, a type checker debug feature
12:39:12 <monochrom> lemevi_: put complete verbatim code on lpaste.net. the problem is always where you don't look at.
12:39:23 <mniip> > map show "hello"
12:39:24 <lambdabot>  ["'h'","'e'","'l'","'l'","'o'"]
12:39:27 <mniip> see it's a list of strings
12:39:28 <lemevi_> ohhh
12:39:31 <lemevi_> thanks
12:39:42 <bollu> Cale: if I throw f = [], for example, that will give me.. (a -> [b]) -> (s -> [t]). So, if I change one a to a list of b's, then I'll get a list of modified structures? Neat
12:39:43 <Cale> bollu: Well, you now understand enough to get what set and view do, and what lenses are. For the most part, you can get by letting the TH stuff in Lens actually write the lenses for various types for you.
12:40:00 <Cale> yeah, and you can indeed use lenses at other types to do fun things like that
12:40:11 <lemevi_> hrm
12:40:19 <Cale> But for the most part, you don't even really choose the functor yourself
12:40:22 <mniip> f ~ Coyoneda
12:40:27 <mniip> @_@
12:40:29 <Cale> Another example where you might want to is IO
12:40:39 <Cale> (a -> IO b) -> s -> IO t
12:40:53 <Cale> IO-performing transformation on a field to IO-performing transformation on the whole structure
12:41:22 <bollu> Cale: I feel that the type should have been: Lens :: Functor f, Functor l => (a -> l b) -> (f s -> l(f t))
12:41:45 <bollu> Cale: to emphasize that we're modifying a "larger structure" on the RHS
12:41:47 <mniip> :t _Just readFile
12:41:48 <lambdabot> Maybe FilePath -> IO (Maybe String)
12:41:49 <mniip> wew
12:42:09 <arkeet> :t traverse_ readFile
12:42:11 <lambdabot> Foldable t => t FilePath -> IO ()
12:42:15 <arkeet> :t traverse readFile
12:42:16 <lambdabot> Traversable t => t FilePath -> IO (t String)
12:42:18 <bollu> Cale: the IO thing is super neat ^_^.
12:42:47 <bollu> Cale: are there "container types" that are not functors?
12:42:54 <arkeet> Set
12:43:09 <bollu> arkeet: hm, you can't have functor over Set?
12:43:19 <arkeet> nope
12:43:20 <bitemyapp> ooh this one agian.
12:43:22 <bollu> oh, because you can potentially change shape?
12:43:26 <Cale> Yeah, things like Set and such are not instances of Functor, even though they might conceptually be functors on subcategories of Hask.
12:43:27 <lemevi_> mniip: thanks, that was helpful, show returns a string, not a char I get it
12:43:27 <arkeet> because of that Ord constraint
12:43:29 <arkeet> :t S.map
12:43:30 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
12:43:47 <bollu> arkeet: oh :(
12:43:58 <monochrom> I have a better reason (i.e., more thorny reason) than Ord
12:44:04 * hackagebot network-transport-composed 0.2.0.0 - Compose network transports  https://hackage.haskell.org/package/network-transport-composed-0.2.0.0 (MathieuBoespflug)
12:44:05 <bollu> monochrom: do tell
12:44:06 * hackagebot network-transport-composed 0.2.0.1 - Compose network transports  https://hackage.haskell.org/package/network-transport-composed-0.2.0.1 (MathieuBoespflug)
12:44:39 <mniip> fmap f . fmap g = fmap (f . g) does not hold?
12:44:58 <bollu> you can destroy the shape of the set?
12:45:10 <monochrom> the following two are in contradiction: Set is a functor (even conceptually/theoretically/morally/whatever); "size of a set" is parametric-polymorphic
12:45:11 <bollu> fmap (const 1) mySet would flatten it
12:45:24 <bollu> yiss :)
12:45:53 <bollu> monochrom: 'cause functor can't change the "shape" ?
12:45:54 <johnw> fmap (const 1) . fmap f and fmap (const 1 . f) result in the same Set
12:46:10 <arkeet> why should mapping preserve the size of a set?
12:46:13 <bollu> johnw: right, but you destroyed the Set, right? that was my argument against it
12:46:24 <johnw> that's OK, as long as the law holds
12:46:36 <johnw> the Const functor is the great structure destroyer
12:46:37 <Denommus> hi
12:46:42 <bollu> arkeet: cause any "functor" is invertible and hence mapping preserves cardinality?
12:46:50 <arkeet> ???
12:46:57 <johnw> functors are not invertible
12:47:05 <bollu> johnw: oh, really? then ignore me
12:47:12 <mniip> how can functors be invertible if morphisms are not inverible
12:47:25 <johnw> if anything, you'd be thinking about natural isomorphisms
12:47:50 <mniip> hmm
12:47:51 <johnw> i.e., forall x. f x <-> g x
12:47:56 <bollu> mniip: hm, I assumed all category theoretic morohisms *had* to be invertible. I realize that's silly now cause you'd never need to call anything an "iso"morphism then
12:47:58 <bollu> yeah
12:48:04 <arkeet> monochrom: I'd be quite willing to not have the latter.
12:48:04 <johnw> (preserving functoriality)
12:48:04 <mniip> I can't think of a reason why Set wouldn't make a categorical functor
12:48:13 <arkeet> mniip: well it does.
12:48:17 <mniip> bollu, "abs" is a non-invertible morphism
12:48:25 <bollu> monochrom: reason?
12:48:29 <mniip> or even "const 1"
12:48:44 <arkeet> or "absurd"
12:48:49 <nolraiU> bollu: If they are all invertible, thats called a groupoid.
12:48:51 <bollu> :t absurd
12:48:52 <lambdabot> Not in scope: ‘absurd’
12:48:57 <arkeet> @let import Data.Void
12:48:57 <mniip> arkeet, well apart from the thing where you have to have a concept of equality
12:48:59 <lambdabot>  Defined.
12:48:59 <arkeet> :t absurd
12:49:00 <lambdabot> Void -> a
12:49:14 <mniip> be it structural equality or semantical
12:49:16 <bollu> nolraiU: difference between a group and a groupoid
12:49:17 <bollu> ?
12:49:29 <jle`> bollu: do you know what a group is?
12:49:32 <arkeet> same as the difference between a monoid and a category.
12:49:46 <bollu> jle': sure - identity, inverses, associativity
12:49:57 <mniip> oh I know why Set isn't a functor
12:50:02 <mniip> because Mu Set is malformed
12:50:17 <nolraiU> bollu: as arkeet said, a 1 object groupoid is a group.
12:50:20 <bollu> what's Mu ?
12:50:20 <monochrom> bollu: if both sentences held, then "size s = size (fmap (const ()) s" would be true for a set s of 10 elements.
12:50:26 <bollu> nolraiU: ahh.
12:50:44 <jle`> bollu: a groupoid is a category where every morphism is invertible
12:51:00 <johnw> newtype Mu f = Mu (forall r. (f r -> r) -> r).  It's a final encoding of Fix f = Fix (f (Fix f))
12:51:22 <johnw> bollu: getting the feeling that every questions creates two more? :)
12:51:27 <mniip> yea Fix Set is pretty broken as well
12:51:28 <bitemyapp> johnw: I sent an email, but seriously, kudos.
12:51:37 <johnw> bitemyapp: ooh, what did I do?
12:51:46 <bitemyapp> johnw: that thread for the downloads page.
12:51:52 <monochrom> I guess you could say "that's covered by 'fmap keeps shape, and shape implies size'", but I like to be specific.
12:51:58 <bollu> johnw: I've actually seen that somewhere as a monad or something, But I hate "typed" fixed point
12:52:01 <bitemyapp> johnw: if it's indicative of a more communicative and cooperative approach from the committee, then I am encouraged.
12:52:05 <johnw> ah, thank you!  and thanks for hearing me in our discussion offline, that was helpful.  You changed my opinion about the HP
12:52:06 <bollu> johnw: bah, never made sense
12:52:36 <jle`> bollu: such hatred :'(
12:52:40 <johnw> bitemyapp: I'm going to continue in this role as "community liaison" of sorts, to ensure that issues are heard and represented
12:52:41 <ReinH> bollu: you "hate" it? Why?
12:52:42 <bollu> johnw: care to example how the hell mu works? :)
12:53:01 <johnw> bollu: Mu Maybe is isomorphic to the natural numbers :)
12:53:05 <ReinH> johnw: +1
12:53:08 <bollu> ReinH: because it's trivial to write without types, but I never understood how to type it. ReinH: "afraid of it" is closer
12:53:09 <johnw> Nothing, Just Nothing, Just (Just Nothing), etc.
12:53:17 <bollu> johnw: what the fuck
12:53:20 <jle`> i mean, i guess it's good that mathematical concepts can inspire real passionate emoions
12:53:21 <bollu> that is crash
12:53:25 <bollu> crazy*
12:53:30 <bitemyapp> johnw: wfm :)
12:53:35 <jle`> *emotions
12:53:45 <bollu> johnw: explain Mu? :)
12:53:54 <johnw> Mu is the fixed point of a functor
12:54:02 <johnw> in the same way that you can have fixed points of functions
12:54:04 * hackagebot calculator 0.4.0.1 - A calculator repl, with variables, functions & Mathematica like dynamic plots.  https://hackage.haskell.org/package/calculator-0.4.0.1 (sumitsahrawat)
12:54:08 <johnw> it's easier to understand in the form of Fix than Mu
12:54:15 <bollu> johnw: okay, go on
12:54:16 <johnw> newtype Fix f = Fix (f (Fix f))
12:54:18 <jle`> bollu: Mu Maybe would be any inhabitant of Maybe (Maybe (Maybe (Maybe ... forever ... )))
12:54:33 <bollu> johnw: that is just the Y combinator
12:54:35 <johnw> so, it wraps 'f' forever, unless f has some notion of termination
12:54:39 <jle`> bollu: so, Nothing is an inhabitant.  so is Just Nothing.  so is Just (Just Nothing)
12:54:45 <bollu> oh, wait, this is type level
12:54:48 <johnw> yep
12:54:55 <jle`> bollu: the y combinator is a specific thing, it's not all fixed point combinators in general
12:54:59 <johnw> we have 'fix' at term level, and 'Fix' at type level, but they're similar
12:55:25 <bollu> johnw: so, Fix is one particular instantiation of Mu ?
12:55:34 <johnw> Fix is a different encoding of Mu
12:55:38 <mniip> no, Mu is a different variant of Fix
12:55:39 <johnw> there are 3 such encodings that work in Haskell
12:55:45 <mniip> they're isomorphic
12:55:47 <johnw> and proving that they are all isomorphic is a terrific exercise
12:55:51 <bollu> johnw: okay, can you show me Mu?
12:56:02 <johnw> newtype Mu f = Mu (forall x. (f x -> x) -> x)
12:56:06 <mniip> μ
12:56:06 <ReinH> No, the Y combinator is specifically Y = \f.(\x.f (x x)) (\x.f (x x))
12:56:12 <johnw> note how the recursion is implied here, and not explicit
12:56:21 <johnw> then there is Nu.
12:56:34 <bollu> johnw: I don't see it (Mu)
12:56:37 <johnw> data Nu f = forall x. Nu (f x, x -> f x)
12:56:39 <bollu> mniip: very clever :)
12:56:40 <johnw> it's ok if you don't
12:56:45 <johnw> in fact, stick with Fix for a while
12:56:51 <johnw> come back to Mu and Nu in a few months, I'd suggest
12:57:14 <bollu> hm
12:57:16 <johnw> I did the isomorphism exercise just a month ago, and it still took me a full day
12:57:41 <bollu> johnw: Nu will keep nesting tuples, right?
12:57:42 <jle`> bollu: it might be interesting to imagine all inhabitants of Maybe (Maybe (Maybe .. forever ..)) ... and for different functors, too
12:57:56 <bollu> jle`: right
12:57:58 <johnw> bollu: it can do that, sure, but so can they all
12:58:12 <jle`> like all of the inhabitants if [[[[..forever...]]]]
12:58:13 <johnw> this is a way of encoding type-level recursion
12:58:20 <johnw> without resorting to infinite types
12:58:20 <jle`> (that one might not be as interesting)
12:58:23 <mniip> and to confuse everything even more I once invented a Mu transformer!
12:58:30 <bollu> johnw: can you show me how you constructed Nat with Fix ?
12:58:35 <johnw> Fix Maybe
12:58:53 <arkeet> what about a 無 transformer?
12:58:53 <monochrom> Set is probably a contravariant functor, since it is like (-> Bool).
12:58:55 <bollu> johnw: so why will it automatically become Nothing, Just (Nothing), ...
12:58:55 <uwap> johnw, I took a look at the Mu - Nu - Isomorphism excercise a day ago and thought "Man. I see why they are isomorphic, though I can't prove it. that's way over my head" 
12:59:07 <jle`> bollu: think of what values have the type "Fix Maybe"
12:59:08 <mniip> monochrom, that's predicative definition of a set
12:59:12 <johnw> bollu: well, it will really become Fix Nothing, Fix Just (Fix Nothing), etc.
12:59:20 <arkeet> monochrom: "finite set" isn't, unfortunately.
12:59:21 <mniip> if we're talking about ZF sets we have an issue
12:59:21 <bollu> johnw: how does it "know" that the initial element must be Nothing?
12:59:22 <johnw> but the Fix's are just type wrapper, so they disappear at runtime
12:59:28 <ReinH> bollu: it doesn't
12:59:28 <jle`> bollu: now think what values have the type Natural (natural numbers)
12:59:36 <johnw> bollu: oh, it doesn't *have* to be, but the type tells us that it can be
12:59:38 <ReinH> Fix Nothing is just an inhabitant of the type, there is no ordering implied
12:59:49 <arkeet> it is a functor if you limit your source morphisms to finite-to-one mappings
12:59:52 <ReinH> an isomorphism to the natural numbers does not have to carry the ordering
12:59:55 <jle`> bollu: Nothing is a value that has the type Fix Nothing.  and Just Nothing is another value that has the type Fix Nothing
12:59:58 <jle`> er, Fix Maybe
12:59:58 <bollu> ReinH: oh. Along with Fix (Just(Nothing)) and so on?
13:00:00 <johnw> I was simply enumerating the order of the natural numbers starting at zero.  As ReinH says, they're all equally inhabitants
13:00:02 <bollu> ahh
13:00:08 <bollu> right, makes sense
13:00:08 <arkeet> contravariant functor*
13:00:13 <monochrom> well, any set you can code up in Haskell is not going to cover all of ZF
13:00:16 <jle`> bollu: Nothing :: Fix Maybe, Just Nothing :: Fix Maybe, Just (Just Nothing) :: Fix Maybe
13:00:25 <bollu> ReinH: you can construct an ordering based on the nesting, though right?
13:00:28 <jle`> bollu: if you consider all the inhabitants of Fix Maybe, then it's more or less just all of the natural numbers
13:00:28 <ReinH> jle`: you do actually need the Fix constructor
13:00:36 <bollu> ReinH: you can construct peano arithmetic
13:00:36 <ReinH> bollu: sure, we can impose an ordering on them
13:00:40 <jle`> ReinH: oh, yeah v.v
13:01:02 <bollu> jle`: Yeah, I can see the isomorphism
13:01:17 <ReinH> bollu: Fix Just is your successor function and Fix Nothing is zero.
13:01:27 <mniip> Fix . Just
13:01:44 <bollu> sum Nothing _ = b; some (Just x) b = sum x Just (b) <- I think this should work as (+)
13:01:50 <monochrom> in fact "binary search tree" is even further from ZF than (-> Bool) is.
13:01:52 <ReinH> mniip: ?
13:02:00 <mniip> Fix Just is something else
13:02:17 <ReinH> mniip: ... no?
13:02:19 <bollu> sum Nothing b = b; some (Just x) b = sum x Just (b) <- I think this should work as (+)
13:02:22 <mniip> :t Fix Just
13:02:23 <lambdabot>     Not in scope: data constructor ‘Fix’
13:02:23 <lambdabot>     Perhaps you meant one of these:
13:02:23 <lambdabot>       variable ‘iix’ (imported from Control.Lens),
13:02:33 <Zemyla> Do I need to uninstall the current Haskell Platform to install the new one?
13:02:36 <mutantmell> Fix is related to Free/CoFree as well, right?  Free a = Either (Fix Free a) a ?
13:02:44 <mniip> :t Fix Just
13:02:45 <lambdabot>     Couldn't match type ‘Maybe a’ with ‘Fix ((->) a)’
13:02:45 <lambdabot>     Expected type: a -> Fix ((->) a)
13:02:45 <lambdabot>       Actual type: a -> Maybe a
13:02:48 <mniip> :t Fix . Just
13:02:49 <lambdabot> Fix Maybe -> Fix Maybe
13:03:00 <Zemyla> :t Fix
13:03:01 <lambdabot> f (Fix f) -> Fix f
13:03:02 <bollu> mniip: what's with the (.) ?
13:03:12 <mniip> just regular composition
13:03:22 <mniip> \x -> Fix (Just x)
13:03:23 <monochrom> Zemyla: I think no, the two versions live in two different directories
13:03:24 <bollu> what is with that type?
13:03:30 <bollu> also, does my definition of sum make sense?
13:03:42 <mniip> as opposed to \x -> Fix Just x  which doesn't make sense
13:03:59 <ReinH> bollu: no. You're missing the Fix constructor, for starters
13:04:05 * hackagebot distributed-process-async 0.2.2 - Cloud Haskell Async API  https://hackage.haskell.org/package/distributed-process-async-0.2.2 (MathieuBoespflug)
13:04:59 <bollu> ReinH: um, I meant it for just adding together numbers represent by inhabitants of Fix Maybe. mniip: what?
13:05:23 <bollu> :t Fix
13:05:25 <lambdabot> f (Fix f) -> Fix f
13:05:26 <mniip> [21:55:56] <ReinH> bollu: Fix Just is your successor function and Fix Nothing is zero.
13:05:32 <mniip> Fix . Just, not Fix Just
13:05:42 <ReinH> mniip: Oh right, it's Fix (Just (Fix Nothing)), not Fix Just (Fix Nothing)
13:05:50 <bollu> mniip: oh, okay, that was what was tripping me up
13:06:00 <bollu> mniip: but.. what does the compositon mean?
13:06:05 <bollu> like, this is type level
13:06:08 <bollu> what are you composing?
13:06:08 <mniip> no
13:06:09 <ReinH> bollu: No it isn't.
13:06:15 <mniip> we are composing the Just constructor
13:06:17 <ReinH> Fix and Just are functions.
13:06:18 <mniip> with the Fix constructor
13:06:24 <ReinH> (Fix is also a type)
13:06:40 <ReinH> (There are two things called Fix)
13:06:42 <mutantmell> :info Fix
13:06:50 <bollu> ReinH: the type and the data constructor
13:07:08 <ReinH> Right.
13:08:31 <bollu> ReinH: so, Fix f = (f(Fix f) -> Fix f) ??
13:08:43 <bollu> so Fix f is a function
13:08:48 <bollu> from f(Fix f) to Fix f?
13:08:58 <mniip> no
13:09:05 <mniip> data Fix f = Fix (f (Fix f))
13:09:16 <mniip> just like Just :: a -> Maybe a
13:09:28 <mniip> FixConstructor :: f (FixType f) -> FixType f
13:09:36 <bollu> ah
13:09:45 <bollu> mniip: okay, here's my confusion
13:09:58 <bollu> Just is of type a -> Maybe a, since Maybe x = Just x | Nothing
13:10:19 <bollu> so similarly, FixType f = ??? (to give FixConstructor that type)
13:10:26 <bollu> if I had to try
13:10:32 <mniip> @let data FixType f = FixConstructor (f (FixType f))
13:10:34 <lambdabot>  Defined.
13:10:38 <mniip> :t FixConstructor
13:10:39 <lambdabot> f (FixType f) -> FixType f
13:10:46 <bollu> oh god
13:11:02 <bollu> mniip: and the fact that it works out that way is "obvious" to you?
13:11:07 <mniip> uh
13:11:08 <mniip> yes?
13:11:42 <bollu> oh, right
13:11:44 <bollu> of course
13:11:54 <mniip> data Foo x p = A (p x) x
13:11:57 <bollu> you're giving a f(Fixtype f) for the FixConstructor to construct
13:12:00 <mniip> A :: p x -> x -> Foo x p
13:12:03 <bollu> which is of type FixType f
13:12:06 <bollu> yes, I see it
13:12:12 <bollu> just had to unclog my brain :)
13:12:51 <mniip> now occasionally, evil people will name constructors the same way as the types
13:12:55 <bollu> :t FixConstructor Maybe
13:12:57 <lambdabot>     Not in scope: data constructor ‘Maybe’
13:12:57 <lambdabot>     Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
13:13:08 <mniip> :t Identity
13:13:09 <lambdabot> a -> Identity a
13:13:10 <mniip> :t Const
13:13:11 <lambdabot> a -> Const a b
13:13:25 <bollu> mniip: yeah, ik :) 
13:13:37 <bollu> mniip: now, how would I construct the Fix over Maybe?
13:13:43 <bollu> :k Fix
13:13:44 <lambdabot> (* -> *) -> *
13:14:03 <bollu> :t Fix []
13:14:04 <lambdabot> Fix []
13:14:10 <mniip> :k FixType Maybe
13:14:11 <lambdabot> *
13:14:17 <mniip> :t FixConstructor Nothing
13:14:18 <lambdabot> FixType Maybe
13:14:23 <bollu> right
13:14:26 <bollu> makes sense
13:14:35 <bollu> Fix []
13:14:40 <mniip> :t FixConstructor (Just (FixConstructor Nothing))
13:14:41 <lambdabot> FixType Maybe
13:14:43 <bollu> > Fix []
13:14:45 <lambdabot>      No instance for (Show (Fix []))
13:14:45 <lambdabot>        arising from a use of ‘show_M30377619873888706056028’
13:14:45 <lambdabot>      In the expression:
13:15:05 <bollu> mniip: I'll need to pen-and-paper for it to sink in
13:15:24 <arkeet> @let deriving instance Show (f (Fix f)) => Show (Fix f)
13:15:26 <lambdabot>  Defined.
13:15:29 <arkeet> > Fix []
13:15:31 <lambdabot>  Fix []
13:15:55 * mniip already typed out instance Show1 f => Show (Fix f) where showsPrec d (Fix x) = showParen (d > 9) $ showString "Fix " . showsPrec1 10 x
13:16:16 <bollu> > Fix ([Fix[]])
13:16:17 <lambdabot>  Fix [Fix []]
13:16:25 <arkeet> mniip: sorry :>
13:16:32 <bollu> hmm
13:16:49 <arkeet> > Fix [Fix [], Fix []]
13:16:51 <orbitz> Hello! Is there a common strategy for controling the order of execution of each step in an applicative?  I would like left-to-right, if that makes sense.  I'm still tryign to wrap my head around it so apologies if my question doesn't make sense.
13:16:51 <lambdabot>  Fix [Fix [],Fix []]
13:17:16 <johnw> orbitz: execution order is defined by each given applicative
13:17:17 <arkeet> orbitz: well, <*> sequences effects from left to right.
13:17:26 <arkeet> (where the meaning of "effect" depends on the applicative)
13:17:40 <mniip> orbitz, <**>
13:17:43 <johnw> arkeet: can I do: mf <*> mx = do { x <- mx; f <- mf; return (f x) }
13:17:46 <mniip> :t (<**>)
13:17:47 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
13:17:49 <cow-orker> Anyone having success building HDBC-mysql with 7.10? I have fixed the setup file and added "extra-libraries: mysqlclient" as described in the tickets, but still there is no reference to libmysqlclient.so and ghci complains "can't load .so/.DLL for: ... libHSHDBC-mysql-0.6.6.1-LUaapFuO0de0Kdx7Qqoiem-ghc7.10.2.so ... undefined symbol: mysql_close
13:17:53 <mniip> actually executes effects backwards ^
13:17:56 <arkeet> johnw: you want mx <**> mf for that.
13:18:03 <bollu> @ let sumfix (Fix (Fix x) y = sumfix (Fix x) (Fix y)
13:18:10 <johnw> what I mean is, can't i defined my applicative that way and still obey the laws?
13:18:13 <bollu> @let sumfix (Fix (Fix x) y = sumfix (Fix x) (Fix y)
13:18:13 <lambdabot>  Parse failed: Parse error: =
13:18:23 <johnw> I didn't think execution order was imposed
13:18:25 <bollu> @let sumfix (Fix (Fix x)) y = sumfix (Fix x) (Fix y)
13:18:26 <lambdabot>  .L.hs:167:14:
13:18:26 <lambdabot>      Couldn't match kind ‘*’ with ‘* -> *’
13:18:26 <lambdabot>      When matching types
13:18:44 <mniip> johnw, correct, you could write a newtype wrapper
13:18:49 <mniip> for flipping applicatives
13:19:05 <orbitz> Hrm, I think I'm just implementing this funnily then
13:19:15 <bollu> @let sumfix (Fix f (Fix x)) y = symfix (Fix x) (Fix (f y))
13:19:16 <lambdabot>  .L.hs:167:28:
13:19:16 <lambdabot>      Not in scope: ‘symfix’
13:19:16 <lambdabot>      Perhaps you meant one of these:
13:19:20 <orbitz> I'll think on it a bit longer
13:19:32 <bollu> @let sumfix (Fix f (Fix x)) y = sumfix (Fix x) (Fix (f y))
13:19:33 <lambdabot>  .L.hs:167:9:
13:19:33 <lambdabot>      Constructor ‘Fix’ should have 1 argument, but has been given 2
13:19:33 <lambdabot>      In the pattern: Fix f (Fix x)
13:19:46 <johnw> bollu: Fix is a great type to really spend some time on, it'll pay off in many ways later
13:19:53 <bollu> @let sumfix (Fix (f (Fix x))) y = sumfix (Fix x) (Fix (f y))
13:19:53 <lambdabot>  Parse failed: Parse error in pattern: f
13:20:04 * nomeata wonders if "liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c" isn’t the more natural basic primitive, instead of "(<*>) :: f (a -> b) -> f a -> f b"
13:20:04 <bollu> what? parse failed?
13:20:22 <johnw> in your pattern match
13:20:28 <nomeata> it looks more symmetric, and – to me – better captures what you can and cannot do with Applicative
13:20:28 <bollu> oh
13:21:04 <orbitz> Ah, so the problam is, I think, I'm trying to delay some execution and the way I'm doing it ends up being right-to-left
13:21:31 <bollu> johnw: how do I get the type constructor of the type that fix was applied on?
13:21:31 <mniip> nomeata, no actually the more basic primitive is (**) :: f a -> f b -> f (a, b)
13:21:39 <bollu> I think you can see what I was going for
13:21:46 <ReinH> orbitz: what specifically are you trying to do?
13:21:53 <mniip> nomeata, actually the name "Applicative" talks about lifting N-ary functions into the functor
13:22:06 <mniip> johnw, lookie
13:22:07 <johnw> bollu: you don't :)
13:22:11 <mniip> > liftA2 (,) [1,2] [3,4]
13:22:13 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
13:22:14 <johnw> bollu: all you know is that it's a functor, so fmap is your friend...
13:22:16 <mniip> > liftA2 (,) (F[1,2]) (F[3,4])
13:22:18 <lambdabot>  F [(1,3),(2,3),(1,4),(2,4)]
13:22:19 <bollu> johnw: you don't, or you can't?
13:22:22 <ReinH> mniip: I don't think so. I think <*> is the basic primitive.
13:22:23 <johnw> you cannot
13:22:23 <bollu> johnw: oh, right!
13:22:25 <johnw> the Functor is abstract
13:22:32 <bollu> I completely forgot that f is a functor
13:22:33 <bollu> hm
13:22:33 <mniip> ReinH, see above comment
13:22:36 <bollu> this should be easy them
13:22:55 <ReinH> I don't like the "lax monoidal functor with a strength" interpretation because it requires that sort of round-about way of thinking
13:22:56 <orbitz> ReinH: I'm trying to create a deserailizer for a format such that you can do buidler <$> type1 <*> type2 <*> type3
13:23:17 <orbitz> I think if ai use a record instead of a function for the delaying i can get what i want!
13:23:22 <mniip> orbitz, nothing's wrong with using liftAN all over the place
13:23:28 <ReinH> I prefer the closed functor interpretation, in which <*> is a direct statement of one of the properties
13:23:30 <mniip> but the mathematical definition is based on <*>
13:23:35 <bollu> johnw: okay, no, I need Applicative. Or at least Pointed
13:23:48 <bollu> ReinH: what in the world is a lax monoidal functor?
13:24:05 <ReinH> bollu: some abstract nonsense
13:24:08 <Fuuzetsu> bollu: there is one place on the internet which can reveal the secrets
13:24:10 <orbitz> mniip: In this case I'm doing some learning, and I liek the (<*>) api aesthetics more 
13:24:12 <bollu> ReinH: I have time :)
13:24:19 <Fuuzetsu> but more than likely it will just send you on endless journey
13:24:22 <ReinH> bollu: Ok, do you know what a category is?
13:24:27 <mniip> bollu, how many years
13:24:31 <bollu> ReinH: object, arrow, functors
13:24:37 <Fuuzetsu> ReinH: that's always a good starting question ;P
13:24:41 <bollu> ReinH: yes, but that's about it 
13:24:46 <bollu> ReinH: that's close to all I know
13:24:49 <ReinH> Ok, do you have about a month?
13:24:55 <bollu> ReinH: actually yes
13:25:02 <ReinH> Well, unfortunately, I don't. But there are some books.
13:25:08 <bollu> ReinH: if you'll tell me to read the book categories for the working pogrammer
13:25:11 <bollu> programmer*
13:25:14 <bollu> I'm already on it!
13:25:15 <bollu> :)
13:25:24 <ReinH> I was going to tell you to read Basic Category Theory by Leinster
13:25:37 <bollu> Oh, I have awodey
13:25:39 <ReinH> And Category Theory by Awodey
13:25:40 <Fuuzetsu> bollu: http://ncatlab.org/nlab/show/HomePage
13:25:50 <mniip> ReinH, by the way, got some literature for whatever comes /after/ basic CT?
13:25:57 <ReinH> mniip: Mac Lane
13:26:14 <ReinH> and Eugenia Cheng's higher order category theory book
13:26:17 <mniip> that's a person
13:26:21 <ReinH> Who wrote a book.
13:26:32 <mniip> "Categories for the working mathematician" ?
13:26:39 <mniip> but I'm not a maethematician :(
13:26:45 <bollu> whoa, dad has that book
13:26:47 <ReinH> bollu: You just said "I have awodey" so I assumed you understood that method of reference.
13:26:48 <bollu> it's pure nonsense
13:27:06 <Fuuzetsu> the proper term is abstract nonsense
13:27:11 <bollu> he starts with, weirdly named stuff like "Kan extensions" and whatnot
13:27:12 <ReinH> It is also pure.
13:27:15 <Cale> I don't actually like CftWM all that much, but I don't know what to recommend exactly. I suppose from there it depends on what you want to focus in on.
13:27:19 <mniip> ReinH, maybe I overstated my knowledge a bit here
13:27:19 <bollu> it seems cool though
13:27:47 <frerich> Fuuzetsu: Or maybe 'abstraction distraction' :o]
13:27:51 <Cale> CftWM has some additional stuff in it relative to Awodey, but mostly it covers the same ground, with more examples that nonmathematicians aren't going to appreciate.
13:28:16 <mniip> ReinH, consider that I have a pretty strong grasp of what a category is, who are monoids and what are monoidal categories, understand the yoneda isomorphism, and understand monads in the category of hask, but not in other categories
13:28:19 <bollu> can I get "pointed" out of a functor?
13:28:29 <mniip> what level is that
13:28:29 <bollu> I want to increate the layering of a Fix
13:28:39 <bollu> increase*
13:28:56 <mniip> :t Fix . Just -- bollu
13:28:57 <lambdabot> Fix Maybe -> Fix Maybe
13:29:02 <ReinH> mniip: Sorry, I got confused for a sec.
13:29:11 <ReinH> Awodey has some stuff on categorical logic that I haven't read yet
13:29:12 <bollu> mniip: but that is for a particular functor
13:29:19 <bollu> mniip: I wanted in general (hence pointed)
13:29:22 <mniip> :t Fix . pure
13:29:23 <lambdabot> Applicative f => Fix f -> Fix f
13:30:06 <ReinH> mniip: You might like Cheng's book on n-category theory
13:31:16 <ReinH> Cale: Well, I think Kan extensions are pretty important no matter what, and CftWM has the only good presentation of those that I've seen?
13:31:41 <bollu> mniip: right, but I'm given only functor, not Applicative
13:31:41 <mniip> oh right
13:31:46 <mniip> natural transformations
13:31:46 <Cale> Yeah, you might be right about that
13:31:52 <mniip> the thing I got stuck on last time
13:32:00 <mniip> bollu, parametrically impossible
13:32:14 <Cale> I kind of find myself wishing for a yet better presentation of Kan extensions.
13:32:22 <ReinH> Cale: me too
13:32:23 <bollu> mniip: can I include fix to have pointed so I can write a general sum? :)
13:32:31 <ReinH> Mac Lane is a bit... brisk
13:34:10 <ReinH> mniip: My earlier point was that (f a, f b) -> f (a, b) is a direct presentation of a monoidal functor in Hask. It takes some extra work to figure out how that... applies... to Applicative.
13:34:25 <ReinH> mniip: While f (a -> b) -> f a -> f b is a direct presentation of a closed functor
13:34:26 <monochrom> hehe
13:34:29 <Cale> Doing a quick search, I just found this http://www.math.harvard.edu/theses/senior/lehner/lehner.pdf which looks good.
13:34:44 <ReinH> (also the unit, which doesn't really matter for Applicative?)
13:35:02 <ReinH> Cale: oh nice
13:35:24 <ReinH> Cale: I love it when a throw-away sentence spawns a thesis. (Ok, not *that* throw-away)
13:35:42 <mniip> (<*>) = fmap (uncurry id) .: (**)
13:35:51 <ReinH> mniip: Right, "some extra work"
13:36:08 <ReinH> which is not obvious
13:36:17 <Cale> Well, it's just a bachelor's degree thesis, but nonetheless it looks like a nice presentation. :)
13:36:17 <mniip> obvious enough to me
13:36:27 <ReinH> mniip: becaue you already know it
13:36:39 <mniip> because I already derived it myself at some earlier point?
13:37:35 <ReinH> Anyway, (.) (fmap (uncurry id)) (**) is an unnecessarily round-about way to describe <*>
13:37:41 <mniip> that's like saying [Bool] is not isomorphic to integers because it requires some "extra work" to arithmetize
13:38:27 <ReinH> Well, it's more like saying "Why use [Bool] to represent your numbers when you can just use Integer?"
13:38:47 <ReinH> I'm not claiming the two aren't isomorphic
13:38:55 <mniip> why use liftA2 (,) to pair your applicatives when you can just use (**)
13:38:58 <ReinH> I'm claiming one is an unnecessarily complicated explanation
13:39:05 <arkeet> what's (**)?
13:39:07 * hackagebot oso2pdf 0.1.0 - Better conversion of Oxford Scholarship Online material to PDF  https://hackage.haskell.org/package/oso2pdf-0.1.0 (spwhitton)
13:39:16 <mniip> arkeet, an alternative Applicative definition
13:39:20 <arkeet> what is it?
13:39:26 <ReinH> arkeet: liftM2 (,)
13:39:30 <ReinH> er liftA2
13:39:35 <mniip> class Functor f => Applicative f where unit :: f (); (**) :: f a -> f b -> f (a, b)
13:39:40 <arkeet> ok
13:39:56 <arkeet> for Applicative I like just taking "pure" and "liftA2" as fundamental.
13:40:06 <ReinH> And I prefer <*>
13:40:24 <arkeet> (<*>) = liftA2 id
13:40:29 <monochrom> sorry, what is (**)?
13:40:36 <mniip> monochrom, 10 lines above
13:40:36 <monochrom> nevermind, I see.
13:40:37 <arkeet> < mniip> class Functor f => Applicative f where unit :: f (); (**) :: f a -> f b -> f (a, b)
13:41:14 <arkeet> <,>
13:41:17 <arkeet> :-)
13:41:22 <monochrom> ok, it looks like more fun to debate over "is [Bool] isomorphic to nteger?"
13:41:37 <arkeet> is nteger like integer without identity?
13:41:40 <mniip> monochrom, binary numbers with implicit leading one
13:41:58 <monochrom> yeah <,> would be much nicer
13:42:14 <monochrom> haha, great typo
13:43:26 <mniip> it is also true because real integers have no zeros :P
13:43:41 <mniip> er
13:43:47 <mniip> s/integer/natural
13:43:51 <mniip> in all of the above
13:44:06 <mniip> although [Bool] is still isomorphic to Integers
13:44:20 <arkeet> which integer is cycle [False,True]?
13:44:34 <monochrom> p-adic integers
13:44:37 <arkeet> (the answer is -1/3)
13:44:53 <arkeet> er, -2/3
13:45:16 <arkeet> 2-adic integers.
13:45:46 <ReinH> monochrom: of course it is :p
13:47:28 <mniip> arkeet, okay you win
13:47:41 <mniip> are you happy
13:47:45 <arkeet> never
13:48:26 <monochrom> arkeet follows Steve Jobs's advice. "stay hungry. stay angry." :)
13:48:29 <bollu> what exactly are the p-adics?
13:48:34 <bollu> I've never read up on them
13:48:43 <bollu> IIRC, they have a different metric?
13:48:44 <arkeet> well, read up on them
13:48:50 <bollu> arkeet: :)
13:49:14 <mniip> monochrom, did he, by chance, decide to follow that advice because he's unable to not follow it? :P
13:49:40 <arkeet> it's what you get instead of the real numbers if you let decimal (well, base-p) expansions extend infinitely to the left, instead of to the right.
13:50:02 <mniip> ......333333333.1 ?
13:50:06 <arkeet> e.g. in binary, ...11111 is -1 (because if you add 1, then things carry indefinitely and you end up with all 0s)
13:50:30 <arkeet> and ...010101 is -1/3 because if you multiply by 3 (well, 11) you get ...111111
13:51:01 <monochrom> yeah, 2-adic is like 2's complement except you don't know how many bits so you just say "unlimited"
13:51:45 <arkeet> right, 2-adic arithmetic is like arithmetic mod 2^n, except n is arbitrarily large.
13:52:05 <bollu> arkeet: so how do you interpret ...33333.1?
13:52:06 <albertus1> *imagining the haskell function operating on an infinite list of digits trying to decide whether the result is 0*
13:52:10 <bollu> Like, how do I get the value?
13:52:23 <arkeet> bollu: uh, depends on the base, my examples were in base 2 (2-adic numbers)
13:53:06 <bollu> arkeet: okay, assuming base 2. Like, with the usual repr, it would be 1 * 2^0 + 1 * 2^1 + … (which will obv diverge)
13:53:14 <bollu> so what's the value in the 2-adic system?
13:53:19 <arkeet> well, it diverges in the real metric
13:53:30 <arkeet> but in the 2-adic metric, large powers of 2 are small (close to 0).
13:53:42 <arkeet> so that converges.
13:53:51 <arkeet> ok, consider:
13:54:05 <arkeet> 2^0 + 2^1 + 2^2 + ... + 2^k
13:54:07 * hackagebot CoreDump 0.1.0.0 - A GHC plugin for printing GHC's internal Core data structures.  https://hackage.haskell.org/package/CoreDump-0.1.0.0 (OmerAgacan)
13:54:14 <arkeet> gets closer to -1 as k increases
13:54:15 <bollu> right...
13:54:17 <arkeet> because
13:54:20 <bollu> what?
13:54:27 <arkeet> 2^0 + 2^1 + 2^2 + ... + 2^k = 2^(k+1) - 1
13:54:36 <arkeet> and as k increases, 2^(k+1) gets smaller (in the 2-adic metric)
13:54:44 <bollu> arkeet: what is the metric?
13:54:56 <bollu> d(p, 0) == ?
13:55:05 <mniip> it's not a space metric
13:55:13 <arkeet> ok, write p = 2^k * r, where r is an odd integer.
13:55:18 <arkeet> then d(p,0) = 2^(-k)
13:55:36 <bollu> 2^(k*r)? or r * 2^k?
13:55:41 <arkeet> what I wrote.
13:55:53 <arkeet> in particular, d(2^k,0) = 2^-k
13:56:08 <arkeet> this defines the metric on the integers, anyway.
13:56:11 <arkeet> (or rational numbers)
13:56:11 <bollu> p = 2^k * r === r * 2^k ? 
13:56:21 <albertus1> True
13:56:30 <arkeet> bollu: in other words
13:56:35 <bollu> okay, I was notationally challended. 
13:56:36 <arkeet> if you factor p into powers of primes
13:56:37 <bollu> arkeet: yes?
13:56:38 <arkeet> k is the exponent on 2
13:56:51 <bollu> the more factorisable it is, the smaller it is?
13:56:53 <bollu> what a weird notion
13:57:16 <arkeet> the p-adic integers/numbers are what you get when you complete the integers/rationals under this metric.
13:57:46 <arkeet> exercise: prove it's actually a metric.
13:57:49 <arkeet> (triangle inequality, etc)
13:58:18 <bollu> arkeet: will do
13:58:31 <arkeet> also I guess just read up on it.
13:58:45 <arkeet> uh, there's a nice book on p-adic numbers
13:59:03 <mniip> okay now
13:59:08 <arkeet> http://www.amazon.com/p-adic-Numbers-An-Introduction-Universitext/dp/3540629114
13:59:09 <bollu> arkeet: which book?
13:59:11 <mniip> can someone explain tensors? \o/
13:59:21 <arkeet> mniip: in what context?
13:59:24 <bollu> mniip: "multilinear maps" drops mic
13:59:34 <mniip> in the commonly used context
13:59:37 <mniip> linalg I guess
13:59:41 <arkeet> ok
13:59:49 <arkeet> pick up a linear algebra text that talks about them
14:00:03 <ReinH> tensor is just a fancy word for product :p
14:00:11 <bollu> arkeet: no paperback in my country :(
14:00:25 <arkeet> bollu: I'm just giving a reference.
14:00:35 <ReinH> (not really)
14:00:38 <mniip> I've digested the "tensors are left adjunctions to hom-functors" definition, but I'm struggling to relate it to the linear algebra thingy
14:00:50 <arkeet> mniip: tensor products represent multilinear maps.
14:01:05 <arkeet> what I mean is
14:01:21 <johnw> http://ncatlab.org/nlab/show/tensor+product
14:01:27 <arkeet> multilinear maps A,B -> C are in natural bijection with linear maps A (x) B -> C
14:02:08 <mniip> er?
14:02:15 <mniip> what does (x) denote here
14:02:19 <arkeet> tensor product
14:02:29 <arkeet> ascii version of ⊗
14:02:38 <mniip> and , ?
14:02:57 <arkeet> I just mean a function of two arguments.
14:03:08 <mniip> so type product
14:03:08 <ReinH> mniip: It helps if you put linear algebra in a categorical setting
14:03:11 <ttt_fff> in Parsec BuildExpressionGrammar, is it possible to specify that "empty space / lack of token = App" ?
14:03:11 <arkeet> I should have said bilinear maps I guess.
14:03:18 <ttt_fff> i.e. I have binary ops + - * /
14:03:26 <mniip> ReinH, how do?
14:03:26 <bollu> ReinH: o_O that's doable?
14:03:28 <ttt_fff> but I also want to say "no token = interpret it as "App""
14:03:30 <shachaf> Multilinear maps (A x B) -> C are in natural bijection with linear maps A (x) B -> C
14:03:34 <ReinH> mniip: http://graphicallinearalgebra.net
14:03:42 <shachaf> The parentheses distribute over the vector spaces.
14:03:52 <shachaf> Commute with? Something.
14:03:54 <ReinH> shachaf: nice
14:04:02 <arkeet> in particular, there's a universal multilinear map A x B -> A (x) B
14:04:29 <arkeet> everything else is just a consequence of all that.
14:04:41 <bollu> arkeet: now explain co and contravariance :)
14:04:47 <ReinH> bollu: The word "algebra" wasn't used by mistake. ;)
14:06:44 <monochrom> ttt_fff: I wouldn't look for "lack of anything apart from space". instead, I use chainl1 token (return App)
14:06:46 <JCI> hi everyone, I'm new here, and I have a sort of hard-to-write-out question about flow control when calling an IO function where each successive call takes as parameters the output from the previous call, until the output meets a predicate. The IO function reads the result from a file, generates a new file based on the output, calls the external app, then repeats the process. Not sure how to efficiently share my code so far...
14:07:10 <ralu> can somebody familiar with package system-filepath explains wizardry behind build process
14:07:15 <arkeet> @paste is a good way to share code.
14:07:16 <lambdabot> Haskell pastebin: http://lpaste.net/
14:07:32 <arkeet> (if it's a single file)
14:07:37 <monochrom> ttt_fff: or rather, chainl1 term (return App)
14:07:51 <JCI> nice, thanks.
14:07:54 <ttt_fff> monochrom: basically, you're saying, at the lexing stage, inject a TokenApp ?
14:08:08 <ttt_fff> monochrom: inject "TokenApp"s between "TokenVar"s during the lexing stage
14:08:10 <monochrom> no, this is not at the lexing stage.
14:08:19 <monochrom> and there is no TokenApp
14:08:35 <monochrom> see my latest correction.
14:08:55 <ttt_fff> monochrom: I have a 2 stage parsec, 1 parsec for lexing, and 1 parsec for parsing expressions
14:09:04 <ttt_fff> monochrom: are you assuming a 1 stage string -> ast ?
14:09:08 * hackagebot MTGBuilder 0.2.0.0 - Builds decks out of a meta  https://hackage.haskell.org/package/MTGBuilder-0.2.0.0 (willfancher)
14:09:09 <ttt_fff> (I need 2 stages to do layout parsing)
14:09:09 <JCI> I've looked into the whileM monad and unfoldr, but I'm having trouble with the implementation
14:09:54 <monochrom> no. if you have separate lexing stage and parsing stage, my chainl1 is in the parsing stage
14:10:16 <monochrom> ok look, I'm going to flesh out an example.
14:10:32 <monochrom> (read: I'm beginning a monologue)
14:11:35 <monochrom> suppose you have this simple grammar: term = var | leftparen var1 ... varn rightparen. (n >= 1)  like s-expressions.
14:11:57 <ttt_fff> monochrom: hmm, is it possible to use that together with buildExpressionParser  ?
14:12:10 <ttt_fff> I want to use buildExpressionParser to handle infix binops that have precedence + asosciativity
14:12:21 <ttt_fff> but I need 'fake' binops inbetween terms
14:12:36 <monochrom> then I would code: term = var <|> between leftparen rightparen (chainl1 term (return App))
14:12:40 <ttt_fff> i.e. [TokenVar "f", TokenVar "a"] gets parsed into ExprApp "f" "a"
14:12:57 <monochrom> I have done this before and it works.
14:13:18 <monochrom> it is also easy to extend this to accomodate binary operators with precedences
14:13:30 <ttt_fff> do you have to implement shunting yard algorithm yourself ?
14:13:32 <ReinH> JCI: I'd start writing something simple like loop arg = do { (result, arg') <- doStuffWith arg; if result then loop arg' else return () }
14:13:44 <monochrom> no.
14:13:59 <ReinH> JCI: just write out the flow control explicitly
14:15:16 <ttt_fff> monochrom: can you share the code that you had?
14:15:31 <monochrom> I am too lazy to dig it out and post it
14:16:38 <JCI> ReinH: thanks, I'll give that a try. I have some code I'll try pasting here, but it's large. 
14:16:47 <ttt_fff> monochrom++ // for honesty
14:19:04 <ReinH> @where lpaste -- JCI
14:19:04 <lambdabot> http://lpaste.net/
14:19:48 <nkaretnikov> woo, i triggered context-reduction stack overflow :)
14:19:53 <monochrom> what I said about "easy to accomodate binary operators" is true when application has higher precendence than actual binary operators. then buildExpression doesn't even need to know about application.
14:20:03 <ReinH> nkaretnikov: *slow clap*
14:20:28 <ReinH> monochrom: It's very easy to write Haskell-like languages using parsec ;)
14:20:32 <ReinH> Go figure.
14:20:55 <bollu> pratt parser is best parser
14:20:56 <bollu> http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/
14:21:17 <magamig> do you recommend any begginers guide to haskell?
14:21:18 <monochrom> it goes like this: term = between leftperen rightparen term <|> chainl1 term2 (return App).
14:21:52 <monochrom> then, term2 = what you get from buildExpression, and tell it to use term
14:23:25 <ReinH> bollu: I think we've made some improvements in parsing since the 70s
14:23:39 <bollu> ReinH: oh, come on. it's so elegant!
14:23:47 <bollu> ReinH: like, top down is too much effort
14:23:51 <bollu> bottom up is too opaque
14:23:53 <geekosaur> @where learnhaskell
14:23:53 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:23:56 <geekosaur> magamig, ^^
14:23:58 <bollu> but, top down operator precedence = <3
14:24:18 <ReinH> bollu: Have you actually used parser combinator libraries?
14:24:41 <bollu> ReinH: yes, I have. And yes, they're nice
14:24:54 <magamig> lambdadot geekosaur ty
14:24:54 <bollu> ReinH: but my tolerance for magic is slightly lower than parser combinators
14:25:00 <ReinH> (Which, to be fair, also originated in the 70s)
14:25:15 <bollu> I think mine is still at the const [True, False] crap that gives you the powerset
14:25:18 <geekosaur> magamig: also, LYAH can be useful along with something else; but by itself, it has no exercises and tends to leave people able to read Haskell but not write it
14:25:56 <ReinH> Wait, what?
14:26:11 <ReinH> Parser combinators are way less "magical" than that
14:26:31 <bollu> ReinH: :) maybe
14:26:35 <ReinH> A parser for a is just a function String -> [(a, String)]
14:26:49 <bollu> ReinH: um, tomorrow?
14:26:52 <bollu> I'm really sleepy
14:27:01 <ReinH> Everything else is just nice combinators
14:27:03 <bollu> thanks! :)
14:27:09 <geekosaur> parser combinators are just functions that can parse simple things, and are arranged so you can compose them to parse complex combinations of things
14:27:19 <montanonic> magamig: I consider myself and "advanced beginner" and have worked through the CIS194 and half of NICTA; the Programming Haskell book that bitemyapp is writing is legitimately excellent in my opinion. I bought it last night and read through 200 pages. Most of those things I felt like I already covered and understood, but even still I learned a good chunk and gained more comfort, and I still have like 600 pages to go :)
14:27:23 <montanonic> an*
14:27:41 <hiptobecubic> damn, it's that long?
14:27:42 <bitemyapp> montanonic: Haskell Programming* (but thank you)
14:27:54 <bitemyapp> hiptobecubic: it doesn't feel as long as it sounds.
14:28:01 <montanonic> bitemyapp: yes, indeed; (and thank you too!)
14:28:01 <hiptobecubic> I'm not complaining
14:28:19 <mniip> ReinH, err what
14:28:23 <mniip> monoids of lego bricks?
14:29:03 <hiptobecubic> bitemyapp, do you have a target date for the first run?
14:29:54 <bitemyapp> hiptobecubic: first run?
14:30:03 <bitemyapp> hiptobecubic: you mean of the final version?
14:30:41 <magamig> montanonic thank you :) @bitemyapp i will check it
14:31:17 <hiptobecubic> bitemyapp, yes. When can I drag one out to the meetup and have you two sign it?
14:31:35 <montanonic> magamig: It's the most comprehensive resource I've found so far. Definitely seems like a great place to start. Enjoy learning Haskell however you end up doing it! :)
14:31:53 <bitemyapp> hiptobecubic: we don't know if it'll get printed or not. content-complete is Jan 15th. Current version is 797 pages, covering up to monad.
14:32:08 <bitemyapp> hiptobecubic: we're trying to find a publisher/printer that can deal with how long the book is.
14:32:14 <montanonic> haha
14:32:20 <montanonic> That's an awesome problem to be dealing with.
14:32:34 <montanonic> Find the people that published David Foster Wallace, they're used to it.
14:33:11 <ReinH> bitemyapp: you should split it up into multiple volumes. I hear a few people have had some success with that approach...
14:33:18 <bitemyapp> ReinH: nope.
14:33:22 <ReinH> bitemyapp: kidding
14:33:31 <bitemyapp> ReinH: what's the reference then?
14:33:32 <ReinH> bitemyapp: They end up getting packaged back together again anyway ;)
14:33:37 <ReinH> bitemyapp: Knuth, Weinberg
14:34:18 <ReinH> Can you imagine if AoCP was a single book o_O
14:35:13 <Andrej_T> hey everyone. i have a function that returns a Float; i want to print it as a 2-decimal string
14:35:25 <Andrej_T> googling yielded printf "%.2f"
14:35:28 <bitemyapp> ReinH: make a good pillar for a hut.
14:35:29 <Andrej_T> but i'm getting strange errors
14:35:41 <geekosaur> https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/base-4.8.1.0/Numeric.html#v:showFFloat
14:36:01 <Andrej_T> main = print $ printf "%.2f" (funThatReturnsFloat)
14:36:04 <Andrej_T> that doesn't work
14:36:12 <geekosaur> printf may well drive you nuts; it's more an example of a certain bit of typeclass hackery which can get you into confusing trouble
14:36:13 <hiptobecubic> bitemyapp, have you thought bout just releasing it in volumes?
14:36:17 <ReinH> hahaha
14:36:17 <hiptobecubic> about*, rather
14:36:27 <ReinH> hiptobecubic: I just asked ;)
14:36:37 <bitemyapp> hiptobecubic: we've considered it and ruled it out.
14:36:39 <geekosaur> (also if you omitted the "print $" it would attempt to print itself)
14:36:48 <geekosaur> (which is part of the typeclass hackery)
14:36:49 <Enigmagic> > (printf "%.2f" 0.01 :: String)
14:36:51 <lambdabot>  "0.01"
14:37:12 <Andrej_T> Enigmagic: supplementing a literal works
14:37:14 <geekosaur> the problem here, I think, is that "print" is polymorphic and that confuses the typeclass hackery
14:37:37 <Enigmagic> Andrej_T: what's the error?
14:37:53 <pavonia> funThatReturnsFloat -- Is that function applied to an argument?
14:38:09 <geekosaur> if you force it to String then it should work, or (again) just omit the "print $" because (a) "printf" will recognize that IO () is the expected type and print it itself (b) "print" will attempt to add string escapes, pointlessly in this case probably
14:38:46 <Andrej_T> so many questions, just a sec, i'll paste the code and the error :)
14:38:52 <hiptobecubic> ReinH, :D oops
14:39:09 * hackagebot ed25519 0.0.4.0 - Ed25519 cryptographic signatures  https://hackage.haskell.org/package/ed25519-0.0.4.0 (AustinSeipp)
14:39:47 <Andrej_T> code and error: https://gist.github.com/whoeverest/a0d1047d6ad83a6962a4
14:39:56 <Fuuzetsu> bitemyapp: what exactly is in there that it warrants 800 pages to get to monad?
14:40:07 <Fuuzetsu> I mean, who's going to read something that long…
14:40:10 <geekosaur> Andrej_T, see what I said earlier
14:40:26 <bitemyapp> Fuuzetsu: have I done something to offend or upset you?
14:40:34 <Fuuzetsu> bitemyapp: no
14:40:38 <Fuuzetsu> it's a genuine question
14:40:40 <bitemyapp> Fuuzetsu: are you that rude by default?
14:40:43 <geekosaur> "printf" is black magic, and you confused it by passing its result to "print" because "print" is polymorphic
14:41:15 <Fuuzetsu> bitemyapp: ok then if you're going to get all defensive for no apparent reason then forget I even asked
14:41:15 <bitemyapp> Fuuzetsu: The book is designed to work for people who haven't necessarily programmed much before. It begins with a tutorial on lambda calculus.
14:41:22 <Enigmagic> Andrej_T: try sticking "main :: IO ()" before the definition
14:41:22 <geekosaur> Andrej_T, if you just leave off the "print $" part, it should work
14:41:25 <Fuuzetsu> OK, that's what I wanted to hear, thanks
14:41:29 <bitemyapp> Fuuzetsu: it's example and exercise driven, which takes up a lot of space. There's much less prose than you'd think.
14:41:35 <Jacoby6000> Fuuzetsu: imagine reading a book about calculus, written for people who have never done algebra
14:41:41 <Andrej_T> geekosaur: in the example, i've ommited the print $ printf
14:41:41 <geekosaur> otherwise, force the result type of the printf call to String
14:41:50 <Jacoby6000> it has to explain all of the foundations to get to the good stuff
14:41:59 <Andrej_T> Enigmagic: yeah. adding a type sig worked
14:42:03 <Fuuzetsu> Jacoby6000: I'm reminded of Spivak's ‘Calculus’
14:42:09 <Fuuzetsu> what a large book that is ;)
14:42:09 <Andrej_T> huh. let me take some time to understand this
14:42:13 <bitemyapp> Fuuzetsu: we pay pretty careful attention to keeping it from getting boring or tiresome.
14:42:19 <geekosaur> hm, yes, that probably needs to be forced to IO ()
14:42:20 <bitemyapp> Fuuzetsu: nobody's complained about the length that has read it, so far.
14:42:20 <geekosaur> same issue
14:42:35 <Enigmagic> Andrej_T: problem is that printf is overloaded.. it has two general forms: one that returns `String` and one that returns `IO ()`
14:42:44 <geekosaur> default type of "main" is "IO a" for unspecified "a", and "printf" doesn't know what to do in that case
14:42:47 <bitemyapp> Fuuzetsu: I've read tiresome Haskell material/books, so I'm sensitive to that.
14:43:04 <shirt> Can I get a better error message when "read" fails, rather than just "no parse"?
14:43:25 <Andrej_T> i see. is there a function that *doesn't* attempt to print (hence it's not overloaded, doesn't print?)
14:43:32 <Fuuzetsu> bitemyapp: well, that's great; I'm simply asking from the point of view of a beginner coming and thinking ‘wow, I have to read thousands of pages to get started?’. But if you say that so far it has been fine then great
14:43:35 <geekosaur> shirt, probably you want to use reads instead, or readMaybe
14:43:55 <geekosaur> [28 21:35] <geekosaur> https://downloads.haskell.org/~ghc/7.10.2/docs/html/libraries/base-4.8.1.0/Numeric.html#v:showFFloat
14:43:59 <bitemyapp> Fuuzetsu: yeah we understand the apprehension some have.
14:44:10 * hackagebot diagrams-contrib 1.3.0.7 - Collection of user contributions to diagrams EDSL  https://hackage.haskell.org/package/diagrams-contrib-1.3.0.7 (BrentYorgey)
14:44:11 <Enigmagic> Andrej_T: adding a type signature to the result will work, e.g.: (printf "%.2f" var) :: String
14:44:14 <bitemyapp> Fuuzetsu: but it's breezier and more pleasant than the page count implies, we think :)
14:44:17 <ReinH> bitemyapp: fwiw I think there's a way to read "what exactly warrants 800 pages" that isn't rude. I read it that way. It does seem like a lot tbh.
14:44:19 <geekosaur> Andrej_T, see that function or its siblings
14:44:37 <Fuuzetsu> when is first edition or preview or something coming out?
14:44:42 <montanonic> Fuuzetsu: Be thankful that there is that much material. Trust me, I've spent a good chunk of time with this language, and there's no way I'd have understood Monads at all without working through all the layers below it. Also, from the chunk that I've read from it, the book is very well paced.
14:44:55 <geekosaur> Fuuzetsu, ReinH, there isa way to read it that isn't rude, yes, but it is a bit... abrupt
14:45:09 <geekosaur> inviting miscommunication
14:45:12 <bitemyapp> Fuuzetsu: it's available for preview right now (797 pages, up to Monad), if you mean "content-complete", that's Jan 15th.
14:45:22 <Fuuzetsu> where can I see the preview?
14:45:42 <bitemyapp> http://haskellbook.com/ the free sample is the 2nd and third chapters plus the intro.
14:46:56 <Andrej_T> Enigmagic geekosaur thanks!
14:47:11 <shirt> geekosaur: i don't see how to get a better error message with reads
14:48:50 <geekosaur> shirt, basically you pattern match the result, if it's [(result,"")] then it succeeded, otherwise you do whatever you want to indicate failure
14:49:03 <Fuuzetsu> bitemyapp: hm, doesn't look like the kind of thing I'd be looking to read but I wish you luck
14:49:07 <albertus1> from my point of view of an experienced (imperative / oo) programmer and "mathematically literate", i found nothing wrong with LYAH, btw. just lacking exercises
14:49:12 <geekosaur> likewise readMaybe you get Just result or Nothing, and do whatever error handling in the latter case
14:49:16 <shirt> but i'm looking for a detailed error message, with line and column
14:49:40 <lpaste> monochrom pasted “application and binary operator” at http://lpaste.net/141890
14:49:41 <bitemyapp> Fuuzetsu: I can't answer that without knowing what you'd want. Is there anything you're looking for material on?
14:49:42 <geekosaur> so? nothing automates tracking line and column, you will need to do that yourself regardless
14:49:53 <monochrom> ttt_fff: http://lpaste.net/141890
14:50:04 <Fuuzetsu> bitemyapp: I mean it's just a bit too basic for me I suppose
14:50:09 <bitemyapp> Fuuzetsu: I believe you're already experienced, so I'm curious as to what you'd be interested in.
14:50:24 <bitemyapp> Fuuzetsu: how are your structural intuitions for things like Applicative?
14:50:45 <geekosaur> shirt, normally when you get to that point then what you really want is a parser, something like Parsec will track that information for you and give you better errors
14:50:53 <shirt> > read "[1, 2, a, 4]" :: [Int]
14:50:54 * frerich moans
14:50:55 <lambdabot>  *Exception: Prelude.read: no parse
14:51:07 <shirt> How can i get the location of the error inside the string?
14:51:16 <ttt_fff> monochrom: hmm, currently reading about pratt parsers :-)
14:51:24 <Fuuzetsu> bitemyapp: modern-day information about optimisation for example but one could probably write whole book about that
14:51:38 <geekosaur> shirt, with reads the string that is empty in the success case is the remainder of the string in the failure case
14:51:48 <bitemyapp> Fuuzetsu: foundational or bag of tricks?
14:51:49 <albertus1> shirt: you could write a recursive function yielding tuples (position, result)
14:51:58 <geekosaur> > reads "1abc" :: Int
14:52:00 <lambdabot>      Couldn't match expected type ‘Int’
14:52:00 <lambdabot>                  with actual type ‘[(a0, String)]’
14:52:00 <lambdabot>      In the expression: reads "1abc" :: Int
14:52:03 <geekosaur> bah
14:52:15 <geekosaur> > reads "1abc" :: [(Int,String)]
14:52:17 <lambdabot>  [(1,"abc")]
14:52:38 <Fuuzetsu> bitemyapp: both, reading core, how to poke GHC in the right way; for example I liked the tooling sections in Simon M.'s book on concurrency, about threadscope &c
14:52:42 <geekosaur> 1 valid parse, recognized a value 1 and couldn't understand "abc"
14:52:49 <shirt> > reads "[1, 2, a, 4]" :: [([Int], String)]
14:52:51 <lambdabot>  []
14:53:04 <shirt> doesn't seem to help at all
14:53:08 <Fuuzetsu> would be very nice to have solid material on space profiling &c too
14:53:10 <bitemyapp> Fuuzetsu: we planned to talk a bit about perf with the non-strictness and data structures chapters, but it's going to try for general reasoning capacity rather than specifics like Simon or Bryan's books.
14:53:19 <Fuuzetsu> right
14:53:25 <geekosaur> ok, you're in parser territory
14:53:30 <geekosaur> go look at Parsec
14:53:31 <bitemyapp> so our approach will be a bit more like Bird, but this is good to keep in mind.
14:53:46 <bitemyapp> Fuuzetsu: I'll see what I can do. I'll let you know if I think there's anything interested in there for you. Thank you!
14:53:49 <shirt> geekosaur: thanks but i can't use parsec. surely "read" knows where the error happened and can tell me?
14:53:56 <geekosaur> nope
14:54:08 <geekosaur> read is intentionally quite stupid (as is reads, which read uses)
14:54:21 <geekosaur> and slow and not really intended for general use
14:54:28 <shirt> well that's a shame
14:54:31 <geekosaur> you are expected to use a real parser in production code
14:54:46 <frerich> Fuuzetsu: In case you didn't see it yet - Real World Haskell has a chapter on profiling, which also involves measuring space usage and understanding the Core language. See http://book.realworldhaskell.org/read/profiling-and-optimization.html (this may be old news, but I thought I'd rather mention it before you miss it :)
14:54:56 <geekosaur> it's really best to think of read and show (and their cousins) as debugging aids
14:55:15 <Fuuzetsu> I saw it but it's old, hence why I specifically said modern-day
14:55:29 <shirt> this is for scripting tasks, where read would be very convenient, but i at least need a line number if there is a parse error
14:55:39 <geekosaur> although they are widely abused as parsers and prettyprinters, respectively, that's not a very good idea and they're not really flexible enough for such uses
14:57:52 <nkaretnikov> how do i define less then using type families? do i need to encode prop for that?
14:58:04 <nkaretnikov> i'm using coq as a references impl.
14:58:21 <ReinH> bitemyapp: well you know how much I like Bird. :)
14:58:24 <geekosaur> the design constraints for read and show were "dirt simple and small enough to go into a compact Prelude" --- error checking was not included
14:58:32 <nkaretnikov> e.g., what do i return in the type instance LE n n case?
14:58:49 <johnw> you mean, type instance LessThan Zero Zero = False, ....?
14:59:01 <nkaretnikov> johnw: i mistyped
14:59:06 <nkaretnikov> i need less or equal
14:59:09 <nkaretnikov> for less then
14:59:29 <nkaretnikov> johnw: so, do i need to encode true and false?
14:59:33 <nkaretnikov> like in coq
14:59:34 <monochrom> the Read type class is not going to give you line numbers or any error message
14:59:35 <johnw> https://hackage.haskell.org/package/PeanoWitnesses-0.1.0.0/docs/src/Data-Numeric-Witness-Peano.html#LessThanOrEqual
14:59:40 <johnw> there's an implementation there
14:59:47 <nkaretnikov> lemme see
14:59:51 <johnw> DataKinds will lift Bool into a kind
15:00:05 <monochrom> insisting on both "I must use Read" and "I want line numbers" is barking at the wrong tree or two wrong trees
15:00:20 <monochrom> you must give up on one of them. or both.
15:00:23 <nkaretnikov> johnw: so, can i use type family LE n m :: Bool with data kinds?
15:00:47 <johnw> yes
15:00:49 <nkaretnikov> johnw: but wouldn't it make possible to use prove False?
15:00:49 <shirt> monochrom: is there a technical reason why Read can't give line numbers? Is it impossible since it needs to be general?
15:00:55 <johnw> 'True and 'False are you type inhabitants
15:00:55 <nkaretnikov> or is in not applicable here?
15:01:09 <johnw> Haskell does not even attempt to be logically consistent
15:01:29 <monochrom> is it important and productive to find an answer to that question?
15:02:02 <printline> I get a parse error when trying this in ghci:  :t IArray.!
15:02:12 <printline> do I have to escape the ! somehow?
15:02:24 <geekosaur> printline, :t (IArray.!)
15:02:38 <geekosaur> operators need to be in "function form", i.e. wrapped in parentheses
15:02:40 <bitemyapp> ReinH: it's less inspired by Bird in terms of actual approach, but there's a general principle in the book to try to target foundational/reusable knowledge that lasts longer and can act as a launchpad for other things.
15:02:48 <monochrom>  :t wants an expression. so you need to supply a legal expression
15:02:55 <shirt> i thought the haskell community encouraged curiosity and deep understanding, with productivity being only a secondary concern....
15:03:00 <bitemyapp> ReinH: so I'm less interested in specific tools than the capacity to reason in your head, but I do still think about 'em.
15:03:02 <printline> monochrom: I see, thanks
15:03:13 <monochrom> whereas :i just want names. (so you need to avoid supplying an arbitrary expression)
15:03:42 <geekosaur> shirt, deep understanding in this case means that the ReadS typeclass implementation in the Report is concise and easy to understand. not an industrial strength parser
15:03:51 <monochrom> for example ":i (+)" is going to be wrong, too
15:04:15 <nkaretnikov> johnw: okay, new problem.  how do i convey to ghc that by n n i mean equal things while by n m i mean different ones?
15:04:24 <nkaretnikov> do i need to match on the constructors?
15:04:28 <nkaretnikov> that'd be messy
15:04:56 <geekosaur> depending on context... don't you have to say something like (n ~ m) => Whatever n m i?
15:05:05 <monochrom> shirt: (1) I do not speak for the haskell community. I speak for myself.  (2) there is no technical reason, only a lot of trade-off reason.
15:05:21 <geekosaur> you can't just reuse the type variables
15:05:43 <geekosaur> likewise in a definition "foo n n = ..." would not ensure the two parameters are the same
15:05:56 <nkaretnikov> geekosaur: type instance LE n n = True
15:06:03 <shirt> monochrom: ok thanks
15:06:03 <johnw> I think he is thinking of Agda-esque foo n .n = ...?
15:06:08 <monochrom> it is easy to rewrite the Read type class to include line numbers. does it mean the Haskell committee accept it?
15:06:18 <johnw> nkaretnikov: that isn't going to work
15:06:25 <nkaretnikov> i know
15:06:44 <nkaretnikov> it the same as in ordinary functions
15:06:55 <johnw> nkaretnikov: well, hmm.... maybe LE n n does do what you think
15:07:01 <johnw> bu LE n m doesn't have any information
15:07:03 <mniip> ReinH, I migh've gone insane thanks to those wire diagrams
15:07:18 <mniip> I'm pretty sure I see an isomorphism between wires and lambda calculus .____.
15:07:26 <albertus1> if n needn't even be member of Eq, "foo n n" would be strange anyway
15:07:43 <nkaretnikov> johnw: i'll try the approach from peanowitnesses
15:08:05 <johnw> nkaretnikov: apparently GHC.TypeLits defines a type-level <=  too, btw
15:08:28 <johnw> by way of a type family named <=?
15:08:39 <nkaretnikov> johnw: i briefly looked at the ghc docs. got scared of proxy, and ran away
15:08:48 <shirt> i just think that the automatic Read and Show instances for any data type in Haskell are really cool. Something that I haven't seen in any other language. It's just a shame that it doesn't provide better parse error messages, since as you say, it could be implemented, and would provide to the user great benefit with no cost
15:08:48 <johnw> proxy is so awesome, though
15:09:10 * hackagebot MTGBuilder 0.2.0.1 - Builds decks out of a meta  https://hackage.haskell.org/package/MTGBuilder-0.2.0.1 (willfancher)
15:09:13 <nkaretnikov> johnw: i know nothing about them at the moment
15:09:21 <nkaretnikov> and probably have no time to learn right now
15:09:29 <johnw> nkaretnikov: an argument with type information only
15:09:29 <monochrom> for example, I do use Read sometimes. but I only use it on one line of user input at a time, or even a fraction of one such line. what line number?
15:09:30 <nkaretnikov> i should have been asleep by now
15:09:37 <johnw> argument/value
15:09:50 <geekosaur> shirt, the Show version of this is that people always want "show" to be a prettyprinter. but they also want to be able to derive it...
15:10:01 <nkaretnikov> johnw: how's that different from undefined :: MyThing?
15:10:11 <geekosaur> you can't have both. for Read there are parsers, for Show there are prettyprinters
15:10:15 <johnw> you can evaluate it to Proxy
15:10:25 <johnw> otherwise, they are used to the same purpose
15:10:27 <Xe> in haskell, how do I setuid() for all existing threads and threads that will exist?
15:10:49 <geekosaur> Xe, uid is a process attribute, at least on POSIX
15:10:53 <chpatrick1> I wonder if there's a quasiquoter that generates a parsers parser for ADTs
15:10:56 <monochrom> if Read provided line numbers, I would find it useless. worse, I would find it stand in the way, because I would have to write extra code to discard the line number.
15:11:27 <nkaretnikov> johnw: is there a type level add in the ghc typelits?
15:11:30 <nkaretnikov> and*
15:11:31 <johnw> yes
15:11:33 <Xe> geekosaur: the use case is something that drops permissions after it opens files
15:11:38 <nkaretnikov> sorry, i meant and
15:12:00 <geekosaur> Xe, I think you missed my point
15:12:05 <johnw> nkaretnikov: you can find lots of that in the singletons library
15:12:06 <geekosaur> you cannot have threads with different uids
15:12:09 <johnw> not sure if GHC surfaces it
15:12:21 <nkaretnikov> oh, i forgot about that one completely!
15:12:23 <nkaretnikov> thanks!
15:12:43 <geekosaur> if you setuid(), it affects the entire process. threads cannot have their own uids independent of each other
15:13:30 <geekosaur> (I know Linux's clone() allows you to do this, but pthreads does not expose that. There are all sorts of nasty security issues in allowing that generally)
15:13:47 <monochrom> so the answer to "how to setuid for all past, present, and future threads" is "just setuid once" :)
15:14:27 <chpatrick1> wow ReadP is Codensity on a Free monad
15:14:30 <chpatrick1> surprising for base
15:14:50 <Xe> geekosaur: strange, i'm having an issue in go code where calling setuid() on one goroutine doesn't affect all goroutines for the process. I'm trying to take this and other inconsistencies as a reason to start the process of writing new code in Haskell like other parts of the company do.
15:14:59 <monochrom> because they didn't think of it that way back then when ReadP was written
15:15:11 <Ralith> Xe: what company is this?
15:15:15 <geekosaur> Xe, that sounds like go uses clone() directly instead of the pthread stuff
15:15:27 <geekosaur> which would seem likely to me, and as I said invites security issues
15:15:31 <chpatrick1> monochrom: what is because of that?
15:15:40 <geekosaur> now you have to track security levels in accessing arbitrary memory locations in the process
15:15:49 <monochrom> they were only thinking "this helps nondeterminism" and "ReadP is overall small and sweet enough to add to base"
15:16:03 <chpatrick1> yeah
15:16:12 <chpatrick1> it's just more sophisticated than what you usually see in base
15:16:27 * geekosaur would in fact take that as meaning "avoid go in security-critical apps"
15:16:56 <geekosaur> unless they actually have a memory MAC framework that isn't a microaccounting nightmare
15:18:32 <nkaretnikov> how do i work with a type that was promoted to a kind?
15:18:38 <nkaretnikov> e.g., bool?
15:18:43 <chpatrick1> work how?
15:19:10 <chpatrick1> same way you do with other types in general
15:19:12 <monochrom> first you have to decide which one you want: the type? or the kind?
15:19:16 <chpatrick1> typeclasses and type families
15:19:30 <johnw> chpatrick1: that's pretty cool, actually
15:19:40 <monochrom> because they are unrelated, except receiving the same name.
15:24:48 <geekosaur> Xe, by the way, are you sure that the goroutines are not using the POSIX saved-setid feature?
15:25:09 <Xe> geekosaur: i setsid in one and the other can open /etc/shadow in writable mode
15:25:31 <geekosaur> ...setsid?
15:25:36 <geekosaur> was that a typo?
15:25:44 <Xe> er
15:25:46 <Xe> uid
15:25:48 <Xe> yeah
15:25:55 <Xe> i'm oncall this week and tired
15:26:25 <geekosaur> you might check that they aren't racing
15:26:49 <monochrom> to really know how go does it, you have to run your go implementation under strace, and actually find out what syscalls it uses. (as opposed to assuming.)
15:26:57 <geekosaur> otherwise, I'd be inspecting those threads from outside to see if they are POSIX threads or clone() threads (which look like processes)
15:29:12 <Xe> they might be clone() threads
15:29:22 <Xe> does that show in strace?
15:30:15 <geekosaur> it would show but you'd have to know what to look for
15:30:39 <geekosaur> also depending on kernel version a POSIX thread might be created with clone(); you would need to inspect the sharing flags
15:30:56 <geekosaur> i.e. whether the cloned "thread" shares credentials or not
15:31:13 <geekosaur> (pthreads expects them to be shared, but you can make them separate)
15:31:36 <nkaretnikov> monochrom: the kind
15:32:15 <monochrom> then use the kind name at places where kinds are expected, e.g., kind signatures.
15:35:30 <geekosaur> hmmm. actually looking at clone(), you can't actually separate set ids with it
15:35:38 <geekosaur> (uid/gid/group vector)
15:35:57 <geekosaur> so either you are seeing a race condition, or for some reason it is using processes instead of threads
15:36:07 <nkaretnikov> monochrom: i usually work with * or * -> * and the like,  how's bool different?
15:36:12 <geekosaur> (butt hat would go against the supposed lightweight nature of goroutines)
15:36:43 <monochrom> I don't understand the question.
15:37:31 <mniip> Hask is a monoidal category, right? As witnessed by the ArrowChoice instance of (->) ?
15:37:32 <nkaretnikov> monochrom: if i try something like undefined :: LT Zero Zero, i'll get the expected type, but got kind bool error
15:37:57 <mniip> (a -> b) -> (c -> d) -> Either a c -> Either b d
15:38:26 <johnw> mniip: Hask is a monoidal category with several choices of tensor, even
15:38:26 <monochrom> I haven't seen how LT and Zero are declared.
15:38:38 <Pamelloes> Would a foreign function to read a constant be considered pure or impure? The value of the constant will never change during program execution, but the value may change between executions.
15:38:40 <mniip> I see, type product and type sum?
15:38:46 <johnw> Compose is one
15:38:49 <mniip> and probably any other bifunctor
15:38:55 <johnw> Day convolution is another
15:39:00 <johnw> Product is another
15:39:04 <mniip> explain compose?
15:39:09 <johnw> Compose gives you Monad
15:39:14 <johnw> (Hask, Compose, Identity)
15:39:20 <mniip> er?
15:39:24 <nkaretnikov> monochrom: data Zero and type family LT n m :: Bool where LT ...
15:39:43 <nkaretnikov> with datakinds enabled
15:39:43 <mniip> Compose as in Compose f g x = Compose (f (g x)) ?
15:39:45 <johnw> mniip: see http://arxiv.org/abs/1406.4823
15:39:46 <johnw> yes
15:39:50 <monochrom> Pamelloes: that is a gray area. but try pure first.
15:40:11 <Pamelloes> monochrom: Thanks :)
15:40:17 <monochrom> I think people have not finished debating over this.
15:40:18 <johnw> Compose f (Compose g h x) =~ Compose (Compose f g) h x
15:42:49 <monochrom> nkaretnikov: whenever you write "undefined :: T", T is required to have kind *. no other choice allowed. "LT Zero Zero" does not satisfy the requirement.
15:43:13 <nkaretnikov> yeah, i get that
15:43:23 <nkaretnikov> hence my question
15:43:34 <monochrom> another example: "undefined :: Maybe" is wrong too, Maybe has kind * -> *, even that is rejected.
15:43:35 <johnw> mniip: ack, I got that wrong
15:43:44 <johnw> mniip: [Hask,Hask] is the monoidal category, not Hask
15:43:44 <nkaretnikov> mon
15:43:48 <nkaretnikov> monochrom: i get it
15:43:59 <johnw> mniip: since I was talking about endofunctors on Hask, not Hask itself
15:44:08 <monochrom> ok, so don't ever write "undefined :: LT Zero Zero"
15:44:16 <nkaretnikov> monochrom: the question is: do i need to define a helper to work with bool to get back a *?
15:44:37 <monochrom> is that even possible?
15:44:49 <nkaretnikov> no idea
15:45:02 <nkaretnikov> i see how * -> * is useful
15:45:05 <monochrom> does the helper have a type? what is its type?
15:45:11 <nkaretnikov> no idea
15:45:28 <Enigmagic> nkaretnikov: Data.Proxy.Proxy will give you back a *
15:45:41 <nkaretnikov> Enigmagic: thanks!
15:49:12 * hackagebot calculator 0.4.0.2 - A calculator repl, with variables, functions & Mathematica like dynamic plots.  https://hackage.haskell.org/package/calculator-0.4.0.2 (sumitsahrawat)
15:50:16 <monochrom> I don't understand how that helps.
15:50:46 <monochrom> it only allows you to write "Proxy :: Proxy (LT Zero Zero)". it still does not allow "Proxy :: LT Zero Zero"
15:53:32 <Enigmagic> *shrug* depends on what he needs it for
15:59:12 * hackagebot plot-gtk-ui 0.3.0.0 - A quick way to use Mathematica like Manipulation abilities  https://hackage.haskell.org/package/plot-gtk-ui-0.3.0.0 (sumitsahrawat)
16:02:40 <odicaa> hi everyone, do you know where can i ask for (big) deals in tech world?
16:02:52 <odicaa> i mean sales
16:03:01 <johnw> not here, odicaa 
16:03:11 <dmj`> odicaa: this room is dedicated to the haskell programming langauge
16:03:29 <odicaa> ok, sorry
16:03:33 <odicaa> thanks
16:06:30 <Denommus> ... do I actually need (>>=) or join for a parser?
16:06:42 <Denommus> I seem to be able to rewrite everything with applicative-style
16:06:53 <Enigmagic> depends on what you're parsing
16:07:26 <Denommus> Enigmagic: any example?
16:08:55 <int-e> Denommus: try parsing an xml-style element: < name > ... </ [same name again] >
16:09:23 <Denommus> int-e: oh!
16:09:30 <int-e> Denommus: basically if what you want to parse depends on the parsed contents (a repeated word, things like that) you'll need a monadic parser
16:11:01 <Denommus> int-e: in that case would it be something like `el = do { char '<'; n <- name; char '>'; e <- el; return n; return (n, e) }`?
16:11:24 <Denommus> oops
16:11:28 <Denommus> e <- some el
16:12:03 <Denommus> hurr, I forgot the </ and >
16:12:05 <Denommus> but you get it
16:12:23 <int-e> Denommus: not sure what the "return n" is supposed to do; is it supposed to be something like `string name`?
16:12:29 <int-e> s/name/n/
16:13:00 <Denommus> int-e: yes, I guess
16:13:17 <Denommus> int-e: isn't "string foo" basically redundant with "pure foo" or "return foo"?
16:13:36 <int-e> Denommus: no, because return and pure don't consume any input.
16:14:13 <int-e> (and never fail)
16:14:20 <Denommus> ah!
16:15:09 <Denommus> int-e: but besides that, I got the general idea, right?
16:15:23 <int-e> Denommus: yes I think so.
16:18:49 <Denommus> int-e: thanks
16:33:55 <AndChat|718256> Is there an abstraction for the following: I have some type B that can be created from type A, such that in some sense A provides 'Metadata' for B. The obvious abstraction is a function A->B, but since B is relatively complex and is used often I'd like there to be some caching. 
16:35:42 <AndChat|718256> The simplest example is that I have A->(B->C), but I'd like to be able to "probe" the B->C function 
16:37:05 <jle`> AndChat|718256: if you want cacheing, you can use a Map
16:37:15 <jle`> if A is Ord
16:38:06 <jle`> er, if it is enumerable
16:38:27 <jle`> and if there are a sufficiently small amount
16:38:54 <jle`> other than that you can use a library like memo-combinators
16:39:14 * hackagebot calculator 0.4.1.0 - A calculator repl, with variables, functions & Mathematica like dynamic plots.  https://hackage.haskell.org/package/calculator-0.4.1.0 (sumitsahrawat)
16:46:31 <rpfun> jle`: memoization is the wrong solution I think. An example might make it clearer. Suppose I can make functions that add some number to integers. In this case A ~ Int. I can give A->B as (+). Then B is Int->Int. I'd like to work with B's, but if they are just functions I can't compare them, or optimize code by figuring out what the A was that generated that B just from the function 
16:47:16 <rpfun> One inefficient solution is to just pass around A and the function A->B, but then I may need to generate B many times
16:48:36 <rpfun> Passing around A and B seems inelegant (for example, how can I know that B was produced by a particular A->B? I can't even compare different A->Bs!)
16:48:59 <rpfun> So to be sure I have to generate B every time anyway
16:58:25 <printline> trying to get this simple example running: main = do; line <- getLine; unlelss (line=="q") $ do; (putStr line; main;)
16:58:39 <printline> ; indicates a line break, (..) indentation
16:59:07 <printline> for some reason the putStr only appears after pressing q
16:59:30 <Hijiri> terminals usually buffer output by line
16:59:42 <Hijiri> so you don't get output until a newline, or unless you explicitly flush the buffer
16:59:51 <Hijiri> or set the buffer mode
17:00:19 <printline> Hijiri: oh, that's something quite significant about terminal buffers that I didn't know there :D
17:00:30 <sm> is there a haskell implementation of wprintf somewhere ? (printf that's aware of wide characters)
17:00:42 <Hijiri> I would suggest using hFlush with stdout (in System.IO), or setting the buffer mode to NoBuffering
17:00:50 <Hijiri> with hSetBuffering
17:00:56 <Hijiri> (also in System.IO)
17:01:13 <printline> thank you
17:04:23 <juanpaucar> Does somebody knows if i can use a git repo as a library in cabal?
17:07:48 <geekosaur> not directly
17:07:59 <geekosaur> that is, you can't name a git repo as a dependency
17:08:35 <geekosaur> you can clone it into a subdirectory and "cabal sandbox add-source" that, but cabal won't update it for you or anything
17:09:48 <Enigmagic> juanpaucar: stack has support for git dependencies
17:10:45 <juanpaucar> I see, thanks geekosaur
17:10:51 <juanpaucar> i'll check that Enigmagic
17:21:04 <Welkin> stack just downloads the git repo
17:21:12 <Welkin> you need to provide the exact hash for the commit though
17:34:16 * hackagebot chatter 0.7.0.0 - A library of simple NLP algorithms.  https://hackage.haskell.org/package/chatter-0.7.0.0 (RoganCreswick)
17:44:08 <glguy> osa1: lexing is in a pretty good state now :)
17:50:40 <osa1> glguy: hey, you there?
18:17:21 <bbb_> Is there a linear algebra library that uses static dimensions (perhaps using type-level Ints)?
18:19:11 <arkeet> bbb_: hmatrix has such a thing
18:19:16 <arkeet> and linear
18:19:20 <athan> bbb_: Isn't the linear package one?
18:20:56 <bbb_> arkeet and athan: does this work okay if a dimension depends on entries that aren't known until runtime, e.g., a null space?
18:21:45 <arkeet> you can have ones that have an unknown dimension at compile time
18:21:50 <arkeet> but then you won't know anything about them
18:22:13 <arkeet> it'll just be some existential thing.
18:22:27 <arkeet> in particular, you won't know that it has the same dimension as itself.
18:23:36 <bbb_> Huh. So I need to refresh my memory on "Haskell doesn't have existential types but they can be simulated with this 'for all' construction?"
18:23:53 <shachaf> GHC has existential types, just not first-class.
18:23:55 <athan> bbb_: Similar in circumstance to having some parser that returns an unknown type? How would you ever make a function that could `parse :: forall a. String -> a`?
18:24:18 * hackagebot husk-scheme 3.19.1 - R5RS Scheme interpreter, compiler, and library.  https://hackage.haskell.org/package/husk-scheme-3.19.1 (JustinEthier)
18:24:23 <athan> It would be (very) difficult to cover all cases.
18:24:26 <shachaf> The keyword you use to express an existential type to GHC is forall.
18:25:09 <Cale> (which seems weird until you see where the forall keyword gets positioned)
18:25:11 <athan> bbb_: In your case, you're looking for a `makeVector :: forall (n :: Nat). RawData -> Vector n`
18:25:48 <athan> (at least I think :s)
18:26:11 <shachaf> Yes.
18:26:39 <shachaf> I see people write "data T = exists a. T a", and it's a bit irritating.
18:27:16 <shachaf> Then again, I also see people write things like "(exists a. Show a => a)"
18:27:18 <hunteriam> Im trying to think of a good data structure here
18:27:20 <athan> shachaf: I agree
18:27:41 <hunteriam> i need a data structure to represent a frequency list of the letters in a string
18:27:45 <hunteriam> not sure what would be good
18:27:53 <hunteriam> Is a simple map the best choice?
18:27:54 <athan> hunteriam: [(Char, Integer)] ?
18:27:59 <athan> that's even better :)
18:28:15 <hunteriam> Is it? because im sticking this thing inside another map that connects it to a list of strings
18:28:15 <athan> because each Char is unique
18:28:47 <arkeet> if Map does the operations you want, use Map.
18:28:47 <hunteriam> Yea ok this is good thanks dude
18:28:53 <arkeet> unless you have a good reason to use something else.
18:28:55 <hunteriam> arkeet: im vaguely concerned about speed
18:29:01 <arkeet> profile it then.
18:29:05 <arkeet> and benchmark.
18:29:08 <hunteriam> Theoretical speed
18:29:14 <arkeet> I don't know what that is.
18:29:30 <hunteriam> Well an array is theoretically faster than a linked list for some operations
18:29:45 <hunteriam> and a hashmap is theoretically faster than an array for some operations
18:29:56 <hunteriam> does that explain it well enough?
18:30:02 <arkeet> and a Map is in practice fast enough for most purposes.
18:30:11 <hunteriam> but i dont care about practical speed
18:30:14 <hunteriam> this is for a class
18:30:22 <arkeet> so you care about asymptotics?
18:30:23 <hunteriam> theoretical speed is all that matters
18:30:45 <hunteriam> ill go with yes even though i dont fully understand what asymptotics are
18:30:50 <arkeet> big O etc.
18:30:54 <hunteriam> yea exactly
18:30:58 <athan> hunteriam: Youll get there maigne
18:31:07 <hunteriam> lol what do you mean ill get there
18:31:21 <arkeet> well fortunately your alphabet is a fixed size.
18:31:24 <athan> to the end of the asymptite
18:31:25 <athan> tote*
18:31:31 <hunteriam> my dream :O
18:31:33 <athan> totes* mcgoats*
18:31:38 <hunteriam> i want to ride the asymptote all the way
18:31:52 <hunteriam> arkeet: thats a good point
18:32:13 <hunteriam> arkeet: data.map runs on haskell lists right? so it should be slower than a hashmap?
18:32:13 <noonan> So I'm having this weird problem and I don't know enough about cabal (or maybe lens, or maybe cabal-macosx) to resolve it.
18:32:18 <arkeet> uh no?
18:32:28 <arkeet> it runs on its own balanced binary tree implementation.
18:32:28 <hunteriam> arkeet: oh ok what does it run on then
18:32:32 <hunteriam> oh ok
18:32:38 <athan> hunteriam: finger trees
18:32:43 <athan> ordered finger trees*
18:32:44 <hunteriam> what a name
18:33:11 <arkeet> which means many operations take log time in the size of the map.
18:33:11 <noonan> I have a cabal sandbox on os x which builds fine, but as soon as I add a file that does makeLenses, cabal build fails in a kind of silent way
18:33:33 <arkeet> since your alphabet is a fixed size, if you didn't need persistence you might also consider just using an array.
18:33:36 <athan> noonan: Can you put your error on lpaste.net?
18:33:43 <arkeet> with one element for each letter.
18:34:15 <arkeet> but then efficient use of that would require mutation
18:34:22 <arkeet> so used in ST or IO or something
18:34:24 <hunteriam> sigh
18:34:41 <hunteriam> >trying to take a class built for normal programming languages in haskell
18:34:55 <noonan> http://lpaste.net/141895
18:34:58 <Zekka> hunteriam: What's that about?
18:35:19 <hunteriam> Zekka: haskell being weird with arrays and its memory management makes things hard in this class
18:35:33 <Zekka> Yeah, but I mean, why are you taking this class in Haskell?
18:35:44 <hunteriam> Zekka: cause i like haskell a lot and my teacher was ok with it
18:35:52 <Zekka> I'd think your class would have been in a language that it was designed for, or else whatever language you want
18:35:55 <Zekka> Oh, sure, I get you
18:36:36 <hunteriam> Its just tough to try and write efficient algorithms in haskell (since the point of this class is efficiency)
18:36:59 <arkeet> you can pretend haskell is an imperative language
18:37:01 <athan> hunteriam: I strongly (typed) disagree
18:37:02 <arkeet> and do everything in IO (or ST)
18:37:09 <arkeet> and then it's not so bad
18:37:17 <hunteriam> athan: i know in practice its not but for this class its hard to show theyre efficient
18:37:21 <arkeet> but then you lose all the advantages of immutability
18:37:25 <hunteriam> arkeet: but then why even haskell
18:37:29 <arkeet> ask yourself :-)
18:37:33 <hunteriam> also whats ST?
18:37:34 <athan> hunteriam: graph algorithms are hard inductively :\
18:37:34 <boj> hunteriam: because you like it apparently
18:37:34 <noonan> and for completeness, here is how it looks if I comment out the makeLenses line: http://lpaste.net/141896
18:37:42 <athan> hunteriam: Are you familiar with monads?
18:37:49 <hunteriam> boj: i dont like it because i want to write imperatively though
18:37:57 <Cale> noonan: apparently  lipo -info /System/Library/Frameworks/QuickTime.framework/QuickTime  should tell you which architectures are in the installed library. You might need to install a QuickTime library for a different architecture.
18:38:01 <hunteriam> boj: i like it cause i minimally have to
18:38:06 <hunteriam> athan: yes
18:38:16 <athan> hunteriam: Do you know the `StateT` monad? or State?
18:38:24 <dmj`> hunteriam: state threads
18:38:27 <hunteriam> athan: yes ive used them before actually
18:38:29 <hunteriam> dmj`: thanks
18:38:32 <arkeet> ST is unrelated to State.
18:38:42 <athan> hunteriam: It gives you multiple state inputs (references)
18:38:45 <noonan> Cale: I think that's just a warning, though?  Or at least, I don't get why that has anything to do with using makeLenses.
18:38:49 <athan> instead of having 1 universal state object
18:39:15 <hunteriam> athan:  well its good to know about if i ever decide to use it
18:39:22 <athan> hunteriam: It's super performant
18:39:33 <arkeet> ST lets you have mutable references (and arrays etc)
18:39:41 <arkeet> and you can use it within pure (non-IO) code
18:40:00 <hunteriam> wow thats impressive
18:40:00 <Cale> noonan: It was the only error I saw in your paste :P
18:40:09 <dmj`> gives you mutability w/o sacrificing referential transparency
18:40:09 <hunteriam> how come i never heard about it when i initially learnt haskell a year or so ago?
18:40:18 <hunteriam> is it new?
18:40:21 <arkeet> it's not new.
18:40:34 <hunteriam> musta missed it
18:41:15 <dmj`> lambdabot @google lazy state threads
18:41:23 <hunteriam> Ah st is a neat idea
18:41:31 <Cale> It doesn't get used all that much because the cases where you really need it are pretty rare, and the additional type parameters which keep things safe can also be a minor source of frustration.
18:42:32 <athan> hunteriam: It's crazy, it's polymorphic in the threading mechanism, letting us directly use RealWorld, for instance, as the means to keep track
18:42:38 <cmccann> and the cause of a horrible special-case hack in GHC's type checker
18:42:41 <athan> instead of using `->` like State
18:42:55 <hunteriam> what does it mean to be polymorphic in the threading mechanism
18:43:00 <Cale> Uh
18:43:01 <hunteriam> theres a lot of talk in this conversation i dont understand
18:43:10 <hunteriam> i mean if its too much to explain i get it
18:43:16 <Cale> The s parameter doesn't usually get filled in with anything.
18:43:19 <hunteriam> ill just put it on the backburner for "haskell things i have to google"
18:43:49 <dmj`> hunteriam: what i wish I knew when learning haskell hits on a lot of these
18:44:01 <cmccann> Cale: I would say that it DOES get filled in with anything. filling it with anything rather than any specific something is the whole idea ;]
18:44:17 <dmj`> lambdabot should have a link to 'wiwikwlh'
18:44:25 <athan> Cale: Exactly!!! :D
18:44:29 <Cale> But there's an stToIO which forces the s to be RealWorld, not that it matters much.
18:44:38 <dmj`> hunteriam: http://dev.stephendiehl.com/hask/
18:45:18 <Cale> (It might as well have a type similar to that of runST)
18:45:52 <athan> Cale: the /compiler/ can choose, right? :s
18:46:08 <Cale> athan: The s is a phantom parameter anyway
18:46:21 <Cale> There are no values of type s anywhere
18:46:44 <athan> exactly!
18:46:52 <athan> but, it does keep the actions in-place, right?
18:47:00 <athan> ehh, nvm :\
18:47:46 <hunteriam> is there an elegant way in a map to insert 1 if the key does not exist and increment by 1 if it does
18:48:13 <dmj`> Cale: how do we get lambdabot to save things ? Like if I want the keyword @wiwikwlh to give a link, etc.
18:48:29 <Cale> uh, there's @where
18:48:47 <Cale> You can't invent new lambdabot commands without modifying the source code of lambdabot
18:48:57 <Cale> @help where
18:48:57 <lambdabot> where <key>. Return element associated with key
18:49:01 <Cale> @help where+
18:49:01 <lambdabot> where+ <key> <elem>. Define an association
18:49:18 <Cale> @where rwh
18:49:18 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:50:05 <dmj`> Cale: very cool, hrm
18:51:25 <Hijiri> hunteriam: does elegant include one of those general updatey combinators in map library
18:51:42 <hunteriam> Hijiri: elegant does indeed
18:51:56 <hunteriam> Hijiri: but none of them seem to quite do this update + default thing
18:51:58 <hunteriam> i want them to do
18:52:29 <Hijiri> you can do it with https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Map-Strict.html#v:alter
18:52:36 <pavonia> When Hackage reports a package being deprecated, where do you see what package to use instead?
18:52:36 <dmj`> hunteriam: insertWith
18:52:54 <Hijiri> oh, insertWith would do it
18:53:03 <dmj`> > M.insertWith (+) 1 1 $ M.fromList [(1,1)]
18:53:04 <lambdabot>  fromList [(1,2)]
18:53:16 <dmj`> > M.insertWith (+) 1 1 $ M.fromList [(2,2)]
18:53:17 <lambdabot>  fromList [(1,1),(2,2)]
18:54:29 <hunteriam> dmj`:  nice thanks
18:55:20 <hunteriam> import qualified Data.Map.Strict as MS
18:55:20 <hunteriam> newtype Composition = MS.Map Char Int
18:55:24 <hunteriam> whats wrong with this?
18:56:08 <pavonia> newtype need an extra constructor name
18:56:23 <dmj`> newtype Composition = Composition (MS.Map Char Int)
18:56:24 <hunteriam> oh thanks
18:57:13 <noonan> or you can use "type Composition = MS.Map Char Int" if you really just want the alias
18:58:42 <hunteriam> https://www.irccloud.com/pastebin/IH7ZAmtf/method
18:58:50 <hunteriam> Does anyone have any criticisms of this code?
18:58:57 <hunteriam> Is it suitably readable? Maybe inefficient?
18:59:15 <dmj`> hunteriam: your base case should come first, o/w it won't be called
18:59:32 <bbb_> athan: thanks for the help with linear algebra. you mentioned  `makeVector :: forall (n :: Nat). RawData -> Vector n`. is this in kmett's linear? i can't find it or figure out how to use toVector in Linear.Vector
18:59:35 <hunteriam> dmj`: it worked when i tested that... why is that?
18:59:55 <noonan> hunteriam: it's fine because the patterns (c:s) and [] don't overlap
19:00:23 <noonan> (i.e. a list is either of the form (c:s) or of [])
19:00:24 <hunteriam> ah right good then, this shoudl actually be more efficient right, since it doesnt check for [] first?
19:00:27 <dmj`> oh, if you had just 'cs' it wouldn't have
19:00:50 <noonan> good argument for the (c:cs) convention :)
19:00:59 <hunteriam> ah i see
19:01:07 <hunteriam> so itd be slightly more readable if i changed it to c:Cs
19:01:11 <hunteriam> c:cs*
19:08:12 <athan> Could someone explain the purpose and capacities of ContT concisely for me, in English and not Haskell? :)
19:08:22 <athan> I feel like it's something to do with modus ponens...
19:09:30 <athan> A continuation is like "I have the way to get to the answer, give me an input"? Like `Cont result input`, via `(input -> result) -> result`?
19:10:50 <Cale> athan: If you're going to relate it to logic, it's like double negation
19:11:20 <athan> Cale: !!!:O
19:11:23 <athan> thank you!!!!!
19:11:27 <Cale> Well, in the case that the result type is False
19:11:38 <Cale> Of course, it needn't be
19:12:15 <glguy> osa1: I am now
19:13:07 <athan> Cale: There's no use of an instance of `a` anywhere, to the arguments of `cont` and `runCont`
19:13:30 <athan> er wait I'm silly
19:14:19 * hackagebot wai 3.0.4.0 - Web Application Interface.  https://hackage.haskell.org/package/wai-3.0.4.0 (KazuYamamoto)
19:14:24 <athan> yeah sorry. Holy beans ContT is like a 2-stage Kleisli composition thing?
19:16:22 <hunteriam> Im trying to create a version of (-) that has type Int -> Int -> Maybe Int
19:16:25 <noonan> athan: you might find this interesting if you haven't seen it: https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence#Classical_logic_and_control_operators
19:16:28 <hunteriam> just by applying Just to the result
19:16:46 <hunteriam> Is there any elegant built-ins to help me?
19:16:48 <hunteriam> Are*
19:18:33 <noonan> hunteriam: depending on what you're planning on doing with it, there is probably a better way
19:19:20 * hackagebot hgrev 0.1.3 - Compile Mercurial (hg) version info into Haskell code  https://hackage.haskell.org/package/hgrev-0.1.3 (LukeHoersten)
19:19:22 <hunteriam> i dont think there is.. but im trying to use the differenceWith function for Data.Map, my map goes  to ints and i want to subtract for duplicate ints
19:19:24 <hunteriam> noonan: 
19:19:25 <cmccann> athan: a value (Cont r a) is just ((a -> r) -> r) and there's not really any composition going on, I'm not sure what you mean there
19:20:03 <arkeet> hunteriam: are you sure differenceWith is what you want
19:20:14 <arkeet> (think about what happens when a key exists in the second map but not the first)
19:20:34 <cmccann> athan: if you mean (Kleisli (Cont r) a b) that ends up equivalent to ((b -> r) -> (r -> a)) which composes directly, but "backwards"
19:20:43 <cmccann> er
19:20:51 <hunteriam> arkeet: oh thats upsetting.. I'm surprised its only 1-way like that
19:20:52 <cmccann> ((b -> r) -> (a -> r))
19:20:56 <cmccann> important difference there
19:21:42 <Cale> athan: One way of thinking about it is to regard a value of type  Cont r a  as a sort of device which can answer r-valued questions about a value of type a
19:23:11 <Cale> So for example,  Cont Bool a ~= (a -> Bool) -> Bool  is something which effectively provides Boolean-valued answers when given predicates on the type a. There may or may not be some value of type a such that it's actually answering truthfully about that given value.
19:24:17 <Cale> But obviously, given any value x of type a, we may construct a function (a -> Bool) -> Bool which just applies whatever question you give it to x, and hands you back the result
19:24:27 <Cale> That's what return does
19:25:37 <Cale> We could also make it always lie (\f -> not (f x))
19:30:00 <hunteriam> what is the name of the type that indexed sql tables use
19:32:02 <athan> Cale: Perfect :) Thank you
19:32:38 <athan> Next question, anyone here use WAI often? If so, ever seen anything like `respondForMe :: (Request -> Response) -> Application`?
19:33:36 <Cale> athan: I didn't really touch on how to interpret bind and callCC in that picture, but with a bunch of work, it's possible to interpret their definitions.
19:34:51 <lemevi> hi
19:34:56 <athan> @src callCC
19:34:56 <lambdabot> Source not found. stty: unknown mode: doofus
19:34:57 <Cale> hello!
19:35:12 <athan> @type callCC --?
19:35:14 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
19:35:29 <athan> @djinn ((a -> b) -> a) -> a
19:35:29 <lambdabot> -- f cannot be realized.
19:35:52 <athan> @info MonadCont
19:35:52 <lambdabot> MonadCont
19:35:56 <athan> :v
19:35:59 <Cale> @djinn ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
19:35:59 <lambdabot> f a b = a (\ c _ -> b c) b
19:36:00 <athan> thanks guys
19:36:05 <athan> :O
19:36:21 <athan> where `MonadCont` is forall. r?
19:36:26 <athan> er yeah <.<
19:36:34 <Cale> MonadCont is an abstraction over Cont-like monads
19:36:54 <Cale> You have to look at the instances to see how the operations get implemented
19:38:34 <athan> So it's completely ignoring the responding function
19:38:44 <athan> and just prepending the monadic data contravariantly?
19:38:52 <Cale> I don't know what you mean :)
19:39:54 <Cale> "prepending the monadic data contravariantly" is a lovely string of words, and while I know what they all mean individually, I have a hard time imagining what you're trying to convey
19:40:16 <cmccann> athan: fun exercise: implement the law of the excluded middle (Cont r (Either a (a -> r))
19:40:21 <cmccann> (without using djinn)
19:44:11 <tokik_> \quit
19:44:16 <tokik_> oops.
19:45:18 <athan> Cale: Look at it like this: (a -> (b -> r) ->r) -> (a -> r) -> r   --  given some application where I'm given some input and a heterogeneous responding function, I'm given another tool - a responding function for the input I /already/ have - thus, I have my result. NOW, given one of THOSE things, I have an application _waiting_ for a different heterogeneous input type, as the old input type is now the new responding function.
19:46:05 <athan> So I was actually wrong, because it completely ignores the old way to get to the result
19:47:33 <Cale> Yeah, when you call the continuation you've been given, it effectively aborts the rest of the computation you were doing.
19:48:23 <Cale> athan: In imperative languages, it's as if every procedure definition has been wrapped in callCC $ \k -> ... and when you write  return x  it's like executing  k x
19:49:06 <bitemyapp> cmccann: ooooh
19:49:11 <cmccann> bitemyapp: ?
19:49:40 <bitemyapp> cmccann: LEM
19:49:48 <cmccann> bitemyapp: ah right
19:49:58 <cmccann> it's a fun brainteaser imo
19:50:18 <cmccann> very simple in hindsight, but requires one particular nonobvious leap to solve it
19:52:11 <carrotlord> lemmings?
19:52:24 <carrotlord> > ["logic", "morals", "emotions"]
19:52:26 <lambdabot>  ["logic","morals","emotions"]
19:53:41 <hunteriam> Is there a class that enables me to write a filter function without specifying the structures data type?
19:53:52 <hunteriam> Traversable and Foldable are both inadequate
19:53:58 <athan> hunteriam: Check Witherable :)
19:53:58 <cmccann> mfilter?
19:54:09 <hunteriam> lol i cant believe thats a word
19:54:10 <cmccann> :t mfilter
19:54:11 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
19:55:24 <hunteriam> why does witherable have type level filters
19:55:28 <hunteriam> thats utterly terrifying
19:55:54 <athan> Okay, how about this one: Wouldn't `Foo r a b ~ a -> (b -> r) -> r` be something where `Foo r` is a ... co-bifunctor? `contrabimap :: (c -> a) -> (d -> b) -> (a -> (b -> r) -> r) -> (c -> (d -> r) -> r)` ?
19:56:07 <hunteriam> i dont even know what a co-bifunctor is
19:56:29 <athan> it has contrabimap :|
19:56:54 <athan> or bicontramap? syntax commutativity via homomorphisms >:O
19:56:55 <cmccann> athan: are you sure that would work
19:56:58 * athan welcome to haskell
19:57:06 <athan> cmccann:
19:57:07 <hunteriam> where did you learn these words
19:57:09 <hunteriam> what math class
19:57:17 <athan> @djinn (c -> a) -> (d -> b) -> (a -> (b -> r) -> r) -> (c -> (d -> r) -> r)
19:57:17 <lambdabot> -- f cannot be realized.
19:57:21 <athan> :o
19:57:30 <hunteriam> :o
19:57:43 <cmccann> athan: one type maps covariantly, the other maps contravariantly
19:57:44 <arkeet> @djinn (c -> a) -> (b -> d) -> (a -> (b -> r) -> r) -> (c -> (d -> r) -> r)
19:57:45 <lambdabot> f a b c d e = c (a d) (\ f -> e (b f))
19:57:50 <cmccann> just like a function
19:58:05 <arkeet> it's a profunctor.
19:58:18 <athan> arkeet: THANK YOU!
19:58:20 <athan> sweet
19:58:29 <athan> hunteriam: I've never colledged
19:58:45 <hunteriam> athan: are you past college age?
19:59:00 <athan> hunteriam: no :\
19:59:09 <hunteriam> athan:  wat are you at college age then?
19:59:14 <arkeet> what is college age?
19:59:17 <athan> It's a complex number
19:59:18 <hunteriam> 18-22
19:59:28 <athan> almost 24 ._.
19:59:49 <hunteriam> :info mfilter
19:59:55 <hunteriam> what module is mfilter in?
19:59:56 <athan> I just have obsessions
20:00:01 <hunteriam> i too, have obsessions
20:00:04 <athan> hunteriam: Should be in base
20:00:07 <athan> er
20:00:07 * cmccann notes that "Kleisli (ContT r f) a b" is equivalent to "(b -> f r) -> a -> f r" which looks worryingly lens-like
20:00:10 <athan> Control.Monad
20:00:18 <athan> @type Control.Monad.mfilter
20:00:19 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
20:00:19 <hunteriam> ty
20:00:22 <athan> :)
20:00:48 <athan> cmccann: How is it lensy?
20:00:53 <athan> because f ~ f?
20:00:58 <athan> and not different?
20:01:30 <nshepperd> LensLike f a r b r
20:01:42 <cmccann> athan: lens as in the lens library specifically
20:01:54 <athan> agh shoot sorry
20:01:56 <athan> thanks
20:02:11 <cmccann> where the lenses are shaped like (a -> f b) -> (s -> f t)
20:03:37 <hunteriam> does anyone have a document filled with random words
20:03:39 <hunteriam> but not too large
20:03:40 <cmccann> I'm always tempted to disambiguate by calling them "stab lenses" but I'm not sure that would result in net unconfusion
20:03:57 <hunteriam> or know where i could acquire one
20:04:05 <lemevi> if I want to map through a list first I just reverse it before giving it to map right
20:04:14 <hunteriam> why would you reverse it?
20:04:22 <lemevi> er
20:04:29 <Cale> cmccann: Continuation passing style lenses?
20:04:29 <lemevi> map through a list from the right to left
20:04:34 <lemevi> I left that part out
20:04:59 <hunteriam> Well that seems like it would work, unless the compiler deletes your reverse
20:05:05 <lemevi> why would it do that
20:05:15 <hunteriam> well if it was pure i dont see why it wouldnt
20:05:21 <hunteriam> but im assuming its not pure since order matters
20:05:23 <lemevi> pure?
20:05:29 <hunteriam> you know, like not effectful
20:05:39 <cmccann> Cale: I don't think that would unconfuse things enough either
20:05:49 <lemevi> ah yeah
20:05:51 <hunteriam> actually why would it delete it im dumb
20:06:00 <hunteriam> ignore me
20:06:50 <nshepperd> stab lenses actually have a name but I can't remember it
20:07:23 <cmccann> van Laarhoven lenses?
20:07:43 <Cale> yes, that's a reasonable name :)
20:07:47 <cmccann> I was under the impression the design had drifted a bit from his original concept so I'm not sure that still applies
20:07:56 <Cale> I'm not sure he invented the type-changing bit
20:07:59 <cmccann> but I guess that'd be the most "official" term
20:08:05 <Cale> and he also discussed the other sort of lenses
20:08:15 <cmccann> the basic shape of the composing-traversals thing was his though I think?
20:08:29 <Cale> I think it might've been Russell O'Connor who noticed that you could also change the type of the field
20:08:33 <nshepperd> oh, generalized van Laarhoven
20:08:34 <cmccann> that sounds plausible
20:08:41 <athan> arkeet: Would you happen to know the name of the `(a -> (b -> r) -> r)` profunctor?
20:08:42 <lispy> Someone on reddit has an application and they are looking for intermediate to expert level help making their API better: https://www.reddit.com/r/haskell/comments/3mpip2/hask_anything_the_thread_where_you_ask_and_we_try/cvhkkjq
20:08:43 <cmccann> I still call them stab lenses in my head though
20:09:35 <cmccann> lispy: I see you successfully summoned ezyang
20:09:53 <lispy> cmccann: thanks for telling me his id :)
20:09:54 <hiptobecubic> That's me.
20:09:57 <hiptobecubic> It's gross.
20:10:06 <cmccann> lispy: good thing I guessed that ezyang's reddit username was ezyang. ;]
20:10:46 <lispy> cmccann: I really should have guessed that, but I did a few google searches without success so then I was afraid to assume
20:10:58 <hiptobecubic> In fact, I was just looking at it again now and tried to play with it in GHCI, but the way the modules are split is borderline antagonistic. Looking forward to testing out haskell's fabled refactorability :)
20:11:11 <TallerGhostWalt> is there a Transposable typeclass for  more generic containers?
20:11:31 <cmccann> lispy: I just typed "www.reddit.com/user/ezyang" into the browser, saw all the comments were about Haskell, and declared success
20:11:42 <lispy> oh, right that makes sense
20:11:51 <athan> ToContT a r m b ~ a -> (b -> r) -> r
20:11:52 <athan> ?
20:12:00 <athan> er
20:12:02 <lispy> hiptobecubic: I'm glancing at it and nothing strikes me as terrible, TBH
20:12:05 <athan> ToContT a r m b ~ a -> (b -> m r) -> m r
20:12:15 <athan> making it a Profunctor :D
20:12:22 <athan> er
20:12:25 <athan> :|
20:12:29 <lispy> hiptobecubic: if the underlying API is stateful then you might be screwed (although, there are sometimes ways to improve it like opengl)
20:12:55 <hiptobecubic> What seems particularly wrong to me is the hodgepodge of transformers
20:13:04 <hunteriam> is there a base function for splitting on new lines?
20:13:08 <hunteriam> lines?
20:13:11 <hiptobecubic> Some things are StateT this and that, some are ExceptT, etc
20:13:21 <cmccann> > lines "foo\nbar\nbaz"
20:13:22 <lispy> hiptobecubic: sometimes it just takes some standing on your head to realize that you could run queries by interpreting queries in a nice little query language
20:13:22 <lambdabot>  ["foo","bar","baz"]
20:13:46 <cmccann> hunteriam: see also unlines to put newlines back in and words/unwords to do the same for whitespace in general
20:13:51 <hiptobecubic> lispy, interestingly enough, I think that's what i'm doing?
20:14:01 <hiptobecubic> see Client.hs
20:14:22 * hackagebot simple-pipe 0.0.0.29 - simple pipeline library like conduit  https://hackage.haskell.org/package/simple-pipe-0.0.0.29 (YoshikuniJujo)
20:14:27 <athan> Network.Wai.Application ~ ToContT ResponseRecieved IO Request Response
20:14:43 <lispy> hiptobecubic: cool. I don't use transformers enough to give good advice. That's why I was trying to pique the interest of others :)
20:14:53 <hunteriam> cmccann:  thanks
20:15:43 <lispy> hiptobecubic: if I were maintaining it, I might hide some of the transformers behind newtypes
20:16:17 <hunteriam> is Text or ByteString better for a huge text file
20:16:20 <lispy> hiptobecubic: you'll have a more boilerplate to write or derive, but it will make refactoring the underlying monad easier because fewer details about it will be exposed.
20:16:27 <arkeet> hunteriam: is it text, or is it bytes?
20:16:32 <hunteriam> its text
20:16:34 <lispy> hunteriam: ByteString is for binary data not textual data
20:16:38 <hunteriam> well thanks then
20:16:53 <hiptobecubic> lispy, i did end up making the Traduisons monad, which is in there somewhere
20:17:38 <lispy> hiptobecubic: once the monads are abstract, you can start to rephrase the primitives interms of the the DSL you've dreamed up
20:17:47 <lispy> (maybe you already do that?)
20:18:07 <lispy> at that point it will feel more like a language with a runtime than a bunch of plumbing to hide exceptions
20:18:22 <lispy> and I think that's the direction you want to head in?
20:18:31 <hiptobecubic> lispy, I do have a kind of mini language I use to control the application itself, which has been a pretty big success I think
20:18:49 <hiptobecubic> lispy, see here for example https://github.com/johntyree/traduisons-hs/blob/master/src/Traduisons/Client.hs#L59
20:19:04 <lispy> heh, that's what's on my screen already :)
20:19:06 <hiptobecubic> So I parse the input into some collection of commands and then run them
20:19:22 <lispy> It seems like you're on the right path
20:26:25 <hunteriam> i have 173,000 words i want to separate by new lines
20:26:33 <hunteriam> Data.Text.lines sends them to a list
20:26:38 <hunteriam> but this seems like too much data for a list
20:26:47 <hunteriam> am i wrong about that?
20:26:57 <noonan> is [1..] too much data for a list?
20:26:59 <lispy> If it makes the list lazily it can be okay
20:27:14 <hunteriam> im going to be operating over every element in this list
20:27:23 <hunteriam> so is there a better choice?
20:27:40 <hiptobecubic> it depends on the operation, but I think it will probably be fine
20:27:57 <hiptobecubic> 173000 is really not very many
20:28:18 <hunteriam> the operation is going to be like n^3 or n^4
20:28:19 <hiptobecubic> unless you're doing something very heavy with them or need to randomly index into them or something
20:28:29 <hunteriam> its probably heavy
20:28:33 <hiptobecubic> hunteriam, ok then :) Yes that's a problem.
20:28:43 <Cale> > [1..]
20:28:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
20:28:51 <Cale> ^^ it works fine
20:28:52 <hunteriam> ok, so what data structure should i use?
20:28:54 <noonan> :)
20:29:05 <noonan> what exactly are you going to do with it?
20:29:06 <hunteriam> wow lambdabot has infinite ram!!!!!!
20:29:08 <hiptobecubic> n^4 on 100,000 of anything is pretty much a non starter
20:29:23 <Cale> hunteriam: Lists are the ideal structure to iterate over in order
20:29:24 <hunteriam> :|
20:29:31 <hunteriam> Cale: order doesnt matter
20:29:36 <Cale> hunteriam: You can think of them as loops which are frozen in time
20:29:41 <Cale> The order of a list matters
20:29:48 <hunteriam> Cale: i meant for what im doing
20:29:57 <hunteriam> Cale: i dont care about order for this problem
20:30:07 <Cale> Yeah, so you need to decide if you're going to access the sequence of words randomly or now
20:30:08 <Cale> not*
20:30:13 <hiptobecubic> hunteriam, I would think very hard about whether or not what you're doing is the best way to achieve whatever it is
20:30:27 <Cale> If it's okay for them to be traversed in the order in which they appear in the file, then a list is perfect
20:30:37 <hunteriam> Cale: and fast?
20:30:39 <Cale> yes
20:30:43 <hunteriam> ok then were good
20:30:57 <Cale> Of course, String is not particularly fast, so you might want a list of Text instead
20:30:59 <hunteriam> thanks #haskell ill report back in 20 years when my computer finishes running this program
20:31:33 <hunteriam> Cale: well i do need to operate on every character of the list too
20:31:37 <hiptobecubic> hunteriam, the problem is not whether lists are fast. The problem is that you are talking about doing 10**20 operations on *anything*
20:31:54 <hunteriam> hiptobecubic: im not sure about that n^4 estimation... might be faster than that well see
20:32:09 <hiptobecubic> Let's hope so
20:32:27 <bitemyapp> hiptobecubic: I'm poking at your project.
20:32:33 <bitemyapp> hiptobecubic: I'm breaking stuff.
20:32:41 <hiptobecubic> hunteriam, even n^3 is 10^15 for you
20:32:46 <hunteriam> in this case... i have a list of a bunch of short strings
20:32:52 <hunteriam> so is text really even beneficial?
20:32:58 <hunteriam> im going to be looking at each character of the strings
20:33:23 <hiptobecubic> bitemyapp, it's pretty breakable I think. Also it's really frustrating to play with because of the initialization and all of the state wrapping that requires functions from all over the place
20:33:34 <bitemyapp> hiptobecubic: I'm not bothering to run it, only compile it.
20:34:25 <hiptobecubic> running it successfully requires a `SECRET` api token from microsoft to be able to get an auth token
20:34:36 <bitemyapp> hiptobecubic: that shit drives me nuts.
20:34:37 <hiptobecubic> So unless you already have one, i think that's fine :)
20:34:39 <hiptobecubic> yes
20:34:49 <bitemyapp> hiptobecubic: Twitter does the same fuckery and it makes it really annoying to experiment or learn with the Twitter API
20:35:03 <bitemyapp> hiptobecubic: unless you cache the auth token from the OAuth handshake, you have to do the tripod every-single-time
20:35:07 <bitemyapp> hate-hate-hate
20:35:08 <hiptobecubic> And the auth token expires every 5 minutes
20:35:19 <bitemyapp> I used to telnet to unauthenticated SMTP servers to learn how the internet worked
20:35:22 <bitemyapp> what the fuck is wrong with people
20:35:48 <hunteriam> is Text supposed to be not-foldable?
20:35:54 <hunteriam> or is it just kinda old?
20:36:01 <glguy> hunteriam: It has the wrong kind to be foldable
20:36:14 <hunteriam> interesting
20:36:18 <hunteriam> :k Text
20:36:19 <lambdabot> Not in scope: type constructor or class ‘Text’
20:36:22 <glguy> *
20:36:23 <bitemyapp> hunteriam: it's MonoFoldable
20:36:37 <bitemyapp> hunteriam: but it might not be the right time for that
20:36:51 <hunteriam> haha no not quite now
20:36:58 <bitemyapp> hunteriam: what you want is http://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text.html#g:10
20:37:24 <hiptobecubic> Yes I thought it had its own fold* functions
20:37:40 <hunteriam> too bad its not foldable
20:37:55 <hunteriam> that would make abstraction 2 times easier
20:37:58 <hiptobecubic> It doesn't really make sense for it to be foldable
20:38:04 <hunteriam> why not?
20:38:18 <hiptobecubic> because, as glguy said, it has the wrong kind
20:38:22 <Cale> hunteriam: Because the types of the Foldable operations would have to be really different
20:38:31 <Cale> :t foldMap
20:38:33 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
20:38:39 <hunteriam> because it onlyl supports folding over chars?
20:38:57 <Cale> Yeah, you'd need some way for that 'a' to magically be forced to Char
20:39:03 <ttt_fff> with parsec, is it possible to write my own error handler? (which dumps out stuff about input stream + user state + can be updated on the fly_)
20:39:20 <bitemyapp> hiptobecubic: PR'd.
20:39:20 <hunteriam> and its not possible for them to extract out the data structure containing the chars?
20:39:26 <hunteriam> and make that foldable?
20:39:32 <Cale> But foldMap is supposed to work with *any* a, and code might be written to work over arbitrary Foldables which uses 'a' which is not Char internally
20:40:02 <anohigisavay> hi. is it possible to write to the program's own stdin?
20:40:02 <hunteriam> By the way Cale, do you have any interest in representation theory?
20:40:24 <Cale> I've studied the basics of representation theory
20:41:08 <hunteriam> ok, just curious because my math class is starting to talk about it
20:41:19 <Cale> anohigisavay: I don't think that's possible
20:41:27 <hunteriam> excited to finally be in a class that vaguely talks about haskelly things
20:41:27 <hiptobecubic> bitemyapp, thanks :)   This brings up another point. It's really annoying that Github doesn't provide anyway to just comment on code as an Issue or something similar.
20:41:45 <anohigisavay> Cale:thanks :/
20:41:59 <Cale> anohigisavay: I could be wrong, but it doesn't seem easy
20:42:15 <nshepperd> data FoldText a where { FoldText :: Text -> FoldText Char }
20:42:29 <nshepperd> instance Foldable FoldText where ...
20:42:41 <Cale> anohigisavay: It's probably better to just restructure your program such that instead of using something like getLine, it instead uses an IO String which you pass in as an argument
20:43:18 <anohigisavay> Cale: yea that sounds good
20:44:56 <hiptobecubic> bitemyapp, oh fancy that. iso639 codes as a library. :)   I was debating whether or not I wanted to go through the trouble of writing them all out as a big sumtype
20:45:10 <hiptobecubic> Apparently I did want to do that.
20:46:59 <bitemyapp> hiptobecubic: there are disadvantages to the sum type
20:47:09 <bitemyapp> hiptobecubic: a sufficiently large sum type can be slow to compile
20:47:32 <bitemyapp> hiptobecubic: there's a third way
20:47:38 <bitemyapp> doesn't bear mentioning here.
20:48:15 <hiptobecubic> I saw an interesting trick in https://www.reddit.com/r/haskell/comments/3l3f1s/ann_googletranslate_written_w_servantclient/, but I haven't sat down to figure out just what is going on there
20:52:28 <hiptobecubic> bitemyapp, off for the night. Thanks again.
20:59:23 <athan> How can we expect `throwM` and `catch` to unify if `MonadCatch` and `MonadThrow` don't expose the error type?
21:01:37 <athan> I just feel like you would get runtime... compiler, errors :|
21:02:45 <nshepperd> isn't the error type 'Exception e => e'?
21:02:50 <bitemyapp> hipcheers
21:02:56 <johnw> they unify if the 'e's are ~
21:03:03 <bitemyapp> dang it tab complete.
21:03:26 <nshepperd> if you try to catch the wrong type with `catch` it just won't catch anything
21:06:23 <hunteriam> hey guys
21:06:29 <hunteriam> is it possible to sort Data.Map
21:06:35 <arkeet> what does that mean
21:06:40 <nshepperd> catch (throwM 7) (\() -> return 4) = throwM 7
21:06:43 <hunteriam> well i need to apply a specific sort to my map
21:06:50 <hunteriam> so that i can solve a problem on it in linear time
21:06:59 <johnw> hunteriam: so, maps are kept sorted by Ord on the keys
21:07:16 <hunteriam> I need to sort them with their values in mind
21:07:28 <johnw> you can do that to the values after removing them from the map
21:07:34 <johnw> but if they're in the map, they are sorted by the keys
21:07:44 <johnw> it's what Map is
21:07:44 <hunteriam> i need to sort the key value pair with values in mind
21:07:47 <hunteriam> ok
21:07:50 <hunteriam> so then i cant use a map?
21:07:56 <johnw> not for this particular task
21:08:05 <heatsink> You can make the values part of the keys
21:08:11 <johnw> yes, you can enrich your key
21:08:16 <athan> johnw: But can it tell at compile-time?
21:08:17 <johnw> even newtype wrap it to make your own Ord instance
21:08:26 <hunteriam> woah woah woah
21:08:28 <athan> nshepperd: Ahh! Thank you!
21:08:30 <hunteriam> hold on a sec
21:08:32 <hunteriam> how do i do that?
21:08:34 <hunteriam> enrich the key?
21:08:53 <athan> hunteriam: :|
21:08:57 <athan> :)*
21:09:08 <athan> use the hoogle
21:09:11 <johnw> newtype MyKey = MyKey (KeyType,ValueType)
21:09:12 <hunteriam> does this mean im just going to have a map like Map (k,v) v
21:09:15 <johnw> now make your own instance for MyKey
21:09:18 <johnw> yes
21:09:25 <hunteriam> well then whats the point of having it in a Map?
21:09:32 <johnw> oops, that has to be data, not newtype
21:09:35 <johnw> hunteriam: now we come full circle :)
21:09:44 <hunteriam> say i did that
21:09:46 <nshepperd> athan: Exception is a subclass of Typeable, so there's some dynamic type comparison going on behind the scenes
21:09:50 <hunteriam> sigh
21:09:54 <dmj`> johnw: data over newtype ay? 
21:09:54 <hunteriam> hm
21:09:57 <anohigisavay> https://bpaste.net/show/a2ca864738af
21:09:59 <johnw> dmj`: hahaha
21:10:04 <johnw> it was a momentary lapse of reason!
21:10:05 <hunteriam> maybe ill just move my map into a list
21:10:08 <nshepperd> athan: this is how we manage the whole 'open class exceptions' thing
21:10:12 <athan> nshepperd: Yeah, I had the feeling. That's pretty interesting. If an exception is uncaught, is it like bottom?
21:10:17 <athan> hm!
21:10:20 <dmj`> johnw: I came in at just the right time :) 
21:10:22 <hunteriam> is there really no map i can manually sort?
21:10:30 <johnw> so *that's* why it happened
21:10:34 <dmj`> johnw: hahaha
21:10:34 <shane> johnw: I have created the file with the probability distribution carrying its normalizer so that the >>= is more efficient. Would you like me to paste it?
21:10:43 <johnw> hunteriam: Maps use sorting as part of what they are, there is no making it manual
21:10:44 <dmj`> johnw: who makes that mistake
21:10:46 <anohigisavay> i don't really know how IORef works. I set the value at line 83 and it still keeps its original empty value
21:10:55 <heatsink> Why would you manually sort an automatically sorted data structure?
21:10:55 <johnw> shane: please!
21:11:09 <heatsink> Also, I'm not sure what "manual" means in this instance
21:11:10 <dmj`> anohigisavay: can you paste your code on lpaste.net?
21:11:25 <heatsink> print out the data on index cards so you can sort it with your hands?
21:11:41 <johnw> hunteriam: you can manually sort as association list
21:11:44 <johnw> s/as/an
21:12:09 <anohigisavay> http://lpaste.net/141910
21:12:17 <nshepperd> athan: an exception in a monad isn't really bottom, it has the semantics of mzero, I guess
21:12:21 <lpaste> shane pasted “Probability monad” at http://lpaste.net/141911
21:13:06 <nshepperd> athan: but indeed if it is never caught, it stop the program and write an error to the console, i presume
21:13:12 <shane> johnw: Although, I think that while this way will take care of the monad, it will become tough or impossible to make this into a functor
21:13:21 <johnw> shane: do you have a version of that that doesn't use the custom Dist stuff?  I want to see the "bones" of the problem
21:13:51 <johnw> if you have a Monad, you have a functor, just fmap = liftM
21:14:44 <athan> ahhhh, okay great. Thank you nshepperd
21:14:54 <lpaste> shane revised “markov test”: “Probability monad 2” at http://lpaste.net/141695
21:15:04 <dmj`> anohigisavay: ioGetLineRef is creating a new IORef (newIORef ""), and returning the value of it. So it's literally no different than return "" :: IO String
21:15:19 <johnw> ok, cool
21:15:21 <shane> johnw: this was what I was trying to achieve but without manually adding the force and norm'
21:15:29 <johnw> ok
21:15:31 <johnw> let me try
21:16:18 <anohigisavay> dmj` thanks
21:16:20 <dmj`> anohigisavay: you probably don't need an IORef for this example, I'd use the readLine function from Prelude
21:17:04 <anohigisavay> dmj` sorry will check it after lunch :D
21:17:06 <dmj`> anohigisavay: getLine here is just (return "")
21:17:10 <dmj`> anohigisavay: k
21:19:58 <nitrix> Apart from the concepts we had to develop around lazy evaluation to maintain purity (like Applicative, Monad), do you guys feel like lazyness' pros outweights the cons?
21:20:09 <johnw> I certainly do
21:20:21 <johnw> laziness is one of the things I love most about Haskell
21:21:07 <nitrix> I'm approaching the question very objectively. I'll admit the amount of articles that I'm reading are making a point about it being hard to reason about and, also, space leaks.
21:21:21 <johnw> space leaks just take experience
21:21:25 <nitrix> I suppose with more experience, these things are easily avoided?
21:21:31 <shane> nitrix: I do too after getting accustomed to it. I once tried to rewrite something I had written in Haskell in ML and i missed the advantages that laziness gave me so much, that I just gave up. 
21:21:46 <johnw> I prefer it if the hard things are hard, so long as all the simple things are simple.  Rather than making most of the simple things harder in order to make the hard things a bit less hard
21:21:49 <emmanuel_erc> Hello there!!
21:21:55 <levi> It's a trade-off; the benefits you get are typically taken for grated when people talk about the downsides.
21:22:15 <shane> nitrix: I am not sure how good I am at preventing space leaks, but I did find an improvement in myself when I took the time to understand the evaluation properly.
21:22:16 <heatsink> I usually want lazy evaluation in some situations and eager evaluation in other situations.
21:22:23 <johnw> also, it's a zero sum game: you're going to pay complexity costs somewhere.  To whine about where they are is ignoring the fact that the cost is always being paid.
21:22:45 <heatsink> So whichever is the default, I have to do some work to get the non-default evaluation strategy when I want it
21:22:48 <levi> Although some operational details get more difficult to reason about, other aspects of your program get easier to reason about.
21:22:53 <emmanuel_erc> Isn't better to at least have the flexibilty (lazy or eager evaluation) in a programming language? Why would anyone NOT want that?
21:22:54 <johnw> shane: https://gist.github.com/7d3aaaeceb2b001b2e63
21:22:59 <johnw> shane this run extremely fast for me
21:23:02 <nitrix> What would be the best ressource to figure out Weak Head Normal Form once and for all?
21:23:24 <johnw> WHNF is exposing the top most constructor, in Haskell terms
21:23:40 <shane> johnw: Thanks...looking at it!
21:24:11 <johnw> shane: all I did was type-wrap you a constantly normalizing Monad
21:24:25 * hackagebot composition 1.0.2 - Combinators for unorthodox function composition  https://hackage.haskell.org/package/composition-1.0.2 (DanBurton)
21:24:56 <shane> johnw: so T a b is the previous un-normalized distribution?
21:25:01 <johnw> yes
21:25:11 <johnw> T' only changes the semantics of >>=
21:26:43 <shane> Why is it that the compiler does not complain that norm only works when a is ordered?
21:27:01 <johnw> it imposes a constraint that we're satisfying
21:27:32 <johnw> oh, hmm
21:28:23 <johnw> i wonder if the constraint is check at point of use here, rather than at definition of >>=?
21:28:41 <emmanuel_erc> So, I have two questions. I've been told that functional programming languages have limits, in other words they can't solve all problems. But as I've been exploring Haskell, I have not encountered anything that strengthens that argument (quite the opposite). Is there any truth to the negative argument against Haskell?
21:28:52 <johnw> i mean, you can't have Monad for Set, because Set itself has the constraint
21:28:59 <johnw> but here the 'a' is not known until the user chooses it
21:29:06 <shane> johnw: In my case it does complain though.
21:29:15 <shane> johnw: when I tried it just now
21:29:24 <johnw> what GHC are you using?
21:29:29 <c_wraith> emmanuel_erc: functional languages are turing complete, so the argument has to be talking about something other than "ideas the language can express".  But I have no idea what.
21:29:47 <shane> john: 7.6.3
21:29:53 <johnw> oh, ancient stuff
21:29:56 <johnw> I'm using 7.10.2
21:29:59 <shane> johnw: oh!
21:30:11 <shane> johnw: And this code is working for you?
21:30:19 <johnw> yeah, I'm doing a profiling build even
21:30:26 <johnw> with a cabal file and everything :)
21:30:34 <shane> johnw: what is making the difference?
21:30:41 <emmanuel_erc> Thanks for the answer c_wraith.
21:30:42 <johnw> that could very well be it
21:31:15 <dmj`> emmanuel_erc: so those who told you fp languages had limits, did they mention what they were?
21:31:45 <levi> emmanuel_erc: There isn't anything that can't be (in theory) programmed in a functional language, though sometimes it requires building a model of some computational feature that an imperative language would have built in to its semantics.
21:31:49 <emmanuel_erc> A CS professor floated this comment by me at first, but I've heard such a comment, from others as well.
21:32:25 <emmanuel_erc> dmj`: They did not mention any inadequacies to me.
21:32:37 <dmj`> emmanuel_erc: I had a CS prof tell me "everyone who uses haskell cheats and uses unsafePerformIO" 
21:32:53 <c_wraith> emmanuel_erc: the only thing I can think of that's even close is that in a strict functional language, certain algorithms have an additional O(log n) factor.
21:33:09 <shane> johnw: on a related but slightly tangential note: why is it that monads are not defined using multi-parameter classes like this : class Monad2 m a b where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b? I am sure there is a very good reason for this, but if I do this, then with -XFlexibleinstances, i can add any constraint on a and b when defining the instance
21:33:16 <emmanuel_erc> what type of algorithms c_wraith?
21:33:23 <davean> c_wraith: I thought the actual theoretical worse case was worse then that
21:33:33 <johnw> shane: that would fix b throughout your monadic computation
21:33:46 <davean> c_wraith: Been ages since my comp. theory studies though
21:33:48 <c_wraith> emmanuel_erc: a common example is fisher-yates shuffle.
21:34:03 <johnw> shane: sorry, it would fix a and b in ways you wouldn't want
21:34:08 <johnw> not throughout
21:34:25 <c_wraith> davean: nah, you can always simulate mutable O(1) memory with a functional tree that has O(log n) updates
21:34:35 <shane> but I can define my list instance as instance [] a a where ... ?
21:34:44 <shane> will that cause this problem of fixing?
21:34:47 <johnw> like, one Monad2 m => m a b and another Monad2 m => m a' b', couldn't play together
21:34:49 <shane> because I tried it aand it worked
21:34:58 <johnw> that's probably because you're only using Int and Float
21:35:02 <levi> Plenty of operations that are O(1) within the range directly implementable via mutating operations on the store become O(log n) when you use a functional/persistent data structure.
21:35:16 <johnw> you're in a restricted universe where everything is constant around m, so it seems to all be happy
21:35:17 <shane> johnw: and strings too
21:35:32 <levi> Of course, those kinds of operations *also* become O(log n) when you scale them up beyond the scale where they're cheaply implemented in hardware.
21:35:41 <johnw> would you really want a different instance for every pair of types involved in >>=?
21:36:21 <c_wraith> shane: I went into some practical issues with an MPTC implementation of Functor here - https://stackoverflow.com/questions/29463811/any-advantage-of-using-type-constructors-in-type-classes/29471935#29471935
21:37:25 <shane> johnw: so why I ask is because, this seems to be closer to the ML module approach to monads which does not have that restricted monad difficulty and I was trying to understand why
21:37:36 <johnw> shane: that link from c_wraith is a great reason why :)
21:37:37 <shane> c_wraith: thanks!
21:37:44 <emmanuel_erc> Ok, well I suppose that settles my first question, my second question is perhaps a little more interesting? I've been reading about Continuation Style Passing recently. It seems very interesting; is there a connection between CPS and Comonads?
21:37:50 <davean> c_wraith: well, thats assuming a direct-access memory model
21:38:00 <davean> c_wraith: Where you don't pay for the garbage
21:38:09 <lamefun> What's the best way to create interfaces?
21:38:34 <johnw> lamefun: that depends
21:39:08 <c_wraith> davean: I think it holds true regardless of the model used, but the overhead is certainly higher in cases like those.
21:39:09 <johnw> plain old functions are good, records of functions, type classes, deeply embedded DSLs...
21:39:16 <lamefun> Well. I have no idea what I'm doing or why.
21:39:22 <johnw> ok, start there then :)
21:40:41 <c_wraith> davean: higher in absolute terms, that is.  I think the asymptotics don't change.
21:40:57 <jle`> i wonder if there's a way to abstract over functors in general in Haskell, and not just endofunctors on hask
21:41:15 <jle`> there probably is a way but it's probably not very useful
21:41:20 <c_wraith> jle`: it's hard for the haskell type system to work on functors over things that are not haskell types. :)
21:41:56 <c_wraith> jle`: on the other hand, if you mean working over subcategories of Hask..  Yes, it can be done.  I think there's even a library called..  subhask?
21:42:24 <c_wraith> There is a library called subhask, but I'm not sure it's the one I'm thinking of
21:43:09 <shane> johnw, c_wraith: just out of curiosity, am I right in assuming that this multi-parameter class approach is closer to the approach to monads mentioned here: https://existentialtype.wordpress.com/2011/05/01/of-course-ml-has-monads/ ?
21:43:19 <lamefun> I want some kind of a filesystem abstraction that would allow accessing different file systems (real, ZIP archives, etc.) with different naming conventions through the same interface.
21:43:32 <levi> emmanuel_erc: CPS is related to codensity monads
21:44:07 <shane> johnw, c_wraith: so the difficulties I face with this are the same as with the approach described on the website?
21:44:19 <johnw> shane: that looks like the Haskell approach
21:44:21 <levi> emmanuel_erc: This may go over your head (mostly goes over mine) but it points out some relationships: http://comonad.com/reader/2008/kan-extensions/
21:44:29 <johnw> 'a and 'b are not instantiated at some type, but are abstract
21:44:35 <emmanuel_erc> levi: I don't know what the latter term 'codensity monads' but I'll have to dive in at some point.
21:44:35 <johnw> only 'monad' is instantiated
21:45:45 <shane> johnw: I mean in the sense that a and b have no restrictions on them...when defining the structure, I could for instance have my first line as type a' monad = int option?
21:45:52 <levi> emmanuel_erc: They're CPS-transformed variants of monads that are more efficient due to not requiring re-traversal of already-traversed structure when they're joined.
21:46:10 <johnw> emmanuel_erc: similar to how a is equivalent to forall r. (a -> r) -> r, the monadic action m a is equivalent to forall r. (a -> m r) -> m r
21:46:18 <hunteriam> guys
21:46:26 <hunteriam> is there any way to actually do stuff with Data.Graphs
21:46:35 <hunteriam> it seems to be only capable of putting things into graphs
21:46:51 <Cale> Data.Graph is a little bit silly
21:47:04 <Cale> fgl is a bit better
21:47:14 <johnw> so, as a is to a CPS transformation, m a is to Codensity m a
21:47:25 <shachaf> ?
21:47:36 <Cale> For the most part when I need a graph data structure, I use something along the lines of  Map Vertex (Set Vertex)
21:47:46 <johnw> ah, the shachaf question mark, somewhere I have gone astray in my wording
21:47:51 <johnw> shachaf: please correct?
21:47:53 <hunteriam> Cale: i dont want to have to write topological sort myself
21:47:57 <hunteriam> and Data.Graph does it for you
21:48:02 <__uu___> is CPS hard?
21:48:11 <emmanuel_erc> That's interesting. I had mentioned in the chat a couple of days ago about using comonads for a small problem I had. I eventually got a simple implementation working, but I am still curious if comonads could work (or why they don't).
21:48:14 <shachaf> If I thought there was a correct thing to say, I would say it.
21:48:20 <shachaf> Question mark means I don't understand.
21:48:23 <johnw> ah
21:48:25 <Cale> Right, if you want that sort of thing, then consider using fgl
21:48:37 <johnw> huh, I usually get it wrong when I see the ?, so I had assumed
21:48:53 <Cale> Or just use Data.Graph and turn your graph into that silly array type when you need to do the topsort :P
21:48:55 <shachaf> Oh, I read some context and now I see.
21:48:57 <hunteriam> Cale: thanks! although it seems rather hard to get started with
21:49:05 <hunteriam> Cale: Data.Graph has built in topsort
21:49:09 <Cale> Yeah, the names of things in fgl are really dumb
21:49:31 <shachaf> (forall r. (a -> r) -> r) is isomorphic to a. (forall r. (a -> m r) -> m r) is not isomorphic to m a.
21:49:34 <levi> __uu___: What do you mean when you ask if CPS is hard?  Hard in what way?
21:49:58 <Cale> http://hackage.haskell.org/package/fgl-5.5.2.3/docs/Data-Graph-Inductive-Query-DFS.html#v:topsort
21:50:08 <__uu___> hard to automate
21:50:25 <shane> johnw, c_wraith: According to that stackoveflow link Oleg Kiselyov has used multi-parameter classes to define unrestricted monads...although a comment there says that ConstraintKinds offers a more straightforward approach
21:50:37 <__uu___> when write code in one style to automatically change to the other
21:50:43 <hunteriam> Cale: im in a situation where I dont know the links to a given node (wihtout a lot of extra work) only the links from a node, and it seems like FGL only supports building graphs if you know both
21:50:46 <hunteriam> am i wrong about that?
21:50:53 <levi> Speaking of Oleg, this paper talks about CPS in relation to monads: http://okmij.org/ftp/Haskell/zseq.pdf
21:51:09 <johnw> shachaf: https://gist.github.com/e4dbfbe2e34ce0ac73d9?
21:51:35 <Cale> hunteriam: You don't have to use buildGr
21:52:18 <Cale> hunteriam: In fact, you can just use mkGraph :: [LNode a] -> [LEdge b] -> gr a b
21:52:21 <emmanuel_erc> (continuing what I was saying earlier) <- I wanted to compute the collection of distances between n points, but do it in such a manner that I only compute (n(n-1))/2 of the distances and ask for the desired quantities later (if that was stated clearly).
21:52:28 <johnw> shane: ok, there may be some interesting thoughts down that road then
21:52:28 <shachaf> That's not an isomorphism.
21:52:39 <Cale> hunteriam: You only have to provide the edges once
21:52:52 <levi> __uu___: It was the standard intermediate representation in optimizing compilers for functional languages for many years, so it's pretty well-known how to automate it.
21:52:53 <shachaf> In paticular to . from isn't necessarily id
21:53:08 <Cale> hunteriam: It is unfortunate that there isn't just a topsort which is abstracted over the operation which determines adjacency
21:53:10 <hunteriam> Cale:  thats very neat. Does it support directed graphs though? LEdge appears to be undirected
21:53:17 <shane> johnw: this seems to be interesting https://jeltsch.wordpress.com/2013/02/14/the-constraint-kind/
21:53:23 <Cale> LEdge is directed
21:53:24 <levi> Appel's book "Compiling with Continuations" talks about it in great detail.
21:53:49 <__uu___> levi: thanks
21:53:52 <shane> johnw: at least the definition of the restricted monad there seems very clean and so does the instance declaration
21:53:59 <hunteriam> Cale: great, thanks. And thats true, its strange theres no abstracted top sort
21:54:09 <Cale> one might exist on hackage
21:54:12 <shachaf> Codensity is an important monad, though.
21:54:17 <Cale> I did an abstract A*
21:55:03 <arkeet> johnw: isn't that ContT?
21:55:12 <Cale> http://hackage.haskell.org/package/astar-0.2.1/docs/Data-Graph-AStar.html -- it doesn't care how you represent your graph, as long as you provide the operations to query it
21:55:20 <arkeet> oh wait there's the forall
21:55:28 <johnw> shachaf is right
21:55:46 <johnw> to . from is a mismatch the forall r
21:55:54 <shachaf> arkeet: It is CodensiT.
21:56:04 <shachaf> Mismatch?
21:56:20 <johnw> (forall r. (a -> m r) -> m r) vs. ((a -> m r) -> m r)
21:56:35 <arkeet> ???
21:56:36 <hunteriam> Cale: for fgl, how should i pick the Ints for my edges and my nodes?
21:56:38 <arkeet> there's an implicit forall
21:56:46 <shachaf> No, there's an implicit forall.
21:56:53 <johnw> that's what the type error said, I'm digging further
21:56:53 <erisco> say you are implementing an eDSL and you want to restrict valid types… add :: (Numeric a) ⇒ Expression (a → a → a)  perhaps and  class Numeric a; instance Numeric Int; instance Numeric Float
21:57:00 <Cale> hunteriam: Good question. Any way that picks a unique Int for each vertex will work.
21:57:01 <erisco> the problem is that anyone can add an instance any time
21:57:10 <erisco> what alternative could you use that is closed?
21:57:14 <hunteriam> Cale: thats more challening than it should me
21:57:14 <shachaf> All Haskell types have an implicit forall in front of them.
21:57:15 <Cale> hunteriam: But sometimes it's annoying :/
21:57:16 <hunteriam> should be
21:57:18 <Cale> yeah
21:57:32 <hunteriam> If its not unique what happens?
21:57:35 <shachaf> Instead of bothering with rank-n types, compare DList a and [a]
21:57:47 <hunteriam> guess that ruins the edges
21:58:37 <Cale> hunteriam: Yeah, if it's not unique, then you've identified the vertices with each other
21:58:58 <Cale> hunteriam: It doesn't matter which Int values you use, just that each Int value you do use corresponds to one vertex
21:59:04 <hunteriam> Cale: how long does it take to calculate length in haskell?
21:59:09 <hunteriam> its not O(n) is it?
21:59:21 <Cale> For which data structure? For lists it's necessarily O(n)
21:59:37 <hunteriam> yea for lists
21:59:40 <Cale> You can't determine how long a list is without walking down it.
21:59:44 <Cale> It might be infinite.
21:59:47 <hunteriam> i was thinking of just labeling the node based on how far into the list we are
21:59:48 <johnw> shachaf: but with the type wrapper it is an isomorphism, because this handles the forall?
21:59:52 <hunteriam> thats fair
22:00:02 <shachaf> No. The forall is a red herring.
22:00:13 <shachaf> It's not an isomorphism because the types are different.
22:00:39 <arkeet> don't you mean it's not not an isomorphism because the types are different.
22:01:06 <erisco> shoot where is sinelaw... he'd know
22:01:10 <Cale> hunteriam: What you can do is to write something like zip [0..] xs
22:01:19 <shachaf> It definitely *is* not an isomorphism.
22:01:29 <hunteriam> cale ah nice
22:01:31 <arkeet> what are we talking about exactly?
22:01:36 <shachaf> But by "different" I meant "not isomorphic", not "not equal".
22:01:53 <johnw> shachaf: the forall r's are always different types
22:02:13 <johnw> is that it?
22:02:20 <shachaf> The type "m a" and the type "forall r. (a -> m r) -> m r" are not in general isomorphic for a monad m.
22:02:25 <shachaf> The forall is still a red herring.
22:02:27 <erisco> you could use a reflexive closed type family, I guess
22:02:31 <shachaf> It's the same situation as DList a vs. [a]
22:02:47 <johnw> i'm not sure which types you mean then
22:03:12 <johnw> are you saying DList a and [a] are not isomorphic?
22:03:25 <awpr> shachaf: (an informative thing to point out is that Codensity IO a can wrap the continuation in 'bracket')
22:03:43 <awpr> which a plain IO a can't
22:03:49 <shachaf> awpr: I think IO is a very complicated example to use here! I don't even know what IO can and can't do.
22:04:14 <shachaf> If you want a simple example, maybe use Codensity (e ->), which is easy to show to be State e.
22:04:24 <awpr> well, in general Codensity m a can use <* to do a bunch of stuff "after" the continuation
22:04:27 <arkeet> johnw: indeed they are not isomorphic.
22:04:27 <awpr> which m a can't
22:04:28 <shachaf> Instead of DList a maybe I should say Endo [a].
22:04:38 <arkeet> yeah.
22:07:29 <hunteriam> Cale: this is actually a really tough interface to work with.. ive got a piece of data and a list of all the data it links to, and i have to go back into my graph and find the numbers for all that data
22:07:44 <hunteriam> Is this what i have to do?
22:09:58 <johnw> shachaf: ok, excellent point, thank you for popping in!
22:10:04 <erisco> the easier solution is just to duplicate the definitions for each type
22:10:22 <erisco> good ol' addi, addf, feels like C :D
22:10:23 <johnw> from the dlist issue tracker: "DList a is isomorphic to [a] via fromList/toList, but [a] -> [a] is not isomorphic to [a]."
22:10:54 <arkeet> only because the DList constructor is hidden.
22:11:06 <shane> johnw: the solution using ConstrainedKinds worked for the probabilty monad :) I do not understand the internal details completely, but I was using it as a blackbox after seeing the example in this page: https://jeltsch.wordpress.com/2013/02/14/the-constraint-kind/
22:11:07 <awpr> fromList . toList isn't the same as id -- it loses internal structure
22:11:19 <shane> johnw: I can paste the code if you want
22:11:24 <johnw> shane: sure
22:11:29 <awpr> er, that and DList won't shuffle your argument list's elements
22:12:09 <shachaf> There are a lot of things DList won't do.
22:12:13 <johnw> shachaf: the ((->) e) and State e comment was very clear too
22:12:30 <lpaste> shane pasted “Probability monad with constraint kinds” at http://lpaste.net/141914
22:14:34 <johnw> hah, edwardk said the very same thing in Jan 2013
22:15:05 <shane> johnw: the solution is quite clean and I have been able to add two constraints: Ord and NFData using constraint synonyms. It means I cannot use the standard monads, but I am sure thereis a library somewhere with these monads. Also it has a default empty constraint.
22:15:35 <johnw> 2013-01-12 03:37:45 +0100	<edwardk> 	Codensity ((->) e) = forall r. (a -> e -> r) -> e -> r ~ e -> (a, e) ~ State e
22:15:44 <shachaf> Sounds plausible.
22:15:55 <johnw> anyway, glad you brought it up
22:17:13 <awpr> :t runCodensity (,)
22:17:15 <lambdabot>     Not in scope: ‘runCodensity’
22:17:15 <lambdabot>     Perhaps you meant ‘runIdentity’ (imported from Control.Monad.Identity)
22:21:58 <bollu> :t ruCodensity
22:21:59 <lambdabot>     Not in scope: ‘ruCodensity’
22:22:00 <lambdabot>     Perhaps you meant ‘runIdentity’ (imported from Control.Monad.Identity)
22:22:18 <bollu> what's "runCodensity" ?
22:22:57 <awpr> unwraps the newtype wrapper "newtype Codensity m a = Codensity { runCodensity :: forall r. (a -> m r) -> m r }"
22:23:13 <awpr> https://hackage.haskell.org/package/kan-extensions-4.2.3/docs/Control-Monad-Codensity.html
22:23:44 <bollu> awpr: can't I take the forall r. out?
22:23:53 <bollu> I always muck up my forall's
22:24:18 <bollu> oh, it isn't part of the Codensity type
22:24:20 <bollu> gotch
22:24:23 <bollu> gotcha*
22:24:25 <shachaf> If you always muck them up, it probably means you should sit down and understand what they do rather than applying approximate heuristics.
22:24:27 <bollu> what's it encoding?
22:24:49 <shachaf> It's worth doing that.
22:25:10 <awpr> you can take the forall out, but then GHC will be eager to instantiate it.  then you have "newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }" and "forall r. ContT r m a"
22:25:20 <bollu> shachaf: that's fair :) But I've seen multiple uses of them (as a "type annotation", as a "let's not be vague and forall everything", as "encapsulate information - I want to know know nothing more about the type")
22:25:47 <awpr> bollu: it's explicitly saying the Codensity is not allowed to be (const (x :: r)) for some x
22:25:48 <shachaf> For the most part (with some small exceptions) forall always means the same thing.
22:26:26 <awpr> or even to change the result of the (a -> m r) in any way
22:26:32 <shachaf> The main thing to know about Codensity is probably that (>>=) :: Monad m => m a -> Codensity m a
22:27:06 <shachaf> Similarly, (++) :: [a] -> DList a
22:27:10 <dfeuer> forall gets more consistent if you use GADT syntax instead of old-school existential syntax for your existentials.
22:27:33 <johnw> omitting the type wrapper, but that's very cool, hadn't see that correspondence before
22:27:52 <bollu> awpr: what's the motivation for it?
22:27:59 <bollu> awpr: like, example use-case?
22:28:33 <dfeuer> bollu, Codensity is about reassociating >>= for efficiency, generally, as I understand it.
22:28:44 <shachaf> If you say that "m a" is isomorphic to "Codensity m a", you're saying that every value :: Codensity m a is of the form (m >>=)
22:29:00 <johnw> bollu: http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
22:29:24 <hunteriam> guys i need to find the longest path in a graph
22:29:40 <hunteriam> and the idea of implementing top sort and depth first search intimidates me
22:29:52 <hunteriam> is there any library that already does this?
22:29:54 <shachaf> If you say that "[a]" is isomorphic to "DList a", you're saying that every value :: DList a is of the form (xs ++)
22:30:14 <dfeuer> So if you have   (a >>= f) >>= g, and the Monad in question is slow associated that way, you can use Codensity to put the pieces together and then convert all together to the base monad.
22:30:17 <dfeuer> Or something like that.
22:31:04 <johnw> shachaf: even clearer yet
22:33:42 * awpr goes to write DNat for efficient sums of Nats.
22:33:53 <johnw> awpr: do it for monoids in general
22:34:48 <awpr> my understanding is the technique has gains for things where appending means replacing some Nil-like constructor with the append-ee, which isn't necessarily the case for all monoids
22:35:22 <awpr> e.g. Sequence I don't think could have a useful difference-type thing
22:35:43 <shachaf> What it does is right-associate your multiplication.
22:36:29 <awpr> ah, yes, by analogy to Codensity.  so every constructor is visited exactly once
22:37:16 <awpr> instead of k times when they're hidden under k left-associated appends
22:39:48 <johnw> I've linked to this maybe too often, but http://arxiv.org/abs/1406.4823: "We show how the Cayley representation of monoids unifies two different known optimisations, namely difference lists and the codensity monad transformation. The similarity between these two optimisations has been noticed before, but now we make the relation precise and demonstrate that they are two instances of the same change of representation."
22:41:24 <bollu> johnw: which one is the cayley repr? with the generators and the relations to I ?
22:41:25 <shachaf> It's pretty easy to make the relation precise. Codensity (Writer w) ~~ Writer (DMonoid w)
22:41:39 <johnw> bollu: the paper explains much better than I
22:42:55 <bollu> ah, you're exploiting Cayley's theorem
22:43:03 <shachaf> At least in one sense.
22:43:38 <bollu> shachaf: well, they're weakening group to monoid, but the idea is the same, I think?
22:44:48 <johnw> bollu: "The representation theorem does not really use the inverse operation of groups so one can generalise the representation to monoids, yielding a Cayley representation theorem for monoids (Jacobson, 2009)."
22:45:18 <shachaf> bollu: I wasn't responding to you. But that seems to be the idea.
22:47:47 <bollu> johnw: yep :)
22:47:58 <bollu> thanks
22:53:14 <xpilot> hello
22:53:21 <xpilot> I believe cpphs is misbehaving
22:53:21 <johnw> hi
22:54:00 <bollu> :t Fix
22:54:01 <lambdabot> f (Fix f) -> Fix f
22:54:20 <xpilot> namely, my source file compiles if I cpphs it first
22:54:28 <bollu> newtype Fix f = Fix (f (Fix f)) ? or did I get it wrong?
22:54:35 <xpilot> but gives errors otherwise
22:55:37 <johnw> bollu: that is right
22:56:07 <johnw> xpilot: I'm not familiar with cpphs
22:56:14 <bollu> johnw: thanks :) was just sanity checking myself after a good night's terrible sleep :P
22:56:18 <athan> :t otherwise
22:56:20 <lambdabot> Bool
22:56:23 <athan> lawl
22:56:30 <xpilot> otherwise = True
22:56:32 <jle`> > otherwise
22:56:35 <lambdabot>  True
22:56:39 <jle`> deep
22:56:41 <athan> xD
23:09:25 <anohigisavay> hi. i tried playing with some basic concurrency with haskell.
23:09:30 * hackagebot warp 3.1.4 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.4 (KazuYamamoto)
23:09:55 <awpr> ^ ooh that'll be the HTTP2Application support
23:10:03 <anohigisavay> like forkIO $ do putStrLn "GG" >> putStrLn "HH"
23:10:20 <anohigisavay> somethings the result turns out to be "GGH\nH"
23:10:31 <anohigisavay> most of the time it's "GG\nHH"
23:10:56 <arkeet> are you sure that's your exact code? (the two putStrLns run in the same thread there)
23:10:58 <bollu> johnw: how much cat theory do I need for the lpaper?
23:11:06 <anohigisavay> arkeet: let me paste my code
23:11:28 <awpr> (but, in putStrLn each character is its own write, so they can interleave if they're concurrent)
23:11:32 <johnw> bollu: you mean, that last one that I linked?
23:11:37 <anohigisavay> http://lpaste.net/141915
23:11:39 <jle`> you might be doing (forkIO (putStrLn "GG")) >> putStrLn "HH"
23:11:43 <bollu> johnw: yep, the monoids
23:11:48 <arkeet> okay, that's different.
23:11:56 <arkeet> and this is to be expected
23:12:00 <jle`> anohigisavay: yeah, you're doing what i wrote
23:12:06 <arkeet> putStrLn isn't atomic
23:12:11 <arkeet> so writes from the two threads may be interleaved
23:12:23 <jle`> you're forking `putStrLn "GG"` to a separate thread, adn running `putStrLn "HH"` on the main thread
23:12:26 <johnw> bollu: some, but not even a lot
23:12:39 <jle`> so those two will be happening at the same time...what character comes when is not deterministic
23:12:40 <anohigisavay> how can i make atomic putStrLn then?
23:12:53 <arkeet> you will need to synchronize the two threads somehow.
23:12:58 <jle`> sounds like an XY problem
23:12:59 <awpr> anohigisavay: this is kind-of a hack, but you can ByteString.putStrLn $ pack str
23:13:12 <arkeet> jle`: he's just playing.
23:13:19 <jle`> ah yeah
23:13:30 <awpr> since a strict bytestring is effectively a buffer and gets written in one syscall (I don't think that's guaranteed)
23:13:37 <arkeet> anohigisavay: MVar is one way to do so
23:13:53 <arkeet> MVar () gives you a mutex
23:14:20 <anohigisavay> arkeet: i see.
23:15:00 <awpr> anohigisavay: you can do more interesting things like having one stdout thread that pulls text off a queue
23:15:18 <lpaste> arkeet annotated “Basic forkIO” with “Basic forkIO (annotation)” at http://lpaste.net/141915#a141916
23:15:21 <arkeet> this is what I mean
23:15:22 <jle`> do mx <- newMVar (); forkIO $ withMVar mx (\_ -> putStrLn "GG"); withMVar mx (\_ -> putStrLn "HH") -- would be an mutex-based way
23:15:34 <awpr> (which is a lot like what Warp does for each HTTP/2 connection)
23:15:45 <arkeet> oh yes I should have used withMVar.
23:15:59 <arkeet> no wait.
23:16:15 <arkeet> yes.
23:16:18 <arkeet> sorry.
23:16:36 <arkeet> (my thing might break if something throws an exception)
23:16:37 <anohigisavay> xD yea i think i got the idea
23:16:47 <jle`> i mean, if they're just playing, they don't have to worry about exceptions
23:16:54 <arkeet> yeah.
23:16:55 <jle`> but it might be nice to play around with the API for MVars
23:16:58 <jle`> and see different methods
23:17:20 <jle`> (just for exposure's sake)
23:17:20 <anohigisavay> thank you guys :)
23:17:29 <anohigisavay> helped me a lot
23:17:48 <jle`> i also probably used $ incorrectly 
23:17:57 <arkeet> jle`: nope
23:17:59 <arkeet> it works.
23:18:11 <jle`> really?  i would think that it complains it's missing a "do" before withMVar
23:18:15 <jle`> haskell syntax is weird :|
23:18:24 <jle`> oh i guess ($) is just a normal operator
23:18:27 <arkeet> correct
23:18:29 <jle`> so the ; means it's just a line break
23:18:52 <arkeet> I *think* it would work even with a lambda or so?
23:18:54 <arkeet> syntactically
23:27:02 <youngthugger> Does anyone have any suggestions of good Haskell projects to read that wouldn't be too hard to understand for a beginner
23:28:38 <jewel> I have several data constructors for the same type that I would like to store as a set using a Data.Map. What should I use as the key for the map?
23:31:13 <jle`> jewel: maybe make a sum type?
23:31:31 <jle`> data AllKeys = FirstKey KeyType1 | SecondKey KeyType2 | ...
23:34:33 <frerich> sp
23:34:42 <frerich> ergs, sorry. I need focus-follows-mind.
23:41:11 <Lokathor> we all do
23:44:23 <zomg> frerich: I'm surprised nobody has yet used an eye tracker to focus windows =)
23:45:48 <lamefun> Should I use records or existential classes to make interfaces?
23:46:02 <lamefun> * classes + existential types
23:46:38 <Cale> Ordinary records to start with
23:46:52 <frerich> lamefun: I'd certainly start out with plain records, they go a long way.
23:46:55 <Cale> I mean, unless you're definitely going to get use out of the type class
23:47:38 <Cale> There isn't much point in introducing a type class for the sole purpose of making existential types over it.
23:50:38 <Cale> Note that you can carry around data of an arbitrary type which doesn't necessarily appear in the types of the fields of your record, if it occurs as parameters to a function which constructs the record, and you use them in the definition of the fields.
23:51:34 <liste> Cale could you give a code example of that?
23:51:37 <Cale> sure
23:52:14 <Cale> Consider something like:
23:52:31 <Cale> data StateOps s m = SO { get :: m s, put :: s -> m () }
23:52:35 <lamefun> Uhm.
23:53:09 <Cale> maybe that should be m s
23:53:16 <Cale> data StateOps m s = SO { get :: m s, put :: s -> m () }
23:53:21 <Cale> yeah, I like that better
23:53:22 <Cale> now
23:53:46 <Cale> mkIORefStateOps :: IORef a -> StateOps IO a
23:54:07 <Cale> mkIORefStateOps r = SO { get = readIORef r, put = writeIORef r }
23:54:23 <Cale> We don't have a field for carrying r around, but it effectively gets carried around
23:54:26 <lamefun> What if I have many interfaces (eg. ReadableFile, WritableFile, LockableFile, etc.), eg. I have OSFile type that implements all of them, ZIPFile that implements ReadableFile and WritableFile, URLFile that implements only ReadableFile, I'll have to carry around 3 object that represent the facets of all of them.
23:54:29 <Cale> Or for a more pure example
23:55:10 <lamefun> Like openFile :: FilePath -> (BasicFileFunctions, ReadFunctions, WriteFunctions, LockFunctions).
23:55:21 <Cale> data Counter = C { incrementBy :: Integer -> Counter, display :: Counter -> String }
23:55:53 <Cale> integerCounter n = C { incrementBy = \k -> integerCounter (n+k), display = show n }
23:56:31 <Cale> starCounter str = C { incrementBy = \k -> replicate k '*' ++ str, display = str }
23:57:09 <liste> lamefun do you usually need all the facets or just a few?
23:57:09 <Cale> lamefun: Sure, you might want to define a further datatype which captures all the things you get.
23:57:48 <Cale> lamefun: Or just a way to transform records of more basic operations into records of more sophisticated ones
23:58:00 <Cale> Depending on what's possible
23:58:56 <Cale> Now, you may also want to build a type class over the data structures which carry around your implementations, specifying how to pull out any given operation.
23:59:11 <Cale> But that's fancier, and you usually don't really *need* it
23:59:59 <Cale> With openFile, it's hard to imagine how you're going to do that one as a type class. You can't produce a new data type to represent the open file along with an instance at runtime.
