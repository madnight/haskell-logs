00:04:24 <liste> aoeuaoeu I may miss something, but you don't seem to be handling grateful connection close
00:04:31 <liste> graceful*
00:05:35 <aoeuaoeu> liste: Is there a generic close function? Because there's no close function in the websockets lib
00:05:52 <aoeuaoeu> and there are no examples with it
00:06:26 <aoeuaoeu> See for example: https://github.com/jaspervdj/websockets/blob/master/example/server.lhs
00:06:48 <aoeuaoeu> doesn't catch any CloseRequest exception - just removes the connection from state
00:07:46 <liste> not very familiar with websockets, but sometimes receiving an empty message means that the connection is closed
00:07:49 <suppi> is there a recommended library for handling cli arguments?
00:08:11 <KaneTW> aoeuaoeu: do you have large memory usage
00:08:17 <liste> suppi optparse-applicative (:
00:08:20 <KaneTW> suppi: not as far as i know, pick whatever you like most
00:08:27 <suppi> liste, thanks :)
00:08:31 <liste> but yeah, listen to KaneTW
00:08:31 <kadoban> suppi: ^ optparse-applicative is great
00:08:39 <liste> do your research, then pick one
00:08:43 <suppi> thank you all :D
00:09:08 <aoeuaoeu> There is a CloseRequest exception which is encountered when the socket is closed: https://hackage.haskell.org/package/websockets-0.9.5.0/docs/src/Network-WebSockets-Types.html#ConnectionException
00:09:32 <aoeuaoeu> KaneTW: no, ~2.8MB not going anywhere
00:13:28 * hackagebot freer 0.2.2.1 - Implementation of the Freer Monad  https://hackage.haskell.org/package/freer-0.2.2.1 (alcabrera)
00:14:14 <KaneTW> profile i guess
00:14:29 <suppi> Also, what is the recommended way to read bytestrings from a file? ByteString.readFile?
00:15:11 <Hijiri> to just get the whole thing in memory?
00:15:28 <Hijiri> if you are expecting large files it might be better to read it by pieces
00:15:35 <Hijiri> or use a streaming library if it is complicated
00:15:59 <roelof> hello, how can I rewrite this : prop_howManyAboveAverage_two_input x  y = (if (x > y) && (x /= y) then 2 else if (x /= y) then 1)  == (howManyAboveAverage x x y)
00:16:13 <roelof> so it's more readable and is working 
00:16:25 <liste> roelof I'd use guards
00:17:38 <KaneTW> roelof: split out the left side of the == into a separate function, use guards there, don't put too many parentheses
00:17:42 <aoeuaoeu> KaneTW, liste: thanks
00:17:49 <roelof> liste:  I was thinking about that but I have no idea how to do that. Can you give a hint ? 
00:17:51 <arkeet> doesn't x > y imply x /= y
00:18:28 * hackagebot iproute 1.7.0 - IP Routing Table  https://hackage.haskell.org/package/iproute-1.7.0 (KazuYamamoto)
00:18:29 <KaneTW> it should, unless someone implements > badly
00:18:30 * hackagebot logging 3.0.2 - Simplified logging in IO for application writers.  https://hackage.haskell.org/package/logging-3.0.2 (aupiff)
00:18:32 <arkeet> also that doesn't look like valid code?
00:18:45 <arkeet> missing an else branch
00:18:48 <roelof> arkeet:  I thought so but this test is failing on 0 0 but 0 0 0 is already in another test here I have this pattern x x y 
00:19:06 <liste> roelof foo x y | x > y = 2; x /= y = 1; otherwise = ???; prop_blah x y = howManyAboveAverage x x y = foo x y
00:19:18 <suppi> Hijiri, I want to load it to a vector of Word8 straight away.
00:19:38 <liste> roelof srry, the first two ;'s should be |
00:19:39 <Hijiri> readFile is probably fine
00:19:52 <suppi> alright. thanks :)
00:19:53 <roelof> liste:  NP, I got the idea 
00:23:24 <roelof> liste : I did this : http://lpaste.net/140899 but then I see this error : solution.hs:135:63: parse error on input ‘=’
00:23:28 * hackagebot linear 1.20.1 - Linear Algebra  https://hackage.haskell.org/package/linear-1.20.1 (EdwardKmett)
00:23:41 <liste> roelof wrong indentation
00:23:48 <liste> oh actually
00:23:56 <liste> replace ; with newline
00:24:03 <liste> then it should work
00:24:42 <KaneTW> aoeuaoeu: i just tried reproducing your issue and didn't get any elevated cpu usage
00:25:20 <aoeuaoeu> KaneTW: thanks for doing that - are you on windows?
00:25:24 <KaneTW> no, linux
00:26:00 <KaneTW> ghc 7.10.2 with a fresh install of relevant packages in a sandbox
00:26:17 <aoeuaoeu> hmph me too
00:26:21 <aoeuaoeu> 'cept windows
00:26:35 <aoeuaoeu> I'll try again on another windows and linux box but sounds like a bug ...
00:26:55 <KaneTW> might be; try bringing it up with the websockets dev
00:27:11 <aoeuaoeu> Thanks
00:27:48 <roelof> liste: thanks, I got it working with this http://lpaste.net/140900
00:28:13 <liste> roelof that looks nice
00:28:43 <roelof> yep, and learned more and more how to do things the Haskell way.
00:31:22 <ely-se> the point of no return
00:31:35 <ely-se> (pun not intended)
00:32:07 <suppi> ely-se, heh
00:32:45 <ely-se> funfact: Scalaz calls return "point"
00:33:41 <kadoban> Sounds like a better name than 'return' at least.
00:34:55 <liste> does it have Pointed?
00:35:43 <ely-se> http://scalaz.github.io/scalaz/scalaz-2.9.1-6.0.4/doc.sxr/scalaz/Pointed.scala.html
00:35:46 <ely-se> apparently
00:36:12 <suppi> we can now call return pure
00:36:23 <suppi> not a very good name, but better than return
00:36:47 <suppi> if you could change the name of return, what would you call it?
00:36:58 <suppi> I'm thinking about something like unitM
00:38:29 * hackagebot freer 0.2.2.2 - Implementation of the Freer Monad  https://hackage.haskell.org/package/freer-0.2.2.2 (alcabrera)
00:41:51 <ely-se> suppi: unjoin XD
00:42:21 <suppi> interesting :)
00:42:57 <ely-se> which reminds me
00:43:33 <ely-se> I'm working on a type checker with type inference (similar to HM) and I want to add constraints with type classes, but I can't find any material on how that works with type inference
00:45:22 <KaneTW> look up OutsideIn(X)
00:45:56 <ely-se> ok, let's see
00:55:40 <ely-se> KaneTW: thanks, I'll read it when I'm back home
00:58:21 <ely-se> for now I'll just make my type checker pretend constraints aren't there so I can work on other stuff
01:18:51 <athan> wtf? I can't `import Server.Schema (migrateAll)` because TemplateHaskell doesn't register generated terms in unconstrainted module exports? That's messed-up, man
01:27:34 <srhb> What's an unconstrained module import_
01:28:09 <delYsid> :t (@?=)
01:28:10 <lambdabot>     Not in scope: ‘@?=’
01:28:10 <lambdabot>     Perhaps you meant one of these:
01:28:10 <lambdabot>       ‘<?=’ (imported from Control.Lens),
01:28:46 <ely-se> srhb: export, not import.
01:28:54 <srhb> Derp, sorry.
01:29:01 <ely-se> I suppose it means "module M where" as supposed to "module M (a, b) where"
01:29:09 <srhb> Yep, got it. Thanks :-)
01:29:58 <merijn> TH is exported if you don't have a list...
01:30:07 <merijn> I'm guessing the TH generation is going wrong somehow
01:33:32 * hackagebot moesocks 1.0.0.1 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-1.0.0.1 (JinjingWang)
01:42:54 <athan> merijn: idk. It was with persistent, with migrations. I'll dig a bit though
02:05:52 <Alien_FX_Fiend> Does haskell involve a lot of maths?
02:06:33 <suppi> Alien_FX_Fiend, what do you mean?
02:07:15 <ely-se> everything does :p
02:07:50 <Alien_FX_Fiend> I wanna learn it thru realworldhaskell.org,but I'm put off by all the lambda and stuff....
02:08:25 <Alien_FX_Fiend> Yeah ely-se
02:08:48 <frerich> Alien_FX_Fiend: You don't need more math than with any other language (i.e. virtually none). As for 'lambda' - if you like, call them 'anonymous'.
02:09:09 <Alien_FX_Fiend> Ahh I see
02:10:01 <sternenseemann> Alien_FX_Fiend: for learning haskell I also can recommend learnyouahaskell.com
02:10:40 <Alien_FX_Fiend> 'K ty,that's greatly appreciated!
02:11:10 <tr_istan> Hello, question about Maybe/Either String/Tree and traverse
02:11:14 <tr_istan> http://lpaste.net/140909
02:11:41 <tr_istan> I want to transform Tree a -> Tree b
02:11:54 <Hijiri> @learnhaskell
02:11:54 <lambdabot> Unknown command, try @list
02:11:58 <Hijiri> @where learnhaskell
02:11:58 <lambdabot> https://github.com/bitemyapp/learnhaskell
02:12:03 <Hijiri> Alien_FX_Fiend: I recommend this one ^
02:12:14 <tr_istan> with a function f :: a -> Maybe b
02:12:31 <tr_istan> that works, but if i switch to Either String it does not compile
02:17:22 <merijn> tr_istan: Completely unrelated side note
02:17:43 <arkeet> :t \f -> traverse <$> pure f
02:17:45 <lambdabot> (Applicative f, Applicative f1, Traversable t) => (a -> f1 b) -> f (t a -> f1 (t b))
02:17:50 <arkeet> this sounds like a weird thing to use.
02:17:52 <merijn> tr_istan: You do realise "traverse <$> pure fn <*> x" is just "traverse fn <$> x"? :)
02:18:04 <arkeet> :t \f x -> traverse <$> pure f <*> x
02:18:06 <lambdabot> (Applicative f, Applicative f1, Traversable t) => (a -> f1 b) -> f (t a) -> f (f1 (t b))
02:18:17 <arkeet> yeah there's that.
02:18:22 <arkeet> but still seems weird.
02:18:57 <merijn> oh, wait
02:19:03 <merijn> This entire thing can be simplified a ton
02:19:14 <merijn> "x >>= traverse fn"
02:19:18 <tr_istan> yes, i realize, it just makes it a bit clear for me at the moment to use both <$> and <*> with applicative
02:19:26 <merijn> :t \fn x -> x >>= traverse fn
02:19:27 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> m (t a) -> m (t b)
02:19:54 <tr_istan> ignorring the simplification, why when i switch form Maybe to Either String it does not work
02:20:23 <merijn> tr_istan: It should, so I'm confused and thinking something is going wrong with all the noise :)
02:20:49 <merijn> :t traverse (undefined :: a -> Either String b)
02:20:50 <lambdabot> Traversable t => t a -> Either String (t b)
02:21:02 <merijn> And
02:21:21 <merijn> :t (>>=) (undefined :: Either String (t b))
02:21:21 <arkeet> tr_istan: I don't see how the first one can work.
02:21:22 <lambdabot> forall (k :: BOX) b (t :: k -> *) (b1 :: k). (t b1 -> Either String b) -> Either String b
02:21:25 <tr_istan> ok, i'll try to come up with a complete example and see if the poroblem is in the other functions or this really does nto work
02:21:36 <merijn> tr_istan: Actually
02:21:41 <merijn> tr_istan: I see why it doesn't work
02:21:51 <arkeet> I don't see why the Maybe one works.
02:21:54 <merijn> arkeet: I do
02:22:05 <merijn> arkeet: It's producing "Maybe (Maybe (Tree b))", afaict
02:22:13 <arkeet> yes, but he specified the type to be Maybe (Tree b)
02:22:15 <merijn> Instead of the Maybe (Tree b) he wants
02:22:34 <Alien_FX_Fiend> Learnyouahaskell is awesome,thank you so much,I'll go read it right away :)
02:22:46 <arkeet> Alien_FX_Fiend: if you want exercises, try here:
02:22:48 <merijn> tr_istan: Anyway your use of applicative is wrong here, you want Monad
02:22:50 <arkeet> @where learnhaskell
02:22:50 <lambdabot> https://github.com/bitemyapp/learnhaskell
02:23:10 <Alien_FX_Fiend> Yeah I bookmarked both
02:23:11 <arkeet> (generally more recommended than lyah these days)
02:23:13 <arkeet> :)
02:24:05 <Alien_FX_Fiend> I've been coming here for two decades,always learn something new!
02:25:05 <lpaste_> merijn annotated “Migrating from Maybe to Either String with traverse” with “Type error” at http://lpaste.net/140909#a140910
02:25:18 <merijn> tr_istan: See that paste
02:25:33 <merijn> tr_istan: The original code didn't work either, unless you're doing something different from what you showed us
02:26:19 <merijn> tr_istan: "(traverse <$> pure fn <*>) :: (Applicative f, Traversable t) => f (t a) -> f (Maybe (t b))"
02:26:45 <merijn> So the result of "traverse <$> pure fn <*> x" has type "Maybe (Maybe (Tree b))"
02:27:11 <merijn> You really want "(>>= traverse fn) :: Traversable t => Maybe (t a) -> Maybe (t b)"
02:27:24 <merijn> And then switching to Either should work too
02:33:34 * hackagebot clash-lib 0.5.12 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.5.12 (ChristiaanBaaij)
02:33:36 * hackagebot clash-systemverilog 0.5.9 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.5.9 (ChristiaanBaaij)
02:33:38 * hackagebot clash-vhdl 0.5.11 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.5.11 (ChristiaanBaaij)
02:33:40 * hackagebot clash-verilog 0.5.9 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.5.9 (ChristiaanBaaij)
02:33:42 * hackagebot clash-ghc 0.5.14 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.5.14 (ChristiaanBaaij)
02:34:11 <tr_istan> @merijn thank you, that worked :)
02:34:12 <lambdabot> Unknown command, try @list
02:34:54 <merijn> Alternatively, I suppose you could have used "join :: Monad m => m (m a) -> m a" :)
02:37:32 <drumrawl> hi guys, any clever ways to write `(\(i,s)-> if null s then show i else s)`?
02:38:54 <Alien_FX_Fiend> Wb ely-se
02:39:14 <merijn> drumrawl: Probably not in a way that's shorter than that
02:39:33 <liste> drumrawl foo (i, []) = show i; foo (_, xs) = xs ?
02:40:00 <drumrawl> liste: I meant as a one-liner.
02:40:35 <liste> @pl (\(i, s) -> if null s then show i else s) -- don't do this please
02:40:35 <lambdabot> uncurry (join . flip (if' . null) . show)
02:40:55 <merijn> Someone should change @pl to use bool instead of if'
02:41:10 <srhb> :t if'
02:41:11 <lambdabot>     Not in scope: ‘if'’
02:41:12 <lambdabot>     Perhaps you meant ‘f'’ (imported from Debug.SimpleReflect)
02:41:16 <srhb> Oh, that's why. :P
02:41:20 <merijn> srhb: if' doesn't actually exist :p
02:41:29 <srhb> Right right.
02:41:29 <merijn> It's "if' :: Bool -> a -> a -> a"
02:41:33 <merijn> :t bool
02:41:35 <lambdabot> a -> a -> Bool -> a
02:42:21 <drumrawl> where does `bool` come from?
02:42:41 <merijn> drumrawl: From the type Bool?
02:42:43 <srhb> @index bool
02:42:43 <lambdabot> Data.Bool
02:42:49 <srhb> ^
02:42:50 <merijn> Oh, the module :)
02:43:07 <drumrawl> srhb: ah, thanks!
02:43:12 <merijn> Note that bool is boolean-elimination, not "if", so it's argument order is different
02:43:20 <merijn> > bool 'c' 'g' True
02:43:22 <lambdabot>  'g'
02:43:26 <drumrawl> merijn: yes, perfect.
02:43:35 * hackagebot conversion 1.2 - Universal converter between values of different types  https://hackage.haskell.org/package/conversion-1.2 (NikitaVolkov)
02:43:41 <Qndel> hey
02:44:06 <Alien_FX_Fiend> Sternenseemann> that was a remarkable resource,ty
02:44:21 <liste> Qndel hi
02:44:47 <Qndel> http://lpaste.net/140912
02:44:53 <Qndel> could you look at my code?
02:45:21 <Qndel> what I'm trying to do is check 4 possible moves, and if a move is valid, I should be adding it to a list
02:45:37 <Qndel> however the list seems to be always empty
02:46:08 <merijn> @quote not.a.bug
02:46:09 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
02:46:29 <Intolerable> you also seem to be using (++) as some kind of mutable append
02:46:33 <Intolerable> prepend rather
02:46:43 <Qndel> hmm
02:46:50 <Qndel> what changes would you suggest then?
02:47:11 <frerich> I wish Haskell's syntax for multiline string literals would be a bit less heavy on those backslashes. :-/
02:47:12 <nshepperd> @where learnhaskell
02:47:12 <lambdabot> https://github.com/bitemyapp/learnhaskell
02:47:18 <nshepperd> Qndel: ^^
02:47:36 <Qndel> please :(
02:47:43 <Qndel> I'm supposed to send the code today
02:47:48 <Qndel> there's simply no time xD
02:48:36 <liste> Qndel you're screwed
02:48:45 <Qndel> why?
02:48:50 <Qndel> I've done most of my game
02:49:25 <Qndel> all I'm missing is the simple AI (tears of sadness while calling it AI) that chooses the move that takes it closer to the player
02:49:37 <Qndel> so I must check 4 possible directions
02:49:47 <Qndel> and choose move with lowest distance
02:49:54 <Qndel> what would be an elegant way to do it?
02:50:15 <liste> Qndel maybe start with making your function IO
02:50:20 <Intolerable> StateT IO
02:50:21 <liste> because you're using an IORef
02:50:42 <liste> but yeah StateT seems elegant in this case
02:51:06 <sternenseemann> Alien_FX_Fiend: yw
02:51:17 <Qndel> could you tell me more about StateT?
02:51:35 <Intolerable> https://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-Trans-State-Strict.html
02:51:45 <merijn> Is there a function that checks whether a list consists of a single element?
02:51:47 <liste> Qndel you can also do it with IORef
02:52:03 <nshepperd> the worst thing you could do here is successfully hand in your assignment while not understanding anything, and end up not getting the help from your instructor that you need
02:52:22 <tr_istan> Is there a idiomatic way of casting Either a b -> Either String b provided we can call show on type a? Thank you 
02:52:33 <Intolerable> :t bimap show id
02:52:35 <lambdabot> (Show a, Bifunctor p) => p a d -> p String d
02:52:36 <liste> Qndel if you're under stress, it's not easy to learn monad transformers in one day
02:52:39 <merijn> tr_istan: Bifunctors is in base :D
02:52:42 <merijn> :t first show
02:52:43 <lambdabot> Show b => (b, d) -> (String, d)
02:52:44 <Qndel> add opengl to it
02:52:46 <Qndel> xD
02:52:56 <merijn> Intolerable: Why bimap instead of first? :)
02:52:56 <liste> but you seem to already be using IORef (incorrectly), so you can stick with that
02:53:02 <Intolerable> i always forget that bimap x id == first x
02:53:08 <merijn> Oh, wait
02:53:13 <merijn> Wrong first in my case
02:53:18 <merijn> :t Data.Bifunctor.first show
02:53:19 <lambdabot> (Show a, Bifunctor p) => p a c -> p String c
02:53:19 <Intolerable> there's one though
02:53:34 <Intolerable> yup, there it is
02:53:48 <merijn> :t Data.Bifunctor.first show `asAppliedTo` Right 'c'
02:53:49 <lambdabot> Show a => Either a Char -> Either String Char
02:53:57 <tr_istan> got it, thanks #merijn  (again)
02:54:01 <Intolerable> :t asAppliedTo
02:54:02 <lambdabot> (a -> b) -> a -> a -> b
02:54:04 <Intolerable> neat
02:54:15 <merijn> Intolerable: It's const with an explicit type signature :p
02:54:27 <merijn> But it's a neat trick for lambdabot :D
02:54:46 <Qndel> ohh wait
02:54:54 <Qndel> so I can't modify the list in my program right?
02:55:03 <Intolerable> you can, but shouldnt
02:55:09 <merijn> Intolerable: You can't
02:55:19 <Intolerable> ?
02:55:26 <Intolerable> i mean you can with iorefs and stuff
02:55:34 <Intolerable> in the state its in at the moment you can't
02:55:35 <liste> but not really from a pure function
02:55:36 <merijn> Well, unless it's in an IORef, but then you're not changing the list, just storing a different list
02:55:41 <Qndel> but I could execute one if and return the empty list with added one of the elements that I'm looking for , right?
02:55:41 <Intolerable> true
02:55:47 <frerich> Qndel: You know, I think it's admirable how you didn't let yourself get stopped by Haskell's pesky type system but rather went straight to adding OpenGL support to your game. That's the spirit!
02:55:57 <Intolerable> heh
02:56:00 <Qndel> my game started with opengl
02:56:14 <Qndel> I keep adding parentheses and typing random stuff until it compiles
02:56:17 <Intolerable> (which is of course mainly in io)
02:57:02 <liste> Qndel Haskell sure doesn't make "throw stuff into the wall until something sticks" development easy, does it?
02:57:23 <Qndel> no ;
02:57:25 <Qndel> ;p
02:57:29 <nshepperd> haskell is famed for its strong type system, but even here trying random things until it compiles won't work
02:57:32 <frerich> Qndel: Yeah - of course, that only gets you so far. Still - it's much nicer to have something running so that you can tinker with it than getting distracted by all these crazy features and not actually making anything.
02:58:01 <Qndel> exactly!
02:58:24 <frerich> Qndel: And in a few months you'll come back to your code and go "What was I thinking??!?"
02:58:28 <frerich> ;-)
02:58:59 <Qndel> I won
02:59:07 <Qndel> I won't :D That's the whole point
02:59:20 <liste> Qndel ever?
02:59:26 <Qndel> going to send the code today, make a format and trust me, I'm not installing ghci again 
02:59:38 <Qndel> so you said about making my function IO
02:59:56 <Qndel> will it be changing let (xx,yy) = unsafePerformIO $ get pos         into  let (xx,yy) = get pos   
03:00:11 <Qndel> and getMoves:: (GLfloat,GLfloat) ->  [(GLfloat,GLfloat)] -> IORef (GLfloat,GLfloat) -> [(Float, (GLfloat,GLfloat))]  into   getMoves:: (GLfloat,GLfloat) ->  [(GLfloat,GLfloat)] -> IORef (GLfloat,GLfloat) ->IO [(Float, (GLfloat,GLfloat))]   ?
03:00:34 <liste> Qndel s/let (xx,yy) = get pos/ (xx,yy) <- get pos/
03:00:41 <Intolerable> number one that type signature is terrifying
03:00:51 <liste> but yes otherwise
03:01:04 <Intolerable> please synonym (GLfloat, GLfloat) to Position or something
03:01:07 <nshepperd> Qndel: I seriously think you should go to your instructor and admit that you're confused and don't know how to complete the project
03:01:08 <liste> Qndel so you don't want to be a developer?
03:01:17 <nshepperd> it's the only honest thing to do
03:01:18 <Qndel> I do
03:01:21 <Qndel> but not haskell for sure
03:01:42 <Qndel> I know that the quality of my code is terrible and it makes me sad
03:01:47 <Qndel> but I don't have time
03:02:26 <tdammers> it takes time one way or another
03:02:37 <tdammers> there are shortcuts, but you pay for them
03:02:43 <Qndel> "s/let (xx,yy) = get pos/ (xx,yy) <- get pos/"  - what's that supposed to be?
03:02:57 <tdammers> sed syntax
03:03:11 <Qndel> parse error on input `<-'
03:03:21 <tdammers> it means you need to write "(xx,yy) <- get pos" instead of "let (xx,yy) = get pos"
03:03:40 <tdammers> <- is syntax sugar inside do blocks, it doesnt' work outside of them
03:04:25 <nshepperd> clearly something went horribly wrong here where you've reached the final project without understanding how do-notation works
03:04:37 <tdammers> anyway, Haskell isn't the kind of language where trying to wing it is going to get you far
03:04:44 <Hijiri> nshepperd: disregarding honesty, that seems like the only practical option
03:08:25 <frerich> Qndel: So I'm a big fan of the Zawinski-style 'Getting Sh*t Done' attitude, but I tend to concur with nshepperd. I think something went really wrong if 'do' notation confuses you still and it would be honest to just use what you have - I suppose *something* works, and it would be fair to point out that you seem to be stuck and you sense you dug yourself a hole you can't get out of.
03:09:26 <liste> Qndel so your instructors/TAs don't look at your source code at all?
03:09:40 <Qndel> they will
03:09:41 <montanonic> Qndel: I think you'd feel more positively about Haskell if you came into it not expecting to do anything practical for several months. I've been at it *constantly* for two months now and I'm still learning the basics, but I'm exploring so many different parts of the language and learning so many different things about CS. So it is definitely worthwhile for me, even if I still can't make a decent website in it :)
03:09:46 <Qndel> I'll laugh with them
03:10:22 <frerich> Qndel: Does something work yet, i.e. can you get nice pixels on your screen which move?
03:10:31 <Qndel> yes
03:10:39 <Qndel> I can move my character
03:10:50 <Qndel> I've placed squares that block the movement
03:10:54 <Qndel> I can zoom in/out
03:11:04 <Qndel> I can drag and move the screen
03:11:10 <Reshi> montanonic: that's so true, going through that as well
03:11:30 <Qndel> I'm only missing proper movement for enemies
03:12:35 <Alien_FX_Fiend> Programming Game AI by Example,gameprogrammingpatterns.com
03:13:02 <Alien_FX_Fiend> Those sites might help^^
03:13:54 <Alien_FX_Fiend> Just google "Programming Gane AI By Example filetype:pdf"
03:13:57 <Qndel> I know how to write AI
03:14:03 <Qndel> Finished a course on harvard about it
03:14:09 <Qndel> but not going to write it in haskell
03:14:13 <Alien_FX_Fiend> *Game
03:14:35 <Alien_FX_Fiend> Oh
03:14:57 <Qndel> I can't see myself writing advanced AI in haskell when I don't even know what I'm doing
03:15:28 <Alien_FX_Fiend> Ah
03:16:35 <montanonic> Reshi: I think Haskell gives programmers the tools to write clean, understandable code in almost every domain, to an incredible degree, and that is absolutely the most valuable thing to have in a language: intelligibility; and Haskell has that because it is so expressive. You pay up front for this though, because you really end up having to learn a language, instead of small little building blocks that you can throw around.
03:17:55 <Alien_FX_Fiend> Brb
03:18:17 <montanonic> Intuition for all the different category theory things is an example of this required learning; you have to have a gut instinct for what Functors and Monads and the like are, but once you do, you gain so much power, and those constructs are far clearer than their alternatives built out of lower level tools.
03:18:57 <Qndel> fk it
03:19:07 <Qndel> I'll just build nested 10 ifs
03:19:09 <Qndel> should do
03:19:19 <Intolerable> what a mess
03:19:20 <montanonic> :(
03:19:40 <montanonic> It's okay, I know what it's like to be in positions like that. I genuinely hated CS in college.
03:19:48 <montanonic> Not saying that you do, but I did.
03:21:13 <liste> Qndel that's just pushing the code around, doesn't make any difference
03:23:03 <liste> Qndel you do realize that whole wall of code can be replaced with a simple `map', do you?
03:23:13 <Qndel> no I don't
03:25:13 <montanonic> Qndel: just out of curiousity, what is the Title of the class this is for? Also, if you'd like, you should paste your current code, and I can try and help. I don't know anything about how to use OpenGL though.
03:25:40 <Qndel> http://lpaste.net/140914
03:26:06 <Qndel> class is functional programming
03:26:12 <montanonic> And as a general tip for Haskell, if you repeat code anywhere, there's probably a way of not repeating it. This makes things far easier to reason about.
03:26:18 <akegalj_> Hey. I am trying to enable profiling using stack as a build tool for my project. How should I enable it? I tried adding -prof to ghc flags in .cabal, also tried adding same flag to stack ghc-options.
03:26:37 <Intolerable> cabal configure --enable-profiling?
03:27:07 <akegalj_> Intolerable: ok, will try it
03:27:44 <cocreature> stack build --library-profiling --executable-profiling
03:28:36 * hackagebot flo 0.1.1 - Generate flow charts from your code base.  https://hackage.haskell.org/package/flo-0.1.1 (ChrisDone)
03:29:03 <montanonic> Qndel: I'd highly recommend taking every chunk of code that does 1 important thing and breaking it off into its own function.
03:31:13 <Qndel> I don't want to break my code even more
03:31:20 <montanonic> Qndel: Depending on how much time you have in the coming weeks, you might also want to review more Haskell basics; if your course isn't nearing its end, this is necessary to do. Again, it can take a while. 
03:31:21 <Qndel> it doesn't work already
03:31:24 <Qndel> jesus
03:31:32 <Qndel> coming weeks XD
03:31:40 <Qndel> I'm supposed to send the code today
03:31:41 <montanonic> is this a Final?
03:31:44 <Qndel> tomorrow I'll go and talk about it
03:31:53 <liste> http://lpaste.net/140912
03:31:55 <Qndel> and bye bye haskell, never touching it again, even with a stick
03:32:34 <liste> Qndel why not
03:32:35 <liste> ?
03:32:39 <Qndel> because I don't like it?
03:32:55 <Qndel> there are so many nice programming languages and I'm not choosing haskell for sure
03:33:03 <liste> there's a reason for not liking it
03:33:16 <liste> what is it?
03:33:34 <merijn> liste: The fact that he started on his homework late and trying to finish a complicated exercise in one day
03:33:50 <montanonic> Let's be fair: college doesn't necessarily facilitate learning well all the time
03:34:08 <montanonic> I work so much harder and effectively as an independent studyer 
03:34:35 <liste> http://lpaste.net/140912 <--- Qndel, this was for you
03:34:46 <montanonic> I wouldn't judge Qndel's study habits as indicative of their character. I could absolutely imagine feeling the way they currently do.
03:35:08 <Qndel> @liste, it's my code, what's with it?
03:35:08 <lambdabot> No module "it's my code, what's with it?" loaded
03:35:14 <montanonic> And hating Haskell to; it was actually the first programming language I was tought at college, and I thought it was worthless at the time.
03:35:18 <liste> Qndel look at the bottom
03:35:18 <merijn> Maybe, but as someone who's TAed functional languages 3 years in a row, the number of students assuming "I'll just start this assignment the day before" and then complaining it's to difficult is making it hard to empathise with people struggling to meet deadlines
03:35:20 <montanonic> taught*
03:36:10 <merijn> montanonic: I don't consider it indicative of character, but my empathy/willingness to help is certainly decreased for "my deadline is tonight!!" problems
03:36:49 <montanonic> merijn: that's absolutely fair
03:37:25 <montanonic> merijn: I would agree that we should exert less effort to help for those types of problems, especially if it's just to satisfy a grade rather than knowledge.
03:37:29 <srhb> My only complaint is that judging openly in the channel creates a bad atmosphere, and it may not be fair (we never have the whole story)
03:37:38 <montanonic> Absolutely. 
03:37:56 <frerich> merijn: Given the list of things he has working already (panning the board, moving his character around, obstacles, zooming) I suspect he didn't exactly start *one* day before. ;-)
03:38:20 <merijn> frerich: Ok, that might be an unfair characterisation
03:38:26 <Qndel> well
03:38:32 <Qndel> it doesn't really work
03:38:46 <Qndel> the enemies are trying to move up all the time, and down if can't go up
03:39:09 <liste> so you need to randomize the order?
03:39:26 <akegalj_> cocreature: thnx, that worked too
03:39:30 <Qndel> no
03:39:31 <Qndel> http://lpaste.net/140917
03:39:35 <xyh> cabal install Agda meet the following error :: https://www.refheap.com/109495
03:39:38 <montanonic> Qndel: Document your code with explanations for what you understand and aren't clear about, and try to explain why things aren't working. If you can't solve the problem knowledgably, that is absolutely the best thing to do in its absence.
03:39:41 <Qndel> that's the code where I seled the move with lowest distance to player
03:39:51 <Qndel> select*
03:40:34 <montanonic> Then again, I don't know your professor, I'm just projecting what my professor respected in absence of a solution.
03:40:47 <Qndel> import qualified Data.Set as S
03:40:49 <Qndel> S is a set
03:41:08 <Qndel> so I think it should have the element with lowest distance as the first, so I just take it using head
03:42:03 <ocramz> hi there
03:42:10 <montanonic> So I have a question about typeclasses; currently I have this code:
03:42:24 <lpaste_> montanonic pasted “Typeclass overloading possible?” at http://lpaste.net/140918
03:42:25 <Intolerable> hello
03:42:40 <montanonic> What I'm wondering is:
03:43:07 <montanonic> can I instead of implementing a `fromTo` and a `toFrom`, instead have two `fromTwo`'s, with different types?
03:43:17 <srhb> montanonic: Another instance.
03:43:30 <srhb> montanonic: instance Convertible First Second and instance Covertible Second First
03:43:33 <montanonic> srhb: damn, I was hoping I wouldn't have to do that
03:43:40 <montanonic> Maybe I should consult TH
03:43:43 <srhb> montanonic: Doesn't it seem more natural though?
03:43:57 <srhb> You can't overload the name except via different instances.
03:43:59 <srhb> Not with TH either.
03:44:10 <montanonic> okay, that's totally fair. It is more natural, for sure.
03:44:22 <srhb> That is how we do ad-hoc overloading in Haskell after all. :)
03:44:23 <montanonic> I just always want to eliminate every bit of repetition :)
03:44:41 <montanonic> so declaring an instance TWICE is one too many for me if I can have otherwise
03:44:44 <montanonic> hehe
03:44:44 <chpatrick> +1 for multiple instances being more natural
03:44:55 <Qndel> how can I debug stuff in haskell ? is there a way to print something without changing my whole code? ;s
03:44:57 <chpatrick> you're saying you can go from a to maybe b
03:44:59 <liste> Qndel if you changed checkMove to be (GLfloat,GLfloat) -> Direction -> (GLfloat,GLfloat) -> Bool then you could map over all the coordinates
03:45:15 <chpatrick> so the instances should be the ones where that is possible
03:45:24 <chpatrick> otherwise you'll have a redundant instance if you want to go the other way
03:45:27 <frerich> Qndel: If you import Debug.Trace you can use a 'trace' function about everywhere.
03:46:01 <Qndel> but why should I map over the coordinates?
03:46:03 <montanonic> chpatrick: I didn't think of that, you're spot on
03:46:17 <montanonic> chpatrick, srhb: thanks for the feedback
03:46:23 <xyh> how should I install agda ?
03:46:53 <srhb> xyh: https://github.com/agda/agda#installing-agda
03:47:12 <xyh> srhb: "cabal install Agda" meet the following error :: https://www.refheap.com/109495
03:47:14 <merijn> Blah, why does Map have a safe "lookupIndex", but not a safe "elemAt"? :(
03:47:24 <Intolerable> what's elemAt?
03:47:30 <Intolerable> :t elemAt
03:47:32 <lambdabot>     Not in scope: ‘elemAt’
03:47:32 <lambdabot>     Perhaps you meant one of these:
03:47:32 <lambdabot>       ‘M.elemAt’ (imported from Data.Map),
03:47:37 <Intolerable> :t M.elemAt
03:47:38 <lambdabot> Int -> M.Map k a -> (k, a)
03:48:02 <srhb> xyh: Try to do what the error message tells you to do.
03:48:04 <merijn> Integer index in the map
03:48:44 <Qndel> so how can I trace this ?   let dirs = getMoves coord myMap playerPos
03:48:46 <srhb> xyh: Also if you just created the directory but didn't initialize a sandbox, it's irrelevant that you've cd'ed to it. It will still be installed in your user package db. And I'm not sure if it would be cumbersome to actually have it in a sandbox anyway.
03:48:53 <Qndel> 'd like to see what's in the dirs ;(
03:49:37 <srhb> :t trade
03:49:38 <tdammers> Qndel: when you're in IO, you can just use hPrint stderr (or even just print if you're fine with logging to stdout)
03:49:38 <lambdabot> Not in scope: ‘trade’
03:49:45 <srhb> :t trace
03:49:46 <lambdabot> Not in scope: ‘trace’
03:49:48 <tdammers> Qndel: otherwise, there's Debug.Trace
03:49:48 <srhb> Hrmpf
03:50:00 <Qndel>   let dirs = trace (dirs) (getMoves coord myMap playerPos)
03:50:09 <srhb> Qndel: The first argument of trace is the string to output, the second is the value it should return
03:50:10 <tdammers> Qndel: there are some caveats related to laziness though; things don't necessarily get printed when you expect them to
03:50:20 <srhb> Qndel: That's recursive and dirs is not a String
03:50:30 <Qndel> so how can I print a list?
03:50:35 <srhb> :t show
03:50:37 <lambdabot> Show a => a -> String
03:50:41 <Intolerable> :t traceShow
03:50:43 <lambdabot> Not in scope: ‘traceShow’
03:51:05 <Intolerable> :t Debug.Trace.traceShow
03:51:06 <lambdabot> Show a => a -> b -> b
03:51:06 <Qndel> now the game crashed
03:51:19 <Intolerable> did you change your infinite recursion?
03:51:26 <xyh> "ghc-pkg init ./db" but the error still >_<
03:51:31 <ocramz> I'm wrapping a bunch of FFI calls with alloc/deallocation: what do you think of this? withAsyncWait io act = withAsync io $ \a -> do {r <- wait a; act r } 
03:51:43 <Qndel> no I haven't
03:52:02 <Qndel> but I have no idea how to do it
03:52:25 <srhb> Qndel: If you use dirs in the definition of dirs, you're recursing.
03:52:35 <srhb> Qndel: You don't want to recurse. Consider carefully what you want to actually print.
03:52:41 <Qndel> http://lpaste.net/140919
03:52:44 <merijn> Any volunteers for the "refactor this to be prettier"-game?
03:52:44 <Qndel> doesn't work anyway
03:52:56 <lpaste_> merijn pasted “UniqMap” at http://lpaste.net/140920
03:53:09 <srhb> Qndel: is (getMoves coord myMap playerPos) a function?
03:53:10 <merijn> I'm looking for suggestion to make that suck less
03:53:28 <xyh> srhb: "use 'ghc-pkg init' to create the database with the correct format." a database for linux user, or a database for agda ?
03:53:42 <srhb> xyh: A database for ghc packages.
03:53:54 <Qndel> ok made it work
03:54:00 <Qndel> just confirms that my code doesn't work
03:54:05 <Qndel> still no idea why
03:54:35 <xyh> srhb: one user one db ? or one haskell repo one db ?
03:54:48 <srhb> xyh: I think that's the user local one.
03:55:17 <Qndel> http://lpaste.net/140921
03:55:21 <srhb> Actually no, it seems to be referring to the one in the package. I'm not sure.
03:55:41 <Qndel> it should return a list with possible moves and distances between player after executing these moves
03:55:52 <Qndel> and I'm supposed to take the move with lowest distance
03:55:55 <Qndel> what's wrong ?
03:56:03 <Intolerable> that doesn't do what you think it does
03:56:07 <liste> Qndel that one just returns one or two moves
03:56:14 <Intolerable> you're returning the first valid move and the default one
03:56:18 <Intolerable> rather than the best ones
03:56:25 <Qndel> so how to return all ? :(
03:56:53 <xyh> srhb: I do "ghc-pkg init ~/.ghc/db", and then "cabal install Agda", but I get the same error ! 
03:56:54 <xyh> ghc: ghc no longer supports single-file style package databases (dist/package.conf.inplace) use 'ghc-pkg init' to create the database with the correct format.
03:56:56 <Qndel> the default one is in case that there were no valid moves
03:57:07 <xyh> so the format is not correct ?
03:57:11 <Qndel> it means stay at your current position
03:57:23 <Qndel> I've given it 99999 distance so it should only be chosen if there are no better moves
03:58:27 <Qndel> so what changes should I make to the getMoves function so it'd return all valid moves, not only the first one?
03:58:34 <srhb> xyh: Sorry, I don't know. Perhaps someone else can help.
03:59:06 <montanonic> Qndel: sidenote: you should give 99999 a name if you use it throughout your code; `maxDistance = 99999` should be fine
03:59:19 <montanonic> just do a search and replace
03:59:26 <Intolerable> (or use Maybe)
03:59:35 <Qndel> but how to return all valid moves?
04:00:00 <frerich> merijn: I think it might be nicer to just use the plain M.fromList and then use 'all (null . tail) . group' on the keys of that map. If it's false, you return Nothing - otherwise oyu wrap the map into your newtype.
04:00:14 <merijn> frerich: You can't use plain fromList
04:00:16 <lpaste_> liste annotated “No title” with “Qndel this?” at http://lpaste.net/140921#a140922
04:00:22 <merijn> frerich: That simply overwrites duplicate keys
04:00:36 <merijn> frerich: oh, wait
04:00:37 <Intolerable> what are we trying to do?
04:00:53 <merijn> Intolerable: Refactor this to suck less: http://lpaste.net/140920
04:00:53 <Intolerable> make a map that rejects if you add duplicate keys?
04:00:58 <merijn> Intolerable: Yeah
04:01:10 <Intolerable> fromListWith?
04:01:29 <Intolerable> hm
04:01:32 <Intolerable> give me a couple minutes
04:01:46 <frerich> merijn: I suppose you don't want to check 'all (null . tail) . groupBy (comparing fst) $ list' up front for performance reasons?
04:01:52 <frerich> (err, add 'sort')
04:01:53 <Qndel> tears of joy
04:01:54 <Qndel> it works!
04:01:58 <Qndel> thanks!
04:02:01 <merijn> frerich: I don't particularly care about performance here
04:02:34 <liste> Qndel you're welcome
04:02:51 <Qndel> now I'll add more obstacles to test it
04:03:19 <Intolerable> :t sequence . M.fromListWith (\_ _ -> Nothing) . fmap (fmap Just)
04:03:19 <lpaste_> frerich annotated “UniqMap” with “UniqMap (annotation)” at http://lpaste.net/140920#a140923
04:03:20 <lambdabot> Ord k => [(k, a)] -> Maybe (M.Map k a)
04:03:24 <Intolerable> ?
04:04:01 <Intolerable> is that right?
04:04:22 <merijn> Intolerable: Ah, nice
04:04:49 <Intolerable> then just do fmap UniqMap or whatever on that
04:05:06 <Intolerable> you can probably clean up some of that tbh
04:05:43 <Intolerable> :t sequence . M.fromListWith (\_ _ -> mempty) . fmap (fmap pure)
04:05:44 <lambdabot> (Monad m, Ord k, Monoid (m a)) => [(k, a)] -> m (M.Map k a)
04:05:52 <frerich> Intolerable: That's clever. :-)
04:06:06 <frerich> Using fromListWith with \_ _ -> Nothing is an interesting idea.
04:06:06 <Intolerable> fromListWith is so useful
04:06:50 <Intolerable> > mzero :: Maybe String
04:06:52 <lambdabot>  Nothing
04:06:59 <Intolerable> :t sequence . M.fromListWith (\_ _ -> mzero) . fmap (fmap pure)
04:07:00 <lambdabot> (Ord k, MonadPlus m) => [(k, a)] -> m (M.Map k a)
04:07:04 <Intolerable> bit nicer
04:07:07 <Intolerable> pick your poison i guess
04:07:36 <frerich> I think it's tricky, but to be honest to me it's a bit of a mental speed bump. I'd probably have to stop reading and think a bit to figure out what it does (and why). :-}
04:07:52 <frerich> Maybe I'm just not used to using fromListWith like this.
04:08:37 <lpaste_> Gurkenglas revised “Qndel this?”: “I would do it like so, by the way; less pure-wrapping of lists that way etc.” at http://lpaste.net/140922
04:08:39 <Qndel> last question for today
04:08:46 <Qndel> http://lpaste.net/140924
04:08:53 <Qndel> any easy way to make my cube a tetrahedron?
04:09:16 <liste> Qndel just add the tetrahedron vertices (:
04:09:21 <liste> it's just geometry
04:09:41 <Intolerable> easy way to make tetrahedron:
04:09:44 <Intolerable> take all ur faces
04:09:53 <Intolerable> average the vertices
04:09:57 <Intolerable> use them as new vertices
04:09:59 <Intolerable> ez pz
04:14:15 <ocramz> any experts on STM around? 
04:14:25 <Intolerable> "experts"
04:14:30 <ocramz> :D
04:14:32 <Intolerable> what do you want to ask
04:15:10 <liste> or, rather, just ask :D
04:15:44 <ocramz> anyway, I'm reading Marlow; he mentions something about STM needing to be able to roll back changes; I understand IO is ruled out? i.e. there cannot be e.g. FFI operations within `atomically` blocks?
04:15:58 <merijn> ocramz: Define "cannot"
04:16:04 <ocramz> hurr
04:16:10 <merijn> ocramz: I mean, you could use unsafePerformIO :)
04:16:17 <merijn> ocramz: But that leads to
04:16:22 <merijn> @quote not.a.bug
04:16:22 <lambdabot> SPJ says: [This is] clearly not a bug in GHC; but it would be more felicitous if it gave you a warning...
04:16:27 <merijn> aww, wrong quote
04:16:31 <merijn> @quote Lemmih not.a.bug
04:16:32 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
04:17:16 <merijn> ocramz: Basically, any STM actionmight be executed multiple times. The type system protects you from doing IO (therefore preventing you from running the same IO action multiple times and violating the isolation/atomicity of your transaction)
04:17:18 <ely-se> I once invoked Perl from unsafePerformIO to manipulate some text :D
04:17:32 <merijn> But if you abuse unsafePerformIO all hell might break loose, obviously
04:18:12 <merijn> Intolerable: I found a slightly nicer formulation :)
04:18:29 <lpaste_> merijn pasted “UniqMap 2.0” at http://lpaste.net/140926
04:18:44 <merijn> Intolerable: That way I can track which keys are duplicates too :)
04:19:22 <ocramz> merijn: I'm more concerned about having a consistent way of handling e.g. allocation exceptions
04:19:47 <merijn> ocramz: What exactly are you doing?
04:22:05 <ocramz> merijn: FFI library, tons of alloc/dealloc function pairs, and other functions that expect arguments to be in some sort of "right" state 
04:23:28 <ocramz> I thought `atomically` could be a good way to hide the temporary state transformations that occur during a variable update or initialization
04:23:41 <merijn> ocramz: No, STM is utterly wrong here
04:23:56 <ocramz> merijn: so async then
04:24:08 <merijn> ocramz: Your problem is needing to "unwind"/cleanup previous allocations if the 3rd or so of a series of allocations fails?
04:24:59 <ocramz> something like that, yes
04:25:00 <merijn> This doesn't sound like an STM/async problem at all, unless you're not saying a lot of details
04:25:13 <merijn> ocramz: You need a pattern like bracket from Control.Exception
04:25:19 <merijn> :t Control.Exception.bracket
04:25:21 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
04:25:27 <ocramz> yes, I'm already using that
04:25:50 <ocramz> one ends with a nest of withX $ \x -> ... 
04:26:11 <merijn> ocramz: You can use ContT to make the nesting "nicer"
04:26:13 <merijn> See https://stackoverflow.com/questions/26436095/what-are-good-haskell-conventions-for-managing-deeply-nested-bracket-patterns
04:26:40 <merijn> That lets you write your brackets as serial monadic statements instead of continuously nesting them
04:29:51 <ocramz> merijn: thanks for the link, looks very much in line w what I'm doing
04:30:08 <Profpatsch> Quick cabal question: http://lpaste.net/4239785968497852416
04:30:39 <Profpatsch> I have to duplicate alle build-depends here, otherwise cabal complains about hidden packages.
04:30:48 <Profpatsch> This doesn’t seem right.
04:31:34 <Profpatsch> Especially since the Main only imports the library.
04:31:35 <merijn> Profpatsch: Make the executable depend on labapi
04:31:48 <Profpatsch> merijn: Argh, of course
04:31:51 <merijn> Profpatsch: :)
04:31:53 <Profpatsch> That was obvious.
04:31:58 <Profpatsch> Thanks. :)
04:32:32 <merijn> Anyone here ever work with Trifecta's error stuff?
04:38:10 <simon> is there a neat way I can derive Show Foo where all those strings are lowercased?
04:38:59 <liste> simon why use Show for that?
04:39:20 <simon> liste, right, it should be PP or something like that.
04:39:45 <Intolerable> merijn: yeah that looks better
04:40:37 <srhb> simon: Look at Data.Derive
04:41:07 <Intolerable> Validation is the Either variant with the Monoid a => Applicative (Validation a b) constraint, right?
04:41:08 <simon> liste, same problem, perhaps. I'd like to derive it. a hack I thought of was; newtype UC Foo = UC Foo; deriving instance Show (UC Foo); instance Show Foo where show x = drop 3 (show UC x) -- I know, ugly!
04:41:12 <simon> hi srhb :)
04:41:19 <srhb> simon: Hi :)
04:41:53 <simon> whoops, show = drop 3 . map toLower . show . UC
04:43:33 <srhb> simon: Why not just use the existing derivation mechanism and provide lShow = map toLower . show ?
04:43:44 <simon> srhb, yeah, of course.
04:45:39 <simon> srhb, I'm making a 'StateT [Ident] Gen a' syntax-tree generator :)
04:45:54 <srhb> Ident being identifier?
04:45:59 <simon> yup.
04:46:00 * srhb nods
04:46:44 <ocramz> @lpaste
04:46:44 <lambdabot> Haskell pastebin: http://lpaste.net/
04:49:06 <Alien_FX_Fiend> Charlize Theron is from South Africa,she's very pretty!
04:49:27 <Alien_FX_Fiend> Whoops wrong window!
04:51:22 <Intolerable> lmao
04:52:14 <lpaste_> ocramz pasted “Checkable” at http://lpaste.net/140928
04:52:28 <ocramz> merijn: ^ this is what I'm working on
04:54:39 <ocramz> merijn: thing is, my FFI functions might return tuples of different structure, which is why I thought I'd use that class CHeckable 
04:58:48 <simon> srhb, how can I most conveniently refer to Gen's combinators inside my stack?
04:59:23 <Profpatsch> merijn: Still not working, though: http://lpaste.net/1100353638934511616
04:59:56 <srhb> simon: Lift or provide a MonadGen instance or something like that :)
05:00:12 <Profpatsch> Now I’m completely lost, as the Labapi.hs can’t access the hidden packages lens, wreq and http-types. oO
05:01:05 <delYsid> OK, two days ago I was rather frustrated with re-acquainting myself with Monadic stuff.  Two days later, I am rather fascinated by using Parsec Applicative-style :-)  This stuff is really really useful.
05:01:33 <merijn> Profpatsch: Executables don't automatically depend on everything the library depends on
05:02:06 <simon> srhb, I did look into QuickCheck-GenT, which I assume is necessary for MonadGen. I'm not sure how I should specify it... it doesn't take a parameter, does it?
05:02:22 <Profpatsch> merijn: You mean it compiles twice?
05:02:45 <srhb> simon: You can look at MonadState, MonadReader and friends to see how it's done.
05:02:49 <Profpatsch> Shouldn’t the executable pick up the already compiled library?
05:02:56 <srhb> simon: That's probably a good introduction anyway. :)
05:04:00 <srhb> simon: Actually, is it Nikita Volkovs library? It already provides MonadGen
05:04:12 <Profpatsch> merijn: Heh, I solved it by putting Labapi.hs into labapi/Labapi.hs.
05:04:34 <Profpatsch> And changing hs-source-dirs for the library to labapi.
05:04:42 <simon> srhb, I've done it for MonadState; newtype StateGen a = StateGen (StateT [Ident] Gen a) deriving (Monad, Applicative, Functor, MonadState [Ident]). it seems that MonadGen expects something with kind * -> *...
05:06:25 <av_> Hi everyone, I just discovered Haskell packages such as atom, improve, and ivory.  I'm looking for a way of programming a microcontroller (ARM-based) with a numnber of peripherals (USB device, most importantly) and want to leverage as much expressiveness as I can (thus code generation via a Haskell EDSL).
05:06:32 <srhb> simon: Hmm. Hang on.
05:06:43 <srhb> simon: I would usually just use a type synonym here, not sure how it's done with newtypes.
05:07:07 <av_> Problem: which one do I pick?  On paper, ivory looks best, but it doesn't install via cabal (base system is too new for its requirements).
05:07:11 <av_> Any ideas?
05:08:59 <simon> srhb, you derive with type synonyms?
05:09:28 <srhb> simon: No, I wouldn't derive at all. Why do you need to derive anything?
05:12:15 <hexagoxel> av_: you mean the dependency bounds on base are too restrictive? on github they say it should work with ghc-7.8.*, while the package seems to restrict it to ghc-7.6.*
05:12:29 <geekosaur> av_, you could try --allow-newer=base but I would expect problems if you're using ghc 7.10
05:12:30 <hexagoxel> av_: probably you can just losen the bounds of the package
05:12:43 <geekosaur> (if your cabal-install is recent enough)
05:13:31 <hexagoxel> (i bet ghc-7.10 won't work directly, as they don't mention it :p)
05:13:41 * hackagebot cubicbezier 0.4.0.1 - Efficient manipulating of 2D cubic bezier curves.  https://hackage.haskell.org/package/cubicbezier-0.4.0.1 (KristofBastiaensen)
05:14:29 <av_> geekosaur: I tried that, and I'm using ghc-7.8, I got an error (would have to look it up, can't remember exactly what it was)
05:15:44 <geekosaur> also if they say on github that it works with 7.8 then you may need to use current git, not the last released version
05:18:45 <av_> geekosaur: yeah, that's what I thought, might try building from git
05:26:51 <t4nk033> hi, haskell newbie gettting a compliation error "Could not find module ‘Data.HashTable’" how do i resolve this?
05:28:35 <Intolerable> make sure you have the correct package installed
05:28:43 <geekosaur> sounds like you're building something fairly old; Data.HashTable was removed in ghc 7.8, in favor of Data.HashMap / Data.HashSet from unordered-containers
05:28:53 <Intolerable> (or that)
05:29:12 <t4nk033> yes looking at http://codereview.stackexchange.com/questions/22713/counting-word-frequencies-in-haskell?rq=1
05:29:53 <geekosaur> (HashTable had fairly lousy performance IIRC)
05:32:53 <t4nk033> ok thanks everyone
05:38:42 * hackagebot yesod-table 2.0.0 - HTML tables for Yesod  https://hackage.haskell.org/package/yesod-table-2.0.0 (andrewthad)
05:48:42 <CpnStumpy> Huzzah, what I have been looking for *is* a SemiRing - and there's a SemiRing package that has precisely the same implementation for boolean as me: https://github.com/srush/SemiRings/tree/master
05:49:40 <CpnStumpy> even has a Monoid based implementation helper just like I expected
05:50:25 <ThreeOfEight> I often wish Haskell had proper algebraic structures in the standard library
05:51:08 <simon> ThreeOfEight, like what?
05:51:27 <simon> ThreeOfEight, like https://wiki.haskell.org/Numeric_Prelude ?
05:52:42 <ThreeOfEight> simon: Probably; at first glance, it looks like what I had in mind
05:52:45 <CpnStumpy> ThreeOfEight: the standard library has a lot of great features, but there's some amount of C++ like "thin STD - non-std libs for real applications" approach. Though not even close to as bad as C++ where STD doesn't even give you network facilities
05:53:14 <ThreeOfEight> I knew that some alternative Preludes exist but I never really looked at them in much detail
05:53:19 <scshunt> CpnStumpy: they're working on networking
05:53:34 <ThreeOfEight> although I am a bit confused by the "numeric" thing
05:53:56 <simon> ThreeOfEight, yeah, that is admittedly a little weird.
05:53:59 <delYsid> oh, Hayoo works a lot bettern then Hoogle when it comes to searching for type signatures!
05:54:09 <simon> delYsid, outside the standard library, yes.
05:54:14 <ThreeOfEight> since most of those structures have nothing to do with numbers a priori, but maybe that's just the abstract algebraist in me
05:54:18 <CpnStumpy> scshunt: C++? Or Haskell? Haskell has a relatively solid standard networking lib (wait, is that a cabal installed piece? It was so standard I don't remember..)
05:54:19 <simon> delYsid, when you know it's in the standard library, hoogle is less cluttered.
05:54:26 <scshunt> CpnStumpy: C++
05:54:52 <delYsid> simon: hmm, I dunno, Hoogle gives me a lot of false positives when I search for type sigs.  All sorts of results that have nothing to do with my query...
05:55:10 <simon> delYsid, true dat.
05:55:17 <CpnStumpy> scshunt: (C++ is my favorite whipping boy) Hail C++, welcome to 2002!
05:55:21 <ThreeOfEight> I never really understood the type signature search on those sites
05:55:34 <ThreeOfEight> I used to think they just do matching, but apparently not
05:55:40 <simon> delYsid, like "look, this thing also has a type constructor where your search has one!"
05:56:48 <delYsid> simon: yeah, I have only tried it half a dozent times, but Hoogle has actually never turned up something useful when I searched for type signature.  I actually was under the impression the feature must be (temporarily?) broken.
05:57:20 <geekosaur> you could try hayoo although usually its type search isn't very good
05:57:36 <geekosaur> (hayoo.fh-wedel.de)
05:57:48 <delYsid> geekosaur: heh, ^^, I just said that I discovered Hayoo and am very happy with it
05:58:12 <delYsid> although a hayoo cli would be convenient
05:58:51 <geekosaur> dunno if anything CLIish is in there yet but hayoo source is on hackage and github
06:01:29 <delYsid> gah, have to leave, need to find an eye doctor to certify that I am really blind (stupid world).
06:02:55 <CpnStumpy> or perhaps it's a ring? http://hackage.haskell.org/package/numeric-prelude-0.4.2/docs/Algebra-Ring.html the stated rules work for one = True, * = && and + = ||
06:03:55 <CpnStumpy> thanks simon, that Numeric Prelude appears pretty helpful
06:05:19 <CpnStumpy> I want to call it a field because it is commutative, but the `Field` definition in that library is a long shot from straight forward
06:05:49 <clrnd> I just use google, hoogle/hayoo still don't work for me
06:06:42 <ThreeOfEight> CpnStumpy: It /is/ a field
06:06:49 <ThreeOfEight> in fact, it's isomorphic to GF(2)
06:07:09 <CpnStumpy> I give up, the Field rules are not super straight forward - I'm just going to use QuickCheck because I think it's a field and the numeric prelude provides the props for QC
06:07:16 <ThreeOfEight> (actually, all finite fields of a given size are unique up to isomorphism)
06:07:57 <CpnStumpy> ThreeOfEight: Yeah? Sweet, I spent a bunch of time trying to figure it out the other day because I've recreated the type class a variety of times and figured there's a standard one for the relation
06:07:58 <ThreeOfEight> CpnStumpy: what are you having problems with, exactly?
06:08:37 <ThreeOfEight> Oh, wait, + = ||?
06:08:42 <ThreeOfEight> No, that's problematic
06:08:51 <ThreeOfEight> It works with + = xor
06:08:51 <CpnStumpy> ThreeOfEight: Not problems, I just wanted to use a standard defined structure instead of recreating the same structure over and over. I use it for control flow definition in code
06:09:15 <ThreeOfEight> if you have * = && and + = ||, it's probably just a Semiring
06:09:22 <ThreeOfEight> because || has no inverse
06:09:35 <ThreeOfEight> i.e. there is no value b such that 1 || b = 0
06:09:51 <ThreeOfEight> a commutative semiring, to be more exact
06:09:55 <CpnStumpy> ThreeOfEight: over the set `True | False` is `||` and `xor` different?
06:10:04 <pavonia> What was the escape sequence to indicate the end of an escape sequence in strings again?
06:10:05 <ThreeOfEight> True xor True = False
06:10:09 <ThreeOfEight> True || False = True
06:10:14 <ThreeOfEight> er
06:10:17 <ThreeOfEight> True || True = True
06:10:36 <geekosaur> pavonia, \&
06:10:47 <pavonia> Ah, thanks!
06:11:53 <ThreeOfEight> CpnStumpy: I suppose the standard structure that you have is just a Boolean Algebra
06:11:56 <ThreeOfEight> https://en.wikipedia.org/wiki/Boolean_algebra_(structure)
06:11:59 <spion> is there anything particular to get ghc-mod to work with stack? its looking into `dist` to try and find the project's dependencies (and failing)
06:12:05 <CpnStumpy> ThreeOfEight: good point. But in the Field a + one /= a ?
06:12:08 <CpnStumpy> I guess that makes sense
06:12:35 <CpnStumpy> Then how about: one = false, * = ||, + = &&
06:12:58 <CpnStumpy> True + True = True so I guess that doesn't work...
06:13:12 <ThreeOfEight> yeah
06:13:15 <CpnStumpy> yeah It must be a semiring (or a ring?)
06:13:25 <ThreeOfEight> it's not going to work because of the way the combination tables look
06:13:31 <CpnStumpy> right
06:13:34 <ThreeOfEight> no matter how you label these things, it's not going to work
06:13:46 <ThreeOfEight> It's a commutative semiring
06:13:49 <ThreeOfEight> but it is /not/ a ring
06:13:53 <CpnStumpy> Ok
06:14:10 <ThreeOfEight> because there are no additive inverses
06:14:54 <ThreeOfEight> As I said, your structure is a Boolean Algebra
06:15:01 <CpnStumpy> Works for me. The reason I figured it's got to be a standard structure is because I can find the precise same relation in other structures and use it for the exact same thing (decision tree switches for control flow): Maybe and Either monoids
06:15:18 <ThreeOfEight> or, if you ignore distributivity and negation: a bounded lattice
06:15:30 <ThreeOfEight> in fact, you probably want to look at bounded lattices
06:15:48 <ThreeOfEight> in a bounded lattice, you have a "top" element (true), a "bottom" element (false)
06:16:10 <ThreeOfEight> and you have operations called "join" and "meet", which take two values and return their upper/lower bound
06:16:20 <ThreeOfEight> that's || and &&
06:16:46 <ThreeOfEight> And that's called a bounded lattice. If you add distributivity of && and || and a negation operator, you get a Boolean Algebra
06:16:55 <akegalj_> I am trying to profile a program which shows that showsPrec has 41% time and 41% alloc. Program is doing some anlysis on 12MB file and spitting that file to 17MB output. Is this ratio wird (could this hint me something?) ?
06:17:09 <CpnStumpy> That sounds like a fit as well. Is there a definable obvious correlary between bounded lattice and semiring? (More rules on one, less on the other, etc?)
06:17:41 <geekosaur> akegalj_, suggests to me that around 41% of work is being "forced" by an invocation of show
06:18:21 <ThreeOfEight> CpnStumpy: I haven't given this much thought, but I think every bounded lattice gives rise to two semirings, yes
06:18:56 <CpnStumpy> ThreeOfEight: Can you define a boolean algebra in terms of a monoid if you add negation?
06:19:00 <akegalj_> geekosaur: by "forced" you mean explicitely forced ?
06:19:05 <ThreeOfEight> Wikipedia says "Any bounded, distributive lattice is a commutative, idempotent semiring under join and meet."
06:19:27 <ThreeOfEight> CpnStumpy: What do you mean by that?
06:19:41 <CpnStumpy> ThreeOfEight: Ok, so Bounded Lattice is the less general structure that fits the boolean version more closely
06:19:48 <akegalj_> geekosaur: ignore that last msg. Thnx
06:20:22 <ThreeOfEight> I wouldn't say less general
06:20:42 <ThreeOfEight> I think they're pretty much orthogonal
06:26:09 <CpnStumpy> ThreeOfEight: Say one = mempty, and `one + a = a = a + one` and `one * a = one = a * one` - this works as the "Boolean algebra" if I define `mempty = False`
06:26:57 <CpnStumpy> So why can't I take that same format and construct a generalization from monoid with it so long as I add the `*` function I defined there - "negation" no?
06:27:35 <CpnStumpy> Or maybe it needs to be a commutative monoid for that to work?
06:28:33 <CpnStumpy> monoid defines exactly what's seen there but for the `*` function
06:29:10 <ThreeOfEight> according to your definition, there would be "1 + 0 = 0" and "1 * 0 = 1"
06:29:12 <ThreeOfEight> that sounds strange
06:29:16 <ocramz> `instance Functor ((,) a)` means that only tuples containing the same type can be mapped over?
06:30:00 <ThreeOfEight> ocramz: what do you mean by that? Which types must be the same?
06:30:23 <CpnStumpy> ThreeOfEight: sorry - as we showed it doesn't meet a Field so the structural terms I'm using there aren't right, one second...
06:30:36 <ocramz> the types of the objects contained in the tuple. 
06:30:42 <frerich> So, after one week of trying to use stackage + stack instead of hackage + cabal for my project, I must say that it works mostly, I still didn't quite wrap my head around it and the term 'LTS' gives me a warm fuzzy feeling.
06:31:12 <frerich> Alas, I had one case where 'stack install foo' failed to compile a package but I guess that's because I did something wrong. It used my system ghc (7.10.2)
06:31:40 <ThreeOfEight> ocramz: (,) a is a partially applied type constructor
06:31:48 <ThreeOfEight> (a,b) is basically the same as (,) a b
06:31:52 <ocramz> yes
06:32:08 <ThreeOfEight> So Functor ((,) a) means that the first tuple component is fixed to type a, and the second component is what is being mapped over
06:32:39 <ThreeOfEight> > fmap (+1) ("foo", 42)
06:32:41 <lambdabot>  ("foo",43)
06:32:53 <ocramz> ThreeOfEight: thanks :) clear now
06:33:08 <ThreeOfEight> There is also something called Bifunctor
06:33:26 <ThreeOfEight> e.g. (,) and Either are Bifunctors
06:33:41 <ThreeOfEight> it basically means that they have two type parameters and are a functor in both of them
06:33:43 <ely-se> not to mention jokers
06:34:01 <ThreeOfEight> https://hackage.haskell.org/package/bifunctors-5/docs/Data-Bifunctor.html
06:34:07 <ThreeOfEight> I found this very useful on occasion
06:37:25 <paldepind> Gurkenglas: Are you there?
06:37:48 <merijn> ThreeOfEight: Bifunctor is in base now :D
06:38:12 <ocramz> bifunctors.. hmmm
06:38:24 <ThreeOfEight> merijn: oh, nice
06:38:32 <ThreeOfEight> Now I want my type lambdas!
06:38:35 * ocramz needs to find a use case
06:39:51 <ely-se> ThreeOfEight: try Scala :P
06:40:05 <ThreeOfEight> meh
06:40:11 <ThreeOfEight> I have, and I wasn't convinced
06:40:12 <lpaste_> CpnStumpy pasted “boolean algebra?” at http://lpaste.net/140930
06:40:30 <ely-se> :[
06:40:36 <ThreeOfEight> but my colleague keeps advertising it to me, so I might have another look at it at some point
06:40:48 <CpnStumpy> ThreeOfEight: So there's my basic definition from what you're saying, hoe does that read for "Boolean Algebra" ? (Are my terms wreckedly wrong?) http://lpaste.net/140930
06:40:48 <ThreeOfEight> But local type inference is really painful
06:40:50 <paldepind> Gurkenglas: You helped me with some code a few days ago. I just wanted to say that I've got it working: http://lpaste.net/140603 . I managed to get your splendid suggestion working in a left fold way.
06:41:08 <ThreeOfEight> And allocating an object for every curried function call? I don't know.
06:41:14 <paldepind> Gurkenglas: I'm still not sure how you think an endo could be used though.
06:42:01 <ely-se> but there are type lambdas :P
06:42:17 <simon> can't I have a 'foo :: Gen String; foo | SomeOption `S.elem` opts = one thing; foo | otherwise = another thing'?
06:42:35 <ThreeOfEight> CpnStumpy: well, I think plus and times are usually referred to as conjunction/disjunction or ∧/∨
06:42:45 <simon> whoops, S.member
06:42:54 <ThreeOfEight> but plus and times work, too, I guess
06:43:19 <CpnStumpy> ThreeOfEight: good to know, I don't really know any of this stuff outside of Haskell...
06:43:22 <simon> it complains about conflicting definitions as if it sees them as separate. must it have explicit arguments for guards to work?
06:43:46 <ThreeOfEight> Well I've never really had anything to do with Boolean algebras myself. I have worked with lattices a bit.
06:43:54 <ThreeOfEight> There you'd just call them top/bottom/join/meet
06:44:28 <ely-se> hmm, lettuces
06:45:06 <ThreeOfEight> cf. https://hackage.haskell.org/package/lattices-1.3/docs/Algebra-Lattice.html
06:45:58 <ThreeOfEight> search for "BoundedLattice"
06:46:08 <ThreeOfEight> even has a Bool instance
06:46:24 <roelof> Can someone help me with the last problem : https://www.reddit.com/r/haskellquestions/comments/3ksahe/how_to_test_this_without_using_the_code_twice/
06:48:11 <wwwwww> hi all together. I want to develop wizards to help write definitions, expressions, functions and then wizards which use the former to build datastructures and more complex expressions etc.
06:48:14 <ThreeOfEight> roelof: for starters, I recommend /not/ using Float
06:48:46 <roelof> ThreeOfEight:  I know. The assignment demands to use float 
06:48:47 <ThreeOfEight> this problem can easily be solved with discrete computations on integers; bringing in fixed-precision numbers with rounding is not a good idea in these cases.
06:48:52 <ThreeOfEight> Wow, that is silly.
06:49:02 <ThreeOfEight> I used to chastise my students for using float in these cases.
06:49:10 <wwwwww> Did anyone start such a thing? Or dou you have some tip(s) for starting? 
06:49:58 <roelof> I know. I use the Craft 3 edition for self study and it demands to use Float on the exercises on chapter 3 
06:50:35 <ThreeOfEight> runeks: what about "howManyAboveAverage nr1 nr2 nr3 = aux nr1 + aux nr2 + aux nr3"
06:50:52 <ThreeOfEight> where "aux x = if x > average then 1 else 0"
06:51:14 <roelof> ThreeOfEight:  If you mean this what does aux 
06:51:20 <CpnStumpy> How on earth is this erroring with cannot find monoid instance: (Just 5) `mappend` (Just 4)
06:51:38 <CpnStumpy> (Maybe has a standard monoid definition in the lib doesn't it??)
06:51:50 <ThreeOfEight> CpnStumpy: the problem is that monoids make sense both for (+) and for (*)
06:51:52 <Intolerable> unfortunately, yes
06:52:02 <wwwwww> the wizards will get commandline and some (lightweight) gui interface
06:52:03 <catgocat> Can anyone confirm that the method length of the Foldable class was only added recently? And if so, in which GHC version does it first show up ?
06:52:19 <catgocat> s/does/did
06:52:31 <ThreeOfEight> you can tag your numbers with "Sum" or "Product" to say which one you want
06:52:43 <wwwwww> and later they should be "programmable" (scriptable)
06:52:45 <ThreeOfEight> cf. https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html
06:53:00 <ThreeOfEight> > Just (Sum 5)) `mappend` (Just (Sum 4))
06:53:01 <lambdabot>  <hint>:1:13: parse error on input ‘)’
06:53:12 <ThreeOfEight> > Just (Sum 5) `mappend` Just (Sum 4)
06:53:14 <lambdabot>  Just (Sum {getSum = 9})
06:53:27 <ThreeOfEight> roelof: Hm? I just posted the definition of aux
06:54:15 <roelof> ThreeOfEight:  then I missed it, Can you repost it 
06:54:20 <geekosaur> catgocat, length is missing from 7.8's Data.Foldable
06:54:25 <av_> quit
06:54:32 <ThreeOfEight> "aux x = if x > average then 1 else 0"
06:54:48 <_d0t> https://bpaste.net/show/fd1d8c33b29f
06:54:58 <ThreeOfEight> You can, of course, also use length and (filter or list comprehensions)
06:54:58 <catgocat> geekosaur: yeah, I have 7.6
06:55:15 <_d0t> this doesn't compile because IP and IPRange are different types obviously. Is there a way I could 'cast' values or something?
06:55:27 <ThreeOfEight> but seeing as you're learning, I thought a solution without lists might be more appropriate
06:56:04 <roelof> ThreeOfEight:  I only did chapter 3 and then no map, filter or list are mentioned 
06:56:21 <ThreeOfEight> Yes, I thought so.
06:56:47 <roelof> ThreeOfEight:  Do you know a good learning resource. I know use the Craft book and still a lot is not clear to me 
06:56:54 <geekosaur> _d0t, there is no general "cast" mechanism
06:57:37 <_d0t> geekosaur: I think I made the question sound wrong
06:58:06 <ThreeOfEight> roelof: in our lecture, we always recommended "Haskell - The Craft of Functional Programming" by Thompson
06:58:07 <programo> If I paste the code in lpaste, for how many days does the lpaste link to my code survive?
06:58:12 <ThreeOfEight> and "Programming in Haskell" by Hutton
06:58:23 <ThreeOfEight> I have read neither of them so I cannot really say anything about them.
06:58:31 <geekosaur> programo, forever for a public paste. I don't know for private but was under the impression those expired
06:58:40 <wwwwww> My plan is to stack these wizards so that they all form a IDE of some sort. A IDE for Haskell in this case.
06:58:42 <roelof> ThreeOfEight:  the first I use now. Maybe look at the second one 
06:58:51 <programo> geekosaur, Thank you!
06:59:00 <ThreeOfEight> I had a few looks at "Learn you a Haskell for Great Good" by Lipovača", which is free online
06:59:10 <hodapp> wwwwww: just don't call them 'stack' :P
06:59:12 <ThreeOfEight> I have heard varying opinions on that one
06:59:16 <frerich> roelof: I like 'Programming in Haskell' by Graham Hutton a lot, and (even though it appears to be really unpopular around here...) "Learn You A Haskell" explained a few things quite nicely, too.
06:59:45 <frerich> roelof: There is no "silver bullet" though IMHO, you'll end up mixing and matching from various sources either way. :-)
06:59:58 <wwwwww> hodapp: No, i will not.
07:00:07 <Gurkenglas> paldepind: I saw this pattern http://lpaste.net/140603 and found the (a -> a) and (b -> b) to look very endo-y; it's probably wouldn't work to use Endo here because of that a ->. Also because you're using left folds.
07:00:16 <ThreeOfEight> I think I never used any textbooks to learn programming maself
07:00:17 <ThreeOfEight> *myself
07:00:39 <Gurkenglas> (I shuffled around the parameters of your add* functions a little
07:00:40 <Gurkenglas> *)
07:00:44 <roelof> oke, I will take a look at Hutton book. I hope it has many exercises so I check if I understand things right 
07:00:54 <geekosaur> @where cis194
07:00:54 <lambdabot> http://www.seas.upenn.edu/~cis194/spring13/
07:01:36 <roelof> geekosaur:  I read this books as a start to I can better do CIS194
07:01:37 <geekosaur> _d0t, I don;t know anything about the IP or IPRange type so I can't say much more than I did. I would *guess* there is a way to decompose an IPRange
07:01:54 <Gurkenglas> (Maybe with "State a (Endo b)"...)
07:02:24 <ThreeOfEight> roelof: you can also try looking at university lectures and tutorials
07:03:05 <ThreeOfEight> I would imagine there are tons of tutorial exercises and solutions online (I would post ours, but they are in German)
07:03:06 <paldepind> Gurkenglas: I'm afraid that is over my head. Would it make the code cleaner?
07:04:44 <hodapp> ThreeOfEight: post them anyhow, some of us can read German... or pretend to
07:04:53 <Gurkenglas> Probably not for a while, except if the code is mathematically canonical enough to simplify, which I don't think it'll be because of the left fold :P. At this point I'm just having fun introducing more math.
07:05:12 <ThreeOfEight> hodapp: http://www21.in.tum.de/teaching/info2/WS1415/uebungen.html
07:05:18 <programo> I am not able to copy the code from VIM editor to lpaste .Can anybody help me with it.I have tried Yank , but not successful
07:05:38 <ThreeOfEight> hodapp: there are English lecture slides, too: http://www21.in.tum.de/teaching/info2/WS1415/slides.pdf
07:06:17 <int-index> how do I call the first argument of `foldMap`? a "monoidal mapping"?
07:06:27 <zomg> programo: "+y (yes those are all chars you need to type out) in normal mode yanks to the clipboard assuming your vim was compiled with clipboard support
07:06:51 <zomg> + is the clipboard register
07:06:54 <mariusmarius> programo, if you are on linux you can do "cat file | xclip" and it will send it to your clipboard
07:07:06 <paldepind> I don't think I can get right of the left fold. I noticed that the problem was harder to express with a left fold but I needed it because the numbers would be reversed either..
07:07:15 <Trentil> exit
07:07:38 <Gurkenglas> int-index: https://hackage.haskell.org/package/newtype-0.1/docs/Control-Newtype.html tentatively calls it a "packer".
07:07:43 <paldepind> One option would be decrement the counter. That would probably allow for a right fold.
07:10:48 <int-index> Gurkenglas: it doesn't even have the `Monoid` constraint there
07:10:58 <Gurkenglas> I think the reason I proposed Endo is because I have so little context. Seeing the space of imaginable possibilities the code resides in would hint at what abstractions ought to be used
07:11:57 <Gurkenglas> int-index: Yes, it calls it a packer for all such functions. alaf Alt foldMap = "asumMap" is another, which uses Alternative.
07:13:03 <Gurkenglas> (Another is traverse/mapM)
07:13:23 <int-index> I'm insterested in a term for functions that return a monoid. `a -> Bool` is called a predicate, and `Monoid m => a -> m` is called a what?
07:13:46 * hackagebot text-show 2.1.1 - Efficient conversion of values into Text  https://hackage.haskell.org/package/text-show-2.1.1 (ryanglscott)
07:16:13 <ThreeOfEight> I don't think there is a name for that
07:16:22 <Intolerable> monoidifier
07:16:24 <Intolerable> monoidizer
07:16:34 <Intolerable> monoidificator
07:16:37 <ThreeOfEight> There might be terms for more specific a's
07:17:05 <ThreeOfEight> if the function fulfils certain laws
07:17:35 <lpaste_> CpnStumpy pasted “What is this ? Is nonsense?” at http://lpaste.net/140933
07:18:04 <int-index> Well, ok, I'll call it "a mapping into a monoid"
07:18:21 <CpnStumpy> I use all 3 of those structures often enough - and as you can see they have literally identical implementations derived from monoid
07:18:49 <nshepperd> int-index: you could abuse terminology horribly be calling it an algebra
07:19:21 <nshepperd> since once you foldMap it you do get 'f a -> m'
07:19:41 <CpnStumpy> I figure somebody else has given a definition to the structure before. The boolean impl is well-formed because it's an unparameterized type, but the type parameters make the negation seem less correct
07:19:52 <nshepperd> probably not a good idea I guess
07:20:13 <int-index> CpnStumpy: https://en.wikipedia.org/wiki/Template:Group-like_structures
07:20:46 <int-index> maybe something from this table?
07:21:22 <ThreeOfEight> Well CpnStumpy has two operations
07:21:32 <ThreeOfEight> Group-like structures only have one
07:21:49 <CpnStumpy> it's *useful* in programming is the only reason I care. I use it for selecting left or right down a decision tree structure - we all use maybe and either in that way really
07:22:13 <CpnStumpy> ThreeOfEight:  Which is why "groups" were really throwing me for a loop when I was looking at that
07:23:33 <nshepperd> int-index: ooh, 'projection' or 'monoid projection'
07:24:00 <simon> is it correct that QuickCheck's Gen is not based on any GenT included in the QuickCheck package? it seems that I had to get QuickCheck-GenT to make this happen, and it causes a lot of naming conflicts between Test.QuickCheck and QuickCheck.GenT ...
07:24:25 <Gurkenglas> CpnStumpy: Looks kinda like Alternative
07:25:14 <CpnStumpy> Gurkenglas:  very similar! That's typically what we all use maybe and either with... mappend and alternative
07:25:28 <CpnStumpy> Example use being: log x = writeToFile x `conjunction` fixFile x `disjunction` writeToFile x `conjunction` writeToDb x
07:25:56 <int-index> nshepperd: monoid projection sounds right, thanks
07:26:08 <geekosaur> simon: qualified imports are a thing
07:26:19 <nshepperd> simon: yeah, it's just 'data Gen = ...'. is there some reason you can't use ThingT Gen instead of GenT Thing though?
07:26:39 <geekosaur> even a common thing in some cases (e.g. Data.Map has a lot of conflicts with Prelude)
07:27:05 <CpnStumpy> Gurkenglas: I'm just surprised everyone uses alternative and mappend in concert for that precise type of behaviour, yet the cooperative effect between these two isn't a well defined relationship that I've noticed? I've defined multiple arbitrary structures with varying amounts of extra info that have that sympathetic relationship between two functions...
07:27:29 <simon> nshepperd, I don't think I can use Gen's combinators on such a ThingT Gen without explicit lifting? with GenT, there are some instances written for me.
07:27:39 <nshepperd> oh, the package has the STM example, that makes sense
07:28:04 <CpnStumpy> It's pretty easy to come up with an arbitrary structure to meet that sympathetic functionality for the described purpose. But it's not been generalized... (alternative doesn't always work as I expect either...)
07:28:22 <CpnStumpy> or rather, I don't know the named generalization
07:28:47 * hackagebot zero 0.1.3 - Semigroups with absorption  https://hackage.haskell.org/package/zero-0.1.3 (DimitriSabadie)
07:28:47 <simon> geekosaur, I'm trying to go with selective imports from Test.QuickCheck and everything from QuickCheck.GenT, since that's where the GenT-compatible combinators are.
07:29:25 <simon> geekosaur, maybe I should just get over myself and use G.listOf (G.choose (x, y)) and not think that looks bad.
07:29:59 <nshepperd> yeah, better to do that
07:30:01 <simon> geekosaur, I've accepted it with Data.Map, so why not!
07:31:13 <Gurkenglas> CpnStumpy: usually we use Applicative, not mappend, and alternative already has applicative as a superclass, so alternative is probably even closer than you think, though Bool isn't included.
07:33:50 * geekosaur wonders if the "with"/"open" proposal got so badly bikeshedded as to be dead...
07:34:03 <geekosaur> (basically, locally unqualifying names)
07:34:46 <simon> sounds like an adequately unproblematic feature to be bikeshedded.
07:35:32 <frerich> Anybody here familiar with mysql-simple? What's a nice way to optionally add clauses to a query (e.g. an optional LIMIT or a 'WHERE foo LIKE bar' clause)? Concatenating strings seems a bit wrong.
07:35:53 <frerich> ...especially because the documentation explains that the 'Query' newtype 'makes it difficult to construct queries from fragments of strings'
07:37:06 <simon> frerich, I don't think there is an inexpensive way to get to a type-safe query framework from mysql-simple. maybe by using the formatting package.
07:38:47 * hackagebot event 0.1.2 - Monoidal, monadic and first-class events  https://hackage.haskell.org/package/event-0.1.2 (DimitriSabadie)
07:42:31 <CpnStumpy> Gurkenglas: Perhaps so.. does `<|>` give the same behaviour for conjunction I'm looking for? Then I presume `<*>` for disjunction?
07:43:03 <CpnStumpy> Gurkenglas: Perhaps so.. does `<|>` give the same behaviour for conjunction I define there? Then I presume `<*>` for disjunction? What is `applicative`s definition for `identity` ?
07:43:22 <CpnStumpy> sorry I mean alternative's definition for `identity`
07:45:59 <CpnStumpy> Gurkenglas: You might be right, this description here: A monoid on applicative functors - does kind of sound like an appropriate structure... maybe and either are both applicative functors (bool obviously isn't because it's unparameterized though...), and a monoidal extension gives them conjunction...
07:48:32 <Gurkenglas> CpnStumpy: (I think you got your words conjunction and disjunction mixed up, they usually stand for and and or respectively. conjunction of two (Maybe a)s should require both to be just.)
07:49:37 <Gurkenglas> :t (*>)
07:49:38 <lambdabot> Applicative f => f a -> f b -> f b
07:49:45 <Gurkenglas> :t (<|>)
07:49:46 <lambdabot> Alternative f => f a -> f a -> f a
07:51:31 <Gurkenglas> > [Just 1 *> Just "asd", Nothing *> Just "asd", Just 1 *> Nothing, Just "dsa" <|> Just "asd", Nothing <|> Just "asd", Just "dsa" <|> Nothing]
07:51:33 <lambdabot>  [Just "asd",Nothing,Nothing,Just "dsa",Just "asd",Just "dsa"]
07:53:32 <voidzero> Useful for Either, right?
07:53:48 * hackagebot text-show-instances 2.1 - Additional instances for text-show  https://hackage.haskell.org/package/text-show-instances-2.1 (ryanglscott)
07:54:40 <frerich> simon: Pity, there's https://hackage.haskell.org/package/mysql-simple-quasi which looks great but doesn't compile with ghc 7.10.2 AFAICS :-(
07:58:48 * hackagebot stickyKeysHotKey 0.1.0.2 - get and set STICKYKEYS.SKF_HOTKEYACTIVE  https://hackage.haskell.org/package/stickyKeysHotKey-0.1.0.2 (SoenkeHahn)
08:07:15 <CpnStumpy> Gurkenglas: Perfect! Thanks, so the generalization I'm looking for is basically a monoid extension to applicative functor ca Alternative - that's why I could tell it's monoid specific but something more and couldn't put my finger on it..
08:08:06 <simon> :t liftM (++)
08:08:07 <lambdabot> Monad m => m [a] -> m ([a] -> [a])
08:08:20 <simon> @hoogle Monad m => m [a] -> m ([a] -> [a])
08:08:21 <lambdabot> Prelude showString :: String -> ShowS
08:08:22 <lambdabot> Text.Show showString :: String -> ShowS
08:08:22 <lambdabot> Text.Show showListWith :: (a -> ShowS) -> [a] -> ShowS
08:09:13 <simon> err.
08:09:22 <simon> :t liftM2 (++)
08:09:23 <lambdabot> Monad m => m [a] -> m [a] -> m [a]
08:09:33 <simon> @hoogle Monad m => m [a] -> m [a] -> m [a]
08:09:34 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
08:09:34 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
08:09:34 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
08:11:14 <CpnStumpy> Is it safe to say - the Alternative type class causes a Semiring
08:11:43 <CpnStumpy> (gives rise to? However you wish to put it)
08:14:16 <clrnd> :t fmap concat
08:14:18 <lambdabot> (Functor f, Foldable t) => f (t [a]) -> f [a]
08:26:29 <beginhas> hello all. 
08:26:44 <beginhas> I am trying to use the upenn course to learn haskell. 
08:27:06 <beginhas> y :: Int y = y + 1
08:27:16 <beginhas> I am on lesson 1. At the very beginning. 
08:27:24 <beginhas> It says y :: Int
08:27:41 <beginhas> so y is defined as type Int. 
08:27:53 <beginhas> y is defined as y + 1
08:28:12 <beginhas> If Y cannot be changed as defined later. How does this work? 
08:28:50 * hackagebot binary-communicator 1.0.2.2 - Flexible way to ease transmission of binary data.  https://hackage.haskell.org/package/binary-communicator-1.0.2.2 (SoenkeHahn)
08:28:52 * hackagebot graphql 0.2 - Haskell GraphQL implementation  https://hackage.haskell.org/package/graphql-0.2 (jdnavarro)
08:29:57 <dmj`> beginhas: that's an infinite loop, the purpose is to portray that the '=' sign doesn't denote assignment (in an imperative sense), but definition
08:30:17 <roelof_> Hello, I have to test a function that calculates how many numbers are above a average of 3 numbers.
08:30:29 <beginhas> dmj`: So, it will not work right?
08:30:30 <roelof_> So far I have this : http://lpaste.net/140934
08:30:37 <tippenein> How do I get a value parsed from Aeson's Object to String? like here: http://lpaste.net/140952
08:30:42 <dmj`> @def y' = y' + 1
08:30:46 <roelof_> but when I do quickcheck on the last test ( prop_howManyAboveAverage_three) it fails with 0 0 0 but that case is already tested. How can I tell quickcheck to use 3 different numbers 
08:30:46 <lambdabot>  Defined.
08:30:47 <dmj`> > y'
08:30:52 <lambdabot>  mueval-core: Time limit exceeded
08:30:56 <dmj`> ^ 
08:31:05 <dmj`> beginhas: right
08:31:17 <tippenein> the instance of FromJSON is the problem with d being a Value instead of a String
08:31:35 <beginhas> also, i have ghci prompt. I tryied 
08:31:41 <beginhas> x :: int
08:31:46 <beginhas> x = 1
08:31:47 <tippenein> I'd preferrably derive generic
08:32:13 <beginhas> <interactive>:11:1: Not in scope: ‘x’
08:32:32 <beginhas> I get this as soon as i try the first line ...
08:32:39 <beginhas> What am I doing wrong?
08:32:54 <greg`> what is the go to library for matrix operations
08:32:57 <clrnd> beginhas, in ghci you need to use let
08:33:04 <clrnd> like this: `let x = 1`
08:33:07 <greg`> btw, started using stack am very happy with it
08:33:09 <clrnd> it's like a big do block
08:33:43 <beginhas> so how do I follow the lectures? if it won't work as is?
08:33:45 <clrnd> also, you can `let x::Int ; x = 1`
08:34:02 <clrnd> beginhas, for following as is you can save a file a `runhaskell myfile.hs`
08:34:22 <clrnd> or build it with `ghc --make myfile.hs && ./myfile`
08:34:33 <beginhas> thanks clrnd !
08:34:57 <delYsid> Why is it that GHC compiled executables are so huge, even if they just do "Hello World!"?
08:35:04 <KaneTW> run-time system
08:35:06 <dmj`> delYsid: the runtime system is usually linked with it
08:35:12 <beginhas> is there a way to use the lhs file talked about in the lecture to do this faster? 
08:35:22 <beginhas> Or must I create a new file each time with each example?
08:35:26 <KaneTW> yes. copy-paste it into a .lhs file and ghc it
08:35:30 <beginhas> dmj`: thank you for the explanation ...
08:36:09 <roelof_> clrnd:  can you help me ? 
08:36:10 <beginhas> KaneTW: so I can run all the programs at once in the lhs file for the lesson? 
08:36:13 <delYsid> dmj`: ahhh. Can it be linked dynamically, so that I can see how much actual code the resulting executable contains?
08:36:22 <clrnd> roelof_, sure! hi
08:36:49 <KaneTW> beginhas: can you link the lesson
08:36:53 <beginhas> clrnd: Thanks I was fluxmmoxed right erhe ...
08:37:06 <roelof_> clrnd:  hello, I did ask on 17:30 
08:37:25 <beginhas> KaneTW:http://www.seas.upenn.edu/%7Ecis194/spring13/lectures/01-intro.lhs
08:37:26 <clrnd> roelof_, it's not even close to 17.30 where I live :P
08:37:35 <clrnd> but le tme see, I've found it
08:37:47 <phadej> Can someone with strictness/performance experience comment on https://github.com/isomorphism/these/issues/32
08:38:01 <roelof_> sorry, that I live in Europe :( 
08:38:02 <Qndel> hey
08:38:18 <Qndel> do you know how to display text in opengl?
08:38:30 <muesli4> Is there anyone with experience in gtk2hs? In case of missing functions (they exist in the comments and the C version), what can I do about it?
08:39:34 <KaneTW> beginhas: you can ghci it and then look at the expressions by typing in their identifier
08:40:15 <dmj`> delYsid: unsure, I've never tried, the GHC user guide might shed some light on that
08:40:19 <beginhas> KaneTW:  how do I do that? 
08:40:26 <Qndel> hey KaneTW, do you know how to display text in opengl?
08:40:43 <KaneTW> Qndel: no, no idea
08:40:46 <Qndel> I've tried using renderString but then my whole screen just goes black ;(
08:40:57 <KaneTW> beginhas: save-as the file, ghci 01-intro.lhs
08:41:10 <beginhas> KaneTW: sorry, I have no idea of programming and this is the deepend ...
08:41:10 <clrnd> roelof_, well, the easiest thing would be to just code the test to return True when the three are the same
08:41:16 <beginhas> KaneTW: ok
08:42:11 <roelof_> clrnd:  oke, but do I not test things double. I already tested that 
08:42:58 <KaneTW> Qndel: https://wiki.haskell.org/OpenGL#I_can.27t_display_text_with_renderString
08:43:53 <beginhas> KaneTW: did as you suggested
08:44:20 <beginhas> then tried y, it's still evaluating the infinite loop. How do I get out? 
08:44:22 <clrnd> roelof_, the other option is to use a newtype, but I'd go with the first one
08:44:46 <beginhas> Ok did ctrl-c
08:44:53 <KaneTW> what was y again?
08:45:02 <Qndel> still nothing
08:45:02 <KaneTW> y will always be an infinite loop
08:45:07 <beginhas> y :: int
08:45:10 <Qndel> I've tried messing with scale, the screen is always black
08:45:11 <beginhas> y = y + 1
08:45:14 <KaneTW> yeah
08:45:29 <KaneTW> basically bindings like that are recursive in haskell
08:45:45 <beginhas> y :: Int 
08:45:46 <KaneTW> you can't reassign to a variable so it tries to do y = y + 1, then y = (y+1) + 1, and so on
08:46:00 <ThreeOfEight> You /want/ "y = y + 1" to be undefined/looping
08:46:15 <beginhas> KaneTW: ok that makes sense. 
08:46:34 <ThreeOfEight> anything else would be highly problematic, because "y = y + 1" is a specification that cannot possibly be fulfilled
08:46:48 <ThreeOfEight> since "y = y + 1" implies, subtracting y on both sides, "0 = 1"
08:47:23 <beginhas> why doesn't ghci give an error instead of accepting my input?
08:47:30 <Intolerable> because it's not wrong
08:47:37 <Intolerable> its just not what you want it to do / expect
08:47:44 <KaneTW> it'd have to give an erro for something like
08:48:08 <KaneTW> > let f = 1 : map (+) f in f
08:48:10 <lambdabot>      Occurs check: cannot construct the infinite type: a1 ~ a1 -> a1
08:48:10 <lambdabot>      Expected type: [a1]
08:48:10 <lambdabot>        Actual type: [a1 -> a1]
08:48:12 <KaneTW> eh,
08:48:14 <KaneTW> > let f = 1 : map (+1) f in f
08:48:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
08:48:25 <roelof_> clrnd:  oke, can you give a example how you would return True then ? Because the type definition would not allow it 
08:48:26 <programo> Could anybody help me solving this error? http://lpaste.net/140962
08:49:19 <KaneTW> beginhas: the issue with + is that in order to determine y, it has to evaluate all the way and as such never finishes. but when you have another data structure like lists, you can always evaluate only that part that you need
08:49:40 <suppi> programo, what is accu?
08:50:28 <programo> suppi, an accumulator to store the number of lists which have a length greater than 15
08:50:48 <suppi> programo, where is it defined?
08:50:55 <beginhas> KaneTW: I think I get what you are suggesting. But I should learn more before, I get lost here :)
08:51:25 <clrnd> roelof_, prop_howManyAboveAverage_three  x y z = (x == y && y == z) || howManyAboveAverage x y z == test_three x y z
08:51:27 <KaneTW> sounds good
08:51:28 <suppi> programo, the error you get is that accu is not in scope - the compiler can't find it
08:51:52 <Qndel> what would be the best way to store tuples of floats which would represent the coordinates where there is something and with ability to remove the tuples?
08:52:12 <Qndel> I must make some balls that I'll collect, so I have to store the positions and remove them as I eat them
08:52:13 <programo> suppi, it is one of the arguments to the function numberOfChains
08:52:33 <programo> Do I have to define the arguments in a function?
08:53:02 <KaneTW> Qndel: is the removal from the beginning or end of the structure?
08:53:06 <KaneTW> or random
08:53:11 <tippenein> > readTime defaultTimeLocale "Y-%m-%d" ("2015-01-01" :: Text) 
08:53:13 <lambdabot>      Not in scope: ‘readTime’
08:53:13 <lambdabot>      Perhaps you meant one of these:
08:53:13 <lambdabot>        ‘readFile’ (imported from Prelude),
08:53:14 <Qndel> random!
08:53:24 <Qndel> depends on the which field I encounter
08:53:26 <suppi> programo, your line 9, where is accu defined?
08:53:32 <suppi> programo, you have _ instead
08:53:45 <Qndel> if player visits a field, I want it to be removed
08:54:01 <roelof_> clrnd:  thanks, I see what you mean. I will try it as soon as my haskell box has started up 
08:54:13 <CpnStumpy> You're out of scope, they're out of scope, the whole system is out of scope!
08:54:36 <clrnd> Qndel, how do you index the balls? (x,y) ? an unique identificator?
08:54:49 <chpatrick> is there any benefit to haskell's alloca vs malloc/free, apart from the with.. style?
08:55:02 <Qndel> I don't do anything yet
08:55:02 <CpnStumpy> uniquely identifying balls... eesh, what a job.
08:55:04 <chpatrick> it looks like it just does an allocation anyway
08:55:13 <Qndel> they (x,y) will be (GLfloat,GLfloat)
08:56:32 <programo> suppi, I get it I have now used numberOfChains [] accu = accu and ran successfully. But is'nt numberOfChains [] _ = accu    correct, as _ can be anything
08:57:06 <roelof_> clrnd:  now its failing on 0 0 1 which is also tested on another test 
08:57:17 <KaneTW> Qndel: are your balls defined by their position?
08:57:21 <suppi> programo, it's not that _ can be anything, it cannot be anything. it's like not giving this argument to a name
08:57:25 <KaneTW> as in
08:57:30 <Qndel> yes
08:57:30 <roelof_> clrnd:  maybe make a big test on all cases instead of three seperate tests ? 
08:57:35 <KaneTW> Data.Map then
08:57:50 <KaneTW> Data.Set actually
08:57:56 <suppi> KaneTW, that's sounds really funny out of context :P
08:58:07 <KaneTW> lol
08:58:10 <programo> okay suppi , thank you!
08:58:20 <simon> is there any way to use guards that are monadic? e.g. the function declaration 'foo x | asks p = ...'
08:58:39 <suppi> programo, np
08:58:58 <tippenein> I misunderstand what OverloadedStrings does. I'm getting unexpected type Text when expecting String
08:59:04 <tippenein>   parseJSON (String d) = readTime defaultTimeLocale "Y-%m-%d" d
08:59:21 <roelof_> clrnd:  if I change it to this : prop_howManyAboveAverage_three  x y z =  (x == y || x == z || y ==z) || howManyAboveAverage x y z == test_three x y z 
08:59:48 <roelof_> then it fails also but now on seperate numbers :) 
09:01:34 <clrnd> roelof_, that you did returns equal if no number of those 3 is repetead, or if the test passes
09:01:46 <beginhas> Is this book in a usable state: http://haskellbook.com ?
09:02:03 <clrnd> then, if it fails, the test fails and the numbers are different to each other
09:02:27 <clrnd> if it fails == if the prop returns False
09:02:31 <roelof_> clrnd:  sorry I not understanding the question 
09:02:47 <clrnd> roelof_, basically, what input made it fail?
09:03:31 <KaneTW> beginhas: if you're self-learning just stick to cis194 imo because it has good exercises
09:03:38 <KaneTW> and exercises are probably the most important part
09:03:55 <beginhas> KaneTW: thanks, will do. 
09:04:07 <roelof_> 0 1 3 and the test is producing the wrong output namely 2 
09:05:59 <clrnd> roelof_, then, what's wrong is the test
09:06:16 <roelof_> im trying to figure out 
09:07:02 <roelof_> I think I made a thinking error by assuming if all three numbers are not equal to the average there will be 2 numbers greater then the average 
09:07:24 <roelof_> so back to the drawing table and test things on paper 
09:07:39 * edwardk waves hello.
09:07:46 <edwardk> KaneTW: cmake has been working out pretty well. https://github.com/ekmett/thc
09:09:48 <KaneTW> nice
09:12:40 <clrnd> roelof_, :D
09:15:05 <Qndel> how would I generate automatically all coordinates from -5,-5 to 5,5 ?
09:15:33 <chpatrick> working on a pure lens-based interface to libclang
09:15:34 <roelof_> I did managed to solve this piece this way : http://lpaste.net/140974
09:15:41 <chpatrick> dump the type of every function in scope in 11 lines: http://lpaste.net/140973
09:15:43 <edwardk> still not much there yet, but now cmake drives doxygen and i can get travis to test, etc. so i have enough i can actually proceed
09:15:45 <roelof_> I hope the experts are happy with it 
09:15:58 <edwardk> chpatrick: nice!
09:16:05 <clrnd> > [-5..5] >>= \x -> [-5..5] >>= \y -> return (x, y)
09:16:07 <lambdabot>  [(-5,-5),(-5,-4),(-5,-3),(-5,-2),(-5,-1),(-5,0),(-5,1),(-5,2),(-5,3),(-5,4),...
09:16:15 <clrnd> Qndel, ^
09:16:48 <CpnStumpy> damnit alternative is confusing - on lists alternative does exactly the same thing as mappend
09:17:19 <CpnStumpy> But on Maybe it doesn't
09:18:26 <chpatrick> CpnStumpy: there's more than one Monoid for Maybe
09:18:31 <CpnStumpy> on Maybe alternative *chooses* one or the other, on Lists alternative sums - this is why I wasn't happy with Alternative to round out the structure I meant
09:19:22 <chpatrick> CpnStumpy: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html#t:Alt
09:19:26 <CpnStumpy> chpatrick: And for list?
09:19:32 <chpatrick> also
09:20:55 <_d0t> is there a way to define a filter for persistent using raw sql?
09:21:47 <joco42> has anyone tried thirft with haskell ?
09:22:11 <tippenein> using deriveJSON depends on the location it's placed in the file?
09:23:01 <ChristianS> tippenei1: how do you mean?
09:23:06 <Qndel> go
09:23:07 <Qndel> god
09:23:11 <Qndel> haskell is my worst nightmare
09:23:34 <Qndel> I'm creating cubes but I can't see them, they appear only if I rotate the screen lol
09:23:46 <chpatrick> sounds like opengl fun
09:23:53 * hackagebot monoidal-containers 0.1.2.3 - Containers with monoidal accumulation  https://hackage.haskell.org/package/monoidal-containers-0.1.2.3 (BenGamari)
09:24:18 <Qndel> yep
09:24:24 <CpnStumpy> chpatrick: and... how do I choose the different list monoids so I can get a choosey alternative rather than an accumulative one?
09:25:07 <chpatrick> CpnStumpy: so you want all or nothing basically right?
09:25:43 <chpatrick> Qndel: don't blame haskell then
09:26:26 <CpnStumpy> chpatrick: I want `[3] <|> [4] = [3]` and `[] <|> [4] = [4]`
09:26:50 <chpatrick> ok, I would recommend a newtype wrapper then
09:27:01 <chpatrick> or just forget about alternative and make a function that does that
09:27:06 <chpatrick> unless you need the instance for something
09:27:27 <CpnStumpy> chpatrick: I've done it a bunch of times - what I want is to find how/where I can get this behaviour out of some standard or common libraries
09:27:44 <chpatrick> ah
09:27:51 <chpatrick> I don't know of a built in "choosy" list
09:28:06 <CpnStumpy> it's not an issue of how to do it - I can easily enough create my own classes, I've been trying to put a pin in naming this behaviour so I can get reuse out of some community resources
09:28:53 * hackagebot smoothie 0.4.1 - Smooth curves via several interpolation modes  https://hackage.haskell.org/package/smoothie-0.4.1 (DimitriSabadie)
09:29:05 <chpatrick> maybe you could make a newtype Choosy f a = Choosy (f a)
09:29:07 <CpnStumpy> chpatrick: from hackage's monoid page - the behaviour is identical to the boolean monoid under disjunction
09:29:19 <chpatrick> and a class IsNull a where isNull :: a -> Bool
09:29:38 <chpatrick> or rather
09:29:47 <chpatrick> class IsNull f where isNull :: f a -> Bool
09:29:59 <chpatrick> and then and then instance IsNull f => Alternative (Choosy f) where ...
09:30:33 <chpatrick> so you would factor out the choosing and the criterion for whether something should be chosen
09:31:05 <exio4> @type null
09:31:06 <lambdabot> Foldable t => t a -> Bool
09:31:17 <exio4> Foldable already has null (and lots of other things, but..)
09:32:45 <chpatrick> ah I didn't know it was in Foldable
09:32:53 <chpatrick> sweet then
09:33:05 <chpatrick> instance Foldable f => Alternative (Choosy f) where
09:33:52 <hackrilege> @let cata f = f . fmap (cata f)
09:33:53 <lambdabot>  .L.hs:151:14:
09:33:53 <lambdabot>      Couldn't match kind ‘*’ with ‘* -> *’
09:33:53 <lambdabot>      When matching types
09:37:27 <hackrilege> @let hylo f e g = f . e .(fmap (hylo f e)).g
09:37:28 <lambdabot>  .L.hs:151:1:
09:37:29 <lambdabot>      Equations for ‘hylo’ have different numbers of arguments
09:37:29 <lambdabot>        .L.hs:(151,1)-(152,26)
09:37:29 <hackrilege> oh dear
09:37:42 <hackrilege> sorry
09:38:49 <hackrilege> @let hylo f e g = f . e .fmap . (hylo f e g).g
09:38:51 <lambdabot>  .L.hs:151:1:
09:38:51 <lambdabot>      Equations for ‘hylo’ have different numbers of arguments
09:38:51 <lambdabot>        .L.hs:(151,1)-(152,26)
09:38:53 * hackagebot woot 0.0.0.5 - Real time group editor without operational transform.  https://hackage.haskell.org/package/woot-0.0.0.5 (tgolson)
09:39:35 <hackrilege> :t hylo
09:39:36 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
09:40:21 <hackrilege> ok its already there, i think the definition used was hylo fe f = fe . fmap . (hylo fe g).g
09:42:01 <hackrilege> \msg lambdabot
09:42:02 <quchen> hylo f g = cata f . ana g -- that one?
09:42:39 <hackrilege> yeh that one, but i dont want to have to give lamdabot the Fix data constructor
09:43:47 <quchen> Why not?
09:43:53 * hackagebot rose-trees 0.0.2 - A collection of rose tree structures.  https://hackage.haskell.org/package/rose-trees-0.0.2 (athanclark)
09:44:07 <quchen> ?let data Fix' f = Fix (f (Fix f))
09:44:08 <lambdabot>  .L.hs:149:23:
09:44:08 <lambdabot>      Data constructor ‘Fix’ cannot be used here
09:44:08 <lambdabot>        (it is defined and used in the same recursive group)
09:44:14 <quchen> ?let data Fix' f = Fix' (f (Fix' f))
09:44:15 <lambdabot>  Defined.
09:45:22 <hackrilege> @let unFix (Fix f) = f
09:45:24 <lambdabot>  .L.hs:155:8:
09:45:24 <lambdabot>      Not in scope: data constructor ‘Fix’
09:45:24 <lambdabot>      Perhaps you meant one of these:
09:45:42 <quchen> ?let unFix (Fix' f) = f
09:45:43 <lambdabot>  Defined.
09:45:59 <hackrilege> ?let cata f = f . fmap (cata f) .unFix
09:46:00 <lambdabot>  .L.hs:153:30:
09:46:00 <lambdabot>      Couldn't match type ‘Fix' f’ with ‘Mu f’
09:46:00 <lambdabot>      Expected type: Mu f -> f (Mu f)
09:46:22 <quchen> cata is already used.
09:46:24 <hackrilege> :t cata
09:46:26 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
09:47:45 <hackrilege> i kind of dont want to spam up the board udefining everything and starting again
09:48:07 <quchen> You can do everything in a private session.
09:48:09 <quchen> Or in GHCi.
09:48:32 <hackrilege> can anyone point me to a minimal version of typeclassopidia, or in its absence, help me compile one
09:48:51 <Sonolin> newbie to haskell... I find a lot of the symbols xmonad uses confusing - what is the difference between --> -?> and -> for example?
09:48:54 <hackrilege> quchen, im on a phone and am struggeling to build haskell projects on android for android
09:49:40 <quchen> Sonolin: -> is Haskell syntax, used in types, lambdas and case blocks. The other two are non-standard and defined in some library.
09:49:54 <Sonolin> oh ok cool that makes more sense
09:49:55 <hackrilege> i dont know how you managed to find a symbol iv never seen as a noob...
09:50:02 <Sonolin> xmonad >.>
09:50:22 <Sonolin> they also use <*> and <&&> a lot, are these standard or no?
09:50:29 <quchen> Sonolin: Usually there's some nomenclature behind operators like that that makes them make sense. But yes, seeing them at first is kind of confusing.
09:50:32 <quchen> <*> is standard, yes.
09:50:33 <hackrilege> :t <*>
09:50:34 <lambdabot> parse error on input ‘<*>’
09:50:46 <quchen> <&&> isn't but it's probably analogous to <**>.
09:50:47 <hackrilege> :t (<*>)
09:50:48 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
09:51:19 <Sonolin> hmm interesting
09:51:30 <hackrilege> :t (<**>)
09:51:32 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
09:51:33 <quchen> Custom operators are something people tend to overuse, which makes the code hard to read. :-|
09:51:46 <quchen> I use them too, but only with very local scope so you don't have to dig for the definition.
09:51:49 <hackrilege> totally
09:52:20 <Sonolin> well I'm glad I'm not the only one confused, I'll just keep working through learnyouahaskell that <*> seems cool
09:52:21 <hackrilege> but then i guess when you see them everywhere it probably means you should know what they are
09:52:44 <hackrilege> i have yet to find a use for it
09:52:50 <quchen> Sonolin: <*> is part of the Applicative class, which is kind of prominent in Haskell.
09:53:17 <quchen> Sonolin: But I had my difficulties with it as a beginner so I skipped it and came back after somewhat understanding monads.
09:53:35 <hackrilege> its about defining functions on parametrised types right?
09:53:54 * hackagebot wai-middleware-metrics 0.2.2 - A WAI middleware to collect EKG request metrics  https://hackage.haskell.org/package/wai-middleware-metrics-0.2.2 (Helkafen)
09:53:56 <hackrilege> monads are just applicatives with bind
09:53:56 <hackrilege> :t bind
09:53:57 <lambdabot>     Not in scope: ‘bind’
09:53:57 <lambdabot>     Perhaps you meant one of these:
09:53:57 <lambdabot>       ‘BS.find’ (imported from Data.ByteString),
09:54:05 <quchen> <*> = ap
09:54:14 <mniip> :t (=<<)
09:54:15 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:54:23 <quchen> mf `ap` mx = do { f <- mf; x <- mx; return (f x) }
09:55:37 <CpnStumpy> what do I import to get to the standard MaybeT?
09:55:55 <quchen> transformers?
09:56:01 <merijn> CpnStumpy: Blind guess: transformers?
09:56:17 <hackrilege> sorry i think i mean join
09:56:17 <hackrilege> :t join
09:56:18 <lambdabot> Monad m => m (m a) -> m a
09:56:24 <quchen> ?hoogle join
09:56:24 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
09:56:24 <lambdabot> package join
09:56:24 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
09:56:28 <CpnStumpy> merijn: `import transformers` doesn't sound very likely, maybe something more specific?
09:56:39 <hackrilege> yeh, thats the only difference between Applicative and Monad
09:56:59 <hackrilege> Monad also had join
09:56:59 <CpnStumpy> Google-fu just gives me endless tutorials on how to create monad transformers and a hackage page which tells me `MaybeT` is in `Control.Monad.Maybe` which it maybe used to was...
09:57:14 <quchen> Monad never had join.
09:57:20 <quchen> It either has join, or it never had join.
09:57:53 <joco42> CpnStumpy: I found your cube: http://lambdacube3d.com/editor.html
09:57:55 <quchen> join is a top-level definition, and it's always been. So it's not part of Monad (the class) but it can be defined with it.
09:57:57 <hackrilege> also has, thanks, sorry
09:58:55 <hackrilege> oh, i have missunderstanding? i though perhaps the other class defitintions could be defined in terms of those of Applicative and this join function
09:58:55 <CpnStumpy> merijn: Do you know the full module name to import for that? Google is failing me
09:59:02 <Sonolin> nice, this makes a lot of sense... love learnyouahaskell
09:59:03 <Sonolin> Just (+3) <*> Just 9  
09:59:30 <joco42> sorry it was meant to be addressed to Qndel 
09:59:36 <quchen> Prefix your expressions with "> ", Sonolin.
09:59:42 <quchen> Then Lambdabot will interpret them.
09:59:42 <joco42> the cubes
09:59:53 <Sonolin> > Just (+3) <*> Just 9  
09:59:54 <lambdabot>  Just 12
10:00:01 <Sonolin> :) thanks
10:00:18 <Sonolin> do I have to import something? says "<*> not in scope in ghci
10:00:18 <hackrilege> :t(  3 <?>)
10:00:29 <quchen> Sonolin: Control.Applicative, if you're before GHC 7.10
10:00:31 <merijn> CpnStumpy: Don't both with google for haskell, use hoogle :)
10:00:34 <kadoban> Sonolin: Control.Applicative, or upgread to GHC 7.10
10:00:34 <merijn> @where hoogle
10:00:34 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
10:00:35 <joco42> > len [1,2]
10:00:38 <lambdabot>      Not in scope: ‘len’
10:00:39 <lambdabot>      Perhaps you meant one of these:
10:00:39 <lambdabot>        ‘lens’ (imported from Control.Lens), ‘lex’ (imported from Prelude)
10:00:39 <merijn> CpnStumpy: And hayoo
10:00:51 <Sonolin> nice thanks 
10:01:00 <merijn> CpnStumpy: transformers is the package, if you look it up on hackage/hoogle you should find it somewhere in the index of the package
10:01:04 <merijn> Gotta run now
10:01:05 <joco42> length [1,2]
10:01:18 <CpnStumpy> merijn: ahh - I thought the transformers were a part of the base! My mistake.
10:01:19 <Ankhers> > length [1,2]
10:01:20 <hackrilege> with the >
10:01:21 <lambdabot>  2
10:01:21 <joco42> > length [1,2]
10:01:22 <lambdabot>  2
10:01:29 <joco42> cool
10:01:35 <joco42> it works :)
10:01:48 <joco42> my first lambdabot expression
10:02:02 <quchen> Congratulations. :-)
10:02:02 <hackrilege> hylo length ((take 5).repeat) []
10:02:12 <hackrilege> >hylo length ((take 5).repeat) []
10:02:12 <hackrilege> > hylo length ((take 5).repeat) []
10:02:14 <lambdabot>  5
10:03:04 <CpnStumpy> boy, at some point in the past year or two haskell mode in emacs was totally reworked - either that or I grabbed a totally different version than I had before
10:03:17 <hackrilege> is it good now?
10:03:18 <CpnStumpy> full of tips and hints and auto-affixing extensions, pretty cool
10:03:26 <hackrilege> nice
10:03:48 <CpnStumpy> hackrilege: It was good before, but it was very simplistic, now it does a bunch of extra interactive stuff
10:04:28 <hackrilege> i wish i could use proot on my phone, living without ghci is like going without food
10:04:31 <CpnStumpy> (or I always had it configured wrong in the past)
10:05:26 <hackrilege> well thanks for reminding me to give it a try when i get my hands on a kernal
10:15:53 <fatgoose> hi, I have a question about lenses
10:16:35 <fatgoose> or more specificaly about an excercise in the "lens over tea blogpost"
10:18:19 <cocreature> fatgoose: just ask your question :)
10:18:54 <fatgoose> -- Make a lens out of a getter and a setter.
10:18:54 <fatgoose> lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b
10:18:54 <fatgoose> lens get set = _
10:19:28 <fatgoose> i can't for the life of me figure out how to do this
10:20:05 <fatgoose> the part that confuses me the most is how to reflect the functor that is hidden inside Lens in the implementation
10:20:58 <quchen> :t lens (\(a,_) -> a) (\(_,b) x -> (x,b)) -- lens for the first element of a tuple.
10:20:59 <lambdabot> Functor f => (a -> f t) -> (a, t1) -> f (t, t1)
10:22:03 <fatgoose> so this is not supposed to be generic?
10:22:06 <quchen> For the inner workings, SPJ's talk is a good introduction, and Edward gave a talk about his viewpoint.
10:22:18 <quchen> Looks fairly generic to me.
10:22:40 <cocreature> I thought the exercise was about reimplementing the lens function yourself
10:23:12 <quchen> Ah, so that was the question.
10:23:41 <cocreature> :t \get set f s -> set s <$> f (get s)
10:23:42 <lambdabot> Functor f => (r1 -> r) -> (r1 -> a -> b) -> (r -> f a) -> r1 -> f b
10:24:42 <L8D> :t hylo
10:24:44 <lambdabot> Functor f => (f b -> b) -> (a -> f a) -> a -> b
10:25:58 <fatgoose> ok, thanks. I was somewhat thrown off by the function having only having two parameters in the excercise I guess...
10:26:14 <quchen> Lens hides a couple of parameters.
10:26:50 <cocreature> fatgoose: well you can return a lambda if you want to stick with two parameters
10:27:59 <fatgoose> ok, I will try that. thank you
10:34:48 <clrnd> https://github.com/search?utf8=%E2%9C%93&q=unsafePerformIO&type=Code&ref=searchresults
10:44:02 <Lacanaoe> Do I learn how to ultimate haxor here?
10:44:14 <arkeet> no.
10:44:20 <dgpratt> should I expect 'ghc-pkg unregister <target>' to warn or halt if other packages depend on <target>?
10:44:27 <arkeet> no.
10:44:33 <arkeet> well maybe it will warn about breakage.
10:44:35 <arkeet> I forget.
10:44:57 <Lacanaoe> I see...
10:46:22 <bitemyapp> arkeet: it'll warn about breakage which you can choose to blithely ignore.
10:46:54 <dgpratt> ok, thanks
10:48:15 <Lacanaoe> so what is haskell exactly?
10:48:27 <arkeet> it's a programming language
10:50:09 <clrnd> it's a mathematician, haskell curry
10:50:14 <Sonolin> its the devil, run away now
10:50:22 <XorSwap> join us
10:50:40 <XorSwap> > join us
10:50:41 <MarcelineVQ> It's too late for you, now you'll look into it and become interested
10:50:41 <lambdabot>      Not in scope: ‘us’
10:50:41 <lambdabot>      Perhaps you meant one of these:
10:50:41 <lambdabot>        ‘u’ (imported from Debug.SimpleReflect),
10:51:16 <KaneTW> @let us = repeat "us"
10:51:17 <lambdabot>  Defined.
10:51:19 <KaneTW> >join us
10:51:24 <KaneTW> > join us
10:51:25 <lambdabot>  "usususususususususususususususususususususususususususususususususususususu...
10:51:49 <XorSwap> beautiful
10:52:10 <clrnd> :t join
10:52:11 <lambdabot> Monad m => m (m a) -> m a
10:53:16 <MarcelineVQ> Lacanaoe: Haskell is a functional (as in mathmatical functions) language that has been around for a long time and is becoming increasingly popular as people find out about its time saving benefits.
10:54:39 <MarcelineVQ> There's all kinds of benefits it has, gurantees about how parts interact, reduced code side, easy refactoring and code maintenance, but it mostly comes down to saved time imo.
10:54:41 <Lacanaoe> is it a low level language?
10:55:12 <ReinH> Lacanaoe: it is a high level langauge
10:55:14 <MarcelineVQ> It's very high level but it can be as low as you need (in most cases) if you're willing to put in the effort, and there's libraries if you're not.
10:55:49 <Lacanaoe> well how exactly does it compare to say python? tons of libraries, easy to code, eyc...
10:55:59 <clrnd> hehe
10:56:00 <MarcelineVQ> That's a really broad question
10:56:07 * clrnd sits back and makes some coffe
10:56:08 <XorSwap> it's very mathematical
10:56:22 <XorSwap> no changing defined variables
10:56:23 <ReinH> Lacanaoe: https://www.haskell.org/ has a nice elevator pitch
10:56:27 <kadoban> It's a bigger learning step for most people, coming from the typical languages most people know. It has many libraries and it's easy to code in once you know it.
10:56:33 <mrkgnao> hey everyone.
10:56:33 <MarcelineVQ> But one answer could be, you can get started in python faster, but you'll end up spending less time debugging in haskell.
10:56:34 <ReinH> You might start there.
10:56:42 <XorSwap> technically no 'statements'
10:56:50 <Lacanaoe> I started with c++
10:56:56 <maerwald> Lacanaoe: not nearly as many libraries as python and not nearly as popular
10:56:57 <kadoban> It has a type system that will save you from many many bugs that python allows to bite you at runtime. It's far better for big projects where that matters a great deal.
10:57:08 <mrkgnao> if I qualified-import Data.Vector, aren't I supposed to get a V.show function?
10:57:18 <mrkgnao> I get a "not in scope" error.
10:57:21 <clrnd> mrkgnao, import qualified Data.Vector as V
10:57:25 <Lacanaoe> ah I see
10:57:30 <mrkgnao> I did.
10:57:49 <mrkgnao> I'm trying to make a Show instance for a little sum type I made.
10:57:50 <maerwald> kadoban: that's only true if you can find enough haskell developers
10:58:20 <mrkgnao> data Stack a = Stack (V.Vector a) Int
10:58:25 <ReinH> Lacanaoe: you might also find the answers to this question interesting http://stackoverflow.com/questions/26585170/in-what-way-is-haskells-type-system-more-helpful-than-the-type-system-of-another?rq=1
10:58:38 <kadoban> maerwald: It's not like haskell is that obscure, especially anymore.
10:58:41 <Lacanaoe> thanks dude
10:58:50 <ReinH> Hmm, that's not the one I was thinking of, but still maybe interesting
10:58:53 <mrkgnao> clrnd, any clue what might be a nice way I can fix this?
10:58:54 <maerwald> kadoban: I cannot find a single haskell developer in my city, so yes, it is
10:59:36 <maerwald> kadoban: I am just saying that if you want to go for "big projects" you also want a low entry barrier for contributions
10:59:46 <edwardk> yo
10:59:50 <maerwald> and lots of people who work on it
10:59:50 <ReinH> edwardk: o/
10:59:50 <edwardk> er wrong window
10:59:54 <ReinH> edwardk: :(
10:59:57 <edwardk> but o/ anyways =)
11:00:00 <clrnd> mrkgnao, mmm the Show typeclass is in Prelude
11:00:02 <Lacanaoe> yeah its good. so haskell works well with different variable types? i know that shit always gave me a headache with other languages
11:00:20 <mrkgnao> edwardk, I'm the guy whose /r/math post you replied to. hi :)
11:00:23 <clrnd> mrkgnao, I mean, sorry, paste the code and the error please
11:00:28 <monochrom> mrkgnao: put actual current code on lpaste
11:00:28 <kadoban> maerwald: I suppose it depends what you mean by big projects. I mostly meant something beyond toys, which is about the limit that I use python anymore.
11:00:29 <mrkgnao> okay, just a sec
11:00:31 <edwardk> mrkgnao: welcome to the fold =)
11:00:34 <ReinH> Lacanaoe: I would say that Haskell has the most powerful and expressive type system of any popular general purpose language
11:00:42 <maerwald> yeah
11:00:43 <mrkgnao> is that a pun?
11:00:44 <kadoban> maerwald: I have little experience using it with multiple contributors, because I mostly don't do that.
11:00:48 <GLM> maerwald:What would you consider one of those projects?
11:00:57 <edwardk> now it is
11:01:03 <maerwald> kadoban: then I wonder why you say it is useful for big project^^
11:01:06 <sunnymilk> hello
11:01:17 <kadoban> maerwald: Because I was using a different definition of a big project than you are.
11:01:18 <sunnymilk> is there a nice way to make haskell programs use a SOCKS proxy for http requests
11:01:27 <sunnymilk> im using wreq but id be willing to use something else
11:01:39 <sunnymilk> wreq and the http library can use http proxies i think
11:01:45 <sunnymilk> but i want to use a SOCKS one
11:01:51 <maerwald> GLM: darcs... and it has only ~4 people who really understand it. compare that with git/mercurial if you like
11:01:53 <Intolerable> there's a env var for it iirc
11:01:59 <ReinH> Lacanaoe: here's another nice summary http://stackoverflow.com/a/1604828/2225384
11:02:01 <sunnymilk> Intolerable really?
11:02:07 <sunnymilk> i tried using tsocks
11:02:14 <sunnymilk> but it doesnt seem to work with haskell programs
11:02:16 <GLM> maerwald:If few people know it, why would I use it?
11:02:26 <monochrom> I thought "http proxy" was already SOCKS proxy.
11:02:32 <kadoban> GLM: You probably wouldn't.
11:02:41 <lpaste_> mrkgnao pasted “No title” at http://lpaste.net/4562878143219630080
11:02:58 <GLM> kadoban:If I shouldn't use it, why does it exist?
11:02:59 <Intolerable> https://github.com/snoyberg/http-client/issues/153
11:03:02 <Intolerable> ah, i misremembered
11:03:04 <Intolerable> apologies
11:03:13 <monochrom> mrkgnao: replace "V.show" by "show". trust me. trust us.
11:03:13 <Lacanaoe> madshit gotta run guys thanks for the tip
11:03:18 <maerwald> GLM: what's your point, anyway? 
11:03:24 <mrkgnao> oh, okay.
11:03:28 <maerwald> your questions sound a bit random
11:03:32 <mrkgnao> oooooh.
11:03:35 <mrkgnao> I get it.
11:03:40 <Intolerable> "if i shouldn't use it, why does it exist?" because other people might need to use it
11:03:49 <kadoban> GLM: Because someone wrote it with the hope that it'd be useful, or some other consideration. I didn't write it, I dunno.
11:03:53 <mrkgnao> thanks!
11:03:54 <monochrom> yeah, the name "show" is from the Prelude not from Data.Vector.
11:04:08 <GLM> maerwald:Two parts. I'm looking for Haskell libraries to contribute to. Secondly, I'm interested in Darcs and am looking for an excuse to replace git with it
11:04:16 <monochrom> in Haskell the import statements say where the name comes from, not where the implementation comes from.
11:04:30 <maerwald> GLM: I've worked a little bit on darcsden... that has a lower entry barrier, but darcs is _very_ strong stuff
11:04:41 <mrkgnao> and the typeclass Show is in the Prelude, so . . . right.
11:04:46 <mrkgnao> thank you.
11:05:16 <GLM> maerwald:What do you mean by strong?
11:05:44 <maerwald> GLM: no documentation and complicated concepts behind it... all that patch theory stuff
11:06:03 <maerwald> (as in: code-level documentation)
11:06:12 <GLM> maerwald:Would you say that it'd be a good foray into Haskell dev?
11:06:24 <quchen> Another one sniped by the "self-documenting code" myth :-C
11:06:25 <monochrom> oh wait, my statement is inaccurate
11:06:33 <monochrom> but too long story.
11:06:36 <maerwald> GLM: as said... I'd rather recommend to start with darcsden
11:06:48 <maerwald> that's web development, but not that bad
11:07:06 <GLM> maerwald:Wouldn't you have to know darcs pretty well to do that?
11:07:16 <maerwald> depends on which parts you touch, but mostly no
11:08:57 * hackagebot HGamer3D 0.6.1 - Toolset for the Haskell Game Programmer  https://hackage.haskell.org/package/HGamer3D-0.6.1 (PeterAlthainz)
11:10:51 <maerwald> GLM: e.g. something we lack is (at least last I checked)... email notification for issues. To do that properly you'd have to extend the database format, add a few options to the web UI and then deal with sendmail functions
11:11:14 <GLM> I could probably do that
11:11:46 <maerwald> http://hub.darcs.net/simon/darcsden that's the main repository
11:16:09 <Denommus> is there any function to convert positive numbers to 1 and negative numbers to -1?
11:16:21 <arkeet> :t signum
11:16:23 <lambdabot> Num a => a -> a
11:16:34 <arkeet> > map signum [-3..3]
11:16:36 <lambdabot>  [-1,-1,-1,0,1,1,1]
11:19:40 <hodapp> http://www.haskelltree.com/ well, that's not what I was searching for...
11:20:38 <clrnd> jajaja
11:24:40 <clrnd> ;wa
11:24:46 <clrnd> lol this ain't vim
11:24:50 <monochrom> are you ok?
11:25:09 <clrnd> :P
11:25:58 <mizu_no_oto> monochrom: probably a focused-window error
11:28:58 * hackagebot xlsx 0.1.1.1 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.1.1.1 (KirillZaborsky)
11:29:56 <sunnymilk> how do you catch one of multiple specific exceptions
11:30:44 <mauke> depends on what you mean
11:30:45 <sunnymilk> like if you have a function f, and it can throw one of multiple distinct (as in, different types) exceptions, how do you run it, catch the exception, figure out what type it is, and then deal with it differently for each type
11:30:55 <mauke> ah, no
11:31:11 <mauke> you can only catch specific exceptions
11:31:35 <mauke> so you'd write a handler for each exception type, then attach them to the catch block
11:31:39 <KaneTW> :t catches
11:31:40 <lambdabot>     Ambiguous occurrence ‘catches’
11:31:40 <lambdabot>     It could refer to either ‘Control.Exception.catches’,
11:31:40 <lambdabot>                              imported from ‘Control.Exception’ at /home/lambda/.lambdabot/State/L.hs:46:1-24
11:31:44 <KaneTW> maybe?
11:31:50 <sunnymilk> hasnt it ever occured to anyone that thats ridiculous and nobody should use exceptions
11:32:20 <mauke> what's the problem with that?
11:32:32 <KaneTW> @unlet
11:32:32 <lambdabot>  Define what?
11:32:36 <KaneTW> @undef
11:32:36 <lambdabot> Undefined.
11:32:38 <KaneTW> :t catches
11:32:40 <lambdabot>     Ambiguous occurrence ‘catches’
11:32:40 <lambdabot>     It could refer to either ‘Control.Exception.catches’,
11:32:40 <lambdabot>                              imported from ‘Control.Exception’ at /home/lambda/.lambdabot/State/L.hs:49:1-24
11:32:44 <KaneTW> wha
11:32:46 * mauke rolls eyes at KaneTW 
11:32:59 <sunnymilk> there are a lot of problems with exceptions
11:33:05 <sunnymilk> for one they dont exist in the type system
11:33:06 <ReinH> https://hackage.haskell.org/package/lens-4.13/docs/Control-Monad-Error-Lens.html provides catches
11:33:12 <KaneTW> oh
11:33:15 <KaneTW> i'm dumb
11:33:15 <mauke> sunnymilk: that's a feature
11:33:25 <shachaf> Exceptions sound like a good idea, but there's a catch.
11:33:25 <arkeet> :t Control.Exception.catches
11:33:26 <lambdabot> IO a -> [Control.Exception.Handler a] -> IO a
11:33:34 <sunnymilk> error for example returns an "a", which is of course absurd - the value it returns inhabits every type
11:33:35 <monochrom> haha shachaf
11:33:39 <ReinH> catches allows you to supply a list of handlers
11:33:41 <KaneTW> what's the other catches it's referring to
11:33:46 <sunnymilk> mauke what possible advantage does this give us
11:33:57 <ReinH> arkeet: yeah, or that
11:34:12 <ReinH> Althoguh I really like lenses for dealing with exceptions
11:34:21 <sunnymilk> it gets even worse, because exceptions dont exist in the type system, you dont know what possible exceptions a piece of code can throw
11:34:21 <ReinH> sunnymilk: error is not an exception
11:34:40 <mauke> sunnymilk: being able to write middle-level code that is unaware of exceptions
11:34:42 <hackrilege> Lenses are not as general as hylomorphisms?
11:34:59 <shachaf> Hylomorphisms are too general.
11:35:00 <mauke> shachaf: I might steal that
11:35:04 <ReinH> error s is bottom, which must necessarily inhabit every type
11:35:13 <monochrom> sunnymilk: see my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
11:35:14 <ReinH> it isn't absurd at all
11:35:27 <hackrilege> I really struggle to see why I would want to use the lens library rather than just writing my own accessor methods, as the overhead is small...
11:35:39 * ww hasn't seen vex.net for a long time!
11:35:48 <mauke> I gave a talk about exceptions and their problems and error handling solutions beyond exceptions at a conference two weeks ago
11:36:12 <sunnymilk> "error handling solutions"
11:36:18 <ReinH> hackrilege: because lens provides far more than just accessor methods
11:36:22 <mauke> hackrilege: you can use the lens library with your own accessor :-)
11:36:23 <sunnymilk> you can deal with them but that doesnt mean theyre good or helpful
11:36:34 <shachaf> lens is not really about lenses.
11:36:37 <dmj`> hackrilege: depends on how deep your ADTs are, how many dependencies you like to have too
11:36:38 <hackrilege> And also if the main application is error handeling, which is always absent from my code as it never produces errors...
11:36:56 <ReinH> hackrilege: no, the main application is not error handling
11:37:14 <hackrilege> Dmj' minimal dependancies is better, and more legible
11:37:32 <CpnStumpy> Has anybody made a play at setting Atom up for Haskell? I switched from emacs to Atom for web dev stuff mostly just for the folder-browser on the side and visual tabs rather than having to scroll through my buffer rotation
11:37:59 <CpnStumpy> other than those two things it's damn similar to emacs
11:38:14 <ReinH> CpnStumpy: uh.
11:38:26 <hackrilege> The real problem that is a wall I hit is trying to make lenses for infinite datatypes, of kind * -> * -> ......
11:38:50 <monochrom> how is such a kind legal?
11:38:51 <ReinH> You can get a folder browser, and there are far better ways to manage buffers than scrolling through a list, but whatever
11:38:53 <CpnStumpy> ReinH: Yes, I realize - that's beyond a stretch to call some little thing similar to emacs which has billions of man miles and whatnot, but...
11:38:58 * hackagebot R-pandoc 0.1 - A pandoc filter to express R plots inside markdown  https://hackage.haskell.org/package/R-pandoc-0.1 (CorentinDupont)
11:38:59 <ReinH> hackrilege: What?
11:39:10 <ReinH> hackagebot: show me such a datatype please.
11:39:12 <hackrilege> I struggle to produce a functor of kind * to lie as the base case for such a datatype recursion
11:39:14 <ReinH> er hackrilege ^
11:39:34 <hackrilege> Lol
11:39:35 <hackrilege> I wish a bot could understand that query...
11:39:37 <KaneTW> hackrilege: haskell doesn't allow infinite types as they would make the underlying logic extremely inconsistent
11:39:45 <ReinH> Functors don't have kind *
11:39:47 <kadoban> There are no Functors of kind *
11:39:47 <hackrilege> Fix return
11:39:50 <CpnStumpy> ReinH: I can use DirEd alright - but are there any you can suggest that have the whole visual tree structure to expand and collapse folders easily rather than navigating them?
11:39:52 <hackrilege> Exactly...
11:40:28 <ReinH> CpnStumpy: neotree
11:40:30 <CpnStumpy> The buffer rotation is a small piece of the puzzle
11:40:47 <ReinH> although with the file navigation capabilities available, I don't know why you'd use a file browser instead
11:41:24 <hackrilege> Let's say I zoom into a picture until I find only an indivisible pixle, by repeatedly partitioning the domain. Since the image could be infinitly large, I could have infinatly many subdevisions
11:41:28 <CpnStumpy> Are there any visual buffer pickers too? I like using c-x arrows for nearby buffers in the rotation or c-x o for the currently tiled open ones
11:41:54 <ReinH> hackrilege: I don't understand how you're struggling to make lenses for datatypes that are impossible to create in the first place
11:42:04 <CpnStumpy> ReinH: ? A file browser instead of what? I use the standard dired buffer - but I can't expand/collapse folders in-situ
11:42:22 <ReinH> CpnStumpy: instead of helm, projectile, etc
11:42:34 <CpnStumpy> I haven't got a clue what those are
11:42:38 <ReinH> Indeed.
11:42:48 <CpnStumpy> ? Little more help? Care to elaborate?
11:42:50 <hackrilege> So if my datatype was Divisible of kind * -> * then I could have Divisible (Divisible (Divisible (... (Divisible pixle))))
11:43:17 <ReinH> https://github.com/emacs-helm/helm http://batsov.com/projectile/
11:43:50 <ReinH> hackrilege: why would you need to use the type system to model that in that way?
11:43:52 <hackrilege> ReinH yes, the problem is not in creating the lens, its terminating the recursion of the datatype while retaining its Functoryness
11:44:03 <hackrilege> In the above example Divisible Pixle has kind *
11:44:24 <ReinH> hackrilege: Well yes, it's impossible. I just don't understand why you would complain about not being able to write lenses when you can't even write the datatype to begin with.
11:44:26 <hackrilege> It's not a functor any more... So I cant make it applicative or anything
11:44:46 <CpnStumpy> ReinH: Is that helm thing for open buffers? Or does it query a folder structure?
11:45:36 <ReinH> CpnStumpy: helm is a framework for writing selective-narrowing menus. There are a wide variety of uses, including find-in-project, fuzzy finding, buffer selection, tag selection, yasnippet selection, all kinds of stuff
11:45:38 <hackrilege> Hmm, because it's only because I want to write a lens that it needs to be a Functor
11:45:39 <hackrilege> Sorry for the poor phrasing of the problem, that I cant make this datatype is making my eyes cross
11:45:49 <ReinH> hackrilege: Why does it need to be a Functor?
11:46:15 <CpnStumpy> Ah interesting, so it adds all the project-scope type facilities I'd want - or rather gives the ability for them to be built easily
11:46:18 <hackrilege> And because lens seems to capture the notion of nested datatype accessors...
11:46:25 <ReinH> CpnStumpy: projectile provides project-scope stuff
11:46:27 <hackrilege> It needs to be a functor because I need to be able to fmap over the final pixles
11:46:38 <ReinH> CpnStumpy: helm provides a very nice interface for making selections from a menu
11:46:47 <ReinH> an improvement over ido
11:47:01 <CpnStumpy> (I am clearly severely lacking in my emacs setup...)
11:47:15 <ReinH> projectile and helm combine to provide file-in-project, buffer-in-project, etc
11:47:18 <hackrilege> But really I should operate over whatever the datatype contains, which needs to be a parametrisable type
11:47:38 <ReinH> CpnStumpy: You should try out spacemacs, if just to get an idea of what sort of things are possible that you might want to add to our own config
11:48:07 <ReinH> hackrilege: I don't see what fmapping has to do with lens
11:48:25 <ReinH> hackrilege: and if they are just pixels then you don't need to fmap since you can't change the type anyway
11:48:51 <ReinH> I suppose you could use monotraversable, but that seems silly for a type like that
11:48:53 <hackrilege> "What is the datatype you want to use to represent the image?", "simply one that is divisible, unless it is a fixed point of division, namely a pixle"
11:49:15 <ReinH> I would prefer Double -> Double -> Pixel, personally
11:49:18 <CpnStumpy> honestly, it's probably because I'm using the oh-so-evilOS of windows but I have the biggest pain in the ass getting extensions working with emacs. It took me forever just to get the damned color scheme I downloaded to work..
11:49:42 <ReinH> which is infinitelyl divisible (up to precision limitations, but infinite by denotation)
11:49:43 <hackrilege> To make them applicative I would need to hold functions over pixles in the same way as I would hold the pixles, its definatly an applicative functor, just an recursive on with a base case
11:50:11 <ReinH> CpnStumpy: spacemacs will work on windows
11:50:33 <ReinH> hackrilege: Well, if it isn't polymorphic then it can't hold both pixels and functions
11:51:05 <monochrom> ReinH: why are you inflicting two debates on yourself at the same time? :)
11:51:06 <hackrilege> But I cant terminate the recursion without supplying this restricting base case
11:51:28 <hackrilege> No I am!
11:51:53 <ReinH> I don't understand what this recursive type gets you anyway
11:52:02 <ReinH> Why not just encode it at the value level?
11:52:21 <ReinH> Besides being impossible, I don't see why it would be a good solution even if it were possible
11:52:39 <CpnStumpy> ReinH: This stuff sounds awesome, thanks! Perhaps my switch to Atom will be short lived then.. Mostly popping around folders and files was taking me too long for the lots-of-files-and-folders of a big web app
11:53:09 <ReinH> CpnStumpy: Emacs has everything you need if you're willing to go find it and configure it ;)
11:53:11 <hackrilege> But I think ReinH has maybe seen me struggle with this problem for a few weeks, and I think it's actually pretty interesting, I still cant tell if I have a despeartly broken perception or if my problem makes sense... The cutting edge of a boggled mind
11:53:18 <johnw> CpnStumpy: check out #emacs!
11:53:31 <CpnStumpy> ReinH: I *knew* that, I just don't know where to start half the time.. Spacemacs I think may resolve a great deal of that for me
11:53:38 <ReinH> CpnStumpy: which is why I like spacemacs: other people have already done all that work for me.
11:54:07 <ReinH> Also someone posted a working spacemacs with haskell-mode and etc with stack recently on reddit
11:54:10 <ReinH> I need to try that
11:54:15 <ReinH> Mine is sort of almost working
11:54:29 <CpnStumpy> haha that's how I always feel about emacs "Mine is sort of almost working"
11:55:12 <CpnStumpy> Whatever, with Haskell 90% of what I need is the ability to open a couple files in a couple buffers, and c-c c-l, who needs lots of files when the code takes up so little space in each one?
11:55:56 <jhrcek> Just trying Haskell wikibook example about list monad, but unable to find better solution than using foldl. Any ideas, please? http://lpaste.net/140982
11:56:32 <johnw> jhrcek: your foldl has another name...
11:56:45 <cgag> b/quit
11:56:47 <johnw> it almost rhymes with replicate
11:57:14 <nolrai66> (Is it a monad thing?)
11:57:17 <johnw> (in that, it just adds a letter at the end)
11:57:55 <ReinH> jhrcek: Are you familiar with (<=<)?
11:58:21 <jhrcek> rein yes
11:58:45 <ReinH> jhrcek: are you familiar with (.)?
11:58:47 <hackrilege> We may have an infinitly devisible image... I could make an infinitly large tree, and simply map down the branches, Tree a = Branches [Tree a] | a. This is a functor and is going to capture my devisions, but it's not the same as a lens where we could have various different nestings, such as tuples of trees of tuples. The lens would capture this structure, but I wanted the infinite version of the lens over only recursive nesting of the s
11:58:48 <hackrilege> Sorry for the wall of text
11:59:03 <jhrcek> johnw, ReinH: thanks, I'll try both :)
11:59:11 <platz> is there way to find the type of an intermediate subexpression in emacs (i.e. not a function) like ghc-mod, in emacs?
11:59:24 <johnw> platz: C-c C-t
11:59:56 <ReinH> hackrilege: I don't understand. What is "the infinite version of the lens"?
12:00:13 <ReinH> jhrcek: You know how you can use (.) to combine a bunch of functions?
12:00:22 <ReinH> like, a list of functions
12:00:35 <ReinH> :t foldr (.) id
12:00:37 <lambdabot> Foldable t => t (b -> b) -> b -> b
12:00:58 <platz> johnw: C-c C-t gives 'Not in scope: `x`
12:01:02 <ReinH> (Ok, or a Foldable t of functions)
12:01:39 <t7> can i make a list of functions where each head has to return the argument expected to the function in the head of the tail ?
12:01:40 <hackrilege> ReinH one that can access the ellement at the end of an infinite recursion
12:01:41 <hackrilege> Or really, that it terminates makes it finite...
12:01:58 <ReinH> hackrilege: there is no element at the end of an infinite recursion.
12:02:00 <hackrilege> But the lens is happy to keep descending until it finds a base case
12:02:16 <platz> in my setup, C-c C-t runs the command haskell-process-do-type
12:02:18 <hackrilege> I already addressed that
12:02:27 <johnw> t7: what would the type of those functions be?
12:02:29 <hackrilege> Just above...
12:02:45 <t7> johnw: dependent 
12:02:55 <kadoban> t7: Lists in haskell are homogenous, so they'd all have to be the same type.
12:03:07 <t7> not even with the fancy extensions ?
12:03:39 <monochrom> no
12:03:52 <hackrilege> T7 you can have Either if you want two datatypes...
12:04:19 <t7> what if i define my own list type
12:04:21 <hackrilege> :t [Left 1,Right "hello"]
12:04:22 <lambdabot> Num a => [Either a [Char]]
12:04:27 <monochrom> I don't think dependent typing allows heterogeneous list either
12:05:09 <ReinH> t7: It sounds like you want type-aligned lists
12:05:10 <t7> i definitely can define this in agda, i think i may be explaining the problem poorly 
12:05:34 <ReinH> t7: https://hackage.haskell.org/package/type-aligned
12:05:35 <johnw> monochrom: you could have a list of types indexed by either another list, or a function from index to type
12:05:51 <ReinH> "type aligned sequences: heterogeneous sequences where the types enforce the element order."
12:05:59 <ReinH> Oleg uses them for the freer monad trick
12:06:29 <hackrilege> This is not makes sense; (t7) can i make a list of functions where each head has to return the argument expected to the function in the head of the tail ?
12:06:37 <johnw> ReinH: he does?  I thought he just used that for the reflection without remorse trick...
12:06:42 <hackrilege> Each head, whats that?
12:06:57 <hackrilege> You have a list of lists?
12:07:00 <ReinH> johnw: Yeah, a type-aligned sequence stores the actions
12:07:06 <johnw> I thought the freer monad trick was using a yoneda transformation to lift the Functor constraint from the Freer monad's Monad instance
12:07:09 <t7> [a -> b, b -> c, c -> d]
12:07:39 <ReinH> so a -> m d might be composed of [a -> m b, b -> m c, c -> m d], and he stores the actions in a type-aligned sequence
12:07:40 <hackrilege> Omg
12:07:46 <johnw> i.e., if you're not ever doing reflection, you don't technically need the type aligned list
12:08:05 <ReinH> johnw: iirc the point is to allow efficient access to the actions
12:08:18 <johnw> ah
12:08:34 <ReinH> johnw: " The continuation exposed in freer monads can then be represented as an efficient type-aligned data structure."
12:09:04 <hackrilege> Couldnt you make a list of a datatype to be supplied a type?
12:09:08 <ReinH> t7: did you look at that package?
12:09:22 <exio4> data FN a b where ID :: FN a a; Comp :: (b -> c) -> FN a b -> FN a c 
12:09:34 <t7> ReinH: not yet
12:09:40 <ReinH> t7: it sounds like what you want
12:10:03 <t7> cool ty
12:10:05 <hackrilege> E.g. [Just,Just,Just] where each of those Just's could be supplied its type parameter later?
12:10:17 <hackrilege> :t [Just]
12:10:18 <lambdabot> [a -> Maybe a]
12:10:34 <hackrilege> :t [Just,Just]
12:10:36 <lambdabot> [a -> Maybe a]
12:11:04 <hackrilege> Oh...
12:11:10 <hackrilege> Damn, so the list forced them all to be the same, thats annoying.
12:11:35 <hackrilege> Makes sense though
12:11:55 <exio4> that GADT looks nicer for the "composition of functions" problems or so
12:12:39 <hackrilege> mylens (+1) $ Just $ Just $ .... $ Just 1
12:12:40 <exio4> oh, type-aligned does that
12:13:49 <hackrilege> ReinH, have I managed to communicate what im up to yet?
12:15:13 <jhrcek> johnw: I don't thing replicateM is a good fit for this. I have a function:    generation :: a -> [a] and need to apply this n times to some a..   Got a 2nd try using (<=<), but not able to figure it out with replicateM :(
12:15:15 <hackrilege> "Cannot create infinite type".....
12:15:27 <jhrcek> johnw: http://lpaste.net/140982
12:15:33 <johnw> jhrcek: ok, never mind my suggestion
12:15:34 <hackrilege> :t (<=<)
12:15:35 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
12:18:05 <hackrilege> > (Just.length) <=< (Just.(:[])) 1
12:18:07 <lambdabot>  Not in scope: ‘Just.length’
12:18:32 <hackrilege> > (Just . length) <=< (Just.(:[])) 1
12:18:33 <lambdabot>      Couldn't match expected type ‘a -> Maybe (t0 a0)’
12:18:34 <lambdabot>                  with actual type ‘Maybe [Integer]’
12:18:34 <lambdabot>      Possible cause: ‘Just . (: [])’ is applied to too many arguments
12:18:47 <hackrilege> Sorry!!
12:19:17 <lpaste_> burbly pasted “Code that used to compile in 2013” at http://lpaste.net/140985
12:19:38 <mniip> burbly, attach error message
12:19:44 <nitrix> Hi, which IRC library does lambdabot uses?
12:19:57 <lpaste_> burbly annotated “Code that used to compile in 2013” with “Code that used to compile in 2013 (annotation)” at http://lpaste.net/140985#a140986
12:19:58 <mniip> nitrix, its own iirc
12:20:13 <breadmonster> :t (Just . length) <=< (Just . build)
12:20:14 <lambdabot>     Not in scope: ‘build’
12:20:14 <lambdabot>     Perhaps you meant ‘buildG’ (imported from Data.Graph)
12:20:21 <burbly> Can anyone help spare a minute to help me with this?
12:20:38 <breadmonster> :t (Just . length) <=< (Just . (\x -> [x]))
12:20:39 <lambdabot> a -> Maybe Int
12:20:40 <burbly> Some changes in GHC mean that some old code of mine no longer compiles...
12:20:50 <breadmonster> hackrilege: You were missing parens.
12:20:58 <amunra81> :t id
12:20:59 <lambdabot> a -> a
12:21:12 <breadmonster> :t (Just . length) <=< (Just . (\x -> [x])) $ 1
12:21:13 <lambdabot> Maybe Int
12:21:15 <hackrilege> Thanks
12:21:46 <mniip> burbly, quick glance suggests a scoped type variables issue
12:21:47 <breadmonster> Though I'm sure there's a cleaner way of writing that.
12:22:11 <hackrilege> I just wanted to see what <=< was up too
12:22:42 <breadmonster> hackrilege: `fmap (length . (: [])) $ return 1` should work.
12:22:56 <hackrilege> :t fix Just
12:22:57 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ Maybe a
12:22:57 <lambdabot>     Expected type: Maybe a -> Maybe a
12:22:57 <lambdabot>       Actual type: a -> Maybe a
12:23:09 <YellowOnion> I'm trying wrap the SetWindowsHookEx function in windows, I'm not sure how to pass a callback to Windows, does anyone know any example using existing Win32 api?
12:23:12 <hackrilege> And thats why haskell sucks
12:23:20 <breadmonster> Can someone tell me if it's better practice to use liftM or liftA or fmap in code?
12:23:22 <joco42_> how con you guys explain this interesting experiment ? http://pasteboard.co/DLjmlJZ.png
12:23:23 <burbly> @mniip: thanks; do you know which change is likely to have caused the issue?
12:23:23 <lambdabot> Unknown command, try @list
12:23:37 <joco42_> the interesting part is in the bottom left corner
12:24:08 <joco42_> where is the variable s stored ?
12:24:14 <joco42_> how long does it live?
12:24:41 <lifter> breadmonster: I use the simplest one that will work
12:24:47 <mniip> burbly, afraid not
12:24:55 <breadmonster> lifter: They're equivalent.
12:25:12 <lifter> breadmonster: Then use fmap or (<$>)
12:25:23 <burbly> How do I make 'RuleExp -> m RuleExp' pick up the m introduced in the outermost scope?
12:25:41 <breadmonster> lifter: Yeah I forgot (<$>)
12:25:44 <breadmonster> love that operator.
12:25:49 <awpr> burbly: turn on the ScopedTypeVariables extension and make sure it's bound with an explicit "forall"
12:26:02 <burbly> ScopedTypeVariables is on
12:26:05 <hackrilege> Why cant I make a hylomorphism out of datatypes?????
12:26:06 <burbly> and the binding is 
12:26:07 <awpr> oh, that's weird.
12:26:19 <burbly> mapFoldCommandM :: forall x . forall a . forall m.
12:26:19 <burbly>                   (Monoid a, Monad m) => (x -> DRSLine -> (a, x))
12:26:25 <breadmonster> hackrilege: There's a type level fix.
12:26:32 <burbly> So there's a 'forall m' in there.
12:26:48 <breadmonster> hackrilege: I just don't remember how it goes.
12:26:50 <hackrilege> Oooo cool
12:26:50 <hackrilege> Link?
12:27:05 <awpr> burbly: yeah, I saw the type signature, I just assumed ScopedTypeVariables was off.
12:27:07 <hackrilege> Haha
12:27:07 <hackrilege> Doh
12:27:29 <breadmonster> One second.
12:27:41 <hackrilege> Joco42_ hows it going, is anyone helping yet?
12:27:42 <geekosaur> joco42, it lives in C's global variable space (initialized data segment, before the heap)
12:27:46 <breadmonster> hackrilege: https://en.wikibooks.org/wiki/Haskell/Fix_and_recursion#Fix_as_a_data_type
12:27:48 <burbly> Definitely on.
12:27:56 <awpr> random hunch, does it work if they're all in one forall?  "forall x a m. <...>"
12:27:57 <burbly> And as I said, the code used to compile
12:28:16 <joco42_> hackrilege: thanks, now yes :) 
12:28:30 <joco42_> geekosaur: thanks
12:28:43 <joco42_> geekosaur: so s lives where a global lives ?
12:28:50 <geekosaur> where a C global does
12:28:53 <joco42_> http://stackoverflow.com/questions/3113668/location-of-pointers-and-global-variables-in-c
12:28:57 <burbly> Hm... think that's fixed it; one sec while I check more carefully...
12:28:57 <joco42_> ok, thanks
12:29:01 * hackagebot atom-basic 0.2.3 - Basic Atom feed construction  https://hackage.haskell.org/package/atom-basic-0.2.3 (cbaatz)
12:29:23 <hackrilege> :t ([]::[Fix Just])
12:29:24 <lambdabot> Not in scope: type constructor or class ‘Fix’
12:29:46 <breadmonster> hackrilege: Try local ghci, I don't think lambdabot will evaluate that.
12:30:05 <johnw> hackrilege: Fix Just?
12:30:17 <hackrilege> @let data Fix f = Fix (f (Fix f))
12:30:18 <lambdabot>  Defined.
12:30:20 <burbly> Yes, that's fixed it. Thank you very much!  How on earth did you guess it?
12:30:24 <johnw> do you mean Fix Maybe?
12:30:26 <hackrilege> Yeh I was just seeing if it worked...
12:31:03 <hackrilege> Because Nothing has kind *? @johnw
12:31:05 <geekosaur> it's actually a little more complicated for ghci because it has its own linker which may do things a bit differently --- it is in effect dlopen()ing a static object file
12:31:21 <geekosaur> (you can't actually do that which is why ghci does its own linker magic)
12:31:52 <johnw> 'Nothing has kind *, I didn't realize you want to use 'Just
12:31:54 <hackrilege> And no I dont have ghci it does not exist on this OS, currently the most used OS in the world...
12:32:01 <awpr> burbly: dumb luck really -- it was clearly caused by not matching up one 'm' with another, and I've never actually used multiple 'forall's in the front of a type signature, and I assume most people wouldn't, so I guessed that's a good place for a bug
12:32:13 <burbly> Anyway, thanks!
12:32:17 <joco42_> geekosaur: ok, good to know
12:32:31 <awpr> and, it might be a bug -- it seems suspicious to me.
12:32:35 <johnw> hackrilege: actually, as far as I can tell, even 'Nothing has the lifted kind Maybe k, and not *
12:32:47 <joco42_> geekosaur: but basically with ghc its just c global
12:33:02 <geekosaur> yes, because you are accessing a C library
12:33:03 <hackrilege> Ok great, so Fix Just should be fine...
12:33:35 <hackrilege> But then how do I modify the base case?
12:33:38 <geekosaur> and because ultimately ghc is implemented on top of a C runtime (and pretty much must be because otherwise you couldn't safelyy use FFI to call any C code)
12:33:50 <johnw> hackrilege: why should Fix Just be fine?
12:34:36 <hackrilege> As just had kind *->*
12:34:53 <johnw> where are you seeing that?
12:35:14 <johnw> here, 'Just has kind * -> Maybe *
12:35:20 <joco42_> geekosaur: ok, one related question, real world haskell says that one has to be careful to create c bindings that are re-entrant , does that matter if the haskell code i am running is single threaded ?
12:35:26 <hackrilege> Oh hmm, is it nested in Fix's now. Im not sure this is producing Just $ Just $ Just... $ Just _ as I desire...
12:35:42 <joco42_> http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
12:35:48 <burbly> :t and
12:35:49 <lambdabot> Foldable t => t Bool -> Bool
12:36:10 <joco42_> " We also need to be very careful with pure C functions that aren't also reentrant, as multiple threads are extremely common in Haskell code, in comparison to C."
12:36:11 <johnw> hackrilege: I don't know what you mean; even if Fix Just were possible, $ would not be involved, that applies a function to a value, not a type constructor to a type
12:36:12 <hackrilege> Yes im sure I want "fix Just" really
12:36:17 <johnw> ah
12:36:43 <joco42_> how big issue is this re-entrant business?
12:36:46 <johnw> still won't work ;)
12:37:07 <hackrilege> Yes I dont thing the Fix datatype is doing what I want it too here
12:37:07 <hackrilege> I know it wont work, but I cant understand why
12:37:08 <joco42_> is this a big concern if my haskell code is single threaded/single process?
12:37:32 <johnw> now, what *will* work is: fix $ Free . Just
12:37:32 <hackrilege> :t hylo
12:37:33 <lambdabot> Not in scope: ‘hylo’
12:37:40 <johnw> because Free can represent your recursive type
12:37:45 <geekosaur> joco42_, I think you misunderstand. you need re-entrant and pure C code if you want to use it from Haskell as a pure function. but reentrancy is only part of the issue in that case
12:37:52 <johnw> and the fact that Just is part of a sum
12:38:03 <geekosaur> most of the C functions you will use with the FFI, you will declare in IO
12:38:05 <hackrilege> What is this Free??
12:38:18 <johnw> data Free f a = Pure a | Free (f (Free f a))
12:38:37 <johnw> or in other words: type Free f a = Fix (Compose (Either a) f)
12:38:54 <hackrilege> Aha, so its Fix but with a leaf, base case thingy...
12:38:57 <johnw> yep
12:39:02 * hackagebot nixfromnpm 0.2.1 - Generate nix expressions from npm packages.  https://hackage.haskell.org/package/nixfromnpm-0.2.1 (thinkpad20)
12:39:03 <joco42_> geekosaur: so if I want to create a pure function, then why do i need the re-entrant issues if my code is single threaded ? can something else mess it up ?
12:39:04 <monochrom> joco42_: if you know you're single-threaded, nothing to worry. if you plan to multi-thread, see my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml , especially the last section.
12:39:13 <hackrilege> Still not really what I was getting at, I wanted type resolution like in hylo...
12:39:24 <johnw> how does hylo do type resolution?
12:39:25 <hackrilege> Or like in fix, I get confused...
12:39:56 <johnw> still, what do you mean by "type resolution"?
12:39:58 <hackrilege> It converges at the fixed point
12:40:08 <johnw> how does that relates to type?
12:40:10 <hackrilege> You know, the whole magic part
12:40:11 <geekosaur> joco42_, "We also need to be very careful with pure C functions that aren't also reentrant, as multiple threads are extremely common in Haskell code, in comparison to C."
12:40:12 <johnw> relate to types*
12:40:14 <johnw> no, sorry, I don't know
12:40:30 <hackrilege> Where it takes a -> b without a function taking a -> b
12:40:42 <johnw> do you mean, tying the knot?
12:40:49 <joco42_> monochrom: ok, thanks, so i can just go ahead and wrap some cool c libraries as pure functions and as long as i am single threaded then i do not need to worry about this re-entrancy issue ? how can i make sure that i am single threaded ?
12:40:50 <geekosaur> you certainly can write single-threaded Haskell code, but Haskell threads are in general easy enough to work with (especially with STM) that they get used a lot
12:40:52 <hackrilege> Because some special thing happens at the fixed point...
12:40:55 <johnw> seeming to produce an "a" out of thin air by using the result of your own function?
12:41:05 <joco42_> geekosaur: i see what you mean
12:41:08 <geekosaur> whereas in C it's *relatively* rare because it's more painful
12:41:29 <hackrilege> Yeh thats the magic right
12:41:51 <johnw> hackrilege: that has nothing to do with types
12:42:00 <geekosaur> so you want to in general make sure you can reuse your C code later in a multithreaded Haskell program; it's rarely worthwhile to FFI for a one-time-use function
12:42:00 <joco42_> geekosaur: can i somehow restrict haskell to use only one single thread ?
12:42:03 <hackrilege> So I should be able to produce an infinite type, as it could result in a kind * at the fixed point
12:42:09 <lpaste_> burbly annotated “More code that used to compile in 2013” with “More code that used to compile in 2013 (annotation)” at http://lpaste.net/140988#a140989
12:42:19 <GLM> Is there a function that takes to functions and apply them to an Either?
12:42:22 <johnw> hackrilege: you can't make infinite types
12:42:39 <johnw> hackrilege: GHC will give you an error that specifically says you can't do that
12:42:40 <Ankhers> GLM: fmap?
12:42:41 <hackrilege> Thats the problem
12:42:41 <hackrilege> I cant see why that should be the
12:42:42 <hackrilege> Case
12:42:43 <joco42_> geekosaur: ok, then maybe i need to read about this re-entrancy business some more...
12:42:53 <awpr> :t either
12:42:54 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
12:42:55 <hackrilege> > fix Just
12:42:55 <monochrom> if you say "ghc -threaded xxx.hs" you get multi-threading. if you make sure "-threaded" does not appear, you get single threading.
12:42:56 <lambdabot>      Occurs check: cannot construct the infinite type: a ~ Maybe a
12:42:56 <lambdabot>      Expected type: Maybe a -> Maybe a
12:42:56 <lambdabot>        Actual type: a -> Maybe a
12:42:58 <burbly> Promise this is the last one!  Any help would be much appreciated.
12:43:01 <hackrilege> That one?
12:43:05 <GLM> Ankhers:That only applies the function to the right side
12:43:12 <johnw> hackrilege: yes
12:43:12 <burbly> [and it's only 3 type signatures + 1 line of code.]
12:43:19 <joco42_> monochrom: is that it ? then no problem with re-entrancy?
12:43:20 <Ankhers> GLM: You want to apply to both/
12:43:23 <Ankhers> :t bimap
12:43:24 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
12:43:25 <monochrom> yes
12:43:26 <hackrilege> Im proposing motivation to an extension for handeling such types I suppose
12:43:41 <johnw> hackrilege: that will never happen
12:44:00 <GLM> either id id (Right 1)
12:44:01 <hackrilege> Or asking if there is one but phrased less crazy
12:44:02 <joco42_> monochrom: so if i dont use -threaded then none of the stm or other thread magic will work ?
12:44:02 <hackrilege> Johnw. WHY?
12:44:02 <GLM> > either id id (Right 1)
12:44:03 <johnw> you're basically asking for bottom as kind of type
12:44:04 <lambdabot>  1
12:44:14 <johnw> also, we don't need infinite type
12:44:16 <monochrom> they still work. they use green threads then.
12:44:18 <burbly> nm, fixed
12:44:19 <johnw> you just need a recursive type, like Free
12:44:25 <joco42_> monochrom: awesome :)
12:44:36 <joco42_> monochrom: corutines...
12:44:40 <geekosaur> note that green threads don't necessarily save you from reentrancy issues
12:44:40 <johnw> hackrilege: see http://stackoverflow.com/questions/9566683/deliberately-defining-infinite-type-in-haskell
12:44:42 <hackrilege> I dont get why it does not make sense, since I seem to have some notion of Type magic at the fixed point of an infinite recursion, it seems to be the way you would deal with such types
12:44:45 <Ankhers> > bimap id id (Right 2)
12:44:46 <KaneTW> hackrilege: because of what i mentioned earlier
12:44:47 <lambdabot>  Right 2
12:44:59 <joco42_> geekosaur: hmmm.... interesting
12:45:03 <johnw> hackrilege: there is no "type magic" involving with fix
12:45:06 <GLM> Ankhers:Thanks. That is what I was looking for
12:45:17 <Ankhers> GLM: No problem.
12:45:19 <hackrilege> I cant recall that KaneTW
12:45:25 <monochrom> when you exclude "-threaded", then when you call C, all Haskell activity stops until the C call finishes.
12:45:33 <KaneTW> 20:39:15*        KaneTW ╡ hackrilege: haskell doesn't allow infinite types as they would make the underlying logic extremely inconsistent
12:45:33 <GLM> :t bimap
12:45:34 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
12:45:35 <hackrilege> Johnw but there is with hylo...
12:45:37 <burbly> has the type signature of 'and' changed over the last couple of years?
12:45:42 <johnw> hackrilege: why do you say that?
12:45:51 <joco42_> monochrom: this is very interesting
12:45:52 <monochrom> therefore, effectively all your C calls must be serialized and therefore nothing re-enters
12:45:52 <geekosaur> burbly, in 7.10 a lot of things were generalized from lists to Foldables
12:45:58 <geekosaur> and that's what you are seeing
12:46:00 <awpr> burbly: yes, with the Foldable changes in base; 4.8.0.0 maybe?
12:46:07 <joco42_> monochrom: fantastic
12:46:10 <hackrilege> We just went over that! Because I can change a to be without explicitly supplying a function from a to b
12:46:13 <fryguybob> monochrom: Unless your C call calls back into haskell...
12:46:17 <johnw> hylo is just using two functions and a value to produce another value
12:46:26 <joco42_> monochrom: makes life easier for a newbee
12:46:35 <monochrom> ah well ok I forgot that case
12:46:38 * geekosaur thought that stop-the-world was only for ffi calls marked "safe"
12:46:42 <geekosaur> "unsafe", all bets are off
12:46:52 <johnw> I can easily choose 'f' to be Identity, and write an instance of hylo that has no magic whatsoever
12:46:54 <burbly> Got it -- thank you.
12:47:06 <Jeanne-Kamikaze> trivia: do you know how many repositories edwardk has on github? answer: wrong, cause he already added a new one
12:47:07 <hackrilege> "Underlying logic being inconsistent" is not informative unfortunatly
12:47:28 <johnw> hackrilege: he means that making types turing complete would mean that types would not communicate total information
12:47:45 <johnw> we could have a type that sends the type-checker into an infinite loop
12:47:55 <joco42_> thanks for the clarification, i then just makes sure that i do not use -threaded and that my c does not call back to haskell, then i should be covered, for a start
12:47:58 <hackrilege> It sure would!
12:47:59 <johnw> and then we don't know if the type is valid or invalid
12:48:04 <monochrom> yeah
12:48:08 <joco42_> cool
12:49:11 <hackrilege> Cant I just represent like "Infinite Just" to make the type checker not die?
12:49:14 <geekosaur> burbly, for what it's worth, the expectation of breakage from 7.10 is reflected in how this change was referred to as the bridge-burning proposal :)
12:49:27 <johnw> what if it's valid if I were to just wait a year?  do I assume that a type is invalid after 10 minutes of it failing to check?  Use Free to represent infinitely recursive Maybe values
12:49:41 <awpr> hackrilege: yes, that's called Fix, but Just is not normally a type.  What about Fix Maybe?
12:49:58 <johnw> Free Maybe a is equivalent to (Int, a)
12:50:05 <hackrilege> We have Free awpr which is like Fix but with a leaf base case
12:51:08 <johnw> Fix Maybe is equivalent to Int
12:51:10 <hackrilege> Is Free motivated by some discussions within Category theory? I need to see what people have been writing about this problem...
12:51:42 <awpr> hackrilege: if you actually want a type whose only inhabitant is an infinite chain of a single constructor, "data X = X X"
12:51:44 <hackrilege> But really I was NOT talking about that, but fix Maybe
12:51:48 <johnw> hackrilege: the Free monad (which is the name you'll find that "Free" under), has ties to category theory, and also lots of utility in functional programming, especially for abstracting DSLs
12:51:51 <dfeuer> Blast. I wish Tekmo were here right now.
12:52:09 <shiona_> johnw: Int or Integer?
12:52:09 <bitemyapp> dfeuer: when was the last time you saw him in IRC?
12:52:14 <johnw> shiona_: you are right, Integer
12:52:18 <dfeuer> bitemyapp, long time ago.
12:52:20 <bitemyapp> johnw: you mean Nat?
12:52:26 <johnw> and yes, I do mean Nat ;)
12:52:30 <bitemyapp> shiona_: they mean Nat.
12:52:34 <bitemyapp> 0 -> infinity
12:52:36 <bitemyapp> no negatives.
12:52:42 <bitemyapp> whole numbers
12:52:45 <hackrilege> Data X a = X (X a) | Y a
12:53:46 <hackrilege> The one represented by Z
12:54:02 <johnw> hackrilege: fix Just cannot type check. However, you can use fix and Fix together to make something that typechecks
12:54:04 <hackrilege> I think... I should not speak when unsure...
12:54:12 <johnw> "fix $ Fix . Just" typechecks
12:54:25 <johnw> because Fix Maybe is not an infinite type, even though it can represent *infinitely recursive values*
12:54:27 <hackrilege> But is it what I was describing?
12:54:57 <johnw> hackrilege: I think all that's happening here is that you're mixing types and values
12:54:59 <hackrilege> Do you know where I can find papers on Free?
12:55:01 <johnw> which is a perfectly normal mistake
12:55:12 <johnw> google for "free monad"
12:55:17 <johnw> there are quite a lot of good resources
12:55:28 <hackrilege> Ok, thanks
12:55:43 <johnw> they will seem a bit dense at first, though
12:55:46 <hackrilege> Im glad it's not the first time anyone has considered this!!
12:55:53 <johnw> I'm not aware of many newbie-friendly introductions to Free
12:55:54 <hackrilege> Its ok, its my job...
12:56:55 <johnw> and we don't even technically need Free here, if all you want is for Just to recurse forever
12:56:57 <hackrilege> Celebraiting 10 years as a Haskell coder, still getting called a noob! Doh!
12:56:58 <hackrilege> Super helpful as always johnw thanks again
12:57:10 <johnw> hackrilege: 10 years!  nice
12:57:26 <hackrilege> Nono, I would really like it to stop recursing at a fixed point
12:57:43 <johnw> Fix Maybe builds in a base case, which is "Fix Nothing"
12:57:58 <johnw> however, the only informational content that Fix Maybe can communicate is how many Just wrappers were used
12:58:08 <johnw> which is why we say it's equivalent to Nat
12:58:30 <johnw> i.e., Fix (Just (Fix (Just (Fix (Just .... Fix Nothing)))))
12:58:32 <hackrilege> Nat, Yeh i got that
12:58:54 <johnw> Free is nice because it gives you a value at the leaves, making it automatically a Functor, an Applicative and a Monad in fact
12:59:14 <johnw> (Oleg even showed how it can be a Monad without assuming anything at all about 'f')
12:59:16 <hackrilege> It was just the most simple example of a kind *->* datatype
12:59:16 <hackrilege> All those Fix everywhere is upsetting
12:59:44 <johnw> pattern synonyms and a good Show instance can hide all the Fix's, if you really want
12:59:46 <hackrilege> Yeh it does look like Free is what im talking about
13:00:01 <johnw> Free is a really powerful addition to the FP toolbox
13:00:06 <johnw> it's worth many hours of study
13:00:26 <johnw> (I've been playing with Free for years now, and still learning new tricks)
13:00:28 <hackrilege> To the batmobile!
13:01:07 <hackrilege> Ok, further discussion is pointless untill iv read the literature
13:01:16 <monochrom> the batmobile will not set you free
13:01:33 <hackrilege> Free to do as I please
13:01:52 <monochrom> it only burdens you with more responsibility and risk
13:02:15 <GLM> johnw:Any preferred lit?
13:02:21 <johnw> GLM: on what?
13:02:31 <GLM> johnw:Free
13:02:46 <hackrilege> We have been refered to google!
13:03:08 <johnw> GLM: I wish I did have one good resource for you
13:03:10 <monochrom> in almost all batman movies, the batmobile becomes a liability, since the villains figure out a way to break it
13:03:30 <tommd> GLM: If I follow this conversation correctly... http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
13:03:32 <hackrilege> Quite like the delorian...
13:04:14 <ew0> hi, what is the most usual way to implement a iterative loop in haskell?
13:04:16 <hackrilege> Ooo free resource
13:04:25 <monochrom> haha
13:04:25 <johnw> maybe try http://underscore.io/blog/posts/2015/04/23/deriving-the-free-monad.html
13:04:32 <ew0> I am using the function until
13:04:37 <monochrom> ew0: recursion, or Data.List goodies
13:04:51 <monochrom> or list comprehension
13:04:51 <sxz> HI
13:04:56 <johnw> ew0: depends on what the loop will do.  I find that 'forM_' is usually the closest to a C loop that I use
13:04:57 <breadmonster> How do I find the size of a data type?
13:05:02 <hackrilege> Ew0, have you tried to write a recursive function definition?
13:05:18 <ew0> yes, but it is not as pretty as until
13:05:24 <ew0> my problem now is the worklist
13:05:45 <hackrilege> Also fold embodies an itterator style for loop which collects values into a carried variable
13:05:48 <johnw> sadly, that link I gave is for Scala
13:06:10 <Welkin> breadmonster: https://wiki.haskell.org/GHC/Memory_Footprint
13:06:11 <hackrilege> E.g. Sum = foldl (+) 0
13:06:19 <geekosaur> breadmonster, under what circumstances? for FFI purposes there is the Storable typeclass
13:06:30 <tommd> breadmonster: Johan had a great talk on that, it depends on a few things such as if a field is unboxed etc.
13:06:31 <hackrilege> Sorry for all the erroneous capitals...
13:06:50 <tommd> breadmonster: https://wiki.haskell.org/wikiupload/6/65/HIW2011-Talk-Tibell.pdf
13:07:23 <hackrilege> Ew0 also you could zip with [1..] if you need the index
13:07:41 <ew0> I need a ton more stuff xD
13:07:46 <breadmonster> I'm trying to figure out how to use unsafeCoerce
13:07:55 <ew0> even some exponentially growing trees
13:08:06 <ew0> https://github.com/wuerges/vlsi_verification
13:08:06 <tommd> breadmonster: Ah, those slides don't include his unpack discussion, sorry never mind.
13:08:10 <johnw> one problem with free monad articles is that, like monad tutorials, they all tend to focus on one typical example, which doesn't necessarily convey all the insights that are available
13:09:28 <tommd> breadmonster: but his blog has a run-down!  http://blog.johantibell.com/2011/06/computing-size-of-hashmap.html
13:09:32 <hackrilege> > foldl1 (\c (a,b)-> c+a+(length b))) (zip [1..] ["hello","world"])
13:09:34 <lambdabot>  <hint>:1:35: parse error on input ‘)’
13:09:56 <hackrilege> Nvm
13:10:02 <hackrilege> > foldl1 (\c (a,b)-> c+a+(length b)) (zip [1..] ["hello","world"])
13:10:04 <lambdabot>      Couldn't match expected type ‘(t, [Char])’ with actual type ‘Int’
13:10:04 <lambdabot>      Relevant bindings include
13:10:04 <lambdabot>        a :: t (bound at <interactive>:1:13)
13:10:20 <hackrilege> Sorry!
13:10:53 <hackrilege> Ok im off before I make more mess. Bye
13:11:25 <ew0> how slow is appending an element to a list?
13:11:36 <Shockk> unsafePerformIO (exitWith hackrilege)
13:11:40 <johnw> O(n) slow
13:11:56 <awpr> ew0: O(n), but there are plenty of techniques to do append-oriented list construction
13:12:04 <johnw> you can use Data.Sequence for O(1) cons and snoc, that can be converted back to a list when you're done
13:12:13 <breadmonster> ew0: What's your purpose?
13:12:26 <ew0> I want a priority queue 
13:12:33 <ew0> but I don't want to add another dependency to my project
13:12:50 <kadoban> ew0: Why not?
13:12:58 <awpr> appending to a list won't get you a priority queue.  do you mean a FIFO queue?
13:13:03 <ew0> Data.Sequence is fine
13:13:03 <monochrom> copy the priority queue code from a priority queue package
13:13:06 <ew0> because it is on base
13:13:40 <kadoban> ew0: But if you really must implement one yourself, there's a couple of simple ones in okasaki's book, Purely Functional Data Structures. It's a bit of a total waste of time though.
13:13:50 <ew0> yes
13:13:58 <ew0> I almost was using 2 lists
13:14:00 <mbrgm> hi! I'm a total noob in haskell but eager to learn... I have a function :: `a -> m b` and want to make a function :: `m a -> m b` from it. how can I do that?
13:14:05 <ew0> and reversing one whet the take list is empty
13:14:18 <johnw> mbrgm: compose "return" to the input side of your function
13:14:18 <awpr> ew0: that's a pretty good FIFO queue implementation
13:14:26 <johnw> mbrgm: f . return
13:14:30 <kadoban> ew0: Are you sure you mean a priority queue? This is sounding like … not that at all.
13:14:31 <johnw> oops, sorry!
13:14:34 <johnw> I got that backwards
13:14:44 <ew0> I want a simple worklist
13:14:47 <johnw> compose it with >>=
13:14:49 <ew0> fifo
13:15:04 <awpr> ew0: yep, I'd just use "data FIFO a = FIFO [a] [a]"
13:15:10 <kadoban> Ah, a fifo is a totally different thing.
13:15:14 <johnw> :t \f -> (f =<<)
13:15:15 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:15:24 <monochrom> guess what, STMChan uses the two-list trick
13:15:29 <ew0> xD we have one in prelude?
13:15:57 <mbrgm> johnw: maybe I should have mentioned the full types: the first function is of `a -> Maybe b` and I want to have a `IO a -> Maybe b` function.
13:16:11 <johnw> oh, that you cannot have :(
13:16:23 <johnw> there is no getting the 'a' out of 'IO a'
13:16:24 <monochrom> then you should have said "m a -> n b"
13:16:53 <mbrgm> monochrom: thank you, I wasn't sure about the notation. thought `m` meant just 'monadic', but of course it has to be a specific monad
13:17:02 <mbrgm> monochrom: in that context
13:17:16 <ew0> uhm, I'll go with Data.Sequence
13:17:28 <ew0> refactoring haskell code is so easy, anyway
13:17:59 <awpr> ew0: that will very likely be slower
13:18:10 <awpr> (not asymptotically)
13:18:33 <ew0> I have a tree as a key of my Data.Map
13:18:38 <ew0> it won't be the slower part of the code
13:18:38 <ew0> xD
13:18:47 <monochrom> haha
13:19:13 <ew0> hey
13:19:16 <ew0> another question
13:19:22 <ew0> is there a way to limit the amount of memory or time
13:19:24 <ew0> a function takes
13:19:26 <ew0> ?
13:19:37 <monochrom> no. only the whole program.
13:19:41 <johnw> there's timeout; for memory, there's allocation counts
13:20:01 <ew0> timeout :: (a -> b) -> Maybe b
13:20:10 <johnw> see setAllocationCounter in https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Conc.html
13:20:27 <ew0> ok
13:21:21 <Shockk> :t timeout
13:21:22 <lambdabot> Not in scope: ‘timeout’
13:21:28 <Shockk> oh
13:21:42 <ew0> System.Timeout
13:21:47 <Shockk> base System.Timeout: timeout :: Int -> IO a -> IO (Maybe a)
13:22:45 <ew0> uhm, I think those droids where what I was looking for
13:30:55 <clrnd> do we have -XPrefixOperators ?
13:31:15 <mniip> not yet
13:31:59 <bitemyapp> could it be said that either the List Monoid or ZipList Monoid are more product-y or sum-y?
13:32:08 <bitemyapp> I'm not sure how to contrast them along those lines.
13:32:14 <bitemyapp> (looking for intuition here)
13:32:17 <KaneTW> list is definitely more summy
13:32:23 <bitemyapp> (++) is more summy?
13:32:36 <bitemyapp> KaneTW: could you elaborate a little please?
13:33:17 <KaneTW> just intuitively
13:33:18 <burbly> Grr: postparse.exe: internal error: evacuate: strange closure type 5101248
13:33:30 <bitemyapp> KaneTW: oh right because the hypothetical ZipList Monoid combines the a's right?
13:33:36 <catau> hi, question, if I want a list that alternates between a random lowercase and a random uppercase character, what is idiomatic haskell? I can produce infinite 'streams' of each with getRandomRs, but can't think of a simple way to produce the final list (maybe by yield-ing values from each base stream (e.g., Conduit/Pipes)?)
13:33:39 <KaneTW> though depends on how you define sum/product
13:33:44 <bitemyapp> no no, this fits.
13:33:49 <bitemyapp> I think you've got it, thank you.
13:33:50 <burbly> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
13:35:26 <burbly> I know what a closure is, but what is a closure type?
13:36:01 <tommd> catau: concat [ [low,high] | low <- lowerCaseLetters | high <- upperCaseLetters ]
13:36:24 <mbrgm> ok, now the second problem. how can `IO a -> (a -> Maybe b) -> Maybe b` be done?
13:36:28 <hhhhhhhh_> if i'm getting a bunch of errors like http://ix.io/kOo does that mean i just can't use libraries
13:36:35 <hhhhhhhh_> (on a raspberry pi)
13:36:41 <tommd> mbrgm: f _ _ = Nothing
13:36:49 <KaneTW> burbly: what's causing the issue
13:37:30 <catau> tommd: thanks, that makes sense!
13:37:38 <geekosaur> hhhhhhhh_, it means you need a supported version of llvm
13:37:40 <burbly> Running a program... 
13:37:48 <mbrgm> tommd: is there a name for that, so I can read more about it?
13:37:59 <burbly> I think it may be a memory issue, but it's a compiled executable being run on complex input
13:38:03 <burbly> so it's hard to diagnose
13:39:48 <geekosaur> hhhhhhhh_, IIRC that error comes from using llvm 3.6; currently ghc only supports 3.5
13:40:11 <hhhhhhhh_> geekosaur: i am building things against 3.6 on my laptop, it's just my pi it doesn't like
13:48:48 <johnw> mbrgm: it means that the only way to produce Maybe b from those arguments, is to ignore the arguments entirely and just return Nothing
13:52:29 <aweinstock> :t \action maybeArrow -> maybeArrow (System.IO.Unsafe.unsafePerformIO action)
13:52:30 <lambdabot> IO a -> (a -> r) -> r
13:52:48 <aweinstock> mbrgm: ^ (although that's probably not what you want)
13:53:57 <aweinstock> :t \action maybeArrow -> maybeArrow (System.IO.Unsafe.unsafePerformIO action) :: IO a -> (a -> Maybe b) -> Maybe b
13:53:58 <lambdabot>     Couldn't match expected type ‘a1
13:53:58 <lambdabot>                                   -> IO a2 -> (a2 -> Maybe b1) -> Maybe b1’
13:53:58 <lambdabot>                 with actual type ‘r’
13:54:05 * hackagebot extra 1.4.2 - Extra functions I use.  https://hackage.haskell.org/package/extra-1.4.2 (NeilMitchell)
13:54:13 <aweinstock> :t (\action maybeArrow -> maybeArrow (System.IO.Unsafe.unsafePerformIO action)) :: IO a -> (a -> Maybe b) -> Maybe b
13:54:14 <lambdabot> IO a -> (a -> Maybe b) -> Maybe b
13:55:28 <monochrom> I disagree with using unsafePerformIO as part of a general, blanket answer
13:56:45 <johnw> monochrom++
13:56:48 <monochrom> that is, until you know the original, specific, ungeneralized problem, you do not have just cause to involve it
13:56:54 <EvanR> he probably wants unsafeCoerce obv
13:57:07 <aweinstock> that is one of the only sensible instantiations of (IO a -> (a -> Maybe b) -> Maybe b) though
13:57:56 <aweinstock> :t const (const Nothing) :: IO a -> (a -> Maybe b) -> Maybe b
13:57:57 <lambdabot> IO a -> (a -> Maybe b) -> Maybe b
13:58:03 <quchen> I didn't see the question but IO a -> (a -> Maybe b) -> Maybe b is highly questionable.
13:58:05 <EvanR> (IO a -> (a -> Maybe b) -> Maybe b) would be an awful library function
13:58:23 <quchen> Unless it's f _ _ = Nothing.
13:58:29 <monochrom> quchen: what you saw is already all there is to see.
13:58:37 <quchen> Oh.
13:58:46 <aweinstock> agreed, IO (Maybe b) is almost certainly more sensible
13:58:57 <monochrom> there have been only "how to IO a -> Maybe a" and this one.
13:59:01 <EvanR> @djinn IO a -> (a -> Maybe b) -> IO (Maybe b)
13:59:01 <lambdabot> Error: Undefined type IO
13:59:09 <quchen> pure Nothing
13:59:30 <aweinstock> :t (>>=) :: IO a -> (a -> Maybe b) -> IO (Maybe b)
13:59:31 <shachaf> aweinstock: You can't give a sensible answer to a nonsensical question.
13:59:31 <lambdabot>     Couldn't match type ‘Maybe’ with ‘IO’
13:59:31 <lambdabot>     Expected type: IO a1 -> (a1 -> Maybe b1) -> IO (Maybe b1)
13:59:31 <lambdabot>       Actual type: IO a1 -> (a1 -> IO (Maybe b1)) -> IO (Maybe b1)
14:00:09 <aweinstock> :t flip fmap :: IO a -> (a -> Maybe b) -> IO (Maybe b)
14:00:10 <lambdabot> IO a -> (a -> Maybe b) -> IO (Maybe b)
14:00:20 <EvanR> ^
14:00:41 <hexagoxel> :exf "IO a -> (a -> Maybe b) -> IO (Maybe b)"
14:00:42 <exferenceBot> \ i1 f2 -> fmap f2 i1
14:01:45 <quchen> dfeuer: Hello! Time to talk a bit about the Github comments? :-)
14:02:02 <quchen> I read them all because of the notification emails, so deletion is futile :-þ
14:02:07 <monochrom> "to comment on comments"... :)
14:02:09 <dfeuer> quchen, I'm on the phone right now.
14:02:40 <quchen> monochrom: Ah, what an opportunity missed.
14:03:04 <mbrgm> johnw, aweinstock: ty
14:04:14 <monochrom> quchen: shachaf made a great one earlier today. "exceptions sound like a good idea, but there are catches"
14:04:39 <quchen> Such as there not being a catch? :-)
14:04:43 <Jinxit> hah
14:05:11 <quchen> Or the classic "throw new ValidResult(...)"
14:05:11 <monochrom> it was made when someone brought up the "catches" function as opposed to the "catch" function, so he went with that.
14:05:58 <monochrom> or maybe he did say "there is a catch". I probably misremember.
14:06:10 <drumrawl> :t let merge (a:t) (b:r) = (a++b) : merge t r in merge
14:06:11 <lambdabot> [[a]] -> [[a]] -> [[a]]
14:06:25 <drumrawl> @pl let merge (a:t) (b:r) = (a++b) : merge t r in merge
14:06:26 <lambdabot> fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip ((.) . flip . (((.) . (:)) .) . (++)))
14:06:51 <quchen>  @pl is either obvious or useless ಠ_ಠ 
14:07:07 <nolrai66> quchen: yeah, pretty much.
14:07:23 <Shockk> what's pl? point-less?
14:07:26 <monochrom> yes
14:07:39 <nolrai66> If we had true data-flow like with wires, then point-less could work.
14:07:48 <drumrawl> quchen: must be someth w/ uncurry and fix that's readable, I thought.
14:07:55 <Shockk> @pl let f g x y = g x y
14:07:55 <lambdabot> (line 1, column 20):
14:07:55 <lambdabot> unexpected end of input
14:07:55 <lambdabot> expecting variable, "(", operator, ";" or "in"
14:08:09 <nolrai66> But otherwise the flips and "." end up crazy.
14:08:21 <Shockk> oh, right, never mind me
14:08:22 <quchen> drumrawl: zipWith (++)
14:08:46 <monochrom> oh! hehe
14:08:58 <clrnd> @unpl fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip ((.) . flip . (((.) . (:)) .) . (++)))
14:08:58 <lambdabot> fix (\ ar d -> (tail >>= \ cx -> return ((\ ch k b -> (tail >>= \ be -> return ((\ y am -> ((:)) ((head ch) ++ (head y)) (ar k am)) b be)) b) d cx)) d)
14:09:02 <quchen> Oh boy.
14:09:14 <drumrawl> quchen: let me crawl in a corner and weep for an hour or two
14:09:26 <monochrom> #haskell humans are a better @pl than lambdabot's @pl
14:09:29 <quchen> That doesn't sound very helpful
14:09:57 <Gurkenglas> @pl fix (\ ar d -> (tail >>= \ cx -> return ((\ ch k b -> (tail >>= \ be -> return ((\ y am -> ((:)) ((head ch) ++ (head y)) (ar k am)) b be)) b) d cx)) d)
14:09:58 <lambdabot> fix (join . (((tail >>=) . (return .)) .) . flip flip id . ((flip . (liftM2 ((tail >>=) . (return .)) .)) .) . flip ((.) . flip . (((.) . (:)) .) . (. head) . (++) . head))
14:10:23 <quchen> monochrom: 1. post horrible ?pl on #haskell. 2. Skip the rambling about the cryptic output. 3. copy human-made result
14:10:24 <clrnd> TODO: make a website where people submit code, and other people @pl it, and rankings and stuff
14:10:37 <monochrom> :)
14:10:39 <shiona_> so, others do that too. I guess someone should write "@fix @pl @unpl"
14:10:50 <quchen> Hey guys, did you know that you can't implement join with Monad alone?
14:10:52 * quchen waits 
14:11:14 <monochrom> I used to know. but I no longer know.
14:11:21 <drumrawl> no.
14:11:50 <KaneTW> maybe
14:11:50 <johnw> isn't it just (>>= id)?
14:11:58 <KaneTW> :t just (>>= id)
14:11:59 <lambdabot>     Not in scope: ‘just’
14:11:59 <lambdabot>     Perhaps you meant data constructor ‘Just’ (imported from Data.Maybe)
14:12:03 <KaneTW> oh
14:12:06 <KaneTW> goddamn
14:12:08 <KaneTW> brainfart
14:12:09 <monochrom> wait, I misremembered. I didn't know.
14:12:11 <KaneTW> :t (>>= id)
14:12:12 <lambdabot> Monad m => m (m b) -> m b
14:12:24 <quchen> So that's less than 2 minutes for the correct answer.
14:12:32 <monochrom> in what sense is join not implementable with Monad alone?
14:12:33 <quchen> Fairly good I'd say!
14:12:45 <KaneTW> sometimes people use fmap
14:12:50 <monochrom> oh ha I see what you mean
14:12:53 <quchen> :-)
14:12:55 <Gurkenglas> :exf (forall a. a -> m a) -> (forall b c. m b -> (b -> m c) -> c) -> m (m a) -> m a
14:12:55 <exferenceBot> \ f1 f2 c -> f2 c f1
14:12:55 <exferenceBot> \ f1 f2 c -> f2 (f1 c) id
14:12:55 <exferenceBot> \ f1 f2 c -> f1 (f2 c id)
14:13:23 <Gurkenglas> Of course, I forgot an m.
14:13:48 <quchen> What is that
14:14:10 <quchen> Some pure-ish function and a semi-CPS'd bind thing can create join?
14:14:21 <quchen> Oh, that's the missing "m" there, I see.
14:16:39 <Gurkenglas> :exf "(forall b c. m b -> (b -> m c) -> m c) -> m (m a) -> m a"
14:16:39 <exferenceBot> \ f1 b -> f1 b id
14:16:55 <Gurkenglas> Allowing unusued parameters doesn't seem to be working right now
14:17:33 <hexagoxel> flag is -u
14:17:59 <hexagoxel> (to allow unused parameters in solutions of exference)
14:18:27 <EvanR> in what sense is join not implementable with Monad lone?
14:18:31 <EvanR> alone
14:18:41 <johnw> EvanR: I think quchen was baiting us to act as a human @pl for him
14:18:50 <EvanR> lol
14:18:53 <ps___> hi! I have install HLearn in a sandbox... but the import HLearn... fails... how can I use the lib from the sandbox?
14:18:57 <EvanR> @src join
14:18:57 <lambdabot> join x = x >>= id
14:19:06 * hackagebot google-translate 0.1.0.1 - Google Translate API bindings  https://hackage.haskell.org/package/google-translate-0.1.0.1 (DavidJohnson)
14:19:15 <KaneTW> @pl \x -> x >>= id
14:19:15 <lambdabot> join
14:19:18 <KaneTW> nooo
14:19:52 <hexagoxel> ps___: use `cabal repl` instead of ghci
14:19:54 <quchen> ps___: GHCi isn't sandbox-aware by default. You need to run "cabal repl" to do so.
14:19:58 <quchen> Or "cabal exec ghci".
14:20:30 <ps___> ok..and to use ghc? cabal exec?
14:20:48 <quchen> When using Cabal you typically don't invoke GHC yourself.
14:20:56 <quchen> "cabal build" compiles the program, for example.
14:21:02 <quchen> "cabal run" runs the main function.
14:21:13 <quchen> "cabal install" builds and installs it.
14:21:30 <quchen> I never used "cabal exec ghc", but it should … well, do something.
14:21:31 <Shockk> does cabal run, run the executable target defined in the cabal file?
14:21:38 <ps___> yeah but I have written a small test program that uses HLearn
14:21:50 <quchen> ps___: cabal repl → :main
14:21:52 <ps___> just some foo.hs
14:21:58 <Shockk> also, I don't know about "cabal exec ghc" but I do know that "cabal exec ghc-pkg" does work correctly in the sandbox
14:22:06 <KaneTW> cabal exec ghc works correctly
14:22:14 <quchen> Good to know.
14:22:27 <ps___> ok ok
14:22:27 <Shockk> I've done "cabal exec ghc-pkg list | grep whatever" to see if packages are installed in the sandbox sometimes
14:23:00 <ps___> weird thing is, it cannot find HLearn.Algebra (but HLearn.Distributions can be found)
14:23:05 <monochrom> yeah, it's how to tell ghc-pkg to be aware of your sandbox
14:23:43 <ps___> I mean when I pwd to the sandbox and type cabal exec ghc ../bar/foo.hs
14:24:16 <Shockk> https://hackage.haskell.org/package/HLearn-algebra
14:24:24 <Shockk> ps___: it's a separate package as far as I can tell
14:25:07 <ps___> but HLearn.distributions depends on HLearn.Algebra :S https://hackage.haskell.org/package/HLearn-distributions
14:25:23 <ps___> I installed everything via git
14:26:08 <Shockk> I don't know if this applies, but it might be that HLearn-algebra is a hidden package because it's not defined as a dependency in cabal file or something 
14:26:19 <ps___> hmmm
14:26:32 <Shockk> that happens if you do the same and use simply cabal build
14:26:58 <lpaste_> Pro9 pasted “What to use instead of two where-clauses in one function?” at http://lpaste.net/2187016476907536384
14:27:27 <ps___> Shockk: you mean inside a sandbox cabal build?
14:27:50 <ps___> I did cabal sandbox init...cabal install --only-dependencies, then cabal build and in the end cabal install
14:28:15 <quchen> Pro9: one where clause!
14:28:43 <Shockk> I mean, when you're doing `cabal build` to compile some source you have, you can't import from hidden packages 
14:29:05 <Shockk> and packages are hidden unless they're in the depends in your cabal file
14:29:15 <Pro9> quchen: how do you combine the two where-clauses I have into one, I tried, but I couldn't get it to work?
14:29:15 <Shockk> but I don't know if that relates to running `cabal exec ghc` to compile your source
14:29:22 <Sonolin> [ className =?  c --> doFloat | c <- myFloatsC ]
14:29:29 <Sonolin> is that | part standard syntax ?
14:29:30 <lpaste_> quchen annotated “What to use instead of two where-clauses in one function?” with “What to use instead of two where-clauses in one function? (annotation)” at http://lpaste.net/2187016476907536384#a140995
14:29:38 <quchen> Like that Pro9 ^
14:29:50 <quchen> Align the blocks' contents
14:29:59 <Pro9> quchen: ahha, thanks' :)
14:30:14 <Shockk> Sonolin: that's called a list comprehension and it is; I don't know what the =? and --> part mean though
14:30:22 <quchen> Pro9: The first token after "where" defines where the block begins, i.e. at which level of horizontal alignment.
14:30:35 <ps___> actually I followed this guide.. https://github.com/mikeizbicki/HLearn/wiki/quick-and-dirty-installation-guide
14:30:57 <Sonolin> Shockk: thanks I'll look that up, already figured those out (from XMonad ManageHelpers) :)
14:30:59 <stapler> hi! any advice for getting productive quickly with haskell?
14:31:11 <quchen> stapler: Work with people that know Haskell
14:31:21 <Shockk> Sonolin: a list comprehension works like: [x * 2 | x <- [1..5]]
14:31:30 <Shockk> the resulting list is [2,4,6,8,10]
14:32:05 <Cale> stapler: How far along are you in learning the language?
14:32:23 <Shockk> you can have predicates I think too, after the input list, but I've never used those and forgot how they're written
14:32:29 <stapler> Cale: i guess i understand monads/monad transformers
14:32:50 <Denommus> ok, iterate is super useful
14:33:39 <Cale> stapler: Okay, so you likely know a fair amount of the basics of the language, and now it's mostly going to be about learning libraries and picking up idioms as you go.
14:34:20 <Cale> Harder to give solid advice for that part than the earlier part, because everyone is going to be doing different stuff with the language :)
14:35:07 <Shockk> stapler: I learned a lot of things over the last year or so, simply by trying to write projects that interested me
14:35:24 <Shockk> some of those projects I abandoned and some I rewrote from scratch after I'd learned stuff
14:35:40 <Cale> But yeah, I guess all there is to do is to *attempt* to be productive and see how it goes. Don't be too scared if it feels like you're mostly thinking about how to do things rather than typing in code.
14:37:24 <Cale> You can get a lot of things done with not a lot of code in Haskell, so even though the connection between productivity and how much you're typing into your editor is weak in programming in general, it can be substantially weaker in Haskell :)
14:38:32 <Cale> But if it feels like you're getting hung up for too long, it can be a good approach to just get *something* working from input to output, and then build out around that.
14:39:19 <stapler> am i right in thinking a monad is like a uh context
14:39:34 <Cale> I don't like to think of them in that sense
14:39:46 <Cale> People use that word, but I'm never totally sure what they mean
14:40:28 <stapler> like passing a struct around
14:40:37 <Shockk> I might be wrong but my thinking is that a monad is a sequence of computations in order
14:40:51 <quchen> A Monad is something that obeys the monad class. What it *means* do be a Monad is something you get used to, not something you can say in a sentence.
14:40:56 <Cale> A monad is a type constructor M which supports an API that has a particular shape, in particular, it has a definition for  return :: a -> M a, and it has a definition for (>>=) :: M a -> (a -> M b) -> M b
14:41:02 <Shockk> stapler: the State monad is like that, but a monad doesn't have to have a context like that
14:41:10 <Cale> and in terms of those, many fun things can be defined
14:41:22 <Cale> stapler: One example of such an M is the type constructor for lists
14:41:33 <Cale> i.e. we have  return :: a -> [a]
14:41:36 <quchen> Understanding monads means understanding the utility of the handful of things that make one. If there is a shortcut to teaching monads, nobody's found it yet. :-s
14:41:40 <Cale> and  (>>=) :: [a] -> (a -> [b]) -> [b]
14:42:01 <Cale> It's unclear how these have anything to do with a "context"
14:42:11 <stapler> i see
14:42:21 <ReinH> stapler: Very few monad instances resemble passing a struct around.
14:43:00 <Cale> Basically, Monad is an abstraction over a pattern which occurs in many libraries, and by abstracting over that pattern, we get a bunch of things which work with any of those libraries.
14:43:12 <Cale> A key example is sequence
14:43:14 <Cale> :t sequence
14:43:15 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
14:43:15 <dmj`> Anything that implements the Monad typeclass and obeys the monad laws is a Monad (L/R identity + associativity). Identity, State, Maybe, Either, Writer, (->), Reader, all do that
14:43:23 <Cale> ugh, I don't want to talk about Traversable!
14:43:25 <Cale> Okay
14:43:31 <ReinH> heh
14:43:34 <Cale> sequence :: Monad m => [m a] -> m [a]
14:43:43 <Shockk> a monad is something like a box, and you can take a normal value and return it to be inside of that box, and you can do something with the thing inside the box to get another thing inside the box as your result
14:44:06 <dmj`> all monads are burritos, but not all burritos are monads
14:44:09 <Cale> Shockk: sort of, but that view can be confusing if you don't have a sufficiently general notion of what a box is
14:44:09 <ReinH> Shockk: please no
14:44:11 <geekosaur> except that it is not a box
14:44:12 <ReinH> A monad is not something like a box
14:44:37 <Cale> For example, IO is a monad, but IO actions are not very much like boxes
14:44:53 <ReinH> Shockk: do you think a recipe for carrot cake is like a box?
14:44:54 <kadoban> [] is quite a bit not like a box either
14:44:54 <quchen> Some monads are boxy, just like some naturals are prime.
14:44:55 <awpr> we clearly need more bad analogies.  a monad is a burrito where the tortillas are still moist so they can be 'join'ed into one tortilla
14:45:05 <Shockk> :(
14:45:12 <Cale> Executing an IO action to produce a result is not very much like pulling a value out of a box, because that analogy makes one think that the value was somehow already inside the box.
14:45:19 <dmj`> (->) doesn't feel like a box
14:45:30 <quchen> ?quote kmc synonymous
14:45:30 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
14:45:31 <Cale> (->) e  kind of feels like a box
14:45:39 <sbrg> lmao
14:45:51 <Cale> Functions e -> a can be thought of as giant boxes indexed by values of type e
14:46:01 <Cale> containing values of type a
14:46:04 <sbrg> the question is: if you have a burrito what are you doing talking about monads when you could be eating a burrito?
14:46:08 <ReinH> Parser is a good example to demonstrate the wobbliness of most monad analogies.
14:46:12 <Cale> If that helps you, then go ahead
14:46:19 <Cale> Yeah, Parser is the best example monad :)
14:46:24 <ReinH> A Parser Foo does not "contain" a Foo by any reasonable definition
14:46:36 <ReinH> It is not a Foo with a context.
14:46:43 <ReinH> It is not a Foo in a box.
14:46:55 <Denommus> but it is like a burrito
14:47:01 <dmj`> The State burrito has different toppings added to it as you progress in line
14:47:08 <ReinH> dmj`: isn't that Writer?
14:47:10 <Shockk> I can't really think of a good analogy now
14:47:23 <ReinH> Shockk: Analogies are a trap.
14:47:34 <Denommus> a monad is just an applicative functor with a join function
14:47:40 <dmj`> ReinH: that's true, a Writer Burrito is isomorphic to Chipotle
14:47:43 <awpr> dmj`: the Indexed State Burrito allows you to change the type of toppings as you execute
14:47:56 <ReinH> dmj`: Mmmm.... chipotle...
14:48:25 <ReinH> quchen: that kmc quote is great
14:48:37 <Cale> The best analogy for programming in Haskell is that values of type M a when M is a monad are to be thought of as computations, which may be executed to result in values of type a. This gets weird in the case of the list monad, but one can think of "running" a list as meaning to pick an element from it in all possible ways.
14:48:42 <quchen> ReinH: All kmc quotes are! :-)
14:48:45 <ReinH> :)
14:49:07 <stapler> i went from understanding it ok-ly back to square one
14:49:17 <Denommus> Cale: you can think about lists as non-deterministic computation
14:49:20 <Cale> yes
14:49:55 <kadoban> stapler: Understand the type of (>>=) and return, and then use several different examples, like IO, Parsec, Maybe, maybe [], until it clicks.
14:49:55 <Cale> (to rephrase what I'm saying)
14:50:24 <quchen> FWIW it never clicked for me, at some point I realized that I don't find it awkward anymore and that was that
14:50:48 <kadoban> stapler: Nothing anyone ever said to explain it helped until I did that, and then it became totally obvious.
14:51:03 <ReinH> It helps to accumulate as many different kinds of monad interpretation as possible, but don't get too fixated on "monads are contexts" or "monads are boxes" or any other particular analogy
14:51:09 <Cale> The whole point is just that there are many libraries which define operations which have types like return and (>>=), and those things interact in a particular nice way
14:51:12 <stapler> kadoban: i do understand the type of >>= and return 
14:51:22 <kadoban> stapler: Then you're 1/2 way there :)
14:51:26 <dmj`> when you 'get' monads, you cease to be able to explain them - the 4th monad law
14:51:26 <Cale> and by abstracting over them, we can write some code once, and not have to rewrite it every time for each of those libraries
14:51:32 <ReinH> Monads are also for variable substitution or parallel term rewriting or tree grafting or...
14:51:44 <Denommus> stapler: monads are just types associated with those two functions, following some laws
14:51:52 <Cale> What return and (>>=) actually *do* will depend on which actual type you're talking about
14:51:56 <Denommus> stapler: if you understand those functions, you mostly understand monads
14:52:12 <ReinH> If you also understand the laws then you completely understand monads ;)
14:52:21 <Cale> So the best advice is not to try to bother understanding Monad until you understand many individual monads.
14:52:48 <Cale> (apart from "I know that I can substitute the m's in these types for the specific case I'm using"
14:52:49 <Cale> )
14:53:03 <Cale> So look at sequence
14:53:11 <Cale> sequence :: (Monad m) => [m a] -> m [a]
14:53:32 <Cale> The computational analogy for what sequence does is that it takes a list of computations whose result has type a
14:53:49 <Cale> and it's going to somehow glue them together into a single computation whose result is a list of values of type a
14:54:40 <Cale> sequence [] = return []  -- if the list of computations is empty, we produce the computation which does nothing apart from producing the empty list as its result
14:55:03 <Cale> (In this analogy, return v is always the computation which "does nothing" (whatever that means), and has v as its result)
14:55:34 <Cale> sequence (x:xs) = do v <- x; ... -- if the list is nonempty, we will first execute the first computation in it, getting some result v ...
14:56:12 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- and then we will execute the remainder of the list of computations, getting a list of results vs ...
14:56:14 <Qndel> is it possible to put a set in IOREF?
14:56:43 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- finally, we will do nothing additional, but produce the combined list (v:vs) as the result of our overall computation
14:57:00 <KaneTW> yes
14:57:33 <awpr> it's possible to put anything into an IORef.  Well... except Void, I suppose.
14:57:43 <Cale> In something like the IO instance, where our computations are IO actions, this interpretation is very natural. Executing an IO action will carry out the effects that it describes, and the actions are executed in the order which you'd expect.
14:58:08 <Tehnix> Anyone have any good articles that explain the magic behind Parsec?
14:58:11 <quchen> awpr: Well, if you have a Void, you can put it into an IORef as well.
14:58:13 <Cale> So sequence, when given a list of IO actions, will produce an IO action which when executed, will execute each of the actions in the list in turn, and produce a list of the results.
14:58:34 <quchen> awpr: For strict IORefs that's not possible, but the default is lazy iirc.
14:59:08 * hackagebot GPipe 2.0.2 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.0.2 (TobiasBexelius)
14:59:20 <Cale> In something list a parsing monad, sequence, given a list of parsers for values of type a, will essentially concatenate the parsers together into a single parser which parses the remaining input from the previous parser with each in turn
14:59:32 <Cale> and again, collecting a list of the result
14:59:32 <Cale> s
14:59:56 <dmj`> Qndel: sure
14:59:58 <Cale> In the list monad, sequence will take a list of lists, and pick one element from each of them, collecting up all the possible lists of results
14:59:59 <KaneTW> that's amusing
15:00:05 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
15:00:06 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
15:00:13 <awpr> quchen: if I had a Void I could also fabricate an IORef without doing any IO :)
15:00:15 <dmj`> :t newIORef (S.empty)
15:00:16 <lambdabot>     Not in scope: ‘newIORef’
15:00:16 <lambdabot>     Perhaps you meant ‘newSTRef’ (imported from Data.STRef)
15:00:25 <KaneTW> ghci never returns when attempting to read a IORef Void; i'd expect it to error out
15:00:31 <Cale> stapler: Following along? :)
15:01:19 <tempay> So why is logarithmic time the standard for maps? why cant we have hashmaps that arent wrapped in Io
15:01:36 <Cale> tempay: Any function whose range has n elements must take at least O(log n) time
15:01:48 <quchen> awpr: Maybe it's more useful to say that an IORef "fully lazy and parametric in its contents".
15:02:04 <quchen> awpr: It's roughly the same as being able to contain Void, but much more useful in practice.
15:02:11 <Cale> tempay: This is a fundamental property of computation which elementary descriptions of hashmaps like to shove under the rug.
15:02:12 <tempay> Cale: why's that?
15:02:37 <Cale> tempay: Because you must examine at least log_2 n bits of the input in order to decide between n cases
15:03:22 <Zekka> Less mathematical: you need to make log_2 n yes/no decisions to identify a specific one of n cases?
15:03:26 <Cale> right
15:04:05 <Cale> Computing hashes is not free, it's often not even cheap
15:04:50 <Zekka> Cale: Right: any hash that disambiguates n elements of input must produce at least log_2 n bits of output, correct?
15:04:57 <Cale> right
15:05:12 <Zekka> But the hope is that it's cheap to make the decisions necessary to build the rsult of the hashing function, where it may be expensive to do log_2 n *comparisons*
15:05:31 <Zekka> and the hope is that it's so cheap that you can treat it as negligible, even though for many subject types it may not be
15:05:50 <Zekka> (e.g. using memory address as a hashing function for values with identity)
15:06:22 <Cale> Yeah, so people say stuff like that it's "O(1)" when that's a complete lie, because if you don't bound the size of your hashtable, you're really going to have to spend longer and longer computing hashes.
15:06:32 <ReinH> The way they get away with saying O(1) is that the hashing function is O(log n) for a fixed n (the entire size of its domain) ;)
15:06:36 <KaneTW> hmm
15:06:41 <Cale> and if you *do* bound the size of your data structure from the outset, then asymptotic analysis is meaningless
15:07:00 <ReinH> (at least O(log n))
15:07:07 <Cale> (because everything is constant time)
15:07:11 <Qndel> how would I tell a function that I'm passing Set as argument?
15:07:25 <quchen> f :: Set -> …
15:07:32 <KaneTW> is there a reason `absurd` is implemented the way it is (absurd a = let spin (Void b) = spin b in a `seq` spin a)
15:07:37 <ReinH> similarly, O(log n) space is really constant space on real machines, where the constant is the total amount of available space ;)
15:07:43 <Cale> presumably Set has an argument type there...
15:07:50 <Cale> At least if it's Data.Set
15:07:54 <tempay> so can haskell get asymptomatic identical hashmaps to imperative languages in a pure way?
15:08:07 <quchen> KaneTW: Yes. If you call "absurd" on an "error" value, this gives you the error, instead of infinite recursion or something like that.
15:08:20 <KaneTW> ah
15:08:22 <Cale> tempay: You might be interested in unordered-containers
15:08:27 <Qndel>  IORef Set.Set -> (GLfloat,GLfloat) doesn't work
15:08:32 <Cale> https://hackage.haskell.org/package/unordered-containers
15:08:38 <awpr> Qndel: Set.Set isn't a type
15:08:47 <awpr> er, isn't kind *
15:08:55 <Qndel> I have this import import qualified Data.Set as Set
15:09:06 <Qndel> haskell didn't recognise Set alone
15:09:07 <Cale> tempay: HashMap and HashSet are almost drop-in replacements for Map and Set respectively, but require hashing rather than ordering.
15:09:08 <KaneTW> i assume ghc detects the infinite loop eventually and cancels with <<loop>>
15:09:13 <awpr> It needs to be IORef (Set.Set something)
15:09:23 <Cale> tempay: In practice, I've often found that Map and Set can win.
15:09:25 <Qndel> ok thanks :)
15:09:33 <stapler> Cale: so i guess the advice is to just start using haskell
15:09:34 <Denommus> I think a nice analogy for monads is saying monads are like the Command Pattern
15:09:36 <quchen> KaneTW: GHC can detect some infinite loops. Not all, because that's impossible.
15:09:39 <Cale> stapler: Yes!
15:09:48 <KaneTW> yeah, i'm aware
15:09:49 <quchen> KaneTW: A <<loop>> means GHC detects that a thunk depends on itself.
15:09:57 <quchen> let x = x in x, for example.
15:10:00 <Cale> stapler: Once you've seen a bunch of examples of things, you'll start understand why we're abstracting certain patterns out.
15:10:05 <Denommus> in that you build a recipe for a given value, as if you were working directly with the value, but never actually touching it
15:10:06 <KaneTW> just ran into ghci looping when i did show (undefined ;: Void)
15:10:12 <KaneTW> on an older ghc version
15:10:14 <Zekka> My suspicion case for Haskell-style maps: where your map is big enough that log n starts to get big, and you're duplicating parts of a comparison
15:10:27 <Zekka> But you can still get OK performance afaik by precomputing a hash value
15:10:37 <Cale> stapler: It's really just avoiding code duplication, but in a way that happens to have a rich mathematical story behind it (that you don't have to know at all to actually get things done)
15:10:56 <quchen> log(n) never gets big in practice.
15:10:56 <Cale> stapler: (I mean specifically the Monad stuff)
15:11:03 <stapler> right
15:11:04 <Zekka> quchen: Well, 30 is still pretty big compared to 1
15:11:08 <KaneTW> > show (undefined :: Void)
15:11:09 <lambdabot>  Not in scope: type constructor or class ‘Void’
15:11:16 <Zekka> As a general rule, for all n, log(n) <= 30
15:11:27 <Cale> tempay: Another thing to be aware of are IntMap and IntSet, which have technically constant time operations because Ints are only so large.
15:11:40 <Cale> tempay: (but if the size of Int changes, the complexity of the operations will change)
15:12:00 <quchen> > log (fromIntegral (maxBound :: Int64))
15:12:02 <lambdabot>  43.66827237527655
15:12:08 <quchen> That's fairly giant
15:12:34 <Zekka> quchen: Don't pretend you have int64 of memory!
15:12:53 <Qndel> Data.Traversable.forM collectDots2 $ \(x,y) -> preservingMatrix $ do
15:12:59 <Qndel> this worked for each element of a list
15:13:00 <Zekka> Also, that's log base 10, not log base 2
15:13:00 <Cale> Yeah, everyone should just ignore logarithmic factors in asymptotic complexity for the most part, and treat them as part of the constant term.
15:13:05 <Qndel> how to make it work for each element of a set? :P
15:13:12 <KaneTW> i guess i should update the system ghc on my server; show (undefined :: Void) loops forever on ghc 7.6.x, but properly errors out with Prelude.undefined on 7.10.2
15:13:16 <Cale> You really have to benchmark things to know how well they work in any given setting.
15:13:24 <quchen> You should just ignore asymptotic complexity in general.
15:13:29 <Zekka> I still think the difference between 30 and say 5 is pretty significant for a lot of programs
15:13:29 <anks> hello, im getting familiar with recursion schemes.. I tried to write a function that folds every level of rose tree with some [a]->b function, and things got a little bit ugly, do I miss some prettier solutions? https://gist.github.com/7c4da0f01d78433fc870
15:13:34 <KaneTW> asymptotic complexity is a trap
15:13:38 <Cale> quchen: Mostly, I'd agree with that.
15:14:06 <Cale> It does kind of matter how things scale with input size
15:14:14 <quchen> "scales like" is a good thing to keep in mind, yes.
15:14:17 <frerich> I'd say it's acceptable to ignore asymptotic complexity, but it's inacceptable to be ignorant about it.
15:14:19 <Zekka> I think the constant factor for comparisons individually is lower than for hashes, but for many types there's a natural hashing scheme which you can still exploit with a tree map
15:14:19 <quchen> But that's not what complexity means.
15:14:37 <Cale> But unfortunately, asymptotic complexity doesn't necessarily tell you anything about how things scale at the sizes you care about.
15:14:57 <Zekka> The nice thing about comparisons is that you can often use laziness -- although you can do it for something like a hashing scheme too
15:15:03 <Cale> Because it's always for values larger than some unspecified constant which might be unimaginably large for all you know.
15:16:42 <quchen> mergesort that falls back to slowsort for lists smaller than Graham's number is still O(n*log(n)). It's also a terrible algorithm in a certain sense.
15:17:10 <quchen> It's also a fairly interesting algorithm in other ways, such as easily implementable in-place, stable, trivial to parallelize and all those good things ;-)
15:17:30 <KaneTW> it also works well in real-life
15:17:44 <quchen> No, I would not say that about Slowsort.
15:17:55 <KaneTW> no, mergesort
15:18:03 <quchen> Oh, that one, yes.
15:18:47 <ReinH> quchen: also sorted lists form a monoid with merge :D
15:19:06 <stapler> Cale: so do you think i could fumble around with scotty and postgresql-simple and come up with something
15:19:09 * hackagebot implicit 0.0.5 - Math-inspired programmatic 2&3D CAD: CSG, bevels, and shells; gcode export..  https://hackage.haskell.org/package/implicit-0.0.5 (mmachenry)
15:19:24 <ReinH> a commutative monoid, even
15:19:29 <quchen> ReinH: Do they? Interesting.
15:19:46 <quchen> Commutative is hard to say in practice.
15:19:57 <quchen> Things might have payloads attached to them that don't affect order.
15:19:58 <zomg> stapler: just give it a try :) Scotty is reasonably simple at least, just try to get one of them working and see if you can put them together then
15:20:05 <Cale> stapler: Yeah, probably!
15:20:09 <Qndel> Data.Traversable.forM collectDots2 $ \(x,y) -> preservingMatrix $ do
15:20:15 <Qndel> this worked when collectDots2 was a list
15:20:20 <Cale> stapler: and feel free to ask people questions here if you get stuck
15:20:20 <Qndel> how to make it work for a set?
15:20:22 <frerich> stapler: I had some nice successes with scotty and mysql-simple
15:20:24 <ReinH> quchen: pigworker to the rescue again http://stackoverflow.com/a/28994079
15:20:44 <stapler> cool. ill play with it.
15:20:45 <stapler> thanks guys.
15:21:02 <ReinH> quchen: commutative up to the relation used to sort ;)
15:21:20 <quchen> Then I agree.
15:21:27 <quchen> Interesting, never thought of it as monoidal.
15:21:40 <ReinH> quchen: yeah, it is :)
15:22:03 <alexv19> Will GHC unbox this: `data A a = A a; data B = B {-# UNPACK #-} !(A Int)` into `data B = B Int#` ?
15:22:13 <ReinH> quchen: so insertion sort is ala' Merge foldMap (:[]) :D
15:22:28 <quchen> uuuhyea maybe
15:22:32 <quchen> I have no idea what that means.
15:22:47 <quchen> ala = ana + newtype fiddling?
15:22:51 <quchen> eh, hylo
15:22:59 <ReinH> merged . foldMap (Merge . (: [])) :)
15:23:18 <ReinH> merge all the singleton lists together
15:23:32 <fmapE> Any idea why the GHC RTS might error with <<loop>> when I make an ffi call to sched_setscheduler?
15:23:52 <ReinH> quchen: so at each step it inserts a singleton list into the already sorted accumulator
15:24:09 * hackagebot wai-middleware-static 0.8.0 - WAI middleware that serves requests to static files.  https://hackage.haskell.org/package/wai-middleware-static-0.8.0 (AndrewFarmer)
15:24:31 <quchen> ReinH: Hm, interesting. Not very efficient though.
15:24:36 <quchen> Wait, that depends on foldMap.
15:24:45 <ReinH> quchen: well no, it's insertion sort ;)
15:25:05 <quchen> Not really: foldMap that splits in halves makes it mergesort
15:25:15 <quchen> Well, for finite inputs at least.
15:25:20 <ReinH> quchen: treeFoldMap, aye
15:25:40 <ReinH> quchen: that's why I think mergesort is an elegant algorithm :)
15:25:41 <quchen> What I'm trying to say is that it's not as terrible if you use it in a smart way. But still terrible.
15:26:21 <ReinH> quchen: that's exactly right: a right fold is insertion sort while a tree fold is merge sort. That's what a I like about mergesort.
15:26:25 <ReinH> s/a I/I
15:26:39 <ReinH> (a right or left fold, actually)
15:27:10 <ReinH> quchen: also the relationship to bubblesort is intriguing http://stackoverflow.com/questions/21877572/can-you-formulate-the-bubble-sort-as-a-monoid-or-semigroup/21879087#21879087
15:27:40 <zipper> From typeclassopedia "The fail function is an awful hack that has no place in the Monad class; more on this later."
15:27:53 <zipper> I had no idea. I thought fail was awesome and I use it everywhere.
15:28:15 <hpc> it is both
15:28:20 <ReinH> zipper: MonadFail might be a useful typeclass, but including it in Monad is an awful hack.
15:28:24 <geekosaur> it's kinda orthogonal to monads. it's useful for do notation.
15:28:39 <geekosaur> I believe ghc8 hs plans to separate it back out
15:28:44 <ReinH> yay
15:28:53 <zipper> ReinH: Hmm I never heard of MonadFail
15:28:58 * quchen is hoping to do the relevant work in the next week
15:29:10 <quchen> It's mostly a rebase and a giant fix-ghc-warnings commit.
15:29:13 <quchen> Hopefully.
15:29:32 <geekosaur> zipper, at the moment it's still conjectural.
15:29:40 <geekosaur> back in the day, there was MonadZero
15:29:40 <ReinH> zipper: It's what you get if you move fail out of Monad into class Monad m => MonadFail m where fail :: String -> m a
15:29:57 <quchen> + left-zero law
15:30:03 <ReinH>  right
15:30:08 <zipper> geekosaur: hmmm there's something with haskell programmers and using words I don't understand.
15:30:10 <zipper> haha
15:30:33 <ReinH> zipper: that's true of any culture with its own jargon though
15:30:48 <geekosaur> learn you a vocabulary for great good :p
15:30:49 <ReinH> I think people expect Haskell jargon to overlap with general programming jargon though, thus the surprise
15:30:51 <zipper> ReinH: Uh that MonadFail typeclass didn't change anything really.
15:30:57 <hpc> it's okay, webdevs use words i don't understand either
15:31:01 <hpc> like "ruby" and "agile" ;)
15:31:05 <ReinH> zipper: It moves fail out of Monad, which is the point
15:31:09 <Shockk> hpc: and type safe?
15:31:15 * Shockk jabs at javascript
15:31:16 <zipper> ReinH: No I mean words like conjectural lol
15:31:47 <ReinH> I like it when people say "conjectural" instead of "an idea". ;)
15:31:48 <zipper> ReinH: oh I get it now.
15:42:29 <Qndel>     Couldn't match expected type `Set.Set (GLfloat, GLfloat)'                 with actual type `IO (Set.Set (GLfloat, GLfloat))'
15:42:39 <Qndel> if Set.member (xx-2,yy) (readIORef collectDots) == True then
15:42:45 <Qndel> how can I make it work? :/
15:43:04 <ReinH> Qndel: make what work?
15:43:08 <ReinH> Use lpaste for code
15:43:10 <johnw> he's using readIORef as an argument
15:43:19 <mauke> readIORef collectDots >>= \set -> if Set.member (xx-2,yy) set then
15:43:22 <ReinH> ah
15:43:24 <johnw> you'll need to read from the IORef before you use it as an argument
15:43:27 <KaneTW> Qndel: you need to readIORef in IO first, then use it
15:43:48 <Qndel> I've just pasted one line
15:43:54 <Qndel> is it worth a lpaste?
15:44:01 <KaneTW> he probably meant context
15:44:12 <johnw> Qndel: no, I think the main issue has been answered now
15:44:26 <Qndel> how can I make my function IO?
15:44:58 <lpaste_> guibou pasted “Echo server - Golf” at http://lpaste.net/5212918415517286400
15:46:22 <exio4> I hope you aren't doing if X == True then True else False 
15:46:29 <geekosaur> Qndel is making the same mistakes as yesterday
15:46:37 <geekosaur> not learning
15:47:08 <Qndel> ?
15:47:18 <geekosaur> reportedly not interested in learning
15:47:24 <geekosaur> (per report in -ops)
15:47:36 <Qndel> http://lpaste.net/140996
15:47:41 <Shockk> -ops leaks :o
15:47:51 <geekosaur> I know for certain that you are making the same mistake because I tried to help you through another of those yesterday
15:47:59 <geekosaur> you cannot simply compare an IO value to a pure value
15:48:07 <Qndel> but what's the solution
15:48:24 <geekosaur> you can learn how IO works, or you can keep being confused when the compiler tells you that you are comparing an IO value to a value
15:48:56 <Jinxit> Qndel: what's your deadline, and when did you get the assignment?
15:49:51 <Qndel> I got the assignment a year ago
15:49:56 <Qndel> the deadline is today
15:50:08 <Shockk> ..
15:50:18 <Jinxit> enjoy
15:50:22 <Clint> moderately good troll
15:50:30 <Jinxit> you had plenty of time to properly learn haskell
15:50:38 <Qndel> no I didn't
15:50:51 <Qndel> I've been trying to do this game for months
15:51:03 <Qndel> but wasted countless hours on trivial things
15:51:04 <Jinxit> did you try something like learnyouahaskell?
15:51:07 <Jinxit> or a book?
15:51:22 <ReinH> trivial things like learning how the language works, I suppose.
15:51:26 <nshepperd> haha did you even go to the lectures
15:51:32 <Qndel> half of them
15:51:44 <Jinxit> you probably missed the lecture on IO, then
15:52:44 <Qndel> the lectures were so long ago that I don't remember a thing
15:52:54 <Qndel> I'm not interested in continuing my adventure with haskell
15:52:59 <Qndel> my only desire is to end it
15:53:11 <ReinH> You can always drop the course
15:53:13 <mauke> that's kind of the opposite of what this channel is for
15:53:18 <Qndel> I can't
15:53:37 <Qndel> if I drop it, I won't pass the year
15:53:53 <Jinxit> well you're not gonna finish a game and be able to properly explain it in a night
15:53:54 <ReinH> You can. You just choose not to. In any event, I'm done being trolled.
15:54:00 <dmj`> Qndel: paste your transcript here
15:54:09 <Qndel> http://lpaste.net/140998
15:54:09 <dmj`> lpaste.net
15:54:16 <Qndel> this is the only thing left that I have problem with
15:54:37 <Qndel> got an IORef set, must remove the coordinates from it if I meet them
15:55:08 <dmj`> Qndel: would your teacher allow you to submit a simpler project? 
15:55:29 <Qndel> I don't think so
15:55:44 <dmj`> Qndel: you've had a haskell class for a whole year?
15:55:45 <Qndel> there are 4 days left till I have to get everything done, so there's no time
15:55:52 <Qndel> no
15:55:56 <Qndel> half a year
15:56:09 <dmj`> Qndel: what school?
15:56:19 <Qndel> I was doing fine in the class but can't write such a big thing like a game
15:57:13 <dmj`> Qndel: have you programmed in OpenGL or haskell before this course?
15:57:33 <dmwit> ?google io monad for people who simply don't care
15:57:35 <lambdabot> http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
15:57:35 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
15:57:58 <Qndel> no i haven't
15:58:08 <dmj`> Qndel: what kind of game is this?
15:58:19 <Qndel> the world's most poor pacman
15:59:03 <dmj`> Qndel: would your teacher care if you didn't use OpenGL ?
15:59:33 <Qndel> what else could I use?
15:59:42 <Qndel> wasted days trying to install gtk and some other stuff
15:59:49 <EvanR> graphics drawing combinators
16:00:02 <Qndel> opengl was the only thing that I've managed to launch
16:01:19 <Qndel> I have no time to try something else
16:01:36 <dmj`> Qndel: pacman doesn't require 3d graphics, OpenGL is a hefty library. You could just do a console application. Trying to make it easier for you
16:01:45 <Qndel> there are 4 days left and I still have to go and talk about my code and find the professor to write my grade in the system
16:01:52 <EvanR> console pacman?
16:01:54 <Qndel> yeah but the guy wanted 3d
16:02:02 <Qndel> said it'd be cool
16:02:42 <dmj`> Qndel: passing would be cooler than 3d graphics though
16:03:06 <ReinH> If you aren't going to talk about haskell, please take it to #haskell-blah
16:05:50 <EvanR> dmwit: good link, but you know, for an article like this you dont even have to say "the IO monad"
16:05:56 <EvanR> i mean, after the title
16:06:26 <EvanR> or applicative or functor,... just "the IO type" might seem less scary
16:07:17 <ReinH> EvanR: +1
16:07:27 <ReinH> In fact I would prefer all
16:07:29 <ReinH> er
16:07:38 <ReinH> it would probably better if "IO monad" were never used
16:08:04 <deech> Hi all, hoping to get some help with ghc-mod. I'm running 7.10.1, ghc-mod from master and haskell-mode from 20150914. When I navigate to one of my project buffers I get: You must run ghc-mod in the project directory as returned by `ghc-mod root`. Currently in: "blah/src/..."but should be in "blah".
16:14:15 <Cale> If you're specifically talking about the manner in which IO is a monad, it's perhaps appropriate to say "the IO monad", but in most cases, if you're just talking about how to do I/O in Haskell, I agree it's better to drop the word "monad", because the fact IO happens to be a monad is not highly relevant to most things.
16:17:28 <EvanR> is IO a monoid?
16:18:12 <Qndel> how do I write new value to IORef ?
16:18:18 <EvanR> wrong kind I guess
16:18:18 <Qndel> is it by using $~!          ?
16:18:26 <ReinH> Qndel: Did you read the docs for IORefs?
16:18:33 <ReinH> Because it's easy to find
16:18:59 <Qndel> please
16:19:00 <basbegin> Hi all
16:19:04 <Qndel> I'm so close to finishing it
16:19:11 <Qndel> halp :<
16:19:22 <pacak> Qndel: Monads are nice and fluffy
16:19:28 <Qndel> collectDots $~! filter (\= (xx-2,yy)) collectDots2
16:19:32 <pacak> Qndel: Study them.
16:19:33 <Qndel> can't I use not equal in filter?
16:19:33 <ReinH> Qndel: here are the docs https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-IORef.html
16:19:46 <basbegin> Why is monoid so well liked by Haskell programmers? I am just one day old in haskell. So, trying to see what lies ahead.
16:19:54 <basbegin> *Monads rather
16:20:14 <nshepperd> oh, I was going to say monoids are also great
16:20:21 <Shockk> monoids are nice
16:20:27 <pacak> basbegin: Monoids are nice and fluffy.
16:20:33 <basbegin> lol
16:20:39 <dmj`> basbegin: there was a discovery by a guy named Moggi, who linked monads to computation. http://core.ac.uk/download/pdf/21173011.pdf
16:20:40 <basbegin> k :)
16:20:54 <EvanR> you had it right the first time, monoids are the bomb
16:20:58 <Shockk> :t when
16:20:59 <lambdabot> Applicative f => Bool -> f () -> f ()
16:21:25 <Shockk> I wrote some variant of `when` like
16:21:33 <catgocat> Hello, what is the best library to make Haskell Games?
16:21:39 <catgocat> 2D Games
16:21:43 <Shockk> (Applicative f, Monoid a) => Bool-> f a -> f a
16:21:49 <nshepperd> catgocat: gloss!
16:21:53 <catgocat> Thanks!
16:22:01 <sm> FunGEn!
16:22:02 <Shockk> () is a monoid so it works like `when` :D
16:22:45 <basbegin> thank dmj`. Are you trying to scare me? :D
16:23:11 <sm> catgocat: and/or sdl2!
16:23:17 <ReinH> dmj`: basbegin said "monoid", fwiw
16:23:29 <EvanR> Shockk: whats that... using Monoid for its default value?
16:23:36 <Shockk> yep
16:23:39 <Shockk> mempty, that is
16:23:43 <ReinH> EvanR: yep, the only thing that could possibly work
16:23:45 <EvanR> theres a class for that
16:23:48 <Shockk> there is?
16:23:53 <EvanR> Default
16:24:00 <EvanR> but I think people hate it
16:24:02 <nshepperd> ReinH: they did mean monad but we rolled with it
16:24:15 <ReinH> nshepperd: ah, well, they were still correct by accident ;)
16:24:19 <EvanR> like Pointed
16:24:25 <Shockk> why do they hate it?
16:24:32 <ReinH> I'm not sure if people hate it. That seems like a silly thing to hate.
16:24:37 <ReinH> Pointed doesn't have any laws.
16:24:45 <EvanR> neither does Default
16:24:47 <Shockk> :i Default
16:24:53 <Shockk> :(
16:24:54 <EvanR> :t default
16:24:55 <lambdabot> parse error on input ‘default’
16:24:59 <Shockk> :t Default
16:25:00 <lambdabot> Not in scope: data constructor ‘Default’
16:25:07 <dmj`> ReinH: yea, but he then said "Monad rather", basbegin: I could tell you that monad is monoid in the category of endofunctors. 
16:25:13 <EvanR> :t def
16:25:14 <lambdabot> Default a => a
16:25:15 <ReinH> dmj`: :)
16:25:41 <Shockk> is this defined in a package?
16:25:42 <ReinH> basbegin: Don't worry too much about "monads", just worry about when and how you can use do notation for starters.
16:25:51 <EvanR> Shockk: data-default package
16:26:09 <Shockk> ahh I see
16:26:14 <basbegin> ReinH: do asReinhSays
16:26:27 <ReinH> basbegin: :)
16:26:28 <basbegin> Let me get back to my tutorial. 
16:26:32 <EvanR> isn't there a bunch of things that are monoids in the category of endofunctors
16:26:55 <ReinH> EvanR: it depends on which product you use
16:27:09 <Shockk> let instructions = asReinhSays in do asReinhSays
16:27:19 <Shockk> er
16:27:26 <Shockk> I massacred that
16:27:30 <ReinH> Shockk: indeed you did <3
16:27:49 <Shockk> it's not even correct
16:27:55 <johnw> EvanR: see http://www.fceia.unr.edu.ar/~mauro/pubs/Notions_of_Computation_as_Monoids.pdf
16:28:07 <dmj`> basbegin: the paper is from 91', but it introduces a few monads to model computation that we use in haskell, like exception, list, and continuation. 
16:28:10 <johnw> by product, I think ReinH means tensor
16:28:27 <ReinH> johnw: sure
16:28:43 <ReinH> "tensor product"
16:28:52 <johnw> yah, that thing
16:29:10 <ReinH> monoidal squish operation
16:30:10 <basbegin> dmj`: Is this were Haskell started? 
16:30:20 <basbegin> Or rather the theoretical foundation?
16:30:32 <ReinH> basbegin: some of it
16:31:06 <ReinH> there's a lot more to haskell than monads
16:31:45 <EvanR> "monoids in a monoidal category"
16:31:52 <Clint> and quantum burritos
16:31:57 <dmj`> basbegin: if you're interested in the history, SPJ gives a great talk on it
16:32:05 <dmj`> basbegin: https://www.youtube.com/watch?v=3bjXGrycMhQ
16:32:11 <ReinH> All of SPJ's talks are great!
16:33:06 <Shockk> I watched his talk on lenses
16:33:21 <basbegin> Thanks dmj` . I saw one of his videos on typeclasses. Didn't get too far, so, I decided I want to learn Haskell so, I can understand some of it :)
16:33:25 <Shockk> he seems pretty charismatic/energetic and enjoyable to watch
16:33:37 <ReinH> Shockk: absolutely, and fun to interview too
16:33:47 <parsnip> hmm, new to xmonad, how to prevent it from taking M-p, and make M-d dmenu instead
16:34:15 <geekosaur> there is #xmonad
16:34:19 <parsnip> oh, i guess "removeMouseBindings"
16:34:23 <dmj`> basbegin: for beginning this is a good guide: https://github.com/bitemyapp/learnhaskell
16:34:27 <geekosaur> that's not a mouse binding
16:34:30 <parsnip> geekosaur: oops, i just did /list and didn't see it
16:34:40 <parsnip> geekosaur: oh gosh
16:34:44 <EvanR> this paper calls the operation a tensor
16:34:47 <geekosaur> http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Util-EZConfig.html#v:removeKeysP
16:34:52 <EvanR> rather than a tensor product, confusing
16:34:55 <basbegin> dmj`:  yes, I am using the upenn lectures suggested in that page. 
16:35:38 <parsnip> geekosaur: thanks
16:35:42 <dmj`> basbegin: great ! 
16:38:00 <Qndel> how would i restart my game?
16:38:16 <EvanR> delete the source code
16:38:29 <Qndel> do I have to manually reset all IORefs etc? or can I run it again somehow?
16:38:50 <EvanR> whatever constructed the IORefs in the first place can be reused and you can forget about the existing IORefs
16:39:20 <Qndel> main constructed the IORefs
16:39:50 <EvanR> well
16:39:55 <catgocat> any good gloss documentation / tutorial ?
16:39:57 <EvanR> execute main again ;)
16:40:10 <dmj`> Qndel: for your game you could generate a board, player locations randomly with QuickCheck arbitrary instances
16:40:30 <dmj`> Qndel: I think they should get garbage collected if they go out of scope
16:40:31 <Qndel> a board?
16:40:39 <Qndel> I don't think so
16:40:41 <dmj`> Qndel: well, whatever your pacman lives in
16:40:52 <Qndel> it'd generate a labirynth for me?
16:41:45 <dmj`> Qndel: Sure why not. I built a game of battleship which generated random locations for boats 
16:41:57 <Qndel> I have few files
16:42:03 <nshepperd> catgocat: oh yeah the haddock generation is broken recently :/
16:42:06 <dmj`> Qndel: why don't you join #haskell-blah with me
16:42:24 <nshepperd> catgocat: https://hackage.haskell.org/package/gloss-1.9.2.1 has working docs
16:43:14 <Qndel> anyway, I have few files
16:43:21 <Qndel> they are modules and I import them in main
16:43:26 <Qndel> how would I execute main from one of them?
16:43:30 <dmj`> Qndel: let's talk in #haskell-blah
16:43:44 <EvanR> move your code out of main, is probably a better idea
16:43:52 <catgocat> nshepperd is there any good tutorials on making games with gloss?
16:44:41 <EvanR> as you refactor you will begin to thank the lambda lords for the static type system
16:45:20 <Qndel> I have 9 hours left, I don't think its a good time to start moving my code
16:47:43 <Jinxit> your deadline keeps moving around dude
16:47:45 <nshepperd> catgocat: unfortunately I don't know anything google doesn't know there
16:47:55 <nshepperd> oh
16:52:59 <ReinH> I mean, how hard is it? Rename main to main' and make main = main'
16:53:16 <ReinH> Then proceed from there
16:57:02 <Qndel> proceed how?
16:57:16 <Qndel> main' still not in scope
16:57:59 <dmj`> Qndel: here's an example of what ReinH means, http://lpaste.net/141004
16:58:45 <dmj`> Qndel: you'll need two loops, one for the gameLoop, another for testing whether they wanna play again
16:59:13 * hackagebot inline-r 0.7.1.0 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.7.1.0 (MathieuBoespflug)
17:01:28 <Qndel> https://wiki.haskell.org/OpenGLTutorial2
17:01:37 <Qndel> so would it be easy to remake this code to use these 2 loops?
17:04:46 <hackrilege> Qndel how is it going?
17:05:50 <hackrilege> I did that tutorial a few years ago, opengl works well
17:08:34 <Qndel> its going good
17:08:42 <Qndel> managed to add score and eating dots
17:08:54 <tommd> Yum!
17:08:55 <Qndel> now i have to add restarting the game but have no idea how
17:09:27 <Qndel> tried to make main a module and import it in the file that was also being imported by the main - haskell didn't like it
17:10:16 <hackrilege> It wouldn't
17:10:16 <hackrilege> Why did you want to do that?
17:10:46 <hackrilege> And yes did you try calling it main' as suggested?
17:13:31 <hackrilege> The paste supplied should work, I guess your doing that now, let us know how it goes. I'd be up for giving you a hand for a short while to help push forward to completion, I know how nasty the feeling of rushing for a deadline
17:13:45 <Qndel> because I have a pacman
17:13:51 <Qndel> and no penalty when enemies catch you
17:13:52 <Qndel> xD
17:14:04 <YellowOnion> Umm, is the issue because GLUT uses callbacks, and not an event loop?
17:14:33 <Qndel> probably yes
17:16:36 <YellowOnion> So your state is being passed around with the keyboardMouseCallback?
17:17:35 <Qndel> what state?
17:17:45 <Qndel> I'm passing most of my IORefs to keyboardMouseCallback
17:19:53 <Qndel> okay I go sleep
17:19:55 <hackrilege> (Qndel) http://lpaste.net/140998
17:19:55 <hackrilege> That's what we ate linking at right?
17:19:56 <hackrilege> Are looking at sorry
17:20:18 <Qndel> can I post all my files somehow?
17:20:19 <hackrilege> Ciao
17:20:36 <YellowOnion> Qndel, github?
17:20:36 <Qndel> anyway I have 3 files that are most important
17:20:42 <hackrilege> You could do a cabal build or put it on github
17:20:58 <YellowOnion> gist.github.com can do collections of files.
17:20:58 <Qndel> no no no
17:21:03 <Qndel> http://lpaste.net/141006
17:21:04 <Qndel> Main
17:21:18 <Qndel> http://lpaste.net/141007
17:21:19 <Qndel> Display
17:21:33 <Qndel> http://lpaste.net/141008
17:21:34 <Qndel> Bindings
17:21:52 <Qndel> please tell me how to restart my game from the bindings file
17:22:21 <hackrilege> No you can't do it like that
17:22:44 <Qndel> am I doomed then?
17:23:08 <hackrilege> That would require bindings importing main
17:23:09 <hackrilege> Why dip you need to restart it from there?
17:23:39 <Qndel> from where then?
17:23:41 <hackrilege> Do
17:24:14 <Qndel> so from Display then
17:24:14 <hackrilege> It sounds like one of the most outer things to do, so do it as close to main as possible
17:24:18 <Qndel> I have the code moving enemies there
17:24:34 <hackrilege> Certainly above all of the stuff you want to restart
17:24:56 <Qndel> I can't do it close to the main
17:25:02 <Qndel> main doesn't know anything about enemy moves
17:25:02 <hackrilege> By restart game you mean basically crash it and restart main right?
17:25:07 <Qndel> would do
17:25:09 <Qndel> anything
17:25:12 <YellowOnion> Qndel, I can see how you've written this program, and how its really bad for restructing :P
17:25:24 <Qndel> I know its bad
17:25:33 <Qndel> I just hope I'll get lowest passing grade and forget about it
17:25:52 <Qndel> sadly its the best I can do
17:27:04 <YellowOnion> Qndel, don't take that as an insult, all part of the learning process :)
17:27:06 <hackrilege> But if all that was just to reset the value of you ioref why not have a function which initializes everything and returns them as a game state datatype, you could then reinitialise everything by calling this again and passing the new values to the thing that uses them...
17:27:56 <Qndel> is it complicated?
17:28:05 <Qndel> because I have like 5 min before my brain explodes lol
17:28:32 <hackrilege> The thing I suggested would certainly clean up that messy main by removing all those ioref initializations
17:29:12 <Qndel> but is it complicated?
17:29:18 <Qndel> if so, I give up and go sleep xD
17:29:43 <Qndel> my head hurts so much
17:30:06 <YellowOnion> Qndel, restarting is an easy thing to conceptialise, maybe you do need some sleep :P
17:30:07 <hackrilege> No no, its not going to make your brain explode, the only reason your code is eyeball wrenching and mind boggling is because you have not compartmentalized it neatly add you went along. Doing so now is probably the best way to stop your brain having to deal with all the craziness you have amalgamated so far
17:30:27 <ReinH> Honestly it would be easier to just put everything in a single file.
17:30:38 <ReinH> No organization is probably better than poor organization.
17:30:44 <Qndel> ok
17:30:48 <Qndel> will do it in the morning
17:30:54 <Qndel> thanks for the idea!
17:30:59 <Qndel> then I'll just simply call main again
17:31:02 <YellowOnion> Qndel, how much longer do you have to complete?
17:31:11 <augur> is fix definable in system F?
17:31:23 <Qndel> its 2:30
17:31:29 <Qndel> I'm supposed to go and show the code at 12
17:31:54 <hackrilege> Lol
17:32:08 <KaneTW> augur: yes
17:32:49 <Qndel> okay goodnight everybody
17:33:03 <Qndel> I must get some sleep or I won't be able to speak properly at 12
17:33:07 <monochrom> augur: fix is not definable in System F.
17:33:29 <YellowOnion> Qndel, just set a bind for like "R" that sets all the IORefs to the starting values.
17:33:47 <Qndel> ok
17:33:50 <hackrilege> Certainly there is no chance of faeries doing it for you if you don't leave a working version in a paste
17:34:00 <augur> monochrom: ok. i didnt think it should be, but my System F knowledge isnt very broad :p
17:34:02 <programo> Can we implement a zipWith function with a map function?
17:34:25 <YellowOnion> Qndel, probably the easiest way to do it for now.
17:35:02 <montanonic> So, if I genuinely find it easier to think about function application as being (x y) f, and find that doing so reflects the logical way I approach solving problems, which goes from the starting case at the beginning, transforms that case, and ends with the result, how much support can Haskell give me in redefining the syntax so that things can behave that way?
17:35:43 <hackrilege> Programo once you have zipped then together you map over that with the function...
17:36:08 <montanonic> I've already defined constructs like >>> for function application/composition that allow me to chain in that order, but it is finicky, and I know I need a more elaborate mechanism to generalize the act of chaining the function application such that it is left-associated
17:36:40 <programo> Nope my question is can I implement the zipWith function itself
17:36:40 <hackrilege> But I don't think you can write zip in terms of map as there are two lists
17:36:58 <programo> with the help of map function
17:37:06 <hackrilege> You can, but not with map alone
17:37:10 <kadoban> Do you need something more elaborate? Wouldn't it just be an operator that's flip ($) ? It'd be a little ugly though.
17:37:11 <nshepperd> montanonic: (>>>) actually already exists, from Control.Category
17:37:18 <YellowOnion> I would be curious to see how different Qndel's code would be if de didn't use the GLUT, and instead used GLFW, which has you write your own mainLoop.
17:37:30 <nshepperd> montanonic: also there's (&) = flip ($)
17:37:32 <montanonic> nshepperd: indeed, I was turned on to it by Purescripts (simpler) use of the same syntax
17:37:34 <hackrilege> Zip is certainly not map
17:37:56 <montanonic> nshepperd: so I have that much, but I need more
17:38:02 <montanonic> nshepperd: for example
17:38:10 <programo> what else can I use to implement a zipWith apart from the map fucntio
17:38:25 <kadoban> The only real problem with it will be that function application doesn't look as nice:  f x y  <-> y & x & f
17:38:27 <hackrilege> Its a completely different recursion.
17:38:34 <hackrilege> Use zip and map and curry
17:38:35 <awpr> programo: zip and map together will do it
17:38:43 <montanonic> for (x && y) >>> return to work, it needs to be definined as: `a >>> f = f a` :: :: a -> (a -> b) -> b
17:38:51 <montanonic> (that's monadic return)
17:39:26 <hackrilege> Zip and map ate the two distinct recursion schemes at work.
17:39:28 <nshepperd> oh yeah, currying is fairly horrible, y & (x & f)
17:39:31 <hackrilege> Are
17:39:41 <kadoban> montanonic: ? I don't understand. Are you talking about the type annotation being "backwards" from what you want?
17:40:14 <montanonic> kadoban: Uh, I'm not sure if that's what I mean, all I can say is, suppose I define a datatype that is a Stream, which is just a list that cannot terminate
17:40:37 <montanonic> kadoban: I want to use scanl from Data.List on a stream though, so I define two functions, streamToList, and listToStream
17:41:03 <montanonic> kadoban: when I define streamScanl, it makes sense to think this way: streamToList >>> scanl >>> listToStream
17:41:09 <hackrilege> zipWith g la lb = map (curry g) (zip la lb)
17:41:17 <montanonic> kadoban: but Haskell wants me to do it the other way around
17:41:24 <hackrilege> :t curry
17:41:26 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:41:33 <kadoban> montanonic: Yes, but … you already figured out how to solve that, no? So … what's the question?
17:41:40 <hackrilege> Oops it should be uncurry
17:42:13 <nshepperd> montanonic: the usual (>>>) works for that
17:42:21 <programo> I want to create my own zipWith function with higher order functions.Are higher order functions like map and foldr  enough to do the job?
17:42:42 <montanonic> kadoban: that everytime I solve a problem, I think in similar ways: start with the first thing I need to do, and work until the end; haskell (and all other languages, basically) force us to write our code backwards, kind of like Lisp
17:42:48 <hackrilege> No as I said, you need zip
17:42:49 <nshepperd> streamScanl f z = streamToList >>> scanl f z >>> listToStream
17:43:04 <kadoban> montanonic: Okay … but you figured out how to define it using >>>, so … all set, right?
17:43:06 <hackrilege> Zip is a higher order function I think
17:43:44 <montanonic> kadoban: hmmm, yes except as I pointed out with the other definition for >>> I created above, I can't always have *function application* follow those rules, at least I don't think so
17:43:45 <hackrilege> @src zip
17:43:45 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
17:43:45 <lambdabot> zip _      _      = []
17:43:50 <programo> Yes I want to create this zipWith higher order function with other higher order functions
17:44:15 <programo> without using pattern matching
17:44:23 <hackrilege> Iv given you the answer twice already
17:44:30 <kadoban> montanonic: You should use a different operator.   >>> is a (more polymorphic) version of flip (.).  Use & for flip ($) ?
17:44:54 <montanonic> kadoban: one example being that this code: http://lpaste.net/141009, needs a specific operator (???) to allow for that syntax at the bottom
17:45:10 <montanonic> at least, I *think* so
17:45:18 <hackrilege> What was wrong with the version using uncurry?
17:45:35 <hackrilege> :t uncurry
17:45:36 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:45:39 <awpr> montanonic: '&' should be that operator
17:46:06 <kadoban> montanonic: That function is actually just:   `liftA2 (&&)`, by the way.
17:46:11 <hpc> man, aeson is handy
17:46:13 <programo> okay hackrilege , thanks! 
17:46:39 <kadoban> montanonic: But yes (&) is ???
17:46:41 <hackrilege> Zip the lists, uncut the function and map it over the new list
17:46:42 <hackrilege> Uncurry
17:47:13 <montanonic> kadoban: I understand that it is, I'm just using it as an example; the desire to have left-associative operations extends through all the code I write in Haskell
17:47:25 <YellowOnion> Has anyone here any tips for working with foreign functions, and getting haskell to sanely handle the strange array of datatypes one function might take?
17:47:57 <kadoban> >>> and & … boom. You're all set (as long as their precedence is actually helpfully correct … I dunno. If not you could make your own versions that have the right fixity and precedence.
17:47:58 <hackrilege> Lube?
17:48:06 <kadoban> )
17:48:26 <montanonic> kadoban: http://lpaste.net/141010
17:48:56 <montanonic> fixity set at 9 also doesn't fix it
17:49:26 <nshepperd> montanonic: (&) = flip ($)
17:49:42 <montanonic> nshepperd: oh, good lord.. hah thank you
17:50:40 <nshepperd> you would have noticed if you gave (&) a type signature :)
17:50:43 <montanonic> wow, & is exactly the function I defined earlier
17:50:47 <montanonic> yeah...
17:50:48 <kadoban> Yeah I think you want a (&) that has really high precedence.
17:50:54 <montanonic> wow, sorry for being a bit dense! :)
17:51:17 <kadoban> Oh I didn't even notice you were defining it above. Okay that makes way more sense.
17:51:18 <montanonic> I spread & and >>> between two modules and didn't realize I'd used (.) for both
17:51:53 <montanonic> Thank you all for helping me! I'm going to go enjoy some left-associated Haskell now.
17:51:54 <hackrilege> Looks like you should use applications though?
17:52:02 <nshepperd> the & from Control.Lens is infixl 1, I think I'd stay consistent with that
17:52:04 <hackrilege> Applicative...
17:52:39 <kadoban> nshepperd: I don't think that's going to match how he wants to use it though. He essentially wants to replace function application syntax, which is high precedence.
17:53:05 <kadoban> Personally I think I'd make up new operators, so I could give them my own precedence and avoid confusion.
17:53:07 <hackrilege> :t liftA2
17:53:08 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:53:36 <montanonic> kadoban: oh, being able to *apply* functions in that order is good enough to me; I don't *need* function application syntax as much as I just want to be able to apply them from left to right
17:53:51 <montanonic> kadoban: unless I misunderstand what I myself am actually asking, which is very plausible
17:53:53 * nshepperd is shocked there exist people who really prefer reverse polish notation
17:54:21 <montanonic> But in essence: my bad for forgetting what the type of ($) is.
17:54:23 <kadoban> montanonic: … yes but I'm saying there's a reason function application is high precedence. If you have a & that is /low/ precedence (which the actually defined one is), it's going to require a fairly tedious amount of parens.
17:54:49 <montanonic> kadoban: oh! I understand
17:54:51 <hackrilege> maby
17:55:04 <montanonic> kadoban: composition has high precedence, $ is low
17:55:23 <montanonic> Right now it works with & set to precedence of 8
17:55:29 <montanonic> But that may lead to issues later on perhaps?
17:55:38 <hpc> nshepperd: preposition oriented programming
17:55:49 <kadoban> montanonic: f x y  <-- that's what you're essentially trying to replace.   $ is just … how you're forced to do it, but I'd highly suspect you want it to behave as much like  f x y as possible.
17:55:52 <nshepperd> application has high precedence
17:55:59 <hpc> do this if that when something happens for each thing in the things
17:56:14 <montanonic> sorry, my domain experience on this is pretty low, you'll have to forgive my density
17:56:18 <Alpha64> nshepperd forth programmers
17:56:19 <kadoban> $ has low precedence because it's kinda used to replace   f (x y) with f $ x y
17:57:08 <montanonic> right, and I want to replace f a (g b) with (g b) & f a
17:57:10 <hackrilege> Hoc I like what you are getting at
17:57:11 <hackrilege> Hpc "
17:57:36 <montanonic> is that example clearer? I think that's what I mean.
17:58:05 <kadoban> montanonic: So as an example … let's see.     blah = length . filter even    <->    blah = even & filter >>> length
17:58:06 <montanonic> (a and b should be swapped) : f b (g a) 
17:58:24 <hackrilege> It looks like you have achieved that with your low precedence operator, yes
17:58:32 <awpr> montanonic: are you sure you don't just want "let c = g a  in f b c" ?
17:58:33 <kadoban> montanonic: If you use low precedence &, that is not going to work, my example. You'd have to put parens around it, which sucks a bit.
17:58:56 <montanonic> kadoban: ideally, filter even >>> length, I'm okay with the f (x y) as long as I can apply it left-to-right
17:59:20 <kadoban> Oh … then I have no godly idea what we're even talking about.
17:59:27 <montanonic> I was about to say the same...
17:59:30 <montanonic> I'm confusing myself
17:59:30 <kadoban> I though the whole point was   even & filter
17:59:47 <nshepperd> ah, if you're just using this to construct 'pipelines' using low precedence (&) makes sense
18:00:03 <montanonic> Okay, here's what I'm going to do: I'm going to just use & and >>> for a while and see what issues come up
18:00:12 <kadoban> Hehe, okay.
18:00:14 <hackrilege> awpr I gather this is an exercise in (&)
18:00:21 <montanonic> then, if there are issues, I'll come back with a CLEAR question so that I don't waste people's time :)
18:00:30 <johnw> montanonic: as long you're the only one maintaining the code, anything goes :)
18:00:30 <montanonic> But, in any case, still a very big thank you for trying to help
18:00:44 <kadoban> Sure, hope it goes well.
18:01:14 <kadoban> montanonic: By the way … I'd feel bad if I don't at least suggest: you might be better off just getting used to the idiomatic way instead of doing this stuff.
18:02:06 <hackrilege> kadoban, the idiom is shifting
18:02:49 <kadoban> hackrilege: I have never seen a single piece of code using flipped (.), except my own when I played with it for a while. If it's shifting, it's not very quickly.
18:03:28 <hackrilege> Iv seen a bunch of (&)
18:03:38 <montanonic> kadoban: that's totally fair, but does it at least make sense why I'm trying to have associativity grouped leftwards? That when you use function composition, the last function is actually the FIRST one being applied
18:04:06 <Lynn> Hey hey! Can I use the Yoneda lemma to show a certain type has only one inhabitant (if you squint and ignore the bottoms)?
18:04:25 <montanonic> func1 . func2 . func3 x makes more sense to me as func3 x & func2 & func1 
18:04:26 <hackrilege> Mostly from edk's lens stuff which composes all backwards and stuff
18:04:29 <kadoban> montanonic: Yes, I've thought that way before as well, but … I solved it by just getting used to it and with getting used to the editor trick necessary to write it cleanly without thinking about it in the "wrong" order.
18:04:33 <Lynn> Something like: (b -> c) -> (a -> b) -> (a -> c).
18:05:14 <nshepperd> well, 'first' can be considered either way here really
18:05:16 <hackrilege> Oh no! It makes much much less sense like that to me
18:05:33 <johnw> :t (.)
18:05:35 <lambdabot> (b -> c) -> (a -> b) -> a -> c
18:05:36 <montanonic> kadoban: doesn't Bind actually end up working that way (if not technically, in metaphor)
18:05:40 <montanonic> ?
18:05:44 <nshepperd> I mean operationally things actually get evaluated from the outside in
18:05:53 <kadoban> montanonic: Bind? (>>=) you mean?
18:05:57 <montanonic> kadoban: yes
18:06:04 <montanonic> At least from what I've seen
18:06:10 <Lynn> johnw: Yeah, that'd be the one
18:06:31 <montanonic> do notation is like "do this first, then this, then that"
18:06:36 <Lynn> And I want to show that there aren't any others, essentially.
18:06:47 <montanonic> not "and then we finish with this, after we do this, and we do this first"
18:06:48 <hackrilege> It makes more sense that the functions ate composes before the argument is applied, but I guess that's just pointless if you know what I mean, but that's the whole Haskell feel your throwing away there
18:07:01 <hackrilege> Are composed
18:07:05 <kadoban> montanonic: I dunno, I use a semi-random mix of (>>=), (=<<) and (>=>), depending. Though (>=>) is kinda the order we're talking about.
18:07:19 <nshepperd> in something like 'return (x,y) :: Maybe (Int,Int)' you evaluate the return *first* to find out whether the result is Just or Nothing
18:07:25 <montanonic> kadoban: oh right, I forgot the other orders exists too, oops
18:07:25 <ReinH> montanonic: (>>=) is the "wrong" way because do bind arrows are also the wrong way, so they cancel out.
18:07:37 <ReinH> montanonic: As in, (>>=) is flipped because <- is also flipped.
18:07:56 <ReinH> (=<<) is the analogue of ($)
18:08:04 <ReinH> e.g. putStrLn =<< getLine
18:08:06 <montanonic> ReinH: oh, okay, right I can see that (to a certain degree)
18:08:20 <ReinH> but do { line <- getLine; putStrLn line }
18:08:41 <ReinH> or getLine >>= \line -> putStrLn line
18:08:46 <montanonic> ahh, okay
18:09:01 <montanonic> so you don't actually need lambdas when you do it with <<=?
18:09:07 <montanonic> err, =<<
18:09:09 <ReinH> getLine >>= putStrLn also works
18:09:16 <ReinH> I was just trying to match the do notation exactly
18:09:20 <montanonic> Oh, I see.
18:09:38 <ReinH> so ($) is to (=<<) as (&) is to (>>=)
18:10:02 <hackrilege> Other way round?
18:10:12 <ReinH> hackrilege: no.
18:10:15 <ReinH> :t ($)
18:10:16 <lambdabot> (a -> b) -> a -> b
18:10:16 <hackrilege> No, ok sorry
18:10:19 <ReinH> :t (=<<)
18:10:20 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:10:20 <kadoban> And (>>>) is to (>=>) I guess
18:10:30 <ReinH> kadoban: right
18:10:59 <montanonic> I'm going to have to just play around with these things. :)
18:10:59 <Gurkenglas> I often do things like x = a $ b $ c. x .= a $ b $ c fails because of the precedence. What am I to do? (x .=) $ a $ b $ c? x .= (a $ b $ c)?
18:11:01 <hackrilege> I don't know those last two
18:11:32 <hackrilege> :t (>>>)
18:11:33 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
18:11:48 <kadoban> (>>>) is a more polymorphic version of: flip (.)
18:11:53 <ReinH> x .= a (b c) seems reasonable
18:11:54 <hackrilege> Omg
18:12:26 <Lynn> > Identity "hello" >>= Identity . length >>= Identity . (^2)   -- >>= is like &
18:12:28 <lambdabot>  Identity 25
18:12:29 <ReinH> (>>>) is flip (.) for any Category
18:12:29 <montanonic> ReinH: would that work as x .= a $ b c ?
18:12:49 <Lynn> > Identity "hello" >>= (Identity . length >=> Identity . (^2))   -- >=> is like `flip (.)`
18:12:49 <hackrilege> Box cat is that a Candace reference!?
18:12:49 <hackrilege> Candace...
18:12:50 <lambdabot>  Identity 25
18:12:53 <ReinH> montanonic: no, x .= a $ b c is (x .= a) (b c)
18:12:54 <hackrilege> Ffs nvm
18:13:09 <hackrilege> Catface
18:13:23 <montanonic> ReinH: ah, okay, stuff like that still bites me in the ass when I try to get clean with $$$
18:13:25 <ReinH> montanonic: $ is sugar for wrapping parens around the expressions on each side
18:13:38 <ReinH> (and is right-associative in the presence of multiple $)
18:13:45 <montanonic> Right.
18:13:55 <ReinH> so a b $ c d = (a b) (c d)
18:14:14 <hackrilege> Its just a precedence breaker right?
18:14:35 <ReinH> and a $ b $ c $ d = a (b (c (d)))
18:14:59 <ReinH> hackrilege: It's used when you want a low precedence for function application, yeah
18:15:25 <programo> thanks 
18:15:28 <programo> hackrilege, 
18:15:36 <programo> I have implemented it
18:15:37 <hackrilege> No I mean it does nothing but destroy the high presence of function composition...
18:16:00 <Shockk> f $ x = f x, but its precedence is the lowest possible so it binds more loosely than all other operators
18:16:02 <ReinH> Lynn: >=> is like flip (.) for composition of "Kleisli arrows" (arrows of type a -> m b for some monad m)
18:16:03 <hackrilege> Let us see!
18:16:23 <ReinH> (arrows, not Arrows)
18:16:46 <Shockk> I wrote a helper infix function for myself like $ but with the highest infix precedence
18:16:48 <ReinH> "functions of type a -> m b", rather
18:17:04 <ReinH> Shockk: That's what adjunction already is though
18:17:14 <ReinH> f a already has highest precedence
18:17:14 <hackrilege> How did you use that? Shockk
18:17:36 <Shockk> I mean, it lets me do like
18:17:56 <Shockk> f x >>= g y `apply` z
18:18:01 <Shockk> bad example
18:18:05 <Shockk> f x >>= g y `apply` h z
18:18:25 <programo> Here is the code http://lpaste.net/141012
18:18:27 <ReinH> so f x >>= (g y) (h z)
18:18:28 <hackrilege> Where is your dollar like thing?
18:18:34 <Shockk> ReinH: yes
18:18:40 <ReinH> Shockk: gotcha
18:18:47 <Lynn> That looks vastly less readable than parentheses to me...
18:18:53 <ReinH> btw parens won't make you go blind
18:19:12 <ReinH> I actually prefer parens to most uses of $
18:19:13 <Shockk> well, I used it where I have more nested parentheses
18:19:30 <ReinH> Shockk: extracting things into where blocks is good btw
18:19:50 <hackrilege> Programo why didn't you use uncurry and what I'd that horrible aux doing?
18:19:54 <Shockk> true
18:20:14 <ReinH> @unpl \(a,b) -> f a b
18:20:15 <lambdabot> \ (a, b) -> f a b
18:20:23 <ReinH> @pl \(a,b) -> f a b
18:20:23 <lambdabot> uncurry f
18:20:29 <ReinH> is what hlint is recommending
18:20:41 <Shockk> I mean the main thing I used it for was the pattern: f >>= g `apply` \x -> ...
18:20:49 <ReinH> Shockk: that's what do notation is for
18:21:03 <ReinH> that is exactly why it exists
18:21:34 <Shockk> hmm
18:21:35 <hackrilege> Wow
18:21:36 <hackrilege> So how do we implement do?
18:21:42 <Shockk> what do you mean ReinH?
18:22:01 <Axman6> hackrilege: do notation is syntax, not something you can implement
18:22:02 <Shockk> rather, how would that be done with do notation instead?*
18:22:12 <hackrilege> He means the newline is your operator in a do block
18:22:23 <kristof> Don't all comonads admit an F-algebra?
18:22:40 <ReinH> Shockk: so f >>= g (\x -> ...) ?
18:23:18 <Shockk> yes
18:23:20 <hackrilege> Is that right?
18:23:24 <hackrilege> Woop
18:23:39 <ReinH> do { y <- f; flip g y (\x -> ...) }
18:23:44 <kristof> What I mean to say is: you look at the signature W b -> a, and you think to yourself "what if that was W a -> a", and huzzah, that is an algebraic function.
18:24:25 <Shockk> hm, I guess
18:24:26 <hackrilege> I'm really happy I finally understand what do is doing
18:24:28 <ReinH> kristof: Yes, extract
18:24:32 <Shockk> I don't like using flip a lot but that would work 
18:24:55 <ReinH> Shockk: I would probably give (\x -> ...) a name
18:25:24 <ReinH> then it's let h = (\x -> ...) in g h =<< f (with better names in the real world ofc)
18:25:33 <kristof> ReinH: Well, in a similar way, all monads have a co-algebra defined over them. So, is that... uh... useful?
18:25:35 <Shockk> my reasoning for not doing that is terrible by the way
18:25:39 <ReinH> kristof: It can be.
18:25:50 <Shockk> it's literally "I can't think of meaningful names"
18:25:51 <Shockk> :(
18:25:55 <kristof> ReinH: Anything you can think of off the top of your head?
18:25:57 <ReinH> kristof: Sometimes the fixed point of that coalgebra is interesting
18:26:04 <ReinH> Lots of fractals work that way
18:26:08 <kristof> Ah, sure
18:26:17 <ReinH> L-systems, for example
18:26:31 <kristof> Yeah, weren't you the one talking about L-systems with me a while ago?
18:26:34 <ReinH> kristof: yep :)
18:26:39 <kristof> oh wow haha
18:26:45 <kristof> full circle.
18:26:49 <hackrilege> h was hardly meaningful
18:26:52 <ReinH> An L-system is the fixed point of applying >>= to a rule, starting wieth an axiom.
18:27:40 <hackrilege> Wow, that sounds crazy and makes no sense
18:28:03 <ReinH> kristof: btw for Functor f, Monad m, you get "f-effects" for determinism via its cofree comonad
18:28:26 <kristof> ReinH: Yeah, I remember being a little floored by that. Now the next step is to find something useful to do with this information, where useful means "solving a difficult problem in a simpler or novel way"
18:28:28 <hackrilege> When did we get rules and axioms in Haskell?
18:28:30 <ReinH> so for f ~ [], you get the usual notion of a non-deterministic L-system
18:28:32 <ReinH> via coiter
18:28:56 <kristof> hackrilege: We're just talking about L systems, where a rule is a transformation from an element of a string to a new string
18:29:22 <hackrilege> Char to string?
18:29:33 <kristof> sure
18:29:37 <hackrilege> Very lost..
18:29:46 <Alpha64> isn't that a fancy name for markov chains?
18:30:00 <ReinH> kristof: Other choices of f are interesting. Pair a gives each rule exactly two choices. (Pair a is representable by 2)
18:30:24 <ReinH> (data Pair a = Pair a a)
18:30:35 <ReinH> (Pair a is isomorphic to Bool -> a)
18:30:51 <kristof> Alpha64: No, markov chains take a single value and apply probabilistic models to produce other single values
18:30:55 <hackrilege> We can model a mark of chain as monads composed with >>= ?
18:31:09 <ReinH> Alpha64: No. L-systems are parallel rewrite rule systems.
18:31:24 <ReinH> There's no notion of a "chain".
18:31:37 <kristof> Alpha64: an L-system would take something like "AB", and the rules A->B and B->BA and turn it into BBA, BABAB, BABBABBA, etc.
18:32:00 <Alpha64> oh right
18:32:01 <geekosaur> ReinH, I think that was a misparse of Markov chain?
18:33:09 <hackrilege> You said fixed point and >>= which looks like a chain to me. I thought if we wanted parallel evaluation we should use applicative rather than monad...
18:33:46 <ReinH> geekosaur: what was?
18:34:06 <ReinH> geekosaur: Oh, I was responding to Alpha64
18:34:17 <geekosaur> never mind, I thought you were responding to [15 01:30] <hackrilege> We can model a mark of chain as monads composed with >>= ?
18:34:39 <hackrilege> I was also responding to the same comment
18:34:40 <ReinH> hackrilege: The "chain" in Markov chain isn't a chain of composed arrows.
18:34:55 <kristof> hackrilege: There is some confusion going on here. :) Parallel when referring to applicative usually just means "the computations cannot rely on any previous computation"
18:34:58 <hackrilege> Really?
18:35:34 <hackrilege> Yeh
18:35:35 <hackrilege> That's what parallel is right?
18:36:04 <kristof> Anyway
18:36:04 <ReinH> Parallel in this sense means that all terms are rewritten on each rewrite step, rather than just the first matching term.
18:36:43 <kristof> Someone in here once told me that if you had a structure that had both a sensible monad instance and a comonadic instance then you can squeeze a hopf algebra out of it.
18:36:45 <hackrilege> Not in I systems?
18:36:45 <hackrilege> L
18:36:45 <hackrilege> Aha
18:36:45 <hackrilege> Ok
18:37:13 <ReinH> kristof: I'd buy it
18:37:27 <kristof> ReinH: The question is if it was worth your money.
18:37:34 <ReinH> Probably not?
18:37:42 <kristof> That is what I am thinking :)
18:37:44 <hackrilege> I'll take five
18:38:28 <kristof> I can't imagine wanting to use the same structure in so many ways. It sounds unprincipled.
18:39:03 <geekosaur> afraid to ask what you think of monoids, then :p
18:39:10 <ReinH> or, you know, functions.
18:40:27 <kristof> What I meant was "in the same area".
18:41:31 <kristof> "Why, absolutely, I need extend, bind, <>, and cata and ana morphisms."
18:42:03 <Lynn> Re: the Hopf algebra thing: how would you get antipodes?
18:42:10 <johnw> katana morphisms
18:43:14 <geekosaur> kata morphisms?
18:43:20 <Lynn> (Also, about my earlier question: I realized I simply need to show that the type of (.) is isomorphic to ()! Then there can surely be only one inhabitant, which is (.))
18:43:29 <geekosaur> (I suppose they're all that in some sense...)
18:43:54 <Lynn> (Now I just need to figure out how to do that... I probably need multiple steps, one of which will be Yoneda-ish?)
18:44:43 * zbcm slaps stapler around a bit with a large fishbot
18:45:03 <Lynn> (I mean, I found a proof by Gabriel Gonzalez that does this for `id`: http://stackoverflow.com/a/12230918/257418)
18:45:43 <arkeet> @free (.)
18:45:43 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
18:45:52 <arkeet> @free dot :: (b -> c) -> (a -> b) -> a -> c
18:45:52 <lambdabot> g . k = p . f => f . q = f1 . h => g . dot k q = dot p f1 . h
18:46:24 <arkeet> I'm not sure how to interpret that considering there rae two => 
18:46:25 <arkeet> are
18:47:15 <arkeet> I guess it wants both conditions.
18:47:40 <kristof> Lynn: Beats me. you'd need to identify a field first before you try to find an antipode and I don't think that's even sensical
18:47:46 <Lynn> Those are... some type names *_*
18:48:16 <shachaf> arkeet: What do you want? You gave it five ->
18:50:52 <arkeet> shachaf: I dunno. I was just momentarily confused because I'd never seen it do that before.
18:51:20 <arkeet> the best I can get from that is dot f g = dot f id . g
18:51:34 <arkeet> but then probably one can also show that dot f id = f or something.
18:53:35 <jkaye> I'm interested in writing a simple web application using Servant as a backend and preferably some Haskell framework as a frontend. Does anyone have suggestions on a package or something that I can look into?
18:57:42 * stapler slaps zbcm around a bit with a large monad
19:01:26 <Welkin> jkaye: scotty, spock, yesod
19:01:33 <Welkin> I just started using servant and it is great
19:01:39 <Welkin> but it is definitely missing features
19:01:50 <Welkin> I have to use Wai directly for redirects
19:02:30 <jkaye> Welkin: I've been really liking it for its simplicity. What I want to accomplish is really small so I'm trying to keep it easy
19:02:51 <jkaye> I would love to just be able to hook some kind of framework into servant-client, since I already have my backend working
19:07:59 <jkaye> Looks like Scotty should do the trick nicely I think
19:42:04 <Pamelloes> What kinds of attributions do I need to make for a haskell project. Do I need to go through each library I'm using or is there a general attribution that covers everything?
19:44:26 <KaneTW> cabal-dependency-licenses
19:46:20 <Pamelloes> oh cool, that's exactly what I'm looking for :)
19:46:21 <Cale> Pamelloes: I don't think that's something which most people consider, but I suppose it's a valid point given that most things are BSD licensed, particularly if you're distributing binaries.
19:50:05 <Pamelloes> I wonder how much of hackage is licensed in a valid manner.
20:13:54 <lethjakman> How do you retrieve one value from persistent? I have a list_id column and I want to grab list_id so I tried (ListId list) but it throws an error
20:15:13 <lethjakman> https://gist.github.com/lethjakman/c689da48da7082dd882f
20:45:28 <Guest494> Is there a library in haskell for controlling unix, (I wish to input to stdin and receive the data from stdout) if so, what is it called?
20:46:21 <Guest494> execute the programs also, kind of like subprocess in python.
20:46:26 <slack1256> and output the data to stdout?
20:46:41 <arkeet> the 'process' package is good for doing stuff with processes.
20:47:09 <arkeet> you might also look at the unix package
20:47:27 <Guest494> arkeet: Thank you.
20:52:36 <Welkin> how does rewrite work in Wai?
20:52:57 <Welkin> what is pathInfo exactly?
20:53:01 <Welkin> it is [Text]
20:53:29 <Welkin> does that mean http://haskel.org/wiki would be ["haskell.org", "wiki"]?
20:53:53 <Axman6> I'd be very surprised if the hostname was included
20:54:02 <Welkin> well
20:54:10 <Welkin> it is used in rewrite to handle redirects
20:54:23 <Welkin> I am trying to figure out how to perform a redirect to a completrely dufferent website
20:54:33 <Welkin> different*
20:55:10 <Welkin> I would like to do this in servant, but since it has no redirect support I can't
20:55:30 <slack1256> I am reading the yesod book and it has some info on pathInfo. Maybe it carries over to Wai?
20:58:02 <lethjakman> Is there a way to see more info on a type error?
21:00:42 <Welkin> hm
21:00:49 <Welkin> how cna I make this work?
21:01:21 <Welkin> how do I redirect in Wai?
21:01:31 <Welkin> is it just a status303... then what else?
21:02:56 <KaneTW> it'd be weird if the hostname but not the scheme were included
21:03:41 <KaneTW> Welkin: there's a redirect utility function in wai-util
21:05:36 <Welkin> I see
21:05:46 <Welkin> you do use responseLBS with status303
21:05:59 <Welkin> but you include the redirect information in the header and an empty bytestring for the body
21:06:09 <Welkin> thanks KaneTW 
21:07:51 <defanor> picosecondsToUTCTime i = UTCTime (addDays (fromIntegral $ i `div` (60*60*24*10^12)) (fromGregorian 1970 1 1)) (picosecondsToDiffTime $ fromIntegral i `mod` (60*60*24*10^12)) ← is there any less verbose/ugly/possibly incorrect way to do that?
21:09:13 <KaneTW> np
21:10:43 <Clint> defanor: you could make it more verbose and less ugly
21:11:29 <defanor> Clint: yep, i've uglified it a bit before pasting here, to fit in a line. but still seems overcomplicated
21:12:33 <defanor> hoped that i'm missing some handy function that does at least some part of that
21:13:09 <dmj`> > join (***) (+1) $ (1,1)
21:13:10 <lambdabot>  (2,2)
21:13:45 <arkeet> > over both (+1) (1,1)
21:13:46 <lambdabot>  (2,2)
21:14:25 <nitrix> I'm sorry for the silly question but, whitin a do block of a `StateT Tape IO Int` monad, can I use IO operations?
21:14:37 <arkeet> only if you lift them
21:14:43 <arkeet> with e.g. liftIO
21:14:44 <dmj`> does anyone know why Object in Data.Aeson isn't HashMap String Value, why is it HashMap Text Value
21:14:48 <nitrix> If so how and why? I'd like to understand this and not always resort to guesswork.
21:14:54 <nitrix> :t liftIO
21:14:56 <lambdabot> MonadIO m => IO a -> m a
21:15:06 <dmj`> oh, String is a data constructor :)
21:15:13 <dmj`> it's late
21:15:16 <arkeet> there is an instance MonadIO (StateT Tape IO)
21:15:19 <KaneTW> nitrix: StateT is a monad transformer, i.e. a way to chain monads together
21:15:24 <nitrix> arkeet: It can be lifted to any monad? Isn't that dangerous?
21:15:29 <Welkin> dmj`: I started using servant
21:15:31 <arkeet> any MonadIO instance
21:15:35 <dmj`> Welkin: atta boy !!!
21:15:40 <dmj`> Welkin: and ?
21:15:43 <Welkin> dmj`: it doesn't have redirects!
21:15:47 <Welkin> otherwise I like it
21:16:12 <nitrix> arkeet: MonadIO m => MonadIO (StateT s m)
21:16:15 <arkeet> yes
21:16:27 <nitrix> arkeet: I see. I really appreciate. Thanks for the help.
21:16:27 <dmj`> Welkin: what do you a need redirect for
21:16:36 <arkeet> (and also an instance for IO)
21:16:58 <defanor> nitrix: yup, just lift them
21:16:58 <defanor> (liftIO)
21:17:33 <Welkin> dmj`: some application I am building with bitly-like functionality
21:18:10 <dmj`> Welkin: you can always just return a 301 Redirection
21:18:35 <Welkin> yeah, I am using wai for the redirect
21:18:48 <Welkin> I would still like to be able to use servant for the request processing though
21:18:53 <Welkin> can I do that using Raw?
21:19:01 <dmj`> Raw is a bit of an abyss
21:19:10 <Welkin> "endpoint" :> Capture "x" Integer :> Raw
21:19:11 <Welkin> ?
21:19:36 <Welkin> otherwise I have to do everything manually through wai and lose all the nice functionality for processing the request
21:19:47 <dmj`> Yea, you could do that, I use Raw to host static sites, unsure about going from Raw back to your handler tho
21:20:59 <Welkin> dmj`: Raw passes the parameters along?
21:21:08 <dmj`> Welkin: no, it won't
21:21:14 <Welkin> oh, that won't work then
21:21:32 <Welkin> I need to look up the parameters to decide where to redirect
21:21:48 <dmj`> Welkin: you need dynamic urls is what you're saying
21:22:43 <dmj`> Welkin: actually, sorry it does pass the parameters along. I use /docs/ and that is present in the url on my static site
21:22:50 <Welkin> I see that there is an open issue since July to add Redirect to servant
21:25:01 <dmj`> Welkin: where?
21:25:20 <dmj`> oh I see it
21:27:18 <dmj`> Welkin: it's definitely possible, just need someone to submit a pull
21:27:28 * dmj` glares at Welkin
21:27:38 <Welkin> haha
21:28:09 <Welkin> I don't even understand what is going on in the library
21:28:22 <Welkin> I'm not familiar with the type tricks they are using
21:29:07 <dmj`> Welkin: this is a good intro, http://www.arow.info/blog/posts/2015-07-10-servant-intro.html
21:29:48 <Welkin> I remember you sending me that before, but I forgot about it
21:29:49 <Welkin> thanks
21:29:59 <Welkin> haha, I actually had it bookmarked
21:31:37 <Welkin> huh, I guess I can't test redirects using curl
21:31:59 <KaneTW> i'm watching cabal install something and i have no idea what i'm installing
21:35:34 <Welkin> :)
21:35:39 <Welkin> it works with Raw
21:35:41 <Welkin> nice
21:36:17 <Welkin> at least this should be fine for now until Redirect gets added
21:36:54 <dmj`> Welkin: cool !
21:39:53 <zxxxxr> pl \x y -> x y
21:40:21 <georgy-> @pl 
21:40:21 <lambdabot> (line 1, column 1):
21:40:21 <lambdabot> unexpected end of input
21:40:21 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
21:40:27 <georgy-> @pl \x y -> x y
21:40:27 <lambdabot> id
21:40:54 <zxxxxr> @pl \x y -> x y
21:40:54 <lambdabot> id
21:41:26 <zxxxxr> @pl \a -> (a:) . (x:)
21:41:26 <lambdabot> (. (x :)) . (:)
21:49:26 * hackagebot quiver 1.0.1 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-1.0.1 (patrykz)
21:49:47 <zxxxxr> @pl \x y -> (x, y)
21:49:47 <lambdabot> (,)
21:50:35 <zxxxxr> @pl \x l r -> p x && l && r
21:50:35 <lambdabot> (. (&&)) . (.) . (&&) . p
21:54:26 * hackagebot gll 0.3.0.1 - GLL parser with simple combinator interface  https://hackage.haskell.org/package/gll-0.3.0.1 (ltvanbinsbergen)
21:55:19 <KaneTW> zxxxxr:  if you're just messing around, /msg lambdabot 
21:58:18 <nitrix> No .cabal file found in directory /home/nitrix/projects/nitrix.me/
21:58:38 <nitrix> There is indeed a file named `nitrix.me.cabal`, could it be because of the dot? Should I report the bug or am I missing something here?
21:58:49 <arkeet> I think it's the dot.
21:59:17 <arkeet> https://www.haskell.org/cabal/users-guide/developing-packages.html#package-names-and-versions "Cabal package names can use letters, numbers and hyphens, but not spaces."
22:00:56 <nitrix> Oh crap. So I'm actually breaking the rules.
22:01:39 <nitrix> Alright, thanks :/
22:05:31 <Welkin> wow
22:05:37 <Welkin> this is horrible
22:05:39 <Welkin> "The word “referrer” has been misspelled in the RFC as well as in most implementations to the point that it has become standard usage and is considered correct terminology"
22:05:53 <Welkin> in regard to the HTTP Reponse headers
22:06:09 <Welkin> so it is Referer instead of Referrer
22:07:41 <wedify> i have very little social contact so i hope you guys will bear with me
22:07:57 <wedify> i'm slowly learning how to have coherent thoughts
22:10:59 <nitrix> wedify: I think there's more out there like you than you want to think. Go at your own pace. (:
22:11:37 <nitrix> Welkin: At least it's consistent.
22:13:14 <wedify> is there a way to make string be an alias for text
22:16:39 <liste> wedify import Prelude hiding (String); type String = Text
22:16:42 <liste> but don't do that
22:17:18 <liste> it'll confuse everyone else
22:17:35 <slack1256> but if you mean treating "string values" as if they were Text, checkout OverloadedStrings extensions
22:18:27 <liste> > ("hi!" :: ByteString) -- like this (lambdabot can't Text)
22:18:28 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
22:18:28 <lambdabot>      Perhaps you meant one of these:
22:18:28 <lambdabot>        ‘BSC.ByteString’ (imported from Data.ByteString.Char8),
22:18:35 <liste> > ("hi!" :: BSC.ByteString) -- like this (lambdabot can't Text)
22:18:36 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
22:18:36 <lambdabot>                  with actual type ‘[Char]’
22:18:36 <lambdabot>      In the expression: ("hi!" :: BSC.ByteString)
22:19:08 <liste> seems lambdabot doesn't have -XOverloadedStrings either :(
22:19:24 <slack1256> @set -XOverloadedStrings
22:19:35 <liste> thanks (:
22:19:38 <liste> > ("hi!" :: BSC.ByteString) -- like this (lambdabot can't Text)
22:19:39 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
22:19:39 <lambdabot>                  with actual type ‘[Char]’
22:19:39 <lambdabot>      In the expression: ("hi!" :: BSC.ByteString)
22:19:50 <slack1256> nah, it didn't reply, so it didn't work
22:19:54 <wedify> it's time to move on :) i'm a hobbyist i'll do what i want
22:20:18 <wedify> like i want to approach natural language
22:20:39 <slack1256> laik diz?
22:20:40 <wedify> so how would i parse multiword function names
22:20:59 <wedify> like has, is, are
22:21:18 <wedify> it's in so many variable names why can't i write it
22:21:30 <wedify> if is foo then ... else ...
22:21:43 <liste> isFoo ?
22:21:44 <slack1256> > words "hello world, don't go over me"
22:21:46 <lambdabot>  ["hello","world,","don't","go","over","me"]
22:21:55 <wedify> so i don't expect anyone to adopt it, it's just weird and funky
22:22:05 <wedify> for the hell of being weird and funky
22:22:14 <slack1256> no, maybe you want parsing libraries?
22:22:40 <wedify> slack1256; yes. i'm learning how to make my own syntax
22:22:46 <wedify> and how to compile it
22:23:00 <wedify> so i'm going to experiment with haskell-like languages
22:23:46 <wedify> ultimately they are all equivalent so this would be an experiment in how to separate syntax from semantics
22:24:26 <wedify> while somehow maintaining readability
22:24:45 <slack1256> I wish you well then
22:25:14 <wedify> by giving semantics to classes of languages
22:25:55 <liste> most Haskell-like languages share similar syntax but have quite different semantics
22:26:10 <wedify> yeah i'm hoping i picked something interesting to do and that we could all speculate as to implementation
22:26:23 <wedify> an impromptu code fest
22:26:54 <slack1256> it is interesting I guess, but this is still #haskell. Mainly a channel for haskell questions
22:27:04 <slack1256> but maybe in #haskell-blah it would be appreciated
22:27:06 <wedify> so if interested  how could we enable efficient parsing of function names with spaces in them
22:27:20 <slack1256> (usually same folks, just different purpose)
22:27:22 <wedify> it would be slow because of backtracking right?
22:28:39 <wedify> so what if we just returned a bunch of parses and the computer would have to make a choice because of limited memory
22:29:10 <wedify> is it possible to specify semantics with sloppy syntax
22:32:18 <wedify> so i have introduced to my syntax has and is, which are nearly redundant
22:32:56 <liste> wedify as slack1256 said, #haskell-blah would be more appropriate, but how would you disambiguate a function "do it" from a function "do" and a variable "it"
22:33:26 <liste> please, if you want to continue about this topic, come to #haskell-blah
23:17:00 <Hakim> Guys, am stuck on how to check the value of a hand with this code
23:17:01 <Hakim> value :: Hand -> Integer
23:17:01 <Hakim> value []		= 0
23:17:01 <Hakim> value (Add card hand)	= + value hand
23:17:28 <Hakim> how can i read each Card and check its rank there by getting its value in a BlackJack game?
23:20:36 <pavonia> Hakim: What is Hand?
23:21:03 <Hakim> hand is desribed as follows
23:21:03 <Hakim> data Hand = Empty | Add Card Hand
23:21:04 <Hakim>             deriving (Eq, Show)
23:21:25 <Hakim> and i described card as follows
23:21:26 <Hakim> data Card = Card { rank :: Rank, suit :: Suit }
23:21:26 <Hakim>             deriving (Eq, Show)
23:21:33 <pavonia> So [] is a type error then
23:22:24 <Hakim> was thinking on the value function, if one provides an empty hand, then the value should ofcourse be 0
23:22:36 <Hakim> or should i put it like value Empty = 0?
23:22:54 <Lynn> Hakim: you could simply say  type Hand = [Card]!
23:22:57 <pavonia> [] is the empty list which is different from the Empty value of type Hand
23:23:33 <Lynn> But yeah, `value Empty = 0` is fine
23:23:40 <frerich> Hakim: I think you should first define a function 'rankValue :: Rank -> Integer'. Using that, you could define 'value Empty = 0; value (Add card rest) = rankValue (rank card) + value rest'
23:24:17 <roelof> anyone with more feedback here : https://www.reddit.com/r/haskellquestions/comments/3kxbko/is_this_a_good_way_to_solve_this_without_using/
23:24:33 <Hakim> ok....cool Lynn....
23:24:52 <frerich> Hakim: If you'd consider 'type Hand = [Card]' then this could be simplified to 'value hand = sum (map rank hand)'
23:25:14 <georgy-> yeah your Hand is basically a custom list-like type, downside being that you can't use any of the existing list functions
23:26:11 <Hakim> No...cant user actually any of the existing list functions
23:26:45 <Lynn> Oh, is this for homework (and the Hand definition is not up to you to change?)
23:27:30 <Hakim> No..its not any form of homework, am new to Haskell and learning from the Pluralsight videos....but they suck..
23:27:43 <KaneTW> @where learnhaskell
23:27:43 <lambdabot> https://github.com/bitemyapp/learnhaskell
23:27:44 <Hakim> but i would like to learn it in both ways...
23:27:45 <KaneTW> ^
23:28:22 <Lynn> Hakim: OK, makes sense!
23:28:27 <Hakim> rewriting my Hand either in a qualified or unqualified format
23:29:19 <roelof> Hakim:  why do the videos suck then ? 
23:30:36 <Hakim> well, i think the way he introduces Haskell as compared to the way they do for other programming languages on their platform is a bit different
23:31:21 <Hakim> they are less connected to each other...almost every lesson is independent rather than being a continuation from the previous one
23:32:20 <Hakim> but can i wrote something like 'type Hand = [Card] deriving (Show, Eq)? is it a valid code?
23:32:58 <KaneTW> you don't need to derive instances for a 'type' declaration
23:33:00 <ldlework> Sorry if this is a dumb quesiton, but is there a formal name for the function parameter of map?
23:33:01 <KaneTW> it's just an alias
23:38:10 <roelof> anyone a idea how I can know how many numbers there are above average on 3 numbers with no use of lists, maps and lambda's ? 
23:38:40 <roelof> I did succced in counting and comparing it with a average but I wonder if there is another way
23:41:09 <Lynn> roelof: So, count how many elements in [a, b, c] are greater than (a + b + c) / 3?
23:41:21 <Hakim> <roelof> could you please giv us your sample code on how you did it?
23:41:30 <roelof> Lynn:  yes, that is what I mean 
23:42:05 <roelof> Hakim:  yes, here you have : http://lpaste.net/141017
23:42:28 <Lynn> Well, a > (a + b + c) / 3  iff  3a > a + b + c  iff  2a > b + c
23:42:43 <roelof> Lynn:  almost correct I mean how many elements in a b c are greater then a + b+ c / 3 
23:43:38 <Lynn> I don't see the difference O_o
23:43:59 <Lynn> I mean, what I said wasn't a full solution.
23:44:23 <roelof> [ a , b c] is a list  . a b c are three arguments , three seperate int 's 
23:44:39 <Lynn> It was just food for thought. If I wanted to avoid lists and maps and lambdas, for some reason, I would probably write something like:
23:47:20 <Lynn> countGreaterThanAvg a b c =   let   f x = if 3*x > a + b + c then 1 else 0   in   f a + f b + f c
23:48:36 <roelof> Lynn:  oke, and the X stands for ? 
23:50:12 <Lynn> Haha, okay, I cheated -- using `let` is kind of like a lambda. It's a parameter to a small function I'm defining, called f.
23:51:44 <roelof> and your suggestion gives the wrong answer for 15 50 35 where the average is 33 so two numbers are more then the average 
23:53:02 <Lynn> @let countGreaterThanAvg a b c =   let   f x = if 3*x > a + b + c then 1 else 0   in   f a + f b + f c
23:53:03 <lambdabot>  Defined.
23:53:12 <Lynn> > countGreaterThanAvg 15 50 35
23:53:14 <lambdabot>  2
23:53:18 <Lynn> Looks good to me.
23:54:13 <roelof> Oke, then I do not understand the code  you are sayin then 1 else 0 
23:54:22 <roelof> where idoes the 2 coming from ? 
23:54:32 <arkeet> 0 + 1 + 1
23:54:33 <arkeet> = 2
23:54:55 <roelof> oke, from the last part f a + f b + f c 
23:54:58 <arkeet> yes
23:56:09 <roelof> oke, so this function takes first a then b and then c  and compare it to the 3 * x > a + b + c part 
23:59:47 <roelof> arkeet:  Lynn  can you answer my last question ? 
23:59:57 <arkeet> what question?
