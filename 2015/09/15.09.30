00:00:20 <jle`> echo-area: i just said that State might not be the best way to work with state in general in Haskell.  but if you had to use State, then using lenses with zoom is probably the nicest way to work with mixing different states together
00:00:52 <Guest78> jle`: and what do you think of the netwire solution ?
00:01:04 <jle`> bollu: another way of looking at it, going backwards, is that a category is a "typed monoid", where the binary function is partial
00:01:28 <bollu> is this construction right? take a single object in the category, make all arrows endo, then take every object of the monoid x to the arrow \y -> x + y
00:01:41 <bollu> take every member of the monoid**
00:01:42 <jle`> for monoids, you can in general "combine" any two items in your set
00:01:54 <echo-area> jle`: Yes I see that.  Were you saying that the choice of using State depends on the problem?
00:01:58 <shachaf> Right for what?
00:02:16 <bollu> shachaf: "right" in the sense of mathematically correct
00:02:53 <shachaf> I don't follow it. What is "make all arrows endo"?
00:02:55 <Guest78> srhb: how high is the learning curve for netwire, or should I use StateT if I have little time ?
00:03:11 <bollu> shachaf: like, make all arrows to and from this one object
00:03:21 <shachaf> What are you trying to accomplish?
00:03:30 <bollu> shachaf: take a monoid and construct a single object cateogr
00:03:33 <bollu> catrgory*
00:03:42 <shachaf> Oh.
00:04:03 <srhb> Guest78: No idea what you're doing. StateT and Netwire are not usually considered interchangable in any way.
00:04:03 <shachaf> Just take yourself as the object, and each element of the monoid as an arrow going from and to that object.
00:04:11 <shachaf> And composition as multiplication in your monoid.
00:04:26 <bollu> shachaf: cool, thanks :)
00:04:51 <shachaf> "the arrow \y -> x + y" I don't know what it is.
00:05:15 <Guest78> srhb: look at these two ansers one is using StateT and lenses the other is using netwire FRP
00:05:18 <Guest78> http://stackoverflow.com/questions/13915923/combining-multiple-states-in-statet
00:05:39 <srhb> Guest78: No, I don't have time for that right now. :)
00:05:53 <bollu> shachaf: well, I was thinking of arrows as functions, but I realize that's silly. I probably should have said, given two arrows X and Y corresponoding to x and y in the monoid, X . Y == arrow from (x <> y)
00:06:12 <Guest78> srhb: Ok, no problem :)
00:06:33 <Guest78> thanks all!
00:06:43 <bollu> shachaf: I hope that made more sense :)
00:06:57 <shachaf> Sure.
00:07:09 <shachaf> Composition in the category is the same operation as multiplication in the monoid.
00:07:23 <bollu> yep
00:08:53 <bollu> shachaf: if I take a group, then I'll get invertible arrows as well. Does that give a "more interesting" category?
00:09:05 <bollu> invertible arrows, meaning, X . Y = id
00:09:19 <shachaf> It gives you a category which is exactly as interesting as the group, since it's the same thing.
00:09:26 <bollu> shachaf: ahh xD
00:09:33 <shachaf> Or if you mean categories in which all arrows are invertible, those are called "groupoids".
00:09:51 <bollu> shachaf: oh, why the name
00:10:13 <shachaf> By analogy to the thing you just said.
00:10:45 <bollu> ah. Why not just "group" ? I think you can get a mapping from Category with invertible arrows -> Group ?
00:12:24 <jle`> a groupoid with only one object is indeed a group
00:12:33 <jle`> but it's nice to give both things different names...it's less confusing that way
00:12:34 <shachaf> No, not if you have multiple objects.
00:13:12 <bollu> shachaf: oh, hm
00:18:36 * hackagebot scientific 0.3.4.0 - Numbers represented using scientific notation  https://hackage.haskell.org/package/scientific-0.3.4.0 (BasVanDijk)
00:33:17 <hc> I've got some code here that reads data directly from a Handle
00:33:26 <hc> is it possible to create a "virtual" handle from a ByteString?
00:33:35 <hc> So that I need not create a temporary file
00:34:08 <Itkovian> you mean like sscanf? :)
00:34:21 <bollu> which one is a Mealy machine and which one is a Moore machine?
00:34:23 <bollu> I always mix em um
00:34:54 <glguy> I don't know if this package works well, but the Handle API is designed to support what you're asking for: http://hackage.haskell.org/package/knob-0.1.1
00:34:56 <hc> Itkovian: yeah, kind of
00:35:10 <hc> glguy: looks interesting, thanks
00:36:19 <jle`> bollu: i know a more reliable way to find out than asking in an unrelated irc channel :)
00:36:42 <bollu> jle`: people here have really cool ways of remembering things :)
00:36:53 <bollu> example: S combinator is isomoprhic to applicative instance of (-> a)
00:37:05 <bollu> that blew my mind >_>
00:37:09 <jle`> ( you probably mean (->) a  )
00:37:15 <bollu> ah yes :)
00:37:26 <hc> haha :)
00:37:38 <bollu> so, well, I guess I should rephrase
00:37:52 <bollu> "Is there an awesome Haskell way to remember the Mealy and Moore machines" ?
00:38:25 <jle`> well...if you're asking for haskell encodings of mealy and moore machines, there are several
00:38:47 <bollu> jle`: um, do tell :)
00:39:24 <joco> say i have two data types which are instances of the show class, Int and String, now, the question, can I create a List which contains anything that is showable ? what is the simplest way of doing so ? so that I can do map show [1,"2",3] ?
00:40:04 <julianleviston> joco: not unless you put these things into your own data type… 
00:40:18 <julianleviston> joco: or enable … I forget the extension… to let you have different types in lists
00:40:27 <liste> joco you can use existentials for that, but storing the results is a better idea
00:41:16 <jle`> bollu: well, for Moore machines, there's the straightforward encoding straight from the mathematical definition of moore machines, data Moore s a b = Moore (s -> b) (a -> s -> s) s
00:41:18 <joco> julianleviston and liste : so i cannot just put Int and String into a list ?
00:41:29 <julianleviston> > [1,”hey”]
00:41:31 <lambdabot>  <hint>:1:4: lexical error at character '\8221'
00:41:50 <liste> joco no, but you could make a Showable type and put them in a list
00:41:51 <jle`> bollu: or a lot of people like to hide the s, data Moore a b = forall s. Moore (s -> b) -> (a -> s -> s) s
00:41:52 <joco> and type it as [1,"hello"] :: Show s => s ?
00:42:03 <liste> joco and that is equivalent to just putting strings in a list
00:42:17 <jle`> um, data More a b = forall s. Moore (s -> b) (a -> s -> s) s
00:42:30 <jle`> bollu: if you look at the last two arguments...what does that look like?  do they look familiar?
00:42:32 <julianleviston> joco: you could also make your own data type… 
00:42:35 <shachaf> Moore a = Cofree (a ->)
00:42:45 <joco> actually i have my own data type
00:42:57 <bollu> jle`: no, but I'm guessing what shachaf said is it?
00:43:02 <liste> joco "Show s => s" means "forall s. Show s => s"
00:43:10 <liste> you want "exists s. Show s => s"
00:43:10 <bollu> jle`: I'm not very familiar with the "co" structures
00:43:15 <shachaf> liste: No you don't.
00:43:33 <shachaf> liste: You might want "exists s. Show s *> s", if *> was in GHC.
00:43:50 <shachaf> But "exists s. Show s => s" is useless.
00:43:55 <liste> thanks for the correction shachaf (:
00:43:55 <jle`> bollu: not directly related
00:44:03 <joco> so I have data A and data B
00:44:13 <joco> they are both instances of typeclass S
00:44:32 <joco> and have the print method
00:44:35 <liste> joco https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
00:44:38 <jle`> hm, i should have written that as (s -> a -> s)
00:45:02 <julianleviston> joco: broadly, what are you trying to do with this list?
00:45:08 <bollu> jle`: wait, data Moore s a b = Moore (s -> b) (a -> s -> s) s | s is your state, (a -> s -> s) is your transition function, so what is (s -> b) ?
00:45:09 <shachaf> jle` is probably trying to get you to say foldl
00:45:24 <jle`> bollu: that's the function from the state to the output
00:45:25 <julianleviston> joco: or put another way, once you have this hypothetical list, what would you do with it?
00:45:37 <joco> julianleviston: print it :)
00:45:48 <joco> it is a svg printer
00:45:50 <shachaf> I can't imagine that this approach is particularly helpful.
00:45:51 <bollu> jle`: oh, to actually "use" the current state?
00:45:58 <joco> svg elements as datatypes
00:46:07 <joco> for rectangle i have Rect
00:46:10 <liste> joco why not put them in a sum type?
00:46:16 <joco> for image I have Img
00:46:21 <jle`> bollu: that's just a part of the definition of a moore machine.  A moore machine is a starting state, a (s -> a -> s), and a (s -> b) to get an output for every state
00:46:29 <julianleviston> joco: yeah, what liste said. :)
00:46:33 <joco> liste: ok, that is interesting 
00:46:46 <joco> julianleviston: thanks for that idea :)
00:46:48 <julianleviston> joco: then you can just map print across them and sequence_ the output
00:46:55 <joco> yeah...
00:46:55 <liste> joco: "data SvgElement = SvgRect Rect | SvgImg Img ..."
00:46:57 <jle`> bollu: anyways yeah, shachaf's point was what i was trying to say.  Moore machines end up being practically used by the `foldl` library on hackage to basically encapsulate a "foldl + output map"
00:47:02 <joco> right
00:47:05 <joco> sounds good
00:47:06 <bollu> jle`: oh, right :) output function
00:47:06 <joco> :)
00:47:09 <shachaf> It wasn't my point.
00:47:19 <joco> cool
00:47:23 <jle`> shachaf's guess at what i was trying to say, then?
00:47:25 <joco> i am gonna try that...
00:47:54 <joco> i think i am still havent forgot completely what i learned in oo languages...
00:48:10 <bollu> :t foldl
00:48:12 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
00:48:17 <joco> i need to unlearn that ASAP
00:48:25 <julianleviston> joco: you might find that if you put them in a sum type, an interesting commonality pops out… which might be useful.
00:48:35 <jle`> :t \g f x -> g . foldl f x
00:48:36 <lambdabot> Foldable t => (b -> c) -> (b -> a -> b) -> b -> t a -> c
00:48:46 <liste> joco or if there's way too many SVG elements and/or the element type needs to be extensible, you could use interface records
00:48:54 <bollu> what the hell, that is crazy
00:49:09 <joco> liste: no, its just a little parser
00:49:17 <joco> liste: for a few elements
00:49:26 <joco> sum type sounds good
00:49:28 <liste> then sum type seounds optimal
00:49:36 <jle`> representing a fold-and-apply 3-tuplet (the (b -> c), (b -> a -> b), and b) as a data type is nice because you can write Applicative, Functor, etc. instances that mean things
00:50:17 <joco> i had the feeling that i was doing something wrong... if i need so compilcated stuff for something simple like this...
00:50:20 <bollu> jle`: whoa, okay, you can get instances of functor, ap and monad for it?. What would it even mean ("map a function over a moore machine") I need to play around with this
00:50:34 <bollu> jle`: 	okay, what's another cool encofing? :)
00:50:39 <joco> this is my first or second real haskell program...
00:50:44 <joco> after lot of reading...
00:50:56 <bollu> encoding*
00:51:15 <joco> anyway, thanks, and talk later
00:51:24 <bollu> jle`: haskell gives you this weird elevated perspective of everything. I don't know if that's a good thing or not >_>
00:51:35 <jle`> bollu: well, if `Moore a b` is a moore machine that takes a's as inputs and returns b's as output, then fmap would be (a -> b) -> Moore r a -> Moore r b.  It'd use an (a -> b) to turn a Moore machine that returns a's as inputs and turns it into a Moore machine that returns b's as inputs.  it probably isn't a huge stretch to see what that means?  writing the instance might be fun
00:52:32 <bollu> ah, yeah. That makes sense. 
00:52:43 <bollu> jle`: related question that's bugged me for a while
00:52:51 <bollu> how do you know what order of type arguments to pick?
00:53:10 <bollu> because different ordering will give you instances of functor, ap, etc that mean different things
00:53:11 <jle`> well in this case, picking Moore a b where b is the output lets you write a Functor and Applicative instance
00:53:22 <jle`> flipping the order, you can't write a Functor instance
00:53:36 <bollu> jle`: ah. So it's more of a "experiment and see" kind of a thing?
00:53:55 <jle`> yeah, although you gain an intuition after a while
00:54:22 <bollu> jle`: hm, okay
00:55:12 <jle`> along this same lines, you can have data Mealy a b = forall s. Mealy (a -> s -> b) (a -> s -> s) s, or data Mealy a b = forall s. Mealy (a -> s -> (b, s)) s
00:55:17 <bollu> also, can every moore machine be seen as a mealy machine whose output function is" mealyOutput = \s a -> mooreOutput s (basically ignore the input token?)
00:55:35 <jle`> which is nothing more than a straightforward tupling of the mathematical definition of a mealy machine
00:55:54 <bollu> oh, that's cute :) I've never seen that before (tupling)
00:56:13 <bollu> wait, that looks suspiciously like Mealy (a -> State s b) s ?
00:57:13 <bollu> jle`: does my intuiton make sense?
00:57:38 <jle`> bollu: yes, i wrote the arguments that way in case you might spot the similarity, but i don't have anything interesting to say about it further than that
00:57:53 <bollu> jle`: ah, okay
00:58:01 <jle`> another very common encoding of mealy machines that people use a lot in the real world is the recursive one
00:58:09 <bollu> oh? I don't know this one
00:58:17 <jle`> data Mealy a b = Mealy (a -> (b, Mealy a b))
00:59:15 <jle`> it's kind of cuter because you don't have to deal with an explicit existential, but I think GHC's optimizer is a little less friendly with it because of the recursive nature
00:59:50 <jle`> if you're ever bored, writing the isomorphism between the two encodings might be fun
00:59:59 <bollu> jle`: recursive types confuse me :( How would I instantiate it? (where would the Mealy a b terminate?)
01:02:16 <bollu> jle`: 
01:02:27 <bollu> data Mealy a b = Mealy (a -> (b, Mealy a b)), right?
01:02:34 <bollu> so, well, If I expand it again
01:02:52 <bollu> (Mealy (a -> (b, Mealy (a -> (b, Mealy a b)))
01:02:58 <bollu> so where would that expansion stop?
01:03:05 <bollu> that's what's confusing me
01:03:06 <bollu> :t Fix
01:03:07 <lambdabot>     Not in scope: data constructor ‘Fix’
01:03:07 <lambdabot>     Perhaps you meant one of these:
01:03:07 <lambdabot>       variable ‘iix’ (imported from Control.Lens),
01:03:27 <jle`> i uh almost completely forgot that i wrote a blog post about this a couple of years ago
01:03:36 <bollu> like, in Fix, you have a surrounding f to let you terminate i
01:03:38 <bollu> it*
01:03:45 <bollu> Fix f = Fix (f Fix f), right
01:03:56 <bollu> so I can use the "f" to stop the structure
01:04:04 <bollu> how do I "stop" the mealy machine structure?
01:04:10 <bollu> jle`: link to blogpost? :)
01:04:50 <slacko1256> maybe you don't?
01:05:04 <slacko1256> maybe just discard the value and laziness won't evaluate the rest?
01:05:05 <jle`> it's at http://blog.jle.im/entry/intro-to-machines-arrows-part-1-stream-and but i feel a bit weird self-promoting.  but going any deeper into this subject would probably be a bit too involved for a discussion here that's tangented a bit.  the answer becomes a lot clearer when you remember what a mealy machine actually is
01:05:47 <bollu> slacko1256: but, won't that be an infinite type?
01:06:24 <jle`> by the way it might be worth noting that what we're calling Mealy and Moore machines here technically aren't the mathematical definitions of Mealy and Moore, because those require finite state, input, and output sets
01:07:19 <cocreature> bollu: here's a minimal example http://lpaste.net/141975
01:07:29 <bollu> oh my god, you can instantiate types like SCons ( 1, SCons ( 2, SCons ( 3, ... ) ) ) :O
01:07:46 <slacko1256> bollu: I am not familiar with infinite types, but this are just recursive types. Also it looks a lot like State
01:07:54 <bollu> cocreature: what would :t myMealy give you?
01:08:14 <cocreature> Mealy Input String
01:08:19 <cocreature> it even has an explicit type annotation :)
01:08:36 <bollu> oh righ
01:08:39 <bollu> oh right*
01:09:28 <bollu> cocreature: so, a end state would be one that "points to itself"?
01:09:59 <cocreature> right, it just transitions to itself for every possible input
01:10:18 <jle`> bollu: but consider the mealy machine whose state starts at 0, and whose "output and new state" given an input is (\inp oldState -> (inp + oldState, inp + oldState)).  This represents a machine whose state and output is the sum of all inputs it's seen "so far".  The first encoding would be Mealy (\x s -> (x+s,x+s)) 0.  the second encoding would be myMealy = go 0 where go s = Mealy (\i -> (i + s, go (i + s))
01:10:51 <slacko1256> @data Mealy a b = Mealy (a -> (b, Mealy a b))
01:10:51 <lambdabot> Unknown command, try @list
01:10:57 <slacko1256> @let data Mealy a b = Mealy (a -> (b, Mealy a b))
01:10:58 <bollu> jle`: I'll be pen and paper-ing this
01:10:59 <lambdabot>  Defined.
01:11:07 <jle`> anyways i have to go to bed, happy haskelling :)
01:11:16 <bollu> night :) and thanks for the knowledge
01:11:32 <cocreature> jle`: well then you're really in the infinite state territory (if you don't count the limited memory of your computer)
01:11:56 <bollu> I've never studied infinite state machines
01:15:25 <cocreature> bollu: if it helps, I added a function to accumulate the outputs if you have a list of inputs http://lpaste.net/141975
01:15:44 <bollu> cocreature: ty :)
01:28:40 <tdammers> bollu: I started studying them, but I don't expect results anytime soon :P
01:38:01 <julianleviston> Does lambdabot use SafeHaskell and Hint?
01:39:01 <quicksilver> I don't think so
01:40:02 <quicksilver> hint uses the GHC API; I think lambdabot actually compiles code and runs it
01:40:20 <geekosaur> lambdabot uses mueval which uses both hint and the SafeHaskell extension
01:40:29 <julianleviston> ah right mueval. 
01:40:35 <julianleviston> nice.
01:40:44 <quicksilver> aha, I'm wrong then
01:40:56 <julianleviston> quicksilver:  not really that wrong.
01:41:16 <quicksilver> well I think it didn't use hint, and it does, via mueval :)
01:41:25 <quicksilver> it was true in the past though
01:41:32 <quicksilver> lambdabot used to use hsplugins and compile.
01:41:47 <geekosaur> you might notice that syntax errors from e.g. :t are reported by hint :)
01:41:54 <geekosaur> :t +
01:41:55 <lambdabot> parse error on input ‘+’
01:42:03 <geekosaur> hm, not syntax errors then
01:42:10 <geekosaur> oh, was a bad char error earlier
01:42:13 <quicksilver> and before SafeHaskell it had its own ad-hoc security
01:42:33 <quicksilver> there is also geordi which takes an entirely different approach to safe running
01:45:30 <phaazon> hey
01:45:31 <phaazon> woah
01:45:36 <quicksilver> I prefer geordi's appraoch in some ways but safehaskell is more benefit to the haskell community
01:45:37 <phaazon> why isn’t there a Functor instance for Set?
01:45:41 <phaazon> there’s a map function though
01:45:44 <julianleviston> quicksilver: the web framework?
01:45:44 <phaazon> I’m being curious
01:45:52 <quicksilver> phaazon: because of the annoying Ord constraint
01:45:57 <phaazon> oh yeah
01:46:02 <phaazon> hm
01:46:04 <phaazon> why?
01:46:09 <phaazon> hm
01:46:11 <phaazon> nevermind :D
01:46:17 <quicksilver> because fmap promises to work for any types a,b
01:46:20 <phaazon> yep
01:46:26 <phaazon> nevermind me :D
01:46:42 <quicksilver> julianleviston: no. that's confusing.
01:46:50 <julianleviston> quicksilver:  haha :) yeah
01:47:04 <julianleviston> quicksilver: you mean this one https://github.com/Eelis/geordi
01:47:13 <julianleviston> quicksilver: not this one https://github.com/liamoc/geordi
01:47:18 <quicksilver> correct!
01:47:46 <quicksilver> it can safely evaluate C and C++ (and anything really - it's a safe executable runner)
01:48:05 <quicksilver> Eelis used to be in this channel in fact.
01:55:51 <julianleviston> If I want to write haskell in my browser, does GHCJS do that?
01:59:54 <srhb> julianleviston: ghcjs allows you to compile Haskell to javascript, yes.
02:00:07 <julianleviston> srhb: but in what environment is the compilation taking place?
02:00:15 <julianleviston> srhb: in the browser?
02:00:18 <srhb> No.
02:00:20 <julianleviston> aw
02:00:38 <srhb> Unless you want to compile GHCJS to JS, in which case, good luck! :-)
02:00:43 <julianleviston> lol
02:01:38 <tdammers> there's always jslinux.org
02:02:40 <julianleviston> I could just do the recompilation on the server, I guess… that would work fine.
02:03:06 <julianleviston> tho… I actually want to pull new data structures into the browser… hm.
02:03:13 <julianleviston> directly.
02:04:26 <srhb> Dynamically? Why?
02:04:38 <srhb> Surely you don't introduce new data structures without restarting your server.
02:04:43 <julianleviston> Oh i can use hint.
02:04:45 <julianleviston> Um...
02:05:02 <julianleviston> because I don’t want to do the dance of JSON
02:05:10 <julianleviston> to send my data structures back and forth 
02:05:15 <julianleviston> is that an insane idea?
02:05:26 <srhb> I don't understand why you think you need hint for this.
02:05:27 <julianleviston> is there a better idea?
02:05:34 <julianleviston> srhb: maybe I don't.
02:05:56 <srhb> When you recompile the server with new data structures, you recompile the client js too with ghcjs
02:06:03 <srhb> They share data structures from some common source
02:06:11 <srhb> Even though server is compiled with ghc and client with ghcjs
02:06:23 <julianleviston> srhb: but I want to recompile the data without touching the source code.
02:06:38 <srhb> "recompile the data"?
02:06:53 <julianleviston> srhb: yeah. say I have a rose tree… 
02:06:58 <srhb> Yes..
02:07:04 <julianleviston> srhb: on the server
02:07:07 <srhb> Uh huh.
02:07:32 <julianleviston> srhb: and the client wants to get it… so it says “hey, gimme” and the server sends something via serialised data to it
02:07:40 <srhb> Yes.
02:08:06 <julianleviston> srhb: now I want to modify, and send back… so I do so.. what format is the serialisation in?
02:08:18 <srhb> Whatever you want. cereal would be obvious.
02:08:44 <julianleviston> ooh.
02:09:36 <julianleviston> Ok… so now I change the form of my data structure… so to do that, I define a new one, and then a translation between them… recompile on the server…and refresh on the client, I guess… that makes sense.
02:09:58 <srhb> If you change the shared data structure, you recompile both server and client.
02:09:58 <julianleviston> srhb: recompile live… while it’s running.
02:10:06 <srhb> I don't understand why you want to do that. 
02:10:07 <julianleviston> srhb: this is the bit I’m missing :)
02:10:17 <julianleviston> srhb: because I do?
02:10:23 <srhb> Uh, ok.
02:10:29 <julianleviston> srhb: sorry, not sure what you’re not understanding.
02:10:36 <srhb> I guess not. Good luck. :)
02:10:37 <julianleviston> srhb: my software changes.
02:10:50 <julianleviston> srhb: does that mean “that’s crazy! don’t do that” lol
02:11:02 <julianleviston> srhb: or is it just hard?
02:11:26 <srhb> No, no. It just seems pointless to do. The server is down for a restart because you recompiled it. Why complicate things by maiking the server "live recompile" the client afterwards, rather than just recompiling the client separately
02:11:34 <srhb> It seems like a ridiculous roundabout approach.
02:12:00 <julianleviston> srhb: no it’s not down
02:12:14 <julianleviston> srhb: there are two layers.
02:12:23 <julianleviston> srhb: sorry, I should explain more
02:12:38 <julianleviston> srhb: I have a base layer which changes *very infrequently*… then on top of that, I have code which loads from a DB…
02:13:08 <julianleviston> srhb: Pretty sure I should be able to use Hint to rebuild the second layer… but I wonder if it’ll work ok with ghcjs. And also wondering if it’ll take ages to do such things.
02:13:26 <julianleviston> srhb: or rather “interpret” the second layer. I wonder if it’ll be slow.
02:13:51 <srhb> So you're going to recompile the second layer by itself because... It's too slow to recompile the infrequent changing one?
02:14:19 <srhb> (Which, assuming modularization, won't be recompiled at all if it's unchanged.)
02:14:50 <julianleviston> srhb: oh?
02:14:51 <julianleviston> srhb: I’m not sure how else to approach it.
02:14:51 <julianleviston> srhb: I am building a cms whose data is in the shape of haskell data, and each site has different data requirements and shape.
02:15:47 <julianleviston> srhb: completely sick of rebuilding the wheel at every turn, so I want sets of “cached, precomputed data”… whech everything is effectively a function on a request, sometimes parameterised, sometimes not.
02:16:05 <julianleviston> where*
02:16:33 <srhb> I guess what you're doing is too advanced for me to really grasp it. Sorry.
02:16:48 <BernhardPosselt> why does bind require a function from a -> m b and not simply from a -> b
02:16:58 <skore_de> julianleviston: Sounds interestingly close to something I have been pondering for a while now
02:17:02 <BernhardPosselt> cant we autowrap it easily in a monad again?
02:17:13 <BernhardPosselt> using return
02:17:16 <srhb> BernhardPosselt: The point is the promise of returning it to the context.
02:17:27 <julianleviston> skore_de: I’ve spent the last few years doing it… 
02:17:29 <srhb> BernhardPosselt: By eliminating that promise, you simply don't have a Monad anymore.
02:17:49 <julianleviston> skore_de: I’ve got quite a ways through, but well, my current technology isn’t good enough, basically.
02:17:58 <srhb> BernhardPosselt: But if you do have a -> b, it's trivial to translate it into a -> m b with return, yes.
02:18:10 <BernhardPosselt> i see
02:18:13 <julianleviston> srhb: no, it’s not the speed… it’s the fact that each “site” effectivly has different code in it.
02:18:18 <skore_de> julianleviston: let me know if you want to discuss this on a separate channel
02:18:23 <julianleviston> skore_de: sure
02:18:36 <BernhardPosselt> btw, M a -> (a -> b) M b would equal a map right?
02:18:42 <liste> BernhardPosselt but "m b" can be much more than just "return (?? :: b)"
02:18:44 <BernhardPosselt> (missed an arrow)
02:19:03 <BernhardPosselt> as in
02:19:13 <BernhardPosselt> List a -> (a -> b) -> Lisb b
02:19:17 <BernhardPosselt> List*
02:19:27 <srhb> BernhardPosselt: Yes, that's fmap.
02:19:33 <srhb> :t flip fmap
02:19:34 <lambdabot> Functor f => f a -> (a -> b) -> f b
02:20:06 <BernhardPosselt> so List a -> (a -> List b) -> List b would be flatMap?
02:20:15 <bollu> question about mealy and moore: can moore be seen as special case of mealy that doesn't use the input token in it's output fn?
02:20:16 <srhb> :t concatMap
02:20:17 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
02:20:34 <srhb> :t flip concatMap
02:20:35 <lambdabot> Foldable t => t a -> (a -> [b]) -> [b]
02:20:42 <srhb> That is indeed bind for the list monad.
02:20:48 <bollu> BernhardPosselt: yes. also know as "flat map"
02:20:57 <BernhardPosselt> pieces start coming together, thanks :D
02:22:18 <BernhardPosselt> srhb: btw, about the promise: would return b instead of m b mean that b would have to be evaluated?
02:22:57 <srhb> I don't understand the question. return b is a term, m b is a type.
02:23:06 <BernhardPosselt> my bad
02:23:27 <BernhardPosselt> why is    m b   used instead of just    b
02:23:32 <BernhardPosselt> what would be the promise
02:23:52 <BernhardPosselt> or an example for it
02:24:09 <bollu> how do I simply view something with a lens?
02:24:41 <srhb> > view _2 (4,5)
02:24:42 <lambdabot>  5
02:24:44 <BernhardPosselt> is it important for Maybe for instance?
02:25:24 <bollu> is there any way to get "simpler" lens types?
02:25:35 <srhb> bollu: SimpleLens ?
02:25:43 <bollu> srhb: oh, nice
02:25:43 <quicksilver> also, you can constraint them and see if they work
02:26:00 <quicksilver> @type _2 :: Lens' (Int,Char) Char
02:26:01 <lambdabot> Functor f => (Char -> f Char) -> (Int, Char) -> f (Int, Char)
02:26:07 <quicksilver> that worked so it was right.
02:26:10 <srhb> BernhardPosselt: I'm not sure I understand your question. I suspect the answer is "that wouldn't be a monad."
02:26:37 <bollu> quicksilver: is there anyway to see the Lens' types rather than the Lens types?
02:26:40 <BernhardPosselt> srhb: BernhardPosselt: The point is the promise of returning it to the context.
02:26:54 <srhb> BernhardPosselt: Right, which is just part of being a monad.
02:27:04 <BernhardPosselt> whats the benefit of that
02:27:05 <quicksilver> bollu: well, not only do you not see the Lens' types you don't even see the Lens types...
02:27:24 <srhb> BernhardPosselt: Monads in general have no concept of "extracting" a value from a context, only the opposite.
02:27:24 <quicksilver> lambdabot replied "Functor f => (Char -> f Char) -> (Int, Char) -> f (Int, Char)
02:27:35 <bollu> quicksilver: ah
02:27:36 <quicksilver> not "Lens (Int,Char) (Int,Char) Char Char
02:27:45 <bollu> right..
02:27:48 <BernhardPosselt> srhb: but doesnt bind sorta extract the value?
02:28:08 <quicksilver> bollu: I also am interested in your question :)
02:28:11 <srhb> BernhardPosselt: Only with giant quotation marks around "sorta"
02:28:44 <quicksilver> I would like there to be a way to see the types with the synonyms in place
02:28:54 <quicksilver> like maybe GHC could have a list of synonyms to try to use to simplify output types
02:28:59 <bollu> so, does anyone know how to see the type synonyms?
02:29:00 <BernhardPosselt> srhb: well the function that i pass in gets the value as parameter right?
02:29:00 <quicksilver> but I don't know if that idea makes any sense
02:29:06 <bollu> why noy?
02:29:08 <BernhardPosselt> (a -> m b)
02:29:11 <bollu> not*
02:29:17 <srhb> BernhardPosselt: Yes, and the mechanics of bind make that possible _as long_ as you stick it back in the context.
02:29:19 <BernhardPosselt> so i can do stuff with a
02:29:32 <quicksilver> BernhardPosselt: I would say, rather than actually extracting the value, bind cunningly allows the function to work on the value without ever extracting it.
02:29:37 <tdammers> quicksilver: I wouldn't like that at all
02:29:58 <quicksilver> tdammers: well it would be an optional mode or a feature command, not something forced upon you :P
02:30:05 <tdammers> quicksilver: what if I have several type synonyms for the same type, which I use for "documentation" purposes, and GHC picks the wrong one?
02:30:18 <BernhardPosselt> cant bind automatically return it to the context?
02:30:38 <quicksilver> tdammers: yes, it would work like the default system in reverse. You'd have to specify which synonyms you wanted GHC to try to use.
02:30:38 <BernhardPosselt> ah the return
02:30:40 <tdammers> type MaybeDistance = Maybe Double; type MaybeSpeed = Maybe Double -- this kind of thing
02:30:43 <BernhardPosselt> what more can it do?
02:30:53 <quicksilver> tdammers: it wouldn't just apply all synonyms it could find.
02:31:11 <srhb> BernhardPosselt: What more can bind do?
02:31:20 <BernhardPosselt> BernhardPosselt but "m b" can be much more than just "return (?? :: b)"
02:31:20 <tdammers> well, but with both these in place, the only sensible thing would be to allow it to use both, or neither
02:31:26 <tdammers> if you allow both, it may pick the wrong one
02:32:00 <bollu> why is lens type synonym'd rather than newtype'd?
02:32:03 <tdammers> that said, if it were to somehow remember the original type synonyms you used, and infer them through the code, then it could work
02:32:05 <quicksilver> tdammers: absolutely. and in that case you'd use neither.
02:32:08 <BernhardPosselt> srhb: i mean what else could you do in a return function other than wrapping the value?
02:32:18 <quicksilver> tdammers: IIRC hugs does that.
02:32:19 <srhb> BernhardPosselt: if you have ma >>= return . f, you're really only using Functor power. ie fmap f ma
02:32:35 <tdammers> but then I'd probably be using newtypes already, if only to get better type checking
02:32:38 <srhb> scratch the "only"
02:32:44 <quicksilver> bollu: if gives better composability I believe.
02:32:58 <bollu> quicksilver: cause wrapping unwrapping?
02:33:09 <quicksilver> bollu: yes. And writing 100 instances.
02:33:24 <quicksilver> bollu: the un-newtyped versions automatically use (.) and Monoid and various other things.
02:33:25 <srhb> BernhardPosselt: Consider putStrLn :: String -> IO (). There's no way to talk about this in some way removed from the IO action, as String -> ()
02:33:43 * hackagebot moesocks 1.0.0.30 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-1.0.0.30 (JinjingWang)
02:33:52 <srhb> BernhardPosselt: The IO action part of it is inherently what it does.
02:33:59 <tdammers> speaking of GeneralizedNewtypeDeriving... I wish there was a nicer way to derive Show in such a way that it doesn't include the newtype constructor
02:34:23 <tdammers> instance Show Blah where show = show . unBlah
02:35:07 <quicksilver> but that's a terrible idea! It violates the unwritten show invariant.
02:35:21 <tdammers> not if read behaves the same way?
02:35:26 <quicksilver> yes it does.
02:35:31 <tdammers> how so
02:35:44 <quicksilver> The show invariant is that (show foo) produces a String which a haskell compiler would accept
02:35:53 <quicksilver> and that it compiles to the same value as foo
02:36:07 <fractalsea> If I build with —ghc-options with stack, does it disable ghc-options and ghc-prof-options in the cabal file?
02:36:08 <quicksilver> that's why the show instance for Data.Map takes that strange form
02:36:18 <tdammers> I believe that invariant gets violated a lot though
02:36:26 <quicksilver> FSOV "a lot", sure
02:36:30 <tdammers> heh
02:36:31 <quicksilver> there are some instances which violate it
02:36:38 <quicksilver> there are many many many which respect it
02:37:03 <quicksilver> although our module/import system isn't actually powerful enough for the Data.Map case
02:37:06 <quicksilver> stupid imports.
02:37:13 <tdammers> I never considered using `show` output for anything other than debugging, really, or maybe turning numbers into strings
02:37:35 <quicksilver> I frequnetly use it to copy-paste counterexamples
02:37:37 <quicksilver> into my tests
02:37:52 <tdammers> heh, that's not a bad idea
02:38:02 <tdammers> (still, "apply brain" involved there)
02:38:20 <quicksilver> "apply brain" is where all my haskell ideas go wrong
02:39:21 <BernhardPosselt> srhb: i see, ty
02:39:46 <srhb> BernhardPosselt: I have a feeling we're sort of dancing around the real issue, but I'm not entirely sure what it is exactly you're trying to grasp. Sorry. :)
02:40:19 <BernhardPosselt> srhb: im trying to understand why to use flatMap in java instead of map on an Optional xD
02:41:13 <BernhardPosselt> srhb: so in general just trying to understand why we need this signature for that type
02:41:49 <liste> BernardPosselt do you mean the null -> not present conversion?
02:42:13 <BernhardPosselt> liste: yep
02:42:16 <liste> that makes map and flatMap on Optional basically equivalent
02:43:27 <liste> but it really makes Optional a non-functor
02:43:48 <liste> so you can't apply the same logic to real functors (and monads)
02:45:14 <liste> > fmap (\_ -> Nothing) (Just 4)
02:45:15 <lambdabot>  Just Nothing
02:45:41 <liste> > (Just 4) >>= (\_ -> Nothing)
02:45:43 <lambdabot>  Nothing
02:46:00 <liste> in Haskell, those are different
02:48:34 <BernhardPosselt> thanks :)
02:56:07 <quicksilver> geekosaur: the mueval page says it can't do qualified imports
02:56:07 <liste> yw (:
02:56:16 <quicksilver> geekosaur: but lambdabot clearly has them
02:56:30 <quicksilver> :t M.fromList
02:56:31 <lambdabot> Ord k => [(k, a)] -> M.Map k a
02:56:57 <quicksilver> maybe mueval can't do them at the API level but you can dump them into a file called L.hs and load that and that's how lambdabot does it
03:01:11 <int-e> quicksilver: lambdabot uses mueval's -l option with a file that contains qualified imports
03:01:31 <int-e> so yes, what you just wrote
03:04:57 <quicksilver> int-e: *nod* thanks
03:07:57 * quicksilver wishes haskell had support for nesting, renaming, and re-exporting qualified
03:08:19 <montanonic> So, suppose that for some dumb reason scanl stopped after 100 recursive calls, so that its output wouldn't necessarily be infinite.
03:08:24 <montanonic> Would something like: fibs = 1 : scanl (+) 1 fibs
03:08:46 <montanonic> Still only make sense in a language that has laziness? And not make sense with strict evaluation?
03:08:59 <srhb> It would make sense in either.
03:09:35 <bollu> is moore < mealy < FSM when it comes to power?
03:09:53 <montanonic> It would? See, scanl calling fibs is the part that makes me think that it has to be lazy
03:09:57 <montanonic> because fibs is incomplete
03:10:08 <montanonic> and being created "on demand" in my mind
03:10:51 <srhb> montanonic: Them I'm unsure how you're defining strictness. It sounds like you're disallowing recursion.
03:10:59 <quicksilver> you're right, strict languages don't normally support value recursion
03:11:16 <quicksilver> if you added a dummy parameter it would work in, for example, ML
03:11:27 <quicksilver> fibs () = 1 : scanl (+) 1 (fibs ())
03:12:06 <quicksilver> and you'd need a parameter to implement your 100 recursive call limit
03:12:12 <chpatrick> is coroutines yet another free monad package?
03:12:16 <quicksilver> if you want to preserve referential transparency
03:12:16 <montanonic> hmmm, man, that value recursion screws with my head
03:12:39 <montanonic> I've seen that equation in different forms like 5 times now
03:12:49 <montanonic> And every time I see it I have to try and understand it all over again.
03:12:54 <quicksilver> fibs max_depth = 1 : scanl (+1) 1 (fibs (max_depth-1))
03:13:08 <quicksilver> is what you'd probably have to write to actually implement the depth limit
03:13:32 <montanonic> Alright, I was just curious about laziness / strictness because I was trying to understand how the call to fibs worked
03:13:33 <quicksilver> oops typo on the +1 :)
03:15:04 <montanonic> like, what's the first eval? 1 : scanl (+) 1 (1 : scanl (+) fibs)
03:15:29 <montanonic> and then it recurses again
03:15:32 <quicksilver> actually the first eval would be unwrapping the defintion of scanl
03:15:44 <montanonic> you're right, I want a different word
03:15:55 <montanonic> first "step"
03:15:56 <montanonic> maybe
03:17:08 <montanonic> 1 : scanl (+) 1 (1 : scanl (+) (1 : scanl (+) 1 (1: scanl (+) fibs)) for the second step; is this what it's actually doing?
03:17:15 <srhb> No difference. When you inspect the second cons cell you substitute in the definition of scanl
03:17:26 <montanonic> so if I wrote take 2 of fibs, that's what it'd evaluate?
03:17:28 <srhb> so it becomes 1 : definition of scanl goes here
03:18:45 * hackagebot binary-orphans 0.1.2.0 - Orphan instances for binary  https://hackage.haskell.org/package/binary-orphans-0.1.2.0 (phadej)
03:18:53 <montanonic> srhb: okay; aside from a missing 1 in the last term of what I wrote, what I wrote is incorrect then?
03:19:06 <srhb> montanonic: Yes, you never expanded the definition of scanl.
03:19:29 <montanonic> Ah, okay.
03:20:48 <bollu> :t _!
03:20:49 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
03:20:50 <bollu> :t _1
03:20:51 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
03:21:28 <John_the_beginne> hello
03:21:41 <liste> hello John!
03:22:12 <John_the_beginne> I'm trying to set up my first haskell project with cabal, and I'm getting some unusual behaviour when trying to run cabal haddock
03:23:07 <montanonic> Interesting, I'm writing it out now, expanding the terms, that makes sense of it. Thanks srhb.
03:23:08 <John_the_beginne> Configuring portfolio-analysis-0.2.0.0...
03:23:08 <John_the_beginne> Running Haddock for portfolio-analysis-0.2.0.0...
03:23:08 <John_the_beginne> Preprocessing library portfolio-analysis-0.2.0.0...
03:23:08 <John_the_beginne> haddock: No input file(s).
03:23:15 <srhb> Ok, great :)
03:23:27 <montanonic> John_the_beginne: what type of project are you creating?
03:23:31 <John_the_beginne> then it fails. Do I need to supply additional arguments to cabal haddock?
03:23:35 <montanonic> John_the_beginne: have you used or heard of stack?
03:23:46 * hackagebot calculator 0.4.1.1 - A calculator repl, with variables, functions & Mathematica like dynamic plots.  https://hackage.haskell.org/package/calculator-0.4.1.1 (sumitsahrawat)
03:23:56 <John_the_beginne> it's an executable and a library. Curently it just has hello world
03:23:59 <bollu> _1 :: (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t | what is the Field1 constraint? Cale didn't mention this the other day
03:24:26 <John_the_beginne> I heard of stack after I got a way down the route of using cabal.
03:25:16 <montanonic> John_the_beginne: gotcha, okay; I just like to recommend people who are new give it a shot because it can be a lot easier to use depending on what you're doing. Doesn't seem like it makes a difference with your particular question though.
03:25:45 <bollu> oh, I think I got it - it's a constraint defined for all tuples :) 
03:26:08 <bollu> what are the lenses over lists? 
03:26:36 <mpickering> John_the_beginne: can you paste the output of "cabal haddock -v2" please?
03:27:25 <John_the_beginne> C:\Users\John\GitHub\haskell_hl_details>cabal haddock -v2
03:27:25 <John_the_beginne> Running Haddock for portfolio-analysis-0.2.0.0...
03:27:25 <John_the_beginne> "C:\Program Files\Haskell Platform\2014.2.0.0\bin\haddock.exe" "--ghc-version"
03:27:25 <John_the_beginne> creating dist\build
03:27:25 <John_the_beginne> creating dist\build\autogen
03:27:26 <John_the_beginne> "C:\Program Files\Haskell Platform\2014.2.0.0\bin\ghc.exe" "--print-libdir"
03:27:30 <John_the_beginne> Preprocessing library portfolio-analysis-0.2.0.0...
03:27:32 <John_the_beginne> creating dist\doc\html\portfolio-analysis
03:27:34 <John_the_beginne> C:\Program Files\Haskell Platform\2014.2.0.0\bin\haddock.exe --prologue=.\dist\doc\html\portfolio-analysis\.\haddock-prolog9888.txt --dump-interface=.\dist\doc\html\portfolio-analysis\.\portfolio-analysis.haddock --optghc=-package-name --optghc=portfolio-analysis-0.2.0.0 --verbosity=1 --html --read-interface=file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1,C:\Program 
03:27:39 <John_the_beginne> Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1\base.haddock --read-interface=file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/ghc-prim-0.3.1.0,C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/ghc-prim-0.3.1.0\ghc-prim.haddock --read-interface=file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/integer-gmp-0.5.1.0,C
03:27:44 <John_the_beginne> :\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/integer-gmp-0.5.1.0\integer-gmp.haddock --odir=.\dist\doc\html\portfolio-analysis\.\ --title=portfolio-analysis-0.2.0.0: Tools for analysing performance of a share portfolio. --optghc=-fbuilding-cabal-package --optghc=-O --optghc=-outputdir --optghc=dist\build --optghc=-odir --optghc=dist\build\tmp-9888 --optghc=-hidir --optghc=dist\build\tmp-9888
03:27:49 <John_the_beginne>  --optghc=-stubdir --optghc=dist\build\tmp-9888 --optghc=-i --optghc=-idist\build --optghc=-ilib --optghc=-idist\build\autogen --optghc=-Idist\build\autogen --optghc=-Idist\build --optghc=-optP-include --optghc=-optPdist\build\autogen\cabal_macros.h --optghc=-hide-all-packages --optghc=-no-user-package-db --optghc=-package-db --optghc=C:\Users\John\GitHub\haskell_hl_details\.cabal-sandbox\x86_64-windows-ghc-7.8.3-pa
03:27:50 --- mode: ChanServ set +o quicksilver
03:27:53 <montanonic> woah woah woah
03:27:54 <John_the_beginne> ckages.conf.d --optghc=-package-id --optghc=base-4.7.0.1-7c4827d45272c6220486aa798a981cbc --optghc=-XHaskell2010 -BC:\Program Files\Haskell Platform\2014.2.0.0\lib
03:27:55 <montanonic> use lpaste
03:27:56 --- mode: quicksilver set +q John_the_beginne!*@*
03:27:57 <montanonic> please
03:28:03 <quicksilver> bah
03:28:13 --- mode: quicksilver set -q John_the_beginne!*@*
03:28:14 <mpickering> @lpaste
03:28:14 <lambdabot> Haskell pastebin: http://lpaste.net/
03:28:27 <John_the_beginne> I'm new to irc. I'll look up lpaste
03:28:30 <quicksilver> bollu: yes Field1 is just 'the typeclass for all things you could use _1 on'
03:28:46 * hackagebot digestive-functors-aeson 1.1.17 - Run digestive-functors forms against JSON  https://hackage.haskell.org/package/digestive-functors-aeson-1.1.17 (OliverCharles)
03:28:48 * hackagebot digestive-functors-aeson 1.1.18 - Run digestive-functors forms against JSON  https://hackage.haskell.org/package/digestive-functors-aeson-1.1.18 (OliverCharles)
03:28:54 <montanonic> It's okay, np. Just wanted to stop you before there was a flood :)
03:29:03 <bollu> hm, so, can I have a lens to index a list?
03:29:04 <quicksilver> bollu: there aren't many lenses over lists really. There are prisms though
03:29:09 <bollu> oh
03:29:12 <quicksilver> and traversals
03:29:16 <bollu> what do we have lists over, usually?
03:29:21 <bollu> I'll take traversal
03:29:26 <quicksilver> > [1,2,3] ^? _head
03:29:28 <lambdabot>  Just 1
03:29:40 <quicksilver> > [1,2,3] ^? ix 6
03:29:42 <lambdabot>  Nothing
03:29:51 <bollu> oh, that's.. interesting?
03:29:51 <John_the_beginne> http://lpaste.net/141978
03:29:55 <bollu> it returns a maybe?
03:30:03 <bollu> what is that? a traversal?
03:30:05 <quicksilver> ^? is an operator on traversals
03:30:20 <quicksilver> it returns the first thing it traverses, in a Just
03:30:24 <quicksilver> or Nothing if it has no items
03:30:30 --- mode: quicksilver set -o quicksilver
03:31:11 <bollu> :t ^?
03:31:12 <lambdabot> parse error on input ‘^?’
03:31:13 <quicksilver> actually works on all Folds, but Traversals (and Prisms) are also folds.
03:31:18 <bollu> :t (^?)
03:31:19 <lambdabot> s -> Getting (First a) s a -> Maybe a
03:31:24 <quicksilver> works on lenses too, since they're folds
03:31:34 <quicksilver> but lenses will never give Nothing
03:31:42 <bollu> aargh, I'm getting confused with the typeclass hierarchy now
03:31:47 <quicksilver> > ('a','b') ^? _2
03:31:47 <bollu> Traversable needs Foldable, right?
03:31:48 <lambdabot>  Just 'b'
03:31:56 <quicksilver> bollu: I'm not talking about typeclasses
03:31:59 <quicksilver> I'm talking about types.
03:32:06 <quicksilver> Lens, Fold, Traversal, Prism are types
03:32:15 <bollu> quicksilver: oh, I didn't know that
03:32:15 <quicksilver> (Foldable and Traversable are type classes)
03:32:26 <bollu> quicksilver: yeah, I thought you were talking about the typeclasses
03:32:39 <bollu> quicksilver: so, like, Traversal is a type? what's its data constructor?
03:32:52 <quicksilver> it is very similar to Lens
03:32:55 <RaceCondition> is there a way to enable TupleSections at the type level? so that (a, b) would be equivalent to (a,) b?
03:33:14 <quicksilver> it's a function with constraints
03:33:15 <bollu> and Fold?
03:33:20 <bollu> oh, go on :)
03:33:24 <quicksilver> also a function with constraints
03:33:28 <quicksilver> that's why (.) works on all of them
03:33:43 <merijn> RaceCondition: You can just write it prefix
03:33:46 * hackagebot distributed-process-simplelocalnet 0.2.3.1 - Simple zero-configuration backend for Cloud Haskell  https://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.3.1 (AlexanderVershilov)
03:33:51 <merijn> RaceCondition: i.e. "(,) a b" should be valid
03:34:04 <merijn> > ('c', True) :: (,) Char Bool
03:34:06 <lambdabot>  ('c',True)
03:34:20 <merijn> :t ('c', True) :: ((,) Char) Bool
03:34:21 <lambdabot> (Char, Bool)
03:34:26 <bollu> ohh, I thought it was because Category was defined on them
03:34:30 <quicksilver> no
03:34:34 <bollu> so, Fold is a type alias?
03:34:37 <quicksilver> yes.
03:34:48 <bollu> type aliases can have constraints?
03:34:49 <Maxdamantus> @let char = '.'
03:34:50 <lambdabot>  Defined.
03:34:56 <merijn> RaceCondition: So, no you can't get type level tuplesections, but that should cover most uses
03:34:59 <Maxdamantus> @let bool = False
03:35:01 <lambdabot>  Defined.
03:35:29 <Maxdamantus> > ('c', True) `asTypeOf` (,) char bool
03:35:30 <lambdabot>      Ambiguous occurrence ‘char’
03:35:30 <lambdabot>      It could refer to either ‘L.char’,
03:35:30 <lambdabot>                               defined at /tmp/mueval13780686242999170.hs:170:1
03:35:31 <quicksilver> bollu: yes, they can.
03:35:38 <Maxdamantus> Meh.
03:35:40 <quicksilver> bollu: the type alias for lense has a functor constraint
03:35:46 <Maxdamantus> > ('c', True) `asTypeOf` (,) L.char L.bool
03:35:47 <lambdabot>  ('c',True)
03:35:51 <RaceCondition> merijn: I see; no probs. I just wanted it to clear demonstrate how `sequence :: t (m a) -> m (t a)` also matches (a, [b]) -> [(a, b)]
03:36:02 <quicksilver> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
03:36:20 <bollu> oh, wow. okay. TIL
03:36:27 <bollu> soo fold is what?
03:36:34 <quicksilver> erm
03:36:40 <bollu> Fold :: Fold s a -> ReifiedFold s a?
03:37:18 <bollu> quicksilver: issokay, I'm guessing it's messed up or something?
03:37:32 <quicksilver> the docs say it's morally 
03:37:33 <quicksilver> type Fold s a = forall m. Monoid m => Getting m s a
03:37:38 <quicksilver> but Getting is an alias itself
03:37:41 <merijn> RaceCondition: "type Tuple = (,); type List = []" and then use prefix plus parenthesis to clarify?
03:37:49 <merijn> @define type Tuple = (,)
03:37:50 <lambdabot>  Defined.
03:37:54 <quicksilver> type Getting r s a = (a -> Const r a) -> s -> Const r s
03:37:56 <merijn> @define type List = []
03:37:57 <lambdabot>  Defined.
03:38:36 <quicksilver> so type Fold s a = forall m. Monoid m => (a -> Const m a) -> s -> Const m s
03:38:43 <merijn> :t (undefined :: (a, [b]) -> [(a, b)]) :: Tuple a (List b) -> List (Tuple a b)
03:38:44 <lambdabot> Tuple a (List b) -> List (Tuple a b)
03:38:51 <bollu> well, the Getting I understand
03:39:10 <bollu> fold returns a monoid?
03:39:15 <quicksilver> bollu: ok, well if you understand Getting, then a fold is just a getting into a Monoid
03:39:25 <quicksilver> bollu: which means if you Get lots of things you can combine them into one thing
03:39:32 <merijn> bollu: Did you see edwardk's talk on lenses yet?
03:39:34 <quicksilver> so it generalises it to get multiple things at once
03:39:36 <merijn> @where lens
03:39:36 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
03:39:44 <bollu> merijn: there's a talk?
03:39:55 <merijn> bollu: See that youtube link, like an hour and a half explaining the basics of lenses and traversals
03:39:56 <bollu> oh wow, awesome
03:40:00 <bollu> thank you
03:40:19 <bollu> why don't I live in NY? ;) That would have been awesome to attend
03:40:21 <merijn> bollu: Although it does assume things like "Const" and Applicative/Functor are easy to you
03:40:27 <bollu> quicksilver: where can you seen the implementations?
03:40:37 <bollu> merijn: eh, I grok basic haskell, so I'll give it a shot
03:40:47 <mpickering> John_the_beginne: Can you also paste your cabal file
03:40:47 <quicksilver> bollu: in the source code? or the haddocks?
03:40:54 <bollu> quicksilver: in the haddock
03:40:55 <Maxdamantus> @let (a ~> b) c = (a `asTypeOf` c) `seq` b
03:40:57 <lambdabot>  Defined.
03:40:59 <quicksilver> bollu: https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Getter.html
03:41:07 <quicksilver> bollu: not sure I understand your question :)
03:41:10 <bollu> thank you 
03:41:10 <merijn> bollu: Ok, I think Const, Identity, Functor and Applicative are the trickiest bits in there. I recommend pausing the video and working through the types on the slides by hand, though
03:41:18 <bollu> merijn: sure
03:41:31 <bollu> oh, that's very detailed docs!
03:41:35 <bollu> I didn't know that existed
03:41:42 <bollu> thanks you guys :D you're all awesome
03:42:23 <Maxdamantus> > (\a -> (succ a, [True, False])) `asTypeOf` (L.char ~> (L.char [L.bool]))
03:42:24 <lambdabot>      Couldn't match expected type ‘[Bool] -> (Char, [Bool])’
03:42:24 <lambdabot>                  with actual type ‘Char’
03:42:24 <lambdabot>      The function ‘L.char’ is applied to one argument,
03:42:25 <John_the_beginne> many thanks mpickering. Here it is: http://lpaste.net/141980
03:43:06 <mpickering> the library section has no modules listed
03:43:13 <RaceCondition> merijn: yeah
03:43:13 <mpickering> which is why no docs get generated
03:43:26 <mpickering> what are you hoping for "cabal haddock" to do?
03:43:38 <RaceCondition> I wonder why TupleSections isn't supported at the type level though; it seems like a caveat
03:43:57 <merijn> RaceCondition: Historical oversight, I think
03:44:05 <John_the_beginne> I was hoping that it would generate docs for all the files under lib
03:44:10 <merijn> RaceCondition: i.e. no one bothered to do it. I don't think it'd be especially hard
03:44:24 <John_the_beginne> or in the project.
03:44:25 <RaceCondition> for uniformity, it would make sense to have them
03:44:31 <mpickering> You need to list the modules in the library section
03:44:56 <John_the_beginne> Many thanks. I really appreciate it. 
03:45:35 <srhb> montanonic: I privmsg'ed you my short explanation anyway :)
03:45:42 <srhb> montanonic: Then you have something to compare with.
03:46:34 <bollu> question about laws
03:46:41 <bollu> how do we know that the laws are "complete"
03:46:46 <quicksilver> bollu: yes, you will go to jail if you break them
03:46:49 <bollu> and how do we know that they are "minimal"?
03:46:49 <bollu> :)
03:46:50 <quicksilver> oh, not that question.
03:47:00 <bollu> IK that haskell can't enforce the laws
03:47:02 <John_the_beginne> I added "exposed-modules: PortfolioAnalysis" and it now works. Thankyou for your help. 
03:47:12 <bollu> but, well, like I asked
03:47:28 <quicksilver> bollu: well as to whether they are complete, for what we need - we check if we can prove the things we want to be true from them
03:47:37 <quicksilver> as for if they are minimal, no idea
03:47:43 <quicksilver> not sure we even care much :)
03:47:44 <bollu> oh, okay. ty
03:47:45 <bollu> xD
03:47:57 <quicksilver> convenient forms of the laws is more important than logical minimality I'd think
03:47:58 <bollu> what would you want to prove about lens?
03:48:13 <bollu> It seems that the lens laws sort of "axiomatically" define everything you'd want a lens to be
03:48:21 <quicksilver> they do
03:48:22 <bollu> I don't see what you would care to derive from them..?
03:48:27 <quicksilver> and from that they enable certain optimisations
03:48:32 <quicksilver> 'fusing' things together
03:48:34 <bollu> oh, that's interesting
03:48:42 <quicksilver> I don't really understand that though
03:48:46 <Taneb> bollu: you can say "This thing isn't actually a lens, it does weird things"
03:48:47 * hackagebot logger 0.1.0.1 - Fast & extensible logging framework  https://hackage.haskell.org/package/logger-0.1.0.1 (danilo2)
03:48:48 <bollu> do you work on leens?
03:48:48 <quicksilver> you need edwardk or shachaf perhaps
03:48:52 <quicksilver> no
03:49:06 <quicksilver> I just started using it recently. No faith like the converted etc
03:49:08 <bollu> Taneb: by showing that it doesn't uphold the laws?
03:49:20 <Taneb> bollu: precisely
03:50:31 <bollu> :t Store
03:50:33 <lambdabot> Not in scope: data constructor ‘Store’
03:50:40 <bollu> Store is the dual of what?
03:50:41 <bollu> State?
03:50:45 <chpatrick> <3 lens
03:50:59 <bollu> store is co-<what actual object> ?
03:51:03 <bollu> Store*
03:51:06 <chpatrick> it took me a while to grok but now I use it all the time
03:51:42 <tdammers> subjectively, Haskell+Lens is a different language than plain Haskell
03:51:56 <montanonic> With regards to lens, what are sensible prerequisites to have before diving into them?
03:52:22 <montanonic> If your goal is to not just use them, but *kind of* understand them at the very least.
03:52:28 <bollu> um, what is Store?
03:52:36 <chpatrick> montanonic: RankNTypes
03:52:58 <chpatrick> and standard typeclasses like Applicative and co
03:53:01 <quicksilver> well you can understand what lenses are for and why you want them by reading twanvl's blog post
03:53:09 <quicksilver> which was based on a simpler type model
03:53:15 <quicksilver> (or many other blog posts from 5 years ago)
03:53:16 <bollu> class http://hackage.haskell.org/packages/archive/comonad/3.0/doc/html/Control-Comonad.html#t:Comonad w => ComonadStore s w 
03:53:21 <bollu> interesting
03:53:26 <quicksilver> if you want to understand the edwardk + friends implementation then
03:53:28 <quicksilver> what chpatrick said :)
03:53:43 <chpatrick> for me the main thing to grok is that 90% of the types in lens are exactly the same apart from the constraints on f
03:53:46 <bollu> so the "comonad" of Store comes from the fact that Store has comonad as a requirement?
03:53:54 <chpatrick> Lens is a Functor f => LensLike f
03:53:58 <montanonic> chpatrick: like, a lot about RankNTypes, or just the basic concept of why you need them, because I think I have that much.
03:54:06 <chpatrick> Fold is an (Applicative f, Contravariant f) => LensLike f
03:54:16 <chpatrick> Traversable is Applicative f =>
03:54:20 <chpatrick> *Traversal
03:54:53 <chpatrick> so everything in lens is basically (a -> f b) -> (s -> f t)
03:54:58 <montanonic> Contravariant is where you lost me.
03:55:05 <montanonic> Everything else I've studied at least a bit.
03:55:07 <chpatrick> so they turn an operation in some functor on a to b into an operation on s to t
03:55:20 <quicksilver> montanonic: contravariant is a functor which has the arrow the other way around in fmap
03:55:27 <bollu> chpatrick: contravariant is (a -> b) -> (f b -> f a) right?
03:55:31 <chpatrick> yes
03:55:33 <chpatrick> and depending on the properties of f you can get different kind of traversals
03:55:40 <quicksilver> but that's kind of a trick
03:55:42 <montanonic> Oh cool, thanks bollu quicksilver chpatrick 
03:55:49 <bollu> I've never seen any contravariant instance that was intuitive
03:55:49 <quicksilver> because Applicative already gives you Functor
03:55:53 <chpatrick> if it's just a Functor then you can only apply the operation once
03:56:01 <quicksilver> then you have Functor + Contravariant
03:56:10 <chpatrick> if it's Applicative you can apply multiple operations, hence Fold and Traversal operate on multiple values
03:56:11 <quicksilver> and if you have that you are *very* limited in what you can be
03:56:24 <montanonic> quicksilver: is this the reference you referred to http://twanvl.nl/blog/haskell/isomorphism-lenses ?
03:56:39 <chpatrick> if it's Applicative and Contravariant then you know that the a in f a is phantom so it's going to be read-only
03:56:44 <chpatrick> as in the case of Fold
03:56:57 <bollu> what's a nice type that implements contravariant?
03:57:18 <quicksilver> montanonic: no, although all his blog posts are a good read
03:57:25 <chpatrick> bollu: newtype FunFrom b a = FunFrom (a -> b)
03:57:41 <quicksilver> montanonic: http://www.twanvl.nl/blog/haskell/overloading-functional-references
03:57:49 <montanonic> ^thanks
03:57:50 <quicksilver> montanonic: (although in my head there is an earlier blog post even than that)
03:58:08 <fizruk> bollu: newtype Predicate a = Predicate (a -> Bool)
03:58:11 <bollu> chpatrick: lol, okay
03:58:22 <montanonic> So from what I've heard, Lens goes a step further than VH lenses?
03:58:22 <quicksilver> bollu: if you look at the type constructor (->) which makes functions
03:58:23 <bollu> chpatrick: I was looking for "useful" as well :)
03:58:30 <montanonic> Or are they just different?
03:58:34 <chpatrick> functions aren't useful? :)
03:58:36 <quicksilver> bollu: it's a functor in the right-hand-argument
03:58:37 <bollu> fizruk: oh, cool, ty!
03:58:41 <quicksilver> bollu: which is a standard instance
03:58:43 <bollu> quicksilver: whoaaa
03:58:48 <quicksilver> it's also contravariant in the left-hand-argument
03:58:54 <quicksilver> which is what chpatrick just said
03:58:56 <bollu> quicksilver, chpatrick: okay, that is _cool_
03:59:01 <quicksilver> and fizruk gave a specific example
03:59:07 <quicksilver> (special cased the right to Bool)
03:59:15 <chpatrick> the one that lens really uses is data Const a b = Const a
03:59:22 <chpatrick> which is both a Functor and Contravariant
03:59:27 <bollu> wait, so (a -> _ ) is covariant, while (_ -> b) is contra?
03:59:30 <chpatrick> which means that the b is phantom
03:59:33 <quicksilver> bollu: precisely.
03:59:42 <bollu> hm, I see
03:59:45 <quicksilver> there is even a word for that
03:59:48 <quicksilver> "profunctor"
03:59:54 <bollu> which one is profunctor?
03:59:57 <quicksilver> contra in one variable and co in the other 
03:59:59 <quicksilver> (->) is
04:00:00 <bollu> oh
04:00:02 <bollu> ah
04:00:08 <bollu> TIL.
04:00:08 * ski . o O ( "difunctor" )
04:00:21 <quicksilver> ski: was I wrong, or is that a synonym?
04:00:30 <bollu> chpatrick: shouldn't it be FuncTo b a?
04:00:35 <Taneb> quicksilver: it;
04:00:37 <chpatrick> sure if you prefer
04:00:39 <ski> "profunctor" is possibly a synonym
04:00:43 <bollu> as in, <to> b <from> a
04:00:44 <Taneb> quicksilver: it's a synonym
04:00:46 <montanonic> I've never learned about Phantoms, are they used to help fine-grain typeclass operations or something?
04:00:49 <bollu> oh, it's on how you read it
04:00:53 <quicksilver> FWIW I think profunctor is a terrible name
04:01:01 <quicksilver> I much prefer difunctor.
04:01:06 <chpatrick> montanonic: it's just a type parameter that doesn't actually appear in the data type
04:01:15 <chpatrick> data Proxy a = Proxy
04:01:17 <montanonic> that much I understand, so what makes it useful
04:01:18 <chpatrick> the a is phantom here
04:01:38 <chpatrick> well for example Const m a is Applicative if m is a Monoid
04:01:42 <fizruk> :t promap
04:01:43 <lambdabot>     Not in scope: ‘promap’
04:01:44 <lambdabot>     Perhaps you meant ‘rmap’ (imported from Control.Lens)
04:01:45 <ski> `Proxy' is both covariant and contravariant
04:01:45 <fizruk> :t dimap
04:01:47 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
04:02:04 <quicksilver> "When I wrote about coends a while back I made up a term 'difunctor'. More recently it was pointed out to me that the correct word for this concept is 'profunctor', but unfortunately my knowledge came from MacLane which mentions that word nowhere"
04:02:12 <quicksilver> that's from sigfpe so it must be true.
04:02:16 <chpatrick> so you can use Const in a traverse to get values out
04:02:22 <chpatrick> and you get foldMap for free
04:02:25 <quicksilver> I still think profunctor is a terrible name tho.
04:02:28 <chpatrick> :t traverse
04:02:29 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
04:02:44 <bollu> oh god my brain is leaking, what a weird function
04:02:45 <ski> quicksilver : i recall seeing "difunctor" way before "profunctor". possibly from some Wadler paper or something ..
04:02:49 <montanonic> chpatrick: oh, so you're saying that you can take a datatype wrapper of sorts, and add a phantom type so that it can work with Typeclasses that you want it to?
04:02:52 <chpatrick> :t traverse (\x -> Const (Sum 1))
04:02:53 <lambdabot> (Num a1, Traversable t) => t a -> Const (Sum a1) (t b)
04:02:53 <montanonic> Or something like that?
04:03:08 <chpatrick> yeah that's the idea
04:03:23 <chpatrick> or you could use it to make things more typesafe
04:03:25 <quicksilver> ski: the 'pro' prefix suggests to me something about being less than a functor or not strictly a functor. It has nothing to hint at the 2-parameter ness :(
04:03:36 <ski> yes
04:03:39 <montanonic> chpatrick: thanks!
04:03:44 <chpatrick> for example if you have some serial library you can only open in some mode
04:03:47 * hackagebot som 8.2.3 - Self-Organising Maps.  https://hackage.haskell.org/package/som-8.2.3 (AmyDeBuitleir)
04:03:50 <chpatrick> and then you can only do certain operations in certain modes
04:04:01 <chpatrick> then you could add a type parameter for the mode that you don't actually use
04:04:12 <chpatrick> data MPSSE mode = ...
04:04:14 <quicksilver> ski: mind you I always got lost in Cat theory at the number of directions you can generalise. bicategories, 2-categories etc.
04:04:18 <montanonic> ah, interesting. I can see how that's useful. Very cool.
04:04:18 <chpatrick> sendPacket :: MPSSE SPI -> ...
04:04:47 <bollu> :t traverse . traverse
04:04:48 <lambdabot> (Applicative f, Traversable t, Traversable t1) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
04:04:54 <bollu> huh
04:05:23 <bollu> > traverse.traverse Just [[1, 2], [3, 4]]
04:05:24 <lambdabot>      Couldn't match expected type ‘a -> a1 -> f b’
04:05:25 <lambdabot>                  with actual type ‘Maybe [[Integer]]’
04:05:25 <lambdabot>      Possible cause: ‘traverse’ is applied to too many arguments
04:05:29 <ski> more brackets
04:05:34 <chpatrick> some of the more advanced things in lens are also polymorphic in the profunctor
04:05:41 <bollu> ski: what?
04:05:44 <chpatrick> so it's not (a -> f b) -> (s -> f b)
04:05:47 <ski> > (traverse.traverse) Just [[0,1],[2,3,4]]
04:05:48 <lambdabot>  Just [[0,1],[2,3,4]]
04:05:52 <bollu> oh, cool
04:05:58 <bollu> that is so cool
04:05:59 <chpatrick> but p a (f b) -> p s (f t)
04:06:10 <chpatrick> so you can have lens that actually go in both directions as needed
04:06:11 <bollu> :t fold
04:06:12 <lambdabot>     Ambiguous occurrence ‘fold’
04:06:12 <lambdabot>     It could refer to either ‘L.fold’,
04:06:12 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:162:1
04:06:13 <chpatrick> for example Iso and Prism
04:06:24 <quicksilver> bollu: in ghci you can try (traverse.traverse) putStrLn [[0,1],[2,3,4]]
04:06:32 <quicksilver> bollu: I mean 'print' not 'putStrLn'
04:07:01 <quicksilver> bollu: but, that particular trick works fine without any of the lens library :)
04:07:05 <bollu> quicksilver: right
04:07:15 <quicksilver> traverse.traverse works fine with vanilla Traversable
04:07:17 <bollu> what is the basic thing needed for foldable?
04:07:19 <bollu> toList?
04:07:26 <chpatrick> foldMap
04:07:29 <quicksilver> yes, toList is sufficient
04:07:34 <chpatrick> but toList would work too
04:07:44 <montanonic> toList would make something traversable as well, yes?
04:07:48 <bollu> :t foldMap
04:07:49 <quicksilver> no
04:07:49 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:07:55 <quicksilver> montanonic: toList lets you build up a new list
04:07:59 <chpatrick> no because that wouldn't let you reconstruct the modified structure
04:08:04 <quicksilver> montanonic: for traversable you need to be able to build up a new 't'
04:08:06 <bollu> :info Foldable
04:08:10 <nolrai66> @pl \ ma pn -> Op ma (tog pn)
04:08:10 <lambdabot> (. tog) . Op
04:08:10 <quicksilver> montanonic: (whatever t you started with)
04:08:20 <ski> there is no `info' command in lambdabot
04:08:27 <montanonic> quicksilver: hmm, it appears I have more to learn then :)
04:08:30 <chpatrick> Foldable let's you get values out, Traversable let's you change the values
04:08:33 <bollu> I still think that toList is the neatest way to characaterise fold
04:08:37 <chpatrick> same for Fold and Traverse in lens
04:08:38 <ski> (also, lambdabot commands are generally prefixed by `@' (or `?', or possibly also some other character i forget))
04:08:45 <bollu> since you have an isomorphism between foldl and toList anyway
04:08:54 <chpatrick> bollu: the problem then is that you have to rely on inlining to eliminate the intermediate list
04:09:00 <chpatrick> which relies on folds internally anyway
04:09:01 <montanonic> chpatrick: functor lets you change the values, how does Traversable improve on that?
04:09:13 <bollu> montanonic: it lets you chain side effects
04:09:17 <quicksilver> bollu: so, the key difference between 'Fold/Traverse' and 'Foldable/Traversable' is that the typeclasses (the -able ones) pick a specified traversal, like the default one for that type.
04:09:42 <montanonic> bollu: I've gotten to use that much, with the FileIO exercises in NICTA
04:09:42 <quicksilver> bollu: 'Fold/Traverse' let you build + compose alternate traversals and folds than only visit some parts of a type
04:09:57 <bollu> quicksilver: because they are functions?
04:09:58 <ski> bollu : see "Free Monoids in Haskell" by dolio in 2015-02-21 at <http://comonad.com/reader/2015/free-monoids-in-haskell/>
04:10:06 <quicksilver> bollu: because they are data types not classes
04:10:15 <montanonic> interesting, I'll have to study Traversable more in depth, it sounds more fascinating than I had originally though
04:10:17 <montanonic> thought*
04:10:20 <nolrai66> (\ ma pn list -> Op ma (tog pn) list) is probably better then ((tog .) . Op), right?
04:10:31 <bollu> :t foldMap
04:10:33 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:10:37 <quicksilver> nolrai66: I would say so, but it is a matter of taste.
04:10:38 <chpatrick> :t traverse
04:10:39 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
04:10:49 <hpc> i don't know if i should be hating ixset for having such weird types, or loving it for the magic it enables
04:10:52 <chpatrick> if you set f = Const m then you get foldMap :)
04:11:10 <ski> bollu : s/side effects/effects/
04:11:15 <bollu> > foldMap (\x -> [x]) (Just 5)
04:11:17 <lambdabot>  [5]
04:11:20 <bollu> nice
04:11:35 <quicksilver> it's worth pointing out that Const m is a bit like the Writer m applicative
04:11:41 <quicksilver> except it promises never to return a value
04:11:44 <hpc> > foldMap (\x -> [x]) Nothing
04:11:46 <lambdabot>  []
04:11:47 <bollu> @let toList = foldMap (\x -> [x])
04:11:49 <quicksilver> it's *only* the part that accumulates log messages
04:11:50 <hpc> oh right
04:11:50 <lambdabot>  Defined.
04:11:54 <bollu> :t toList
04:11:55 <lambdabot>     Ambiguous occurrence ‘toList’
04:11:55 <lambdabot>     It could refer to either ‘L.toList’,
04:11:55 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:176:1
04:12:03 <hpc> @undefine
04:12:03 <lambdabot> Undefined.
04:12:12 <hpc> @let convert = foldMap return
04:12:13 <quicksilver> and if your 'log message' is just the value at that place in the traversal
04:12:13 <lambdabot>  Defined.
04:12:16 <hpc> :t convert
04:12:16 <montanonic> chpatrick: wait, that's hilarious. Doesn't that just wrap up the value?
04:12:17 <lambdabot> (Monad m, Foldable t, Monoid (m a)) => t a -> m a
04:12:17 <quicksilver> then you accumulate them all
04:12:21 <quicksilver> and that's how a fold is a traversal
04:12:25 <hpc> > convert (Just 5) :: [Int]
04:12:27 <lambdabot>  [5]
04:12:33 <montanonic> What's the def of Const again?
04:12:40 <montanonic> I don't know how to query LB on that
04:12:45 <quicksilver> montanonic: Const b a is just a value of type 'b' yes
04:12:47 <hpc> data Const a b = Const a
04:12:59 <quicksilver> to be concrete a value of type "Const Int Char" is just an Int
04:13:01 <quicksilver> wrapped up.
04:13:04 <chpatrick> montanonic: it wraps up a different value
04:13:13 <ski> > (traverse . traverse) (\n -> if odd n then [n,-n] else [n]) [[0,1],[2,3,4]]
04:13:14 <lambdabot>  [[[0,1],[2,3,4]],[[0,1],[2,-3,4]],[[0,-1],[2,3,4]],[[0,-1],[2,-3,4]]]
04:13:52 <mpickering> data Const a b = Const a
04:13:58 <montanonic> hmmm, that's interesting; so phantom type Const with Monoid m gives you monoid properties, and so you can use it with flatMap
04:14:07 <montanonic> that seems funny to me
04:14:11 <chpatrick> traverse you mean
04:14:16 <bollu1> @let _toList = foldMap (\x -> [x])
04:14:17 <lambdabot>  Defined.
04:14:20 <ski> montanonic : that nondeterministically replaces the odd elements with either themselves, or their negation. there's four possible global solutions, since there were two odd elements
04:15:15 <ski> @hoogle Const
04:15:15 <lambdabot> Control.Applicative Const :: a -> Const a b
04:15:15 <lambdabot> Control.Applicative newtype Const a b
04:15:15 <lambdabot> Data.Data data Constr
04:15:21 <ski> montanonic ^
04:15:23 <montanonic> ski: what a funky function
04:15:31 <montanonic> ski: the traverse. traverse; cool stuff
04:16:00 <ski> the `traverse . traverse' just "selects" the elements of the elements of the whole list to work on
04:17:21 <bollu> ski: isn't it like the first traverse picks the list, and the second traverse picks elements of the list?
04:17:30 <bollu> thereby allowing you go "two levels deep" ?
04:18:29 <bollu> Functor == Traversable with Identity applicative
04:18:32 <bollu> :t fmap
04:18:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:18:35 <bollu> :t traverse
04:18:36 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
04:18:41 <bollu> hm, right
04:18:43 <bollu> neat
04:19:34 <quicksilver> > (traverse . _Left) (\n -> [n,n]) [Left 1, Right 2, Left 3, Right 4]
04:19:35 <lambdabot>  [[Left 1,Right 2,Left 3,Right 4],[Left 1,Right 2,Left 3,Right 4],[Left 1,Rig...
04:20:17 <bollu> oh, wait, so if I have a traversable on t
04:20:23 <bollu> then I have a functor on *t* ?
04:20:31 <chpatrick> yes
04:20:33 <bollu> ahh
04:20:37 <bollu> that is non-trivial
04:20:47 <bollu> lol, I don't know what I was thinking ^_^
04:20:48 <merijn> bollu: Functor is a superclass of Traversable
04:20:59 <merijn> bollu: "class Functor f => Traversable f"
04:21:09 <chpatrick> fmap = traverse with Identity
04:21:17 <joco42> are the existential types and sum types somehow similar? they seem to me a little bit similar, or is it just me? what do you think? what is the main difference between them? they both seem to bring differnt types under one big umbrella... but in slightly(?) different way
04:21:18 <bollu> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b) <- doesn't seem like it?
04:21:24 <merijn> Actually, I think it's class Functor f => Foldable f" and "class Foldable f => Traversable f", but you get the idea
04:21:30 <chpatrick> bollu: set f = Identity
04:21:40 <bollu> chpatrick: no, what I was saying was
04:21:50 <joco42> any thoughts on this?
04:22:21 <bollu> IF (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b), then, Applicative Identity t => Functor t ?
04:22:31 <merijn> :t \f -> runIdentity . traverse (Identity . f)
04:22:32 <bollu> so, like, t was a traversable (with no functor structure)
04:22:32 <lambdabot> Traversable t => (a -> b) -> t a -> t b
04:22:56 <bollu> merijn: the way I'm seeing it is, for any traversable, we get a functor instance. Is that correct?
04:23:01 <chpatrick> yes
04:23:17 <bollu> so traversable is more powerful than functor
04:23:23 <merijn> bollu: Traversable is more powerful than Functor, so yes. The Traversable methods lets you implement fmap
04:23:33 <bollu> okay, cool
04:23:44 <bollu> but to get Traversable, we need some other unrelated Functor
04:23:53 <merijn> bollu: Applicative
04:23:57 <bollu> oh, right
04:23:59 <bollu> okay
04:24:05 <bollu> hmm
04:24:07 <bollu> that is cool
04:24:17 <bollu> Also, why does Applicative f need functor f?
04:24:40 <bollu> what do I call a type with just <*> but no <$> (hypothetically) ?
04:24:47 <merijn> bollu: If you think of lists "traverse f (x:xs) = (:) <$> f x <*> traverse f xs
04:24:48 <tero-> why doesn't hoogle find yesod's functions?
04:24:59 <merijn> tero-: Hoogle only indexes a part of hackage
04:25:07 <merijn> tero-: FPComplete's hoogle is more complete
04:25:18 <hpc> bollu: you're ignorint pure
04:25:20 <tero-> merijn: ok. I'll try it
04:25:26 <bollu> hpc: oh
04:25:33 <hpc> and if you have (<*>) and pure, you have (<$>)
04:25:35 <montanonic> tero-: try Hayoo or Stackage
04:25:38 <merijn> bollu: If your type has "pure" You can get fmap for free
04:25:40 <hpc> thanks to the applicative laws
04:25:42 <bollu> hpc: ah. 
04:25:48 <hpc> which are only defined in terms of both (<*>) and pure
04:25:48 <merijn> bollu: "fmap f x = pure f <*> x"
04:25:49 <bollu> :t pure
04:25:50 <lambdabot> Applicative f => a -> f a
04:25:55 <bollu> aww, I wanted to find that out :)
04:26:06 <bollu> hm
04:26:09 <tero-> montanonic: will do
04:26:09 <hpc> heh
04:26:12 <bollu> so we say Functor f => Applicative f why?
04:26:28 <bollu> it's not like, applicative *needs* functor, right?
04:26:46 <bollu> it's more like, every applicative *is* a functor?
04:27:00 <merijn> bollu: Right
04:27:09 <merijn> bollu: Applicative is "more powerful" than Functor
04:27:29 <merijn> bollu: So it's impossible to be an Applicative without also being a Functor
04:27:34 <hpc> specifically, applicative is less general and enables more operations
04:27:34 <bollu> so, shouldn't it be something like class Functor f where … | Applicative f => Functor f where … | 
04:27:44 <merijn> bollu: Whereas you can be a functor that can't be an Applicative
04:27:50 <bollu> oh, right
04:28:16 <merijn> bollu: For example, "Const a" is not a Functor, but not an Applicative without extra constraint on 'a'
04:28:28 <bollu> right
04:28:33 <bollu> ah, now it's coming together
04:28:41 <bollu> thanks :)
04:29:08 <fizruk> merijn: Const a *is* a functor, right?
04:29:19 <merijn> fizruk: eh, yes, typo :)
04:29:52 <hpc> and you can see why by tring to write pure :: b -> Const a b
04:30:08 <mpickering> Is there a way to get ":r" to reload all library modules when using "cabal repl test"
04:30:13 <mpickering> it only reloads test modules
04:30:27 <bollu> :t over
04:30:28 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
04:30:29 <bernalex> anyone with wiki access that could do a quick edit for me?
04:30:33 <bollu> tch
04:33:44 <mpickering> bernalex: Sure
04:34:21 <bernalex> mpickering: https://wiki.haskell.org/User_groups#Norway -- would you terribly mind adding Trondheim Haskell Users' Group here? link: http://www.meetup.com/Trondheim-Haskell-Users-Group/
04:34:24 <bernalex> mpickering: about text: A Haskell users' group in the Trondheim area. For seasoned veterans, complete newbies who only heard of Haskell two minutes ago, and everyone in between and beyond. We meet and talk about Haskell and anything else members are interested in.
04:34:41 <bollu> ^. is over?
04:34:55 <quicksilver> yes
04:35:05 <merijn> Isn't it view?
04:35:11 <bennofs> it's view
04:35:16 <quicksilver> oops
04:35:20 <quicksilver> .~ is over
04:35:24 <fizruk> :t over
04:35:25 <bennofs> quicksilver: no, %~ is over
04:35:26 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
04:35:29 <quicksilver> gah
04:35:31 <fizruk> :t (.~)
04:35:32 <lambdabot> ASetter s t a b -> b -> s -> t
04:35:35 * quicksilver gives up :)
04:35:36 <fizruk> :t (%~)
04:35:37 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
04:35:40 <fizruk> ^
04:35:50 <fizruk> bollu: (%~) is over
04:36:15 <bollu> wait, why is it called "over" ?
04:36:19 <bollu> over is the setter?
04:36:20 <mpickering> bernalex: done
04:36:22 <bollu> no, over is the getter
04:36:26 <bollu> set is the setter?
04:36:27 <bernalex> mpickering: ta ever so much!
04:36:33 <quicksilver> over is the modifier
04:36:41 <quicksilver> it modifies a value 'over' a traversal
04:36:45 <bollu> so there is no set?
04:36:46 <quicksilver> (or other Setting thing)
04:36:57 <bennofs> bollu: over = "map function 'over' the value viewed by the lens (=> modify)"
04:36:57 <quicksilver> .~ is the 'set'
04:37:32 <fizruk> > (2, 3) & _1 %~ (+1)
04:37:33 <bollu> what is the diffrence?
04:37:33 <lambdabot>  (3,3)
04:37:44 <bollu> oh, over takes a function while set takes a value?
04:37:47 <bennofs> bollu: yes
04:37:51 <bollu> ahh
04:37:54 <bennofs> bollu: set l x = over l (const x)
04:38:07 <bollu> bennofs: that helps a ton
04:38:49 * hackagebot OpenGLRaw 2.5.5.0 - A raw binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGLRaw-2.5.5.0 (SvenPanne)
04:41:59 <joco42> in this post https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ what is the "data AnyWidget = forall w. Widget w => AnyWidget w" ? from which extension does that come from? what does it do?  this does not offer much help : https://wiki.haskell.org/Data_declaration_with_constraint
04:42:27 <quicksilver> joco42: that wiki page is indeed not what it is
04:42:30 <merijn> joco42: That's ExistentialQuantification
04:42:38 <merijn> Hence "Existential antipattern"
04:42:48 <chpatrick> joco42: although these days I would use a GADT
04:42:51 <quicksilver> joco42: try this one - https://wiki.haskell.org/Existential_type
04:42:54 <chpatrick> not that you should use anything in this case :)
04:43:15 <joco42> cool , thanks
04:44:11 <joco42> does the "data AnyWidget = forall w. Widget w => AnyWidget w" say that w is always a Widget ?
04:44:26 <joco42> inside AnyWidget?
04:44:48 <quicksilver> it says w is some type which is amamber of Widget
04:44:51 <quicksilver> but you don't know which one
04:45:16 <joco42> ok that makes sense
04:45:33 <quicksilver> this kind of thing often comes from an attempt to convert 'java classes' to 'haskell typeclasses' and then implement subtyping with an existential like that
04:45:40 <joco42> so it basically does this https://wiki.haskell.org/Data_declaration_with_constraint right?
04:45:48 <quicksilver> no
04:45:53 <quicksilver> that is something totally different
04:45:57 <joco42> i mean it constrains w to be a Widget
04:45:59 <joco42> no?
04:46:00 <quicksilver> it's annoying how similar the syntax is but it's quite different
04:46:08 <joco42> hmm
04:46:18 <merijn> The data constraint doesn't actually *do* anything
04:46:25 <merijn> Hence why they are dumb and deleted from the language
04:46:32 <joco42> aham
04:46:51 <joco42> ok , so that data constraint is some obsolete stuff
04:47:12 <merijn> joco42: With the data constraint your functions still need constraints to work
04:47:40 <merijn> joco42: Also, with data constraint the constraint variable is visible in the type, with the existential one you can't "see" the 'w' in the type
04:47:41 <quicksilver> the data constraint was a misfeature in the language which never really worked properly anyway
04:47:56 <merijn> It worked properly, it just didn't do what beginners expect :p
04:48:01 <joco42> ok cool
04:48:21 <quicksilver> merijn: no, it was useless - it didn't achieve what the designers imagined it acheived.
04:48:42 <quicksilver> not until GADTs came along did we have working constraints on constructors
04:48:43 <merijn> quicksilver: In what way? The idea was to restrict datatypes and it did just that
04:48:52 <joco42> good to know
04:48:59 <quicksilver> but, even then, it isn't actually a feature which is advisable very often
04:49:10 <quicksilver> merijn: it restricts the data type without providing a proof to the compiler
04:49:10 <joco42> it is just some confusing historical thing
04:49:19 <merijn> GADTs just includes ExistentialQuantification
04:49:24 <quicksilver> merijn: so you might "know" that Foos are always Ord because of the constraint
04:49:25 <merijn> They are literally the same thing
04:49:41 <quicksilver> merijn: but you can't actually use the Ord instance on an unpacked Foo
04:49:43 <quicksilver> so it's useless.
04:50:05 <quicksilver> GADTs support both of these things
04:50:14 <quicksilver> existentials *and* non-existential constraints on constructors
04:50:40 <joco42> so GADT's are a good and useful extension to learn?
04:50:58 <quicksilver> they are different things - as merijn pointed out, not being able to see the w in the type is the big difference between the two
04:51:05 <quicksilver> GADTs are definitely worth learning about.
04:51:27 <joco42> ok, cool
04:51:35 <joco42> i read about it
04:55:08 <merijn> The GADT wikibook is pretty good
04:56:03 <joco> i have a look ath that
04:56:17 <joco> and maybe i re watch adventures with types...
04:56:29 <joco> SPJ
04:58:54 <fractalsea> My program is allocating a lot of memory when it uses cereal’s toByteString function. Is there any way to reduce the number of allocations, other than representing my data as a raw bytestring internally?
04:59:53 <merijn> fractalsea: cereal uses strict ByteString, so why *wouldn't* serialising it allocate a lot of memory?
05:01:06 <fractalsea> merijn, I understand that it does allocate a lot of memory. I’m just wondering if there alternative approaches to using cereal..
05:01:21 <merijn> binary serialises to lazy ByteString
05:01:36 <Apocalisp> shachaf: This SE question was very illuminating regarding the question of adjoint functors forming the reader monad http://math.stackexchange.com/questions/1274989/what-is-the-eilenberg-moore-category-of-this-diagonal-like-monad
05:03:35 <fractalsea> OK, and I’m still not clear on why a lazy bytestring would help. Does it serialise a datastructure into the same portion of memory, overwriting parts of the serialised structure that has already been read?
05:04:12 <merijn> fractalsea: It doesn't build the bytestring until it gets consumed, meaning you can "stream" the serialisation
05:04:27 <merijn> You can also look into pipes/conduit for doing streaming serialisation
05:04:36 <fractalsea> merijn, ah interesting
05:05:03 <fractalsea> merijn. Well I will switch to binary serialisation for now and see if that helps
05:05:57 <fractalsea> Oh cereal does have an `encodeLazy` function, so I will give that a go
05:06:01 <fractalsea> Thank you for your help
05:08:50 * hackagebot nix-eval 0.1.0.0 - Evaluate Haskell expressions using Nix to get packages  https://hackage.haskell.org/package/nix-eval-0.1.0.0 (chriswarbo)
05:11:48 <firstglitch> After I upload a package candidate to Hackage, will it be possible to install by running cabal install?
05:12:14 <dcoutts> firstglitch: yes, but you need to run "cabal update" first.
05:13:29 <firstglitch> dcoutts: Cabal update takes so long to complete (I am running it in a VM). Is there any way to speed that up?
05:14:18 <dcoutts> firstglitch: not yet. The next cabal release will include download security and incremental index download.
05:15:16 <dcoutts> firstglitch: though you can run a proxy or mirror, which might speed things up, if it's really critical
05:18:20 <firstglitch> dcoutts: Can I post the package link here to request a quick review?
05:18:52 <dcoutts> firstglitch: sure, but ask the channel generally, not me, I don't have time right now
05:19:07 <firstglitch> dcoutts: Yes. That is what I meant.
05:19:59 <bennofs> Hmm, cabal supports installation of package candidates now? cool
05:21:10 <dcoutts> oh does it?
05:21:32 <bennofs> I thought that was what you just said? :o
05:21:34 <dcoutts> bennofs: it does by explicit http url, anything else?
05:22:12 <dcoutts> ohhh, I misread what firstglitch said
05:22:31 <dcoutts> firstglitch: sorry, no, candidates are candidates, they don't appear in the main index
05:22:53 <dcoutts> but you can get people to try them by giving an explicit url to the tarball
05:23:00 <firstglitch> I have just uploaded a Haskell program to download subtitles, as a package candidate to Hackage. This is the package page at Hackage https://hackage.haskell.org/package/hastily-0.1.0.0/candidate. Can someone take a quick look at the code and the package page to check if I am doing something wrong? Here is the bitbucket repo. https://bitbucket.org/sras/hastily
05:23:21 <dcoutts> ie cabal install https://hackage.haskell.org/package/hastily-0.1.0.0/candidate/hastily-0.1.0.0.tar.gz
05:23:40 <dcoutts> (or http if you're using an older cabal that doesn't support https)
05:24:06 <firstglitch> dcoutts: Oh. I see. 
05:25:16 <bennofs> firstglitch: if you add README.md to extra-source-files in your .cabal, it will appear on hackage as well
05:26:03 <bennofs> firstglitch: like https://hackage.haskell.org/package/hcltest-0.3.8/candidate#readme for example
05:26:04 <firstglitch> bennofs: Oh. Cool. I will do that.
05:30:21 <fractalsea> merijn, I switched to using runPutLazy from cereal instead of runPut. The memory foot seems less initially, but then I now get a memory leak. I’m sending the data to sendAll from Network.Socket.ByteString.Lazy. I’m assuming that the send is not executaed on all the data, is there any way to force this to happen?
05:31:24 <RageYL> hi
05:32:03 <RageYL> how would you make a c-like parser (i have predefined structure that i want to read) in haskell ?
05:32:38 <dcoutts> RageYL: I'd use a happy parser for anything as complex a C
05:32:47 <dcoutts> e.g. the language-c package
05:32:54 <RageYL> i mean i don't want to write a parser for c
05:33:03 <RageYL> i would like to parse a file format
05:33:14 <RageYL> *binary file format
05:33:25 <dcoutts> oh, then try the binary library
05:33:52 <RageYL> do you think is it a good/bad idea to do something like that in haskell ?
05:34:30 <tdammers> haskell is very suitable for writing parsers, so probably yes
05:34:35 <dcoutts> if you've got an externally specified binary format, then there's not a lot you can do about that, you have to deal with it
05:35:20 <RageYL> kk thanks ;). i'm going to take a look at the binar library
05:35:27 <dcoutts> RageYL: but if you have a choice of the format then there's easier things
05:35:53 <RageYL> no for example it would be for creating a elf parser or stuff like that
05:36:02 <merijn> RageYL: Use the binary library
05:36:03 <RageYL> so i don't have the choice of the format
05:36:13 <danza> sorry, can anybody explain me what does this syntax with curly braces mean? https://github.com/snoyberg/haskellers/blob/master/Handler/Job.hs#L27-L29 i do nor recognise it, i am a bit lost
05:36:42 <quicksilver> danza: it's "record notation"
05:36:57 <merijn> RageYL: It's pretty straightforward, one warning, don't use the Binary class for existing formats, it introduces it's own stuff into the resulting binary data, just use Data.Binary.Put and Data.Binary.Get directly
05:37:08 <danza> quicksilver, yes, now i recall, it was so obvious! thanks a lot!
05:37:14 <dcoutts> RageYL: so the binary lib is primarily aimed at reading in contiguous chunks of data, so if you have to chase pointers within the format you'd need to use some extra stuff on top of what the binary lib gives you
05:37:35 <RageYL> ok
05:37:44 <dcoutts> RageYL: and of course ELF has a mixture, tables of data but then pointers to other parts of the file.
05:40:33 <nomeata> Hi. Have people tried to use criterion to measure the performance of an external process?
05:41:03 <nomeata> (I’m currently very annoyed by the noise in nofibs performance numbers, and wonder if it makes sense to replace the nofib benchmark runner by something using criterion.)
05:41:17 <quicksilver> nomeata: criterion's main focus was accurately timing very small things; the overhead of fork() and exec() would not really be very small
05:41:30 <quicksilver> might still work tho?
05:41:40 <nomeata> right, that’s why I’m asking if someone has tried it before.
05:48:53 <bennofs> nomeata: at least with new criterion versions, I believe that I've observed that results get more and more inaccurrate as the tests take longer (since criterion will take less samples in these cases i think)
05:50:01 <firstglitch> I just deleted  a package candidate from Hackage. But cabal can still install the package using the old url to tar.gz package file. How can I force cabal to download the file again?
05:50:31 <aweinstock> firstglitch: cabal update?
05:51:02 <firstglitch> aweinstock: it is a package candidate.
05:51:02 <bennofs> aweinstock, firstglitch: cabal update probably won't help when using http url to install packages
05:51:33 <bennofs> firstglitch: are you sure that cabal is not re-downloading it? Perhaps the hackage server just still has your .tar.gz ?
05:52:22 <bennofs> firstglitch: right, I can still download the .tar.gz for your package from hackage
05:52:30 <firstglitch> bennofs: indeed. I can still downlaod it.
05:53:22 <bennofs> firstglitch: hmm, even the candidate package is still accessible: https://hackage.haskell.org/package/hastily-0.1.0.0/candidate
05:53:27 <firstglitch> bennofs: the problem I am facing is that  I have made a small change (Added an import for Data.Functor), but it is not getting updated at Hackage.
05:53:51 <bennofs> firstglitch: I think you can just re-upload the package and it should replace the old candidate on hackage
05:54:16 <firstglitch> bennofs: I tried it.
05:54:41 <fractalsea> This is the series of functions I apply to some data `Serialize a => [a]`. `Network.Socket.ByteString.Lazy.sendAll . toLazyByteString . mconcat . map . fromLazyByteString . runPutLazy . put`. If I replace `fromLazyByteString . runPutLazy`  with `fromByteString . runPut` I get a memory leak. Why would this be?
05:54:42 <bennofs> firstglitch: oh, it does show the readme now
05:54:58 <firstglitch> But the file is not getting updated. I tried deleting the local tar.gz file and rebuild it usign stack sdist. And reuploaded the file.
05:55:00 <fractalsea> That’s using teh cereal library.
05:55:18 <firstglitch> bennofs: Yes. I added readme to the .cabal file.
05:56:03 <firstglitch> bennofs: I think I will just bump the version number and try again.
05:56:09 <fractalsea> Sorry should have been  `map (fromLazyByteString . runPutLazy . put)`
06:01:26 <julianleviston> did backpack get any traction?
06:01:32 <julianleviston> as a module system?
06:01:41 <quicksilver> it's still being worked on
06:01:47 <julianleviston> ah ok
06:01:47 <quicksilver> I don't think it has any traction yet
06:02:14 <quicksilver> julianleviston: https://ghc.haskell.org/trac/ghc/wiki/Status/GHC-8.0.1
06:02:17 <julianleviston> it’s one part of the “new styles” of approaches to cleaning up the whole cabal / packages / everything stuff?
06:02:20 <quicksilver> very very brief mention there
06:02:24 <julianleviston> ah cool
06:03:20 <julianleviston> is GHC usually fairly accurate in its anticipated estimates?
06:04:12 <merijn> julianleviston: Depends on whether there's crucial bugs/blocking things discovered last minute
06:04:20 <quicksilver> have you ever met a software team which was?
06:04:26 <quicksilver> let alone a volunteer open source one?
06:04:27 <quicksilver> :)
06:04:29 <merijn> julianleviston: Usually pretty regular, the whole 7.6 OSX/clang debacle notwithstanding
06:05:29 <haskell439> Need some help with how to check that my lists in a list contains 9 elements: http://lpaste.net/2727985715420856320
06:05:33 <frerich> quicksilver: Projects which do time-based releases (e.g. Firefox) tend to be fairly reliable in that respect.
06:05:50 <quicksilver> frerich: it was only a quip :)
06:06:12 <frerich> quicksilver: Damn, there goes my once-in-a-month moment where I know something!
06:06:23 <quicksilver> haskell439: ((==9).length)
06:06:29 <quicksilver> haskell439: instead of (length == 9)
06:06:37 <quicksilver> but... it is probably good to understand why it works, too :)
06:06:38 <haskell439> quicksilver: Thanks!
06:07:05 <quicksilver> (\l -> length l == 9)
06:07:14 <quicksilver> ^^ possibly more readable and closer to what you were thinking (?)
06:07:53 <haskell439> quicksilver: probably, I have not seen anything like ((==9).length) before
06:08:04 <haskell439> I think atleast
06:08:34 <quicksilver> length is a function which takes in lists and spits out numbers
06:08:52 <quicksilver> (==9) is a function which takes in numbers and spits out 'True' or 'False' (depending if they equal 9)
06:08:53 * hackagebot patches-vector 0.1.0.0 - A library for patches (diffs) on vectors, composable and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.0.0 (LiamOConnorDavis)
06:09:04 <quicksilver> so (==9).length combines those two functions.
06:09:17 <quicksilver> > length "hello"
06:09:19 <lambdabot>  5
06:09:22 <quicksilver> > (==9) 5
06:09:24 <lambdabot>  False
06:09:34 <quicksilver> > ( (==9) . length ) "hello"
06:09:36 <julianleviston> quicksilver: he hask’t seen function composition, possibly.
06:09:37 <lambdabot>  False
06:09:55 <quicksilver> quite possibly yes.
06:10:18 <theme2> > (==9) 9
06:10:20 <lambdabot>  True
06:10:24 <theme2> > (==9) 8
06:10:28 <lambdabot>  False
06:10:34 <quicksilver> theme2: magic isnt' it?
06:10:38 <theme2> quicksilver, that is called "sections" IIRC
06:10:43 <quicksilver> yes.
06:10:44 <julianleviston> tis
06:12:39 <theme2> I got into some weird mess with cabal and just reinstalled cabal-install
06:13:03 <theme2> and when I typed "cabal" into bash, it says "/home/theme/.local/bin/cabal: No such file or directory"
06:13:13 <theme2> what can that possibly mean?
06:14:06 <int-e> theme2: you probably have a file .local/bin/cabal  that is not executable for whatever reason, for example due to a missing shared library
06:14:07 <danza> theme2, does that happen also in a new terminal?
06:14:53 <theme2> danza, nope
06:14:53 <theme2> lol
06:14:55 <theme2> thanks
06:15:01 <theme2> weird
06:15:11 <int-e> or... it was a cached location (hash -r usually solves *that* problem)
06:15:42 <julianleviston> os a non-updated bashrc or somesuch
06:15:47 <julianleviston> or*
06:15:59 <danza> theme2, yeah, weird ... maybe the new executable was installed elsewhere, while somehow the terminal had the previous location cached
06:17:12 <int-e> danza: fwiw, "terminal" is a bit confusing, bash is a shell.
06:17:54 <tdammers> s/a bit confusing/wrong/ ;)
06:19:34 <haskell439> Is (==5)(length "Hello") equivalent to ((==5).length) "Hello"
06:20:13 <int-e> tdammers: well to be fair, the things we tend to call terminals these days are actually terminal emulators ;)
06:20:19 <danza> int-e, tdammers, yeah sorry, it is called terminal in Mac OS, meaning "terminal emulator"
06:20:19 <julianleviston> >  (==5)(length "Hello")
06:20:21 <lambdabot>  True
06:20:25 <bollu1> haskell439: do you know the definition of (.) ? you can derive if they are equal or not :)
06:21:04 <tdammers> int-e: yeah, but calling a terminal emulator a terminal is "less wrong" than calling a shell a terminal
06:21:12 <haskell439> bollu1: if you the function f(g(x)), then you can use dot, to seperate them f.g(x) right?
06:21:30 <tdammers> because to large parts of the system, the terminal emulator *is* a terminal
06:21:32 <julianleviston> @src (.)
06:21:32 <lambdabot> (f . g) x = f (g x)
06:21:33 <tdammers> but the shell never is
06:21:50 <julianleviston> haskell439: that answer your question?
06:22:21 <haskell439> julianleviston: yes, thanks!
06:22:37 <julianleviston> (length . count) [1,2,3] == length (count [1,2,3])
06:23:18 <julianleviston> haskell439: what you’re doing in the first is “building a new function” and applying it. In the second, you’re applying two functions one to the others’ result.
06:23:41 <julianleviston> haskell439: they happen to be equivalent because of the way (.) is defined.
06:24:50 <julianleviston> haskell439: the cool thing about (.) is you can define countLength = (length.count) as a new function, then go around “countLength”ing all kinds of lists.
06:25:25 <julianleviston> oh god
06:25:29 <julianleviston> my brain.
06:25:41 <julianleviston> haskell439: sorry, there’s no such thing as count. lol.
06:26:02 <julianleviston> haskell439: I really should take my own advice and run my own code before I show it. :)
06:26:49 <haskell439> julianleviston: I think a have a good picture on how you use the dot
06:26:56 <tdammers> another cool thing about (.) is that it's just another function, so you can pass it to things like foldl
06:27:02 <julianleviston> haskell439: :) that’s the main thing :)
06:29:14 <haskell439> What is the \l called in the expression: \l -> length l == 9, because that is also something that is new to me, and just gooling for / and haskell dosent give me any good results
06:29:34 <srhb> haskell439: It's lambda syntax. So l is the argument
06:29:49 <tdammers> the \l on its own isn't anything at all; \l -> length l == 9 as a whole is a lambda
06:30:02 <tdammers> \arg -> expr
06:30:04 <srhb> haskell439: \a b c -> ... -- is a lambda (unnamed) function with three arguments, a b and c
06:30:05 <fizruk> haskell439: \ is λ
06:30:06 <tdammers> is the general form
06:31:54 <cow_2001> i can't cabal install stack :(
06:32:27 <julianleviston> haskell439: (\x -> x + 1) == (+1)
06:32:32 <fizruk> cow_2001: do you need to? what os are you on?
06:32:41 <cow_2001> some ubuntu
06:33:06 <cow_2001> it complains about stm having some bad type signature
06:33:11 <haskell439> ahh, so if I understand it correctly , the \ is just pointing out that its a lambda expression, after which we have a number of arguments, to which we apply some function
06:33:12 <cow_2001> something about mkweak
06:33:13 <fizruk> cow_2001: please, follow this instructions: https://github.com/commercialhaskell/stack/blob/master/doc/install_and_upgrade.md#ubuntu
06:33:21 <julianleviston> haskell439: yep
06:33:23 <bollu> haskell439: yep. 
06:33:30 <cow_2001> fizruk: it's 32 bit
06:33:36 <cow_2001> fizruk: not 64
06:33:38 <bollu> haskell439: in the original lambda calculus notation, it was \x.\y.x+y IIRC
06:33:40 <julianleviston> haskell439: or at least, the stuff to the right defines the function
06:33:44 <cow_2001> oh wait
06:33:53 <bollu> haskell439: you separated the body from the arguments with a "."
06:34:03 <fizruk> cow_2001: okay, follow general Linux instructions then
06:34:17 <julianleviston> haskell439: why are you telling s/him old syntax?
06:34:17 <fizruk> cow_2001: https://github.com/commercialhaskell/stack/blob/master/doc/install_and_upgrade.md#linux
06:34:48 <julianleviston> bollu: sorry, I meant why are *you* telling s/him old syntax?
06:34:52 <julianleviston> bollu: not an actual question.
06:35:04 <cow_2001> fizruk: thanks!
06:35:26 <bollu> julianleviston: because it might help when he goes to read literature :)
06:35:27 <fizruk> cow_2001: you're welcome!
06:35:41 <bollu> julianleviston: and, like, every lambda calculus book I've seen uses it
06:36:00 <BernhardPosselt> hi i want to save entries in a database but sometimes only if any previously added entry was successfully added. in OOP id just sequentially loop over the entries and record the successfully saved entries in a hash set
06:36:12 <BernhardPosselt> whats the FP way to do this?
06:36:20 <julianleviston> bollu: well, if you think it’s helpful, I guess.
06:36:30 <fizruk> bollu: in books it's more like (λx y. x + y)  =Ъ
06:36:50 <BernhardPosselt> keep a list of successfully added entries and recursively pass it to the next add entry call?
06:36:51 <bollu> fizruk: yeah :) 
06:36:55 <theme2> BernhardPosselt, are you sure you mean "any" and not "all"?
06:37:08 <theme2> "only if any previously added entry was successfully added"
06:37:10 <bollu> fizruk: but, like, if they want to stress on the "closure" bit
06:37:18 <BernhardPosselt> theme2: each entry can have dependencies on any previously added entry
06:37:20 <bollu> (λx.λy. x + y) is used AFAIK. 
06:37:27 <bollu> to show that "a function returns a function"
06:37:47 <fizruk> haskell439: btw, lambda arguments are actually patterns, like when you define a regular function
06:38:10 <fizruk> > (\(a, b) -> (b, a)) (1, 2) 
06:38:12 <lambdabot>  (2,1)
06:39:02 <ski> ⌜λxy.…x…y…⌝ is a common abbreviation for ⌜λx.λy.…x…y…⌝
06:39:06 <julianleviston> BernhardPosselt: you’d iterate over your data, and as you save build a new result set.
06:39:28 <bollu> ski: huh, I didn't know that. My knowledge of lambda calc. is very fragmented
06:39:33 <BernhardPosselt> julianleviston: which is passed along correct?
06:39:34 <julianleviston> BernhardPosselt: the only difference being that instead of jabbing at a piece of state as you’re looping, you’d return the new list
06:39:36 <bollu> I'm sorry if I misled anyone
06:39:44 <julianleviston> BernhardPosselt: not sure how to answer that
06:40:16 <theme2> BernhardPosselt, Yes (I suggest using the State monad or the StateT monad transformer)
06:40:16 <BernhardPosselt> julianleviston: as in: the saveentry would receive a list of entries and a list of sucessfully saved entries
06:40:34 <theme2> BernhardPosselt, maybe not if you don't understand monads *yet*
06:40:47 <theme2> BernhardPosselt, yes
06:40:52 <aweinstock> BernhardPosselt: if any entry can depend on any previous entry, you'd want to fail the entire update at the first individual error, I'd think
06:40:52 <BernhardPosselt> theme2: i will take a look thanks :)
06:40:55 <julianleviston> BernhardPosselt: I’m not sure, because I don’t know what your code looks like, but sure.
06:41:02 <aweinstock> (which is exactly what Either does)
06:41:09 <ski> <ski> the `traverse . traverse' just "selects" the elements of the elements of the whole list to work on  <bollu> ski: isn't it like the first traverse picks the list, and the second traverse picks elements of the list?  <bollu> thereby allowing you go "two levels deep" ?
06:41:19 <ski> bollu : yes, which is what i meant by what i said
06:41:32 <BernhardPosselt> aweinstock: nope, update is only failed for the stuff that depends on it :)
06:41:59 <bollu> ski: ahh, ty :)
06:42:59 <Saizan> "λxy. .." <- that's so bad, damn math mode not having sensible space
06:43:19 <ski> bollu : cf. Semantic Editor Combinators
06:43:25 <ski> Saizan : aye
06:43:29 <ski> @where SEC
06:43:29 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
06:44:19 <theme2> Is there an alternative definition for Traversable?
06:44:32 <ski> alternative to what ?
06:45:10 <theme2> I think that it would help me understand it, since I first understood Applicative with a definition based on a function with type `Applicative f => f a -> f b -> f (a, b)`
06:46:33 <ski> it suffices to define either `traverse' or `sequenceA'
06:47:55 <theme2> my computer just crashed and rebooted :(
06:49:37 <ski> (`mapM' is the monadic version of `traverse', just as `sequence' is the monadic version of `mapM'. since every monad is idiomatic (is an applicative functor), the default implementations of `sequence',`mapM' uses `sequenceA',`traverse')
06:49:53 <ski> (an alternative name of `traverse' might have been `mapA')
06:50:20 <theme2> hmm
06:51:17 <ski>   mapM :: Monad m => (a -> m B) -> ([a] -> m [b])  -- this is the original version of `mapM'
06:51:35 <ski>   sequence :: Monad m => [m a] -> m [a]  -- this is the original version of `sequence'
06:51:50 <ski> theme2 : do you understand these ^ two ?
06:52:04 <ski> (er, s/B/b/)
06:52:18 <theme2> ski, yes
06:53:02 <ski> they pick a particular order in which to traverse the data structure (a list), executing a monadic action for each element, in that order
06:53:25 <theme2> but generalizing them to anything other than lists is confusing to me
06:53:29 <jkaye> In structured-haskell-mode, has anyone encountered an issue where trying to add a guard moves the existing guard to a new line instead of leaving it where it was?
06:53:38 <ski> (in the `sequence' case, the element itself is the action, in the `mapM' case, you get each action by applying a separate function on each element)
06:54:21 <ski> theme2 : consider a tree of elements. fix a traversal order, e.g. depth-first left-to-right. visit the elements in this order, executing the action for each element
06:54:35 <ski> let's say you have
06:54:49 <theme2> ok... lemme think
06:54:52 <ski>   data Tree a = Tip
06:55:03 <ski>               | Node (Tree a) a (Tree a)
06:55:13 <theme2> ski, that mental model works for me for mapM and sequence
06:55:20 <ski> so you'd define `mapM' like :
06:55:34 <theme2> but I suppose that applicatives don't have anything equivalent to (>>), right?
06:55:39 <BartAdv>  suppose I've got some language which syntax is described by type SExp. Now, I've got function infer :: SExp -> Infer Type, so given an expression I can infer its type. But now suppose instead of a type of whole expression I'd like to obtain a tree similar to SExp but with types attached at each node. How would one tackle such problem?
06:56:11 <tdammers> :t (*>)
06:56:12 <lambdabot> Applicative f => f a -> f b -> f b
06:56:25 * theme2 looks that up
06:56:27 <ski>   mapM act  Tip           = do return Tip
06:56:42 <ski>   mapM act (Node la a ra) = do lb <- mapM act la
06:56:48 <theme2> ski, I'm ok with that part already
06:57:01 <ski>                                b  <-      act  a
06:57:14 <ski>                                rb <- mapM act ra
06:57:22 <ski>                                return (Node lb b rb)
06:57:25 <ski> theme2 : ok
06:57:49 <theme2> now... what the heck does (*>) do...
06:58:17 <ski>   ia *> ib = (\a b -> b) <$> ia <*> ib
06:58:49 <ski>            = liftA2 (\a b -> b) ia ib
06:58:50 * theme2 hates rare non-descriptive operators
06:58:55 * hackagebot composition-tree 0.1.1.0 - Composition trees for arbitrary monoids.  https://hackage.haskell.org/package/composition-tree-0.1.1.0 (LiamOConnorDavis)
06:59:19 <bollu> :t >>
06:59:21 <lambdabot> parse error on input ‘>>’
06:59:21 <bollu> :t (>>)
06:59:23 <lambdabot> Monad m => m a -> m b -> m b
06:59:27 <bollu> :t (*>)
06:59:28 <lambdabot> Applicative f => f a -> f b -> f b
06:59:39 <ski>   ma >> mb = ma >>= \a -> mb
06:59:43 <julianleviston> isn’t it applicative sequencing?
06:59:48 <ski>            = ma >>= \a -> mb >>= \b -> return b
06:59:57 <ski>            = liftM2 (\a b -> b) ma mb
07:00:17 <julianleviston> theme2:  Sequence actions, discarding the value of the first argument
07:00:25 <theme2> ok...
07:00:25 <ski> so `(*>)' is the idiomatic version/variant of `(>>)'
07:00:46 <julianleviston> “then”
07:01:09 <theme2> for zip lists, truncate the second argument to the same length as the first argument?
07:01:26 <theme2> what a weird behavior for a generic operator
07:01:42 <ski> truncate to the minimum length of both, yes
07:02:19 <quicksilver> it is slightly weird behaviour for a generic operations and arguably zip is "most at home" on infinite lists
07:02:31 <ski> theme2 : i think the idea is that you should be able to write e.g. parsers like `frob <$> foo <* bar *> baz', where the result of the parser `bar' will be ignored (iow not passed as an argument to `frob')
07:03:12 <theme2> oh wait... so sequenceA is just the generalization of my `Applicative f => f a -> f b -> f (a, b)` function
07:03:23 <ski> theme2 : huh ?
07:03:24 * theme2 headdesks
07:03:36 <quicksilver> on infinite lists there is a Monad structure where "ap" ends up being zip and 
07:03:45 <quicksilver> join is diagonal? is that right?
07:03:51 * quicksilver lost confidence mid sentence
07:03:58 <ski> `sequenceA' works on any list, or, generalizing, on any `Traversable' structure
07:04:05 <theme2> `f a -> f b -> f (a, b)` is equivalent to `(f a, f b) -> f (a, b)`
07:04:10 <ski> quicksilver : diagonal, yes
07:04:13 <fizruk> quicksilver: like in Control.Monad.Omega?
07:04:28 <quicksilver> fizruk: I expect so :) that sounds like the right name for it!
07:04:57 <quicksilver> fizruk: no, not that.
07:05:08 <ski> theme2 : well, `Traversable' only works for types of kind `* -> *', while in your case `(,) :: * -> * -> *'
07:05:22 <ski> theme2 : if you defined `newtype Vector2 a = MkV2 (a,a)', then sure
07:05:31 <quicksilver> fizruk: that's a enumerate-all-of-AxB join, like a generalisation of the normal list monad.
07:05:58 <theme2> ski, well... there is an instance of `((,) a)` defined
07:06:06 <ski> theme2 : i.e., you could get `sequenceA :: forall i a. Applicative i => Vector2 (i a) -> i (Vector2 a)', then
07:06:11 <fizruk> quicksilver: oh, you meant it for infinite-infinite lists :)
07:06:23 <ski> theme2 : yes, but that will only "visit" (traverse) the right component of the pair
07:06:33 <theme2> ski, close enough for me
07:06:49 <fizruk> quicksilver: although I can't tell the difference now
07:07:08 <ski> fizruk : diagonalization as in diagonal functor, contraction, &c.
07:08:17 <theme2> I sometimes understand stuff in weird ways
07:08:20 <fizruk> ski: okay, I think I do not know what that is :)
07:08:47 <ski> fizruk : do you know any category theory ? adjunctions ? how about logic ?
07:08:52 <theme2> when I first thought I understood monads, I actually understood arrows
07:09:10 <theme2> and then I got an headache on "how are monads and applicatives different?"
07:09:11 <theme2> lol
07:09:26 <ski> theme2 : anyway, it's important that in the `Vector2' case here, both components are required to have the same type
07:10:12 <fizruk> ski: well, just a little bit, I guess
07:13:54 <fizruk> ski: the phrase "join is diagonal" does not typecheck for definitions of diagonal I can look up
07:18:50 <ski> fizruk : for any sets ⌜I⌝,⌜A⌝, we can think of the inhabitants of ⌜I → A⌝ (or ⌜A^I⌝) as ⌜I⌝-tuples of ⌜A⌝s (when ⌜I⌝ is ⌜2⌝ (`Bool'), `Bool -> a' is iso to `(a,a)')
07:18:56 * hackagebot nix-eval 0.1.0.1 - Evaluate Haskell expressions using Nix to get packages  https://hackage.haskell.org/package/nix-eval-0.1.0.1 (chriswarbo)
07:20:15 <ski> fizruk : we can define a "diagonal" function ⌜Δ : A → (I → A)⌝, that given an inhabitant of ⌜A⌝, gives an ⌜I⌝-tuple of ⌜A⌝s, by ⌜Δ a _ = a⌝. the tuple will be a "constant" one, having the value ⌜a⌝ in all components
07:21:25 <fizruk> so const is a diagonal
07:22:19 <ski> fizruk : we can think of `Stream a' as ⌜ℕ → α⌝, and so `Stream (Stream a)' as ⌜ℕ → (ℕ → α)⌝, iso to ⌜ℕ × ℕ → α⌝, iso to ⌜(2 → ℕ) → α⌝. so `join :: Stream (Stream a) -> Stream a' becomes ⌜μ : ((2 → ℕ) → α) → (ℕ → α)⌝, which is just a composition with ⌜Δ⌝ : ⌜μ ass = ass ∘ Δ⌝
07:23:14 <voidzero> i wish my terminal font showed those glyphs correctly
07:23:44 <ski> so, the ⌜i⌝th element of the resulting stream will be the ⌜(i,i)⌝th element of the input stream of streams ("two-dimensional stream")
07:24:45 <voidzero> ski, TERM is not a ctcp my client knows
07:24:56 <fizruk> okay, now it typechecks, when join is (∘ Δ), not just Δ
07:25:26 <ski> voidzero : <http://ircbrowse.net/day/haskell/today?mode=recent> might work for you ..
07:25:41 <fizruk> ski: thanks for the explanation!
07:25:42 <ski> voidzero : i was (potentially) expecting a manual reply :)
07:27:14 <voidzero> hmm, well i'm using urxvt with Terminus. Now I added unifont, and I see the glyphs, but 'ugly' is an understatement hehe
07:28:04 <ski> fizruk : in category theory, ⌜I⌝ and ⌜A⌝ can be categories (⌜I⌝ often being called the "diagram category". it represents the shape of a diagram, involving both types/objects, and morphisms/functions between them, including info on which compositions of morphisms are equal), and then ⌜Δ⌝ will be a functor from ⌜A⌝ to the exponential category ⌜A^I⌝
07:30:40 <_riba> hello, i have a really complex data structure (representing a whole program after the lexical analysis), is there an easy way to get to the elements, e.g. by data type?
07:30:51 <tulcod> _riba: "get to the elements"?
07:31:14 <greg`> im going to ask a question to about category theory, the problem is im not sure what im talking about , so feel free to tell me i dont make sense 
07:31:29 <tulcod> greg`: that sounds like category theory alright
07:31:32 <geekosaur> _riba, that sounds like you want a generics package such as uniplate
07:32:00 <greg`> does A -> ( B x C) imply (A x B) -> C  ?
07:32:33 <tulcod> greg`: "imply" is not the right word
07:32:43 <ski> fizruk : there's something called (left, respectively right) adjoint (functors) (to a functor, like e.g. ⌜Δ⌝). these (if existing) will both go in the opposite direction, from ⌜A^I⌝ to ⌜A⌝
07:32:56 <ski> fizruk : the right-adjoint will be an ⌜I⌝-product construction, combining ⌜I⌝ ⌜A⌝-types (really an ⌜I⌝-shaped diagram in ⌜A⌝) into a single ⌜A⌝ type. like ⌜(×) : ★ × ★ → ★⌝ (`(,)' in Haskell) in the ⌜I = 2⌝ case. the left adjoint will be an `I'-coproduct, like ⌜(+) : ★ × ★ → ★⌝ (`Either' in Haskell)
07:32:56 <greg`> tulcod: what is the right word?
07:32:59 <_riba> tulcod, well, on the top level there's the program, which is defined by procedures, which are defined by strings and guards and commands and variable assignments, ... and now i'm looking how to see all variable assignments for instance, without writing my own parser for it
07:33:16 <_riba> geekosaur, thanks for the hint, i'll have a look
07:33:19 <tulcod> greg`: in some categories (those with "exponentials"), there are exactly as many morphisms A x B -> C as there are morphisms A -> C^B
07:33:28 <ski> @djinn (a -> (b,c)) -> ((a,b) -> c)
07:33:28 <lambdabot> f a (b, _) =
07:33:28 <lambdabot>     case a b of
07:33:28 <lambdabot>     (_, c) -> c
07:33:37 <ski> greg` : yes
07:33:45 <glguy_> Data.Data is good at type driven traversals of ast
07:33:52 <tulcod> greg`: (an "exponential" is a specific case of an "adjunction")
07:33:58 <ski> tulcod,greg` : logically speaking, "imply" is the right word
07:34:32 <tulcod> ski: what (A x B) -> C are you thinking of?
07:34:41 <greg`> ooooh i need to install djinn
07:35:09 <tulcod> ski: i mean. if the context is category theory
07:35:11 <tulcod> rather than haskell
07:35:24 <tulcod> okay so obviously that is where we have different interpretations :)
07:35:48 <tulcod> greg`: in pure category theory, there need not exist such a relation. in haskell, there is, as ski pointed out.
07:36:07 <tulcod> actually this is bullshit. i'm sorry.
07:36:15 <tulcod> you have that function in pure category theory as well :-/
07:36:47 <greg`> lol - thanks , i understand this is so abstract
07:37:02 <ski> tulcod : given ⌜f : A ⟶ B × C⌝, ⌜π₁ ∘ f ∘ π₀⌝ ?
07:37:06 <greg`> just trying to figure out how the refactorings i do naturally work out in CT
07:37:11 <tulcod> ski: yeah don't worry i realized that
07:37:16 <julianleviston> Has anyone read the book “The Haskell School of Expressions” and if so, have you managed to install the Libs?
07:38:26 <ski> tulcod : i suppose one could internalize it as a natural transformation ⌜π₀ ⟶ π₁⌝
07:38:43 <fizruk> ski: okay, that kind of makes sense, don't know how to use this knowledge though :)
07:38:55 <halosghost> okay, so I'm trying to work with the Xlsx library <https://hackage.haskell.org/package/xlsx>, and I've correctly created a spreadsheet from the data (and it exports to a .xlsx correctly)
07:39:58 <halosghost> but, when I try to add some column width properties so that it will display sensibly in Excel by-default, everything still compiles okay, but I get the following error on opening with Excel: “Excel found unreadable content in 'document_name.xlsx'. Do you want to recover the contents of this workbook? If you trust the source of this workbook, click Yes.”
07:40:55 <greg`> fizruk: perhaps i could describe what i did, in laymans terms i had a Data.Map A (B,C) and I just knew i could refactor it to a Data.Map (A,B) ,C
07:41:04 <halosghost> I tried to read in a .xlsx that has the column widths already set correctly, but when I try to show the document to see how it is formatted, the _wsColumns record field is an empty list (it seems as though it failed to keep the column width data)
07:41:21 <greg`> and i knew my program would still work
07:41:34 <greg`> the hard part was working out why/how I knew that
07:42:08 <fizruk> greg`: did you mean to refer to someone else? :)
07:42:28 <ski> fizruk : in terms of logic, contraction is a rule that says that if ⌜Γ,A,A ⊢ Δ⌝, then ⌜Γ,A ⊢ Δ⌝. so is we have a proof that uses the assumption ⌜A⌝ twice, we can pretend that we've used it just once. since we're allowed to use an assumption as many times as we like (the "contraction" rule is exactly what allows us to do that)
07:42:53 <greg`> sorry fizruk: I thought you were looking for a use of the knowledge
07:43:38 <fizruk> greg`: I was referring to diagonal functors ski was explaining to me)
07:43:42 <ski> fizruk : so this is related to the ⌜Δ : A → (2 → A)⌝ and ⌜(∘ Δ) : ((2 → A) → B) → (A → B)⌝ things
07:44:27 <ski> greg` : you can't make such a refactoring. the types are not isomorphic
07:44:47 <ski> greg` : refactorings are supposed to preserve program behaviour exactly
07:45:12 <ski> @djinn ((a,b) -> c) -> (a -> (b,c))
07:45:13 <lambdabot> -- f cannot be realized.
07:45:16 <tulcod> _riba: but if you just have a single Expression data type, with several constructors, such a parser is easily written
07:45:40 <ski> greg` : there isn't even a conversion in the opposite direction, much less one which is an inverse to the other one
07:46:17 <ski> greg` : however, you could consider going between `Map (A,B) C' and `Map A (Map B C)' (compare with currying of functions)
07:46:20 <ski> @type curry
07:46:21 <ski> @type uncurry
07:46:21 <lambdabot> ((a, b) -> c) -> a -> b -> c
07:46:22 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:47:31 <bollu> ski: I always mix curry and uncurry. Any pointers?
07:47:44 <ski> though .. i think `Map A (Map B C)' is slightly larger than `Map (A,B) C', since in the former case, you could have an `a :: A', which is associated with an empty map from `B' to `C'
07:47:56 <halosghost> bollu: 0x74f86227
07:48:03 <halosghost> /sarcasm
07:48:06 <bollu> halosghost: :)
07:48:34 <ski> bollu : `curry' returns the curried version of a (`2'-)tupled function
07:48:35 <fizruk> bollu: curry is to make function more haskellish (as in Haskell Curry)
07:48:49 <bollu> fizruk: I'm sorry but I love your version
07:49:00 <bollu> ski: yes, yours is more correct :)
07:49:08 <td123> bollu: curried form allows for partial application
07:49:12 <ski> there's two main ways (/styles) to represent a "function with multiple arguments" (e.g. in Haskell)
07:49:18 <bollu> td123: yes, ik
07:49:36 <td123> bollu: was giving a possible pointer on how to remember it :)
07:49:42 <bollu> td123: but, like, I'm not sure if ((a, b) -> c) -> (a -> b -> c) is curry or uncurry
07:49:55 <bollu> td123: I tried thinking about it that way, but I mix em uo
07:49:57 <ski> curried style : making a function that accepts the first argument, returning a function that accepts the next argument, returning ..., returning a function that accepts the last argument, returning the result
07:49:57 <bollu> up*
07:50:15 <ski> tupled style : making a function that accepts a tuple (or record) of the arguments, returning the result
07:50:22 <_riba> tulcod, is it really that simple? the only way i see right now is basically re-writing the lexer but parsing the tokens it returned
07:50:31 <bollu> ski, td123, fizruk: thanks :) hopefully I'll remember next time
07:50:49 <tulcod> _riba: ah, i see what you mean - you'd like to avoid recursing into all the fields, is that right?
07:50:54 <ski> so these are two ways to simulate "multiple function arguments" in a system that only allows a function to accept a single argument
07:51:27 <fizruk> bollu: well, compiler will most likely stop you if you're doing it wrong :)
07:51:40 <_riba> tulcod, yes. a very minimal example which i need the "CAssign" out of would be: Program [Procedure (SLiteral "asd") (Op "->") (SVar (Var "b")) [GCommand [] (CAssign (SVar (Var "b")) (SLiteral "test"))]]
07:51:50 <ski> bollu : btw, note that if `f' is a curried function, e.g. defined like `f x y = ..x..y..', then `f 3' is a *partial application* of `f'
07:52:15 <tulcod> _riba: i guess this would be a good use case for lenses, if you're willing to read up a bit
07:52:43 <ski> "partial application" simply means that given a function accepting multiple arguments, you apply it to some, but not all, of those arguments, and get back a function that still accepts the remaining arguments before returning the result
07:53:09 <ski> (and "function accepting multiple arguments" in this Haskell context must be simulated in some way, e.g. in the curried or the tupled way)
07:53:39 <_riba> tulcod, i have used them a bit, but are they really flexible enough for such a data structure?
07:53:57 <tulcod> _riba: otherwise, you'll need some way to introspect the type's definition, so a generics package like was suggested earlier (note that lenses actually does some generics stuff on its own - it's nothing magical)
07:54:02 <ski> (btw, another distinct sense of "tupling". if we have `f :: A -> B' and `g :: A -> C', then we could define `fg :: A -> (B,C); fg a = (f a,g a)', `fg' could be said to be `f' and `g' tupled together)
07:54:46 <quicksilver> _riba: absolutely they are. see https://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Plated.html
07:56:10 <camm1> Hello everyone. Is renaming the only way to resolve this warning: "This binding for ‘name’ shadows the existing binding ..."?
07:56:10 <_riba> quicksilver, thanks, i'll have a look
07:57:00 <_riba> an alternative i see is adding some state to the parsing, but that would be kind of redundant
07:58:19 <tulcod> _riba: well, think about it. probably you'll need this style of data access more often. so don't repeat yourself, go for a more fancy solution to solve the problem once and for all
07:58:23 <bollu> ski: that is like, direct product
07:58:31 <bollu> ski: the product you constructed?
07:58:40 <clrnd> camm1, yes
07:58:49 <clrnd> that's nice though
07:58:56 <camm1> :( 
07:59:00 <camm1> That will be boring.
07:59:09 <clrnd> camm1, wouldn't it be confusing otherwise?
07:59:10 <camm1> Thank you clrnd.
07:59:49 <tulcod> camm1: you might want to do a qualified import rather than a normal import, somewhere
08:01:36 <merijn> camm1: You can just disable that warning too...
08:03:11 <camm1> Thanks everyone I'll to fix it. Thanks for your ideas.
08:03:38 <ski> bollu : it's categorical product. it's a generalization of various particular direct products in different categories / mathematical universa
08:05:28 <ski> math people often implicitly apply the latter notion of "tupling" i mentioned above. in category theory, `fg' would be written ⌜⟨f,g⟩⌝
08:06:13 <delYsid> Why does flip id work like flip ($)?  Why would I use flip id, instead of flip ($), and why does @pl rewrite ($ x) to flip id?
08:06:58 <Hafydd> delYsid: there is no difference.
08:07:19 <Hafydd> delYsid: ($) is an infix version of id with low precedence.
08:07:33 <nolrai66> Hafydd: and a restricted type.
08:07:41 <Hafydd> Oh, and that.
08:07:58 <delYsid> Hafydd: I gathered that by experimentation.  However, I still wonder why flip of a unary function can return a binary function, and why lambdabot would suggest rewriting some use of $ to flip id?
08:08:19 <shapr> delYsid: oh hey, long time no see
08:08:24 <nolrai66> @ty flip id
08:08:25 <lambdabot> b -> (b -> c) -> c
08:08:32 <Hafydd> delYsid: which is the unary function that gets flipped to a binary function?
08:08:55 <delYsid> shapr!!!!!
08:08:56 <Hafydd> (Note: Haskell only has unary functions, technically.)
08:09:13 <shapr> delYsid: You're back into learning Haskell, hurrah! It's only been ... seven or eight years? ;-)
08:09:40 <delYsid> shapr: 10
08:09:43 <hodapp> lol
08:09:45 * ski vaguely recalls seeing delYsid years ago, in here ?
08:09:46 <clrnd> > let r = flip id in r 7 (+1)
08:09:47 <lambdabot>  8
08:09:53 <shapr> delYsid: bah, I lost track
08:09:54 <clrnd> flipd id is reverse polish notation then?
08:10:23 <greg`> what are the CT names for ⌜ Γ , ⊢  and   Δ⌝
08:10:37 <greg`> I want to figure out what you guys are talking about?
08:10:56 <delYsid> Hafydd: The type of id and ($) are different enough to make me wonder why flipping them results in the same thing.  Its really a puzzle I cant work out.
08:11:12 <Hafydd> :t id
08:11:14 <lambdabot> a -> a
08:11:15 <Hafydd> :t ($)
08:11:16 <lambdabot> (a -> b) -> a -> b
08:11:27 <lambdadoodle> :t extend
08:11:29 <lambdabot> Not in scope: ‘extend’
08:11:34 <clrnd> :t flip
08:11:35 <lpaste> bluhd pasted “How to recursively call subst?” at http://lpaste.net/4602937423448506368
08:11:35 <lambdabot> (a -> b -> c) -> b -> a -> c
08:11:37 <Hafydd> delYsid: if you instantiate a to a -> b in the type of id, you get the type of ($). It is strictly less general.
08:12:03 <bluhd> What do I put where it says "-- Recursively call subst here." I'm a little lost haha
08:12:34 <Hafydd> Indeed:
08:12:41 <lambdadoodle> edwardk: I just wanted to say that I find the fact that u used w to address Comonads very very smart
08:12:45 <Hafydd> :t id :: (a -> b) -> a -> b
08:12:46 <lambdabot> (a -> b) -> a -> b
08:13:25 <delYsid> Hafydd: I still dont get it.  I know that Haskell functions strictly speaking, only have one argument.  I also know that the parens (or I believe so) are optional.  Given that, there seems to be a big gap in my understanding of partial application, if flip id, can do what it does.
08:13:31 <ski> greg` : those are from logic (and from there, type theory), not category theory. the first is a majuscule (/capital) Gamma. the last is a majuscule Delta. those are greek letters. the middle one is a "turnstile" symbol, meaning "(syntactic) entails"/"proves"/"(syntactic) implies" in logic
08:13:58 * hackagebot tubes 1.0.0.1 - Effectful, iteratee-inspired stream processing based on a  free monad.  https://hackage.haskell.org/package/tubes-1.0.0.1 (gatlin)
08:14:18 <ski> (greg` : `⌜',`⌝' are just fancy quotation symbols that i'm sometimes using)
08:14:18 <delYsid> Hafydd: oh, of course, if I pass a function to id, that will change its type signature to more -> :-)
08:14:30 <Hafydd> delYsid: yes.
08:14:32 <delYsid> (for a lack of better words)
08:14:33 <greg`> ski: thanks
08:14:38 <geekosaur> yeh, the a -> a in id's type can match anything
08:15:19 <geekosaur> if you instantiate it as (a' -> b) (renaming a for clarity) then you get (a' -> b) -> (a' -> b), and the latter is the same as (a' -> b) -> a
08:15:20 <geekosaur> er
08:15:27 <ski> greg` : ⌜Γ⌝ and ⌜Δ⌝ are here sequences of (logical) formulae. in (the "sequent"/"judgement") ⌜Γ ⊢ Δ⌝, ⌜Δ⌝ would commonly only allowed to have a single formula
08:15:32 <geekosaur> if you instantiate it as (a' -> b) (renaming a for clarity) then you get (a' -> b) -> (a' -> b), and the latter is the same as (a' -> b) -> a' -> b because -> associates rightward
08:16:03 <greg`> i see
08:16:11 <clrnd> bluhd, well, let's take the first case
08:16:14 <ski> greg` : ⌜Γ ⊢ Δ⌝ then means : assuming all the formulae in ⌜Γ⌝ holds (true), it follows logically that ⌜Δ⌝ holds
08:16:17 <clrnd> subst x (App z z') y = (App new_z new_z')
08:16:26 <delYsid> That still doesnt explain why
08:16:28 <delYsid> @pl \x -> map ($ x) [\y -> y*2]
08:16:29 <lambdabot> flip map [(2 *)] . flip id
08:16:48 <ski> (greg` : in case ⌜Δ⌝ is allowed to be any sequence of formulae, then ⌜Γ ⊢ Δ⌝  means : assuming all the formulae in ⌜Γ⌝ holds (true), it follows logically that at least one formula in ⌜Δ⌝ holds)
08:16:59 <clrnd> bluhd, what do you have to do, conceptually?
08:17:16 <delYsid> True, @pl is obfuscation by definition, but why does it choose to obfuscate more then necessary?
08:17:34 <Hafydd> delYsid: that output meets the specification of being a point-free version of your function. The choice of ($) or id is arbitrary in this case.
08:17:54 <greg`> ski is that the same as saying Γ -> Δ ( i realise im mixing notation)
08:17:58 <Hafydd> (I wouldn't attribute any meaning to the choice.)
08:18:13 <greg`> where Γ  and Δ are expressions in Hask
08:18:54 <greg`> and would this be an example of the howardcurry isomorphism
08:18:58 <nolrai66> I need to fix my fonts.
08:18:59 * hackagebot CoreDump 0.1.1.0 - A GHC plugin for printing GHC's internal Core data structures.  https://hackage.haskell.org/package/CoreDump-0.1.1.0 (OmerAgacan)
08:19:08 <greg`> nolrai66: lol
08:19:15 <bluhd> clrnd: I'm very new to haskell and was given this as a template to complete the question. From what I understand, in this first case we take an application and replace x with y in both z and z'
08:19:16 <greg`> emacs ftw
08:19:20 <delYsid> Hafydd: I would vote that ($) is more expressive, at least to someone like me, not fully understanding why flip id does what it does.
08:19:32 <bluhd> clrnd: I'm just not sure how to call subst with the proper arguments to do so
08:19:43 <ski> greg` : in type theory, instead of them being sequences of formulae, they would be sequences of "typings", like ⌜t : τ⌝, where ⌜τ⌝ is any type (expression). in ⌜Γ⌝, each ⌜t⌝ would normally have to be a variable (so ⌜Γ⌝ is then basically a type environment, assigning types to variables (the free variables in the current scope)), while in ⌜Δ⌝, ⌜t⌝ could be any (value) expression, allowed to mention (only) the variables in ⌜
08:19:51 <nolrai66> delYsid: Yes. pointless is not perfect.
08:19:54 <geekosaur> delYsid, there's a sizeable contingent that considers ($) to be evil
08:19:56 <Hafydd> delYsid: do you still doubt that flip id is the same function as flip ($)?
08:20:00 <greg`> ok my fonts are broken too, can anyone read that?
08:20:05 <geekosaur> in any form or use
08:20:17 <clrnd> bluhd, join #haskell-beginners please
08:20:22 <geekosaur> greg`, that is double UTF8-encoded garbage
08:20:29 <firstglitch> I just uploaded my first haskell package, a Haskell program to download subtitles, to hackage. Can someone please take look at the code, https://bitbucket.org/sras/hastily  and the package https://hackage.haskell.org/package/hastily-0.1.0.4/candidate . Any feedback is welcome.
08:20:41 <bluhd> clrnd: okay, do I just ask the question in there?
08:20:44 <Hafydd> delYsid: if you do, look at this: f $ x = ($) f x = id f x = (id f) x = f x.
08:20:47 <clrnd> bluhd, I;m there too!
08:20:54 <bluhd> clrnd: okay, be right there
08:21:03 <fizruk> geekosaur: is it because of special parsing rules for it or are there other arguments against it?
08:21:04 <delYsid> Hafydd: I don't doubt it, I can check that by experimenting, however, I really dont grok how it works.
08:21:19 <geekosaur> fizruk, there's no special parsing rules
08:21:36 <delYsid> geekosaur: Even since the Applicative revolution?  i.e., given the nice similarity between ($) and (<$>)?
08:21:56 <ski> greg` : ⌜Γ → Δ⌝ would be nonsense, illformed. ⌜→⌝ combines two types (or in logic, formulae) into a new type (formula). ⌜Γ⌝,⌜Δ⌝ are not types (/formulae), they are sequences expressing that their element types (/formulae) are inhabited (/ holds true)
08:22:22 <geekosaur> I'm not really the person to ask about it; I consider ($) fine when used judiciously
08:22:42 <greg`> i understand ski , thanks
08:22:42 <delYsid> Hafydd: Thanks!!!!! id f x did sink it in.
08:22:50 <bollu> geekosaur: should I do my daily bit of (|>)? :)
08:22:51 <ski> greg` : if there's some symbol you can't read, you could try <http://ircbrowse.net/day/haskell/today?mode=recent>. or ask me to rephrase it in ascii
08:22:57 <ski> nolrai66 ^
08:23:11 <delYsid> since the function application is implicit there, oh!
08:23:15 <geekosaur> ski, whateveryou sent there got double-encoded
08:23:28 <shapr> delYsid: so, what got you back to trying Haskell?
08:24:13 <ski> geekosaur : which statement ?
08:24:23 <geekosaur> [30 15:19] <ski> greg` : in type theory, instead of them being sequences of formulae, they would be sequences of "typings", like âŒœt : Ï„âŒ, where âŒœÏ„âŒ is any type (expression). in âŒœÎ“âŒ, each âŒœtâŒ would normally have to be a variable (so âŒœÎ“âŒ is then basically a type environment, assigning types to variables (the free variables in the current scope)), while in âŒœÎ”âŒ, âŒœt
08:24:23 <geekosaur> âŒ could be any (value) expression, allowed to mention (only) the variables in âŒœÎ
08:24:25 <ski> (looks fine to me, at <ircbrowse.net>)
08:24:52 <geekosaur> your previous messages decoded fine, but all the â and such hint at double-encoding
08:25:01 <delYsid> shapr: I wanted to contribute/hack propellor.  And got frustrated by not understanding the Monad stuff.  So I went and started my own learning project, rewriting a C++ based algorithm I "invented" in Haskell.  Something about parsing braille music code. (github.com/mlang/hbmc)
08:25:05 <geekosaur> or some serious utf8 vs. iso8859-1 confusion somewhere
08:25:26 <geekosaur> (possibly using both in the same message which will confuse receiving clients)
08:25:28 <ski> oh, i got cut off there
08:25:39 <shapr> delYsid: did you ever get a better display? or are you still using one line that's 80-chars wide?
08:25:47 <ski> ".., while in ⌜Δ⌝, ⌜t⌝ could be any (value) expression, allowed to mention (only) the variables in ⌜Γ⌝ freely"
08:25:48 <geekosaur> ah, cut off in the middle of a sequence
08:25:57 <geekosaur> probably broke utf8 decode then
08:26:09 <delYsid> shapr: Currently, one line with 88 cells.
08:26:12 <geekosaur> many clients will fall back to iso8859-1 if utf8 decode fails
08:26:14 <f-a> I am writing a small program that as a first step needs to browse a directory tree. When the directory is large it takes some time and I'd like it to display a counter ("xyz files parsed"). I suppose it's a well known problem, which libraries are there to help me?
08:26:20 <shapr> delYsid: well, that's better, I guess
08:26:32 <delYsid> (which is, in fact, the largest continuous braille display commercially available)
08:26:46 <shapr> delYsid: I've thought of ways to improve on braille displays, but never put any work into trying them out.
08:26:56 <delYsid> goes for 16kEUR where I live...
08:27:10 <f-a> shapr: what were your ideas?
08:27:14 <b_jonas> delYsid: there are ones largers than 80 character cells?
08:27:17 <b_jonas> wow
08:27:24 <f-a> 80 looks scary big
08:27:31 <ski> greg` : anyway, you might be interested in looking at "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> (available both in PS and PDF)
08:27:36 <b_jonas> f-a: exactly
08:27:43 <shapr> delYsid: holy wow, my ideas were *much* cheaper, maybe I should try them
08:27:51 <delYsid> shapr: Please dont waste your time :-)  I've had about 20 tech friends already propose some half-hearted attempts to revolutionize braille displays already, they all seem to think it should be easy, but piezzo is quite unbeatable regarding performance and longlevity
08:28:21 <shapr> delYsid: fair enough, I'll go back to my pitch shifting hearing aid project
08:28:57 <ttt_fff> when migrating a piece of haskell code (which uses typeclasses) to Fay (which does not support typeclasses), are there any recommended best practices ?
08:29:26 <chpatrick> ttt_fff: use ghcjs instead? :P
08:29:27 <delYsid> shapr: dont get me wrong, it would be wonderful to have something which can display more chars at once for a smaller price, its just that this is a reoccuring pattern, and I *know* it needs much more involvement than your typical electronics project...
08:29:39 <f-a> ttt_fff: there is a way to 'fake' typeclasses with types
08:29:43 <ttt_fff> chpatrick: ghcjs is huge and hard to understand
08:29:46 <ttt_fff> f-a: can you point me at links?
08:29:57 <ttt_fff> chpatrick: fay, the source code is small enough that I can actually read it + possibly hack on it in the future
08:30:09 <f-a> one sec ttt_fff 
08:30:35 <delYsid> A braille diisplay should survive 10000 hours of use, potentially refreshing roughly 10 to 20 times a second...
08:30:44 <delYsid> that is *a lot* of movement
08:31:46 <f-a> ttt_fff: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html <-- but I wonder if it is any help to you. I mean, I'd just juse monomorphic functions and screw everyone
08:32:18 <ttt_fff> f-a: how does 'monomorphic functions' solve the typeclasses issue?
08:32:25 <f-a> delYsid: I don't get the 10/20 times a second. Why does it (potentially) need to do that?
08:32:58 <ttt_fff> f-a: oh man, http://www.haskellforall.com/2012/05/scrap-your-type-classes.html is evil
08:33:07 <clrnd> :P
08:33:08 <f-a> ttt_fff: it doesn't really. I'd rewrite/hammer the program not to use typeclasses (so you'd have map fmap gmap qmap etc
08:33:20 <merijn> What?
08:33:23 <merijn> Why is it evil?
08:33:35 <delYsid> f-a: Because you want to follow along while scrolling, possibly to look just at indentation or something.  I am tempted to ask back, why does your monitor need to refresh 100 times a second :-)
08:33:42 <ttt_fff> f-a: okay, so a typeclass named "foo" because foo_with_encoding_of_types_of_args_we're_calling_it_on_but_shorter ? :-)
08:34:06 <f-a> haha delYsid & ttt_fff 
08:35:18 <geekosaur> javskell?
08:39:43 <ski> greg` : you can also try "Interactive Tutorial of the Sequent Calculus" by ezyang at <http://logitext.mit.edu/logitext.fcgi/tutorial> ("Sequent Calculus Primer" by Alexander Sakharov in 2005 at <http://sakharov.net/sequent.html> also has some info on this)
08:40:05 <greg`> pass :D
08:41:36 <ski> greg` : "Sequent Calculus" and "Natural Deduction" are two common ways to present a logical proof/derivation/deduction/inference system. the latter exists in two variants, one mentioning ⌜⊢⌝ in the rules, the other not. all these systems have been applied in type theory and type systems
08:42:59 <ski> greg` : your question about ⌜Γ → Δ⌝ indicates you probably don't understand the difference between proposition and judgement. see <http://cstheory.stackexchange.com/questions/9826/what-is-the-difference-between-propositions-and-judgments>
08:44:35 <ski> greg` : <http://stackoverflow.com/questions/12532552/what-part-of-milner-hindley-do-you-not-understand> might also be useful (cf. with the Schwartzbach paper)
08:46:17 <ski> greg` : "Crash Course on Notation in Programming Language Theory" by Jeremy Siek in 2012-07-26 at <http://siek.blogspot.se/2012/07/crash-course-on-notation-in-programming.html> could also be interesting, more generally speaking
09:02:14 <merijn> I don't suppose there's anyone better at Trifecta than me around? :p
09:03:02 <bollu> merijn: what's Trifecta?
09:03:08 <merijn> Parsing library
09:03:26 <quchen> merijn: Edward?
09:03:36 <quchen> let isEdwardAround = True
09:03:41 <merijn> quchen: Yeah, but he's almost always asleep when I have questions :p
09:04:14 <quchen> Silly Americans, always sleeping during daytime in the Netherlands
09:05:13 <quchen> merijn: Are you just exploring Trifecta for the fun of it?
09:05:34 <merijn> quchen: I'm writing a parser for a project and using that as an excuse to figure out trifecta :p
09:06:02 <bollu> "A modern parser combinator library with slicing and Clang-style colored diagnostics
09:06:02 <bollu> "
09:06:05 <bollu> I LOVE you
09:06:11 <bollu> I am sooo using it for my language
09:06:26 <f-a> I hate writing parsers merijn, glad to see someone who takes pleasure in it xD
09:06:44 <quchen> merijn's error message from the other day was quite nice. Made me look at Trifecta's docs.
09:06:57 <merijn> quchen: And dive away in horror? ;)
09:07:14 <quchen> merijn: I didn't want to mention that part. But yes.
09:07:40 <merijn> It's not that bad when it clicks :p
09:07:45 <bollu> um, I think I just broke my setup by runniing "stack init" inside a folder with cabal
09:07:59 <bollu> how do I fix it?
09:08:15 <neptune_34444665> I want to block IP addresses from accessing my web server....how do I do this in apache?
09:08:15 <quchen> merijn: I also tried looking at Hoopl, which is apparently awesome but the Haddocks are bad. There's a paper about it that seems to be the best documentation.
09:08:30 <neptune_34444665> I am not using .htaccess since I am root on the server
09:08:33 <quchen> neptune_34444665: This channel is about Haskell, the programming language.
09:08:35 <quchen> Not htaccess.
09:08:54 <bollu> what is the stack equivalent of "cabal run" ?
09:09:04 <bollu> also, how do I "cabal install" with stack?
09:09:10 <quchen> merijn: I'd read a post about "how to make Trifecta click" :-þ
09:09:32 <quchen> merijn: But I guess that's just me being lazy, there ought to be a few small examples around that one can learn from
09:09:38 <bollu> oh, cool, "stack install" works
09:09:48 <bollu> what's the equivalent for "cabal run"?
09:09:56 <merijn> quchen: You can look at my example here: https://github.com/merijn/lambda-except/blob/master/Lexer.hs
09:10:20 <merijn> quchen: I'm trying to get it so I can highlight source lines in my type errors now, which is where my question is coming from
09:11:18 <merijn> Because, essentially I'm trying store location for everything, but naively using the "spanned" operator is also capturin whitespace, so I'm trying to figure out how to get rid of that...
09:13:28 <cocreature> bollu: stack exec
09:13:35 <bollu> cocreature: ty
09:13:47 <cocreature> bollu: but that does not rebuild, so you need stack build && stack exec if you want the exact same behavior as cabal run
09:15:57 <bollu> cocreature: stack exec needs a parameter?
09:16:33 <cocreature> bollu: yeah the executable name
09:18:42 <bollu> cocreature: stupid question - how do you find it?
09:19:31 <cocreature> bollu: it's in your cabal file
09:19:50 <bollu> cocreature: ty :)
09:20:40 <merijn> Actually, ircbrowse tells me edwardk should be getting online any time now... *pokes him*
09:22:13 <Taneb> merijn: edwardk gets online when edwardk gets online and no-one can change when that is
09:23:34 <hexagoxel> you can get, but not set, the time of his appearance
09:24:06 <cocreature> you would have expected that there is a lens that allows you to set it
09:26:25 <geekosaur> unsafeSummonEkmett >.>
09:27:36 <merijn> :p
09:30:50 <quchen> merijn: Sounds like a sibling of a problem I've been having: annotating a syntax tree with source location. Standard "Fix" catamorphism magic wouldn't work because it's a complex beast and I'd have to compose several functors.
09:30:56 <td123> so i was looking into "DeriveGeneric" and I was wondering if I could use a similar representation to build types at runtime and then use them at runtime
09:31:15 <quchen> I was enlightened as to why GHC uses Located and not some cooler solution.
09:31:28 <merijn> quchen: I tried fixing that
09:31:37 <merijn> quchen: I gave up after talking to edward
09:32:16 <quchen> Yeah, the papers that I've read weren't very encouraging either
09:33:03 <quchen> It's *so* pretty for a simple recursive tree
09:33:19 <quchen> Quite sad really. 
09:33:37 <quchen> Usually when FP is sad Okasaki has a paper about how wrong I was thinking that.
09:33:52 <merijn> I gave up on the Free based AST too
09:34:13 <quchen> So what did you settle for?
09:34:35 <merijn> Just a hardcoded Expr type
09:34:51 <td123> I guess I'm asking, is there a way haskell can let me construct algebraic data types that allow me to manipulate and analyze them at runtime
09:35:07 <quchen> merijn: "Hardcoded" in what sense?
09:35:20 <quchen> merijn: Sprinkle explicit "SrcLoc"s all over the place in the constructors?
09:35:27 <merijn> quchen: https://github.com/merijn/lambda-except/blob/master/AST.hs#L48-L56
09:35:27 <quchen> Parametrizing Expr with Annotation?
09:35:45 <merijn> Loc all over the place and explicit recursive ADT instead of Free based
09:35:48 <td123> I've looked into interpreters but I think it should be possible to do this all statically in the same program
09:35:55 <merijn> So results in hardcoding the Monad instance too
09:36:00 <Cale> td123: I'm not sure what you mean
09:36:15 <Cale> td123: You can use the GHC Generics types directly.
09:36:34 <Cale> td123: Types only exist at compile time in Haskell
09:36:48 <Cale> td123: They aren't a runtime thing, they all get removed by compilation.
09:37:22 <ggole> You could pull the Loc out as an element of a pair rather than repeat it for every constructor
09:37:50 <merijn> quchen: The problem I have is that everything uses "token" from the TokenParsing class in parsers, which consumes white space too. So anything like "spanned :: DeltaParsing m => m a -> m (Spanned a)" is also including the white space in the pan
09:37:54 <quchen> ("No types at runtime" actually means "no types", unlike e.g. Java.)
09:38:08 <merijn> ggole: Yeah, but end up being a more annoying hassle to deal with
09:38:47 <Gurkenglas> merijn, could you do Expr = (Loc, Expr') and have Expr' be 48-56 without all the Loc?
09:38:58 <Gurkenglas> Whoops, hivemind.
09:39:16 <quchen> This was my naive solution, http://lpaste.net/141999
09:39:21 <ggole> merijn: seems more tedious than difficult
09:39:22 <quchen> i.e. the sprinkler
09:39:25 <merijn> That was my initial approach, together with using a Free based AST, but like I said, ended up having so much boilerplate it was tedious
09:39:33 <ggole> Right
09:39:40 <merijn> ggole: I said "annoying hassle", i.e. tedious, not difficult :p
09:40:22 <merijn> But yeah, I need to somehow figure out how to strip the whitespace of my spans for nice highlighting and it's not obvious how
09:40:34 <merijn> In general I'm not very happy with how the "token" thing works anyway
09:40:44 <quchen> Hahaha, Text.Trifecta.Parser.unparser
09:41:17 <quchen> It's really hard to tell which part is internal and which is normal API in that package
09:41:26 <quchen> I'm hoping unparser is far from user space
09:41:33 <merijn> quchen: I've not had to use it :p
09:42:47 <cocreature> I found the best way to use trifecta is by not looking at the docs and trying to use it like parsec
09:44:12 <delYsid> megaparsec looks nice.
09:53:23 <merijn> quchen: Best thing I can come up with is modifying "token" to store the end of the last parsed token and using that for as end for my span
09:53:33 <merijn> But that feels hacky
10:03:47 <broma0> Any idea why I'm seeing this error after adding a local dependency with 'cabal sandbox add-source' and running a repl? 'can't load .so/.DLL'
10:04:33 <broma0> the error refers to the local dep i added
10:09:51 <ttt_fff> paf31: why is Tokens parser a list of Tokens, rather than an Array of Tokens + an index to current token ?
10:10:26 <paf31> ttt_fff: wrong channel?
10:10:34 <ttt_fff> wrongchannel
10:14:26 <aweinstock> If I have a (Conduit a m b) and a (Conduit b m a), is there any fixpointy way to tie them together? (e.g. 2 processes, have each read from the other's output)
10:18:08 <firstglitch> Can someone please take a quick look at the code  of my first Haskell package,  https://bitbucket.org/sras/hastily/src  ?  
10:19:56 <johnw> aweinstock: sure there is
10:20:13 <johnw> aweinstock: write your own operator that evalutaions the Conduit data types directly, passing the data back and forth
10:20:18 <johnw> evaluates*
10:20:35 <johnw> you can see how `connect` does it for the unidirectional flow case
10:20:54 <johnw> but I don't think this functionality is in conduit already
10:21:33 <johnw> also, what will happen if the first one produces two outputs, but the second only reads a single input before it produces more output
10:21:41 <johnw> you'll probably need two queues
10:23:23 <xplat> aweinstock: if you want things that are *made* to be tied together in a fixpointy way like that, try hyperfunctions!
10:25:17 * ski . o O ( `data Hyper f a b = Hyp (a -> b) (Hyper f (f a) (f b)' ? )
10:25:26 <johnw> not quit
10:25:36 <aweinstock> xplat: hyperfunctions looks like it's beyond my understanding for now
10:25:46 <johnw> Hyper a b = Hyper a b -> a -> b
10:25:50 <johnw> or something along those lines
10:26:05 <johnw> unless I misunderstood your representation, ski
10:26:54 <aweinstock> also, the documentation for conduits suggests that ($=), (=$) and (=$=) are all the same, but were different historically; where can I read about that (the symbols are kind of difficult to search for)
10:27:06 <ski> johnw : that looks dangerously non-monotonic / non-positive
10:27:26 <johnw> um, (Hyper a b -> a) -> b
10:27:28 <johnw> oops
10:27:47 <ski> hm, that looks a bit like "`W'-types"
10:27:54 <johnw> yeah, doesn't it though?
10:28:01 <Cale> newtype Hyper a b = Hyper (Hyper b a -> b)
10:28:17 <johnw> yep, and if you unfold one level of the innermost Hyper...
10:28:38 <johnw> newtype Hyper a b = Hyper (((Hyper a b) -> a) -> b)
10:29:19 <k0001> Question: If I compile a library/executable with profiling enabled, but then don't use any of the profiling features at runtime: Is there any penalty on the performance of the generated code?
10:29:43 <bennofs> k0001: yes, GHC disables some optimaztions when compiling with profiled enabled
10:30:38 <bennofs> k0001: in particular, I believe it has to do with not being able to move subexpressions in/out of a cost centre, since that would skew profiling results
10:30:41 <Cale> If you enable library profiling with Cabal, it builds both versions for you
10:30:49 <obadz> ghc-mod with -fdefer-type-errors is sooooo good.
10:30:54 <obadz> just sayin...
10:30:57 <xplat> aweinstock: basically they were different when conduits was 'the practical iteratees'--somewhere along the way it turned to 'the practical pipes' and they're no longer different
10:31:36 <k0001> bennofs: ahh, I see. Thanks.
10:33:13 <bennofs> xplat: is pipes not pratical? :(
10:33:25 <xplat> aweinstock: iteratees was a design by oleg kiselyov that is primarily based on a producer abstraction and a consumer abstraction and an abstraction (=$=) to tie them together.  things that go 'in the middle' were sort of an addon and had to be composed from the ends inward.
10:33:40 <johnw> pipes is quite practical
10:34:10 <johnw> I think that conduit sacrifices type clarity for more features
10:34:22 <xplat> johnw: it wasn't when conduit first adopted its abstractions
10:34:25 <johnw> whereas pipes sacrifices YOU for type clarity
10:34:25 <k0001> Cale: thanks.
10:34:37 <johnw> xplat: I can believe that
10:34:49 <xplat> johnw: especially since that was back when gabriel rewrote it incompatibly every month or two
10:36:47 <obadz> lots of overlap between dates:Data.Dates.DateTime and time:Data.Time.. is there one that's preferred?
10:37:28 <xplat> aweinstock: pipes was/is a design by gabriel gonzalez that treats producers/consumers as special cases (not using one end) of transformers, and has 'plugging two transformers together' as its basic operation, which served the purposes of =$, $=, =$=, as well as some none of those could do
10:39:06 * hackagebot crypto-enigma 0.0.1.7 - An Enigma machine simulator with display.  https://hackage.haskell.org/package/crypto-enigma-0.0.1.7 (Orome)
10:44:04 <shapr> Do any of the mysql libraries have Arbitrary instances?
10:45:13 <emmanuel_erc> hello everyone!
10:47:22 <oldnemo> hey guy's :)
10:50:42 <thimoteus> is Applicative really only 7 years old? I'm looking at this paper: http://staff.city.ac.uk/~ross/papers/Applicative.html
10:50:53 <johnw> thimoteus: 2006 it was?
10:50:59 <johnw> or 2008?
10:51:13 <thimoteus> paper says it was published 2008
10:51:39 <johnw> that sounds about right then
10:51:51 <thimoteus> wow, i would've thought they'd be older. they seem so fundamental now
10:56:26 <bennofs> 7 years in haskell is a lot :p
10:59:23 <maerwald> bennofs: only because we have people like edward who throw out CT stuff that others would need a decade for :/
10:59:58 <paldepind> maerwald, how so?
11:00:21 <maerwald> I'm just saying there are some extemely smart people in haskell, so quite a high bus factor :P
11:02:25 <paldepind> maerwald, indeed yes.
11:03:14 <hiptobecubic> I think people forget that kind of thing too quickly when talking about languages. Philosphy of the community makes a big difference
11:03:20 <hiptobecubic> Philosophy*
11:03:25 <johnw> absolutely
11:03:44 <obadz> Live feed starting now: https://www.youtube.com/watch?v=de-bbvzsr6U
11:03:59 <johnw> obadz: live feed of what?
11:04:04 <johnw> i don't click random youtube links
11:04:13 <obadz> it's pr0n!
11:04:14 <clrnd> I do, yupi
11:04:15 <hiptobecubic> There are some really smart people working on Python too, but the notion that things should be "rigorous" just isn't there.
11:05:12 <johnw> hiptobecubic: and there are some things (concurrency, ahem) that those smart people apparently just don't like, and so no intellectual effort is expended there.  We'll go after just about any crazy idea, so long as the rigour is there
11:05:54 <maerwald> hiptobecubic: so, would you say that haskells unstable API problems which are the reason for stuff like stack comes from the philosophy of the community? ;)
11:06:12 <hiptobecubic> johnw, the concurrancy story in python confuses me even today. I know the arguments made against remove the GIL for example, but I still don't see why python is unique there.
11:06:46 <hiptobecubic> maerwald, unstable *API* comes from too much research :) Not a lack thereof
11:07:08 <maerwald> and it makes haskell very difficult for deployment indeed
11:07:32 <hiptobecubic> Honestly i think python is no better
11:07:36 <maerwald> sure it is
11:07:41 <maerwald> but not THAT much better
11:08:24 <hiptobecubic> it's "better" in the sense that duck typing lets you take more risks
11:08:40 <maerwald> not only that... it's also about the ecosystem of libraries
11:08:53 <hiptobecubic> it's not better in the sense that breaking changes are often poorly understood and their interactions even less so
11:08:56 <thimoteus> obadz: is this being recorded?
11:08:58 <johnw> Haskell was never created to success commercially, where things like stability are kind
11:09:02 <johnw> succeed*
11:09:15 <obadz> thimoteus: pretty sure
11:09:15 <johnw> it was created to explore ideas, and people found that it's also cool for production work
11:09:16 <hiptobecubic> maerwald, the breadth of libraries in python is outstanding. totally agree.
11:09:28 <johnw> obadz: so what is the live stream of?
11:09:32 <thimoteus> awesome, then i can check it out later. thanks!
11:10:06 <bennofs> "
11:10:07 <maerwald> hiptobecubic: I don't just mean the breadth, but the fact that you don't get ~300 broken packages every two weeks because a library maintainer made a version bump
11:10:08 <bennofs> Functional Programming for the Web meetup, September 2015
11:10:11 <bennofs> is the youtube video title
11:10:15 <obadz> johnw: kris jenkins on elm followed by a haskell talk
11:10:16 <johnw> thanks, bennofs 
11:10:43 <hiptobecubic> maerwald, but you do, is what I'm saying. They just don't all fail at deploy time, they fail intermittently over the coming weeks as rare code paths are finally hit
11:10:53 <maerwald> hiptobecubic: nah
11:11:02 <maerwald> I would know if it is that bad
11:11:23 <hiptobecubic> So you have things like pandas deciding that Series is no longer going to subclass ndarray, which silently breaks all kinds of code out there, but *just barely* so you don't notice at first.
11:11:45 <maerwald> we notice, because we test the applications in distros
11:11:55 <maerwald> it's still ~10 times less
11:11:57 <nitrix> class Monad m => MonadState s m | m -> s where
11:12:00 <nitrix> What does that | means?
11:12:07 <johnw> functional dependency
11:12:18 <johnw> it says that a choice of m fixes the choice of s
11:12:27 <johnw> if you have MonadState Int IO, then you can't have MonadState Char IO as well
11:12:47 <johnw> said another way, each 'm' only has one kind of state visible
11:13:00 <hiptobecubic> maerwald, my point is that you can achieve sudden python-like upgradeability by just pretending there are no version constraints at all and running your tests.
11:13:15 <hiptobecubic> And if that sounds like a bad idea, then it's a bad idea everywhere.
11:13:42 <maerwald> hiptobecubic: my experiences disagrees
11:14:33 <srhb> It's pretty close to a logical implication though.
11:14:47 <hiptobecubic> Why do you think people use requirements.txt? stack takes the same approach.
11:15:21 <maerwald> the times I had to fix my haskell code because libraries changed something is 10 times that high compared to any other project I have been working on
11:15:43 <maerwald> >=foo-1.2 deps don't work very well in haskell eco system
11:15:52 <tommd> maerwald: Other projects ihn other languages?
11:15:57 <maerwald> yes
11:16:08 <nitrix> Were the other projects also libraries?
11:16:16 <maerwald> if you pretend there are no version constraints, you will just get more build failures
11:16:32 <maerwald> nitrix: I am talking about applications that use libraries
11:16:39 <bennofs> maerwald: well, but couldn't you have used an upper bound and continue to use the old version?
11:16:40 <ttt_fff> I heard that precedence parsing can be expressed in terms of chainl and chainr
11:16:47 <nitrix> maraoz: In which case, I suspect you were just less worried about major version breakage.
11:16:48 <maerwald> bennofs: upper bounds are the worst
11:16:54 <nitrix> maerwald: ^ *
11:16:55 <ttt_fff> I heard that precedence parsing can be expressed in terms of chainl and chainr (in the context of parsec / precedence / binops / infix notation / shunting yard) -- how do I do this?
11:17:08 <maerwald> which is exactly what I was saying in the beginning... you barely need upper bounds in the python ecosystem
11:17:19 <bennofs> maerwald: why? if you want, new cabal versions allow you to ignore an upper bound: --allow-newer=pkgname
11:17:22 <johnw> ttt_fff: what is "precedence parsing"?
11:17:40 <maerwald> bennofs: so I get a build failure now, what does that improve? ;)
11:17:41 <ttt_fff> johnw: https://en.wikipedia.org/wiki/Operator-precedence_parser
11:17:54 <nitrix> maraoz: You need them equally the same with python or haskell; it's just that we minimize the risks here.
11:17:54 <bennofs> maerwald: upper bounds allow us to evolve libraries, and not be forced to stick with a bad initial design just for the staying backwards compatible
11:17:57 <johnw> chainl will let you do left-recursion
11:17:58 <nitrix> maerwald: ^
11:18:18 <maerwald> bennofs: I know what they are for
11:18:20 <johnw> or you can just use the tokenizing features of Parsec and get automatic operator handling with precedence tables
11:18:21 <nitrix> maerwald: : You need them equally the same with python or haskell; it's just that we minimize the risks here.
11:18:22 <bennofs> maerwald: the idea would be that the cabal solver can pick an older version and your application actually builds (just not using the latest-greatest-everything)
11:18:32 <maerwald> nitrix: no, you don't need them equally the same
11:18:53 <johnw> see http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Token.html
11:19:04 <maerwald> nitrix: that goes against all my experience as a distro developer
11:19:24 <maerwald> haskell is the number one language that needs upper bounds on distro level, so things don't break
11:19:43 <maerwald> upper bounds then cause the dependency graph to become very complicated
11:19:48 <maerwald> and you get lots of unsolvable conflicts
11:19:51 <srhb> It would be rather unsurprising if Haskellers tend to break interface compatibility more, since it's so safe.
11:19:51 <nitrix> maerwald: I think you're confused. Versoning is a concept, not a language feature. Thus, languages that uses versoning for package dependencies all have to deal with the same concerns.
11:19:55 <maerwald> hence cabal sandboxes, stack and nix and whatnot
11:20:05 <maerwald> that's all an ecosystem problem in the end, not a tool problem
11:20:13 <hiptobecubic> maerwald, I don't understand how you deploy python. Are you just installing whatever pip happens to find or are you using requirements.txt and version pinning? If the former, then your code not crashing just means that libraries aren't changing much, which I'll happily put up with for new features. If the latter, then you are just implementing your own little stackage inside each project and I don't see what
11:20:14 <nitrix> maerwald: They are necessarily equal, they just differ in their approach. Haskell takes a safer conservative approach with upper bounds.
11:20:15 <hiptobecubic> the issue is.
11:20:19 <maerwald> nitrix: I'm not confused at all :)
11:20:31 <nitrix> I insist that you are.
11:20:36 <maerwald> good
11:20:40 <ttt_fff> johnw: I've used Parsec's buildExpressionGrammar; I'm trying to understand how it works
11:20:53 <johnw> ttt_fff: ok
11:20:57 <maerwald> hiptobecubic: I use the distro package manager
11:21:07 <maerwald> for haskell that is almost impossible unless you use nix
11:21:22 <maerwald> the reason is the broken dependency graph
11:21:34 <maerwald> and upper bounds do play a huge role there
11:21:56 <srhb> Surely any distro can do as nix or stackage or whatever and have a consistent package set.
11:21:59 <bennofs> maerwald: well, do you have a compiled language to compare against, that also does cross-package inlining? because that complicates things a little bit
11:22:12 <maerwald> srhb: it's not that easy to do what nix does...
11:22:42 <maerwald> and most distros unfortunately don't get inspired by that technological achievement
11:22:51 <johnw> dcoutts showed me a version of cabal on his machine doing much of what Nix does, btw
11:22:55 <srhb> Well, stackage then.
11:23:03 <maerwald> that made it worse for me, even
11:23:03 <johnw> it was a cabal-private Nix store, effectively
11:23:06 <srhb> That's the important thing, re. your complaint about distros. :)
11:23:13 <maerwald> I cannot build any of my personal projects with stack, because it lacks libraries
11:23:15 <srhb> johnw: I heard about that. pretty cool.
11:24:26 <nitrix> maerwald: That'd be because you're using stack incorrectly. It only apply constraints on a given list of packages, namely this: https://www.stackage.org/lts-2.22/cabal.config
11:25:03 <nitrix> maerwald: Everything else works normally, since it's cabal underneath. You must've missed a bit of the documentation.
11:25:05 <maerwald> bennofs: mhh, my point is that haskell libraries are not maintained in the same over-careful and backwards-compatible way like common C libraries are. And this is not about the ABI problem even...
11:25:33 <nitrix> maerwald: They are. They all have minor and major versions.
11:25:39 <ttt_fff> johnw: ok
11:25:43 <maerwald> nitrix: what?
11:25:44 <bennofs> maerwald: ofc, I agree that the haskell community is much more willing to do things right than favour backwards compat
11:25:56 <nitrix> maerwald: Haskell, and, C, libraries, all, have, minor, and, major, versions.
11:26:01 <maerwald> nitrix: I know
11:26:07 <maerwald> bennofs: yeah, it has pros and cons
11:26:23 <nitrix> Then how can you say it's not backwards-compatible or things like "over-careful".
11:26:24 <maerwald> but I wish it would go more into the compatibility direction
11:26:51 <srhb> nitrix: I think the point is that regardless of indicating interface change with version numbers or not, there are just more breaking interface changes.
11:27:02 <bennofs> maerwald: but, I thought that most authors at least try to follow PVP? So putting major-version upper bounds should work in most cases, no? (really interested to know where it fails. Are you using so many libraries that also have lower bounds on these deps?)
11:27:02 <srhb> That sounds like a reasonable observation.
11:27:36 <maerwald> bennofs: I probably use too many... but that again is a haskell thing, because haskell is so modular, why would you not use ~100 libraries?
11:27:56 <maerwald> in C you barely go over 5 for small projects
11:27:58 <nitrix> Fair enough. That's the reality of any software though if you don't want to accumulate technical debt. Besides, packages on Hackage are frozen so he could use a old version forever if he wanted to.
11:28:37 <srhb> Sure, it is a trade off.
11:28:38 <nitrix> Saying he was _forced_ to update his library is stretching it.
11:29:02 <bennofs> maerwald: well, if you want, you can even just pin all dep versions and then don't worry until you need to add a new dep
11:29:24 <srhb> But again, you add a library that needs newer versions and since you can't depend on two version of the same package...
11:29:28 <cmperez> noob question: I'm trying to take a [String] and break them up into a [[String]] based on whether the string is a line break
11:29:31 <srhb> I mean, it _is_ a tradeoff, as stated.
11:29:36 <srhb> cmperez: see lines
11:29:39 <srhb> :t lines
11:29:41 <lambdabot> String -> [String]
11:29:47 <cmperez> I got the lines
11:29:52 <srhb> Oh, sorry.
11:29:54 <cmperez> that's the [String]
11:30:47 <srhb> cmperez: Then I'm not sure what you want to do. Can you give a small example?
11:30:53 <cmperez> sure sure
11:31:15 <cmperez> I have a lot of lines, and every so often there's a line break
11:31:20 <nitrix> cmperez: If [String] was constructed based on newlines using `lines`, then there's technically no other newlines to be split on to create a [[String]].
11:31:21 <bennofs> maerwald: and that why in C everyone reinvents the wheel :p
11:31:26 <maerwald> right...
11:31:34 <maerwald> and you get more interesting bugs!
11:31:49 <srhb> Pah, I got all my interesting bugs back by misusing the FFI.
11:31:54 <srhb> So C doesn't have THAT on me!
11:31:57 <cmperez> and I want to concatenate each line with the next, unless the line is a newline
11:32:13 <cmperez> in which case, I want to start a new String and start concatenating fresh from there
11:32:19 <cmperez> ultimately getting back a [[String]]
11:32:22 <bennofs> maerwald: just wondering, is it really the case for you that you need to use libraries which depend on newer versions which cause build failures? (i.e. the build failure could not be fixed by adding appropriate upper bounds)
11:32:27 <srhb> cmperez: Sounds like you want some of the groupBy functions
11:32:37 <cmperez> ah I'll check that out
11:33:02 <srhb> Or even just a fold.
11:33:12 <srhb> Actually that'll probably be a bit hassly.
11:33:13 <cmperez> tru
11:33:35 <bennofs> maerwald: I'm just a hobby haskell user so I suppose I don't really have the problems you get when dealing with larger haskell projects :D
11:33:35 <nitrix> cmperez: From your explanation, it sounds like the resulting type would be [String], not [[String]].
11:33:37 <maerwald> bennofs: sure you can use upper bounds, but as said... upper bounds are evil. And on distro level, you don't have sandboxes anyway, unless you use nix
11:33:59 <maerwald> bennofs: uh, I'm just a hobby haskeller too
11:34:05 <cmperez> nitrix: my bad, you're right
11:34:15 <maerwald> it's just that I also tried to deploy a few haskell things
11:34:15 <nitrix> cmperez: Because of the concatenation. Otherwise, it's just grouping.
11:34:21 <maerwald> and happen to work on a linux distro
11:35:27 <maerwald> I ended up using cabal sandboxes in docker
11:35:30 <bennofs> maerwald: well, can't the distro just hold back a package update until the other packages updated? I believe distros also sometimes have two versions of some C lib IIRC ?
11:36:08 <maerwald> bennofs: not on source distros (except for library sonames that are for binary compatibility... but you cannot build against them)
11:37:41 <maerwald> bennofs: reality with haskell on system-level is that you get too many "nah, cannot install both apps at the same time, because there is no solution for the dependency graph, because of conflicting library version requirements"
11:37:59 <maerwald> again... except you use nix
11:38:27 <bennofs> maerwald: nix doesn't really solve that. if your transitive dependency set includes two versions of the same lib, your doomed no matter what
11:39:18 <maerwald> bennofs: oh, it has very nice chrooting support
11:39:40 <bennofs> maerwald: yeah, but if you need two versions of one lib in one application, it won't work with nix either
11:40:31 <maerwald> bennofs: nah, I mean two versions of one lib for two different applications
11:40:41 <maerwald> and there is no common version range for the lib
11:40:48 <maerwald> so the PM just says "no"
11:41:26 <bennofs> oh ok. right, that case nix can handle. it might still require lots of rebuilds though :p
11:41:44 <maerwald> exactly, but the point was... you barely have that problem with python packages
11:42:11 <lpaste> zuserm pasted “Weird? Data Family / Closed Type Family behavior.” at http://lpaste.net/142004
11:42:29 <maerwald> but yeah, "duck typing" might play a role there, or implicit type conversion and whatnot
11:42:29 <bennofs> maerwald: yes, though providing multiple versions is much easier with python packages as well (no recompilation needed)
11:42:55 <zuserm> hey folks, I was wondering if anyone could explain what's going on in that paste
11:42:56 <maerwald> so stuff doesn't break as easily as in haskell, just because the interface changed a bit
11:43:07 <maerwald> ofc its debatable whether that is good
11:44:16 <bennofs> I wonder how much of breaking changes could be automatically refactored via refactorings provided by the package itself using HaRe or so
11:44:55 <alanz> bennofs: That is something we want to investigate. One HaRe stabilises
11:45:19 <alanz> Possibly using something similar to hlint / apply-refact
11:48:18 <maerwald> would this be automated on infrastructure level? e.g. library maintainer bumps version... build bot tries to refactor automatically... if it succeeds, push the new application version
11:48:42 <mniip> "build bot tries to refactor automatically"
11:48:47 <mniip> what a perfectly sane and safe idea!
11:48:56 <maerwald> I thought that was the point of HaRe
11:49:09 * hackagebot git-annex 5.20150930 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20150930 (JoeyHess)
11:49:38 <maerwald> mniip: time to test the slogan "if it typechecks, it works" I hear so often in this channel ;)
11:49:59 <alanz> maerwald: I have in mind some kind of format (similar to a hlint hint) that maintainers can use to specify changes required as a new version of a package comes out
11:50:13 <mniip> maerwald, pi :: Double; pi = 0.0
11:50:37 <maerwald> mniip: right, I have never actually propagated that slogan...
11:50:43 <bennofs> alanz: use SafeHaskell and let use write real haskell code for refactoring! (package maintainers can already execute arbitrary code using TH, so nothing lost there)
11:50:58 <maerwald> mniip: we would have to assume there are actual tests too
11:51:13 <alanz> ok, it is still all conceptual at the moment, haven't had time to look in earnest
11:51:23 <bennofs> maerwald: I think it would work more like this: you type cabal fix in your repository and it will automatically bump deps + refactor your code, you review and release a new version if neccessary
11:52:11 <mniip> bennofs, eventually there will be a 'cabal implement'
11:53:05 <bennofs> mniip: right, with Dependent Haskell, we're getting there... write the specification and generate the code. But now the specification is the new code ...
11:56:34 <nitrix> I would find interesting a Haskell editor that'd use hole-driven development and make sensible recommendations to fill the hole.
11:57:35 <srhb> yessss.
11:57:49 <nitrix> (Because just matching types isn't enough to cover semantics)
11:58:01 <bennofs> nitrix: not sure you know, but some dependently typed languages have that
11:58:09 <maerwald> nitrix: I think your best bet is leksah, but I doubt they already have real hole-driven development
11:58:21 <phaazon> @hoogle Float -> Int
11:58:23 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
11:58:24 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
11:58:24 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
11:59:15 <predator117> :t floor :: Float -> Int
11:59:16 <lambdabot> Float -> Int
11:59:20 <predator117> :t ceil :: Float -> Int
11:59:21 <phaazon> yeah
11:59:22 <lambdabot> Not in scope: ‘ceil’
11:59:27 <phaazon> but I’d like to use something different
11:59:28 <nitrix> phaazon: https://www.haskell.org/hoogle/?hoogle=%28RealFrac+a%2C+Integral+b%29+%3D%3E+a+-%3E+b
11:59:30 <phaazon> I’m profiling my application
11:59:38 <phaazon> and turns it floor allocates a LOT of memory :/
11:59:43 <predator117> phaazon: nevermind then ;)
12:00:13 <nitrix> phaazon: Maybe truncate instead of floor?
12:00:46 <cocreature> zuserm: that looks like a bug to me, especially since it works in ghc master
12:01:03 <cocreature> zuserm: btw is there any usecase for a data family without a parameter? I didn't even know that was possible
12:01:08 <nitrix> bennofs: Any language comes to mind? Sounds interesting.
12:01:24 <cocreature> idris has that
12:01:28 <cocreature> I'm sure agda too
12:02:23 <chpatrick> cocreature: doesn't sound like much of a family
12:02:50 <cocreature> chpatrick: yeah that's what confuses me
12:03:06 <cocreature> you're basicaly creating a new type with no inhabitants
12:03:20 <chpatrick> wouldn't it be a plain old data type?
12:03:27 <chpatrick> with no parameters
12:03:43 <chpatrick> can you make a data instance?
12:03:43 <cocreature> I think so
12:03:56 <cocreature> you can use data family F
12:03:59 <cocreature> data instance F = F
12:04:06 <cocreature> which is what zuserm had in his code
12:04:15 <cocreature> but why you would want that is beyond me
12:04:26 <chpatrick> that's bizarre
12:04:33 <chpatrick> I guess it makes sense so they allowed it
12:04:41 <chpatrick> but I have no idea why you wouldn't just use a data type
12:05:04 <cocreature> it's not even a particulary interesting datatype, it's just void
12:05:10 <chpatrick> wait what
12:05:14 <chpatrick> I can make multiple instances in ghci
12:05:37 <cocreature> I can't do that if I load a file
12:05:45 <chpatrick> that's really weird
12:05:57 <chpatrick> I mean you'd never be able to get anything out of it right?
12:07:02 <cocreature> ghci seems to just override the instance
12:07:06 <cocreature> if you declare it multiple times
12:09:50 <phaazon> hm
12:09:53 <phaazon> if I have something like
12:10:23 <phaazon> f x = sum (fmap …)
12:10:28 <phaazon> can I turn that strict with
12:10:36 <phaazon> f !x = let !r = sum (fmap …) in r
12:10:36 <phaazon> ?
12:13:29 <nshepperd> are data families just like open GADTs?
12:13:36 <dolio> `let !r = ... in r` is the same as `let r = ... in r`
12:14:40 <mniip> nshepperd, nothing like it
12:14:42 <dolio> And no, data families are not like open GADTs.
12:16:07 <nshepperd> hmm
12:16:10 <dolio> GADTs allow pattern matching on constructors to refine indices, whereas data families allow pattern matching on indices to tell you which constructors are available.
12:16:40 <seagreen> Is there a nice tool for pretty printing HTML in haskell? I'm actually starting with a Lucid `Html`, but I can turn it into a `Text` and then parse it into some other data type if necessary, performance doesn't matter in my case.
12:17:06 <sinelaw> blaze-html has something, maybe IIRC
12:17:18 <dolio> A data instance can be a GADT, though.
12:17:25 <johnw> dolio: what is pattern matching on indices?
12:17:29 <nshepperd> oh, data families only accept one instance per value of the argument
12:17:32 <johnw> I thought that the choice of index didn't need a pattern match
12:17:47 <dolio> You pattern match on indices using type classes.
12:18:01 <dolio> That's how you do all pattern matching on types to produce values.
12:19:07 <seagreen> sinelaw: It's Text.Blaze.Renderer.Pretty. Thanks!
12:19:23 <sinelaw> :)
12:20:03 <phaazon> does sum build up thunks?
12:20:14 <seanw> Hi all.  I want to use the "cpython" package but that builds against an ancient version of Data.Text.  Is it impossible to have my cpython dependency depend on one version of Text and other dependencies (or even my project itself) depend on a more recent version?
12:20:28 <seanw> That is: must all my dependencies that themselves depend on text depend on the same version of text?
12:21:18 <zuserm> @cocreature Thanks! I thought it might be a bug. I tried the latest release, but hadn't tried master. My original code had a parameter to the data family, I just removed it to simplify the code snippet.
12:21:19 <lambdabot> Unknown command, try @list
12:21:22 <nshepperd> phaazon: possibly. you might want foldl' (+) 0
12:21:29 <zuserm> gotta run
12:21:34 <Hijiri> seanw: if the deps were different, Text used in cpython might have a different representation that the one used in your package, for example
12:24:42 <the_2nd> I want two different programs flows depending on whether a maybe is nothing or just x
12:24:54 <the_2nd> within a do
12:25:31 <cocreature> the_2nd: use case
12:26:29 <bennofs1> the_2nd: use case yourMaybeValue of Nothing -> do bla  ...  Just x -> do bla  ?
12:26:37 <bennofs1> (with line breaks added ofc)
12:28:20 <_ikke_> 9/close
12:28:44 <seanw> Hijiri: ah yes.  They're going to interact badly.  Is my only option to try to hack on cpython to bring it up to speed?
12:29:11 <Hijiri> seems like it, unless there are newer bindings somwhere
12:33:19 <the_2nd> bennofs, parse error on input
12:33:24 <the_2nd> paste comming
12:34:34 <the_2nd> bennofs, http://pastebin.com/DSyAD2yE
12:35:47 <seanw> Hijiri: okay thanks for your input :)
12:38:10 <bennofs> the_2nd: the Just x  part must start on the same column as the Nothing
12:38:26 <bennofs> the_2nd: currently, the J is under the o from Nothing
12:38:57 <the_2nd> bennofs, damn editor failing me :D
12:42:32 <the_2nd> bennofs, enableplots is of type https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Internal-Lazy.html
12:42:56 <the_2nd> can I just do a if enablePlots == empty then else ?
12:44:44 <phaazon> hey
12:44:54 <phaazon> in the .prof file
12:45:01 <phaazon> what does the MUT row stand for?
12:45:23 <bennofs> the_2nd: you can use Data.Text.Lazy.null to check if a text is empty (returns True if it is empty) as well 
12:45:45 <bennofs> phaazon: MUTator, time spent evaluating stuff I think
12:45:52 <bennofs> phaazon: can you show the prof file?
12:46:07 <phaazon> yeah
12:46:16 <phaazon> http://lpaste.net/1089431726079344640
12:46:33 <phaazon> I’m trying to fix totalProbability
12:46:38 <ttt_fff> anyone have an example of APL parser in parsec ?
12:46:38 <phaazon> http://lpaste.net/142005
12:46:46 <phaazon> I don’t see why it allocates that much memory
12:46:57 <phaazon> and why it spends so much CPU time…
12:47:10 <ttt_fff> laziness
12:47:28 <phaazon> http://lpaste.net/142005
12:47:34 <phaazon> getProbability is there as well
12:47:36 <phaazon> ttt_fff: hm?
12:47:39 <phaazon> which function is lazy?
12:47:40 <phaazon> sum?
12:47:55 <the_2nd> bennofs, my bad, seems to be :
12:48:31 <the_2nd> https://hackage.haskell.org/package/happstack-server-7.4.4/docs/Happstack-Server-RqData.html  lookText -> ... -> m Text
12:48:32 <bennofs> phaazon: where do you see a MUT row there?
12:48:40 <phaazon> bennofs: it’s the -s output, wait
12:49:11 <phaazon> bennofs: http://lpaste.net/142007
12:49:11 <bennofs> phaazon: ah ok, yes in that case MUT is the mutator (i.e. evaluation) time (as opposed to time spent garbage collecting etc)
12:49:12 <phaazon> there
12:49:28 <phaazon> ok, so it sounds pretty ok then
12:50:09 <bennofs> phaazon: yeah, 92.5% productivity sounds good
12:50:16 <phaazon> ok
12:50:29 <phaazon> then, I don’t get why my function creates so many thunks
12:50:34 <bennofs> also only 2MB total in use, so I think memory is ok
12:50:34 <phaazon> or allocates so much memory
12:50:44 <phaazon> look at the trace
12:50:56 <phaazon> everything happens at line 46
12:51:03 <phaazon> http://lpaste.net/1089431726079344640#line46
12:51:36 <bennofs> phaazon: hmm, wait did it says total alloc=61GB? wow
12:51:55 <phaazon> geez
12:51:55 <bennofs> ah ok, that's total allocated, not maximum usage
12:51:59 <phaazon> yeah it says that
12:52:10 <monochrom> oh! I remember now. "mutator" is GC-centric terminology. CPU time is split between GC and real work. the GC-centric view calls real work "mutator". this is true for all GC, e.g., you can say that for Java too
12:52:14 <Enigmagic> phaazon: take a look at sum, it used to be problematic
12:52:21 <phaazon> ah
12:52:25 <phaazon> I thought it was pretty good
12:52:32 <phaazon> like, a strict fold
12:52:43 <Enigmagic> might be fixed now, back in the day it wasn't
12:53:04 <bennofs> phaazon: just wondering, where do you see thunks build up in that output? does't immediately look out to me that there is a thunk buildup
12:53:21 <phaazon> I don’t
12:53:26 <phaazon> just guessing
12:54:12 * hackagebot nix-eval 0.1.0.2 - Evaluate Haskell expressions using Nix to get packages  https://hackage.haskell.org/package/nix-eval-0.1.0.2 (chriswarbo)
12:54:28 <phaazon> I’ll split the function and add SCC to see what’s going on
12:54:44 <Enigmagic> phaazon: sum                     =  foldl (+) 0
12:54:50 <Enigmagic> that's in base still
12:54:53 <bennofs> phaazon: ah, you're wondering where that 80% alloc in totalProbabilty comes from?
12:55:13 <phaazon> bennofs: yeah!
12:55:13 <bennofs> Enigmagic: yes, but GHC optimizes that to a strict loop I think
12:55:23 <phaazon> bennofs: I don’t have optimization enabled
12:55:27 <Enigmagic> bennofs: it does sometimes, yes
12:55:28 <phaazon> -O0, I guess
12:55:32 <bennofs> phaazon: WHAT? :o
12:55:33 <phaazon> or by default ghc default to O1?
12:55:38 <phaazon> bennofs: I don’t use cabal
12:55:39 <bennofs> default is O1 :)
12:55:41 <phaazon> ok
12:55:57 <phaazon> ok, the sum is not the proble
12:55:59 <phaazon> problem
12:56:05 <phaazon> it’s the fmap (getProbability)
12:56:14 <bennofs> -O1 is ok. it just doesn't make sense to optimize without enabling compile optimizations first :p 
12:56:23 <phaazon> it is
12:56:24 <bennofs> phaazon: what's grid?
12:56:35 <phaazon> http://lpaste.net/8547419694284406784
12:56:39 <phaazon> s = the sum
12:56:42 <phaazon> prob = the fmap stuff
12:57:09 <bennofs> phaazon: can you show a bit more of the surrounding code?  Also, try a heap profile (run with +RTS -hy, then run hp2ps on the .hp and view the .ps file) 
12:57:43 <phaazon> yeah, wait
12:57:54 <bennofs> phaazon: (-hy shows you which types the objects on the heap have)
12:58:16 <phaazon> it’s a code for a job application programming challenge, I guess I can’t show you that much
12:58:19 <hunteriam> https://www.irccloud.com/pastebin/1p2rkhbE/where
12:58:23 <phaazon> wait, I test the -hy stuff
12:58:23 <hunteriam> guys whats wrong with this
12:58:28 <hunteriam> im getting parse error on input where
12:58:32 <hunteriam> like the word where is wrong
12:58:42 <hunteriam> what could cause that?
12:59:04 <geekosaur> missing close paren
12:59:05 <bennofs> hunteriam: missing closing )
12:59:12 <hunteriam> ahhhhh
12:59:17 <hunteriam> you guys are geniuses
12:59:22 <arkeet> also you have a tab
12:59:31 <arkeet> (but that's not the cause of the error)
13:00:00 <phaazon> bennofs: hm
13:00:07 <phaazon> what does hp2ps generate?
13:00:12 <phaazon> an .aux?
13:00:23 <phaazon> oh, a .ps
13:00:25 <phaazon> I’m stupid.
13:00:58 <phaazon> bennofs: Set is very present in the graph
13:01:05 <phaazon> I can show you, wait
13:01:10 <info_is_good> You can accurately evaluate a Haskeller's expertise in lab by measuring how quickly he detects missing parenthesis.
13:01:32 <phaazon> http://phaazon.net/pub/Main.ps bennofs 
13:02:32 <bennofs1> phaazon: oh, and pass -c to hp2ps for colors (if you're like me and not into grayscale)
13:02:41 <phaazon> I did
13:02:43 <phaazon> look at the output ;)
13:02:47 <phaazon> I just linked it to you
13:03:19 <bennofs1> oh
13:03:24 <phaazon> I’m allocating a lot of paths and keep them live in Set
13:03:31 <phaazon> (with already visited cells)
13:03:38 <phaazon> wtf is BLACKHOLE :D
13:03:48 <RageYL> i would like to be able to :reload then :main xxx yyy in one command in ghc
13:03:54 <phaazon> the memory consumption is pretty constant though
13:03:57 <RageYL> :rmain xxx yyy for example
13:03:58 <phaazon> that’s pretty good
13:04:01 <the_2nd> within a do, each value <- monadic method, returning the Nothing will stop all execution below, right?
13:04:02 <geekosaur> info_is_good, I developed that skill loong before I learned haskell :)
13:04:15 <phaazon> the_2nd: because of (>>=) for Maybe, yes
13:04:45 <the_2nd> phaazon, how can I within a do then add control flow depending on whether it is a Nothing or not?
13:04:56 <the_2nd> x <- someFunc y
13:05:04 <the_2nd> case x of 
13:05:07 <jophish_> Hmm, How suprised would you be if a function called getEndTime (or something like that) returned +INF for something which doesn't have an end. Thinking about it, it might be nicer for it to return Nothing
13:05:14 <the_2nd> since the Nothing case will never be reached
13:05:22 <the_2nd> my case of afterwards is useless
13:05:22 <geekosaur> use let and pattern match
13:05:45 <geekosaur> so you're not getting >>= operating on the Nothing
13:05:51 <hunteriam> is there a built in function that does (\(a,b) -> (b,a))
13:05:59 <arkeet> hunteriam: Data.Tuple.swap
13:06:01 <jophish_> hunteriam: hoogle is your friend
13:06:06 <geekosaur> that said, if you need to do that, maybe you should not be using the Maybe monad
13:06:06 <arkeet> and that
13:06:10 <hunteriam> so is #haskell jophish_ !
13:06:30 <jophish_> hunteriam: that's very true :) 
13:06:30 <jophish_> http://hoogle.haskell.org/?hoogle=(a%2Cb)-%3E(b%2Ca)
13:06:41 <the_2nd> geekosaur, gonna paste you my example
13:06:49 <arkeet> perhaps, but you should generally spend a bit of effort finding the answer yourself first.
13:06:53 <jophish_> @hoogle (a,b) -> (b,a)
13:06:53 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
13:06:53 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:06:53 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
13:07:09 <bennofs1> phaazon: yeah, doesn't look like a memory leak
13:07:14 <phaazon> bennofs1: I really don’t get it
13:07:18 <phaazon> how can it be so slow
13:07:19 <phaazon> like
13:07:28 <phaazon> a 9x9 graph is really slow
13:07:30 <bennofs1> phaazon: how long is the whole program?
13:07:33 <phaazon> like it takes minutes to complete
13:07:37 <bennofs1> phaazon: can you paste it?
13:07:39 <phaazon> it’s 80 lines long
13:07:47 <phaazon> in mp only, because as I said, it’s for a job application
13:07:49 <phaazon> wait
13:08:01 <phaazon> well, 127 loc actually
13:08:39 <bennofs1> hmm
13:08:48 <phaazon> bennofs: mp
13:09:05 <the_2nd> geekosaur, http://pastebin.com/eq8QK3Ds
13:09:36 <geekosaur> one of these days I'm just gonna block pastebin.com until they grow up
13:09:51 <jophish_> geekosaur: ad block detected?
13:09:55 <the_2nd> geekosaur, what shall I use instead?
13:10:01 <medfly> you can use lpaste.
13:10:24 <geekosaur> also, I don't see the 'let' there, just a '=
13:10:40 <the_2nd> geekosaur, my bad
13:10:48 <the_2nd> it was enablePlots <-
13:11:12 <the_2nd> "=" results in parse error
13:11:19 <the_2nd> let requires an "in"
13:11:24 <geekosaur> not in a do block
13:11:25 <the_2nd> which I fail to apply then
13:11:45 <the_2nd> "parse error on input '='"
13:11:51 <geekosaur> sigh
13:12:01 <the_2nd> one sec
13:12:22 <geekosaur> let does not require in, inside a do block
13:12:50 <the_2nd> "could not match Data.Text.Internal.Lazy.Text with hapstack.server.intrnal.monads.serverpartT
13:13:17 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
13:13:32 <the_2nd> expected serverpart ...lazy.text , got ...lazy.text
13:13:35 <hunteriam> is there a function for converting between monadpluses?
13:13:41 <hunteriam> i tried hoogling
13:13:52 <geekosaur> erm, that is not what you just said...
13:14:25 <the_2nd> yeah, my bad
13:14:36 <the_2nd> line in question is "Empty -> do"
13:14:36 <clrnd> hunteriam, holly molly
13:14:49 <hunteriam> clrnd: what? why?
13:15:05 <clrnd> nothing, your question was just funny to me :P
13:15:07 <clrnd> never mind
13:16:23 <hunteriam> why is it an absurd idea?
13:16:48 <clrnd> hunteriam, I wouldn't know, sorry
13:17:03 <hunteriam> oh ok.. well ive got no clue what was funny but (y)
13:17:18 <the_2nd> geekosaur, any idea what to do?
13:17:55 <clrnd> hunteriam, well, MonadPlus is a class, what do you mean by "converting" ?
13:18:28 <hunteriam> a function taking MonaPlus a, MonadPlus b,  and some kind of function for converting
13:18:40 <hunteriam> and then doing the converting
13:18:46 <hunteriam> somehow using mplus
13:18:48 <geekosaur> the_2nd, I'm not familiar with happstack programming
13:19:00 <hunteriam> but i dont even want that as it turns out
13:19:03 <hunteriam> after thinking about it
13:19:05 <clrnd> hunteriam, could you give an example type signature?
13:19:06 <geekosaur> hunteriam, I would doubt in general that it could do that
13:19:15 <geekosaur> for arbitrary MonadPlus instances
13:19:34 <hunteriam> why not? couldnt you just Mplus all the elements from one to the mzero of the other
13:19:40 <clrnd> :|
13:19:41 <hunteriam> you probably need foldable also
13:20:05 <hunteriam> right? that seems possible to me
13:20:09 <clrnd> > (mzero :: Maybe Int) `mplus` (mzero :: [Int])
13:20:11 <lambdabot>      Couldn't match type ‘[]’ with ‘Maybe’
13:20:12 <lambdabot>      Expected type: Maybe Int
13:20:12 <lambdabot>        Actual type: [Int]
13:21:08 <monochrom> hunteriam: I think the problem is that you stated the question confusingly.
13:21:34 <monochrom> I feel that your wording has nothing to do with your thinking.
13:21:35 <hunteriam> no....
13:21:39 <hunteriam> thats not what i mean clrnd
13:21:41 <hunteriam> and i disagree monochrom 
13:21:45 <arkeet> IO is a MonadPlus
13:21:47 <arkeet> [] is a MonadPlus
13:21:51 <arkeet> how to convert from IO to [] ?
13:22:23 <arkeet> wait IO isn't.
13:22:29 <arkeet> but STM is so let's talk about that.
13:22:31 <mniip> arkeet, is this a serious question?
13:22:44 <hunteriam> (Foldable a, MonadPlus a, MonadPlus b) => a c -> b c... (\struc -> foldr (\x -> mplus x) mzero struc)
13:22:45 <hunteriam> there
13:22:49 <mniip> or am I missing context
13:22:51 <hunteriam> why wouldnt that work?
13:23:00 <arkeet> it's more rhetorical than serious.
13:23:16 <hunteriam> its not rhetorical.. maybe hypothetical
13:23:18 <arkeet> hunteriam: that has nothing to do with the MonadPlus on a.
13:23:28 <hunteriam> thats a good point
13:23:33 <hunteriam> you dont even need monadplus a
13:25:54 <quchen> I don't know the question but the answers are confusing.
13:25:55 <monochrom> "Foldable a, MonadPlus a" is a kind error.
13:26:30 <quchen> Huh?
13:26:33 <Enigmagic> ?
13:26:38 <Enigmagic> :k Foldable
13:26:39 <lambdabot> (* -> *) -> Constraint
13:26:44 <Enigmagic> :k MonadPlus
13:26:45 <lambdabot> (* -> *) -> Constraint
13:34:14 * hackagebot GPipe 2.1.2 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.1.2 (TobiasBexelius)
13:40:15 <RageYL> how can i decode a Binary in Get monad ?
13:40:19 <RageYL> parseHeader :: Get Header
13:40:21 <RageYL> parseHeader = return . (decode :: ByteString -> Header)
13:41:10 <ReinH> RageYL: if you already have decode, why use Get?
13:41:41 <RageYL> that' my first time using this kind of stuff and i'm trying to parse multiple stuff one after another
13:41:54 <RageYL> i thought Get is used to keep track of where the 'cursor' is
13:41:58 <johnw> RageYL: Get actions describe how to decode something
13:42:15 <johnw> they don't actually do the decoding
13:43:02 <johnw> 'runGet' does that
13:43:25 <johnw> (or at least, that's a way to look at it)
13:43:28 <mniip> hey ReinH
13:43:37 <RageYL> i my main is: main = B.readFile "./sample" >>= print . runGet parseHeader
13:43:57 <RageYL> if i use: print . (decode :: ByteString -> Header) it works
13:44:04 <RageYL> i would like to decode multiple header
13:44:09 <mniip> ReinH, I've read the diagrams and matrices thingy :o
13:46:03 <c_wraith> RageYL: Binary isn't great for interfacing with an existing format. It's really about serializing data in some opaque manner. 
13:46:35 <RageYL> which module do you advice ?
13:47:36 <c_wraith> RageYL: if you want to parse an existing format, I'd go with one of the parser libraries. Maybe attoparsec if it's an ascii format 
13:48:20 <RageYL> it's a binary format that's why i choose Binary (i asked about which module i should use to parse existing binary format few hours ago and someone tell me to go with Binary)
13:48:42 <ReinH> mniip: sweet
13:48:44 <RageYL> (or i have misinterpreted)
13:48:57 <mniip> ReinH, I have a question thought
13:49:14 <mniip> if we interpret matrices as columns-then-rows, instead of the given way
13:49:19 <c_wraith> Actually, attoparsec would work for octet-oriented formats, it just has a bunch of combinators that aren't helpful when the format isn't ascii
13:49:23 <mniip> wouldn't that give use straightforward multiplication?
13:49:25 <mniip> instead of reversed/
13:49:40 <Enigmagic> RageYL: binary is fine for dealing with binary data
13:50:31 <RageYL> c_wraith: i've mainly used Parsec, i will take a look at it
13:50:46 <RageYL> Enigmagic: is it possible to read structure like in c-language ?
13:51:03 <Enigmagic> RageYL: yes
13:51:17 <RageYL> i was trying to create an instance of Binary and defined Get and use 'decode' to read the full structure
13:52:01 <Enigmagic> RageYL: if you really need to get a ByteString value within the Get monad look at getByteString
13:52:51 <Enigmagic> RageYL: http://hackage.haskell.org/package/binary-0.7.6.1/docs/Data-Binary-Get.html#v:getByteString
13:53:26 <RageYL> don't know if this is the thing i want: here is a small example: https://gist.github.com/anonymous/4de2fd64ab202cb672fe
13:54:03 <RageYL> and read many structure one after another
13:54:59 <Enigmagic> RageYL: two options... fastest at runtime is to use runGetIncremental to parse one at a time
13:55:52 <Enigmagic> RageYL: the other option (simpler but slower) is to use the `many` or `some` combinators to build a parser that will return a list
13:56:00 <Enigmagic> :t many
13:56:01 <lambdabot> Alternative f => f a -> f [a]
13:56:29 <RageYL> hum ok...
13:56:38 <quchen> Ewww, many
13:56:41 <RageYL> the second is like 'normal' parsing so
13:57:23 <Enigmagic> yeah, much more similar to defining a grammar... just it's not very memory or cpu friendly :)
13:57:47 <bramgg> How can I timeout a blocking function? System.Timeout doesn't work.
13:57:54 <RageYL> Enigmagic: as this is for learning purpose i would like to go with the first option. do you know about a project that use this stuff ? (i can use to have an example)
13:58:30 <Enigmagic> RageYL: github is always a nice place to dig around; https://github.com/search?l=haskell&q=runGetIncremental&type=Code&utf8=%E2%9C%93
13:58:32 <bramgg> i.e. if a function I've called hasn't returned anything in 5 seconds do something, even if that function is blocking the main thread.
13:58:37 <RageYL> thanks ;)
13:58:42 <geekosaur> bramgg, you can't
13:59:11 <quchen> bramgg: fork the operation instead of running it in the main thread, nuke that thread on timeout?
14:00:08 <geekosaur> if it's blocking such that System.Timeout doesn't work, it's probably in FFI and there's not a lot you can do to interrupt it safely
14:01:02 <nkaretnikov> Enigmagic: hey!  thanks for all the tips on github, much appreciated
14:01:10 <bramgg> This line right here takes H99 down every week or so https://github.com/bramgg/99haskell/blob/master/Sandbox.hs#L38
14:01:24 <Enigmagic> nkaretnikov: no problem, thought it would be easier than spamming irc :)
14:01:41 <monochrom> eh? hIsEOF should be very timeoutable
14:02:12 <tomus>  ok, I am too stupid to parse Haskell's documentation even though I really try
14:02:22 <nkaretnikov> Enigmagic: i have a new challenge, sort of.  i need to construct my succ type based on the values, is it possible?
14:02:27 <Stoner19> shirt you around?
14:02:53 <nkaretnikov> Enigmagic: like i define foo 1 2 3 and it infers that it's a triangle
14:03:03 <bramgg> montanonic: see note https://hackage.haskell.org/package/base-4.8.1.0/docs/System-IO.html#v:hIsEOF
14:03:05 <jle`> tomus: what parser are you using?
14:03:16 <nkaretnikov> Enigmagic: well, the triangle type, i mean
14:03:31 <tomus> jle`: biological neural network
14:03:32 <monochrom> yes, but its "block" should be very timeoutable
14:03:38 <Enigmagic> nkaretnikov: not following... do you want to promote the values to types and then check if it's a triangle?
14:03:50 <montanonic> bramgg: I think you meant monochrom  :)
14:03:50 <geekosaur> bramgg, it should be using ghc's I/O manager, so it['s a "soft block" in ghc's thread scheduler
14:03:51 <nkaretnikov> Enigmagic: exactly!
14:04:08 <jle`> tomus: ah yeah those have some typical issues with training i hear...but usually given enough time they can get the task done :)
14:04:08 <nkaretnikov> i need a way to lift a value to the type level
14:04:08 <bramgg> montanonic: err yes I did
14:04:15 <nkaretnikov> or at least communicate some information
14:04:58 <Enigmagic> nkaretnikov: that's a bit harder to do... certainly easy enough to promote the values individually but it's going to be trickier to do it while maintaining the triangle constraint
14:05:23 <geekosaur> hm, actually it depends on what it is reading. fifos apparently don't go through the thread scheduler and can hard block?
14:05:57 <geekosaur> sockets should go through the thread scheduler. regular files do not, iirc
14:05:57 <nkaretnikov> Enigmagic: could you show a simple example that just maps an int to a peano numeral at the type level?
14:06:01 <bennofs> ö
14:06:05 <bennofs> l
14:06:16 <Enigmagic> nkaretnikov: sure, hang on
14:06:19 <nkaretnikov> Enigmagic: cool
14:06:24 <tomus> jle`: they have limitted will power too
14:07:03 <jle`> that's the crazy thing about them though...even with limited power they can achieve amazing things.
14:07:17 <geekosaur> hm, so it's a pipe. should be going through the thread scheduler then
14:07:25 <hunteriam> what keyword do i use for type synonyms that take variables
14:07:33 <hunteriam> like type SpecialList a  = [a]
14:07:37 <jle`> hunteriam: `type` should still work
14:07:45 <hunteriam> oh cool i didnt think it took variables
14:07:53 <jle`> yup
14:08:01 <jle`> it's almost as if they were like...type functions or something
14:10:02 <haskell070> hello
14:10:13 <haskell070> I've a problem 
14:10:16 <haskell070> :D
14:10:23 <haskell070> someone to help me
14:10:25 <jle`> that's the attitude :)
14:10:44 <ReinH> haskell070: what is your question?
14:10:59 <haskell070> well
14:11:33 <haskell070> i've already know let < > in < > syntac
14:11:51 <bramgg> Seems your right, it's "timeoutable"
14:11:54 <bramgg> *you're
14:12:07 <bramgg> My problem is elsewhere
14:12:20 <Enigmagic> nkaretnikov: https://gist.github.com/NathanHowell/a3e09ef3740acf9b8178
14:12:32 <nkaretnikov> Enigmagic: just realized that singletons might come in handy
14:12:55 <haskell070> but i've this error : parse error in let binding
14:13:04 <haskell070> missing required inn
14:13:07 <Enigmagic> nkaretnikov: yes, they do come in handy. didn't know how much of the weeds you wanted to implement yourself :)
14:13:24 <jle`> haskell070: any chance you can paste your code?
14:13:38 <ReinH> @where lpaste -- haskell070 
14:13:38 <lambdabot> http://lpaste.net/
14:13:38 <geekosaur> @paste
14:13:38 <lambdabot> Haskell pastebin: http://lpaste.net/
14:14:17 <nkaretnikov> Enigmagic: okay, i'm super tired right now, but i'll take a look at your impl later.  thanks again :)
14:14:44 <Enigmagic> nkaretnikov: heh no problem, if you have any questions just ping me here or add a comment to the gist
14:15:03 <nkaretnikov> Enigmagic: sure!
14:15:06 <haskell070> http://pastebin.com/VGJPy6nv
14:15:36 <ReinH> haskell070: please include the error message
14:15:36 <jle`> haskell070: the "in" has to come after the "let", indetntation wise
14:15:43 <jle`> oh wait, it doesn't
14:15:53 <jle`> the "let" has to come after the "cylinder", indentation wise
14:15:59 <ReinH> haskell070: although I suspect the problem is that let is indented at same level as the definition
14:16:01 <jle`> otherwise it thinks you're "done" with cylinder
14:16:13 <ReinH> Lines 3-5 have to be indented
14:16:29 <haskell070> I've tried to put at the same level
14:16:35 <ReinH> @google haskell layout
14:16:36 <lambdabot> https://en.wikibooks.org/wiki/Haskell/Indentation
14:16:52 <ReinH> Understanding the (few) layout rules will prevent this sort of thing in the future.
14:18:22 <ReinH> haskell070: it *shouldn't* be at the same level
14:19:33 <haskell070> sry dont understand
14:20:14 <ReinH> haskell070: lines 3-5 need to be indented
14:20:58 <haskell070> ok ok
14:21:00 <haskell070> ty
14:21:04 <haskell070> a lot dude
14:21:10 <haskell070> ure awesome ! 
14:21:12 <haskell070> :D
14:22:51 <t7> haskell070: 你也是
14:22:55 <td123> Hi, I'm using hint https://hackage.haskell.org/package/hint-0.4.2.3/docs/Language-Haskell-Interpreter.html and I'm wondering if there is a way it can interpret a statement to define a type in haskell like "data Test = Test"
14:24:09 <td123> it seems like the package expects expressions only
14:24:47 <t7> what would i return?
14:26:23 <geekosaur> td123, it looks like hint only wraps the evaluator. you could look at the source of ghci to see what it does with ghc-api to define types
14:28:09 <tomus> > import qualified Vision.Image as I
14:28:10 <lambdabot>  <hint>:1:1: parse error on input ‘import’
14:28:14 <hunteriam> im trying to implement this
14:28:15 <hunteriam> https://en.wikipedia.org/wiki/Topological_sorting#Application_to_shortest_path_finding
14:28:21 <tomus> :hoogle I.DelayedMask I.RGBPixel -> I.RGB
14:28:22 <td123> geekosaur: I see
14:28:23 <hunteriam> i was panning on using an array as it does
14:28:26 <td123> geekosaur: thanks for looking
14:28:27 <tomus> > :hoogle I.DelayedMask I.RGBPixel -> I.RGB
14:28:28 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:28:34 <hunteriam> but is there a better more haskelly way?
14:28:48 <geekosaur> tomus, it's @hoogle
14:29:06 <tomus> geekosaur: I don't think it will do what I want though...
14:29:12 <tomus> @hoogle I.DelayedMask I.RGBPixel -> I.RGB
14:29:12 <lambdabot> Parse error:
14:29:12 <lambdabot>   I.DelayedMask I.RGBPixel -> I.RGB
14:29:12 <lambdabot>     ^
14:29:21 <tomus> why the error?
14:29:29 <geekosaur> you might note the qualified import failed too, not allowed
14:29:38 <geekosaur> [30 21:27] <tomus> > import qualified Vision.Image as I
14:29:39 <geekosaur> [30 21:27] <lambdabot>  <hint>:1:1: parse error on input ‘import’
14:29:47 <geekosaur> that *might* be doable with @let if the module is Safe
14:29:52 <tomus> but I got the same error in my ghci
14:29:57 <tomus> where qualified doesn't fail
14:30:26 <geekosaur> hm. I don't know how hoogle's parser works
14:30:39 <tomus> λ: import qualified Vision.Image as I
14:30:39 <tomus> λ: :hoogle I.DelayedMask I.RGBPixel -> I.RGB
14:30:39 <tomus> Parse error:
14:30:53 <geekosaur> actually even if you got that to import, it wouldn't be there for hoogle
14:31:03 <geekosaur> because it won't be in hoogle's database
14:31:14 <geekosaur> fpcomplet's web hoogle indexes more, but not all of hackage
14:33:10 <zipper> How can I ask the GHC library to dump interface files i.e .hi files?
14:33:36 <hunteriam> does anyone have any information about the efficiency of FGL?
14:36:18 <haskell070> Ey guys someome one what mean this warning: Tab character ?
14:36:37 <haskell070> Ey guys someone oknow what mean this warning: Tab character ?
14:36:40 <dtscode> as in
14:36:45 <dtscode> as in
14:36:47 <dtscode> gd
14:36:50 <dtscode> as in \t?
14:36:54 <haskell070> Ey guys someone know what mean this warning: Tab character ?
14:36:57 <scshunt> haskell070: it means you have a tab character in the source
14:37:02 <scshunt> it's highly recommended you use spaces only
14:37:06 <geekosaur> please stop repeating yourself like that
14:37:12 <scshunt> ^
14:37:13 <geekosaur> and warning on ytabs is the default in ghc 7.10
14:37:19 <haskell070> so sorry geekosaur 
14:37:55 <geekosaur> (there is a spam-detecting bot in here that will kline you for too many repeats)
14:38:21 <dtscode> :D yay Sigyn is in here too
14:40:28 <td123> geekosaur: opened a bug report/feature request to find out more, thanks again
14:40:47 <ReinH> haskell070: tabs tend to cause parse errors so it warns you about them. You should use spaces instead.
14:40:57 <hunteriam> whats the best haskell library for arrays?
14:41:04 <hunteriam> ie vectors or arrays? (unless there are others)
14:41:07 <bitemyapp> hunteriam: vector, why do you want them?
14:41:18 <hunteriam> https://en.wikipedia.org/wiki/Topological_sorting#Application_to_shortest_path_finding
14:41:26 <haskell070> actually is not  an error but a warning 
14:41:31 <hunteriam> i cant think of a better way to write this algorithm
14:41:37 <bitemyapp> hunteriam: you want a graph?
14:41:39 <ReinH> haskell070: Right, it's warning you because it often does lead to errors.
14:41:42 <hunteriam> i already have a graph
14:41:51 <hunteriam> the algorithm i linked has 2 arrays inside it
14:41:54 <hunteriam> that need random access
14:41:55 <haskell070> so let me try use spaces
14:42:03 <bitemyapp> hunteriam: you're writing your own graph data structure?
14:42:04 <ReinH> haskell070: This is because GHC interprets tabstops as 8 chars, so if your editor is configured differently then you will not see the same thing ghc sees.
14:42:06 <hunteriam> no im not
14:42:15 <hunteriam> im just trying to implement the algorithm i linked
14:42:17 <hunteriam> im using fgl
14:42:22 <ReinH> Which makes it easy to indent things improperly
14:42:22 <bitemyapp> okay
14:42:27 <bitemyapp> hunteriam: yeah start with Vector.
14:42:32 <hunteriam> alright thanks :D
14:42:34 <geekosaur> hunteriam, the array library is ancient and basically still around because a lot of old code depends on it. vector is newer and faster
14:42:47 <hunteriam> anyone plan on updating that old code?
14:43:00 <bitemyapp> Arrays aren't identical to Vectors, I'm not sure if it always make sense to do so.
14:43:01 <geekosaur> not really, most of the guts are low level ghc stuff iirc
14:43:08 <bitemyapp> makes sense*
14:43:13 <ReinH> hunteriam: Have you considered a Data.Map or Data.IntMap?
14:43:15 <bitemyapp> hunteriam: start by using ordinary vectors, resort to mutable ones only if necessary for perf.
14:43:22 <hunteriam> ReinH: i need O(1) random access
14:43:28 <hunteriam> otherwise this will be really slow
14:43:28 <bitemyapp> ReinH: I doubt that would make sense here
14:43:40 <ReinH> bitemyapp: Why?
14:43:41 <geekosaur> so actually updating it usefully requires ghc source hackery. Vector uses a newer set of primitives and manages the data itself instead of relying on special ghc primitives, iirc
14:43:51 <bitemyapp> ReinH: IntMap is almost always slower than a HashMap and I think they want the memory layout benefits of a Vector in addition the O(1) indexing.
14:43:52 <hunteriam> ReinH: maps have log(n) access
14:44:00 <hunteriam> afaik
14:44:06 <hunteriam> Data.Map does anyways
14:44:17 <hunteriam> I actually use them to help assemble my graph in the first place
14:44:21 <bitemyapp> hunteriam: that's not actually the best reason to use a Vector here, but that's neither here nor there.
14:44:31 <hunteriam> bitemyapp: what is the best reason?
14:44:33 <hunteriam> im curious
14:44:35 <ReinH> I'm not convinced that a log factor is fatal to your algorithm's performance, but ok.
14:44:45 <hunteriam> ReinH: im going to running this algorithm n times
14:44:51 <hunteriam> and the algorithm is already linear
14:44:56 <bitemyapp> you'd need to confirm with benchmarks, but I think memory layout and ability to shift to mutable vectors later may matter more.
14:44:59 <hunteriam> so throwing in another log isnt helping much
14:45:32 <quchen> Rather than a good complexity class, you should also look for an algorithm that performs well.
14:45:37 <cite-reader> What are you actually trying to solve here? It's starting to sound like you're doing all-pairs shortest paths.
14:45:45 <hunteriam> yes i am cite-reader 
14:45:51 <hunteriam> actually longest path but its the same algorithm
14:46:22 <hunteriam> so if knowing that helps you advice me, im all ears
14:46:39 <hunteriam> cause i dont claim to know the best way to do this
14:46:49 <hunteriam> this just seems the best from what i can tell
14:46:59 <ReinH> Asymptotic performance isn't the only thing that matters
14:47:02 * ReinH shrugs
14:47:49 <hunteriam> what else are you thinking about?
14:47:57 <hunteriam> im running this on a large list
14:48:03 <ReinH> how "large"?
14:48:04 <hunteriam> so it seems like the most important thing right now
14:48:08 <hunteriam> 173,000
14:48:11 <ReinH> heh
14:48:15 <hunteriam> yes i know
14:48:19 <hunteriam> when youre a professional thats tiny
14:48:24 <hunteriam> but i am no professional
14:48:32 <haskell070> ReinH: I've deleted all tabs and instead put 3 or 4 spaces to ident 
14:48:34 <ReinH> GHC isn't slower if its user is an amateur
14:48:47 <hunteriam> well anyways
14:48:54 <hunteriam> n^2 is bad enough with 173k
14:49:00 <ReinH> I'm just saying your assumptions about needing an array may be incorrect, and it might be worthwhile to check them
14:49:22 <haskell070> no more warnings
14:49:22 <hunteriam> i only need an array if theres no better structure
14:49:25 <hunteriam> and there doesnt seem to be
14:49:28 <bitemyapp> hunteriam: don't debate it, just write a benchmark.
14:49:38 <quchen> ReinH: Asymptotic performance never matters, unless you're interested in the logical aspect of your program structure. I could rant about this all day. ಠ_ಠ 
14:49:39 <hunteriam> i have to write the algorithm first :D
14:49:43 <bitemyapp> hunteriam: get it working with vector, then make another path that uses Data.Map, see how the benchmark goes.
14:49:46 <bitemyapp> hunteriam: sure.
14:49:47 <ReinH> quchen: oh well
14:49:55 <hunteriam> also ive never done benchmarking in haskell
14:50:00 <quchen> ReinH: Quicksort is O(n!) best case, abandon ship
14:50:01 <bitemyapp> hunteriam: use criterion.
14:50:03 <hunteriam> quchen: it matters if youre taking a class in algorithms
14:50:05 <ReinH> hunteriam: use criterion
14:50:07 <ReinH> heh
14:50:23 <hunteriam> and besides
14:50:24 <bitemyapp> hunteriam: https://github.com/bitemyapp/blacktip/blob/master/benchmarks/benches.hs example here.
14:50:28 <hunteriam> the 173k one is only the test list
14:50:34 <hunteriam> im going to run it on a list of 3m later
14:50:36 <bitemyapp> hunteriam: don't debate it, just do it.
14:50:41 <hunteriam> im just making the case
14:50:43 <hunteriam> for this choice
14:50:51 <bitemyapp> hunteriam: it's not worth your time :P
14:50:56 <hunteriam> sure it is
14:50:58 <ReinH> Theorising about it is useless in the face of benchmarks
14:51:03 <bitemyapp> hunteriam: hope that helped, look forward to seeing what you come up with :)
14:51:07 <hunteriam> thanks
14:51:09 <hunteriam> sure it will
14:51:11 <hunteriam> ill look at it later
14:51:32 <hunteriam> so you said Data.Map is worth trying?
14:51:36 <hunteriam> as an alternative?
14:51:38 <hunteriam> once ive got it done
14:51:40 <ReinH> Absolutely
14:51:46 <hunteriam> alright, ill try it
14:51:56 <ReinH> or IntMap, more likely
14:52:04 <ReinH> since you're indexing an array by ints anyway
14:52:08 <hunteriam> and to use these data structures effectively
14:52:13 <hunteriam> should i not use random access?
14:52:19 <quchen> ReinH: Are there reasons to prefer Map Int over IntMap at all?
14:52:27 <ReinH> quchen: No?
14:52:36 <quchen> ReinH: OK :-)
14:52:42 <hunteriam> if youre too lazy to include IntMap
14:52:46 <hunteriam> and youve already got Data.Map
14:52:50 <hunteriam> aka me
14:53:00 <hunteriam> not that i have any Map Ints atm
14:53:16 <ReinH> hunteriam: Wasn't this whole conversation about you wanting to use the "right" data structure? ಠ_ಠ
14:53:23 <hunteriam> :)
14:53:27 <hunteriam> only where its really important
14:53:30 <ReinH> ...
14:53:33 <hunteriam> like in the thing thats going to be run a million times
14:53:47 <hunteriam> literally, actually
14:54:20 <jle`> IntMap has better merger than Map Int, right?
14:54:53 <ReinH> IntMap uses a patricia trie, iirc, and is more efficient than Map Int
14:54:53 <jle`> . o O ( traverse :: Map Int -> IntMap )
14:55:00 <jle`> s/traverse/sequence
14:55:22 <jle`> . o O ( sequence :: Map Int a -> IntMap a )
14:55:26 <quchen> "Millions" isn't a whole lot.
14:55:27 <ReinH> Docs suggest is it "much faster" on insertions and deletions than Map Int
14:55:29 <quchen> > foldl' (+) 0 [1..10^6]
14:55:31 <lambdabot>  500000500000
14:55:48 <ReinH> It's quite possible that the log factor can't even make a difference on data sets that fit in memory
14:55:58 <ReinH> i.e. that for real world use it is a constant factor
14:56:12 <quchen> For real world use, most log factors are under 5.
14:56:20 <quchen> Up to a constant factor, of course.
14:56:36 <jle`> nope...they're just ... 5
14:56:48 <mniip> actually it's e squared
14:57:13 <quchen> Instead of solving quantum chromodynamics, I would advise to just benchmark how fast the apple falls when you let go of it.
14:57:50 <monochrom> wait, how does quatum chromodynamics tell you about falling speeds?
14:57:58 <geekosaur> I was wondering that too
14:58:24 <ReinH> monochrom: It doesn't. :D
14:58:24 <quchen> seventh order loop contributions
14:59:03 <ReinH> I'm pretty sure the behavior of a falling apple is dominated by gravity rather than the strong interaction...
14:59:18 <quchen> ReinH: Just you wait until we unify those
14:59:41 <mniip> ReinH, depends on the distance of the fall
14:59:45 <ReinH> mniip: does it?
15:00:02 <quchen> Also, consider that the mass of the apple is dependent on the mass of its constituents, and those …
15:00:11 <tomus> anyone familiar with friday library. I've been trying to figure out how to convert I.DelayedMask I.RGBPixel to I.Manifest I.RGBPixel for some time now
15:00:24 <mniip> at picoscopic distances the strong force starts to dominate
15:00:28 <geekosaur> considering the strong interaction disappears at distances smaller than the gap between an apple and the table it's sitting on...
15:01:22 <monochrom> at picoscopic distances you don't talk of "fall"
15:01:40 <monochrom> instead, you talk of threadDelay
15:03:01 <monochrom> wait, I have confused distance with time
15:03:40 <ReinH> mniip: :p
15:04:06 <geekosaur> tomus, I think you want http://hackage.haskell.org/package/friday-0.2.2.0/docs/Vision-Image-Type.html#v:compute
15:04:42 <tomus> geekosaur: that's what I thought... but I can't get the types to match :/
15:04:49 <haskell070> Can I work with GTK package on Windows using Leksah?
15:05:07 <mniip> monochrom, it's all the same thing really
15:05:37 <geekosaur> oh wait, DelayedMask not just Delayed
15:06:11 <zipper> Hey I'm looking at https://hackage.haskell.org/package/Cabal-ide-backend-1.23.0.0/docs/Distribution-PackageDescription.html
15:06:44 <geekosaur> aha
15:07:15 <geekosaur> hm, wait, no, that one isn't DelayedMask either
15:07:23 <zipper> and I can't find a way to get the extract what is pointed to by "hs-source-dirs:" in a cabal file
15:07:31 <zipper> Am I missing something?
15:07:52 <zipper> I just want to get hs-source-dirs from a cabal file.
15:10:52 <hexagoxel> zipper: package contains one or more components. see the Library, Executable, .. data types. those contain BuildInfo's. Those have hsSourceDirs
15:12:22 <geekosaur> tomus, if I am reading this stuff correctly, you can't convert them because a DelayedMask has regions that can't be represented as an Image
15:12:46 <geekosaur> "Provides an abstraction for images which are not defined for each of their pixels. The interface is similar to Image except that indexing functions don't always return."
15:14:49 <hunteriam> am i going to take performance hits by using a large vector in a recursive function?
15:17:25 <tomus> geekosaur: yeah... but I wanna provide a default value for those...
15:21:18 <monochrom> every computation takes a performance hit
15:21:24 <tomus> geekosaur: should I just roll my own? create new image and check if a pixel is set in a masked one?
15:21:39 <geekosaur> no idea, sorry
15:21:55 <tomus> thanks ok
15:21:57 <tomus> thank you
15:26:16 <haskell070> geekosaur: Do u know if Is it possible use Gtk and Leksah on windowss?
15:26:34 <geekosaur> don't know
15:26:39 <haskell070> ty
15:33:17 <tomus> geekosaur: ended up writing
15:33:18 <tomus>                 
15:33:26 <tomus> fromMasked color size masked = I.fromFunction size unMaskedPixel where unMaskedPixel pixel = fromMaybe color (masked `I.maskedIndex` pixel)
15:33:39 <tomus> oops, sorry about the paste. but you get the gist
15:36:24 <ReinH> or unMaskedPixel = fromMaybe color . I.maskedIndex masked
15:37:08 <tomus> the latter is easier for me to read that this point free one
15:37:12 <tomus> sorry the former
15:40:18 <GLM> Just read up on pointfree style. Why would I want to do that?
15:41:40 <ReinH> Because reasoning about function composition is a big part of functional programming
15:43:05 <Sindriava> It would be really nice to have major haskell utilities installable via homebrew on OSX
15:43:13 <Sindriava> cabal shouldn't be used to install this stuff
15:43:19 <ReinH> like what?
15:43:45 <Sindriava> ReinH: Was that meant for me?
15:43:48 <GLM> Does stack not work?
15:43:48 <montanonic> GLM compare squishMap f lls = squish $ map f lls  with   squishMap f = squish . map f ; just a small example of something I just wrote.
15:43:55 <ReinH> Sindriava: yes
15:43:59 <Sindriava> GLM: When it's more readable
15:44:05 <Sindriava> ReinH: Like ghc-mod or hakyll
15:45:50 <montanonic> GLM: it's appropriate when, as ReinH said, you are reasoning about function composition. In other words, building new functions out of other functions. Writing it in that style allows you to focus on the functions and not the data you're passing around; though it depends on the nature of what you're working with, of course.
15:46:28 <Sindriava> GLM: Yeah, it can be more readable sometimes, or totally unreadable.
15:46:53 <Sindriava> @pl ((((x + 5) / 10) - 20) * 10)
15:46:53 <lambdabot> ((x + 5) / 10 - 20) * 10
15:47:04 <ReinH> Sindriava: I would rather use cabal to install haskell packages
15:47:16 <Sindriava> ReinH: For any particular reason?
15:47:52 <Sindriava> ReinH: I wasn't talking about packages though. I was talking about utilities, which is a bit different. I wouldn't install `mtl` through homebrew
15:48:08 <Sindriava> ReinH: But I find it reasonable to install ghc-mod or hoogle through homebrew
15:48:16 <ReinH> Well, hakyll still requires a haskell compiler to use
15:48:20 <ReinH> As, for that matter, does ghc-mod
15:48:24 <montanonic> @pl (\f a b c -> f c b a)
15:48:24 <lambdabot> flip . (flip .) . flip
15:48:25 <ReinH> So they are not stand-alone utilities
15:48:44 <Sindriava> ReinH: So does cabal-install, and it's installed separately
15:48:51 <Sindriava> montanonic + 1
15:48:52 <MitchellSalad> Yo - any idris people here? I have an outstanding question in #idris but no one seems to be around =)
15:49:12 <ReinH> Sindriava: cabal-install makes sense
15:49:19 <ReinH> As do actual utilities like pandoc
15:49:47 <Sindriava> ReinH: I don't recall hakyll needing a compiler, though. You mean for compiling site.hs ?
15:50:02 <ReinH> Yes
15:50:02 <Sindriava> Hm, I guess it kinda does
15:50:24 <Sindriava> Still, until cabal can uninstall the package, it's not suitable for installing binaries IMO
16:09:30 <tpsinnem> ghah, why did i only hear of this zseq/reflection-without-remorse/freer-monads stuff only just lately?
16:10:01 <bitemyapp> tsani: spending your time wisely (ie, not on reddit)
16:10:03 <bitemyapp> er
16:10:05 <bitemyapp> tpsinnem: ^^
16:10:08 <bitemyapp> tsani: mis-tab, sorry.
16:10:51 <tpsinnem> i wonder how the various 'zseq everything' projects that i'm sure are going on everywhere are going on?
16:15:24 <tpsinnem> i did note edwardk (how seriously?) tweeting about zseqqing the machines library. i ran into all this just now as i had been thinking of playing with some frp stuff on top of machines or something like it.
16:16:03 <hpc> zseq?
16:16:11 <tpsinnem> hpc: wait a sec..
16:16:54 <Enigmagic> @google zseq haskell
16:16:57 <lambdabot> http://okmij.org/ftp/Haskell/zseq.pdf
16:16:57 <lambdabot> Title: Reflection without Remorse
16:16:57 <Enigmagic> :P
16:16:58 <tpsinnem> hpc http://okmij.org/ftp/Haskell/zseq.pdf
16:17:11 <hpc> oh jeez, an oleg original
16:17:46 <tpsinnem> hpc: also http://okmij.org/ftp/Haskell/extensible/more.pdf
16:20:22 <hpc> man, my days of not paying enough attention to haskell developments are certainly coming to a middle
16:21:28 <c_wraith> hpc: what if I offered to trade you a large gun for your attention? 
16:22:06 <hpc> heh
16:22:21 <hpc> it doesn't have a name, that's one of the hard problems
16:22:51 <cite-reader> Name the gun Reasoned Discourse.
16:22:57 <c_wraith> I could just call it Vera
16:25:48 <sclv> quick poll -- anyone on OS X el Capitan yet?
16:26:07 <sclv> we need to fix the platform installers for it and could use some testers
16:26:51 <c_wraith> I have no idea what OS X I'm on. What number is it? 
16:27:01 <Enigmagic> the one that came out today
16:27:08 <Enigmagic> if you didn't upgrade today you're not on it :)
16:27:37 <cite-reader> What broke this time?
16:27:44 <c_wraith> Hmm. That computer hasn't been awake and had Internet access simultaneously today. 
16:27:55 <hunteriam> why is updating an element in a vector O(m+n) and not O(1)?
16:28:29 <hunteriam> and really is there a data structure that can update and access in O(1)?
16:28:33 <arkeet> "an element"
16:28:39 <arkeet> you mean the update function? (which updates multiple elements)
16:28:42 <c_wraith> hunteriam: probably because you're looking at immutable vectors
16:28:45 <arkeet> ^
16:28:50 <cite-reader> hunteriam: You're doing a functional update; copying the vector into a new position with one element changed. If that's unacceptable, work in ST s or IO and use a mutable vector.
16:29:16 <hunteriam> how do functional vectors achieve O(1) access?
16:30:22 <Adeon> access part easily gets O(1)
16:30:48 <Adeon> updating doesn't, unless, like mentioned, it's a mutable vector in ST s or IO or something
16:31:27 <hunteriam> where can i read how it gets O(1)
16:31:34 <arkeet> access doesn't require mutation
16:31:43 <hunteriam> i know
16:31:50 <hunteriam> that still doesnt explain how its accessing in O(1)
16:32:20 <exio4> it is just a normal vector
16:32:27 <hunteriam> i dont know how those work either
16:32:34 <c_wraith> It does a multiply, an add, and a read from the calculated memory location. 
16:32:37 <cite-reader> Do you C at all?
16:32:48 <hunteriam> oh its a C vector?
16:32:51 <arkeet> it's an array
16:33:06 <hunteriam> does it require some secret haskell stuff to layout your data like that
16:33:38 <c_wraith> It depends on compiler primitives, though it could be done via the FFI
16:34:21 * hackagebot tzdata 0.1.20150810.0 - Time zone database (as files and as a module)  https://hackage.haskell.org/package/tzdata-0.1.20150810.0 (MihalyBarasz)
16:34:29 <arkeet> it's built on https://hackage.haskell.org/package/primitive-0.6.1.0/docs/Data-Primitive-Array.html
16:34:50 <c_wraith> The primitives are just better at cooperating with things like the GC
16:35:03 <arkeet> which uses some ghc primitives
16:38:10 <Shockk> hmm, I've got a problem with two mutually recursive modules 
16:38:17 <sclv> cite-reader, the new rootless security means we can't put links into /usr/bin anymore
16:38:21 <sclv> and have to put them in /usr/local/bin
16:38:24 <sclv> no big deal, but still
16:38:37 <sclv> (oh, and if you upgrade, the existing links get removed from /usr/bin)
16:39:12 <sclv> anyway, not to cause too much noise, but again, if anyone is on el capitan already and is willing to be a test subject, please let us know :-)
16:39:40 <pavonia> Shockk: What problem?
16:40:24 <Shockk> one of the modules defines PolarCore and part of what makes up that type is PolarState which has a field of type :: [PolarLL [PolarCore ()]]
16:40:30 <c_wraith> I'd assume the problem is that .hs-boot files suck. 
16:40:43 <Shockk> the other module defines PolarLL which is made up from LLState 
16:40:48 <Shockk> LLState also has a field of the same type
16:41:34 <Shockk> I tried using an hs-boot file but that forms a cycle as well because the definition of both PolarCore and PolarLL depend on each other
16:44:14 <Shockk> one solution I know exists would be to put both definitions in the one file, although that's not ideal because it prevents me from organizing the two separately 
16:44:41 <hpc> pick a better separate organization, honestly
16:45:17 <c_wraith> Don't forget that you can re-export the types from other modules. 
16:45:36 <Shockk> c_wraith: hmm, that's true
16:46:12 <Shockk> I'll do that I think
16:50:52 <sclv> cmccann: ping
16:51:27 <dmwit_> I don't understand "I tried using an hs-boot file but that forms a cycle as well.".
16:51:30 <dmwit_> Can we get a MWE?
16:51:37 <c_wraith> sclv: I'll update tonight, but that'll be in like 4-5 hours.
16:52:03 <sclv> c_wraith: cool, no prob, i'll add you to my email list of potential testers
16:52:41 <dmwit> I have a cabal sandbox that's not associated with a specific cabal package (there are several packages that I want to install into the sandbox). I can specify `-w ghc-7.6.3` when running `cabal install`; how can I specify which GHC to use when running `cabal sandbox hc-pkg`?
16:53:10 <dmwit> Shockk: (Above comment about MWE was aimed at you.)
16:53:20 <Shockk> oh, hmm?
16:53:26 <Shockk> MWE?
16:53:31 <dmwit> minimal working example
16:53:39 <dmwit> where here "working" means "produces the error you're seeing"
16:54:25 <tommd> dmwit: Does 'cabal install --with-hc=...' not do as desired?
16:54:46 <tommd> or perhaps --with-ghc
16:55:14 <Shockk> ohh, I am/was declaring the data type PolarState (which contains the field) with the constructor too, in the hs-boot file
16:55:16 <dmwit> tommd: "unrecognized 'sandbox' option `--with-hc'"
16:55:20 <dmwit> tommd: Same for with-ghc
16:55:42 <dmwit> tommd: `cabal install` is fine; I'm asking about `cabal sandbox hc-pkg`
16:55:48 <Shockk> but I actually removed the constructor just now after reading they aren't required for data definitions in hs-boot files
16:56:03 <Shockk> and now I'm not getting a cycle any more
16:56:16 <dmwit> Shockk: Great!
16:57:12 <hunteriam> how do i hide something from prelude?
16:57:20 <dmwit> import Prelude hiding (...)
16:57:26 <hunteriam> thanks
16:57:32 <cmccann> sclv: pong
16:57:45 <dmwit> Unless "something" is a class instance; in which case you must use the NoImplicitPrelude language extension.
17:06:05 <geekosaur> dmwit, I think that goes in cabal.config inside the sandbox (with-hc-pkg: /path/to/ghc-pkg-versionmaybe)
17:08:42 <maudefi_> q
17:18:19 <hunteriam> whats the best way to find the minimum value & its index in a mutable vector?
17:18:27 <hunteriam> it seems like i want to convert it to a regular vector
17:18:31 <hunteriam> since mutables arent foldable
17:19:46 <Tekmo_> hunteriam: Data.Vector.minIndex
17:20:05 <hunteriam> ah i forgot Data.Vector had things that work on mutables
17:20:06 <hunteriam> thanks
17:20:15 <Tekmo_> You're welcome!
17:26:09 <Stoner19> has anyone had experience with rss2irc ?
17:27:02 <Stoner19> Error (TlsException (HandshakeFailed (Error_Protocol ("certificate rejected: chain doesn't match",True,CertificateUnknown)))), retrying in 5 minutes
17:28:41 <maudefi__> he
17:30:49 <Romefeller> Hey
17:30:59 <Romefeller> can anyone help me with yesod?
17:32:35 <maudefi__> sd
17:34:50 <mpickering> Romefeller: Ask your question and someone will answer if they know
17:35:19 <Romefeller> static file subsite
17:35:21 <Romefeller> i want a img with a jpg
17:35:26 <Romefeller> and my router got lost
17:35:31 <Romefeller> http://lpaste.net/142041
17:35:49 <dmwit> geekosaur: Hrm. When I set with-hc-pkg in cabal.sandbox.config, it complains that ghc and ghc-pkg have a version mismatch. There doesn't seem to be a corresponding with-hc or with-ghc option to set (neither is recognized).
17:36:00 <dmwit> (Is this stuff documented anywhere...?)
17:36:22 <geekosaur> it's with-compiler
17:36:35 <geekosaur> look in ~/.cabal/config, not really documented but all options shown
17:36:52 <dmwit> Well, that gets me a new error, anyway.
17:37:01 <dmwit> "ghc-pkg: too few bytes. Failed reading at byte position 41"
17:37:35 <Stoner19> Romefeller me first :p
17:37:49 <dmwit> It seems to be pointing ghc-pkg-7.6.3 at the 7.10.1 package database for some reason.
17:38:09 <Romefeller> Stoner19: ?
17:38:23 <Stoner19> Error (TlsException (HandshakeFailed (Error_Protocol ("certificate rejected: chain doesn't match",True,CertificateUnknown)))), retrying in 5 minutes
17:38:24 <Stoner19> from rss2irc
17:38:57 <geekosaur> I think you need to set package-db in that case
17:39:10 <geekosaur> not sure of that though
17:39:50 <dmwit> geekosaur: In any case, --verbose got me enough information to invoke ghc-pkg on my own, which is enough for now.
17:39:57 <Stoner19> I can't even find where rss2irc files are located to try and make modifications
17:39:59 <dmwit> I'll figure out how to wrangle cabal-install properly another day.
17:40:02 <dmwit> Thanks for the help.
17:40:43 <Sindriava> dmwit: Good luck with that.
17:40:57 <dmwit> Sindriava: It is a journey.
17:42:29 <mpickering> I think -w ghc-7.11xxxxx also points to the right hc-pkg exe
17:42:39 <Sindriava> I wouldn't wish it on anyone, though
17:43:02 <dmwit> mpickering: `cabal sandbox hc-pkg` doesn't seem to understand `-w`
17:43:52 <Shockk> I compiled my game engine loop code, ran it
17:43:54 <mpickering> if you "cabal configure -w ghc-711.." and then cabal sandbox hc-pkg
17:43:58 <mpickering> does it do the right thing?
17:44:06 <Shockk> 20 minutes later I've finished rebooting after my code hung my whole PC
17:44:16 <dmwit> mpickering: There's no *.cabal file here, so cabal configure doesn't work.
17:44:20 <Sindriava> Shockk: Are you using linux?
17:44:24 <Shockk> Sindriava: Windows
17:44:27 <dmwit> mpickering: (There are several packages in subdirectories.)
17:44:43 <Sindriava> Shockk: Welp, not even the pope can help you :D
17:44:48 <Shockk> lol
17:44:53 <Sindriava> Shockk: Do you have an nvidia graphics card?
17:45:02 <Sindriava> An older one, presumably?
17:45:09 <Shockk> oh I wasn't even doing anything graphics-related
17:45:32 <Shockk> literally just empty loop, looping continuously
17:45:36 <Sindriava> Nothing at all? Not even initialising SDL or GLFW or something like that?
17:45:37 <Sindriava> Oh
17:45:48 <Sindriava> like "forever $ return ()" ?
17:46:12 <Shockk> not exactly, hmm let me get the code up again
17:46:55 <hunteriam> whats the recommended way to take a [Maybe a] and map over it to [Maybe b]
17:47:02 <geekosaur> Stoner19, https://github.com/vincenthz/hs-tls readme might nbe of interest
17:47:08 <hunteriam> im sure tehres something in Data.Maybe, but what about Control.Monad? Or something better?
17:47:16 <Stoner19> will check it out geekosaur thank you
17:47:27 <Sindriava> hunteriam: fmap.fmap
17:47:54 <dmwit> getCompose . fmap . Compose
17:47:56 <geekosaur> I have no idea where it thinks the "OS keystore" is though
17:48:02 <hunteriam> Hm those are nice solutions
17:48:06 <hunteriam> but not the most readable i think
17:48:15 <hunteriam> thanks anyways
17:48:15 <Sindriava> hunteriam: You're not looking at it in a general enough way, what you've described is basically `f (g a) -> f (g b)`
17:48:28 <hunteriam> yea i get it
17:48:29 <Sindriava> hunteriam: fmap.fmap is idiomatic and readable.
17:48:36 <hunteriam> maybe to other haskellers
17:48:51 <hunteriam> i dont think itll be very readable to people less experienced with haskell
17:48:58 <Sindriava> hunteriam: Isn't that the point of readability? Should it be readable to COBOL programmers?
17:49:06 <hunteriam> no youre right
17:49:11 <hunteriam> but in my circumstance youre not
17:49:20 <hunteriam> because this is for my teacher whos not a haskell programmer
17:49:25 <Sindriava> hunteriam: What would that circumstance be?
17:49:32 <lpaste> Shockk pasted “Run.hs” at http://lpaste.net/8470964530476744704
17:49:33 <hunteriam> ahem
17:49:44 <Sindriava> hunteriam: Then decompose it into smaller chunks.
17:49:53 <hunteriam> like map fmap?
17:49:58 <hunteriam> or what were you thinking
17:49:58 <Shockk> Sindriava: basically that code
17:50:19 <Sindriava> hunteriam: maybeAtoMaybeB = fmap foo
17:50:22 <dmwit> > let xs = [Nothing, Just 3, Just 68] in [ (+1) <$> x | x <- xs ]
17:50:24 <lambdabot>  [Nothing,Just 4,Just 69]
17:50:45 <Sindriava> hunteriam: Split the code into smaller chunks, and compose those.
17:51:27 <Sindriava> hunteriam: `fmap maybeAtoMaybeB listOfMaybes` is as readable as it gets
17:51:58 <hunteriam> :t fmap.fmap
17:51:59 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:52:24 <hunteriam> might go with map.fmap
17:52:31 <dmwit> :t \f xs -> f <$> Compose xs
17:52:32 <lambdabot>     Not in scope: data constructor ‘Compose’
17:52:32 <lambdabot>     Perhaps you meant variable ‘icompose’ (imported from Control.Lens)
17:52:34 <Sindriava> hunteriam: DON'T
17:52:40 <dmwit> :t \f xs -> f <$> Data.Functor.Compose xs
17:52:41 <hunteriam> i get why you dont want me to
17:52:41 <lambdabot>     Not in scope: data constructor ‘Data.Functor.Compose’
17:52:44 <dmwit> Sindriava: Why the heck not?
17:52:56 <hunteriam> because it obscures the idea of fmap/map being the same thing
17:53:00 <dmwit> :t \f xs -> f <$> Data.Functor.Compose.Compose xs
17:53:01 <lambdabot> (Functor f, Functor g) => (a -> b) -> f (g a) -> Data.Functor.Compose.Compose f g b
17:53:06 <hunteriam> and it makes [] different from other functors
17:53:18 <hunteriam> or look that way
17:53:19 <Sindriava> dmwit: And why the heck yes? It's poor code, it smells of not understanding that map is a subset of fmap and it's weird
17:53:35 <hunteriam> and yet i still want to
17:53:40 <hunteriam> because i think its easier to understand
17:53:40 <dmwit> Sindriava: Why the heck yes: because map is more monomorphic, and thus an aid to readers who don't want to run type inference in their head.
17:53:54 <hunteriam> :t monomorphic
17:53:56 <lambdabot> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Lib.ExpQ
17:54:02 <hunteriam> wow that returned something
17:54:10 <Sindriava> dmwit: I'm against `map` even existing in Prelude, so there's that.
17:54:30 <johnw> > [Nothing, Just 3, Just 68] & traverse._Just +~ 1
17:54:31 <lambdabot>  [Nothing,Just 4,Just 69]
17:54:32 <Sindriava> As far as readability and clarity goes, mixing map and fmap isn't either.
17:54:36 <Sindriava> johnw + 1
17:54:57 <hunteriam> i think it is
17:55:07 <hunteriam> because it makes it clear that youre using 2 different structures
17:55:34 <Sindriava> Except you're not, hngnngngng
17:55:39 <hunteriam> yes you are
17:55:43 <hunteriam> maybe and list are different structures
17:55:48 <hunteriam> even if they share properties
17:56:19 <Sindriava> hunteriam: Yet neither of the properties that make them different are required to do `f (g a) -> f (g b)`
17:56:22 <Ralith> fmap is not 'map but for Maybe'
17:56:33 <hunteriam> i know what fmap is
17:56:41 <hunteriam> and i know that sindriava
17:56:55 <dmwit> Ralith: Presumably if there were a standard "map but for Maybe", hunteriam would use that instead of fmap. =)
17:56:58 <dmwit> :t mapMaybe -- ?
17:56:59 <lambdabot> (a -> Maybe b) -> [a] -> [b]
17:57:09 <dmwit> yeah, not quite right
17:57:09 <Ralith> dmwit: in lieu of that, however, his statement is incoherent :P
17:57:15 <dmwit> Ralith: disagree
17:57:19 <hunteriam> thats still useful though
17:57:22 <Sindriava> Ralith: agree
17:57:24 <hunteriam> incoherent?
17:57:27 <hunteriam> ...
17:57:51 <Sindriava> hunteriam: It's not clear what you want to do and what you say you want to do isn't idiomatic, healthy or recommended
17:57:56 <Ralith> dmwit: there is nothing in 'map.fmap' that says 'two structures' more clearly than 'fmap.fmap'
17:58:14 <hunteriam> since map is used exclusively with lists
17:58:17 <hunteriam> using map . fmap
17:58:19 <Ralith> it just says 'one structure is a list' which may or may not be obvious from context or relevant regardless
17:58:23 <hunteriam> communicates youve got some structure inside a list
17:58:25 <cite-reader> Tiy =
17:58:33 <dmwit> Ralith: There is something. `map.fmap` asks the question: "Why `map` here, and `fmap` there?".
17:58:34 <Sindriava> hunteriam: I have never used map tbh
17:58:43 <hunteriam> good for you?
17:59:02 * Enigmagic makes some fresh popcorn
17:59:12 <Sindriava> hunteriam: You are hell-bent on rejecting every criticism I make
17:59:16 <hunteriam> no
17:59:19 <hunteriam> i understand your criticism
17:59:21 <hunteriam> and i disagree
17:59:31 <geekosaur> Sindriava, perhaps calm down a bit?
17:59:39 <Sindriava> geekosaur: Huh?
17:59:44 <dmwit> hunteriam: You could consider making a "map but for Maybe" and using it. You could call it... `mapM`. I bet Sindrivia would like that.
17:59:45 <geekosaur> or if you really want an aneurysm, go look at code on hackage...
17:59:52 <Shockk> map vs fmap for a list doesn't seem like a big deal#
17:59:53 <hunteriam> lol
18:00:03 <geekosaur> Sindriava, you are pointlessly picking a fight
18:00:07 <Sindriava> geekosaur: What makes you think I'm not calm? O.o
18:00:13 <Enigmagic> i propose we rename fmap as map in the Prelude. problem solved.
18:00:21 <Sindriava> Enigmagic + 1
18:00:22 <Enigmagic> then we can use map.map instead and get back to doing something productive
18:00:29 <hunteriam> i like that
18:00:51 <geekosaur> might even happen someday. the wheels of change grind slowly
18:01:15 <Sindriava> I'm not sure why it didn't happen when fmap was introduce, since it would be backwards compatible AFAIK
18:01:28 <Ralith> dmwit: yes, using map does marginally add information, but it does not "make it clear that you're using two different structures" compared to fmap.fmap except by the most tenuous of speculation
18:01:30 <geekosaur> meanwhile, Sindriava, what makes me think you';re not calm is you're all but beating hunteriam with a bat because they won't do it the way you prefer
18:01:39 <Sindriava> @src fmap :: (a -> b) -> [a] -> [b]
18:01:39 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
18:01:39 <Enigmagic> Sindriava: prior to H98 it map was actually fmap .. 
18:01:45 <Ralith> nor is that even particularly useful information
18:01:52 <Sindriava> Enigmagic: Really?
18:01:58 <Enigmagic> Sindriava: yes
18:02:05 <hunteriam> Ralith: i think its useful for someone who is new to haskell
18:02:09 <Shockk> Sindriava: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-712
18:02:16 <Shockk> that's what you're looking for
18:02:19 <geekosaur> yes. h98 committed a number of things now regarded as unfortunate if not evil, in the name of making things simpler for beginners
18:03:04 <Sindriava> geekosaur: "beating with a bat"? Don't you think that's a bit of an stretch? I simply disagree with mixing map and fmap for pretty good reasons, and in return I'm provided none. I'm honestly trying to solve this, not pick an argument, nor attack anyone.
18:03:12 <geekosaur> and there's actually a small but significant contingent, mostly involved with teaching Haskell, who would prefer that it remain that way (admittedly, they're probably throwing fits over the BBP)
18:03:13 <hunteriam> anyways
18:03:21 <hunteriam> heres what i want in the end
18:03:24 <hunteriam> :t (=<<)
18:03:25 <lambdabot> Monad m => (a -> m b) -> m a -> m b
18:03:28 <Shockk> BBP?
18:03:47 <geekosaur> Sindriava, you are disagreeing rather strenuously though, at least insofar as how you are expressing yourself in channel
18:04:31 <geekosaur> perhaps work on your presentation. high pressure isn't really helping
18:04:38 <Enigmagic> Shockk: this would be the burning bridges proposal
18:04:39 <Sindriava> geekosaur: I'm disagreeing consistently and for a good reason– mindlessly agreeing with someone doesn't get you to understand their point of view.
18:05:03 <geekosaur> Shockk, otherwise known as Foldable/Traversable Proposal
18:05:08 <Shockk> Enigmagic: oh, I've n- oh that
18:05:35 <geekosaur> "bridge burning proposal" because it had potential to break a lot of stuff by going more general than existing code expected
18:05:38 <hunteriam> i gotta say i love the way haskell builds up typeclasses
18:05:39 <Sindriava> geekosaur: And I *honestly* don't understand what got you so riled up. I will retract from the conversation then, since you appear to think I'm bearing some sort of ill intent in trying to explain why `fmap.fmap` is better than `map.fmap` O.o
18:05:47 <hunteriam> its very mathy
18:05:49 <geekosaur> what makes you think I am riled up?
18:06:09 <geekosaur> I am watching you apply what look like pressure tactics and suggesting you not do so
18:06:28 <Sindriava> geekosaur: "pressure tactics"? Like trying to get someone to explain what they mean?
18:06:38 <geekosaur> if I were actively annoyed by it, there'd be ops discussion going on by now
18:07:06 <Sindriava> geekosaur: To me, riled up means throwing around stuff like "pressure tactics" when I *really* didn't mean any harm
18:07:24 <Ralith> Sindriava: nobody is accusing you of malice
18:07:24 <Sindriava> geekosaur: If you want, let's settle this in PM, to not spam this channel any more
18:07:26 <geekosaur> [01 00:55] <Sindriava> Except you're not, hngnngngng
18:07:26 <geekosaur> [01 00:58] <Sindriava> hunteriam: You are hell-bent on rejecting every criticism I make
18:07:43 <geekosaur> these do not come across as reasoned discussion
18:07:46 <dmwit> Sindriava: For what it's worth, I also found your claims to be quite strongly stated compared to the impact of the decision.
18:08:09 <Ralith> geekosaur is just giving advice in good faith to improve your success in conveying your position
18:08:16 <dmwit> Sindriava: Perhaps take this as a chance to calibrate your internal pressure meter. =)
18:08:46 <Sindriava> Ralith: So was I, yet when I do it, it's somehow considered malice :(
18:09:00 <Sindriava> dmwit: Pressure meter? Why does everyone keep insisting I'm angry or something?
18:09:12 <dmwit> Because you appear angry.
18:09:25 * hackagebot twiml 0.2.0.0 - TwiML library for Haskell  https://hackage.haskell.org/package/twiml-0.2.0.0 (andrus)
18:09:30 <Ralith> Sindriava: I reiterate, nobody thinks you were or are malicious
18:09:34 <Sindriava> dmwit: And to me, someone might appear hell-bent on rejecting what I say :(
18:09:43 <MarcelineVQ> hunt doesn't seem bothered, not sure why other people are trying to be bothered for him
18:09:49 <Sindriava> If anything, I'm really sad that my attempt to straighten up fmap vs. map caused this sort of reaction
18:10:03 <hunteriam> this is interesting though
18:10:07 <Sindriava> Because I'm still waiting to receive any argument against it that's on topic
18:10:37 <dmwit> More monomorphic is better for beginners, and better for experienced readers who don't want to do type inference in their heads.
18:10:48 <Enigmagic> *arguably
18:10:50 <Sindriava> dmwit: That's arguable at best.
18:10:57 <glguy> The whole topic is arguable
18:11:00 <Enigmagic> yep
18:11:05 <Sindriava> hunteriam: I really didn't mean any disrespect, I do *honestly* think that using map at all is a bad idea. I understand why it might seem better, and I disagree because I think obscuring this from anyone is just going to add more cruft
18:11:06 <Enigmagic> hence bikeshedding
18:11:09 <glguy> it's a matter of opinion, so everything that is said about it is going to be opinion
18:11:10 <dmwit> Or, to say it another way: why did you write `fmap.fmap` instead of `fmap fmap fmap`?
18:11:26 <hunteriam> Sindriava: i understand
18:11:47 <hunteriam> i dont think its worth talking more about
18:11:49 <Shockk> :t fmap fmap fmap
18:11:50 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
18:12:00 <MarcelineVQ> I'm also on the side of agreeing that having map is a good thing, both for teaching and for expressing the intent of working on a list. Especially when the person learning gets to fmap and has something they can relate to.
18:12:05 <Sindriava> hunteriam: Maybe try to introduce your situation a bit better, maybe if you're trying to show haskell to *complete* beginners, there's a better way to show it's properties?
18:12:12 <MarcelineVQ> Just to add 2 cents in
18:12:15 <hunteriam> im not trying to teach haskell
18:12:17 <hunteriam> im trying to use haskell
18:12:21 <Shockk> thanks dmwit that just blew my brain
18:12:23 <hunteriam> and it will eventually seep in
18:12:42 <Sindriava> Shockk: (.) is fmap for functions ^^
18:12:49 <glguy> Using map isn't for beginners, it's for using the specific operation you intended to when you aren't trying to work generally over all Functors
18:12:56 <hunteriam> Sindriava: map is fmap for lists
18:13:10 <Shockk> hmm huh I see 
18:13:21 <Sindriava> hunteriam: The difference is that (.) cannot be defined in haskell as it is AFAIK
18:13:33 <dmwit> ?src (.)
18:13:33 <lambdabot> (f . g) x = f (g x)
18:13:33 <Sindriava> :i (->a)
18:13:50 <Sindriava> oh yeah, lambdabot doesn't have info
18:14:16 <Shockk> instance Functor ((->) r) -- Defined in `GHC.Base'
18:14:27 <Sindriava> Huh, neat
18:14:59 <Sindriava> Shockk: Basically, if you replace the `f` in the type of `fmap` with `r ->`, you get `(.)`
18:15:10 <MarcelineVQ> oh man, learning how to make an instance of (->) r was so cool, reducing functions algenbraicly
18:15:19 <Sindriava> MarcelineVQ + 1, that's really fun
18:15:46 <Sindriava> It's fun to make a newtype for a function and see where that takes you
18:16:16 <MarcelineVQ> I'm doing nicta and that part of it was a real a-ha moment
18:16:35 <Sindriava> deriving lenses is real fun too
18:16:50 <codebje> a sad moment when travis's free container infrastructure can build my project faster than my own unloaded machine :(
18:17:06 <MarcelineVQ> What's that codebje?
18:17:20 <Sindriava> codebje: Maybe travis uses threads?
18:17:21 <codebje> a nearly empty hakyll site: https://github.com/codebje/hakyll-site
18:17:21 <dmwit> codebje: Hah, your computer is worse than worthless. =D
18:17:33 <codebje> dmwit has the right answer :-)
18:17:59 <MarcelineVQ> Oh hehe, I meant what's free container infrastructure?
18:18:03 <codebje> oh, travis
18:18:10 <codebje> continuous integration
18:18:14 <codebje> https://travis-ci.org/codebje/hakyll-site
18:18:51 <dmwit> MarcelineVQ: You may be thinking "free container" as in "free monad" or "free theorem". Instead you should be thinking of "free beer".
18:19:03 <Shockk> I'm still waiting for that container-based speed on travis :(
18:19:04 <codebje> zero-cost docker instance? :-)
18:19:14 <MarcelineVQ> I'm not thinking anything at all I don't know what it is ^^;
18:19:35 <shachaf> dmwit: Isn't "free theorem" free as in "free beer"?
18:19:42 <codebje> MarcelineVQ, every git push results in Travis pulling the changes and executing a stack build --test
18:19:58 <dmwit> shachaf: Oops, maybe!
18:20:12 <codebje> shachaf, both certainly leave me with a headache, yes
18:21:04 <MarcelineVQ> Oh I see it's a site that does the building
18:21:13 <codebje> and, if I had tests, would run the tests
18:21:56 <MarcelineVQ> I wonder what's in the eula
18:22:12 <obadz> I'm trying to implement a Json parser for matrices which must be rectangular. I'm leveraging up the Json parser for [[a]] but I need to introduce a check for rectangularity
18:22:18 <MarcelineVQ> Ah I see they get money from private repos
18:22:48 <obadz> if I do fmap listOfListToMatrix (parseJSON j) that works fine, but if I have listOfListToMAYBEMatrix, then obvioulsy that doesn't work
18:22:49 <Sindriava> obadz: Checking if all rows have the same size?
18:22:53 <obadz> Sindriava: yes
18:23:11 <geekosaur> right, they use spare capacity from the commercial service to provide free CI to any FOSS project (from some value of FOSS) on github
18:23:17 <codebje> :t mapM
18:23:18 <Sindriava> obadz: Something like… `foldr (==) $ length <$> rows` ?
18:23:18 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
18:23:23 <obadz> how do I compose parseJSON j :: Parser [[a]] to listOfListToMaybeMatrix :: [[a]] -> Maybe (Matrix a) ?
18:23:26 <geekosaur> of course you get to wait in line if one of the paying customers needs a build...
18:23:55 <obadz> Sindriava: I've already written listOfListToMaybeMatrix, it's the parser composition that kills me
18:24:13 <Sindriava> ah
18:24:48 <Sindriava> fmap listOfListToMaybeMatrix (parseJSON j) :: Parser (Maybe (Matrix a)) ?
18:24:54 <codebje> parseJSON >>= return . listOfListToMaybeMatrix ?
18:25:29 <Sindriava> :t (>>=) . return
18:25:31 <lambdabot> Monad m => a -> (a -> m b) -> m b
18:25:53 <obadz> codebje: that's fmap
18:25:59 <Sindriava> yep
18:26:23 <obadz> Sindriava: I don't want a Parser (Maybe (Matrix a)) I want a Parser (Matrix a) (parsers already use Results for success/failure)
18:26:34 <Sindriava> obadz: Oh
18:26:54 <dmwit> :t (>>= maybe (fail "bad matrix") id)
18:26:56 <lambdabot> Monad m => m (Maybe (m b)) -> m b
18:27:03 <dmwit> ew, no
18:27:12 <dmwit> :t (>>= maybe (fail "bad matrix") return)
18:27:13 <lambdabot> Monad m => m (Maybe b) -> m b
18:27:13 <Sindriava> obadz: if Parser is MonadPlus, you could maybe use guard?
18:27:24 <Sindriava> dmwit + 1
18:27:39 <dmwit> Substitute whatever aeson's way of reporting errors is for `fail` there.
18:28:05 <Shockk> quick question; 
18:28:26 <obadz> dmwit / Sindriava, thanks that makes sense. Thought fail was like error but I realize it's not.
18:29:09 <Sindriava> obadz: Alternatively, you could skip the Maybe and do the failing in the conversion function
18:29:29 <Sindriava> But that's mad ugly
18:29:35 <Sindriava> now that I think about it
18:29:36 <codebje> :t fail
18:29:38 <lambdabot> Monad m => String -> m a
18:29:41 <codebje> make the parser generic
18:29:47 <codebje> fail in Maybe is Nothing, I think
18:29:50 <Shockk> it's my understanding that with GHC, forkIO runs the IO action on a lightweight thread as opposed to a full separate thread
18:29:50 <dmwit> ?let ensure p x = x <$ guard (p x)
18:29:52 <lambdabot>  Defined.
18:30:15 <Sindriava> :t (<$)
18:30:16 <lambdabot> Functor f => a -> f b -> f a
18:30:19 <Shockk> do functions like threadDelay block an entire thread or only the lightweight thread they're run on?
18:30:24 <dmwit> :t let isRectangular :: [[a]] -> Bool; isRectangular = undefined in (>>= ensure isRectangular)
18:30:26 <lambdabot> (Monad m, Alternative m) => m [[a]] -> m [[a]]
18:30:31 <awpr> Shockk: only the individual green thread
18:30:41 <Shockk> ahh great, thanks
18:30:46 <hunteriam> it seems to me that IOVector from Data.Vectors.Mutable is not convertable to Vector
18:30:51 <geekosaur> Shockk, even forkOS creates lightweight threads, it just uses a different mapping from lightweight threads to capabilities (real threads)
18:30:52 <codebje> listOfListToMaybeMatrix :: Monad m => [[a]] -> m (Matrix a) ; use fail in place of Nothing, and use return in place of Just
18:30:57 <hunteriam> since "freeze" doesnt work on it, which i think is strange
18:31:04 <hunteriam> seems like an inconsistency to me
18:31:04 <geekosaur> and yes, threadDelay blocks only the lightweight thread
18:31:07 <codebje> then it'll work if you run it in the Parser monad
18:31:09 <Shockk> ahh
18:31:52 <Shockk> oh, I just noticed one of these functions I didn't notice before
18:32:12 <Shockk> I'm assuming it's better to call `yield' than `threadDelay 1'
18:32:16 <Enigmagic> or you can use `empty` instead of guard/fail/etc so you're not restricted to monadic parsers :p
18:32:42 <obadz> so this seems to work:
18:32:43 <obadz> parseJSON j = Json.parseJSON j >>= (helper . fromLists')
18:33:05 <obadz> where helper (Just v) = return v; helper Nothing = fail "Some error"
18:33:37 <obadz> is helper something that can be trivially written with some fancy monad magic?
18:34:11 <dmwit> Shockk: It's probably about the same.
18:34:18 <Shockk> ah right
18:34:40 <awpr> Shockk: sure, probably marginally better, but why do you need either?  even when I was still writing Go I only had to explicitly yield one or two times ever
18:35:12 <dmwit> Shockk: You shouldn't need yield in most cases. Exceptional circumstances include programs with unsafe FFI calls and tight (non-allocating) pure loops.
18:35:21 <hunteriam> https://www.irccloud.com/pastebin/Rk5TSovX/wtf
18:35:24 <hunteriam> what have i done
18:35:28 <Shockk> I'm writing a game engine loop and I just don't want that loop to use 100% of the cpu
18:35:37 <hunteriam> how could these possibly be different types
18:35:46 <dmwit> Shockk: You should ask your event handler to block on an event instead.
18:36:01 <dmwit> Shockk: (And, assuming you want to wake up periodically, make a timer be one of the events.)
18:36:18 <obadz> codebje: oh I see you've answered my question!
18:36:26 <Shockk> hmm.. that sounds like a good idea
18:37:10 <dmwit> s/on an event/until an event happens/
18:38:03 <hunteriam> can anyone help me resolve this quagmire?
18:38:28 <hunteriam> well its this:
18:38:28 <hunteriam> https://www.irccloud.com/pastebin/Rk5TSovX/wtf
18:38:41 <hunteriam> to me, these types are equivalent
18:38:44 <hunteriam> but ghc disagrees
18:39:48 <lpaste> Prateem pasted “ad infinitum msum issue” at http://lpaste.net/142046
18:39:52 <awpr> hunteriam: the expected type is more general -- it has to include any m0, not just IO.  (I think the other choice is ST)
18:40:37 <hunteriam> why do we have foldl and foldr vs. foldl and fold
18:40:52 <Enigmagic> :t fold
18:40:53 <lambdabot> (Foldable t, Monoid m) => t m -> m
18:41:02 <maudefi> exit
18:41:17 <hunteriam> i see
18:41:50 <prateem> Newbie question.. I am reading the chapter on Monad transformers (https://en.wikibooks.org/wiki/Haskell/Monad_transformers) and my implementation is almost identical but the adinfinitum msum example is not working
18:42:06 <obadz> Is there a circumstance where fail "some string" becomes Left/Right "some string" in Either monad?
18:42:36 <dmwit> obadz: Yes, the Error monad does that.
18:42:37 <prateem> I pasted the code and output here http://lpaste.net/142046 and I could not figure out the issue with my implementation
18:42:43 <geekosaur> @src Error fail
18:42:43 <lambdabot> Source not found. Maybe you made a typo?
18:43:21 <awpr> obadz: unfortunately not for Either, because it would require overlapping instances, but you could make a newtype wrapper for Either String that does that.
18:43:31 <hunteriam> awpr: that doesnt make any sense, actually, in this context
18:43:34 <geekosaur> silly @src database... Error/ErrorT monad, fail = Left
18:43:41 <hunteriam> im just assigning something to freeze vector
18:43:48 <hunteriam> theres no constraints in the type signature
18:44:16 <hunteriam> NEVERMIND
18:44:20 <awpr> hunteriam: I'm just explaining what the error message says.  without the source that triggered it there's not much more I can do
18:44:25 <dmwit> prateem: Your MonadPlus instance looks a bit funny.
18:44:38 <obadz> dmwit / awpr: I'm noticing that Json.eitherDecode returns Left "errorMsg" where my parser invoked fail "errorMsg"
18:44:42 <dmwit> prateem: In the Just case, are you sure you want to run the `x` action a second time?
18:44:43 <obadz> wondering how it got there
18:45:08 <dmwit> obadz: That is a question about aeson's Parser monad, not about Either.
18:45:42 <obadz> k, probably a question for another day :)
18:45:53 <awpr> obadz: to add to what dmwit said, I'm fairly certain eitherDecode translates whatever 'fail' does in 'Parser' to 'Left'.
18:46:11 <prateem> dmwit: Can you explain why is that creating a problem?
18:46:20 <obadz> for functions that might fail, does it make sense to use return/fail rather than Just/Nothing ?
18:47:29 <Ralith> fail doesn't usually make sense, and even when it's defined, it can make little sense e.g. due to throwing away its argument
18:47:38 <awpr> obadz: I usually avoid the 'fail' from 'Monad' because I never correctly predict what it will do.  I do often use return over Just, though.
18:47:58 <awpr> obadz: also, if you want something more generic to use for Nothing, look at 'mzero' from 'MonadPlus'
18:48:00 <awpr> :t mzero
18:48:02 <lambdabot> MonadPlus m => m a
18:48:23 <dmwit> prateem: Certainly. Suppose the first action is to get a line and check if it's a password. If it succeeds, and you run it again, it will get a line a second time and check that the new line is a password.
18:48:38 <dmwit> prateem: Instead of getting a second line, one should simply succeed immediately.
18:49:49 <obadz> awpr: I enjoy the string comment, maybe throwError in MonadError ?
18:50:26 <prateem> dmwit: Confirmed that it was the issue. That was the only change I made and guess that was the only problem with the code :) Thanks for the clear explanation
18:50:45 <dmwit> prateem: Try running this action to see what I mean: `mplus (MaybeT (putStrLn "I print twice!" >> return (Just 3))) (MaybeT (putStrLn "I never print" >> return Nothing))`.
18:51:34 <dmwit> prateem: glad it's working now =)
18:53:14 <obadz> is section 4 of http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/ incorrect, insinuating that fail would end up in Left ?
18:55:44 <davean> obadz: Why would it be?
18:56:41 <dmwit> obadz: It is incorrect, yes. A bit outdated.
18:57:00 <davean> did that change? Neat (I haven't used fail in years)
18:57:03 <obadz> davean: case (fail "hi") of Left x -> x ; Right _ -> "ho"
18:57:09 <dmwit> obadz: The modern libraries use `fail = error` for `Either`; `fail = Left . strMsg` for `Error`.
18:57:21 <obadz> davean: hits bottom rather than return a string
18:57:39 <dmwit> well... `fail = ErrorT . Left . strMsg` or some suitable lifted version of that, anyway
18:57:40 <awpr> > fail "hi" :: Either String Int
18:57:42 <lambdabot>  *Exception: hi
18:57:54 <dmwit> > fail "hi" :: Error String Int
18:57:55 <lambdabot>  Not in scope: type constructor or class ‘Error’
18:57:58 <davean> (I've always considered that a terrible way to return errors)
18:58:24 <dmwit> > fail "hi" :: Control.Monad.Error.Error String Int
18:58:25 <lambdabot>      Not in scope: type constructor or class ‘Control.Monad.Error.Error’
18:58:47 <dmwit> But yes, use of `fail` is generally frowned upon.
18:59:04 <dmwit> That is why I suggested looking up what aeson uses for error reporting instead of using `fail` when you asked your very first question.
18:59:29 <obadz> dmwit: you mention Error, but the packag efor Control.Monad.Error says Control.Monad.Except supersedes it.. or am I looking in the wrong place?
18:59:52 <dmwit> You are looking in the right place.
19:00:00 <dmwit> throwError is preferred over fail, and Except over Error
19:00:16 <awpr> indeed, the issue with Error (iirc) is that it needs a string-related constraint on its error type
19:02:37 <obadz> throwError "hi" :: Either String Int
19:02:40 <Sindriava> what's the equivalent of `cabal run` for stack?
19:02:41 <obadz> => Left "hi" !
19:02:45 <obadz> finally I get it :)
19:03:59 <dmwit> I find it puzzling that *that* cleared things up for you.
19:06:07 <obadz> :)
19:06:59 <obadz> grmbl, can't I compose a MonadError with a regular Monad ?
19:07:15 <julianleviston> If I want to pretty print (to string) an in-memory structure for later round-tripping… should I use this? http://hackage.haskell.org/package/pretty-show
19:07:44 <obadz> MonadErrors bound together need the same error type I assume?
19:11:57 <obadz> so if x :: Parser a, and f :: MonadError String m => a -> m b, x >>= f doesn't typecheck?
19:27:18 <Denommus`> can stack be used with ghcjs?
19:29:08 <fizruk> Denommus`: yes
19:31:16 <fizruk> Denommus: see here https://github.com/commercialhaskell/stack/issues/749#issuecomment-143184033
19:32:04 <fizruk> Denommus: and here (for improved base): https://github.com/commercialhaskell/stack/pull/1030#issuecomment-144570922
19:32:41 <emmanuel_erc> Is anyone having issues with the fgl-5.2.2.3?
19:32:47 <obadz> sometimes ghc-mod shows ghc-prim-0.4.0.0:GHC.Prim.Any in type inference. what is it and how can I make it go away?
19:32:50 <emmanuel_erc> package?
19:34:41 <ReinH> julianleviston: what sort of round-tripping?
19:35:15 <julianleviston> ReinH: um..
19:35:29 <julianleviston> ReinH: I’d like to put it into a DB, then pull it out again later
19:36:24 <julianleviston> ReinH: without doing any kind of translation to RDBMS data.
19:36:53 <hunteriam> what should i use to profile?
19:37:11 <julianleviston> hunteriam: GHCi has some simple profiling built in...
19:37:24 <hunteriam> someone reccomended a library or something to me earlier
19:37:26 <hunteriam> that was external
19:37:40 <julianleviston> hunteriam: if you :set +s it’ll do time/memory stats for anything
19:37:44 <julianleviston> ah ok sorry
19:37:55 <hunteriam> np
19:38:34 <hunteriam> "criterion"
19:38:52 <ReinH> julianleviston: Most Haskell database libraries handle that for you
19:39:02 <julianleviston> ReinH: they do?
19:39:15 <julianleviston> ReinH: but I’d like to be able to edit it offline as text.
19:39:31 <ReinH> Yeah. Alternatively, I'd suggest using aeson instances to encode as json
19:39:43 <Sindriava> How can I get from Vector to MVector?
19:39:51 <julianleviston> ReinH: I don’t understand.
19:39:56 <Denommus`> fizruk: thanks
19:40:05 <Denommus`> fizruk: one more question: can I have an hybrid project?
19:40:07 <julianleviston> ReinH: how can json represent, say, a sum data type?
19:40:15 <Denommus`> fizruk: like, with a GHC backend and GHCJS frontend?
19:40:19 <julianleviston> ReinH: can aeson encode haskell types?
19:40:23 <ReinH> Yes, of course.
19:40:48 <fizruk> Denommus`: you can have two .yaml files, one with GHC resolver, one with GHCJS
19:40:52 <ReinH> You can also use template haskell to automatically generate the instance for encoding/decoding
19:40:57 <ReinH> *instances
19:40:57 <Sindriava> Are sum data types semantically different from tagged unions?
19:41:27 <fizruk> Denommus`: e.g. stack.yaml for backend and stack-ghcjs.yaml for GHCJS for frontend
19:41:37 <radix> Sindriava: nope, they're the same
19:41:48 <radix> they're typically referred to as "sum type" in the haskell world
19:41:53 <fizruk> Denommus`: `stack build --stack-yaml stack-ghcjs.yaml` will then build frontend
19:42:06 <julianleviston> ReinH: but JSON can’t express things like sum data types, can it?
19:42:09 <Sindriava> Yeah, then that's really trivial to serialise, julianleviston
19:42:17 <Sindriava> julianleviston: Easily, as a tagged union :)
19:42:20 <julianleviston> ReinH: and how do you serialise code into it?
19:42:30 <tabemann> ugh why am I using yi
19:42:36 <fizruk> Denommus`: does that make sense? I am trying out this myself right now :)
19:42:41 <ReinH> julianleviston: http://artyom.me/aeson
19:43:04 <Sindriava> How do I create an MVector from a Vector?
19:43:22 <Sindriava> *IOVector
19:43:44 <Sindriava> *IOVector from a Vector
19:43:45 <tabemann> (okay, I am using it because haskell-mode is breaking w.r.t. indentation in a source file of mine... except yi is also broken in a different way; the thing is that yi is like a horribly minimal version of emacs such that much functionality I would expect simply isn't present)
19:44:18 <tabemann> maybe I'm onna start editing my Haskell code with vim
19:44:37 <Sindriava> tabemann: Vim's pretty good for Haskell, with `vim2hs` and such
19:44:58 <sclv> anyone on OS X who is willing to help test the new platform installer (putting symlinks into /usr/local/bin instead of /usr/bin) take a look here: https://github.com/haskell/haskell-platform/issues/205#issuecomment-144600675
19:45:26 <sclv> ideally people on the new El Capitan should give it a try, but it would be good to ensure it works for prior versions of OS X as well
19:45:51 <Denommus`> fizruk: it does make sense
19:46:18 <tabemann> the only thing is that I dislike vim, and am definitely an emacs user by habit
19:46:24 <kristof> Ah, shoot.
19:46:40 <kristof> Guys, tags are not caps sensitive, are they ?
19:47:06 <kristof> etags, at least. I like to pun constructors with functions of the same name.
19:47:12 <Sindriava> tabemann: Honest to god suggestion: Learn vim, it will change the way you look at text editing. Emacs is better in everything except UI in my opinion. But the modes are just *so good*
19:47:36 <Sindriava> tabemann: You can look over my vim setup on my github, I've got some haskell specific stuff there
19:48:17 <ReinH> *spacemacs*
19:48:29 <Sindriava> ReinH + 1, I was just writing that out
19:49:11 <levi> spacemacs++
19:49:35 <Sindriava> [a] -> [a] 
19:51:15 <julianleviston> ReinH: ah ok so data contsructors basically become object names… seems very boilerplatey
19:52:57 <julianleviston> ReinH: thanks!
19:53:15 <Sindriava> How can I get from Vector to IOVector?
19:53:55 <glguy_> thaw
19:54:37 <Sindriava> glguy_: Thanks!
19:55:29 <maudefi> exit
19:55:30 <erikd> @src extQ
19:55:30 <lambdabot> Source not found. Wrong!  You cheating scum!
20:00:45 <erikd> i'm looking at https://wiki.haskell.org/Quasiquotation and when i try to compile the code i get: Not in scope: ‘extQ’
20:02:11 <tabemann> Sindriava: I just find the different modes and the way commands have to be entered to be awkward in vim
20:02:15 <glguy`> ExtQ is an SYB thing
20:02:48 <erikd> glguy`: ah yes, that makes sense
20:03:01 <Sindriava> tabemann: Yeah, I did too, at first. But the powerful idea is that text isn't just something you edit, it's something you can also view, move in and manipulate without writing
20:03:43 <Sindriava> tabemann: Vim sucks on many levels, but it's currently amongst the *very* few editors that support this, and I find it very comfortable after 3 years with Vim
20:03:57 <Sindriava> tabemann: Also probably topic for #haskell-blah :)
20:04:13 <tabemann> when I wan tto just view something, I use less
20:07:01 <obadz> (try (print x)) >>= \ x -> case x of { Left _ -> putStrLn "Exception caught!" ; Right _ -> putStrLn "Carry on" } => anyone understands this type error? complaining with: No instance for (Exception e0) arising from a use of ‘try’
20:07:50 <obadz> I'd except the signature of this to be IO (), so not sure why it cares about the Exception typeclass at all..
20:08:25 <Hijiri> obadz: ghc doesn't know what exception type you are trying to catch in try
20:09:01 <obadz> oh
20:09:09 <Hijiri> you need to annotate x with the exception type or otherwise do something that the compiler can infer it from
20:09:24 <obadz> is Real World Haskell not up to date?
20:09:36 <obadz> http://book.realworldhaskell.org/read/error-handling.html doesn't have annotations
20:10:06 <Sindriava> obadz: Careful that ghci behaves differently than code in a file
20:10:14 <Sindriava> obadz: Monomorphism restriction is on by default in ghci IMO
20:10:18 <obadz> looks like Exception used to be an algebraic datatype rather than a typeclass
20:10:55 <Hijiri> RWH is out of date in some places, I don't know if this is one of them
20:11:34 <glguy`> Looks like this is one
20:12:04 <obadz> k
20:12:12 <obadz> looks like error handling has evolved a lot
20:13:44 * obadz over & out. thx all.
20:18:49 <Denommus`> fizruk: what version of stack is that? That resolver didn't work here :-/
20:19:32 <fizruk> Denommus`: try stack upgrade --git, some fixes have been merged but not released yet
20:20:00 <Denommus`> fizruk: thanks again
20:20:31 <fizruk> Denommus`: you're welcome!
20:40:50 <radens> How do I write my own type extension for haskell? I would like to capture something which haskell currently does not.
20:41:00 <radens> Such a thing is possible: https://downloads.haskell.org/~ghc/6.4-latest/docs/html/users_guide/type-extensions.html
20:42:38 <nshepperd> typechecker plugins?
20:51:21 <julianleviston> How come if in my module I have OverloadedStrings, it doesn’t turn that extension on in GHCi when I load the module?
20:51:29 <julianleviston> Is there a way to circumvent this?
20:51:53 <dfeuer> julianleviston, it doesn't turn them on ever :(
20:52:02 <dfeuer> I don't know if thtere's a good workaround.
20:52:33 <ReinH> Well, importing modules doesn't turn on their extensions.
20:53:12 <julianleviston> ReinH: bummer. I’m just trying to type :l test and get it to make the code I’m testing work...
20:53:35 <dfeuer> ReinH, right, but when I type  ghci file.hs, I'm not just importing a module. I'm also granted access to non-exported identifiers. 
20:53:36 <julianleviston> my pseudo-repl-driven development style :)
20:54:03 <dfeuer> Since I'm already in a land of not-exactly-haskell, I think it's only fair to get the extensions from the module while I'm at it.
20:54:32 * hackagebot patches-vector 0.1.0.1 - A library for patches (diffs) on vectors, composable and invertible.  https://hackage.haskell.org/package/patches-vector-0.1.0.1 (LiamOConnorDavis)
21:05:59 <julianleviston> ReinH: so I guess I just have to use set then...
21:07:38 <nolrai66> are there any good example instances of arbitrary for rose trees around?
21:08:39 <julianleviston> nolrai66: pretty sure there’s a standard rose trees lib 
21:09:01 <nolrai66> Ah.
21:09:05 <julianleviston> nolrai66: https://hackage.haskell.org/package/rose-trees maybe?
21:09:18 <julianleviston> nolrai66: https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Tree.html
21:09:22 <julianleviston> the latter is what I was thinking of
21:10:01 <julianleviston> haven’t used either 
21:12:07 <nolrai66> Doesn't seem to have an arbitrary instance.
21:12:12 <nolrai66> *Arbitrary
21:16:52 <nolrai66> ANd the kunth trees do, but its naive.
21:16:54 <nolrai66> Hmm.
21:17:21 <nolrai66> Really I just want a way to choose an 'arbitrary' partition of a given number.
21:18:10 <kazagistar> The nice thing about Arbitrary is that it makes it pretty straightforward to make a new instance
21:19:00 <nolrai66> Yeah, what I am having trouble with is taking a size and figureing out how I shouuld break that up among the children. (and how many children should there be.)
21:21:02 <nolrai66> Is (the first element of a random partition ++ a random partition of whats left) the same distrubution as a random partition? 
21:21:27 <nolrai66> Eh, its probobly close enough.
21:21:43 <nolrai66> I don't need it exact, just not horribly biased.
21:22:30 <nolrai66> Now I just need to figure out what a random element in a partition looks like.
21:24:06 <awpr> https://en.wikipedia.org/wiki/Dirichlet_distribution
21:28:12 <kazagistar> @nolrai66 yeah, that looks like it could actually end up being a tough problem, depending on the distribution you are looking for
21:28:12 <lambdabot> Unknown command, try @list
21:29:06 <Denommus`> holy cow, I didn't remember that GHCJS boot takes so long
21:33:17 <bakibour> Greetings
21:34:43 <bakibour> I would really like to use stackage, has anyone got it to run on Windows and setting it up with some IDE like Atom or Sublime?
21:35:03 <kazagistar> nolrai66: there is a nice isomorphism between rose trees and binary trees, but I suspect the binary tree arbitrary won't act like you want
21:35:08 <bakibour> I struggle a bit with installing ghc-mod and the lot
21:49:58 <julianleviston> bakibour: do you mean stack?
21:50:34 <julianleviston> bakibour: just wondering - how do you install stackage? I thought it was a package repo?
21:52:09 <Denommus`> bakibour: if you're using stack, stack-ide > ghc-mod
21:56:07 <bakibour> julianleviston: yes
21:56:27 <bakibour> Denommus`: Stack-ide?
21:56:55 <Denommus`> bakibour: https://github.com/commercialhaskell/stack-ide
21:56:56 <bakibour> I just downloaded the binaries for windows and ran stack to download ghc
21:57:16 <Denommus`> I don't know if it supports vim, though
21:57:56 <bakibour> Well id like to run Atom :) so ill have to see how it works out
21:58:34 <njosh> What does :set +s return as the memory used?
21:58:44 <njosh> What memory is this? 
21:59:41 <njosh> Memory allocated and garbage collected during the execution? 
22:00:07 <njosh> The accumulative sum of all the allocations? 
22:01:11 <Hafydd> njosh: "Display some stats after evaluating each expression, including the elapsed time and number of bytes allocated. NOTE: the allocation figure is only accurate to the size of the storage manager's allocation area, because it is calculated at every GC. Hence, you might see values of zero if no GC has occurred."
22:01:17 <Hafydd> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-set.html#idp7248304
22:02:15 <njosh> Okay. That's why [x*x | x <- [1..100]] shows non-zero memory usage only after the first time it is evaluated in ghci. 
22:02:19 <njosh> Hafydd: Thanks.
22:03:08 <julianleviston> njosh: you might want http://hackage.haskell.org/package/criterion instead
22:04:45 <julianleviston> njosh: errr don’t listen to me… that’s only perf.
22:05:12 <njosh> julianleviston: No problem. 
22:11:07 <julianleviston> Is there really nothing that will just spit out Haskell data structures as a big string for me?
22:11:20 <julianleviston> rather than wrangling through JSON?
22:11:30 <julianleviston> show / read just won’t do it, right?
22:12:10 <shirt> Should i use Data.Maybe.maybeToList or Data.Foldable.toList ?
22:13:38 <julianleviston> is Parsec a bad idea?
22:14:21 <liste> julianleviston what'd you do with that string?
22:14:39 <julianleviston> liste: sorry?
22:15:03 <liste> the Haskell data structures as a big string
22:15:14 <Hafydd> shirt: I'd be inclined to use Data.Maybe.maybeToList, for the same reason that I'd use map instead of fmap, which is that it reduces the knowledge required to read the code; but if you're already using toList somewhere else, perhaps that isn't a benefit.
22:15:35 <liste> is it for storage? debugging? network transfers?
22:15:38 <julianleviston> liste: say I have a tiny program that takes input from the keyboard, and when I press enter it adds each string into a list… then when I blank line, it saves the data into a file, which next time I run the program it loads and...
22:15:53 <julianleviston> liste:  so on :)
22:16:00 <Hafydd> In another sense, maybeToList might make it more readable because it reminds the reader what the involved types are; and it's less likely to clash with something else of the same name.
22:16:17 <julianleviston> liste: but what I actually want to do with it is store it in a DB (whatever the data type is).
22:16:18 <Hafydd> But, on the other hand, the generality of toList is pleasing.
22:16:23 <liste> julianleviston how about cereal or binary?'
22:16:33 <liste> they're efficient to store
22:16:49 <julianleviston> liste: but not human readable.
22:17:14 <julianleviston> liste: I’m going to be changing the shape of the data over time with the code, so also writing some mini-translators…
22:17:18 <shirt> Hafydd: so no clear answer? :(
22:17:23 <julianleviston> liste: I’m not 100% sure I need human readability.
22:17:32 <julianleviston> liste: but I think initially it would definitely help.
22:18:01 <Hafydd> shirt: it isn't the kind of question that has a clear answer, I think.
22:18:01 <julianleviston> liste: and I will need to transfer it through HTTP
22:18:17 <Hafydd> shirt: but my personal opinion is in favour of maybeToList (3 points vs 1).
22:18:19 <nshepperd> show/read is human readable
22:18:34 <nshepperd> the only problem there should be that it gets slow on really big structures
22:18:50 <julianleviston> nshepperd: how big is big there?
22:19:18 <liste> @hackage safecopy -- check this out also for (limited) schema changes
22:19:18 <lambdabot> http://hackage.haskell.org/package/safecopy -- check this out also for (limited) schema changes
22:19:41 <nshepperd> thousands of nodes? not quite sure
22:20:18 <nshepperd> if you need more speed json could be the thing to use
22:20:19 <hunteriam> can anyone comment on the readability of this program i wrote?
22:20:31 <shirt> Hafydd: ok thanks
22:20:41 <hunteriam> https://www.irccloud.com/pastebin/nL6aBkAn/thing
22:20:52 <hunteriam> Any comments are welcome
22:20:53 <julianleviston> nshepperd: ah ok… that seems odd.
22:20:55 <nshepperd> you can just keep defining FromJSON/ToJSON instances until the thing compiles
22:20:56 <hunteriam> even if you dont go through the whole thing
22:21:22 <julianleviston> nshepperd: so parsing it from/to a totally different intermediate format is faster than something else more native? hm
22:22:09 <nshepperd> Read has some sort of backtracking
22:22:13 <nshepperd> iirc
22:22:33 <julianleviston> nshepperd: yeah, but surely there’s a non-JSON way to turn haskell data into text?
22:22:51 <julianleviston> nshepperd: maybe not! :)
22:22:52 <julianleviston> hehe
22:22:55 <nshepperd> while the json grammar should be unambiguous enough to parse efficiently
22:23:08 <julianleviston> nshepperd: yeah, fair enough. :) ok.
22:23:23 <julianleviston> nshepperd: I’ll stick with it. :) sorry for the bother.
22:23:56 <julianleviston> hunteriam: it’s very pretty.
22:24:01 <hunteriam> :D
22:24:06 <hunteriam> you dont hate it?
22:24:33 <julianleviston> hunteriam: even if it doesn’t favour the usual haskell concision … personally I find the concision a bit opaque.
22:24:38 <nshepperd> I would use json anyway, because it's standardized and therefore easy to pretty-print. much more human readable that a Show of a huge structure
22:24:47 <hunteriam> Which bits are out of line, if i may?
22:24:55 <hunteriam> I mean ultimately if its readable then im happy
22:25:23 <julianleviston> hunteriam: line 43.
22:25:36 <julianleviston> nshepperd: fair enough.
22:25:51 <julianleviston> hunteriam: what is stringsToMap? 
22:26:04 <hunteriam> its later on in the document
22:26:15 <hunteriam> it converts a [Text] -> Map Composition Text
22:26:16 <julianleviston> hunteriam: oh sorry - my repeat-find didn’t work … 
22:26:20 <hunteriam> np
22:26:50 <hunteriam> whats unconventional about 43 btw?
22:27:16 <julianleviston> hunteriam: tabs
22:27:22 <hunteriam> oh lol
22:27:33 <julianleviston> hunteriam: I don’t know if it’s unconventional. it’s just not ligned up.
22:27:51 <hunteriam> yea weird cause its ilned up in my editor
22:27:57 <julianleviston> hunteriam: but that’s not what concision means
22:28:02 <liste> hunteriam you have 8 space tab stops?
22:28:06 <julianleviston> LOL
22:28:12 <hunteriam> indeed
22:28:14 <hunteriam> :)
22:28:15 <julianleviston> wow
22:28:19 <hunteriam> its the default for vim
22:28:34 <liste> line 43 looks goofy with 4 space tab stops
22:29:09 <hunteriam> fixed
22:29:33 <julianleviston> hunteriam: what does stringsToMap mean?
22:29:46 <hunteriam> it takes a list of Texts
22:29:51 <julianleviston> hunteriam: it sounds like a noun.
22:30:03 <julianleviston> hunteriam: but it’s a function.
22:30:04 <hunteriam> hm, alternatives?
22:30:34 <hunteriam> the idea was "strings -> map"
22:30:34 <julianleviston> hunteriam: what does it do? takes a list of Text and maps composition across them?
22:30:43 <julianleviston> hunteriam: ohhhh
22:30:50 <julianleviston> now I get it
22:30:59 <hunteriam> :D
22:31:21 <julianleviston> the confusing word “map”. :)
22:31:24 <julianleviston> in FP.
22:32:25 <julianleviston> hunteriam: makeMapFromStrings is a bit of a mouthful
22:33:03 <davidar> julianleviston (IRC): map vs Map ;)
22:33:06 <julianleviston> hunteriam: I think your code is fine.
22:33:27 <julianleviston> davidar: a bit value when it’s a camelcased function name huh :)
22:33:50 <julianleviston> davidar: what does stringifyThenMap mean? ;-)
22:34:03 <julianleviston> davidar: for example
22:34:16 <davidar> Yeah, it makes googling hard sometimes
22:34:32 <davidar> Don't ask me ;)
22:34:37 <julianleviston> hunteriam: tho, if you renamed your functions to be more FP, it might make more semantic sense… 
22:34:45 <hunteriam> what would be more fp?
22:35:11 <davidar> hunteriam (IRC): FiniteFunction?
22:35:29 <julianleviston> davidar: ooh what’s that? :)
22:35:33 <hunteriam> ^
22:35:45 <julianleviston> hunteriam:  I mean, “getPath” is very actiony, right?
22:35:56 <julianleviston> hunteriam: “pathFromNode” is more nouny.
22:35:58 <davidar> A more fp name for Map ^
22:36:09 <hunteriam> i dont understnad that name davidar
22:36:10 <julianleviston> declarative versus imperative.
22:36:14 <hunteriam> oh i understand it now
22:36:19 <julianleviston> hunteriam:  but it’s up to you. it’s probably just fine.
22:36:28 <hunteriam> nodesToPath?
22:37:03 <julianleviston> hunteriam: oh I’m an idiot. What does that function do...
22:37:12 <julianleviston> hunteriam: takes a node, and a vector node, and gives you a path list
22:37:15 <julianleviston> a node list
22:37:36 <hunteriam> yep
22:37:51 <julianleviston> hunteriam: this is a minor quibble… and it depends on the style YOU want to have. not me.
22:38:09 <julianleviston> hunteriam: but you should be consistent.
22:38:11 <hunteriam> im just afraid this things going to be totally opaque to my teacher
22:38:36 <julianleviston> hunteriam: compToNodeMap is in one mode, getPath is in another.
22:39:10 <hunteriam> well, conversion vs not conversion
22:39:17 <hunteriam> compToNodeMap converts bettween Maps
22:39:29 <julianleviston> hunteriam: I’m just talking about the naming convention you’ve chosen.
22:39:41 <julianleviston> hunteriam: so convertCompToNodeMap
22:39:51 <julianleviston> but things get big, hm.
22:40:08 <julianleviston> the price you pay for putting a verb at the front of everything, stylistically.
22:40:21 <julianleviston> hunteriam: like I said, tho, this is your stylistic choice, so I really can’t comment too much.
22:40:39 <hunteriam> ah i understand now
22:40:59 <julianleviston> hunteriam: from the perspective of someone trying to understand your code, though, it was tricky to understand “stringsToMap” after I’d seen “findNeighbors”
22:41:08 <liste> though a lot of Haskell code uses verbs in the front
22:41:16 <liste> runReader, getSum...
22:41:22 <julianleviston> my brain did a little gymnastics trying to find out the verb in “stringsToMap"
22:41:29 <julianleviston> liste: agreed.
22:42:00 <julianleviston> hunteriam: until i realised that there is no verb. It’s an elided “convert” :)
22:42:24 <julianleviston> hunteriam: and “longestPaths” has an elided “get”
22:43:05 <julianleviston> hunteriam: but that’s ok. It just means I have to spend an extra 5 or so minutes looking at it to work out what’s going on.
22:43:27 <julianleviston> hunteriam: and no doubt someone who’s better at grokking type signatures will be fine with it
23:10:50 <Lokathor> what's with haskell people and "elide"?
23:13:04 <julianleviston> Lokathor: mean?
23:13:48 <julianleviston> Lokathor: *cough* I meant to say “what do you mean?”
23:13:56 <gfixler> elide :: a -> [a] -> [a]
23:14:24 <Lokathor> huh
23:16:10 <kazagistar> Lokathor: first I heard elide was in a C++ context, and I don't even C++
23:16:27 <wagle> is the haskell platform still the way to go?
23:17:00 <Lokathor> wagle, consider using stack perhaps. Though i'm told that haskell platform is less bad with the latest release because it includes a full msys if needed
23:17:35 <wagle> yeah, wondered if things like stack were ready for "prime time"
23:18:07 <Lokathor> unless you're doing production work this second, best way to find out is to give it a whirl
23:18:36 <Lokathor> my biggest complaint is that it doesn't have a simple version of "cabal run", which auto-rebuilds if necessary
23:19:04 <Lokathor> "stack exec" will run a program, but won't auto-rebuild if the source files have changed. maybe they've fixed that in the past month though
23:19:11 <wagle> gave it a whirl a couple months ago, seemed to make a mess that I am just now cleaning up with a fresh install of everything (cruft! everywhere!)
23:19:39 <Lokathor> stack seems to move rather quick. I gave them a bug report once and they had a fix into the repo within 2 days
23:19:52 <Lokathor> it was a small bug, but still
23:19:57 <wagle> cool
23:21:43 <julianleviston> Lokathor: is that fast?
23:21:53 <julianleviston> Lokathor: I guess so.
23:22:07 <nitrix> Lokathor: I had the same complain about `stack ghci` and there's ongoing discussion/work to improve the situation.
23:22:16 <nitrix> About fetching dependencies and reloading modules properly.
23:22:19 <julianleviston> niteria: what’s wrong with stack ghci?
23:22:23 <julianleviston> ah
23:22:58 <nitrix> It's the second time someone refers to me as niteria here >:(
23:23:12 <nitrix> Is this a hint for gender change?
23:23:40 <ibid> probably just nick a completion mistake
23:23:52 <ibid> just a nick ...
23:25:07 <julianleviston> nitrix: soz
23:28:42 <wagle> oh bummerz: haskell platform tries to Executables are symlinked in /usr/bin and should be available in any shell.
23:29:15 <wagle> el capitan doesnt let you modify /usr/bin
23:30:18 <julianleviston> wagle: wow you’re quick off the mark.
23:31:00 <wagle> yeah, i ran out of disk, so I though I'd do a fresh install
23:31:13 <wagle> get rid of 8 years of cruft
23:32:42 <glguy_> If you install the relocatable GHC for os x note that the version of cabal install packaged with it doesn't work with 10.11 as of r2
23:33:35 <glguy_> But if you've compiled your own recently before updating it will
23:33:38 <wagle> all the symlinks in /usr/bin failed
23:33:58 <wagle> so no ghci, ghc, or cabal, etc
23:34:13 <wagle> googling for the best workaround
23:44:36 <wagle> workaround i made up is to build a bin directory of symlinks to the haskell-platform binaries
23:44:45 <xpilot> > :k (':)
23:44:46 <lambdabot>  <hint>:1:1: parse error on input ‘:’
23:45:29 <xpilot> I want to partially apply list cons (:) a the type level
23:45:32 <xpilot> is this possible?
23:45:51 <xpilot> :k (Int ': '[])
23:45:52 <lambdabot> [*]
23:46:17 <xpilot> :k (Int ':)
23:46:18 <lambdabot> parse error on input ‘)’
23:46:34 <gfixler> at the type level?
23:46:41 <xpilot> yes
23:46:45 <gfixler> explain, please
23:47:02 <xpilot> as would be standard with -XDataKinds
23:47:17 <xpilot> I suspect the issue is that lists are built in
23:47:27 <xpilot> and there is something nonstandard going on
23:48:35 <xpilot> it would be fine if I defined my own list type
23:49:25 <xpilot> but I'd like to use the built in list type, since it supports nicer type-level literals and so I can interop with Data.Vinyl and other libraries
23:57:12 <wagle> .. seems to work
