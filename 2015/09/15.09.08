00:03:29 * hackagebot structs 0 - Strict GC'd imperative object-oriented programming with cheap pointers.  https://hackage.haskell.org/package/structs-0 (EdwardKmett)
00:03:31 * hackagebot quickcheck-text 0.1.0.1 - Alternative arbitrary instance for Text  https://hackage.haskell.org/package/quickcheck-text-0.1.0.1 (fractalcat)
00:05:18 <edwardk> ack, 121
00:05:46 <bergmark> edwardk: there's also http://matrix.hackage.haskell.org/user/EdwardKmett
00:05:59 <julianleviston> edwardk: does it weigh heavy on your mind?
00:06:14 <edwardk> julianleviston: the number of packages or the maintenance factor?
00:06:31 <julianleviston> edwardk: yes.
00:07:02 <edwardk> julianleviston: neither so much. maintenance isn't so bad if you do a little bit at a time.
00:07:17 <edwardk> Haskell is a lot easier to do this with than any other language I've ever worked in.
00:07:47 <edwardk> It is easier for me to page in how to work with some obscure library I wrote 3 years ago than it ever was for me to even remember the syntax of some of the languages I worked in before. ;)
00:07:55 <julianleviston> edwardk: Having the proper abstraction levels for things helps a lot, doesn’t it :)
00:08:01 <edwardk> indeed
00:08:38 <nocturne777> would you guys recommend Purescript over GHCJS and Haste for front-end programming? 
00:08:48 <julianleviston> nocturne777: no.
00:08:58 <KaneTW> try it out
00:09:20 <KaneTW> purescript is more lightweight, ghcjs is more powerful
00:09:25 <KaneTW> iirc, anyways
00:09:51 <julianleviston> nocturne777: if you’re a beginner, I’d recommend trying out Elm, or at least reading the Elm architecture guide. It’ll solidify a lot of things for you.
00:09:59 <nocturne777> what I like about purescript is that it says its semantics are closer to javascript rather than ghc
00:10:26 <julianleviston> nocturne777: if you like it, you should definitely use it!
00:10:33 <MasseR> I'm a bit of a heretic, but check out js_of_ocaml
00:10:55 <MasseR> http://ocsigen.org/js_of_ocaml/
00:11:07 <nocturne777> julianleviston: I have not tried it out properly yet
00:13:03 <julianleviston> nocturne777: could I ask what you’re hoping to get from asking?
00:13:44 <julianleviston> nocturne777: in other words, are you after recommendations for your next serious project, or just wanting to know what to play with next? :)
00:14:27 <julianleviston> nocturne777: Haskell has a rather nice thing in “Reflex”, but I’m not sure if you’re aware of it… https://github.com/ryantrinkle/try-reflex
00:16:36 <julianleviston> nocturne777: and also, I’m not sure which paradigm you’re interested in… and this largely relates to my previous question… because if you’re building a large system, you want a kind of FRP thing most likely (the flow of data is an incredibly difficult thing to manage using “standard” programming methodologies in the browser - ie callbacks)… but if you’re not, then you can probably get by with, well, pre
00:16:36 <julianleviston> much anything, more or less… 
00:16:56 <nocturne777> julianleviston: I use Haskell in the back-end. I'd also prefer to use Haskell in the front-end as well. But I got these questions in my mind: are the semantics of GHC suitable for front-end? Would future front-end hires want to work with some language similiar to Haskell?
00:17:51 <julianleviston> nocturne777: that seems a little conflicted to me. hires == popular, ergo not haskell.
00:18:10 <julianleviston> nocturne777: depending on if you want *good* hires, or *many* hires.
00:18:34 <nocturne777> good hires, of course :)
00:18:40 <julianleviston> Then it’s moot.
00:18:57 <julianleviston> good == polyglot, or capable.
00:19:23 <julianleviston> “of course” ;-) I love it. “Hey, all our programmers are 80% better than average… what?”
00:19:52 <xylen> elm is a neat little "web" language that uses Haskell. I still want to try it eventually.
00:20:53 <nocturne777> julianleviston: have you worked on a front-end application using GHCJS with FRP ?
00:21:01 <julianleviston> nocturne777: nope.
00:21:14 <julianleviston> nocturne777: I should have lead with that. Apologies!
00:21:17 <julianleviston> led*
00:21:43 <julianleviston> nocturne777: I’m just about to rebuild my clojurescript front end FRP system in Haskell using GHCJS tho.
00:22:29 <nocturne777> julianleviston: it quite OK, I am just curious to hear others' take on this
00:23:23 <julianleviston> nocturne777: no worries. I’ll be quiet :)
00:28:30 * hackagebot rcu 0 - STM-based Read-Copy-Update  https://hackage.haskell.org/package/rcu-0 (EdwardKmett)
00:28:34 <edwardk> 122
00:29:41 <julianleviston> edwardk: hackagebot should also announce the count hm? :)
00:29:47 <edwardk> hah
00:29:57 <edwardk> i mostly mentioned it for the continuation of the earlier joke =)
00:30:11 <julianleviston> edwardk: yeah, I know :) 
00:30:34 <julianleviston> edwardk: it should also announce “winning” for the max count
00:30:38 <julianleviston> edwardk: ;-)
00:30:42 <edwardk> hah
00:31:03 <edwardk> then i think i lose to snoyman
00:31:12 <julianleviston> yeah prolly
00:32:38 <julianleviston> edwardk: how many lens libs do you have now?
00:32:54 <edwardk> just lens. i gave data-lens to roconnor years ago
00:33:06 <julianleviston> ah
00:33:53 <glguy> You aren't counting things like zippers, lens-aeson?
00:36:45 <edwardk> thought about clarifying, decided not to =)
00:38:47 <julianleviston> Hey is there anything like Apache Samza or Storm but *inside* Haskell? Would that just basically be Distributed-Process, with something like Pipes or Quiver?
00:39:05 <julianleviston> am I on the right track here?
00:40:42 <hc> hey everyone, just wanted to say thank you for the absolutely awesome sauce stack infrastructure! :-)
00:52:23 <lpaste_> yrlnry pasted “What is "rigid type variable"?” at http://lpaste.net/140469
00:53:04 <frerich> Hm, that reminds me, I ran 'stack init && stack build' in a few Cabal-based packages. The installation went fine and the package is registered at the end. However, I cannot seem to import the built module with either 'ghci' or 'stack ghci' (I thought the latter was akin to 'cabal repl'). Is there some search path which needs adjusting?
00:53:32 <yrlnry> I have code where I thought the unification algorithm would conclude that two types are equal.  But instead I get an error I don't understand.  But when I adjust the type signature manually to express the equality, the code compiles.
00:54:24 <tdammers> yrlnry: paste some code? there are cases where you need to manually disambiguate even though it seems like there is only one possible solution
00:54:32 <yrlnry> http://lpaste.net/140469
00:54:35 <julianleviston> tdammers:  I think he just did.
00:54:46 <tdammers> right, missed that, sorry
00:54:49 <yrlnry> np
00:55:19 <Saizan> yrlnry: the 'o' variable is universally quantified at the front, it's not an unification variable
00:55:28 <tdammers> ^ this
00:55:49 <tdammers> what you wrote says "this works for any possible i combined with any possible o"
00:56:12 <tdammers> GHC complains because your type signature says they can be different, but your actual code needs them to be the same
00:56:50 <yrlnry> Is type a also implicitly universally-quantified?
00:57:04 <Saizan> yep
00:57:12 <tdammers> yes, but that one isn't problematic here
00:59:00 <yrlnry> Oh, it's as if I wrote foo (a, b) = [a, b]  and tried to claim foo :: (a, b) -> [a]
01:00:20 <tdammers> yes
01:01:18 <yrlnry> Are there any ways to express what I mean other than explicitly replacing o with i to express that they must be the same?
01:03:07 <tdammers> you could use ~ to constrain things, but that's kind of overkill in this situation
01:03:12 <tdammers> https://wiki.haskell.org/Keywords#.7E
01:03:31 * hackagebot travis 0.1.0.1 - A simple client implementation using Travis CI API.  https://hackage.haskell.org/package/travis-0.1.0.1 (tomtau)
01:03:40 <tdammers> https://wiki.haskell.org/Type_families#Equality_constraints
01:04:23 <tdammers> in this case, I'd go with just using the same type var for both
01:04:39 <shachaf> Is what you mean that they are equal?
01:04:40 <tdammers> easier on the eyes, and expresses more clearly what you intend
01:04:54 <shachaf> If so, the type should show that.
01:05:11 <shachaf> Maybe you want :: i ~ o => ...i...o...
01:05:21 <shachaf> Which is the same as writing :: ...i...i...
01:05:51 <yrlnry> Replacing o with i is fine.  I just wanted to know more.
01:06:14 <yrlnry> Thanks, you've all been very helpful.
01:06:27 <shachaf> Well, i ~ o => ... is an equality constraint. It does the same thing here.
01:09:11 <shachaf> I guess, in GHC terminology, (a ~ b) is the constraint. What is (a ~ b *> (a,b))?
01:14:50 <Axman6> shachaf: what's *>?
01:14:58 <shachaf> The dual of =>
01:15:07 <shachaf> Not real syntax.
01:15:35 <Axman6> I'm not sure what the dual of => means
01:16:48 <shachaf> If I give you (A => B), it means, it's your job to show that A, and then I'll give you a B.
01:17:01 <shachaf> If I give you (A *> B), it means, it's my job to show that A, and then I'll give you a B.
01:17:41 <Axman6> so, you need to provide a proof of A?
01:17:57 <shachaf> Sure.
01:18:08 <shachaf> It often goes together with exists, though not always.
01:18:30 <shachaf> (exists a. Show a *> a) -- I'm giving you a value of some type, which is an instance of Show.
01:19:31 <shachaf> (exists a. Show a => a), which people sometimes write, doesn't make much sense.
01:20:17 <shachaf> It means, I'm choosing some type a, and not telling you which type it is. Now you have to show me that a is an intstance of Show. Only then will I give you a value of type a.
01:20:22 <Axman6> hmm, yeah I think this is beyond my type theory knowledge at the end of a long day
01:20:49 <Axman6> right, ok. how would you show that a is an instance of show?
01:20:52 <Axman6> S*
01:23:32 * hackagebot clash-vhdl 0.5.10 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.5.10 (ChristiaanBaaij)
01:23:34 * hackagebot clash-ghc 0.5.13 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.5.13 (ChristiaanBaaij)
01:23:36 * hackagebot xdot 0.2.4.8 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  https://hackage.haskell.org/package/xdot-0.2.4.8 (DennisFelsing)
01:23:54 <shachaf> Well, generally GHC does it automatically for you.
01:24:23 <shachaf> YOu can imagine implementing (Show a) with (to a first approximation) a function :: a -> String
01:24:48 <shachaf> => is like ->, *> is like (,)
01:25:33 <shachaf> So if I give you (exists a. (a -> String, a)), that makes sense. I give you a value of some unknown type a, and a function :: a -> String.
01:25:56 <Axman6> right, similar to how stream fusion is implemented?
01:26:32 <Axman6> hmm, it uses forall though
01:26:35 <Geraldus> lambdabot: help
01:26:45 <shachaf> I don't know.
01:27:14 <shachaf> If you're talking about https://hackage.haskell.org/package/stream-fusion-0.1.2.5/docs/src/Data-Stream.html#Stream , yes, that's an example of an existential type with a "coconstraint".
01:27:55 <shachaf> Interesting, this is like a Nu type. Makes sense.
01:28:32 * hackagebot peyotls-codec 0.0.0.1 - Codec parts of Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-codec-0.0.0.1 (YoshikuniJujo)
01:33:32 * hackagebot peyotls-codec 0.0.0.2 - Codec parts of Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-codec-0.0.0.2 (YoshikuniJujo)
01:33:34 * hackagebot x509-validation 1.6.2 - X.509 Certificate and CRL validation  https://hackage.haskell.org/package/x509-validation-1.6.2 (VincentHanquez)
01:33:36 * hackagebot peyotls 0.1.6.6 - Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-0.1.6.6 (YoshikuniJujo)
01:37:28 <yrlnry> Oh, if I had left out the type annotation for runStateWriter and then asked GHC what type it had elaborated, it would have unified i and o and told me they had to be equal.
02:08:34 * hackagebot peyotls-codec 0.1.0.0 - Codec parts of Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-codec-0.1.0.0 (YoshikuniJujo)
02:18:34 * hackagebot peyotls 0.1.6.7 - Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-0.1.6.7 (YoshikuniJujo)
02:53:36 * hackagebot SourceGraph 0.7.0.7 - Static code analysis using graph-theoretic techniques.  https://hackage.haskell.org/package/SourceGraph-0.7.0.7 (IvanMiljenovic)
03:03:36 * hackagebot binary-tagged 0.1.0.0 - Tagged binary serialisation.  https://hackage.haskell.org/package/binary-tagged-0.1.0.0 (phadej)
03:18:37 * hackagebot test-sandbox-hunit 0.1.2 - HUnit convenience functions for use with test-sandbox  https://hackage.haskell.org/package/test-sandbox-hunit-0.1.2 (junjihashimoto)
03:37:32 <tr_istan> Question about monadic computations (hope the pasted code is readable)
03:37:35 <tr_istan> import qualified Hasql as H import qualified Hasql.Backend as B import qualified Hasql.Postgres as P main = do     ...     ...     -- columns :: String -> H.Tx P.Postgres s [Column]     let tbls = ["tbl1","tbl1"]      -- this works     colsRes <-  H.session pool $ H.tx txParam $ columns $ head tbls     let colsForOneTable = either (fail . show) id colsRes      -- how can i construct a cols list that contains the cols for all tables
03:37:50 <tr_istan> no ..., il try line by line
03:37:50 <Intolerable> lpaste it
03:37:58 <Intolerable> don't paste things into the channel
03:38:24 <tr_istan> sorry, how can i show a few lines of code here
03:38:40 <Intolerable> @where lpaste
03:38:40 <lambdabot> http://lpaste.net/
03:39:30 <tr_istan> thanks, here is the link http://lpaste.net/140471
03:41:11 <Intolerable> H.session pool $ H.tx txParam $ traverse columns tbls
03:41:18 <Intolerable> will probably do what you want
03:41:30 <Intolerable> you need to map columns over the tables
03:41:31 <tr_istan> thank you, i' try that
03:41:34 <Intolerable> :t traverse
03:41:35 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:41:37 <Intolerable> :t mapM
03:41:39 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
03:45:28 <tr_istan> @Intolerable traverse compiles, thank you
03:45:28 <lambdabot> Unknown command, try @list
04:06:07 <Sindriav_> Can I make a data type that's parametrised over an arbitrary number of params?
04:06:59 <saulzar> Sindriav_, You can make a data type parameterised by a list of types ..
04:07:19 <Sindriav_> saulzar: That works. Where can I read more?
04:08:39 <int-index> Sindriav_: official GHC documentation, the bit about DataKinds
04:08:39 * hackagebot shivers-cfg 0.1.1 - Implementation of Shivers' Control-Flow Analysis  https://hackage.haskell.org/package/shivers-cfg-0.1.1 (JoachimBreitner)
04:08:49 <Sindriav_> int-index: Thanks ^^
04:09:03 <saulzar> type-list or singletons package would be good to check out, maybe hvect library
04:10:08 <int-index> Sindriav_: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html
04:10:30 <Sindriav_> int-index: Reading through it already, thanks ^^
04:12:04 <Sindriav_> I'm not sure it's going to help, though… Hm…
04:12:11 <chpatrick> what are you trying to do?
04:12:28 <Sindriav_> What I'm trying to do is a heterogenous map, that can retrieve the values in a type-safe manner
04:12:50 <Sindriav_> What more, a heterogenous TypeMap
04:13:03 <chpatrick> hmm but then you statically need to know the elements right?
04:13:12 <chpatrick> why not a record?
04:13:12 <Sindriav_> I don't think so
04:13:16 <Sindriav_> Record?
04:13:23 <Sindriav_> That's not dynamic
04:13:28 <chpatrick> why not?
04:13:36 <chpatrick> I mean it's fixed-size
04:13:41 <Sindriav_> Exactly.
04:14:09 <chpatrick> well you could do it
04:14:18 <int-index> Sindriav_: check out the `vinyl` library
04:14:19 <Sindriav_> I want a Map, which can at runtime store and retrieve arbitrary types
04:14:20 <chpatrick> but I can't really think of a use case
04:14:29 <chpatrick> what int-index said
04:14:38 <Sindriav_> int-index: I'll look into it.
04:14:49 <int-index> and it uses type-level lists, by the way.
04:15:22 <chpatrick> all this type level stuff usually ends up very heavy imo
04:16:00 <chpatrick> not usually worth the power to weight ratio
04:16:15 <Sindriav_> I'm not sure Vinyl does what I want. It's cool though.
04:16:20 <chpatrick> why not?
04:16:25 <int-index> Sindriav_: then maybe `dependent-map`
04:17:00 <Sindriav_> int-index: That looks more promising :)
04:17:20 <Sindriav_> chpatrick: Because… I want something else? What do you want to hear?
04:17:55 <int-index> chpatrick: I don't mind the heavy type-level stuff. Recently I wrote a type-safe EDSL using vinyl+singletons, and it turned out just fine.
04:18:36 <chpatrick> I just mean that type safety is meant to save you time in the end by preventing bugs
04:18:39 * hackagebot syntactic 1.16 - Generic abstract syntax, and utilities for embedded languages  https://hackage.haskell.org/package/syntactic-1.16 (AndersPersson)
04:18:59 <chpatrick> but if it costs more time than it saves preventing bugs then it's not worth it, productivity-wise
04:19:10 <chpatrick> not to say it's not elegant or desirable
04:19:54 <Sindriav_> Actually, I could use vinyl to build the world-type
04:20:01 <Sindriav_> Hm…
04:21:05 <Sindriav_> Basically, I want to have a World, which associates Entities with Components, where Entity is a newtype for Word and Component is any datatype
04:21:23 <Sindriav_> I then want to retrieve said datatype for the Entity.
04:21:36 <Sindriav_> If only I could treat types as values, this would all go away IMO
04:21:50 <DEA7TH> Suppose I have an application in which at least 2 different events might happen. Both need to read, and change, some global state. What is the conventional way to implement this? 
04:22:10 <Sindriav_> e `get` Type :: Entity -> ??? -> StateT World ???
04:22:29 <Sindriav_> DEA7TH: What kind of events?
04:22:51 <DEA7TH> Sindriav_: like button presses or similar. It's for a mobile application. I'm actually using Swift, but I want clean code anyway.
04:22:56 <Sindriav_> DEA7TH: Are they synchronous? Asynchronous?
04:23:01 <Sindriav_> Oh
04:23:03 <int-index> Sindriav_: you can treat types as values, read this paper http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf - the relevant library is `singletons`
04:23:06 <DEA7TH> so I'm OK with solutions which only work in Haskell, not Swift.
04:23:35 <Sindriav_> DEA7TH: If you're using Swift, do it the Swift way. As for Haskell, there are safe threadable containers
04:23:48 <Sindriav_> int-index: Huh. I'll look into it!
04:24:12 <DEA7TH> Sindriav_: what is the term for them so that I can look them up?
04:24:47 <Sindriav_> int-index: What I really want is " e <- createEntity `with` MkColor 0 0 0 " and then " e `get` Color " for " data Color = MkColor Int Int Int "
04:25:01 <Sindriav_> DEA7TH: Look into FRP, that might suit that use-case better.
04:25:11 <chpatrick> I still think with this approach you'll need to know the size of your world at compile time
04:25:40 <chpatrick> I mean the compiler needs to know at some point if some entity is in your map
04:25:43 <int-index> Sindriav_: You're using `<-`, what is the monad?
04:25:50 <chpatrick> therefore you need to know all entities at compile time
04:25:51 <chpatrick> not very dynamic
04:26:26 <Sindriav_> chpatrick: I've hacked it together already with wrapper types, so it does work. I'm going to look for a solution, though you say it's impossible, but thanks anyways.
04:26:34 <Sindriav_> int-index: StateT World a
04:26:52 <Sindriav_> int-index: Basically, `createEntity` makes a new entity with an ID unique to the World it's in
04:26:59 <chpatrick> I mean how could the compiler check some runtime property:?
04:27:48 <chpatrick> I'm not trying to be a smartass, I just don't think it can work
04:28:11 <int-index> Sindriav_: can an entity change its type?
04:28:36 <Sindriav_> int-index: Nope. Entity is just a newtype for Word, so I can pass around the IDs in a type-safe manner
04:28:47 <saulzar> Sindriav_, Sounds almost like you want a DMap - i.e. the entity has a bunch of properties which can be different types..?
04:29:07 <int-index> Sindriav_: can a component change its type? (that's what I actually wanted to ask)
04:29:12 <Sindriav_> saulzar: Yeah, exactly. I'm looking at DMap right now :)
04:29:27 <Sindriav_> int-index: What do you mean?
04:29:41 <chpatrick> these things just give you anonymous record types basically
04:29:46 <chpatrick> but you still need to know what's in them statically
04:29:50 <int-index> If you created an entity, can the associated component change its type later?
04:29:51 <Sindriav_> int-index: e.g. what would "changing it's type" mean?
04:30:07 <int-index> apply a type-changing function
04:30:24 <Sindriav_> int-index: Oh! Hm… Not really, no.
04:31:04 <Sindriav_> I'll draft up a very rough pseudocode of what I want to do and paste it here, so it's more clear for everyone ^^
04:31:50 <Intolerable> we back onto the ECS stuff?
04:32:03 <int-index> then all entities and their types should be represented in `World`, so the easiest solution would be to name each entity by a type-level string and use a `vinyl` record
04:32:48 <Sindriav_> int-index: Yah
04:32:55 <Sindriav_> *Intolerable ^
04:33:24 <Sindriav_> int-index: Don't you mean "name each component" ?
04:33:41 <chpatrick> ekmett came up with this recently btw: https://youtu.be/I1FuZrDhOEk
04:33:44 <chpatrick> although it's kinda horrible
04:33:56 <int-index> I don't get the distinction between an entity and a component in your case, since an entity is just a number enumerating the component
04:35:30 <int-index> You also might need type-changing StateT (a parametrised monad) so you can add/remove components.
04:36:13 <int-index> because `StateT (World '[Int]) a` turns into `StateT (World '[Int, Bool]) a` after you create a new component of type `Bool`.
04:37:44 <Sindriav_> int-index: Entity has many components, component belongs to an Entity.
04:38:06 <Sindriav_> int-index: Entity is an integer, Component is an arbitrary data type
04:40:54 <saulzar> Sindriav_, Do you know all the types Component can be before you start?
04:41:11 <Sindriav_> saulzar: "before you start" means at compile time?
04:41:55 <Intolerable> that's how i would do it
04:42:22 <saulzar> Sindriav_, I mean is there a fixed set of types a Component can be ..
04:42:30 <Intolerable> my prototype just had a huge type with a bunch of Map EntityID x things in it
04:42:40 <Sindriav_> saulzar: Nope. I want this API to be extensible.
04:42:48 <saulzar> I see, right
04:43:29 <Intolerable> hm
04:43:29 <int-index> Sindriav_: do all components associated with a single entity have different types? 
04:43:34 <Sindriav_> Give me a minute, I'm writing up a long .lhs file that explains as accurately as possible what I'm trying to do
04:43:42 <Sindriav_> int-index: Yup
04:43:55 <Intolerable> you can always get around that limitation tbh
04:43:56 <Sindriav_> int-index: e.g. entity cannot have two components of the same type. Just newtype them if you want to have more
04:44:28 <Intolerable> i used MonadState at one point
04:44:43 <Intolerable> some of the things are super awkward
04:44:56 <Intolerable> my prototype has a slightly modified Map with an applicative instance
04:44:57 <saulzar> DMap k   lets a user chose a set of types (but it's also fixed for a type 'k')
04:45:13 <saulzar> You could take the Typeable approach and use Any..
04:45:43 <Sindriav_> saulzar: That's what I hacked together. I used Typeable and a wrapper type, but that's… ugly, to say the least.
04:45:50 <Intolerable> which allows for (,) <$> componentA <*> componentB to get every entity with both component A and B
04:46:10 <Sindriav_> Intolerable: That sounds neat
04:46:16 <Intolerable> its awful
04:46:47 <Intolerable> it works up until the point that you want to get all entities with component A and then Maybe for component B
04:47:14 <int-index> Sindriav_: Looks like you want a `vinyl` record for a custom type constructor that associates the universe of entities with component sets.
04:48:12 <int-index> So `type World es = Vinyl.Rec F es`, where `F` is a custom type constructor, and `es` is a type-level list of entities
04:48:57 <Sindriav_> int-index: Might be, yeah. I'll finish up the write-up
04:49:21 <int-index> You need to understand that you can't make this stuff type-safe within `StateT`.
04:49:55 <int-index> The entities you have and their components should be represented in the type of `World`, thus this type changes when you add/modify an entity.
04:50:03 <int-index> `StateT` does not let you change the state type.
04:50:48 <saulzar> int-index, Not quite sure I understand how you'd use vinyl .. because each of his 'Components' wouldn't all have the same set of fields
04:51:31 <int-index> saulzar: this is a separate matter, `vinyl` can be used to associate component sets with entities
04:51:43 <int-index> then you can use the `hset` package to represent component sets
04:54:33 <int-index> You'll have something like `Rec F '['(Entity1, '[Component1, Component2]), '(Entity2, '[Component3, Component4])]`, and `F` takes care about turning this into something inhabited.
04:55:21 <int-index> to make it extensible, just assume `EntityN :: *` and `ComponentN :: *`.
04:56:42 <DEA7TH> What's the point of functors anyway? I don't recall ever writing a function which takes a type in order to only do a fmap over it, without caring what type it is. When I fmap, I do it for type-specific reasons.
04:56:47 <saulzar> Ohhh
04:56:57 <Reite> Is it possible to write a SafeCopy instance for a Gadt where the return value is specialized like this?: http://lpaste.net/140474
04:57:13 <Sindriav_> DEA7TH: What?
04:57:16 <saulzar> DEA7TH, Quite often you might use it in conjunction with other properties..
04:57:18 <Reite> Im thinking its not since getCopy would have to wrong signature
04:57:46 <saulzar> DEA7TH, and, it's good to have one common name for it - otherwise every data type would have their own 'mapX' ..
04:57:48 <DEA7TH> Sindriav_: I'm assuming that classes only exist in order to abstract away the type, and only know the class.
04:58:10 <Sindriav_> int-index: That sounds reasonable. Really, just give me time to write it up. The discussion can't really go forward until we're on the same page on the requirements :)
04:58:16 <Sindriav_> e.g. what I want
04:58:34 <int-index> Have to go now, I hope you find a solution
04:59:05 <Sindriav_> int-index: okay, see you around ^^
04:59:28 <DEA7TH> saulzar: how might one use it with other properties? 
04:59:51 <DEA7TH> you mean if I take a type which implements multiple classes, one of which is a Functor?
04:59:57 <Sindriav_> DEA7TH: Glaring example is `class Functor f => Monad f`, no?
05:00:02 <saulzar> Yeah..
05:00:31 <Sindriav_> DEA7TH: Also, you might want to phrase you questions better. "What's the point of functors anyway?" is a really useless one.
05:01:42 <Sindriav_> DEA7TH: `double :: (Num a, Functor f) => f a -> f a` `double = fmap (*2)` is an example.
05:02:57 <DEA7TH> Makes sense.
05:03:27 <ski> DEA7TH : consider defining `data Tree f a = Leaf a | Branch (f (Tree f a))' and then e.g. `data TwoThree a = Two a a | Three a a a', then `Tree TwoThree a' is a type of trees branching by two or three
05:04:14 <ski> DEA7TH : if you want to be able to traverse a `Tree f a', then you'll probably need to assume `Functor f'
05:04:56 <ski> so you can use the same type `Tree', and the same generic code operating on it, swapping out different "branching types" `f', for different uses
05:06:21 <DEA7TH> or I could write code which only works for implementations where f is a functor. 
05:06:37 <DEA7TH> that might be still useful
05:07:38 <Sindriav_> Intolerable: If you're interested, I drafted up my idea of the API: http://lpaste.net/792165735169261568
05:07:49 <ski> that's what i meant, yes. e.g. `instance Functor f => Functor (Tree f) where fmap f (Leaf a) = Leaf (f a); fmap f (Branch ts) = Branch (fmap (fmap f) ts)'
05:08:51 <Intolerable> Sindriav_: is with defined somewhere?
05:09:03 <Sindriav_> Intolerable: Oh yeah, I'll add that, gimme a sec
05:09:25 <ski> DEA7TH : you can also make it `Traversable', ..
05:09:28 <Intolerable> > What more, the list of all entity IDs could be itself stored in World. That way, we have access to *all* entities at once.
05:09:30 <lambdabot>  <hint>:1:10: parse error on input ‘,’
05:09:37 <Intolerable> yeah, that's what i did
05:10:05 <Intolerable> i'll probably put my code on github at some point
05:10:13 <Intolerable> its old but it might give you some pointers
05:10:37 <elfeck> heyoh, can someone tell me how to make more complex SQL queries with persistent?
05:10:52 <saulzar> Sindriav_, Curious what you come up with! 
05:11:05 <bergmark> elfeck: preferably using esqueleto
05:11:11 <Sindriav_> Intolerable: There http://lpaste.net/792165735169261568
05:12:02 <Intolerable> i guess you aren't worrying at all about performance yet
05:12:13 <Intolerable> is it gonna be pure?
05:12:15 <Sindriav_> Yeah, that comes when it comes :D
05:12:17 <Intolerable> mine was in IO
05:12:29 <Intolerable> but i think that was a bad decision
05:12:40 <Sindriav_> Intolerable: It should be. I hacked together something that kinda worked and was pure
05:12:47 <Sindriav_> I'll paste it too
05:13:19 <Sindriav_> Intolerable: http://lpaste.net/2818339814305169408
05:13:30 <elfeck> bergmark: thanks! can you quickly think of a solution which checks if a [Text] in the DB contains all elements of a different [Text]?
05:13:44 <elfeck> not quite sure how to go about that
05:13:58 <Sindriav_> Intolerable: This should work, if I didn't make any dumb edits since the last time. It just returns the components wrapped in `Component`, but they should be unwrappable
05:14:21 <Intolerable> that looks less awful than i was expecting Typeable to be
05:14:47 <Intolerable> mine is very lens-y
05:15:13 <bergmark> elfeck: i forgot everything about persistent after opaleye came out
05:15:45 <Intolerable> i assume Typeable doesn't do anything weird with newtype?
05:16:05 <Sindriav_> Intolerable: What do you mean?
05:16:26 <Sindriav_> Intolerable: Oh, like if it doesn't return the same type for a wrapped value? It *shouldn't*, but I haven't tried
05:16:29 <Intolerable> when the newtype is erased, you still get a different newtype tag than the underlying thing
05:16:32 <Intolerable> yeah
05:16:49 <Sindriav_> I'm considering just using Clojure, to be honest
05:17:09 <Sindriav_> The macro system and quoting (and being dynamic) would work pretty good for this
05:17:20 <Intolerable> probably
05:17:20 <Sindriav_> Plus the live-coding stuff would be swell for game-development anyways
05:18:04 <Intolerable> yeah newtypes work fine w/ Typeable
05:18:17 <Sindriav_> Neat
05:21:45 <tdammers> fwiw, clojure has so far been pretty disappointing to me
05:23:48 <Sindriav_> It's largely regarded as being really well designed, but… It's pretty dense
05:24:05 <Sindriav_> It uses a lot of Java functionality, some functions are painfully missing (like `any?`)
05:24:23 <Sindriav_> But it's a JVM lisp, so that's pretty neat
05:24:31 <Sindriav_> live-coding on JVM is really nice
05:25:07 <saulzar> You need to stay on Haskell so I can use your library :)
05:25:14 <tdammers> idk, I don't quite understand the appeal
05:26:20 <Sindriav_> saulzar: Well, I'd backport to Haskell eventually, but I feel like Clojure might be a lot better for exploring the concept and getting it down right
05:26:38 <Sindriav_> saulzar: With that much hackery, it would be really hard to make changes in the future in Haskell
05:26:54 <Sindriav_> I've got it working in C++, but the code is such a mess x_x
05:30:56 <srhb> Does anyone know of a really good writeup on why laziness by default is the right choice, preferably with some focus on compositionality?
05:31:12 * srhb wants to sell the argument soon, and wants to do some more reading first
05:31:40 <chpatrick> I don't know if people are sure that it is :)
05:32:14 <chpatrick> you couldn't do stuff like forever without it though
05:32:29 <srhb> chpatrick: I'm pretty sure that such a writeup will be written by a person who is sure that it is, if such a writeup exists :P
05:32:36 <saulzar> I've been working on a small scene graph like thing with reflex  (using gloss, but just to test the concept). Would be interesting to see how it could work with a component type system at the base... 
05:33:07 <lieven> srhb: https://hackhands.com/modular-code-lazy-evaluation-haskell/
05:34:01 <srhb> lieven: Thanks!
05:36:34 <Sindriav_> saulzar: I'll look into vector and dependent-map, maybe that will lead me somewhere :)
05:41:03 <saulzar> Sindriav_, Maybe something simpler like a HSet of Maps or Vectors of different types
05:41:17 <Sindriav_> Maybe… hm…
05:41:35 <saulzar> Sindriav_, So you index the HSet by type and it gives you a collection (all the same type) which you index by key..
05:43:36 <saulzar> I am guessing Components might want to be shared between Entities
05:43:43 * hackagebot GHood 0.0.5 - A graphical viewer for Hood  https://hackage.haskell.org/package/GHood-0.0.5 (JanisVoigtlaender)
05:44:27 <Sindriav_> saulzar: Shared?
05:45:08 <saulzar> i.e. two entities reference the same thing (e.g. they have the same bitmap for a texture or something)
05:45:39 <saulzar> Probably not a good example, because you'd separate rendering out - but something like that
05:45:51 <Intolerable> don't suppose there are <$$> and <**> lying around anywhere?
05:46:01 <frerich> srhb: http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf has a few examples which verym uch rely on non-strictness, and the paper concludes with a strong argument in favour of lazieness being the default
05:46:18 <srhb> frerich: Thank you!
05:46:19 <saulzar> Intolerable, I don't think so... I quite often define them too
05:46:38 <Intolerable> <$$> :: (Functor f, Functor g) => (a -> b) -> g (f a) -> g (f b)
05:46:42 <Intolerable> that what you're using?
05:46:47 <saulzar> Yup
05:46:54 <Intolerable> unfortunate
05:47:17 <frerich> srhb: Also, http://pchiusano.blogspot.de/2011/12/future-of-programming.html is a very strong proponent of laziness being the default (and 'optional laziness doesn't quite cut it'): http://pchiusano.blogspot.de/2009/05/optional-laziness-doesnt-quite-cut-it.html
05:47:24 <Intolerable> disappointing that it isn't in Data.Functor.Compse
05:47:27 <Intolerable> *compose
05:47:58 <Lutin`> Intolerable, http://hackage.haskell.org/package/composition-extra-1.2.0/docs/Data-Functor-Syntax.html
05:48:36 <saulzar> Wow.. (<.**$$$$>)
05:48:43 * hackagebot GHood 0.0.6 - A graphical viewer for Hood  https://hackage.haskell.org/package/GHood-0.0.6 (JanisVoigtlaender)
05:49:01 <Intolerable> god knows i'm always using <~~$$$$>
05:49:07 <Lutin`> lol
05:53:35 <Sindriav_> wtf :D
05:54:14 <Intolerable> you've got me working on this silly ECS access thing again now
05:54:44 <Intolerable> i want to be able to do stuff like
05:55:49 <Intolerable> (,,) <$> entityID <*> collision <*> perhaps sprite :: [(EntityID, CollisionData, Maybe SpriteData)]
06:00:53 <xandaros> Is there some easy way to bind two monadic values to a function? I have an `m a` and a `m b`, as well a a function `a -> b -> m c`. Currently I do `join (f <$> a <*> b)`, but that looks rather ugly to me
06:01:31 <pacak> :t liftM2
06:01:33 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:01:43 <indiagreen> not it
06:01:44 <Intolerable> :t \f a b -> f <*> a <*> b
06:01:45 <lambdabot> Applicative f => f (a1 -> a -> b) -> f a1 -> f a -> f b
06:01:56 <Intolerable> (that's not right either)
06:02:09 <Intolerable> :t \f a b -> join (f <$> a <*> b)
06:02:11 <lambdabot> Monad m => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
06:02:38 <pacak> Right, function is monadic as well.
06:03:44 <Intolerable> :t \f -> sequence (f :: a -> Maybe b)
06:03:45 <lambdabot>     Couldn't match expected type ‘a2 -> Maybe b’ with actual type ‘r’
06:03:46 <lambdabot>       because type variables ‘a2’, ‘b’ would escape their scope
06:03:46 <lambdabot>     These (rigid, skolem) type variables are bound by
06:05:07 <xandaros> I've been wondering about this for a while, just never asked. Looks like this is a less common problem than I thought
06:05:13 <Intolerable> tbh i would just do the a >>= \x -> b >>= \y -> f x y thing
06:05:28 <Intolerable> :t \f a b -> a >>= \x -> b >>= \y -> f x y
06:05:31 <lambdabot> Monad m => (a -> a1 -> m b) -> m a -> m a1 -> m b
06:05:31 <indiagreen> xandaros: I needed it exactly once and I ended up using join, I think
06:05:45 <xandaros> Yeah, I think I will go for that. It IS in a d block, but I like to keep those as short as possible
06:06:24 <Intolerable> i feel like it *should* exist somewhere
06:06:39 <indiagreen> http://hayoo.fh-wedel.de/?query=bind2
06:06:55 <indiagreen> it has been reinvented at least thrice
06:07:12 <indiagreen> and there are probably other less-obvious names too
06:07:54 <xandaros> To be honest, I would have expected such a function in Control.Monad or something
06:12:41 <roelof> hello, Im doing chapter 2 of the craft book and first I did double(square 2) which is 8. After that I must use it which is also 8 . Am I correct that it is the outcome of the last expression 
06:13:03 <geekosaur> roelof, yes
06:14:02 <roelof> thanks, it was not explained in the book so I wonder and want to be sure 
06:28:44 * hackagebot fgl 5.5.2.2 - Martin Erwig's Functional Graph Library  https://hackage.haskell.org/package/fgl-5.5.2.2 (IvanMiljenovic)
06:28:46 * hackagebot fgl-arbitrary 0.2.0.1 - QuickCheck support for fgl  https://hackage.haskell.org/package/fgl-arbitrary-0.2.0.1 (IvanMiljenovic)
06:29:05 <verumequals> I just googled and found a stackoverflow comment that said EclipseFP is not maintained anymore. I've recently installed Haskell Platform, Eclipse Mars and EclipseFP but no syntax highlighting or any sort of Haskell integration seems to be working, no solution for this I suppose?
06:33:44 * hackagebot memory 0.10 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.10 (VincentHanquez)
06:39:34 <sinelaw> Hi! Is there a short way to implement: firstJustIO :: [IO (Maybe a)] -> IO (Maybe a)
06:39:45 <sinelaw> should perform IO actions until first Just
06:40:10 <sinelaw> fmap msum . sequenceA <--- has the same type, but runs all actions before finding the first just
06:42:40 <supki> :t runMaybeT . asum . fmap MaybeT
06:42:42 <lambdabot> (Monad m, Functor t, Foldable t) => t (m (Maybe a)) -> m (Maybe a)
06:43:08 <clrnd> :t asum
06:43:09 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
06:43:29 <chpatrick> very nice
06:43:42 <clrnd> > asum [Nothing, Just 5, Just 7]
06:43:44 <lambdabot>  Just 5
06:44:14 <sinelaw> :t MaybeT
06:44:18 <lambdabot> m (Maybe a) -> MaybeT m a
06:44:31 <sinelaw> supki: :)
06:45:51 <sinelaw> supki: but it doesn't seem to work?
06:46:26 <sinelaw> > runMaybeT . asum . fmap MaybeT $ [Nothing, return (Just 2), return (Just 1)]
06:46:30 <lambdabot>  Nothing
06:46:42 <sinelaw> the list is of actions
06:46:56 <chpatrick> > runMaybeT . asum . fmap MaybeT $ [return Nothing, return (Just 2), return (Just 1)]
06:46:58 <lambdabot>      No instance for (Show (m0 (Maybe a0)))
06:46:58 <lambdabot>        arising from a use of ‘show_M753205114796092252213711’
06:46:58 <lambdabot>      The type variables ‘m0’, ‘a0’ are ambiguous
06:47:12 <sinelaw> ah
06:47:14 <sinelaw> oops.
06:47:36 <sinelaw> thanks!
06:50:39 <harlchen> i give _svgDefinitions a type of [Attribute] like it says in the documentation but it says that the type should be a SvgM @ http://lpaste.net/1841458436361945088 , what did i misunderstand ?  [ Diagrams , svg]
06:53:45 * hackagebot fgl 5.5.2.3 - Martin Erwig's Functional Graph Library  https://hackage.haskell.org/package/fgl-5.5.2.3 (IvanMiljenovic)
06:53:47 * hackagebot tasty 0.11 - Modern and extensible testing framework  https://hackage.haskell.org/package/tasty-0.11 (RomanCheplyaka)
06:54:08 <byorgey> harlchen: whoops, looks like the type changed to  Maybe SvgM  but we didn't update the documentation to match
06:54:23 <byorgey> harlchen: let me see if I can figure out what you should change it to
06:54:33 <harlchen> btw the attribute link in the doc links to a local file :)
06:55:05 <harlchen> thx
06:58:16 <byorgey> harlchen: so SvgM is an alias for Svg () which is in turn an alias for HtmlT m ()  from lucid
06:59:21 <byorgey> to be honest I'm not sure what you are supposed to do to get an HtmlT m ()  if you just have an attribute to set
07:03:21 <byorgey> harlchen: let's ask in #diagrams, others there know more about the SVG backend than I do
07:03:32 <harlchen> ok, thx
07:04:59 <f-a> this expression gives me type error:
07:05:01 <f-a> let a = 25 ** (1/2) in a == floor a
07:05:13 <f-a> I understand why, but I don't know how to fix it
07:05:31 <Intolerable> > let a = 25 ** (1/2) in a == floor a
07:05:33 <lambdabot>      No instance for (Floating a0) arising from a use of ‘a’
07:05:33 <lambdabot>      The type variable ‘a0’ is ambiguous
07:05:33 <lambdabot>      Note: there are several potential instances:
07:05:43 <Intolerable> it has no idea which Floating instance to use
07:05:50 <Intolerable> specify a type signature for a and you should be fine
07:05:58 <Intolerable> > let a = 25 ** (1/2) in a == floor (a :: Float)
07:06:00 <lambdabot>      No instance for (Floating a0) arising from a use of ‘a’
07:06:00 <lambdabot>      The type variable ‘a0’ is ambiguous
07:06:00 <lambdabot>      Note: there are several potential instances:
07:06:04 <f-a> yep
07:06:14 <f-a> that's what I did and that's the error I was thrown
07:06:23 <Intolerable> > let a = (25 ** (1/2) :: Float) in a == floor a
07:06:25 <lambdabot>      No instance for (Integral Float) arising from a use of ‘floor’
07:06:25 <lambdabot>      In the second argument of ‘(==)’, namely ‘floor a’
07:06:25 <lambdabot>      In the expression: a == floor a
07:06:29 <Intolerable> hm
07:06:49 <Intolerable> :t (**)
07:06:50 <lambdabot> Floating a => a -> a -> a
07:07:00 <Intolerable> :t floor
07:07:01 <lambdabot> (Integral b, RealFrac a) => a -> b
07:07:19 <Intolerable> ok i don't think it even makes sense
07:07:48 <clrnd> :t (/)
07:07:50 <lambdabot> Fractional a => a -> a -> a
07:08:09 <clrnd> all distinct classes, lol so much fuuuun
07:08:16 <Intolerable> is a floating or integral? because it shouldn't be both, but a == floor a needs it to be both
07:08:23 <Intolerable> :t \a -> a == floor a
07:08:25 <lambdabot> (Integral a, RealFrac a) => a -> Bool
07:08:50 <clrnd> @info RealFrac
07:08:51 <lambdabot> RealFrac
07:09:02 <clrnd> @cookie
07:09:02 <lambdabot> Unknown command, try @list
07:09:51 <f-a> Intolerable: the aim of the function is to check wether the number is squareable
07:09:52 <clrnd> :t (^)
07:09:56 <lambdabot> (Integral b, Num a) => a -> b -> a
07:10:07 <Intolerable> squareable or sqrtable?
07:10:09 <clrnd> > let a = (25 ^ (1/2)) in a == floor a
07:10:10 <lambdabot>      Could not deduce (Integral b0) arising from a use of ‘^’
07:10:10 <lambdabot>      from the context (Num a)
07:10:10 <lambdabot>        bound by the inferred type of a :: Num a => a
07:10:21 <f-a> sqrt, sorry
07:10:34 <dexterph> > let a = 25 ** (1/2) in a == fromIntegral (floor a)
07:10:37 <lambdabot>  True
07:10:46 <Intolerable> :t sqrt
07:10:46 <byorgey> Intolerable: the problem is that  a  is some floating point type but  floor a  is an Integral type
07:10:48 <lambdabot> Floating a => a -> a
07:11:11 <byorgey> Intolerable: one solution is to convert  floor a  back to a floating-point type using fromIntegral, as dexterph illustrated above
07:11:23 <f-a> thanks dexterph 
07:11:24 <byorgey> Intolerable: however, comparing floating point values for equality is not a very good idea
07:11:34 <byorgey> oh, sorry, I mean f-a
07:11:38 <Intolerable> np
07:12:29 <byorgey> f-a: are you starting with an Integral value (like Int or Integer) and want to test whether it is a perfect square?
07:12:48 <f-a> byorgey: yes
07:13:15 <f-a> as I said, it's a very very silly way to test it, but in this case I wanted to win against the typechecker
07:13:34 <byorgey> f-a: OK, fair enough =)
07:14:22 <byorgey> see http://stackoverflow.com/questions/19965149/integer-square-root-function-in-haskell  for a nice way to compute the square root of an Integer value, without going via floating-point at all
07:14:41 <byorgey> then you can just square the result and see if it is equal to the starting value
07:14:45 <dickewolle> hey guys, i'm new here.  i'm working on the nicta exercises but i'm stuck on the applicative set.  is anybody familiar with the course?
07:14:55 <byorgey> which will be an (exact) equality comparison between Integer values
07:14:56 <f-a> thanks
07:15:48 <dickewolle> if anybody could offer some intuition as to what 'filtering' is supposed to do, that'd be great
07:15:52 <clrnd> dickewolle, I'm not, but maybe I can answer your question
07:16:13 <byorgey> dickewolle: also, welcome! =D
07:16:45 <clrnd> > filter (>7) [1..10]
07:16:47 <lambdabot>  [8,9,10]
07:17:12 <dickewolle> the exercise is here: https://github.com/NICTA/course/blob/master/src/Course/Applicative.hs
07:17:18 <dickewolle> filtering is different from filter
07:17:42 <dickewolle> eg: -- >>> filtering (const $ True :. True :.  Nil) (1 :. 2 :. 3 :. Nil)
07:17:44 <dickewolle> -- [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
07:17:52 <Intolerable> :t traverse
07:17:54 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
07:18:23 <Intolerable> do you understand what traverse does?
07:20:13 <clrnd> looks like a filterM for Applicative
07:22:18 <dickewolle> what's filterM?
07:22:24 <Intolerable> :t filterM
07:22:25 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
07:22:47 <mariusmarius> :t filter
07:22:48 <lambdabot> (a -> Bool) -> [a] -> [a]
07:23:15 <Intolerable> :t filterA
07:23:16 <lambdabot>     Not in scope: ‘filterA’
07:23:17 <lambdabot>     Perhaps you meant one of these:
07:23:17 <lambdabot>       ‘filter’ (imported from Data.List),
07:23:24 <Intolerable> lambdabot pls
07:23:24 <mariusmarius> Ok. so its like fmap is to map…but its a monad
07:23:27 <dickewolle> ah, yes, that's the right kinda thing
07:23:47 * hackagebot binary-tagged 0.1.1.0 - Tagged binary serialisation.  https://hackage.haskell.org/package/binary-tagged-0.1.1.0 (phadej)
07:24:07 <slomo> more like mapM for Applicatives/Traversables
07:24:30 <sshine> :t mapM
07:24:31 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
07:24:39 <sshine> :t Control.Monad.mapM
07:24:40 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
07:24:53 <sshine> :t map
07:24:54 <lambdabot> (a -> b) -> [a] -> [b]
07:25:14 <sshine> mariusmarius, if you're looking for something like fmap for monads, liftM.
07:25:33 <dickewolle> but i want m (t a) as output
07:25:37 <mariusmarius> sshine: thanks…I meant filterM as opposed to regular filter
07:25:44 <kadoban> dickewolle: It's like 'filter', but it can do /something else/ at the same time. So something like you could filter, and while you're doing it output to the console a message any time you hit a 7, or something (that'd be the IO applicative), you could log them instead (that'd be the Writer applicative).
07:25:46 <Intolerable> if you're looking for something like fmap for monads, use fmap
07:25:49 <Intolerable> :P
07:25:49 <mariusmarius> cuz regular filter only applies to lists
07:26:04 <sshine> mariusmarius, filterM also only applies to list... ;)
07:26:06 <clrnd> so `filtering` takes a function from `a` to `f Bool` (a condition with an effect), filters the True values and `runs` the effects
07:26:45 <clrnd> a good question would be, does it "run" all the effects or only the True ones??
07:27:08 <sshine> mariusmarius, wait, sorry. it does apply to traversable.
07:27:14 <clrnd> (can it even know it's True before "running" it?)
07:27:21 <kadoban> dickewolle: I think the doctest there using Empty/Full is probably the most understandable of the doctests, if you want to look at that one. That one is … say you're doing a computation on percents, 0-100, and you want to find the percents bigger than 50. /but/ you'd like the whole thing to totally fail (Empty) if you find an invalid value, like 105. You could do that with the Optional applicative like they're doing.
07:27:31 <dickewolle> cool, thnx
07:28:38 <dickewolle> ah yes, i'll take a look at the doctests
07:29:13 <dickewolle> i wasn't sure what was going on with the list example i posted above but i think what clrnd said about effects makes it a bit clearer
07:31:17 <kadoban> Yeah the list one I remember not making any sense to me when I first did that. Now I can understand what it's doing … but it's still not really a conceptually clear thing (why you'd do that), it's really just a test that your implementation does the right thing.
07:33:43 <dickewolle> ok, i'll go think about it a bit more
07:33:47 * hackagebot arbtt 0.9.0.5 - Automatic Rule-Based Time Tracker  https://hackage.haskell.org/package/arbtt-0.9.0.5 (JoachimBreitner)
07:33:48 <dickewolle> thanks for the help guys
07:33:49 * hackagebot list-fusion-probe 0.1.0.4 - testing list fusion for success  https://hackage.haskell.org/package/list-fusion-probe-0.1.0.4 (JoachimBreitner)
07:38:47 * hackagebot hops 0.1.0 - Hackable Operations on Power Series  https://hackage.haskell.org/package/hops-0.1.0 (AndersClaesson)
08:15:42 <flippant> sm: just OBS for mac
08:23:49 * hackagebot pinboard 0.8.9 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.8.9 (jonschoning)
08:27:38 <Sindriava> Does anyone use emacs on OSX?
08:28:09 <mariusmarius> Sindriava: yes, kind of
08:28:17 <Sindriava> Kind of?
08:28:56 <mariusmarius> I use linux on my personal computer, and I work in a non-programmer job, but they give us macs, so I installed emacs on it.
08:29:01 <Sindriava> I see!
08:29:09 <Sindriava> My question is, which version should I use?
08:29:22 <Sindriava> There's aquamacs, carbon… Which one do you use?
08:29:27 <mariusmarius> Just standard emacs.
08:29:32 <mariusmarius> install brew
08:29:35 <mariusmarius> and just install emacs from there
08:29:39 <Sindriava> I see
08:29:50 <Sindriava> Spacemacs recommend some other port, so I got kinda confused :)
08:29:53 <Sindriava> Thanks ^^
08:30:08 <mariusmarius> I would highly highly recommend just learning standard emacs. Don't do any crazy config stuff.
08:30:24 <mariusmarius> Just for future reference, this is a good topic for #haskell-blah
08:30:39 <Sindriava> Oh man, I though this was -blah
08:30:43 <Sindriava> Derp, I'll take it there
08:30:44 <mariusmarius> u good
08:34:52 <dickewolle> wooo...i have a solution
08:36:10 <clrnd> :D
08:38:50 * hackagebot tinytemplate 0.1.2.0 - A tiny text templating library  https://hackage.haskell.org/package/tinytemplate-0.1.2.0 (PhilFreeman)
08:39:11 <platz> i tried spacemacs but it installed too many plugins for my taste.. just installing the Evil packages separately works great
08:39:58 <platz> spacemacs has the 'layers' abstraction that forces a different package organization.. cool because you can rollback stuff, but also heavy handed
08:42:37 <breadmonster> I'm trying to figure out how to find the smallest factor of a given number by trial division.
08:42:54 <breadmonster> And it's pretty straightforward, but I'd like to figure out how to do it elegantly.
08:43:41 <breadmonster> Ideally something like `factor n = factor f n [2..n]` where f is some mystery function.
08:44:09 <breadmonster> I'm also okay with using a right fold and finding the largest factor, it doesn't really change the problem I'm working on.
08:46:43 <breadmonster> the best I've gotten is `factor n = foldr (\z x -> if n `mod` z == 0 then z else x) [2..(n-1)]`
08:46:50 <breadmonster> Is there a shorter solution?
08:47:02 <chpatrick> why not factor n = head $ filter (\n' -> n `mod` n' == 0) [2..n] ?
08:47:16 <breadmonster> chpatrick: Point taken.
08:47:29 <clrnd> this ^ ellegantly like `filter isDivisible [2..n] where ...`
09:03:51 * hackagebot hspec-snap 0.3.3.1 - A library for testing with Hspec and the Snap Web Framework  https://hackage.haskell.org/package/hspec-snap-0.3.3.1 (DanielPatterson)
09:10:07 <fractalsea> I have a library that returns values in a reader monad for a particular environment (Env1). In my application I have a transformer stack with a ReaderT with another environment (Env2). Is there any way I can combine two ReaderT’s in a nice way? Or should I patch the library to read from a typeclass rather than a concrete type, and then implement the typeclass in my application?
09:11:13 <Intolerable> does MonadReader work for that?
09:12:17 <glguy> :t withReader
09:12:19 <lambdabot> (r' -> r) -> Reader r a -> Reader r' a
09:13:32 <glguy> You can use that to convert on Env into the other or to merge the two
09:13:38 <glguy> depending on what your Env types are
09:14:27 <glguy> It's just function composition but with a fancier name and with the newtypes
09:14:43 <fractalsea> I
09:16:49 <lpaste_> fractalsea pasted “Intolerable, I did try, that but I got an error like this” at http://lpaste.net/140480
09:17:08 <fractalsea> glguy, thanks I will give that a go
09:20:49 <indiagreen> meanwhile in my ghci, “randomRIO (1, 3)” crashes with “Exception: Prelude.last: empty list”
09:20:58 <indiagreen> it doesn't happen in another ghci
09:21:01 <indiagreen> I do wonder why
09:23:05 <Intolerable> you on windows?
09:23:38 <indiagreen> nope
09:27:35 <srhb> That is weird...
09:28:07 <indiagreen> yeah (and I also checked that it wasn't redefined somehow)
09:28:09 <srhb> My first feeling was DMR but I can't really find a reasonable explanation after thinking it over :P
09:28:37 <indiagreen> wait, what's DMR?
09:28:44 <srhb> Dreaded Monomorphism Restriction
09:29:10 <indiagreen> nope, I also ran it as “randomRIO (1,3) :: IO Integer” and the same happened
09:30:08 <srhb> indiagreen: What happens if you do foo <- randomRIO (1,3) ?
09:30:27 <indiagreen> I closed that ghci already so can't do more experiments, sorry
09:30:42 <srhb> Oh, okay. Probably wouldn't have been enlightening anyway.
09:31:24 <indiagreen> well, it took me 10m to debug it and it was a 50-line program so if something like this starts happening more often, that would be... unpleasant
09:32:10 * geekosaur wonders what getStdGen would have done
09:32:13 <srhb> Cosmic radiation. *nods*
09:43:53 * hackagebot pinboard 0.8.10 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.8.10 (jonschoning)
09:48:53 * hackagebot goatee 0.3.1 - A monadic take on a 2,500-year-old board game - library.  https://hackage.haskell.org/package/goatee-0.3.1 (khumba)
10:03:53 * hackagebot goatee 0.3.1.1 - A monadic take on a 2,500-year-old board game - library.  https://hackage.haskell.org/package/goatee-0.3.1.1 (khumba)
10:03:55 * hackagebot goatee-gtk 0.3.1 - A monadic take on a 2,500-year-old board game - GTK+ UI.  https://hackage.haskell.org/package/goatee-gtk-0.3.1 (khumba)
10:34:31 <breadmonster> Hello.
10:34:42 <breadmonster> All ACME libraries are jokes right?
10:35:59 <Taneb> breadmonster, yes
10:36:05 <clrnd> breadmonster, not all
10:37:03 <breadmonster> Any interesting libraries?
10:37:29 <breadmonster> I've heard that continuation passing style is the secret to fast Haskell code, whatever that means.
10:38:30 <hodapp> where did you hear said secret
10:38:32 <hodapp> ?
10:38:51 <clrnd> acme-lookofdisapproval is nice
10:39:35 <breadmonster> hodapp: The review of Parsec 3.
10:39:53 <breadmonster> Something about adding CPS boosted speed by some huge constant factor.
10:40:01 <breadmonster> Also, random rants on the blog that bos runs.
10:40:10 <breadmonster> I can neither pronounce nor spell that name.
10:40:13 <hodapp> hmm, trying to figure out how to best write this library
10:40:35 <drewbert> Does anybody know any tricks to get aeson to list the key name on which an error was encountered, all I'm getting is: "when expecting a Int, encountered String instead"
10:41:34 <breadmonster> hodapp: Have you ever seen bonus on here?
10:41:50 <hodapp> I had monad Foo and monad Bar which were separate, and it seems that while Bar can exist on its own and have some usefulness, the only real way that Foo and Bar can operate together is to combine them somehow and I just defined Bar as a transformer (StateT) on Foo
10:42:28 <hodapp> there are various Foo operations and I guess I'd need to lift them all
10:42:51 <hodapp> but, trying to decide whether Foo and Bar have any reason to exist separately
10:45:39 <jle`> hodapp: if you want, you can write Foo and Bar as functors, and use a functor Sum to combine their separately-defined effects
10:46:07 <jle`> automagically
10:46:16 <hodapp> jle`: ahh, hmm.
10:46:22 <drewbert> Hrmm, seems like it would be trivial to get Aeson to list more information about how it is failing.
10:46:48 <hodapp> jle`: right now Bar is a StateT so that's why I went to using it to transform Foo... is there strong reason to use Sum over this?
10:47:24 <drewbert> The Fail constructor of the Result type in it's attoparsec backend contains the remaining string and a list of contexts, but these are ignored by the aeson library.
10:47:32 <jle`> hodapp: hm.  i can't formulate a coherent response at the moment
10:48:30 <hodapp> but functors alone don't really suffice for what I'm doing
10:54:46 <jle`> hodapp: i was talking about the pattern mentioned here -- http://dlaing.org/cofun/posts/coproducts_for_free_and_products_for_cofree.html
10:55:14 <jle`> but i think you're right
10:56:27 <Gurkenglas> What IRC nick wrote https://hackage.haskell.org/package/ACME-0.0.0.1/docs/src/Acme-Smash.html#smash ? That algorithm doesn't even have "smash (reverse y) (reverse x) = reverse $ smash x y" >:(
10:57:54 <Imagine> I'm getting an "*** Exception: <<loop>>"
10:58:00 <Imagine> but I've never encountered that before
10:58:06 <geekosaur> @paste
10:58:06 <lambdabot> Haskell pastebin: http://lpaste.net/
10:58:11 <geekosaur> ^ pastebin code
10:58:16 <Imagine> yep - one sec
10:58:26 <jle`> Imagine: GHC solved the halting problem and can predict when code won't terminate
10:58:35 <geekosaur> usually that means you've done the equivalent of let x = x in x
10:58:38 <jle`> so it pops up that exception to save you the time of waiting an eternity :)
10:58:56 <KaneTW> such a great language
10:59:00 <ReinH> heh
10:59:16 <Imagine> http://lpaste.net/140485
10:59:17 <Imagine> ah got it
10:59:23 <Imagine> hmm let me see if I did something like that
11:00:26 <Imagine> I'm getting the loop exception when I try to show my structure
11:01:21 <nitrix> Given a stack-based language, I want to claim the stack is acting like a continuation but then I read on delimited continuations. Which one is the most sensible term?
11:02:55 <KaneTW> your issue is in your let declaration
11:03:09 <KaneTW> it tries to do let m = insert 5 (insert 5 (insert 5 (...
11:03:25 <KaneTW> let is recursive
11:03:32 <geekosaur> yeh, that "let m = insert 5 m" does not use the old m on the rgight, but the new one
11:03:32 <Imagine> ah gotcha
11:03:39 <Imagine> yeah that makes sense
11:06:45 <Imagine> Okay - new issue
11:06:57 <Imagine> Suppose I have a main function with that same code:
11:07:11 <Imagine> main = do print empty
11:07:24 <Imagine> that throws an error because the type of empty is ambiguous 
11:07:25 <Gurkenglas> (No need for do on that one)
11:08:07 <Imagine> Should I add (Show a => Fheap a) as the type declaration to empty?
11:08:14 <Imagine> and got it -- I'll get rid of the do
11:08:17 <geekosaur> you need to specify a type, yes. ghci doesn't require it because of extended defaulting --- but that can also yield surprises (usually it infers () and then you get a type error later...)
11:08:18 <Cale> Imagine: no, that is just as ambiguous
11:08:32 <Denommus> Imagine: Show a => Fheap a is not a concrete type
11:08:34 <Cale> Imagine: Yeah, try  main = print (empty :: FHeap ())
11:08:43 <Denommus> Imagine: it's just a constraint
11:08:50 <Cale> Or  FHeap Integer  or something like that
11:09:13 <jle`> the problem is that it doesn't know empty is Showable or not, the problem is that it doesn't know what empty to show
11:09:24 <jle`> cause there are bunches of empties
11:09:34 <Imagine> ah
11:09:44 <Imagine> and even though every empty shows the same thing, ghc doesn't know that?
11:10:18 <Imagine> That makes sense, cool
11:10:59 <jle`> i think in ghci it assumes `FHeap a` is FHeap ()
11:16:07 <Reite> Is it possible to write a SafeCopy instance for a Gadt? One like this: http://lpaste.net/140474
11:17:07 <Reite> Im thinking no because there is no way the getCopy would typecheck
11:20:40 <lpaste_> yrlnry pasted “Unexpected Num [Char] constraint” at http://lpaste.net/140486
11:22:08 <jle`> yrlnry: are you expecting ghc to implicit convert 17 to "17" ?
11:22:18 <jle`> there are no implicit conversions in haskell
11:22:31 <yrlnry> I jut don't understand where the Num constraint comes from.
11:22:36 <mpickering> yrlnry: you need to use existential quantification
11:22:45 <mpickering> In the IT type
11:22:51 <yrlnry> I need to understand what is happening first :)
11:23:02 <jle`> yrlnry: it's inferring that your State type is String
11:23:16 <jle`> and you only put Strings
11:23:34 <jle`> so then you put a 17, and 17 is an overloaded literal for (fromInteger 17)
11:23:45 <jle`> so it sees a 17 and tries to parse it into whatever type you expect there
11:23:45 <srhb> :t fromIntegral
11:23:46 <lambdabot> (Integral a, Num b) => a -> b
11:23:53 <jle`> :t fromInteger
11:23:54 <lambdabot> Num a => Integer -> a
11:23:58 <mpickering>  One of the parameters is fixed to Num by the first put 
11:24:19 <jle`> whenever you use a number literal like 17, GHC tries to parse it as whatever type is expected there
11:24:28 <mpickering> Ah its hard to keep up from your phone...
11:25:01 <jle`> it can only do this if the "expected type" is an instance of Num
11:25:07 <yrlnry> Oh, so it figures out from the literal 17 that type o has a Num o constraint, and then it barfs on the "foo" because there is no Num instance for String.
11:25:08 <jle`> but String is not an instance of Num, so no go :'(
11:25:13 <yrlnry> got it.
11:25:35 <jle`> yrlnry: yeah, you can think of it that way.  i like to think of it as, it sees "foo" and knows it expects a String, but it can't parse 17 as a String becuse there's no Num instance for String
11:26:07 <yrlnry> Couldn't it come to the same conclusion in either order, depending on the internals of the type elaboration algorithm?
11:26:12 <KaneTW> Reite: i don't see why it shouldn't
11:26:24 <jle`> yrlnry: i think it should come to the same conclusion
11:26:31 <mpickering> Is it not fixing the type to be Num a => a and then failing to match that with String?
11:27:35 <jle`> i think, it sees 17 and knows, "okay, this can be any Num instance.  what does it have to be?"; and it goes on until it sees more hints on what the 17 has to be
11:27:58 <jle`> when it sees that it has to be a String, and String has no Num instance, it freaks out
11:28:49 <yrlnry> Yeah, I was confused about what my (Show o) constraint meant.   o still has to be a single type, and that single type must satisfy the Show constraint.
11:29:12 <yrlnry> Now I understand why I need an existential type.  How do I do that?
11:29:27 <shachaf> Uh oh.
11:30:14 <jle`> yrlnry: you don't want an existential type
11:30:26 <jle`> why not just show the 17 and store "17" ? 
11:30:37 <jle`> why do you have to store 17-the-Int?
11:30:44 <jle`> why can't you just trace "17"?
11:30:56 <yrlnry> I don't have to do anything, I'm just tinkering.
11:31:09 <jle`> ah, ok
11:31:51 <shachaf> GHC doesn't support first-class existential types.
11:31:52 <emmanuel_erc> Hello there!
11:32:00 * shachaf looks for the original question.
11:32:30 <jle`> yrlnry: in this case the best idiomatic option would be to just let runTraceWriter take IT i String a instead of Show o => IT i o a
11:32:40 <emmanuel_erc> So I was on here yesterday and I mentioned that someone had told me that Haskell can only solve so many problems.
11:32:50 <emmanuel_erc> To what extent is that true?
11:32:57 <emmanuel_erc> if at all.
11:33:08 <yrlnry> shachaf: It's http://lpaste.net/140486
11:33:17 <jle`> emmanuel_erc: well for one, it can't solve the problem of how vague that question is :P
11:33:30 <yrlnry> jle`: I had it that way before but I thought I'd try it this way and see what happened.
11:33:32 <mpickering> You need to be more specific,  which problems are you talking about :)
11:33:43 <emmanuel_erc> Lol... umm sorry.
11:33:57 * hackagebot skeletons 0.4.0 - Manage project skeletons  https://hackage.haskell.org/package/skeletons-0.4.0 (WilliamCasarin)
11:33:59 * hackagebot tubes 1.0.0.0 - Effectful, iteratee-inspired stream processing based on a  free monad.  https://hackage.haskell.org/package/tubes-1.0.0.0 (gatlin)
11:34:31 <emmanuel_erc> Well at first that Haskell might be slower than most common imperative languages.
11:34:47 <shachaf> yrlnry: OK, I see.
11:35:04 <jle`> emmanuel_erc: are you counting node, python, ruby...?
11:35:04 <emmanuel_erc> And also that certain problems would either be difficult or impossible to solve using a functional programming language.
11:35:09 <emmanuel_erc> Yes I am.
11:35:21 <shachaf> yrlnry: Well, using a String instead of a value of a type which is an instance of Show is indeed probably a better solution.
11:35:32 <yrlnry> Why so?
11:35:36 <jle`> hm, haskell is generally considered to be on the comaprable speed level to C/Java
11:35:38 <shachaf> yrlnry: What's the definiition of your data type?
11:35:46 <yrlnry> Which data type?
11:35:47 <jle`> so maybe an order of magnitude faster than node/python/ruby/etc.
11:36:01 <shachaf> Whatever is defining Pure/Get/Put.
11:36:14 <jle`> emmanuel_erc: also, Haskell is a pretty good imperative language too, and can implement any imperative algorithm as an imperative algorithm
11:36:29 <jle`> and you get a lot of benefits, like type inference, type checking, parametricity...
11:36:37 <emmanuel_erc> Well, that concern (about speed) has already been resolved.
11:36:38 <lpaste_> yrlnry annotated “Unexpected Num [Char] constraint” with “Unexpected Num [Char] constraint (annotation)” at http://lpaste.net/140486#a140487
11:36:51 <yrlnry> shachaf^^
11:37:11 <jle`> i can't imagine how a problem would be solvable in an "imperative language" and not be solvable in the same way in Haskell
11:37:21 <jle`> because Haskell has nice constructs for imperative programming
11:38:10 <lpaste_> yrlnry revised “Unexpected Num [Char] constraint (annotation)”: “No title” at http://lpaste.net/140487
11:38:11 <shachaf> yrlnry: Something like (exists a. Show a *> a), which is the sort of thing I think you're getting at, is a value such that the only thing you can do with it is show it.
11:38:13 <emmanuel_erc> I was told that haskell might have some shortcomings by a CS professor who happens to teach SML in a senior level programming languages class.
11:38:26 <athan> jle` ...Every imperative algorithm as a pure function*
11:38:35 <yrlnry> That seems of very limited usefulness.
11:38:58 <athan> yrlnry: If you had everything in the universe at your disposal, at one time, you'd have chaos
11:38:58 <jle`> athan: hm, i don't know about that
11:39:04 <jle`> a lot of imperative algorithms aren't functions
11:39:06 <Rembane> emmanuel_erc: Did the prof say which ones?
11:39:23 <jle`> they just are a collection of instructions
11:39:24 <athan> jle`: o_o reread your post lol
11:39:35 <jle`> which one?
11:39:38 <athan> quit using the identity funciton in prose! :P
11:39:43 <athan> 12:35
11:39:45 <athan> er
11:39:49 <athan> my time ._.
11:39:53 <jle`> i did mean haskell can implement any imperative algorithm as a literal imperative algorithm
11:40:05 <emmanuel_erc> No he didn't. I had mentioned that I was learning Haskell to him (we were colleagues at the time, I was an instructor) over lunch, and he just made the passing comment about Haskell. 
11:40:05 <shachaf> yrlnry: It's pretty close to just having the String you get from show in the first place.
11:40:20 <athan> oh :x
11:40:32 <emmanuel_erc> I suspect he hasn't really used Haskell at all.
11:40:42 <hiptobecubic> of course haskell has some short comings. 
11:40:51 <jle`> so you don't *have* to rephrase every imperative algorithm as a fancy functional reformulation...you can just implement the algorithm as-is
11:40:56 <jle`> emmanuel_erc: be careful with that assumption :)
11:41:07 <jle`> everyone who uses haskell knows a lot of its shortcomings, heh
11:41:36 <mauke> put :: Show o => o -> IT i a -> IT i a; put = Put . show
11:41:38 <shachaf> yrlnry: Are you still asking why you're getting that type error, or was that clarified?
11:41:53 <emmanuel_erc> Well I didn't mean to imply that Haskell doesn't... but I am not sure if his opinion is qualified. To be honest, I will have to have a honest discussion with him.
11:42:02 <shachaf> mauke: IT i String a?
11:42:36 <mauke> shachaf: why keep the parameter if you're only going to store strings?
11:42:53 <jle`> mauke: i think the intent was, put :: Show o => IT i a -> IT String a
11:43:00 <jle`> er, s/i/o
11:43:16 <shachaf> mauke: Fair enough. It looks like that data type is more general than this one use.
11:43:18 <jle`> um the depth of my mangling of letters is strong
11:44:06 <mauke> hmm
11:45:12 <jle`> put :: Show o => o -> IT i String a
11:45:15 <shachaf> yrlnry: By the way, if you're using types like IT, you might want to read about free monads, if you haven't.
11:46:48 <shachaf> yrlnry: IT i o a = Free (F i o), where data F i o r = Get (i -> r) | Put o (() -> r)
11:56:59 <hiptobecubic> googling for things related to stack is *terrible*
11:57:22 <hiptobecubic> Whoever thought it wasn't going to be a big deal obviously did not think about it very hard :(
11:58:03 <brbblnch> hello
11:58:33 <brbblnch> Is this statement (https://www.reddit.com/r/haskell/comments/3jf2tq/using_rankntypes_and_constraintkinds_to_create_an/cup2ubk) true?
11:58:57 <brbblnch> or rather, do you agree with it?
11:58:58 * hackagebot hscope 0.4.2 - cscope like browser for Haskell code  https://hackage.haskell.org/package/hscope-0.4.2 (BorisSukholitko)
11:59:03 <mauke> meh, too hard to select the link
11:59:39 <yrlnry> shachaf: My definition of IT is copied from Kiselyov and Ishii Freer Monads, More Extensible Effects
11:59:42 <brbblnch> https://tinyurl.com/ndv5jk2
11:59:51 <clrnd> lol
12:00:54 <geekosaur> more or less true, yes. that said, there is ongoing work on simplifying and combining them
12:01:25 <shachaf> yrlnry: Ah. I haven't read it yet.
12:01:50 <geekosaur> serious type level programming support as a ghc objective is fairly recent
12:01:51 <brbblnch> I've read somewhere that, as a "logic", haskell was not consistant. Are those two more or less the same problem?
12:02:13 <mauke> no, haskell has always had unrestricted res
12:02:16 <mauke> cursion
12:02:17 <mauke> dammit
12:02:49 <bitemyapp> mauke: mens rea cursion
12:03:01 <clrnd> > let a = undefined in 5
12:03:02 <lambdabot>  5
12:03:11 <brbblnch> But this is a feature, like I/O. But are there stuff that aren't logically sound due to a bad implementation, or cooperation of features?
12:04:42 <clrnd> haskell is a language from 1990, I think that that it got as far is a wonder, not a shortcoming
12:05:17 <hpc> we did everything we could but it succeeded anyway
12:05:42 <brbblnch> alright. So here is my next question: Is Idris 'haskell done right' ?
12:06:10 <clrnd> in my very humble opinion, no, it's a diferent language with diferent core ideals
12:06:30 <brbblnch> clrnd: For instance?
12:06:32 <clrnd> idris is more like coq done right
12:06:44 <Cale> Well, coq done practical?
12:06:45 <hpc> coq is already coq done right
12:06:51 <hpc> idris is meant to be run
12:06:56 <clrnd> haskell is not intended as a theorem prover
12:07:09 <Cale> I agree, coq is already pretty much coq done right -- apart from some concrete syntactic choices :)
12:07:39 <clrnd> yeah you are right, maybe agda done right? (discussable)
12:07:42 <Cale> Idris is also not intended as a theorem prover
12:07:47 <brbblnch> but agda's syntax is closer to haskell, right? So, would agda be coq done right?
12:07:48 <hpc> if you want to write theorems in idris, you're a bit closer to the right language but still a bit out of your element
12:07:54 <clrnd> oh yeah?
12:08:01 <hpc> agda and coq are different approaches to the same problem
12:08:03 <clrnd> the tutorial has 4 sections for prooving a theorem
12:08:10 <clrnd> (idris')
12:08:16 <Cale> Idris is intended to be a practical language for writing software that happens to have a dependent type system
12:08:39 <Cale> So while you might be able to prove some theorems using its type system, it's not focused on that.
12:08:44 <brbblnch> hpc: What's the diff in the approaches?
12:08:46 <hpc> clrnd: you can, but it's not a language you use when you set out to prove a theorem
12:08:59 <hpc> it's a language where when you need to solve a problem, theorem proving is available to you
12:09:26 <mauke> "need to solve a problem? why not prove a theorem or two while you're at it?"
12:09:31 <brbblnch> By the way, I thougt that by "theorem proving", you used Curry-Howard and simply gave a function. That isn't it, right?
12:10:01 <Cale> brbblnch: Well, not necessarily a function, but some value of a type which encodes what your theorem's statement is.
12:10:06 <hpc> brbblnch: coq's use of tactics, for instance
12:10:11 <clrnd> hpc, mmm you are right, but I have to say that haskell wasn't born with any proving facilities, while idris was
12:10:30 <Welkin> has anyone used reflex and reflex-dom? If so, what do you think of it?
12:10:31 * hpc doesn't know coq or agda enough to speak intelligently at length about hem
12:10:33 <clrnd> that's a big difference
12:10:35 <Cale> But yeah, coq has a whole additional language of tactics for trying to construct such terms
12:10:48 <clrnd> coq is far older too
12:10:55 <hpc> clrnd: it is, but like
12:10:57 <Cale> Welkin: I'm using it for work right now, and it's pretty great, if still a bit rough around the edges.
12:11:06 <Welkin> Cale: really? Tell me more
12:11:25 <hpc> clrnd: the tools exist in perl to write GUI applications, but it's not something you set out to do in perl
12:11:34 <brbblnch> But I read this coq tutorial (seems well liked here) and theorem proving was just giving a list of "hints" or "rules", not giving a function
12:11:35 <Welkin> I have never used ghcjs and am a bit put off by all the steps necessary to install it and get it working
12:11:53 <clrnd> hpc, those are libraries and extensions
12:12:11 <hpc> clrnd: doesn't really matter for this metaphor
12:12:22 <clrnd> agree
12:12:39 <geekosaur> ghcjs isn't trally "released" yet
12:12:40 <Cale> I'm working for Obsidian Systems, we're using Haskell for both the frontend and the backend of our web application. Currently, we're doing a Haskell version of lanehoney's (https://www.lanehoney.com/) web service.
12:12:43 <hpc> a better rephrasing would perhaps be "if all you need is theorems, there are better languages"?
12:13:06 <Cale> It's really nice to be able to share a bunch of code between the frontend and backend, especially data structures.
12:13:12 <Welkin> Cale: ah, that is why. You work for the author of reflex/reflex-dom
12:13:15 <Alpha64> i still don't get what you mean by theorem proving, other than things like "this list will never be empty" or small things like that
12:13:15 <Cale> yes :)
12:13:18 <clrnd> hpc, I agree with that, idris is not a theorem proving language at all, it just supports it if you want to
12:13:22 <Alpha64> what's an example ?
12:13:51 <clrnd> https://en.wikipedia.org/wiki/Automated_theorem_proving
12:14:18 <Cale> Welkin: Also, I worked with him before on a game (that sadly didn't get to the point where we could release it), where we developed an FRP system, and many of the ideas we took away from that about how FRP systems should behave are encoded in Reflex.
12:14:31 <clrnd> proving mathematical facts with computers, that's what we mean
12:14:32 <Welkin> Cale: how do you think it compares to Purescript with purescrupt-signal or Elm?
12:14:34 <chaosmasttter> brbblnch: those "hints" and "rules" generate the terms behind the scene
12:14:42 <Cale> Welkin: I haven't actually tried either of those.
12:15:23 <Welkin> Cale: I have been looking at different options for web front-end, and Elm, Purescript, and GHCJS (with reflex/reflex-dom) are the primary ones I am considering
12:15:41 <Cale> Welkin: Using GHCJS is also really nice because a *lot* of Haskell libraries build in it.
12:15:59 <brbblnch> chaosmasttter: So, what would be generated is a standard function of type "Fixpoint …" or the equivalent ?
12:16:05 <Cale> Welkin: For example, I've compiled all of diagrams before and used it to generate SVG in the frontend
12:16:33 <Cale> (not officially, yet, but we might do this in our application even, for some charts)
12:17:27 <Cale> Welkin: It's nice to have most of Hackage available in your frontend :P
12:18:52 <Welkin> Cale: one thing I am looking for is abstracting away the javascript semantics
12:19:41 <Cale> brbblnch: Yeah, well, "of type" is unfortunate wording there, but some term you could also write directly, yes. You can also ask coq to print the term it generated.
12:20:12 <Cale> Welkin: Yeah, I personally haven't had to think about javascript at all so far.
12:20:17 <brbblnch> oh, that's nice
12:20:52 <brbblnch> I must say that this "Software Foundations" tutorial was rather confusing for me. It seems like agda has less technicalities 
12:21:35 <Cale> Welkin: There's a bunch of foreign imported Javascript stuff (like we're using the Google Maps API for instance), which involves writing FFI declarations with snippets of Javascript in them.
12:22:18 <Cale> Welkin: But overall, it's extremely different from writing Javascript, or really imperative code of any kind.
12:23:32 <Cale> Welkin: Sometimes you might wish for a mutable reference that you can update, but you'll generally be forced to write something saner that explains how things change properly ;)
12:28:23 <NemesisD> anyone here pretty knowledgeable about linking? i'm trying to create a fully statically linked ghc executable. the idea was to create a build image in docker with alpine and ghc. it will compile and linke with musl there. would the executable i produce be portable to any system after that point?
12:28:30 <NemesisD> or rather any linux system
12:29:12 <clrnd> I just scheduled the first real haskell meetup for my city, yay!
12:29:21 <bitemyapp> clrnd: congrats :)
12:29:28 <mariusmarius> clrnd: very nice
12:40:07 <Corki_> Join #python !
12:40:23 <Ankhers> Why?
12:40:31 <clrnd> I no longer troll there
12:41:34 <Cale> clrnd: Which city?
12:41:42 <clrnd> Cale, Buenos Aires
12:41:45 <agocorona> NemesisD:  http://stackoverflow.com/questions/5953199/create-a-static-haskell-linux-executable
12:41:52 <Cale> cool :)
12:53:34 <platz> dysinger worked on docker+haskell a bit https://www.fpcomplete.com/blog/2015/05/haskell-web-server-in-5mb
12:53:57 <platz> https://github.com/fpco/haskell-scratch
12:54:01 * hackagebot haskell-neo4j-client 0.3.2.0 - A Haskell neo4j client  https://hackage.haskell.org/package/haskell-neo4j-client-0.3.2.0 (asilvestre)
13:04:59 <JamesJRH> Is there a lower-volume Haskell channel? This channel has about 4 times too many nicks in it for me.
13:05:23 <voidzero> #haskell.dut
13:05:31 <voidzero> i think 2 members
13:05:34 <voidzero> lambdabot is one of them
13:05:39 <JamesJRH> Lol.
13:05:55 <voidzero> 1522 nicks atm
13:06:14 <voidzero> but usually pretty ok to follow imo
13:08:53 <srhb> JamesJRH: Most of the other channels are usually topic-specific. Like some web framework, in depth discussion, beginners issues, ...
13:08:59 <koala_man> like all scalability problems, this one can be easily solved with sharding. just /ignore [a-m]*!*@*
13:09:07 <agocorona> JamesJRH:  I would like to find a haskell channel for real world programming
13:09:07 <srhb> :P
13:09:18 <srhb> This is such a channel. :-)
13:09:29 <agocorona> no IO -> no real programming -> no fun
13:09:39 <srhb> This is not an anti IO channel.
13:10:19 <voidzero> I wish there was a proper Dutch haskell community
13:10:25 <SrPx> When I use view patterns, will haskell memoize? For example, "f (view -> Bar a) = ...; f (view -> Foo a) = ...;" becomes "f view = case View of { Bar a -> ...; Foo a -> ... }", or "f view = case View of { Bar a -> ...; otherwise -> case View of { Foo a -> ...; ....}}" ?
13:10:34 <agocorona> srhb: no, at least not officially
13:10:47 <srhb> Not unofficially either. Where'd you get that idea. :P
13:11:18 <Ankhers> SrPx: That may be better served in a paste.
13:11:25 <SrPx> fair enough, a secon
13:11:27 <ralu> can someone report how long it takes for this command -> print $ sum [1,2 .. 200000000]  
13:11:52 <agocorona> srhb:  anty IO is in the body and soul of every misinformed functional programmer
13:11:52 <ralu> it takes 6s on my pc and i cant figure out why
13:11:59 <JamesJRH> I think that this channel looks more for me:
13:12:00 <JamesJRH> 20:06:01 -alis(alis@services.)- #haskell-in-depth                                   51 :Haskell in depth - slower paced discussion of use, 
13:12:03 <JamesJRH> theory, implementation etc with no monad tutorials!
13:12:25 <SrPx> http://lpaste.net/140491 Ankhers 
13:12:29 <srhb> agocorona: oook. Anyway, I'm not trying to convince you, mostly just serving as a counterpoint to your claim, so that others don't get that idea. :)
13:13:02 <ahihi> JamesJRH: it's kind of dead, though
13:13:07 <JamesJRH> Look, nearly a screen of scrollback since my previous comment. (While I was looking at Alis.) Way to high-volume for me.
13:13:26 <JamesJRH> ahihi: It has 50 nicks within it.
13:13:33 <ahihi> JamesJRH: sure, but almost no discussion
13:13:34 <JamesJRH> That's far from dead.
13:14:42 <SrPx> Also, would anyone suggest a lightweight and fast way to create a parser for a very simple grammar? A grammar with lambdas, strings, numbers and nothing else? 
13:15:14 <SrPx> I don't want to import Parsec because I guess it is a little heavyweight (I will compile to JS), but I'm not sure if that's covered by dead code elimination?
13:16:10 <JamesJRH> srhb: Yes, I saw on Alis that there are a lot of Haskell channels. That's why it took me a while to filter for one that looks hopeful. I think that it's a good thing that the community is that large though.
13:16:35 <Hijiri> SrPx: you could do list of successes parser
13:16:37 <srhb> JamesJRH: It really is. And good luck finding a fit. :) Sometimes it's quieter in here too, so you might hang around.
13:16:52 <SrPx> Hijiri: like how? Link?
13:17:21 <Hijiri> the data Parser a = Parser (String -> ([a], String)) that lots of tutorials use
13:17:41 <SrPx> Hmm makes sense, I'll think about it, thanks :)
13:17:46 <Hijiri> I don't know a specific link let me check some place
13:18:03 <JamesJRH> voidzero: Is #haskell.dut a region-specific channel?
13:18:28 <JamesJRH> I would have guessed Dutch, but that's nl.
13:18:41 <ralu> has anyone has is  why is this  code with my ghc and -O3 flag slower than eqivealent python3 version . again for me-> main = print $ sum [1,2 .. 200000000] 
13:18:43 <voidzero> i thought dutch
13:18:48 <Hijiri> SrPx: here is one https://www.seas.upenn.edu/~cis194/fall14/spring13/extras/10-applicative/AParser.hs
13:18:53 <Hijiri> using Maybe and not []
13:18:56 <voidzero> #haskell.nl is non existent, isn't it?
13:18:58 <Hijiri> and also my definition was wrong
13:19:01 <indiagreen> SrPx: can you use ReadP (which is already in base)? (sorry, I don't have context)
13:19:05 <SrPx> thanks! Hijiri 
13:19:27 <SrPx> indiagreen: interesting, probably. Thanks!
13:19:44 <Hijiri> oh yeah, I guess ReadP would do the same thing
13:19:48 <Hijiri> or be better
13:22:20 <Welkin> @src sum
13:22:20 <lambdabot> sum = foldl (+) 0
13:22:24 <Welkin> that is why ralu 
13:22:29 <Welkin> sum is implemented stupidly
13:22:57 <Welkin> > sum [1..1000000] -- lazy
13:22:59 <lambdabot>  *Exception: stack overflow
13:23:01 <ralu> so i need to to make tail recursive version?
13:23:02 <SrPx> I wasn't even aware of it, much less that it was in base...
13:23:09 <Welkin> > foldl1' (+) [1..1000000] -- strict
13:23:11 <lambdabot>  500000500000
13:23:15 <Welkin> no ralu
13:23:18 <Welkin> just use foldl'
13:23:20 <indiagreen> doesn't it have optimised specialised versions that get substituted when you use -O2? 
13:23:23 <indiagreen> hm
13:23:48 <Welkin> the same with product
13:23:50 <Welkin> @src product
13:23:50 <lambdabot> product = foldl (*) 1
13:24:48 <clrnd> GHC 8 is gonna be fantastic guise, GODAMNIT
13:24:55 <indiagreen> ralu: try using Int specifically
13:25:00 <voidzero> @src foldl'
13:25:00 <lambdabot> foldl' f a []     = a
13:25:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
13:25:00 <indiagreen> main = print (sum [1..200000000] :: Int)
13:25:06 <indiagreen> this works in 0.1s for me
13:25:32 <indiagreen> the default version uses Integer, and that takes 4s
13:25:40 <Welkin> indiagreen: perhaps -O2 replaces foldl with foldl'
13:25:52 <indiagreen> Welkin: it doesn't in general
13:25:59 <indiagreen> it can't
13:26:01 <JamesJRH> srhb: Quiet in here is still too much for me. Plus, even if it is sometimes manageable, I can't rely on the channel if I need help and come to ask a question but it's a rapid raging torrent that I have no chance of keeping up with. Filtering on Alis with ‘list * -topic *Haskell* -min 50 -max 300’ shows channels of a reasonable volume, that at least mention Haskell in the topicline.
13:26:20 <ralu> ok i see
13:26:22 <ralu> Int
13:26:24 <JamesJRH> srhb: But I will still hang around.
13:26:33 <voidzero> @src foldl1'
13:26:33 <lambdabot> Source not found. Wrong!  You cheating scum!
13:26:44 <srhb> JamesJRH: OK. Well, feel free to poke a privmsg at me if I can be of help, even if I'm not a guru :)
13:27:19 <Welkin> voidzero: foldl1 is a left fold that uses the first value in the input as the default accumulator value
13:27:22 <JamesJRH> voidzero: I didn't see one. Do you know if there's one for Britain?
13:27:32 <voidzero> is there some version of @src for ghci?
13:27:46 <Welkin> voidzero: src is often not correct anyway
13:27:51 <voidzero> oh :)
13:27:57 <Welkin> voidzero: rather, look up the documentation
13:28:10 <Welkin> using hoogle or hayoo
13:29:32 <voidzero> yeah.. although, I have :search, thanks to some tutorial from jakor
13:29:38 <absence> does anyone know if the role stuff that prevented "join" from being moved to Monad will be fixed for ghc 8.0?
13:29:55 <voidzero> but then again, hayoo is pretty nice too.
13:31:41 <JamesJRH> 20:09:57 < voidzero> I wish there was a proper Dutch haskell community  ← You're joking, right? I went to Utrecht, The Netherlands for a summer school on Applied Functional Programming, mainly Haskell. I gather that there's a concentration of functional programming and Haskell users there.
13:32:03 <JamesJRH> The Netherlands is one of my favourite countries.
13:32:20 <JamesJRH> I might move there one day.
13:32:32 <mariusmarius> JamesJRH: This is a longshot…but are you familiar with the ILLC at UvA?
13:32:44 <JamesJRH> Haskell and bikes! :-)
13:32:46 <hiptobecubic> I am
13:32:57 <JamesJRH> mariusmarius: No.
13:33:03 <mariusmarius> hiptobecubic: is this in reference to what I said
13:33:43 <zaquest> is there a way to dup/clone TBMChan/TBChan?
13:33:58 <hiptobecubic> yes
13:34:29 <hiptobecubic> mariusmarius, i took the software testing course by the author of "Haskell Road to Logic Math and Programming." It was pretty good, I thought.
13:36:53 <clrnd> did you know about #nothaskell? it's like politically correct #haskell
13:40:56 <mariusmarius> hiptobecubic: that is so cool. Do you know if there are many persons other than him that are interested in functional programming? I have a philosophy background, and want to go to a logic program…the ILLC would be in my top 3. I'm curious to hear your thoughts…feel free to PM me or reply here or in #haskell-blah
13:44:54 <voidzero> JamesJRH, that's nice, I didn't know that. Actually I meant I'd like to see a Dutch #haskell channel
13:45:09 <SrPx> Job done. I can't believe I actually did this in 30 minutes. That would be a few hours back on the js times... maybe learning Haskell actually paid out. I can go live now, thanks indiagreen and Hijiri.
13:47:24 <JamesJRH> voidzero: I can't find a regional Haskell channel that applies to me; there appears to be no Britain or Europe channel. However, I did also find this, which interests me:
13:47:27 <JamesJRH> 20:37:12 -alis(alis@services.)- #haskell-irc  15 :Discussion about IRC clients and bots written in Haskell - Try glirc: https://github.com/glguy/irc-core
13:48:30 <hiptobecubic> mariusmarius, there is a group at UvA that has a an in-house language that's used for studying parallelism, if I recall correctly. Jan van Eijck (the author) is across the street at CWI. I went to Utrect to take Advanced Functional Programming though. I do think there are more serious haskellers over there.
13:48:31 <JamesJRH> Other than that, I'll say what I had to say in #haskell-in-depth.
13:48:50 <JamesJRH> It's probably best suited anyway.
13:49:03 * hackagebot yesod-routes-flow 1.1 - Generate Flow routes for Yesod  https://hackage.haskell.org/package/yesod-routes-flow-1.1 (FelipeLessa)
13:51:04 <Cale> JamesJRH: Well, people usually talk about Haskell in English in #haskell already
13:51:36 <Cale> JamesJRH: I was of the understanding that most of the separate country channels are mainly based on language choice.
13:53:10 <voidzero> yeah i assume that's why there isn't a Dutch channel
13:53:17 <voidzero> as I understand it, most courses are in English
13:53:42 <mariusmarius> hiptobecubic: yeah I think Jan van Eijck teaches part time at the ILLC too. Ok that is good news. I don't have any concrete research interests yet, but I'm interested in the sort of things being done there.
13:54:03 * hackagebot magma 0.4.0.0 - magma is an algebraic structure consisting a set together with an binary operation.  https://hackage.haskell.org/package/magma-0.4.0.0 (KatsutoshiItoh)
13:56:20 <JamesJRH> clrnd: No way! ‘politically correct’ turns-out to be ‘don't ask questions’. The channel claims to be welcoming and accommodating, but the person who runs it is an intollerant illogical idiot who banned me without giving a constructive explaination why or giving a valid justifying argument that he himself was not breaking (i.e. he's also a hypocrite).
13:56:57 <clrnd> JamesJRH, jaja that just confirms mi prejudices :P
13:57:53 <clrnd> I think that being PC to the extreme is more censoring than having a picture of some boobs in a PPT
13:57:53 <JamesJRH> Cale: I see. I was thinking that it would be useful for reducing volume and also to talk about regional events and meetups.
13:58:33 <dolio> clrnd, JamesJRH I think that's enough talk about #nothaskell.
13:59:17 <clrnd> dolio, I thought *this* was the liberal channel
13:59:51 <Cale> JamesJRH: Well, there's no problem about starting one if there'll be a lot of regional-specific discussion of course.
14:00:27 <JamesJRH> clrnd: Oh, don't go to that channel expecting freedom of speech! However, I'm not saying be prejuced either; I actually like the channel, what it stands for, and its other channel operators. Just not the owner.
14:00:39 <indiagreen> guys guys please we already have a channel where they ask for preferred pronouns, we don't need another channel where they bash channels where they ask for preferred pronouns
14:00:44 <indiagreen> or else we'll need a 3rd channel
14:00:59 <clrnd> #notnothaskell
14:01:10 <JamesJRH> Cale: Indeed I may do that.
14:01:11 <clrnd> == #haskell, hey it's this channel
14:01:13 <dolio> This isn't a channel for bashing other channels.
14:01:24 <clrnd> okok sorry, I'll let it go :P
14:01:39 <mariusmarius> I thought this sort of talk belonged in #haskell-blah
14:01:55 <clrnd> #haskell-blah does not allow the word haskell
14:02:18 <mariusmarius> what about reverse "leksah"
14:02:21 <Rembane> #-blah?
14:02:47 <JamesJRH> I never bashed the channel, just the owner. He's an intollerant hypocrite that makes me out to be impolite while being somewhat abusive to me via PM.
14:03:04 <voidzero> enough with this
14:03:18 <dolio> This isn't a channel for bashing channel owners, either. Or other languages. Etc.
14:03:27 <clrnd> JamesJRH, let's procede in #haskell-blah
14:03:30 <JamesJRH> Sure, okay.
14:03:44 <JamesJRH> Just saying that it was a bad recommendation.
14:04:43 <hiptobecubic> mariusmarius, he's a nice guy. Just email him and ask him what he does. I doubt he'll remember me, but then again, he probably doesn't have a lot of black functional programmers with afros that have already used haskell come through his class, so who knows.
14:05:13 <JamesJRH> 20:26:22 < srhb> JamesJRH: OK. Well, feel free to poke a privmsg at me if I can be of help, even if I'm not a guru :)  ← I'll talk about it in #haskell-in-depth, as it is quite an in-depth topic that I want to talk about anyway.
14:06:09 <JamesJRH> srhb: You can join if you're interested. I'm going to ask about relational programming.
14:07:25 <JamesJRH> 20:32:10 < mariusmarius> JamesJRH: This is a longshot…but are you familiar with the ILLC at UvA?  ← No, what was it that you were going to say about it?
14:07:57 <mariusmarius> hiptobecubic: hahah ok. That sounds like a good idea. Thanks! :)
14:09:04 * hackagebot data-util 0.5 - utilities for handle data  https://hackage.haskell.org/package/data-util-0.5 (KatsutoshiItoh)
14:09:05 <mariusmarius> JamesJRH: Just that it is a cool place. It's composed of a bunch of professors from linguistics/mathematics/computer science/philosophy. It stands for Institute for Logic Language and Computation.
14:10:18 <mariusmarius> JamesJRH: I am interested in their masters program (I'm interested in their phd program as well, but you need a masters to enter it, and I only have a bachelors. And my research interests have changed since I initially became interested in it (from philosophical logic/formal semantics to…something else)
14:10:45 <mariusmarius> missing parens after "enter it"
14:12:17 <mariusmarius> JamesJRH: I was originally interested more in the logic/language part, and I had very little/no expertise in the computation part, whereas now, I am more interested in the computation part. So I'm self-studying and saving up money to pay for tuition.
14:13:53 <mariusmarius> JamesJRH: The reason why I'm interested in a place like the ILLC rather than somewhere else is because I'm interested in research being doing by logicians who haven't forgotten that they're philosophers. I don't think I would be very happy in a traditional cs program.
14:14:06 <mariusmarius> **being done
14:14:50 <JamesJRH> 20:59:29 < Cale> JamesJRH: Well, there's no problem about starting one if there'll be a lot of regional-specific discussion of course.  ← Okay, well I've just joined 2 empty channels, #Haskell-Europe and #Haskell-UK. Maybe others of geographic proximity will follow. I'd sure like to find more local Haskellers, the closer the better as it would be easier to meet-up.
14:15:26 <SrPx> > :t maybe
14:15:27 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:15:31 <SrPx> woops
14:15:32 <indiagreen> :t maybe
14:15:33 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:15:36 <SrPx> :t list
14:15:38 <lambdabot>     Not in scope: ‘list’
14:15:38 <lambdabot>     Perhaps you meant one of these:
14:15:38 <lambdabot>       ‘last’ (imported from Data.List),
14:15:51 <SrPx> Is there a "maybe" analogue for "List"?
14:15:55 <SrPx> indiagreen: (thanks)
14:16:03 <spaceloop> foldr?
14:16:06 <indiagreen> foldr, I guess
14:16:40 <IP92> has anyone got this https://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments to work properly?
14:17:28 <SrPx> oh... it is a fold? No, I meant just the match `list cons (x:xs) = cons x xs; list nil [] = nil`... although I guess laziness makes this irrelevant? 
14:18:04 <SrPx> (I'm just wondering what I do with the list returned by `readP_to_S parser string`... I guess I just return the first element, right?
14:18:07 <SrPx> )
14:18:23 <glguy> SrPx: I don't think base has a list analogue to maybe
14:18:39 <indiagreen> well, you can get something close with uncons
14:18:45 <indiagreen> and then maybe
14:19:04 * hackagebot RepLib 0.5.3.4 - Generic programming library with representation types  https://hackage.haskell.org/package/RepLib-0.5.3.4 (sweirich)
14:19:33 <JamesJRH> mariusmarius: Oh, it's in the Netherlands.
14:19:41 <SrPx> I'm currently doing this, "parseTerm = fst . head . readP_to_S term where ... {my parser}", looks wrong
14:19:50 <JamesJRH> mariusmarius: “by logicians who haven't forgotten that they're philosophers.”  ← Heh, yeah definitely.
14:20:31 <JamesJRH> mariusmarius: This reminds me of something that annoys me about an Xkcd...
14:20:31 <indiagreen> SrPx: it looks alright to me, tho I would've replaced head with matching on the result and throwing an error
14:20:51 <SrPx> Okay then!
14:22:28 <JamesJRH> mariusmarius: Xkcd 435 (https://xkcd.com/435/ ) – it annoys me that it completely forgets about philosophy.
14:23:09 <SrPx> Oh, there's listToMaybe for this. Okay
14:23:44 <SrPx> When I import just the functions I need from a lib, will it reduce build times?
14:23:55 <JamesJRH> mariusmarius: I sometimes think that there should be another comic where Xkcd 435 is entirely embedded within a think cloud of a philosopher. :-D
14:24:05 * hackagebot hslua 0.4.1 - A Lua language interpreter embedding in Haskell  https://hackage.haskell.org/package/hslua-0.4.1 (OmerAgacan)
14:24:13 <voidzero> JamesJRH, could you please move these kinds of conversations to #haskell-blah?
14:24:17 <mariusmarius> JamesJRH: lets continue this in #haskell-blah
14:27:42 <JamesJRH> Well I've joined, but actually I haven't much else to say. I'll stop getting distracted and, now that I've found #haskell-in-depth, I'll ask about relational programming there, which I think is probably the best channel for it.
14:28:53 <eitanChatav> Hey has anyone seen the following error happen and know how to deal with it? "schedule: re-entered unsafely.    Perhaps a 'foreign import unsafe' should be 'safe'?"
14:29:05 * hackagebot cblrepo 0.18.0 - Tool to maintain a database of CABAL packages and their dependencies  https://hackage.haskell.org/package/cblrepo-0.18.0 (MagnusTherning)
14:29:15 <johnw> eitanChatav: sounds like you tried to use a Haskell callback on the C side
14:29:27 <ReinH> eitanChatav: o/
14:29:52 <johnw> hiya ReinH!
14:29:59 <ReinH> johnw: hi!
14:30:17 <eitanChatav> I'm using a lot of "foreign export ccall"s
14:30:23 <eitanChatav> to expose Haskell functions
14:30:28 <eitanChatav> also hi :-)
14:30:34 <sinelaw> what's the dual of asum (or msum)?
14:31:29 <eitanChatav> The calling language is threaded (Rust)
14:31:41 <sinelaw> sequenceA_, I guess
14:32:57 <kristof> sinelaw: You mean something that starts with an Mplus/Alternative and generates a Traversable composed of those?
14:33:19 <sinelaw> kristof: no, sorry bad terminology
14:33:21 <kristof> sinelaw: That sounds like a generalized unfold over Mplus/Alternative
14:33:33 <sinelaw> kristof: I mean something that sums with the opposite meaning of <|>
14:33:34 <kristof> sinelaw: Oh, well, you still came up with an interesting idea :P
14:33:41 <kristof> sinelaw: Oh, like a "difference"
14:33:51 <sinelaw> heh
14:33:59 <geekosaur> eitanChatav, was the haskell library compiled with -threaded?
14:34:04 <sinelaw> kristof: like for Either, stops at first Left instead of at first Right
14:34:07 <eitanChatav> geekosaur: yes
14:34:28 <kristof> sinelaw: That's just an alternative definition of the Alternative instance for Either
14:34:37 <kristof> sinelaw: I mean, Left, Right, what's the difference?
14:34:41 <sinelaw> yip
14:34:50 <geekosaur> hm. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi-ghc.html#idp34320112 has a couple of things to watch out for, otherwise I suspect you're better off asking in #ghc
14:34:53 <sinelaw> I could just flip my left/right
14:34:55 <geekosaur> you may well be breaking new ground >.>
14:35:10 <eitanChatav> thanks!
14:35:40 <ReinH> eitanChatav: ooh, ffi with rust? fun
14:36:19 <eitanChatav> ReinH: yeah, having a lot of fun. Rust has a really nice thread management setup. 
14:36:24 <ReinH> yeah
14:36:27 <bitemyapp> @pl (\e -> logErr (show e) >> return Nothing)
14:36:27 <lambdabot> (>> return Nothing) . logErr . show
14:36:44 <bitemyapp> left to right or right to left?
14:36:59 <eitanChatav> geekosaur: would objdump tell me if I have linked with -threaded (objdump -t [libname] | grep 'thread')?
14:37:04 <bitemyapp> ¯\_(ツ)_/¯
14:37:29 <geekosaur> I don't know offhand (and if I did it would probably be OS X specific >.> )
14:38:03 <eitanChatav> geekosaur: Thank, I didn't figure. I just tried it and nothing came up. Mac OS X has an equivalent from brew in binutils called `gobjdump`
14:38:36 <indiagreen> bitemyapp: or “(Nothing <$) . logErr . show”, but that's not much better
14:39:06 * hackagebot peyotls-codec 0.2.0.0 - Codec parts of Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-codec-0.2.0.0 (YoshikuniJujo)
14:39:12 <geekosaur> I meant that what you'd be looking for stands a chance of being differemnt, not how you look for it
14:40:20 <geekosaur> (in general you can do with otool what you could do with objdump, or if you are lucky the objdump port will be sufficiently up to date n Mach-O format which has tended to be a problem, but I still don't know what specifically you'd look for)
14:44:06 * hackagebot peyotls 0.1.6.8 - Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-0.1.6.8 (YoshikuniJujo)
14:44:54 <SrPx> Is there anything very obviously wrong with this? http://lpaste.net/140492 i.e. did I use something that could make it slow?
14:46:22 <johnw> the choice . map char thing looks odd
14:46:34 <johnw> you can use satisfy or oneOf
14:47:54 <Cale> Yeah, probably satisfy will be much faster
14:48:03 <ryantrinkle> has anyone here worked with FunctionalWorks (hiring or being hired)?
14:49:06 * hackagebot cblrepo 0.18.1 - Tool to maintain a database of CABAL packages and their dependencies  https://hackage.haskell.org/package/cblrepo-0.18.1 (MagnusTherning)
14:54:06 <SrPx> Ah, makes sense. Changed. http://lpaste.net/140492 now lpaste magically asks me to use isDigit (!?) but I couldn't find that on the ReadP library
14:54:37 <mauke> @index isDigit
14:54:37 <lambdabot> Data.Char
14:55:06 <SrPx> ahhh I see :)
14:55:30 <SrPx> should've hoogled - is it all fine now?
14:57:08 <SrPx> (updated)
14:58:46 <Denommus> I wanted to write about SOMETHING about Haskell in my blog
14:58:53 <Denommus> but I can't think of anything worth writing
14:59:16 <johnw> just say it was fun ;)
14:59:53 <Denommus> johnw: I want to write something useful, to be honest
15:00:11 <Denommus> I wanted to say how LINQ is just a poor-man's MonadPlus, but someone else already did it
15:00:25 <johnw> ah
15:01:43 <koala_man> Denommus: are you aware of LINQ's AST functionality?
15:02:36 <Denommus> koala_man: no
15:03:19 <koala_man> monadic computation is just one possible evaluation mechanism backing linq. it's not used by linq-to-sql and friends. 
15:04:01 <Denommus> koala_man: in theory, I could get a MonadPlus-to-sql thing, I guess
15:05:35 <athan> Is there a safe `minimumByMaybe` anywhere? :(
15:06:42 <scshunt> athan: minimumByMaybe?
15:06:44 <Rembane> athan: What do you want to use it on? And what should it do?
15:07:50 <athan> Rembane: Right now, `minimumBy` is partial in that it expects the Foldable to have at least one element
15:08:24 <lpaste_> athan pasted “minimumByMaybe” at http://lpaste.net/140496
15:09:09 <athan> Rembane: I'd ideally just like to use it with the Monad instance of Maybe
15:09:12 <ReinH> I think a function nonEmpty :: [a] -> Maybe (NonEmpty a) might be useful in a lot of these scenarios.
15:09:17 <athan> scshunt: ^ sorry!
15:09:30 <athan> ReinH: I think you're right
15:10:07 <ReinH> Oh wait it exists.
15:10:16 <ReinH> then fmap (minimumBy foo) . nonEmpty
15:10:25 <athan> mer
15:10:32 <athan> thanks ReinH
15:11:13 <ReinH> ofc then you have to work with NonEmpty
15:12:21 <Denommus> koala_man: http://programmers.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern
15:12:29 <jle`> ReinH: is there no such function?
15:12:42 <jle`> oh, i didn't read on
15:19:12 <SrPx> What was that structure that offers fast concatenation of lists, that is not Data.Sequence?
15:20:17 <ReinH> SrPx: diff list?
15:20:22 <SrPx> That, ty
15:20:30 <ReinH> @hackage dlist
15:20:30 <lambdabot> http://hackage.haskell.org/package/dlist
15:20:46 <johnw> if you only need a diff list to accumulate, just use Endo
15:20:55 <johnw> or even just functions:
15:21:01 <johnw> ("foo" ++) . ("bar" ++) $ ""
15:21:21 <johnw> Endo will simply give you back a Monoid interface
15:23:08 <SrPx> I'm not sure I understand, instead of ` "(" ++ var ++ " → " ++ pretty body ++ ")" ` I use ("(" ++ var) . (" → " ++ pretty body) . ...) ?
15:23:33 <johnw> turn a ++ b into (a ++) . (b ++)
15:23:41 <johnw> and then "finish it off" at the end by applying it to []
15:23:43 <ReinH> SrPx: A diff list accumulates (str ++) via composition and th en eventually "evaluates" by applying
15:23:54 <ReinH> it replaces ++ with .
15:24:11 <johnw> well, ++ is still there, it's just deferred so we can reassociate it
15:24:22 <ReinH> yep
15:24:33 <ReinH> (I meant as the monoidal operation)
15:24:37 <johnw> ah, right
15:24:54 <SrPx> Hmm okay, and just doing that will fix the asymptotic  
15:25:35 * Peaker wonders why diff-list isn't a reassoc-monoid
15:26:04 <ReinH> yes, you get amortized O(1) appends with a final O(n) evaluation phase
15:26:44 <ReinH> Peaker: It might as well be. It's really just an encoding of a Monoid m as Endo (m -> m)
15:26:54 <johnw> ReinH: does it need to be O(n), if the segment is referenced by nothing else?
15:27:10 <Peaker> yeah, could be nicer to have ReassocLeft and ReassocRight as newtypes around a Monoid instance
15:27:20 <ReinH> johnw: hmm
15:27:30 <johnw> i.e., in ("foo" ++) . ("bar" ++) . ("baz" ++) $ "", it's safe to do it by directly modifying three cons cells, because there is no other reference
15:27:40 <johnw> I wonder if that happens....
15:28:02 <johnw> or if it would require too much high-level knowledge to be possible
15:28:06 <ReinH> "by modifying three cons cells" but you have to find the cons cells
15:28:46 <Peaker> I wonder if having the compiler automatically "unroll" linked lists to a constant like 4 would be feasible and a net-gain
15:28:47 <johnw> it's almost like i want unsafeAppend, which has the caveat that its first argument must never be referenced afterward
15:29:14 <ReinH> johnw: but you have to find the cons cell to mutate, which is linear anyway
15:29:18 <ReinH> so what do you get?
15:29:25 <johnw> oh yeah, duh
15:47:11 <jle`> i have type called `DumbError`, which is an error type for errors when trying to typecheck `DumbExpr` (untyped expressions) into `Expr` (typed expressions). ... i should probably take a step back and rethink some life choices
15:48:53 <Imagine> So I'm trying to implement a functional heap (for practice), that has two invariants (the regular heap invariant) and then the left side of any heap must be at most one bigger than the right side
15:49:02 <Imagine> I have insertion functions 
15:49:12 <Imagine> but now I'm working on the pop function
15:50:14 <Imagine> http://lpaste.net/140501
15:50:18 <jle`> Imagine: i suppose implementing a skew heap is too easy? :)
15:50:24 <Imagine> this is my current code, and I'm trying to figure out the siftdown function
15:51:04 <Imagine> I haven't ever really dealt with a skew heap, but I'm doing a regular heap because it was an interview question hahaha
15:51:15 <Imagine> and I was able to sorta figure it out, but now I'm really curious to see how I'd do it
15:51:58 <jle`> ah haha.  yeah, a skew heap is like a heap with the same operations and amortized asymptotics (i think?) but is much much simpler functional/persistent/pure implementation
15:52:48 <Imagine> gotcha
15:53:11 <Imagine> I might take a look at that after, but I want to be able to get this one working too
15:53:25 <jle`> you might be interested in Okasaki's "Purely Functional Data Structures"
15:53:33 <ReinH> +1
15:53:37 <ReinH> @where okasaki
15:53:38 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
15:53:40 <jle`> i think it contains a heap implementation too
15:53:49 <ReinH> much expanded in his book
15:54:00 <Imagine> ooh great thanks
15:54:17 <jle`> i feel bad for pushing your lpaste up the screen so much with my unrelated rambling so i'll try to help ^^
15:54:21 <Imagine> I will take a look
15:54:29 <Imagine> thanks!
15:54:37 <jle`> what is shiftDown trying to do?
15:55:40 <Imagine> siftdown is supposed to take a binary tree that doesn't necessarily follow the heap property (but only by one element), and "move" the element down until it follows the heap property
15:55:52 <Imagine> (I'm not sure of naming conventions)
15:56:45 <Imagine> So essentially it is supposed to swap the heads of the heaps/subheaps along a path until we get an actual heap
15:57:01 <Imagine> (Also, if anything is bad style/there is an easier way to do it, please let me know!)
15:57:22 <shersh> Hello everyone! Doen anyone know a good reason why RecordWildCards is not a part of language and are enables only by extension? I know they cah shadow names but you can shadow them withoud records so I don't see any meaning in not enabling this extension by default.
15:58:15 <geekosaur> because the language committee is extremely conservative and has okayed I think only one extension in the past several years
15:58:54 <geekosaur> (also the committee process kinda stalled, but is in the process of being rebooted with some hope that it will actually consider language changes)
15:59:59 <shersh> geekosaur: that clarifies a lot :)
16:02:46 <jle`> Imagine: i suppose you can pattern match on l and r because their constructors actually matter
16:02:57 <jle`> if they're both Nil then you're done
16:02:59 <jle`> if not, then...?
16:03:25 <Imagine> hmm okay yeah I can do it like that
16:07:43 <SrPx> That was kinda tricky... are you sure this is how I'm supposed to do it? It looks awful http://lpaste.net/140502
16:08:45 <johnw> SrPx: you can use functor fixpoints to get that "fold" for free, at the cost of uglier constructors (or using pattern synonyms)
16:09:09 <SrPx> really? show me the way 
16:09:29 <johnw> https://www.youtube.com/watch?v=Zw9KeP3OzpU
16:10:54 <jle`> SrPx: basically replace SugaredTerm with SugardTermF, and every time you use SugaredTerm in a constructor, use `f` instead
16:11:09 <jle`> then you can use `cata` from data-fix :D  or recursion-schemes
16:11:27 <jle`> but you should probably just watch the video
16:11:52 <SrPx> That makes sense. I'll watch it as I code
16:12:01 <SrPx> I'll also define (><) a b = (a ++) . (b ++) to make that whole code look better
16:12:05 <SrPx> thanks !
16:12:50 <johnw> SrPx: you won't be able to write (a >< b) >< c with that definition
16:13:05 <TheCrafter> Hello #haskell. I have a problem. I am trying to implement a kind of State-IO monad transformer. (I started learning about monad transformers today). I cannot find a way to make it work.
16:13:12 <catgocat> Hello, what happens when I download a package that exposes only an executable from cabal?
16:13:20 <TheCrafter> My code is here, it's nothing big. http://lpaste.net/4772323185481744384
16:13:20 <jle`> SrPx: alternatively, you can just always leave your "strings" as ("blah" ++) instead and never use normal strings
16:13:22 <SrPx> oh of course
16:13:26 <jle`> SrPx: then you can just use (.) for (++)
16:13:37 <Denommus> TheCrafter: do you need a State-IO monad transformer, or are you trying to learn how to do it?
16:13:38 <catgocat> I am currently downloading the tar file, unzipping it, cabal configure && cabal build && ./dist/build/package-name/package-name
16:13:39 <jle`> when you finally need a String you can apply the function to ""
16:13:54 <catgocat> Is there a better way to do it?
16:14:10 <ew000> hello, I'm writing a some code
16:14:25 <TheCrafter> Denommus, I'm trying to learn how to do it. I know I could just use the standard state-io transformer. Actually I'm following this article: https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md
16:14:30 <ew000> that transforms each node of a graph into a potentially exponential size graph
16:14:44 <TheCrafter> Denommus, in this article it was IO-Either monad transformer. Which is really easier -.-
16:14:49 <jle`> TheCrafter: as you're going now, it's impossible to write a MOnad instance
16:14:57 <ew000> the exponential graph is recursive
16:15:02 <ew000> and can be reused a lot
16:15:07 <ew000> so I'm trying to memoize it
16:15:08 <TheCrafter> jle`, great news :P why?
16:15:08 <jle`> TheCrafter: ...i think
16:15:25 <ew000> however, how do I control what is kept in memory and what is not?
16:15:35 <jle`> TheCrafter: what would work is data IOBot a = IOBot (BotState -> IO (BotState, a))
16:15:38 <TheCrafter> By the way, I'm trying to figure this out for the last 2.5 hours. My head hurts..
16:15:39 <jle`> you can write a Monad instance for that
16:16:51 <TheCrafter> jle`, well, I might try that!
16:16:58 <jle`> TheCrafter: think about how you'd write join :: IO (Bot (IO (Bot a))) -> IO (Bot a).  you'd ahve to write a Bot (IO a) -> IO (Bot a), essentially
16:17:07 <jle`> but is that possible?
16:17:59 <jle`> and if it is, is the resulting join/bind following the Monad laws?
16:18:17 <TheCrafter> The best I could do so far is reach a point that I need this: foo :: (a -> IO(Bot b)) -> (Bot a -> IO(Bot b))
16:18:53 <TheCrafter> And you're basically sayign to approach the problem from a different angle.
16:19:30 <TheCrafter> Well that might work but I can't be sure. I seriously lack the experience to know... I learned the basic haskell syntax 4 days ago... I managed to figure out how monads work just this morning :P
16:19:51 <jle`> if you have foo f x and you do fmap f x, you have a IO (Bot (IO (Bot b))), then you're reduced to the same problem I mentioned before
16:19:52 <TheCrafter> So, shifting my way of thinking entirely, is right now difficult!
16:20:22 <TheCrafter> Yeah so it's a dead end.
16:20:31 <jle`> BotState -> IO (BotState, a) is exactly how transformers the library does it, so it might be helpful to figure it out
16:20:48 <jle`> i mean, to approach from that angle
16:21:47 <jle`> besides, this is closer to what you actually *want*, right?
16:21:57 <jle`> you want to take a BotState to a new BotState and a result, where that process can do IO
16:22:19 <jle`> so you really want to be chaining "functions modifying a BotState and returning results that do IO in the process"
16:22:29 <jle`> which is literally a BotState -> IO (BotState, a)
16:23:05 <TheCrafter> " <jle`> so you really want to be chaining "functions modifying a BotState and returning results that do IO in the process" "
16:23:18 <TheCrafter> so shouldn't it be: BotState -> (BotState, IO a)
16:23:19 <TheCrafter> ?
16:23:50 <jle`> well, wouldn't you want to be able to do IO to determine the new BotState too?
16:24:27 <TheCrafter> give me a moment to parse all that.
16:24:30 <TheCrafter> tmi :P
16:24:37 <jle`> in most cases you would, expecially if you're talking about a chatbot
16:24:45 <TheCrafter> yeah, an irc bot
16:24:49 <jle`> your "new bot state" probably depends on IO
16:25:10 <TheCrafter> well all the fuss is because I need to do networking operators
16:25:16 <TheCrafter> while passing a Socket around
16:25:21 <TheCrafter> so yeah I guess you're right
16:25:59 <jle`> oh hm.  if your network operations don't affect the results, then you might not even need to use IO to find the result or the new state
16:26:22 <jle`> in that case your IO just comes in during the `runBot` function...not in the Bot itself
16:26:40 <jle`> runBot :: Bot a -> BotState -> IO (BotState, a), if you need to do IO to "prepare" and "clean up" after your running
16:27:01 <jle`> if you never need IO in your actual BotState -> (BotState, a), then you can get away with defining that instance, and just having a "smart runner"
16:27:11 <TheCrafter> yeah but what about something like reconnect? where I actually need to change the dataset (the socket)
16:27:45 <jle`> one way you can approach this is to have an IORef/MVar/passed recursive parameter that stores a BotState
16:28:07 <TheCrafter> okay totally lost you :D
16:28:17 <jle`> ah, have you ever used IORefs?
16:28:34 <TheCrafter> 4 days ago I had never used Haskell :P
16:29:08 <jle`> heh
16:29:30 <jle`> so, if your main chain is Message -> Bot Response, that's like, a function that takes a message and generates a response in return, using the BotState and modifying it
16:29:54 <TheCrafter> yeah something like that
16:30:06 <jle`> if you can make that your "callback", then what you can do is just store a BotState somewhere, like in the argument of a recursive function, or in an IORef
16:30:41 <jle`> and then your "main IO loop" would essentially be, receiving messages, running it through your `Message -> BotResponse Response`, sending the response, and updating the stored BotState
16:30:48 <jle`> er, `Message -> Bot Response`
16:31:08 <jle`> it all sort of depends on what your IRC interface/library is
16:31:09 <TheCrafter> uhm, I thought Haskell was supposd to be stateless and full pure or something
16:31:18 <TheCrafter> isn't what you just said a glimpse back to procedural?
16:31:39 <jle`> haskell isn't about statelessness, it's about getting rid of explicit state
16:31:42 <TheCrafter> oh, by the way I haven't used any other functional language before :D
16:31:49 <jle`> and only using state when it's needed :)
16:32:02 <jle`> i mean, getting rid of implicit state
16:32:29 <TheCrafter> how do you define explicit state?
16:32:29 <jle`> it's the ability to reason about things without state if you want to/don't need to, and having disciplined explicit state when you do
16:32:42 <jle`> your Bot type is "explicit state", for example
16:32:58 <jle`> when you have a computation `Bot a`, you know it can't launch missles or affect any global state, or modify weird state in weird ways
16:33:11 <jle`> you know that the state will always just be a BotState, and nothing else; that's all it can ever touch/modify
16:33:26 <TheCrafter> that's a good thing, right?
16:33:41 <jle`> mhm, it makes you be able to make stronger statements about your programs
16:33:46 <jle`> expands the scope of what you can reason about
16:33:52 <jle`> makes things much simpler to conceptualize
16:34:25 <TheCrafter> so implicit state should be when you're running a Java function that is supposed to add two integers together and at the same time, prints in the screen, starts 2 threads and destroys the world
16:34:26 <jle`> if your entire Bot's logic can be contained in a `Message -> Bot Response`, then that's a win.  now you know that, your bot's logic is entirely *that* function
16:34:45 <jle`> so you can say `myBot :: Message -> Bot Response`
16:35:01 <jle`> and you can tell the world "this is my bot's entire logic: a function taking a Message and returning a Bot Response"
16:35:26 <jle`> and the world knows that a `Bot Response` can only change some underlying BotState, and nothing else
16:35:38 <jle`> so you write your entire bot as a `myBot`, your entire bot logic
16:35:48 <jle`> you don't have to worry about IO or weird state or anything like that
16:36:02 <TheCrafter> yeah that might be the case when I only use my bot to Parse the message and answer something. But that puts limits..
16:36:17 <TheCrafter> For example I might want my bot to hold statistics for everyone who joins the channel or something
16:36:23 <jle`> now, to actually *run* your `myBot` and do useful things with it, you have to do some IO and potential IO-related stateful stuff to hook it up to your IRC library
16:36:43 <jle`> but the win of haskell is that you can separate the two parts of the logic
16:37:00 <jle`> your IO stuff doesn't have to worry about the logic of your bot; your bog doesn't ahve to worry about IO, and you can tell by the types that this is the case
16:37:11 <jle`> TheCrafter: well, then you'd do (Message, Room) -> Bot Response :)
16:37:21 <jle`> and your BotState would include things like, channel statistics
16:37:55 <jle`> or like, ChatEvent -> Bot Response
16:38:05 <jle`> where ChatEvent can be a Message, a Join, a Part, etc.
16:38:35 <jle`> Either Message JoinPart -> Bot Response, for instance...whatever you feel like
16:39:27 <TheCrafter> Well, in any case I guess I have to study more.
16:39:38 <jle`> now the trick is just to hook up your ChatEvent -> Bot Response to whatever IRC library you're using, using that library's functionality
16:39:48 <TheCrafter> The whole point anyway, is not to make the ultra-profitable-super-irc-bot :P I just want to learn!
16:39:57 <TheCrafter> I'm not using any library.
16:40:08 <jle`> well then, however you interface with mIRC :)
16:40:11 <jle`> er, IRC
16:40:25 <TheCrafter> yeah
16:40:37 <jle`> you'll benefit from having your entire bot logic as a `ChatEvent -> Bot Response`, doing no IO at all...and then the rest of the job is just to somehow hook that function to IRC
16:40:55 <TheCrafter> so, we told a lot. To sum it up: You think that my code is leading to a dead end right? I'll just change the whole design like you said
16:41:20 <TheCrafter> "  then the rest of the job is just to somehow hook that function "
16:41:34 <jle`> well the code you posted was an attempt to do something that, when done, might not be advisable
16:41:37 <TheCrafter> everytime I start a design with "somehow I WILL do that" I find myself crying in my bathtub
16:41:38 <TheCrafter> :P
16:42:15 <jle`> so if you write out IOBot like i mentioned, you *can* write IO-ful Bot logic.  but there's a good chance you might not need it
16:42:43 <jle`> and if your bot logic does involve IO, it *definitely* shouldn't involve network things involving IRC
16:42:49 <SrPx> What is the most expressible type system with type inference? Is it system-f?
16:42:51 <jle`> like connecting, disconnecting, etc.
16:43:11 <TheCrafter> well...the bot will need to send data at some point right?
16:43:18 <TheCrafter> I need my sweet little socket to do that!
16:43:23 <jle`> TheCrafter: yeah, but that's handled by the IO part of your library
16:43:28 <jle`> not by the bot logic
16:43:31 <jle`> s/library/project
16:44:25 <TheCrafter> so you're saying to use the IO-part to *dispatch* events to the Bot-part
16:44:35 <jle`> so when you design your IO interface/network interface to IRC, you design it with "all i need is a `ChatEvent -> Bot Response`, and this thing will work great.".   so just work on the network stuff, the sockets, etc., but ignore the parts involving the actual Bot logic
16:44:53 <jle`> yeah.  so then now when the IO part, say, receives a message, or receives a join/part
16:45:05 <jle`> it can just *call* the `ChatEvent -> Bot Response` function
16:45:17 <jle`> with that message/join/part that it received.  and then send the response in response
16:45:21 <Imagine> Okay -- I seem to have everything working. Now the problem is to see how everything could be made cleaner. (This is for a functional heap. What would you change to make it easier to read/mantain?) http://lpaste.net/140505
16:45:57 <Imagine> (if there is a website/better place for this than the irc please let me know!)
16:46:09 <TheCrafter> and that way I avoid all the monad-transformer headache
16:46:32 <jle`> anyways, i got to go, but good luck :)  my advice was mostly on how to separate IO from your bot's actual logic, which probably won't involve IO, and if it does, definitely not involve IO involving IRC
16:46:34 <TheCrafter> because even if I managed to create a StateIO (or use the standard one) , it may not be the right choice
16:46:39 <jle`> yeah
16:47:00 <jle`> create an IO interface that's able to react to messages/joins/parts/etc. somehow, and then have it call your `ChatEvent -> Bot Response` function when it gets a message/join/part
16:47:07 <jle`> and then have it send the Response that it gets
16:47:17 <TheCrafter> yeah got it! I'll mangage somehow (hopefully :P) 
16:47:31 <TheCrafter> its pretty simple idea really
16:47:40 <jle`> your IO interface might store the BotState in an IORef (which is basically a variable/container in IO), and take it out to run the function, and pop back in the modified version that the function returns
16:47:54 <TheCrafter> I guess I was blinded with the whole "Monads is the answer to everything" stuff I read about in Google results :P
16:48:13 <TheCrafter> I should really learn what an IORef is!
16:48:16 <jle`> haha.  yeah, it can sometimes seem that way with Haskell
16:48:23 <jle`> TheCrafter: luckily for you, GHC has great documentation for IORef :)
16:48:36 <TheCrafter> oh wait. so like my state monad or something?
16:48:43 <jle`> http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-IORef.html
16:48:45 <ew000> http://pastebin.com/2t2LLGxx
16:48:50 <TheCrafter> ioref keeps data through the chain of io operations?
16:48:53 <TheCrafter> that's cool.
16:49:00 <ew000> is my function fib2 more or less ok?
16:49:17 <jle`> TheCrafter: you can think of an IORef as like, a pointer to a container that you can read, modify, replace, etc. while in IO
16:49:20 <ew000> is there a simpler way to do it? I want that my memoizing structure to be explicit
16:49:28 <ew000> so I Can control bit
16:49:33 <jle`> anyways, good luck :)
16:50:07 <TheCrafter> so there is actually mutation but it doesn't hurt because it is contained within the IO-part.
16:50:20 <TheCrafter> sounds cool! I'll read about it and probably use it
16:50:39 <TheCrafter> I dont want to keep you any longer, you said you've got to go and you've already helped me more than enough!
16:50:40 <TheCrafter> Thanks :D
16:50:58 <TheCrafter> I got enough reading and thinking material for the next couple of days ^_^
16:56:34 <rdz_> has anyone had any luck installing hmatrix on Windows?
16:56:54 <TheCrafter> let me try it
16:57:19 <rdz_> https://github.com/albertoruiz/hmatrix/blob/master/INSTALL.md#windows
16:57:26 <rdz_> if you need the C libraries
16:57:56 <rdz_> I tried installing in a sandbox with: cabal install hmatrix --extra-lib-dirs=D:\gsl --extra-include-dirs=D:\gsl
16:58:17 <rdz_> but still getting told "* Missing C libraries: blas, lapack, blas, lapack"
16:58:25 <TheCrafter> okay wait a sec
17:00:29 <TheCrafter> yep. same problem.
17:01:17 <TheCrafter> I can't help more right now I need to sleep, its 3am here. Good luck!
17:02:43 <rdz_> TheCrafter: thanks, night!
17:02:58 <rdz_> if anyone else out there has any ideas, I found this SO post... http://stackoverflow.com/questions/32423225/how-to-build-hmatrix-with-blas-and-lapack-under-windows
17:03:12 <rdz_> it'd be good to see a response there in case others are having the same problem
17:14:39 <greg`> been flowing a tutorial using gloss
17:17:59 <tommd> greg`: How's it been going?
17:18:53 <tommd> greg`: Gloss is great fun.  You can actually get raw video from an input device, such as a web camera, all the way to gloss fairly painlessly these days.
17:21:56 <tommd> Stack failes for me after populating the index with "Invalid cabal path depricated: no slash"  does anyone know what this it talking about?
17:22:24 <Axman6> which version of stack?
17:22:44 <tommd> Axman6: 0.0.3
17:23:03 <Axman6> that's very old
17:23:08 <tommd> Oh, we're up to 9.9.9 now. OK
17:23:14 <Axman6> "very" - several versions behind
17:23:21 <Axman6> well, we're up to 0.1.4
17:28:39 <tommd> And stack requires the PCRE library to build.  Grrrrr....
17:36:31 <Enigmagic> tommd: why not just download a prebuilt one?
17:38:44 <tommd> Enigmagic: I can, it is just simplier with cabal where I can run `cabal install cabal` without too many extra deps (just zlib, right?)
17:40:09 <Enigmagic> tommd: do you build GHC from source too?
17:40:20 <flexfit> Is it possible to do multiple actions in a then statement? 
17:40:27 <tommd> Enigmagic: lol, that's usually my line.  I sometimes do ;-)
17:40:44 <Enigmagic> tommd: yeah, and i sometimes build stack but it's faster to just download it ;-)
17:41:07 <tommd> Enigmagic: It just interrupts flow, having to lookup a url instead of treating hackage as a big index.
17:41:12 <Welkin> flexfit: you mean `if ... then ... else ...`?
17:41:17 <flexfit> For example, if a condition is true, I want to append an element to a list. Then call that function again on that updated list. 
17:41:30 <Zekka> flexfit: You can put any value inside the then branch of if..then..else if it typechecks
17:41:36 <Welkin> flexfit: if-then-else is not idiomatic haskell
17:41:52 <flexfit> Welkin: What would be idiomatic haskell then?
17:41:54 <Welkin> flexfit: I recommend you use pattern guards instead
17:42:05 <Zekka> For some code you might be able to write something that looks like multiple actions
17:42:22 <Welkin> myFunction a | a > 5 = someFunction
17:42:58 <Welkin>               | otherwise = otherFunction
17:44:09 <Zekka> flexfit: Being clear, e.g. a do block with multiple actions in it is just a value representing all those actions joined together
17:44:17 <Welkin> flexfit: also, if you are just building a list, you can use a fold
17:44:23 <Zekka> Values representing groups of actions are allowed wherever other expressions are, if they have the right type
17:44:31 <flexfit> Welkin: I see what you're saying. Now that you mentioned it LYAH did mention guards.
17:44:50 <MarcelineVQ> I don't think he's after a do block zekka, sounds like he's just building lists and is still learniing about recursion
17:45:57 <flexfit> Welkin: I thought you use folds to accumulate and make lists smaller.
17:46:09 <Zekka> flexfit: You can also write folds that make lists bigger
17:46:24 <Zekka> foldr (\x xs -> x:x:xs) [] [1, 2, 3]
17:46:27 <Zekka> > foldr (\x xs -> x:x:xs) [] [1, 2, 3]
17:46:28 <lambdabot>  [1,1,2,2,3,3]
17:47:15 <Welkin> flexfit: a fold is just an abstraction over recursion
17:47:26 <Zekka> > foldr f z [a, b, c]
17:47:28 <lambdabot>  f a (f b (f c z))
17:47:48 <Welkin> it doesn't need to be lists, it can be anything that is an instance of Foldable (which you will learn about later)
17:47:54 <Zekka> compare (:) a ((:) b ((:) c []))
17:48:36 <Zekka> foldr on lists is like find-and-replace for (:) and []
17:49:25 <flexfit> wow. So many people left.
17:49:56 <geekosaur> that's usually a netsplit that didn't get detected as such
17:50:00 <MarcelineVQ> irc networks are made up of multiple servers, whatever server they were on hiccuped
17:50:07 <Zekka> Or maybe they just didn't like my answer to your question
17:54:15 * hackagebot handle-like 0.1.0.3 - HandleLike class  https://hackage.haskell.org/package/handle-like-0.1.0.3 (YoshikuniJujo)
17:54:36 <flexfit> so if I wanted to only include items in the list fulfill some condition, would I use a guard in my foldl?
17:55:03 <Welkin> I love the discussions that result from a netsplit :)
17:55:15 <Welkin> "You got disconnected in the netsplit!"
17:55:22 <Welkin> "No, you did! I stayed connected!"
17:55:25 <Welkin> who is right?
17:55:29 <MarcelineVQ> If you're working with one item per time, if you already have a list of things though you can use filter
17:55:31 <geekosaur> "mu"
17:55:31 <Welkin> neither and both!
17:55:58 <MarcelineVQ> > filter even [1..10]
17:56:00 <lambdabot>  [2,4,6,8,10]
17:56:09 <geekosaur> "server is not moving. client is not moving. network is moving"
17:56:14 <Welkin> you can use filter to simply "filter" the list
17:59:25 <MarcelineVQ> flexfit: If you have some code already and you want more specific opinions you can paste it in a pastebin like http://lpaste.net/ as far as I've seen that's usually the best way to go about things here because people can see what you're trying to do easier than you can explain it.
17:59:47 <MarcelineVQ> Obviously that doesn't apply if you don't have anything to show yet but I thought it was worth mentioning
17:59:56 <Welkin> @lpaste
17:59:57 <lambdabot> Haskell pastebin: http://lpaste.net/
18:00:37 <flexfit> darn, it looks like it's down.
18:00:46 <MarcelineVQ> hmm, works for me
18:01:01 <flexfit> now it's up for me
18:01:14 <Welkin> flexfit: you are shifting realities!
18:01:23 <Welkin> flexfit is caught in a time rift!
18:01:28 <Welkin> MarcelineVQ, what have you done!
18:01:46 <flexfit> http://lpaste.net/8556389827971383296
18:01:48 <MarcelineVQ> It's a netsplit cascade, the internet itself is cracking
18:01:50 <geekosaur> it will show the "down" thing even if the machine is just temporarily loaded (i.e. if the backend is slow to respond)
18:02:04 <flexfit> I'm trying to write my own version of nub
18:02:32 <flexfit> oh wait, it looks like it's creating the list backwards
18:02:47 <Welkin> flexfit: yes
18:02:52 <Welkin> you are using a left fold
18:03:04 <Welkin> use a right fold to create it forwards
18:03:17 <Welkin> > foldr (:) [] [1..10]
18:03:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
18:03:31 <merlin2> is there a shortcut for this? (replicateM 2 digit)
18:03:36 <merlin2> (parsec)
18:04:11 <Welkin> > foldr f a [x,y,z]
18:04:13 <lambdabot>  f x (f y (f z a))
18:04:16 <flexfit> The only thing though is that using a right fold counts the digits at the end as the first 
18:04:20 <Welkin> > foldl f a [x,y,z]
18:04:22 <lambdabot>  f (f (f a x) y) z
18:04:32 <Welkin> that is the difference between a left vs right fold
18:05:02 <dmj`> merlin2: (x,y) <- (,) <$> digit <*> digit ?
18:05:17 <dmj`> merlin2: otherwise just pattern match the list
18:05:49 <flexfit> and I wanted to start counting unique digits from the left
18:06:22 <merlin2> I don't actually need each separate digit. I am doing this, x <- replicateM 2 digit. but I could swear I remember seeing something like `ndigits 2' or similar
18:07:04 <divVerent> !pl \ f -> takeWhile (not . f)
18:07:35 <divVerent> @pl \ f -> takeWhile (not . f)
18:07:36 <lambdabot> takeWhile . (not .)
18:07:39 <divVerent> ah, right
18:08:15 <flexfit> Welkin: Is there a more elegant solution to this than simply using reverse? http://lpaste.net/7852135592245592064
18:08:48 <flexfit> Welkin: Using a right fold will count unique digits from the right, but I wanted to count the unique digits from the left
18:10:56 <flexfit> Or is there a way for me to get rid of the if statements completely in the fold?
18:12:18 <MarcelineVQ> there is, in the source code of nub, which I'm trying to decipher at the moment because it's quite interesting
18:12:36 <Welkin> you are implementing nub
18:12:46 <Welkin> @src nub
18:12:46 <lambdabot> nub = nubBy (==)
18:12:49 <Welkin> @src nubBy
18:12:49 <lambdabot> nubBy eq []     = []
18:12:49 <lambdabot> nubBy eq (x:xs) = x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:13:39 <Welkin> it looks like bumb just builds its list as it goes
18:13:42 <Welkin> nub*
18:13:47 <MarcelineVQ> take an x, remove x's from the rest of the list, repeat?
18:13:55 <Welkin> yeah
18:14:59 <merlin2> can someone suggest impromenets to this parsec code? http://lpaste.net/140506
18:17:48 <MarcelineVQ> I learned earlier you can replace repeated ++'s with compositons of ++ instead, idk if it's actually an improvement in a case like this one though. (x++) . (y++) etc. I guess the idea is that instead of walking each list for each extra concatenation, it organizes them together for one larger walk later.
18:18:28 <MarcelineVQ> Other than that I couldn't tell you, that's pretty simple looking code already so my intuition is if it works it's fine
18:19:03 <Cale> For a finite number of (++)'s like that, they'll already be associated the more efficient way, and it'll be fine
18:19:17 <Cale> You really only get into trouble with xs ++ ys when xs is long
18:19:45 <Cale> (and/or you're doing (++) repeatedly with potentially longer and longer left arguments)
18:20:25 <Welkin> although, is there still not a penalty for matching on the single element list?
18:20:33 <Cale> (++) is defined to associate to the right, so that'll be  x ++ ("-" ++ (y ++ ("-" ++ z)))
18:22:01 <Cale> What Marceline is referring to is the trick where for a function which is building up a list by many concatenations, in order to avoid the fact that xs ++ ys takes O(length xs) time, you can
18:22:08 <Cale> instead of constructing some list of type [a]
18:22:27 <Cale> you construct a function of type [a] -> [a] which adds elements to the beginning of whatever list it's given
18:22:35 <Cale> and instead of using the empty list []
18:22:43 <Cale> you use the identity function id
18:22:50 <glguy_> Specifically in the case that you're accumulating on the right
18:22:53 <Cale> and instead of using a singleton list [x]
18:23:11 <Cale> you use the function (x:) which adds x to the beginning of a list
18:23:12 <arkeet> this trick is called "difference lists"
18:23:21 <Cale> and then most importantly, instead of (++)
18:23:28 <Cale> you use function composition (.)
18:23:55 <Cale> and since function composition is always constant time (it immediately evaluates into a lambda and is done), you can asymptotically improve the time performance of your program
18:24:17 * hackagebot universe-base 1.0.2 - A class for finite and recursively enumerable types and some helper functions for enumerating them  https://hackage.haskell.org/package/universe-base-1.0.2 (DanielWagner)
18:24:27 <Cale> If you have constant lists xs, you can also replace them by (xs ++) as Marceline mentioned already
18:24:56 <Welkin> oh, difference lists
18:25:20 <Cale> I'm not sure why I never really like the term "difference lists", but I suppose I can't offer a better name
18:25:24 <Cale> liked*
18:25:44 <Cale> I tend to think of it as the "replacing lists with functions trick"
18:25:45 <jle`> i guess you're providing the deltas?  instead of the concretes?
18:26:06 <Cale> I mean, you're kind of providing deltas, but all the deltas are of a very specific kind
18:26:10 <ttt_fff> state monad is like that too
18:26:15 <Cale> You don't usually use all the functions [a] -> [a]
18:26:17 <ttt_fff> replacing state with functions that transforms the state
18:26:27 <Cale> just ones which add elements to the beginning of their argument
18:27:02 <arkeet> it's a practical application of Cayley's theorem (for monoids).
18:27:04 <jle`> maybe it is a difference w.r.t. something that can be considered a sum
18:27:15 <glguy> If your appends are already right associated it doesn't help, though
18:27:19 <Cale> jle`: I can't really see how :)
18:28:19 <Cale> Right, if everything already looks like xs ++ (ys ++ (zs ++ ws)), then that's already the best you'll ever do with lists.
18:28:27 <jle`> diffinitely
18:28:43 <Lokathor> the spec says that a number can be 0 to 1023
18:28:47 <Lokathor> this is 10 bits unsigned
18:29:06 <Lokathor> is there a way to, uh, "make a type", that's automatically like that?
18:29:22 <Lokathor> or should i use a Word16 and just check for overflows and stuff myself?
18:29:57 <jle`> Lokathor: V 10 Bool ?
18:30:04 <Cale> Lokathor: There's a way, but it's terrible. You're better off just making a smart constructor.
18:30:06 <glguy> also you can't peek at the list until you're done without paying the currently accumulated compose cost
18:30:19 <arkeet> jle`: sounds slow.
18:30:55 <merlin2> did I reinvent combine in here? http://lpaste.net/140506
18:31:06 <Lokathor> I could write an Int10 type maybe?
18:31:09 <arkeet> you can make a newtype wrapper around Word.
18:31:20 <arkeet> with its own Num instance or whatever that does everything mod 2^10.
18:31:23 <Welkin> Lokathor: bitvector, like what jle` suggested
18:31:39 <Welkin> except there is an actual bitvector library that uses Integer underneath
18:31:48 <arkeet> in fact, Word8 and Word16 and such already do this.
18:32:26 <arkeet> (well, not exactly that, they wrap an unboxed Word#.)
18:33:07 <Lokathor> Welkin, in the bv package?
18:33:48 <Welkin> arkeet's solutions sounds better though
18:33:49 <Welkin> :)
18:34:07 <Lokathor> yeah that's more what i was thinking
18:34:21 <Lokathor> Word10, i guess
18:34:34 <Welkin> Lokathor: yeah, I used the bv package for some crypto stuff I was playing with
18:34:46 <Welkin> it can get messy though
18:35:52 <merlin2> hmm, how can I parse at least X digits and at most Y digits?
18:38:02 <Welkin> at least would just be applying the digit parser the minimum number of times
18:38:35 <merlin2> yeah, but if the range is 5 to 10, and there are 10 characters, I want all 10
18:39:07 <Lokathor> apply it 5 times, then try to apply it up to 5 more times?
18:39:18 * hackagebot universe-base 1.0.2.1 - A class for finite and recursively enumerable types and some helper functions for enumerating them  https://hackage.haskell.org/package/universe-base-1.0.2.1 (DanielWagner)
18:40:02 <merlin2> with try?
18:41:55 <MarcelineVQ> idk how parser works, but isn't the idea to apply max times, if result isn't more than min, error?
18:41:57 <SrPx> Having many maybes, how do I get the first one that is a Just tersely ?
18:42:46 <Zekka> > msum [Just 1, Nothing, Just 4]
18:42:48 <lambdabot>  Just 1
18:42:55 <SrPx> I see... thanks :)
18:42:57 <merlin2> MarcelineVQ not in my case, it should be greedy I guess. it can't parse below minimum, but it should try to parse maximum times
18:42:59 <dmwit> > catMaybes [Just 1, Nothing, Just 4]
18:43:00 <lambdabot>  [1,4]
18:43:10 <dmwit> > foldMap First [Just 1, Nothing, Just 4]
18:43:11 <lambdabot>  First {getFirst = Just 1}
18:43:36 <Cale> > [x | Just x <- [Just 1, Nothing, Just 4], even x]
18:43:37 <lambdabot>  [4]
18:43:50 <merlin2> oh I have misread that. yes that would be an error
18:44:16 <dmwit> ?let ensure p x = x <$ guard (p x)
18:44:18 <lambdabot>  Defined.
18:44:36 <dmwit> > foldMap (First >=> ensure even) [Just 1, Nothing, Just 4]
18:44:38 <lambdabot>      Could not deduce (Alternative First) arising from a use of ‘ensure’
18:44:38 <lambdabot>      from the context (Integral a)
18:44:38 <lambdabot>        bound by the inferred type of it :: Integral a => First a
18:44:50 <dmwit> okay =(
18:46:09 <Lokathor> hmm
18:46:23 <dmwit> Alternative is in base, right? So why doesn't First have an Alternative instance?
18:46:24 <Lokathor> and similar to the above, if a list had to have at most 1023 characters in it
18:46:53 <Lokathor> perhaps some sort of newtype?
18:47:01 <Lokathor> or just careful accessors?
18:50:23 <Imagine> Is there anywhere I can go to have my relatively short (50 line) and simple code reviewed for style etc?
18:50:35 <dmwit> There's the code review StackExchange.
18:50:47 <dmwit> You could also put it on lpaste; probably people here will be willing to take a look.
18:50:50 <dmwit> ?paste
18:50:50 <lambdabot> Haskell pastebin: http://lpaste.net/
18:51:11 <Imagine> http://lpaste.net/140509
18:51:23 <Imagine> I checked StackExchange but it seemed to be not very active
18:51:42 <Imagine> I'm just trying to implement a functional heap as an exercise and it'd be nice if there were far easier ways of doing things
18:52:00 <jamiis> Is the Haskell Platform (somewhat) discouraged still? I installed the platform two years ago and I'm having odd problems now that I'm getting back into haskell. Thinking of starting anew. What is the recommended install process?
18:52:33 <dmwit> Imagine: This exchange? http://codereview.stackexchange.com/questions/tagged/haskell Looks like it has a post every few days, and answers to most requests.
18:52:34 <MarcelineVQ> the most common reccomendation​ I see these days is to use stack
18:52:44 <dmwit> Although I admit I don't go there very often. =)
18:52:51 <MarcelineVQ> instead of the platform
18:53:15 <MarcelineVQ> Some distros have up to date builds, but probably not many
18:53:33 <Imagine> dmwit - yeah I suppose that does work, but a few days for something short/that I'll probably be able to write something better by that point seems somewhat silly
18:54:21 <dmwit> `all id` = `and`
18:54:21 <jamiis> MarcelineVQ thanks \o/
18:54:22 <Imagine> I guess I'll try to see if anybody here has any comments and if not I can probably go talk to a professor/TA
18:54:32 <MarcelineVQ> jamiis: https://github.com/commercialhaskell/stack
18:54:37 <dmwit> `all id [x, y]` == `x && y`
18:54:46 <Imagine> ooh great
18:54:52 <Imagine> that makes it simpler
18:55:15 <merlin2> is there a floating point number parser in Parsec
18:55:56 <merlin2> hmm actually a regular one won't work, I need ',' as a decimal separator
18:56:16 <arkeet> can't you use , instead of && in guards?
18:56:17 <dmwit> merlin2: Have you looked at the pre-built language parser stuff?
18:56:32 <dmwit> arkeet: I don't think so. That's a comprehension thing.
18:56:48 <arkeet> > let x | True, True = 5 in x
18:56:50 <lambdabot>  5
18:56:55 <merlin2> dmwit, in Parsec? I am at hackage but I can't see it
18:57:02 <dmwit> arkeet: Huh!
18:57:03 <shachaf> It's part of PatternGuards, I think.
18:57:12 <Imagine> Wait what is that doing? 
18:57:23 <shachaf> > let f x | Just y <- x, Just z <- y = z in f (Just (Just 5))
18:57:25 <lambdabot>  5
18:57:29 <arkeet> it's saying x = 5 if True and True.
18:57:42 <dmwit> merlin2: http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Token.html
18:57:58 <Imagine> thats cool
18:58:00 <arkeet> I guess I mean you can write ... | lk >= k, k >= rk = Node blah blah
18:58:01 <Imagine> comma it is then!
18:58:05 <dmwit> merlin2: (and http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Language.html for instantiations to specific languages)
18:58:34 <merlin2> wow awesome
18:58:59 <arkeet> shachaf is correct, it requires PatternGuards
18:59:10 <dmwit> Imagine: Nothing else jumps out at me as particularly unidiomatic.
18:59:18 <arkeet> Imagine: so I guess stick with &&
18:59:22 <arkeet> anyway.
18:59:34 <Imagine> Okay!
18:59:44 <Imagine> I guess it just felt weird using 5 pattern guards 
19:00:14 <arkeet> the use of guards there looks ok to me.
19:00:31 <rdz_> with `STRef`... if I have `stx :: STRef a` and `sty :: STRef a`, and a function `g :: (a -> a -> a)`... then is there a way I can "merge" `stx` and `sty` using `g`?
19:01:00 <Imagine> okay great! thanks
19:01:12 <rdz_> that way anything with a pointer to `stx` and a pointer to `sty` now points to the merged `stxy`?
19:01:51 <isaac_rks> http://pastebin.com/YGZawzvT - anyone know why I get "Multiple declarations of empty" error from this?
19:02:02 <merlin2> dmwit am I missing something or there isn't a parser there that will parse "10,53" (comma seperator) into 10.53?
19:02:21 <dmwit> isaac_rks: Because both Tree and MyList have an Empty.
19:02:30 <roboguy`> rdz_: an STRef outside of ST?
19:02:30 <dmwit> isaac_rks: Put them in different modules, or name them differently.
19:02:43 <isaac_rks> ah so empty's not something built in
19:02:54 <rdz_> roboguy`: no, it's in ST
19:02:57 <dmwit> merlin2: I don't know. I haven't looked. But I figured *if* parsec had something for it, that's where it would be.
19:03:24 <roboguy`> rdz_: well, if those were 'ST a's, you could...
19:03:25 <rdz_> roboguy`: I have a `ST s (HashMap k (STRef s a))`
19:03:41 <roboguy`> depending on what you mean by merging
19:03:44 <dmwit> merlin2: At the very least, you ought to be able to steal code from that library and modify it to your tastes, if "." is not a configurable part of their float parser.
19:04:00 <rdz_> multiple keys might point to the same value
19:04:42 <dmwit> rdz_: You could write an operation of type `(a -> a -> a) -> STRef s a -> STRef s a -> ST s a` for which the result would dynamically apply `g` to the two input refs; would that be suitable?
19:05:02 <rdz_> if I find 2 key value pairs (k1,v1) and (k2,v2), I want to merge them (g v1 v2)
19:05:08 <dmwit> rdz_: oops, I meant the return type should be `ST s (ST s a)`, which is more interesting
19:05:24 <dmwit> rdz_: Since you can then pass around the resulting action and only use it when you want the merged value.
19:05:26 <rdz_> but I want any key that pointed previously to v1 or v2 to now point to the merged values
19:05:39 <dmwit> Oh. You want union-find.
19:05:43 <dmwit> There are packages for that on Hackage.
19:07:03 <dmwit> rdz_: You might like http://hackage.haskell.org/package/union-find-0.2/docs/Data-UnionFind-ST.html
19:07:40 <rdz_> dmwit: http://lpaste.net/140510
19:07:54 <rdz_> that's what I'm doing at the moment but it won't update any other references
19:08:09 <rdz_> I'll check out union-find
19:12:51 <Pamelloes> what's the two parameter version of (=<<)? i.e. (a -> b -> m c) -> m a -> m b -> m c
19:13:54 <rdz_> dmwit: is `Point s a` essentially `STRef s a` but where each reference has a layer of indirection and multiple references are treated as equivalence classes of the same value?
19:14:19 <rdz_> so `fresh` ~ `newSTRef` ?
19:14:34 <Cale> Pamelloes: I don't think it has a name, but \f x y -> join (liftM2 f x y)
19:15:37 <Pamelloes> Hm :/ I might as well just use do notation and bind the two values.
19:16:11 <rdz_> Pamelloes: what about just `ma >>= \a -> mb >>= \b -> g a b` ? It's basically just a one line version of the do notation
19:17:03 <Pamelloes> rdz_: Good idea! I'll see what ends up looking the nicest :)
19:18:53 <dmwit> rdz_: yes
19:19:14 <merlin2> "ma >>= \a -> mb >>= \b -> g a b" is just "liftA2 g a b" is it not?
19:19:21 <dmwit> merlin2: it is not
19:19:33 <Pamelloes> :t liftA2
19:19:34 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
19:19:36 <merlin2> are you nitpicking about liftA2 vs liftM2
19:19:39 <dmwit> merlin2: (liftA2 would use `return (g a b)`)
19:19:45 <Pamelloes> :t liftM2
19:19:46 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
19:19:56 <dmwit> merlin2: or `pure` or whatever; this is not a nitpick but an actual difference
19:20:14 <Pamelloes> Oh, I see what Cale was getting at :)
19:20:47 <dmwit> :t fmap (fmap join) liftA2
19:20:48 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f b)
19:20:48 <lambdabot>     Expected type: (a1 -> b -> a) -> f a1 -> f b -> f b -> a
19:20:48 <lambdabot>       Actual type: (a1 -> b -> a) -> f a1 -> f b -> f a
19:20:54 <rdz_> merlin2: join $ g <$> ma <*> mb
19:21:10 <rdz_> Applicative lacks join
19:21:12 <merlin2> hmm
19:21:29 <dmwit> oh, right
19:21:34 <dmwit> :t fmap (fmap (fmap join)) liftA2
19:21:35 <lambdabot> Monad m => (a1 -> b -> m a) -> m a1 -> m b -> m a
19:21:52 * dmwit wipes a tear from his eye
19:22:21 <merlin2> oh yeah I get it now
19:22:52 <Pamelloes> I think the applicative version is a winner as far as aesthetically pleasing goes :)
19:25:20 <rdz_> Pamelloes: though the point free `join . liftM2` isn't too bad either
19:25:35 <dmwit> rdz_: That's not the point-free version. =)
19:25:52 <dmwit> The point-free version is truly terrible.
19:25:55 <Pamelloes> rdz_: That won't work because litM2 has two args. The point free would be ((.).(.) join liftM2
19:26:00 <Pamelloes> *((.).(.))
19:26:01 <merlin2> :t ((join.).) . liftA2
19:26:01 <dmwit> But the pointful one that Cale suggested is quite fine.
19:26:02 <lambdabot> Monad m => (a1 -> b -> m a) -> m a1 -> m b -> m a
19:26:08 <rdz_> :t (join . liftM2)
19:26:09 <lambdabot> Monad m => (a1 -> a1 -> r) -> m a1 -> m r
19:26:15 <rdz_> oh
19:26:20 <dmwit> Pamelloes: s/two/three/, and the corresponding edits to your composition operator
19:26:21 <rdz_> I'll just let myself out
19:26:22 <rdz_> :P
19:26:25 <dmwit> Pamelloes: Same mistake I made. =)
19:26:28 <merlin2> it is not so bad. number of dots equals number of arguments :)
19:26:38 <merlin2> (the second function takes)
19:27:04 <Pamelloes> dmwit: Yep. I knew what I meant even if I wasn't able to communicate it effectively :D
19:29:02 <rdz_> dmwit: union-find means I have to set up an actual project and sandbox, haha, so I think it can wait till after some food
19:29:17 <rdz_> thanks for the help
19:29:20 * hackagebot peyotls-codec 0.3.0.0 - Codec parts of Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-codec-0.3.0.0 (YoshikuniJujo)
19:29:22 * hackagebot peyotls 0.1.6.9 - Pretty Easy YOshikuni-made TLS library  https://hackage.haskell.org/package/peyotls-0.1.6.9 (YoshikuniJujo)
19:29:44 <dmwit> rdz_: Just use cabal-no-reinstall. No need to make a project if you're still just playing around.
19:29:53 <merlin2> what is the boobs version of above? this doesn't work
19:29:54 <merlin2> :t ((.).(.)) join liftM2
19:29:55 <lambdabot>     Occurs check: cannot construct the infinite type: m ~ (->) (m a2)
19:29:56 <lambdabot>     Expected type: (a1 -> a2 -> a) -> m a1 -> m a2 -> m a2 -> a
19:29:56 <lambdabot>       Actual type: (a1 -> a2 -> a) -> m a1 -> m a2 -> m a
19:30:03 <dmwit> (cabal-no-reinstall means you don't need a sandbox)
19:30:11 <dmwit> :t ((.).(.).(.)) join liftM2
19:30:12 <lambdabot> Monad m => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
19:30:37 <merlin2> ah right
19:31:25 <Alpha64> total recall version
19:31:35 <rdz_> dmwit: how does that work? not used cabal-no-reinstall before
19:32:09 <dmwit> rdz_: http://blog.ezyang.com/2015/08/help-us-beta-test-no-reinstall-cabal/
19:32:39 <dmwit> I've been using it since it was announced and it's been a dream so far.
19:42:35 <jle`> Pamelloes: honestly to me, this is one of the situations where do notation clearly shines
19:42:45 <jle`> like, if there were situations that do notation was *invented for*, it's situations like these
19:43:02 <jle`> like, why even have it in the language at all if not for things like this
19:43:49 <rdz_> jle`: 3 lines of do notation always feels a bit short though! :P
19:44:21 <rdz_> for purely aesthetic reasons obviously
19:44:22 <Pamelloes> jle`: That's true. However, in this case the two parameters are record types built with big applicative statements, so I find it more aesthetically pleasing to keep using applicative notation rather than mix and match.
19:44:57 <merlin2> if I have a whole and fractional part of the decimal number as two integers how do I get a Double out of it?
19:45:07 <SrPx> What is a good name for a function that takes a term such as "((f x) y)" and return "(f x y)" ? I.e., removing redundant parens... (other than removeRedundantParens)
19:45:15 <dmwit> > 3 + (4 * 10^-2)
19:45:16 <lambdabot>      Not in scope: ‘^-’
19:45:17 <lambdabot>      Perhaps you meant one of these:
19:45:17 <lambdabot>        ‘-’ (imported from Prelude), ‘^’ (imported from Prelude),
19:45:19 <jle`> merlin2: fromInteger x + fromINteger x / 100
19:45:21 <Alpha64> merlin2 concat and read ?
19:45:23 <dmwit> > 3 + (4 * 10**(-2))
19:45:25 <lambdabot>  3.04
19:45:26 <rdz_> by the way - if anyone has had any luck installing `hmatrix` on Windows, could you respond to this SO post I found: http://stackoverflow.com/questions/32423225/how-to-build-hmatrix-with-blas-and-lapack-under-windows
19:45:30 <jle`> *fromInteger y
19:45:39 <merlin2> fractional part could have more than two digits
19:45:56 <dmwit> merlin2: You will of course need to know how many digits the fractional part had.
19:46:01 <dmwit> merlin2: (To handle leading zeros!)
19:46:44 <jle`> i don't know why i immediately thought about two digits
19:46:55 <dmwit> > (\whole frac numDigits -> fromInteger whole + fromInteger frac * 10**(-numDigits)) 3 4 2
19:46:57 <lambdabot>  3.04
19:47:13 <jle`> but apparently i wasn't alone too
19:47:14 <dmwit> :t \whole frac numDigits -> fromInteger whole + fromInteger frac * 10**(-numDigits)
19:47:15 <lambdabot> Floating a => Integer -> Integer -> a -> a
19:47:16 <jle`> some psychological thing?
19:47:26 <dmwit> oops, still got a `Floating a` in the input.
19:47:28 <SrPx> also, how do I make an infinite list like ['a' ... 'z', 'A' ... 'Z', 'aa' ... 'zz', 'ZZ' ... 'aaa' ...]
19:47:33 <dmwit> > (\whole frac numDigits -> fromInteger whole + fromInteger frac * 10**(-fromInteger numDigits)) 3 4 2
19:47:35 <lambdabot>  3.04
19:47:36 <merlin2> jle` yea. and I didn't think about leading zeroes
19:48:00 <roboguy`> SrPx: what about something like 'unLeftAssoc'?
19:48:09 <dmwit> SrPx: Ooo, I've done this one before, and it's surprisingly tricky!
19:48:12 <jle`> SrPx: concatMap (\x -> replicateM x listOfValidStrings) [1..]
19:48:32 <MarcelineVQ> SrPx: unbracket maybe, that's a pretty general name though I wouldn't let it escape into the wild
19:48:34 <Pamelloes> Is there a monad form of if? i.e. ifm :: m Bool -> m a -> m a -> m a
19:48:43 <dmwit> ?hackage monad-loops Pamelloes
19:48:43 <lambdabot> http://hackage.haskell.org/package/monad-loops Pamelloes
19:48:53 <jle`> > concatMap (\x -> replicateM x (['a'..'z'] ++ ["A".."Z"])) [1..]
19:48:55 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
19:48:55 <lambdabot>      In the expression: "A"
19:48:55 <lambdabot>      In the second argument of ‘(++)’, namely ‘["A" .. "Z"]’
19:48:56 <SrPx> MarcelineVQ, roboguy` good ones thanks :)
19:48:59 <dmwit> Oh, wait, that doesn't have ifM. Dang.
19:49:09 <jle`> > concatMap (\x -> replicateM x (['a'..'z'] ++ ['A'..'Z'])) [1..]
19:49:11 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
19:49:21 <jle`> > concatMap (\x -> replicateM x "ab") [1..]
19:49:23 <SrPx> > concatMap (\x -> replicateM x (['a'..'z'] ++ ['A'..'Z'])) [1..] !! 800
19:49:23 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
19:49:25 <lambdabot>  "ou"
19:50:29 <SrPx> ah
19:50:34 <SrPx> that's very neat
19:50:53 <SrPx> thank you
19:51:16 <jle`> np. you could probably also make it a little more readble using list comprehensions, perhaps
19:51:23 <jle`> > [replicateM x "ab" | x <- [1..] ]
19:51:25 <lambdabot>  [["a","b"],["aa","ab","ba","bb"],["aaa","aab","aba","abb","baa","bab","bba",...
19:51:33 <jle`> oops
19:51:42 <SrPx> concat, I get
19:51:48 <jle`> > [ y | x <- [1..], y <- replicateM x "ab" ]
19:51:50 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
19:51:52 <jle`> that's what i meant heh
19:51:54 <dmwit> > do { x <- [1..]; replicateM x "ab" }
19:51:57 <lambdabot>  ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb"...
19:53:05 <merlin2> > [replicate n x | n <- [1..], x <- "ab"]
19:53:06 <lambdabot>  ["a","b","aa","bb","aaa","bbb","aaaa","bbbb","aaaaa","bbbbb","aaaaaa","bbbbb...
19:55:06 <SrPx> amazing
19:56:03 <jle`> dmwit's do notation verson is surprisingly pleasant to red
19:56:05 <jle`> *read
19:56:59 <Pamelloes> What monad transformer do I need to add to my stack in order to satisfy MonadBaseControl IO?
19:57:06 <Pamelloes> (I already have MonadIO)
19:57:24 <dmj`> Pamelloes: MonadBase
19:57:42 <dmj`> Pamelloes: you can't derive MonadBaseControl IO instances though, since they contain type families
19:59:07 <Pamelloes> Hm, I think I'll just drop everything into IO, since I don't really need any special monads in this case.
20:01:10 <dmwit> There is no transformer you can add to your stack to satisfy MonadBaseControl IO.
20:01:16 <dmwit> The only way is for your base monad to be IO.
20:02:01 <Pamelloes> dmwit: Well, I'm in a MonadIO so the base monad is IO. The MonadBaseControlIO instance just didn't get derived.
20:02:21 <dmj`> Pamelloes: it's not deriveable
20:02:30 <Pamelloes> Then how do you get it?
20:02:51 <dmj`> Pamelloes: define an instance by hand
20:03:04 <dmwit> ...or use a stack containing only those transformers that already have instances.
20:03:39 <dmj`> dmwit: it sounds like he/she is newtyping though
20:03:53 <dmj`> could just use a typedef I suppose
20:04:04 <jle`> Pamelloes: MonadIO doesn't necessarily mean your base is IO
20:04:11 <Pamelloes> jle`: Really?
20:04:19 <jle`> yeah, it just means that your type implements liftIO
20:04:35 <Pamelloes> How can you implement liftIO without the base being IO?
20:04:37 <jle`> one way to get a MonadIO "for free" is to make a transformer over IO
20:04:46 <jle`> and put IO as the transformed monad
20:05:05 <jle`> but you can write a MonadIO instance without using monad transformers and a "base monad" (whatever that means)
20:05:20 <jle`> for example i can have a type data AskIO r a = AIO { r -> IO a }
20:05:26 <julianleviston> sanity check: I’m trying to import Network.Socket and GHCI is complaining with “could not find module"
20:05:28 <jle`> and write a MonadIO instance for that
20:05:29 <dmj`> Pamelloes: here's an example instance from snap 1.0
20:05:36 <dmj`> Pamelloes: http://lpaste.net/140511
20:05:40 <jle`> liftIO x = AIO $ \_ -> x
20:05:59 <dmj`> julianleviston: did you install the network package into your sandbox?
20:06:00 <jle`> there might not even be a monad transformer involved at all, or any sort of "stack"
20:06:09 <julianleviston> dmj`: I’m not in a sandbox
20:06:17 <Pamelloes> Hm... I wonder if that's what's going on in this case.
20:06:19 <dmj`> julianleviston: then do ghc-pkg list | grep network
20:06:21 <julianleviston> dmj`: I installed it globally tho
20:06:31 <jle`> Pamelloes: you can't derive it because you have to deal with it case-by-case for every MonadIO
20:06:39 <jle`> because every MonadIO can implement liftIO in a different way
20:06:49 <julianleviston> dmj`: ah - blank. 
20:07:11 <dmj`> julianleviston: I'd recommend sandboxes, or using stack / nix
20:07:23 <julianleviston> dmj`: I did stack install network-2.6.2.1
20:07:31 <Pamelloes> Well, I but the code that needed MonadBaseControl IO into a liftIO call, so now everything's working. I might come back and see if there's a MonadBaseControl IO instance that can be made, or if it's not possible at a later date.
20:07:36 <Pamelloes> *I put
20:07:51 <julianleviston> dmj`: ok I’ll go into a sandbox. I wish it was a bit easier.
20:08:26 <julianleviston> dmj`:  thanks
20:09:00 <julianleviston> dmj`: thanks for ghc-pkg - I didn’t know that even existed.
20:09:07 <julianleviston> dmj`: guess I should read the manual! :)
20:09:55 <glguy_> Cabal install network would have installed into the user database, but I'm guessing that's not what stack install does
20:13:26 <julianleviston> God
20:14:15 <julianleviston> stack might be easier than cabal is / was for package management, but it’s still pretty much impossible unless you know what’s going on
20:14:46 <julianleviston> makes me feel so stupid.
20:14:55 <scshunt> julianleviston: yeah :(
20:18:06 <lethjakman-l> if you enable Vi mode in haskeline is there a way to let backspace work as well?
20:19:23 * hackagebot keera-hails-reactivevalues 0.1.2.1 - Haskell on Rails - Reactive Values  https://hackage.haskell.org/package/keera-hails-reactivevalues-0.1.2.1 (IvanPerez)
20:20:21 <glguy_> There's not going to be much getting around understanding what you're doing when it comes to installing and building packages
20:32:56 <julianleviston> glguy: the problem isn’t the understanding, it’s the (lack of) discoverability about getting that understanding.
20:33:09 <julianleviston> glguy: but I’ll just suck it up and bash on it.
20:35:06 <julianleviston> glguy: for example… how can I install a package, and then make it available in a GHCI session? I’d expect it to be something like “stack new temp simple; cd simple; edit a file; stack ghci; import PACKAGENAME” 
20:35:58 <julianleviston> Ooh looks like I wrote myself a readme… I’ll read that ;-)
20:41:26 <ZeroElement> Gah. I was just helping my friend with an assignment from his Programming Languages class. It's some of the worst shit I've ever seen. They're using untyped Cons, and the professor is telling them that the list [1,2,3,4] has the structure 1:2:3:4. I.e. uncons has type [a] -> (a,[a]) OR [a] -> (a,a).
20:41:50 <ZeroElement> Conversely, cons is (a,a) -> [a] OR (a, [a]) -> [a]
20:42:30 <julianleviston> Sorry can someone help me? I did stack new temp, then edited extra-deps to include - network-2.6.2.1 and then tried stack build then stack ghci then import Network.Socket and it replies with Could not find module… It is a member of the hidden package ‘network-2.6.2.1’.
20:43:26 <julianleviston> I’m just trying to use Network.Socket in my code :)
20:45:43 <julianleviston> glguy: do you have any pointers for finding out how to work out how stack works?
20:49:25 * hackagebot yesod-pnotify 1.0.0 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-1.0.0 (KatsutoshiItoh)
20:51:22 <julianleviston> hm ok nevermind. Turns out I was editing the .yml file when I should have been editing the .cabal file. yay! 
20:54:40 <ZeroElement> Another great tidbit: a:Nil == a
20:54:41 <ZeroElement> wtf
20:55:01 <slack1256> Nil?
20:55:59 <ZeroElement> The thing that represents an empty list in my Friend's PL class's language
20:57:24 <julianleviston> ZeroElement: that’s so odd - sounds like they’ve applied John McCarthy’s original LISP paper to Haskell or something 
20:57:45 <ZeroElement> They're not using Haskell. They're using something called "L". But yeah, it's truly horrible
20:58:42 <julianleviston> ZeroElement: maybe it’s not horrible once you understand it
20:59:01 <slack1256> so they make the single list element jugdmentally equal to the single element?
20:59:04 <ZeroElement> I do understand it. It is very horrible
20:59:09 <slack1256> that doesn't seems too bad
20:59:10 <ZeroElement> Nothing has a sensible type
20:59:25 <ZeroElement> Really? cons doesn't have a consistent type, even structurally!
20:59:47 <Ralith> yeah, it sounds pretty dumb
20:59:49 <julianleviston> yeah, but if they’re programming in a lisp-like language, there are no types ordinarily, right?
21:00:13 <julianleviston> at least… the types aren’t explicit
21:00:25 <julianleviston> they’re dynamic
21:00:34 <Ralith> explicit types have been important in most of the lisp I've ever written
21:00:44 <chreekat> julianleviston: network is in stackage, so you don't need to add it to extra-deps
21:00:47 <julianleviston> Ralith: not talking about what’s possible.
21:00:51 <Ralith> neither am I
21:00:55 <chreekat> network-2.6.2.1, in particular
21:01:01 <Ralith> I'm talking about what's ordinary
21:01:21 <ZeroElement> julianleviston: But you can at least do consistent cons in Lisp
21:01:30 <julianleviston> Ralith: ah, my experience is different
21:01:31 <ZeroElement> i.e. it would have a reasonable type if List was typed
21:01:44 <julianleviston> ZeroElement: but list isn’t typed
21:01:46 <chreekat> julianleviston: stack still uses Cabal-the-library under the hood, and "stack ghci" relies on it heavily. To get network available in ghci, you have to add it to the *cabal* config file, your-package.cabal
21:02:02 <ZeroElement> julianleviston: I said "*If* lisp was typed
21:02:05 <julianleviston> chreekat: yeah, I worked that out after a while. Thanks :)
21:02:09 <julianleviston> ZeroElement: yep.
21:02:15 <chreekat> julianleviston: cool :)
21:02:32 <julianleviston> chreekat: now, however, it seems to be complaining at me for using Network… 
21:03:15 <julianleviston> chreekat: but I just realised why that is :)
21:03:19 <chreekat> julianleviston: what sort of complaint? did ... ah :)
21:03:39 <julianleviston> chreekat: I moved a source file and my editor wasn’t aware, and was saving over the old location ;-) silly mistakes.
21:03:51 <chreekat> haha
21:04:54 <julianleviston> chreekat: ah it’s saying this now Not in scope: ‘listenOn’ Perhaps you meant ‘listen’ (imported from Network.Socket)
21:05:11 <julianleviston> chreekat: my imports are import System.IO and import Network
21:06:21 <julianleviston> chreekat: because i have this: sock <- listenOn (PortNumber (fromIntegral port))
21:06:37 <julianleviston> chreekat: in hoogle, listenOn is clearly in Network.
21:07:27 <julianleviston> chreekat: I’m trying to do the “trivial example” in http://chimera.labs.oreilly.com/books/1230000000929/ch12.html#sec_server-trivial
21:07:33 <chreekat> The file abstraction is actually a real pain for tooling/editing. Renaming in particular. vim, for instance, loses all viminfo for a file that is moved. Persistent undo, gone. Similarly, git must be babied over file movings
21:07:56 <chreekat> s/is actually/can actaully be/
21:07:56 <julianleviston> trivial server.
21:08:30 <julianleviston> this book is reasonably frustrating because it doesn’t tell you the imports you need for the code to run ;-)
21:08:49 <julianleviston> otherwise it’s fantastic.
21:09:08 <chreekat> julianleviston: hmm, you've used "import" on the ghci prompt, yes? Does it work better/differently if you use :m + Network?
21:09:30 <dmwit> Network is the old non-hierarchical name.
21:09:30 <julianleviston> chreekat: oh I’m actually using :l start2.hs and I’ll paste my code one sec
21:09:41 <dmwit> You can use hoogle to find out what modern module you should import.
21:09:57 <dmwit> What is the function you need?
21:10:06 <chreekat> julianleviston: Oh, then you might only be get whatever start2 does or does not export
21:10:26 <julianleviston> here’s my code http://pastie.org/10406569
21:10:28 <dmwit> (reading scrollback now)
21:11:06 <julianleviston> chreekat: yeah, it’s just main. So I’m just running stack ghci, doing :l start2.hs and then main
21:11:52 <dmwit> julianleviston: That doesn't complain about `listenOn` for me.
21:12:04 <julianleviston> dmwit: hm… wonder what I’m doing.
21:12:07 <dmwit> It does complain about printf, forever, and forkFinally.
21:12:50 <chreekat> dmwit: vanilla ghci, or stack ghci? julianleviston is using the latter
21:12:57 <julianleviston> oh… my cabal has network should it have network-2.6.2.1 ?
21:13:06 <julianleviston> dmwit: yeah.
21:13:08 <dmwit> chreekat: vanilla
21:13:15 <julianleviston> dmwit: http://pastie.org/10406571
21:13:26 <julianleviston> in which case need network-2.6.2.1 ok. trying that
21:13:54 <chreekat> julianleviston: no, 
21:14:10 <julianleviston> hm. that doesn’t work
21:14:14 <chreekat> julianleviston: that's one of the main design points of stack: it picks the version for you
21:14:38 <julianleviston> So is import Network not correct?
21:14:53 <dmwit> import Network is fine
21:14:58 <chreekat> whether it should be Network or a different import because of deprecations isn't the issue, i don't think
21:15:13 <chreekat> I mean, isn't involved with why you can't call listenOn from ghci.
21:15:39 <woddy> impressive 1482 people
21:15:42 <julianleviston> ah ok
21:15:43 <woddy> and so little talk
21:15:57 <julianleviston> chreekat: it’s a bit odd?
21:16:04 <chreekat> Because of whatever combination of options stack ghci uses, it's more like actually importing a module, which means you don't have the entire namespace available *in the module's definition* available at the ghci prompt.
21:16:32 <julianleviston> chreekat: but I don’t want it at the prompt, do I? I just want it available in my start2.hs file
21:16:50 <julianleviston> Oh… it might not have imported it into the module that start2 has in it?
21:16:51 <julianleviston> god
21:17:01 <chreekat> julianleviston: maybe I'm confused. At what point do you get the complaint about listenOn not existing?
21:17:11 <julianleviston> chreekat: when I type main
21:17:20 <chreekat> but it compiles?
21:17:22 <dmwit> what
21:17:24 <julianleviston> chreekat: you can see in this what happens: http://pastie.org/10406571
21:17:34 <julianleviston> sorry
21:17:41 <dmwit> You did not type "main" there. =P
21:17:42 <julianleviston> when I do the load
21:17:48 <julianleviston> it doesn’t compile
21:17:49 <julianleviston> yes sorry
21:18:24 <chreekat> ohh it *doesn't* compile :P Ok oops. Um actually that seems odd. Can you also paste your cabal file and stack.yaml?
21:18:33 <julianleviston> chreekat: sure
21:18:42 <kadoban> julianleviston: It looks like you have at least some of the required imports commented out?
21:19:03 <julianleviston> kadoban:  no
21:19:09 <dmwit> kadoban: Definitely yes, but that doesn't explain the `listenOn` complaint (the one we're currently debugging).
21:19:18 <julianleviston> kadoban:  they’re just *my* refs for later
21:19:34 <dmwit> julianleviston: You definitely have some required imports commented out. But Network is not commented out.
21:19:43 <dmwit> So listenOn should be in scope.
21:19:46 <kadoban> Oh okay, carry on.
21:19:47 <julianleviston> kadoban: sorry I’m just trying to get Network working.
21:19:52 <julianleviston> kadoban: apologies.
21:20:02 <dmwit> I also checked that listenOn is available even in old versions of network (back to 2.0, the oldest one available on Hackage).
21:21:13 <julianleviston> Ok stack.yaml and test.cabal (my proj is called test): http://pastie.org/10406589
21:22:12 <julianleviston> dmwit: yeah, and it’s loading the latest package anyway… (Loading package network-2.6.2.1 ... linking ... done)
21:22:35 <julianleviston> dmwit: is it because I should be putting the code in Lib.hs or something?
21:23:21 <kadoban> Well, you probably should be putting your code there instead, but I don't think that'd be causing this, unless I'm missing something.
21:24:28 <chreekat> ah
21:24:38 <chreekat> julianleviston: you only list network under one dependency list; that of the test suite
21:24:51 <julianleviston> chreekat: oh god
21:24:56 <julianleviston> chreekat: lol thanks! I’ll change it
21:25:22 <chreekat> I made exactly that mistake earlier this week (well, not putting it under test, but you get the idea). Luckily I knew where to look for the problem :)
21:25:44 <kadoban> That also shouldn't matter, should it? It should give a different error if that was it I believe.
21:26:07 <julianleviston> chreekat: my mental pattern match on “the right place” was limited to just “build-depends”
21:26:40 <julianleviston> Ah… yeah, it didn’t fix it.
21:28:10 <chreekat> kadoban: yeah, in fact
21:28:58 <kadoban> julianleviston: So you're doing 'stack ghci' and then ':l start2.hs   I guess?
21:29:07 <julianleviston> kadoban: yep.
21:29:53 <chreekat> yeah, i can't get "Not in scope: ‘listenOn’" to happen to me
21:29:55 <kadoban> julianleviston: What if you ... just put that code in test/Spec.hs instead and try 'stack test' ? Just out of curiosity.
21:30:10 <kadoban> julianleviston: Also worth a shot: 'stack clean', maybe and then try again
21:30:16 <julianleviston> kadoban: I’ll try the clean
21:30:19 <chreekat> also, do you have anything like a .ghci scampering about?
21:31:12 <julianleviston> It’s weird because it seems to be acting as though it’s still got Network.Socket imported (used to be the case)
21:31:29 <julianleviston> oh my god
21:31:37 * chreekat holds his breath
21:32:05 <julianleviston> Ok 
21:32:12 <julianleviston> I *was* editing the wrong flipping file…. AGAIN
21:32:16 <julianleviston> good freaking god
21:32:22 <chreekat> lol
21:32:26 <julianleviston> seriously
21:33:02 <julianleviston> Yay different errors! :) woo thanks so much
21:33:21 <julianleviston> PEBKAS
21:34:09 <kadoban> You sit between the keyboard and the screen? O.o
21:34:27 * hackagebot yesod-pnotify 1.0.1 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-1.0.1 (KatsutoshiItoh)
21:35:36 <julianleviston> lol
21:35:58 <julianleviston> where is printf? lol. I hoogled it. It seems to be in Text.Printf is that right?
21:36:09 <kadoban> Sounds right
21:36:11 <julianleviston> Isn’t there a standard Text package?
21:36:12 <julianleviston> ah ok
21:36:12 <julianleviston> thanks
21:36:54 <julianleviston> heh. apparently hoogle can’t see Control.Concurrent
21:37:20 <kadoban> hackage's hoogle is pretty terrible at that. I usually use the one at stackage.org, or there's hayoo
21:37:24 <chreekat> julianleviston: since you're using stack, the search on stackage.org is a good resource. E.g. https://www.stackage.org/lts-3.4/hoogle?q=control.concurrent
21:37:52 <julianleviston> oh… there are two hoogles?
21:37:55 <chreekat> you may want to adjust to your version of lts, which was lts-2.19 judging by your stack.yaml
21:38:15 <julianleviston> chreekat: how come? is 2.19 bad?
21:38:30 <kadoban> He just means adjust the URL above so it matches.
21:38:39 <julianleviston> kadoban: ahhh gotcha. 
21:38:43 <julianleviston> chreekat: thanks!
21:38:55 <julianleviston> oh maybe my stack is out of date
21:39:01 <kadoban> Although lts-3.x has GHC 7.10, which is nice, but it doesn't matter much.
21:39:02 <chreekat> julianleviston: Yes; the one on stackage searches the packages distributed through stackage, and the one on haskell.org searches hackage
21:39:10 <julianleviston> God this language is so freaking awesome...
21:39:29 <chreekat> agreed on 2.19 not mattering
21:39:36 <dmwit> hoogle beta is pretty good, though it only does name search (not type search)
21:39:54 <julianleviston> I wish the whole world would get behind stack tho. I guess it’s slowly happening
21:40:09 <dmwit> Why do you wish that?
21:40:16 <kadoban> It's quite new, but lots of people seem to like it so far.
21:40:44 <julianleviston> dmwit: because it makes doing the little things you do all the time easier
21:41:06 <julianleviston> dmwit: and also, it’d be less details to remember… for example - two hoogles.
21:41:36 <dmwit> Hoogle is completely orthogonal to what build tool you use.
21:41:45 <julianleviston> look at that. The example code ran! thanks so much.
21:41:50 <slack1256> also, nix 4 ever
21:41:53 <julianleviston> dmwit: how come there are two then?
21:42:06 <dmwit> Why shouldn't there be two?
21:42:38 <dmwit> (It's not like one is for cabal-install and the other is for stack!)
21:42:51 <julianleviston> dmwit: ah, i’ve misunderstood then. Apologies.
21:42:52 <dmwit> You can have a local instance of Hoogle on your own machine if you want.
21:42:54 <dmwit> Nothing against that.
21:43:18 <chreekat> julianleviston: stack and stackage are separate ideas. stackage is a set of packages, originally shared via hackage, that are known to work together. stackage's hoogle thus only shows documentation for the particular version that is included. Haskell.org's hoogle has all versions, and defaults to the most recent. And yeah, Hoogle is just a tool that searches a package database, wherever that database may be
21:43:37 <shachaf> There are two Hoogles, but each of them says as a matter of policy that there's only one Hoogle.
21:43:50 <julianleviston> gotcha
21:43:56 <chreekat> To be more clear, Hackage has many versions, defaulting to the most recent, and Haskell.org's hoogle searches that
21:45:06 <chreekat> Policy may be a strong term, but it's certainly true there aren't links between the two that I can see :P
21:47:04 <kadoban> "haskell.org's hoogle has all versions ..." and doesn't search any of them :-/
21:48:26 <chreekat> heh
21:48:55 <chreekat> Control.Concurrent is... back? If it was gone? http://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Concurrent.html
21:49:36 <julianleviston> Um… yes?
21:49:44 <julianleviston> I don’t know? :) haha not sure if you were asking me
21:50:59 <chreekat> ¯\_(ツ)_/¯
21:51:39 <julianleviston> when you call forkFinally, does it create a ‘spark’ ?
21:51:59 <julianleviston> it’s not a green thread is it?
21:52:02 <dmwit> No, sparks are for parallelism. fork creates a green thread.
21:52:18 <dmwit> ...assuming forkFinally is a forkIO variant.
21:52:44 <julianleviston> ah
21:52:50 <SrPx> Anyone remembers the paper that proposed the type system used by Morte?
21:52:53 <dmwit> There's also a fork system call, which does something else. =P
21:52:55 <julianleviston> I just read “Sparks are not threads. GHC supports sparks, which are unevaluated computations in a queue, Haskell (lightweight threads) and OS threads"
21:53:22 <julianleviston> cool...
21:53:53 <dmwit> Roughly speaking, sparks are for evaluating things in parallel, and threads are for executing things concurrently.
21:54:09 <dmwit> Be careful about the distinction between evaluation and execution.
21:54:19 <julianleviston> was it Automatic synthesis of typed Λ-programs on term algebras ?
21:54:31 <julianleviston> SrPx: sorry - was it “Automatic synthesis of typed Λ-programs on term algebras”?
21:55:05 <julianleviston> dmwit: yeah, it’s cool, I just got my nomenclature confused. :)
21:55:18 <julianleviston> dmwit: I actually meant green thread, not spark
21:55:35 <dmwit> ok
21:55:44 <Arahael> And curiously, fork - the system call, is /not/ threadsafe.
21:56:03 <julianleviston> dmwit: and when I said “green thread” I actually meant OS thread. lol
21:56:10 <julianleviston> I never understood why they were called greent.
21:56:12 <julianleviston> green*
21:56:23 <SrPx> julianleviston: uhm doesn't look like what I recall, but could be
21:57:03 <darkf> is there a flag to get GHC to dump the options it passes to the linker?
21:57:07 <dmwit> julianleviston: You understand the implementation, but not the name? Or you are curious about the implementation?
21:57:27 <julianleviston> dmwit: I don’t know why they are named green.
21:57:31 <dmwit> julianleviston: If the name, I guess it's an allusion to "green" as in "eco-friendly" (which usually means "using less resources").
21:57:49 <julianleviston> dmwit: oh. ok.
21:58:39 <julianleviston> be back later. thanks all for being awesome! :)
21:59:28 <Axman6> darkf: -v should show you that
21:59:57 <darkf> Axman6: thanks :)
22:08:24 <flippant> the name green thread comes from java
22:08:27 <flippant> not sure why though
22:08:37 <flippant> why it's green, i mean
22:08:54 <Arahael> I thought it predated java?
22:10:39 <bob_twinkles> I think they're called "green" because they use less resources than full OS threads (so green like "green power" from environmentally friendly power sources)
22:11:20 <jle`> will the new GHC mean that GHC will stop warning me about incomplete patterns and then not compile when i put in the pattern they suggested?
22:11:31 <dmwit> bob_twinkles: Well, if it's just a hallucination, at least it's a mass hallucination.
22:11:41 <flippant> https://en.wikipedia.org/wiki/Green_threads
22:11:44 <flippant> just looked it up
22:12:40 <flippant> >Green threads refers to the name of the Java thread library. The Green Team is the name of the team at Sun Microsystems that designed the Java thread library
22:13:10 <bob_twinkles> oh huh. I think my proposal works better for marketing though =P
22:13:22 <jle`> does ghc have marlow threads?
22:13:49 <flippant> bob_twinkles: :D
22:15:01 <Axman6> jle`: it so should
22:20:36 <flippant> i tried looking up marlow threads
22:20:49 <flippant> and all i see are results for beauty salons
22:21:51 <julianleviston> Henk: a typed intermediate language: http://research.microsoft.com/en-us/um/people/simonpj/papers/henk.ps.gz
22:22:01 <julianleviston> I forget who was asking before.
22:22:08 <flippant> wb julianleviston
22:22:19 <julianleviston> flippant: ‘lo :)
22:30:35 <julianleviston> Can I read this as “A function which takes some a-typed value (in an IO monad), and a function from an Either someException of type a to an IO that returns unit, and then returns an IO wrapped ThreadId ?
22:30:37 <julianleviston> forkFinally :: IO a -> (Either SomeException a -> IO ()) -> IO ThreadId
22:32:18 <liste> I'd call "a-typed value (in an IO monad)" an "IO action that yields a"
22:32:25 <julianleviston> Does Either SomeException a mean the Left value will be of type SomeException, and the rigth will be of type a?
22:32:36 <julianleviston> liste: sure.
22:32:40 <liste> julianleviston yeah
22:33:41 <julianleviston> so you can pass that whole chunk (\_ -> hClose handle) for example, and it’s fine…
22:34:08 <liste> yeah
22:34:19 <julianleviston> by the way if I write \_ -> 7, can I read that as “lamda from thunk to 7”?
22:34:33 <julianleviston> (ie do you read pattern match anything as thunk?)
22:35:36 <liste> I wouldn't, it could also be an evaluated value
22:35:50 <kadoban> julianleviston: I suspect you're somewhat confusingly mixing levels of abstraction doing that.
22:35:57 <julianleviston> liste:  I mean how do you read the _ char in \_ -> 1 + 3 when you’re reading it aloud?
22:36:04 <julianleviston> kadoban: could be!
22:36:06 <liste> "underscore" or "don't care"
22:36:15 <julianleviston> liste:  aha. thanks
22:36:24 <julianleviston> liste:  so… IO () means “a value of unit wrapped in a monad”?
22:36:35 <julianleviston> or does IO () mean “a monadc action returning unit”?
22:36:41 <liste> the latter
22:36:46 <julianleviston> ok :)
22:36:53 <liste> actually "IO action returning unit"
22:37:00 <liste> IO just happens to be a monadf
22:37:01 <kadoban> It means an IO action resulting in ()
22:37:07 <julianleviston> yep sorry :)
22:37:16 <kadoban> () is just a type, nothing too special ... only it only has one value, also called ()
22:37:24 <julianleviston> it’s actually lifting () into the IO monad?
22:37:32 <julianleviston> is that what return does?
22:37:39 <liste> julianleviston no, "return ()" would be that
22:37:54 <julianleviston> liste: isn’t that what the IO () will do?
22:38:08 <kadoban> julianleviston: It doesn't do anythnig in particular? It's just a type.
22:38:12 <liste> julianleviston "IO ()" can be other things too
22:38:21 <liste> :t putStrLn "hello world"
22:38:22 <lambdabot> IO ()
22:38:26 <julianleviston> kadoban: no, sorry I mean “the thing you pass in as the argument for a function which takes that type"
22:39:13 <kadoban> Oh, yeah you can't tell what an IO action will do at all really. It could be "return ()" or it could be "fireTheMissiles"
22:39:25 <kadoban> That's kind of the whole point of IO.
22:39:31 <julianleviston> kadoban:  i’m talking about the end result only.
22:40:28 <kadoban> Ah, then yeah the end result has to be something equivalent to "return ()", or bottom (undefined, infinite loop, error, whatever)
22:41:34 <julianleviston> cool
22:42:05 <glguy> "A function that takes that type"? Like: twice :: IO () -> IO (); twice m = m >> m
22:58:36 <paldepind> Data.Aeson has a type `Value` where one of the value constructors `Number` that takes a `Scientific`. How come I can do "Number 12"? How is the number literal turned into a Scientific?
22:58:36 <paldepind> It must be some kind of overloading/coercion but I can't figure out how it works.
22:59:05 <glguy> Numeric literals over overloaded via the "Num" class
22:59:07 <opqdonut> :t 12
22:59:08 <lambdabot> Num a => a
22:59:32 <glguy> when you write 12 that's compiled to a call to the "fromInteger" function with an Integer literal 12
23:00:37 <paldepind> :t fromInteger
23:00:39 <lambdabot> Num a => Integer -> a
23:01:38 <paldepind> But the `Number` constructor mentioned above takes a Scientific. Not a member of the Num class?
23:02:01 <paldepind> It has type: Data.Scientific.Scientific -> Value
23:02:08 <opqdonut> https://hackage.haskell.org/package/scientific-0.3.3.8/docs/Data-Scientific.html#t:Scientific
23:02:16 <glguy> Scientific *is* an instance of the Num typeclass
23:02:18 <opqdonut> look at Instances, it says Num Scientific
23:03:43 <glguy> When you use 12, which as a type Num a => a, where a Scientific is needed the a unifies with Scientific and you get a Num Scientific constraint
23:03:45 <paldepind> There is something I'm missing. I though that when a function declares that one of it's arguments must be of a specific typeclass I can pass it anything of that typeclass. But when a function wants a value of a specific type I can only pass it that specific type.
23:04:07 <opqdonut> paldepind: yes
23:04:17 <opqdonut> paldepind: however, the value 12 itself is polymorphic
23:04:34 <opqdonut> paldepind: it has type Num a => a, which means it can get "interpreted" as any type in the Num class
23:05:43 <glguy> :t 12 :: Data.Scientific.Scientific
23:05:44 <lambdabot> Data.Scientific.Scientific
23:06:05 <glguy> Scientific is a valid type for 12, so it fits in that constructor
23:06:47 <paldepind> opqdonut, ok. I that makes sense. It's not the function that is polymorphic. It is the literal. But how does this interpretation happen? I guess what I don't understand is the type of `fromInteger` how can it take something specific (an Integer) and return something more general?
23:07:15 <opqdonut> fromInteger is part of the Num class
23:07:44 <opqdonut> so for each type "X" in the Num class, a definition has been written for fromInteger :: Integer -> X
23:08:11 <paldepind> opqdonut, ahhh! Now I get it :)
23:09:25 <paldepind> Thank you glguy and opqdonut!
23:38:00 <julianleviston> How could I rewrite this so it just pulls clientSendChan directly out of Client without using RecordWildCards ? sendMessage Client{..} msg = writeTChan clientSendChan msg
23:38:41 <liste> julianleviston sendMessage client msg = writeTChan (clientSendChan client) msg
23:38:43 <glguy> sendMessage Client { clientSendChan 07= c } msg 07= writeTChan c msg
23:38:57 <julianleviston> oh wow… both awesome. thank you
23:39:35 <liste> check out NamedFieldPuns also if you haven't
23:39:36 * hackagebot flowdock-rest 0.1.0.0 - Flowdock REST API  https://hackage.haskell.org/package/flowdock-rest-0.1.0.0 (phadej)
23:39:43 <julianleviston> ok
23:40:11 <liste> that way it would be sendMessage Client{clientSendChan} msg = writeTChan clientSendChan msg
23:41:16 <julianleviston> liste: yeah, cool! :)
23:42:33 <julianleviston> He keeps saying things like “note that this function is in the STM Monad (sig is sendMessage :: Client -> Message -> STM ()
23:42:49 <julianleviston> does that mean the function is an action?
23:43:00 <glguy> No, it means that it makes them
23:43:02 <julianleviston> or that it returns an action?
23:43:03 <julianleviston> ah
23:43:04 <julianleviston> right.
23:43:09 <julianleviston> that makes sense!
23:43:36 <julianleviston> but only an action in the STM Monad, right?
23:43:54 <julianleviston> obviously.
23:44:33 <glguy> It makes a value with the type "STM ()" which people tend to refer to as "actions"
23:44:40 <glguy> same for values with type "IO ()"
23:45:43 <shachaf> It's a shame that that use of the word isn't compatible with e.g. "group action".
23:47:41 <liste> the term "action" sounds a bit vague for me, though I use it
23:47:52 <liste> e.g., is [()] an action?
23:48:17 <liste> (value of type [()] that is)
23:53:36 <julianleviston> can I write a commend in .cabal files?
23:54:05 <glguy_> Maybe? Depends how you're using it. It doesn't need an exact definition, it's just relative to how someone is thinking of what they're modeling
23:54:07 <liyang> julianleviston: -- works; same as .hs files.
23:54:18 <julianleviston> liyang: sweet. thanks!
23:54:56 <julianleviston> liyang:  hm I just tried, and it how says NoParse “build-depends”
23:55:18 <julianleviston> liyang: seems to work if I put it on a new line tho
23:58:48 <julianleviston> If I want to import TChan from Control.Concurrent.STM.TChan can I not just import Control.Concurrent?
23:59:42 <liste> julianleviston only if Control.Concurrent exports it (which it doesn't afaik)
23:59:52 <liste> re-exports*
23:59:58 <julianleviston> ok
