00:00:12 <rui> Arahael: No reason except that I haven't used docker yet for anything. There are more things to learn that time
00:07:40 * hackagebot polar-shader 0.1.0.0 - High-level shader compiler for Polar Game Engine  https://hackage.haskell.org/package/polar-shader-0.1.0.0 (Shockk)
00:07:40 * hackagebot cabal-helper 0.6.0.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.6.0.0 (DanielG)
00:42:35 * hackagebot moesocks 0.1.2.30 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.2.30 (JinjingWang)
00:48:08 <Lokathor> i find myself needing to programatically generate variables
00:48:50 <liste> Lokathor for what?
00:49:19 <Lokathor> curses FFI binding coverage
00:49:48 <Lokathor> KEY_F0 is defined, and then KEY_F1 to KEY_F64 are KEY_F0 + x for x from 1 to 64
00:50:01 <liste> Lokathor then Template Haskell
00:50:20 <Lokathor> I'll look into that perhaps
00:50:40 <Lokathor> more likely, i'll just leave the low-level bindings a little lacking, and then fix it up at the higher level
00:50:52 <jle`> Data.Proof.EQ changed my life
00:51:34 <xuxu> is there a way to install dependencies into the Project.cabal file without having to edit a file manually?
00:52:12 <xuxu> for nodejs, `npm install --save express` will install the express framework 
00:52:23 <xuxu> you can also specify the version that you want
00:52:36 <xuxu> the latest is fetched if you don't
00:53:21 <xuxu> if that wasn't clear, the command will fetch the depenency and it add it to the list of your project's depdencies
00:53:23 <Lokathor> xuxu, do you mean that your project has a .cabal file, but it doesn't currently list a dependency that you want to add?
00:53:37 <xuxu> Lokathor: correct
00:53:49 <Lokathor> ah, hmm, you can't do that as far as I know. you have to add it to the cabal file before cabal can figure out what you need
00:54:13 <liste> cabal init does something like that but I'm not sure how you do it with already Cabalized project
00:54:17 <Lokathor> haskell folks are often particular enough about their version numbers that i think it's preferred to pick your own versions
00:54:29 <liste> it has a --overwrite but it sounds scary
00:55:01 <xuxu> i would like to say `cabal install --save conduit` or `stack install --save conduit` and the dependency will be fetched for me and placed inside the list of dependencies
00:55:28 <merijn> Lokathor: You're working on curses bindings?
00:55:30 <xuxu> Lokathor: you can pick your own version from the the command
00:55:36 <Arahael> Frankly, I wish it had something like Ruby's bundler.  You can specify whatever packages you want...  And the versions are specified in the bundler *lock* file, which you can version as well.
00:55:41 <xuxu> npm install --save express@2.0.1
00:55:48 <Lokathor> merijn, yes indeed
00:56:28 <merijn> Lokathor: Any specific reason? Might be a better time investment to contribute to brick (the successor of vty)
00:57:34 <liste> merijn wasn't it vty-ui ?
00:57:47 <Lokathor> merijn, i've never even heard of brick >_>
00:57:49 <merijn> liste: oh, right
00:58:00 <Lokathor> i tried vty once... but it was terrible
00:58:05 <merijn> Lokathor: vty is a pure haskell library for curses like programming except saner
00:58:09 <liste> brick is more high-level
00:58:16 <merijn> Lokathor: vty-ui is a wrapper for higher-level vty work
00:58:27 <merijn> Lokathor: It has things like text-input widgets, buttons, text fields, etc.
00:58:34 <merijn> brick is the cleaner successor to vty-ui
00:58:40 <Lokathor> vty wouldn't let me just easily put a character i wanted at a point i wanted. that is 90% of what i want out of such a library
00:58:48 <merijn> ah
00:58:52 <liste> Lokathor I use vty for that (:
00:59:27 <liste> use setCursorPos and outputByteBuffer
00:59:36 <Lokathor> i'm sure it's possible liste, but i was not able to figure it out at all
01:01:07 <lpaste_> liste pasted “Lokathor this is how I use vty” at http://lpaste.net/140430
01:02:02 <liste> https://github.com/ilmoeuro/frontier/blob/master/src/main/Frontier/IO.hs this is the whole file
01:02:16 <Lokathor> This... might not have existed last time i looked at vty?
01:02:41 <liste> Lokathor it was hard to find
01:03:05 <liste> I tried to use the Picture etc first but redrawing the whole screen got too exensive
01:03:14 <Lokathor> i last looked at vty quite a while ago, but all i could figure out was the Picture stuff, which seemed nonsenstically out of the way
01:03:49 <Lokathor> merijn, vital question, does brick build on windows without cygwin?
01:03:52 <Lokathor> that'd make me a convert
01:04:45 <liste> brick is built on top of vty
01:05:05 <Lokathor> i forget, does *that* build on windows?
01:05:30 <Lokathor> ah, looks like vty requires unix
01:06:22 <liste> https://github.com/coreyoconnor/vty#windows
01:06:30 <liste> says cygwin only
01:06:47 <liste> http://hackage.haskell.org/package/ansi-terminal <-- this works with Windows
01:07:43 <Lokathor> ansi-term doesn't have input though
01:08:09 <Lokathor> i think you can maybe setup stdin just right to have it work though
01:09:05 <merijn> The problem with getting curses like behaviour on windows is the fact that windows doesn't have a notion of terminals to begin with
01:09:32 <Lokathor> true, i will (one of these days) make a similar-enough thing in SDL
01:09:46 <Arahael> Windows barely even has standard input, output, and error, unless you use a specific subsystem (ie, the console subsystem)
01:09:46 <Lokathor> until then, i'll slowly fiddle with curses bindings
01:09:52 <merijn> There's programs that do the user side part of it, but you need to emulate the kernel part (i.e. cygwin)
01:10:03 <merijn> Lokathor: You know what my new solution is? :)
01:10:10 <Arahael> I think cygwin does it's own subsystem.
01:10:28 <merijn> Lokathor: Write it for unix, dump it on a $5 VPS and tell windows using friends to use PuTTy :p
01:10:46 <merijn> Although whether that works depends on how broadly you plan to let people use it
01:11:00 <Arahael> Actually, git 2.5 and higher has a remarkably good cmd alternative. 
01:11:44 <Arahael> Shares code with mtty or something, which is also used by putty (if my vagually recalled memory is correct)
01:12:23 <merijn> Arahael: That only deals with the terminal emulator part, not with the kernel part :p
01:12:25 <Lokathor> merijn, not the worst solution. I've got an old spare tower that i do most of my haskell work on
01:15:11 <merijn> I'd personally go with a VPS over my own machine, given that my local machines probably cost more in electricity than VPS' do these days, but yeah :)
01:15:41 <Arahael> merijn: Still, it beats the Putty idea. :)
01:15:58 <Arahael> merijn: git looks reasonably professional these days.  Putty's website looks like a forgotten website from 1995.
01:16:22 <frerich> Arahael: I think the Putty website looks like the program is 'done'. :-)
01:17:12 <Arahael> frerich: Try doing a poll amongst your windows users and see what they think. :)
01:17:53 <frerich> Arahael: Putty is like a standard piece of software to install on new Windows systems around here - and not because it's dictated (people can install whatever they like) but because it just works. :-)
01:18:09 <Arahael> frerich: I just install git.  :)
01:18:36 <Lokathor> merijn, well this isn't really a service for others :P it's just probably a roguelike or whatever
01:18:37 <Arahael> frerich: Gives me a useable shell, a few minimal tools, and it works well, even in 64-bit.
01:18:51 <merijn> PuTTy is one of the few programs that has always Just Worked™ for me.
01:19:18 <merijn> Lokathor: Right, then you could just make a single anonymous user with no password that has the rogue binary as shell :)
01:22:42 * frerich thinks this is #haskell-blah material
01:48:03 <Jinxit> if I want something like an interface from OOP - a set of functions that need to be implemented - what's the correct translation to Haskell?
01:48:30 <liste> Jinxit I'd go with a record of functions (:
01:48:30 <Lokathor> typeclass
01:48:33 <Lokathor> ...sorta
01:49:04 <liste> data Interface = Interface { func1 :: Int -> String; func2 :: Text -> Maybe ByteString }
01:49:18 <liste> s/;/,/
01:49:30 <Jinxit> and how is that then used?
01:49:53 <Lokathor> liste what you're describing is a cumbersome version of a typeclass >_>
01:50:06 <Jinxit> oh lol
01:50:22 <liste> myFunc :: Interface -> Foo; myFunc Interface{func1, func2} = ... func1 4 ... func2 "hello"
01:50:24 <Jinxit> I'll look into typeclasses
01:50:35 <liste> Lokathor except it's first class
01:51:08 <liste> so that if you have e.g. different database modules you can put them in a list
01:51:31 <Lokathor> couldn't you just make an instance for each module?
01:52:03 <liste> that would mean a type for each module
01:52:13 <liste> and then you couldn't mix them
01:52:43 <Lokathor> true i guess
01:53:27 <liste> http://www.haskellforall.com/2012/07/first-class-modules-without-defaults.html
01:53:46 <liste> and NamedFieldPuns makes it much less cumbersome
01:54:34 <Lokathor> i'd generally like it to all be automatically carried around for me
01:54:41 <Lokathor> but i can imagine when you'd want to have manual control
01:56:31 <merijn> Lokathor: The interface record thing is, in my experience, a subtantially nicer and easier way to do OO type stuff than typeclasses are
01:56:58 <Lokathor> i've never tried to do OO in haskell
01:57:09 <merijn> Typeclasses are really only worth something if they have some kind of laws/reasoning attached to them
01:57:11 <Lokathor> what OO does, haskell usually does well enough on its own
01:59:04 <merijn> Lokathor: I've used it for modelling multiple types of different sockets that support the same operations by doing something like "data Socket = Socket { send :: ByteString -> IO (); recv :: IO ByteString }" and then have "createSocketType1, createSocketType2 :: IO Socket", etc. storing/hiding the socket specific operations in the record and storing socket specific state in an IORef/MVar
01:59:11 <merijn> It worked really nicely
01:59:32 <kqr> merijn, since you brought up laws and typeclasses and that
01:59:51 <kqr> merijn, a recent understanding of mine is that typeclasses are useful if you have reason to abstract over whatever interface the typeclass is providing
01:59:58 <kqr> merijn, if you don't, you're better off creating regular functions
01:59:59 <Jinxit> what I'm trying to do is I'm writing some game AI functions, and I want them to be able to handle different board games - as long as they implement a set of functions
02:00:01 <kqr> merijn, is this wrong?
02:00:06 <Jinxit> perhaps there's a better way to do it?
02:00:09 <merijn> kqr: Pretty much
02:00:17 <merijn> kqr: Pretty much right, I mean :)
02:00:21 <kqr> hahah
02:00:23 <kqr> cheers
02:00:33 <kqr> it took a few years to get to that intuition
02:00:39 <kqr> but it feels nice to finally have a guiding light
02:01:01 <merijn> kqr: If you use typeclasses and want to do things like lists of sockets you run into problems with all your sockets being different types
02:01:15 <Jinxit> so something like "negamax :: (BoardGame g) => g -> Int" I guess
02:01:39 <merijn> And you end up creating existential wrappers because that seems like a "simple" solution, but the end result ends up being a lot of boilerplate and pain
02:01:56 <merijn> Because it takes like 2-3 days before you realise existential wrappers for typeclasses *suck*
02:02:17 <merijn> Where as the "data Socket" approach can trivially keep all different sockets in the same datastructure :)
02:02:32 <kqr> merijn, but it is closed, as opposed to the typeclass approach?
02:02:41 <merijn> kqr: Not necessarily
02:03:10 <kqr> Jinxit, that sounds like a place where typeclasses make sense, at least based on my understanding
02:03:17 <Jinxit> alright
02:03:18 <kqr> Jinxit, since you're looking to create functions that abstract over board games
02:03:23 <Jinxit> yeah
02:03:34 <merijn> kqr: Take my "data Socket = Socket { send :: ByteString -> IO (); recv :: IO ByteString }", adding new types just means writing a new "IO Socket" action that initialises the right state/values
02:03:55 <kqr> you don't care what kind of board game, just that it follows some set of "laws" universal to all board games in relation to the interface they provide 
02:04:22 <kqr> Jinxit, however, that only applies if you want the same AI to be able to play multiple board games
02:04:35 <kqr> Jinxit, and/or you have an idea on how to create convenience functions wrapping all board games
02:04:46 <kqr> Jinxit, if you don't, you might as well just give the AIs the specific board game type and use it
02:04:54 <lpaste_> merijn pasted “Socket example” at http://lpaste.net/140435
02:04:54 <kqr> merijn, ohh, yes, that's really nice
02:04:56 <liste> Jinxit is g a board game state or stateless description of the game?
02:05:13 <merijn> kqr: Ignore the error calls in that example, I'm using GADT/typeclass voodoo for that
02:05:17 <Jinxit> it was a state in this case, bad naming
02:05:32 <merijn> kqr: But if you simply export the constructor for Socket users of your library can easily implement custom Sockets :)
02:05:41 <Jinxit> can a typeclass have data types?
02:06:14 <Jinxit> each board game has a different board representation, but I don't care about that
02:06:33 <kqr> merijn, that's very nice. I've skirted around that pattern before but never quite been able to focus on what it is so my attempts at using it have been a little all over the place heh
02:06:35 <Jinxit> (like how tic-tac-toe has X | O | Empty and checkers has Red | Black | RedQueen | BlackQueen | Empty)
02:06:57 <liste> Jinxit theres multi-param type classes and type families if you need relations between types
02:07:05 <kqr> Jinxit, which functions do you want the boardgame interface to export?
02:07:18 <liste> but they're pretty advanced
02:07:22 <Jinxit> let me check
02:07:39 * hackagebot hgrib 0.2.0.0 - Unofficial bindings for GRIB API  https://hackage.haskell.org/package/hgrib-0.2.0.0 (mjakob)
02:08:07 <Jinxit> initialState, makeMove and score should be enough for now
02:08:17 <Jinxit> that's what I need from every board game
02:08:31 <merijn> liste: There's data families too :)
02:09:23 <Jinxit> actually, I probably don't need to know the internal board representation
02:09:36 <kqr> Jinxit, how can makeMove be the same for every board game?
02:09:45 <kqr> I mean in terms of its arguments
02:14:08 <Jinxit> got disconnected
02:14:25 <Jinxit> what I meant was, every BoardGame has to implement those three (makeMove, score, initialState)
02:14:32 <kqr> what's the type signature of makeMove
02:14:51 <Jinxit> GameState -> Int -> Maybe GameState
02:15:02 <Jinxit> where each board has a different GameState
02:15:11 <Jinxit> s/board/game
02:15:58 <kqr> oh right so the AI doesn't really know what kind of move it makes, it just makes moves and then checks the score?
02:16:08 <Jinxit> pretty much yes
02:16:30 <Jinxit> tries move 0 to n, where n is also defined by the game
02:17:39 * hackagebot memory 0.9 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.9 (VincentHanquez)
02:20:20 <merijn> hmm
02:20:38 <merijn> I want to insert keys into a Map, but I want to detect a "failure" if a key already exists
02:20:53 <Darwin226> Hey guys, TypeLits has Nat, but is there a way to get ints?
02:21:03 <merijn> Darwin226: Not at the moment
02:21:09 <Darwin226> merijn: How come?
02:21:19 <merijn> Darwin226: Well, I guess you could do "data TypeInt = Pos Nat | Neg Nat"
02:22:02 <Darwin226> merijn: I see. Floats are probably out of the question then, right?
02:22:18 <merijn> Darwin226: I think writing a Float solver would be HARD
02:22:36 <tdammers> merijn: regular old Data.Map? why not the naive implementation?
02:22:41 <Darwin226> merijn: I just need the ability to lift literals to type level and then get them as values again
02:22:50 <merijn> tdammers: How do I detect whether a key is already present?
02:23:01 <merijn> Darwin226: "just" :D
02:23:22 <tdammers> merijn: Data.Map.member ?
02:23:30 <merijn> tdammers: I don't want to explicit "notMember" on every insert :\
02:23:32 <Darwin226> merijn: Yeah, I guess I'm not aware of the complexities.
02:23:48 <merijn> I basically want "alter", but returning "Maybe (Map k a)" instead of just "Map k a"
02:23:58 <merijn> Darwin226: This is basically what dependent types are
02:24:31 <Darwin226> merijn: Well, I could basically do data Decimal = Pos Nat Nat | Neg Nat Nat
02:24:33 <merijn> Darwin226: Doing it in haskell is messy and hard because the languages was never designed for/around dependent types and doesn't have them. It just has crude and complex hacks to fake it :)
02:24:52 <merijn> Darwin226: Have a look at Idris/Coq/Agda? :)
02:25:14 <tdammers> merijn: maybe something from the "Indexed" section then?
02:25:30 <tdammers> merijn: you'd still do an explicit "exists" test, but at least you won't do a second lookup
02:27:32 <merijn> tdammers: I can write something myself, but the reason I asked was the hope that someone already knew :p
02:27:42 <tdammers> ah, right
02:28:18 <ww> dependent types aside, if you can do it for integers, you can do it for floats i think
02:28:38 <merijn> ww: You can't really do it for integers in haskell either
02:28:59 <ww> merijn: that's why i said "if" ;)
02:29:20 <merijn> ww: Oh, sure. If you have proper dependent types then doing it for floats is fine
02:29:43 <merijn> It's just that Nat already requires a complex special-cased hack in GHC, so floats would be downright painful :)
02:34:41 <kalkin-> Hi
02:35:12 <liste> kalkin- hi
02:35:58 <kalkin-> I'm porting some code from python to haskell. The original code parses an xml file gets the list of the xml nodes instantiates them as objects depending on type and then executes some methods. Dependeing on the type the object model overwrites some methods. 
02:36:39 <liste> what do the methods do?
02:36:40 <kalkin-> how would i model in haskell, that the method foo on Object A is different then method foo on ObjectB
02:36:51 <kalkin-> would i create like fooA and fooB?
02:37:23 <liste> do the methods modify the tree or perform other actions?
02:37:58 <kalkin-> liste: the methods called mostly for side effects. like start a VM. set VMs root path to foo
02:37:59 <ww> A and B would be different instances of the same typeclass
02:38:16 <ww> (first guess)
02:39:00 <kalkin-> ww: right, this was also my line of thinking. i could do some pattern matching depending on the type of the VM
02:39:32 <liste> I'd break the parsing and performing actions to different stages
02:40:04 <kalkin-> but how do i let the users extend it? i.e i want to have users write their own config like in xmonad, and extend it with own vm types. how can i do it, without the user having to patch every method foo extending it to handle his own Object C?
02:40:04 <liste> like stage1 :: Xml -> [Action]; stage2 :: [Action] -> IO ()
02:40:32 <avm314`> Hi! Does anybody know why if we do pattern matching against the first element in the list |> myButLast [x,_] = x | we use square brackets , but in |>  myButLast (_:xs) = myButLast xs | we use round brackets? [] makes sense for me - it's for the list, but what is the meaning of () in pattern matching?
02:41:01 <merijn> avm314`: [x] is syntactic sugar for "(x:[])"
02:41:28 <merijn> avm314`: : is the constructor for list, you need the parentheses because the precedence difference between operators and function application
02:41:43 <kalkin-> liste: what do you mean when you say stage?
02:41:56 <merijn> avm314`: So "myButLast _:xs" parses as "(myButLast _):(xs)"
02:42:18 <merijn> avm314`: So the parentheses are just to indicate grouping, the "magic" is the pattern matching on the ':' constructor
02:42:40 * hackagebot log 0.3.1 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.3.1 (arybczak)
02:42:54 <merijn> avm314`: If you take "data List a = Nil | Cons a (List a)" then "myButLast (_:xs)" is the same as "myButLast (Cons _ xs)"
02:42:57 <avm314`> merijn` Thanks a lot!
02:43:08 <liste> kalkin- something like stages of compilation: lexing, parsing, translation, code generation...
02:43:51 <liste> avm314` also note that when speaking about *types*, [a] is sugar for [] a
02:44:22 <liste> if you happen to bump into that in the future
02:45:32 <kalkin-> liste: ah ok. thanks
02:46:40 <avm314`> liste, thanks!
02:46:56 <liste> yw (:'
02:49:20 <liste> kalkin- you could have something like "data VmHandler = VmHandler (Xml -> [Action])" and load those from disk using either `hint' or other config language
02:49:38 <liste> and then collect the results
02:49:50 <liste> and run the actions
02:52:29 <merijn> Is there a version of Either that lets me collect multiple errors?
02:52:40 * hackagebot binary-orphans 0.1.1.0 - Orphan instances for binary  https://hackage.haskell.org/package/binary-orphans-0.1.1.0 (phadej)
02:52:42 * hackagebot language-puppet 1.1.4 - Tools to parse and evaluate the Puppet DSL.  https://hackage.haskell.org/package/language-puppet-1.1.4 (SimonMarechal)
02:54:19 <chpatrick> @hackage Validation -- <-- merijn
02:54:19 <lambdabot> http://hackage.haskell.org/package/Validation -- <-- merijn
02:55:09 <chpatrick> not sure why it's not a newtype though
02:55:33 <chpatrick> a bit ugly-looking package if I'm honest
02:55:57 <merijn> Big dependency set too
02:56:06 <merijn> Although I think I'm already depending on most of that :p
02:56:54 <chpatrick> aha: https://hackage.haskell.org/package/either-4.4.1/docs/Data-Either-Validation.html
02:56:58 <chpatrick> this is the kmett version
02:57:40 * hackagebot tamarin-prover 0.8.6.2 - The Tamarin prover for security protocol analysis.  https://hackage.haskell.org/package/tamarin-prover-0.8.6.2 (SimonMeier)
02:57:57 <chpatrick> I don't get why that's not a newtype either
02:58:16 <chpatrick> it's just changing the applicative instance after all
03:01:38 <kalkin-> liste: hmm defining own VmHandlers, neat idea. i will explore it further, thank you!
03:02:41 * hackagebot asn1-data 0.7.2 - ASN1 data reader and writer in RAW, BER and DER forms  https://hackage.haskell.org/package/asn1-data-0.7.2 (VincentHanquez)
03:37:42 * hackagebot asn1-encoding 0.9.1 - ASN1 data reader and writer in RAW, BER and DER forms  https://hackage.haskell.org/package/asn1-encoding-0.9.1 (VincentHanquez)
03:41:43 <sinelaw> Peaker: :P
03:51:39 <merijn> hmmm
03:52:06 <merijn> What's the name of "flip (.)"? I need a more convenient way to compose LambdaCase
03:52:57 <bartavelle> merijn, >>>
04:02:25 <merijn> Rats...I need something like a combination of fold and traverse...does that even exist?
04:02:33 <Intolerable> type?
04:02:39 <pacak> :t foldMap
04:02:40 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
04:03:02 <pacak> :t cata
04:03:03 <lambdabot> Functor f => (f a -> a) -> Mu f -> a
04:03:07 <quicksilver> what would a 'combination' of fold and traverse mean?
04:03:15 <bartavelle> fold . traverse ? :)
04:03:16 <quicksilver> traverse reconstructs the previous structure
04:03:21 <quicksilver> fold destroys it
04:03:25 <quicksilver> where is the middle ground?
04:03:30 <merijn> quicksilver: Applicative effectful fold, then?
04:03:32 <quicksilver> traverse with an accumulating parameter?
04:03:42 <pacak> :t hylo
04:03:43 <bartavelle> merijn, foldM for applicative ?
04:03:44 <lambdabot> Not in scope: ‘hylo’
04:03:44 <quicksilver> do you mean an effectful traverse?
04:03:52 <obadz> scan ?
04:04:20 <quicksilver> fold . traverse would be an effectful fold....
04:04:33 <pacak> merijn: What are you trying to do?
04:05:01 <merijn> "(Foldable f, Applicative f) => (a -> f b -> f b) -> t a -> f b" or something...mmm, maybe just fold is enough if I liftA2
04:06:14 <merijn> pacak: Construct a Map from a list of key value pairs and trying to accumulate a list of "duplicate" keys if they exist
04:06:22 <obadz> :t scanr
04:06:24 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
04:06:33 <merijn> So I want either 1) a Map or 2) a list of duplicate keys
04:07:21 <merijn> And I didn't want to write the recursion out by hand, but seems that might end up being simpler...
04:08:57 <merijn> obadz: I don't see how scan fits what I want?
04:09:37 <bartavelle> merijn : you can easily write [(a,b)] -> Map a [b], and then Map.filter ( (> 1) . length) ?
04:09:40 <merijn> The more I think about it I don't think there's a simple combinator for it, because, for example Validation doesn't quite fit
04:09:45 <obadz> If your t happened to be [], wouldn't scanr be what you want?
04:09:59 <merijn> obadz: How does [] build a Map?
04:10:54 <obadz> Doesn't I had not read your comment about maps when I typed :t scanr ..
04:10:56 <bartavelle> merijn, basically you'd need fromListWithA :)
04:11:48 <merijn> Anyway, I'll just recurse by hand
04:17:36 <lpaste_> merijn pasted “lookup” at http://lpaste.net/140436
04:17:48 <merijn> I think that's the simplest I can come up with
04:19:55 <obadz> merijn: insertLookupWithKey + filter would do it no?
04:21:01 <gingitsune> can anyone make anything off: ghc.exe: C:\Users\Karlis\AppData\Roaming\cabal\i386-windows-ghc-7.6.2\network-2.6.2.1\HSnetwork-2.6.2.1.o: unknown symbol `_getWSErrorDescr'
04:30:49 <obadz> merijn: foldKVs kvs = L.foldl' (\ (m, d) (k, v) -> f (M.insertLookupWithKey (\ _ n _ -> n) k v m) k d) (M.empty, []) kvs where f (Just _,  m') k d = (m', k : d); f (Nothing, m') _ d = (m', d)
04:32:06 <obadz> foldKVs [ ("Hi", 5), ("Ho", 7), ("Hi", 8) ] => (fromList [("Hi",8),("Ho",7)],["Hi"])
04:32:29 <bartavelle> merijn, http://lpaste.net/140437
04:52:45 * hackagebot tamarin-prover 0.8.6.3 - The Tamarin prover for security protocol analysis.  https://hackage.haskell.org/package/tamarin-prover-0.8.6.3 (SimonMeier)
04:54:41 <Eduard_Munteanu> Is there a good library for video playback and compositing?
04:55:43 <merijn> hmmm, it's actually non-trivial to implement proper lazy evaluation while you have things like as-patterns, etc.
05:02:45 * hackagebot blaze-shields 0.1.0.0 - create svg by Haskell  https://hackage.haskell.org/package/blaze-shields-0.1.0.0 (Qinka)
05:05:27 <lunaris> Anyone here use Spacemacs?
05:05:39 <lunaris> And if so, is the Haskell layer sufficient for you?
05:06:04 <lunaris> I think I've got it working with Stack through some .dir-local.el tricks but am sort of confused as to what I should be expecting it to provide after that.
05:09:04 <obadz> lunaris: I loved spacemacs at first, then realized I just couldn't work with it and went back to regular emacs
05:09:22 <lunaris> obadz: I'm coming from Vim, so that forms part of my motivation.
05:09:28 <obadz> lunaris: the , key which is supposed to be a shortcut for S-m did not work
05:09:39 <obadz> lunaris: ghc-mod would freeze emacs
05:09:47 <lunaris> But, disregarding that, I think I'm just plain confused about what haskell-mode (I believe that is basically what the haskell layer for Spacemacs provides) gives me.
05:10:01 <obadz> lunaris: and the menues are not labeled so you need the memory of an elephant to navigate them
05:10:07 <lunaris> For instance, I'm not sure if there's integration with e.g. company for completion.
05:10:16 <lunaris> Or if I'm just getting tag navigation etc.
05:10:30 <obadz> I think I had company mode work in spacemacs though can't recall
05:10:37 <obadz> same about tagnav
05:10:52 <lunaris> :/
05:11:25 <lunaris> I am very confused.
05:11:32 <lunaris> I just want a tutorial that holds my hand for a bit.
05:11:39 <lunaris> But I don't think such a tutorial exists.
05:11:54 <obadz> lunaris: on spacemacs specifically?
05:12:00 <lunaris> No, their documentation is excellent.
05:12:10 <lunaris> The Haskell layer, assuming that it is that which I should be using.
05:12:14 <lunaris> Like I said, I'm using Stack.
05:12:22 <lunaris> Which I appreciate means it's all a bit up in the air.
05:12:36 <lunaris> But I think I've solved those problems using some of the notes people have posted on various Github issues etc.
05:12:46 <lunaris> So now it's just about learning how to use the major mode itself
05:12:49 <obadz> lunaris: there's really not that much to the layer, all the shortcuts are there: https://github.com/syl20bnr/spacemacs/blob/master/contrib/!lang/haskell/packages.el#L91
05:13:13 <lunaris> So no completion then?
05:13:28 <lunaris> I read that .el and it seemed to hint at some stuff using the autocomplete layer.
05:13:34 <obadz> lunaris: yes: https://github.com/syl20bnr/spacemacs/blob/master/contrib/!lang/haskell/packages.el#L251
05:13:43 <lunaris> But I'm not sure what that's pushing out to for its completion.
05:14:03 <lunaris> Well, it's haskell-mode, but after that.
05:14:14 <obadz> it's company-ghc
05:14:25 <lunaris> I see.
05:14:33 <lunaris> N00b emacs question:
05:14:37 <lunaris> How do I load the messages buffer?
05:14:46 <lunaris> To see if there are any messages that I'm missing.
05:14:58 <lunaris> Because I suspect that some work is required on my part to sort company-ghc.
05:15:05 <obadz> in spacemacs, S-b-b will show you the list of buffers
05:15:11 <lunaris> Since as I understand it, it should complete automatically when I pause typing, right?
05:15:19 <obadz> lunaris: I think so
05:15:40 <obadz> in non-spacemacs, I bound C-SPC to 'company-complete
05:16:10 <lunaris> Ok.
05:16:16 <lunaris> I will try and invoke that function directly.
05:16:56 <obadz> Ok haskell question: I hear there's a way to write a function like "FromJSON a, b, .., z => (a -> b -> .. -> z) -> ([Json.Value] -> Maybe Json.Value) using type families. Can anyone point me in the right direction?
05:17:12 <lunaris> So, company-ghc-diagnose says that company-ghc is not found.
05:17:20 <obadz> might be a ToJSON constraint on z
05:17:27 <lunaris> obadz: You can do it with either type families or classes, I believe.
05:17:42 <obadz> yes, I'm interested in learning how to do it with type families
05:17:47 <obadz> I was told it's simpler
05:17:48 <lunaris> Ok, one second.
05:17:52 <lunaris> I will try and knock something up.
05:17:58 <obadz> the typeclass hackery makes my brain explode
05:18:15 <lunaris> It's all much of a muchness at that level :)
05:20:49 <lunaris> obadz: You want it to take a list of values, right?
05:22:02 <obadz> lunaris: yes
05:22:21 <obadz> lunaris: this is the part of my ~/.emacs (non-spacemacs) that relates to haskell & company in case that helps: https://gist.github.com/obadz/9c15cbc2e0640538e34e
05:26:01 <obadz> lunaris: would like to return Nothing if one of the Jsons fail to parse of if there are too many/too few inputs
05:26:30 <obadz> lunaris: I'm hoping it'll be relatively easy to extend to return something a bit more explicit than Nothing :)
05:32:18 <lpaste_> lunaris pasted “JSON munging” at http://lpaste.net/140438
05:32:45 <lunaris> obadz: I used type classes I'm afraid -- the fact that you want a function built alongside the type meant I felt they were a better fit than TFs.
05:32:46 * hackagebot clash-lib 0.5.11 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.5.11 (ChristiaanBaaij)
05:32:46 <lunaris> Sorry.
05:32:48 * hackagebot clash-vhdl 0.5.9 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.5.9 (ChristiaanBaaij)
05:32:50 * hackagebot clash-verilog 0.5.8 - CAES Language for Synchronous Hardware - Verilog backend  https://hackage.haskell.org/package/clash-verilog-0.5.8 (ChristiaanBaaij)
05:32:52 * hackagebot clash-systemverilog 0.5.8 - CAES Language for Synchronous Hardware - SystemVerilog backend  https://hackage.haskell.org/package/clash-systemverilog-0.5.8 (ChristiaanBaaij)
05:32:54 * hackagebot clash-ghc 0.5.12 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.5.12 (ChristiaanBaaij)
05:33:20 <obadz> lunaris: thanks, let me digest.
05:33:22 <lunaris> Np.
05:34:20 <obadz> that's actually pretty simple
05:34:27 <obadz> well, still mind bending
05:34:40 <lunaris> Completely untested so could be crap :)
05:34:41 <obadz> but you didn't need functional dependencies which is cool
05:35:03 <lunaris> Well, there's only one type variable, so I think it's good.
05:35:08 <obadz> if it typechecks, it's like it's tested right ? :)
05:35:16 <lunaris> So, stack with company-ghc -- do I need some hackery?
05:35:48 <obadz> hmmm come to think of it, I think company-ghc uses ghc-mod no?
05:37:03 <lunaris> Yep.
05:37:12 <lunaris> But I have no idea if company is even enabled in this buffer.
05:37:16 <lunaris> Man, feeling like a noob.
05:37:21 <lunaris> Worth doing every now and then.
05:37:43 <obadz> With haskell I feel like a noob every day
05:37:46 * hackagebot Graphalyze 0.14.1.1 - Graph-Theoretic Analysis library.  https://hackage.haskell.org/package/Graphalyze-0.14.1.1 (IvanMiljenovic)
05:38:06 <obadz> ok let me try to start spacemacs and see if I had company working
05:41:05 <lunaris> I think it's Stack causing my problems.
05:41:15 <lunaris> Or rather, my not understanding where to get this all looking for ghc-mod etc.
05:45:29 <obadz> lunaris: yeah I've got no company in spacemacs, but then again ghc-mod also doesn't start
05:45:36 <obadz> lunaris: so that doesn't really mean anything
05:45:44 <lunaris> How do you know it doesn't start?
05:45:46 <lunaris> The messages buffer?
05:46:02 <obadz> ghc-mod freezes emacs on startup, I have to Ctrl+G
05:46:12 <Jinxit> http://pastebin.com/pkeyJwjR bear with me, I'm pretty new, but what am I doing wrong here?
05:46:19 <Jinxit> (error on line 26)
05:46:55 <obadz> lunaris: nothing about company in there, but: Making inhibit-read-only local to *helm-mode-completion-at-point* while let-bound!
05:46:55 <clrnd> Jinxit, ReversiState is a type, not a constructor
05:47:02 <chpatrick> your constructor is BoardGameState
05:47:18 <chpatrick> wait nm
05:47:26 <Jinxit> no that produces the same error
05:47:38 <chpatrick> Jinxit: you're confusing class and data
05:47:47 * hackagebot smallcheck-laws 0.3 - SmallCheck properties for common laws  https://hackage.haskell.org/package/smallcheck-laws-0.3 (jdnavarro)
05:47:48 <chpatrick> typeclasses mean something else in haskell
05:47:49 * hackagebot x509-system 1.6.1 - Handle per-operating-system X.509 accessors and storage  https://hackage.haskell.org/package/x509-system-1.6.1 (VincentHanquez)
05:48:07 <lunaris> This feels somewhat futile.
05:48:25 <lunaris> Back to work for now; will have to try again another time.
05:48:32 <obadz> lunaris: there's a gitter channel where the spacemacs guys typically hang out
05:48:39 <lunaris> It is that responsive?
05:48:41 <obadz> lunaris: https://gitter.im/syl20bnr/spacemacs
05:48:47 <obadz> lunaris: yeah mostly it is
05:48:53 <lunaris> Ok, will give it a shot.
05:48:56 <lunaris> Thanks obadz.
05:49:04 <chpatrick> Jinxit: oh wait no I see what you're doing
05:49:07 <obadz> sure. thank you for your help with munge
05:49:23 <Jinxit> I want a generic board game and a specific implementation
05:49:24 <obadz> (did it typecheck for you btw?)
05:49:39 <Jinxit> that specific implementation would then get 'foo' for free
05:49:40 <chpatrick> Jinxit: you need to make a concrete data type for the ReversiState
05:49:59 <chpatrick> also BoardGameState needs to have an s parameter
05:49:59 <lunaris> obadz: It did.
05:50:06 <lunaris> obadz: I simply haven't run it :)
05:50:12 <m1dnight_> Do any of you guys happen to know what technology was used to create the book learn you a haskell?
05:50:16 <chpatrick> and then it would be board :: s -> b, player :: s -> p
05:50:17 <m1dnight_> Like what tools etc..
05:50:17 <chpatrick> right
05:51:15 <chpatrick> currently BoardGameState doesn't make any sense and the type synonyms should be data definitions
05:51:26 <obadz> lunaris: problem is fromJSON returns Result a, not Maybe a
05:51:30 <obadz> lunaris: I can fix that
05:52:27 <lunaris> They are compatible enough for your needs I think.
05:52:47 * hackagebot tasty-laws 0.3 - Test common laws  https://hackage.haskell.org/package/tasty-laws-0.3 (jdnavarro)
05:53:19 <Jinxit> chpatrick: trying to work this out, how would you define ReversiState?
05:55:15 <chpatrick> Jinxit: data ReversiState { reversiBoard :: ReversiBoard, reversiPlayer :: ReversiPlayer }
05:55:25 <chpatrick> data ReversiState = ReversiState { reversiBoard :: ReversiBoard, reversiPlayer :: ReversiPlayer }
05:55:26 <chpatrick> sorry
05:55:50 <Jinxit> but that doesn't use BoardGameState?
05:56:07 <chpatrick> why would it?
05:56:23 <chpatrick> BoardGameState s means there are certain functions that exist for type s
05:56:26 <chpatrick> it's not a class like in oop
05:57:00 <Jinxit> if you look at line 16, I want to use "board s" on any state
05:57:13 <Jinxit> which is why I wanted BoardGameState
05:57:14 <lunaris> Jinxit: Type classes resemble OO interfaces more than classes, if that helps.
05:57:34 <Jinxit> I'm trying to use them like interfaces
05:57:36 <lunaris> They capture the "class of types" which implement some interface.
05:57:47 <lunaris> Apologies for butting in then; just wanted to clarify :)
05:57:55 <Jinxit> yeah no problem, I appreciate it
05:59:56 <quicksilver> they aren't even the right way to model interfaces unless you want to be able to overload w.r.t. that interface
06:00:00 <quicksilver> but I'm butting in also :)
06:00:17 <chpatrick> Jinxit: you need to define ReversiState as a concrete independent thing
06:00:31 <Jinxit> but then how could I call board on it?
06:00:35 <Jinxit> in foo
06:00:37 <chpatrick> then you can say ReversiState is an instance of BoardGameState because board and player are defined on it
06:01:04 <chpatrick> instance BoardGameState ReversiState where board = <reversi-specific implementation>; player = <reversi-specific implementation>
06:01:45 <chpatrick> in java superinterfaces and superclasses are baked into a given class
06:01:53 <chpatrick> in haskell typeclasses are just observations about some types
06:02:06 <chpatrick> they're not integral to them
06:02:26 <chpatrick> look at Show
06:02:33 <chpatrick> class Show a where show :: a -> String
06:02:50 <chpatrick> that just says something is an instance of Show if there exists a show function for that type
06:03:00 <chpatrick> that doesn't mean that type is somehow "built on" Show
06:03:01 <exio4> thinking of typeclasses as something totally unrelated might help, any analogy falls down as soon as you get past any hello-world-like example (between OOP classes/interfaces and typeclasses)
06:03:49 <tdammers> I like to think of typeclass instances as "recipes"
06:04:35 <tdammers> instance Show Blah where show = showBlah -- means: A Blah can be used as a Show, in order to do that, use "showBlah" as the implementation of the "show" method
06:04:39 <Jinxit> well, what I want is being able to create a function "minimax" which accepts any valid (implements a common interface) board game
06:04:45 <Jinxit> is type classes not the best way?
06:04:50 <chpatrick> yeah you're on the right track
06:05:07 <chpatrick> but first you need to define your game and not even worry about typeclasses
06:05:29 <chpatrick> and then you can say that your game is an instance of BoardGame because because because
06:05:41 <chpatrick> but that's external to the game itself
06:08:33 <Jinxit> do I have to name reversiPlayer and reversiBoard if they're just a straight mapping to player and board?
06:09:22 <chpatrick> what do you mean a straight mapping?
06:09:39 <chpatrick> reversiPlayer and reversiBoard are the concrete implementations
06:09:51 <chpatrick> defining player and board just fits them into the bigger BoardGame pattern
06:10:12 <chpatrick> I think you're still thinking of typeclasses as oop classes
06:11:00 <chpatrick> what this would look like is instance BoardGameState ReversiState where board = reversiBoard; player = reversiPlayer
06:11:14 <chpatrick> you're saying ReversiState is a BoardGameState because there exist functions board and player
06:11:24 <chpatrick> which are equal to reversiBoard and reversiPlayer
06:11:30 <Jinxit> yeah okay, got that
06:12:48 * hackagebot asn1-encoding 0.9.2 - ASN1 data reader and writer in RAW, BER and DER forms  https://hackage.haskell.org/package/asn1-encoding-0.9.2 (VincentHanquez)
06:12:50 * hackagebot tasty-laws 0.3.1 - Test common laws  https://hackage.haskell.org/package/tasty-laws-0.3.1 (jdnavarro)
06:19:08 <Jinxit> chpatrick: http://pastebin.com/RHqpJL4r I have this now, but line 21 is wrong
06:19:13 <Jinxit> probably misunderstood something
06:20:15 <chpatrick> Jinxit: what's the error?
06:20:37 <Jinxit> illegal instance declaration (All instance types must be of the form (T t1 ... tn)
06:20:59 <chpatrick> you need {-# LANGUAGE MultiParamTypeClasses #-}
06:21:04 <Jinxit> I have that
06:22:19 <merijn> yeah...this is not gonna work out
06:22:23 <obadz> lunaris: ok works great, thank you :) I just needed some small tweaks to use Result & an overlappable pragma
06:22:33 <merijn> This needs FunDeps, FlexibleInstances and a bunch of other stuff
06:22:34 <chpatrick> Jinxit: you need FlexibleInstances
06:22:37 <ski> `foo x = V.length $ board x' looks like it will not work, as written
06:22:38 <chpatrick> yep
06:22:41 <merijn> Jinxit: This is really not the right design
06:22:44 <lunaris> obadz: Excellent :D
06:22:47 <Jinxit> that's fine with me
06:22:48 * hackagebot ViennaRNAParser 1.2.6 - Libary for parsing ViennaRNA package output  https://hackage.haskell.org/package/ViennaRNAParser-1.2.6 (FlorianEggenhofer)
06:22:53 <Jinxit> what's a better design?
06:22:55 <merijn> Jinxit: Why are you trying to make a typeclass in the first place?
06:23:07 <chpatrick> I think it's not far off
06:23:15 <exio4> you are making a instance for a type synonym
06:23:16 <chpatrick> why does minmax need to know what the board type is?
06:23:31 <merijn> chpatrick: You don't need a typeclass for minimax
06:23:41 <Jinxit> enlighten me
06:23:44 <chpatrick> I don't think it needs the player either, as long as it's comparable
06:24:01 <chpatrick> merijn: he wants to make a minimax AI that can play any game
06:24:06 <Jinxit> yeah
06:24:31 <bartavelle> chpatrick, you can replace that kind of use of typeclasses by just passing the dictionary
06:24:43 <chpatrick> you could but I think this is a reasonable use case
06:24:51 <merijn> Just needs minimax that takes an initial state, update function and fitness function
06:24:53 <bartavelle> I think this is the typical antipattern :)
06:24:56 <chpatrick> I don't think it's the existential antipattern
06:25:05 <chpatrick> no, I don't think so
06:25:16 <chpatrick> a game has a state and some operations that change the state
06:25:21 <bartavelle> look at the astar package for example : http://hackage.haskell.org/package/astar-0.2.1/docs/Data-Graph-AStar.html
06:25:32 <chpatrick> I know what you're talking about
06:25:34 <merijn> "minimax :: (s -> Int) -> (s -> m -> s) -> s -> Result" or whatever
06:25:46 <Jinxit> hmm
06:26:05 <merijn> minimax reversiScore reversiUpdate reversiStart
06:26:08 <merijn> etc.
06:26:12 <chpatrick> I think it would be nice to generalize minimax like that
06:26:22 <chpatrick> but regardless you could make a typeclass that captures board games
06:27:09 <Jinxit> just having it as a function makes sense actually
06:27:16 <flux> I've often thought logic programming languages would be suitable for board game simulators. haven't tried it, though :)
06:27:19 <merijn> Or "data Game state move = Game { score :: state -> Int; updateBoard :: state -> move -> state; initialState :: state }"
06:27:37 <merijn> "minimax :: Game s m -> Result s"
06:27:46 <chpatrick> what does that really buy you though?
06:27:59 <exio4> you would need some way to generate a move, though? 
06:28:03 <chpatrick> there's unlikely to be more than one Game for a given board right?
06:28:27 <bartavelle> chpatrick, what does a typeclass instance buys you ? Is that really obvious that there is only a single instance that makes sense for all board games ?
06:28:32 <Jinxit> flux: maybe suitable logic wise, but not very efficient
06:28:37 <chpatrick> well it's not for all board games
06:28:45 <bartavelle> for a given board game
06:28:48 <merijn> chpatrick: typeclasses rarely buy you anything
06:28:53 <chpatrick> for a given board game there's probably a given rule :)
06:29:04 <merijn> chpatrick: And often make things annoying when it comes to, e.g., mixed collections
06:29:08 <chpatrick> I don't know why I'm arguing, I agree that typeclasses are considered harmful
06:29:08 <bartavelle> chpatrick, clearly score might be a heuristic
06:29:11 <exio4> the uniqueness property is pretty handy if you need/want it
06:29:22 <chpatrick> but I don't think this is necessarily a case 
06:29:23 <exio4> but I don't see that used here
06:30:30 <chpatrick> but it's true that the rules don't really derive from the types
06:30:36 <bartavelle> in the pastebin, "board" and "player" are just "getters" from a structure "s"
06:30:37 <chpatrick> so you're probably right
06:31:31 <bartavelle> well, looks like that
06:31:51 <bartavelle> I don't personally buy the "rule" rule for typeclasses, but I suppose it is very valid
06:31:51 <Jinxit> yeah they were
06:32:43 <bartavelle> also typeclassing "initialState" means you can't solve endgames in isolation for example, so you clearly lose something here
06:40:58 <merijn> Anytime my classes need FunDeps it's time to pause and reflect for me
06:41:46 <exio4> fundeps are just for fun? :p 
06:52:49 * hackagebot blaze-shields 0.1.0.1 - create svg by Haskell  https://hackage.haskell.org/package/blaze-shields-0.1.0.1 (Qinka)
07:22:35 <erisco> what is (a -> a -> Ordering) -> (a -> a -> Ordering) -> a -> a -> Ordering ?
07:22:59 <erisco> i.e. if the first compare is EQ, then use the second compare
07:23:09 <mariusmarius1> does it compose the orderings?
07:23:37 <erisco> > (EQ <> GT, EQ <> LT)
07:23:38 <lambdabot>  (GT,LT)
07:23:43 <erisco> hm
07:23:47 <ski> erisco : `(<>)'
07:23:58 <Intolerable> > mempty :: Ordering
07:24:00 <lambdabot>  EQ
07:24:26 <erisco> @pl \f g a b -> f a b <> g a b
07:24:26 <lambdabot> liftM2 (liftM2 (<>))
07:24:40 <ski> > sortBy (comparing length <> compare) (words "The quick brown fox jumps over the lazy dog")
07:24:41 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
07:25:06 <ski> no need for `liftM2', just use `Ord a => Ord (rho -> a)'
07:25:26 <ski> erisco : see Cale's <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx>
07:25:28 <clrnd> lol monoid everything
07:25:39 <Intolerable> monoids and semigroups are magical
07:25:40 <clrnd> there must be an esoteric language that only has <>
07:25:51 <clrnd> is there a proof it's turing comp?
07:26:23 <jmcarthur> > sortOn (length &&& id) (words "The quick brown fox jumps over the lazy dog")
07:26:25 <lambdabot>  ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
07:27:26 <erisco> okay, because  (Monoid b) => Monoid (a -> b)
07:27:36 <ski> er, yes
07:28:47 <frerich> jmcarthur: Neat, I always only used the Monoid instance, it never occurred to me that sortOn could be put to use, too :-)
07:29:07 <erisco> :t sortOn
07:29:08 <lambdabot> Ord b => (a -> b) -> [a] -> [a]
07:30:27 <erisco> okay, what if you can only use type classes with empty contexts?
07:31:14 <ski>   sortOn = sortBy . comparing  -- presumably ?
07:34:09 <Philonous> Where would an instance (MonadTrans t, MonadIO m) => MonadIO (t m) where liftIO = lift . liftIO   break down?
07:36:59 <Philonous> Or rather, why do we have instances for individual transformers rather than one catch-all instance? Are there t :: * -> * that aren't monad transformers but that lead to valid MonadIO instances? 
07:39:05 <nshepperd> an instance Foo (t m) requires some extensions to be allowed, iirc
07:39:23 <nshepperd> beyond that there might be other problems, idk
07:40:48 <Philonous> OK, thanks
07:42:24 <jmcarthur> erisco: i don't recall exactly the implementation in base, but i can think of two useful ones with different performance characteristics
07:43:26 <jmcarthur> erisco: there's the one you guessed, and there's     map snd . sortBy (comparing fst) . map (f &&& id)
07:43:34 <jmcarthur> the latter might be nice if f is expensive
07:45:19 <Peaker> You require Ord on the list element type too
07:48:59 <clrnd> :t (&&&)
07:49:00 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:49:43 <aweinsto1k> :t (&&&) :: (b -> c) -> (a -> c') -> (b -> (c, c'))
07:49:44 <lambdabot>     Couldn't match type ‘a1’ with ‘b1’
07:49:44 <lambdabot>       ‘a1’ is a rigid type variable bound by
07:49:44 <lambdabot>            an expression type signature:
07:49:56 <aweinsto1k> :t (&&&) :: (b -> c) -> (b -> c') -> (b -> (c, c'))
07:49:59 <lambdabot> (b -> c) -> (b -> c') -> b -> (c, c')
07:50:38 <aweinsto1k> clrnd: the above is (&&&) specialized to a = (->)
07:50:55 <clrnd> aweinsto1k, yes! I got that, tried in a repl too
07:51:40 <clrnd> but yeah, it can look confusing to see `(->) a b`
07:51:45 <clrnd> be*
07:54:52 <MaCx> anyone has zenphone 5 running on Qualcom Proccesor ? kindly pm me thank you!~
07:59:10 <haskell850> hi i'm a haskell noob, need help with rose trees/trie, data Rose a = Branch a [Rose a] deriving (Ord, Eq, Show) , i am storing letters at each node and each path in the tree is a word, i can create a tree for a single word, but cannnot figure out how to add a word to an existing tree, any help welcome
07:59:36 <quicksilver> Philonous: because that would overlap with all over instances, making it hard to write other kinds of MonadIO instance
08:00:38 <tdammers> haskell850: can you add a single-letter word to a tree?
08:02:01 <haskell850> no, because the root will not change
08:02:32 <Philonous> quicksilver, It would overlap with instances of the form (t m), yes, but are there any that look like the one I gave?
08:02:43 <Philonous> that don't look like the one I have, I mean
08:02:50 <Philonous> gave
08:02:51 * hackagebot x509 1.6.1 - X509 reader and writer  https://hackage.haskell.org/package/x509-1.6.1 (VincentHanquez)
08:02:53 * hackagebot x509-store 1.6.1 - X.509 collection accessing and storing methods  https://hackage.haskell.org/package/x509-store-1.6.1 (VincentHanquez)
08:02:55 * hackagebot x509-validation 1.6.1 - X.509 Certificate and CRL validation  https://hackage.haskell.org/package/x509-validation-1.6.1 (VincentHanquez)
08:03:03 <haskell850> Branch "c" [ Branch "a" [ Branch "t" []]]]  i want to add "cats","cots"
08:03:11 <Cale> haskell850: If you want a trie, it's probably better to have edge labels
08:03:19 <quicksilver> Philonous: I dunno. That's a big class of instance. Probably :)
08:03:44 <Cale> Something like  data Trie a = Branch [(a, Trie a)]
08:03:49 <Philonous> quicksilver, At least there are none that spring to mind, right? 
08:03:54 <Eduard_Munteanu> haskell850, you won't be able to distinguish "cat" and "cats"
08:03:56 <quicksilver> Philonous: something can probably fail to be a MonadTrans in full generality but still enough to do MonadIO
08:04:17 <quicksilver> Philonous: well, such monads (which which support IO operations) tend to be custom ones in application code, not common libraries
08:04:35 <haskell850> ok make sense
08:04:40 <Cale> Perhaps with an additional case for a node that marks the end of a word
08:04:54 <Cale> er
08:05:34 <haskell850> ok will try that thanks everyone
08:06:17 <Cale> haskell850: Also, you might want to replace that list of pairs with a Map
08:06:31 <Philonous> quicksilver, thanks
08:06:37 * Eduard_Munteanu . o O (   data Trie a = Trie Bool a [Trie a]   )
08:07:02 <Eduard_Munteanu> Then membership of a particular string is trivial.
08:07:09 <Cale> For two reasons: it'll perform much better, but even if that's unimportant to you, Maps have a lot of relevant operations conveniently defined on them
08:07:53 <Cale> Eduard_Munteanu: I still think it should be edge labels and not vertex labels, but yeah, having a Bool field might be nicer than a separate constructor
08:08:56 <Eduard_Munteanu> Yeah, more generally edge labels allow empty strings to be in the trie.
08:09:33 <Eduard_Munteanu> And different start symbols.
08:46:33 <Gurkenglas> Should we strive for the property "ala Identity = ($ id)"?
09:04:44 <rui> Are all the haskell packages in nix of versions that work well with each other?
09:06:04 <rui> If so, how do they manage to have all the packages in hackage while stackage has some? are all updated together like stackage snapshots?
09:06:36 <obadz> rui: there are some overrides
09:07:16 <obadz> rui: in https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/configuration-ghc-7.10.x.nix
09:07:47 <obadz> rui: so if someone needs a package that doesn't build they can go shove a patch or pass some option that will make it work in there..
09:07:53 * hackagebot polar-shader 0.1.0.1 - High-level shader compiler for Polar Game Engine  https://hackage.haskell.org/package/polar-shader-0.1.0.1 (Shockk)
09:09:50 <rui> humm
09:11:59 <rui> obadz: thanks. A dumb example could help me understand better. Say someone upgrades his package P in hackage to a newer version
09:12:18 <rui> How does that propagate to nix?
09:12:58 <rui> Automatically? Or someone interested in the newer version changes some hackage-packages.nix file?
09:13:34 <obadz> rui: someone has to run hackage2nix and commit it to the nix repo
09:14:45 <obadz> rui: but automatically created hackage-packages.nix can be overriden in manually maintained configuration-ghc-7.10.x.nix, hence more stuff might build on nix than on hackage
09:15:40 <jmcarthur> edwardk: is there a safe zip function somewhere in hybrid-vectors, or are unsafeZip and convert the only built in way to construct them from pairs of vectors?
09:27:43 <rui> so hackage2nix converts latest hackage versions into nix expressions with cabal2nix
09:27:54 * hackagebot travis 0.1.0.0 - A simple client implementation using Travis CI API.  https://hackage.haskell.org/package/travis-0.1.0.0 (tomtau)
09:28:06 <rui> what does cabal2nix do with all the dependency version restrictions in the cabal file? ignores them?
09:35:04 <osa1> I have a OVERLAPPING typeclass instance and in the module that imports it I have OverlappingInstances enabled, but I'm still getting "overlapping instances for blah arising from blah imported from ..." errors. any ideas why my OVERLAPPING instance doesn't overlap the other instance?
09:35:23 <osa1> in the error message it shows an instance from a library[safe] and my instance [overlapping]
09:37:32 <wedify> why not take matrices as the thing most obessed with?
09:37:56 * ski doesn't understand wedify's question
09:38:27 <wedify> it seems that discussions of algorithms most often deal with singly linked lists
09:38:32 <KaneTW> osa1: do you have safe haskell enabled
09:38:41 <osa1> KaneTW: I don't want to enable that, do I have to?
09:38:45 <KaneTW> no
09:38:57 <osa1> KaneTW: the library has that enabled though
09:39:01 <KaneTW> it has conditions on overlapping type instances
09:39:18 <osa1> KaneTW: so I have two instances, one imported form a Safe module and one imported from my module and this one has OVERLAPPING pragma
09:39:21 <KaneTW> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe-haskell.html
09:39:28 <KaneTW> OverlappingInstances — This extension can be used to violate semantic consistency, because malicious code could redefine a type instance (by containing a more specific instance definition) in a way that changes the behaviour of code importing the untrusted module. The extension is not disabled for a module M compiled with -XSafe but restricted. While M can define overlapping instance declarations, they can
09:39:30 <KaneTW> only overlap other instance declaration defined in M. If in a module N that imports M, at a call site that uses a type-class function there is a choice of which instance to use (i.e. an overlap) and the most specific instances is from M, then all the other choices must also be from M. If not, a compilation error will occur. A simple way to think of this is a same origin policy for overlapping instances
09:39:30 <osa1> KaneTW: yeah but I'm not in SafeHaskell
09:39:32 <KaneTW> defined in Safe compiled modules.
09:39:33 <ski> wedify : parallel arrays are interesting
09:40:17 <KaneTW> try marking it as -XUnsafe
09:40:27 <KaneTW> the library being Safe might cause that
09:40:42 <osa1> didn't work.
09:40:42 <KaneTW> although it shouldn't
09:40:45 <KaneTW> humm
09:40:56 <KaneTW> can you paste a minimal working example
09:40:58 <osa1> KaneTW: btw, the error message doesn't say anything about being safe or not
09:41:10 <osa1> KaneTW: yeah, give me a sec
09:42:55 * hackagebot docopt 0.7.0.3 - A command-line interface parser that will make you smile  https://hackage.haskell.org/package/docopt-0.7.0.3 (ryanartecona)
09:47:56 <kalkin-> i have a a function `shouldMatchList` :: [a] -> [a] -> Expectation
09:48:09 <kalkin-> and i want to compare [String] and IO [String]
09:48:33 <kalkin-> i know i have to use a trick to compare a pure result with impure result
09:48:45 <kalkin-> i tried fmap but this doesn't work
09:48:48 <glguy_> There's no String in an IO String
09:48:56 <wedify> you'll have to do it inside the io monad unfortunately
09:49:30 <wedify> whereIOStrCameFrom >>= shouldMatchList str
09:49:49 <Tuplanolla> You can use fmap, but it gives you something of type IO Expectation.
09:49:55 <Tuplanolla> As does that one.
09:50:11 <kalkin-> wedify: i think i recognize it from lyah 
09:50:32 <Intolerable> you can join an IO Expectation
09:50:41 <Intolerable> since Expectation is just IO ()
09:50:48 <glguy> fmap (shouldMatchList string1) ioString2 :: IO Expectation
09:50:54 <Intolerable> so you can join the IO (IO ())
09:52:33 <kalkin-> wedify, Tuplanolla  Intolerable thank you for your advice
09:53:11 <kalkin-> got it running
10:04:27 <sudeep> hi
10:04:29 <sudeep> guys
10:04:32 <KaneTW> hello
10:04:32 <Intolerable> hello
10:04:44 <sudeep> i have question that might be noob
10:04:44 * kalkin- just figured out that records fields can't be easily exported
10:04:53 <KaneTW> don't ask to ask, just ask
10:04:54 <kalkin-> should i uses lens for this?
10:05:01 <sudeep> why is list comprehension important in Haskell?
10:05:03 <Intolerable> how do you mean?
10:05:06 <geekosaur> kalkin-, in what sense?
10:05:07 <sudeep> i am from python
10:05:08 <Welkin> sudeep: it's not
10:05:20 <ski> sudeep : sometimes they can be nice
10:05:20 <Welkin> sudeep: you would normally use map and filter in place of a list comprehension
10:05:26 <mauke> I almost never use list comprehensions
10:05:31 <KaneTW> it's one of many tools but i don't find myself using them much
10:05:32 <sudeep> and there is a seperate lesson in most of the book about list comprehension
10:05:37 <kalkin-> geekosaur: to access getters and setters or is it overkill?
10:05:51 <sudeep> so is it the data type?
10:06:14 <sudeep> it there array in haskell or list is itself and array
10:06:17 <ski> sudeep : no, it's a syntax construction
10:06:22 <geekosaur> kalkin-, field accessors are just functions you can put in the export list
10:06:22 <ski> sudeep : there are arrays
10:06:33 <ski> both mutable and immutable
10:06:50 <sudeep> ski: example of array
10:06:54 <kalkin-> geekosaur: but i thought i had to declare them each one as a function redundandly?
10:06:59 <geekosaur> ?????
10:07:29 <chpatrick> @hackage vector -- sudeep
10:07:29 <lambdabot> http://hackage.haskell.org/package/vector -- sudeep
10:07:32 <geekosaur> no, data Foo = Foo {bar :: String} implictly declares bar :: Foo -> String
10:07:35 <Welkin> sudeep: Array, MArray, Vector, MVector, List, Sequence, ...
10:07:45 <Tuplanolla> Also note that there's the MonadComprehensions extension for generalized list comprehensions, sudeep.
10:07:46 <KaneTW> when you do data R = R { a :: Int, b :: Bool } you get functions a :: R -> Int, b :: R -> Bool
10:07:48 <kalkin-> geekosaur: maybe i misunderstood something, 
10:07:56 <ski> > listArray ((2,2),(3,3)) [x^y | (x,y) <- range ((0,0),(2,3))]  -- two-dimensional array
10:07:58 <lambdabot>  array ((2,2),(3,3)) [((2,2),1),((2,3),0),((3,2),0),((3,3),0)]
10:08:13 <chreekat> kalkin-: import Module M (DataType(..)) where ....
10:08:15 <ski> > listArray ((2,2),(3,3)) [x^y | (x,y) <- range ((0,0),(2,3))] ! (2,3)  -- indexing in an array
10:08:16 <lambdabot>  0
10:08:17 <KaneTW> and you can also pattern match like f R {a = x} = x + 2
10:08:21 <geekosaur> omne of the points of lens is that an inconvenience here is you can't have fields of the same name in different records (or the same record but different types in different constructors) in scope at the same time
10:08:31 <Tuplanolla> > [(x, y) | x <- Just (), y <- Nothing]
10:08:33 <lambdabot>      Couldn't match expected type ‘[t]’ with actual type ‘Maybe ()’
10:08:33 <lambdabot>      In the expression: Just ()
10:08:33 <lambdabot>      In a stmt of a list comprehension: x <- Just ()    Couldn't match expect...
10:08:43 <ski> er .. perhaps it would have been better if i used `(2,2)' instead of `(0,0)'
10:08:45 <KaneTW> or do g r x = r { a = x }
10:08:45 <geekosaur> so lens creates "special" accessors that can deal with that, at the price of some Template Haskell
10:08:49 <Intolerable> aww, no monadcomprehension
10:08:52 <ski> > listArray ((2,2),(3,3)) [x^y | (x,y) <- range ((2,2),(3,3))] ! (2,3)
10:08:55 <lambdabot>  8
10:09:00 <chreekat> dur, i used both module import and module declaration syntax accidentally
10:09:09 <ski> sudeep : arrays can e.g. be good for dynamic programming
10:09:15 <Tuplanolla> That should've worked.
10:09:21 <hc> hi, quick question about parsing http queries with 
10:09:31 <ski> sudeep : there's no syntactic sugar for arrays, but they're there
10:09:32 <hc> sry, never mind
10:09:59 <sudeep> ski:  thanks
10:10:24 <ski> sudeep : if you need mutable arrays, you'll need to do it in `IO' or `ST' or something similar
10:11:22 <kalkin-> geekosaur: i see. thank you. i do not need lens at the moment. i think i just misunderstood the import syntax
10:11:29 <kalkin-> chreekat: thanks, that was the issue :)
10:11:35 <geekosaur> possibly. it's consistent but a bit confusing sometimes
10:17:57 * hackagebot tight-apply 0.1.0.0 - Tightly binding infix function application  https://hackage.haskell.org/package/tight-apply-0.1.0.0 (Shockk)
10:19:54 <wedify> I don't think we need more line noise (tight-apply)
10:25:25 <mniip> [19:13:47] * hackagebot tight-apply 0.1.0.0 - Tightly binding infix function application  https://hackage.haskell.org/package/tight-apply-0.1.0.0 (Shockk)
10:25:25 <mniip> but
10:25:27 <mniip> id
10:25:43 <mniip> > negate `id` 5
10:25:45 <lambdabot>  -5
10:26:13 <Tuplanolla> Where's (&) defined by the way?
10:26:14 <Gurkenglas> Weird that Data.Array doesn't provide (i, i) -> (i -> e) -> Array i e
10:26:31 <Gurkenglas> Tuplanolla, http://hayoo.fh-wedel.de/?query=%28%26%29
10:27:02 <Tuplanolla> Oh, it's in base these days.
10:27:54 <benzrf> > 5 & negate
10:27:56 <lambdabot>  -5
10:28:05 <wedify> ok i looked at the hackage for tight-apply and there isn't an operator. odd
10:29:16 <rui> Anyone able to install and use ihaskell notebooks properly though nix?
10:29:18 <benzrf> odd
10:29:47 <benzrf> there was a join immediately after wedify said that, and in my client it lined up such that the 'ight' in 'lightspeed' was right under the 'ight' in 'tight-apply'
10:31:14 <rui> Installed ihaskell fine with nix, and also ipython. Then did "ihaskell install".
10:32:02 <rui> ipython notebook works and it sees a haskell kernel, but the kernel dies instantly
10:33:46 <ski> Gurkenglas : i call it `tabulate'
10:34:03 <ski> (after SML)
10:37:41 <KaneTW> i don't get the point of tight-apply
10:38:31 <geekosaur> @quote chrisdone parentheses
10:38:31 <lambdabot> No quotes match. Take a stress pill and think things over.
10:38:34 <geekosaur> bah
10:39:12 <Gurkenglas> Has @quote ever worked out as hoped?
10:39:52 <Tuplanolla> ?quote Gurkenglas yes
10:39:52 <lambdabot> No quotes for this person. Sorry about this, I know it's a bit silly.
10:41:17 <Zemyla> @quote Gurkenglas 
10:41:17 <lambdabot> No quotes match. That's something I cannot allow to happen.
10:41:27 * geekosaur can't remember where he saw the quote... something about haskellers being afraid of parens
10:43:17 <Alpha64> there's a marked prejudice against them
10:43:51 <ski> `$' is used too much
10:44:10 <Alpha64> "I swear mom! I'm not using lisp!"
10:44:29 <geekosaur> yep. thing is that tight-apply is in the same area
10:44:44 <Gurkenglas> "Being scared of parens is like being scared of a great big monster with poisonous fangs. It actually makes a great deal of sense, and does not, in fact, indicate that you have a psychological problem."
10:44:47 <pyon> Well, `$` *is* easier to read.
10:45:10 <Alpha64> i prefer <| 
10:45:21 <pyon> Not that I'm afraid of parens, just that too many of them looks ugly. Lisp needs the parens because it has variadic functions.
10:46:10 <monochrom> I know how to eliminate most parentheses.
10:46:39 <mauke> lisp doesn't need the parens
10:47:06 <monochrom> for every infix operator, make 9 versions, one version for each precedence level
10:48:01 <monochrom> for example + at highest precedence (9), .+. at 8, ..+.. at 7, etc., ........+........ at 1
10:48:28 <monochrom> therefore for example  x .+. y ...*... z is unambiguous and does not need parentheses
10:49:17 <monochrom> f ..$.. x + y ..$.. g .$. x + y
10:49:30 <pyon> mauke: In what other way (other than parens, brackets, etc.) can variadic functions be handled?
10:49:32 <monochrom> is clearly f (x+y) (g (x+y))
10:49:59 <Tuplanolla> ...and then increase the precedence levels to 100, just like Coq does.
10:50:08 <KaneTW> :t printf
10:50:09 <lambdabot> PrintfType r => String -> r
10:50:19 <monochrom> well, too bad Haskell only knows 9 levels.
10:50:35 <mniip> well you're forgetting about
10:50:37 <mauke> pyon: with $
10:50:37 <mniip> fixities!
10:50:42 <mniip> er
10:50:46 <c_wraith> > length [0..9] -- monochrom 
10:50:48 <lambdabot>  10
10:50:51 <mniip> brainfart
10:50:54 <mniip> associativities!
10:51:14 <mniip> gotta make an infixr and infixl version of every operator
10:51:25 <Tuplanolla> ...then introduce infixa, an alternating associativity.
10:51:29 <pyon> mauke: How do you indicate «this is the end of the argument list»?
10:51:30 <KaneTW> fixity sections
10:51:33 <mauke> pyon: I've written a reader macro that turns (foo #$ bar #$ baz) into (foo (bar (baz)))
10:51:35 <mniip> Tuplanolla, no
10:51:36 <KaneTW> ($ infixr 9)
10:51:36 <monochrom> c_wraith, is "infixl 0 .$." legal Haskell? if not, then there is no "0"
10:51:41 <mniip> programmable fixity
10:51:43 <pyon> mauke: Ah.
10:51:46 <c_wraith> monochrom: I'm pretty sure it is
10:51:49 <mauke> pyon: it extends as far to the right as possible
10:51:54 <c_wraith> monochrom: $ is infixr 0
10:52:06 <pyon> mauke: But that isn't variadic functions. :-|
10:52:26 <mauke> pyon: (+ 1 2 3 4 5) doesn't need additional parens
10:52:41 <mniip> (+) 1 2 3 4 5
10:52:47 <monochrom> thank you for the correction?
10:52:50 <mniip> same amount of parens
10:53:30 <pyon> mauke: Oh, what I was talking about is the need to wrap expressions in parentheses in the first place, not the need to use parentheses to control nesting.
10:54:13 <Alpha64> i always wondered if you could just use indentation for that pyon
10:54:26 <mauke> well, you can get rid of some other parens if you agree to mark functions-vs-values other than by position
10:54:26 <pyon> Alpha64: I wouldn't want to have to read it.
10:55:03 <mauke> also, you don't wrap expressions in parens in lisp. parens are specifically function calls
10:56:17 <pyon> Oh, right.
10:56:28 <pyon> Yes, I was thinking about function calls.
10:56:54 <mauke> perl does the other thing I mentioned
10:57:06 <mauke> instead of (foo foo (bar bar)) you'd write foo $foo, bar $bar
10:57:34 <mauke> using $ to mark the non-function values, not position
10:57:58 * hackagebot truthful 0.1.0.0 - Typeclass for truthfulness of values  https://hackage.haskell.org/package/truthful-0.1.0.0 (Shockk)
10:59:25 <Alpha64> mauke prototypes?
10:59:41 <Alpha64> sub foo($$) etc ?
11:00:29 <mauke> Alpha64: I'm assuming no prototypes here
11:00:40 <mauke> (because they're icky)
11:01:23 <Welkin> haha, I was just reading about perl last night
11:01:37 <Welkin> supposedly there are a lot of haskell users in the perl6 community
11:02:16 <mauke> blame audrey tang and the pugs project for that :-)
11:03:01 <mauke> (it's also how I got into haskell)
11:06:07 <Alpha64> i'm not sold on perl6, i'd rather learn haskell, if you already know perl5 there isn't much to see
11:06:37 <Alpha64> implementing the thing in haskell looked like a crazy adventure though
11:07:34 <mauke> "if you already know perl5 there isn't much to see" <- I don't agree with that
11:07:41 <mauke> it looks like a completely different language to me
11:09:04 <Alpha64> i might give it another show when it gets released
11:09:39 <Alpha64> last time i tried it ( a year ago or so ) most of the interesting things didn't work or were broken
11:10:22 <geekosaur> it's made quite a lot of progress since then
11:10:56 <geekosaur> although just now there are some breakages due to a major refactoring of lists (among other things, they are more consistent and more performant)
11:12:58 * hackagebot GPipe 2.0.1 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.0.1 (TobiasBexelius)
11:17:08 <tedkornish> Has anyone deployed a haskell service using docker-compose? I'm getting a weird thing where it's hanging when I try to run `docker-compose up $MY_HASKELL_APP`
11:17:29 <tedkornish> But services in other languages (Python and Ruby are on the ones I tried) are hanging like that.
11:18:07 <lpaste_> inininin pasted “Can't find... Can't load” at http://lpaste.net/140448
11:18:54 <inininin> has anyone ever had problems with missing .DLLs on a brand new Haskell installation? http://lpaste.net/140448
11:22:59 * hackagebot sets 0.0.5 - Various set implementations in Haskell.  https://hackage.haskell.org/package/sets-0.0.5 (athanclark)
11:23:01 * hackagebot inline-r 0.7.0.0 - Seamlessly call R from Haskell and vice versa. No FFI required.  https://hackage.haskell.org/package/inline-r-0.7.0.0 (MathieuBoespflug)
11:23:03 * hackagebot H 0.7.0.0 - The Haskell/R mixed programming environment.  https://hackage.haskell.org/package/H-0.7.0.0 (MathieuBoespflug)
11:23:05 * hackagebot ihaskell-inline-r 0.1.0.0 - Embed R quasiquotes and plots in IHaskell notebooks.  https://hackage.haskell.org/package/ihaskell-inline-r-0.1.0.0 (MathieuBoespflug)
11:23:22 <sm> sweet
11:27:33 <grayen> Is there a general way, other than creating specialized operators for each arity, to rewrite foo x y z = baz (bar x y z), to something similar to foo = baz . bar?
11:28:14 <ski>   foo = baz .:: bar
11:28:21 <glguy> grayen: no
11:28:25 <ski>   (.::) = (.) . (.) . (.)
11:28:45 <mniip> fmap (fmap baz) . bar
11:28:46 <grayen> ski: that is the specialized operator for each arity I was talking about ;)
11:28:53 * ski bows
11:30:05 <ski>   foo = (result . result . result) baz bar  -- using `result = (.)', is another variant
11:30:08 <ski> @where SEC
11:30:08 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
11:30:22 <solarus> :t \f g -> ((f .) .) . g
11:30:25 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
11:30:36 <ski> (well, turning out to be the same in this case, but it yields another way to *think* about it, i mean)
11:30:40 <grayen> I always use, (.:) = fmap . fmap, and (..:) = fmap . fmap . fmap, is .:: more commonly used for three arguments?
11:31:04 <ski> grayen : when i invented the names `.:',`.::',`.:::',..., that's what i used
11:31:40 <ski> the number of characters in `.::' is the number of arguments "passed on", the number of dots is the same as the number of dots in `(.) . (.) . (.)'
11:33:10 <grayen> ski: ah, that makes sense, when using (.) instead of fmap
11:38:37 <grayen> Well, ok, I will keep using specialized operators. I do not really like ((f .) .) . g because it can be harder to understand in terms of readability
11:39:14 <glguy> Yeah, it's clearer to write the arguments than to get clever with composition operators
11:39:45 <jmcarthur> i'm generally happy to write (fmap.fmap.fmap) and such
11:40:00 <jmcarthur> it reads pretty nicely as "three levels deep"
11:40:09 <Welkin> point-free is certainly abused :)
11:40:50 <jmcarthur> and the pattern is general enough that one can use it pervasively, so it doesn't have to be surprising
11:41:19 <jmcarthur> e.g. (liftA2.liftA2.liftA2), (foldMap.foldMap.foldMap), (traverse.traverse.traverse)
11:41:58 <KaneTW> point free is fine when it actually improves readability
11:43:17 <grayen> exactly, just keep to basic usage, no over usage, then you can better start using a concatenative language
11:44:11 <jmcarthur> I see bad point free code as worse than bad pointful code, but I see good point free code as better than good pointful code.
11:48:26 <Lokathor> why is good point free code better than good pointful code?
11:49:09 <zimp> is there anything like a parallel (and lazy) any or all? or how might i go about implementing that myself? would i have to get in to forkIO etc?
11:49:10 <ski> perhaps "wholemeal programming"
11:49:56 <tdammers> Lokathor: generally speaking, because once you're used to dealing with it, fewer variables means smaller mental overhead
11:50:46 <l0p3n> I'm trying to return the last element in a list. It doesn't work. http://lpaste.net/140450. Could someone spot what's wrong with my code?
11:51:25 <ski> l0p3n : perhaps you mean to use recursion ?
11:51:55 <ski> if `_:xs' is `[0,1,2]', then `xs' is `[1,2]'
11:52:01 <mniip> l0p3n, (x:xs) means an element x prepended to a list xs
11:52:44 <l0p3n> ski: Is that necessary? I just want to return the last element in a list.
11:52:47 <jmcarthur> Lokathor: It's easier to think about and manipulate code that's expressed as a series of transformations.
11:52:49 <l0p3n> mniip: Aha ok!
11:52:52 <Lokathor> l0p3n, you're returing the tail of the list, not the last element
11:53:13 <mniip> l0p3n, you'll have to take the whole list apart recursively
11:53:29 <ski> l0p3n : the last element is the next-to-last thing you see as you follow the chain of cons-cells until the end (the empty list)
11:54:56 <l0p3n> Lokathor: mniip: ski: That's strange... :)
11:55:15 <mniip> no that's just how it works
11:55:27 <Welkin> l0p3n: if you think of a list as a recursive structure with a base-case, it is not strange at all
11:55:31 <Welkin> in fact, that is what a list is
11:55:32 <mniip> it's basically a singly linked list
11:55:36 <Lokathor> l0p3n, it's different to get used to. a List isn't like an array in other languages, for that we have an array package :P
11:55:41 <mniip> except with more constraints
11:55:46 <Welkin> data List a = Empty | Cons a (List a)
11:56:11 <l0p3n> Welkin: Well I guess that makes sense
11:56:42 <Welkin> even in a language like C, you have the base case of the list as NULL
11:57:08 <jmcarthur> @src last
11:57:08 <lambdabot> last [x]    = x
11:57:08 <lambdabot> last (_:xs) = last xs
11:57:08 <lambdabot> last []     = undefined
11:57:16 <ski> l0p3n : the only way to reach an element of a list is to traverse the "spine" of cons-cells "down" to where it's located
11:57:32 * ski idly wonders whether l0p3n is familiar with C
11:59:47 <l0p3n> Yes I'm familiar with C but I think I just learned a new way to look at lists
12:00:37 <ski> would you like to elaborate ?
12:02:16 <l0p3n> No, as I guess I just said something that doesn't make any sense. But I think I understand how it works now. Thank you guys!
12:04:27 <ski> np
12:06:26 <agocorona> Are there some standard data structure like:   More a | Last a  |  NoMore   to express data from a stream?
12:08:00 * hackagebot pipes-extras 1.0.1 - Extra utilities for pipes  https://hackage.haskell.org/package/pipes-extras-1.0.1 (GabrielGonzalez)
12:08:14 <mniip> agocorona, Compose Maybe ((,) Bool)
12:08:17 <ski> agocorona : i would prefer baking the current "state" of the stream into the `More' alternative
12:13:03 <agocorona> bytestring has it: http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/src/Data.ByteString.Builder.Extra.html#Next
12:22:26 <KaneTW> something like Result there https://hackage.haskell.org/package/attoparsec-0.8.3.0/docs/Data-Attoparsec.html is what i'd use, but I'd just define an own ADT
12:23:01 * hackagebot sdl2 2.0.0 - Both high- and low-level bindings to the SDL library (version 2.0.3).  https://hackage.haskell.org/package/sdl2-2.0.0 (OliverCharles)
12:27:45 <obadz> :t fmap (.) pure (+ 1) 
12:27:46 <lambdabot> Num a1 => (a -> b) -> a -> a1 -> a1
12:27:54 <obadz> why does the Applicative f drops from the type signature?
12:28:13 <obadz> huh, forgot some parens
12:28:47 <c_wraith> in that case, it isn't present because it knows what instance it has to use - ((->) a)
12:29:47 <KaneTW> @src fmap
12:29:47 <lambdabot> Source not found. That's something I cannot allow to happen.
12:30:00 <obadz> :t \ f g -> (fmap (.) f) <*> g
12:30:01 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
12:30:04 <ski> @src (->) fmap
12:30:05 <lambdabot> fmap = (.)
12:30:10 <obadz> any reason this isn't in the stdlib?
12:30:30 <obadz> I guess it's also liftA2 (.)
12:30:34 <ski> @type liftA2 (.)
12:30:37 <lambdabot> Applicative f => f (b -> c) -> f (a -> b) -> f (a -> c)
12:30:46 <obadz> but still feels like a useful operator no?
12:30:58 <ski> dunno
12:31:20 <KaneTW> usually chaining <*> is more common
12:31:31 <KaneTW> :t (<*>)
12:31:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:34:30 <obadz> head explodes. fifth time today.. I don't even understand what I don't understand.
12:35:12 <levi> Don't worry, you can get plenty of good programming done without understanding everything. :)
12:38:53 <sshine> https://tweag.github.io/HaskellR/ - this is crazy.
12:38:57 <obadz> can't wrap my head around how to use instance Applicative ((->) a)
12:39:51 <obadz> I think I get instance Monad ((->) a)
12:39:52 <Pamelloes> Are there any good libraries for rendering svgs in Haskell? I've found a lot of libraries for making svgs, but I need to load them from a file and convert them to a rasterized image.
12:39:52 <Sindriav_> sshine: You spelt "amazing" wrong
12:40:05 <sshine> obadz, did you look at the instance Applicative ((->) a)?
12:40:13 <obadz> sshine: yes
12:40:23 <Sindriav_> Pamelloes: Why? And why can't that be solved with an external tool?
12:40:59 <obadz> anyway I can probably get through the day without wrapping my (already stretched thin) head around this
12:42:50 <Pamelloes> Sindriav_:  I have an svg source for an image and I'd like my webserver to be able to provide clients with png versions of it, ideally of any size. Of course, I could just render the image in an external tool and not have dynamic sizes but the rest of my project is in Haskell so I'd like to keep it that way :)
12:43:21 <Sindriav_> Pamelloes: Why couldn't you have dynamic sizes with an external tool?
12:44:35 <sshine> obadz, maybe if I were doing 'M.insert k (transform k v)'  (M.insert k . transform k $ v)  I could do 'M.insert <*> transform $ k $ v'. seems a little fringey.
12:44:37 <Sindriav_> Pamelloes: Anyways, if you really are convinced that you want a haskell solution (which I am still not), try the ImageMagick bindings for Haskell
12:44:56 <Welkin> obadz: the Applicative instance for ((->) r) forms the SKI combinator calculus!
12:46:01 <Welkin> obadz: very good explanation here: http://people.cs.uchicago.edu/~odonnell/Teacher/Lectures/Formal_Organization_of_Knowledge/Examples/combinator_calculus/
12:46:03 <Pamelloes> Sindriav_: If I used an external tool, in order to get dynamic sizes I'd have to hook it up into my webserver. Which means I'd have to create my own Haskell bindings which is a pain.
12:46:05 <levi> obadz: The fmap is simply function composition, while the <*> applies the environment parameter to each argument and then composes them.
12:46:41 <Sindriav_> Pamelloes: What prevents you from calling it from the commandline? Ideally with ShQQ? Don't overcomplicate stuff.
12:46:54 <Sindriav_> Pamelloes: But as I said, if you really want this, go for ImageMagick :)
12:47:25 <sshine> Sindriav_, does it actually parse the R in Haskell?
12:47:44 <sshine> Sindriav_, I mean, do you get compile-time analysis that you don't get in R?
12:48:02 <sshine> (besides referring to _hs variables)
12:48:10 <Pamelloes> Sindriav_: Perhaps I could just call it from the command line... Though now that I'm thinking about it, I don't really know why I even want dynamic sizes.
12:48:24 <Sindriav_> Pamelloes: Even better.
12:48:32 <Pamelloes> I think the best solution might be to render everything in an external tool and then just host the images :)
12:49:16 <Sindriav_> Pamelloes: Using ShQQ, Haskell is a pretty nice language to do Shell scripting in too :)
12:49:34 <Pamelloes> Hm, I've never used ShQQ. I mighht look into that :)
12:50:10 <Sindriav_> Pamelloes: It lets you call shell commands using quasiquoters, eg. ` [sh| cat /etc/passwd |]
12:50:50 <Pamelloes> Ooh, so it'll prevent stupid syntax errors :) Do you get any form of type safety?
12:51:33 <Sindriav_> Pamelloes: I think that everything it returns is a string. But combined with `readMaybe`, you'll pretty much get type-safety
12:51:53 <Pamelloes> Cool! I'll have to take a look into that.
12:52:10 <Sindriav_> Pamelloes: what more, it let's you write the actual logic of the script in Haskell, because shell is useless for that
12:53:02 * hackagebot parsers 0.12.3 - Parsing combinators  https://hackage.haskell.org/package/parsers-0.12.3 (EricMertens)
12:53:04 <Sindriav_> Pamelloes: Also, you can do a shebang on a haskell file, to make it executable :)
12:53:15 <Pamelloes> I was just about to ask that :)
12:53:15 <Sindriav_> Pamelloes: #!/path/to/runghc
12:53:31 <Pamelloes> i think I definitely have to check this out at somepoint.
12:54:29 <voidzero> there is also Turtle
12:54:49 <voidzero> https://hackage.haskell.org/package/turtle
12:55:16 <Pamelloes> Cool. I'll be sure to check that out, too :)
12:55:29 <voidzero> lots of checking out to do hehe
12:55:29 <darteksyes> Hello guys, sorry to bother, do you think that "learn Haskell for great good" is a good way to start?
12:55:32 <voidzero> welcome to Haskell
12:55:36 <voidzero> yes darteksyes I do think so
12:55:41 <darteksyes> thanks
12:55:53 <voidzero> just suspend your critical thought, accept everything at face value, and keep on reading
12:55:58 <catgocat> hello all, what is the version system for hackage pakages? I mean A.B.C.D
12:56:06 <catgocat> I have never seen the .D there
12:56:12 <catgocat> I always use A.B.C
12:56:12 <obadz> Welkin/levi - thx
12:56:16 <catgocat> but i'm curious about that one
12:56:32 <voidzero> depends on the dev
12:56:47 <Pamelloes> A.B are breaking changes. C.D are non-breaking changes.
12:56:56 <voidzero> darteksyes, for me, the first time i could not get through the book when I tried to understand it all in the first go
12:56:58 <Pamelloes> What each number means depends on teh dev
12:56:59 <darteksyes> I just started with the first 3 chapters, I'm just a little disoriented 'cause it's my first approach to functional prog
12:57:14 <voidzero> yeah. Just say 'umm okay' and keep reading - that worked for me at least :D
12:57:24 <darteksyes> :D
12:57:26 <levi> obadz: There's a nice explanation here: http://stackoverflow.com/questions/11810889/functions-as-applicative-functors-haskell-lyah
12:57:47 <darteksyes> thanks for the advice void!
12:57:59 <voidzero> yw, hope it'll work for you too
12:58:17 <obadz> levi: thx
12:59:43 <voidzero> At one point I just realised that I couldn't understand it, so then I stopped thinking about what I read until the end. Then, reading it for the second time, things made much more sense.
13:00:56 <Zemyla> I noticed that the latest parsers lib came out, and yet it still doesn't have ReadPrec.
13:03:45 <Pamelloes> levi: That's actually a really good explanation, thanks for linking that :)]
13:05:12 <voidzero> keep in mind that Applicative and Monad are separate things
13:05:18 <voidzero> <*> and pure: Applicative
13:05:33 <voidzero> bind (i.e. >>=) and return: Monad
13:06:40 <levi> The thing with Monad and Applicative instances is that if you're familiar with the types that you're considering the instances for, the instance methods tend to do some fairly normal/obvious things. The trick is remembering which ones.
13:06:46 <voidzero> also - next to this place #haskell there is an channel #haskell-beginners
13:08:18 <zachk> can't all monad's be made applicative, but not vice versa?
13:08:30 <voidzero> levi, yeah. I'm saying this because a friend was asking for help and I saw him using 'return' in an Applicative function with do notation
13:08:44 <levi> For Monad, sometimes the bind method is strange, but the join method is something obvious.
13:09:18 <voidzero> indeed
13:09:43 <levi> zachk: In GHC 7.10 and later, all Monads must also be Applicatives.
13:10:34 <zachk> doesn't pure = return? 
13:10:44 <voidzero> I read some document by simonpj that got into bind, he explained (getLine >>= putStrLn) very well
13:11:09 <zachk> >>= is kind of like unix pipe | 
13:11:17 <zachk> at least in the IO monad
13:11:23 <Gurkenglas> Is there something that can be deduced from Monad, which cannot be combined with pure to nail down the monad instance, but which can be combined with pure and <*> to nail down the monad instance?
13:11:26 <voidzero> :t (<|>)
13:11:27 <lambdabot> Alternative f => f a -> f a -> f a
13:11:28 <mniip> zachk, no, that'd be >=>
13:11:42 <mniip> >>= feeds a value into a function
13:11:55 <voidzero> a value in a context
13:12:33 <mniip> voidzero, it destructs a Kleisli arrow :P
13:13:01 <voidzero> yes hehe you are far ahead of me :D
13:13:14 <voidzero> :t (>=>)
13:13:14 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
13:13:29 <ski> zachk : `pure = return', at least assuming you want your `Applicative' and `Monad' instance to agree (so `(<*>) = ap')
13:14:15 <ski> (i'm of the opinion they ought to agree)
13:14:33 <zachk> one might want to be pathological....
13:15:44 <glguy> ski's opinion is also documented as a requirement http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Applicative
13:16:39 <ski> iirc, Cale had some counterargument. you could ask, if you feel like
13:30:47 <deech> Hi all, This is a haskell-mode/ghc-mod question. I occasionally get the follow error when trying to save a Haskell buffer in Emacs: ghc-check-syntax: ghc process may have hung or exited with an error. Googling got me to this issue: https://github.com/kazu-yamamoto/ghc-mod/issues/523 but I don't get how the reporter solved it. Has anyone else seen this?  
13:57:14 <srhb> deech: If you get no response here, you might try #haskell-emacs
13:59:17 <sshine> srhb, did you see HaskellR?
13:59:36 <srhb> sshine: I did. Very excited. I didn't install it yet though, slightly complicated here. :)
14:00:20 <sshine> srhb, I'm still at work, too, so... not sure what my use-case will be. trying to persuade Marianne to rewrite her thesis code in Haskell. ;)
14:01:23 <KaneTW> friend of mine was complaining about R's language recently and i linked him that
14:01:25 <sshine> srhb, maybe plotting. I don't ever plot.
14:01:28 <KaneTW> i hope he likes it
14:01:52 <srhb> sshine: Something along those lines. :)
14:02:22 <sshine> I guess R's runtime is still the same old kludgy thing where for-loops are memory-intensive.
14:08:01 <erktest> > "test"
14:08:02 <Sindriav_> There's #haskell-emacs? Jeez…
14:08:03 <lambdabot>  "test"
14:08:05 * hackagebot truthful 0.1.0.1 - Typeclass for truthfulness of values  https://hackage.haskell.org/package/truthful-0.1.0.1 (Shockk)
14:08:49 <Sindriav_> Does haskell support if-let?
14:09:38 <Cale> Sindriav_: What does that mean?
14:10:15 <Sindriav_> Cale: It's a common pattern in some languages. Basically testing whether a bind was successful
14:10:20 <Cale> if is an expression form, it can go anywhere that an expression would.
14:10:22 <Cale> let is as well
14:10:35 <Cale> There's no nontrivial interaction between the two.
14:10:57 <mauke> Sindriav_: let can't fail; case can
14:11:01 <Cale> Making definitions is always successful
14:11:09 <Sindriav_> ` if let (Just x) = readMaybe "…" then … else … `
14:11:19 <Cale> nope
14:11:22 <Cale> You want
14:11:22 <Sindriav_> Oh well.
14:11:26 <mauke> case readMaybe "..." of Just x -> ...; _ -> ...
14:11:29 <Cale> case readMaybe "..." of ...
14:11:32 <Cale> yep
14:11:38 <Sindriav_> I'm well aware of case, but thanks ^^
14:12:03 <Cale> When you put a pattern binding inside a let, it automatically becomes irrefutable
14:12:20 <Cale> Pattern match failures are deferred to evaluation of the bound variables.
14:12:45 <Sindriav_> I see
14:12:50 <Cale> (the binding is successful regardless, but your variable might be bound to an error)
14:13:48 <ski> Sindriav_ : redundant brackets
14:14:03 <Sindriav_> ski: Huh?
14:14:16 <ski> `let Just x = ...' works just fine
14:14:21 <Sindriav_> ski: I know, thanks
14:14:25 <ski> (in case you weren't aware)
14:14:43 <Sindriav_> ski: I used them in that case to emphasize what it should do (destructuring) :)
14:14:45 <ski> oh, apologies, then
14:15:01 * ski doesn't understand that
14:18:06 * hackagebot bytestring-plain 0.1.0.2 - Plain byte strings ('ForeignPtr'-less 'ByteString's)  https://hackage.haskell.org/package/bytestring-plain-0.1.0.2 (HerbertValerioRiedel)
14:20:47 <scshunt> Sindriav_: perhaps you want the function `maybe'
14:21:20 <Sindriav_> scshunt: Not really. All I asked about was whether or not Haskell syntax supports the if-let pattern, that's all.
14:29:46 <greg`> not much activity on the haxl project of late, has it been superceded by something more new and more shiny?
14:31:26 <johnw> greg`: Marlow just gave a presentation on Haxl at CUFP
14:31:43 <johnw> there may not be as much activity because they're actually using it heavily and it works
14:32:10 <greg`> lol , sorry im not used to software being so reliable
14:32:55 <greg`> i think i may use it then
14:33:15 <greg`> johnw: do you have a link to the presentation?
14:33:25 <johnw> I didn't see a camera those days :(
14:34:02 <greg`> gah!
14:34:44 <greg`> ill watch one from 2014 to get the gist
14:37:08 <d-snp> ohhh I'm so close I can almost taste it
14:37:32 <greg`> d-snp: close to what?
14:38:07 <d-snp> http://pastie.org/10403866 <-- this is the IR my C compiler generates
14:38:16 <d-snp> sort of
14:38:22 <d-snp> after some snipping of useless stuff :P
14:38:32 <d-snp> it's very close to being correct
14:39:21 <d-snp> though making it correct requires me to add an awful feature I'm not sure about yet
14:52:24 <harlchen> hello,  why does ( read "aaaaaa" :: StdGen ) work, but ( read "aaaaaaa" :: StdGen ) does not ?
14:52:58 <harlchen> in System.Random 
14:55:22 <slack1256> harlchen: what is the difference? an extra 'a' right?
14:55:28 <harlchen> yes
14:56:51 <MedDev> harlchen, probably has to do with how the seed is represented as a string. it looks like in the source the function stdFromString uses the "splitAt 6" so it's expecting a string with a length in a multiple of six
14:57:07 <MedDev> harlchen, http://hackage.haskell.org/package/random-1.1/docs/src/System-Random.html#StdGen look at stdFromString in this file
14:57:46 <arkeet> not multiple
14:57:54 <arkeet> splitAt just splits off the first 6 elements
14:57:59 <arkeet> characters
14:59:11 <chreekat> But, that being the case, there are leftovers when the string is 7 chars, so overall i think 'read' would fail, right?
14:59:11 <MedDev> arkeet, you're correct
15:00:12 <KaneTW> > read "aaaaaaa" :: StdGen
15:00:13 <lambdabot>  *Exception: Prelude.read: no parse
15:01:03 <arkeet> > (reads :: ReadS StdGen) "aaaaaaa"
15:01:05 <lambdabot>  [(36038 1,"a")]
15:01:25 <arkeet> yeah it has a weird Read instance
15:01:56 <KaneTW> Read doesn't even make a lot of sense for StdGen
15:02:31 <harlchen> so maybe i should use mkStdgen with my own String -> Int .
15:02:32 <arkeet> > read (show (StdGen 123 1)) :: StdGen
15:02:34 <lambdabot>      Not in scope: data constructor ‘StdGen’
15:02:34 <lambdabot>      Perhaps you meant variable ‘mkStdGen’ (imported from System.Random)
15:02:36 <arkeet> oh.
15:02:52 <arkeet> > read (show (mkStdGen 123)) :: StdGen
15:02:53 <lambdabot>  124 1
15:03:01 <arkeet> > mkStdGen 123
15:03:03 <lambdabot>  124 1
15:03:08 * hackagebot truthful 0.1.0.2 - Typeclass for truthfulness of values  https://hackage.haskell.org/package/truthful-0.1.0.2 (Shockk)
15:03:08 <arkeet> yeah
15:03:17 <harlchen> okay, thx
15:03:19 <ski> probably `Show StdGen' should output something in terms of `mkStdGen' (if possible ?) ?
15:03:20 <KaneTW> In general, the Read instance of StdGen has the following properties:
15:03:22 <KaneTW> It guarantees to succeed on any string.
15:03:26 <KaneTW> sounds like a bug to me
15:03:41 <arkeet> only upon using reads, not read
15:03:42 <arkeet> It guarantees to consume only a finite portion of the string. 
15:03:52 <KaneTW> oh
15:03:58 <chreekat> > read "a" :: StdGen
15:03:59 <KaneTW> so basically it's read being read
15:03:59 <lambdabot>  101 1
15:04:17 <chreekat> > reads "a" :: StdGen
15:04:19 <lambdabot>      Couldn't match expected type ‘StdGen’
15:04:19 <lambdabot>                  with actual type ‘[(a0, String)]’
15:04:19 <lambdabot>      In the expression: reads "a" :: StdGen
15:04:22 <arkeet> the only real thing expected of a Read instance is that read (show x) = x
15:05:30 * ski also expects `reads = readsPrec 0'
15:05:52 <arkeet> well ok.
15:05:53 <KaneTW> > read . show $ mkStdGen (2^30 :: Int)
15:05:55 <lambdabot>  *Exception: Prelude.read: no parse
15:06:03 <KaneTW> > mkStdGen (2^30 :: Int)
15:06:03 <arkeet> > read . show $ mkStdGen (2^30 :: Int) :: StdGen
15:06:04 <lambdabot>  1073741825 1
15:06:05 <lambdabot>  1073741825 1
15:06:11 <KaneTW> oh
15:06:13 <KaneTW> right
15:09:08 <raulfpl> I heard about a tool that uses cabal for seting up projects but also download a local ghc with the version required by the project. 
15:09:19 <raulfpl> does anyone know the name of such tool?
15:09:59 <srhb> That might be stack, I suppose.
15:10:06 <zachk> stack or stackage or osmething like that
15:10:35 <raulfpl> thanks
15:16:39 <arkeet> root
15:28:24 <Shockk> hello, I wanted to ask about a problem I'm having with my package on hackage
15:29:00 <srhb> Ask away.
15:29:02 <Shockk> the build log for it seems to suggest that it's unable to resolve base 4.8
15:29:05 <Shockk> https://hackage.haskell.org/package/truthful-0.1.0.2/reports/1
15:29:33 <Shockk> I've got a constraint on base >=4.8 && <5.0 which I'd expect should work 
15:30:09 <srhb> Shockk: base 4.8 is ghc 7.10, is it not?
15:30:14 <Shockk> srhb: it is
15:30:27 <glguy>  That just means that hackage tried to build it with GHC 7.8.something and it was incompatible
15:30:52 <Shockk> is there a way to get hackage to build it with GHC 7.10?
15:31:22 <glguy> No. Eventually it will use 7.10 to build
15:31:23 <Shockk> I tried adding the tested-with field to the cabal file and specified ghc 7.10 there but that didn't make a difference
15:31:30 <Shockk> ohhhh
15:31:39 <glguy> You can upload your own docs, but today it's not using 7.10
15:31:39 <Shockk> right
15:31:48 <Shockk> oh, I can?
15:32:13 <glguy> Yeah, you can use my script. Run it in the directory with your package's cabal file and with your hackage username as the argument
15:32:13 <glguy> https://github.com/ekmett/lens/blob/master/scripts/hackage-docs.sh
15:33:34 <Shockk> glguy: ooh, thanks, I'll try that 
15:34:37 <greanbeen> So, Haskell was Dijkstra's favorite first language because it shows programmers that there's more to programming than just imperative langauges?
15:34:39 <greanbeen> That's it?
15:35:13 <ReinH>  That's what?
15:35:28 <greanbeen> That's his only reasoning?
15:35:36 <ReinH> I guess you should ask him
15:35:59 <Shockk> glguy: I ran that script and it seems to be stuck after the line:  truthful-0.1.0.2-docs/truthful.txt
15:36:26 <greanbeen> It's not a compelling argument, which is why he probably failed (in keeping Haskell as the first language at his school).
15:36:30 <Shockk> has been there for 3 minutes, unless it just takes a while to do something
15:36:52 <glguy> Shockk: It's usually pretty fast. You can paste the output up to that point if you want to lpaste.net
15:37:08 <srhb> greanbeen: There were probably many more reasons than that that he failed.
15:39:12 <Shockk> glguy: http://lpaste.net/5405761373365862400
15:39:49 <Shockk> if it makes a difference, I'm running this on windows in cygwin
15:40:17 <glguy> that might make a difference. I don't use Windows for anything but playing Eve Online and Minecraft
15:40:40 <Shockk> what should happen after that point in the output?
15:42:12 <glguy> It should probably be uploading at that point
15:42:17 <glguy> with the curl command
15:42:30 <Shockk> hmm
15:45:09 <glguy_> You can always try stepping through the script by hand, or maybe someone else knows about windows issues
15:45:43 <Shockk> I added an echo before the curl command and it shows, so it's curl that it's getting stuck on
15:49:24 <Shockk> hm, glguy_ is it supposed to run this command? http://lpaste.net/488752220129460224
15:49:41 <Shockk> the @build-docs part looks-
15:49:42 <Shockk> oh
15:51:09 <Shockk> glguy`: is it supposed to run the above? the @build-docs bit looks the most out of place to me but I don't know if that's intended or if it gets interpreted differently by bash on other platforms
15:53:09 * hackagebot react-flux 0.9.4 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-0.9.4 (JohnLenz)
15:53:12 <Shockk> oh, I'm not using cygwin curl, that would explain it I think
15:55:27 <glguy`> I can run it when I get back to my computer for f output
15:55:31 <glguy`> Sample
15:57:24 <emmanuel_erc> hello there everyone!
15:59:30 <Shockk> glguy`: out of interest, what license(s) is that script under?
16:00:18 <Shockk> specifically if I wanted to include the script in my own repositor(y/ies) would I be required to credit in a specific way?
16:03:31 <glguy`> Whatever license lens has. If that's too restrictive I can do whatever
16:04:21 <glguy`> A link to the original would be nice in case I update it but not required
16:04:27 <Shockk> hmm, ah that's under bsd3, okay
16:04:31 <Shockk> er, bsd 3 clause*
16:13:53 <cow_2001> trying to make sense out of this http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
16:28:20 <pavonia> cow_2001: What part don't you understand?
16:28:54 <cow_2001> i just don't understand what's going on :|
16:29:10 <cow_2001> i don't know which part is it that i do not know
16:30:14 <Sindriav_> cow_2001: If you read through that carefully and still don't understand free monads (at least on a basic level), maybe you should start with something more general?
16:31:55 <cow_2001> i'm going through the typeclassopedia exercises
16:32:37 <shachaf> If you read that article carefully and you still don't understand the topic, maybe you should read a different article on the same topic.
16:33:28 <cow_2001> i should retreat to a less advanced subject
16:33:36 <cow_2001> RUN AWAY RUN AWAAAAY!!
16:33:55 <cow_2001> /monty python reference
16:34:25 <cow_2001> the vampire queen had suggested i do some more functor exercises
16:36:00 <levi> The free monad basically turns a Functor into a Monad by recording the 'return' and 'bind' calls into a data structure along with their arguments. You can then later 'interpret' the free monad structure via a tree-walking function.
16:40:41 <levi> This is analogous to how the [a] instance for Monoid works; mempty provides an empty list and mappend appends a list of some elements to another list. The list data type happens to have data constructors that correspond exactly to the Monoid operations; the free monad is that data type that has data constructors corresponding to the Monad operations.
16:43:54 <ttt_fff> for migration.ex files, what is difference of "change" vs "up/down"
16:43:58 <ttt_fff> wrong channel
16:44:21 <shachaf> I wouldn't say that the [] turns a type into a monoid.
16:44:51 <shachaf> I also wouldn't say that []'s data constructos correspond exactly to the Monoid operations.
16:45:16 <levi> Perhaps my wording was off, would you care to clarify?
16:45:21 <ttt_fff> forall a. Monoid (List a), not [] a
16:45:56 <ttt_fff> it's "List" (the type constructor), not [] (the alias for Nil) which turns "a" into a Monoid
16:46:06 <cow_2001> [] is * -> * [a] is *
16:46:10 <cow_2001> :D
16:46:10 <hiatch> share somethigy
16:46:45 <hiatch> zenzike you suspect me?
16:47:49 <shachaf> levi: Monoid's operations are mempty and mappend, []'s constructors are [] and (:)
16:48:06 <shachaf> Maybe I'm too pedantic in both of these cases.
16:48:07 <levi> If you look at what I said, you'll see I said there's an analogy between 'the [a] instance for Monoid' and the free monad.
16:48:27 <shachaf> Yes, there's certainly an analogy.
16:48:30 <levi> You're right that the constructors don't correspond exactly, though.
16:48:57 <levi> But they're close enough that the list type is often referred to as the 'free monoid' type.
16:49:28 <shachaf> It is the free monoid type.
16:49:45 <shachaf> You have the same relationship with []'s constructors and with Free's constructors.
16:50:35 <levi> That's pretty much what I said, modulo the 'exactly' bit describing the correspondence.
16:51:43 <levi> cow_2001: Anyway, you didn't respond to what I initially said; was it helpful, or are you still confused?
16:52:29 <cow_2001> levi: very confused. i'll go through the NICTA exercises before going through the typeclassopedia
16:53:08 <Tuplanolla> Confused, but more profoundly so? That's called learning.
16:54:14 <levi> cow_2001: Was there some aspect of what I said that was confusing, or did it just fail to relate to your general confusion?
16:54:48 <levi> It's hard to help without specific feedback as to what you're not getting.
16:55:34 <cow_2001> recording the return and bind calls? how?
16:55:49 <levi> By building a data structure.
16:56:26 <SirCremator> hello everyone
16:56:32 <SirCremator> first time user here. :)
16:56:33 <levi> Like how the Monoid [a] instance builds a data structure out of mempty and mappend calls.
16:56:34 <cow_2001> could you demonstrate it with the [] Functor?
16:58:18 <levi> Note how Monoid [a] is rather different than Monoid Sum; Sum holds Num types and adds them together during mappend, while Monoid [a] holds each individual element that's mappended.
16:58:35 <ski> SirCremator : hello
16:59:01 <SirCremator> how's everyone doing? 
16:59:05 <ski> SirCremator : if you have (haskell-related) questions, just ask, and wait
16:59:33 <SirCremator> i dont have any questions. i just wanted to see what it was all about. 
16:59:49 <ski> are you interested in Haskell ? or programming ?
17:00:08 <SirCremator> yes
17:00:31 <Shockk> good answer
17:00:38 <SirCremator> i'm very new to everything. i can build a computer but i can't write a code for a computer. :)
17:00:42 <ski> many people idle in here, sometimes lurking and reading what others say, possibly learning. sometimes chiming in themselves
17:01:20 <ski> sometimes the channel is more busy, sometimes less
17:01:43 <glguy> Shockk: Did you figure things out?
17:01:45 <Sindriav_> Man, I really wish I could treat types as values in Haskell.
17:02:06 <Shockk> glguy: oh, I don't know why it was happening, but I fixed it by installing the cygwin version of curl
17:03:01 <ski> SirCremator : (assuming you're new to IRC) one of the most common mistakes newbies make is leaving too early, after saying something, before anyone has had a chance of reacting. waiting half an hour (or more) is better
17:03:06 <ski> SirCremator : have fun
17:03:37 <SirCremator> yes. i understand. I went on the original IRC about 15 yrs ago. 
17:03:50 <SirCremator> I was more of a pirate and did warez websites. :P
17:04:15 <ski> (not a cracker or a demoscener, then ?)
17:04:38 <ski> (also, fyi, this channel is (publicly) logged)
17:04:55 <Shockk> lol
17:04:57 <SirCremator> no...i dont do anything risky anymore....with age comes less risk. haha
17:05:08 <SirCremator> now i just pay bills. :P
17:05:25 <SirCremator> er i mean, with age comes more liability.
17:05:25 * ski isn't sure how the demo scene would be considered risky in this sense
17:05:58 <SirCremator> i certainly remember using proggies on american online. 
17:07:00 <ski> if you haven't seen them yet, you might want to try one of the Haskell tutorials or books
17:07:05 <inininin> Has anyone ever seen this "can't load .so/.DLL for:" error before? http://lpaste.net/edit/140448
17:07:56 <SirCremator> i've never actually heard of haskell programming. how old is it?
17:08:12 <Shockk> 1990
17:08:23 <SirCremator> wow. can't believe i've never heard of it. 
17:08:23 <Shockk> latest stable release 2010
17:08:32 <arkeet> (it's evolved a fair bit since 1990)
17:09:00 <jmcarthur> that 2010 release is of the language definition, not the compiler, by the way
17:09:12 <Sindriav_> The so called "Haskell Report"
17:09:22 <SirCremator> anyway guys, the main reason why i'm in here...i'm 30 now, out of high school i took the construction route in the work force. currently going back to school at night for computers.
17:09:45 <hpc> it took you that long to finish high school? ;)
17:09:53 <SirCremator> i was debating still to either do computer science or just do networking/admin as a major. any suggestions? computer science looks pretty intimidating.
17:10:10 <SirCremator> haha
17:10:15 <MedDev> computer science is very math heavy
17:10:18 <SirCremator> i wish i was in high school for that long.
17:10:21 <hpc> CS is cheaper to get into, too
17:10:41 <hpc> you can build experience on the couch in your underwear
17:11:00 <hpc> you don't have to deal with physical hardware
17:11:06 <MedDev> very true
17:11:17 <Sindriav_> hpc: You don't have to do that with sysadmin stuff either, arguably
17:11:18 <hpc> it's also more fun
17:11:21 <glguy> Might be better for #haskell-blah
17:11:23 <Sindriav_> hpc: Though it's much more useful
17:11:28 <Sindriav_> glguy + 1
17:11:34 <SirCremator> yea. i can build a computer no problem...the code/programming, i never got into. 
17:12:20 <Hijiri> @where learnhaskell
17:12:20 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:12:33 <hpc> bringing it a bit back on topic, check out http://tryhaskell.org/
17:12:36 <MedDev> SirCremator, you may want to look at a more marketable language. sure it looks good to have haskell on a resume but good luck finding a haskell job and even then it's going to be applied to by a lot of very qualified people
17:12:41 <MorpheusB> anyone have example working hpdf program I can look at or point me to one please
17:13:20 <hpc> if you need other languages that are good to get started with, ask in -blah
17:13:30 <hpc> it's always a fun question to answer
17:13:34 <Shockk> imvu make use of haskell interestingly
17:13:57 <Shockk> I know someone who got into working there and they use haskell for stuff behind scenes 
17:16:01 <SirCremator> what kind of popular programs/software used haskell?
17:16:37 <MedDev> FB uses it internally, imvu as mentioned, many financial institutions
17:17:38 <Shockk> there's a program/library used to convert documents from one format to another (for example markdown to html or microsoft word to latex or etc) called pandoc
17:17:55 <hpc> i vaguely recall EVE Online using it for backend stuff, but i looked recently and couldn't find where i heard it
17:18:04 <MedDev> xmonad (a tiling window manager) too which I use every day
17:18:05 <Shockk> there's also a windowing manager for linux called Xmonad
17:18:28 <Shockk> main = medDev $ high5
17:18:46 <Shockk> really bad joke
17:18:51 <Shockk> I applied high5 to medDev
17:18:53 <hpc> you'll occasionally find places where they don't really care what language you use
17:19:05 <MedDev> yeah
17:19:18 <hpc> and i am sure there's a good deal of internal one-off haskell thingies that nobody ever feels worth mentioning
17:19:27 <MedDev> i use it all the time for scripts
17:19:51 * Shockk is writing a game engine in haskell right now
17:19:51 <kadoban> I notice hakyll a decent number of places, I'm sure yesod is used in many places.
17:20:03 <hpc> i wrote one for my job that ended up not being used because it was just a refactor
17:20:14 * MedDev wonders how common yesod really is
17:20:23 <SirCremator> are you guys employed in the computer industry? or do it as a hobby?
17:20:32 <AshyIsMe> SirCremator: Yes.
17:20:40 <hpc> some of us are
17:20:48 <hpc> some are students, some are professors / researchers
17:21:03 <Arahael> SirCremator: And some of us are, but are only tangentially interested in haskell.
17:21:10 <Shockk> right now I'm on a computer games university course and all of that's in like C++ and occasionally C# or Java
17:21:20 <Shockk> but I learned about haskell in my spare time
17:21:26 <MorpheusB> me - use for ancient brain training exercise
17:21:36 <SirCremator> any of you work in Silicon Valley or from?
17:21:43 <SirCremator> I live in the San fran bay area.
17:21:52 <SirCremator> the economy here is booming.
17:22:08 <hpc> i think we have a few
17:22:14 <hpc> out of 1480
17:22:17 <Shockk> lol
17:23:05 <Arahael> I never understood the silicon valley thing.
17:23:13 <hpc> it's just a place where jobs are
17:23:19 <Arahael> Software dev is *uniquely* suited to internet telecommuting.
17:23:23 <hpc> they were a big place to be in the 90s
17:23:24 <MedDev> i'd rather work remotely and live way more lavishly on the salary i got
17:23:35 <MorpheusB> What I am looking for is not document conversion using pandoc, but more information with practical examples on https://hackage.haskell.org/package/HPDF-1.4.8/docs/Graphics-PDF-Documentation.html for entering personal info and producing pdf with embedded text around the personal information
17:23:36 <hpc> before people knew what a tele-anything was
17:23:36 <Arahael> MedDev: That is my dream.
17:23:45 <hpc> people carried their keyboards uphill both ways
17:23:52 <MorpheusB> I live remotely, but every day get up and get retired
17:24:03 <hpc> and when they invented DNS they had to reboot the internet
17:24:13 <SirCremator> haha
17:24:21 <SirCremator> man those dial up days.....
17:24:33 <SirCremator> "son get off the internet! i have to use the phone!"
17:24:38 <Shockk> aha that dialup noise
17:24:52 <Shockk> ee, aa, pe tang pe tang 
17:24:57 <MorpheusB> solved with 2 telephone lines or ISDN which was painfull
17:24:58 <SirCremator> hhaha
17:25:12 <MedDev> i felt like such a badass when i used my paper route money to pay for a 2nd line at our house so i could be online without tying up the phone
17:25:19 <hpc> iirc silly valley was where a lot of hardware innovation came from, hence the name
17:25:23 <Arahael> The point remains: Software dev is currently really suited to telecomuting.
17:25:25 <SirCremator> yea well, it was difficult enough to have 1 phone line for the parents to pay for.
17:25:39 <hpc> today it'd probably be called "cloud valley" which sounds too much like a gated mcmansion community
17:25:44 <MorpheusB> Ahh but I was the parent!
17:26:12 <MedDev> Arahael, there's something to be said about working face to face in a team though IMO
17:26:31 <Arahael> MedDev: Yes, I suppose so.  But is that worth the daily commute?
17:26:34 <hpc> also that, enough of programming jobs is nonprogramming stuff that you do still need to be physically there
17:26:54 <MedDev> Arahael, again it depends where you live
17:27:10 <MedDev> i wouldn't mind commuting in my current metro area because it's small (~350k people)
17:27:10 <Arahael> MedDev: Anywhere there's traffic.
17:27:22 <hpc> it's a bit more convenient for taxes/insurance/time zones
17:27:35 <hpc> and the good old "they aren't working if i can't see them" which still exists
17:27:48 <Arahael> MedDev: I dream of being able to buy a house.  But the cheapest within an hour's commute is...  Roughly $600k for a 2-bedroom.
17:27:56 <hpc> and people don't answer emails
17:28:09 <MedDev> Arahael, move to the midwest :D cheap to live in WI and MN if you can withstand the winters
17:28:19 <Arahael> MedDev: I'm in Sydney, Australia.
17:28:34 <hpc> midwest winters aren't so bad
17:28:42 <hpc> it tends to be colder, but easier to deal with
17:28:44 <MedDev> Arahael, well there's your problem! if your sink just drained the other way we could avoid all this
17:29:00 <MedDev> hpc, you can always put more clothes on but can't take more off
17:29:14 <Arahael> MedDev: The crazy thing is, you could buy a place for $150k anywhere else in the country, just about.
17:29:20 <hpc> and everyone in the area generally knows how to deal with it too
17:29:36 <hpc> in DC, you get an inch of black ice instead of 6 inches of snow
17:29:42 <hpc> and everyone is still going normal speed
17:29:49 <hpc> (which is about 10 over the limit)
17:29:53 <Arahael> MedDev: Yet, Sydney is insane.
17:30:07 <MorpheusB> Arahael: I am north of you and inland, houses out here in smaller towns pretty cheap, lots now have nbn provided fibre
17:30:11 <MedDev> Arahael, any major area in the US is going to be similar.
17:30:32 <hpc> anyway, there's much more midwest than just WI/MN
17:30:44 <hpc> you managed to pick canada junior when you could also go to texas junior
17:30:52 <hpc> or texas, which somehow has a tech industry
17:31:19 <glguy> For general discussion beyond Haskell programming you can use #haskell-blah
17:31:21 <Arahael> MedDev: I doubt it.  Do the major areas have a million-dollar average house price?
17:31:45 <MedDev> Arahael, SF, NYC, and Seattle yes
17:32:36 <Arahael> MedDev: Just took a look, Seattle has some places available for less than $300k.
17:32:40 --- mode: ChanServ set +o glguy
17:33:14 <pacak> #haskell-blah?
17:33:19 <glguy> yup
17:36:15 <SirCremator> what's the best programming language to learn? 
17:36:28 <Xe> SirCremator: Modula-3
17:36:34 <SirCremator> what's also a beginning language?
17:36:44 <SirCremator> a good beginning language
17:36:55 <glguy> SirCremator: Please take the general questions to #haskell-blah
17:37:04 <glguy> This channel is specifically for Haskell programming discussion
17:37:11 <SirCremator> oh sry
17:37:54 <Zekka> SirCremator: #yfl may be able to help you with these questions
17:38:01 <Cale> SirCremator: Haskell is not a bad language to start with, imo
17:38:28 --- mode: glguy set -o glguy
17:38:32 <Zekka> (#yfl is the polyglot programming channel -- meaning that it's dedicated to working in a lot of languages)
17:38:45 <inininin> SirCremator: Python would be great as a first language. It's easy, it's simple, and it has a lot in common with more elaborate languages, including Haskell
17:39:31 <Zekka> (FWIW #yfl has a heavy Prolog and Erlang bias, although I have a feeling that's not what they'll recommend you, depending on what you're trying to do)
17:40:55 <Zekka> I could probably come up with some kind of answer for you but other people don't agree with my opinions on this so I'd rather defer to them
17:41:42 <Zekka> (That's a silly thing to say, but I don't really have strong opinions unless you qualify your question with "I am trying to do [X]")
17:42:16 <Alpha64> anything is good, really, it's like asking "what's the best song to learn?", once you are comfortable with one, you develop your taste
17:42:41 <levi> cow_2001: Probably the best way to 'get' what the free monad does is to look at Monad in terms of fmap, return, and join. You can get fmap and return straight from the Functor instance, but 'join' provides the 'monad-ness' by combining nested layers of the functor into a single layer of the functor.  I.e. join :: m (m a) -> m a; so with the list monad it's specialized to [[a]] -> [a].  We can't use the list
17:42:42 <levi> monad as the free monad because the 'join' for lists relies on knowing how to collapse a nested list into one list layer. Once you've done that, the information about where the boundaries of the nested lists were is lost. It's like how Monoid Sum loses the information about what numbers led to the summation. We want a list-like data structure that preserves the sources of the layers as they're combined in
17:42:44 <levi> the monad's 'join'.
17:43:45 <Zekka> SirCremator: If it makes a differene, I can recommend *not* picking up PHP, C++, C, or a Visual Basic variant
17:44:00 <SirCremator> ty
17:44:49 <SirCremator> i was focused on the networking/admin side of computer too, it seemed more attainable, since computer science have a huge math load. 
17:44:51 <Zekka> I'll slide on C but for programming projects that aren't super specific those languages are IMHO hard-to-use or deceptive
17:45:00 <Sindriav_> How would I unwrap `data Component = forall a. Typeable a => MkComponent a` back into `a` ?
17:45:22 <Zekka> SirCremator: With that existential you can't really say what a is
17:45:27 <Zekka> all you know is that it's Typeable
17:46:18 <Zekka> SirCremator: Most languages people would still recommend you aren't targeted specifically at math, etc.
17:46:42 <Zekka> Are you interested in a language that has good unix integration?
17:47:02 <Shockk> Sindriav_: you can check if some Component you have is of a specific type by using fromDynamic
17:47:06 <Zekka> If so, C might be back in the running. It's possibly Python, Perl or Ruby might work too, although Perl is not used that much lately
17:47:14 <Shockk> :t fromDynamic
17:47:15 <lambdabot> Typeable a => Dynamic -> Maybe a
17:47:48 <Cale> IMO the only reason to learn C now is if there's an existing project you want to work on and it's written in C.
17:48:03 <Shockk> the a there is inferred by how you use the result, so you still need to know the type you're checking for
17:48:11 <Shockk> and if it returns Nothing, that means it's not of that type
17:48:11 <Zekka> (might move this to #haskell-blah or #yfl like I brought up earlier)
17:48:20 <Cale> yeah, might be a good idea to move to -blah
17:56:00 <Sindriav_> Cale: I think you're talking about C++. There are plenty of pragmatic reasons for C, still.
17:56:17 <shachaf> This is not the channel for that.
17:57:04 * Arahael twitches, really wanting to contribute to the C++ convo.
18:03:27 <dmwit> :t cast
18:03:28 <lambdabot> (Typeable a, Typeable b) => a -> Maybe b
18:04:02 <dmwit> (i.e. no need to stick it in a Dynamic first)
18:04:09 <Cale> heh, and Sindriav_ isn't even in #haskell-blah, so he won't have seen my response there :)
18:14:12 <clintm> Are stack questions ok here, or is there a better channel for them?
18:16:14 <bergmark> clintm: was just a discussion about that, seems stackoverflow is the preferred place
18:16:32 <clintm> bergmark: ok, thanks!
19:38:18 * hackagebot pinboard 0.8.5 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.8.5 (jonschoning)
19:55:35 <Pamelloes> Is there a readMaybe function anywhere? Hoogle turns up one in Network.CGI but that's a weird place so I'm skeptical.
19:56:26 <shachaf> Text.Read
19:56:53 <Pamelloes> Awesome :)
20:01:13 <Cale> Pamelloes: It might also be worth knowing about readMay from the safe package.
20:01:34 <Cale> Pamelloes: and there's reads from the Prelude (but it produces a list of parses, rather than a Maybe)
20:03:10 <Pamelloes> Interesting. ReadS looks like more than what I need, right now but I'll keep that in mind. What's the advantage of readMay over readMaybe?
20:04:31 <Bashmetim> I have a weird pedagogical question... What's with haskell people defining trees like this:
20:04:31 <shachaf> Cale: Why not just Text.Read.readMaybe?
20:04:34 <Bashmetim> data Tree a = Leaf a | Node (Tree a) (Tree a)
20:06:42 <Cale> shachaf: What's the type of that?
20:06:55 <shachaf> :t Text.Read.readMaybe
20:06:57 <lambdabot> Read a => String -> Maybe a
20:07:08 <Cale> oh, hah
20:07:14 <Cale> I was thinking Data.Text
20:07:28 <shachaf> Control.Text.Read
20:16:25 <cdk> I'm taking a look at ocharles' new SDL bindings and noticed that foldFlags https://github.com/haskell-game/sdl2/blob/master/src/Data/Bitmask.hs is simply foldMap for a suitable "logical or" monoid ((.|.), 0). I was surprised such a monoid, as well as the corresponding "logical and", aren't a part of Data.Monoid already. Is this just an oversight?
20:17:47 <wtfhaskell> Hello
20:18:44 <wtfhaskell> Well, I am trying to compile ghc7 under NetBSD and get the following error: 
20:18:45 <wtfhaskell> ERROR: Put your trusted bootstrap archive as /usr/distfiles//ghc-7.6.3-boot-i386-unknown-netbsd.tar.xz
20:18:55 <wtfhaskell> What do I do?
20:20:29 <glguy_> Probably put the aforementioned file in the aforementioned place
20:20:46 <wtfhaskell> But... Where do I take this file from?
20:23:42 <wtfhaskell> Anyone had this fucking issue before?
20:24:46 <Pamelloes> wtfhaskell: You can probably download the binary you want from https://www.haskell.org/ghc/download_ghc_7_6_2
20:25:28 <wtfhaskell> So does that mean that the NetBSD port is messed up? :P
20:26:02 <Pamelloes> GHC is self compiling so you need a ghc binary to get started. 
20:26:11 <Pamelloes> I'm not sure how well things work on NetBSD, though.
20:26:17 <glguy_> Watch you language please. Netbsd isn't one of the platforms that GHC has a binary for, but it does appear to be in the netbsd package list
20:26:37 <glguy_> Pkgsrc 
20:26:52 <wtfhaskell> Yeah, pkgsrc. And?
20:27:15 <Pamelloes> Is there a good method for limitting a bytestring to alphanumeric chars + "-"?
20:27:35 <glguy_> And so that might be your best bet for getting a working GHC install on netbsd
20:27:35 <wtfhaskell> BTW I am trying to get this to compile since liek 3 hours, so don't tell me what to do...
20:28:05 <glguy_> Once you have a working GHC you can compile more
20:28:41 <jle`> Pamelloes: by the way, the index on the official hoogle is significantly outdated
20:28:58 <jle`> Pamelloes: but there's a preview version with an up-to-date index at http://hoogle.haskell.org/
20:29:24 <wtfhaskell> One more question: Why does this language is so big? :P
20:29:35 <wtfhaskell> The source is like ~2GB in size
20:29:45 <jle`> wtfhaskell: ah do you mean GHC, the compiler?
20:29:51 <wtfhaskell> Yes
20:29:55 <Pamelloes> jle`: oh, that's exciting! :D
20:30:30 <jle`> the new one's index is suspended until the new version of hoogle becomes officially released or something, but it's been quite a while now in that limbo
20:30:39 <glguy_> The source isn't 2GB
20:30:41 <jle`> *the old one's index
20:30:47 <wtfhaskell> What's a hoogle?
20:30:49 <Pamelloes> This new version is super fast :)
20:31:13 <wtfhaskell> glguy: Well, I am saying what I see, source+depends~2GB
20:31:18 <jle`> wtfhaskell: search engine for haskell API, documentation, reverse type signature lookups :)
20:31:38 <wtfhaskell> Why would you even need something like that? :P
20:31:39 <jle`> API/documentation of libraries
20:31:50 <wtfhaskell> A search engine for the API lol
20:32:06 <jle`> wtfhaskell: not for haskell itself, but for every library on hackage
20:32:11 <jle`> but it's also useful to search by type signatures
20:32:16 <Pamelloes> It's super helpful.
20:32:21 <wtfhaskell> I see
20:32:22 <jle`> for example, you might want to ask, "how do i turn a Char into an Int?"
20:32:26 <jle`> so you can search for `Char -> Int`
20:32:27 <jle`> and voila :)
20:32:51 <jle`> @hoogle Char -> Int
20:32:53 <lambdabot> Data.Char digitToInt :: Char -> Int
20:32:53 <lambdabot> Data.Char ord :: Char -> Int
20:32:53 <lambdabot> Data.Text.Internal.Read digitToInt :: Char -> Int
20:33:09 <jle`> or you can ask "how do i map an (a -> b) function over a list of [a]'s", so you can just search for (a -> b) -> [a] -> [b]
20:33:18 <wtfhaskell> Are there any other Haskell compilers?
20:33:24 <wtfhaskell> I feel like ghc sucks
20:33:28 <jle`> no serious ones that are still maintained at the moment
20:33:36 <jle`> but GHC is probably one of the most amazing pieces of engineering i've ever seen
20:33:37 <wtfhaskell> Bad design choices there :P
20:33:37 <jle`> in my entire life
20:33:44 <jle`> hm, like what?
20:34:12 <wtfhaskell> Like I cannot gcc this bitch and it wants some binary that I don't have :P
20:34:28 <jle`> hm, building is a bit tricky, but few people actually build it...
20:34:40 <jle`> whatever system you have probably has a pre-compiled binary on the website
20:34:42 <bitemyapp> wtfhaskell: almost nobody builds their own copy of GHC from source.
20:34:51 <wtfhaskell> Well, I do
20:35:00 <jle`> i don't think anybody has built GHC from since the 90's
20:35:00 <wtfhaskell> Make a binary for NetBSD :P
20:35:12 <bitemyapp> wtfhaskell: GHC is itself written in Haskell -- it's a bootstrapped compiler. You need a binary whether you want to build from source or not.
20:35:25 <wtfhaskell> My entire system+programs are built from source
20:35:29 <wtfhaskell> lol
20:35:33 <bitemyapp> wtfhaskell: https://ghc.haskell.org/trac/ghc/wiki/Platforms#Tier3platforms
20:35:40 * Pamelloes has, unfortunately, compiled GHC too many times to count :(
20:35:42 <bitemyapp> netbsd worked before, probably doesn't work now.
20:35:45 <Pamelloes> Stupid nix.
20:35:53 <bitemyapp> People didn't maintain the netbsd version, so it fell into disrepair.
20:36:04 <wtfhaskell> Pamelloes: Who do you call stupid, Windows kid?
20:36:13 <bitemyapp> wtfhaskell: manners.
20:36:28 <wtfhaskell> Yeah, exactly :P
20:36:31 <bitemyapp> wtfhaskell: the atmosphere here is generally friendly, collegial, and professional.
20:36:41 <bitemyapp> wtfhaskell: acting out will not get you help. be nice.
20:36:55 <wtfhaskell> Cannot I even make a joke?
20:37:00 <wtfhaskell> You are too stiff to be alive
20:37:05 <bitemyapp> wtfhaskell: fine, leave.
20:37:09 <chreekat> Jokes translate poorly in text chat
20:37:25 <bitemyapp> the mistake rude people make is in holding their own company hostage
20:37:26 <wtfhaskell> Ehh, poor folks
20:37:30 <bitemyapp> nobody cares if you shoot the hostage
20:37:40 <Pamelloes> hehe
20:37:58 <Pamelloes> Not all jokes translate poorly into text :)
20:38:03 <jle`> wtfhaskell: Pamelloes was not referring to unix/*nix, but the software called "nix"
20:38:05 <wtfhaskell> bitemyapp: Yeah, you seem very rude to me. Told me to leave and all. Bad manners, pal. Not proud of you :(
20:38:52 --- mode: ChanServ set +o glguy
20:38:53 --- mode: glguy set +q *!*@5.172.238.153
20:39:02 <flippant> Ooh
20:43:03 <flippant> Hey there folks
20:43:10 <Pamelloes> Hi! :D
20:43:54 --- mode: glguy set -o glguy
20:46:15 <flippant> This week I'm Gonna try to finish my last project in Haskell
20:46:21 <jle`> :D
20:47:38 <flippant> So far it's been fun. I've rewritten it at least 3 or 4 times as I learn more
20:49:17 <jle`> that sounds like every haskell project i've ever done, haha
20:49:34 <flippant> Screen casting the whole process makes it feel kinda like pomodoro. I give myself 30 mins to an hour to finish a small bit of the project
20:49:52 <flippant> And then I go back and watch it
20:50:01 <flippant> Listening to my comments
20:50:19 <flippant> It's like pair programming with yourself
20:51:30 <Pamelloes> That's pretty awesome :)
20:51:37 <jle`> flippant: nice. are you screen casting publicly? :)
20:53:22 * hackagebot pinboard 0.8.6 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.8.6 (jonschoning)
20:54:14 <flippant> yeah
20:54:15 <flippant> jle`: https://www.youtube.com/playlist?list=PLXWjY7Nyj-PIPQAPojlvuoDbphPzjwObD
20:54:32 <jle`> sweet
20:54:46 <flippant> it took me a few videos before i realized the benefit of screen casting
20:55:50 <Pamelloes> if I have an algebraic datatype of the form MyType = A | B | C | D | ... is there an easy way to get a list [A,B,C,D,...]? Or do I have to write it out by hand?
20:56:51 <shachaf> deriving Enum, and then [A..Z]
20:56:54 <ski> Pamelloes : `[minBound .. maxBound :: MyType]', if you derive `Bounded' and `Enum'
20:57:12 <shachaf> Or that.
20:57:17 <Pamelloes> Cool!
21:05:19 <jle`> sometimes [minBound .. maxBound] is just fine if the type can be inferred later
21:05:21 <jle`> (and it likely can)
21:05:39 <jle`> probably a bad idea for readability though, heh
21:05:48 <julianleviston> flippant: this video is fascainting! (Creating an Agar.io server with Haskell 2)
21:06:34 <Pamelloes> Ooh, that sounds like a fun project :)
21:07:35 <platz> flippant: ever thought about streaming? maybe livecoding.tv or something
21:07:57 <platz> oh just saw the twitch link
21:08:05 <julianleviston> platz:  he’s got a link to a … nevermind you saw
21:09:14 <platz> wonder how many coders are on twitch vs livecoding
21:09:56 <Pamelloes> Is live coding actually a thing?
21:10:27 <moghedrin> Pamelloes: Apparently.
21:11:04 <Pamelloes> I think this is the second time I've seen someone live-stream coding. And the last time was in 2010.
21:11:16 * Pamelloes shrugs
21:14:59 <flippant> julianleviston: thank you
21:15:25 <flippant> platz: the problem with livecoding.tv is that a lot of streamers just play music
21:15:36 <flippant> i'd like to be able to know what the person is thinking
21:16:08 <julianleviston> Yeah, there’s really no value in watching someone type.
21:16:10 <platz> I've seen that a few times but not the majority
21:16:44 <julianleviston> or at least, little value.
21:16:44 <flippant> ah
21:16:58 <julianleviston> flippant: you should do some for beginners.
21:17:07 <julianleviston> flippant: if you have the time or inclination...
21:17:07 <flippant> im a beginner :P
21:17:15 <julianleviston> flippant: we all are :)
21:17:25 <platz> anyways I thought about streaming but wonder who really wants to watch me convert a static monad stack into an extensible monad transformer stack
21:17:32 <flippant> i would :D
21:17:43 <platz> lol, i'll have to fire it up then!
21:18:06 <flippant> you should explain why you're doing it in the first place though
21:18:10 <julianleviston> platz: as long as you explain your thinking, that’d be fascinating.
21:18:16 <platz> it would be several hours of watching error messages and tweaking constraints
21:18:18 * julianleviston hi5’s flippant 
21:18:54 <platz> julianleviston: yeah explanation would be needed
21:19:28 <julianleviston> the thing that sucks about watching videos of people “building systems” in haskell as it is is they’re usually already capable of it, so they don’t have the problems a beginner would… 
21:19:32 <platz> problem is i've cargo-culted some of my haskell knowledge  
21:20:02 <platz> so sometimes i need to look up patterns from code in other repos and things like that
21:20:29 <julianleviston> platz: as do we all
21:20:42 <julianleviston> platz: it’s the honesty that’s important, I think.
21:21:24 <platz> well that is encouraging i guess, yeah
21:21:42 <julianleviston> We want to see your mistakes, because they’re our mistakes.
21:22:10 <Pamelloes> I don't think anyone would want to watch me program because half of my time programming is just reading IRC....
21:22:26 <flippant> it would be cool to record a bunch of noobs messing around with haskell
21:22:33 <flippant> and then aggregate the most common mistakes
21:22:48 <flippant> and get an expert to explain it
21:23:56 <platz> that would be cool
21:56:35 <AshyIsMe> there's this which is along those lines: http://www.sanityinc.com/articles/haskell-peer-to-peer-session-with-ollie-charles/
21:57:15 <AshyIsMe> an expert demonstrating his haskell workflow and thought process while solving problems
22:08:59 <Peach1> hi everone
22:09:06 <Peach1> *everyone
22:09:29 <julianleviston> Silence is how we say hello :)
22:09:37 <julianleviston> oops ;-)
22:15:45 <sm> flippant: pretty cool.. what tools do you use for live streaming ?
22:16:16 <sm> or is just record a session and upload it ?
22:33:25 * hackagebot pinboard 0.8.7 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.8.7 (jonschoning)
22:54:28 <emmanuel`> Hello there everyone!
22:55:08 <ski> ello emmanuel`
22:59:01 <jigargosar> noob question "Haskell: Parsing and processing stream of json requests"
22:59:10 <jigargosar> http://stackoverflow.com/questions/32431296/haskell-parsing-and-processing-stream-of-json-requests
22:59:30 <jigargosar> I asked it on SO but didn't get satisfactory response
22:59:41 <jigargosar> can anyone help plz.
23:05:00 <ReinH> Well, you lose information about the type of Request, so you have to provide it somewhere.
23:05:33 <jigargosar> can it be refactored, abstracted better?
23:06:00 <ReinH> Well, it's a bit odd that you have both Createuser and Deleteuser
23:06:14 <ReinH> why not Request a = Request String RequestType a or so?
23:06:22 <ReinH> data RequestType = Create | Delete
23:08:21 <AshyIsMe> jigargosar: can you do something similar to the Maturity type here?: https://ocharles.org.uk/blog/posts/2012-12-07-24-days-of-hackage-aeson.html
23:10:29 <jigargosar> reinh: then I will have to modify dat RequestType every time. I am going to have tons of requests. created in multiple projects. 
23:10:55 <emmanuel`> I just want to float a question by everyone if that is ok.
23:11:07 <ski> jigargosar : `(Request a)' could be `Request a'. i would probably write type signatures for `parseCreateUser',`parseDeleteUser'(,`tojson'). in `parse', i'd use `case'. `exeTuple' could be defined by two separate defining equations, instead of `case'. `parseCreateUser $ a' and `parseDeleteUser $ a' is silly, drop the `$'s there. i'd personally get rid of the other `$'s as well (in favor of brackets)
23:11:37 <emmanuel`> So I have decided to use Haskell full time for my PhD work (it is not related to the study of haskell or programming languages).
23:11:58 <ski> jigargosar : "Is there any way to remove the following duplication?" -- one option would be to not name `parseCreateUser',`parseDeleteUser', using `parse' directly
23:12:14 <emmanuel`> I've been told in the past that Haskell/functional programming languages are only useful for thinking about certain kinds of problems. 
23:12:25 <ski> jigargosar : "Is this idiomatic haskell code?" -- use multiple defining equations, as i said
23:12:27 <emmanuel`> (This was by a CS professor).
23:12:31 <ReinH> emmanuel`: right, only the sorts of problems you can solve with a computer.
23:12:48 <emmanuel`> lol ReinH
23:12:51 <ReinH> well, actually that isn't even true
23:12:56 <ReinH> you can think about other sorts of problems too
23:13:05 <Zekka> emmanuel`: I don't think Haskell is the easiest language to solve a lot of the problems I work on with
23:13:09 <Zekka> But I think it's *suitable* for them
23:13:20 <emmanuel`> What type of problems do you work on Zekka?
23:13:31 <Zekka> emmanuel`: Lately, a whole lot of rule-based AI
23:13:48 <emmanuel`> Interesting!
23:13:56 <ReinH> seems like haskell would be pretty good at that
23:14:11 <Zekka> It's probably suitable, I just prefer doing it in Prolog
23:14:41 <Zekka> There's actually a port of one of my more preferred logic languages (Constraint Handling Rules) to Haskell, although I don't know if it's very good.
23:14:42 <emmanuel`> I am going to be applying manifold learning (this is subdiscipline of machine learning that is heavily influenced by topology and the like)
23:14:44 <ReinH> Ah, well if you have a special purpose language you might prefer it
23:14:51 <emmanuel`> to object recognition 
23:15:12 <Zekka> There aren't obvious inadequacies to doing this stuff in haskell, but it's useful to have a database globally in scope and to be able to carry out arbitrary side effects on that database
23:15:24 <Zekka> and while that stuff is easily possible it isn't already done for me
23:15:37 <ReinH> emmanuel`: I think that CS professor doesn't know very much about haskell
23:15:52 <Zekka> There's nothing stopping you from completely reimplementing Prolog in side effect-free Haskell if you really insist on doing that
23:16:09 <emmanuel`> ReinH: He does teach SML.
23:16:16 <Zekka> (I don't think this is a very good idea, because I have a feeling that going at "prolog but built out of persistent data structures" without being careful will murder performance)
23:16:31 <emmanuel`> But that obviously doesn't necessarily mean anything.
23:16:33 <Zekka> I'm actually implementing a prolog with persistent data structures right now, but not in Haskell
23:16:38 <ReinH> And he's calling another language useless. That's pretty rich.
23:17:11 <dmiles_afk> Zekka: what language is your impl?
23:17:14 <Zekka> dmiles_afk: Java
23:17:25 <ReinH> SML is a perfectly good language that no one uses outside of professors who teach SML...
23:17:30 <emmanuel`> Yeah, I don't know.  To be honest I was a little scared of haskell because of performance concerns.
23:17:32 <Zekka> If my design appears to work well I'll probably document it in case anyone (possibly including me) wants to port it to Haskell
23:17:57 <Zekka> It assumes a lot of things are strict that are not strict by default in Haskell and there are parts of it that are possibly more destructive than normal Haskell programmers would be comfortable with, though
23:18:08 <Zekka> even though the base database representation is a fairly uninteresting persistent data structure
23:18:25 <jigargosar> ski: thanks. could you clarify "`exeTuple' could be defined by two separate defining equations, instead of `case'"
23:18:31 <emmanuel`> I am now learning that Haskell can be very fast.. I was amazed!
23:18:36 <Zekka> (it used to be an interesting one, but the interesting one had significant performance problems when I tried to make it stable about clause selection order)
23:18:59 <dmiles_afk> Zekka: i am so annoyed at life.. A java lisp I know of runs faster than AllegroCL .. yet i cant find a Java Prolog that runs faster than SWI-Prolog :) 
23:19:16 <Zekka> dmiles_afk: Mine probably won't be faster than swi prolog, but if it is I'll let you know
23:19:22 <Zekka> I hear SWI-prolog is not that clever, but mine isn't either
23:19:27 <ski>   exeTuple ("createUser",a) = ...
23:19:28 <ski>   exeTuple ("deleteUser",a) = ...
23:19:30 <ski> jigargosar ^
23:19:30 <Zekka> there are some really obvious bonehead optimizations I want to implement before I start benchmarking
23:19:53 <ReinH> Zekka: if you want to use prolog you could attempt to write your program using Haskell's type system...
23:19:56 <ReinH> ;)
23:19:57 <dmiles_afk> Zekka: well problem is just how well even the slowest C prolog runs
23:20:25 <ski> ReinH : no backtracking :)
23:20:40 <Zekka> ReinH: I've heard this pitch before! I've never actually gone about trying to do it though
23:20:49 <dmiles_afk> Zekka: So if we need a fast prolog.. cant have it in lisp or java.. horrible!
23:21:04 <Zekka> In this case one of my big design goals is keeping runtime representation of code pretty fast to introspect upon
23:21:28 <dmiles_afk> Zekka: Though I suspect we can have a fast prolog written in ML.. I dont know about Haskell (anyone care tyo comment?)
23:21:44 <Zekka> That's not really that hard if I just keep a pointer to the term representation of my code and then compile it every time someone changes the term representation
23:21:46 <jigargosar> ski: thanks a lot. 
23:21:54 <Zekka> But it basically means assert can never be fast. (retract can be)
23:21:54 <ski> np
23:22:23 <Zekka> IIRC WAM has issues that would necessitate recompiling additional clauses when someone retracts, stuff like that, so that'd be a super huge performance killer
23:22:27 <ReinH> Zekka: have you looked at Oleg's LogicT stuff?
23:22:30 <Zekka> But I don't know WAM too well so don't trust me
23:22:33 <Zekka> ReinH: No, I haven't
23:22:52 <Zekka> FWIW there are other reasons I want to do my current project using this Prolog in Java, but that doesn't at all hold for future projects
23:22:57 <Zekka> so I'm still interested
23:23:00 <ReinH> You should. Oleg wrote a prolog in Scheme in Reasoned Schemer as well
23:23:19 <Zekka> I see one by Dan Doel here: https://hackage.haskell.org/package/logict
23:23:27 * hackagebot pinboard 0.8.8 - Access to the Pinboard API  https://hackage.haskell.org/package/pinboard-0.8.8 (jonschoning)
23:23:34 <Zekka> Looks like it's adapted from an essay Oleg wrote
23:23:48 <Zekka> and looks like there's a straightforward translation from Cont
23:23:49 <dmiles_afk> I do know the fastedst java prolog used WAM (that is Paul Taraus  JinniProlog
23:24:01 <ReinH> Zekka: there's also fun stuff like http://web.engr.oregonstate.edu/~erwig/papers/Zurg_JFP04.pdf
23:24:02 <edwardk> Zekka: it is. it hasn't been converted to reflection without remorse yet
23:24:27 <dmiles_afk> i studied his code .. and he passes TAGGED ints! like some ints are atom handles.. some are term pointers
23:24:30 <Zekka> edwardk: Were I to use it, are there gotchas I should know about?
23:24:48 <Zekka> dmiles_afk: FWIW I don't know how to wriite a faster prolog than WAM because I don't really know the WAM that well at this point
23:25:01 <Zekka> I do know several optimizations WAM uses that mine doesn't, but which I could rewrite mine to use
23:25:14 <edwardk> Zekka: logict performs pretty well, especially for 'single inspection' workloads. under the reflection-without remorse scenarios where you alternate between construction and inspection it can get expensive, but RwR has big constants
23:25:49 <Zekka> My plans are just not to do anything that directly contradicts my current design goals (have cheap support for introspection, have fast retract and moderately fast assert), and then make an optimization pass later
23:26:44 <dmiles_afk> Zekka: if you want to checkt it out later is.. https://code.google.com/p/jinniprolog/source/browse/#git%2FMainProlog%2Fprolog%2Fkernel
23:27:01 <edwardk> Zekka: i have a few things I've been exploring in this space that might be applicable.
23:27:35 <Zekka> edwardk: If you feel like it, tell me about it, although I don't know for sure that I'll be able to use what you bring up
23:27:36 * ski . o O ( "A Functional Hitchhiker's Guide to Hereditarily Finite Sets, Ackermann Encodings and Pairing Functions" by Paul Tarau in 2008-08-06 at <http://arxiv.org/abs/0808.0754>  )
23:27:52 <Zekka> because my implementation is not that far from being complete and I've probably already made assumptions you owuldn't have made in yours
23:28:18 <edwardk> Zekka: notably, there is an old algorithm for making imperative algorithms into partial or fully persistent ones. the partial persistence bound can be made worst case by using a technique from brodal http://dl.acm.org/citation.cfm?id=642153 -- with that technique now you can make imperative structures that have O(1) w.c. rollback to undo the actual changes
23:28:18 <edwardk> made, ignoring the time spent finding the changes to make
23:29:14 * dmiles_afk googling for LogicT benchmarks
23:29:17 <Zekka> edwardk: In many places I'm using an O(log n) persistent data struture with a reference to a previous version to support rollback
23:29:32 <edwardk> anyways, the brodal deamortization is something that struck me as rather particularly relevant to non-determinism.
23:29:38 <Zekka> I suspect the constant factors will be pretty high
23:29:55 <Zekka> I have a feeling I'm missing the thrust of what you're saying though because what I'm talking about is a pretty well-known finding afaik
23:30:00 <edwardk> Zekka: the dietz and sleator / brodal machinery can cut your log factor
23:30:08 <Zekka> (that is, that a lot of O(1) things are O(log n) things when done persitently)
23:30:10 <emmanuel`> I just want to throw this (possibly ridiculous) question owe<Zekka> I have a feeling I'm missing the thrust of what you're saying though because what I'm talking about is a pretty well-known finding afaik
23:30:11 <emmanuel`>  
23:30:23 <emmanuel`> Sorry... Something  went screwy on my end.
23:30:26 <edwardk> Zekka: in general we use 'path copying' to get persistence in functional algorithms because we can't do anything else and remain 'purely functional'
23:30:54 <Zekka> edwardk: path copying -- you mean representing the structure involved as a tree and then copying everything along the path to any part you modify?
23:31:00 <ski> .. and persistent
23:31:33 <emmanuel`> Continuing.... Is it possible to use cata/anamorphisms to represent transitions between abstract mathematical structures?
23:31:35 <edwardk> so if you have, say, a binary search tree, we take the binary search tree and we take our O(log n) time update operation, and recopy the path to the root. this turns an O(log n) TIME operation into one that takes O(log n) SPACE, but then we reclaim that delta space bound by the fact that the gc cleans up the old version and we don't notice -- and after all
23:31:35 <edwardk> the imperative algorithm would have lost the old version, right?
23:31:38 <dmiles_afk> one thing that path copying makes me think of is imagine the memory work of draing a term structure
23:31:44 <emmanuel`> ** I hope that makes any sense**
23:32:06 <dmiles_afk> "drawing the term" like  loves(joe,motherOf(joe))
23:32:10 <Zekka> edwardk: OK, pretty sure we're on the same page. What you're suggesting is an alternative to that that works for some structures, correctly?
23:32:16 <Zekka> correct*
23:32:24 <edwardk> but there are O(1) overhead conversions from imperative algorithms on data structures with bounded in-degree to ones equipped with partial persistence (ability to read old versions) or full persistence (ability to read or modify any version)
23:33:22 <edwardk> in between those two bounds, if you take partial persistence and make it O(1) w.c. by using an upgrade of the original technique for making imperative structures persistence then you can get an O(1) undo. this was called 'semi-persistence' in one paper on it, but the undo was mentioned at the end of the brodal paper
23:33:55 <edwardk> anyways with that, if you are walking through a non-deterministic calculation each branch of which wants to make a bunch of modifications, you can walk backwards and rollback the operations in the time it takes to scribble back the pointer changes you made
23:34:00 <dmiles_afk> loves(joe,motherOf(joe)) = "loves" + "(" + "joe" + "motherOf" + "(" + "joe" + "]"
23:34:30 <dmiles_afk> (is that second form an example of a Path?)
23:35:46 <Zekka> edwardk: I'll read up on the technique to see if I can upgrade anything with it
23:35:47 <edwardk> (you can also retain the ability to view old versions, in a snapshot capacity). so any of these scenarios you can hold onto all M historical versions of a data structure with N size on average, in M space, assuming O(1) mutations per update, even if it takes O(log n) time to find where to put those modifications, whereas using path copying you can do M log N
23:35:47 <edwardk> at best.
23:36:41 <edwardk> I've been exploring ways to make it so that if you hold onto a smaller subset of snapshots you can then upgrade the entire system to be friendly to the garbage collector. so that holding onto one version of the tree with N nodes only holds onto O(N) memory, as the system above leaked "all versions" for all time.
23:36:57 <Zekka> Currently the structures that most need to be rolled back are the database itself (represented with a fingertree seq and (not implemented yet) some tree-based maps to serve as indices) and a pair of stacks which together describe what database is being modified and what databases depend on those changes
23:37:07 <edwardk> if you don't need partial persistence (to see old versions) then you can of course just keep track of an undo record
23:37:19 <Zekka> (the details of how the pair of stacks do that aren't super important -- they don't really need to do anything unique or interesting to the stored databases)
23:37:33 <edwardk> anyways basically with the building blocks you're using you're pretty much guaranteed a log factor slowdown
23:37:40 <edwardk> i'm just offering up ways you might try to avoid it
23:38:04 <Zekka> I don't necessarily need to be using these building blocks but my current plan is to let people pretty arbitrarily say "I want to keep this version of the database forever"
23:38:20 <Zekka> this probably isn't strictly necessary for a lot of usecases, of course
23:38:22 <edwardk> that is something you can do with the full persistence variant i mentioned above
23:39:42 <edwardk> and with the gc machinery I mentioned above in place that says that holding onto a version (which contains n things) doesn't hold onto more than O(n) space
23:39:49 <Zekka> From what you mention above, it sounds like what you're saying is that you can get constant-time undo, but you lose *something* from full persistence
23:40:08 <edwardk> i'm offering a few points in the design space
23:40:09 <Zekka> My parse of that was that you lose the ability to make additional changes from that point (because other structures already depend on that one)
23:40:27 <Zekka> edwardk: Yeah, I recognize that -- you seem to be trying to present one as more likely to be relevant to what I'm trying to do, tohugh
23:40:37 <Zekka> So I'm trying to figure out what guarantees the point you're talking about makes
23:40:47 <edwardk> one is you can just keep an undo log, one is semi-persistence using brodal with fast undo, one is full persistence with g.c.
23:41:36 <Zekka> Can you be a little more clear about what semi-persistence is losing me?
23:42:09 <edwardk> with partial persistence time forms a line, you can add new versions on the end of the number line by bumping a counter.
23:42:30 <edwardk> with full persistence it forms a tree, you can change any version you had before by making a new version under it
23:42:48 <Zekka> OK, so it's what I thought: it's better than an undo log because you have constant-time access to past versions, but you can't modify old versions without breaking current versions
23:42:54 <edwardk> with semi persistence you can only edit the latest version but you can 'undo it' to make the latest version the one before.
23:43:39 <edwardk> so 'semi persistence' gives a sort of middle ground between the two, pretty close to partial persistence
23:44:17 <edwardk> and it is basically an 'undo log' that doesn't cost you access to read old versions until you roll back past them
23:44:53 <edwardk> so if you look at it as stuff you could compute in a non-determinism monad then while in any one computation every version of the structure you could grab a reference to will still be valid.
23:45:01 <edwardk> everything in your 'relative past' is still readable
23:45:39 <edwardk> it is a thing i keep looking for nice applications for, and my main thought so far has been for things like constraint programming or logic programming
23:47:35 <edwardk> the main way i've been thinking about this is if i wanted to work in a non-determinism monad that could go back in time, etc. i could build data structures that i could pass around references to in the monad, snapshot at any version in O(1) pay the minimal cost for all the versions i have lying around and then still go back in time by rolling back the world
23:47:35 <edwardk> when a given future universe doesn't pan out
23:48:17 <edwardk> then since those 'references' look functional to me, my non-determinism monad's 'applicative' can do things like explore both sides of a <*> independently
23:49:55 <edwardk> anyways right now it is definitely a solution in search of a problem =)
23:50:12 <Zekka> edwardk: If I wasn't interested in exposing my database, etc to the outside world I might be more enthusiastic
23:50:24 <Zekka> but this is Java and there's really only one preferred way to expose a data structure to the outside world
23:50:27 <Zekka> and it gives me less freedom
23:50:38 <edwardk> sure, for that then the full persistence scheme might make more sense
23:50:48 <edwardk> still O(1)ish costs, no rollback needed
23:51:00 <Zekka> I basically use the full persistencec scheme except in a few cases that aren't that important
23:51:17 <Zekka> I've already run into a similar tradeoff to this that probably has much more effect on performance with variable representation
23:51:20 <edwardk> by full persistence i don't mean the path-copying functional scheme
23:52:47 <Zekka> OK, what did you mean?
23:53:16 <Zekka> I got the impresssion the algorithm presented in the paper you've linked isn't useful for full persistence
23:53:28 * hackagebot quickcheck-text 0.1.0.0 - Alternative arbitrary instance for Text  https://hackage.haskell.org/package/quickcheck-text-0.1.0.0 (fractalcat)
23:53:30 <Zekka> so that leaves me thinking you can only mean pretty structure-specific representation differences
23:54:00 <edwardk> Zekka: i mean https://www.cs.cmu.edu/~sleator/papers/another-persistence.pdf section 3
23:54:13 <edwardk> which does provide a full persistence in O(1) amortized
23:54:46 <edwardk> the one i linked before was partial persistence in O(1) worst case, leading to O(1) w.c. semi-persistence in the presence of an undo log
23:56:37 <edwardk> you need order-maintenance http://ekmett.github.io/structs/Data-Struct-Order.html to make that version work, but i have it lying around to build on ;)
23:56:46 <emmanuel`> Hey edwardk, are you the guy that created/developed the autodiff haskelll library?
23:56:52 <edwardk> emmanuel`: i am
23:57:05 <emmanuel`> Awesome! I really like it.
23:57:10 <edwardk> thanks =)
23:57:56 <emmanuel`> I want to use haskell as the programming language for all my research. It was encouraging to find an autodiff library in haskell.
23:58:10 <edwardk> http://hackage.haskell.org/user/EdwardKmett <- ugh, 120 packages now
23:58:22 <emmanuel`> Lol, I'll take a look.
23:58:25 <CoconutCrab> :o
