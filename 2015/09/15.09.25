00:00:16 * hackagebot luminance 0.1.1.1 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.1.1.1 (DimitriSabadie)
00:00:48 * quicksilver isn't sure that "dependently-typed" is obvious a positive attribute for a graphics format.
00:01:16 <shachaf> TO be fair, that's a framework, not a format.
00:02:00 <quicksilver> hmm that's what I meant. I have a bad habit of thinking about something else as I type.
00:02:29 <shachaf> I like the version scheme. 0.1, 0.1.1, 0.1.1.1
00:02:55 <cocreature> unary version numbers
00:07:37 * hackagebot ihaskell-widgets 0.2.2.0 - IPython standard widgets for IHaskell.  https://hackage.haskell.org/package/ihaskell-widgets-0.2.2.0 (gibiansky)
00:07:37 * hackagebot luminance 0.1.1.1 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.1.1.1 (DimitriSabadie)
00:13:15 <quicksilver> hmm IHaskell looks interesting
00:13:23 <quicksilver> I've always wondered about a notebook-based repl
00:13:32 <quicksilver> especially for playing with diagrams-type packages
00:13:38 <cocreature> I played around with it a bit at some point, it's pretty cool
00:15:28 * quicksilver would rather it ran in emacs
00:15:44 <quicksilver> but it does look like there is an IPython emacs frontend so presumably that's not inconceivable
00:16:02 <cocreature> not sure how well graphics work in that case
00:16:12 <cocreature> which is imho one of the more compelling features
00:16:27 <quicksilver> it says it supports inline images
00:18:08 <quicksilver> cocreature: screenshot here - https://github.com/tkf/emacs-ipython-notebook
00:18:16 <quicksilver> of the python mode not hte haskell one of course
00:18:44 <cocreature> cool
00:19:19 <quicksilver> I would also like something like that for SQL
00:19:38 <quicksilver> something smart enough to just display the first few lines of large query results etc
00:20:04 <cocreature> I would assume there is an org babel thingy for sql
00:20:57 <quicksilver> yes, there is
00:21:20 <quicksilver> it feels less elegant than a real mathematica-style notebook though
00:21:25 <cocreature> fair enough
00:21:26 <quicksilver> (although in other ways it's more powerful of course)
00:22:49 <quicksilver> I wonder if chrisdone has thought about this kind of thing
00:23:03 <quicksilver> he's generally thought of every emacs/haskell idea I have before I think of it
00:23:43 <mgsloan> Hahah he has totally worked on that one
00:23:44 <cocreature> sadly he seems to have turned down his (public) emacs haskell activities
00:24:51 <mgsloan> https://github.com/chrisdone/present  Dunno where the emacs side of this is, but it lets you drive lazy evaluation from inside emacs
00:24:57 <mgsloan> so you can force subtrees
00:25:29 <cocreature> I think it's somewhere in the repl mode for haskell-mode
00:25:37 <mgsloan> Probably
00:25:48 <quicksilver> that's like vacuum, isn't it?
00:25:57 <quicksilver> I mean, it's taken a step further in a useful direction
00:26:29 <mgsloan> Right, whereas vacuum is about "let's visualize all the details of the GHC heap!"
00:26:35 <quicksilver> maybe there is a terrible danger here? Because mmorrow contributed many amazing things to this community, wrote vacuum, and then vanished never to be seen again
00:26:44 <quicksilver> has 'present' done the same thing to chrisdone?
00:27:07 <mgsloan> Oh, chris is alive and well, just busy
00:27:10 <cocreature> you can't survive very long in vacuum
00:27:23 * mgsloan hopes the same for mmorrow
00:27:33 <quicksilver> I have no reason to think mmorrow is not alive and well
00:27:36 <quicksilver> but he left us :(
00:42:51 <nchambers> is there a way to see the value of a variable whenever it is passed to a function?
00:43:07 <quicksilver> Debug.Trace.trace, nchambers 
00:43:15 <nchambers> thanks
00:43:26 <quicksilver> although you'll actually see it *whenever it is evaluated*
00:43:37 <quicksilver> which depending on good your intuition is for evaluation order might not be when you expect
00:44:07 <kriztw> There's also the wrapper traceShowId
00:44:13 <kriztw> which might be more convenient
00:44:52 <quicksilver> traceShowId forces you to do your own seqqing though?
00:45:03 <quicksilver> I think traceShow is closer to what nchambers probably wants
00:45:19 <quicksilver> anyhow, read the docs :)
00:45:20 <quicksilver> https://hackage.haskell.org/package/base-4.8.1.0/docs/Debug-Trace.html
00:55:07 <lpaste> sinelaw pasted “How to reduce stack usage” at http://lpaste.net/141654
00:55:42 <sinelaw> the recursive IO function I pasted has a stack space leak
00:56:18 <sinelaw> is there way to avoid it without resorting to IO-internals tricks?
00:59:35 <quicksilver> does it matter? haskell is generally more tolerant of deep stacks than C
01:00:02 <Gurkenglas> sinelaw, whether or not you find a solution, I would use https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:unfoldWhileM instead of your recursive definition
01:00:12 <Gurkenglas> (Don't know whether that one helps with the leak.)
01:00:25 <sinelaw> Gurkenglas, thanks, was just looking at that! perhaps I will
01:01:11 <jacereda> When submitting a patch to ghc, can I submit it relative to 7.10 or should it be relative to master?
01:01:16 <sinelaw> quicksilver, I'm trying to avoid unevaluated thunks being chained
01:01:40 <sinelaw> but I just found a better way - the function is used elsewhere in a way that can be fused with the iteration
01:01:50 <sinelaw> so I guess that's better
01:02:18 <Gurkenglas> Has anyone ever used null in a situation where they would rather not use (not . null)?
01:02:38 <gamegoblin> Gurkenglas: yes
01:03:03 <cocreature> jacereda: in most cases relative to master afaik, unless it's specific to 7.10
01:03:24 <cocreature> sinelaw: can't you make that tail recursive to avoid the leak?
01:03:30 <gamegoblin> I wonder if it’s an absolutely terrible idea to define a typeclass like "class Coerce a b where coerce :: a -> b"
01:03:33 <jacereda> cocreature: thanks
01:03:57 <Gurkenglas> gamegoblin, https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Coerce.html
01:04:16 <gamegoblin> Gurkenglas: Oh, ha. I’d searched hoogle for something similar but nothing came up.
01:04:28 <cocreature> you can't implement that yourself however
01:04:34 <cocreature> it's only for stuff like a list of newtypes
01:04:49 <lagrangi-wan> gamegoblin: instance Coerce a b where coerce x = error "in your dreams!"
01:05:18 <Gurkenglas> If instead of null, we had notnull, when would someone ever need to write (not . notnull)?
01:05:22 <julianleviston> I seem to be having an issue with my typeclass instancing: http://lpaste.net/141657 I wonder if someone might feel like having a look?
01:05:50 <lagrangi-wan> Gurkenglas: Dunno, I prefer pattern matching and views to Boolean blindness :-p
01:05:54 <julianleviston> I feel like I might have over-specified on my typeclass constraints! 
01:06:33 <quicksilver> julianleviston: well your code compiled, didn't it?
01:06:44 <quicksilver> julianleviston: I think your problem is just with expecting "5x" to work
01:06:50 <quicksilver> how did you expect 5 x to work?
01:06:56 <julianleviston> quicksilver:  it did compile.
01:07:09 <Gurkenglas> Is null the only time True stands for "There is no data."?
01:07:31 <Gurkenglas> (In either something producing or taking a Bool)
01:07:34 * hackagebot megaparsec 4.0.0 - Monadic parser combinators  https://hackage.haskell.org/package/megaparsec-4.0.0 (mrkkrp)
01:07:36 <quicksilver> Gurkenglas: "isNothing"? "isLeft"?
01:07:43 <julianleviston> quicksilver: because the tutorial / exercise I’m following suggested it might “just work” :) http://www.seas.upenn.edu/~cis194/hw/04-typeclasses.pdf (exercise 6)
01:08:07 <julianleviston> quicksilver:  at least it said I can stop using (P [5,3]) syntax.
01:08:46 <quicksilver> julianleviston: it tells you to write "5*x" doesn't it?
01:09:07 <quicksilver> not "5x" :)
01:09:10 <julianleviston> quicksilver: lol thanks. I just re-read it :)
01:09:18 <julianleviston> quicksilver:  silly me. Brainfart moment!
01:09:34 <Gurkenglas> Ah, "until" too
01:09:49 <quicksilver> I mean, you possibly could make a Num instance for (Poly a -> Poly a) so that "5x" works
01:09:54 <quicksilver> I'm not sure if that's a good idea or not
01:10:03 <julianleviston> quicksilver:  haha all good :) thanks.
01:10:21 <quicksilver> Gurkenglas: I kind of agree that "not.null" is a bit more common than "null"
01:10:26 <quicksilver> but I've definitely used null
01:11:15 <Gurkenglas> Example? And don't use until :P
01:11:27 <quicksilver> also I prefer to use "when (null x)" to "unless (not.null$x)" and "unless (null x)" to "when (not.null$x)"
01:12:08 <quicksilver> when (null acts) $ Left "Called with empty list of actions!"
01:12:19 <zipper> unless?
01:12:44 <zipper> What are we talking about here? unless it the opposite of when
01:12:44 <Gurkenglas> Would you also prefer "when (not.notnull$x)" to "unless (notnull x)" if those were your options?
01:15:32 <quicksilver> Gurkenglas: I would prefer let null = not.notnull; when (null x) $ :P
01:15:50 <quicksilver> but if it had a better name like nonEmpty
01:15:52 <quicksilver> then sure
01:15:58 <quicksilver> unless (nonEmpty x) is OK
01:16:09 <quicksilver> but double negatives are always harder to read
01:18:28 <Gurkenglas> I chose the name notnull for its connection to the discussion, not for its viability as a name in a library :P
01:18:55 <Gurkenglas> Naming just gets more and more painful as you get more experienced doesn't it
01:19:25 <lpaste> guibou pasted “No title” at http://lpaste.net/141658
01:19:26 <Gurkenglas> No wonder Adam was told to do it
01:19:45 <quicksilver> to be honest it's better to just pick a song you like and name all your functions after words or lines from the song. Meaning is an illusion anyway.
01:19:53 <guillaum2> anyone could have a quick look at my space leaks on http://lpaste.net/141658 ?
01:19:55 <zipper> I've never actually heard of null in haskell
01:20:02 <zipper> Is it the same as undefined?
01:20:05 <zipper> :t null
01:20:06 <lambdabot> Foldable t => t a -> Bool
01:20:24 <sinelaw> zipper, it's the same as "length xs == 0"
01:20:24 <jle`> back in the day, null [] = True null _ = False
01:20:34 <sinelaw> zipper, but generalized for foldables
01:20:34 <jle`> sinelaw: not quite, because it doesn't require an Eq instance :O
01:20:40 <zipper> jle`: Hey o/
01:20:45 <zipper> jle`: Been long
01:20:51 <jle`> how u been \o
01:21:02 <quicksilver> jle`: how does "length xs == 0" require an Eq instance? :P
01:21:07 <jle`> oh
01:21:08 <sinelaw> that too
01:21:08 <jle`> nevermind v.v
01:21:09 <sinelaw> :)
01:21:14 <jle`> >_____________________________>
01:21:15 <zipper> sinelaw: The only foldable I know is a list
01:21:17 * jle` heads to bed
01:21:22 <opqdonut> quicksilver: well for 0, obviously :P
01:21:24 <quicksilver> guillaum2: your inference is incorrect that the function with the high alloc % must be where the leak is.
01:21:34 <zipper> jle`: Well I've been okay
01:21:38 <quicksilver> opqdonut: but 0 has a Num instance so it must have an Eq instance.
01:21:48 <opqdonut> (I'm joking)
01:21:54 <quicksilver> guillaum2: it's quite normal for a function to do loads of allocationa nd still not leak - the GC is smart.
01:21:56 <zipper> Can't wait to get back to playing with auto. Such fun. Learning learning learning.
01:22:00 <zipper> jle`: ^
01:22:02 <opqdonut> jle`: you're probably thinking about xs == [], which does require Eq
01:22:08 <jle`> opqdonut: yeah, that :)
01:22:16 <zipper> Which other foldables are there?
01:22:27 <jle`> zipper: it's fun to just gobble up anything you can find :)
01:22:32 <jle`> zipper: Maybe is another famous one
01:22:36 <Gurkenglas> zipper, Tree
01:22:42 <jle`> > [null Nothing, null (Just 1)]
01:22:44 <lambdabot>  [True,False]
01:22:59 <guillaum2> quicksilver: good point, thank you. So what is the approach to understand what is happening in this code which leads to 800 Mb of memory usage ?
01:23:00 <jle`> Data.Map's Map is another one
01:23:04 <jle`> > null M.empty
01:23:06 <lambdabot>  True
01:23:31 <quicksilver> guillaum2: possibly a heap profile.
01:23:38 <zipper> I don't see how Maybe is a foldable. Doesn't a foldable have to have a "spine"?
01:23:42 <zipper> Let me google it
01:23:50 <quicksilver> zipper: it's a foldable with 0 or 1 elements
01:24:01 <quicksilver> zipper: Maybe is just like "Lists of length at most 1"
01:24:08 <quicksilver> and it has the same Foldable instance as that.
01:24:08 <jle`> zipper: one way to look at a Foldable is something that can be turned into a list in a meaningful way
01:24:17 <quicksilver> that's why we have functions listToMaybe and maybeToList
01:24:38 <zipper> Makes sense
01:25:10 <jle`> actually all of the Foldable methods are basically the same as converting the value into a list, and then using the corresponding list function
01:27:11 <quicksilver> s/basically/exactly/
01:27:23 <quicksilver> although they might run more efficiently, that is precisely what they are semantically.
01:28:26 <jacereda> I need to build a program on windows that contains 32-bit parts and 64-bit parts. Can cabal handle that? Would stack be the answer here?
01:28:48 <quicksilver> guillaum2: your sum is never forced
01:29:03 <zipper> jle`: Thanks
01:29:22 <zipper> jacereda: Windows == pain
01:29:23 <quicksilver> guillaum2: as you traverse your disk you are building up a beautiful - and very large - sum[ sum [ sum [1,3,5], sum [2,4,6] .. ] .. ] .. ]
01:29:25 <cocreature> is there a recursion scheme for folding over a structure and producing a new structure using an accumulator?
01:29:46 <quicksilver> cocreature: that's just a foldr, isn't it?
01:29:57 <jle`> cocreature: looks just like a cata, unless you had something more specific in mind
01:30:13 <cocreature> quicksilver: sure I can do it as a fold, but I thought that there might be something that does the rebuilding of the new structure
01:30:29 <cocreature> jle`: yeah I was hoping that there was something more specific
01:30:34 <quicksilver> the recursion scheme is still going to be foldr
01:30:43 <quicksilver> what you do *inside* the function parameter to the foldr
01:30:48 <quicksilver> is the 'building up' part
01:31:00 <quicksilver> although it's pretty limited in its option since it's being fed things one at a time
01:31:04 <jacereda> zipper: agreed, but like most developers I'm a code prostitute doing things I dislike for money
01:31:19 <quicksilver> guillaum2: do you see?
01:31:49 <Gurkenglas> quicksilver, doesn't -O2 optimize sum into a strict fold, meaning that he only allocates 2 to the power of his folder depth nodes at a time?
01:31:56 <quicksilver> Gurkenglas: no.
01:31:57 <cocreature> quicksilver: well I can also implement a paramorphism as a catamorphism, still it's nice to be able to not having to do that manually
01:32:07 <quicksilver> Gurkenglas: sum will indeed be optimised into a strict fold
01:32:12 <quicksilver> but he's still not demanding the result
01:32:12 <guillaum2> quicksilver: well done. I replaced it by ret <- sum .. ; return $! ret
01:32:19 <quicksilver> strict doesn't mean "calculate immediately"
01:32:29 <quicksilver> it's just a description of how the fold is done when it is finally done :)
01:32:37 <quicksilver> guillaum2: and that fixed it?
01:32:55 <jle`> cocreature: you can use cataM under State maybe, but this is assuming that your resulting structure is unrelated to your original structure
01:32:56 <guillaum2> drop from 800 Mo to 30 Mo
01:33:01 <quicksilver> yay
01:33:09 <quicksilver> love it when a plan comes together
01:33:25 <cocreature> jle`: hm ok, I guess I'll just stay with a fold :)
01:33:28 <guillaum2> (interestingly, I thought that foldl' should do the trick, but no)
01:33:34 <Gurkenglas> This whole thing looks like it should be abstracted into a hylo
01:33:59 <jle`> cataM w/ State means you can enforce a somewhat linear ordering to how you traverse over the objects
01:34:24 <jle`> just using cata alone for most structures, you just get the "result" of each branch
01:35:00 <jle`> but you lose the information on how much each branch branches out, the ordering of your traversal, etc., unless you manually incorporate it back in
01:35:21 <cocreature> basically I want a scanl but emit something different to my accumulator
01:42:16 <jle`> omg i have been hunting for a bug all week and it was just forgetting a ' v.v
01:42:22 <jle`> type system you have failed me
01:42:24 <jle`> ;_;
01:43:00 <jle`> or maybe i have failed the type system by not providing expressive enough types
01:43:38 <guillaum2> quicksilver: thank you, now I'm able to scan a more complex directory using only 30Mb of ram. Now I have to understand why stuff are slower (10 fold) than the shell version.
01:48:05 <quicksilver> guillaum2: when you say the shell version you mean the C version? :)
01:48:09 <quicksilver> 'du' from coreutils
01:48:52 <guillaum2> quicksilver: yes ;) that one.
01:49:38 <guillaum2> quicksilver: I don't expect to beat it ;) But the exercice is interesting.
01:49:43 <quicksilver> interesting question. 10 times slower does seem surprising
01:50:11 <CoconutCrab> shell util can be extremely fast, like grep for example
01:53:18 <quicksilver> yup but normally we within 2x/3x 
01:53:26 <quicksilver> grep is a special case because it's all about string processing
01:53:41 <quicksilver> du is mostly about disk IO and you wouln't expect such a difference
01:53:57 <quicksilver> maybe du has access to a syscall which is faster than haskell's getFileSize
01:54:20 <Wizek> Hello! Anyone knows if with Gloss, it is possible to get the pixel width of a given Text or Picture typed value?
01:55:20 <guillaum2> quicksilver: I suspect du is doing some weird stuff, because du /sys is instant answer (which is 0) when looping over all the /sys entries is a nightmare ;)
02:05:07 <cocreature> what exactly does let a/b = 1 bind? it doesn't seem to bind a/b as that is not an identifier, it doesn't bind a and it doesn't bind b but it's not a syntax error either
02:05:25 <jle`> cocreature: it's defining (/)
02:05:28 <opqdonut> cocreature: defines the infix operator /
02:05:29 <cocreature> jle`: ah ofc
02:05:33 <jle`> > let a/b = 3 in 10 / 9
02:05:35 <cocreature> now I feel stupid
02:05:35 <lambdabot>  3
02:05:41 <opqdonut> > let a/b = 1 in True/[]
02:05:43 <lambdabot>  1
02:06:18 <quicksilver> guillaum2: a thought. du doesn't have to handle filenames *at all*. It can simply get the directory contents as a list of inode
02:06:28 <quicksilver> guillaum2: and then get the file size and contents from those inodes
02:06:40 <quicksilver> guillaum2: no processing of names, no concatenating of strings, none of that.
02:09:35 <quicksilver> or can it? I assumed that would be possible but now I'm not sure.
02:11:42 <frerich> Judging by http://opensource.apple.com/source/file_cmds/file_cmds-212/du/du.c it indeed uses fts_open() to traverse a file hierarchy, 
02:11:57 <frerich> (That's a BSD thing, maybe the GNU version uses opendir())
02:12:59 <frerich> It does not!
02:13:09 <frerich> https://github.com/goj/coreutils/blob/rm-d/src/du.c uses (x)fts_open, too!
02:13:20 <quicksilver> yes, linux has fts_open
02:13:35 <quicksilver> even though it isn't POSIX
02:13:46 <quicksilver> anyhow that is probably faster because it avoids all that filename nonsense
02:13:49 <frerich> Yeah
02:14:17 <quicksilver> I'm somewhat suprised that posix doesn't have stat-by-inode I must admit
02:14:32 <quicksilver> kind of thing I imagined would be there
02:16:06 <quicksilver> more to the point I should say glibc has fts_open
02:16:40 <syntagma> I have a quesion for Vim users out there. Is there any quick way to compile and run current (single file) program? One solution that comes to my mind is using vim-slime, though I would prefer a solution which wouldn't use any plugins.
02:18:21 <frerich> syntagma: If you don't *need* the 'compile' step, you could use 'runhaskell'
02:20:10 <frerich> syntagma: E.g. '!runhaskell %:p'. Or you bind that to a key, like 'nnoremap <leader>r :!runhaskell %:p<CR>'
02:20:20 <frerich> syntagma: Then you can use <leader>r to run the file in the current buffer.
02:21:10 <syntagma> frerich: Thanks, that's what I was looking for
02:21:29 <syntagma> Though I get this error: Not in scope: `main'
02:21:47 <syntagma> But it's probably something I should learn before asking here
02:22:12 <liste> syntagma do you have a main function?
02:22:25 <liste> or do you just want to load your program in ghci
02:23:17 <syntagma> liste: I added main function, it almost works now
02:23:56 <syntagma> all I want is something like adding few lines of code exactly like I would do in ghci, evaluate it (with or without compiling) and save the file
02:25:12 <quicksilver> maybe you just want to run ghci on it
02:25:15 <quicksilver> instead of runhaskell
02:25:25 <quicksilver> runhaskell looks for and runs the Main
02:25:34 <quicksilver> but ghci will just load the file and then be available for interactive queries
02:28:49 <cheater> hello, is there an irc channel for HalVM?
02:29:01 <cheater> I am trying to find out if there are any fast web servers that run on it.
02:30:24 <pavonia> When you're constructing values of some type that need an extra runtime-check, what is the usual way to inform the user about errors that might occur on construction? Return only a Maybe, or an Either String Foo, or something else?
02:32:18 <Hafydd> unsafePerformIO causeSementationFault
02:32:31 <Hafydd> ...Segmentation
02:33:21 <syntagma> quicksilver: Is there any way to immediately close ghci after evaluation?
02:34:52 <pavonia> syntagma: Are you looking for "ghc -e" perhaps?
02:40:07 <haskell542> Data.Binary or Data.Serialize for binary serialization?
02:40:38 <haskell542> Six to one, half dozen to the other?
02:42:17 <pavonia> More like 71625  to 149272
02:43:16 <haskell542> haha. I'm really, really new to Haskell. Which should I go with?
02:43:53 <pavonia> Well, according to package downloads people pefer the latter
02:44:30 <haskell542> Hrm. Ok. Thanks.
02:45:14 <syntagma> pavonia: thanks, still looking for a right solution
02:46:48 <frerich_> syntagma: I always used 'binary' for no particular reason. https://mail.haskell.org/pipermail/haskell-cafe/2013-February/106634.html may be an interesting thread in this context (though I don't know whether it's outdated by now).
02:47:40 * hackagebot sign 0.4.2 - Arithmetic over signs and sets of signs  https://hackage.haskell.org/package/sign-0.4.2 (MasahiroSakai)
02:47:51 <quicksilver> syntagma: I thing you can use ghc -e or ghci -e or something
02:48:00 <quicksilver> but that take a single expression not a whole file
02:48:01 <syntagma> frerich_: I think you meant haskell542, not me
02:48:09 <quicksilver> 'evaluating' a whole file doesn't mean anything
02:48:10 <frerich_> syntagma: Oops, you're right - sorry. :-)
02:48:19 <quicksilver> files don't have values, they aren't expressions.
02:49:02 <syntagma> quicksilver: I know, I need to evaluate all the expressions in the given file
02:49:11 <syntagma> Looks like vim-slime is the way to go
02:49:14 <quicksilver> syntagma: haskell files don't contain expressions
02:49:21 <quicksilver> I believe we must be at cross purposes )
02:49:22 <quicksilver> :)
02:49:33 <quicksilver> I mean clearly they do, but their top-level is definitions, not expressions.
02:50:08 <quicksilver> pavonia: if there is no useful info to give apart from 'that didn't work' then Maybe. If it is useful to be specific about what didn't work then Either String.
02:50:30 <quicksilver> pavonia: and possibly a version which just uses error, if that seems appropriate.
02:51:26 <pavonia> The only error that can occur is "out of range", I guess a Maybe is good then
02:51:58 <pavonia> and adding information about the range in haddock comments
03:02:40 * hackagebot optparse-applicative 0.12.0.0 - Utilities and combinators for parsing command line options  https://hackage.haskell.org/package/optparse-applicative-0.12.0.0 (huw)
03:30:49 <pavonia> Can anyone think of a reason why GHC tells me "No instance for (IsString BS.ByteString)" only in a specific module? All my modules include Data.ByteString and use OverloadedStrings, but only one fails
03:31:50 <quicksilver> that module is using the Word8 ByteString not the Char8 one?
03:33:38 <pavonia> How does it choose the version?
03:33:53 <pavonia> I thought Data.ByteString defaults to Word8
03:38:03 <pavonia> I reduces it to this example http://lpaste.net/7286101478643597312
03:38:15 <pavonia> *reduced
03:38:49 <quicksilver> pavonia: by importing Data.ByteString.Char8 instead
03:39:22 <merijn> Something, something, char8, something, something, evil...
03:39:46 <pavonia> quicksilver: But this isn't the case here
03:40:15 <pavonia> And there's only one bytestring package installed
03:40:19 <merijn> pavonia: His point is that ByteString doesn't have an OverloadedString instance when not importing Char8
03:41:18 <pavonia> merijn: The docs say it has
03:41:36 <pavonia> Oh wait
03:42:13 <pavonia> Ah, I got it now, you need both. Thanks!
03:42:26 <tsahyt> What? "abc" :: ByteString works perfectly in ghci for me without importing the Char8 module.
03:42:35 <tsahyt> As long as -XOverloadedStrings is enabled of course
03:43:12 <pavonia> tsahyt: Without importing any other modules?
03:43:36 <tsahyt> pavonia: import Data.ByteString and :set -XOverloadedStrings are the only things I did
03:43:41 <pavonia> My other file has a lot of extra imports, so I guess one of them uses the Char8 version
03:43:53 <tsahyt> pavonia: Also, your paste compiles for me
03:44:23 <jophish_> Quickcheck has the === operator, which check equality on its two operands, and should they fail adds the string (show a ++ " /= " ++ show b) to the counterexample. Something really useful some of the time. Does anyone thing they'd make use of a package of a few more comparison operators like that?
03:44:31 <jophish_> I couldn't find one already
03:44:54 <merijn> jophish_: acme-php? :p
03:44:57 * merijn ducks
03:45:20 <quicksilver> maybe some version of bytestring has that instance more visible, tsahyt 
03:45:45 <tsahyt> quicksilver: bytestring-0.10.4.0 here. Interestingly I can't see the instance with :info though
03:45:49 <jophish_> merijn: !!!
03:49:08 <tsahyt> Speaking of QuickCheck. Is there a function that directly returns a counterexample? I can kinda roll my own with sample' and enough tries but it's really unwieldy. It's just something that would be nice to have in ghci when debugging more complex that operates on larger data structures.
03:52:49 <merijn> tsahyt: Pretty sure quickcheck already reports counterexamples?
03:53:10 <merijn> @check \(xs ::[Int]) -> xs == reverse xs
03:53:10 <lambdabot>  <unknown>.hs: 1: 15:ScopedTypeVariables is not enabled
03:53:14 <tsahyt> merijn: It only prints them. I can't do something like x <- quickCheck myproperty.
03:53:14 <merijn> awww
03:53:26 <merijn> Oh, right
03:54:06 <tsahyt> merijn: I've been dealing with properties on rather large structures lately, which don't even fit into one screen when printed, so even copy-pasting them back onto the REPL is a bit of a pain.
03:55:55 <jophish_> tsahyt: perhaps some really basic parsing and a call to read?
03:56:30 <tsahyt> jophish_: I guess that could work. I think the Result type or whatever it was called contains the full string, which I could pass to read.
03:56:49 <jophish_> it's a pain, but probably quicker than modding quickcheck
03:57:03 <jophish_> I suppose it depends on how much of a perfectionist you are :)
03:58:29 <tsahyt> jophish_: I just need it as a tool on the REPL to get examples quickly so I can then step through the code with it, or look for things that look odd. I think it should be possible to write a function foo :: Read a => Result -> Maybe a and use foo <$> quickCheckResult bar
03:59:16 <jophish_> that sounds perfectly possible :)
04:00:15 <tsahyt> I think I'll do that when I need it. Non-strictness is a virtue.
04:00:34 <vburakovs> join #android
04:06:59 <Gurkenglas> Surely there is something like teaspoon to redirect stdout to a String in IO?
04:09:37 <frerich> Gurkenglas: Maybe something like 'capture' in http://hackage.haskell.org/package/silently-1.2.5/docs/System-IO-Silently.html ?
04:10:04 <quicksilver> was about to say that
04:10:07 <frerich> Gurkenglas: FWIW I found that via http://hayoo.fh-wedel.de/?query=IO%20a%20-%3E%20IO%20%28String%2C%20a%29 :-)
04:10:48 <frerich> I think I really only use Hoogle out of a habit and sympathy for the author. Hayoo came a looong way...
04:11:15 <frerich> Plus, fh-wedel.de is basically next door so some local patriotism is involved, too.
04:14:49 <Hafydd> Having no users is better than having pity-users.
04:33:18 <bernalex> Hafydd: investors would disagree :]
04:33:50 <Hafydd> bernalex: does the website somehow make money from you using it?
04:34:02 <bernalex> Hafydd: investors seem to think so
04:34:10 <Hafydd> Does it have ads?!
04:34:14 <bernalex> Hafydd: "we'll just get lots of users and then data mine them and then ??? and then money!!!"
04:34:18 <Hafydd> Heh.
04:34:38 <bernalex> I wish I were joking. :]
04:35:10 <Hafydd> "and then data mine them and then ???" is probably a common thought, these days.
04:36:10 <voidzero> where ??? means "sell our souls"
04:36:56 <eikke> voidzero: nope, sell your users' souls
04:37:45 * hackagebot wai-middleware-crowd 0.1.2.1 - Middleware and utilities for using Atlassian Crowd authentication  https://hackage.haskell.org/package/wai-middleware-crowd-0.1.2.1 (MichaelSnoyman)
04:37:46 <dutchie> "get bought by facebook"
04:38:56 <quchen2> "Getting bought by Facebook" brought us Haxl, so it's not that bad either
04:41:17 <exio4> quchen2: https://ro-che.info/ccc/19 :p
04:43:16 <eikke> anyone else waiting for an email from SPJ announcing he's joining Twitter?
04:44:44 <voidzero> fax
04:45:50 <saulzar_> I tried to join twitter but the sign up was quite complicated
04:46:15 <indiagreen> can't be more complicated than learning Haskell
04:46:17 <indiagreen> ...or can it?
04:47:38 <saulzar_> It's up there with opening the door the correct way
04:48:02 <voidzero> there are many weird types on twitter though.
04:48:21 <frerich> Hafydd: Not sure I get it, but I'm not a "pity user". Lately, Hayoo works very nicely for me. In a few cases, it almost returned too many results though. In this particular case, it helped find a package which Hayoo didn't index. :-)
04:56:08 <Hafydd> <frerich> I think I really only use Hoogle out of a habit and sympathy for the author. 
04:57:48 <merijn> Hayoo doesn't let you search by type, though
04:57:58 <merijn> I'm just hoping Hoogle 5 comes out soon :)
04:58:43 <quicksilver> merijn: rly?
04:58:46 <quicksilver> what's this then:
04:58:48 <quicksilver> http://hayoo.fh-wedel.de/?query=Int+-%3E+%5Ba%5D+-%3E+a
04:58:56 <frerich> merijn: It does
04:59:13 <merijn> Oh, must be new
04:59:19 <merijn> It didn't last time I used it
04:59:24 <frerich> Hafydd: Ah you mean 'pity' for Hackage? Well, not really. It's more like a habit. :-)
04:59:26 <merijn> Admittedly a long time ago :p
04:59:30 <quicksilver> what you mean, perhaps, is it doesn't do the alpha-converting and unifying search
04:59:33 <merijn> http://neilmitchell.blogspot.nl/2015/01/hoogle-5-is-coming.html
04:59:44 <quicksilver> hoogle is certainly much cleverer in this respect
05:00:13 <quicksilver> actualy looks like it does alpha-conversion
05:00:15 <quicksilver> just not unifying
05:01:29 <frerich> quicksilver: With 'unifying' you mean that e.g. searching for '(a -> b) -> a -> b' should also find 'id'?
05:01:51 <obihann> with list comprehension can you have an or statment?
05:02:06 <obihann> I'm trying to build a list that contains all numbers divisible by 3 or 5
05:02:09 <Nux_> are expressions in normal form a subset of expressions in WHNF?
05:02:16 <merijn> :t or
05:02:17 <lambdabot> Foldable t => t Bool -> Bool
05:02:23 <merijn> hmm, not what I was thinking off
05:02:24 <quicksilver> frerich: well, I mean that [a] -> b -> a will also find results for [a] -> Int -> a
05:02:34 <merijn> obihann: List comprehensions take guards which are a boolean
05:02:36 <frerich> quicksilver: Ah I see
05:02:37 <merijn> obihann: You can just use
05:02:40 <merijn> :t (||)
05:02:41 <lambdabot> Bool -> Bool -> Bool
05:02:42 <quicksilver> obihann: you can certainly have an or inside the Bool part
05:02:43 <merijn> in the guard
05:02:44 <quicksilver> (the guard part)
05:03:33 <Nux_> obihann, attempting the project euler problems I see
05:03:47 <obihann> so something like this x = [(x) | x <- [1..10], x `mod` 3 == 0 :t or x `mod` 5 == 0]
05:03:59 <frerich> Not quite. :-)
05:04:00 <obihann> haha you know it
05:04:36 <Nux_> ':t' is an interpreter command for checking types
05:04:36 <frerich> obihann: The ':t' part is something which the IRC bot 'lambdabot' listens for. The actual function is called 'or' (resp. '||'). So with ':t or' you ask lambdabot to give the type of the function 'or'.
05:05:08 <obihann> oh ok haha
05:05:12 <obihann> so || is what I need
05:05:39 <Nux_> for starters yes
05:05:54 <obihann> x = [(x) | x <- [1..1000], x `mod` 3 == 0 || x `mod` 5 == 0]
05:05:55 <obihann> x = [(x) | x <- [1..1000], x `mod` 3 == 0 || x `mod` 5 == 0]
05:05:57 <obihann> perfect!
05:06:03 <obihann> damn I love haskell
05:07:12 <fizruk> obihann: you don't need parens around (x)
05:07:22 <Nux_> [1..1000] will include 1000
05:07:30 <Nux_> the problem your on says 'below'
05:07:54 <Nux_> not 'up to an including'
05:08:00 <Nux_> *and
05:08:35 <quchen2> > [x | x <- [1..100], let divisibleBy n = x `mod` n == 0, divisibleBy 3 || divisibleBy 5 ] -- obihann: you can use 'let' in list comps as well!
05:08:37 <lambdabot>  [3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,55,5...
05:09:52 <Nux_> obihann, other than those things, that solution is the same as my first attempt :)
05:10:12 <aweinstock> Nux_: I think NF is a subset of WHNF (If I understand correctly, (1+1, 2+2) is in WHNF since the outermost constructor is a data constuctor (,) but it has thunks inside; and (2, 4) is in NF (fully evaluated))
05:11:06 <aweinstock> and something like (fst (1+1, 2+2)) is neither NF nor WHNF, since the outermost thing is a function application
05:11:45 <obihann> thanks!
05:12:11 <Nux_> aweinstock, I'm not going to say you're wrong as I'm just learning this myself but from what I've read it sounds like (1+1) isn't in NF or WHNF
05:12:14 <merijn> aweinstock: Correct, any NF is by definition also in WHNF form
05:12:37 <merijn> (1+1) isn't in either normal form
05:12:57 <Nux_> as I understand it, WHNF is like an extension to NF which allows partially applied functions and constructors
05:12:58 <merijn> Nux_: (1+1, 2+2) *is* in WHNF, though
05:12:59 <aweinstock> Nux_: 1+1 isn't, but ((,) (1+1) (2+2)) is in WHNF
05:13:16 <Nux_> I see
05:13:21 <aweinstock> (since (,) is a data constructor, and not a normal function)
05:13:24 <merijn> Nux_: No, an expression is in WHNF if the outermost part is a constructor
05:13:58 <merijn> Nux_: NF is more strict than WHNF since NF doesn't allow any unreduced expressions
05:14:20 <merijn> Whereas WHNF allows unreduced expressions everywhere, except the "outermost" position
05:14:32 <Nux_> ok so to test me
05:14:50 <Nux_> Just 2 -- is in WHNF (and NF)
05:14:59 <merijn> Right
05:15:00 <Nux_> Just (1+1) -- is in WHNF (and not NF)
05:15:10 <aweinstock> also correct
05:15:23 <Nux_> (1+1) -- is in neither form
05:15:50 <Nux_> Just -- is in neither form and is also an invalid expression altogether
05:16:05 <aweinstock> :t Just
05:16:07 <lambdabot> a -> Maybe a
05:16:16 <Nux_> oh yes
05:16:22 <aweinstock> (1+1 :: Int) is in neither form
05:16:32 <merijn> Technically Just is a valid expression in WHNF and NF :p
05:16:41 <Nux_> ok
05:16:54 <merijn> For the same reason say "id" is
05:17:00 <Nux_> makes sense
05:17:05 <quicksilver> or even (\x -> x)
05:17:15 <aweinstock> I think it's possible to make "symbolic" Num instances for which (+) is a data constructor
05:17:32 <Nux_> + 2 -- is an actual example of an invalid expression
05:17:39 <quicksilver> aweinstock: not really. (+) is always a function. Its implementation might reduce to a data constructor.
05:17:48 <quicksilver> but that would be called Add or :+ or something
05:18:18 <aweinstock> data Symbolic a = Lit a | Var String | Add (Symbolic a) (Symbolic a) | ...; instance Num a => Num (Symbolic a) where (+) = Add; ...
05:18:18 <quicksilver> so you'd have (2 + 5) =~~=> (Add 2 5)
05:18:31 <quicksilver> and you'd still have (2+5) not being WHNF
05:18:34 <aweinstock> ah
05:18:38 <quicksilver> while (Add 2 5) is
05:18:47 <Nux_> + 2 -- is an actual example of an invalid expression
05:18:49 <Nux_> right?
05:18:53 <quicksilver> yes
05:18:54 <aweinstock> Nux_: (+2) is in NF, I think
05:19:04 <quicksilver> + 2 just isn't a haskell term at all
05:19:08 <aweinstock> oh
05:19:09 <Nux_> but I left off the brackets for a reason
05:19:10 <Nux_> yes
05:19:12 <Nux_> ok
05:19:14 <pbl64k> hi
05:19:29 <aweinstock> (\x -> x+2) isn't NF or WHNF?
05:19:40 <merijn> WHNF
05:19:41 <pbl64k> I wonder if there's any way to convince GHC that those two types (using DataKinds) are the same:
05:19:50 <pbl64k>     Couldn't match type ‘forall (ix1 :: ()).                          ListFunctor (Union (Const b) (Const a)) ix1 -> Const a ix1’                   with ‘ListFunctor (Union (Const b) (Const a)) '() -> Const a '()’
05:19:58 <aweinstock> merijn: the outermost "constructor" is lambda?
05:20:03 <merijn> aweinstock: "(\x -> x+2) 4" would not be WHNF
05:20:13 <merijn> aweinstock: Yeah, lambdas are irreducible
05:20:22 <aweinstock> so (+2) is in WHNF?
05:20:36 <quicksilver> yes.
05:20:42 <Nux_> aweinstock, the brackets you're adding weren't in my example
05:20:47 <merijn> I have a (hopefully) correct eval function for NF and WHNF here, btw: https://github.com/merijn/lambda-except/blob/master/Eval.hs
05:20:48 <Nux_> I think that's the confusion here
05:21:34 <quicksilver> to put (\x -> x+2) into NF you need to look up the definition of +
05:21:36 <quicksilver> and write it in there
05:21:56 <exio4> pbl64k: do you have some code for this? 
05:22:10 <merijn> Actually, bah
05:22:18 <merijn> I have a bug in my implementation of NF :p
05:22:25 <merijn> Good I'm looking at this again :p
05:22:57 <Nux_> is there any performance reason not to use Data.Set in favor of operating on a list in restricted ways?
05:23:19 <merijn> Nux_: No, Set should be faster, but Sets don't have ordering
05:23:35 <frerich> Nux_: Well, if you get a list and you need to produce a list eventually, then using a Set somewhere inbetween may not be a good idea. :-)
05:24:24 <frerich> I.e. you might end up introducing  conversions to/from lists somewhere if you use Set
05:24:47 <Wizek> Hello!
05:24:52 <Nux_> ok so instead of doing what I'm currently doing, which is operating on my lists in ways that avoid reordering / even attempting to add duplicates, I will definitely be better off using Data.Det?
05:24:54 <Nux_> *Set
05:24:54 <Wizek> Anyone familiar with Gloss in here?
05:25:50 <fizruk> Wizek: sure, ask away!
05:26:00 <frerich> Nux_: That sounds like a good use case for Set, yeah!
05:26:05 <Nux_> I guess what I'm asking is, if you never make use of the duplicate/order ignoring properties of Data.Set, are you worse off for using it?
05:26:21 <Wizek> In Gloss. is it possible to get the pixel width of a given Text or Picture?
05:26:33 <Nux_> (given that you aren't using duplicates/order anyway)
05:26:40 <Wizek> Or is that data not accessible in any way?
05:26:56 <indiagreen> Nux_: if you need to be deleting items from the set, then you might be better off using Set
05:27:03 <Nux_> I'm not
05:27:13 <Nux_> I'm avoiding even 'attempting to'
05:27:36 <fizruk> Wizek: AFAIK you can't
05:27:36 <Nux_> as in I've restructured the problem in such a way that the scenario never comes up
05:28:03 <indiagreen> if you need fast `elem`, you might be better off using Set too
05:28:20 <Nux_> that might be useful yes
05:28:44 <quchen2> If you need fast elem, implement a bianry search on an unboxed vector.
05:28:54 <indiagreen> okay, correction
05:29:03 <Nux_> so is there any (performance) cost involved from switching from lists to Data.Set?
05:29:24 <Nux_> not sure what an unboxed vector is
05:29:27 <indiagreen> if you need fast elem but not fast enough to be bothered to implement binary search on an unboxed vector
05:29:30 <fizruk> Wizek: it is definitely not possible to get pixel width/height of a Picture, because it only gets pixels when rendered
05:30:23 <guillaum2> quicksilver: (I found the hack in du which leads to more speed. I'm 5x times slower than system du and I'm still using 40 times more ram, but still, it works... And I have a pull request to send for the unix package ;)
05:30:32 <Wizek> fizruk, Is that so? For circles and rectangle I need to supply dimensions, and those are pixel values, are they not?
05:31:03 <Wizek> The picture could of course be scaled, but then those dimensions could be scaled with it
05:31:50 <Wizek> well, anyways, here is a higher level question: How could I write a bit of text on screen, and put it inside a neatly fitting rectengle?
05:32:17 <Wizek> The content of the text is unkown and may be dynamic
05:32:33 <Nux_> Unboxed types... are these types that have a concrete representation on the machine?
05:32:48 <merijn> Wizek: What kind of box? Like terminal output?
05:32:53 <Wizek> The most straightforward way I could think of is asking gloss what the width of the 
05:33:03 <Wizek> text
05:33:05 <aweinstock> yes (stored contiguously, no/few heap allocations/pointers)
05:33:12 <Wizek> merijn, It is more like a node in a graph
05:33:15 <aweinstock> Data.Vector.Unboxed is kind of like a C array
05:33:19 <Wizek> and the text is the content of the vertex
05:33:24 <fizruk> Wizek: the font Gloss uses in not of constant width
05:33:50 <quicksilver> guillaum2: (and what is du's hack, you mean the fts_ functions?)
05:33:51 <Wizek> correct
05:33:57 <mroman_> There's nothing like Data.Map.IO is there?
05:34:19 <Nux_> aweinstock, is there anything to be aware of in the way they behave?
05:34:40 <Nux_> aweinstock, I imagine I'm going to be made very aware of implementation quirks when working with them
05:35:00 <aweinstock> (i.e. (Data.Vector.Unboxed Word8) is the same as (std::vector<unsigned char>), (Data.Vector Word8) is (std::vector<std::unique_ptr<unsigned char>>))
05:35:47 <aweinstock> Data.Vector has a pure interface which looks kind of list-ish, but with fast indexing (but O(n) cons)
05:36:16 <mroman_> nvm. seems there's a Data.HashTable.IO package
05:36:17 <aweinstock> Data.Vector.Mutable lets you run ST computations in-place on vectors
05:36:57 <Wizek> Okay, so if gloss can't do this, is there some alternative that can? It is a UI that I want to write, but I'd need quite a bit of control. E.g. with the canvas of JavaScript, and there AFAIK if I have a text object, I can ask the renderer what the width is going to be
05:37:35 <aweinstock> Nux_: but it sounds like you probably want Set as a quick code change to bring `elem` down from O(n) to O(log(n)) with no change in style
05:37:35 <fizruk> Wizek: I guess the best you can do is limit number of symbols to maximum number of widest symbols that fit into rectangle
05:37:59 <Nux_> aweinstock, cheers I'll give it a go
05:38:28 <aweinstock> Nux_: binary search on a sorted Data.Vector.Unboxed is also O(log(n)), but with better constant factors/cache footprint/lower memory use
05:38:50 <Nux_> makes sense
05:38:51 <Nux_> cheers
05:38:52 <Wizek> well, I know of a workaround that would work quite perfectly, it would just be a PITA to implement: measure the pixel width of individual letters, and add them together based on the string input
05:38:58 <aweinstock> Nux_: (but that would complicate your code, and is only for if you *need* that last drop of performance)
05:39:04 <Wizek> then take into consideration all the scales and rotates
05:39:12 <Wizek> and then I would have my number
05:39:14 <Nux_> aweinstock, I agree
05:39:26 <quicksilver> Wizek: yeah I think gloss can't do this.
05:39:40 <Nux_> aweinstock, in terms of readability my code would probably benefit from using Data.Set
05:39:41 <Wizek> Is there any other lib/framework that can?
05:39:46 <quicksilver> aweinstock: I have the impression he is also adding elements; unboxed vectors are not great for adding.
05:40:18 <quicksilver> Wizek: last time I did this I used freetype and hopengl
05:40:23 <aweinstock> quicksilver: I mentioned O(n) cons already
05:40:28 <Wizek> I am also tempted to peek inside the internals of gloss to see if they do calculate these values and maybe I could expose it easily.
05:40:38 <quicksilver> Wizek: it is considerably less simple
05:40:48 <Nux_> cheers for your help guys
05:40:49 <guillaum2> quicksilver: (mostly they do not follow symlink by default ;) This is not really a hack, but it changes the number of files a lot.
05:40:51 <aweinstock> but yeah, it might even be O(n*log(n)) to insert while preserving ordering?
05:41:07 <quicksilver> Wizek: AIUI they're using badly supported opengl vector fonts with no proper metric
05:41:26 <quicksilver> Wizek: the design goals of gloss include simplicity and crossplatform ness; font loading is a pain.
05:42:47 * hackagebot mida 0.4.4 - Language for algorithmic generation of MIDI files  https://hackage.haskell.org/package/mida-0.4.4 (mrkkrp)
05:43:00 <guillaum2> (Damned, my first github pull request is an haskell one... I'm impressed by myself)
05:44:03 <jophish_> guillaum2: way to go! Many more please!
05:46:46 <Wizek> quicksilver, well, I see what you mean, but I don't yet mind using the built in vector font, it is just the lack of dimension-introspection that I am surprised and disappointed by
05:46:56 <Wizek> e.g. even if I compose a picture of simple shapes
05:47:05 <quicksilver> I agree
05:47:06 <Wizek> and scale and rotate stuff inside
05:47:12 <quicksilver> you've kind of reached the limits of gloss :(
05:47:14 <Wizek> I might still want to query the dimensions
05:47:15 <quicksilver> which is a shame.
05:47:32 <Wizek> Well, I am glad I did so quickly, as I started toying with it yesterday :D
05:48:07 <Wizek> But, I still am tempted to peek in there, maybe this functionality could be easily exposed
05:48:23 <saulzar_> I just use an approximation of the font length, gloss looks pretty bad anyway so it hardly matters if it's not quite right :)
05:48:56 <Wizek> saulzar, oh, you do in production? Can I see how that looks? :D
05:48:57 <Jinxit> the character widths should be in the font, for proper kerning
05:49:05 <Wizek> saulzar_, ^
05:49:10 <quicksilver> Jinxit: it's not a font.
05:49:13 <quicksilver> it has no metrics.
05:49:15 <Jinxit> ah, my bad
05:49:28 <quicksilver> it's an obsolete - deprecated - way of drawing text with opengl
05:49:35 <saulzar_> I don't think anyone would use gloss in production..
05:49:39 <quicksilver> Wizek: have you seen the diagrams package?
05:49:42 <quicksilver> it's ... different
05:49:52 <quicksilver> but has some of the same ideas and some entirely different goals
05:50:19 <Wizek> taking a look
05:50:35 <Sindriav_> Diagrams are dope
05:51:07 <fizruk> quicksilver: can one build GUI with diagrams?
05:51:59 <medicijnman> how can one make sure that when computing the minimum of a list that the function returns when e.g. the first negative value has been found?
05:51:59 <quicksilver> I don't think it can sensible be used for anything interactive, no
05:52:05 <quicksilver> I could be wrong.
05:52:16 <saulzar_> I've heard a lot of people say that diagrams is slow for interactive rendering - I'm curious if it's just the renderer (no good support for interactive rendering) or it's the algorithms inside
05:52:43 <quicksilver> it has many renderers
05:52:59 <Wizek> hmmm
05:53:03 <Wizek> it looks interesting
05:53:11 <Wizek> does it support interactivity?
05:53:16 <quicksilver> I don't think so
05:53:20 <Wizek> damn :(
05:53:40 <Wizek> it is a UI I want to write :D It would be boring if it were static :D
05:54:03 <saulzar_> http://projects.haskell.org/diagrams/blog/2015-04-30-GTK-coordinates.html
05:54:25 <fizruk> > foldr1 (\x acc -> if x < 0 then x else min x acc) [10, 9 ..]  -- medicijnman 
05:54:26 <lambdabot>  -1
05:54:52 <quicksilver> the only interactive GUIs I have done in haskell have been using wxHaskell or just hand coded opengl
05:55:01 <fizruk> > minimum $ takeWhile (>= 0) [10, 9 ..]
05:55:03 <lambdabot>  0
05:55:06 <saulzar_> I'm hoping to get it working with reflex - from what I can see it has all the picking support needed to make it interactive. I'm making prototypes on gloss first though
05:55:06 <quicksilver> other libraries exist though...
05:55:16 <medicijnman> fizruk: thanks that worked
05:55:45 <byorgey> quicksilver, Wizek, saulzar_
05:55:48 <byorgey> whoops
05:55:51 <fizruk> medicijnman: use takeWhile version, it's cleaner
05:56:14 <byorgey> quicksilver, Wizek, saulzar_: ocharles__ wrote a doom level editor GUI thing using diagrams
05:56:15 <jophish_> So here's a problem I've got, and I'm wondering what the idiomatic solution is: I have a module which defined a bunch of fun stuff. I want to make this stuff instances of lots of classes in other modules, but don't want to inflict having those modules as dependencies on my users (big packages like Diagrams). Is the idiomatic solution to create a new package "jophishmodule-diagrams-instances" full of awful orphan instances, or perhaps
05:56:15 <jophish_>  full of newtypes which are instances of things in diagrams, or is it best to just put a stack of dependencies in the initial package?
05:56:23 <pbl64k> exio4: apologies, I had to go afk. yes, https://github.com/pbl64k/gpif-datakinds/blob/master/IxFun.hs
05:56:25 <quicksilver> byorgey: wow
05:56:36 <medicijnman> fizruk: the takeWhile version differs from the foldr1. e.g.  [4, 3, (-1), (-3)] yields 3 in the takeWhile version but -1 in the foldr1 version
05:56:58 <pbl64k> exio4: I find the whole thing quite unsatisfactory, and the failure to unify types like this is the prime culprit
05:57:03 <Wizek> byorgey, Do you know where it is so I could take a look at it?
05:57:10 <Wizek> e.g. on GitHub
05:57:18 <pbl64k> exio4: so what I'm trying tight now is this:
05:57:19 <pbl64k> cataList' :: forall a b. (Either () (b, a) -> a) -> [b] -> a cataList' algebra = to . (alg `cata`) . from     where         cata :: (ListFunctor (Union (Const b) (Const a)) '() -> Const a '()) -> List (Const b) :-> Const a         cata = ixcata         alg :: ListFunctor (Union (Const b) (Const a)) :-> Const a         alg (IxIdUnit x) = from $ algebra $ to x
05:57:25 <pbl64k> argh, formatting.
05:57:37 <byorgey> Wizek: https://github.com/ocharles/hadoom
05:57:57 <exio4> pbl64k: use lpaste for those errors, btw, as pasting them here makes them impossible to read!
05:58:05 <saulzar_> byorgey, Ah, cool. Thanks!
05:58:08 <byorgey> Wizek: there's a video of it somewhere but I can't find it right now
05:58:09 <pbl64k> exio4: right, makes sense
05:58:16 <saulzar_> I'd heard about it actually, had no idea it used diagrams though.
05:58:43 <byorgey> so although diagrams is not explicitly trying to support interactive/real-time sorts of things it seems like it can be fast enough for simple-ish things
05:58:45 <pbl64k> exio4: error message: http://lpaste.net/141666
05:59:11 <pbl64k> exio4: code I'm trying right now: http://lpaste.net/141667
06:00:00 <byorgey> jophish_: if you ask the same question in #diagrams (so I don't forget) I will have time to think about it later
06:00:10 <byorgey> right now I have to run to class
06:00:14 <byorgey> if only I were teaching them Haskell
06:00:27 <jophish_> byorgey: sure, thanks!
06:00:53 <pbl64k> in short, ghc does not recognize "forall (x :: ()). t x" and "t '()" as the same type
06:01:09 <pbl64k> which is understandable, so I'm rather looking for a clever trick to get this through
06:02:29 <Wizek> byorgey, If you do find it please tell me, in the meantime I am trying to compile it
06:03:07 <exio4> pbl64k: let me check
06:07:58 <dredozubov> Do we have any russian-speaking public here? 6th installment of haskell-themed podcast "Bananas and lenses" is here. :) Please mention us on twitter or something.
06:09:37 <dredozubov> http://ruhaskell.org/posts/cast/2015/09/25/issue6.html link
06:17:44 <exio4> pbl64k: what about making the code more polymorphic? I don't really think there exists any property on the type level that tells you the only value of kind () is () either, I mean, there are things like `Any` there too
06:18:28 <exio4> pbl64k: so, instead of data Something ... (k :: ()) .. ; instance Blabla (Something ... () ..) you leave the () polymorphic in the class instances?
06:22:51 <malorie> hi. I'm writing a small pixel editor, and I want to add a feature that allows me to replace 2D pixel patterns with other pixel patterns. how'd I go about implementing something like that?
06:24:38 <malorie> my current approach is applying the pattern at every possible position, check for a match, and then emit the position; but that seems quite tedious, because I have to do a lot of book-keeping
06:25:27 <liste> malorie as in ▀▀ -> ▀▄ for example?
06:25:34 <malorie> exactly
06:26:21 <Hafydd> Hahaha.
06:26:48 <Jinxit> nice
06:28:06 <Jinxit> I don't think there's a more clever way to do it - you have to actually look for the pattern (or hash if it's sufficiently large to be worth it) in order to find it
06:28:51 <malorie> yeah, I guess so
06:30:26 <quicksilver> for perfect matches there is no clever way
06:30:42 <quicksilver> for fuzzy matches there is an entire research industry devoted to finding the clever ways :)
06:31:01 <malorie> nah, I like my matches exact :->
06:31:32 <Hafydd> If your pattern contains repeated subpatterns, there may be a clever way.
06:41:32 <Jinxit> you can of course break early as soon as a single pixel doesn't match
06:41:37 <Jinxit> but you might already be doing that
06:42:22 <Sindriav_> Is there a prefix version of (==) ?
06:42:26 <Sindriav_> e.g. not an operator
06:42:56 <malorie> Jinxit: not yet, I'm still working on the prototype. but, there are lots of optimizations to be made :-)
06:43:00 <quicksilver> no, Sindriav_ 
06:43:05 <Sindriav_> Welp/
06:43:05 <liste> Sindriav_ why not just use (==) ?
06:43:10 <geekosaur> Sindriav_, arguably you just wrote it
06:43:14 <quicksilver> the standard library generally has either infix or prefix but not both
06:43:17 <Sindriav_> liste: It's not great of mapping
06:43:20 <geekosaur> > (==) 5 5
06:43:21 <lambdabot>  True
06:43:30 <quicksilver> whereas some other libraries (e.g. lens) have a habit of providing both
06:43:35 <quicksilver> and giving the prefix one a better name
06:43:36 <Sindriav_> geekosaur: I stated "not an operator" afterwards specifically to prevent this remark.
06:43:46 <pbl64k> exio4: apologies, had to run off once again. unfortunately, that doesn't pan out either, at least my attempts at it. the problem is that I eventually want to get to mapping to ordinary types. and while that is possible to do, instantiating concrete anamorphisms becomes an enormous pain in the neck (you basically need to provide so much type-specific information that the whole advantage of being generic vanishes in a puff of smoke)
06:43:57 <Sindriav_> quicksilver: I see. Yeah, lens do have both most of the time
06:44:09 <Sindriav_> liste: It's not that great for fmapping
06:44:38 <Sindriav_> liste: ` eq Foo <$> action ` is neater than ` (==Foo) <$> action `
06:45:01 <quicksilver> that's a question of taste
06:45:06 <quicksilver> personally I find the second example fine
06:45:10 <pbl64k> exio4: even the current version is not generic enough. I would want `isocata' that wouldn't require anything much more than an isomorphism between the recursive data type and the fixed point of an indexed functor and an (automatically derived) isomorphism between base functor and ordinary unindexed type
06:45:18 <quicksilver> although, possibly, I'd write (Foo==) <$>
06:45:22 <pbl64k> exio4: but it doesn't seem the type system is powerful enough to do that
06:45:58 <exio4> pbl64k: hm, makes sense, I don't really know as I haven't played with this (I mostly avoid doing things kind of type hackery with type classes and instead try to either make it explicit or use other methods)
06:45:59 <Sindriav_> quicksilver: I don't know, I always felt weird about sections that are not for Num for some reason
06:46:20 <quicksilver> map (l!!) [1,2,3]
06:46:27 <quicksilver> map ($x) [f,g,h]
06:46:36 <quicksilver> are two sections which come up pretty often in this channel
06:46:40 <pbl64k> exio4: thanks for looking at it anyway
06:46:52 <Sindriav_> quicksilver: Yeah, the first example just makes me feel weird. the second one not so much
06:47:00 <Sindriav_> quicksilver: Even then, I'd prefer (\x -> x == Foo) for the sake of readability
06:47:26 <quicksilver> pbl64k: I don't entirely follow but it seems to me what you really wanted was kind-case
06:47:48 <quicksilver> pbl64k: so that if you had kind F you could case that down to E or L (sorry I forgot what your letters were)
06:47:50 * hackagebot streaming-commons 0.1.14.1 - Common lower-level functions needed by various streaming data libraries  https://hackage.haskell.org/package/streaming-commons-0.1.14.1 (MichaelSnoyman)
06:47:50 <Sindriav_> quicksilver: Maybe it's just that I'm not used to it :) I write (== Foo) because it's more lispy
06:48:00 <pbl64k> quicksilver: yes, pretty much so
06:48:20 <quicksilver> pbl64k: and similarly (vacuously) a kind-case for case () of () ->...
06:48:20 <pbl64k> quicksilver: but I don't want to dispatch on kinds, that would lose us some free theorems, wouldn't it?
06:48:28 <pbl64k> quicksilver: this case is very specific, though
06:48:42 <pbl64k> quicksilver: yes, and I think that's the *only* case I actually need
06:49:17 <pbl64k> quicksilver: for any other kind there's no isomorphism between forall (ix :: k). t x and t 'K
06:49:31 <exio4> @kind Any
06:49:32 <lambdabot> *
06:49:55 <tsahyt> Can I load the contents of a file at compile time and store them in a String or Text or something?
06:50:09 <liste> @hackage file-embed -- tsahyt
06:50:09 <lambdabot> http://hackage.haskell.org/package/file-embed -- tsahyt
06:50:28 <tsahyt> Thanks!
06:50:38 <quicksilver> pbl64k: there is a hack to use type families to get a kind-case because of the way type family resolution works
06:51:04 <pbl64k> quicksilver: I might look into that again, but in general type families seemed inappropriate here
06:51:24 <pbl64k> quicksilver: unless I'm much mistaken, those need to be fully applied? and I'm juggling higher-kinded types a lot here
06:51:46 <quicksilver> pbl64k: I can't find a proper reference. I had some memory of a mailing list posting. It's mentioned in passing in this bug report - https://ghc.haskell.org/trac/ghc/ticket/9171
06:52:08 <pbl64k> quicksilver: thanks, I'll take a look at that
06:54:07 <pbl64k> in case anyone's interested in what I'm trying to do here, this is basically ekmett's recursion-schemes, but more general in certain senses (arbitrary arity of functors)
06:54:44 <pbl64k> I believe McBride explored this first in unfinished "slicing it", and later discussed doing this using datakinds instead of SHE
06:55:23 <pbl64k> Loeh did this in Agda in Generic Programming with Indexed Functors
06:55:34 <zipper> Other than pattern matching how else can I get the a out of `newtype Sum' a = Sum' a`
06:56:00 <pbl64k> backporting that to Haskell in any general enough form would be, I think, very entertaining, if not necessarily practical
06:56:00 <ski> zipper : no
06:56:19 <pbl64k> but there's a lot of struggling against the type system going on
06:56:29 <liste> zipper (unsafe)Coerce ?
06:57:00 <zipper> liste: Is that a function?
06:57:08 <liste> unsafeCoerce and coerce are
06:57:15 <liste> :t unsafeCoerce
06:57:17 <lambdabot> Not in scope: ‘unsafeCoerce’
06:57:19 <liste> :t coerce
06:57:21 <lambdabot> (Functor f, Contravariant f) => f a -> f b
06:57:24 <zipper> Why did you use brackets up there?
06:57:32 <zipper> You wrote newtype Sum' a = Sum' a
06:57:36 <liste> to refer to both of them
06:57:42 <zipper> Oh
06:57:46 <liste> coerce is some GHC magic thing I guess?
06:57:48 <zipper> And I pasted the same thing
06:57:50 * hackagebot hills 0.1.2 - Generate STL models from SRTM elevation data.  https://hackage.haskell.org/package/hills-0.1.2 (djf)
06:58:07 <merijn> liste: That coerce is from lens
06:58:15 <liste> zipper https://wiki.haskell.org/GHC/Coercible this is the right coerce
06:58:17 <merijn> liste: GHC also has a safe "coerce :: a -> b" function
06:58:42 <ski> zipper : why is pattern-matching not good enough ?
06:58:52 <zipper> ski: For the repl
06:59:01 <zipper> ski: nothing practical
06:59:04 <ski> i don't understand
06:59:14 <ski> if you want to, you could define
06:59:20 <ski>   getSum (Sum' n) = n
06:59:29 <ski> and then use `getSum' in expressions in the interactor
06:59:37 <liste> zipper or even newtype Sum' a = Sum' { getSum' :: a }
06:59:42 <ski> (but that's still using pattern-matching)
07:02:54 <speedstoned> How can i spoof mac addresses of android phone permanently
07:03:07 <liste> speedstoned try #android-dev
07:08:37 <beaky> hello
07:08:41 <beaky> what is the best haskell orm
07:08:54 <beaky> something like sqlite in haksell
07:08:58 <beaky> sqlalchemy*
07:09:11 <speedstoned> How can i spoof mac address of and android device permamently
07:09:20 <liste> beaky there isn't any, haskell is not OO, but there are data mappers which are kinda similar
07:09:28 <beaky> ah
07:09:35 <liste> persistent+esqueleto, opaleye, haskelldb
07:09:35 <geekosaur> speedstoned, ask in an appropriate channel
07:09:39 <beaky> i thought things like persistent and esqueleto were orms
07:09:49 <beaky> ok ill check out opaleye and haskeldb then
07:10:07 <beaky> i tried persistent and esqueleto and they felt too magic 
07:10:48 <liste> postgresql-simple has less magic
07:12:48 <liste> beaky if you struggle with HaskellDB documentation, check this: http://chrisdone.com/posts/haskelldb-tutorial
07:12:48 <beaky> i tried postgresql-simple it felt too stringy 
07:13:00 <eacameron> I need to build a web-app with DB persistence and AJAX-based interactions, what's the best framework for that, Haste?
07:13:01 <liste> then opaleye may be for you
07:13:28 <liste> eacameron Haste only covers the client side
07:13:38 <eacameron> liste: I thought it did both?
07:14:20 <tsahyt> How can I force stack to recompile?
07:14:26 <liste> eacameron well you can use Haskell on both sides but the client side is handled by Haste
07:14:38 <tsahyt> Nevermind, --force-dirty does it apparently
07:15:11 <beaky> stack is awesome
07:15:49 <zipper> beaky: IKR
07:16:09 <liste> eacameron and the client<->server communication
07:16:12 <beaky> yes to install something i can just do 'stack install' and it magically installs stuff
07:16:42 <liste> you still need to access DB from purely the server side
07:16:46 <eacameron> liste: hmm, weird, I thought haste had a client monad and a server monad and would build both sides
07:17:13 <eacameron> it seemed that there was SOME framework that tried to do both, I thought
07:17:15 <the_2nd> how can I change the GUI theme of leksah? not the editor itself
07:17:16 <tero-> beaky: I use persistent and esqueleto happily 
07:17:18 <eacameron> MFlow?
07:17:26 <Jacoby6000> Does anybody know of some papers that show that typesafe languages are more advantageous than unityped languages in practice? I've got a CS paper i have to write and was hoping you guys knew of some resources
07:17:45 <merijn> liste: Haste doesn't let you use haskell, afaik
07:18:06 <merijn> Jacoby6000: The problem with your question is that there is no such thing as a "typesafe language"
07:18:18 <merijn> Jacoby6000: Languages can only by typesafe with respect to a defined model
07:18:31 <eacameron> merijn: Haste doesn't let you use haskell??? What does that mean?
07:18:49 <merijn> Jacoby6000: I recommend carefully reading Harper's comments here: http://www.pl-enthusiast.net/2014/08/05/type-safety/
07:18:50 <beaky> tero-: me too so far i am happy with them 
07:18:50 <liste> eacameron it does both sides (for client<->server communication), but it doesn't do DB access, at least any that I know
07:18:55 <merijn> eacameron: Haste is not haskell
07:18:57 <beaky> and when i need raw sql i can rawExecute
07:19:09 <merijn> eacameron: Haste is a subset of haskell, so any valid haste happens to be valid haskell, but not vice versa
07:19:13 <geekosaur> the_2nd, not entirely sure what you're asking, but it's gtk and admits to the usual gtk theming (location and form depends on gtk version)
07:19:20 <eacameron> merijn: Oh
07:19:27 <merijn> eacameron: So you can use Haste on client and server side (where the server side compiles Haste using a Haskell compiler)
07:19:39 <merijn> eacameron: But not every arbitrary Haskell expression will work on the client
07:19:44 <eacameron> merijn: Oh I see
07:19:54 <merijn> That's the main selling point, imo of ghcjs
07:20:10 <merijn> The fact that any haskell package (not counting those using the FFI) can be compiled for the client side
07:20:23 <eacameron> liste: merijn: so what's the best route to take? I don't want to learn JS much right now and I don't have much time; I just need a webpage to ask for data via AJAX and I'll query a db for it
07:20:52 <eacameron> sounds like I still need to write two apps: client and server
07:21:03 <eacameron> but they can both be in haskell, and potentially share libs that I write
07:21:07 <the_2nd> geekosaur, it doesnt seem to set the background color e.g.
07:21:18 <liste> eacameron haste for the shared parts, something like persistent+esqueleto for DB access
07:21:55 <merijn> liste: Why not ghcjs for shared parts? Then you're not limiting the code you can use server side
07:22:05 <eacameron> liste: so GHCJS doesn't do communication with server?
07:22:18 <merijn> eacameron: No, it just compiles haskell to JS
07:22:26 <eacameron> in other words, is there something for haste or GHCJS that will build AJAX stuff for me?
07:22:36 <liste> merijn that would work too (:
07:22:42 <merijn> eacameron: Sounds like you want Ur/Web :p Except the docs of that are even more non-existent for Haskell :)
07:22:57 <eacameron> merijn: Yes that's exactly what I want...In Haskell :D
07:23:07 <merijn> eacameron: Doesn't exist yet, afaik
07:24:05 <eacameron> merijn: So I need to build a server-side API with normal GHC, etc. Then build a client side with GHCJS and manually use the FFI to do AJAX....
07:24:24 <tero-> would cloud haskell work with ghcjs?
07:24:25 <merijn> eacameron: Pretty much, there might be libraries for parts of that
07:24:38 <eacameron> merijn: liste: thanks much
07:26:21 <liste> eacameron yw (: btw, from haste web page: "Haste program can be compiled [...] into a JavaScript file and a server-side binary, with strongly typed communication between the two"
07:26:42 <liste> but yeah, ghcjs is *real* haskell
07:27:04 <liste> well, *real* ghc
07:27:19 <eacameron> liste: the bummer is I'll bet Haste doesn't support the db libs I need :(
07:27:29 <beaky> btw why do we need monads if monads are also applicative functors
07:27:31 <tero-> I'm very intrigued by PureScript
07:29:24 <tero-> ghcjs comes with a magical runtime and outputs a ton of JS 
07:29:56 <Myrl> is there an interpreter monad which allows me to limit the execution time?
07:30:01 <ARM9> I feel like all to javascript compilers have that problem (except coffeescript since it's basically just js)
07:30:17 <beaky> i think 
07:30:28 <beaky> some like purescript dont have that overhead
07:30:29 <ARM9> dart, clojurescript, elm, you name it
07:30:44 <ARM9> I haven't tried purescript yet so I don't know about that one
07:32:51 <eacameron> beaky: Monads are applicative functors, but applicative functors are not monads. Monads add something to the mix
07:34:55 <beaky> oh
07:34:57 <beaky> what do they add 
07:35:13 <fabian__> Im using acid-state to keep an IxSet with client data on a server. However, if I add some data and then remove all of it, the DB just keeps growing
07:35:43 <fabian__> even if I archive every 15 seconds and  create checkpoints. The DB on disk also keeps growing
07:37:43 <hodapp> PureScript generates much cleaner JS, from what I've seen.
07:37:52 <alpounet> fabian__: probably because it writes a transaction log, instead of just maintaining "the data that's currently there"?
07:39:19 <eacameron> beaky: intuitively, monads add the ability to "sequence" different monadic contexts in a particular order. That's why you need them for IO. Applicative gives you context-based actions and function application, but it does not let you choose ordering, specifically
07:39:44 <beaky> oh
07:39:56 <beaky> i always thought applicative had ordering
07:40:08 <beaky> esp the order in which side of <*> you put things
07:40:20 <fabian__> alpounet: but then how does one use it with normal mounts of RAM?
07:40:32 <beaky> (unless  its comutative0
07:41:03 <eacameron> <*> is function application within a context, so it's only ordering in the same way that function arguments are ordered
07:41:10 <beaky> right
07:41:59 <eacameron> but it's not "sequenced"; i.e. you can't choose what happens BETWEEN consecutive applicative actions
07:42:39 <eacameron> since monad depends on sequence ordering (via bind), you can choose to, say, stop sequencing, log to a file, etc.
07:43:08 <eacameron> applicative can't do short-circuiting do blocks, for example
07:43:20 <eacameron> where one action prevents the others (like when or unless)
07:43:46 <eacameron> because all applicative actions must be known *at once*
07:43:50 <beaky> oh
07:45:00 <beaky> what about maybe isnt that an example of short circuiting aplicative
07:45:21 <alpounet> fabian__: if you use Data.Acid.Local/Remote, then the log files will grow but the RAM should not get filled up
07:45:29 <ski> eacameron : "but it does not let you choose ordering" sounds a bit inaccurate/unelaborated (see `(<**>)',`(<*)',`(*>)')
07:46:41 <ski> beaky : i would say that with `Applicative', the "structure" of the actions is static/fixed. can't be determined partially by the particular result of executing earlier parts of it. unlike for monadic actions
07:47:03 <eacameron> ski: beaky: that's a much better description than mine :D thank you
07:47:18 <beaky> but for monads the values determine the sturcture?
07:47:21 <eacameron> beaky: yes, applicative actions cannot depend on the *result* of previous actions
07:47:41 <ski> (eacameron : iow, i don't think you have it wrong. i'm just saying that i think your explanation could easily be interpreted badly)
07:48:36 <eacameron> ski: (thanks, I'm pretty new to helping others understand monads....ya'll likely have way more experience)
07:49:22 <ski> beaky : using `Maybe',`Either e' or a parser, using an applicative interface, is not (in this sense) an example of "short circuiting", or letting the results of previous parts of the execution determine *what* action the later parts of the execution will execute
07:50:20 <indiagreen> can someone give me a particularly bad example of @pl'd code?
07:50:41 <beaky> @pl \x y z -> x y z y x y z
07:50:42 <lambdabot> flip flip id . (ap .) . join . (flip .) . (flip =<< (flip .) . (flip =<<))
07:50:49 <quicksilver> @pl f a b c d e = e d c b a f
07:50:49 <lambdabot> f = fix (flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))))
07:50:52 <eacameron> beaky: right, but it is true that applicative is a subset of what monad can do, hence the ApplicativeDo extension we'll all waiting for :D
07:51:05 <indiagreen> I like beaky's more
07:51:06 <indiagreen> beaky++
07:51:10 <indiagreen> thanks everyone, tho
07:51:16 <exio4> er, applicative a subset of monad? 
07:51:34 <exio4> oh, I see
07:51:39 <quicksilver> the theorems about applicative are a subset of the theorems about monad
07:51:45 <quicksilver> because monads are a subset of applicatives
07:51:49 <quicksilver> duality is confusing :)
07:51:57 <eacameron> exio4: not mathematically speaking, but in terms of ability.
07:51:57 <ski> beaky : consider something like `(string "a" *> pure A) <|> (string "b" *> moreStuff)', being a parser. in one sense, you could say here that the result of the earlier parser execution (here either succeeding in eating an `a', alternatively a `b' from input) determines "what to do afterwards"
07:52:23 <ski> beaky : however, that doesn't matter for the sense of "static vs. dynamic structure" that we're talking about here
07:52:50 <eacameron> ski: ah yes, that's a great example
07:52:51 <ggole> Hmm: @pl doesn't type check the code?
07:53:13 <geekosaur> not really
07:53:14 <ggole> @pl \x -> x x
07:53:14 <lambdabot> join id
07:53:18 <ggole> Right.
07:53:29 <ski> exio4 : `Monad m' implies `Applicative m'. so the set `{m | Monad m}' (a subset of the set of functors) is a subset of `{m | Applicative m}'
07:53:45 <fabian__> alpounet: When the server is running, the Archive is quite small, but  then I restart the server, everything is moved to Archive and RAM is low
07:54:30 <fabian__> alpounet: why can that be? I call 
07:54:32 <fabian__> createCheckpoint db createArchive db
07:54:34 <eacameron> ski: well I'll be....
07:54:41 <ski> eacameron : don't let me discourage you from attempting to help, when you think you can make a positive difference :)
07:55:07 <exio4> ski: yeah, I read the phrase wrong at first 
07:55:13 <geekosaur> the transformations it does are mechanical; feed it badly typed input and it produces badly typed output, and occasionally it will generate badly typed output on its own because the mechanics don't know you did something clever with the types
07:55:54 <eacameron> ski: haha, no worries. What I mean is "anything Applicative can do, Monad can do, and then some"
07:57:31 <beaky> yes monads are more powerful one thing you can do is decide the result by the function vs. applicatives having result decided by the outside
07:58:02 <ski> exio4 : but also see what quicksilver said, if you missed it
07:58:26 <ski> eacameron,beaky : ndm's <http://neilmitchell.blogspot.se/2014/07/applicative-vs-monadic-build-systems.html> in 2014-07-23 might be interesting in better understanding the difference in power between monadic and idiomatic actions
07:58:50 <exio4> ski: I read 
07:58:57 <exio4> er, I have read it* 
07:59:04 <eacameron> beaky: I think that's actually where I finally understood the difference
08:01:55 <eacameron> Learning highly abstract things takes seeing a few good examples. Sort of like teaching a child their colors. You can't really accurately describe "green"
08:02:00 <ski> eacameron : another way to think about it is that for monadic actions, part of the "logic" (by which i mean further sub-actions) will lie inside (the body of) functions (because `>>=' takes a function that returns an action, as right argument)
08:02:24 <ski> eacameron : while for idiomatic actions, there's no such sub-actions hiding behind functions
08:03:02 <eacameron> ski: ah yeah, that's a really good way of seeing it. Monads are like Onions... ;)
08:03:13 <eacameron> Monadic actions, that is
08:03:14 <ski> (concretely, this e.g. means that you can traverse the full of a free idiomatic action, but not a free monadic action)
08:04:14 <eacameron> ski: right because the monadic action's structure is dynamically determined during execution
08:04:24 <eacameron> or is that right...
08:06:14 <athan_> Hi everyone. How can I use a DiffTime to subtract time from UTCTime?
08:06:16 <ski> i think "dynamically determined during execution" here specifically means that it is determined by the values passed to the function right argument of calls to `>>='
08:06:35 <athan_> I don't see any DiffTime -> NominalDiffTime functions, that's why I'm confused :\
08:07:38 <ski> .. or, if you're thinking in terms of `join', then it is related to taking an `M (M T)', executing (as usual) it, and then interpreting the resulting monadic result value (of type `M T') (which has been "dynamically constructed") as a further "list of instructions" to perform
08:08:55 <ski> however, in one sense, the whole structure is statically determined. you can think of a function of type `T -> M U' as a datastructure collection, that has one `M U'-shaped slot for each value of type `T'
08:09:21 <eacameron> ski: huh, wow, yep that makes sense
08:10:50 <geekosaur> athan_, realToFrac should work, although I imagine there are better ways
08:10:52 <ski> (but then you must know what type `T' is to be able to "inspect" that. if you know `mu, of type `M U', is of the shape `mt >>= tmu', with `mt :: M T' and `tmu :: T -> M U', then you generally don't know what type `T' is)
08:11:34 <eacameron> athan_: Perhaps you need to build a UTCTime with it by adding a day value: UTCTime day diffTime
08:11:38 <frerich> Funny, I also oftne have an 'onion' idea in my mind when thinking about monads such that in 'm >>= f' there is a bit of logic hidden in >>= and a bit of it 'f'.
08:12:36 <eacameron> frerich: One man's onion is another's burrito
08:13:54 <frerich> eacameron: One of my colleagues actually once explained monads in terms of the colors of a rainbow - imagine the vivid language!
08:14:15 <frerich> He's usually a somewhat boring guy though, so I accepted the chromatic exuberance. ;-)
08:15:02 <frerich> Boring is unfair, sorry.
08:15:17 <frerich> He's more like... un-excited, even by German standards.
08:20:21 <athan_> eacameron: Ahh okay, thank you
08:20:35 <athan_> geekosaur: I'll give it a go :P
08:22:55 * hackagebot HPi 0.5.0 - GPIO, I2C and SPI functions for the Raspberry Pi.  https://hackage.haskell.org/package/HPi-0.5.0 (WJWH)
08:23:52 <ski> eacameron : oh, i forgot to say that you could possibly think of the `M'-layers in `M (M (..(M (M T))..))' which is what you get if you delay the `join'ing to the end, as being "onion layers" :)
08:23:57 <ttt_fff> is there a one-line way of saying "if it matches this pattern, return Just (); else return Nothing"  ?
08:24:34 <ski>   listToMaybe [() | <pat> <- [<expr>]]  -- ?
08:24:39 <eacameron> ski: bingo
08:24:49 <ttt_fff> https://gist.github.com/anonymous/8e2d31be71ea5d74aac1 <-- 
08:24:54 <ttt_fff> like blah, but just one line
08:25:04 <ttt_fff> i.e. I only wan to specify the (Cat _ 20) pattern
08:25:22 <eacameron> athan: you also might be able to just do the subtraction, perhaps with some 'toIntegral' thrown in
08:26:05 <ski>   blah foo = listToMaybe [() | Cat _ 20 <- [foo]]  -- ttt_fff, ?
08:26:14 <ttt_fff> ski: hmm, that is cute
08:26:23 <ttt_fff> though seems rube goldberg-esque
08:26:27 <ttt_fff> constructing a list for this purpose
08:26:36 <ski> with MonadComprehensions, you could skip the `listToMaybe'
08:27:06 <ski> (oh, but you have to use `return' (or `Just') instead of the singleton, then)
08:27:08 <ttt_fff> i was hoping to 'treat pattern matching as first class object'
08:27:08 <Intolerable> case x of { Cat _ 20 -> Just (); _ -> Nothing } 
08:27:09 <Intolerable> ?
08:27:13 <Intolerable> whats wrong w/ that?
08:27:29 <ski> presumably ttt_fff doesn't like it having two "branches"
08:27:30 <ttt_fff> Intolerabe: it's sorta ugly, and I have to do this for many options
08:27:36 <ttt_fff> ski: yeah, exactly
08:27:40 <ski> (which the original also had)
08:29:35 <quicksilver> preview (_Cat . filtered ((==20).snd) . to (const()))
08:29:42 <quicksilver> and no, I don't think that's an improvement :P
08:32:52 <lunaris> Hi all. I'm using the reflection package and notice that it uses Proxy for type specification.
08:32:58 <quicksilver> ttt_fff: somewhat quirky to be using Just()/Nothing instead of True/False, any particular reason?
08:33:16 <lunaris> Is there a cost to this at runtime? I'm aware of GHC.Prim.Proxy#, which as I understand it, bears no cost at runtime.
08:33:16 <ttt_fff> quicksilver: 3rd argument of Text.Parsec.Prim.token
08:33:22 <ttt_fff> it wants token -> Maybe a
08:33:38 <tulcod> lunaris: Proxy stuff might be optimized away? 
08:33:42 <lunaris> And wonder why reflection doesn't use Proxy# (whether it's a portability argument or there's not cost etc)
08:33:52 <lunaris> tulcod: I guess that's what I'm wondering.
08:34:01 <tulcod> lunaris: i mean, that's what i'd say intuitively, since it's just for compile-time type safety, which *should* get optimized away
08:34:03 <lunaris> But then I wonder why Proxy# exists if Proxy should be optimised away.
08:34:16 <lunaris> There is a runtime value Proxy :: Proxy k a though.
08:34:18 <tulcod> lunaris: isn't it just the unpackaged variant of the latter?
08:34:30 <Myrl> Is there a way to limit the execution time of something?
08:34:36 <tulcod> lunaris: well yeah but that's like () :: (), which hopefully gets optimized away
08:34:47 <tulcod> no, that's not true
08:34:49 <tulcod> undefined :: ()
08:34:53 <lunaris> "A Proxy# is not only unboxed, it also has a polymorphic kind, and has no runtime representation, being totally free."
08:34:58 <lunaris> From the GHC.Prim docs.
08:35:08 <lunaris> Hence my wondering about Data.Proxy's boxed variant.
08:35:35 <tulcod> lunaris: okay, maybe I am not so sure. but i don't think this is the right way to think about performance
08:35:43 <ski> @kind GHC.Base.Proxy#
08:35:44 <quicksilver> lunaris: IIRC reflection is older than Proxy#
08:35:45 <lambdabot> k -> #
08:36:35 <lunaris> tulcod: I concede that it's a premature optimisation in practical scenarios; I'm mostly just curious :)
08:37:19 <lunaris> Since reflection doesn't seem like a library where portability would be an argument (it is relying on the dictionary-passing transformation which, albeit common in Haskell implementations, isn't in the standard AFAIK)
08:37:21 <tulcod> lunaris: okay, then I have nothing to offer you, except to suggest you to look at the Core output
08:37:27 <athan> note to self - never pass-around Database.Persistent keys to outside functions - associated type inference totally breaks and you have to rittle your code with `toSqlKey`, `fromSqlKey` and `fromIntegral`
08:37:36 <tulcod> and other intermediary representations
08:38:20 <lunaris> Ok; guess I'll do that. Thanks.
08:38:54 <begriffs> These days is it better to omit dependency version constraints in a project cabal file since Stack picks the packageset?
08:39:48 <tulcod> begriffs: not everyone uses stack
08:40:06 <indiagreen> begriffs: if you're going to publish this on Hackage, no
08:40:29 <indiagreen> even if you're not going to, well
08:40:35 <tulcod> begriffs: having said that, (and i'll get shot down for this) it's better to have no version constraints than wildly incorrect version constraints
08:41:22 <begriffs> Yeah it's on hackage. As part of my continuous integration I run packdeps which identifies when my version constraints exclude the newest versions of packages. Every so often it blows up and I have to go adjust the constraints to allow the newer version (after verifying my project compiles with it)
08:42:37 <indiagreen> maybe you are setting too tight constraints
08:42:57 <begriffs> tulcod: would an unbounded constraint (like warp >= 3.0.2) be one of those "wildly incorrect" ones?
08:43:20 <indiagreen> e.g. you don't have to set “lens == 4.12.*”, just having “lens >= 4.8 && < 5” would probably be okay
08:43:25 <begriffs> indiagreen: the one it complained about was optparse-applicative == 0.11.* since 12 got released.
08:44:16 <tulcod> begriffs: i don't know. probably best to add && warp < 4, to be on a pretty relaxed yet not entirely permissive side
08:44:54 <begriffs> OK. And for the optparse constraint, would it be better to say >= 0.11 && < 1 ?
08:44:57 <tulcod> (though purists would say: add && warp < 3.2, since warp 3.1.3 is the latest version, and you don't know what's gonna happen)
08:46:08 <tulcod> begriffs: but something that would be wildly incorrect would be warp == 3.0.2, IMO, since that's waay too restrictive
08:46:19 <tulcod> causing at least as many problems as it solves
08:47:00 <begriffs> So the correct constraint is always >= [version where I know things work] and < [next major version] ?
08:47:34 <tulcod> begriffs: that would cover 90% of the cases, yes
08:47:51 <monochrom> I have seen optparse-applicative making substantial changes from 0.8 to 0.9. so >= 0.11 && < 1 will be a false promise of compatibility.
08:47:54 <Myrl> Guys?
08:48:21 <tulcod> begriffs: and then whoever has build problems can complain
08:48:32 <indiagreen> begriffs: technically, yeah. In practice I still think it's alright to do stuff like “lens < 5” for big libraries, but libraries like aeson and optparse-applicative can easily change between 0.x and 0.x+1
08:48:41 <tulcod> indiagreen: amen
08:48:43 <quicksilver> tehre is no perfect solution
08:49:08 <tulcod> indiagreen: base < 5 ?
08:49:14 <geekosaur> Myrl, http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/System-Timeout.html ?
08:49:14 <quicksilver> it's a judgement call based on how important your library is, how many users you believe depend on it, and your beliefs about the update strategies of your dependents
08:49:16 <indiagreen> tulcod: base < 6 :)
08:49:20 <tulcod> hehe
08:49:23 <indiagreen> seen it somewhere
08:49:24 <indiagreen> anyway
08:49:40 <monochrom> there is "base < 10"
08:49:52 <tulcod> monochrom: then you might as well not add an upper constraint
08:50:06 <indiagreen> begriffs: also note that if something is correct but too annoying for you to be actually doing then it doesn't matter how correct it is
08:50:21 <Myrl> geekosaur: Thanks! :D
08:51:08 <begriffs> OK, I'll try adding fairly permissive upper bounds to all my deps.
08:51:12 <indiagreen> so settle on the most correct thing that is still bearable and doesn't make you want to say “to hell with upper bounds”
08:51:36 <tulcod> begriffs: that sounds alright. but on the other hand, there's also --permit-newer, so you don't need to be /too/ permissive :P
08:52:17 <monochrom> here base < 10: http://hackage.haskell.org/package/judy
08:52:20 <tulcod> begriffs: but < [next major version after the version i know things work] will never get you flamed down for
08:53:44 <Myrl> Hmmm...
08:55:44 <arnabold> @pl \f g x y -> f (x ++ g x) (g y)
08:55:44 <lambdabot> join . ((flip . ((.) .)) .) . (. ap (++)) . (.)
08:56:08 * Intolerable screams
08:56:38 <tulcod> :t (.) . (.) . (.)
08:56:40 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
08:56:52 <Gurkenglas> There should be a tool to have lambdabot try all the permutations of variables in a @pl request and output the one with the shortest answer
08:57:56 * hackagebot stylish-haskell 0.5.14.2 - Haskell code prettifier  https://hackage.haskell.org/package/stylish-haskell-0.5.14.2 (JasperVanDerJeugt)
08:58:00 <Gurkenglas> (Yay for searching a superexponential space according to a utility function that doesn't align with human values!)
09:00:52 <IP92> can someone tell me why http://pastebin.com/nXXqhTTs the test function return the same string, although it should return "[a] -> [(b,a)]"
09:03:07 <Myrl> geekosaur: Do you think it'd be possible to use this along with Cont to do pseudo-preemptive multitasking?
09:04:01 <Myrl> geekosaur: And a better question would be, "is it worth the pain?"
09:04:18 <Myrl> Considering that we already have forkIO and the like.
09:04:56 <geekosaur> I would think it better to just compile without threaded and maybe run with +RTS -V0
09:05:09 <quicksilver> IP92: your dictionary is the wrong way around isn't it?
09:05:27 <quicksilver> IP92: it takes 'a' to 's' and 'b' to 't'
09:05:44 <quicksilver> IP92: swap the two parameters to 'zip' in line 15
09:05:59 <geekosaur> especially since when it comes down to it you're using the runtime's multitasking under the covers anyway (because that's how System.Timeout works)
09:06:12 <IP92> quicksilver: yes, that was the problem, thanks
09:06:43 <Myrl> geekosaur: Ah.
09:07:03 <exio4> timeout is starting a new thread, waiting a bit and then throwing an exception to that thread
09:08:42 <geekosaur> actually the exception is thrown by the thread; note comment about the thread ID not changing for the function run under timeout
09:09:40 <Myrl> exio4: Do you still remember me? :3
09:10:07 <exio4> geekosaur: oh, makes sense 
09:10:18 <exio4> Myrl: yes
09:10:55 <Myrl> exio4: :D That means I'm not as forgettable as I thought I was.
09:28:06 <danilo2> Hello guys! :) Is there any way in haskell to concatenate outputs of expansion in Haskell cpp macros? I mean, in CPP we can do something like `#define foo(name) name ## name` which just expands `foo(bar) to barber` - can we do something like that in Haskell's cpp macros version 
09:28:10 <danilo2> ?
09:28:38 <monochrom> have you tried?
09:28:48 <danilo2> sorry, in my question "barber" should be "barbar"
09:29:17 <mniip> in monochrom's question "tried" should be "actually tried it"
09:29:37 <geekosaur> ghc is just using C's cpp, it should just work. (if you have forced it to use hscpp, I would expect it to work but don't know for certain)
09:30:16 <monochrom> mniip: is the difference substantial enough for the correction?
09:30:38 <geekosaur> there *may* be some caveats if you are on a system with clang as its default compiler, as it's more aggressive about expecting ANSI C and Haskell code often confuses its preprocessor...
09:30:59 <mniip> monochrom, no I was just reiterating :P
09:31:04 <danilo2> Hmm, interesting, Im here on OSX and it does not work
09:31:12 <danilo2> I'll try though, thank you :)
09:31:29 <geekosaur> OS X would be one of those clang systems
09:31:43 <geekosaur> (recent FreeBSD also)
09:31:57 <edwardk> begriffs: fwiw- my experience with overly permissive bounds on anything but base is they tend to bite you later
09:32:27 <geekosaur> you may have to install a gcc from somewhere and build a custom ghc installation using it
09:32:37 <monochrom> mniip: if you want to reiterate, you say your own sentence, rather than tear apart mine and "correct" it like you're marking my English homework.
09:32:58 <geekosaur> or try installing hscpp and using -progP to point ghc to it
09:32:58 * hackagebot wai-middleware-content-type 0.0.1 - Route to different middlewares based on the incoming Accept header.  https://hackage.haskell.org/package/wai-middleware-content-type-0.0.1 (athanclark)
09:34:17 <mniip> monochrom, sorry, it was an unfunny (or failed) joke I guess
09:36:04 <danilo2> Ok guys, I'e tested the code (http://lpaste.net/141680) on Windows, Linux and OS X and it simply does not work, while this is just valid cpp macro :(
09:36:47 <danilo2> monochrom, geekosaur: this is a bit of work and it adds some time to maintenance the code. I wanted to just use a built in solution
09:37:22 <geekosaur> there is no built in solution
09:37:53 <geekosaur> ghc uses an external preprocessor. if the one it knows about is clang (mac/freebsd) then you will have problems with some things
09:37:58 * hackagebot dead-code-detection 0.3 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.3 (SoenkeHahn)
09:38:14 <monochrom> just checking, do you have {-# LANGUAGE CPP #-} ?
09:38:22 <monochrom> (is it CPP?)
09:38:32 <geekosaur> it is
09:39:14 <nchambers> so is there a good specialized editor/ide for haskell?
09:40:01 <ARM9> emacs, vim, pick your poison
09:40:21 <geekosaur> nchambers, not really. most people use emacs or vim with their various haskell support mechanisms. there are also haskell plugins for sublime text and atom that are reasonably well maintained
09:40:43 <nchambers> ah ok... thanks
09:41:01 <dgpratt> nchambers, many popular code editors have Haskell plug-ins or extensions, but Leksah is one that is just for Haskell code/projects
09:41:16 <geekosaur> (almost certainly others as well, those are the ones I'm aware of being well supported)
09:41:23 <dgpratt> which is not to say that Leksah is the best option
09:41:26 <nchambers> http://leksah.org/ ?
09:41:36 <dgpratt> yes
09:41:48 <geekosaur> leksah is there and maintained but I believe its maintainer still considers it something of a proof of concept
09:42:25 <ARM9> one problem with leksah is that it's so specific, I guess you can always extend it but why bother when there are already more mature options available
09:42:40 <nchambers> hrmm... maybe I'll go back to vim then
09:42:43 <ARM9> yeah it's a cool proof of concept for sure
09:42:52 <spaceloop> well actually, I'm contributing since a short while to Leksah, and we're working hard to make the next release work much better out of the box and make it a pleasent Haskell experience
09:42:58 * hackagebot wai-middleware-verbs 0.0.2 - Route different middleware responses based on the incoming HTTP verb.  https://hackage.haskell.org/package/wai-middleware-verbs-0.0.2 (athanclark)
09:43:55 <dgpratt> in my very brief experimentation with Leksah, I was fairly impressed
09:44:17 <geekosaur> I was under the impression it was still kinda light on things like refactoring
09:44:40 <kaidelong> no more so than intellij, emacs, vim, IIRC
09:44:49 <kaidelong> no semantic-aware search and replace in those
09:44:56 <geekosaur> then again I think the HaRe project finally woke up again a couple months ago...
09:45:26 <kaidelong> the main thing leksah has over other options is a project manager and project view
09:45:41 <dgpratt> yes, I've seen HaRe discussions recently on other haskell-related channels
09:45:41 <kaidelong> amazingly useful tools. Emacs and intellij pretend with file browsers
09:45:53 <spaceloop> yes, we're planning on integrating some more automatic refactoring with HaRe at some point in Leksah
09:46:21 <Sindriav_> Are there plans on introducing a more general way to handle tuples of different lengths?
09:46:29 <kaidelong> any intention to replace the "candy" with hasklig so that candy doesn't mess up indentation?
09:46:34 <dgpratt> alanz might know something about the status of HaRe
09:46:54 <kaidelong> Sindriav_: look for "extensible records"
09:47:07 <spaceloop> kaidelong: you could open an issue about that at https://github.com/leksah/leksah, I never use the candy feature
09:47:10 <kaidelong> you could also use length typed vectors but they are clunky
09:47:11 <Sindriav_> kaidelong: Thanks ^^
09:47:22 <Sindriav_> kaidelong: I was looking specifically for tuples though
09:47:47 <kaidelong> you need some kind of subtyping to handle tuples of different lengths
09:48:04 <kaidelong> well, if you really only care about taking 0 or many inputs, you could accept a list
09:48:36 <spaceloop> you can use typeclasses to write functions for nested tuples
09:48:48 <Sindriav_> kaidelong: Again. I'm not looking for a solution *now*. As the question states, I was wondering if there are plans for ways to handle *tuples* in a general way
09:48:57 <kaidelong> no
09:49:00 <begriffs> edwardk: ah OK. Well I'll continue my strategy of more modest bounds and rely on packdeps to yell at me when I need to update them.
09:49:04 <kaidelong> not to my knowledge
09:49:09 <Sindriav_> kaidelong: Shame. `(Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g,
09:49:10 <Sindriav_>           Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m)
09:49:10 <Sindriav_>         => Bounded (a,b,c,d,e,f,g,h,i,j,k,l,m)` is weird
09:49:20 <kaidelong> oh well
09:49:31 <kaidelong> I don't know of any plans to improve the situation of that for typeclasses
09:49:53 <kaidelong> extensible records will solve many of the same problems, and people are looking to eventually include that in haskell proper as the record abstraction
09:49:56 <kaidelong> but AFAIK, not that one
09:50:19 <Sindriav_> kaidelong: I see :) Well, I've never really used tuples to be honest, so it's not that much of a deal anyways
09:50:29 <kaidelong> one way to have handled this would have been to make (,) right associative
09:50:51 <kaidelong> then all you would have needed is an instance (Bounded a, Bounded b) => Bounded (a,b)
09:50:57 <kaidelong> and that would have generalized to all tuples
09:51:01 <kaidelong> but alas, they did not do that
09:51:40 <kaidelong> admittedly, that leads to some weird polymorphism in pattern matching
09:51:57 <Sindriav_> Ah, that's true
09:52:06 <kaidelong> you wouldn't expect the behavior of swap (a,b) = (b,a) to result in swap (1,2,3) = ((2,3),1)
09:52:10 <kaidelong> but I think the tradeoff is worth it
09:52:32 <Sindriav_> I guess extensible records are the way to go.
09:55:13 <kaidelong> I guess left associative would have worked too, wouldn't it?
10:02:22 <Cale> Larger tuples are something which just doesn't come up so much in real code, because people always define their own data types beyond a certain point.
10:02:44 <Cale> If you're using tuples larger than pairs, or maybe the occasional triple, something is wrong.
10:02:59 * hackagebot cabal-debian 4.31.7 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.31.7 (DavidFox)
10:04:39 <Cale> (and this is not just because the operations on large tuples are somewhat impoverished)
10:05:29 <Cale> We could do without the instances for 13-tuples and so on quite nicely.
10:05:57 <Welkin> Cale: 67-tuples
10:06:19 <Welkin> is there a functor instance for a 3-tuple?
10:06:34 <Welkin> > fmap (+1) (1,1,1)
10:06:36 <lambdabot>      No instance for (Show t0)
10:06:36 <lambdabot>        arising from a use of ‘show_M523503788681748100230468’
10:06:36 <lambdabot>      The type variable ‘t0’ is ambiguous
10:06:40 * mniip mentions https://ghc.haskell.org/trac/ghc/ticket/10648
10:06:45 <Welkin> > fmap (+1) (1,1)
10:06:47 <lambdabot>  (1,2)
10:06:49 <Welkin> guess not
10:09:37 <magneticduck> huge lists of imports are super ugly
10:09:49 <magneticduck> like, 50 lines of imports in a module
10:09:58 <mniip> place them all on one line!
10:09:59 <magneticduck> anybody here do anything to circumvent that problem?
10:10:06 <magneticduck> I mean
10:10:16 <magneticduck> I guess I could make a little module that just reexported a bunch of useful functions
10:10:23 <magneticduck> but.. is that bad style, or what? x)
10:10:41 <Welkin> magneticduck: the yesod scaffolding uses a module like that called Import
10:10:48 <Welkin> to reduce repetition
10:10:50 <CindyLinz> magneticduck: distribute them into 5 files, that each file imports 10...
10:11:00 <Welkin> it re-exports all the most common modules
10:11:04 <magneticduck> yeah
10:11:22 <magneticduck> I guess in haskell we don't care too much about knowing where the functions came from
10:11:24 <magneticduck> we just import and forget
10:11:28 <magneticduck> lol
10:12:00 <magneticduck> unlike some other languages like python where it's super bad style to import all the symbols from a module into local scope
10:12:10 <magneticduck> or javascript, where the 'with' keyword was deprecated
10:12:26 <magneticduck> maybe that's because haskell doesn't have 'metavariables' or whatever they're called
10:12:59 * hackagebot vcache-trie 0.2.3 - patricia tries modeled above VCache  https://hackage.haskell.org/package/vcache-trie-0.2.3 (dmbarbour)
10:13:00 <Sindriav_> magneticduck: Maybe because unused functions can be removed during compilation?
10:13:11 <magneticduck> uh
10:13:12 <Sindriav_> magneticduck: Although I suppose Python and JS also do that
10:13:17 <magneticduck> yeah
10:13:44 <magneticduck> also I don't see how using qualified imports would help, if that was an issue (which is generally isn't)
10:13:51 <jle`> hm, what's the purpose of "votes" on hackage?
10:14:17 <Sindriav_> jle`: I guess if two people implement the same thing, people can vote on which is better?
10:14:39 <Sindriav_> Namespaced packages would be nice
10:14:46 <voidzero> i'll just vote on who has the coolest nick
10:15:10 <jle`> i just click vote on everything i download but i think i'm doing it wrong
10:15:41 <magneticduck> democracy to the rescue
10:15:43 <Welkin> jle`: lol!
10:15:49 <Welkin> I have seen that too
10:15:56 <Welkin> most packages have 0 or 1 vote
10:16:12 <monochrom> geekosaur: (this is on linux) when GHC calls "gcc -E" for CPP, it also adds "-traditional". therefore, ## is not honoured.
10:16:14 <ski> the solution is clearly to never vote
10:16:14 <voidzero> 1 vote means jle` downloaded it
10:17:06 <jle`> anyone know how i'm supposed to use SNat from Data.Singletons.TypeLits ?  it's just a constructor with no fields so how am I supposed to gain anything meaningful from pattern matching on it
10:17:09 <geekosaur> hm, pretty sure I had seen stuff use it...
10:17:16 <geekosaur> hscpp should support it in any case
10:17:18 <jle`> i mean
10:17:22 <jle`> Data.Singletons
10:18:14 <jle`> case (x :: Sing 9) where SNat -> ..., how am I supposed to get the 9 back?
10:18:57 <jle`> wait did i type something wrong
10:19:04 <geekosaur> "of"?
10:19:18 <jle`> yeah, of, heh
10:19:35 <doomlord> is there   any change recently in haskell land with its' handling of records (c-like structs)
10:19:57 <jle`> like, i can do case (x :: Sing 'True) where STrue -> -- this will match; SFalse -> -- this will never match
10:20:05 <doomlord> (i haven't looked into haskell for a long time)
10:20:19 <quchen> doomlord: No, sadly.
10:20:38 <jle`> oh sorry i have confused everything
10:20:39 <Cale> Not sure if sadly? :)
10:20:39 <quchen> doomlord: OverloadedRecordFields has been on the horizon for over a year now, and there is also promising work by Nikita Volkov.
10:20:55 <quchen> But nothing's in GHC right now.
10:23:00 * hackagebot sdl2-compositor 1.0 - image compositing with sdl2 - declarative style  https://hackage.haskell.org/package/sdl2-compositor-1.0 (seppeljordan)
10:26:45 <mizu_no_oto> quchen, doomlord: there's also lens
10:27:27 <davidfetter> !lens
10:27:31 <davidfetter> hrm
10:28:05 <cocreature> @hackage lens
10:28:05 <lambdabot> http://hackage.haskell.org/package/lens
10:28:06 <mizu_no_oto> see e.g. http://statusfailed.com/blog/2013/02/19/overloading-record-fields-with-lens.html
10:28:44 <mizu_no_oto> Basically, there's some templatehaskell that will autogenerate typeclass based lenses
10:29:12 <quicksilver> record syntax isn't really a problem if you use lenses
10:29:15 <edwardk> davidfetter: i noticed you've been slumming around here a lot lately. getting more curious about haskell?
10:29:23 <quicksilver> you just, donit use record syntax except maybe for initialisation
10:29:38 <quicksilver> however the single name space for terms is.. one of those things
10:29:44 <davidfetter> edwardk, yeah. pm?
10:29:49 <edwardk> sure =)
10:30:06 <quicksilver> personally I like that haskell has one namespace but it's surprisingly and annoying if you're used to method names and properties being in their own private namespaces
10:30:18 <quicksilver> and I haven't seen any solution to that that isn't worse than the diseaes
10:30:27 <edwardk> quicksilver++
10:30:51 <mizu_no_oto> So there will be a HasFoo typeclass with a lens from a HasFoo t to a Foo.  Bar, Baz, Quux, and all the rest of your records that contain foo will have autogenerated implementations of HasFoo.
10:30:54 <quicksilver> obviously the (huge) plus point is compositionality in all kinds of ways that those languages can only dream of.
10:34:40 <breadmonster> Does Google use Haskell?
10:35:17 <mizu_no_oto> breadmonster: I don't think they use it to any great extent, but they've released some white papers on doing some stuff with it, iirc
10:35:20 <geekosaur> not so far as I'm aware, although they made it clear to me when they were headhunting me that my haskell experience was one of the things they were interested in
10:35:36 <breadmonster> geekosaur: Did you go?
10:35:41 <geekosaur> no
10:35:45 <breadmonster> I was wondering if it's a bad idea to use Haskell in an interview.
10:36:20 <gfixler> IME, using Haskell to explain things is frustrating for both parties
10:36:35 <geekosaur> (google's a bit of a high tension environment and I'm increasingly prone to panic attacks. ueghh.)
10:36:46 <magneticduck> uhh, I kind of thought haskell had support for all kinds of crazy recursive imports
10:37:00 <magneticduck> but I'm getting an error about a module being 'not loaded' when having an import scheme like
10:37:23 <magneticduck> module A (module A.B) where import A.B ; module A.B () where import A
10:37:32 <magneticduck> not possible? :/
10:37:42 <magneticduck> I mean, I can refactor it out
10:37:56 <geekosaur> magneticduck, the haskell standard allows that but ghc doesn't really support it
10:38:07 <geekosaur> there's some horkery with source imports and hs-boot files
10:38:15 <geekosaur> (which you should avoid if you can)
10:38:34 <magneticduck> hm okay
10:39:03 <breadmonster> gfixler: Shame, I got a recommendation, but like I don't know any other programming language comfortably enough.
10:39:28 <breadmonster> geekosaur: ghc doesn't implement the standard completely?
10:39:40 <gfixler> breadmonster: afaict, people are upset that I can write so little code that looks like the problem :)
10:39:42 <geekosaur> not with respect to recursive imports, no
10:40:00 <gfixler> breadmonster: "Yeah, well we're not using Haskell, are we?"
10:40:07 <geekosaur> known shortcoming.r ather hard to fix as I understand it
10:40:08 <breadmonster> gfixler: You're at Google?
10:40:15 <gfixler> breadmonster: no
10:40:26 <breadmonster> Oh right misread.
10:40:47 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bugs-and-infelicities.html#infelicities-Modules
10:41:00 <gfixler> I've observed a few times people not thinking Haskell looks like Real Programming™
10:41:43 <geekosaur> haskell is much higher level than many languages, so it does often look a lot like pseudocode to people used to other languages
10:41:49 <gfixler> yeah
10:43:52 <geekosaur> breadmonster, as noted in that link, the report does have some weasel-wording in acknowledgement that proper recursive import handling is a Hard Problem
10:46:50 <koala_man> breadmonster: I'm at Google, and no, the only somewhat significant haskell project is Ganeti. Starting a new project in Haskell is against the company's default language policy.
10:47:07 <breadmonster> koala_man: There's a default language policy?
10:47:11 <breadmonster> actually, may I PM?
10:47:17 <breadmonster> this isn't relevant here.
10:47:19 <koala_man> sure
10:48:42 <kaidelong> magneticduck: what people often do anyway is that they make Internal modules where the exposed modules in the library just re-export from those
10:49:06 <quicksilver> magneticduck: it's often quite reasonable to refactor so the common-common part of the mutal is in a central module and the others depend on it, breaking the recursion.
10:49:08 <kaidelong> it's a bit embarrassing but you can avoid the problem like that
10:49:21 <quicksilver> magneticduck: in those cases where it doesn't make sense you just get to complain about hs-boot files :(
10:49:49 <kaidelong> well it never really makes sense, code for separate concerns should not pollute the same file
10:49:56 <kaidelong> bad for readability
10:50:01 <quicksilver> also you can break apart recursive functions by passing them as an argument to each other.
10:50:07 <quicksilver> another hack tho :)
10:50:27 <quicksilver> actually you can do that with mutuall recursive data types too.
11:06:01 <kaidelong> has anyone compiled a list of the differences between f x = y and f = \x -> y in haskell?
11:06:30 <kaidelong> I know GHC violates eta equivalence at an operational level but I'm not aware of any good document explaining how
11:07:31 <shachaf> Well, there's the monomorphism restriction.
11:07:39 <shachaf> But as far as GHC goes the main difference is inlining, I think.
11:07:49 <shachaf> GHC will generally only inline saturated application.
11:08:10 <quchen> Not only inlining, but memoization/sharing as well.
11:08:22 <kaidelong> so f = \x -> y gets inlined more often than f x = y. in general?
11:08:26 <quchen> f x = expensive `seq` y -- will recompute expensive on each call
11:08:52 <kaidelong> oh, vice versa then
11:08:54 <quchen> f = \x -> exp `seq` y where exp = expensive -- will share expensive
11:09:15 <kaidelong> oh you are talking about sharing
11:09:29 <kaidelong> although sharing and inlining are related, to my memory
11:09:30 <quchen> I am talking about sharing. shachaf talked about inlining.
11:09:32 <Gurkenglas> Why did you put it into a where clause there?
11:10:04 <quchen> Gurkenglas: I forgot that in the first example for comparability. So it should have been "f x = exp `seq` y where exp = expensive" in the first example.
11:10:06 <shachaf> quchen: ?
11:10:35 <quchen> shachaf: ?
11:10:36 <Gurkenglas> f = \x -> expensive `seq` y wouldn't share?
11:10:58 <quchen> Not sure about that.
11:11:23 <kaidelong> I think it depends on if "expensive" is actually bound to expensive
11:11:41 <kaidelong> if it is being used to represent an arb. expression it might not be bound to some name
11:11:41 <shachaf> quchen: Are you sure about what you're saying?
11:12:09 <quchen> shachaf: Pretty sure, yes. I've had quite a few performance problems solved by eta-expanding functions.
11:12:11 <kaidelong> bc I do recall the optomization where you name things to prevent inlining
11:12:15 <kaidelong> err
11:12:17 <kaidelong> inlined behavior
11:12:18 <shachaf> Why should f x = exp `seq` y behave differently from f = \x -> exp `seq` y as far as sharing?
11:12:23 <kaidelong> I guess you are literally inlining them otherwise
11:12:25 <Gurkenglas> Reducing, you mean?
11:12:33 <shachaf> OK, can you write a small file that reproduces this?
11:12:36 <quchen> shachaf: because f is a CAF
11:12:44 <quchen> In the second example
11:12:49 <quchen> I'll try.
11:12:55 <shachaf> Which is a function.
11:15:43 <quchen> shachaf: http://lpaste.net/141682
11:16:10 <shachaf> What? That's completely different from what you said.
11:16:21 <shachaf> Obviously that's going to be evaluated differently.
11:16:31 <shachaf> f1 = let e = ... in \x -> ...
11:16:36 <shachaf> f2 = \x -> let e = ... in ...
11:17:16 <quchen> If you're saying that that's not strictly eta expansion you're right. But it certainly feels like it in practice.
11:17:33 <quchen> Anyway, that's what I meant to say.
11:17:35 <alanz> spaceloop, geekosaur, dgpratt : HaRe for 7.10.2 should be released within the next week.
11:17:50 <byorgey> \o/
11:17:56 <alanz> And I am keen on having people who know how to integrate it into IDE's
11:18:11 <shachaf> OK, but it's a red herring, and "I've had quite a few performance problems solved by eta-expanding functions." is misleading.
11:19:38 <Gurkenglas> Writing it like http://lpaste.net/141682#a141684 (pardon me missing to remove the last 3 comment lines) makes it clear that both would work identically
11:20:03 <quchen> Oh, I think I just misused the term eta expansion there. Long day.
11:20:23 <quchen> Apart from the fact that your let-commutation remark is also right.
11:20:59 <Gurkenglas> More interesting is how this one would behave http://lpaste.net/141682#a141685 . Too bad lambdabot doesn't support it.
11:29:32 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | http://reddit.com/r/haskell | Administrative issues: #haskell-ops | Hackage status? http://status.haskell.org | http://downloads.haskell.org'
11:29:32 --- topic: set by johnw!~johnw@c-98-214-120-98.hsd1.il.comcast.net on [Tue May 05 17:23:26 2015]
11:32:23 <kwickymartkidd> https://play.google.com/store/apps/details?id=com.PinkElephant.BoingGame.android
11:38:03 * hackagebot sdl2-compositor 1.0.0.1 - image compositing with sdl2 - declarative style  https://hackage.haskell.org/package/sdl2-compositor-1.0.0.1 (seppeljordan)
11:46:45 <kaidelong> oh that's right
11:46:59 <kaidelong> what I was talking about wasn't even eta-equivalence
11:47:06 <kaidelong> eta equivalance is that f and 
11:47:13 <kaidelong> \x -> f x should behave the same
11:47:18 <kaidelong> does GHC violate this too?
11:47:37 <kaidelong> I guess it could in the context of seq
11:47:46 <kaidelong> but it'd be hard to observe because of the lack of side effects
11:48:13 <mniip> kaidelong, you can observe it very well
11:48:16 <kaidelong> and .. that was what quchen demonstrated
11:48:39 <kaidelong> he introduced a side effect and strictness and showed that you get the same lack of eta-equivalence out of that as you do in something like ML
11:49:34 <kaidelong> so that particular eta-equivalence violation is real but not very interesting and not really relevant to haskell because you don't generally use things like Debug.Trace
11:49:40 <shachaf> Eta expansion can cause this novel type of performance problem: https://ghc.haskell.org/trac/ghc/ticket/7436
11:52:19 <kaidelong> oh, the perils of being high level
11:53:42 <bitemyapp> is there a CPP macro that can detect if something is being run by GHCi?
11:55:12 <monochrom> I think there is none
11:55:15 <Zemyla> bitemyapp: Okay, what are you actually trying to solve?
11:56:15 <geekosaur> doesn't look like it
11:56:20 <geekosaur> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-phases.html#c-pre-processor
11:56:53 <mmachenry> If I'm using an Integral as my exponent, for example a literal 2, and I have a float as the base, is there any difference between using (**) vs (^), including precision and warnings I'd get from GHC?
11:57:23 <Cale> mmachenry: ** won't work because there are no types which are instances of both Integral and Floating
11:57:37 <adas> when someone uses the word 'combinator' what do they mean?
11:57:57 <Cale> adas: There's a technical sense for that word, and a colloquial sense
11:58:14 <quicksilver> in practice people mean a higher order function, often one with two or more arguments
11:58:20 <bitemyapp> Zemyla: n/m, using a flag we use for production instead.
11:58:27 <mmachenry> Cale: No the base is float and the exponent is integral
11:58:40 <adas> so basically a function that takes functions
11:58:41 <Cale> mmachenry: Right, but look at the type of (**), it's not an option.
11:58:44 <Cale> :t (**)
11:58:45 <lambdabot> Floating a => a -> a -> a
11:58:57 <mmachenry> Cale for example (x :: Float) ** 2    vs    (x :: Float) ^ 2
11:59:14 <Cale> In the first example there, 2 :: Float
11:59:14 <adas> i always thought it meant something esoteric..
11:59:18 <Cale> It's not integral.
11:59:26 <mmachenry> Cale yes I know.
11:59:35 <Cale> In the second example, 2 :: Integer via numeric defaulting.
12:00:05 <Cale> The algorithm used to compute the result is different in each case.
12:00:22 <Zemyla> bitemyapp: I actually am curious, though.
12:00:28 <Cale> (**) uses the natural logarithm and exponential functions.
12:00:30 <mmachenry> But I have a literal in my program. It is two. I don't care if it's a Float or an Int. My (x :: Float) is a float. So I'm wondering if there's an observable difference between using (**2) or (^2)
12:00:35 <adas> the first post on reddit/r/haskell has the title 'megaparsec: Monadic parser combinators ' . so basically its just megaparsec: monadic parser higher order functions?
12:00:45 <Cale> Possibly.
12:00:47 <adas> is it right to put it that way? ^^^
12:01:01 <ski> shachaf : hmm .. that reminds me of how you can make the CPS translation generate less useless redices, first everywhere, then as a second step, handling tail-contexts separately
12:01:13 <indiagreen> adas: parsec has exactly the same description
12:01:19 <Cale> @check \x -> x**2 == (x :: Float)^2
12:01:21 <lambdabot>  +++ OK, passed 100 tests.
12:01:22 <mmachenry> Cale basically I'm using this
12:01:24 <mmachenry> :t (^2) :: (Floating a => a -> a)
12:01:26 <clrnd> megaparsec: haskell code
12:01:26 <lambdabot> Floating a => a -> a
12:01:29 <ski> shachaf : see "Representing control: a study of the CPS transformation" by Olivier Danvy,Andrzej Filinski in 1992 at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/RC.ps.gz> for details
12:01:34 <indiagreen> clrnd++
12:01:36 <Cale> It'll be a bit rare that you get a different result, if it happens.
12:03:27 <tekkkz> Hi! Why is here: http://ix.io/l14 a ":5:15: parse error on input =" Error?
12:03:58 <ski> tekkkz : use `a == 0' and `b == 0' instead of `a = 0' and `b = 0'
12:04:16 <ski> or .. use a separate defining equation for each of those
12:04:27 <ski>   euclid 0 b = b
12:04:30 <ski>   euclid a 0 = a
12:04:34 <monochrom> later, "euclid ( (a-b) b)" is very wrong, too. make it "euclid (a-b) b"
12:04:35 <ski>   euclid a b
12:04:38 <ski>     | ...
12:06:04 <tekkkz> ty
12:06:06 <tekkkz> sure
12:06:12 <tekkkz> was my simple mistake, sorry
12:06:19 <ski> tekkkz : `=' is semantical equality, used for defining things, and for talking about when things are equal. `==' is computable equality, used for comparing whether things are equal or not. may sometimes not give an answer (e.g. hanging). also isn't always even defined
12:06:41 <Cale> Prelude Test.QuickCheck> quickCheckWith (stdArgs { maxSuccess = 1000000 }) (\x -> x**2 == (x :: Float)^2)
12:06:42 <Cale> +++ OK, passed 1000000 tests.
12:06:45 <Cale> mmachenry: ^^
12:06:46 <tekkkz> yaya
12:06:55 <tekkkz> i know ^^ i just forgot, its late already ;)
12:07:04 <Cale> mmachenry: So apparently cases where they differ are quite rare.
12:07:19 <Cale> mmachenry: I'd generally expect (^) to be faster though.
12:07:31 <Cale> But I haven't tested with Criterion or anything.
12:07:36 <ski> tekkkz : no worry :)
12:15:03 <lpaste> tippenein pasted “parse time error ” at http://lpaste.net/141688
12:15:34 <tippenein> yI'm having troubles getting this FromJSON instance to compile
12:15:46 <Cale> Use Data.Text.unpack to turn the Text into a String
12:16:13 <tippenein> OverloadedStrings doesn't handle this case?
12:16:17 <johnw> funny that the constructor is named String, but it's argument is Text
12:16:25 <monochrom> :)
12:16:26 <johnw> no, OverloadedStrings makes "foo" a polymorphic constant
12:16:37 <monochrom> OverloadedStrings is for literals only
12:16:46 <johnw> in this case, Day's String constructor want a Text
12:17:56 <tippenein> no instance of Parser Day for parseTimeOrError
12:18:03 <tippenein> seems like a step in the right direction
12:18:25 <johnw> that doesn't sound right
12:18:32 <johnw> did you change the left-hand side of the =?
12:18:52 <johnw> it should now be: parseJSON (String d) = ... (Text.unpack d)
12:18:56 <tippenein> no, the parseJSON (String d) seems wrong though
12:19:33 <tippenein> It's only Object d if you plan on extracting values into a custom datatype?
12:20:16 <tippenein> parseTimeOrError True defaultTimeLocale "Y-%m-%d" (unpack d)
12:23:19 <shane_> I am getting a space leak when trying foldl' (\x y -> force (x >>= y) ) m $ replicate f ; here f is a function that takes a value and returns a monad. Any ideas why this is happening?
12:23:53 <johnw> shane_: foldl' is pretty horrible to use with >>=, in general
12:23:59 <johnw> try foldr
12:24:16 <johnw> your "leak" here might just be that it's holding on to all resources until the end of the fold
12:24:41 <Gurkenglas> How would I get a Lens' String String such that over (>>= replicate 2) would turn, say, [Hello|World] into [HHeelllloo|World]? (Turning parsers into lenses)
12:24:51 <johnw> space leak seems like the wrong word for what's happening in these cases
12:24:57 <ski> it doesn't "returns a monad". it returns a monadic action
12:24:58 <johnw> "unexpected residency"
12:25:09 <ski> shane_ : if `f' is a function, then `replicate f' would be a type error
12:25:11 <Gurkenglas> *over <thelens> (>>= replicate 2)
12:25:13 <ski> @type replicate
12:25:14 <lambdabot> Int -> a -> [a]
12:25:51 <shane_> ski: I forgot to put a number after replicate
12:26:00 <ski> shane_ : maybe you're looking for `replicateM' or `foldM' ?
12:26:35 <shane_> johnw: I will try foldr...but why should it have to remember the previous resources when they are not being used anymore?
12:27:04 <ReinH> shane_: foldl' only evaluates to WHNF, which is probably not enough to prevent thunks from building up unevaluated.
12:27:33 <ReinH> So it isn't remembering 'previous' resources. It's remembering current resources.
12:28:09 <johnw> shane_: you're making this: ((((a >>= b) >>= c) >>= d) >>= e)
12:28:29 <ReinH> We sometimes call this a "space leak" but really it isn't a leak, as johnw says. It's an unexpected but bounded use of resources.
12:29:04 <johnw> *making that* isn't the same as causing >>= to be evaluated, and thus releasing the resource held by 'a'
12:29:13 <shane_> ReinH: that is why I am also using force...which is being triggered by the strictness of foldl' and evaluates all the way down
12:29:27 <ski> shane_ : hm, `foldr' could possibly also work here
12:29:50 <ReinH> What is force?
12:30:51 <monochrom> killing laziness is not how to reduce all space usage
12:30:59 <johnw> monochrom+++
12:31:14 <johnw> in fact, increasing laziness can reduce space usage too
12:31:15 <shane_> I am using force from deepseq
12:31:20 <monochrom> despite a commonly believed false dichotomy and wish for a silver bullet
12:31:27 <johnw> force doesn't force until it itself is evaluated
12:31:59 <shane_> johnw: would that not be triggered by using strict fold?
12:32:00 <johnw> so you're making a big action (having references to resources) that is awaiting evaluation after the foldl' is done
12:32:58 <johnw> strict foldl' evaluates the accumulator to WHNF.  Hmm.. is that enough here to force all the >>=?  Depends on other factors.  Can you paste some code?
12:33:09 <barelyBurrito> Does there exist a combinator that would allow me to write something similar to this with Aeson: ((o .:? "thing") ">>=" (o .:? "stuff))
12:33:26 <johnw> barelyBurrito: cute name
12:33:38 <shane_> This is from the probability distribution package
12:33:45 <indiagreen> barelyBurrito: I don't understand what do you actually want to do
12:33:45 <indiagreen> can you clarify a bit?
12:33:48 <ski> shane_ : how about `m >>= \z -> foldM (\x y -> y x) z (replicate n f)' ?
12:33:49 <indiagreen> (why is “>>=” in quotes?)
12:34:41 <shane_> Here is the rnf instance instance (NFData a, NFData b) => NFData (T a b) where rnf (Cons x) = x `deepseq` Cons x `seq` ()
12:34:46 <monochrom> is it «liftA2 (,) (o .:? "thing") (o .:? "stuff")» ?
12:34:53 <ReinH> johnw: even if it forces the >>=, it's still walking the spine over and over again
12:34:58 <johnw> ski: isn't that the same as z >>= replicateM_ n f?
12:35:07 <johnw> ReinH: yeah, there's that too
12:35:53 <johnw> ski: oh, you're just applying, not >>=
12:36:00 <cocreature> hey, can I do something like that http://lpaste.net/141691 using typelits? ghc complains that + is not in scope
12:36:28 <johnw> did you import GHC.TypeLits, and turn on TypeOperators?
12:36:29 <shane_> ski: I tried your suggestion, the leak still exists
12:36:36 <cocreature> johnw: yep
12:36:39 <johnw> shane_: did you try foldr?
12:36:51 <shane_> johnw: yes...the leak still exists
12:36:55 <ski> johnw : the idea is `f :: T -> M T'
12:37:00 <cocreature> ah damnit, nvm
12:37:11 <cocreature> I imported GHC.TypeLits () to silence the warning :)
12:37:19 <johnw> shane_: next step for me is usually heap profiling and residency profiling
12:38:37 <brtmr> hello, i am writing an academic thesis about a program which was partially developed in haskell, and i would like to give proper references to some of the popular libraries that i have used (like attoparsec, lens, scotty, postgresql-simple...) however, some of these have do not even have a website except the hackage and github repos - do i quote those when introducing the library?
12:39:28 <monochrom> I think yes, simply say where to find those libraries, e.g., hackage url
12:39:47 <dstromberg>  Hi folks. I've assigned myself at least part of http://www.seas.upenn.edu/~cis194/lectures.html to get a feel for Haskell.  I'm working on homework 02 right now.  Part of the assignment statement includes using http://www.seas.upenn.edu/~cis194/extras/01-intro/Testing.hs for testing. I'm kinda stumped on how to use Testing.hs - I want to just give it a main and get something I can inspect visually, but I don't know
12:39:47 <dstromberg>  how to do that. Am I better off in ghci? I'm coming from Python, where I construct my own tests to output nothing on success and complain a little on failure.
12:40:20 <johnw> shane_: can you give me more code, so I can try it here?
12:40:48 <shane_> johnw: Sure...do you have the probability package installed?
12:40:59 <johnw> shane_: I can install it; is your project on GitHub?
12:41:09 <johnw> I actually rather enjoy tracking down space leaks
12:41:13 <johnw> the more you do it, the easier it gets
12:41:57 <shane_> johnw: no it is not on github...its a very tiny thing that I was trying...basically trying out a sort of a markov process...just a toy example at first, to see if everything works as expected
12:42:08 <johnw>  ok, just pastie the file then
12:42:45 <ski> dstromberg : hm, i suppose you'd run `mapM_ print . runTests $ myListOfTests' or something ..
12:43:07 <shane_> import Control.DeepSeq
12:43:07 <shane_> import Numeric.Probability.Distribution
12:43:07 <shane_> import Control.Monad
12:43:07 <shane_> import Data.List
12:43:07 <shane_> instance Monad Dist where
12:43:08 <shane_>     return x = D [(x,1)]
12:43:10 <shane_>     (D d) >>= f = D [(y,q*p) | (x,p) <- d, (y,q) <- unD (f x)]
12:43:12 <shane_> newtype Dist a = Cons {unD :: [(a, Float)]}
12:43:14 <shane_> instance (NFData a, NFData b) => NFData (T a b) where rnf (Cons x) = x `deepseq` Cons x `seq` ()
12:43:16 <shane_> f 1 = fromFreqs [(1, 0.3), (2, 0.7)] 
12:43:18 <shane_> f 2 = fromFreqs [(1, 0.5), (2, 0.5)]
12:43:20 <bz> oh lawd
12:43:21 <monochrom> we mean on lpaste, shane_ :)
12:43:21 <johnw> shane_: I meant using a pasting service
12:43:28 <ski> @paste
12:43:28 <lambdabot> Haskell pastebin: http://lpaste.net/
12:43:32 <shane_> oh am so sorry
12:43:37 <shane_> how do I do that ? 
12:43:42 <johnw> don't worry, we give everyone a single pass on that ;)
12:43:48 <ski> now you know
12:43:50 <johnw> go to that URL, it should be obvious
12:44:48 <ski> to add things you've forgotten to say, and for updated versions, and so on, use the "Annotate" button. annotations will appear on the same page
12:44:54 <dstromberg> Thanks ski. That gets me past the type error. Now I'm getting this when I try to link: 
12:44:55 <dstromberg> ghc HW02Tests.o Testing.o HW02.o -o HW02Tests
12:44:55 <dstromberg> /tmp/ghc5106_0/ghc5106_0.o: In function `main':
12:44:55 <dstromberg> ghc5106_0.c:(.text+0x38): undefined reference to `ZCMain_main_closure'
12:44:58 <lpaste> shane_ pasted “markov test” at http://lpaste.net/141695
12:45:04 <phaazon> hey, I thought I read a DependentType GHC extension
12:45:33 <phaazon> was I wrong?
12:45:34 <dstromberg> What do I need to change to get it to link?  I thought adding a main would be enough.
12:45:50 <lamefun> does Haskell have something like "deriving (FromJSON by Parsable, ToJSON by Formattable)"?
12:45:59 <ski> shane_ : there's also a "Edit" button, which can be used to override a paste/annotation (you can still view earlier versions, by clicking a link)
12:46:01 <phaazon> lamefun: what would that do?
12:46:06 <johnw> shane_: ok, looking at it now
12:46:17 <shane_> johnw: now after I load that file into ghci, this is the function that gave me the space leak
12:46:19 <shane_> foldl' (\x y -> force (x >>= y)) (f 1) $ replicate 25 f
12:46:25 <ski> dstromberg : if you want to, you could put that into a `main' or `test' definition or something
12:46:40 <ski> (dstromberg : sorry, got side-tracked a bit by shane_ :)
12:46:41 <shane_> ski: thanks for letting me know :) 
12:46:53 <dstromberg> What I have now: 
12:46:54 <dstromberg> main :: IO ()
12:46:54 <dstromberg> main = do
12:46:54 <dstromberg>     -- runTests
12:46:54 <dstromberg>     mapM_ print . runTests $ allTests
12:47:17 <dstromberg> I imagine that may be part of the wrong module, because it's under: main :: IO ()
12:47:18 <dstromberg> main = do
12:47:18 <dstromberg>     -- runTests
12:47:18 <dstromberg>     mapM_ print . runTests $ allTests
12:47:28 <dstromberg> Oops, it's in module Testing
12:47:33 <phaazon> please use lpaste.net, dstromberg 
12:47:46 <dstromberg> I'm not familiar with lpaste.net, but I'll have a look
12:48:42 <lpaste> shane_ revised “markov test”: “No title” at http://lpaste.net/141695
12:48:51 <lamefun> phaazon, "instance ToJSON MyType where toJSON = Aeson.String (format value)"
12:49:16 <shane_> johnw: I just added the function that is producing the leak to the code itself
12:49:19 <phaazon> hm?
12:49:53 <johnw> shane_: I'm getting "unknown data constructor 'D'"
12:50:10 <lpaste> shane_ revised “markov test”: “No title” at http://lpaste.net/141695
12:50:32 <monochrom> is D supposed to be Cons? (or the other way round)
12:51:07 <shane_> johnw: sorry the D was not needed....I forgot to delete that...I was only trying to manually defined the probabilty monad as it was in the original Distributions package
12:51:10 <information_is_g> Hello, is there any simple library to output sounds by writing a wave function?
12:51:22 <johnw> shane_: can I see the version of the source you are using, that loads for you in ghci?
12:51:28 <lamefun> phaazon, use only functions from Formattable to implement ToJSON
12:51:37 <shane_> monochrom: D was supposed to play the role of Cons in my own manual version of the probability distribution
12:51:46 <ski> dstromberg : there's also a `-main-is <name>' option, in case you'd prefer to not call that `main'. see <http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-phases.html#idp12203648>
12:52:16 <shane_> johnw: indeed, it does load into ghci
12:52:22 <johnw> hmm.. not here
12:52:25 <shane_> the newest version does
12:52:27 <johnw> i'm building with 7102
12:52:32 <johnw> ah, ok
12:54:12 <dstromberg> Got it working: thanks folks!
12:54:29 <dstromberg> I had to comment out some stuff to keep from getting a complaint and Prelude.undefined
12:54:38 <lpaste> shane_ revised “markov test”: “No title” at http://lpaste.net/141695
12:55:06 <shane_> Added a type signature that may have been necessary
12:57:35 <johnw> shane_: how would you execute this within a main function?
12:57:42 <Guest78385> i wrote something in haskel
12:57:52 <Guest78385> and it works as intended
12:58:00 <Guest78385> i just have no idea why
12:58:18 <Guest78385> can someone help me here?
12:58:22 <lpaste> shane_ revised “markov test”: “No title” at http://lpaste.net/141695
12:58:31 <indiagreen> Guest78385: paste your code
12:58:34 <indiagreen> @where lpaste
12:58:34 <lambdabot> http://lpaste.net/
12:58:41 <shane_> johnw: I was using ghci
12:58:56 <Guest78385> http://lpaste.net/141700
12:58:56 <shane_> but I added the main function in the revision
12:59:20 <Guest78385> how does it know that it should stop at b?
13:00:26 <indiagreen> Guest78385: actually it doesn't
13:00:34 <indiagreen> Guest78385: how are you running it?
13:00:53 <monochrom> > let enumFromTo1 a b = [a] ++ [last(enumFromTo1 a b) + 1] in enumFromTo1 2 4
13:00:56 <lambdabot>  [2,*Exception: stack overflow
13:00:58 <Guest78385> oh yeah you're right, it doesnt stop
13:01:21 <Guest78385> i was running enumFromTo instead of enumFromTo1, my bad~
13:01:31 <Guest78385> sorry for the stupid question
13:02:26 <shane_> johnw: I am very sorry, I will have to leave now, but in case you figure it out and I find you here tomorrow, I would love to hear how to plug it. I really want to get used to preventing space leaks!
13:03:24 <shane_> johnw: thank you for your help.
13:03:51 <ski> dstromberg : <http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/defer-type-errors.html> might perhaps also be interesting
13:06:37 <mmachenry> Is there a way I can tell when OverlappingInstances was deprecated in version number that is understood by #if __GLASGOW_HASKELL__ < ??
13:07:17 <mmachenry> I need to keep the language pragma in for GHC 7.6.3 support but GHC 7.10.3 is giving me warnings that I'd like to clean up.
13:07:29 <monochrom> I think yes. look into the GHC user's guide.
13:08:57 <monochrom> the section name is "Options affecting the C pre-processor"
13:10:07 <monochrom> I don't give a URL because the GHC user's guide is already on your hard disk along with your GHC. you should develop the habit of using your own hard disk.
13:12:12 <mmachenry> Why should I use my own hard disk?
13:12:20 <monochrom> ok, I see, it may not be easy to perform comparisons
13:12:48 <monochrom> but starting with 7.10, they have a "MIN_VERSION_GLASGOW_HASKELL(x,y,z,z')" to do comparisons for you.
13:13:25 <mmachenry> I don't see how any of this answers my question.
13:13:59 <monochrom> a subtle way to use it is: if you are just asking ">= 7.10 or not?", then "#ifdef "MIN_VERSION_GLASGOW_HASKELL" will do :)
13:14:25 <mmachenry> Yes but my question was not how to use these features. I know how to use these features.
13:14:36 <mmachenry> I need to know which version number to put in there.
13:14:46 <monochrom> ok, I don't know which version begins to deprecate OverlappingInstances
13:15:00 <mmachenry> Yes, that's my question.
13:15:33 <mmachenry> It's been annoying to Google for. I guess lots of discussion on it. Not real changelists
13:17:53 <monochrom> I have both 7.8.3 and 7.10.2. 7.8.3 says nothing. 7.10.2 says warning, deprecated. so I'm going to just say it begins with 7.10.*
13:18:28 <monochrom> (it's simply {-# LANGUAGE OverlappingInstance #-} module G where )
13:19:31 <mmachenry> Yeah looks like it.
13:20:48 <zipper> Hey from the signatures it seems that fmap is equal to (<$>)
13:21:09 <zipper> Why do we have this repition?
13:21:12 <voidzero> yep
13:21:21 <johnw> it's the operator form of fmap
13:21:42 <zipper> johnw: You mean infix.
13:22:01 <johnw> it makes foo <$> x <*> y <*> z rather conveniently reminiscent of foo x y z
13:22:02 <zipper> *?
13:22:20 <johnw> <*> is from Applicative
13:22:23 <shachaf> If only there was a right-associative version that was that convenient.
13:24:04 <mniip> you know what else is somewhat reminiscent of foo x y z
13:24:13 <zipper> mniip: Tell me
13:24:13 <mniip> :t liftA3
13:24:15 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
13:25:43 <lemevi> hi
13:25:48 <voidzero> hi
13:26:00 <tomberek> Why is multiplate not used more often or incorporated into the Generics ecosystems a bit more? Most datatypes could have automatic boilerplate via TH, and it can accommodate many more via manual instances as well. 
13:27:24 <tomberek> Uniplate and the Control.Lens.Plated do subsume a portion of multiplate, but (correct me if I'm wrong) multiplate can be used with GADTs and more complicated recursion than Compos,Uniplate/Biplate etc.
13:29:25 <zipper> in let f = (+) <$> (*2) <*> (+10). How are (*2) and (+10) in contexts? or of type f(a->b)?
13:29:57 <bitemyapp> zipper: (->) e
13:30:04 <johnw> f is like saying: (\x -> ((x * 2) + (x + 10)))
13:30:52 <zipper> bitemyapp: Is this in the haskell book?
13:31:16 <bitemyapp> zipper: it will be on Oct 15th
13:31:22 <zipper> I glossed over some chapters like functors up to monads thinking I knew it all.
13:31:33 <bitemyapp> zipper: this is Reader, Reader chapter is next release.
13:31:34 <zipper> Now I know that I don't
13:31:42 <bitemyapp> zipper: Reader confuzzles people.
13:31:56 <mniip> bitemyapp, wait wiat what will be on oct 15th
13:32:07 <zipper> mniip: Hi mixtape
13:32:10 <zipper> :)
13:32:12 <bitemyapp> mniip: we release new chapters on the book the 15th of every month
13:32:26 <zipper> *His
13:32:28 <bitemyapp> of the book*
13:32:33 <mniip> ah
13:32:34 <mniip> I see
13:32:40 <zipper> Oh well new keyboard is bad for jokes.
13:32:42 <bitemyapp> http://haskellbook.com/progress.html
13:34:28 <johnw> @tell shane_ The docs for probability tell us exactly what the problem is: "If you need efficiency, you should remove redundant elements by norm. norm converts to Map and back internally and you can hope that the compiler fuses the lists with the intermediate Map structure."
13:34:28 <lambdabot> Consider it noted.
13:34:52 <johnw> @tell shane_ So the foldl' is fine, just use: foldl' (\x y -> norm (x >>= y)) ...
13:34:52 <lambdabot> Consider it noted.
13:44:38 <jophish_> I have a function which at the end of the day hinges on a call to acos with a user supplied number, for example my function is foo x = 1 + acos x. What would the most idiomatic type signature be for this. Part of me wants it to be (Double -> Maybe Double) with Nothing when x is not in [-1..1]
13:44:52 <jophish_> Another part of me would be very happy with returning NaN for bad inputs
13:45:12 <hpc> :t acos
13:45:13 <lambdabot> Floating a => a -> a
13:45:31 <jophish_> > acos 2
13:45:33 <lambdabot>  NaN
13:45:33 <hpc> > acos pi
13:45:35 <lambdabot>  NaN
13:45:51 <voidzero> > pi
13:45:53 <hpc> yeah, just NaN
13:45:53 <lambdabot>  3.141592653589793
13:46:00 <hpc> > acos pi :: CReal
13:46:01 <lambdabot>  *Exception: Ratio has zero denominator
13:46:16 <hpc> or spoon
13:46:45 <zipper> In the reader functor, applicative, monad the context/container mental image falls apart.
13:46:50 <jophish_> spoon?
13:46:54 <zipper> Is this just me?
13:47:06 <zipper> :t spoon
13:47:08 <lambdabot> Not in scope: ‘spoon’
13:47:19 <hpc> http://hackage.haskell.org/package/spoon
13:47:20 <geekosaur> @hackage spoon
13:47:20 <lambdabot> http://hackage.haskell.org/package/spoon
13:47:48 <geekosaur> zipper, that would be why we don't like the container view
13:47:53 <hpc> zipper: it's not, the container metaphor is not perfect
13:48:06 <hpc> and neither is the computation metaphor, though that one is a bit closer
13:48:14 <zipper> Because now I'm a little screwed.
13:48:43 <zipper> What will I relate this to?
13:50:47 <exio4> maybe it's time to start thinking a bit more abstractly?
13:50:48 <jophish_> I have the impression that if I return a Maybe type, every call to this function will be wrapped in fromJust
13:51:33 <hpc> well, make your caller pay a syntactic cost for being a terrible person then ;)
13:51:38 <exio4> it's a different thing, if it was a container we'd call it a container instead of a monad/functor/applicative/whatever
13:51:51 <jophish_> but then again, I've already got functions returning Maybe in this package, would it be weird to mix and match returning NaN and Nothing?
13:52:04 <hpc> also Maybe is a monad, so it's not like it's hard to use
13:52:10 <jophish_> the contexts are a little different, and I have a clear idea which function should return which
13:54:27 <monochrom> zipper: reader doesn't break the container model yet. "f :: String -> Bool" is an "array" with String indexes and Bool cells. this is still a container, written functionally. to really break the container model, you have to do something like writer or state
13:54:44 <monochrom> or even free monads
13:54:45 <shapr> Anyone in Atlanta? I'm starting a Haskell User's Group in ATL
13:56:34 <monochrom> > acos 2
13:56:36 <lambdabot>  NaN
13:56:55 <voidzero> i've read 'free monad' a lot but have no idea what it is
13:57:03 <shapr> I should probably rejoin the haskell-cafe mailing list for announcing a new user group
13:57:45 <c_wraith> voidzero: it's just a data type that happens to have a very flexible Monad instance 
13:58:20 <monochrom> jophish_: consistency is valuable. if your other stuff is already using Maybe, then stick to Maybe. however, Prelude's acos will give you NaN, so you have to add your own conversion. "isNaN" exists.
13:58:24 <geekosaur> voidzero, a free <thing> is a data structure that is isomorphic to <thing>. so list is the free Monoid because [] and (:) are directly isomorphic to mempty and mappend. a free monad is any data structure isomorphic to return and (>>=)
13:58:36 <jophish_> hpc: I think you're probably right. I'll write it with Maybe for now,
13:58:53 <zipper> monochrom: Shouldn't reader be a function strictly?
13:58:54 <geekosaur> basically you can reproduce the operations of <thing> as data
13:59:02 <c_wraith> geekosaur: (++), not (:) 
13:59:06 <jophish_> monochrom: that shouldn't be a problem, I have a pretty easy way of knowing when it's going to fail way before getting to acos :)
13:59:08 <geekosaur> right, sorry
13:59:10 <monochrom> zipper, a function is an array, broadly.
13:59:49 <zipper> monochrom: In my mind arrays are something like lists but whose size you must know beforehand.
13:59:50 <geekosaur> (although that makes the apparent correspondence look weaker...)
14:00:10 <geekosaur> isn't the usual formalization of a function a map?\
14:00:23 <geekosaur> although you can represent that as an array indexed by inputs
14:00:47 <geekosaur> but this is not a programming language "array", it's a conceptual array which might well be infinite
14:01:01 <monochrom> ok, but I work at the API level. a function just misses out a "size" accessor. but the rest of the immutable array API is supported.
14:01:05 <geekosaur> (and the correspondence there breaks down for e.g. Double)
14:01:16 <c_wraith> geekosaur:  That's because [] isn't a free monoid when infinite codata gets involved. :) 
14:01:35 <geekosaur> sure, these things break down easily :)
14:01:47 <exio4> we need a better programming language 
14:01:51 <voidzero> So.. does the word 'free' indicate that any <thing> simply adheres to the laws of the type?
14:01:54 <monochrom> or yeah, if you really hate array, then change all my sentences with s/array/dictionary/
14:02:06 <voidzero> and its use case is not relevant?
14:02:12 <mniip> exio4, you mean untyped lambda calculus?
14:02:33 <geekosaur> voidzero, you could think of it as the maximally usable data structure
14:02:34 <exio4> mniip: we haven't got a perfect type system.. yet!
14:02:42 <voidzero> right ok yes
14:02:44 <mniip> no types best types
14:02:52 <geekosaur> because it doesn't impose "extra" things on top
14:02:52 <monochrom> oh, Double admits finitely many values. Double -> X is an array alright :)
14:03:19 <mniip> exio4, can't wait until the typechecker will be programmable in haskell
14:03:22 <geekosaur> werll, yes, bad example. the reals would break down, but I dont think the functions-as-maps formalism intended to deal with Cantor :)
14:03:28 <voidzero> ok that does clear it up a bit, thanks
14:03:34 <mniip> import Prelude hiding (HindleyMilner)
14:04:36 <geekosaur> so the idea behind the free monad is we can convert a monadic sequence of actions into data, manipulate or pass around the data, and later "interpret" the monadic actions back ou
14:04:38 <monochrom> Real -> X is going to be wacky. Scott would sound confusing when he said "continuous functions" :)
14:04:39 <geekosaur> out
14:05:44 <geekosaur> or move them from one monad to another --- the earliest free monad ("prompt" package on hackage) was about letting you build an interface without having to commit to IO vs. some other monad
14:06:09 <c_wraith> I've been playing with Cofree a bunch lately. Its instances aren't as convenient, but the type can do so much. 
14:06:14 <geekosaur> so you could "mock" a UI more easily
14:07:00 <voidzero> oh cool
14:07:44 <voidzero> https://github.com/mstksg/prompt
14:08:09 * hackagebot ContextAlgebra 0.2.0.0 - Context Algebra  https://hackage.haskell.org/package/ContextAlgebra-0.2.0.0 (jhahn)
14:08:11 * hackagebot NearContextAlgebra 0.1.0.1 - Context Algebra of near  https://hackage.haskell.org/package/NearContextAlgebra-0.1.0.1 (jhahn)
14:08:43 <voidzero> this seems like something worth playing with :)
14:08:48 <voidzero> prompt, I mean
14:09:07 <monochrom> our popular examples of free monads are EDSLs written as ADTs and making them monadic EDSLs.
14:09:45 <monochrom> (the "and" there is conjunctive, not causal)
14:27:53 <Denommus> I wish FRP's denotational semantics described the lifetimes
14:27:58 <tulcod> are there any production code usages of fix or the Y combinator or other non-type fixpoint operators?
14:28:28 <Denommus> tulcod: FRP code uses mfix somewhat frequently
14:28:45 <marchelzo> Could someone give me a hint for this? It's an exercise fmor Gabriel Gonzalez's comonad post. http://sprunge.us/VIWg?
14:28:50 <Denommus> tulcod: because sometimes you need a behavior or an event to depend on itself
14:28:52 <tulcod> Denommus: hm, for some reason it feels like that doesn't count
14:28:53 <marchelzo> s/fmor/from/
14:29:04 <marchelzo> It seems like it isn't even possible.
14:29:05 <Denommus> tulcod: "that" what? FRP or mfix?
14:29:13 <tulcod> Denommus: mfix
14:29:23 <Denommus> tulcod: mfix is just... fix. But monadic
14:29:28 <tulcod> IO mfix, anyway
14:29:46 <marchelzo> I mean I can satisfy the type signature, but not in the way I think is intended.
14:29:52 <tulcod> cause that's more about getting partial data here to feed into there, without having to break up implementation details everywhere
14:30:31 <tulcod> Denommus: i mean, the mfix is translated to non-fix code at compile time
14:30:35 <Denommus> tulcod: well, if mfix doesn't count you probably won't find a lot of fix in use out there
14:30:55 <hiptobecubic> tulcod, I used fix once
14:31:02 <hiptobecubic> feels good, man
14:31:06 <Denommus> tulcod: because you can almost always express fix as a simple recursive function
14:31:11 <hiptobecubic> granted it was a pretty obvious use of fix
14:31:16 <hiptobecubic> if there is ever such a thing
14:31:24 <tulcod> hiptobecubic: you have my attention
14:31:31 <tulcod> Denommus: right, when can't you?
14:32:03 <Denommus> tulcod: when you're tired and you can't think how to express it
14:32:08 <hiptobecubic> tulcod, http://john.bitsurge.net/blag/posts/2015-05-25-brnfckr-opt.html
14:33:42 <orbitz> Hello, I'm not using Haskell but think this is probably an appropriate place to ask this question: I have an applicative but I actually want an API that looks like run (values) fun.  For example: run (Just 1 <*> Just 2) (+).  Is there somethign I can read to understand how to accomplish this?  And I am using Ocaml but I think the rough ideas should apply.  Thanks.
14:33:49 <hiptobecubic> tulcod, I had a list of terms that I wanted to repeatedly apply a set of substitution rules to and I used fix to do so
14:34:14 <tulcod> hiptobecubic: yep, seeing it. that might be acceptable.
14:34:43 <tulcod> though it somewhat fits in Denommus' category in that you *could* decide pre-emptively whether you're done or not
14:35:15 <marchelzo> Just 1 <*> Just 2 doesn't typecheck
14:35:24 <orbitz> I know
14:35:34 <orbitz> Which is why I'm asking how to accomplish this rough idea.
14:35:58 <hiptobecubic> tulcod, you don't know that you're done until you've run it
14:36:10 <hiptobecubic> tulcod, then you compare this result to the last one.
14:36:35 <marchelzo> orbitz: I don't think you can, unless you specialize it for a particular number of arguments
14:36:36 <monochrom> orbitz: "run (Just 1) negate" makes sense, but it is already "fmap negate (Just 1)" and "negate <$> Just 1"
14:36:37 <hiptobecubic> tulcod, so you can't know ahead of time if the next optimization round will be a nop or not.
14:36:41 <tulcod> hiptobecubic: well  that's your technique, yes. but in this particular case, you could also just count the number of repeated ValIncr's and run compress that many times
14:37:18 <marchelzo> run (a, b) f = liftA2 f a b
14:37:43 <hiptobecubic> tulcod, for this particular case, sure. But when you combine with many other things, such as entire loops being optimized away etc, it becomes very unclear how many passes it will take
14:37:47 <tulcod> orbitz: if you want it to deal with an arbitrary number of arguments, you're going to need Typeable or something like that
14:38:01 <orbitz> is there somethign I could do like: run (placeholder <*> Just 1 <*> Just 2) (+) that would make sense?
14:38:04 <hiptobecubic> tulcod, [++++-------] -> [-] -> SetVal 0
14:38:12 <tulcod> hiptobecubic: yeah, i agree. it's definitely a reasonable use-case in the sense of programming-effectiveness.
14:38:34 <mniip> hiptobecubic, false
14:38:37 <hiptobecubic> well not quite in that case
14:38:48 <mniip> okay not false
14:38:53 <mniip> but a bit misleading
14:38:54 <quchen> orbitz: (\f -> pure f <*> Just 1 <*> Just 2) (+)?
14:38:57 <arkeet> not false because 3 and 256 are coprime.
14:38:58 <hiptobecubic> mniip, right... i pressed - too many times :)
14:38:59 <mniip> [+---] is not the same as [-]
14:39:00 <hiptobecubic> yes
14:39:25 <orbitz> quchen: Thta's a bit heaveir than the API i'm looking for.
14:39:39 <hiptobecubic> [++++-----] is what i intended :)
14:40:17 <monochrom> orbitz: is there a reason you don't just do "(+) <$> Just 1 <*> Just 2"?
14:40:44 <hiptobecubic> liftA2 (+) is pretty light I'd say
14:41:02 <orbitz> monochrom: readability, the function I'm applying could be quite long and it reads better to do run (...) (\x y z -> ..........)
14:41:16 <orbitz> this is purely an aesthtics question, I'm trying to get a pretty API
14:41:20 <mniip> hiptobecubic, that's just the inversion axiom of + and -
14:41:26 <mniip> +- = -+ = id
14:41:30 <tulcod> orbitz: what about formatting it differently?
14:41:48 <tulcod> myFun\n    arg1\n    arg2\n    arg3
14:42:02 <marchelzo> Any hints for my question above?
14:42:08 <hiptobecubic> mniip, yes. and so the loop becomes [-], which maps all inputs to 0
14:42:59 <tulcod> marchelzo: it is supposed to alternate?
14:43:03 <orbitz> tulcod: I think run\nargs_to_be_applied\nfunction reads much easier.
14:43:09 <tulcod> marchelzo: err, scratch that
14:43:16 <monochrom> orbitz: ok, don't define run, define "use a b f = f <$> a <*> b"
14:43:49 <tulcod> orbitz: pretty sure most people would disagree that introducing new syntax for function evaluation will improve readability :)
14:45:19 <orbitz> In this case I think it would make sense.  I'm trying to implemtn a with_resource function, so: run (open_file fname <*> open_socket hostport) (\x f s -> ...)
14:45:34 <marchelzo> Disregard my question. He shows the solution right below >.<
14:47:44 <marchelzo> His definition doesn't seem to satisfy his description though :/
14:48:47 <orbitz> marchelzo: Sorry, since I don't know the solution I'm no tlikely to use the correct functions to show what I'm after.  
14:48:56 <tulcod> marchelzo: just read up, sorry for the delay
14:49:17 <tulcod> marchelzo: (had to understand the actual exercise, which i couldn't derive from just the types involved)
14:49:30 <tulcod> marchelzo: so extend needs to, eventually, output some Iterator a, right?
14:49:31 <marchelzo> that's understandable
14:49:39 <marchelzo> yes. I just read his solution.
14:49:49 <marchelzo> :/
14:49:56 <tulcod> marchelzo: so is it clear or not?
14:50:03 <orbitz> monochrom, tulcod thanks for the help.  Time for bed for me though.
14:50:04 <tulcod> cause i do think it satisfies his description
14:51:48 <marchelzo> I was thinking like, for (Iterator Int), you could have an (Iterator Int -> Int) that didn't take the kth value, but did something more complicated, like taking the first value greater than 12. Then I realized that since it's (Iterator a -> a), you can't do anything like that without doing weird unsafe stuff.
14:51:55 <marchelzo> So I guess it is correct.
14:52:19 <tulcod> marchelzo: yeah, the "retrieve" doesn't tell you which value you should get, but it tells you the actual value
14:52:31 <marchelzo> for any (f :: Iterator a -> a), there must exist some k such that f = (next . next . ... k times).
14:52:36 <tulcod> so the fact that it's a shift is implicit in the "extend" (which is poorly named), not the "retrieve"
14:52:45 <marchelzo> or it could be infinite
14:54:21 <marchelzo> So (Iterator a -> a) and Integer are isomorphic I think.
14:55:15 <nolraiU> marchelzo: What about negatives?
14:56:15 <marchelzo> Is there an arbitrary precision unsigned type? :)
14:56:31 <hpc> Wordeger
14:56:58 <dolio> Natural
14:58:11 * hackagebot mtl-unleashed 0.3.2 - MTL classes without the functional dependency  https://hackage.haskell.org/package/mtl-unleashed-0.3.2 (DavidFox)
14:58:29 <tulcod> dolio: that's a terrible package though. it calls NaN a number.
14:58:35 <tulcod> a natural number, at that
14:58:50 <dolio> It's not a package. It's a type.
14:58:54 <hpc> that's what it stands for
14:58:58 <hpc> Number au Naturale
14:59:04 <monochrom> heh
14:59:09 <tulcod> dolio: the package that defines the Natural data type is a terrible package though*
14:59:12 * geekosaur *eyeroll*
14:59:15 <dolio> base?
14:59:27 <tulcod> dolio: i was looking at "naturals"
15:00:33 <tulcod> dolio: ah, yes, base :)
15:00:37 <tulcod> that does look better, apologies
15:01:28 <tulcod> (in Numeric.Natural for you lurkers out there)
15:02:24 <cmccann> oh man, one of my lambdabot quotes is totally out of date now, I just realized D:
15:02:27 <cmccann> @quote cmccann demote
15:02:27 <lambdabot> cmccann says: personally I'm just waiting for an extension that demotes types to the value level, so that we can finally have natural numbers.
15:03:17 <tulcod> cmccann: existential types?
15:03:24 <tulcod> with Typeable
15:09:40 <NoobsEnslaver> Hi everyone!
15:18:23 * NoobsEnslaver
15:19:06 <lamefun> Should I switch to Megaparsec?
15:19:28 <indiagreen> lamefun: I'm in the middle of writing a long post about it, as it happens
15:20:14 <lamefun> Have you written Megaparsec?
15:20:25 <indiagreen> I contributed a bit 
15:20:41 <tulcod> lamefun: one the one hand, if you have a piece of parsec code lying around that works just fine and doesn't need changing... i'd say, if it ain't broken, don't fix it
15:20:41 <indiagreen> mostly in form of nagging the author about stuff I wanted to have
15:21:07 <tulcod> lamefun: on the other hand, i'm a big supporter of the megaparsec work, and think it fixes some long-standing issues with parsec
15:21:59 <indiagreen> lamefun: short answer: switching won't bring you much benefit (error messages are better and you can use various monad transformers more easily, but that's not something really worth switching over), but on the other hand using an effectively unmaintained library isn't that wise
15:22:34 <tulcod> lamefun: for new code, "probably yes"
15:23:49 <tulcod> indiagreen: (i think you had some very interesting contributions though - don't underestimate the value of some wise input)
15:24:13 <indiagreen> lamefun: for new code, almost certainly yes unless you need the Haskell lexer out of the box (because Parsec for whatever reason provides it)
15:24:27 <tulcod> indiagreen: not quite, i think
15:24:33 <indiagreen> hm?
15:24:40 <tulcod> the parsec TokenParser is not quite haskell syntax
15:24:42 <tulcod> iirc
15:25:20 <ReinH> If you want better parse errors, try trifecta/parsers
15:25:22 <indiagreen> close enough for sufficiently lazy people to just use it for their mini-languages, I guess
15:26:20 <indiagreen> sure, trifecta's errors are still better
15:26:42 <indiagreen> ain't trying to compete with trifecta
15:27:47 <ReinH> indiagreen: neither am I as I hadn't heard of it.
15:28:22 <zachk1> trifecta's still around?
15:29:56 <nolraiU> So is there like a list of differences with Parsec somewhere?
15:29:58 <indiagreen> zachk1: yeah, tho the last meaningful commit was like... a year ago?
15:30:09 <indiagreen> after that it's all maintenance
15:30:43 <indiagreen> nolraiU: http://hackage.haskell.org/package/megaparsec-4.0.0/changelog
15:30:45 <tulcod> nolraiU: "soon"
15:31:17 <tulcod> nolraiU: i mean, the main author is planning to write a "translation guide"
15:33:30 * cmccann has been considering reworking and releasing a simple parsing library and suddenly second-guesses the life choices that brought him to this point.
15:34:47 <indiagreen> cmccann: why?
15:35:01 <cmccann> indiagreen: why worry about my life or why release a parsing library?
15:35:07 <indiagreen> why second-guess
15:35:24 <tulcod> cmccann: both actually
15:36:07 <cmccann> the former because Haskell already has more parsing libraries than anyone would ever want. the latter is a very good question indeed.
15:36:18 <monochrom> yes, please second-guess why you second-guess. :)
15:36:44 <cmccann> monochrom: does that become triple-guessing or quadruple-guessing?
15:36:59 <nolraiU> Tri...
15:37:03 <nolraiU> hhm.
15:37:09 <hiptobecubic> cmccann, i'd think it's multiplicative
15:37:24 <tulcod> i guess at this point it'd be called "making shit up"
15:37:29 <monochrom> hmm, it doesn't matter because you can always convert between the lg scale and the 2^ scale :)
15:37:43 <cmccann> tulcod: the serious answer is because it's a special purpose thingie that doesn't fit any parsing library I'm aware of, btw.
15:37:55 <tulcod> cmccann: sounds interesting!
15:38:01 <tulcod> what is the special purpose?
15:38:08 <monochrom> if it is special-purpose and it is useful to you, it is worth the effort
15:38:31 <cmccann> tulcod: here's a dump of the code I wrote for a one-off project: https://github.com/isomorphism/labelled-hexdump-parser
15:38:39 <monochrom> but I'm lazy and I usually try first shoehorning a general-purpose library
15:38:53 <cmccann> I'm debating beating it into the shape of something reusable.
15:39:06 <cmccann> tulcod: (just look at the README, the code is a disaster)
15:40:29 <monochrom> in other words, if I need a hammer, but I haven't bought a hammer, but I already have a paperweight lying around, I will use the paperweight to hammer things
15:40:53 <hiptobecubic> cmccann, nice. I could have used this as well for a simple project I was working on
15:40:57 <monochrom> "if all I have is a paperweight, everything looks like a wack-the-mole game"
15:41:05 <cmccann> monochrom: I'm more likely to find a stick and duct tape the paperweight to that and call it a hammer
15:41:27 <tulcod> monochrom: your metaphorical default use for a paperweight is wack-the-mole?
15:41:42 <cmccann> maybe they're paper moles.
15:41:53 <zipper> The reader monad and reader applicative are the same thing?
15:42:02 <cmccann> hiptobecubic: interesting, what was the project?
15:42:10 <nolraiU> The paperweights I know would make good hammers.
15:42:14 <monochrom> tulcod: no, I'm making genetic mutations to the ".... hammer ... nail ..." saying
15:42:23 <hiptobecubic> cmccann, I was trying to figure out how to interpret and use the output from a Griffin Powermate knob
15:42:39 <nolraiU> zipper: Usually if theres an "x" monad and an "x" applicative they are the same thing.
15:42:39 <tulcod> monochrom: yeah, but in the hammer...nail thing, the nail is the common object under the hammer's subject
15:42:51 <cmccann> monochrom: something I've always wondered, what does everything look like to someone who only has MC Hammer?
15:43:04 <tulcod> monochrom: iow, when you're using a hammer, you're probably using it for a nail. you're kinda turning that upside down.
15:43:13 <cmccann> actually nevermind, this is too off-topic.
15:43:21 <zipper> nolraiU: I didn't know that
15:43:59 <nolraiU> Well Applicative is a super-class* of Monad.
15:44:16 <nolraiU> (* Is that the right term when talking about type classes?)
15:44:19 <cmccann> hiptobecubic: ...what kind of knob has output complicated enough that it requires parsing? D:
15:44:57 <tulcod> nolraiU: (* yes)
15:45:33 <monochrom> cmccann: http://www.amazon.ca/Griffin-Technology-NA16029-Multimedia-Controller/dp/B003VWU2WA
15:45:41 <monochrom> it is a USB input device
15:45:47 <dfeuer> How do you prove that  traverse f . fmap g = traverse (f . g) ?
15:46:03 <ReinH> dfeuer: ah ha!
15:46:04 <hiptobecubic> cmccann, it's not very complicated, but it would have been useful to see that output while figuring out how the protocol
15:46:08 <indiagreen> cmccann: more off-topic: can I see your insightful Reddit comments?
15:46:10 <dfeuer> I've been banging my head against the Traversable laws, and finding them ... tricky.
15:46:14 <hiptobecubic> how the protocol works*
15:46:33 <dfeuer> Yes, ReinH, you recognize what reminded me of this question :P
15:46:40 <ReinH> dfeuer: :)
15:47:25 <cmccann> indiagreen: that was sarcasm, in case it wasn't obvious. this is the comment I was talking about: https://www.reddit.com/r/haskell/comments/3mb8lb/monad_of_no_return_proposal_mrp/cve8w92
15:47:41 <ReinH> dfeuer: something something naturality and the free theorem for fmap?
15:48:10 <cmccann> though apparently ReinH shares my current depth of insight.
15:48:27 <ReinH> cmccann: :p
15:48:34 <indiagreen> cmccann: that was very sneaky of you to throw that “a” out of your nick, just so that you know
15:48:40 <ReinH> cmccann: In our defense, it is friday.
15:49:34 <ReinH> dfeuer: I forgot the QED :(
15:50:06 <monochrom> "QED" is too cliche anyway
15:50:17 <cmccann> indiagreen: other people with the same first initial and last name as me keep making accounts on websites, it's very inconvenient
15:50:32 <monochrom> but "&c" is stylish. always remember to add it.
15:50:57 <cmccann> yes, I like &c.
15:51:01 <ReinH> Sorry, I mean "something something naturality and the free theorem for fmap ∎"
15:51:03 <Cale> Use &c in place of QED, to keep people wondering for a few more seconds.
15:51:06 <cmccann> ReinH: excellent
15:51:19 <cmccann> Cale: I used both!!
15:51:44 <hpc> i always end my proofs with "and you know, whatever"
15:52:25 <monochrom> I use indentation
15:52:39 <Clint> zero-width whitespace
15:52:41 <cmccann> hpc: my favorite was someone who added a footnote to the QED saying it was Latin for "so there"
15:53:01 <ReinH> ∎-∎ is, of course, latin for "deal with it"
15:53:38 <Cale> The joke almost-proofs which the notation of http://incredible.nomeata.de/ allows for are amusing. http://cale.yi.org/share/proof-okay-so-far.svg --> http://cale.yi.org/share/proof-awww-come-on.svg
15:53:55 <Denommus> monadic parser combinators just clicked for me
15:53:57 <Denommus> whoa
15:54:09 <Denommus> I don't know how they are internally implemented, but I understand how to use them
15:54:19 <cmccann> hiptobecubic: at any rate, more data points on how people might use such a library are helpful in encouraging me to turn it into one
15:56:06 <cmccann> hiptobecubic: in particular the existing code generally assumes that all input is available and in memory, and it doesn't sound like that would have always been the case for your project...?
15:56:46 <hiptobecubic> cmccann, it depends. When I was working on deciphering the protocol, I just captured a bunch of interactions
15:56:58 <tulcod> dear mobile data, i love you. please let's just stay friends. why does this "provider" friend of yours always have to come in the way? kind regards, your love, your one and only.
15:58:08 * yoho strokes his unlimited mobile data
15:58:31 <cmccann> hiptobecubic: what sort of high-level structure did it have?
16:00:04 <hiptobecubic> it turned out to be quite simple, a stream of structs representing events, which I found out by looking at it in a hexeditor and adjust the column width until it locked into place visually
16:00:25 <hiptobecubic> but then i had to write the parser and label fields so that it would be obvious when they were changing and where the boundaries were, etc
16:00:50 <cmccann> hiptobecubic: the second file in this gist shows a sample of me using that code: https://gist.github.com/isomorphism/6def39f8d99d7ab2e005
16:01:27 <cmccann> does that look like something that would have fit what you were doing?
16:01:47 <hiptobecubic> yes, ver much like this although i'd have had only one parser i think and am more interested in using the pretty output to figure out what that parser was supposed to be
16:02:16 <dfeuer> ReinH, I don't see where to get the applicative transformation for naturality. I'd want to use it with  traverse f . runIdentity, I guess, but I don't know any particular reason that should be applicative transformation.
16:02:58 <dfeuer> Maybe the composition law comes in somehow.
16:03:05 <cmccann> hiptobecubic: ok, I think I get the general idea
16:03:18 <cmccann> I'll keep that in mind if/when I get back to working on this code
16:03:53 <dfeuer> No ... composition ain't it....
16:04:23 <ReinH> cmccann: what library is this?
16:04:43 <cmccann> ReinH: one that doesn't exist
16:04:47 <ReinH> ah :D
16:04:58 <ReinH> shame
16:05:10 <cmccann> ReinH: I've been talking about turning this code from a one-off project into something more reusable: https://github.com/isomorphism/labelled-hexdump-parser
16:06:02 <cmccann> I'll probably do it eventually so I've been poking people to get a sense of what use cases might exist
16:06:12 <hiptobecubic> cmccann, :)  It's not a very fancy use case. But i ended up essentially implementing it myself in python at the time. It was much easier to figure out when the I could see that I was turning the knob and changing the timestamp field rather than the data field.
16:06:27 <hiptobecubic> when the -> when
16:12:11 <dfeuer> ReinH, Cale, I remain stuck. I don't see a way to apply any of the Traversable laws to traverse f . fmap g without first applying  fmap f = runIdentity . traverse (Identity . f). Applying it gets me traverse f . fmap g = traverse f . runIdentity . traverse (Identity . g), which looks like a dead end.
16:14:04 <dfeuer> Naturality is all about applicative transformations, and none of those seem to be anywhere in sight. Identity looks utterly dull. Composition seems to be about traversing with traverse.
16:15:33 <glguy> dfeuer: Can you use something like:  fmap f = runIdentity . traverse (Identity . f)
16:15:36 <Cale> dfeuer: What are you trying to check?
16:15:43 <glguy> to think of it as composed traverses?
16:16:11 <glguy> Oh, nevermind, I missed a big chunk of your message
16:18:32 <TheGoldenAngel>       My Official GIRL Channel : https://www.youtube.com/channel/UCpW7RV72BJzs7OTSgBEmZCQ/videos
16:18:39 --- mode: ChanServ set +o glguy
16:18:39 --- mode: glguy set +b *!*@87-205-173-234.adsl.inetia.pl
16:18:39 --- kick: TheGoldenAngel was kicked by glguy (TheGoldenAngel)
16:23:45 --- mode: glguy set -o glguy
16:24:44 <thecontrarian42_> is anybody here? i need some architecture advice.
16:24:59 <Cale> There are 1500 users in the channel. Someone must be here.
16:25:00 <Lokathor> 1500 of us are
16:25:09 <cite-reader> Hi yes I'm paying attention.
16:25:09 <thecontrarian42_> cool
16:25:43 * quchen wonders what all those idlers are doing
16:25:46 <thecontrarian42_> so its not in haskell, but i figured if there was one place i could fine good engineers it was here
16:26:00 <thecontrarian42_> so, i'm building a dataflow language
16:26:34 <hodapp> I'm an engineer, legally.
16:26:37 <quchen> We're roughly average, half of us are below the median even. We just happened to stumble upon the right language.
16:26:45 <hodapp> whether I'm a good one or not is another matter.
16:28:48 <tippenein> thecontrarian42_: you going to leave us hanging? What are you BUILDING?!?!
16:29:07 <thecontrarian42_> i have a runtime, which manages multiple patches, which manage multiple objects, which manage multiple inlets and outlets, where each inlet can have some number of connections, each to a different outlet, and each outlet can have some number of connections, each to a different inlet. a connection references one outlet and one inlet
16:29:12 <thecontrarian42_> sorry, slow typist
16:29:27 <tippenein> hehe, nah. apologies for my impatience
16:29:37 <glguy> dfeuer: The types of \f g -> traverse f . fmap g   and   \f g -> Compose . fmap (traverse f) . traverse (Identity . g)
16:29:48 <glguy> seem terribly similar
16:31:29 <tippenein> so a connection is just a pipe from In to Out? and an object manages the multiple connections
16:32:02 <thecontrarian42_> no, an outlet/inlet manages the multiple connections
16:32:57 <thecontrarian42_> if an object sends 'hat' out its first outlet, it shouldnt care whos connected to that, be it nobody or everybody
16:33:09 <thecontrarian42_> the outlet is what does the fanout
16:34:42 <thecontrarian42_> same with inlets. when an inlet gets some data from one of its possibly multiple connections, it just forwards that data to the object that manages it, as the inlet. the object itself doesnt get to know who sent it, unless thats somehow contained within the data payload itself, which it wont be
16:35:33 <frerich> This "Incredible Proof Machine" is very entertaining :-)
16:35:50 <thecontrarian42_> idontgetthatreference.jpeg
16:36:23 <quchen> dfeuer: No worries. I just keep bookmarks of things to keep an eye on, and when they grow too many I'm cleaning up.
16:38:34 <thecontrarian42_> also, this whole system is meant to be edited graphically, as a flow graph of boxes with lines connecting them, but it also needs to be able to work without the gui, as a library, by just instantiating the runtime, and giving it some serialized representation of the flow graph.
16:39:24 <thecontrarian42_> for a common implementation of this idea look at puredata and max/msp
16:40:20 <EvilMachine> What do I use, if I want a type like IO, but without that return parameter? (As in: IO () )
16:40:45 <thecontrarian42_> so ive written a version of this sort of system before, but when i did i made every reference a direct reference. so an object would have a field with an array of its outlets and another with its inlets.
16:40:59 <simon_> EvilMachine, what do you mean? could you elaborate?
16:41:20 <quchen> EvilMachine: () is the parameter for "don't care" in many situations.
16:41:26 <awpr> EvilMachine: well, 'type O = IO ()'
16:41:28 <cmccann> EvilMachine: so... you want IO ()?
16:41:40 <awpr> if you're just looking to avoid the parameter syntactically
16:41:47 <EvilMachine> I tried Applicative, but class (Applicative x) => X x where { f :: x -> IO () } says x is of kind (* -> *). I need kind (*)
16:41:55 <cmccann> EvilMachine: you could wrap it in some other type or whatever but then you can't use it for IO directly
16:42:00 <thecontrarian42_> the problem is that it becomes sort of hard to reason about.
16:42:11 <quchen> Or you could use IO () because that's a very common type and everyone knows that it means.
16:42:17 <simon_> EvilMachine, if you want a type that isn't constructed by application of a type constructor, define your own type from the bottom up.
16:42:24 <jle`> EvilMachine: try f :: x a -> IO ()
16:42:27 <hodapp> thecontrarian42_: have you read much of FRP yet?
16:42:28 <awpr> EvilMachine: class Applicative x => X (x a) where ...
16:42:40 <awpr> or what jle` said
16:43:05 <EvilMachine> awpr: but I don’t want to write () behind my type everywhere
16:43:19 <simon_> type ThenDont = IO ()        foo :: ThenDont
16:43:19 <thecontrarian42_> hodapp: ive looked into it several times, but ive never actually done anything in it
16:43:24 <quchen> #define IOUNIT IO ()
16:43:36 <jle`> EvilMachine: x can only be an Applicative if it's  * > *
16:43:42 <jle`> it doesn't make any sense for a * to be an Applicative
16:43:55 <jle`> if you care a lot about having it be kind *, then just drop the Applicative constraint?
16:44:12 <jle`> or do f :: x () -> IO (), or f :: x a -> IO ()
16:44:14 <simon_> EvilMachine, it is not uncommon for often used types to receive aliases, but IO () is a very commonly used type.
16:44:31 <EvilMachine> jle`: It being Applicative is the whole point. I can drop everything but that.
16:44:41 <Cale> EvilMachine: That... is not the definition of Applicative at all, what you wrote.
16:44:53 <Cale> (Applicative is an actual thing which is in the Prelude now)
16:44:55 <jle`> if you want it to be an Applicative, and you want it to be *, then you have a bit of an ideological mismatch
16:45:10 <awpr> EvilMachine: what are you actually trying to accomplish?  i.e. what are real names for X and f?
16:45:15 <jle`> that's like saying you want a dog but only are willing to take lead pipes
16:45:19 <Cale> EvilMachine: I suspect you're undergoing some kind of severe XY problem here :)
16:45:32 <thecontrarian42_> my new idea is to store all of the intances of the various objects in the runtime, give each an id, and then only pass around and store the ids in all of the other objects, along with a reference to the runtime so if they do need to do work on them, they can request them from from runtime with the id
16:45:51 <jle`> it doesn't even make sense to ask for a * to be an Applicative
16:45:55 <thecontrarian42_> i have a sneaking suspicion thats dumb tho
16:45:59 <EvilMachine> simon_: Basically, I want a type, that I can string together like (a1 *> a2 *> a3), and then use some run function to wrap the IO () out of every (a)
16:46:02 <jle`> what would the type signature of pure even be?
16:46:06 <ttt_fff> what is the closest to "Fearless Refactoring w/ the Haskell Type Checker" ?
16:46:20 <Cale> EvilMachine: IO () and >> satisfy this property.
16:46:23 * simon_ watches EvilMachine get killed by over-eager Haskell programmers, like a kitten in a shelter visited by a kindergarten. :D
16:46:44 <Cale> Or maybe I don't understand what your description is describing.
16:47:03 <quchen> ttt_fff: What do you mean with that?
16:47:14 <quchen> Closest in what sort of space
16:47:15 <Cale> The "run function" would just be the identity function if you used IO ()
16:47:22 <Cale> I think?
16:47:33 <Cale> Or maybe I don't understand what you're trying to accomplish at all.
16:47:42 <simon_> EvilMachine, I'm not sure I understand what you mean, but if you use type Whatever = IO (), and foo, bar, baz :: Whatever then (foo *> bar *> baz) is a valid expression.
16:47:48 <ttt_fff> quchen: I want a book / article on fearless refactoring haskell code using th type chcker
16:48:34 <quchen> Aaah. Hm. I don't think I've seen something specifically about that. Learning Haskell is a lot about finding the right level of abstraction that gives you type safety and doesn't overthink things I guess, and then you get the refactoring for free.
16:49:03 <quchen> A good rule of thumb is to avoid type synonyms and types with more than 2 parameters.
16:49:17 <EvilMachine> Damn, I’m starting to hate that stupid “XY problem” meme that everyone’s suddenly parroting around. I do not want some idiotic one-trick-pony “solution” that only works for that one single case. That’s exactly why I’m giving generic examples when asking! So I get a generic solution that works for every instance of it! That has nothing to do with XY.
16:49:38 <EvilMachine> This is #haskell and not #php, after all.
16:49:45 <quchen> Watch your language.
16:49:48 <quchen> :-C
16:50:15 <awpr> EvilMachine: but as far as we can tell you've asked for a type with *> and convertible to IO (); the simplest such type is 'IO ()'.  So what is it you want that that doesn't do?
16:50:18 <Cale> EvilMachine: Don't worry, our solutions will be sufficiently abstract.
16:51:14 <EvilMachine> quchen: And this “bad language” insanity I hate even more. Nobody even knows why it’s even supposed to be “bad”! But they’re all parroting that Catholiban social rule as if it’s somehow causing harm to people.
16:51:31 <EvilMachine> Sorry this is the wrong crowd for me today. :/
16:51:32 <Cale> EvilMachine: My reaction is this way because your question makes very little sense.
16:51:38 <EvilMachine> Usually Haskell is sane.
16:51:42 <awpr> I think the bad language in question was "php"
16:52:00 <simon_> I think so, too. :)
16:52:11 <Shockk> I got that impression too, that it was directed at your php comment
16:52:41 <Shockk> clever punnery doesn't always translate well over text
16:53:07 <Shockk> oh they quit
16:53:08 <Cale> EvilMachine: If, rather than complaining about the way that we're trying to answer you, instead you just provided the additional details we were asking for, we might be able to help you better.
16:53:14 <Shockk> Cale: they left
16:53:24 <Cale> ah, yes
16:53:25 * simon_ ignores joins/parts/quits on freenode.
16:53:32 <awpr> joins and parts: can't live with them, can't live without them
16:53:46 <glguy> That's part of why I made my own client :)
16:53:56 <Shockk> I mentally ignore them in #haskell so I didn't notice it until I looked really hard
16:54:00 <Cale> glguy: What client did you write?
16:54:02 <simon_> glguy, how do joins/parts show in your client? got a screenshot? and was it made in haskell?
16:54:13 <hiptobecubic> weechat can hide them for all but people who have spoken recently. It's very handy.
16:54:39 <simon_> hiptobecubic, that seems useful. naturally, irssi can do that, too, if you write the script. ;)
16:54:54 <Welkin> you can tell if they left by using tab autocompletion
16:54:55 <Welkin> :P
16:55:06 <Welkin> not sure how Cale missed that
16:55:09 <simon_> Welkin, not halfway through a long message to them :)
16:55:14 <Welkin> Cale: did you manually type out the nickname?
16:55:19 <Welkin> oh
16:55:21 <Cale> Welkin: I'd already autocompleted the name before he left.
16:55:21 <quchen> If you write the patch you can use your kernel to chat on here.
16:55:41 <hiptobecubic> Cale uses spaces, not tabs.
16:55:43 <glguy> All sequential joins/parts/nick-changes etc go on the same line and scroll of the right side of the screen and I can press F2 to toggle visibility of them
16:55:44 <glguy> http://imgur.com/N0l2arp
16:56:12 <glguy> You can see some of the higher-up ones collected on the same line
16:56:22 <Shockk> that looks nice
16:56:23 <ttt_fff> is it posible to use guards + case together ?
16:56:30 <ttt_fff> or can guards only be used at the top level of defining functions
16:56:44 <awpr> ttt_fff: yep!  guards can go between the pattern and the -> symbol
16:56:44 <quchen> Case can contain guards.
16:56:46 <glguy> If the same person has multiple events, their name is shown once and the events stack
16:57:09 <quchen> ttt_fff: When you're inside a "case" then you're in there for good though, you can't "fall out" of a case block again.
16:57:17 <hiptobecubic> ttt_fff, case x of -> _ | True = ....
16:57:24 <Welkin> you can actually do some pattern matching inside a guard too
16:57:26 <Shockk> glguy: like +xShockk?
16:57:28 <hiptobecubic> not the best example in the world :)
16:57:46 <hiptobecubic> glguy, what is the coloring? People you've recently highlighted?
16:57:47 <ttt_fff> awpr, hiptobecubic: nice, thanks
16:57:54 <ttt_fff> quchen: I have no idea what that means
16:58:05 <Welkin> | Just count <- mCount, count > 5 = ...
16:58:17 <exio4> question without clear answer (after reading the MRP); how many packages would break if Monoid was split into Semigroup and Monoid? :P 
16:58:23 <glguy> hiptobecubic: It highlights peoples names in chat messages the same as when they talk to help connect conversations
16:58:27 <quchen> exio4: Plenty.
16:58:47 <exio4> that'll be for GHC 9.0? :p 
16:58:49 <thecontrarian42_> hodapp: how would frp help me keeps things clean?
16:58:54 <hiptobecubic> glguy, I use that also, but I'm looking at the names which are still white
16:58:55 <exio4> I would like a nice 
16:59:06 <exio4> +Maybe instance for Monoid
16:59:07 <hiptobecubic> What determines who is white and who is orange?
16:59:22 <glguy> hiptobecubic: white is just one of the randomly assignable colors. it is picked via a hash of the name
16:59:38 <hiptobecubic> glguy, ah ok. My mental model was overfitting :)
16:59:57 <Cale> thecontrarian42_: I don't know exactly why people brought it up, but FRP is internally a lot like dataflow.
17:00:07 <glguy> Anyway, it's in Haskell. I have a few users, not a lot though :) https://github.com/glguy/irc-core
17:00:27 <quchen> exio4: AMP was somewhat painful, MonadFail will be comparatively painless, NoReturn will have quite an impact. Splitting Monoid is probably in the upper half of the pain scale, not sure where exactly though.
17:01:12 <glguy> Shockk: Suppose someone joined and then logged into nickserv, you'd see:   +x+Username (where the + and x were colored)
17:01:24 <Shockk> ahh I see
17:01:33 <Shockk> also nice, supports CAP
17:01:47 <glguy> It supports all the stuff Freenode supports
17:01:51 <voidzero> glguy is making one of the best (most modern) clients there is
17:02:02 <voidzero> I'm frikkin' jealous of those skillz :P
17:02:05 <thecontrarian42_> Cale: oh, ok cool. i'll look into it.
17:02:17 <glguy> it's certainly newer than most clients, I won't argue for best :)
17:02:18 <quchen> Making a modern IRC client is fairly easy, because all the existing ones are awful. :-s
17:02:43 <Welkin> quchen: really?
17:02:48 <Welkin> ERC, irssi?
17:02:51 <voidzero> quchen, you need to work on your arguing skillz
17:03:12 <glguy> I wanted to be able to see status changes without it taking over the screen to help with moderation stuff
17:03:14 <Shockk> I was working on some irc services in haskell ages ago and the code is probably horrible to me now https://github.com/shockkolate/arata
17:03:28 <voidzero> a
17:03:29 <Cale> thecontrarian42_: While there are many FRP systems, and no clear winner (though some are getting very practical, we're using Reflex in production at the company I work for), essentially all FRP systems have two major ideas represented in some form
17:03:35 <voidzero> oops
17:03:40 <exio4> quchen: yeah, MonadFail sounds painless compared to AMP/NoReturn, and Monoid/Semigroup sounds even more painful because (it being a typeclass in base, and being so generic), has lots of instances :p 
17:03:48 <glguy> to able to /ignore people while still knowing they were talking if I just wanted to hide a conversation I wasn't following temporarily, but still be able to toggle the messages back
17:04:51 <voidzero> btw, just to be fair, weechat is the other very decent client
17:04:53 <Cale> thecontrarian42_: For any type a, values of type Behaviour a represent things which always have a value whenever you care to observe what it is. Things like the current position of the mouse, the number of hitpoints a monster has, or what graphics to display on the screen at any moment might be represented by behaviours.
17:05:16 <aupiff> why would stack detect local changes in a package that points to a git commit? How do I make sure that sort of thing is never rebuilt?
17:05:30 <Shockk> weechat is pretty good but over prolonged periods of time it does have high memory
17:05:56 <hiptobecubic> yes
17:06:11 <hiptobecubic> sometimes when I quit it does some serious gyrations that I can't explain
17:06:20 <hiptobecubic> like 100% cpu usage for 30 seconds
17:06:27 <Cale> thecontrarian42_: For any type a, values of type Event a represent things which occur at particular points in time, and have a value (of type a) at that moment. Things like the sequence of keystrokes, or mouse clicks, the sequence of attacks made by a monster, or the sequence of sound effects to be played might be represented by events.
17:06:29 <hiptobecubic> no idea what that's about
17:06:38 <voidzero> strace it
17:06:57 <voidzero> i'd be curious
17:07:21 <Shockk> in relation to Haskell I was working on a Haskell plugin for Weechat ages ago
17:07:34 <thecontrarian42_> that sounds really similar to the concept of signals and messages in the system i'm building
17:08:14 <Shockk> I actually got kind of far to the point where it was just about implementing the correct API to be available through the ffi
17:08:20 <Cale> thecontrarian42_: FRP libraries generally give you a bunch of ways to take existing behaviours and events and compose them together, e.g. taking a function (a -> b -> c), a value of type Behaviour a and an Event b, and forming a new Event c which occurs at the same times as the original Event b, but whose value is obtained by applying the function to the current value of the behaviour at that time, and the value of the
17:08:20 <Cale>  event.
17:08:28 <Shockk> but I stopped because weechat passes around pointers in scripts as strings :/
17:08:35 <voidzero> a haskell plugin for weechat.. would so make my day
17:08:36 <jle`> good question dfeuer 
17:09:41 <Shockk> https://github.com/shockkolate/weechat/tree/weechat-haskell/src/plugins/haskell
17:09:45 <Shockk> ^ if you're interested
17:10:05 <Shockk> this worked and added a bar to weechat with text 
17:10:07 <Shockk> https://github.com/shockkolate/weechat/blob/weechat-haskell/src/plugins/haskell/example.hs
17:10:45 <Cale> thecontrarian42_: and while there are many possible implementations, internally, these descriptions might be used to construct a dataflow graph of some sort, which might be optimised a bunch, and then turned into a program which does mutable updates of variables.
17:10:49 <voidzero> Shockk, cool :)
17:11:06 <voidzero> I'll check it out 
17:11:46 <Shockk> this was my favourite function to write, by which I mean it was annoying to write
17:11:49 <Shockk> https://github.com/shockkolate/weechat/blob/weechat-haskell/src/plugins/haskell/Weechat.hs#L119
17:12:24 <Shockk> thinking about it, I could have done it with <$> and <*> though, but I didn't know how to use those at the time
17:14:01 <voidzero> Shockk, this might interest you too: https://github.com/AJFarmar/haskell-polyvariadic
17:14:04 <voidzero> via reddit
17:15:02 <Shockk> ahhh, I saw that being discussed in here the other day
17:16:06 <Shockk> that looks somewhat like the idea I had in my head at the time
17:16:23 <Shockk> it seems like a nice way of doing it
17:18:05 <Shockk> I assume GHC would infer the return type to be String if it was inferred by the context
17:18:18 * hackagebot luminance 0.2 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.2 (DimitriSabadie)
17:18:20 * hackagebot postgresql-schema 0.1.6 - PostgreSQL Schema Management  https://hackage.haskell.org/package/postgresql-schema-0.1.6 (markfine)
17:18:55 <voidzero> I have yet to check it out
17:19:17 <voidzero> darn, past 2am
17:19:20 <voidzero> i gotsta go.. ttyl
17:28:18 * hackagebot luminance-samples 0.2 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.2 (DimitriSabadie)
17:45:55 <rhz> I implemented a bunch of first order logic stuff in Haskell. Includes an automated theorem prover, somewhat basic.  https://bitbucket.org/ruben_zilibowitz/harrisonlogichaskell
17:52:44 <ajp> is there tooling support to minimize bulid-depends in a cabal file? I'd like to figure out packages I'm not actually using in the code (and can thus remove), without manually checking each package
17:55:37 <Welkin> ajp: pull your code into a new directory and run cabal init
17:56:02 <Welkin> it will auto detect the packages the code is using and create a new .cabal file with the necessary package names
17:56:59 <ajp> Welkin: awesome
17:56:59 <Welkin> or actually, you could just rename your exisintg project.cabal or project.cabal.bak and do this
17:57:11 <Welkin> to*
17:57:56 <geekosaur> hm, there are tools to figure out required versions, but none to reanalyze for needed/unnecessary deps
17:58:49 <cmccann> geekosaur: hm?
17:58:51 <Welkin> another solution would be to just delete all of the build-depends and let the compiler tell you
17:59:00 <Welkin> then add only the necessary ones back
17:59:02 * geekosaur poked hackage re cabal tools
17:59:03 <cmccann> oh, I see what you were replying to, nevermind
17:59:51 <cmccann> ajp: you can get that information easily but indirectly by having GHC dump minimal imports and then see what's missing
18:00:16 <cmccann> ajp: you can get that information precisely with more effort from your package's .hi files
18:00:56 <cmccann> if those both sound like overkill, I recommend Welkin's approach of remove everything and add things back until it works
18:01:21 <Welkin> I think cabal init also adds bounds to the package names too
18:02:25 <dmj`> haskell-mode for emacs will actually tell you which dep. and version to import
18:02:34 <dmj`> to add to cabal file, rather
18:03:06 <cmccann> geekosaur: y'know btw, as far as tooling goes, it seems like there should be enough information in .hi files to make explicit version bounds unnecessary in most cases
18:05:21 <cmccann> in fact I think it tracks the transitive closure of imported orphan instances, so you could potentially do *better* than what perfect PVP compliance would offer
18:16:45 <JagaJaga> Getting <<loop>>. Compilet with -prof, trying to tun with +RTC -xc. But getting nothing. How to print stack trace or smth?
18:17:22 <JagaJaga> s/Compilet/Compiled
18:18:34 <vedosity> JagaJaga use traceStack
18:19:01 <vedosity> in Debug.Trace
18:19:02 <JagaJaga> I'm idiot. Mistake in m code was obvious :)
18:19:12 <JagaJaga> vedosity: thank you anyway!
18:20:04 <mitochon> is there an easy way to browse a package from hoogle .. seems to assume your query is a function
18:27:51 <dmwit_> cmccann: I'm around for a few minutes. Can get back on later if it's going to be useful.
18:27:54 <dmwit_> What's up?
18:28:24 <cmccann> dmwit: I was going to ask you something minor but I forgot what. new version of these has the function you wanted though.
18:28:57 <dmwit> Oh, sweet, disclose.
18:29:02 <dmwit> I'll start using it post-haste.
18:29:20 <cmccann> oh, I think I was gonna ask if I should write a Default instance for These but based on what instances exist I concluded it shouldn't have one
18:29:37 <ttt_fff> in Parsec: instead of giving parsec a stream, is it possible ot provide it a monadic function to call whenever it wants the next token?
18:29:42 <dmwit> Yeah, I don't really think there's a sane Default instance.
18:30:22 <cmccann> dmwit: I couldn't find an instance Default (Either a b), so I figured These fit in the same category
18:30:32 * dmwit nods agreement
18:30:57 <dmwit> ttt_fff: Isn't that pretty much exactly what the Stream class does?
18:31:03 <cmccann> dmwit: anyway, that was all :]
18:31:09 <ttt_fff> dmwit: so I'm reading http://hackage.haskell.org/package/parsec-3.1.6/docs/src/Text-Parsec-Prim.html#Stream
18:31:13 <ttt_fff> dmwit: and I have to agree with you
18:33:58 <shachaf> cmccann: There's an obvious symmetric choice for These, but not for Either.
18:35:00 <cmccann> shachaf: but not necessarily a meaningful choice
18:35:30 <cmccann> I couldn't really think of any situation where that would be a sensible default
18:36:11 <shachaf> Default isn't about sensible choices.
18:37:15 <felix-honneker> poke
18:37:22 <dmwit> puke
18:37:43 <ttt_fff> what's the best way to sandbox haskell (for an online submission system where users can submit haskell code)
18:38:03 <felix-honneker> ping
18:38:10 <cmccann> shachaf: if there was a Monoid instance I would've used mempty as default but there isn't
18:41:29 <geekosaur> ttt_fff, I think mueval is how lambdabot does it
18:46:11 <levi> I think the tryhaskell site uses mueval too.
18:50:51 <Hijiri> I wonder what nomyx uses
18:52:44 <Hijiri> first glance on the github it just builds its own thing on top of ghc lib
18:53:52 <Hijiri> oh, it uses hint
19:06:12 <rsyring> trying to start this introduction: http://learnyouahaskell.com/introduction#what-you-need
19:06:45 <rsyring> It says to use Haskell Platform, but I've seen others that say stackage is better.  Can I run through learnyouhaskell with stackage tools?
19:09:03 <Adeon> you can
19:09:29 <Adeon> I don't remember if it had any parts about installing haskell but if it has, then you would use the stackage tools instead
19:09:41 <Adeon> you probably only need the stack executable, it can install ghc and all packages you need
19:11:10 <Adeon> the 'stack' tool is quite new but it's a killer app for haskell development so it's a good idea to learn how to use it
19:11:42 <rsyring> Adeon: thanks for the reply.  Looks like I just need the stack prefix now that I have it setup.  `stack ghci` instead of just `ghci` etc.
19:11:58 <Adeon> it probably did install ghci somewhere that you can run directly but stack ghci should work too, yes
19:12:05 * geekosaur wonders how long before #haskell goes after the severly misguided persons having created the most evil platform with torches and pitchforks
19:12:39 <Adeon> geekosaur: is that stack or haskell platform? :-)
19:12:58 <geekosaur> the most evil platform, not the hallowed stackage
19:13:06 <cmccann> to be even-handed and fair I think we should target both
19:13:13 <geekosaur> the one that is utterly hated here
19:13:26 <cmccann> I mean why complain about one thing when you can complain about two??? I rest my case.
19:13:32 <Adeon> yeah I think overall you should know hackage and cabal-install as well
19:13:46 <Adeon> but I don't think haskell platform is so useful for...anything? I'm not sure
19:14:13 <Adeon> maybe on windows?
19:14:38 <cmccann> personally I install GHC tarballs manually and just install things to my user package DB using cabal-install without all this newfangled "sandbox" stuff
19:16:26 <cmccann> and tbh I really haven't had any problems despite occasionally forcing reinstalls and installing lots of cabal packages from github repos and whatever else
19:16:33 <jackhill> well, when I was first starting out, I installed the platform, but since I use Linux exclusively, it was just a meta-package for my distribution
19:16:49 <jackhill> now, I'm tryin to figure out how to use stack to my liking
19:19:00 <cmccann> that said, I'm on linux and last I heard the Haskell Platform was the best way to install some packages on windows without having to stop to gouge your brain out a few times during the process
19:19:03 <cmccann> dunno if that's still the case
19:21:13 <bitemyapp> cmccann: no longer the case.
19:21:23 <cmccann> bitemyapp: that's good to know
19:21:27 <bitemyapp> cmccann: I used to recommend HP only for Windows users on the guide for the reason you mention - MinGHC is better now as is Stack.
19:21:52 <bitemyapp> I waited until several people I trust gave me the thumbs up on MinGHC before I finally excised it from the guide.
19:22:54 <Adeon> I need to check out the windows story with haskell tools at some point
19:23:06 <Adeon> it's been a while since I've done any haskell development on windows side
19:23:29 <cmccann> Adeon: back in the day the story was one of those classical tragedies, where everyone dies horribly at the end
19:23:29 <Adeon> does 'stack' just work on windows?
19:24:01 <cmccann> I stopped even trying to do anything with Haskell on windows, since my main desktop runs linux anyway :T
19:24:33 <Adeon> yeah, I run linux at home and when in serious stuff all the haskell stuff is deep in backend on linux or bsd machine so windows doesn't enter the picture
19:24:47 <Adeon> which is great
19:25:34 <jasonkuhrt> Can someone explain how/what happens if a function that accepts 1 argument is composed with a function that accepts 2 arguments?
19:25:37 <bitemyapp> I even flipped my gaming machine over to Linux, so I couldn't test anything Windows related now if I wanted to.
19:25:37 <cmccann> bitemyapp: btw, I've been tinkering a bit with finding ways to more accurately infer workable package dependencies. I think there's a lot of room for automated stuff to be much smarter than it is currently
19:25:59 <bitemyapp> cmccann: oh I agree. Is it related to the PVP stuff Michael's been talking about?
19:26:08 <cmccann> no, it's stuff I'm just doing on my own
19:26:10 <Adeon> I wish I could ditch windows but there are still games I want to play that will only work on windows :-(
19:26:15 <jasonkuhrt> (+1) . (+1)  has type of Num c => c -> c
19:26:31 <jasonkuhrt> but (const) . (+1) has type of Num a => a -> b -> a
19:27:02 <jasonkuhrt> And if I compose another function that accepts say 3 arguments the resulting function accepts 4 arguments then
19:27:05 <jle`> jasonkuhrt: the best way to think about it is to just manually apply the definition of (.)
19:27:06 <jasonkuhrt> I don't understand
19:27:07 <cmccann> bitemyapp: actually I'm not sure what PVP stuff you're thinking of
19:27:09 <jle`> @src (.)
19:27:10 <lambdabot> (f . g) x = f (g x)
19:27:26 <bitemyapp> cmccann: Snoyman's trying to make a facility for Stack to infer package bounds based on PVP guidelines.
19:27:43 <jle`> jasonkuhrt: (const . (+1)) x = const ((+1) x)
19:27:50 <bitemyapp> cmccann: he wants it (or Cabal?) to start generating a log of successful builds so that you have a database of "known good"
19:28:01 <jle`> jasonkuhrt: ((+1) . (+1)) x = (+1) ((+1) x)
19:28:06 <jle`> or 1 + (1 + x)
19:28:08 <bitemyapp> cmccann: you should check out his couple recent blog posts on it, it's pretty cool.
19:28:32 <cmccann> bitemyapp: ah. I'm looking into the viability of doing something a bit more direct than that
19:29:00 <bitemyapp> cmccann: yeah that's the initial pass he's doing for Stack's ability to infer bounds.
19:31:43 <nitrix> Is there a Haskell test framework that's kind of monadic with combinators like `it`, `describe`, `expects`, etc?
19:32:04 <nitrix> Parsec but for testing, basically.
19:32:27 <dmj`> nitrix: hspec
19:32:29 <bitemyapp> nitrix: hspec
19:32:29 <jasonkuhrt> jle: so in the simple case of: const . id
19:32:30 <hodapp> nitrix: hspec
19:32:34 <dmj`> @package hspec
19:32:34 <lambdabot> http://hackage.haskell.org/package/hspec
19:33:16 <jasonkuhrt> id accepts 1 argument and const accepts 2, manually run it could be:   (cosnt (id 1) 2)
19:33:23 * hackagebot poppler 0.13.1 - Binding to the Poppler.  https://hackage.haskell.org/package/poppler-0.13.1 (IanWooKim)
19:33:31 <nitrix> That looks like it, thanks hodapp, dmj`, bitemyapp.
19:33:43 <bitemyapp> back to fighting that damn CoArbitrary/Fun/Arbitrary for Applicative f => f (a -> b)
19:33:54 <jasonkuhrt> when you compose them ...
19:34:33 <jasonkuhrt> 1 goes to id which returns 1 and enters cosnt which returns a function which accepts 1 more argument
19:34:50 <jasonkuhrt> hm
19:34:53 <jasonkuhrt> I see..
19:34:57 <jasonkuhrt> const . id :: a -> (b -> a)
19:35:25 <jasonkuhrt> it actually makes more sense when I wrap the end as a function
19:35:34 <jasonkuhrt> darn currying makes things hard to visualize sometimes
19:35:40 <jasonkuhrt> but I love it...
19:35:46 <cmccann> jasonkuhrt: you get used to it eventually
19:36:17 <emmanuel_erc> Hello everyone.
19:36:23 <jasonkuhrt> Just need to fully solder the model into my mind
19:36:25 <jasonkuhrt> practice
19:38:56 <jasonkuhrt> Does anyone here find the majority of pointfree actually helps the readability of their program
19:39:08 <jasonkuhrt> or in most cases except trivial ones does it hurt readability
19:39:12 <nitrix> Too much is like not enough.
19:39:36 <jasonkuhrt> huh? ha
19:39:42 <cmccann> jasonkuhrt: the majority of the vaguely sensible ways to write things pointfree are an improvement, to my mind
19:39:45 <jasonkuhrt> Die Hard Pointfree?
19:40:01 <cmccann> but there's a very, very large number of ways to make things pointfree and horrible
19:40:21 <jasonkuhrt> For example...
19:40:26 <jasonkuhrt> reverseTuple (a, b) = (b, a)
19:40:27 <jasonkuhrt> vs
19:40:30 <nitrix> Pointfree isn't bad, it's a concatenative style that combines smaller functions into bigger functions.
19:40:33 <jasonkuhrt> reverseTuple = uncurry (flip (,))
19:40:34 <hodapp> jasonkuhrt: if it's easy to make point-free, I usually try to because I find that it clears things up and eliminates the clutter of names
19:41:11 <jasonkuhrt> but something like that reverseTuple is absurd no?
19:41:20 <jasonkuhrt> Or do Haskellers actually thing that's a kind thing to do
19:41:20 <cmccann> jasonkuhrt: once you start nesting operator sections of (.) or using the pointless obfuscation monad to duplicate arguments you're probably not helping readability anymore
19:41:31 <hodapp> but when I'm getting into all manners of other clutter instead, I prefer to just name the arguments
19:41:41 <hodapp> rather than having . and $ all over the place
19:41:45 <hodapp> cmccann: there's a pointless obfuscation monad?
19:41:46 <awpr> jasonkuhrt: I think it's pleasantly clever and not hard to understand.  but the straightforward definition is simpler and preferred IMO
19:41:48 <nitrix> The problem is when you try to combine too many things, it becomes hard to understand the essence of what it is that you're trying to achieve; also to visualize the type transformations.
19:42:04 <cmccann> hodapp: a.k.a. the monad/applicative instance for (->)
19:42:23 <shachaf> cmccann: whoa whoa whoa, it's used for both duplicating and eliminating arguments.
19:42:33 <awpr> cmccann: that's my favorite instance when I want to make impossible-to-read code
19:42:56 <cmccann> shachaf: using it to eliminate arguments doesn't hurt readability anywhere NEAR as badly.
19:43:07 <cmccann> awpr: hence my name for it :P
19:43:12 <shachaf> If you use return instead of const to eliminate arguments, I won't be happy about it.
19:43:21 <awpr> Identity can also be a pointless obfuscation monad
19:43:45 <cmccann> eh, Identity just creates extra noise. that's not as bad.
19:43:55 <hardmath123> How do you know whether a function is pattern-matchable or not?
19:44:03 <cmccann> shachaf: that's fine then, since I'd use pure instead.
19:44:05 <hardmath123> I want to pattern-match against Set.singleton.
19:44:06 <jasonkuhrt> I can absolutely see cases where point free is a positive thing for the reader... f = (* 2) is better than f x = x * 2
19:44:42 <jasonkuhrt> but in many cases it seems like it just hides the visualization properties of an algorithm
19:45:21 <glguy> hardmath123: functions aren't pattern matchable
19:45:55 <hardmath123> glguy: what about the constructor-functions that get defined when you create an algebraic data type?
19:46:19 <dmj`> glguy: hey, if you were to write ffi bindings to a c lib right now, would you use c2hs? 
19:46:23 <glguy> Constructors can be used as patterns, and they can demote themselves to be functions, too
19:46:40 <glguy> But once they becomes functions you can't match with them
19:47:15 <hardmath123> glguy: ah, okay. In that case, what's the idiomatic way to get the only item of a singleton set? Set.elemAt 0?
19:48:52 <glguy> I'd use minView to extract elements from a set, or work with it as a list via toList
19:49:25 <glguy> dmj`: I don't know enough about c2hs to have an opinion about it, actually.
19:49:32 <glguy> My default is hsc2hs
19:51:45 <hardmath123> is there an idiomatic way to query whether X pattern-matches against P? do we generally use case-of statements for that?
19:52:04 <hardmath123> (to clarify, i'm interested in a boolean result)
19:52:14 <dmj`> glguy: cool, thanks
19:52:15 <awpr> hardmath123: you can put it in a pattern guard if you only want to condition a function on it
19:53:19 <glguy> hardmath123: The way to check if a pattern matches is to match with it. You can use that to write a boolean predicate for that constructor if that's useful
19:53:45 <nitrix> hardmath123: You can write a helper function isX or isP.
19:53:50 <glguy> e.g. isJust (Just _) = True; isJust _ = False
19:56:43 <jle`> jackhill: (const . id) x = const (id x)
19:56:50 <jle`> jackhill: that just comes from the definition of (.)
19:56:56 <jle`> er, jasonkurst, sorry
19:56:58 <jle`> oh they left
19:57:30 * nitrix hands jle` a consolation cookie.
19:58:36 <jle`> thank you nitrix :)
20:04:45 <jle`> i'm having trouble using SNat from Data.Singletons.TypeLits
20:04:58 <jle`> the constructor, not the type
20:05:14 <jle`> no matter what i do, it's never in scope ;_; i can import the module succesfuly and i can verify that it's there as a data constructor using :browse
20:07:06 <jle`> :browse Data.Singleton.TypeLits => it shows up, but let x = SNat says SNat not in scope...not even a "cannot infer type" error
20:07:27 <cmccann> jle`: is the type Sing in scope?
20:07:51 <cmccann> (Sing Nat is the type of SNat, right?)
20:07:59 <jle`> yes, and :i Sing shows SNat as a constructor
20:08:02 <jle`> *as an instance
20:08:07 <cmccann> hm.
20:08:17 <cmccann> I assume you have all the relevant extensions enabled
20:08:28 <cmccann> though I'd expect that to give other errors...
20:08:31 <jle`> i'm wondering if this happens to anyone else or just me...this happens even after nuking sandboxes
20:08:53 <jle`> yeah, i enabled all of the extensions that i think would be relevant, and haven't gotten any errors from those
20:09:46 <jle`> interestingly when i do :i Sing, it shows SNat fully qualified -- Data.Singletons.TypeLits.SNat, even though Data.Singletons.TypeLits is already imported
20:09:55 <cmccann> I don't have the package installed so I can't check right now
20:10:02 <cmccann> does it work if you fully qualify the name?
20:10:21 <jle`> when i fully qualify the name it says that Data.Singletons.TypeLits.SNat is not in scope
20:10:36 <cmccann> hm.
20:10:45 <cmccann> do you have multiple versions of any of the relevant packages installed?
20:10:58 <jle`> i started a new sandbox and installed only singletons, this still happens :|
20:11:09 <cmccann> bother. so much for that guess.
20:11:17 <jle`>  :i SNat shows the type alias SNat, not the data constructor, of course
20:11:39 <cmccann> hm.
20:11:47 <cmccann> ...is GHC drunk?
20:11:55 <cmccann> sorry, I'm out of ideas.
20:12:04 <jle`> thanks for your help anyways :)
20:12:06 <awpr> Glasgow *Hic* Compiler
20:18:48 <jle`> hm well it looks like i am able to just generate the SNat with just `sing` and never directly using the data constructor...and i can pattern match on (_ :: Sing 9), so i guess i don't ever even need SNat
20:19:28 <cmccann> does that pattern match bring the constraints you want into scope?
20:19:30 <jle`> oh actually my pattern matching doesn't work
20:19:32 <cmccann> I bet it doesn't.
20:20:03 <cmccann> GADT-ish constructors don't magic unless you risk _|_
20:27:00 <hardmath123> is there a way to recover the "default" `Show` behavior temporarily for a data type?
20:27:34 <jle`> what do you mean by default?
20:27:39 <glguy> derived
20:28:34 <glguy> You can derive a new Show with GHC.Generics or Data.Data, but if it's your own data type you should fix the bug and revert to the derived instance
20:29:49 <hardmath123> jle`: glguy: I'm in the REPL, and I want to copy the value of a variable so that I can paste it into my code.
20:30:06 <glguy> hardmath123: What type has the broken Show instance?
20:31:47 <hardmath123> glguy: one i defined myself with `data Sentence = [...]` and then `instance Show Sentence where [...]`
20:32:17 <glguy> You should move that custom show function to a separate function and leave Show as the default
20:32:47 <glguy> Show isn't for pretty versions of things, it's for generating Haskell source looking representations
20:33:28 <hardmath123> Oh. So then why would you ever have to create an instance of Show manually?
20:34:03 <glguy> One example is Data.Map where the constructors aren't exported so it wouldn't be a valid way to produce a new value of that type
20:34:45 <glguy> > M.singleton 'a' 'b'
20:34:46 <lambdabot>  fromList [('a','b')]
20:34:58 <hardmath123> Ah, okay. That makes sense, thanks.
20:34:59 <glguy> It should still try to be valid Haskell, but it might not use the constructors
20:36:13 <info_is_good> I have: Foo/Foo.hs, Bar/Bar.hs. I init cabal and run "cabal setup" on Foo. How do I import Foo from Bar? I.e., how do I make GHC aware of a local cabal library?
20:36:48 <glguy> In the Foo.Foo module you'll import Bar.Bar
20:36:59 <glguy> or are you wanting them to be separate packages/
20:37:05 <glguy> ?
20:37:47 <glguy> If they're separate packages you can "cabal install" the Foo package and then add that package as a build-depends: in Bar
20:37:55 <info_is_good> Foo.hs defines a module Foo. Foo is independent from Bar, Bar depends on Foo.
20:38:21 <info_is_good> glguy: okay!
20:48:22 <info_is_good> If I want to make my project as free as possible, what is best - unlicense, creative commons or something else?
20:49:01 <tabemann> new BSD
20:49:23 <tabemann> same as is practically standard for Haskell development
20:49:40 <tabemann> (I mean BSD minus the advertising clause)
20:50:43 <Clint> info_is_good: CC0 or Expat
20:50:51 <info_is_good> Looking at http://choosealicense.com/licenses/ it looks less free than cc0 and unlicense, since it requires a copyright notice, no?
20:52:24 <cmccann> info_is_good: there's always WTFPL :]
20:53:16 <cmccann> sadly I don't think cabal knows about that one :[
20:53:17 <nitrix> Hey guys, what are the implications of integrating OverloadedStrings directly in the language with a Stringable typeclass with a String and ByteString instance?
20:53:32 <info_is_good> cmccann: doesn't that allow someone to copyright my own work?
20:53:59 <cmccann> nitrix: lots of ambiguous type errors, probably
20:54:14 <cmccann> info_is_good: I don't think copyright works that way
20:54:35 <glguy> niteria: OverloadedStrings is integrated into the language and the typeclass is called IsString
20:54:55 <nitrix> Oh boy, I just became a female.
20:54:58 <cmccann> haha
20:55:07 <Myrl> nitrix: With cat ears?
20:55:08 <cmccann> nick autocomplete is suffering
20:55:15 <nitrix> Myrl: Of course :P
20:55:17 <info_is_good> I see - how do I change the License of a Cabal project to CC0? Do I just write CC0 after "license-file"?
20:55:20 <Myrl> nitrix: <3
20:55:56 <info_is_good> Or do I need to actually put the file there?
20:56:00 <nitrix> glguy: Oh! So this is the IsString that I've been seeing! Interesting, that solved two questions at once.
20:56:05 <nitrix> glguy: Appreciated.
20:57:19 <Myrl> I'm trying to parse a string of text, and sections of text that's enclosed in <` and `> will be passed to function f, and the result will replace the enclosed text, along with the delimiters.
20:58:05 <Myrl> It's harder than I expected, though that may just be because I'm very bad when it comes to parsing. :/
20:58:33 <glguy> Are you doing it with list manipulation? parser combinators?
20:59:05 <Myrl> glguy: I'm trying to do it with parsec.
20:59:21 <Myrl> My first idea was to use sepBy `> then pass the result to sepBy <`
20:59:39 <glguy> sepBy does something else
21:00:03 <awpr> I think there's one called something like manyTill
21:00:20 <Myrl> So basically, a <` b `> c becomes {a <` b `>} {c}, and the second pass goes  {{a <`} {b}} {`>}
21:00:38 <Myrl> Or something like that.
21:00:58 <Myrl> awpr: Yeah, I'm checking out manyTill.
21:01:09 <Myrl> Here's the code I have currently.
21:01:09 <Myrl> htmlHsFile = (,) <$> manyTill anyChar codeOpen  <* codeOpen <*> manyTill anyChar codeClose <* codeClose
21:01:47 <glguy> I don't think you'd need duplicate codeOpen when using manyTill
21:01:55 <Myrl> Ah.
21:02:39 <glguy> manyTill is a little strong than you need here: many (satisfy (/= '<')) >> codeOpen >> many (satisfy (/='>'))
21:03:06 <glguy> it'll work, it'll just work a little harder along the way
21:03:30 <Myrl> glguy: I can't use '<' since it's meant to be embedded in an HTML file.
21:03:42 <Myrl> Should be <`.
21:03:57 <glguy> oh I see. if it's two characters like that then manytill is better
21:04:55 <Myrl> glguy: I also need to capture the normal HTML text, since I'll need it once I condense everything to one text.
21:05:01 <awpr> also, Attoparsec will be much faster
21:05:14 <Myrl> glguy: Basically, I want to make some kind of preprocessor.
21:05:55 <Myrl> glguy: Say, `Hello, you have enterred <` putStrLn =<< getContents `>
21:08:27 * hackagebot hgrev 0.1.1 - Template Haskell splices for including the current Mercurial revision info in code.  https://hackage.haskell.org/package/hgrev-0.1.1 (LukeHoersten)
21:09:13 <Myrl> glguy: There are also some problems with my old code such as, <` putStrLn "<`" `>
21:10:13 <awpr> yeah that's a much harder parsing problem -- it needs to understand actual Haskell syntax to work.  have you thought about implementing it as a quasiquoter instead of astandalone language?
21:10:30 <awpr> (Template Haskell thing)
21:11:08 <Myrl> awpr: I'll be passing it to hint.
21:11:35 <glguy> Myrl: You're in good company. Haskell gets that wrong, too: {- putStrLn " -} " -}
21:11:37 <Myrl> awpr: I actually made the delimiters <` and `> since it's a parse error outside strings.
21:12:21 <Myrl> glguy: Lol wow.
21:15:19 <awpr> I don't think the Haskell parser is what's wrong there -- just because the contents of a comment look like Haskell syntax doesn't mean they should be interpreted that way
21:15:50 <awpr> OTOH the contents of the <``> are explicitly Haskell expressions
21:16:09 <glguy> Don't worry, I'm just having fun
21:26:24 <info_is_good> If I have a library that works as a library but has a minimalist command line interface, should I create a different cabal project in a different directory for the command line interfae?
21:28:12 <dmj`> info_is_good: you could keep it in the same directory, it's preferential
21:28:26 <dmj`> info_is_good: src/Main.hs (executable) src/Web/Foo/Bar.hs (library)
21:29:10 <dmj`> executable main-is: Main.hs hs-source-dirs: src ... library exposed-modules Web.Foo.Bar hs-source-dirs: src
21:30:28 <info_is_good> dmj`: thanks!
21:30:39 <glguy> Make sure you aren't putting your executable in the same directory as your library source files
21:33:12 <dmj`> glguy: you mean the source for the executable? or the executable itself
21:33:19 <glguy> source
21:33:23 <dmj`> glguy: why?
21:33:41 <glguy> Things get confused when building and instead of using modules from the library it rebuilds them as part of the executable
21:33:42 <dmj`> glguy: if library and executable both have hs-source-dirs: src
21:33:46 <info_is_good> Is it okay to drop "src" if the source is just a single file?
21:34:14 <Myrl> Parsing really is harder than I expected. :/
21:34:23 <glguy> best case you do a bunch of build duplication (slower), worst case you get build failures
21:34:42 <info_is_good> Also. If I create, say, Project/src/A/Bar.hs, Foo/src/B/Foo.hs, how can I import src/A/Bar.hs from src/B/Foo.hs?
21:35:22 <glguy> once you install Project you'll be able to import A.Bar in B.Foo
21:35:51 <dmj`> glguy: wouldn't the modules from the library need to be rebuilt anyways if you've specified the executable depends on the internal library
21:35:53 <info_is_good> So it just works? Okay, makes sense. Thanks.
21:38:25 <dmj`> glguy: interesting
21:48:24 <glguy> dmj`: This is an example I either made or helped make showing when things fall down https://github.com/dagit/cabal-quirk/blob/master/cabal-quirk.cabal
21:53:07 <dmj`> glguy: interesting, does it occur only when the library has both src and srcLibraryOnly specified
21:53:29 <dmj`> in that code, if 'srcLibraryOnly' were removed, would it still occur
21:54:02 <glguy> then it would just duplicate work rather than fall down
21:57:32 <dmj`> glguy: strange
21:58:35 <dmj`> glguy: if a module is already built, it shouldn't get rebuilt, just because a folder is shared
21:59:50 <glguy> Instead of using the module from the library it will think that it's supposed to shadow the library module with hte local one
21:59:57 <glguy> It's not that smart about what is being shadowed
22:31:05 <fr33domlover> Q: How to I normally determine that a Handle has reached EOF? e.g. when I get a handle for a socket using Network.Socket.socketToHandle and start communicating with a server, sometimes suddenly the connection closes but no exception is thrown to let me know
22:31:27 <fr33domlover> I just see an error in the terminal, like it's some kind of assertion
22:31:51 <fr33domlover> Does it mean I have to check the Handle status every time myself, before every read/write?
22:35:29 <slack1256> I haven't done any network programming. But weren't network sockets their own thing different than file handles?
22:35:55 <slack1256> It made sense close a socket, but saying that it reached the end of it?
22:36:35 <glguy> fr33domlover: reading on a closed socket will result in an exception being raised
22:37:37 <glguy> You'll want to be handling the IOExceptions that using Handles can raise whether or not you're checking hIsEOF before reading from a handle
22:38:31 <fr33domlover> glguy, my code does catch them, only to close the socket and re-throw
22:39:18 <fr33domlover> but when that EOF happens nothing is thrown, also I just found this: http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-IO-Handle.html#v:hGetLine
22:39:39 <fr33domlover> Looks like indeed it won't throw, but handle the EOF as a line terminator?
22:48:31 * hackagebot oidc-client 0.1.0.0 - OpenID Connect 1.0 library for RP  https://hackage.haskell.org/package/oidc-client-0.1.0.0 (ShoKuroda)
22:52:28 <nitrix> How do I see the precedence of an operator in GHCI ?
22:52:57 <nitrix> :info (!) doesn't shows it somehow.
22:53:42 <nitrix> Also, higher infix means tigther binding?
22:56:36 <Maxdamantus> Maybe the precedence hasn't been defined.
22:56:41 <jle`> nitrix: it'll show it if it's defined
22:56:51 <jle`> try :i (:)
22:56:55 <nitrix> What is the default?
22:57:17 <Maxdamantus> I think it's an error to rely on precedence without defining it.
22:57:24 <jle`> https://www.haskell.org/onlinereport/decls.html
22:58:11 <nitrix> jle`: 4.4.2  Fixity Declarations, thanks.
22:58:20 <Maxdamantus> maybe not.
22:58:43 <jle`> np!
23:02:45 <fr33domlover> glguy, hmmm I think you were right and I was wrong, the issue was that the exception happened in a separate thread, not the main thread
23:03:03 <fr33domlover> that's why execution didn't terminate... my mistake :P
23:28:33 * hackagebot curves 1.1.0.2 - Library for drawing curve based images.  https://hackage.haskell.org/package/curves-1.1.0.2 (UlfNorell)
23:52:11 <latermuse> are there any libraries that help with loading config files written in haskell into a compiled binary at run-time?
23:52:20 <latermuse> kind of like what xmonad does
