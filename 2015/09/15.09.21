00:00:02 <Cale> like Maybe, IO, the list type constructor [], etc.
00:00:15 <Cale> I'm not sure what that question means
00:00:25 <Cooler> the actual function its mapping is a->b so why does it need another function f?
00:00:28 <Cale> Look at the type signature for fmap
00:00:35 <Cale> fmap :: (a -> b) -> f a -> f b
00:00:43 <Cale> If a is some type, then f a also needs to be a type
00:01:01 <Cale> whatever f is, it needs to be able to accept a type as an argument, and produce another type
00:01:25 <Cale> Let's look at an example or two
00:01:32 <Cooler> why isn't fmap:: (a->b) -> a -> b
00:01:42 <Cale> because that's way too boring to be useful
00:02:26 <kriztw> that's just function application with an extra indirection
00:02:29 <Cale> Such a function can't do anything interesting at all, it either produces the function it is given as its result, or it produces undefined or (const undefined)
00:02:32 <Cooler> What exactly is f? a function that takes a type and returns the same type or a different one?
00:02:39 <shachaf> Before understanding fmap, you should understand map.
00:02:40 <Cale> a different type, usually
00:02:47 <shachaf> map :: (a -> b) -> [a] -> [b]
00:02:57 <Cale> Oh yeah! Do you understand the map function for lists?
00:03:19 <Cale> It takes a function (a -> b) and a list of values of type a, and produces a list of values of type b
00:04:00 <Cooler> whats the type of fa?
00:04:01 <Cale> and it does that by applying the given function to each element of the given list, collecting up a list of the results
00:04:19 <Cale> f a doesn't have a type, it is a type, so it has a kind
00:04:26 <Cale> It will be kind *
00:04:44 <Cooler> fa isn't a value?
00:04:52 <Cale> It's on the right hand side of the ::
00:05:14 <Cale> things on the left of :: are always values, things on the right are types
00:05:26 <Cooler> what? i meant in an example
00:05:27 <Cale> They are two separate worlds in Haskell
00:05:40 <Cooler> not in the definition
00:05:42 <Cale> Let's look at an example
00:05:50 <Cale> I'll define a type of binary trees:
00:06:00 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
00:06:14 <Cale> i.e. a binary tree with values of type a is either the empty tree Tip
00:06:22 <Cooler> what would the type of f a be in a instance of Functor
00:06:37 <Cale> or it is constructed by applying the function Branch to a value of type a, and two values of type (Tree a) (the two subtrees)
00:06:50 <Cale> Does this definition make sense?
00:07:03 <Cale> @let data Tree a = Tip | Branch a (Tree a) (Tree a)
00:07:04 <lambdabot>  .L.hs:147:25:
00:07:05 <lambdabot>      Ambiguous occurrence ‘Tree’
00:07:05 <lambdabot>      It could refer to either ‘L.Tree’, defined at .L.hs:146:1
00:07:10 <Cale> @undefine
00:07:11 <lambdabot> Undefined.
00:07:21 <Cale> @let data BinTree a = Tip | Branch a (Tree a) (Tree a)
00:07:23 <lambdabot>  Defined.
00:07:30 <Cale> oops!
00:07:32 <Cale> @undefine
00:07:32 <lambdabot> Undefined.
00:07:38 * hackagebot nested-routes 4.0.0 - Declarative, compositional Wai responses  https://hackage.haskell.org/package/nested-routes-4.0.0 (athanclark)
00:07:38 * hackagebot hasql-postgres 0.10.6 - A "PostgreSQL" backend for the "hasql" library  https://hackage.haskell.org/package/hasql-postgres-0.10.6 (NikitaVolkov)
00:07:41 <Cale> @let data BinTree a = Tip | Branch a (BinTree a) (BinTree a)
00:07:43 <lambdabot>  Defined.
00:07:47 <Cale> there we go
00:07:50 <Cale> :k BinTree
00:07:52 <lambdabot> * -> *
00:08:00 <Cale> So BinTree is a type constructor of kind * -> *
00:08:02 <Cale> :t Tip
00:08:04 <lambdabot> BinTree a
00:08:07 <Cale> :t Branch
00:08:08 <lambdabot> a -> BinTree a -> BinTree a -> BinTree a
00:08:24 <Cale> and it has Tip and Branch as data constructors
00:08:28 <Cale> With me so far?
00:08:35 <Cooler> ok
00:08:50 <Cale> We're going to make BinTree into a functor, by defining  fmap :: (a -> b) -> BinTree a -> BinTree b
00:09:06 <Cale> fmap f Tip = ...
00:09:12 <Cale> fmap f (Branch x l r) = ...
00:09:20 <Cale> So we have these two cases to define
00:10:50 <Cale> The idea is that we're going to apply the argument function f to all the elements in the branch nodes of the tree
00:11:12 <Cale> So  fmap f Tip = Tip  since there's nothing to apply f to, this is pretty much all we can do
00:12:08 <Cale> fmap f (Branch x l r) = Branch (f x) ... ... -- here we get to apply f to the element x, and make the result the element in the new Branch node, and now we just need to deal with the subtrees, applying f to all their elements
00:12:21 <Cale> So, let's just use fmap to do that recursively:
00:12:33 <Cale> fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)
00:13:14 <Cale> @let instance Functor BinTree where fmap f Tip = Tip; fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)
00:13:15 <lambdabot>  Defined.
00:14:20 <Cale> > fmap length (Branch "here" (Branch "is" (Branch "a" Tip Tip) (Branch "tree" Tip Tip)) (Branch "of" (Branch "strings" Tip Tip) Tip))
00:14:22 <lambdabot>      No instance for (Show (BinTree Int))
00:14:22 <lambdabot>        arising from a use of ‘show_M60946015852584487520058’
00:14:22 <lambdabot>      In the expression:
00:14:28 <Cale> argh, haha!
00:14:33 <delYsid`> Is "f (x:xs) = ps >>= \p -> fmap (p :) (f xs)" the idiomatic way to combine all non-deterministic results of ps?  Or do I miss something obvious here?
00:14:44 <Cooler> f isn't the function your passing to fmap is it? what about (a -> b)
00:14:48 <Cale> @let deriving instance Show a => Show (BinTree a)
00:14:49 <lambdabot>  Defined.
00:14:51 <Cale> > fmap length (Branch "here" (Branch "is" (Branch "a" Tip Tip) (Branch "tree" Tip Tip)) (Branch "of" (Branch "strings" Tip Tip) Tip))
00:14:53 <lambdabot>  Branch 4 (Branch 2 (Branch 1 Tip Tip) (Branch 4 Tip Tip)) (Branch 2 (Branch ...
00:15:13 <Cale> Cooler: Sorry for reusing f at the value level if it's confusing
00:15:43 <Cale> Cooler: the f which is an argument to fmap in my definition for BinTree here is not the same as the f in the generic type of fmap
00:16:03 <Cooler> oh ok
00:16:07 <Cale> (you can tell because they live in entirely separate namespaces, one is a function and so is a value, the other is a type)
00:16:43 <Cale> BinTree is taking the place of the f in the generic type of fmap
00:16:45 <Cale> :t fmap
00:16:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:16:56 <Cale> :t fmap :: (a -> b) -> BinTree a -> BinTree b
00:16:58 <lambdabot> (a -> b) -> BinTree a -> BinTree b
00:17:07 <Cale> We can specialise the type of fmap like that
00:17:18 <Cale> now that I defined the instance of Functor for BinTree
00:17:53 <Cale> and in my example where I applied length to the BinTree String to obtain a BinTree Int, it was specialised further:
00:18:01 <Cooler> well in this example the f was the type of the BinTree
00:18:03 <Cale> :t fmap :: (String -> Int) -> BinTree String -> BinTree Int
00:18:04 <lambdabot> (String -> Int) -> BinTree String -> BinTree Int
00:18:10 <Cooler> BinTree Int for example
00:18:12 <Cooler> http://pastebin.com/2CBx88zv
00:18:14 <Cale> nope
00:18:27 <Cooler> in that pastebin the f is not used at all
00:18:29 <Cale> Here, f = BinTree, a = String, b = Int
00:18:50 <Cale> in fmap :: (Functor f) => (a -> b) -> f a -> f b
00:19:08 <Cooler> no i meant the type parameter, the other f
00:19:27 <Cale> Sorry, which f?
00:19:40 <Cooler> data Bintree f
00:19:46 <Cale> oh, you have yet another f, what I've been calling a?
00:20:13 <Cale> data BinTree a = Tip | Branch a (BinTree a) (BinTree a)
00:20:31 <Cale>              ^ this thing
00:20:45 <Cooler> The type parameter is actually used in this example
00:20:56 <Cooler> but in the pastebin, its only there to instance Functor
00:21:22 <Cale> Right, and while the compiler should accept it now, that isn't really a *valid* instance of Functor
00:21:49 <Cale> Since it's required (by convention) that  fmap id x  should be x, no matter what x is.
00:22:02 <Cale> but  fmap id Test1 = Test2 there
00:22:06 <Cooler> so why do you need the type parameter when its never used?
00:22:42 <Cale> You can define trivial functors which don't make use of the type parameter, but they're of limited usefulness indeed.
00:22:55 <merijn> Cale: Tell that to lens :)
00:22:57 <Cale> (They do actually turn out to be somewhat useful)
00:22:58 <Cale> yes
00:23:08 <Cale> I didn't want to get into lenses right at the moment though
00:23:50 <Cale> Cooler: Usually you want fmap to actually apply the function it's given somehow
00:25:48 <Cooler> Why does Functor require a type parameter?
00:26:09 <Cale> Cooler: It just does. The type of operation we're abstracting over involves a type constructor
00:26:19 <merijn> Cooler: What would it's type look like without a parameter?
00:26:32 <Cooler> also regarding applying the function fmap is given thats the other f, thats not the type paramter
00:26:49 <Cale> Cooler: We're not trying to capture some other pattern involving types that don't have type parameters
00:27:35 <Cale> If we were, we'd define a different class instead, and probably not use the word "functor" for it, since that word has a lot of mathematical history behind it.
00:27:43 <Cooler> the f your talking about is (a->b) the type parameter f is usually something like Int
00:27:48 <Cale> NO
00:27:56 <Cale> the f in types is never Int!
00:28:16 <Cooler> you just made a BinTree Int
00:28:18 <Cale> It *must* be a type constructor, not a type like Int which has no type parameters
00:28:27 <Cale> :t fmap
00:28:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:28:37 <Cale> the f's in that are never Int
00:28:40 <Cooler> it can be Int, i didn't say it has to be
00:28:43 <Cale> a and b might be Int
00:28:46 <merijn> Cooler: It *can't* be
00:28:56 <Cale> f cannot be Int there
00:29:02 <Cooler> again your talking about the other f
00:29:03 <Cale> Because  Int String  doesn't make any sense
00:29:06 <merijn> Cooler: 'f' can't be Int because that's a type error (technically a kind error, but let's gloss over terminology)
00:29:11 <Cale> (supposing we picked a = String)
00:29:28 <Cooler> data Test Int
00:30:58 <Cooler> why do say it can't be of type Int
00:31:10 <Cale> You don't mean to say "of type" there
00:31:37 <Cale> f can't be Int because it must be something which we can apply to a type
00:31:42 <Cale> :t fmap
00:31:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:31:48 <Cale> f a shows up there
00:31:55 <Cale> in a position where a type is expected
00:32:22 <Cale> and a shows up also in a position where we expect an ordinary type to be
00:32:43 <Cale> So applying f to some type a results in another type f a
00:32:56 <Cale> a might be String, it can be any type at all
00:33:13 <Cale> (any ordinary type with values, i.e. a type level thing of kind *)
00:33:31 <Cale> So whatever f is, we need for  f String  to make sense
00:34:06 <Cale> If we tried f = Int, with a = String then we'd run into f a = Int String
00:34:13 <Cale> and Int String doesn't make sense
00:34:25 <Cale> Int doesn't have type parameters
00:35:11 <Cale> right?
00:35:25 <Cooler> in data BinTree f = Leaf f | Branch (BinTree f) (BinTree f)
00:35:33 <Cale> don't use f there
00:35:35 <Cooler> your saying f can't be int?
00:35:38 <Cale> bad choice of variable
00:35:40 <Cale> use a there
00:35:49 <Cale> Well, you can write f there, but it's just confusing
00:35:55 <Cale> (you can use any letter you like)
00:36:24 <Cale> But that variable needs to be something which is a plain type like Int or String, so using f there would be misleading
00:36:41 <Cooler> thats why i said type parameter
00:36:47 <Cale> BinTree is something which can serve as our f in the type of fmap
00:36:52 <Cale> :t fmap
00:36:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:37:03 <Cale> If we plug in BinTree for f this still makes sense:
00:37:09 <Cale> (a -> b) -> BinTree a -> BinTree b
00:37:38 <Cooler> Why does Functor require a type parameter? its not actually used
00:37:43 <Cale> huh?
00:38:06 <Cale> Functor itself requires a type parameter because all classes need one
00:38:17 <Cale> (it's actually a type constructor parameter)
00:38:26 <merijn> Cooler: What would it do without the type parameter?
00:38:43 <Cale> Type classes exist to constrain the set of type level things over which type variables range.
00:39:13 <Cale> So e.g. the constraint  (Functor f)  may appear in types to constrain which type constuctor  f  you're allowed to choose
00:39:39 <Cale> Without that type parameter, you wouldn't be constraining anything
00:39:50 <Gurkenglas> Hmm. Maybe one could have a parameterless "typeclass" of kind Constraint, that would either have an instance or not, globally. Something like showMyRecord :: Debug => ()
00:39:54 <Cale> So there would be almost no point to the type class.
00:40:13 <Cale> Yeah, you can do that with an extension actually, though it is a little bit silly.
00:40:39 <shachaf> An instance is either defined along with the class or orphan.
00:40:43 <Cooler> "type level things" what does that even mean?
00:41:18 <Cale> Cooler: Well, I'm trying to be a bit cautious, because some people use the word "type" to refer only to things which classify values
00:41:40 <Cale> e.g.  Maybe Integer  is a type, that's pretty uncontroversial
00:41:54 <Cale> But you're not allowed to have values whose type is just  Maybe  on its own
00:42:14 <Cale> So do we call Maybe on its own a type?
00:42:22 <Cale> Well, it's something which lives in the world of types
00:42:36 <shachaf> ski would call it an uninhabitable type
00:42:36 <Cale> It transforms types into other types
00:45:19 <Cale> Maybe is actually another good example of a functor
00:45:29 <Cale> data Maybe a = Nothing | Just a
00:45:34 <Cale> instance Functor Maybe where
00:45:36 <merijn> Gurkenglas: You can have parameterless typeclasses, I think shachaf at some point complained about them being missing
00:45:39 <Cale>   fmap f Nothing = Nothing
00:45:44 <Cale>   fmap f (Just x) = Just (f x)
00:46:08 <shachaf> merijn: Implementing nullary classes involved removing ~3 lines from GHC.
00:46:14 <merijn> :)
00:46:18 <Gurkenglas> Do we have Constraint -> Constraint?
00:46:30 <Cale> Here, our implementation of fmap for this instance has the type (a -> b) -> Maybe a -> Maybe b
00:46:53 <Cale> > fmap (*2) (Just 7)
00:46:55 <lambdabot>  Just 14
00:47:00 <Cale> > fmap (*2) [1,2,3,4]
00:47:01 <lambdabot>  [2,4,6,8]
00:47:33 <Cale> > fmap (*2) (Branch 2 (Branch 1 Tip Tip) (Branch 3 Tip Tip))
00:47:35 <lambdabot>  Branch 4 (Branch 2 Tip Tip) (Branch 6 Tip Tip)
00:47:50 <merijn> Gurkenglas: What do you mean? You can write arbitrary type families with kind Constraint -> Constraint, sure
00:49:09 <Cale> Cooler: Is this helping?
00:49:49 <Gurkenglas> merijn, for example AlsoPointed :: (* -> Constraint) -> (* -> Constraint) , which adds point :: a to the requirements for an instance of its parameter class C (and a is the type parameter)
00:50:18 <merijn> Gurkenglas: I think that should be possible
00:50:41 <Cale> uh, sort of
00:51:21 <Cale> (you'll need a Pointed class with that method)
00:52:03 <merijn> Sure
00:52:22 <merijn> You need a separate pointed class, but you can "add" the Pointed constraint to a constraint this way
00:53:00 <merijn> Gurkenglas: Fun fact, with type families + constraint kinds you are also allowed to write "type Compound a = (Read a, Show a, Eq a)" and then writing "foo :: Compound a => a" is valid :)
00:53:31 <lpaste_> Cale pasted “compiles” at http://lpaste.net/141407
00:55:56 <lpaste_> Cale revised “compiles”: “No title” at http://lpaste.net/141407
00:56:32 <Cale> Gurkenglas: ^^ see my paste :)
00:58:29 <Gurkenglas> Cale, can it be done so that one can define "instance AlsoPointed MyClass MyType" without having defined an instance of MyClass?
00:58:56 <Cale> no
00:59:14 <Cale> When you write instances, the instance head is not an arbitrary constraint
01:00:37 <arman> ciao
01:00:43 <arman> !list
01:00:43 <monochrom> arman: http://lpaste.net/browse
01:01:11 <Cale> monochrom: NICE CATCH!
01:01:56 <shachaf> It is a script.
01:02:39 <Cale> I sort of figured, but regardless :)
01:03:53 <MatthewRock> Hey guys! Why should I learn haskell?
01:04:05 <ttt_fff> https://www.haskell.org/hoogle/?hoogle=AlexPosn <-- WHAT MODULE exports AlexPosn ???
01:04:24 <irrequietus> MatthewRock: because it will make you a better programmer regardless of what your current mainstream legacy language used at work is.
01:06:11 <MatthewRock> irrequietus: But will it be fun? I enjoy writing in Lisp, although I'm often programming in other languages.
01:06:47 <merijn> MatthewRock: Note the poll results mentioned here: http://www.huffingtonpost.com/aaroncontorer/haskell-the-language-most_b_4242119.html
01:07:16 <irrequietus> MatthewRock: I don't know what your definition of fun is, but if you are somebody who likes a challenge proving itself to be a useful endeavor, yes, it will be quite fun.
01:07:36 <merijn> MatthewRock: Basically, the common experience is frustration (due to needing to relearn programming from scratch) at first and nirvana once you suddenly go "oh!"
01:08:10 <merijn> "Of the 51 programming languages listed in the Hammer Principle Programming Languages survey, Haskell was ranked first by 1,821 programmers for this statement, "I would recommend most programmers learn this language, regardless of whether they have a specific need for it.""
01:08:16 <irrequietus> I disagree, you don't relearn anything from scratch, you actually do learn something.
01:09:03 <MatthewRock> I'm not sure if Java is so ugly, or Java is so ugly and the code in the article is terrible as well.
01:09:27 <irrequietus> Java is bureocratically ugly to begin with.
01:10:51 <tero-> is there a job queue library for redis?
01:11:01 <merijn> MatthewRock: Ignore that code simple, that's not something I would use as an example of "what haskell is good at" anyway
01:11:17 <MatthewRock> Well, I have a similar approach to Java as I had to Flash - I think that people who created it were dangerous psychopaths, and they should be held in prison while waiting for Java to slowly die.
01:11:22 <merijn> Mostly because I don't think a short code example is good at illustrating that for haskell anyway :)
01:11:40 <MatthewRock> merijn: I have to agree, the code sample has no point, imho
01:11:42 <merijn> Although there's some cute and neat examples like the usualy fibonacci wizardry
01:11:58 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
01:11:59 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:12:01 <irrequietus> what haskell is really good is at allowing you to efficiently express yourself through function composition, recursion and all those sane practices, allowing you to really be DRY instead of dealing with inane OOP obscenities.
01:12:07 <MatthewRock> Do you loop often in Haskell, or do you use tail recursion more often?
01:12:32 <merijn> MatthewRock: There's no loops, I mean you could use recursion to make a "forLoop" function, but...
01:12:35 <MatthewRock> Since in most mainstream programming languages, you don't use recursion that often(if at all)
01:12:41 <merijn> MatthewRock: Tail recursion isn't very important in haskell
01:12:47 <MatthewRock> merijn: why?
01:12:52 <irrequietus> OOP lOOPs, haskell folds and fmaps.
01:13:04 <merijn> MatthewRock: Because Haskell (pendantic note: GHC's implementation of haskell) does not use a call stack
01:13:09 <irrequietus> :P
01:13:25 <merijn> MatthewRock: Tail recursion is to avoid linear call stack growth, but lacking a call stack means there's no growth to avoid :)
01:13:33 <MatthewRock> sounds nice.
01:13:33 <irrequietus> --^ +1
01:13:45 <ttt_fff> Is there a way to tell Happy: DO NOT MATCH LONGEST; instead, match in the order of the rules under "tokens :-" ...
01:13:54 <merijn> MatthewRock: Basically, haskell compiles function calls to asm jumps, not asm call instructions
01:14:20 <MatthewRock> So if I decide to learn it, and I come here and ask stupid questions, will you help me reach enlightenment, or tell me to rtfm?
01:14:27 <lpsmith> Hmm, has anybody deciphered the semantics of converting a AF_UNIX Datagram socket to a handle?
01:14:42 <merijn> MatthewRock: I would say this is probably the nicest IRC channel in existence :)
01:14:52 <irrequietus> yup
01:15:04 <quchen2> GHC-Haskell can still stack overflow of course. It's just not a *call* stack.
01:15:20 <merijn> lpsmith: Eh, "socketToHandle :: Socket -> IOMode -> IO Handle" ? :p
01:15:35 <merijn> lpsmith: I know it's deceptively named, but!
01:15:48 <u-ou> what kind of stack is it, quchen2?
01:15:56 <merijn> u-ou: Pattern match stack
01:16:18 <Hijiri> I think the stack limit was removed by default in 7.10 or 7.8?
01:16:28 <u-ou> how does that work exactly?
01:16:37 <merijn> Hijiri: It's still wise to avoid useless piling up the pattern match stack
01:16:49 <lpsmith> merijn, right, but what's the semantics of the resulting handle?   I mean,  the handle is conceptually a bitstream and doesn't handle any message framing,  which the Datagram does....
01:17:24 <merijn> u-ou: If you're interested in the details of compiling haskell to machine code, there's an excellent paper on this (which also covers things like how laziness is implemented)
01:17:41 <u-ou> merijn: link pls :3
01:17:47 <merijn> u-ou: I'd say it requires only basic haskell knowledge, but you should have some basic knowledge about asm/C too (obviously)
01:17:57 <quchen2> ?google making a fast curry haskell
01:17:59 <lpsmith> And many protocols transported over AF_UNIX Datagram sockets do actually _depend_ on the built-in message framing.
01:17:59 <lambdabot> http://community.haskell.org/~simonmar/papers/evalapplyjfp06.pdf
01:17:59 <lambdabot> Title: Under consideration for publication in J. Functional Programming 1 Making a F...
01:18:04 <quchen2> ^ u-ou 
01:18:11 <merijn> u-ou: http://research.microsoft.com/apps/pubs/default.aspx?id=67083
01:18:21 <u-ou> thanks
01:18:23 <ttt_fff> is ther a haskell builtin for this:
01:18:24 <ttt_fff> ignoreName :: (a -> c) -> a -> b -> c  ignoreName f a _ = f a 
01:18:28 <merijn> quchen2: No, I would not recommend eval apply until after the SPJ one
01:19:16 <merijn> u-ou: Note, many of the optimisations discussed in that paper have been obsoleted. But the over all high-level ideas are still pretty applicable and it should give you a decent idea on how to esimate the execution cost of haskell code
01:19:36 <quchen2> merijn: Maybe. The first one is still very instructional, despite it not being what's in GHC right now.
01:19:56 <merijn> quchen2: I linked the first one, eval-apply builds on the STG one
01:20:06 <merijn> So I would recommend starting with STG and reading eval-apply next
01:20:17 <merijn> Since STG is longer and more in-depth
01:20:19 <quchen2> Is that so? I forgot. If the one builds on the other, start with the 199X one.
01:21:02 <merijn> quchen2: eval-apply mostly deals with how to compile lazy function calls efficiently, so it's smaller in scope, it's also like 70 pages shorter than the STG one ;)
01:21:36 <merijn> lpsmith: Good question, I recommend looking at the code of socketToHandle and Handle functions and enlightening us :)
01:21:56 <quchen2> merijn: Those 70 pages are remarkably smooth to read.
01:22:06 <quchen2> Especially the first 40 until they get into the nitty gritty C details.
01:22:33 <merijn> quchen2: I'm confused, are you arguing in favour of the STG one or not? >.>
01:22:47 <merijn> STG is the long detailed one, eval-apply the short specific one :)
01:23:43 <merijn> ttt_fff: That's just "const . f" I think?
01:23:50 <merijn> :t const . (undefined :: a -> c)
01:23:51 <lambdabot> a1 -> b -> a
01:24:09 <ttt_fff> merijn: that does not look right
01:24:13 <ttt_fff> we need (a -> c) -> (a -> b -> c)
01:24:20 <ttt_fff> it's the _2nd_ arg that is ignored
01:24:22 <tero-> what'd be a good module name (path) for a simple job queue on top of redis?  
01:24:25 <merijn> :t const
01:24:26 <KaneTW> :t const
01:24:27 <lambdabot> a -> b -> a
01:24:28 <lambdabot> a -> b -> a
01:24:49 <merijn> Should be right, type naming is acting weird, I think
01:24:50 <ttt_fff> no no, it needs type (a -> c) -> (a -> b -> c) .. it returns a func which ignores 2nd arg
01:25:32 <merijn> :t let f :: Int -> Char; f = chr; ignoreStuff = const . f in ignoreStuff
01:25:34 <lambdabot> Int -> b -> Char
01:25:51 <quchen2> merijn: For! It's an excellent paper.
01:25:57 <quchen2> No irony intended.
01:26:04 <ttt_fff> oh I see
01:26:07 <ttt_fff> I'm an idiot
01:26:08 <ttt_fff> thanks
01:30:24 <ttt_fff> $whiteSpace = [ \t\n] <-- how should I be defining whitespace in Alex
01:30:27 <ttt_fff> does the above work?
01:30:33 <ttt_fff> for some reason I'm getting lexical errors
01:31:10 <gamegoblin> Why do a lot of functions in base take an Int and say "the int must be positive" instead of using a Word?
01:31:14 <gamegoblin> historical reasons?
01:34:08 <kriztw> ttt_fff: can't you use $white which is built-in?
01:34:13 <merijn> gamegoblin: Yeah, also Int is in Prelude and Word is not, afaik
01:34:14 <ttt_fff> yeah
01:34:15 <ttt_fff> just found that in the docs
01:34:21 <ttt_fff> should be using $white instead
01:34:44 <gamegoblin> merijn: I think it is in prelude these days
01:34:49 <kriztw> but as i recall from last time i messed with alex, there are some gotchas when using their regex syntax
01:35:08 <KaneTW> http://stackoverflow.com/questions/12432154/int-vs-word-in-common-use
01:35:11 <gamegoblin> merijn: at least it is in 7.10
01:35:18 <kriztw> especially around ranges, where some of the examples in the docs were wrong
01:35:38 <merijn> gamegoblin: By now it's mostly historical reasons, I think
01:37:36 <jophish_> gamegoblin: I had it rationalized in part to me this way: If you have something like x :: Int; x = -1; and later in the program try and do something like: take x [1..] this will be an error straight away. If however you did this: take (fromIntegral x) [1..], the outcome will probably be worse, and harder to debug
01:38:22 <jophish_> I think that Haskell tries to strike a nice balance between usability and safety (certainly much nicer than most other languages in widespread use today)
01:39:25 <merijn> The other problem is that Word is still a num instance so "take -1 [1..]" would still compile and fail at runtime
01:39:35 <merijn> Actually, I guess it's worse
01:39:38 <merijn> > -1 :: Word
01:39:40 <lambdabot>  18446744073709551615
01:39:43 <jophish_> In an ideal world the compiler would require (or better yet construct) a proof that x can't be negative before casting to a word, but in practice this ends up littering the code with checks which still fail at runtime
01:39:58 <merijn> jophish_: Smart constructors plus my neat TH hacks!
01:40:26 <merijn> jophish_: Then you can do things like: https://github.com/merijn/validated-literals/blob/master/examples/Examples.hs
01:40:54 <jophish_> merijn: oooh, very nice!
01:41:02 <merijn> I should expand the docs a little on how to implement proper Lift instances
01:41:44 <merijn> jophish_: All it requires is this code: https://github.com/merijn/validated-literals/blob/master/examples/Even.hs
01:41:59 <jophish_> yeah, I'm just looking around.
01:44:27 <merijn> jophish_: Lemme know if the haddocks need any improvement. I think I could expand a little on the how/why of Lift instances, but I hope the rest is clear
01:48:49 <jophish_> merijn: It all seems pretty easy to understand just from reading the code
01:49:16 <merijn> I really dislike the type signature of spliceValid, but it's the best way I could think of given the large number of missing Lift instances
01:49:28 <merijn> (8.0 should get DerivingLift, so that should make things better)
01:54:52 <jophish_> It's not the end of the world. At least that's not something a user will interact with very often
01:55:19 <merijn> Sure and I figure the warnings are bolded enough to persuade them not to :p
01:55:48 <nullx002> splitWhen (<(-1) || >15) [-1,1,0,-2,17,43,-4,5,7,-9,0,2,33,876]
01:55:56 <nullx002> throws an error
01:55:57 <nullx002> '
01:56:10 <merijn> That code doesn't parse
01:56:12 <nullx002> import Data.List.Split
01:56:18 <nullx002> why?
01:56:31 <merijn> "(<(-1) || >15)" <- this is not valid haskell
01:56:40 <nullx002> splitWhen (<-1) [-1,1,0,-2,17,43,-4,5,7,-9,0,2,33,876] works well
01:57:00 <merijn> Yes, because "(<-1)" *is* valid haskell :)
01:57:12 <nullx002> hum... so how to achieve that?
01:57:21 <nullx002> what is the right syntax
01:57:49 <merijn> nullx002: Your comparison operators are in infix notation, but lacking a left hand argument and boolean operations like || don't work on functions anyway
01:58:03 <merijn> Simplest way would be "\x -> x < -1 || x > 15"
01:58:03 <nullx002> it is from here http://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html
01:58:05 <KaneTW> what (<-1) does is define an operator section of (<) with the second argument being -1
01:58:36 <nullx002> bool dont work on functions???
01:58:48 <KaneTW> hm?
01:58:50 <merijn> Why do we still not have strength in Prelude (or somewhere...)?
01:58:53 <KaneTW> you're confusing things
01:59:01 <shachaf> (||) doesn't, and even if it did, what you wrote would be a syntax error.
01:59:17 <nullx002> yes i know...
01:59:23 <KaneTW> you could do 
01:59:29 <KaneTW> @pl \x -> x < a || x > b
01:59:29 <lambdabot> liftM2 (||) (< a) (> b)
01:59:32 <nullx002> canpt split with 2 operators
01:59:34 <KaneTW> but the lambda is cleaner
02:00:28 <nullx002> lambda was cleaner since always.. :D
02:00:34 <KaneTW> not really
02:00:42 <KaneTW> (<a) is cleaner than \x -> x < a
02:00:57 <KaneTW> it's a subjective thing in the end
02:00:59 <nullx002> yes in that sense..
02:01:25 <nullx002> so is it possible to split a 'set' with 2 conditions?
02:01:42 <nullx002> || or && 
02:02:07 <nullx002> 'set' more like in math than in haskell
02:04:30 <jophish_> It might be worth looking into https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html#v:Any
02:04:58 <jophish_> so you can input a list of conditions [(< -1), (>5)]
02:05:25 <merijn> jophish_: I don't think it is. I think nullx002 has enough trouble with basic Haskell he shouldn't be worrying about that yet
02:05:38 <merijn> The solution is to use the lambda mentioned like 50 lines ago
02:05:54 <merijn> (ok, more like 20, I guess)
02:05:59 <jophish_> ah, sorry. I just read a couple of lines later down
02:06:27 <nullx002> i guess i can at least look at that...
02:06:35 <jophish_> If things end up with a whole stack of conditions then that might be best, but obviously for just 2 then Any is overkill :D
02:07:22 <jophish_> :t splitWhen
02:07:24 <lambdabot> (a -> Bool) -> [a] -> [[a]]
02:07:32 <nullx002> yes spitWhen
02:07:39 * hackagebot raven-haskell 0.1.0.1 - Haskell client for Sentry logging service.  https://hackage.haskell.org/package/raven-haskell-0.1.0.1 (AlexanderBondarenko)
02:07:43 <nullx002> i was looking at that..
02:08:01 <nullx002> are all libraries part of standard install?
02:08:13 <merijn> No
02:08:15 <nullx002> or i have to cabal ?
02:08:28 <merijn> Data.List.Split is in another package, afaik
02:08:39 <nullx002> coz i haven't installed that one and still it was loaded in ghci
02:08:50 <merijn> Oh, it might be in the Haskell Platform
02:10:08 <jophish_> nullx002: do you want to split the list whenever something matches the condition, or do you want to partition the list into those that match and those that don't?
02:11:22 <jophish_> > partition (\x -> x < -1 || x > 5) [-1,1,0,-2,17,43,-4,5,7,-9,0,2,33,876]
02:11:24 <lambdabot>  ([-2,17,43,-4,7,-9,33,876],[-1,1,0,5,0,2])
02:11:30 <jophish_> > splitWhen (\x -> x < -1 || x > 5) [-1,1,0,-2,17,43,-4,5,7,-9,0,2,33,876]
02:11:32 <lambdabot>  [[-1,1,0],[],[],[],[5],[],[0,2],[],[]]
02:12:15 <absence> > [Right 1,Left 2,Right 3] ^.. each._Right
02:12:16 <lambdabot>  [1,3]
02:12:31 <absence> is it possible to make this fail for non-homogenous lists?
02:15:47 <ttt_fff> https://github.com/ghulette/haskell-parser-examples/blob/master/src/HappyParser.y#L12-L24
02:15:52 <ttt_fff> why do Happy parsers have a "TOKEN" section?
02:15:59 <ttt_fff> isn't all "TOKEN" processing done by the lexer / Alex ?
02:21:22 <KaneTW> you don't need to
02:22:51 <merijn> Is there a version of when that has "(Monad m, Monoid a) => Bool -> m a -> m a"?
02:24:37 <KaneTW> :t when
02:24:39 <lambdabot> Applicative f => Bool -> f () -> f ()
02:26:49 <jophish_> hmm, I wonder if that could be put in base, merijn. () is a monoid after all
02:27:59 <CindyLinz> I think that what merijn want is   whenM cond act = if cond then act else return mempty
02:28:09 <merijn> Yeah
02:28:25 <Gurkenglas> > [sequenceA [Right 1,Left 2,Right 3, Left 4], sequenceA [Right 1, Right 2, Right 3, Right 4]] -- absence
02:28:27 <lambdabot>  [Left 2,Right [1,2,3,4]]
02:28:27 <merijn> He's just saying that we can backwards compatibly generalise when
02:28:33 <CindyLinz> :t \cond act -> if cond then act else return mempty
02:28:34 <lambdabot> (Monad m, Monoid a) => Bool -> m a -> m a
02:28:58 <jophish_> :t \cond act -> if cond then act else pure mempty
02:28:59 <lambdabot> (Applicative f, Monoid a) => Bool -> f a -> f a
02:29:40 <bz> merijn: what happens when false?
02:29:47 <jophish_> pure mempty
02:29:50 <merijn> bz: return mempty
02:31:11 <nullx002> .
02:31:49 <merijn> hmmm, I'm realising this is probably not the clearest line of code every written...
02:31:52 <merijn> "    join (fmap . first . abstractKeys) <$> parseValid decMap"
02:32:15 * frerich squints to see what's going on there...
02:33:10 <Gurkenglas> lambdabot should have a command to apply :t to the input after declaring all unknown identifiers variables
02:33:29 <merijn> frerich: Basically, replace everything in front of <$> with "scopify d = first (abstractKeys d) <$> d"
02:33:48 <jophish_> The numeric hierarchy has really got me down today :(
02:34:02 <KaneTW> :t fmap . ?f
02:34:03 <lambdabot> (Functor f, ?f::a -> a1 -> b) => a -> f a1 -> f b
02:35:07 <Gurkenglas> > join (fmap . first . ?abstractKeys) <$> ?parseValid ?decMap
02:35:09 <lambdabot>  mueval-core: internal error: PAP object entered!
02:35:09 <lambdabot>      (GHC version 7.10.2 for x86_64_unknown_linux)
02:35:09 <lambdabot>      Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
02:35:24 <Gurkenglas> :t join (fmap . first . ?abstractKeys) <$> ?parseValid ?decMap -- soz
02:35:25 <lambdabot> (Functor f, Functor f1, ?abstractKeys::f1 (b, d) -> b -> c, ?decMap::t, ?parseValid::t -> f (f1 (b, d))) => f (f1 (c, d))
02:37:45 <Gurkenglas> Cool. I'll be using that one, thanks.
02:44:17 <montanonic> Wow, https://cdsmith.wordpress.com/2012/04/18/why-do-monads-matter/ is superb. Best thing I've read so far about Monads.
02:44:37 <jophish_> "abstraction distraction"
02:45:19 <KrzyStar> Lol
02:45:47 <KrzyStar> Top-level binding with no type signature: dbHost :: String
02:46:44 <KrzyStar> GHC what are you tellin' me
02:50:26 <merijn> KrzyStar: That you have a top-level binding with no type signature?
02:50:43 <merijn> KrzyStar: -Wall complains about top-level names that don't have type signatures
02:52:00 <amicuscuriae> hey why do we have type and Declare a variable like  x :: Int
02:52:10 <amicuscuriae> why cannot it know that it is an integer?
02:52:11 <KrzyStar> Well, duh
02:52:19 <KrzyStar> dbHost :: String = "127.0.0.1
02:52:37 <merijn> amicuscuriae: What do you mean?
02:52:44 <KrzyStar> No way to make it a oneliner without complaints from -Wall?
02:53:11 <frerich> KrzyStar: Well you could write 'dbHost = "127.0.0.1" :: [String]'
02:53:17 <merijn> You can disable the missing signature warning (lookup the flag in the manual, probably something like -fno-warn-missing-signatures or whatever)
02:53:26 <merijn> frerich: I don't think that removes that warning
02:53:50 <frerich> (sorry, I meant 'String' or '[Char]' but not '[String]' :-)
02:54:03 <KrzyStar> frerich: doesn't make a difference
02:54:21 <KrzyStar> Since the type declaration refers to the value and not the actual binding
02:54:26 <KrzyStar> Or how sohuld I put it
02:54:28 <merijn> frerich: -Wall wants an actual type annotation at the top level to not complain
02:54:37 <frerich> Yeah, I thought I could maybe cheat ghc a bit.
02:54:43 <frerich> (or ghc would be a bit more forgiving ;-)
02:54:59 <amicuscuriae> merijn, why y :: Int and then y = 5; why not just y = 5 ; the Variable has to know if it integer or string "hello"
02:55:16 <merijn> amicuscuriae: You can leave out "y :: Int", but other programmers will hate you
02:55:23 <merijn> amicuscuriae: It compiles just fine without "y :: Int"
02:55:36 <KrzyStar> Hah, I guess I'll just go with -fno-warn-missing-signatures
02:55:37 <amicuscuriae> merijn, What other programmer?
02:55:46 <merijn> amicuscuriae: Whoever works together with you
02:55:52 <frerich> amicuscuriae: Your future self
02:55:52 <amicuscuriae> oh
02:55:58 <KrzyStar> Since every binding *has* the type annotation here
02:56:01 <merijn> KrzyStar: Not sure if that's the actual flag name, consult manual for details ;)
02:56:35 <amicuscuriae> merijn, frerich What is with the main = do ?
02:56:36 <KrzyStar> merijn: it is :p
02:56:39 <amicuscuriae> why do we need it?
02:57:09 <hvr> is there some package providing a generic-programming style recursive enumeration of algebraic data-types?
02:57:34 <knupfer> Why is the signature of genericLength :: Num b => [a] -> b and not :: (Foldable t, Integral b) => t a -> b?
02:57:51 <knupfer> Which list has a length of 4.5?
02:57:51 <hvr> like e.g. for things like (Either (Maybe Bool) (Ordering,Bool))
02:58:07 <merijn> knupfer: Someone missed it during the the FTP proposal?
02:58:22 <merijn> knupfer: None, it's to avoid writing "fromIntegral $ length blah"
02:59:32 <knupfer> merijn: I understand the practicallity, but isn't it strange to use a typesignature where only a subset can be the result?
02:59:53 <merijn> knupfer: What do you mean?
03:00:00 <ttt_fff> what does $$ mean in Happy ?
03:00:04 <ttt_fff> does it mean "arbitrary value filler" ?
03:00:07 <merijn> knupfer: genericLength is there so you can get the length of a list as, say, a Double
03:00:11 <knupfer> (Integral a) is a subset of (Num a)
03:00:29 <merijn> knupfer: But you can't just get Integral from generic length...
03:00:38 <merijn> > genericLength [1..10] :: Double
03:00:42 <lambdabot>  10.0
03:00:47 <merijn> > genericLength [1..10] :: Complex Double
03:00:50 <lambdabot>  10.0 :+ 0.0
03:00:54 <knupfer> merijn: Yes, I understand that part.
03:01:49 <knupfer> but these are always special cases with equivalences in the integral world
03:02:04 <Hafydd> You certainly don't need any member of Integral to define genericLength; so why would you constrain it?
03:02:11 <merijn> knupfer: Otherwise you can never multiply, add, etc. with the length of a list
03:02:34 <knupfer> Hafydd: Because lengths of lists are in Nat?
03:02:49 <Hafydd> knupfer: they're also in C.
03:02:49 <knupfer> well, there is fromIntegral
03:03:53 <knupfer> Hafydd: Assuming that you talk about complex numbers, that's a special case in which the two are the same.
03:04:41 <Hafydd> knupfer: what's a non-Integral but Num type for which you think it wouldn't make sense?
03:05:34 <knupfer> Hafydd: Every non-Integral type
03:06:09 <knupfer> It's like defining (+) :: (Integral a, Num b) => a -> a -> b
03:06:11 <concept> Hello
03:06:25 <Hafydd> knupfer: why does Double's 0.5 not being the image make less sense than Integer's -1 not being in the image, for example?
03:07:28 <knupfer> Hafydd: For me the two don't make sense, with the difference that Nats aren't easily expressible in haskell
03:07:51 <knupfer> Hafydd: You could use liquidHaskell for that
03:08:27 <Hafydd> knupfer: I don't understand why you apparently think genericLength should be a surjective function. It's very often not reasonable for a function to be surjective.
03:09:02 <liste> hello concept
03:10:07 <Guest87009> so I am playing a little bit with state monad
03:10:23 <Guest87009> liste: so I am playing a little bit with state monad
03:10:37 <Guest87009> liste: http://lpaste.net/5786568468207763456
03:11:00 <Guest87009> liste: I am not sure why the doesn't print the Map with inserted key value
03:12:26 <liste> Guest87009 use evalState or put
03:12:47 <knupfer> Hafydd: It's just unintuitonal for me that such a function could return for example polar coordinate
03:12:50 <knupfer> s
03:12:59 <liste> in that one you don't modify the state at all
03:13:04 <Guest87009> liste : I don't know why my name was changed to Guesss (concept)
03:13:08 <Hafydd> knupfer: what is the Num instance for polar coordinates?
03:13:23 <knupfer> Complex i guess
03:13:26 <knupfer> :)
03:13:48 <Hafydd> knupfer: then it makes sense, interpreting it as a complex number of argument 0 and length the length of list!
03:13:52 <Guest87009> liste : it worked with evalState what is the difference ?
03:14:14 <liste> evalState returns the result of function, execState returns the final state
03:14:33 <Guest87009> liste: so it's laziness ?
03:14:36 <liste> no
03:15:21 <liste> what if you had test :: State ClientsMap () ?
03:15:37 <knupfer> Hafydd: What about genericLength [1..] :: (a -> b) ?
03:15:41 <knupfer> https://wiki.haskell.org/Num_instance_for_functions
03:15:41 <Guest87009> liste: actually that was my original try
03:15:44 <Hafydd> (It's unfortunate that the definition of Integral does not allow Gaussian integers to be an instance.)
03:16:03 <liste> Guest87009 then go with it (:
03:16:14 <liste> ps. you don't need return at all
03:16:42 <liste> :t modify
03:16:44 <lambdabot> MonadState s m => (s -> s) -> m ()
03:16:50 <Guest87009> ok I see
03:16:58 <Hafydd> knupfer: that makes sense, in the case of, for example, f + genericLength xs, I'd say.
03:17:16 <Hafydd> Although it's one of the less sensible uses of Num, I'd agree.
03:19:08 <knupfer> Hafydd: Ok, hmm.  And why doesn't it Foldable? Or Traversable?
03:20:11 <Hafydd> knupfer: I'd agree that taking Foldable as the argument would be better.
03:20:12 <Guest87009> liste: like this http://lpaste.net/5786568468207763456
03:20:25 <zalatovo> Is there a function to evaluate a list of monadic actions one after another and make the result that of the last action in the list?
03:20:32 <Hafydd> knupfer: it's just a consequence of the setting not being general enough at the time they were defined, probably.
03:20:34 <zalatovo> couldn't find it by type signature on hoogle
03:21:01 <zalatovo> Something like :: [m a] -> m a
03:21:23 <liste> Guest87009 yep
03:21:39 <zalatovo> Wait think I found it: msum
03:22:17 <liste> Guest87009 try typing /nick concep
03:22:22 <liste> concept*
03:22:46 <Guest87009> test
03:23:00 <liste> zalatovo that works differently
03:23:19 <liste> it's for MonadPlus
03:25:55 <zalatovo> liste: do you know if there's anything that does what I want? I think I could also just fold using (>>) perhaps
03:26:25 <Gothmog_> zalatovo: Like liftM last . sequence?
03:26:47 <knupfer> or fmap last . sequence
03:26:55 <zalatovo> Gothmog_: That would work, but it also means I have to traverse the entire list of results using last
03:27:05 <merijn> What's the quickest way to determine all elements in a list are unique? I guess "length l = S.size (fromList l)"?
03:30:18 <frerich> merijn: I always use 'all (null . tail) . group . sort'
03:30:34 <frerich> I don't know whether it's the quickest though...
03:30:36 <merijn> frerich: Ah, good point
03:30:50 <merijn> frerich: Should be more than quick enough (probably even nub would be)
03:32:02 * frerich feels like he's a "made man" now (in the Mafia sense), first time he managed to show something helpful to merijn
03:33:08 <knupfer> instead of (null . tail) you could use ((==1) . length) if you dislike partial functions
03:33:44 <merijn> knupfer: Except that that potentially traverses infinite lists :)
03:34:06 <merijn> knupfer: length is bad because it needlessly traverses infinite lists and group is guaranteed not to have empty lists in it's output
03:34:11 <knupfer> merijn: No, that's not the case
03:34:20 <knupfer> merijn: he uses sort beforehand
03:34:20 <jophish_> Is it necesary to sort the list
03:34:28 <jophish_> probably
03:34:31 <merijn> oh, right
03:34:42 <merijn> But then length is still asymptotically worse than "null . tail"
03:35:49 <knupfer> doesn't ghc optimize that away? he has only to check up to length two, no?
03:36:05 <merijn> knupfer: No, it can't optimise that away
03:37:31 <Gothmog_> merijn: It doesn't increase the asymptotic runtime of the whole function, however. ;-)
03:37:34 <knupfer> merijn: Is there a theoretical reason for that or is it simply not implemented?
03:37:59 <merijn> Gothmog_: It does
03:38:13 <Gothmog_> That seems like a very specific optimization to me.
03:39:12 <Gothmog_> merijn: How? length touches each element of the original list once.
03:39:29 <merijn> knupfer: Because it's very hard to prove that it can indeed stop at 2? You have to prove all sorts of properties of addition, lists, etc. to optimise that away. Or you need to special case the specific "(==1) . length" thing in the compiler
03:39:36 <Gothmog_> So O(n), when we're already in O(n*log(n))
03:39:42 <merijn> Gothmog_: How is that relevant for whether it is asymptotically faster?
03:40:01 <merijn> Gothmog_: Asymptotically faster does *not* mean "different complexity class" as some people seem to think
03:40:28 <Gurkenglas> merijn, so many people seem to think it that I would say your version should get a different name
03:40:31 <merijn> It merely means "faster for sufficiently big N", needlessly traversing those lists is *always* more work for any N
03:40:48 <Gothmog_> Alright, that's true.
03:41:09 <quchen2> Especially when N is infinite.
03:41:47 <Gothmog_> But they will differ only by a constant factor. ;-)
03:42:11 <merijn> Not really, the difference depends on the number of repetitions in the input
03:42:55 <merijn> Suppose I have "concatMap (replicate 1000000) [1..10]" then you will do 10 * 999,999 useless extra pointer dereferences + additions
03:44:37 <Gothmog_> Now you're nit-picking. Let me rephrase that: There is a constant that bounds the factor by which the runtime differs.
03:44:48 <Gothmog_> *runtimes
03:49:19 <knupfer> quchen2: not possible because it is sorted beforehand, it wouldn't even take O(1)
03:49:23 <knupfer> :)
03:53:13 * frerich looks at #haskell again and is not surprised that the 'allDifferent' function is still being discussed. :o]
03:53:15 <knupfer> so ghc doesn't make optimizations based on monotonicity of functions?
03:53:39 <merijn> knupfer: That would require proving functions monotonic
03:54:17 <knupfer> there could be some "blessed" functions in base, like length
03:54:56 <knupfer> liquidHaskell does this with induction to prove termination
03:55:08 <merijn> liquidHaskell has a full-blown SAT solver powering it
03:55:57 <jophish_> It would be really nice to be able to classify a set of functions :: a -> Bool, as covering any values of a. I explained this poorly.
03:56:16 <jophish_> It would be nice to sometimes get non-exhaustive warnings on multi way if
03:56:59 <ChristianS> jophish_: don't you get them, at least with -Wall?
03:57:05 <jophish_> in the same way we can annotate minimum definitions for class instances.
03:57:43 <jophish_> ChristianS: I don't think so. For example I have an "orbit" data type, and some if are like: if | isElliptical orbit -> ... | isHyperbolic orbit -> ...
03:57:49 <jophish_> that's missing isParabolic
03:58:07 <jophish_> but there's no way the compiler can detect that that's missing in the general case
03:58:39 <jophish_> but it would be super to be able to say, the minimum covering set for multi way if is isElliptical && isParabolic && isHyperbolic
03:58:55 <tomus> I've finally manged to scrape together some code so that it compiles and it uses optparse-applicative. My only problem is: I largely don't get how it works. And I read the post blog with simplified implementation - but, no, I still don't. Now I am relying on a library which is largely like a black box, and I am not sure whether understanding it properly is worth the effort
03:59:04 <jophish_> I don't know if this would have much utility
03:59:23 <merijn> tomus: Can you explain what you don't understand?
03:59:39 <merijn> tomus: Also, are you familiar with parser combinators? e.g. parsec
03:59:46 <tomus> no
03:59:54 <merijn> No to which one? ;)
04:00:05 <tomus> no, I don't know parsec
04:00:21 <tomus> I thought knew applicatives, functors and monads
04:00:24 <merijn> tomus: You may wanna read the Real World Haskell book on parsec then. Which introduces the basics of parser combinators
04:00:26 <tomus> but this is challenged
04:00:41 <knupfer> tomus: or on fpcomplete about attoParsec
04:00:42 <merijn> tomus: optparse-applicative is essentially a high level parser combinator library for commandline arguments
04:01:04 <merijn> tomus: So I think reading up on the ideas behind parsec should (hopefully) clear up a bunch of things
04:01:20 <opqdonut> jophish_: how about classifyOrbit that returns Elliptical, Hyperbolic, Parabolic and then a pattern match?
04:01:36 <jophish_> opqdonut: That's exactly what I've settled on for this :)
04:01:42 <opqdonut> jophish_: see also https://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
04:01:46 <jophish_> but it was still a simple example
04:02:11 <jophish_> opqdonut: even the name classifyOrbit
04:02:49 <tomus> marijn: unfortunately I gave up RWH book last time exactly in the chapters where he was writing a parser. It was so poorly motivated and obfuscated I was a little bit put off haskell tbh
04:03:04 <tomus> by haskell in the real world to be precise
04:03:19 <tomus> cuz I really like it for maths motivated problems
04:06:07 <jophish_> opqdonut: A better example might be a set of functions {isA, isB, isC, isAorB} where isAorB is perhaps much faster than (liftA2 (||) isA isB). Then the covering functions could be (((isA && isB) || isAorB) && isC)
04:06:30 <phaazon> hey, is there a way to know which version of a library is used when building a package?
04:06:32 <tomus> ah, it was "Writing a library: working with JSON data" chapter
04:06:36 <phaazon> can -vn show that?
04:06:46 <jophish_> perhaps the complication isn't worth the extra safety. It's tricky to think of real world cases when this would be useful
04:07:43 * hackagebot MFlow 0.4.6.0 - stateful, RESTful web framework  https://hackage.haskell.org/package/MFlow-0.4.6.0 (AlbertoCorona)
04:08:09 <YellowOnion> Is there any way to get more info about a blocked MVar operation?
04:09:45 <knupfer> YellowOnion: No, you can only see if an MVar would block, and if not what would be it's content if you take it, that's all
04:09:45 <YellowOnion> I'm not even sure how a TVar blocks in the first place.
04:10:04 <merijn> YellowOnion: You mean blocked Indefinitely on MVar exception?
04:10:24 <YellowOnion> merijn, yeah
04:10:38 <merijn> YellowOnion: It basically means a thread is blocked on an MVar that is being GCed
04:10:47 <merijn> (And therefore can longer ever be filled)
04:11:18 <tomus> tomus: Can you explain what you don't understand?
04:11:28 <knupfer> a recursion
04:11:29 <magneticduck> jophish_: boolean blindness can always be avoided with accessor functions that return classification data types
04:11:47 <tomus> runParser :: Parser a -> [String] -> Maybe (a, [String]), why Maybe (a, [String] <---), why string should be returned?
04:11:49 <magneticduck> although sometimes you might need several classification functions, and accessors that take as input a previous classification (for branching)
04:12:12 <merijn> tomus: Left over input
04:12:14 <magneticduck> tomus: the unconsumed input
04:12:26 <magneticduck> teamwork
04:12:44 <YellowOnion> merijn, The strange thing is, Im' using a TVar because I don't even need it to block.
04:14:58 <knupfer> YellowOnion: You get a MVar exception while using solely TVars?
04:15:51 <YellowOnion> knupfer, yes, unless its not my code that is doing it.
04:16:22 <knupfer> YellowOnion: where is that code?
04:17:18 <tomus> data Parser a where: ConsP :: Option (a -> b)
04:17:23 <tomus> -> Parser a -> Parser b
04:17:42 <knupfer> YellowOnion: besides (unless . not) is quite curious
04:17:59 <YellowOnion> knupfer, I mean it could be in one of the libraries I'm using.
04:18:08 <knupfer> ;)
04:18:19 <tomus> this idea of chaining parsers via an option is not clear
04:19:26 <merijn> tomus: I don't think I've ever looked at the definition of Parser while using optparse-applicative?
04:19:45 <knupfer> YellowOnion: It's hard to guess without seeing code, but I've never managed to get a MVar exception from TVars.
04:20:03 <tomus> I am reading http://www.paolocapriotti.com/blog/2012/04/27/applicative-option-parser/
04:20:09 <tomus> trying to get the idea
04:20:10 <YellowOnion> knupfer, I'll paste the code, give me a second.
04:20:58 <tomus> don't know whether I should bother
04:21:12 <merijn> tomus: I don't think that post is very helpful when trying to understand how to use them
04:21:49 <tomus> using it wasn't particularly difficult
04:22:09 <tomus> a little bit
04:22:10 <YellowOnion> knupfer, https://gist.github.com/YellowOnion/1049cc8180d8dc56fad7
04:22:26 <merijn> I've got a question on evaluation strategies
04:23:34 <merijn> When you're evaluating "let { ... } in foo" to normal form (not weak head normal form) should you first subtitute the definitions into foo, then normalise. Or first normalise everything, then substitute, then normalise again?
04:25:31 <YellowOnion> knupfer, line 82 of Engine.hs is where I read the TVar.
04:27:05 <stoopkid> hello
04:27:12 <stoopkid> any haskell IDE recommendations?
04:27:24 <kaidelong> intellij is alright
04:27:39 <kaidelong> leksah is alright if you can get it working but it can be slow
04:27:51 <knupfer> stoopkid: emacs
04:27:57 <kaidelong> the general answer seems to be "abandon all hope" though
04:27:58 <kaidelong> aka emacs
04:28:01 <merijn> stoopkid: Most people just use what they normally use. i.e. majority uses vim/emacs, and then there's all the rest using sublime/atom/whatever fancy newthing the kids use
04:28:04 <kaidelong> I use spacemacs myself
04:28:30 <kaidelong> there isn't really any haskell IDE, leksah is the closest thing
04:28:48 <kaidelong> even if you use something like intellij or eclipse they'll act more like text editors in practice
04:28:50 <stoopkid> ok ill just go with vim then i guess
04:28:59 <stoopkid> thank you :)
04:29:03 <kaidelong> leskah is the only thing I know with a GUI project editor for cabal files
04:29:12 <knupfer> YellowOnion: I really don't know, but my intuition says: try (atomically . readTVar) instead of readTVarIO (I know that the docs say that it's the same)
04:29:19 <merijn> stoopkid: I use vim + syntastic together with hdevtools
04:29:39 <kaidelong> I was a vim user
04:29:49 <kaidelong> vim didn't work that great for me and haskell
04:29:57 <knupfer> YellowOnion: And perhaps use type signatures for all top-level functions
04:29:58 <kaidelong> emacs is better, spacemacs makes emacs usable
04:30:13 <jophish_> kaidelong: I'm having great success with ghc-mod and friends on vim
04:30:24 <knupfer> stoopkid: If you feel brave, try Yi
04:30:53 <jophish_> he's gone :/
04:31:15 <kaidelong> jophish_: it is possible you are more patient than I am on that front with having to manually invoke ghc-mod
04:31:15 <knupfer> jophish_: Yi ?
04:31:22 <kaidelong> once I set up keybinds for it it wasn't so bad
04:31:34 <kaidelong> but emacs bindings will do this sort of thing in the background with a server
04:31:51 <knupfer> ahh
04:32:22 <knupfer> well, Yi sort of too perhaps.
04:34:27 <zaquest> kaidelong, syntastic can invoke ghc-mod for you
04:34:50 <kaidelong> oh, I was using syntastic at the time
04:34:53 <kaidelong> how do you configure that?
04:35:13 <knupfer> Are there any news on the android front?
04:36:03 <knupfer> Considering that MediaTek wants to put 16 cores in a smartphone seems like a dream for haskell.
04:36:04 <zaquest> kaidelong, i just installed ghc-mod and it worked
04:36:20 <kaidelong> maybe I should try vim again
04:36:27 <kaidelong> the last time I used it for haskell dev was 3 years ago
04:36:31 <kaidelong> it was somewhat sad
04:36:43 <tdammers> idk, I like vim
04:36:53 <kaidelong> (I mean objectively it was very sad but all your options for a development env for haskell are in the "sad" range)
04:37:07 <kaidelong> I like vim itself
04:37:09 <tdammers> depends on your wishlist
04:37:12 <kaidelong> it was the haskell tooling that was sad
04:37:19 <tdammers> oh, I don't use that stuff
04:37:22 <knupfer> kaidelong: emacs works quite well on my side of the internet.
04:37:22 <tdammers> just vanilla vim
04:37:30 <tdammers> well, that, and hasktags
04:39:53 <knupfer> I use it with ghc-mod, haskell-mode, stylish-haskell and liquid-haskell.  Do you miss something?
04:40:05 <merijn> knupfer: syntastic
04:40:20 <kaidelong> syntastic is pretty great
04:40:35 <knupfer> flycheck?
04:40:38 <kaidelong> I only wish the error window for it was used by the ghc-mod plugin
04:40:44 <kaidelong> isn't flycheck an emacs plugin?
04:40:48 <knupfer> yep
04:41:14 <knupfer> I'm talking about emacs and don't know syntastic, never used vim.
04:41:17 <kaidelong> oh okay
04:41:21 <kaidelong> whoops
04:41:35 <knupfer> But neovim seems interesting to me.
04:41:37 <kaidelong> is liquid haskell the refinement type provider for haskell?
04:41:42 <knupfer> Yes.
04:42:15 <knupfer> There is an emacs mode for liquid haskell, it works good but it is *very* slow.
04:42:37 <knupfer> About 1 min per 100 sloc.
04:43:17 <kaidelong> does liquid haskell not do anything incrementally?
04:43:25 <kaidelong> I guess GHC itself doesn't support that either
04:44:07 <knupfer> it's an option, but it doesn't reliably recheck everything necessary
04:44:51 <YellowOnion> knupfer, I just replaced it with IORefs, and still getting the same error.
04:45:25 <zaquest> i wrote a program that uses conduit, but now i think it either doesnt need conduit or im using it in a wrong way or both. all i do with conduit is reading from network, parsing lines into irc messages, and putting them in TBMChan (and reverse). is it ok to use conduit that way or is it better to just hGetLine and parse?
04:45:35 <zaquest> i think i might not need conduit because im dealing with input one line at a time and either discard it silently or output something immediately and forget about it, so im not sure how the problem conduit solves can arise here, can it?
04:45:45 <zaquest> also i wonder if im supposed to put most of my program inside conduit between source and sink and control data stream in conduit using my monad by deciding if i should answer to something that comes in and yield answer only in that case?
04:45:59 <knupfer> kaidelong: it checks only code changes, not specification changes
04:46:53 <kaidelong> how useful is liquid haskell really?
04:47:03 <kaidelong> I mean in practice you're going to be using third party libs all the time
04:47:04 <knupfer> YellowOnion: IORefs don't use MVars, so it is probably in a lib
04:47:51 <knupfer> kaidelong: I've used it and consider it useful as, let's say, a linter.
04:48:16 <knupfer> It shows you when you use non provable termination (i.e. loops)...
04:48:45 <kaidelong> so liquid haskell provides some static safety even when you don't use its refinement types?
04:48:46 <hodapp> I want to learn a little about Liquid Haskell, but mostly just so that I can tell it to a certain professor who loves Haskell and SMT, but doesn't know about Liquid Haskell, and try to make his head explode.
04:49:19 <knupfer> kaidelong: yes, and there are some functions in base which liquid haskell knows about without annotations from your part.
04:49:56 <knupfer> i.e.  length :: (Foldable t) => t a -> Nat
04:51:18 <knupfer> for example LH complains about \xs -> head xs, but doesn't complain about \xs -> head (0:xs)
04:51:57 <kaidelong> what about "alleq xs = all (head xs ==) xs
04:52:11 <kaidelong> (that is a total function)
04:52:24 <knupfer> that doesn't even type check
04:52:40 <kaidelong> @type all
04:52:42 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
04:53:10 <knupfer> > \xs -> head xs ==
04:53:12 <lambdabot>  <hint>:1:18:
04:53:12 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:53:17 <kaidelong> @type (head [] ==)
04:53:19 <lambdabot> Eq a => a -> Bool
04:53:46 <kaidelong> @type \xs -> all (head xs ==) xs
04:53:47 <lambdabot> Eq a => [a] -> Bool
04:53:52 <knupfer> oh
04:54:26 <knupfer> all (head [] ==) []
04:54:32 <knupfer> > all (head [] ==) []
04:54:34 <lambdabot>  True
04:54:40 <jophish_> kaidelong: I use syntastic 
04:55:00 <jophish_> if ghc-mod is in PATH then syntastic picks it up afair
04:56:18 <knupfer> kaidelong: LH dislikes your function
04:56:32 <jophish_> to force it you can do: let g:syntastic_haskell_checkers=['ghc_mod', 'hlint']
04:56:49 <kaidelong> knupfer: interesting
04:57:04 <kaidelong> I'm wondering what limits it from figuring that case out
04:57:13 <kaidelong> probably all is a black box to it
04:57:22 <kaidelong> so it doesn't know that head is safe there
04:57:54 <knupfer> kaidelong: it can prove stuff only via induction if i'm not wrong
04:58:25 <knupfer> and doesn't realy understand/evaluate haskell functions
05:00:51 <knupfer> if you put alleq [] = True beforehand, it stops complaining
05:01:21 <kaidelong> @src all
05:01:21 <lambdabot> all p = and . map p
05:01:28 <knupfer> but  alleq xs = if null xs then True else all (head xs ==) xs
05:01:33 <kaidelong> @src and
05:01:33 <lambdabot> and  = foldr (&&) True
05:01:33 <knupfer> isn't fine to LH
05:01:41 <kaidelong> @src foldr
05:01:41 <lambdabot> foldr f z []     = z
05:01:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:01:44 <kaidelong> mm
05:01:52 <kaidelong> well, if it follows the definition to foldr, it could do the same thing
05:01:59 <kaidelong> but I guess it doesn't
05:01:59 <xyh> I have a package installed by cabal, 'cabal install <name>', now I wish to play with the git version of '<name>-git'. I build the Program in '<name>/.cabal-sandbox/bin', how should I uninstall the old one and use the new one ???
05:02:27 <kaidelong> the null xs case I understand better
05:02:38 <kaidelong> null isn't "obviously" something that tests if a list is empty
05:02:43 <kaidelong> pattern matching is
05:02:54 <knupfer> for xs == [] it's the same
05:02:57 <kaidelong> although
05:03:02 <kaidelong> null is a proposition
05:03:20 <kaidelong> so you'd think a refinement type system could potentially give it special treatment
05:03:41 <kaidelong> but I can understand that this would be an embellishment
05:03:46 <kaidelong> you'd need smarter whiteboxing
05:04:19 <nullx002> 'uncons' from Data.List gives me an error
05:04:28 <nullx002> not in scope
05:04:45 <xyh> cabal can not uninstall a package ?
05:04:53 <kaidelong> xyh: yes
05:05:01 <kaidelong> you have to wipe your entire local cabal store
05:05:13 <knupfer> kaidelong: I think your function isn't fine, because it contains undefined
05:05:35 <knupfer> it's like saying
05:05:38 <knupfer> > map undefined []
05:05:40 <nullx002> uncons [1..10] what should that return??
05:05:41 <lambdabot>  []
05:06:02 <kaidelong> knupfer: "contains undefined?"
05:06:07 <magneticduck> nullx002: import Data.List
05:06:09 <magneticduck> <_<
05:06:14 <nullx002> already imported
05:06:25 <magneticduck> and the type signature / name should make its function obvious
05:06:25 <knupfer> (head [] ==) is undefined
05:06:26 <nullx002> Data.List and Data.List.Split
05:06:36 <kaidelong> it's also not reachable from that function
05:06:44 <knupfer> it works only because it's not reachable
05:06:51 <nullx002> throws error not in scope magneticduck
05:07:00 <knupfer> like my map example
05:07:05 <kaidelong> right but undefineds that aren't reachable are okay
05:07:11 <magneticduck> fmap (uncurry (:)) . uncons <-> pure
05:07:13 <knupfer> perhaps not to LH
05:07:17 <magneticduck> nullx002: uh >_>
05:07:17 <kaidelong> that's why you can use the null type to do useful things
05:07:27 <magneticduck> nullx002: paste full code and full error
05:07:37 <kaidelong> well, not in haskell, but idris and agda you can
05:07:41 <kaidelong> their provers will be like
05:07:47 <kaidelong> "oh okay, I see this is unreachable"
05:07:55 <knupfer> ok, map undefined xs is fine to LH
05:08:02 <knupfer> hmm
05:08:05 <nullx002> code is nothng but uncons [1..10]
05:08:16 <kaidelong> there is actually one input where alleq does fail
05:08:19 <xyh> kaidelong: every time you dev a package, you just add its '.cabal-sandbox/bin' to your 'PATH' ??
05:08:21 <nullx002> error: Not in scope: `uncons'
05:08:22 <nullx002>     Perhaps you meant `union' (imported from Data.List)
05:08:29 <kaidelong> alleq . repeat == const _|_
05:08:53 <magneticduck> nullx002: is this in a code file or in ghci?
05:09:01 <kaidelong> xyh: if you want to go to that effort, I'd recommend you just use stack. What I did was manually install the built binaries to a folder on my path
05:09:03 <nullx002> ghci
05:09:31 <nullx002> but it should work like head, tail, init, last etc
05:09:52 <Axman6> so it should only work some of the time?
05:09:58 <magneticduck> nullx002: maybe you have an old library version
05:10:10 <magneticduck> ghc -v
05:10:16 <magneticduck> | grep base
05:10:17 <nullx002> i dont think so... i installed haskell and ghci a month ago
05:10:41 <Axman6> from where?
05:10:46 <Axman6> /how?
05:10:49 <nullx002> debian repo
05:10:51 <nullx002> Glasgow Haskell Compiler, Version 7.6.3, stage 2 booted by GHC version 7.6.3
05:10:57 <kaidelong> ouch
05:11:03 <knupfer> that's stone age
05:11:05 <nullx002> or manually may be i dont remember
05:11:11 <Axman6> that's about three years old or so
05:11:13 <Axman6> maybe 2
05:11:17 <Axman6> but very old
05:11:25 <nullx002> ok
05:11:35 <nullx002> so how should i upgrade?
05:11:39 <nullx002> manual install?
05:11:49 <kaidelong> I would recommend stack
05:11:58 <xyh> stack >
05:12:05 <xyh> * stack ?
05:12:12 <knupfer> to upgrade ghc, you could use the ppa:hvr/ghc
05:12:12 <nullx002> i know about that
05:12:15 <kaidelong> https://github.com/commercialhaskell/stack
05:12:16 <nullx002> it is on github i think
05:12:19 <bgamari> Does anyone know anything about this type? https://gist.github.com/bgamari/ce27adeb0dd0561c2b37
05:12:20 <knupfer> it works as well with debian
05:12:28 <xyh> kaidelong: thx
05:12:30 <bgamari> Does it have a name?
05:12:37 <nullx002> do i have to remove debian repos first?
05:13:10 <nullx002> i have installed haskell through debian repo too
05:13:19 <Yuu-chan> Eh. What a hurried age, where 2 years is very old
05:13:40 <liste> it's interesting times for Haskell
05:13:50 <nullx002> hum..
05:14:09 <nullx002> do i remove it all from my machine before manual reinstall? is it necessary?
05:14:13 <Yuu-chan> Btw, why some didn't recommend installing Haskell platform?
05:14:14 <knupfer> nullx002: no
05:14:38 <knupfer> it will install with qualified version names
05:14:53 <nullx002> any possible conflicts when i upgrade via apt-get?
05:14:59 <knupfer> in your /opt/var or something like that, so you have to put it afterwards into your path
05:15:02 <knupfer> no
05:15:03 <nullx002> ok
05:15:06 <magneticduck> you know, you should all just be using nix
05:15:07 <nullx002> thanks all
05:15:08 <magneticduck> because nix is badass
05:15:12 <knupfer> yep
05:15:13 <nullx002> will install it and check it
05:15:18 <knupfer> I use as well nix
05:15:24 <nullx002> be back in a min
05:15:37 <knupfer> Such a pitty that it doesn't use haskell as language.
05:15:39 <kaidelong> nix is problematic outside of nixos
05:15:47 <kaidelong> try building a haskell openGL lib with nix
05:15:55 <kaidelong> on ubuntu or some non-nixos distro
05:16:03 <kaidelong> it doesn't know what the hell to do about linking it to a driver
05:16:41 <knupfer> It could use shake as build system for the entire os
05:16:48 <magneticduck> knupfer: eh, there are good reasons
05:17:24 <knupfer> magneticduck: Because of embedded concerns?
05:17:59 <knupfer> Because of portability?
05:18:08 <TMM> I was wondering, is there a type of software that Haskell is particularly well suited for writing?
05:18:14 <magneticduck> honestly I have no complaints about the nix language, it's flexible enough to make things easy and functional enough to make things doable
05:18:17 <magneticduck> now, if they used haskell
05:18:17 <kaidelong> TMM: compilers
05:18:37 <TMM> That's a bit of a broken, sentence, sorry.
05:18:43 <TMM> kaidelong, oh, interesting
05:18:44 <knupfer> TMM: Anything parallel or concurrent that isn't graphics.
05:19:07 <magneticduck> you'd have to port a compiler of some sort along with the language, you'd have to make a little additional DSL to make nix-related things easy
05:19:11 <kaidelong> being good at writing compilers is actually a paradigm in and of itself
05:19:31 <kaidelong> "language-oriented"
05:19:38 <kaidelong> the other MLs and the lisps also do this
05:19:38 <tdammers> "DSL-oriented"
05:20:08 <tdammers> 1. invent a minilanguage that covers your problem domain; 2. solve problem in minilanguage
05:20:09 <kaidelong> also REBOL, Red, Nimrod, and arguably C++
05:20:14 <TMM> hmm, interesting 
05:20:27 <knupfer> TMM: papers, thats not really software, but if you reverse your sentence...
05:20:32 <tdammers> well, people do it in all programming languages, but it's somewhat more explicit and conscious in Haskell
05:20:38 <magneticduck> or write an "embedded DSL" inside haskell and use that
05:21:06 <magneticduck> like those companies that use haskell for describing contracts and legal stuff or something
05:21:11 <knupfer> magneticduck: I wouldn't oppose a nix-dsl written in haskell.
05:21:12 * magneticduck can totally find citation
05:21:17 <tdammers> from("table")->select(["username", "id"])->whereEquals("username", username)->limit(1); // is also sort of a minilanguage
05:22:11 <knupfer> now we need a totality checker
05:22:47 * hackagebot smoothie 0.4.2.1 - Smooth curves via several interpolation modes  https://hackage.haskell.org/package/smoothie-0.4.2.1 (DimitriSabadie)
05:22:51 <knupfer> TMM: parsers are as well premium
05:22:53 <TMM> I'm primarily a C++ programmer now. I use it for almost everything right now. I've never really be able to wrap my head around modeling problems in recursions but I thought I'd give it another go. I need some kind of project to try to complete in Haskell though. Maybe I'll write a toy compiler for something.
05:23:23 <liste> @where write yourself a scheme in 48 hours
05:23:23 <lambdabot> I know nothing about write.
05:23:25 <tdammers> @where scheme
05:23:25 <lambdabot> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
05:23:29 <kaidelong> C++ and haskell are pretty similar
05:23:30 <tdammers> ^ TMM
05:23:53 <TMM> tdammers, That's a good idea, thanks.
05:24:03 <knupfer> TMM: You don't need necessarily recursions, you can use maps and folds
05:25:18 <quchen2> C++ and Haskell are similar, except for the evaluation model, the type system, the general design philosophy, their capabilities to abstract things, and a few other details.
05:25:38 <magneticduck> quchen2: but they both have printf
05:25:39 <tdammers> yntax
05:25:42 <kaidelong> quchen: "their capabilities to abstract things?"
05:25:43 <tdammers> *syntax
05:25:43 <magneticduck> they're practically the same
05:26:02 <kaidelong> that is the important point where CPP and haskell converge
05:26:04 <TMM> knupfer, I'm sure there are different ways. The main issue for me is just that I can kind of automatically 'see' the solution using the paradigm I'm used to. The unlearning/relearing cycle hasn't worked well for me so far :)
05:26:06 <kaidelong> I mean
05:26:08 <augur> edwardk: i wrote that blogpost. its mostly about the pattern matching aspect, but the discussion at the end talks about the weird categorial connection briefly   http://languagengine.co/blog/compiling-pattern-matching/
05:26:11 <kaidelong> compared to most other languages
05:26:30 <augur> edwardk: its missing some pictures still, but they're not essential
05:26:30 <kaidelong> template templates can model things that most other languages are missing that haskell does have
05:26:42 <TMM> knupfer, I'm actually trying to design a very domain specific language now and I thought I could do with some horizon expansion. 
05:26:47 <hodapp> "can model" is a gigantic trapdoor
05:26:48 <whald> hi! can s.o. point me to some public project that managed to bundle a haskell backend and a elm frontend in one cabal (or stack, don't care) package? so a "cabal build" or "cabal install" also fires up the elm compiler and does, well, "the right thing"?
05:26:59 <kaidelong> right, writing haskell in C++ is very ugly
05:27:02 <magneticduck> hodapp: with a big turing tarpit under it
05:27:02 <kaidelong> but it is actually possible
05:27:08 <hodapp> "possible"
05:27:14 <kaidelong> in something like java, you just don't have the expressive power
05:27:27 <kaidelong> also there are many similarities too
05:27:28 <hodapp> some very ugly projects I've seen online beg to differ
05:27:54 <kaidelong> haskell generally allows you to shoot yourself in the foot if you want
05:27:58 <kaidelong> like C++
05:28:14 <quchen2> Haskell makes it hard to shoot you in the foot if you don't want to do that.
05:28:25 <hodapp> "with enough work, they can express the same thing" isn't really a very strong assertion of similarity
05:28:44 <kaidelong> in practice you also don't have memory management because you work with raw C libraries rather than fancy bindings
05:28:46 <kaidelong> again like C++
05:29:01 <tdammers> if you write good code, it'll probably be quite similar whether you use C++ or Haskell; but if you don't, the C++ code will be super ugly, and the Haskell code won't compile
05:29:35 <tdammers> other than that; I don't find them super similar
05:29:38 <kaidelong> also it takes long to compile and has rather awful tooling and error reporting
05:29:41 <hodapp> that's a rather big "if"
05:29:42 <tdammers> just more similar than you'd expect at first sight
05:30:13 <hodapp> when you have different abstractions available, the code tends to look different
05:30:16 <kaidelong> it also falls into roughly the same application domains
05:30:24 <kaidelong> "performance would be nice but it is not critical"
05:31:27 <tdammers> "performance is important", as opposed to "performance is key" (C, ASM, ...) and "performance is irrelevant" (Python, Ruby, Lisp, ...)
05:31:53 <knupfer> you could pack everything into IO and write c++ in an haskell dsl
05:32:00 <kaidelong> I actually don't think it's moot or dumb to compare C++ to haskell
05:32:12 <tdammers> although with C++ you can go as deep as you need to in order to get on par with C
05:32:22 <kaidelong> because many C++ projects could probably be rewritten in Haskell without too much pain
05:32:26 <kaidelong> and vice versa
05:32:39 <kaidelong> tdammers: this is true about haskell too, although not well documented
05:32:40 <knupfer> in haskell you've got the FFI
05:32:51 <hodapp> kaidelong: the lack of simple things like algebraic data types tends to contribute to that pain
05:32:54 <tdammers> FFI isn't as seamless though
05:33:22 <hodapp> tdammers: C integration in C++ sure isn't seamless either, just sometimes easier...
05:33:31 <kaidelong> hodapp: closed ADTs have a useful dual in open dynamic dispatch that is arguably better
05:33:35 <kaidelong> it comes at a runtime cost, though
05:33:53 <tdammers> in C++, you can write C-style C++, and it performs about the same as the equivalent C would
05:34:06 <tdammers> malloc is still there for you if you want to
05:34:13 <kaidelong> haskell has tools for inline C and inline ASM
05:34:19 <tdammers> point
05:34:20 <kaidelong> so I'm not sure if this is terribly worse in haskell
05:34:26 <hodapp> kaidelong: yes, emphasis on "arguably".
05:34:53 <hodapp> kaidelong: when I wrote C++ professionally, there was certainly a lot of argument about why the language was obviously superior for every last thing.
05:34:54 <knupfer> haskell is only by a constant factor slower than C, but because of the better optimizability due to pureness, it's just a matter of time that it's the same speed
05:35:08 <cow-orker> Anyone having success building HDBC-mysql with 7.10? I have fixed the setup file and added "extra-libraries: mysqlclient" as described in the tickets, but still there is no reference to libmysqlclient.so and ghci complains "can't load .so/.DLL for: ... libHSHDBC-mysql-0.6.6.1-LUaapFuO0de0Kdx7Qqoiem-ghc7.10.2.so ... undefined symbol: mysql_close
05:35:10 <kaidelong> I don't know about that
05:35:33 <hodapp> kaidelong: and then I gave up trying to explain a bunch of Haskell abstractions to people who only wanted to see C++.
05:35:41 <kaidelong> knupfer: actually, I think that's wrong
05:35:45 <ggole> Representation matters too much for performance for that to be likely
05:36:12 <knupfer> kaidelong: why?
05:36:18 <kaidelong> you could use that argument to say that it's easier to make haskell code run faster than C code in some cases but not to argue that haskell could match optomized C because mutability
05:36:34 <kaidelong> those optomizations only help in cases where programmers write code that would otherwise be inefficient
05:36:45 <kaidelong> not with the constant factors of the runtime system and such
05:36:55 <ggole> Although it is inconvenient, we live with architectures where (uncached) data-dependent loads are horribly expensive, and that heavily favours flat C-like layout
05:37:09 <merijn> @hoogle (a -> m Bool) -> [a] -> m Bool
05:37:10 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
05:37:10 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
05:37:10 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
05:37:15 <fractalsea> Is there a way I can add a context to LoggingT from monad-logger? i.e. I can wrap code in LoggingT with something like `withContext “ctx” thecode` and it will append “ctx” to the start of all log messages?
05:37:40 <arw_> knupfer: counterexample: c vs. fortran, c is always just about to get as fast as fortran... until the compiler suspects a whiff of aliasing or some other c-specific optimization problem, then its slower again.
05:38:02 <kaidelong> this does happen with haskell
05:38:02 <ggole> Even the JVM people have given up trying to make it happen automatically and are designing ways for programmers to have the control over layout that you get for free with C
05:38:14 <kaidelong> performance of haskell programs can be destroyed by subtle changes in code
05:38:25 <kaidelong> this isn't as big a problem as bloggers make it out to be and isn't exclusive to haskell
05:38:29 <valdyn> and in C
05:38:36 <kaidelong> but it does make the case that you can't hope for a clever enough compiler
05:39:05 <kaidelong> so improving haskell's support for low level programming is just as valid as trying to improve its optomizer or teach better practice
05:39:47 <kaidelong> and that allowing programmer control is a good thing (you can always just implement the optomization anyway, and then blame the programmer when the optomizations break what they were trying to do with their rewrite rules and specializations)
05:40:59 <knupfer> kaidelong: I don't want to be pedantic, but it's "optimization".
05:41:06 <kaidelong> I think it also means there is a good case for the C++ philosophy of performance costs needing to be associated with syntactic costs
05:41:16 <kaidelong> but on this the C++ folks have already lost
05:41:34 <kaidelong> so the continued emphasis on that might not be helpful anymore
05:43:03 <knupfer> Is there some performance comparision which is not in the shootout?  Like a more largish piece of code.
05:43:37 <kaidelong> GNOME 3 vs KDE 5 could be seen as a comparison between javascript and C++
05:43:46 <kaidelong> they do very similar things
05:43:59 <knupfer> :) I wanted to say ghc vs gcc C++
05:44:17 <kaidelong> both of those are pretty slow but they are solving hard problems
05:44:21 <kaidelong> undecidable, actually
05:44:50 <quicksilver> is there a version of 'guard' for Either which lets you choose the message if the guard fails?
05:44:57 <quicksilver> or something which subsumes that
05:45:13 <knupfer> Left "abc"
05:45:35 <quicksilver> :t \b err -> if not b then Left err else return ()
05:45:37 <lambdabot> Bool -> a -> Either a ()
05:47:09 <kaidelong> nothing in Data.Either or Control.Monad.Except that I can see quicksilver 
05:47:23 <knupfer> quicksilver: unless b $ Left "abc"
05:47:37 <knupfer> from Control.Monad
05:48:17 <quicksilver> yes that's better than nothing
05:48:18 <quicksilver> thanks knupfer 
05:48:31 <xyh> 'stack' also use '.cabal' files >
05:48:34 <xyh> * 'stack' also use '.cabal' files ?
05:48:42 <knupfer> or if you want to write more positive, use when
05:48:55 <kaidelong> xyh: yes, stack does use a .cabal file
05:49:06 <knupfer> you're welcome
05:49:40 <kaidelong> but you should edit the stack.yaml
05:49:51 <kaidelong> I'm pretty sure the project.cabal file is generated from that
05:50:57 <xyh> stack 'Fetching package index ...' like forever long >_<
05:50:59 <kaidelong> oh, doesn't look like it
05:51:09 <kaidelong> you can edit the project.cabal file if you want
05:52:11 <kaidelong> the stack.yaml is used for things like extending the library of installed packages cabal will search through
05:52:15 <zaquest> xyh, if you just want to execute binary from sandbox's bin dir you can use `cabal exec`
05:52:39 <zaquest> xyh, with stack you'll need to `stack exec` too
05:57:29 <zaquest> xyh, also i have `.cabal-sandbox/bin` in my path, so when i'm in any cabal sandbox's root dir i can execute program's from the sandbox directly w/o adding path for every separate sandbox
05:58:46 <xyh> I will try to add each `.cabal-sandbox/bin` in my path too
06:00:27 <zaquest> xyh, not each .cabal-sandbox/bin, but only one relative path like `export PATH=.cabal-sandbox/bin:$PATH`
06:01:34 <xyh> zaquest: oh! I ll try this. thx :)
06:01:38 <Jeanne-Kamikaze> has anyone come across runtime linker errors like these using gloss on Windows? http://i58.tinypic.com/2iloc2q.png
06:02:00 <labbe> @pl \fa fb x -> (fa x) , (fb x)
06:02:00 <lambdabot> (line 1, column 20):
06:02:00 <lambdabot> unexpected ','
06:02:00 <lambdabot> expecting variable, "(", operator or end of input
06:02:12 <labbe> @pl \fa fb x -> ((fa x) , (fb x))
06:02:12 <lambdabot> liftM2 (,)
06:02:48 * hackagebot moesocks 1.0.0.20 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-1.0.0.20 (JinjingWang)
06:07:37 <kaidelong> Jeanne-Kamikaze: never seen that before
06:07:40 <kaidelong> might be a new bug
06:07:48 * hackagebot asn1-types 0.3.1 - ASN.1 types  https://hackage.haskell.org/package/asn1-types-0.3.1 (VincentHanquez)
06:07:57 <Jeanne-Kamikaze> I installed the GLUT package by linking against freeglut dynamic
06:08:11 <Jeanne-Kamikaze> a mingw build of freeglut, I don't know if that might be the issue
06:08:48 <kaidelong> (tinypic was so slow that I accidentally clicked on an ad, sad)
06:09:02 <kaidelong> it might be
06:09:13 <kaidelong> are you using haskell-platform?
06:09:17 <Jeanne-Kamikaze> oh, seems to be reported already: https://ghc.haskell.org/trac/ghc/ticket/9297
06:09:21 <kaidelong> that comes with the GLUT and OpenGL libs
06:09:23 <Jeanne-Kamikaze> no, latest ghc and cabal-install
06:09:49 <geekosaur> I think there are known windows linking bugs. yeh
06:10:07 <Jeanne-Kamikaze> would getting the glut from the haskell platform fix it ?
06:10:20 <Jeanne-Kamikaze> I don't even know why gloss depends on glut
06:12:07 <geekosaur> "Gloss uses OpenGL under the hood, but you won't need to worry about any of that."
06:12:11 <kaidelong> gloss needs to draw a window somehow
06:12:24 <geekosaur> I have certaionly heard of people using opengl for 2D just because it provides a consistent and relatively nice API
06:12:29 <kaidelong> GLUT is one of the only cross platform ways to do that
06:12:41 <Jeanne-Kamikaze> yeah but GLUT is a horrible choice, there are a million other windowing libraries
06:12:49 * hackagebot asn1-encoding 0.9.3 - ASN1 data reader and writer in RAW, BER and DER forms  https://hackage.haskell.org/package/asn1-encoding-0.9.3 (VincentHanquez)
06:12:50 <geekosaur> ...and more portable than the bewildering array of platform specific 2D graphics libraries
06:12:55 <kaidelong> less sure on that "million other" part
06:13:07 <kaidelong> and I doubt they're smaller/more portable than GLU
06:13:10 <kaidelong> GLUT*
06:13:43 <kaidelong> or appropriate for what gloss needs (a GL draw surface)
06:14:57 <Jeanne-Kamikaze> heck, it even has GLFW-b as a dependency
06:15:13 <Jeanne-Kamikaze> oh right, you can choose between the two :D
06:17:49 * hackagebot asn1-parse 0.9.2 - Simple monadic parser for ASN1 stream types.  https://hackage.haskell.org/package/asn1-parse-0.9.2 (VincentHanquez)
06:22:50 * hackagebot shadowsocks 1.20150921 - A fast SOCKS5 proxy that help you get through firewalls  https://hackage.haskell.org/package/shadowsocks-1.20150921 (rnons)
06:27:50 * hackagebot asn1-parse 0.9.3 - Simple monadic parser for ASN1 stream types.  https://hackage.haskell.org/package/asn1-parse-0.9.3 (VincentHanquez)
06:44:58 <fractalsea> Is there a reason why LoggingT isn’t an instance of MonadFix? http://haddock.stackage.org/lts-3.6/monad-logger-0.3.13.2/Control-Monad-Logger.html
06:52:29 <merijn> blah
06:52:46 <merijn> How do I check an expression does *not* match a certain constructor?
06:53:00 <kaidelong> fractalsea: mm, so you can use previous things logged to influence what will be logged next?
06:53:03 <bartavelle> merijn, with a prism !
06:53:12 <bartavelle> hasn't _Constructor foo
06:53:29 <TMM> I've been following along with "Write_Yourself_a_Scheme_in_48_Hours" I'm at the 'parsing' page now, but it's still not entirely clear to me what a 'monad' is :-/ I imagine that this is a problem.
06:53:51 <merijn> bartavelle: Except that I don't have any lenses for this stuff
06:53:59 <bergmark> TMM: in my experience all design patterns are weird until you figure out you need them
06:54:00 <erikD_> hi, does anybody here have any experience with the different FRP libraries out there?
06:54:42 <kaidelong> erikD_: if you your underlying library you are wrapping uses push-based control flow, don't use netwire
06:54:46 <TMM> bergmark, oh, sure. I wasn't complaining about anything. :) I'm just worried I'm not getting something fundamental
06:54:48 <fractalsea> kaidelong, To be honest I don’t really understand it yet. I have a codebase that I am adding a logger to. It currently includes mdo blocks, so when I add the LoggingT transformer to the stack, the compiler complains because LoggingT is not an instance of MonadFix
06:54:50 <bartavelle> merijn, then maybe foo bar (Just Constructor <- expression) ?
06:55:01 <bartavelle> errr
06:55:06 <bartavelle> Constructor <- Just expression
06:55:16 <merijn> bartavelle: That does the opposite of what I want :)
06:55:20 <erikD_> I’m trying to figure out which one suits me the most, I found frp-zoo on github, but a lot of them seem a bit samey..
06:55:28 <bartavelle> merijn, well you have the two cases in the maybe ?
06:55:43 <bergmark> TMM: if you can write code that type checks, don't worry about it for now
06:56:02 <merijn> bartavelle: The problem is that using a positive (i.e. it matches the constructor) way means I have to write out a lot more cases than if I can just match the negative
06:56:16 <tero-> should I put this to hackage https://github.com/tlaitinen/redis-job-queue or is it too simple to put there?
06:56:24 <bartavelle> TMM, don't worry too much about it, I wrote the parser of my first large haskell program with no clue about what a monad was, just bruteforcing until it compiled
06:56:55 <kaidelong> there are plenty of trivial packages on hackage, and many of them are no longer maintained, so you wouldn't be a standout
06:57:05 <kaidelong> not sure if there's some standard saying "library has to be X size"
06:57:54 <merijn> bartavelle: i.e. I want to match "if it doesn't match Foo, do Y, else X". But writing out the reverse "if it matches Foo do X, else do Y" requires me to write out like 10 cases :\
06:57:57 <bergmark> hehe i did the same as bartavelle, then i looked at how ugly it got and i tried to force a monad in there, then i figured out everything was already in the transformers package
06:58:27 <tdammers> TMM: common problem. Once you realize that "what a monad is" isn't even super exciting, your desire to "understand" monads will go away
06:58:27 <bartavelle> bergmark, I actually used parsec
06:58:33 <kaidelong> fractalsea: I don't really see why LoggerT should not support it
06:58:35 <bartavelle> bergmark, but yes, it was terrible
06:58:54 <tdammers> TMM: a monad is really just another typeclass, and its methods and laws pretty much describe all there is to it
06:58:56 <kaidelong> fractalsea: maybe go add that instance and put a pull request up
06:59:14 <bergmark> tero-: there's absolutely no quality requirements for adding a package, if you are interested in how to maintain haskell packages there's only one way to learn
06:59:17 <fractalsea> kaidelong, OK that’s good. I guess I will just try and come up with my own instance (with unwrapping and wrapping the base monad)
06:59:22 <bartavelle> merijn, I don't follow, your problem is not writing that helper function or something else entirely ?
06:59:29 <kaidelong> by the looks of it, the monadfix instance of LoggerT should really just be the same as some theoretical "IdentityT"
06:59:41 <merijn> bartavelle: Oh, I didn't understand what you meant
06:59:48 <tdammers> TMM: at some point, you'll develop an intuition, but until that happens, just learning some tricks and patterns and applying them successfully isn't half bad
06:59:52 <fractalsea> Great, thanks! I will look into that
07:00:08 <kaidelong> the underlying monad will have to also implement MonadFix
07:01:57 <bartavelle> merijn, I just pointed out the "failing pattern match" trick with the maybe monad that would give you your result without having to write a helper function that would tell you if you don't match a given constructor
07:02:12 <bartavelle> but I am not sure that was your problem at all :)
07:02:36 <merijn> bartavelle: The failing pattern match trick does the opposite of what I wanted, was what I was saying
07:02:42 <tero-> bergmark: maybe search engines find github repos well enough?
07:02:51 <merijn> bartavelle: But for some stupid reason writing a trivial helper returning a boolean didn't occur to me
07:03:05 <tero-> probably no one wants to have yet another dependency to a micro package
07:03:34 <merijn> Yay! My evaluation function is no longer "to good" at reaching normal forms ;)
07:03:42 <bergmark> tero-: i think this is the smallest library we depend on at work :) http://hackage.haskell.org/package/uuid-aeson-0.1.0.0/docs/src/Data-UUID-Aeson.html
07:04:38 <tero-> bergmark: heh, that's compact
07:04:40 <bergmark> tero-: but is there any downside in uploading it to hackage you think?
07:05:11 <tero-> bergmark: feeling guilty for spamming the hackage database?
07:07:13 <bergmark> meh :-) i've uploaded things just for fun (almost)
07:07:32 <hodapp> one of these days I need to get my Ion package into Hackage
07:07:41 <hodapp> but I need an Ivory release to happen first
07:08:44 <benzrf> what is Ion, hodapp
07:09:11 <bergmark> tero-: on the flip side, if someone needs what you've done it's much easier for them to use it if it's on hackage
07:09:12 <hodapp> benzrf: well, it started out as a version of Atom that targeted Ivory instead of directly using C code
07:09:13 * ion
07:09:22 * hodapp looks at ion
07:09:36 <benzrf> hodapp: atom?
07:09:40 <benzrf> like. the webkit emacs?
07:09:50 <TMM> tdammers, thanks
07:09:54 <ion> A Haskell EDSL for programming for embedded things.
07:09:56 <hodapp> benzrf: https://hackage.haskell.org/package/atom
07:10:02 <benzrf> o
07:10:50 <hodapp> benzrf: but right now, it is a library I'm using at my job for (1) doing realtime scheduling of tasks in generated C code and also for (2) more idiomatic chaining of async stuff in generated C using a form of continuation-passing  style
07:12:29 <tdammers> hodapp: somehow, I think this kind of thing is something I've been meaning to write but never did, taken to the extreme
07:12:43 <tdammers> hodapp: my plan was to make a preprocessor that extends C with lambdas and closures
07:13:34 <hodapp> benzrf: so - it lets me build Haskell values which specify what should run in the generated C code and at what schedule and under what conditions, it lets me build Haskell values which specify how a bunch of C calls are chained together and pass their results in CPS
07:14:19 <hodapp> benzrf: and both of those interface directly to Ivory, and because they are Haskell values I can parametrize and compose them, and easily make them functions that express some pattern I would otherwise be doing repeatedly by hand
07:16:25 <hodapp> tdammers: http://lpaste.net/8667125741403504640 and https://github.com/HaskellEmbedded/ion/blob/ionseq/src/Ivory/Language/Ion/Example.hs#L39 - that's an example I added recently though it needs some improvement to make sense
07:17:31 <hodapp> tdammers: now, Ivory sort of kind of gets you lambdas that turn to C
07:17:52 * hackagebot redis-job-queue 0.1.0 - Simple priority job queue backed by Redis.  https://hackage.haskell.org/package/redis-job-queue-0.1.0 (TeroLaitinen)
07:17:54 * hackagebot country-codes 0.1.3 - ISO 3166 country codes and i18n names.  https://hackage.haskell.org/package/country-codes-0.1.3 (FelipeLessa)
07:18:07 <hodapp> tdammers: look at line 75 and that's basically Ivory code where you pass a lambda and out comes a C function
07:18:59 <merijn> blah
07:19:12 <merijn> I hate it when I end up with four nested cases marching of the right of my screen...
07:19:32 <tero-> bigger screen helps
07:20:53 <merijn> I have a big screen, but 3 terminal columns
07:22:52 * hackagebot fb 1.0.12 - Bindings to Facebook's API.  https://hackage.haskell.org/package/fb-1.0.12 (FelipeLessa)
07:22:54 * hackagebot mangopay 1.11.5 - Bindings to the MangoPay API  https://hackage.haskell.org/package/mangopay-1.11.5 (FelipeLessa)
07:22:56 * hackagebot yesod-mangopay 1.11.5 - Yesod library for MangoPay API access  https://hackage.haskell.org/package/yesod-mangopay-1.11.5 (FelipeLessa)
07:22:58 <delYsid> Whats the best way to combine two different Eithers?  I am getting Either ParseError a from parsec, and I'd like to do my own error reporting in the post-processing.  How do I combine these so that a compound function can return either parse or semantic errors?
07:24:53 <delYsid> Or can someone recommend a codebase that does something similar I could have a look at?
07:26:46 <fvgvxmpv1> I don´t think you´ll get around nesting 'Either's
07:26:53 <fvgvxmpv1> in one way or another
07:27:40 <fvgvxmpv1> or just build your own error type: data Error = Syntax ParseError | Semantic
07:28:27 <exio4> you can them lmap Syntax <expr> or so, for `converting` the ParseError into the "Error" you want
07:29:47 <fvgvxmpv1> exio4, where do you get lmap from? (excepting, of course: lmap f = either f id)
07:30:45 <fvgvxmpv1> (no, it isn´t)
07:31:27 <exio4> oh, it's `first` in the Bifunctor typeclass, I was confusing with another method
07:31:36 <exio4> @type Data.Bifunctor.first
07:31:37 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
07:37:32 <l0p3n> Trying to call a function withhttp://lpaste.net/141415
07:37:42 <nitrix> Hi. Can someone help be build simplessh on Windows? I understand absolutly nothing to the mysys/mingw shabang.
07:38:00 <fvgvxmpv1> l0p3n, why the '_'?
07:39:06 <fvgvxmpv1> l0p3n, also: have a look at (>>)
07:39:09 <nitrix> l0p3n: Your function is exactly sequence_
07:39:20 <nitrix> :t sequence_
07:39:22 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
07:39:44 <nitrix> Where t is [] and m is IO.
07:39:52 <fvgvxmpv1> nitrix, not "exactly"
07:40:07 <nitrix> fvgvxmpv1: What is different?
07:40:20 <l0p3n> Trying to call the function with, instructions [show 'a', show 'b'], but it doesn't work.
07:40:21 <fvgvxmpv1> sequence_ is more generic
07:40:47 <fvgvxmpv1> l0p3n, drop the '_' at the end of instructions in lines 2 and 3
07:40:49 <nitrix> He could sill use sequence_
07:40:50 <ski> l0p3n : did you mean to use `print' instead of `show' ?
07:41:17 <ski> @type [show 'a',show 'b']
07:41:18 <lambdabot> [String]
07:41:26 <ski> `String' is not `IO ()'
07:41:45 <l0p3n> ski: Of course, my mistake, thank you!!!
07:41:49 <ski> np
07:43:32 <delYsid> Ah, thats bimap leftEx id.  Nice trick!
07:46:49 <quchen2> delYsid: bimap f id = first f
07:47:26 <pavonia> Can anyone tell me when attoparsec's (<?>) is actually used? 'parseOnly (string "foo") "bar"' and 'parseOnly (string "foo" <?> "foo") "bar"' both yield an "Failed reading: takeWith" error for me
07:48:48 <geekosaur> that looks more like an internal logic error than a parse error...
07:49:50 <geekosaur> I haven't worked with attoparsec so I can't realy say any more. but attoparsec is known to have poor error reporting in general
07:51:47 <pavonia> Well, I can't find any parser that uses the annotation in the error message, so I'm curious what it's actually used for
07:53:16 <srhb> I would expect to be able to use it just as you did.
07:53:56 <geekosaur> it's not used by a parser. if it gets an actual parse error (as opposed to some kind of read error which is what it looks like you are getting; maybe it's confused because you don't parse end-of-data?) then it should report that it was expecting the string named by <?> instead of a list of the tokens it was expecting to see
07:55:28 <geekosaur> the error you are getting is at a layer *below* parsing
07:55:40 <geekosaur> so it never considers using the string
07:55:46 <pavonia> What is a parse error then?
07:56:34 <srhb> parseOnly (string "foo" <?> "foo") "bar" gives me: Left "foo: string"
07:56:36 <srhb> Seems more sane
07:56:37 <geekosaur> you have a read error. a parse error is "I recognized a token, but it's not the one I wanted"
07:56:49 <geekosaur> you are getting "I had an error while trying to read something I can turn into a token"
07:57:43 <geekosaur> and my best guess is that parseOnly expects you to include something that matches end-of-input
07:57:59 <geekosaur> but you didn't, so it threw a low level error when it hit the end of your input string
07:58:09 <catsup> i downloaded the binary executable for 'stack' for macosx.  when i run it it, it segfaults.  i tried the past three versions, they all do the same thing.  what could be wrong?  how do i debug this?
07:58:19 <srhb> That doesn't seem right.
07:58:20 <geekosaur> (parsec does this also but at least gives you a hint that this is the problem; in general parsec's errors are much better than attoparsec's)
07:58:49 * hackagebot clash-prelude 0.9.3 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.9.3 (ChristiaanBaaij)
07:59:09 <pavonia> geekosaur: Sorry, I don't understand the difference. What is a token in that context?
07:59:25 <pavonia> Also, parseOnly ((string "foo" <* endOfInput) <?> "foo") "bar" gives the same error for me
07:59:32 <srhb> pavonia: Did you really give us your exact test cases? :) Your example Works For Me.
08:00:18 <pavonia> srhb: Yes. I expect it's because I'm using an older version then
08:00:50 <srhb> Ok.
08:02:14 <pavonia> srhb: In your example, is the "foo" in the output the "foo" from the string function or that from the (<?>) function?
08:02:35 <srhb> That from the <?>
08:02:48 <pavonia> Ah, okay
08:03:01 <srhb> parseOnly (string "foo" <?> "quux") "bar" = Left "quux: string"
08:03:03 <putis> Hi! I am wondering which string concatenation method is better: using (++) or (<>) operator
08:03:14 <srhb> putis: For String, they are identical.
08:04:12 <geekosaur> putis: in general if I know I am working with String I will use (++), because (<>) tells me to look for something more general than String being involved
08:04:18 <putis> srhb: there are no 'best practices' in that domain
08:05:08 <putis> ok, thanks
08:05:31 <srhb> putis: If you ever choose to alter your string type to something else, using (<>) will make you have to change less code. That may or may not be good.
08:06:00 <tdammers> putis: my rule of thumb is that if my values are conceptually lists of characters, I'll use ++, but if they are conceptually blobs of text, I'll use <>
08:06:31 <tdammers> the reason being that in the latter case, it's very likely that I will be switching to Data.Text sooner rather than later, and <> will just keep working
08:06:42 <putis> tdammers: good point
08:06:47 <tdammers> OTOH, <> also works on lists, so I guess my point is moot
08:07:13 <tdammers> but I think it's nice to use ++ when I want to somehow signal that the listness of my strings is relevant
08:09:06 <knupfer> Is there something like stylish-haskell but more aggressive?
08:09:26 <srhb> knupfer: #haskell ? :-)
08:09:31 <knupfer> lol
08:09:59 <knupfer> Ideally, I want something that produces unique output from identical programs.
08:10:18 <knupfer> So that I haven't to worry in any sense about code cosmetics.
08:10:28 <srhb> I think you mean identical for identical. But no, I don't know of any.
08:11:36 <knupfer> Perhaps parsing with haskell-src-exts and prettyprinting afterwards, albeit I've got another definition of pretty.
08:12:19 <geekosaur> I think the general case of that is intractible
08:12:54 <geekosaur> although if all you mean is formatting then I think there's some reformatters somewhere on hackage
08:13:29 <knupfer> The idea is to enforce programatically a unified coding style across a team.
08:14:28 <geekosaur> http://hackage.haskell.org/package/hindent is what I was thinking of
08:14:35 <geekosaur> dunno how maintained it is
08:15:38 <Sindriava> How sane is having a typeclass method that doesn't depend on the type?
08:15:56 <Sindriava> e.g. class Foo a where method :: Bar
08:17:37 <Sindriava> Oh, apparently, it's not even possible
08:17:51 <geekosaur> not sane at all, as you found
08:17:57 <Sindriava> yah
08:18:04 <Sindriava> That's unfortunate.
08:18:15 <Sindriava> Is there a way to add typeclass properties to data types then?
08:18:32 <Sindriava> e.g. I have a data type Player, and a class Controllable
08:18:49 <geekosaur> I have the feeling you don't understand what typeclasses are about --- or possibly that you do but have decided you must force them to be something else
08:18:59 <geekosaur> this will end in tears either way
08:19:03 <Sindriava> geekosaur: Well, the latter case mostly
08:19:08 <Sindriava> and the instance of Controllable should define a Keymap :: [Mapping]
08:19:27 <geekosaur> don't bother trying, really
08:19:27 <Sindriava> Oh shit, I'm dumb
08:19:32 <Sindriava> I don't need that at all
08:20:02 <Sindriava> With typeclasses, what the update method does can depend on the type directly, what I was doing was adding an unnecessary level of abstraction
08:20:06 <Sindriava> derrrrrp
08:20:10 <Sindriava> geekosaur: Thanks though!
08:22:13 <nshepperd_> it is sort of possible to do this ("this" = typeclass entries that depend on the type but not any value)
08:22:53 <nshepperd_> class Foo a where method :: proxy a -> Bar
08:23:15 <nshepperd_> that makes the ambiguity at the call site go away
08:23:57 <nshepperd_> but the fiddlyness of having to use Proxys means I'd only do this is if absolutely nothing else would work
08:24:22 <nshepperd_> just by the way, I guess
08:27:18 <dstromberg> Hi folks.  I'm trying to install Safe, but I'm a total newb.  I seem to be getting Safe-1.0, but I want the latest: 0.3.9.   I tried to use the cabal install that comes with Linux Mint, but that gave me 1.0 by default.   I also tried hardcoding the version with "cabal install Safe-0.3.9", but that was "rejected".  Does anyone know what command I need to use to get the latest version of Safe?  BTW, I tried a "cabal u
08:27:19 <dstromberg> pdate", and that ran without an error message, but I still get Safe-0.1.
08:28:31 <dstromberg> Oops s/1\.0/0.1/
08:28:41 <nshepperd_> dstromberg: you want 'safe' (lowercase)
08:29:12 <dstromberg> That worked.  Thanks nshepperd_!
08:30:47 <geekosaur> yeh. package names are case dependent andf the very first version was released as "Safe" and then deprecated with later verisons calling themselves "safe"
08:31:33 * nshepperd_ finds this a little bit disturbing really
08:32:42 <Sindriava> @pl foldr (>>)
08:32:42 <lambdabot> foldr (>>)
08:34:09 <geekosaur> haskell does the same thing with module names (to the annoyance of OS X and Windows users)
08:36:26 <jophish_> What's the name of our solar system?
08:36:31 <zipper> Any way to force a rebuild of a template haskell file?
08:36:31 <jophish_> The Sol System?
08:36:51 <Shockk> jophish_: I think so
08:37:03 <Shockk> well, it's the name of our sdun
08:37:03 <Shockk> sun*
08:37:08 <jophish_> ah, some people say "Solar System" for ours specifically
08:37:14 <jophish_> and Star System for others
08:37:16 <johnw> jophish_: this isn't a Haskell topic at all, is it?
08:37:16 <geekosaur> think we just call it the solar system and haven't given a real thought to naming otherwise
08:37:31 <jophish_> whoops, wrong channel
08:37:34 <Shockk> lol
08:37:34 <geekosaur> not like we've had much reason :p
08:37:34 <jophish_> thanks johnw
08:37:55 <Shockk> maybe the solar system physics simulation is written in Haskell 
08:38:01 <k0001> zipper: ghc -fforce-recomp ?
08:38:18 <johnw> Shockk: gives new meaning to space leaks, I suppose
08:38:23 <Shockk> haha
08:38:31 <jophish_> as it happens, I can rephrase this as a haskell question: I'm writing a module with orbital information of the bodies in our Solar System, what should I title this module?
08:39:05 * hackagebot clash-vhdl 0.5.12 - CAES Language for Synchronous Hardware - VHDL backend  https://hackage.haskell.org/package/clash-vhdl-0.5.12 (ChristiaanBaaij)
08:39:05 * hackagebot clash-ghc 0.5.15 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.5.15 (ChristiaanBaaij)
08:39:10 <knupfer> geekosaur: thanks for the pointer to hindent, any idea why https://github.com/chrisdone/haskell-style-guide  advertises  f (h x) over f $ h x and (f . g . h) x over f . g $ h x?
08:39:18 <Jeanne-Kamikaze> import Orbit hiding (Sun)
08:39:36 <cocreature> knupfer: that's because chris done used to be a lisper :)
08:39:38 <geekosaur> knupfer, many Haskell programmers consider ($) to be overused
08:39:47 <jophish_> that kind of thing, although I've already got a module called orbit
08:39:55 <barrucadu> knupfer: I think the general argument is that most people come from languages where you can't define your own operators, so $ looks to them like a new bit of built-in syntax to learn
08:40:03 <pikajude> yes, i would avoid $
08:40:16 <pikajude> the first time someone showed me haskell, he was showing me a hand-built parser that used $ maybe 11 times in one function
08:40:30 <pikajude> fortunately i was able to overcome adversity. but many people will not be as lucky
08:40:40 <Shockk> I avoid ($) a lot of the time except when I'd require at least 2 or 3 levels of nested brackets otherwise, or when I use `do` after it
08:40:56 <sm> knupfer: I think (1) because $ is unfamiliar and (2) mixing both . and $ is bad and also grouping the functions clarifyies the overall operation and makes converting to/from point-free style easier
08:41:32 <knupfer> Well ok, "learn you a haskell for great good" advertises a . b $ c d, if I recall correctly
08:41:46 <Shockk> with liftIO for example, I would write liftIO (putStrLn "hello world") but I'd also write liftIO $ putStrLn ("hello " ++ name)
08:41:50 <knupfer> sm: why is (2) the case?
08:42:14 <sm> knupfer: 2a, 2b or 2c ? :)
08:42:29 <knupfer> 2a
08:43:01 <sm> mixing them just adds to the confusion for new haskellers. Also, see 1
08:43:02 <darkf> f . g $ x is nice because you can just extract the left side of ($) out to a (point-free) function, and ($) is nice because I find parentheses distracting (so it's really up to your preference)
08:43:22 * sm uses $ all the time, but is trying to get with the program
08:43:25 <visof_> hi guys
08:43:40 <visof_> if i have two methods called, updateU, processU, and list = [s1 s2 s3], how can i achieve this (processU (updateU s3 (processU (updateU s2 (process s1)))))
08:43:43 <visof_> ?
08:44:14 <knupfer> Ok, I'm just curious, I'm using most of the times the ...$ notation, albeit I've got a lisp background.
08:44:19 <darkf> Shockk: yes for me the ($) makes it a lot clearer and easier to read
08:44:44 <sm> whatever rule you prefer, there will probably be special cases where it's clearer to break it
08:44:45 <darkf> sometimes I even cringe when reading a few nested calls in other languages like f(g(h(x)))
08:44:51 <knupfer> Perhaps a point is, that the ($) doesn't exist in mathmatics, or am I wrong?
08:45:09 <darkf> well it _can_, you just have to define it ;)
08:45:16 <geekosaur> knupfer, not really; lots of things in programming languages "don't exist in mathematics"
08:45:18 <cocreature> visof_: processU . updateU s3 . processU . update s2 . process $ s1 is probably a bit easier to read, but apart from that I'm not sure if you can simplify it much more
08:45:34 <Shockk> I only usually use nested brackets when using $ would make it look worse for some reason, like if it would result in 3 $ all in a row or whatever
08:46:04 <knupfer> darkf: obviously, I'm talking about what's conventional, for example (a . b)(x) is fine in math
08:46:23 <knupfer> geekosaur: yes, but haskell is quite near to mathematics
08:46:35 <knupfer> typesignatures for example
08:46:39 <darkf> knupfer: well to be fair we also choose juxtaposition as application instead of f(x)
08:46:44 <sm> parentheses everywhere also makes life much easier for tool implementors, which is important for chris
08:46:53 <darkf> so "sticking to conventional mathematical notation" is not a massive concern
08:47:05 <sm> since he does a lot of that
08:47:24 <knupfer> darkf: that's common in category theory
08:47:38 <darkf> ah, I'm not familiar
08:49:00 <knupfer> Is there some extension which enables to write   join :: (Monad m) => m^2 a -> m a
08:49:01 <knupfer> ?
08:49:21 <geekosaur> no
08:49:42 <geekosaur> mostly because I think that's pretty much the only place where it'd be useful
08:50:15 <knupfer> it would work as well with concat :)
08:50:19 <knupfer> []^2
08:50:51 <darkf> how often are you referring to deeply nested structures in types though?
08:51:19 <darkf> maybe if you had a list of list of list of list of [Char] :)
08:51:39 <knupfer> that would be a []^5 Char!
08:52:03 <knupfer> actually seldom, just wondered and am curious
08:53:02 <knupfer> this notation is for example used on the monad (math) article of wikipedia
08:53:07 <fvgvxmpv1> everything that can be iterated probably should be
08:54:39 <Shockk> knupfer: the question is whether or not it's possible to implement Monad ^ Int or something at the type level :D
08:54:53 <Shockk> or rather Nat*
08:54:57 <knupfer> fvgvxmpv1: I don't want see when you've to write 10^32
08:55:14 <knupfer> Shock: yep
08:55:17 <medfly> hello
08:55:35 <knupfer> I like all the typelevel stuff, but it's quite hard for me to grasp.
08:56:05 <knupfer> hello
08:57:02 <Shockk> hmm assuming you have some Nat type (a type level whole number that's greater than or equal to zero),
08:57:15 <Shockk> it might be simple, just like
08:57:38 <Shockk> err..
08:57:44 <knupfer> unbox :: Maybe^1 a -> Maybe^0 a
08:57:48 <knupfer> :)
08:58:37 <lpaste_> Exio4 pasted “type-level pow” at http://lpaste.net/141425
08:58:43 <exio4> ^ there you have! 
08:59:03 <Shockk> oh
08:59:25 <knupfer> exio4: Great!
08:59:34 <knupfer> Can you explain how it works?
09:01:06 <exio4> it's a type-level function that basically converts (Pow m n a) into m (m (.. [m n-times] .. (m a))) .. )), I don't know what to explain out of it :)
09:01:16 <Shockk> Pow :: (* -> *) -> Nat -> * -> *
09:01:52 <Shockk> in the case that the Nat is 0, the resulting type is k (the last *)
09:02:51 <Shockk> I mean it's 'a'
09:03:23 <Shockk> otherwise it's m with (Pow m (n-1) a) as the type applied to it, since m is of kind * -> *
09:03:40 <Shockk> n-1 means it'll hit 0 eventually
09:03:51 <knupfer> and Nat is provided by which extension?
09:03:52 <Shockk> so you'll get like m (m (m (a)))
09:04:03 <Shockk> Nat is defined in GHC.TypeLits
09:05:13 <knupfer> hmm, Nat is only for Types?  Trying  2 :: Nat  doesn't work
09:05:16 <exio4> knupfer: DataKinds gives you type-level literals
09:05:26 <exio4> :k 2
09:05:28 <lambdabot> GHC.TypeLits.Nat
09:05:38 <exio4> it's a type that has a kind, not a value with a type
09:05:47 <exio4> the value-level natural number is something else
09:06:01 <knupfer> exio4: ok
09:06:15 <Shockk> am I correct in saying that Nat is type-level church numerals?
09:06:35 <exio4> does it look like a church numeral to you? 
09:06:51 <Shockk> I don't know :(
09:07:02 <dutchie> it's closer to peano naturals
09:07:47 <Shockk> ahh I see
09:08:40 <knupfer> Oh, I've got my first compile loop!
09:08:48 <exio4> the Pow type family could be somewhat seen as the morphism between natural numbers and church numerals, the "Nat" kind isn't either a peano number, church number, or whatever 
09:08:56 <knupfer> I've commented out the base case of Pow
09:09:16 <knupfer> What exactly is it doing now? How can n be lower as 0 if it's a Nat?
09:09:40 <exio4> @type Proxy :: Proxy (0-1) 
09:09:42 <lambdabot> Not in scope: type constructor or class ‘-’
09:10:39 <exio4> hm, I don't know :) 
09:12:26 <knupfer> exio4: I'm very happy with this example, I'll try to obfuscate my code bit with it.
09:13:13 <knupfer> These type families are turing complete, aren't they? At least you've defined a recursion which is computed in the typechecker?
09:14:00 * hackagebot diversity 0.7.0.3 - Return the diversity at each position by default for all sequences in a fasta file  https://hackage.haskell.org/package/diversity-0.7.0.3 (GregorySchwartz)
09:16:53 <exio4> knupfer: that type-family isn't that fancy, it's primitive recursive, some `basic` totality inference could have deduced it was total, the type checker doesn't need type families for being turing complete, as far as I know
09:20:09 <knupfer> exio4: ok, but am I wrong if I'm thinking that ghc/haskell is heading to dependent types which would make types first class and therefore turing complete?
09:23:14 <tjpeden> Is there any reason why one would want to use createProcess . shell over readProcess?
09:23:28 <tjpeden> I guess for the exit code?
09:23:45 <Shockk> there's readProcessWithExitCode
09:23:54 <exio4> knupfer: the type system is currently turing complete and has been for 10+ years (I think?), it's slowly gaining features that make quasi-dependent typing possible, but I don't know if there is any progress towards `true` dependent types in Haskell
09:26:20 <knupfer> exio4: I think yes, I've read something about ghc8 and types and kinds, but don't remember.
09:26:40 <exio4> do you have links to that?
09:26:52 <tjpeden> Shockk: so, then there's probably very few reasons to choose createProcess . shell over readProcess or readProcessWithExitCode?
09:26:55 <knupfer> Just found it:
09:26:58 <knupfer> https://typesandkinds.wordpress.com/2015/08/19/planned-change-to-ghc-merging-types-and-kinds/
09:27:31 <Welkin> does anyone know if it is possible to use built-in database functions with Persistent?
09:28:06 <Welkin> I know there is a way to use DB-specific types and operators
09:29:07 <exio4> knupfer: oh, that one, thought you meant values and types
09:29:30 <Shockk> tjpeden: readProcess calls withCreateProcess_ from what I can tell from the source
09:29:44 <hackal> Hello, so I just had my Informatics 1 Functional Programming lecture. We will be using haskell. Looking forward! Is haskell very different from JavaScript? I do not have much programming experience other than php/delphi/javasript. What should I expect from haskell?
09:29:58 <Shockk> tjpeden: which does createProcess_ in a bracketOnError
09:30:24 <tjpeden> Shockk: well, yes lol I assumed readProcess was an abstraction of createProcess
09:30:41 <Welkin> what is with the Proxy type and value?
09:30:55 <Welkin> why does it exist?
09:31:19 <Shockk> tjpeden: I don't see any API advantage of using createProcess, as readCreateProcessWithExitCode exists
09:31:26 <Shockk> which lets you give a CreateProcess value
09:31:29 <Welkin> is it just to provide a free phantom type?
09:31:30 <Shockk> and you get the ExitCode back
09:32:34 <knupfer> hackal: yes, it is like mathematics
09:33:06 <knupfer> x += 1 isn't possible
09:33:06 <tjpeden> Only reason I ask is because I say it on a YT tutorial last night and was kind of confused as to why he chose createProcess . shell over readProcess[WithExitCode]
09:33:28 <tjpeden> s/say/saw
09:33:30 <abra0> Correction, <tjpeden> Only reason I ask is because I saw it on a YT tutorial last night and was kind of confused as to why he chose createProcess . shell over readProcess[WithExitCode]
09:33:47 <tjpeden> That's neat
09:33:59 <knupfer> hackal: albeit you're beginning with haskell, you seem to have grepped already naming conventions :)
09:34:05 <kaidelong> hackal: mainly, a lot fewer weird things going on that you don't understand once the program is running
09:34:18 <kaidelong> hackal: also, it'll take ages and be very frustrating to get it to that point
09:34:31 <kaidelong> it shifts the frustration to that end
09:34:47 <exio4> Welkin: free as "no runtime cost"? there's Proxy# ...
09:35:03 <Welkin> exio4: no, I am asking what the purpose of Proxy is
09:35:09 <Welkin> why does it exist?
09:35:24 <Welkin> it looks to me like it just provides a place to put a phantom type
09:36:15 <knupfer> Is there a good tutorial for type level stuff?
09:36:45 <knupfer> I'm fascinated with the Pow solution.
09:37:11 <tjpeden> knupfer: Pow solution?
09:37:31 <knupfer> The code from exio4
09:37:48 <Sonolin> how do you print an "IO a" var ?
09:37:58 <Sonolin> does it have to go in a do block?
09:38:11 <knupfer> var >>= print
09:38:27 <knupfer> Sonolin: no, but it's perhaps clearer
09:38:31 <Sonolin> thanks!
09:38:34 <Sonolin> perfect :))
09:39:02 <knupfer> Sonolin: do notation is Just Sugar, so you can safely apply fromJust
09:39:24 <knupfer> (joke)
09:40:06 <tjpeden> Every stinkin time, I run into "Expected String Got IO String" is there a good rule of thumb to avoid hitting that?
09:40:24 <knupfer> Sonolin: If you are in ghci, you can just enter the var, ghci defaults to printing it
09:40:49 <dutchie> tjpeden: not really other than "practice keeping track of types"
09:41:07 <knupfer> apply unsafePerformIO :P
09:41:43 <Shockk> :(
09:41:53 <tjpeden> dutchie: I am keeping track of the types, however, I need to print this IO String...
09:42:19 <knupfer> tjpeden: var >>= print
09:42:31 <fvgvxmpv1> (which leaves you with a 'IO ()')
09:42:33 <Shockk> when you've got an IO String, that's not a String in itself, it's a value that describes some IO computation that will have a String as its result
09:43:30 <knupfer> @ty (>>= print)
09:43:31 <lambdabot> Show a => IO a -> IO ()
09:43:32 <tjpeden> Well now I feel dumb, I totally just watched you say that to Sonolin
09:43:36 <glguy> tjpeden: and IO String isn't a String, it's a way to get Strings
09:43:46 <Sonolin> lol
09:43:50 <Sonolin> glad to be of help :)
09:43:50 <tjpeden> glguy: I know
09:43:53 <glguy> so you have to decide when you want to execute it and how many times before you can start printing them
09:43:56 <knupfer> @pl return "abc" >>= print
09:43:57 <lambdabot> print "abc"
09:44:50 <Sonolin> is there a point to using either instead of fail? Is it just because its easier to pass around?
09:45:03 <knupfer> tjpeden: do you become these "errors" on compiling?
09:45:12 <knupfer> tjpeden: use ghc-mod
09:45:36 <knupfer> Sonolin: Either is more well defined
09:45:39 <tjpeden> knupfer: I am, I was not compiling, I simple saved in Atom :-)
09:45:47 <knupfer> good :)
09:46:01 <tjpeden> s/simple/simply
09:46:01 <abra0> Correction, <tjpeden> knupfer: I am, I was not compiling, I simply saved in Atom :-)
09:46:04 <knupfer> Sonolin: fail will make a lot of funny things
09:46:42 <knupfer> or "I simple-saved"
09:46:44 <exio4> abra0: what's up with that bot? 
09:46:44 <knupfer> :)
09:46:53 <Sonolin> knupfer: so fail doesn't always just fail? The case I'm looking at is a hardcoded error condition in a game (where a hard fail would be a-ok)
09:47:15 <Sonolin> either would probably allow more input from user (restart, etc.) so I guess it might be better anyway
09:47:19 <Shockk> fail has the quirk that it's unclear how to define it for Monad instances such as (Either e)
09:47:21 <Shockk> :t fail
09:47:23 <lambdabot> Monad m => String -> m a
09:47:30 <knupfer> Sonolin: fail depends on it's monad in which you call it and it is considered bad practice
09:47:37 <Shockk> it takes a String but the e in Either e isn't necessarily String obviously
09:47:38 <Sonolin> ah I see
09:47:49 <Sonolin> so since either has 2 args it comes back partially applied
09:48:24 <Sonolin> well maybe not
09:48:25 <knupfer> well, fail just calls error in many cases, which typechecks everywhere...
09:48:48 <Shockk> so in the case of Either e, fail s = error s
09:48:51 <knupfer> Also, calling error isn't so nice than an Either that handles that case
09:49:02 <Shockk> which will error out of the Haskell environment entirely
09:49:13 <Sonolin> oh interesting
09:49:32 <knupfer> It's like putting undefined in your code
09:49:46 <Sonolin> ok I'll stick to either then, good to know :)
09:50:06 <knupfer> Which actually isn't error handling, but a sign: "I'll implement that later, drinking coffee."
09:50:21 <Sonolin> I guess I was trying to simplify things because the tut I'm watching uses a lot of "Maybes" and "Either", but it looks like the eithers are placed right at least
09:50:48 <Sonolin> and with the either function I can at least still hardcode to the types
09:50:56 <knupfer> Sonolin: If you use do notation (Either is a monad) you actually don't see a lot of the internals
09:51:06 <Shockk> I use Maybe when there's only one possible reason for failure of the function
09:51:16 --- mode: ChanServ set +o dolio
09:51:20 <Sonolin> oh duh! good point I forget about do for maybes and eithers :P
09:51:21 --- kick: abra0 was kicked by dolio (abra0)
09:51:46 <Shockk> I use Either when there are a few potential reasons it could fail
09:51:54 --- mode: ChanServ set +o glguy
09:51:54 --- mode: glguy set +b *!*@abra.me
09:51:55 --- kick: abra0 was kicked by glguy (abra0)
09:52:21 <Sonolin> yea that sounds like a good idea :) thanks
09:52:24 <knupfer> You can use Maybe as well for optional stuff, like  fromMaybe x (stripPrefix p x)
09:52:35 --- mode: dolio set -o dolio
09:52:54 <knupfer> married :: Maybe Bool
09:53:04 <Shockk> using Maybe conveys that the function returns something, or it doesn't
09:53:09 <knupfer> nowadays perhaps Either Bool
09:53:17 <Shockk> using Either conveys that it returns something, or it returns a different thing
09:53:44 <knupfer> but note that Either is biased, it prefers the right thing
09:54:16 <knupfer> > Right 3 >>= Left 2 >>= Right 1
09:54:18 <lambdabot>      Couldn't match expected type ‘Integer -> Either a a0’
09:54:18 <lambdabot>                  with actual type ‘Either Integer b0’
09:54:18 <lambdabot>      Possible cause: ‘Left’ is applied to too many arguments
09:54:34 <knupfer> > Right 3 >> Left 2 >> Right 1
09:54:37 <lambdabot>  Left 2
09:55:09 <knupfer> so the Left is something like a stop gap
09:55:32 <Sonolin> so Left is like Nothing, but with an arg
09:55:34 <Sonolin> nice
09:55:45 <scshunt> it's often used to represent an error with information
09:55:59 <scshunt> e.g. Left "unable to establish connection" or the like
09:56:33 <knupfer> If you want to have equal sides you could use arrows
09:56:48 <Sonolin> thats actually really useful, I'm so used to imperative "if (conn) doSomething" is just ">> doSomething" with Either.. pretty cool
09:57:20 <knupfer> Sonolin: sort of
09:57:20 --- mode: glguy set -o glguy
09:57:42 <knupfer> what you describe is:  Control.Monad.when conn $ doSomething
09:58:21 <Shockk> for example; data PostCodeError = NoLetters | NoNumbers | EvenWorse   and then   parsePostCode :: String -> Either PostCodeError PostCode
09:58:34 <knupfer> >> is more like execute and abort if it fails
09:58:37 <Shockk> that took me too long to type
09:59:18 <Sonolin> ok cool, got it
09:59:26 <Sonolin> and nice example Shockk :) 
09:59:43 <Shockk> thanks
10:00:59 --- mode: ChanServ set +o glguy
10:00:59 --- mode: glguy set -b *!*@abra.me
10:01:18 <knupfer> Sonolin: You can actually write a bunch of "instructions" into a list and run it with sequence
10:01:46 <knupfer> which will automatically shortcut if something goes wrong
10:02:03 <Sonolin> hmm interesting
10:02:32 <cocreature> well if your monad shortcircuits at least, if you do that for e.g. IO it will run all of them
10:02:33 <knupfer> > sequence [Right 2, Right 3, Left 4]
10:02:35 <lambdabot>  Left 4
10:02:39 <Shockk> > sequence $ map print [1,2,3]
10:02:41 <lambdabot>  <IO [()]>
10:02:49 <knupfer> sequence [Left 2, Right 3, Left 4]
10:02:57 <knupfer> > sequence [Left 2, Right 3, Left 4]
10:02:59 <lambdabot>  Left 2
10:03:03 <knupfer> these darn bird-ticks
10:03:09 <Sonolin> woah nice
10:03:16 <Sonolin> how does the type signature make sense though
10:03:19 <Sonolin> > :t sequence
10:03:20 <lambdabot>  <hint>:1:1: parse error on input ‘:’
10:03:26 <exio4> @type sequence
10:03:28 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
10:03:41 <ski>   sequence :: [Either e a] -> Either e [a]  -- in this case
10:03:48 <exio4> t = []; m = Either e; [Either e a] -> Either e [a]
10:04:01 <Shockk> in the case of a list, the type can be imagined to be like
10:04:02 <Sonolin> oh ok
10:04:03 <knupfer> sequence [Right 2, Right 3, Right 4]
10:04:05 <ski> > sequence [Right 2,Right 3,Right 5]
10:04:07 <lambdabot>  Right [2,3,5]
10:04:10 <knupfer> lol
10:04:10 <Shockk> (Monad m) => [m a] -> m [a]
10:04:15 <Sonolin> ok that makes more sense now :)
10:04:38 <Sonolin> I thought it would give Right 5 based on the Left examples, but its Either Int [Int]
10:04:40 <knupfer> if you are only interested in side-effects use sequence_
10:04:48 <Shockk> but in reality it works with any instance of Traversable (which [] is)
10:04:59 <Shockk> which [a] is *
10:05:48 <ski> (`[a]' isn't an instance of `Traversable', for any `a'. `[]' is, though)
10:05:57 <Shockk> oh
10:06:07 --- mode: glguy set -o glguy
10:06:33 <knupfer> Sonolin:  A traversable is a structure which you can transform and preserve it's structure, for example a rose tree
10:07:15 <knupfer> note that tuples aren't traversable
10:07:40 <glguy> Well, instance Traversable ((,) a) is, at least
10:08:01 <ChristianS> a rose tree? i've no idea what that is, but it sounds poetic!
10:08:07 <benzrf> well
10:08:20 <knupfer> your file system is a rose tree
10:08:26 <knupfer> (at least mine)
10:08:42 <knupfer> data Rose a = Rose a [Rose a]
10:08:48 <knupfer> | Leaf
10:08:49 <benzrf> to be precise, a Traversable is something for which you can do t (g a) -> g (t a) where g is Applicative
10:09:14 <benzrf> (plus laws)
10:09:37 <knupfer> A rose tree is just a tree with an arbitrary amount of children per node
10:09:43 <knupfer> like a directory
10:09:45 <ski> > runWriter (traverse tell ("foo","bar"))
10:09:47 <lambdabot>  (("foo",()),"bar")
10:09:47 <benzrf> something that's possible to 'reconstruct under the covers'
10:12:49 <knupfer> Sonolin: A foldable only ensures that you can "traverse" it but doesn't guarantee the preservation of structure
10:13:21 <Sonolin> ah interesting
10:13:30 <knupfer> :t sum
10:13:31 <lambdabot> (Num a, Foldable t) => t a -> a
10:13:39 <knupfer> :t map
10:13:40 <lambdabot> (a -> b) -> [a] -> [b]
10:13:47 <knupfer> arg, old ghc
10:14:16 <knupfer> oh, my fault
10:14:24 <knupfer> :t traverse
10:14:25 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:16:25 <knupfer> so foldable is more general than traversable, because every structure you can traverse you can as well fold up to construct say the sum of it's elements
10:17:06 <Sonolin> ok.. is "[]"  higher level than Traversable?
10:18:13 <Sonolin> I mean I understand [1,2,3] is traversable, but just wondering why not just say [a] instead of Traversable a
10:18:14 <knupfer> Hmm, a list is traversable and foldable
10:18:21 <Sonolin> oh ok
10:18:36 <Sonolin> so Traversable is more specific
10:18:41 <knupfer> no
10:18:41 <hiptobecubic> Traversable is something you can say about a data structure, [] *is* a data structure
10:18:49 <knupfer> a list is more specific
10:18:52 <hiptobecubic> about which you can say Traversable
10:18:53 <knupfer> it could be as well a tree
10:20:04 <Sonolin> ok right I meant "more small" not "specific"
10:20:08 <Sonolin> if that makes more sense...
10:20:19 <knupfer> could you clarify?
10:20:26 <qmm> after asking this channel about the algorithm for url shorteners a few days ago, i realized it's a simple increment of a higher base than base 10
10:20:45 <Sonolin> well Traversable is smaller than [], like Num is smaller than Int
10:20:46 <hiptobecubic> Sonolin, many things can be described as Traversable. [] is just one of those things.
10:20:47 <Sonolin> is that right?
10:21:00 <Sonolin> yea
10:21:11 <qmm> my new question is: how do they keep the URLs so short? They've had millions of URLs shortened at this point, but i stil get `1bdDlXc` as a bit.ly path
10:21:16 <hiptobecubic> By writing code in terms of traversable, you don't restrict yourself to just the implementation that is associated with []
10:21:20 <knupfer> Sonolin: no, Traversable is a general characteristic and [] is an instance of it
10:21:26 <Welkin> qmm: base62 encoding
10:21:48 <knupfer> Traversable <-> [] is like Gender <-> Sonolin
10:21:59 <qmm> Welkin: do you think it's possible they are using base128?
10:22:21 <Welkin> qmm: well, base62 is just base64 without the '+' and '/'
10:22:35 <Welkin> I'm not sure what base 128 would include
10:23:19 <koala_man> unicode emoticons
10:23:20 <Welkin> > 62 ^ 7
10:23:22 <lambdabot>  3521614606208
10:23:29 <Welkin> that is quite a large number
10:23:44 <Welkin> 3,5 trillion
10:24:09 <knupfer> Sonolin: So [] is more or less like a subtype of Traversable, like Int of Integer (note that this is not standard use of termini)
10:24:41 <Welkin> qmm: funny that you bring this topic up, since I have been working on a url shortener myself as part of an application I am building
10:24:54 <Shockk> Int and Integer are different types, Int is a 4 byte integer as far as I know whereas Integer is an integer of arbitrary precision
10:25:01 <Shockk> Traversable is a typeclass though
10:25:06 <Welkin> writing the bijective set of function to convert to/from base62/base10 was fun
10:28:19 <Welkin> qmm: at least based on my own encoder/decoder, 1bdDlXc = 3035577444826
10:29:27 <GLM> Are Tress considered to be traversable or are tree, path pairs only traversable?
10:30:13 <Shockk> exio4: I have a question about type level stuff 
10:30:20 <statusfailed> Is there a library for getting a list of unicode glyphs from a bytestring? (I understand a glyph to be a collection of 1 - 4 bytes, representing a character)
10:30:49 <lpaste_> Shockk pasted “PolyMap.hs” at http://lpaste.net/141428
10:31:04 <Shockk> I want to write a function 'empty' for this data type
10:31:33 <Shockk> I don't know how to do this though because if I do something like
10:31:39 <Shockk> empty :: PolyMap xs
10:32:07 <Shockk> that doesn't work because ghc can't match type `xs' with '[]
10:32:29 <Shockk> I can write empty :: PolyMap '[]
10:32:34 <Shockk> and then empty = UnitPolyMap
10:32:59 <Shockk> I don't know how to write a 'version' of empty for PolyMap (a ': as) though
10:33:01 <przembot> is it ok? https://hackage.haskell.org/package/test-framework-quickcheck2 hackage website it depends on 
10:33:13 <Shockk> in the same way that I've written data instances for the data family
10:33:27 <przembot> QuickCheck < 2.9, but in cabal file it's < 2.8
10:34:29 <qmm> Welkin: thank you for your help
10:34:40 <exio4> Shockk: so you want empty :: PolyMap xs to be either UnitPolyMap or [] :<->: empty ? 
10:34:48 <Shockk> that's right
10:35:14 <exio4> Shockk: I would use a typeclass for that, class EmptyPolyMap (xzs :: [*]) where empty :: PolyMap xs
10:35:20 <exio4> s/xzs/xs
10:36:20 <Shockk> hmm I see
10:36:32 <Shockk> and I'd write an instance for PolyMap '[] and for PolyMap (a ': as) right?
10:37:47 <exio4> yes, a maybe-nicer approach would be to define PolyMap as a GADT, and then define an empty function as empty :: Proxy xs -> PolyMap xs 
10:37:58 <athan> Hmm... If I have an `IO a -> IO b`, how could I turn that into a `MonadIO m => m a -> m b`? 
10:38:21 <exio4> athan: MonadIO isn't enough :(
10:38:30 <athan> D:
10:38:30 <ski> you can't, in general
10:38:38 <athan> dang
10:38:42 <Intolerable> yeah, you that is not a thing you can do
10:38:51 <Intolerable> what are u trying to do?
10:38:58 <ski> @google monad tunneling
10:38:58 <lambdabot> https://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
10:39:49 <Intolerable> maybe take a look at MonadBase / MonadBaseControl
10:40:36 <emmanuel_erc> hello there!
10:40:41 <Intolerable> hi
10:40:59 <qmm> Welkin: does your representation of the link look somewhat like this? `{ id: <db_generated_id>, shortened_url: <base64_number>, expanded_url: "http://haskell.org" }`
10:41:18 <qmm> Welkin: i'm building a url shortener myself for the first time
10:41:23 <emmanuel_erc> hi intolerable, I hope your name is merely amusing.
10:41:41 <qmm> Welkin: this is how i imagine the resource to be represented
10:42:18 <athan> let factorOut :: Functor f => f (a -> b) -> a -> f b; factorOut f x = ($ x) <$> f
10:42:25 <athan> @let factorOut :: Functor f => f (a -> b) -> a -> f b; factorOut f x = ($ x) <$> f
10:42:27 <lambdabot>  Defined.
10:42:44 <Shockk> exio4: ooh it works
10:42:53 <athan> now, how would you define `factorIn :: (a -> f b) -> f (a -> b)` :)
10:43:02 <Shockk> polymap :: PM.PolyMap '[Integer, String]  /  polymap = PM.empty
10:43:06 <Shockk> main = print polymap
10:43:19 <Shockk> and it outputs   [] :<->: ([] :<->: UnitPolyMap)
10:44:18 <Sonolin> ski: thanks for that article, interesting stuff
10:44:29 <Sonolin> little over my head but saved for later 
10:44:45 <exio4> Shockk: oh, re: my "Proxy" solution, it doesn't work that nice, you would need to do other kind of type hackery for that
10:44:54 <Shockk> ohh I see
10:45:13 <Shockk> I was about to look into that, but I might not then
10:52:00 <emmanuel_erc> hey I got a question, I realize that one can use an applicative functor to thread the results of two or more functions into the arguments of a function that can operate on the final numbef of results. Is there a generalization that permits threading the results of n functions, whose forms, though compatible, have yet to be realized (e.g (==m) where m, an integer is determined later by walking a list), and additionally n may not be
10:52:00 <emmanuel_erc> known?
10:52:56 <KaneTW> Monoid?
10:53:05 <KaneTW> that sounds like a Monoid instance
10:53:14 <emmanuel_erc> Are you talking to me KaneTW?
10:53:15 <KaneTW> probably gotta define a fitting newtype
10:53:18 <KaneTW> yes
10:53:24 <emmanuel_erc> cool
10:53:33 <KaneTW> :t sequence
10:53:34 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
10:53:40 <KaneTW> oh
10:53:44 <KaneTW> i just realized what you want
10:53:50 <emmanuel_erc> What do you think I want?
10:54:22 <KaneTW> do you want something like
10:54:24 <KaneTW> :t liftA2
10:54:25 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:54:30 <KaneTW> except for n arguments?
10:54:55 <emmanuel_erc> I am not sure. I'll write out explicitly what I am trying to do.
10:55:03 <exio4> I think it is meant to be something like a lifted monoid? foldr (liftA2 mappend) (liftA mempty)? 
10:55:13 <KaneTW> that's what i thought at first
10:56:25 <emmanuel_erc> I want to compute this for instance. (||) <$> (==4) <*> (==2). The integers 4 and 2 are determined by some list.
11:01:07 <KaneTW> hmm
11:01:50 <KaneTW> not sure if applicative is strong enough
11:03:01 <exio4> @type \f -> foldr (liftA2 (mappend . f)) (liftA mempty)
11:03:02 <lambdabot> (Applicative f, Foldable t, Monoid b, Monoid (f b)) => (a -> f b) -> t (f a1 -> a) -> f a1 -> f b
11:03:02 <emmanuel_erc> To give you some more context, I was trying to do zip two lists, but with add context that I want to use certain values from the second list to create the zipped up list.
11:03:24 <johnw> have you seen MonadZip?
11:03:28 <exio4> hm, it seems it's not what I want :P 
11:03:45 <KaneTW> yeah
11:03:50 <KaneTW> Monoid (f b):v
11:04:11 <emmanuel_erc> I'll take a look at that.
11:04:26 <emmanuel_erc> Thanks for the tip.
11:04:53 <Welkin> qmm: that looks fine
11:05:13 <Welkin> mine oesn't look like that because I am building a link shortener for internal use only, so it works a bit differently from yours
11:06:10 <Welkin> qmm: I am actually just using the 64-bit id number of a record and encoding it to base62 for the textual representation, then when a user visits the link, I decode it to the id
11:07:55 <tjpeden> I keep seeing where Text.Regex.Posix is bundled in Haskell, but ghc-mod says it can't find that package... am I missing something?
11:08:32 <glguy> tjpeden: It's not "bundled" but it's available in the regex-posix package
11:09:00 <Welkin> qmm: so with my scheme, the maximum length base62 string I can represent is 11 characters
11:09:12 <Welkin> which is maxBound :: Word64
11:10:44 <Welkin> qmm: h, actually it is maxBound :: Int64 because of the way the databse handles the serial integer
11:10:47 <Welkin> what a shame
11:11:51 <Welkin> although it still ends up being 11 characters long
11:13:53 <Welkin> ~9.2 quintillion entries
11:16:05 <hak> Hello I just installed ghci and I would like to ask if there is a way to paste in your clipboard when you type to console. My c button is not working and when I want to use letter c I press ctrl+v
11:17:33 <fvgvxmpv1> Shift+Insert does the same thing as middle-click on X, methinks
11:17:39 <tjpeden> Installed that with cabal now it's saying that "import Text.Regex.Posix" is redundant... what am I doing wrong?
11:18:27 <fvgvxmpv1> tjpeden, importing Text.Regex.Posix, when it´s redundant
11:18:27 <ski> hak : not sure if you're using a windows `cmd.exe' thing .. if so, try right-clicking on the top-left icon in the window, to get a menu ?
11:19:09 <tjpeden> fvgvxmpv1: so I don't need to import it at all?
11:19:20 <fvgvxmpv1> apparently
11:19:28 <fvgvxmpv1> you seem to not be using it
11:19:41 <tjpeden> Ohhhh, right... yet
11:19:43 <tjpeden> lol
11:20:42 <Chobbes> Is there a way to use `stack new` and have it create everything in the current directory, or over an existing directory?
11:24:05 * hackagebot PortMidi 0.1.5 - A binding for PortMedia/PortMidi  https://hackage.haskell.org/package/PortMidi-0.1.5 (PaulLiu)
11:34:06 * hackagebot PortMidi 0.1.5.1 - A binding for PortMedia/PortMidi  https://hackage.haskell.org/package/PortMidi-0.1.5.1 (PaulLiu)
11:37:15 <ReinH> Chobbes: from an existing directory, stack init I believe
11:49:32 <Ankhers> ReinH: `stack init' is for setting up stack with a current cabal project.
11:52:53 <Shockk> whew
11:53:25 <Shockk> my head hurts massively but I managed to write 'singleton' for my PolyMap
11:54:28 <exio4> Shockk: singleton :: a -> PolyMap '[a] ; singleton x = [x] :<->: UnitPolyMap ? or a different thing?
11:54:50 <Shockk> exio4: well I did it by defining a data family Relation :: [*] -> *
11:55:04 <Shockk> is defined like PolyMap except instead of [a] :<=>: PolyMap as
11:55:12 <Shockk> is just   a :<->: Relation as
11:55:22 <Shockk> and singleton :: Relation as -> PolyMap as
11:56:04 <exio4> I would work with GADTs, instead of data families, as you probably want everything to be actually closed
11:56:08 <Shockk> so I can construct a PolyMap now like `PM.empty` or like `"one" :<->: 1`
11:56:21 <exio4> I mean, right now, you can't do anything else
11:56:39 <Shockk> hmm, I haven't used GADTs before, what would I do to use those in place of the families?
12:13:26 <Denommus> hi
12:14:07 * hackagebot atom-conduit 0.2.0.0 - Streaming parser/renderer for the Atom 1.0 standard (RFC 4287).  https://hackage.haskell.org/package/atom-conduit-0.2.0.0 (koral)
12:30:21 <nullx002> hi
12:30:38 <nullx002> i updated cabal using cabal install cabal cabal-install
12:30:38 <nullx002>  
12:30:44 <nullx002> still it shows older version
12:31:05 <nullx002> [~] # cabal --version
12:31:06 <nullx002>  
12:31:32 <nullx002> cabal-install version 1.20.0.3
12:31:32 <nullx002> using version 1.20.0.2 of the Cabal librar
12:31:37 <geekosaur> why are you doing that as root? especially if you installed it as yourself
12:31:38 <nullx002> instead of 1.22
12:31:44 <nullx002> yes
12:31:45 <nullx002> root
12:31:50 <przembot> nullx002: `which cabal`
12:31:53 <nullx002> also changed $path
12:32:12 <geekosaur> upgrading cabal does not replace one installed on a system path, it installs it in ~/.cabal/bin
12:32:18 <przembot> does it point to correct binary file?
12:32:30 <nullx002> yes it is in .cabal/bin
12:32:38 <nullx002> how to change installed one?
12:32:57 <nullx002> i removed debian repos becasue they were 2 years oild
12:33:05 <nullx002> trying to install haskell-platform
12:33:13 <nullx002> but build fails with an error
12:33:27 <nullx002> Exit code: 1
12:33:27 <nullx002> Stderr:
12:33:28 <nullx002> ghc: ghc no longer supports single-file style package databases (dist/package.conf.inplace) use 'ghc-pkg init' to create the database with the correct format.
12:33:28 <nullx002>  
12:35:09 <nullx002> any one?
12:37:35 <geekosaur> I think that's a known issue when the Cabal library used by cabal-install and the Cabal library used by Setup.hs differ for some reason?
12:38:39 <geekosaur> but I don't know what to do about it offhand
12:39:46 <nullx002> so no way to install haskell playform instead of older debian repos..
12:40:44 <Denommus> nullx002: have you tried to install from stack?
12:43:46 <nullx002> yes
12:43:50 <nullx002> it fails
12:44:21 <Denommus> weitd
12:44:24 <Denommus> weird
12:45:06 <nullx002> tried everything
12:45:17 <nullx002> including purge and than manual install
12:45:41 <Denommus> I don't actually use Debian, so I don't know how to help you
12:46:16 <nullx002> let me reboot and check if it works
12:48:03 <nullx002> ..
12:48:05 <monochrom> at this point you need computer forensic to rediscover what you really did, what you really erased, and what have not been really erased.
12:48:32 <monochrom> because human memory tends to be fuzzy
12:48:33 <Shockk> exio4: I tried rewriting PolyMap as a GADT but I can't figure out how to write the Show instance for it
12:49:05 <nullx002> no.. purged debian repos but will load still from memory, have to restart
12:49:13 <nullx002> after that i hope it is all done
12:49:17 <lpaste_> Shockk pasted “PolyMap.hs” at http://lpaste.net/141434
12:50:00 <Shockk> for the first deriving instance, I get an error that it can't match type '[] with `a : as'
12:50:22 <Shockk> for the second deriving instance, I get an error that it can't match type `a : as' with '[]
12:50:23 <Shockk> lol
12:52:33 <Shockk> I'm guessing it's because the instance has to be written for the whole GADT
12:54:59 <monochrom> where is ': defined?
12:55:15 <Shockk> ': is the promoted kind for :
12:55:25 <monochrom> does it really exist? how do you know?
12:56:20 <Shockk> when I write this with a data family and with:  data instance PolyMap (a ': as) = [a] :<=>: PolyMap as
12:56:23 <Shockk> it works
12:56:53 <Shockk> :k ':
12:56:55 <lambdabot> parse error on input ‘:’
12:57:05 <monochrom> lambdabot doesn't have it
12:57:14 <Shockk> I forgot what lambdabot command someone used yesterday to demonstrate this
12:59:08 <Shockk> :k (Integer ': '[])
12:59:08 <lambdabot> [*]
12:59:11 <Shockk> monochrom: %
12:59:16 <Shockk> er, monochrom: ^ *
12:59:29 <monochrom> :k (':)
12:59:30 <lambdabot> parse error on input ‘:’
12:59:41 <Shockk> hmm
12:59:42 <Shockk> :k :
12:59:43 <lambdabot> parse error on input ‘:’
13:00:20 <Shockk> I have no idea
13:00:25 <Shockk> :k (:)
13:00:27 <lambdabot> parse error on input ‘:’
13:04:09 * hackagebot arbtt 0.9.0.7 - Automatic Rule-Based Time Tracker  https://hackage.haskell.org/package/arbtt-0.9.0.7 (JoachimBreitner)
13:04:11 * hackagebot x509 1.6.2 - X509 reader and writer  https://hackage.haskell.org/package/x509-1.6.2 (VincentHanquez)
13:09:09 * hackagebot x509-validation 1.6.3 - X.509 Certificate and CRL validation  https://hackage.haskell.org/package/x509-validation-1.6.3 (VincentHanquez)
13:09:11 * hackagebot x509-util 1.6.0 - Utility for X509 certificate and chain  https://hackage.haskell.org/package/x509-util-1.6.0 (VincentHanquez)
13:16:27 <Shockk> making progress, I can now construct a PolyMap as 'one = singleton ("one" :<->: 1 :<->: UnitRelation)' and construct another PolyMap as 'two = insert ("two :<->: 2 :<->: UnitRelation) one'
13:19:37 <lrocksmashtime> Hey guys I'm really interested in using Haskell's attoparsec library but I specifically need to use it on streaming data. The documentation and the types are pretty overwhelming has anyone here successfully used attoparsec with pipes or an input stream?
13:20:26 <glguy> lrocksmashtime: google for "pipes attoparsec", people have made packages to link the two, you can see how they did that
13:20:51 <lrocksmashtime> yeah that's about as far as i've gotten. couldn't get the wiring right.
13:26:12 <pikajude> what problems are you having with wiring?
13:26:14 <pikajude> i'm sure someone here could help
13:28:50 <lrocksmashtime> pikajude: basically given some regular Parser type how would I combine it with Pipes.Attoparsec parse 
13:29:59 <lrocksmashtime> and then just generally making sense of the pipes library and how the result type (Parser a m (Maybe (Either ParsingError b))) works
13:30:28 <pikajude> lrocksmashtime: you just do Pipes.Attoparsec.parse myParser
13:30:38 <pikajude> or, you could use `parsed`
13:30:44 <pikajude> which turns your parser directly into a pipes Producer
13:31:08 <pikajude> http://hackage.haskell.org/package/pipes-4.1.6/docs/Pipes-Tutorial.html might help you understand what a Producer does
13:31:14 <lrocksmashtime> then the producer can be used with the standard pipes operators like (>->) ?
13:31:26 <pikajude> yes
13:31:41 <lrocksmashtime> awesome. time to play around. Thanks pikajude
13:31:48 <pikajude> absolutely
13:34:11 * hackagebot FunGEn 1.0 - A lightweight, cross-platform, OpenGL/GLUT-based game engine.  https://hackage.haskell.org/package/FunGEn-1.0 (SimonMichael)
13:34:13 * hackagebot asn1-parse 0.9.4 - Simple monadic parser for ASN1 stream types.  https://hackage.haskell.org/package/asn1-parse-0.9.4 (VincentHanquez)
13:46:42 <nitrix> If I use atomic IORef updates, I'm guaranteed that another thread reading the same IORef will get either the old or the new value but nothing in-between?
13:47:07 <Cale> nitrix: yes
13:47:20 <Cale> nitrix: In fact, even if you don't use atomic IORef updates, this is the case
13:47:34 <nitrix> Cale: How come?
13:47:50 <Cale> Because all you ever do is update a pointer (to code)
13:48:22 <Cale> and that's atomic no matter what
13:48:39 <nitrix> So it accidently happens to provide atomic update. I'll still use the atomic function for the sole purpose of being self-documenting.
13:48:47 <Cale> The atomic update thing is so that you can read, compute a new value, and write without having to worry about an update in the middle of that.
13:49:18 <nitrix> Oh the atomic update also takes care of that?
13:49:26 <nitrix> I thought I'd need some kind of MVar for that.
13:49:53 <nitrix> Brilliant then :)
13:49:53 <glguy> You need an MVar if your computation includes executing something in IO
13:50:57 <nitrix> glguy: All the timme or being cautious?
13:51:16 <glguy> Because of the type of atomicModifyIORef
13:51:24 <nitrix> Okay.
13:51:30 <nitrix> Thanks guys.
13:53:35 <Ralith> you can just use STM for everything
13:54:11 * hackagebot x509 1.6.3 - X509 reader and writer  https://hackage.haskell.org/package/x509-1.6.3 (VincentHanquez)
13:54:40 <sinelaw> nitrix, note that if you need to decide which IO action to do based on current value while updating the IORef, but you don't need to do it atomically with the change of the IORef value, you don't need an MVar
13:55:26 <sinelaw> (I mean, if you don't need to execute the decided IO action at the same time as modifying the IORef, you just need to decide which action to do later)
13:55:51 <sinelaw> so a common idiom is:
13:56:18 <sinelaw> join $ atomicModifyIORef foo (\bla -> build an IO action here...)
13:58:47 <Cale> Sometimes you're better off just switching to using MVars or STM just for your own sanity though.
14:00:16 <quicksilver> I generally only use IOref when I know multiple threads won't access it
14:07:06 <Cale> One thing which is generally a pretty good idea is to make all your thread communication variables at the top level, and then *don't* pass them directly to the threads which will use them. Instead pre-apply stuff like readIORef and writeIORef or atomicModifyIORef or whatever you'd otherwise be using.
14:07:17 <Cale> and pass around the relevant functions/IO actions
14:08:13 <johnw> "IORef closures" are a great way to ensure access policies
14:08:19 <Cale> That means if you eventually want to refine how your threads communicate, or do logging and such, you have a centralised place in your code to change how that communication happens.
14:08:23 <johnw> and they let you trivially switch to TVars later
14:08:24 <Cale> and yeah, you get to control access nicely
14:09:55 <quicksilver> even better to just pass around values and pure functions, if you don't need fine grained control on the IO parts
14:12:10 <avishai> Hi guys
14:12:24 <avishai> I'm going through Real World Haskell for the first time
14:13:09 <avishai> and I'm confused about the example in "Parameterized types": http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
14:13:22 <dfeuer> Argh.
14:13:57 <dfeuer> Is there a way to file a ticket against regex-posix without dealing with this SourceForge nonsense? It seems to have crashed my browser.
14:14:03 <avishai> What is Just and Nothing?
14:14:25 <ski> they are data constructors belonging to the type constructor `Maybe'
14:14:26 <dfeuer> oh, I guess not crashed; just a really really long delay.
14:14:37 <sinelaw> avishai, they are the constructors of the type "Maybe a" (for some type a)
14:14:55 <sinelaw> :t Just 'x'
14:14:56 <lambdabot> Maybe Char
14:14:58 <Cale> Nothing :: Maybe a
14:15:02 <Cale> Just :: a -> Maybe a
14:15:05 <dfeuer> :k Just 'x'
14:15:06 <lambdabot> parse error on input ‘'’
14:15:09 <avishai> So that's an arbitrary name? Could as well be "Ham" and "Spam"?
14:15:12 <Cale> yep
14:15:13 <dfeuer> :k Just "x"
14:15:14 <lambdabot> Maybe GHC.TypeLits.Symbol
14:15:21 <dfeuer> :k Just 'x
14:15:23 <lambdabot>     Identifier ‘x’ used as a type
14:15:23 <lambdabot>     In a type in a GHCi command: Just x
14:15:26 <dfeuer> bleh.
14:15:51 <dfeuer> :k Just False
14:15:52 <lambdabot> Maybe Bool
14:15:56 <Cale> There's nothing special about the named Nothing and Just apart from the fact that they start with an uppercase letter, indicating that they're data constructors (and so pattern matching against them is allowed)
14:15:58 <dfeuer> There we go.
14:16:00 <Cale> names*
14:16:22 <dfeuer> :k [Just False, Nothing, Just True]
14:16:24 <lambdabot> [Maybe Bool]
14:16:24 <avishai> OK, but since Haskell already has Just and Maybe, why are we defining it here?
14:16:38 <dfeuer> avishai, probably for educational purposes.
14:16:43 <athan> :k (':)
14:16:44 <lambdabot> parse error on input ‘:’
14:16:45 <ski> avishai : if you have an `Maybe T', then you maybe have a `T'. you have one, or none. in the former case, you have a value of shape `Just x', where `x :: T'. in the latter case, you have a value `Nothing'
14:16:46 <athan> er
14:16:51 <athan> :k (:')
14:16:52 <lambdabot> parse error on input ‘:’
14:16:55 <athan> blast
14:16:56 <dfeuer> :k ( ': )
14:16:58 <lambdabot> parse error on input ‘:’
14:16:59 <dfeuer> hmm
14:17:00 <mniip> :k (:)
14:17:01 <lambdabot> parse error on input ‘:’
14:17:04 <Cale> avishai: If books didn't talk about the implementation of any of the stuff which is in the standard libraries, there would be very little beginner material to discuss
14:17:08 <athan> :k []
14:17:09 <lambdabot> * -> *
14:17:12 <avishai> Ah
14:17:14 <athan> :k '[]
14:17:15 <lambdabot> [k]
14:17:19 <athan> thar she blows!
14:17:26 <Cale> guys, lambdabot responds to private messages, you know
14:17:34 <ski> dfeuer : maybe you meant `:t' ?
14:17:40 <avishai> So this looks like this actually should have been myJust and myNothing
14:17:42 <dfeuer> ski, of course not.
14:18:00 <avishai> like myNot, which came before this in the book
14:18:03 <Cale> avishai: It would have to be MyJust and MyNothing, but yeah that's an option
14:18:05 <monochrom> @pl (\x y -> (f `fmap` x) <*> y))
14:18:05 <lambdabot> (line 1, column 29):
14:18:05 <lambdabot> unexpected ')'
14:18:05 <lambdabot> expecting variable, "(", operator or end of input
14:18:07 <athan> I wonder how SystemFC_pro will change with -XDependentHaskell...
14:18:09 <monochrom> @pl (\x y -> (f `fmap` x) <*> y)
14:18:10 <lambdabot> (<*>) . (f `fmap`)
14:18:12 <monochrom> :)
14:18:18 <benzrf> :k [Int, String]
14:18:19 <lambdabot> [*]
14:18:28 <benzrf> :k Int ': [String]
14:18:29 <lambdabot>     The second argument of ‘:’ should have kind ‘[*]’,
14:18:30 <lambdabot>       but ‘[String]’ has kind ‘*’
14:18:30 <lambdabot>     In a type in a GHCi command: Int : [String]
14:18:32 <benzrf> huh
14:18:40 <benzrf> oh
14:18:44 <benzrf> :k Int ': '[String]
14:18:45 <lambdabot> [*]
14:18:50 <benzrf> well it works /there/
14:18:52 <Cale> avishai: Another option is just to hide the Prelude definition, by explicitly importing the Prelude and telling it not to import Maybe and its constructors:
14:19:11 <ttt_fff> Data.Text.Lazy.IO.writeFile "output" "some arbitrary text" >> error "wtf wtf wtf"  <-- now, when I execute this case, nothing gets written to output, persurmurably due to laziness
14:19:15 <Cale> import Prelude hiding (Maybe(..))
14:19:19 <ttt_fff> how do I "flush" the output file before the error ?
14:19:21 <dfeuer> athan, I'm still wondering why it won't accept the section ( ': )
14:19:39 <avishai> I guess I was confused with which parts of this example were using predefined Haskell things.
14:19:42 <Cale> ttt_fff: uhhh, writeFile isn't in any way lazy
14:19:43 * athan shrugs
14:19:50 <avishai> Thanks guys. But another question.
14:19:55 <ttt_fff> Cale: so you're saying my error is somewhere else?
14:19:56 <glguy> ttt_fff: error and fail are different
14:19:57 <avishai> Is a type constructor a function?
14:20:07 <sinelaw> ttt_fff, is the result of your IO stuff being used at all? if not, the io action will never be executed
14:20:10 <johnw> avishai: no, it's a "type former" is one word for it
14:20:13 <dfeuer> avishai, it is a function on the type level.
14:20:16 <johnw> avishai: a data or value constructor is a function
14:20:16 <glguy> ttt_fff: Use fail when you want execution to raise the exception rather than evaluation
14:20:17 <Cale> sinelaw: no!
14:20:23 <Cale> sinelaw: It's writeFile, not readFile
14:20:26 <avishai> I meant value constructor
14:20:35 <dfeuer> A value constructor is a function on the value level.
14:20:40 <ttt_fff> main :: IO () \n main Data.Text.Lazy.writeFile "tokens" (result of alex) >> tries to call happy -- and gets an error
14:20:41 <avishai> sorry, I'm a noob
14:20:47 <Cale> writeFile is entirely strict, and consumes the whole lazy Text value.
14:20:49 <Sindriava> is there something a bit more elegant then `when (isJust val) $ let Just v = val in …` ?
14:20:50 <johnw> avishai: we love your noobness
14:20:53 <sinelaw> Cale, ah sorry
14:20:56 <ski> avishai : a type constructor may be a *type* function (a "function on the type level"). but it's not a value function (a "function on the value level", like `not',`words',...)
14:21:10 <dfeuer> Sindriava, yes. Always.
14:21:19 <avishai> So it's possible to define a function with no arguments?
14:21:19 <Sindriava> dfeuer: And what would that be?
14:21:35 <ski> avishai : some data constructors are functions (like `Just',`(:)',`Left',`Right'), some aren't (like `Nothing',`[]',`False',`True')
14:21:39 <ttt_fff> https://gist.github.com/anonymous/4e7dd158bd8178465c71
14:21:41 <Sindriava> dfeuer: e.g. execute code only for a `Just` value. Maybe forM_, hm…
14:21:47 <ttt_fff> https://gist.github.com/anonymous/4e7dd158bd8178465c71 <-- how do I fix this? describes my data.text.lazy.io.writefile error
14:21:53 <johnw> avishai: a function technically always has one argument
14:21:58 <johnw> avishai: you can define values with no arguments
14:22:08 <dfeuer> Sindriava, well, it all depends on your sense of elegance, I suppose. You can always use case, or the maybe function.  I'm not sure if there's a nice way to avoid extra nesting though.
14:22:12 <ski> avishai : no. every function takes exactly one argument, in Haskell
14:22:26 <avishai> What would the argument be for the Nothing value constructor in that example?
14:22:31 <dfeuer> Ah yes, I wasn' thinking about nullary constructors.
14:22:36 <dfeuer> Those aren't functions.
14:22:42 <ski> avishai : `Nothing' is not a function, so it doesn't accept an argument
14:22:46 <dfeuer> And there are also type constructors that aren't functions on the type level.
14:23:02 <ski> like `Int',`Bool',...
14:23:14 <avishai> Hmm.
14:23:21 <avishai> What are they called if not functions?
14:23:25 <johnw> values
14:23:31 <ski> avishai : which "they" ?
14:23:37 <quicksilver> Sindriava: I often define a function 'whenJust' for that 
14:23:39 <Sindriava> ski: a useful metaphore for nullary functions is a function that accepts unit ;)
14:23:42 <avishai> Data constructors that are not functions
14:24:03 <dfeuer> Of course, if you like to think of Haskell by translation to System FC, Nothing *is* a function, from a type to a value... but that's not Haskell per se.
14:24:04 <Sindriava> quicksilver: That's doesn't perform the unwrapping though. I quite like forM_, i guess
14:24:07 <ski> avishai : values, data constructors, perhaps constant constructors
14:24:18 <dfeuer> quicksilver, oh, nice.
14:24:23 <avishai> I guess Nothing is like True or False then?
14:24:27 <johnw> exactly
14:24:34 <ski> Sindriava : tupled style
14:24:42 <quicksilver> Sindriava: it does perform the unwrapping
14:24:45 <johnw> the only difference is that Nothing is polymorphic
14:24:57 <ski> the empty list, `[]', is also polymorphic
14:25:03 <johnw> i.e., there is Nothing :: Maybe Int, and Nothing :: Maybe Bool, and they are not the same thing (although they can be safely coerced one to the other)
14:25:08 <quicksilver> whenJust :: Maybe a -> (a -> m()) -> m()
14:25:17 <quicksilver> although other choices exist.
14:25:25 <Sindriava> quicksilver: so the type is `whenJust :: Monad m => Maybe a -> (a -> m ()) -> m () ?
14:25:28 <Sindriava> ah, ninja'd
14:25:39 <Sindriava> Yeah, that doesn't feel like `when` though
14:25:42 <dfeuer> WTF, I think I got the wrong repository.
14:26:02 <Sindriava> :t forM_
14:26:04 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
14:26:07 <ski> Sindriava : .. are you looking for `forM_' ?
14:26:38 <Sindriava> quicksilver: You basically have a constrained forM_
14:26:40 <Sindriava> ski: I've mentioned it several times :)
14:27:05 <johnw> in fact, Data.Foldable.forM_ works on Maybe a values quite nicely
14:27:07 * ski didn't follow it
14:27:09 <johnw> with one exception
14:27:21 <avishai> Awesome. Thank you guys
14:27:21 <johnw> don't expect recursion from within the block to be efficient
14:27:42 <lpaste_> Cale pasted “ttt_fff try this program” at http://lpaste.net/141436
14:27:57 <ski> johnw, elaborate ?
14:28:08 <Cale> ttt_fff: ^^ can you tell me whether that fails to produce a correct "foo.out" file?
14:28:24 <ttt_fff> Cale: oh, sorry, I fixed it, it was due to some stupid terminal issue
14:28:33 <ttt_fff> where because it did not output an end of line, tmux was not displaying the file
14:28:36 <johnw> the "block" is a closure being passed as a function argument
14:28:43 <Cale> huh, interesting
14:28:43 <ttt_fff> Cale: where "cat tt \n" <-- no output, but "cat tt \n\n" <-- I get output
14:28:44 <ttt_fff> weird
14:28:47 <johnw> so recursion will keep making these closures
14:28:56 <johnw> it can't see the tail call and switch to iteration
14:29:12 <Cale> Ah, it's line buffering and is one line behind or something.
14:29:36 <ttt_fff> Cale: I don't know exactly, but yeah, those words sound right.
14:32:50 <Sindriava> johnw: Ooh, tricky
14:32:52 <quicksilver> Sindriava: it is precisely a constrained forM_
14:33:06 <quicksilver> Sindriava: I have been using it since before Foldable existed, I think.
14:33:28 <Sindriava> quicksilver: Yeah, my point was that naming it `whenX` is pretty misleading
14:33:30 <quicksilver> and because old habits die hard, I find the more explicit type (and name) comforting :)
14:33:48 <quicksilver> it's not misleading to me, it seems quite natural
14:33:54 <quicksilver> if you are doing something only in the Just case
14:33:55 <johnw> withX would fit the general pattern better
14:34:08 <quicksilver> it is natural to supply the unwrapped Just
14:34:28 <quicksilver> I think 'withX' should represent some more substantial setup/teardown
14:34:33 <quicksilver> like lock acquisition and release
14:34:36 <quicksilver> but what's in a name :)
14:34:49 <Sindriava> quicksilver: "not misleading to me" is the number #1 cause of misleading code ever
14:35:20 <Sindriava> Sometimes I wish we had if-let patterns, e.g. `if let Just v = maybeValue then x else y`
14:36:24 <quicksilver> Sindriava: misleading is an inherently subjective judgement, relative to the culture of the programming community
14:36:41 <quicksilver> whenJust was a very common idiom 7 years ago; it shows up in mailing lists posts and the source to XMonad
14:37:03 <quicksilver> would your if-let be refutable or irrefutable? how is it better than case?
14:38:24 <quicksilver> refutable surely; but then it looks like let but behaves like case
14:38:31 * ski . o O ( `let try <name> = <expr1> in <expr2> with <exception-handler>' <http://mjambon.com/extend-ocaml-syntax.html#lettry>,"Exceptional Syntax" by Nick Benton,Andrew Kennedy in 2001-07 at <http://research.microsoft.com/en-us/um/people/akenn/sml/exceptionalsyntax.pdf>,<http://lambda-the-ultimate.org/node/1193> )
14:38:49 <quicksilver> ski: yuck :)
14:39:13 * hackagebot yesod-angular 0.1.0.2 - Angular JS integratoin  https://hackage.haskell.org/package/yesod-angular-0.1.0.2 (ChristopherReichert)
14:39:15 * hackagebot roller 0.1.4 - Playing with applicatives and dice!  https://hackage.haskell.org/package/roller-0.1.4 (PiotrJustyna)
14:39:34 <Sindriava> quicksilver: Refutable, obviously
14:39:49 <Sindriava> It does behave like case, indeed.
14:40:00 <Sindriava> quicksilver: Then again, so does `if`.
14:40:18 <nitrix> Is there an easy way to get the exact same opposite of <$> on the Maybe Functor?
14:40:29 <quicksilver> yes, if is (occasionally controversial) sugar for Bool case
14:40:30 <Sindriava> nitrix: Opposite?
14:40:48 <nitrix> Aka, have a function to replace the Nothing by something else, instead of working with a Just value.
14:40:52 <Sindriava> quicksilver: if-let is a natural continuation of that train of though
14:40:56 <quicksilver> why would your "if let" be any better than case maybeValue  of Just v -> .... _ -> ....
14:41:19 <Sindriava> quicksilver: Why is `if` better than a bool case?
14:41:34 <quicksilver> it isn't :) but it's familiar to some people
14:41:48 <Sindriava> quicksilver: That might be your opinion, other might be of other opinions.
14:42:00 <nitrix> Sindriava: I'm loading many configuration options from a file (using a library), but the result from a lookup is a Maybe; I want to provide default values.
14:42:04 <Sindriava> quicksilver: Let me stop you there.
14:42:05 <quicksilver> you appeared to be asking me my opinion.
14:42:12 <nitrix> Sindriava: I might just write my little helper but I was still curious.
14:42:17 <quicksilver> nitrix: try fromMaybe
14:42:21 <Rembane> nitrix: maybe is a good function imo.
14:42:27 <Rembane> :t maybe
14:42:27 <quicksilver> > fromMaybe "default" Nothing
14:42:28 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:42:29 <lambdabot>  "default"
14:42:36 <Hijiri> :t maybe replacement id
14:42:37 <lambdabot> Not in scope: ‘replacement’
14:42:45 <quicksilver> > fromMaybe "default" (Just "real value")
14:42:46 <lambdabot>  "real value"
14:42:47 <nitrix> :t fromMaybe
14:42:49 <lambdabot> a -> Maybe a -> a
14:42:50 <Sindriava> nitrix: Yeah, either maybe or fromMaybe seem to do what you want
14:42:57 <Hijiri> oh yeah, fromMaybe
14:42:58 <nitrix> Yeah that's what I want. fromMaybe :)
14:43:33 <hnghfghfd> x59.noip.me hack please
14:43:37 <ski> quicksilver : i've actually wanted something like `catchBindE :: Monad m => ExceptT e0 m a -> (e0 -> ExceptT e1 m b) -> (a -> ExceptT e1 m b) -> ExceptT e1 m b'
14:44:06 <hnghfghfd> x59.noip.me hack please
14:44:51 <ski> hnghfghfd : do you have a Haskell-related question or comment ?
14:47:25 <Sindriava> @karma+ ski
14:47:25 <lambdabot> ski's karma raised to 38.
14:49:34 <ski> Sindriava ?
14:50:26 <cluzz> Hi, does anybody know about a function to transpose tuples of tuples?
14:50:34 <Sindriava> ski: Partly for contributing to the previous discussion and partly for managing such a response to hnghfghfd
14:50:59 <Sindriava> cluzz: Like `((a, b), (c, d)) -> ((d, c), (b, a))` ?
14:51:13 <Sindriava> @djinn ((a, b), (c, d)) -> ((d, c), (b, a))
14:51:14 <lambdabot> f ((a, b), (c, d)) = ((d, c), (b, a))
14:51:16 <cluzz> No, i mean from rows to columns
14:51:37 <Sindriava> cluzz: What do you really want to do? Is it matrix related?
14:52:02 <cluzz> Kind off... implementing tic tac toe for uni -.-'
14:52:13 <ski> @type (fst *** fst) &&& (snd *** snd)
14:52:14 <lambdabot> ((c, b), (c', b1)) -> ((c, c'), (b, b1))
14:52:16 <cluzz> I'd rather use lists but they force me to use tuples
14:52:48 <Sindriava> cluzz: Well, there's not a general way to treat tuples
14:53:20 <cluzz> Hmm, so i'll be writing it all out then ;) thanks
14:53:32 <Sindriava> cluzz: So you'll probably have to write that function yourself. I'd try thinking whether you can avoid transposing them
14:53:46 <Sindriava> cluzz: For matrix related operations, there's the always great `linear` package
14:54:08 <ski> @let fst3 (a,_,_) = a; snd3 (_,b,_) = b; thd3 (_,_,c) = c; tuple3 (f,g,h) x = (f x,g x,h x); cross3 (f,g,h) = tuple3 (f . fst3,g . snd3,h . thd3)
14:54:09 <lambdabot>  Defined.
14:54:29 <cluzz> Allright, i'll keep it in mind for when i have to do matrix operations. Thanks!
14:54:44 <ski> @type tuple3 (cross3 (fst3,fst3,fst3),cross3 (snd3,snd3,snd3),cross3 (thd3,thd3,thd3))
14:54:45 <lambdabot> ((t4, t5, t), (t6, t7, t1), (t8, t9, t2)) -> ((t4, t6, t8), (t5, t7, t9), (t, t1, t2))
14:54:52 <t7> ?
14:54:55 <Sindriava> cluzz: Also, let me rephrase my previous note: There's not a way to treat tuples of general lengths.
14:54:59 <Sindriava> t7 :D
14:55:05 <Sindriava> cluzz: Also, what ski said
14:55:21 <Sindriava> @djinn ((t4, t5, t), (t6, t7, t1), (t8, t9, t2)) -> ((t4, t6, t8), (t5, t7, t9), (t, t1, t2))
14:55:21 <lambdabot> f ((a, b, c), (d, e, f), (g, h, i)) =
14:55:21 <lambdabot>     ((a, d, g), (b, e, h), (c, f, i))
14:55:33 <ski> @let diag3 = tuple3 (id,id,id)
14:55:34 <lambdabot>  Defined.
14:55:57 <t7> @pl f ((a, b, c), (d, e, f), (g, h, i)) = ((a, d, g), (b, e, h), (c, f, i))
14:55:57 <lambdabot> (line 1, column 38):
14:55:57 <lambdabot> unexpected " "
14:55:57 <lambdabot> expecting operator
14:55:58 <ski> @type tuple3 (diag3 fst3,diag3 snd3,diag3 thd3)
14:55:59 <lambdabot>     Couldn't match expected type ‘t9 -> t’
14:55:59 <lambdabot>                 with actual type ‘((t0, t10, t20) -> t0,
14:55:59 <lambdabot>                                    (t0, t10, t20) -> t0,
14:56:22 <t7> @pl \((a, b, c), (d, e, f), (g, h, i)) -> ((a, d, g), (b, e, h), (c, f, i))
14:56:22 <lambdabot> (line 1, column 10):
14:56:22 <lambdabot> unexpected "c"
14:56:22 <lambdabot> ambiguous use of a non associative operator
14:56:40 <ski> hm, not polymorphic enough, i suppose
14:56:42 <cluzz> Rather weird, i saw that too on hackage
14:56:49 <t7> @pl \a -> [a]
14:56:50 <lambdabot> return
14:56:52 <cluzz> tuples defined up to 7 in length
14:57:18 <Sindriava> cluzz: Fun fact, GHC only supports tuples up to 62
14:57:41 <ski> @let newtype Cube3 a = MkCube3 (a,a,a) deriving Show
14:57:43 <lambdabot>  Defined.
14:58:00 <cluzz> really? so why is that? 62 seems arbitrary
14:58:00 <ski> er, skip the `3'
14:58:05 <ski> @let newtype Cube a = MkCube (a,a,a) deriving Show
14:58:07 <lambdabot>  Defined.
14:58:26 <ski> @let instance Functor Cube where fmap f (MkCube (a0,a1,a2)) = MkCube (f a0,f a1,f a2)
14:58:27 <lambdabot>  Defined.
14:58:54 <cluzz> O.o
14:59:20 <ski> @let instance Applicative Cube where pure a = MkCube (a,a,a); MkCube (f0,f1,f2) <*> MkCube (a0,a1,a2) = MkCube (f0 a1,f1 a1,f2 a2)
14:59:22 <lambdabot>  Defined.
15:01:06 <ski> @let instance Foldable Cube where foldMap f (MkCube (a0,a1,a2)) = f a0 <> f a1 <> f a2
15:01:09 <lambdabot>  Defined.
15:02:45 <ski> @let instance Traversable Cube where traverse f (MkCube (a0,a1,a2)) = MkCube <$> liftA3 (,,) (f a0) (f a1) (f a2)
15:02:48 <lambdabot>  Defined.
15:03:24 <sinelaw> anyone used the unification-fd package? trying to figure out what "freshen" does, documentation seems confusing
15:03:42 <ski> @let unCube (MkCube a) = a
15:03:45 <lambdabot>  Defined.
15:04:18 <sinelaw> pinging wrengr_away 
15:04:20 <ski> @type unCube . fmap unCube . sequenceA . fmap MkCube . MkCube
15:04:21 <lambdabot> ((t, t, t), (t, t, t), (t, t, t)) -> ((t, t, t), (t, t, t), (t, t, t))
15:04:34 <ski> > (unCube . fmap unCube . sequenceA . fmap MkCube . MkCube) ((0,1,2),(3,4,5),(6,7,8))
15:04:37 <lambdabot>  ((0,4,7),(1,4,7),(2,5,8))
15:04:43 <ski> cluzz ^
15:05:24 <arkeet> ski I think you messed up the applicative instance :-)
15:05:40 <cluzz> I have no clue xD sorry
15:05:41 <ski> er, i did
15:05:51 <ski> s/f0 a1/f0 a0/
15:06:46 <ski> > (unCube . fmap unCube . sequenceA . fmap MkCube . MkCube) ((0,1,2),(3,4,5),(6,7,8))  -- there
15:06:47 <lambdabot>  ((0,3,6),(1,4,7),(2,5,8))
15:06:59 <cluzz> O.o
15:07:04 <cluzz> like magic
15:07:25 <ski> it's basically the same idea as
15:09:02 <ski> > (getZipList . fmap getZipList . sequenceA . fmap ZipList . ZipList) [[0,1,2],[3,4,5],[6,7,8]]
15:09:04 <lambdabot>  [[0,3,6],[1,4,7],[2,5,8]]
15:09:29 <ski> (had to add the `Foldable' and `Traversable' instances for `ZipList', since they weren't there for some reason)
15:09:44 <cluzz> transpose [[0,1,2],[3,4,5],[6,7,8]]
15:10:05 <ski> > foldr (zipWith (:)) (repeat []) [[0,1,2],[3,4,5],[6,7,8]]
15:10:07 <lambdabot>  [[0,3,6],[1,4,7],[2,5,8]]
15:10:11 <ski> > transpose [[0,1,2],[3,4,5],[6,7,8]]
15:10:13 <lambdabot>  [[0,3,6],[1,4,7],[2,5,8]]
15:10:36 <cluzz> > transpose [[1,2],[3,4]]
15:10:38 <lambdabot>  [[1,3],[2,4]]
15:10:47 <cluzz> ah i see, the angled bracket ^^
15:10:48 <ski> that's what `sequenceA' amounts to, for `ZipList'
15:10:58 <cluzz> I got it now
15:11:04 <cluzz> thanks :D
15:11:04 <monochrom> interesting, I didn't think of transpose as a foldr
15:11:05 <ski> ("angled bracket" ?)
15:11:28 <cluzz> angled bracket for lambdabot
15:11:37 <monochrom> oh, the ">"
15:11:41 <ski> oh, you mean for `@run'
15:11:51 <cluzz> i was wondering why my input didn't run
15:12:31 <ski> arkeet : .. i didn't even notice, until you said
15:13:41 <Sindriava> @where manuel
15:13:41 <lambdabot> https://downloads.haskell.org/~ghc/7.4.1/docs/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html
15:13:43 <Sindriava> heh
15:15:07 <Gurkenglas> > ala ZipList traverse [[0,1,2],[3,4,5],[6,7,8]] -- ala does the unpacking for you, although it always needs a function "with a hook", like traverse instead of sequenceA
15:15:10 <lambdabot>  [[0,3,6],[1,4,7],[2,5,8]]
15:18:44 <ski> > ala ZipList traverse (map (: []) [[0,1,2],[3,4,5],[6,7,8]])
15:18:45 <lambdabot>  [[[0,1,2],[3,4,5],[6,7,8]]]
15:19:10 <ski> > ala ZipList traverse [[[0,1,2],[3,4,5],[6,7,8]],[[9,10,11],[12,13,14],[15,16,17]],[[18,19,20],[21,22,23],[24,25,26]]]
15:19:12 <lambdabot>  [[[0,1,2],[9,10,11],[18,19,20]],[[3,4,5],[12,13,14],[21,22,23]],[[6,7,8],[15...
15:19:15 * hackagebot luminance 0.1 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.1 (DimitriSabadie)
15:19:47 <ski> > ala ZipList traverse [[[0,1],[2,3]],[[4,5],[6,7]]]
15:19:49 <lambdabot>  [[[0,1],[4,5]],[[2,3],[6,7]]]
15:20:14 <ski> > ala ZipList traverse [[[[0,1],[2,3]],[[4,5],[6,7]]],[[[8,9],[10,11]],[[12,13],[14,15]]]]
15:20:16 <lambdabot>  [[[[0,1],[2,3]],[[8,9],[10,11]]],[[[4,5],[6,7]],[[12,13],[14,15]]]]
15:20:40 <c_wraith> :t ala ZipList traverse
15:20:41 <lambdabot> Traversable t => t [b] -> [t b]
15:20:59 <c_wraith> Whoa.  unsequence.
15:21:38 <arkeet> :t getZipList . traverse ZipList
15:21:39 <lambdabot> Traversable t => t [b] -> [t b]
15:21:46 <arkeet> :t \f -> getZipList . fmap f . traverse ZipList
15:21:47 <lambdabot> Traversable t => (t b -> a) -> t [b] -> [a]
15:24:04 <arkeet> @let zippy f = getZipList . fmap f . traverse ZipList
15:24:06 <lambdabot>  Defined.
15:24:09 <arkeet> > zippy id [[0,1],[2,3]]
15:24:11 <lambdabot>  [[0,2],[1,3]]
15:24:15 * hackagebot luminance-samples 0.1 - Luminance samples  https://hackage.haskell.org/package/luminance-samples-0.1 (DimitriSabadie)
15:24:22 <arkeet> > (zippy . zippy) id [[[0,1],[2,3]],[[4,5],[6,7]]]
15:24:24 <lambdabot>  [[[0,4],[1,5]],[[2,6],[3,7]]]
15:25:31 <arkeet> sort of like a 3d transpose. or something.
15:25:40 <arkeet> permutes the 3 dimensions of the array?
15:27:16 <Gurkenglas> Hmm. What remains is turning a permutation (e.g. [1, 5, 3, 2, 4]) into a "Free [] a -> Free [] a"
15:28:07 <ski> well, factoring a permutation into transpositions, first
15:28:10 <Gurkenglas> (With the "=n deep" invariant on the Free)
15:29:58 * ski . o O ( `data Hyper f a b = Fun (a -> b) | Map (Hyper f (f a) (f b))' )
15:30:34 <nitrix> What is the easiest way for multiple functions to share a mutable Map? I sadly cannot modif the type of those functions as they are event handlers for a library.
15:30:39 <Denommus> what is the recommended package for SDL?
15:31:03 <Gurkenglas> nitrix, do they have the same type?
15:31:04 <aweinstock> nitrix: what's the type signature you need to fulfill?
15:31:20 <Denommus> nitrix: can't you curry the map?
15:31:47 <ski> nitrix : `frob :: ... -> IO (.. -> ..,.. -> ..,.. -> ..)' ?
15:31:51 <Denommus> there are two packages for SDL in Hackage: SDL and sdl2. Which one to use?
15:31:51 <nitrix> Gurkenglas: aweinstock: They do: https://hackage.haskell.org/package/simpleirc-0.3.1/docs/Network-SimpleIRC-Core.html#t:EventFunc
15:32:03 <nitrix> type EventFunc = MIrc -> IrcMessage -> IO ()
15:32:20 <aweinstock> I'd think something like: let map = newIORef M.empty in let f = unsafePerformIO do { ... }; g = unsafePerformIO do { ...} in h f g
15:32:24 <arkeet> nitrix: they could share an IORef
15:32:32 <arkeet> you don't need unsafePerformIO
15:32:32 <ski> so `frob :: ... -> IO [EventFunc]', maybe ?
15:32:33 <Denommus> nitrix: if you have IO you're lucky, you can perform IO inside the function
15:33:20 <nitrix> My current solution uses an explicit parameter (I'm abusing currying) and an IORef.
15:33:46 <nitrix> Is there better? Reader monad, State? I know very little about those.
15:34:18 <aweinstock> if you can't change the type, then having them both be closures over an IORef sounds best
15:34:19 <ski> nitrix : staging ?
15:35:07 <Denommus> nitrix: those monads don't actually perform mutation
15:35:18 <Denommus> nitrix: they just hide the latest, but pure, state
15:35:44 <nitrix> Which would be fine by me.
15:36:03 <nitrix> Provider GHC is smart enough to re-use the map and not really copy it.
15:36:16 <nitrix> s/Provider/Provided/
15:37:00 <nitrix> (The IORef is a Map)
15:37:28 <aweinstock> nitrix: are the two callbacks communicating through the IORef Map? (should updates in 1 be visible in the other?)
15:38:00 <aweinstock> if so, I don't think there's any other way (aside from things like replacing IORef with MVar)
15:38:13 <Denommus> nitrix: a State (a pure State, that is, because you can have State transformers, which are kinda more complicated) is just a function s -> (a, s)
15:38:14 <nitrix> aweinstock: Yes. Although the library guarantee the event callbacks are executed sequentially.
15:38:28 <arkeet> just use an IORef imo
15:39:04 <nitrix> This just feel strange. If it was C, it'd be a top-level definition and I'd be done with it :/
15:40:10 <aweinstock> nitrix: are you familiar with the encoding of OOP-objects as mutable closures? (I've seen it in the context of lisp textbooks)
15:40:41 <Denommus> nitrix: you can have a toplevel IORef
15:40:45 <nitrix> aweinstock: No, but I have a decent imagination.
15:41:00 <nitrix> Denommus: the unsafe hack?
15:41:10 <aweinstock> if so, consider the IORef that's closed over to be the object's internal state, and each closure as a method on the object
15:41:25 <Denommus> nitrix: it doesn't need unsafe. But every time you must access or modify it, you need to do so inside a IO function
15:41:42 <Denommus> nitrix: since the function in question does perform IO, that's not a problem
15:41:58 <arkeet> you need unsafe to make a truly top level IORef though.
15:41:59 <nitrix> Denommus: Right. So what is your suggestion?
15:42:01 <aweinstock> Denommus: I thought creating the toplevel definition requires unsafePerformIO
15:42:11 <Gurkenglas> You'd think "IORef a -> State a () -> IORef a" or even "IORef a -> StateT a IO () -> IORef a" would be encouraged enough that it wouldn't require swapping a tuple.
15:42:27 <aweinstock> :t System.IO.Unsafe.unsafePerformIO (newIORef 'a')
15:42:28 <lambdabot>     Not in scope: ‘newIORef’
15:42:28 <lambdabot>     Perhaps you meant ‘newSTRef’ (imported from Data.STRef)
15:42:35 <Gurkenglas> -IORef +IO on each second one there of course
15:42:36 <aweinstock> :t System.IO.Unsafe.unsafePerformIO (Data.IORef.newIORef 'a')
15:42:37 <lambdabot> GHC.IORef.IORef Char
15:42:38 <Denommus> aweinstock: oh, wait
15:43:10 <Denommus> hm
15:43:16 <Denommus> nitrix: aweinstock is right
15:43:29 <Denommus> newIORef will always perform IO again when you join or bind it
15:43:31 <nitrix> I see, so that brings us back to aweinstock's suggestion then.
15:43:37 <aweinstock> :t modifyIORef
15:43:38 <lambdabot>     Not in scope: ‘modifyIORef’
15:43:38 <lambdabot>     Perhaps you meant one of these:
15:43:38 <lambdabot>       ‘modifySTRef’ (imported from Data.STRef),
15:44:05 <aweinstock> nitrix: my suggestion was to keep it as a closure over an IORef, and maybe think of it as an OOP object if that helps
15:44:22 <nitrix> Pretend my program state is the object and that my handlers are methods on that object. It's nothing quite like it, but it already is more familiar to me and comforting.
15:44:35 <Denommus> nitrix: wait a moment
15:44:45 <Denommus> nitrix: you could have something like that
15:45:38 <Denommus> nitrix: main = do { globalIORef <- newIORef <something>; actualEntryPoint globalIORef }
15:46:16 <Denommus> nitrix: every time you actually need it, you must curry it
15:46:25 <aweinstock> Denommus: that's what it sounds like he's already doing
15:46:28 <Denommus> nitrix: but you can't really run away from that, unless you use unsafePerformIO
15:46:33 <nitrix> Well, I think that's what I said, right?
15:46:38 <nitrix> :: State -> MIrc -> IrcMessage -> IO ()
15:47:02 <nitrix> In main, when I initialize the library, I feed all those handlers the state, leaving up the curried versions that the library is happy with.
15:47:11 <nitrix> :: MIrc -> IrcMessage -> IO ()
15:47:41 <mniip> did someone say mIRC?
15:47:59 <Xe> mniip: irc monad
15:48:01 <Xe> we're safe
15:48:05 <mniip> ah
15:48:06 <Denommus> nitrix: there's one more option
15:48:08 <mniip> phew
15:48:12 <exio4> MIrc doesn't look like a monadic action to me
15:48:20 <Denommus> nitrix: but you'd have to reengineer your whole program
15:48:24 <exio4> unless it's wraping one there, or so
15:48:28 <aweinstock> (let ((state initial-value)) (define (add x) (set! state (+ state x))) (define (get) state) (list add get)) -- counter object in scheme
15:48:31 <nitrix> Denommus: There's not much "whole" yet.
15:48:44 <Denommus> nitrix: instead of working with a mutable state, you use FRP to model time-varying values
15:49:16 <Denommus> nitrix: FRP makes it easier to work with global "mutable" state, but you'd have to think somewhat backwards
15:49:27 <aweinstock> haskell equivalent: let state = newIORef initialValue in let {add x = modifyIORef state (+x); get = readIORef x} in (add, get)
15:49:36 <Denommus> nitrix: because instead of modifying a value whenever an event happens, you do the other way around: you define the value in terms of the event
15:49:55 <exio4> nitrix: when working with my irc library, I gave up on the whole concept of callbacks
15:50:02 <exio4> while*
15:50:11 <mniip> on the while concept?
15:50:18 <exio4> while working :P 
15:51:01 <aweinstock> c++, with objects instead of closures: class counter { private: int state = initial_value; public: void set(int x) { state += x; } int get() { return state; }};
15:51:21 <aweinstock> oops, s/set/add/
15:51:51 <aweinstock> nitrix: do you see how the three examples are "the same", in some sense?
15:51:52 <mniip> haskell: counter :: (State Int (), State Int Int); counter = (modify (+1), get)
15:52:49 <aweinstock> mniip: the point wasn't demonstrating idiomatic haskell, it was about a specific encoding of OOP-objects as mutable closures
15:52:59 <nitrix> aweinstock: Omg.
15:53:03 <exio4> data Counter = Counter { get :: IO Int; add :: Int -> IO (); }  newCounter :: Int -> IO Counter ; newCounter initial_value = do { r <- newIORef initial_value; return (Counter (readIORef r) (modifyIORef' r . (1+))); } -- or something like this
15:53:03 <nitrix> I think it just clicked.
15:53:19 <exio4> oh you did it before 
15:53:36 <nitrix> aweinstock: I could do that, but then all my event handlers would need to be inside a `let in` expression.
15:53:54 <nitrix> Or `where` of greater function.
15:54:05 <aweinstock> nitrix: exio4 just demonstrated how to encode a constructor
15:54:16 * hackagebot GLM 0.3.0.0 - Simple Gridlab-D GLM parser and utilities.  https://hackage.haskell.org/package/GLM-0.3.0.0 (LyndonMaydwell)
15:54:33 <exio4> er. s/(1+)/(+)/ :P 
15:54:55 <aweinstock> the let .. in that I used was just how to create an "anonymous object"
15:55:50 <nitrix> That, is, brilliant.
15:56:18 <aweinstock> I think SICP might've been one of the lisp textbooks I read that has this
15:56:42 <aweinstock> maybe that's what people mean when they talk about SICP having mind-expanding insights in it?
15:56:50 <exio4> nitrix: I used a free monad for that on my library, note that it is a work-in-progress-never-going-to-be-finished project though, so it lacks primitives for async things
15:57:01 <EvanR> Regular -> SICP -> Haskell -> ???
15:57:56 <EvanR> some mind-expanding things in SICP are disappointing in retrospect like homoiconicity and meta circular evaluation
15:58:10 <nitrix> The only thing is, exio4's solution groups the operations with the counter, that's great, it takes care of the mutable part. I still have to give my handlers the counter, though?
15:58:40 <Denommus> nitrix: I thought you were aware of the object-closure equivalence XD
16:01:01 <aweinstock> nitrix: newObject :: IO (EventFunc, EventFunc); newObject = do { x <- newIORef ...; let f = ...; let g = ...; return (f, g)}
16:01:51 <aweinstock> all those lets and returns, hmm...
16:02:03 <aweinstock> :t fmap Data.IORef.newIORef
16:02:04 <lambdabot> Functor f => f a -> f (IO (GHC.IORef.IORef a))
16:02:18 <nitrix> I get the idea though.
16:02:22 <aweinstock> :t \x -> (Data.IORef.newIORef x >>=)
16:02:24 <lambdabot> a -> (GHC.IORef.IORef a -> IO b) -> IO b
16:02:54 <aweinstock> :t \f x -> fmap f (Data.IORef.newIORef x)
16:02:55 <lambdabot> (GHC.IORef.IORef a -> b) -> a -> IO b
16:03:03 <nitrix> I'll have a `events` function in IO that creates the state and returns all the event handlers.
16:03:14 <exio4> nitrix: https://github.com/EXio4/netza/blob/master/src/IRC/Raw/Monad.hs https://github.com/EXio4/netza/blob/master/src/IRC/Raw/Types.hs
16:03:15 <nitrix> And in the where clause, I'll define those.
16:03:37 <nitrix> Minor the one level identation, it'll be all clean and easy to work with.
16:04:10 <aweinstock> :t (<&>)
16:04:11 <lambdabot> Functor f => f a -> (a -> b) -> f b
16:05:07 <aweinstock> newObject x = newIORef x <&> (\state -> let {f = ...; g = ...} in (f,g)) -- This should work too
16:05:54 <aweinstock> how would I go about finding out where (<&>) is defined?
16:06:09 <nitrix> :info <&>
16:06:13 <nitrix> :info (<&>)
16:06:14 <exio4> if it is an operator, assume lens 
16:06:17 <glguy> It's in lens, but you could use hoogle to find that
16:06:23 <exio4> lambdabot has no info command
16:06:29 <aweinstock> @hoogle (<&>)
16:06:29 <lambdabot> No results found
16:06:33 <aweinstock> @hoogle <&>
16:06:33 <lambdabot> No results found
16:06:35 <glguy> lambdabot has an ?index command, but it doesn't know everything
16:06:42 <aweinstock> ?index (<&>)
16:06:43 <lambdabot> bzzt
16:06:49 <aweinstock> ?index <&>
16:06:49 <lambdabot> bzzt
16:06:57 <ski> @index (<*>)
16:06:57 <lambdabot> Control.Applicative, Prelude, Compiler.Hoopl
16:07:27 <aweinstock> @hoogle (&)
16:07:27 <lambdabot> Data.Graph.Inductive.Graph (&) :: DynGraph gr => Context a b -> gr a b -> gr a b
16:07:27 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
16:07:27 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
16:07:41 <nitrix> <&> really isn't on Hoogle, I tried manually. Strange.
16:07:46 <aweinstock> I thought (&) was used for (flip ($))?
16:07:58 <glguy> among other things
16:08:18 <aweinstock> (and by analogy, (<&>) for (flip (<$>)))
16:08:21 <ski> > let (&) = 8 in (&)^2
16:08:22 <glguy> https://www.haskell.org/hoogle/?hoogle=%2Blens+%28%3C%26%3E%29
16:08:23 <lambdabot>  64
16:08:32 <glguy> It's on Hoogle, you just have to know where it is to find it :)
16:15:04 <Denommus> is stack really worth my effort?
16:18:10 <AfC> Denommus: uh, what effort?
16:18:24 <AfC> Denommus: it basically just works.
16:18:47 <MarcelineVQ> It's no more effort than cabal already is, afaik
16:21:34 <AfC> Less, because a wide number of problems won't arise (for the cost of having to do things its way. Most of the time you just don't notice).
16:36:40 <Denommus> AfC: installing it, for instance XD
16:37:01 <Denommus> AfC: it's requiring libtinfo-5, which requires ncurses<6, which... no longer exist in Arch
16:40:53 <Shockk> hmm I have another question about DataKinds stuff
16:42:11 <Shockk> I want to write something a little bit like this (probably very wrong code, but it demonstrates what I'm trying to do):
16:42:22 <Shockk> HasType :: * -> [*] -> Bool
16:42:56 <Shockk> takes a type and a list of types, and returns something to signify true/false depending on whether or not the type is in the list
16:43:11 <jle`> Shockk: in one era we'd use MPC's for that
16:43:17 <jle`> nowadays you might be able to use a type family too
16:44:06 <Shockk> what kind of thing would I return for this though, if I'm returning a type and not a value?
16:44:21 <jle`> if you use type families, you'd be returning a lifted Bool
16:44:21 <Gurkenglas> :t fmap fromJust $ runMaybeT $ ?a <|> lift ?d -- Should I use fromJustNote here? It feels mathematically superfluous, but then that could also be said in a note
16:44:23 <lambdabot> (Monad f, ?a::MaybeT f b, ?d::f b) => f b
16:44:23 <mniip> :k True
16:44:25 <lambdabot> Bool
16:44:33 <Shockk> oooh
16:44:35 <jle`> if you used an multi-parameter typeclass, you'd be returning a Constraint
16:44:56 <Shockk> I didn't think to check if Bool was promoted to a datakind 
16:44:59 <xyh> when using the git version of yi
16:44:59 <xyh> it says:
16:44:59 <xyh> /home/xyh/.config/yi/yi.hs:1:8:
16:44:59 <xyh>     Could not find module ‘Yi’
16:45:01 <mniip> jle`, but bools and constraints are 2 very differnt things
16:45:02 <xyh>     Use -v to see a list of the files searched for.
16:45:04 <Shockk> so I can use 'True and 'False?
16:45:05 <xyh> where should i 'Use -v' ?
16:45:15 <mniip> jle`, classical logic vs constructivist
16:45:38 <jle`> yeah, which way Shockk should go down depends on what he actually wants to do with it
16:46:24 <jle`> or she
16:46:35 <Shockk> oh, I'm a he
16:47:42 <Shockk> also I don't specifically need HasType that results in true/false, but I thought that'd be a good starting point to understand how to do that kind of thing
16:47:45 <jle`> class HasType (t :: *) (ts :: [*])
16:47:53 <jle`> instance HasType t '[]
16:47:59 <jle`> um
16:48:01 <Shockk> what I really want to do is find a way to write a lookup function for the PolyMap type I'm making
16:48:26 <jle`> any further and i'll have to have ghc ready to make sure i'm doing it right v.v
16:48:31 <mniip> then you want a regular function
16:48:39 <jle`> ^^
16:48:51 <mniip> your PolyMap is a GADT if I recall correctly
16:49:23 <Shockk> ah nope, I tried to make it a GADT but after I did that I couldn't derive a Show instance, as far as I could tell
16:49:27 <mniip> actually there's an issue
16:49:35 <mniip> Shockk, may I have a look
16:49:50 <Shockk> at the current code or the GADT I tried?
16:49:55 <mniip> either
16:51:05 * Shockk hastily commits and pushes current code
16:51:17 <Shockk> https://github.com/shockkolate/hs-polymap/blob/master/src/Data/PolyMap.hs
16:53:19 <Shockk> this is the GADT I tried
16:53:21 <Shockk> http://lpaste.net/141434
16:54:34 <Dillard> What do you guys think of my research proposal ? http://pastebin.com/tpFGg3sH Anti-Virus Evasion
16:54:39 <Dillard> oops
16:54:50 <Dillard> i wanted to post in haskell-blah
16:59:34 <xyh> when using '.cabal-sandbox/' I also need to add new module search path to GHC ?
17:00:00 <Shockk> xyh: invoke ghc with cabal exec to have cabal set those options correctly
17:00:12 <mniip> Shockk
17:00:21 <xyh> oh! I see :: https://groups.google.com/forum/#!topic/yi-devel/_DMkDLwlY8A
17:00:27 <Shockk> like for example '$ cabal exec ghc-pkg list' will list packages including ones installed in the sandbox
17:00:30 <Shockk> mniip: hello
17:00:34 <lpaste_> mniip pasted “instance Show PolyMap” at http://lpaste.net/141441
17:01:36 <Shockk> hmm
17:01:42 <mniip> you could totally avoid the auxiliary class if you allowed FlexibleInstances FlexibleContexts
17:02:15 <mniip> also I messed up the precedences herre
17:02:17 <mniip> here
17:02:39 <mniip> showParen should be > not >=
17:06:16 <Shockk> mniip: ah I see now
17:08:23 <Shockk> mniip: hmm, how would I do that lookup function with just a regular function like you said?
17:08:40 <mniip> what type
17:09:32 <Shockk> what I want to try and get is a lookup function that I can use from any side of the polymap to any other side of the polymap
17:09:43 <Shockk> I realize that sounds slightly ridiculous 
17:09:57 <sinelaw> dmwit, there? got a question about unification-fd
17:10:23 <mniip> Shockk, err?
17:12:17 <Shockk> one thing I was thinking of was maybe to do something like have the PolyMap hold its size as a Nat type literal, and something like have the lookup function take a Nat for which side of the polymap to lookup the key by
17:13:08 <mniip> maybe I'm not understanding what is the intuition behind the PolyMap type...?
17:13:20 <Shockk> like, what its purpose is?
17:14:10 <mniip> no, what do its values represent
17:16:10 <Shockk> oh, hmmm, well UnitPolyMap is a polymap with no 'sides', in other words, the list of types that are mapped between is an empty list so it holds no data,
17:17:06 <Shockk> [a] :<=>: PolyMap as   -   [a] is the list of keys on a single side of the polymap
17:18:01 <mniip> so it's a relation?
17:18:34 <Shockk> so like a pseudocodey bimap of Int <=> String would be like:   [Int] :<=>: ([String] :<=>: UnitPolyMap)
17:19:04 <Shockk> that definition is kind of loose, bear in mind, because I'm still learning about how type level stuff works as I write it
17:19:10 <mniip> is it a polyadic relation, or a polyjection?
17:19:48 <Shockk> what's a polyjection?
17:19:58 <mniip> like bi-jection, but poly
17:20:29 <harwiltz> hey can someone help me with a frustrating problem in my code?
17:20:59 <harwiltz> I'm trying to make a function that converts an amount of money into the least amount of coins
17:21:01 <mniip> harwiltz, don't ask to ask
17:21:09 <harwiltz> mniip, thanks
17:21:15 <Shockk> hmm.. I'm not sure which of those it is
17:21:26 <harwiltz> So should I send it line by line? It's only 5 lines long
17:21:27 <Shockk> I don't fully understand the concepts
17:21:39 <mniip> Shockk, [1,2] :-: [True, True] :-: PNil
17:21:52 <mniip> is a 2-place relation, but not a bijection
17:22:34 <harwiltz> makeChange :: Num a => a -> (a -> [a] -> [a]) -> [a]
17:22:36 <Shockk> oh, because it's not a 1:1 correspondence?
17:22:42 <mniip> yes
17:22:56 <mniip> relations are just sets of unique tuples
17:22:57 <harwiltz> makeChange m = let list = [200,100,25,10,5,1]
17:23:03 <harwiltz> in calculateChange m list
17:23:09 <mniip> bijections ensure that for every A there's exactly one B, and vice versa
17:23:40 <harwiltz> where calculateChange money (x:xs) = (floor(money/x)):(calculateChange (money `mod` x) (xs))
17:23:53 <harwiltz> And I'm getting that calculateChange is being applied to too many arguments
17:24:26 <Shockk> I haven't thought about that specifically very much, and it's probably something I should think about 
17:25:10 <mniip> [02:17:36] <harwiltz> makeChange :: Num a => a -> (a -> [a] -> [a]) -> [a]
17:25:26 <mniip> that signature seems wrong
17:25:27 <harwiltz> mniip, that's what I wrote
17:25:33 <harwiltz> mniip, yea I thought so hahaha
17:25:53 <harwiltz> mniip, Is it because of Num, or because of the whole thing in general?
17:26:28 <mniip> you take a function turning a number and a list into a list, and that function in combination with a number gives you a list of numbers
17:26:31 <Shockk> ultimately I want to use Set instead of [], so in that case the elements would be unique, although I want to do so through a typeclass for the type of storage, so I can have a set on one side of the map and a multiset on some other side
17:26:42 <harwiltz> mniip, thats right
17:26:58 <mniip> Shockk, so why are you storing your polymap in such a /transposed/ way
17:27:53 <Shockk> transposed?
17:27:54 <harwiltz> mniip, both numbers in the type signature represent the same number. Just that I pass it from the big function into the subfunction
17:28:51 <mniip> harwiltz, why would makeChange take a function as argument
17:29:01 <harwiltz> makeChange takes just a number
17:29:03 <hunteriam> How does one develop a package with stack? Is there a guide anywhwere, i couldnt find one
17:29:12 <harwiltz> but it passes that number into another function (calculateChange)
17:29:24 <mniip> harwiltz, right
17:29:38 <mniip> and what does calculateChange have to do with the type signature
17:29:42 <harwiltz> mniip, so I don't have to declare the other function (calculateChange) in the type signature?
17:30:18 <mniip> no, why would you
17:30:27 <Shockk> I've got to go afk now actually, sorry
17:30:33 <mniip> a type signature is a declaration of what arguments does your function take, and what it returns
17:30:37 <harwiltz> mniip, I was reading a book and I thought it said I had to. Thanks
17:30:52 <harwiltz> mniip, so it should be Num a => a -> [a]
17:30:54 <mniip> yes
17:31:08 <mniip> harwiltz, what book if I may
17:31:08 <harwiltz> mniip, Ok, thanks a lot, I'll try it
17:31:15 <harwiltz> mniip, Real World Haskell
17:31:23 <harwiltz> I probably misunderstood something
17:31:39 <mniip> I wonder what path of logical thought lead you to this
17:31:45 <mniip> chapter/location?
17:32:14 <harwiltz> mniip, Chapter 4. There was a function that had another function inside it, and it looked like the other function was declared in the type signature
17:32:39 <harwiltz> mniip, That's where I got the idea of putting stuff in parentheses. I didn't make it up, I probably just misunderstood.
17:33:10 <mniip> harwiltz, that's probably because the "function inside it" was actually passed as argument
17:33:18 <harwiltz> mniip, probably
17:33:22 <mniip> like for example how 'map' does it
17:33:33 <mniip> like I said, [02:25:34] <mniip> a type signature is a declaration of what arguments does your function take, and what it returns
17:33:59 <gpacheco> Hi, I'm having a design doubt. If I'm going to make an applicative parser, for example using uu-parsinglib, is it a good idea to use Alex to parse the tokens first, or is it considered ok to just use the parsing combinators even for Lexer?
17:34:12 <harwiltz> mniip, thanks, I get it now. I got another error but I think this one I can fix haha
17:34:23 <mniip> parentheses are just... parentheses, they're there for the same reason as we write (1 + 2) * 3 with parens
17:35:32 <harwiltz> now it's saying to add RealFrac a to the context of the type signature
17:35:34 <emmanuel_erc> hello there everyone..
17:36:15 <mniip> harwiltz, it's because you're using floor and /
17:36:26 <mniip> you should be using something else instead
17:36:28 <hunteriam> in ghci how do you write a line with "b :: String; b = "string""
17:36:33 <hunteriam> it says ; is unrecognized
17:36:36 <mniip> hunteriam, let ...
17:37:08 <hunteriam> does not work
17:37:10 <hunteriam> mniip: 
17:37:12 <hunteriam> afaik
17:37:32 <mniip> how much do you want to bet
17:37:42 <emmanuel_erc> I just wrote (what I believe to be) a now testable version of some code I've been working on.
17:37:43 <hunteriam> i really just want to know how i was supposed to do it
17:37:44 <hunteriam> not bet
17:37:52 <mniip> [02:32:10] <hunteriam> does not work
17:37:56 <mniip> it does very well work
17:38:00 <emmanuel_erc> It isn't anything special but I would like to know how I could improve it speed wise.
17:38:01 <hunteriam> ok..
17:39:40 <lpaste_> emmanuel_erc pasted “Simple code” at http://lpaste.net/141445
17:45:28 <emmanuel_erc> If anyone would be able to gve me a few pointers, I would greatly appreciate it!
17:45:41 <harwiltz> mniip, I got it! Thanks for the help. Never saw the quot function before but that solved the issue
17:46:03 <mniip> harwiltz, general advice: use div with mod, and quot with rem
17:46:12 <mniip> otherwise it's mixing pepsi with coke
17:46:18 <harwiltz> mniip, what's rem?
17:46:29 <harwiltz> nevermind lol
17:46:43 <mniip> > quotRem -5 3
17:46:44 <lambdabot>      Could not deduce (Num a0)
17:46:44 <lambdabot>      from the context (Integral a,
17:46:44 <lambdabot>                        Num a1,
17:46:55 <mniip> > quotRem (-5) 3
17:46:56 <lambdabot>  (-1,-2)
17:46:58 <mniip> > divMod (-5) 3
17:46:59 <lambdabot>  (-2,1)
17:47:04 <mniip> observe the difference
17:47:16 <Sindriava> …oh. OH.
17:47:19 <Sindriava> > otherwise
17:47:20 <lambdabot>  True
17:47:26 <harwiltz> mniip, Yup, I just changed it. Thanks a lot for your help
17:47:47 <mniip> Sindriava, yes
17:48:51 <Sindriava> I always find it funny how little stuff in Haskell is actual syntax
17:49:18 <Sindriava> and how much stuff is just stuff from prelude
17:49:34 <mniip> @src Bool
17:49:35 <lambdabot> data Bool = False | True deriving (Eq, Ord)
17:49:40 <Sindriava> Yeah
17:49:48 <Sindriava> @src [a]
17:49:49 <lambdabot> Source not found. Maybe you made a typo?
17:49:51 <dmwit> sinelaw: pong
17:49:51 <Sindriava> aw
17:49:53 <johnw> funny :: (HowLittle a, a ~ syntax) => There -> really is; funny that@~(is _) | to _me <- I guess = :)
17:51:49 <Sindriava> johnw: What you wrote still contains a *lot* less syntax than a common C++ sample IMO
17:51:50 <mniip> johnw, forgot {} and indentation blocks, do, let, if, case
17:51:58 <harwiltz> does anyone know how to stop GHCi from warning me about Tab characters?
17:52:10 <Welkin> harwiltz: don't use tabs
17:52:10 <Sindriava> harwiltz: Stop using tab characters :D
17:52:10 <mniip> ! `infix` $() 
17:52:15 <Welkin> harwiltz: it will cause problems
17:52:24 <harwiltz> But then isn't code ugly?
17:52:28 <Welkin> no
17:52:29 <johnw> Sindriava: is that unique syntax, as I just did, or do you mean C++ just using lots of it?
17:52:30 <mniip> harwiltz, {-# OPTIONS_GHC -fno-warn-tabs #-}
17:52:33 <Welkin> use spaces
17:52:38 <Welkin> have your editor convert tabs to spaces
17:52:40 <Sindriava> harwiltz: What do tabs have to do with appearance?
17:52:43 <johnw> mniip: yeah, it wasn't exhaustive :)
17:53:01 <harwiltz> Sindriava, if there's no tabs code is often hard to read
17:53:14 <Sindriava> harwiltz: I think you're confusing tabs with indentation.
17:53:38 <harwiltz> Sindriava, evidently I am, I just don't understand why tabs should cause issues
17:53:47 <mniip> because some people misuse tabs
17:53:51 <mniip> and mix them with spaces
17:53:51 <Welkin> harwiltz: haskell is whitespace sensitive
17:54:04 <Sindriava> harwiltz: They don't have the same width everywhere.
17:54:27 <harwiltz> Ok, so I just have my editor replace tabs with spaces?
17:54:28 <Sindriava> harwiltz: They are used for tabulation. Indentation is arguably not tabulation.
17:54:44 <Sindriava> harwiltz: Yep. `expandtab` in Vim IIRC
17:54:51 <harwiltz> really?
17:54:54 <harwiltz> thats easy hahaha
17:54:59 <Axman6> harwiltz: tabs in haskell are defined to be at 8 character tabstops, most editors render them as 4 by default, or any other number, which means that code that looks right is actually grossly misaligned
17:55:00 <harwiltz> and how did you know I use vim?
17:55:07 <broma0> anyone ever have postgresql-simple hang?
17:55:23 <harwiltz> Axman6, thanks, that explains it!
17:55:28 <mniip> Axman6, writing moronic tabwidth-dependent code is not an excuse!
17:55:47 <Welkin> broma0: what do you mean? The connection?
17:55:49 <Sindriava> harwiltz: Because you said editor and not IDE :D
17:55:54 <Sindriava> johnw: I mean that in languages like C++ have a lot of arbitrary rules that you just have to remember
17:56:09 <harwiltz> Sindriava, fair enough! Thanks, I'll go try it out now
17:56:10 <broma0> Welkin: i get the connection just fine, but when i try to run a query it just hangs indefinitely
17:56:20 <broma0> the query is dead simple too
17:56:22 <dmwit> harwiltz: You may like http://dmwit.com/tabs, which includes advice for configuring your editor.
17:56:25 <dmwit> Then again, you may not.
17:56:30 <dmwit> mniip: I mix tabs and spaces. =)
17:56:32 <Sindriava> johnw: Haskell has surprisingly little of that. Parametric types behave like type-level functions. Functions are just parametrised values and use = for definition too.
17:56:49 <Sindriava> johnw: Bool is properly defined in Haskell, not a language feature.
17:56:53 <harwiltz> dmwit, thanks, I'll check it out!
17:57:21 <johnw> Sindriava: oh ho, you are so dead right about that
17:57:25 <emmanuel_erc> hello again.
17:57:31 <Welkin> broma0: I have never used postgresql-simple directly
17:57:37 <mniip> dmwit, I always write indented blocks entirely on their own line
17:57:52 <emmanuel_erc> I just posted some code to lpaste. I would like to ask for some pointers on making it run faster.
17:57:53 <johnw> Sindriava: I used to implement the C++ standard for a living; I'll take System FC with a bunch of sugary extensions on top any day of the week
17:57:58 <dmwit> mniip: That is one of the styles I mark as "acceptable" in my discussion. =)
17:58:09 <Welkin> broma0: can you enter the shell and execute sql queries?
17:58:13 <dmwit> mniip: Though that's not quite enough.
17:58:25 <dmwit> mniip: See, e.g., the problem of do blocks in (aligned) lists discussed on my page.
17:58:44 <mniip> dmwit, it's sad that we have to suffer because of tabwidth-dependent morons
17:58:50 <Sindriava> johnw: When you look at a simple C++ hello world, there's actually a *lot* going on
17:59:01 <Welkin> mniip: you mean harwiltz? 
17:59:29 <mniip> Welkin, no I mean dmwit
17:59:53 <harwiltz> Welkin, who said I'm tabwidth dependent? I'm just used to pressing tab to indent my code
17:59:56 <mniip> [02:51:51] <Sindriava> johnw: Bool is properly defined in Haskell, not a language feature.
17:59:59 <mniip> welll actualllly
18:00:07 <mniip> it's not
18:00:15 <lpsmith> broma0, unix or Windows?
18:00:16 <mniip> it's a wired in datatype
18:00:25 <Sindriava> mniip: Oh yeah, I should have phrased that better
18:00:29 <mniip> things like 'if' and guards require it to work
18:00:48 <Sindriava> mniip: What I mean was that it *can* be properly defined, which is what matters
18:01:00 <mniip> well it won't be the condition type of 'if' though
18:01:13 <dmwit> mniip: Are you saying I am a tabwidth dependent moron?
18:01:22 <mniip> no
18:01:34 <mniip> I'm saying that the reason tabs are taboo in haskell
18:01:53 <broma0> lpsmith: linux
18:01:57 <mniip> is because some people misuse them
18:02:11 <Sindriava> mniip: Fair enough, yeah. I guess the most accurate way of saying it would be that "The way Bool works in Haskell can be accurately conveyed with compact Haskell code", maybe?
18:02:12 <dmwit> ah, right, yes, agreed
18:02:23 <lpsmith> broma0, hmm, strange, what version of postgresql, libpq, and postgresql-simple are you using?
18:02:41 <pikajude> to be fair, you can use RebindableSyntax and define your own Bool
18:02:50 <lpsmith> Also, what version of GHC?
18:02:57 <mniip> pikajude, guards
18:03:10 <mniip> or do those translate to ifThenElse too
18:03:53 <broma0> postgres: 9.4.4, postgresql-simple 0.5.0.0
18:04:05 <broma0> lpsmith: postgres: 9.4.4, postgresql-simple 0.5.0.0
18:04:07 <pikajude> mniip: afaik rebindable syntax indicates that all the syntax can be rebound
18:05:05 <mniip> pikajude, there's a strict list of rebound things
18:05:12 <zaquest> is anyone using Yi here? can not figure out how to imap in vim keymap
18:05:21 <lpsmith> broma0: what version of GHC?
18:05:24 <evanbd> I'm having trouble figuring out performance on a recursive function definition.
18:05:28 <evanbd> http://lpaste.net/141446
18:05:34 <broma0> lpsmith: 7.10
18:05:43 <evanbd> Should run in O(n^(3/2)), I think it's running in exponential time
18:05:54 <evanbd> Any pointers as to why would be awesome :)
18:06:22 <broma0> lpsmith: id expect it to throw an error somewhere.. I believe the DB itself is working fine because psql works as expected
18:06:28 <Welkin> broma0: 7.10.1 or 7.10.2?
18:06:34 <Welkin> I know 7.10.1 has issues
18:06:56 <Welkin> not that I have any idea what is wrong :P
18:06:58 <lpsmith> broma0, what's your transport?  unix sockets, loopback,  local area network,  WAN?   And if loopback or network,  SSL or no?
18:08:24 <broma0> Welkin: 7.10.1-2
18:08:35 <evanbd> (I'm assuming it's repeatedly recomputing the intermediate results, though it shouldn't need to.)
18:08:52 <dmwit> evanbd: Perhaps you are expecting partitions to be memoized. This is a common beginner misunderstanding.
18:09:21 <dmwit> evanbd: If you want memoization, you'll have to do it yourself. There are libraries to help, though in this case there's probably a nice compact way to do it with a lazy list.
18:09:24 <broma0> lpsmith: now you're pushing my knowledge.. not entirly sure the answer to that. I didn't do any configuring for the db isntallation and I'm using the defaultConnectInfo excluding the dbname/user
18:09:33 <evanbd> dmwit: Yeah, that's probably it.
18:10:08 <dmwit> evanbd: This may also be a case of wanting to give a monomorphic type to statically choose the Num instance.
18:10:17 <dmwit> evanbd: So you might try that first and see if that gets it "fast enough" for you.
18:10:24 <evanbd> dmwit: ok, thanks
18:10:25 <lpsmith> broma0:  ok,  then you are using loopback
18:10:59 <lpsmith> probably SSL
18:11:17 <Welkin> broma0: what is the dna sequence of the third gene in your chromosomes from the direction of the Andromeda galaxy right now?
18:11:44 <broma0> Welkin: ACGTGGCAAGTC
18:12:56 <lpsmith> broma0, well, I'm grasping at straws now,  but you _might_ try disabling SSL and/or connecting over unix sockets.   See the connectPostgreSQL function for a brief intro to the connection stuff.
18:13:12 <hunteriam> is there anyway to run a project with stack
18:13:17 <evanbd> dmwit: re: typing, you mean add "partitions :: Integer -> Integer" lines for each of the lists / functions?
18:13:36 <evanbd> dmwit: No luck there, will see about doing it as a lazy list
18:13:37 <Welkin> hunteriam: stack run?
18:13:55 <Welkin> hunteriam: or some variation of stack exec -- <command>
18:14:03 <lpsmith> broma0, also, I would appreciate if you could open a github issue on this:   https://github.com/lpsmith/postgresql-simple/issues
18:14:05 <Welkin> I haven't tried stack yet myself
18:14:36 <hunteriam> Welkin: how do i figure out my program name in stack?
18:14:39 <hunteriam> i dont remember naming it...
18:15:18 <Welkin> no idea
18:15:31 <broma0> lpsmith: i'll open an issue. 
18:15:38 <Welkin> there should be documentation somewhere about stack
18:15:41 <lpsmith> Don't worry too much about writing the issue;  start with what you know,  and we can flesh the info out as needed.   (I'll probably ask for a packet capture,  but I'll try to help guide you through that on github.)
18:15:47 <Welkin> I constantly see people confused and asking questions about it
18:15:51 <Welkin> this is a problem
18:15:54 <broma0> lpsmith: thank you for your help though, i really appreciate it. are you a contributer to that project?
18:16:00 <lpsmith> yup.
18:19:22 * hackagebot postgresql-simple 0.5.0.1 - Mid-Level PostgreSQL client library  https://hackage.haskell.org/package/postgresql-simple-0.5.0.1 (LeonSmith)
18:23:03 <evanbd> dmwit: Lazy list version works! Thanks!
18:23:10 <lpsmith> broma0, you are welcome,  and yes I am.
18:33:28 <Shockk> :k 0
18:33:29 <lambdabot> GHC.TypeLits.Nat
18:38:05 <pikajude> :k *
18:38:06 <lambdabot> parse error on input ‘*’
18:38:39 <Gurkenglas> evanbd, are you using !! to look up memoized values in the list? If so, you should get another O-improvement by using https://hackage.haskell.org/package/memoize-0.7/docs/Data-Function-Memoize.html#v:memoFix
18:40:22 <Gurkenglas> (Why does that doc show a big list of instances but clicking on source shows a stub?
18:40:24 <Gurkenglas> *)
18:52:58 <Axman6> Gurkenglas: they may be implemented in modules imported by that module
19:16:18 <Gurkenglas> Axman6, https://hackage.haskell.org/package/memoize-0.7/docs/src/Data-Function-Memoize-Class.html#Memoizable doesn't seem to import any modules
19:18:12 <benl23> Does anyone know what the deal is with Hackage still building everything with GHC 7.8.3? All my libs need 7.10, so the Hackage docs don't build
19:22:18 <erikd> benl23: you may get a better answer on #haskell-infrastructure
19:22:31 <benl23> erikd: ok, thanks
19:23:49 <Cale> benl23: this might be useful to you: http://neilmitchell.blogspot.ca/2014/10/fixing-haddock-docs-on-hackage.html
19:24:03 <Cale> http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html says how to do it more manually
19:25:51 <broma0> lpsmith: hey, still around?
19:26:37 <benl23> Cale: thanks
19:27:50 <broma0> anyone know if the <db>-simple libs run queries lazily? i asked about an issue where postgresql-simple  hung indefinitely earlier, and i can now say i have the same issue with sqlite-simple
19:30:11 <exio4> broma0: sqlite-simple offers a few functions that may be helpful for that
19:30:52 <exio4> https://hackage.haskell.org/package/sqlite-simple-0.4.9.0/docs/Database-SQLite-Simple.html#g:14 
19:31:50 <broma0> exio4: streaming results?
19:32:49 <exio4> (the `low-level` api of sqlite may be helpful too)
19:33:02 <exio4> broma0: what did you mean by lazily?
19:33:51 <jasonkuhrt> Has there ever been a feature request/disucssion to support the question mark '?' in identifier names?
19:34:11 <jasonkuhrt> e.g.: a function name called:   odd?
19:34:55 <cmccann> jasonkuhrt: ? is supported in identifier names today, you just have to use symbols for the rest of the name :P
19:35:16 <jasonkuhrt> cmccann: : s
19:35:17 <jasonkuhrt> haha
19:35:40 <jasonkuhrt> Its a pretty darned useful _feature_ I think, having had to read clojure code and such
19:35:49 <jasonkuhrt> it just makes sense, at least IMO
19:35:53 <jasonkuhrt> maybe I'm missing something
19:36:03 <cmccann> which is also why that request probably won't fly, for better or worse. there's already code out there using ? in operators and changing the parsing rules could cause unknown breakage.
19:36:04 <jasonkuhrt> no language does it other than clojure, not sure why
19:36:10 <dmj`> @def odd = not . even
19:36:11 <lambdabot>  Defined.
19:36:42 <exio4> jasonkuhrt: scheme :) 
19:36:47 <cmccann> jasonkuhrt: pretty sure I remember doing that in scheme too
19:36:49 <Chobbes>  jasonkuhrt lots of lispy scheme things allow it.
19:37:04 <jasonkuhrt> cmccann: In all honesty the parsing rules for supporting ? in idents seems trivial at first thought but again I didn't think hard about this
19:37:13 <Chobbes> jasonkuhrt: the problem is we use symbols for operators.
19:37:20 <cmccann> jasonkuhrt: the parsing rules aren't the problem, it's changing the parsing rules that's the problem.
19:37:29 <Chobbes> And spacing doesn't matter e.g., 1+3
19:37:54 <jasonkuhrt> Oh...
19:38:07 <broma0> exio4: i'm just trying to figure out why all of my queries hang indefinitely, and i was wondering if it was an issue with lazy io
19:38:08 <jasonkuhrt> so we cannot tell the difference between say
19:38:18 <Chobbes> jasonkuhrt: I mean, it'd be trivial to change, but it would kind of interfere with things.
19:38:19 <jasonkuhrt> `foo?bar` and `foo ? bar`
19:38:30 <Chobbes> ident1?+indent2
19:38:32 <broma0> exio4: i just noticed that GHC ends up taking up nearly 100% of the memory after hanging for a while
19:38:38 <cmccann> jasonkuhrt: under current parsing rules those are the same, right
19:38:47 <Chobbes> Is that the operator ?+ or what? It'd be ambiguous.
19:38:47 <jasonkuhrt> ouch, ok
19:38:53 <cmccann> jasonkuhrt: allowing ? in alphanumeric identifiers would obviously change that
19:39:07 <exio4> broma0: GHC? are you running this under GHCi?
19:39:21 <exio4> broma0: also, I don't know the code not the actual problem more than "it uses all my memory" 
19:39:47 <broma0> broma0: it occurs both in ghci and when i compile and run it
19:39:52 <Chobbes> jasonkuhrt: the other thing to think about is some GHC extensions like PostfixOperators.
19:39:55 <broma0> ha, whoops
19:40:03 <cmccann> Chobbes: I'm assuming that jasonkuhrt's suggestion is to make ? like ' and not count as a symbol at all
19:40:28 <Chobbes> cmccann: sure, but that also breaks existing code.
19:40:35 <Chobbes> Like Hunit uses '?' for operators.
19:40:39 <cmccann> anything else would be kinda horrible. to be fair there are already similarly horrible picky parsing details, like . for qualified names vs. as an operator
19:40:41 <jasonkuhrt> Well if there ever becomes a version of Haskell that is open for being backwards incompatible (e.g. "Lets make `head` return `Maybe a`! etc.") then I feel like this could be a worthwhile addition to Haskell
19:41:05 <broma0> exio4: it occurs both in ghci and when i compile and run it. i can gladly post the code in an lpaste, though it's literally an "c <- open 'mydb'" and a subsequent "query c 'blah'"
19:41:23 <jasonkuhrt> At the same time I would suggest that spaces between opeators should absolutely be required
19:41:24 <cmccann> Chobbes: well yeah, obviously. that's why I was saying it wouldn't ever happen  :P
19:41:29 <jasonkuhrt> but maybe that's not good
19:41:41 <Chobbes> jasonkuhrt: I don't disagree, but I also don't think it's really worth it.
19:41:52 <cmccann> jasonkuhrt: that's been suggested before, but again it'd break lots of code for a trivial reason
19:42:13 <exio4> broma0: the query has to load all the elements, if you mean that, as far as I know, query isn't a liar :) 
19:42:13 <jasonkuhrt> Its difficult to make a case for small things like this, agreed
19:42:29 <jasonkuhrt> Well, ^ that's an understatement
19:42:47 <Chobbes> Also I feel like there are bigger problems with Haskell identifiers. The constructor capitalization thing is a bit awkward sometimes.
19:42:48 <cmccann> and the situation is rapidly deteriorating for requiring spaces around operators, because lens operators are often used with no spaces
19:43:15 <lpsmith> broma0, no, postgresql-simple is strict and fully synchronous unless you use specific streaming operators (which are just convenient (?) wrappers for cursors.)
19:43:31 <cmccann> but it was already common for e.g. (x:xs)
19:43:37 <jasonkuhrt> Yeah 
19:43:44 <jasonkuhrt> That was the one exception I was thinking about
19:43:49 <cmccann> suddenly requiring that to be (x : xs) would break... quite a bit of code, I'd wager
19:43:49 <jasonkuhrt> (x:xs) feels food
19:43:50 <jasonkuhrt> good*
19:44:29 <edwardk> jasonkuhrt: foo.bar.traverse._2.traverse feels good too if you get used to it =)
19:44:51 <jasonkuhrt> ha
19:45:11 <cmccann> edwardk: my brain grinds to a halt for a couple seconds every time I try to use a lens that was imported qualified because of that :[
19:45:24 <edwardk> haha
19:45:39 <lpsmith> Or you use the COPY OUT interface
19:45:39 <lpsmith> postgresql-simple is implemented using async, non-blocking primitives though.
19:45:40 <lpsmith> that is very curious that you are having the same problem with sqlite-simple
19:45:41 <lpsmith> broma0, can you post your code to lpaste or as a gist?
19:45:42 <lpsmith> Actually,  might you have accidentally written something like   let x = ... x ...
19:45:43 <lpsmith> ?
19:45:58 <lpsmith> I'd suggest posting to lpaste.net,  or opening a github issue.
19:46:31 <broma0> lpsmith: ill create a minimum example of the issue and then post it to lpaste. i'm planning on opening an issue tonight if i cant determine it was an issue specific to me
19:46:36 <broma0> hang on a minute for that lpaste..
19:47:32 <jasonkuhrt> What appears trivial does not mean its unimportant though; I wager more engery is lost on the daily struggles of trying to remember what are the boolean functions in a library/codebase/whatever, authors trying to decide if its better to prepend `is` or avoid camelCase, etc.
19:47:54 <lpsmith> broma0, don't worry about making it too minimal unless there's something in your code you specifically don't want to share.  I'm fine with a less than minimal example :)
19:47:56 <jasonkuhrt> Certainly boolean-returning functions play a huge role in programming
19:48:07 <jasonkuhrt> its a UX win for almost everyone every day
19:48:16 <exio4> boolean blindness though! :P
19:48:34 <jasonkuhrt> but I'm just day dreaming though, for fun
19:49:07 <broma0> lpsmith, ok. ill post most of it then.. nothing to hide here!
19:49:13 <broma0> *most* :D
19:51:00 <lethjakman> Are there any good html ajax libraries for ghcjs?
19:51:08 <lethjakman> Preferably something that doesn't depend on jquery. 
19:51:49 <jasonkuhrt> I wish I could get a show of hands of how many people are seriously using GHCJS
19:51:54 <jasonkuhrt> it seems like its sort of becoming a thing
19:52:22 <jasonkuhrt> but still not really ready yet, meanwhile PureScript is rolling along
19:53:53 <lethjakman> jasonkuhrt: It looks really cool
19:54:01 <lethjakman> I like the looks of Elm a bit better than purescript
19:54:08 <lethjakman> It looks like purescript just uses the haskell api
19:54:09 <broma0> lpsmith: ok, so the last 3 functions interact with the database. any of the routes that hit those functions hang indefinitely. If you need me to post all the nitty gritty lens code i will. http://lpaste.net/141450
19:54:57 <broma0> wait a minute.. wtf am i aliasing both sqlite and prelude to 'P' ha
19:55:34 <lpsmith> well, that's ok actually
19:55:53 <lpsmith> Maybe not convenient,  but that shouldn't cause any problems.
19:55:56 <broma0> lpsmith: yeah, just a funny thing to notice
19:56:01 <jasonkuhrt> lethjakman: I used to Elm > PS but its become clear to me at least that PS is more general purpose and more featureful. Sometimes it also feels like a generally more professional project and developing at a faster pace
19:56:21 <lethjakman> jasonkuhrt: that's definitely good to know. 
19:56:28 <lethjakman> Have you tried integrating it with any of the web frameworks?
19:56:47 <jasonkuhrt> No not personally
19:57:09 <lethjakman> jasonkuhrt: I heard a podcast about it, the guy who wrote it sounded like he knew a bit less about compiler theory and such, but maybe that was just me. 
19:57:36 <jasonkuhrt> lethjakman: You mean PS on a pdocast?
19:57:43 <lethjakman> Yes
19:58:34 <lethjakman> When you type PS it makes me think postscript and cringe a little
19:58:56 <lpsmith> broma0, hmm,  I assume the framework is doing some sort of connection pooling?
19:58:56 <jasonkuhrt> lethjakman: Elm is more character driven (Evan) than PS is I think. Also its highly design oriented which can lead to both bad and good results. On the one hand they make a big deal out of compiler error messages (awesome, way better than Haskell in several regards actually) but then they do really weird things like us "I" perspective in copywriting for Elm tools
19:59:30 <lpsmith> broma0, are you compiling your application --threaded?
19:59:34 <broma0> lpsmith: not sure i know what you mean there
19:59:39 <broma0> lpsmith: yes
19:59:48 <lethjakman> Apparently the Elm guy really hates Haskell too. 
19:59:49 <jasonkuhrt> lethjakman: You could use PS full-stack today, the same defintely cannot be said for for Elm
20:00:08 <lethjakman> No? I thought it could. That's a bit disappointing. 
20:00:11 <jasonkuhrt> But its really exciting to see two very-solid projects dervied from Haskell in the world now
20:00:17 <jasonkuhrt> that are both gaining traction
20:00:21 <jasonkuhrt> its a trend alright
20:00:22 <lethjakman> The guy developing PS said there was a ton of community support. 
20:00:37 <lethjakman> How is Elm/PS's typing?
20:00:38 <lpsmith> broma0, actually I don't _think_ there's any connection pooling there.
20:00:55 <lethjakman> Does PS seem to catch a lot of error's before runtime? 
20:01:01 <jasonkuhrt> One place I think PS lags technically is the package system; they tried relying on bower and I thnik are starting to realize that they need their own thing
20:01:14 <jasonkuhrt> Elm has its own system already using the type-system to enforce SemVer
20:01:16 <montanonic> lethjakman: I read a huge thread where they talked about Evan's views on other languages, and the gist is not that he hates Haskell, but that he wanted Elm to be very accessible, and disagrees strongly about Haskell being accessible.
20:01:16 <lethjakman> The Elm guy was talking about how he's only ever had one runtime error, and it was something he was patching anyways. 
20:01:23 <jasonkuhrt> Elm really got that right so far it seems
20:01:26 <lpsmith> broma0, have you tried printf debugging to find out exactly where it's hanging?
20:01:40 <montanonic> It's up for debate if he's right about that, but I wouldn't say he hates Haskell.
20:01:54 <montanonic> He's just not at all bothered by not having a Haskell-like language.
20:01:55 <jasonkuhrt> PS has rank-2 kinds and most everything you expect from Haskell I think, but I'm still learning Haskell so might be wrong about that
20:02:04 <jasonkuhrt> Elm has a considerably weaker type system
20:02:10 <lethjakman> montanonic: There was a big long thing in JSJ where he listed a bunch of things he wanted in a language and one of the other podcasters said "So pretty much you hate haskell" and he said "I was trying really hard not to say that"
20:02:40 <lethjakman> So that's where I got it from. 
20:02:51 <montanonic> lethjakman: Sounds like an interesting podcast; I'm curious what things he wanted in a language?
20:02:56 <montanonic> about what*
20:03:03 <lethjakman> I'll link. 
20:03:12 <montanonic> ty
20:03:18 <broma0> lpsmith: yes. it is hanging precisely where i query is
20:03:21 <lethjakman> https://devchat.tv/js-jabber/175-jsj-elm-with-evan-czaplicki-and-richard-feldman
20:03:23 <broma0> in terms of line numbers.. hang on
20:03:25 <lethjakman> I rather enjoyed it. 
20:03:26 <lpsmith> broma0,  I'm thinking the problem _probably_ isn't with *-simple,  especially considering that it's happening with two libraries,  and that the idioms and immediately surrounding code look pretty standard and well-tested execution paths.
20:03:37 <lpsmith> hmm :-/
20:03:39 <broma0> lpsmith: 174
20:03:50 <broma0> lpsmith, thats what im thinking too
20:04:01 <broma0> but why on earth is it failing with both!?
20:04:24 <lethjakman> http://www.functionalgeekery.com/episode-26-phil-freeman/
20:04:25 <montanonic> Also, with regards to PS, it seemed very well designed to me on the superficial level. The tooling was solid, the library website, Pursuit, beautiful, and the book helpful.
20:04:26 <lethjakman> purescript
20:04:43 <lethjakman> Can anyone else tell that I have a long commute to work?
20:05:07 <lethjakman> montanonic: I've heard the book was good, I love having a book to be able to get into a language. 
20:05:35 <jasonkuhrt> lethjakman: Conversations in Elm community sometimes feel less sophsiticated than PS which may be a testament to its accessible nature but I think also is just a testament to the fact that it attracts UI focused peoplea who are sometimes not of CS backgrounds but more art/design/media backgrounds which is fine and great but just that PS has more going on in the systems-thinking
20:05:35 <jasonkuhrt> discussions I think
20:05:51 <lpsmith> broma0:  maybe try putting this right after you grab the connection:   putStr "testing that we have a connection:  " >> print (p == p)
20:06:03 <lpsmith> the other possibility is that you have a bottom in your user
20:06:06 <lethjakman> jasonkuhrt: I've noticed that the more mathematical a language gets the less conversations people have. 
20:06:14 <montanonic> jasonkuhrt: That's a good point. 
20:06:20 <lethjakman> I'm thinking at least partially because they need less conversations. 
20:06:27 <montanonic> That seems true.
20:06:52 <lpsmith> broma0, so you might try also try something like     putStr "testing that we have a user:  " >> print (u == u)
20:07:10 <montanonic> One thing I've loved about Haskell so far is that, unlike Scala, there have been almost no "wait, why the fuck do I have to write it this way?" moments, and when there have been, the answer is very straightforward.
20:07:14 <jasonkuhrt> lethjakman: Hard to say haha, but certainly the content is different, that I have noticied
20:07:21 <lpsmith> Alternatively,  you could deepseq the user,  make sure you don't have a bottom there.
20:07:28 <lethjakman> True, I'm just speculating. 
20:07:33 <broma0> lpsmith: well here are the types if youre interested http://lpaste.net/141452
20:07:36 <montanonic> In other words, Haskell seems to eliminate a cruft of questions about syntax confusion.
20:07:49 <broma0> lpsmith: im going to try that putStr
20:07:50 <lethjakman> montanonic: Could that be because you know functional programming now?
20:08:02 <lethjakman> I've noticed I seem to pick them up a lot faster now that I have a bit more of an understanding. 
20:08:03 <jasonkuhrt> lethjakman: I think PS is a healthier project if you rank health by distribution of thinking
20:08:07 <montanonic> lethjakman: no, Scala has legitimately confusing syntax requirements
20:08:12 <jasonkuhrt> lethjakman: Elm is very much Evan's baby it feels like
20:08:13 <lethjakman> Oh
20:08:28 <lethjakman> jasonkuhrt: yeah...PS seems very community driven. Which is nice. 
20:08:35 <lethjakman> But Evan does seem to have some great ideas
20:08:36 <lpsmith> broma0, well, every haskell type has a bottom
20:08:45 <broma0> lpsmith: do you mean testing that we have a username?
20:08:52 <broma0> lpsmith: specifically in that getUser function
20:08:53 <lpsmith> yeah
20:08:57 <broma0> ok one sec
20:09:02 <lpsmith> no, I mean in the database access function
20:09:07 <montanonic> lethjakman: http://stackoverflow.com/questions/31606556/reason-for-scala-apply-method-type-errorvariadic-function/31607555#31607555
20:09:10 <lethjakman> Also, while I'm here. Does anyone have any recommendatinos for haskell podcasts?
20:09:19 <lethjakman> I've consumed all of the haskellcasts and I'm sad about that. 
20:09:27 <montanonic> My answer is not very good (I was, and still am, new to programming), but it should illustrate my point clearly.
20:09:35 <broma0> lpsmith: True!
20:09:50 <broma0> lpsmith: meaning yes we have a user but we still have indefinite hanging...
20:10:00 <lethjakman> montanonic: how long have you been programming?
20:10:13 <montanonic> Less than 5 months?
20:10:17 <lpsmith> broma0:  part of the trouble with infinite loops in Haskell,  is they can be transported around in thunks and manifest in places far from the place they were actually create
20:10:22 <lpsmith> created
20:10:32 <montanonic> I took two semester courses two years ago, but I feel like I didn't understand too much / learn much.
20:10:34 <jasonkuhrt> lethjakman: Yes... but as per the definition of design its less about innovation and more about integration, he's applying some good principals in different domains together. As for his contributions to FRP I think its TBD if he really nailed it or not. My understanding is Connal Eliott (inventor of FRP) is still one the thought leaders here and I am very curious what he thinks
20:10:35 <jasonkuhrt> of Evans papers
20:10:35 <lethjakman> montanonic: Seems like a good answer to me. 
20:10:49 <lpsmith> broma0, try it with the database connection too.
20:11:00 <lpsmith> (I dunnno if sqlite-simple has an eq instance or not...)
20:11:02 <Shockk> I'm trying to figure out a type signature to use for a member function for the PolyMap I'm writing
20:11:09 <lpsmith> postgresql-simple does, though.
20:11:10 <Shockk> right now I've got this 
20:11:11 <Shockk>     member :: n -> TypeAt n as -> PolyMap as -> Bool
20:11:17 <jasonkuhrt> lethjakman: Evan is a centralized case of what might be happening to Haskell generally
20:11:27 <jasonkuhrt> lethjakman: Have you seen the Haskell for Mac app?
20:11:27 <Shockk> but TypeAt takes a Nat for its first argument
20:11:32 <lethjakman> jasonkuhrt:Connal seems to really hate how FRP is being represented. Most people have it all wrong. 
20:11:37 <montanonic> lethjakman: thanks :) ; I genuinely find the need to do anything of that as needless confusion now that I've been using Haskell.
20:11:40 <lethjakman> jasonkuhrt: no?
20:11:42 <jasonkuhrt> lethjakman: Yes that's correct
20:11:42 <lethjakman> On the app. 
20:11:47 <montanonic> especially given how common it is to want to do that in Scala.
20:11:58 <jasonkuhrt> http://haskellformac.com/
20:12:02 <Shockk> I get an error "The first argument of `TypeAt' should have kind `Nat'."
20:12:23 <Shockk> although if I change 'n' to '(n :: Nat)' 
20:12:26 <exio4> Shockk: you might want a GADT (which I don't know if it exists standalone, outside singletons)
20:12:28 <broma0> lpsmith: there isnt one for sqlite, but ill switch back over to psql real quick
20:12:41 <Shockk> I get "Excpected a type, but `n' has kind `Nat'"
20:12:43 <Shockk> Expected*
20:12:44 <lethjakman> Ahhh, that seems nice...but I'm kindof a command line editor guy. 
20:12:53 <lethjakman> I've recently switched from vim -> emacs
20:12:57 <lethjakman> well evil-emacs
20:13:19 <jasonkuhrt> lethjakman: Elm is missing do-notation which I know has been a big gripe for people writing HTML templates i elm
20:13:27 <Shockk> exio4: hmm, for member?
20:13:30 <jasonkuhrt> I think PS has do-notation... but please check I'm not sure
20:13:52 <exio4> data TNat (k :: Nat) where Z :: TNat 0 ; S :: TNat n -> TNat (n+1) -- maybe, I would like to know if GHC got better at infering things
20:14:19 <jasonkuhrt> lethjakman: Another thing Elm got right is removing partial functions from the standard library
20:14:20 <montanonic> jasonkuhrt: It definitely does.
20:14:23 <montanonic> http://try.purescript.org/example/do
20:14:25 <jasonkuhrt> head -> Maybe a
20:14:30 <jasonkuhrt> Yes!
20:14:43 <jasonkuhrt> montanonic: Yep, cool
20:14:48 <jasonkuhrt> thanks
20:15:13 <lethjakman> Ahhh, nice!
20:15:13 <montanonic> One simple small thing I really liked about purescript is that >>> and <<< are what they use for function composition. Associativity is implied.
20:15:22 <lethjakman> PS seems less app centric as well
20:15:24 <ski> "implies" meaning ?
20:15:29 <jasonkuhrt> So basically the downlow is this.... you can write your own Signal implementation in PS (there already is one) with a better type system and syntax
20:15:38 <jasonkuhrt> its kind of like watch spacemacs be a better vim than vim
20:15:41 <jasonkuhrt> watching*
20:15:51 <lethjakman> Do either of them have a good ajax library?
20:16:03 <jasonkuhrt> lethjakman: No idea : D
20:16:04 <montanonic> ski: sorry, f >>> g is g(f(x)), and g <<< f is standard f . g = f(g(x))
20:16:12 <jasonkuhrt> lethjakman: But you couldn't even do AJAX in Elm until a few months ago
20:16:21 <lethjakman> That always seems glossed over, but what's the point of a web application without that? 
20:16:24 <jasonkuhrt> lethjakman: So I bet the one PS has is better
20:16:26 <ski> montanonic : yes, but what did you mean by "Associativity is implied." ?
20:16:43 <lethjakman> I couldn't find anything not using jquery for ghcjs
20:16:46 <jasonkuhrt> I mean more mature
20:16:51 <montanonic> ski: the way that >>> and <<< associate is implied by the directions they imply.
20:16:55 <montanonic> lol, wow, sorry
20:17:02 <montanonic> that was a trash explanation
20:17:14 <montanonic> beyond trash, haha
20:17:23 <ski> hopefully, both should be associative ..
20:17:31 <jasonkuhrt> lethjakman: PS is very much less app centric, e.g. go ahead and make servers that run on the Node.js platform...
20:17:42 <broma0> lpsmith: aha!
20:17:47 <jasonkuhrt> You simply cannot do that with Elm today and its certainly not a focus so don't wait up for that : )
20:17:49 <montanonic> Yes, I meant with regards to left-associative vs right-associative
20:17:56 <broma0> lpsmith: i dont get the print out from 'print $ p == p' with postgres
20:18:08 <lpsmith> yeah,  your connection is bottom for some reason :)
20:18:15 <broma0> lpsmith: how the heck do i fix that?!
20:18:21 <lpsmith> lol, I dunno
20:18:24 <montanonic> jasonkuhrt: what do you mean by App-centric?
20:18:34 <montanonic> I'm not familiar with the term.
20:18:36 <ski> montanonic : are you saying `f >>> g >>> h' means `f >>> (g >>> h)', while `f <<< g <<< h' means `(f <<< g) <<< h' ?
20:18:37 <broma0> lpsmith: darn.
20:18:42 <ski> montanonic : or perhaps vice versa ?
20:18:43 <lpsmith> broma0, a real common mistake is to write something like   let  x =  ... x ...  somewhere
20:18:54 <lpsmith> those can be real frustrating ones to find.
20:18:55 <montanonic> ski: precisely that, yes
20:19:07 <montanonic> wait...
20:19:24 <montanonic> no
20:19:29 <montanonic> it has to be the opposite
20:19:30 <broma0> lpsmith: talk to you in a few hours.. going to analyze this code..
20:19:35 <montanonic> ski: vice-versa
20:19:40 <ski> montanonic : explain ?
20:19:43 <broma0> lpsmith: thank you for helping me find the source of the problem.
20:19:45 <jasonkuhrt> montanonic: Was answering suggestion from lethjakman before, meaning UI as I understood it
20:19:53 <saulzar> I like to think that reflex will be as simple as Elm soon - and be much more 'correct' on the FRP front too. The trouble with Elm is that because the view and model are always pure, widgets aren't composable 
20:20:36 <jasonkuhrt> lethjakman: Also I wouldn't discount core compiler team chops for PS; One of the core developers of Idris is a contributor to PS
20:20:39 <montanonic> ski: if you apply those functions to some x, the first equation suggests that you pass x to f first, then g, then h; the second is that it goes h to g to f
20:20:46 <saulzar> The only 'reactiveness' is at the top level, so if you want to have an animation you have to pipe the state to the top level and back
20:21:11 <lethjakman> jasonkuhrt: Yeah, I've heard of a couple of people using it in prod. 
20:21:37 <jasonkuhrt> lethjakman: Yep
20:21:53 <ski> montanonic : if you pass `x' to `h . g . f' in haskell, then `x' is passed to `f', the result `f x' is passed to `g', the result `g (f x)' is passed to `h', whose result `h (g (f x))' is the result of passing `x' to the whole `h . g . f'
20:22:04 <jasonkuhrt> Frankly between GHCJS / PS / Elm nothing is obviously super-duper the best
20:22:22 <ski> montanonic : this is true regardless of whether `h . g . f' is interpreted as `(h . g) . f' or as `h . (g . f)'
20:22:32 <jasonkuhrt> early days, efforts not consolidated yet, two years from it should be obvious
20:22:32 <saulzar> Right now there's a hundred different, fragmented projects
20:22:47 <jasonkuhrt> from now*
20:23:21 <ski> montanonic : i'm curious about your reasons for preferring one reading to the other
20:23:45 <montanonic> ski: right, but it forces writing function composition from right to left when using (.)  . Control.Arrow has >>> which allows for >>= like chaining (left to right). I think that should be a standard option for normal composition.
20:23:46 <jasonkuhrt> saulzar: Reflex looks very interesting
20:24:09 <jasonkuhrt> the theory/work behind looks pretty impressive at first glance, I've only watched a long presentation by the author
20:24:20 <jasonkuhrt> it seems like he _really_ knows what he is doing
20:24:22 <saulzar> Even writing a UI in plain Haskell is really hard (i.e. without using IO to an external library)
20:24:25 <montanonic> ski: when I write out function composition, I always start from what would normally be the right-most term, and it just makes more sense to write it first, which is what >>> allows you to do.
20:25:11 <montanonic> doThis >>> thenThis >>> finallyEndWithThis
20:25:14 <lpsmith> broma0, well, getting closer to the source of the problem, anyway ;-)
20:25:25 <montanonic> Instead of: finallyEndWithThis . thenThis . doThis
20:26:00 <lethjakman> jasonkuhrt: They still seem better than JS lol. 
20:26:05 <broma0> lpsmith: well i checked out a few commits behind and it solved the problem, so the digging will only have to be through a diff
20:26:13 <saulzar> jasonkuhrt, Yeah, though it's a little bit rough right now, too. But I think the idea is solid.. especially the way of embedding the FRP in a framework
20:26:19 <ski> montanonic : ok. i'm still not getting what this has to do with associativity
20:26:58 <jasonkuhrt> lethjakman: JS has flowtype on its end coming
20:27:04 <montanonic> ski: I probably misused the term. What I was thinking of is that >>> is infixl, whereas . is infixr.
20:27:05 <jasonkuhrt> everything is sort of moving in the same direction
20:27:12 <montanonic> Hence, left vs. right-associative
20:27:13 <jasonkuhrt> Its becoming more a matter of dialects now
20:27:14 <lethjakman> I've seen it, but it's still incredibly mutable. 
20:27:21 <jasonkuhrt> Yep
20:27:22 <montanonic> In the sense of operator precedence.
20:27:31 <lethjakman> Which I'm sick of 
20:27:39 <jasonkuhrt> JS is all about compromise baby : )
20:27:42 <lethjakman> I'm tired of other people changing things from under my feet. 
20:27:55 <jasonkuhrt> A test of endurance!
20:28:00 <lethjakman> link to reflex?
20:28:06 <lethjakman> Right? 
20:28:13 <ski> montanonic : yes, that's what i'm not connecting to your talk about `>>>' and `<<<'
20:29:00 <jasonkuhrt> JS popularity reflects the world. It makes no good sense. Its awful and chaotic. Its inferior in every imaginable way to known other tools
20:29:02 <jasonkuhrt> yet here we are
20:29:05 <montanonic> ski: >>> is left associative and <<< is right associative, this allows for f >>> g >>> h to be written without parenthesis and work properly, and vice-versa.
20:29:35 <montanonic> jasonkuhrt: It hurts me everytime I think about Worse is Better.
20:29:41 <ski> montanonic : what would the difference to that be, if `>>>' was right associative and `<<<' left associative ?
20:29:51 <saulzar> lethjakman, The presentation is here: https://www.youtube.com/watch?v=3qfc9XFVo2c   and the library is on hackage, though a lot of people use Ryan's try-reflex sandbox 
20:30:12 <ski> s/was/was declared/
20:30:16 <montanonic> ski: I do know for sure. I assumed it had to be the case 
20:30:18 <jasonkuhrt> I'm hoping to see the barrier to Haskell drop as things like Haskell for Mac mature, GHCJS, etc.
20:30:20 <montanonic> @:t >>>
20:30:21 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
20:30:28 <montanonic> @:t (>>>)
20:30:29 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
20:30:31 <montanonic> damn
20:30:41 <jasonkuhrt> People are listening, Haskell definitely has peoples' attention now
20:30:43 <Shockk> @ty >>>
20:30:44 <lambdabot> parse error on input ‘>>>’
20:30:46 <lethjakman> saulzar: thanks!
20:30:46 <Shockk> :/
20:30:49 <montanonic> :(
20:30:49 <Shockk> @ty (>>>)
20:30:50 <jasonkuhrt> Its basically on Haskell to screw up its mainstream adoption now
20:30:51 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
20:30:51 <ski> montanonic : s/do know/don't know/ ?
20:30:52 <Shockk> there
20:30:56 <montanonic> Shockk: hah thanks
20:30:59 <jasonkuhrt> Which may be a goal...
20:31:01 <Shockk> it's @ty or :t
20:31:02 <Shockk> not @:t
20:31:06 <jasonkuhrt> "Don't get popular" as they used to say
20:31:18 <lethjakman> jasonkuhrt: https://www.destroyallsoftware.com/talks/wat
20:31:24 <lethjakman> This hits a little too close to home...
20:31:32 <lethjakman> As far as JS goes. 
20:31:33 <nitrix> The Javascript part is nice.
20:31:39 <nitrix> I remember that talk.
20:31:54 <montanonic> jasonkuhrt: So, I'm a noob, but as far as I understand, if people want an easier Haskell, the solution is to make Haskell-compatible DSL's within Haskell.
20:32:02 <lethjakman> What happened that got haskell to start getting popular again?
20:32:06 <lethjakman> I mean...it's older than Java. 
20:32:16 <montanonic> Because the fact is, there's no way every programmer would want to learn something like Haskell. Then again, not every programmer should be one.
20:32:40 <lethjakman> montanonic: A programmer can/should learn a haskell in my opinion
20:32:44 <lethjakman> A designer may not want to. 
20:32:54 <lethjakman> Maybe a data scientist or something. 
20:32:56 <Shockk> montanonic: who knows, over the next 2 decades, the style of programming may shift dramatically to languages exactly like Haskell
20:33:03 <montanonic> lethjakman: ah, okay, that's a good way of categorizing the difference, perhaps
20:33:20 <montanonic> Shockk: Swift is already moving towards a good chunk of similarities with it
20:33:23 <ski> @quote unofficial.motto
20:33:23 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
20:33:29 <montanonic> and Swift is apple's new flagship
20:33:33 <montanonic> *new* 
20:33:40 <montanonic> 'new'
20:33:44 <Shockk> lol
20:33:52 <Shockk> you're right though
20:33:58 <jasonkuhrt> montanonic: As a arts school designer turned professional programmer I can tell you a lot can be done to make Haskell friendlier
20:34:07 <jasonkuhrt> -Wall should be on by default
20:34:24 <jasonkuhrt> Compile error messages should use something COLOUR
20:34:29 <montanonic> yes!
20:34:30 <montanonic> indeed
20:34:43 <jasonkuhrt> and they should dump the the source code where the offending lines are
20:34:44 <Shockk> that'd be nice actually
20:34:48 <jasonkuhrt> Elm _nailed_ it
20:35:03 <ski> jasonkuhrt : a type error slicer would be nice ..
20:35:04 <jasonkuhrt> I really don't know why Haskell doesn't get this fixed, not sure who to ask : )
20:35:09 <montanonic> And we need easy GHCi integration into text editors that aren't emacs or vi/vim
20:35:12 <jasonkuhrt> I guess go on Trac and check there
20:35:36 <montanonic> jasonkuhrt: those are superb suggestions, I know that I would benefit from them
20:35:43 <jasonkuhrt> Me too!
20:35:52 <montanonic> I'd love to make sure that GHC hackers are aware of such things
20:36:04 <jasonkuhrt> As for books I used to complain but thankfully this is happening http://haskellbook.com/
20:36:06 <montanonic> err, is that the domain of GHC?
20:36:07 <jasonkuhrt> and wow its awesome
20:36:26 <jasonkuhrt> montanonic: Yes I thnik so
20:36:42 <montanonic> jasonkuhrt: oh yeah? I wasn't sure if I was too much of an "advanced" beginner for it to be what's relevant to me
20:37:00 <montanonic> jasonkuhrt: I know that's a loose term, but the implication is, I've done *so* many tutorials
20:37:10 <montanonic> on basic and intermediate ideas, that I don't need any more
20:37:30 <jasonkuhrt> Yeah same, but the approach of the book is different as is the authors
20:37:53 <jasonkuhrt> the first chapter is about lamba calculus, there are exercises everywhere (every ~20 pages)
20:37:53 <montanonic> jasonkuhrt: did you start reading it at the point where you were already what you'd qualify as an "advanced" beginner?
20:37:59 <jasonkuhrt> Yes
20:38:04 <montanonic> Oh, huh, that actually sounds awesome
20:38:10 <montanonic> Wow, I think I might just buy it then.
20:38:21 <montanonic> I'm working through Typeclassopedia right now
20:38:21 <jasonkuhrt> So I'm reading through some stuff fairly fast but that's fine
20:38:37 <montanonic> And was planning on following that up with chimera.labs.oreilly.com/books/1230000000929/index.html
20:38:40 <jasonkuhrt> its stepped very intentionally so that a lot of the "gaps" I had are being filled in
20:39:08 <jasonkuhrt> Yeah I started reading that 
20:39:16 <jasonkuhrt> and then dropped it for Haskell book first
20:39:22 <montanonic> So have you read through Typeclassopedia?
20:39:23 <jasonkuhrt> realizing that I want the foundation done first
20:39:28 <jasonkuhrt> Not yet
20:39:28 * hackagebot wai-transformers 0.0.1 - Simple parameterization of Wai's Application type  https://hackage.haskell.org/package/wai-transformers-0.0.1 (athanclark)
20:39:48 <jasonkuhrt> link?
20:40:05 <montanonic> https://wiki.haskell.org/Typeclassopedia#Abstract
20:40:20 <montanonic> That's the level of Haskell that I'm at right now: just trying to get fluent with the core typeclasses
20:40:44 <montanonic> I just started to get a really solid feel for Monads, though I have much to learn about their potential uses.
20:41:21 <jasonkuhrt> Looks awesome thanks
20:41:28 <montanonic> jasonkuhrt: no problem
20:41:45 <jasonkuhrt> montanonic read this before buying the book http://bitemyapp.com/posts/2014-12-31-functional-education.html so that you know where the author is coming from
20:42:01 <jasonkuhrt> he basically wanted to write the positively definitive book on Haskell
20:42:05 <jasonkuhrt> and its going to be 1000+ pages
20:42:07 <jasonkuhrt> apparently
20:42:13 <montanonic> jasonkuhrt: I've skimmed it. Didn't notice that part
20:42:21 <montanonic> Hmm, and how far are you into it now?
20:42:31 <jasonkuhrt> 233
20:42:54 <jasonkuhrt> I'm enjoying it, Chris suggets doing the Nicta course after
20:43:05 <montanonic> What if I was already able to do NICTA?
20:43:15 <lethjakman> montanonic: the typeclassopedia is awesome. 
20:43:16 <montanonic> I'm just trying to gauge whether or not I need it
20:43:18 <jasonkuhrt> https://github.com/bitemyapp/learnhaskell
20:43:41 <montanonic> jasonkuhrt: that's what I've been following
20:43:55 <jasonkuhrt> montanonic: It sounds like Nicta is for after his book not before
20:44:01 <jasonkuhrt> so you probably don't need it
20:44:44 <jasonkuhrt> But best bet is to check the ToC
20:44:45 <montanonic> jasonkuhrt: hmm okay; I wish I'd known about it when I started Haskell in serious about two months ago though
20:44:57 <montanonic> Yeah I think they just finished up on Monads
20:46:14 <montanonic> jasonkuhrt: thanks for your feedback on it
20:46:20 <lethjakman> I really like real world haskell. 
20:46:29 <lethjakman> I found that after LYAH and wish I started with it. 
20:46:38 <montanonic> lethjakman: were you a programmer beforehand?
20:46:41 <jasonkuhrt> lethjakman: See Chri's remarks about both books in his blog post
20:46:44 <montanonic> I really struggled with it.
20:46:45 <jasonkuhrt> linked to above
20:46:47 <lethjakman> not that LYAH isn't good, but I liked it better. 
20:46:53 <lethjakman> Yes, I am. 
20:46:54 <montanonic> The JSON parser ended up being so confusing to me.
20:47:01 <jasonkuhrt> bed time for me
20:47:02 <jasonkuhrt> ciao
20:47:04 <lethjakman> I do web development. 
20:47:08 <montanonic> jasonkuhrt: night!
20:47:08 <lethjakman> jasonkuhrt: cya, thanks for the help :)
20:47:16 <jasonkuhrt> cheers good luck!
20:47:27 <montanonic> lethjakman: okay, well I've only been learning for 5 months, so I think that was the issue with it for me
20:47:43 <lethjakman> montanonic: Yeah, it moves quite quickly...
20:47:47 <montanonic> lethjakman: indeed
20:47:53 <lethjakman> I agree that there should be better resources for true beginners. 
20:47:59 <lethjakman> The documentation in haskell really sucks too
20:48:06 <lethjakman> I've been struggling with a lot of different things
20:48:06 <montanonic> seems like the one jason is using is good though
20:48:18 <lethjakman> You're pretty much left to figure things out on your own
20:48:28 <montanonic> lethjakman: Yeah; have a recent example?
20:48:33 <montanonic> do you have* 
20:49:47 <lethjakman> montanonic: Yeah, Yesod's google oauth, and SES-mail
20:51:02 <montanonic> lethjakman: I can't comment on that, but I can say that Yesod confused the ever-living shit out of me when I tried learning it a few weeks ago; granted I had more to learn about Haskell, and have devoted my time since then to studying it in depth so that I can jump back into Yesod in the coming weeks.
20:51:58 <hardmath123> is there a simple way to compile a single file in a cabal sandbox?
20:52:05 <montanonic> Nonetheless, better documentation for a lot of Haskell projects would be great :) ; I'm hoping that Stack Overflow's new documentation experiement can potentially help us out on that front.
20:52:08 <montanonic> Potentially...
20:52:18 <ttt_fff> is Happy/Alex available as a Haskell DSL / some template haskell hack, rather than a separate process?
20:53:53 <lethjakman> montanonic: Yeah...I'm still fresh to haskell, but I've got some of it. 
20:54:02 <lethjakman> I have to do things the hard way and throw myself into a project to understand it. 
20:54:14 <lethjakman> I love type safe web development though. 
20:54:30 <lethjakman> I think it just needs to be in the mentality. 
20:54:36 <lethjakman> As I understand more I plan to implement some myself. 
20:54:40 <montanonic> of web devel in general?
20:54:58 <lethjakman> montanonic: The only truely type safe web development I know if is yesod
20:55:11 <lethjakman> Even that isn't perfect...it'd need ghcjs to be implemented for the frontend. 
20:55:15 <lethjakman> or something similar. 
20:55:17 <montanonic> lethjakman: awesome! I know several people who'd love Yesod to be improved, so any contributions you made would be great
20:55:38 <lethjakman> It's on my list...as soon as I'm done with this first little application. 
20:55:39 <montanonic> lethjakman: purescript seems like it would be the best fit
20:55:50 <montanonic> but you need a whole additional devel environment for it
20:56:02 <lethjakman> I really do like ghcjs better. 
20:56:13 <lethjakman> Just because haskell seems to be a bit better of a language. 
20:56:24 <montanonic> lethjakman: the way I see it is this
20:57:02 <montanonic> Haskell is of course always preferable, but Purescript makes compromises so that JS interop is more optimal
20:57:39 <bitemyapp> montanonic: Yesod ended up being worth it for me once I knew enough Haskell that I wasn't getting the firehose.
20:57:43 <lethjakman> True...but if you could share the typesafety of Yesod to a frontend application?
20:57:56 <bitemyapp> montanonic: I've done enough Happstack and Snap (use it at my 9-5) to know what I am and am not missing.
20:58:02 <montanonic> From what I understand, GHCJS is necessarily slower. But, you are actually working with them, so I'd just qualify my opinions as impressions.
20:58:03 <bitemyapp> lethjakman: you can/could right now.
20:58:14 <lethjakman> bitemyapp: Tell me more. 
20:58:23 <bitemyapp> GHCJS isn't really slower for the purposes of most applications, especially business or cnsumer apps.
20:58:24 <lethjakman> I'd like the type safe routes to be compiled with ghcjs
20:58:34 <bitemyapp> the payload is a little large on first load, but that's what's caching is for.
20:58:47 <lpaste_> Shockk pasted “PolyMap.hs” at http://lpaste.net/141453
20:58:48 <lethjakman> bitemyapp: also, have you done any ajax/dom manipulation with it?
20:58:55 <montanonic> bitemyapp: I have a few questions for you about what I should do to learn Haskell after you finish helping lethjakman. :)
20:58:57 <bitemyapp> lethjakman: oh you want the routes to be shared. Hrrrrm. I haven't tried that but I've shared types and JSON marshalling.
20:58:58 <Shockk> I have no idea what the error means 
20:59:08 <Shockk> (in the lpaste I just posted)
20:59:12 <bitemyapp> lethjakman: I bet Servant would be a good candidate for type-safe API servers + clients
20:59:33 <bitemyapp> I have a buddy who's literally in the middle of making a type-safe end-to-end GHCJS + GHC servant backend setup.
20:59:47 <montanonic> oh awesome
20:59:48 <bitemyapp> so, uh, when they get done kicking it around, I could try seeing if I can get a scaffold out of them.
20:59:49 <montanonic> that's awesome
20:59:56 <bitemyapp> I don't know if they're using the client-gen or not.
21:00:03 <lethjakman> bitemyapp: that sounds amazing. 
21:00:12 <glguy> Shockk: the type variable 'n' in the instance line is different from the one in the first argument of member
21:00:25 <bitemyapp> the stuff dmj` has been doing with Servant and servant-client has been p cool
21:00:30 <bitemyapp> so that's another person to watch.
21:00:45 <Shockk> glguy: hmm I see
21:00:52 <bitemyapp> anyhoo, given my druthers, I'd use Yesod or Servant depending on the nature of the project.
21:00:57 <bitemyapp> second choice would be Snap
21:00:59 <glguy> Shockk: Oh, but regarding the stuff about injective type families, can you paste a self contained bit of code?
21:01:05 <bitemyapp> Snap/Scotty/Spock
21:01:11 <bitemyapp> further down would be Happstack et al.
21:01:23 <Shockk> glguy: self-contained? do you mean paste the TypeAt code?
21:01:46 <glguy> Shockk: something that if I put in a file would load and has the error in it
21:02:03 <Shockk> oh ermm
21:02:42 <glguy> Shockk: In the end the answer is probably going to be just to not put the type annotations on the arguments
21:02:44 <montanonic> bitemyapp: Hey, regarding Yesod, one thing I was trying to do a bit ago was make a blog for me, and this included a chronology of webpages that I've made as I learn/learned CSS and HTML. In other words, they are different static templates, but I heard Yesod is a waste if you are building a static site? 
21:02:55 <Shockk> glguy: https://github.com/shockkolate/hs-polymap/blob/master/src/Data/PolyMap.hs
21:03:35 <Shockk> that's pretty much self-contained apart from the PolyMapClass class functions and instances
21:03:42 <glguy> Shockk: You need an argument on member that determines what 'n' is
21:04:21 <Shockk> hmm, an argument on it?
21:04:22 <glguy> member 07:: proxy n 07-> TypeAt n as 07-> PolyMap as 07-> Bool
21:04:22 <lethjakman> montanonic: It's more for restful stuff. 
21:04:25 <glguy> like that
21:04:29 <lethjakman> Restful/Crud. 
21:04:35 <montanonic> lethjakman: is there a good place to learn about those concepts?
21:04:55 <lethjakman> montanonic: You'll just naturally pick it up after making a few websites
21:05:01 <Shockk> hmmm, how does proxy work?
21:05:07 <montanonic> lethjakman: okay :)
21:05:09 <Shockk> or what does it do, rather?
21:05:11 <lethjakman> I guess I picked that up because I was working on rails...
21:05:17 <lethjakman> It actually explains that pretty well. 
21:05:25 <glguy> Shockk: consider this case:      member True (_ :: PolyMap '[Bool,Bool])
21:05:31 <glguy> Shockk: what is 'n' in that case?
21:05:33 <montanonic> lethjakman: I heard that Yesod is very "rails-like" in its philosophy.
21:06:24 <Shockk> so the (proxy n) is True..I have no idea
21:06:41 <Shockk> or do you mean with my current type of member?
21:06:44 <glguy> current
21:06:52 <lethjakman> montanonic: It definitely feels like it. 
21:07:05 <lethjakman> Of course it's not as objecty
21:07:18 <lethjakman> and the meta-programming has been replaced with templat haskell or removed. 
21:07:21 <montanonic> lethjakman: interesting; I only bring that up because Rails is very popular, and if Yesod feels similar, that would bode well?
21:07:35 <Shockk> glguy: oh, I see what you mean
21:07:38 <lethjakman> montanonic: I hope so. 
21:07:43 <montanonic> lethjakman: template Haskell *is* metaprogramming though, isn't it?
21:07:45 <lethjakman> I really am enjoying working in haskell.
21:07:52 <lethjakman> It's nice to have the compiler tell you your application doesn't work. 
21:07:55 <montanonic> oh, I see your point though: it was reduced.
21:08:04 <lethjakman> montanonic: Well, it's not run-time. 
21:08:04 <montanonic> lethjakman: I agree! :)
21:08:09 <glguy> Shockk: So the type error is saying that type families aren't objective, so knowing that (for example)  Bool == TypeAt n '[Bool,Bool]   isn't enough to determine n
21:08:12 <montanonic> lethjakman: ah, okay, yes indeed not
21:08:12 <lethjakman> I'm not sure if it's technically meta-programming. 
21:08:14 <glguy> injective*
21:08:28 <lethjakman> But having your classes opened and modified, and functions coming from no where gets really annoying. 
21:08:35 <lethjakman> You lose some "ease of use"
21:08:45 <lethjakman> But honestly I think it's worth it
21:08:50 <glguy> Shockk: By adding a "proxy" argument you have a way to pass in what you intended that 'n' to be explicitly
21:09:01 <lethjakman> It makes refactoring a LOT easier. 
21:09:05 <Shockk> glguy: so instead of trying to have (n :: Nat) as a parameter to that typeclass, I can just put member in PolyMapClass but I would use a proxy?
21:09:21 <glguy> You could have this:
21:09:25 <lethjakman> (I just changed a route and found all the places it changed instantly. That would have taken quite a while, and quite a bit of grepping in rails)
21:09:50 <glguy> 03class PolyMapClassWithNat (n 07:: Nat) (as 07:: [07*]) 03where member 07:: proxy n 07-> TypeAt n xs 07-> PolyMap xs 07-> Bool
21:09:56 <Shockk> ooh color
21:10:06 <Shockk> it's like weechat suddenly became vim
21:10:07 <montanonic> lethjakman: Snowdrift.coop is a project that I'm hoping to contribute significantly to, and so I can't wait until I know enough Yesod to make an impact. Glad to hear that it has so many benefits from the perspective of a web developer.
21:10:16 <montanonic> lethjakman: seems like it will be a good investment of my time
21:10:26 <glguy> or you could try a different design, but that's one way to specify 'n'
21:10:39 <Shockk> ahh I see
21:11:01 <Shockk> glguy: can I give member a type signature like :: proxy (n :: Nat) -> ...   or something?
21:11:19 <glguy> proxy n ->    is enough
21:11:33 <glguy> You've already specified that n had kind Nat in the class declaration
21:11:44 <montanonic> lethjakman: yeah the URLs are really awesome; one funny thing you can do easily is make it so that you can have a route /add/#Int/#Int that takes you to a page with the sum of those integers.
21:12:00 <Shockk> sorry, I mean if it wasn't specified in the class declaration
21:12:05 <lethjakman> montanonic: Yeah!
21:12:12 <lethjakman> I saw some cool fib stuff with that too. 
21:12:21 <montanonic> haha, indeed
21:12:29 <glguy> Shockk: It'd still be inferred due to the kind of the TypeAt type family
21:12:34 <lethjakman> montanonic: functinoal programming and haskell definitely change how you think (for the better in my opinion)
21:12:34 <Shockk> ohhh I see
21:12:40 <Shockk> clever
21:12:55 <lethjakman> I'm honestly sick of rails at this point. 
21:13:03 <Shockk> is proxy lowercase or uppercase p?
21:13:03 <glguy> at least I think it would be... I try not to be this clever in general :-p
21:13:07 <lethjakman> It's good for a job right now, but I wouldn't start another company in it. 
21:13:17 <glguy> when it's an argument it's more general for it to be lowercase (a variable)
21:13:19 <montanonic> lethjakman: definitely, I absolutely love FP at this point; and the category theory typeclasses that Haskell offers really expand the mind.
21:13:31 <glguy> You don't care which proxy the caller uses, you're going to ignore that argument
21:13:33 <lethjakman> Yeah, it seems like the best of the FP languages right now. 
21:13:58 <Shockk> what should I even pass as that argument?
21:14:17 <Shockk> oh wait, just Proxy
21:14:28 <montanonic> lethjakman: I've spent a good chunk of time browsing around languages, and Haskell was the constant one with regards to awesomeness and usefulness
21:14:36 <glguy> yeah, Proxy is a valid choice
21:15:15 <montanonic> lethjakman: I'm glad you've found it for yourself :)
21:16:39 <lethjakman> montanonic: You too, it sounds like you're on the right path. 
21:16:47 <lethjakman> Anyways, I'm out of here, thanks for the chat! :)
21:17:00 <montanonic> Definitely seems so. And likewise! Time to get some studying done :)
21:17:35 <Shockk> I think I might be able to get this working now if I use proxy stuff
21:17:37 <Shockk> thanks glguy 
21:18:29 <glguy> yw!
21:32:36 <Shockk> oh glguy I realized I do have to write it with (n :: Nat) in the class declaration
21:32:56 <Shockk> glguy: otherwise I can't write a different instance for 'Z and for ('S n)
21:43:26 <glguy> Shockk: I only meant that you didn't need the kind annotation
21:43:41 <Shockk> ooh right
21:45:57 <Shockk> hahahahah it works
21:46:33 <Shockk> glguy: I can do: member (Proxy :: Proxy Z) "one" pm
21:47:00 <Shockk> where pm = singleton $ "one" :<->: 1 :<->: UnitRelation
21:47:11 <Shockk> that compiles and is equal to True
21:47:37 <Shockk> but if I change Proxy Z to Proxy (S Z)
21:48:05 <Shockk> it whines about not being able to match Integer with [Char]
21:48:07 <Shockk> so it works!
21:57:39 <nitrix> Guys, I have a word on the tip of my tongue and I'm almost sure the initials for it are "PR".
21:58:28 <nitrix> In a large project where features require a design document with a rationale, implications, etc, I'm looking for the name of that document.
21:58:59 <dmwit> evanbd: You understood me well about typing. Sorry that didn't work out, but I'm glad the list version worked well. =)
22:00:14 <dmwit> nitrix: I might call that a whitepaper.
22:01:38 <nitrix> Mhhh, in the Haskell world maybe because there's a research linked to it.
22:01:41 <mazur> what's wrong with "design document"?
22:02:18 <nitrix> I think I'm just too tired to find the exact word that I want. It's on a smaller scale, more focused on the implementation details.
22:02:32 <dmwit> I don't know what word you're looking for. But "P" could stand for "Planning".
22:02:41 <dmwit> Perhaps "Planning Requirements"?
22:03:48 <mazur> "requirements specification"? https://en.wikipedia.org/wiki/Software_requirements_specification
22:04:06 <glosoli> Hey, is the thing like "cabal hell" string present nowadays ? 
22:05:48 <nitrix> Oh! "Proposal", there's proposal in it.
22:06:34 <nitrix> Anyway, I'll figure it out on my own, sorry for ranting.
22:06:41 <Shockk> Proposal Rant?
22:06:45 <adas> i have servant installed and it is in path. but i still get the module not found error. all the dependencies of servant are okay but servant is a problem
22:06:54 <adas> how can i diagnose the problem?
22:08:21 <dmj`> adas: are you using stack or cabal sandboxes?
22:08:48 <adas> dmj`: stack
22:08:51 <dmj`> adas: type ghc-pkg list | grep servant on the command line, does anything show
22:09:13 <dmj`> adas: I'm not sure how stack interacts w/ ghc-pkg, so that might not help
22:09:42 <adas> stack list-dependencies | grep servant -> shows servant 0.4.4.2 as being installed
22:10:30 <dmj`> adas: ok, are you doing 'import Servant.API' or 'import Servant'
22:10:40 <adas> dmj`: import Servant
22:10:45 <dmj`> adas: try the latter
22:10:50 <dmj`> er, the former 
22:10:54 <glguy> It might be worth pasting what you did that you think should work and then pasting the error message you go
22:10:57 <dmj`> 'import Servant.API'
22:11:33 <adas> dmj`: i did `import Servant.API` but then I get errors saying that the combinator type functions like (:>) are not found
22:12:21 <adas> dmj`: exact error  - > `Not in scope: Type constructor or class GET`
22:12:24 <dmj`> (:>) is exported by Servant.API.Sub, and re-exported by Servant.API, so it shoudl be present
22:12:35 <dmj`> adas: there is no 'GET' only 'Get'
22:12:44 <dmj`> s/shoudl/should
22:14:19 <adas> dmj`: Now i get `Not in scope: Type constructor or class Server`
22:14:32 <adas> dmj`: im just following the tutorial on Servant homepage
22:15:24 <dmj`> adas: there is no 'Server' on the homepage tutorial
22:15:36 <dmj`> there is a 'serve' and a 'server' though
22:15:40 <glguy> ?lpaste
22:15:40 <lambdabot> Haskell pastebin: http://lpaste.net/
22:15:49 <dmj`> adas: yes lpaste.net
22:15:52 <dmj`> adas: ^
22:16:01 <dmj`> glguy ty
22:16:17 <adas> one moment
22:17:09 <lpaste_> adas pasted “servant tutorial” at http://lpaste.net/141456
22:17:18 <adas> ^^^
22:18:05 <dmj`> adas: can you paste the error too
22:19:32 * hackagebot PortMidi 0.1.5.2 - A binding for PortMedia/PortMidi  https://hackage.haskell.org/package/PortMidi-0.1.5.2 (PaulLiu)
22:19:50 <lpaste_> adas revised “servant tutorial”: “No title” at http://lpaste.net/141456
22:20:25 <lpaste_> adas revised “servant tutorial”: “No title” at http://lpaste.net/141456
22:21:14 <adas> please take a look at the second edit link. first one is duplications
22:21:28 <lpaste_> dmj` revised “servant tutorial”: “No title” at http://lpaste.net/141456
22:24:32 * hackagebot yesod-content-pdf 0.1.0.2 - PDF Content Type for Yesod  https://hackage.haskell.org/package/yesod-content-pdf-0.1.0.2 (alexkyllo)
22:24:44 <dmj`> adas: I added some imports
22:27:29 <adas> dmj`: now I have an import error on Servant.Server
22:27:40 <adas> dmj`: is there some other dependency i have to install other than servant?
22:27:55 <dmj`> adas: servant-server
22:28:26 <adas> dmj`: I wonder why the tutorial on the homepage never mentioned that.
22:29:32 * hackagebot sbv 5.0 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  https://hackage.haskell.org/package/sbv-5.0 (LeventErkok)
22:30:16 <dmj`> adas: it does in the longer tutorial, the front page is just a teaser, http://haskell-servant.github.io/tutorial/server.html
22:31:16 <adas> servant-server has tons of dependencies
22:32:22 <dmj`> adas: stack should share them I believe
22:33:40 <adas> dmj`: i am following the exact same link. 
22:34:33 * hackagebot GLM 0.5.0.0 - Simple Gridlab-D GLM parser and utilities.  https://hackage.haskell.org/package/GLM-0.5.0.0 (LyndonMaydwell)
22:34:40 <dmj`> adas: yea?
22:35:14 <adas> dmj`: yes. in the list of imports at the top, there is no mention of the fact that those 2 imports are required although it looks like its mentioned later down the page
22:36:31 <adas> however much thanks for helping to resolve the issue. it wworks now
22:36:36 <dmj`> adas: cabal get servant-examples
22:36:43 <dmj`> adas: fantastic, cheers
22:38:33 <tippenein>   parseJSON (String d) = readTime defaultTimeLocale "%Y-%m-%d" (showText d)
22:39:29 <tippenein> No instance for ParseTime of a Parser Day arising from use of readTime
22:40:10 <tippenein> I have my toSON just defined as toJSON . showGregorian but I can't get the parseJSON to work
22:51:30 <mazur> what's the 'unit' for the exponential _^B, left pairing _xB adjunction? looks like `Ax_ : B -> (A,B)` basically just a right-pairing function for some A?
22:54:47 <shachaf> unit as in eta?
22:55:33 <shachaf> I guess so.
22:55:43 <shachaf> It's return for State: eta : a -> (e -> (e,a))
23:03:28 <mazur> shachaf: yes eta
23:05:01 <mazur> i'm just starting to understand adjoints, was wondering if it had a special meaning in that case like epsilon does (eval)
23:05:48 <shachaf> They seem equally special to me.
23:07:41 <crocket> Can a kernel be compiled by GHC?
23:07:58 <crocket> Can an effective game engine be written in haskell and compiled by GHC?
23:10:03 <liste> crocket Metasepi is a kernel project that had some success with Haskell
23:10:34 <crocket> unix-like kernel
23:11:00 <crocket> metasepi is written in C.
23:13:36 <liste> crocket actually it used ajhc to compile Haskell into C
23:13:45 <liste> but they switched to ATS
23:14:25 <liste> because Haskell requires a garbage-collected runtime (afaik?)
23:15:06 <liste> http://www.metasepi.org/en/posts/2013-01-09-design_arafura.html
23:15:36 <slack1256> there was also a big "serious" game engline released not that much ago
23:15:44 <slack1256> It had lambda on the name 
23:16:40 <crocket> I like garbage collection in kernel.
23:16:53 <crocket> slack1256, What is the name of the engine?
23:16:57 <slack1256> @where lambdacube
23:16:57 <lambdabot> I know nothing about lambdacube.
23:17:28 <slack1256> https://lambdacube3d.wordpress.com/
23:17:45 <crocket> Ok
23:17:50 <crocket> Lambdacube is written in haskell.
23:18:04 <slack1256> AFAIK the switched from a haskell DSL to their own which is very haskell-like but has better error messages
23:18:30 <broma0> say i have the user type defined here http://lpaste.net/141460, is it there a way to not only generate 'instance HasUser User ...' and the like, but also generate "nested" instances like '
23:18:37 <broma0> instance HasCreds User' etc
23:18:39 <slack1256> It would be funny if it where calles lambdacube3d and written in pascal, I would piss off everybody :-)
23:19:02 <slack1256> *called
23:22:24 <mazur> shachaf: is the eta funciton defined in the MonadState class?
23:23:48 <shachaf> It's called return.
23:30:04 <pavonia> When using acronyms in identifiers, do you prefer capitalizing the whole acronym or only the first letter? E.g. "CTCPMessage" or "CtcpMessage?"
23:30:49 <pavonia> Is there a generally accepted standard for this?
23:31:03 <pacak> I tend to go with CTCPMessage unless it's more than 4-5 caps in a row
23:31:04 <MarcelineVQ> No idea, I'd tend towards CTCP though since each letter is a word
23:31:28 <pacak> If it looks too  strange - use _
23:32:21 <glguy> I tend to start lowercasing them if they are longer than 2 characters
23:34:20 <slack1256> what do superclasses actually buy me? apart of more default methods and less explicit constrains ie (Eq a, Ord a) = Ord a ?
23:34:26 <slack1256> Am I missing something else?
23:35:41 <pavonia> glguy: Heh, that question actually arose while I was looking at your irc-core code :p
23:35:58 <glguy> What decision did I make there?
23:36:14 <pavonia> The Ctcp version
23:36:26 <slack1256> broma0: Can you do without the typeclass? Seems you can do with a type family which evaluates to 'True or 'False if it has credentials
23:37:07 <slack1256> and a family for HasCred that depends on definition of HasUsers
23:40:04 <quicksilver> broma0: you're talking about the instances that lens makes?
23:41:46 <quicksilver> broma0: if so I think the answer is no although if you fancy writing some TH you could probably hack something together; but you have to traverse the entire nested structure to check there aren't two possible Creds and be careful of recursive structures etc.
23:43:12 <broma0> slack1256: I cant do without the typeclass
23:43:49 <broma0> quicksilver: that's a bit intense for the use case, but sounds like a cool idea. I'd just rather not write out all of those extra instances
23:44:04 <broma0> quicksilver: maybe ill find some time to figure that out though
23:45:27 <quicksilver> it doesn't seem worth it to me *in general*
23:45:36 <quicksilver> but it migh tbe a fun excercise in TH programming :)
23:46:12 <quicksilver> in general the difference between foo^.creds and foo^.bar.creds seems worth prserving
