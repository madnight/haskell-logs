00:00:57 <sinelaw> or anywhere else in the program, for that matter
00:01:21 <ski> sinelaw : are you talking about applying the value `foo' to the value `bar' ? or about defining `foo' for any `bar' parameter/argument ?
00:01:52 <sinelaw> ski: on second thought 'foo' would be allowed to assume 'con' regardless of where 'bar' is
00:01:59 <Hafydd> (*>) :: Applicative f *> f a -> f b -> f b
00:02:00 <sinelaw> so maybe the second thing you said
00:02:19 <ski> Hafydd : .. bold promises
00:05:02 <ski> sinelaw : given `foo :: con => tau -> ...' (or `foo :: (con *> tau) -> ...') and `bar :: con *> tau', we could get `foo bar :: ...' (even `foo bar :: con *> ...')
00:07:27 <sinelaw> ski: how about this
00:07:28 <sinelaw> give :: a -> (Give a => r) -> r
00:07:28 <sinelaw> give = undefined
00:07:36 * hackagebot ig 0.5.1 - Bindings to Instagram's API.  https://hackage.haskell.org/package/ig-0.5.1 (FelipeLessa)
00:07:36 * hackagebot app-lens 0.1.0.1 - applicative (functional) bidirectional programming beyond composition chains  https://hackage.haskell.org/package/app-lens-0.1.0.1 (kztk)
00:07:38 <ski> sinelaw : in the other case, defining `foo bar = ..bar..', `..bar..' would know `bar :: con *> tau', so it could use `con' as well as `bar :: tau'. so we could have either `foo :: (con *> tau) -> ...' or `foo :: (con *> tau) -> (con *> ...)' .. having `foo :: con => (con *> tau) -> ...' would be little point (ambiguous ?), since we now get the constraint from two places
00:07:43 <sinelaw> class Give a where ... whatever
00:08:44 <ski> sinelaw : what about it ?
00:08:56 <sinelaw> should I be able to write: give 0
00:09:21 <sinelaw> no instances for Give
00:09:42 <sinelaw> I think I see what you mean, is there a reference that defines *> ?
00:09:53 <ski> i think so. it would have type `(Give a => r) -> r', with the presupposition `Num a'
00:10:24 <jhrcek> Is there a way to "undefine" specific bindings defined interactively at GHCI? 
00:10:24 <ski> `*>' is pseudo-syntax i've invented here to be able to talk about this distinction more clearly
00:10:31 <sinelaw> ah
00:10:41 <sinelaw> ski: give 0 doesn't compile
00:10:42 <jhrcek> Check this snippet pleasehttp://lpaste.net/140159
00:11:05 <jhrcek> I'd like the 2nd data declaration to "override" the first, but it creates new one instead
00:11:07 <sinelaw> oh wait
00:11:31 <shachaf> There is no overriding in Haskell.
00:11:31 <ski> the obvious implementation of `con *> tau' would be to pass a pair of a dictionary for `con', and a value for `tau', just like the obvious implementation of `con => tau' (dictionary-passing implementation) is a function that accepts a dictionary for `con' and returns a value of type `tau'
00:12:13 <sinelaw> "give False" does compile, with FlexibleContexts, 
00:12:39 * ski nods
00:12:49 <qmm> https://groups.google.com/d/msg/elixir-lang-talk/Vq--xwBMmAI/WRjH3NKlZVYJ
00:12:50 <sinelaw> give False :: (Give Bool => r) -> r
00:12:59 <qmm> is cloud haskell taking care of case #1 in that link?
00:13:00 <sinelaw> ski: maybe <= is better? :)
00:13:06 <crocket> Is it wise to write an RDBMS like MySQL in haskell?
00:13:18 <ReinH> crocket: sure
00:13:55 <crocket> How do you compare clojure with haskell?
00:14:06 <sinelaw> crocket: will it be performant? RDBMS play around with memory pages, dense packing of rows, and other low-level stuff to get performance
00:14:20 <ReinH> sinelaw: no reason you can't do that
00:14:29 <sinelaw> ReinH: you can do anything
00:14:36 <sinelaw> but it won't be so easy
00:14:45 <ReinH> Not sure why you think that
00:15:04 <sinelaw> I have bad experience with binary serialization
00:15:29 <chattered> crocket: I don't really find them comparable.
00:15:30 <crocket> Someday, automatic memory management would be better than most hand-crafted memory management tactics.
00:15:33 <sinelaw> without resorting to writing unsafe code
00:15:36 <sinelaw> plus there's the GC
00:15:53 <crocket> C is already better than hand-crafted assembly in most cases.
00:16:01 <ski> sinelaw : imho that glyph still rather suggests an implication, being translated into a function type (otoh, Mercury does use `=>' and `<=', one for "input constraints" (`=>' here), and the other for "output constraints" (`*>' here))
00:16:25 <sinelaw> ski: it implies that <= does the opposite of what => does
00:16:38 <sinelaw> or you could say
00:16:48 <sinelaw> a => Bla
00:16:51 <ski> to be `<=' implies the converse of `=>', or at least something close to that
00:16:52 <sinelaw> (flip the order)
00:17:09 <shachaf> (->) and (,) are dual in one sense.
00:17:10 <ski> (iow, `A => B' would be equivalent with `B <= A')
00:17:52 <sinelaw> at least you could flip the order in *>
00:17:54 <ski> (rather `(a ->)' and `(a,)' are dual in one sense (adjunction), i'd say)
00:18:07 <TheTrueBrot> You are entitled to claim Â£36.5M Mr Graham left in his investment account on a legitimate proposal contact me for details Email: mattbennt@gmail.com Martin
00:18:26 <ski> sinelaw : `(*>) :: Constraint -> * -> *' and `(<*) :: * -> Constraint -> *', you mean ?
00:18:35 <sinelaw> give :: a -> (r => Give a) -> r
00:18:43 <sinelaw> or *>
00:18:46 <shachaf> ski: I think that "F and G dual" usually more often means "there exists H such that F -| H -| G" than it means "F -| G"
00:19:07 <ski> shachaf : hm, point
00:19:08 <shachaf> are dual
00:20:03 <jhrcek> Can someone please explain this GCHi behavior to me please? http://lpaste.net/140159
00:20:08 <shachaf> ski: But (->) is like a (repeated) product and (,) is like a (repeated) sum.
00:20:26 <ski> yes
00:20:28 <shachaf> And those seem pretty dual from that perspective. So there's probably something going on there.
00:20:42 <shachaf> And of course forall is dual to exists.
00:21:02 <sinelaw> * is to + as ^ is to *?
00:21:56 <opqdonut> sinelaw: yes, and the relationship is called "logarithm"
00:22:00 <ski> also cf. `not (a \/ b)' ~ `(not a) /\ (not b)' vs. `not (a /\ b)' ~ `a -> (not b)'
00:22:19 <sinelaw> opqdonut: right! (that wasn't really a question :) 
00:22:24 <ski> (`\/' being dual to `/\' in the former case. `(a /\)' being dual(?) to `(a ->)' in the latter case)
00:22:42 <crocket> Is it wise to write a general purpose AI in haskell?
00:22:49 <opqdonut> sinelaw: there's this nice paper somewhere about the semantics of type-level logarithm and exponentiation
00:23:18 <sinelaw> opqdonut: yeah I love the algebra of types stuff
00:24:38 <sinelaw> ski:  so are you aware of systems that allow placing a constraint on all row fields?
00:24:52 <sinelaw> is it "a thing"?
00:25:23 <sinelaw> or the dual, on sum types
00:25:43 <ski> i'm not aware of them. i've just figured someone ought to investigate the idea
00:27:09 <ski> (how else would we express `case :: Rec (MapRow (-> o) r) -> (Var r -> o)' ?)
00:29:20 <sinelaw> not sure what you mean by that
00:29:57 <sinelaw> What are Rec and Var?
00:30:32 <saulzar> crocket, What is a general purpose AI?
00:30:42 <ski> `Rec :: Row * -> *',`Var :: Row * -> *'. the former forms a record type from a row of concrete types. the latter forms a variant type from a row of concrete types
00:30:54 <crocket> An AI that can recognize, imagine, decide, and act in general situations.
00:31:05 <crocket> Even, a squirrel can do that.
00:31:25 <sinelaw> Can you write a squirrel?
00:31:28 <crocket> not yet
00:31:41 <ski>   case rec (`X x) = (#X rec) x
00:31:41 <saulzar> A squirrel is a pretty advanced AI :)
00:31:45 <crocket> Squirrel AIs in traffic lights would be hilarious.
00:31:52 <ski> where
00:32:12 <crocket> Is haskell's garbage collector decent and better than that of JVM?
00:32:24 <athan> Is there a kind of parallelism that generates an arbitrary amount of threads?
00:32:36 <ski>   `X :: forall a r. a \ r => a -> Var {X :: a | r}
00:32:44 <athan> instead of manually asking for each fork?
00:32:47 <ski>   #X :: forall a r. a \ r => Rec {X :: a | r} -> a
00:33:08 <sinelaw> #X is field getter?
00:33:11 <athan> basically, I have a `someComputation :: Int -> Maybe Foo`, and I need to find which Int gives me a Just
00:33:23 <athan> It would be nice to do a lot of them en-masse
00:33:28 <orb_> crocket: you mean ghc's GC?
00:33:29 <ski> (er, `X \ r', not `a \ r'. it would express that the name `X' is not in `r')
00:33:33 <crocket> orb_, yes
00:33:40 <ski> sinelaw : yes. that's SML syntax (which i prefer)
00:33:54 <orb_> crocket: Haskell code can produce Gigabytes of garbage a second.
00:34:02 <sinelaw> ok, and `X is variant "injection"?
00:34:14 <ski> yes ("polymorphic variants" in OCaml uses that notation)
00:34:16 <crocket> Can it collect the garbage efficiently and return free memory to OS?
00:34:16 <orb_> JVM wouldn't deal well with the kind of workload that Haskell causes, but I don't think ghc's gc is better in an absolute sense.
00:34:28 <sinelaw> crocket: ghc's GC isn't great
00:34:32 <orb_> Does anyone return free memory to OS?
00:34:33 <sinelaw> but isn't bad
00:34:45 <crocket> JVM almost never returns memory to OS.
00:34:59 <orb_> That's what Virtual Memory is for. ;)
00:35:18 <crocket> JVM doesn't even bother with virtual memory much.
00:35:19 <athan> cmon guys :(
00:35:19 <ski> sinelaw : "Polymorphic variants"  <http://caml.inria.fr/pub/docs/manual-ocaml/lablexamples.html#sec46>
00:35:37 <sinelaw> ski: yip, was just reading that the other day
00:35:41 <orb_> crocket: shouldn't the OS do that automatically?
00:35:46 <sinelaw> Peaker here showed me some nice things about them
00:35:59 <crocket> orb_, JVM refuses to return
00:36:01 <crocket> memory
00:36:16 <crocket> OSes can't steal memory from programs.
00:36:21 <orb_> crocket: sure, but the OS can park unaccessed pages on disk.
00:36:24 <crocket> If they did, programs would crash.
00:36:38 <crocket> orb_, That has a limit.
00:36:42 <orb_> As long as your gc is compacting and not fragmenting.
00:36:49 <orb_> Now, a compacting gc is a special beast.
00:36:56 <orb_> Some java virtual machines features these.
00:37:32 <orb_> It looks like you can ask ghc to run compaction on the oldest generation, too.
00:37:33 <crocket> To me, that's a horrible memory management practice.
00:37:37 <orb_> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/runtime-control.html
00:37:40 <orb_> crocket: why?
00:37:46 <sinelaw> so your `case` matches variant constructor X, takes the 'x' out of it, and puts it in a record { X | ... } ?
00:37:50 <crocket> It confuses users as to how much free memory you actually have.
00:37:57 <crocket> s/you/they/
00:38:03 <orb_> On a modern os you never have any free memory.
00:38:14 <orb_> It's all used for disk cache.
00:38:15 <crocket> orb_, linux calculates free memory anyway.
00:38:38 <crocket> disk cache is sort of free memory to be used by newly launched apps.
00:38:42 <sinelaw> ski: ^^
00:38:48 <nshepperd> it may be used for disk cache but it's stil free in that you can use it for things
00:38:57 <orb_> crocket: sort-of.  And so is memory that the apps don't touch.
00:39:18 <gamegoblin> Does where I put template haskell code into my program matter? I am getting an error that shows up if I have "template stuff <several newlines> my code" but does not error on "my code <several newlines> template code"
00:39:19 <nshepperd> after kicking out the disk cache contents
00:39:19 <orb_> `normal memory' is just mmapped to anonymous files in Linux.
00:39:21 <crocket> orb_, I'm not sure how well it works for now.
00:39:23 <gamegoblin> the template code is makeLenses
00:39:56 <crocket> If all system processes ran on JVM, it'd access swap too much.
00:40:05 <crocket> I told you, there are limits.
00:40:18 <orb_> crocket: that might be because Java accesses too much RAM,
00:40:23 <orb_> gc might not help there very much.
00:40:31 <ski> sinelaw : no, it matches all variant constructors, unwraps the value wrapped by it, extracts the field with the same name in the record, and applies the function (the "case branch") in that field to the unwrapped value
00:40:34 <crocket> That's what I was trying to mean.
00:40:35 <orb_> (Because the representation in memory of what's being worked on is just big.)
00:40:42 <orb_> At least that easily happens with Haskell.
00:40:45 <crocket> JVM is inefficient.
00:41:00 <orb_> Haskell is only memory efficient if you work for it (or get lucky).
00:41:04 <crocket> Does haskell return memory to OS?
00:41:10 <ski> @type uncurry either  -- sinelaw, compare with this
00:41:11 <lambdabot> (a -> c, b -> c) -> Either a b -> c
00:41:28 <orb_> crocket: wouldn't make a difference.  Keeping your working set small is what counts.
00:42:16 <shachaf> ski: "F -| G -| H" as a meaning for "F dual to H" is kind of odd, because it's not symmetric.
00:42:19 <sinelaw> ski: ah right, you did MapRow (-> o), so all fields contain handlers o -> ...
00:42:20 <orb_> crocket: see https://ghc.haskell.org/trac/ghc/ticket/698
00:42:31 <nshepperd> doesn't it make a difference? explicitly freeing memory provides more useful information to the OS than forcing it to rely on heuristics about last access time
00:42:49 <orb_> nshepperd: sure, but the heuristics ain't that bad in practice.
00:43:03 <nshepperd> for whether or not to park this or that page on disk
00:43:26 <ski> shachaf : *nod*
00:43:31 <sinelaw> ski: that's nice! but then how does the type checker match a given row type with MapRow (-> o)
00:43:33 <shachaf> ski: Is there a case with F -| G -| H -| I -| J, F /= J?
00:43:34 <orb_> They addressed returning memory to os that in the bug I linked.
00:43:48 <nshepperd> I find they're pretty terrible in practice
00:44:02 <arkeet> aren't double adjunctions like that relatively rare
00:44:05 <ski> sinelaw : no, all fields contain handlers of type `... -> o' (for varying `...')
00:44:08 <nshepperd> or at least, the heuristics for whether to kill apps or swap vigorously are pretty terrible
00:44:16 <sinelaw> ski: oh right
00:44:20 <arkeet> I can only think of one
00:44:23 <arkeet> in mathematics
00:44:49 <shachaf> Which one?
00:44:55 <sinelaw> so the type checker needs to know about MapRow, and do a type-level pattern-match on all fields to see they fit "-> o"?
00:44:56 <ski> shachaf : i don't know. it wouldn't surprise me, though
00:45:07 <arkeet> discrete and indiscrete topology
00:45:10 <orb_> nshepperd: anyway, they are returning memory to os now.
00:45:22 <shachaf> arkeet: ?
00:45:31 <arkeet> you have a forgetful functor from topological spaces to sets
00:45:35 <arkeet> it has both a left and right adjoint
00:45:37 <shachaf> Discrete functor is left adjoint to forgetful functor, which is left adjoint to indiscrete functor.
00:45:38 <arkeet> which are those two things
00:45:42 <arkeet> yeah
00:45:54 <shachaf> But how does that make five functors?
00:45:57 <sinelaw> ski: also, I'm still not sure what Rec does
00:45:57 <arkeet> it doesn't.
00:46:05 <arkeet> I'm not talking about quadruple adjunctions.
00:46:08 <shachaf> Oh, you're just talking about "F -| G -| H"?
00:46:12 <shachaf> That comes up all the time.
00:46:15 <sinelaw> isn't `MapRow (-> o) r` enough?
00:46:16 <arkeet> maybe.
00:46:20 <shachaf> For instance everywhere where you have a limit and a colimit.
00:46:25 <shachaf> They're adjoint to the same thing.
00:46:36 <ski> <ski> `Rec :: Row * -> *',`Var :: Row * -> *'. the former forms a record type from a row of concrete types. the latter forms a variant type from a row of concrete types
00:46:41 <ski> sinelaw ^
00:46:56 <sinelaw> ski: yes, but what do you call a record vs. a row?
00:47:11 <ski> sinelaw : so `Rec {x :: Int,y :: Int}' is a type of points
00:47:51 <sinelaw> why not just '{ x :: Int, y :: Int }'
00:48:30 <ski> while `Var {ThisError :: (),ThatError :: Info,SuccessA :: A,SuccessB :: B}' is a variant type with four alternatives
00:48:47 <sinelaw> ah
00:49:03 <ski> sinelaw : because `{ x :: Int, y :: Int }' is the row itself, where we haven't decided yet whether to form a record or a variant type
00:49:09 <sinelaw> I've seen { , .. , } and [ , .. , ] somewhere
00:49:13 <sinelaw> matter of notation
00:49:15 <ski> (and where we may yet apply `MapRow' to it)
00:49:20 <Lokathor> ~575 definitions to declare and comment for my ffi module to be "complete"
00:49:25 <Lokathor> woo boy
00:49:28 <sinelaw> or +{ ... } and *{ .. }
00:49:35 <ski> yes
00:50:44 <sinelaw> ski: that's very nice, your case
00:50:53 <ski> does the indiscrete functor have a right adjoint ?
00:50:57 <martinvlk> @pl (\c -> not (isPunctuation c) && not (isSpace c))
00:50:57 <lambdabot> ap ((&&) . not . isPunctuation) (not . isSpace)
00:51:04 <sinelaw> enforcing that the row fields match the variant columns
00:52:23 <ski> sinelaw : without something like that, i don't see as much point in having a kind of rows, common to records and variants
00:52:48 <frerich> martinvlk: I think (with a de morgan) a 'not . ((||) <$> isPunctuation <*> isSpace)' would be nicer - but still more ugly than the pointy version you started with.
00:53:21 <ski> frerich : or `liftM2'/`liftA2' ?
00:53:22 <sinelaw> ski: I'm still wondering how one would implement type checking for MapRow. The checker will have to know about it specifically
00:53:35 <ski> sinelaw : probably
00:54:02 <martinvlk> frerich: yeah, thanks for guidance.. appreciated - I always try to see what lambdabot has to say, often I end up with the old version being the clearest
00:54:37 <martinvlk> let me see with lift..
00:54:38 <ski> (also, to avoid lambdas in types, one might want to make a version of it that binds the row component type variant)
00:54:55 <ReinH> I don't think the (a ->) applicative is a usually good way to make code simpler
00:55:07 <qmm> https://groups.google.com/forum/#!msg/elixir-lang-talk/Vq--xwBMmAI/WRjH3NKlZVYJ
00:55:17 <qmm> is there anything like behaviours or protocols for haskell?
00:55:20 * ski didn't notice that was the idiom being used
00:56:10 <ely-se> qmm: type classes can do everything protocols can do
00:57:23 <ely-se> behaviours aren't a thing in Haskell
00:57:24 <ReinH> I think the (a ->) applicative is a good way to make people stop and think about what applicative is being used ;)
00:57:39 <ely-se> Modules aren't first-class values anyway, so they'd be quite useful.
00:57:57 <ely-se> eh, useless*
00:59:17 <sinelaw> ski: thanks for this, I have more food for thought
00:59:20 <sinelaw> later
01:03:11 <nshepperd> I still don't really understand what first class modules are for (in erlang or ocaml)
01:04:11 <nshepperd> I understand them to be something like a record object containing a few values but also with associated types?
01:05:21 <chattered> nshepperd: I've seen them used for academic hacks mostly. You should be able to get higher-rank polymorphism using them, for starters.
01:06:09 <chattered> I've yet to use them in earnest.
01:07:05 <ski> nshepperd : factoring out the particular implementation of a library interface that you're using in some other module
01:07:50 <chattered> ski: Wouldn't you just use an ordinary functor for that.
01:07:53 <chattered> ?
01:08:04 <ski> so that, to swap out implementation of a data structure, e.g., you don't have to modify the module using it, at all. instead modifying the external application of that module to the data structure implementation module
01:08:31 <qmm> "Code written without using behaviours can be more efficient, but the increased efficiency is at the expense of generality. The ability to manage all applications in the system in a consistent manner is important. Using behaviours also makes it easier to read and understand code written by other programmers. Improvised programming structures, while possibly more efficient, are always more difficult to understand."
01:08:35 <ski> chattered : "functor" in which sense ?
01:08:39 <chattered> The Ocaml sense.
01:08:44 <nshepperd> ski: right, so that is the dictionary transformation of using a typeclass in haskell?
01:08:53 <ski> chattered : then that's what i'm talking about, yes
01:08:55 <qmm> http://www.erlang.org/doc/design_principles/des_princ.html
01:09:06 <chattered> ski: I thought be "first-class modules", we were talking about modules as runtime values.
01:09:10 <chattered> Ocaml has those now.
01:09:51 <ski> oh, i understood nshepperd as primarily asking about module functors
01:09:59 <qmm> http://elixir-lang.org/getting-started/typespecs-and-behaviours.html#behaviours is also worth a look
01:10:22 <nshepperd> ski: yes, that's the correct interpretation of my question
01:10:37 <ski> you could serialize module values and pass them over a network connection, i think .. (iirc Alice ML can do this ?)
01:10:49 <chattered> Apologies then. You use functors all the time.
01:10:56 <noodles-> random question, how many of you use/have used Haskell at work?
01:11:13 <nshepperd> data Arithmodule = forall a. Arithmodule { ttype :: Proxy a; (+) :: a -> a -> a; (*) :: a -> a -> a; negate :: a -> a } -- would this be a reasonable representation of an ML module?
01:12:27 <quicksilver> unfortunately a lot of the approach that GHC uses for optimisation (inlining + rules) is defeated by such thorough modularisation
01:12:40 <nshepperd> or...
01:12:50 <quicksilver> to recover it you'd need to do some kind of 'just-in-time' optimisation when the modules are composed at runtime
01:13:28 <nshepperd> well, Arithmodule would need some conversion functions to be actually useful for anything, Int -> a; a -> Int or whatever
01:13:49 <ski> nshepperd : with a typeclass, you can associate at most one instance with a particular set of type parameters for a type class. in return, the instances gets constructed and passed around automatically (implicitly)
01:14:07 <qmm> quicksilver: do you think it's possible that in the future modules might be first class?
01:14:18 <ski> nshepperd : with a module argument, you don't need to cater to such a restriction
01:14:50 <quicksilver> qmm: I think it is something that interests a number of people and might motivate an experimental implementaiton :)
01:15:07 <ReinH> Haskell doesn't have modules in the Erlang or ML sense. It has namespaces that are called modules
01:15:18 <ely-se> lol
01:15:26 <quicksilver> I haven't read scrollback, has backpack been mentioned yet?
01:15:35 <qmm> nope
01:15:54 <quicksilver> google "haskell backpack" for papers, blog posts and wiki pages
01:16:07 <quicksilver> it isn't everything mentioned above but it intends to address some of it
01:16:08 <ReinH> There was just a talk at ICFP, perhaps the video is up...
01:16:52 <ReinH> (about backpack)
01:18:36 <ReinH> nshepperd: you might find this one interesting https://www.youtube.com/watch?v=42Wn-mXWcms
01:18:50 <lpaste_> inininin pasted âProfunctors cabal install errorâ at http://lpaste.net/140174
01:19:09 <ReinH> Not seeing the one I was looking for yet
01:19:29 <ReinH> nshepperd: btw you aren't at icfp, are you?
01:19:32 <inininin> Anyone ever had trouble with installing profunctors through cabal like this? http://lpaste.net/140174
01:19:59 <qmm> it looks like backpack is actually happening! :) https://ghc.haskell.org/trac/ghc/wiki/Backpack
01:20:59 <ReinH> fsvo happening
01:21:13 <ReinH> or actually
01:26:22 <qmm> ReinH: i'm sorry, i don't follow. it looks like there is progress and possibly almost complete?
01:26:54 <ReinH> Well, if happening involves being a part of GHC, it isn't happening.
01:27:04 <qmm> oh
01:27:20 <ReinH> At the moment it's a proposal
01:29:24 <nshepperd> ReinH: I'm not
01:29:30 <nshepperd> maybe I should be!
01:30:25 <jhrcek> noodles- I use it at work, but just for personal purposes (scripting, automation etc - not teamwide tools)
01:32:33 * hackagebot Hoed 0.3.0 - Lighweight algorithmic debugging.  https://hackage.haskell.org/package/Hoed-0.3.0 (faddegon)
01:32:47 <ReinH> nshepperd: yes
01:33:41 <quicksilver> ReinH: it's a proposal co-authored by SPJ and being worked on by an MSR intern though?
01:33:47 <quicksilver> which is some kind of 'happening'
01:36:53 <ReinH> that's what I said :)
01:38:49 <merijn> quicksilver: ezyang is working on backpack
01:39:01 <merijn> quicksilver: And has been for awhile, I talked with him about it at PLDI'14
01:39:14 <ReinH> yep
01:39:27 <merijn> The GHC mailing list earlier this week said that preliminary work for backpack is shipping in 7.12
01:39:36 <merijn> So I don't see how "it isn't happening" can be true
01:40:44 <merijn> "Backpack is chugging along; we have a new user-facing syntax which allows multiple modules to be defined a single file, and are hoping to release at least the ability to publish multiple "units" in a single Cabal file."
01:43:37 <ReinH> nice
01:43:50 <ReinH> I just didn't want to give the impression that it was scheduled for a release
01:44:53 <qmm> why is the next major release after ghc 7.10 ghc 7.12? :)
01:45:08 <Hafydd> Microsoft.
01:45:08 <ReinH> odd numbers are bad luck
01:45:30 <ReinH> (https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/version-numbering.html)
01:45:54 <qmm> hah :) thank you ReinH 
01:48:28 <merijn> qmm: odd numbers are development branches :)
01:48:47 <merijn> I think linux followed the same release numbering?
01:53:41 <lieven> they used to but they've stopped 
01:53:59 <lieven> the major problem was noone was working on the so-called stable branches
01:56:42 <merijn> Holy hell, this is the genius stuff I've always wanted but couldn't figure out how to implement: https://github.com/mikeizbicki/ifcxt#ifcxt
01:57:55 <lieven> wow, I'm surprised this is even possible
02:01:25 <ski> nshepperd(,chattered) : see "Re: Is overloading a good thing?" on <news:comp.lang.functional> in 2002-07-14 by Neelakantan Krishnaswami,Adrian Hey at <news:slrnaj33gt.gos.neelk@h00045a4799d6.ne.client2.attbi.com>,<news:1026869085.2292.0.nnrp-12.c1ed6811@news.demon.co.uk>
02:01:33 <ski> (see e.g. <https://groups.google.com/forum/#!original/comp.lang.functional/_gLfqJN_7pE/opce0T3FnqwJ>,<https://groups.google.com/forum/#!original/comp.lang.functional/_gLfqJN_7pE/uL-Ky6GH6iIJ>,<https://groups.google.com/forum/#!topic/comp.lang.functional/_gLfqJN_7pE>)
02:02:13 <ski> for some info on how one can encode functors in Haskell, using existentials
02:06:10 <chattered> ski: Yeah. The first time I read the title of Bob Harper's blog, I went "oh yeah", and did an existential encoding of abstract collections in Haskell.
02:07:33 <chattered> Though Ocaml has additional goodies as well, such as structural subtyping of modules and things like equality constraints.
02:07:52 <qmm> i'm posting at https://groups.google.com/forum/#!forum/parallel-haskell with questions that i have which i think are relevant to that mailing list
02:08:22 <qmm> i would be happy if any of you were to look at it and comment somehow
02:08:24 <nshepperd> ski: I was just fiddling with that now
02:08:48 <lpaste_> nshepperd pasted âmodules?â at http://lpaste.net/140179
02:09:01 <nshepperd> eg. the above ^^
02:09:17 <nshepperd> but i'm not sure if what i implemented is actually the correct thing
02:10:21 <ski> chattered : *nod*
02:14:37 <ski> nshepperd : i'm not sure whether you need the proxy there, since you have no constraints on `s'
02:16:26 <nshepperd> ah, yes, in this case I don't think I use it
02:16:37 <ski> nshepperd : it might perhaps be nicer to make the constraint a parameter. like `module_set :: SetModule Ord' and `module_unsorted_list :: SetModule Eq'
02:17:11 <ski> possibly using
02:17:16 <ski> @hackage constraints
02:17:16 <lambdabot> http://hackage.haskell.org/package/constraints
02:19:12 <eikke> when using GHC.TypeLits.someNat and pattern-matching on the result to get a Proxy n (and as such 'n' with ScopedTypeVariables), is there any way to 'prove' 'n' obeys to a certain constraint (e.g. > 0, which it is by construction in the code)?
02:20:54 <quicksilver> meretrix: 
02:21:21 <quicksilver> merijn has gone, apparently, but isn't that ifCxt trick unsafe for the usual reasons overlapping instances are unsafe?
02:21:32 <nshepperd> ski: I think in this case they would both be Ord since I need findMinimum
02:22:02 <comerijn> quicksilver: Naah, just university wifi that crapped out :p
02:22:03 <nshepperd> but yes, I can do that with ConstraintKinds
02:22:32 <quicksilver> merijn: ah, I have joins and quits hidden in this channel because they are too noisy
02:22:38 <merijn> Same here :)
02:22:54 <merijn> Anyway, I guess. But that's not THAT big of an unsafety
02:22:58 <quicksilver> anyway, overlaps like that fail with separate compilation in some cases
02:23:10 <merijn> Because I don't think you can really define more specific overlaps than "complete direct overlap"
02:23:15 <shachaf> That's why you need glguy's fancy Haskell IRC client.
02:23:16 <quicksilver> you can have cases where it can't "see" the instance beacuse it wasn't visibel in the module it was compiled it
02:23:17 <merijn> So I think it should be pretty robust
02:23:33 <ski> nshepperd : hm, you're right
02:23:43 <merijn> shachaf: Which one? Can I script it in haskell? :>
02:23:46 <shachaf> Where you can press a key to show all the things you were hiding, and another key to hide them again. Or collapse all joins/quits into one line.
02:23:57 <shachaf> https://github.com/glguy/irc-core
02:25:17 <ski> nshepperd : an alternative would be to have a fold operation which as a precondition required the operation to be "commutative"
02:26:36 * ski measures time by the passage of joins and parts/quits
02:27:09 <chattered> Just like the ancient Egyptians used to.
02:28:32 <merijn> ugh, I hate having to rethink the tricky parts of my parser >.<
02:33:36 <quicksilver> just change the language to match what the parser does
02:33:38 <merijn> Is anyone that's used trifecta aware of something like (atto)parsec's <?> combinator for labelling failures
02:34:10 <merijn> quicksilver: Well, that'd be easy, because currently the parser hangs :p
02:34:20 <merijn> quicksilver: So it treats all input as identical :p
02:34:25 <quicksilver> perfect
02:42:26 <qmm> "Spawning processes is cheap, but not free as each process is a haskell thread, plus some additional book keeping data."
02:48:33 <ReinH> merijn: parsers has <?>
02:48:42 <ReinH> trifecta is meant to be used with the combinators from parsers anyway
02:48:45 <merijn> ReinH: oh? Maybe I'm blind :)
02:48:49 <merijn> ReinH: I know :)
02:48:57 <ReinH> http://hackage.haskell.org/package/parsers-0.12.2.1/docs/Text-Parser-Combinators.html#v:-60--63--62-
02:51:52 <cocreature> merijn: you need to improve your hoogle skills :)
02:52:32 <RageYL> i'm writing a scheme interpreter (i am inspired by https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Error_Checking_and_Exceptions). i would like to add error handling. but i wonder if Either would not be better than exception
02:53:37 <RageYL> in the document they use error (which say is deprecated), so i tried with exception. after reading some papers about Either vs Maybe vs exception i think it's bettter to use Either/Maybe when we now something can go wrong
02:53:55 <RageYL> for example if the parsing fail would you use exception or either ?
02:54:36 <Intolerable> Either
02:54:51 <Intolerable> parse failures are absolutely not the right thing to use exceptions for
02:54:52 <liste> Either can be handled from pure code
02:55:09 <cocreature> RageYL: the tutorial uses Either, ThrowsError is just a type synonym for Either LispError
02:55:40 <RageYL> ah ok
02:55:49 <RageYL> so i will use either everywhere ;)
02:55:50 <RageYL> thanks
02:59:15 <nshepperd> I use (pure) exceptions for the cases where failure indicates catastrophic programmer error or such
02:59:49 <orbifx1> merijn: https://github.com/orbifx/hacronyms/commit/7e37e345d2b82c45e8b8b60c22dcb143867b55a2
03:00:24 <nshepperd> eg. if you try to get the minimum from a set in which you just inserted an element, it makes sense to throw an exception if the set is empty, because that means the set operations are broken and there's no real sane recovery strategy
03:01:35 <RageYL> nshepperd: ok. i loved the example with the doctor in this post: http://programmers.stackexchange.com/questions/150837/maybe-monad-vs-exceptions
03:02:09 <nshepperd> parse failures are pretty 'normal' behaviour though, so better to use Either in that case
03:05:14 <frerich> orbifx1: I think another nice definition for 'cappedAtIdx'  would be 'cappedAtIdx i = zipWith (\n -> if i == n then toUpper else toLower) [0..]'
03:05:26 <nshepperd> ah, that's a nice example
03:06:27 <orbifx1> thanks frerich, I'll keep it in mind for next time.
03:06:34 <orbifx1> Kinda done with that project
03:21:27 <orbifx> but thanks frerich 
03:22:37 * hackagebot pcre-heavy 1.0.0.1 - A regexp library on top of pcre-light you can actually use.  https://hackage.haskell.org/package/pcre-heavy-1.0.0.1 (myfreeweb)
03:31:54 <mietek> My datatype has a GADT signature such as "data Foo :: (Bar -> *) -> Baz -> *".  I canât figure out the syntax for pulling out "Bar -> *" as a type synonym.  Any hints?
03:34:14 <cocreature> Bar -> * is not a type, so I don't think you can put that in a type synonym
03:34:49 <mietek> Itâs a kind, isnât it?
03:35:04 <cocreature> yep
03:35:11 <mietek> Thereâs some mention of that in https://ghc.haskell.org/trac/ghc/wiki/GhcKinds#Kindsynonymsfromtypesynonympromotion
03:35:17 <mietek> But I canât tell whatâs been done
03:38:21 <cocreature> mietek: that looks like even if it was implemented it could only promote type synonyms to kind synonyms, but they still need to be valid type synonyms which Bar -> * is not
03:49:13 <merijn> orbifx: cappedAtIdx adds a space every time you use it now
03:49:46 <hvr> what is considered a "project" in stack-lingo?
03:50:20 * hvr saw a comment that "each projects needs a stack.yaml"
03:50:24 <merijn> I would probably rewrite it: "cappedAtIdx _ [] = []; cappedAtIdx 0 (c:cs) = toUpper c : map toLower cs; cappedAtIdx n (c:cs) = toLower c : cappedAtIdx (n - 1) cs"
03:51:49 <mettekou> I've been struggling with a rather basic problem: converting an index in a multidimensional array to an index in its one-dimensional equivalent. The problem is that for example for int[4][4] a both a[0][3] and a[1][0] produce the same result. So I guess I must be missing a succ somewhere, but I can't seem to figure out where. http://lpaste.net/5198926086376783872
03:53:16 <orbifx> merijn: I want it to have a whitespace appended at that stage. Are you saying the number of whitespaces increased?
03:54:11 <merijn> orbifx: Well if you call cappedAtIdx multiple times you'll add a space every time
03:54:25 <merijn> Whether that's intended depends on you
03:54:51 <orbifx> yeah, the result was good
03:55:30 <mettekou> Got a better solution: use a list comprehension to generate all 3 index pairs, zip those with the integers and I should be golden.
03:55:43 <mettekou> Or n index lists, for that matter.
03:56:37 <orbifx> mettekou: Few days ago, I was asking how this could be done more.. monadically 0o if that is correct use of this vague term.
03:57:39 <orbifx> mettekou: list comprehension was one of my guesses although, I'm still not at a level i can just contrive that without a lot of trial and error or to know if it is possible.
03:57:40 <mettekou> orbifx: I'm gonna go with the zip with integers then assoc solution, because I'm using it in a toy compiler project for school, performance or even modularity and reuse aren't issues.
03:59:55 <merijn> How do I stop GHC from only evaluating traceM values once? (i.e. I want them reevaluated every time it runs across one)
04:03:15 <orbifx> mettekou: are you using the hacronyms code?
04:04:56 <cocreature> hvr: a stack project is a collection of cabal projects. you can have separate projects for each one or have one project containing multiple cabal projects which makes sense if they depend on each other and you want to modify all of them and not just treat them as deps
04:05:40 <mettekou> orbifx: Nope, never heard of it.
04:06:18 <orbifx> ok, thought you were referring to that when you said about zip with integers then association.
04:12:41 <bergmark> hvr: we essentially converted cabal.config -> stack.yaml to get our stack (!!!) building with stack
04:13:23 <hvr> cocreature: ...ok, what do you refer to as a "cabal project"  then? :)
04:13:53 <cocreature> hvr: the thing belonging to a .cabal file
04:14:36 <bergmark> this cabal.config was for all our internal packages, public packages, and forks
04:14:46 <hvr> cocreature: ok, so a 'cabal package'?
04:15:28 <hvr> bergmark: so you're replacing the use of 'cabal freeze' w/ the use of stack?
04:15:42 <cocreature> hvr: yeah, that's probably a better term
04:16:02 <bergmark> hvr: yup
04:16:34 <hvr> bergmark: and what's the benefit over cabal freeze?
04:17:23 <cocreature> the main reason I use stack is that it caches deps where possible
04:17:43 <bergmark> tracking of changes in dependencies is the biggest one, you can just run "stack build" and it will re-build everything that changed. cabal-install can kind of do that but it takes like 2 minutes for it to start building
04:17:59 <hvr> cocreature: judging from comments, I doubt it exploits *all* opportunities to cache packages :)
04:18:36 <bergmark> we also moved to a private snapshot now to reduce rebuilds (e.g. when the stack sandbox gets corrupt....)
04:18:44 <cocreature> hvr: sure, but it uses more than cabal sandboxes do :)
04:19:16 <hvr> cocreature: more than "standard" cabal sandboxes... I've got a maximally caching system on top of cabal sandboxes 
04:19:36 <cocreature> oh cool
04:19:44 <hvr> it's used on matrix.hackage.haskell.org
04:20:59 <merijn> So how do people here debug their parsers? traceM only prints the first evaluation and I'm not quite understanding where mine gets stuck
04:21:06 <hvr> bergmark: the thing about dep-tracking is something I wanted to look at in cabal-install as well
04:21:31 <hvr> this seems slower than it could be
04:21:59 <hvr> bergmark: I assume you had many add-source packages?
04:22:27 <hvr> or is this also for many modules in a single package?
04:22:40 * hackagebot dequeue 0.1.10 - A typeclass and an implementation for double-ended queues.  https://hackage.haskell.org/package/dequeue-0.1.10 (HenryBucklow)
04:25:00 <mettekou> orbifx: http://lpaste.net/8044840166247890944 I did it like that.
04:25:38 <orbifx> merijn: are you using Parsec?
04:27:17 <orbifx> mettekou: what does this do?
04:28:16 <athan> Say I have a function `foo :: Int -> Maybe Foo`, and `xs :: [Int]`. How could I concurrently or in parallel run `foo` on random values in `xs`, until I get a `Just` value?
04:28:21 <athan> All I need is one, that's the thing
04:29:09 <mettekou> orbifx: Provided with a list of indices for a multidimensional array, generates their onedimensional equivalent.
04:29:36 <mettekou> [0,1] should be indices though.
04:30:22 <orbifx> mettekou: I think there is some cross-over, how does that relate to the code I was mentioning?
04:30:33 <merijn> orbifx: parsers + trifecta
04:30:46 <orbifx> merijn: ok, not heard of either
04:31:00 <orbifx> better or different from Parsec?
04:31:25 <merijn> parsers is library that abstracts away attoparsec/parsec/trifecta so you can write parser library agnostic parsers
04:32:06 <merijn> It's also the main way to use trifecta. I like it better than parsec because the error reporting is awesome. But it's a bit more intimidating to get started, due to a lot of stuff being very polymorphic
04:33:31 <orbifx> merijn: I'll check it out.. * distractions * :P
04:34:16 <merijn> orbifx: Basically trifecta can output errors like http://files.inconsistent.nl/screen.png without you doing anything :)
04:35:15 <orbifx> handy
04:35:57 <qmm> i started acquainting myself with stack, but i'm having issues working with spock as shown here: https://gist.github.com/qmmdb/61548b843fae5beed0f8
04:36:16 <qmm> i'd like to try out spock if possible to see what's it like
04:39:08 <liste> qmm it's Spock, not spock
04:40:25 <EvanR> select "spock" = "Spock";
04:40:29 <EvanR> 1
04:40:50 <liste> at least hackage.haskell.org makes the difference
04:40:58 <liste> not sure about stack or cabal install
04:40:58 <bergmark> hvr: we have 138 packages at the moment... :-)
04:42:28 <hvr> bergmark: ...all as local packages?
04:42:45 <hvr> do you even use packages from Hackage anymore? =)
04:43:19 <bergmark> heh we use a lot from hackage
04:44:57 <liste> qmm does it help to change line 27 to , Spock >=0.9.0.1 in your paste?
04:52:39 <qmm> liste: thanks, Spock not spock
04:52:41 * hackagebot dequeue 0.1.11 - A typeclass and an implementation for double-ended queues.  https://hackage.haskell.org/package/dequeue-0.1.11 (HenryBucklow)
04:53:10 <qmm> is there a way to make runghc aware of stack?
04:53:30 <cocreature> qmm: have you tried stack exec runghc?
04:54:51 <qmm> `stack runghc Main.hs`
04:55:02 <qmm> cocreature: ah :)
04:55:21 <qmm> i just discovered it in https://github.com/commercialhaskell/stack/blob/master/GUIDE.md
04:55:22 <cocreature> ah right stack runghc also exists
05:02:42 * hackagebot dequeue 0.1.12 - A typeclass and an implementation for double-ended queues.  https://hackage.haskell.org/package/dequeue-0.1.12 (HenryBucklow)
05:03:21 <hc> hi there, quick question
05:03:37 <hc> I'm currently looking for a potential memory leak in my application; mapM_ shouldn't be the cause, if used like this:
05:03:40 <hc> -    mapM_ doWork $ repeat conn
05:03:42 <hc> +    doWork conn
05:03:45 <hc> should it?
05:04:21 <hc> (where conn is a postgresql connection)
05:04:51 <hc> (- and + are from the git diff)
05:07:29 <bartavelle> hc: why not "forever (doWord conn)" ?
05:07:35 <Hafydd> No comment on the main issue, but "mapM_ doWork $ repeat conn" could equivalently be written: "forever doWork".
05:07:42 <Hafydd> Er... yes, that.
05:07:42 <bartavelle> err doWork
05:08:20 <merijn> Not equivalent, "forever doWork" should be asymptotically more efficient
05:08:28 <hc> okay, the answer to that would be "because I haven't heard of it" ;-)
05:08:34 <merijn> Well, "forever (doWork conn)", I guess
05:08:35 <hc> thanks
05:09:00 <Hafydd> Why is it asymptotically more efficient?
05:09:16 <Hafydd> Does the list given by "repeat conn" get kept for some reason?
05:09:20 <merijn> Hafydd: Doesn't rebuild the monad data structure up repeatedly
05:09:34 <merijn> Hafydd: And it might be leaking the list, yes
05:09:40 <Hafydd> Hmm...
05:09:47 <merijn> Depends on the implementation of mapM_, I think
05:10:08 <Hafydd> Ah, I suppose so; but doesn't the former just add a constant factor?
05:10:19 <hc> (it's a stack installation with ghc 7.6.3)
05:10:36 <merijn> Hafydd: constant factors are still asymptotically faster :p
05:10:55 <merijn> Hafydd: asymptotically just means it's faster in the limit as input size grows towards infinity
05:11:35 <Hafydd> What is the input in this case?
05:12:03 <merijn> If 'f' and 'g' are in the same complexity class, they grow equally fast as input increases. If 'f' is a constant factor faster it is faster at any input size, including bigger ones and thus asymptotically faster :p
05:12:08 <merijn> Hafydd: Number of iterations
05:12:11 <merijn> Hafydd: I'd say
05:12:49 <Hafydd> Hmm... then I agree.
05:18:52 <JBX39> shouldn't a sufficiently smart compiler make them equivalent?
05:19:17 <merijn> JBX39: Sure, but sufficiently smart compilers don't exist at the moment :p
05:23:56 <JBX39> to those of us with more casual familiarity with ghc, it's not so obvious what exists at the moment
05:24:36 <jmcarthur> ghc is far, far, far from sufficiently smart
05:25:01 <kuribas> I wish ghc had the same budget as java ...
05:25:02 <merijn> Although, to be fair GHC, it's pretty impressive at optimising and other compilers are also far, far, far from sufficiently smart :)
05:25:04 <Gurkenglas> That's how "asymptotically equal" works in math, but "asymptotic complexity" ignores constant factors as well. https://en.wikipedia.org/wiki/Asymptotic_computational_complexity
05:25:05 <jmcarthur> it's actually really dumb. it just does things that look smart.
05:25:30 <jmcarthur> ghc is a pretty sophisticated compiler, yes
05:25:34 <JBX39> can you characterize 'dumb' for us?
05:25:55 <merijn> Gurkenglas: We weren't talking about "asymptotic computational complexity" but asymptotic runtimes, at least I was
05:25:56 <jmcarthur> the rules it follows are mostly straightforward and don't involve much deep analysis
05:26:04 <jmcarthur> JBX39: ^^
05:26:44 <JBX39> i guess, but there's certainly enough analysis to qualify it as optimizing
05:26:58 <jmcarthur> strictness analysis is kind of an interesting part, but i think that's the most magical bit to me
05:27:30 <jmcarthur> because in practice that's the part i find the most difficult to predict
05:27:39 <JBX39> hmmm i wonder about that actually
05:27:45 <jmcarthur> oh sure, it's very much an optimizing compiler
05:27:59 <JBX39> has it been proven we are near the theoretical limit of what can be accomplished via strictness analysis?
05:28:07 <c_wraith> No
05:28:15 <jmcarthur> i just can't imagine a compiler as predictable as ghc is anywhere near what most people mean by "sufficiently smart"
05:28:30 <c_wraith> There have been several recent advances in strictness analysis
05:28:36 <cocreature> sufficiently smart is always the thing we can't do right now
05:28:41 <JBX39> that's great news c_wraith 
05:29:16 <jmcarthur> i think of "sufficiently smart" as "i neither know nor care how it works"
05:29:31 <JBX39> which advances do you have in mind?
05:29:35 <jmcarthur> ... "because it does its job so well"
05:29:45 <c_wraith> You can show that in the limit, strictness analysis is the same as the halting problem.
05:30:18 <c_wraith> So if you want it to go fast, all you can do is approach it heuristically.
05:30:43 <c_wraith> And there are always more cases you can check for, as well as better ways to organize existing checks.
05:59:15 <merijn> heh
05:59:34 <merijn> GHC is acting weird...it's complaining I'm missing a pattern which is clearly there...
06:00:28 <lpaste_> merijn pasted âheh....â at http://lpaste.net/140206
06:00:50 <merijn> GHC keeps complaining I'm missing the empty list pattern there...
06:01:59 <Intolerable> that's the point at which i clean everything
06:02:05 <Intolerable> and build from scratch
06:02:32 <merijn> Intolerable: Already did that
06:02:36 <Intolerable> very odd
06:24:39 <phadej> Is there de-facto package for orphans for pretty from ansi-wl-pprint
06:24:48 <phadej> I so miss Pretty Text instance
06:31:35 <RageYL> i'm trying to execute: mapM ((+) 1) [Right 1, Right 2, Right 3] in ghci
06:31:50 <RageYL> is says that i must use FlexibleContext flag to be able to do that
06:31:58 <RageYL> how can i set a flag in ghci ?
06:32:05 <bergmark> :set -XFlexibleContexts
06:32:08 <RageYL> can't find anything in google
06:32:23 <Intolerable> you shouldn't need it for that, though
06:32:37 <RageYL> oh ! i missed the X.
06:32:47 <Intolerable> well i mean you need it for that
06:32:49 <Intolerable> but that isn't right
06:33:08 <Hafydd> RageYL: look at the output of :help in ghci, or at <https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html>.
06:33:09 <Intolerable> you don't need FlexibleContexts for what you actually want to do
06:33:11 <bergmark> strangely enough you do need it there, but it's also not a well typed expression
06:33:51 <bergmark> i suppose i haven't used ghci w/ 7.10 much yet
06:34:23 <Intolerable> :t mapM ((+) 1) [Right 1, Right 2, Right 3]
06:34:25 <lambdabot> (Num b, Num (Either a b)) => Either a [b]
06:34:33 <Intolerable> (nonsense)
06:34:48 <Hafydd> ((+) 1)>!
06:34:52 <Hafydd> *?!
06:34:58 <RageYL> Intolerable: i think i don't understand
06:35:22 <Intolerable> you're trying to do [Right 1 + 1, ...]
06:35:35 <Intolerable> which is not the same as [Right (1 + 1), ...]
06:36:00 <Intolerable> there's no Num (Either a b) instance
06:36:07 <Intolerable> because it's nonsensical
06:36:14 <RageYL> mapM is not your second proposition ?
06:36:34 <RageYL> i was trying this expression to understand how mapM worked, so ^^
06:36:40 <Intolerable> you need to do mapM (fmap ((+) 1)) [Right 1, Right 2, ...]
06:36:43 <Intolerable> fair
06:37:20 <RageYL> hum ok
06:38:06 <RageYL> ok now i understand ^^
06:38:16 <RageYL> mapM just 'chain' the result 
06:38:25 <srhb> @src mapM
06:38:25 <lambdabot> mapM f as = sequence (map f as)
06:38:39 <srhb> Yes, although we call it "sequence" instead of chain :-)
06:38:48 <RageYL> :D
06:39:54 <merijn> or "map (+1) . rights" :)
06:40:01 <merijn> Depending on your goal :p
06:40:04 <merijn> :t rights
06:40:05 <lambdabot> [Either a b] -> [b]
06:43:07 <chpatrick> what's _the_ paper for observable sharing?
06:47:45 <Sindriav_> @where real world haskell
06:47:45 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
06:47:53 * srhb snickers
06:48:17 <Intolerable> thanks lambdabot
06:48:19 <clrnd> lol
06:49:04 <aweinstock> Intolerable: would "instance (Num a, Num b) => Num (Either a b)" make sense?
06:49:07 <hodapp> lol, what chucklehead did that
06:49:15 <Intolerable> no
06:50:06 <Intolerable> what would be the value of Left 5.0 + Right 2
06:50:39 <clrnd> deppends on your political standing
06:51:05 <aweinstock> hmm, consider Left to be negative, so either Left 3.0 or Right (-2.0)? :)
06:51:16 <Intolerable> they're different types
06:51:16 <aweinstock> s/-2.0/-3.0
06:51:20 <aweinstock> oh
06:51:39 <aweinstock> (Num a) => Num (Either a a) then
06:51:50 <aweinstock> (it would be silly, but defineable)
06:52:28 <Intolerable> it would be a really shitty instance, nearly unusable, and almost certainly wrong most of the time
06:53:03 <Intolerable> there are lots of awkward instances that i would like to have, but Num Either is not one of them :)
06:53:51 <aweinstock> which instances?
06:54:37 <chpatrick> Left 3.0 `orbanviktor` Right True
06:55:44 <Intolerable> nothing in particular
06:55:56 <Intolerable> just stuff i come across and im like "this needs an X instance"
06:56:06 <Intolerable> but its a bit janky so i don't do it
06:57:05 <aweinstock> chpatrick: is that some sort of in-joke I'm not getting?
06:57:13 <chpatrick> never mind :P
06:57:22 <aweinstock> (if so, please explain it?)
06:57:47 * hackagebot amazonka-core 1.3.0 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.3.0 (BrendanHay)
06:57:48 <clrnd> hungarian joke?
06:57:49 * hackagebot amazonka 1.3.0 - Comprehensive Amazon Web Services SDK  https://hackage.haskell.org/package/amazonka-1.3.0 (BrendanHay)
06:57:51 * hackagebot amazonka-test 1.3.0 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.3.0 (BrendanHay)
06:57:52 <chpatrick> yeah
06:57:53 * hackagebot amazonka-config 1.3.0 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.3.0 (BrendanHay)
06:57:55 * hackagebot amazonka-sns 1.3.0 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.3.0 (BrendanHay)
07:02:34 <athan> Why isn't there an instance for Foldable Data.Vector.Storable.Vector?
07:02:53 <Intolerable> doesn't that have a Storable constraint?
07:02:55 <athan> foldr exists for it c_c
07:02:57 * hackagebot amazonka-sqs 1.3.0 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.3.0 (BrendanHay)
07:02:59 * hackagebot amazonka-glacier 1.3.0 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.3.0 (BrendanHay)
07:03:01 * hackagebot amazonka-cloudhsm 1.3.0 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.3.0 (BrendanHay)
07:03:03 * hackagebot amazonka-datapipeline 1.3.0 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.3.0 (BrendanHay)
07:03:04 <athan> ahhh I see
07:03:05 * hackagebot amazonka-iam 1.3.0 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.3.0 (BrendanHay)
07:03:08 <athan> thanks Intolerable
07:03:17 <Intolerable> Foldable has to work for any type of element
07:03:26 <Intolerable> which is why is has foldr but not Foldable
07:03:35 <Intolerable> there are a few containers with that
07:03:47 <Intolerable> Unboxed, Storable, Text, ByteString, etc
07:03:54 <UberLambda> Is purity really essential for fast multicore programming?
07:03:55 <mniip> same as why Set is not functor
07:04:12 <merijn> UberLambda: Define fast and multicore programming
07:04:14 <Intolerable> UberLambda: no, but it's very very nice to have
07:04:17 <UberLambda> Or you can mutate as much as you'd like as long as mutable data can't be shared among threads?
07:04:44 <UberLambda> merijn: say that I'd like to create a video game (soft real-time) that scaled well on X cores
07:04:46 <Intolerable> question: is there some way to hide hackage's synopsis thing without being able to click the button
07:04:56 <merijn> UberLambda: Also, you can mutate things just fine in haskell. As long as they're explicitly mutatable
07:04:59 <Intolerable> (nvm u can just click on it)
07:05:04 <Intolerable> (my monitor is too tiny)
07:05:14 <merijn> UberLambda: I've got slides to a relevant talk for you!
07:05:36 <UberLambda> merijn: :D
07:06:14 <merijn> UberLambda: Keynote at POPL (Principles Of Programming Languages) by Tim Sweeney (head of Epic Games): https://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
07:06:37 <chpatrick> athan: you could try mono-traversable
07:06:45 <chpatrick> or lens
07:06:54 <chpatrick> those are the current best approaches for monomorphic containers
07:07:01 <chpatrick> personally I think lens is better
07:07:01 <UberLambda> merijn: thanks, checking it out right now
07:07:37 <merijn> UberLambda: Basically, his opinion is "It won't be Haskell, but it will certainly be a lot more like Haskell than anything we have today"
07:08:07 * hackagebot amazonka-route53-domains 1.3.0 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.3.0 (BrendanHay)
07:08:09 * hackagebot amazonka-directconnect 1.3.0 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.3.0 (BrendanHay)
07:08:11 * hackagebot amazonka-devicefarm 1.3.0 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.3.0 (BrendanHay)
07:08:13 * hackagebot amazonka-cognito-sync 1.3.0 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.3.0 (BrendanHay)
07:08:15 * hackagebot amazonka-elb 1.3.0 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.3.0 (BrendanHay)
07:08:29 <frerich> It's Haytime!
07:09:02 <mniip> which gives me an idea
07:09:15 <UberLambda> merijn: I'd like to design a programming language... and I'm not sure about a lot of things
07:09:26 <UberLambda> the ideal use case would be for video games
07:10:12 <UberLambda> functional? partially functional and partially OOP-like? pure functions imposed + monads? pure functions optional? what threading models (STM?)?
07:10:24 <chpatrick> UberLambda: for fun or seriously?
07:10:28 <mniip> class Contains c f where cmap :: (c a, c b) => (a -> b) -> f a -> f b
07:10:28 <merijn> UberLambda: Do you plan to make it a typed language?
07:10:33 <merijn> chpatrick: Does it matter? :p
07:10:37 <chpatrick> kinda
07:10:41 <merijn> chpatrick: Why?
07:10:48 <chpatrick> there are a lot of serious languages here that are just another slight variation on something else
07:10:51 <liste> serious langs can be for fun too (:
07:10:54 <UberLambda> chpatrick: for fun... but if I can create one that works, I can't see why I couldn't use it for my own games
07:10:59 <merijn> Everyone should implement more languages...
07:11:03 <chpatrick> seems kinda pointless judging by how hard it is to get a language really good
07:11:08 <chpatrick> for a toy project sure
07:11:20 <UberLambda> I'd like to know how compilers work
07:11:24 <merijn> UberLambda: Right, so one book I'd recommend is TaPL (Types and Programming Languages)
07:11:25 <chpatrick> but I'm tired of seeing "ruby with curly brackets instead"
07:11:30 <liste> chpatrick why half-ass even a toy language?
07:11:39 <UberLambda> merijn: I'd like a type system similiar to Haskell's if possible :D
07:11:48 <chpatrick> I'm fine with taking a toy language seriously
07:11:50 <merijn> UberLambda: It explains everything you need to know and more about writing type systems/checkers for languages
07:11:56 <merijn> @where tapl
07:11:56 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
07:11:57 <chpatrick> just not a serious language unless it's really something new
07:11:59 <fosterite> chpatrick: the hardest part of making a toy language is the parser
07:12:02 <UberLambda> merijn: nice :D
07:12:08 <chpatrick> fosterite: no it's not
07:12:12 <chpatrick> imo
07:12:16 <merijn> UberLambda: At the end of that book you should certainly be able to implement a type system like Haskell's without too much difficulty
07:12:17 <chpatrick> parsing is super easy with haskell
07:12:23 <chpatrick> the hard part is coming up with semantics that you won't regret later
07:12:45 <fosterite> chpatrick: parsing nice indent sensitive is a pain
07:12:58 <UberLambda> I'm not sure if I'd implement the compiler in Haskell... I'm a complete noob
07:12:58 <merijn> UberLambda: It contains example implementations of all type systems, checkers, and evaluators discussed too. (In ocaml, unfortunately, but should be trivial to read with only basic haskell knowledge)
07:13:02 <chpatrick> I don't think the implementation is really the hard part
07:13:06 <chpatrick> it's the design
07:13:08 <UberLambda> but Parsec seems quite nice
07:13:11 <chpatrick> UberLambda: it's a great way to learn
07:13:17 * hackagebot amazonka-cloudformation 1.3.0 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.3.0 (BrendanHay)
07:13:18 <chpatrick> writing compilers is a haskell killer feature
07:13:19 * hackagebot amazonka-sts 1.3.0 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.3.0 (BrendanHay)
07:13:20 <clrnd> merijn, the unreal slides are from 2005! wow
07:13:21 * hackagebot amazonka-kinesis 1.3.0 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.3.0 (BrendanHay)
07:13:23 * hackagebot amazonka-cloudsearch-domains 1.3.0 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.3.0 (BrendanHay)
07:13:25 * hackagebot amazonka-cloudwatch 1.3.0 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.3.0 (BrendanHay)
07:13:32 <merijn> fosterite: I just finished implementing my layout based parser with trifecta
07:13:33 <chpatrick> such amazon
07:13:33 <UberLambda> merijn: isn't Haskell quite similiar to ML?
07:13:44 <fosterite> well, my toy language is "fun with dependent types" so I don't really have semantics
07:13:52 <merijn> fosterite: Well, hopefully... :p It can parse my current layout, but not sure if it's very robust
07:13:54 <UberLambda> chpatrick: yeah, but I'm still really imperatively-minded :P
07:14:07 <UberLambda> chpatrick: and I seem to have an allergy to some monads
07:14:11 <chpatrick> well it's time to open your mind :D
07:14:22 <merijn> UberLambda: In many ways it is, in many others it's not. But the book only uses basic ocaml, which is very much like haskell
07:14:23 <fosterite> merijn: is there a decent axplanation of what's going on with trifecta? I am aware it's supposed to be awesome but when I looked at it a while ago the story was "check out idris' parser"
07:14:26 <chpatrick> compiler stuff is a real joy in haskell
07:14:39 <UberLambda> I don't think imperative programming has a bright future IMHO
07:14:52 <merijn> fosterite: ok, so the trick with trifecta is that you don't look at the docs of trifecta, because they're mostly not needed
07:15:08 <fosterite> merijn:  just pretend it's parsec and go to town?
07:15:22 <merijn> fosterite: The things you have to look at are the typeclasses
07:15:24 <UberLambda> merijn: thanks for both links, I'll read them as soon as I can
07:16:01 <merijn> fosterite: The parsers package has the TokenParsing typeclass with instance for parsec (and maybe attoparsec?), trifecta includes instances for Text.Trifecta.Parser
07:16:27 <athan> Is there a strict `foldl'` for lists?
07:16:42 <merijn> fosterite: Additionally trifecta includes classes like DeltaParsing (with positioning), and LookAheadParsing with again instances for trifecta
07:17:18 <fosterite> merijn: oh I see, found it
07:17:21 <merijn> fosterite: So my current parser just uses combinators from parsers to write my parsers (they're basically the same as Parsec) and imports Text.Trifecta.Delta so I can use "position" to get positions in the file
07:17:46 <fosterite> an aside: I spent a few days trying to get invertible parsing/prettyprinting working on a real example
07:17:50 <fosterite> more trouble than it's worth
07:18:00 <clrnd> athan, I thought foldl' was strict and for lists
07:18:05 <merijn> fosterite: I did the same thing as this example I got linked: https://github.com/bartavelle/language-puppet/blob/master/Puppet/Parser.hs#L73-L94
07:18:15 <clrnd> :t foldl'
07:18:16 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
07:18:27 * hackagebot amazonka-cloudtrail 1.3.0 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.3.0 (BrendanHay)
07:18:29 * hackagebot amazonka-elasticache 1.3.0 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.3.0 (BrendanHay)
07:18:31 * hackagebot amazonka-importexport 1.3.0 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.3.0 (BrendanHay)
07:18:33 * hackagebot amazonka-s3 1.3.0 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.3.0 (BrendanHay)
07:18:35 * hackagebot amazonka-swf 1.3.0 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.3.0 (BrendanHay)
07:18:58 <fosterite> merijn: I'll give it a shot later today
07:19:14 <merijn> fosterite: i.e. I defined "newtype Parser a = Parser (StateT Layout Trifecta.Parser a)", used GeneralizedNewtypeDeriving to derive all instances except TokenParsing from Trifecta.Parser and then defined a custom TokenParsing instance to implement my whitespace rules
07:19:33 <merijn> fosterite: Once I figured out this trick, writing the parser was easy-peasy
07:19:36 <fosterite> merijn: how do you get the indent-sensitive stuff going
07:19:50 <merijn> Currently extremely ghetto-style Haskell-like rules
07:20:52 <merijn> I have "StateT [Layout]" with "data Layout = Indent Int64 | NewLayout", my definition of "token" in TokenParsing checks the state, if it has NewLayout at the top I put the current offset as new Indent onto the Layout
07:20:57 <fosterite> merijn: oh I had hoped there was some magic that did it like Data.Syntax.Indent
07:21:10 <fosterite> although I've never used that
07:21:20 <fosterite> gotta go, meting I forgot about, thanks for your help
07:21:29 <frerich> merijn: I'd be really happy if you could wrap your head around Trifecta and then build 'Trifecta-for-mere-mortals' which is the same thing but about 50% less polymorphic.
07:21:58 <merijn> frerich: Look at the earlier puppet example, it was fairly enlightening to me. In hindsight it's not that hard...
07:22:22 <ttt_fff> anyone have a nice haskell DSL which outputs erlang ?
07:22:35 <clrnd> jaja
07:22:52 <clrnd> ttt_fff, no, but you have distributed-process to avoid erlang entirely
07:23:03 <ttt_fff> yeah
07:23:10 <ttt_fff> but that does not give you per heap gc
07:23:13 <ttt_fff> which gives you low latency
07:23:18 * ttt_fff puts down erlang sales matrial
07:23:23 <Intolerable> lol
07:23:30 <clrnd> ajja, I guess not
07:23:31 <Intolerable> what's wrong with just writing erlang?
07:23:36 <clrnd> but gives you type safety
07:23:37 * hackagebot amazonka-sdb 1.3.0 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.3.0 (BrendanHay)
07:23:39 * hackagebot amazonka-codecommit 1.3.0 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.3.0 (BrendanHay)
07:23:39 <ttt_fff> all I reallyw ant is the typing power of haskell with erlang's vm
07:23:41 * hackagebot amazonka-codedeploy 1.3.0 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.3.0 (BrendanHay)
07:23:43 * hackagebot amazonka-cloudfront 1.3.0 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.3.0 (BrendanHay)
07:23:45 * hackagebot amazonka-efs 1.3.0 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.3.0 (BrendanHay)
07:23:48 <Intolerable> and just using dialyzer a bunch?
07:23:57 <Intolerable> i know its not quite haskell
07:23:57 <merijn> frerich: hold on, I'll just push my initial commit to github
07:24:00 <ttt_fff> Intolerable: dialyzer does "success typing", which is the really weird
07:24:14 <Intolerable> but writing erlang isn't that bad
07:24:25 <Intolerable> it's certainly not as awkward / error-prone as writing c
07:24:37 <Ankhers> Elixer. But it doesn't have a type system (that I know of)
07:24:40 <ttt_fff> i'm not bashing erlang
07:24:51 <ttt_fff> I would just be happier if I had type safety.
07:25:29 <myfreeweb> Ankhers: Elixir has optional type annotations for the dialyzer thing
07:25:42 <Ankhers> myfreeweb: I did not know that.
07:25:43 <merijn> frerich: https://github.com/merijn/lambda-except
07:25:43 <ttt_fff> erlang has optional type annotation too, but Dialyzer != HM type checking
07:25:49 <ttt_fff> it does "success typing" which is not nearly as useful
07:26:05 <merijn> frerich: Lexer.hs does the layouting stuff and Parse.hs obviously does the parsing :)
07:26:09 <frerich> merijn: I hope you'll go slow, I'm on the Parsec level and kmett-style things like 'coparse :: CoyonedaParse o h m y g o d -> ParsecT h e l p m e p l z' makes me weep in frustration. :-)
07:26:43 <clrnd> :t CoyonedaProPreFunctorMaybeLens
07:26:44 <lambdabot>     Not in scope: data constructor âCoyonedaProPreFunctorMaybeLensâ
07:26:44 * frerich looks...
07:26:47 <merijn> frerich: Parse.hs looks exactly like a Parsec parser would
07:27:12 <merijn> frerich: There's an immediate improvement in error reporting, though: http://files.inconsistent.nl/screen.png
07:27:29 <merijn> (Sorry for the excessively large screenshot xD)
07:27:40 <merijn> I don't even use lens atm
07:28:18 <epta> merijn: is it a Monaco font?
07:28:21 <frerich> merijn: https://github.com/merijn/lambda-except/blob/master/Lexer.hs#L27 does not look like something I'd start with (not sure I ever derived so many things at once)
07:28:43 <merijn> epta: Yeah
07:28:46 <merijn> epta: <3 Monaco
07:28:47 * hackagebot amazonka-codepipeline 1.3.0 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.3.0 (BrendanHay)
07:28:49 * hackagebot amazonka-elasticbeanstalk 1.3.0 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.3.0 (BrendanHay)
07:28:51 * hackagebot amazonka-autoscaling 1.3.0 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.3.0 (BrendanHay)
07:28:53 * hackagebot amazonka-ses 1.3.0 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.3.0 (BrendanHay)
07:28:55 * hackagebot amazonka-support 1.3.0 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.3.0 (BrendanHay)
07:29:11 <merijn> frerich: I just literally copied every single instance from Text.Trifecta.Parser and copied them all
07:29:24 <UberLambda> What would be the "correct" way to parse an indentation-sensitive language?
07:29:28 <merijn> frerich: Just to be sure that every trifecta/parsers functions/combinators would work
07:29:41 <merijn> UberLambda: Depends on the kind of indentation you wanna parse
07:29:42 <UberLambda> Inject a monad in a parser combinator to keep track of the current indentation level?
07:29:57 <merijn> The repo I just linked does ghetto haskell-style layouting
07:30:01 <UberLambda> merijn: probabily python-style indentation sensitivity
07:30:14 <merijn> I didn't write a grammar spec before, so the implementation is a bit ad hoc :p
07:30:23 <frerich> UberLambda: I used the 'state' value which Parsec parsers come with in the past to keep track of such things.
07:30:24 <merijn> UberLambda: Python style with fixed indent levels would be easy
07:30:47 <UberLambda> and what about Haskell-style one? it seems a lot more complex :P
07:30:52 <UberLambda> like, really complex
07:31:35 <merijn> frerich: Alternative,MonadPlus, and all the usual ones should be obvious, I think
07:31:54 <merijn> frerich: And all the FooParsing ones are for trifecta functionality like the ability to get a position, etc.
07:32:07 <merijn> UberLambda: Haskell's layout rules are actually pretty simple
07:32:23 <merijn> UberLambda: See https://en.wikibooks.org/wiki/Haskell/Indentation
07:32:40 <merijn> Implementing them is a bit of a mess though. Like I said, my current implementation is rather...hacky :p
07:32:51 <UberLambda> merijn: I'm quite worried of "<keyword> line1 ... indented line 2 ..."-style blocks
07:33:21 <aweinstock> :t (>>>=)
07:33:23 <lambdabot>     Not in scope: â>>>=â
07:33:23 <lambdabot>     Perhaps you meant one of these:
07:33:23 <lambdabot>       â>>=â (imported from Control.Monad.Writer),
07:33:29 <merijn> aweinstock: That's from Bound
07:33:46 <merijn> It's basically "x >>>= f = x >>= lift . f"
07:33:57 * hackagebot amazonka-dynamodb-streams 1.3.0 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.3.0 (BrendanHay)
07:33:59 * hackagebot amazonka-redshift 1.3.0 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.3.0 (BrendanHay)
07:34:01 * hackagebot amazonka-opsworks 1.3.0 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.3.0 (BrendanHay)
07:34:03 * hackagebot amazonka-emr 1.3.0 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.3.0 (BrendanHay)
07:34:05 * hackagebot amazonka-cognito-identity 1.3.0 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.3.0 (BrendanHay)
07:35:24 <uniquenick> I don't know much about linking, so I am not sure what would cause this error: libHSwarp-3.1.3.a: unknown symbol `warpzm3zi1zi3_NetworkziWaiziHandlerziWarpziMultiMap_Tom_con_info'
07:35:59 <uniquenick> I get that when installing wai-app-static when it gets to linking in warp
07:35:59 <bergmark> uniquenick: usually a module is missing from exposed-modules for the barely readable package name
07:36:28 <bergmark> i've also seen it several times when a sandbox has gotten corrupted
07:38:39 <uniquenick> bergmark: thanks, fixing that worked
07:38:58 <chpatrick> why does linear's Additive have a Functor superclass?
07:39:07 * hackagebot amazonka-ssm 1.3.0 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.3.0 (BrendanHay)
07:39:09 * hackagebot amazonka-ml 1.3.0 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.3.0 (BrendanHay)
07:39:11 * hackagebot amazonka-workspaces 1.3.0 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.3.0 (BrendanHay)
07:39:13 * hackagebot amazonka-dynamodb 1.3.0 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.3.0 (BrendanHay)
07:39:15 * hackagebot amazonka-rds 1.3.0 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.3.0 (BrendanHay)
07:40:02 <bergmark> cool
07:42:15 <sinelaw> is haskell-src-exts compilation getting slower with every ghc release?
07:43:17 <merijn> sinelaw: There's a bug files against it for slowness, I think
07:43:48 <athan> Are parsec-3.1.9 and tf-random-0.5 broken? :(
07:43:54 <bergmark> there is
07:44:17 * hackagebot amazonka-ds 1.3.0 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.3.0 (BrendanHay)
07:44:19 * hackagebot amazonka-cloudwatch-logs 1.3.0 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.3.0 (BrendanHay)
07:44:21 * hackagebot amazonka-route53 1.3.0 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.3.0 (BrendanHay)
07:44:23 * hackagebot amazonka-cloudsearch 1.3.0 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.3.0 (BrendanHay)
07:44:25 * hackagebot amazonka-storagegateway 1.3.0 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.3.0 (BrendanHay)
07:44:38 <Taneb> chpatrick, I believe you can make fmap from liftI2 and zero
07:44:58 <bergmark> athan: i doubt it
07:45:16 <Taneb> chpatrick,:
07:45:18 <Taneb> Prelude Linear> :t \f -> liftI2 (\_ -> f) zero
07:45:18 <Taneb> \f -> liftI2 (\_ -> f) zero :: Additive f => (b -> c) -> f b -> f c
07:45:28 <Taneb> fmap
07:45:57 <bergmark> athan: http://matrix.hackage.haskell.org/package/parsec http://matrix.hackage.haskell.org/package/tf-random (warning for slow loading time)
07:49:27 * hackagebot amazonka-ec2 1.3.0 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.3.0 (BrendanHay)
07:49:29 * hackagebot amazonka-kms 1.3.0 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.3.0 (BrendanHay)
07:49:31 * hackagebot amazonka-elastictranscoder 1.3.0 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.3.0 (BrendanHay)
07:49:33 * hackagebot amazonka-lambda 1.3.0 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.3.0 (BrendanHay)
07:49:35 * hackagebot amazonka-ecs 1.3.0 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.3.0 (BrendanHay)
07:50:06 <athan> Hm, using --enable-executable-profiling causes them to break somehow bergmark
07:50:52 <athan> They are claiming to not have modules in-scope from dependency pragmas in your .cabal, when they're clearly there
07:50:56 <athan> It's a strange error
07:51:14 <athan> cabal-install v. 1.22.6.0
07:54:37 * hackagebot hpc-coveralls 1.0.0 - Coveralls.io support for Haskell.  https://hackage.haskell.org/package/hpc-coveralls-1.0.0 (killy971)
07:54:39 * hackagebot probability 0.2.5 - Probabilistic Functional Programming  https://hackage.haskell.org/package/probability-0.2.5 (HenningThielemann)
07:59:07 <bergmark> athan: worksforme
08:07:34 <S11001001> dolio: if you can't rename in darcs, what do you use for a mergeable skeleton?  if anything
08:16:17 <Jello_Raptor> hmm, is there some notion out there of pluggable syntax modification/parsing/semantics? I'm imagining someone defining an AST, a parser and a compiler for a language, and having an interface that allows people to add new syntax constructs modularly, along with rules for compilation and whatnot. 
08:18:35 <scshunt> Jello_Raptor: I'm not directly aware of one
08:18:57 <scshunt> but you could design a parser combinator library which was limited enough that it wouldn't cause issues with the larger parser
08:19:05 <scshunt> and  then modules could just supply those combinators
08:19:18 <Jello_Raptor> scshunt: I'm not sure what you mean :(
08:19:36 <dolio> S11001001: You can rename in darcs.
08:20:23 <scshunt> Jello_Raptor: are you familiar with parser combinator libraries?
08:20:40 <dolio> S11001001: It's called move, though.
08:21:14 <chpatrick> Jello_Raptor: template haskell/quasiquoters is almost that...
08:21:40 <chpatrick> you can do crazy stuff like inline-c
08:22:00 <Jello_Raptor> scshunt: not parsec or attoparsec. I've made a simple monadic/applicative parsing tool and used Happy and Alex, but that's it
08:22:26 <S11001001> dolio: oh, cool
08:22:57 <scshunt> Jello_Raptor: well, if you've build a monadic parser, then you should sort of understand
08:23:27 <dolio> S11001001: The thing you can't do is make a copy, like mercurial can.
08:23:41 <S11001001> dolio: which wouldn't matter for this, so cool
08:29:32 <geekosaur> Jello_Raptor, ghc has experimental support for plugins in HEAD
08:29:54 <geekosaur> (i.e. not in a released version that I am aware of)
08:32:15 <geekosaur> oh, probably not what was meant, feh
08:34:18 <dgryski> I've seen lots of haskell tutorials out there; any consensus of a reasonable one for somebody who already has lots of experience with imperative programming?  (both scripting languages and lower-level C stuff).  My background is math/cs.
08:35:04 <RageYL> dgryski: learn you a haskell
08:35:16 <dgryski> RageYL: thanks
08:35:28 <RageYL> i'm new to haskell but this is the one i've learn with and it is very well written
08:35:51 <sinelaw> dgryski: https://github.com/bitemyapp/learnhaskell
08:36:12 <dgryski> Ah, I was hoping to stay away from bitemyapp.  I just had a twitter conversation with him and it wasn't very pleasant.
08:36:19 <dgryski> Well, 'conversation' is perhaps the wrong word.
08:36:32 <sinelaw> :O
08:37:02 <liste> well that repo is mostly pointers to other materials
08:37:23 <liste> also, :O
08:37:25 <dgryski> I'll try learnyouahaskell. 
08:37:40 <dgryski> ( https://twitter.com/jacrough/status/639189916849573888 <-- but you'll need to click "More" a few times..)
08:37:54 <MarcelineVQ> You can't have conversations on twitter, it's an argument platform, probably should just start over.
08:40:20 <sinelaw> I just see 4 messages
08:41:19 <RageYL> imagine i have a big array that represent memory. how can i manage such a structure ? in haskell i don't know a way to modify element (and i think it's not something haskell do), so each time i change a cell, i should recreate a full memory object ? it seems non efficient to loop each time to access the good cell and maybe not efficient de recreate each time the array (but i think haskell may handle that
08:41:21 <RageYL> pretty well)
08:42:04 <sinelaw> RageYL: you can do that in haskell if you really need. in many case you just don't need to, there are other idioms 
08:42:20 <bergmark> haskell can do mutation, no problem, see e.g. Data.Array.ST
08:42:45 <RageYL> what's the way you would advice to do something like that (imagine i want to create an emulator)
08:42:49 <sinelaw> RageYL: a few of the common libs do it under the hood
08:44:04 <sinelaw> RageYL: there's this old page https://wiki.haskell.org/Arrays
08:44:31 <RageYL> thanks
08:44:32 <sinelaw> RageYL: and there's the vector package
08:44:32 <sinelaw> https://wiki.haskell.org/Numeric_Haskell:_A_Vector_Tutorial
09:02:54 * hackagebot propellor 2.7.3 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.7.3 (JoeyHess)
09:05:54 <chpatrick> RageYL: definitely MVector
09:06:05 <chpatrick> Data.Vector.Unboxed.Mutable for emulator memory :)
09:06:18 <RageYL> ok ;)
09:06:28 <chpatrick> or Data.Vector.Storable.Mutable if you need to pass it to some foreign library
09:06:56 <RageYL> for the moment that was just a question how i would do that in haskell, but i will take a look at your project one day i see you do all that stuff :D
09:07:13 <chpatrick> ok ok :P
09:07:14 <ReinH> (but try immutable vectors first. you might be surprised)
09:18:02 <Sindriav_> WHAT THE FUCK
09:18:04 <Sindriav_> Somebody hold me
09:18:13 * Sindriav_ curls up in the corner and sobs
09:19:21 <Sindriav_> I just tried Scala
09:19:23 <Sindriav_> It's evil
09:20:28 * liste holds Sindriav_
09:20:35 <Intolerable> try go
09:20:36 <Sindriav_> Thanks, liste
09:20:49 * d-snp cuddles Sindriav_ a bit
09:21:08 <Sindriav_> I spent 3 hours trying to get LWJGL to work and I had to give up
09:21:09 <d-snp> where did the bad language touch you?
09:21:29 <d-snp> I hope not in your immutable bits
09:21:45 <Sindriav_> d-snp: Itâ¦ it touched my tooling *cries*
09:21:50 <Sindriav_> The response from the community was astonishing.
09:22:09 <Sindriav_> "Yeah, you basically have to choose between two broken tools. Each one does something, but you need both, so you're basically fucked."
09:22:21 <Sindriav_> #hugYourCabalToday
09:22:29 <d-snp> :P
09:23:32 <Sindriav_> I'm seriously sorry about everything bad I've ever said about cabal-install :D
09:23:41 <Sindriav_> It feels good to be back ^-^
09:23:54 <tero-> Sindriav_: have you tried stack?
09:24:29 <liste> couldn't I just use Scala with Java tools
09:24:33 <liste> best of both worlds
09:24:41 <liste>  ave
09:26:13 <Ignatius> Walsall
09:29:19 <Ignatius> just wanted to go swimming
09:31:23 <Sindriav_> tero-: I've seen it, haven't yet tried it ^^
09:31:45 <Sindriav_> liste: Nope! Because each tool misses a very important aspect, and can't do just the thing I want x_x
09:32:02 <Sindriav_> Anyways, anyone have any tips on a new language I could try?
09:32:03 <Sindriav_> :D
09:32:16 <seanparsons> Esperanto.
09:32:19 <suppi> Sindriav_, what are you looking for?
09:32:39 <bitemyapp> Sindriav_: go hard. Learn Finnish.
09:33:21 <Sindriav_> suppi: First of all OOP, ideally compiled but with a repl (like Haskell). Easy C interaction, or SDL2 as a library. Something C-like, probably.
09:33:28 <Sindriav_> suppi: Basically C++, but a good language :D
09:33:47 <Sindriav_> suppi: I'm thinking about giving Objective-C + Swift another try
09:33:51 <suppi> Rust?
09:34:04 <Sindriav_> suppi: Rust is great, but it's not OOP :(
09:34:24 <suppi> what does OOP mean? inheritance?
09:34:34 <S11001001> @remember Intolerable try go
09:34:34 <lambdabot> It is stored.
09:34:37 <nshepperd> Ocaml? it has 'object' in the name!
09:34:50 <Intolerable> (go is so bad)
09:35:06 <S11001001> Intolerable: I liked the juxtaposition with your username
09:35:08 <Sindriav_> suppi: Well, object-oriented. Haskell is functional, Rust isâ¦ Like C, basically.
09:35:25 <suppi> (structured)
09:35:32 <suppi> D?
09:35:34 <Sindriav_> suppi: It has structs and functions. Doesn't have inheritance, doesn't have traits (proper)
09:35:48 <Sindriav_> suppi: That might be worth a look, yeah. I've been reading their webpage
09:35:53 <ReinH> Rust is like C with algebraic data structures, type inference, and affine types
09:35:57 <ReinH> so not very much like C
09:36:03 <nshepperd> meh, inheritance is bad anyway
09:36:07 <suppi> I don't really know of an interesting programming language with inheritance
09:36:12 <suppi> that has*
09:36:16 <Clint> OO is bad anyway
09:36:32 <Sindriav_> Clint: That's arguable. Have you ever done proper OOP? Like Smalltalk?
09:36:39 <ReinH> Rust has traits
09:36:42 <Clint> Sindriav_: no, i haven't
09:36:42 <suppi> Sindriav_, Haxe?
09:36:50 <Intolerable> try smalltalk
09:36:58 <Intolerable> its not useful but it is an adventure
09:36:59 <Sindriav_> ReinH: Yeah, but they can't add data, only methods
09:37:22 <Sindriav_> Intolerable: I'm familiar with it, but I'm waiting until I'm doing my masters degree (we have a really good course on it)
09:37:30 <ReinH> They are basically typeclasses
09:37:35 <Sindriav_> ReinH: Yeah
09:37:36 <suppi> I just don't like inheritance and mutability by default.
09:38:18 <Sindriav_> suppi: Inheritance isn't really what I'm after. What I'd like is basically a language-level ECS
09:38:45 <Sindriav_> suppi: I'll look at Haxe! Never seen it.
09:38:58 <suppi> what is ECS?
09:39:06 <Intolerable> entity component system
09:39:32 <Intolerable> i have a horrid ECS monstrosity in haskell somewhere
09:39:35 <suppi> hmmm
09:39:41 <Intolerable> should fish that out and get it working at some point
09:39:54 <Sindriav_> suppi: You have an Entity (basically an unsigned int used as ID), which has components assigned to it (structs, basically)
09:39:55 <suppi> oh, I heard Common Lisp has a good object system :P
09:40:15 <Sindriav_> suppi: And you have systems, which process entities based on the components they have
09:40:36 <Sindriav_> suppi: Good object system with a bad type system :D I like lisp, though. It's weird.
09:40:52 <suppi> so... adt and pattern matching?
09:41:04 <Sindriav_> suppi: Huh?
09:41:11 <Intolerable> suppi: not even similar
09:41:43 <Sindriav_> suppi: Yeah, that's really different.
09:41:47 <nshepperd> that seems like it would apply to lots of things?
09:42:04 <Sindriav_> I'll write down some pseudocode, so it's clear what I mean ^^
09:42:05 <nshepperd> like, a database has rows with ids and things associated
09:42:18 <Sindriav_> nshepperd: Basically
09:42:21 <Intolerable> its like a series of tables
09:42:26 <nshepperd> and any database accessing code is sort of a 'system'
09:42:28 <suppi> Sounds a bit like row polymorphism now that I think of it, you specify the components and the functions are the systems
09:42:29 <Intolerable> with a single primary key for all of them
09:42:56 * hackagebot ja-base-extra 0.1.0.0 - Extra functions I require in base  https://hackage.haskell.org/package/ja-base-extra-0.1.0.0 (justus)
09:43:02 <nshepperd> or it could just be an enormous Vector and some functions
09:43:21 <Intolerable> i use a series of maps
09:43:25 <Intolerable> one per component
09:43:45 <Intolerable> and then an applicative Map instance but its a bit awkward
09:43:49 <nshepperd> I don't really see what this has to do with object-orientedness
09:44:03 <Intolerable> it doesnt
09:44:27 <Intolerable> it's a bunch of entity IDs which can have any number of structs hanging off them
09:44:58 <Intolerable> outside of "this entity has X properties" its not very objecty
09:45:33 <suppi> this entity has X properties: { location :: Point | r }
09:45:59 <suppi> moveSystem :: { location :: Point | r } -> Point -> { location :: Point | r }
09:46:08 <suppi> pseudo code, does that make sense?
09:46:14 <Intolerable> eh
09:46:16 <Intolerable> yeah
09:46:35 <suppi> Sindriav_, PureScript :P
09:48:16 <Sindriav_> suppi: I'll look at that
09:48:20 <Sindriav_> Here's a VERY rough sketch: http://lpaste.net/628525213448929280
09:52:58 <chpatrick> late to the argument but I think OOP has its place
09:53:03 <chpatrick> it's just really overused
09:53:11 <chpatrick> since Java doesn't give you a choice
09:53:21 * S11001001 zzz
09:53:37 <chpatrick> but I don't think Haskell has a realistic alternative to the kind of entity systems game engines have
09:53:53 <suppi> what about extensible-effects?
09:53:57 <chpatrick> where everything has its own state
09:54:07 <suppi> I'm trying to find that blog post I was looking for...
09:54:23 <chpatrick> and there's a graph of mutable entities
09:54:25 <suppi> chpatrick, I think row polymorphism will do a great job at that actually
09:54:46 <chpatrick> haven't heard of that yet
09:55:37 <seanparsons> Ironically I think the data oriented design that a lot of game developers have oriented console game engines is _more_ suited to Haskell, because it reduces the amount of OO.
09:55:42 <suppi> chpatrick, which one?
09:55:48 <chpatrick> row polymorphism
09:56:03 <chpatrick> I don't know
09:56:26 <chpatrick> I have some career game developer friends and they said they couldn't imagine game logic programming without oop
09:56:35 <bitemyapp> chpatrick: you can do ECS in Haskell.
09:56:38 <suppi> chpatrick, https://leanpub.com/purescript/read#leanpub-auto-record-patterns-and-row-polymorphism
09:56:42 <bitemyapp> Just don't know that it'd be the nicest way to go.
09:56:46 <chpatrick> ECS?
09:56:53 <bitemyapp> chpatrick: entity component system
09:57:03 <chpatrick> I remember someone came on here asking about how to implement some kind of console game with entities
09:57:10 <seanparsons> chpatrick: I work at a game developer and my boss is a 15 year vet of the industry. :)
09:57:13 <chpatrick> without just making it a graph with dangling pointers etc
09:57:22 <chpatrick> and everyone was just like errrrrrr
09:57:26 <bitemyapp> the simplest thing is to compute a new game state and generate updates to the GL context from that.
09:57:29 <bitemyapp> then make it a loop
09:57:30 <chpatrick> fair does seanparsons
09:57:39 <bitemyapp> that doesn't really require OOP, row polymorphism, or anything else.
09:57:43 <bitemyapp> just functions, data, and some IO.
09:58:02 <chpatrick> that's simplifying a bit though
09:58:03 <suppi> I wrote a simple game in Elm once for ludumdare
09:58:12 <chpatrick> it's like saying for a car you just need four wheels
09:58:14 <suppi> not having oop was definitely not a problem
09:58:25 <bitemyapp> chpatrick: you need to get concrete or you're wasting your time.
09:58:29 <suppi> it was really simple to translate the logic of the game.
09:58:46 <bitemyapp> chpatrick: most times I've seen people try to embed OOP in Haskell, it was because they were new and didn't know what they were doing. Whether it was a game or not.
09:58:58 <chpatrick> exactly, which is why I said healthy way
09:59:00 <Sindriav_> suppi: I might look at Elm tooâ¦ Do you have any experience with Haxe?
09:59:01 <bitemyapp> without a real example to-hand which can be analyzed, this is pointless.
09:59:02 <Sindriav_> it looks neat
09:59:03 <dgryski> bitemyapp: I left my titanium spork in Canada when I moved
09:59:08 <chpatrick> I don't know any serious game written in any functional language
09:59:10 <chpatrick> correct me if I'm wrong
09:59:12 <suppi> But the lack of higher kinded system in Elm made it a little bit harder to generalize it
09:59:16 <suppi> Sindriav_, yes I do
09:59:36 <Sindriav_> suppi: How is it? How would you describe it to a newbie?
09:59:44 <dgryski> chpatrick: a few have used a lisp-like as a scripting language 
09:59:52 <chpatrick> can you give an example?
09:59:57 <seanparsons> chpatrick: Naughty Dog made a lisp called Goal for their Jak & Daxter games on the PS2.
09:59:58 <suppi> Sindriav_, it is very familiar if you know a java like language
10:00:17 <Sindriav_> suppi: Is it performant? Is there a lot of libraries?
10:00:20 <chpatrick> >Syntactically GOAL resemblesÂ Scheme, though with many idiosyncratic features such as classes, inheritance, and virtual functions
10:00:26 <chpatrick> that kind of supports my point
10:00:34 <suppi> Sindriav_, game related libraries, yes. it is relatively performant
10:00:38 <dgryski> chpatrick: Abuse is the obvious one. It's been long time since I've looked at any game code
10:00:59 <bitemyapp> chpatrick: https://github.com/nikki-and-the-robots/nikki
10:01:13 <Sindriav_> suppi: Game related is my jam! ^^ Is there an SDL2 port? Or does it come with it's own features instead of SDL (being cross platform and all)
10:01:19 <chpatrick> I'm not sure I'd call that a serious game, sorry
10:01:26 <seanparsons> Certainly with console games historically the main problem is that it's C/C++ or bust because of the tooling.
10:02:01 <bitemyapp> chpatrick: see, this is why I hate talking about game dev with people.
10:02:01 <suppi> Sindriav_, there are plenty of game frameworks and libraries like OpenFL, snowkit, HaxeFlixel, heaps.io
10:02:11 <bitemyapp> chpatrick: because if it's not a AAA game that cost $100 million to make, it doesn't count.
10:02:16 <suppi> nikki and the robots is serious
10:02:18 <chpatrick> that's not true
10:02:21 <chpatrick> I'd be fine with a popular indie game
10:02:29 <Sindriav_> "serious"
10:02:33 <bitemyapp> what does popularity have to do with the fucking code?
10:02:36 <Sindriav_> what the fuck does "serious" mean
10:02:46 <bitemyapp> it's an interactive game with graphics, audio, etc. the works.
10:02:48 <chpatrick> look you can write anything in anything if you try hard enough
10:02:52 <bitemyapp> it demonstrates the design I was talking about.
10:02:56 <suppi> bitemyapp, and it looks great.
10:02:57 <chpatrick> that doesn't mean it's suitable
10:02:59 <bitemyapp> suppi: right!
10:03:04 <Sindriav_> chpatrick: Yes, c++ being the living example of that
10:03:12 <Sindriav_> suppi: Thanks for the recommendation! I'll try it out ^^
10:03:14 <Intolerable> haskell in a nutshell
10:03:17 <chpatrick> sure but there are a bajillion games in c++ and unity
10:03:21 <Intolerable> > look you can write anything in anything if you try hard enough
10:03:23 <lambdabot>  <hint>:1:29: parse error on input âinâ
10:03:23 * Intolerable ducks
10:03:24 <Ankhers> Serious - acting or speaking sincerely and in earnest, rather than in a joking or halfhearted manner
10:03:27 <chpatrick> for haskell the only example is this niche thing
10:03:30 <chpatrick> I'm not saying it's a bad game
10:03:32 <suppi> Sindriav_, no problem. you will soon feel like you want to come back to haskell though :P
10:03:39 <chpatrick> I just don't think it supports haskell as a practical gamedev language
10:03:51 <suppi> haskell is not a practical gamedev language
10:03:55 <chpatrick> well that's my point
10:03:57 <suppi> but not for the reasons you stated
10:04:03 <Sindriav_> suppi + 1
10:04:10 <Sindriav_> suppi: I don't think so. I'm not leaving Haskell, see :) I just want a duo of functional / oop languages, because I like both worlds
10:04:20 <suppi> the language features has nothing to do with the availability of game frameworks
10:04:31 <suppi> Sindriav_, good luck then :)
10:04:36 <chpatrick> there are a lot of games written in raw opengl though
10:04:41 <chpatrick> just not in haskell
10:04:41 <seanparsons> Big budget games aren't C++ because of the OO, they're C++ because of the C.
10:04:53 <Sindriav_> chpatrick: Moreover, Haskell has SDL2, which is more than enough for a game
10:05:02 <chpatrick> yeah
10:05:06 <Sindriav_> suppi: I'll probably look at Objective-C and Swift in the future, but Haxe is interesting, if nothing else :)
10:05:08 <chpatrick> so where are all the haskell games?
10:05:19 <chpatrick> or other non-oop games
10:05:21 <bitemyapp> seanparsons: and the middleware
10:05:32 <Sindriav_> chpatrick: Quake isn't OOP Â¯\_(ã)_/Â¯
10:05:41 <chpatrick> sure people made games in C
10:05:53 <chpatrick> that's a good counterargument
10:06:08 <Sindriav_> None of the nintendo games on the gameboy were OOP
10:06:14 <Sindriav_> or sega
10:06:15 <suppi> or SNES
10:06:27 <chpatrick> yes, that's true
10:06:42 <chpatrick> well is it actually?
10:06:58 <chpatrick> C++ compilers were crap at the time weren't they?
10:07:04 <suppi> OpenGL is stateful and OpenGL requires extensive FFI usage
10:07:09 <chpatrick> and you had to be careful with the hardware
10:07:17 <chpatrick> so everything was fine tuned
10:07:20 <Sindriav_> Unless you like writing OOP in assembly
10:07:23 <Sindriav_> it's true
10:07:26 <suppi> I'm waiting for the new GPipe2 tutorials
10:07:54 <suppi> and after I learn some OpenGL or WebGL I will use this to write games in PureScript or Haskell
10:08:35 <seanparsons> bitemyapp: Well prior to the current generation most consoles had <crazy hardware X> for which there was only 1 or 2 compiler tool chains that were C/C++ based usually.
10:08:45 <suppi> I have witnessed myself that writing a game in a functional language is really nice.
10:09:03 <Sindriav_> suppi: How's PureScript, btw?
10:09:12 <suppi> I don't know, I haven't used it much
10:09:18 <suppi> But it looks great.
10:09:20 <bitemyapp> seanparsons: that too
10:09:22 <chpatrick> bitemyapp: this is what I could find for ecs: http://www.thesoftwaredevelopmentlifecycle.com/?p=133
10:09:24 <dgryski> bitemyapp: btw, I'm going to try converting some of my repositories to haskell. Just need to find a good candidate for a beginner. 
10:09:24 <chpatrick> but it's dead
10:09:30 <chpatrick> do you know where to find it?
10:09:34 <bitemyapp> dgryski: learn Haskell first
10:09:38 <bitemyapp> seanparsons: PC AAA dev is heavily middleware-driven these days.
10:09:52 <bitemyapp> seanparsons: even smaller projects for indies need this to save time (see how popular unity is)
10:10:07 <chpatrick> wait it looks like the problem I said though
10:10:18 <chpatrick> if entity IDs are just ints you're back to where you started no?
10:10:21 <suppi> Haskell doesn't have a good story for simple game frameworks
10:10:41 <suppi> like Haxe or C++
10:10:44 <bitemyapp> chpatrick: I didn't say it was good. Just that it existed.
10:10:51 <chpatrick> okay but I think that's a problem
10:11:04 <bitemyapp> chpatrick: game state as ADT -> render commands is nicer, easier, more reliable, often better typed.
10:11:12 <suppi> bitemyapp, exactly
10:11:26 <chpatrick> so what if you want to have a new type of entity
10:11:30 <chpatrick> new constructor somewhere?
10:11:59 <bitemyapp> dgryski: tons of resources for learning Haskell, but you need to do that first before you attempt a port.
10:12:01 <chpatrick> or record-of-functions style
10:12:02 <bitemyapp> @where learnhaskell
10:12:02 <lambdabot> https://github.com/bitemyapp/learnhaskell
10:12:05 <bitemyapp> dgryski: ^^
10:12:16 <bitemyapp> dgryski: there's also the book I am working on at http://haskellbook.com
10:12:32 <Sindriav_> chpatrick: Entity is never anything else than an Int in ECS.
10:12:35 <dgryski> bitemyapp: yes, I was planning on using learnyouahaskell
10:12:46 <bitemyapp> dgryski: don't
10:13:05 <bitemyapp> dgryski: you won't learn Haskell from LYAH.
10:13:11 <chpatrick> Sindriav_: well it's a proper GC'd reference in managed languages no?
10:13:25 <chpatrick> that's quite useful already
10:13:29 <dgryski> bitemyapp: it was suggested to me when I asked in here earlier.
10:14:02 <Sindriav_> chpatrick: DUDE
10:14:20 <Sindriav_> chpatrick: What do you don't get about "it's an int". It's literally a number, used to lookup in the tables
10:14:25 <Sindriav_> No reference
10:14:27 <Sindriav_> no GC
10:14:29 <bitemyapp> dgryski: they did not do you a favor.
10:14:31 <chpatrick> yeah I get it
10:14:32 <Sindriav_> an `int`
10:14:35 <suppi> (if someone want to look at the game I made in Elm: https://github.com/soupi/ld32)
10:14:36 <chpatrick> I'm saying that's the problem
10:14:41 <chpatrick> no GC
10:14:53 <Sindriav_> chpatrick: That's not a fucking, that's a fucking language feature.
10:15:01 <chpatrick> if you have a bunch of objects which only refer to each other by Ints, how do oyu ever get them out of your big intmap?
10:15:02 <suppi> (** note: use chrome, run it twice for cache to kick in)
10:15:04 <chpatrick> calm down dude :/
10:15:11 <Sindriav_> chpatrick: you don't have objects
10:15:16 <bitemyapp> suppi: (I was curious, thank you)
10:15:21 <MarcelineVQ> the stack is only so big
10:15:23 <Sindriav_> chpatrick: You have an INT
10:15:25 <Sindriav_> and tables
10:15:27 <suppi> bitemyapp, sure!
10:15:36 <suppi> also: https://github.com/soupi/ld32/blob/ldjam-entry/src/Game/Game.elm
10:15:40 <chpatrick> what situation are you talking about here?
10:15:57 <MarcelineVQ> You can avoid objects but gc is still a thing that'll happen because you're gonna use the heap eventually with a game
10:15:58 <chpatrick> where you have a mapping from int to entities
10:15:59 <Sindriav_> chpatrick: And you manage that ECS manually, like you would anyways in C++, which is such a serious language
10:16:11 <chpatrick> and the entities refer to each other with these identifiers
10:16:13 <frerich> dgryski: I started with learnyouahaskell, too (and then 'Programming in Haskell') and it worked out.
10:16:13 <suppi> (** another note: this is 3 days work and from scratch**)
10:16:37 <frerich> dgryski: There's another popular book called Real World Haskell which is quite nice, though a bit dated -- but if you're new to Haskell, it still has a lot of interesting things.
10:16:42 <chpatrick> so how do you GC?
10:16:45 <chpatrick> in this situation
10:16:58 <chpatrick> let's say you have this in haskell
10:17:21 <chpatrick> you have an intmap from identifier to game entity
10:17:30 <chpatrick> how do you know when it's safe to remove something from the map?
10:17:31 <Profpatsch> bitemyapp: dgryski I learned the basics of Haskell from LYAH and it was great.
10:17:46 <Sindriav_> chpatrick: How do you know when it's safe to free a pointer?
10:18:03 <chpatrick> well it's difficult isn't it?
10:18:05 <dgryski> frerich: so, do you think learning by trying to convert an existing project is a reasonable idea?
10:18:18 <chpatrick> if I use unity then references are first class and stuff gets GC'd
10:18:21 <chpatrick> I don't get that in haskell
10:18:25 <suppi> I also learned the basics of Haskell from LYAH, I did thought me how to think functionally but I could write any Haskell after reading it
10:18:28 <chpatrick> which is why I'm saying the whole thing is awkward
10:18:31 <bitemyapp> Profpatsch: counter examples with an n=1, often with a valorized memory of how it went doesn't mean anything.
10:18:34 <bitemyapp> frerich: ^^
10:18:35 <suppi> It*
10:18:37 <chpatrick> by references I mean references to entities
10:18:54 <dgryski> I will follow the book, but I want to write something more than Hello World, fibonacci and quicksort 
10:19:08 <bitemyapp> frerich: Profpatsch those resources fail most learners try to learn Haskell. Typically they either give up or supplement with other resources.
10:19:09 <Profpatsch> bitemyapp: Well, statements from a person writing a competing book mean even less, probably.
10:19:16 <chpatrick> I'm not slagging off haskell, I'm firmly in the church
10:19:23 <bitemyapp> Profpatsch: I wouldn't have written the book if good enough resources existed.
10:19:24 <chpatrick> I just don't think it has a nice solution for this at this time
10:19:34 <chpatrick> and it's something that's very easy in your popular managed OOP languages
10:19:39 <bitemyapp> Profpatsch: I've invested a _lot_ of time in teaching people Haskell, I never wanted to write a book.
10:19:45 <MarcelineVQ> dgryski: if you want to start with something significant have a look at https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
10:19:51 <bitemyapp> Profpatsch: I just wanted a reliable means for people to learn Haskell so I could use it where I worked.
10:20:05 <MarcelineVQ> I'd start with https://www.seas.upenn.edu/~cis194/fall14/spring13/ though
10:20:13 <dgryski> MarcelineVQ: ah yes, I've seen that before
10:20:21 <frerich> dgryski: I also did the 'convert my other projects to Haskell' part and it was very nice - because I knew what I wanted to do. However, I understimated how different the solution would be.
10:20:46 <bitemyapp> Profpatsch: I've spent as much time teaching people for free and working on accumulating a guide of free resources as I have on the book. You're being an ass.
10:21:05 <bitemyapp> Profpatsch: I've got https://github.com/bitemyapp/open-cis194 lined up for when the book requires less of my time as well.
10:21:06 <Profpatsch> Learn you a Haskell is a great step for the first 3% of the way.
10:21:31 <Profpatsch> bitemyapp: Youâre right. But I want to say LYAH worked great for me.
10:21:33 <suppi> ^
10:21:38 <suppi> first 3%
10:21:41 <Profpatsch> Like an overlong blog entry.
10:21:46 <dgryski> frerich: I have lots of repos to choose from :)
10:21:50 <suppi> but it's too long for just 3% :(
10:21:50 <dgryski> https://github.com/dgryski
10:21:54 <sm> #haskell is feisty this morning!
10:21:55 <Profpatsch> suppi: Iâm not sure any book can get you over the first 3% with Haskell.
10:22:12 <suppi> Profpatsch, I agree.
10:22:23 <bitemyapp> Profpatsch: a 10 year old has done the first four chapters of our book with minimal help (unfamiliar arithmetic concepts only)
10:22:27 <suppi> http://hackage.haskell.org/package/turtle-1.2.1/docs/Turtle-Tutorial.html might be nice if you like writing shell scripts
10:22:27 <MarcelineVQ> I kind of checked out of LYAH when I got to applicatives, it was just too much stuff without work to solidify things in between
10:22:35 <Sonolin> That nikki and the robot game is amazing, thanks for that ex. btw
10:22:49 <Sonolin> I'm starting on a roguelike in hs so its a good reference
10:22:51 <bitemyapp> Sonolin: you're welcome :)
10:23:00 <suppi> Sonolin, do you know of Hickory?
10:23:03 <bitemyapp> Sonolin: you could even possibly reuse some of the engine to make the RL tiled if you wanted.
10:23:04 <Profpatsch> Itâs not that long, especially for someone completely unfamilliar with Functors &al.
10:23:10 <Ankhers> bitemyapp: Looking over the content available in the book, you have a section that shows the "basics of Cabal". Are there plans to extend that to stack as well?
10:23:19 <Sonolin> bitemyapp: nice idea :)
10:23:34 <bitemyapp> Ankhers: maybe. I might just update my tutorial at howistart.org/posts/haskell/1 and then it'd be free for everyone.
10:23:50 <Ankhers> Fair enough.
10:23:57 <bitemyapp> then people could learn Cabal, Stack, etc. in one go.
10:23:58 <suppi> Sonolin, ohh sorry, LambdaHack
10:24:18 <bitemyapp> Ankhers: Michael Snoyman started a new guide, a more comprehensive one, for Stack recently as well.
10:24:25 <frerich> dgryski: I think it can be safely said that you don't do a mistake with LYAH. Depending on who you ask it may not be the best choice, but it's not a bad choice - especially when you're starting out.
10:24:33 <bitemyapp> Ankhers: https://github.com/commercialhaskell/stack/blob/master/GUIDE.md
10:24:35 <Sonolin> suppi: I'll take a look but haven't looked in depth yet
10:24:37 <Ankhers> bitemyapp: I did see that. I haven't had the time to look at it yet.
10:24:49 <Ankhers> bitemyapp: Thanks for the link.
10:24:50 <Sonolin> suppi: is that the RL engine?
10:24:55 <bitemyapp> this is the thing that sucks about focusing on teaching
10:25:02 <bitemyapp> no matter how many hundreds, thousands of hours you put in
10:25:10 <Cale> chpatrick: Perhaps you're looking for weak references?
10:25:11 <bitemyapp> no matter how many comprehensive tutorials and books you write
10:25:13 <suppi> Sonolin, it's this: https://github.com/LambdaHack/LambdaHack . I don't know of the RL engine
10:25:29 <Ankhers> Stuff changes?
10:25:30 <bitemyapp> some dude with an opinion because he learned it himself and has taught nobody else for more than 5 sustained minutes in IRC isn't going to care anyway
10:25:31 <Cale> chpatrick: https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/System-Mem-Weak.html
10:25:49 <Sonolin> suppi: yea I saw that last night, that's the one I meant :)
10:25:55 <kadoban> frerich: It's a bad choice. It doesn't have exercises, so unless you're just looking for some kinda amusing reading, it's mostly a waste of time.
10:25:56 <Sonolin> suppi: looks awesome
10:25:59 <bitemyapp> it doesn't matter that you happened to read something before you got comfortable in Haskell. That doesn't mean it was a good use of your time.
10:26:03 <suppi> Sonolin, yes it does!
10:26:06 <bitemyapp> That doesn't mean it contributed to your success.
10:26:16 <Cale> chpatrick: Sorry if that's totally not what you're after, I only skimmed the discussion
10:26:22 <Profpatsch> bitemyapp: It did.
10:26:24 <bitemyapp> Most people don't even remember how they learned Haskell very well, partly because it's usually a _very_ diffuse process involving many resources.
10:26:31 <chpatrick> Cale: I think it's more of a design problem
10:26:36 <bitemyapp> Profpatsch: okay, but that's n=1
10:26:45 <bitemyapp> Profpatsch: I've helped a lot of people. It isn't effective.
10:26:47 <suppi> bitemyapp, thanks for How I Start btw!
10:26:50 <bitemyapp> suppi: y/w :)
10:27:18 <bitemyapp> Profpatsch: now if you taught a statistically significant number of people and LYAH ended up being the best way to start new people on learning Haskell, that would be interesting.
10:27:22 <chpatrick> the big-graph-of-mutable-extensible-entities problem specifically
10:27:49 <bitemyapp> Profpatsch: pretty fucking unlikely. I'm not alone here. kadoban is among many that have been paying attention to what works and what doesn't.
10:28:01 <Ankhers> bitemyapp: Dumb question but... If I were to buy your book now, would I eventually get a physical copy, or am I limited to the PDF?
10:28:03 <frerich> dgryski: There won't be a single best book anyway. I suspect just with any language, you'll end up reading three of them and then somewhere between #haskell, blog articles and experiment you'll figure your way around. So I wouldn't worry too much.
10:28:34 <bitemyapp> Ankhers: just PDF (and epub, if I ever figure out how to make one) - but you'll get the final version.
10:28:41 <Profpatsch> Right. Thatâs why I find bitemyappâs comments strange.
10:28:49 <bitemyapp> Ankhers: printing the book will be very expensive and somewhat difficult (>1000 pages)
10:29:04 <Ankhers> bitemyapp: So not plans for a physical?
10:29:17 <bitemyapp> Ankhers: it's complicated. We had a publisher, but we fired them for many reasons.
10:29:33 <Profpatsch> LYAH has probably done itâs fair share about the recent increase in interest in the language.
10:29:35 <bitemyapp> Ankhers: we'd like to find a printer/publisher for a print version alone (we keep the ebook running separately), but that's going to take some legwork.
10:29:37 <Profpatsch> *its
10:29:48 <bitemyapp> Profpatsch: that doesn't make it pedagogically effective.
10:30:17 <bitemyapp> I don't know why this is hard for you to understand. Just because the failure rate isn't 100% doesn't mean it can't be vastly improved upon.
10:30:34 <Profpatsch> Maybe it doesnt, but itâs the best there is atm.
10:30:40 <bitemyapp> It's really not.
10:30:44 <Ankhers> bitemyapp: Fair enough. Thanks!
10:30:56 <ReinH> LYAH is nowhere near the best
10:31:08 <ReinH> it's quite mediocre. I think it's popular because it's cute.
10:31:14 <bitemyapp> there are a lot of resources, even apart from ones I recommend in the guide, which would be better than LYAH.
10:31:14 <Profpatsch> At least the most accessible.
10:31:16 <kadoban> Profpatsch: All I know is from experience. I read it, paid attention very well, and then got to the end and still couldn't write anything. Which makes sense because it never actually asks you to â¦ do anything substantial. It's just light reading about haskell, to me.
10:31:18 <ReinH> btw I'm not selling a book so apparently you can believe me
10:31:50 <bitemyapp> ReinH: yeah don't spend too much time writing and testing material for people to learn Haskell with, then we'd never want to listen to you about how to learn Haskell.
10:31:54 <suppi> I had the exactly same experience as kadoban 
10:31:59 <bitemyapp> ReinH: so you'd better stop teaching people in here, so you can keep that street cred.
10:32:02 <kadoban> It's popular because it's easy to read â¦ which is like one positive I guess, but it's not a very important one.
10:32:14 <chreekat> increasing popularity != teaching people the language. It definitely did the former, I think, but I can't speak to the latter, because I read LYAH for the entertainment value after already knowing Haskell
10:32:34 <bitemyapp> getting attention with a bad resource leads to a lot of people who burn out when they try to do something real
10:32:40 <chreekat> *cough* HP
10:32:48 <bitemyapp> then they write off the language as impractical because their induction was with a resource that doesn't work well.
10:32:57 <bitemyapp> chreekat: :)
10:33:03 <suppi> HP?
10:33:43 <chreekat> Haskell Platform
10:34:14 <suppi> After two years with Haskell, I don't feel I'm anywhere near as good as I could be if I knew how to invest my time in it right
10:34:30 <suppi> chreekat, I actually found HP ok for my uses
10:34:40 <Rembane> Is there a fastpath for learning Haskell?
10:34:40 <monochrom> I use HP
10:34:55 <ReinH> Rembane: no, but there is a slow one :)
10:35:02 <suppi> I no longer use it since moving to 7.10.2 which I just install using the binary from GHC site
10:35:13 <Rembane> ReinH: So a standard one, and a multitude of slower ones? :)
10:35:22 <suppi> but I used it until fairly recently
10:35:52 <suppi> I'm definitely taking the slower one, I feel :)
10:35:57 <chreekat> yay, glad HP works for some people
10:36:31 <Profpatsch> suppi: You write stuff in it and when you hit a problem, you learn how to solve it. :)
10:36:55 <suppi> Profpatsch, yeah...
10:37:12 <suppi> Keep writing and reading I guess.
10:37:33 <sm> Rembane: I think reading and working on the code of many projects is it
10:37:56 <chreekat> I started learning Haskell by just sitting down and reading the Report, which to this day strikes me as a reasonable thing to do. Probably not to everyone's taste, but it gave me an understanding that, while not as entirely pratical as real experience, gave me a really big base for building that experience on. As one small example, do-notation was never mysterious
10:38:13 <Profpatsch> I donât think there is a fix (or even dynamic) point where you can say âIâve learned Haskellâ.
10:38:33 <bitemyapp> chreekat: the Report is really very good, but it can be hard to understand if you don't have a point of reference to work with.
10:38:48 <bitemyapp> chreekat: if somebody had a background in PL or knew SML/OCaml I'd recommend it.
10:38:56 <ReinH> The biggest problem with LYAH by far is that the reader is completely passive. It claims that reading a bunch of stuff prepares you to write Haskell, but *writing* a bunch of stuff is what prepares you.
10:38:56 <Profpatsch> chreekat: Thatâs how I did it with Scheme; I simply read R5RS.
10:39:04 <Cale> Profpatsch: Well, at a point you sort of stop learning things about Haskell, and everything new you're learning really is just about functional programming.
10:39:05 <bitemyapp> chreekat: also the grammars are incomprehensible.
10:39:14 <bitemyapp> @karma+ ReinH
10:39:14 <lambdabot> ReinH's karma raised to 25.
10:39:28 <Rembane> sm: Cool! I've finally leveled up so much that I can start doing that.
10:39:47 <bitemyapp> chreekat: we leaned on the Report a lot for the first 1/3 of the book.
10:39:51 <sm> Rembane: let me add: ...with as much real-time mentorship as you can get (in person or online, eg from project maintainers)
10:40:01 <bitemyapp> it was the best way to get concise answers to queries.
10:40:25 <Cale> Though I guess you could learn about the implementation and theory behind various extensions and stuff, you don't really get that just by using the language.
10:40:46 <Rembane> sm: Ah, yes, indeed.
10:40:48 <chreekat> bitemyapp: fair enough.. While I had no PL/ML background (my CS dept had apparently never heard of modern PL research), my background was sciency enough to be comfortable skipping over the parts I didn't understand
10:41:06 <bitemyapp> chreekat: most CS departments are like that. It's embarrassing.
10:41:26 <Cale> https://www.haskell.org/tutorial/ is the one true haskell tutorial ;)
10:41:33 <Cale> hehe
10:41:43 <chreekat> I keep hearing good things about the Haskell Wikibook, fwiw
10:42:03 <sm> indeed, any time I accidentally land on the wikibook, it is excellent
10:42:08 <bitemyapp> chreekat: only a handful are the exception (OSU, PSU, CMU, etc.)
10:42:12 <Cale> (It actually isn't bad, but if we're considering just reading the Report as an option, it's a bit gentler than that)
10:42:25 <bitemyapp> chreekat: the wikibook is spotty but the parts that are good, are good.
10:42:27 <suppi> I actually have a hard time reading code on hackage (view source)
10:43:05 <bitemyapp> chreekat: may I query you?
10:43:10 <chreekat> sure
10:43:20 <suppi> Maybe it's the packages I try to look at, like vector
10:43:22 <Cale> suppi: Sometimes that doesn't get generated properly for some reason. I think it might be when the docs can't be compiled by Hackage itself, and the author uploads docs manually which are missing the highlighted source.
10:44:37 <suppi> Cale, I don't think that's the reason in my case though
10:44:42 <Cale> It's slightly unfortunate that the ability to generate Haddock is so closely tied to the ability to build the package, right up to being able to solve dependencies and such.
10:44:53 <sm> agreed
10:45:07 <glguy> It's easy to upload docs manually even with the new source highlighter
10:45:12 <glguy> I'll poke on getting vector updated
10:45:21 <Cale> The source links on the vector package seem to work for me
10:45:50 <suppi> Cale, yeah, I did not mean that in the technical sense
10:45:51 <ReinH> I like how sometimes they point to file:// locations
10:46:02 <Cale> suppi: Oh, okay, so just understanding the code itself :)
10:46:11 <suppi> Cale, yes
10:46:12 <sm> the phrase "upload docs manually" sounds a bit sad to me
10:46:22 <Cale> suppi: Because a lot of packages really do have "view source" links which are broken.
10:46:25 <glguy> sm: It's a command you run
10:46:35 <suppi> Cale, oh, I see
10:50:53 <Cale> suppi: As for understanding how vector does its stuff, there are some relevant papers on stream fusion you might find interesting
10:50:56 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/haskell-beats-C.pdf
10:51:08 <Cale> http://citeseer.ist.psu.edu/viewdoc/download?doi=10.1.1.104.7401&rep=rep1&type=pdf
10:51:33 <Cale> suppi: It's pretty fancy
10:51:43 <suppi> Cale, thanks for the links :)
10:52:38 <Cale> Also, most of the readable implementations of basic functions are in this module: http://hackage.haskell.org/package/vector-0.11.0.0/docs/src/Data-Vector-Generic.html
10:52:48 <suppi> I will save it in my Haskell resources safe for later use
10:53:08 <suppi> Cale, oh, thanks!
10:55:44 <suppi> bought Parallel and Concurrent Programming in Haskell yesterday :D
10:55:53 <Cale> cool
10:55:58 <bitemyapp> suppi: that's a good book
10:56:38 <suppi> I used Haskell for my final project at college, which used parallelism. this book and the parallel library was a godsend
10:59:21 <lingxiao> hey all
10:59:56 <lingxiao> why does `maximumBy (compare `on` length) ["a", "b"] return "b"
11:00:05 <lingxiao> even though a precdes b ?
11:00:34 <pyon> What's the type `N` in lambdabot?
11:01:43 <glguy> lingxiao: Because the documentation doesn't make any promises about which element you get back when they are equal w.r.t. the equality you defined
11:02:23 <lingxiao> wait what does it mean when you say:  documentation doesn't make any promises ..
11:02:37 <glguy> maximumBy : "The largest element of a non-empty structure with respect to the given comparison function."
11:03:39 <levi> lingxiao: You have two values that are equal according to the comparison function you gave. Why would you expect to get one vs. the other if you haven't given it a means of ordering them?
11:03:48 <lingxiao> so it always returns the last element in the list 
11:03:53 <lingxiao> assuming the list 
11:04:01 <lingxiao> is made of equal lengthed elements
11:04:25 <lingxiao> right .. because there's no Ord a constraint on the list of a`s
11:04:30 <levi> That is not something you should make any assumptions about.
11:04:40 <levi> At least if you want to write a robust program.
11:04:46 <pyon> lingxiao: All that it guarantees is that the element you get isn't shorter than any other element in the list.
11:05:06 <pyon> lingxiao: If there's a tie for the longest element, you could get any of them.
11:05:24 <lingxiao> I see ..
11:07:04 <levi> It might seem to behave consistently in one way today, but change next time the library is updated, or when it builds with some different versions of dependencies, etc. Unless the types or the documentation make a claim about some property, you shouldn't expect it to stay the same.
11:08:11 <levi> Now, if you *need* a certain property to hold, you just need to add that property to your function that provides the ordering.
11:09:29 <dgryski> Is the ghc that ships with ubuntu 15.04 recent enough or should I build from source?
11:09:31 <levi> That's part of the beauty of functional programming. A function can implement a general algorithm with certain guarantees. You can then change some aspect of that algorithm by taking some part of it as a function parameter.
11:09:59 <MarcelineVQ> When I still play around with C++ I vaguely remember this exact thing being an issue, where when you pass in values to to a function you don't know the order of evaluation
11:10:10 <kadoban> dgryski: You should install the haskell 'stack' and let it install GHC for you. https://github.com/commercialhaskell/stack
11:10:11 <Cale> chpatrick: Having thought a bit about what I'd want to say regarding that sort of problem, I think what I'd recommend to start off in cases like that, where you don't have an understanding of your problem which is any better than what allows you to implement it as a mess of nodes connected by pointers...
11:10:18 <MarcelineVQ> haskell gets around that by being pure I guess?
11:10:42 <Cale> chpatrick: Is just to do the same think as you'd do in your favourite imperative language at first, and implement the data structures using IORef or MVar
11:10:51 <levi> Haskell guarantees different things about evaluation than C++ does.
11:10:53 <nitrix>  MarcelineVQ Purity doesn't imply any order of evaluation.
11:11:10 <MarcelineVQ> no nitrix but it does cut the side effects
11:11:22 <nitrix> MarcelineVQ: That's not related.
11:11:35 <dgryski> kadoban: ok ... (/me runs sudo apt-get --purge remove ghc )
11:11:39 <suppi> A common function signature in an imperative language: void f()
11:11:41 <Cale> chpatrick: You then hope to build up a library of operations for manipulating your graph such that 1) the operations are sufficient to do all the manipulations you need to do, and 2) there's hopefully no explicit mention of IORef anywhere.
11:11:42 <suppi>  = no guarantees.
11:12:03 <MarcelineVQ> Why wouldn't it be? Isn't the order of evalutation problem in imperative functions due to the fact that they can have side effects?
11:12:27 <suppi> MarcelineVQ, it is a problem.
11:12:39 <Cale> chpatrick: Once you have that, you have some options. You can build a type class and abstract over the implementation -- perhaps allowing for a separate pure-but-inefficient implementation to be used for testing.
11:13:09 <Cale> chpatrick: Perhaps once you see your interface, it'll also be clearer how to implement the operations you really need efficiently using pure data structures.
11:14:02 <Cale> But even if not, you can hopefully pass to using a language in which explicit low-level IO operations aren't mentioned, and instead you write things in terms of your higher level operations.
11:14:12 <nitrix> MarcelineVQ: It's a problem but you're not tying the right concepts togheter. Order of evaluation has nothing to do with side-effects, it's language semantics. Haskell manages evaluation order through sequencing IO actions (>>=), otherwise, the language semantics uses a lazy evaluation mechanism.
11:14:37 <levi> MarcelineVQ: I would say that it is easier to handle imperative side-effecting programs when you use a strict/eager evaluation strategy. Haskell's choice of non-strict/lazy evaluation strategy made side-effecting programs something that would be far more troublesome to reason about, which made it easier to stick to purity as a general policy.
11:15:33 <Cale> levi: Yeah, specifically, it's easier to manage having side effects as part of *evaluation* if it's strict evaluation.
11:16:36 <Cale> nitrix: The sequence on IO actions really has very little to do with the order in which anything is evaluated.
11:17:07 <Cale> nitrix: Instead, the order in which IO actions are to be executed is explicitly represented as those IO action values are built up in terms of (>>=)
11:17:18 <nitrix> Cale: The "little" being the most important part; offering a guarantee.
11:17:25 <nitrix> I think you're confused.
11:17:26 <Cale> hm?
11:17:31 <Cale> Evaluating IO actions does very little
11:17:42 <Cale> (apart from making your processor slightly warmer)
11:18:10 <levi> The guarantee is provided by the structure of the IO action composition, not necessarily by when various parts of that composition are evaluated.
11:18:14 <Cale> Executing IO actions, which is a separate process from evaluation, causes the effects they describe to occur.
11:18:29 <nitrix> levi: Namely (>>=). Cale seems confused.
11:18:38 <ReinH> I'm pretty sure Cale is not confused.
11:18:41 <nitrix> He's not wrong, he's just extrapolating for no reason.
11:18:41 <Cale> I'm not confused at all.
11:18:48 <Profpatsch> Whatâs all that fuzz about Stack about?
11:18:56 <levi> nitrix: No, not confused, he's just trying to point out a distinction that you're not making.
11:18:56 <Cale> I'm just being picky about the distinction between evaluation and execution.
11:18:59 <ReinH> Extrapolating? He's explaining how it works.
11:19:01 <Profpatsch> nix works quite well.
11:19:05 <nitrix> levi: Cale: My statement didn't go that far.
11:19:09 <Ankhers> Profpatsch: Essentially an easier cabal.
11:19:21 <Cale> "Haskell manages evaluation order through sequencing IO actions (>>=)"
11:19:41 <kadoban> Profpatsch: Never tried nix, it seemed too complicated. stack provides everything I ever used cabal sandboxes and weird invocations â¦ without all of the tedious parts.
11:19:44 <Cale> ^^ I think this statement is anywhere from misleading to incorrect.
11:19:57 <kadoban> :(
11:20:15 <nitrix> Cale: It offers a guarantee that these IOs will be sequenced.
11:20:20 <ReinH> Haskell manages evaluation order via its lazy graph reduction semantics, which has nothing to do with IO or >>=
11:20:24 <nitrix> Cale: Regardeless of when it's actually evaluated.
11:20:26 <levi> It would be more precise to say that "Haskell manages effect ordering through sequencing provided by IO's (>>=)"
11:20:31 <Cale> While it's true that if the right hand argument to (>>=) is a lambda, the body of that lambda can't be evaluated until the first IO action has been executed, making its result available
11:20:37 <ReinH> You keep saying "evaluated" when you don't mean evaluated
11:20:37 <Profpatsch> kadoban: Maybe we need to write a Learn You A Nix For Great Good then. :P
11:20:45 <Cale> There's no other connection between the order of evaluation and the order of execution.
11:21:05 <kadoban> Profpatsch: Quite possibly, if it turns out to actually be easier to use than I suspect it is. But I really didn't try very hard, so maybe it is nice.
11:21:19 <Profpatsch> I read something about isolated dependencies.
11:21:20 <kadoban> I'm quite happy with using 'stack' though, currently.
11:21:22 <monochrom> I believe that the present disagreement is due to: in other languages, evaluation and execution are the same thing; in Haskell, they are separated.
11:21:30 <Cale> Right.
11:21:34 <nitrix> Execution is evaluation.
11:21:40 <ReinH> No, it isn't.
11:21:42 <Cale> nope
11:21:46 <monochrom> not for Haskell
11:21:47 <Cale> Not here it's not :)
11:22:00 <Profpatsch> kadoban: So I assume no two projects with stack share the same depency files?
11:22:00 <monochrom> yes for SML, I don't object to that
11:22:18 <Profpatsch> kadoban: Does it need to compile the dependencies?
11:22:34 <MarcelineVQ> I âjust meant that pure functions won't depend on side-effects that make their order matter, so they can skip the evaluation-order problem that c++ functions have e.g. foo(bar(), baz()), not that purity tells anything what order to happen in.
11:22:44 <kadoban> Profpatsch: Not sure I understand the (first) question? It automatically builds dependencies, sure.
11:23:12 <Profpatsch> kadoban: No binary caches then?
11:23:43 <Cale> Yeah, in many other languages, there's no separation between those two things, because those languages don't represent actions as values like Haskell does, so you generally don't evaluate which action you're going to perform, and then perform it separately like what happens in Haskell.
11:23:58 <glguy> Profpatsch: Two things built with stack will share the same dependencies built from one of the stackage resolvers, at least
11:24:10 <glguy> but I don't think they share the packages built that weren't in that snapshot
11:24:11 <sm> Profpatsch: it has to compile every haskell package, but shares those between projects using the same snapshot (and soon, across snapshots)
11:24:15 <levi> MarcelineVQ: Evaluation order can matter even in pure languages; non-strict evaluation will reduce to normal form in cases where strict evaluation might not. But I think you've generally got the right idea.
11:27:32 <clrnd> stack is fantastic, I have to say it
11:27:53 <glguy> so brave
11:28:02 * sm eggs clrnd on
11:28:12 <slack1256> what is the difference between execution and evaluation on haskell?
11:28:45 <Cale> slack1256: Evaluation refers to the process of reducing expressions to values, largely for the purposes of pattern matching
11:29:01 <Cale> slack1256: Execution refers to carrying out the effects described by IO action values.
11:29:18 <Cale> (which can perform pretty much any operation that your computer is capable of)
11:30:19 <slack1256> got it.
11:30:22 <levi> I would go so far as to say that evaluation, as a process, is also executed. And its execution is typically interleaved with execution of effects. It's the runtime that provides this execution mechanism.
11:30:22 <Cale> Evaluation in Haskell is (with a few low level exceptions that are mostly not relevant to daily programming) entirely deterministic, and only depends on which expression is being evaluated.
11:30:30 <dmead> > let 5 = 0 in 5+5
11:30:33 <lambdabot>  10
11:30:33 <dmead> oh hey cale
11:30:42 <Cale> When we say that "Haskell is pure" what we really mean is "expression evaluation in Haskell is pure"
11:31:00 <dmead> > let 5 = 2in 5+5
11:31:02 <lambdabot>  10
11:31:10 <dmead> > let 5 = [] in 5+5
11:31:12 <lambdabot>      Could not deduce (Eq t0) arising from the literal â5â
11:31:12 <lambdabot>      from the context (Num a)
11:31:12 <lambdabot>        bound by the inferred type of it :: Num a => a at <interactive>:1:1
11:31:21 <dmead> how do i get this to do bad math?
11:31:22 <dmead> i forget
11:31:23 <Cale> dmead: Did you want to know what's going on there?
11:31:30 <bitemyapp> Cale: I do, either way :)
11:31:32 <Cale> Oh, well, you could locally define addition
11:31:40 <dmead> oh yea
11:31:49 <kadoban> > let 2 + 2 = 5 in 2 + 2
11:31:50 <lambdabot>  5
11:31:56 <Cale> 5 = 2  is a pattern binding against a numerical pattern that binds no variables
11:31:59 <dmead> ah thats right
11:32:01 <bitemyapp> kadoban: there you go
11:32:05 <dmead> thanks dudes
11:32:09 <dmead> do you remember me cale?
11:32:16 <Cale> I think so :)
11:32:17 <dmead> we bumped into eachother in starcraft once :D
11:32:20 <Cale> ah, right!
11:32:27 <bitemyapp> dmead: BW or 2?
11:32:29 <Cale> 2
11:32:30 <dmead> 2
11:32:31 <nshepperd> > let !5 = 2 in 5+5
11:32:33 <lambdabot>  *Exception: <interactive>:3:5-10: Non-exhaustive patterns in pattern binding
11:32:37 <dmead> legacy of the void is soon
11:32:43 <nshepperd> interesting
11:33:06 <Cale> Since the pattern binds no variables, and pattern bindings in let are lazy, the pattern will never be checked.
11:33:18 <Cale> > let (x:xs) = [] in 6
11:33:20 <lambdabot>  6
11:33:22 <levi> "legacy of the void" makes me think of null pointer exceptions.
11:33:28 <nitrix> Cale: I take my words back. Thanks for the explanation.
11:33:47 <Cale> ^^ this pattern is also lazy, you won't get a pattern match failure until you try to use x or xs
11:33:50 <Cale> > let (x:xs) = [] in x
11:33:52 <lambdabot>  *Exception: <interactive>:3:5-15: Irrefutable pattern failed for pattern (x ...
11:33:53 <Ankhers> When did StarCraft come into this?
11:34:03 <qmm> i have to write a web API, and i want to use Haskell. spot looks nice, but i need token based authentication, also if the user hits /api/* i need to serve json but if they don't, i need to serve html
11:34:06 <Cale> Ankhers: dmead and I met up there :)
11:34:11 <qmm> does this community have a recommendation on a web framework?
11:34:20 <levi> nitrix: It's a tricky thing to get straight, because it's generally unfamiliar to people coming from other languages.
11:34:23 <bitemyapp> qmm: Yesod, probably.
11:34:44 <bitemyapp> qmm: I've done a fair bit of web in Haskell it's the one I've enjoyed most, but it assumes you are comfortable in Haskell.
11:35:10 <Ankhers> Cale: Cool.
11:35:19 <levi> qmm: Yesod is a nice full-featured framework. Snap is also nice, but has a different feel. There are a number of other alternatives for more lightweight and less integrated solutions, too.
11:35:23 <ReinH> (content types should be negotiated based on headers, not paths)
11:35:37 <Cale> Yesod does some cool things, but I don't know how I feel about it. I have a hard time recommending it to anyone who might be a beginner in Haskell, because it contains many little additional languages you need to learn which are not Haskell, and whose interactions with the Haskell code are not entirely obvious.
11:36:03 <Ankhers> qmm: Yesod is arguably the rails or django of the Haskell world. Scotty is sort of the sinatra or flask of Haskell.
11:36:04 <dmead> > let 1 + _ = 2 in 1 + 3
11:36:05 <Cale> Those additional languages are certainly useful once you know them though.
11:36:05 <lambdabot>  2
11:36:07 <ReinH> I'd recommend scotty as a good starter framework
11:36:08 <dmead> naace
11:36:15 <nitrix> I find Scotty to be easier for beginners.
11:36:26 <qmm> bitemyapp, levi, Ankhers: i like the idea of keeping it lightweight and mix/matching libs as i need them
11:36:30 <Cale> Happstack and Snap are also worth looking at, I think.
11:37:08 <Cale> Happstack is probably the easiest one to mix and match with(?)
11:37:09 <levi> Happstack has some decent tutorial documentation that describes a bunch of different ways of doing things.
11:37:11 <Welkin> I started with Yesod as a beginner, and I feel it helped me learn much faster
11:37:19 <qmm> Ankhers: i got that impression, and i'm digging spot, but i'd rather not have to build the libraries that i need to get started :)
11:37:20 <Cale> I'm not totally sure about that statement, but I think I'm right :)
11:37:36 <ReinH> spot?
11:37:43 <Ankhers> spock maybe?
11:37:44 <Welkin> the Yesod book is a good resource to start with, and the #yesod channel for more help
11:37:45 <clrnd> qmm, you are gonna have to build the libraries anyway
11:37:47 <clrnd> spock he means
11:37:49 <levi> Snap is probably just as easy to mix/match with if you already know what you're doing, but there's not as much support for the non-default way.
11:37:52 <bitemyapp> qmm: I understand that desire, but having some direction on how to pull everything together when you're new can be helpful and Yesod is far less opinionated than a comparison to Rails or Django makes it sound.
11:37:54 <qmm> Cale: heh i'll have to look into snap then
11:37:59 <Cale> levi: Yeah
11:38:02 * hackagebot hunch 0.2.0 - CSS-like syntax for file system manipulation.  https://hackage.haskell.org/package/hunch-0.2.0 (loganbraga)
11:38:07 <nitrix> @let test is js = do { i <- is; j <- js; [i,j] }
11:38:09 <lambdabot>  Defined.
11:38:15 <slack1256> did spock take over hakyll as the lightweight solution?
11:38:16 <qmm> ReinH: sorry, i meant spock: http://www.spock.li/
11:38:18 <nitrix> > test [1,2,3] [5,6]
11:38:20 <lambdabot>  [1,5,1,6,2,5,2,6,3,5,3,6]
11:38:28 <levi> Really, most Haskell things can be mixed and matched a lot more than you might think at first glance.
11:38:30 <clrnd> hakyll is a different thing altogether
11:38:36 <nitrix> Could someone explain me how that list monad works?
11:38:37 <Cale> qmm: Snap and Happstack are two separate frameworks, in case I was unclear there :)
11:38:38 <bitemyapp> qmm: yeah, what levi said.
11:38:43 <kadoban> slack1256: I don't think spock and hakyll target the same use-cases. Hakyll is a static-site compiler
11:38:52 <sshine> does haskell perform CSE on stuff like '(map f xs, map f xs)'?
11:38:58 <Ankhers> nitrix: Do you have a specific question?
11:39:06 <sshine> I mean, if there's no unsafe IO in the sub-expression.
11:39:17 <slack1256> kadoban: got it, spook is also dynamic on content generation
11:39:19 <Cale> nitrix: first, does it help if I do this:
11:39:21 <Welkin> nitrix: bind on lists is the cartesian product
11:39:22 <slack1256> *spock
11:39:40 <Cale> > let test is js = do { i <- is; j <- js; k <- [i,j]; return k } in test [1,2,3] [5,6]
11:39:42 <lambdabot>  [1,5,1,6,2,5,2,6,3,5,3,6]
11:39:47 <levi> sshine: Haskell-the-language doesn't guarantee that sort of optimization. But it doesn't rule it out either. I'm not sure if GHC-the-compiler does it or not.
11:39:49 <monochrom> nitrix: in list comprehension, it goes [ [i,j] | i <- is, j <- js ]
11:39:57 <monochrom> err, no, I'm wrong
11:39:58 <slack1256> nitrix: think it is a map followed by a concat
11:40:08 <nitrix> Ankhers: What are the types of i and j? And how comes [i,j] returns the combination of both?
11:40:23 <Cale> nitrix: i and j will be numbers
11:40:29 <monochrom> [ a | i <- is, j <- js, a <- [i,j] ]
11:40:30 <Cale> (Integer values by default)
11:40:42 <slack1256> > [2,3,9] >>= (\a -> [a^2, a^3])
11:40:44 <lambdabot>  [4,8,9,27,81,729]
11:40:56 <levi> sshine: If you do 'let ys = map f xs in (ys, ys)' then it'll only evaluate it once. :)
11:41:02 <Cale> So, we pick i from is, and pick j from js, and then pick an element from [i,j] in all possible ways
11:41:11 <sshine> levi, maybe that's what I should be asking.
11:41:23 <nitrix> Cale: I get that in a list comprehension, I don't in the do form. I just don't understand how come it's evaluated more than once for each elements.
11:41:33 <Cale> nitrix: well, look at this:
11:41:42 <Cale> > let test is js = do { i <- is; j <- js; return (i,j) } in test [1,2,3] [5,6]
11:41:43 <monochrom> always translate do-notation to list comprehension :)
11:41:44 <lambdabot>  [(1,5),(1,6),(2,5),(2,6),(3,5),(3,6)]
11:41:50 <Cale> > let test is js = do { i <- is; j <- js; [i,j] } in test [1,2,3] [5,6]
11:41:52 <lambdabot>  [1,5,1,6,2,5,2,6,3,5,3,6]
11:41:58 <Cale> compare the results :)
11:42:07 <dmead> > let 1 + _  + _ = 2 in 1 + 3 + 1
11:42:09 <lambdabot>  <hint>:1:5: Parse error in pattern: 1 + _
11:42:48 <dmead> > let (1 + _)  + _ = 2 in 1 + 3 + 1
11:42:50 <lambdabot>  <hint>:1:6: Parse error in pattern: 1 + _
11:42:57 <dmead> > let 1 + _ = 2 in 1 + 3
11:42:57 <Cale> dmead: You can't define functions via arbitrary expressions involving them
11:42:59 <lambdabot>  2
11:43:24 <dmead> it's only what a valid instance of numeric for + correct?
11:43:29 <dmead> *whats
11:43:53 <Cale> dmead: In particular, the arguments to a function in a function binding have to be patterns. The syntax of patterns involves a bunch of different things, but it differs somewhat from the syntax of expressions.
11:44:00 <levi> sshine: You can think of how haskell evaluates things like this: 'let ys = map f xs in (ys, ys)' => '(<ys: map f xs>, <ys: map f xs>)' And then if either side is required by a pattern-match, the 'map f xs' expression is evaluated once and used for both sides.
11:44:09 <nitrix> Cale: Still doesn't click. One list, no problem. Two, can't understand. I know why the end list is in this specific order, it's a cartesian product, but the code itself makes no sense to me.
11:44:12 <dmead> ah
11:44:26 <Cale> Individual numbers can serve as patterns which only match in the case that the argument supplied is equal to the given number.
11:44:51 <Cale> Variables can serve as patterns, and data constructors (applied to patterns for their fields) also can
11:45:06 <nitrix> Cale: i <- is is giving you one number, so does j, then you return a pair. First, why is there multiple pairs if it only picks one number, and why are they in a list?
11:45:06 <Cale> nitrix: Okay, so let's desugar
11:45:08 <monochrom> nitrix: [i,j] = do { a <- [i,j]; return a }. there is a (>>=) version. there is a monad law for that.
11:45:27 <Cale> nitrix: It picks those two numbers in all possible ways, like a couple of nested loops
11:45:56 <dmead> let 1+ _ = 10; 2+_=0 in 1+2 + 3
11:46:00 <dmead> > let 1+ _ = 10; 2+_=0 in 1+2 + 3
11:46:02 <lambdabot>  *Exception: <interactive>:3:5-20: Non-exhaustive patterns in function +
11:46:03 <levi> sshine: If you *don't* introduce that name 'ys' for the common expression to be bound to, then an optimization pass would have to introduce one in order to eliminate the apparently redundant evaluation.
11:46:15 <dmead> > let 1+ _ = 10; 2+_=0 in (1+2 )+ 3
11:46:17 <lambdabot>  *Exception: <interactive>:3:5-20: Non-exhaustive patterns in function +
11:46:26 <Cale> You need a definition for 3 + _
11:46:31 <nitrix> Cale: That's not because of do, is it? That's because of the list monad?
11:46:32 <Cale> erm
11:46:35 <Cale> 10 + _ rather
11:46:37 <Cale> haha
11:46:59 <Cale> nitrix: yeah
11:47:14 <dario> nitrix: yep, return x = [x] and xs >>= f = [f x | x <- xs]
11:47:20 <dmead> > let 1+ _ = 10; 2+ _  =0 ; 10 + _ = 0 in (1+2 )+ 3
11:47:21 <RageYL> i'm trying to create an uncurry function with list: is it possible ? (something like: uncurry f xs = foldl (\a b -> a b) f xs)
11:47:21 <lambdabot>  0
11:47:23 <Cale> nitrix: so, do-notation, in case you haven't seen the desugaring for it, works like this:
11:47:47 <Cale> do { v <- x; <stmts> } = x >>= (\v -> do { <stmts> })
11:48:03 * hackagebot serversession-backend-acid-state 1.0.2 - Storage backend for serversession using acid-state.  https://hackage.haskell.org/package/serversession-backend-acid-state-1.0.2 (FelipeLessa)
11:48:12 <Cale> do { x; <stmts> } = x >> do { <stmts> }
11:48:13 <levi> (BTW: For understanding how things desugar, the Haskell Report is a great reference. It's pretty much all about desugaring.)
11:48:16 <Cale> and
11:48:20 <Cale> do { x } = x
11:48:21 <nitrix> Right.
11:48:24 <Cale> as a base case
11:48:29 <nitrix> There's a lambdabot command too I think.
11:48:31 <Cale> yeah
11:48:46 <Cale> @undo do { i <- is; j <- js; return (i,j) }
11:48:46 <lambdabot> is >>= \ i -> js >>= \ j -> return (i, j)
11:49:11 <Cale> That's  is >>= (\i -> js >>= (\j -> return (i, j))) in case the lack of parens is confusing
11:49:32 <Cale> Now, for lists, we have   xs >>= f = concat (map f xs)
11:49:45 <kadoban> @parenthesizeAllTheThings
11:49:45 <lambdabot> Unknown command, try @list
11:50:01 <monochrom> I love parentheses.
11:50:01 <bitemyapp> kadoban: in case you need 'em((((()))))
11:50:09 <bitemyapp> kadoban: I use $ so I need them less.
11:50:15 <kadoban> Hehe
11:50:16 <Cale> So that becomes  concat (map (\i -> js >>= (\j -> return (i, j))) is)
11:50:37 <monochrom> (but I don't like prefix. so no, I don't like lisp syntax or scheme syntax)
11:50:38 <Cale> So for each i in is, we're going to apply this function (\i -> js >>= (\j -> return (i, j))), and then concatenate all the resulting lists together
11:50:48 <nitrix> :t concat
11:50:50 <lambdabot> Foldable t => t [a] -> [a]
11:51:06 <monochrom> (but strangely, I like syntax trees)
11:51:07 <Cale> Feel free to read that as [[a]] -> [a]
11:51:24 <nitrix> Right. t can be a tuple?
11:51:38 <monochrom> no no, you want t = [] here.
11:51:39 <Cale> t can be lots of stuff, but I'm not sure tuples have a Foldable instance
11:51:55 <nitrix> How are those tuples concatenated then?
11:52:07 <Cale> The pairs weren't concatenated
11:52:13 <Cale> in the example which had pairs
11:52:17 <nitrix> Oh that's the first example.
11:52:24 <nitrix> Gotcha
11:52:37 <monochrom> the concat is for concat [ [(a,b)], [(c,d)], [(e,f)] ]
11:52:46 <clrnd> > snd . snd . snd . snd $ ("i", ("<3", ("lizp")))
11:52:48 <lambdabot>      Couldn't match expected type â(a1, (a0, c))â
11:52:48 <lambdabot>                  with actual type â[Char]â
11:52:48 <lambdabot>      In the expression: ("lizp")
11:52:59 <monochrom> because [(a,b)] comes from return(a,b)
11:53:33 <mniip> guys
11:53:41 <mniip> why are injective type families a thing
11:53:56 <monochrom> because it has both demand and supply
11:53:59 <mniip> there totally is a way to achieve this with regular type families
11:54:00 <monochrom> (great tautology)
11:54:19 <Jello_Raptor> hmm, if I was making a lens for a datatype with multiple constructors, where sometime the field I want doesn't exist (like "data Foo a = Nothing | Something  { _elem :: a }") would I want a total lens of the type "elem :: Lens (Foo a) (Maybe (Foo b)) a b" or "elem :: Lens (Foo a) (Maybe (Foo b)) a (Maybe b)" ? 
11:54:20 <Welkin> > let xss = [[1,2,3],[4,5,6]] in concat (sequence xss) == head xss >>= last xss
11:54:22 <lambdabot>      Couldn't match expected type âm a0â with actual type âBoolâ
11:54:22 <lambdabot>      In the first argument of â(>>=)â, namely
11:54:22 <lambdabot>        âconcat (sequence xss) == head xssâ
11:54:24 <monochrom> no, regular type families don't promise injective
11:54:24 <Cale> mniip: Oh?
11:54:32 <Welkin> > let xss = [[1,2,3],[4,5,6]] in concat (sequence xss) == (head xss >>= last xss)
11:54:33 <lambdabot>      Couldn't match type â[Integer]â with âInteger -> [Integer]â
11:54:33 <lambdabot>      Expected type: [Integer -> [Integer]]
11:54:33 <lambdabot>        Actual type: [[Integer]]
11:54:34 <levi> Things generally become things when someone creates them, whether they have a good reason to do so or not.
11:54:35 <mniip> Cale, yes!
11:54:53 <Cale> mniip: How do you convince the type checker when it knows that F a ~ F b to infer a ~ b ?
11:54:57 <mniip> Cale, I have a blog post about this, too!
11:54:58 <htebalaka> is there any minor way to change the data declaration for this datatype to permit the monad instance? http://lpaste.net/140215
11:55:16 <mniip> Cale, it's slightly more complicated than that
11:55:19 <monochrom> oh you mean you know how to encode an injective type family using regular type families?
11:55:20 <mniip> say you
11:55:30 <mniip> monochrom, yeah basically
11:55:48 <monochrom> you know what, I know how to encode existential types using forall types. not going to do that in practice.
11:56:24 <mniip> Cale, say you have a type family F :: k -> l that you believe is injective
11:56:38 <mniip> you define a type family InverseF :: l -> k
11:56:39 <levi> Just because you can encode something in another thing doesn't always mean you ought to use the encoded construction instead of a primitively-provided one.
11:56:44 <mniip> which does what is says on the label
11:57:01 <mniip> and 'a -> F a' turns into
11:57:14 <mniip> '(r ~ F a, a ~ InverseF r) => a -> r'
11:57:32 <levi> Otherwise we'd be stuck with some unsugared variant of SystemF. :P
11:57:48 <Ankhers> What does "~" mean in this context?
11:57:55 <Cale> Ankhers: Type equality
11:57:55 <monochrom> type equality
11:58:03 <mniip> monochrom, forall'd types, if I'm not mistaken, have include a performance hit
11:58:07 <mniip> this is the typechecker
11:58:07 <Ankhers> Cale, monochrom: Thanks!
11:58:14 <Cale> I'm not 100% sure why they couldn't just use = for it, but probably some parsing ambiguity reason
11:58:32 <mniip> monochrom, and wrt having to encode something
11:58:40 <mniip> isn't composability the main idea of haskell
11:59:09 <sinelaw> greetings.
11:59:56 <Cale> mniip: I'm not sure how that'll play out in practice. You'll have to explicitly apply the inverse type family constructor in some places, and it might get weird.
12:00:03 <Sindriav_> Is there a way to turn a type into an Int?
12:00:04 <monochrom> encoding is irrelevant to composition
12:00:18 <monochrom> in fact, encoding probably mars composition
12:00:25 <clrnd> Sindriav_, fromInteger/fromIntegral?
12:00:38 <Sindriav_> clrnd: That turns a *value* into an Int ;)
12:00:44 <geekosaur> er, what type(s)?
12:00:49 <geekosaur> and why?
12:00:51 <clrnd> oh, sorry
12:00:52 <mniip> monochrom, having basic blocks and composition tools instead of having clumsy big unseparable stones
12:01:08 <levi> ~ is generally used in mathematics as a relational operator meaning two things that have an equivalence relation.
12:01:10 <clrnd> then your quesiton doesn't make sense?
12:01:15 <Sindriav_> geekosaur: Any type, and I'm playing around with some FFI magicks
12:01:21 <mniip> there
12:01:43 <mniip> there's a reason we have 'map' and 'negate', and no 'negateAllNumbersInList'
12:01:47 <Sindriav_> clrnd: It does. I want to basically turn a type into an unique identifier I can pass elsewhere
12:01:57 <dgryski> sinelaw: mostly the thread attached to https://twitter.com/bitemyapp/status/639448222801334272
12:01:59 <sinelaw> Sindriav_, theres TypeRep  https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Typeable.html
12:02:09 <sinelaw> *there's
12:02:10 <Cale> mniip: Like, in cases where you know F a ~ F b, and you have a value of type b that you want to use as a value of type a, I don't know if it's easy to get the compiler to think of that value of type b as a value of type InverseF (F b), and the context of type a as having type InverseF (F a), so that you can use the fact that F a ~ F b
12:02:22 <geekosaur> TypeRep is not an Int though, nor is it isomorphic to one
12:02:52 <Sindriav_> sinelaw: That's promising
12:03:02 <mniip> Cale, let
12:03:04 <Cale> mniip: You might have to introduce some spurious identity functions
12:03:04 <mniip> 's see
12:03:09 <monochrom> every time you encode something, you have to write boilerplate code. and then, either you have to add a comment "I am writing dictionary passing by hand to encode a type class", or you assume that the reader recognizes your boilerplate to be writing dictionary passing by hand to encode a type class. This is the origin of Design Patterns.
12:03:15 <Cale> mniip: and otherwise clutter your program
12:03:25 <Sindriav_> geekosaur: Well, it doesn't need to be an int, just something I can pass to FFI
12:03:37 <Sindriav_> monochrom: This won't be a public API
12:03:59 <geekosaur> I don;t see a Storable instance either, and suspect making one would be Difficult
12:04:07 <monochrom> don't worry Sindriav_, I am not critiquing yours
12:04:07 <Sindriav_> yeah
12:04:14 <athan> What's a good way to asynchronously try to get the first `Just` value, given a function `(a -> Maybe b)` and `xs :: [a]`?
12:04:35 <athan> and giving-up on the rest of the computations when one is found?
12:04:45 <mniip> hrm
12:04:53 <geekosaur> although I suppose you could use the Show instance and then hash the resulting String
12:05:06 <Sindriav_> I'm basically making "Map Type (Map Word a)" for varying `a` inside the map
12:05:14 <mniip> monochrom, does that mean any code that is used at least twice belongs in the compiler/base library?
12:05:19 <Sindriav_> In C, and working with it through the FFI
12:05:35 <Sindriav_> Can I write an extension for deriving custom classes?
12:05:37 <Cale> athan: msum . parMap f
12:05:51 <Welkin> athan: asynchronously?
12:06:10 <Welkin> athan: you can use catMaybes to extracts the Just values from a [Maybe]
12:06:11 <geekosaur> (note that TypeRep is recursive)
12:06:12 <mniip> Cale, actually wait what
12:06:16 <bitemyapp> athan: https://hackage.haskell.org/package/parallel-3.2.0.6/docs/Control-Parallel-Strategies.html
12:06:18 <mniip> if we have F a ~ F b
12:06:46 <mniip> we instead have (r ~ F a, r ~ F b, b ~ InverseF r, a ~ InverseF r)
12:06:58 <mniip> (r because ra ~ rb)
12:07:36 <mniip> now *actually* if that family is truly injective, you wouldn't be having a and b there
12:07:48 <Cale> what?
12:07:52 <Cale> I don't understand
12:07:53 <clrnd> I can't wait for ahskell to become idris so we can mock the idris guys for being to "academic"
12:08:01 <Cale> heh
12:08:05 <mniip> Cale, I'm not sure I understand your use case
12:08:16 <mniip> you want GHC to prove a ~ b from F a ~ F b?
12:08:17 <monochrom> mniip: see my http://www.vex.net/~trebla/haskell/crossroad.xhtml#philosophy  although the whole article is for pattern matching vs predicates+selectors, the same consideration applies every time you have a collection of basic blocks.
12:08:29 <Cale> mniip: Yes, that's the whole point of injective type families after all
12:08:40 <mniip> ok
12:08:44 <Sindriav_> geekosaur: Maybe I could write up what I'm trying to do into a private message, so it's a bit clearer? :)
12:08:45 <dolio> How are you going to ensure that all possible ways of 'F a ~ F b` ending up known are instead 'F a ~ r, F b ~ r, ...'?
12:08:50 <mniip> why do you want it to prove that?
12:09:11 <mniip> do you have a specific non-trivially-reducible use case?
12:09:46 <geekosaur> Sindriav_, in that case just send it to haskell-cafe list instead of here, perhaps
12:09:47 <Cale> mniip: Because maybe I know by construction that F a ~ F b, because I've pattern matched on some GADTs or something, but now I have a value of type a and I want to use it as a value of type b, or vice versa.
12:10:11 <Sindriav_> geekosaur: I wasn't aware of that channel, I'll join now ^^
12:10:22 <geekosaur> not a channel
12:10:24 <monochrom> no, haskell-cafe is a mailing list
12:10:24 <geekosaur> mailing list
12:10:33 <dolio> For instance, 'F a ~ F b` often ends up happening during unification in OutsideIn, and you have to add Proxy arguments to nail down a and b.
12:10:34 <nitrix> Is it possible to get currying in a RPN language?
12:10:35 <Sindriav_> Ah, I see
12:10:36 <mniip> Cale, and what's a ~ b got to do with this?
12:10:39 <geekosaur> thus more suitable for the longer things
12:10:49 <nitrix> How clumsy would it be?
12:10:50 <Sindriav_> geekosaur: It's not really long, just a tad complex
12:11:03 <Sindriav_> geekosaur: I'll see what I can conjure up in C first
12:11:04 <Cale> mniip: If you want to use a value of type a in some place where a value of type b is required, then the two types had better be equal
12:11:17 <mniip> and F a ~ F b comes from the gadt?
12:11:24 <Sindriav_> geekosaur: I basically want a database for arbitrary types
12:11:29 <mniip> sounds weird as hell
12:11:45 <Cale> mniip: e.g. maybe I want to apply a function of type b -> Integer which came from one of my GADT structures to my value of type a which came from the other
12:11:46 <geekosaur> anyway it's not difficult to do a Typeable a => Map TypeRep a in Haskell. doing it for C via the FFI is harder
12:12:13 <mniip> Cale, I guess I'll have to ask you to concretize further
12:12:22 <mniip> I still don't understand the issue
12:12:23 <geekosaur> (not exactly that type)
12:12:53 <Sindriav_> geekosaur: Hmâ¦ I'll try to do it in Haskell first :) Thanks for the info!
12:13:58 <dolio> mniip: Also, did you read the specification for injective type families?
12:14:36 <mniip> dolio, glanced over it
12:14:42 <levi> athan: Note that if you just take the head of the catMaybes list, it automatically terminates after the first Just value. E.g. 'head . catMaybes . fmap Just $ [1..]' => 1 
12:14:44 <mniip> fundep-like, aren't they
12:15:59 <dolio> So, you're enthused about creating two extra type families to witness the injectivity of Plus on both arguments?
12:16:42 <levi> athan: If you really want to do all the things in parallel and take the first that completes succesfully though, then you want the parmap thing.
12:17:29 <levi> athan: I wasn't entirely clear on what you meant by 'asynchronous' though.
12:17:45 <dolio> Manually specifying those families, too, instead of having GHC check that the family is injective for you.
12:18:20 <mniip> dolio, I would prefer a TH solution over a compiler feature in this case
12:19:38 <mniip> migth even boilerplate some 'type FRelation a r = (r ~ F a, a ~ InverseF r)'
12:19:57 <mniip> ugh, that's just emulation of MPTC via type families :o
12:21:15 <lpaste_> Cale pasted âsilly exampleâ at http://lpaste.net/140217
12:21:23 <Cale> mniip: ^^
12:21:24 <monochrom> this leads me to a great crazy idea. a programming language that provides a programmable type system.
12:21:37 <mniip> you mean haskell?\
12:21:46 <mniip> if in doubt, TH
12:21:47 <Cale> mniip: Play around with that, it's a little example of the sort of case which makes you want injective type families
12:22:09 <levi> monochrom: Isn't that sort of what Shen is?
12:22:41 <monochrom> I don't know. I haven't looked at Shen. the Shen I know is a human.
12:23:10 <mniip> Cale, data T :: * -> * where C :: (r ~ F a, a ~ InverseF r) => a -> (a -> Integer) -> T r
12:23:19 <mniip> if I recall gadt syntax correctly >.>
12:23:32 <monochrom> but did someone record Shen's mind on magnatic tape? that would certainly turn him into a programming language :)
12:24:29 <mniip> monochrom, a programmable typesystem is just as evil as raw memory access
12:24:46 <Cale> mniip: still doesn't compile ;)
12:24:57 <Cale> We can even throw in  InverseF (F a) ~ a, F (InverseF r) ~ r
12:24:58 <mniip> where evil is a linear combination of powerful and dangerous
12:25:34 <geekosaur> accursedUnutterableCoerce
12:25:41 <mniip> Cale, oh
12:25:47 <lpaste_> Cale annotated âsilly exampleâ with âsilly example (annotation)â at http://lpaste.net/140217#a140218
12:25:52 <mniip> this isn't a closed type family
12:25:59 <mniip> you should close both families
12:26:05 <levi> monochrom: It's got some sort of sequent calculus system for defining and extending its type system.
12:26:25 <Welkin> levi: Shen is now closed-source
12:26:32 <monochrom> ah, then yeah
12:26:57 <mniip> Cale, open injective type families I don't think I can emulate
12:27:24 <lpaste_> Cale revised âsilly example (annotation)â: âNo titleâ at http://lpaste.net/140218
12:27:36 <Cale> now what?
12:27:41 <levi> Welkin: I heard, but I don't really have an opinion about it.
12:28:36 <Cale> mniip: ^^ see revision :)
12:29:04 <mniip> Cale, f :: T r -> T r -> Integer
12:29:16 <mniip> also get rid of those extra constraints, they're useless
12:29:28 <mniip> they can be derived from the other two by the typechecker
12:29:45 <Cale> okay, that works again for now :)
12:30:17 <clarkenciel> has anyone else had trouble installing the stream-fusion package? Any advice?
12:30:36 <Cale> mniip: So, I guess we have one answer to your question: non-closed type families
12:30:44 <mniip> yeah okay
12:30:58 <mniip> can't deny that
12:31:40 <mniip> Cale, oh actually
12:31:46 <mniip> I just took the final code
12:31:55 <mniip> opened the families, and it typechecked
12:32:03 <mniip> \o/
12:32:07 <Cale> er, no, actually, it works if they're not closed
12:32:10 <Cale> yeah
12:32:51 <Cale> I guess we'll have issues if F a occurs explicitly in some cases though
12:33:00 <mniip> Cale, I'm pretty sure if this was some widely known concept and you knew what all these constraints do, you'd figure out why those particular errors arise and how to fix them
12:33:05 * hackagebot yesod-crud 0.1.3 - Generic administrative CRUD operations as a Yesod subsite  https://hackage.haskell.org/package/yesod-crud-0.1.3 (league)
12:33:42 <mniip> but... injective type families already are :(
12:33:53 <Cale> hm?
12:34:11 <mniip> they are already implemented and accepted for merge
12:34:24 <mniip> also I wonder
12:34:30 <Cale> sure, I don't see why that's a problem
12:34:34 <mniip> can polymorphic MPTC instances be fixed finally?
12:35:00 <Cale> With injective type families, you'd be able to write  f :: T (F a) -> T (F a) -> Integer
12:35:14 <Cale> which you might actually kind of want to do in some cases
12:35:27 <Cale> Let me revise this example a bit
12:35:40 <Cale> I'm sure we'll be able to fix it by adding enough constraints
12:35:42 <mniip> if you're trying to say "understandable type singatures are cool"
12:35:49 <Cale> But we can make this annoying
12:35:54 <mniip> >lens
12:36:51 <djbeau> glguy, Profpatsch, kadoban: a question on an old discussion, but what is "stack"?
12:37:07 <mniip> djbeau, a data structure interface
12:37:22 <mniip> something you can add items into, and retrieve in LIFO order
12:38:11 <mniip> unless you're talking about the new slightly less broken cabal
12:38:13 <djbeau> does all this refer to the haskell package with that name?
12:38:19 <djbeau> that I just found?
12:38:49 <kadoban> djbeau: https://github.com/commercialhaskell/stack  you can use it instead of cabal-install or other tools
12:39:07 <djbeau> I see, thanks!
12:39:07 <lpaste_> Cale pasted â:(â at http://lpaste.net/140221
12:39:16 <kadoban> It's pretty new, but already far superior to cabal-install IMO.
12:39:39 <Cale> mniip: You can sort of get everything to work with enough fiddling around
12:39:48 <mniip> Cale, you need both constraints on f
12:39:51 <mniip> for proper inference
12:40:01 <Cale> yeah, possibly
12:40:07 <Cale> right
12:40:17 <mniip> F and InverseF are one
12:40:26 <mniip> they're like a fundep
12:40:39 <Cale> errrr
12:40:40 <mniip> if you only specify one half, you only get one direction of inference
12:41:04 <Cale> yeah
12:41:18 <Cale> So, these constraints are going to spill out all over your program
12:41:22 <mniip> yes
12:41:25 <Cale> You can't just have them in the definition of the types
12:41:34 <mniip> your argument is valid, but
12:41:37 <mniip> >lens
12:41:40 <Cale> ?
12:41:54 <mniip> lens code does the same to your program
12:42:08 <Cale> That... is a strawman argument?
12:42:24 <mniip> hence I said your argument is "valid, but"
12:42:35 <Cale> "This library makes my types ugly, so I stopped caring about having sane looking types"
12:42:55 <Cale> You could also use another lens library if you wanted.
12:43:01 <Cale> There are simpler ones
12:45:24 <mniip> on an unrelated note does anyone know a symbolic math package, that can, for example, differentiate a function
12:45:53 <sm> ad ?
12:46:19 <fosterite> mniip: have you looked at the constructie algebra packages
12:46:55 <dolio> None of the simpler ones are worth using.
12:47:28 <sm> oh, I guess ad is not symbolic
12:48:12 <mniip> I guess I just define the differentiation rules by myself
12:48:34 <mniip> just need some dirty work done
12:49:50 <sm> mniip: here ya go https://www.youtube.com/watch?v=whQQpwwvSh4
12:55:20 <Sindriav_> geekosaur: I forgot an important fact: I can't store different `a`s in `Map TypeRep (Map Int a)` :/
12:55:49 <geekosaur> Sindriav_, there was a hint in wjhat I said earlier
12:56:38 <Sindriav_> What do you mean?
12:56:44 <geekosaur> basically you are using Typeable twice. once for the TypeRep key, once with an existential value with a Typeable constraint
12:56:59 <Sindriav_> Huhâ¦
12:57:15 <Sindriav_> So `forall a. Typeable a => Map TypeRep (Map Int a)` ?
12:57:16 <geekosaur> so you can, given the key, use it both to look up the value in the Map and to Data.Typeable.cast the existential value to the result type
12:57:25 <geekosaur> (xmonad's ExtensibleState does this)
12:57:27 <Jello_Raptor> is there a lens that'll let me work inside a Maybe? 
12:57:36 <geekosaur> the forall needs to actually be closer to the "a"
12:58:06 * hackagebot network-house 0.1.0.2 - data and parsers for Ethernet, TCP, UDP, IPv4, IPv6, ICMP, DHCP, TFTP  https://hackage.haskell.org/package/network-house-0.1.0.2 (NiklasHambuechen)
12:58:13 <geekosaur> Map TypeRep (Map Int (forall a. Typeable a => a))
12:58:19 <Sindriav_> I see!
12:58:29 <Sindriav_> I'll give that a shot
12:59:49 <geekosaur> ...also consider IntMap instead of Map Int
13:00:42 <ReinH> Jello_Raptor: _Just is a prism
13:01:21 <Jello_Raptor> ReinH: thanks :)
13:01:34 <ReinH> > Just 2 & _Just %~ Prelude.succ
13:01:36 <Sindriav_> geekosaur: Yeah, it won't eventually be an int, but Thanks! ^^
13:01:38 <lambdabot>  Just 3
13:04:58 <Ankhers> :t (&)
13:05:00 <lambdabot> a -> (a -> b) -> b
13:05:15 <Ankhers> :t (.)
13:05:16 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:05:22 <Ankhers> :t ($)
13:05:23 <lambdabot> (a -> b) -> a -> b
13:05:41 <Ankhers> :t (%~)
13:05:43 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
13:06:10 <Cale> One of these things is not like the others
13:06:41 <ReinH> heh
13:07:20 <Ankhers> (&) = flip ($) -- ?
13:07:59 <Cale> :t (<|)
13:08:01 <lambdabot> Cons s s a a => a -> s -> s
13:08:04 <Cale> heh
13:08:12 <Cale> Gets in the way of Data.Sequence
13:08:31 <Cale> But maybe it's just a generalisation
13:09:23 <Cale> Ankhers: yes
13:09:30 <Cale> Ankhers: somewhat unfortunate that :)
13:09:30 <Ankhers> Cale: Thanks!
13:09:47 <Ankhers> It seems strange to me to specify the value before the function...
13:09:52 <Sindriav_> geekosaur: How do I then actually store the value in the map?
13:11:48 <Ankhers> Cale: Why do you consider it to be unfortunate?
13:11:51 <geekosaur> you can store any value whose type has a Typeable constraint, as is. you use the TypeRep (which you are also using as the key, so you know it matches) with http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/base-4.6.0.1/Data-Typeable.html#v:cast to extract it
13:12:06 <geekosaur> (you can put anything in the box, it's getting things back out that is tricky)
13:13:21 <Sindriav_> geekosaur: I can't seem to just store the value :/
13:13:27 <Cale> Ankhers: It usually results in weird code where things switch direction
13:13:36 <Soviet_Jesus> Noob question: my solution is called problem2 and the one I found online is problem2' and I had a couple of questions about them and their differences http://lpaste.net/140223
13:13:52 <Ankhers> Cale: I figured as much. Thanks!
13:14:14 <Cale> Soviet_Jesus: sure
13:14:17 <Sindriav_> geekosaur: http://lpaste.net/6447580054074425344
13:14:18 <mariusmarius> Soviet_Jesus: you might want to check out #haskell-beginners
13:14:20 <Soviet_Jesus> Why is problem2' SO MUCH FASTER? and how should I be visualizing that zipWith function they're using
13:14:28 <athan> Say I have some positive number `n`. Is there an efficient pure function that generates values like `[n/3,2n/3,n/4,n/2,3n/4,n/5,..]`
13:14:36 <Cale> Soviet_Jesus: because it only computes each Fibonacci number once
13:14:39 <athan> something like a pseudo-uniform generation?
13:15:01 <athan> but uniform in stages - that's the important part
13:15:15 <Cale> Soviet_Jesus: Evaluating fib n will require computing an exponential number of applications of fib (in n)
13:15:39 <Cale> Soviet_Jesus: i.e. proportional to fib n itself
13:15:48 <Soviet_Jesus> oh, so for each n I try to compute, I'm computing all n below it?
13:15:54 <Cale> yeah, repeatedly
13:16:06 <fosterite> athan: map (n*) (that function that generates all rationals) ?
13:16:12 <Cale> When you compute fib (n-2), the result isn't reused for computing fib (n-1)
13:16:14 <fosterite> it's one of the funcitonal pearls
13:16:27 <Cale> So fib 80 even will take quite some time
13:16:47 <Soviet_Jesus> so then I guess I'm struggling to understand  how they're recursively building that list then
13:16:59 <Cale> Okay, so yeah, that list is cleverly constructed
13:17:25 <Cale> Let's write fibs and tail fibs above one another:
13:17:33 <Cale> 1 : 2 : ...
13:17:42 <Cale>     2 : ...
13:17:54 <ReinH> er
13:17:55 <Cale> er, not like that :)
13:17:58 <Cale> 1 : 2 : ...
13:18:00 <Cale> 2 : ...
13:18:04 <Cale> yeah
13:18:05 <geekosaur> mrrr. yes, I think it needs more than that but I am failing to think of how this is done properly right now :/
13:18:09 <ReinH> yeah
13:18:17 <lamefun> Why doesn't Text have Language.Haskell.TH.Syntax.Lift?
13:18:20 <Cale> So, now we add down the column to determine the next element of both
13:18:24 <lamefun> Is there one somewhere?
13:18:33 <Cale> zipWith (+) after all will add these two lists elementwise
13:18:55 <Cale> So the next element is 3, and we have
13:19:31 <Sindriav_> geekosaur: Maybe using Data.Data?
13:19:48 <Cale> fibs                         = 1 : 2 : 3 : ...
13:19:48 <Cale> tail fibs                    = 2 : 3 : ...
13:19:48 <Cale> zipWith (+) fibs (tail fibs) = 3 : ...
13:20:11 <geekosaur> I am looking at http://xmonad.org/xmonad-docs/xmonad-contrib/src/XMonad-Util-ExtensibleState.html but it doesn't do quite the same thing
13:20:19 <Cale> and now the next element after that we get by adding down the column, 2 + 3 = 5
13:20:26 <ReinH> (One important point is that the fibs expression is shared)
13:20:36 <Cale> fibs                         = 1 : 2 : 3 : 5 : ...
13:20:36 <Cale> tail fibs                    = 2 : 3 : 5 : ...
13:20:36 <Cale> zipWith (+) fibs (tail fibs) = 3 : 5 : ...
13:20:41 <Cale> right
13:20:41 <ReinH> s/expression/value
13:20:52 <geekosaur> (in particular it has an extra "box" around the value, because some of them persist across restarts and therefore need to be serializeable)
13:21:19 <Cale> fibs itself is a single list, and won't be recomputed as long as it remains in scope
13:21:29 <Sindriav_> geekosaur: I seeâ¦
13:22:00 <Soviet_Jesus> so fibs is growing, and tail fibs is the length of fibs without the head, but the head doesn't matter becasue we need to add from the back?
13:22:13 <Cale> tail fibs is the actual list without the head
13:22:17 <Cale> not the length of the list
13:22:20 <Cale> the list is infinitely long
13:22:42 <Cale> But we find out what its elements are only as we look at each one
13:23:00 <geekosaur> (also we access it via an interface more resembling the state monad, although it is not in fact MonadState)
13:23:19 <Cale> https://www.haskell.org/tutorial/fig1.gif
13:23:23 <Soviet_Jesus> erm, sorry, i guess what I was trying to get at was that it seems to be taking advantage of that offsett-y thing 
13:23:29 <ReinH> > zipWith (+) [1,2] [2] -- is evaluated and placed in the next spot in fibs
13:23:30 <lambdabot>  [3]
13:23:31 <Cale> I'm not sure that diagram helps, but maybe :)
13:23:40 <ReinH> rather, the first element is placed there
13:23:50 <ReinH> so now it's zipWith (+) [1,2,3] [2,3]
13:23:52 <ReinH> and so on
13:23:58 <Cale> Soviet_Jesus: yeah, we're adding the list of fibs to the list of fibs that's been shifted down by 1
13:24:00 <Sindriav_> geekosaur: It's strange. What I want to do is conceptually *really* simple, but seems to be almost impossible in most languages I've tried.
13:24:12 <Sindriav_> geekosaur: Maybe I'd be better of with Idris or Agda, where types are values too?
13:24:15 <Cale> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
13:24:18 <lambdabot>  Defined.
13:24:21 <Cale> > fibs
13:24:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:24:26 <ReinH> Soviet_Jesus: consider a simpler example:
13:24:27 <Cale> > tail fibs
13:24:28 <geekosaur> wouldn't bet on that...
13:24:29 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:24:33 <ReinH> > let ones = 1 : ones in ones
13:24:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:24:37 <Cale> > zipWith (+) fibs (tail fibs)
13:24:39 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
13:25:28 <Cale> you can see that indeed, fibs is equal to the result of adding fibs to (tail fibs) elementwise, and then sticking 0 and 1 on the front
13:25:36 <MarcelineVQ> what a fascinating way to build a list
13:26:13 <Sindriav_> geekosaur: From what I understand, the problem seems to be that the type checker cannot match the `a` I'm trying to store with the `a` in DB?
13:26:24 <ReinH> Then a slightly less simple example:
13:27:14 <ReinH> > let nats = 0 : fmap Prelude.succ nats
13:27:16 <lambdabot>  <no location info>:
13:27:16 <lambdabot>      not an expression: âlet nats = 0 : fmap Prelude.succ natsâ
13:27:20 <ReinH> > let nats = 0 : fmap Prelude.succ nats in nats
13:27:21 <geekosaur> well, it can't unify a known (Typeable a => a) with an unknown (forall a. Typeable a => a). I think this is ... overconstrained somehow
13:27:22 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
13:27:36 <RageYL> i've written a function that works. and i wantd to add a parameter to be able to reuse it: https://gist.github.com/anonymous/e7a07d60bea9ccd6414c howewer the fact to add a parameter raise an error. if you can take a look and tell me why
13:27:38 <Cale> :t succ
13:27:40 <lambdabot>     Ambiguous occurrence âsuccâ
13:27:40 <lambdabot>     It could refer to either âL.succâ,
13:27:40 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:158:1
13:27:42 <Cale> oh
13:27:44 <Cale> unfortunate
13:27:48 <ReinH> yep
13:27:50 <Cale> Maybe just use (+1)
13:27:51 <geekosaur> (but the weather is starting to mess with my head and I'm not able to think clearly about it right now :/ )
13:27:56 <ReinH> sure
13:28:01 <MarcelineVQ> > (takeWhile (<4000000) . filter even) fibs
13:28:03 <lambdabot>  [0,2,8,34,144,610,2584,10946,46368,196418,832040,3524578]
13:28:04 <ReinH> or undefine
13:28:11 <Soviet_Jesus> so the whole fib n = (n-1) + (n-2) is a pretty naive way of seeing it? 
13:28:26 <Cale> Soviet_Jesus: fib (n-1) + fib (n-2)
13:28:29 <Cale> yeah
13:28:37 <Sindriav_> geekosaur: Probably just leave it for now, then :)
13:28:45 <Cale> Soviet_Jesus: The important thing to note is that the results of function applications are not remembered forever
13:29:02 <Sindriav_> geekosaur: It feels really tricky, I'm treading on ground that's *very* new to me
13:29:08 <Cale> Soviet_Jesus: If they were, then nothing would ever be garbage collected, and your programs would eat up all the memory on the system very quickly
13:29:09 <geekosaur> it is indeed tricky
13:29:22 <clrnd> RageYL, what would be the error?
13:29:33 <Cale> Soviet_Jesus: There's another way we could do this, which would perhaps be easier to understand at first
13:29:59 <Cale> Soviet_Jesus: We could, instead of defining fibs, define a function which produces the list of Lucas numbers, given the first two elements
13:30:00 <RageYL> in the case i pasted it is: Illegal polymorphic or qualified type: Ord a => a -> a -> Bool
13:30:21 <Cale> i.e. the same as fibs, but with any two starting numbers
13:30:23 * frerich reads "Soviet_Jeans" all the time and remembers a stay in Moscow were young boys wanted to buy pens, bubblegum and bluejeans I brought into the country...
13:30:38 <RageYL> but if i remove the signature it tell it couldn't match String/Char/Bool with Integer
13:30:39 <geekosaur> erm, warning warning ... yes, you don;t want that Ord in there
13:30:46 <Cale> @let lucas a b = a : lucas b (a + b)
13:30:48 <lambdabot>  Defined.
13:30:49 <geekosaur> migrate it outward
13:30:57 <RageYL> what i don't understand is i juste replace the (==) with a parameter
13:30:58 <geekosaur> Ord a => (a -> a -> Bool) -> ...
13:31:01 <Cale> > lucas 0 1
13:31:05 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:31:35 <Cale> This will again be quite fast, just like fibs, but maybe is easier to understand
13:31:35 <geekosaur> may still not be enough because it has no idea how to match that up
13:31:58 <RageYL> geekosaur: oh yeah i should do that :D
13:32:01 <RageYL> but still an error
13:32:08 <Soviet_Jesus> sorry I'm so quiet, absorbing 
13:32:13 <Sindriav_> geekosaur: Well, placing the hole in the insert call says the type needs to be `forall a1. Typeable a1 => a1`, which is indeed the type inside the map. I could unsafecoerce, but that's lightspeed ugly
13:32:33 <stianhj> Can I view type constructors in ghci?
13:32:43 <geekosaur> RageYL: yes, I think it can never make that work as written. but perhaps if you made it (SchemeValue -> SchemeValue -> Bool)
13:33:05 <Sindriav_> stianhj: `:i Type`
13:33:08 <geekosaur> bvecause trying to pull the "hidden" type out like that is not going to work 
13:33:10 <mariusmarius> Cale: I see, so because we are using 'a' in the recursive call of lucasâ¦haskell can't let 'a' be garbage collected.
13:33:39 <mariusmarius> not immediately at least
13:33:40 <Cale> mariusmarius: not until the (a + b) is computed at least, and then it can be collected
13:33:43 <geekosaur> Sindriav_, yes, we need to rearrange that so it's not trying to do it that way
13:33:46 <RageYL> geekosaur: ok i will try that
13:33:54 <monochrom> stianhj: :info is very versatile. you can say ":info Maybe" or ":info Just" and you will get much information
13:34:13 <geekosaur> RageYL, it has no way to know that the a you are using there is related to the SchemeValue
13:34:15 <Sindriav_> geekosaur: unsafeCoerce gets it to compile, even, but it fails when calling it
13:34:23 <Cale> mariusmarius: As long as we compute the elements of the list as we walk down it, we'll only need enough space to store two of the previous list elements at a time
13:34:34 <mariusmarius> gotcha
13:34:52 <Soviet_Jesus> Cale I think you just put into words what I was trying to grox there
13:34:58 <Sindriav_> geekosaur: Maybe I could parametrize the DB?
13:35:09 <geekosaur> no, you can;t parameterize it finely enough
13:35:23 <Sindriav_> Hmmmâ¦
13:35:37 <geekosaur> you may be on the right path though
13:35:51 <monochrom> I much resent the zipWith+tail version
13:35:53 <stianhj> Sindriav_, Of course. Thanks
13:35:58 <RageYL> geekosaur: what i don't understand i just tell him that it take a function that take 2 orderable and return a bool, i don't understand why it's not possible
13:36:02 <mariusmarius> so the shittier way of doing lucas would be like this @let lucashit a = a : lucas (a - 1)
13:36:19 <mariusmarius> because lucashit forgets about 'a' as soon as it goes onto the next thing
13:36:36 <geekosaur> RageYL, because you told it "anything" and it therefore knows nothing about it and can't *use* it for anything
13:36:40 <zipper> Hey, I want to stream output to a browser.
13:36:47 <hannes__> Nickeeh: what do you have against it
13:37:01 <Sindriav_> zipper: That's a broad statement! Can you elaborate? :)
13:37:02 <zipper> I have a function that gives me a string. Then another then another.
13:37:23 <Cale> mariusmarius: Well, that's not the right sequence, but you can certainly write that function and it will work
13:37:26 <Sindriav_> zipper: And you want to show those in a browser window?
13:37:30 <zipper> If I wanted to take it to terminal I would `print` and have it print to terminal
13:37:39 <Cale> @let descending a = a : descending (a-1)
13:37:41 <lambdabot>  Defined.
13:37:46 <Cale> > descending 100
13:37:49 <zipper> However I want this string to go to browser the next so forth and so forth.
13:37:49 <lambdabot>  [100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76...
13:37:54 <Cale> > descending 10
13:37:57 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
13:37:57 <zipper> Sindriav_: Yes and not in terminal
13:38:05 <zipper> Sindriav_: Ideas?
13:38:22 <Sindriav_> zipper: Sounds like a job for WebSockets
13:38:35 <mariusmarius> Cale: yeah sorry I am tired, I did something totally different
13:38:50 <zipper> Sindriav_: It's a half duplex thing
13:39:01 <zipper> The browser should only take
13:39:15 <Sindriav_> zipper: That still fits websockets
13:39:36 <frerich> Soviet_Jesus, Cale: I'm probably too late for the party, but a couple of weeks ago our very own arkeet created this drawing which IMHO explains the 're-using values' part in recursive definitions quite nicely: http://puu.sh/isDAc/a70bc263c5.jpg
13:39:45 <Cale> Soviet_Jesus: So lucas sort of uses the same method as you might use on paper to compute the Fibonacci numbers, keeping track of the previous two at least, and adding them together to find out what the one after that will be.
13:40:04 <Cale> yes
13:40:07 <Soviet_Jesus> So, me being like 3 days into haskell, what I think I'm taking away here is that I should get better at constructing lists on the fly instead of trying to brutishly calculate all of them to the nth?
13:40:08 <Cale> That's a good drawing
13:40:22 <Cale> Soviet_Jesus: eventually, yeah :)
13:41:06 <Cale> Soviet_Jesus: Another way you can think of it is that we've written down an equation that the list of Fibonacci numbers ought to satisfy, and it's a strong enough equation that it uniquely determines which list we have.
13:41:46 <aweinstock> :t \connection -> mapM_ (Network.WebSockets.sendTextData connection)
13:41:48 <lambdabot> Not in scope: âNetwork.WebSockets.sendTextDataâ
13:42:09 <ReinH> frerich, arkeet: nice
13:42:22 <arkeet> ??
13:42:29 <arkeet> oh
13:42:34 <ReinH> The wiki has a thing as well https://wiki.haskell.org/Tying_the_Knot
13:42:48 <ReinH> As does SO http://stackoverflow.com/questions/357956/explanation-of-tying-the-knot
13:42:49 <Soviet_Jesus> frerich: I need to stare at that for a little while
13:42:56 <ReinH> Perhaps those explanations might also be useful
13:43:03 <aweinstock> zipper: I'm pretty sure Network.WebSockets.sendTextData (from the websockets package) is the relevant function (and use mapM_ to apply it to a (potentially infinite) list of strings/bytestrings)
13:43:03 <arkeet> > let x = 1 : map (2*) x in x
13:43:05 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
13:43:30 <Cale> Soviet_Jesus: ^^ yeah, that's the program which is depicted in the diagram
13:43:45 <frerich> Soviet_Jesus: Sorry, I only now realize I forgot to provide a bit of context - there was a discussion about a definition like 'powers = 1 : map (2*) powers' and how often (*2) was calculated for some (say, the 99th) element.
13:43:51 <zipper> aweinstock: Let me see 
13:43:59 <arkeet> also refer to http://www.vex.net/~trebla/haskell/lazy.xhtml for the notation
13:44:05 <arkeet> also just read that article :p
13:44:30 <Cale> i.e. the list of powers of 2 starts with 1, and what follows can be obtained by multiplying by 2 each of the elements of that list
13:44:37 <ReinH> Cale: My favorite use so far was the one for tying the knot in HOAS, can't remember the paper name though
13:44:59 <Soviet_Jesus> So, related question, are there resources better than Learn you a Haskell for great good? Because I'm on the chapter for modules and am starting to get lost
13:45:12 <Cale> Soviet_Jesus: Another thing to note, if you're familiar with imperative programming, is that lists act a whole lot like loops in Haskell
13:45:21 <ReinH> Soviet_Jesus: yes
13:45:29 <arkeet> @where learnhaskell -- nowadays people recommend this for learning haskell
13:45:29 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:45:36 <ReinH> Yes that
13:45:45 <Cale> Soviet_Jesus: Just as a loop will either have no iterations (because its precondition isn't met), or will consist of a single iteration followed by another loop,
13:46:06 <Cale> Soviet_Jesus: every list is either the empty list [], or consists of a single element x followed by another list xs, written x:xs
13:46:24 <Cale> Just as loops can be infinite, so can lists
13:47:16 <Soviet_Jesus> Cale: it seems like lists are more "forward looking" than loops
13:47:22 <Cale> It's weird in Haskell to just delete the nth element of a list, just as it would be to skip just the nth iteration of a loop
13:47:33 <athan> Would `getFirst . foldMap` be minimal in how you'd expect?
13:48:02 <Cale> Or in general random accesses to lists are unnatural operations to perform, and if you need to do lots of that, then lists are not the right thing to use really.
13:48:19 <Cale> Lists should almost always be loops "waiting to happen" in some sense
13:48:25 <Cale> or "frozen in time"
13:49:06 <Soviet_Jesus> I think I'm not even there yet, I'm still trying to "get" how one is built well vs poorly
13:49:10 <Cale> You don't *have* to follow that, sometimes a list is just a list, but this is what lists are good at and why they're so important.
13:49:43 <Soviet_Jesus> though I suppose that comes down having good functions rather than any large conceptual thing?
13:50:01 <Cale> yeah, understanding the functions you have available to manipulate lists is important
13:50:11 <frerich> Soviet_Jesus: I liked the book 'Programming in Haskell' a lot, because it starts at zero and it also takes the time to talk about proving properties of your program. And I think the pace is just right (not too fast, not too slow).
13:50:25 <Cale> You'll probably end up implementing a lot of the Prelude and list library for yourself as you learn Haskell :)
13:50:32 <frerich> Soviet_Jesus: It's also quite short, which may be a testament to the authors ability to limit himself to the relevant. :-)
13:51:13 <Soviet_Jesus> I did notice a lof of the book's function signatures had a ' thrown on the end
13:51:43 <mariusmarius> you usually do that when you're reimplementing a function andâ¦well..you can't use the same name
13:51:51 <Cale> For example, let's say you want to find where some substring occurs in a string. While there are better algorithms, let's just go with the very simple algorithm of looking for the substring starting at each position
13:52:10 <Cale> We can use the function tails:
13:52:16 <Cale> > tails "abracadabra"
13:52:18 <lambdabot>  ["abracadabra","bracadabra","racadabra","acadabra","cadabra","adabra","dabra...
13:52:29 <L8D> I see a lot of people pointing to LYAH for experienced programmers, and then for entry-mid level programmers they point to other things
13:52:36 <skore_de> Soviet_Jesus: I also got lost at precisely that chapter in LYAH. It seems to be a common theme. bitemyapp is around on #haskell-beginners a lot and I've switched to his 'Haskell Programming' book and have a much better experience - http://haskellbook.com/
13:52:39 <Cale> and then look for a string which has the desired substring as a prefix:
13:53:01 <Cale> > map (isPrefixOf "cad") (tails "abracadabra")
13:53:02 <L8D> and a commonly pointed out problem of LYAH is that is uses existing concepts and imperative thinking to explain functional/declarative concepts
13:53:03 <lambdabot>  [False,False,False,False,True,False,False,False,False,False,False,False]
13:53:22 <Cale> > or (map (isPrefixOf "cad") (tails "abracadabra"))
13:53:24 <lambdabot>  True
13:53:36 <Cale> > findIndex (isPrefixOf "cad") (tails "abracadabra")
13:53:38 <lambdabot>  Just 4
13:53:49 <L8D> I wonder if there's a good book or tutorial on Haskell that emphasizes the high-level effects and powers of Haskell
13:53:54 <Cale> > filter (isPrefixOf "cad") (tails "abracadabra")
13:53:56 <lambdabot>  ["cadabra"]
13:54:14 <skore_de> L8D: Exactly my experience as well. It tries to use your preconceived notions on a number of concepts. Turns out a lot of mine weren't good enough ;)
13:54:20 <Sindriav_> geekosaur: The issue is that I can't get rid of either Typeable constraint, and only one needs to be there, it seems :/
13:54:38 <Cale> Soviet_Jesus: The fact that tails and map and so on are all lazy makes this a lot more reasonable
13:54:51 <Cale> Soviet_Jesus: because we can stop looking once we've found the first match
13:54:57 <monochrom> Richard Bird's emphasizes the high level and power of algebra, of which Haskell is a special case.
13:55:22 <Cale> Soviet_Jesus: this will even work on infinite lists...
13:55:29 <Sindriav_> geekosaur: Nope, scratch that, even getting rid of the Typeable Constraint in registerComponent doesn't help :/
13:55:37 <ReinH> Cale: Well, it will sometimes work on infinite lists.
13:55:41 <Cale> well yes
13:55:42 <Cale> heh
13:55:45 <ReinH> :)
13:55:53 <Cale> It will search forever until it finds one
13:55:59 <ReinH> yep
13:56:40 <Cale> @let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) -- an interesting infinite list for example use
13:56:42 <lambdabot>  Defined.
13:56:44 <Cale> > priems
13:56:46 <Cale> oops
13:56:46 <lambdabot>      Not in scope: âpriemsâ
13:56:46 <lambdabot>      Perhaps you meant one of these:
13:56:46 <lambdabot>        âprimesâ (line 151), âprism'â (imported from Control.Lens),
13:56:48 <Cale> > primes
13:56:51 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:56:55 <Soviet_Jesus> so basically instead of a loop with a found it boolean flag or what have you, haskell just says good enough and crawls back into its home?
13:57:38 <Soviet_Jesus> that primes lambda has been driving me insane for like 2 days now
13:57:39 <Cale> > map (take 2) (filter (\(x:y:_) -> y == x + 2) (tails primes))
13:57:41 <lambdabot>  [[3,5],[5,7],[11,13],[17,19],[29,31],[41,43],[59,61],[71,73],[101,103],[107,...
13:58:23 <ReinH> @src (||)
13:58:23 <lambdabot> True  || _ =  True
13:58:23 <lambdabot> False || x =  x
13:58:31 <Cale> So here, we filter the list of tails of primes for ones which start with a number and one which is two greater than that
13:58:38 <Cale> i.e. looking for twin primes
13:58:39 <ReinH> Soviet_Jesus: Notice that if || encounters a True on the left hand side, it doesn't need to evaluate the right hand side
13:58:51 <Cale> and then we map (take 2) in order to chop each tail off
13:59:04 <monochrom> recursion drives operationally minded people crazy.
13:59:17 <Cale> and if we only want the first example, we can apply head to the result:
13:59:21 <Cale> > head (map (take 2) (filter (\(x:y:_) -> y == x + 2) (tails primes)))
13:59:23 <lambdabot>  [3,5]
13:59:48 <ReinH> Soviet_Jesus: consider the definition: or [] = False; or (x:xs) = x || or xs
14:00:13 <ReinH> Soviet_Jesus: if x is True, or xs is not evaluated
14:00:20 <Soviet_Jesus> the fact that the "->" and "<-" both can show up blows my mind
14:00:20 <Cale> (or use find)
14:00:36 <monochrom> when Peter Naur successfully implemented recursion for Algol and reported it in a conference, a lot of attendees refused to believe it.
14:00:44 <ReinH> monochrom: heh
14:00:45 <Cale> Soviet_Jesus: Oh, that's just punctuation
14:01:12 <Cale> Soviet_Jesus: <- shows up in list comprehensions and do-notation
14:01:21 <Cale> -> shows up in the syntax of lambda and case
14:01:30 <Cale> they're just ascii art for arrows
14:01:55 <ReinH> (and in types ofc)
14:01:56 <levi> monochrom: I was just reading some anecdotes about how recursion was "snuck" into the Algol 60 specification.
14:01:58 <Cale> yes
14:02:09 <ReinH> levi: I too would like to read anecdotes
14:02:26 <levi> I'm trying to remember where I read them, but it's eluding me.
14:02:29 <earthy> levi: wasn't it more of a matter of 'dang, forgot to exclude it'?
14:02:30 <ReinH> :(
14:02:42 <ReinH> but mah anecdotes
14:03:09 <monochrom> and Peter Naur got to brag, "you know what, it's trivial in retrospect. see, if you have so much as decided to use a stack for non-recursive calls, may as well do the exact same thing to recursive calls, the computer doesn't need to know the difference"
14:03:14 <earthy> https://vanemden.wordpress.com/2014/06/18/how-recursion-got-into-programming-a-comedy-of-errors-3/
14:03:31 <Soviet_Jesus> ok.....so I think I've been trying to do like everything as a list comprehension, when i probably dont need to
14:04:03 <Cale> oh, jeez, I just ran into this:
14:04:09 <Cale> > replicate (-5) 0
14:04:10 <lambdabot>  []
14:04:13 <Cale> ^^ reasonable
14:04:17 <Cale> > Seq.replicate (-5) 0
14:04:19 <lambdabot>  fromList *Exception: replicate takes a nonnegative integer argument
14:04:22 <Cale> ^^ whoops!
14:04:49 <levi> earthy: No, there were a number of people who wanted to include it, but also a sizable faction that didn't, mostly because it wasn't understood how to implement it well.
14:04:50 <Cale> (this isn't aimed at Soviet_Jesus)
14:04:51 <Soviet_Jesus> http://lpaste.net/140224 so far this, and computing vector products are all I've been able to do
14:05:18 <Cale> Soviet_Jesus: List comprehensions can certainly be nice
14:05:48 <Cale> > [(x,y) | (x:y:_) <- tails primes, y == x + 2]
14:05:50 <lambdabot>  [(3,5),(5,7),(11,13),(17,19),(29,31),(41,43),(59,61),(71,73),(101,103),(107,...
14:05:59 <Cale> perhaps nicer than what I wrote before
14:06:24 <Cale> Especially if you want to make selections from multiple lists at once
14:06:34 <Cale> List comprehensions can be pretty compact
14:06:45 <Cale> But higher order functions can be more flexible in many ways too
14:07:16 <levi> Peter Naur basically hijacked the Algol 60 specification process by showing up to the first official meeting with a nearly-complete draft. A lot of people were peeved, but he did a good enough job with his draft that it basically set the groundwork for the language.
14:07:48 <Soviet_Jesus> I have, SO many things to learn. but english is basically just nested function application so how hard can it be ... >_>
14:07:48 <Cale> I think there's a tendency to start out writing lots of list comprehensions as a beginner, and then once you know enough higher order functions you start using those almost exclusively, and then eventually you work out which things list comprehensions are really good at exactly.
14:08:10 * hackagebot loop 0.3.0 - Fast loops (for when GHC can't optimize forM_)  https://hackage.haskell.org/package/loop-0.3.0 (NiklasHambuechen)
14:08:22 <Cale> It's a bit of a matter of taste
14:08:29 <levi> ReinH: I think this is the source I was thinking of: https://vanemden.wordpress.com/2014/06/18/how-recursion-got-into-programming-a-comedy-of-errors-3/
14:08:30 <Soviet_Jesus> Ok, so at least I'm not a total idiot
14:08:43 <ReinH> levi: What... what format did he specify the grammar in?
14:09:43 <levi> ReinH: He used Backus's recent notation, of course. Probably with some of his own modifications, though I'm not sure about that right now.
14:10:52 <ReinH> levi: I wonder what you would call that combination of Backus's notation with Naur's modifications.
14:11:20 <levi> Heh.
14:12:11 <levi> So, here's an account from someone who personally remembers someone questioning Naur on the possibility of implementing recursion: http://horningtales.blogspot.com/2006/07/recursion.html
14:16:59 <levi> ReinH: So, Alan Kay received an award from the U of U (he was a grad student there) and was invited to give a lecture as part of it. There was a reception afterward, which I attended (because no one said that random people in the audience couldn't attend, and how could I pass that up?) and it was really fun to listen to him and some others from the time he was there chat about the computers of the day and
14:17:01 <levi> the sort of things they were up to.
14:17:30 <Soviet_Jesus> What constitutes a proof in haskell? I know a program is technically a proof that a computation is possible, but I was under the notion you can prove theorems with it.
14:18:19 <Soviet_Jesus> Like could I do something like have a language M and define properties for it and then prove further properties, but keep it all contained in haskell?
14:18:29 <hiptobecubic> Soviet_Jesus, https://en.wikipedia.org/wiki/Curry-Howard_correspondence
14:18:35 <levi> Soviet_Jesus: When people talk about proving things in Haskell, they are usually talking about doing the sort of algebraic manipulation of programs that you'd do in a standard algebraic proof.
14:19:29 <Sindriav_> geekosaur: I just need to specify that the `a` in the Map and the `a` passed to the function are the same, no?
14:19:29 <Soviet_Jesus> like could I implement my mathematical logic textbook in haskell?
14:19:59 <Cale> Soviet_Jesus: Unfortunately (or fortunately for many other purposes) the logic which Haskell's type system represents is inconsistent, because Haskell allows general recursion
14:20:02 <levi> There's also a sense (which hiptobecubic referenced) in which a type is a proposition and a program inhabiting that type is a proof of the proposition. But all of those proofs in Haskell are a bit handwavey because the type system isn't really designed for it.
14:20:25 <Cale> Soviet_Jesus: but apart from this, you could mimic much of intuitionist and even classical logic
14:20:42 <geekosaur> Sindriav_, it's harder than that because then the map has a fixed type
14:20:54 <Cale> (imitating classical logic will be a bit funny though, the programs corresponding to proofs involving LEM will all have to be useless ones)
14:21:02 <Sindriav_> geekosaur: I seeâ¦
14:21:03 <geekosaur> which is why we need the forall; you would not be able to use the same map for different types
14:21:16 <Sindriav_> this is driving me nuts X_X
14:21:17 <geekosaur> (note that this type "infects" the outer Map
14:21:20 <geekosaur> )
14:21:21 <Cale> :t let fix f = x where x = f x in fix
14:21:23 <lambdabot> (t -> t) -> t
14:21:47 <Cale> This lets us prove t, given a proof that t implies t, which is troubling
14:21:52 <Cale> :t id
14:21:54 <lambdabot> a -> a
14:21:57 <Cale> :t let fix f = x where x = f x in fix id
14:21:59 <lambdabot> t
14:22:02 <Cale> ^^ proof of anything
14:22:27 <levi> Soviet_Jesus: The useful sort of Haskell proofs are the ones that we use to show that one expression means the same thing as another expression by applying a number of program-transformation steps and referencing the rules that justify those steps.
14:22:48 <Soviet_Jesus> ahhh
14:22:57 <Cale> Functional languages which are more intended for use as proof checkers, such as Agda and Coq, forbid unrestricted general recursion for this reason
14:23:10 <Sindriav_> geekosaur: hmâ¦ Maybe I should try a simpler example first? Like a list?
14:23:10 * hackagebot RSA 2.1.0.2 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  https://hackage.haskell.org/package/RSA-2.1.0.2 (AdamWick)
14:23:12 * hackagebot RSA 2.1.0.3 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  https://hackage.haskell.org/package/RSA-2.1.0.3 (AdamWick)
14:23:57 <Soviet_Jesus> I was just thinking back to chapter 1 of the book where you need to prove that a valid statement has to have a ) for each (
14:24:00 <Cale> and they get a lot of leverage out of the Curry-Howard correspondence -- you can encode essentially all of mathematics in those type systems
14:24:39 <levi> Soviet_Jesus: Even the program-transformation via algebraic manipulations sort of proofs in Haskell come with some caveats, but they're still generally useful.
14:25:02 <Cale> But yeah, I like to joke that functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in inconsistent intuitionist logics.
14:25:10 <Sindriav_> geekosaur: this exhibits the same problem on a much simpler example: http://lpaste.net/9047271192238489600
14:25:22 <bitemyapp> Cale: nb
14:25:39 <Soviet_Jesus> Cale: you just blew my mind a little
14:25:44 <hpc> occasionally the theorems are even correct!
14:26:53 <Cale> Once you care about the difference between proofs, the inconsistency of the logic is no longer quite as disastrous as it once was. You have something other than truth to worry about then.
14:27:14 <Cale> and we care about the difference between proofs: the distinction between values of the same type
14:27:23 <Cale> (proofs of the same theorem)
14:27:33 <Lokathor> style question, when writing a parser for a language that ignores unaccepted characters, should the parser itself just eat up unaccepted chars, or should it error and rely on the input already having been properly filtered?
14:28:07 <Alpha64> should error
14:28:33 <mauris> brainfuck?
14:28:37 <monochrom> what does "ignore" mean?
14:28:43 <Lokathor> mauris got it in one :3
14:28:46 <Alpha64> you can't assume that the user wanted to input things wrong
14:29:30 <Lokathor> brainfuck accepts any of ><+-.,[] with all other characters being "comment characters" that are ignored
14:29:39 <levi> Lokathor: Typically you have a separate lexical analysis phase that munches ignored characters and tokenizes things, but sometimes that duty is also performed by the parser.
14:29:40 <monochrom> my perspective: "ignore" cannot possibly mean "notice and loudly complain"
14:29:55 <mauris> maybe  data BrainfuckChar = LeftAngle | RightAngle | Plus | Minus | Comma | Period | OpenBracket | CloseBracket
14:30:04 <mauris> and write a  String -> [BrainfuckChar]
14:30:42 <Lokathor> i was going to make "loop" into one of the constructors that'd hold a sublist of what to loop, but something like that.
14:31:18 <mauris> well, yeah, your parser would go from [BrainfuckChar] to [BrainfuckCommand]
14:31:54 <mauris> which just maps LeftAngle to MoveLeft, RightAngle to MoveRight, Plus to Increment, ... and matching Bracket pairs to a Loop [BrainfuckCommand]
14:32:26 <mauris> i mean, this is a bit data type heavy. but it allows you to *guarantee* that you're only caring about 8 types of tokens and ignoring everything else, which is neat. it's just an idea!
14:32:35 <mauris> parsers don't *have* to work on Char
14:32:57 <mauris> (if you use Parsec at least)
14:32:58 <Soviet_Jesus> Well, thanks for all the advice all, I really appreciate it. I'm gonna go cry at sublimetext till either my functions suck less
14:33:08 <Lokathor> I wanted to use Parsec to arrange the parsing, because it's a small enough setup that you can use it as an example of how you might use Parsec
14:33:23 <Soviet_Jesus> -either, because there will only be crying
14:33:37 <Lokathor> Soviet_Jesus, :(
14:33:38 <hpc> in fact, traditional parsers such as the classic lex/yacc combo work on tokens (or yacc does, after lex is done)
14:33:56 <Lokathor> i've heard of lex and yacc, but never used them
14:34:18 <hpc> they show their age, we'll say
14:34:53 <Soviet_Jesus> Lokathor, nah its how I prefer things. I threaten the IRB console on a regular basis
14:35:23 <geekosaur> lex and yacc were all about fitting complex parsers into 64K PDP11 address spaces
14:35:40 <Sindriav_> geekosaur: I think I've got something! http://stackoverflow.com/questions/12774056/haskell-list-of-instances-of-a-typeclass
14:36:09 <Soviet_Jesus> in fact, I might just make a bunch of functions that lets me tell the GHCI off and have it take it like a bitch
14:36:43 <eitanChatav> Hi, does anyone know why I might be having this problem? I'm trying to use HDBC-ODBC to connect to a database and it seems to work in GHCi but the compiled program doesn't work; it fails to connect.
14:36:54 <sm> easy there Soviet_Jesus 
14:37:09 <geekosaur> can we keep the sexist bro-isms to wjerever it is you live where women aren't considered human beings?
14:37:13 <qmm> which should one use halcyon, and when should one use stack?
14:37:35 <mauris> geekosaur: amen
14:37:44 <qmm> i tried installing hoogle by doing `stack install hoogle`, but the `hoogle` command didn't seem to be available afterward
14:37:59 <qmm> also, how does those two projects relate?
14:38:09 <Sindriav_> eitanChatav: Maybe because you're using a relative path, and the compiled program isn't run in the same place as the repl?
14:38:11 <geekosaur> qmm, check ~/.local/bin (iirc)
14:38:18 <sm> qmm: add ~/.local/bin or windows equivalent to your PATH
14:38:41 <Soviet_Jesus> sorry, totally inappropriate 
14:38:51 <eitanChatav> Sindriav_: no relative paths in my program
14:39:21 <qmm> geekosaur: ty
14:39:30 <qmm> i just need to add ~/.local/bin to my path i suppose
14:39:48 <eitanChatav> here's the code: http://lpaste.net/140225
14:40:13 <mietek> qmm: both serve much of the same purpose. One is funded.
14:40:24 <joobus> he referred to a female dog.  Where were women brought into this (i.e. you made the assumption)?
14:40:35 <mietek> !ops
14:41:16 <Sindriav_> geekosaur: Maybe I need to use GADTs?
14:41:20 <qmm> mietek: interesting
14:41:36 <shachaf> Soviet_Jesus, joobus: Not funny or appropriate.
14:41:53 <joobus> never said it was either.
14:42:05 <geekosaur> eitanChatav, one difference between ghci and compiled is that ghci is always threaded, did you compile it with -threaded?
14:42:10 <Soviet_Jesus> joobus: nah, I really shouldn't have phrased it like that
14:42:35 <eitanChatav> geekosaur: no, I'll try that
14:42:52 <joobus> i just think it is fascinating some of you read that and automatically thought "women"
14:43:13 <hexagoxel> fascinating or not, completely off-topic
14:43:14 <geekosaur> joobus, perhaps you've heard of "idiom"?
14:43:24 <geekosaur> it's a well known and off topic idiom
14:43:29 <geekosaur> and unacceptable here
14:43:43 <eitanChatav> geekosaur: no luck :-(
14:44:04 <Soviet_Jesus> thanks for not insta banning me by the way, it really was a slip of the tongue
14:44:29 <geekosaur> another difference is some versions of ghci run things in a "sandbox" thread, but that is more likely to break things than fix them (mostly things that use thread local storage or otherwise rely on being the main thread, which most OSes treat specially)
14:44:48 <eitanChatav> i'm actually running in cabal repl if that makes a difference
14:44:56 <eitanChatav> in a sandbox
14:44:58 <geekosaur> oh. try cabal exec to run it?
14:45:25 <geekosaur> cabl exec -- yourprogram whateverArgsHere
14:45:30 <geekosaur> *cabal
14:45:46 <levi> ReinH: More about Backus: http://horningtales.blogspot.com/2007/04/john-backus-1924-2007.html
14:45:48 <geekosaur> although that "shouldn't" affect antyhing if it starts up at all...
14:46:25 <geekosaur> (also, I hope that test line of yours does not mean that $DYLD_LIBRARY_PATH is being set somewhere --- that is a recipe for trouble)
14:46:38 <programo> Can we build a client - server , web chat application in haskell?
14:48:19 <zipper>  I have a function say f that calls/takes a function x of type String -> IO () internally severally. Now what I want to do is make it so that everytime x is called by x it should be appended to what already exists on the browser.
14:48:48 <eitanChatav> geekosaur: I'm not setting DY_LIBRARY_PATH in the program...just printed it to verify it was correct. `cabal exec odbc-test` and other modifications of that are giving me cabal: The program 'odbc-test' is required but it could not be found.
14:49:10 <zipper> So basically instead of printing continuously to terminal by repeatedly calling print. I want to stream this to the browser.
14:49:44 <zipper> With websockets. I don't see how I can continiously call the function of type `String -> IO ()
14:49:47 <geekosaur> hrm, old version of cabal-install then?
14:49:57 <eitanChatav> could it be something weird with HDBC-ODBC specifically?
14:49:58 <mietek> @quote faq
14:49:58 <lambdabot> elliott says: "with a lot of unicode" is like agda's @faq. "yes, agda can do that with a lot of unicode!"
14:50:00 <mietek> @quote faq
14:50:00 <lambdabot> cmccann says: @faq is it possible to find things Haskell can't do?  <lambdabot> The answer is: Yes! Haskell can do that.
14:50:24 <mietek> Who broke lambdabotâs @faq command?
14:51:01 <eitanChatav> geekosaur: cabal-install version 1.22.6.0
14:51:09 <geekosaur> (although I am getting "cabal: unrecognized command: exec" with the old cabal on my OS X install, not that "is required" thing)
14:51:27 <eitanChatav> I don't think it's a sandbox thing
14:51:41 <eitanChatav> it's a simple 1-module program with almost no dependencies
14:51:45 <geekosaur> mietek, it changed several lambdabot revisions ago
14:51:53 <mietek> :(
14:52:57 <geekosaur> eitanChatav, I think I'm at the end of my troubleshooting ability here :/ I'd probably be hauling out dtruss at this point to try to see how it differs in each run (although dtruss is annoyingly limited in my experience)
14:54:07 <eitanChatav> geekosaur: Thanks for your help!
14:54:48 <Soviet_Jesus> so, if I wanted to do something that evaluates english, would this be on the right track? (it may be trash, but is it at least useful trash?) http://lpaste.net/140224
14:55:18 <geekosaur> NLP is a Hard Problem in any language
14:55:52 <geekosaur> (and for any language, for that matter)
14:56:59 <sebastianrkg> is it possible to compile an executable that contains HUnit tests such that it outputs such test results as XML each time the executable is run?
14:57:29 <Soviet_Jesus> the professor used lisp if i recall correctly to demonstrate some stuff, and the way haskell applies functions I figure I might be able to at least get a "John likes Mary who hates Jane" to evaluate sensibly 
14:58:26 <sebastianrkg> I can obviously output to XML with regards to a .cabal file and all the source code, using something like "cabal run -j8 test -- --xml=test-results.xml"
14:58:53 <sebastianrkg> But can I do the same thing to compiled code, or compile it such that it always does this?
15:01:24 <Soviet_Jesus> so reading this tutorial, if I'm on windows, I should prepare to have a lot of heartache?
15:04:56 <Sindriav_> geekosaur: Hey, doesn't Data.Dynamic do exactly what I want? :D
15:06:22 <geekosaur> this is actually a variant on Dynamic. the problem with just using that, I think, is it's too general. here you *have* the type information, we just have to figure out how to get it to the right place
15:06:57 <Sindriav_> geekosaur: Well, I still store the type information, it's the key to the first Map
15:06:58 <Cale> Sindriav_: If what you want is a mildly disappointing compromise which sacrifices both clarity and generality...
15:07:17 <Sindriav_> Cale: What I want is constructive criticism, which this was not.
15:07:21 <Cale> sorry :)
15:07:53 <qmm> is there a command for stack to install the latest version of a dependency and to put it within build-depends of the executable?
15:08:12 <Cale> Dynamic is kind of frustrating though. It's okay, it's just you're restricted to instances of Typeable in many use cases where you'd hope to be able to use any type at all
15:08:28 <Cale> and it induces a lot of syntactic noise in your programs
15:08:32 <qmm> this community in this irc channel is amazing!
15:08:46 <Sindriav_> qmm + 1
15:08:52 <Sindriav_> geekosaur: Hmâ¦ I mean, I know which type I want to get, right?
15:09:02 <geekosaur> yes
15:09:14 <Sindriav_> geekosaur: What good is then storing it twice (kinda) ?
15:09:28 <geekosaur> we just have to get it to inside the inner Map without having it force its type on the entirety of both Maps
15:09:41 <geekosaur> which is what the forall is about --- we need to encapsulate it
15:09:45 <Sindriav_> Ah, I seeâ¦
15:09:56 <Sindriav_> So create a separate data type for the inner Map?
15:15:25 <Sindriav_> Cale: Sorry, now that I read it after myself, I might have come off more harsh than I wanted to
15:16:14 <Sindriav_> Cale: In my particular case, Dynamic introduces barely any clutter at all, since it'd be all nicely hidden inside the implementation
15:16:26 <Sindriav_> Cale: e.g. invisible to the user
15:16:33 <geekosaur> I think you still have the problem that the inner Map has to have a consistent type, and the outer Map has to incorporate that type
15:17:31 <geekosaur> Cale: Sindriav_ is trying to reproduce something like xmonad's ExtensibleState, which is more or less a Map with TypeRep keys to values with that TypeRep
15:17:45 <Sindriav_> geekosaur: Maybe this could be it? https://wiki.haskell.org/Heterogenous_collections#Existential_types
15:17:57 <geekosaur> but xmonad doesn;t just declare that, it's got some extra stuff around it because some of those keys can be tagged persistent (serialized across invocations)
15:20:04 <shachaf> It isn't confusing to say that (() :: exists a. a) and (1 :: exists a. a) are equal, right?
15:20:18 <geekosaur> aaaand I just realized the ExtensibleState typeclass is part of how xmonad makes that work. (sorry I am still not braining very well...)
15:20:56 <monochrom> shachaf: why are they equal?
15:21:10 <shachaf> Because they're indistinguishable.
15:21:39 <shachaf> The type (exists a. a) has only one (non-_|_) inhabitant, and they are both that inhabitant.
15:21:48 <monochrom> interesting
15:21:56 <shachaf> What about foo, bar :: forall r. (forall a. a -> r) -> r; foo k = k (); bar k = k 1?
15:22:01 <shachaf> I would also say that foo and bar are equal.
15:22:19 <geekosaur> also xmonad actually uses a String (from show on the TypeRep) as the key, so we odn't actually have the key and value having coordinated types --- this may well be important
15:22:43 <geekosaur> (gr, sinus pressure please let up so I can think properly, I used to know how this worked :/ )
15:23:29 <Cale> You might be looking for http://hackage.haskell.org/package/dependent-map-0.2.0.1/docs/Data-Dependent-Map.html
15:24:46 <shachaf> Why is that dependent?
15:25:07 <shachaf> It looks like only types depending on types.
15:25:15 <Cale> shachaf: In the sense that the type of the value depends on the type of the key
15:25:20 <Sindriav_> geekosaur: I think I've solved it!
15:26:04 <Soviet_Jesus> the beginner channel is all sad and inactive, this question should take like 2 seconds: This is not how pattern matching works, is it? http://lpaste.net/140229
15:26:12 <Sindriav_> geekosaur: http://lpaste.net/8401868213310193664 ?
15:26:25 <Cale> shachaf: You might have many differently typed values in the same map, indexed by differently typed keys.
15:26:27 <Sindriav_> Soviet_Jesus: no
15:26:36 <Sindriav_> Soviet_Jesus: foo x | x < 1 = â¦
15:26:41 <shachaf> Soviet_Jesus: #haskell is the beginner channel of #haskell.
15:27:01 <shachaf> Soviet_Jesus: The answer is no. You can write what Sindriav_ said if you want.
15:27:03 <geekosaur> #haskell-beginners is more like a channel for group study of cis194
15:27:12 <geekosaur> or similar
15:27:19 <Cale> yeah
15:27:21 <geekosaur> not really a beginner questions channel
15:27:32 <Cale> I really wish that #haskell-beginners could be renamed :S
15:27:40 <Soviet_Jesus> fair enough. and tbh my question is for CIS194
15:27:52 <shachaf> It's more like a channel of a certain individual.
15:28:08 <monochrom> I don't like "this question should take like 2 seconds"
15:28:17 <Cale> Its inappropriately general name gives the wrong impression about #haskell
15:28:33 <Soviet_Jesus> sorry monochrom
15:28:37 <shachaf> I agree.
15:28:38 <sm> Cale, what would you call it ?
15:29:20 <geekosaur> you can write something vaguely like the original question with a view pattern, I think, but it's not really the idiomatic way to do it. toDigits 0 = []; toDigits x | x < 0 = [] | otherwise = ...
15:38:40 <bss03> I am having problems getting vim to spellcheck comments in Haskell code.
15:38:58 <bss03> I am using the master branch of vim-haskell via pathogen.
15:39:33 <bss03> I added some @Spell / @NoSpell annotations, but they don't seem to be working.
15:40:04 <bss03> Hints?
15:43:27 <dmwit> Is there some standard wrapper type that conceptually gives instance (Applicative f, Monoid m) => Monoid (f m)?
15:44:13 <quchen> I don't think so, because Gabriel Gonzalez keeps bringing up how he misses that one :-)
15:44:50 <bss03> dmwit: Last time I checked there wasn't one.  I think I put one in a reddit comment, then, though. ;)
15:45:06 <dmwit> ok =(
15:45:27 <mauris> https://github.com/ekmett/monoids/blob/master/Data/Monoid/Applicative.hs#L75 ?
15:45:47 <dmwit> mauris: WFM, thanks!
15:46:43 <dmwit> ack, that package is deprecated in favor of a package that doesn't provide a type with a Monoid instance (only Semigroup)
15:46:45 <mauris> oh, it's Ap now http://hackage.haskell.org/package/reducers-3.11/docs/Data-Semigroup-Applicative.html
15:47:05 <mauris> it still seems to provide (Applicative f, Monoid m) => Monoid (Ap f m) 
15:47:39 <dmwit> Wow, what is the relationship between D.S.Applicative and D.S.Apply?
15:47:45 <dmwit> Check how similar they are!
15:48:22 <shachaf> Apply doesn't have pure.
15:48:45 <shachaf> Ap is a pretty fancy type.
15:48:54 <dmwit> Ah, I see.
15:49:07 <dmwit> Yeah, okay, I get it. That is pretty sneaky.
15:49:32 <dmwit> thanks to all
15:50:04 <Sindriav_> geekosaur: Can I get the TypeRep of a data type without making a value from it?
15:50:20 <shachaf> Viewing [()] as the type of (co)natural numbers, the monoid instance for [] () gives you addition, Ap [] () gives you multiplication, and Ap ZipList () gives you minimum.
15:50:25 <shachaf> (With infinity as the unit.)
15:51:06 <mauris> what is the canonical example of a semigroup-but-not-a-monoid?
15:51:12 <shachaf> Nonempty lists.
15:51:15 <geekosaur> undefined :: SomeType?
15:51:33 <Sindriav_> geekosaur: Good point.
15:51:49 <Sindriav_> geekosaur: But that's still a value, kinda. I'll probably use TH for that bit
15:51:57 <dmwit> canonical in a very strong sense -- they're the free semigroup
15:52:03 <shachaf> Yes.
15:52:06 <geekosaur> I think there's also Proxy :: Proxy Type
15:52:14 <shachaf> That trick usually works.
15:52:15 <Sindriav_> geekosaur: So I can do `get entity Color`
15:52:20 <Sindriav_> geekosaur: I'll look into proxy
15:52:27 <shachaf> But not always -- I wouldn't say the discrete topology is a very good canonical example.
15:52:32 <mauris> sgtm. i was thinking strings under (\x y -> x ++ "-" ++ y)
15:53:02 <shachaf> There are lots of examples.
15:53:09 <qmm> how are sessions typically created and fetched later? is there a document that would help me with this?
15:53:12 <shachaf> Void, for instance.
15:53:14 <mauris> yes, semigroups "easier than monoids"
15:53:42 <mauris> i remember "instance Monoid Void" being controversial
15:53:54 <shachaf> It had better be. There's no mempty.
15:54:01 <dmwit> shachaf: The discrete topology is a pretty good canonical example if you want "the topology that isn't X".
15:54:19 <Sindriav_> geekosaur: But I think that TH will enable me to write the type name directly, which would be nicer
15:54:31 <mauris> because "absurd" is a valid "mempty" for all values in Void (vacuously)
15:54:32 <qmm> idea of maybe how you get/set sessions:  server generates priv/pub key pair, server sends pub keypair to user, user sends the server the pub keypair anytime it wants to initiate a session with the server?
15:54:42 <mauris> i don't buy it, though
15:54:43 <shachaf> dmwit: i,i http://catseye.tc/node/Book
15:54:57 <shachaf> dmwit: Well, specifically "counterexamples in topology" on that page.
15:55:10 <shachaf> absurd doesn't even type-check.
15:55:41 <geekosaur> in theory it is also possible to build a TypeRep. in practice I think this is forbidden because what made it possible also made deriving unsafeCoerce possible
15:56:05 <dmwit> shachaf: sounds fun
15:56:34 <shachaf> dmwit: Anyway the discrete topology doesn't seem to me that it gives you a very good intuition for topologies in general.
15:56:38 <Sindriav_> geekosaur: I see
15:56:41 <mauris> err, not absurd, undefined
15:56:44 <shachaf> dmwit: Which is what I would hope to get from free structures.
15:56:51 <shachaf> mauris: That is scow.
15:57:19 <mauris> like the boat?
15:57:26 <shachaf> Yep, that bad.
15:57:48 <shachaf> If you accept undefined :: Void, then Void isn't uninhabited anymore.
15:57:58 <shachaf> In which case you're just talking about the Monoid instance for ()
15:58:20 <mauris> yeah, it's very fishy to me, too
15:59:41 <Sindriav_> geekosaur: This seems to work reasonably well :) http://lpaste.net/9137368971769544704
16:24:46 <ReinH> shachaf: speaking of the Devil's Dictionary, which is listed on that books page, I found one for CS called "The Computer Contradictionary" at a used bookstore here in Vancouver.
16:25:04 <ReinH> shachaf: It includes, e.g., curry v. trans: see Schoenfinkel
16:33:17 * hackagebot validate-input 0.3.0.0 - Input validation combinator library  https://hackage.haskell.org/package/validate-input-0.3.0.0 (AlexanderThiemann)
16:35:31 <Shockk> hello, I've written a typeclass that I'm finding quite useful in my code and it's surprising to me that such a typeclass doesn't exist in Haskell's standard library, so I wanted to ask if anything similar to it *does* exist?
16:35:34 <Shockk> the typeclass: https://github.com/shockkolate/polar4/blob/master/src/Data/Truthful.hs
16:35:45 <Denommus> why don't we have a database layer based on MonadPlus, like LINQ?
16:37:13 <Shockk> the reason I wrote the typeclass was so that I have a common function to determine if a value that might or might not have an inner value, has that inner value or not
16:37:44 <Shockk> or in the case of the instance for Bool in that link there, the result is simply the bool itself
16:39:13 <myfreeweb> Shockk: in ClassyPrelude: null :: MonoFoldable c => c -> Bool
16:40:06 <myfreeweb> (in mono-traversable actually)
16:42:44 <mauris> that stuff is in Prelude now, isn't it
16:42:48 <mauris> :t null
16:42:50 <lambdabot> Foldable t => t a -> Bool
16:42:50 <mauris> > [null (Just 3), null Nothing, null (Right 5), null (Left 4)]
16:42:53 <lambdabot>  [False,True,False,True]
16:43:13 <Shockk> hmmm
16:43:40 <shachaf> Traversable is a much better class than MonoTraversable, which probably shouldn't exist.
16:43:41 <Shockk> ooh
16:43:47 <shachaf> Well, it doesn't really exist. In base, at least.
16:44:04 <Shockk> mauris: that's basically what I was looking for
16:44:13 <arkeet> shachaf: what about Each?
16:44:26 <mauris> i mean, it doesn't do your Bool instance, but that instance is quite different from the others anyway
16:44:43 <arkeet> :t nullOf each
16:44:45 <lambdabot> Each s s b b => s -> Bool
16:44:45 <Shockk> hmm, true
16:44:45 <shachaf> arkeet: Better.
16:44:54 <Shockk> is a bool even considered something that can be folded?
16:44:56 <shachaf> arkeet: At least all the lens operators are reasonable. Each is just one class.
16:45:30 <mauris> Shockk: not really. but a Maybe () is, and it's basically the same thing
16:45:59 <Shockk> that's true
16:46:02 <mniip> :t bool
16:46:03 <lambdabot> a -> a -> Bool -> a
16:46:04 <Shockk> that's True *
16:46:21 <mauris> (i.e. the only values are Just () and Nothing, which fold like [()] and [])
16:46:26 <mniip> fold over Bool ^
16:46:49 <mauris> mniip: what are those functions called again?
16:46:52 <mauris> :t (maybe, either)
16:46:54 <lambdabot> (b -> (a -> b) -> Maybe a -> b, (a1 -> c) -> (b1 -> c) -> Either a1 b1 -> c)
16:46:59 <arkeet> catamorphisms?
16:47:00 <shachaf> mauris: Folds.
16:47:11 <arkeet> :t foldr
16:47:13 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
16:47:16 <shachaf> "catamorphism" is a fancy word for people who are too good for the word "fold".
16:47:22 <arkeet> it's more googleable.
16:47:32 <mauris> maybe they like cats?
16:47:47 <Shockk> I notice sum and product are in Foldable but are constrained by Num a 
16:48:20 <mniip> because their monoids behave that way
16:48:25 <Shockk> I'm assuming that only restricts sum and product and not the whole typeclass
16:48:43 <Shockk> only constrains*
16:48:52 <mniip> or you mean Prelude.sum
16:49:01 <arkeet> no, Data.Monoid.Sum
16:49:04 <arkeet> > Sum 1 <> Sum 2
16:49:06 <lambdabot>  Sum {getSum = 3}
16:49:25 <arkeet> wait
16:49:29 <arkeet> never mind.
16:49:37 <arkeet> you mean sum from Data.Foldable.
16:49:40 <arkeet> well sure.
16:50:50 <Shockk> right now I'm trying to decide whether to switch to using null from Foldable and write an instance for Bool, or keep that Truthful typeclass I wrote
16:51:23 <arkeet> what instance?
16:52:10 <Shockk> arkeet: of Foldable
16:52:22 <arkeet> that has the wrong kind.
16:52:26 <arkeet> :k Foldable
16:52:28 <lambdabot> (* -> *) -> Constraint
16:52:29 <arkeet> :k Bool
16:52:31 <lambdabot> *
16:52:31 <Shockk> ohhh * -> *
16:52:33 <Shockk> right
16:52:35 <mniip> Shockk,  your nickname seems familiar
16:52:47 <Shockk> it does?
16:52:53 <mniip> somewhat
16:53:03 <Shockk> from here or elsewhere?
16:53:10 <mniip> either
16:53:18 * hackagebot TypeNat 0.4.0.1 - Some Nat-indexed types for GHC  https://hackage.haskell.org/package/TypeNat-0.4.0.1 (alexvieth)
16:53:34 <Shockk> I have no idea, I get around a bit on irc
16:53:38 <beatboxchad> yo. Who's at ICFP?
16:55:31 <mniip> Shockk, I remember now
16:55:47 <Shockk> oh?
16:56:20 <mniip> I remembered your nickname from when I downloaded the entire keybase tracking graph
16:56:32 <Shockk> ..
16:56:34 <mniip> you're 1 or 2 nodes away from me
16:56:46 <Shockk> ah lol
16:58:36 <mniip> mniip -> blackl -> ariscop -> shockk
16:58:45 <mniip> the internet is a tiny place
16:58:50 <Shockk> is a small i- yes
16:58:53 <mniip> also <3 graphs
17:00:21 <mniip> oh by the way
17:00:55 <mniip> is there a package for efficient transitivity reduction
17:01:02 <Shockk> hmm well I may stick with my Truthful class in that case if Foldable is * -> *; actually that makes sense now because of the constraints on some of the functions in the class
17:02:08 <mniip> I've got 27k nodes, 125k edges
17:02:35 <mniip> tred from graphviz has been running for 1200 hours now
17:03:57 <mniip> I heard transitivity reduction reduces to matrix multiplication?
17:04:43 <Sindriav_> What is the GHC stage restriction and how do I fix it?
17:06:25 <glguy> Sindriav_: It should tell you what isn't allowed in the error message
17:07:05 <Sindriav_> glguy: Yeah, I'll paste it, gimme a sec
17:07:49 <Sindriav_> http://lpaste.net/1966903285637971968
17:08:19 <Sindriav_> How can I import a function parameter? O.o
17:08:33 <glguy> You pass the function parameter in as a splice
17:08:53 <glguy> has x [| Stuff |]
17:09:09 <glguy> err, a quotation
17:09:56 <Sindriav_> ohâ¦
17:10:08 <Sindriav_> So `has e [| n |] = [|d â¦ |] ?
17:10:34 <Sindriav_> That doesn't seem right
17:11:33 <Sindriav_> I'm going off of https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md
17:12:30 <glguy> [d|...|] quotes a declaration and probably isn't what you need there
17:12:34 <glguy> What are you trying to do?
17:13:32 <glguy> has e n = [d| return . isJust =<< get e $(conT n) |]
17:13:38 <glguy> err, didn't mean to press enter
17:13:53 <glguy> has e n = return . isJust =<< get e $(conT n)
17:14:04 <Sindriav_> Yeah
17:14:15 <Sindriav_> I want n to be in the form of ` ''Type `
17:14:24 <Sindriav_> and to be passed to get as a value (undefined :: Type)
17:15:00 <Sindriav_> e.g. something like ` has e n = return . isJust =<< get e (undefined :: $(conT n)) ` ?
17:15:54 <Sindriav_> ` has e n = return . isJust =<< get e (typeOf $ undefined :: $(conT n)) ` even
17:18:06 <glguy> You can't do that, but you could have something like: generateHas e n = [| return . isJust =<< get e (typeOf $ undefined :: $(conT n)) |]
17:18:15 <glguy> and then use generateHas in another module
17:18:31 <glguy> hasInt x = $(generateHas x ''Int)
17:19:57 <Sindriav_> I see
17:20:12 <glguy> You can't generate Haskell syntax based on runtime values
17:20:20 <glguy> this is where the staging restriction comes in
17:20:37 <glguy> All the syntax has to be generated before compilation is finished
17:26:46 <Sindriav_> glguy: Hmâ¦ And could I somehow do " e `has` ''Color ?
17:27:46 <Sindriav_> Or even " e `has` Color "
17:28:20 * hackagebot Concurrential 0.5.0.1 - Mix concurrent and sequential computation  https://hackage.haskell.org/package/Concurrential-0.5.0.1 (alexvieth)
17:50:23 <Sindriav_> Or *even better*, can I get the TypeRep of a function's return value?
17:50:33 <Sindriav_> the final one, that is
17:52:13 <Cale> Sindriav_: which one is the final one? ;)
17:53:07 <Cale> Sindriav_: you can probably splitTyConApp a bunch
17:54:30 <hiptobecubic> Is it possible to tell stack to ignore upper bounds on an extra-deps package?
17:55:24 <hiptobecubic> I tried flags: {hsqml: {allow-newer: true}}, but it doesn't seem to work
17:56:04 <hiptobecubic> I wonder if these are flags about the package itself and not really useful otherwise?
17:57:06 <Sindriav_> Cale: Oh yeah, I can just repeat splitTyConApp, until it's []!
17:57:07 <Sindriav_> Thanks
17:57:50 <glguy_> Sindriav_: it might be worth explaining what you're actually doing if you want to see if there's a better way to solve the problem
18:00:37 <Sindriav_> glguy_: Storing arbitrary data in a map
18:00:54 <Sindriav_> glguy: And I want to query for it using constructors
18:02:43 <Sindriav_> `a -> b -> c -> d -> X` recursed with splitTyConApp results in X
18:02:59 <hiptobecubic> I guess you can get around it by having a local copy, fiddling with the deps yourself, and then setting it as a package in stack.yaml with extra-dep: true, but it's a bit cumbersome and exactly why --allow-newer was added to cabal-install.
18:03:03 <Sindriav_> so I can do ` e `has` Color ` and let it sort it out itself
18:06:27 <glguy> Sindriav_: Instead of manipulating typereps you could do something like this:
18:06:30 <glguy> has e p = fmap isJust (get e (typeOf1 p))
18:06:35 <glguy> example use: has x (Proxy :: Proxy Int)
18:08:03 <Sindriav_> hmâ¦
18:08:37 <Sindriav_> That still doesn't let me write it nicely
18:09:00 <glguy> oops, typeOf1 was the wrong one but there's one that does work in that place
18:09:07 <Sindriav_> yeah
18:10:48 <glguy> has e p = fmap isJust (get e (typeRep p))
18:10:57 <Sindriav_> but doing the typerep manip will literally allow me to do ` e `has` Constructor `
18:12:47 <glguy> ok
18:15:25 <sm> so, I'm using the GHCI debugger, in iterm2 on osx. After a little stepping, it gets into a mode where keypresses don't register unless I press the each key twice. Is this a known thing ?
18:16:19 <Arahael> sm: Try in terminal, then.
18:16:24 <kristof> Can someone explain to me the difference between associated types and type families?
18:16:31 <Arahael> sm: Don't give people the opportunity to blame iterm2. ;)
18:16:38 <kristof> And also, I'm having trouble seeing how "open type families are not modular", for those that get the reference.
18:17:09 <sm> good idea.
18:18:09 <sm> yes it happens in terminal too
18:18:39 <Arahael> sm: Is it a particular key sequence?
18:18:50 <sm> no, it seems to affect all keys
18:18:57 <Arahael> sm: I don't know how to do debugging in ghci as yet, just doing regular troubleshooting.
18:19:02 <sm> after about four :stepmodules
18:19:41 <sm> I'm sick of printf debugging and guesswork, it's time to try the debugger again
18:19:58 <Arahael> Not unit tests?
18:20:02 <sm> no
18:20:09 <Arahael> You really should do unit tests.
18:20:20 <Arahael> manual testing is...  Manual, and you can't reproduce it.
18:20:34 <acowley> Anyone know how to get a {-# ... #-} bit of text to be rendered as a source block by haddock?
18:20:55 <acowley> The closest I've come is this:
18:20:57 <sm> I'd love to look over your shoulder and see how you would debug this problem with unit tests
18:20:58 <acowley> @
18:20:58 <acowley>              {\-\# OPTIONS_GHC -cpp -pgmPhpp -optP\-\-cpp \#\-}
18:20:58 <acowley>              @
18:21:08 <acowley> But the braces get left out of the rendered output
18:22:45 <Arahael> sm: I admit I usually don't work with Haskell (I only learn it out of interest...), but at work I use TDD.  If a function isn't behaving, I'd make sure I have a failing test that is demonstrating the issue.
18:23:58 * geekosaur thinks it sounds like multiple things are reading from the terminal...
18:24:13 <sm> I don't think it's practical in this case, certainly not as efficient as debugging would be
18:24:15 * Arahael agrees that would make sense.
18:24:29 <Arahael> sm: I've never come across a case where that's true.
18:25:06 <Arahael> Well, that's a particularly bold claim - there's a few cases where that's true - scripting windows installer, for instance.
18:25:22 <acowley> Dang, it seems like this is yet another way for haddock to disappoint. http://stackoverflow.com/questions/3596399/in-cabal-for-haddock-documentation-in-haskell
18:26:20 <Arahael> sm: Put it another way: If you can't test it, how do you know it's working?
18:26:33 <ReinH> acowley: o/
18:26:45 <acowley> ReinH: Hola!
18:26:51 <sm> I'm not sure if this is something local or a known issue and just no-one ever uses ghci debugger
18:26:57 <ReinH> acowley: wish you were here
18:27:04 <acowley> ReinH: Don't tell me that
18:27:14 <acowley> ReinH: It still burns me up that I'm not!
18:27:24 <ReinH> :(
18:27:24 <acowley> ReinH: I had travel budget if my paper got accepted, but it didn't
18:27:34 <Arahael> sm: It may depend on the code you're debugging.
18:27:42 <ReinH> sad day
18:27:50 <acowley> ReinH: Extremely!
18:28:15 <acowley> ReinH: I have to make various robots do various things at high speeds as penance for the lab
18:29:22 <ReinH> hah
18:33:24 * hackagebot stack 0.1.4.0 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-0.1.4.0 (borsboom)
18:34:00 <Sindriav_> glguy: Proof of concept is here! http://lpaste.net/3420236818929418240
18:36:48 <Sindriav_> glguy: As you can see, the TypeRep hackery simplifies the code quite a bit
18:37:12 <Sindriav_> glguy: Except for sum types, which I'm not sure about
18:37:40 <Sindriav_> If an entity has X from ` data Foo = X | Y `, does it also have Y? That's sketchy.
18:38:24 * hackagebot hpp 0.1.0.0 - A Haskell pre-processor  https://hackage.haskell.org/package/hpp-0.1.0.0 (AnthonyCowley)
18:38:26 * hackagebot GLUtil 0.8.7 - Miscellaneous OpenGL utilities.  https://hackage.haskell.org/package/GLUtil-0.8.7 (AnthonyCowley)
18:39:01 <Sindriav_> I'm under the impression this would work so much better in Lispâ¦
18:39:58 <slack1256> no, they have either an X or an Y
18:40:28 <slack1256> > :t Right 5 :: Either String Int
18:40:30 <lambdabot>  <hint>:1:1: parse error on input â:â
18:40:36 <slack1256> > :t Right 5 
18:40:38 <lambdabot>  <hint>:1:1: parse error on input â:â
18:40:51 <slack1256> @type (Right 5) 
18:40:53 <lambdabot> Num b => Either a b
18:41:23 <glguy_> You don't need > when using :t
18:41:29 <acowley> I figured it makes sense for me to be the first to take a dependency on hpp
18:41:56 <acowley> I'd definitely appreciate it if anyone else kicks the tires on it. After a few success stories, we can try to get it into GHC so CPP can run in-process.
18:42:34 <Sindriav_> slack1256: You might want some context with that.
18:42:45 <Sindriav_> glguy_: What do you think?
18:43:49 <Sindriav_> glguy_: I guess it's fine to just return whichever gets stored and make the user match them.
18:44:05 <slack1256> Sindriav_: Yep, context is king. Go on
18:45:12 <Sindriav_> slack1256: I'm storing that stuff in a heterogenous map.
18:45:32 <Sindriav_> Yeah, I'll just leave it to the user to mathc
18:45:49 <Sindriav_> I don't want to bend the type system even more
18:45:57 <slack1256> Sindriav_: I'll read the start of the discussion, don't worry about filling me in
18:46:28 <Sindriav_> slack1256: If you read my last paste, you'll be pretty much filled in :)
18:52:33 <sm> acowley: nice
18:57:48 <sm> hmm, GHCI needs some love: https://ghc.haskell.org/trac/ghc/query?status=!closed&component=GHCi&desc=1&order=id
19:13:23 <sshine> isn't there a 'Monad m => m Bool -> m a -> m a' similar to Control.Monad.when, but where I don't have to 'do { b <- foo; when b action }'?
19:16:22 <sshine> @pl do { b <- f; when b g }
19:16:22 <lambdabot> (line 1, column 4):
19:16:22 <lambdabot> unexpected '{'
19:16:22 <lambdabot> expecting variable, "(", operator or end of input
19:17:09 <glguy_> Sshine: not in base but people have defined such a thing in other libraries before
19:17:22 <benzrf> what do destructuring let-exprs look like in core
19:18:26 * hackagebot yesod-static-angular 0.1.7 - Yesod generators for embedding AngularJs code into yesod-static at compile time  https://hackage.haskell.org/package/yesod-static-angular-0.1.7 (JohnLenz)
19:18:32 <mauris> https://hackage.haskell.org/package/IfElse-0.85/docs/Control-Monad-IfElse.html seems to have `whenM`?
19:18:50 <mauris> sshine: ^
19:19:14 <c_wraith> :t traverse_
19:19:16 <lambdabot> (Applicative f, Foldable t) => (a -> f b) -> t a -> f ()
19:19:22 <c_wraith> looks like whenM to me
19:19:43 <c_wraith> ... If you squint a lot. :)
19:21:11 <sshine> mauris, thanks!
19:25:21 <Sindriav_> sshine: What about "f >>= flip when g" ?
19:28:42 <Xe> Lemmih: here?
19:30:36 <Alpha64> is there a way to make a pattern match like (x:xs:xss) but x is "greedy" so that xs and xss are the last elements of the list ?
19:35:58 <sm> Alpha64: I don't think so
19:36:27 <glguy_> No. There are some ways to kind of simulate it with extensions but they won't look quite like that
19:36:35 <sm> well, you can add a guard
19:36:56 <sm> we try to avoid checking last elements
19:39:09 <sm>    xs | take 2 (reverse xs) == [last,secondlast] = ...
19:39:14 <sm> don't do that :)
19:39:19 <sshine> Sindriav_, thanks.
19:40:17 <sshine> I wonder if this exists...
19:40:23 <sshine> @undo do { b <- f; when b g }
19:40:24 <lambdabot> f >>= \ b -> when b g
19:40:51 <sshine> @pl \ b -> when b g
19:40:51 <lambdabot> flip when g
19:40:57 <sshine> Sindriav_ :-P
19:41:02 <Alpha64> sm so how would an idiomatic butlast look like ?
19:41:17 <Sindriav_> Neat
19:41:47 <glguy_> > init "xyz"
19:41:49 <lambdabot>  "xy"
19:41:54 <sm> Alpha64: secondlast = last . init
19:42:46 <Alpha64> oh i see
19:45:08 <Sindriav_> Alpha64: Careful though, operating on the end of a list is expensive
19:45:50 <sm> I'm beginning to think my GHCI double keypress problem is due to importing Vty
19:46:16 <sm> I thought it would be harmless since I'm not calling any Vty code
19:47:11 <Alpha64> what do you mean by operating Sindriav_ ? accessing or modifications ?
19:47:54 <Sindriav_> Alpha64: Both, but for what it's worth, modifications are "impossible" in Haskell
19:48:43 <Sindriav_> Alpha64: Haskell's [a] is a linked-list, so to access an element on the end, you have to do O(n) operations where n is the length of the list
19:56:49 <mauris> interesting follow-up: what would an idiomatic nthFromLast look like?
19:57:28 <mauris> i suppose reverse and then !! is good enough. but i think that's still more traversals of the list than you really need
20:03:22 <kristof> Is it possible to make a typeclass C be an instance of another typeclass D?
20:03:36 <kristof> Or does that not interact well with coherence?
20:03:51 <mauris> kristof: you mean something like  instance C a => D a where ...  ?
20:04:45 <benzrf> no, clearly kristof means something of kind (k -> Constraint) -> Constraint
20:04:59 <mauris> (when people say stuff like "make a typeclass an instance of a typeclass" i always wonder if they've mixed something up, or if they're talking -- about something magical like that, yes)
20:06:44 <kristof> mauris: Nope. More like instance D C
20:07:15 <benzrf> haha i was right
20:07:16 <kristof> ...actually, yes
20:07:20 <benzrf> tbh i was joking when i said that
20:07:24 <kristof> I do m ean instance C a => D a
20:07:28 <benzrf> oh lol
20:08:00 <kristof> Where for some trait C, to implement D I don't actually need any specific functions over a concrete C a => a, I actually just need methods from the typeclass C
20:08:23 <kristof> Because the way I would currently do it is make an instance of D for EVERY instance of C that I can imagine, and simply call the same functions over again
20:08:32 <kristof> And then I would resort to metaprogramming but there's something more abstract going on here
20:08:43 <benzrf> @let class HasConstant c where constant :: c a => a
20:08:43 <lambdabot>  Parse failed: Illegal class assertion
20:08:44 <geekosaur> you can provide default implementations
20:08:46 <benzrf> whaaaaaaaaaaa
20:09:01 <benzrf> @let class HasConstant (c :: * -> Constraint) where constant :: c a => a
20:09:01 <lambdabot>  Parse failed: Illegal class assertion
20:09:05 <kristof> geekosaur: In which class?
20:09:05 <benzrf> what the heck
20:09:40 <geekosaur> I think I misunderstood what you were talking about, sorry
20:10:07 <geekosaur> in any case I'd like to see a little more detail of what you are doing, because in general "instance C a => D a" is problematic
20:10:33 <geekosaur> because it really declares the instance for every possible a, and only checks the "superclass" on use
20:10:50 <kristof> geekosaur: Something concrete. I've got a concerete type Concrete, and a trait Super. Concrete has an obvious implementation of Super. Everything is good in the world.
20:10:51 <geekosaur> so any other instance of D will overlap it
20:11:28 <kristof> geekosaur: But one day I realize that Concrete has a more general structure that I can reuse for other types, so I decide to turn it into a trait Abstract.
20:11:39 <kristof> but now I have lost the ability to use Super in my code the way I was doing before! I have broken everything.
20:12:24 <kristof> So this is the very ironic circumstance that trying to be more general has broken modularity.
20:13:21 <geekosaur> the fact that you're talking in terms of traits makes this whole thing kinda suspect, tbh. it sounds a lot like trying to use typeclasses as OO classes, which is a lovely way to go wrong
20:13:37 <kristof> Oops.
20:13:56 <kristof> Caught me. I've been programming in Rust for ages, but they're one-to-one isomorphisms to Haskell typeclasses with associated types.
20:14:01 <kristof> Traits in Rust, that is.
20:14:53 <kristof> I decided to walk on over here and see what the haskellites had to say about it.
20:15:10 <geekosaur> I am not sure of that, in part because of things like this... they seem isomorphic at first glance, but other aspects of the type system cause them to diverge
20:15:35 <kristof> "Things like this". This is not possible in Rust, either. They are entirely equivalent.
20:17:00 <kristof> geekosaur: Anyway, I guess the answer is just to make every concrete type an instance of Super and use the methods from Abstract, yeah?
20:17:44 <geekosaur> well. if you know every instance of Abstract must be an instance of Super, then we're actually back to my first comment
20:17:56 <glguy> What would the rust version of this look like in traits?: class L a where someList :: [a] 
20:18:23 <geekosaur> class Super a => Abstract a where ... {- here you may provide default method implementations using methods from Super -}
20:19:14 <geekosaur> but this can be a bit fraught; you might want to read up on the evolution of the Applicative-Monad Proposal, which inserted Applicative as a "superclass" of Monad
20:20:51 <kristof> geekosaur: See, that's backwards. There's an instance of Super I want to express using methods from Abstract.
20:20:56 <geekosaur> what you can't easily do is what I think you ... right
20:21:01 <geekosaur> you can't do that
20:21:32 <kristof> Maybe I can just make a wrapper type Abstract a => AbstractWrapper a
20:21:53 <kristof> and write an instance of Super for AbstractWrapper
20:22:19 <geekosaur> wrapper types are how we usually deal with the problem of instance Abstract a => Super a overlapping everything else, yeh
20:22:38 <kristof> geekosaur: Unfortunately, I have to wrap everything in that wrapper type, now.
20:22:40 <geekosaur> usually with a newtype
20:22:49 <kristof> ... but if it's a newtype, it's zero cost. I guess I'm okay with that.
20:22:52 <kristof> Yeah, that's really slick.
20:23:15 <kristof> I've usually replaced inheritance with composition and I guess it works in this scenario too. :)
20:23:20 <glguy> Looking at Rust traits it seems like they are only like typeclasses if your method mention an argument of the type of the thing the trait i parameterized over directly
20:23:46 <glguy> so things like: class L a where xs :: [a] -- or -- class E a where m :: Either Int a -> Bool -- would be out
20:26:53 <kristof> glguy: Is there a separate instance of xs for every instance of L?
20:27:16 <glguy_> Read typeclass is probably out
20:27:54 <glguy_> Yeah, each instance would define that list
20:29:19 <Denommus> why isn't there a library for databases based on MonadPlus?
20:30:09 <kristof> glguy_: http://is.gd/fO1rma
20:30:15 <kristof> glguy_: Someday, we will get associated constants. :(
20:30:32 <kristof> glguy_: They'll add that probably when they're done making a formal model for the type system, which is also when they're going to add higher kinded types.
20:31:04 * violentPython slaps `0660 around a bit with a large trout
20:31:41 <kristof> glguy_: But as you can see, I can (someday) express your examples. 
20:32:58 <ttt_fff> I want a language with all the advnatages of haskell, but strict instead of lazy.
20:33:03 <ttt_fff> I want a language with all the advnatages of haskell, but strict (by default) instead of lazy.
20:33:49 <geekosaur> can you hold out until 7.12 (or 8.0 if they decide to call it that)?
20:33:55 <kristof> ttt_fff: You would get about 70% of them from Rust or Ocaml.
20:34:03 <kristof> but they are missing some key stuff :)
20:34:08 <glguy_> The way they tie traits to be methods on the objects of the type implementing the trait means they'll always be limited
20:34:25 <ttt_fff> kristof: both of these langauge have the problem that "Int -> Int" does not imply that there's no side effects
20:34:30 <ttt_fff> geekosaur: ohh, wht's happening in 7.12 ?
20:34:35 <geekosaur> -XStrict
20:34:38 <ttt_fff> geekosaur: I'm even willing to install the experiemntal branch of 7.12
20:34:39 <ttt_fff> hmm
20:34:50 <kristof> ttt_fff: Oh, well, uh, don't write a function with side effects. \o/
20:34:50 <geekosaur> nto sure it's landed fully in HEAD yet
20:35:03 <Alpha64> ttt_fff F#? 
20:35:04 <ttt_fff> kristof: it's other people I don't trust
20:35:39 <geekosaur> that said, you'd need more than just the compiler supporting strict-by-default; you'd need a matching Prelude
20:35:46 <kristof> ttt_fff: IO is easy to "avoid" (people do not write functions with invisible IO in any language) and functions that side-affect state have it written in its type signature.
20:36:11 <geekosaur> I suspect a lot of the standard Prelude definitions would prove problematic in a strict-by-default environment
20:36:33 <ttt_fff> it's fine, I'm already using NoImplicitPrelude
20:36:49 <ttt_fff> what scares me is losing things like Data.Map, Data.Set, etc ...
20:36:49 <kristof> That's just prelude. Entire types like the Par monad and Strategy's wouldn't even work.
20:36:52 <ttt_fff> those libraries I'd like ot keep
20:37:23 <kristof> glguy_: Not true, any "method" in a trait can be parameterized over whatever types you want. 
20:37:34 <kristof> glguy_: A trait just creates a namespace/module for functions to live.
20:37:40 <kristof> Much like SML modules.
20:37:41 <rjeli> you can use strict evaluation operators
20:37:57 <geekosaur> I suspect you can get away with using Data.Map and friends as is, with some care
20:38:26 <glguy_> Kristof: I'm talking about how you need a value of the object to call the trait method from what I'm seeing
20:38:27 <geekosaur> maybe the bigger problem is that the language *idiom* changes massively
20:38:41 <glguy_> someValue.traitMethod
20:39:06 <ttt_fff> geekosaur: you are right, appears to not have landed in HEAD yet
20:39:59 <glguy_> Typeclasses don't dispatch on the type of the first argument, but on the type at which the method is used
20:40:22 <geekosaur> if you're feeling rather daring and ambitious, you can install the Phabricator stuff and apply the current patch
20:40:53 <geekosaur> but I assume the fact that it hasn't landed yet means there are still unresolved problems (but at least Phab will help you see what they are...)
20:41:38 * geekosaur is still rather weirded out that ghc development depends on a massive glob of command line PHP...
20:45:48 <kadoban> :-/ it does?
20:45:57 <geekosaur> phabricator and friends, yes
20:46:30 <geekosaur> there's discussion on the ghc-dev list about it, but I can see where the alternatives aren't really up to the task
20:47:13 <kadoban> Oh it's like collaboration stuff? Interesting.
20:47:23 <geekosaur> and review and stuff liek that, yes
20:47:48 <kristof> glguy_: Negatory! Traits are really just namespaces. http://is.gd/S0kebt
20:47:52 <kristof> Just like modules.
20:48:00 <geekosaur> I understand an upcoming addition to phab includes group messaging support (think slack/hipchat)
20:48:11 <geekosaur> (not that they're planning to use it since they already have #ghc)
20:48:59 <glguy_> Kristof: ah cool. That wasn't in the examples I found in the docs
20:49:11 <kristof> glguy_: See, methods for method notation are just fns that take a pointer to self, but if I declare a method in the trait that doesn't have such a pointer as an argument, it's really just a function sitting in an ad-hoc namespace.
20:49:26 <kristof> glguy_: Yeah, the documentation is written to appeal to people coming from OO languages.
20:49:50 <kristof> glguy_: What the guys at Mozilla do not like to admit is that Rust is two steps away from SML and a million miles away from C++/Java.
20:52:55 <geekosaur> "do not like to admit"? I thought the *point* of Rust was to be an SML-like targeting C/C++/Java developers?
20:57:10 <kristof> geekosaur: You never hear it being advertised as such.
20:57:26 <kristof> I suppose I meant that rather than "do not like to admit".
20:57:32 <kristof> "do not typically mention"
20:57:43 <geekosaur> marketing out of tune with engineering, that's a new one :p
20:57:51 <kristof> lol
20:57:59 <kristof> Well I would imagine that Mozilla marketing is in touch with its engineers
21:02:32 <nshepperd> huh, I imagined rust to be the bastard child of haskell and C
21:02:49 <ReinH> nshepperd: not so far off I guess
21:03:16 <ReinH> nshepperd: if you like your C with ADTs, type inference, and affine types...
21:03:33 <nshepperd> I do like my C with those things! :p
21:03:38 <ReinH> Indeed!
21:06:33 <sm> PHP FTW!
21:08:39 <kristof> I don't know if that^ was a response to the above discussion
21:09:02 <sm> kristof: sorry. It was in response to geekosaur about 20m ago
21:13:46 <octopuscabbage> does stack automatically use a sandbox?
21:17:16 <geekosaur> yes
21:17:34 <octopuscabbage> tyu
21:18:09 <geekosaur> and maintains it automatically, as I understand it; stuff you build gets cached and can be brought in in compiled form into new sandboxes
21:51:20 <clarkenciel> Would there be any difference in performance between these two versions of finding a max integer in a list? http://pastebin.com/raw.php?i=8ZXwfWSE
21:51:49 <clarkenciel> not that it really matters, I'm just fooling around.
21:52:37 <glguy> The first one does a lot more work than the second
21:53:11 <kadoban> clarkenciel: By the way â¦ don't call stuff 'head' and 'tail', those are in prelude (and mean different things)
21:53:24 <clarkenciel> kadoban: ah thanks
21:54:12 <aupiff_> I'm seeing a <<loop>> error all of the sudden when I execute a compiled program. is there any clever way to detect where the infinite loop is?
21:54:43 <gfixler> Any definitive writeup on forall? I've had it explained so many times now, and still don't grok it.
21:58:09 <lpaste_> glguy pasted âfor clarkencielâ at http://lpaste.net/140234
21:58:56 <glguy> clarkenciel: but rather than either of those you'd want to do this
21:58:59 <nshepperd> I feel like the only time it's permissible to call things head and tail is if you're doing 'f (head:tail) = ...' because then you're sort of doing record destructuring (if we imagine that data [a] = [] | (:) { head :: a, tail :: [a] })
21:59:23 <nshepperd> but we already have the x:xs convention anyway so it's inferior
22:00:24 <nshepperd> otherwise if you're writing your own head and tail for a vector library or something
22:01:23 <clarkenciel> nshepperd: nah, I'm just really green and wasn't thinking :)
22:02:00 <ReinH> head and tail are idiomatic names in other languages
22:02:22 <clarkenciel> glguy: did you include the warning about foldl? this does look distinctly fold-y
22:02:46 <glguy> clarkenciel: No, that's hlint doing it's thing
22:03:53 <clarkenciel> as they say in my hometown: "hot dang"
22:04:34 <glguy> you could rewrite it using 'foldl' and then 'foldl1' and then just using the existing 'maximum'
22:04:34 <kadoban> Yeah, hlint can be pretty smart sometimes.
22:05:56 <clarkenciel> right, cool!
22:09:30 <gfixler> I was demoing writing sum as a recursive function, and hlint said "Why not use folder?"
22:09:44 <gfixler> so I changed to its suggestion, and it said "You can eta reduce that"
22:09:50 <gfixler> so I removed the xs, and it said "Why not just use sum?"
22:09:53 <gfixler> :)
22:10:14 <gfixler> *where folder == foldr
22:10:34 <kadoban> Haha, yeah it's pretty funny when it does that.
22:35:23 <tommd> acowley: Yay, camera PR done.  Sort of... travis-ci seems to install an oldish version of ffmpeg which means the test failes.
22:42:46 <MarcelineVQ> gfixler: sometimes you'll use two maps `map f . map g` and it'll be like just use map (f . g) and you smack your forehead
22:43:10 <MarcelineVQ> gfixler: hlint and things like it are pretty cool
22:47:39 <Vyn> away
22:48:33 <gfixler> MarcelineVQ: I kept asking my friend how he was coming up with such nice CIS 194 answers, and he always said "hlint"
22:49:16 <MarcelineVQ> gfixler: ditto :3 I have it in atom and it's really nice
22:49:38 <MarcelineVQ> It can't solve things for you but it can make you look like a genius
23:08:23 <nitrix> Hi, I need help with stack. I write a simple `main = putStrLn "Hello world"`, no import no explicit module. I create the project with cabal init, then done a stack init.
23:08:51 <nitrix> I manage to build it with stack build, but the stack ghci gives me absolutly no import of Main in scope.
23:09:06 <nitrix> cabal does it when I do cabal repl, why can't stack do it?
23:09:59 <AshyIsMe> try :l Main
23:10:27 <nitrix> Is this by design?
23:13:01 <gamegoblin> is there a way to automatically export lenses generated by makeLenses? So tedious to type them all.
23:13:24 <pacak> gamegoblin: create them in a separate file and export all the things.
23:13:38 <gamegoblin> pacak: how do you export everything?
23:13:59 <pacak> module Foo where
23:14:10 <haskell730> Hello I have a lifecycle transitions like : data Order = Request | Approved | Delivered 
23:14:10 <gamegoblin> oh, huh, never knew that
23:14:57 <haskell730> I wanted express that Approved order is indeed requested so Delivered is always approved in type itself
23:15:14 <haskell730> any hints?
23:16:20 <gamegoblin> haskell730: does your thing always transition from Request -> Approved -> Delivered?
23:16:50 <pacak> haskell730: isApproved :: Order -> Bool ; isApproved = (/=) Delivered
23:16:57 <pacak> isRequested ..
23:17:52 <gamegoblin> pacak: I think haskell730 might be saying that they want to force a transition from Request to Approved at the type level, or something like that
23:17:55 <gamegoblin> Canât quite understand
23:18:09 <pacak> gamegoblin: Neither do I.
23:18:10 <gamegoblin> haskell730:  you there?
23:20:46 <haskell846> yeah my transitions will be in order
23:20:51 <pacak> haskell846: Are you haskel730?
23:20:55 <haskell846> yes
23:21:03 <haskell846> I got disconnected :)
23:21:17 <haskell846> client assigned another id 
23:21:19 <pacak> You can pick a better nick...
23:21:33 <pacak> Plz explain what are you trying to do.
23:22:12 <haskell846> I wanted to encode the information that Approved Order is Requested
23:22:45 <mauke> that depends more on the code that uses that information
23:22:50 <gamegoblin> haskell846: do you have any more code you can show us? there are several approaches.
23:23:24 <mauke> e.g. currently there's no need to check that an order is requested because all orders are
23:23:54 <mauke> isApproved o = o >= Approved  -- matches Approved, Delivered
23:24:09 <mauke> (deriving Ord)
23:25:02 <haskell846> it's just a thought touched my mind....while working don't have code as such
23:25:25 <gamegoblin> haskell846: you could represent the order status at the type level with some empty types and phantom types. Something like "data Requested; data Approved; data Delivered" (types with no constructors). Then have "data Order a = Order ___ whatever an order contains ____". Then you could have functions like "requestOrder :: â¦ -> Order Requested" and "approveOrder :: Order Requested -> Order Approved" and "deliverOrder :: Order Approved -> Order Delivered"
23:25:36 <gamegoblin> haskell846: if I understand what youâre trying to do, which I donât really
23:25:48 <pleiosaur> kristof: rust is firmly in the ML family, but the "zero-cost abstractions" influence of C++ infuses every aspect of the language. I'd say, ultimately, the end result is equal parts ML and C++
23:26:00 <pleiosaur> kristof: and the reason you don't hear rust advertised as an ML is because nobody's ever heard of ML :P
23:26:37 <kaidelong> SML/NJ was the first language I learned
23:26:52 <kaidelong> ML has some presence
23:27:19 <haskell846> gamegoblin: how can I right a function to get all approved orders. 
23:27:34 <pleiosaur> ML has presence in the same way that lisp has presence, which is to say that its primary importance is how it has influenced modern languages rather than being used in its own right
23:27:41 <gamegoblin> haskell846: you would have to maintain a datastructure of all the orders you approved. 
23:27:47 <haskell846> gamegoblin: because that should get me all delievered + approved orders
23:28:40 * hackagebot stack 0.1.4.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-0.1.4.1 (borsboom)
23:28:44 <gamegoblin> haskell846: can you express what you want to do as how you would do it in another programming language you know, and maybe I can help tell you how to do it the haskell way
23:29:16 <gfixler> so is the a in forall a referring to a value of the type?
23:29:27 <gfixler> reading: https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
23:29:36 <gfixler> "We see that most intersections over types just lead to combinations of bottoms in some ways, because types don't have a lot of values in common."
23:29:48 <gfixler> "[forall a. a] is the type of a list whose elements all have the type forall a. a, i.e. a list of bottoms."
23:30:06 <gfixler> I read forall a. a as identity, but I'm thinking of a as a type
23:30:23 <gfixler> this seems to say "for all values a. a"
23:30:27 <kristof> pleiosaur: I think there's a non negligible amount of C++ that was discarded and replaced with equivalently powerful constructs from ML.
23:30:32 <opqdonut> gfixler: i.e. a value that has every type
23:30:39 <haskell846> gamegoblin: thanks. idea is to give evidence at type level for the fact that Approved order is also Requested
23:30:42 <kristof> And I think the parts that are from ML completely outdwarf the parts from C++.
23:30:47 <opqdonut> gfixler: think of a top-level definition "thing :: a; thing = ..."
23:30:57 <opqdonut> gfixler: which is equivalent to "thing :: forall a. a; thing = ..."
23:30:59 <kristof> It's like they took SML and slapped mutability and statements on it
23:31:03 <opqdonut> how would you define it?
23:31:16 <gfixler> opqdonut: I don't know yet - I'm still quite confused
23:31:18 <haskell846> gamegoblin: it's not any problem I am trying to solve...just exploring if type system can encode that
23:31:37 <gfixler> opqdonut: I just know that "all these intersections results in bottoms" was a big surprise to me
23:32:14 <gamegoblin> haskell846: it can, but the way you do it depends on your application. 
23:32:16 <gfixler> [forall a. a] just reads to me as [a]
23:32:32 <gfixler> but that's not wrong, because [a] can be a list of any type, but apparently [forall a. a] is a list of bottoms
23:32:38 <opqdonut> gfixler: ah, the difference is that just [a] is actually "forall a. [a]"
23:32:40 <gfixler> *that's not right
23:32:48 <opqdonut> gfixler: whereas now we have "[forall a. a]"
23:32:49 <gfixler> opqdonut: ah, that's helpful
23:32:58 <gfixler> hmm
23:33:11 <opqdonut> gfixler: i.e. the "a" is constant in "[a]", whereas in "[forall a. a]" it can be different for each element
23:33:18 <haskell846> gamegoblin: okay lets take a use case where I need a function `Order -> Order` but it's partial for only Approved and Requested
23:33:19 <opqdonut> thus the term heterogeneous list 
23:33:21 <gfixler> opqdonut: right, I'm starting to see it
23:33:41 <haskell846> gamegoblin: can I say that in type?
23:33:49 <gamegoblin> haskell846: what do you mean partial for only Approved and Requested?
23:34:08 <haskell846> gamegoblin: it should only take Approved and Requested order
23:34:30 <gamegoblin> haskell846: I see, let me write some code and show you
23:34:41 <haskell846> gamegoblin: okay thanks :)
23:34:52 <gfixler> opqdonut: having trouble resolving this: "For example, forall a. a is the intersection over all types, which must be {â¥}"
23:35:11 <gfixler> with: [a] is actually "forall a. [a]"
23:35:33 <gfixler> if forall a. a is â¥, why isn't forall a. [a] then [â¥]?
23:36:36 <opqdonut> gfixler: forall a. [a] can also be []
23:36:41 <opqdonut> :t []
23:36:42 <lambdabot> [t]
23:36:50 <opqdonut> (i.e. forall t. [t])
23:37:07 <gfixler> so forall a. [a] can't be [Int], right?
23:37:22 <opqdonut> yeah, it can't
23:37:53 <opqdonut> however if you had a function "forall a. ([a] -> Int)", you could pass a [Int] into it
23:38:24 <gfixler> wow, this is confusing stuff
23:38:32 <gfixler> "forall a. [a] is the type of the list whose elements have some (the same) type a, which can be assumed to be any type at all by a callee (and therefore this too is a list of bottoms)."
23:38:52 <opqdonut> yeah
23:38:54 <gfixler> by "is the type of the list whose elements have some (the same) type a" to me could easily work as a definition of [a]
23:38:58 <gfixler> sorry of [Int]
23:39:18 <opqdonut> yeah but the relevant part is "which can be assumed to be any type at all by a callee"
23:39:40 <pleiosaur> kristof: "mutability and statements" are not what characterizes rust in practice. it's unique ownership (which C++ has been feebly approximating since 2005 via std::unique_ptr and std::move) and borrowed references (admittedly more from Cyclone than C++, but yet still more familiar to C++ than ML)
23:39:41 <opqdonut> it seems to me you should study vanilla haskell types a bit more before diving into existential types
23:39:47 <gfixler> opqdonut: but [a] can be assumed to be any type at all as well
23:39:57 <gfixler> and that doesn't stop it resolving to [Int] or whatever
23:41:06 <pleiosaur> kristof: I'd also argue that despite ADTs rust explicitly rejected ML's favorite feature, modules, while embracing C++'s favorite feature, RAII
23:41:25 <gfixler> opqdonut: I've been studying them for 2 years - how long do I need?
23:41:57 <gamegoblin> haskell846: http://lpaste.net/7961676551286685696
23:43:45 <haskell846> gamegoblin: it will be very notorious to write type class for various combinations 
23:44:11 <gamegoblin> haskell846: type-level programming can be tedious :)
23:44:15 <haskell846> gamegoblin: consider we have more states 
23:45:23 <haskell846> gamegoblin: thanks for help :)
23:45:47 <gamegoblin> haskell846: if youâre interested, you can look up how people do crazy things like implement quicksort at the type level. The code is very crazy.
23:46:15 <haskell846> gamegoblin: are you pointing at depedent types?
23:46:40 <gamegoblin> haskell846: sort of. Haskell doesnât have very good support for dependent types, but you can sort of hack them in sometimes.
23:47:12 <haskell846> gamegoblin: okay.. :)
23:58:17 <levi> gfixler: Thinking about type variables outside the context of function parameters is a bit different. 'forall a. a' is what we mean by just 'a'. If I tell you I have a value of type 'a', what can you tell me about that value?  What would have to be true of a value that has type 'a' for any 'a' we might pick?
