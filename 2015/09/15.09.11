00:02:06 <liste> you're welcome (:
00:05:34 <srenatus> daqo: try "/exit" and "/quit" or even Ctrl-D
00:07:38 * hackagebot ihaskell-diagrams 0.3.1.0 - IHaskell display instances for diagram types  https://hackage.haskell.org/package/ihaskell-diagrams-0.3.1.0 (gibiansky)
00:07:38 * hackagebot egison 3.5.10 - Programming language with non-linear pattern-matching against non-free data  https://hackage.haskell.org/package/egison-3.5.10 (SatoshiEgi)
00:16:16 <{AS}> GHC Core seems really useful :) 
00:16:55 <lamefun> is it required that the result of "show" can be used from another module (i.e. can I simply use deriving (Show, Read) even if I don't expose the constructors)?
00:17:31 <{AS}> lamefun: You can, but it will still show the internal constructors AFAIR
00:17:56 <lamefun> I know, but is it OK to do?
00:18:04 <{AS}> so even though you can't use the constructors, calling show from another module will print the internal names
00:18:36 <liste> Read without exposed constructors sounds dangerous
00:18:51 <liste> others could construct arbitrary values of your types
00:19:44 <lamefun> what's the point of Show and Read anyway?
00:20:09 <pyon> Is there any way to define a custom pattern `(x, x)` that's syntactic sugar for `(x, y) | x == y`?
00:21:13 <{AS}> In GHC Core, as I understand let is non-strict but case is strict, right?
00:22:56 <montanonic> I genuinely don't understand why I'm getting this error in Yesod in a simple Data.Map constructor function, http://pastebin.com/jZHEGXXH (error included at end of file).
00:23:10 <montanonic> templateNames is the relevant function, and it's final line is line 33
00:23:15 <montanonic> its*
00:23:40 <{AS}> montanonic: templateList has the wrong indentation
00:23:43 <lamefun> I mean, Show is good for simple debugging, but what's the point of Read?
00:24:04 <montanonic> oh, oops on the paste
00:24:11 <montanonic> {AS}: in my source it is indented properly
00:24:18 <{AS}> Oh OK :)
00:24:24 <lamefun> Is actually used somewhere?
00:24:25 <montanonic> {AS}: but ty! :)
00:25:00 <montanonic> (my bad for not double-checking)
00:25:39 <montanonic> It's worth saying that I'm running the templateNames function on the Haskell Center IDE, and it works exactly as intended.
00:26:05 <montanonic> For some reason Yesod gets mad at it, and I'm wondering if it has to do with `import Import`
00:26:31 <{AS}> montanonic: I am not sure :)
00:29:12 <lamefun> Is it OK to ignore Read completely?
00:32:14 <quicksilver> {AS}: in GHC core case is 'magic' and forces its argument to WHNF even if it doesn't inspect it, I think.
00:35:26 <cocreature> lamefun: read is nice for debugging aswell, since usually you can read a value dumped by show back in using read.
00:37:29 <ReinH> lamefun: yes, it's ok
00:38:02 <RlyDontKnow> it could have been done better
00:38:08 <RlyDontKnow> sorry
00:56:38 <{AS}> quicksilver: Ah, thanks
00:57:30 <lamefun> BTW there's deriving (Read) in refined library...
00:57:51 <{AS}> Is there a way that I can compile a function in Haskell to GHC Core?
00:59:17 <{AS}> Oh found it, "ghc-core" package
01:00:09 <frerich> What's really irritating me is how Cale is being so relaxed and patient around here, and then I try to push the boundaries of my Haskell knowledge thinking that I'm really cool only to find some Reddit post where he explains everything in great detail - and the post is seven years old.
01:00:27 <merijn> {AS}: Just ask GHC to output the Core? :)
01:00:28 <frerich> He's kinda like a sleeper, you know - beetles with a Porsche engine.
01:00:49 <merijn> {AS}: ghc-core is just a pretty-printing frontend for GHC itself by stripping out "useless" Core
01:00:49 <{AS}> merijn: I should take a look at GHC options too I guess :), thanks
01:01:30 <merijn> {AS}: If you want Core you can modify and feed back into GHC to compile, just use ghc. If you wanna look at core and not have an unreadable mess (to understand what your code looks like) use ghc-core
01:01:55 <Cale> frerich: heh, which post?
01:02:05 <{AS}> merijn: OK :)
01:02:58 <frerich> Cale: Arrr, now I cannot find it again, let me search. It was by a user 'CaleGibbard' (I suppose that's you) about the monomorphism restriction.
01:03:04 <frerich> And it was from early 2008
01:03:27 <Cale> I'm usually cgibbard on reddit, so that's a little weird, but maybe :)
01:03:42 <Cale> (But yeah, I am Cale Gibbard)
01:04:09 <Trc> Hi guys, anyone been reading the chapters of haskellbook.com? is it good compared to the other books on the market?
01:04:52 <frerich> Cale: It was definitely a user account called 'CaleGibbard' but now you got me wondering whether it wasn't Reddit maybe.
01:05:04 <julianleviston> Trc: there’s only one book I think is really well written so far WRT haskell, and that’s this: http://chimera.labs.oreilly.com/books/1230000000929/
01:05:47 <julianleviston> Trc: the only trouble is it’s decidedly NOT for beginners.
01:05:49 <merijn> That's not a helpful book for learning Haskell, though
01:06:02 <Trc> I am not there yet :)
01:06:23 <merijn> Trc: The current recommended way is too mix and match from https://github.com/bitemyapp/learnhaskell, Learn You a Haskell and/or Real World Haskell
01:06:25 <julianleviston> I wish he’d write a beginner book because his writing is amazing
01:06:26 <merijn> @where lyah
01:06:26 <lambdabot> http://www.learnyouahaskell.com/
01:06:32 <Cale> Graham Hutton's book is pretty good for what it covers
01:06:37 <merijn> julianleviston: bitemyapp is working on a beginner book
01:06:52 <merijn> One that's more in-depth and structured than LYAH
01:06:53 <julianleviston> merijn: yeah, I know … that’s what this question originated with
01:06:53 <frerich> julianleviston: I liked 'Programming in Haskell' a lot, I only wish I read it earlier.
01:07:11 <Trc> merijn: ya, thats why I asked, because haskellbook.com is by bitemyapp.. So I wanted to know if anyone read the chapters yet :)
01:07:17 <Trc> thanks for input though
01:07:25 * frerich doesn't know why "Programming in Haskell" is never mentioned but always only LYAH/RWH/bitemyapp's
01:07:48 <Cale> frerich: Probably because there's no free web version of it
01:07:50 <julianleviston> frerich: probably because it’s old / in HUGS isn’t it? (I get confused between it and another one)
01:07:58 <Cale> I don't think it's that old
01:08:02 <julianleviston> Trc: my measure of whether a book is good is whether I go to sleep reading it...
01:08:15 <frerich> julianleviston: Yes it does use Hugs, but that wasn't a problem for me, I cannot recally having issues with using ghc instead
01:08:20 <Cale> It's from 2007 and it doesn't cover anything which could have gone much out of date
01:08:31 <Cale> Ah, okay
01:08:36 <julianleviston> Cale: It uses some strang syntax, too like n+1 pattern matching
01:08:46 <julianleviston> but it’s very good.
01:08:51 <merijn> Trc: Should be fine, basically despite not being finished
01:09:09 <Trc> I'll probably take a look at it
01:09:13 <julianleviston> I find most haskell books insanely boring
01:09:16 <merijn> Trc: Combining multiple books/sources is good anyway, helps fill in any holes some of the other may have mixed :)
01:09:20 <julianleviston> including LYAH
01:09:27 <julianleviston> they’re not concrete enough for my liking.
01:09:35 <frerich> Cale: I'm somewhat annoyed that I cannot find that posting of yours anymore, but assuming that The Real Cale Gibbard just stood up - can you maybe tell whether you use the user name 'CaleGibbard' (i.e. without a space) in some forum? I was so sure it was Reddit...
01:09:38 <julianleviston> but that’s probably just me
01:09:57 <Cale> frerich: Probably, but I can't think of something major off hand
01:10:07 <merijn> Trc: Personally I recommend keeping RWH as a reference, i.e. it has some good chapters on some libraries, things like transformers, parsec, profiling, etc. but I don't think it's a very good book for learning the language itself :)
01:10:07 <Cale> frerich: Could it have been a comment on someone's blog?
01:10:21 <julianleviston> that’s probably why I like the parallel & concurrent programming book… even though it’s an advanced topic, it’s much more understandable than most beginner books
01:10:34 <julianleviston> merijn: totally
01:10:48 <frerich> Cale: It was definitely a comment to *something*. I remember that it had an orangeish background. Sorry for the fuzzyness :-/
01:10:53 <MarcelineVQ> julianleviston: I also found the parellel & concurrency book very clear in its explanations
01:11:12 <julianleviston> Trc: my current recommendation is: read many different books… and guide yourself with yorgey’s course
01:11:20 <Cale> frerich: Oh, or the old wiki... though if it was that far back, it would have more likely been someone explaining the MR to me :D
01:11:22 <Trc> thanks
01:12:11 <julianleviston> Trc:  you kind of have to provide your own overarching process, and construct your own “best bits” from all the web and books that are out there … if something doesn’t work for you, find a different explanation. :)
01:12:23 <julianleviston> at least, that worked for me.
01:12:35 <julianleviston> (works for me)
01:13:00 <merijn> There's probably a bunch of online courses too, but in reality this channel is an excellent place to get pointers of where to look/what to do next/ask clarifying quesitons
01:13:01 <Cale> Oh, the newer wiki has a comment from me here: https://wiki.haskell.org/Monomorphism_restriction
01:13:22 <frerich> True, but that's not it, gnaaah. How frustrating.
01:13:54 <frerich> It was from 2008. Well in any case I felt like I'm basically beyond the real of human knowledge and then I found that you commented on the whole stuff seven years ago. How sobering.
01:14:11 <Trc> I am probably going to start a project on tuesday, where I will force Haskell in.. The gui-part will probably be in c#/wpf, but the logic will be in Haskell.
01:14:39 <julianleviston> Trc: But you don’t know haskell yet?
01:14:44 <Trc> A little bit
01:14:54 <Trc> enough to try and use it in an application I think
01:15:45 <julianleviston> Trc: Good luck! :)
01:15:58 <Trc> My goal is really to get my job to let me spend some worktime using it, and therefore I need to prove, that it can provide value and be relatively easy used from c#
01:16:13 <Trc> I think it is great fun, and that is really my motivation
01:16:20 <merijn> Trc: Sounds reasonable, GUI frameworks are a bit of a pain (in any language), so the bindings are a bit underdeveloped in haskell. But if you already know how to do those in C# then talking to a haskell process should be pretty easy
01:16:31 <merijn> Or just FFI'ing from C# to haskell, I guess
01:16:38 <merijn> (Or the reverse...)
01:16:54 <merijn> I'm assuming C# has a C FFI somewhere
01:17:02 <Trc> Ya, it has
01:18:48 <julianleviston> Has anyone got experience with distributed haskell on heroku?
01:19:14 <merijn> Linking haskell into other languages/other languages into haskell is pretty easy provided you 1) don't plan to mutate C structs from haskell and 2) already know the basics of linking and libraries in C
01:19:24 <julianleviston> I’d like to run a set of worker processes across a couple of dynos and have them share workloads while also being a server each…
01:19:47 <julianleviston> but from memory, heroku is share-nothing, which means no process communications, no?
01:19:53 <Trc> merijn: I have worked a bit with it, so hopefully it'll work out
01:20:20 <Trc> woawa the person with the nickname so must be tagged quite often
01:20:34 <merijn> Trc: Here's a minimal example I wrote for calling haskell from C: https://gist.github.com/merijn/4a0fee2b3a5ef3476aa4
01:21:40 <Trc> thanks
01:21:58 <merijn> I recommend reading the FFI section of the Haskell Report too, it's very good to know
01:28:46 <pseudomeme> hello everyone. Could use some guidance. I have a state and am using the State monad. I use a lot of random numbers too, though, and it would be really handy to have a random state in my monad too.
01:29:14 <pseudomeme> is there a way to combine 2 states? I was looking at StateT but can't figure out how to make the second monad another state. I also read that lenses might be the way to do it?
01:29:25 <pseudomeme> I could use some input since state and lenses are entirely new to me
01:30:40 <opqdonut> pseudomeme: the simple solution is just to use a state type of (YourState,StdGen)
01:31:21 <pseudomeme> opqdonut: I could do that, but then manipulating the individual parts of the state would be messier
01:31:24 <opqdonut> pseudomeme: lenses are a way to make accessing a structured state a bit simpler, but they're not necessary
01:31:26 <pseudomeme> although I guess not with lenses?
01:31:46 <opqdonut> I'd just write nice combinators
01:32:18 <opqdonut> something like "modifyMyState f = do (s,rand) <- get; put (f s, rand)"
01:32:27 <pseudomeme> opqdonut: well, for example, how would you extract a random number from the state with a state like (MyState,StdGen)?
01:32:28 <merijn> You could use lens, but if that intimidates you, you can fake things using bifunctor (since that's in base now! :D)
01:32:34 <merijn> :t modify . second
01:32:36 <lambdabot> MonadState (d, c) m => (c -> c) -> m ()
01:32:41 <merijn> :t modify . first
01:32:42 <lambdabot> MonadState (c, d) m => (c -> c) -> m ()
01:32:53 <pseudomeme> oh that's neat
01:33:13 <merijn> Look at Data.Bifunctor
01:33:23 <merijn> pseudomeme: and gets/modify from State
01:33:29 <opqdonut> pseudomeme: "runRandom r = do (s,rand) <- get; let (result,rand') = r rand; put (s,rand'); return result"
01:33:54 <merijn> (Note that Data.Bifunctor might be onlin since 7.10)
01:34:14 <opqdonut> pseudomeme: I feel that it's good to start simple and just write the stuff out. once you feel comfortable with playing with state you can try making things easier with lens or something
01:34:22 <opqdonut> but merijn has good suggestions too
01:36:41 <kadoban> Couldn't he use RandT g (State s) or something?
01:36:51 <pseudomeme> hmmm, well all of those are ways I could do it, but they feel a bit bulky. With RandT I can use one call to get a random number
01:37:05 <pseudomeme> kadoban: I thought of something like that, but State takes 2 type arguments, doesn't it?
01:37:11 <pseudomeme> the state and the return type
01:37:26 <pseudomeme> :info State
01:37:31 <pseudomeme> :(
01:37:40 <merijn> pseudomeme: Shouldn't be hard to implement a new combinator that basically "takes the StdGen, gets a number, puts the new StdGen back"
01:37:47 <merijn> And then you can just use that new thing everywhere
01:37:49 <opqdonut> pseudomeme: that doesn't matter
01:37:57 <pseudomeme> merijn: RandT already does that
01:37:58 <opqdonut> pseudomeme: RandT g (State s) is a valid monad
01:38:08 <opqdonut> pseudomeme: just like e.g. RandT g Maybe would be
01:38:25 <pseudomeme> opqdonut: oooooooooooooooohhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh
01:38:34 <pseudomeme> of course it valid
01:38:36 <kadoban> pseudomeme: In practice I'd probably do the RandT thing, but I kinda suspect merijn's advice is also good. I've found it far more sensible doing it kinda manually first.
01:38:54 <opqdonut> pseudomeme: RandT has kind * -> (* -> *) -> * -> *
01:39:05 <opqdonut> and State s has kind * -> *
01:39:43 <pseudomeme> yeah, I forgot that the monad taken by a monad transformer is * -> *
01:39:56 <pseudomeme> the return type argument is left out so often I forgot it's there
01:43:10 <pseudomeme> I think I understand how to use RandT g (State s) now
01:43:20 <pseudomeme> thank you all for the help! This is super cool!
01:44:25 <echo-area> Is rpar/rseq/rseq the same as rseq/rseq?  In one run here I didn't see the difference
01:47:38 * hackagebot inline-c 0.5.5.0 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.5.5.0 (FrancescoMazzoli)
01:48:29 <echo-area> Oh, there didn't seem to be sparks with rseq/rseq
01:52:38 * hackagebot inline-c 0.5.5.1 - Write Haskell source files including C code inline. No FFI required.  https://hackage.haskell.org/package/inline-c-0.5.5.1 (FrancescoMazzoli)
02:35:47 <mietek> julianleviston: you’d have to use a service to coordinate communication
02:36:03 <julianleviston> mietek: what do you  mean a service?
02:36:08 <julianleviston> mietek: an add-on?
02:36:20 <mietek> julianleviston: I don’t have anything specific in mind; just thinking about the architecture
02:36:36 <julianleviston> mietek: Um. Ok. I’m talking about Heroku in particular.
02:36:46 <mietek> julianleviston: yes. Heroku dynos can’t talk directly with each other.
02:36:48 <julianleviston> mietek: see, there *was* this: http://tomvn.com/posts/tcp-sockets-for-heroku.html but I think it got killed… coz I can’t find it.
02:37:17 <julianleviston> That kind of sucks. I guess I’ll have to use AWS if I want to do socket or process comms :S
02:38:12 <mietek> AWS, DigitalOcean, Linode...
02:38:39 <julianleviston> Damn. I got used to how awesomely quick process-scaling and deployment is in Herokue
02:38:42 <julianleviston> Heroku.
02:39:12 <mietek> As I understand, Amazon Elastic Beanstalk does the scaling bi
02:39:13 <mietek> bit
02:39:56 <julianleviston> Yeah, AWS is *not* easy ;-)
02:40:15 <mietek> Anyway, as I was saying, you could have Heroku dynos communicate through a service
02:40:17 <julianleviston> I was hoping to mitigate some of the difficulty… I’m already using them for S3… but yeah, all good
02:40:26 <julianleviston> mietek: what do you mean a service?
02:40:44 <julianleviston> mietek: do you mean via an API?
02:40:45 <mietek> Instead of sending messages directly to each other, send them through an intermediary
02:41:04 <julianleviston> mietek: that kind of defeats the purpose of what I’m trying to do, though, in a way… 
02:41:34 <julianleviston> mietek: I’m thinking of building a lightweight messaging system inside each web server process
02:41:48 <julianleviston> that also does computational processing
02:42:02 <julianleviston> well - the messaging would be separate to the computation
02:42:23 <mietek> https://en.wikipedia.org/wiki/NAT_traversal
02:42:54 <mietek> Maybe you can work around Heroku’s routing layer using some of these techniques
02:43:00 <mietek> I don’t know; it would also be working against the grain
02:43:27 <julianleviston> mietek: No - there aren’t any ports open to do that with
02:43:44 <julianleviston> mietek: they use an ingress proxy
02:44:12 <julianleviston> my only alternative seems to be to use the db as a messaging queue and that’s a terrible idea
02:45:00 <mietek> A DB or any other service which you could write yourself
02:45:33 <mietek> The only requirement is for it to be available on a predefined address, to which all nodes would make requests
02:45:47 <julianleviston> mietek: at which point I may as well not be on heroku, really.
02:45:59 <mietek> Maybe. Depends on what your considerations are.
02:46:06 <julianleviston> mietek: speed.
02:46:18 <mietek> If you want to do high-performance computing, then yeah, you probably don’t want to be on Heroku.
02:46:34 <julianleviston> mietek: not *THAT* high-performance
02:47:38 <julianleviston> I don’t know all of this is highly theoretical at this stage anyway.
02:51:36 <bernalex> Norwegian people who happen to see this: we're breathing some life into #haskell.no as of today. :)
02:52:54 * hackagebot tamper 0.4.2.2 - Blaze-style HTML templates as a Monad Transformer.  https://hackage.haskell.org/package/tamper-0.4.2.2 (TobiasDammers)
02:54:42 <lamefun> I wish there were a pure functional language from Apple...
02:55:01 <srhb> bernalex: Oh, whatcha doing with it?
02:55:26 <glaukon> Heap overflow question, please help! http://stackoverflow.com/questions/32520595/heap-overflow-in-haskell
02:55:51 <julianleviston> lamefun: nu ?
02:56:06 <julianleviston> lamefun:  actually maybe not.
02:56:42 <julianleviston> lamefun: you don’t like swift?
02:56:43 <bernalex> srhb: nm. I started the Trondheim Haskell Users' Group, and there already is Osλo Haskell. so we've put up haskell.no and got on #haskell.no so that we can have some organising on the national level. going to promote the channel on the first Trondheim meetup (today), and have the Oslo guys promote it on their next. :)
02:57:11 <srhb> bernalex: Very cool. :)
02:59:09 <bernalex> srhb: there are very few that use haskell in production here -- that I know of. would be neat to collect them in one place and trade off ideas and stuff. :)
02:59:23 <srhb> bernalex: Yeah definitely. I think it's a great initiative. :)
02:59:29 <bernalex> srhb: http://haskell.no/funksjonelle-bedrifter/ there are three companies listed here, and mine is one of them heh
02:59:47 <bernalex> hyPiRion: you should get him to list yours, since you rewrote everything whilst everyone else were on holiday. :D
02:59:49 <srhb> bernalex: Cool! I'll be snooping on the channel. :-)
03:00:01 <bernalex> srhb: great, thanks!
03:17:55 * hackagebot smsaero 0.2 - SMSAero API and HTTP client based on servant library.  https://hackage.haskell.org/package/smsaero-0.2 (NickolayKudasov)
03:37:56 * hackagebot hastache-aeson 0.1.1.0 - render hastache templates using aeson values  https://hackage.haskell.org/package/hastache-aeson-0.1.1.0 (VladimirKirillov)
03:40:45 <Gurkenglas> Can I make a default value of a record that leaves the values undefined? (Or somehow else aborts out when someone tries to access a field.) (So I can then fill the fields from stdin using lens.)
03:42:37 <merijn> Gurkenglas: I think partially initialising a record automatically already leaves the fields undefined
03:43:09 <merijn> Gurkenglas: Better would be to make a smart constructor for your record?
03:43:15 <liste> > Just{}
03:43:17 <lambdabot>  Just *Exception: <interactive>:3:1-6: Missing field in record construction
03:48:08 <Gurkenglas> Why doesn't it say which field?
03:48:36 <Nux_> my question is why? http://pastebin.com/utaEY9Nw
03:49:17 <liste> @src Just
03:49:17 <lambdabot> Source not found. You untyped fool!
03:49:21 <liste> @src Maybe
03:49:21 <lambdabot> data Maybe a = Nothing | Just a
03:49:31 <liste> Gurkenglas maybe because the field has no name?
03:49:48 <bernalex> Nux_: please use lpaste in the future instead of pastebin. :)
03:49:59 <liste> @let data FieldWithName = FieldWithName { iHaveAName :: Int }
03:50:00 <lambdabot>  Defined.
03:50:02 <bernalex> Nux_: why what btw?
03:50:07 <liste> > FieldWithName {}
03:50:08 <lambdabot>      No instance for (Show FieldWithName)
03:50:10 <lambdabot>        arising from a use of ‘show_M389748766061062966111590’
03:50:14 <lambdabot>      In the expression:
03:50:18 <Nux_> bernalex, why doesn't answer2 evaluate?
03:50:30 <Gurkenglas> Ah, right, thanks.
03:50:37 <Nux_> as in why does it fail to nonstrictly evalurate to the same as answer1?
03:50:41 <Nux_> *evaluate
03:50:50 <bernalex> Nux_: because you are using an endless list?
03:50:52 <liste> > FieldWithName {}
03:50:54 <lambdabot>  FieldWithName {iHaveAName = *Exception: <interactive>:3:1-16: Missing field ...
03:52:16 <liste> it cuts off too early even with shorter names :/
03:52:21 <liste> so I gotta try it with ghci
03:52:58 <merijn> Nux_:  Needs more local definitions, btw
03:53:01 <liste> Gurkenglas ghci at least says what field is not initialized
03:53:37 <merijn> Nux_: btw, foldl doesn't work on infinite lists and your primes' is infinite
03:54:20 <bernalex> merijn: that was my observation as well
03:54:42 <bernalex> I'm not sure why Nux_ expected it to halt
03:55:55 <merijn> Also, since this is using ++ to append this algorithm is a classical Shlemiel the Painter algorithm
03:55:59 <merijn> i.e. terribly slow
03:56:08 <Nux_> yes I realize now that foldl wouldn't halt on an infinite list
03:56:24 <int-e> liste: hint, lambdabot truncates less aggressively in private chat
03:56:29 <merijn> http://www.joelonsoftware.com/articles/fog0000000319.html
03:56:57 <Nux_> the original version of this used foldr and (:) rather than foldl and (++)
03:57:10 <Nux_> it got into this state after me frustratedly changing it in many ways
03:57:19 <bernalex> > foldl (const . const $ True) False [1...] -- :-]
03:57:20 <lambdabot>      A section must be enclosed in parentheses thus: (1 ...)
03:57:43 <bernalex> > foldl (const . const $ True) False [1..] -- :-]
03:57:46 <liste> int-e I tried it in private chat, still too truncated :(
03:57:48 <lambdabot>  mueval-core: Time limit exceeded
03:58:37 <lpaste_> merijn pasted “Refactored” at http://lpaste.net/140649
03:58:57 <merijn> Nux_: See that link for a slightly cleaner way to write the same
03:59:30 <merijn> (That doesn't solve the termination and sucky speed issue, but I'm too lazy for that atm)
03:59:37 <Nux_> that's fine cheers
04:00:11 <Nux_> I feel like what I'm trying to do should be achievable with folds
04:00:30 <Nux_> yet it seems like either direction I try to fold in causes infinite regression
04:01:03 <Nux_> I want to go through each natural above 1 trying to add it to my current list of primes
04:01:09 <merijn> Nux_: It is, but you have to use foldr and you should avoid the use of ++ to append :)
04:01:22 <Nux_> I've tried this
04:01:26 <bernalex> Nux_: https://wiki.haskell.org/Prime_numbers might be interesting to you. :)
04:01:28 <merijn> The order in which you test primes is irrelevant, so you can simply build in reverse using :
04:01:42 <Nux_> the order is relevant
04:01:51 <merijn> Why?
04:02:50 <Nux_> I don't want to check large primes because I know that if the prime squared is greater than my number then I'm not going to find a prime divisor larger
04:03:16 <Nux_> since I didn't find one up to that point
04:03:20 <merijn> dropWhile (>=x) instead of takeWhile (<=x)? I guess that does some extra work
04:03:21 <Nux_> it's an optimisation
04:03:28 <merijn> But that should still be less extra work than appending
04:03:48 <merijn> Nux_: You realise that appending rebuilds the *entire* list on *every* append?
04:03:59 <Nux_> yes
04:04:09 <merijn> So you're adding way more work than checking extra numbers is
04:04:30 <Nux_> I wouldn't say necessarily so
04:05:04 <merijn> Look into DList and/or Seq for data types with efficient append operations
04:05:19 <Nux_> I'm aware of difference lists
04:06:13 <Nux_> the problem is I often find myself going through most of the primes
04:06:34 <Nux_> so it seems like potential optimisations just cost me overall thanks to the overheads of implementing them
04:07:16 <merijn> I think a self recursive implementation would probably end up being substantially faster
04:08:33 <bernalex> how did @. work again?
04:09:23 <bernalex> I tried @. pl . undo do { ... } -- but that's apparently wrong heh
04:13:59 <lpaste_> merijn annotated “Refactored” with “Faster primes” at http://lpaste.net/140649#a140650
04:14:15 <merijn> Nux_: That one is infinite and substantially faster than your versions on my machine
04:15:45 <merijn> Nux_: Because it never rebuilds the list of primes. Once an element is in it, it's in the right order and never changed
04:16:31 <merijn> It's similar to the usual efficient fibonacci definition
04:16:50 <merijn> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
04:16:52 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:17:12 <Nux_> merijn, cheers I'll have a look at these when I'm free again
04:17:18 <Nux_> sorry, I'm busy now
04:19:44 <bernalex> oh. it was correct. pl just couldn't handle the output of undo.
04:20:31 <bernalex> seems undo can handle trailing whitespace & pl can't. someone should fix that I guess. :)
04:21:12 <Nux_> merijn, one slight issue, 'notPrime' gives true when the number is prime
04:21:29 <bernalex> is there some function in base equivalent to: `forM_ [n, n - 1 .. 0] $ const`?
04:22:15 <merijn> Nux_: Oh, I messed up the name AND the way filter filters, so it works right the name is just confusing :p
04:22:26 <Nux_> :)
04:22:30 <merijn> So it should just rename notPrime to isPrime
04:22:45 <Nux_> which I've done :P
04:22:59 * hackagebot EntrezHTTP 1.0.0 - Libary to interface with the NCBI Entrez REST service.  https://hackage.haskell.org/package/EntrezHTTP-1.0.0 (FlorianEggenhofer)
04:23:00 <Nux_> I chose the same name
04:23:14 <kadoban> I would have gone with notNotPrime
04:23:38 <Nux_> notDoublePlusUnPrime
04:24:55 <honeywhite> Hey fellas!
04:24:59 <Nux_> ok that 1984 joke might have been double plus unobvious
04:25:53 <honeywhite> Just need a little bit of help with Haskell.  Absolutely zero experience doing imperative programming (I'm a page layout sort of guy).  Haskell is literally bending my mind.
04:26:22 <honeywhite> I know it's a functional language---just saying I don't have any imperative bacground at all
04:26:31 <quicksilver> hmm, still no priority queue in containers or platform :(
04:26:39 <bernalex> merijn: Nux_: and this is why you name all your functions f. it's a mnemonic for function, so the meaning is always correct!
04:26:44 <mpickering> quicksilver: just use the psqueues package
04:27:11 <bernalex> honeywhite: haskell can do imperative programming too. but usually functional is preferable. :)
04:27:15 <merijn> bernalex: "f = fix f"? :)
04:27:20 <honeywhite> Haskell treats a string like Fortran, right?  Just a list of characters.  Hello world is ["H","e","l".."d"] correct?
04:27:37 <mpickering> Anyone know of any haskell related tourism opportunities in Arnheim? my attempt to get to utrecht has so far failed
04:27:37 <merijn> I doubt fortran treats strings as lists
04:27:44 <merijn> I would expect fortran to use arrays
04:27:47 * mpickering crosses fingers
04:27:57 <bernalex> @src String
04:27:57 <lambdabot> type String = [Char]
04:28:00 <bernalex> honeywhite: ^
04:28:07 <merijn> mpickering: Arnheim? Do you mean Arnhem?
04:28:23 <Maxdamantus> > let str = 'H':'e':'l':'l':'o':str in str
04:28:25 <lambdabot>  "HelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHelloHello...
04:28:41 <mpickering> yes Arnhem
04:28:53 <quicksilver> mpickering: nod
04:29:14 <honeywhite> Right.  What IU was wondering about is if there's a function to transliterate several elements of that list based on a lookup of some sort
04:29:35 <honeywhite> So let's say I wanted to transliterate H into X, and O into Y...
04:29:45 <merijn> mpickering: There's some stuff in Amsterdam, but that's further than Utrecht :p
04:29:54 <mpickering> yes, map
04:29:58 <quicksilver> mpickering: why psqueues instead of pqueue?
04:30:16 <mpickering> the trains aren't running between arnhem and utrecht which is why I am here
04:30:24 <honeywhite> Oh, wow!  Thanks.
04:30:28 <ski> > map (\c -> case c of 'H' -> 'X'; 'o' -> 'y'; _ -> c) "Hello world"
04:30:32 <lambdabot>  "Xelly wyrld"
04:30:40 <merijn> mpickering: Ah, if the trains to Utrecht don't run you're not getting anywhere, no :p
04:31:05 <bernalex> honeywhite: a very basic way to do it is to have stuff like `t 'a' = 'i'; t 'b' = 'j'; t 'c' = 'k'` or something, and then map t "abc".
04:31:08 <honeywhite> I am still surprised at the huge variety of shit that's possible with H.
04:31:35 <honeywhite> I mean, the only time I ever tried to do a bit of actual programming was when I was forced to take a class in Visual BASIC
04:31:43 <statusfailed> anyone using gitit? can't figure out why my post-commit hook isn't running when I edit pages
04:31:46 <merijn> mpickering: So what qualifies as "haskell related tourism"?
04:32:09 <bernalex> merijn: stalking pwadler's house like a crazy papparazzi?
04:32:10 <honeywhite> and I was left banging my head against the fucking keyboard, it was so goddam frustrating.
04:32:14 <merijn> There's a couple universities in the east of the country doing Haskell and/or FP
04:32:38 <merijn> But considering Utrecht seems to indeed be having major issues it's an open question whether you could even get there :p
04:32:39 <mpickering> seeing a bike monitoring system implemented in haskell
04:33:11 <honeywhite> @Bernalex basic won't cut it because it's essentially a program to transliterate between various different non-unicode mappings for the Greek language
04:33:11 <lambdabot> Unknown command, try @list
04:33:22 <mpickering> quicksilver: just the best one I have used
04:33:25 <quicksilver> ok
04:33:30 <quicksilver> I don't actually need the 'search' part
04:33:36 <quicksilver> plain priority is all I'm after
04:33:54 <mpickering> Just use () for that then
04:34:04 <mpickering> the library is designed by good people 
04:34:17 <honeywhite> I don't know what to think about Haskell---it's quite mind-bending TBH
04:34:39 <mpickering> Maybe I will have to resort to traditional tourism opportunities 
04:34:44 <liste> honeywhite non-unicode?
04:34:51 <liste> why are you using String then?
04:35:07 <liste> do you map non-unicode -> string -> non-unicode ?
04:35:18 <honeywhite> Like just from reading some of the introductions it would be VERY difficult to do the stuff I'm accustomed to doing in a shell script/bat file (GOTO being one of them)
04:35:41 <ski> honeywhite : if you sometimes need to translate a character to more or less than a single character, use `concatMap' instead. .. if you sometimes need to translate several contiguous character together, then i suppose i might reach for a direct recursion
04:35:41 <bernalex> honeywhite: that's a design feature to discourage you from doing that, mostly. :)
04:36:23 <honeywhite> I'm aware of that Bernalex ;) Haskell makes you think sideways instead of forwards.
04:36:46 <merijn> I disagree, haskell makes you think forwards, it's everything else that makes you think sideways >.>
04:36:56 <ski> honeywhite : you can easily implement a flat flowchart with tail-calls
04:37:03 <bernalex> I don't get the metaphor at all. :)
04:37:20 <honeywhite> And because my brain isn't quite used to thinking sideways OR into the fourth dimension (i.e. "advanced" Haskell) it a splodes instead
04:37:33 <ski> honeywhite : practice
04:38:08 <honeywhite> @ski that's actually not a problem at all.  It's a straightforward "g" to "j", "x" to "c" type thing
04:38:08 <lambdabot> Maybe you meant: wiki src ask
04:38:56 <bernalex> honeywhite: on IRC we use 'nick:' to highlight each other.
04:38:56 <honeywhite> More or less it can be accomplished with UNIX tr but I don't want to lug around Cygwin wherever I go and need to use this
04:39:16 <ski> honeywhite : fyi, it is not customary on IRC to prepend a `@' to the nicks of people
04:39:19 <bernalex> honeywhite: starting a post with '@' is historically reserved for bots, which makes lambdabot whinge when you do it.
04:39:21 <honeywhite> bernalex: sorry about that
04:39:25 <bernalex> honeywhite: NP.
04:39:42 <ski> (also, lambdabot will be confused if you do it at the start of a line)
04:40:23 <honeywhite> the only time I ever frequented IRC was when I was trying to hammer out a new Gopher RFC (i.e. Internet engineering/IETF work)
04:41:44 <honeywhite> I just started learning H. yesterday---been trying to do it all month, but I'd heard stuff like "H. is only good for mathematical programming"
04:42:04 <liste> actually it's not that good for numerics :(
04:42:13 <honeywhite> which SEEMED to be the case when reading just the first couple chapters of LYAH
04:42:31 <honeywhite> but honestly I can see all manner of stuff written with it
04:42:56 <honeywhite> and certainly more useful than, say, Turbo Pascal :D
04:42:57 <bernalex> honeywhite: haskell is a general-purpose language.
04:43:22 <bernalex> honeywhite: here is a study of what it excells at: http://www.haskellforall.com/2015/08/state-of-haskell-ecosystem-august-2015.html
04:43:38 <honeywhite> then I heard stuff like "H. will make your brain a splode", which is more or less true
04:44:50 <honeywhite> Yeah, I was labouring under the misapprehension that H. is basically Matlab on steroids---turns out I was greatly mistaken]
04:45:07 <bernalex> R is matlab on steroids. the good kind of steroids. :)
04:47:08 <liste> (modern) fortran is matlab with a caffeine overdose
04:49:24 <honeywhite> Ehh, I did write some teddy-bear programs with Fortran 68, and it sure wasn't a purely mathematical language
04:49:40 <mission712> ##socialDawgs waaa
04:49:56 <honeywhite> I mean, you COULD theoretically write a perfectly good payroll programme in Fortran...
04:50:04 <honeywhite> but that's why there's COBOL
04:50:28 * liste has a horrible vision of a payroll program written in Matlab
04:51:23 <honeywhite> But I do concede that at the university where I study (Durham) Fortran is not taught by the compsci department, but (surprisingly) by the chemistry department
04:51:58 <honeywhite> I wonder if you could do it in Haskell.  :D
04:53:38 <honeywhite> I mean, I don't think you could easily write a payroll program or a simple game in, say, Prolog
04:54:06 <delYsid> I need a monad intro pointer.  I did some Haskell roughly 10 years ago.  Really loved the type system and simple syntax, but went stuck when it came to IO and stateful monads.  After a while, I gave up on it.  Today, I am coming back to Haskell via Propellor (the orchestration tool).  I'd like to tailor Propellor to my needs.  Much of what I read, I do already recognize.  But when it comes to understanding how it makes use of monadic
04:54:06 <delYsid> stuff, I am seemingly going stuck again.  I gather documentation has improved the last 10 years :-)  Anything you'd like to point me at especially?
04:54:24 <liste> delYsid start with functors and applicatives
04:54:39 <liste> @where typeclassopedia
04:54:39 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
04:54:46 <merijn> delYsid: There's only one explanation worth (well, maybe two if you count Wadler's paper), which is
04:54:55 <merijn> @google you could've invented and maybe you already have
04:54:57 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
04:54:57 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Al...
04:55:00 <merijn> That one
04:58:18 <lunaris> Anyone here used CORS with Spock?
05:02:53 <roelof> what do you experts think of my final solution here : https://www.reddit.com/r/haskellquestions/comments/3k9s53/how_to_test_this_with_quicktest/
05:06:26 <greg`> whats the word on the street about stackage, is it worth it or should i hold out for the new non conflicting cabal
05:07:44 <merijn> greg`: Yes, no, maybe :)
05:08:08 <merijn> greg`: I've heard people say it's better than sex, is absolutely terrible, or is no worse/better than cabal
05:08:16 <Gurkenglas> Can MaybeT be used to implement unfoldM? https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:unfoldM
05:08:21 <merijn> So basically, you'll have to try and see if it works for you
05:09:37 <greg`> merijn: im trying to work out how cabal compares to sex now , and i must admit im none the wiser
05:09:50 <Jules_> does anybody know a good introduction to (n,k)-category theory?
05:13:24 <hexagoxel> greg`: well, for cabal i would recommend always doing it in a sandbox..
05:15:52 <greg`> hexagoxel: usually yes , but i hear theres a super cabal in development by the infamous mr yang, that is more nix like and will remove the need for sandboxes
05:16:33 <roelof> greg`:  more nix like ?? 
05:18:02 * hackagebot d-bus 0.1.3.2 - Permissively licensed D-Bus client library  https://hackage.haskell.org/package/d-bus-0.1.3.2 (PhilippBalzarek)
05:19:25 <roelof> but no - one can say if my solution is good Haskell ?? 
05:19:54 <hexagoxel> greg`: phew, you interpreted my statement just as intended :)
05:22:54 <merijn> greg`: It'll be awhile before that's all finished and complete
05:23:02 * hackagebot period 0.1.0.2 - Parse and format date periods, collapse and expand their text representations.  https://hackage.haskell.org/package/period-0.1.0.2 (alkar)
05:23:43 <greg`> http://goo.gl/oeAd0b
05:25:12 <sperminator> !help
05:25:15 <sperminator> `
05:25:17 <sperminator> `help
05:25:20 <sperminator> @help
05:25:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:25:28 <sperminator> @list
05:25:28 <lambdabot> What module?  Try @listmodules for some ideas.
05:25:33 <sperminator> @listmodules
05:25:33 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
05:25:46 <sperminator> @list hoogle
05:25:47 <lambdabot> hoogle provides: hoogle hoogle+
05:25:53 <sperminator> @help hoogle
05:25:53 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
05:25:55 <darthdeus> @dice
05:25:55 <lambdabot> unexpected end of input: expecting number, "d" or "("
05:25:59 <sperminator> lol
05:26:01 <darthdeus> @dice 3
05:26:01 <lambdabot> unexpected end of input: expecting digit, operator or end of input: no rolls in expression
05:26:11 <darthdeus> @help dice
05:26:11 <lambdabot>  @dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
05:26:16 <sperminator> @dice 3d28
05:26:16 <lambdabot> sperminator: 19+18+28 => 65
05:26:22 <darthdeus> hehe
05:26:23 <sperminator> ^
05:26:25 <merijn> Please experiment in private message
05:26:26 <sperminator> (:)
05:26:29 <sperminator> ok
05:26:29 <darthdeus> sorry
05:28:35 <Denommus> gosh
05:28:50 <Denommus> someone is insisting on ##programming that you can get a Monad out of any Applicative
05:28:52 <Denommus> holy hell
05:29:41 <capisce> should be easy to demonstrate if it were the case
05:30:03 <merijn> Denommus: Well you can get *a* monad out of any applicative...
05:30:05 <Denommus> yeah, I asked him to produce the join function out of Applicative operations, and he can't
05:30:10 <merijn> Denommus: Just not the same Monad as that type :)
05:30:40 <merijn> Denommus: You can build a Free monad for every functor, therefore you can do so for every Applicative and get *a* Monad out of any Applicative
05:30:42 <capisce> is Haskell often discussed on ##programming ?
05:30:45 <greg`> i think you can get a monad out of any functor, and i think applicative is a functor so yes
05:30:47 <merijn> capisce: Yes
05:30:59 <roelof> what do you experts think of my final solution here : https://www.reddit.com/r/haskellquestions/comments/3k9s53/how_to_test_this_with_quicktest/
05:31:07 <merijn> capisce: There's a strong contigent of strongly typed FP people there
05:31:15 <merijn> capisce: And the mandatory lisp weenies
05:31:23 <liste> sounds like a battlefield
05:31:23 <capisce> nice mix
05:31:41 <merijn> Denommus: So depending on what both of you are meaning, your either both right or both wrong or any mix of those two :p
05:31:58 <Denommus> capisce: quite frequently
05:32:38 <frerich> roelof: In 'threeDifferent x y z = ( x == y ) && ( y == z)' isn't the function name a bit misleading? Wouldn't "threeEqual" be a better fit?
05:32:55 <Denommus> merijn: I was talking about Alternatives, which are something with more structure than an Applicative
05:33:18 <roelof> oops, then I made a error . The function has to check if 3 digits are not the same 
05:35:16 <ankitk> hi, I am trying to install hmp3 in cabal
05:35:22 <ankitk> but getting this error
05:35:23 <ankitk> http://lpaste.net/45177
05:35:37 <ankitk> can someone pls advise what to do now ?
05:36:29 <frerich> roelof: Maybe it's a bit overkill, but it might have been nice to define a function like 'allUnique :: Ord a => [a] -> Bool' which tells whether each element in the input list appears exactly once. You could then define 'threeDifferent x y z = allUnique [x,y,z]' and 'fourDifferent a b c d = allUnique [a,b,c,d]'
05:36:35 <liste> ankitk try updating (n)curses
05:37:03 <ankitk> ankitku@Ankits-MacBook-Pro~$ brew install ncurses Warning: ncurses-5.9 already installed
05:37:17 <ankitk> i have ncurses-5.9
05:37:42 <liste> actually, when I read that further, it looks like a libc problemn
05:37:50 <liste> /usr/include/stdio.h:671:20: note: previous declaration of ‘getline’ was here
05:37:55 <roelof> frerich:  oke, but when I do threeDifferent 1 2 3 then it's not a list I think 
05:38:10 <merijn> ankitk: does your gcc know to use the homebrew version of ncurses?
05:38:12 <hexagoxel> ankitk: uh, you have ghc-7.0.2? that is ancient..
05:38:26 <ankitk> i have ghc 7.10
05:38:32 <frerich> roelof: Right, in 'threeDifferent 1 2 3' there's no list - but if you define 'threeDifferent x y z = allUnique [x,y,z]' then allUnique is called with a list made from the three values passed to threeDifferent.
05:38:49 <ankitk> merijn how to tell that ?
05:39:18 <roelof> oke, that way. Then I have to find out how to check for uniqness in a list 
05:40:00 <roelof> how to interate through a list is not mentioned in the craft book on chapter 3 
05:40:41 <frerich> roelof: Right. There's a fairly concise way to do that. You don't need to iterate, but it's useful to know about three standard functions: 'sort' to sort a list, 'group' which groups equal consecutive elements into sub-lists and 'all' which checks whether some predicate applies to all elements of a list.
05:40:55 <hexagoxel> ankitk: ah ok sorry; the paths suggest otherwise.
05:41:26 <roelof> frerich:  oke, I need  all 
05:41:43 <ankitk> oh the pastebin is actually what i found on net
05:41:50 <ankitk> but the problem is same
05:43:08 <roelof> BRB, I have to walk with my dog 
05:43:28 <ankitk> hexagoxel: here is my output
05:43:29 <ankitk> http://pastebin.com/D2gzwdM6
05:45:55 <roelof> frerich:  you mean a solution like this : allTheSame'''' :: (Eq a) => [a] -> Bool allTheSame'''' xs = all (== head xs) (tail xs)
05:46:46 <frerich> roelof: Well rather the opposite - my understanding is that you need to test whether all elements are *different*, i.e. none of them appears more than once (and that particular definition would not work well for empty lists)
05:47:04 <frerich> roelof: but yeah, that's an example of how to use 'all'
05:48:03 * hackagebot gll 0.3.0.0 - GLL parser with simple combinator interface  https://hackage.haskell.org/package/gll-0.3.0.0 (ltvanbinsbergen)
05:48:05 * hackagebot blaze-shields 0.1.1.2 - create svg by Haskell  https://hackage.haskell.org/package/blaze-shields-0.1.1.2 (Qinka)
05:48:27 <roelof> frerich:  for me the == will be /= 
05:48:58 <suppi> recommended frp system anyone?
05:48:59 <frerich> roelof: You mean 'all (/= head xs) (tail xs)'? That would check whether all elements are different than the first one.
05:49:34 <suppi> (and documentation/tutorial for it?)
05:49:42 <roelof> frerich:  oke, not right. Back to the drawing table :( 
05:50:07 <frerich> roelof: I'd suggest to play with 'sort' and 'group' to see whether you can think of a solution using those.
05:50:48 <roelof> frerich:  oke, first google what sort and group exactly does 
05:51:42 <frerich> roelof: How boring. Try it in ghci! :-)
05:52:24 <frerich> roelof: Compare e.g. 'sort [5,5,1,4,2,3,3,1,2]' and 'group [5,5,1,4,2,3,3,1,2]' and 'sort (group [5,5,1,4,2,3,3,1,2])'.
05:52:31 <frerich> err
05:52:34 <frerich> group (sort [5,5,1,4,2,3,3,1,2])
05:52:42 <roelof> I can do that also. Fine thing to do the next few days / hours 
05:53:02 <frerich> I'm sure it won't take that long. There's not much to those functions ;-)
05:53:03 * hackagebot smallcheck-lens 0.3 - SmallCheck properties for lens  https://hackage.haskell.org/package/smallcheck-lens-0.3 (jdnavarro)
05:53:10 <mietek> Does Haskell have anything like Agda/Idris mix-fix binders?
05:55:28 <mietek> hmm. CPP...
05:56:19 <Philonous> mietek, Haskell does not have mix-fix, no. Though there are some hacks to emulate it, IIRC
05:56:32 <mietek> Any examples?
05:59:24 <Philonous> See http://hackage.haskell.org/package/esqueleto-2.4.1/docs/Database-Esqueleto.html#v:case_
05:59:59 <Philonous> when_ , then_ and else_ are set up to look like they are mix-fix
06:00:14 <mietek> Cheers
06:10:11 <roelof> frerich:  problem : Not in scope: ‘sort’ I think I need lists/sort ?? 
06:10:25 <frerich> roelof: Right, you need to 'import Data.List'
06:12:03 <roelof> frerich:  then I see this output : http://lpaste.net/140654
06:12:32 <Profpatsch> Is there some work on lenses in a dependent type system?
06:13:04 * hackagebot tasty-lens 0.3 - Tasty TestTrees for Lens validation  https://hackage.haskell.org/package/tasty-lens-0.3 (jdnavarro)
06:13:15 <Profpatsch> Yesterday our FP group had a lenses introductory presentation.
06:14:03 <Profpatsch> The lenses lens is Lens s t a b, where s transforms to t because some element(s) transform(s) from a to b
06:15:10 <Profpatsch> But all the information of that trasformation should be in the values already, so we thought that in a dependently typed language it should be possible for the lens type to be Lens a
06:15:17 <Profpatsch> Or maybe Lens a b
06:15:42 <Profpatsch> Where a is the data structure and b is the transformed value.
06:16:01 <Profpatsch> You probably don’t even need b, because you know the transformation.
06:23:05 * hackagebot xlsx 0.1.1 - Simple and incomplete Excel file parser/writer  https://hackage.haskell.org/package/xlsx-0.1.1 (KirillZaborsky)
06:25:38 <jameseb> roelof: you need a comma between the first two 5s, it sees you applying a 5 to a 5 and assumes it's a list of functions then gets puzzled as to how to turn numbers into functions
06:29:00 <delYsid> merijn: nice document.  I kind of get the idea, actually, I kind of got it in 2005 already... However, I feel the style these intros use are confusing me, since they start with deliberately strangely named identifiers, only to later tell me that in actual haskell, they are called something else.  What I am actually missing are some sort of real-world patterns explained.  Whenever I see liftM or mapM or ifM, I kind of get their intent,
06:29:00 <delYsid> but I am lost on the actual type madness.  I'D really love to see someone explain monads based on a real world application of them.
06:29:35 <delYsid> Because that is what I am faced with, I'd like to grok and further modify the monadic interna of an existing codebase that is roughly 10kloc...
06:30:42 <roelof> jameseb:  thanks, stupid typo 
06:33:06 <delYsid> I feel like I am not able to manage the semicolon :-)  Which is really quite depressing.  Any other language I know of, I can sort of hack an existing codebase after a few days of (re)familiarizing myself with the actual language.  But with Haskell, this is really different.
06:34:31 <roelof> another question : when I do sort(group [ 5,5,1,4,2,3,3,1,2]) I see this output : [[1],[1],[2],[2],[3,3],[4],[5,5]]
06:34:45 <roelof> how can I check how many items that list have ? 
06:34:59 <jameseb> delYsid: semicolon?
06:39:37 <frerich> roelof: You can use 'length' to check how many items a list has.
06:40:03 <c_wraith> roelof: beware that sometimes lists don't end, so length never returns.
06:40:12 <chpatrick> delYsid: you'll get the hang of it eventually
06:40:17 <delYsid> jameseb: I dont know how the Haskeller calls it, I really mean the C-style ; :-)  i.e., I totally get simple functions, compositions, partial functions and whatnot, but as soon as I need some kind of side effect, or global state/data, I am so totally lost, it is not funny anymore.
06:40:24 <chpatrick> maybe write something small before tackling the 10k loc codebase?
06:40:48 <chpatrick> or just implement some monads yourself
06:40:54 <chpatrick> make your own maybe and write all the instances for it
06:41:16 <roelof> frerich:  I know that but  sort(group [ 5,5,1,4,2,3,3,1,2]) . length and (sort(group [ 5,5,1,4,2,3,3,1,2])) . length  gives error messages 
06:41:31 <delYsid> thats my point, I dont want to reinvent an existing wheel to learn about it.  I'd much rather prefer to be shown how to use a wheel in real world.
06:41:36 <chpatrick> roelof: you need length . 
06:42:08 <chpatrick> delYsid: I think that makes sense if you're using some big library and you don't care how it works
06:42:16 <chpatrick> but the basic monads are the bread and butter of haskell programming
06:42:23 <chpatrick> you need to know what's going on before you really get it
06:42:24 <jameseb> delYsid: you mean do notation? or do you mean that you don't get what Haskell uses to do the semantics of C's ;?
06:42:56 <geekosaur> roelof, somehow I think you have some language confusion still
06:43:11 <delYsid> The monad learning approaches I've seen so far all kind of feel like you're forcing a small child to build a bike from scratch, before you let it use one.  I kind of feels paradox to me.
06:43:13 <roelof> geekosaur:  I know 
06:43:18 <geekosaur> your two examples there look more like python than haskell; in particular they seem to think that (.) is a method call
06:43:41 <chpatrick> the thing is though that stuff like Maybe are really simple things
06:43:50 <roelof> chpatrick:  length . does not work. See http://lpaste.net/140656
06:43:51 <chpatrick> the kind of thing that's a language feature in other languages
06:44:07 <chpatrick> roelof: you want length . sort . group
06:44:08 <c_wraith> delYsid: that problem usually shows up when you expect Monad to have some additional concrete meaning on top of the types and laws.  But it doesn't.
06:44:27 <c_wraith> delYsid: monad is an abstraction that's almost free of meaning.
06:44:34 <frerich> roelof: Don't bother playing with "." for now. Just use parentheses. E.g. "length (group (sort [...]))"
06:44:49 <frerich> roelof: That'll do what you think it does.
06:45:17 <jameseb> delYsid: c_wraith is right, Monad is just a typeclass with some laws that instances are expected to follow
06:45:40 <chpatrick> if you don't know what these things do you can't really use them
06:45:55 <frerich> chpatrick: Challenge accepted!!
06:46:07 <jewel> how can I generate the list [1,11,21,31,41 ...] ?
06:46:16 <chpatrick> it's like saying "I want to just use exceptions in Java without having to know what is happening"
06:46:24 <geekosaur> > [1, 11..]
06:46:26 <lambdabot>  [1,11,21,31,41,51,61,71,81,91,101,111,121,131,141,151,161,171,181,191,201,21...
06:46:37 <chpatrick> most common monads in haskell are more like that
06:46:53 <chpatrick> rather than some library that you call and don't need to understand
06:46:59 <delYsid> chpatrick: well, sort of a bad example, because exceptions aren't really that hard to grok, even if you dont get their internas fully...
06:47:15 <chpatrick> Maybe isn't hard to grok either
06:47:34 <delYsid> c_wraith: Yeah, I think I know what you are telling me, and I think in some sense I already know that.  What I am missing is, how to apply the basic building blocks to real world programming patterns.
06:48:05 * hackagebot yesod-pnotify 1.1.1 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-1.1.1 (KatsutoshiItoh)
06:48:17 <chpatrick> can you explain where you're stuck?
06:48:36 <glaukon> Heap overflow question, please help! http://stackoverflow.com/questions/32520595/heap-overflow-in-haskell
06:50:14 <roelof> frerich:  thanks, so I can check with the length of the group sort if all numbers are the same. When the length == 1 they are the same otherwise they are not the same
06:51:52 <frerich> roelof: If the length of the list produced by 'group' is 1, then all elements are equal. If the length of *each element of* the list produced by 'group' is 1, then all elements are different. :o]
06:53:06 <delYsid> chpatrick: I wish I could.  I guess what would help me the most would be a monadic cookbook.   Something I could use to lookup common idioms.  Things like, how to deal with global state, which of the library provided modules to use in what situation (Control.* and friends).
06:54:57 <delYsid> And an easy reference for crazy symbols.  I recently saw something like <<=< (I dont even remember it exactly) which really confused me
06:55:56 <dutchie> https://www.haskell.org/hoogle/?hoogle=%3C%3D%3C ?
06:57:15 <voidzero> :t (>=>)
06:57:17 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
06:58:00 <clrnd> :t liftM2 (.)
06:58:02 <lambdabot> Monad m => m (b -> c) -> m (a -> b) -> m (a -> c)
06:58:17 <jameseb> delYsid: state can be handled with the State type (which is a Monad); for which modules to use I would suggest getting familiar with the other typeclasses beyond Monad so you know when those would be more appropriate, try reading typeclassopedia; for finding functions, use hoogle
06:58:32 <roelof> frerich:  thanks for the lessons. I try to implement this , this evening. Now my daugther is back from school and she wants to have some attention 
06:59:32 <frerich> roelof: Alright, have fun! Good to see you have your priorities straight. :-)
07:00:15 <quicksilver> old enough to go school == old enough to teach her dad haskell!
07:00:16 <quicksilver> :)
07:00:19 <roelof> frerich:  for me programming is a hobby so it's always family first 
07:00:39 <quicksilver> (or mum, apologies for assuming gender)
07:00:58 <roelof> quicksilver:  I do not think so. she is mentally disabled if I use the right words 
07:01:04 <frerich> roelof: For me programming is a job and a hobby, but ever since my (now 5yr old) son was born I appreciated the behaviour of vim - I can have him hammer on the laptop keyboard and nothing happens. :)
07:01:10 <roelof> quicksilver:  I am a man 
07:01:48 <apo_> frerich: until he starts leaning on d
07:01:50 * quicksilver nods
07:02:02 <voidzero>  qap
07:02:11 <apo_> or i :D
07:02:36 <voidzero> 'dap' even
07:02:42 <roelof> no, im stuck on haskell :) I do try to learn two languages at one moment 
07:03:19 <voidzero> speaking of real lives,  need to take come care of my own, ttfn
07:03:25 * hackagebot memexml 0.0.3 - Library for reading Meme XML output  https://hackage.haskell.org/package/memexml-0.0.3 (FlorianEggenhofer)
07:07:25 <pkkm2> hi, does the standard library contain a division function that rounds up? or should I just define something like: divUp n m = n - (n `div` m)
07:08:59 <frerich> Err, that definition is confusing. So `divUp 5 5` should yield `4`?
07:09:06 <pkkm2> sorry, should be divUp n m = n + (if n `div` m > 0 then 1 else 0)
07:09:40 <pkkm2> err, divUp n m = n + (if n `mod` m > 0 then 1 else 0)
07:10:13 <Gurkenglas> You mean div n m = (div n m) "mathegrundlagen & literaturanschluss" ist eine Einfhrung in das Themengebiet, in der erklrt wird was es auf sich hat mit Stitching, Registrierungen und Co, und wo man mehr darber finden kann. Der Beitrag dieser Arbeit wird auch angesprochen.
07:10:13 <Gurkenglas> "Algorithmus" leitet verschiedene Lsungswege her und erlutert sie.
07:10:13 <Gurkenglas> "Experimente" zeigt Ergebnisse dieser Lsungswege und wertet sie aus.
07:10:19 <Gurkenglas> Sorry bad paste
07:11:59 <nakilon> hi guys; there is a young programming language and there are debates about how and which 'fold' function to implement in it -- I'm here to ask you for nice examples why do we need 'foldr'; thanks
07:12:07 <frerich> pkkm2: What would you expect if the two values have a different sign? E.g. 5 `divUp` (-2)?
07:12:16 <frerich> pkkm2: As it is, that yields 5.
07:13:34 <clrnd> nakilon, why not both?
07:13:39 <clrnd> is it a strict language?
07:13:50 <merijn> nakilon: foldr is strictly more expressive than foldl
07:14:03 <merijn> nakilon: You can implement foldl using foldr, but not vice versa
07:14:12 <clrnd> there is a difference in their associativities too
07:14:16 <frerich> pkkm2: If you always want to round to the larger number, you could use 'divUp n m = ceiling (n / m)'
07:14:40 <clrnd> (fun fact: Data.Foldable.foldl' is implemented with foldr)
07:14:44 <merijn> clrnd: That's irrelevant, since you can implement foldl using foldr, so...
07:14:55 <merijn> The associativity is then fixed too
07:15:28 <clrnd> merijn, everything can be implemented in terms of other functions which together are turing complete, I guess
07:15:31 <merijn> nakilon: If you are of a more theoretical persuasion there's an excellent tutorial/paper on how any primitive recursive function can be implemented using fold + a trivial helper :)
07:15:49 <clrnd> I think he is talking about what to provide in the stdlib
07:17:50 <delYsid> Ahh, the Typeclassopedia looks like it might be what I was looking for... It tells me about fmap.  I ask myself: And why fmap, not just map?  And the document answers that.  Looks like it was written for me :-)
07:18:26 * hackagebot docopt 0.7.0.4 - A command-line interface parser that will make you smile  https://hackage.haskell.org/package/docopt-0.7.0.4 (ryanartecona)
07:23:08 <asciiascetic> I'm curious about people's experiences with the transient package. For what have people used it? Why might they have stuck with it? 
07:23:22 <pkkm2> frerich: yeah, I want something equivalent, but working with arbitrary precision integers. thinking about it now, divUp n m = (n `div` m) + (if n `mod` m == 0 then 0 else 1) seems to be a correct definition. is something like this already in the standard library? (sorry for being confusing, I'm a bit sleep deprived and started learning haskell yesterday.)
07:25:26 <nakilon> clrnd, foldl will be definetely implemented -- the question is in naming, because if foldr will be considered important they'll be called 'foldl' and 'foldr', otherwise it will be 'reduce' or smth
07:28:26 * hackagebot language-lua-qq 0.1.0.0 - Initial project template from stack  https://hackage.haskell.org/package/language-lua-qq-0.1.0.0 (HiromiIshii)
07:30:34 <nakilon> merijn, isn't "ability to express foldl via foldr but not vice versa" a Haskell-syntax-specific issue?
07:31:01 <merijn> nakilon: No
07:31:04 <nakilon> I'm newb in Haskell, just joined here for expertise on folding
07:31:29 <merijn> nakilon: You might be able to do foldr using foldl if you only have finite lists, I'm not sure about that
07:32:16 <syntagma> Hello everyone
07:32:52 <syntagma> What are the most advanced Haskell libraries? I am looking for something which is for Haskell what Boost is for C++. Something written by very experienced Haskell programmers.
07:32:57 <merijn> Is there a way to not export typeclass functions? (Obviously I can't hide the typeclass, but I want the class to be visible but the functions in it unusable by users)
07:33:08 <frerich> nakilon: Is your language strict, i.e. are arguments evaluated before a function is applied to them?
07:33:17 <merijn> syntagma: Advanced as in difficult or as in "does cool things"?
07:33:29 <merijn> syntagma: conduit, pipes, async, and lens come to mind
07:33:52 <frerich> syntagma: I think the entire STM stuff is pretty much leading edge
07:34:26 <merijn> STM is a bad example, I think since large parts are tied directly into the runtime/GHC :)
07:35:23 <Philonous> merijn, You can give an explicit list of class members to export, as in Class(member1, member2,...) 
07:35:37 <merijn> Philonous: Can people still implement the hidden function then?
07:35:57 <Philonous> That's a good question, I don't know.
07:36:02 <syntagma> merijn: advanced as in difficult but efficient and preferably readable
07:36:05 <frerich> merijn: I think I may have misunderstood the question, I thought the intention was to find some Haskell libraries which show off what you can do with the language which other languages struggle with.
07:36:24 <merijn> Philonous: Apparently you can't >.>
07:36:33 <Philonous> Isn't that the point?
07:37:07 <merijn> Philonous: No, my class should be implementable by people, but the functions used in it should never be directly used. They should use my wrapper combinators
07:37:29 <merijn> I'll probably move the class to .Class with a "DON'T USE!!!" warning in the docs
07:37:51 <bartavelle> merijn, have the function return something that is like Identity but for which only a constructor function exists ?
07:38:11 <nakilon> frerich, list lazyness is possible https://github.com/manastech/crystal/issues/1167
07:38:11 <Philonous> merijn, I like that approach better, anyway
07:38:26 <merijn> bartavelle: That just makes implementing it more annoying than it already is
07:38:40 <bartavelle> merijn, I believe what you try to do is annoying in itself :p
07:38:53 <merijn> bartavelle: Why?
07:39:04 <nakilon> frerich, or should be, because the language is supposed to be as close to Ruby as possible
07:39:22 <bartavelle> nah, just j/k, about the fact that you get to implement a function and then you get told you can't use them
07:39:46 <Philonous> merijn, I often end up needing some low-level stuff from a library that the author decided to hide.
07:39:57 <merijn> bartavelle: The typeclass functions have a high likelihood of being misused. The combinators I write don't :)
07:40:27 <bartavelle> interesting !
07:41:08 <ski> nakilon : /wg #haskell-in-depth
07:41:20 <ski> (mispaste)
07:41:23 <frerich> nakilon: FWIW I think the argument given in favor of reduce (" It just makes more sense. You're reducing a sequence of values to some single answer;") is bogus, since that single value may be a sequence, too.
07:41:29 <merijn> bartavelle: Mostly because 1 of them is an ugly hack to work-around the deficiency of GHC's Lift class atm
07:41:40 <nakilon> ski, already there )
07:42:41 <ski> nakilon : i was about to say that with the usual `foldr'-based Church representation of a list, you place the first element in front of the rest, which might be more natural, depending on how you want to generate the list ..
07:42:44 <clrnd> nakilon, I always hated python's `reduce`, it's unnecesarily ambiguous, I'd go with foldl and foldr, you just don't loose anything
07:42:58 <clrnd> lose
07:43:05 <ski> nakilon : .. but i'm not sure whether that would matter to you
07:43:21 <ski> (it's sortof tangential)
07:44:00 <clrnd> he is specifically talking about a method for some Enumerable interface
07:44:17 <nakilon> for Array
07:44:44 <nakilon> Enumerable will be sure foldl only, at least for next few years ..)
07:45:22 <nakilon> but can't be sure about such young language
07:45:38 <xikuuky> Hey guys, I need some help. I really like languages like Haskell, Clojure, F#, functional etc; but I really have a hard time understanding functional programming. I am used to OOP and Procedural. Help?
07:46:23 <Clint> i also like things that i do not understand
07:46:57 <xikuuky> Clint: I knew I wasn't the only one.
07:47:08 <xikuuky> :P
07:47:10 <nakilon> I mean if implement the foldr, it won't be important to be usable for all kinds of lists, but at least for precalculated 'Array's will it be useful or not -- that is the questions guys are talking it that Github issue
07:47:37 <nakilon> *in that
07:51:20 <glguy_> Merijn: the Read class among others have two sets of methods. To implement some you need to import a different module. That might be an approach you could use
07:51:32 <xikuuky> Can someone show me a very simple function in Haskell and explain like every word of it? I'm really bad at this. :(
07:51:41 <merijn> glguy_: Yeah, I'm using a ".Class" module now
07:52:11 <ski> nakilon : if you're supporting infinite lists/streams, then `foldr' could possibly be a useful operation on them
07:56:01 <sunnymilk> is there a library that can parse html/xml and run xpath queries that isnt hxt-xpath
07:56:48 <sunnymilk> ideally one that is type safe (ie, failed parses/queries will present as a different constructor)
07:57:14 <merijn> sunnymilk: I've used html-conduit and xml-conduit with decent success
07:57:30 <merijn> sunnymilk: The API is mostly inspired by xpath
07:58:14 <merijn> sunnymilk: I wrote a simple scraper for a webcomic archive using it together with http-conduit (which plug nicely into eachother): https://gist.github.com/merijn/d8188ddd129718ffcfb0
07:59:03 <sunnymilk> i see, thank you!
07:59:36 <merijn> sunnymilk: I've seen a lot of people complain hxt is confusing/obtuse, I've never tried. But I thought the conduit libraries were fairly straightforward to use
08:00:22 <sunnymilk> theyre obtuse but the worst part is how they dont use the type system
08:01:11 <sunnymilk> failed parses/queries that dont return anything use the same type as successful parses/queries that return things
08:01:20 <sunnymilk> if you do an xpath query and it doesnt match anything, you get []
08:01:38 <merijn> sunnymilk: Right html-conduit just returns a list of matching nodes
08:01:48 <sunnymilk> if you parse and it fails, you get some weird xml ast that contains a text string saying what failed
08:02:11 <sunnymilk> i might like to give that a try
08:03:58 <Geekingfrog> Any idea why searching for (<>) on hoogle only return stuff from template haskell and pretty-print (and not Data.Monoid for example) ?
08:05:13 <Ankhers> Geekingfrog: Not sure. Hayoo finds it though.
08:05:36 <KaneTW> Geekingfrog: (<>) is a method
08:05:50 <Geekingfrog> oÔ first time I see hayoo, how does it compare to hoogle ?
08:06:12 <Ankhers> This is actually the first time I've used it.
08:06:23 <haskell828> can someone help me with randomR function?
08:06:27 <haskell828> http://lpaste.net/140661
08:06:31 <Ankhers> But there have been a couple improvements to it if I'm not mistaken.
08:06:31 <haskell828> i cant get it to work..
08:06:36 <Ankhers> (recent improvements)
08:06:53 <Geekingfrog> ok, good to know if I don't find something on hoogle I'll try this one
08:07:06 <mauke> hayoo searches more libraries
08:07:29 <clrnd> haskell828, what would be the error?
08:07:41 <haskell828>  Couldn't match expected type `Integer' with actual type `StdGen'
08:07:49 <clrnd> oh
08:07:59 <dramforever> :t System.Random.randomR
08:08:00 <clrnd> haskell828, where rNr = randomR (1 ,(size (Add c1 h1))) r
08:08:00 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
08:08:11 <clrnd> you are passing a tuple even though you don't expect one, I think
08:10:30 <clrnd> nakilon, btw foldl can't handle infinite lists by definition, it starts at the end
08:10:41 <ski> haskell828 : perhaps instead of `rNr = randomR (1 ,(size (Add c1 h1))) r' you wanted something like `(n,r2) = randomR (1 ,(size (Add c1 h1))) r' ?
08:11:04 <Ankhers> haskell828: There also isn't really a point in the where clause in your `randomInt' function.
08:18:01 <glguy`> Haskel828 : you'll need to thread the updated StdGen around to each randomR use
08:18:41 <glguy`> And to deal with that function returning a tuple of the random number and also the updated gen
08:20:41 <roelof> what type is a list for this line : allEqual:: List -> Bool 
08:22:23 <CpnStumpy> are the and monoid and the or monoid - comonoids of eachother?
08:22:24 <clrnd> roelof, sorry I don't understand
08:22:47 <roelof> found it already it has to be [Num] instead of List 
08:22:57 <clrnd> Num a => [a] ?
08:23:11 <clrnd> ok
08:23:28 * hackagebot yesod-pnotify 1.1.2 - Yet another getMessage/setMessage using pnotify jquery plugins  https://hackage.haskell.org/package/yesod-pnotify-1.1.2 (KatsutoshiItoh)
08:25:56 <ski> CpnStumpy : what do you mean by "comonoid" ?
08:26:02 <merijn> Is Hackage suddenly slow for anyone?
08:28:28 * hackagebot validated-literals 0.2.0 - Compile-time checking for partial smart-constructors  https://hackage.haskell.org/package/validated-literals-0.2.0 (MerijnVerstraaten)
08:28:39 <pavonia> merijn: Not for me
08:28:40 <merijn> Is there a way to link to example files on Hackage from haddock?
08:28:49 <merijn> pavonia: It's fixed, as you can see by hackagebot ;)
08:29:15 <roelof> how do I make this type signature work : http://lpaste.net/140664. Allequal still give some errors 
08:29:26 <CpnStumpy> ski: I guess I'm asking what a comonoid is in a round about way... I just find it interesting how I can combine and and or monoids to get two different behaviours: One's for fallback on mempty, the other's for halt on mempty. I use both monoids symbiotically to create a decision tree in a way, is that symbiosis a side effect of being duals?
08:29:39 <tulcod> i remember there being this article about finding the fastest way to convert some (byte?)string into an Int, just in haskell (i.e. without C's atoi), which (iirc) concluded that it was quite useful to improve Warp performance. does anyone know where i can find that article?
08:30:15 <CpnStumpy> ski: I do the same with the Maybe monoid sometimes by creating an alternative implementation that instead of halting on mempty will halt on non-mempty
08:30:41 <clrnd> roelof, doesn't group return [[a]]?
08:30:50 <clrnd> :t Data.List.group
08:30:51 <lambdabot> Eq a => [a] -> [[a]]
08:31:29 <CpnStumpy> or rather, instead of choosing mempty will choose non-mempty
08:31:42 <roelof> oke, so I have to enter the type signature of each step (group and sort) also ?? 
08:31:58 <clrnd> roelof, no, the thing is that sort wants [a] and you are giving it [[a]]
08:32:14 <ski> CpnStumpy : well .. a comonoid to me is something different from a monoid. in the usual set theoretical universe, all comonoids are trivial
08:32:21 <clrnd> unless you are ussing [[a]]'s Ord instance
08:32:30 <clrnd> :t sort [[1]]
08:32:31 <lambdabot> (Num t, Ord t) => [[t]]
08:32:43 <roelof> wierd on ghci I could sort [ 1,1] , [3,3], [2.2] 
08:32:52 <merijn> btw, if someone can have a look at the docs I just uploaded, I'm curious if there's any comments on them
08:32:53 <clrnd> you can
08:32:53 <ski> CpnStumpy : i suppose one might say `All' and `Any' are dual to each other, in some sense
08:33:05 <geekosaur> didn't you want to sort the input to group, not the output?
08:33:10 <clrnd> > sort $ group [1..5]
08:33:12 <lambdabot>  [[1],[2],[3],[4],[5]]
08:33:40 <merijn> https://hackage.haskell.org/package/validated-literals
08:33:56 <clrnd> rofer, what's the error you are getting?
08:34:42 <CpnStumpy> ski: I guess, if a monoid has an identity element that has no effect on the rest of the set elements, is it fair to call it a comonoid if the identity element is the *only* element that effects the output?
08:34:51 <roelof> clrnd:  this one : http://lpaste.net/140666
08:35:13 <clrnd> roelof, oooooh, ((==) etc..)
08:35:22 <clrnd> == is infix
08:35:26 <ski> CpnStumpy : a comonoid has a "coidentity" and a "cocombination"
08:35:44 <CpnStumpy> ski: yeah, those are kind of the duals I'm thinking in terms of I guess.. like I said, it's a technique I've used often with booleans or `Maybe` or `Either` for creating a decision tree of sorts, us `or` to lead right `and` to lead left kind of thing
08:35:53 <clrnd> :t ((==) (length (sort (group [1..5]))) 1)
08:35:54 <lambdabot> Bool
08:36:00 <clrnd> :t (== (length (sort (group [1..5]))) 1)
08:36:01 <lambdabot>     Couldn't match expected type ‘Integer -> a’ with actual type ‘Int’
08:36:02 <lambdabot>     The function ‘length’ is applied to two arguments,
08:36:02 <lambdabot>     but its type ‘[[Integer]] -> Int’ has only one
08:36:22 <ski> CpnStumpy : a "coidentity" is not an element. it's a way to get rid of an element. and a "cocombination" is, in some sense, a way to copy/split an element
08:36:56 <clrnd> rofer, when you use `==` like that you are giving it it's right argument only, so it expects the left one, and the types fail to match
08:36:57 <ski> CpnStumpy : .. so, i believe "comonoid" is not describing the thing you're thinking about
08:37:12 <clrnd> to make it prefix you need to surround it in parens `(==)`
08:37:18 <clrnd> > (==) 1 2
08:37:20 <lambdabot>  False
08:37:35 <roelof> clrnd:  thanks, This one does what I mean 
08:38:50 <clrnd> roelof, no problem. May I ask why are you using prefix notation?
08:39:56 <roelof> I thougth that was the haskell way. Im a beginner who tries a solution that is given on this channel to learn 
08:40:56 <clrnd> roelof, of that's perfectly fine, let me show an alternative I'd consider more "haskell-like"
08:41:24 <roelof> clrnd:  NP, I like to learn the right haskell way 
08:42:36 <clrnd> > let allEquals = (1 ==) . length . sort . group in allEquals [1,1,1,1]
08:42:38 <lambdabot>  True
08:43:32 <clrnd> instead of explicitly building a nested expresion, this says "allEquals is the composition of this functions"
08:43:41 <ski> why is `sort' in there ?
08:43:45 <clrnd> of course your way is perfectly fine too! 
08:45:14 <roelof> clrnd:  oke, then I have to study the in  statement. I did not read about it in the first 3 chapters of Craft 
08:46:01 <clrnd> roelof, that's just for defining the expression for lambdabot, you can ignore that for your purposes
08:47:33 <clrnd> (defining and using it in the same line)
08:47:42 <roelof> clrnd:  how can I use it then on my code ? Everything except the in part ?
08:47:58 <clrnd> allEquals = (1 ==) . length . sort . group
08:47:59 <clrnd> yep
08:49:21 <roelof> and then Haskell knows that the list must be applied ?? 
08:50:11 <Hakim> hi
08:50:21 <Hakim> am new to haskell and would like to get some support
08:50:25 <Hakim> anyone out there
08:50:35 <geekosaur> ski, I already asked if the sort was supposed to be applied to group's input
08:50:40 <geekosaur> I don't think anyone cares >.>
08:50:43 <dutchie> i care!
08:50:49 <Hakim> you suck!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
08:50:50 <dutchie> & i noticed
08:51:01 <roelof> clrnd: apperently ir does.  I see the right answer appear 
08:51:21 <dutchie> maybe it doesn't matter because of lexicographical sorting though
08:51:24 <roelof> Hakim:  what is your question ? 
08:51:31 <geekosaur> roelof, do you? have you tested with something other than [1..5]?
08:51:42 <geekosaur> > group [3,5,3]
08:51:44 <lambdabot>  [[3],[5],[3]]
08:52:11 <dutchie> wait, you don't even need to sort
08:52:13 <roelof> I tried both with 1 1 1  and 1 1 2 . I now try to test it with QuickCheck 
08:52:27 <geekosaur> yes, you missed a significant case
08:52:28 <roelof> geekosaur:  ^^^
08:52:35 <Hakim> can someone please hear me put
08:52:36 <geekosaur> look at what I just asked lambdabot anbd think about it
08:52:36 <Hakim> out
08:52:41 <geekosaur> Hakim, just ask
08:53:41 <roelof> Oke, all the groups must be a length 1. Back to the drawing board 
08:54:16 <Hakim> size :: Num a => Hand -> a
08:54:17 <Hakim> size Empty            = 0
08:54:17 <Hakim> size (Add card hand)  = 1 + size hand
08:54:33 <Hakim> i was given that code and i kinda got confused what it has to do
08:54:54 <Hakim> but in summary, it calculates the size of a collection of cards
08:55:03 <Hakim> which in otherwods is called a Hand
08:55:20 <clrnd> Hakim, you suck
08:55:31 <geekosaur> clrnd, ???
08:55:40 <clrnd> he started :P
08:55:41 <Hakim> what really confuses me is why i have to add a card to a hand to figure out the number of cards in a hand
08:56:13 <dutchie> Hakim: presumably Hand is defined by something like "data Hand = Empty | Add Card Hand"?
08:56:26 <Hakim> exactly
08:56:26 <roelof> geekosaur:  in your case all numbers are not eqaual  3 /= 5 
08:56:27 <geekosaur> Hakim, you are not adding a card to a hand there
08:56:38 <geekosaur> roelof, compare what I did to:
08:56:44 <geekosaur> > group [3,3,5]
08:56:46 <lambdabot>  [[3,3],[5]]
08:56:50 <roelof> and my code says also false , so why is it false 
08:56:59 <CpnStumpy> ski: Can you think of any formal structure or concept that *does* describe the relationship I'm talking about? I'm imagining there is one based on the fact that it is a relationship that I've been able to generalize to use across multiple monoids. I guess the two sides are something like: Chooses mempty over *, and Chooses * over mempty - two binary functions over the same set which have that inverse choosing strategy
08:57:06 <Hakim> thisz how my card custom data type looks like
08:57:07 <Hakim> data Card = Card { rank :: Rank, suit :: Suit }
08:57:07 <Hakim>             deriving (Eq, Show)
08:57:24 <roelof> length is also not 1 so it will be false , geekosaur 
08:57:27 <geekosaur> roelof, actually I think what you did just has a pointless sort, because for all-equal it doesn't matter
08:57:37 <dutchie> Hakim: so as geekosaur said, you aren't really adding a card to a hand. a Hand can either be empty, or it can be a (necessarily smaller) Hand plus another Card
08:57:39 <Hakim> adn thisz my hand function data Hand = Empty | Add Card Hand
08:57:39 <Hakim>             deriving (Eq, Show)
08:57:40 <geekosaur> but if you want to generalize, notice how many groups you get in each case
08:58:19 <geekosaur> Hakim, you are reading the (Add card hand) there as an action. It is instead a pattern: if the hand *looks like* (Add card hand) then ...
08:58:22 <CpnStumpy> it's inverse in the same sense that an else block is the inverse of an if block
08:58:30 * hackagebot temporal-media 0.6.1 - data types for temporal media  https://hackage.haskell.org/package/temporal-media-0.6.1 (AntonKholomiov)
08:58:31 <geekosaur> so any hand will look like Empty or Add something something
08:58:32 * hackagebot csound-expression-typed 0.0.7.8 - typed core for the library csound-expression  https://hackage.haskell.org/package/csound-expression-typed-0.0.7.8 (AntonKholomiov)
08:58:34 * hackagebot csound-expression 4.8.3 - library to make electronic music  https://hackage.haskell.org/package/csound-expression-4.8.3 (AntonKholomiov)
08:58:50 <dutchie> Hakim: try working out how to evaluate "size Empty", then "size (Add x Empty)", and so on
08:58:54 <dutchie> by hand
08:58:55 <roelof> oke, so I can delete the sort 
08:59:01 <roelof> I will try that geekosaur 
08:59:21 <geekosaur> right. but if you later want something other than all-equal there, the sort goes on the other side of the group
08:59:38 <geekosaur> so that you get everything grouped, not just things next to each other grouped
09:01:05 <roelof> geekosaur:  no I miss you, what other then all-equal and why the sort on the other side ? 
09:02:24 <geekosaur> for this problem, there is no reason to do so. have you looked at later problems? You may encounter group again later and want to use it for something other than all-equal
09:03:07 <clrnd> roelof, basically, sort doesn't change the size of a list, so taking the length of a list after it makes no practical sense
09:03:30 * hackagebot csound-sampler 0.0.6.3 - A musical sampler based on Csound  https://hackage.haskell.org/package/csound-sampler-0.0.6.3 (AntonKholomiov)
09:03:32 * hackagebot csound-catalog 0.3.0 - a gallery of Csound instruments.  https://hackage.haskell.org/package/csound-catalog-0.3.0 (AntonKholomiov)
09:03:49 <roelof> oke, I now have to find out why this test (prop_threeDifferent_same_parameters:: Integer -> Bool prop_threeDifferent_same_parameters x = True == threeDifferent x x x) fails on the new code 
09:05:48 <roelof> on the old code it works fine :( 
09:06:08 <CpnStumpy> I'm sure I could come up with a formal and general definition of the relationship between associative binary operators `i * a = i` and `i * a = a` but I gotta think it's been well defined and named previously..
09:06:14 <clrnd> roelof, wouldn't `threeDifferent x x x` == False?
09:06:21 <clrnd> assuming x == x of course
09:07:04 <roelof> clrnd:  you are right 
09:07:27 <roelof> but I see this outcome : *** Failed! Falsifiable (after 1 test): 0 
09:07:29 <CpnStumpy> hell, I could define a type class easy enough with a default monoid implementation if I wanted, but I have a hard time imagining it's not already defined
09:08:30 * hackagebot postgresql-typed 0.4.1 - A PostgreSQL access library with compile-time SQL type inference  https://hackage.haskell.org/package/postgresql-typed-0.4.1 (DylanSimon)
09:08:36 <roelof> aha, I see , I forget that I turn the function. I was testing on eqaulty and now on non-eqaulty 
09:08:57 <clrnd> :D
09:13:30 <roelof> oke, time to make my test again. The current different test still fails 
09:17:45 <ski> CpnStumpy : possibly cut off ".. - two binary functions over the same set which have that inverse choosing strategy" ?
09:21:05 <ski> CpnStumpy : an element `i' such that `forall a. i * a = a' is a (left) neutral/identity/unit element (wrt `*'). an element `i' such that `forall a. i * a = i' is a (left) absorbing/annihilating/zero element (wrt `*')
09:30:35 <paul0> haskell seems to be changing pretty fast, an example from Learn You a Haskell that should return an error just returned the correct answer without error
09:31:04 <paul0> Right 3 >>= \x -> return (x + 100) -- evaluates to Right 103, instead of returning an error
09:33:39 <cocreature> paul0: do you have a link to the passage describing this as an error? I don't think this should be an error in previous versions of haskell
09:33:47 <cocreature> or previous versions of ghc to be more accurate
09:34:36 <geekosaur> cocreature, actually yes
09:34:44 <geekosaur> that's ExtendedDefaultRules
09:35:00 <geekosaur> if I turn that off then I get a type error in ghci
09:35:03 <cocreature> ahh right
09:36:37 <paul0> cocreature, http://learnyouahaskell.com/for-a-few-monads-more#error
09:37:17 <paul0> I've seen some other compatibility issues with the book examples and my ghc version
09:37:19 <geekosaur> this also means you will get an error in compiled code, it's just ghci interactive prompt that has extended defaulting enabled
09:40:31 <paul0> geekosaur, thanks
09:41:18 <ttt_fff_> is there a good book on writing compilers in haskell?
09:43:10 <bergmark> ttt_fff_: site maintenance yay http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm
09:43:32 * hackagebot csound-expression-typed 0.0.7.9 - typed core for the library csound-expression  https://hackage.haskell.org/package/csound-expression-typed-0.0.7.9 (AntonKholomiov)
09:43:33 <ttt_fff_> ha
09:43:37 <ttt_fff_> I think I have that in ~/Downloads/ somewhere
09:43:45 <ttt_fff_> spj taught a course on implementing functional langauges ... in haskell
09:45:09 <cocreature> there is also a translation of the llvm tutorial to haskell http://www.stephendiehl.com/llvm/
09:45:23 <roelof> what do you experts think of this solution : http://lpaste.net/140667
09:45:28 <cocreature> but that is fairly specific to llvm
09:47:09 <cocreature> roelof: True == x is the same as x
09:48:17 <roelof> cocreature:  sorry , what do you mean exactly ? 
09:48:32 * hackagebot csound-expression-typed 0.0.7.9.1 - typed core for the library csound-expression  https://hackage.haskell.org/package/csound-expression-typed-0.0.7.9.1 (AntonKholomiov)
09:49:52 <cocreature> roelof: so (True ==) takes one boolean and returns a boolean which is true if the boolean you passed in is true and false if the boolean you passed in is false, so it's just the same as the boolean you passed in
09:50:13 <cocreature> and instead of (False ==) I would go for "not"
09:50:39 <Gurkenglas> roelof, are you sure [1,1,2], which has allEqual [1,1,2] being False, should have threeDifferent being True?
09:52:51 <CpnStumpy> ski: you understand what I'm getting at there - is there a formal thing for the situation where the same element is neutral under one operator and absorptive under another - the relationship between those two operators?
09:54:27 <CpnStumpy> they're not precisely comonoidal as you pointed out because the monoid is just an example basis the situation can be constructed from.
09:55:15 <Gurkenglas> You mean https://en.wikipedia.org/wiki/Semiring or do you also not want associativity and distributivity?
09:55:16 <CpnStumpy> But the operators themselves could be seen as duals perhaps in their own right I suppose? Perhaps? Is it accurate to call the dual of absorptive is neutral and vice versa?
09:56:23 <roelof> Gurkenglas:  nope, True is only when all three are the same 
09:57:12 <IanMalcolm> hey guys, I'm trying to install stylish-haskell from cabal, but I get "setup-Simple-Cabal-1.22.4.0-x86_64-osx-ghc-7.10.2: The program 'happy' version
09:57:13 <IanMalcolm> >=1.17 is required but it could not be found."
09:57:22 <CpnStumpy> Gurkenglas that may be precisely what I'm looking at... it shows both operators are monoidal, but the identity in one is absorptive under the other operator
09:57:27 <roelof> cocreature:  oke, I understand now. How do I change this to the right one 
09:57:32 <IanMalcolm> I'm on OSX
09:57:47 <cocreature> IanMalcolm: cabal install happy
09:57:50 <tommd> With the freenect library, what is the 'Vector Word8' argument to the call back?  Depth information?
09:58:00 <cocreature> and make sure that ~/.cabal/bin is in your path
09:58:23 <IanMalcolm> cocreature ah, the path thing was missing
09:58:28 <IanMalcolm> thanks
09:59:21 <cocreature> roelof: just replace "True == threeDifferent x y z " by "threeDifferent x y z" and "False == threeDifferent x x x" by "not (threeDifferent x x x)"
10:00:56 <CpnStumpy> Gurkenglas: Though in a since with `and` and `or` monoids, they are invertible - that Semiring example dictates they may not be invertible..not be.. So maybe I'm referring to a `ring?
10:02:05 <Gurkenglas> CpnStumpy, a field is when both are invertible.
10:03:10 <ski> CpnStumpy : "Is it accurate to call the dual of absorptive is neutral and vice versa?" -- no
10:03:33 <ski> the zero element isn't invertible in a field
10:04:18 <roelof> cocreature:  I change the test to this : http://lpaste.net/140670 and everything is working well 
10:04:58 <emilypi> well, not under * :)
10:05:49 <ski> CpnStumpy : for a short while i was thinking you wanted two elements and two binary operations, the two elements being neutral resp. absoptive wrt the first binary operation, and absorptive resp. neutral wrt the other one
10:06:45 <roelof> cocreature:  you are happy now with the code ? 
10:07:09 <emilypi> roelof: ohi roelof long time no talk
10:07:42 <roelof> emilypi:  Do I know you ? 
10:07:54 <emilypi> Arabian :)
10:08:49 <cocreature> roelof: I still think that it's strange that "threeDifferent 1 1 2" returns true, but if that's what you want then it's fine
10:11:27 <roelof> cocreature:  this is the exact text of the challenge : Define a function  threeDifferent :: Integer -> Integer -> Integer -> Bool  so that the result of threeDif f erent m n p is True only if all three of the  numbers m, n and p are different. 
10:11:46 <cocreature> roelof: well 1 1 2 two are not all different
10:12:06 <cocreature> but your function thereDifferent returns True
10:12:19 <roelof> cocreature:  oke, again back to the drawing table :( 
10:12:52 <cocreature> roelof: the problem is that threeDifferent really only means that they are not all equal in your implementation
10:13:09 <cocreature> if two of them are equal but one is different they are not all equal, so threeDifferent returns true
10:13:49 <roelof> 1 1 2 gives indeed true and that must be false 
10:14:24 <roelof> cocreature:  I know, with back to the drawing table I mean I have to think what to change 
10:18:22 <NeverDie> Anyone want a Oneplus Two invite?
10:21:44 <roelof> cocreature:  you agree on this scheme : http://lpaste.net/140674
10:33:17 <OutlawStar> is there a way to start processing from a conduit Producer, create a ResumableSource and then fork the rest of the processing to a different thread?
10:34:11 <hodapp> I wonder if there's an easy way to get via stack or cabal the information that some external dependency changed
10:34:32 <hodapp> my Shake build needs to re-run certain code generation steps if so
10:34:38 <hodapp> but I don't know how to easily detect this
10:35:23 <athan> Hi everyone. Anyone know where I could find a `Parser UTCTime` or `ByteString -> Maybe UTCTime`? Is there a fast & efficient timestamp format?
10:37:06 <bz> l .cab
10:41:47 <aweinstock> athan: https://en.wikipedia.org/wiki/ISO_8601
10:42:10 <roelof> cocreature:  I think I do not need the group for this example. If x /= y and x /= z and x/= z then it must be true otherwise it must be false 
10:42:21 <d-snp> is there any crypto in base? like an md5 or a sha?
10:43:36 <roelof> but can I then make a function which can takes 3, 4 or 5 numbers ? 
10:44:13 <OutlawStar> solve, my problem. Ignore it
10:46:09 <clrnd> roelof, no, at least in haskell no
10:46:16 <clrnd> but you can do that for a list of numbers
10:46:20 <clrnd> apply the same logic
10:47:31 <roelof> clrnd:  oke, then I have to iterate through the list or am I mistaken  ?
10:47:38 <clrnd> roelof, right!
10:47:50 <clrnd> roelof, you'll have to iterate trough it several times
10:48:22 <clrnd> or find a property that shortcuts the need to compare every X to every other X
10:49:09 <clrnd> for example, for integers, I guess that if you sort the list first, then finding 2 consecutive equal numbers already means False
10:49:14 <roelof> clrnd:  oke, that does not sound like a easy task with nice code 
10:49:32 <bergmark> d-snp: don't think so
10:49:49 <geekosaur> roelof, now might be the time to think about what I said about sort and group earlier?
10:49:50 <d-snp> bergmark: I found one, Unique
10:50:22 <roelof> geekosaur:  that remark I have to find in the logs I think 
10:50:24 <clrnd> > let allDifferent = all (== 1) . map length . group in allDifferent [1,2,1]
10:50:26 <lambdabot>  True
10:50:42 <clrnd> oh group doesn't sort
10:50:47 <clrnd> > let allDifferent = all (== 1) . map length . group . sort in allDifferent [1,2,1]
10:50:49 <lambdabot>  False
10:52:10 <roelof> I see , I think I make different code for 3 and 4 and hopefully I learn further in the book to write code like you clrnd  
10:52:24 <roelof> I did not learn group and map right now 
10:52:39 <geekosaur> > let allDifferent l = length l == length (group (sort l)) in allDifferent [1,2,1]
10:52:41 <lambdabot>  False
10:52:45 <geekosaur> > let allDifferent l = length l == length (group (sort l)) in allDifferent [1,2,3]
10:52:50 <lambdabot>  mueval-core: Time limit exceeded
10:52:56 <geekosaur> sigh
10:52:57 <geekosaur> > let allDifferent l = length l == length (group (sort l)) in allDifferent [1,2,3]
10:52:59 <lambdabot>  True
10:53:43 <roelof> this code is out of my lequa now  
10:53:46 <mniip> allDifferent xs = not $ any $ zipWith (==) xs (tail xs)
10:54:02 <mniip> allDifferent = not . any . zipWith (==) <*> tail
10:54:03 <quchen> mniip: That only checks whether there are consecutive duplicates.
10:54:08 <geekosaur> roelof, hm? it's got the same components as what you were doing earlier
10:54:09 <mniip> oh wait right
10:54:09 <clrnd> let's not code golf this one
10:54:32 <d-snp> hey roelof where are you learning haskell? :)
10:54:49 <mniip> allDifferent xs = not $ or $ any $ map (zipWith (==) xs) tails xs
10:54:52 <roelof> geekosaur:  I know. Someone gave some examples of group and sort so I could figure out what it did 
10:55:14 * frerich offers 'allDifferent = all (null . tail) . group . sort'
10:55:23 <mniip> >ord constraint
10:55:26 <roelof> d-snp:  Im learning Haskell by following the Craft book 3 edition 
10:55:59 <clrnd> there always is #haskell-beginners
10:56:04 <roelof> geekosaur:  Here the in is used and I did not know that one 
10:56:08 <d-snp> roelof: I mean as  in what location? in the nl? :)
10:56:12 <mniip> also that code is bad
10:56:20 <mniip> allDifferent xs = not $ or $ any $ map (zipWith (==) xs) $ tails (tail xs)
10:56:25 <roelof> Yes, I live in the Netherlands 
10:56:31 <geekosaur> roelof, no, in goes with let so I could build an expression for lambdabot
10:56:39 <geekosaur> let definition in expression
10:56:49 <roelof> oke, and the l is the list ?? 
10:56:53 <geekosaur> yes
10:57:00 <mniip> :t not . or . any . (map . zipWith (==)) <*> (tails . tail)
10:57:01 <lambdabot>     Couldn't match type ‘Bool’ with ‘[[a]] -> b’
10:57:01 <lambdabot>     Expected type: [a] -> [[a]] -> b
10:57:01 <lambdabot>       Actual type: [a] -> Bool
10:57:35 <roelof> so you are checking the actual length against the number of items in the group list ? 
10:57:45 <geekosaur> yes
10:58:03 <geekosaur> because if they're all different then I get each one in its own length-1 list
10:58:13 <roelof> geekosaur:  then I understand. That was one of the ideas I get from making a list of possibilities 
10:58:18 <geekosaur> so the outer list has the same number of elements as the input list, iff they are all different
10:58:54 <mniip> :t not . any or . ((map . zipWith (==)) <*> (tails . tail))
10:58:55 <lambdabot> Eq a => [a] -> Bool
10:59:13 <bz> :t any
10:59:14 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
10:59:24 <roelof> I know if you do  123 you get [1,2,3] which produces [[ [1], [2], [3]) which has 3 items which is also the length of the orginal length 
11:00:08 <geekosaur> > (group . sort) [1,2,3,1,4,3,6]
11:00:10 <lambdabot>  [[1,1],[2],[3,3],[4],[6]]
11:00:34 <geekosaur> > (group . sort) [1,2,3,7,4,5,6]
11:00:35 <mniip> roelof, get your braces and parens right!
11:00:38 <lambdabot>  mueval-core: Time limit exceeded
11:00:40 <geekosaur> > (group . sort) [1,2,3,7,4,5,6]
11:00:43 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7]]
11:00:44 <geekosaur> busy bot...
11:01:07 <roelof> mniip:  sorry, typed too quick 
11:01:19 <geekosaur> but the input has to be sorted because group only notices the same element if it's consecutive
11:01:23 <geekosaur> > group [1,2,1]
11:01:25 <lambdabot>  [[1],[2],[1]]
11:01:32 <geekosaur> > (group . sort) [1,2,1]
11:01:35 <lambdabot>  [[1,1],[2]]
11:02:15 <d-snp> lame!
11:02:28 <d-snp> but probably performant :P
11:03:21 <Cale> Well, sometimes you want that behaviour too
11:03:21 <roelof> thanks, now rewriting my test I think 
11:04:12 <Cale> > map (\xs -> (length xs, head xs)) . group $ "mississippi"
11:04:14 <lambdabot>  [(1,'m'),(1,'i'),(2,'s'),(1,'i'),(2,'s'),(1,'i'),(2,'p'),(1,'i')]
11:04:23 <Cale> run length encoder
11:04:59 <d-snp> :P
11:05:05 <geekosaur> yeh, RLE is the obvious application of group as is
11:05:20 <mniip> liftA2 (,) length head
11:05:26 <geekosaur> most compression algorithms have RLE at some level
11:05:41 <roelof> oke, new code which passed quickCheck :http://lpaste.net/140675. I hope it is right now 
11:05:57 <mniip> sorry I can't control myself when it comes to stealing people's points :P
11:06:01 <Welkin> geekosaur: for encoding binary data?
11:06:15 <frerich> I also used 'group' once to 'compress' commands received via a network connection such that multiple subsequent 'Refresh' commands were squashed into one.
11:06:52 <frerich> mniip: but '&&&' would have been nicer :-)
11:07:04 <mniip> but that's an extra import
11:08:29 <frerich> For me, liftA2 needs an import, too.
11:08:35 * hackagebot text-regex-replace 0.1.1.1 - Easy replacement when using text-icu regexes.  https://hackage.haskell.org/package/text-regex-replace-0.1.1.1 (EricRochester)
11:09:03 <mniip> how about... hmm
11:09:20 <geekosaur> Welkin, the simplest compression just RLEs the input. more complex ones build tables of repeated sequences and RLE those in various ways
11:11:18 <mniip> frerich, head >>= (,) >>= return . (>>= return . length)
11:11:57 <monochrom> a popular "what is the next number" riddle uses RLE. "what is the next number in this sequence? 1, 11, 21, 1211, 111221, 312211"
11:12:20 <johnw> monochrom: that was in the book The Cuckoo's Nest :)
11:12:21 <monochrom> err I have an error there
11:12:35 <monochrom> no, no error
11:12:38 <mniip> head >>= flip ((,) . length)
11:12:54 <frerich> monochrom: mmmh 13112221 ?
11:12:56 <mniip> monochrom, its not an RLE
11:13:04 <mniip> it's the self-describing sequence
11:13:48 <roelof> sorry for maybe a stupid question but what is a RLE ? 
11:13:55 <mniip> run-length encoding
11:14:15 <clrnd> not a stupid quesiton
11:14:21 <geekosaur> roelof: group's output is a run length encoding of the input
11:14:47 <mniip> well it needs some more preprocessing to be run-length
11:15:00 <geekosaur> > group [1,1,1,2,1,1,1,1,1,4,4.4,3,6,1,7,7,2,9]
11:15:01 <lambdabot>  [[1.0,1.0,1.0],[2.0],[1.0,1.0,1.0,1.0,1.0],[4.0],[4.4],[3.0],[6.0],[1.0],[7....
11:15:05 <geekosaur> whoops
11:15:13 <geekosaur> > group [1,1,1,2,1,1,1,1,1,4,4,4,3,6,1,7,7,2,9]
11:15:14 <lambdabot>  [[1,1,1],[2],[1,1,1,1,1],[4,4,4],[3],[6],[1],[7,7],[2],[9]]
11:15:31 <geekosaur> one dot in place of a comma and wheee >.>
11:15:59 <geekosaur> and yes, ideally you postprocess to get lengths (map length . group)
11:18:20 <roelof> experts. my last solution is a good one : http://lpaste.net/140675 
11:20:12 <Welkin> roelof: shouldn't `allEqual` be `allUnique`?
11:21:13 <clrnd> threeDifferent == allEqual?
11:22:08 <roelof> clrnd:  what do you mean with your remark ? 
11:22:33 <clrnd> roelof, you have `threeDifferent  x y z = allEqual [x, y,  z]`
11:22:35 <roelof> Welkin:  I think you are right. It's looking if all  numbers are unique. Wil change it 
11:22:49 <Welkin> roelof: your program makes no sense
11:23:10 <Welkin> why would you sort and group a list of 3 elements?
11:24:28 <roelof> Welkin:  this one schould also work with a list of 4 elements. I sort and group them to see if they are all different or not ? 
11:24:39 <Welkin> roelof: another way to do this is to transform your list into a Set (which by definition only consists of unique elements) then transform it back into a list
11:24:58 <Welkin> that runs in O(n) time
11:25:15 <Welkin> oh wait, nevermind
11:25:23 <Welkin> I think Set.fromList is O(n log n)
11:25:32 <Welkin> but it is still a valid approach
11:26:02 <Welkin> so it is the same or better than your approach
11:26:02 <Welkin> https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Set.html#v:fromList
11:26:21 <roelof> oke, and the list of the transform has to have the same length as the original list. then the numbers are all unique 
11:26:39 <clrnd> yes
11:27:13 <roelof> oke, nice to try tomorrow. Now almost time to sleep 
11:27:28 <Welkin> > let xs = [1,1,1,2,6,5,4,3,2,1,4] in length (Data.Set.toList (Data.Set.fromList xs)) == length xs
11:27:30 <lambdabot>  Not in scope: ‘Data.Set.toList’Not in scope: ‘Data.Set.fromList’
11:27:44 <clrnd> > let allUnique xs = length xs == (S.toList . S.fromList) xs
11:27:46 <lambdabot>  <no location info>:
11:27:46 <lambdabot>      not an expression: ‘let allUnique xs = length xs == (S.toList . S.fromLi...
11:27:57 <clrnd> forgot in , meh
11:28:47 <mariusmarius> :t in
11:28:48 <lambdabot> parse error on input ‘in’
11:28:58 <Welkin> > let xs = [1,1,1,2,6,5,4,3,2,1,4] in length xs == length ((S.toList . S.fromList) xs)
11:29:00 <lambdabot>  False
11:29:11 <Welkin> > let xs = [1,2,6,5,4,3] in length xs == length ((S.toList . S.fromList) xs)
11:29:12 <lambdabot>  True
11:30:06 <clrnd> :t S.fromList
11:30:07 <lambdabot> Ord a => [a] -> S.Set a
11:30:12 <clrnd> Ord though
11:30:13 <Welkin> @let allUnique xs = length xs == length ((S.toList . S.fromList) xs)
11:30:15 <lambdabot>  Defined.
11:30:21 <Welkin> > allUnique [1..10]
11:30:23 <clrnd> you could get away with just Eq
11:30:25 <lambdabot>  True
11:30:26 <clrnd> ;)
11:30:50 <Welkin> > allUnique [1,1..10]
11:30:57 <lambdabot>  mueval: ExitFailure 1
11:30:58 <mpickering> I found the haskell bike signs in Utrecht, perhaps the first act of Haskell tourism 
11:31:04 <Welkin> > allUnique [1,1,2,3]
11:31:09 <lambdabot>  False
11:31:12 <Welkin> mpickering: link?
11:31:40 <mpickering> https://www.reddit.com/r/haskell/comments/3959r0/haskellbased_bicycle_parking_guidance_system_in/
11:32:15 <roelof> mpickering:  lucky, Im not the only Dutch guy here :) 
11:35:14 <Welkin> wow that is cool mpickering 
11:35:23 <Welkin> although I don't see the connection to haskell
11:35:41 <mpickering> Well the backend is written in haskell
11:35:51 <mpickering> doesn't get much more real-world then being able to touch it
11:35:55 <Welkin> oh
11:35:56 <Welkin> haha
11:37:19 <Welkin> I'd love to live somewhere like that
11:44:17 <d-snp> roelof: I'm dutch as well, why do you think I asked where you were :P
11:48:40 <tombert> Howdy, I have an aeson question for anyone who's willing to help, assuming already have a String that's properly formatted for JSON, how would I go about making that an Aeson object?
11:49:24 <Ankhers> encode jsonString
11:49:28 <dmj`> tombert: decode :: FromJSON a => ByteString -> Maybe a
11:49:39 <Ankhers> woops
11:49:44 <Ankhers> I went the wrong way.
11:49:46 <dmj`> or just decode :: ByteString -> Maybe Value
11:50:01 <tombert> dmj`: what if I need it to be a rgular string?
11:50:32 <Ankhers> convert it to a ByteString
11:51:08 <dmj`> tombert: Ankhers 
11:51:11 <Guest58998> How can I memoize the following recursive function? http://lpaste.net/6294287508729495552
11:51:15 <roelof> d-snp:  which part on the Netherlands do you live. I live in East 
11:51:55 <Ankhers> tombert: Aeson doesn't have a `FromJSON a => String -> Maybe a' function.
11:52:08 <dmj`> tombert: String is evil, don't use it
11:54:05 <slowbait> Hi, how would you decompose a permutation into its cycles? 
11:54:34 <Welkin> Guest58998: add a type declaration
11:57:18 <dmj`> tombert: String has insane space inflation
11:57:45 <tombert> gotta question then why it's teh default
11:57:47 <tombert> lol
11:57:47 <Welkin> you can use Text instead of String
11:57:58 <tombert> text might be easier
11:58:17 <kalkin-> hi
11:58:27 <dmj`> tombert: it is questioned yes
11:58:36 <Guest58998> Welkin: Added the type declaration.
11:58:36 <monochrom> indeed, String = [Char]. for every [X], if the length is n, then the memory used is at least 16n bytes (this is just the spine)
11:58:38 <Welkin> String has advantages
11:58:47 <Ankhers> tombert: I'm going to go with historical reasons and/or lists are useful.
11:58:51 <Welkin> because it is just a list
11:59:19 <kalkin-> i'm using HXT do unpicle some Xml. One Element has 27 attributes which i need to serialize to a record with 27 fields. there is a lot of boilerplate. how can i avoid it?
11:59:23 <Welkin> for processing large amounts of data, use Text, or if it is just binary data, ByteString
11:59:30 <monochrom> [Char] is de facto because it has a long history. and decades ago people did not need efficiency
11:59:39 <kalkin-> i kind of followed this guide https://wiki.haskell.org/HXT/Conversion_of_Haskell_data_from/to_XML#Constructing_the_example_picklers
11:59:55 <Welkin> kalkin-: GHC.Generic?
12:00:13 <kalkin-> Welkin: What do you mean by that?
12:00:22 <Welkin> make your data type derive Generic
12:00:27 <Welkin> then create an instance
12:00:34 <Guest58998> Can someone help me in memoizing the recursive function at http://lpaste.net/6294287508729495552
12:00:42 <Welkin> instance SomeTypeClass MyDataType
12:02:32 <Welkin> kalkin-: https://wiki.haskell.org/GHC.Generics#Using_GHC.27s_new_features
12:03:13 <tombert> it looks like Aeson uses Lazy bytestrings, how do I go about converting a regular string to a lazy bytestring?
12:03:31 <kalkin-> Welkin: thanks for the hint it seems like i need to do a bit of reading :)
12:03:50 <Welkin> tombert: toStrict
12:03:55 <Welkin> oh
12:04:03 <Ankhers> tombert: Data.ByteString.Lazy.pack
12:04:52 <Ankhers> Thats wrong.
12:05:00 <tombert> Ankhers: pack takes in word8s
12:05:06 <Ankhers> Data.ByteString.Lazy.Char8.pack
12:05:13 <Welkin> @hoogle String -> ByteString
12:05:15 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
12:05:15 <lambdabot> Graphics.Rendering.OpenGL.GL.Shaders.ShaderObjects packUtf8 :: String -> ByteString
12:05:15 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
12:05:18 <arkeet> no!!
12:05:25 <Welkin> Char8 loses information
12:05:41 <Ankhers> I did not know that.
12:05:53 <tyler> hi all
12:05:54 <Welkin> it trunactes the characters to 8 bits
12:05:57 <Ankhers> Though, it makes sense that it does.
12:05:57 <tombert> this is pretty basic stuff, no special characters or anything
12:06:10 <tombert> I think that'll be sufficient
12:06:39 <Welkin> convert to Text, then to ByteString
12:07:15 <Welkin> Data.Text.Lazy.Encoding.encodeUtf8 . Data.Text.pack
12:07:32 <Welkin> > Data.Text.Lazy.Encoding.encodeUtf8 . Data.Text.pack $ "Hello"
12:07:34 <lambdabot>      Not in scope: ‘Data.Text.Lazy.Encoding.encodeUtf8’Not in scope: ‘Data.Te...
12:07:49 <Welkin> > encodeUtf8 . T.pack $ "Hello"
12:07:50 <lambdabot>  Not in scope: ‘encodeUtf8’    Not in scope: ‘T.pack’
12:07:51 <lambdabot>      Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
12:07:54 <t_durden> test
12:08:20 <Welkin> of course, you could also just read the data in as Text to begin with
12:08:22 <Welkin> or ByteString
12:08:29 <Welkin> and avoid all the conversions
12:08:39 * hackagebot tsvsql 0.2.0.0 - Template tsv into SQL  https://hackage.haskell.org/package/tsvsql-0.2.0.0 (DanielChoi)
12:10:12 <t_durden> hey all. quick question. i'm trying to implement a powerset function using a list comprehension as opposed to direct recursion alone. powerset [1,2,3] should yield [[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]. Just yields all possible subsets of the given set. Any ideas how to do this using a list comprehension?
12:10:30 <t_durden> my current solution works but does not use a list comprehension.
12:10:55 <_Jules> i don't think it's possible without recursion
12:10:59 <monochrom> list comprehension or not, you will use recursion.
12:11:22 <t_durden> Oh, it will use a list comprehension ~in addition to~ direct recursion. Sorry.
12:11:46 <_Jules> how are you doing it currently?
12:12:34 <t_durden> powerset [] = [[]]
12:12:36 <monochrom> powerset (x:xs) = "get the powerset of xs. then you have two choices: add x or don't add x"
12:12:48 <Gurkenglas> You can try using one of the recursively defined functions from libraries. Beware spoilers, somebody is probably currently typing in their own clever solution to be checked by lambdabot
12:12:54 <_Jules> t_durden, that's a good start
12:12:55 <t_durden> powerset (x:xs) = powerset xs ++ map (x:) (powerset xs)
12:13:17 <t_durden> sorry i don't know how to newline in irc
12:13:23 <monochrom> oh nevermind
12:13:31 <_Jules> so you can use a list comprehension instead of map, would that satisfy the requirements?
12:13:48 <monochrom> you can write "map (x:) (powerset xs)" in list comprehension
12:13:55 <t_durden> yeah
12:14:09 <t_durden> wait how would i go about doing that? what do you mean by write that in a list comprehension?
12:14:13 <shachaf> When you come to a fork in the road, take it.
12:14:17 <dmj`> > and $ Prelude.map (flip S.member $ S.fromList (subsequences ("haskellisgreat" :: String))) ["haskell", "is", "great"]
12:14:18 <lambdabot>  True
12:14:20 <Gurkenglas> powerset (x:xs) = [f x' | f <- [id, (x:)], x' <- powerset xs]
12:14:23 <arkeet> map f xs = [ f a | a <- xs ]
12:14:51 <_Jules> you found that solution in the internet didn't you? :P, map f xs = [f x | x <- xs]
12:15:06 <RevJohnnyHealey> filterM (const [True, False])
12:15:37 <Gurkenglas> There it is! I knew somebody would say filterM (const [True, False]) sooner or later x)
12:15:50 <t_durden> I read an article about the reason for that answer a while back. Very interesting deduction!
12:15:55 <dmj`> Guest58998: I'd put all subsequnces in a set, store that in State / I/O. Then reference from there.
12:16:08 <monochrom> yes, in general, you always know someone will add noise by going tangential
12:16:15 <mniip> [21:08:54] <t_durden> sorry i don't know how to newline in irc
12:16:17 <mniip> you can't
12:16:34 <Welkin> :t filterM (const [True, False])
12:16:35 <Gurkenglas> mniip, sure you can, I do it by mistake all the time
12:16:35 <lambdabot> [b] -> [[b]]
12:16:39 <Welkin> > filterM (const [True, False]) [1,2,3]
12:16:41 <lambdabot>  [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:16:50 <_Jules> that filterM solution actually is nice and understandable in Eff
12:16:51 <Gurkenglas> Type your multiple lines into notepad, then copypaste them in here as a block
12:17:00 <t_durden> Gurkenglas thanks
12:17:00 <M2tias> hey, I bought Learn You a Haskell, and the book mentions this channel. if the writer is here, great job!
12:17:01 <mniip> Gurkenglas, you can send multiple messages
12:17:10 <mniip> but not embed newlines in a message
12:17:39 <Gurkenglas> mniip, he was probably just concerned that people would think the first line of his program was all of it. "that's a good start"
12:17:59 <tulcod> Welkin: look, sometimes i genuinely think i understand haskell. and then i'm in #haskell and someone pulls stuff like that, and I can hardly define what a category is
12:18:38 <mniip> > traverse (:"_") "hello"
12:18:40 <lambdabot>  ["hello","hell_","hel_o","hel__","he_lo","he_l_","he__o","he___","h_llo","h_...
12:18:40 <t_durden> Gurkenglas I don't understand your solution. Could you explain the f <- [id, (x:)] part? what is id?
12:18:50 <Gurkenglas> :t id
12:18:51 <lambdabot> a -> a
12:18:55 <Gurkenglas> It is the only member of its type
12:19:02 <Gurkenglas> inb4 someone says undefined
12:19:09 <tulcod> undefined
12:19:16 <mniip> const undefined
12:19:32 <tulcod> :t undefined
12:19:33 <lambdabot> t
12:19:53 <tulcod> what's t?
12:19:54 <Gurkenglas> Hmm. It is the only member of its type that isn't also a member of a more general type?
12:20:00 <tulcod> :k t
12:20:01 <lambdabot> Not in scope: type variable ‘t’
12:20:21 <clrnd> wat
12:20:30 <_Jules> powerset in scheme: (reset (filter (lambda (x) (shift k (k #t) (k #f))) xs))
12:20:32 <clrnd> :t error "lolz"
12:20:33 <Welkin> tulcod: lol, I didn't come up with that
12:20:34 <lambdabot> t
12:20:42 <monochrom> t_durden: id is this function: id x = x
12:20:47 <Welkin> I saw RevJohnnyHealey write it, so I wanted to see how it worked
12:20:52 <mniip> :t moo
12:20:53 <lambdabot> forall (k :: BOX) (k1 :: BOX) (typevariables :: k -> k1 -> *) (are :: k) (cool :: k1). typevariables are cool
12:20:56 <t_durden> monochrom forgot that. thanks!
12:21:04 <tulcod> Welkin: okay, i gues i joined late. still sick though.
12:21:12 <Gurkenglas> I'll bet karma he also didn't come up with it
12:21:20 <monochrom> "f <- [id, (x:)]" says: choose from two possibilities: don't prepend x, do prepend x
12:21:25 <mniip> hmm
12:21:25 <tulcod> okay but surely someone came up with it
12:21:31 <mniip> kind polymorphism
12:21:35 <mniip> not cool
12:22:08 <Gurkenglas> I'll bet (fix id) that that guy also didn't come up with it
12:22:22 <monochrom> look how all you people are having fun for yourself at the expense of spamming the channel and not answering genuine questions
12:22:29 <mniip> :t moo
12:22:30 <lambdabot> typevariables are cool
12:22:42 <t_durden> okay this makes complete sense now. all that does is applies a function f to every possible subset of xs. f either prepends nothing or prepends x. 
12:23:02 <monochrom> yeah, it's also related to the filterM version
12:23:28 <Gurkenglas> Also related to your version. They're all pretty close!
12:23:46 <tulcod> in the context of strictness and space leaks, what does the following mean? "Note that binary trees do not have a value-strict variant that is not spine-strict as well, because you can build trees such as Bin thunk1 thunk1 out of unevaluated leaves." (from: http://apfelmus.nfshost.com/blog/2013/08/21-space-invariants.html )
12:23:56 <t_durden> I don't think i understand Haskell in general well enough to understand filterM. But I've read about that solution.
12:24:04 <t_durden> Still working my way through Learn You a Haskell
12:26:09 <mniip> t_durden, filterM applies an effectful predicate to elements of a list. In our case the "effect" is nondeterminism. We say that we both want the element, and not want it
12:26:10 <monochrom> tulcod: I would delete "because", and treat the two sentences as unrelated.
12:26:28 <tulcod> monochrom: thank you
12:26:32 <mniip> the list monad magic gives us a list of all combinations of "want" and "don't want"
12:26:40 <mniip> quantum-computing-esque
12:27:06 <tulcod> monochrom: what is the reason for the former? can't you have evaluated values in "unknown" (ie unevaluated) positions?
12:27:51 <t_durden> mniip: so it applies said nondeterminism to all elements in the list?
12:27:59 <mniip> yes
12:28:07 <monochrom> you have to evaluate the spine, some path of it, before you reach a value position
12:28:12 <mniip> we get a list where each element is simultaneously contained and not contained
12:28:27 <t_durden> thanks all; solved my problem.
12:28:45 <mniip> one day I will understand Traversable
12:28:54 <_Jules> while filter is going over the list, every time it calls the predicate the universe is split in two, and in one universe the predicate returns True and in the other universe it returns False. at the end of the day all universes are collected in a list
12:29:46 <Welkin> hm
12:29:53 <Welkin> I have to read the definition of filterM to understand it
12:29:55 <Welkin> now it makes sense
12:30:17 <mniip> Welkin, well I can perfectly see what it does from its signature
12:30:19 <mniip> :t filterM
12:30:20 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
12:30:27 <Welkin> also, because of the definition of bind for lists
12:30:42 <Welkin> mniip: I meant how it works for lists
12:30:53 <Welkin> er, I mean the solution posted earlier
12:30:59 <Welkin> filterM (const [True, False])
12:31:10 <mniip> Welkin, well it helps to imagine that the list monad is a quantum computer
12:31:33 <mariusmarius1> mniip: I like that.
12:31:43 <tulcod> mniip: uh, because we all totally understand quantum computers :P
12:32:55 <monochrom> in fact, the statement "the list monad is a quantum computer" reflects a popsci misconception rather than true knowledge.
12:32:57 <mniip> tulcod, if you don't, _Jules gave an accurate description of what happens
12:33:50 <mniip> monochrom, you mean the fact that there's no actual "forking"?
12:34:26 <monochrom> not even close
12:34:58 <tulcod> monochrom: well the worst part is that the "forking" view is not even entirely wrong
12:35:01 <_Jules> but in this case the popsci view is more useful to explain the list monad than real QM is ;-)
12:35:06 <tulcod> it's just that it's right in a very specific inescapable sense
12:35:12 <mariusmarius1> monochrom: I thought he was just getting at the basic intuition that a list monad could either have stuff in it or just be []…it's underdetermined, in the same way that unobserved stuff is underdetermined.
12:35:48 <mniip> relevant:
12:35:50 <mniip> > takeWhileM (const [True, False]) "hello"
12:35:52 <lambdabot>  ["","h","he","hel","hell","hello"]
12:36:11 <ReinH> The basic intuition is that the list monad can be used to encode "nondeterminism" as in choice.
12:36:29 <ReinH> This isn't it's only use
12:36:37 <monochrom> ok, the list monad lacks these: eigenstates, qubits, the collapse at the observation. if you lack all of those, you can't be looking at quantum computing.
12:37:04 <ReinH> Calling the list monad "quantum computing" strikes me as using a sledgehammer of an analogy when a screwdriver would do
12:37:04 <Welkin> > "" : tails "hello"
12:37:07 <lambdabot>  ["","hello","ello","llo","lo","o",""]
12:37:12 <Peaker> Quantum Mechanics in Haskell (as I understand it):  type UniverseState = Map (Map ParticleType (Set ParticlePosition)) Complex ; nextState :: UniverseState -> UniverseState -- complex values affect their "neighbors" in the big map
12:37:16 <mniip> todo: implement an eigenstate monad
12:37:21 <Welkin> > inits "hello"
12:37:22 <ReinH> Since you then have to explain all the ways in which it isn't like a quantum computer so you can focus on the one way that it is sort of like a quantum computer
12:37:23 <lambdabot>  ["","h","he","hel","hell","hello"]
12:37:48 * hodapp looks around for a flowchart that explains to him whether he should represent his EDSL as a free monad or not
12:38:00 <ReinH> hodapp: [ Yes ]
12:38:03 <mniip> > takeWhileM ((:[True]) . isDigit) "foo0bar1baz2qux"
12:38:04 <lambdabot>  ["","f","fo","foo0","foo0b","foo0ba","foo0bar1","foo0bar1b","foo0bar1ba","fo...
12:38:08 <clrnd> data List a = Quark | Lepton a (List a)
12:38:09 <hodapp> ReinH >_>
12:38:17 <ReinH> hodapp: Actually, [ maybe ] :p
12:38:19 <monochrom> when you code up "x <- [False, True]" you are not even getting remotely close to superimposing "False" and "True" to get a complex number.
12:38:20 <mniip> or rather
12:38:25 <mniip> > takeWhileM ((:[True]) . isLetter) "foo0bar1baz2qux"
12:38:27 <lambdabot>  ["foo","foo0bar","foo0bar1baz","foo0bar1baz2qux","foo0bar1baz2qux","foo0bar1...
12:38:31 <Peaker> I wonder if a physicist could debug my QM declaration :)
12:38:33 <hodapp> ReinH: GAH!
12:39:01 <ReinH> Peaker: well, it doesn't enforce a whole bunch of invariants
12:39:10 <clrnd> so [a] is not differenciable at origin
12:39:12 <ReinH> since it allows, e.g., information to travel faster than light
12:39:21 <Peaker> ReinH: That's what the comment is about :)
12:39:25 <ReinH> Peaker: :)
12:39:44 <ReinH> Peaker: surely you need a comonad to encode your light cone ;)
12:39:54 * hodapp realizes he still hasn't figured out comonads
12:39:54 <ReinH> *cones
12:40:03 <Peaker> ReinH: possibly, but the universe isn't polymorphic enough :)
12:40:09 <ReinH> Peaker: :)
12:40:25 <mniip> Peaker, what if you found an adjoint functor?
12:40:28 <mniip> for the universe?
12:40:44 <ReinH> "the list monad is a quantum computer" is about the worst weight to power ratio of any monad analogy I've heard yet...
12:41:14 <mniip> ReinH, :/
12:41:20 <Clint> quantum burrito
12:41:29 <ReinH> Excepting perhaps burritos, which possibly have zero power
12:41:34 <tulcod> Clint: +1
12:41:41 <tulcod> the list monad is like a quantum burrito
12:41:41 <mniip> well no
12:41:43 <clrnd> a quantum burrito would be awful though, it could be empty!
12:41:45 <mniip> you can compose burritos
12:42:01 <ReinH> No you can't. Try it sometime.
12:42:06 <ReinH> You can't join them wither.
12:42:09 <ReinH> *either
12:43:07 <mniip> you still can return them though
12:43:08 <MarcelineVQ> Can you intersect a burrito?
12:43:17 <ReinH> With my face.
12:43:47 <monochrom> no, you don't want someone to intersect a burrito (or a cake, or a pie) with your face :)
12:44:11 <ReinH> Let's try it
12:47:36 <johnw> couldn't a burrito be a Free monad?  I can always add more tortillas, or I can unwrap them all, manipulate the filling, and wrap them back up
12:48:08 <bitemyapp> johnw: you've kicked around MonadBaseControl in your notes, yeah?
12:48:18 <johnw> bitemyapp: yeah, plenty of times
12:48:26 <johnw> i wrote a tutorial even
12:48:34 <tulcod> johnw: free as in beer?
12:48:34 <bitemyapp> johnw: whoa, where's this tutorial?
12:48:35 <hodapp> there's no such thing as a free... burrito... monad?
12:48:47 <bitemyapp> johnw: I'm reading http://blog.ezyang.com/2012/01/modelling-io/ and trying to get a deeper understanding of monad-control
12:48:50 <johnw> bitemyapp: http://newartisans.com/2013/09/using-monad-control-with-monad-transformers/
12:48:52 <ReinH> johnw: no, burritos violate the monad laws.
12:49:06 <johnw> ReinH: how so?
12:49:10 <ReinH> they are of fixed dimension
12:49:21 <johnw> meaning?
12:49:46 <ReinH> For the same reason that you can't make a monad out of a fixed-size array
12:49:47 <monochrom> I want to know too
12:49:57 <monochrom> oh, that dimension
12:50:15 <hodapp> well, yeah, a given burrito is immutable
12:50:24 <ReinH> it has a wrapper of fixed size
12:50:39 <ReinH> you can't fit a burrito inside a burrito
12:50:43 <bitemyapp> johnw: thank you
12:50:57 <ReinH> unless you change the size of one of them
12:51:02 <ReinH> in which case you violate the laws
12:51:03 <johnw> ReinH: perhaps we need to define what a burrito is
12:51:07 <ReinH> johnw: :)
12:51:11 <johnw> I was thinking of "Tortilla a"
12:51:19 <johnw> so, I can imagine "Tortilla (Tortilla a)" 
12:51:44 <johnw> join for that may not be possible, but Free Tortilla a could have arbitrary many layers of tortillas
12:51:54 <monochrom> yeah, I think some defines it to allow an unlimited supply of varies sizes
12:51:57 <bitemyapp> johnw: hrm, needs updated for monad-control-1.0, but that doesn't seem like it would be a tremendous change.
12:52:03 <bitemyapp> johnw: is your blog on github?
12:52:09 <johnw> bitemyapp: true; and yes, it is! https://github.com/jwiegley/newartisans
12:52:18 <ReinH> monochrom: I reject such definitions as spurious and also not supporting my argument
12:52:25 <tulcod> johnw: why would the join not be possible?
12:52:26 <monochrom> :)
12:52:42 <johnw> tulcod: it would require having the tortillas merge somehow, to become one tortilla again
12:52:46 <tulcod> johnw: join (Tortilla (Tortilla a)) = Tortilla a
12:52:51 <FireFly> johnw: but let's be realistic here--who would offer you free Tortillas?
12:53:02 <johnw> tulcod: you've lost information there
12:53:09 <johnw> tulcod: you've thrown away one of the two tortillas; but which?
12:53:44 <tulcod> johnw: so we need dependent types?
12:53:49 <ReinH> You also can't physically fit a burrito inside a same-sized burrito
12:53:58 <monochrom> none is thrown away, because, tortillas are trapped in monads.  <duck>
12:54:13 <tulcod> so tortillas are like monads
12:54:27 <johnw> ReinH: no one said I can't use ever-larger tortillas
12:54:37 <ReinH> Tortillas are size-indexed
12:54:47 <tulcod> burritos are borritois in the category of endotortillas?
12:54:52 <ReinH> large-tortilla is a different type than small-tortilla
12:54:54 <dolio> So it's the time of week where we spend half an hour deconstructing bad jokes?
12:54:58 <monochrom> ok great, now we get to indexed monads
12:55:05 <ReinH> monochrom: no
12:55:07 <johnw> ReinH: hmm
12:55:16 <monochrom> can we just all agree "a burrito is an object" and be done with it?
12:55:26 <ReinH> johnw: otherwise you could also try to fit large tortilla inside small tortilla
12:55:42 <tulcod> monochrom: but is the object in WHNF?
12:55:51 <johnw> ReinH: ok, I see
12:55:57 <ReinH> dolio: I would like to submit that it's friday...
12:56:18 <bitemyapp> johnw: whoa, this bears more comment I think
12:56:22 <bitemyapp> "One notable difference in this example is that the second print statement in foo becomes impossible, since the “monadic value” returned from the inner call to f must be restored and executed within the outer monad."
12:56:36 <bitemyapp> johnw: ^^ is there a workaround? Is this a strict limitation in what it can do? Seems disconcerting.
12:56:59 <bitemyapp> johnw: I'm not sure if it explicitly calls out what Ed Yang wrote about either.
12:57:07 <ReinH> bitemyapp: where are you reading that?
12:57:14 <bitemyapp> IS SEKRIT
12:57:19 <bitemyapp> ReinH: http://newartisans.com/2013/09/using-monad-control-with-monad-transformers/
12:57:22 <ReinH> heh
12:57:40 <bitemyapp> ReinH: I needed to mapConcurrently something in a bigger Monad than IO
12:57:44 <bitemyapp> ReinH: then my world fell apart :P
12:57:57 <bitemyapp> the code works with monad-control now just fine, but I want to understand what I just did.
13:14:03 <hodapp> ReinH: what is making it a little more confusing for me (with figuring out whether I should use a free monad or not) is that my EDSL is based around some combinators that behave like... foo a $ foo b $ stuff, where you sort of have a hierarchy of nodes that inherit the innermost function call
13:14:10 <kristof> When is haskell-docs going to support 7.10? Not trying to whine, just curious.
13:14:30 <hodapp> 'foo' sets some property, and there are a couple different things that behave like 'foo'
13:15:08 <hodapp> and I'm not sure what to call this style... I took it from how Atom behaves, and it's not exactly applicative, but I don't know what it is
13:15:19 <bitemyapp> hodapp: call it functional
13:15:51 <kristof> goes against the "recognizing patterns" philosophy
13:16:01 <bitemyapp> kristof: call it funky
13:16:45 <akegalj> is there something like (Foldable t) => t a -> t a -> t (a, a)  ; like more general zip ?
13:17:01 <hodapp> And I'm following along in some free monad explanations, but they seem to only handle EDSLs that don't have this hierarchical nature to them
13:17:13 <shachaf> No.
13:17:14 <Stratege> so you have something like: a -> Foo a -> Foo a? Looks like a list to me.
13:17:15 <kristof> akegalj: That stops when one of the traversables is finished?
13:17:23 <akegalj> kristof: yes
13:17:31 <kristof> akegalj: You can convert any traversable into a list and then zip those two
13:17:44 <kristof> oh
13:17:49 <shachaf> There isn't even Foldable t => t a -> t a other than id.
13:17:50 <kristof> that'll give you a list, not a t
13:18:20 <kristof> I know there's a way to preserve the shape of a traversable in general... 
13:19:11 <TheCrafter> Hello #haskell ! I am creating a build script using shake and I want your feedback regarding a specific part. What do you have to say about these lines: https://github.com/TheCrafter/Habs/blob/master/src/Main.hs#L46-L104
13:19:33 <akegalj> kristof: hm ok. I don't really need it. I was just wondering is there something like that. Thanks for your time
13:19:55 <kristof> akegalj: No, you've got me curious, now.
13:20:11 <hodapp> TheCrafter: why not make a type with constructors for MSVC, c++, gcc, and so on, and pattern-match rather than using a map?
13:20:30 <akegalj> kristof: :)
13:20:43 <hodapp> TheCrafter: or, a typeclass for types that can give information on flags
13:20:43 <ReinH> hodapp: sounds like function composition to me
13:21:03 <ReinH> I'm not seeing the hierarchical structure in what you described
13:23:23 <TheCrafter> hodapp: I just thought it easier to use a map since everything are static and they won't change. I mean, the flags will be for either debug or release. There will never be a 3rd variant.
13:23:28 <TheCrafter> but I guess you're right.
13:23:29 <bitemyapp> ReinH: \x -> f (g (h x))
13:23:42 * hackagebot pred-trie 0.2.4 - Predicative tries  https://hackage.haskell.org/package/pred-trie-0.2.4 (athanclark)
13:23:52 <bitemyapp> ReinH: true anarchists will not allow greedy kulak function f to benefit from the hierarchy of functions
13:24:01 <hodapp> ReinH: this is the style in which it's used: http://lpaste.net/140707
13:24:04 <bitemyapp> ReinH: down with function composition! Down with function hierarchy!
13:24:06 <bitemyapp> all functions equal!
13:24:19 <ReinH> bitemyapp: wat
13:24:30 <bitemyapp> ReinH: f is roader.
13:24:37 <bitemyapp> ReinH: g is accomplice
13:24:53 <ReinH> hodapp: Oh, right, you are using the monad interface in a sort of degenerate way, similar to lucid
13:25:02 <ReinH> bitemyapp: wat again
13:25:22 <ReinH> hodapp: I'd probably just do whatever lucid does, minus the extra fiddly bits
13:25:22 <ChristianS> bitemyapp: anarchists are very much for cooperation, so function composition is fine
13:25:30 <hodapp> ReinH: and usualy compositionally - to where you can define things elsewhere, and put them someplace (perhaps multiple times) in the hierarchy so that they inherit the properties at that point
13:25:43 <bitemyapp> ChristianS: ;)
13:25:56 <bitemyapp> hodapp: so you're saying they're functions
13:26:00 <ReinH> hodapp: You get that for free via the monad laws and referential transparency
13:26:05 <kristof> akegalj: Such a general zip cannot exist because one t will have a different structure from another t
13:26:39 <ReinH> well, except for "inheritance", I guess
13:26:55 <kristof> akegalj: Even if they are the same t. How do you zip two trees together? The only way to do it is to either bias to one structure or to convert to a canonical representation, like list
13:27:02 <hodapp> bitemyapp: I'm saying multiple things. I'm saying words. I'm saying they're functions. I'm saying they're Haskell. I'm looking for something that conveys more of the essence.
13:27:13 <bitemyapp> hodapp: you want intuition?
13:27:50 <hodapp> bitemyapp: I want a meaningful way to talk about this pattern, and see other implementations of it, since I rather doubt Atom is solely it.
13:27:54 <bitemyapp> hodapp: having taken a glance, I don't think it's formalized as anything in particular, but I think it's a stateful monad.
13:27:59 <hodapp> and it sounds like Lucid is one
13:28:02 <bitemyapp> hodapp: it's a hierarchy of nested lambdas.
13:28:11 <bitemyapp> hodapp: Hspec is too, but it's heterogenous.
13:28:29 <bitemyapp> so, that's my answer.
13:28:44 <kristof> what does propl even do?
13:28:52 <CpnStumpy> how exactly do I implement an instance against a typeclass again? (As in, instead of against an actual data type)
13:29:02 <hodapp> kristof: it applies some property to whatever is 'underneath'.
13:29:06 <kristof> CpnStumpy: You cannot. That's inheritance.
13:29:11 <CpnStumpy> I thought I remembered there's an extension that lets me do that so I can implement one type class in terms of another
13:29:38 <kristof> CpnStumpy: Make a generic wrapper around all T that implement such a Typeclass, and then make an instance of that other typeclass for your new wrapper type
13:29:40 <tulcod> CpnStumpy: you can say e.g.: "instance Monad a => Functor a"
13:29:59 <tulcod> (where blablabla)
13:30:15 <exio4> you mean the other way :p
13:30:26 <CpnStumpy> beautiful lemme try that, that's exactly how I meant
13:30:29 <tulcod> exio4: no? not every functor is a monad
13:30:41 <akegalj> kristof: Yes maybe having that would't make sense. What I really need is 'list' of elements but would like to apstract the list so someone can supply any other structure, and foldable seamed like good choice
13:30:42 <exio4> oh, instance, nvm
13:30:45 <kristof> CpnStumpy: If you want your datatype to hide the underlying, you can use an existential type.
13:30:48 <CpnStumpy> exio: no - the constraint is on the left, the implementing type is on the right (note the =>)
13:31:06 <akegalj> kristof: but taking toList from foldable is ok for me
13:31:11 <exio4> but that is basically overlapping with everything 
13:31:12 <CpnStumpy> kristof: I don't have a data type, I just am creating a type class that effectively extends functionality to every type that has implemented `mempty`
13:31:23 <exio4> making the functor class useless, and actually being just a simple function 
13:31:34 <hodapp> bitemyapp: yes, Atom used some wonky State-but-not-exactly-State-but-basically-State monad to achieve this but very incomprehensibly
13:31:48 <tulcod> CpnStumpy: "instance MyClass a, Monoid a => MyNewClass a"
13:31:51 <tulcod> i think
13:31:54 <akegalj> kristof: as a final result i don't really need (t a) , but only 'a', so I'm good with foldable
13:32:19 <geekosaur> needs parens. and is risky because it matches all types
13:32:38 <geekosaur> the correct way to do it is make a newtype and put the instance on that
13:32:38 <bitemyapp> hodapp: AS I SUSPECTED
13:32:42 <bitemyapp> hodapp: case closed. Next?
13:32:49 <tulcod> geekosaur: it's either correct or you shouldn't be writing this instance
13:32:52 <geekosaur> unless you really do intend only that instance
13:33:04 <exio4> and if you do, you can avoid using typeclasses at all
13:33:56 <hodapp> bitemyapp: nevermind.
13:34:28 <bitemyapp> hodapp: oh I'm just teasing you. You're right to notice Lucid as being comparable.
13:34:34 <hodapp> ReinH: http://hackage.haskell.org/package/lucid-2.9.2/docs/Lucid-Base.html#t:Attribute looks relevant
13:34:50 <hodapp> but they went about it in a different way (which is not surprising since a lot of Atom code is very wtf)
13:36:25 <bitemyapp> hodapp: what are you comparing Attribute to in atom?
13:37:04 <hodapp> can't remember offhand, maybe AtomSt, maybe Atom monad?
13:37:28 <bitemyapp> hodapp: looks Statey, but not sure how Attribute is comparable: http://hackage.haskell.org/package/atom-1.0.13/docs/src/Language-Atom-Elaboration.html#Atom
13:37:50 <bitemyapp> type AtomSt = (UeMap, (Global, AtomDB)) hum.
13:39:10 <hodapp> looking elsewhere in Lucid, I see the type signature "Term arg result => arg -> result" for a whole range of things
13:39:37 <bitemyapp> oh right, that thing.
13:39:50 <hodapp> that's not related to Attributes, I don't think, but it may be what I'm looking for
13:41:28 <bitemyapp> hodapp: not clear to me why all the terms aren't one big datatype.
13:41:42 <hodapp> bitemyapp: in Lucid?
13:41:45 <bitemyapp> yes
13:41:47 <bitemyapp> I'd need to kick it around to understand the point
13:42:10 <hodapp> I was looking at their table_ (tr_ (td_ (p_ "Hello, World!"))) :: Html () example and those calls
13:43:40 <orion> Does anyone know where in this code multiple keys containing the same name get filtered out?: https://github.com/scotty-web/scotty/blob/0.10.2/Web/Scotty/Route.hs#L180
13:43:44 <bitemyapp> hodapp: not really the same sort of thing as the Atom Monad though?
13:44:24 <hodapp> bitemyapp: it looks to me like it can be used in a very similar way
13:44:26 <Intolerable> orion: they don't iirc, they just look through the list for the first matching thing
13:46:04 <hodapp> and I see the instance Term [Attribute] (f -> HtmlT m a) - so the result of any of those various calls then can be another function, hmmm
13:47:33 <orion> Intolerable: Something strange is occurring then. When I submit a query string like ?x=0&x=1, I do not get what I expect: [("x","0"),("x","1")] Instead, I get [("x","1")]
13:47:50 <Intolerable> it might be backwards
13:48:01 <Intolerable> scotty's param handling code is really really weird
13:48:51 <hodapp> but, in hspec I see a lot of explicit "SpecWith a -> SpecWith a" at the ends of type signatures
13:49:02 <hodapp> which looks closer
13:49:36 <bitemyapp> hodapp: yeah Hspec was the first thing I thought of with your Atom example.
13:50:01 <hodapp> bitemyapp: what did you mean heterogenous?
13:52:02 <bitemyapp> hodapp: you can next Specs but there's a top-level.
13:52:06 <bitemyapp> of a different type.
13:52:09 <bitemyapp> nothing too interesting.
13:55:33 <hodapp> bitemyapp: https://hackage.haskell.org/package/hspec-2.2.0/docs/Test-Hspec.html#g:4 - yeah, those look pretty relevant. I've called things like that 'combinators' but I have no idea if that's a correct/descriptive term
14:00:54 <bitemyapp> hodapp: well, they're not properly combinators I don't think. They're making use of (>>) and (>>=)
14:01:00 <bitemyapp> hodapp: and those weren't passed in as arguments.
14:01:11 <bitemyapp> but they do have a combinatory'ish flavor WRT the Hspec API
14:02:04 <hodapp> and their core looks like WriterT & SpecTree
14:04:18 <CpnStumpy> Can't figure out how to make my monoid derivation work here reasonably generally (may not be possible) - I'm mostly there:
14:04:19 <CpnStumpy> http://lpaste.net/140708
14:05:32 <bitemyapp> CpnStumpy: data Bool = False | True
14:05:39 <bitemyapp> CpnStumpy: how do you pick a monoid for that>
14:06:09 <bitemyapp> CpnStumpy: Monoids are not, in general, unique. This is why Applicatives often aren't.
14:06:32 <bitemyapp> I'm not even really sure how to characterize the different sorts of Monoid instances beyond saying that some are like multiplication, others summation.
14:06:39 <CpnStumpy> bitemyapp: don't have to? If it *has* a monoid then the monoid instance will work, if not... (though mempty = True mappend = && works for bool, as well as False, ||)
14:07:10 <bitemyapp> CpnStumpy: wait wait, you're not deriving a Monoid, you're writing one?
14:07:25 <CpnStumpy> bitemyapp: I'm extending monoid with the `Field` typeclass
14:07:56 <CpnStumpy> so all types that meet the constraint `Monoid a, Eq a` can use `halt`, `onHalt`, `onContinue`
14:08:35 <kristof> Using SublimeHaskell and getting Not in scope: data constructor ‘H.PNeg’
14:08:38 <bitemyapp> CpnStumpy: how does it express halt vs. continue when you only have mappend at your disposal?
14:08:44 * hackagebot foldl-transduce 0.4.1.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.4.1.0 (DanielDiazCarrete)
14:08:58 <bitemyapp> CpnStumpy: if one of those operations is more like product, the other more like Sum and you want to express both in an algebra you need something bigger than Monoid.
14:09:02 <CpnStumpy> bitemyapp: I constrainted `Eq` as well so I can `Eq` mempty
14:10:11 <nshepperd> it looks like you're only using Monoid to get mempty out as a chosen value
14:10:37 <CpnStumpy> bitemyapp: the bool instance I defined works perfectly. I would however like to get that monoid instance working just for the heck of it, but it may be totally undecidable
14:10:45 <monochrom> CpnStumpy: you are writing "halt = mempty" without knowing that "instance Monoid (ByMonoid a)" exists
14:11:20 <nshepperd> oh yeah, you want halt = ByMonoid mempty
14:11:38 <CpnStumpy> monochrom: yeah.. and unfortunately I can't make `ByMonoid` deriving (Monoid) as it's not a type that allows that. Is there a way to add the derivation through constraint to `ByMonoid` ?
14:12:00 <CpnStumpy> nshepperd: !! yes! Thankyou!
14:15:09 <CpnStumpy> nshepperd:  err no... hrmm maybe I'm just shitting up a tree sideways. Anyway, will peek at it another day, Friday be over. Out.
14:19:13 <orion> Is there a function in base which allows one to take a [(a, b)] and turn duplicates of 'a' in to (a, [b])?
14:21:11 <orion> Wait, that makes no sense because the list needs to be homogenous.
14:21:28 <mmaruseacph2> I'd do it with a Map, mapAccum and they getting back the assoc list to get [(a, [b])]
14:21:42 <Clint> or (Data.Map.toList . Data.Map.fromAscListWithKey)
14:22:08 <suppi> orion, hoogle says no
14:22:29 <suppi> but building one should be pretty straightforward
14:23:26 <orion> The issue I'm running in to is that when I serialize a [(a,b)] to JSON with aeson, I must first convert it to a Map with fromList.
14:24:27 <glaukon_> Heap overflow problem, please help! http://stackoverflow.com/questions/32520595/heap-overflow-in-haskell
14:24:43 <orion> The goal is, if I have something like [("x", "0"), ("x", "1"), ("y", "2")], I want the JSON representation to be {"x":["0","1"],"y":"2"}
14:24:58 <monochrom> ok, don't do [(a,b)] -> [(a,[b])]. just do [(a,b)] -> Map a [b].
14:25:17 <monochrom> (add "Ord a =>")
14:25:41 <orion> monochrom: But, wouldn't that render as {"x":["0","1"],"y":["2"]}
14:25:46 <monochrom> yes
14:25:48 <catgocat> Hello everyone, what's the GUI library that everyones uses?
14:27:27 <orion> monochrom: I'm not sure that's what I want.
14:27:43 <monochrom> ok, do you accept Map a (Either b [b])?
14:28:08 <orion> That might work
14:28:18 <monochrom> and then maybe a final pass using Map.map for Map a (Either b [b]) -> Map a Object
14:29:15 <suppi> catgocat, I really don't know, but I might check out reflex-dom.
14:29:26 <monochrom> actually maybe Map a [b] -> Map a Object
14:29:41 <Sindriava> "let's send a canary down with the bitcoin miners" - gold
14:34:39 <syntagma> I should start learning haskell.
14:34:48 <syntagma> Every. Single. Day.
14:34:51 <dmj`> syntagma: yes
14:35:00 <emmanuel_erc> lol
14:35:01 <emmanuel_erc> yes
14:35:32 <syntagma> It's not going to be easy but it's going to be fun.
14:35:34 <monochrom> you can always start tomorrow
14:35:44 <syntagma> Should I?
14:35:47 <mauke> you are old, father william
14:36:13 <suppi> just do it.
14:36:16 <dmj`> syntagma: go hard or go home. 
14:36:24 <syntagma> Exactly.
14:36:25 <suppi> *diamond focus on crotch*
14:36:29 <syntagma> Screw it, let's doing.
14:36:34 <monochrom> go home today. go hard tomorrow.
14:37:02 <syntagma> go hard at home, tomorrow.
14:37:21 <mauke> romanes eunt domus
14:37:29 * Clint claps.
14:37:31 <dmj`> syntagma: study CIS194, LYAH, RWH, ParConc + Typeclassopedia, Grabmueller transformers. Then be able to write Prelude, Data.List, Control.Monad from scratch. 
14:38:41 <syntagma> Yes, that's my plan exactly. Will 1.5 weeks be just enough?
14:38:47 <dmj`> syntagma: Make a grid of data types (X - axis) and type classes (Y - axis), where the values are the instances. If you have Identity, State, Reader, Writer, Maybe, Either, (->), [], with Functor, Monad. Applicative, Monoid, you're probably doing fine
14:38:51 <dmj`> syntagma: 1.5 years
14:38:59 <monochrom> is that "Rome is ruled by eunuchs"?
14:39:18 <Sindriava> syntagma: DON'T LET YOUR DREAMS BE DREAMS! JUST- DOOOO IIIIITTTTT
14:39:23 <syntagma> I was planning on doing Grabmueller tranformers on my way to work on Monday
14:39:57 <syntagma> BTW they are not named that way, just monad transformers I guess
14:40:45 <dmj`> syntagma: be familiar with monads first, even though monad trasformers are still monads
14:41:12 <dmj`> syntagma: the haskell wiki is still good too
14:41:28 <montanonic> dmj`: I'm not sure I'd personally recommend RWH at this point; it doesn't seem to work well for a lot of people
14:41:36 <syntagma> dmj`, what are you working currently on (I assume your daily job is Haskell)?
14:41:52 <montanonic> dmj`: I think working on a project that you find interesting supplements the real world part
14:42:02 <syntagma> I wanted to start with Learn You (...) actually
14:42:04 <dmj`> montanonic: there might be some historical flavor, but yes, working on a project would be best
14:42:16 <suppi> syntagma, go with CIS194 in my opinion
14:42:17 <syntagma> dmj`, oh, so you don't write Haskell code in work
14:42:21 <montanonic> syntagma: learn you is great for showing you a bunch of cool stuff in Haskell
14:42:35 <montanonic> suppi: I agree, CIS194 is amazing
14:42:45 <montanonic> I haven't finished it myself, but that's because I'm working on two projects
14:42:46 <dmj`> syntagma: this is a good guide, https://github.com/bitemyapp/learnhaskell, which recommends CIS194, but Typeclassopedia is awesome, the sooner you get to it, the sooner the lambdas will flow
14:42:49 <syntagma> montanonic, just showing or letting me learn?
14:43:06 <montanonic> syntagma: just showing; I'd recommend what suppi recommended for learning
14:43:12 <dmj`> syntagma: right now I do
14:43:25 <montanonic> syntagma: although I'd recommend also reading LYAH at the same time, it has some very clear explanations of things
14:43:38 <montanonic> syntagma: it does a *great* job with Functors and Applicative Functors, for example
14:43:48 <montanonic> which are *very* fun and useful
14:44:32 <montanonic> syntagma: you'll definitely be able to do Haskell; I've only been learning it for just about 1.5/2 months, and I've only bee programming for 5
14:44:36 <dmj`> syntagma: PFDS is good too, it has haskell examples in the back
14:44:36 <montanonic> been*
14:44:41 <tombert> has anyone here used teh Wreq http library?
14:44:47 <syntagma> montanonic, this I won't believe
14:45:10 <montanonic> syntagma: you'll find out that aside from the math jargon, it's easier to use once you get the hang of it
14:45:16 <tombert> and if so, does anyone know of a good way to enable connection pooling?
14:45:30 <syntagma> montanonic, unless you have math background
14:45:34 <montanonic> just gotta commit to reading things about it and trying exercises as much as possible :)
14:45:44 <dmj`> @pkg resource-pool
14:45:44 <lambdabot> Maybe you meant: pl ping msg bug
14:45:49 <dmj`> @package resource-pool:
14:45:50 <lambdabot> http://hackage.haskell.org/package/resource-pool:
14:45:55 <montanonic> syntagma: it depends, but it's still going to throw Category Theory terms at you, which most people don't know
14:46:33 <dmj`> syntagma: do you program for work right now?
14:46:53 <montanonic> syntagma: though one important thing I'd recommend is please, please use Stack to install Haskell, and read the guide on Stack (it's on Github)
14:47:00 <montanonic> it will pay huge dividends for you
14:47:24 <syntagma> dmj`, Yes, I do, mostly C and C++.
14:47:33 <montanonic> it makes it *much* easier to get packages and revolve dependency issues
14:47:40 <syntagma> But I have some experience with FP, mainly OCaml
14:48:04 <montanonic> syntagma: oh cool; you'll be solid; I think getting used to folds was the hardest thing for me with FP
14:48:09 <dmj`> syntagma: perfect
14:48:25 <syntagma> montanonic, I have everything ready to go, just need some time to make some space in my mind for category theory and FP
14:48:40 <montanonic> syntagma: oh awesome! well I totally wish you luck; I know you'll have fun
14:48:59 <dmj`> syntagma: to use haskell you don't have to be a category theorist
14:49:07 <shachaf> Unless you specifically seek it out, you'll run into very little category theory in Haskell.
14:49:18 <montanonic> syntagma: just always read a different resource when one isn't working for you; there are lots availible; again though, CIS 194 is so so good, and it has 3 years of class material with differences every year, if you want to work through even more of it
14:50:04 <dmj`> syntagma: CIS194 is taught by the author of the Typeclassopedia (right?), anything byorgey is really good
14:50:13 <montanonic> on the otherhand, being comfortable with Functors, Monads, Arrows, that *is* important, and it seems like that's 40% learning category theory, isn't it?
14:50:17 <shachaf> You might get the first few pages' worth of a category theory book.
14:50:20 <suppi> this is the recommended cis194 I think: https://www.seas.upenn.edu/~cis194/spring13/
14:50:33 <syntagma> I see. What about lambda calculus? I have an optional class at my university and I am thinking about it.
14:50:42 <suppi> syntagma, I'd go for it :D
14:51:21 <Roger_grealish> montanonic: so should new haskell developers not bother with cabal at all, and start with stack straight away?
14:51:23 <montanonic> syntagma: yeah that seems like a good opportunity
14:51:42 <shachaf> Category theory people don't talk about the Haskell concept of Arrow -- most Haskell people don't talk about it either, it's not very important -- and their functors are much more general than what you have in Haskell.
14:52:05 <montanonic> Roger_grealish: well you'll *need* to bother with Cabal a bit, and I'd say that Cabal isn't a bother to the extent that it fills a huge gap needed in haskell
14:52:13 <montanonic> Stack just makes it much *easier* to use cabal
14:52:14 <suppi> I don't know CT at all
14:52:48 <montanonic> And the project I'm volunteering on, which is hoping to launch sometime in the medium-future, has solved tons of issues by using stack
14:52:58 <suppi> (I'm still using cabal)
14:53:03 <montanonic> Roger_grealish: so to that degree, use Stack for every project
14:53:11 <Welkin> I have not yet tried stack
14:53:20 <Welkin> but cabal works fine for me at the moment
14:53:32 <Roger_grealish> montanonic: ok thanks
14:53:33 <suppi> My experience with cabal was pretty painless since I discovered sandboxes. at least for my use case
14:53:42 <Welkin> I solve most of the issues by just using a cabal.config with explicit constraints in it (basically, my own version of stackage)
14:53:44 <syntagma> OK thanks guys
14:53:57 <suppi> syntagma, have fun!
14:54:03 <montanonic> Roger_grealish: for sure; if you're familiar with Cabal sandboxes, Stack is just a more advanced version of that (as far as I can tell)
14:54:22 <montanonic> well, it's more than that, but functionally, it serves that purpose
14:54:26 <dmj`> syntagma: everyday
15:07:33 <Roger_grealish> montanonic: ok, so if I don't know how cabal sandboxes work, I should learn that before using stack?  I've never done any haskell beyond project euler problems.
15:07:52 <montanonic> Roger_grealish: oh, no don't worry about it, let me link you something
15:08:27 <montanonic> Roger_grealish: https://github.com/commercialhaskell/stack/blob/master/GUIDE.md
15:08:59 <montanonic> Roger_grealish: what OS are you on?
15:09:12 <Roger_grealish> osx
15:09:20 <Roger_grealish> (yosemite)
15:09:36 <montanonic> okay, yeah, it should work just fine
15:09:44 <montanonic> *should*; I use Linux
15:10:06 <montanonic> Roger_grealish: https://github.com/commercialhaskell/stack/wiki/Downloads
15:10:11 <montanonic> it has the OSX build information there
15:10:35 <montanonic> once you get it downloaded, follow the guide to create a folder that you'll have a project in
15:11:44 <montanonic> It has several templates you can pick from, and I think `stack new _FOLDERNAME_ simple` is the easiest way to start if you just want to have a little workstation
15:12:05 <montanonic> where _FOLDERNAME_ is the name of the project folder you want it to create in the current directory
15:14:03 <lamefun> Is there a library that can define a parser and a formatter at the same time ("Biparsec"?).
15:16:39 <Welkin> project euler is the stereotypical exercise for new haskell users to start with
15:16:41 <Welkin> haha
15:16:47 <Welkin> it is a really bad introduction to the language though
15:17:06 <suppi> yup
15:17:09 <Welkin> one that makes more sense is a course like CIS194
15:17:12 <suppi> (though I did that also)
15:17:21 <Welkin> or Write Yourself a Scheme in 48 Hours
15:17:34 <Lutin`> lamefun: I don't know of a library that's explicitly meant for that, but people have done it
15:17:48 <suppi> I don't think I could handle the last one without prior haskell knowledge
15:18:21 <Roger_grealish> I did look at the Write Yourself a Scheme one and it looked pretty heavy
15:18:32 <Welkin> Roger_grealish: I used it when I first started
15:18:37 <Welkin> it helped me understand a lot
15:18:54 <monochrom> most people use Project Euler to learn list comprehension and brute-force algorithms to great success
15:19:08 <Welkin> the point at which I really began to get comfortable in Haskell was when I built a full-featured web application in Yesod
15:19:10 <monochrom> (in other words, learn nothing else)
15:19:41 <Welkin> but the best way to start is CIS194 then Nicta
15:19:44 <Welkin> @where learnhaskell
15:19:44 <lambdabot> https://github.com/bitemyapp/learnhaskell
15:19:56 <Welkin> and the Typeclassopedia
15:19:56 <Lutin`> that's why you have to sort by how many people have solved it (ascending) and work your way down till you think you can do one
15:20:01 <Welkin> @where typeclassopedia
15:20:01 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
15:20:37 <Lutin`> https://projecteuler.net/problem=512 was fun
15:20:43 <Welkin> yeah, the only thing I learned form project euler was that brute force methods suck
15:20:46 <Welkin> :D
15:20:58 <Welkin> and it is the only place I ever use list comprehensions
15:21:05 <geekosaur> project euler is great for teaching math fundamentals
15:21:06 <Welkin> I never use them in haskell
15:21:20 <geekosaur> not so great for learning languages >.>
15:21:27 <Lutin`> indeed
15:21:36 <kaidelong> project euler is pretty good for embarrassing Haskell
15:21:37 <Welkin> yeah, I realized that using math insight to solve the problems is the only way to go
15:22:01 <lispy> I thought PE was good for teaching dynamic programming
15:22:18 <kaidelong> that might also make it a better language to do the problems in since you can't rely on the performance of the Haskell runtime to make things easier
15:22:33 <monochrom> Project Euler teaches you what you have already learned.
15:22:34 <Lutin`> lispy: I would agree with that
15:23:01 <monochrom> actually, that's off
15:23:10 <monochrom> Project Euler teaches you what you are already aware of.
15:23:30 <monochrom> if you are not aware of dynamic programming, Project Euler will not teach you that.
15:23:53 <monochrom> if you are already aware of dynamic programming, then Project Euler gives you a chance to practice it.
15:24:00 <kadoban> Some project euler problems would be decent practice ... but they're totally unordered and uncategorized, so you'd basically have to search through them all and know enough to recognize that it'd be good practice for whatever you're trying.
15:24:11 <nolrai66> Yeah.
15:24:13 <monochrom> similarly other topics such as number theory
15:24:39 <nolrai66> I got through a bit of them, but..if you are trying to learn something they are not super useful.
15:24:49 <Lutin`> I'm not sure if I would even say Project Euler teaches
15:25:08 <Lutin`> It more provides a set of problems to motivate you to teach yourself
15:25:08 <Welkin> it is a game
15:25:13 <syntagma> It teaches, if you want it to.
15:25:40 <monochrom> likewise, if all you know is brute-forcing, then Project Euler gives you a lot of practice on brute-forcing.
15:25:46 <nolrai66> I wanted it too.
15:25:47 <monochrom> Project Euler is a mirror.
15:26:02 <kaidelong> needing dynamic programming would explain why Haskell does not work that well, I guess
15:26:02 <nolrai66> It gave me practice with small scale haskell.
15:26:11 <kaidelong> Haskell gives you extremely limited forms of mutation
15:26:20 <kaidelong> you can just evaluate thunks
15:26:48 <nolrai66> What is "dynamic programing"?
15:26:57 <Welkin> you can do dynamic programming just using a list
15:27:00 <Lutin`> !give nolrai66 wiki dynamic programming
15:27:08 <Lutin`> bah
15:27:13 <kadoban> nolrai66: It's a really bad term for what's essentially caching partial results to solve a bigger problem.
15:27:14 <kaidelong> Welkin: if you like doing things polynomially rather than linearly, sure
15:27:22 <kadoban> nolrai66: It's an algorithmic technique.
15:27:29 <monochrom> a large chunk of dynamic programming does not need mutation. it only needs write-once read-many. therefore Haskell beats other languages on this. https://wiki.haskell.org/Dynamic_programming_example
15:27:35 <Welkin> you could use Vectors too for the same purpose
15:27:46 <Lutin`> nolrai66: solving a larger problem by breaking it down to simpler subproblems
15:27:53 <nolrai66> kaidelong: you can do mutation in haskell, not very efficently.
15:28:05 <Welkin> mutation is handled by the ST monad
15:28:10 <monochrom> Haskell beats other languages on this because Haskell non-strictness can figure out the data dependency for you, so you don't have to code up the dependency.
15:28:15 <kadoban> You can do mutation just fine. You just have to be explicit about when you want it.
15:28:15 <Lutin`> nolrai66: and taking advantage of overlapping subproblems
15:28:18 <Welkin> I don't see any difference with other languages in that regard
15:28:21 <nolrai66> Oh I forgot about ST.
15:28:22 <Welkin> you can mutate just fine
15:28:25 <Welkin> and do it in a pure way
15:28:26 <nolrai66> Doh.
15:28:27 <nshepperd> monochrom++
15:28:29 <kaidelong> monochrom: I think that's exactly what hurts in PE problems
15:28:38 <kaidelong> it's very easy for you to do better at this than the compiler
15:28:40 <nshepperd> you can do dynamic programming without mutation easily
15:28:41 <kadoban> nolrai66: Also IO, like IO refs.
15:28:43 <syntagma> BTW is there any plugin for Vim that would help me with types?
15:28:54 <kaidelong> explicit mutation is easier than figuring out an evaluation strategy that is efficient
15:28:54 <nshepperd> using lazy arrays or explicit memoization
15:29:37 <nolrai66> kaidelong: Could I get an example?
15:29:58 <monochrom> I know of a dynamic programming algorithm that really needs mutation (i.e., the whole table gets fully revised every iteration), but this seems rare.
15:30:15 <kaidelong> nolrai66: well one example would be calculating collatz lengths. The idiomatic Haskell way to do this would be to make a list of collatz lengths that recursively uses itself in its own definition
15:30:17 <kadoban> kaidelong: ... I personally think you're going down some weird path. Even in languages /with/ mutation, the only thing it's used for is what's basically the cache of the dynamic programming problem. You just explicitly use State or ST or whatever in Haskell and it works great. It's ... not really very different at all, except it's safer.
15:30:21 <kaidelong> but this is terribly slow
15:30:38 <nolrai66> ST isn't slow.
15:30:53 <nolrai66> collatz?
15:30:56 <Lutin`> kaidelong: then don't use a list? 
15:31:01 <nshepperd> kaidelong: I think the idiomatic way would be to use a patricia tree instead of a list
15:31:05 <kaidelong> needing to enter ST is the embarrassment, yes
15:31:24 <kaidelong> nshepperd: what about a trie?
15:31:32 <kaidelong> it is a function from the naturals
15:31:33 <kadoban> Needing to be explicit about your mutable state is an embarrassment? O.o
15:31:46 <Lutin`> you don't even need mutable state in that case..
15:32:00 <Lutin`> Like monochrom said, it's write-once, read-many
15:32:09 <Lutin`> take advantage of the laziness
15:32:09 <kaidelong> I understand that
15:32:12 <nolrai66> Yeah a list is wrong.
15:32:18 <kaidelong> laziness is a limited form of mutation
15:32:20 <nolrai66> Its just an array.
15:32:22 <nolrai66> ...
15:32:29 <nolrai66> Yes.
15:32:31 <kaidelong> nolrai66: lists are not arrays, and that's the problem
15:32:53 <nshepperd> haskell has arrays o_O
15:32:56 <nolrai66> ..no I mean this is where you use an array or map or patritatree.
15:33:16 <Welkin> nshepperd: ...of course
15:33:20 <Welkin> they are fundamental
15:33:20 <kaidelong> implementing write-once, read-many structures for things like data structures for memoization is not a natural thing to do
15:33:25 <Welkin> Data.Array and Data.Vector
15:33:48 <nshepperd> kaidelong: of course it is, in haskell
15:33:51 <nolrai66> How is it not?
15:33:57 <monochrom> http://hackage.haskell.org/package/memoize uses a lazy binary search tree so you don't have to worry about unknown bounds
15:33:59 <nshepperd> the memoize package even does it all for you
15:34:50 <monochrom> "natural" is subjective.
15:35:18 <kadoban> kaidelong: ... I actually just got done doing quite a few dynamic programming problems in haskell. They seemed nice to me. I'm still not clear on why you disagree. Yeah I'm also not sure what "natural" means in this context.
15:35:20 <monochrom> my "natural" means I just write down the recurrence.
15:35:21 <nolrai66> And ..what do you even mean by "implementing" write-once, read-many?
15:35:45 <nolrai66> Thats just kind of the default.
15:36:05 <kaidelong> kadoban: the problem for me isn't with the syntax or expression per se
15:36:13 <nshepperd> I don't even know how i'd calculate collatz lengths naturally in another language, since I don't know how I'd decide on my array bounds
15:36:17 <kaidelong> you can express very natural looking, glorious solutions in Haskell
15:36:23 <kaidelong> and they will run incredibly slowly
15:36:26 <monochrom> strict and eager languages forbid me from writing the recurrence at all. they ask me to guide them: what to evaluate first?
15:36:30 <kaidelong> no dispute there, my problem is with the second part
15:36:43 <kadoban> kaidelong: ... mine were for a programming competition site, with pretty strict time bounds. I had little problem meeting them.
15:36:44 <nolrai66> Yeah, if you use a list.
15:36:56 <kaidelong> nolrai66: trees don't improve things much
15:37:09 <kaidelong> proper chunking and unboxing helps a lot when dealing with tons of small values
15:37:26 <kaidelong> trees improve asymptotics but constant factors matter a lot
15:37:33 <nolrai66> Ah. I can see that.
15:38:13 <kaidelong> also the most natural data structure to use in Haskell are lists, so people use them as a first resort
15:38:27 <monochrom> that is not my "natural"
15:38:34 <kaidelong> this might have been a mistake but I actually think it does make some sense for Haskell in light of fusion (which the language standard should guarantee)
15:38:56 <nolrai66> I guess..I never use a list if its going to be large though.
15:38:59 <monochrom> my "natural" is that the most natural thing to do in Haskell is to define my own data structure that fits my problem
15:39:15 <kadoban> Lists are far from the only data structure in haskell, and they're far from "the first resort". I use whatever is appropriate.
15:39:16 <kaidelong> right, this for me is where purity gets annoying
15:39:35 <nshepperd> using a list for memoization is generally the Wrong Thing
15:39:39 <kaidelong> I would much rather use a library like Data.Function.Memoize than make a purpose-built data structure myself, in Haskell
15:39:42 <nshepperd> it's nothing to do with purity
15:40:05 <monochrom> as for constant factors, Project Euler's timer is already lax with that.
15:40:08 <kaidelong> nshepperd: you have to be explicit about benign effects or get the runtime system to do them for you via laziness
15:40:38 <Lutin`> You realize Data.Function.Memoize is pure, yeah?
15:40:50 <kaidelong> Lutin`: so it uses the second approach, then
15:41:01 <Lutin`> ?
15:41:21 <kaidelong> you can get the Haskell runtime to do mutation on your behalf through exploiting how lazy evaluation works
15:42:08 <kadoban> Again, how is mutation even desired for whatever we're even talking about anymore? And ... what?
15:42:09 <kaidelong> it's limited in such a way that you know the result is not observably impure, kind of like ST (although you can break referential transparency of ST using things like STT or unsafeInterleaveST)
15:42:30 <kaidelong> kadoban: thunks are destroyed and updated in place when they are evaluated
15:42:35 <kaidelong> it's mutation
15:43:10 <monochrom> I don't understand why you have to look at that low level to justify saying "mutation"
15:43:17 <kadoban> Barely, but okay. That has to do with ... what anymore?
15:43:36 <monochrom> by your standard, not only dynamic programming requires mutation, all computing requires mutation
15:43:37 <kaidelong> the idiomatic way to achieve dynamic programming in haskell is to use lazy evaluation
15:43:48 <kaidelong> monochrom: why, yes it does
15:44:03 <kaidelong> that is what my standard is
15:44:05 <kaidelong> I guess
15:44:12 <kaidelong> that to me is not surprising, or controversial
15:44:26 <monochrom> at which point you have to say that all computing, not just PE dynamic progrmaming exercises, embarass Haskell.
15:44:30 <kaidelong> well, maybe the "all computing" part
15:44:43 <nshepperd> so what's wrong with using lazy evaluation then
15:44:52 <kaidelong> nshepperd: in principle, it's better
15:45:02 <monochrom> but you only set out to argue about dynamic programming, not all computing.
15:45:18 <kaidelong> in practice it's harder for me to figure out how to improve a program that uses lazy evaluation than one that uses explicit mutation
15:45:29 <kaidelong> subtle tweaks can wreck performance in non-obvious ways
15:46:40 <kaidelong> monochrom: I think the fundamental issue might be more universal yes, it is just normally outweighed more by the benefits
15:47:02 <monochrom> so until you openly declare "yes, I say that all computing embarass Haskell", I am going to conclude tentatively that you're using double standard.
15:47:05 <kaidelong> when doing numerical work, it's less obvious the benefits outweigh the annoyances compared to something like C
15:47:45 <kaidelong> I don't understand how you can conclude that
15:47:57 <Lutin`> the key is tradeoffs
15:48:06 <kaidelong> even if computing embarrasses haskell that doesn't mean haskell is bad for programs
15:48:11 <nshepperd> well, I see no problem with writing expensive tight loops in C and then calling into them from haskell ffi
15:48:30 <kaidelong> nshepperd: right, in fact, that is what I'd recommend
15:48:44 <kaidelong> but I think people trying the PE problems in Haskell will be disappointed
15:48:52 <nshepperd> if they're small enough that the laziness overhead is really bigger than the actual cost
15:48:59 <kaidelong> although it might be great from the learning POV, because Haskell is so different in this regard
15:49:17 <nshepperd> no, I doubt PE problems care much about constant factors
15:49:23 <kaidelong> and it is mind bending to try to get Haskell to do these things efficiently
15:49:54 <Lutin`> bending your mind is good. Otherwise it gets rigid and stuck up :P
15:50:27 <nshepperd> I never had to rewrite a google code jam solution in C to get them fast enough
15:50:30 <kaidelong> it's just disheartening to see clever solutions in compiled haskell being beaten by naive ones in python
15:50:52 <monochrom> PE's timer cannot possibly be very tight on constant factors. it has to accomodate a lot of interpreters too. GHC is not the most heavily boxing thing in the world. at various points python and ruby can be even worse.
15:50:54 <Welkin> nshepperd: https://ro-che.info/ccc/25
15:51:05 <Lutin`> wait
15:51:09 <Lutin`> PE has a timer now?
15:51:15 <Lutin`> this all makes sense now
15:51:22 <kadoban> kaidelong: I really still don't know what you're arguing.
15:51:24 <nshepperd> Welkin: haha
15:51:34 <kadoban> PE doesn't even /have/ a timer, so ... yeah I have no idea what's going on anymore.
15:51:52 <monochrom> wait, it doesn't?
15:51:58 <kadoban> At one point I did quite a few PE problems in haskell. Even as a newbie they went fine. There's haskell answers to like /all/ of them, if you look in the problem forums.
15:52:00 <kaidelong> not to my knowledge
15:52:03 <kadoban> No, you just give the answer.
15:52:08 <monochrom> ok, I see
15:52:28 <kaidelong> the problems are perfectly solvable in Haskell and all
15:52:30 <kadoban> It's not randomized or anything. I think they have some rule of thumb that your program should be able to do most of them in like a minute or something, but ... it's honor system.
15:52:42 <kaidelong> just you take 7 seconds rather than 2 because of constant factors
15:52:46 <kadoban> For the ones I knew enough math for, that was never a problem.
15:52:49 <kaidelong> that's what made me tear my hair out
15:52:54 <nshepperd> kaidelong: if naive python is beating haskell the problem is probably not that you're not unboxing your values
15:52:56 <kaidelong> things like F#, Python, should rightly be slower than python
15:53:13 <kaidelong> than Haskell*
15:53:14 <Lutin`> "Python, should rightly be slower than python" :P
15:53:19 <kadoban> kaidelong: 5 seconds of runtime makes you want to tear your hair out? I think I'm rather okay with that when it takes me less time to code it.
15:54:13 <kaidelong> kadoban: you want F# then, it's generally less verbose too
15:54:27 <exio4> F# lacks higher-kinded types
15:54:28 <kaidelong> the thing I like about Haskell isn't just its syntax/expressiveness
15:54:40 <kadoban> Why do I want F#? I'm having fun in haskell, thanks. Thanks for telling me what I want though, that's ... something.
15:54:47 <kaidelong> it's the neat type system, the purity, and the fact that laziness by default usually helps
15:55:04 <kaidelong> and the fact that Haskell makes it really hard to shoot yourself in the foot
15:55:21 <kaidelong> those are all good things, and worth sacrificing expressiveness for
15:55:26 <Lutin`> oh no...I can't login to Project Euler
15:56:03 <Welkin> yeah
15:56:06 <Welkin> they got hacked a while bak
15:56:09 <Lutin`> "Sacrificing expressiveness"?
15:56:10 <Welkin> accounts were deleted
15:56:14 <Welkin> I had to make a new account too
15:56:30 <kaidelong> Lutin`: having to be a little bit more verbose
15:56:48 <kaidelong> I cannot fault Haskell on its expressiveness, it's worlds above most of the competition there, definitely
15:58:52 <nshepperd> well, if you have an actual problem with the performance of one of your solutions, you can post your code and someone here will probably be able to explain how to optimise it
15:58:52 <hardmath123> Hi #haskell! Quick question -- does Haskell have an analogue of Scheme's interned `symbol`s? I'd use strings, but equality-checking strings is probably slow since they aren't interned.
15:59:05 <kaidelong> exio4: higherkinded polymorphism, it has HKTs
15:59:12 <nshepperd> i feel like that would be more productive than monologuing about it
15:59:34 <hardmath123> The context is that I want to represent Horn clauses in a Haskell datastructure somehow. Any advice on the "idiomatic" way to do that would be ncie.
15:59:39 <hardmath123> *nice
15:59:41 <osa1> hardmath123: http://hackage.haskell.org/package/symbol
15:59:57 <ski> hardmath123 : depending, data constructors would often be used for similar purposes
16:00:08 <dibblego> kaidelong: no .NET language has higher kinds, including F#
16:00:44 <dmj`> nor OCaml
16:00:49 <exio4> it also doesn't have lots of GHC extensions, like RankNTypes 
16:01:04 <exio4> (as far as I know...)
16:01:06 <ski> hardmath123 : well, i suppose you could manually map identifiers to integers ..
16:02:13 <kaidelong> dibblego: I'm less sure how to respond to that, it doesn't really have "kinds" at all
16:02:19 <kaidelong> but it has higher kinded types
16:02:21 <kaidelong> like ->
16:02:31 <kaidelong> it does not have higher kinded polymorphism, though
16:04:27 <kaidelong> also didn't OCaml modules allow you to get HKP?
16:04:32 <kaidelong> even if that is a hack
16:05:05 <dibblego> first-order kind
16:05:21 <ski> kaidelong : can you express `data Tree f a = Leaf a | Branch (f (Tree f a))' (possibly uncurried) ?
16:05:53 <kaidelong> ski: no, that requires you to be polymorphic on a type of a higher kind
16:06:00 <kaidelong> that is not supported
16:06:44 <ski> merely defining such a type wouldn't require you to be "polymorphic on a type of a higher kind"
16:07:03 <kaidelong> why not, you take f as a parameter
16:07:14 <kaidelong> you want to be polymorphic on it
16:07:21 <kaidelong> you could fix it, that would be perfectly supported
16:07:26 <kaidelong> but you can't be polymorphic on it
16:07:26 <ski> if you wanted to be able to define `foo :: Tree f a -> ...' (rather than, say `bar :: Tree [] a -> ...') then you'd need such polymorphism
16:07:51 <kaidelong> oh, I see
16:08:07 <kaidelong> mm, well
16:08:17 <montanonic> Is Applicative now a Superclass of Monad in GHC?
16:08:23 <kaidelong> then I misunderstood the term higher kinded polymorphism
16:08:24 <ski> (of course, having the former, you'd really want the latter as well. but they are two separate (though related) things)
16:08:32 <kaidelong> because to me, your definition of tree uses it
16:08:35 <geekosaur> montanonic, as of 7.10, yes
16:08:46 <nshepperd> I don't know F#, but I wouldn't say C++ has "higher kinded types" even though it has types like set<a>, because it always has to be applied to something. writing 'set' by itself is considered pretty much meaningless
16:08:47 <montanonic> geekosaur: okay, cool! :) ty
16:09:29 <kaidelong> nshepperd: I don't know how useful it really is to complain about C++ only checking types after they are fully expanded, I don't think it is meaningfully different from something like Haskell
16:09:44 <ski> kaidelong : `bar :: forall (a :: *). Tree [] a -> ...' is not higher-kinded polymorphism. `foo :: forall (f :: * -> *) (a :: *) -> Tree f a -> ...' is, because the kind of the `forall'-bound type variable `f' is not `*'
16:09:45 <kaidelong> I would still consider C++ to support higher kinded polymorphism
16:09:58 <kaidelong> template templates were not intended to provide that feature but, de facto, they do
16:10:03 <nshepperd> kaidelong: in haskell Set is a discrete entity with a kind
16:10:11 <kaidelong> but C++ type system supports everything because it is turing complete anyway
16:10:14 <nshepperd> you can refer to it directly
16:10:25 <kaidelong> well
16:10:27 <kaidelong> the templates are
16:10:46 <nshepperd> in C++ you can't do anything with 'set' except write 'set<foo>'
16:10:55 <ski> kaidelong : having `Tree :: (* -> *) -> * -> *' would be a higher-order type (not kind), because the kind of the first type argument is a function kind (iow, the first type argument is a type function)
16:11:06 <scshunt> that's a lie
16:11:07 <kaidelong> set is a template, you can pass it as a parameter to templates that take templates
16:11:11 <scshunt> ^
16:11:12 <kaidelong> so no, nshepperd, that's wrong
16:11:27 <scshunt> template <template <typename> T> ...
16:11:33 <nshepperd> you can?
16:11:35 <nshepperd> whoa
16:11:52 <kaidelong> it was kinda an accident
16:11:57 <kaidelong> but it means you can do things like Monad in C++
16:12:00 <kaidelong> which is neat
16:12:06 <kaidelong> you can't in F# or C#
16:12:11 <shachaf> Poor innocent nshepperd is not acquainted with the ways of the world.
16:12:37 <nshepperd> my god, this changes everything
16:12:53 <kaidelong> ski: do you have a good link on precise defn's for this?
16:14:29 <kaidelong> dibblego: looks like F* supports higher-kinded types
16:14:35 <shachaf> "turing complete" and "supports everything" are not the same.
16:14:37 <kaidelong> although it just models them as Type -> Type
16:14:46 <ski> kaidelong : parametric type (iow function type) definitions doesn't use polymorphism at all (sometimes people misuse terminology here). polymorphism is like `length :: [a] -> Int', which really is short for `length :: forall (a :: *). [a] -> Int'. it's the `forall' in the type which expresses that the value `length' is polymorphic
16:14:53 <kaidelong> it's a dependently typed language, so I guess it kinda gets them for free like that
16:15:00 <kaidelong> but there's a .NET language that has it
16:16:02 <ski> kaidelong : it would also be possible to have a polymorphic type. with extensions, one can e.g. define `data Flip f b a = MkFlip (f a b)' such that `Flip' is a polymorphic type, with kind `forall k0 k1. (k0 -> k1 -> *) -> k1 -> k0 -> *'
16:17:09 <kaidelong> ski: but your Tree isnt' a polymorphic type in the same way?
16:17:32 <ski> kaidelong : correct. it is a monomorphic type, with kind `(* -> *) -> * -> *' (no `forall' in that kind)
16:17:43 <kaidelong> ah I see
16:17:45 <ski> `Tree' is a parametric type, aka a type function
16:18:03 <kaidelong> I get that now, k0 and k1 are not neccessarily *
16:18:13 <ski> in this case, a higher-order type function (because it accepts a (first-order, in this case) type function, as argument)
16:18:20 <ski> yes
16:18:25 <kaidelong> because f can have a type like (* -> *) -> * -> *
16:19:05 <kaidelong> so what do we call the tree example if it isn't higher-kinded polymorphism?
16:19:13 <kaidelong> higher-kinded parameters?
16:19:15 <ski> a higher-order type
16:19:19 <kaidelong> okay
16:19:35 <kaidelong> so then F# lacks higher order types?
16:19:41 <kaidelong> it also would lack higher-kinded polymorphism
16:20:10 <kaidelong> but it's more correct to say it lacks higher order types then
16:20:14 <kaidelong> I'll try to remember that
16:20:32 <kaidelong> what is the meaning of a "higher-kinded type" in this context?
16:20:34 * ski isn't quite sure what "higher-kinded" is supposed to mean
16:20:38 <kaidelong> I assumed it was just like, []
16:20:57 <exio4> high-order type is what I meant
16:21:34 <kaidelong> I'm going to chalk that up to being confused on terminology
16:21:41 <ski> one could take it to mean that it refers to kinds that are the kinds of higher-order types, maybe
16:22:46 <kaidelong> I'm actually wondering if F* can be considered to have higher order types or not
16:23:04 <ski> however, it seems that maybe people want to use "higher-kinded polymorphism" not only for a type of the shape `forall (g :: (* -> *) -> *). ..g..', but also for one of the shape `forall (f :: * -> *). ..f..', where the type variable `f' itself is first-order, not higher-order
16:23:09 <kaidelong> since you can make functions between Types, and take those functions as parameters, it seems like it should be considered to have them
16:23:13 <ski> (since higher-order usually implies an order greater than one)
16:23:19 <kaidelong> but someone might object that this is "value-level"
16:23:22 <exio4> what killed F#'s type system is the `natural` .NET interop
16:23:37 <kaidelong> but the entire point of dependently typed programming is that there is no distinction between value level and type level, I thought
16:25:06 <kaidelong> exio4: it has some OCaml legacy too
16:25:12 <ski> there's still the distinction that types can have inhabitants, values can't
16:25:39 <ski> can you elaborate on how these functions between types work in F# ?
16:25:49 <kaidelong> ski: this is F*, not F#
16:26:07 <ski> oh, mea culpa
16:26:18 <kaidelong> F* is a dependently typed language for .NET with termination checking
16:26:39 <ski> aye, i now remember F* being something else (which i haven't looked at in detail)
16:29:21 <kaidelong> mmm
16:29:28 <kaidelong> I'm no longer sure it has higher-order types
16:29:28 <ski> btw, Mercury has multi-parameter type classes (with FDs), but tyvars can only have kind `*', so you can't make a `Functor' class, e.g.
16:29:51 <kaidelong> but that's mostly just because F* is so strange to me
16:30:03 <kaidelong> it can express things like higher-order types but I'm not comfortable with the terminology
16:31:36 <kaidelong> it has first class kinds
16:31:50 <kaidelong> you can define new kinds, and kinds can be functions that produce types
16:32:05 <mietek> What does it mean that a type is "not promotable"?
16:36:30 <geekosaur> mietek, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html "The following restrictions apply to promotion:"
16:36:51 <geekosaur> (or, you had DataKinds enabled and accidentally used a type as a kind?)
16:37:06 <geekosaur> (or a data constructor as a type constructor maybe)
16:37:08 <mietek> geekosaur: yes, I’m reading this, but it doesn’t explain...
16:37:17 <mietek> OK.
16:37:20 <geekosaur> well, what's it complaining about?
16:37:37 <mietek> Probably using type as a kind, as you say
16:38:00 <mietek> Thanks.
16:56:32 <CpnStumpy2> did anybody come up with a solution to my lpaste?
16:58:27 <CpnStumpy2> Or has anybody decided if the concept I'm looking for is correct to be called a `Field` ? http://lpaste.net/140708
16:58:33 <Gurkenglas> Why doesn't Witherable export blight?
16:59:35 <arkeet> Gurkenglas: https://github.com/fumieval/witherable/commit/6d4c097c64f674ff4e5cdc712522fe197c0a1fb4
17:00:01 <CpnStumpy2> totally unrelated note - is Yesod still the web framework du jour or has any other frameworks really overtaken it on the hype/popularity scale? (any really straightforward JSON restful web frameworks out there or is everyone still just using warp directly for that?)
17:00:04 <arkeet> it just hasn't been released yet.
17:05:03 <wedify> what's the arrow equivalent to join f (a, b) = f a b?
17:05:19 <wedify> man is the type of (***) confusing
17:05:54 <Cale> wedify: It may help if you write  a b c  as  b ~> c  instead
17:06:00 <orion> Has anyone developed an elegant method for compiling the git commit ID in to your application?
17:06:51 <Cale> orion: Wouldn't the git commit ID depend on itself then? You want to find some kind of fixed point of the hashing function?
17:07:24 <orion> Cale: The binary is not included in the repo.
17:07:39 <d-snp> :D
17:08:06 <Cale> Oh, I suppose you could use Template Haskell to read Git's junk at compile time.
17:08:08 <thoughtpolice> Cale: No, because normally you generate a file with the commit ID inside or something at build time, before compiling. So the file containing the hash is never part of the source tree.
17:08:31 <orion> Oh, cool!: https://hackage.haskell.org/package/gitrev-1.1.0/docs/Development-GitRev.html
17:08:37 <wedify> so (***) :: (a ~> b) -> (c ~> d) -> (a, c) ~> (c,d)?
17:08:52 <Cale> wedify: Yeah
17:08:53 <CpnStumpy2> Gads Haskell's library system is explosive... everytime I look at doing Haskell stuff again I find a shit load of new standard libs come with the GHC framework that previously had to come from cabal, and way more stuff on hackage that has become basically standard use... either that or I'm terribly lacking on learning the libs..
17:08:54 <Cale> er
17:08:58 <CpnStumpy2> (plausibly the ladder)
17:09:03 <Cale> wedify: modulo letter typos
17:09:16 <Cale> (***) :: (a ~> b) -> (c ~> d) -> (a, c) ~> (b, d)
17:09:23 <wedify> so it always operates on tuples?
17:09:32 <Cale> yes
17:09:44 <Cale> The resulting arrow operates on tuples
17:10:26 <wedify> alright that makes sense. i was thinking it was more general and so overloaded my brain
17:11:25 <CpnStumpy2> Cale: thx for teaching me what a group was like 3 years ago; turned out to be the most helpful thing I learned as it helped me understand the concept of maths abstractions and how they can aid coding
17:11:27 <Cale> You can think of the resulting arrow  (a, c) ~> (b, d)  as having two input and two output ports, and (f *** g) is the thing which internally wires the a input to the b output using f and wires the c input to the d output using g
17:11:44 <Cale> CpnStumpy2: No problem, good to hear it :)
17:11:53 <wedify> so is this the best way to write this expression: join (++) . first (++ "1") . second (++ "2") . break (== ":") $ "a:b"?
17:12:33 <wedify> ie, there's not something i would use instead of join
17:12:49 <Cale> first (++ "1") . second (++ "2") is the same as (++ "1") *** (++ "2")
17:12:59 <Cale> However, I wouldn't write an expression like that at all
17:13:05 <Cale> Lambdas exist for a reason
17:13:15 <arkeet> @unpl join (++) . first (++ "1") . second (++ "2") . break (== ":")
17:13:15 <lambdabot> (\ f -> ((++) >>= \ g -> g) (first (\ a -> a ++ "1") (second (\ b -> b ++ "2") (break (\ c -> c == ":") f))))
17:13:20 <arkeet> ow
17:13:20 <Cale> heh
17:13:20 <wedify> yeah i'm just trying to understand arrows
17:14:04 <arkeet> :t break
17:14:05 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
17:14:26 <arkeet> hm that doesn't even typecheck does it?
17:14:38 <wedify> i'm just suprised there isn't something already defined that is equivalent to my definition of join
17:15:05 <arkeet> oh you're talking about a different join
17:15:11 <arkeet> that's uncurry in Prelude
17:15:48 <arkeet> and that's not really an arrowy thing.
17:16:28 <wedify> ah good ol uncurry. i always forget about it
17:16:35 <wedify> ok that works thanks 
17:18:04 <CpnStumpy2> So back to my earlier question: Is a monoid with a second binary operation where the identity is absorptive rather than neutral  make a "Field" ? Or is that just a "SemiRing" ? (And are there standard Haskell libraries for either?)
17:23:52 * hackagebot yesod-auth 1.4.6.1 - Authentication for Yesod.  https://hackage.haskell.org/package/yesod-auth-1.4.6.1 (GregWeber)
17:25:15 <ricochet1k> So I have namemap m = m & fmap (^? key "name")  with type Map Integer Value -> Map Integer (Maybe Value). I'm trying to find something (maybe lens/traversal related?) That will just give me back a Map Integer Value ignoring any missing values. Any tips?
17:27:23 <arkeet> ricochet1k: mapMaybe? https://hackage.haskell.org/package/witherable-0.1.3/docs/Data-Witherable.html
17:28:30 <ricochet1k> That almost works. That returns a list though.
17:28:35 <arkeet> no.
17:28:40 <ricochet1k> Wait
17:28:46 <arkeet> not the mapMaybe from base
17:28:46 <ricochet1k> I've not seen that package before.
17:29:39 <ricochet1k> That looks cool, thanks.
18:01:50 <gads> o/
18:23:55 * hackagebot pure-zlib 0.4 - A Haskell-only implementation of zlib / DEFLATE  https://hackage.haskell.org/package/pure-zlib-0.4 (AdamWick)
18:27:12 <ttt_fff> is there any monad (something like Traversable?) that models well the notion of "doing substitutions on expressions with lambda" ?
18:29:44 <ricochet1k> Are you talking rewrite expressions?
18:29:50 <ttt_fff> yeah
18:30:05 <ttt_fff> so substitution/rewriting in expressions is non-trivial to avoid capture
18:30:32 <ttt_fff> things like "replace x with z" in (fn (z) (+ x z))
18:30:37 <ricochet1k> Idk about a Monad, but rewrite or transform in https://hackage.haskell.org/package/lens-4.12.3/docs/Control-Lens-Plated.html
18:31:08 <ricochet1k> I've never used them myself, but they look neat.
18:45:37 <XexonixXexillion> Can I tell stack where to find bash? I tried running "stack upgrade", and at some point during the operation tries to run /bin/bash, which doesn't exist on my machine. Is this fixable, or do I need to symlink /bin/bash to where my bash actually is?
18:47:43 <ttt_fff> anyone here switched to idris, found it unsatisfying / not production ready, and then swittched back to haskell ?
18:58:56 * hackagebot pipes-text 0.0.0.17 - Text pipes.  https://hackage.haskell.org/package/pipes-text-0.0.0.17 (MichaelThompson)
19:08:57 * hackagebot pipes-text 0.0.1.0 - Text pipes.  https://hackage.haskell.org/package/pipes-text-0.0.1.0 (MichaelThompson)
19:14:13 <octopuscabbage> how is haskell for machine learning? i know it has inline r but does it have any good libraries for it?
19:26:27 <sm> is there anything apl/j/k-like for haskell ?
19:27:59 <FireFly> In what sense?
19:29:57 <FireFly> I think Repa is pretty APL-y
19:41:34 <sm> eg an embedded DSL influenced by those languages, exploring how concise you can make haskell
19:51:30 <wedify> what if instead of a single io value we allowed multiple ones. If they are not explictly sequenced together they are seen as concurrent threads that are safe to run indepently
19:54:14 <octopuscabbage> wedify, i mean you could probably build that monad
19:54:26 <octopuscabbage> wedify, just make it an instance of monadIO
19:54:48 <octopuscabbage> wedify, you'd probably want to make the applicative instance do that and the monad instance single threaded
19:54:58 <dramforever> octopuscabbage: NOOOOO
19:55:10 <octopuscabbage> I am told you don't want to do that
19:55:11 <dramforever> ap = <*> is required isn't it
19:55:37 * dramforever goes away and gets out of http://xkcd.com/386 mode
19:55:53 <octopuscabbage> but haxl does it
19:56:19 <geekosaur> be interesting to see if haxl breaks when ApplicativeDo hits
19:56:22 <dramforever> if ap = <*> is satisfied then I'm fine with it
19:57:18 <exio4> geekosaur: IIRC haxl was reason ApplicativeDo happened?
19:57:44 <octopuscabbage> exio4, you would be correct
19:59:59 <geekosaur> hm, maybe ApplicativeDo doesn't require that correspondence then (it doesn't explicitly, I think, but there may be RULES or etc. that would become confused in that case?)
20:00:23 <exio4> it needs to be semantically the same, not performance-wise
20:00:31 <geekosaur> in any case I suspect that if ap doesn't match <*> then unpleasant surprises lie in store
20:00:35 <geekosaur> (and yes, I mean semantics)
20:01:15 <geekosaur> and they will become more likely as ghc is enhanced to make use of Applicative as "superclass" of Monad
20:05:02 <octopuscabbage> correct me if i'm wrong but it's possible for ap to equal <*> in semantics while still having one threaded and one not threaded
20:10:13 <geekosaur> only if you can guarantee that they don't interact, I think, which would be difficult for an arbitrary computation with e.g. a Chan reachable
20:11:02 <exio4> the idea is that you have a type where there's only benefit from doing that :p 
20:13:29 <octopuscabbage> I see, perhaps you could design a subset of the IO monad where you know these operations won't interfere with each other
20:13:52 <octopuscabbage> Could you do it in the STM monad?
21:05:14 <julianleviston> Super noob question here. 
21:05:32 <julianleviston> Using snap, :t writeText "hey" gives writeText :: MonadSnap m => Text -> m ()
21:05:55 <julianleviston> :t writeText "hey" errors with couldn’t match type ‘Text’ with actual type ‘[Char]'
21:05:56 <lambdabot> lexical error at character '\8217'
21:06:20 <ricochet1k> You need to use OverloadedStrings
21:06:37 <julianleviston> that’s the weird thing. I’ve got them enabled… 
21:06:46 <julianleviston> however, maybe not in GHCI. 
21:06:55 <ricochet1k> :set -XOverloadedStrings
21:06:57 <julianleviston> I have it in my file, and I’m just loading my file into GHCI.
21:07:00 <julianleviston> ahhhh
21:07:14 <julianleviston> so even though I have it in the file I’m loading?
21:07:18 <julianleviston> that kind of sucks.
21:07:19 <ricochet1k> Yep
21:07:21 <julianleviston> oh well :)
21:07:23 <julianleviston> thanks
21:07:28 <ricochet1k> In the file it only applies to the file.
21:07:37 <julianleviston> makes sense.
21:07:48 <ricochet1k> Yeah, I don't like it either, but solutions are difficult.
21:08:00 <julianleviston> can I ask what the x is?
21:08:29 <ricochet1k> It's a GHC parameter, I think it just turns the language flags on.
21:08:40 <julianleviston> ok. :)
21:08:51 <julianleviston> I’ll remember it as eXtension
21:08:56 <julianleviston> thansk
21:10:47 <julianleviston> would you read x => m as “constrains m such that it is of typeclass x”?
21:11:35 <ricochet1k> Um, are you talking like :: Monad m -> m ()  ?
21:11:44 <ricochet1k> Sorry, :: Monad m => m()
21:11:46 <julianleviston> yep
21:11:52 <julianleviston> erm.
21:12:09 <julianleviston> Monad m => m () exacttly.
21:12:11 <ricochet1k> Yes.
21:12:15 <julianleviston> sweet.
21:12:36 <ricochet1k> That's something like "m is a Monad in this type"
21:12:55 <julianleviston> what does “in” mean, there?
21:13:03 <julianleviston> Oh… 
21:13:11 <julianleviston> does it mean that the type includes the Monad
21:13:16 <ricochet1k> Well
21:13:25 <julianleviston> sorry, includes being a monad, so to speak
21:13:29 <ricochet1k> I meant in as referring to the type of the function that follows =>
21:13:46 <julianleviston> aha.
21:14:07 <julianleviston> “in the type whose type signature is currently beign defined, m represents a Monad” ?
21:14:14 <ricochet1k> Yes.
21:14:44 <julianleviston> and x m => m () means “m is constrained such that it is of the typeclass x in this type”
21:14:49 <julianleviston> is that correct?
21:14:52 <ricochet1k> Yep.
21:14:58 <julianleviston> awesome. :)
21:15:11 <julianleviston> just checking I’ve understood correctly.
21:15:24 <ricochet1k> I'm pretty new to haskell too :P
21:15:27 <julianleviston> :)
21:15:43 <ricochet1k> I think this is the 4th time I've come to it trying to understand it.
21:15:54 <julianleviston> Haskell?
21:15:56 <ricochet1k> Yep.
21:16:04 <julianleviston> Ah ok.
21:16:08 <ricochet1k> And this time, I think I'm finally understanding Monads :P
21:16:36 <julianleviston> I don’t think Monads are hard to understand… it’s how everything fits together that makes things hard to understand.
21:18:36 <julianleviston> Link… for example, I find the way typeclasses are expressed and the semantics they represent quite tricky to understand, but that’s mostly because the explanations we have are either laden with a huge amount of mathematical nomenclature that I didn’t understand, or the explanations are too abstract.
21:18:41 <julianleviston> like*
21:19:05 <ricochet1k> Heh, yeah, I'll agree with that.
21:20:21 <ricochet1k> I find there is also a major lack of beginner information for Haskell and also a lot of missing examples for use of various libraries. I've read a lot of the wiki book and related, but sometimes I just want examples of how to use all the functions in a library.
21:20:29 <dramforever> monads are just monoids on the category of endofunctors of a category C, aren't they
21:20:31 <julianleviston> A Monad is a typeclass. That alone is hard enough to explain. What is a typeclass? It’s an agreement the compiler has with the typechecker that types tagged with that typeclass must have some functions created for it.
21:21:02 <julianleviston> ricochet1k: yep.
21:21:19 <dramforever> I was only half joking. This definition seriously helps when understands, for example, free monads, because if you know what a free monoid is, you know what a free monad is
21:21:26 <dramforever> *understanding
21:21:49 <ricochet1k> Yeah, it helps, but only when I know what Monoids are...
21:21:52 <julianleviston> dramforever: That’s precisely illustrative of the point I was making. Things are simple as long as you understand the requisite information.
21:22:02 <ricochet1k> I still plan on reading through Typeclassopedia sometime.
21:22:20 <julianleviston> dramforever: it only helps if you know what monoids, categories, endofunctors and the category C is.
21:22:23 <dramforever> julianleviston: yeah I was confirming you
21:22:33 <julianleviston> ricochet1k: you haven’t? It’s got some amazing stuff in it.
21:22:53 <ricochet1k> I have looked at it, but I want to have a good sit-down reading session sometime when I've got a few hours free :P
21:22:53 <julianleviston> dramforever: ah sorry :) I don’t see it as a joke, because it’s not. It’s true. That’s what they are… :)
21:23:21 <dramforever> julianleviston: joke because (figuratively) no one understands it
21:23:29 <julianleviston> dramforever: oh ok.
21:23:48 <julianleviston> dramforever: eveyone of the audience it’s intended for understands it ;-)
21:24:18 <ricochet1k> I've watched Edward Kmett's lens video like 4 times now. I can tell they are awesome, but only this last time did I start understanding why certain decisions were made.
21:24:41 <julianleviston> dramforever: and I really have no problem with that at all… but until we all start building bridges between where we are and good ways to get here, it will remain hard.
21:25:01 <julianleviston> dramforever: and honestly, maybe it being hard is a very very good thing.
21:25:25 <julianleviston> dramforever: smalltalk and OOP is a sobering illustrative example of what happend when the masses “understand” a thing.
21:25:42 <dramforever> julianleviston: I don't know about you, but I never knew why a free monad was made that way until I started thinking them as free monoids
21:26:00 <julianleviston> dramforever: this second, I have no idea what a free monad is.
21:26:06 <julianleviston> dramforever: hang on I’ll look.
21:26:12 <dramforever> oh forget about it...
21:27:03 <julianleviston> dramforever: nah, it’s cool. I just looked it up. God it.
21:27:07 <julianleviston> got it*
21:27:18 <julianleviston> “one that does no work during the normalization step beyond simply grafting the two monadic values together”
21:27:22 <julianleviston> that’s perfectly understandable
21:27:33 <dramforever> I hope you know what I mean by thinking them as free monoids
21:27:54 <julianleviston> dramforever: I just have to look up monoids. again.
21:28:05 <dramforever> stop it stop it
21:28:07 <julianleviston> ok closed under a binary operation
21:28:10 <julianleviston> no I’m serious
21:28:13 <julianleviston> I didn’t remembr
21:28:15 <julianleviston> that’s all
21:28:18 <julianleviston> I do understand.
21:28:38 * dramforever leaves to do "real" work
21:28:42 <julianleviston> a good example is + and natural numbers
21:28:45 <julianleviston> oh sorry :(
21:28:48 <ricochet1k> lol
21:29:28 <julianleviston> we have a lot of names in math (and therefore Haskell)
21:29:29 <ricochet1k> I think I get what he's saying about free monads and free monoids, but in only a cloudy sort of way...
21:29:36 <julianleviston> anyway I’ll get back to my thing.
21:30:33 <julianleviston> I need to study more before I really understand these things.
21:30:36 <julianleviston> so much to learn.
21:30:42 <ricochet1k> Yes.
21:34:00 <ricochet1k> You know, sometimes it bothers me that laws associated to a type cannot be expressed or verified by Haskell.
21:35:52 <nshepperd> well, a library could provide quickcheck properties?
21:36:59 <ricochet1k> It can manually be verified, that's fine. I just think in a language with such strong typing, I'd like a little more assurance that values with a certain type will actually behave like they should.
21:37:06 <edwardk> ricochet1k: the old new york one or the new cufp video?
21:37:24 <ricochet1k> New york. Is there a new one?
21:37:48 <edwardk> https://www.youtube.com/watch?v=T88TDS7L5DY
21:37:54 <edwardk> ^- that should be pretty accessible
21:38:14 <ricochet1k> Ooh. I've never seen this one. Where should I have found it?
21:38:30 <ricochet1k> lens.github.io still points to the old one
21:38:33 <edwardk> It was at CUFP, which just ended a week ago
21:38:38 <ricochet1k> Ah :)
21:38:58 <edwardk> I haven't been able to get jekyll to rebuild the site for lens.github.io, so it points to ancient news ;)
21:39:15 <edwardk> If someone wants to figure out how to fix that thing, it'd be a lot easier to put up new lens news
21:39:17 <julianleviston> edwardk: what happened to your voice, man? You sound so different!
21:39:27 <edwardk> julianleviston: i was talking for a week solid before my talk
21:39:40 <julianleviston> edwardk: ah… :)
21:39:54 <edwardk> julianleviston: i almost lost my voice a couple of days prior
21:40:28 <julianleviston> edwardk: I think lenses are incredibly easy to work with… the semantics of things and understanding them is pretty different than being able to work with something
21:40:55 <edwardk> basically my voice tends to drop most of an octave every 3 days at a conference. ;)
21:41:36 <ricochet1k> One simple thing I have been wondering: is there a concept of a lens that enforces certain structures by throwing errors rather than ignoring them if they don't match? Like, a missing key or wrong type?
21:42:07 <edwardk> ricochet1k: you can use 'failover' to complain if the traversal doesn't match anything
21:42:35 <edwardk> i, somewhat self-deprecatingly fail to do so successfully in response to a question during that talk even
21:43:10 <edwardk> :t failover
21:43:11 <lambdabot> (Alternative m, Profunctor p) => Over p ((,) Any) s t a b -> p a b -> s -> m t
21:43:20 <edwardk> pick m = Maybe
21:43:31 <edwardk> p = (->)
21:45:54 <ricochet1k> Hmm. Well, using ^? returns Maybes anyway. This doesn't appear to change much.
21:47:34 <ricochet1k> I just want to know why it returned a Maybe. Debugging why a bunch of lenses/traversals gave me Nothing is a pain.
21:49:49 <edwardk> ^? matches. 'failover' transforms the thing using a function and tells you in passing if it succeeded
21:50:25 <edwardk> sadly i don't have a way i can give you error messages in, say, an either, in a way that is compatible with any of the existing lens machinery
21:50:46 <edwardk> i played around with 'coindexed traversals' and 'coindexed prisms' for this sort of thing
21:50:57 <edwardk> which are in theory the path to make it go
21:51:21 <edwardk> but they are incompatible with indexed things and due to certain asymmetries in the way functions work they are less powerful
21:52:53 <ricochet1k> Hmm. Yeah, an Either would be great if it could have been made to work.
21:53:46 <edwardk> the short version it can't. the long version is it can almost be done ;)
21:54:06 <edwardk> but not in a way that i can package up for consumption
21:55:06 <ricochet1k> one day, "coindexed traversals" and "Costate Comonad Coalgebra" will make complete sense to me
21:56:12 <edwardk> Costate is 'Store'    data Store s a = Store (s -> a) s -- if you squint at it that looks a bit like State s a = s -> (s, a)   except the pair is on the outside of the function rather than inside
21:56:44 <edwardk> comonad = you have the dual of return and join,         extract :: w a -> a, duplicate :: w a -> w (w a)
21:57:11 <edwardk> extract (Store f s) = f s; duplicate (Store f s) = Store (Store f) s -- with the right laws to match up with the monad side
21:58:23 <edwardk> comonad-coalgebras are a bit more complex, but not much, they have a connection to the laws for a comonad
21:58:39 <edwardk> extract . duplicate = id     is one of the comonad laws analogous to a monad law
21:59:01 <shachaf> I don't think the whole "costate comonad coalgebra" thing helps with understanding lenses very much.
21:59:37 <edwardk> an f-coalgebra is just (f :: a -> f a) with a couple of laws: extract . f = id; duplicate . f = fmap f . f
21:59:58 <edwardk> but we normally have extract . duplicate = id; and duplicate . duplicate = fmap duplicate . duplicate
22:00:00 <shachaf> It's a bunch of concepts -- some of them poorly named, for the sake of alliteration -- that happen to mean "lens" when you put them together, quite possibly by accident.
22:00:16 <edwardk> so 'duplicate' is an f-coalgebra
22:00:21 <edwardk> but we can have others
22:00:46 <shachaf> Maybe I'm not helping.
22:01:06 <ricochet1k> shachaf: maybe understanding it wouldn't help me understand lenses, but understanding that would be a good indicator of me understanding category theory
22:01:18 <edwardk> anyways, that is a rats nest of definitions, but the 'costate comonad coalgebra' thing is sort of a coincidence
22:01:40 <edwardk> it just happens to turn out that the comonad coalgebra laws for costate match up perfectly with the 'common sense' getter and setter laws
22:02:09 <edwardk> in one sense it is a coincidence, in another sense it is inevitable, but it depends on what you are focusing on =)
22:02:09 <shachaf> OK, perhaps an indicator, but not so much a goal.
22:02:23 <shachaf> Goodhart's law. :-)
22:02:52 <shachaf> Anyway "costate" is a bad name.
22:03:01 <edwardk> anyways, if you fuse a 'getter: s -> a' and a 'setter : s -> a -> s'  together by noticing they both start with (s ->)  you get s -> (a, a -> s)  which is s -> Store a s
22:03:32 <edwardk> and then the 'nice' laws we like for lenses are just the comonad coalgebra laws i mentioned above.
22:03:51 <shachaf> Can you make this definition work with type-changing lenses?
22:03:57 <ricochet1k> nope
22:04:00 <edwardk> sadly it deadends
22:04:03 <shachaf> Then I would be more inclined to buy it.
22:04:04 <ricochet1k> That much I know from the first talk :)
22:04:19 <edwardk> it also dead-ends when you go to build prisms
22:04:25 <edwardk> or work with lenses in other categories
22:04:33 <shachaf> Maybe in some functor category, with natural transformations?
22:04:35 <edwardk> so i think of it as a happy coincidence
22:04:56 <edwardk> you can build it in a cartesian closed category when you are using the product structure
22:05:00 <shachaf> Since that's what type-changing lenses are.
22:05:04 <edwardk> but you can build lenses in any monoidal category
22:05:07 <shachaf> Natural lenses.
22:05:13 <edwardk> and in the monoidal setting they can type-change
22:05:45 <edwardk> it just happens that (,) and (->) have a nice relationship in a closed monoidal category
22:06:02 <roconnor> http://r6research.livejournal.com/27071.html?thread=16575#t16575
22:06:14 <roconnor> Well, if you find a functor (\A) adjoint to (A+), then you get (a prism = an algebra over a monad).
22:06:37 <edwardk> roconnor: btw- you may be amused to find that we're playing with 'Wander' as the encoding of traversals in purescript
22:06:56 <edwardk> roconnor: due primarily to limitations in the purescript type system forcing it closer to haskell 98
22:07:06 <edwardk> but since they have rank-2 types you can get away with a middle ground
22:07:14 <shachaf> I haven't seen a response to my argument that Wander isn't right yet.
22:07:34 <roconnor> Wander?
22:07:44 <edwardk> class Strong p => Wander p where wander :: (forall f. Applicative f => (a -> f b) -> s -> f t) -> p a b -> p s t
22:08:13 <shachaf> Wait, that's not the class I was thinking of.
22:08:15 <edwardk> roconnor: IIRC you named the damn thing. class ... => Wander p where wander :: Traversable t => p a b -> p (t a) (t b)
22:08:40 <shachaf> Yes, that one.
22:08:44 <edwardk> switched to the rank-2 form above it works in purescript nicely
22:08:49 <roconnor> I called it walk.
22:09:01 <shachaf> Using wander twice if distinguishable from using it once.
22:09:05 <shachaf> is
22:09:07 <roconnor> wander seems nicer though. I might steal that.
22:09:34 <shachaf> Typing on a phone isn't optimal for this sort of discussion.
22:09:43 <edwardk> anyways the rank-2 version can get away with about half the work in most situations
22:10:12 <edwardk> and carefully avoids caring about which 'f' we're wandering with
22:10:42 <edwardk> like we get to with strong and choice in many ways. they are analogous to being (co)representable but without knowing the (co)representation
22:10:51 <edwardk> except they can be a little bit more powerful
22:10:57 <shachaf> I think that argument was someone else's (xplat's) originally.
22:11:18 <shachaf> But I haven't seen a response.
22:11:31 <edwardk> don't remember
22:12:02 <roconnor> shachaf: I'm fairly confident that my Walk class is correct (assuming law abiding inputs).
22:12:11 <roconnor> No claims about efficency.
22:12:29 <shachaf> What does correct mean here?
22:12:38 <edwardk> roconnor: its 'correct', the concern is more that it requires a lot more copying than we'd want
22:12:42 <shachaf> I think I can construct a counterexample.
22:13:09 <edwardk> shachaf: i'd be curious to see it
22:13:20 <octopuscabbage> is there a way to install more than one base when using stack?
22:13:45 <edwardk> octopuscabbage: base is tied to the compiler version, IIRC stack can use multiple ghc versions though
22:13:49 <shachaf> edwardk: Can you write an isomorphism to the usual Traversal?
22:14:21 <octopuscabbage> edwardk, how would i go about using a different ghc?
22:14:33 <shachaf> Or maybe you already have one?
22:15:13 <kadoban> octopuscabbage: The GHC version is tied to what resolver you're using. Set a different resolver for the project or whatever.
22:15:24 <edwardk> octopuscabbage: i'm only going based on comments made during the presentation of stack at HIW a couple weeks back: https://www.youtube.com/watch?v=RRmb2RtU0hU&list=PLnqUlCo055hVfNkQHP7z43r10yNo-mc7B&index=7
22:15:46 <kadoban> octopuscabbage: Like lts-3 uses GHC 7.10   lts-2 uses GHC 7.8
22:15:58 <edwardk> shachaf: in one direction its easy, the other uses bazaar, no?
22:16:10 <roconnor> shachaf: I wrote one direction of the isomorphism.  The hard one (twice).
22:16:28 <shachaf> I'm not at a computer right now, but if you hpaste it I'll look at it later.
22:16:41 <shachaf> And maybe I'll be convinced. :-)
22:17:06 <roconnor> shachaf: here is the "efficent" version: http://r6research.livejournal.com/27476.html?thread=19540#t19540
22:17:34 <edwardk> so who wants to talk about the details of a hypothetical runtime system for a hypothetical haskell compiler? ;)
22:17:45 <octopuscabbage> cool. any idea how i can find which ghc uses a base between 4.5 and 4.8?
22:18:17 <edwardk> the PKStore bit there is the Bazaar thing i mentioned above
22:18:35 <c_wraith> edwardk: does it have to be a specific hypothetical haskell compiler, or can it be my own particular hypothetical haskell compiler?
22:18:44 <kadoban> octopuscabbage: I don't know how well stack is going to support GHCs that old. I don't think it's going to know how to install it automatically like it does with newer ones, but maybe I'm wrong.
22:19:08 <edwardk> c_wraith: i'm open to suggestions, but i'm actually in the process of hacking on the one i'm looking to talk about =)
22:19:11 <roconnor> I'm going to need to rename PKStore the FreeApplicativePStore.
22:19:20 <edwardk> trying to make it a little less hypothetical
22:19:21 <shachaf> edwardk: The same thing you were talking about yesterday?
22:19:36 <edwardk> roconnor: there is a nice free monad involved even
22:20:26 <roconnor> my paper finally got published this week in the JFP.
22:20:33 <octopuscabbage> roconnor, congrats!
22:20:39 <roconnor> ty!
22:21:14 <edwardk> http://comonad.com/reader/2015/categories-of-structures-in-haskell/ talks about how Dan and xplat and I think of it as 'Free Applicative'
22:21:52 <edwardk> but the fact that 'Free Applicative' is a monad comes up in the construction
22:22:37 <edwardk> and has a nice connection to yoneda/coyoneda as '(co)free functor'
22:23:13 <roconnor> you don't have to think of it as a free applicative of pstore.  it is the free applicative of the pstore functor.
22:23:23 <edwardk> shachaf: pretty much
22:25:16 <edwardk> newtype Free σ f a = Free { gratis :: forall g. σ g => (f ~> g) -> g a }, then you can just look at Free Functor and Free Applicative as forming a monad in their own right
22:25:30 <shachaf> I'm interested in these conversations if they're happening, but at a time when I'm more awake. :-)
22:25:47 <edwardk> shachaf: re the compiler thingy. made #thc
22:26:23 <roconnor> Hmm interesting PCont i j x = Identical f => (i -> f j) -> f x ...
22:26:29 <roconnor> I never noticed that before.
23:09:08 * hackagebot refined 0.1.1.0 - Refinement types with static and runtime checking  https://hackage.haskell.org/package/refined-0.1.1.0 (NikitaVolkov)
23:44:30 <kalkin-> i'm using HXT do unpicle some Xml. One Element has 27 attributes which i need to serialize to a record with 27 fields. there is a lot of boilerplate. I asked yesterday how to avoid it and was told to have a look at GHC.Generics. Well I'm looking at it but don't seeing anything 
23:45:05 <scshunt> what sort of boilerplate are you trying to avoid, exactly?
23:45:05 <kalkin-> as far as i know it should magically help me, but i don't get it how
23:45:53 <kalkin-> scshunt: https://github.com/UweSchmidt/hxt/blob/master/hxt/examples/arrows/AGentleIntroductionToHXT/PicklerExample/Baseball.hs#L104 this kind only bigger
23:46:58 <kalkin-> This artike also speaks about using GHC.Generics with XML parsing https://ocharles.org.uk/blog/posts/2014-12-16-derive-generic.html but there is no working code
23:49:52 <scshunt> kalkin-: you may find https://wiki.haskell.org/GHC.Generics
23:49:54 <scshunt> more helpfu
23:50:41 <kalkin-> scshunt: thanks will try that
23:56:03 <kalkin-> scshunt: just noticed it the same wiki artikel as i read yesterday. i just always started with 1.2
23:57:28 <kalkin-> so basically i'm not really smarter than before. i have no idea what the hell is happening, which LANGUAGE pragmas i need, what have i to do or how to apply it to xml parsing
23:58:46 <kalkin-> especially the whole Serialize class looks like more boilerplate not less
23:58:53 * kalkin- is confused
