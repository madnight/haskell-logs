00:02:49 <liste> TIL about ?loc :: CallStack
00:02:55 <liste> may come handy when debugging
00:04:34 <Shockk> > mconcat [[5,2], [3,4,65]]
00:04:35 <lambdabot>  [5,2,3,4,65]
00:07:39 * hackagebot clckwrks-plugin-page 0.4.1 - support for CMS/Blogging in clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-page-0.4.1 (JeremyShaw)
00:07:39 * hackagebot clckwrks-plugin-media 0.6.14 - media plugin for clckwrks  https://hackage.haskell.org/package/clckwrks-plugin-media-0.6.14 (JeremyShaw)
00:15:41 <Shockk> in case anyone cares 
00:16:46 <Shockk> I separated out the storage type for sides of my PolyMap type, so whereas before it was storing as [a], it now stores as Storage s a => s a
00:16:58 <Shockk> https://github.com/shockkolate/hs-polymap/blob/master/src/Data/PolyMap/Storage.hs
00:18:30 <Shockk> now should be able to easily write a Storage instance for Data.Set 
00:47:51 <felixn> > runStateT (do { x <- lift [1,2]; modify (+ 1); return (x * 2) }) 0
00:47:53 <lambdabot>  [(2,1),(4,1)]
00:48:30 <felixn> what I want is ([2,4],2)... I looked this up before, I don't remember if I figured it out, or just let it go >_<
00:50:44 <opqdonut> felixn: it looks to me like StateT [] isn't the right monad then?
00:51:36 <opqdonut> > runState (mapM (\x -> do modify (+1); return (x*2)) [1,2]) 0
00:51:38 <lambdabot>  ([2,4],2)
00:52:21 <felixn> pretty sure I have to flip it, but "ListT done right" is a confusing article
00:53:05 <felixn> opqdonut: that's actually an isolated use case, using the list monad to run through permutations, but now I have to keep track of state xD
01:00:11 <jdnavarro> is it possible to enforce non-empty `Text` with the type system?
01:00:34 <jdnavarro> I know about https://hackage.haskell.org/package/semigroups-0.17.0.1/docs/Data-List-NonEmpty.html
01:00:58 <jdnavarro> but maybe there is already something for `Text` or `ByteString`
01:01:45 <kriztw> jdnavarro: maybe use a newtype and smart constructors?
01:02:30 <jdnavarro> kriztw: yeah, I can got with that for now
01:03:10 <kriztw> I would be surprised if there is a built-in type for that, it seems pretty specific
01:03:20 <Cale> jdnavarro: You could store the first Char separately, which would be analogous to what the nonempty list type does.
01:04:08 <Fuuzetsu> sounds like it'd be a lot more pain to work with whereas with just newtype you automatically get all the Text functions without extra work
01:04:13 <Cale> right
01:04:48 <Cale> I don't think I could actually *recommend* going down that road, but it's... possible :)
01:06:05 <jdnavarro> I'll start with the newtype and smart constructors, that may be enough
01:06:48 <jdnavarro> but it's good to know you can go all the way in :)
01:07:25 <Cale> There'd be lots of hassle storing the first character separately, because of things like what happens when you upper/lowercase Text, the number of characters can change.
01:08:32 <jdnavarro> Cale, do you think a package dealing with the first `Char` would be useful?
01:08:57 <Cale> I usually don't try to enforce that kind of thing with Haskell types.
01:09:30 <felixn> > runState (runListT $ do { x <- ListT $ return [1,2,3]; lift $ modify (+ 1); return (x * 2); }) 0
01:09:32 <lambdabot>  Not in scope: ‘runListT’Not in scope: data constructor ‘ListT’
01:10:02 <jdnavarro> in my case I'm trying to enforce it because I'm violating lens laws
01:10:03 <felixn> bwahaha I did it, I couldn't find any simple examples on google, nor github code search, but I did find that gem in ircbrowse :D
01:10:16 <jdnavarro> concretely Prism laws
01:19:25 <jle`> everybody breaks prism laws anyway
01:20:05 <jle`> it's what people do when they want the rush/thrill but can't handle real consequences
01:22:19 <jle`> > over hex id "00abc"
01:22:20 <lambdabot>  "abc"
01:23:43 <kriztw> jle`: why does that happen?
01:24:44 <jle`> kriztw: hex lets you manipulate the number that the hex string represents...so it works by converting the string to the number, performing the operation, and converting it back to hex
01:24:54 <jle`> > over hex (*2) "849"
01:24:56 <lambdabot>  "1092"
01:25:08 <jle`> in this process you're going to lose any leading 0's
01:25:13 <kriztw> ah, that makes sense
01:26:51 <kriztw> yeah, that makes it hard to satisfy the law in a meaningful way
01:26:58 <jdnavarro> jle`: what are the potential pitfalls when breaking them?
01:29:50 <quicksilver> unexpected results when combining a pipeline of operators
01:30:05 <quicksilver> if there are two values which 'should' be the same according to the laws
01:30:11 <quicksilver> you might get either one or the other
01:30:19 <quicksilver> depending how your expression happens to inline
01:30:25 <quicksilver> I think ?
01:31:56 <jdnavarro> I'm trying to visualize when it'd be safe to combine improper Prisms and when not
01:33:51 <jdnavarro> but I guess there is no easy way
01:35:59 <micmus> Hey, I'm learning haskell and in the effect I wrote a blog post "Simple monadic parser in Haskell" http://michal.muskala.eu/2015/09/23/simple-monadic-parser-in-haskell.html I'd love your feedback. Criticism welcome, but don't be too harsh - I'm only learning
01:36:28 <Gurkenglas> xkc
01:37:21 <quicksilver> jdnavarro: safe as long as you aren't interested in distinguish the elements it confuses, I guess?
01:42:21 <jdnavarro> quicksilver: that sounds right
01:42:59 <jdnavarro> I'm suspecting combining with traversals would be a problem too
01:44:09 <jdnavarro> anyway, I think it's not that much of a pain to have non empty text with smart constructors
01:48:15 <quicksilver> you can define a (proper) Prism from Text into your non-empty Text :)
01:48:38 <quicksilver> and if you use real texts via that prism you'll be safe
01:51:23 <hc> Hi all
01:52:14 <hc> I've got a question about channels.. Suppose I have a million haskell threads (forkIO) and they are all communicating with one process through a channel
01:52:38 * hackagebot RoyalMonad 1000.7 - All hail the Royal Monad!  https://hackage.haskell.org/package/RoyalMonad-1000.7 (AtzeVanDerPloeg)
01:52:45 <hc> Then, this one process can assign a new channel to two threads to "connect" them, so they can talk to each other independently, much like passing a PID around in erlang.
01:52:55 <hc> Is that a bad idea, is there a better way to do this?
01:53:43 <hc> Example scenario, a chat server with a million connections, and once two users chat with each other, a direct haskell channel is exchanged between the two threads so there is no third thread involved
01:54:09 <bartavelle> how would you reap the channel when the communication is over ?
01:54:19 <bartavelle> (ie. how do you know it's over)
01:54:40 <bartavelle> (also you would need 2 channels)
01:54:55 <hc> ah right, i'd need two channels
01:54:59 <bartavelle> (perhaps it would be easy if the mediator passes the threads it already uses to talk to the processes)
01:55:01 <hc> and i guess to reap them a special message is exchanged
01:55:10 <bartavelle> err
01:55:12 <bartavelle> passes the channels
01:55:39 <jdnavarro> quicksilver: that's right, that will work! thanks!
01:55:42 <hc> how much resources does one channel use?
01:55:52 <hc> is there any documentation on this? or on how they are implemented?
01:55:52 <bartavelle> no clue :)
01:56:13 <bartavelle> I think their implementation is documented in the marlow book
01:56:45 <hc> ah that sounds interesting, thanks
01:57:28 <quicksilver> negligible resources
01:57:40 <quicksilver> channels are very lightweight, don't worry about creating lots of them
02:18:05 <Gurkenglas> One might compare it with the ressources used in creating another IRC channel and moving part of the discussion there
02:21:18 <trumanshow1> Can anyone answer this tweet? "Sometimes "stack build" doesn't do anything even when I have source changes. What am I doing wrong here?" https://twitter.com/Blair_Archibald/status/644908053561765888
02:21:44 <trumanshow1> I have the same issue occasionally, i.e. I change a .hs file in src/ , and yet `stack install` doesn't recompile it.
02:22:40 * hackagebot RoyalMonad 1000.9 - All hail the Royal Monad!  https://hackage.haskell.org/package/RoyalMonad-1000.9 (AtzeVanDerPloeg)
02:24:31 <mgsloan> trumanshow1: Is the module listed in your cabal file?
02:25:23 <trumanshow1> Woops.
02:25:29 <trumanshow1> mgsloan: good catch :-)
02:26:05 <mgsloan> :D I think recent stack versions also warn about this when it's detected that unlisted modules are being compiled
02:30:03 <saulzar_> I've been caught with that one quite a few times with vanilla cabal ,where a package depending on that library mysteriously can't find a module
02:31:32 <ttt_fff> is there something like "error", but will let me perform IO before dying? i.e. instead of      error "blah"      I really want to do instead is      writeFile "error.log" [big data structure]; die     ... and still have the function be pure
02:31:56 <ttt_fff> so I know that "writefile" is IO .... but i'd like a way where I can do an IO, then die,     (instead of just printing error to stdout) .... and ahve the function still be pure
02:32:56 <quicksilver> not built in, no
02:33:06 <quicksilver> you'll have to unsafePerformIO it
02:33:09 <nobos> Hi, I have a probably silly question regarding casting from IO to an EitherT
02:33:34 <nobos> I have a function that returns an IO String
02:33:35 <liste> nobos liftIO (:
02:33:40 <liste> :t liftIO
02:33:41 <nobos> aha
02:33:41 <lambdabot> MonadIO m => IO a -> m a
02:33:58 <quicksilver> (w.r.t. ttt_fff's quesiton) doesn't seem like a very good idea to me - but no worse than using 'error' in the first place
02:34:09 <quicksilver> personaly I only use error for "things which can't happen"
02:44:35 <nobos> liste: either (left 1234) $ liftIO buildDatabase 
02:45:30 <nobos> liste: I'd like the left side to return an int and the right side a string, is that possible?
02:46:32 <nobos> list: my code is coming from servant, buildDatabase :: IO String
02:46:41 <nobos> liste: either (left err500) $ liftIO . buildDatabase
02:47:41 * hackagebot servant 0.4.4.3 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.4.4.3 (jkarni)
02:47:43 * hackagebot servant-client 0.4.4.3 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.4.4.3 (jkarni)
02:47:45 * hackagebot servant-docs 0.4.4.3 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.4.4.3 (jkarni)
02:47:47 * hackagebot servant-jquery 0.4.4.3 - Automatically derive (jquery) javascript functions to query servant webservices  https://hackage.haskell.org/package/servant-jquery-0.4.4.3 (jkarni)
02:47:49 * hackagebot servant-server 0.4.4.3 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.4.4.3 (jkarni)
02:49:04 <pavonia> nobos: What result type do you want, IO (Either Int String)?
02:50:05 <merijn> pavonia: He said EitherT, so presumably liftIO is enough for what he wants
02:51:51 <pavonia> But either (left err500) $ liftIO . buildDatabase won't still work then, no?
02:52:19 <JHall> \quit
02:52:51 * hackagebot servant-examples 0.4.4.3 - Example programs for servant  https://hackage.haskell.org/package/servant-examples-0.4.4.3 (jkarni)
02:52:53 * hackagebot servant-blaze 0.4.4.3 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.4.4.3 (jkarni)
02:52:55 * hackagebot servant-lucid 0.4.4.3 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.4.4.3 (jkarni)
02:52:57 * hackagebot servant-mock 0.4.4.3 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.4.4.3 (jkarni)
03:04:46 <dzhus> what is ARR_WORDS type that shows up in the profiling information after running a program with +RTS -hy?
03:08:45 <indiagreen> dzhus: http://stackoverflow.com/a/7241686/615030
03:09:11 <dzhus> indiagreen: oops, thanks :)
03:09:28 <liste> nobos what type you need?
03:12:42 * hackagebot tighttp 0.0.0.9 - Tiny and Incrementally-Growing HTTP library  https://hackage.haskell.org/package/tighttp-0.0.0.9 (YoshikuniJujo)
03:16:31 <pavonia> If you're prasing a very long bytestring with attoparsec via "many p" and the parser fails on the last byte, will it backtrack at worse up to the very frst byte?
03:24:57 <kriztw> jeg skal have fjernet visdomstænder senere i dag, så bliver der bad blood!
03:25:03 <kriztw> oops, wrong window :D
03:27:55 <Gurkenglas> ttt_fff, in your situation I would use Either (IO ())
03:30:39 <anaxk> I have installed ghc 7.10.2 on Windows. The ghci process dies very often. Perhaps haskell-mode is doing something because the process dies when I am not interacting with it.
03:57:44 * hackagebot tasty-lens 0.3.1 - Tasty TestTrees for Lens validation  https://hackage.haskell.org/package/tasty-lens-0.3.1 (jdnavarro)
04:07:45 * hackagebot wxAsteroids 1.1 - Try to avoid the asteroids with your space ship  https://hackage.haskell.org/package/wxAsteroids-1.1 (HenkJanVanTuyl)
04:18:48 <barrucadu> Fuuzetsu: Video is up now: https://youtu.be/jQCDa6WoFeY
04:24:08 <Fuuzetsu> cool
04:47:46 * hackagebot super-user-spark 0.2.0.0 - Configure your dotfile deployment with a DSL.  https://hackage.haskell.org/package/super-user-spark-0.2.0.0 (Norfair)
04:47:48 <merijn> Did 7.10 have PartialTypeSignatures yet?
04:51:37 <nomeata> merijn: you can run "ghc --supported-extensions" to find out
04:52:14 <nomeata> but the answer seems to be yes: https://downloads.haskell.org/~ghc/7.10.2/docs/html/users_guide/partial-type-signatures.html
04:52:46 <Walther> Hmm. http://lpaste.net/376189090170667008 any hints?
04:54:14 <cocreature> Walther: you probably want print ("Result" ++ fib n)
04:54:36 <dutchie> you probably also want "show (fib n)" as well
04:54:42 <cocreature> yeah was just about to mention that
05:02:51 <Walther> hmm, trying to tidy it up a bit, http://lpaste.net/376189090170667008
05:03:25 <Walther> and with "<-" instead of "=" i get another error
05:04:17 <kriztw> Walther: let result = ...
05:04:18 <cocreature> Walther: you need to use "let result = …"
05:04:21 <MarcelineVQ> you try using let instead? if you're not lifting a value out of something you don't need to bind (<-)
05:04:22 <ironChicken> Walther: you could say let result =
05:04:31 <MarcelineVQ> all at once eh..
05:04:32 <Walther> ah, right
05:04:46 <kriztw> the easy questions gets pounced on immediately :D
05:04:59 <Walther> hmm... wonder what would be the most "pretty" and "readable" way to write the whole thing
05:05:46 <quicksilver> well my rule of thumb is don't name something you only use once
05:06:05 <quicksilver> so I'd write putStrLn ("Result " ++ show (fib n))
05:06:11 <cocreature> as long as there is a good name for it, naming can only make it easier to read imho
05:06:12 <quicksilver> and skip the result variable entirely
05:06:21 <cocreature> although result is probably not exactly a useful name
05:06:34 <quicksilver> namign it doens't *only* make it easier to read
05:06:39 <quicksilver> it makes it easier and also longer
05:06:43 <kriztw> except when it gets more complicated, then it sometimes makes sense to split up whenever you can think of a name for a sub-expression
05:07:10 <quicksilver> kriztw: yes but I'm more likely to name a function than a value
05:07:13 <Walther> sure, i'm just trying to avoid having a huge oneliner that resembles your "stereotypical perl"
05:07:16 <quicksilver> if it gets long.
05:07:45 <MarcelineVQ> Walther: It only does one thing, I wouldn't worry too much about line-count :>
05:07:54 <quicksilver> because functions like that often turn out to be re-usable
05:08:15 <Walther> MarcelineVQ: Line count isn't the thing i'm aiming to reduce or increase, i'm just thinking of readability
05:08:15 <ironChicken> i have an impression that there's a not insignificant overlap between haskell and perl communities
05:08:43 <Walther> and i don't mean to bash perl, just referred to the stereotype
05:10:20 <MarcelineVQ> I'm trying to make a: instance Applicative ((->) t)
05:10:22 <Walther> namely, I have heard many people say that haskell is an unreadable language, and I kinda want to prove those friends that haskell can be very readable and pretty :)
05:10:35 <MarcelineVQ> And I don't have the slightest clue how to implement pure, can anyone point me in the right direction?
05:10:58 <MarcelineVQ> It's from nicta so​ I don't want the direct answer if possible, just a hint
05:11:09 <merijn> MarcelineVQ: Write out the type of pure for me
05:11:12 <merijn> Expanded
05:11:50 <MarcelineVQ> a -> f a where f is Applicative f
05:11:58 <MarcelineVQ> er Functor f
05:12:02 <merijn> MarcelineVQ: That's not expanded
05:12:10 <merijn> I meant expand ((->) t) in there
05:13:13 <MarcelineVQ> like a -> t -> a ?
05:13:29 <merijn> MarcelineVQ: Right, so now implement the function with that type :)
05:14:06 <MarcelineVQ> That's where I'm stuck ^^;
05:14:22 <cocreature> MarcelineVQ: so a -> t -> a is the same as a -> (t -> a)
05:14:30 <merijn> Hint, there's only 1 total and only 3 including non-total implementations possible in haskell
05:14:47 <merijn> MarcelineVQ: What are you stuck on?
05:20:51 <MarcelineVQ> merijn: I don't know how to satisfy a -> t -> a with just an a. I feel likie composition is the key but I can't figure out how to put it together
05:21:27 <cocreature> MarcelineVQ: so you're giving an 'a' and a 't' and you need to return an 'a', what can you do?
05:21:29 <merijn> MarcelineVQ: "pure a t = ?" what can you put there to match the type?
05:24:39 <aweinstock> merijn: how are there 2 non-total implementations for that? are (error "foo") and (let x = x in x) considered different?
05:25:36 <merijn> aweinstock: My bad, it's 3 non-total
05:26:06 <merijn> aweinstock: "undefined", "\_ -> undefined" and "\_ _ -> undefined"
05:26:16 <aweinstock> ah
05:26:59 <merijn> MarcelineVQ: Another question: How many ways do you have to create a's?
05:28:42 <aweinstock> MarcelineVQ: it's much simpler than you're (probably) thinking it is
05:28:47 <MarcelineVQ> just returning what you have, so something like pure a _ = a I guess
05:28:57 <aweinstock> exactly
05:28:59 <MarcelineVQ> I didn't realise I had a t on the left side of the =
05:29:06 <MarcelineVQ> I was taking pure's signature too literally I guess instead of treating it in a curried form like things actually are
05:29:39 <merijn> MarcelineVQ: Then you could still write "pure a = \t -> a" :)
05:29:58 <aweinstock> :t [\x y -> x, const, curry fst]
05:30:00 <lambdabot> [a -> b -> a]
05:30:48 <MarcelineVQ> Thank you all this is a very useful insight
05:31:32 <aweinstock> :t [\x y -> y, flip const, curry snd]
05:31:33 <lambdabot> [a1 -> a -> a]
05:32:16 <aweinstock> MarcelineVQ: point-free-ifying stuff is a way to get practice with currying/uncurrying
05:35:35 <MarcelineVQ> :>
05:36:41 <phaazon> hm
05:36:47 <phaazon> haste sounds pretty amazing
05:37:30 <merijn> hmmm
05:37:39 <merijn> Is there a "flip (>>)" operator?
05:38:57 <cocreature> :t (<*)
05:38:59 <lambdabot> Applicative f => f a -> f b -> f a
05:39:06 <merijn> No, that's wrong
05:39:15 <merijn> hmm, or is it...
05:39:24 <cocreature> well in 7.10 it should work, no?
05:39:29 <cocreature> ofc the constraint is different
05:39:37 <merijn> cocreature: No, I meant the effects should run in opposite order
05:39:51 <merijn> That just runs the effects on the "normal" order and returns the first result
05:40:01 <cocreature> ah gotcha
05:40:12 <KaneTW> :t (<<)
05:40:14 <lambdabot>     Not in scope: ‘<<’
05:40:14 <lambdabot>     Perhaps you meant one of these:
05:40:14 <lambdabot>       data constructor ‘Seq.:<’ (imported from Data.Sequence),
05:40:20 <KaneTW> worth a try :v
05:40:24 <cocreature> I don't think there is a flip (>>) then
05:42:58 <aweinstock> > let (<<) = flip (>>) in [First (Just 1) <* First (Just 2), First(Just 1) << First (Just 2)]
05:43:01 <lambdabot>  [First {getFirst = Just 1},First {getFirst = Just 1}]
05:43:59 <aweinstock> > let (<<) = flip (>>) in [Left 1 <* Left 2, Left 1 << Left 2]
05:44:01 <lambdabot>  [Left 1,Left 2]
05:44:21 <aweinstock> merijn: ^ there's the counterexample
05:45:32 <aweinstock> is there something like quickcheck, but more polymorphic? (in the sense that you give it an expression involving typeclass operators, and it tries it with different typeclasses in scope?)
05:47:08 <aweinstock> so you'd use it as (somethingCheck (\return -> return 1 <* return 2 == return 1 << return 2))
05:47:25 <aweinstock> and it'd find the above counterexample (or a different one)
05:49:23 <KaneTW> that sounds difficult to implement
05:50:14 <delYsid> levi: Thanks for your hint regarding s -> [(a,s)] being a parser.  I finally managed to use StateT for that, and even wrote my own combinator that mimicks sequence.  Thanks again!
05:51:57 <lamefun> How can I use C++ with Haskell?
05:52:32 <glguy_> Via C
05:52:41 <ImNotAKompjoetr> lamefun: https://wiki.haskell.org/Foreign_Function_Interface 
05:52:55 <lamefun> export "C"?
05:53:38 <ImNotAKompjoetr> lamefun: and more specific to cpp https://wiki.haskell.org/Cxx_foreign_function_interface
05:54:28 <glguy_> Yeah, Haskell can import/export C procedures and so can C++
05:55:55 <KaneTW> export "C" seems like the best choice tbh
05:56:24 <ChristianS> hm,  traceM "static string"  seems to be optimized away on repeated calls, so "static string" is printed only once even if the traceM is invoked several times. how very annoying!
05:56:47 <merijn> ChristianS: It's not optimised away, just only evaluated once
05:57:24 <lamefun> Is there a library to automatically compile C++ when building a Haskell package? I could only find "c-sources:" in Cabal docs, not "c++-sources:"
05:57:49 * hackagebot super-user-spark 0.2.0.1 - Configure your dotfile deployment with a DSL.  https://hackage.haskell.org/package/super-user-spark-0.2.0.1 (Norfair)
05:57:52 <merijn> lamefun: Just use the cabal hooks to call you C++ buildsystem?
05:57:55 <ChristianS> merijn: well isn't the purpose of tracing that you see what else is going on? i didn't expect it to become hidden like that.
05:58:51 <geekosaur> the usual purpose of tracing in Haskell is to know when something has been evaluated
05:58:55 <ChristianS> merijn: i'm mean, when i put  traceM "function called"  at the begin of the function, i expect "function called" to be printed whenever the function is called, not just the first time
05:59:15 <geekosaur> if you want to know when something is called, wrap the *call* in a trace
06:00:13 <ChristianS> geekosaur: i'll do that from now on, just expected that in a do block  traceM; x  is equivalent to  trace x .
06:01:55 <geekosaur> I will invite you to think about what is happening and why it has to behave that way. Hint: laziness
06:02:08 <geekosaur> also note "Note that the application of trace is not an action in the monad, as traceIO is in the IO monad."
06:04:21 <ChristianS> geekosaur: hmm, i guess i'll just avoid it from now on.
06:06:06 <geekosaur> if your monad is a MonadIO, you might consider traceMIO = liftIO . traceIO
06:10:35 <ChristianS> yes
06:19:17 <KrzyStar> Is there any significant performance advantage of using strict bytestrings over lazy ones?
06:19:34 <merijn> KrzyStar: Depends on what you're doing
06:20:03 <KrzyStar> Implementing a tcp server with binary protocol
06:20:13 <KrzyStar> Prolly gonna need all the values I extract from the data
06:20:51 <KrzyStar> It seems like I'm gonna need to use zlib a lot, and this library operates on lazy ones
06:21:44 <KrzyStar> So I guess actual converting back and forth will be slower than just sticking to the lazy bytestrings?
06:22:01 <merijn> KrzyStar: Basically, strict ByteString is a dense byte array (think C's "char*"), lazy is a lazily generated list of strict chunks
06:23:07 <merijn> KrzyStar: lazy will probably be more than fast enough unless you're building for a high-demand application
06:23:25 <merijn> KrzyStar: Also, may wanna look at pipes/conduit for high level libraries for stream processing of data
06:23:39 <KrzyStar> Yeah, I'm going to use conduit for that too
06:23:54 <KrzyStar> Thanks then, I think I'll stick to lazy bytestrings for now
06:24:27 <KrzyStar> And tune the performance later :p
06:26:58 <merijn> edwardk: I'm trying to use Unspaced and running into some really confusing behaviour and I can't seem to figure out why if you have a minute to perhaps provide some clues...
06:37:48 <Peaker> Applying the new ndm trick for stack restriction and detecting stack leaks, I get a stack overflow with a 160K stack (OK with 161K), under this recursive traversal: https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/Makefile/Types.hs#L102
06:38:14 <Peaker> This seems like a very canonical traversal code -- I wouldn't expect it to leak thunks
06:39:01 <Peaker> hmm.. I'm using it without the lens library, in a funny way, maybe that's it
06:39:26 <kaidelong> does a Data.Semigroup compatible "Ring" class live anywhere in hackage?
06:40:10 <eacameron> anyone out there working at a Python shop? If so, how do you cope?
06:40:11 * merijn facepalms
06:40:39 <merijn> Goddamn...I spend 2 hours debugging something because of a wrong default definition in a library...bollocks...
06:40:42 <mniip> can the GHC api check whether an instance exists?
06:45:37 <merijn> mniip: I think so, but don't ask me how
06:45:49 <merijn> Is there a way to quickly find all typeclasses defined in a library?
06:46:15 <mniip> I've got a rather insane idea
06:47:26 <mniip> data Context ctx where Context :: ctx a => a -> Context ctx
06:47:32 <mniip> unsafeAssumeContext :: a -> Context c
06:47:49 <merijn> Context already exists, btw
06:48:00 <merijn> It's called Dict in one of edward's wizwardry packages
06:48:21 <mniip> unsafeShow x = case unsafeAssumeContext x :: Context Show of Context r -> show r
06:48:50 <mniip> merijn, it's not dict
06:49:39 <mniip> merijn, it's like a ShowBox, except polymorphic in the box
06:49:49 <mniip> polymorphic in the show, rather
06:50:45 <mniip> so yeah, what unsafeAssumeContext would do, is package Context with a dictionary, which when unpacked, would ask the environment whether the instance exists
06:50:54 <mniip> and bottom if it doesn't exist
06:52:44 <mniip> cool huh
06:53:00 <cocreature> mniip: sounds similar to https://github.com/mikeizbicki/ifcxt#ifcxt
06:53:26 <mniip> you could even do some unsafePerformIO with catchError and make a bottomless unsafeShow
06:53:39 <mniip> cocreature, that's boring template haskell bruteforce
06:53:56 <bennofs> mniip: where are you going to get the dictionary for the instance from?
06:54:09 <bennofs> mniip: there is no "global map of all instance dictionaries" at runtime afair
06:54:16 <mniip> ghc-api
06:54:28 <mniip> ghc-api can hardly be called "runtime"
06:54:39 <bennofs> mniip: for ghc-api, you need to package the source code with the application?
06:54:50 <mniip> keep in mind this is mostly a debug thing
06:54:57 <mniip> not intended to be packaged
06:54:59 <bennofs> or at the very least the object files. 
06:55:21 <mniip> why would one want an unparametric show if not debug
06:55:26 <Peaker> https://github.com/ElastiLotem/buildsome/blob/master/src/Lib/List.hs#L18-L24 <-- how would one improve the stack space here while keeping just an Applicative constraint and not a Monad constraint?
06:56:04 <bennofs> mniip: hmm, if you're not using template haskell, then surely it must happen at runtime. Do you plan on loading the code via the GHC API?
06:56:42 <mniip> you can disassemble closures using the GHC API
06:58:26 <c_wraith> Peaker: that's pretty much an impossible request with that signature 
06:58:46 <Peaker> c_wraith: Needs a Monad constraint?
06:59:55 <c_wraith> Peaker: that doesn't help either. The problem is that for most types f, it will always have to traverse the whole input before providing output. 
07:00:08 <Peaker> c_wraith: for strict Applicatives, you mean
07:00:15 <cow_2001> i am stuck with NICTA's Course.Applicative.filtering
07:00:20 <c_wraith> Which is most of them. 
07:00:20 <Peaker> c_wraith: Does that mean it must use stack space to do so?
07:00:38 <cow_2001> i've been looking at (<$) and (<*)
07:00:57 <knupfer> Is it somehow possible to write:   deriving *
07:01:16 <knupfer> With GeneralizedNewtypeDeriving, ghc should know all the instances, no?
07:01:21 <Phlogistique> o/g
07:01:22 <Peaker> c_wraith: surely it can do so in constant stack space
07:01:23 <Phlogistique> o/go
07:01:24 <c_wraith> Peaker: I suppose you could convert it to heap space 
07:01:28 <Phlogistique> oops
07:02:07 <cocreature> cow_2001: filtering is filterM with an applicative constraint?
07:02:14 <cow_2001> :|
07:02:17 <ChristianS> knupfer: no
07:02:20 <cow_2001> i don't know
07:02:21 <geekosaur> knupfer, it is not possible
07:02:21 <c_wraith> Peaker: but I'm on my phone, so not about to try to CPS the list it builds. 
07:02:29 <cocreature> cow_2001: well what's the signature
07:03:07 <c_wraith> Peaker: but that's the idea I'd use. CPS the list construction to convert it heap space use. 
07:03:12 <Peaker> c_wraith: trying to change partitionOne to be `first (x:)` or `second (x:)`
07:03:18 <knupfer> :(
07:04:17 <geekosaur> also, while ghc may know all the instances, what should ghc do when some of them are incompatible? I may have newtype-d a monad stack with two StateT-s in it (some of which I may not know about because they're hidden in newtype-s I am building upon), I must explicitly pick *one* to derive MonadState for
07:05:52 <merijn> @tell Nevermind, I solved my issue. It was because Unspaced uses the default definition of "token". I don't think token should be in the TokenParsing class if custom "token" definitions break when using any of the fancy newtypes.
07:05:52 <lambdabot> Consider it noted.
07:05:58 <MarcelineVQ> cocreature: Applicative f => (a -> f Bool) -> List a -> f (List a)
07:05:58 <merijn> whoops
07:06:04 <mniip> geekosaur, derive?
07:06:05 <merijn> @tell edwardk Nevermind, I solved my issue. It was because Unspaced uses the default definition of "token". I don't think token should be in the TokenParsing class if custom "token" definitions break when using any of the fancy newtypes.
07:06:05 <lambdabot> Consider it noted.
07:06:31 <geekosaur> mniip, the question was how to GND all known instances
07:07:08 <geekosaur> I am pretty sure you can't derive more than one instance of MonadState because it wouldn't know which one to use?
07:07:28 <Gurkenglas> MarcelineVQ, https://hackage.haskell.org/package/witherable-0.1.3/docs/Data-Witherable.html#v:filterA
07:07:44 <knupfer> geekosaur: that makes sense, but it could default to take the topmost
07:07:59 <cocreature> cow_2001: you can write that as a fold, your folding function then gets f [a] and an a, so you need to try to smash them together using your predicate function (hint: liftA2 is probably helpful)
07:08:15 <MarcelineVQ> Gurkenglas: I was just providing context :> witherable is something I​plan to use in the future though
07:08:15 <Peaker> c_wraith: https://github.com/ElastiLotem/buildsome/blob/bad_attempt/src/Lib/List.hs#L17-L30 <-- this just made things worse :(
07:08:29 <geekosaur> then you potentially have to know which parts you are composing together have what where, and be aware of order. part of the point of GND is you are *removing* that requirement
07:08:43 <Peaker> c_wraith: is that what you meant by CPS'ing the list construction?
07:09:23 <knupfer> ok, got it.
07:09:32 <Peaker> I guess 'traverse' itself is already bad in its stack-space use with strict Applicatives
07:09:56 <c_wraith> Peaker: basically. Let me try something.. 
07:13:11 <eacameron> I figured my question was better for Reddit: https://www.reddit.com/r/haskell/comments/3m2fqk/how_a_haskeller_copes_in_a_pythonruby_shoppe/
07:14:31 <clrnd> eacameron, hi, I work in a Python shoppe
07:15:14 <Ankhers> eacameron: And I'm in a ruby shoppe
07:15:54 <geekosaur> C shop. :p
07:16:05 <eacameron> geekosaur: at least you have a compiler ;)
07:16:06 <Ankhers> geekosaur: I'm jealous
07:16:13 <geekosaur> (often rather terrifying C...)
07:16:30 <clrnd> at least you don't have *args
07:16:42 <clrnd> nevermind, I just remembered pointers and casting
07:16:46 <geekosaur> :p
07:17:04 <Ankhers> I used to love Ruby. I strongly dislike it, and moreso each day.
07:17:30 <eacameron> Ankhers: sounds like the coping isn't going so well?
07:17:31 <geekosaur> Ruby has a good language trapped inside it, screaming for release
07:17:38 <bergmark> i loved ruby because i went to it from perl
07:17:47 <Ankhers> I went to it from PHP.
07:17:50 <eacameron> geekosaur: did you steal that quote from Stroustroup??
07:17:57 <geekosaur> not consciously
07:18:00 <bergmark> i went to perl from php :D
07:18:03 <Ankhers> eacameron: It is the language itself. The more I use it, the more I find its quirks.
07:18:33 <eacameron> geekosaur: Oh, well he says that about C++ :D
07:18:35 <clrnd> eacameron, I resigned so yeah, not really coping
07:18:49 <Ankhers> PHP -> perl -> PHP -> Ruby -> C++ / Objective-C / Java -> Haskell (only for about two weeks) -> Go -> Ruby.
07:18:54 <eacameron> geekosaur: Assembly has it too... ;)
07:19:07 <eacameron> clrnd: Sorry to hear that :(
07:19:07 <clrnd> but did for a year, basically you get into fights where people just look around and don't understand what you mean by "not failing"
07:19:19 <geekosaur> not even remotely surprised
07:19:20 <clrnd> eacameron, oh no! it's for the best :D
07:19:29 <geekosaur> (I was thinking that C++ was the other language I'd apply that to....)
07:20:30 <geekosaur> ...actually C++ could be great if it'd just give up on being derived from C
07:20:34 <eacameron> Ankhers: That's quite the tale
07:20:46 <eacameron> geekosaur: My thoughts exactly
07:21:10 <Ankhers> For anyone that doesn't know Ruby, the inject doesn't work. http://lpaste.net/141555
07:21:31 <Ankhers> Well, maybe for people that know Ruby as well.
07:21:40 <Ankhers> (inject is essentially a right fold)
07:21:55 <eacameron> Ankhers: whoa, and I thought Haskell was esoteric looking
07:21:59 <Ankhers> the second inject doesn't work.
07:22:54 <Peaker> geekosaur, eacameron: That's basically D, except for a few silly "we have to keep C syntax kinda working" mentality
07:23:19 <Peaker> but D also messes up nullability, doesn't have good sum types, and a few more problems
07:23:29 <Ankhers> Usually the `{ ... }' syntax is used if you can fit it on a single line, and use the `do' syntax otherwise. But due to the way Ruby binds things in this case, it expects a symbol as an argument in the second case.
07:23:30 <eacameron> Peaker: well they picked a good name for it anywoy
07:23:33 <eacameron> *way
07:23:42 <Peaker> not a very googlable name
07:23:59 <eacameron> Peaker: it's not alone
07:24:14 <eacameron> Ankhers: wow
07:24:29 <geekosaur> yeh, my recollection is that do and { } are not 100% interchangeable, there are by design binding difference
07:24:30 <geekosaur> s
07:24:34 <geekosaur> it's been a while
07:24:38 <Ankhers> Exactly that.
07:24:44 <eacameron> sign. I was hoping there was a success story! ;)
07:26:18 <Ankhers> This is what I ended up with. http://lpaste.net/141557 -- And people say Haskell has bad syntax...
07:26:40 <eacameron> if anyone cares to upvote my reddit question so it gets more publicity, I'd be grateful ;)
07:26:43 <c_wraith> My feeling with ruby is the semantics weren't designed, they were what was easy to implement 
07:27:34 <Ankhers> This explains my thoughts on Ruby's "duck typing" - https://pbs.twimg.com/media/B3Fvg-sCYAAkLSV.jpg
07:27:34 <eacameron> Ankhers: jeepers; yep as I suspected. Ruby and Python win all the noobs because they're "simple" but they don't scale
07:27:58 <eacameron> Ankhers: AWESOME
07:28:17 <geekosaur> pretty much. take perl, hack in smalltalk-style OO, hooking in extra syntax as needed without much thought as to consequences
07:28:28 <Ankhers> eacameron: I'm sure there is a more "Ruby" way of doing things, but a fold is what made sense to me in this case.
07:28:56 <mniip> so what's UniqFM?
07:29:00 <mniip> sort of like a Map?
07:29:10 <geekosaur> and then try to remove the perl and end up hacking even more stuff in without considering the consequences of either
07:29:11 <mniip> hashmap, even
07:29:45 <luite> mniip: ~IntMap keyed by the Unique of the values
07:30:02 <mniip> not the values
07:30:05 <mniip> Unique of the keys
07:30:21 <geekosaur> (seriously, if you're going to start with perl, add smalltalk, then remove perl... maybe you'd be better off just using smalltalk?)
07:30:45 <eacameron> Ankhers: I think you image should be an answer to my reddit question...it's just too funny to pass up
07:31:12 <Ankhers> geekosaur: That is an outrageous idea.
07:31:29 <lpaste> bldzrr pasted “q1” at http://lpaste.net/341366036500578304
07:31:35 <Ankhers> eacameron: If you don't post it, I will when I get a chance.
07:31:42 <eacameron> Ankhers: I won't
07:31:53 <luite> mniip: ah right
07:32:22 <bldzrr> I was wondering if I could get some help with the question I posted. I'm not sure how to go about counting the number of slots in a template
07:32:27 <luite> mniip: it's actually an IntMap under the hood nowadays
07:32:54 * hackagebot wxAsteroids 1.1.0.1 - Try to avoid the asteroids with your space ship  https://hackage.haskell.org/package/wxAsteroids-1.1.0.1 (HenkJanVanTuyl)
07:32:58 <eacameron> geekosaur: somehow Ruby and Python programmers still have some of the highest salaries.
07:33:34 <eacameron> geekosaur: I guess you get paid for your pain tolerance
07:33:39 <Gurkenglas> bldzrr, what type does xs have?
07:33:47 <clrnd> Cobol programmes $$$
07:34:14 <merijn> clrnd: A friend of mine is decompiling OS360 assembly to cobol to recompile it to x86 :p
07:34:21 <merijn> clrnd: Millions I tell you!
07:34:29 <lpaste> bldzrr pasted “No title” at http://lpaste.net/3960992808021524480
07:34:47 <bldzrr> Template which is defined as that
07:34:47 <clrnd> merijn, that sounds awesome, the real problem is documentation I guess
07:35:39 <merijn> Whooo! I think I finally mastered trifecta :> Now I just need to force myself to try and write useful docs for mere mortals >.>
07:36:03 <eacameron> merijn: and there was much rejoicing!
07:36:33 <eacameron> I for one would appreciate some mere mortals oriented docs :D
07:36:40 <geekosaur> yeh, I could make quite a lot more by going into COBOL, but I don't hate myself that much
07:36:42 * eacameron is a mere mortal
07:36:59 <merijn> eacameron: The problem is that I now realise why there are no "mere mortals" docs :p
07:37:04 <geekosaur> (I did a lot of COBOL early on. will be happy not to do any more of it)
07:37:20 <eacameron> merijn: :/
07:37:44 <eacameron> geekosaur: merijn: clrnd: yep. pain tolerance is where the $$ is
07:37:57 <merijn> eacameron: But maybe my first parser attempt helps: https://github.com/merijn/lambda-except/blob/master/Lexer.hs
07:38:13 <geekosaur> that said, I think I'd choose COBOL over FORTRAN
07:38:31 <merijn> eacameron: I realised it'd be better to use semi and nesting to do my pseudo-layout parsing, but my refactored parser isn't there yet
07:38:38 <eacameron> merijn: So what's the impetus to use trifecta over parsec, etc.?
07:38:49 <merijn> eacameron: Cool looking errors ;)
07:39:06 <eacameron> merijn: oh...
07:39:27 <merijn> eacameron: If you want to generate parse errors like: http://files.inconsistent.nl/screen.png without actually writing anything except your parser it's great :)
07:40:00 <clrnd> Fortran is the shit man, shut up
07:40:09 <quchen2> s/the//
07:40:11 <eacameron> merijn: I suppose that is pretty coo,l
07:40:37 <geekosaur> s/the // :p
07:41:02 <c_wraith> Peaker: I tried an experiment, but it didn't work either. Type checked, but still all stack
07:41:08 <merijn> eacameron: afaik it also performs slightly faster than Parsec and seems more flexible in how you can reuse/transform parsers
07:42:02 <clrnd> merijn, is it faster than attoparsec?
07:42:49 <merijn> eacameron: The trick to realise is that the TokenParsing (from parsers) and DeltaParsing (from trifecta) typeclasses are doing all the heavy lifting in terms of overloadable combinators. The combinators in parsers are pretty much the same as in Parsec, so you can just write as normal. The beauty is when you start defining newtypes for your own Parser and transforming parsers using stuff like Unspaced.
07:43:16 <merijn> eacameron: Then you can "magically" reuse any existing parsers, but make them ignore whitespace, or change the tokenization, etc.
07:43:19 <merijn> clrnd: Doubt it
07:43:37 <eacameron> merijn: very cool
07:43:46 <suppi> next time I'm going to write a parser, I will definitely try trifecta
07:43:51 <clrnd> interesting, all the tokens stuff in Parsec is a little silly, yeah
07:44:17 <merijn> clrnd: But different use case. Attoparsec tries be fast at the cost of diagnostics (i.e. aimed at networking/protocols where error reporting is not as important) whereas trifecta is more aiming at better diagnostics
07:44:47 <merijn> eacameron: Oh, and afaict it's much simpler to write input agnostic parsers than with Parsec
07:44:58 <Peaker> c_wraith: ok, thanks. My benchmark was just running a build system -- not fully reproducible as the state changed, so now different issues reproduce. I'll come back to that if +RTS -K hits that again
07:45:03 <clrnd> merijn, now go write them tutorials
07:46:04 <clrnd> geekosaur, how would you define an array that depended on user input in COBOL?
07:46:21 <clrnd> does it have "allocatable" and "allocate" like Fortran?
07:46:43 <merijn> clrnd: I think for now I'd go with "look at the parser I linked" it's pretty easy to understand (I hope!). Tutorial has to wait until I finish this at work :p
07:54:27 <lpaste> bldzrr pasted “Parse error on input '{' ?” at http://lpaste.net/2859661419782078464
07:54:38 <bldzrr> Can anyone explain why I'm getting this error?
07:55:20 <bldzrr> getting a parse error for { when I input it
07:55:42 <merijn> bldzrr: Because "({})foo{}{}" is not valid Haskell?
07:55:52 <merijn> Therefore "templateArity ({})foo{}{}" makes no sense?
07:56:52 <bldzrr> but ({})foo{}{} is an argument for templateArity, how can I pass it in as an argument without getting a parse error?
07:57:11 <ChristianS> in practice, for string concatentation of a few Texts, is there a disadvantage when using  a <> b <> c  instead of T.concat [a, b, c] ?
07:57:52 <jameseb> bldzrr: you need to either translate it to its Haskell format or make a Read instance for it
07:57:55 * hackagebot GeBoP 1.7.5 - Several games  https://hackage.haskell.org/package/GeBoP-1.7.5 (HenkJanVanTuyl)
07:58:11 <merijn> ChristianS: A disadvantage? Sure. Is it worth caring about outside a loop/large numbers? No
07:58:48 <bldzrr> How would I "translate" it into its Haskell format?
07:59:19 <clrnd> bldzrr, what are you trying to do?
07:59:58 <lpaste> bldzrr pasted “Parse error on input '{' ?” at http://lpaste.net/4389153661058547712
08:00:04 <bldzrr> okay so
08:00:11 <bldzrr> the last 2 lines is what I'm inputting into ghci
08:00:12 <ChristianS> merijn: ok, thanks (i suspected as much)
08:00:22 <clrnd> bldzrr, yeah I've seen that
08:00:37 <clrnd> bldzrr, maybe you want to input a string literal?
08:00:45 <clrnd> like templateArity "({})foo{}{}"
08:00:51 <bldzrr> the templateArity function is suppose to count the number of templates in the argument given which in this case is '({})foo{}{}' which is supposed to return 3
08:01:04 <jameseb> bldzrr: well, I think what you have there is really Template [Left "(", Right Slot, Left ")foo", Right Slot, Right Slot]
08:01:18 <IP92> is getChar supposed to wait for enter when reading from input?
08:01:41 <jameseb> bldzrr: but that's complicated to type so it might be better to have a Read instance
08:01:48 <bldzrr> nah a string literal won't work because it's to take in a type Template
08:02:57 <bldzrr> nvm I think I got it
08:02:59 <bldzrr> thanks guys
08:03:17 <the_2nd> If I have a function f :: a -> b -> c -> result
08:03:30 <the_2nd> I can call let g = f a b
08:04:37 <the_2nd> and use g c
08:04:37 <the_2nd> is there a way to have g = f _ b c ?
08:04:37 <clrnd> the_2nd, yep, curry love
08:04:37 <Sindriava> the_2nd: let g = \x -> f x b c
08:04:37 <clrnd> the_2nd, a lambda, and @pl for much fun
08:04:37 <the_2nd> is flip the right way?
08:04:37 <Sindriava> the_2nd: But careful about the monomorphism restriction
08:04:37 <Sindriava> the_2nd: not really, not for ternary functions anyways
08:04:50 <Sindriava> the_2nd: For binary functions sure, but beyond that it gets unreadable
08:04:56 <Sindriava> @pl \x -> f x b c
08:04:56 <lambdabot> flip (flip f b) c
08:05:18 <the_2nd> whats @pl for?
08:05:23 <the_2nd> or how is it called?
08:05:35 <Sindriava> it's not called, it's a lambdabot command
08:05:37 <clrnd> point free notation
08:05:38 <ski> @help pointless
08:05:38 <lambdabot> pointless <expr>. Play with pointfree code.
08:05:53 <ski> it's for making a code snippet more pointless
08:05:54 <Sindriava> It uses some background software to create a point-free notation of a function
08:06:15 <Sindriava> the_2nd: point-free notation is a notation without unnecessary arguments
08:06:30 <Sindriava> the_2nd: e.g. `a + b = add a b` -> `(+) = add`
08:06:48 <Sindriava> the_2nd: Point-free doesn't always mean more readable and vice-versa
08:08:30 <Sindriava> Are there some resources on state machines in Haskell?
08:08:36 <the_2nd> clrnd, ah, its a lambdabot only command
08:09:27 <ski> jameseb : please not `Read' for this ..
08:10:38 <jameseb> ski: yeah, I was just thinking Read wouldn't quite do it
08:12:55 * hackagebot persistent-template 2.1.3.5 - Type-safe, non-relational, multi-backend persistence.  https://hackage.haskell.org/package/persistent-template-2.1.3.5 (GregWeber)
08:13:01 <Shockk> I've been looking at Data.Map and Data.Set--particularly the Indexed category of functions for each
08:13:41 <Shockk> I notice there's lookupIndex which returns *maybe* the index, and findIndex which returns it or errors
08:14:18 <Shockk> is there a reason something like lookupElemAt doesn't exist, whereas elemAt does which returns the elem or errors?
08:15:08 <Shockk> elemAt :: Int -> Set a -> a
08:15:25 <Shockk> I'd imagine lookupElemAt would be :: Int -> Set a -> Maybe a
08:16:17 <ski> Shockk : "Indexed category of functions" -- "category" in the sense of category theory ?
08:16:42 <ski> hm, on closer reading, i suppose not
08:16:56 <Shockk> ski: no no I just mean the functions categorized under "Indexed" here http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Set.html#g:8
08:17:02 * ski was initially thinking of stuff like indexed monads ..
08:17:56 * hackagebot servant 0.4.4.4 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.4.4.4 (jkarni)
08:17:58 * hackagebot servant-client 0.4.4.4 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.4.4.4 (jkarni)
08:18:00 * hackagebot servant-docs 0.4.4.4 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.4.4.4 (jkarni)
08:18:02 * hackagebot servant-jquery 0.4.4.4 - Automatically derive (jquery) javascript functions to query servant webservices  https://hackage.haskell.org/package/servant-jquery-0.4.4.4 (jkarni)
08:18:04 * hackagebot servant-server 0.4.4.4 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.4.4.4 (jkarni)
08:18:27 <quicksilver> Shockk: I don't think so. I guess it's cheap to check 'size' first.
08:18:38 <clrnd> ski, you pretentious quat!
08:18:38 <Shockk> I mean, from looking at the source, I don't see anything preventing that error from being replaced with a Nothing, and EQ -> x being replaced EQ -> Just x I think
08:19:09 <magneticduck> so I have a library that depends on version X of 'A', and also depends on another library that depends on version Y of 'A'
08:19:16 <magneticduck> version X is incompatible with version Y
08:19:19 <magneticduck> is there a way of making this work?
08:19:34 <ski> clrnd : "quat" being short for "quaternion" ?
08:19:35 <clrnd> Shockk, not that I know of, it seems trivial to write
08:19:35 <cocreature> magneticduck: fix one of the libraries :)
08:19:49 <ski> @wn quat
08:19:51 <lambdabot> *** "quat" wn "WordNet (r) 3.0 (2006)"
08:19:51 <lambdabot> quat
08:19:51 <lambdabot>     n 1: the leaves of the shrub Catha edulis which are chewed like
08:19:51 <lambdabot>          tobacco or used to make tea; has the effect of a euphoric
08:19:53 <lambdabot>          stimulant; "in Yemen kat is used daily by 85% of adults"
08:19:55 <lambdabot>          [syn: {kat}, {khat}, {qat}, {quat}, {cat}, {Arabian tea},
08:19:55 <clrnd> Shockk, maybe pull request ? :D
08:19:57 <lambdabot>          {African tea}]
08:19:58 <ski> hmm
08:20:01 <magneticduck> cocreature: yeah that's one way, but it's not really viable in this case
08:20:05 <Shockk> quicksilver: I guess `size' would work although it seems a bit untidy to do it that way
08:20:07 <clrnd> oh didn't know about @wn
08:20:12 <cocreature> magneticduck: I don't think there is a way around it
08:20:25 <geekosaur> magneticduck, I think you are guaranteed symbol conflicts
08:20:36 <Shockk> does containers have a git repository?
08:20:44 <ski> @help dict
08:20:44 <lambdabot> dict provides: dict-help all-dicts bouvier cide devils easton elements foldoc gazetteer hitchcock jargon thesaurus vera wn world02
08:20:47 <geekosaur> at the very least
08:20:47 <clrnd> Shockk, https://github.com/haskell/containers/issues
08:20:52 <ski> @help wn
08:20:52 <lambdabot> wn .......... WordNet (r) 1.7
08:20:55 <Shockk> aha, okay
08:20:55 <clrnd> @help devils
08:20:55 <lambdabot> devils ...... The Devil's Dictionary
08:21:02 <quicksilver> Shockk: I dunno; if you are working on Int-based indices into a Set it seems likely you'll need to know its size anyway.
08:21:06 <clrnd> @hitchcok towel
08:21:07 <lambdabot> No match for "towel".
08:21:22 <quicksilver> magneticduck: No. In principle you might think they could make that work with versioned symbols.
08:21:34 <quicksilver> magneticduck: but the real problem is deeper than that
08:21:38 <magneticduck> okay
08:21:51 <geekosaur> if the second library exposes A and you are expected to make use of it (e.g. instances or data types) then you have even bigger problems
08:22:10 <quicksilver> magneticduck: the first library's copy of 'A' might communicate indirectly with the second library's copye of 'A'
08:22:19 <clrnd> @hitchcock Ezequiel
08:22:19 <lambdabot> No match for "Ezequiel".
08:22:19 <quicksilver> and if they are different versions, bad things might be expected!
08:22:42 * cocreature remembers horrible type errors from having two different versions of a library installed
08:22:55 <geekosaur> yep
08:23:06 * hackagebot servant-examples 0.4.4.4 - Example programs for servant  https://hackage.haskell.org/package/servant-examples-0.4.4.4 (jkarni)
08:23:07 <cocreature> back in the good old days before sandboxes where a thing
08:23:08 * hackagebot servant-blaze 0.4.4.4 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.4.4.4 (jkarni)
08:23:10 * hackagebot servant-lucid 0.4.4.4 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.4.4.4 (jkarni)
08:23:12 * hackagebot servant-mock 0.4.4.4 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.4.4.4 (jkarni)
08:24:03 <Shockk> quicksilver: well I mean more the fact that the user of the library needs to remember not to lookup an elem at an index outside the bounds of the Set, like, the potential for a fatal error exists while using that (that's why I prefer not using head/tail most of the time)
08:25:43 * clrnd wouldn't be surprised if safe-containers existed
08:25:54 <clrnd> @hackage safe containers
08:25:54 <lambdabot> http://hackage.haskell.org/package/safe containers
08:26:02 <clrnd> ¬¬
08:26:04 <Shockk> @hackage safe-containers
08:26:04 <lambdabot> http://hackage.haskell.org/package/safe-containers
08:26:23 <clrnd> lambdabot, that's not very cleevr, isn't it?
08:26:42 <merijn> It's not a search, it just prefixes the hackage url for lazy people
08:27:02 <clrnd> I realized that, yeah
08:30:07 <Shockk> looks like Set.size is O(n) rather than O(1) too (at least it looks that way for IntSet so I'd imagine the same for Set), so checking `size' and then using `elemAt' would require an extra traversal over the structure as opposed to returning Nothing if the Tip of the Set is reached
08:30:44 <shachaf> It is not the same for IntSet and for Set.
08:30:49 <Shockk> oh
08:30:51 <shachaf> They're completely different data structures.
08:31:03 <jameseb> Shockk: size for Map claims to be O(1)
08:31:10 <bennofs> shachaf: http://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Set.html#v:size O(1)
08:31:16 <Shockk> oh right I see size is part of the structure in Set
08:31:20 <bennofs> Shockk: ^^^
08:31:28 <shachaf> bennofs: Yes.
08:34:26 <phaazon> hey, how can I put heads and titles in haddock-formatted comments?
08:35:22 <phaazon> oh it =
08:35:24 <phaazon> it’s*
08:36:14 <zipper> Hmmmm there's a new foldable typeclass. Did you guys know?
08:36:27 <Shockk> new?
08:37:28 <zipper> Shockk: Well I looked at the type of foldr and saw iot
08:37:31 <zipper> *it
08:37:38 <bennofs> :t foldr
08:37:39 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
08:37:42 <quicksilver> ironChicken: ping
08:37:57 * hackagebot super-user-spark 0.2.0.2 - Configure your dotfile deployment with a DSL.  https://hackage.haskell.org/package/super-user-spark-0.2.0.2 (Norfair)
08:38:12 <merijn> zipper: Foldable and that function have existed for years. It was finally decided to generalise a lot of functions in Prelude to use it so that it works by default
08:38:15 <bennofs> zipper: this is called BBP proposal and is implemented since GHC 7.10 [generalizing many prelude functions to Foldable/Traversable]
08:38:27 <ironChicken> quicksilver: lo
08:39:12 <ironChicken> quicksilver: are you wondering if i've solved my hxt problem yet?
08:39:13 <quicksilver> ironChicken: I haz solution to your HXT woes.
08:39:13 <zipper> I only know
08:39:23 <ironChicken> yay! \o/
08:39:30 <zipper> I only knew of the monad applicative proposal.
08:39:54 <zipper> GHC 7.10 is really quite different.
08:40:25 <suppi> so it looks like my 100% mutation free chip-8 emulator works pretty well https://www.youtube.com/watch?v=8gVS-433w8g
08:40:39 <jameseb> zipper: not different, just generalised
08:40:52 <quicksilver> ironChicken: http://lpaste.net/141558; I'll update the SO answer too.
08:41:17 <clrnd> suppi, congrats! but really, is it mutaiton-free? no Data.Vector? not a single IORef?
08:41:40 <suppi> clrnd, I do use Data.Vector, but isn't that mutation free?
08:41:50 <suppi> not a single IORef
08:42:26 <merijn> Every time I see people ask HXT questions it always seems so needlessly confusing...
08:42:40 <cocreature> xml-conduit to the rescue
08:42:46 <merijn> cocreature: Word.
08:42:47 <clrnd> Data.Vector uses Control.Monad.ST ... ;P
08:42:48 <Shockk> hmm, does anyone know how to install a cabal project in the current directory, into a sandbox in the target directory?
08:42:57 <ironChicken> quicksilver: cool. i'll have a look in a few minutes
08:43:28 <cocreature> Shockk: just run cabal install path/to/project from the directory the sandbox is in
08:43:39 <suppi> clrnd, oh... so 100% pure emulator? :p
08:43:42 <Shockk> cocreature: ahhh thanksd
08:43:43 <Shockk> thanks*
08:44:07 <clrnd> yay purity, arians
08:44:07 <suppi> clrnd, what is the difference between Vector and MVector then?
08:45:13 <Cale> suppi: The M stands for mutable
08:45:25 <clrnd> suppi, afaik they are faster for some things?
08:45:45 <suppi> Cale, yes, but if Vector also mutate...?
08:45:53 <Cale> Vector isn't mutable
08:46:14 <Cale> It might use mutation internally to implement its operations, but it doesn't expose this fact to the user.
08:46:28 <hexagoxel> Shockk: Also consider `cabal sandbox add-source` (cabal help sandbox)
08:46:55 <suppi> Cale, hmm...
08:46:56 <Cale> Actually, it probably doesn't use much mutation at all..
08:47:12 <Shockk> hexagoxel: ooh
08:47:16 <suppi> Cale, clrnd said that Vector uses Control.Monad.ST
08:47:31 <Shockk> hexagoxel: this uses a source project directory and rebuilds when that project changes?
08:47:40 <Cale> Maybe bits of it do, but for the most part, no.
08:47:48 <clrnd> well, I've seen it in the code, maybe it's just for MVectors :P
08:48:10 <suppi> Cale, clrnd, so can I say my emulator is 100% mutation free? :}
08:48:32 <suppi> (apart for sdl display as such)
08:48:36 <suppi> and*
08:48:43 <hexagoxel> Shockk: yes, that is the idea (only it seems/feels kind of unreliable)
08:48:48 <clrnd> suppi, :P okay, it is
08:48:54 <suppi> :)
08:48:57 <Cale> http://hackage.haskell.org/package/vector-0.11.0.0/docs/src/Data-Vector-Fusion-Stream-Monadic.html#Step -- this is the main type that operations on Vectors use
08:48:58 <Shockk> ahh I see
08:49:36 <Cale> Most of the operations are implemented in a way which is totally polymorphic in the choice of m in that Stream type
08:49:57 <Cale> (as you can see from the rest of the module)
08:50:04 <suppi> I see, thanks Cale
08:50:46 <suppi> I wanted to see how far I could go with no mutation at all. I was told I should use mutation for the emulator so it will be performant enough
08:51:02 <Cale> I hate the word "performant"
08:51:03 <clrnd> suppi, ohh like that, show them!
08:51:21 <suppi> Cale, what would be a better word?
08:51:34 <Cale> Well, what do you mean by it? :)
08:51:42 <clrnd> "performant enough" is what doesn't make sense
08:51:45 <suppi> clrnd, it looks like for a weak platform such as CHIP-8, no mutation is needed
08:51:47 <clrnd> enough for who? what?
08:52:03 <suppi> enough to model a real chip-8
08:52:10 <Cale> (nevermind that performant is a noun)
08:52:55 <clrnd> suppi, I can model it in paper and follow the steps by hand, is that performant enough?
08:53:20 <suppi> clrnd, can you run a game at the same speed as a real chip-8 system on paper?
08:54:07 <Cale> Usually when people say that word, they really mean to say that the program will run quickly. Usually there are tradeoffs to be made between time and space performance.
08:54:13 <clrnd> suppi, that's a characteristic of the hardware
08:54:51 <suppi> english is not my native language so I may use expressions that doesn't make sense, please tell me if i do
08:54:56 <suppi> clrnd, what do you mean?
08:55:38 <Cale> suppi: Your English is actually fine, this is something that English speakers actually say, I just don't care for it :)
08:55:41 <matman> Trying to learn some haskell! Kind of stuck on how to get this simple app working.. https://coderpad.io/TPX9Z9P9
08:55:42 <clrnd> suppi, I mean, "performant enough" needs a reference framework, "at least as fast as an original chip-8" makes sense, but it's a mixture of hardware and software
08:55:54 <KrzyStar> @pl (\(a,b,c) -> f a >> f b >> f c)
08:55:55 <lambdabot> (line 1, column 8):
08:55:55 <lambdabot> unexpected "c"
08:55:55 <lambdabot> ambiguous use of a non associative operator
08:56:31 <suppi> Cale, i don't fancy it either, but I thought that in this context (comparing to a real live platform) it makes sense
08:56:37 <geekosaur> there is no standard way to unpack a 3-tuple without points
08:56:46 <suppi> clrnd, what do you mean a mixture of hardware and software?
08:56:47 <Cale> suppi: Well, originally "performant" was just a noun that meant "one who performs", but this new adjective sense has become popular lately, and I think it usually gets used by people who are being handwavy.
08:56:48 <KrzyStar> Dammit!
08:57:23 <clrnd> suppi, the speed, that is how many real world seconds it takes to compute something, depends on hardware too, don't you agree?
08:57:33 <suppi> clrnd, definitely
08:57:44 <suppi> clrnd, though I meant on a modern computer
08:57:44 <mtesseract> Hi
08:57:53 <suppi> like my macbook air
08:57:55 <glguy> KrzyStar: Control.Lens.each :: Applicative f => (a -> f b) -> (a,a,a) -> f (b,b,b)
08:58:02 <Cale> KrzyStar: I don't think @pl knows how to deal with triples
08:58:05 <quicksilver> KrzyStar: (1,2,3) & each print
08:58:10 <radens> Hey, I've found pydoc (basically a clone of perldoc) to be an invaluable reference. Is there something similar for haskell?
08:58:19 <quicksilver> where print is just standing in for your 'f' as a monadic action
08:58:20 <suppi> like, "these days it makes sense to build software that way"
08:58:26 <Cale> quicksilver: Why not  each print (1,2,3) ?
08:58:33 <radens> I know about haddock but that doesn't document standard library functions etc. and only seems to do html.
08:58:34 <quicksilver> Cale: because I'm odd like that.
08:58:46 <Cale> I find almost all uses of & disgusting :P
08:58:49 <suppi> Cale, I agree, especially I don't like how people say "this language is slow and this one is fast"
08:59:30 <quicksilver> Cale: I find some consistency in keep the object I'm working on at the left. Consistency between uses of ^. and %~ and so on.
08:59:33 * KrzyStar looks at Lenses and runs away
08:59:50 <KrzyStar> :D
08:59:57 <glguy> quicksilver: That won't be an issue once you give up ^. and %~ :)
09:00:01 <mtesseract> Why is "((\ a -> return a) >>= (\ b -> return b))" a valid expression? As I understand it, the first argument of ">>=" needs to be a monadic value, but I am giving a function (of type a -> m a) as first argument. How (and why?) is this interpreted as a monadic value?
09:00:07 <quicksilver> Cale: but mostly I am cargo culting, so blame edwardk and shachaf 
09:00:30 <shachaf> quicksilver: whoa whoa whoa, I hardly use the lens operators.
09:00:41 <quicksilver> ok just blame edwardk
09:00:42 <glguy> haha
09:00:44 <dmj`> mtesseract: (->) is a monad, can be considered your "m a"
09:00:46 <geekosaur> mtesseract, there is a function monad
09:00:48 <shachaf> And I'm not a big fan of (&). It can be OK in lens, but I don't think it should've gone into base.
09:00:51 <shachaf> Oh well.
09:01:33 <mtesseract> dmj`, geekosaur: I see, thanks, I wasn't familiar with that.
09:01:51 <shachaf> Next quicksilver will start using (<&>) instead of fmap.
09:02:27 <quicksilver> sometimes notational choices make it easier to see useful patterns in code
09:02:34 <quicksilver> which notational choices to make can be a hard decision.
09:02:51 <glguy> I think that the possible redeeming value of <&> is when you want to have an open lambda on the right side
09:04:29 <clrnd> matman, don't know coderpad, can you see what I did?
09:04:58 <matman> clrnd I can!
09:05:16 <clrnd> matman, oh, ok :P, did you get what was the problem?
09:05:22 <matman> clrnd not really
09:06:22 <clrnd> lets see
09:06:40 <matman> clrnd I can kind of see what you did.. kind of turned the filter function into a curried function that takes 1 argument
09:06:55 <ironChicken> quicksilver: thanks, that works for me :-)
09:06:58 <matman> then liftm that.. so it works with IO
09:07:02 <ironChicken> i've accepted your answer on SO
09:07:32 <clrnd> matman, the thing is, filter and leftHandWord are pure both
09:07:32 <matman> clrnd I think I see why that works
09:07:35 <lpaste> bldzrr pasted “replace empty slots in template with strings?” at http://lpaste.net/1849929739662262272
09:07:47 <delYsid> How would people call the "parser" primitive in function pvs (line 118) here: https://github.com/mlang/hbmc/blob/master/Text/Braille/Music.hs  It is basically a "sequence on steroids", using (++) instead of (:) to concatenate non-deterministic results.  I am wondering if there is a proper name for that pattern.
09:08:28 <clrnd> matman, pure is a bad word, meant "non monadic"
09:09:41 <clrnd> you have some `m [a]` and needed to filter the `[a]`, so yeah you need some kind of `m [a] -> (a -> Bool) -> m [a]`
09:09:57 <Fuuzetsu> :t filterM
09:09:58 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
09:10:17 <clrnd> liftM2 would have worked if leftHandWord was also `m (a -> Bool)`, but it isn't
09:10:30 <Fuuzetsu> :t (>>= filterM undefined)
09:10:32 <lambdabot> Monad m => m [a] -> m [a]
09:11:01 <phadej> :t \p mx -> liftM (filter p) mx
09:11:02 <lambdabot> Monad m => (a -> Bool) -> m [a] -> m [a]
09:11:15 <phadej> :t \p mx -> fmap (filter p) mx
09:11:16 <Fuuzetsu> or that
09:11:17 <lambdabot> Functor f => (a -> Bool) -> f [a] -> f [a]
09:11:29 <Fuuzetsu> :t liftM2 filter
09:11:30 <lambdabot> Monad m => m (a -> Bool) -> m [a] -> m [a]
09:11:36 <matman> <clrnd> so what if my monadic input was the first parameter and the pure function was the second? 
09:11:41 <Fuuzetsu> kind of it if you lift the p
09:11:49 <Fuuzetsu> flip?
09:12:22 <clrnd> matman, flip, or "do notation" why not
09:12:34 <clrnd> you can play between totally unreadable and boring
09:12:40 <tomberek> Alternative f => (forall z. z -> f z) -> a -> b -> f ( a -> b -> c) -> f c    This is almost Applicative with <$> and <*>, but I want slightly different behavior. Basically, whenever both f a and f b are isomorphic to Just something, i want both arguments to <*> to use the Just variation of the alternative. I can do this demanding Alternative and MonadPlus, is that too strong?
09:15:05 <ski> tomberek : not sure where `Maybe'd fit into that ..
09:15:21 <tomberek> ski: optional from alternative
09:17:28 <tomberek> ski: taking a step back, using Maybe for applicative operations a <$> b <*> c creates failure whenever b or c is "empty".  I have a situation were: func = pure a <$> f a <*> f b, but I want to link (f a) and (f b) such that both are success (using <|> and pure) if either one is.
09:17:57 <NemesisD> does anyone know why https://hackage.haskell.org/package/asynchronous-exceptions-1.1.0.1 was deprecated?
09:18:14 <chpatrick> are there any plans to deprecate Data.Functor.Constant in favor of Control.Applicative.Const?
09:18:33 <NemesisD> it backports SomeAsyncException and provides variations of catch/try that let async exceptions pass through. seems useful, why would it be deprecated?
09:18:55 <ski> did you mean `pure a <*>' or `a <$>' instead of `pure a <$>' ?
09:19:14 <chpatrick> ski: no, the Const type vs the Constant type
09:19:18 <chpatrick> they're the same
09:19:23 <tomberek> ski: for now I do this: http://lpaste.net/141559
09:19:48 <ski> chpatrick : sorry, meant for tomberek
09:19:50 <chpatrick> oh sorry maybe you were replying to something else
09:21:09 <chpatrick> tomberek: what is this for?
09:21:24 <ski> tomberek : are `f a' and `f b' idempotent ?
09:21:56 <tomberek> yes, I don't think I need MonadPlus
09:22:38 <tomberek> ski, chpatrick: this is an operator for compos (Almost compositional Types, generic programming that allows GADTs) that supports the rewrite operation
09:23:13 <tomberek> (alternatively, does anyone know how to write the rewrite from Control.Lens.Plated using the compos operators?)
09:24:03 <tomberek> http://www.cse.chalmers.se/alumni/bringert/publ/composOp-jfp/composOp-jfp.pdf
09:25:45 <tomberek> i have a GADT that is difficult to use with generics libraries, and only the compos approach seems to work for me. The uniplate compatibility layer only applies to normal algebraic types.
09:26:28 <tomberek> i also tried ho-rewriting, but that relies on compdata, also not friendly to GADTs
09:27:09 <chpatrick> tomberek: can I see the GADT out of interest?
09:29:14 <tomberek> chpatrick: data Cat a b where Id :: Cat a b    (:>>>) :: Cat a b -> Cat b c -> Cat a c      just that seems to be problematic
09:30:06 <chpatrick> ah so it's like a free category?
09:30:08 <tomberek> the trouble always seems to be that the descendants of :>>> are not of the same type as the parent.  Then the 'b' parameter becomes 'untouchable'.
09:30:09 <tomberek> yeah
09:30:33 <tomberek> i'll work up through all the structures to closed cartesian and arrows
09:30:51 <chpatrick> and you would like to do generic traversal
09:30:57 <tomberek> using this structure for now: https://github.com/gelisam/category-syntax/tree/master/src/Control/Category
09:32:02 <Shockk> could someone tell me how this patch looks?
09:32:03 <tomberek> chpatrick: yes... I could not get any of the generics libraries to work, only compos seems up to it. But rewrite needs slightly different behavior to signal a successful rewrite
09:32:08 <Shockk> https://github.com/shockkolate/containers/commit/f024d9eeaaf3d4921c81bcc55a8f79069fb1ef76
09:32:59 <chpatrick> Shockk: isn't that elemAt?
09:33:16 <chpatrick> ah but with a Maybe
09:33:22 <Shockk> chpatrick: see the commit message
09:33:24 <Shockk> yep
09:33:42 <ski> tomberek : hm, yes `b' there is "existential"
09:35:22 <ski> @type let (a <^> b) f = optional (f a) >>= maybe (liftM ((,) a) (f b)) (\a -> liftM ((,) a) (f b `mplus` return b)) in (<^>)
09:35:23 <lambdabot> MonadPlus m => a -> a -> (a -> m a) -> m (a, a)
09:35:33 <chpatrick> tomberek: I wonder if you could make some kind of rank-n traversal for it...
09:35:44 <ski> tomberek : it also made me think of a `cond'/`ifte' operation as perhaps more appropriate
09:36:49 <chpatrick> tomberek: catPlate :: forall f. Applicative f => forall x y. (Cat x y -> f (Cat x y)) -> Cat a b -> f (Cat a b)
09:36:58 <chpatrick> it wouldn't be a traversal though strictly speaking...
09:37:47 <chpatrick> actually I'm not even sure that would make sense like that
09:38:27 <tomberek> something like:  forall f. Applicative f => forall x y. (Cat x y -> f (Cat x y)) -> Cat a b -> Cat a b  is the eventual goal
09:38:40 <tomberek> though I think it needs to be Alternative at least
09:38:45 <chpatrick> can't you just write that though?
09:39:20 <merijn> Ugh, I hate rewriting grammars >.>
09:39:24 <ski> tomberek : something like `(a <^> b) f = cond (f a) (\a -> cond (f b) (\b -> return (a,b)) (return (a,b))) (liftM ((,) a) (f b))', given `cond :: forall a b. m a -> (a -> m b) -> m b -> m b'
09:39:41 <ski> tomberek : not sure whether `cond' would make sense for a non-monad idiom ..
09:40:05 <ski> chpatrick : brackets ?
09:41:33 <merijn> I stupidly screwd up my parser for function application and the "simple" restructuring makes it loop due to left recursion in the grammar, yay! >.>
09:42:01 <lpaste> chpatrick pasted “catplate” at http://lpaste.net/141561
09:42:08 <chpatrick> tomberek: ^^^^ typechecks FWIW
09:42:18 <chpatrick> it's not really plate though, it's rewrite
09:42:58 <tomberek> ski: chpatrick: the compos approach usually defines the compos operator like:  pure (:>>>) <$> f a <*> f b
09:42:58 <lpaste> chpatrick revised “catplate”: “No title” at http://lpaste.net/141561
09:43:00 * hackagebot super-user-spark 0.2.0.3 - Configure your dotfile deployment with a DSL.  https://hackage.haskell.org/package/super-user-spark-0.2.0.3 (Norfair)
09:43:02 <chpatrick> it's plate now
09:43:22 <tomberek> chpatrick... is it? on failure won't the <*> default to the failure case?
09:43:33 <chpatrick> not sure what you mean by failure
09:44:11 <tomberek> let's say we want to use rewrite where your func is (a -> Maybe a) -> a -> a
09:45:42 <tomberek> using `catPlate myRewriteRule` with compos would create a Nothing on one side of the <*> operator, failing the whole rewrite.
09:46:07 <ski> chpatrick : tomberek wants to use `pure' instead of `f' on one part, if it fails and the other still succeeds
09:46:19 <ski> iiuc
09:46:22 <chpatrick> hmm
09:46:27 <chpatrick> I wonder if we could fit it into rewriteOf somehow
09:46:46 <tomberek> chpatrick: I'm not sure how rewrite does it, but it uses the Just as a signal for success that trickles all the way back to the top
09:47:08 <tomberek> normally Maybe signals failure for Monad and Applicative and short-circuits. 
09:47:54 <tomberek> I need the opposite, where Just is success and forces the application of pure everywhere else, but if I have Nothing everywhere, I need the Nothing to signal that rewriting is over with.
09:48:58 <tomberek> ski: hopefully that made sense... yes, I'd love to use rewriteOf.... i couldn't figure out how to use rewrite due to the Plated constraint and use of GADT
09:50:00 <tomberek> Simple ASetter   ===>  (a -> Identity a) -> s -> Identity s
09:52:30 <tomberek> catSetter f Id = Identity Id      catSetter f (a :<<< b) = Identity ( catSetter f a :<<< catSetter f b)     i'm not sure that's on the right track
09:55:40 * ski isn't following tomberek
09:56:13 <chpatrick> I have a feeling it's impossible to write a Plated for it
09:56:25 <bldzrr> http://lpaste.net/1849929739662262272
09:56:27 <tomberek> ski: trying to see if rewriteOf from Control.Lens.Plated can be used instead of my messing around with writing a Plated Instance
09:56:31 <bldzrr> Anyone know how to do this?
09:56:49 <tomberek> not sure if I can write an ASetter'
09:56:50 <chpatrick> or anything that can fit into ...Of
09:56:57 <chpatrick> I don't think so
09:57:32 * ski cringes on this use of `Show'
09:57:56 <tomberek> chpatrick... that was my fear.... so I fell back to trying to write my own with the compos approach, but I couldn't figure out how to write rewrite using the composOp, etc. primitives
09:58:45 <tomberek> I actually got it working, here's the lpaste: http://lpaste.net/141563
09:58:58 <tomberek> but it's ugly and i thought there might be a better way
09:59:03 <Sindriava> Is there perhaps an extension that allows monadic construction of records with fields?
09:59:19 <Sindriava> e.g. `Record { field <- monad }`
09:59:23 <ski> bldzrr : `concatMap f xs' or `concatMap (either id (const "{}")) xs'
09:59:53 <Sindriava> Which would have the type of `monad Record`
10:01:42 <ski> bldzrr : if you really don't like the default `Show' on `Template', i'd define a `parseTemplate :: String -> Template' and then make `show (Template [Right Slot,Left "word",Right Slot,Right Slot])' output the characters `parseTemplate "{}word{}{}"'
10:02:20 <bldzrr> ski : but in your first message, that isn't using anything in strs is it?
10:02:59 <hackrilege> Hi gang, I'm reading http://stackoverflow.com/questions/13352205/what-are-free-monads and I was wondering about why is endo-functors, and how important they are, I just wanted a quick pointing in the right direction in case it's a side track. I feel that I'd I went down all the new avenues I see I would never get what I wanted... I can't even remember why im learning about free monads...
10:03:11 <ski> bldzrr : for `template', you need to thread your state (the remaining strings to plug into the template) through your recursion. use a helper `loop :: Template -> [String] -> (String,[String])', e.g., or use `State'
10:03:33 <monochrom> hackrilege: do you mean "what is endo-functors"?
10:03:35 <ollo`> I'm trying to log responses in Wai so I'm `mappend`ing builders in an IORef. However, the actual output from `decodeUtf8 . Builder.toByteString` is a stuff like `\u001f\u0023...`. What decoding should I be using?
10:03:35 <hackrilege> What are - not "why is", in the above
10:03:44 <ski> bldzrr : my first was about your `Show' instance
10:04:22 <tomberek> ski: chpatrick: that doesn't seem like it would compose well or be general. Can I capture that pattern somehow in a newtype'd instance for Applicative?
10:04:22 <monochrom> ok, first endo-function: it simply means X -> X. for example not :: Bool -> Bool is an endo-function. domain and co-domain are the same.
10:04:47 <hackrilege> Ok cool thanks that was so fast!
10:05:25 <monochrom> endo-functor: every functor is from a category to a category. when the "from" and the "to" are the same category, you have an endo-functor.
10:07:08 <bldzrr> ski : can it not just stay the way it is? This is a homework question and that was given to us
10:07:20 <lpaste> chpatrick revised “catplate”: “No title” at http://lpaste.net/141561
10:07:29 <chpatrick> tomberek: ^ can't you do that?
10:07:33 <bldzrr> ski : we're just told to replace slots with the strings and we can assume that they'll always be equal
10:07:57 <ski> tomberek : i'd avoid using `isJust' like that (unless you know you're idempotent). try using something like my suggested `(a <^> b) f = optional (f a) >>= ...' in there instead ?
10:08:10 <chpatrick> I mean if you just want rewrite that's pretty much it
10:08:19 <chpatrick> it doesn't express the traversal nicely though...
10:08:26 <chpatrick> but I don't know if that's possible, at least with lens
10:08:36 <tomberek> ski: okay
10:08:39 <ski> bldzrr : personally, i think it's bad style to have a `Show' instance like that
10:08:58 <bldzrr> ski : I'd change it but I think we're suppose to keep it the way it is
10:09:10 <hackrilege> I'm not sure how a Functor casts between categories in analogy top how functions map between sets
10:09:16 <bldzrr> ski : how would I go about my question while keeping the instance of Show the same?
10:09:25 <hackrilege> To
10:09:35 <tomberek> chpatrick: again, that doesn't seem to have the right sematics
10:10:00 <chpatrick> tomberek: why not?
10:10:07 <chpatrick> it applies f until it's no longer possible to
10:11:14 <ski> hackrilege : consider the category `Graph' of graphs, and graph-homomorphisms, there's a functor from it to `Set', that forgets all the edges of a graph, and just gives you the set of vertices. there's another functor from `Graph' to `Set' that gives you the set of connected components of a graph
10:12:42 <tomberek> chpatrick: ah, i see
10:12:53 <ski> bldzrr : try my latter suggestion ?
10:13:05 <hackrilege> So Functor extracts either objects or stores from a category? Ski
10:13:20 <hackrilege> Across, not stores sorry
10:13:26 <bldzrr> ski : sorry could you resend it? I lost it
10:13:27 <hackrilege> Arrows, ffs
10:15:05 <ski> hackrilege : a functor from `C' to `D' maps objects of `C' to objects of `D', and maps morphisms of `C' to morphisms of `D' (namely to a morphism between the two objects in `D' that the functor maps the domain and codomain of the given morphism to)
10:15:19 <hackrilege> This is the statement I'm trying to understand "monads can be seen as monoids in the category of endo functors"
10:15:48 <lpaste> chpatrick revised “catplate”: “No title” at http://lpaste.net/141561
10:16:07 <ski> hackrilege : if `F' is a functor from `C' to `D', write `F : C >---> D'. for any object `A' of `C', write the object of `D' that `F' maps it to as `F_obj A'
10:16:08 <Sindriava> So when a functor maps obejcts A and B to A' and B', it will map the morphism AB to A'B' ?
10:16:20 <chpatrick> :t fmap
10:16:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:16:36 <shachaf> Many things can be seen as monoids in one category of endofunctors or another.
10:16:45 <chpatrick> (a -> b) -> (f a -> f b)
10:17:00 <hackrilege> Here you are using the word morphism where I had used arrow, is there a difference between these terms?
10:17:09 <ski> hackrilege : given any two objects `A',`B' of `C' and any morphism `f : A >---> B' of `C', `F' maps this to a morphism of `D' between `F_obj A' and `F_obj B'. write `F_mor f : F_obj A >---> F_obj B'
10:18:21 <tomberek> chpatrick: should the last line not be: process x = maybe x process (catRewrite f x)
10:18:57 <tomberek> a rewrite higher in the structure might trigger a possible rewrite later on?
10:19:45 <ski> hackrilege : finally, a functor has to satisfy two laws. for any object `A', say `id_A' is the identity morphism on it. `g . f : A_0 >---> A_2' will be the composition of `f : A_0 >---> A_1' and `g : A_1 >---> A_2'. the two functor laws, for `F' are : (a) `F_mor id_A = id_{F_obj A}', for any object `A' of `C', and (b) `F_mor (g . f) = F_mor g . F_mor f', for any objects `A_0',`A_1',`A_2' of `C' and `f',`g' as before
10:20:55 <ski> Sindriava : well `AB' (presumably ?) isn't a morphism ..
10:20:57 <hackrilege> Thanks ski, still reading but this seems pretty great
10:21:26 <Sindriava> ski: I meant A >—> B, I just didn't know the notation ^^
10:21:47 <ski> well `A >---> B' here would be a collection of morphisms, not an individual morphism
10:22:32 <hackrilege> Again, just since I'd never seen what is a morphism, how does it differ from an arrow (namely something with a defined domain and codomain)
10:22:33 <ski> (`f : A >---> B' meaning that `f' is a morphism with domain `A' and codomain `B')
10:22:50 * ski isn't sure how hackrilege defines "arrow"
10:23:25 <ski> in category theory, the terms "morphism","map","arrow" are sometimes used more or less interchangably
10:23:52 <ski> (also "homomorphism", though it tends to be used in algebraic cases, where there's an algebraic structure to be preserved)
10:27:08 <hackrilege> As far as I know as a complete noob, an arrow is just something with a defined domain and codomain. Which seems to be how you are using morphism. An example being that "a category is a collection of objects and arrows who's domain and domain are contained within these objects."
10:27:26 <shane_> Does anyone here use category theory to get ideas useful in Haskell? I specifically mean, do you for instance, recognize a category theory abstraction and use a theorem from category theorem to get some useful abstraction for programming in Haskell?
10:27:38 <ski> (btw, note that some people would use `--->' for a general morphism arrow, reserving `>--->' (sometimes `c--->') for monomorphisms (morphisms satisfying a particular property, being a generalization of injectivity). also `--->>' for epimorphisms (the property being a generalization of surjectivity))
10:28:00 * ski personally uses `>>--->' respectively `>--->>' for those
10:28:20 <lpaste> bldzrr pasted “No title” at http://lpaste.net/6118819016443166720
10:28:35 <ski> shane_ : edwardk has been known to do such things
10:30:13 <hackrilege> Shane_ I'm trying to rewrite chemistry in terms of category theory from higher order functional programming. My motivation is that hopefully drawing parallels between existing fields of representation will allow sharing of resource. I have found many of the ideas I thought were my own in chemistry have actually been well studied in category theory
10:31:15 <shane_> ski: Indeed, I read that somewhere. I was hoping to get something more detailed
10:32:11 <hackrilege> It's obvious that you never need classes, but that by recognising when you use them you can use libraries defined in terms of them
10:32:21 <shane_> hackrilege: can you elaborate some more? I know some category theory, being a mathematician.
10:33:02 * hackagebot direct-sqlite 2.3.16 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  https://hackage.haskell.org/package/direct-sqlite-2.3.16 (JanneHellsten)
10:34:28 <ski> bldzrr : either explicitly say `f :: String -> Either String Slot -> State [String] String', or add `{-# LANGUAGE FlexibleContexts #-}' to the top of your source file
10:34:47 <hackrilege> It's actually protected up of my own, but I'll share it all after I publish. Keep an eye on the discussions here for many many examples. But as I say, i can see no clear example of why it is necessary, other than to find existing resource on equivalent definitions. Later I would like to find some lemmas and corllaries which are non obvious, but I hasn't found any yet
10:35:01 <ski> bldzrr : also, why not use `foldr' instead of `foldM' .. or at least accumulate in the opposite order, and do a final `reverse'
10:35:01 <hackrilege> Protected ip
10:35:20 <ski> shane_ : you could try to catch edwardk
10:35:33 <shane_> ski: I'd love to do that.
10:36:11 <shane_> ski: I read a response by him on stackoverflow and he seems the very person I want to ask
10:36:23 <ski> shane_ : yoneda, density, and kan extensions are examples of things that have found use
10:36:39 <joshkirklin> The quickselect implementation at http://rosettacode.org/wiki/Quickselect_algorithm#Haskell seems to have a space leak. I'm a bit of a novice in all the details of thunks etc. Can someone point me in the right direction to fixing the leak?
10:36:59 <hackrilege> I think I found a nice paper about defining computation in terms of monads by Phil wadeler who wrote Haskell. It more or less seems the whole language is done in this sense
10:37:01 <frerich> Hm, wasn't there a common name for 'foldr (<|>) empty'?
10:37:08 <ski> (apart from the obvious : functor, monad, category, the concept of "free")
10:37:53 <shane_> hackrilege: thanks, I will try and keep. Indeed, these non-obvious lemmas and corollaries are exactly what I am looking for>
10:37:57 <hackrilege> Ski, you can summon him by saying lens three times in the mirror
10:38:08 * ski thinks hackrilege ip is 188.29.165.242
10:38:20 <hackrilege> Shane_ sorry, not ski
10:38:34 <shane_> hackrilege: :D 
10:39:08 <hackrilege> I'm not sure why you just posted my ip address?
10:39:20 <ski> <hackrilege> Protected ip
10:39:28 <hackrilege> Oh I meant intellectual property, not ip address
10:39:45 <Shockk> lol https://github.com/haskell/containers/pull/166
10:39:52 <Shockk> the test failed due to "Your test run exceeded 50 minutes. "
10:39:58 <ski> shane_ : also <http://comonad.com/reader/>
10:40:21 <frerich> Ah, asum!
10:40:32 <hackrilege> What about density you refer to, it is not a term without ambiguity for a Google search
10:40:53 <Shockk> haha @ the posted IP
10:41:03 <ski> hackrilege,shane_ : yes, Wadler papers are usually good
10:41:13 <shane_> ski: thanks I will check them out
10:41:30 <ski> (also they tend to have witty titles)
10:41:39 <hackrilege> :t asum
10:41:41 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
10:43:12 <hackrilege> Ski what about the density? Better phrasing of this question above
10:43:32 <shane_> what is the category-extras used for?
10:44:54 <hackrilege> Shane_ it looks like our quests are similar, can you drop me a message at hackrilege@gmail.com if you unearth any goodness?
10:45:20 <shane_> hackrilege: I surely will!
10:45:33 <hackrilege> Thanks
10:46:06 <broma0> Need some help with handling types in a web app. Say I have a User type with records id, fname, lname, username, and password. How can handle the decoding of requests containing only sub-parts of the user type (like just a uname/pass for login, just uname/fname/lname for account update) as well as the encoding of responses containing only sub-parts (when a user requests their account, i want to send the wh
10:46:12 <broma0> ole User type excluding the password) from the main User type without creating N additional types containing the just sub-parts in question? Sorry about how long that was..
10:46:16 <hackrilege> The best thing I found so far was fix...
10:46:50 <hackrilege> Which I barely understand but it involves type magic
10:46:58 <shane_> hackrilege: I just sent you an email to your account. Let me know in case you too find anything
10:47:09 <hackrilege> Cheers
10:48:02 <joco42_> what are the the naming conventions for creating haskell packages ? how should I name a file that contains only type and data declarations ? how should I name a file that contains only related pure functions? and related a->IO m functions ? is there some guidelines how one should structure the namespaces in Haskell ? how to divide the code into packages?
10:48:16 <shane_> hackrilege: fix? Do you mean the fix function?
10:48:27 <hackrilege> I have funding so I'll report my findings, it's a shame when you have to write the resource you were trying to find...
10:50:08 <hackrilege> Shane_ something about hylo. I'm really unsure sorry
10:50:08 <joco42_> how is it done in largish libraries?
10:50:08 * ski . o O (: <http://comonad.com/reader/2015/on-the-unsafety-of-interleaved-io/> :)
10:50:08 <ski> @karma+ dolio
10:50:08 <lambdabot> dolio's karma raised to 18.
10:51:15 <ski> hackrilege : iirc it's mentioned in "Category Theory for the Working Mathematician" by MacLane ? i only know the definition in the Haskell context
10:51:17 <monochrom> http://lpaste.net/77374 :)
10:51:46 <edwardk> shane_: i get a lot of mileage out of category theory
10:52:00 <hackrilege> Hey hey, it worked!
10:52:44 <shane_> edwardk: Could you elaborate a bit! Did you use any theorems in category theory to come up with ideas for abstractions in Haskell that would normally not be very natural to think about?
10:53:03 * hackagebot psqueues 0.2.0.3 - Pure priority search queues  https://hackage.haskell.org/package/psqueues-0.2.0.3 (JasperVanDerJeugt)
10:53:03 <shane_> hackrilege: Indeed, :)
10:53:09 <edwardk> sure. lets see things that category theory led me to a good understanding of. hrmm
10:53:42 <hackrilege> Women are best understood using category theory
10:53:55 <shane_> I am particularly looking for abstractions which would normally have been very difficult to think about without linking with some category theory theorems
10:54:02 <edwardk> that applicatives are closed functors. that i can use the yoneda lemma on the functor category to take the definition of a lens in terms of the 'costate comonad coalgebra' and reformulate it to get the van laarhoven lens representation. now we can use (.) to compose, because we're composing functions, and it is obvious through yoneda why that works
10:54:33 <geekosaur> hackrilege, stop now
10:54:45 <Fuuzetsu> yes, if you say the w word people flip shit
10:54:58 <joco42_> hackrilege: yes, i agree with that, and i am even writing a program in haskell just for that, and i am not kidding :) really
10:55:34 <joco42_> the thing is that no-one would believe that i am not kidding ... :)
10:55:52 <edwardk> free and cofree monads and other constructions, that [] isn't the 'free monoid' in haskell, that class if I build an adjunction class in hask that is limited to functors from hask -> hask it is boring. why? because well, if g is a right adjoint and it is a functor to * then it is represented by the left adjoint applied to (), leading to the observation that
10:55:52 <edwardk> all instances of such a class are isomorphic to the normal (,) e -| (->) e adjunction, so you need to go outside of kind * to find interesting adjunctions.
10:56:46 <edwardk> that i can read off a universal property as a definition for many useful things, just by rearranging it so that the thing is on one side of the (->) and taking it as a data type definition. this let me talk about ends and coends, limits and colimits, kan-extensions of various flavors.
10:57:22 <edwardk> using codensity lets me rearrange code to 'fuse (>>=)'s, using yoneda lets me fuse 'fmap's
10:58:29 <shane_> edwardk: all this sounds quite interesting! Can you point me to some resources. I know of the usual category theory resources for mathematicians, but I wanted to get acquainted with the applications in Haskell too.
10:58:43 <edwardk> category theory is a great source of isomorphisms, of structures that exist within the category in question, after all, a lot of it is trying to move more and more of that structure into the internal language of the category, but in hask we're stuck programming 'in that internal language' for Hask, so getting more names for relationships i can employ here
10:58:43 <edwardk> inside my code gives me more directions to exploit. they are all the same to a mathematician, one isomorphic thing is as good as another, but to a computer scientist who cares about asymptotics they may differ wildly
10:59:28 <edwardk> the main reference i can offer is my blog on comonad.com/reader and my posts on fpcomplete.com/user/edwardk    a number of them wander off and ramble in this direction =)
10:59:40 <shane_> edwardk: thanks ! 
10:59:44 <hackrilege> I guess we could do with a simple phrasing of the yoneda mamma. The wiki page is difficult
10:59:51 <hackrilege> Lemma
10:59:55 <edwardk> hackrilege: hah
11:00:09 <hackrilege> Sorry, its my phone's keyboard
11:00:46 <edwardk> yoneda lemma in 5 seconds:
11:00:54 <Fuuzetsu> that's a new one
11:00:54 <mniip> fin
11:00:56 <edwardk> :t ($ id) .  flip fmap
11:00:57 <lambdabot> Functor f => f b -> f b
11:01:05 <Fuuzetsu> when are you writing category theory for dummies?
11:01:06 <edwardk> that is id
11:01:16 <edwardk> and the other way around when given a rank n type
11:01:30 <edwardk> :t flip fmap . ($ id)
11:01:32 <lambdabot> Functor f => ((a1 -> a1) -> f a) -> (a -> b) -> f b
11:01:44 <hackrilege> Fuuzetsu, I guess that's our job
11:02:02 <shane_> edwardk: I am familiar with the Yoneda's lemma and the universal properties as they are used in mathematics...but how for instance, once you recognize that a certain thing is an initial or a final object, how do you exploit that?
11:02:29 <edwardk> shane_: if you give me a universal property i can usually transform that into a candidate definition
11:02:44 <shane_> say the products or products
11:03:12 <shane_> i meant or coproduct
11:03:17 <edwardk> lets do something like a kan-extension
11:03:52 <shane_> unfortunately, I am not familiar with that...my area of mathematics does not make very heavy use of category theory :)
11:04:27 <shane_> I am familiar with adjoints, yoneda's lemma, the universal properties
11:04:33 <shane_> to name a few of the concepts
11:05:02 <shane_> i have the book, Categories for the Working Mathematician, but I have never really gone too deep into it yet...I may need to in the near future though.
11:06:05 <shane_> if I could get a taste of how useful it would be in Haskell, I might be quite eager to explore it in more detail
11:06:14 <hackrilege> Did I miss the lemma!?
11:06:31 <magneticduck> if I instantiate a type as a monad, it also automatically becomes a functor right?
11:06:44 <edwardk> hackrilege: ($ id)  and flip fmap  are inverses
11:06:51 <cocreature> magneticduck: no
11:06:51 <magneticduck> I know the laws, just wondering if this is an automatic thing >_>
11:06:53 <magneticduck> darn
11:06:57 <edwardk> hackrilege: that is the pithy haskell-specific form =)
11:07:05 <mniip> magneticduck, no but it's easy to fix
11:07:06 <geekosaur> magneticduck, no, you must provide Functor and Applicative instances before defining the Monad instance
11:07:13 <mniip> instance Functor f where fmap = liftM
11:07:17 <Cale> Well, you can define them after as well
11:07:18 <geekosaur> (well, "before" --- has to be around somewhere)
11:07:21 <Cale> But you must provide them all
11:07:23 <mniip> instance Applicative f where pure = return; (<*>) = ap
11:07:29 <magneticduck> Cale: yeah that was my idea
11:07:43 <magneticduck> if I could just specify the monad and have TH or magical 'deriving' take care of functor and applicative
11:07:46 <mniip> geekosaur, errr what?
11:07:55 <mniip> order of instances doesn't matter
11:08:04 <geekosaur> that's why I repeated with "before" in quotes
11:08:38 <magneticduck> uhm
11:08:39 * geekosaur split attention, a bit slow
11:08:55 <magneticduck> okay so I want to have a data type that represents a parse result, either fail or success
11:09:01 <magneticduck> it would be great for that to be a monad and everything
11:09:07 <magneticduck> Either is the normal solution
11:09:14 <magneticduck> but either isn't a monad
11:09:16 <hackrilege> Edwardk ok thanks
11:09:18 <mniip> yes it is
11:09:19 <edwardk> shane_: if you write down the universal property of a product you get something like given objects X and Y you have an object X * Y with projections pi1 :: X * Y -> X  and pi2 :: X * Y -> Y such that given any other object Z and arrows f: Z -> X and g: Z -> Y, there exists a unique morphism h: Z -> X * Y such that f = pi1.h, g = pi2.h
11:09:23 <magneticduck> mniip: .. oh
11:09:27 <magneticduck> okay no problem then x)
11:09:45 <hackrilege> :t (flip fmap)
11:09:46 <lambdabot> Functor f => f a -> (a -> b) -> f b
11:10:05 <geekosaur> Either isn't a monad. (Either ParseError) or etc. could be
11:10:06 <edwardk> shane_: we can arrange that as forall z. (z -> x) -> (z -> y) -> (z -> x * y)
11:10:24 <hackrilege> I guess we take a = b in the above?
11:10:30 <magneticduck> > fmap (+1) $ Right 1
11:10:32 <lambdabot>  Right 2
11:10:34 <edwardk> now we can get forall z. (z -> x) -> (z -> y) -> z -> x * y    -- that looks like th signature of a data constructor
11:10:51 <edwardk> data Prod x y where Prod :: (z -> x) -> z -> y) -> z -> Prod x y
11:10:55 <edwardk> er.. data Prod x y where Prod :: (z -> x) -> (z -> y) -> z -> Prod x y
11:11:03 <magneticduck> > Left . (+1) . =<< Right 1
11:11:05 <lambdabot>  <hint>:1:15: parse error on input ‘=<<’
11:11:09 <magneticduck> > Left . (+1) =<< Right 1
11:11:11 <lambdabot>  Left 2
11:11:18 <magneticduck> geekosaur: muaha
11:11:31 <edwardk> pi1 (Prod f _ z) = pi1 (f z)
11:11:41 <edwardk> er = f z
11:11:50 <edwardk> pi2 (Prod _ g z) = g z
11:11:51 <edwardk> etc.
11:12:09 <edwardk> you can check the laws above, and the types force you to define the only sane thing
11:12:21 <edwardk> so we just read off the universal property of a product and built a (crappy) product
11:12:30 <edwardk> it does all the right things
11:12:33 <edwardk> it may be rather slow =)
11:13:01 <hackrilege> Magneticduck, while it is not automatic to derive applicative and Functor instances from a monad instance, since you can use the functions over monads in your applicative and Functor instances, they become trivial, and always the same, I think some have been given above
11:13:34 <edwardk> internally in GHC if you look at (a,b) it can either be a data constructor or it can be a thunk that will compute a and b when demanded. that thunk looks a lot like that thing we just constructed by reading off the category theory inspired definition as a type
11:14:49 <shane_> edwardk: the pair (a,b) is a product right?
11:15:19 <shane_> So what you defined just now should be isomorphic to the pair owing to the universal property?
11:15:55 <edwardk> shane_: yes
11:16:06 <edwardk> the next step would then be reducing one to the other and back, and showing they are isomorphic
11:16:48 <edwardk> you can similarly construct using the universal properties of coproducts something that looks like 'either' wrapped up as a data type.
11:16:49 <edwardk> :t either
11:16:50 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
11:16:59 <edwardk> rearrange it to get Either a b as the first argument
11:17:09 <edwardk> Either a b -> (a -> c) -> (b -> c) -> c
11:17:16 <edwardk> now move the quantifier over
11:17:27 <edwardk> Either a b -> forall c. (a -> c) -> (b -> c) -> c
11:17:41 <edwardk> runEither :: Either a b -> forall c. (a -> c) -> (b -> c) -> c
11:17:42 <edwardk> implies
11:18:04 <edwardk> newtype Either a b = Either { runEither :: forall c. (a -> c) -> (b -> c) -> c } -- would be a viable coproduct
11:18:09 <edwardk> in a church-encoded style
11:19:07 <edwardk> either is the universal property of a coproduct written down as a combinator. you still have to prove it is unique, etc.
11:19:14 <edwardk> but its a nice skeleton upon which to lay your proof
11:20:21 <ski> @quote Yoneda's.lemma
11:20:21 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment. Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
11:21:08 <shane_> edwardk: thanks I think I am beginning  to see what you are saying. But now that you know that Either is a product and that the pair is a cop-product, can you use that knowledge for something? Or was this an example of how one could similarly come up with abstractions like Either and Pairs when one translates definitions?
11:21:28 <shane_> Sorry I mean Either is a co-product nad pair is a product
11:21:52 <edwardk> shane_: well, in this case its boring. i was offering these up as an example because you went to the product/coproduct level
11:22:39 <edwardk> but when i start writing down more complex things like codensity or kan extensions, etc. having the ability to read off the universal property as a type and then transform it slowly using correctness preserving transformations into something more efficient is pretty much invaluable.
11:23:14 <navaati> hi
11:23:20 <edwardk> ski: just last year i helped erik meijer make the reactive framework a lot more efficient by judiciously applying the yoneda lemma =)
11:23:45 <edwardk> so it has real world enterprise applications =)
11:25:13 <navaati> it may be slightly offtopic, but I know you guys will know:
11:25:32 <shane_> edwardk: Right, I understand that this was only a simple example. So basically you take some universal property and translate it into a datatype?
11:25:42 <navaati> is void in C the same as haskell's Void, or as haskell's () ?
11:25:47 <edwardk> shane_: it is one of my favorite tricks
11:26:14 <edwardk> shane_: IIRC dolio first showed me how to do it for harder things.
11:27:00 <shane_> edwardk: out of curiosity, do you have some specific application in mind and choose the universal property to translate from, or do you take a universal property and just see what datatype it translates to and then see how to use it? Sorry, if the question is dumb
11:27:10 <aweinstock> navaati: ()
11:27:13 <geekosaur> navaati, it's conceptually closer to ()
11:28:02 <navaati> ah. then it's a shame that the C compiler doesn't let me have void as a union member, right :) ?
11:28:03 <geekosaur> Haskell's Void is a type with no inhabitants. C's (void) is a value to be ignored/thrown away, so maps to ()
11:28:03 <aweinstock> navaati: getChar :: IO (), void getchar()
11:28:44 <aweinstock> (all C functions are implicitly in IO)
11:29:07 <navaati> does C's void has inhabitants ? hehe just kidding (i hope)
11:29:42 <mniip> he just said that C's void has 1 inhabitant
11:29:45 <mniip> namely (void)0
11:30:08 <aweinstock> mniip: you can't do "void x = (void)0;" in C, can you?
11:30:53 <aweinstock> whereas in haskell, (let {x :: (); x = ()} in x) is valid
11:30:55 <navaati> aaaaah, now the "let's cast an unused variable to void" trick makes sense : it really *is* a cast, to the unique value in void !
11:31:29 <navaati> feels satisfying !
11:31:48 <edwardk> shane_: i have a penchant for stumbling through ncatlab looking for things i can express =)
11:32:03 <edwardk> shane_: then later on i tend to pair them up with problems i find
11:32:50 <navaati> still… the langage, who knows why, forbids you to have a variable containing this value, which feels unelegant, but well
11:33:10 <edwardk> :t let x = x in x
11:33:10 <aweinstock> navaati: I think Rust does treat () as a valid type/value, so you can do "fn foo() {}; fn main() { let x: () = foo(); }"
11:33:11 <lambdabot> t
11:33:19 <edwardk> even better
11:33:23 <navaati> (maybe C doesn't like the concept of zero-sized variable)
11:33:48 <Shockk> struct {}?
11:34:21 <navaati> aweinstock: yes, rust handles it quite properly (and indeed, I take this notion of zero-sized types from rust)
11:34:35 <monochrom> there is still a difference between zero-sized and no-possible-value
11:34:49 <Shockk> edwardk: do you know who the maintainer of containers is btw?
11:34:51 <navaati> edwardk: is there any _|_ in the semantic of C ?
11:34:59 <monochrom> because zero-sized = one-possible-value, not no-possible-value
11:35:11 <aweinstock> navaati: here's a writeup of ZST's in rust: http://cglab.ca/~abeinges/blah/rust-generics-and-collections/
11:35:15 <shane_> edwardk: I see. Interesting to know that you go through ncatlab for this purpose! While the examples you gave just now were about coming up with datatypes, do you also do things at the typeclass level, I mean like coming up with typeclasses for abstractions that were inspired by some category theoretic definition/theorem?
11:35:18 <broma0> is there a standard hashing library for haskell? I need to hash passwords before putting them in my DB
11:35:32 <dmj`> @package scrypt
11:35:32 <lambdabot> http://hackage.haskell.org/package/scrypt
11:35:34 <navaati> monochrom: yeah, sure. haskell's Void is… minus-infinite sized ^^
11:35:41 <monochrom> yeah :)
11:35:42 <aweinstock> navaati: among other things, it seems like rust optimizes Map<T, ()> to Set<T> automatically, using the ZST machinery
11:35:57 <dmj`> broma0: I'd use scrypt/bcrypt for that
11:35:58 <ski> edwardk :)
11:36:23 <aweinstock> :t absurt
11:36:25 <lambdabot>     Not in scope: ‘absurt’
11:36:25 <lambdabot>     Perhaps you meant ‘assert’ (imported from Control.Exception)
11:36:28 <aweinstock> :t absurd
11:36:29 <broma0> dmj`: thank you!
11:36:30 <lambdabot> Not in scope: ‘absurd’
11:36:33 <navaati> aweinstock: i wonder if GHC optimizes (a, ()) to a, or Either a () to Maybe a…
11:36:34 <shane_> edwardk: Sorry, I got logged out for a moment. While the examples you gave just now were about coming up with datatypes, do you also do things at the typeclass level, I mean like coming up with typeclasses for abstractions that were inspired by some category theoretic definition/theorem?
11:36:39 <aweinstock> :t Data.Void.absurd
11:36:40 <lambdabot> Data.Void.Void -> a
11:37:46 <ski> navaati : iirc, `struct {}' and `int[0]' are not allowed
11:37:54 <ski> edwardk : which reactive thing is this ?
11:38:06 * hackagebot propellor 2.8.0 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.8.0 (JoeyHess)
11:38:08 * hackagebot hapistrano 0.2.1 - A deployment library for Haskell applications  https://hackage.haskell.org/package/hapistrano-0.2.1 (jpvillaisaza)
11:38:13 <edwardk> ski: the .net reactive framework
11:38:19 <ski> @djinn Void -> a
11:38:19 <lambdabot> f = void
11:38:35 <delYsid> ah, new propellor!
11:38:37 <aweinstock> ski: I seem to remember seeing "char []" used for variable-sized (possibly 0) padding in C structs
11:38:55 <edwardk> shane_: sure. http://hackage.haskell.org/package/contravariant-1.3.3/docs/Data-Functor-Contravariant-Divisible.html was basically obtained by reading off day convolution
11:39:00 <ski> navaati : "i wonder if GHC optimizes ..." .. bottoms complicate stuff
11:39:33 <Shockk> navaati: I don't know if that'd be the case, because iirc one of the differences between data and newtype is that a new data type created with newtype uses the same kind of storage as its one field or something and that a new bottom of that type isn't created or something like that
11:39:39 <aweinstock> :t Left undefined :: Either () Int
11:39:40 <lambdabot> Either () Int
11:39:44 <Shockk> navaati: (,) is created with data and not newtype
11:39:44 <navaati> well, anyway, I wanted to have a tagged union (in C) with branches without fields explicitely having a void in the union, and i can't
11:39:56 <navaati> C is so… clumsy…
11:40:04 <Shockk> I have no idea really though
11:40:15 <navaati> ski: ah, you're right, that's the big difference between haskell and rust
11:40:18 <aweinstock> > case Left undefined of {Left () -> 0, Right () -> 1}
11:40:19 <ski> navaati : "is there any _|_ in the semantic of C ?" -- yes, but you don't need to include it in the denotation of types (except ones including function pointers), because of strictness
11:40:19 <lambdabot>  <hint>:1:37: parse error on input ‘,’
11:40:25 <aweinstock> > case Left undefined of {Left () -> 0; Right () -> 1}
11:40:26 <lambdabot>  *Exception: Prelude.undefined
11:41:04 <navaati> ski: "except ones including function pointers" goddamn, tell me more !
11:41:44 <Shockk> "don't need to include it in the denotation of types"
11:41:49 <Shockk> I read that as detonation"
11:42:14 <EvanR> C4 has a detonation
11:42:58 <shane_> edwardk: thanks a lot for your help and explanations! I will take a look at some of the things you suggested. After reading one of your responses on stackoverflow, I realized that you were *the* person  I wanted to ask the kind of questions I had! Thanks for taking the time to answer them :)
11:43:02 <navaati> boom go your types ! (also called unsafeCoerce)
11:43:33 <ski> aweinstock : see <https://gcc.gnu.org/onlinedocs/gcc-5.2.0/gcc/Zero-Length.html>,<https://gcc.gnu.org/onlinedocs/gcc-5.2.0/gcc/Empty-Structures.html>
11:43:36 <edwardk> no problem!
11:44:26 <ski> navaati : well, obviously calling a function might cause non-termination
11:44:46 <lpaste> bldzrr pasted “Compute maximum template arity in derivation?” at http://lpaste.net/8296073981874667520
11:46:57 <navaati> mmh… right, thanks for your insights everyone !
11:47:06 <EvanR> how can C have denotational semantics
11:47:38 <joeyh> delYsid: with contributions from you 4 others in this release!
11:48:17 <navaati> EvanR: well the denotational semantic is very close to the operationnal one, making it not so usefull I guess. aka, C provides no (or few) abstraction.
11:48:36 <navaati> (but maybe i say garbage…)
11:50:23 <bldzrr> is anyone able to help with this? http://lpaste.net/8296073981874667520
11:50:29 <bldzrr> I'm not sure where to start
11:51:23 <dolio> Worst case scenario, you can always have a trivial denotational semantics where the model is just the syntax.
11:52:02 <monochrom> Shockk: you may like https://www.mail-archive.com/haskell-cafe@haskell.org/msg86241.html
11:57:49 <EvanR> "this means nothing."
11:58:37 <monochrom> bldzrr: if the question is really "how to code up derivationFoldR", this is a pretty abstract and advanced question. you have to had seen many other examples of foldr-like functions for many other data types before you see the picture.
11:58:52 <monochrom> to start with, have you seen the foldr for lists?
11:58:54 <nitrix> Hi, is there such thing as withMaybe? I have one specific `case x of Just c -> ...  Nothing -> return ()` that is annoying me.
11:59:29 <Fuuzetsu> :t fromMaybe
11:59:30 <lambdabot> a -> Maybe a -> a
11:59:34 <nitrix> Since it returns an `IO ()` for both cases, I figured I must be missing on something.
11:59:36 <monochrom> there are fromMaybe and maybe
11:59:39 <monochrom> @type maybe
11:59:40 <lambdabot> b -> (a -> b) -> Maybe a -> b
11:59:45 <dolio> EvanR: No, it means the words you wrote. :)
11:59:53 <bldzrr> monochrom : yes I have
12:00:04 <EvanR> dolio: right, and this works for both C and Haskell and anything
12:00:16 <dolio> Yes.
12:00:17 <EvanR> and is somehow not satisfying, but maybe it should be
12:01:21 <dolio> Well, I don't think it should be, but it shows that worrying about whether you can have a denotational semantics is not sufficient.
12:01:40 <EvanR> youre the best denotation youve ever had
12:01:40 <dolio> Because the answer is trivially, "yes," you can have a useless one.
12:01:58 <Shockk> monochrom: 
12:02:01 <Shockk> detonational semantics:
12:02:01 <Shockk>    what does this button do?
12:02:02 <Shockk> hahaha
12:02:06 <monochrom> yeah :)
12:02:28 <Shockk> this is great
12:03:23 <Shockk> musical semantics :D
12:04:47 <EvanR> many of those come up a lot IRL
12:05:00 <EvanR> especially detonational
12:06:52 <Shockk> if I'm understanding the semantics thing correctly, I've had a few zen semantics moments with Haskell
12:07:00 <Shockk> like when I finally understand monads
12:07:45 <shachaf> I think that, almost universally, when someone has said "ah! i finally understand monads! what a zen moment!", they've been wrong.
12:08:02 <EvanR> nobody understands monads --feynmann
12:08:05 <trolling> they really are just monoids in the category of endofunctors!
12:09:10 <Shockk> well I still don't fully understand them because I don't understand the bigger picture behind them, I just had a zen moment of understanding how to use >>= and how do syntax works
12:11:07 <EvanR> how about undo notation for comonads
12:11:19 <sinelaw> +1
12:11:25 <Shockk> EvanR: I- what
12:11:48 <cocreature> ah so that's what lambdabots @undo really means :P
12:11:52 <Shockk> based on what I'm picturing a comonad to be like in my head, and the name `undo'
12:11:57 <Shockk> I can imagine what it might do
12:12:12 <EvanR> ehem what it undoes
12:13:08 * hackagebot GPipe 2.1 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.1 (TobiasBexelius)
12:23:10 <ski> EvanR : yes, i believe that's thinking more in the right direction
12:24:20 <EvanR> in response to what
12:26:07 <ski> <EvanR> how about undo notation for comonads
12:26:16 <ski> EvanR : "how can C have denotational semantics" -- well, i'm thinking of something like what is vaguely indicated at <http://blog.regehr.org/archives/161>
12:28:28 <lpaste> aweinstock pasted “Can this be made more efficient?” at http://lpaste.net/141571
12:29:33 <aweinstock> I know I'm asking for exponential-length output, I'm wondering if I'm producing it right such that a filter over it will run in constant space
12:30:01 <aweinstock> (context is brute-force tools for CTFs)
12:30:39 <ski> aweinstock : `pred' and `succ' will not error out the least respectively the greatest element. similarly `enumFrom' won't stop at `Z', &c.
12:31:13 <ski>   mapM_ putStrLn . (map . map) getUA  =  mapM_ (putStrLn . map getUA)
12:32:05 <aweinstock> ski: I tested it locally in GHCI, and it looked like it did the right thing
12:32:39 <aweinstock> *Main> map getUA [minBound..maxBound]
12:32:39 <aweinstock> "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
12:33:09 * hackagebot pandoc-types 1.12.4.7 - Types for representing a structured document  https://hackage.haskell.org/package/pandoc-types-1.12.4.7 (JohnMacFarlane)
12:33:11 <EvanR> ski: 2010 was fermats last theorem proven at that point
12:34:25 <chpatrick> aweinstock: isn't that just replicateM?
12:34:28 <ski> > replicateM 2 "abc"  -- aweinstock, did you try this ?
12:34:30 <lambdabot>  ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
12:34:33 <chpatrick> ^
12:34:41 <aweinstock> ski: oh, I see what you mean (it only works there because that desugars to enumFromTo)
12:34:54 <ski> yes
12:35:49 <aweinstock> chpatrick: thanks
12:36:09 <aweinstock> chpatrick: does that run in constant space though?
12:36:21 <ski> (aweinstock : also, if you put this in a non-main module, obviously don't export the data constructor)
12:36:35 <chpatrick> can't see why it wouldn't
12:37:04 <arkeet> aweinstock: yeah you'd need to write a different Enum instance too.
12:38:35 <chpatrick> I think it's even list fused...
12:41:32 <lpaste> monochrom annotated “Compute maximum template arity in derivation?” with “examples of foldr-like functions” at http://lpaste.net/8296073981874667520#a8428573246214897664
12:41:53 <monochrom> bldzrr: http://lpaste.net/8296073981874667520#a8428573246214897664
12:42:26 <aweinstock> I ran "ghc -O2" on a file containing `main = mapM_ putStrLn . filter (=="COOKIE") $ replicateM 6 ['A'..'Z']`, according to top(1), it's using 1.7GB of memory
12:43:09 * hackagebot GPipe-GLFW 1.1 - GLFW OpenGL context creation for GPipe  https://hackage.haskell.org/package/GPipe-GLFW-1.1 (plredmond)
12:45:14 * ski remembers writing a version of `combinationsWithoutReplacementTo' in C, using `goto' into and out of a `for', reverse-engineered from a flowchart
12:46:35 <aweinstock> ski: did it call a function pointer on a local buffer at each iteration? mallocing the whole thing doesn't sound possible
12:47:49 <EvanR> ski: that post is interesting, it assigns a meaning to C programs. but it does not do it by using the meaning of any subprogram
12:49:09 <monochrom> shachaf: when one thinks "ah! now I understand", they are at the same time universally right and universally wrong
12:49:17 <aweinstock> how do I write permutationsWithReplacementTo in a manner that fuses nicely / has constant space when iterating over?
12:49:26 <monochrom> they are right because they understand a bit more
12:49:44 <monochrom> they are wrong because there are still an infinite amount they haven't understood
12:56:40 <ski> aweinstock : see "ordered selection (combinations), Prolog solution, from 2012-12-16" at <http://lpaste.net/117380>
12:56:57 <ski> (note that the latter part of the Prolog version is commented out. it's just for comparision)
12:57:02 <ski> (s/part/half/)
12:58:03 <ski> aweinstock : so, it called a function pointer (instead of manually inlining the body)
12:58:41 <deech> Hi all, haskell-mode on Emacs will occasionally stop me from hitting "Enter" with an "Illegal token" message. Has anyone else experienced this?
13:00:42 <sinelaw> deech, yes, happens to me too. don't know the solution, for now my workaround is to disable haskell-indentation-mode when that happens
13:01:15 <deech> sinelaw: Yes I had to do that too. Painful.
13:01:17 <bitemyapp> deech: haskell-indentation-mode has been hinky like this on and off for awhile. Dunno why.
13:01:29 <bitemyapp> deech: I complained about the instability to the haskell-mode maintainer, fell on deaf ears.
13:01:39 <bitemyapp> deech: getting really close to vendoring and stripping it down again.
13:01:59 * sinelaw gives bitemyapp a very gentle shove
13:02:00 <bitemyapp> particularly since I'd rather the stack-mode stuff handle IDE'ish things.
13:02:09 <ReinH> bitemyapp: hey! You use reflex and reflex-dom right?
13:02:24 <bitemyapp> ReinH: hey! I haven't done frontend in a century. So no.
13:02:30 <ReinH> wah wah
13:02:36 <bitemyapp> ReinH: I did however steal some things from it
13:02:40 <ski> aweinstock : it basically implements "Power Loops", as in (page 49) section 4 of chapter 2 of the book :
13:02:40 <ReinH> trying to figure out how to get started
13:02:41 <bitemyapp> like these
13:02:43 <ski> @where APLD
13:02:43 <lambdabot> "Advanced Programming Language Design" by Raphael Finkel in 1996 at <http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/>
13:02:43 <deech> So is haskell-indent-mode better?
13:02:44 <bitemyapp> these are great
13:02:57 <ReinH> these?
13:03:01 <bitemyapp> yep, these.
13:03:05 <bitemyapp> cmccann: care to introduce these?
13:03:13 <ski> (the chapters seem to be missing from that link now. try <https://web.archive.org/web/20150504131137/http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/>)
13:03:13 <ReinH> Oh you mean the package
13:03:13 <bitemyapp> deech: a good sanity check is to look at my dotfiles. I keep them working at all times.
13:03:18 <ReinH> Right. Am familiar.
13:03:25 <ReinH> I thought "these" was a preface to a list of things you stole. :)
13:03:28 <bitemyapp> deech: shared across 9-5 and at-home working machines https://github.com/bitemyapp/dotfiles
13:03:51 <ski> chapter 3, "Continuations : Io", of that book is also interesting
13:03:54 <bitemyapp> ReinH: yeah face-planting into highly developed code like that can be rough. I probably can't offer better than the todo-list example.
13:04:05 <ski> see
13:04:06 <ski> @where Io
13:04:06 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede' - (perhaps you were looking for `@wiki Introduction to IO' ?)
13:04:08 <ReinH> bitemyapp: I would like a todo-list example.
13:04:23 <cocreature> ReinH: https://github.com/ryantrinkle/reflex-todomvc/
13:04:27 <ReinH> tyty
13:05:39 <bitemyapp> ReinH: https://github.com/unisonweb/platform
13:05:47 <bitemyapp> ReinH: https://github.com/reflex-frp/reflex-dom-contrib
13:06:08 <bitemyapp> ReinH: https://github.com/int-index/kalium
13:06:15 <ReinH> bitemyapp: <3
13:06:16 <bitemyapp> ReinH: https://github.com/Saulzar/squares
13:06:24 <ski> (er s/chapter 3/section 3 of chapter 2/)
13:06:25 <bitemyapp> ReinH: https://github.com/0not/rpn_calc
13:06:37 <bitemyapp> ReinH: https://github.com/imalsogreg/collabplot
13:06:46 <bitemyapp> ReinH: https://github.com/osener/markup.rocks
13:07:08 <bitemyapp> ReinH: https://github.com/martin-kolinek/some-board-game
13:07:23 <bitemyapp> ReinH: https://github.com/z0isch/ten-twenty-five
13:07:32 <frerich> Please...
13:07:40 <sinelaw> this can go on for a while
13:07:46 <bitemyapp> ReinH: https://github.com/Saulzar/reflex-examples/blob/master/Free.hs
13:07:55 <bitemyapp> I'm done
13:08:08 <nitrix> Hey guys, how would you write this?
13:08:10 <nitrix> Found hole ‘_’ with type: Maybe [B.ByteString] -> Maybe String
13:08:19 <nitrix> Is this a use case for applicatives?
13:08:48 <sinelaw> fmap (B.pack . B.concat)
13:08:51 <sinelaw> or so
13:09:09 <clrnd> mmm quick question, I have a function `something :: Blah -> [Vector a]` which has a where-clause with something of type `loop :: [Vector a]`
13:09:10 <nitrix> sinelaw: I want the behavior to be like listToMaybe
13:09:13 <clrnd> if I include loop's type signature, it complains, otherwise not
13:09:23 <clrnd> I kind of understand why, they are the same a, but no idea how to say that in types, maybe I can't?
13:09:27 <nitrix> sinelaw: But then it gets super confusing because I have `Maybe (Maybe ...)`
13:09:40 <sinelaw> nitrix, use "join"
13:09:44 <ReinH> use =<<
13:09:49 <ReinH> That's what it's for.
13:10:00 <ReinH> You have a Maybe a and a function a -> Maybe b
13:10:03 <bitemyapp> I've caught myself writing join (fmap ...) before.
13:10:11 <ReinH> :t (=<<)
13:10:12 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:10:45 <monochrom> clrnd: use the extension ScopedTypeVariables, and add a "forall" to something's type: "something :: forall a. Blah -> [Vector a]"
13:10:45 <ReinH> or (>>=), whichever you prefer. I prefer to think of it as function application when I am not using do notation so I generally use =<<.
13:11:12 <monochrom> this tells the compiler that "a" now means the same "a" as "that a"
13:11:23 <nkaretnikov_> yo, is there a version of flip fmap that's in base?  i'm aware of <&> from lens, etc.  i could probably use forM, but that'd require accounting for the fact that it requires to lift the result
13:11:38 <sinelaw> has anyone here used unification-fd to implement type inference?
13:11:46 <clrnd> monochrom, ok, why forall?
13:12:06 <ReinH> nkaretnikov_: You can just define (<&>) = flip (<$>) without incurring a lens dependency.
13:12:10 <clrnd> (I have to admit, I tried using RankNTypes and forall with no idea of what I was doing, didn't work ofc)
13:12:33 <bitemyapp> one minute you're importing <&> from Control.Lens
13:12:40 <geekosaur> it used forall because that syntax was already stolen
13:12:42 <bitemyapp> next thing you know, you're selling your couch for more profunctors
13:12:50 <monochrom> because "forall a" is a convenient syntax
13:12:51 <geekosaur> but it's kinda 'backwards' from what forall normally means
13:12:52 <bitemyapp> you haven't showered in two weeks
13:13:05 <bitemyapp> you're itching yourself and asking people, "buddy, can you spare a kan extension?"
13:13:13 <ReinH> I mean, the probability of your project incurring a lens dependency approaches 1
13:13:13 <clrnd> geekosaur, oh I see, that makes sense
13:13:16 <clrnd> :P
13:13:17 <monochrom> yeah, basically "may as well overload that syntax"
13:13:30 <ski> clrnd : because `ScopedTypeVariables' is a bit silly like that
13:13:34 <ReinH> monochrom: heh, but there's a format justification for... yeah, pretty much.
13:13:50 <clrnd> ski, that must be the best answer just ever
13:13:52 <clrnd> thanks everyone
13:14:07 <sinelaw> should be "forthose" in this case :)
13:14:34 <deech> bitemyapp: Thanks!
13:15:02 <nkaretnikov_> ReinH: noooo
13:15:09 <nitrix> So, using holes, I ended up with: B.unpack <$> (mOther msg >>= listToMaybe)
13:15:10 <nkaretnikov_> ReinH: i'd rather import lens
13:15:16 <nitrix> I'm sure this can be made prettier :/
13:15:18 <ski> something like `forall a. {something :: Blah -> [Vector a]; something = ..a..}' would make more sense, imho
13:15:21 <nkaretnikov_> nih is evil
13:15:32 <bitemyapp> deech: yarp
13:15:51 <bitemyapp> deech: I'm (relatively?) conservative about my setup. "just works" across Mac & Linux are a priority.
13:16:13 <sinelaw> ugh, why is the Io paper paywalled? it's from 1989
13:16:16 <ski> @tell clrnd it used to be you could bring `a' into scope with `PatternSignatures', which i preferred
13:16:16 <lambdabot> Consider it noted.
13:16:25 <bitemyapp> sinelaw: which?
13:16:38 <drewbert> If I do `count <$> words <$> readFile "largeFile.txt"` Is there a time when the whole file is read into memory, or does lazy io cause the count to tally up as the large file is read in chunks?
13:16:38 <sinelaw> @where Io
13:16:38 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede' - (perhaps you were looking for `@wiki Introduction to IO' ?)
13:18:23 <Welkin> Io is a planet!
13:18:31 <Welkin> more precisely, a moon!
13:21:47 <ski> @where Amalthea
13:21:47 <lambdabot> Implementation made by Martin Sandin of the (continuation-based) `Io' language at <http://web.archive.org/web/20091106041222/http://www.guldheden.com/~sandin/amalthea.html>
13:21:53 <ski> @where Ganymede
13:21:53 <lambdabot> Implementation by BMeph of the (continuation-based) `Io' language at <http://hackage.haskell.org/package/Ganymede>
13:22:12 <Welkin> haha
13:22:14 <Welkin> Ganymede
13:22:23 <Welkin> I like all the references to moons of the gas giants
13:24:01 <sinelaw> what exactly does "metavariable" mean in the context of types?
13:24:06 <EvanR> some moons are bigger than planets which is annoying
13:24:11 <ski> sinelaw : i thought i had it somewhere, but i can't find it atm. perhaps try asking BMeph ?
13:24:33 <mniip> EvanR, and asteroids are supposed to be star-like
13:24:40 <sinelaw> in "forall a. a -> a" - is "a" a type variables or a metavariable?
13:24:41 <ski> well, if you can get hold of them, i.e. .. seems they were last active on IRC in late June
13:24:49 <ski> sinelaw : `a' is a type variable there
13:25:10 <sinelaw> and when it's not qualified? i.e. free
13:25:11 <ski> meta/logic/dataflow variables are used during the process of type inference
13:25:37 <ski> sinelaw : in `length :: [a] -> Int', `a' is still a type variable
13:25:51 <ski> you don't see metavariables in Haskell code
13:25:56 <sinelaw> I've been doing inference for a while, and didn't see why it's "meta". is there an accepted definition?
13:26:02 <sinelaw> ski, sure, during inference I mean
13:26:15 <ski> you might perhaps see them in type errors (and possibly in inferred types, depending)
13:26:16 <bldzrr> I'm still not able to complete this derivationFoldR function. http://lpaste.net/8296073981874667520#a8296073981874667520
13:26:49 <bldzrr> I understand it's purpose and how to use foldr
13:26:50 <sinelaw> ski, are they the ones we allocate ("fresh") when entering lambda, etc.?
13:27:57 <ski> sinelaw : metavariables (aka placeholders) are used in place of types which we haven't figured out yet. a metavariable might later become instantiated to a type like `Int', or a type variable like `a', or something involving type variables, like `a -> [b]'
13:28:22 <ski> not sure what you mean by "allocate (\"fresh\") when entering lambda, etc."
13:29:14 <ski> if you mean when inferring the type of `\x -> E', by adding `x' with an unknown type to the type environment, and then infer the type of `E', then yes
13:29:17 <sinelaw> ski, in HM you might assign a new type variable to the lambda's argument, and later unify it with something
13:29:24 <sinelaw> ok, yeah
13:29:53 <sinelaw> so when does it become a type variable per se?
13:30:05 <rhovland> getting some error about "expecting one more argument to DSum Config" when trying to compile lambdabot for the past few days... look familiar to anyone?
13:30:22 <ski> when generalizing. *if* it becomes a type variable at all
13:30:30 <sinelaw> if it is replaced with a quantified variable
13:30:31 <sinelaw> ok
13:31:03 <ski> (if it has earlier been instantiated, it doesn't become a type variable. only uninstantiated metavars (not occuring in the context) get generalized to tyvars)
13:32:05 <ski> in OCaml, the interactor can sometimes leave uninstantiated metavars in the inferred types of defined values
13:32:08 <sinelaw> but not being generalized is the same as being generalized and then instantiated but not resolved to any particular type
13:33:31 <ski> (namely, in cases where it doesn't generalize, since always generalizing in those cases, will sometimes lead to type inconsistency (you can implement `unsafeCoerce'), due to the presence of side-effects (specifically mutable, element-type-parametric, reference types))
13:33:52 <ski> sinelaw : yes
13:34:37 <ski> (as long as the intermediate generalized form isn't used otherwise)
13:34:44 <sinelaw> ok. I'm playing around with unification-fd and was trying to understand what they meant by metavars 
13:35:49 <ski> sinelaw : being familiar with Logic Programming (specifically unification and logic variables), help here
13:36:44 <ski> sinelaw : mayhaps "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995-03 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/typeinf.p(s|df)> would also be of some interest
13:38:06 <dustin_> what's the correct way to install ghc/cabal/etc. on ubuntu?
13:38:16 <dustin_> i did apt-get install cabal-install ghc 
13:38:29 <dustin_> but i'm noticing problems trying to install HStringTemplate
13:39:38 <geekosaur> ubuntu has an ancient ghc
13:39:48 <dustin_> aha
13:39:59 <dustin_> ppa?
13:40:18 <monochrom> there is no "the". there are a handful.
13:40:27 <geekosaur> sudo apt-add-repository ppa:hvr/gcc
13:40:31 <geekosaur> er
13:40:32 <dustin_> i think i did hvr/ghc before
13:40:34 <geekosaur> sudo apt-add-repository ppa:hvr/ghc
13:40:36 <dustin_> now that i google that
13:41:10 <monochrom> hvr's repos is correct. ghc's website is correct. haskell platform website's is correct. stack is correct.
13:41:51 <monochrom> and yet each of them is also wrong
13:41:52 <geekosaur> it weill be the ghc-7.10.2 package (hvr's ppa supports multiple ghc versions)
13:42:12 <monochrom> oh, darn, then hvr's is not wrong
13:42:59 <geekosaur> then either install stack from https://stackage.org or the cabal-install bindist from https://www.haskell.org/cabal/release/cabal-install-1.22.0.0/cabal-1.22.0.0-i386-unknown-linux.tar.gz
13:43:00 <bitemyapp> @where learnhaskell
13:43:00 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:43:15 <bitemyapp> dustin_: I'd say hvr's repos or Stack.
13:43:39 <dustin_> .cabal is the only directory where stuff gets stored if --global isn't used, right?
13:43:43 <geekosaur> (stack is a little different from cabal, and can also manage its own ghc installations so you might skip hvr's repo and let stack do it)
13:43:48 <geekosaur> .cabal and .ghc
13:43:52 <geekosaur> dustin_ ^^
13:44:23 <geekosaur> specifically cabal-install writes its libraries and state to ~/.cabal but it registers packages with ghc which writes to ~/.ghc
13:44:34 <dustin_> ok
13:44:39 <geekosaur> just removing ~/.cabal will leave broken packages registered with ghc
13:44:39 <dustin_> trying to install taffybar, always a little annoying
13:47:00 <sinelaw> ski, what do they mean by "weighted" path compression? in unification-fd
13:47:22 <sinelaw> is that the same as what ocaml does with levels/regions?
13:48:13 * hackagebot chatter 0.5.2.1 - A library of simple NLP algorithms.  https://hackage.haskell.org/package/chatter-0.5.2.1 (RoganCreswick)
13:48:46 <sinelaw> doesn't seem to be
13:49:48 <sinelaw> ah, there's a hint: > a "rank" which is related to the length of the variable chain to the term it's ultimately bound to.
13:50:14 <cmccann> bitemyapp: the primary design principle of these is to make statements about the library sound confusing, as you demonstrated with ReinH 
13:50:39 <cmccann> how's that for an introduction
13:52:06 <bitemyapp> cmccann: we are of like mind in the usefulness of these then
13:52:44 <ew0> hi
13:52:52 <dmj`> hi
13:52:57 <ew0> I want to make a sum of 2 fgl graphs
13:53:02 <ew0> is there an easy way to do it?
13:53:09 <Welkin> dmj` says hi to random people
13:53:21 <bitemyapp> dmj`: hi
13:53:26 <bitemyapp> ew0: hi
13:53:33 <Welkin> hi
13:53:34 <bitemyapp> ew0: sum?
13:53:38 <Welkin> oh, it is not a script
13:53:49 <cmccann> bitemyapp: did you know that someone actually uses ChronicleT from these? I was amazed.
13:53:57 <ew0> I just want to put them together in the same graph
13:54:05 <ew0> with all nodes disjointed
13:54:12 <johnw> cmccann: hello!
13:54:16 <monochrom> I am a script.
13:54:18 <ew0> xD
13:54:20 <dmj`> bitemyapp: hi
13:54:48 <cmccann> johnw: is continuing theme of greetings, a specific greeting, or a claim of using ChronicleT in practice
13:54:51 <cmccann> I can't tell from context
13:55:08 <johnw> cmccann: just saying hi, since I've only spoken with you on GitHub lately
13:55:15 <cmccann> also I think I missed a few words in that sentence
13:55:23 <cmccann> ok so #2 then :]
13:55:59 <johnw> despite helping to maintain these, I'd never even heard of ChronicleT :)
13:56:04 <cmccann> hahahahaha
13:56:30 * mniip has heard of ChronicleT but has no idea what it is
13:56:37 <cmccann> I put a lot of work into that module, making the names as silly as possible while still plausible enough to use.
13:56:49 <ski> sinelaw : hm. possibly you can ask edwardk to elaborate on that
13:57:14 <cmccann> mniip: http://hackage.haskell.org/package/these-0.4.2/docs/Control-Monad-Chronicle.html
13:57:36 <mniip> ah right
13:57:39 <mniip> the These thingy
13:57:53 <cmccann> yes
13:57:59 <cmccann> still more useful than Bicrosswalk though
13:58:42 <drewbert> I just got a FP job!
13:58:51 <Welkin> drewbert: what does that mean?
13:58:58 <Welkin> drewbert: FP Complete?
13:59:03 <drewbert> a job performing functional programming
13:59:08 <Welkin> Haskell?
13:59:21 <mniip> dreamdust, good for you ಠ-ಠ
13:59:27 <drewbert> unfortunately, no, scala, sorry I was just excited.
13:59:32 <johnw> drewbert: nice!
13:59:38 <cmccann> johnw: btw, since you presumably know a bit more than I do about hackage uploading, do you have any idea why these-0.6 still has no docs or builds?
13:59:49 <sinelaw> mniip, you mean drewbert maybe
13:59:57 <mniip> er yes
13:59:59 <mniip> drewbert, *
14:00:23 <drewbert> mniip: haha, what's with the angry eyes?
14:00:38 <cmccann> johnw: I've poked it a few times with trivial revisions to dep bounds, clicking the "delete docs and force rebuild" button, etc., still nothing. but other packages uploaded more recently have docs.
14:00:39 <dolio> sinelaw: It's like union-find, I think, if you're familiar with that.
14:00:39 <johnw> cmccann: that's usually a crash in hscolour, or some other doc generation bug; or it could be a Hackage bug
14:00:46 <johnw> cmccann: there's an option to upload the docs yourself directly
14:00:53 <cmccann> yeah, I need to do that at some point
14:00:56 <sinelaw> dolio, except for the weighting
14:01:03 <Welkin> drewbert: it is a military jeep with no doors
14:01:04 <cmccann> I just wish I knew why it wasn't building
14:01:24 <bitemyapp> cmccann: wow.
14:01:30 <sinelaw> dolio, but I guess I'll just look it up now!
14:01:35 <drewbert> Welkin: an analogy for side-effect free programming no doubt
14:02:10 <johnw> cmccann: the documentation build log looks fine; I'd mention this to dcoutts when you see him next
14:02:40 <cmccann> johnw: would a crash in hscolour or such prevent it from even showing an attempted build, though?
14:03:01 <johnw> cmccann: I'd expect the memory exhaustion failure from that bug to appear in the log
14:03:08 <cmccann> if there were cryptic build failures that'd be, y'know, welcome to the world of software engineering etc.
14:03:19 <cmccann> the total absence is what confuses me
14:03:20 <bitemyapp> cmccann: I only found this: https://github.com/gelisam/hawk/issues/151
14:03:22 <geekosaur> they were having buildbot issues last I heard, although I'd stopped following
14:03:25 <johnw> your log clearly says "Documentation created: dist/doc/html/these/index.html"
14:03:55 <dolio> sinelaw: I think the weight has to do with how long the largest chain of references is to a variable.
14:04:10 <cmccann> bitemyapp: ...aww, I like my names :[ 
14:04:16 <sinelaw> dolio, yes, it seems to be used to build better union graphs
14:04:19 <cmccann> johnw: that's weird
14:05:04 <dolio> You're trying to avoid making that longer when you unify two variables.
14:05:04 <johnw> it is
14:05:37 <dolio> So you point the variable with the shorter chain at the one with the longer one.
14:05:49 <dolio> If I recall correctly.
14:06:51 <bz> idk why i ever expected cabal to permit fine grained c compilation params
14:06:59 <dolio> And if you do everything correctly, somehow that leads to alpha in your asymptotics, for reasons I don't understand.
14:07:25 <lpaste> bldzrr pasted “Compute maximum template arity in derivation?” at http://lpaste.net/7956945627630272512
14:08:52 <edwardk> sinelaw: it is the standard trick used to take union-find to the alpha(n) time per step bound
14:09:09 <edwardk> sinelaw: IIRC though unification-fd gets it wrong
14:09:36 <edwardk> it increases the rank _way_ too often
14:09:40 <edwardk> in ermine we get it right
14:10:36 <sinelaw> edwardk, ok, I was hoping it had to do with variable liveness as in ocaml (levels, regions whatver they're called) that can be used to make generalization quicker
14:10:45 <edwardk> we use that too
14:10:50 <edwardk> but its a separate optimization
14:10:50 <edwardk> =)
14:10:54 <sinelaw> edwardk, yup
14:11:03 <sinelaw> you don't have a generic unification lib, do you? :)
14:11:39 <edwardk> https://github.com/ekmett/ermine/blob/master/src/Ermine/Unification/Meta.hs#L124  has a fairly general 'meta-variable' notion we use for kinds, types, etc.
14:11:50 <bitemyapp> cmccann: just wondering whom you saw using ChronicleT
14:11:59 <sinelaw> edwardk, ooh, thanks
14:12:07 <edwardk> there what we call depth is the kuan and macqueen lambda-rank
14:12:13 <edwardk> what we call rank is the rank in union-find terms
14:12:16 <sinelaw> zonking! yip
14:12:27 <cmccann> bitemyapp: see here: https://github.com/isomorphism/these/issues/35
14:12:28 <sinelaw> (kidding)
14:12:41 <edwardk> sinelaw: https://github.com/ekmett/unification is simpler but is missing the fancy bits
14:13:00 <bitemyapp> cmccann: cringing at the Default
14:13:04 <edwardk> zonk was IIRC named by simon marlow "for the sound it makes"
14:13:30 <edwardk> i believe that that was how sclv said he explained the naming
14:13:53 <cmccann> edwardk: seems like a reasonable explanation to me
14:13:58 <edwardk> =)
14:14:26 <sinelaw> edwardk, does ermine avoid the expensive occurs?
14:14:36 <edwardk> anyways http://people.cs.uchicago.edu/~gkuan/pubs/ml07-km.pdf is the origin of the ocaml levels idea IIRC
14:14:45 <edwardk> sinelaw: 'sometimes'
14:15:13 <sinelaw> edwardk, not according to Oleg http://okmij.org/ftp/ML/generalization.html
14:15:15 <cmccann> personally, I enjoy the fact that GHC's source is full of things like "zonking" and comments to the effect of "if anyone wants to figure out this corner case there's probably a PhD thesis in it"
14:15:33 <edwardk> sinelaw: we can get away with watched variables in some situations, but we have a couple of situations where we had to fall back on the occurs check style
14:16:04 <sinelaw> edwardk, "OCaml's generalization is a (partial) implementation of the algorithm discovered by Didier Rmy back in 1988"
14:16:13 <edwardk> sinelaw: ah, that was the one for sml/nj
14:16:14 <edwardk> yeah
14:16:21 <edwardk> its one of those ideas that keeps popping up
14:17:04 <edwardk> dolio came up with it 'from scratch' at one point in writing our type checker, and then we found it in code by daan leijen for HMF
14:17:35 <aphocus> I've noticed you can automatically make lenses like _name -> name for a record, is there a way to do name -> _name instead?
14:17:39 <sinelaw> edwardk, for the occurs, i want to allow recursives sometimes (e.g. they go through a record, a la ocaml)
14:17:48 <edwardk> aphocus: sure. if all the fields are named that way it'll switch =)
14:17:53 <sinelaw> not sure how that can work with the optimizations
14:17:57 <cmccann> lens magic(tm)
14:18:14 * hackagebot envy 0.3.0.2 - An environmentally friendly way to deal with environment variables  https://hackage.haskell.org/package/envy-0.3.0.2 (DavidJohnson)
14:18:34 <shachaf> cmccann: You were missing out on dual intuitionstic logic talk in #-blah.
14:18:41 <shachaf> But maybe it's worth it.
14:18:44 <cmccann> oh no
14:19:01 <aphocus> edwardk, cool, I guess this error isn't related to making the lens incorrectly then.
14:19:10 <cmccann> shachaf: anything particularly interesting come up
14:21:33 <monochrom> w00t, dual intuitionistic logic
14:21:50 <kritzcreek> How would I go about hot reloading code into a running scotty webserver? Something utilizing ghci would be optimal. I tried http://chrisdone.com/posts/ghci-reload but it seems to be outdated since the WAI api changed and it doesn't compile anymore...
14:21:56 <indiagreen> edwardk: it still doesn't switch, actually (I think)
14:22:24 <edwardk> indiagreen: hrmm. i may be wrong about that, but i thought that was the behavior that glguy coded.
14:22:37 <edwardk> you can specify a custom naming convention to makeLensesWith though
14:23:04 <indiagreen> I had a pull request about it and it didn't go thru
14:23:19 <Intolerable> i know i stripped out some of that part of lens at one point
14:23:28 <cmccann> edwardk: does lens include a built-in "select nearest pun" naming convention yet
14:23:42 <Intolerable> i removed some of the magic that was happening
14:24:05 <edwardk> cmccann: only for internal development. we don't expose that to end users or they'd use them all up
14:24:12 <cmccann> haha
14:28:15 * hackagebot chatter 0.6.0.0 - A library of simple NLP algorithms.  https://hackage.haskell.org/package/chatter-0.6.0.0 (RoganCreswick)
14:28:28 <aphocus> OK, so I'm trying to wrap PortMidi with lenses, but I get this error: http://lpaste.net/141580
14:30:55 <hackrilege> How can monads can be seen as monoids in the category of endo functors?
14:31:59 <monochrom> first you need the category of endo-functors. that is going to be a long story.
14:32:15 <hackrilege> No that's fine
14:32:49 <monochrom> I might still know a video that does it
14:32:57 <shachaf> After that you need "monoid". Also a long story, which makes the category monoidal.
14:33:18 <mniip> well before you can have a monoid you need a magma
14:33:31 <hackrilege> That a collection of Functor who's domain and codomain are the same set, along with some morphisms between them
14:33:34 <shachaf> Not particularly?
14:33:38 <bitemyapp> mniip: I don't think anybody bothers.
14:33:39 <cmccann> hackrilege: the same way the Endo newtype has a Monoid instance
14:33:52 <pavonia> aphocus: Why _input instead of input?
14:34:09 <hackrilege> @where Endo
14:34:10 <lambdabot> I know nothing about endo.
14:34:20 <mniip> bitemyapp, Magma? Semigroup? Quasigroup? Loop?
14:34:37 <mniip> hackrilege, Endo is the type of endofunctions
14:34:41 <mniip> not endofunctors
14:34:41 <aphocus> pavonia, because Sound.PortMidi exports input instead
14:34:51 <cmccann> hackrilege: http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Monoid.html#t:Endo
14:35:12 <hackrilege> Thanks
14:35:16 <quchen> Come to Zurihac, have Edward explain this in 5 minutes! :-D
14:35:29 <shachaf> cmccann: That's analogous to the tensor product in the required category of endofunctors, but you still need a monoid object to finish the story.
14:36:12 <aphocus> pavonia, unless I'm mistaken in what makeLenses does.
14:36:48 <bldzrr> Can anyone help me with this? http://lpaste.net/7956945627630272512
14:36:57 <hackrilege> Ok well that's a pretty transparent instance, how is that a monad?
14:37:05 <cmccann> it's not a monad
14:37:22 <hackrilege> As in my original question
14:37:38 <pavonia> aphocus: Hhm, I don't know how lenses work, but I thought the cause of the error would be the underscore that introduces a hole in the expression
14:37:41 <hackrilege> (hackrilege) How can monads can be seen as monoids in the category of endo functors?
14:37:51 <mniip> [23:29:33] <mniip> hackrilege, Endo is the type of endofunctions
14:37:56 <cmccann> hackrilege: instances of Monad have kind * -> *
14:38:08 <mniip> [23:29:37] <mniip> not endofunctors
14:38:20 <cmccann> Endo a values have type a -> a
14:38:31 <hackrilege> So my question is I'll posed?
14:39:20 <aphocus> pavonia, I don't actually know what or how underscores introduce holes (or what a hole is really), so you could be correct for all I know.
14:39:30 <aphocus> don't know*
14:40:44 <cmccann> hackrilege: no, it's a reasonable question
14:40:52 <mniip> aphocus, a hole is a typechecker debug feature
14:40:55 <cmccann> hackrilege: I'm just not explaining things very well right now, sorry
14:41:09 <pavonia> > head _foo
14:41:10 <lambdabot>      Found hole ‘_foo’ with type: [a]
14:41:11 <lambdabot>      Where: ‘a’ is a rigid type variable bound by
14:41:11 <lambdabot>                 the inferred type of it :: a at <interactive>:1:1
14:41:12 <mniip> a value that infers whatever surrounding context is, and raises an error mentioning what its inferred type is
14:41:47 <shachaf> I'm actually not sure what cmccann is getting at with Endo.
14:41:59 <shachaf> Explaining what an endofunctor is?
14:42:11 <lpaste> tiggery pasted “No title” at http://lpaste.net/7512171776667811840
14:42:30 <hackrilege> A monad is an applicative Functor with join. A monoid is an object with mempty and happens. The category of endofunctors is a category (collection of objects and arrows) who's objects are Functors with the same set as domain and codomain, Right?
14:42:52 <hackrilege> Mappend, not happens
14:42:59 <cmccann> hackrilege: I believe that's right, yes
14:43:03 <cmccann> modulo typos ;]
14:43:08 <quchen> I don't think so.
14:43:13 <shachaf> A category is not just a collection of objects and arrows, it's a rule for composing arrows.
14:43:20 <hackrilege> Oh
14:43:21 <hackrilege> Ok
14:43:23 <edwardk> hackrilege: i don't have the time to make this rigorous right now, but if you look at mempty :: a, and switch to const mempty :: () -> a  and mappend :: a -> a -> a   and you uncurry mappend you get (a,a) -> a     then you can use the fact that () acts like a 'unit' for (,)    ((),a) is isomorphic to a, (a,()) is isomorphic to a and (a,(b,c)) is isomorphic
14:43:23 <edwardk> to ((a,b),c).    and mempty takes that unit and gives back a value, and mappend respects that associativitity. there are some other tedious axioms you need. if you replace '(,)' with functor composition and 'e' with Identity and look at what mempty and mappend would be you get 'return' :: Identity ~> m     and 'join :: Compose m m ~> m'    just like 'const
14:43:23 <edwardk> mempty' and 'uncurry mappend' with all the same structure preserved.
14:43:30 <sinelaw> edwardk, why do your skolems need depth?
14:43:52 <sinelaw> (looking at ermine link you gave)
14:44:04 <edwardk> sinelaw: i don't rightly remember
14:44:11 <sinelaw> ok, i'll keep reading
14:44:40 <edwardk> IIRC we started phasing out the use of skolems entirely by the end
14:44:48 <sinelaw> oh?
14:45:02 <edwardk> just by checking that things emerged distinct
14:45:03 <sinelaw> do you do subsumption?
14:45:04 <aphocus> mniip, pavonia, well I guess the follow on, packages like Linear, export lens like _x, so I wonder how they do that.
14:45:22 <sinelaw> I mean do you have a subtyping notion of polymorphic subsumption
14:45:26 <dustin_> https://gist.github.com/anonymous/1ee53d1832de5e86aca4 can someone help me with this
14:45:31 <mniip> aphocus, it's only a hole if it's not a defined name
14:45:32 <dustin_> HStringTemplate constantly failing to install 
14:45:34 <edwardk> aphocus: i just have a class R1 f where _x :: Lens (f a) a
14:45:39 <edwardk> er Lens'
14:45:43 <mniip> > let _x = 1 in _x
14:45:45 <lambdabot>  1
14:45:46 <mniip> > let _x = 1 in _y
14:45:47 <lambdabot>      Found hole ‘_y’ with type: t
14:45:47 <lambdabot>      Where: ‘t’ is a rigid type variable bound by
14:45:47 <lambdabot>                 the inferred type of it :: t at <interactive>:1:1
14:45:50 <dolio> sinelaw: No.
14:45:55 <edwardk> if _foo is in scope it doesn't become a hole
14:46:01 <Shockk> a hole D: better `fix' it
14:46:06 <aphocus> oh, I think I know what the issue is.
14:46:18 <sinelaw> dolio, good for you
14:46:42 <sinelaw> but what are skolems used for if not for that?
14:46:50 <aphocus> I guess I need to redefine all the types from PortMidi?
14:46:56 <dolio> sinelaw: I don't think anyone's given a story for type classes with those.
14:47:02 <hackrilege> Hmmm. Edk, what did you just do? You showed some things were isomorphic, I guess that makes sense. But that is literally all I can clean from your response. Thanks anyway, I keep a log of your writings in the hope that one-day I understand hour that was the answer...
14:47:03 <dolio> sinelaw: Existential quantification.
14:47:11 <dolio> Also there's one level of subsumption.
14:47:12 <sinelaw> ah
14:47:19 <hackrilege> Gleen, not clean
14:47:43 <dolio> But we don't do the whole subtyping relation.
14:48:05 <edwardk> sinelaw: https://github.com/ermine-language/ermine/blob/master/src/Ermine/Unification/Meta.hs#L131 <- i linked you to an old version, that is the current Meta type we use
14:48:10 <shachaf> You can find more in-depth explanations than someone's ad-hoc response to your question in IRC.
14:48:28 <shachaf> @google monoid in the category of endofunctors
14:48:29 <lambdabot> http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
14:48:29 <lambdabot> Title: haskell - A monad is just a monoid in the category of endofunctors, what's th...
14:48:44 <edwardk> hackrilege: to understand 'monads are monoids in the category of endofunctors' you need what a monoidal category is
14:49:15 <edwardk> hackrilege: start here: https://www.youtube.com/watch?v=cB8DapKQz-I
14:49:20 <Adeon> monoids in the category of endofunctors are just monads, what's the problem
14:49:27 <sinelaw> edwardk, dolio do you have a trick for more efficient skolem escape check?
14:49:38 <edwardk> hackrilege: the relevant bit starts about 6 minutes in
14:49:44 <hackrilege> It can't be defined?
14:49:50 <aphocus> mniip, ekwardk, I guess making lenses of types defined in another package is causing issue, do I have to redefine them locally?
14:49:52 <monochrom> hackrilege: https://www.youtube.com/watch?v=cB8DapKQz-I&feature=youtu.be&t=6m15s
14:50:01 <erisco> I assume there are Haskell SQL DSLs for doing select queries... what are the relevant packages
14:50:04 <edwardk> sinelaw: https://github.com/ermine-language/ermine/blob/master/src/Ermine/Unification/Meta.hs#L311
14:50:13 <erisco> I want to see how they do a join
14:50:17 <monochrom> which is edwardk's but with the start time in the url
14:50:18 <sinelaw> maybe one can keep track of skolem count lower bound on composite types and check that it's 0?
14:50:21 <edwardk> that plus the distinct check
14:50:24 <hackrilege> Thanks for the resource. Maybe I'll be able to make the definition from this
14:51:05 <edwardk> hackrilege: it can be defined. what i indicated was 'i don't have time to do the full intro here' =)
14:51:28 <sinelaw> ah looks like you use depth for that. 
14:51:40 <tyler_durden> hi all
14:51:56 <sinelaw> gotta love 'ultraZonkWith'
14:52:01 <edwardk> sinelaw: =)
14:52:06 <shachaf> Discrimination is monoids in the category of endofunctors now?
14:52:09 <edwardk> i confess i've largely forgotten how all this works
14:52:10 <dolio> I think when we leave a scope that introduces skolems, we check that none of them have depth less than the scope that introduced them.
14:52:16 <hackrilege> No, a definition should be a collection of very simple statements. Cf "a monad is an applicative Functor with join"
14:52:37 <edwardk> hackrilege: http://ncatlab.org/nlab/show/monoidal+category is a monoidal category
14:52:50 <hackrilege> Thank you
14:52:54 <edwardk> hackrilege: (Hask, (,), ()) is one such example, ([Hask, Hask], Compose, Identity) is another
14:53:14 <sinelaw> this is my 5-6th iteration of implementing inference, Oleg's page really opened my eyes
14:53:28 <nitrix> I'm using a library (timers) that lets you run a task in parallel at a given interval. If my program terminates abruptly while one of those tasks are running, will the runtime wait for that thread to terminate before exiting?
14:53:38 <sinelaw> ermine has rank-n types?
14:53:39 <edwardk> http://ncatlab.org/nlab/show/monoid+in+a+monoidal+category gives the right notion of a 'monoid'
14:53:54 <edwardk> sinelaw: yeah, rank-n + polykinds, not much else
14:53:59 <sinelaw> k
14:54:53 <hackrilege> That resource contains the definition, thank you.
14:55:26 <johnw> edwardk: is that page what led you into multicategories?
14:55:32 <hackrilege> The one before that last one
14:55:36 <edwardk> hackrilege: with that you can then show that a monad is just a monoid in the monoidal category ([Hask, Hask], Compose, Identity)
14:55:46 <edwardk> johnw: nah, the multicategory stuff was an obsession long before
14:56:07 <tyler_durden> I have a question about a definition for a binary tree I've been given. Here's the definition and an example of one. http://pastebin.com/a1fCZN1M     my question is this: is this defining a tree as a Branch AND a Leaf, or is it being defined as a Branch OR a Leaf? 
14:56:49 <edwardk> hackrilege: the reason why i was trying to avoid giving the technical introduction is because the material you need to get the joke is literally an appendix added in the second edition of mac lane's "Categories for the Working Mathematician"
14:57:05 <sinelaw> so what does zonk really mean? is it traversing the union path all the way and writing down the result?
14:57:07 <edwardk> so there are a few pre-requisites
14:57:11 <monochrom> tyler_durden: I bet OR. (I have to bet because I can't be sure what your OR means.)
14:57:21 <edwardk> sinelaw: zonk basically ensures that you don't have any unexpanded variables in the tree
14:57:23 <cmccann> the monad thing isn't even the funniest part of that post anyway
14:57:47 <monochrom> at this point it is more mincing words than getting at real issues.
14:58:18 <sinelaw> oh, what i said is more like semiprune
14:58:23 <monochrom> to get at real issues: one example tree is a Leaf. another example tree is a Branch.
14:58:50 <edwardk> sinelaw: not the best names i admit =)
14:59:20 <sinelaw> unfortunately they are becoming standard parlance
14:59:27 <sinelaw> so I need to know them
14:59:28 <edwardk> IIRC semiprune is also what unification-fd called it
14:59:30 <edwardk> yeah
14:59:34 <edwardk> https://hackage.haskell.org/package/unification-fd-0.10.0.1/docs/Control-Unification.html#v:semiprune
14:59:40 <sinelaw> yeah, semiprune is that
15:00:02 <sinelaw> semiprune could be called "peach" to make it worse :)
15:00:06 <monochrom> wait, "zonk" is becoming standard parlance?!
15:00:07 <edwardk> =P
15:00:23 <edwardk> maybe 'plum'
15:00:35 <tyler_durden> monochrom: thanks, that's what I figured. I'm attempting to implement preorder, inorder, and postorder traversals. it's such a strange type i've been given too;  preorder  :: (a -> c) -> (b -> c) -> Tree a b -> [c]    
15:00:36 <sinelaw> yip. pull request? :)
15:00:40 <cmccann> monochrom: one can only hope
15:01:11 <sinelaw> is there an official "zonking" paper from some Simon?
15:01:26 <edwardk> sinelaw: i don't remember where i first saw the term
15:02:30 <ew0> hey, how do I found out what is caising a Main: <<loop>> ?
15:02:41 <mniip> well
15:02:42 <mniip> a loop
15:02:44 <hackrilege> What is this crazy Pentagon thing. I must misunderstand it since it just seems to be a large expansion of the laws of associativity
15:03:02 <hackrilege> How is out not that?
15:03:11 <hackrilege> It, not pour, sorry
15:03:20 <ew0> can't ghc help me a bit more than just print <<loop>> ?
15:03:22 <hackrilege> Ffs, out, not pour
15:03:29 <sinelaw> ew0, it also quits
15:03:45 <ew0> yeah, I figured out that part too =D
15:04:44 <Cale> hackrilege: You're talking about the pentagon formed by associative laws on the 5 possible ways of associating a product of 4 things?
15:05:12 <sinelaw> ew0, I've never tried it myself, but if you compile with profiling + rtsopts, there's a flag to print out backtraces when an exception occurs
15:05:34 <Cale> ew0: Well, printing <<loop>> is generally a whole lot nicer than just taking forever using 100% cpu which is what it'd be doing otherwise ;)
15:06:03 <sinelaw> ew0, -xc, see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime-control.html#rts-options-debugging
15:06:12 <sinelaw> not sure if that thing works on <loop>s
15:06:16 <Cale> it should
15:06:20 <Cale> It's not always useful
15:06:23 <hackrilege> But if I define associativity using three things, as usual, it would imply 4 things would be associative also... Right?
15:06:33 <Cale> but it should print something
15:06:43 <hackrilege> So what is different in these bicategories?
15:06:43 <Cale> hackrilege: right
15:07:46 <Shockk> pentagon?
15:07:52 <Cale> hackrilege: There are two ways to apply associative laws to go from ((A * B) * C) * D to A * (B * (C * D)). When your associative laws are not given as equalities, but instead as isomorphisms, you might care that those two ways end up producing the same result every time.
15:07:57 <hackrilege> Why state the laws of association using 4 objects when this follows trivially from a definition over 3. The fact this Pentagon thing is a thing at all implies something untoward is afoot, no?
15:08:00 <cmccann> monochrom: sadly I can only find three other compilers using the term "zonk", of which one is a toy project and another appears to be abandoned
15:08:04 <Cale> i.e. that the two paths around the pentagon are equal
15:08:34 <hackrilege> Shockk http://ncatlab.org/nlab/show/pentagon+identity
15:09:03 <phao> Is there a channel for haskell game programmers?
15:09:09 <Cale> phao: #haskell-game
15:09:17 <phao> thanks
15:09:38 <Shockk> oh I should join
15:10:00 <hexagoxel> moral question: am i allowed to unsafeCoerce when ghc can't infer `r ~ HList.Append r '[]` ?
15:10:16 <Cale> hexagoxel: no?
15:10:20 <hamilto-nyan> hackrilege: What doesn't follow trivially from the associative laws is that the two paths are the same -- not just two isomorphisms, but *the same* isomorphism.
15:10:25 <hexagoxel> aww
15:10:26 <Cale> hexagoxel: I don't think that'll work.
15:10:52 <tiggery> Can anyone help? http://lpaste.net/7512171776667811840
15:10:58 <hackrilege> Hmmm.... Hmmm....
15:11:11 <Cale> hexagoxel: Isn't that like using unsafeCoerce to deal with the case that GHC can't infer a ~ [a] ?
15:11:17 <hackrilege> Brain makes clunking noise
15:11:41 <shachaf> Cale: Append is (++), not (:), presumably.
15:11:57 <hexagoxel> right
15:12:01 <Cale> shachaf: Oh, good point
15:12:01 <monochrom> tyler_durden: the type is kind of forced, i.e., you don't have a really better choice.
15:12:06 <nitrix> Is GHC clever enough to not copy entirely a record when using the  `x { y = ... }` syntax?
15:12:14 <Cale> In that case, I don't know
15:12:23 <monochrom> if you have heard of Either, you may say, how about "Tree a b -> [Either a b]".
15:12:31 <shachaf> I'd hope that there's a better way to tell GHC that those are equal.
15:12:44 <Cale> nitrix: It copies the rest of the fields, but each field is only a code pointer anyway
15:13:00 <monochrom> ok, that's a good one too, but it's indirectly equivalent to (a -> c) -> (b -> c) -> Tree a b -> [c].
15:13:02 <nitrix> Cale: I see.
15:13:11 <hackrilege> There are different isomorphisms, but only one notion of equality, so we care that the isomorphisms don't mess up in this way. Ok I can kind of but that, I'll roll with it if there is no further clarification
15:13:25 <hackrilege> Buy not but
15:13:30 <jake__> I'm trying to understand the relationship between maps and functions: (Map k v) is like a partial function (k -> v) aka (k -> Maybe v) except you also get (m -> k -> Maybe v -> m) and (m -> [(k, v)]) and some more, is there a generalization of this or something I should read to understand better?
15:13:51 <hexagoxel> Cale: the alternative seems to be to add the constraint `r ~ Append r '[]` to all functions "above" the one that needs it (in the call stack), until the types are definite.
15:14:09 <hexagoxel> which is annoying
15:14:21 <Cale> hexagoxel: Maybe you can write a function of type r -> Append r '[] and vice versa?
15:14:39 <hackrilege> One day I'll get bored of amending typos enough to get in the habit of reading my posts before submitting them, until then I'm so sorry.
15:14:46 <Cale> I don't know how the type Append u v is defined
15:15:03 <Cale> It's not clear that those types really are or can be equal
15:15:10 <cmccann> hexagoxel: there's probably a clevererer way to write Append that would help
15:15:39 <hexagoxel> it is equivalent to http://hackage.haskell.org/package/HList-0.4.1.0/docs/Data-HList-HList.html#t:HAppendListR
15:16:30 <hexagoxel> a "HAppendListL" would work i guess, but would in turn break other stuff, so no good.
15:16:47 <Cale> hexagoxel: Okay, so this requires proof...
15:17:48 <cmccann> hexagoxel: couldn't that be rewritten into a single type family that would handle both cases?
15:18:47 <ski> sinelaw : both metavars and skolems are for both univeral and existential quantification
15:19:05 <monochrom> :)
15:22:08 <shachaf> hexagoxel: You can write a proof that Append xs [] ~ [] pretty easily.
15:22:19 <hexagoxel> cmccann: no, then ghc cannot infer the inverse in cases where it is necessary, because it becomes ambiguous (you lose injectivity (?))
15:22:28 <dolio> sinelaw: Now that I think of it, I think you need skolem-like things even if you're just doing unification of higher-rank types.
15:22:46 <jake__> Is there like a typeclass for Map like things? I see there's IsMap in classy-prelude, but it's very large, I feel like there should be something prettier to encapsulate mapness
15:22:52 <sinelaw> dolio, right, to check higher vs. lower rank of same structure (Subsumption)
15:22:55 <hexagoxel> shachaf: in a form that ghc understands?
15:23:01 <sinelaw> dolio, is that what you mean?
15:23:07 <dolio> sinelaw: No, I mean even when you're not doing subsumption.
15:23:19 <hexagoxel> i don't switch to idris for this :D
15:23:41 <shachaf> hexagoxel: Yes.
15:23:48 <sinelaw> dolio, then why
15:23:48 <shachaf> Unless I misunderstand the problem.
15:24:03 <shachaf> E.g.
15:24:04 <dolio> sinelaw: The procedure is: check that you have foralls with equal numbers of variables, make up that many new skolems, instantiate them them in order, then keep unifying.
15:24:14 <cmccann> hexagoxel: infer the inverse in what context?
15:24:35 <dolio> sinelaw: Presuming the forall has been normalized so that variables must be quantified in a coherent order.
15:24:42 <shachaf> class Rid a where { rid :: Is a (Append a '[]) }; instance Rid '[] where { rid = Refl }; instance Rid xs => Rid (x ': xs) where { rid = case rid :: Is xs (Append xs '[]) of Refl -> Refl }
15:24:46 <shachaf> Something like that?
15:24:56 <sinelaw> dolio, ah, so it's the case of "same rank subsumption" 
15:25:08 <sinelaw> equivalence
15:25:31 <dolio> Subsumption you just instantiate one with non-skolems.
15:25:54 <sinelaw> and see if it can be unified with the skolemized one
15:26:03 <dolio> Right.
15:26:20 <sinelaw> here you get rid of all quanitfied vars by skolmeizing them equally
15:26:25 <dolio> Yes.
15:26:45 <sinelaw> if the structure is the same, no skolem will be unified with anything but itself
15:26:54 <dolio> Exactly.
15:27:05 <tommd> Wizek: Ninjas uses Gloss.  I'm also using gloss for sort of a party dance video cature/display setup.
15:27:24 <sinelaw> I forgot what skolem escape checks are for
15:28:15 <hexagoxel> cmccann: uhm, the second HInit instance breaks, see https://hackage.haskell.org/package/multistate-0.6.2.0/docs/Data-HList-HList.html
15:28:31 <hexagoxel> (for example)
15:29:02 <Cale> jake__: There's http://hackage.haskell.org/package/lens-4.13/docs/Control-Lens-Indexed.html but it's perhaps even more complicated
15:29:37 <dolio> sinelaw: I can't remember if we use escapes for anything but existential types.
15:29:40 <Cale> jake__: It's probably best just to think about which operations the map-like data types you want to abstract over have in common, and define some record type for those.
15:30:11 <dolio> sinelaw: For existential types, when you go out of a scope that introduced the existential, you have to check for escape.
15:30:13 <hexagoxel> shachaf: any pointers how to do that / what to google for?
15:30:20 <jake__> @Cale yeah, it just really smells like there's something more elegant in there trying to get out
15:30:21 <lambdabot> Unknown command, try @list
15:30:23 <shachaf> hexagoxel: Something like what I posted above?
15:30:33 <shachaf> lens says there are two operations for map-like data types: traverseWithKey and alterF
15:30:50 <dolio> Or, elminated an existential, I guess.
15:31:27 <sinelaw> dolio, in subsumption I check for escaped skolems to see if any free type vars (metavariables) were assigned to skolems
15:31:34 <mitochon> I'm trying to manipulate strings, e.g using "aaa" ++ "bbb" but for long strings it takes really long time ... is there a recommended workaround?
15:31:37 <jake__> @Cale The lens thing I don't think is sufficient for example, it doesn't give (m -> [(k, v)]) afaik
15:31:37 <lambdabot> Unknown command, try @list
15:31:39 <cmccann> hexagoxel: hmm
15:31:43 <dolio> For 'data Foo = forall e. Foo ...' when you do 'case x of Foo ... -> ...' you need to check if the skolemized e escapes from the body.
15:31:45 <shachaf> lens gives you that.
15:31:50 <sinelaw> dolio, sounds like it could happen in your higher-rank equivalence unification
15:32:20 <shachaf> Using traverseWithKey and alterF, you can write all of: (!) adjust adjustWithKey alter delete findWithDefault foldl foldl' foldlWithKey foldlWithKey' foldr foldr' foldrWithKey foldrWithKey' insert insertLookupWithKey insertWith insertWithKey lookup map mapAccum mapAccumRWithKey mapAccumWithKey mapMaybe mapMaybeWithKey mapWithKey member notMember toList update updateLookupWithKey updateWithKey
15:32:21 <dolio> Maybe we do it there, then.
15:32:29 <sinelaw> forall a. a -> b   vs.  forall a. a -> a
15:32:35 <sinelaw> b is free, will be assigned to a skolem
15:32:59 <Cale> hmm
15:33:27 <dolio> sinelaw: It's difficult to have that situation in ermine, though, because there are no scoped type variables.
15:33:45 <jake__> shachaf: interesting
15:33:47 <dolio> Maybe you can write a term that causes it to happen, though.
15:33:55 <Cale> > ifoldMap (\k v -> [(k,v)]) (Map.fromList [(1,"one"), (2,"two"), (3,"three")])
15:33:57 <lambdabot>      Not in scope: ‘Map.fromList’
15:33:57 <lambdabot>      Perhaps you meant one of these:
15:33:57 <lambdabot>        ‘M.fromList’ (imported from Data.Map),
15:34:02 <Cale> > ifoldMap (\k v -> [(k,v)]) (M.fromList [(1,"one"), (2,"two"), (3,"three")])
15:34:03 <lambdabot>  [(1,"one"),(2,"two"),(3,"three")]
15:34:10 <monochrom> mitochon: my recommendation is questioning yourself, e.g., "should they really be strings?"
15:34:24 <monochrom> always question yourself and your design choices
15:34:25 <drewbert> I asked earlier "If I do `length <$> words <$> readFile "largeFile.txt"` Is there a time when the whole file is read into memory, or does lazy io cause the count to tally up as the large file is read in chunks?"  The answer is that the process does not read the whole file into memory.  Lazy IO magic keeps the memory usage low.
15:34:43 <Cale> > ifoldMap (\k v -> [(k,v)]) (IM.fromList [(1,"one"), (2,"two"), (3,"three")])
15:34:44 <lambdabot>  [(1,"one"),(2,"two"),(3,"three")]
15:35:17 <Cale> > ifoldMap (\k v -> [(k,v)]) (S.fromList ["one","two","three"])
15:35:18 <lambdabot>      No instance for (Show t0)
15:35:18 <lambdabot>        arising from a use of ‘show_M359065147073491578520491’
15:35:18 <lambdabot>      The type variable ‘t0’ is ambiguous
15:35:20 <mitochon> monochrom so avoid Strings in general?
15:35:23 <glguy> :t itoList
15:35:25 <lambdabot> FoldableWithIndex i f => f a -> [(i, a)]
15:35:36 <Cale> > ifoldMap (\k v -> [(k,v)]) (S.fromList ["one","two","three"]) :: [(Int,String)]
15:35:37 <lambdabot>      No instance for (FoldableWithIndex Int S.Set)
15:35:37 <lambdabot>        arising from a use of ‘ifoldMap’
15:35:37 <lambdabot>      In the expression:
15:35:43 <Cale> oh, Set
15:35:50 <Cale> > ifoldMap (\k v -> [(k,v)]) (Seq.fromList ["one","two","three"]) :: [(Int,String)]
15:35:51 <lambdabot>  [(0,"one"),(1,"two"),(2,"three")]
15:35:54 <Cale> right
15:36:07 <Cale> > ifoldMap (\k v -> [(k,v)]) (V.fromList ["one","two","three"]) :: [(Int,String)]
15:36:09 <lambdabot>      Not in scope: ‘V.fromList’
15:36:09 <lambdabot>      Perhaps you meant one of these:
15:36:09 <lambdabot>        ‘M.fromList’ (imported from Data.Map),
15:36:12 <monochrom> no. avoid self-confidence in general.
15:36:18 <Cale> hmm, I don't know if we have Vector
15:36:28 <Cale> anyway, there are a lot of instances of FoldableWithIndex
15:36:36 <jake__> I think this is what I'm looking for, thanks!
15:36:55 <sinelaw> dolio, maybe this
15:36:56 <sinelaw> f id x y = (id x, id y)
15:36:56 <sinelaw> g x = f (const x)
15:37:07 <jake__> man lenses/traversables/etc are really magical
15:37:28 <hexagoxel> shachaf: ah, sorry, i was blind. Where does `Is` come from?
15:37:34 <Fay> why does fold exist?  what is it used for? 
15:37:44 <Cale> Fay: which fold?
15:37:47 <Cale> :t fold
15:37:49 <lambdabot> (Foldable t, Monoid m) => t m -> m
15:37:52 <Cale> ^^ that one?
15:38:42 <Fay> my question is alot more general....what is a fold 
15:39:02 <Cale> Okay, so let's look at the most obvious fold on lists, which is foldr
15:39:04 <dolio> sinelaw: Looks like we do check for escapes during type unification.
15:39:05 <shachaf> hexagoxel: data Is a b where Refl :: Is a a
15:39:15 <shachaf> I think it's called (:~:) in base these days.
15:39:17 <monochrom> I use various variants of fold for summing, multiplying, etc
15:39:30 <hexagoxel> shachaf: yeah, i just found that, let me see.
15:39:46 <Cale> Fay: Recall that every list is either the empty list [], or it is built up by adding an element to another list like (x : xs)
15:40:22 <Cale> Fay: What foldr f z does is take some list, and replace every occurrence of (:) in it with f, and replace the [] at the end (if any) with z
15:40:46 <dolio> sinelaw: checkSkolems is the things that checks for the escaping part of skolems. And checkDistinct is the thing that checks for the not-unifying-with-anything-other-than-itelf part of skolems.
15:40:48 <Cale> Fay: actually, let's take a step further back, and look at the recursive implementations of a few simple functions on lists
15:40:59 <Cale> Fay: We might write a function to sum the elements of a list like this:
15:41:02 <Cale> sum [] = 0
15:41:02 <sinelaw> dolio, ah thanks
15:41:06 <Cale> sum (x:xs) = x + sum xs
15:41:21 <shachaf> Well, the word "fold" means something more general than foldr, and the class Foldable also means something more general than foldr (though a different thing).
15:41:35 <Cale> and similarly, we might want to take the product of the elements like this:
15:41:38 <Cale> product [] = 1
15:41:44 <Cale> product (x:xs) = x * product xs
15:42:02 <Cale> Or maybe it's a list of lists instead of a list of numbers, and we want to concatenate the lists:
15:42:06 <Cale> concat [] = []
15:42:12 <Cale> concat (x:xs) = x ++ concat xs
15:42:31 <Cale> and you can see there's a pattern here
15:43:04 <Fay> yes i can
15:43:18 * hackagebot rainbox 0.18.0.4 - Two-dimensional box pretty printing, with colors  https://hackage.haskell.org/package/rainbox-0.18.0.4 (OmariNorman)
15:43:20 * hackagebot luminance 0.1.1 - Type-safe, dependently-typed and stateless graphics framework  https://hackage.haskell.org/package/luminance-0.1.1 (DimitriSabadie)
15:43:30 <Cale> The only things which have been changing are what the result should be for an empty list, and which function is used to combine the first element of the list with the result of combining the rest.
15:43:30 <Fay> so for fold does ...
15:43:37 <Cale> So:
15:43:41 <Cale> foldr f z [] = z
15:43:50 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
15:44:03 <Cale> and this lets us write:
15:44:09 <Cale> sum = foldr (+) 0
15:44:15 <Cale> product = foldr (*) 1
15:44:21 <Cale> concat = foldr (++) []
15:44:48 <Fay> ohhh thankyou Cale 
15:45:54 <Cale> There are a bunch of variations on the idea of "combine all the elements of this data structure somehow" which are also referred to as folds.
15:46:33 <Cale> foldr is also somewhat special in that it directly replaces each constructor of the list data type with some other specified value
15:46:55 <Cale> The technical term for functions which do that is "catamorphisms"
15:47:20 <Cale> For a simpler non-recursive example of a catamorphism, there's the function either
15:47:24 <Cale> :t either
15:47:25 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:47:37 <Cale> either left right (Left x) = left x
15:47:42 <arkeet> :t either Left Right
15:47:43 <Cale> either left right (Right x) = right x
15:47:43 <lambdabot> Either a b -> Either a b
15:47:56 <arkeet> :t foldr (:) []
15:47:57 <lambdabot> Foldable t => t a -> [a]
15:47:59 <arkeet> oops.
15:48:08 <arkeet> :t Data.OldList.foldr (:) []
15:48:09 <lambdabot>     Not in scope: ‘Data.OldList.foldr’
15:48:10 <lambdabot>     Perhaps you meant one of these:
15:48:10 <lambdabot>       ‘Data.List.foldr’ (imported from Data.List),
15:48:20 <radens> is there a pydoc equivalent for haskell? Good command line docs on what functions do?
15:50:04 <Shockk> who maintains https://www.haskell.org/haddock/ ?
15:50:09 <Shockk> because there's a broken link on there
15:50:44 <Shockk> "The latest version of the documentation is /here/."
15:50:51 <Shockk>  /here/ results in a 404
15:52:13 <radens> Shockk: looks like it lives on github
15:52:16 <radens> https://github.com/haskell/haddock
15:52:29 <radens> that's the tool, not sure about the docs
15:54:46 <Shockk> radens: ah I see, I can't see the docs/source for the web page in there
15:55:02 <radens> Yeah.
15:55:24 <Shockk> that page also says the repository is git.haskell.org/haddock.git 
15:55:34 <Shockk> idk if that's out of date or if the github repository is a mirror
15:55:47 <radens> I'd guess it's a mirror
15:58:57 <hexagoxel> shachaf: hmm i ended up with: castWith (Equality.apply (Equality.apply (Equality.apply (Equality.apply (Equality.apply Refl rid) Refl) Refl) Refl) Refl)
15:59:10 <hexagoxel> which still complains: Could not deduce (Rid r) arising from a use of ‘rid’
15:59:30 <shachaf> hexagoxel: Oh, well, do you know that r :: [k]?
16:00:22 <hexagoxel> shachaf: [k] or [*] ?
16:00:37 <hexagoxel> i know [*], which should be more specific, right?
16:00:42 <shachaf> Yes.
16:01:31 <shachaf> Does GHC know [*] at that point?
16:01:47 <shachaf> Hmm, maybe that's not enough.
16:02:09 <hexagoxel> shachaf: yes, it does
16:03:26 <hexagoxel> (btw even if this does not work, this approach is new to me and is really interesting!)
16:04:07 <shachaf> Oh, right.
16:04:12 <shachaf> I bet this isn't even true, because of Any.
16:04:15 <shachaf> Or something like that.
16:09:45 <AfC> Should we be committing `stack.yaml` to each project's git repository, or letting users `stack init` their own in place? I used to think the latter was the idea, but I've seen a lot of the former of late, which does seem to make sense: "here, this is what builds"
16:13:56 <johnw> I prefer not to commit things like stack.yaml, since it can be generated
16:13:56 <athan> AfC: I've found it's more of a personal file for users - they might use a different resolver, or local packages. IIRC you should ignore stack.yaml
16:16:31 <AfC> Damn it. Ask a question then fall of the internet. Charming. In case it didn't go out (and apologies if it did):
16:16:36 <AfC> Should we be committing `stack.yaml` to each project's git repository, or letting users `stack init` their own in place? I used to think the latter was the idea, but I've seen a lot of the former of late, which does seem to make sense: "here, this is what builds"
16:17:50 <athan> AfC: I get it all the time :P
16:17:55 <athan> you should ignore your stack.yaml
16:18:19 <athan> people that install your library / executable might have different resolvers or local packages in mind when `stack` does lookups
16:19:13 <thecontrarian42_> Does anyone know of a good resource for general programming/compsci concepts that is programming language agnostic? i'm specifically looking for resources regarding language design and concepts that arent specific to any one language.
16:20:11 <hpc> you're going to find that almost everything is language-specific by way of needing a language for demonstrative purposes
16:21:06 <jmcarthur> TAOCP is sort of language unspecific in that knuth invented a language for it
16:21:30 <AfC> athan: ok. So how about https://github.com/leksah/leksah/blob/master/stack.yaml , https://github.com/commercialhaskell/stack/blob/master/stack.yaml , https://github.com/brendanhay/amazonka/blob/develop/stack.yaml and so on?
16:22:06 <jmcarthur> i dislike stack.yamls in repos
16:22:35 <jmcarthur> it basically guarantees that i will have to remove it so i can use stack to build it to use with my own projects, with whatever version of ghc i want to use
16:22:59 <jmcarthur> i think it makes more sense for applications than libraries though
16:23:06 <hpc> yaml as a config format seems wrong somehow
16:23:11 <thecontrarian42_> hmm. what about one that covers many languages? for instance, i'm picturing a book or wiki that has an article on Symbols, describes the concept and some implementations (ruby, lisps, etc.) and compare and contrasts them.
16:23:13 <hpc> it's too close to markdown
16:23:39 <jmcarthur> you can just use json in place of yaml if you dislike it
16:24:08 <jmcarthur> or am i crazy?
16:24:14 <jmcarthur> been a while since i thought about markup languages
16:24:37 <jmcarthur> ah, no, i'm not (totally) crazy
16:25:11 <hpc> ah, nifty
16:25:42 <hpc> we should muddy the waters by making yet-another-ML
16:25:46 <hpc> or yaML
16:26:08 <jmcarthur> or we could make a Standard Markup Language
16:26:20 <mgsloan> I like having a stack.yaml around in projects, as it's an indication that "this is the configuration the author used, and really ought to work"
16:26:41 <hpc> that's fair
16:26:48 <hpc> it looks a lot like having cabal files in repos
16:26:52 <jmcarthur> mgsloan: that purpose could be served without breaking my workflow by not calling it stack.yaml
16:27:25 <AfC> mgsloan: yeah, that's what I thought too
16:27:33 <jmcarthur> could be stack.yaml.works-for-me or whatever
16:27:57 <mgsloan> jmcarthur: Interesting point.  So the issue is that you tend to want to replace the default stack.yaml with your own?
16:28:47 <mgsloan> There is the "--stack-yaml my-config.yaml" flag, but I understand that can get verbose
16:28:52 <AfC> Well it only matters in libraries if you're trying to build that library independently, which you really only do to get the test suite. That doesn't impact what you're doing in a project that happens to depend on that library, right?
16:29:14 <jmcarthur> mgsloan: here's an example. a few weeks ago i added the ghc-mod repo to my global stack config so i could install the latest conveniently. however, the repo had a stack.yaml in it, so it built with the wrong ghc, which didn't work out well for me.
16:29:15 <mgsloan> Yeah, if you're depending on the library it shouldn't matter
16:29:31 <jmcarthur> mgsloan: i wanted it to build with the ghc i had in my global stack config
16:30:08 <jake__> shachaf: You mentioned alterF earlier, I don't actually see it anywhere except in a few mailing list posts
16:30:17 <shachaf> Yep, it never actually got in there.
16:30:19 <jmcarthur> mgsloan: if you want the more convenient stack command as the maintainer of the repo you can just symlink stack.yaml -> stack.yaml.whatever and have git ignore stack.yaml
16:30:20 <shachaf> That might be my fault. :-(
16:30:23 <AfC> So I'm going to guess the problem there was using global stack config, rather than just making an empty directory with a stack.yaml to your taste and installing from there?
16:30:26 <shachaf> lens calls it at
16:30:40 <shachaf> But it could be implemented more efficiently from inside Data.Map.
16:31:17 <jake__> ahh
16:31:24 <jmcarthur> AfC: i only get one ghc-mod. i wanted it to work with the majority of my projects. i wanted to be able to say in my global config which one is installed. i wanted to be able to change it by just changing the global config and reinstalling.
16:31:38 <jake__> is the Lens one efficient even though it's not in Data.Map?
16:31:59 <jmcarthur> AfC: but the real problem isn't that i couldn't get what i wanted, but that the behavior was weird.
16:32:08 <jmcarthur> AfC: it took a long time for me to realize it was using the wrong ghc
16:32:12 <mgsloan> jmcarthur: Hmm, AFAIK that isn't how it should work.  If you add ghc-mod to the global stack yaml, then it really should be using the ghc that it specifies
16:32:27 <AfC> Hm
16:32:51 <jmcarthur> mgsloan: well, the github one overrode my global config... even when the github repo was specified *in* my global config.
16:33:06 <jmcarthur> i have no opinion on whether it was correct behavior, and i can imagine some people thinking it did what they would expect
16:33:26 <AfC> I've got a ~/opt/haskell/pandoc directory, for example, and in there a stack.yaml that knows how to build pandoc. I `stack install` and get the resultant binary into ~/.local/bin and ta-da, global. I haven't had much need to mess with the "global stack" fallback.
16:33:36 <mgsloan> Fairly sure that's not correct.  Are you sure there isn't some old ghc-mod on your PATH?
16:33:44 <AfC> (not that I _didn't_ checkout the source from Git there)
16:33:48 <AfC> note*
16:33:50 <mgsloan> Maybe ~/.cabal/bin is getting precedence over ~/.local/bin ?
16:33:50 <jmcarthur> AfC: ah, i just mean i didn't make a clone of the repo and didn't want to. i wanted stack to just do it for me
16:34:24 <jmcarthur> AfC: oh you mean that dir had just the config and nothing else?
16:34:44 <jmcarthur> mgsloan: i'm sure. it was fixed as soon as i cloned the repo and removed the stack.yaml myself
16:34:56 <AfC> jmcarthur: yes
16:34:59 <AfC> jmcarthur: exactly
16:35:17 <jmcarthur> mgsloan: this (building an exe on its own) may be different from when you have a library that depends on the repo.
16:35:24 <AfC> then `stack install pandoc` from that directory 
16:35:27 <jmcarthur> mgsloan: in which case i'd definitely say something it wrong, because it's inconsistent
16:35:53 <jmcarthur> AfC: the thing i don't like about that is having to maintain a whole separate file just for my pandoc install
16:36:07 <jmcarthur> AfC: and i still don't see how that would fix my exact problem
16:36:15 <jmcarthur> AfC: which is that the repo's stack.yaml override mine
16:36:24 <johnw> easter egg idea: have the command "stack overflow" open a browser to the SO discussion about stack
16:37:30 <jake__> shachaf: it seems like traversals in general aren't the right abstraction for modifying maps as many maps don't require traversing the whole thing to find the key? Or is it possible to do that w/in the bounds of a traversal?
16:37:32 <cmccann> johnw: you should open a github issue for that
16:37:43 <mgsloan> johnw: haha :D
16:37:48 <mgsloan> jmcarthur: Can you please open an issue about this?
16:37:53 <shachaf> jake__: traverseWithKey traverses the whole map. alterF is about viewing/modifying one key.
16:38:04 <jake__> ahh
16:38:35 <mgsloan> Anyway, AFAIK, stack.yaml in a directory shouldn't have any effect unless you are running stack commands in a subdirectory.  So, it's quite benign to add them to your repo
16:38:41 <YellowOnion> Does anyone have critiques? http://lpaste.net/141587
16:38:50 <mgsloan> (barring the potential bug we're discussing here, heh)
16:41:41 <mac10688> idIdentity :: Id (a -> a)
16:41:41 <mac10688> idIdentity = MkId $ \x -> x
16:41:57 <mac10688> how to call this function with idIdentity?
16:42:11 <mac10688> everything I try in the repl returns an error
16:43:17 <mac10688> I would have thought it would be something like | idIdentity (\x -> x)
16:44:16 <dmj`> let MkId f :: Id (Int -> Int) = idIdentity in f 1 ?
16:45:58 <YellowOnion> @pl \x -> a x b
16:45:58 <lambdabot> flip a b
16:46:17 <YellowOnion> thought so.
16:46:29 <Lokathor> are "@-patterns" really called "as patterns"? I thought it was "at patterns" because it's an 'at sign'.
16:47:26 <hpc> they're whatever rolls of the tongue faster
16:47:29 <jle`> they are indeed called as patterns
16:48:11 <jle`> https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
16:48:51 <YellowOnion> lpaste's hlint recomended I do (`a` b)
16:48:56 <echo-area> What is ~ called in type annotations?  E.g. (MonadWidget m, HandlerSite m ~ App) => ...
16:49:09 <echo-area> Is it a language extension?
16:49:14 <hpc> type-level equality
16:49:19 <cmccann> according to the INTERCAL reference manual tonsil, @ is pronounced "whirlpool"
16:49:21 <cmccann> so I saw go with that
16:49:27 <cmccann> s/saw/say/
16:49:36 <phaazon> 18:04  * KrzyStar looks at Lenses and runs away
16:49:36 <echo-area> hpc: Thanks, I'll learn it
16:49:38 <phaazon> haha :D
16:49:41 <hpc> ooh, the shirt came today as kind of a funny coincidence
16:49:43 <jle`> it's a constraint that the two types are equal
16:49:51 <hpc> at work we discovered an old mainframe that used @ as the control character
16:49:55 <hpc> but it was called the master space
16:50:05 <hpc> so we made the most inside-joke t-shirt i've ever seen
16:50:11 <cmccann> hpc: oh dear
16:50:22 <hpc> and now i have gone and ruined it
16:50:33 <hpc> so we'll see how long it takes this knowledge to go from irc to irl
16:50:47 <echo-area> jle`: Is it part of haskell2010?
16:51:04 <shirt> hpc: eh?
16:51:22 <hpc> haha
16:51:43 <hpc> shirt: welcome to my life when people mention haskell program coverage
16:52:30 <cmccann> I remember there used to be (?) someone here with a nick that looked like one of GHC's generated type variable names
16:52:37 <cmccann> I'm pretty sure they got pinged a lot 
16:52:41 <hpc> hah
16:52:42 <elbiot> I have a simple question about modules...
16:52:49 <dmj`> hpc lol
16:52:58 <dmj`> elbiot: ask away
16:53:18 <lpaste> elbiot pasted “export type class” at http://lpaste.net/141590
16:53:32 <radens> What's wrong with this function? let test :: [String]-> [String]; test [f, "(", l] = l
16:53:56 <elbiot> How do I use the showsvg method of Line in a file that imports this?
16:53:58 <jle`> radens: it's partial, which might not be desirable
16:54:03 <hpc> radens: l :: String, but your type signature says it should be [String]
16:54:07 <scshunt> ^
16:54:10 <jle`> oh i see
16:54:20 <echo-area> It looks like ~ is enabled by either GADTs or TypeFamilies
16:54:29 <hpc> also you likely want more cases, but that's not going to stop it compiling and you might be safe with just that
16:54:33 <elbiot> Do I export ShowSVG? do I export showSVG?
16:54:48 <radens> Ah
16:54:57 <ski> Lokathor : it's spelled `as' in the MLs
16:55:06 <radens> Is there a way to make l represent the rest of the string?
16:55:16 <jle`> rest of the list?
16:55:24 <lpaste> toytoy pasted “find max arity in tree” at http://lpaste.net/4281598948298194944
16:55:31 <jle`> test (f:"(":l) = l , you mean?
16:55:44 <scshunt> jle`: (f:'(':l)
16:55:54 <radens> jle`: yep that's what I meant
16:56:02 <lpaste> toytoy revised “find max arity in tree”: “No title” at http://lpaste.net/4281598948298194944
16:56:03 <jle`> scshunt: that'd be String -> [String]
16:56:15 <scshunt> jle`: oh right
16:59:50 <radens> jle`: okay, how smart is haskell? Can I make a function matcher with this sort of a form? String:"(":StringList:")":StringList?
17:00:18 <jle`> pattern matching in normal haskell is structural
17:01:04 <radens> I don't follow
17:01:53 <toytoy> can anyone help me with: http://lpaste.net/4281598948298194944 ?
17:01:55 <jle`> it works because a list is literally just a constructor (:) with two fields: a head and a tail
17:02:21 <radens> okay
17:02:22 <jle`> it's not really a "smart" process...it's just on the actual structure of the list  in-memory
17:02:42 <radens> I knew it was a stretch, but it would be awfully convenient if it did work that way.
17:02:44 <jle`> it's like matching on a tuple
17:03:00 <jle`> f (x,y) = x works, because a tuple is just structurally a pairing of two values with (,)
17:03:19 <jle`> (:) is just a pairig of two values, in the same way
17:03:25 <jle`> (x:xs)
17:03:56 <radens> That's kind of neat
17:05:08 <ttt_fff>   lst <- many ((tokenTerm <|> tokenBinop <|> tokenSeparator) <* mySpaces0) <-- how do I modify this to say (1) two terms must be separated by a space, and (2) two binops can not be adjacent
17:06:30 <elbiot> Never mind.  I figured it out!
17:15:56 <rhz> Is there any reason we cannot use list comprehension notation with other data structures, such as sets?
17:16:16 <Welkin> rhz: you could overload it, sure
17:16:20 <hpc> oh that's a fun question
17:16:39 <roconnor> rhz: something about the Ord constraint.
17:16:42 <hpc> so, list comprehension syntax is a special form of do-notation, which is sugar for (>>=) and return
17:16:50 <hpc> which is general to any Monad
17:17:08 <hpc> Set can't be Monad because of stuff to deal with Ord and uniqueness of elements
17:17:16 <hpc> (iirc)
17:17:56 <hpc> actually yes
17:18:19 <hpc> to be a bit more specific, Set isn't even a Functor because it gets in trouble with fmap
17:19:09 <awpr> more practically, you can just use S.fromList [(x, y) | x <- [1..10], y <- [1..10]].  most containers tend to have a fromList function in their module.
17:19:10 <hpc> like
17:19:23 <S11001001> so when are we gonna get PolyRoles, y'all?
17:19:24 <hpc> you couldn't do (fmap openFile) on a (Set String)
17:20:39 <hpc> some containers have annoying ways of building them however, so you have to be careful
17:21:39 <hpc> like Vector
17:21:41 <hpc> http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#g:7
17:22:03 <c_wraith> I've never bothered to figure out.. How well does fmap (const ()) work with the functors laws and sets with a theoretical fmap? 
17:22:32 <hpc> c_wraith: it should just be S.fromList [()]
17:22:36 <c_wraith> Like, does changing cardinality break the functor laws? 
17:22:51 <arkeet> no, it's not about laws
17:22:57 <roconnor> @free length
17:22:58 <hpc> i think it could be an indexed Functor and work out fine
17:22:58 <lambdabot> Extra stuff at end of line in retrieved type "Foldable t => t a -> Int"
17:23:05 <roconnor> @free Data.List.length
17:23:06 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
17:23:11 <arkeet> it's just that fmap needs to work with any function type, and you can only build Sets of types with an ordering
17:23:16 <roconnor> @free [a] -> Integer
17:23:16 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
17:23:19 <roconnor> damn it
17:23:20 <hpc> but for the prelude classes it's about the polymorphism, yeah
17:23:25 <roconnor> @free length :: [a] -> Integer
17:23:25 <lambdabot> length = length . $map f
17:23:36 <arkeet> :t S.map
17:23:37 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
17:23:57 <roconnor> c_wraith: so yes, it does break the naturality laws.
17:24:15 <awpr> arkeet: yeah, that's one practical reason it's not possible, but that map function also can't satisfy the law that map f . map g == map (f . g)
17:24:21 <arkeet> why not?
17:24:45 <arkeet> do you have a counterexample?
17:25:26 <roconnor> c_wraith: actually ... I take that back.  With the ord constraint, we wouldn't expect the free theorem to hold.
17:25:42 <roconnor> @free OrdLength :: (a -> a -> Bool) -> [a] -> Integer
17:25:42 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
17:25:48 <roconnor> @free ordLength :: (a -> a -> Bool) -> [a] -> Integer
17:25:48 <lambdabot> (forall x. g x = h (f x) . f) => ordLength g = ordLength h . $map f
17:26:37 <awpr> if the Ord instance does unintuitive things (which it's allowed to), f can map different values onto two "equal" values that g maps to different values.
17:26:51 <Shockk> quick question about Haddock
17:26:52 <roconnor> (forall x y. g x y = h (f x) (f y)) => ordLength g x = ordLength h (f x)
17:27:11 <Shockk> on this page for example https://hackage.haskell.org/package/containers-0.5.6.2/docs/Data-Map-Lazy.html
17:28:07 <roconnor> (forall x y. g x y = h (f x) (f y)) => ordLength g x = ordLength h (fmap f x)
17:28:17 <roconnor> c_wraith: I guess it says "for any injective monotonic map, we'd exect the cardinality to remain the same."
17:28:20 <Shockk> I notice in the source, there are comments for each section in the table of contents, and there are also matching section name comments at the points in the code itself
17:28:28 <roconnor> c_wraith: which is true for sets.
17:28:40 <Shockk> which of these actually tells Haddock what to put in the Contents table?
17:29:10 <awpr> Shockk: the table of contents is based on the stuff in the module export list
17:29:20 <Shockk> awpr: ahh, thanks
17:32:19 <Rusky> @pl \x x + sin x
17:32:19 <lambdabot> (line 1, column 6):
17:32:19 <lambdabot> unexpected "+"
17:32:19 <lambdabot> expecting pattern or "->"
17:32:22 <Rusky> @pl \x -> x + sin x
17:32:22 <lambdabot> ap (+) sin
17:33:04 <Shockk> :t ap
17:33:05 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:33:21 <anelson> hey guys, I'm trying to define a package which has a library and an executable. The executable is exactly the same as the library but with a Main module. I tried to write a cabal file that lets me just put the library as a dependency of the executable, and then the only module the executable would need is Main. But that doesn't seem to work. Is there a way to do this? Also, doing `cabal build` builds all of the modules twic
17:33:21 <anelson> the library and once for the executable (again for the test suites if I'm running those)
17:38:04 <birmjin> part
17:38:12 <birmjin> \part #haskell
17:39:47 <barrucadu> birmjin: It's /part
17:40:32 <geekosaur> they figured it out. and then rejoined
17:40:37 <barrucadu> Ah
17:41:04 <barrucadu> I have joins/parts disabled, so I just saw that they were still here
17:44:30 <Shockk> just going to throw this here; it'd be great for Haddock to show kind signatures involving operators or things like (,) as you'd normally write them when writing such a kind signature
17:45:04 <Shockk> for example [(*, * -> *)] is generated by Haddock as:   (,) * (* -> *)
17:45:09 <Shockk> er
17:45:26 <Shockk> as: [] ((,) * (* -> *))
17:46:31 <vedder-> hey
18:08:15 <Romefeller> Hi all
18:22:53 <ski> Romefeller : lo yourself
18:32:40 <Romefeller> anyone alive??
18:32:43 <Shockk> me
18:33:04 <c_wraith> I'm undead. Is that close enough? 
18:33:05 <flippant> is there anyway to turn IO (IO a) into IO a ?
18:33:14 <flippant> or should i restructure my code?
18:33:15 <Romefeller> Haskell has a headless browser? Like Phatomjs
18:33:21 <Romefeller> join
18:33:33 <flippant> thanks
18:34:26 <Shockk> is join implemented like action >>= id?
18:34:35 <c_wraith> I don't know of any published headless browsers 
18:34:36 <Shockk> @src join
18:34:36 <lambdabot> join x = x >>= id
18:34:39 <Shockk> :D
18:34:53 <flippant> Romefeller: is there no selenium library?
18:35:04 <Romefeller> i cant find anything
18:35:11 <Romefeller> i need to do some scraping
18:35:24 <flippant> do you need javascript support?
18:35:37 <Romefeller> No. I want to do this in Haskell
18:35:40 <dmj`> @package webdriver
18:35:40 <flippant> if you don't, you can use handsomesoup
18:35:40 <lambdabot> http://hackage.haskell.org/package/webdriver
18:35:51 <flippant> which is what im currently using
18:35:54 <flippant> hxt + handsomesoup
18:36:03 <Romefeller> lol thx lambda
18:36:08 <Romefeller> smart bot
18:36:27 <Romefeller> i was using conduit
18:36:42 <Romefeller> but some ajax request is hard to do
18:37:20 <Romefeller> filppant hxt?
18:39:00 <dmj`> @package shpider
18:39:01 <lambdabot> http://hackage.haskell.org/package/shpider
18:40:32 <flippant> Romefeller: http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html
18:41:12 <felixn> > evalState (runListT (do { s <- lift get; x <- ListT (return s); return (x * 2); })) [1,2,3]
18:41:14 <lambdabot>  Not in scope: ‘runListT’Not in scope: data constructor ‘ListT’
18:41:19 <felixn> "s <- lift get; x <- ListT (return s);" <-- is it possible to do that in one statement?
18:41:38 <felixn> my linter usually tells me how to write more succinct code, but not this one :D
18:43:21 <roconnor> x <- ListT . return =<< lift get
18:43:38 <felixn> ahhh thanks!
18:43:48 <roconnor> notice the cool looking long arrow
18:43:56 <roconnor> skewering ListT . return
18:45:28 <felixn> what if you saw someone do "x <- lift get >>= ListT . return", what would you think of that person?
18:45:48 <Shockk> when specifying a module export list, if I want to export instances for a type, do I just export S.Set()?
18:47:09 <roconnor> felixn: I would think that they like effects to read from left to right.
18:47:16 <roconnor> like a norma person
18:47:29 <roconnor> and they don't like cool arrows.
18:47:39 <Shockk> oh wait I don't need the ()
18:48:18 <roconnor> Shockk: I think you don't need anything.  instances are always exported I think.
18:48:38 <felixn> roconnor: haha, so you're not normal?
18:48:56 <Shockk> roconnor: ahh I see
18:49:03 <Shockk> I was misinterpreting errors
18:49:10 <roconnor> felixn: I've gotten used to the backwards f(g(x)) notation of math.
18:49:35 <roconnor> it has some advantages, especially in light of lazy evaluation.
18:49:40 <felixn> [1..10] |> filter (> 3) >>> map (* 2) <-- actually, that brings up, is there a way I can do this?  is there operator that I can use (|>) ?  I don't want to define it
18:49:52 <roconnor> Did you the commands in the state monad are processed bottom to top?
18:50:56 <roconnor> I think |> is the same as >>=.  Maybe it is a precedence issue.
18:51:26 <flippant> hi there
18:51:38 <flippant> sorry i didn't give the right type signature earlier
18:51:39 <roconnor> oh maybe |> is $>
18:51:53 <arkeet> |> is just flipped function application no?
18:52:02 <roconnor> oh, so it is &
18:52:02 <flippant> i want to go from IO(IO [a]) to IO [a]
18:52:14 <roconnor> @type join
18:52:15 <lambdabot> Monad m => m (m a) -> m a
18:52:23 <flippant> join should work for that?
18:52:28 <roconnor> yep
18:52:30 <flippant> im debugging right now
18:52:31 <flippant> thank you
18:53:11 <Shockk> it's satisfying when I make a relatively big rework to my codebase,
18:53:29 <kyfho> how do haskell web apps become tolerant of vm faults?
18:53:32 <Shockk> and I do cabal build and then cabal test and I watch it finally compile without warnings 
18:55:49 <felixn> roconnor: can I import (&) somewhere?  it's sounds really familiar, I've looked this up quite a few times
18:57:21 <flippant> actions :: [IO a] ; return $ join . sequence $ actions
18:57:30 <flippant> any idea why that wouldn't work?
18:57:38 <geekosaur> felixn, Data.Function in 7.10, otherwise lens
18:57:55 <flippant> oh wait nvm. i think i've figured it out
18:58:06 <Romefeller> @type sequence
18:58:07 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
18:58:31 <felixn> geekosaur: wow thanks, wasn't sure if I was tripping that I remember reading about (&) being added, weird that it's not in Hoogle
18:58:40 <dmj`> kyfho: vm faults?
18:58:41 <kyfho> anyone doing web aps in haskell?
18:58:42 <Shockk> in the case of [IO a], [] is the Traversable and IO is the Monad
18:58:46 <kyfho> yeah liek if a vm goes down
18:58:53 <Shockk> felixn: I wondered that too
18:58:56 <Romefeller> sequence $ action is IO [a]
18:58:59 <Romefeller> right?
18:58:59 <dmj`> kyfho: what vm ? 
18:59:00 <kyfho> assuming you do a bit of horizonal scaling
18:59:13 <kyfho> liek one running a php appserver say cherokee and php
18:59:25 <kyfho> with users on my cool iste trying to buy stuf
18:59:27 <Romefeller> join you use when you need to glue two containers
18:59:35 <awpr> felixn: it shows up on Stackage's Hoogle instance at least.  I've been using that for everything recently.
18:59:47 <Shockk> Romefeller: sequence (actions :: [IO a]) is IO [a]
18:59:55 <Romefeller> yeah
19:00:07 <Romefeller> he dont have IO (IO [a])
19:00:11 <Romefeller> join is useless
19:00:15 <dmj`> kyfho: how does any process survive a machine failure ? 
19:00:27 <dmj`> how is that haskell specific
19:00:35 <Romefeller> what return do you need?
19:00:55 <Shockk> dmj`: we need hardware that runs on haskell at the hardware level of course
19:01:32 <Shockk> runAction (Left GraphicsCardOnFire) = error "toast"
19:01:48 <felixn> awpr: thanks, didn't want to switch because hoogle is so pretty.  it will be missed!
19:02:13 <roconnor> I think (&) is in recent versions of Data.Function
19:02:26 <ski> felixn : which `ListT' is this ?
19:02:49 <kyfho> I dunno
19:03:02 <Shockk> stackage also doesn't have a Search plugin thingy
19:03:03 <felixn> ski: bro, I can't even lift, how would I know that?
19:03:03 <roconnor> felixn: I think (&) is in recent versions of Data.Function
19:03:08 <kyfho> I am not master of web app creation
19:03:16 <kyfho> any more than being a pikup artist
19:03:26 <Shockk> so I can't type `hoogle whatever' into my bar :(
19:03:27 * hackagebot webdriver 0.6.3 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.6.3 (AdamCurtis)
19:03:37 <felixn> webdriver++
19:03:53 <awpr> Shockk: for Chrome?  I have it registered as a search engine just fine -- it's no harder than haskell.org Hoogle, just a different URL
19:03:58 <felixn> though it's ironic how buggy it is for being a testing tool
19:04:10 <Shockk> awpr: hmm, I don't know how to do it manually for firefox
19:04:15 <dmj`> kyfho: haskell is a good choice for making web apis, regardless of machine failure
19:04:39 <kyfho> ya?
19:04:53 <kyfho> whats best way learn haskell if I know only shell sofar?
19:05:06 <kyfho> good news is I know 0 java
19:05:09 <kyfho> ;)
19:05:14 <Romefeller> thats a start
19:05:31 <Romefeller> kyfho Learn you a haskell for a great good. 
19:05:33 <Shockk> kyfho: as far as persistent state that's safe across events like power loss, there's a package called acid-state that I've used before
19:06:07 <kyfho> happstack looks liek a dream come true for web
19:06:14 <dmj`> kyfho: you've come to the right place, I'd say stick around here, read haskell reddit, write a lot of bad haskell code while reading LYAH, RWH, CIS194, Typeclassopedia and Parconc
19:06:14 <kyfho> any e commerce sites using it?
19:06:20 <felixn> kyfho: I recommend Atom + Haskell IDE plugin, a good tools makes things easier.  in this case, it's nice to see errors as you work in your code, as well as helpful linting suggestions
19:06:33 <dmj`> kyfho: this SO post is a good road map for the journey
19:06:35 <kyfho> cis194?
19:06:38 <dmj`> kyfho: http://stackoverflow.com/questions/1012573/getting-started-with-haskell
19:06:40 <Romefeller> I use eclipse
19:06:47 <kyfho> parconc?
19:06:53 <dmj`> kyfho: http://www.seas.upenn.edu/~cis194/
19:07:00 <awpr> kyfho: Standard Chartered is a bank in England that uses it to great effect.  not exactly e-commerce, but related
19:07:04 <dmj`> kyfho: http://chimera.labs.oreilly.com/books/1230000000929
19:08:03 <Shockk> kyfho: not exactly e-commerce either, but imvu and facebook use it behind the scenes 
19:09:15 <ski> felixn : i was wondering whether it's `transformers', or `list-t' or something else
19:09:18 <radens> Is it unhaskellic to return 2 tuples?
19:09:31 <awpr> I'm not sure I'd recommend worrying about making web servers fault-resilient as a first foray into software development.  maybe just a single-instance web app at first?
19:09:39 <kyfho> sounds like haskell, prolog, lisp, smalltalk could all be more productive than other things
19:09:43 <Shockk> radens: like ((a, b), (c, d, e))?
19:09:55 <radens> return (Ast { typ=If, children=[cond, body] }, rest)
19:10:03 <kyfho> It would be dream come true to make money at a statup using something cool like one of those
19:10:15 <Romefeller> kyfho im having it here in Brazil
19:10:24 <kyfho> yes?
19:10:27 <Romefeller> kyfho me and 3 students of mine
19:10:31 <Romefeller> yeah
19:10:42 <ski> radens : no
19:10:43 <kyfho> I heard some nice looking models there
19:10:52 <kyfho> data models of course
19:11:08 <ski> radens : though perhaps you could use `State' instead ..
19:11:13 <dmj`> Romefeller: do you guys have a public website?
19:11:16 <Shockk> kyfho: I know two people (I think, although might be only one of them) who work at imvu and I think they got roles related to haskell
19:11:28 <dmj`> kyfho: facebook uses haskell
19:11:31 <Romefeller> dmj` working on that
19:11:47 <dmj`> Romefeller: nevertheless, very cool ! 
19:11:47 <Romefeller> dmj` we just started. Buyed domains and stuff
19:11:59 <radens> ski is state a monad I should look at?
19:12:09 <Shockk> radens: yes
19:12:11 <dmj`> Romefeller: using ghcjs? Just curious
19:12:33 <Romefeller> dmj` Firstly Yesod.
19:12:36 <Shockk> radens: look at, definitely, if only to see what it does
19:12:37 <felixn> radens: let's you return something, with context (state!)
19:12:47 <radens> ah
19:12:58 <radens> that sounds exactly like what I want
19:13:10 <Romefeller> dmj` we are looking into Haste/Ghcjs to pic the best one
19:14:25 <Shockk> this is an interesting read
19:14:26 <Shockk> https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/
19:15:35 <Romefeller> Haskell community people is far more nicer than Java or PHP
19:15:39 <Romefeller> lol
19:16:00 <Shockk> because we have...
19:16:03 <Shockk> ..good types
19:16:06 <Romefeller> lol
19:16:16 <dmj`> Romefeller: it's so true, far more humble and intelligent. Academia seems to be that way, compared to industry. Haskell is closer to academia it seems
19:16:30 <Romefeller> dmj`yeah
19:16:38 <glguy> Yeah, definitely more humble, probably the most humble
19:16:40 <kyfho> lolz
19:16:50 <bitemyapp> glguy: how good are you at QuickCheck>
19:16:58 <Romefeller> i think beacause we know that Haskell is not a piece of cake
19:17:05 <glguy> I'm not as quick at it as quickcheck is
19:17:09 <Romefeller> and the others is lol
19:17:13 <dmj`> glguy: haha :)
19:17:15 <Shockk> ar*
19:17:16 <Shockk> are*
19:17:21 <Shockk> I messed up my correction
19:17:58 <glguy> bitemyapp: I don't use it much, but I'm happy to take a shot at a question if you have one
19:18:04 <dmj`> bitemyapp: ask me ! :P 
19:18:09 <bitemyapp> glguy: using Fun from Test.QuickCheck.Function
19:18:10 <Shockk> also using Haskell is certainly as nice as eating cake once you get properly into it, compared to other language
19:18:12 <Shockk> s
19:18:18 <bitemyapp> (a -> b) is fine, (a -> m b) is fine
19:18:22 <ski> radens : yes. also `Writer',`Reader',`Maybe',`Either',`[]',`Cont'
19:18:25 <Shockk> it's a joy to program in
19:18:29 <bitemyapp> those are Fun a b  and    Fun a (m b)   respectively.
19:18:33 <bitemyapp> but uh, applicative?
19:18:37 <bitemyapp> f (a -> b)    <--- wut
19:18:48 <Romefeller> Shockk agreed. No misconceptions. OOP has A LOT of misconceptions
19:19:04 <kyfho> how do I learn to write nice haskell code as a beginner to programming and functional programming?
19:19:25 <Romefeller> ask 10 OOP guys what is polymorphism. Probably you will get 10 different answers.
19:20:04 <ski> kyfho : with practice and reading
19:20:18 <dmj`> kyfho: I'd read a lot of code from experienced haskellers and papers, and attempt to write it on your own. Then use what you've learned to write your own ideas, and ask questions here. It's hard to not write bad code in the beginning
19:20:19 <glguy> bitemyapp: I agree that that doesn't look like it's going to fit within Fun...
19:20:27 <bz> which other typeclassses are as useful and ubiquitous as F/A/M?
19:20:31 <glguy> I guess the real question is how best to test it with quickcheck?
19:20:38 <Shockk> just the fact that defining an error type like: data BuildingError a = GoneTo Place | BurntDown | TooSmallBy a
19:20:55 <dmj`> bz: Monoid, IsString, Show, Eq, Ord, Bounded, Enum, Arbitrary
19:20:57 <bitemyapp> glguy: I'm quickchecking Applicative laws.
19:21:00 <Shockk> is so concise in haskell compared to anything in C++ or Java or etc
19:21:00 <ski> bz : `Traversable', and also `Foldable'
19:21:11 <bitemyapp> glguy: I'd like to maintain a consistent style and I'd generated the Functor and Monad functions automatically.
19:21:13 <Romefeller> yeah
19:21:20 <Romefeller> I was into Java
19:21:33 <Romefeller> I loved Java. Like a marriage.
19:21:42 <Romefeller> When I met Haskell lol
19:21:50 <ski> bz : `Typeable' is good to know about, even though you seldom use it
19:21:57 <bitemyapp> dmj`: please pipe up if you know :)
19:21:59 <Romefeller> cheated
19:23:17 <Romefeller> kyfho start with simple functions. And use a lot of ghci
19:23:22 <dmj`> bitemyapp: quickspec should be able to derive proofs of laws from types... I think
19:23:39 <Pamelloes> dmj`: What's Arbitrary? I've never heard of it...
19:23:48 <ski> bz : adding to dmj`s, you should know about `Ix' as well
19:24:01 <ski> Pamelloes : `Arbitrary' is used with `QuickCheck'
19:24:04 <bz> ski: is that the one from Data.Array?
19:24:08 <ski> bz : yes
19:24:21 <bitemyapp> dmj`: this isn't for work mate
19:24:42 <bitemyapp> dmj`: I'm writing QuickCheck into the MFAM sequence, I'd like something small and simple.
19:24:43 <Romefeller_> dc
19:24:46 <ski> @type range  -- can often be useful
19:24:47 <lambdabot> Ix a => (a, a) -> [a]
19:24:59 <ski> bz : oh, also `Random'
19:25:07 <bz> that's just Enum, though
19:25:14 <ski> bz : .. and `Read'
19:25:48 <bz> :t fromToEnum
19:25:49 <lambdabot>     Not in scope: ‘fromToEnum’
19:25:49 <lambdabot>     Perhaps you meant ‘fromEnum’ (imported from Prelude)
19:25:58 <ski> > range ((0,0),(2,2))  -- this is not just like `Enum'&`Bounded'
19:25:58 <awpr> :t enumFromTo
19:25:59 <lambdabot> Enum a => a -> a -> [a]
19:26:00 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
19:26:05 <dmj`> bitemyapp: is your Applicative for Fun a b defined using `return` and `ap`
19:26:28 <bz> so every enum is trivially ix. i wonder if there are ix instance that aren't enum.
19:26:48 <glguy> (Int,Int) is an Ix instance and not ENum
19:26:48 <dmj`> Pamelloes: Arbitrary is awesome
19:27:37 <ski> bz : also, if you every manually write `Show' and `Read' instances, you should know how to do it properly, defining `showsPrec'&`readsPrec' using `showParen'&`readParen',`shows'&`reads',`showChar',`showString',`lex'
19:27:42 <ski> s/every/ever/
19:28:30 <Pamelloes> Hm, maybe I should look into Quickcheck...
19:29:04 <ski> you should, even if only to get an idea of what it's for
19:29:05 <dmj`> Pamelloes: so any type that has an Arbitrary instance can be gen'd automagically. It works nicely with newtype deriving
19:29:18 <dmj`> :t generate arbitrary
19:29:19 <lambdabot> Arbitrary a => IO a
19:29:32 <dmj`> Pamelloes: then you can just get whatever you want out of IO
19:29:43 <dmj`> :t generate arbitrary :: IO (Int, String, Integer)
19:29:44 <lambdabot> IO (Int, String, Integer)
19:30:03 <Pamelloes> > generate arbitrary :: IO (Int, String, Integer)
19:30:04 <lambdabot>  <IO (Int,[Char],Integer)>
19:30:13 <Pamelloes> errr
19:30:16 <glguy> bitemyapp: To be able to use this Fun to test your Monad instances you already have to be able to generate arbitrary values of the monad type
19:30:43 <glguy> why can't you just use that as is? Where do functions feature?
19:31:32 <Gurkenglas> dmj`, Quickspec quickchecks all the possible laws, so it doesn't prove anything, it just disproves as much as possible and shows you the rest. (Except that it does a little work to remove redundant laws by deriving them from the rest)
19:31:43 <Shockk> what's the formal name for a [*]?
19:31:46 <Shockk> a kindlist?
19:32:45 <athan> Wait, so monad-control is like a way to lift arbitrary sub-monadic computations (for a transformer stack), but from the top-down? And you don't just have to do one step, like `lift`?
19:33:09 <dmj`> Gurkenglas: I see, hmm
19:34:11 <dmj`> athan: it's like inception
19:34:23 <ski> Pamelloes : the lambdabot `run' command doesn't execute I/O
19:34:43 <athan> dmj`: Burritos for you
19:34:48 <Pamelloes> ski: Yep :)
19:34:49 <ski> Shockk : "list of types" ?
19:34:52 <athan> meta burritos
19:35:07 <athan> ^ yep
19:35:24 <ski> Shockk : list of concrete/inhabitable types, if you want to be more specific
19:35:25 <athan> Shockk: People often pronounce * as "Type"
19:35:33 <athan> or well-valued type
19:35:46 <ski> oh
19:35:53 * ski likes "well-valued" :)
19:36:06 <athan> :D
19:36:07 <Shockk> ski: hmm I guess type list would fit where I'm putting it I think
19:36:30 <Shockk> athan: I read about that the other day when I looked up the wikipedia article on kinds (category theory)
19:36:31 <awpr> athan: my intuition for it is that it gives something like "lift" but with the additional capability to re-enter the containing MonadControl within the lifted computation.
19:36:49 <Gurkenglas> I'm a little sad Quickspec doesn't have a thing to automatically generate a test file from a hackage module. That would immediately produce a global power multiplier for the entire ecosystem, like hlint and that new herbie thing.
19:37:01 <ski> Shockk : kinds aren't a concept from category theory, though
19:37:19 <Shockk> hmm where did I read this
19:37:33 <Shockk> https://en.wikipedia.org/wiki/Kind_(type_theory)
19:37:37 <Shockk> oh type theory not cat theory
19:37:43 <athan> Shockk: If you really want to leapfrog, read "Lambda Calculi with Types"
19:38:20 <athan> awpr: That is amazing, thank you for the insight :)
19:38:44 <Shockk> athan: that sounds.. interesting
19:40:57 <athan> Gurkenglas: ermagersh quickspec :O
19:42:33 <bitemyapp> glguy: that's not a blocking issue atm
19:42:43 <bitemyapp> glguy: the problem is   f (a -> b)
19:43:09 <dmj`> athan: biggest win from monad-control is the ability to fork threads and not escape into I/O forever, but retain the monad
19:43:10 <dmj`> imo
19:43:11 <Gurkenglas> A while back I wanted to write a package that does what quickspec does and apply it to everything and push to get the laws added to haddock or something, then I was told of quickspec on the relevant haskell thread, and i thought all that was already underway. It isn't! It's like I'm in a pen and paper RPG and the game master is desperately trying not to have the NPCs munchkin
19:43:20 <Shockk> would it be considered bad form to match the style of a package like containers, to the functions exposed (roughly) as well as their documentation?
19:44:23 <athan> dmj`: What the beans...
19:44:29 <dmj`> athan: I guess that's more what lifted-base gives you
19:44:31 <athan> can you write me a quick paste? :D
19:44:33 <dmj`> lifted-async too
19:44:52 <athan> that sounds rediculously warlock-ish
19:45:40 <Shockk> I don't know if doing so would be considered bad form, or just trying to be consistent
19:46:01 <athan> Shockk: Not at all, imo - I feel like it's a common interface people expect
19:46:35 <Shockk> athan: that's my thinking, I wasn't sure though because it was just my own thinking
19:46:36 <dmj`> athan: it is, you have to define another type, fork to it, then synchronize back from it. The instance has an associated type family, so you can't newtype derive it like everything else
19:46:37 <awpr> athan: the basic concept is that liftWith captures all the extra stuff on top of IO and wraps it up in a package that lets you un-lift things.  that package (the Run t) can be used in other threads just like any other value
19:47:33 <awpr> e.g. if you're talking about ReaderT, the Run ReaderT is essentially a closure holding the context value
19:49:01 <Axman6> Gurkenglas: I don't understand your point, but you did pretty much describe QuickSpec
19:49:14 <awpr> if it sounds like voodoo, remember that not every MonadTrans is a MonadTransControl.  e.g. I'd be surprised if ConduitM could have a MonadTransControl instance.
19:50:11 <dmj`> athan: https://github.com/snapframework/snap-core/blob/master/src/Snap/Internal/Core.hs#L344
19:52:22 <bitemyapp> dmj`: ffs
19:52:29 <bitemyapp> dmj`: that fucker is why we had to upgrade to 1.0
19:52:46 <bitemyapp> bcuz mapConcurrently with Snap actions.
19:52:50 <bitemyapp> fuck that was annoying
19:54:11 <dmj`> bitemyapp: yes, *very* annoying
19:57:33 <cmccann> Shockk: if you're writing a module defining a type with a maplike or setlike API then yes, by all means imitate containers
19:58:01 <Shockk> cmccann: that's pretty much what I'm doing, thanks
19:58:50 <cmccann> I guess ideally there'd be some sort of type class for that but trying to define one always ends up death by a thousand cuts with fiddly details and at least one "obvious" instance that's horribly wrong somehow
20:00:12 <cmccann> you'd end up with something ugly like Foldable, except even worse and without Traversable to retroactively justify its existence
20:00:15 <Shockk> a typeclass also wouldn't work for my use case because I vary from the usual function signature for some of them
20:00:24 <bitemyapp> cmccann: that doesn't sound like a good candidate for typeclasses at all.
20:00:39 <Shockk> like member :: Proxy n -> TypeAt n (MapFst as) -> PolyMap as -> Bool
20:00:54 <dongerlord> Haskell is shit, COBOL is way better
20:01:07 <dongerlord> Just thought I'd share my opinion
20:01:17 <Shockk> dongerlord: thanks
20:01:20 <bitemyapp> dongerlord: thank you
20:01:29 <cmccann> bitemyapp: a bunch of types that all define what are conceptually the same operations and want to use the same name?
20:01:56 <cmccann> that's pretty much all Num is, and as much as I dislike the design of Num I wouldn't want to get rid of it
20:02:08 <bitemyapp> cmccann: for fiddly reasons, not because it's not convenient.
20:02:26 <bitemyapp> cmccann: can you remember where past conversations were had on this?
20:02:35 <cmccann> not off the top of my head
20:02:57 <bitemyapp> nuts, thanks anyway.
20:03:28 <cmccann> I know I've heard people suggest it before and have it shot down for several good but nonobvious reasons
20:03:30 * hackagebot webdriver 0.6.3.1 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.6.3.1 (AdamCurtis)
20:04:13 <cmccann> and at least once I wrote a convenience class for vaguely maplike things to use internally in a project and even with no attempt at generality I hit multiple irritating corner cases 
20:08:30 * hackagebot language-c-quote 0.11.0.1 - C/CUDA/OpenCL/Objective-C quasiquoting library.  https://hackage.haskell.org/package/language-c-quote-0.11.0.1 (GeoffreyMainland)
20:12:14 <kyfho> I can get ghc 7.10.2 on freebsd 10.2
20:12:26 <kyfho> will cabal work on freebsd and let me install whatever else?
20:14:29 <Zemyla> Hmm, is there a dual of Foldable and Traversable for Contravariants?
20:15:13 <awpr> kyfho: I assume it will work since I know of a few packages that have FreeBSD-specific cabal config.  some things might fail though, since it's a less popular build environment
20:15:48 <Shockk> [(type, storage type)]
20:15:54 <Shockk> "-- |A polymap whose sides are defined by a list of types zipped with storage types."
20:16:19 <Shockk> does this sound like an accurate (and helpful) description of that list?
20:22:14 <farra_000> Hello. What is the description for this channel?
20:22:20 <farra_000> Im on an ipad so i cant see
20:23:23 <farra_000> Nvm
20:23:32 <farra_000> I need some help with my haskell code
20:24:25 <awpr> Zemyla: maybe an implementation of sequenceA with a Divisible constraint instead of Applicative is what you're imagining?
20:24:35 <awpr> :t sequenceA
20:24:36 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
20:25:04 <Zemyla> awpr: Not really. Hmm, actually, I can't figure out how a contravariant foldable would work.
20:26:01 <Gurkenglas> Zemyla, I am reminded of http://stackoverflow.com/questions/23855070/what-does-a-nontrivial-comonoid-look-like , since comonoids would probably be what a cofoldable would run on
20:27:01 <Gurkenglas> (But a general recipe on how to construct co-x would be nice.)
20:27:32 <farra_000> I think john harrop has a decent lecture about constructing co-x 
20:27:54 <farra_000> However, dont forget to 
20:28:05 <farra_000> Check the contravariant
20:28:14 <Shockk> finally threw it at hackage in its current state 
20:28:18 <Shockk> |https://hackage.haskell.org/package/polymap-0.1.0.0/docs/Data-PolyMap.html
20:28:31 * hackagebot polymap 0.1.0.0 - Polydirectional maps  https://hackage.haskell.org/package/polymap-0.1.0.0 (Shockk)
20:28:37 <kyfho> is archlinux the best distro for haskell support?
20:32:14 <glguy> It generally doesn't matter because people tend not to use the packages provided by the distribution but install packages using cabal or stack 
20:32:20 <glguy> to their user-account or sandboxes
20:33:12 <cmccann> or to the global package DB, but usually they only do that once
20:33:13 <echo-area> But for scripting the packages in the distro are used
20:33:52 <echo-area> (Not to argue with that here; I do cabal install too)
20:34:44 <echo-area> *argue about
20:35:43 <kristof> In a sentence, why do you like Servant?
20:45:00 <dmj`> kristof: Servant is nice because auto-generation of http clients simplifies / ensures correctness of writing tests against against a web server (generated from the same api spec)... type safe routing ensures handlers never get out of sync either
20:45:37 <kristof> "type safe routing"?
20:46:06 <dmj`> kristof: routes aren't strings, but type level literals
20:46:15 <kristof> Oh, that's different.
20:46:36 <dmj`> kristof: how so
20:46:50 <kristof> No, I meant, that's different from the status quo of matching against routes.
20:47:12 <kristof> *matching against strings.
20:47:16 <dmj`> oh yes, indeed. 
20:47:55 <dmj`> kristof: It lets you delete a ton of code. Code base halved in size from the previous framework
20:48:00 <Shockk> I just realized if I give something a type signature of, say, :: SimplePolyMap '[String, Handler]
20:48:28 <dmj`> kristof: auto generation of docs too is nice, that is a lot of mundane work
20:48:38 <Shockk> assuming Handler isn't an instance of Eq, that'll actually work as a unidirectional map (except not very efficient)
20:50:07 <dmj`> kristof: Servant is made possible by DataKinds, TypeOperators, PolyKinds and KindSignatures
20:50:37 <kristof> Guess I should read the talk, then.
20:51:38 <Shockk> ...I wonder if I can write instances for cases like those or something, to make it more efficient as a unidirectional map 
20:52:19 <dmj`> type API = "api" :> "users" :> Capture "userid" UserId :> Get '[JSON] [User]
20:52:26 <johnw> yay, servant
20:53:08 <Shockk> dmj`: that looks interesting
20:53:10 <kristof> "read the talk". It really is late. I meant watch the talk, read the paper.
20:53:13 <dmj`> kristof: data (path :: k) :> a, KindSignatures has to be enabled here, and PolyKinds I believe, otherwise the kinds of Symbol wouldn't be compatible w/ normal promoted data kinds
20:53:27 <kristof> I don't even know what that means
20:53:29 <kristof> ._.
20:53:39 <dmj`> also TypeOperators, since (:>) is an operator, but used in a type definition
20:53:52 <dmj`> johnw: yay \o/
20:54:07 <Shockk> yep needs PolyKinds
20:54:20 <Shockk> PolyKinds lets you use like kind variables in kind signatures
20:54:29 <cmccann> {-# LANGUAGE EnableAllTheThings #-}
20:54:32 <kristof> And where can you use kind signatures?
20:54:49 <Shockk> on types
20:54:58 <dmj`> kristof: data (path :: k) :> a
20:54:59 <kristof> Isn't that normally inferred in haskell?
20:55:10 <dmj`> type signatures are yes
20:55:18 <kristof> Kind signatures are, too
20:55:23 <cmccann> kristof: depending on your definition of normally, probably
20:55:25 <kristof> class Monad m where 
20:55:45 <kristof> And the usage of m annotates what kind it has.
20:56:35 <cmccann> kristof: it becomes an issue if you want to do stuff with types that aren't made of just -> and *
20:56:50 <dmj`> kristof: it comes from the 'giving haskell a promotion' paper, where kinds were given signature and polymorphism, like types
20:56:51 <Shockk> like [*] or (*, *) or [*, (*, [*])]
20:56:55 <cmccann> though a lot of stuff can still be inferred with PolyKinds enabled
20:56:56 <Shockk> or Bool as a kind
20:57:07 <Shockk> cmccann: oh it can?
20:57:28 <cmccann> kristof: like, say you want to make Monad itself an instance of some class
20:58:03 <cmccann> you'll probably need some kind annotations for that (plus, y'know, ConstraintKinds)
20:58:39 <cmccann> Shockk: some stuff works, some doesn't. I have yet to figure out exactly what GHC can infer or generalize enough on its own.
20:58:46 <Shockk> ahh
20:59:34 <Gurkenglas> How about making MonadIO, MonadPlus, MonadReader, MonadState and the like instances of such a metaclass whose instances get lifted by monad transformers?
20:59:56 <Gurkenglas> (Except when the transformer provides such an instance themselves. Hmm.)
21:00:13 <kristof> cmccann: What?
21:00:24 <dmj`> kristof: are you thinking about using servant
21:00:28 <cmccann> kristof: hm?
21:01:02 <kristof> dmj`: No, it seems to have taken the haskell community by storm and I want to know what the fuss is about. mostly to add to my repertoire of "examples where functional programming makes everything way easier."
21:01:02 <Pamelloes> cmccann: What does making Monad an instance of accomplish? Can you give me a real world example?
21:01:33 <glguy> When you make a Monad instance you get to use do-notation and functions like liftM
21:01:52 <dmj`> kristof: I can't think of a better example really
21:02:00 <cmccann> Pamelloes: http://hackage.haskell.org/package/constraints-0.4.1.3/docs/Data-Constraint.html#t:Class
21:02:30 <cmccann> though that's using fully applied constraints, but you get the idea
21:02:45 <kristof> cmccann: No, I don't understand what you mean by that. instance Abstract Monad where ... is that what you mean?
21:03:01 <cmccann> :k Monad
21:03:02 <lambdabot> (* -> *) -> Constraint
21:03:30 <cmccann> kristof: "class Abstract (f :: (* -> *) -> Constraint) where ..."
21:03:34 <cmccann> or whatnot
21:03:43 <glguy> Oh, I see that I misread Pamelloes message
21:04:05 <cmccann> glguy: understandably so, since you misread it as the by far more common scenario :P
21:04:07 <Pamelloes> cmccann: Errrr.... Do you have a real world example of where that package is used? I've looked at it before and I can sort of make sense of the types but I can't figure out what to do with it.
21:05:10 <cmccann> Pamelloes: the stackage page lists a couple dozen reverse deps for that package, so I assume it's used for SOMETHING
21:05:20 <cmccann> nothing I know of off the top of my head though
21:05:45 <Pamelloes> Yeah... I really just want to see some example code :/ I'll go check out the stackage pave
21:05:46 <Pamelloes> *Age
21:06:27 <cmccann> Pamelloes: it's certainly not something you'll see all that often, to be sure
21:06:52 <Pamelloes> Yep
21:07:05 <Pamelloes> Hm, I've never heard of any of the reverse dependencies
21:07:07 <cmccann> I don't think "making classes instances of classes" was anywhere near the top of the list of expected use cases for ConstraintKinds
21:08:24 <emmanuel_erc> hello everyone!
21:08:31 <Pamelloes> I don't really get kinds beyond * [ -> * ]
21:08:45 <kristof> cmccann: https://www.reddit.com/r/haskell/comments/3loxh8/open_question_instance_of_typeclass_for_another/
21:08:49 <Pamelloes> Is there any good tutorial behind them?
21:09:23 <cmccann> Pamelloes: that's a very broad question these days, what with DataKinds and all
21:10:04 <kristof> dmj`: Ah, so it's *that* good? :)
21:10:16 <cmccann> Constraint is just the kind of, well, constraints. Having it means you can have type families that select constraints based on type and such.
21:10:27 <kristof> dmj`: I took the time to really get a good feel for lenses when I found out about them. I even watched the Simon Peyton Jones talk on them!
21:10:38 <emmanuel_erc> So, I am trying to find a quick way to perform this computation, and I have a type signature written that I think may work, but it has a few caveats. I want to ask if it is (based on my little knowledge), possibly "comonadic" behavior I may be performing.
21:10:38 <dmj`> kristof: yea, it's still new, and a lot of exciting things are in the pipeline, but it's great so far. 
21:11:01 <dmj`> kristof: plus wai/warp is fast, simple
21:11:13 <Shockk> cmccann: are there any kinds beyond * and -> without DataKinds?
21:11:18 <Pamelloes> cmccann: Yep, I get ConstraintKinds. It's DataKinds that really freaks me out.
21:11:22 <kristof> cmccann: How do you solve double diamond inheritance if you implement typeclasses over typeclasses?
21:11:29 <Shockk> oh ConstraintKinds wha?
21:12:06 <cmccann> kristof: I'm not sure what you mean? making a class an instance of something has basically nothing to do with any instances of the class itself
21:12:10 <ski> Shockk : also `#' and `(#)'
21:12:17 <dmj`> kristof: typically kinds with * mean they are heap allocated, kinds with # arent
21:12:18 <ski> (maybe also `!' ?)
21:12:21 <cmccann> the class is more like a... constraint constructor I guess
21:12:37 <emmanuel_erc> Essentially, I want to compute the distances between a point and its neighbors (in Euclidean space) within some epsilon ball. However, due to the obvious symmetry, I do not want to replicate any computations that may have already been performed.
21:12:37 <dolio> ski: (#) doesn't exist anymore.
21:12:47 <ski> dolio : oh. any info on that ?
21:12:51 <Shockk> kristof: the two names would create ambiguity if used unqualified, like with any exported names
21:13:07 <dolio> Neither does !, I think (and I can't remember what it actually was).
21:13:16 <cmccann> Shockk: DataKinds and ConstraintKinds are all I can think of right now that add more (explicitly usable) kinds
21:13:24 <kristof> cmccann: Oh, I think I understand. So you're talking about making classes over classes, essentially.
21:13:25 <Shockk> ahh
21:13:26 <cmccann> Shockk: or PolyKinds if you want to include kind variables
21:13:30 <dolio> ski: You're now allowed to pass unboxed tuples as arguments to functions, and put them inside data types, so there's no need for it, I think.
21:13:35 <Shockk> ah that too
21:13:49 <ski> dolio : ok
21:13:59 <Shockk> without anything else though PolyKinds would only be able to match * though I guess
21:14:19 <cmccann> Shockk: no, it'd still match anything made from * and ->
21:14:27 <Shockk> cmccann: oh right 
21:14:39 <Shockk> I was meaning that in my head before I typed it :(
21:14:43 <cmccann> which matters for things like Typeable, I think
21:15:00 <dmj`> kristof: the kind of a type level literal is Symbol, but the kind of Symbol is * IIRC
21:15:19 <cmccann> Pamelloes: DataKinds is... what it is, I guess. The concept is basically self-explanatory but using it without getting a headache is another matter.
21:15:21 <dmj`> kristof: so PolyKinds needs to be enabled to allow normal types promoted to kinds to coexist
21:15:40 <Shockk> dmj`: a type alias or something?
21:15:43 <Pamelloes> cmccann: Right. Exactly.
21:15:45 <Shockk> er
21:15:46 * kristof can't stop his head from spinning.
21:15:46 <Shockk> kind*
21:16:06 <dmj`> Shockk: yea so type API = "foo", can only work if DataKinds is enabled
21:16:25 <Shockk> you can do that?
21:16:33 <Pamelloes> kristof: I find forgetting about more advanced kinds makes life much nicer.
21:16:45 <Shockk> I mean, Char is promoted?
21:16:52 <dmj`> and type API = "foo" :> ReqBody '[JSON] Foo :> Post '[] () can only work if (:>) is defined w/ PolyKinds, IIRC
21:16:55 <emmanuel_erc> Hi guys!
21:17:07 <Shockk> :k 'a'
21:17:08 <lambdabot> parse error on input ‘'’
21:17:09 <dmj`> dolio: no (#) ? is this a GHC 8 thing
21:17:21 <dolio> No.
21:17:34 <dolio> I'm not sure when it disappeared, but it's been gone for a bit.
21:17:51 <Shockk> :k "test"
21:17:52 <emmanuel_erc> Do you mind if I ask a question about comonads?
21:17:53 <lambdabot> GHC.TypeLits.Symbol
21:17:57 <Shockk> oooh
21:18:10 <awpr> :k GHC.TypeLits.Symbol
21:18:11 <lambdabot> *
21:18:20 <Shockk> does that only work for "..." and not for individual '.'?
21:18:26 <cmccann> Shockk:  pretty sure Symbol is not in any way a type-level list of promoted Char
21:18:28 <dolio> (# Int, Int #) :: # already in 7.6.
21:18:37 <shachaf> emmanuel_erc: Well, it's better than asking a question about asking a question about comonads.
21:18:47 <cmccann> hi shachaf
21:19:05 <shachaf> hi
21:19:07 <Shockk> is there no type literal equivalent for 'a' though?
21:19:11 <dmj`> dolio: kinds as (#) ?
21:19:22 <dmj`> dolio: like this one, http://lpaste.net/141598
21:19:23 <emmanuel_erc> Yea, well I had to get someone's attention.
21:19:40 <shachaf> Not a good way to get people's attention.
21:19:50 <kyfho> why is haskell nicer than say python?
21:20:06 <dolio> dmj`: Eh?
21:20:09 <emmanuel_erc> Well, I won't do that next time.
21:20:17 <cmccann> Shockk: I don't think so, no
21:20:23 <dmj`> dolio: I durno :/
21:20:30 <Shockk> like, I could imagine "asdf" instead of being of kind Symbol, being of kind [Symbol] where 'a' is of kind Symbol
21:20:33 <Shockk> cmccann: ahh, aww
21:20:41 <cmccann> Shockk: pretty sure Char isn't promotable and there's no built-in type-level Char literals
21:20:49 <dolio> dmj`: Just so we're clear, (#) used to be a different kind than #. It's not just # in parentheses. It was the kind of unboxed tuple types.
21:20:57 <Shockk> the built-inness is what I was wondering 
21:21:06 <cmccann> :k 'a'
21:21:08 <lambdabot> parse error on input ‘'’
21:21:09 <dfeuer> dolio, it's the same kind now?
21:21:12 <awpr> kyfho: Python only has one type, so everything that might go wrong will do so at runtime
21:21:19 <dolio> Unboxed tuple types are now kind #.
21:21:23 <Pamelloes> kyfho: If a Haskell program compiles, 90% of the time, it will be bug free—the compiler and type system prevent corner cases and catch most bugs.
21:21:38 <cmccann> I think 90% is dramatically overstating it :P
21:21:44 <dfeuer> Oh, were they * before?
21:21:49 <cmccann> though it depends a lot on what kind of program you're writing.
21:21:50 <kyfho> are haskell programs automatically concurrent? and fast using all cpu?
21:21:53 <Shockk> 90% of testing haskell code is getting the compiler to compile it
21:21:57 <ski> dfeuer : no, `(#)'
21:22:02 <emmanuel_erc> shachaf: I was reading the other day that comonads are good for simulating object oriented programming. Does it make sense to use them to build a list of lists, based on previously computed values?
21:22:05 <dfeuer> Oh, weird.
21:22:16 <shachaf> emmanuel_erc: Why are you asking me?
21:22:29 <Pamelloes> cmccann: Fair enough. I think Shockk's statement is a more accurate explanation.
21:22:49 <emmanuel_erc> Sorry...
21:22:56 <dmj`> dolio: I see, interesting
21:22:58 <awpr> kyfho: they're not automatically concurrent, but it's *way* easier to do concurrency correctly in Haskell than most languages.  it's also got way better performance than Python for CPU-bound code.
21:24:10 <Pamelloes> emmanuel_erc: Sorry no one's responding to you :( This is usually a pretty helpful place so try to be patient and someone who knows what they're talking about will probably be able to help you sooner or later. :)
21:24:57 <emmanuel_erc> Thansk Pamellloes.
21:25:05 <emmanuel_erc> Thanks**
21:25:38 <dmj`> kristof: so using the 'symbolVal' function from GHC.TypeLists and Data.Proxy you can 'Proxy' values from the type level to the value level at compile time
21:26:27 <johnw> emmanuel_erc: lists are not comonads; but I'm not sure from your question what you'd use these lists for, so it's hard to say if there's any relevance
21:27:07 <cmccann> they're not? oh, they'd need to be non-empty, right.
21:28:06 <emmanuel_erc> Well what I want to do is at first compute the distances between a point and all the surrounding points within some epsilon (simple).
21:28:22 <emmanuel_erc> But I want to do that for all the points in my data set and  not repeat any work.
21:29:12 <emmanuel_erc> The most sensible function signature that I can think of right now is (I am really using vectors by the way) is : 
21:30:18 <emmanuel_erc> (Vector Distances -> Point -> Vector Point) -> Vector Distances (where type Distances = Vector Double, and type Point = Vector b)
21:31:16 <Gurkenglas> emmanuel_erc, if you only need the distances to compare them to each other, a large performance gain lies in not sqrt-ing the summed squares. (That one isn't specific to Haskell.)
21:31:47 <awpr> emmanuel_erc: ah, it sounds like if you want to be explicit about caching and reusing values, you'd want State (Map (pt, pt) Double) [[Double]].  but, you can probably take advantage of thunks to avoid recomputing.
21:31:48 <Gurkenglas> By repeating work, do you mean that you hope to share the computation of the distance between two points between those points?
21:31:50 <emmanuel_erc> I am already do not doing that.
21:31:57 <emmanuel_erc> Yes Gurkenglas.
21:32:10 <emmanuel_erc> There is one more wrinkle however.
21:32:32 <emmanuel_erc> Well actually no, sorry.
21:33:06 <Shockk> hmm I asked this before but I don't think anything answered / saw my question; does anyone know who the maintainer(s) of containers is/are? (or know who checks the pull requests for containers)
21:34:25 <emmanuel_erc> awpr: Could I instead write State (Map (pt,[pt]) [Double])
21:35:13 <awpr> that needs another type argument, but that looks like it could work.
21:35:16 <Gurkenglas> emmanuel_erc, the cost of that is of course that once you computed the distance between A and B because your global computation required it when looking at A, you'll need to keep it in memory until you're at B.
21:35:26 <Shockk> emmanuel_erc: if you're mapping from k to [v], check out multimap, I saw it a little while ago
21:35:45 <Shockk> it's basically exactly that and is just represented like that internally
21:36:28 <emmanuel_erc> Gurkenglas: Actually, I want to keep all the distances computed around for some time.
21:37:54 <emmanuel_erc> However, I don't anticipate each list/vector being very long. I want to use the distances calculated to determine neighborhoods around each point and then I am going to do some matrix computations afterward.
21:38:05 <Pamelloes> Why does GHC compile everything twice, once to ._o and once to ._p_o?
21:38:15 <Shockk> you have profiling enabled
21:38:22 <emmanuel_erc> Gurkenglas: Are you implying that it might be better to just recompute the distances when I need them?
21:38:33 <Shockk> p is for objects built with profiling stuff
21:38:39 <Pamelloes> Shockk: Ah, thanks :)
21:38:44 <awpr> emmanuel_erc: what I meant by taking advantage of thunks is to explicitly calculate the distances for every *set* of two points, then look them up in both orders to expand to ordered pairs
21:40:59 <Gurkenglas> emmanuel_erc, it depends. If you're already not taking square roots and pick out millions of specific distances between two points that might as well be selected randomly, recomputing a sum of squares won't take that much more performance than looking up the precomputed distance
21:41:51 <Gurkenglas> emmanuel_erc, if you're always looking at all the distances originating from one point at once, keeping a list of them around that can be looked up as a whole sounds good
21:42:25 <Gurkenglas> In that case, you might even want to save each distance in two places, one for each point
21:43:19 <Gurkenglas> If you only use the list of distances originating from each point once, and don't use the distances for anything else, you can skip making a list beforehand and just compute the distances when you need them
21:43:35 <emmanuel_erc> Gurkenglas: And of course, keeping the distances  in two places would only require one computation.
21:43:55 <Pamelloes> accursedUnutterablePerformIO has got to be the greatest name for a function ever.
21:44:05 <Pamelloes> It makes me smile every time I see it :)
21:44:28 <Shockk> Pamelloes: wha?
21:44:33 <Gurkenglas> (By the way, explicitly telling it to do things "beforehand" is harder than it might seem, so you probably aren't doing it beforehand when you're trying to.)
21:44:52 <emmanuel_erc> Well right now, I am only working with "small" data (less than 1000 points, each being 784 dimensional), but I expect that I am going to have to deal with larger numbers in the future.
21:44:53 <Pamelloes> Shockk: It's in bytesting. It's like unsafePerformIO except evil.
21:44:55 <Shockk> oh I see
21:44:58 <Shockk> I googled it and lol
21:50:06 <Shockk> I'm kind of a fervent believer in not using stuff in my code that's either unsafe or can cause an exception (like undefined and error and code that can result in them), as much as is sane
21:51:10 <emmanuel_erc>  Thanks for the tips everyone. I wish I had considered Data.Map (and its variants) sooner.
21:51:31 <Shockk> that's why I pull request'd a lookupElem function for Data.Set as an alternative to elemAt (lookupElem returns a (Maybe a) and elemAt returns an (a) or errors)
21:52:00 <Shockk> emmanuel_erc: containers is nice
21:53:42 <emmanuel_erc> Thanks. I recently coverted to Haskell (this is my first functional programming language). At this point, I have a lot of faith that Haskell is the best vehicle for expressing high level ideas for my research. 
21:54:03 <emmanuel_erc> I hope my bet pays off.
21:54:15 <Shockk> it was my first as well 
21:54:31 <awpr> +1, high-level ideas get mercilessly shredded by tedious details in most other languages.
21:56:08 <Shockk> template <typename T> class Mayb- this is already longer than
21:56:09 <Shockk> data Maybe a = Just a | Nothing
21:56:50 <awpr> I tried to fmap an std::optional today... eventually I just got sad and used a ternary expression.
21:56:51 <emmanuel_erc> An end goal for me is to design an algorithm that will have to create functions on the fly in light of previous data generated.
21:57:06 <Shockk> awpr: you just made my made
21:57:09 <johnw> Shockk: Haskell's handling of abstract types is pretty awesome, I agree
21:57:09 <dmj`> emmanuel_erc: sounds like a free monad thing
21:57:11 <Shockk> my day
21:57:12 <emmanuel_erc> I know that doing that in python or Matlab would be weird.
21:57:50 <emmanuel_erc> dmj`: I'll have to check that out. Thanks.
21:59:40 <hodapp> emmanuel_erc: also sounds vaguely like a supercompiler?
22:00:05 <slacko1256> what is an actual difference between a compiler and a supercompiler?
22:00:10 <slacko1256> whole program analysis?
22:00:49 <hodapp> slacko1256: as I understand it, a supervisor compiler does a very extensive form of whole program analysis and basically generates a new program that happens to produce the same results.
22:01:14 <emmanuel_erc> hodapp: that sounds really heavy (by that, I mean deep...).
22:01:24 <hodapp> slacko1256: this is my view from reading one person's write-up in Monad.Reader.
22:02:00 <slacko1256> my personal understanding was from somebody IIRC here 3 years ago that said mlton was one
22:02:13 <hodapp> https://themonadreader.files.wordpress.com/2014/04/super-final.pdf
22:02:15 <slacko1256> also that neil mitchell project supero said something on those lines
22:02:35 <slacko1256> but what you say sounds really... super for a compiler
22:02:38 <hodapp> This one uses SC Mini.
22:02:58 <hodapp> slacko1256: the super is more about 'supervised' here, I think.
22:03:23 <hodapp> not super as in 'zomg so awesome it'll rewrite CS, I bet Wired will write an article about this right now'
22:04:06 <slacko1256> supervised? I only understand that term on the context of recurrent neural networks
22:04:43 <hodapp> slacko1256: not sure if it's that same context or not.
22:04:56 <slacko1256> I don't think so
22:05:38 <hodapp> slacko1256: that link is the Monad.Reader article, and it might be worth reading some into (though the details get a bit heavy and I'm not sure I've even made it through them)
22:05:47 <hodapp> emmanuel_erc: likewise to you ^
22:06:11 <slacko1256> got it, will put it on my queue
22:06:42 <emmanuel_erc> I've downloaded it already. Though it is getting late here and I am already digging through an explanation of free structures on haskell.org. I will definitely take a look at it. Thanks!
22:07:51 <glguy> Is System.IO.hLookAhead the closest to ungetc(3) I'm going to get while using Handles?
22:07:52 <slacko1256> why would you want to learn about free structures for programming in haskell?
22:08:10 <slacko1256> unless you have a Cat-theory inclination
22:08:38 <emmanuel_erc> I was looking up free monads (someone suggested it), and I found free structures.
22:08:59 <emmanuel_erc> So, me being the curious cat with 9 lives....
22:19:55 <thoughtpolice> slacko1256: It is more nuanced than that. A whole program compiler (MLton is one) can merely see every translation unit globally, so it can make optimizations with global knowledge as opposed to local knowledge. MLton is a very good whole program compiler.
22:20:41 <thoughtpolice> slacko1256: There are a certain class of program specializations under the umbrella of 'partial evaluation'. Supercompilation is a kind of partial evaluation algorithm, one with nice properties that would make it suitable for a compiler.
22:22:49 <thoughtpolice> In particular a supercompiler always terminates, and it doesn't require certain kinds of expensive analysis to determine what things should be specialized (a 'binding time analysis' which essentially amounts to 'abstract interpretation', which means statically approximating the meaning of a program, but it is expensive)
22:24:20 <xpilot> is anyone around to answer a few questions about edwardk's PHOAS stuff (https://www.fpcomplete.com/user/edwardk/phoas)?
22:25:00 <xpilot> first off, it doesn't look like you need a Profunctor at all, just a Functor (ExpF a)
22:25:23 <xpilot> also, I'm confused by what the Monad instance does
22:25:32 <thoughtpolice> slacko1256: You might find it informative to read Chapter 1  of this thesis, it's only a few pages and gives an example: http://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-835.pdf
22:27:16 <xpilot> the claim is that monadic binding performs capture-avoiding substitution, but that doesn't seem to be what is happening
22:27:47 <radens> When using a do block in haskell can you have multiple return statements?
22:28:10 <radens> How would I say `return Nothing if failure_condition`?
22:28:10 <awpr> oh, it occurs to me this is a good place to ask this: is there an established name for lattices isomorphic to Either Bool a, where Left True and Left False are the join and meet of any set of multiple distinct 'a' elements?
22:28:21 <slacko1256> thoughtpolice: will read, but you cleared up my misconception of supercompilation being a set of diciplines (in which whole program opti fell) instead of an actual algorithm with good propieties
22:29:12 <slacko1256> @type when
22:29:14 <lambdabot> Applicative f => Bool -> f () -> f ()
22:29:23 <slacko1256> aweinstock: you probably want ^
22:29:28 <thoughtpolice> Yes, you can think of supercompilation as being more of an optimization pass a compiler might use, rather than a 'kind of compiler'.
22:29:45 <thoughtpolice> That thesis describes a compiler pass for GHC to add Supercompilation.
22:29:59 <slacko1256> if you mean multiple return as C returns (output paths) then you will reach the cont monad
22:30:02 <hodapp> thoughtpolice: neat, I will have to give this a read
22:30:20 <slacko1256> which if I've been told with lack of dicipline is not what you want
22:30:22 <awpr> radens: you can *have* them, but they won't do what you're thinking.  it's possible to have a monad supporting early returns -- I think Snap does that -- but you would normally put the whole skipped section in the 'else' part of an if-then-else.
22:30:28 <thoughtpolice> It has been dormant for a few years, but there has been recent work to revive it and turn it into a real compiler plugin.
22:31:38 <nitrix> M.mapMaybe (\x -> if M.null $ op2 x then Nothing else Just $ op2 x)
22:31:40 <kristof> I have not obeyed the monad laws. What is my punishment?
22:31:58 <nitrix> Is `op2 x` going to be computed twice or I can assume memoization here?
22:32:10 <slacko1256> @slap kristof
22:32:10 <lambdabot> Come on, let's all slap kristof
22:32:21 <kristof> :)
22:32:29 * slacko1256 yells SHAME, SHAME to kristof
22:32:34 <kristof> I'm serious, though. I want to know what I have lost in terms of expressiveness, or usability.
22:32:37 <Cale> kristof: Inconsistent program behaviour under refactorings
22:32:58 <kristof> Cale: Ah, but those refactorings probably relied on the monad laws in the first place.
22:32:59 <awpr> kristof: if that's a serious question, a lot of Monad combinators will have bizarre behavior on your Monad
22:33:15 <slacko1256> kristof: sometimes you can get the laws if you ask for more stuff of your underlying monad stack
22:33:21 <Cale> kristof: If the associative law isn't obeyed, then it's no longer valid to factor out a chunk of a do block into its own definition and then use it
22:33:27 <slacko1256> as list-done-wrong did with commutative monads
22:33:32 <nitrix> Can I assume `if g $ f x then Nothing else Just $ f x` wont call f twice and leverage memoization?
22:33:57 <slacko1256> no
22:34:06 <Gurkenglas> No. And you want mfilter (not . g) $ f x
22:34:06 <Cale> nitrix: You can assume it will apply f twice
22:34:08 <slacko1256> but it would be an educated guess :-)
22:34:11 <thoughtpolice> nitrix: I assume you mean "Will GHC turn `... f x ... f x ...` into `... let e = f x in ... e ... e ...` " GHC is very conservative about CSE, so in general the answer is "no"
22:34:20 <Gurkenglas> Oh wait nvm f doesn't return Maybe
22:34:57 <Gurkenglas> So we have that usecase again where the oneliner implementation is painfully long and for some reason base won't make a function for it
22:35:17 <slacko1256> which use case?
22:35:18 <kristof> Cale: Ah, that is troubling. What about (return x) >>= f != f x?
22:35:18 <Cale> nitrix: If functions were automatically memoised, then nothing would ever be garbage collected. If they were aggressively CSE'd it wouldn't be quite as bad, but you'd still get unavoidably horrible space usage in a bunch of cases
22:35:57 <Cale> kristof: That's also kind of an important part of the same kind of refactoring a lot of the time
22:36:17 <Gurkenglas> :exf (a -> Bool) -> a -> Maybe a -- slacko1256
22:36:17 <exferenceBot> \ f1 -> mfilter f1 . pure
22:36:25 <kristof> I guess I've never refactored do blocks in this way but I believe you.
22:36:39 <Cale> kristof: But also that's part of what provides the intuition that return isn't doing stuff
22:36:49 <kristof> Ah, I see.
22:36:50 <nitrix> How would I yield Nothing if a Map is null without applying my transformation twice (for the condition and the result) ?
22:37:00 <Cale> return v does nothing apart from producing v as its result
22:37:43 <vburakovs> hey guys, can anybody help me with one problem? why doesn't this composition: http://pastebin.com/bAXcepL9 work?
22:38:14 <slacko1256> @type (pure .) 
22:38:15 <lambdabot> Applicative f => (a -> a1) -> a -> f a1
22:38:24 <Gurkenglas> @pl f' x = Circle . Point x
22:38:24 <lambdabot> f' = (Circle .) . Point
22:38:32 <bz> hm
22:38:38 * hackagebot json-rpc-server 0.2.2.0 - JSON-RPC 2.0 on the server side.  https://hackage.haskell.org/package/json-rpc-server-0.2.2.0 (grayjay)
22:38:40 <slacko1256> Gurkenglas: ^
22:39:02 <slacko1256> no
22:39:22 <slacko1256> wrong a/a1 :-)
22:39:23 <Hijiri> vburakovs: Point :: Float -> Float -> Point, Circle :: Point -> Float -> Shape
22:39:25 <Hijiri> :t (.)
22:39:27 <lambdabot> (b -> c) -> (a -> b) -> a -> c
22:39:31 <bz> why would f be applied twice? i thought the whole point of purity is that all values are immutable
22:39:33 <Hijiri> so if we do Circle . Point, we have
22:39:41 <Gurkenglas> slacko1256, you mean (. pure) . mfilter, but that is annoyingly long/unreadable, and there should be an alias for it
22:39:45 <Hijiri> Circle must be (b -> c), Point must be (a -> b)
22:39:56 <Hijiri> For the first part, b becomes, Float, and c becomes (Float -> Point)
22:40:06 <Hijiri> so we have b ~ Float, c ~  (Float -> Point)
22:40:20 <nitrix> Oh I guess I can just do  let .. in ..
22:40:26 <Gurkenglas> bz, because it still has to keep in memory everything it memoizes, so memoizing everything is unreasonable
22:40:34 <Hijiri> For the second part, we then have a ~ Point, b ~ (Float -> Shape)
22:40:48 <Hijiri> but that conflicts, because earlier we thought that b ~ Float
22:40:56 <Hijiri> and Float doesn't unify with (Float -> Shape)
22:41:01 <Gurkenglas> There has to be some compromise on what is memoized, and the one Haskell chooses is that everything with a name is memoized, which includes functions but not function applications
22:41:08 <Hijiri> so the types are wrong
22:41:23 <vburakovs> Hijiri: but how does providing "x" to a function solve this?
22:41:24 <bz> Gurkenglas: huh
22:41:32 <Hijiri> vburakovs: what do you mean?
22:41:39 <Hijiri> oh
22:41:56 <bz> Gurkenglas: please clarify "it" and "everything"
22:42:00 <vburakovs> well, if I say "let f x = Circle . Point x" it does work
22:42:14 <vburakovs> I thought that I could "cancel out" the xs on both sides
22:42:19 <Hijiri> ok so Point :: Float -> Float -> Point, so Point x is (Float -> Point) (we know x is a Float because Point is only applied to Floats)
22:42:52 <Hijiri> so now (a -> b) is (Float -> Point) instead of (Float -> Float -> Pint)
22:42:55 <Gurkenglas> bz, "your computer" and "all the things we chose to memoize"
22:43:00 <awpr> vburakovs: Circle . Point x is Circle . (Point x), not (Circle . Point) xs
22:43:06 <Hijiri> wait, I lost myself
22:43:48 <bz> Cale: by "nothing" you mean "no thunks," right?
22:43:51 <Hijiri> awpr's explanation is better
22:43:55 <Cale> bz: hm?
22:44:01 <Hijiri> since your issue was with precedence and not the types
22:44:10 <Cale> I mean "no effects"
22:44:15 <bz> l07:34 <Cale> nitrix: If functions were automatically memoised, then nothing would ever be garbage collected. If they were aggressively CSE'd it wouldn't be quite as bad, but you'd still get unavoidably horrible space usage in a bunch of cases  -- this
22:44:19 <Cale> oh
22:45:01 <vburakovs> Hijiri: ok, I'll try to wrap my head around it then
22:45:08 <bz> assuming that the return value of nitrix's expression is strict, i think it's reasonable to assume that f will, in practice, be applied only once
22:45:08 <vburakovs> Thanks
22:45:21 <nitrix> bz: let .. in .. has the behavior that I want though?
22:45:27 <Hijiri> awpr is saying you can't cancel out the x unless it was (Circle . Point) x
22:45:27 <Cale> bz: If the result of every function application were made live by automatically memoising it, then you could never garbage collect the result of any function application
22:45:39 <Hijiri> which is different from Circle . Point x
22:45:42 <bz> Cale: i'm not talking globally
22:45:46 <Cale> bz: You'd fill up memory very very quickly, since there would be essentially no garbage
22:46:13 <Hijiri> when you eliminate points it has to be in the form    f x = g x
22:46:21 <bz> Cale: why would you think that?
22:46:33 <Cale> Isn't it obvious?
22:46:34 <Hijiri> (f might be a function that's already applied, like h 1 2 3)
22:46:43 <Hijiri> or h w r t
22:46:49 <Hijiri> since it would be arguments not actual values
22:46:59 <bz> Cale: eval the f x thunk, eval g (f x), eval Just (previously evaluated thunk), collect
22:47:08 <vburakovs> Ohhh, right
22:47:21 <Cale> bz: I think we're talking about different things
22:47:32 <bz> he's only asking within the context of the let expression, not the program as a whole (or at least he hasn't explicitly given the latter context)
22:48:18 <Cale> Well, other stuff got said in that discussion which discussed the case of common subexpression elimination
22:48:19 <bz> not the lifetime of the entire program*, if that clarified anything
22:48:27 <vburakovs> That's why it also works with Circle $ Point, which makes arguments apply in right-associative way
22:48:34 <Cale> I was talking about another common misconception
22:48:40 <Cale> just in case
22:49:23 <bz> k then
22:49:35 <Hijiri> vburakovs: also note you will probably get better type errors if you give your functions explicit type signatures
22:49:36 <bz> on a side note: tfw you realize that monad laws are actually monoid laws
22:49:37 <awpr> incidentally you can define an operator to compose over two arguments (I like to call it .:), which would work for this as Circle .: Point
22:51:26 <vburakovs> Hijiri: will the errorrs themselves be better or will it just make it easier for myself to debug? I thought that haskell would infer the correct type anyway
22:51:28 <structuralist> Is it possible to have first-class instances using constraint kinds?
22:51:52 <Hijiri> vburakovs: the errors will be more informative, because you told the compiler what you intended it to be
22:52:12 <Hijiri> there are cases where an expression has *a* correct type, but not *the* type you wanted
22:52:15 <awpr> let's try this:
22:52:16 <awpr> :exf (c -> d) -> (a -> b -> c) -> a -> b -> d
22:52:17 <exferenceBot> \ f1 f2 c -> f1 . f2 c
22:52:30 <awpr> ^ f1 = Circle, f2 = Point
22:52:38 <Hijiri> so then that particular definition won't have an error, but you'll get an error somewhere else where you try to use it
22:52:53 <Hijiri> for example I could do something like
22:53:03 <Hijiri> @let add = (+); four = add 2
22:53:04 <lambdabot>  Defined.
22:53:09 <Hijiri> and I forgot to put another 2
22:53:23 <Hijiri> so now I think four is the number 4, but it's actually some function, and I didn't get an error
22:53:33 <Hijiri> @let 6 = add four 2
22:53:34 <lambdabot>  .L.hs:179:1:
22:53:34 <lambdabot>      No instance for (Eq (a0 -> a0))
22:53:34 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
22:53:38 * hackagebot json-rpc-client 0.2.2.0 - JSON-RPC 2.0 on the client side.  https://hackage.haskell.org/package/json-rpc-client-0.2.2.0 (grayjay)
22:53:39 <Hijiri> and now I get a type error
22:53:49 <Hijiri> @let six = add four 2
22:53:51 <lambdabot>  Defined.
22:53:53 <Hijiri> sorry, this is what I meant
22:53:55 <Hijiri> wait what
22:53:56 <Hijiri> > six
22:53:58 <lambdabot>  <Integer -> Integer>
22:54:15 <Hijiri> > (sin + cos) 0
22:54:16 <lambdabot>  1.0
22:54:38 <Hijiri> someone defined Num for applicative things
22:54:47 <Hijiri> @undefine
22:54:47 <lambdabot> Undefined.
22:55:01 <Hijiri> @let add = (+); four = add 2; six = add four 2
22:55:01 <opqdonut> Hijiri: yeah it's the Num a => Num (b -> a) instance
22:55:02 <lambdabot>  Defined.
22:55:11 <Hijiri> is this instance in by default?
22:55:22 <Hijiri> I didn't think it used to be
22:55:53 <opqdonut> nah it's lambdabot-special
22:55:57 <awpr> > replicate four 'a'
22:55:58 <lambdabot>      Couldn't match expected type ‘Int’
22:55:58 <lambdabot>                  with actual type ‘Integer -> Integer’
22:55:58 <lambdabot>      Probable cause: ‘four’ is applied to too few arguments
22:56:18 <vburakovs> Hijiri: Oh, now I understand 
22:56:34 <awpr> eh, close enough.
23:04:54 <xpilot> structuralist: you can construct constraint-carrying values like data Dict c where Dict :: c => Dict c
23:09:24 <xpilot> and do stuff like: type Implies c1 c2 = Dict c1 -> Dict c2
23:10:56 <xpilot> the downside is that you have to pass these around
23:13:04 <xpilot> one use case is in https://hackage.haskell.org/package/vinyl-0.5.1/docs/Data-Vinyl-Core.html
23:16:00 <cocreature> ofc there is a package for that https://hackage.haskell.org/package/constraints-0.4.1.3/docs/Data-Constraint.html
23:24:25 <xpilot> I wonder why that package doesn't use type Forall c = forall a. Dict (c a)
23:31:38 <dxld> Can someone explain to me why, at the top level in a module, `foo = show` works and `(foo, bar) = (show, show)` produces a type error? (both with -XNoMonomorphismRestriction)
23:32:54 <opqdonut> dxld: what type error? note that monomorphism restriction only applies to non-functions
23:33:13 <arkeet> dxld: what error?
23:33:16 <dxld> "Could not deduce (Show a0) from the context (Show a)"
23:33:29 <opqdonut> hmm sorry, I was wrong about MR not applying to functions
23:34:05 <dxld> I find this quite puzzling, in my mind those two assignments should be equivalent
23:34:22 <dxld> the funny thin is if you do it in GHCi it works just fine
23:34:34 <dxld> so `let (foo,bar) = (show, show)`
23:35:14 <dxld> I'm just wondering if this is even supposed to work or if this is a bug/oversight in ghc or something
23:35:36 <arkeet> interesting
23:35:53 <arkeet> :r
23:36:02 <arkeet> oops
23:36:07 <arkeet> aha
23:36:13 <arkeet> try (foo,bar) = (show, ()) or something
23:36:33 <arkeet> note that the ambiguous type error is on bar
23:37:00 <arkeet> or simply bar = snd (show, ())
23:37:04 <dxld> arkeet: oh yeah, you're right. I didn't notice that
23:37:16 <dxld> same thing though
23:37:32 <dxld> lol
23:37:39 <dxld> this one's even better though: "No instance for (Show a0) The type variable ‘a0’ is ambiguous When checking that ‘bar’ has the inferred type bar :: ()"
23:38:07 <dxld> so bar has type () which isn't even polymorphic
23:39:56 <arkeet> it works fine in ghci because of extended default rules
23:40:08 <dxld> ah yeah those
23:41:01 <dxld> I suppose if this is actually a real problem and I'm not being completely moronic I'll go ask in #ghc
23:41:29 <xpilot> if you change bar to _ it works
23:41:43 <arkeet> also note that the class constraint is important
23:41:55 <arkeet> if you change it to (id, ()) or something
23:42:07 <arkeet> then it checks fine, I guess because it puts Any -> Any for the type of id or so.
23:42:15 <dxld> xpilot: I can't reproduce that, I still get could not deduced with _ in place of bar
23:42:51 <arkeet> but that obviously doens't work when you put a constraint.
23:42:58 <xpilot> dxld: I'm in 7.8.4
23:43:04 <arkeet> I'm on 7.10.1
23:43:11 <dxld> i'm on 7.10.2
23:43:37 <dxld> arkeet: it get's better though, if I put explicit type signatures it still doesn't work
23:43:42 <arkeet> well sure.
23:43:51 <arkeet> for the same reason show . read doesn't work
23:44:00 <dxld> why?
23:44:07 <arkeet> :t show . read
23:44:08 <lambdabot> String -> String
23:44:08 <dxld> it's not like there's any ambiguity then
23:44:16 <arkeet> er
23:44:24 <dxld> `foo :: Show a => a -> String, bar :: Show a => a -> String`
23:44:41 <dxld> then ghc shouldn't even be trying to resolve a to any particular instance
23:44:48 <arkeet> show . read :: (Show a, Read a) => String -> String
23:45:05 <dxld> arkeet: I don't understand how that's related
23:45:23 <dxld> in that case you obviously have an ambigous type variable somewhere in the middle of an expression
23:45:29 <arkeet> :t (show, ())
23:45:31 <lambdabot> Show a => (a -> String, ())
23:45:39 <arkeet> when getting the value of the second component
23:45:42 <arkeet> what type do you pick for a?
23:45:44 <dxld> whereas in my case I have a toplevel type variable that has the constraint applied
23:45:46 <arkeet> you can't not pick.
23:46:11 <dxld> hmm
23:46:31 <arkeet> ExtendedDefaultRules picks ()
23:46:51 <arkeet> if it weren't for the class constraint it could pick Any
23:47:14 <xpilot> (a,b) = (undefined :: Num a => a, ()) works
23:47:24 <xpilot> (a,b) = (undefined :: Show a => a, ()) doesn't
23:47:26 <KrzyStar> Damn, binary-strict doesn't work with ghc >= 7.10
23:47:38 <arkeet> xpilot: yes, because Num has a default instance
23:47:38 <arkeet> namely, Integer
23:47:56 <dxld> arkeet: I guess that makes sense
23:48:03 <boj> how would i use Eq for a type alias? i have type Foo = Vec3 (from Data.Vect.Float.Base) and want to compare two Foos like they were Vec3s
23:48:17 <arkeet> boj: they *are* Vec3s.
23:48:21 <xpilot> arkeet: well the resulting a has type Num t => t
23:48:33 <boj> i see
23:48:34 <srhb> boj: If you mean a different instance from that of Vec3, then it's not possible. Use newtypes instead.
23:48:36 <arkeet> xpilot: that's not a problem.
23:48:46 <arkeet> the issue is with b.
23:49:35 <dxld> arkeet: so anyways, thanks :3
23:49:36 <boj> i am getting "No instance for (Eq Foo) arising from a use of '=='"
23:50:05 <arkeet> boj: well, that seems to imply that there's no Eq instance for Vec3.
23:50:26 <arkeet> if it really is just a type synonym.
23:50:33 <boj> hmm, the docs say there is
23:50:46 <Gurkenglas> I hereby propose the Hufflepuff project: Collect all the various packages that can somehow be made to take a .hs file and say things about it (hlint, herbie, quickspec, etc., especially little stuff like https://hackage.haskell.org/package/dead-code-detection that no one would ever hear about) on one side, all .hs files that can be laid hands upon, and smack them together, producing annotated .hs files readable 
23:50:46 <Gurkenglas> on some website.
23:51:04 <breadmonster> @seen amnn
23:51:04 <lambdabot> 4mnN
23:51:54 <Gurkenglas> (Because no library writer can be bothered to apply all the tools, and few tool writers can be bothered to traverse all libraries, and this is about twice the work of doing either of those so it'll take a true Hufflepuff to do it if we ever find one.)
23:53:33 <gamegoblin> Anywhere here want to try their hand at making an efficient toList implementation for this type? http://lpaste.net/722473345261502464 By efficient implementation, it should visit each element of the tree once and should only allocate a single list as a result
23:53:51 <arkeet> boj: mind sharing the code?
23:53:58 <boj> srhb: thank you, it was newtype i was looking for
23:53:59 <dxld> Gurkenglas: how about integrating those tools into ghc-mod? we already have hlint and just regular old ghc ;)
23:54:06 <arkeet> k
23:54:15 <srhb> boj: Sure thing.
23:54:53 <ttt_fff> https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Prim.html <-- where are the funcs for parsing
23:55:04 <ttt_fff> when my stream is NOT TEXT / [CHAR], but some other TOKEN type ?
23:55:34 <Gurkenglas> dxld, installing ghc-mod and running it on your stuff is a trivial inconvenience that too many library writers have not done, as opposed to a website whose link can be directly sent to them. Could ghc-mod be funneled into such a website?
23:56:13 <dxld> Gurkenglas: I suppose you could run ghc-mod as a service, why not?
23:56:51 <Cale> ttt_fff: runParser
23:57:37 <dxld> Gurkenglas: the thing is anything that uses ghc (the library) has to deal with all the bullshit that ghc-mod already handles. (dead-code-detection is one of those for example, hlint not so much but that's already integrated anyways)
23:57:49 <Cale> ttt_fff: Actually, nothing in that module you linked seems to specify the stream type
23:57:54 <glguy> http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Prim.html#v:token
23:58:41 * hackagebot http-client 0.4.24 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.24 (MichaelSnoyman)
23:58:55 <glguy> You'll use token or tokenPrim or tokenPrimEx to make parsers for your tokens
23:58:58 <lpaste> Gurkenglas revised “No title”: “gamegoblin, is this sufficient?” at http://lpaste.net/722473345261502464
23:59:32 <ttt_fff> Cale: yeah, runParser seems to be irrelevant
23:59:37 <ttt_fff> glguy: okay, https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec.html#v:tokenPrim looks important, thanks!
23:59:42 <Gurkenglas> gamegoblin, you could also simply use Data.Tree, that already has a Foldable instance.
23:59:52 <Cale> ttt_fff: Well, in that case, I don't understand the question.
