00:18:52 <echo-area> Is there a predefined function of type `(a -> b -> c) -> a -> b -> m c`?  Hoogle search hit nothing
00:19:50 <shachaf> No.
00:20:47 <johnw> echo-area: a construction like that often involves using return
00:22:19 <echo-area> johnw: I know, I was wondering if there was a standard concise form for expressions such as \ x y -> return (f x y)
00:23:09 <bjornars> @pl \x y -> return (f x y)
00:23:09 <lambdabot> (return .) . f
00:23:19 <bjornars> (don't do that)
00:23:33 <bjornars> @pl \x -> return (f x)
00:23:33 <lambdabot> return . f
00:24:27 <echo-area> bjornars: What I needed was actually `((return .) .) . f` >_<
00:25:09 <Iceland_jack> echo-area: Nobody needs '(((return .) .) .)'
00:25:53 <arkeet> ((.).(.).(.)) return f
00:26:15 <echo-area> That is so weird
00:26:46 <echo-area> Iceland_jack: Right, I shouldn't need that
00:27:06 <bjornars> you know your day is good when you can finally use the triple-boob-operator
00:27:12 <arkeet> :-)
00:27:28 <Iceland_jack> Unless you live by some kind of weird hierarchy of needs that I wish to have no part of :)
00:29:06 * hackagebot tttool 1.4.0.4 - Working with files for the TiptoiÆ pen  https://hackage.haskell.org/package/tttool-1.4.0.4 (JoachimBreitner)
00:45:10 <tsani> Servant is producing a 201 status when I'd like it to produce a 200 status code; how I can select which status code is used ?
00:48:13 <srhb> tsani: There's a pretty active #servant channel, perhaps they can help. :)
00:49:41 <anohigisavay> hi. is it possible to curry any number of arguments to a function? the arguments come from a list
00:49:52 <ski> echo-area : if you want to, you can define `result :: (b0 -> b1) -> ((a -> b0) -> (a -> b1)); result = (.)' (coming with `argument :: (a1 -> a0) -> ((a0 -> b) -> (a1 -> b))') and then it's `(result . result) return' (assuming `m' was a monad)
00:50:01 <ski> @where SEC
00:50:01 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
00:50:12 <srhb> anohigisavay: I think you're talking about multivariate functions, and no, not really (except yes of course) but you probably shouldn't.
00:50:14 <Lokathor> there's a haskell version of a C lib, but it's FFI bindings to the C lib.. but the C lib's core functionality is 1 function and 1 struct. why oh why.
00:51:04 <srhb> anohigisavay: If you need to take a number of same-typed arguments, lists are the way to go. If you don't, you probably have a design problem, but there's HLists and co.
00:51:50 <echo-area> ski: That is not intuitive, so I am keeping the anonymous function.  But thanks for the tip :)
00:52:23 <anohigisavay> srhb: yes they happen to be of the same type
00:52:34 <srhb> anohigisavay: Then why not just let your function take a list?
00:52:43 <srhb> anohigisavay: That encompasses arbitrary number of elements pretty well.
00:52:56 <anohigisavay> srhb:this is coincidence but i think using heterogenous lists is not a big deal to me
00:53:21 <srhb> That's pretty certain. :-)
00:53:32 <ski> echo-area : if you wanted to express `(a -> [Int] -> b) -> (a -> [Char] -> b)', then it could be `(result . argument . map) ord'
00:54:09 <anohigisavay> srhb: it's actually a data record with a lot of arguments. the arguments come from a row of a file
00:54:47 <srhb> anohigisavay: mhm. But why do you need arbitrary arity on your functions?
00:55:22 <EvanR> keeping the structure of that record straight is the point of the type system
00:55:35 <ski> echo-area : `result' focuses on the `[...] -> b' part of `a -> [...] -> b', then `argument' focuses of the `[...]' part of `[...] -> b', and then `map' focuses on the `...' part of `[...]'.finally, we apply the transformation `ord :: Char -> Int' on this focused position
00:55:52 <alpounet> tsani: as it currently stands, each method has its own "status code if everything goes fine". 201 only happens with POST endpoints, i assume that's your case too? for now, it's being discussed: https://github.com/haskell-servant/servant/issues/189
00:56:27 <alpounet> however i you really want it you can define your own "Post" combinator =) that returns the status you want
00:56:29 <EvanR> any number of arguments of any type, even if it made sense in haskell, you lose some guarantees about what your code can do
00:56:51 <anohigisavay> srhb: eventually i want to do something like: foldl (myApply)  MyConstructor [arguments..]
00:56:56 <ski> echo-area : it's definitely more readable than `((. map ord) .)', imho
00:57:02 <anohigisavay> srhb:and myApply applies one argument
00:57:11 <anohigisavay> is that a design problem?
00:57:13 <EvanR> you get the same effect if you have a sufficiently universal single sum type
00:57:24 <EvanR> basically, dynamic typing
00:57:26 <tsani> alpounet: yeah, I'm digging through the servant source right now, and I can see that the 201 code is baked into the POST request handling logic.
00:59:17 <ski> anohigisavay : what is the type of `myApply' ?
00:59:21 <echo-area> ski: It is cool
00:59:28 <EvanR> anohigisavay: that would work if MyConstructor took a list of Argument where all your arguments are the same type, which might be how youre secretly thinking of it. like, they are all Strings
01:00:12 <ski> echo-area : i'm not saying SEC is to always be preferred over lambdas. i'm just saying that it's worth being aware of, and worth considering, at times
01:00:15 <EvanR> but what you really want is to validate the strings and convert them to the proper types for that record
01:00:16 <echo-area> ski: BTW, is there a definition similar to `argument` in the standard?
01:00:19 <anohigisavay> ski: type is not rigid though. say (String -> String -> String) -> String -> (String -> String)
01:00:49 <anohigisavay> EvanR:coincidentally they take Integers. i can simply call read :: Integer
01:01:09 <EvanR> well read isnt the best method of validation + conversion
01:01:33 <echo-area> ski: Yes, I got that point.  Many thanks
01:01:56 <ski> (echo-area : for brevity, one could name them `res' and `arg' ..)
01:02:16 <alpounet> tsani: we're thinking about a way to change that for a future version, but I'm afraid you *have* to define another combinator for now if you want Post that doesn't return 201
01:02:16 <ski> i don't think they are in the standard
01:02:32 <anohigisavay> EvanR: right. but anyway i can provide a new function :: String -> Int and map it over the argument list
01:02:43 <EvanR> anohigisavay: the Read type class can get you out of half this conundrum, but you still dont have logically "any number" of arguments
01:02:51 <alpounet> OTOH, the advantage of having a DSL like that is that you can always ignore some standard combinators and define your own to do precisely what you need =)
01:02:58 <ski> anohigisavay : hm, you're parsing, then ?
01:02:59 <EvanR> anohigisavay: ... they are all Ints?
01:03:20 <ski> anohigisavay : have you considered using idiomatic/applicative style parsing ?
01:03:55 <ski> anohigisavay : i'm not clear on what `myApply' is supposed to do exactly .. in addition to applying some function to an argument, i mean
01:04:03 <anohigisavay> UM...
01:04:33 <anohigisavay> To make it clear, i'm reading from /proc/stat cpu usage info
01:04:50 <anohigisavay> each row is in a format of "cpuX: num1 num2 num3 ..."
01:05:02 <EvanR> MyConstructor <$> read1 row1 <*> read2 row2 <*> ...
01:05:12 <EvanR> where each read has the right type
01:05:14 <anohigisavay> they have concrete meanings and they map to each argument in my data record
01:05:44 <EvanR> or that seems like a matrix
01:05:56 <ski> the syntax EvanR showed is the idiomatic style
01:06:08 <anohigisavay> um...
01:06:12 <anohigisavay> let me see
01:06:30 <anohigisavay> Kool
01:06:56 <anohigisavay> i think that solves the problem
01:07:42 <anohigisavay> no no
01:07:57 <ski> btw, if you're going to use operations based on the `Read' class, then it's probably better to use `reads' rather than `read'
01:08:24 <tsani> alpounet: for now I think I'll code my own Post200 combinator or some such. It would be cool if there were a way to override the status code of the built-in combinators though
01:08:44 <echo-area> I think a gift of using operators is that they encourage thinking at a more abstraction level and thus leading to the discovery of the nature of a piece of computation
01:08:47 <anohigisavay> wait. what i intended first was to reduce the tedium of repetitive <*>
01:08:55 <echo-area> *abstracted
01:09:36 <ski> anohigisavay : it's not clear if there's a fixed number of numbers following the `cpuX:' or not
01:10:11 <ski> iow, is there a fixed number of them, each having a different interpretation, or is there a variable-length list of them, each element having a similar interpretation ?
01:10:21 <anohigisavay> ski:it's fixed number. but what if it's 100?
01:10:22 <ski> (or perhaps some combination of the two)
01:11:02 <ski> if it's 100, perhaps they're conceptually grouped in some way, which you could use to structure the parsing
01:11:07 <anohigisavay> in reality it's 10 numbers
01:11:44 <srhb> So you're asking: For the sake of argument, what if I have Foo Field1 Field2 Field3 ... Field100, and they're all disparate and I can parse those 100 fields simply from a text file but I want to be able to apply Foo without being explicit about each Field
01:12:00 <anohigisavay> srhb:yes exactly
01:12:35 <anohigisavay> maybe template haskell can help? but i'm not familiar with that
01:14:08 <srhb> Possibly.
01:14:58 <srhb> I'd probably end up with some kind of [Attr] list instead
01:15:06 <srhb> Or Map, even.
01:16:48 <anohigisavay> srhb:thanks i think i'll try with Map
01:17:21 <srhb> Like, data FieldType = Field1 | Field2 | ... and then DataSet (Map FieldType Value)
01:17:43 <srhb> I would not do it for something as short as you're doing though.
01:18:09 <EvanR> very large records are probably not a great idea
01:18:30 <srhb> EvanR: How'd you do it?
01:18:42 <srhb> I think the Map method is OK, but I've never actually thought about it before.
01:18:47 <EvanR> ski suggested splitting it up into groups
01:19:02 <EvanR> i was only thinking of the performance of updates
01:19:06 <srhb> Right, if they are gconceptually grouped that sounds fine.
01:19:08 <anohigisavay> well in reality the list is not very long. and i think listing the names in the data definition makes clear the intuition
01:19:29 <EvanR> wait until theres an actual problem to solve it
01:22:09 <anohigisavay> well lucky that i'm only getting cpu usage. next time i read IRQ info i'm in this trouble xD
01:22:56 <anohigisavay> thank you guys you've been of great help
01:25:32 <jle`> first time i had to provide explicit kind signatures in a RankN type
01:25:38 <jle`> sometimes i think i'm going too deep
01:50:03 <bdha> Anyone using Stack a fair bit? I'm trying to seed .stack on build machines, and seeing some .. non-deterministic behavior.
02:25:00 <DruidofLuhn> Hello
02:25:07 <DruidofLuhn> Got a question about defining a type
02:25:20 <DruidofLuhn> Is it possible to define a numeric type that can only have 3 given values?
02:25:29 <DruidofLuhn> Or is there a better way to do it?
02:26:24 <jle`> DruidofLuhn: do you mean something like, data MyNum = One | Two | Three ?
02:27:24 <DruidofLuhn> jle`: Yeah, hadn't thought of that, as I was going to use the integer values, but actually don't
02:27:46 <DruidofLuhn> jle`: thanks, seems rather obvious really
02:29:13 * hackagebot moesocks 0.1.0.25 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.25 (JinjingWang)
02:33:13 <jle`> i have definitely gone way too deep
02:34:48 <concept> What is the relation between type theory, set theory and category theory ? 
02:37:07 <EvanR> HMM https://www.andrew.cmu.edu/user/awodey/preprints/stcsFinal.pdf
02:37:10 <EvanR> concept: ^
02:37:18 <phadej> concept: usually the third one is "logic", not set theory
02:37:39 <phadej> https://existentialtype.wordpress.com/2011/03/27/the-holy-trinity/ shorter intro
02:38:04 <concept> I was reading https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
02:38:17 <concept> and I have small background in category theory
02:38:19 <phadej> ah, there is the foundation of math "trinity" too
02:38:31 <phadej> TIL
02:47:10 <EvanR> in the paper i pasted, the author considers type theory and higher order logic as the same thing
02:47:25 <EvanR> at least, inhabiting the same place in the triangle
02:47:54 * EvanR continues cargo culting
02:52:37 <jle`> i've found the need for newtype Fix2 f a = Fix2 (f (Fix2 f) a), and newtype Fix3 f a b = Fix3 (f (Fix3 f) a b)
02:52:46 <jle`> are these already anywhere on hackage?
02:53:21 <mniip> reminds me of MuT
02:53:54 <jle`> mniip: is in a package/written about anywhere i can look up?
02:54:14 <jle`> i really only need Fix3, so i could probably write all the utility functions on it myself, but it'd be nice if it was already somewhere implemented
02:54:17 <jle`> like ana, cata, etc
03:01:39 <EvanR> phadej: in the comments of that post, it links to a book practical foundations of programming languages, do you know if this is any good?
03:24:16 <lwm> can someone point me in the right direction for how to solve a problem? It's basically a big case statement involving IO but not sure exactly where to start
03:24:18 <lpaste_> lwm pasted ‚Äúhowto.hs‚Äù at http://lpaste.net/139677
03:25:13 <dramforever> lwm: do your whole thing inside an IO action
03:25:42 <dramforever> and that "return $"s don't make sense, because getEnv is in IO already
03:25:57 <lwm> oh woops, I thought I removed them :|
03:26:17 <lwm> ok, but cool, so I should try to get each env variable and then assign them into the connection info
03:26:57 <dramforever> "assign" well we try to avoid that word here...because it kinda implies mutable variables
03:27:01 <phadej> EvanR: hadn't time to read PFPL, unfortunately
03:27:38 <lwm> haha right
03:32:03 <lwm> OK, this works:
03:32:05 <lpaste_> lwm pasted ‚Äúhowto2.hs‚Äù at http://lpaste.net/139678
03:32:54 <captain_haddock> did http://augustss.blogspot.co.uk/2014/04/a-small-haskell-extension.html ever get off the ground?
03:33:14 <lwm> thanks @dramforever
03:33:15 <captain_haddock> specifically, being able to do something like (show . (:: Double) . read)
03:33:47 <ttt_fff> is "what music do you listen to while coding" #haskell or #haskell-blah ?
03:34:01 <tdammers> ttt_fff: I'd say -blah
03:40:22 <Taneb> apo_, I don't believe so
03:40:31 <Taneb> captain_haddock, sorry
03:52:09 <orbifx> can `sepBy` from Parsec return tuples somehow?
03:52:44 <orbifx> and can the rest of the Parsec deal with that? or do I have to get the the list of values and then convert them to another structure?
03:53:46 <tdammers> orbifx: sepBy returns a list, there is no way to change that
03:54:00 <orbifx> ok
03:54:12 <orbifx> so convert outside the parser then?
03:54:31 <tdammers> also note that there is no function [a] -> (a, a) that isn't partial
03:54:50 <tdammers> (and partial => evil)
03:55:42 <tdammers> so I'm guessing what you really want is either explicitly parsing each element and the separator, and then returning a tuple constructed from the results, which will allow you to fail when the number of elements doesn't match your tuple type
03:56:01 <tdammers> or you'd use sepBy anyway, but add a check that fails when the number of elements isn't right
03:56:40 <tdammers> oh, and, consider applicative syntax and tuple sections for this kind of thing
03:56:44 <tdammers> it's really nice:
03:57:04 <tdammers> (,) <$> firstElem <*> (separator >> secondElem)
03:57:27 <mniip> <*
03:57:38 <tdammers> it's equivalent to do { a <- firstElem; separator; b <- secondElem; return (a, b) }
03:57:42 <tdammers> :t (<*)
03:57:43 <orbifx> i want a [(a,a)] type where is element in the list i a line
03:57:43 <lambdabot> Applicative f => f a -> f b -> f a
03:57:46 <mniip> (,) <$> firstElem <* separator <*> secondElem
03:57:54 <tdammers> right, that
03:58:55 <orbifx> from what you are saying then, the rest of Parsec doesnt care if the seperator parser returns a tuple?
04:00:07 <tdammers> the separator parser itself should return (), I would think
04:00:37 <tdammers> but other than that, parsec doesn't care at all about what the parsers return, as long as the whole thing typechecks
04:01:22 <orbifx> csvFile = endBy line eol 
04:01:24 <orbifx> line = sepBy cell (char ',')
04:01:26 <orbifx> cell = quotedCell <|> many (noneOf ",\n\r") 
04:01:31 <tdammers> that's basically reflected in the types of the Parsed functions
04:01:46 <tdammers> oh, right, CSV
04:01:56 <tdammers> I don't think you can use tuples for that
04:02:06 <orbifx> so i can apply applicatives on: line = (,) <$> ... sepBy .. ?
04:02:12 <tdammers> no
04:02:16 <tdammers> well
04:02:48 <tdammers> the thing is, tuples of different arities are separate types
04:03:03 <tdammers> your parser can return (a, a), or it can return (a, a, a), but it can't be both
04:03:29 <orbifx> I know
04:03:44 <tdammers> so the arity has to be fixed at compile time
04:03:58 <orbifx> I want to force it to return a tuple with two elements anyway, even if it means ("", "")
04:04:05 <tdammers> ah
04:04:28 <tdammers> in that case, I'd go with something like:
04:04:32 <orbifx> its currently givining me [[String], [String]] and I want ([String], [String])
04:05:07 <tdammers> yeah, so you're blocked on [a] -> (a, a)
04:05:24 <tdammers> and we're back to the fact that that function is partial
04:05:35 <tdammers> but if you can somehow provide a default, then it doesn't have to be
04:05:50 <tdammers> [String] -> (String, String) is solvable
04:06:12 <tdammers> you can either pattern-match to handle the nullary and unary cases separately
04:06:34 <tdammers> or you can append a list of empty strings to the input and then take the first two elements
04:06:47 <tdammers> (an infinite list, that is, or a 2-element list, whatever you prefer)
04:07:09 <tdammers> or you could use something like headDef from Safe
04:07:13 <tdammers> many ways
04:08:55 <orbifx> by the way when you say partials -> evil, you are not talking about using partial function right? Cause I though it's all about point-free?
04:09:53 <ChristianS> orbifx: they are talking about functions that die with an error on some inputs. nothing to do with point-free.
04:10:24 <orbifx> ChristianS: ok thought so
04:10:45 <orbifx> back to getting a tuple with sepBy
04:11:25 <orbifx> can I apply the applicative in line = ... sepBy cell.. ?
04:14:16 * hackagebot dataflow 0.7.3.0 - Generate Graphviz documents from a Haskell representation.  https://hackage.haskell.org/package/dataflow-0.7.3.0 (owickstrom)
04:16:57 <ocharles__> Does anyone know what units the `length` parameter to `Data.Vector.Storable.Mutable.unsafeFromForeignPtr0` is?
04:17:04 <ocharles__> is the amount of elements, or the amount of bytes?
04:17:55 <ocharles__> I think it's the amount of elements, from what I understand reading the code
04:20:19 <dramforever> hmm...
04:20:26 <dramforever> partial application/partial functions
04:20:29 <orbifx> ocharles__: can you run a test to find out?
04:21:11 <ocharles__> orbifx: you mean do some work?!
04:21:12 <ocharles__> :)
04:21:40 <orbifx> :P
04:22:00 <orbifx> dramforever: yeah i think that is the distinction :P
04:22:26 <darenthis> I have the following (broken) code: http://lpaste.net/448605472891600896 I'm wanting to inject the result as the new starting state each time round the loop. Can anyone help?
04:23:18 <dramforever> darenthis: use a function that takes the state as an argument
04:26:21 <bernalex> anyone in Trondheim? http://www.meetup.com/Trondheim-Haskell-Users-Group/events/224896251/
04:27:24 <lf94> guys...how can I terminate dfsTree's execution when I find the node I'm after? https://gist.github.com/lf94/8558d89d380f7a26fdad
04:27:37 <lf94> Like, if I remove n : it just returns the node I was looking for
04:27:51 <lf94> But I want the path it took to that node
04:29:45 <lf94> Nevermind I think I have it!
04:35:11 <bernalex> hyPiRion: ser deg ikke i #plaimi. ;_;
04:35:39 <bernalex> hyPiRion: uansett, send gjerne rundt ^^^^^^ om du kjenner litt haskellere eller bare studenter i trondheim enn√•. :]
04:37:36 <dramforever> weird...that looks on topic
04:37:57 <dramforever> although it doesn't make sense to me
04:39:13 <bergmark> that's norweigan for you
04:40:42 <hyPiRion> bernalex: my server died, so I've been slowly accumulating my lost channels
04:41:39 <ttt_fff> -–∏–π–Ω –Ø–ø–æ–Ω –¥–∞—Ö—å Haskell —è—Ä—å—è
04:43:24 <kqr> is there a name for the function (:[]) in the standard libraries?
04:44:19 <bernalex> maybe? why would you want it though? :[] is rather short.
04:44:21 <cocreature> kqr: you can use the applicative/monad instance of lists for that so it is pure/return
04:46:33 <kqr> bernalex, mostly because when used with composition it becomes character soup
04:47:17 <kqr> bernalex, ((:[]) . unpack) is not nearly as nice as something like (singleton . unpack)
04:47:38 <kqr> cocreature, that's probably the best suggestion so far! cheers
04:47:46 <cocreature> np
04:51:31 <lf94> can you stop the recursive execution of a function right away
04:51:40 <lf94> and just leave it
04:51:43 <lf94> or something
04:51:44 <lf94> x_x
04:52:31 <ely-se> errir
04:52:34 <ely-se> error*
04:52:42 <lf94> https://gist.github.com/lf94/8558d89d380f7a26fdad
04:53:07 <lf94> I'm trying to stop the dfsTree function from concatenating numbers when it finds the Node 5
04:53:18 <lf94> So I only have the path to Node 5
04:53:35 <lf94> Right now I can get it to just return [5]
04:53:45 <lf94> Which is nice, but I'd like that path it used to get there too
04:54:38 <lf94> Maybe I need like, (GoodNodes, BadNodes) or something
04:56:26 <Ornedan> Can you have one or more matches?
04:56:49 <lf94> The first match is good enough, this is just a personal exercise
04:56:58 <lf94> I think I'm going to do what I said
04:57:08 <lf94> and at the end, just throw out the nodes I don't want
04:57:15 <lf94> (The ones on the right
04:57:16 <lf94> (
04:57:20 <lf94> ))
04:57:48 <lf94> Haha, I guess Either may be useful.
04:58:11 <lf94> Either a b, where a are the nodes I don't want, so I can fold over b if I wanted.
04:58:25 <Ornedan> If you allow for more than one match, it's basically filter
04:59:12 <lf94> How?
04:59:49 <Ornedan> Well, you want the paths to the matching nodes, right? So that result can be represented with a pruned tree
04:59:56 <lf94> How do the other branches with nodes 3 and 4 know the goal is found
05:00:10 <lf94> mmm
05:00:18 <catgocat> Is there a library for running and manipulating headless browsers?
05:00:29 <catgocat> Something that allows me run a headless browser in Haskell
05:00:39 <catgocat> For logging into websites etc.
05:00:50 <bennofs> https://hackage.haskell.org/package/webdriver perhaps?
05:01:57 <catgocat> bennofs: thanks
05:02:21 <lf94> selenium is closed source?
05:02:44 <lf94> I'd rather use casperjs+phantomjs than this if that's the case
05:04:41 <Intolerable> ?
05:04:42 <Intolerable> https://github.com/SeleniumHQ/selenium
05:05:22 <lf94> Ok cool :)
05:05:39 <lf94> I couldn't find anything on their project page quickly that suggested it was open source
05:21:04 <Ornedan> lf94: http://lpaste.net/139681
05:22:11 <frerich> lf94: You might also like http://phantomjs.org/
05:22:34 <Arahael> So, I tried installing a haskell game.  ned #haskell                                                          ‚îÇ absence   
05:22:41 <Arahael> Darn clipboard.
05:22:47 <Arahael> This one: https://github.com/ivanperez-keera/haskanoid
05:23:13 <Arahael> Not trivial, seems I need a bunch of C libraries that cabal doesn't manage. Is this normal for haskell projects?
05:23:34 <Arahael> Doesn't seem hard, mind you - may yet be easy, but definitely not trivial.
05:23:58 <dramforever> cabal can't manage those foreign libraries
05:24:17 <Arahael> dramforever: It can't, at all? :/  Perhaps it should include them in-tree, then?
05:24:19 <Ornedan> Well, you specifically picked one that uses a lot of external systems
05:24:25 <Arahael> Or auto-wget them.
05:24:31 <Arahael> Ornedan: Do you have other suggestions?
05:24:34 <Arahael> (Other games)
05:24:37 <dramforever> and I'm not aware of any package manager(*) that does manage this
05:25:05 <dramforever> *: some say that cabal isn't a package manager, but I would rather say that it's pretty incomplete as for now
05:25:05 <Ornedan> Not really, but my point is "The game has been created for educational purposes, but tries to feature a substantial amount of the complexity often found in real arcade games."
05:25:16 <srhb> dramforever: Nix does it, I think?
05:25:30 <Arahael> srhb: Indeed, to a point.
05:25:48 <srhb> Yeah it's custom made nixexprs, of course.
05:25:50 <Arahael> Though it isn't unusual for C or C++ projects to auto-pull in their deps and link them in.
05:25:57 <Ornedan> You'd run into similar things in any language once sound and more than basic I/O systems come into play
05:26:33 <Ornedan> And complex graphics, for that matter. Although I think current Haskell Platform at least includes OpenGL
05:26:53 <Arahael> Ornedan: Last time I checked, even OpenTTD was simpler to build.
05:27:18 <Arahael> Though SDL does seem to have a huge bunch of deps, by the looks of it.
05:27:25 <KaneTW> it's pretty normmal that you have to pull in external  deps first
05:27:49 <KaneTW> for nearly any language
05:28:13 <bennofs> tbh, I don't like build systems that try to fetch & build all deps. At least if they don't also give me the possibility of using an already-installed version of a library
05:29:04 <Arahael> bennofs: I've seen a bunch that first try to see if it's present, and if not, fall back to an internal one.
05:29:27 <Ornedan> Theoretically Cabal could generate the list of required external library headers, and you could then feed that to 'yum whatprovides' or equivalent
05:29:27 <Arahael> Python will build C libraries automatically, incidentially.
05:29:39 <Arahael> Eg, pip install whatever.
05:29:55 <Ornedan> Where does it get those C libraries from?
05:30:09 <Arahael> Ornedan: It's specified in the respective setup.py file.
05:30:38 <Arahael> Well, this isn't a good sign: checking whether the C compiler works... no
05:32:00 <Arahael> gcc, the compiler it used, definitely can produce executables.
05:34:09 <Arahael> How do i get the intermediate config.log from a corresponding SDL-image-0.6.1.1 failed during the configure step. The exception was:
05:34:29 <Arahael> (When invoking cabal install)
05:34:56 <Intolerable> it'll be in ~/.cabal/logs
05:35:01 <Intolerable> or .cabal-sandbox/logs
05:35:40 <Arahael> Ah, indeed - in the latter.
05:36:07 <Arahael> Outdated ./configure options, by the looks of it.
05:39:01 <Arahael> Hmm. breakout doesn't build either, haskgame is broken.
05:39:20 * hackagebot snmp 0.2.0.1 - API for write snmp client.  https://hackage.haskell.org/package/snmp-0.2.0.1 (chemist)
05:45:07 <Arahael> Ornedan: An alternative is to have a virtual or fake package that just brings in the C library - really, cabal should look at pip and to a lesser degree, ruby gems, to see how they do it.
05:45:30 * Arahael just got haskanoid to compile! breakout is too old, as is momao.
05:46:25 * Arahael i shappy.
05:49:07 * Arahael blinks.
05:49:13 <Arahael> I lost the damnned ball!
05:49:23 <Arahael> (In the game. :) )
05:50:33 <lwm> nice job Arahael
05:50:49 <lwm> you won the real game, which was, compiling the damn thing
05:51:08 <lwm> anyone used Servant? I keep getting an import error when I do `import Servant`
05:51:26 <lwm> I am trying to get at the `serve` function
05:54:16 <bennofs> Arahael: how do you "bring in the c library"? Doesn't this depend on the package manager that you use and which Linux distribution ? (
05:58:48 <alpounet> lwm: have you been able to solve your servant problem?
05:58:50 <EvanR> rubygems seems to build c libs behind the scenes on its own
06:01:24 <newstuff> ||||| >>>>> WHAT IS YOUR DOMAIN NAME WORTH? Vist >>> www.VALBOT.com <<< FREE DOMAIN VALUATION! or GOOGLE >>> VALBOT.com <<< |||||
06:01:35 <Intolerable> oh dear
06:02:56 <fvgvxmpv1> "google <domain>", really?
06:03:41 <EvanR> wait about 3 years, that is what commercials will be telling you to do to their domain
06:03:54 <EvanR> google our domain name today
06:04:09 <lwm> alpounet: sure, but actually, on to a new one. When I run a server, I get no debug info on the CLI
06:05:58 <lwm> oh, it appears it has something to do with Warp ... Ill keep digging
06:06:01 <TiTo___> hi haskellers
06:06:26 <TiTo___> I have a question which is what is the difference between these two functions?
06:06:29 <TiTo___> factorial :: (Integral a) => a -> a   factorial 0 = 1   factorial n = n * factorial (n - 1) 
06:06:37 <TiTo___> factorial' :: Int -> Int  factorial' 0 = 1   factorial' n = n * factorial' (n - 1) 
06:07:21 <cocreature> TiTo___: the first one works for any type that is an instance of the Integral typeclass. so it does not only work for Int, but also for Integer and similar stuff
06:08:37 <TiTo___> @cocreature  Thanks a lot 
06:08:37 <lambdabot> Unknown command, try @list
06:09:43 <TiTo___> when should I use a (Integral a ) => ???
06:09:54 <EvanR> it doesnt actually need Integral right
06:09:57 <EvanR> only Num
06:10:41 <cocreature> EvanR: yeah, but you'll loop if you pass in 1.5
06:11:11 <TiTo___> is Num more general than Integral 
06:11:15 <EvanR> is there a law that says you cant be Integral and Fractional
06:11:33 <EvanR> TiTo___: Num gives you 0 1 - and * needed for your function. Integral builds on that and gives you division
06:12:06 <cocreature> also "toInteger" is an important part of Integral
06:12:12 <TiTo___> do you advice to keep using (Integral a)=> for all functional that deals with Int & Integer instead of Num ?
06:12:23 <EvanR> if you need division
06:12:42 <EvanR> but rule of thumb is use the most general class you can
06:13:08 <EvanR> or dont use a class
06:14:00 <TiTo___> By using Num, or Integral typeclasses, will that affect the over all execution time or the performance ??? 
06:14:28 <EvanR> if toInteger is supposed to be an injective function into the integers, then that'd eliminate the possibility of a fractional type
06:15:08 <Twey> Is MonadComprehensions in 2010?
06:15:39 <EvanR> TiTo___: depending on how you use your polymorphic function, it may have the same performance as using a monomorphic version, or it may not
06:17:14 <EvanR> TiTo___: in the worst case scenario, any function using a class constraint like that will be implemented by passing a dictionary of the methods behind the scenes, if that helps
06:17:44 <EvanR> but it might be optimized away
06:19:09 <quchen2> Twey: No
06:19:43 <TiTo___> Therefore its better for practice and performance to stay with monophonic till I do need to use polymorphic  
06:20:13 <EvanR> generally i prefer stereo
06:21:41 <EvanR> do what makes the most sense until it becomes a performance concern as evidenced by testing
06:22:12 <Twey> quchen2: Thanks!
06:22:17 <fvgvxmpv1> MonadState s m | m -> s has a functional dependency. I¬¥m trying to have a newtype Foo = Foo { unFoo :: StateT SOne (StateT STwo Identity) } and MonadState instances. Because of functional dependencies this won¬¥t work as such. Any suggestions for a workaround?
06:22:19 <Twey> (also, awww.)
06:23:28 <Twey> fvgvxmpv1: You can make an instance  MonadState (SOne, STwo) Foo
06:24:07 <Twey> Because it's isomorphic to newtype Foo = Foo { unFoo ‚à∑ State (SOne, STwo) } anyway, I think
06:24:26 <Twey> Er, plus return type
06:27:38 <fvgvxmpv1> Twey: ah, yes I considered that. I seem to have oversimplified :/ What I¬¥m actually using is a custom transformer (let¬¥s call it StateT') where those two things would have significantly different behaviour (My state is not held in RAM but serialized to disk ‚Äî (a, b) would get one file while the transformer stack gets two)
06:27:53 <Twey> Aha
06:28:04 <Twey> fvgvxmpv1: You can still write a MonadState (SOne, STwo) Foo
06:28:53 <Twey> Even if you've got  DiskStateT SOne (DiskState STwo) r  underneath
06:29:47 <fvgvxmpv1> Oh I see
06:29:53 <fvgvxmpv1> yes, that¬¥s a viable solution, thanks
06:30:28 <sgflt> has there been a "Common" module that is no more? i'm new and trying to compile https://hackage.haskell.org/package/alsa-seq-0.6.0.5/src/examples/dump.hs, but ghc complains "Could not find module `Common'"
06:30:51 <Twey> fvgvxmpv1: It's not because of the functional dependency that you can't do what you want ‚Äî the functional dependency is just expressing in the type system the constraint that each state monad can only have one state type
06:31:40 <Twey> In your example, if you were allowed to write both instances, it would be unclear whether ‚Äòget‚Äô should return an SOne or an STwo, for example
06:32:06 <Twey> But really you want it to return both, so you expose the combined state as a pair
06:32:17 <fvgvxmpv1> I guess I just assumed that type inference on all occurrences of get would‚Ä¶ occur
06:35:22 <lush> yo)
06:36:06 <Twey> fvgvxmpv1: I think you can start getting into OverlappingInstances territory, that way
06:40:41 <Twey> sgflt: It's in the package, next to dump.hs
06:41:05 <Twey> sgflt: You'll want to be in the same directory as dump.hs when compiling it
06:41:18 <Twey> (or add that directory to your include path)
06:42:43 <catgocat> What is a good headless browser library for Haskell? I have tried selenium but it requires java + it doesnt hide the browser
06:43:41 <athan_> catgocat: I don't think there is one yet. PhantomJS might be the best bet for now.
06:43:55 <quchen2> ?quote elliott conservative
06:43:55 <lambdabot> elliott says: An interesting exercise is to try and imagine a language revision more conservative than H2010.
06:43:57 <quchen2> Twey: ^
06:44:07 <Twey> Haha.
06:44:13 <Twey> quchen2: It added PatternGuards!
06:44:27 <quchen2> Ssssh
06:44:34 <quchen2> (I've never used a pattern guard.)
06:44:35 <Twey> And MonadComprehensions (or some of them, anyway) are actually a reversion!
06:44:52 <Twey> I have, but not nearly as often as I've used a ViewPattern.  :√æ
06:45:30 <orbifx> how can I get something outside the scope of a case?
06:45:48 <orbifx> a "variable"
06:45:56 <quchen2> Twey: H20 will be a little bigger though.
06:46:07 <quchen2> MultiBangCase and friends ;-)
06:47:10 <Twey> quchen2: Haha.  ‚òπ
06:47:24 <Twey> orbifx: Please rephrase?
06:47:42 <geekosaur> orbifx: case is an expression. it's not uncommon to see: x <- case foo of { 1 -> doThis; a -> doSomethingElse a }
06:48:01 <geekosaur> or similar with let, although that's less commonly needed
06:48:05 <dramforever> orbifx: return that value
06:48:08 <Twey> Oh, ‚Äòoutside‚Äô in that sense
06:48:11 <orbifx> geekosaur: i did that but it freaked out
06:48:23 <dramforever> orbifx: I wonder if it's just a conversion
06:48:29 <orbifx> maybe my tabulations where getting wrong (yes I'm using spaces)
06:48:32 <dramforever> if that's the case then just return the value you want to get out
06:48:59 <geekosaur> @paste your code?
06:48:59 <lambdabot> Haskell pastebin: http://lpaste.net/
06:49:01 <dramforever> > case Just 2 of Just _ -> 1; Nothing -> 2
06:49:03 <lambdabot>  1
06:50:01 <orbifx> I get a "The last statement in a 'do' block must be an expression"
06:50:23 <orbifx> but I have `return` as the last statements
06:50:43 <dramforever> @paste your code -- no question mark here, just do it
06:50:43 <lambdabot> Haskell pastebin: http://lpaste.net/
06:50:53 <dramforever> =P
06:51:24 <orbifx> coming
06:51:51 <srhb> Generally that happens when you have a do block that ends in a <- bind, which is not allowed, case or not.
06:52:29 <orbifx> http://lpaste.net/139684
06:52:48 <srhb> What on earth are those dollar signs at the end?
06:53:07 <Intolerable> semicolons?
06:53:14 <orbifx> ah
06:53:23 <orbifx> srhb: you are write
06:53:35 <orbifx> I hadn't finished writing the code after the case bind :P
06:53:36 <dramforever> orbifx: eol markers?
06:53:55 <orbifx> dramforever: srhb: they are vim markers, ignore them
06:54:01 <dramforever> ok
06:54:08 <srhb> orbifx: Right. You can always throw in a return () or undefined or whatever at the end while you're working on it.
06:54:23 * hackagebot cgrep 6.5.3 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.3 (NicolaBonelli)
06:54:37 <orbifx> srhb: yeah
06:54:39 <dramforever> orbifx: i wonder why you can't just continue in the Right branch
06:54:53 <dramforever> you know, you could shift the case block to a left quite a bit
06:55:04 <orbifx> dramforever: I don't like extended codes
06:55:09 <orbifx> extensive^
06:55:15 <dramforever> extensive?
06:55:21 <orbifx> 3-5 lines, then on to another function or block
06:55:35 <sgflt> Twey, thanks
06:56:19 <dramforever> orbifx: I don't think it's too bad, you know, especially if it's not very deep
06:56:41 <dramforever> if you are doing something like 7 nested case expressions then something is wrong
06:57:01 <geekosaur> heh, someone else using :set list
06:57:17 <dramforever> ?
06:57:39 <orbifx> dramforever: geekosaur is on about vim options
06:57:43 <geekosaur> ^
06:57:51 <geekosaur> makes line endings tabs, etc. visible
06:57:58 <dramforever> ok
07:00:30 <orbifx> geekosaur: are you using any haskell related plugins?
07:00:38 <geekosaur> nope
07:00:56 <geekosaur> mostly I use emacs for "serious" development and vi(m) for quick stuff
07:01:12 <geekosaur> ...emphasis on "quick" so no plugins etc. for vi
07:01:36 <geekosaur> (then again I'm not that much into fancy editing support packages anyway)
07:01:38 <quchen2> edwardk: Why does your Heap type (from heaps) carry the comparison operator with it, instead of using an external Ord constraint in all the functions?
07:02:17 <ahg> In "stack ghci", how can I get access to Data.Numbers.Primes?
07:02:30 <Twey> orbifx: If you use 22 spaces for an indent level, I'm not surprised!
07:02:48 <ahg> I see "Could not find module" errors when I try to load it
07:03:03 <geekosaur> ahg, I think we need a bit more information
07:03:09 <geekosaur> that said, you might ask in #haskell-stack
07:03:14 <dramforever> Twey +1
07:03:39 <ahg> @geekosaur thanks. I'll try there
07:03:39 <lambdabot> Unknown command, try @list
07:03:40 <dramforever> I said "shift left a bit" for the same reason
07:03:46 <quchen2> It's quite weird to read all those operations like "nub" not requiring a constraint. Furthermore, the docs claim the type is a min heap, when it's actually "some heap that carries a comparison operation", with the min-heap property enforced by the API instead of the type, which has the comparison left open explicitly.
07:04:53 <orbifx> Twey: not surprised about what?
07:05:49 <supki> quchen2: have you seen the comment in the source of Data.Heap under the import list?
07:06:22 <quchen2> supki: Aaah, I haven't seen that. Thanks, makes perfect sense!
07:06:50 <srhb> orbifx: They're saying: "Why not indent something like this?" http://lpaste.net/139684
07:06:56 <quchen2> Interesting trick.
07:08:58 <orbifx> srhb: because it was giving me errors, and my knowledge, experience and confidence when errors occur with haskell make me reconsider everything, I ended up with the ridiculous indentation. It is fixed now
07:09:21 <srhb> orbifx: OK, sure, I don't think anyone meant to imply that it was stupid or anything, just that it could be better. :-)
07:09:24 * hackagebot relational-query-HDBC 0.1.0.1 - HDBC instance of relational-query and typed query interface for HDBC  https://hackage.haskell.org/package/relational-query-HDBC-0.1.0.1 (KeiHibino)
07:09:26 * hackagebot persistable-record 0.1.0.1 - Binding between SQL database values and haskell records.  https://hackage.haskell.org/package/persistable-record-0.1.0.1 (KeiHibino)
07:10:31 <orbifx> ofcourse, no offense taken. It was silly :P
07:10:50 <Twey> orbifx: http://lpaste.net/6449232259273719808
07:10:58 <geekosaur> you're allowed to ask for help :) I think getting the hang of layout bites pretty much everyone early on
07:12:10 <srhb> Suddenly, arrow operators!
07:12:14 <hexagoxel> are the older releases of haskell platform available somewhere?
07:12:48 <Twey> orbifx: Rather than shooting off to the right or returning a value back up, you can extract a chunk of your code into a new function
07:13:10 <orbifx> nice one Twey 
07:13:17 <Twey> orbifx: Haskell code often comprises many small functions, rather than one big one
07:13:44 <orbifx> makes sense, i like that in the language (C++ background here, function = expense :P)
07:14:00 <orbifx> but I get haskell, not worried about such things when using it.
07:14:16 <orbifx> But it is a leap in everything, from syntax to code composition
07:14:16 * Twey nods.
07:14:44 <dramforever> function = expense lol
07:14:48 <orbifx> so when an error baffles me, everything is under scrutiny
07:14:56 <Twey> orbifx: People have differing opinions, but I would usually consider any function (equation) bigger than about five lines to be suspiciously large
07:15:17 <orbifx> "is the feng shui in the room right or is it causing this error"
07:15:18 <dramforever> Twey +1 except for well known algorithms
07:15:27 <Twey> orbifx: Hehe
07:15:34 <Twey> orbifx: Haskell isn't out to get you!
07:15:40 <dramforever> orbifx: must be feng shui =)
07:15:41 <srhb> orbifx: I know that feeling... In any language :P
07:15:54 <Twey> dramforever: I don't know, often the well-known algorithms can be broken down too
07:16:03 <Twey> Though sometimes it's non-trivial
07:16:05 <orbifx> Twey: I'm the same about functions in terms of size, even in C++ actually.
07:16:23 <dramforever> Twey: the red-black tree, for example, has (IIRC) 5 cases for insertion
07:16:40 <Twey> Note ‚Äòsuspiciously‚Äô, not ‚Äòerroneously‚Äô.  There are certainly some functions that are better expressed in larger blocks, but they're rare enough that I look twice.
07:16:41 <dramforever> don't tell me you think you can write them in one line
07:16:56 <Twey> dramforever: No, of course not, but I might break them into one function per case
07:17:04 <dramforever> each case isn't very long
07:17:10 <Twey> dramforever: That's the point :√æ
07:17:34 <dramforever> I wonder if it's actually useful...
07:17:42 * Twey shrugs.
07:17:50 <Twey> It's a stylistic question
07:18:49 <dramforever> yep
07:25:07 <stelleg_> do people considered undefined a value or an expression?
07:25:12 <stelleg_> consider*
07:26:21 <stelleg_> i'm wondering if it's correct to say there are no values of type forall a, a
07:27:00 <Twey> stelleg_: Sometimes
07:27:18 <Twey> stelleg_: Often we like to reason ‚Äòup to termination‚Äô, assuming all functions are total
07:27:48 <Twey> There are no *total* values of type forall a. a
07:28:05 <Twey> But there is of course undefined, error "foo", let x = x in x, &c.
07:29:02 <stelleg_> Twey: but I guess if you don't define undefined and (error x) values, then there aren't *values* of type forall a, a, just expressions
07:29:11 <stelleg_> e.g. let x = x in x
07:29:27 <Twey> Good point
07:29:37 <dramforever> good theory
07:30:15 <Twey> If you're using ‚Äòvalue‚Äô to mean ‚Äòterm in normal form‚Äô, then that's true, as well
07:30:22 <orbifx> can Map support duplicate items?
07:30:27 <Twey> orbifx: Of course
07:30:40 <stelleg_> Twey: right, I'm using the term to mean 'term in whnf'
07:30:41 <Twey> (even WHNF, I think?)
07:30:44 <Twey> Yeah
07:30:46 <orbifx> 00 how did you answer within 6 secs?! :P
07:30:51 <Taneb> orbifx, duplicate values, not duplicate keys
07:31:00 <stelleg_> Twey: thanks for the discussion!
07:31:10 <Twey> No problem ‚ò∫
07:31:24 <Twey> orbifx: Five, actually!
07:31:30 <orbifx> within :P
07:31:34 <Twey> orbifx: (I happened to already be looking at IRC :√æ)
07:32:02 <aweinstock> :t fix id
07:32:02 <Twey> If you want duplicate keys then you can use a Map k (Set a)
07:32:03 <lambdabot> a
07:32:27 <orbifx> hmm, let's see I need to somehow get my map to have (a, [b]) so that it can support multiple values under that same key
07:32:30 <Twey> aweinstock: That's a term, but not a value
07:32:48 <Twey> aweinstock: (in fact it's definitionally equal to let x = x in x)
07:33:00 <orbifx> Twey: is that the same as (a, [b])? Set isn't a List right?
07:33:09 <orbifx> Set is made of unique elements I pressume?
07:34:11 <Twey> orbifx: A list has an ordering, which is a bit more
07:34:19 <aweinstock> :t Data.Map.insertWith (<>)
07:34:21 <lambdabot> (Ord k, Monoid a) => k -> a -> M.Map k a -> M.Map k a
07:34:40 <catgocat> please help find a headless browser library for haskell?
07:34:56 <orbifx> aweinstock: are you answering in my topic?
07:35:01 <Twey> orbifx: A set is a collection of values, a multiset is a collection of potentially-duplicate values (or equivalently values with counts), and a list is a collection of potentially-duplicate values *in some order*
07:35:07 <dramforever> catgocat: consider posting on reddit
07:35:11 <dramforever> it lasts longer
07:35:18 <catgocat> I don't use reddit
07:35:28 <dramforever> it's up to you
07:35:49 <orbifx> Twey: would I have to write my own functor to go with `unionWith`?
07:36:05 <Twey> orbifx: If you don't care about the order, you don't want a list (you can do it with a sorted list, but it's easier just to use a set or multiset)
07:36:13 <Twey> :t unionWith
07:36:14 <lambdabot>     Not in scope: ‚ÄòunionWith‚Äô
07:36:14 <lambdabot>     Perhaps you meant one of these:
07:36:14 <lambdabot>       ‚ÄòIM.unionWith‚Äô (imported from Data.IntMap),
07:36:18 <Twey> Tsk
07:36:23 <Twey> :t Data.Map.unionWith
07:36:24 <lambdabot> Ord k => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
07:36:27 <Twey> orbifx: No functors here
07:37:03 <orbifx> sorry function
07:37:11 <orbifx> for the (a -> a -> a)
07:37:21 <Twey> orbifx: No, you can just use the merging operation of‚Ä¶ whatever you're using
07:37:21 <aweinstock> orbifx: yes (suggesting using (Map k [v]))
07:37:41 <orbifx> o0 yes, no 
07:38:00 <Twey> Well, ‚Äòwrite your own‚Äô is not a well-defined concept :√æ
07:38:23 <Twey> If you consider ‚ÄòunionWith (+)‚Äô to be ‚Äòyour own function‚Äô then sure.  :√æ
07:38:52 <orbifx> i have map1 and map2 and I want to unite them with duplicate value for the same key preserved 
07:39:21 <orbifx> and now that I'm thinking about this, I need to go all the way back and work on fromList, because even at that stage there are duplicate keys.
07:41:33 <aweinstock> :t Data.Map.fromListWithKey -- should be flexible enough
07:41:34 <lambdabot> Ord k => (k -> a -> a -> a) -> [(k, a)] -> M.Map k a
07:44:01 <orbifx> thanks aweinstock and Twey 
07:46:52 <athan> Why isn't there a `mapMaybe` analogue for Data.Set? I feel like it would be pretty easy to make
07:47:01 <catgocat> I am stuck in the webdriver package. How do I run a IO action like putStrLn inside a WD ?? example: runSession myConfig $ openPage "http://google.com" >> putStrLn "hello" doesnt work
07:47:21 <catgocat> it says it is a state monad transformer over IO, but I can't really do IO actions within it
07:47:21 <dramforever> catgocat: hint: always read the instances list
07:47:34 <dramforever> even if it's very easy to overlook
07:47:43 <catgocat> I don't really know what you mean
07:47:57 <catgocat> I see that there are Monad, Functor, Applicative instances of WD
07:48:01 <catgocat> but that really doesnt tell me anything
07:48:06 <quchen2> MonadTrans?
07:48:08 <mauke3> is there MonadIO?
07:48:11 <quchen2> MonadIO?
07:48:13 <catgocat> yes
07:48:14 <catgocat> MonadIO
07:48:19 <mauke3> liftIO, then
07:48:26 <dramforever> :t liftIO -- ok obviously you don't really know this
07:48:27 <lambdabot> MonadIO m => IO a -> m a
07:48:38 <catgocat> lol
07:48:40 <mauke3> liftIO embeds arbitrary IO actions in a wrapper monad
07:48:48 <catgocat> I thought you couldn't transform any IO a into other thing
07:48:59 <athan> Basically, anything that's a MonadIO can handle IO actions, because it eventually can turn into IO
07:49:02 <dramforever> :t Just (print 3)
07:49:03 <lambdabot> Maybe (IO ())
07:49:08 <athan> `it` being `m`
07:49:16 <catgocat> where do I import liftIO?
07:49:24 <athan> Control.Monad.IO.Class
07:50:09 <Profpatsch> catgocat: Use Hoogle https://www.haskell.org/hoogle/?hoogle=liftIO :)
07:50:24 <ely-se> when one says "the T monad", is one speaking of T in "instance Monad T", or of the instance itself?
07:50:38 <mauke3> depends on who's speaking
07:50:45 <ely-se> :c
07:50:46 <Taneb> ely-se, the former when the latter is relevant
07:50:49 <mauke3> (I don't like "the T monad")
07:50:52 <arianvp> yo ely-se 
07:50:57 <ely-se> hai arian
07:51:12 <catgocat> I get an error that WD isnt instance of MonadIO
07:51:17 <Twey> orbifx: http://lpaste.net/139685
07:51:19 <catgocat> but in the documentation it says so
07:51:21 <ely-se> mauke3: me neither
07:51:26 <Profpatsch> There was a essay somewhere why saying ‚Äúthe T monad‚Äù doesn‚Äôt make sense.
07:51:29 <mauke3> catgocat: missing import, possibly
07:51:48 <dramforever> mauke3: a monad is an instance, and we sometimes use the type to refer to the instance
07:51:54 <catgocat> I am importing control.monad.io.class ..
07:52:02 <ely-se> e.g. hello world doesn't need monadic operations, but some people still say it uses the I/O monad.
07:52:05 <athan> ely-se: When I say "the T monad..." we're usually speaking of some data type T that happens to be an instance of Monad
07:52:18 <mauke3> catgocat: doesn't matter; Control.Monad.IO.Class obviously doesn't know about WD
07:52:18 <ely-se> athan: I see, thanks.
07:52:45 <quchen2> ely-se: "1+1 requires the Integer Ord" is just as strange.
07:52:48 <mauke3> catgocat: what are your other imports?
07:52:57 <arianvp> ely-se: I think that's especially valid because if there are 'multiple instances' we usually wrap the data type in a newtype wrapper for every instance
07:52:58 <catgocat> test.webdriver and test.webdriver.monad
07:53:00 <arianvp> so it still holds
07:53:08 <catgocat> thats it
07:53:42 <Twey> quchen2: ‚ÄòRequires the Integer Num‚Äô seems reasonable on thought, though.
07:53:54 <mauke3> catgocat: what's the exact error message?
07:54:11 <catgocat> I am on irssi, don't really know how to paste stuff here
07:54:11 <hacker> Twey: main = putStrLn "hello world" -- what's monadic about this?
07:54:25 <catgocat> let me go to the webclient
07:54:26 * hackagebot snmp 0.2.1.1 - API for write snmp client.  https://hackage.haskell.org/package/snmp-0.2.1.1 (chemist)
07:54:26 <Twey> hacker: Er, nothing.
07:54:33 <quchen2> Twey: Yes, but then you're talking about the (+) and not the 1. When saying "print requires the IO Monad" you're not usually talking about >>=.
07:54:37 <mauke3> catgocat: don't paste it in the channel; use something like lpaste.net
07:54:42 <catgocat> ok
07:54:42 <Twey> quchen2: *nod*
07:54:59 <Twey> quchen2: Well, the 1 too, technically :√æ
07:55:26 <hacker> Twey: it's normally overused where the type you're working with is a monad, even if you're using the functor/applicative interface or nothing at all
07:55:30 <quchen2> "(1::Int)+(1::Int) requires the Integer Ord" is just as strange.
07:55:32 <hacker> Twey: that's the "only" issue
07:55:33 <quchen2> Twey: ^
07:55:49 <orbifx> Twey: heh, looking for challenges?
07:55:51 <Twey> quchen2: Because it's false: now you're using Int
07:55:54 <quchen2> And if you're already typing about Int vs. Integer I'm going to 
07:55:57 <quchen2> ....
07:55:57 * Twey will shut up now
07:56:11 <Twey> Yes, I get the point.  ‚ò∫
07:56:14 <aweinstock> quchen2: how does that require the Integer Ord? it requires the Int Num (unless I'm misunderstanding)
07:56:28 <catgocat> http://lpaste.net/139687
07:56:29 <Twey> Haha.
07:56:30 <catgocat> there
07:56:30 <ely-se> quchen2: I think you mean the Int Ord
07:56:37 <quchen2> aweinstock: It requires it the same way as "print 1" requires the IO Monad: it doesn't.
07:57:19 <aweinstock> "print 1 >> print 2" can meaningfully be said to require "the IO Monad" then?
07:57:38 <aweinstock> or rather, "the IO Applicative"?
07:57:42 <ely-se> monad
07:57:45 <ely-se> (>>) is in Monad
07:57:46 <quchen2> >> requires the IO Monad. print does not.
07:57:46 <aweinstock> (since (>>) = (*>))?
07:57:53 <catgocat> Did you see my lpaste?
07:57:58 <catgocat> It tells the error I'm getting
07:58:00 <Twey> aweinstock: (>>) may not = (*>)
07:58:01 <quchen2> print requires IO.
07:58:08 <Intolerable> :t (>>)
07:58:09 <lambdabot> Monad m => m a -> m b -> m b
07:58:09 <Twey> Annoyingly
07:58:10 <aweinstock> :t [(>>), (*>)]
07:58:11 <lambdabot> Monad m => [m a -> m b -> m b]
07:58:18 <Twey> The types match, but the behaviours might not
07:58:22 <quchen2> Twey: Legally?
07:58:26 <Twey> I think so
07:58:27 <fractalsea> Is there a version of fromIntegral that is safe? i.e. returns a Maybe value and Nothings when coercing a value that is out of the range of the type that is being coerced to
07:58:31 <Profpatsch> quchen2: Nope.
07:58:46 <aweinstock> > fromIntegral 257 :: Word8
07:58:48 <lambdabot>  1
07:58:53 <Profpatsch> Doesn‚Äôt it break the laws if the two behave differently?
07:58:58 <Twey> I remember being convinced that they could be different, but I don't remember how
07:59:13 <Profpatsch> The applicative can have a more efficient implementation.
07:59:24 <hacker> it may be parallel-ish 
07:59:26 <Profpatsch> e.g. in parallel.
07:59:42 <hacker> where >>= can't
07:59:50 <Profpatsch> Because in a <*> b b doesn‚Äôt depend on a.
07:59:52 <catgocat> Can anyone help me with webdriver?
07:59:57 <quchen2> >> can be just as parallel.
07:59:59 <jameseb> Twey: I think the behaviours match (in terms of the laws) but (>>) cant be used for something that implements Applicative but not Monad
08:00:22 <hacker> quchen2: indeed, but there could be two potentially valid instances there
08:00:26 <Twey> Oh, no, never mind, I'm confused
08:00:50 <Twey> It's just that (<*) is not flip (*>)
08:00:57 <umib0zu> Hey all. How do lists work in Haskell in both ghci and in compiled code? I‚Äôm assuming they‚Äôre lazy by default, but for ghci it by default ‚Äúshows‚Äù a list. Also, what‚Äôs the difference between a list and an iterable list? In some languages these are different but in Haskell we seem to have the iterate function, so is that list actually different?
08:00:58 <Twey> Completely different issue
08:01:00 <hacker> we normally assume X >> Y = Z = X *> Y 
08:01:25 <quchen2> Twey: And <**> isn't flip <*>.
08:01:30 <Twey> Yeah.
08:02:09 <quchen2> umib0zu: Lists are always lazy. GHCi just prints them because it prints the value of any expression you're entering.
08:02:33 <quchen2> umib0zu: "iterate" in Haskell does not iterate over a list, it iteratively generates a list by repeatedly applying a function to an initial seed.
08:02:37 <Twey> umib0zu: Lists are lazy always.  If you show the list it will force the list.  ‚Äòiterate‚Äô iterates a *function* to produce a list; it's not related to iterating the list (which is done with map/foldl/foldr).  Lists are always iterable.
08:02:44 <aweinstock> :t \a b -> unwrapMonad $ WrapMonad a *> WrapMonad b
08:02:45 <lambdabot> Monad m => m a1 -> m a -> m a
08:02:55 <quchen2> > iterate (*2) 1 --- umib0zu 
08:02:56 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
08:02:59 <Twey> s/show the list/print the list/
08:03:02 <hacker> aweinstock: that's not needed anymore
08:03:10 <quchen2> > iterate f x
08:03:12 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
08:03:25 <Twey> :t WrapMonad
08:03:26 <lambdabot> m a -> WrappedMonad m a
08:03:31 <aweinstock> quchen2: what show instance is lambdabot using for that?
08:03:33 <Twey> What is this magic?
08:03:42 <Twey> :t f
08:03:43 <lambdabot> FromExpr a => a
08:03:44 <aweinstock> WrapMonad is an applicative
08:03:54 <Twey> aweinstock: Expr
08:03:57 <aweinstock> :t [q, w, e, r, t, y]
08:03:59 <lambdabot> [Expr]
08:04:00 <quchen2> aweinstock Twey simple-reflect is the package
08:04:02 <Twey> aweinstock: Ahh, I see.
08:04:04 <Twey> Yep
08:04:11 <quchen2> > foldr f z [a,b,c]
08:04:12 <lambdabot>  f a (f b (f c z))
08:04:16 <hacker> Twey: WrappedMonad is basically Monad m => Applicative (WrappedMonad m) 
08:04:22 <Twey> Right, got it.
08:04:26 * hackagebot uniform-pair 0.1.6 - Uniform pairs with class instances  https://hackage.haskell.org/package/uniform-pair-0.1.6 (ConalElliott)
08:05:18 <orbifx> Twey: brb
08:06:50 <umib0zu> I see. I‚Äôm actually trying to make a prime generator that‚Äôs sightly efficient. My current implementation is pretty lame.
08:11:29 <Profpatsch> So while doing a quick nap a few minutes ago a common problem entered my mind and I am not sure how to represent it as a type.
08:11:44 <Profpatsch> You have inputs into a system, e.g. a game.
08:11:59 <Profpatsch> For example you are in a menu.
08:12:09 <dfeuer> I‚Äôm trying to start working on the llvm-general tutorial at http://www.stephendiehl.com/llvm/ but I‚Äôm having trouble because the LLVM on my system (OSX) is too new. How, if at all, can I get this working? Is there some sane way to set up an older LLVM?
08:12:28 <Profpatsch> You can go up, down, hit enter, or enter the first char of the Konami Code.
08:12:58 <Profpatsch> Each of the first changes the state of the system, the last needs more input to know what should be done.
08:13:15 <Profpatsch> The question is: How do I represent this as a type?
08:13:26 <Profpatsch> My first try is:
08:14:00 <Profpatsch> data Input ret = Char -> Either (Input ret | ret)
08:14:06 <Taneb> Profpatsch, entering the first char of the Konami code does change the system in an invisible way, it changes it to "you can go up, down, hit enter, or enter the *second* char of the Konami Code"
08:14:27 <Denommus> Profpatsch: have you ever heard about FRP?
08:14:54 <Intolerable> https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString.html#t:IResult ?
08:14:56 <Intolerable> similar to this?
08:15:14 <Profpatsch> Taneb: Yeah, but apart from that it‚Äôs basically the general problem of ‚Äûmore than one possible input, where some inputs need more input‚Äú
08:15:36 <Profpatsch> Another example would be Prefix Commands in Vim/Emacs.
08:15:45 <Profpatsch> Or object motions in vim
08:16:25 <Profpatsch> e.g. 'c' -> need more input -> 'c' or 'c' -> need more -> 'i' -> need more -> 'w'
08:16:56 <Profpatsch> That‚Äôs a pattern that happens a lot and I wonder how to abstract it.
08:17:49 <Profpatsch> Denommus: Of course, but even then I only build a state machine, this pattern seems to be orthogonal to FRP.
08:19:09 <Profpatsch> As I said, my first thought would be: ‚ÄúAn Input is a Function from an InputValue to Either a return datatype ret or another Input‚Äù.
08:19:29 <Intolerable> so https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString.html#t:IResult
08:19:35 <Intolerable> without the error bit
08:20:03 <Profpatsch> Intolerable: ah! You are right. It is similar to a partial parse.
08:20:09 <geekosaur> one thing you can do is that the state produced includes a new input specification. most things just produce the same one they are passed, things that require submaps produce the submap (or the original top level map if nothing matches)
08:20:14 <Denommus> Profpatsch: for instance, in reactive-banana, you could use accumE to accumulate a list of events into a new event, and then filter a certain order of events that match your konami code
08:20:36 <geekosaur> (or variant thereof: Nothing or Just the new map)
08:20:42 <Denommus> Profpatsch: *to accumulate sequential events into a event of list
08:21:27 <Profpatsch> Denommus: That looks like it doesn‚Äôt scale very well.
08:22:01 <Profpatsch> A linear filter over a few thousand or million different combinations?
08:22:08 <Profpatsch> Take Emacs for example.
08:22:27 <Profpatsch> There‚Äôs more than a few thousand possible commands. :)
08:23:15 <orbifx> Twey: back
08:23:32 <orbifx> Twey: how long have you been working with Haskell?
08:23:42 <Profpatsch> So it would be more of a
08:23:50 <Twey> orbifx: Um, I don't know.  Some years?
08:24:27 * hackagebot streaming 0.1.0.8 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.8 (MichaelThompson)
08:25:04 <Profpatsch> data Input i r = Partial (i -> Input i r) | Done i r
08:25:29 <Profpatsch> Or rather
08:25:35 <Profpatsch> data Input i r = Partial (i -> Input i r) | Done r
08:26:24 <Profpatsch> It would be interesting to do a type search over this
08:27:03 <Profpatsch> Is this some well-known pattern?
08:27:39 <umib0zu> What is a nice way to say <*> in English? Applicative apply?
08:27:59 <umib0zu> Applicative Map?
08:28:04 <umib0zu> Amap?
08:28:05 <lush> I'd just say apply I guess
08:28:11 <Taneb> I say it "Ap"
08:28:15 <Denommus> Profpatsch: say, every button you press "emit" a character (that is, you have an Event t Char). You want to know whether the user pressed the sequence jkjk. You make jkjkEvent = filterE (=="jkjk") $ accumE "" $ fmap (\c str -> str++[c]) buttonPress
08:28:45 <Denommus> Profpatsch: amazingly, that is not as inefficient as it seems, because reactive-banana does some magic XD
08:29:16 <Profpatsch> Denommus: Maybe it does exactly thata.
08:29:18 <Profpatsch> *that
08:29:27 * hackagebot streaming-bytestring 0.1.0.0 - Effectful sequences of bytes.  https://hackage.haskell.org/package/streaming-bytestring-0.1.0.0 (MichaelThompson)
08:30:30 <Denommus> Profpatsch: though my code is wrong
08:30:34 <Denommus> haha
08:33:36 <Profpatsch> Is there a way to search for ADTs that have the same / a similar signature?
08:38:14 <Denommus> filterE (\l -> (take 4 l)==(reverse "jkjk")) $ accumE "" $ fmap (:) buttonPress
08:38:19 <Denommus> Profpatsch: ^
08:38:44 <Denommus> Profpatsch: due to lazyness and the "take 4", the runtime will throw away older events
08:39:26 <stianhj> I have a function f that takes a foo and a bar and returns a bar, and list of foos. How can I call the function f for each of the elements in foo on a bar and end up with a bar?
08:40:08 <tommd> f :: foo -> bar -> bar ; list :: [foo]?
08:40:16 <mauke3> map (\a foo -> f a foo a bar) list of foos
08:40:26 <Denommus> Profpatsch: or even better: filterE (==(reverse "jkjk")) $ fmap (take 4) $ accumE "" $ fmap (:) buttonPress
08:40:32 <stianhj> no, f :: [foo] -> bar -> bar
08:40:52 <mauke3> ?
08:41:02 <tommd> so `f listOfFoos bar` is just function application... what are you wanting?
08:41:17 <srhb> stianhj: That takes a list of foo and a bar and returns a bar. Not what you just said.
08:41:47 <codedmart> What is the best way to go with an error like this http://lpaste.net/139690
08:41:48 <serendependy> stianhj, You have f :: foo -> bar -> bar
08:42:11 <serendependy> and you want f' :: [foo] -> bar -> bar
08:42:12 <serendependy> ?
08:42:15 <stianhj> Sorry, let me get the foos and the bars straight. I have a function a :: Int -> Thing -> Thing, now I want to create a function b :: [Int] -> Thing -> Thing.
08:42:28 <serendependy> stianhj, thought so
08:42:41 <mauke3> b ns t = map (\n -> a n t) ns
08:42:45 <athan> Is there an easy way to guard a boolean statement, monadically? Something like `do (returnWhen someBoolTest foo)`?
08:42:48 <mauke3> hmm, no
08:42:52 <mauke3> that returns [Thing]
08:43:00 <serendependy> stianhj, I think you want a fold
08:43:03 <serendependy> :t foldl
08:43:04 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
08:43:04 <aweinstock> :t foldr (undefined :: Int -> Void -> Void)
08:43:05 <lambdabot> Not in scope: type constructor or class ‚ÄòVoid‚Äô
08:43:05 <lambdabot> Not in scope: type constructor or class ‚ÄòVoid‚Äô
08:43:09 <athan> or really, in the context of Maybe - when the bool is False, just return Nothing
08:43:10 <serendependy> @type foldl
08:43:12 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
08:43:14 <Intolerable> athan: what's the type of that?
08:43:23 <aweinstock> :t foldr (undefined :: Int -> a -> a)
08:43:24 <lambdabot> Foldable t => b -> t Int -> b
08:43:36 <aweinstock> :t flip (foldr (undefined :: Int -> a -> a))
08:43:36 <athan> Intolerable: Something like `returnWhen :: Bool -> a -> m a`
08:43:37 <lambdabot> Foldable t => t Int -> c -> c
08:44:01 <Ankhers> foo b = if b then return "Something" else Nothing -- athan?
08:44:07 <athan> Intolerable: Actually, `returnWhen :: Bool -> a -> Maybe a`, because you need the False case
08:44:08 <Profpatsch> Denommus: FRP does indeed make it a lot more compositable.
08:44:14 <Profpatsch> If that‚Äôs even a word
08:44:17 <athan> Ankhers: I don't like if statements :(
08:44:24 <Intolerable> composable
08:44:29 <Ankhers> athan: Use a guard or case.
08:44:31 <stianhj> serendependy: thanks. let me give it a whirl
08:44:44 <athan> Ankhers: :| but howwwww
08:44:48 <Profpatsch> The data type is only the first part, how to tell the system what your combinations are is the next.
08:44:55 <serendependy> stianhj, Don't get to confused about the "Foldable t" part, just assume it's a [t] for now
08:45:01 <Profpatsch> And I‚Äôm not too sure the input type above can do that.
08:45:17 <Intolerable> :t \x a -> case x of {True -> return (Just a); False -> return Nothing }
08:45:18 <lambdabot> Monad m => Bool -> a -> m (Maybe a)
08:45:49 <Intolerable> or
08:45:57 <Ankhers> athan: http://lpaste.net/139691
08:46:00 <stianhj> serendependy: yeah, I didn't use to look like that did it?
08:46:04 <Ankhers> using a guard, specific to Maybe
08:46:25 <Intolerable> \x -> bool x (return . Just) (const (return Nothing))
08:46:27 <Intolerable> : t\x -> bool x (return . Just) (const (return Nothing))
08:46:30 <Intolerable> :t \x -> bool x (return . Just) (const (return Nothing))
08:46:31 <lambdabot>     Couldn't match expected type ‚ÄòBool‚Äô
08:46:31 <lambdabot>                 with actual type ‚Äòb0 -> m0 (Maybe a0)‚Äô
08:46:31 <lambdabot>     Probable cause: ‚Äòconst‚Äô is applied to too few arguments
08:46:40 <Intolerable> ugh
08:46:42 <Intolerable> who even knows
08:46:42 <slack1256> @type bool
08:46:43 <lambdabot> a -> a -> Bool -> a
08:46:54 <Intolerable> :t bool (return . Just) (const (return Nothing))
08:46:55 <lambdabot> Monad m => Bool -> a -> m (Maybe a)
08:46:58 <Intolerable> there we go
08:47:01 <Intolerable> (ty)
08:47:06 <Ankhers> athan: You could generalize it by using `pure a` instead of `Just a`, and `fail` instead of `Nothing`. But I think `fail` is considered bad style. I could be wrong though.
08:47:14 <slack1256> > bool True False True
08:47:15 <Intolerable> don't use fail, use mzero
08:47:16 <lambdabot>  False
08:47:31 <slack1256> > bool False True True
08:47:32 <lambdabot>  True
08:47:33 <Ankhers> Intolerable: That sounds better. Thanks!
08:47:34 <Intolerable> is it f t? thats unfortunate
08:47:37 <slack1256> > bool False True False
08:47:38 <lambdabot>  False
08:47:59 <Intolerable> :t bool (const mzero) (return . return)
08:48:01 <lambdabot> (Monad m1, MonadPlus m) => Bool -> a -> m (m1 a)
08:48:29 <slack1256> so `bool` is the characterises Bool in the same way foldr does with Lists?
08:48:40 <stianhj> serendependy: That went swimmingly. foldr a inputThing [list of ints]. I had a feeling there was something exactly for this. Been too long since I've played with haskell. Thank you
08:48:46 <Intolerable> yes
08:48:58 <Intolerable> well
08:48:59 <Intolerable> almost
08:49:02 <lpaste_> athan pasted ‚Äúreturn when True for Maybe?‚Äù at http://lpaste.net/139693
08:49:07 <athan> Ankhers: I think it is, too. MonadFail should clean it up, though
08:49:09 <athan> it's just lawless and stringy :(
08:49:21 <athan> Anyway, here's what I was thinking ^
08:49:33 <athan> Intolerable: Hmm, okay!
08:49:35 <serendependy> stianhj, np. In the future, you should use Hoogle, it's amazing for finding functions using a type signature
08:49:44 <serendependy> It's my best friend!
08:50:14 <athan> :t bool (const mzero) (const . return)
08:50:15 <lambdabot> (Monad m, MonadPlus ((->) b)) => Bool -> a -> b -> m a
08:50:22 <athan> er
08:50:22 <athan> something
08:50:28 <athan> thanks :)
08:51:21 <athan> :t \x -> bool mzero (pure x)
08:51:23 <lambdabot> MonadPlus m => a -> Bool -> m a
08:51:27 <athan> :)
08:51:34 <stianhj> serendependy: Yeah, I got my search wrong when I tried it first time. Now that I put in [a] -> b -> b, foldr shows up as the first results :)
08:51:59 <athan> Thanks Intolerable & Ankhers!
08:52:03 <Intolerable> bool : Bool :: (list :: (a -> b) -> b -> [a] -> b) :: List
08:52:09 <Intolerable> so not quite foldr
08:59:29 * hackagebot moesocks 0.1.0.26 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.26 (JinjingWang)
09:01:54 <sm> hey all.. is it possible to put haddock comments on each of a data type constructor's arguments ?
09:02:29 <sm> it complains when I put them one per line and add -- ^ 
09:03:47 <geekosaur> my recollection is that is known not to be possible
09:04:03 <geekosaur> (would have to dig for references but pretty sure it's been discussed in -cafe)
09:04:23 <sm> bummer, thanks
09:06:19 <slack1256> sm: also, if you will use those comment to tell the user to not put certain things on those field, you are better off with smart constructors
09:09:11 <sm> thanks.. I just want to explain their meaning
09:10:57 <jewel> Why does ghc warn me about a type hole when I use an accessor function named with a leading underscore?
09:11:08 <bennofs> > _example
09:11:09 <lambdabot>      Found hole ‚Äò_example‚Äô with type: t
09:11:09 <lambdabot>      Where: ‚Äòt‚Äô is a rigid type variable bound by
09:11:09 <lambdabot>                 the inferred type of it :: t at <interactive>:1:1
09:11:16 <bennofs> jewel: ^^^^ like that?
09:11:23 <jewel> yes
09:11:34 <bennofs> jewel: that means that the identifier is not defined
09:11:35 <Intolerable> because stuff w/ _ at the start is not intended to actually be used
09:11:46 <Intolerable> (it should work fine though)
09:12:06 <bennofs> jewel: typed holes are "place holders" for parts in an expression that you haven't wrote yet (like undefined, but it also gives you the type that is expected at that place)
09:12:09 <geekosaur> did you import it? the inferred type thing implies it's not known
09:12:16 <bennofs> > let _foo = 3; in _foo  -- works just fine
09:12:18 <lambdabot>  3
09:12:40 <geekosaur> (it should know more than the inferred type of "it" for a name that's in scope)
09:13:37 <geekosaur> (and the typed hole machinery should only trigger on _ or a name that is not otherwise in scope)
09:14:26 <edwardk> quchen: Foldable
09:14:43 <edwardk> quchen: without carrying the Ord the heap can't be Foldable
09:15:22 <edwardk> with it, Foldable.toList can return things in heap order
09:15:40 <edwardk> in practice? i probably should split into a Heap k v and just require Ord on k
09:15:55 <edwardk> but it was a very early library for me
09:16:08 <edwardk> and i hadn't solidified my design sensibilities by then
09:19:45 <kuznero> Hi All!
09:19:49 <kuznero> I am wondering if it is possible to install hlint with using stack tool? As if I was using cabal install hlint?
09:20:06 <Ankhers> kuznero: stack install hlint?
09:20:40 <kuznero> Ankhers: is it possible to pass through some additional parameters like with cabal? For example --enable-relocatables (Windows)?
09:21:50 <Ankhers> kuznero: stack install --help
09:22:09 <kuznero> Ankhers: yep :) thanks for the tip about stack install!
09:22:56 <GLM> How can I go within a data wrapper and then wrap it in another type?
09:23:02 <Ankhers> kuznero: #haskell-stack may also be useful.
09:23:12 <kuznero> thanks!
09:24:22 <athan> http://athanclark.github.io/posts/2015-08-26-returnWhen-for-MonadPlus.html
09:24:31 * athan places target on forehead
09:26:31 * mauke3 boops athan
09:26:46 <athan> mauke3: D:
09:26:57 <fosterite> athan: seems reasonable, reasonably idiomatic translation
09:27:18 <athan> fosterite: Thank you, I'm very surprised this doesn't already exist
09:27:32 <fosterite> athan: that was my exact response
09:28:36 <Welkin> hello athan 
09:29:11 <athan> Hi Welkin!
09:29:16 <mauke3> ashin, achos, athan
09:31:49 <wkmanire> mauke3: nathin nashin nachos
09:31:59 <wkmanire> oops. nathan* crap, ruined it.
09:33:57 <the_2nd> can someone point me to a ressources showing the minimal setup for a cabal project/package/lib?
09:34:09 <the_2nd> folder structure, cabal file, setup, testing
09:34:15 <GLM> the_2nd: http://howistart.org/posts/haskell/1
09:34:30 * hackagebot leksah-server 0.15.0.9 - Metadata collection for leksah  https://hackage.haskell.org/package/leksah-server-0.15.0.9 (HamishMackenzie)
09:35:43 <ReinH> the_2nd: you could use stack and have it generate it for you
09:36:23 <the_2nd> GLM, ReinH what if I already have the .hs files?
09:36:41 <ReinH> the_2nd: stack init or cabal init in the directory
09:37:01 <ReinH> note that latest stack's project generation seems much smarter, not sure if that's released or on HEAD
09:37:34 <xandaros> How would I go about reading a binary format? I am looking at the 'binary' package, but I don't see any way to read, for example, 2-bit values from a bytestring
09:37:39 <ReinH> the_2nd: the naming convention for source files is ./src/Foo.hs contains Foo and ./src/Foo/Bar.hs contains Foo.Bar
09:37:54 <ReinH> xandaros: You use Get
09:38:46 <ReinH> xandaros: here's an example using bytes, but it's very similar with binary http://lpaste.net/8497494672313155584
09:38:48 <the_2nd> synopsis = small description? (no native english speaker)
09:38:59 <ReinH> the_2nd: yes
09:40:24 <xandaros> ReinH: Well, I know I am going to need Get and I can probably use it to read bytes without issue. I'm looking at a heavily packed format, though, where some values are only a few bits long and not byte-aligned
09:40:34 <ReinH> xandaros: oh, *bits*.
09:40:38 <ReinH> I misread.
09:40:53 <the_2nd> no wonder there are no tutorials for this which I could find
09:40:58 <the_2nd> cabal init and thats it
09:40:59 <the_2nd> thx
09:41:18 <ReinH> the_2nd: yeah :/
09:42:50 <ReinH> xandaros: yeah, binary et al work on bytes... you say not byte-aligned. Does that mean you're reading, e.g., 5 5 5 1 or so?
09:43:53 <ReinH> xandaros: at one point I wrote some template haskell to do this, so you could say readBits, e.g., "aaaaabbbbbcccccd" and automatically define a, b, and c via the appropriate bit shifting.
09:44:03 <ReinH> I'm not sure if I have that on this computer
09:44:28 <ReinH> I used it for an 8080 emulator iirc
09:44:36 <xandaros> hmm, that's an interesting idea, but then you get variable-sized values and stuff
09:44:51 <ReinH> xandaros: yeah :/
09:45:10 <the_2nd> ReinH, how to use leksah now, so auto complete etc. works?
09:45:15 <ReinH> well, you could define some combinators
09:45:19 <ReinH> the_2nd: I don't use leksah
09:45:21 <the_2nd> seems like it simply opens files as editor for me
09:45:26 <the_2nd> ReinH, any IDE?
09:45:32 <the_2nd> or does anyone else use leksah?
09:45:39 <ReinH> the_2nd: I use emacs. Some people might use leksah.
09:46:03 <ReinH> xandaros: Hmm... you could read a Word32 as [Bool] and then operate on slices... that might work.
09:46:14 <hamishmack> the_2nd: How did you install Leksah?
09:46:22 <ReinH> you'd spend a fair amount of time building up some combinators to make that ergonomic
09:46:31 <the_2nd> hamishmack, via cabal
09:46:33 <xandaros> cereal, binary and bytes have a striking similarity
09:46:47 <ReinH> xandaros: bytes was designed to bridge cereal and binary functionality
09:47:01 <ReinH> at one point, cereal had some featuers that binary lacked. At this point, I think most people use binary.
09:47:12 <geekosaur> ...which is mildly weird since cereal started out as lazy binary
09:47:16 <the_2nd> ReinH, how would I use this lib from another project now?
09:47:26 <hamishmack> When you first run it it create or download metadata for the packages you have installed
09:47:38 <glguy> xandaros: cereal existed because binary used to be missing a bunch of features, but binary has incorporated them at this point
09:47:51 <glguy> Ah, which ReinH said already
09:47:59 <ReinH> the_2nd: stack is designed to make this easier. With cabal, you can add its root directory as a source. I don't know where this is described though :/
09:48:01 <hamishmack> If this fails the Modules pane will remain empty and autocomplete will not work
09:48:08 <ReinH> glguy: :D
09:48:21 <sm> silly haddock, stop choking on my commented out pattern guards
09:48:34 <hamishmack> it will retry automatically, but it may take a while to finish
09:49:01 <hamishmack> you can check it is making progress by looking in ~/.leksah-0.15/metadata
09:49:04 <ReinH> xandaros: however, cereal has a more clever name, so you may consider using it for that reason.
09:49:10 <xandaros> lol
09:49:40 <glguy> geekosaur: cereal started out as a binary that worked on strict bytestrings. What do you mean that it started as a lazy binary?
09:49:52 <xandaros> only both solve problems other than mine
09:49:53 <geekosaur> maybe I'm recalling backwards then
09:50:01 <geekosaur> I thought binary was strict bytestrings originally
09:50:12 <glguy> binary used to be lazier than it is now
09:50:47 <hamishmack> the_2nd: Also check ~/.leksah-0.15/collectSystem.report
09:50:55 <glguy> now it's less lazy and is built on top of an incremental interface to strict bytestrings which can be driven by a lazy bytestring
09:51:04 <ReinH> xandaros: I still use bytes out of habit and because I like the Serial typeclass
09:53:09 <xandaros> binary-strict has a 'BitGet' module!
09:53:28 <the_2nd> ReinH, when doing cabal build, it says it cant find my file
09:53:37 <the_2nd> source dirs : MYNAME
09:53:43 <the_2nd> all files in MYNAME/
09:53:52 <the_2nd> with MYNAME.SUBNAME as module
09:54:31 * hackagebot debian 3.88.1 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-3.88.1 (DavidFox)
09:55:45 <xandaros> Guess it is decided, then. binary-strict, it is. (Makes me wonder why binary doesn't have it o_O)
09:57:35 <xandaros> ...which fails to compile *sigh*
09:59:29 <ReinH> the_2nd: what is MYNAME?
09:59:35 <bergmark> xandaros: 7.10 not supported it seems http://matrix.hackage.haskell.org/package/binary-strict
09:59:48 <ReinH> the_2nd: MYNAME should be, e.g., src, and does not appear in the module name.
10:00:00 <ReinH> the_2nd: so ./src/Foo.hs contains the Foo module
10:03:32 <Denommus> Profpatsch: composable XD
10:08:40 <Denommus> anyone here installed nix in Arch Linux?
10:09:16 <Denommus> I installed it from AUR, started the daemon, but still can't execute any command because of permission issues
10:09:21 <Denommus> I wonder what I'm missing
10:09:22 <slack1256> Denommus: probably you should ask in #nixos
10:09:39 <slack1256> (I did, I ended up installing nixos)
10:09:49 <Denommus> slack1256: they probably won't have specific instructions for Arch Linux, though
10:09:57 <slack1256> neither haskell
10:09:57 <Denommus> slack1256: is NixOS worth it?
10:10:12 <slack1256> but you have a better shot with them
10:12:13 <the_2nd> ReinH, all working now
10:12:21 <the_2nd> how can I use it in another project?
10:12:33 <the_2nd> just include NAME.module after building?
10:19:35 <ReinH> xandaros: you should port GetBits to bytes :D
10:20:27 <xandaros> ReinH: already thinking about it :P
10:21:10 <ReinH> xandaros: my TH would also support things like "aa1bbbb", which would guard on 0b0010000 .&. byte == 0b0010000. I should find it.
10:21:36 <ReinH> er, that but with the right number of bits in a byte
10:30:37 <ReinH> actually the guard was the one that actually worked, but you get the idea
10:33:54 <jle`> when did data families become a thing
10:35:24 <xenog> Anybody using Haskell on Raspberry Pi?
10:40:03 <codedmart> I would like to be able to use Raw with Enter. I have 'Mine' in files with my changes and 'Now' with what it is currently. https://gist.github.com/codedmart/3d0277cd6947e5d72dab#file-error
10:40:09 <codedmart> This is just what I tried right now.
10:40:19 <codedmart> Not sure how to go about getting Raw to work with Enter.
10:43:30 <fjordrunner> Couldn't match type ‚ÄòData.ByteString.Internal.ByteString‚Äô
10:43:30 <fjordrunner>                    with ‚Äò[Char]‚Äô
10:43:35 <fjordrunner> please, I have a ByteString which I would like to parse into my datastructure with 'read' function. Problem is that I'm getting: 
10:43:40 <fjordrunner> above
10:43:57 <fjordrunner> please, any ideas that why?
10:44:53 <SrPx> Hey guys, I have some kind of flattened tree structure using an unboxed vector. To access an element, a binary, O(logN) search is made. There is a caveat, though - when you access consecutive elements (say, indexes 3, 4, 5, 6) the logN search could not be necessary as it is likely that those are in the same bucket...
10:44:58 <SrPx> That doesn't matter, the point is
10:45:05 <bergmark> @type read
10:45:06 <lambdabot> Read a => String -> a
10:45:16 <SrPx> I could make the access function much faster if I could store in the structure the last accessed index.
10:45:23 <SrPx> But doing so is impossible due to purity
10:45:42 <SrPx> But since that is an optimization and doesn't affect the result of the accessor function at all
10:45:47 <SrPx> is it ok to use unsafePerformIO there?
10:46:11 <kqr> :t (<$)
10:46:12 <lambdabot> Functor f => a -> f b -> f a
10:46:12 <jle`> fjordrunner: `read` only works on String
10:46:25 <jle`> which is a linked list of Char
10:46:45 <jle`> ByteString is just a blob of bytes, so it's a bit ambiguous how you would turn a blob of bytes into a string to read
10:46:52 <fjordrunner> yes, but ByteString is also instance of Read,...should that not work (sorry,..just starting)
10:47:05 <kqr> :t \x f -> fmap (const (return x)) f
10:47:07 <lambdabot> (Monad m, Functor f) => a -> f b -> f (m a)
10:47:14 <kqr> whoops
10:47:23 <kqr> :t \x f -> fmap (const x) f
10:47:24 <lambdabot> Functor f => b -> f b1 -> f b
10:47:28 <kqr> neat
10:47:50 <jle`> fjordrunner: read :: String -> ByteString, in that case
10:47:57 <jle`> fjordrunner: read means you can turn a String into that type
10:48:07 <jle`> so it being an instance of read means that you can get a String and read it as a Bytestring
10:48:11 <fjordrunner> ohh,,...I see
10:48:50 <fjordrunner> so in my case I just have to parse it to String - if I want it to parse to data structure
10:49:08 <jle`> well, you need to decode it into a String
10:49:11 <jle`> but yeah
10:49:18 <jle`> if you can decode it into a String, you can parse it using `read`
10:49:35 <jle`> one way to go from ByteString to String is to use a decoding function from the text package -- http://hackage.haskell.org/package/text
10:49:50 <jle`> http://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text-Encoding.html
10:50:08 <fjordrunner> many thanks!!!!
10:50:10 <jle`> they have a bunch of decoders if you know what encoding the text is encoded as in the bytestring
10:50:33 <jle`> once you get the Text, you can use the `unpack :: Text -> String` function to get a String from it
10:50:48 <jle`> np!
10:51:06 <jle`> SrPx: i think that sort of semantically fits with the pure model, if the only thing is a performance optimization
10:51:18 <jle`> it preserves referential transparency because your function itself is always pure
10:51:32 <jle`> the result it returns is the same no matter where it is in the program, what the ordering is, etc.
10:52:17 <ChristianS> fjordrunner: if you can, consider generally using Text instead of String, it's much more efficient.
10:52:49 <SrPx> jle`: that's what I thought, but I'm not sure how unsafePerformIO works and if it could break in some cases (?)... also, I'm not sure how I could store the "last accessed index" of the structure. I could make a global hash table, but I'd need to somehow have an unique id of the structure 
10:53:13 <fjordrunner> thanks,..I just like that I can convert data from file straight to my datastructure
10:53:15 <jle`> fjordrunner: actually, you can `read` straight from Data.Text, http://hackage.haskell.org/package/text-0.11.2.3/docs/Data-Text-Read.html
10:53:23 <jle`> you don't need to go through String, my bad
10:53:29 <fjordrunner> great
10:53:30 <SrPx> or I could store it on the structure like: "data StructureWrapper a = Structure { lastIndex :: Int, structure :: Structure }"
10:53:34 <jle`> oh wait, that module doesn't use Read
10:53:38 <jle`> sorry, misread the module's intent ><
10:53:45 <SrPx> but how could I change the value of lastIndex impurely? that is kinda a long question though, I'll put it on SO
10:55:39 <ChristianS> SrPx: a { lastIndex : newval }  changes it purely. that's almost certainly the better approach.
10:56:38 <SrPx> ChristianS: but using that I'd have to return the new structure each time I read it. That would make the API terrible. Like, imagine if (!) on Data.Vector returned not only the read element, but a new vector, with the old one being invalid
10:56:59 <SrPx> An optimization that doesn't change the semantics shouldn't change the API
10:58:13 <ChristianS> SrPx: i didn't quite get what problem you're trying to solve
10:59:26 <SrPx> no problems !
10:59:33 * hackagebot lentil 0.1.4.0 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.4.0 (fffaaa)
11:00:05 <SrPx> It is just that for an optimization I need to internally break purity and I'm not sure how
11:04:07 <ouanixi> Hi guys, I'm new to Haskell and trying to get my head around the State monad by reading tutorials etc... The problem I'm facing at the moment is that the type "State s a" is not defined in Control.Monad.State
11:04:27 <beckyconning_> is there a nicer way to do `a == Array.nub a`?
11:04:31 <ouanixi> does anybody know which module has it been moved to ?
11:04:50 <beckyconning_> i mean `a == nub a`
11:07:09 <quchen> beckyconning_: You mean to check whether a list contains a duplicate?
11:07:16 <beckyconning_> quchen: yes
11:07:25 <quchen> You could reimplement nub to terminate once a single duplicate has been found
11:07:48 <quchen> a == nub a will perform bad for long lists
11:08:49 <quchen> duplicate = duplicate' Set.empty; duplicate' _ [] = False; duplicate cache (x:xs) | x `S.member` cache = True | otherwise = duplicate (Set.insert x cache) xs
11:08:54 <quchen> Something along those lines
11:11:13 <beckyconning_> thanks : )
11:11:50 <Axman6> ouanixi: it's probably defined using the StateT transformer over Identity: type State s a = StateT s Identity a; StateT is defined as: newtype StateT s m a = StateT (s -> m (a,s)). When you substitute Identity into that you can basically read that as State s a = State (s -> (a,s))
11:11:55 <phaazon> is there anyone here to help me understand how to use Proxy#?
11:12:15 <Axman6> phaazon: depends what your question is
11:13:19 <phaazon> Axman6: kind mismatch
11:13:37 <phaazon> I‚Äôd like to replace (Proxy :: Proxy Int) by (proxy# :: Proxy# Int)
11:13:40 <phaazon> but it fails
11:13:47 <phaazon> Proxy# * Int, maybe?
11:13:59 <Axman6> what's *?
11:14:08 <phaazon> a kind
11:14:20 <phaazon> the kind of inhabited types
11:14:30 <Axman6> oh, perhaps. do you have the link to the proxy# docs?
11:14:39 <phaazon> there‚Äôs none! :(
11:14:45 <hiptobecubic> I don't understand why nub performs so badly, it seems like it should be no worse than whatever the cost of set membership checking is
11:15:00 <Axman6> I'm sure there is, I'm pretty sure I've read them
11:15:04 <phaazon> Axman6: it‚Äôs defined in GHC.Exts
11:15:24 <Axman6> hiptobecubic: it has to be O(n^2) because there isn't an Orc constraint
11:15:31 <ouanixi> Axman6, thanks it makes sense.
11:15:37 <phaazon> https://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Exts.html
11:15:41 <phaazon> ctr-f Proxy
11:15:43 <phaazon> nothing found
11:15:50 <kadoban> Orc constraint XD
11:16:37 <hiptobecubic> Axman6, ah, right. Still it seems like the default nub should be fast and if you need a more general one you use nubEq or something
11:16:46 <SrPx> Question moved to S.O., http://stackoverflow.com/questions/32233788/how-to-impurely-modify-a-state-associated-with-an-object
11:16:53 <SrPx> Thanks guys :)
11:17:05 <Axman6> phaazon: http://hackage.haskell.org/package/tagged-0.8.1/docs/Data-Tagged.html is where I remember reading about it
11:17:32 <phaazon> there‚Äôs nothing about Proxy# here
11:17:35 <Axman6> hmm
11:17:50 <phaazon> what you‚Äôr talking about is in Data.Proxy
11:17:53 <phaazon> I‚Äôm not looking for that
11:17:57 <phaazon> I‚Äôm looking for Proxy#
11:18:00 <Axman6> yeah, I'm sure I've read about it though
11:18:07 <phaazon> I‚Äôll try to understand the error
11:18:58 <phaazon> oh it‚Äôs actually defined in GHC.Prim!
11:19:11 <phaazon> why does the doc link to GHC.Exts‚Ä¶
11:20:38 <phaazon> http://lpaste.net/139698
11:20:40 <phaazon> I don‚Äôt get it
11:20:50 <quchen> nub isn't only O(n^2), it also scales quadratically for values smaller than almost infinity.
11:20:50 <phaazon> data Proxy# a b
11:20:57 <SrPx> Thinking about it, though, I guess the most elegant solution is to use a global hashmap. All I need is to get the unique pointer of a runtime value. Is that possible?
11:20:58 <phaazon> and proxy# is Proxy# a
11:21:17 <phaazon> how should I¬†use that :D
11:22:21 <SrPx> stablename that is
11:22:24 <SrPx> guess I know what to do now
11:22:25 <SrPx> :D
11:25:20 <phaazon>     Couldn't match kind ‚Äò*‚Äô with ‚Äò#‚Äô
11:25:21 <phaazon> dammit
11:29:28 <Peaker> quchen: x == nub x   will terminate at the first value that is a duplicate, no?
11:29:50 <quchen> Peaker: You're right
11:30:03 <quchen> Well, not really!
11:30:22 <quchen> > [1,1..] == nub [1,1..]
11:30:27 <lambdabot>  mueval-core: Time limit exceeded
11:30:43 <quchen> When you've got otherwise distinct lists it'll short-circuit like that
11:30:46 <Peaker> quchen: ah, nuanced :)
11:30:55 <quchen> But if they're full of duplicates you've got a problem
11:33:46 <jle`> SrPx: https://wiki.haskell.org/Top_level_mutable_state
11:33:58 <jle`> not that this is a good idea :)
11:34:21 <the_2nd> how to merge multiple lists? [a]
11:34:27 <the_2nd> is there a built in?
11:34:35 * hackagebot uniform-pair 0.1.7 - Uniform pairs with class instances  https://hackage.haskell.org/package/uniform-pair-0.1.7 (ConalElliott)
11:34:38 <jle`> > concat [[1,2,3],[4,5,6]] -- ?
11:34:40 <lambdabot>  [1,2,3,4,5,6]
11:35:45 <Denommus> > join [[1,2,3],[4,5,6]]
11:35:47 <lambdabot>  [1,2,3,4,5,6]
11:36:03 <Denommus> I like join because it's generic :-) (works over any monad)
11:36:03 <lingxiao> hey all
11:36:08 <lingxiao> could someone take a look at my question here?
11:36:09 <lingxiao> http://stackoverflow.com/questions/32234185/counting-the-frequency-of-values-in-a-list-using-control-foldl
11:36:23 <jle`> > mconcat [[1,2,3],[4,5,6]]
11:36:25 <lambdabot>  [1,2,3,4,5,6]
11:36:32 <jle`> > fold [[1,2,3],[4,5,6]]
11:36:35 <lambdabot>  [1,2,3,4,5,6]
11:37:01 <Axman6> lingxiao: you could use a DMap (Maybe String) Int to do that easily
11:37:07 <Axman6> s/DMAP/Map
11:37:11 <jle`> sometimes the monomorphic version helps readability, too :)  so you don't have to do type inference in your head
11:37:25 <jle`> seeing map instead of fmap makes things easier to read a lot of times...same as using (.) instead of `fmap`
11:37:47 <lingxiao> Axman6 the example I showed is just a toy example
11:38:10 <lingxiao> in reality I need to traverse a arb large list many times computing statistics
11:38:15 <lingxiao> hence using the foldl library
11:38:47 <lingxiao> which allow me to combine the computations using applicatives ie `toResults <$> stat1 <*> stat2 <*> ... <*> statm $ largeList`
11:38:51 <SrPx> jle`: I think you agree with me it is a good idea when it is "fake state", i.e., state that isn't actual program state
11:39:06 <lingxiao> and foldl allow me to traverse the list just once, computing all m statistics
11:42:28 <Denommus> lingxiao: if you use foldl, you'll have to traverse the resulting list, too
11:42:38 <Denommus> lingxiao: so the algorithm will be O(n^2)
11:42:57 <Denommus> lingxiao: if you use Map as an intermediary representation, you'll be doing it in O(n)
11:44:47 <lingxiao> Denommus so in reality my list is someting like [Row1, Row2, ... ]
11:45:18 <lingxiao> where for example Row1 = Row1 (Just "a" Just "b" Just 12 Just 34.5)
11:45:53 <lingxiao> and for each column i need to compute count, count of Nothig, min, max, avg, shortest/longest string, average length of string ..
11:46:08 <quchen> Denommus: fold is also an option.
11:46:36 <lingxiao> quchen do you mean Control.Foldl
11:46:41 <lingxiao> or just folding over a list?
11:46:44 <quchen> Data.Foldable.fold
11:47:12 <quchen> :t fold :: [[a]] -> [a]
11:47:13 <lambdabot> [[a]] -> [a]
11:47:24 <Denommus> @import qualified Data.Map as M
11:47:24 <lambdabot> Unknown command, try @list
11:47:31 <Peaker> lingxiao: sounds like you want an Applicative instance for your Row
11:48:03 <Denommus> :t Data.Map.fromListWith
11:48:04 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
11:48:28 <Denommus> > let countUnique = Data.Map.toList . Data.Map.fromListWith (+) . map (flip (,) 1) in countUnique [Just "a", Just "b", Just "aab", Nothing, Just "aab"]
11:48:29 <lambdabot>  Not in scope: ‚ÄòData.Map.toList‚ÄôNot in scope: ‚ÄòData.Map.fromListWith‚Äô
11:48:45 <quchen> Data.Map is imported qualified as M.
11:48:50 <quchen> :t M.fromList
11:48:51 <lambdabot> Ord k => [(k, a)] -> M.Map k a
11:48:55 <Denommus> > let countUnique = M.toList . M.fromListWith (+) . map (flip (,) 1) in countUnique [Just "a", Just "b", Just "aab", Nothing, Just "aab"]
11:48:56 <lambdabot>  [(Nothing,1),(Just "a",1),(Just "aab",2),(Just "b",1)]
11:51:11 <hiptobecubic> Denommus, "countUnique" is not a great name for such a function. Just "count" would work better, or perhape "histogram."
11:51:26 <Denommus> hiptobecubic: whatever
11:52:05 <hiptobecubic> Denommus, I find names in haskell to be more important than other languages, since everyone just relies on type signatures rather than writing proper docs with examples.
11:53:17 <jamesfordummies> running into these issues when running `stack build`, http://lpaste.net/139699, when i do `cabal install base` it says i have 4.8. very confused
11:53:25 <Denommus> hiptobecubic: histogram is probably better, I would use count if I want to count the occurrences of a single element
11:53:32 <hiptobecubic> Denommus, agreed
11:57:23 <cocreature> jamesfordummies: base is tied to your ghc version which is tied to your snapshot when using stack, so you need a newer snapshot
11:57:34 <cocreature> also cabal install does nothing useful when using stack
11:57:43 <benzrf> hello Denommus
11:57:45 <benzrf> are u still missing macros :}
11:57:48 <jamesfordummies> k. how do I update my snapshot?
11:58:13 <cocreature> jamesfordummies: change the resolver line in your stack.yaml
11:58:27 <cocreature> you can change it to lts-3.1 which has ghc-7.10.2 which comes with base-4.8
12:04:21 <jamesfordummies> cocreature: thanks, solved that issue - more dependency issues now
12:04:36 * hackagebot bitx-bitcoin 0.5.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.5.0.0 (tebello_thejane)
12:08:03 <Denommus> wait, stack can handle different GHC versions for different projects?
12:09:11 <jamesfordummies> new problem: http://lpaste.net/139703
12:09:36 * hackagebot hspec-structured-formatter 0.1.0.0 -   https://hackage.haskell.org/package/hspec-structured-formatter-0.1.0.0 (flbulgarelli)
12:09:38 * hackagebot hsdev 0.1.4.3 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.4.3 (AlexandrRuchkin)
12:13:14 <jamesfordummies> cocreature: you have any ideas about this? http://lpaste.net/139703
12:13:58 <cocreature> jamesfordummies: give me a few minutes, I'm busy right now
12:14:05 <jamesfordummies> sorry, no problem
12:14:37 * hackagebot google-cloud 0.0.3 - Client for the Google Cloud APIs  https://hackage.haskell.org/package/google-cloud-0.0.3 (wereHamster)
12:21:01 <cocreature> Denommus: yep, assuming there is a snapshot for your ghc version. I think we only have those for 7.8 and 7.10
12:22:40 <cocreature> jamesfordummies: alright, the problem is that lts-3.1 contains a version of the OpenGL package that is too new
12:22:48 <GLM> Why would I get the following error?
12:22:49 <GLM> Could not deduce (Show AverageLen)
12:22:49 <GLM>       arising from a use of ‚ÄòshowsPrec‚Äô
12:22:49 <GLM>     from the context (a ~ TextualKind)
12:23:07 <arkeet> show your code
12:23:13 <jamesfordummies> cocreature: so i‚Äôll try lts-3.0?
12:23:23 <arkeet> @paste
12:23:23 <lambdabot> Haskell pastebin: http://lpaste.net/
12:23:30 <cocreature> jamesfordummies: oh no sorry, it's actually not in the lts snapshot but in your extra-deps
12:23:34 <cocreature> jamesfordummies: just change the version there
12:23:47 <GLM> arkeet: https://github.com/GarrettMosier/CSVStreaming
12:23:47 <cocreature> 2.12.0.1 should work
12:23:51 <GLM> On the irccomments branch
12:24:22 <arkeet> I don't see any showsPrec
12:24:25 <arkeet> what line
12:24:32 <jamesfordummies> cocreature: awesome, i had tried 2.12.0.0 but it didn‚Äôt work. why did .1 work?
12:24:55 <cocreature> jamesfordummies: I had to see the error message to comment on that
12:24:58 <arkeet> most likely you just need to make a Show instance
12:25:02 <GLM> arkeet:I don't use it but I think some part of my code calls it
12:25:02 <arkeet> or unpack the newtype before showing
12:25:33 <arkeet> so
12:25:37 <arkeet> what line is the error on?
12:25:41 <aweinstock> I'm installing my own lambdabot to use on another IRC server, and I noticed that there's a brainf*** interpreter as one of the dependencies
12:25:57 <Hafydd> An essential feature.
12:26:04 <aweinstock> does anyone know what that's about?
12:26:10 <GLM> http://lpaste.net/139704
12:26:16 <Hafydd> Just people being silly, as usual.
12:26:16 <arkeet> aweinstock: it's exactly as you think.
12:26:22 <arkeet> lambdabot includes one.
12:26:22 <kadoban> I would assume there's some goofy brainfuck command in lambdabot then
12:26:40 <Hafydd> @help bf
12:26:40 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
12:26:57 <aweinstock> @bf +++++++++++++++...
12:26:57 <lambdabot>  Done.
12:27:03 <arkeet> GLM: ok, so it's in a derived instance.
12:27:37 <arkeet> GLM: well, all the arguments to the constructors must have a Show instance
12:27:43 <arkeet> but Count, NullCount, etc. don't have any.
12:27:50 <GLM> How do I do that?
12:27:55 <arkeet> you can derive them.
12:27:57 <arkeet> if you want.
12:28:10 <GLM> Where?
12:28:15 <arkeet> on your newtypes.
12:28:26 <arkeet> newtype Count = Count Int deriving Show, etc
12:28:49 <aweinstock> so, where does the input/output for @bf come from/go?
12:29:12 <arkeet> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
12:29:13 <lambdabot>   Hello World!
12:29:27 <arkeet> I have no idea about input.
12:29:32 <arkeet> @bf ,. 1
12:29:32 <lambdabot>  Done.
12:29:41 <arkeet> "Done." ????
12:29:55 <aweinstock> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++...
12:29:55 <lambdabot>   <<<
12:30:05 <arkeet> maybe it doesn't accept input.
12:30:28 <aweinstock> so it only supports 7 instructions?
12:30:31 <jle`> "that's it, i'm done."
12:34:51 <demize> https://github.com/lambdabot/lambdabot/blob/master/lambdabot-novelty-plugins/src/Lambdabot/Plugin/Novelty/BF.hs hmm
12:36:53 <demize> So it seems it uses the brainfuck package from hackage and just runs the program given to it.
12:38:10 <fayong> hi everyone! Does anyone know if there is going to be a new version of Real World Haskell?
12:38:23 <fayong> I would love to see that book updated
12:39:49 <Welkin> fayong: not that I know of
12:40:10 <geekosaur> dons doesn't have enough pictures of sunsets to put one on each page yet >.>
12:40:11 <Welkin> there are new haskell books that come out pretty often though
12:40:25 <Welkin> bitemyapp is working on a book too
12:41:09 <Welkin> I haven't looked at it, but it is here: http://haskellbook.com/
12:41:33 <Hafydd> Collected Monad Tutorials.
12:41:34 <Welkin> there is no definitive resource yet for haskell
12:42:59 <kadoban> fayong: RWH is still usable as is. Not a lot is broken, though some stuff is.
12:43:19 <fayong> :Welkin what I liked about real world haskell was the introduction of concrete examples, using libraries
12:43:35 <Welkin> the wiki has lots of good resources, the typeclassopedia, various blogs from users here, LYAH, RWH, ParConc, and this channel
12:43:39 <kadoban> I think it's mostly ‚Ä¶ the parsec module names changed?
12:44:13 <fayong> I can't get the glade examples to work
12:45:04 <haskellberry_pie> I need an english dictionary, the more words the better but at least 10000, preferrably 50000+. how can I get one? expensive? are there free ones?
12:45:26 <fayong> I have been able to run all the code up to the gui chapter, by slitghty modifying the code in places
12:45:29 <Welkin> haskellberry_pie: there are lots of free dictionaries
12:45:35 <Welkin> do you mean an open source one?
12:46:00 <fayong> but the last chapters seems too hard to fix for me
12:46:15 <haskellberry_pie> i need to be able to use it programmatically
12:46:20 <haskellberry_pie> can you link one?
12:46:58 <demize> Well, what exactly do you need it /for/?
12:47:11 <Welkin> haskellberry_pie: I don't know of a specific English one, although I know of CC-CEDIT (Chinese-English)
12:47:25 <Welkin> I'm sure there is something similar for English-English
12:47:52 <demize> I wonder what license the aspell dictionary is under.
12:49:38 * hackagebot comfort-graph 0.0 - Graph structure with type parameters for nodes and edges  https://hackage.haskell.org/package/comfort-graph-0.0 (HenningThielemann)
12:49:40 * hackagebot linear-circuit 0.0 - Compute resistance of linear electrical circuits  https://hackage.haskell.org/package/linear-circuit-0.0 (HenningThielemann)
12:49:42 <Welkin> haskellberry_pie: http://blog.okfn.org/2009/07/21/open-dictionary-databases-an-overview/
12:52:59 <haskellberry_pie> I need a big list of english words!
12:53:02 <Welkin> ftp://ftp.gnu.org/gnu/aspell/dict/en/
12:53:14 <phaazon> hm, I don‚Äôt get how EmptyCase interacts with the typesystem
12:54:12 <kadoban> haskellberry_pie: You know a wordlist and a dictionary aren't really the same thing, right? What are you using it for?
12:54:38 * hackagebot resistor-cube 0.0.0.3 - Compute total resistance of a cube of resistors  https://hackage.haskell.org/package/resistor-cube-0.0.0.3 (HenningThielemann)
12:57:15 <phaazon> @let import GHC.Prim
12:57:16 <lambdabot>  .L.hs:123:1:
12:57:16 <lambdabot>      GHC.Prim: Can't be safely imported! The module itself isn't safe.
13:01:31 <NemesisD> has anyone experienced an issue where compiling with -threaded causes some loop using "forever" to hold an exclusive lock on the runtime and not let other threads interrupt or cancel it?
13:02:32 <NemesisD> i've got a thread i fork off with async that is in a loop and has an STM transaction inside. At some point in my program i cancel it, i've found that the loop never yields to the thread thats killing it, but if I run the same exact program with +RTS -NX where X > 1 it does
13:02:54 <pyon> Is there any library for writing lexers that's compatible with any of the major parser combinator libraries?
13:03:14 <NemesisD> i've also tried explicitly calling Control.Concurrent.yield to try to prod the runtime into giving someone else a chance. nothing
13:03:36 <phaazon> hm
13:05:15 <belst> hey guys, i have problems installing haskell-src-exts. Im running out of memory during compilation. I'm inside a vm so i can't just add a swapfile. any ideas?
13:05:21 <NemesisD> does omitting N use some completely different mode in the runtime?
13:06:12 <Welkin> belst: how much memory do you have?
13:06:43 <belst> Mem:          2048        736       1311         78          0        400
13:06:53 <belst> output of free -m
13:07:31 <Welkin> 736 MB free?
13:07:48 <belst> no used
13:07:50 <belst> 1311 free
13:08:26 <phaazon> hm, because Proxy# has a kind of #, I don‚Äôt get how I‚Äôm supposed to use it in functions like proxy a -> String
13:08:29 <Welkin> I now when I tried to install ghc on a vm with only 1GB of memory it failed
13:08:33 <Welkin> know*
13:08:35 <phaazon> class Foo a where foo :: proxy a -> String
13:08:45 <phaazon> how can I use Proxy# there?
13:09:26 <hexagoxel> belst: are you using -j1 already?
13:09:37 <belst> im just cabal install haskell-src-exts
13:09:39 * hackagebot hspec-structured-formatter 0.1.0.1 -   https://hackage.haskell.org/package/hspec-structured-formatter-0.1.0.1 (flbulgarelli)
13:11:05 <hexagoxel> belst: try adding -j1 then to ensure it does not start two compiles in parallel
13:11:47 <belst> thx i'll try. Will report back
13:22:52 <Denommus> hm, is there a dedicated channel for stack?
13:23:08 <kadoban> Denommus: #haskell-stack , though it's fairly small
13:24:40 * hackagebot lentil 0.1.4.1 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.4.1 (fffaaa)
13:24:41 <aweinstock> when trying to install lambdabot, I'm getting "cabal: The program 'happy' version >=1.17 is required but it could not be found."
13:24:42 * hackagebot Ebnf2ps 1.0.15 - Peter's Syntax Diagram Drawing Tool  https://hackage.haskell.org/package/Ebnf2ps-1.0.15 (FranklinChen)
13:24:57 <aweinstock> how should I go about resolving that?
13:25:26 <Denommus> aweinstock: you install the program happy in a version that is equal or higher than 1.17
13:25:41 <hexagoxel> and put in on PATH
13:25:55 <belst> hexagoxel: well i got further now. now i run out of memory at step 13 of 22. before it was at step 9
13:26:12 <NemesisD> i can't tell from the base haddocks, is GHC's SMP implementation cooperative or preemptive?
13:26:33 <M-ou-se> Is it possible to use Template Haskell to make a function with signature `foo :: a -> String`, that would give the type of whatever you give to it? for example: foo (1 :: Int) == "Int", foo "asdf" == "[Char]", etc.
13:26:47 <nitrix> Hi, quick question, stack seems to behave differently than cabal, where the repl doesn't import my src/Main.hs as a Main module automatically, so I had to explicitely add a Main module and now I'm stuck doing Main.main to run the program.
13:26:48 <Denommus> I'm trying to build stack-ide
13:26:53 <aweinstock> huh, so that's just an edge case in the dependency resolution?
13:26:54 <NemesisD> "The yield action allows (forces, in a co-operative multitasking implementation) a context-switch" which implementation is it?
13:26:57 <nitrix> Shouldn't it normally takes care of this?
13:27:00 <Denommus> but I'm getting an error .stack-work/dist/x86_64-linux/Cabal-1.22.4.0/build/src/Control/Monad/Base.dump-hi: commitBuffer: invalid argument (invalid character)
13:27:09 <Denommus> when compiling transformers-base
13:27:15 <Denommus> also, some warnings like /bin/sh: warning: setlocale: LC_ALL:
13:27:15 <Denommus>                cannot change locale (C.UTF-8)
13:31:02 <fvgvxmpv1> I¬¥m getting GHC panics when trying to build a cabal test-suite (using cabal2nix on nixos): "Don¬¥t understand library name test-foo" ‚Äî This seems, according to google, somewhat common but I couldn¬¥t find a solution; What¬¥s happening here?
13:31:20 <belst> hexagoxel: ok nvm. if i do cabal get, cabal configure, cabal build i get to step 13. if i just do cabal install i only get to step 9
13:32:02 <hexagoxel> aweinstock: it is a dependency on the happy _executable_. those are not managed by `cabal` (which is unfortunate, but does not happen too often)
13:33:32 <aweinstock> hexagoxel: thanks, that's a clear explanation
13:34:19 <jle`> phaazon: if Foo :: * -> Constraint, then you can't really write an instance for something of kind #, I think
13:34:22 <jle`> because only *'s work
13:34:23 <geekosaur> Denommus, my guess is your system does not have locale C.UTF-8 and that's breaking anything that depends on locales (such as the runtime's output conversion)
13:34:56 <geekosaur> export LANG=en_US.UTF-8 # or some other locale that exists on your system and preferably is UTF8-based
13:35:00 <jle`> phaazon: if Foo :: k -> Constraint then you might have better luck
13:35:14 <jle`> try turning on PolyKinds ?
13:35:14 <cocreature> Denommus: stack is broken on non debian based systems atm
13:35:42 <cocreature> because it tries to change the locale to C.UTF-8 which doesn't exist on e.g. fedora or arch
13:35:50 <phaazon> jle`: yeah, edwardk is explaining everything about that on #haskell-lens
13:35:57 <phaazon> jle`: btw 
13:36:02 <jle`> phaazon: sweet :)
13:36:03 <cocreature> Denommus: see https://github.com/commercialhaskell/stack/issues/856
13:36:05 <phaazon> do you know how EmptyCase interacts with the type stystem?
13:36:06 <phaazon> system/
13:36:07 <geekosaur> owwww
13:36:07 <phaazon> *
13:36:10 <phaazon> I really don‚Äôt get it
13:36:12 <geekosaur> their fault, cute
13:36:46 <cocreature> yeah they tried to fix the encoding problems and it resulted in a far worse situation :)
13:36:49 <jle`> phaazon: never used it, sorry
13:37:00 <fvgvxmpv1> this page: http://lpaste.net/new/haskell
13:37:03 <fvgvxmpv1> upps
13:37:06 <nitrix> Is it normal stack gives me "not in scope main" when trying to run main?
13:37:16 <nitrix> cabal lets me, stack doesn't. I have to do Main.main
13:37:43 <fvgvxmpv1> this page: https://ghc.haskell.org/trac/ghc/ticket/9625 lead me to try calling my 'test-suite' "HStest-foo" which yields "undefined reference to `‚Ä¶"-errors
13:38:23 <Denommus> cocreature: are you guys working on a fix?
13:39:16 <cocreature> Denommus: borsboom said that he is going to fix it so I didn't start working on a fix (also I'm not really involved with the stack project although for some reason I have commit access)
13:39:25 <Denommus> cocreature: I can help, but I don't want to duplicate effort
13:40:15 <cocreature> Denommus: well then comment on the issue and say that you want to fix it
13:41:03 <fvgvxmpv1> (7.10.2, btw)
13:51:11 <nitrix> Okay, apparently stack 2.0.0 solves many of the issues I'm having. I just read the tickets.
13:51:12 <nitrix> I'll try the master version.
13:52:37 <kadoban> There's a stack 2.0.0 ? I only see 0.1.3.1
13:52:57 <Ankhers> nitrix: I think you mean 0.2.0.0
13:53:16 <kadoban> I don't think that exists yet either, heh.
13:53:42 <Ankhers> Technically not, but issues are tagged with it.
13:54:07 <kadoban> Ah
13:56:11 <hwhelchel> hello
13:56:30 <Ankhers> hwhelchel: Howdy.
13:57:13 <hwhelchel> I'm looking at Data.Array in the docs. It says "Haskell provides indexable arrays, which may be thought of as functions whose domains are isomorphic to contiguous subsets of the integers." see: http://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array.html
13:57:18 <hwhelchel> What does that mean?
13:57:28 <hwhelchel> domains are isomorphic...
13:57:55 <Denommus> hwhelchel: do you know what the domain of a function is?
13:57:56 <jle`> hwhelchel: it means that it's a function from "something" that is isomorphic to a range of integers, like [1..3]
13:57:58 <Hafydd> Isomorphic means "same" (iso) "shaped" (morph).
13:58:24 <hwhelchel> what is the domain of a function? All valid inputs?
13:58:29 <jle`> for example, Bool is isomorphic to [1..2], or [5..6]
13:58:38 <jle`> in this case it means the `a` in f :: a -> b, roughly
13:58:55 <Denommus> hwhelchel: yes, the domain of a function is the set of "input" that is valid for that function
13:59:05 <jle`> so this is saying that an Array Int, with two elements, can be thought of as an f :: Bool -> a
13:59:09 <jle`> er, f :: Bool -> Int
13:59:21 <Denommus> hwhelchel: an array is like a function where the input has the same structure as contiguous integers
13:59:50 <Denommus> hwhelchel: you don't need to worry about that, this is just explaining what an array is in mathematical terms
13:59:52 <jle`> a better phrasing might be, "functions whose domains are contiguous subsets of the integers...or anything isomorphic to it, i guess"
14:00:22 <hwhelchel> So maybe a function that maps integers (the array indices) to the the elements of the array?
14:00:33 <jle`> hwhelchel: yup
14:00:35 <pyon> jle`: How can a type (a type-level entity) be the same thing as a list (a value-level entity?
14:00:43 <Denommus> hwhelchel: CONTIGUOUS integers
14:00:54 <pyon> )*?
14:00:54 <hwhelchel> right
14:00:54 <hwhelchel> thanks everyone
14:00:56 <jle`> hwhelchel: but, more powerful than that, a function from *any type* that can go to the indices
14:01:02 <jle`> so like, Bool works as a domain for an array of two elements
14:01:10 <jle`> because an array of two Int's is basically a Bool -> Int
14:01:17 <jle`> because Bool is isomorphic to [1..2]
14:01:35 <jle`> pyon: hm, is there a context here?
14:01:50 <jle`> oh, i'm not using haskell lists, i'm using notation to talk about a set
14:01:56 <pyon> Oh, okay.
14:02:03 <Hafydd> A type is a type-level entity, eh?
14:02:15 <jle`> so Bool is isomorphic to the set {1, 2}
14:02:49 <hwhelchel> jle: gotcha so any type that is isomorphic to a contiguous set of integers can serve as the first type in the array function?
14:02:55 <Denommus> Hafydd: yes. They don't exist at the value-level
14:03:07 <jle`> hwhelchel: yeah, in the "encoding of an Array as a function"
14:03:14 <jle`> or, the representation of an array as a function
14:03:19 <hwhelchel> neat
14:03:29 <jle`> it's just a fancy pants way of talking about arrays as mathematical objects
14:04:03 <jle`> instead of in like...computer terms
14:04:17 <jle`> cause it's not like we're programming a computer or anything...
14:04:26 <jle`> #haskellculture
14:04:37 <kuribas> we're computer scientists!
14:04:38 <Denommus> hwhelchel: basically, that means you can use any type that instances the typeclass Ix :P
14:04:47 <kuribas> though I am not...
14:05:00 <Hafydd> What's the "computer term" for a set isomorphic to a contiguous range of integers?
14:06:18 <jle`> "an array is a contiguous chunk of memory that you can store things and retrieve things in by providing a pointer offset"
14:06:23 <nitrix> hwhelchel: Are you familiar with functions? Domain and codomain?
14:06:43 <hwhelchel> nitrix: don't think so. would be happy to learn.
14:06:55 <Hafydd> jle`: that's abysmal.
14:07:24 <jle`> why do you think i spend all my time in #haskell
14:08:03 <Hafydd> (And untrue, since the array is not necessarily stored as contiguous memory.(
14:08:59 <hwhelchel> what is the domain of a function?
14:10:00 <Denommus> hwhelchel: I told you. The domain of a function is the set of valid input for the function
14:10:34 <hwhelchel> You're right thanks
14:11:21 <hexagoxel> phaazon: couldn't you use Tagged (on the result of the class' method) instead? should be free, and not too clunky regarding usage.
14:11:59 <Denommus> hwhelchel: while the codomain is the set of f(x) for every valid x
14:12:25 <Hafydd> codomain <=ANAGRAM=> condom AI
14:13:33 <Hafydd> (The codomain is not the set of all f(x) -- that's the /image/ -- but rather an arbitrary superset of that by which the function is defined.)
14:13:51 <Denommus> Hafydd: ah, that's right
14:14:59 <hwhelchel> so is the codomain all valid outputs of the function?
14:15:12 <fosterite> all valid outputs are in the codomain
14:16:20 <hwhelchel> how can one reason about values in the codomain of a function that are not inputs or outputs of the function? how do those values relate to the function?
14:18:11 <hwhelchel> might be the wrong question haha
14:18:27 <johnw> how is the codomain not the same as the output?
14:19:55 <shachaf> Sometimes "output" can mean "image".
14:20:20 <fosterite> johnw: the codomain of `const 1` is Integer, not {1} usually
14:20:28 <ttt_fff> are there any langauge features that haskell has but purescript lacks?
14:20:39 <shachaf> "range" and "output" and so on are ambiguous terms, which is why I say "image" and "codomain".
14:20:40 <ttt_fff> are there any langauge features that haskell has but purescript lacks? (not referring to libraries)
14:22:03 <fosterite> ttt_fff: some extensions of course. newtype deriving just landed. I don't think you can DeriveFunctor in psc yet
14:22:33 <ttt_fff> hmm, but basics things like typeclasses, gadts, monads are all there?
14:22:45 <shachaf> Why are you asking here?
14:22:45 <johnw> hwhelchel: LiquidHaskell is one possibility, as it allows you to reason about the image of the function by applying refinements to Integer that do not change the type from Haskell's perspective
14:22:49 <shachaf> Ask in the purescript channel.
14:23:13 <ttt_fff> shachaf: when comparing langauges #A and #B, how do you pick which channel to ask in?
14:23:29 <shachaf> Most people who knows about purescript know about Haskell, and not vice versa.
14:23:57 <shachaf> I declare that this channel isn't a great place for it.
14:29:39 <ttt_fff> by hiding Prelude, and declaring typeclasses with (+) , (*), (/), (-), it's possible to define an expr language DSL and use +-*/ in the expr language. Is there clever way to push haskell anon functions, i.e. \x y -> ,, or pattern matching "case ... of ... -> ... " into a DSL ? [without use of TH]
14:33:27 <Peaker> ttt_fff: I think this conal post is relevant: http://conal.net/blog/posts/overloading-lambda
14:37:59 <Hafydd> hwhelchel: they relate to the function as much as -1 :: Int relates to abs :: Int -> Int, i.e. not much.
14:38:52 <Hafydd> But it's difficult to define a notion of "function" if you require that every element in the codomain is also in the image.
14:39:29 <xcv_> hi
14:39:38 <xcv_> should I feel bad for using unsafePerformIO . getEnv?
14:39:59 <jle`> yes
14:40:02 <jle`> :)
14:40:07 <xcv_> D:
14:40:08 <jle`> environment variables can change over the course of the program
14:40:15 <jle`> GHC might inline
14:40:25 <jle`> different behavior depending on optimization
14:40:30 <xcv_> it's a one-shot tool, though
14:40:43 <xcv_> I'm writing a unix find clone
14:41:00 <jle`> and you can't use bind getEnv ?
14:41:06 <xcv_> well, not a clone exactly, but the functionality is similar
14:41:14 <jle`> it looks like you're doing IO anyways
14:41:32 <xcv_> I have a little language for predicates, and I analyze them before running the whole thing
14:41:38 <xcv_> and I'd like to make the analyzer pure
14:41:54 <jle`> so make your analyzer a pure function on a list of environment variables
14:42:00 <xcv_> the only thing remaining is the part that checks whether environment variables exist and bakes them into the predicate
14:42:03 <jle`> and pass it the environment variables :)
14:42:39 <xcv_> I guess I could add just another field to the ReaderT then
14:42:39 <aweinstock> I build a copy of lambdabot, but when I do "> sum [1..10]", it prints: mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
14:42:43 <aweinstock> s/build/built
14:42:48 <jle`> or you can just pass it as an argument, too
14:43:43 <xcv_> I think I'll just use System.Posix.Env.ByteString.getEnvironment and lookup
14:43:57 <xcv_> the best solution usually just ends up being the simplest one :D
14:44:23 <jle`> :D
14:46:37 <kadoban> Is there a syntax for documenting things in the export list of a module? Some stuff I'm defining is made via TH, so I can't really document it in the body of the code :-/
14:46:47 <kadoban> s/things/types/
14:47:10 <kadoban> I've tried -- ^   and -- |  , the first gives a syntax error, the second ‚Ä¶ seems to add text to the description of the module itself.
14:48:44 <ttt_fff> https://gist.github.com/anonymous/09c2f15886b8a5010f6b <-- anyone know why I get an "unknown command: Enter"
14:49:01 <kadoban> That's some funny haskell.
14:49:33 <ttt_fff> yeah, does this belong in #haskell-tools instead
14:49:44 * hackagebot comfort-graph 0.0.0.1 - Graph structure with type parameters for nodes and edges  https://hackage.haskell.org/package/comfort-graph-0.0.0.1 (HenningThielemann)
14:49:55 <kadoban> Isn't there a #tmux or something? I'd think they'd know much better.
14:54:44 * hackagebot foldl-transduce 0.1.2.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.1.2.0 (DanielDiazCarrete)
14:57:44 <arkeet> kadoban: I don't think there is any way to document TH-generated things
14:58:12 <aweinstock> how do I get evaluation working in my offline copy of lambdabot? it seems to not be loading the L.hs file
14:59:00 <agocorona> sdfasf
15:02:14 <arkeet> kadoban: hm
15:02:28 <arkeet>  the generated functions do not include type signatures, then you can write a type-signature by hand and document things the normal way."
15:02:39 <arkeet> er, "if" at the start.
15:03:22 <arkeet> maybe that's an option for you.
15:11:35 <SrPx> Hey guys, any idea how to make this faster? http://lpaste.net/139714
15:18:24 <sm> kadoban: -- * isn't it. Haddock docs should say
15:23:14 <ttt_fff> is there a way in haskell to say: (1) I give up all existing libraries, including prelude, and (2) please make default evalutaion strategy stirict ?
15:23:54 <arkeet> sm: that's for making sections
15:24:16 <arkeet> but perhaps you can just designate a section for auto-generated stuff and put some prose in there
15:24:28 <fosterite> ttt_fff: there are strict haskell compilers (Disciple)
15:25:19 <ttt_fff> fosterite: https://wiki.haskell.org/DDC ?
15:25:32 <fosterite> ttt_fff: yeah
15:26:14 <fosterite> also this https://ghc.haskell.org/trac/ghc/wiki/StrictPragma
15:27:17 <fosterite> it's not implemented though
15:27:47 <ttt_fff> yeah, "not implemented" makes it slightly less useful :-)
15:28:24 <mauris> i read somewhere that i should write "pure" everywhere instead of "return" now that Monad is a subclass of Applicative. is this a good idea?
15:29:45 * hackagebot foldl-transduce 0.1.2.1 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.1.2.1 (DanielDiazCarrete)
15:30:30 <Welkin> subclass?
15:30:46 <fosterite> mauris: entirely your call. they are the same function now
15:31:09 <markwashere> Does anyone mind if a haskell newbie ask a very newbie question?
15:31:22 <shachaf> Questions about Haskell are fine.
15:31:26 <Welkin> it will not be backwards compatible with anything before 7.10 is you do that
15:31:30 <Welkin> I am still on 7.8.4
15:31:31 <kadoban> sm: -- * didn't seem to do anything :(
15:31:38 <shachaf> Questions about asking questions should generally be avoided.
15:31:40 <kadoban> arkeet: Oh yeah? That kinda sucks :-/
15:31:41 <Welkin> if*
15:32:07 <markwashere> Heh. Well, I'm trying to figure out why last [1..] eats memory. I expected it to just sit there and spin forever, but it starts allocating memory as well.
15:32:22 <markwashere> I assume I'm missing something very basic.
15:33:06 <nitrix> markwashere: There are some cases where the list would need to be evaluated entirely before returning a result.
15:33:20 <nitrix> markwashere: sum [1..] for example. Can you provide your coe?
15:33:25 <nitrix> I'm sorry, code.
15:33:37 <shachaf> It depends on the situation.
15:33:44 <Welkin> :t least
15:33:46 <lambdabot>     Not in scope: ‚Äòleast‚Äô
15:33:46 <lambdabot>     Perhaps you meant one of these:
15:33:46 <lambdabot>       ‚Äòlast‚Äô (imported from Data.List),
15:33:47 <Welkin> :t last
15:33:48 <lambdabot> [a] -> a
15:34:19 <Welkin> it must traverse the list before it can get to the end
15:34:47 <kadoban> sm: Oh hmm, it does do something ‚Ä¶ it makes like, a section or something? But not the right thing :-/
15:34:50 <jmcarthur_> well, you can still gc the list as you go for both of those functions, unless you are also holding on to the list for later
15:37:33 <markwashere> nitrix: https://gist.github.com/MurphyMarkW/9dd348963de56bf79868
15:37:52 <markwashere> Sorry if that's not entirely valid haskell. Literally just started.
15:38:21 <fosterite> @src last
15:38:21 <lambdabot> last [x]    = x
15:38:21 <lambdabot> last (_:xs) = last xs
15:38:21 <lambdabot> last []     = undefined
15:39:16 <markwashere> fosterite: That's nifty. I'm totally gonna make use of that. o.o
15:39:23 <jle`> how does last (iterate (+1) 0) fare, memory-wise?
15:39:23 <nitrix> The implementation looks identical to me.
15:39:56 <kadoban> If you're talking about what @src said ‚Ä¶ that's not trustworthy.
15:39:58 <shachaf> @src is often wrong about the real implementation.
15:41:11 <nitrix> I see.
15:41:29 <fosterite> the implementation in prelude is `last xs = foldl (\_ x -> x) lastError xs`
15:41:34 <shachaf> There are lots of things that could be going on.
15:41:40 <nitrix> Now I'm also currious about markwashere's question. How does one predict thins kind of behavior?
15:41:47 <jle`>  @src is just a text file on lambdabot's file system that it does a text sarch on
15:41:50 <nitrix> Is it because GHC only garbage collects between thunks evaluations?
15:42:38 <nitrix> Certainly this has to be predictable somehow.
15:42:53 <arkeet> so
15:43:01 <arkeet> if last uses foldl
15:43:16 <arkeet> it would just build up a big thunk I guess.
15:43:25 <arkeet> uh.
15:44:28 <jle`> i guess this is one of the cases where foldl is what has to be used
15:44:30 <jle`> go figure
15:45:01 <arkeet> but
15:45:22 <arkeet> wouldn't it end up buliding up a huge thunk like
15:45:24 <nitrix> Oh, foldl doesn't garbage why folding?
15:45:27 <arkeet> ok, let f = (\_ x -> x)
15:45:39 <arkeet> so last [1,2,3] would be like
15:46:18 <arkeet> > foldl (f :: Expr -> Expr -> Expr) (var "lastError") [1,2,3]
15:46:20 <lambdabot>  f (f (f lastError 1) 2) 3
15:46:31 <arkeet> would just build up a big thing like that
15:46:54 <arkeet> and then once the end of the list is reached, it would evaluate the outer f and discard the first argumente
15:47:04 <nitrix> Holy. Are you serious? Fold just applies functions and then it's regular evaluation that takes care of it?
15:47:07 <jle`> but the alternative, foldl', gives the wrong semantics
15:47:15 <jle`> at least on that isn't obvious
15:47:16 <jle`> *on
15:47:19 <jle`> e
15:47:21 <arkeet> foldl' has wrong semantics yes.
15:47:26 <arkeet> but foldl is also bad.
15:47:32 <arkeet> correct semantics but poor performance.
15:48:05 <nitrix> Is there any reason why it isn't implemented as a recursive function?
15:48:13 <arkeet> I don't know
15:48:30 <arkeet> -- Use foldl to make last a good consumer.
15:48:30 <arkeet> -- This will compile to good code for the actual GHC.List.last.
15:48:31 <arkeet> -- (At least as long it is eta-expaned, otherwise it does not, #10260.)
15:48:39 <arkeet> that's why it uses foldl. apparently.
15:49:10 <nitrix> To make last a good consumer... What is good code, ahah.
15:49:50 <arkeet> well, optimizations might improve things.
15:50:04 <jle`> maybe it plays more nicely with ghc's fusion mechanics?
15:50:27 <nitrix> Isn't a change like this the sort of thing that breaks backwards compatibility? Suddently someone's code is having a space leak or whatever?
15:51:00 <nitrix> It's not an API break per say, but performance breakage.
15:51:08 <arkeet> maybe with optimizations on, last [1..] will take constant space.
15:51:10 <arkeet> I haven't tried.
15:51:42 <nitrix> This space leak thing is starting to worry me a lot.
15:52:22 <nitrix> Is that a result of lazyness or infinite lists?
15:52:28 <arkeet> laziness.
15:53:10 <haskell979> woah - is it always this full in here?
15:53:17 <arkeet> yes
15:53:37 <haskell979> wow. I had no idea.
15:53:40 <nitrix> haskell979: I guess we would need a frame of reference to call it full.
15:54:18 <haskell979> Well, there's a lot of names in the list at the side.
15:54:50 <haskell979> I mean, I heard people say it was friendly on #haskell, but I thought small and friendly, not huge and friendly!
15:55:08 <nitrix> arkeet: That's honestly very scary. I typically write code thinking lazy evaluation is just a added bonus and I've never really relied on it, but that's scarry.
15:55:28 <haskell979> Oh, and me joining makes conal eliot fall asleep!
15:55:45 <nitrix> Enough to make me look at alternatives.
15:55:48 <markwashere> haskell979: Well, they're being really nice about the super newbie question I asked, so I'd say it's safe to say they're friendly, regardless of size. :)
15:56:10 <haskell979> markwashere: Good to hear it.
15:56:21 <jle`> nitrix: well, if you're using `last`, your problem might be that you're using the wrong data structure, heh
15:56:48 <nitrix> jle`: I can only agree, yet something bothers me :/
15:56:56 <arkeet> fwiw ghc 7.8 uses a different definition of last.
15:57:01 <nitrix> It's sort of like the partial `head []`
15:57:10 <arkeet> that doesn't space leak.
15:57:38 <nitrix> No, but that makes two things that really bothers me and doesn't have their justifications :/
15:59:40 <nitrix> arkeet: Oh I think your last comment was coincidently fitting.
15:59:47 * hackagebot foldl-transduce 0.1.2.2 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.1.2.2 (DanielDiazCarrete)
16:00:56 <arkeet> anyway.
16:00:59 <arkeet> with ghc 7.10
16:01:04 <arkeet> with last defined in terms of foldl
16:01:22 <arkeet> last [1..] doesn't leak when compiled with optimizations
16:02:04 <nitrix> Interesting. The repl does though.
16:02:57 <arkeet> sure.
16:03:04 <arkeet> because no optimizations.
16:05:18 <arkeet> actually I lied. I used 7.8, with my own version of last defined using foldl.
16:05:20 <arkeet> but I assume it's similar.
16:05:40 <arkeet> I should probably put 7.10 on this machine.
16:06:07 <haskell979> 7.10 is nice, yes.
16:24:48 * hackagebot foldl-transduce 0.1.2.3 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.1.2.3 (DanielDiazCarrete)
16:26:55 <Lokathor> arkeet, if you get stack, it will pull in a copy of 7.10 for you as part of its setup
16:27:05 <arkeet> I know.
16:27:08 <arkeet> I'm lazy.
16:27:18 <Lokathor> lazier than haskell :P
16:28:04 <Arahael> I'd argue that.
16:28:16 <Arahael> arkeet will get stack precicely when he requires it.
16:28:51 <Lokathor> so does that make him exactly as lazy as haskell? some libs used are strict all the time and perhaps a value is never needed despite using a strict lib
16:31:00 <Arahael> Lokathor: Yes, but don't they need to be explicitly set as strict? Eg, with ! or seq?
16:31:18 <ansible1> hey all, I'm trying to compile persistent-sqlite, I get "fatal error: ffi.h: No such file or directory"
16:31:33 <hacker> that's forcing us to do stuf we are use we might need later, but we can still be lazy and start doing it later 
16:31:43 <ansible1> while ghc is compiling a file "/tmp/ghc24677_0/ghc24677_5.c"
16:31:54 <Arahael> Incidentially, I need to start working soon.
16:32:01 <ansible1> I added the dir with ffi.h to my PATH, but that didn't help...
16:32:04 <Arahael> Which means having coffee, which means I need to cycle to the work cafe.
16:33:56 <Lokathor> Arahael, Data.Map.Strict, for example, has a map type that's always strict when you get/put. If you put in a value you later don't need, you accidentally used too much strict.
16:35:11 <Lokathor> speaking on another subject, there's an RNG in C that's supposed to be rather good. It has a C and C++ version, and there's a Haskell FFI for it
16:35:46 <Lokathor> however, the core of the RNG is a single function and a single struct. Is haskell really bad at fiddling with bits enough to want to use FFI?
16:37:18 <arkeet> would you rather reimplement the whole thing in pure haskell?
16:37:28 <jmcarthur_> GCC is probably better at optimizing that kind of code
16:37:46 <jmcarthur_> and it's not like it's hard to write a C binding
16:37:59 <Lokathor> http://www.pcg-random.org/download.html it's 1 function in C, you can see it there on the page.
16:38:35 <Lokathor> jmcarthur_, my thought was that if you had the pure haskell version you could do it outside of IO
16:38:37 <jmcarthur_> also, how old is the library? we gained some more efficient bit shift functions just a couple years ago, iirc
16:38:51 <Lokathor> it's extremely new
16:39:01 <jmcarthur_> the "safe" ones do some extra check i don't remember
16:39:14 <jmcarthur_> well, it's pretty simple. you could write a benchmark
16:40:21 <jmcarthur_> Lokathor: are you talking about the pcg-random package?
16:40:21 <Lokathor> I will look into that
16:40:26 <mniip> is there a datatype like 'data Foo a = Unit a | Concat (Foo a) (Foo a)'
16:40:29 <jmcarthur_> Lokathor: it looks like there is already a pure haskell implementation in there
16:40:33 <mniip> with an included -> [a] transformation
16:40:39 <jmcarthur_> ah
16:40:43 <jmcarthur_> the "fast" variant of the prng
16:40:44 <Lokathor> jmcarthur_, yes that's the haskell package
16:40:50 <jmcarthur_> whatever that means
16:40:54 <jmcarthur_> lower quality
16:41:04 <jmcarthur_> i haven't found a haskell implementation of the "unfast" version
16:41:17 <Lokathor> oh
16:41:22 <Lokathor> there was a commit in the last day
16:41:30 <mniip> I could of course implement the folding myself but eh
16:41:31 <Lokathor> that.. changes things i guess
16:41:32 <jmcarthur_> Lokathor: also, the web site you just linked to is clear that the code sample is the "minimal" version
16:41:52 <jmcarthur_> Lokathor: so it's more work than just a function and a data structure
16:41:52 <Lokathor> yes, that's the core, and the rest of the stuff builds upon that core
16:41:56 <jmcarthur_> for the whole thing
16:42:28 <Lokathor> i'm not saying never use FFI, i was just wondering if i'd get an answer like "yeah bitwise operation is terrible in haskell" or something
16:42:37 <jmcarthur_> they aren't terrible
16:42:54 <jmcarthur_> the ghc code gen is not going to outperform gcc often though
16:42:59 <jmcarthur_> the llvm backend may do better?
16:43:51 <jmcarthur_> but really, if it comes down to optimizing basically C in ghc vs. in gcc, gcc will probably do better. if it comes down to optimizing something higher level, ghc probably do better.
16:44:20 <jmcarthur_> maybe
16:44:21 <jmcarthur_> :)
16:45:46 <Lokathor> honestly, my objection was more from the fact that, as a windows user, i don't trust haskell's FFI stuff, because i don't trust and C stuff on windows
16:46:51 <Arahael> Lokathor: Good to know - regarding the strict map. :)
16:47:02 <jmcarthur_> depending on the definition of trust, i might trust C stuff more than Haskell stuff on windows
16:47:12 <Arahael> Lokathor: Why don't you trust C stuff on windows, other than it being woefully low-level and implementation-defined?
16:47:31 <hpc> Arahael: the stuff you have to include is totally different
16:47:32 <Lokathor> jmcarthur_, i trust it to work once compiled, but i don't trust it to compile properly
16:47:36 <hpc> and it's not totally posix
16:47:41 <hpc> and the tools are a pain
16:47:57 <jmcarthur_> Lokathor: it sounds like you are describing the experience of haskell on windows ;)
16:48:06 <Lokathor> well.... yes :P
16:48:18 <Arahael> hpc: Well, yes, the libraries themselves are different.  And yes, it's not posix. And yes, the tools are simplistic.
16:48:40 <Arahael> Not many people focus on the C api in windows. (The native API in windows is C++, or .NET)
16:48:41 <Lokathor> these days stack lets you compile sdl2 without much fuss, so that's cool. things are getting better
16:49:38 <Arahael> But I absolutely loathe the variation in CRT's on windows. :( (C Runtimes)
16:49:40 <redxaxder> is there someone here who understands servant and is willing to answer a few questions?
16:51:22 <alpounet> redxaxder: yep, i'm one of the devs. but there's #servant too, where you'll probably have higher chances to get answers at any given time of the day =)
16:51:32 <Arahael> So I was talking to someone the other day about possibly learning about Arrows, he mentioned that Arrows are old and I shouldn't bother learning about them.
16:51:34 <Arahael> Is that true?
16:51:44 <Arahael> I thought FRP was all about arrows?
16:52:44 <Arahael> (Though, it should be said that the only reason I'm looking into FRP, is because most of the more recent haskell games seem to be in it - and more specifically, haskanoid uses FRP - even more specifically, it uses Yampa)
16:52:48 <Stratege> what I heard from the haskellcast FRP is all about time varied behaviour. I might be remembering wrong.
16:53:24 <Arahael> Stratege: That's the essence of what little I understand.  Something about a signal being sent at time t being dependant on the event occuring at the time duration [0,t]
16:55:47 <Stratege> Arahael I can really recommend http://www.haskellcast.com/episode/009-conal-elliott-on-frp-and-denotational-design/ for an explanation on frp. Been a while since I heard it and I was driving so I don't remmeber that much of it, but I recall that it was a rather good explanation and spent some time talking about missconceptions
16:56:11 <Stratege> (I sadly don't have any experience with FRP myself yet, so can't help much more with your question)
16:56:37 <Arahael> Stratege: Does that come with a transcription?
16:56:55 <Arahael> Stratege: That's like, a solid hour of non-stop talking, and I'm deaf.
16:56:59 <Stratege> not that I'm aware of, sadly.
16:57:01 <Arahael> :
16:57:08 <Arahael> Ah well.
16:57:41 <fosterite> Arahael: one way to make FRP libraries that don't leak space like a sieve was to use arrows, but other ways have been developed
16:58:06 <Arahael> fosterite: Does Yampa use these 'toerh ways'?
16:58:08 <Arahael> *other
16:58:19 <fosterite> AFAIK the last bastion of arrows was circuit design but new advances have been made
16:59:29 <Arahael> So I'm still stuck.
17:00:12 <fosterite> Arahael: Yampa uses arrows. that's not a flaw
17:00:33 <Arahael> fosterite: Right, is it still worth learning Yampa, though?
17:00:40 <fosterite> plus with arrows you can use the needle quasiquoter! http://scrambledeggsontoast.github.io/2014/09/28/needle-announce/ :D
17:01:40 <fosterite> Arahael: I'm not qualified to compare it to other FRP frameworks, sorry
17:01:53 <Arahael> fosterite: that's...  An insane quasiquoter. :)
17:02:27 <Arahael> fosterite: And actually seems to make more sense to me(!)
17:03:50 <ttt_fff> in haskell, does both pattern matching + type checking both reduce down to (1) generate set of constraints, and (2) run an unification algorithm?
17:05:08 <hpc> type checking is more or less that, pattern matching is simpler and more specific
17:05:56 <Arahael> fosterite: It strikes me that an editor would be well placed to support arrows.
17:07:42 <fosterite> Arahael: here's what it could look like with different syntax, courtesy of the subreddit http://imgur.com/vPWIl4B
17:08:03 <ttt_fff> does haskell now have arbitrary-rank types, or is it still limited to monomorhic type? (reading "practical type inference for arbitrary-rank types")
17:08:14 <fosterite> I think it would be a great fit for visual programming
17:08:28 <Arahael> fosterite: That's a nice one.
17:08:58 <Arahael> fosterite: One thing I'm struggling with, however, is trying to see why you'd use them over monads and functions - and how they actually represent an advantage.
17:09:08 <Arahael> fosterite: Especially in the context of game programming.
17:09:24 <fosterite> ttt_fff: RankNTypes has been around for a while. type inference for higher rank types is extremely difficult
17:09:31 <Arahael> The haskell.org/arrow page is very brief...
17:09:43 <Arahael> https://www.haskell.org/arrows/
17:09:54 <ttt_fff> fosterite: the paper I'm reading says that with programmer type annotations for the functions that are not monomorphic, it's very easy to check
17:10:00 <fosterite> Arahael: Arrows were sort of like an early stab at applicative
17:10:08 <fosterite> ttt_fff: that's not exactly inference then is it
17:10:24 <Arahael> fosterite: Applicatives, I think I understand. Monads, I definitely understand.
17:10:29 <fosterite> with annotations anything is easy to check
17:10:31 <ttt_fff> well, without annotations, it's supposedly undecidable
17:10:39 <ttt_fff> so yeah, that would fall under 'extremeley difficult'
17:10:56 <nshepperd> ttt_fff: yes, inference is hard, checking is easy
17:11:23 <ttt_fff> nshepperd: this is like "finding a solution to SAT is hard", "checking if an assignemnt satisfies SAT is easy"
17:12:49 <nshepperd> although I guess it's harder even than SAT if it's undecidable
17:12:53 <fosterite> Arahael: arrows mostly died, in part because proc notation isn't great 
17:13:23 <Arahael> fosterite: Is that the only reason?
17:13:31 <Hijiri> on top of it being hard to deal with outside proc notation
17:13:44 <hpc> also arr makes arrows necessarily limited to things (->) can do
17:13:44 <Hijiri> trying to fit things together, I mean
17:13:44 <Arahael> That's the same reason, isn't it?
17:13:59 <Hijiri> sort of
17:14:44 <fosterite> arrows don't map directly onto a concept for most people
17:15:11 <hpc> they're categories with more stuff
17:15:11 <Arahael> I'm strugglign to even find documentation that explains it properly.
17:15:32 <Arahael> And I'm someone who's _done_ electrical engineering. (Albiet first year - but this involves visual programming)
17:16:08 <nshepperd> Arrows are just kind of weird and restricted, yet not powerful enough
17:16:32 <Arahael> I wanto say: "Stop teasing me".
17:16:54 <nshepperd> arr makes the typeclass inapplicable to anything that can't contain arbitrary functions
17:17:13 <fosterite> also, you can do circuit layout type stuff with an appropriate monad
17:17:37 <nshepperd> Arahael: https://wiki.haskell.org/Typeclassopedia#Arrow ?
17:17:58 <fosterite> they're categories that have to be at least as powerful as (->)
17:18:50 <Arahael> I'll try and follow those later today. :)
17:18:58 <fosterite> which isn't very useful, because you want Category when you don't want arbitrary power
17:20:14 <Arahael> fosterite: The sole purpose of this is to understand Yampa.
17:20:23 <KaneTW> imo Arrows are very powerful
17:23:09 <fosterite> Arahael: the typeclassopedia is probably your best bet
17:23:25 <Arahael> Thanks,I'll go through that then.
17:24:34 <Arahael> It's taking a while for the loingo to get through to me...  I'm not a mathematician.
17:32:20 <toblerone> Anyone know how to use JSON instead of SafeCopy for serialization in acid-state? The readme mentions that you can, but I see no way to do this
17:38:49 <Lokathor> Do folks here use haskell-mode on emacs? Is there a way to make a tooltip appear when you mouse over a function, or maybe show in the info bar when the cursor is over a function?
17:39:10 <Lokathor> tooltip of the type signature, that is
17:40:10 <lalaland1125> Hi #haskell. I am writing my first Haskell program and I was wondering about the best approach for handling errors. I have read http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/, and it seems to present 8 competing options.
17:40:23 <lalaland1125> Has there been any consensus in the community since that blog post was written?
17:41:20 <Lokathor> what is the context?
17:41:30 <pacak> lalaland1125: Those methods are still valid, usually 1..4 are used.
17:41:36 <Lokathor> sometimes you need more or less error info
17:42:22 <lalaland1125> Right now at this point I only need string error messages. So I'll probably just go with #1.
17:43:07 <Lokathor> well
17:43:20 <kadoban> lalaland1125: "error" is pretty bad. If this is in any way real code, I'd avoid using it for anything that you ever expect to come up, under any circumstances.
17:43:23 <pacak> lalaland1125: When you use error you usually mean "I don't really  care about anything else after that".
17:43:27 <Lokathor> #1 has the downside that you can't handle the error until you get back to IO
17:44:06 <Lokathor> using "Either String a" is a better option if you want detailed messages
17:44:22 <pacak> If that's the case for  you - using error is fine.
17:44:48 <KaneTW> error is pretty much only fine if you write an executable and not a library and whatever you encountered is a fatal error
17:45:30 <lalaland1125> Good point. I'll go with Either then.
17:45:39 <lalaland1125> Thanks for the advice.
17:47:18 <Lokathor> note that Either is a monad, so if you've got several Either String a steps you bind them one after the other
17:48:00 <Lokathor> that's what #4 is talking about, kinda
17:48:12 <mauris> i think it's more precise to say that `Either a` is a monad?
17:48:31 <mauris> but that is still handwavey and informal so who's counting
17:49:07 <Lokathor> oh, right, Either a is a monad, so the monad part of Either String a is "Either String". The String being a part of it is locked in from step to step
17:49:16 <Lokathor> but the non-string part can change between steps
18:19:53 * hackagebot cabal-helper 0.5.3.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.5.3.0 (DanielG)
18:32:06 <clarkenciel> where is a good place to start with audio analysis and/or synthesis in haskell?
18:54:54 * hackagebot unit 0.1.0.0 - Aliases for ().  https://hackage.haskell.org/package/unit-0.1.0.0 (cxfreeio)
18:55:44 <arkeet> broken github links
18:57:23 <dipperswett> With Parsec, is there a particular idiomatic way to stick two "Parser String"s together to get something that does both parsers and returns the concatenated result?
18:57:44 <fosterite> liftM2 (++)
18:58:06 <dipperswett> That'll do it.
18:58:38 <dipperswett> What I actually want to do: grab one or more characters, where every character is a letter, digit, or underscore, and the first character is not a digit.
18:59:06 <fosterite> parsing variable names?
18:59:15 <dipperswett> Yep.
18:59:33 <Hafydd> I would just write (++) <$> parser1 <*> parser2.
19:00:33 <Hafydd> Or actually for that case, rather (:) <$> headParser <*> tailParser.
19:01:23 <fosterite> I don't remember the combinators but it's (++) <$> something ( == '_') <*> many (somethingElse (\x -> isLetter x || isDigit x || (x == '_'))
19:12:17 <johnw> you can also set up a tokenizer with parsec
19:12:26 <johnw> it has support for parsing things that are like programming languages
19:14:55 * hackagebot linearscan 0.9.0 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-0.9.0 (JohnWiegley)
19:14:57 * hackagebot linearscan-hoopl 0.9.0 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.9.0 (JohnWiegley)
19:16:44 <indiagreen> what do you think of my idea to make ‚Äúif c then x‚Äù (without ‚Äúelse‚Äù) equivalent to ‚Äúif c then x else mempty‚Äù? It would let people write stuff like ‚Äúif c then putStrLn hello‚Äù and it would Just Work
19:18:06 <indiagreen> and it also lets us have ‚Äúif c then [a]‚Äù instead of the non-obvious ‚Äú[a | c]‚Äù trick
19:19:09 <indiagreen> (the reason it would Just Work for IO is that starting from GHC 7.12 there's an instance for ‚ÄúMonoid a => Monoid (IO a)‚Äù)
19:19:33 <johnw> because we have: when c $ putStrLn "Hello"
19:19:34 <indiagreen> ...tho I wonder how well it would interact with the parser
19:28:15 <Hafydd> That seems pretty Dirty to to me: making a special case in the syntax for a certain type class.
19:28:44 <Hafydd> The appealing feature of if..then..else is that it's explicitly total.
19:29:17 <Hafydd> Ah, yes, and johnw's argument, of course.
19:29:31 <arkeet> :t when
19:29:32 <lambdabot> Applicative f => Bool -> f () -> f ()
19:39:56 * hackagebot apiary 1.4.4 - Simple and type safe web framework that generate web API documentation.  https://hackage.haskell.org/package/apiary-1.4.4 (HirotomoMoriwaki)
19:44:54 <ttt_fff> examples link on https://hackage.haskell.org/package/servant appears to be broken; anyone have a working link?
19:47:47 <fosterite> after doing the rounds of the ligature fonts, I have a question: is >>= supposed to look like something specific, or is it just supposed to evoke "into-ness"
19:48:24 <kadoban> ttt_fff: https://github.com/haskell-servant/servant/blob/master/servant-server/example/greet.hs
19:52:40 <ttt_fff> kadoban: thanks!
20:15:05 <ttt_fff> does parsec only work on string/Data.Text, or can it also work on things like sexps? so I have (1) Text -> Lisp Sexps, and (2) Lisp Sexps -> AST; right now, (1) is via Parsec, (2) is adhoc, and I'm wondering if I can do (2) via Parsec as well.
20:17:48 <c_wraith> ttt_fff: Text can work over any token type, but it has lots of helper funcs for text-like things
20:17:55 <c_wraith> ttuegel: err, *parsec* can
20:18:12 <ttt_fff> c_wraith: so you're saying parsec works over [a] for any a
20:18:24 <ttt_fff> sexps are a bit weird in that the a's are recursive rather than "a unit"
20:24:58 * hackagebot linearscan-hoopl 0.9.1 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.9.1 (JohnWiegley)
20:24:59 <mindless_null> Parsec is a monad, isn't it? So you could run the parsec monad inside of the parsec monad for sexps and then call join, right?
20:25:50 <johnw> Parsec is pure, you can run it anywhere
20:28:28 <shachaf> No one said it wasn't.
20:28:46 <johnw> not sure what you're saying
20:34:36 <johnw> mindless_null: why wouldn't you just use the sexp parser directly, though?
20:35:52 <mindless_null> I was suggesting that join might be the solution to ttt_fff's problem of parsing a [sexp] recursively.
20:36:15 <mindless_null> Personally I wouldn't use sexpr's at all ;) But that's me.
20:37:57 <johnw> yeah, I think you're right about join being involved
20:38:12 <johnw> but I'd have to try it
20:39:58 <felixn> ttt_fff: I've used parsec to turn AST into VM representation, so you should be fine :D  I had the same issue where it was adhoc and messy at first, but then parsec cleaned it up
20:44:10 <johnw> mindless_null: I'm not so sure anymore
20:44:26 <mindless_null> Oh?
20:44:56 <johnw> the parsing is of the sexp, building the AST just operates on that value
20:45:11 <johnw> a "parser over sexps" is something different (although it's possible)
20:45:25 <johnw> so it would just be: parseSexp >>= buildAST
20:47:05 <mindless_null> Oh yah, I didn't mean join on the parseSexp to the buildAST function, I meant that buildAST might be implemented using join.
20:47:31 <jle`> was about to parameterize a function by a (forall a. a -> a) but then i was like oh wait
20:47:36 <johnw> it wouldn't be a parser, though
20:47:44 <johnw> it wouldn't need to have anything to do with Parsec
20:48:14 <johnw> it would probably even just be buildAST <$> parseSexp
20:49:04 <felixn> johnw: yea most likely, if it's already in a structured format and just needs to be translated all that's needed is a function
20:51:01 <tomberek> @anyone: I implemented the normalization for skew-monoidal categories from [http://arxiv.org/pdf/1406.2064v1.pdf]. Is this useful, how can it be more useful? You can see a working copy at: https://www.fpcomplete.com/user/tomberek/skew-monoidal
20:51:01 <lambdabot> Unknown command, try @list
20:51:07 <mindless_null> You can do the building up of the ast with a normal function, but ttt_fff was asking about using parsec to parse the sequence of items in a sexpr.
20:51:18 <mindless_null> Sort of a two-phase parsing setup
20:53:06 <ttt_fff> that;s right
20:53:07 <camm_v222> Hi guys. Usually, when I get errors about dependencies I get this message at the end "Dependency tree exhaustively searched." What does it mean? 
20:53:12 <ttt_fff> buildAST :: Sexp -> AST is sorta ugly
20:53:21 <ttt_fff> and I think parsec like backtracking might make it cleaner
20:54:09 <tomberek> by @anyone, i mean anyone in the room
21:20:00 * hackagebot linearscan-hoopl 0.9.2 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.9.2 (JohnWiegley)
21:30:01 * hackagebot diversity 0.7.0.1 - Return the diversity at each position for all sequences in a fasta file  https://hackage.haskell.org/package/diversity-0.7.0.1 (GregorySchwartz)
21:33:46 <slack1256> I got no credit card, but I already have a static blog on hakyll but no domain. What are my options for buying a domain?
21:34:15 <shachaf> Doesn't sound like a Haskell question.
21:34:31 <slack1256> you're right, going to -blah. Sorry
21:59:56 <lamefun> Is there a finite list type?
22:00:19 <liste_> lamefun so arbitrary size but not infinite?
22:00:28 <lamefun> Yes.
22:02:51 <lamefun> I want it to be clear from the type signature that my function only works with finite lists (it removes elements from the end of the list).
22:05:34 <jle`> lamefun: there's Data.Sequence
22:05:46 <Iceland_jack> lamefun: Datatypes like Seq or Vector are always finite, it's easy to create a new datatype that is a pair of a lists length + the list, but it's not worth keeping track of 
22:05:55 <jle`> with O(1) pattern matching from both front and the back
22:20:39 <jle`> what's the current preferred parser combinator library?
22:20:55 <jle`> i hear people using parsec, attoparsec, trifecta...
22:21:54 <Cale> jle`: Those are all good
22:23:15 <YellowOnion> I just upgraded to the new 64bit haskell platform, and now ghc refuses to find a c library that worked fine in 32bit ghc-7.8
22:23:43 <Cale> YellowOnion: Do you have the 64 bit version of the library installed?
22:23:46 <YellowOnion> yep
22:24:38 <YellowOnion> I'm following this guide: https://noamlewis.wordpress.com/2012/12/16/cabal-install-ftgl-on-windows-and-getting-exes-that-use-it-to-work/
22:24:58 <slack1256> do a ldd on the 64 bit ghc and see what happens
22:25:55 <Cale> hmm
22:27:04 <YellowOnion> ldd: C:\Program Files\Haskell Platform\7.10.2-a\bin\ghc.exe: Function not implemented
22:27:04 <Cale> They're telling you to put the binaries into syswow64, which is (confusingly) the location for 32 bit libraries. If you got the 64 bit versions of the DLLs, they should go into system32, because Windows makes no sense.
22:27:30 <slack1256> oh the prices of backwards compatibility
22:27:32 <jle`> Cale: any reason why i'd pick one or the other?
22:27:53 <jle`> syswow.  much system
22:28:17 <Cale> jle`: attoparsec is more for parsing binary formats and network protocols
22:28:27 <jle`> i see
22:28:36 <jle`> i'm going to be parsing source code
22:28:48 <YellowOnion> Cale, yeah I made some adjustments for the 32bit stuff, infact I got this working with ftgl.dll being in $CWD on the 32bit version.
22:29:53 <Cale> jle`: Parsec and Trifecta are more for parsing human readable stuff like source code.
22:29:55 <liste> 66666
22:30:17 <jle`> neat
22:30:26 <jle`> i've used parsec years ago so maybe it's time to try out trifecta
22:30:52 <Cale> Trifecta has a bunch of fancy stuff for producing colourful error messages which highlight relevant parts of source lines.
22:31:13 <jle`> is there much extra cost in writing the parsers for this?
22:31:20 <jle`> i guess fancy colors doesn't hurt
22:31:39 <Cale> I haven't yet tried Trifecta myself
22:32:10 <YellowOnion> maybe ghc is looking for flgl64.dll or something.
22:32:13 <jle`> i might as well try it out then :)
22:32:22 <jle`> this is just a personal project anyways so i have no deadlines
22:32:48 <Cale> I'd expect it to be very similar to using Parsec otherwise. It uses a bunch of type classes defined in the parsers package for the combinators, and they're the same names as used in Parsec pretty much.
22:33:11 <jle`> hooray
22:33:40 <jle`> i was a bit hesitant because there were some strong indicators that it would pull in lens
22:33:53 <jle`> oh, there it is
22:34:02 <Cale> It will pull in lens
22:34:03 <Cale> heh
22:34:06 <jle`> welp
22:34:47 <edwardk> wait, does parsers depend on lens? i don't remember
22:34:57 <edwardk> trifecta does, but i don't think parsers does
22:34:59 <jle`> lens is an explicit dependency of trifecta
22:35:05 <edwardk> trifecta does i know
22:35:06 <jle`> i'm trying out trifecta :D
22:35:09 <edwardk> ah
22:35:41 <edwardk> the error messages from trifecta are nifty, the scaffolding around getting it to fit into your project is a bit convoluted at times
22:35:54 <edwardk> but it mostly feels like 'parsec updated to work with monad transformers'
22:39:06 <jle`> well i don't really need monad transformers, i just wanted to use this need for a parser combinator library to try out something new
22:39:26 <jle`> but it looks like most parsers are written to be polymorphic over typeclasses from parsers anyway, right?
22:39:39 <jle`> so i could use the same parsers for both trifecta and parsec ?
23:10:10 * hackagebot streaming-bytestring 0.1.0.1 - Lazy bytestring done right  https://hackage.haskell.org/package/streaming-bytestring-0.1.0.1 (MichaelThompson)
23:10:12 * hackagebot streaming 0.1.0.9 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.9 (MichaelThompson)
23:11:04 <EvanR> 10000 roundhouse of streaming-bytestring chop
23:34:38 <yellow_apple> how are you doing?
23:35:45 <yellow_apple> amm
23:39:10 <yellow_apple> > IRC client for Emacs
23:39:12 <lambdabot>  Not in scope: data constructor ‚ÄòIRC‚ÄôNot in scope: ‚Äòclient‚ÄôNot in scope: data...
23:40:47 <yellow_apple> mda
23:52:35 <zcd> anyone using haskell-mode finding that haskell-process-type is missing cabal-repl?
23:53:48 <yellow_apple> there's no one here
23:54:32 <zcd> spooky
23:54:40 <slack1256> netsplits
23:55:10 <slack1256> there is a bizarro #haskell on some freenode servers where people are actually speaking of haskell-mode I am sure of it!
23:59:45 <liste> how about #haskell-emacs ?
