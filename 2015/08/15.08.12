00:00:10 <mniip> that's a mealy machine!
00:00:32 <gamegoblin> src/Data/Binary/Builder/Base.hs:193:37: Warning:
00:00:33 <gamegoblin>     In the use of `inlinePerformIO'
00:00:34 <gamegoblin>     (imported from Data.ByteString.Internal):
00:00:34 <gamegoblin>     Deprecated: "If you think you know what you are doing, use 'unsafePerformIO'. If you are sure you know what you are doing, use 'unsafeDupablePerformIO'. If you enjoy sharing an address space with a malevolent agent of chaos, try 'accursedUnutterablePerformIO'."
00:00:37 <gamegoblin> <<< died laughing when I read that
00:01:57 <concept> ski: so let's say I have a graph and I want to point at node depending on what event I have.  step :: Event ->  Node 
00:02:05 <ski> concept : anyway, if you have `MyState -> MyState' or `OtherInput -> MyState -> MyState', then you can often use function composition to pass on the versions of the state between the different "stages" of the computation
00:02:08 <ttt_fff> in vim, is there a way to do somethign to my code, where (1) lines are NOT indeneted, but (2) spaces are inserted so that "::" 's match up
00:02:28 <liste> ttt_fff try StylishHaskell
00:02:41 <liste> and filter thru it from vim with :!'
00:02:54 <ttt_fff> liste: https://github.com/jaspervdj/stylish-haskell ?
00:02:55 <ski> concept : for more complex cases, or if you need `MyState -> (MyState,OtherOutput)' or `OtherInput -> MyState -> (MyState,OtherOutput)' (as well), then you'd tend to either need to name all your intermediate states .. or use some abstraction to hide doing that
00:03:14 <liste> ttt_fff yeah
00:04:15 <ttt_fff> liste: if this doens't work, we're going to send ou through :!
00:04:28 <ski> concept : i'm not quite grasping your situation, but i suspect you'd pass the graph as an additional argument to `step' ?
00:04:45 <concept> ski: yes exaclty.. 
00:04:52 <ski> (and perhaps also as an additional result, in case you wanted also to "modify" it)
00:05:54 <concept> ski: if I passed my graph I don't have to worry about copying ?
00:08:09 <ttt_fff> liste: stylish-haskell = much dependencies; manyw ait
00:08:41 * hackagebot halive 0.1.0.7 - A live recompiler  https://hackage.haskell.org/package/halive-0.1.0.7 (lukexi)
00:09:18 <ttt_fff> whoa, https://github.com/lukexi/halive seems pretty badass
00:09:19 <ski> concept : in terms of implementation, if in-place mutation is disallowed, then one can't tell a difference (as far as behaviour is concerned) between copying or not, and therefore passing an argument typically just copies an address/pointer/reference
00:10:25 <fffej> Hi!  If I've got a type with multiple constructors with different args, is there a nice pattern I'm missing for writing Arbitrary instances?  Currently I just make a lot of construction lambdas and choose them from a list, but this feels yucky
00:10:40 <ski> concept : if you compute new versions in terms of the old ones, then commonly most of the structure can be shared between the old and the new, and so there's not that much copying cost there either
00:10:48 <ski> concept : does that help ?
00:12:04 <concept> ski : yes great discussion. One last question, is passing state explicitly every time, a replacement for ST Monad (or mutation in general ) or is just a matter or style, for instance I can't see how algorithms like QuickSort would be implemented using this style?
00:13:40 <Wizek> Good Morning! I have a JavaScript project, and would like to refactor it towards using Haskell or similar. How much of a headache is it to introduce GHC.JS or something similar to an existing codebase? I am also considering PureScript. Anyone has any experience with similar refactorings?
00:15:25 <ChristianS> Wizek: GHC.JS is quite heavyweight (at least 1 mb runtime or so), so PureScript might be better for practical purposes
00:15:26 <liste> fffej how about something like oneof [Foo <$> arbitrary <*> arbitrary, Baz <$> arbitrary]
00:16:11 <fffej> liste: that's much nicer (and I can't believe I didn't think of that!)
00:16:15 <fffej> liste: thanks!
00:16:33 <liste> yw (:
00:17:01 <liste> concept that's the mechanism behind State monad
00:17:14 <ski> concept : passing state around explicitly can become a pain (easy to mix up the different versions), if it happens overly much. that's why `State s' (as a monad, and as an applicative functor) was invented (to hide this state-passing behind a nice abstraction)
00:17:57 <liste> ST monad is just IO in disguise, so it has real mutation
00:18:11 <quchen2> IO is just ST in disguise.
00:18:48 <mniip> quchen2, IO is a specialization of ST
00:18:59 <quchen2> That's what I said. :-)
00:19:04 <ski> concept : conceptually, `ST s' can be thought of in a similar way (implicitly passing state). it differs in two ways, though : (a) you can construct *new* "mutable cells" of *any* type at any point; and (b) the implementation will use update-in-place (which is safe because old versions of the state can't be reused)
00:19:11 <concept> ski: Thanks, that was helpful, I can see that, I am going to read about state monad, if my case isn't painful I will pass states directly otherwise I will use the state monad.
00:19:17 <mniip> which due to less generality can be more specific in what you can do :)
00:19:19 <quchen2> And as for Quicksort, it's an in-place algorithm. You cannot do it in a mutation-free context. What you *can* do is implement it using a language that descibes these steps, which is what ST does.
00:20:39 <ski> concept : there's a concept called "uniqueness types" in the language Clean (or "uniqueness modes" in Mercury) that allows the system to keep track of whether there's only one reference to some structure, and in that case the compiler will automatically use update-in-place as an optimization. in this case we get it even without hiding state-passing behind an abstraction like `ST'
00:20:49 <mniip> or you could go fully functional and parametrize your quicksort by the monad
00:20:49 <ski> concept : however, Haskell doesn't have uniqueness
00:21:30 <mniip> quicksort :: Monad m => (Int -> Int -> m Ordering) -> (Int -> Int -> m ()) -> m ()
00:21:48 <quchen2> mniip: That's not Quicksort anymore. It's divide-with-pivot-and-sort-both-halves-sort.
00:22:10 <ski> mniip : you need a swap as well, or something like that
00:22:36 <ski> hm, or i suppose the `Int -> Int -> m ()' was that ?
00:24:58 <ski> concept : though a bit old, i think "What the hell are Monads?" by Noel Winstanley in 1999 at <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> is still a short simple introduction to a couple of monads
00:25:45 <ski> concept : it illustrates the kind of boilerplate code repetition that monads are designed to abstract away
00:26:30 <concept> ski: I think I understand what monads are, but I didn't have much practice. I will read that though.
00:27:09 <concept> ski: the link is broken
00:27:24 <ski> works here
00:28:04 <ski> (perhaps your client or terminal erroneously included one or two of the delimiting angle brackets in the URL ?)
00:28:14 <concept> ski: yes it's working now
00:28:33 <concept> ski: I understand the concept of monad in terms of join, return, and fmap
00:28:42 * hackagebot cabal-helper 0.5.0.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.5.0.0 (DanielG)
00:29:14 <concept> ski: I also see how this is useful for capturing side-effects.
00:30:13 <ski> i'd say "expressing effects", but fine
00:30:45 <concept> ski: well, expressing effect is more accurate
00:30:55 <ski> (*side*-effects being what Haskell doesn't allow. at all)
00:32:08 <bezirg> hi, I have a small question: i have an action   run = do lift print ... ; lift print .... ; :: StateT IO ()    . Is it always better (in performance) to combine these succesive lifts to a single lift? like run = lift $ do print; print.... ?
00:33:58 <concept> ski: so if my understand is "correct", a functor is a computaional contex, for example a Maybe functor is a type that can express failing, but functors alone don't capture the effect they are only a contex, so by adding join and reeturn operations we can be able to take the computational context evaluarte it and then mapping the result again to it's same category (endofunctor) so this way we can chain operations.
00:34:28 <ski> bezirg : normally it should be no worse, at least
00:34:37 <bezirg> ski: that's good enough :D
00:35:02 <quchen2> Maybe leave away the category/endofunctor part.
00:35:07 <bezirg> i did some profiling, and I saw a lot of lift calls
00:35:11 <bezirg> time profiling
00:35:25 <bezirg> so I was wondering if I could improve it that way
00:35:54 <bezirg> the thing is I have a lot of stacked monad transformers, and I think this is expensive :/
00:36:38 <quchen2> If push comes to shove, you should hardcode your own stack.
00:36:48 <quchen2> It's not modular at all, but gives you a performance boost.
00:36:56 <quchen2> Rarely necessary though.
00:37:53 <ski> concept : possible nitpick -- apologies if misplaced . "a functor is a computaional contex","a Maybe functor" suggests that maybe you think of *values* of type `Maybe T' (for some type `T') as being "a Maybe functor"; while really it's `Maybe' itself (together with the implementation of `fmap' for it, satisfying the two laws) that is the functor. similar remarks hold for monads
00:40:46 <ski> concept : a value of type `M T', where `M' is here any monad (like `Maybe') is often called a monadic action, or an `M'-action. one can very loosely think of it as a "computational `M'-context around `T'" (there need not be exactly one value of type `T' to be computed, depending on `M', and on the particular "context")
00:42:04 <ski> concept : it's also not clear to mean what you mean by "evaluate" in "take the computational context evaluarte it", nor the "mapping the result again to it's same category (endofunctor)" part. (perhaps you could try to elaborate on what you intended)
00:42:54 <EvanR> a (endo)functor from * -> * is a mapping from types to types which also preserves any operation on the source type by lifting it to an appropriate function on the target type
00:44:04 <concept> ski: with evaluate I mean (apply function to "M a" which takes "a" ).. map it as return the result value in the original context (using return)
00:44:23 <ski> concept : in any case, if you don't use `join' (or `(>>=)'), then if you try to compose several actions together, you may end up with something of type `M (M (..(M (M U))..))' (where `U' is some type). the outermost `M' represents the "first" action part to be executed "in the monad", and so on until the innermost one representing the last one before getting the "result" of type `U'
00:45:31 <ski> concept : so you see, you need `join :: M (M a) -> M a' to be able to "smash" these multiple layers of `M' in the type together to a single one. conceptually concatenating the "list of steps" to do at the layers that are "smashed" together
00:46:28 <ttt_fff> if only I can write haskell LOCs at the rate at which I write java code
00:46:30 <ttt_fff> i'd be so produtive
00:47:08 <concept> ski: back to your functor nitpick,  What I understand Maybe a along with fmap is a functor (Maybe for mapping categories) and fmap for mapping morphisms ..? 
00:49:41 <ski> (concept : btw, re the possible nitpick : i mentioned it because it's a reasonably common misunderstanding that beginners in here often seem to have)
00:50:47 <ski> concept : yes. `Maybe :: * -> *' is the object mapping part of the functor, while `fmap :: forall a b. (a -> b) -> (Maybe a -> Maybe b)' is the morphism-mapping part of the functor, in category-theory terminology
00:50:48 <quchen2> concept: a functor consists of two mappings, one for objects and one for morphisms. In Haskell, the type constructor (such as Maybe) is the object mapping, and fmap is the morphism mapping.
00:50:52 <bezirg> quchen2: ski: thanks
00:51:48 <ski> (concept : also, it's not `Maybe a', but `Maybe' alone that is (the object-mapping part of) the functor)
00:52:22 <ski> concept : if we imagine for a moment that we could write function composition in types, then we could write `M (M (..(M (M U))..))' as `(M . M . ... . M . M) U', and then we use `join :: (M . M) a -> M a' to merge two `M's separated by a composition `.' into a single `M'. one of the monad laws (associativity) then says that it doesn't matter in `M . M . M' whether we chose to do it in the grouping `(M . M) . M' or in the grouping `M . (M . M)'
00:52:24 <concept> ski: np, thanks, most of your comments made me re-evaluate my understanding.. even though I am not category expery by any means I think Bartoz Mileweski blog helped me get intuition eventhough they say category terms confuse beginners I found them quite helpful
00:52:51 <ski> concept : hm, cut off near end of ".. one of the monad laws (associativity) then says that it doesn't matter in `M . M . M' whether we chose to do it in the grouping `(M . M) . M' or in the grouping `M . (M . M)'"
00:53:11 <merijn> Whoo! Looks like brick might fix most of my annoyances with vty-ui :D
00:53:45 <ski> concept : so, under this view, `join' is for joining two (or more, by repetition) "layers" of `M' into a single one
00:54:31 <concept> ski: I see, I always think of join as flatten
00:54:33 <ski> concept : while `return' is for introducing a "dummy" layer, that acts as a neutral element to `join' (like how `0' is a neutral element to `+', and `1' a neutral element to `*')
00:57:00 <ski> concept : could you clarify "with evaluate I mean (apply function to \"M a\" which takes \"a\" ).. map it as return the result value in the original context (using return)", perhaps using an example ?
00:57:48 <ski> concept : .. the nice thing about thinking of `return' and `join' as above is that the three monad laws becomes easier to understand and remember
00:58:12 <nomeata> Is there a way to configure `~/.cabal/config` to make `cabal test` assume `--show-details=streaming` by default?
00:59:38 <merijn> ski: I always like to think of Kleisli arrows, (>=>) and return have a pleasing symmetry to monoids that is easy to remember, imo
00:59:50 <ski> yes, that's also nice
00:59:51 <merijn> Also stating the laws in terms of >=> and return is easier, imo
01:00:05 <quchen2> It's a symmetry to categories, not monoids.
01:00:13 <merijn> quchen2: It *is* a category
01:00:20 <quchen2> Exactly.
01:00:25 <quchen2> It *is not* a monoid. :-)
01:00:25 <ski> merijn : hehe, i've been pondering a syntax in which the other formulation would look as pleasing :)
01:00:32 <merijn> quchen2: And there's clearly a symmetry between categorial composition and monoids
01:01:04 <merijn> quchen2: Both are binary operations with an identity element and associativity, how is that not symmetry?
01:01:21 <concept> ski: I was talking about this   (>>=) :: m a -> (a -> m b) -> m b
01:01:46 <quchen2> I think talking about >=> as if it was monoidal in some way is misleading.
01:01:50 <mniip> 00:21:48 <quchen2> mniip: That's not Quicksort anymore. It's divide-with-pivot-and-sort-both-halves-sort.
01:01:56 <mniip> pretty sure that's a quicksort
01:02:01 <ski> concept : ok, i was beginning to suspect you were. but i was still unsure if you were simultaneously talking about `return :: a -> M a'
01:02:08 <merijn> concept: Personally I think >>= while having practical reasons (easy to use/implement in haskell) is not as theoretically nice
01:02:10 <mniip> the first argument is the test function, and the second argument is the swap function
01:02:28 <merijn> mniip: To me (I know opinions differ) it's not quicksort unless it O(n * log n) and in place
01:02:41 <concept> ski: would return be irrelavant here ?
01:02:49 <merijn> mniip: The typical haskell "quicksort" example is neither of those things
01:02:51 <quchen2> Quicksort is O(n^2) worst case.
01:03:01 <merijn> quchen2: I'm talking average case here
01:03:02 <mniip> merijn, it takes O(n log n) if given operations are unit time
01:03:07 <ski> concept : depends on what you wanted to say
01:03:24 <mniip> and it can be in place with a relevant monad and swap routine
01:03:41 <merijn> mniip: But then it's no longer the simple example usually trotted out
01:03:46 <ski> concept : surely you need `return' as an operation, regardless of whether you use `join' or `(>>=)' for composing multiple actions
01:03:58 <quchen2> merijn: Why isn't the "typical Haskell" one n*log(n)?
01:04:10 <mniip> merijn, we're not talking about "sort"
01:04:15 <mniip> we're talking about specifically quicksort
01:04:17 <concept> ski: yup, that what I was going to say, return is for chaining multiple binds, isn't it /
01:04:24 <merijn> quchen2: Every pivot you add an extra filter which I don't think is constant time
01:04:45 <quchen2> merijn: Hmm, because you have to traverse the list again and again. Maybe it's n^2*log(n) then?
01:04:47 <merijn> mniip: Maybe I'm inferring the wrong context :)
01:04:57 <ski> concept : `return' is for introducing a dummy/trivial action that represents doing no effect, before yielding a given result value
01:05:16 <ski> concept : `join'/`(>>=)' is for chaining multiple actions together
01:05:18 <mniip> merijn, fix your typechecker then :)
01:06:08 <merijn> concept: I prefer the definition of "(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c" and "return :: Monad m => a -> m a" where ">=>" is associative and "f >=> return = f = return >=> f" (i.e. return is left and right identity for >=>)
01:06:40 <ski> concept : consider `sequence :: [M a] -> M [a]' that can be used to "execute" all the actions in a list in order (more accurate is to say it composes the actions together, in order, into a compound action that, when later executed, will execute the individual ones in the order)
01:06:47 <merijn> mniip: Usually people pull out the one line "quicksort" in haskell, and I don't consider that one to be quicksort
01:06:56 <mniip> merijn, you're forgetting 'return (f x) = fmap f (return x)'
01:07:39 <arkeet> @free return :: a -> M a
01:07:39 <lambdabot> $map_M f . return = return . f
01:07:45 <ski> concept : it can be defined by `sequence [] = return []' and `sequence (act:acts) = act >>= \result -> sequence acts >>= \results -> return (result:results)'
01:07:46 <arkeet> it's free.
01:07:52 <mniip> merijn, you mean, 'sort (x:xs) = sort (filter (> x) xs) ++ [x] ++ sort (filter (<= x) xs)'
01:08:20 <merijn> mniip: You don't need that because "fmap f x = (\() -> x) >=> (return . f) $ ()"
01:08:24 <merijn> mniip: Yes
01:08:39 <ski> merijn : that is the naturality condition
01:09:07 <mniip> merijn, that's not quick
01:09:14 <merijn> mniip: Irrelevant
01:09:23 <merijn> mniip: It means you don't need a separate proof for fmap
01:09:32 <mniip> no I mean that sort isn't quick
01:09:43 <ski> concept : in the empty list case, we're supposed to compute an action, but we have no individual actions to run, so we use `return' to build a trivial one that, when executed, will do nothing before "yielding" the empty list
01:09:44 <merijn> mniip: Oh, getting conversations mixed up :)
01:10:05 <merijn> mniip: I know, hence my objection to it, but I was unsure what prompted the original conversation :p
01:10:29 <proteusguy> What is the actual minimum size of a practical runtime environment for haskell? In my case I'm under linux but I'm curious how small a "stand alone" haskell machine could actually get. (assume 32 or 64 bit processor)
01:10:44 <mniip> proteusguy, about a megabyte
01:10:54 <mniip> the executable size, that is
01:10:55 <ski> concept : the recursive case can be thought of as : first execute `act', then `sequence acts', then `return (result:results)' (which does nothing but yield `result:results')
01:11:08 <merijn> proteusguy: There's been a bunch of "standalone" haskell things
01:11:16 <merijn> proteusguy: Check out "House" and HaLVM
01:11:24 <proteusguy> merijn, oh? Thanx! I will. 
01:11:25 <mniip> ski, I prefer the 'liftM2 (:) x (sequence xs)'
01:11:27 <ski> concept : alternatively, it could be written `sequence (act:acts) = act >>= \result -> fmap (result :) (sequence acts)', without using `return'
01:11:38 <arkeet> sequence doesn't need the full power of monad though
01:11:46 <ski> mniip : i'm not sure whether concept has seen `liftM2' yet
01:11:46 <merijn> proteusguy: HaLVM runs directly in Xen, House was an attempt to make an OS in haskell
01:11:54 <proteusguy> Another question - why does haskell call their 'list' a list when it acts a lot more like a stack?
01:11:58 <mniip> arkeet, right, can get away with liftA
01:12:03 <arkeet> proteusguy: it's a linked list.
01:12:07 <proteusguy> merijn, did House ever work?
01:12:23 <merijn> proteusguy: Define work, it boots and runs code. I don't think anyone ever seriously used it
01:12:27 <mniip> proteusguy, it's a singly linked cons-cell-powered list
01:12:44 <merijn> Lisp has been using the same style list as haskell since like the late 1950s
01:12:49 <quchen2> proteusguy: Historical reasons. "Stack" would be just as wrong because a stack is an abstract data type.
01:12:54 <proteusguy> arkeet, I understand it's implemented like a linked list but that's not the exposed interface is it? Seems to be limited to the interface of a stack with the ability to offset index it.
01:13:00 <merijn> If anything, any language that's using a list different from haskell's is weird
01:13:00 <quchen2> "List" on the other hand is a singly linked list.
01:13:03 <concept> ski: I think I need sometime to digest all you said
01:13:13 <ski> concept : np, take your time
01:13:15 <merijn> proteusguy: How is that not the exposted interface?
01:13:27 * quchen2 doesn't think "list" is a bad name either
01:13:28 <merijn> proteusguy: What kinda features would you expect lists to have?
01:13:32 <ski> concept : if there's anything you'd want elaboration on, do tell
01:14:20 <proteusguy> merijn, I'd expect a singularly linked list to easily insert items into the list. I'm recently re-newing my haskell exposure but this doesn't seem to be a common operation but I could be mistaken.
01:14:35 <mniip> proteusguy, it's easy to insert items into
01:14:43 <quchen2> > 'h' : "ello" -- Insertion
01:14:44 <proteusguy> merijn, I'd also expect to be able to add things to the end of a singularly linked list.
01:14:45 <lambdabot>  "hello"
01:14:49 <mniip> but you have to "traverse" to your target position first
01:15:01 <ski> > insert 'd' "abce"
01:15:03 <lambdabot>  "abcde"
01:15:07 <arkeet> proteusguy: you can't do that without mutation.
01:15:10 <mniip> proteusguy, here's the problem
01:15:13 <mniip> haskell values are immutable
01:15:27 <arkeet> unless you copy the entire list.
01:15:37 <ski> > "abcd" ++ ['e'] -- adding things to the end of a singularly linked list
01:15:40 <lambdabot>  "abcde"
01:15:43 <merijn> proteusguy: You can't insert in haskell because lists are immutable
01:15:46 <mniip> if you add something to the end, you end up changing the last cons cell
01:15:54 <merijn> proteusguy: All values are immutable
01:15:55 <mniip> which means you have to change the one begore it also
01:16:06 <mniip> and so you end up re-making the whole list
01:16:12 <proteusguy> merijn, which is why I feel the interface that the haskell list exposes is more closely related to a stack than a list.
01:16:15 <merijn> proteusguy: So "inserting" into a list means "making a new list consisting of part of the old list"
01:16:19 <mbrock> (the common types of linked lists in e.g. C don't keep track of the end pointer as far as I know)
01:16:25 <proteusguy> merijn, yes I get that.
01:16:25 <mniip> proteusguy, "exposes" ?
01:16:50 <mniip> you think there is some hidden interface below what you see?
01:16:50 <merijn> proteusguy: Stacks don't let you access any element other than the top
01:17:03 <proteusguy> mniip, no that's not what I mean.
01:17:08 <quchen2> proteusguy: One use case of lists is to use them like a stack implemented via a singly linked list, yes. There are other uses though, such as viewing them as loops.
01:17:11 <arkeet> merijn: sure they do. just pop repeatedly.
01:18:17 <proteusguy> quchen2, does viewing them as loops require some capability beyond what a normal stack would offer?
01:18:25 <arkeet> anyway, the point is that a stack is an abstract data type.
01:18:35 <arkeet> it specifies an interface (push and pop), but nothing about implementation.
01:19:15 <quchen2> proteusguy: No.
01:19:32 <quchen2> proteusguy: Similarly, viewing them as stacks requires no capabilities over viewing them as loops.
01:19:45 <arkeet> I have no idea what a "loop" is, though.
01:19:48 <proteusguy> arkeet, that's not strictly true. a machine stack happens to be an array of data values which can be offset indexed and also commonly has a push and pop operation as well.
01:20:10 <quchen2> proteusguy: The correct view of a list is that it's either empty or an element with another list attached to it. The rest is interpretation.
01:20:15 <catofhask> hi, what are ossibilities that modifyTvar' hangs up indefinitely ?
01:20:26 <quchen2> arkeet: A formal definition of "loop" is subject to further research. :-)
01:20:36 <arkeet> even informally.
01:20:43 <merijn> catofhask: Keeps getting an exception/conflicting with another transaction?
01:20:55 <merijn> catofhask: And/or keeps evaluating to retry
01:20:58 <mniip> arkeet, a constant space infinite list, like one produced by 'cycle'
01:20:59 <joco> what is the easiest way to install ghc 7.8.4 to ubuntu 14 ? is this a good way  https://launchpad.net/~hvr/+archive/ubuntu/ghc ?
01:21:08 <quchen2> arkeet: When you coinductively construct a list and then walk over it that's what you would solve elsewhere with a loop.
01:21:28 <quchen2> Corecursively? Co-something.
01:21:38 <arkeet> joco: yes
01:21:43 <catofhask> merijn: I have a trivial transaction where it modifies a map TVar -  modifyTVar' m $ M.insert (producerId e) (seqNum e)
01:22:02 <joco> arkeet : thanks - then i give it shot
01:22:22 <catofhask> merijn: I am not getting any exception. I don't see why it should retry the transaction as well
01:22:25 <merijn> catofhask: Is anything else concurrently access that tvar?
01:22:39 <proteusguy> all: thanx for your patience with my questions. I'm not trolling. I'm very interested in langauge design and have a strong background in languages like C++, forth, python, erlang. Haskell has some interesting similarities to forth but with a type system as strong (stronger?) than C++ all while being truely functional yet still useful. So these are quite promising aspects I want to explore deeper. To me, however, the haskell
01:22:40 <proteusguy>  list operates like a stack more than a list in the classic sense so I'm curious as to the history of how it came to be called this or whether I'm just missing something that makes it non-stack-like.
01:23:05 <merijn> proteusguy: Do you consider Lisp lists to be stacks too?
01:23:21 <merijn> proteusguy: Or in general C linked lists?
01:23:31 <proteusguy> merijn, no as they are mutable as the C style lists.
01:23:39 <catofhask> merijn: not of my knowledge 
01:23:40 <quchen2> proteusguy: One thing that distinguishes Haskell lists from stacks is that stacks usually have an end. Haskell lists don't necessarily.
01:23:45 <quchen2> > cycle "hello "
01:23:47 <lambdabot>  "hello hello hello hello hello hello hello hello hello hello hello hello hel...
01:24:14 <merijn> proteusguy: For example, is this a list or not? "struct linked_list { void *element; const struct linked_list const *next; };" 
01:24:16 <arkeet> quchen2: I would still call it a list in a strict language.
01:24:23 <mniip> proteusguy, here's an analogue
01:24:31 <arkeet> where infinite lists don't exist.
01:24:32 <rlewis> stack is usually mutable in C as well
01:24:37 <mniip> imagine a linked list where next element pointer is a const pointer
01:24:39 <merijn> I guess I should've made that "void const *"
01:24:48 <proteusguy> quchen2, most stacks I deal with don't have formal ends unless you add it as a protection against overflows. Typically you just start writing over someone else's memory.
01:24:49 <merijn> or is that "void * const"? I forget...
01:24:57 <mniip> meretrix, void const * or const void *
01:24:58 <keko_> proteusguy: the haskell list totally seems like a list to me, but maybe your "list" is my "array"
01:25:19 <quchen2> arkeet: Depends on what you mean with infinite. A cyclic list is arguably both.
01:25:55 <mniip> proteusguy, are we talking about C++ std::stack?
01:25:57 <proteusguy> keko_, don't you find that the vast majority of your operations against haskell lists are dealing with the top item? This smells stackish to me. :)
01:25:59 <arkeet> quchen2: you can't observe whether a list is cyclic. 
01:26:07 <Unhammer> a circle is infinitely long? =P
01:26:07 <quchen2> arkeet: You can in C.
01:26:13 <arkeet> quchen2: you can do a lot of things in C.
01:26:14 <merijn> mniip: No, I meant "void * const"
01:26:24 <merijn> mniip: Should've been "* const next" too
01:26:31 <proteusguy> mniip, not necessarily.
01:26:32 <mniip> merijn, constant pointer to a mutable void?
01:26:46 <quchen2> arkeet: I just meant to say that in C, you might call a cyclic list infinite because there's always a next element, yet you can find out how many unique elements are in there, making it finite.
01:26:49 <keko_> proteusguy: not really
01:26:53 <merijn> mniip: Sure, why not :)
01:27:01 <keko_> it's usually the entire list, in order
01:27:05 <mniip> proteusguy, what you talked above sounds a bit like the naive array stack
01:27:15 <arkeet> "stack" is an abstract data type, a specification of an interface. "linked list" is a concrete data structure, which is one of many possible implementations of "stack".
01:27:27 <arkeet> a [] list in haskell is a concrete data structure.
01:27:56 <proteusguy> mniip, yes but with push & pop operations and you don't manipulate the contents of the list, only (possibly) the "top" item which in fact is really changing the top item of the list.
01:28:06 <arkeet> it is data, not operations.
01:28:12 <keko_> to me, "list" means a linked list, and "array" means a C-style array
01:28:23 <keko_> and "sequence" is the generalization
01:28:31 <proteusguy> keko_, I would tend to agree with those two statements.
01:28:36 <mniip> proteusguy, do you know how to map a function over a stack?
01:28:41 <mniip> recursively I mean
01:28:41 <proteusguy> keko_, so what is your definition of a stack?
01:29:21 <frerich_> proteusguy: To me, a 'stack' is an abstract data type with a couple of operations like 'empty' or 'push' or 'pop' (but not much more than that). A linked list is a data structure with a very precise definition of how data is stored (but with a wider range of plausible operations). Isn't std::stack even a container *adapter* which is implemented in terms of list or so?
01:29:45 <arkeet> frerich_++
01:29:51 <catofhask> merijn: http://lpaste.net/3205590481077534720
01:30:02 <frerich_> proteusguy: E.g. mapping a function over a list or an array seems like a very natural thing to do, but mapping a function over a stack of things? Not so much.
01:30:05 <proteusguy> mniip, sure I would pop content until it was empty and apply the operator to each item as it was taken off the top of the stack. Do this in forth all the time.
01:30:08 <keko_> proteusguy: not sure, but it would probably involve O(1) push/pop
01:30:44 <catofhask> merijn: A bit simplified...
01:30:50 <mniip> prophile, map(f, s) { if(!s.empty()) { x = s.pop(); map(f, s) s.push(f(x)); } }
01:31:13 <ski> itym ..
01:31:14 <proteusguy> keko_, sure - and doesn't that make you feel that the haskell list behaves more like a stack than the classic list?
01:31:26 <mniip> we split the list into the top element and the rest, and then perform operations on the rest, as well as the top element
01:31:30 <mniip> and then combine them again
01:31:37 <mniip> that's how lists are processed in haskell
01:31:43 <arkeet> lists behaves like stacks if you define stack operations on lists.
01:32:02 <merijn> catofhask: No idea, tbh
01:32:20 <rlewis> proteusguy that would reverse the stack
01:32:26 <proteusguy> mniip, but the list is immutable so aren't you just referencing a list that starts at the next beginning place each time? This is identical to how a stack in your cpu is implemented.
01:32:30 <arkeet> I can also make arrays and balanced binary trees and whatever unsuitable structures also behave like stacks.
01:32:40 <catofhask> merijn: Ah, thanks
01:32:42 <arkeet> that doesn't make them stacks.
01:32:47 <mniip> a stack in my CPU is a memory region
01:32:54 <joco> what is the easiest way to get a recent cabal on ubuntu 14 ?
01:33:02 <joco> compile it myself ?
01:33:05 <mniip> which is basically an array with a pointer explaining where the 'end' is
01:33:24 <joco> which is the best option from here ? https://www.haskell.org/cabal/download.html
01:33:45 * hackagebot tianbar 0.4.8.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-0.4.8.0 (AlexeyKotlyarov)
01:33:47 <mniip> proteusguy, map (x:xs) = f x:map f xs
01:33:52 <mniip> xs refers to the rest of the list
01:34:02 <mniip> map f xs, however, is a different list
01:34:12 <mniip> than s
01:34:15 <mniip> than xs*
01:34:25 <keko_> proteusguy: no, because to me a classic list is the lisp-style list made of cons cells, whick is what haskell has
01:35:04 <arkeet> mniip: tbh I don't see how mapping is relevant.
01:35:31 <proteusguy> arkeet, my perspective isn't about what you *can* do with the data structure that haskell calls a list, it's more to do with how it's general usage model behaves. In my, still early, experience with haskell, it feels a lot more like I'm using a forth stack than a C++ const list. I'm trying to find common examples where I'd say, "No - that acts more like a list and is something I couldn't normally do with a stack." Cause rig
01:35:31 <proteusguy> ht now there are things I'd expect to be able to do with a classic list that I really can't do with the haskell one. Thus my curiosity about the choice of terms "list vs stack".
01:35:39 <mniip> arkeet, I've figured out what he means by working with only the top element, and I'm trying to explain how to work with the whole list using just that
01:35:55 <quchen2> joco: I use this script to quickly create a VM for a workshop. It downloads GHC binaries and compiles Cabal from source. http://lpaste.net/138575
01:36:06 <joco> quchen2: thanks
01:36:08 <mniip> proteusguy, it's not a const list
01:36:16 <mniip> it's a list where all internal structures are also const
01:36:32 <proteusguy> mniip, sure - but doesn't change my point.
01:36:51 <mniip> so, const struct { void const *head; void const *tail; }
01:37:02 <quchen2> joco: Depending on your machine it should run in 10 minutes.
01:37:08 <quchen2> And internet connection of course.
01:37:12 <mniip> that is still a linked list
01:37:22 <mniip> but it mimics exactly what haskell has to deal with
01:37:22 <ReinH> quchen2: why not use the PPA ghc and cabal packages?
01:37:28 <joco> quchen2: I have ghc 7.8.4 now, so I only do the cabal part
01:37:42 <concept> ski: I can see the sequence example but why would sequence need a Monad ?
01:37:44 <proteusguy> So my working conclusion thus far is that haskell calls their "very closely resembling a stack" data structure a list because it's just like the lisp list except immutable. Would that be a fair judgement?
01:37:44 <joco> ReinH: Is there cabal ppa ?
01:38:01 <quchen2> ReinH: I'm not aware of a PPA that lets me choose versions that easily.
01:38:10 <arkeet> basically I'm saying "stack" isn't a data structure.
01:38:17 <ReinH> quchen2: https://github.com/freebroccolo/docker-haskell/blob/master/7.10/Dockerfile#L11
01:38:23 <joco> https://launchpad.net/~hvr/+archive/ubuntu/ghc
01:38:24 <ski> concept : an idiom / applicative functor is enough, but they weren't invented when `sequence' was defined
01:38:24 <proteusguy> arkeet, hahaha I'd have to disagree.
01:38:28 <joco> this is good !
01:38:33 <ReinH> or https://github.com/freebroccolo/docker-haskell/blob/master/7.8/Dockerfile#L11
01:38:35 <mniip> proteusguy, you're pretty much correct, however in haskell we don't "pop" or "push"
01:38:38 <edk> proteusguy, it's called a list because a list is the data structure that it is
01:38:39 <joco> thanks for the tip ReinH
01:38:41 <mniip> we cons, and pattern match on consing
01:38:57 <ReinH> A stack isn't a data structure, it's an interface.
01:39:17 <edk> (that could be implemented using a list or other data structures)
01:39:26 <proteusguy> mniip, right - haskell's operations on "stacks" are cleaner and more implicit than the direct mechanics of a forth or machine stack.
01:39:34 <concept> ski: I was looking at liftM I don't see why it's useful ?
01:39:37 <ttt_fff> ping
01:39:52 <ttt_fff> what are the obstacles to adding per green thread heap to haskell? (i.e. erlang style)
01:39:55 <concept> ski: it looks like fmap but for Monads
01:40:03 <arkeet> concept: it is.
01:40:05 <proteusguy> edk, I like your recursive definitions. befits a language like haskell but not satisfactory when discussion language design semantics. ;)
01:40:10 <ReinH> ttt_fff: probably a complete redesign of the RTS threading system.
01:40:14 <frerich_> proteusguy: I think what arkeet meant is that a 'stack' is an abstract description of a data type with a couple of operations (push/pop/empty/size). There's no notion of how that is implemented in a computer. In fact, a wide range of data structures can be used to implement a stack. In this sense, a data structure is something with a precise definition of storage or layout in memory - and a data type (e.g. stack) is a definition of a set of 
01:40:14 <frerich_> ations and their semantics.
01:40:14 <mniip> concept, it is fmap with a monad constraint
01:40:15 <quchen2> concept: It used to be useful when Functor wasn't a superclass of Monad. Now it is, so liftM is almost redundant.
01:40:20 <ski> concept : `liftM' is (should be) the same as `fmap'. `liftM2' is useful (but really should belong to applicative functors, not monads)
01:40:25 <mniip> thanks to monad laws it is guaranteed to behave the same
01:40:36 <arkeet> concept: (1) historically, Functor wasn't a superclass of Monad. so liftM was the thing to use when all you had was a Monad constraint.
01:40:48 <edk> proteusguy, it's not recursive. haskell's list type is named after the list data structure
01:40:55 <frerich_> proteusguy: ...which would be consistent with what e.g. C++ does -- it has no std::stack container (like std::list or std::vector) but a container adaptor such that you get the stack operations implemented in terms of some specific container.
01:41:01 <mniip> historically? heh, many distributions still ship 7.8.4
01:41:02 <rlewis> proteusguy what is your objection in calling it a list? the fact that it is immutable? something else?
01:41:07 <edk> proteusguy, it's not named after the stack data structure because a stack is not a data structure
01:41:09 <arkeet> (2) "fmap = liftM" is a convenient definition to make for a Functor instance when you already defined the Monad operations.
01:41:12 <proteusguy> frerich_, I understand his meaning and agree with your interpretation but it isn't actually responsive to the point I was making in that the same could be said for the 'list'.
01:41:35 <ReinH> It's pretty simple
01:41:39 <arkeet> so, now that Functor really is a superclass of Monad, redefining "liftM = fmap" would break any such definitions.
01:41:43 <ski> frerich_ : ".. - and a data type (e.g. stack) is a definition of a set of"
01:41:46 <mniip> it's burritos all the way down
01:42:06 <ReinH> A list in Haskell is data [a] = [] | : [a]
01:42:10 <ReinH> It is not a stack.
01:42:13 <ReinH> There's nothing else to it.
01:42:25 <mniip> correction: data [a] = [] | a : [a]
01:42:27 <ReinH> er, data [a] = [] | a : [a]
01:42:35 <proteusguy> rlewis, I'm not objecting at all. I'm trying to understand it's context in terms of language design and checking to see if I was missing something about the haskell list that would disqualfy it from being considered a stack. I think what haskell has done with (what I consider) a stack data type is quite remarkable and elegant.
01:42:37 <ReinH> typo sorry
01:42:41 <frerich_> ReinH: Let's define it 'List a = Empty | Push a (List a)' :-)
01:42:44 <edk> proteusguy, a stack is anything providing a push and pop operation, it need not be implemented as a list
01:43:02 <frerich_> ReinH: Just for kicks.
01:43:15 <arkeet> proteusguy: it is very easy to use lists as stacks, but "stack" is something more general than any particular data structure.
01:43:19 <ReinH> proteusguy: It isn't a stack. It can be used to implement a stack.
01:43:36 <ReinH> Because, again, a stack is not a data structure. It is an interface.
01:43:41 <proteusguy> edk I never claimed otherwise. Please review the key question I posed. I'm more asking how is the haskell 'list' not more like a stack than what people from other languages would consider a "normal" list?
01:43:46 <mniip> frerich_, data Stack a = Push a (Stack a) | Pop (Stack a) :)
01:43:46 * hackagebot snap-web-routes 0.5.1.0 - Type safe URLs for Snap  https://hackage.haskell.org/package/snap-web-routes-0.5.1.0 (lukerandall)
01:43:53 <new_mind> well, a binary tree can be used to implement a list too, if you want to
01:44:00 <edk> proteusguy, it's exactly what a "normal" list is
01:44:00 <ReinH> proteusguy: It's a very direct way to implement a stack
01:44:05 <arkeet> haskell lists and cpu stacks are both "stacks", but they are nothing like each other.
01:44:09 <ReinH> but you continue to make a basic category error here
01:44:19 <quchen2> proteusguy: The confusion here is between abstract data types and concrete data structures. A stack is not a concrete data structure, it is "whatever as long as you can push and pop". A list is the concrete data type of "element and then another list".
01:44:49 <proteusguy> edk, except "normal" lists in most languages are not immutable. This fact changes the usage of the haskell list to more resemble the stack model. head == top of stack/ala pop.
01:44:55 <quchen2> std::vector is just as much of a stack as Haskell::list is.
01:44:56 <ReinH> Another implementation of a stack is an array an a stack pointer
01:45:04 <ReinH> this is definitely a stack, and also definitely not a list
01:45:11 <edk> proteusguy, "normal" integers in most languages are not immutable
01:45:20 <edk> proteusguy, the immutability is a feature of haskell, not its lists
01:45:50 <proteusguy> edk, true but I can change the n'th integer in a list to another value and this is not something a haskell list wants to do.
01:45:54 <ReinH> proteusguy: You can keep saying that a stack is a list is a stack, but saying it won't make it so.
01:46:05 <proteusguy> ReinH, I said no such thing.
01:46:10 <arkeet> proteusguy: that's a feature of haskell, not of lists.
01:46:17 <proteusguy> arkeet, agreed. :)
01:46:18 <rlewis> proteusguy in most languages stack is not immutable either
01:46:27 <mniip> [10:43:27] <proteusguy> edk, true but I can change the n'th integer in a list to another value and this is not something a haskell list wants to do.
01:46:27 <new_mind> proteusguy: its something no immutable list _can_ do, but you can just create another modified list with the changed value
01:46:37 <frerich_> proteusguy: I think that indeed, in many cases when people talk about 'lists', they mix the data structure 'singly-linked list' with the generic data "type"  (i.e. the interface, the set of operations) which permit iteration, getting the length, getting the n'th element in O(n) etc.
01:46:46 <proteusguy> rlewis, that's very true but most correct usages of those stacks is to only operate on the top item.
01:46:46 <mniip> [10:43:27] <proteusguy>  <...> I can change <...>
01:46:51 <mniip> here's your problem :)
01:47:38 <proteusguy> rlewis, that restriction of only operating on the top item effectively considers the rest of the stack immutable (albeit not enforced of course as haskell does).
01:47:41 <frerich_> proteusguy: I believe that to a certain degree, you can certainly identify a data type (an 'interface') "list" much ilke "stack" based on the observation that there's a conventional set of operations which people expect to be able to do on list'ish data structures.
01:47:54 <edk> proteusguy, lists have that restriction
01:48:26 * frerich_ senses he has a poor signal/noise ratio and shuts up :-]
01:48:38 <ReinH> I'm not sure what thinking of Haskell's lists as being "like stacks" buys you, aside from indirection.
01:48:38 <edk> proteusguy, for e.g. in C, i would assume a "list" is a linked list (which is essentially what haskell's lists are like). the elements would be mutable, because almost everything in C is mutable by default. you can only perform operations on top of those, too (but of course you can iterate to get a new top to operate on, as in haskell)
01:48:43 <sgronblo> Is there some theoretical or practical limit to how deep you can make your ADTs? As in will data CoolNumber = One | Two | Three | ... | OneGazillion cause a Haskell program's performance to suffer?
01:48:51 <proteusguy> If I were to put the haskell 'list' on a scale where one end was List and the other was Stack I think it would lean towards the stack end. :-) I think that's really the only point I'm making here and I'm curious to know what would make it lean the other way that perhaps I missed out on with my limited exposure to haskell.
01:49:01 <edk> proteusguy, they are *different kinds of thing*
01:49:05 <ReinH> proteusguy: There is no such list
01:49:05 <mniip> sgronblo, I believe machine word size is the only limit
01:49:09 <merijn> sgronblo: The practical limit is "when GHC starts to crap out"
01:49:28 <mniip> sgronblo, as long as dataToTag# works
01:49:41 <new_mind> edk: you got me curious: what _isn't_ modifiable in C?
01:49:59 <edk> new_mind, the storage of string literals, any object defined with a const-qualified type
01:50:00 <ski> new_mind : string literals ?
01:50:02 <proteusguy> ReinH, it doesn't bug me at all. I'm trying to see if I missed something about the haskell list that I wasn't aware of. It seems I did not.
01:50:04 <merijn> mniip: That's not required AFAIK
01:50:06 <mniip> ski, you think so?
01:50:12 <arkeet> you know what else is a stack? an append-only list of push and pop instructions.
01:50:15 <mniip> new_mind, behavior of ;
01:50:15 <ReinH> If you were to put apples and screwdrivers on a scale, which end do you think apples would be at?
01:50:18 <arkeet> (as a data structure.)
01:50:18 <merijn> mniip: Because AFAIK there's no guarantee dataToTag# works on all datatypes
01:50:19 <ReinH> That's what you sound like right now ;)
01:50:27 <arkeet> arguably this is the most stack-like data structure.
01:50:59 <proteusguy> ReinH, sorry you think that. 
01:51:16 <mniip> sgronblo, I don't think GHC will "start to crap out" on such datatypes
01:51:26 <proteusguy> arkeet, sure.
01:51:32 <ReinH> We've been going at this for a while, we've repeatedly said that lists and stacks are different kinds of things, and you keep wanting us to compare them as if they weren't.
01:51:38 <edk> proteusguy, a list is a data structure, a stack is an interface. a list is a viable *implementation technique* for a stack, it is not *like* a stack
01:51:48 <merijn> proteusguy: His point is, as has been made multiple times that lists are A CONCRETE IMPLEMENTATION whereas stacks are AN ABSTRACT INTERFACE
01:52:05 <rlewis> string literals in C are immutable in a sense that mutating them results in undefined behavior (and actual behavior in practice can range from segfault to mutating the string without any issues)
01:52:09 <merijn> proteusguy: The fact that said concrete implementation maps nicely to said abstract interface is a coincidence
01:52:13 <proteusguy> ReinH, then you did completely misunderstand what I said - i'm starting to think willingly now. Thanx anyway
01:52:14 <sgronblo> mniip: Ok, good to know. Thanks.
01:52:22 <MrMeowMeow> lol
01:52:26 <ReinH> proteusguy: No, I'm just listening to you.
01:52:31 <ReinH> You're the one that hasn't been listening to us.
01:52:44 <proteusguy> merijn, if you're trying to be pedantic then you should say singularly-linked lists.
01:52:55 <arkeet> it would be inappropriate to give the name "stack" to any data structure.
01:52:56 <ReinH> Well, if this was ever productive, it definitely isn't now
01:53:01 <mniip> sgronblo, implementation wise, sum types are an integer tag, with a union of the contained data
01:53:05 <arkeet> (except perhaps the one I just defined.)
01:53:15 <proteusguy> ReinH, I'm talking about the usage of the data structure that haskell calls a list. USAGE. 
01:53:18 <arkeet> (which maybe I'd call "free stack")
01:53:23 <merijn> proteusguy: I'm not trying to be pedantic, I'm trying to point out your thought mistake. If you insist that interfaces and implementations aren't different this conversation is useless and I'm wasting my time
01:53:31 <quchen2> proteusguy: ReinH wasn't pedantic, he was correcting a mistake. That's different from narrowing down a definition. Calling a singly linked list "a list" is inaccurate, callint it a stack is *wrong*.
01:53:33 <mniip> sgronblo, so, Just "hello" is {1, "hello"} whereas Nothing is {0}
01:53:44 <merijn> mniip: This is not actually guaranteed anywhere
01:53:47 <ReinH> proteusguy: And yet you keep saying things like "a scale with lists one one side and stacks on another"
01:53:54 <mniip> merijn, that's why I said implementation wise
01:53:57 <edk> quchen2, possibly it is imprecise, it's not inaccurate
01:54:02 <merijn> mniip:Not even then
01:54:05 <mniip> we're talking about a specific compiler here right
01:54:29 <quchen2> edk: "Stack via list" would be right.
01:54:30 <merijn> mniip: The STG paper explicitly mentions optimisations that do not use tagging, which AFAIK have been used (and may still be in use) in GHC
01:54:46 <quchen2> mniip: "The STG paper"? You mean the 1992 one?
01:54:47 <edk> quchen2, i mean calling a singly-linked list a list
01:54:53 <ReinH> Basically, we're just talking past each other at this point, and have been for some time.
01:55:00 <quchen2> edk: Oh.
01:55:11 <mniip> merijn, unless you mean cases where you know the tag statically, I'm not sure what you're talkign bout
01:55:15 <mniip> talking about*
01:55:17 <merijn> mniip: There is no guarantee as far as I know (and I've done my research asking in #ghc because I wanted this!) that you can obtain an Int# tag for a datatype
01:55:18 <proteusguy> merijn, I'm happy to modify my speech to fit the structure you'd like to impose on it. What interface would you call what is naturally exposed by the concrete data structure called a list?
01:55:24 <quchen2> merijn: The fast curry paper throws much of the original paper overboard, so maybe cross-check with that one
01:55:43 <Sindriava> edk: I'd think that "List" is an interface, not an implementation
01:55:47 <ReinH> proteusguy: it exposes contructors [] and (:).
01:55:48 <merijn> proteusguy: There isn't a single interface, it matches multiple interfaces including stacks, sequences, optional values
01:56:05 <proteusguy> Sindriava, I agree. :) Especially when the conversation is about usage, not implementation.
01:56:13 <merijn> proteusguy: So the question "which interace does it expose" is silly, because it confirms to multiple ones
01:56:37 <edk> the conversation is about Lists, which *are* an implementation. the conversation can't help but be about implementation
01:56:50 <merijn> quchen2: I read that one too, but that mostly redoes function application/currying
01:57:09 <merijn> quchen2: AFAIK it doesn't touch case-of at all, therefore shouldn't affect any optimisations relating to case-of
01:57:20 <proteusguy> merijn, it's not silly at all. Without an interface it isn't useful. EVERYTHING is an abstract data type once it gets used. My entire question has been about usage yet people focus on implementation details that aren't strictly relevant.
01:57:32 <arkeet> many uses of lists don't refer to any stack operations on them.
01:57:33 <ReinH> The interface is [] and (:)
01:57:35 <ReinH> That's it.
01:57:39 <arkeet> concatenation, mapping, folding, etc.
01:57:41 <mniip> the interface haskell's list exposes is: create an empty list, create a list of an element prepended to a given list; check if list is empty, take apart a non-empty list producing the front element and the rest of the list
01:57:45 <dramforever> foldr
01:57:48 <mniip> all other functions re implemented on top of that
01:57:50 <merijn> proteusguy: "everything is an abstract datatype"? <- that's patently false, haskell lists are very clearly not abstract datatypes
01:57:51 <quchen2> merijn: Probably. But since it corrected so many things I thought held true for the 1992 paper I'm now very careful to talk about it :-)
01:58:00 <quchen2> s/for/in/
01:58:15 <ReinH> If you want to talk about usage for haskell lists, here it is: you use [] and (:).
01:58:16 <proteusguy> merijn, everything you touch on a computer is an abstraction. sorry.
01:58:18 <ReinH> Again, that's it.
01:58:19 <merijn> quchen2: The specific thing I'm referring to is that you can compile pattern matching to branching on tag OR jump table
01:58:23 <merijn> I'm out
01:58:28 <merijn> This conversation is pointless
01:58:39 <mniip> point-free*
01:58:39 <ReinH> merijn: Everything is pointless relative to something.
01:58:48 <merijn> ReinH: "f x = x" isn't ;)
01:58:52 <quchen2> ?pl \this conversation -> this conversation
01:58:53 <lambdabot> id
01:59:05 <ReinH> merijn: that's just like your opinion, man. Etc.
01:59:42 <Gurkenglas> @pl this conversation
01:59:42 <lambdabot> this conversation
01:59:57 <mbrock> interestingly lists in Haskell can also be viewed as being "control structures" instead of "data structures"
02:00:08 <ReinH> You can say that [] and (:) are like empty, push and pop. Ok. Great. Lists can be given a stack interface.
02:00:13 <dramforever> who knows, they are the same
02:00:30 <arkeet> this is going nowhere so I'm out.
02:00:46 <proteusguy> I think I made the scope of my question quite clear, multiple times. Focusing on implementation instead of interface is pointless when the question is clearly about usage. Anyway - thanx for the thoughtful replies and clarifications. I think the lack of counter examples confirms I didn't misunderstand the haskell list which was my chief concern. I've no problem with haskell's choice of words for its data types.
02:01:34 <edk> i think we made the scope of your mistake quite clear, multiple times. but whatever, i'm done also
02:01:41 <ReinH> lol
02:01:55 <ReinH> Glad we ended up exactly where we started
02:02:05 <darenthis> but older and wiser
02:02:09 <ReinH> older at least
02:02:18 * arkeet feels only older
02:02:37 <ReinH> darenthis: well, possibly marginally less likely to get baited in the future
02:02:52 <ReinH> probably not though
02:02:54 <proteusguy> ReinH, you weren't baited.
02:02:58 <Sindriava> What the fuck is going on in here anyways
02:03:09 <mniip> Sindriava, we talk about haskell here
02:03:20 <proteusguy> Sindriava, I asked an honest question with the wrong perspective. ;)
02:03:20 <arkeet> cool, let's talk about haskell.
02:03:25 <arkeet> I like burritos.
02:03:26 <ReinH> I guess that's supposed to be ironic.
02:03:30 <arkeet> they are like monads.
02:03:33 <ski> Sindriava : miscommunication of some or other sort, possibly
02:03:41 <merijn> arkeet: Did you see this year's SIGBOVIK? :)
02:03:50 <arkeet> nope
02:03:53 <mniip> arkeet, I also like free burritos
02:04:13 <dramforever> lemme see...so are you guys talking about the interface of []?
02:04:15 <Sindriava> ski: Sounds like it
02:04:36 <merijn> arkeet: It had a paper titled "Burritos for the Hungry Mathematician" explaining burritos to mathematicians :p
02:04:37 <ReinH> merijn: oh god I had forgotten about those
02:04:39 <mbrock> I feel like there should be a standard phrase to mean "this discussion is getting combative and weird, so if you have an argument to make then please write it down in clear logical form on a pastebin and we might be able to proceed further"
02:04:41 <mniip> I heard you can get any burrito for free, but you have to pay when you try consume it
02:05:10 <new_mind> does /dev/null count as an acceptable pastebin?
02:05:17 <arkeet> merijn: reading it now :-)
02:05:28 <merijn> arkeet: Containing the line: "a burrito is just a strong monad in the symmetric monoidal category of food; what's the big deal?!"
02:05:39 <mbrock> new_mind: yes, but only if you don't lazy evaluate, the part about clear reasoning is not optional!
02:05:42 <darenthis> I was reminded of this mindblowing example of what you can get up to with mere lists in haskell: http://blog.jle.im/entry/practical-fun-with-monads-introducing-monadplus
02:05:45 <mniip> new_mind, it's an acceptable sink but not an acceptable source
02:06:00 <ReinH> merijn: for some reason I particularly enjoy "A Proof of the Twelve-Color Theorem: Hey, Nobody Bothered Before"
02:06:16 <merijn> ReinH: "Red i detection" is one of my favourites :D
02:06:19 <mniip> ReinH, what are we coloring with 12 colors?
02:06:27 <merijn> mniip: A map, presumably
02:06:32 <mniip> on what
02:06:50 <Sindriava> mniip: I'd presume it's about coloring a graph
02:06:55 <edk> a plane
02:06:55 <merijn> mniip: No, colouring the map
02:07:17 <merijn> mniip: i.e. "is it possible to colour every country/shape so that no two adjacent shapes have the same colour?"
02:07:44 <MrMeowMeow> isn't that one of those unsolveable problems
02:07:51 <merijn> MrMeowMeow: No, it's solved
02:07:55 <mniip> merijn, but what are these contries laid on
02:07:58 <Sindriava> MrMeowMeow: Not to my knowledge
02:08:02 <mniip> because it's 4 colors on a sphere
02:08:03 <merijn> MrMeowMeow: Any 2d map can be 3-coloured
02:08:03 <darenthis> 4 colours
02:08:05 <proteusguy> MrMeowMeow, depends on the number of colours.
02:08:07 <Sindriava> merijn: Don't you need only 4 colors for that?
02:08:10 <arkeet> merijn: it can?
02:08:16 <edk> it was one of the first things to be directly proved by computer, iirc
02:08:17 <mniip> and 7 colors on a torus
02:08:19 <dramforever> that's impossible
02:08:20 <ReinH> "But luckily I found a proof for the 5-color theorem that made sense, and since having more colors is obviously better, that should work just as good."
02:08:23 <merijn> Sindriava: 3, which is why the 12-colour thing is so silly :)
02:08:44 <arkeet> merijn: it's 4.
02:08:46 <edk> merijn, it's 4 for a 2d map
02:08:49 <Sindriava> merijn: On a plane?
02:08:51 <arkeet> it's easy to find counterexamples for 3.
02:08:56 <Sindriava> Yah
02:09:04 <arkeet> consuder luxembourg and it's neighbours.
02:09:10 <dramforever> if it were 3 then we would have proved P = NP
02:09:12 <arkeet> consider
02:09:30 <ReinH> "Proof. Using Theorem 1.2, generate a 5-color assignment for G. As 5 is less than 12, this assignment suffices."
02:09:34 <ReinH> Really enjoying this one
02:09:54 <merijn> hmm, I stand corrected
02:09:55 <Sindriava> :D
02:10:10 <arkeet> its* it's late.
02:10:16 <Sindriava> merijn: It's 2 for 1D and 3 for 2D
02:10:27 <arkeet> :(
02:10:31 <mniip> Sindriava, depends on the 2d being used
02:10:43 <Sindriava> mniip: Well, 2D meaning a plane
02:10:56 <Sindriava> mniip: I'd argue that 2D that's not a plane is 3D, no?
02:11:02 <mniip> no
02:11:03 <arkeet> no
02:11:07 <arkeet> it could be a torus
02:11:13 <arkeet> or a sphere, or ...
02:11:17 <ReinH> mniip: btw the paper was for a 6th grade class entitled "United States History: The 2017 Burrito Wars to the Present Day"
02:11:19 <mniip> and toruses can use as many as 7 colors
02:11:19 <merijn> Anyway, my work here is done: http://sigbovik.org/2015/proceedings.pdf
02:11:20 <Sindriava> and is a sphere not 3D?
02:11:21 <ReinH> We are so close
02:11:28 <arkeet> a sphere is a surface.
02:11:30 <edk> Sindriava, its surface
02:11:30 <ski> a ball is 3D
02:11:37 <mniip> Sindriava, a sphere is a topological surface
02:11:49 <ReinH> I for one welcome our new burrito overlords.
02:12:00 <mniip> we don't consider the fact that it "fits" in a 3D space, but rather the way a sphere's points are connected
02:12:00 <arkeet> it's 2d, as it can be locally parametrized by 2 parameters.
02:12:23 <edk> Sindriava, and it's 4 for a plane, anyway
02:12:26 <Sindriava> arkeet: Or 1 parameter on a hilbert curve?
02:12:32 <arkeet> (if I'm on a sphere, I only need 2 numbers to describe nearby points.)
02:12:38 <ski> Sindriava : continuously
02:12:44 <arkeet> that's not a parametrization (it's not bijective)
02:12:49 <Sindriava> Oh yeah
02:13:01 <Sindriava> Fair enough, 2 parameters I get
02:13:01 <arkeet> (much less a homeomorphism)
02:13:32 <arkeet> ski: it is continuous though.
02:14:40 <ski> arkeet : oh. for some reason i was thinking of the binal interleave thing
02:14:40 <aib> "Each audience member is given a pair of colored 3D glasses.  One presenter wears red.  One presenter wears blue."
02:14:55 <arkeet> the what
02:15:00 <arkeet> aib: :-)
02:22:22 <aloiscochard> could anyone please explain me what `STRICT_1_OF_2(go)` do in this code here: https://hackage.haskell.org/package/containers-0.5.6.3/docs/src/Data-Map-Base.html#lookup ?
02:23:21 <dramforever> looks like a marco defined in containers.h
02:23:28 <dramforever> better get that file
02:23:29 <opqdonut> yeah that's my guess too
02:23:40 <aloiscochard> cool I'll look there, ty
02:23:43 <liste> https://github.com/haskell/containers/blob/master/include/containers.h here
02:23:48 <liste> if you're lazyt
02:23:51 <liste> -t
02:24:04 <aloiscochard> oh I see, thanks a lot liste, I'm definitely lazy ;)
02:24:32 <liste> yw (:
02:25:36 <Sindriava> Could I get some help with mtl?
02:25:57 <liste> Sindriava please elaborate
02:26:24 <Sindriava> liste: I'm migrating my GLFW code to use monad transformers, and I can't get it to compile
02:26:44 <Sindriava> I've fixed most of the errors, but now I can't sequence my monad stack with IO actions
02:26:50 <Sindriava> or so I think
02:26:55 <liste> Sindriava are you using liftIO ?
02:27:00 <Sindriava> liste: Yeah
02:27:05 <Sindriava> Here's the code: http://lpaste.net/8956488464207970304
02:27:24 <Sindriava> the error appears on line 79, because `f win` is of type App (), while others are IO
02:27:51 <Sindriava> App is a newtype of `StateT AppState (ReaderT AppConfig IO) a`
02:28:25 <dramforever> lift all IO functions
02:28:43 <Sindriava> dramforever: Isn't that what I'm doing?
02:28:44 <liste> or get `f win' outside the liftIO
02:28:47 <concept> what is a Comonad ?
02:28:52 <concept> Why is it useful ?
02:28:55 <dramforever> Sindriava: oh sorry
02:28:56 <Sindriava> concept: Monad with the arrows reversed
02:29:00 <dramforever> you have to keep f outside
02:29:04 <dramforever> yes
02:29:05 <merijn> concept: CoX is "X with the arrows reversed"
02:29:22 <liste> Sindriava could you split you big liftIO into two, and put `f win' between them?
02:29:23 <merijn> concept: So, monad has "a -> M a" and "M (M a) -> a"
02:29:32 <merijn> eh "M (M a) -> M a"
02:29:35 <Sindriava> concept: It's useful for representing computations formed from lots of smaller, similar computations, like cellular automata
02:29:55 <merijn> concept: Comonads have "M a -> a" (extract) and "M a -> M (M a)" (extend)
02:29:58 <Sindriava> concept: Write game of life using a comonad and you'll pretty much understand them, there's a lot of material about it on the internet :)
02:30:17 <Sindriava> liste: Well I'll try, gimme a sec
02:30:38 <Sindriava> liste: But it needs to be inside the case, pretty much :/
02:30:44 <merijn> concept: As for "Why are they useful?", they're just another pattern/interface/whatever that is reusable. Although they occur less frequently than monads
02:31:30 <no> Hey guys.
02:31:39 <no> What's the reason for learning Haskell? I think VB.NET is great!
02:31:50 <merijn> @quote merijn burrito
02:31:50 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
02:32:00 <merijn> Aww, it's no longer there? :(
02:32:12 <dramforever> @remember merijn burrito
02:32:12 <lambdabot> It is forever etched in my memory.
02:32:14 <Guest81176> Hey guys
02:32:19 <dramforever> @quote merijn
02:32:19 <lambdabot> merijn says: if there's anything the GHC is good at it's releasing memory fast.
02:32:19 <Guest81176> What's the reason for learning Haskell?
02:32:22 <Guest81176> I think VB.NET is great!
02:32:26 <liste> Sindriava how about returning Maybe Window from your big liftIO ?
02:32:54 <Sindriava> liste: That's a good idea! then I can just `f <$> win`
02:32:55 <merijn> dramforever: It had "A comonad is like a burrito. It's hard to keep things inside." as one of my quotes :p
02:33:04 <dramforever> oh sorry
02:33:05 <Sindriava> merijn++
02:33:08 <Sindriava> shit
02:33:09 <Sindriava> merijn + 1
02:33:10 <dramforever> did I just add something bad?
02:33:16 <merijn> @forget merijn burrito
02:33:16 <lambdabot> Done.
02:33:21 <dramforever> @forget merijn burrito
02:33:22 <lambdabot> No match.
02:33:27 <dramforever> ok
02:33:30 <liste> Guest81176 programming language evolution (:
02:33:40 <Guest81176> What do you mean?
02:34:02 <dramforever> Guest81176: every language has something good and something bad
02:34:04 <aloiscochard> I'm curious, are you folks grouping your imports? I use to split "global" import from the one relative to the current project... but that seems useless, so I'm not doing it anymore. I'm curious what others usually do.
02:34:08 <dramforever> we don't have a perfect language
02:34:12 <merijn> aloiscochard: I do
02:34:18 <dramforever> aloiscochard: I do
02:34:25 <dramforever> also I sort my imports
02:34:31 <aloiscochard> merijn, dramforever: with the same approach I described?
02:34:36 <dramforever> kinda
02:34:38 <aloiscochard> yeah I sort them as well, very important imo
02:34:46 <dramforever> not very import imo
02:34:50 <dramforever> *important
02:34:53 <dramforever> good pun
02:35:10 <merijn> aloiscochard: "global vs local" although sometimes "global and common (i.e. transformers, etc.), global but specific dependencies, and local"
02:35:22 <aloiscochard> dramforever: maybe not so important with some tooling, but at least I know where to look for a given import if sorted
02:35:45 <aloiscochard> merijn: make senses ty, roughly what I use to do
02:36:13 <dramforever> Guest81176: learning a new language will give you another way to program
02:37:06 <Guest81176> dramforever Yes, but "purely functional" seems like a confusing disadvantage
02:37:10 <aib> aloiscochard: yes, I usually have 3 groups: 1) File-specific at the top (file.h from file.c, for example) 2) "global" library imports 2.5) downloaded/external library imports 3) project-internal imports
02:37:20 <dramforever> Guest81176: well explain that a bit
02:37:52 <Guest81176> Everything has to return something right? Since "functions"?
02:37:58 <dramforever> yep
02:37:59 <Guest81176> So how would methods and stuff work?
02:38:07 <Guest81176> I'm not used to this way of thinking
02:38:14 <tdammers> of course you're not
02:38:19 <dramforever> "I'm not used to this way of thinking" GREAT
02:38:25 <ski> methods would just be fields that happens to be functions
02:38:38 <dramforever> now THAT'S why learning haskell is benefitial
02:38:42 <dramforever> screw it spelling
02:38:53 <tdammers> ski: I'm thinking what Guest81176 means is "routines that do not return anything, but are executed for their side effects"
02:39:09 <ski> mayhaps
02:39:16 <AndChat196224> Should security researches or pentration tester learn haskell
02:39:23 <matsuura> Yeah Hi, i'm looking for the Boddhisattva school of Haskell?
02:39:25 * ski stares at Guest81176
02:39:46 * dramforever stares at ski
02:39:51 <tdammers> AndChat196224: when their work requires it, yes
02:39:56 <aloiscochard> AlainODea: nice! I can see usefull to split global from base, I actually use to do that with scala
02:40:29 <liste> Guest81176 the things that feel weird (purity, laziness) make some very different and beneficial techniques possible
02:40:37 * ski waits for Guest81176 to complete the deadly circular stare
02:40:40 <dramforever> Guest81176: so...are you convinced that there's something to learn?
02:40:43 <Guest81176> Lazyness seem awesome.
02:40:50 <dramforever> *laziness
02:40:52 <Guest81176> Yes. There's definitely stuff to learn
02:40:53 <dramforever> ftfy
02:41:13 <liste> @where Why FP matters
02:41:13 <lambdabot> I know nothing about why.
02:41:14 <dramforever> Guest81176: "purely functional" another way to program, sure worth learning
02:41:15 <Guest81176> What platforms can you compile haskell natively to?
02:41:21 <aloiscochard> Guest81176: non-strict evaluation is indeed awesome, that is something I kept looking for until I have met haskell
02:41:30 <dramforever> I compiled to Windows, Linux
02:41:36 <dramforever> before
02:41:51 <liste> you can also compile to JavaScript
02:41:55 <dramforever> I think to javascript thing works pretty well
02:41:56 <ski> @google Why FP matters
02:41:56 <lambdabot> https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf
02:42:02 <ski> liste
02:42:16 <liste> thanks (:
02:42:23 <liste> there's some rationale
02:42:36 <liste> and benefits of Haskell
02:42:50 <dramforever> Guest81176: if you do come to learn, do remember one thing
02:43:17 <dramforever> learning haskell is kinda like learning programming from scratch
02:43:30 <lamefun> Is Template Haskell broken? http://lpaste.net/9041153122994487296
02:43:55 <dramforever> don't expect to be able to just read some example code and start going because you have learnt programming before
02:44:36 <aib> What's with the -- | comments? Never saw them before yesterday, but 3 since then
02:44:44 <merijn> aib: Haddock comments
02:44:57 <merijn> lamefun: Newtype in a function body, why'd you expect that to work?
02:45:01 <aib> cheers
02:45:18 <merijn> lamefun: Wait, I'm an idiot, nvm
02:47:11 <Sindriava> liste: Got it working! Now come hours of refactoring to get a good feel for the code and make it worth looking at :D
02:47:46 <liste> great \o/
02:48:13 <Sindriava> It'd be nice to have a truthiness typeclass
02:49:06 <tdammers> boolean blindness and all taht
02:49:13 <Sindriava> when :: Boolable a, Applicative f => a -> f () -> f ()
02:49:18 <Sindriava> Oh yeah, hmmm
02:49:29 <dramforever> toBool?
02:49:43 <dramforever> Sindriava: can't you pattern match or something?
02:49:56 <Sindriava> dramforever: I can, sure
02:50:02 <tdammers> my point is, most likely what you want is conceptually more specific than "truthiness"
02:50:09 <dramforever> exactly
02:50:13 <Sindriava> tdammers: Yeah, probably
02:50:14 <tdammers> so it's probably better to make a custom typeclass to express *that*
02:50:21 <dramforever> hmm......
02:50:27 <Sindriava> Nah, I'll just use case
02:50:30 <JWZH> I'm trying to write a lexer in haskell, but I having trouble tracking current line and column, as there is no variable in haskell.. Anybody can give a hint ?
02:50:44 <tdammers> case *is* pattern matching
02:50:55 <Sindriava> tdammers: No shit
02:51:20 <Sindriava> tdammers: Like I said, I *can* use pattern matching, I was just playing around with the idea of more general `when`
02:51:23 <dramforever> JWZH: pass the current position to the recursive call
02:51:51 <dramforever> wait what's code like?
02:52:20 <Sindriava> case maybe_a of { Just a -> ; Nothing -> return () } is kinda mouthful
02:52:22 <dramforever> JWZH: "no variable" hmm...that "variable" isn't a good name, but I get what you mean
02:52:23 <JWZH> I see, so the lexer function should have an additional parameter which is the lineno
02:52:31 <dramforever> Sindriava: prism?
02:52:32 <tdammers> :t maybe
02:52:33 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:52:54 <Sindriava> tdammers: I'm well aware of that, but still
02:53:01 <Sindriava> is there a `maybeWhen` ?
02:53:01 <dramforever> Sindriava: prisms?
02:53:10 <Sindriava> dramforever: lens are kinda overkill for that
02:53:20 <dramforever> Sindriava: yes maybe could be used as maybewhen
02:53:20 <Sindriava> dramforever: Since I basically need one specific function :D
02:53:39 <tdammers> I think I have a maybeM floating around somewhere
02:53:51 <Sindriava> tdammers: No need, really
02:53:52 <mpickering> :t forM_
02:53:54 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
02:53:54 <dramforever> :t maybe :: Monad m => m b -> (a -> m b) -> Maybe a -> m b -- ok tell me it doesn't work
02:53:56 <lambdabot> Monad m => m b -> (a -> m b) -> Maybe a -> m b
02:53:59 <Sindriava> tdammers: maybeWhen = maybe ()
02:54:03 <Sindriava> :t maybe ()
02:54:05 <lambdabot> (a -> ()) -> Maybe a -> ()
02:54:41 <Sindriava> oh yeah, I forgot monad
02:54:41 <tdammers> :t maybe (return ())
02:54:43 <mpickering> Sindriava: You can use mapM_ or forM_ 
02:54:43 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
02:54:48 <Sindriava> tdammers + 1
02:54:51 <merijn> :t forM_ (undefined :: a -> Maybe b)
02:54:52 <lambdabot>     Could not deduce (Foldable ((->) a0)) arising from a use of forM_
02:54:52 <lambdabot>     from the context (Monad m)
02:54:52 <lambdabot>       bound by the inferred type of
02:55:01 <merijn> eh, whoops
02:55:02 <Sindriava> :t forM_
02:55:04 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
02:55:10 <merijn> :t forM_ Nothing (undefined :: a -> Maybe b)
02:55:12 <lambdabot> Maybe ()
02:55:38 <Sindriava> mpickering: merijn: Oh neat, Maybe is foldable?
02:55:44 <merijn> Sindriava: Of course
02:56:07 <mpickering> :t forM_ `asAppliedTo` Nothing
02:56:08 <lambdabot> Monad m => Maybe a -> (a -> m b) -> m ()
02:56:08 <merijn> Sindriava: Foldable is basically "toList" and Maybe turns into a 0 or 1 element list
02:58:18 <Hafydd> I have looked at all of the "Time" libraries on Hackage, and it seems that not one of them provides access to a timestamp that increases by 1 second for every second that physically passes (or while the machine is not suspended; sometimes referred to as "wall clock time"). There is System.CPUTime.getCPUTime and Data.Time.Clock.getCurrentTime, but neither fit this specification. This functionality is provid
02:58:24 <Hafydd> ed, for example, on Linux, by clock_gettime(CLOCK_MONOTONIC_RAW, ...). An application of this is measuring the execution time of a computation. Is there some facility for this that I haven't noticed? If not, why does this not exist? Surely others have seen the need for it before.
02:58:50 * hackagebot aeson-qq 0.8.1 - JSON quasiquoter for Haskell  https://hackage.haskell.org/package/aeson-qq-0.8.1 (qoelet)
02:59:31 <srhb> How is getCurrentTime different from that specification?
02:59:44 <srhb> Maybe I'm just confused with the concept. :)
03:00:06 <dramforever> srhb: I think it only measures the time when the machine is running
03:00:14 <liste> I guess the days is the problem
03:00:14 <dramforever> that's a bit weird, you know
03:00:28 <Hafydd> getCurrentTime gives the current UTC timestamp, which is adjusted according to leap seconds.
03:00:39 <Sindriava> merijn: Neat!
03:00:40 <srhb> Ah.
03:00:42 <Sindriava> :t asAppliedTo
03:00:45 <lambdabot> (a -> b) -> a -> a -> b
03:00:45 <Hafydd> Therfore, it doesn't always increase by 1 second for each physical second.
03:00:53 <srhb> So the leap second is the problem.
03:01:07 <Hafydd> Yes.
03:01:17 <EvanR> Hafydd: theres a package for monotonic clock, for the process
03:01:21 * dramforever thinks there must be something like "seconds since 1 Jan 1970"
03:01:27 <EvanR> cross platform (and more or less recently fixed)
03:01:44 <ski> @type asTypeIn
03:01:45 <lambdabot> a -> (a -> b) -> a
03:01:47 <EvanR> dramforever: well, thats not totally well defined, but there is POSIXTime
03:01:48 <ski> @src asTypeIn
03:01:48 <lambdabot> a `asTypeIn` f = a where _ = f a
03:01:48 <lambdabot> infixl 0 `asTypeIn`
03:02:00 <dramforever> dunno...
03:02:01 <Hafydd> dramforever: there is, but that requires a database of leap seconds, so it isn't practical when you just want absolute time differences.
03:02:09 <EvanR> Hafydd: do you want AbsoluteTime? 
03:02:14 <WeaponX> Hafydd, Data.Time.Clock.POSIX ?
03:02:18 <ski>   f `asAppliedTo` a = f `asTypeIn` ($ a)
03:02:24 <ski> Sindriava ^
03:02:35 <Sindriava> ski + 1
03:02:41 <EvanR> Hafydd: in real life you probably want to diff times and get a NominalDiffTime
03:02:52 <EvanR> this is a difference of times which ignores leap seconds
03:03:02 <EvanR> its the difference of POSIXTimes
03:03:13 <EvanR> and is compatible with UTC
03:03:50 * hackagebot fusion 0.1.2 - Effectful streaming library based on shortcut fusion techniques  https://hackage.haskell.org/package/fusion-0.1.2 (JohnWiegley)
03:03:52 * hackagebot webdriver 0.6.2.1 - a Haskell client for the Selenium WebDriver protocol  https://hackage.haskell.org/package/webdriver-0.6.2.1 (MichaelSnoyman)
03:04:20 <EvanR> Hafydd: https://github.com/evanrinehart/time-diagram
03:04:28 <Hafydd> EvanR: yes, if such a thing were possible to obtain. WeaponX: Data.Time.Clock.POSIX gives the POSIX time, which, again, isn't suitable for measuing absolute time differences.
03:04:53 <EvanR> Hafydd: for two UTCTimes you dont want absolute time difference
03:05:04 <Hafydd> EvanR: on what are you basing the assertion that "in real life you probably want to diff times and get a NominalDiffTime"?
03:05:07 <EvanR> for two times within your processes run time, you can use the clock
03:05:26 <EvanR> Hafydd: years of experience implementing time and date software
03:05:33 <WeaponX> Hafydd, are you trying to do hard real-time stuff with Haskell?
03:06:11 <EvanR> Hafydd: the monotonic clock will give you real time diff, its not involved with leap seconds
03:06:20 <EvanR> but its only for your process
03:06:23 <Hafydd> EvanR: I didn't ask for your credentials; I asked for a reason for your statement.
03:06:52 <EvanR> Hafydd: because it has simpler algebraic properties 
03:07:13 <EvanR> people live in an abstract system of times and dates and dont care about leap seconds
03:07:13 <Hafydd> I am unconvinced.
03:07:32 <EvanR> the calendar is isomorphic to the integers
03:07:41 <Hafydd> WeaponX: no, not really. I just don't want my time measurement to differ by a second because it happened to occur during a leap second.
03:07:47 <EvanR> (in many ways)
03:08:05 <EvanR> Hafydd: thats exactly why you want to use NominalDiffTime
03:08:29 <EvanR> or the monotonic clock
03:09:08 <nshepperd> what does "ignores leap seconds" mean
03:09:18 <EvanR> it means take the difference of two UTCTimes in seconds
03:09:19 <Hafydd> EvanR: perhaps I'm not clear: I don't want it to deviate from the physically elapsed time due to a leap second, which NominalDiffTime would.
03:09:21 <tdammers> EvanR: I think if you use diffUTCTime to create NominalDiffTime values, leap seconds are exactly your problem
03:09:33 <tdammers> it ignores leap seconds
03:09:41 <EvanR> which is probably a good idea
03:10:01 <tdammers> yes, but UTCTime timestamps are based on a system that *does* use leap seconds
03:10:32 <tdammers> but NominalDiffTime ignores those, assuming that every minute has 60 seconds
03:10:45 <Hafydd> It's a good idea if you're representing how much the Earth has rotated around the sun, but not if you're measuring the performance of a program, for example.
03:10:53 <EvanR> if you hae two UTCTimes such as 12:00 Jan 1 1980 and 12:00 Jan 1 2000 then you probably expect the time diff to equal 86400*number of days between those days number of seconds of diff time
03:10:55 <Gurkenglas> How much would break if a unified with () -> a?
03:11:13 <tdammers> EvanR: yes, and that would be incorrect
03:11:13 <EvanR> no scheduling app is going to want it the appointment ot be off by 7 seconds
03:11:22 <dramforever> Gurkenglas: the type system will fall into an infinite loop
03:11:23 <EvanR> tdammers: no
03:11:24 <ski> Gurkenglas : you'd get a cyclic type
03:11:26 <nshepperd> sounds like Hafydd wants timing, not calendaring
03:11:37 <EvanR> if you want timing, use the monotonic clock
03:11:45 <berdario> gosh... I hate sleepless nights of coding. I couldn't think straight, and I ended up having to use unsafePerformIo :/
03:11:59 <Hafydd> Yes, indeed. The calendar and the solar system should be irrelevant to this, which is just based on the atomic clock in the CPU (or whatever it is).
03:12:32 <tdammers> EvanR: it would be incorrect because it would not be the number of seconds elapsed between these UTC timestamps
03:12:40 <lamefun> k3wl
03:12:42 <lamefun> "Looks like you're either a brand new user or your posts have not been doing well recently. You may have to wait a bit to post again. In the meantime feel free to check out the reddiquette, join the conversation in a different thread, or verify your email address."
03:12:43 <EvanR> the clock package deals with that, and is cross platform
03:12:54 <tdammers> some of the days between them have more than 86400 seconds
03:13:11 <EvanR> tdammers: well, it depends on what time system you use and for what purpose
03:13:15 <lamefun> (I deleted my first post to improve code examples and re-post)
03:13:17 <tdammers> UTC
03:13:22 <tdammers> it's pretty well defined
03:13:29 <EvanR> the point of leap seconds is to fake correspond the real world with our clocks and calendaras
03:13:33 <EvanR> for better or worse
03:13:35 <tdammers> yes
03:13:39 <lamefun> How long do I have to wait now?
03:13:47 <EvanR> hopefully they are abolished 
03:13:57 <tdammers> don't think so
03:14:06 <tdammers> but who knos
03:14:17 <Hafydd> Perhaps I will have to write my own time library.
03:14:35 <tdammers> anyway, the point is, NominalDiffTime is basically "the number of seconds that would have elapsed between these UTC timestamps if there hadn't been any leap seconds"
03:15:05 <EvanR> tdammers: you can think of UTC as a pair (Day, SecondsPastMidnight), then you have a vector space (by choosing an arbitrary origin) and the NominalDiffTimes are the vectors
03:15:12 <EvanR> or torsors
03:15:26 <EvanR> this is way easier to deal with and works great as long as you live in that space
03:15:29 <EvanR> which people do
03:15:31 <tdammers> ofc
03:15:34 <EvanR> unless you are doing atomic physics
03:15:58 <EvanR> Hafydd: ... did you look at the clock package?
03:16:01 <tdammers> that's why I'd generally advise people to program anything calendar-based in the realm of calendar data types, not seconds-based ones
03:16:16 <tdammers> using UNIX timestamps to represent dates is a big mistake
03:16:21 <EvanR> tdammers: right, dates are even easier than UTC, since they arent fractional
03:16:54 <tdammers> just use a "date/time with time zone" type, and make sure all operations on it are well-defined and decidable
03:16:56 <tdammers> ("just")
03:17:01 <rlewis> what's the rationale behind NominalDiffTime ignoring leap seconds?
03:17:04 <EvanR> dates + time of day of your appointment, sometimes you may ask how long you have until the appointment
03:17:21 <EvanR> the answer is a NominalDiffTime
03:17:23 <tdammers> rlewis: ease of implementation, being able to handle future dates at all?
03:17:37 <EvanR> and its correct
03:17:46 <EvanR> because time isnt even real
03:17:47 <dramforever> interesting
03:17:50 <Hafydd> EvanR: oh, no, I didn't see that. I thought you were referring to Data.Time.Clock, before. For some reason this isn't categorised under "Time" on hackage.
03:18:01 <tdammers> EvanR: if there's a leap second between "now" and "when the appointment starts", then it'll be off by one second
03:18:02 <dramforever> so say we have minutes M1 M2 M3
03:18:03 <EvanR> Hafydd: no its a separate thing
03:18:09 <dramforever> and M2 has a leap second
03:18:12 <tdammers> which is acceptable, because people don't care about errors this small
03:18:38 <tdammers> but if you want to do it correctly, do your arithmetic in calendar types, and report it as such
03:18:42 <EvanR> tdammers: it is, and even if it included leap seconds you cant predict politics
03:18:53 <lamefun> nvm, it worked after verifying e-mail.
03:18:57 <dramforever> is the NominalDiffTime between [the end of the last second of M1] and [the beginning of the first second of M2] 61 seconds?
03:19:03 <dramforever> EvanR: ^
03:19:06 <tdammers> today 12:00 until tomorrow 12:00 is always going to be "one day", whether that day includes leap seconds or not is unspecified
03:19:07 <EvanR> i know its hard to reall grasp, its an incredibly cultural + algebraic issues
03:19:15 <EvanR> dramforever: no
03:19:25 <dramforever> wow
03:19:36 <EvanR> tdammers: the earth days arent even 86400 seconds, so thats already "wrong"
03:19:37 <tdammers> EvanR: that's why I said that future dates are "impossible"
03:19:41 <ski> dramforever : s/M2/M3/ ?
03:19:52 <tdammers> and I'm not talking about that level of wrong, even
03:19:59 <EvanR> levels of wrong!
03:20:05 <EvanR> thats all im saying
03:20:12 <EvanR> you pick your math world ot live in
03:20:35 <tdammers> theoretical consistency is the baseline
03:20:46 <EvanR> how is 86400 theoretically consistent
03:20:50 <tdammers> if your types aren't even internally consistent, then what use is there
03:20:58 <EvanR> they are consistent
03:21:08 <EvanR> UTC is a consistent timescale in isolation
03:21:15 <tdammers> yes
03:21:32 <tdammers> but the length of one UTC day isn't necessarily 86400 seconds
03:21:41 <tdammers> that's just how UTC works
03:21:41 <EvanR> yes it is
03:21:56 <nshepperd> it's 86400 "seconds"
03:22:05 <EvanR> 86400, 86401 and however map leapseconds you add get forgotten when the next advances
03:22:18 <EvanR> next day
03:22:19 <nshepperd> where a "second" may be shorter or longer than a second depending on leap blah blah
03:22:32 <EvanR> the seconds length is not changing anymore
03:23:05 <tdammers> quoting wikipedia on UTC: "The number of seconds in a minute is usually 60, but with an occasional leap second, it may be 61 or 59 instead."
03:23:31 <nshepperd> this really strikes me as a nonsensical way to think about time though
03:23:33 <EvanR> well i guess its a matter of what question you are asking
03:23:39 <nshepperd> actual wall clock time is one thing
03:23:41 <rlewis> I'm scrolling back but failing to find the answer to my question.. what would one use instead of NominalDiffTime to time the duration of some computation?
03:23:49 <nshepperd> human calendars are another thing
03:23:51 * hackagebot bitx-bitcoin 0.4.0.0 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.4.0.0 (tebello_thejane)
03:23:56 <Sindriava> how would I pass a state to a callback?
03:23:57 <EvanR> rlewis: no
03:24:04 <tdammers> rlewis: something like "number of SI seconds elapsed since system boot" or something
03:24:04 <EvanR> use Double
03:24:11 <Sindriava> e.g. I'm passing a callback to GLFW, and I want it to modify a state in my monad stack
03:24:15 <EvanR> or Integer number of nanoseconds
03:24:24 <EvanR> Pico
03:24:50 <Hafydd> Hmm... the clock package supports CLOCK_MONOTONIC and CLOCK_REALTIME, which according to `man 3 clock_gettime' are both affected by NTP changes.
03:24:50 <EvanR> Sindriava: use TVars or MVars for that
03:24:51 <dramforever> tdammers: what if the time "stopped" for a while? for example when you suspend the computer
03:25:06 <EvanR> Hafydd: yes, dont change your system clock
03:25:14 <EvanR> unless you know what youre doing
03:25:17 <tdammers> dramforever: as long as you're aware of this, and the time thus represented is what you want, that's fine
03:25:18 <Sindriava> EvanR: Do I have to? I mean, what's the point of using the state monad then?
03:25:25 <EvanR> Sindriava: none, dont use it
03:25:33 <EvanR> for that at least
03:25:39 <Hafydd> EvanR: I don't need to change my clock if it's updated by NTP.
03:25:47 <Sindriava> EvanR: *sigh*
03:25:51 <rlewis> tdammers and what is a portable haskell equivalent of that? hopefuly resolution is higher than one second too
03:25:57 <dramforever> tdammers: example: if you start a minecraft server, suspend your computer, wait like 1h, start your computer
03:26:10 <tdammers> rlewis: well, that's kind of the problem Hafydd is running into
03:26:11 <dramforever> the server complains that "last tick took too long"
03:26:13 <EvanR> dramforever: youll get a huge jump in time
03:26:15 <dramforever> and stops
03:26:42 <dramforever> EvanR: yes, especially if the program is not prepared for this
03:27:10 <EvanR> guys, the monotonic clock works fine (until it overflows...) i think leap seconds are the least of your problems
03:27:40 <tdammers> https://en.wikipedia.org/wiki/International_Atomic_Time
03:27:44 <EvanR> your PC clock sucks anyway for atomic science
03:27:45 <tdammers> this is what you'd ideally want
03:29:13 <tdammers> you can convert between TAI and UTC, back and forth, but you have to take leap seconds into account
03:29:23 <EvanR> for short experiments modern computers can give you pretty high precision that wont be disturbed by a user/ntp changing the time of day, but its still not even going to be as accurate as all that
03:29:27 <Hafydd> I only need millisecond accuracy, realistically, but not even that is given by a clock that has discontinuities and nonmonotonicity due to (ignoring) leap seconds.
03:29:44 <EvanR> how long are you going to leave it running?
03:29:59 <Hafydd> No more than an hour, probably.
03:30:01 <tdammers> EvanR: one second is enough if there happens to be a leap second
03:30:06 <EvanR> you should be fine
03:30:27 <Hafydd> I will not be fine if a leap second happens to occur during the measurement.
03:30:35 <tdammers> OTOH, if "don't run the thing during a leap second" is a viable plan, then just do that
03:30:41 <Hafydd> I'm aware the probability is small, but why should I accept a small probability when 0 is possible?
03:31:07 <EvanR> what, monotonic clock increases according to the OS, its not disturbed by a leap second
03:31:16 <EvanR> its not the UTC time of day
03:31:26 <Hafydd>        CLOCK_MONOTONIC
03:31:26 <Hafydd>               Clock  that  cannot be set and represents monotonic time since
03:31:26 <Hafydd>               some unspecified starting point.  This clock is  not  affected
03:31:26 <Hafydd>               by discontinuous jumps in the system time (e.g., if the system
03:31:28 <Hafydd>               administrator manually changes the clock), but is affected  by
03:31:31 <Hafydd>               the incremental adjustments performed by adjtime(3) and NTP.
03:31:42 <rlewis> so system-time-monotonic or clock?
03:31:50 <EvanR> so you dont even have to worry about NTP
03:31:53 <EvanR> oh you do
03:32:13 <EvanR> that doesnt make much sense
03:32:32 <tdammers> it does
03:32:35 <EvanR> guess they are trying to correct for small skew in your clock
03:32:38 <tdammers> jumps can be detected
03:32:38 <nshepperd> well, that kind of defeats the point of having a monotonic clock
03:32:46 <Hafydd> I believe that CLOCK_MONOTONIC_RAW is what I want, which is also documented on `man 3 clock_gettime'.
03:37:06 <EvanR> so adjtime corrects the system time by gradually slowing or speeding it up for a while until its synced up
03:37:25 <nshepperd> it would be good if there were ntp servers running on TAI though
03:38:08 <nshepperd> you could continuously calibrate the monotonic clock by communicating with atomic clocks, and get some decent accuracy
03:38:11 <EvanR> i still dont think leap seconds are going to affect the monotonic clock that way
03:38:31 <hpc> there's always the smear second
03:39:04 <Hafydd> If it's not, then why is it necessary to update it by NTP?
03:39:36 <EvanR> thats to fix your system time, and then apparently while its gradually sped up or slowed down that is somehow affecting your monotonic clock
03:39:49 <EvanR> its still monotonic
03:40:01 <nshepperd> well, if your ntpd is talking to a server that does leap second adjustments, it doesn't have any way of "undoing" them, so they'd necessarily have some effect
03:40:16 <nshepperd> I'm pretty suspicious
03:40:22 <Hafydd> "Monotonic" only means that it can reliably be used to determine the order of events, but not the magnitude of the elapsed time between them.
03:40:47 <EvanR> im suspicious that anyones computer even has support to comprend a leap second besides reset the system time
03:41:24 <EvanR> Hafydd: for that, ignoring ntp, youre going to be at the mercy of the accuracy of the computer clock
03:41:50 <flux> order within the single session (time after reboot) on that particular computer
03:41:54 <EvanR> you might be off by a millisecond!
03:42:01 <Hafydd> I can live with that.
03:42:12 <flux> so a millisecond or a century offset doesn't affect that :)
03:42:43 <nshepperd> leap seconds "could" be understood really easily: just measure actual elapsed time, and have a table of leap seconds
03:42:50 <nshepperd> like we already do with timezones
03:43:19 <nshepperd> bleh
03:43:32 <EvanR> nshepperd: i mean, the unix clock is implemented as (daynumber, timesincemidnight), and im questioning if timesincemidnight is ever >= 86400
03:43:39 <EvanR> i think its silly to even implement that
03:43:48 <EvanR> when ntp will correct you
03:44:21 <EvanR> the clock will skew more than a second on a regular basis
03:44:42 <EvanR> drift
03:45:12 <nshepperd> well, there's no need to be even wronger on purpose
03:45:42 <dramforever> ok you guys still talking about clock here?
03:45:52 <nshepperd> i'm surprised by that though, I thought the unix clock was just a single number
03:46:05 <EvanR> not to underestimate the simplification that 0-59 is over 0-60ish
03:46:32 <dramforever> somebody register a channel #haskell-clock
03:46:37 <Hafydd> Hahah.
03:46:37 <EvanR> nshepperd: well, utc isnt a single number, unix time can be derived from the two numbers
03:46:48 <dramforever> just sayin'~
03:46:50 <EvanR> otherwise you have to deal with leap seonds
03:48:20 <nshepperd> yeah this is pretty OT
03:49:13 <Hafydd> If nobody has any more suggestions for libraries solving my problem, I'll be happy to clock off.
03:50:00 <rhaps0dy> hey, is there any way to write a variadic function in Haskell?
03:50:07 <rhaps0dy> not that I need it, just wondering
03:50:53 <dramforever> yes, with some typeclass-o-magic
03:51:02 <dramforever> or lists maybe?
03:51:03 <EvanR> Hafydd: clock is the standard solution right now, you should experiment as much as you can to show how wrong it is
03:51:09 <Hafydd> Not a monomorphic variadic function, though, as far as I know.
03:51:24 <dramforever> EvanR: I can't change how UTC works
03:51:27 <rhaps0dy> hmmmm
03:51:47 <rhaps0dy> the first thing I thought of was trying to get a type that changed depending on an argument, but I'm pretty sure that's not possible
03:51:58 <EvanR> dramforever: what? talking about Hafydd and doing a stopwatch
03:52:07 <Hafydd> rhaps0dy: look at the implementation of printf.
03:52:07 <EvanR> not utc
03:52:17 <rhaps0dy> Hafydd: oh, thank you
03:52:21 <dramforever> oh forget about it then
03:53:39 <merijn> rhaps0dy: Depends on how hacky/complex you like to get :)
03:53:42 <nshepperd> Hafydd: maybe you could modify the `clock` package to support MONOTONIC_RAW?
03:54:00 <merijn> rhaps0dy: You can use the typeclass recursion ala printf, but that costs you type safety
03:54:07 <Hafydd> Yes, maybe I shall.
03:54:29 <merijn> rhaps0dy: Alternatively, I have a "variadic"-like function application in my HList example of -XKitchenSink abuse :) https://gist.github.com/merijn/dc00bc7cebd6df012c5e
04:00:42 <ski> rhaps0dy : <http://okmij.org/ftp/typed-formatting/index.html> might be interesting
04:02:09 <rhaps0dy> merijn, ski, thank you, am reading all :D
04:02:42 <dramforever> ski: wow that's interesting
04:03:01 <dramforever> it looks related to HList
04:03:15 <rhaps0dy> merijn, a lot of -Xs that I have no idea about :O
04:03:41 <Hafydd> I must be jaded, because that list of extensions doesn't seem very long.
04:08:12 <rhaps0dy> Hafydd, you just are familiar with them.
04:08:29 <rhaps0dy> I hadn't even heard of any of them
04:10:58 <Hafydd> I call it a good day when I don't have to break out -XDataSorts.
04:11:03 <merijn> rhaps0dy: DataKinds, GADTs, and TypeFamilies are the only ones that "really" do anything, the rest are mostly convenience
04:11:46 <merijn> Actually, I think that file should require ConstraintKinds, curious that GHC didn't complain when I tested it...
04:28:15 <safinaskar> how to see reverse depends of extensible-effects?
04:29:07 <liste> safinaskar http://packdeps.haskellers.com/reverse/extensible-effects
04:29:52 <safinaskar> liste: thanks
04:30:17 <liste> yw (:
04:40:33 <sgronblo> its so annoying that the effect of running cabal is dependent on cwd
04:40:53 <bennofs> sgronblo: why?
04:40:58 <zipper> sgronblo: What do you mean?
04:41:57 <dramforever> sandboxes?
04:47:25 <cow_2001> how can whole haddock documentations go missing D:<
04:47:42 <dramforever> maybe they aren't built yet
04:51:08 <sgronblo> zipper: lets say i run "cabal install cabal-install" but happen to do it in a dir with a sandbox, hooray, now i didnt get the latest version in my ~/.cabal/bin right?
04:51:45 <cow_2001> package uploaded at Mon May 11 13:40:46 UTC 2015
04:52:15 <dramforever> maybe check build reports
04:52:19 <dramforever> which package?
04:52:23 <cow_2001> oh, all reported builds failed
04:52:35 <cow_2001> https://hackage.haskell.org/package/gloss-1.9.4.1/reports/
04:53:20 <cow_2001> base-4.8 problem
04:54:04 <cow_2001> no base-4.8 yet
04:54:10 <dramforever> sigh
04:54:11 <cow_2001> 4.8.*, that is
04:54:25 <cow_2001> only 4.7.* installed
04:54:26 <cow_2001> oh well
04:54:57 <cow_2001> i could just create my own haddock docs
04:55:29 <shirt> how can i import qualified the current module? i get a "cyclic import" error
04:55:40 <phadej> Package maintainers and Hackage trustees are allowed to edit certain bits of package metadata after a release, without uploading a new tarball. Note that the tarball itself is never changed, just the metadata that is stored separately.
04:55:44 <phadej> but how?
04:56:02 <dramforever> shirt: you can't, what are you trying to do?
04:56:09 <zipper> sgronblo: I guess that's the idea of a sandbox.
04:56:21 <dramforever> oh maybe your module is defining functions with strange names
04:56:59 <zipper> cow_2001: What do you mean haddocks disappeared?
04:57:26 <shirt> my module declares a new name that conflicts with a name that i'm importing, so i need to use the new name qualified. but i don't want to type the whole module name, so i want to import it qualified
04:58:00 <dramforever> shirt: import ThatModule as ShortName
04:58:57 <dramforever> shirt: that will import the module that "you're importing" qualified *and* qualified
04:59:15 <merijn> dramforever: not really
04:59:19 <shirt> dramforever: i can't do that, because i'm using this template haskell function that expects ThatModule's names to be visible. (At least i think, i'm not an expert in TH)
04:59:22 <dramforever> oh sigh
04:59:24 <CrabbyCoconut> so, umm.. what is the recommended way to use Haskell platform now? I have tried 1> distro provided binary -> got conflict, 2> install a minimal set with cabal install, got parsec module not found when trying to upgrade cabal-install 3> using stack, there were several packages missing (from snap) and 4> using nixpkg, a bit too complicated when I just want to learn haskell 
04:59:24 <merijn> dramforever: You can always qualify, that just introduces an alias
04:59:29 <dramforever> qualified and unqualified
04:59:38 <merijn> dramforever: qualified imports means you can ONLY use qualified names
04:59:40 <dramforever> merijn: oh sorry I mean an alias
04:59:41 <dramforever> sorry
05:00:02 <CrabbyCoconut> it's quite frustrating that one approach might work, but very unreliable (2)
05:00:17 <dramforever> CrabbyCoconut: minimal set is pretty good
05:00:22 * dramforever uses that minimal set approach
05:00:23 <CrabbyCoconut> note that I use minimal + sandbox
05:00:27 <dramforever> ok then
05:00:37 <dramforever> there's no reason why that won't work
05:00:57 <dramforever> shirt: ThatModule's names *are* visable
05:01:11 <CrabbyCoconut> dramforever: I got this parsec module missing error, which I guess is due to distro provided parsec
05:01:21 <dramforever> oh sorry sorry it won't
05:01:23 <dramforever> sorry...
05:01:35 <shirt> dramforever: when i try importing ThatModule as qualified then i get a compile error on the template haskell line
05:01:46 * dramforever says a lot of "sorry"s in a quick succession
05:01:53 <safinaskar> extensible effects. why runReader definition is so difficult? http://hackage.haskell.org/package/extensible-effects-1.11.0.0/docs/src/Control-Eff-Reader-Lazy.html . please, explain me it. or say how to write simpler. i want to write my own reader effect
05:03:18 <liste> CrabbyCoconut distro provided stuff (Ubuntu at least) are very old
05:03:33 <liste> I use them for just bootstrapping
05:03:46 <dramforever> CrabbyCoconut: I wonder which minimal set are you refering to
05:04:54 <CrabbyCoconut> liste: I use OpenSUSE, the selection is quite up to date
05:05:17 <CrabbyCoconut> dramforever: er, I only use cabal-install from OpenSUSE repo 
05:05:30 <dramforever> I don't even use that from my repo
05:05:34 <dramforever> I download it myself
05:05:36 <CrabbyCoconut> if there is anything missing while upgrading cabal-install -> install in from repo too
05:05:54 <dramforever> get it here https://www.haskell.org/cabal/download.html
05:06:00 <dramforever> *I got
05:06:10 <dramforever> I downloaded the cabal-install binary download
05:06:25 <dramforever> there's a bootstrap.sh that sets up cabal-install pretty well
05:06:34 <CrabbyCoconut> hmm
05:06:44 <CrabbyCoconut> okay, thank, I will try again
05:07:13 <dramforever> CrabbyCoconut: there's one issue, though
05:07:30 <dramforever> you need to recompile the world if you ever update GHC
05:08:12 <CrabbyCoconut> dramforever: well, with sandboxing approach, I still have to recompile everything for each projects anyway..
05:08:14 <dramforever> if you get packages from repo, persumably they will be already compiled for you
05:08:20 <dramforever> CrabbyCoconut: good luck then
05:08:24 <CrabbyCoconut> okay, thank
05:08:57 * hackagebot debian-build 0.7.2.2 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.7.2.2 (KeiHibino)
05:09:14 <dramforever> interesting...hackagebot seems to know what we were just talking about
05:09:57 <CrabbyCoconut> :)
05:15:57 <sgronblo> How am I supposed to install a package from source with cabal?
05:16:22 <quicksilver> untar the source and type 'cabal install' from inside the source dir
05:16:46 <sgronblo> quicksilver: and where does the binary end up then?
05:17:06 <quicksilver> same place it normally does?
05:17:27 <sgronblo> ~/.cabal/bin?
05:18:50 <sgronblo> seems to be getting installed to the sandbox i had created
05:23:38 <safinaskar> how to write effects for extensible-effects? for example, i don't understand code for runReader in eff lib
05:31:55 <tsahyt> Is it possible to work with a join of two subqueries in esqueleto? The SQL would look something like "select ... from (select ...) as a, (select ...) as b where ...". The documentation is rather opaque to me to be honest, and I haven't found any way to do this yet. The only alternatives I have is using raw SQL (ouch) or finding a way to create a view for it on migration.
05:33:21 <rom1504> is there anything you can do with subqueries than you cannot do with joint ? I don't think so
05:33:45 <rom1504> *join
05:33:58 * hackagebot BufferedSocket 0.2.1.0 - A socker wrapper that makes the IO of sockets much cleaner  https://hackage.haskell.org/package/BufferedSocket-0.2.1.0 (tmore)
05:34:16 <dramforever> rom1504 ++
05:34:37 <tsahyt> I'm not sure but I haven't figured out a way to do it with a join. I need to group two different but related things into two groups before joining them and perform separate aggregation functions on the rows.
05:34:53 <tdammers> join twice?
05:35:03 <tsahyt> That resulted in messing up the grouping
05:35:38 <tsahyt> It's been years since I've used SQL, so I'm not quite up to par with it to be honest
05:43:57 <jura> Hello I have a question about the vector library?
05:45:36 <dramforever> ftfy d/?/
05:45:58 <dramforever> you don't need to ask to ask in #haskell
05:47:15 <merijn> I was gonna say "And you'd like us to guess what it is?", but I didn't wanna be mean :p
05:47:35 <dramforever> maybe jura is typing it (no pun intended)
05:55:21 <jura> ok thanks. My question is that the vector library represents Vector (a,b) as Vector a, Vector b. under the hood This is causing me a massive amount of pain because I am using zip quite often in my program. This causes a big slowdown because I am using (,) to pair data that will be used together, but since the data is stored in two different vectors, there is terrible cache performance because data that is used together is not stored 
05:55:22 <jura> together. So far I have gotten around the problem by writing instances for vector as described in this stackoverflow question: http://stackoverflow.com/questions/22882228/how-to-store-a-haskell-data-type-in-an-unboxed-vector-in-continuous-memory      but this requires a lot of code and I have to create a newtype instance for each (a,b) that I zip together. So I guess my question is there a better way to operate on Unboxed sequential 
05:55:22 <jura> data in Haskell?
05:56:45 <EvanR> jura: dont use (,) for that
05:56:57 <EvanR> make a new data type which has two fields, unboxed
05:57:08 <EvanR> and a storable instance so you can make a storable vector of them
05:57:52 <EvanR> basically this like C programming
05:58:00 <EvanR> you asked for it though
05:58:47 <merijn> EvanR: You'd need a new datatype for each combination of field types, though
05:58:59 * hackagebot fast-logger 2.4.1 - A fast logging system  https://hackage.haskell.org/package/fast-logger-2.4.1 (KazuYamamoto)
05:59:13 <jura> EvanR so I should be using Vector.Storable instead of Vector.Unboxed? Also when you say datatype would It be better to use newtype?
05:59:28 <EvanR> merijn: yeah
05:59:30 <merijn> jura: Newtypes can only have one field
05:59:47 <EvanR> you cant do polymorphic unboxed
06:00:26 <jura> yes, but the field can be a tuple and define the storable instance for the newtype to store the elements sequentially.
06:00:42 <EvanR> no no no
06:00:58 <jura> no?
06:01:08 <EvanR> newtype Triple x = Triple (x,x,x) ?
06:01:18 <EvanR> data Triple x = Triple x x x !
06:01:28 <merijn> The data is much better for performance
06:01:37 <merijn> Tuple == extra layer of indirection for the box
06:02:03 <merijn> Well, I guess you could have unbox the tuple, but still
06:03:08 <jura> are you sure? In my experience the newtype gets optimized better than the data for types that get constructed/destructed very often. 
06:03:15 <jura> You can't unbox the tuple
06:04:21 <EvanR> when its a newtype over a tuple or a record data types, its missing the point
06:04:37 <EvanR> at least for representation
06:04:39 <Philonous> The newtype is free, but you still have a tuple, which is just another data constructor
06:05:12 <jura> for example, If I have a Ray type consisting of a point x y z and a vec u v w and the Ray type really only gets created by one function and consumed by the next function, then the newtype performs much better than the data, even if the data is strict and unboxed.
06:05:29 <EvanR> newtype what?
06:06:19 <dramforever> oh
06:06:28 <dramforever> jura: yes you are right I think
06:06:35 <jura> newtype Ray (Point,Vec) performs better in data Ray = Ray  {-#UNPACK#-}!Point {-#UNPACK#-}!Vec
06:07:03 * EvanR skeptical
06:07:05 <jura> in situtions where it is created/consumed between functions
06:07:08 <dramforever> what about removing the UNPACK and bang?
06:07:17 <jura> Didn't try it
06:07:30 <EvanR> in any case you have to use the unboxed version to put it in a vector like you wanted
06:07:48 <dramforever> I think maybe that will allow ghc to optimize [that destructing Ray and constructing a tuple part] away
06:08:04 * dramforever sometimes uses [] to indicate sentence structure
06:08:06 <dramforever> FYI
06:09:17 <jura> EvanR I'm pretty sure you don't. 
06:09:59 <EvanR> if you dont want to unbox anything you dont have to i thought thats what you wanted
06:10:06 <EvanR> its way easier if you dont
06:10:49 <EvanR> in which case dont use newtype Foo = Foo (a,b) but... (a,b)
06:10:58 <jura> I mean't you can have data Ray = Ray Point Vec and have Point and Vec be boxed and STILL have instance Ray Unbox
06:11:14 <dramforever> jura: have you tried passing that around?
06:11:20 <EvanR> no you need a new data type
06:11:45 <dramforever> no I mean that boxed lifted Ray
06:12:50 <jura> I didn't benchmark it when I did so I can't recall if it was faster. I only benchmarked the difference between the strict data and the newtype
06:14:00 * hackagebot yesod-auth-oauth2 0.1.3 - OAuth 2.0 authentication plugins  https://hackage.haskell.org/package/yesod-auth-oauth2-0.1.3 (PatrickBrisbin)
06:14:02 * hackagebot tsvsql 0.1.1.0 - Template tsv into SQL  https://hackage.haskell.org/package/tsvsql-0.1.1.0 (DanielChoi)
06:14:09 <EvanR> jura: well passing thunks around and not using them might be faster than using strict fields and not using them
06:14:25 <EvanR> in a benchmark
06:15:20 <jura> that is a good point. This is numerical code and all in tight loop (ray tracing) so I did not think to benchmark the unstrict data because I assumed it would be slower.
06:17:56 <jura> I think I will first try to rewrite the code to avoid using zips, and then if I can't do that use Storable and write Storable instances for all the tuples. I already wrote unbox instances for all my data it can't be more painful than that ;)
06:18:35 <jura> thank you guys for the help
06:18:51 <tsahyt> How would I go about defining a view for a database that is automatically created when persistent performs the migration step? The way this is going now, this seems to be by far and wide the cleanest solution to my problem.
06:19:09 <dramforever> EvanR: actually I'm thinking with the boxed one ghc can optimize it away\
06:19:23 <dramforever> oh no more
06:19:35 <dramforever> [^ wrong channel]
06:19:56 <Philonous> tsahyt, I just run some custom SQL after the migration 
06:20:03 <dramforever> EvanR: ghc thinks "hey this guy is constructing a tuple and destructing it, get rid of that step"
06:20:12 <dramforever> but with the unboxed one ghc can't do that
06:20:39 <tsahyt> Philonous: Okay, thanks!
06:20:48 <jura> especially because all the functions inside the raytracing loop are inlined.
06:21:05 <dramforever> jura: profiling is very important
06:22:06 <Philonous> tsahyt, There's one problem though, if you have the view as an entity definition in the schema, persistent will try to create a table for it. I wrote a small snippet to avoid that, just a second
06:23:24 <Philonous> tsahyt, https://gist.github.com/Philonous/6d63ca960058c3065177
06:25:08 <tsahyt> Philonous: But that's only necessary when I put it into the persistent schema, right? I need it just to get a nice view on a bunch of tables containing data from various joins and aggregation functions, to the point where the queries get a little ridiculous. This way I can have it all in one place and then use much simpler queries to perform some final filtering depending on what data I need to provide to 
06:25:14 <tsahyt> the application.
06:25:55 <Philonous> tsahyt, Sure, but how are you going to use the view in esqueleto then?
06:27:48 <tsahyt> Philonous: That's a good point, yeah. I didn't think that far yet. So I just put it into the the schema such that the columns match the view that I create with a seperate SQL statement, so I have the corresponding types and constructors available, and use the filtering code above to prevent creating a new table?
06:28:18 <Philonous> tsahyt, Yep. 
06:29:01 * hackagebot Spock 0.8.1.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-0.8.1.0 (AlexanderThiemann)
06:30:20 <codedmart> I have this overlapping instance that compiles fine. This specific doctest passes on 7.10 but fails on 7.8. Can anyone explain why? http://lpaste.net/138505
06:34:18 <zipper> Is there a way to make travis wait longer than it usually does if your build usually takes a while?
06:34:49 <dramforever> zipper: weird, IIRC travis waits 50 minutes
06:35:12 <dramforever> is that not long enough, or there's another limit?
06:35:52 <zipper> Not like that
06:36:07 <dramforever> dunno about that then
06:36:08 <zipper> dramforever: For example here: https://travis-ci.org/urbanslug/wai-devel/builds/75262229
06:36:24 <zipper> I want it to wait for this package to build.
06:36:34 <dramforever> dunno...
06:36:41 <zipper> Thanks.
06:36:56 * dramforever is just trying to be helpful by ... wow you are internet-psychic?
06:37:06 <dramforever> by telling others what he knows
06:37:12 <dramforever> you're welcome
06:40:45 <hodapp> huh, I found http://okmij.org/ftp/Haskell/tr-15-04.pdf to be quite readable and clever, though I suspect that with extensions like DataKinds it'd be a bit shorter
06:45:27 <bennofs> hodapp: you might like reflection... be aware that it uses a trick though to make it much faster which relies on GHC implementation details
06:45:34 <bennofs> @hackage reflection
06:45:34 <lambdabot> http://hackage.haskell.org/package/reflection
06:45:40 <hodapp> bennofs: yeah, reflection is where I found this paper
06:46:07 <bennofs> hodapp: look at the fast path. it basically just uses unsafeCoerce to directly make a GHC dictionary argument from the value
06:46:17 <bennofs> that's clever :)
06:50:42 <lingxiao> hey all
06:50:49 <lingxiao> I have some question about System.Process
06:50:56 <lingxiao> and I am wondering if anyone here care to help me!
06:52:10 <grayen> Is there a way to use OverloadedStrings, but default to String when the type is ambiguous?
06:53:19 <grayen> lingxiao: That would depend on the question, what is it you would like to know?
06:53:42 <lingxiao> It's more of a not-informative error message issue
06:53:46 <lingxiao> I havea  unix exectuable file
06:54:13 <lingxiao> which outputs data in CSV format
06:54:19 <bergmark> grayen: ExtendedDefaultRules with default (String)
06:54:24 <lingxiao> I'd liek to run it
06:54:45 <lingxiao> so suppose the file is located at some path = "pathToFile/filename"
06:55:01 <lingxiao> and I do let o = readProcess path [] ""
06:55:15 <lingxiao> I get back Exception: readProcess pathToFile (exit 1): failed
06:55:21 <lingxiao> which is not every helpful at all
06:55:38 <grayen> bergmark: Awesome! I will look into that, thanks!
06:55:42 <dramforever> I think it can't be helpful
06:55:53 <dramforever> lingxiao: IIUC all the function know is "exit 1"
06:56:02 <lingxiao> sorry what's IIUC?
06:56:03 <dramforever> i.e. the program returned an error status
06:56:14 <dramforever> lingxiao: If I Understand Correctly
06:56:14 <lingxiao> yeah I'm just not sure what to do with it
06:56:18 <lingxiao> oh haha
06:56:53 <lingxiao> Now it does say the "program takes in a number of rows youd like returned as a command line argument:" ./program 10000
06:57:08 <lingxiao> but that's not relevant to me not being able to open the program
06:57:10 <lingxiao> I believe
06:57:29 <dramforever> nothing about open here
06:57:57 <lingxiao> yeah ... so I'm not sure what's wrong ..
06:58:18 <lingxiao> what are some typical problems that could occur in this situation?
06:58:29 <dramforever> lingxiao: program returned error
06:59:04 <lingxiao> so is it safe to assume the program is not working (for whatever reason)?
06:59:09 <grayen> lingxiao: What happens when you run the program from the command line?
07:02:07 <lingxiao> when I run ./ program
07:02:13 <lingxiao> I get -bash: ./: is a directory
07:02:28 <dramforever> why don't you remove the space?
07:02:36 <lingxiao> when I click on the program directly I get "program" can't be opened beacause it's from an unidentified developer
07:02:49 <lingxiao> sorry guys ... this isn't really a haskell question I suppose ..
07:03:02 <lingxiao> but is that why I can't open it in ghci
07:03:12 <dramforever> weird
07:03:30 <bergmark> lingxiao: osx i take it? system preferences > security & privacy > Allow apps downloaded from anywhere
07:03:55 <dramforever> maybe that's no good
07:04:12 <ski> dramforever suggested you try `./program' instead of `./ program'. does that also error ?
07:04:24 <dramforever> I guess si
07:04:25 <dramforever> *so
07:04:38 <lingxiao> ahhh ... got it!
07:04:41 <lingxiao> thanks guys!
07:04:56 * ski blinks
07:05:04 <tdammers> kind of stupid how many end-user OSes give you only the choices "stay completely inside the walled garden" or "throw all security measures out the window"
07:05:07 * dramforever stares at lingxiao
07:05:19 <tdammers> but not, "trust this authority as well as the preprogrammed one"
07:05:36 <dramforever> tdammers: I guess it's possible, just harder than usual
07:05:40 <dramforever> example: selinux
07:05:46 <dramforever> *often possible
07:06:14 <tdammers> hmm, I wasn't really referring to Linux distros... those tend to have pretty OK mechanisms in place
07:06:28 <lingxiao> lol yeah ... at no point did I even think my OS was doing that thing again
07:06:31 <dramforever> many people complain that "hey this selinux thing prevented apache from reading my custom www directory" yes that's by design
07:06:45 <tdammers> oh, that, yes
07:08:56 <aweinstock> dramforever: is allowing apache to read a specific directory (and presumably all subdirectories) a simple thing to do with selinux (e.g. a few lines of config files)?
07:09:45 <dramforever> dunno, maybe involves creating a new apache selinux-user and confining apache or something
07:09:49 <dramforever> dunno
07:10:03 <dramforever> but it's definitely worth it
07:15:23 <lingxiao> ok one more question please ...
07:15:36 <lingxiao> so now when I do something like (m1,m2,m3,p) <- createProcess $ proc path ["10"]
07:15:51 <lingxiao> I see that m1,m2,and m3 are all Nothing
07:16:08 <lingxiao> and running that line in ghci just gives me the output from the program
07:16:27 <dramforever> I think you need something better than just proc
07:16:34 <lingxiao> I thought the output should be in m2, which is 
07:16:36 <dramforever> look around in the module docs
07:16:41 <lingxiao> Just stdout
07:16:46 <lingxiao> ok got you
07:16:53 <muesli4> lingxiao: If you run that line, m1, m2, m3 and p should be bound.
07:16:57 <muesli4> in ghci
07:17:06 <dramforever> muesli4: no different problem
07:17:17 <dramforever> m1 is bound to Nothing
07:17:20 <dramforever> which is unexpected
07:18:03 <xhal> ?wiki Monad
07:18:03 <lambdabot> http://www.haskell.org/haskellwiki/Monad
07:18:20 <muesli4> dramforever: well he said that running that line just gives him the output, but it actually also binds m1, m2, m3 and p
07:18:50 <dramforever> yes, but m1 m2 m3 are all bound to Nothing, the value
07:18:51 <lingxiao> hmm.. dramforever what does it mean when you say "better"?
07:18:53 <dramforever> which is unexpected
07:19:13 <aweinstock> you need to tell createProcess to create pipes for stdin/stdout/stderr
07:19:16 <dramforever> lingxiao: there must be something configuration thing
07:19:19 <lingxiao> muesli4 sorry I wasn't clear, I'm saying m1 ... m3 are all Nothing as well
07:19:20 <xhal> @help
07:19:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:20:22 <muesli4> lingxiao: have you tried using createProcess_ ?
07:20:44 <aweinstock> lingxiao: addPipes cfg = cfg { std_in = CreatePipe, std_out = CreatePipe, std_err = CreatePipe }
07:21:09 <lingxiao> muesli4 sorry createProcess_ with an underscore is not in my System.Process?
07:21:35 <aweinstock> lingxiao: (m1,m2,m3,p) <- createProcess . addPipes $ proc path ["10"]
07:21:41 <muesli4> lingxiao: http://hackage.haskell.org/package/process-1.2.3.0/docs/System-Process.html#v:createProcess
07:23:05 <grayen> I am still getting the same error about ambiguity with both OverloadedStrings and ExtendedDefaultRules, what am I missing? No instance for (IsString a1) arising from the literal " not found in ". The type variable a1 is ambiguous.
07:23:58 <aweinstock> grayen: do you have an lpaste link?
07:23:59 <muesli4> lingxiao: you need version 1.2.1.0 of process
07:24:08 <geekosaur> grayen, we'd have to see the context (i.e. what code is around it). sometimes it's a function which just declares it wants some kind of string, and there is no defaulting for strings
07:24:22 <geekosaur> an example in the context of numbers is 
07:24:25 <geekosaur> :t (^)
07:24:27 <lambdabot> (Integral b, Num a) => a -> b -> a
07:24:46 <geekosaur> that "b" gets defaulted (with a warning in modern ghc) because it can never be inferred
07:25:03 <geekosaur> similar if something does that with IsString, except there's no defaulting
07:25:09 <geekosaur> so it errors like you got
07:25:11 <bz> fromEnum really should :: (Integral b, Enum a) => a -> b
07:25:59 <grayen> I will post an lpaste link
07:28:09 <lingxiao> ok will do that muesli4 thanks!
07:28:17 <lingxiao> aweinstock that worked!
07:28:18 <lingxiao> Thank you!
07:28:27 <lingxiao> now that it works .. could I ask you what was wrong before?
07:28:35 <muesli4> lingxiao: I actually talked shit, sry.
07:28:44 <lingxiao> lol huh
07:28:44 <lingxiao> ?
07:29:08 <geekosaur> language, please
07:29:56 <muesli4> lingxiao: As already said, you have to supply within the CreateProcess record, that you want to create those handles.
07:31:45 <muesli4> geekosaur: I apologize, not a native english speaker, wasn't meant in an offensive way.
07:32:01 <lpaste_> grayen pasted OverloadedStrings default at http://lpaste.net/138586
07:32:41 <geekosaur> right, that's just lack of defaulting
07:33:22 <geekosaur> Haskell's defaulting mechanism can't handle [Char] type strings at all, so it can't provide a default --- so somewhere in there it needs to have a specific IsString instance specified
07:33:44 <geekosaur> easiest is just to annotate the literal: ("this is a test: " :: Text) or whatever
07:34:01 <geekosaur> (or String or ByteString or whatever)
07:34:59 <grayen> So there is no way around the boilerplate code of either annotating the strings where there is no default, or annotating all strings to begin with (no OverloadedStrings)?
07:35:14 <geekosaur> not currently
07:35:28 <geekosaur> there's been some discussion of how to fix defaulting
07:36:20 <geekosaur> but [Char]-type strings turn out to complicate things and all the mechanisms discussed have problems as a result :/
07:36:52 * geekosaur looks for pointer to discussion
07:36:56 <grayen> Ok, is only some boilerplate code, no big deal, I just always aim to remove as much boilerplate as possible, and was hoping there was already something available in the latest version.
07:39:02 <bz> ghci
07:39:04 <aweinstock> geekosaur: would NoMonomorphismRestriction fix/band-aid grayen's problem with OverloadedStrings?
07:39:04 * hackagebot lzma-conduit 1.1.3.0 - Conduit interface for lzma/xz compression.  https://hackage.haskell.org/package/lzma-conduit-1.1.3.0 (NathanHowell)
07:40:11 <geekosaur> aweinstock, not really --- at some point the compiler *must* commit to some specific type so it knows what code to emit
07:40:57 <geekosaur> the (^) issue doesn't involve the monomorphism restriction, for example
07:41:27 <geekosaur> (where it can't type the 'b', so (2 ^ 3) issues a warning about defaulting the 3 to Integer)
07:43:24 <hackrilege> @let fact a b = if a == b then a else fact a ((a + b) `div` 2) * fact ((a + b) `div` 2 + 1) b
07:43:26 <lambdabot>  Defined.
07:43:38 <hackrilege> >fact 1 50
07:44:01 <hackrilege> > fact 1 20
07:44:01 <ski> > fact 1 50
07:44:03 <lambdabot>  <no location info>: can't find file: L.hs
07:44:03 <lambdabot>  30414093201713378043612608166064768844377641568960512000000000000
07:45:45 <hackrilege> i guess i want to put fork IO somewhere in this and distribute the work over several peocessors.. but im not sure how to do mpi like calls (mpiGather, mpiBroadcast) in haskell as I failed to get the haskell-mpi library working...
07:46:03 <hackrilege> it depends on the C library MPI which I would rather emulate than depend on
07:46:28 <apankiv> fact 2 34
07:46:36 <apankiv> >fact 2 34
07:46:42 <hackrilege> does anyone have any experience with Control.Concurrent?
07:46:49 <Intolerable> hackrilege: https://github.com/intolerable/haskell-mpi
07:47:04 <hackrilege> > fact 2 34
07:47:06 <lambdabot>  295232799039604140847618609643520000000
07:47:09 <Intolerable> that will probably work on more recent versions of ghc
07:47:11 <hackrilege> outch, sorry Intolerable
07:47:20 <Intolerable> but what are you actually trying to do with Control.Concurrent?
07:47:32 <hackrilege> MPI
07:47:43 <Intolerable> if you're trying to parallelize something, Control.Concurrent is not what you want
07:47:54 <Intolerable> see if you can get that haskell-mpi to compile
07:48:05 <geekosaur> there are a number of things where you are better off binding to an existing tested solution than trying to write it yourself
07:48:05 <Intolerable> i haven't used it in ~8 months
07:48:07 <hackrilege> can i get an explanation I could give to other users who advised that I do?
07:48:11 <geekosaur> especially if you want to interoperate
07:48:50 <Intolerable> i have an working example of the mpi library if you want to take a look at that
07:50:05 <Intolerable> hackrilege: https://github.com/intolerable/mpi
07:50:47 <hackrilege> i do want to interpolate
07:51:17 <hackrilege> i cant build mpi for windows in a way that is understood by this haskell-mpi library
07:52:02 <hackrilege> missing, open-rte, openpal, mpi
07:52:14 <Intolerable> oh, windows
07:52:15 <Intolerable> rip
07:52:21 <MHD1> What's a good way to obtain the haskell platform w/ GHC version 7.10.2-a on ubuntu, when the repos only sport 7.6.3
07:52:54 <hackrilege> anyway, id really rather not depend on an external library, even one written in pure haskell. the aim of my work is to show how to use haskell to do the stuff... 
07:52:58 <ChristianS> MHD1: download and install manually?
07:52:58 <Lokathor> you can download a linux build directly and unpack it MHD1 
07:53:09 <lpaste_> bealhorm pasted Difference in execution, Non-exhaustive patterns in function at http://lpaste.net/138589
07:53:11 <Intolerable> hackrilege: what exactly are your goals?
07:53:37 <MHD1> Should I build from Source or choose precompiled generic?
07:53:53 <hackrilege> i will release an open source code to run a polymer growth simulation on various supercomputer platforms
07:53:54 <grayen> geekosaur, aweinstock: I got it working!
07:54:12 <hackrilege> I have 3 years of funding
07:54:59 <bealhorm> I don't see the difference in execution between the two codes, and why one of them is a non-exhaustive pattern. http://lpaste.net/138589
07:55:10 <ChristianS> MHD1: i installed ghc from source but note that that'll take quite a while
07:55:16 <lpaste_> grayen pasted Working OverloadedString default at http://lpaste.net/138590
07:55:21 <bealhorm> I only see the difference in adressing the two conditions
07:55:26 <MHD1> ChristianS: Ok
07:56:00 <geekosaur> bealhorm, what happens when the first parameter is [] and the second is not?
07:56:22 <bealhorm> As in expected output or actual output? And for what function?
07:56:27 <Intolerable> bealhorm: [] [_] _ _ is not matched
07:56:41 <geekosaur> as in what Intolerable just said
07:56:46 <geekosaur> what happens is the error you got :)
07:56:53 <Intolerable> if you turn on exhaustiveness checking, it should tell you
07:56:55 <bealhorm> ah yes, the case when there is only one item left
07:57:10 <bealhorm> exhaustiveness checking, is that in hlint?
07:57:24 <Intolerable> -fwarn-incomplete-patterns
07:57:26 <Intolerable> iirc
07:57:31 <bealhorm> Thank you very much
07:57:39 <Intolerable> (in ghc, not hlint)
07:58:00 <bealhorm> So the reason the second implementation uses the case of variant is to prevent individually addressing the single element list?
07:58:55 <hackrilege> Intolerable, im not sure what you were asking "what exactly are your goals", today I would like to run haskell over 4 cores, demonstrating the major types of paralell data communication between threads, e.g. broadcast gather and case statements depending on processor rank 
07:59:41 <hackrilege> but as you say, i cant use haskell-mpi on windows, so it does not look like a good solution
08:00:08 <hackrilege> id like then to implement e.g. mpiBroadcast, in some other communication paradigm
08:01:11 <hackrilege> i was asking about how to do this with Control.Concurrent which apparently has similtanious thread execution and blocking and non blocking thread communication and is alread used to make haskell server instances which must run simultaniously, and it works great...
08:02:32 <lingxiao> hey all 
08:02:50 <lingxiao> I'd like to scan over an arbitrarily large list and compute some statisics
08:03:04 <Intolerable> what kind of statistics?
08:03:07 <lingxiao> like how many times foo apear, what is the maximum/min/average value ..
08:03:21 <lingxiao> and I'm looking for a library ...
08:03:26 <Intolerable> hackage foldl
08:03:30 <hackrilege> perhaps it would be helpful if you could tell me why I shuld not try to use this package and why it is unsuitable, and maybe if you know of a better one, I would really like to know about it! I guess in the end I will be rewriting MPI in pure haskell. If you wrote the haskell-MPI library, perhaps you know the pitfalls or imposibilities I may face...
08:03:30 <Intolerable> @hackage foldl
08:03:30 <lambdabot> http://hackage.haskell.org/package/foldl
08:03:50 <Intolerable> hackrilege: i didn't write it, i just updated it for 7.10
08:03:50 <geekosaur> hackrilege, Control.Current is largely lower level stuff. You might want to look at
08:03:54 <geekosaur> @hackage async
08:03:54 <lambdabot> http://hackage.haskell.org/package/async
08:03:58 <hackrilege> :type scan
08:04:08 <geekosaur> er Control.Concurrent
08:04:10 <hackrilege> :type scanl1
08:04:18 <geekosaur>  :t or @type
08:04:20 <hackrilege> sorry...
08:04:25 <lingxiao> oh I meant if there are libraries that do all these things efficiently already .. so I don't have to roll my own
08:04:28 <hackrilege> :t scan
08:04:29 <lambdabot>     Not in scope: scan
08:04:29 <lambdabot>     Perhaps you meant one of these:
08:04:29 <lambdabot>       scanl (imported from Data.List),
08:04:41 <hackrilege> :t scanl
08:04:43 <lambdabot> (b -> a -> b) -> b -> [a] -> [b]
08:04:51 <hackrilege> so looks like he is after Data.List
08:05:02 <saml> how can I get infinite string of random choice from a set of chars?
08:05:04 <Intolerable> lingxiao: the foldl library is probably what you want
08:05:15 <Intolerable> you can build a Fold in there and run it over your list
08:05:24 <Intolerable> and it will efficiently compute the statistics for you
08:05:39 <saml> @hoogle [a] -> a
08:05:40 <lambdabot> Prelude head :: [a] -> a
08:05:41 <lambdabot> Data.List head :: [a] -> a
08:05:41 <lambdabot> Prelude last :: [a] -> a
08:05:47 <Intolerable> http://hackage.haskell.org/package/foldl-1.1.1/docs/Control-Foldl.html
08:06:08 <hackrilege> saml: maybe you could access a random element of a list, use System.Random to generate random integers in range
08:07:03 <Gurkenglas> Why did that package choose to use left folds rather than right folds?
08:07:13 <breadmonster> Hello everyone.
08:07:25 <hackrilege> saml: maybe you could make a list of IO functions returning a random IO Char
08:07:29 <saml> > (generate . elements) [1, 2, 3]
08:07:31 <lambdabot>  <IO Integer>
08:07:36 <saml> how can I run IO monad?
08:07:51 <Intolerable> hello breadmonster
08:08:19 <rlewis> saml by naming it main and compiling and then running your program
08:08:25 <hackrilege> hi breadmonnster
08:08:30 <saml> not in lambdabot?
08:08:42 <Welkin> saml: lambdabot does not do IO
08:08:55 <hackrilege> rlewis: I think actually you can do things like concatinating [IO Char] -> IO String
08:08:59 <Intolerable> also don't do that, it will give you awful results
08:09:16 <Intolerable> :t randomR
08:09:17 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
08:09:22 <Intolerable> :t randoms
08:09:24 <lambdabot> (RandomGen g, Random a) => g -> [a]
08:09:46 <hackrilege> but all the random stuff is IO?
08:09:58 <Intolerable> create a newtype with a Random instance that returns a random character
08:10:25 <Intolerable> hackrilege: no its not?
08:10:28 <Intolerable> :t random
08:10:31 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
08:10:38 <ski> > randomRs (0,9) (mkStdGen 142857)  --  hackrilege ?
08:10:38 <Intolerable> that's pure
08:10:40 <lambdabot>  [3,9,0,5,3,1,4,8,0,7,1,0,0,1,5,7,8,4,7,1,0,0,4,3,7,4,6,2,6,7,6,7,5,0,9,4,5,4...
08:10:56 <Intolerable> > randomRs (0,9) (mkStdGen 142857)
08:10:59 <lambdabot>  [3,9,0,5,3,1,4,8,0,7,1,0,0,1,5,7,8,4,7,1,0,0,4,3,7,4,6,2,6,7,6,7,5,0,9,4,5,4...
08:11:03 <ski> repeatable
08:11:08 <Intolerable> no io / nondeterminism there
08:11:27 <ski> @help run
08:11:27 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
08:11:30 <geekosaur> hackrilege, there are two things in System.Random that require IO: (a) getting an initial random seed (b) using the "default" stored seed/generator, which is in IO
08:11:40 <breadmonster> > print $ (generate . elements) [1, 2, 3]
08:11:41 <lambdabot>  <IO ()>
08:11:54 <hackrilege> http://lpaste.net/138593
08:12:00 <geekosaur> if you carry the seed around yourself (often in a State / StateT, or MonadRandom) then the only time you need IO is that initial seed value
08:12:11 <breadmonster> Has someone upgraded lambdabot?
08:12:20 <ski> @type generate
08:12:20 <geekosaur> @version
08:12:21 <lambdabot> Gen a -> IO a
08:12:21 <lambdabot> lambdabot 5.0.2.2
08:12:21 <lambdabot> git clone https://github.com/lambdabot/lambdabot
08:12:37 <ski> breadmonster : i don't think you want to `print' that, in lambdabot or otherwise ..
08:13:01 <Intolerable> :t generate . elements
08:13:02 <ski> (well, or you want `(print =<<)', perhaps)
08:13:02 <lambdabot> [a] -> IO a
08:13:25 <ski> @type (print =<<) . generate . elements
08:13:25 <breadmonster> > do { a <- (generate . elements) [1, 2, 3]; print a } 
08:13:26 <lambdabot> Show a => [a] -> IO ()
08:13:27 <lambdabot>  <IO ()>
08:13:30 <Intolerable> @hoogle generate
08:13:31 <lambdabot> Test.QuickCheck.Gen generate :: Gen a -> IO a
08:13:31 <lambdabot> Test.QuickCheck generate :: Gen a -> IO a
08:13:31 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Parameters generateMipmap :: ParameterizedTextureTarget t => t -> StateVar Capability
08:13:43 <breadmonster> :t generate . elements 
08:13:45 <lambdabot> [a] -> IO a
08:13:50 <breadmonster> :t generate . elements [1,2,3]
08:13:52 <lambdabot>     Couldn't match expected type a -> Gen a1
08:13:52 <lambdabot>                 with actual type Gen Integer
08:13:52 <lambdabot>     Possible cause: elements is applied to too many arguments
08:13:57 <Intolerable> :t unGen
08:13:59 <lambdabot> Not in scope: unGen
08:14:04 <breadmonster> :t (generate . elements) [1,2,3]
08:14:06 <lambdabot> Num a => IO a
08:14:21 <breadmonster> :t (>>=) (generate . elements) [1,2,3 :: Int]
08:14:22 <lambdabot>     Couldn't match expected type IO a -> [a] -> b
08:14:23 <lambdabot>                 with actual type [Int]
08:14:23 <lambdabot>     In the second argument of (>>=), namely [1, 2, 3 :: Int]
08:14:29 <breadmonster> :t (>>=) ((generate . elements) [1,2,3 :: Int])
08:14:30 <lambdabot> (Int -> IO b) -> IO b
08:14:39 <hackrilege> Intollerable, can you see any reason haskell would not be able to emulate the C MPI libraries completely in pure haskell?
08:14:49 <Intolerable> no, but it's a huge undertaking
08:14:56 <ski> breadmonster : perhaps you want to continue in private, unless there's something you want to show, or ask about ?
08:14:59 <Intolerable> and it would likely be slower unless you definitely know what you are doing
08:15:13 <hackrilege> Intolerable, I need only implement the functionality I require...
08:15:14 <Flonk> breadmonster: you can always just /query lambdabot
08:15:16 <breadmonster> ski: Alright, yeah, I'm just trying to figure out why I can't get lambdabot to print the answer...
08:15:36 <Intolerable> hackrilege: it will still be a huge amount of effort and inefficient
08:15:44 <geekosaur> because the result is in IO and lambdabot will not run IO actions
08:15:57 <hackrilege> basically the whole project is just a lens on a cyclic tree in paralell
08:16:01 <Intolerable> your time would likely be better spent getting haskell-mpi working on whichever platform you need
08:16:11 <hackrilege> Inefficeincy is not permisable]
08:16:29 <geekosaur> then you're still better off binding to a working library
08:16:35 <Slay> hey. is it possible to put guards inside if..then..else? or are they only allowed at the start of a function?
08:16:37 <geekosaur> instead of debugging your own
08:16:43 <breadmonster> Has anyone implemented dancing links in Haskell?
08:16:46 <hackrilege> I dont understand fundamentally why haskell should fail compared to C for this task
08:16:58 <Intolerable> Slay: MultiWayIf 
08:17:18 <geekosaur> hackrilege, it doesn't "fail". it does usually require figuring out where to be properly strict and properly lazy to avoid inefficiency in time or space (i.e. memory)
08:17:20 <ski> Slay : you can also do `case () of () | blah -> ... | bleh -> ...'
08:17:32 <geekosaur> especially with concurrency which most people find difficult to reason about / around anyway
08:17:42 <Intolerable> hackrilege: it won't, but there has been a lot of manpower put into MPI and replicating it will be incredibly difficult
08:17:47 <geekosaur> which is why you benefit from using something already known to work and bind to it
08:18:07 <hackrilege> geekosaur, as my project is educational, I should communicate full understanding of all considerations. I will be rewriting all of my dependencies in a minimal way to show exactly how small the program needs to be, and not depend on illegible behemoth libraries
08:19:07 * hackagebot sets 0.0.2 - Various set implementations in Haskell  https://hackage.haskell.org/package/sets-0.0.2 (athanclark)
08:19:22 <hackrilege> geeokosaur, your description of the challanges are actually pretty inciting... though I would not have time to offer a complete package, maybe I can get my accessor methods running quickly. 
08:20:36 <hackrilege> I can put some time to benchmarking simple comparisons to the pure version of a simple broadcast 
08:21:27 <hackrilege> i can get haskell-mpi working on linux, but im trying to provide a platform interdependent sollution, so pure haskell which builds on windows is actually more or less essential  
08:22:12 <Slay> ski : this is my current(non compilable) code - http://lpaste.net/138595  . whats the proper way to do it? case..of.. doesnt seem to be possible in this situation. do I really need an extension as suggested by Intolerable ?
08:23:05 <hackrilege> is it the compilers fault i will create slower programs? i really dont get it..
08:23:25 <Intolerable> the case () of () works fine
08:23:26 <ski> Slay : `case'-`of' is available without extensions
08:23:26 <Intolerable> one second
08:23:37 <geekosaur> hackrilege, I don't see where that question came from
08:23:56 <Intolerable> Slay: http://lpaste.net/138595
08:24:04 <Intolerable> if u dont want MultiWayIf
08:24:50 <ski> Slay : also, your `if lx /= tx || ly /= tx then ... else return ()' there could be `when ((lx,ly) /= (tx,tx)) $ ...' (should one of those `tx's be `ty' ?)
08:24:53 <Slay> Intolerable thanks. Im trying to learn basic haskell for now :)
08:25:38 <Slay> ski oh thats right, thanks
08:25:50 <quchen2> Intolerable: You can leave most of the () away for less clutter: http://lpaste.net/138597
08:26:02 <quchen2> That, and change the "=" to "->"
08:26:06 <ski> Slay : instead of `dir /= ""', it's more idiomatic to say `not (null dir)' (probably doesn't matter in this case, but this is more general, doesn't assume you have equality on the list elements)
08:27:06 * ski would probably use (a single) `()' instead of the `_' .. just because of personal taste
08:27:19 <Intolerable> but what about undefined
08:27:21 <Intolerable> ;)
08:27:38 <Slay> heh thanks a lot for all the suggestions :)
08:27:44 <ski> Slay : instead of `loop lx ly tx+1 ty-1' you possibly mean `loop lx ly (tx+1) (ty-1)' (similar for other cases)
08:28:11 <Slay> ski do the parantheses matter?
08:28:28 <ski> yes
08:28:38 <Slay> alright.
08:28:56 <ski> Slay : `loop lx ly tx+1 ty-1' will be interpreted as `(loop lx ly tx)+(1 ty)-1', which is probably not what you want
08:29:07 * hackagebot sets 0.0.2.1 - Various set implementations in Haskell  https://hackage.haskell.org/package/sets-0.0.2.1 (athanclark)
08:29:09 * hackagebot git-annex 5.20150812 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20150812 (JoeyHess)
08:29:11 * hackagebot stack 0.1.3.1 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-0.1.3.1 (borsboom)
08:30:01 <ski> Slay : btw, in your case, i might use something like :
08:30:21 <ski>   case (tx `compare` lx,ty `compare` ly) of
08:30:41 <ski>     (LT,EQ) -> loop lx ly (tx+1)  ty
08:30:49 <ski>     (LT,GT) -> loop lx ly (tx+1) (ty-1)
08:30:54 <ski>     ...
08:31:24 <Slay> looks pretty cool
08:31:40 <ski> Slay : this way, the comparisions between `tx' and `lx', and between `ty' and `ly' aren't redone while it's trying to find which alternative to choose
08:32:05 <hackrilege_> geekosaur: sorry i got disconnected: my question was why pure haskell will be slower than using the C MPI libraries to do communication between processors. unless there is a performance drop, I would like to implement the communication myself
08:32:09 <ski> Slay : `LT' meaning "Less Than", `EQ' "EQual", and `GT' "Greater Than"
08:32:18 <SwashBuckla__> Is there a Haskell way to test a datastructure for properties as in this (if .. else if... else if...) chain? https://github.com/spanners/udacity-homeworks/blob/master/cs212/unit1/jokers.py#L83-L103
08:32:25 <Slay> then thats probably the right way to do it :)
08:32:56 <SwashBuckla__> I usually know how to model this kind of code but the FP way of doing this escapes me at the moment
08:33:02 <geekosaur> hackrilege_, it's not going to be slower because of the compiler. it's going to be slower because you do not have years to optimize the code to match the years of optimization applied to the C one
08:33:17 <Intolerable> hackrilege_: there will not be a slowdown because of the language, there will be a slowdown because there is colossally more time invested in MPI to improve its performance
08:33:39 <hackrilege_> improvment in the compiler?
08:33:48 <Intolerable> SwashBuckla__: try asum
08:34:17 <frerich> SwashBuckla__: That is already very close to functional code.
08:34:25 <Intolerable> if you give it a list of Maybes to evaluate, it'll return you the first one which is Just
08:34:35 <juanpaucar> has anyone ever tried to build something with GTK?
08:34:35 <Intolerable> > asum [ Just 5, Just 6, Nothing ]
08:34:37 <lambdabot>  Just 5
08:34:40 <Intolerable> > asum [ Nothing, Just 5, Just 6, Nothing ]
08:34:42 <lambdabot>  Just 5
08:34:58 <hackrilege_> can you give me a tangible description of such an improvment? 
08:35:17 <geekosaur> not to mention debugging corner cases and such which was done long ago with the C one and you will have to do yourself for a reimplementation. certainly you can do it, but you will be reinventing form scratch a wheel that has already been polished an optimized over years by many people
08:35:53 <SwashBuckla__> frerich: hmm okay
08:35:55 <Intolerable> > let f x = asum [ guard (x > 5) *> return 5, guard (x < 9) *> return 9 ]
08:35:57 <lambdabot>  <no location info>:
08:35:57 <lambdabot>      not an expression: let f x = asum [ guard (x > 5) *> return 5, guard (x...
08:36:02 <Intolerable> > let f x = asum [ guard (x > 5) *> return 5, guard (x < 9) *> return 9 ] in f 8
08:36:03 <lambdabot>      No instance for (Show (f0 a0))
08:36:04 <lambdabot>        arising from a use of show_M35349295534436069510082
08:36:04 <lambdabot>      The type variables f0, a0 are ambiguous
08:36:14 <Intolerable> > let f x = asum [ guard (x > 5) *> return 5, guard (x < 9) *> return 9 ] in f 8 :: Just Int
08:36:16 <lambdabot>      Expected a type, but Just Int has kind Maybe *
08:36:16 <lambdabot>      In an expression type signature: Just Int
08:36:16 <lambdabot>      In the expression: f 8 :: Just Int
08:36:16 <hackrilege_> i think im close to understanding you, but i cant grasp what these optimizations are...
08:36:29 <SwashBuckla__> frerich: so should I just use a bunch of `if.. else if...` in Haskell too?
08:36:34 <geekosaur> that might be part of the problem...
08:36:38 <Intolerable> > let f x = asum [ guard (x > 5) *> return 5, guard (x < 9) *> return 9 ] in f 8 :: Maybe Int
08:36:40 <lambdabot>  Just 5
08:36:43 <frerich> SwashBuckla__: You could. Or you use guards ,something like http://lpaste.net/138599
08:36:46 <geekosaur> do you have any experience with large software projects?
08:36:46 <hackrilege_> i think so
08:36:54 <geekosaur> do you have any experience with concurrent programming?
08:36:57 <hackrilege_> yes
08:37:09 <frerich> SwashBuckla__: The Python code is already where 'functional', so it would be just a syntax translation.
08:37:24 <hackrilege_> i used forkIO to run servers simultaniously
08:37:58 <hackrilege_> I have never tried to communicate between threads, which I thought I was about to embark upon
08:38:00 <geekosaur> (I don;t have much of the latter so I am the wrong person to ask about specifics. But I've enough experience to have seen --- and indeed directly experienced --- the other, many times. it's just part of software life cycle)
08:38:49 <hackrilege_> id just like to know why I am destined to fail, and if it surmountable
08:38:49 <Intolerable> hackrilege_: this is a REALLY bad project to jump into if you've never done any inter-thread communication before
08:39:04 <hackrilege_> its what I must do next
08:39:08 * hackagebot tempus-fugit 0.1.0.1 - Programmers' time tracker  https://hackage.haskell.org/package/tempus-fugit-0.1.0.1 (kadoban)
08:39:34 <Intolerable> building something this complex never having made two threads communicate is an awful idea
08:39:42 <Intolerable> start with something simple, and work up from there
08:39:59 <hackrilege_> my task is actually very small, but If it will not be fast when I do it then I will struggle to defend haskell for this application
08:40:15 <Intolerable> i'm not trying to dissuade you here, and i'm all for building something from scratch, but i think you're vastly underestimating the amount of work required for what you seem to want
08:40:31 <Intolerable> what *exactly* is your task
08:40:34 <hackrilege_> Intolerable, the basic MPI functionality is small in my mind
08:40:50 <hackrilege_> ok, 1 sec
08:41:06 <geekosaur> hm, wait.
08:41:12 <Intolerable> the basic functionality may be simple, but getting it to be fast and reliable is not
08:41:19 <geekosaur> you are doing stuff between threads in the same program?
08:41:46 <geekosaur> isn't one of the points of MPI generalizing that not only across processes but across machines (highly linked supercomputing clusters)?
08:41:51 <geekosaur> MPI may be overkill
08:42:00 <geekosaur> maybe you just want async as I suggested earlier
08:42:08 <hackrilege_> Suppose I had a linked list with some branches, but only few, I wish to fold this list with a function which explores its local neighbours with some function and returns a subtree which I will fold over
08:42:33 <Intolerable> the function itself is not really the complicated part here
08:42:40 <Intolerable> as long as it is parallelizable you should be fine
08:42:49 <hackrilege_> geekousaur: I think async would be good, but maybe it wont be suitable as I must run on very many cores
08:42:51 <Intolerable> the architecture you want is the complicated bit
08:43:02 <Intolerable> how many machines do you want to be using
08:43:05 <hackrilege_> xenon
08:43:08 <Intolerable> what kind of machines
08:43:08 <hackrilege_> 64
08:43:19 <hackrilege_> intel cores
08:43:19 <Intolerable> not the machine arch
08:43:25 <Intolerable> the architecture of the entire system
08:43:57 <hackrilege_> x64? no im confused my your question
08:43:58 <hackrilege_> by*
08:44:08 * hackagebot sets 0.0.2.2 - Various set implementations in Haskell  https://hackage.haskell.org/package/sets-0.0.2.2 (athanclark)
08:44:20 <Intolerable> are you going to be running it on one machine?
08:44:26 <Gurkenglas> Slay, I would also do this: http://lpaste.net/138595 - Do the recursing part in some further-up function. Some further refactoring would probably allow you to pull the Just out to the return; and at some point you could use monad transformers to replace steps type with "Int -> Int -> StateT (Int, Int) (MaybeT IO) ()" and get neatness like the forever function automatically doing the looping you wanted
08:44:34 <Intolerable> or will it be on a cluster of machines?
08:44:50 <hackrilege_> Intolerable, I will be running it on a head node which can access 64 cores of slave cpu
08:45:09 <hackrilege_> normally i would use mpiexec or mpirun
08:45:09 <hackrilege_> -n
08:45:22 <Intolerable> use MPI in haskell then
08:45:51 <Intolerable> you are very much into "too complex for a one man job" territory
08:45:52 * Clint grumbles.
08:45:53 <hackrilege_> why not just do it in haskell?
08:46:18 <hackrilege_> I really cant see how that would be the case, can you tell me why?
08:46:25 <Gurkenglas> (Slay, of course what is to the right of the Justs is wrong, as I now notice. Just so you won't wonder.)
08:47:39 <hackrilege_> because haskell has no way of driving these slave processors? or there is no way of linking together haskell threads and communication between different cpus (which could be simply emulated on 1 cpu)
08:47:49 <Intolerable> because even getting a basic subset of MPI functionality working will take an incredibly huge effort
08:47:55 <Gurkenglas> (What I meant to do was http://lpaste.net/138600 )
08:48:25 <Intolerable> sure, it's possible to do, but if you have never made two threads communicate you will find it incredibly difficult
08:49:07 <Slay> Gurkenglas although I dont understand most of the things you're talking about just yet, I appreciate the info - I'll try to analyze it slowly after I get the program to work in a simpler way :)
08:49:08 * hackagebot sets 0.0.2.3 - Various set implementations in Haskell  https://hackage.haskell.org/package/sets-0.0.2.3 (athanclark)
08:49:10 * hackagebot sets 0.0.3 - Various set implementations in Haskell  https://hackage.haskell.org/package/sets-0.0.3 (athanclark)
08:50:22 <hackrilege_> suppose I had the most simple task, just 2 counters which sum the input from the other process with their held value and pass this to the other process. I can afford to do a lot of work to get this to run in pure haskell over 2 processors, I dont need to emulate even a large part of MPI, just the essential, can these threads talk to each other bit. i guess your saying I could but it would be *slow* and so it seems like a strang
08:50:53 <mauris_> Slay: fyi you could do something like   let (dx, dy) = (signum (lx - tx), signum (ly - ty))
08:51:02 <Intolerable> on a single machine that's trivial
08:51:11 <hackrilege_> im happy to abandon all hope, but id love to know what would be required to do it properly in haskell
08:51:12 <Intolerable> it's extending it to work on many machines that's the hard bit
08:51:51 <hackrilege_> because i must access the hardware ports and stream in from them?
08:52:14 <Gurkenglas> mauris_, compare has already been suggested
08:52:34 <hackrilege_> Theis i think is getting towards the real problem I face with the MPI binding, I cant read what they are doing...
08:53:01 <mauris_> yes, and signum hasn't
08:53:20 <mauris_> (it returns -1/0/1, not LT/EQ/GT!)
08:53:37 <hackrilege_> is the problem in fact that we *cannot* communicate between threads on different processors in haskell at all?
08:53:38 <Gurkenglas> Which is bad, right?
08:53:48 <mauris_> yeah, it's a bit of a hack :)
08:53:49 <codedmart> I have this overlapping instance that compiles fine. This specific doctest passes on 7.10 but fails on 7.8. Can anyone explain why? http://lpaste.net/138505
08:53:53 <Cale> hackrilege_: what?
08:54:09 * hackagebot reducers 3.11 - Semigroups, specialized containers and a general map/reduce framework  https://hackage.haskell.org/package/reducers-3.11 (EdwardKmett)
08:54:27 <Gurkenglas> It makes the pattern match necessarily inexhaustive and I could believe that the compiler might optimize the Ordering version
08:54:42 <Intolerable> hackrilege_: no, it's that communicating between processes on different machines will either be simple or efficient
08:54:54 <mauris_> well, there would be no more pattern match
08:55:03 <Intolerable> if you're on a single machine the entire thing is fairly simple
08:55:03 <mauris_> just  loop lx ly (tx + dx) (ty + dy)
08:55:11 <mauris_> and a single check for (0, 0)
08:55:13 <hackrilege_> Cale: MPI allows instances of the same program to run on multiple processors and handles the communication between these processes. I am trying to understand why this task is slow in haskell 
08:55:52 <Intolerable> it's not slow because of haskell, it's slow because your program won't have the years of optimization that MPI has had
08:56:03 <Cale> Which program is slow?
08:56:06 <hackrilege_> and you lost me!
08:56:18 <hackrilege_> what optimizations?
08:56:24 <frerich> hackrilege_: I don't know your task exactly, but maybe you wouldn't even run multiple processes of your Haskell program in the first place. It's perfectly possible to have a Haskell program executed by two (native) threads which your operating system executes on two separate CPUs.
08:56:43 <geekosaur> oh dear
08:56:54 <Slay> mauris_ thats exactly what I wanted to do at first, just couldnt figure out if it was possible. thanks
08:56:58 <Gurkenglas> mauris_, not quite. Slay's program halts immediately if both coordinates are lower than the target coordinates.
08:57:03 <Cale> hackrilege_: You said "we *cannot* communicate between threads on different processors in haskell at all?". There are lots of ways to communicate between Haskell threads, and they work independently of which processors those threads are running on. There's not necessarily any fixed correspondence between Haskell threads and physical processors. GHC uses an N:M scheduler
08:57:17 <hackrilege_> Cale: the bit that handles the communications between *any* programs expecting input and output run on different processors 
08:57:25 <mauris_> Gurkenglas: oh, you're right!
08:57:39 <mauris_> Slay: is that intentional? O_o
08:57:40 <Slay> Gurkenglas true, because I forgot that thing and even the compiler reminded me - "Non-exhaustive patterns in case"
08:57:40 <hackrilege_> in response to "which bit do i fear is slow"
08:57:50 <Cale> But maybe you're talking about something different from what I thought you were talking about initially (as I jumped into the middle of this conversation)
08:57:58 <Gurkenglas> And you just put return () x)
08:58:03 <Cale> hackrilege_: Do you have a specific program we can run?
08:58:26 <Gurkenglas> Slay, this'll help a little: https://hackage.haskell.org/package/NumInstances
08:58:37 <hackrilege_> Intolerable: Cale and frerich seem to surgest the problem is infact trivial in haskell. where is the confusion here?
08:58:59 <Intolerable> hackrilege_: they are unaware of your actual problem
08:59:00 <Cale> I don't know what we're actually talking about, since I haven't seen the program which is supposedly slow.
08:59:04 <Cale> Which program is slow?
08:59:09 <Intolerable> Cale: it's entirely theoretical at the moment
08:59:09 <frerich> hackrilege_: Disclaimer: I do not know what 'the problem is :-)
08:59:22 <Intolerable> he wants a reimplementation of MPI in haskell
08:59:22 <Cale> Intolerable: Oh, then this whole discussion is meaningless.
08:59:33 <hackrilege_> Cale: its a c library called MPI
08:59:40 <Intolerable> and i am trying to explain that it will not be fast without optimization
08:59:50 <Intolerable> and that the optimization will not be simple
08:59:54 <hackrilege_> i was asking what the problem is too...
08:59:56 <frerich> hackrilege_: I just wanted to emphasize (IIRC geekosaur already did that) that it's perfectly plausible (and practical) to not use a multi-process architecture in the first place but rather write a Haskell program which runs as a single process, executing on 64 cores in parallel.
09:00:03 <frerich> hackrilege_: In fact, I'd imagine it to work quite well!
09:00:18 <Intolerable> sure, if it's on one machine
09:00:23 <mauris_> > abs (5, -3)
09:00:26 <lambdabot>      No instance for (Show t0)
09:00:26 <lambdabot>        arising from a use of show_M456737033683879588610471
09:00:26 <lambdabot>      The type variable t0 is ambiguous
09:00:29 <Cale> Yeah, you're much more likely in Haskell just to use the lovely SMP support already provided by GHC.
09:00:33 <mauris_> > abs (5, -3) :: (Int, Int)
09:00:35 <lambdabot>      No instance for (Num (Int, Int)) arising from a use of abs
09:00:35 <lambdabot>      In the expression: abs (5, - 3) :: (Int, Int)
09:00:41 <frerich> Intolerable: Right
09:00:43 <Gurkenglas> Slay, is this for CodinGame?
09:00:44 <Intolerable> the problem is extending it to 64 physical machines
09:00:45 <Welkin> mauris_: what are you trying to do?
09:00:47 <Welkin> :t abs
09:00:49 <lambdabot> Num a => a -> a
09:00:58 <mauris_> Welkin, i was checking if lambdabot has https://hackage.haskell.org/package/NumInstances-1.4/docs/src/Data-NumInstances-Tuple.html
09:01:00 <Welkin> it only takes one parameter
09:01:00 <frerich> Intolerable: Oh, then I misread, I thought earlier he explained that he was on a single system with a Xeon CPU with 64 cores.
09:01:03 <Welkin> oh
09:01:04 <hackrilege_> cant we make a distributed cluster appear to haskell as one machine?
09:01:17 <hackrilege_> or its the OS thread handeler that does this?
09:01:25 <Gurkenglas> @let import Data.NumInstances.Tuple
09:01:26 <lambdabot>  Defined.
09:01:36 <Gurkenglas> > abs (5, -3) :: (Int, Int)
09:01:37 <lambdabot>  (5,3)
09:02:00 <Cale> hackrilege_: There are ways you could approach doing that, but in practice, you usually want a clear distinction between distributed processes and SMP threads
09:02:00 <Slay> Gurkenglas yup. I've done a whole bunch with ease in imperial languages so I decided to learn something completely different(haskell) :)
09:02:25 <Cale> hackrilege_: The delays and the amount of communication you can reasonably do are quite different
09:02:34 <hackrilege_> frerich: yes in this case it is, but what MPI brings to the table is the ability to replace the OS thread handeler, I think... please can you correct this if its wrong Intolerable
09:02:42 <Cale> hackrilege_: So attempting to hide that will usually run you into problems.
09:02:52 <breadmonster> Is there any good reference on alex + happy?
09:02:56 <Intolerable> hackrilege_: that is essentially it
09:03:04 <Gurkenglas> Slay, I'm not sure you even need to halt. The environment might just say you won as soon as you reach the endpoint x)
09:03:05 <breadmonster> I'd like to get a compiler up and running soon.
09:03:13 <mauris_> > pi :: (Double,Double,Double,Double,Double,Double,Double)
09:03:14 <lambdabot>  (3.141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,3.1...
09:03:16 <breadmonster> And the back end is going to take a fair bit of time anyway.
09:03:25 <mauris_> hahaha. great
09:03:27 <hackrilege_> Cale: any robust parallelisation should have parameters which will tune to the message transfer latency.
09:03:30 <Welkin> > pi [Double]
09:03:32 <lambdabot>      Not in scope: data constructor Double
09:03:32 <lambdabot>      Perhaps you meant variable double (imported from Text.PrettyPrint.Hugh...
09:03:34 <Welkin> > pi :: [Double]
09:03:35 <lambdabot>      No instance for (Floating [Double]) arising from a use of pi
09:03:36 <lambdabot>      In the expression: pi :: [Double]
09:03:47 <Slay> Gurkenglas yeah but in my opinion that's cheating :)
09:04:14 <mauris_> > (pi :: (Int -> Double)) <$> [0..]
09:04:15 <lambdabot>      No instance for (Floating (Int -> Double))
09:04:15 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
09:04:15 <lambdabot>        arising from a use of pi
09:04:21 <mauris_> @let import Data.NumInstances.Function
09:04:23 <lambdabot>  Defined.
09:04:24 <mauris_> > (pi :: (Int -> Double)) <$> [0..]
09:04:26 <lambdabot>  [3.141592653589793,3.141592653589793,3.141592653589793,3.141592653589793,3.1...
09:04:28 <Gurkenglas> But if your character asks you what to do next once he has reached the endpoint, you can't just stop talking to him! You just tell him to stay right there.
09:04:39 <hackrilege_> but then any OS I run on must support MPI, so perhaps the haskell compiler will also be able to call the OS thread handeler sufficiently...
09:04:40 <mauris_> > (pi + pi :: (Int -> Double)) <$> [0..]
09:04:42 <lambdabot>  [6.283185307179586,6.283185307179586,6.283185307179586,6.283185307179586,6.2...
09:05:27 <Cale> hackrilege_: What I mean is that you can get away with entirely different styles of programming depending on the latency. For example, par annotations that are designed with SMP in mind aren't likely to work very well at all if the sparks end up being computed on some other machine entirely.
09:05:59 <Slay> Gurkenglas I suppose that's what you should do in video games. didn't think of that :)
09:06:46 <Cale> hackrilege_: Also, you might want the nodes in your distributed network to be running different architectures, so sharing unevaluated expressions becomes difficult.
09:07:10 <Cale> (at least with GHC's thunks)
09:07:20 <hackrilege_> in which case we need an instance where MPI is more diverse than the OS threading, as I think there is a chance my problem will not extend to such an architecture. I mean, it would be great to run it over a network of nodes communicating over the internet... but really I think it just needs to be for the national supercomputer
09:07:41 <Cale> Maybe you're looking for distributed-process?
09:08:17 <hackrilege_> ill check it out
09:08:18 <Intolerable> is that not designed to be more erlang-style?
09:08:41 <Cale> Intolerable: It is.
09:08:51 <hackrilege_> i dont know erlang
09:09:04 <Cale> It's designed for programming clusters of machines rather than SMP parallelism though, so that sounds more like what he's looking for.
09:09:08 <Intolerable> Cale: what's performance like with it?
09:09:25 <Cale> Intolerable: In what units? :)
09:09:26 <opaqueghost> is there a web API from which I can query packages in Hackage which implement an instance(s) of a given typeclass?
09:09:28 <Intolerable> since i know erlang is more "reliability at the cost of efficiency"
09:09:36 <Intolerable> relative to erlang / mpi
09:09:53 <hodapp> I should look into Cloud Haskell one of these days(tm)
09:10:59 <hackrilege_> nonononooo no cost of efficiency, this is not suitable. ok im happy i can only extend to SMP
09:11:12 <Cale> hm?
09:11:38 <Cale> There's a good talk on it here, though they make you sign up for an account https://skillsmatter.com/skillscasts/3523-cloud-haskell
09:11:40 <hackrilege_> in which case i do not have to use mpi? there is no opptimisations i need fear i am missing out on?
09:12:04 <hackrilege_> hm? I will stick to the case where a single opperating system controls threads over all processors
09:12:16 <Cale> I don't know what your program does, and if you can't show me a program which is running too slow, I can't recommend anything you should do to make it faster.
09:12:46 <Cale> It's pointless to talk about performance without profiling measurements.
09:12:46 <hackrilege_> Cale: it was the haskell-mpi binding which the speed of was in question
09:13:32 <hackrilege_> Cale: i know, but intollerable will not specify the nature of the optimisations in place which make MPI so much more refined and unemulatable
09:14:17 <hackrilege_> sorry... bad phrasing
09:14:18 <Cale> I haven't used that library before, so I don't know what performance is like, but it's a binding, not an emulation.
09:14:43 <Cale> i.e. it just foreign imports the C stuff and calls that.
09:15:26 <Cale> It's likely doing a bunch of marshalling between C data structures and Haskell data structures, which will have some cost associated to it.
09:15:34 <Cale> But hopefully not too significant a cost.
09:15:57 <SwashBuckla__> I can't find where headMay is located.. how do I import it? I am referring to the Safe Haskell package: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/safe-haskell.html
09:16:07 <Intolerable> when i used it last haskell-mpi had took 5-10% longer to do the same thing as C was doing
09:16:08 <SwashBuckla__> is it in Data.Safe?
09:16:18 <Intolerable> but don't quote me on that since it wasn't a proper benchmark
09:16:48 <Cale> SwashBuckla__: hm? Where do you see headMay there?
09:16:53 <Intolerable> i was passing full matrices between machines, and most of the extra time was serializing those
09:17:02 <hackrilege_> but all of the stuff being done by the C library is blisteringly fast communication, i was struggling to  understand the process of optimising this which haskell could not achieve easily...
09:17:11 <Gurkenglas> Is there a Applicative f => Maybe a -> (a -> f b) -> f b?
09:17:39 <Gurkenglas> No wait. @hoogle Applicative f => Maybe a -> (a -> f ()) -> f ()
09:17:41 <Cale> SwashBuckla__: Also, Safe Haskell isn't a package as such. It's a system for marking packages as trusted or not.
09:17:43 <Gurkenglas> -@hoogle
09:18:14 <Cale> SwashBuckla__: I think you'r looking for this: https://hackage.haskell.org/package/safe-0.3.9/docs/Safe.html
09:18:18 <Cale> you're*
09:18:21 <SwashBuckla__> Cale: https://hackage.haskell.org/package/safe-0.3.7/docs/Safe.html
09:18:26 <Cale> yeah
09:18:27 <SwashBuckla__> (or other package, yes)
09:18:29 <hackrilege_> @hoogle Applicative f => Maybe a -> (a -> f ()) -> f ()
09:18:29 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
09:18:29 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
09:18:29 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:18:39 <Cale> That's the safe package, it doesn't really have anything to do with Safe Haskell
09:18:49 <SwashBuckla__> Cale: okay. How do I import it?
09:19:13 <Intolerable> hackrilege_: it's not "c vs. haskell", its "12 years of optimization vs zero"
09:19:14 <liste> Grukenglas why not maybe (return ())
09:19:23 <liste> :t maybe (return ())
09:19:24 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
09:19:32 <Cale> SwashBuckla__: Make sure that you have it installed by running  ghc-pkg list safe  at the commandline, and if so, you can just  import Safe
09:19:33 <Gurkenglas> I guess.
09:19:37 <liste> :t maybe (pure ())
09:19:38 <lambdabot> Applicative f => (a -> f ()) -> Maybe a -> f ()
09:20:12 <hodapp> hmmm... this code builds on GHC 7.10, but fails on 7.8; it is complaining about 'b' being ambiguous in a call that is something like 'Foo a b c => Bar a -> c", but in this case, how can I make 'b' any more specific?
09:20:22 <SwashBuckla__> Cale: aha, I didn't have it installed -- that was the problem!
09:21:05 <hackrilege_> Intolerable: i really am being told different things here... you are saying mpi will outperform native haskell. but haskell uses OS threading which should be very good. so im really stuck as to who to believe. i dont want to believe you because i want to do it in pure haskell, but im worried you are right. I wish there was a diffinative answer here, but i will do the benchmarks... 
09:21:13 <Cale> SwashBuckla__: So you can cabal install safe to install it if you like. I wouldn't do so if all I wanted was headMay, since that's the same as listToMaybe in Data.Maybe
09:21:31 <Intolerable> you are being told two different thing because you are asking two different questions
09:21:41 <Intolerable> yes, you will be fine with haskell if you stick to one machine
09:21:53 <hackrilege_> i am?
09:21:55 <hackrilege_> ok, so i will stick to one machine
09:21:58 <Intolerable> no, you will not if you try to extend to multiple machines
09:22:15 <Intolerable> because at that point you are ignoring the literal decades of work put into MPI
09:22:51 <hackrilege_> actually thats one of the few things im considering
09:22:53 <Cale> I don't think the things which Intolerable is saying here are very solid either -- you might be fine extending your program to work on multiple machines using Cloud Haskell. You might have trouble getting enough performance on a single machine.
09:23:08 <Cale> It's pointless to talk about until you have an actual program which is too slow.
09:23:11 <hackrilege_> but i dont understand its mysterious nature...
09:24:41 <Gurkenglas> Slay, my version would probs look something like this: http://lpaste.net/138600 . (Of course I didn't write the imports.) (The one thing I don't like is that the parameter order might not be obvious.)
09:24:46 <geekosaur> hackrilege_, I'm sorry but you are demonstrating a lot of inexperience here
09:24:49 <hackrilege_> Cale: on the national supercomputer where it will run, every flop costs, so any performance gain will be necessary. i think im going to have to do the benchmarks, its no problem, its just necessary from what I understand from this discussion (thanks). 
09:25:05 <hackrilege_> dont be sorry, I am...
09:25:25 <breadmonster> How do you use Alex for whitespace sensitive languages?
09:25:28 <breadmonster> I'm thinking of Python.
09:25:44 <geekosaur> you're also asking for specifics and I think you need an MPI impelemntor for that. or a literature search because it's probably documented somewhere... if only in changelogs
09:26:02 <geekosaur> in which case you would have to understand implementation details to understand the performance implications
09:26:03 <Cale> hackrilege_: Even running something on a supercomputer where you're paying for the processing time, there's a point where the programmer time spent optimising the program further will outdo the additional compute time cost.
09:27:54 <Cale> In cases where your program will be run for an indefinite amount of time into the future, it might warrant a huge amount of optimisation effort, but otherwise there's some room for trading off small amounts of performance for other things, like the ability to know that the program you're going to run is actually computing the correct thing.
09:28:52 <tafryn> I'm trying to compile h4sh, but it is complaining that it "Could not find module 'Text.Regex'". However, ghc-pkg find-module Text.Regex works just fine as does loading up ghci and importing Text.Regex. Anyone know what my problem is?
09:30:10 <johnw> carter: ping
09:30:12 <nshepperd> it's pretty important to know that your program is correct, I think, when you're running on expensive cluster time
09:30:24 <Slay> Gurkenglas thats insanely short... and incomprehensible for me heheh. for now I'm trying to get your version with Maybes to work :) when I call it from main, compiler complains that it expects IO() and not IO(Maybe(Int,Int)). changing main() return type makes it go only 1 step. what am I doing wrong?
09:30:25 <nshepperd> it sucks when I realise I have a bug and have to restart
09:31:04 <hackrilege> hi sorry, i got disconnected again...
09:31:15 <Gurkenglas> Slay, main has to feed the result of each step into a next step call
09:32:02 <Slay> Gurkenglas alright. Ill let you know if I cant figure it out by myself
09:32:46 <hackrilege> so, im quite hopeful now that pure haskell will have merits, which I am happy about, as I came on looking for reasons a pure alternative to MPI might be perishable and think I have found it. Also I understand better where MPI will be necessary, and will explore both avenues with reasonable justification. thank you all for your help 
09:33:14 <hackrilege> permissible* 
09:35:28 <hodapp> With an external definition like 'Foo a b c => Bar a -> c" and GHC 7.8 complaining where it's used about 'b' being ambiguous, what can I do to specify 'b'? I'm at a loss for how to search about this
09:35:57 <hodapp> 'b' occurs in neither 'Bar a' nor 'c' so I can't give an explicit signature on the argument or result, can I?
09:39:03 <Hijiri> (Foo a b c, b ~ Baz) ?
09:39:06 <Hijiri> I don't know if it works that way
09:40:03 <hodapp> Hijiri: but where would I put that constraint?
09:40:05 <ski> hodapp : .. i suppose you can't add an FD ?
09:40:10 <hodapp> ski: to what?
09:40:13 <Intolerable> > let s = (show :: (Show a, a ~ Int)) in s 5
09:40:14 <ski> `Foo'
09:40:15 <lambdabot>      Expected a type, but (Show a, a ~ Int) has kind Constraint
09:40:15 <lambdabot>      In an expression type signature: (Show a, a ~ Int)
09:40:15 <lambdabot>      In the expression: (show :: (Show a, a ~ Int))
09:40:24 <Intolerable> > let s = (show :: (Show a, a ~ Int) => a -> String) in s 5
09:40:27 <lambdabot>  "5"
09:40:29 <hodapp> ski: 'Foo' is not my definition
09:40:33 <ski> ok
09:40:35 <Intolerable> hodapp: something like that?
09:41:00 <Intolerable> redefine the problematic function locally with tighter constraints
09:41:09 <bennofs> hodapp: then the only possible way to call that function is to have an instance Foo T b X, where b is not in any way constrainted
09:41:25 <hodapp> bennofs: or to use GHC 7.10.
09:41:32 <bennofs> hodapp: GHC 7.10 can do this? how?
09:41:39 <ski> Intolerable : presumably you wanted something like `show :: (Show a,a ~ Int) *> a -> String' (pseudocode) ?
09:41:55 <hodapp> bennofs: that's sort of what I'm here asking...
09:42:08 <bennofs> hodapp: well, how can you do it with GHC 7.10??
09:42:25 <Intolerable> ?
09:42:37 <hodapp> bennofs: It just typechecks.
09:42:39 <Intolerable> it was an example of what hodapp could use
09:42:53 <bennofs> @let class Foo a b c where foo :: a -> c; bar :: b
09:42:55 <lambdabot>  Defined.
09:43:04 <bennofs> :t foo
09:43:05 <lambdabot> Foo a b c => a -> c
09:43:23 <Intolerable> :t foo :: (Foo a b c, b ~ Int) => a -> c
09:43:24 <lambdabot>     Could not deduce (Foo a1 b0 c1) arising from a use of foo
09:43:24 <lambdabot>     from the context (Foo a Int c)
09:43:24 <lambdabot>       bound by the inferred type of it :: Foo a Int c => a -> c
09:43:27 <bennofs> hodapp: can you show the code?
09:43:44 <ski> hm, actually. `show :: exists a. (Show a,a ~ Int) *> a -> String', which would mean `show :: a -> String' endowed with the extra information that `(Show a,a ~ Int)'
09:44:21 <bennofs> > instance Foo Int String String where foo = show; bar = ""  -- now have fun using foo from this instance
09:44:22 <lambdabot>  <hint>:1:1: parse error on input instance
09:44:24 <hodapp> bennofs: in the present form, no, but I may be able to get a test case, though it would require one to have latest Ivory most likely
09:44:31 <ski> (as opposed to using `show :: forall a. (Show a,a ~ Int) => a -> String' which would express that this has to work for *any* `a', that happens to satisfy that constraint)
09:44:33 <bennofs> @let instance Foo Int String String where foo = show; bar = ""  -- now have fun using foo from this instance
09:44:34 <lambdabot>  Defined.
09:44:53 <ski> .. otoh, i suppose it might logically turn out as the same thing, in this case ?
09:45:02 <bennofs> hodapp: are you sure that there is no conditional compilation going on where GHC 7.10 has a different instance in scope than GHC 7.8?
09:45:33 <hodapp> bennofs: it is a possibility
09:45:45 <bennofs> @let instance Foo Bool b String where foo = show; bar = undefined
09:45:47 <lambdabot>  Defined.
09:45:54 <bennofs> > foo True :: String
09:45:56 <lambdabot>  "True"
09:46:02 <bennofs> > foo (3 :: Int) :: String
09:46:04 <lambdabot>      No instance for (Foo Int b0 String) arising from a use of foo
09:46:04 <lambdabot>      The type variable b0 is ambiguous
09:46:04 <lambdabot>      Note: there is a potential instance available:
09:46:25 <bennofs> hodapp: hmm, or maybe there actually is an instance Foo YourConcreteA b YourConcreteC ?
09:46:51 <bennofs> let my quickly check this with GHC 7.8
09:46:57 <valica92> :t chunksOf
09:46:58 <lambdabot> Int -> [e] -> [[e]]
09:47:06 <nshepperd> hodapp: suppose the original function is 'foo :: Foo a b c => Bar a -> c', you could try defining 'quux :: Foo a b c => Proxy b -> Bar a -> c; quux Proxy bar c = foo bar c'?
09:47:39 <nshepperd> I think that would get plumbed together the right way, then you could provide the 'b' by passing the correct Proxy
09:47:51 <bennofs> nshepperd: there is still no way to call foo with a fixed b
09:48:09 <bennofs> nshepperd: try calling foo :: Foo Int String String => Int -> String in lambdabot
09:49:43 <bennofs> hodapp: if there is a general instance Foo T b U, it seems to work in GHC 7.8 as well
09:50:46 <bennofs> hodapp: maybe the API is supposed to be callable only by "making" an instance via reflection-like techniques?
09:53:06 <hodapp> bennofs: no, that's not how it's used... trying to get a minimal test case here
09:54:12 * hackagebot tictactoe3d 0.1.0.1 - 3D Tic-Tac-Toe game  https://hackage.haskell.org/package/tictactoe3d-0.1.0.1 (ryo0ka)
09:54:34 <mauris_> gosh, i can't stop thinking about this idea for a "puzzle/challenge" kind of thing:
09:56:14 <mauris_> i wonder what the smallest "basis" for the functions in Prelude is. a set of functions F so that all of the functions in Prelude can be defined as applying elements of F to other elements of F
09:56:30 <nshepperd> huh, I thought the necessity for polymorphism would disambiguate the instance, but ghc insists 'b0 is ambiguous'
09:57:45 <mauris_> the way, say, `map` is just `flip foldr [] . ((:) .)`
10:00:05 <mauris_> but something like `foldr` is probably hard to build out of other functions in the prelude (without using lambdas/pattern matching), so it'd probably have to be in the basis
10:00:09 <breadmonster> mauris_: Isn't that missing brackets?
10:00:19 <breadmonster> :t flip foldr []
10:00:20 <lambdabot> Foldable t => (a -> [t1] -> [t1]) -> t a -> [t1]
10:00:35 <breadmonster> Okay, no it isn't.
10:00:36 <mauris_> i don't think it is (i stole it from @pl and i trust lambdabot a lot)
10:04:16 * nshepperd doesn't even see how to extract the correct 'foo' from a Dict giving a constructed instance
10:07:40 <Slay> Gurkenglas I have no clue. there must be a way of detecting what type was returned and depending on that call itself with only the last parameter changed. all my attempts were breaking the type somewhere. I feel like Im missing something huge
10:07:54 <bennofs> nshepperd: there could be a function: withFooInstance :: x -> (forall b. Foo A b C -> y) -> y I think
10:08:10 <bennofs> nshepperd: that second -> should ofc be a =>
10:08:19 <ReinH> mauris_: it's a bit easier to read as map f = foldr ((:) . f) []
10:08:24 <hodapp> bennofs: http://lpaste.net/138611 that is what I have gotten it to and I am trying to narrow it further
10:09:03 <hodapp> bennofs: if 'Foo' (which is unrelated to the Foo typeclass earlier) no longer is an existential then the issue appears to go away, but I'm checking this again
10:09:45 <bennofs> hodapp: where exactly is that call that is ambigious there?
10:10:03 <hodapp> bennofs: call_
10:10:44 <hodapp> yeah, just checked again, the issue occurs only when Foo is an existential
10:11:29 <bennofs> hodapp: hmm, http://hackage.haskell.org/package/ivory-0.1.0.0/docs/Ivory-Language-Proc.html#t:IvoryCall_ looks like the IvoryCall_ typeclass indeed only has instances where eff is polymorphic
10:12:02 <hodapp> bennofs: not sure what that implies
10:12:47 <bennofs> hodapp: ah, IvoryCall_ has functional dependencies
10:13:45 <hodapp> bennofs: what changes in GHC 7.10 should have affected this?
10:13:52 <bennofs> hodapp: so as long as your impl is unambigious, GHC should be able to derive eff
10:14:53 <bennofs> hodapp: can you try annotating your call_ with a type signature for the return value (use -XScopedTypeVariables)
10:15:16 <hodapp> ScopedTypeVariables is already on
10:15:41 <hodapp> and, what, something like (call_ :: IvoryCall_ blahblahblah) cb undefined?
10:15:54 <bennofs> hodapp: no, call_ cb undefined :: Ivory eff ()
10:16:12 <hodapp> I'd need forall eff one level up, wouldn't I?
10:16:13 <bennofs> (with forall eff. in the type sig of testFn too)
10:16:38 <hodapp> same problem
10:18:04 <hodapp> I have to wonder what that existential in Foo is doing that sets this off
10:21:31 <hackrilege> could someone take a look at my CyclicTree? I wish to extract a subtree using Lens  http://lpaste.net/138612
10:21:53 <ski> hodapp : hm, what is the error ?
10:23:30 <hodapp> ski: http://lpaste.net/138611 see comment
10:25:01 <bennofs> hodapp: the problem there seems to be that GHC doesn't know that ref ~ Ref
10:26:10 <aphorisme> how does the streaming work in `Network.HTTP.Client`? It uses lazy bytestrings somehow, but I have no clue. If I take a look onto `brRead :: IO Strict.ByteString -> IO Strict.ByteString`, which is used to read out a chunk, it confuses me even more, since it is defined by `brRead = id`
10:27:23 <trumanshow19> Would someone mind help iron out the inconsistencies in my head with respect to purity in Haskell. Statement 1: Haskell is a purely functional lanugage, S2: Haskell is not impure, but... S3: f :: a -> a is a "pure" function as opposed to a -> IO a.
10:27:54 <trumanshow19> If a -> is pure, to distinguish a -> IO a, then how do I describe the latter, is there is no impurity in Haskell ?
10:27:56 <hodapp> bennofs: hmmmm...
10:28:22 <Gurkenglas> Waait a second. Slay, why do the recursive loop calls change the tx/ty (target?), not the lx/ly (location?)
10:28:23 <trumanshow19> The only opposite of pure I know is impure.
10:28:38 <geekosaur> trumanshow19, IO is a bit of a trick. anything you write in IO is actually entirely pure: you are actually writing in Haskell a program that emits IO "opcodes" which are run by the runtime, which is impure. 
10:28:55 <aweinstock> (f :: a -> IO a) is a pure function that returns an IO action (which can be executed impurely)
10:29:03 <bennofs> @quote /bin/ls
10:29:03 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
10:29:03 <hodapp> bennofs: now I'm not clear on why I used polymorphic 'ref' in the first place.
10:29:09 <Slay> Gurkenglas tx/ty is not the target, its thor. lx/ly is light which is the target
10:29:17 <Gurkenglas> suuuure.
10:29:17 <geekosaur> that is, "getLine" is not a function which reads a line, it is a variable containing an opcode that the runtime interprets to mean "read a line".
10:29:21 <ski> trumanshow19 : all functions in Haskell are "pure"
10:29:35 <geekosaur> the main function's result is an IO action, or a chain of these opcodes connected by >>=
10:29:46 <geekosaur> which the runtime can then run
10:30:15 <trumanshow19> geekosaur: thanks. But that's true of *any* language. The `getLine` equivalent in Java doesn't get a line when I write the Java, it's run when I run the executed impure bytecode.
10:30:23 <Slay> Gurkenglas I was confused in the beginning too. Ive been working on this silly thing for half a day hahah
10:30:46 <Philonous> trumanshow19, The heart of the issue is that IO values are just values like any other and they can be returned from a function, IO values represent programs that, when executed, can have "impure" effects. You can't execute them from within haskell, though
10:30:47 <bennofs> trumanshow19: well, in most languages, IO a would be represented as a function without any arguments 
10:30:50 <trumanshow19> ski: this is what is confusing. People often say: a -> a is pure, by which they mean there is no "IO" before the last a.
10:30:54 <geekosaur> trumanshow19, not quite the same situation
10:31:01 <trumanshow19> So if a -> is pure, what is a -> IO a ?
10:31:01 <Slay> Gurkenglas but now Ive got it working in 3 different ways and Ive learned a lot along the way so its all good
10:31:02 <geekosaur> think of a program that outputs a program
10:31:15 <bennofs> > const 3 getLine
10:31:17 <lambdabot>  3
10:31:17 <geekosaur> your Java writes a JavaScript program that, when run, does the IO
10:31:27 <trumanshow19> I very often see this kind of definition, in the widely used Haskell books and online material.
10:31:28 <geekosaur> *that* is the analogy in effect here
10:31:45 <ski> trumanshow19 : you can't embed I/O actions inside e.g. an expression of type `Integer'. that is the most visible difference with Java here
10:32:04 <Gurkenglas> Slay, here's a recursive implementation of a looper for step: http://lpaste.net/138614
10:32:10 <ski> trumanshow19 : "People often say: a -> a is pure, by which they mean there is no "IO" before the last a." -- yes. and it's bad terminology to say so
10:32:30 <bennofs> trumanshow19: yeah, and there is a clear separation between "constructing" an IO value and actually executing the IO
10:33:06 <hodapp> bennofs: so it appears it wasn't so much the existential, but the ambiguity that one introduced, or something like that...
10:33:07 <trumanshow19> "ski: yes. and it's bad terminology to say so" ... Learn you a Haskell, Real World Haskell,.... they all use this "a -> a" is pure distinction in their descriptions.
10:33:19 <ReinH> trumanshow19: And yet it's still bad.
10:33:33 <aweinstock> is it possible to get an offline copy of the database that lambdabot uses for @quote?
10:33:45 <bennofs> trumanshow19: and yet... it doesn't matter so much, as long as you understand how it is meant
10:34:13 * ski thinks it confuses newbies
10:34:33 <tommd> I like saying it is "deterministic" or a "function", though some people have different opionions on what constitutes a "function".
10:34:54 <ski> `putStr' is clearly a function (returning a monadic action)
10:35:06 <ski> @type putStr
10:35:07 <lambdabot> String -> IO ()
10:35:26 <tommd> ski: Are you sure that's always true?
10:35:28 <bennofs> ski: is there any other word for a thing of type a -> IO b that you'd recommend, instead of "impure function"?
10:35:31 <ski> tommd : yes
10:35:33 <trumanshow19> Learn you a Haskell: " And if we're taking data out of an I/O action, we can only take it out when we're inside another I/O action. This is how Haskell manages to neatly separate the pure and impure parts of our code."
10:35:37 <trumanshow19> http://learnyouahaskell.com/input-and-output
10:35:45 <ReinH> The definition of function is pretty clear: a type whose outermost constructor is (->).
10:35:49 <hodapp> bennofs: thanks for the help; I'll have to look closer in the errors next time.
10:36:05 <tommd> ski: Does HaLVM (or any other compiler) not through an exception?  Does the language require no exception can be thrown?
10:36:09 <ReinH> trumanshow19: Yes, LYAH is not a paragon of accuracy
10:36:15 <ski> bennofs : you could possibly say "monadic function" or maybe "Kleisli function" to mean a function which returns a monadic action
10:36:19 <bennofs> hodapp: to be fair, I only figured this out after manually looking for the instances of IvoryCall_ and trying to see why the compiler couldn't choose an instance
10:36:22 <Philonous> LYAH seems to be preoccupied with cutesy analogies and pretty pictures rather than rigorous
10:36:28 <Philonous> being*
10:36:30 <trumanshow19> Real World Haskell: "In Haskell, the default is for functions to not have side effects: the result of a function depends only on the inputs that we explicitly provide. We call these functions pure; functions with side effects are impure."
10:36:34 <trumanshow19> http://book.realworldhaskell.org/read/types-and-functions.html
10:36:43 <ReinH> trumanshow19: I know they say this.
10:36:45 <ReinH> It's still wrong.
10:36:49 <tommd> ski: Ah, unapplied, as in 'putStr' as a value.  Nevermind.
10:37:03 <ReinH> it's a convenient fiction
10:37:16 <ski> tommd : `putStr' will return the same action (an equal action) every time you call it with the same (an equal) string argument
10:37:19 <Philonous> It's not even convenient, really.
10:37:29 <ski> it's a point-of-view
10:37:38 <ReinH> ski: that's just like your opinion man
10:37:52 <ski> what matters is how we can reason about it, at the level of the language
10:38:16 <ski> ReinH : which ?
10:38:23 <trumanshow19> It isn't too surprising, then, when the declaration that Haskell is a purely FP language is met with confusion when the pillars of Haskell teaching use imprecise analogy for pure vs impure.
10:38:30 <ReinH> ski: I was just going off of "it's a point of view"
10:38:33 <tommd> ski: I'm sure I can construct a situation where that isn't true.  () /= _|_
10:38:40 <ReinH> trumanshow19: I wouldn't call either of those "pillars of Haskell teaching"
10:38:42 <ReinH> not by a long shot
10:38:45 <tommd> ski: Am I missing your point?
10:39:15 <bennofs> Well, you could argue that since you can't really do anything at all with IO actions other than forcing them or putting them in another IO action so they're executed, the function itself is still impure since you cannot get the result without performing impure actions 
10:39:19 <trumanshow19> (Despite that, I've heard Haskeller's often react with the "what part of 'purely' FP don't you understand".. when these trusted resources use the 'impure' quite freely.
10:39:22 <Philonous> trumanshow19, You're not the first to notice this. Unfortunately, those sources aren't going to go away
10:39:28 <ReinH> bennofs: not really
10:39:51 <ski> ReinH : i mean that if we're talking about the POV of implementing Haskell, then implementations typically use update-in-place of memory and registers. e.g. if compiling via C, then it would probably use impure constructions in C. however, this in no way affects the purity of the language itself
10:39:51 <ReinH> It's pretty simple: evaluation of IO actions is pure.
10:40:15 <ReinH> ski: Sure, and underlying it all is mutations of registers, so Haskell can't be pure, QED
10:40:26 <ski> ReinH : by "POV" i mean that whether it's pure or not depends from which language level you're viewing it. it's not absolute. it's relative to the language you're reasoning inside
10:40:44 <ski> ReinH : therefore, it *is* pure, from the POV of the Haskell language
10:41:09 <ReinH> Evaluation of haskell is observably pure.
10:41:12 <ski> tommd : elaborate on what you mean ?
10:41:32 <bennofs> ReinH: I still wouldn't call getLine a "pure function", simply because you cannot use it in any meaningful way if you're not perfoming the impure part of it. The main functionality of it is impure, no matter if techniqually, you can already get the "IO" action without executing it
10:41:43 <ReinH> bennofs: I wouldn't call getLine a function.
10:41:46 <ReinH> Because it isn't.
10:41:49 <ski> (well, `getLine' is simply not a function at all)
10:42:07 <bennofs> oops, sorry. substitute getLine with putStrLn
10:42:09 <ReinH> The main functionality of getLine is to be a value that represents an IO action
10:42:20 <ReinH> bennofs: putStrLn is a pure function that returns an IO action, as mentioned
10:42:28 <ReinH> Again: evaluation of IO values is pure
10:42:35 <ReinH> Execution is not, but no one expects execution to be pure
10:42:46 <ReinH> indeed, it can't be pure if you want to actually do anything
10:43:26 <trumanshow19> ReinH: are you getting about evaluation as a distinction of execution for the fact that Haskell evaluation is lazy?
10:43:27 <Philonous> bennofs, You can store the result in a datastructure and use it later, at which point the association between "putStrLn" and the action is lost. 
10:43:40 <ReinH> trumanshow19: no, simply for the fact that they are different things
10:43:54 <trumanshow19> That is to say: it would be impossible to implement a strict purely functional programming language that has getLine and putStrLn ?
10:44:00 <bennofs> trumanshow19: no
10:44:05 <ReinH> It has nothing to do with laziness
10:44:13 <bennofs> trumanshow19: the point of IO actions is that you can build IO actions without performing there effects
10:44:37 <bennofs> trumanshow19: building the actions is pure. Perfoming their effects (= executing them) (this is what the Haskell runtime does) is not
10:44:47 <ski> bennofs : you can refactor `do _ <- putStrLn "foo"; _ <- putStrLn "foo"' into `do let {act = putStrLn "foo"}; _ <- act; _ <- act' in Haskell. you can't refactor `{ puts("foo"); puts("foo"); }' into `{ int act = puts("foo"); (void)act; (void)act; }' in C
10:45:01 <Slay> Gurkenglas that's brilliant. thanks a lot for all the help!
10:45:05 <nshepperd> putStrLn is actually more powerful than the equivalent impure C function, in that you can bundle up 'putStrLn "hello"' as a value, put it into a list, pass it to a function to be executed later, etc etc
10:45:29 <trumanshow19> By building you mean tying into a text editor? I.e. getLine >>= putStrLn  :: IO ()  ?
10:45:40 <ReinH> trumanshow19: No, evlauation
10:45:44 <ReinH> *evaluation
10:46:20 <ReinH> putStrLn "foo" >> putStrLn "bar" evaluates to an IO action that is composed of both actions. This happens separately from execution.
10:46:25 <trumanshow19> Well, how would a strict language evaluate `getLine >>= putStrLn` *without* performing these two effects?
10:46:35 <bennofs> trumanshow19: evaluating it. You can build up a value of type :: IO () in your program and store it in a datastructure 
10:46:36 <nshepperd> > putStrLn "we don't print this" `seq` 7
10:46:38 <lambdabot>  7
10:47:32 <trumanshow19> "<bennofs> You can build up a value of type :: IO () in your program and store it in a datastructure" .. in a strict language also?#
10:47:59 <ReinH> bennofs: laziness makes the separation between evaluation and execution more clear, but they are still two separate processes
10:48:05 <nshepperd> trumanshow19: yes
10:49:02 <nshepperd> trumanshow19: just as much as you can (strictly) compile a program without running it
10:49:02 <ski> > length [putStrLn s | s <- take (2 + 3) (cycle ["hi","there"])]
10:49:04 <lambdabot>  5
10:49:23 <trumanshow19> Interesting, what would this look like? I'd love to see an example in OCaml, or Java, where I am able to build up an IO value of `getLine >>= putStrLn` that does *not* either execute getLine or write to the terminal my key strokes.
10:49:32 <bennofs> trumanshow19: you can for example represent IO () a just a function in a strict language that doesn't take any arguments. Executing the IO action would then correspondend to involking that function
10:49:43 <ski> trumanshow19 : "how would a strict language evaluate `getLine >>= putStrLn` *without* performing these two effects?" -- more or less as in Haskell
10:49:45 <trumanshow19> Maybe I'm being stupid, but I've never seen this in an imperative do-this-do-that language.
10:49:58 <ReinH> trumanshow19: Well yes, because they are not pure.
10:50:02 <ReinH> So they don't have the same semantics
10:50:07 <hexagoxel> trumanshow19: i liked http://www.alexeyshmalko.com/2015/io-is-your-command-pattern/
10:50:35 <bennofs> trumanshow19: (fun () =>   ... get line in ocaml ...) : () -> string   would be equal to just getLine in Haskell
10:50:41 <ReinH> strictness is a property of *evaluation*, not execution
10:50:42 <trumanshow19> ReinH: what's an example of a strict, purely FP language?
10:51:07 <trumanshow19> Then my question is "how would <that language> evaluate `getLine >>= putStrLn` *without* performing these two effects?"
10:51:11 <bennofs> trumanshow19: sequencing it would work like:   sequence f k = fun () => k (f ()) ()
10:51:12 <nshepperd> Idris is strict, isn't it?
10:51:33 <ski> trumanshow19 : there's a temptation in strict languages to add side-effects, because strictness means that it's relatively easy (for smaller examples, not using higher-order functions) to reason about when they will happen. otoh "non-strictness (especially by-need/lazinesS) keeps you honest", by making it harder to predict this
10:51:57 <ReinH> nshepperd: yes
10:52:11 <bennofs> trumanshow19: oops, just looked up ocaml syntax, replace => with -> in my examples
10:52:51 <ski> trumanshow19 : continuing what bennofs says, you'd probably never explicitly execute an I/O action in such a strict language, letting the run-time start the process
10:53:12 <ReinH> trumanshow19: They would implement getLine >>= putStrLn by strictly evaluating rather than lazily evaluating to the resulting IO () value.
10:53:19 <ReinH> strictness is a property of evaluation, not execution
10:53:23 <ski> (if you could/would execute it yourself, then that would break equational reasoning for you)
10:53:49 <ReinH> There is no reason IO can't be implemented both strictly and purely because strictness and purity are orthogonal
10:54:07 <nshepperd> > (getLine >>= putStrLn) `seq` 500
10:54:08 <lambdabot>  500
10:54:21 <aphorisme> if `Network.HTTP.Client.responseOpen` throws an exception, is a socket left open? (sorry, very special question)
10:54:30 <nshepperd> trumanshow19: strictly evaluated IO action ^^
10:54:55 <nshepperd> (more or less)
10:54:59 <hodapp> hmm, I wonder if https://ghc.haskell.org/trac/ghc/wiki/GhcKinds/PolyTypeable is the reason why this next issue in my code comes up on GHC 7.8 but not 7.10
10:55:00 <ski> i recall seeing on some blog someone who'd made a toy language and implementation for controlling some kind of robots. using monads for those effects (also being a dynamically typed language)
10:55:14 <hodapp> particularly, it complains that "foo" (the symbol) is not an instance of Typeable
10:55:34 <aweinstock> trumanshow19: ocaml example: fun () -> print_string (read_line ())
10:55:48 <trumanshow19> ski ReinH nshepperd hexagoxel bennofs : thanks! Time to ponder :-)
10:56:16 <aweinstock> (ocaml is strict and impure, but still in the ML family, related to haskell)
10:57:34 <ski> trumanshow19 : "what's an example of a strict, purely FP language?". Hope is an example
10:57:51 <ski> <https://en.wikipedia.org/wiki/Hope_%28programming_language%29>
10:58:40 <ski> trumanshow19 : for one that is used (and is actually a logic/functional programming language), Mercury
10:59:09 <hackrilege> could somebody take a look at this dataStructure for me? http://lpaste.net/8509247691404869632
10:59:37 <johnw> what is your question?
11:00:01 <hackrilege> im trying to build a lens accessor for it
11:00:11 <hackrilege> is it suitable?
11:00:12 <ski> (Mercury actually also supports `impure' (and `semipure') annotations on predicates and functions, but they're intended for doing FFI, before wrapping in a declarative interface)
11:00:35 <johnw> hackrilege: if you are asking that, why are you trying to use lens?
11:01:54 <hackrilege> johnw because i fear an ill phrased datatype... its a cyclic tree, im guessing at its implementation and am wondering if anyone crindges because of something horrible i have done in the paste...
11:02:16 <Cale> hackrilege: I tend to find that if you're dealing with any sort of cyclic data structure, it makes life a lot easier to use something like a Map to store adjacency information, but I don't know what your program actually is.
11:02:46 <johnw> do not fear; phrase it poorly and then learn from experience what was wrong with it
11:02:59 <siriusbtx> I have a function that takes a 'Ptr Rect' as argument. I can create a Rect but how do I make a Ptr to it?
11:03:07 <hackrilege> um, could you tell me from experience what is wrong with it?
11:03:11 <johnw> siriusbtx: the FFI
11:03:21 <johnw> there are many ways to get a Ptr Rect
11:03:33 <siriusbtx> johnw: well im a noob in haskell
11:03:36 <johnw> alloca is a favorite of mine
11:03:43 <siriusbtx> johnw: ye I found that function
11:03:45 <johnw> but it really depends on your use case
11:03:58 <siriusbtx> johnw: well https://hackage.haskell.org/package/sdl2-1.3.1/docs/Graphics-UI-SDL-Video.html
11:04:08 <hodapp> ugh, this oracle crap from Shake is always a source of annoyance. I wonder if I could use Data.Reflection to just let me turn a value into the unique type it needs... problem is, said unique type must derive from Show, Eq, Typeable, Hashable, NFData, Binary, and Generic.
11:04:08 <siriusbtx> johnw: renderDrawRect
11:04:16 * hackagebot google-drive 0.4.1 - Google Drive API access  https://hackage.haskell.org/package/google-drive-0.4.1 (PatrickBrisbin)
11:04:26 <siriusbtx> johnw: it takes a Ptr Rect but there are no functions to create it. So I should use alloca?
11:04:36 <hodapp> this code builds on GHC 7.10, but on 7.8 I can't seem to have type-level symbols that are an instance of Typeable
11:05:14 <Cale> siriusbtx: That is a really raw binding... Yeah, you can use alloca, and then poke a value
11:05:15 <hackrilege> Cale: if a Map is not a tree? what is it? just a list of pairs of flags and values?
11:05:39 <Cale> hackrilege: I mean you store a mapping from vertices to their sets of neighbours.
11:05:52 <siriusbtx> Cale: poke is a function for a Storable?
11:05:53 <Cale> (or lists, if there's an ordering on the outgoing edges you'd like to maintain)
11:05:57 <Cale> siriusbtx: yeah
11:06:10 <aweinstock> :t Foreign.Marshal.new
11:06:12 <lambdabot> Foreign.Storable.Storable a => a -> IO (GHC.Ptr.Ptr a)
11:06:20 <siriusbtx> Cale: thx that what was I was looking for. Didnt know how to get a value in the pointer
11:06:22 <johnw> you can also StablePtr your object in the heap and then get a Ptr to that
11:06:27 <johnw> to avoid copying it through poke
11:06:41 <siriusbtx> johnw: well I am just playing around with SDL to learn haskell
11:06:49 <siriusbtx> johnw: so dont rly care about performance or w/e
11:06:54 <johnw> that's good
11:07:04 <ski> @hoogle poke
11:07:04 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
11:07:04 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
11:07:04 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
11:07:05 <johnw> using the FFI to "learn Haskell" is maybe not as good
11:07:27 <Cale> Yeah, this binding looks a bit sad, maybe there's something built on top of it?
11:07:57 <siriusbtx> johnw: ive studied haskell a while but im tired of the theory :)
11:08:12 <siriusbtx> johnw: so im gonna try to write a ray caster in haskell
11:08:36 <johnw> I can never get enough of the theory
11:08:48 <johnw> we should have as support group for abstract theory junkies
11:09:09 <siriusbtx> johnw: practical experiences makes the theory more clear to me
11:09:15 <hodapp> why a ray caster?
11:09:16 * hackagebot fusion 0.2.0 - Effectful streaming library based on shortcut fusion techniques  https://hackage.haskell.org/package/fusion-0.2.0 (JohnWiegley)
11:09:21 <johnw> yay, fusion is now twice as fast as conduit on my benchmark pipelines; but props to conduit, which is _very_ fast for the functionality it offers (3x as fast as pipes for the same pipeline)
11:09:21 <siriusbtx> hodapp: why not
11:09:38 <aweinstock> siriusbtx: you don't need to do FFI to output images (e.g. https://github.com/aweinstock314/neural-networks/blob/master/VisualizeFunction.hs)
11:09:45 <hackrilege> Cale, so my map is fromList on a list of pairs of flags and values which include a list of flags that are my neighbours?
11:09:55 <Cale> hackrilege: So, for instance, you can make this more elaborate like  Map Vertex (VertexLabel, Set (ArcLabel, Vertex))
11:10:12 <Cale> Or  Map Vertex (VertexLabel, Map ArcLabel Vertex)
11:10:27 <Cale> Or split that into two maps, one for the labelling and one for the adjacency
11:10:46 <Cale> There are lots of data types around there which are pretty similar to work with
11:10:46 <hackrilege> wowza
11:10:53 <siriusbtx> aweinstock: id like some realtime feedback :)
11:11:04 <hackrilege> ok it looks strong
11:11:04 <ralu> is there common  way to enforce some operations ordering trough type system. For example one can read file unless it is opened first.OR is this just bad idea
11:11:37 <Cale> hackrilege: If you're comfortable with pointers in C, you can think of the Map as being like a miniature C heap where the keys in the Map are your pointers.
11:11:42 <aweinstock> siriusbtx: fair enough
11:11:59 <geekosaur> ralu, don't know of common ones, but it's an area various people work in
11:12:00 <hackrilege> i am not comfortable with C
11:12:20 <geekosaur> there's a certain tradeoff between safety and how cumbersome the interface is, for one
11:12:24 <ralu> does this people make any publications?
11:12:26 <Cale> All right then, it's probably easier not to think like that anyway, but it helps some people :)
11:12:31 <geekosaur> and exception handling, etc.
11:12:48 <johnw> ralu: there are publications on exactly that question, in fact
11:12:56 <hackrilege> my first lesson in programming was from Philip Wadler, lambda man
11:15:44 <breadmonster> How does the GC work in ghc?
11:16:01 <breadmonster> Is it mark and sweep? Or generational?
11:16:10 <breadmonster> And does it reorder the heap?
11:16:43 <hackrilege> Cale: is my datatype the same as data CyclicTree a = Map Int ([Int],a) 
11:16:52 <bennofs> breadmonster: it's a copying, generational collector AFAIK
11:16:56 <mauris_> siriusbtx: re "why not": because graphics programming is inherently low-level and mathematically oriented, and will teach you less about haskell than many other projects
11:17:10 <bennofs> breadmonster: see https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/GC
11:17:11 <breadmonster> bennofs: So there's no like real time stopping like OCaml?
11:17:27 <bennofs> breadmonster: it's stop-the-world
11:17:45 <mauris_> siriusbtx: i mean, i'm not stopping you! but a raycaster is one of the programs that would be the *least* demonstrative of haskell's differences from other programming languages
11:17:57 <Cale> hackrilege: kind of... I don't know if they're entirely equivalent
11:18:08 <breadmonster> bennofs: Then how is Haskell used for real time systems?
11:18:41 <hackrilege> but i can store my neighbours like this and my values.. i dont know about the "closed loop" bit though...
11:18:50 <bennofs> breadmonster: mostly by writing haskell code that generates C code (or other code that works without GC) I believe
11:19:20 <bennofs> breadmonster: see for example atom
11:19:24 <bennofs> @hackage atom
11:19:24 <lambdabot> http://hackage.haskell.org/package/atom
11:19:31 <Cale> hackrilege: One thing is that with Map Vertex [Vertex] or so, you don't necessarily have a notion of which Vertex is the "root"
11:20:00 <hodapp> bennofs: or Ivory, and its delicious type signatures you just saw!
11:20:02 <hackrilege> without that part of the datatype im not sure how i would avoid repeatedly traversing the Map by repeatedly referencing neighbours, i guess id have to store an pass a list of viseted node lables while traversing...
11:20:14 <bennofs> @hackage ivory :)
11:20:14 <lambdabot> http://hackage.haskell.org/package/ivory :)
11:20:21 <Cale> hackrilege: Set is usually a bit better for that
11:20:48 <hackrilege> Set... ok
11:21:03 <Cale> But yeah, traversing the graph, you'd collect a set of visited nodes
11:21:16 <Cale> So that you wouldn't follow cycles forever.
11:21:41 <hackrilege> but with my tree i just stepped to my neighbour and hit a "closed tree" at some point where it referenced itself. this was safe and fast
11:21:42 <Cale> Your type imposes some extra structure about where the cycles "begin"
11:22:12 <hackrilege> its fine to do so arbritrarily as its ill defined as to which would be the ideal choice
11:22:47 <hackrilege> begin and close cycles where you like as long as you can traverse them quickly
11:22:49 <ralu> is there haskell tool for programming real time system?
11:22:59 <siriusbtx> mauris: true, but thats what currently intrests me
11:23:11 <siriusbtx> mauris: so id rather do something im intrested in that something im not
11:23:21 <Cale> So yeah, there might be some up-sides to your representation, but it might be a lot trickier if you want to modify the graph, for instance.
11:23:32 <bennofs> ralu: you mean one that doesn't generate C code (like ivory and atom do) ?
11:23:48 <hackrilege> i can store reference to the ellement I know is in the best place to start navigating from
11:23:49 <ralu> even generating C code is fine
11:23:50 <Cale> hackrilege: Like, if you want to add a new arc to the graph, then the manner in which you break cycles might have to change a bunch
11:23:57 <siriusbtx> mauris: what would you suggest as a project to learn haskell?
11:23:59 <bennofs> ralu: well, look up ivory or atom :)
11:24:07 <Cale> hackrilege: But I don't know if you even need to do that :)
11:24:15 <hackrilege> yes, i guess the changing is easy with string or Int refereincing
11:24:31 <hackrilege> im not sure that i do actually
11:24:51 <Cale> Yeah, you just look in the Map for the vertex the arc comes from, and modify the Set you find there, inserting the new neighbour.
11:25:00 <hackrilege> but anyway, the idea was to get a lens to do the work, and this is done for me already with Map so i guess i shuld just use it...
11:26:35 <hackrilege> I think maybe I was trying to do it this way because I dont understand lens, so I dont understand Map's implementation, and I thought if I did my own lens instance for this datastructure then I would understand what was going on better... I cant actually use the Map package so easily...
11:26:50 <mauris> siriusbtx, the famous "write you a scheme" tutorial is very nice
11:27:24 <mauris> it's great practice on how to use ADTs and parsing and various monads
11:29:09 <aweinstock> siriusbtx: if you want to do graphics stuff, you can do that in haskell too (it might be more complicated due to learning both the graphics math and haskell at the same time, but that might be a worthwhile tradeoff to you)
11:29:37 <siriusbtx> mauris: ye that was my second project rewriting my c compiler in haskell
11:30:02 <siriusbtx> aweinstock: ray casting is probably the easiest you can do in 3d rendering
11:30:13 <siriusbtx> aweinstock: ray casting != ray tracing
11:32:50 <siriusbtx> johnw: how wuold that StablePtr work? Since castStablePtrToPtr returns a Ptr () and not a Ptr Rect
11:32:54 <tpsinnem> can anyone explain why might this be happening?:
11:32:55 <siriusbtx> would*
11:32:55 <tpsinnem> System/Log/FastLogger/File.hs:6:1:
11:32:56 <tpsinnem>     System.Directory: Can't be safely imported!
11:32:56 <tpsinnem>     The module itself isn't safe.
11:33:14 <tpsinnem> the hackage page for directory at least says it's safe
11:33:53 <bennofs> siriusbtx: you can castPtr a Ptr () to a Ptr a
11:33:59 <siriusbtx> bennofs: ty
11:35:13 <bennofs> siriusbtx: not sure if that works as you expect though
11:35:27 <ttt_fff> serious question: how many people here use erlang for distributed systems?
11:35:28 <siriusbtx> bennofs: we'll see in a second :P
11:35:43 <bennofs> siriusbtx: the documentation says: "No guarantees are made about the resulting value, except that the original stable pointer can be recovered by castPtrToStablePtr."
11:35:43 <glguy> tpsinnem: Are you looking at the documentation for the version of directory that you're using?
11:36:05 <siriusbtx> bennofs: idd my program crashes
11:36:29 <johnw> siriusbtx: ah, maybe not then :(
11:37:08 <siriusbtx> btw is haskell suited for web development?
11:37:19 <ttt_fff> johnw: do you use erlang?
11:37:23 <bennofs> siriusbtx, johnw: Haskell values are represented differently than C structs, so you're not going to get around a marshalling step
11:37:23 <ttt_fff> despite being a haskell master
11:37:26 <johnw> ttt_fff: no
11:37:27 <bennofs> siriusbtx: yes it is
11:37:32 <johnw> bennofs: great point
11:37:42 <ttt_fff> johnw: have you ever had to write a soft real time system ?
11:38:19 <siriusbtx> bennofs: any suggestions for a library for webdevelopment? (I dont like frameworks)
11:38:34 <johnw> ttt_fff: no
11:38:53 <bennofs> siriusbtx: easy/small ones are scotty or spock (I've only used scotty a little bit, haven't use spock)
11:39:03 <siriusbtx> kk
11:39:45 <dmj`> siriusbtx: servant is cool, http://www.arow.info/blog/posts/2015-07-10-servant-intro.html
11:40:22 <tpsinnem> glguy: yes as far as i can tell. at least that's the version i have in my .cabal directory
11:40:34 <tpsinnem> agh, he's gone
11:40:35 <siriusbtx> dmj`: ill loot at it
11:41:08 <tpsinnem> glguy: yes as far as i can tell. at least that's the version i have in my .cabal directory
11:42:11 <tpsinnem> and fast-logger doesn't specify any particular version
11:42:50 <dmj`> siriusbtx: what kind of web development? Are you building an html forms app, or a single page application
11:43:36 <siriusbtx> dmj`: im not writing anything atm
11:43:42 <siriusbtx> dmj`: maybe in the future
11:44:32 <tpsinnem> glguy: apparently the same error comes up in a Travis build, so it's not just at my end: https://travis-ci.org/idris-lang/Idris-dev/jobs/75272495
11:46:24 <glguy> tpsinnem: Which version of GHC are you using?
11:46:46 <tpsinnem> glckr: 7.8.2
11:46:48 <tpsinnem> aef
11:46:51 <tpsinnem> glguy
11:47:13 <glguy> tpsinnem: It might be the case that directory now only infers as Safe when compiled with GHC 7.10.2 (and the new base library)
11:47:19 <glguy> or 7.10.*
11:47:27 <tpsinnem> ok
11:48:10 <comprehension> hey all
11:48:22 <comprehension> what does the empty production in Happy match? 
11:50:44 <Cale> comprehension: The empty string? I'm not sure what you're referring to.
11:51:12 <glguy> tpsinnem: https://github.com/haskell/directory/issues/30
11:51:36 <tpsinnem> glguy: many thanks!
11:51:53 <comprehension> Cale: Happy suggests using empty productions as part of a rule for "zero or more repetitions of foo"
11:52:06 <arkeet> zero repetitions of foo is the empty string.
11:52:14 <Cale> Then yeah, that matches the empty string successfully.
11:52:19 <comprehension> but when i add that production in, it seems like it matches *every* input
11:52:53 <Cale> The empty string is an initial substring of any string.
11:53:37 <comprehension> Cale: so how can i make it use a "useful" production when possible, rather than just matching the empty string and stopping after the first token?
11:54:00 <Cale> Force it to look for something after the sequence.
11:54:16 <Cale> (which won't be there unless it's matched enough occurrences of the thing)
11:54:18 * hackagebot purescript 0.7.2.1 - PureScript Programming Language Compiler  https://hackage.haskell.org/package/purescript-0.7.2.1 (PhilFreeman)
11:54:28 <comprehension> i can also see two possible ways for it to match "the empty string" in relation to the token stream that's coming in --- either TokenEOF (the string that doesn't contain anything), or any token 
11:54:57 <comprehension> Cale: won't it need to look down the non-empty rule and then do backtracking?
11:55:04 <Cale> maybe
11:55:14 <haskell780> http://lpaste.net/138618 . Why does type of isPrime return isPrime :: (Floating a, Integral a, RealFrac a) => a -> Bool while the type of sqrt is sqrt :: Floating a => a -> a
11:55:18 <comprehension> i have a trace statement in the non-empty rule and it never gets hit
11:55:22 <Cale> That depends on the implementation of the parser
11:55:33 <Cale> It may build a table which will help it avoid backtracking
11:55:38 <comprehension> hm, okay
11:55:46 <arkeet> :t round . sqrt
11:55:47 <lambdabot> (Floating a, Integral c, RealFrac a) => a -> c
11:55:50 <Cale> I don't know the details of the algorithm that Happy uses.
11:56:08 <ski> haskell780 : use `round . sqrt . fromInteger' ?
11:56:15 <arkeet> (or fromIntegral)
11:56:34 <ski> er, yes. i meant to say what arkeet suggested
11:56:42 <comprehension> thank you. my parser is incomplete right now and it might be that there's no path from the start state to a terminal
11:57:30 <haskell780> ok but sqrt accepts a floating point type so when I pass it a Integer type it blows so why is not narrowed to floating point as sqrt is the first function applied
11:58:08 <arkeet> there is no narrowing.
11:58:09 <geekosaur> :t rem
11:58:10 <lambdabot> Integral a => a -> a -> a
11:58:24 <arkeet> you have to explicitly convert between numeric types.
11:58:52 <Cale> Yeah, the problem is you *also* want to apply rem, which wouldn't work on any instance of Floating
11:59:03 <geekosaur> ^ you invoke rem on "num", which adds an Integral constraint. Haskell's type system does not have the ability to conclude that no type can be both Floating and Integral
11:59:13 <Cale> There's no type of number which supports both rem and sqrt at the same time
11:59:19 * hackagebot varying 0.1.1.1 - Automaton based varying values, event streams and tweening.  https://hackage.haskell.org/package/varying-0.1.1.1 (SchellScivally)
11:59:27 <Cale> So you need to convert one way or the other
11:59:32 <arkeet> btw, you can avoid using sqrt
11:59:44 <arkeet> > takeWhile (\x -> x^2 < 90) [3..]
11:59:46 <lambdabot>  [3,4,5,6,7,8,9]
11:59:52 <arkeet> or <= or whatever.
12:00:00 <haskell780> how can i avoid sqrt?
12:00:06 <arkeet> I just siad.
12:00:09 <arkeet> said
12:00:33 <Cale> Yeah, it does eventually cost more to do all that squaring, but it works for all Integer values, whereas using sqrt and converting to Float will eventually mess up.
12:00:56 <Cale> If you want a really serious implementation, it might be worthwhile to use an Integer square root algorithm.
12:01:01 <Cale> (but you won't get one from the Prelude)
12:01:39 <arkeet> hm, is there something on hackage that provides that?
12:02:29 <haskell780> cool. I was thinking that three types were there for isPrime bcoz i use even which requires integer and sqrt which requires floating point.
12:02:36 <Cale> Yeah, I believe arithmoi provides high quality implementations of lots of number theoretical stuff like this
12:02:50 <Cale> http://hackage.haskell.org/package/arithmoi
12:03:19 <Cale> http://hackage.haskell.org/package/arithmoi-0.4.1.3/docs/Math-NumberTheory-Powers-Squares.html
12:03:22 <arkeet> btw, Integral and Floating are different from Integer and Float.
12:03:24 <Cale> Lots of square roots :)
12:03:28 <arkeet> the former are type classes.
12:04:45 <haskell780> ok.. I am a newbie to haskell so I am not much informed about the exact term usage.
12:06:12 <maerwald> Cale: we still lack numpy :P
12:07:25 <Cale> I don't really know all of what numpy does, but there's a fair amount of stuff available in various packages.
12:07:29 <sunnymilk> are there refactoring tools for haskell
12:07:40 <Cale> sunnymilk: Which do what?
12:07:49 <sunnymilk> like if i wanted to replace a top level identifier foo with bar, either in an entire project or just in one submodule, is there a program to do that?
12:08:02 <maerwald> in haskell you refactor with sed (no kidding)
12:08:05 <sunnymilk> :|
12:08:09 <Cale> wat
12:08:29 <sunnymilk> is there really nothing that can do that that actually understands haskell
12:08:35 <Cale> There's a program called HaRe that I'm not sure whether it's been maintained for a while.
12:08:39 <maerwald> last time I had to upgrade for the new diagrams version, I just did it with sed... compile and check for errors, fix them all blindly
12:08:40 <maerwald> and it works
12:08:46 <ww> find . -name \*.hs | xargs sed -i 's/^foo /bar /'
12:08:48 <sunnymilk> maerwald thats really depressing
12:08:53 <maerwald> without even thinking about what the code does
12:08:56 <maerwald> sunnymilk: not at all
12:09:03 <sunnymilk> ww that isnt exactly what i asked for
12:09:03 <Cale> I guess you can use sed if you like sed :)
12:09:10 <Cale> I'd just use my editor...
12:09:26 <sunnymilk> it should also replace calls to foo with bar instead
12:09:30 <sunnymilk> and also not do it inside comments
12:09:31 <kadoban> Yeah I just search/replace in vim  can't say it's ever been painful enough to make me want a tool for it.
12:09:37 <maerwald> sunnymilk: my point is... there's not much to think about when doing large changes like renaming stuff or using new functions, because the types will tell you if it's right
12:09:49 <maerwald> so we don't need a lot of things e.g. a java IDE would need
12:09:54 <geekosaur> well, in Haskell it's not like you need a lot of help with it. most forms of refactoring are either type driven (and the compile errors are an accurate guide), or at a design level that no tool can help you with
12:10:13 <Cale> You can generally just change something, then run ghc and it'll tell you what else to change.
12:10:22 <hackrilege_> Cale: I had a go using Map for my problem, can you take a look? http://lpaste.net/138620
12:10:23 <Cale> with source locations for everything
12:10:29 <sunnymilk> but that is a lot of work
12:10:31 <hackrilege_> sorry if your busy..
12:10:47 <maerwald> not compared to what I know from C
12:11:01 <pgib> refactoring tools have a knack for screwing stuff anyway.. I agree with edit search/replace. I prefer validating the changes
12:11:04 <sunnymilk> regex search and replace also is difficult or impossible to use for more complicated examples
12:11:24 <Cale> sunnymilk: Well, don't even regex search then. Just change the name at the definition site
12:11:27 <sunnymilk> ie, replace all foo x y with foo y x, and all partially applied foos with (flip foo)
12:11:31 * mauris patiently waits for jetbrains to make a Haskell IDE
12:11:34 <Cale> and let the compiler find all the things which need changing after that
12:11:40 <ww> as i said...
12:11:45 <maerwald> mauris: we already have leksah
12:12:06 <sunnymilk> Cale but then you havr ot do it all manually
12:12:23 <sunnymilk> im wondering if theres something that will do work for me so i dont have to
12:12:28 <mauris> does it have their style of powerful refactoring tools, though?
12:12:36 <sunnymilk> that isnt regex search and replace
12:12:39 <ww> sunnymilk: the compiler does most of the work for you
12:12:43 <sunnymilk> no it does not
12:12:47 <sunnymilk> it doesnt change my source code for me
12:12:53 <sunnymilk> it just tells me what i have to change, this is not the same as doing it for me
12:13:09 <Cale> sunnymilk: Well, it doesn't do that little bit of typing for you, but it does the job of finding all the places where you need to edit.
12:13:10 * arkeet thinks the question has been answered
12:13:10 <ww> knowing what to change is most of the work
12:13:18 <Cale> (which I would say is most of the actual work)
12:13:29 <sunnymilk> arkeet it hasnt, nobody has said "no such a tool does not exist that does what i want"
12:13:45 <mauris> i'm afraid it doesn't exist (yet)
12:13:50 <sunnymilk> thank you
12:13:55 <sunnymilk> thats what i wanted to know
12:14:12 <Cale> sunnymilk: If you wanted to work on one, you might want to see if you can get HaRe working.
12:14:27 <maerwald> sunnymilk: did you try leksah? maybe it has such support, I am not sure
12:14:29 <ww> you could take the output of the compiler, which is already parsed by emacs, and write a little function that does the replacement on those lines...
12:14:39 <maerwald> but that would be your best bet I'd say
12:14:48 <alanz> Cale,sunnymilk: There should be a GHC 7.10.2 version of HaRe in a month or so
12:14:52 <sunnymilk> Cale maerwald those sound very interesting! ill have to look at those
12:14:56 <Cale> alanz: cool
12:15:02 <hackrilege_> oh god no you shouldnt let the compiler change your source thats insane!
12:15:02 <sunnymilk> ww that sounds very difficult and fragile
12:15:17 <alanz> See https://github.com/alanz/HaRe/tree/wip
12:15:23 <sunnymilk> hackrilege_ you could run it in a loop until it reaches a fixed point and compiles :p
12:15:26 <ww> unless you spend a lot of time renaming top-level functions, it's probably much more work than just doing it...
12:15:27 <maerwald> after I installed 7.10, pretty much none of my packages compiled anymore :D
12:15:31 <sunnymilk> alanz sweet!
12:16:35 <hackrilege_> imagine if it started propagating type errors around... the point of a type error is that what you have told the compiler to do does not make sense, there is no way it could try and infer what you meant and implent that for you, you must rephrase the code you submit to the compiler until it understands you. thats it
12:16:58 <ww> hackrilege_: that would be amusing
12:17:32 <hackrilege_> sunnymilk, yes i suppose you culd also get the compiler to generate source code and reimplement itself in a trial and error way, with success being it could compile that program... but really i think its damn near impossible
12:17:35 <ww> but in this case i meant specific errors relating to a specific symbol that isn't defined (because it has been renamed)
12:17:42 <sunnymilk> hackrilege_ of course its absolutely absurd
12:17:55 <sunnymilk> i would not try to do it
12:18:06 <Cale> sunnymilk: But yeah, in my experience, it's rarely enough work that if you had to take time to set up a tool to do it for you that the tool could pay for itself in one go.
12:18:55 <hackrilege_> ww: if you dont tell it what you mean, how can it know what you mean?
12:19:22 <hackrilege_> o sorry i misread your comment...
12:19:56 <Cale> sunnymilk: I've done more subtle refactorings, where I replaced a fundamental datatype (not a simple name change, but a structural change), and then just steamrolled the compiler over my code, doing what it told me to do until it stopped complaining, and after hundreds of edits spread over ~8k lines of code, the whole thing actually worked immediately once it compiled.
12:20:18 <hackrilege_> can anyone look at my paste and help me understand how to use a lens on this Graph? http://lpaste.net/138620
12:20:28 <Cale> I wouldn't have been able to do that refactoring in any automated way I can think of though.
12:21:06 <Cale> I usually don't just want to rename something, but actually change stuff in a deeper way, and for that, automation isn't likely to be too successful.
12:21:24 <codedmart> Anyone that can help me with the overlapping instance problem? http://lpaste.net/138505
12:21:38 <codedmart> Compiles fine but this doctest fails on 7.8, but not 7.10.
12:21:50 <Cale> hackrilege_: Well, what sort of lens? You want to focus on the label at a particular index?
12:22:32 <hackrilege_> Cale, firstly id like it if you could tell me if any of the things I have already done could have been done using a lens...
12:23:22 <hackrilege_> i think the Map datatype is not an instance of Lens, so I can still do a lot with it, I guess why would I need a Lens? because it is natural to define one/
12:23:33 <Cale> Lens isn't a type class
12:23:41 <hackrilege_> oh
12:23:42 <hackrilege_> my mistake
12:23:48 <Cale> There are lenses for accessing maps
12:24:21 <Cale> But whether or not they're worth bothering with is another thing -- it really depends on whether you're doing fiddly nested accesses
12:24:24 <hackrilege_> what are these "lenses" if they are not instances of a typeclass?
12:24:34 <arkeet> lenses are values
12:24:42 <Cale> They're values of type Lens a b c d for various types a b c d
12:24:48 <hackrilege_> I am doing brutally fiddely nested access and traversal
12:25:03 <Cale> Then yeah, maybe lenses would help
12:25:14 <arkeet> > view _2 (x,y,z) -- _2 is a lens
12:25:16 <lambdabot>  y
12:25:43 <arkeet> > set _2 w (x,y,z) -- the same lens
12:25:45 <lambdabot>  (x,w,z)
12:25:45 <hackrilege_> :t view
12:25:46 <lambdabot> MonadReader s m => Getting a s a -> m a
12:25:55 <arkeet> the types can be confusing.
12:26:11 <hackrilege_> why is not complaining that x is not in scope?
12:26:14 <arkeet> :t x
12:26:15 <lambdabot> Expr
12:26:25 <hackrilege_> !?
12:26:28 <benzrf> hackrilege_: lambdabot has some kind of package set up that provides letter names
12:26:30 <benzrf> > x + y
12:26:32 <lambdabot>  x + y
12:26:38 <Cale> Yeah, lens used to be a lot more simple, but various concessions have been made with respect to how easy it is to understand the types in order to obtain more generality.
12:26:41 <benzrf> > foldr1 (+) [x, y, z]
12:26:43 <lambdabot>  x + (y + z)
12:26:47 <benzrf> > foldl1 (+) [x, y, z]
12:26:49 <lambdabot>  x + y + z
12:26:50 <benzrf> :]
12:26:59 <hackrilege_> argh stop blowing my mind
12:27:38 <Cale> hackrilege_: It's a pretty simple trick. Expr is a type which is similar to String, but which implements instances of various type classes like Num and so on.
12:27:39 <hackrilege_> its ok, i think the type structure is pretty neat
12:27:40 <arkeet> the types given by :t can be confusing if you're unfamiliar with lens workings, but
12:27:49 <arkeet> the documentation is nice because
12:27:51 <arkeet> for example https://hackage.haskell.org/package/lens-4.12.3/docs/Control-Lens-Getter.html#v:view
12:28:05 <hackrilege_> > x+1
12:28:07 <arkeet> it gives various "example types"
12:28:07 <lambdabot>  x + 1
12:28:11 <arkeet> such as view :: Lens' s a -> s -> a
12:28:44 <maerwald> benzrf: how does lambdabot do that? it definitely does not work in ghci
12:28:56 <arkeet> the simple-reflect package
12:28:58 <Cale> I'm still a bit torn on the extensive use of type synonyms in Lens and pipes and various other libraries.
12:29:22 <Cale> Sure, it makes value-level usage kind of nice.
12:29:24 <hackrilege_> more pragmas!
12:29:31 <arkeet> https://hackage.haskell.org/package/simple-reflect-0.3.2/docs/Debug-SimpleReflect-Vars.html -- maerwald 
12:30:15 <hackrilege_> the main problem with Lens is that all anyone can say about it is its types arnt helpful...
12:30:16 <hackrilege_> which is none information
12:30:30 <Cale> hackrilege_: heh, well, there are various tutorials...
12:30:57 <ww> so then...
12:30:59 <ww> > f + 1
12:31:01 <hackrilege_> i understand it gives me getters and setters and ways to alter ellements, also these access operations are composable. thats all i know really
12:31:01 <lambdabot>      No instance for (Show a0)
12:31:01 <lambdabot>        arising from a use of show_M14559631751392706113914
12:31:01 <lambdabot>      The type variable a0 is ambiguous
12:31:06 <arkeet> > f + 1 :: Expr
12:31:06 <Cale> > f x + 1
12:31:09 <lambdabot>  f + 1
12:31:09 <lambdabot>  <no location info>: can't find file: L.hs
12:31:16 <Cale> > f x + 1
12:31:18 <lambdabot>      No instance for (Show a0)
12:31:18 <lambdabot>        arising from a use of show_M268458741893729251713957
12:31:18 <lambdabot>      The type variable a0 is ambiguous
12:31:25 <Cale> fine then :)
12:31:29 <Cale> > f x + 1 :: Expr
12:31:31 <lambdabot>  f x + 1
12:31:32 <hackrilege_> is there more too it than that?
12:32:03 <arkeet> hackrilege_: that's the starting point
12:32:11 <Cale> hackrilege_: That's the big picture, yeah. There are various details like prisms which do a similar thing for types with multiple constructors.
12:32:12 <hackrilege_> then what?
12:32:23 <hackrilege_> cool
12:32:29 <flux> personally I would use linux raid for that. so, partitioning time.. I'm not sure if swap over btrfs files is supported currently.
12:32:31 <Cale> hackrilege_: But mostly it's just composable getters and setters for mutable data
12:32:35 <flux> oops
12:32:38 <Cale> er, immutable data rather
12:32:41 <arkeet> like
12:32:53 <hackrilege_> so the only reason i use lenses is to compose accessors and use prisms?
12:32:53 <arkeet> the most obvious thing to do for composable getting and setting is something like
12:33:13 <arkeet> data Lens s a = Lens { view :: s -> a, set :: a -> s -> s }
12:33:24 <arkeet> and define some way to compose them (making Lens a Category)
12:33:33 <arkeet> but
12:33:42 <hackrilege_> and make them functors and applicative and so on
12:33:52 <arkeet> no, it can't be.
12:33:59 <hackrilege_> oh
12:34:04 <Cale> hackrilege_: You might, if you use a lot of record syntax, find yourself writing things like  theEmployee { contactInfo = contactInfo theEmployee { phoneNo = x } }
12:34:14 <Cale> hackrilege_: lenses clean up this kind of mess
12:34:34 <arkeet> set (contactInfo . phoneNo) x theEmployee
12:34:43 <arkeet> or, if you use lens operators...
12:34:49 <hackrilege_> yes I had this example of heavily nested data http://lpaste.net/138478
12:34:51 <arkeet> theEmployee & contactInfo . phoneNo .~ x
12:34:53 <mniip> (don't use lens operators)
12:35:00 <arkeet> (why not?)
12:35:03 <hackrilege_> i wrote this yeasterday 
12:35:07 <Cale> There are other ways of cleaning up that mess, but lenses are one particularly nice one.
12:35:32 <Zemyla> But Lens can't be a functor, as a is on both the positive and negative sides?
12:35:32 <mniip> Cale, van laarhoven lenses specifically
12:35:36 <arkeet> Zemyla: right.
12:35:45 <Cale> mniip: hm?
12:35:55 <Cale> mniip: Any kind of lenses
12:35:57 <hackrilege_> thanks Zemyla
12:35:58 <Cale> :)
12:36:13 <arkeet> van laarhoven lenses just let you compose with regular function composition (.)
12:36:16 <mniip> well for "any kind of lenses" you don't get the Prelude.. to work
12:36:24 <Cale> mniip: Yeah, that doesn't matter
12:36:30 <ww> makes me think of spinoza
12:36:45 <hackrilege_> <mniip> (don't use lens operators) <- this what the voice in my head says to greet me when I wake up
12:36:52 <bennofs> mniip: lens' doesn't even implement van-laarhoven lenses exactly. Prisms are based on profunctor-style lenses
12:37:19 <arkeet> hm?
12:37:27 <arkeet> Lens in lens is exactly a van laarhoven lens
12:37:29 <mniip> hackrilege_, I mean lens operators would be okay if there was some structure in them
12:37:37 <arkeet> there is!
12:37:41 <hackrilege_> if?
12:37:58 <mniip> as opposed to "% is usually related to mapping"
12:38:10 <bennofs> mniip, arkeet: ok right, Lens is van laarhoven (but index preserving lenses are not :)
12:38:58 <Cale> (.~) I don't really hate, but I also don't really see the need for it. (&) is dumb, because it inverts application order for no good reason. But these aren't the lens operators I really oppose too much.
12:39:11 <hackrilege_> lets be clear, this is a paradigm changing package which is causing me to have to relearn my native language. Can we be clear about what it is and what it does please
12:39:34 <arkeet> bennofs: the profunctor thing is just a generalization
12:39:41 <bennofs> mniip: there is a structure:  ~ means "modify in reader monad (mostly used instance of reader is (->))", = means in state monad, % is update with function 
12:39:44 <arkeet> at least it's not pure profunctor lenses (p a b -> p s t)
12:39:47 <Cale> The ones which I have a problem with are the things like (+~) and the 18 million variations on that
12:40:03 <Cale> That are all unnecessary because we're using a functional programming language
12:40:10 <hackrilege_> yes, they should be defined by the user in terms of (+) for sure
12:40:10 <arkeet> there is no "modify in reader monad". it's just a function.
12:40:22 <mniip> :t (.~)
12:40:22 <Tuplanolla> Is there a tool for converting Haskell code with {-# LINE 42 "File.lhs" #-} pragmas back into literate Haskell code?
12:40:23 <lambdabot> ASetter s t a b -> b -> s -> t
12:40:33 <arkeet> Cale: you are free to %~ (+1)
12:40:38 <Cale> arkeet: and I would
12:40:48 <Cale> arkeet: Given that %~ exists, +~ shouldn't
12:40:58 <Zemyla> :t (+~)
12:40:59 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
12:41:12 <bitemyapp> :t (%~)
12:41:14 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
12:41:15 <arkeet> Cale: but it's darn handy sometimes.
12:41:25 <mniip> :t (.=)
12:41:26 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
12:41:28 <bennofs> yeah, writing x *= 3 is just nice :D
12:41:31 <mniip> okay
12:41:34 <Cale> arkeet: Not handy enough to justify its separate existence, imo.
12:41:39 <mniip> it makes more sense than I initially suspected
12:41:44 <bitemyapp> Cale the Minimalist
12:41:46 <arkeet> it's obvious what it does.
12:41:47 <Cale> x %= (*3) seems fine to me
12:41:57 <bitemyapp> @ty (%=)
12:41:58 <lambdabot> (Profunctor p, MonadState s m) => Setting p s s a b -> p a b -> m ()
12:42:14 <hackrilege_> it should at least come in its own submodule accessed only at the users desire
12:42:17 <bennofs> Cale: x += 3 + y ? 
12:42:39 <bennofs> hackrilege_: import Control.Lens.Combinators    -- no operators
12:42:57 <Cale> bennofs: x %= (+ (3 + y))
12:43:00 <bitemyapp> @ty (.=)
12:43:01 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
12:43:07 <arkeet> "This lets the subset of users who vociferously disagree about the full scope and set of operators that should be exported from lens to not have to look at any operator with which they disagree."
12:43:11 <arkeet> haha
12:43:24 <Cale> arkeet: Yeah, kinda
12:43:32 <hackrilege_> thanks bennofs
12:43:33 <bitemyapp> .= overlapping in lens and aeson drives me crazy.
12:43:33 <Cale> It doesn't stop people from using those operators though.
12:43:37 <bitemyapp> that's my only problematic operator.
12:43:49 <Cale> So such users may still be forced to deal with code that uses them. :P
12:44:16 <Tuplanolla> I guess not.
12:44:18 <arkeet> I still think it's obvious what they do.
12:44:35 <Cale> Also, what the heck? Why isn't .= function composition modifying assignment?
12:44:41 <hackrilege_> there should be as few infix functions as possible... they are blinding 
12:45:09 <maerwald> then we'd do a lot more () stuff
12:45:09 <arkeet> Cale: that seems like it would get little use.
12:45:13 <arkeet> and obviously simply = won't work.
12:45:30 <bennofs> :t (<<<>~) -- my personal favourite
12:45:30 <hackrilege_> <*> and <$> are enough to start with anyway.. then all these ^ ~ things...
12:45:31 <lambdabot> Monoid r => Optical' (->) q ((,) r) s r -> r -> q s (r, s)
12:45:49 <Cale> arkeet: Well, I don't use lens all that much, but I've often maintained a state which was a function and done updates to it by composition.
12:46:07 <arkeet> but .= suggests composition on the right.
12:46:08 <Cale> arkeet: It's pretty common when you're doing ShowS-like stuff.
12:46:10 <hackrilege_> Optical'...
12:46:12 <arkeet> I guess maybe.
12:46:22 <arkeet> but you would just use %= (. f) anyway.
12:46:26 <arkeet> :-)
12:46:29 <Cale> Right, I would.
12:46:42 <Cale> But if I saw .= that's what I'd expect anyway.
12:46:53 <Cale> It's just a big mess imo.
12:46:57 <arkeet> and if you actually had a monoid like Endo or something, you could use <>=
12:47:15 <bennofs> hackrilege_: in next lens version, the type will be LensLike' ((,) r) s r -> r -> s -> (r,s)
12:49:15 <hackrilege_> crazy... anyway im getting nowhere... ill be back with a better problem presently
12:49:22 <Tuplanolla> Is there a tool for converting Haskell code with {-# LINE 42 "File.lhs" #-} pragmas back into literate Haskell code or do I have to make my own?
12:49:40 <mniip> bennofs, and what would be, view in the state monad
12:49:42 <Cale> hackrilege_: I think we kind of have an unfortunate state of affairs where the best way to understand everything about lens is to have begun using it back when it was starting out, and been around for all the changes.
12:49:59 <bennofs> mniip: there is no operator for that. but the function is called use
12:50:09 <Cale> hackrilege_: You can get a good idea for what lenses are about just by defining them in a different way:
12:50:31 <Cale> data Lens a b = L { view :: a -> b, set :: b -> a -> a }
12:50:42 <Cale> or, for type-changing lenses, you'd have:
12:50:43 <hackrilege_> i like that definition
12:52:15 <hackrilege_> sorry you trailed off.. 
12:52:17 <Cale> data Lens s t a b = L { view :: s -> a, set :: t -> a -> b } -- I think that's the right convention.
12:52:28 <mniip> Cale, s -> b -> y
12:52:32 <mniip> t
12:52:33 <arkeet> set :: s -> b -> t
12:52:38 <Cale> ah, okay :)
12:52:51 <arkeet> old outer value, new inner value, new outer value.
12:53:01 <mniip> Lens oldpicture newpicture oldelement newelement
12:53:23 <Cale> right, right
12:53:59 <arkeet> :t set
12:54:00 <lambdabot> ASetter s t a b -> b -> s -> t
12:54:10 <arkeet> flipped I guess.
12:54:17 <Cale> So, yeah
12:54:25 <Cale> data Lens s t a b = L { view :: s -> a, set :: b -> s -> t }
12:54:28 <mniip> isomorphic
12:54:29 <Cale> yes, that makes more sense
12:55:58 <Cale> anyway, yeah, you'd implement values of that type of lens like:  fstL = L { view = \(x,y) -> x, set = \x' (x,y) -> (x',y) }
12:56:02 * ski sadly stabs a lens on lent
12:56:23 <Cale> and you could implement things like polymorphic composition of lenses
12:57:03 <Cale> hackrilege_: The sneaky thing about the definition of Lens in the lens package is that it avoids the need for a separate definition for composition of lenses -- (.) does the trick
12:58:00 <Cale> It uses a definition which is polymorphic in a choice of functor, and by plugging in either a constant functor, or the identity functor, you can extract view and set.
12:58:11 <Gurkenglas> Given two typed-hole expressions, I would like to substitute one for a typed hole in the other. Does some library help with this?
13:00:49 <hackrilege_> hmm
13:01:01 <Gurkenglas> (Ultimately I want to construct all the possible boolean expressions from a namespace, but going from the above to the former sounds like an unfold, while going from nothing to the former sounds like reimplementing the typechecker.)
13:01:16 <Gurkenglas> -nothing to the former+nothing to the above
13:02:28 <hackrilege_> so given a getter and a setter the Lens library will allow me to compose these.
13:03:19 <Cale> hackrilege_: Well, every lens is *both* a getter and setter
13:03:30 <hackrilege_> as well as being traversable and a functor
13:03:35 <hackrilege_> no..
13:03:37 <Cale> hackrilege_: Which taken together provide a sort of way of "focusing in" on a part of a structure.
13:04:08 <hackrilege_> hence the name lens
13:04:22 * hackagebot tictactoe3d 0.1.0.2 - 3D Tic-Tac-Toe game  https://hackage.haskell.org/package/tictactoe3d-0.1.0.2 (ryo0ka)
13:04:34 <ski> @where lenses
13:04:34 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-
13:04:34 <lambdabot> structure-access-and-mutation>
13:04:51 <zipper> Hey you know how stack promises to install build tools alex and happy for it's users?
13:05:09 <zipper> Well I ran into an issue where it didn't.
13:05:23 <hackrilege_> dead link
13:05:40 <zipper> How can I fix this since I want something that works with little complications because I want this to work on travis-ci
13:05:51 <zipper> Here is a gist of what's up https://gist.github.com/urbanslug/904f3ce8d15f5f579912
13:08:17 <hackrilege_> so if a lens is a structure created from a getter and setter functions which can be composed, what is a prism?
13:08:24 <zipper> *rebooting* still waiting for feedback.
13:08:47 <geekosaur> zipper, have you asked in #haskell-stack?
13:08:57 <zipper> geekosaur: No I haven't
13:09:01 <zipper> Let me join
13:09:58 <arkeet> hackrilege_: lenses let you manipulate one piece of a product. (so there are _1 and _2 lenses for pairs)
13:10:07 <mbrock> wow, this opens up whole new vistas for the lens operator discussion: http://stackoverflow.com/questions/31965349/using-emoji-in-haskell
13:10:09 <arkeet> prisms let you manipulate one piece of a sum. (so there are _Left and _Right lenses for Either)
13:10:34 <hackrilege_> how is either a sum?
13:10:49 <camm> Hi everyone, I have a doubt. When I use getCurrentTime (from the module Data.Time.Clock) I get 20:00:03 ... but it's 15:03 in my country. I don't understand that.
13:11:04 <Gurkenglas> How about a library that I can ask to unify two types?
13:11:06 <hackrilege_> mbrock: lol
13:11:07 <arkeet> > (preview _Left (Left 1), preview _Left (Right 2), review _Left 3)
13:11:08 <lambdabot>  (Just 1,Nothing,Left 3)
13:11:11 <bennofs> camm: that's UTCTime and not local time probably
13:11:29 <Mauke> hackrilege_: the number of possible values in Either A B is the number of possible values in A plus the number of possible values in B
13:11:37 <arkeet> ^
13:12:02 <Cale> (the fully-defined ones anyway)
13:12:02 <hackrilege_> camm: mine works ok, maybe your system clock is wrong or for some reason ghc cant see the right time?
13:12:08 <arkeet> lenses have get and set. prisms have review and preview
13:12:14 <arkeet> (and each has some set of laws)
13:12:22 <geekosaur> how are you checking that time?
13:12:36 * geekosaur recalls at one point an evil Show instance...
13:12:45 <geekosaur> but that may have even been old-time
13:12:57 <bennofs> getTime returns UTCTime, so not timezone adjusted probably
13:13:09 <bennofs> s/getTime/getCurrentTime
13:13:34 <bennofs> camm: try getZonedTime
13:13:36 <geekosaur> EDT by any chance, camm?
13:14:05 * geekosaur has his IRC client configured for UTC, and indeed it's showing 20:13 currently
13:14:08 <camm> thanks everyone, I'm going to try that.
13:14:16 * edwardk looks up and sees the standard Cale screed on lens operators.
13:14:19 <arkeet> geekosaur: ecuador, by the looks of it :-)
13:14:25 <arkeet> (which is in -0500)
13:14:42 <hackrilege_> well i guess you know my timezone...
13:14:43 <geekosaur> but summer time so likely -0400
13:14:49 <bennofs> edwardk: do you have a ping alert on lens or something? :p
13:15:00 <arkeet> they don't have summer time.
13:15:06 <geekosaur> hm
13:15:09 <edwardk> or something. i have a steadily rolling set of topics i let ping me, lens is usually on that list
13:15:12 <arkeet> (they don't have summer.)
13:15:22 <geekosaur> point
13:16:00 <hackrilege_> no, i dont get it, how is a preview and review working?
13:16:23 <arkeet> ok so
13:16:40 <arkeet> if we had data Lens s a = L { get :: s -> a, set :: a -> s -> s }
13:16:52 <arkeet> then we also have data Prism s a = P { review :: a -> s, preview :: s -> Maybe a }
13:17:10 <edwardk> arkeet: http://hackage.haskell.org/package/data-lens-2.10.7/docs/Data-Lens-Common.html
13:17:22 <hackrilege_> somthing to do with the possible vaules of Either A B being the product of the number of possible types for A and B
13:17:45 <arkeet> for _Left, review is Left, and
13:17:52 <arkeet> preview takes Left x to x and Right x to Nothing.
13:17:52 <edwardk> technically prism should be previous s -> Either s a -- otherwise it doesn't promote correctly to the type changing version
13:17:55 <arkeet> er, Left x to Just x
13:18:09 <arkeet> edwardk: trying to keep things simple atm :p
13:18:11 <edwardk> er preview :: 
13:18:43 <bennofs> hackrilege_: The number of values that the type Either A B has is the sum of the number of possible values of A and the number of possible values of B. So Either Bool Bool has 2 + 2 number of possible values [all this only holds if ignoring undefined]
13:18:52 <mniip> edwardk, I spy with my little eye something beginning with costate comonads
13:18:59 <arkeet> hackrilege_: Prism as it exists in lens is somewhat different, but the operations are basically what I said.
13:19:43 <edwardk> mniip: (s -> a, s -> a -> s)   can be fused into s -> (a, a -> s) -- which is s -> Store a s   'a costate comonad coalgebra', but when you look at Prism s a given by arkeet above it doesn't fuse into anything nice
13:20:32 <edwardk> this is one reason why i tend to view the costate comonad coalgebra view of lenses as an evolutionary dead-end. it gives no insights, it just exploits a coincidence
13:20:44 <mniip> edwardk, arr a s?
13:20:56 <mniip> where arr ~ (->) and arr ~ Cokleisli?
13:21:00 <hackrilege_> i understand preview as you describe it but _Left & review is Left i dont understand what review is doing.. what is _Left
13:21:20 <Cale> edwardk: haha
13:21:32 <Cale> (re: my screed)
13:22:03 <edwardk> mniip: for prism?
13:22:18 <mniip> yeah
13:22:21 <hackrilege_> edwardk i saw that approach in Functor is to Lens as Applicative is to Biplate..
13:22:23 <edwardk> you can get prism out of Choice p => p a b -> p s t.   and lens out of Strong p => p a b -> p s t
13:23:04 <edwardk> hackrilege_: yes, but it tops out. it gives you no deeper insights, it doesn't steer you towards prisms, in fact if you took 'costate comonad coalgebras' and looked for 'state monad algebras'  as the obvious 'dual' you'd get nothing interesting.
13:23:23 <hackrilege_> ok
13:23:37 <edwardk> on the other hand the Choice or Strong  p => p a b -> p s t    thing can be seen as two instances of the _same thing_ not dual constructions!
13:24:14 <edwardk> class Profunctor p => Strong p where second' :: p a b -> p (c, a) (c, b)
13:24:23 * hackagebot liquid-fixpoint 0.4.0.0 - Predicate Abstraction-based Horn-Clause/Implication Constraint Solver  https://hackage.haskell.org/package/liquid-fixpoint-0.4.0.0 (EricSeidel)
13:24:32 <edwardk> class Profunctor p => Choice p where right' :: p a b -> p (Either c a) (Either c b)
13:24:55 <mniip> why would prism be a dual of lens
13:25:01 <edwardk> both of them are simply with respect to a different choice of 'tensor' to equip a monoidal category. they don't need the 'product-like' nature
13:25:02 <mniip> that's not how that works
13:25:37 <hackrilege> lost
13:25:50 <edwardk> mniip: you can write down the lens laws in terms of view and set  and then write them down in terms of review and preview and you get analogous constructions where you flip the arrows from one to get the other
13:26:09 <hackrilege> sounds like a dual to me
13:26:30 <edwardk> but the fact that they are 'dual'-looking is also an accident, its the fact that prism has one relationship to a monoidal structure, and lens has the exact same relationship to a _different_ monoidal structure.
13:26:44 <mniip> edwardk, also
13:26:46 <edwardk> we can have this relationships to monoidal structures that aren't products or coproducts.
13:27:01 <edwardk> e.g. we can talk about lenses in the category of endofunctors on hask with respect to functor composition
13:27:06 <edwardk> that isn't a product!
13:27:09 <edwardk> or a coproduct
13:27:20 <edwardk> and so the costate comonad coalgebra dead-end would preclude you from thinking that thought
13:27:39 <mniip> edwardk, remember how I tried to reason about lenses/prisms/traversals/folds/isos with inversibility and so on
13:27:57 <edwardk> in non-symmetric monoidal categories you can even have left-lenses and right-lenses
13:29:09 <edwardk> basically what happens is the laws described in terms of get and put get entangled in the product and coproduct-like nature of the things they respect, those parts wind up making the whole construction look dual, but there is a better presentation out there, one step removed, which just talks about strength
13:29:21 <edwardk> and both lens and prism are an instance of strength with respect to a monoidal category
13:29:28 <mniip> basically, type Multiple s a = s -> [a]; type Single s a = s -> a; type Optional s a = s -> Maybe a
13:29:39 <hackrilege> you mean that since there are many such duals we could observe, we should treat all of them at once?
13:29:43 <edwardk> we can build an 'unlens' and 'unprism' that are instances of costrength with respect to a monoidal category, and flip back and forth between all these 4 points
13:30:00 <mniip> type Reversible t b = b -> t; type Contextful s t b = s -> b -> t
13:30:18 <mniip> Lens s t a b ~ (Contextful s t b, Single s a)
13:30:25 <edwardk> hackrilege_: my point is this, there are categories where you don't have a product, where, you have things that act sort of like a tuple, but where you lack fst and snd, where you can't throw anything away, such as categories in which you can think using linear logic or linear types. there are still lenses there!
13:30:37 <mniip> Prism s t a b ~ (Reversible t b, Optional s a)
13:31:01 <edwardk> mniip: you're addressing a symptom with this construction though, it doesn't extend to all the other cases where you can have optics in categories that just have monoidal structure
13:31:02 <mniip> Traversal s t a b ~ (Contextful s t b, Multiple s a)
13:31:32 <edwardk> you've embraced the accidental consequences of this construction in a single category/kind: *
13:31:52 <edwardk> now if i were to tell you we could build lenses into stacks of functors it wouldn't fit your worldview
13:32:41 <hackrilege> what is a stack of functors? f $ f $ f $ f ... $ f a?
13:32:52 <edwardk> we can lift natural transformations into functor composition, by applying them over the first or second half of compose. e.g. given f ~> g  i can take Compose f h ~> Compose g h     or Compose h f ~> Compose h g
13:33:54 <edwardk> hackrilege_: one way folks think about lenses is as a lens splitting s into (c, a) where c is the stuff 'out of focus' and a is the stuff you are looking for
13:34:37 <hackrilege> nice anlogy, i was trying to understand what you were saying about a lens into a stack of functors
13:34:39 <edwardk> we could do the same with functors, Lens f g   could split f into Compose c_1 (Compose g c_2)
13:35:08 <hackrilege> what is Compose?
13:35:14 <edwardk> so all we're saying is with that is f is isomorphic to the composition of a bunch of functors with g in the middle of it somewhere
13:35:34 <edwardk> now we could apply natural transformations to that g.
13:35:46 <mniip> newtype Compose f g x = Compose (f (g x))
13:35:58 <bezirg> can I ask something stupid? is it normal for perfomance to degrade when increasing the cores in the thread-ring benchmark? : http://benchmarksgame.alioth.debian.org/u64q/program.php?test=threadring&lang=ghc&id=1
13:36:02 <hodapp> hmm, wonder what's uglier... foo <- blahblah :: (FooMonad (Other Junk Bar)) or foo <- blahblah (Proxy :: Proxy Bar)
13:36:07 <edwardk> we can talk about situations where we can have many g's in the stack of functors, and arise at situations where we can count them, where we have something like a traversal, or where there are too many to iterate over and get something like a setter
13:36:18 <edwardk> we can apply natural transformations to those targets like modify, etc.
13:36:31 <edwardk> nothing here is a product or a coproduct
13:36:56 <edwardk> all that we have is that we can associate functor composition, and it has a unit (Identity), and a couple of coherence conditions from mac lane hold
13:37:03 <hackrilege> bezirg: if you are partitioning a task that would be performed quickly into a lot of slow communications, yes
13:37:13 <edwardk> this relies solely on the fact that the category of functors on Hask forms a monoidal category
13:37:24 <edwardk> and gives rise to another notion of a lens
13:37:24 <hackrilege> thanks mniip
13:37:55 <edwardk> on the other hand we can have something like a category of monad transformers, where my objects are monad transformers like StateT s, ReaderT e, WriterT r, EitherT e
13:38:51 <edwardk> and the morphisms are monad transformer homomorphisms. Hom s t = forall m a. Monad m => s m a -> t m a -- that respect the structure
13:39:11 <bezirg> hackrilege: thx for confirming this. but why the forkOn numCapabilities? I don't get that. I would expect if i run it with -N4  , all tasks would be allocated on the last core and I would see 100% cpu utilization.  But instead, I see sth like ~140% cpu utilization
13:39:36 <edwardk> now we can build a tensor for this category, something that acts like Compose, (,), Either:      newtype Tensor s t m a = Tensor { runTensor :: s (t m) a }
13:39:57 <edwardk> and if s and t are monad transformers (and we lifted dictionaries a bit better than MonadTrans can do) then Tensor s t would be a monad transformer
13:40:00 <hackrilege> 1.21 Giggawatts, great scott!
13:40:05 <edwardk> with a unit: IdentityT
13:40:10 <edwardk> and associativity and unit laws
13:40:19 <edwardk> now we can talk about lenses into stacks of monad transformers
13:40:31 <edwardk> lenses that are capable of running monadic actions designed for simpler concrete monads inside of a larger context
13:40:34 <mniip> *look of disapproval*
13:40:58 <hackrilege> im not sure i understand your question <bezirg> hackrilege: thx for confirming this. but why the forkOn numCapabilities?
13:40:59 <edwardk> this also doesn't involve a product or a coproduct anywhere
13:41:50 <bezirg> hackrilege: if u check that program http://benchmarksgame.alioth.debian.org/u64q/program.php?test=threadring&lang=ghc&id=1 , it uses forkOn numCapabilities (instead of the more usual forkIO). Why is that? and why i see ~140% cpu utilization instead of 100% 
13:41:55 <mniip> edwardk,  here's the problem
13:42:11 <edwardk> so the long version of this is that lenses and prisms are exactly the same construction, just on different monoidal categories.
13:42:21 <hackrilege> i have no idea why your cpu is breaking the limits of sense
13:42:29 <mniip> I know some of those words, so I generally understand what you're talking about
13:42:57 <mniip> but I dont know some other words
13:43:02 <edwardk> mniip: the things i just said are basically the general shape of how _i_ think about lenses. they don't have to be the way you think about them
13:43:07 <mniip> so I don't fully understand
13:43:18 <edwardk> the reason i'm chasing after this general design is that it lets me talk about things that we currently can't talk about in haskell
13:43:34 <edwardk> e.g. how to swizzle code written for the wrong monad transformer stack to run in the bigger one you actually have
13:43:46 <bennofs> bezirg: forkOn numCapabilities is used there to guarrante that all the threads run on a single cpu core, which reduces the synchronization overhead
13:43:49 <edwardk> because right now, what do we encourage folks to do with the mtl?
13:44:13 <mniip> do pointless lifting
13:44:24 * hackagebot tictactoe3d 0.1.0.3 - 3D Tic-Tac-Toe game  https://hackage.haskell.org/package/tictactoe3d-0.1.0.3 (ryo0ka)
13:44:31 <bennofs> mniip: lifting is not enough. you also need hoisting, and even that sometimes isn't enough I think
13:44:31 <edwardk> not really, I never want people to lift, we encourage them to write code like foo :: (MonadState s m, MonadReader Foo m) => ...
13:44:35 <hackrilege> what is a monoidal category?
13:44:46 <bezirg> bennofs: thanks. I understand now
13:44:48 <edwardk> this doesn't lift, but it does dispatch through some random dictionary for everything you want to do
13:44:50 <mniip> ohh
13:44:59 <edwardk> you're constantly asking the MonadFoo constraints 'mother may I?' and looking up how to do it
13:45:01 <mniip> width and depth subtyping
13:45:03 <edwardk> if you're lucky it inlines
13:45:10 <edwardk> and then you get decent code
13:45:56 <edwardk> but with the approach i just sketched you could write a concrete action against a concrete monad transformer stack, let the compiler optimize that, and then outside of the inner loop when things are allowed to be slow you cn deal with the impedence mismatch between the API you coded to and the full context of the larger monad you have to run the action
13:45:56 <edwardk> inside!
13:46:32 <edwardk> this is potentially as interesting and as powerful as anything we've expressed with lenses to date and tackles an entirely different problem set
13:46:41 <mniip> I wish I could comprehend
13:46:50 <edwardk> just like prisms let us start talking about smart constructors and json and xml and the like
13:47:01 <edwardk> lets try the functor composition story for a sec.
13:47:09 <edwardk> State s a = s -> (a, s)   right?
13:47:34 <mniip> sas right
13:47:43 <edwardk> lets flip the second tuple and break that apart, State s a ~ Compose ((->) s) ((,) s) a
13:47:45 <subleq> can I invite lambdabot to my channel?
13:47:52 <hackrilege> mniip, to me it sounds like he wants to write data a b c in his code, and later change it to data a b c d and force all the instances defined on the original datatype to just work... maybe im miles off...
13:47:56 <bennofs> edwardk: oh, so you're "storing" the instructions for how to lift in the transformer stack in a lens, which you only compute once?
13:48:10 <edwardk> bennofs: yes
13:48:14 <bennofs> that sounds nice
13:48:16 <edwardk> and then you can lift the whole computation with it
13:48:19 <edwardk> just like we 'zoom' today
13:48:25 <mniip> hackrilege, pretty close, except it's not data but monadic actions
13:48:28 <edwardk> but now swapping out whole levels of monad transformers
13:48:37 <bennofs> edwardk: it's kind of how lenses "stores" a position in a data structure
13:48:44 <hackrilege> i still havnt quite got the difference between them...
13:49:24 * hackagebot XSaiga 1.1.0.0 - An implementation of a polynomial-time top-down parser suitable for NLP  https://hackage.haskell.org/package/XSaiga-1.1.0.0 (InBetweenNames)
13:49:25 <bennofs> edwardk: hmm, but do these "lenses" also have 2 operations (like view/set   preview/review) or do they only have one?
13:49:28 <edwardk> with that way of thinking of State s a ~ Compose ((->) s) ((,) s) a   -- the moral equivalent of the _1 lens would be _1 :: Lens (State s) ((->) s)  -- and lets you focus on the reader part of state
13:49:34 <lpaste_> a pasted d at http://lpaste.net/6616746682581254144
13:49:52 <mniip> and what would that do
13:50:11 <edwardk> view/set rely on Lens s a    meaning that exists c. s ~ (c, a)   and that i can peel apart (c, a) with fst and snd.
13:50:17 <mniip> I mean I can see how set corresponds to lifting the actions
13:50:18 <edwardk> that i can destroy information
13:50:26 <mniip> but what about view
13:50:30 <edwardk> but we can construct similar operations
13:50:49 <edwardk> ones that work in a linear logic / merely monoidal setting
13:51:03 <Gurkenglas> subleq, ask int-e.
13:51:06 <edwardk> view here relies on the properties of the product
13:51:14 <mniip> Hold on hold on
13:51:28 <mniip> what interface does your functoral lens provide
13:51:30 <bennofs> edwardk: is "over" more fundamental than "review" / "view" ? since "over" can be implemented for both Prisms / Lenses
13:51:50 <mniip> bennofs,  it's a traversal thing
13:51:58 <edwardk> mniip: i'm sketching the design space, it basically peels apart    f   into the composition of 3 functors with the target in the middle
13:52:11 <edwardk> now you can do anything you want on that and put it back together
13:52:15 <mniip> but how
13:52:29 <mniip> functors are of non-* kind
13:52:30 <edwardk> it an isomorphism, i can write the function that i just described pretty easily
13:52:34 <mniip> you can't extract them
13:53:01 <edwardk> nothing in the definition of Lens s a requires s and a to have kind *
13:53:19 <mniip> it doesn't make sense as a value
13:53:27 <edwardk> there are perfectly useful notions of lenses on (k -> *) for any index, that uses product-like structures
13:53:32 <edwardk> and traversals, etc.
13:53:34 <bennofs> edwardk: hmm, you're using a Monad ((,) s) instance there without a Monoid ?
13:53:37 <edwardk> sure it does
13:53:40 <mniip> view, conceptually, returns the zoomed in part
13:53:48 <mniip> which is a functor in our case
13:54:12 <edwardk> why can't Lens s a   split s into something like exists c. forall i. s i <-> (c, a i)
13:54:31 <edwardk> you're getting tied operationally to the current behavior not the underlying semantics
13:54:33 <mniip> huh?
13:54:57 <hackrilege> what is this opperator <->?
13:55:10 <edwardk> this isn a different notion of a lens that works on kind (k -> *) using Data.Functor.Product basically 
13:55:35 <edwardk> hackrilege: its a notational placeholder for an isomorphism, functions in both directions that are mutual inverses
13:55:39 <mniip> I'm not sure I follow
13:56:41 <hackrilege> so you want to sepperate out the contents of the lens, into the bits in and out of focus, and you are surgesting this has type like exists c. forall i. s i <-> (c, a i)
13:57:13 <edwardk> hackrilege: sure, that would be a product-like one
13:57:34 <hackrilege> so that for any i there is a 'c' such that (c, a i) is isomorphic to s i
13:58:01 <edwardk> exists c_1, c_2. (Functor c_1, Functor c_2) => forall i. s i <-> Compose c_1 (Compose a Compose c_2) i   -- also works
13:58:09 <edwardk> there is one c that works independently of the is
13:58:17 <edwardk> its a so-called 'constant complement'
13:58:18 <hackrilege> brarg
13:58:54 <edwardk> the Compose story is messier beause it isn't symmetric, Compose f g  isn't the same as Compose g f
13:59:02 <edwardk> hence the need for two 'complement' parts
13:59:06 <edwardk> the stuff to the left, and the stuff to the right
13:59:09 <hackrilege> Obsidian: are you maintaining Obsidian?
13:59:15 <edwardk> whereas we can swap things around to mash it all into one 'c' in the product case
13:59:33 <Obsidian> oh im sorry, i did not intend to
13:59:48 <hackrilege> lol
13:59:59 <hackrilege> you wrote it?
14:00:38 <Obsidian> um did write what? I think there is a misunderstanding here
14:00:55 <hackrilege> :hackage Obsidian
14:00:55 <bitemyapp> edwardk: may I query you?
14:00:58 <edwardk> mniip: to show you this actually compiles: https://github.com/ekmett/hask/blob/master/src/Hask/Iso.hs#L20 is a definition of a lens-style Iso in a more general setting that works over any category you want
14:01:00 <edwardk> sure
14:01:05 <Obsidian> Oh no thats not me
14:01:07 <hackrilege> @hackage Obsidian
14:01:07 <lambdabot> http://hackage.haskell.org/package/Obsidian
14:01:11 <hackrilege> ok!
14:01:23 <hackrilege> shame...
14:01:46 <hackrilege> as you were
14:01:53 * mniip s t a b s edwardk
14:01:58 <hackrilege> lol
14:02:22 <mauke> time to s t a b some b a t s
14:02:48 <hackrilege> okok...
14:02:49 <bennofs> edwardk: heh, I was surprised that this does look so similar to lenses... but Bifunctor is probably not what I expect here :D
14:03:05 <edwardk> bennofs: Bifunctor in that world is used for both Bifunctor and Profunctor
14:03:12 <edwardk> its a bifunctor from a contravariant category
14:03:16 <mniip> :t to
14:03:17 <lambdabot> (Profunctor p, Contravariant f) => (s -> a) -> Optical' p p f s a
14:03:18 <edwardk> er from an opposite cateogry
14:03:25 <mniip> er
14:03:38 <bennofs> edwardk: Profunctor is a Bifunctor from C and C op, right
14:03:49 <hackrilege> abraham Beget Isacc
14:03:54 <mniip> whichever was the 'Iso s t a b -> Iso b a t s' function
14:04:21 <bennofs> :t from
14:04:22 <lambdabot> (Functor f, Profunctor p) => AnIso s t a b -> p t (f s) -> p b (f a)
14:04:29 <edwardk> Bifunctor p, Opd p ~ c, Dom2 p ~ d, Cod2 p ~ e     is saying p is an e-enriched profunctor, which viewed as a functor would look like a functor from c^op*d -> e -- but all category theory in that hask package is 'curried'
14:04:41 <hackrilege> whats an Iso?
14:04:49 <mniip> isomoprphism
14:04:59 <hackrilege> yeh but what is it
14:05:24 <edwardk> so a bifunctor P :: C*D -> E gets represented as P :: C -> [D, E]   -- or C -> Nat D E
14:06:12 <mniip> in lens, iso can be thought of as a pair of functions: to :: a -> b, from :: b -> a
14:06:13 <hackrilege> :t Iso
14:06:14 <lambdabot> Iso s t a b -> ReifiedIso s t a b
14:06:26 <hackrilege> wow!
14:06:34 <bennofs> edwardk: where is the constraint there that some of the bifunctor's domain is an opposite category? or do these lenses not even require a Profunctor?
14:06:37 <edwardk> :t iso
14:06:39 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
14:06:43 <mniip> such that to . from = id, from . to = id
14:06:52 <bennofs> mniip: from is not the inverse of to
14:07:05 <webchat099> ok
14:07:05 <bennofs> mniip: oops, you defined from above, sorry
14:07:11 <mniip> I'm not referring to the lens function
14:07:14 <edwardk> bennofs: in 'hask' what i do is build 'Yoneda' as my opposite category (which works once i curry all of my category theory)
14:07:34 <edwardk> https://github.com/ekmett/hask/blob/master/src/Hask/Category.hs#L49
14:07:38 <hackrilege> what is a Profunctor?
14:07:49 <bennofs> edwardk: I should probably learn some category theory :p
14:07:51 <edwardk> then contramap looks like https://github.com/ekmett/hask/blob/master/src/Hask/Category.hs#L152
14:08:16 <edwardk> bennofs: this code is pretty strange to both haskeller and category theorist alike ;)
14:08:36 <bennofs> edwardk: well, my cat theory stops at basic categories and perhaps functors/natural transformations
14:08:37 <edwardk> :t dimap
14:08:38 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
14:08:51 <edwardk> hackrilege: ^- anything that implements that with laws like the functor laws
14:09:18 <hackrilege> looks a lot like an Iso
14:09:31 <edwardk> bennofs: basically what i do in hask is look at :k (->)      ==>      * -> * -> *    as saying that we've already 'curried' apart the hom set we use in haskell
14:09:46 <hackrilege> an iso is a profunctor of a functor?
14:10:21 <edwardk> hackrilege: dimap takes two functions and maps backwards on the first arg contravariantly and forward on the second arg covariantly
14:10:36 <edwardk> instance Profunctor (->)    exists
14:10:43 <edwardk> instance Monad m => Profunctor (Kleisli m)
14:10:54 <edwardk> instance Functor w => Profunctor (Cokleisli w)
14:10:56 <bennofs> hackrilege: (->) is a Profunctor: you can transform "inputs" by composing another function on one side, and transform "outputs" by composing a function on the other side
14:11:14 <mniip> edwardk,  why Monad
14:11:21 <mniip> you can get away with fmap
14:11:22 <edwardk> data Mealy a b = Mealy { runMealy :: a -> (b, Mealy a b) }  -- instance Profunctor Mealy
14:11:26 <edwardk> mniip: now you can
14:11:34 <edwardk> back when the instance was written it was before AMP
14:11:37 <mniip> ah yes
14:11:46 <mniip> pre-amp kleisli issues
14:12:00 <edwardk> :t Data.Profunctor.Star
14:12:01 <lambdabot>     Not in scope: data constructor Data.Profunctor.Star
14:12:06 <edwardk> :t Data.Profunctor.UpStar
14:12:07 <lambdabot> (d -> f c) -> Data.Profunctor.UpStar f d c
14:12:11 <edwardk> :t Data.Profunctor.DownStar
14:12:12 <lambdabot> (f d -> c) -> Data.Profunctor.DownStar f d c
14:12:13 <bennofs> edwardk: aren't CoKleisli/Kleisli basically Costar/Star
14:12:16 <bennofs> ?
14:12:18 <edwardk> ^- lambdabot is on an old version
14:12:46 <edwardk> bennofs: Star and Costar had to exist before Functor was a superclass of Monad, otherwise the profunctor instance needed too much from 'm'
14:12:55 <edwardk> but then there is still a difference in intent
14:13:12 <edwardk> kleisli/cokleisli really signals a particular intent to do monadic things
14:13:14 <mniip> edwardk, I should probably start noting down all the ct stuff
14:13:20 <edwardk> er (co)monadic 
14:13:59 <edwardk> anyways once the entire universe stops using any version of GHC before 7.10 i could possibly consider retiring them, but they do signal intent
14:14:26 * hackagebot hackport 0.4.6 - Hackage and Portage integration tool  https://hackage.haskell.org/package/hackport-0.4.6 (SergeiTrofimovich)
14:14:31 <mniip> edwardk,  so, tell me more about: natural transformations
14:14:59 <edwardk> mniip: the pleasant lie we tell ourselves is that we can use type f ~> g = forall i. f i -> g i        as a notion of natural transformation in haskell
14:15:03 <edwardk> and for the most part it works
14:15:19 <edwardk> the more general story is uglier
14:15:24 <edwardk> https://github.com/ekmett/hask/blob/master/src/Hask/Category.hs#L100
14:15:43 <edwardk> so its not a surprise most folks let parametricity stand in for naturality
14:15:53 <mniip> and the lie is... "invalid polymorphic or quantified type"?
14:15:54 <edwardk> gotta run for a bit
14:15:56 <mniip> "?
14:15:59 <mniip> "?
14:16:04 <edwardk> no
14:16:06 <bennofs> mniip: -XRankNTypes
14:16:10 <mniip> ugh keyboard
14:16:15 <edwardk> the lie there is parametricity is in many ways a much stronger claim
14:16:15 <mniip> ah
14:16:54 <edwardk> and if you carry that notion of a 'natural transformation' around you can't build a strong enough notion of (co)limits on top to derive working (co)products.
14:17:19 <mniip> (co)limits?
14:17:20 <edwardk> so its a pleasant fiction
14:18:37 <edwardk> mniip: for that one i'll say 'read a category theory book' i think maybe lawvere and schanuel get far enough to cover it, but in hask letting * play the role of Set, a limit looks a lot like using 'forall' on a covariant argument and a colimit like 'exists' on a covariant argument.
14:18:53 <edwardk> in other categories it is more interesting
14:19:31 <edwardk> gotta run for a bit for real though =)
14:19:47 <mniip> uh
14:19:50 <mniip> cya
14:19:51 <hackrilege_> keep it cool essay
14:22:07 <edwardk> mniip: limits/colimits come up pretty quick in a category theory book
14:23:18 <hackrilege_> mniip, i think this class is above my level
14:23:42 <mniip> edwtjo,  any particular book you'd recommend
14:24:02 <hackrilege_> when im through with this a comprehensive lesson in lenses will be 3 sentences long
14:24:21 * mniip slaps keyboard with a rainbow trout
14:24:27 <mniip> edwardk, ^
14:24:33 <hackrilege_> lol
14:25:05 <edwardk> mniip: http://www.quora.com/What-is-the-best-textbook-for-Category-theory?share=1
14:25:09 <hackrilege_> wiki is pretty good on this stuff actuailly
14:25:43 <webchat099> I think that category theory lack a good pedagogical introduction
14:26:13 <bitemyapp> webchat099: CM seems reasonable if a little bit confusing at times.
14:26:13 <hackrilege_> its always best to answer these things with an awesome blog post.
14:26:26 <bitemyapp> webchat099: the pedagogy is in doing the exercises.
14:26:39 <webchat099> math notation is good for storing and transmitting information between initiates. but very bad for teaching to non initiated
14:27:07 <bennofs> bitemyapp: the problem to me was always that if you do it yourself, nobody is checking your exercises/proofs :|
14:27:09 <webchat099> bitemyapp:  yes, but Im lazy
14:28:08 <hackrilege_> but class declarations are perfect
14:28:28 <mniip> edwardk,  well my background is a pretty good understanding of Haskell and fancy stuff
14:28:30 <hackrilege_> there should be a simple book in haskell for lenses
14:29:38 <bitemyapp> bennofs: yeah it's not ideal, but I've not seen anything better yet.
14:30:12 <hackrilege_> you can think you understand a lens when you know it is a getter and a setter method and then wham, out comes profunctor. but if you just write the class declerations one ofter each other with inheritance, its basically the best notation you could want
14:30:37 <hackrilege_> i started at functor.. then traversable
14:31:07 <webchat099> lenses are a little boring for me
14:40:10 <webchat099> I'm wrong if I say that solving a functional problem is to navigate the arrows in the space of the categories of the problem until a final element is found?
14:44:13 <hackrilege_> solving a functional problem? we only have equivalence?
14:44:36 <hackrilege_> you mean compiling and executing?...
14:45:12 <hackrilege_> the navigating arrows stuff sounds good though
14:45:26 <Welkin> arrows meaning functions?
14:45:58 <hackrilege_> an arrow is something with a domain and a codomain which are objects in the category the arrow is in
14:46:23 <hackrilege_> it is isomorphic to pairs of these objects
14:46:39 <Welkin> so, a function
14:47:33 <Cale> uh
14:47:45 <Cale> There may be many distinct arrows between any given pair of objects though
14:47:56 <Cale> The canonical example is sets and functions
14:48:20 <Cale> In the category of sets, the objects are sets, and the arrows X -> Y are the functions having domain X and codomain Y
14:48:35 <Cale> There will generally be many different ones for any particular X and Y
14:50:13 <hackrilege_> if the function were different it would still map between the same sets? 
14:50:19 <hackrilege_> could*
14:50:48 <hackrilege_> so the identity arrow is not unique?
14:52:08 <mauris> there is always one unique identity arrow per object
14:52:14 <Cale> hackrilege_: Consider for instance the set of real numbers. There are many arrows R -> R, the identity function being just one of them, such as x |--> x^2, the sine function, ...
14:52:43 <lpaste_> ericw pasted cabal test errors at http://lpaste.net/138625
14:52:57 <ericw> I'm trying to get setup for the nicta haskell course (https://github.com/NICTA/course), and I'm running into this problem when trying to run tests via cabal test ^^ any guidance?
14:53:47 <kadoban> ericw: Did you try following its advice?
14:54:02 <ericw> kadoban: I did, but there's no change
14:54:22 <ericw> I understand what it's saying, but not how I got two different versions, or how to remove one of the versions. 
14:54:31 <hackrilege_> im confused, i thought the category had only arrows, are the functions here objects like the sets of numbers?
14:54:55 <kadoban> ericw: Personally I just ran the doctest command manually on each file as I was going. Not really sure.
14:54:56 <Cale> hackrilege_: No, in this category, the arrows are functions.
14:55:13 <hackrilege_> arrows *are* functions after all...
14:55:19 <Cale> hackrilege_: In an arbitrary category, the arrows needn't be functions, but they can be any mathematical thing we can define.
14:55:37 <ericw> kadoban: OK, I'll move forward with that approach for now. All the other steps do seem to succeed.
14:55:42 <Cale> hackrilege_: That's just how the category of *sets* is defined.
14:55:54 <hackrilege_> oh i see, yeh that makes more sense, here we have a sets and functions, the sets are the objects the functions are the arrows
14:56:00 <Cale> yep
14:56:41 <hackrilege_> so since the arrows domain and codomain can be the same set, for different functions, the identity is non unique?
14:56:45 <Cale> ericw: That's really pretty weird. Try  ghc-pkg list Cabal
14:57:20 <hackrilege_> for instance both +2 and +3 map the set of real numbers to itself
14:57:23 <Cale> hackrilege_: The identity function isn't in general going to be the only function from a set to itself, unless that set has 0 or 1 elements.
14:57:43 <lpaste_> ericw pasted ghc-pkg list Cabal output at http://lpaste.net/138626
14:57:58 <hackrilege_> then what is the identity if it does more than just have the same input as output?
14:58:11 <ericw> Cale: http://lpaste.net/138626
14:58:19 <Cale> ericw: Okay, so the only version of the Cabal library you have installed is 1.22.2.0
14:58:37 <Cale> ericw: However, suspiciously, your cabal-install program was built against 1.22.0.0
14:58:46 <Cale> ericw: Maybe try  cabal install cabal-install
14:59:16 <ericw> Cale: running now...
14:59:33 <hackrilege_> like, the identity is *all* functions mapping the set to itself...
14:59:35 <sizur> Any way to evaluate a Haskell expression on cli without entering a ghci shell?
14:59:46 <Cale> hackrilege_: The identity function is the particular function from a set to itself which sends each element of the domain to itself.
14:59:53 <hackrilege_> aha
14:59:58 <Cale> i.e. (\x -> x)
15:00:02 <Cale> In Haskell notation
15:00:18 <Cale> sizur: ghc -e
15:00:26 <hackrilege_> well no, that was my more general type, and is the type f all of the arrows that are not the identity...
15:00:35 <Cale> cale@ender ~ $ ghc -e "foldr (+) 0 [1..10]"
15:00:35 <Cale> 55
15:00:35 <hackrilege_> you need to delve into the sets
15:00:46 <sizur> Cale: thanks
15:01:22 <hackrilege_> map id
15:01:41 <hackrilege_> is the identity as you describe it
15:01:56 <Cale> hackrilege_: In order to be able to obtain arrows of a category which are not identity arrows, you need to know something more about the category than just the fact that it's a category.
15:02:15 <hackrilege_> thats true
15:02:40 <hackrilege_> im doing wuaternian rotatoin, perhaps thats a good example
15:02:48 <hackrilege_> quaternian*
15:03:08 <hackrilege_> it sends a vector space to itself
15:03:34 <dolio> Cale: In order to obtain identity arrows you need to know more than that it is a category. :)
15:03:42 <hackrilege_> the functions are the rotations about all vectors..
15:04:01 <Cale> dolio: Well, that's true. You need to know that it has objects.
15:04:14 <zipper> Anyone know how one can spawn a minute counter on travis?
15:04:34 <Cale> hackrilege_: There are a few ways you could picture the quaternions as a category. They can be a one-object category with many arrows from the object to itself, one for each quaternion, with composition of arrows taken to be multiplication (or addition) of quaternions.
15:04:34 <hackrilege_> Cale: and also the type of objects, for instance i had to know they were collections themselfs to enforce that each of these was mapped to itself in the identity
15:04:35 <zipper> It has been listed as a solution to travis builds timing out when used with stack.
15:04:40 <zipper> "Spawning a simple minute counter while using stack is a cheap trick to ensure that the Travis build does not time out due to lack of output for longer than 10 minutes "
15:05:11 <hackrilege_> well done zipper
15:05:30 <zipper> hackrilege_: What have I done?
15:05:41 <hackrilege_> i thought you got a bug fixed
15:05:55 <ericw> Cale: That installed cabal-install 1.22.6.0, but running cabal clean, then starting the process over yields the same error as before.
15:06:09 <Cale> hmm
15:06:10 <zipper> hackrilege_: I am asking how to spawn a minute counter with stack
15:06:20 <Cale> ericw: what does cabal --version say now?
15:06:44 <Nox_> can somebody please explain me this function?  any_foldr p xs = foldr (||) False (map p xs)
15:06:51 <ericw> Cale: 1.22.0.0 for cabal-install and 1.22.0.0 for the Cabal library
15:06:57 <Cale> Nox_: Sure
15:06:58 <ericw> weirdly enough...
15:07:00 <mauke> Nox_: what's the first part that's unclear?
15:07:19 <Nox_> well, the only thing that is unclear to me is the (map p xs)
15:07:27 <Cale> Nox_: map p xs will apply p to each of the elements of xs, producing a list of Bool values which are the results of that test
15:07:54 <Lokathor> in plain terms, "it takes a list and a predicate and sees if any elements satisfy the predicate
15:08:00 <ericw> Cale: running exec bash -l got me to show 1.22.6.0 for cabal-install, but Cabal is now at 1.22.2.0... Will try the clean and re-build process
15:08:36 <Cale> ericw: cabal --version should report both the version of cabal-install *and* the version of the Cabal library which was used to build it
15:08:50 <Cale> ericw: The complaint is about inconsistent versions of the Cabal library.
15:08:51 <Nox_> if i got it right, i'll get an bool value that will be compared with false using or?
15:09:12 <ericw> Cale: yes, I think I see where things went south now.
15:09:16 <Cale> Nox_: You get a whole bunch of Bool values
15:09:23 <Cale> > map even [2,3,4,5,6]
15:09:25 <lambdabot>  [True,False,True,False,True]
15:09:25 <Lokathor> Nox_, well, you will get a bool value. It will be true if any of the elements pass the predicate, or false otherwise
15:09:28 * hackagebot vector-algorithms 0.7.0.1 - Efficient algorithms for vector arrays  https://hackage.haskell.org/package/vector-algorithms-0.7.0.1 (DanDoel)
15:09:38 <ericw> Cale: I followed the instructions, which upgraded my cabal-install version, but because I didn't restart my shell, the new versions weren't properly picked up.
15:09:56 <Cale> ericw: Ah, okay
15:10:00 <ericw> Cale: I'm not sure *why* they weren't picked up, but they are now
15:10:17 <Cale> ericw: Yeah, maybe just needed a rehash
15:10:33 <Nox_> but why is there then the foldr (||)? can't this be written easier?
15:10:49 <Cale> If the new cabal-install was installed to ~/.cabal/bin or something, but you have one installed globally in /usr/bin
15:10:59 <Lokathor> Nox_, the foldr with (||) combines up the list of booleans from the map result
15:11:06 <Cale> Nox_: So, foldr (||) False is then used to combine the results of the tests
15:11:23 <ericw> Cale: kadoban: thanks for the help
15:11:33 <Cale> Basically, it sticks || in between each of the elements of the list, with False at the end when it reaches the empty list.
15:11:54 <Cale> x || False being the same as x, the False on the end doesn't affect much
15:12:05 <Lokathor> the "any" version uses (||), an "and" version of the same sort of thing would use (&&) instead, and have True as the initial value
15:12:07 <Nox_> ok, i understand it now, thank you
15:12:10 <Cale> (but it's nice to get a result when the list is empty)
15:15:06 <Nox_> actually, one more thing. the p in this code is an operator? i.e. < = >                                                any_foldr p xs = foldr (||) False (map p xs)
15:15:21 <Nox_> i meant <, =, >
15:15:27 <Nox_> ==*
15:16:35 <Cale> Nox_: p is any function which will take an element of the list xs, and produce a Bool result.
15:16:55 <Cale> Nox_: That is, it's a function which expresses something that might be true or false of any given element of xs
15:17:09 <Nox_> alright, thank you
15:17:29 <Cale> and this any_foldr function (which is usually just called 'any'), is trying to decide if it's true for any of the elements of the list
15:17:44 <Cale> > any even [3,5,7,9]
15:17:45 <lambdabot>  False
15:17:50 <Cale> > any even [3,5,4,7,9]
15:17:51 <lambdabot>  True
15:18:11 <Cale> > any (< 0) [3,4,8,9]
15:18:12 <lambdabot>  False
15:18:18 <Cale> > any (< 0) [3,4,8,-5,9]
15:18:19 <lambdabot>  True
15:19:07 <mauke> > any (\x -> length x > 5) ["foo", "bar", "hello", "world"]
15:19:08 <lambdabot>  False
15:19:13 <Nox_> ohh, for a moment i thought about any as foldr. that's why i was so confused
15:19:56 <Cale> Yeah, I don't fully understand why they called it any_foldr, but maybe they have multiple implementations of it in whatever you're reading or something.
15:20:34 <mauke> probably a manual recursion thing
15:21:22 <mauke> map is also a foldr, though, so you could fuse those
15:21:43 <Nox_> i'm reading real world haskell, and there's an exercise in which i have to write that function using foldr
15:22:03 <Nox_> i know, now i'm thinking how to write foldr and foldl using map
15:22:35 <mauke> I don't think you can
15:22:35 <Nox_> also, here's the link to the any_foldr function: http://haskell.elkstein.org/search?updated-max=2009-05-17T04:53:00-07:00&max-results=4&start=8&by-date=false
15:22:39 <mauke> at least not using map alone
15:23:04 <mauke> map insists on producing a list as output (of the same length as the input list)
15:25:15 <Nox_> foldr f z []     = z  foldr f z (x:xs) = f x (foldr f z xs) so this would be a foldr right?
15:25:52 <mauke> yes
15:26:12 <Nox_> ok, thank you
15:28:13 <Nox_> but still, while using foldr, doesn't it start from the right value to the left? in this case it looks like it starts from the left one
15:28:34 <mauke> no, it starts from the left :-)
15:29:55 <Nox_> i was looking for an example of it on stackoverflow and found this: http://stackoverflow.com/questions/1757740/how-foldr-works
15:30:19 <mauke> foldl (?) z [a,b,c,d] = (((z ? a) ? b) ? c) ? d
15:30:31 <mauke> foldr (?) z [a,b,c,d] = a ? (b ? (c ? (d ? z)))
15:31:42 <mauke> http://stackoverflow.com/a/11891218/1848654
15:36:12 <Nox_> thanks mauke, i understand it now :)
15:43:34 <YaRly> Can I make "Show" display my custom datatype differently? 
15:43:56 <mauke> sure, just write your own instance
15:45:04 <Cale> YaRly: Yes, though it's usually suggested that Show should produce valid Haskell code wherever possible
15:46:08 <shachaf> Valid Haskell code like T { someMap = fromList [], someSet = fromList [] }
15:49:41 <YaRly> mauke: Ah, thanks. Cale, shachaf: I see, perhaps I should define a custom typeclass then
16:01:02 <linman32> does anyone have opaleye expirience? trying to aggregate over a (Column (Column a)) type
16:09:31 * hackagebot liquidhaskell 0.5.0.0 - Liquid Types for Haskell  https://hackage.haskell.org/package/liquidhaskell-0.5.0.0 (EricSeidel)
16:14:34 <ttt_fff> wtf .... is zipWith just liftA2 .... MIND BLOWN .... 
16:14:36 <ttt_fff> SKY FALLING
16:14:56 <hpc> :t zipWith
16:14:57 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
16:15:04 <ttt_fff> :t liftA2
16:15:05 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:15:07 <mauke> ttt_fff: no
16:15:09 <ttt_fff> YEAH, the fucking match
16:15:10 <hpc> it's one of the liftA2s
16:15:16 <mauke> well, ZipList
16:15:18 <Taneb> ttt_fff, zipWith is liftA2 for the the ZipList applicative
16:15:23 <mauke> but that requires explicit (un)wrapping
16:15:42 <ttt_fff> > liftA2 + [1, 2, 3] [4 5 6]
16:15:44 <lambdabot>      Couldn't match expected type [Integer]
16:15:44 <lambdabot>                                    -> (a -> b -> c) -> f a -> f b -> f c
16:15:44 <lambdabot>                  with actual type [Integer]
16:15:46 <ttt_fff> > liftA2 + [1, 2, 3] [4, 5, 6]
16:15:48 <lambdabot>      Couldn't match expected type [Integer]
16:15:48 <lambdabot>                                    -> (a -> b -> c) -> f a -> f b -> f c
16:15:48 <lambdabot>                  with actual type [Integer]
16:15:56 <ttt_fff> > liftA2 (+) [1, 2, 3] [4, 5, 6]
16:15:58 <lambdabot>  [5,6,7,6,7,8,7,8,9]
16:16:05 <ttt_fff> WHAT ?
16:16:09 <Taneb> ttt_fff, that is zipping every possible pair of elements
16:16:17 <mauke> > liftA2 (+) [1, 2, 3] [4, 5, 6] :: [Expr]
16:16:19 <lambdabot>  [1 + 4,1 + 5,1 + 6,2 + 4,2 + 5,2 + 6,3 + 4,3 + 5,3 + 6]
16:16:23 <ttt_fff> mind no longer blown; sky no longer falling down
16:16:40 <ttt_fff> wait .. what does :: [Exor] do ?
16:16:42 <ttt_fff> taht looks badass
16:16:54 <ttt_fff> > 1 + 2 :: Expr
16:16:56 <lambdabot>  1 + 2
16:18:24 <hpc> Expr is a type for expressions that it just shows
16:18:54 <hpc> it's got Num instances and various things
16:18:59 <hpc> with varying degrees of reduction
16:19:27 <pacak> > getZipList $ liftA2 (+) (ZipList [1..4]) (ZipList [1..4])
16:19:29 <lambdabot>  [2,4,6,8]
16:20:24 <pacak> liftA2 can be zipWith, but not with default Functor instance for []
16:20:55 <shachaf> There's only one Functor instance for []
16:21:13 <pacak> @src ZipList
16:21:13 <lambdabot> Source not found. You type like i drive.
16:21:16 <pacak> That's why newtype
16:21:22 <ttt_fff> okay, gentlemen, this makes sense now, I'm an idiot, and I see what's going on
16:21:31 <ttt_fff> liftA2 blah lst1 lst2 is sorta, like, if this Applicative was a MOnad, it'd be like
16:21:37 <ttt_fff> x <- lst1; y <- lst2; blah x y;
16:21:42 <ttt_fff> and this is definitely not element wise addition
16:22:10 <mauke> do you know about liftM2? :-)
16:22:14 <ttt_fff> I do
16:22:19 <ttt_fff> :t liftM2
16:22:20 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:22:26 <ttt_fff> I also know about liftM3, liftM4, and liftM5 too
16:22:32 <mauke> @src liftM2
16:22:32 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:22:38 <ttt_fff> mauke: do you know about (>>=) :-)
16:22:46 <mauke> just saying, it's exactly that
16:22:49 <ttt_fff> @src liftA2
16:22:49 <lambdabot> liftA2 f a b = f <$> a <*> b
16:23:00 <ttt_fff> mauke: yeah, but I was drawing an analogy from liftA2
16:23:17 <ttt_fff> and liftA2 vs liftM2 is confusing since monad isn't subclass of applicative or something
16:23:29 <ttt_fff> I've yet to see a single class, where liftA2 and liftM2 are defined, yet liftA2 != liftM2
16:23:39 <mauke> I thought it was nowadays
16:24:01 <ttt_fff> oh, i'm on 7.8.x
16:28:33 <mauris> there's a lot of weird crap on here: http://www.angelfire.com/tx4/cus/combinator/birds.html but no \abc.a :(
16:33:46 <mauke> K(Kx)?
16:34:22 <mauris> yeah. was wondering if it had a common letter (and cute bird name!) attached to it
16:34:53 <mniip> const . const
16:35:00 <mniip> S(KK)K
16:35:46 <mauris> more specifically, i'm writing:  newtype Const3 a b c = Const3 { getConst3 :: a }
16:35:54 <mauris> but i don't like the name.
16:36:11 <mniip> ConstPeriodConst
16:36:15 <mauris> ConstConst is also bad (and `const const` is something different from `const . const` anyway).
16:36:35 <mniip> mauris, maybe something like
16:36:38 <mniip> Forget2?
16:36:59 <mauke> CKK
16:37:24 <mniip> hmm
16:37:32 <mniip> that's different
16:37:46 <mauris> it's BKK
16:37:58 <mauris> but yeah, that is a good idea!
16:38:57 <mniip> maurer, I would like to see the end result
16:39:09 <mniip> I can think of some fancy instances for that data
16:40:44 <mauris> instance Monoid m => Category (BKK m) :)
16:41:07 <mniip> damn
16:41:20 <slowbait> Hi, I read somewhere that there are some polymorphic functions that are not natural transformations, do you know where can I read about it?
16:41:20 <mniip> the word BKK brings some bad associations
16:44:32 <mauris> it seems to work! http://lpaste.net/138633
16:48:15 <mniip> maurer, Functor Applicative Monad Bifunctor Biapplicative Profunctor Contravariant Invariant Monoid Arrow
16:50:00 <mauris> (you're pinging the wrong person!)
16:50:24 <mniip> why in the hell would 2 people share a 4-char prefix
16:50:38 <kadoban> heart(s) of pure evil
16:50:57 <hpc> join the ranks of 3-char nicks
16:51:03 <hpc> all the cool people have one
16:51:08 <mniip> 5 is the most balanced number
16:51:17 <hpc> 3 is optimized 5
16:51:25 <mniip> 3 is laminarty
16:51:26 <kadoban> 7 is cooler 3
16:51:33 <hpc> 7 is too many syllables
16:51:52 <arkeet> hi
16:52:29 <mauris> mniip, even cooler: i derive a lot of those if i use Compose Const Const instead
16:52:32 <kadoban> kadoban has as many syllabels as hpc
16:52:46 <kadoban> Unless it's pronounces hupuck
16:52:47 <arkeet> but seven has more syllables than three.
16:52:51 <hpc> my syllables are better ;)
16:52:53 <kadoban> Ah, true
16:54:44 <mniip> ugh
16:54:59 <mniip> I need a more stable connection for this
16:55:46 <5EXABUSUB> there
16:55:58 <5EXABUSUB> you're never going to be as cool as me :)
16:56:38 <5EXABUSUB> isDigit . head ftw
16:57:23 <funfunctor1> Hi
16:58:01 <funfunctor1> I have the following data type, src/Types.hs:data Point = Point {-# UNPACK #-} !Double {-# UNPACK #-} !Double deriving (Eq, Show, Typeable, Generic)
16:58:39 <mniip> that was a forced nickname collision followed by the server forcibly changing my nick to my unique ID
16:58:45 <mniip> if anyone was wondering
16:59:25 <mauris> wait, i can't do Compose Const Const because of the kinds... hm
16:59:31 <funfunctor1> and I am trying to write the following FromField instance for Data.CSV http://lpaste.net/138637
16:59:48 <mniip> :k Compose
16:59:49 <lambdabot>     Not in scope: type constructor or class Compose
16:59:54 <mniip> dang
17:01:19 <mauris> type C3 a = forall b. Compose (Const a) (Const b)  -- there we go (i think)
17:02:34 <mniip> mauke, I think you can get away with an 'exists', no?
17:03:15 <mniip> ugh, again
17:03:17 <mauris> oh, wait, Category expects kind * -> * -> * of course...
17:03:17 <mniip> mauris, *
17:04:34 <mniip> mauris, that's not it sadly
17:04:46 <mauris> yeah, :k Compose is (* -> *) -> (* -> *) -> (* -> *)
17:05:12 <mauris> so i can never write what i want, i suppose
17:05:27 <mniip> it won't be a data
17:05:35 <mniip> datas can only contain *
17:08:57 <funfunctor1> @hoogle m -> (a, a) -> m (a, a)
17:08:59 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
17:08:59 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
17:08:59 <lambdabot> Data.Graph.Inductive.Monad delNodeM :: GraphM m gr => Node -> m (gr a b) -> m (gr a b)
17:09:18 <funfunctor1> @hoogle (a, a) -> m (a, a)
17:09:19 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
17:09:19 <lambdabot> Data.Graph.Inductive.Query.BFS leveln :: Graph gr => [(Node, Int)] -> gr a b -> [(Node, Int)]
17:09:19 <lambdabot> Data.Graph.Inductive.Query.BFS bfen :: Graph gr => [Edge] -> gr a b -> [Edge]
17:09:31 <mauris> funfunctor1, return?
17:09:49 <funfunctor1> mauris: nar.. see my question above..
17:16:05 <mauris> i'm confused about this. looks like Category accepts (k -> k -> *) so maybe there's some solution
17:16:10 * mauris summons edwardk 
17:17:24 <shachaf> Why?
17:20:42 <mauris> shachaf: i made a type constructor   newtype Const3 a b c = Const3 { getConst3 :: a }   and i'm trying to do the same thing but with Compose/Const/maybe other magical things
17:20:47 <Digitteknohippie> hi, wasnt sure if this is more a cabal question or a xmonad question, so i came here.  cabal install xmonad tells me it failed to get an older version of X11 than i already have.  is there a way to tell cabal to ignore that dep?  
17:21:31 <Digitteknohippie> (already have newer version of X, sry, that was ambiguous)
17:22:04 <mauris> (if you mean "why ed kmett": i dunno, he seems to be the best person to ask about things like this, having written half the relevant libraries)
17:22:10 <shachaf> mauris: What same thing?
17:23:45 <Hijiri> Digitteknohippie: could you put the full error on lpaste? I don't know if I can help, but it might help someone help you
17:24:02 <mauris> a type constructor (is that the right word?) that's isomorphic (how about that?) to mine
17:25:41 <mauris> shachaf: i mean like: instead of defining `newtype Foo a = Foo { getFoo :: Maybe (Maybe a)) }` from scratch, you can just use `Compose Maybe Maybe` and derive a lot of instances
17:28:27 <mauris> as mniip mentioned, i know my `Const3` is a Functor, Applicative, Monad, ... so maybe if i can write it as `Compose ...` i can get all my instances for free from `(Functor f, Functor g) => Functor (Compose f g)` etc.
17:28:52 <mauris> i figured it might simply be Compose Const Const, at first, as:
17:28:55 <mauris> :t const . const
17:28:56 <lambdabot> a -> b -> b1 -> a
17:29:47 <Digitteknohippie> http://lpaste.net/138642 for my query regarding cabal install xmonad wanting older X11 
17:32:26 <geekosaur> Digitteknohippie, you are missing client (not server) devel packages
17:33:01 <geekosaur> server devel files are only useful if you are writing a video driver or a server plugin
17:33:05 <mauris> i guess i'm not sure why
17:33:08 <mauris> :k Const
17:33:09 <lambdabot> * -> * -> *
17:33:25 <mauris> isn't * -> k -> *
17:38:24 <arkeet> because no one made it polykinded.
17:40:03 <geekosaur> Digitteknohippie, on debian-derived systems the packages you would need are: libx11-dev libxau-dev libxext-dev libxinerama-dev libxrandr-dev libxrender-dev libxss-dev. I don't know the equivalent packages for your system (void linux?)
17:40:39 <geekosaur> probably add libxft2-dev as xmonad-contrib prefers to have it around
17:51:26 <dmj`> which do you think takes longer, running doctests on lens, or cabal install acme-everything
17:52:16 <pacak> dmj`: cabal install acme-everything will fail
17:54:39 <dmj`> pacak: there's that
17:55:15 <kadoban> OMG stackage lts-3 is out, using GHC 7.10. Yay
18:00:39 <Digitteknohippie> http://lpaste.net/138645 have compared my system where i have xmonad installed, and added all the -devel files it has.  cabal install xmonad wanting older xft now.  :/  cant just get around that by installing more devel files from the repo it seems.
18:01:33 <Digitteknohippie> i'm probably too sleepy for this ... will see responces in the morning.  thnx for any pointers. :)
18:02:52 <geekosaur> Digit, that one is asking for a helper program used to find C libraries, called pkgconfig or pkg-config
18:03:50 <geekosaur> (well, the program is always pkg-config, the package is variously pkg-config or pkgconfig depending on distribution)
18:04:17 <ttt_fff> is there any library for interacting Haskell + surface pro 3? (in particular, the pen part, for taking notes with)
18:05:58 <davean> ttt_fff: I would expect that pen shows up as a pointer device?
18:06:17 <ttt_fff> I don't know; I have not written any surface pro 3 apps
18:06:26 <ttt_fff> I was thinking of doing it via javascript + browser, but that introduces delays
18:06:34 <ttt_fff> so now I am looking for native bindings, and thus curious if ...
18:07:50 <dmj`> ttt_fff: sounds like a cool project
18:08:06 <Digitteknohippie> ah, thnx geekosaur, good catch.  seems to make the install proceed now.  that'll be joyous to wake up to xmonad on both my main machines again.  :) gni  ~ ps voidlinux leaving it to cabal has me itching to cabal around for other curious haskell wonders.
18:09:42 <geekosaur> ttt_fff, the only pen-related thing I'm aware of in haskell is http://hackage.haskell.org/package/hxournal, and I don't think it's for windows
18:10:17 <ttt_fff> geekosaur: looks like gtk + dead since 2012
18:22:06 <creichert> HsQML might be a native option, but of course the GUI stuff is still written in haskell
18:22:49 <creichert> but, being Qt it has decent native support for Windows
18:23:05 <creichert> GUI stuff is written in Javascript, sorry (and a javascript-like language, QML)
18:23:31 <creichert> https://hackage.haskell.org/package/hsqml
19:11:45 <lingxiao> hey all 
19:12:06 <lingxiao> I have a problem I am wondering if pipes or conduit is an appropriate use case here for what I want
19:15:37 <Axman6> what's the problem?
19:17:37 <Welkin> Axman6: "A Monad is just an endofunctor in the category of monoids"
19:18:24 <dramforever> Welkin: IMHO that's in fact the best description
19:18:46 <dramforever> well, maybe it's backwards
19:18:58 <Welkin> dramforever: yes, I realized that after learning monads, monoids, and what an endofuntor is
19:19:07 <dramforever> Welkin: ftfy "A Monad is just a monoid in the category of endofunctors"
19:19:09 <Welkin> oh
19:19:11 <Welkin> oops
19:19:12 <Welkin> hahaha
19:20:52 <broma0> Can you have two separate ReaderT's in stack? something like (MonadReader X m, MonadReader Y m) => m a?
19:21:24 <dramforever> no you can't, it's by design
19:21:37 <dramforever> by "design" I mean there's a functional dependency that disallows this
19:21:47 <broma0> hm
19:21:57 <dramforever> broma0: however why can't you just have a type that wraps X and Y together?
19:22:01 <broma0> so i'd really need a sum type to get it to work?
19:22:06 <dramforever> product
19:22:12 <broma0> whoops 
19:22:15 <broma0> yes product. 
19:22:26 <dramforever> yes I think so
19:22:46 <dramforever> there's a function called asks that might make it look better
19:22:47 <dramforever> :t asks
19:22:48 <lambdabot> MonadReader r m => (r -> a) -> m a
19:23:02 <dramforever> :t (<$> ask)
19:23:03 <lambdabot> MonadReader a f => (a -> b) -> f b
19:23:15 <broma0> dramforever: that'd definitely work.. but i have a more general goal in mind.. 
19:23:29 <broma0> you know how lens creates HasBlah classes with makeClassy?
19:23:47 <dramforever> hmm that will also work I guess
19:23:57 <dramforever> (MonadReader r m, HasBlah r) =>
19:24:14 <dramforever> :t view -- okay this one is sooo general
19:24:15 <lambdabot> MonadReader s m => Getting a s a -> m a
19:24:20 <dramforever> horray
19:24:41 <broma0> dramforever: well what id like to do is call a functio in 'MonadReader r m, HasBlah r' of the type 'MonadReader r m, HasBlah r, HasBleh r'
19:24:58 <dramforever> yes you can to that
19:25:06 <broma0> i cant get it to work!
19:25:13 <broma0> how would i accomplish that?
19:25:22 <dramforever> wait that's reversed
19:25:46 <nshepperd> ooh, view lensBlah :: (MonadReader r m, HasBlah r) => m Blah
19:25:50 <broma0> im trying to use another runReaderT 
19:25:58 <dramforever> no that's not required
19:26:08 <dramforever> just call that more general function in the more specific one
19:26:35 <broma0> hmmm.. let me send you two type signatures i'm working with.
19:27:08 <broma0> route :: (Monad m, MonadReader r m, HasAppEnv r, MonadIO m)
19:27:09 <broma0> secure :: (Monad m, MonadReader s m, MonadReader r m, HasAppEnv r, HasSession s, MonadIO m)
19:27:25 <broma0> im trying to call secure inside of route, once i get a session 
19:27:38 <dramforever> oh you can't do that
19:27:41 <broma0> so i get a Session in route, and then id like to add it to the environment of secure
19:27:45 <dramforever> secure has a bad type
19:27:53 <dramforever> s and r have to be the same
19:28:01 <broma0> dramforever: wait i messed that up!!
19:28:09 <dramforever> so it's basically secure :: (Monad m, MonadReader r m, HasAppEnv r, HasSession r, MonadIO m)
19:28:16 <broma0> secure :: (Monad m, MonadReader r m, HasAppEnv r, HasSession r, MonadIO m) 
19:28:17 <dramforever> then you still can't do it
19:28:20 <broma0> that's what i want
19:28:23 <broma0> why not?
19:28:33 <dramforever> no HasSession in route
19:28:44 <dramforever> can you add that?
19:28:47 <broma0> no!
19:28:52 <broma0> i get Session from within route
19:28:54 <nshepperd> the type of route claims it'll work for any r, even one without a session
19:29:19 <broma0> basically i want to either call another thing with the same type as route, or 'secure' with the added HasSession
19:29:39 <dramforever> no more suggestions.
19:29:45 <broma0> i can easily call something with the same type, but i want to 'add' HasSession to secure
19:29:48 <broma0> alright
19:30:32 <broma0> nshepperd: is there a way to just call 'secure' from inside of 'route' ?
19:30:47 <broma0> provided that i get a 'Session'
19:30:58 <nshepperd> hold on, you want to create a Session in 'route' and then add it to the environment so that 'secure' can access it?
19:31:27 <broma0> yes
19:31:30 <broma0> basically
19:33:00 <nshepperd> hmm, that's sort of like 'local', but local isn't powerful enough
19:33:10 <broma0> shellyssh: there's withReaderT
19:33:14 <broma0> shellyssh: sorry!
19:33:20 <broma0> nshepperd: there's withReaderT
19:33:50 <broma0> imagine if we had anon records.. i could do it with that
19:34:27 <nshepperd> oh yeah, you could use withReaderT, if you want to restrict yourself to using ReaderT rather than any MonadReader
19:34:47 <broma0> can i do it with any MonadReader though? 
19:35:03 <broma0> id like to keep it all based on constrants without concrete monads/trnasformers
19:35:23 <broma0> the goal is to call
19:35:24 <broma0> secure :: (Monad m, MonadReader r m, HasAppEnv r, HasSession r, MonadIO m) 
19:35:26 <broma0> from
19:35:28 <koala_man> which exception monadT should I be using? there's several and I can't figure out which one is not deprecated
19:35:36 <dramforever> I wonder if we can lift a ReaderT like that
19:35:37 <broma0> route :: (Monad m, MonadReader r m, HasAppEnv r, MonadIO m)
19:36:14 <broma0> koala_man: Control.Monad.Except?
19:37:47 <broma0> nshepperd: how would i do this using ReaderT instead of MonadReader?
19:38:12 <dramforever> broma0: I have an idea
19:38:18 <koala_man> I'll give that a go
19:38:20 <broma0> dramforever: yes!
19:38:43 <dramforever> let's somehow lift that secure function
19:38:51 * dramforever is working on a type signature
19:40:06 <lingxiao> hey all I am wondering if someone could shorten this data type declarlation?
19:40:39 <lingxiao> data Statistic	    = Count | NullCount | Min | Max | AvgNum | Shortest | Longest | AvgStrLen
19:40:39 <lingxiao> 	deriving (Show,Eq)
19:40:39 <lingxiao> 			
19:40:41 <lingxiao> type Count 		    = Int
19:40:43 <lingxiao> type NullCount 		= Int
19:40:45 <lingxiao> type Min  		    = Int
19:40:47 <lingxiao> type Max 			= Int
19:40:47 <dramforever> stop
19:40:47 <dramforever> stop
19:40:48 <dramforever> stop
19:40:49 <lingxiao> type AvgNum 		= Int
19:40:51 <lingxiao> type Shortest    	= Int
19:40:53 <lingxiao> type Longest  	    = Int
19:40:54 <geekosaur> @paste
19:40:54 <lambdabot> Haskell pastebin: http://lpaste.net/
19:40:55 <lingxiao> type AvgStrLen 		= Int
19:40:55 --- mode: ChanServ set +o geekosaur
19:40:56 <dramforever> someone kick lingxiao
19:40:59 <lingxiao> data Statistic	    = Count | NullCount | Min | Max | AvgNum | Shortest | Longest | AvgStrLen
19:41:01 <lingxiao> 	deriving (Show,Eq)
19:41:03 <lingxiao> 			
19:41:05 <lingxiao> type Count 		    = Int
19:41:07 <lingxiao> type NullCount 		= Int
19:41:08 --- kick: lingxiao was kicked by geekosaur (lingxiao)
19:41:11 <matsuura> lol
19:41:24 <geekosaur> my notwork is lagging...
19:41:34 <dramforever> broma0: obviously there's still a problem
19:41:46 <broma0> dramforever: hm?
19:41:47 <dramforever> those two r's can't possibly be the same type
19:41:52 <dramforever> how are you going to deal with it?
19:42:04 <broma0> dramforever: yeah.. am i really gonna need to make damn product type?
19:42:07 --- mode: geekosaur set -o geekosaur
19:42:19 <geekosaur> language, please
19:42:19 <dramforever> broma0: I'm thinking maybe we could write a general function
19:42:30 <dramforever> then oh no it won't work...
19:43:05 <geekosaur> please don't paste into the channel like thta
19:43:24 <dramforever> and please don't paste twice...
19:43:24 <geekosaur> you just found out why... only way to stop the flood is a kick (or the server forcing you off for flooding)
19:43:26 <geekosaur> @paste
19:43:26 <lambdabot> Haskell pastebin: http://lpaste.net/
19:43:34 <geekosaur> ^ pastebin, please use it
19:43:54 <exio4> there's also a freenode bot that could have got your connection banned from freenode
19:43:59 <broma0> dramforever: i had the thought of using withReaderT to add Session to a tuple with the existing r
19:44:01 <exio4> so it's a bit risky!
19:44:04 <dramforever> lingxiao: there's an interesting way to solve this problem
19:44:09 <lingxiao> yeah I usually use it by clicking pasting online, but this time it didnt work
19:44:09 <dramforever> GADT!
19:44:11 <geekosaur> (and most IRC clients are dumb and will hang while that massive paste is going on)
19:44:32 <dramforever> broma0: looks like we still need a product type anyway
19:44:52 <broma0> dramforever: yeah.. 
19:44:52 <lingxiao> dramforever how would I use GADT in this caes?
19:44:53 <lingxiao> case *
19:44:56 <dramforever> one of the main problems is HasBlah classes don't say anything by themselves
19:45:15 <broma0> damn so there's really no way to just add something to the environment
19:45:37 <dramforever> lingxiao: data Statistic a where Count :: Statistic Int; NullCount :: Statistic Int
19:46:02 <dramforever> lingxiao: wait a sec can you post all relevant code to the pastebin?
19:46:11 <dramforever> I'm not really sure how that type is going to be used
19:46:18 <dramforever> because it doesn't even look usable this way
19:46:41 <lingxiao> http://pastebin.com/c8F2JsUT
19:47:07 <dramforever> sigh...I'm really sorry but pastebin is blocked here
19:47:12 <dramforever> @paste -- maybe this
19:47:12 <lambdabot> Haskell pastebin: http://lpaste.net/
19:47:41 <lingxiao> http://lpaste.net/138652
19:47:48 <lingxiao> sorry for the indentation that's showing up wonky
19:48:08 <lingxiao> by here did you mean where you are? or this channel?
19:48:22 * dramforever is in China
19:48:38 <dramforever> **** the Great Firewall
19:48:46 <geekosaur> also, many places block pastebin.com because sometimes credit card numbers or passwords etc. are pasted there, so it's shown up in many commercial net-nanny block lists
19:48:53 <lingxiao> ahhh ...
19:48:56 <dramforever> lingxiao: ok how are you going to use this type?
19:48:58 <lingxiao> fun
19:49:02 <lingxiao> you're right it makes no sense
19:49:20 <dramforever> dramforever: so like an argument to pass in to a function
19:49:31 <lingxiao> I'm looking for readablility, so really I just need type Count, type Min ... etc
19:49:33 <dramforever> and pick out the statistic to use?
19:49:42 <jakeehrlich> So how should haskell models be layed out? Right now I have my project setup to be run from the outermost folder and for all all the modules to refrence each other from there. Is this the correct way or somthing wrong with this idea?
19:50:10 <lingxiao> dramforever ... I'm sorry yeah the type was not useful, so I dont really have a problem anymore
19:50:22 <jakeehrlich> Namely some tools I am using seem not to be jiving with this layout which makes me think I did somthing suspect.
19:50:29 <dramforever> jakeehrlich: you should check other people's layout
19:50:46 <dramforever> check famous packages like conduit, gloss, lens, etc.
19:50:51 <nshepperd> broma0: you could add the session as an argument of secure, I guess. 'secure :: (MonadReader r m, HasAppEnv r, MonadIO m) => Session -> ...'
19:51:17 <dramforever> lingxiao: why don't you just write many functions?
19:51:33 <dramforever> oh how could I have forgotten!
19:51:46 <broma0> nshepperd: that's how i had it before.. but then functions called from secure would want a Session in their environment, and we have the same problem
19:51:48 <lingxiao> yeah that's what I'm doing ... not sure why I even made data stastics to begin with
19:51:52 <nshepperd> or define some sort of MonadReaderLocal type class that would provide the equivalent of withReaderT
19:52:04 <jakeehrlich> dramforever: gloss does what I do it seems
19:52:08 <broma0> nshepperd: now that's moving in the right direction i think..
19:52:13 <dmj`> mniip: ping
19:52:42 <dramforever> broma0: I can write a function with this type I think (forall r m. MonadReader r m, HasSession r => m a) -> Session -> m a
19:53:08 <mniip> hi
19:53:09 <dramforever> wait dammit no
19:53:20 <dramforever> oops sorry I shouldn't have said that
19:53:26 <jakeehrlich> lol
19:53:35 <broma0> dramforever: why not?
19:53:49 <dramforever> that m won't work out
19:54:10 <dramforever> on the other hand, Monad m => (forall r. MonadReader r m, HasSession r => m a) -> Session -> m a
19:54:13 <dramforever> this looks good
19:54:36 <broma0> dramforever: whoa that a confusing one..
19:54:36 <jakeehrlich> dramforever: Thanks; they all do what I was already doing. So its the tool that needs to adapt not me.
19:54:44 <dramforever> maybe
19:54:55 <dramforever> broma0: essentially runReaderT
19:54:56 <broma0> looks like it still requres Session as an argument instead of in the env..
19:55:07 <dramforever> lemme see, what about this type?
19:55:08 <broma0> oh but you're saying that fn will add it?
19:55:36 <dramforever> no too bad it won't
19:55:41 <dramforever> so hard
19:57:50 <nshepperd> class MonadReaderLocal r m | m -> r where { type family With r' m :: (* -> *); withLocal :: (r -> r') -> With r' m a -> m a }
19:58:10 <nshepperd> ...something like that?
19:58:20 <broma0> nshepperd: this got advanced quick
19:58:23 <dramforever> hmm wait interesting idea
19:58:26 <broma0> im not sure i follow all of that
19:59:05 <nshepperd> withLocal is basically a classy withReaderT
19:59:24 <dramforever> oh too bad it's wrong
19:59:32 <dramforever> ^ I'm refering to my idea
19:59:41 <nshepperd> you need the type family to tell ghc what is the result when you replace the environment type like that
20:00:00 <broma0> im not sure i even know how to use that idea to solve this problem
20:00:09 <broma0> how do the types of secure and route change?
20:00:28 <broma0> and how do i call secure from within routes, using a Session, to accmplish this/
20:01:41 <nshepperd> secure stays the same. route :: (MonadReaderLocal r m, HasAppEnv r, MonadIO m) => ...
20:02:21 <nshepperd> and then you call 'withLocal (\appenv -> (appenv, session)) secure'
20:02:47 <nshepperd> assuming you have HasAppEnv and HasSession instances for (AppEnv, Session)
20:06:05 <broma0> hmm if i were going to solve this with a product type.. id just have to make dome data P = P { env :: AppEnv, ses :: Session } right?
20:06:15 <broma0> some data P...*
20:07:31 <nshepperd> yeah, and give it HasWhatever instances
20:11:05 <kasabian> hello, how can I write a data constraint involving some property?
20:11:32 <dramforever> that's too general, can you give an example?
20:11:37 <kasabian> yes
20:12:58 * dramforever is getting distracted
20:15:34 <kasabian> http://lpaste.net/3810398485685993472
20:16:52 <dramforever> okay I saw it
20:17:12 <dramforever> no you cannot
20:17:16 <kasabian> is it possible to do what I want?
20:17:19 <dramforever> I'm afraid you cannot do that
20:17:31 <dramforever> however why are you doing this?
20:17:59 <kasabian> I was just playing around with gadts
20:18:23 <kasabian> I am a newbie with that
20:18:25 <dramforever> IIUC that's beyond haskell
20:18:33 <dramforever> but I don't know for sure
20:18:42 <dramforever> kasabian: idea: why not make two constructors?
20:19:15 <kasabian> how would it be?
20:19:47 <dramforever> data Cons a = One a | More [a]
20:20:06 <dramforever> or something like that
20:20:50 <exio4> (Maybe Bool, [a]) <=> C1 [a] | C2 [a] | C3 [a]; now you can change the name of the constructors into something that's useful, and express the invariants
20:21:11 <exio4> by removing the [a] parameter, you get the invariant of `must be Nil` (which is a single possible value)
20:21:24 <dramforever> exio4: also eliminate a few constructors maybe?
20:21:37 * dramforever wonders if kasabian understands all these
20:21:59 <kasabian> exio4: could you explain it more? I'm not getting it, thanks
20:22:09 <kasabian> dramforever: thanks
20:22:20 <dramforever> oh you understood my solution
20:22:27 <dramforever> then exio's shouldn't be a problem now
20:22:33 <exio4> kasabian: tuples represent product types, and | represents sum types
20:22:35 <dramforever> *exio4
20:22:53 <mauris> kasabian: perhaps you can model your data type more smartly. what are all the "valid" values?
20:22:54 <exio4> kasabian: "Bool" is basically 2, (it may take the value "True" or "False")
20:23:03 <dramforever> =) smart way ++
20:23:23 <exio4> Maybe adds an extra value to it, so Maybe Bool = 1 + 2 
20:23:23 <dramforever> kasabian: use different constructors, they are your friends
20:24:06 <exio4> it's basically doing high school arithmetic over types
20:24:19 <dramforever> yep
20:24:52 <dramforever> exio4: IIRC some polynominal magic could also work
20:24:54 <exio4> distributive properties (1+1+1) * list a = 1 * list a + 1 * list a + 1 * list a, 1 * x = x; so list a + list a + list a 
20:25:04 <dramforever> https://codewords.recurse.com/issues/three/algebra-and-calculus-of-algebraic-data-types/
20:25:16 <exio4> yeah, there are lots of things to do here if we want to
20:25:21 <dramforever> there, polynominal magic like taylor expansion and differentiation
20:25:53 <dramforever> looks interesting, because it only partially work
20:26:30 <exio4> (I just explained how I got that relation, not how useful it is, because the whole point was converting it to a sum type, and then start making the invariants explicit)
20:26:54 <dramforever> oh yes sorry I got off topic
20:27:32 <lpaste_> nshepperd pasted MonadReaderLocal at http://lpaste.net/138653
20:27:45 <nshepperd> broma0: ^^
20:34:35 <kasabian> dramforever  exio4 : something alike? http://lpaste.net/3810398485685993472
20:35:14 <dramforever> that False one doesn't make sense
20:35:17 <kasabian> I haven't tested it yet
20:35:21 <dramforever> 1. False is already taken
20:35:41 <dramforever> 2. there's nothing to store in the False case, so just False will work
20:35:50 <dramforever> i.e. data Ma a = False | Other [a]
20:35:58 <dramforever> 3. why don't you use Maybe?
20:36:14 <kasabian> yes, just pretend it's not False from Bool
20:37:24 <kasabian> mmm, but my constraint was for Maybe False, the list on the second element must be `[]`
20:37:33 <dramforever> yes
20:37:38 <dramforever> so just don't store
20:37:40 <dramforever> it
20:37:46 <nshepperd> oh hm, this thing doesn't maintain the MonadIO constraint
20:37:47 <dramforever> because there's no information in it
20:38:12 <kasabian> dramforever : sounds good, thanks :)
20:42:02 <nshepperd> broma0: oh hold on, you can just do 'runReaderT secure (P appenv session)' from inside 'route'
20:42:11 <nshepperd> broma0: without changing any of the types
20:42:26 <nshepperd> because a ReaderT at the time of the stack takes precedence
20:42:34 <nshepperd> at the top
20:43:00 <nshepperd> that's way easier than this type families mumbo jumbo
20:43:30 <nitrix> What the hell does "time of the stack takes precedence" even means?
20:43:44 <nshepperd> because a ReaderT at the top of the stack takes precedence
20:43:54 <nshepperd> typo :]
20:44:43 <nitrix> Are you talking about some metaconcept of a transformer stack?
20:45:49 <nshepperd> um... i'm talking about ordinary transformer stacks. nothing meta here
20:46:40 <nitrix> How does that avoids any type families?
20:46:52 <nitrix> In your example, you'd have IO, StateT then ReaderT.
20:47:18 <nshepperd> the point is, MonadReader r' (ReaderT r' m) holds, regardless of whether there's a MonadReader r m instance too
20:49:11 <nitrix> Still doesn't explains "time of the stack" and "takes precedence".
20:49:25 <nshepperd> 'time' was a typo...
20:49:36 <nitrix> Ah.
20:50:30 <cosmicexplorer> is there a way to turn off syntax check on save on ghc-mod? it's nice but always-on syntax checking is kinda distracting for me
20:50:47 <cosmicexplorer> sorry, i'm using emacs
20:52:39 <nshepperd> anyway, here I was trying to write a generalised withReaderT that works for any transformer stack with some typeclass constraint, and it turns out dramforever was way ahead of me
20:52:52 <ReinH> cosmicexplorer: disable flycheck mode or flymake mode
20:54:44 * hackagebot picoparsec 0.1.2.3 - Fast combinator parsing for bytestrings and text  https://hackage.haskell.org/package/picoparsec-0.1.2.3 (MarioBlazevic)
20:56:33 <lpaste_> nshepperd annotated MonadReaderLocal with MonadReaderLocal (annotation) at http://lpaste.net/138653#a138654
20:57:52 <cosmicexplorer> ReinH: i tried disabling that, but they were both already off. it seems ghc-mod adds annotations separately from flycheck, even though it looks like flycheck
20:58:25 <nshepperd> broma0: way better ^^
20:58:26 <nshepperd> ping
20:58:55 <cosmicexplorer> turning on flycheck makes yellow underlines into red though, so it's probably using flycheck's highlighting functions?
21:00:27 <cosmicexplorer> i'm currently delving into the ghc-mod code to see if i can insert an advice or something to kill it cause it doesn't look like there's a toggle anywhere
21:05:04 <gamegoblin> Is there any way to make a newtype just derive every typeclass its member type is an instance of?
21:05:12 <gamegoblin> (rather than manually selecting which ones to derive)
21:11:46 <hackrilege> :t first'
21:11:47 <lambdabot>     Not in scope: first'
21:11:47 <lambdabot>     Perhaps you meant one of these:
21:11:47 <lambdabot>       first (imported from Control.Arrow),
21:12:53 <hackrilege> :t Data.Profunctor.first'
21:12:54 <lambdabot> Data.Profunctor.Strong p => p a b -> p (a, c) (b, c)
21:13:06 <hackrilege> where is that c coming from!?
21:14:45 * hackagebot keyed 0.1.0.0 - Generic indexing for many data structures  https://hackage.haskell.org/package/keyed-0.1.0.0 (wyager)
21:15:52 <hackrilege> > first' (Either 1 2)
21:15:53 <lambdabot>      Not in scope: first'
21:15:53 <lambdabot>      Perhaps you meant one of these:
21:15:53 <lambdabot>        first (imported from Control.Arrow),
21:16:01 <cosmicexplorer> decided to make an around advice on ghc-check-syntax so it does nothing and make a function to toggle it which seems to work
21:16:04 <cosmicexplorer> thanks for the help
21:16:16 <hackrilege> > Data.Profunctor.first' (Either 1 2)
21:16:18 <lambdabot>  Not in scope: Data.Profunctor.first'    Not in scope: data constructor Ei...
21:16:18 <lambdabot>      Perhaps you meant variable either (imported from Data.Either)
21:16:56 <hackrilege> > Data.Profunctor.first' (either 1 2)
21:16:58 <lambdabot>  Not in scope: Data.Profunctor.first'
21:17:11 <hackrilege> :t Data.Profunctor.first' 
21:17:12 <lambdabot> Data.Profunctor.Strong p => p a b -> p (a, c) (b, c)
21:17:19 <hackrilege> sorry for the mess...
21:17:50 <hackrilege> can anyone explain what first' is doing here and where it gets the type c in its type definition?
21:18:53 <hackrilege> is nobody online?
21:19:17 <hackrilege> i cant believe haskell sleeps..
21:19:17 <geekosaur> possibly nobody who understands profunctors
21:19:36 <hackrilege> ha your always online!
21:19:45 * hackagebot mutable-containers 0.3.1 - Abstactions and concrete implementations of mutable containers  https://hackage.haskell.org/package/mutable-containers-0.3.1 (MichaelSnoyman)
21:19:48 <gamegoblin> geekosaur is actually a bot
21:19:55 <geekosaur> no, not always, inf act I should probably be heading to bed soonish
21:19:57 <gamegoblin> he just knows haskell really well
21:19:57 <hackrilege> of course 
21:20:06 <gamegoblin> hes written in Haskell, of course
21:20:21 <geekosaur> and no, sorry, not "really well". in fact I'm remembering this stuff derives from arrows and urgh
21:20:29 <hackrilege> he can sense a noob worried about profunctors...
21:20:31 * geekosaur never did really "get" arrows
21:20:52 <gamegoblin> I still dont get arrows
21:20:58 <geekosaur> anyway it looks like a profunctor p has two associated functions (a -> b) and (c -> d), the latter is where your d comes from
21:21:00 <hackrilege> arrows are just pointy things, its fine
21:21:37 <hackrilege> but i can write Data.Profunctor.Strong p => p a b 
21:21:46 <geekosaur> http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html might be worth a read to understand what's going on
21:21:48 <hackrilege> just an a and a b here...
21:22:00 <geekosaur> and http://comonad.com/reader/2008/deriving-strength-from-laziness/ for Strong
21:22:04 <shachaf> Profunctor is simple if you understand Functor and Contravariant.
21:22:15 <geekosaur> (both of those lifted from the Data.Profunctor haddock)
21:22:30 <shachaf> Those are also both simple.
21:22:56 <shachaf> geekosaur: Those aren't the same Strong (though they're related).
21:23:01 <geekosaur> ok
21:23:16 <hackrilege> class Contravariant f where contramap  (b  a)  f a  f b
21:23:17 * geekosaur did not say he understood this, in fact tried to imply the opposite
21:23:56 <ttt_fff> in a haskell project, is it good or bad to have a file called "Data.hs" and stuff all data declarations into that file?
21:24:04 <ttt_fff> i.e. this file serves as "all the nouns are here"
21:24:28 <geekosaur> not sure there's a good or bad there in any general sense
21:24:35 <geekosaur> if it makes sense for the project, go for it
21:26:30 <hackrilege> there is nothing in either of those articles about magically appearing types
21:28:22 <hackrilege> apparently first' is a generalisation of upStar
21:28:32 <geekosaur> no, without digging too deeply before bed I'd guess it's from a use of dimap :: (a -> b) -> (c -> d) -> p b c -> p a d ?
21:28:46 <geekosaur> may well be wrong though, it's late and I should be off
21:28:52 <shachaf> What is the question?
21:28:54 <hackrilege> it looks good
21:29:57 <hackrilege> shachaf: im wondering what is first' which is required to make a Strong profunctor 
21:30:49 <hackrilege> :t Data.Profunctor.first' 
21:30:50 <lambdabot> Data.Profunctor.Strong p => p a b -> p (a, c) (b, c)
21:32:26 <geekosaur> :t first
21:32:27 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
21:32:33 <geekosaur> thought that looked familiar...
21:34:05 <hackrilege> Send the first component of the input through the argument arrow, and copy the rest unchanged to the output.
21:35:14 <hackrilege> > first (arr (+)) 
21:35:18 <lambdabot>      No instance for (Show (a0 (a1, d0) (a1 -> a1, d0)))
21:35:19 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
21:35:19 <lambdabot>        arising from a use of show_M252024221391393863222664
21:35:31 <hackrilege> oops..
21:37:30 <hackrilege> nope no clue...
21:39:29 <hackrilege> :t first (arr (+)) 
21:39:30 <lambdabot> (Num a1, Arrow a) => a (a1, d) (a1 -> a1, d)
21:39:56 <hackrilege> :t first (arr (+1)) 
21:39:58 <lambdabot> (Num c, Arrow a) => a (c, d) (c, d)
21:42:20 <hackrilege> ok, d is not a Num because first is only applying it to the first element, and the arrow represents a function from (c,d) -> (c,d) 
21:42:46 <hackrilege> :t Data.Profunctor.first' 
21:42:47 <lambdabot> Data.Profunctor.Strong p => p a b -> p (a, c) (b, c)
21:44:46 * hackagebot keyed 0.2.0.0 - Generic indexing for many data structures  https://hackage.haskell.org/package/keyed-0.2.0.0 (wyager)
21:44:55 <hackrilege> geekosaur: do you know how i could use first' like i have used first above to understand the types...
21:45:49 <gamegoblin> @pl \(a,b) -> (f a, b)
21:45:49 <lambdabot> first f
21:47:18 <hackrilege> gamegoblin: cool
21:48:34 <hackrilege> :t first 
21:48:35 <hackrilege> :t Data.Profunctor.first' 
21:48:35 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
21:48:36 <lambdabot> Data.Profunctor.Strong p => p a b -> p (a, c) (b, c)
21:49:39 <hackrilege> id love to know how currying fits into all of this
21:49:47 * hackagebot keyed 0.3.0.0 - Generic indexing for many data structures  https://hackage.haskell.org/package/keyed-0.3.0.0 (wyager)
22:09:47 * hackagebot mutable-containers 0.3.2 - Abstactions and concrete implementations of mutable containers  https://hackage.haskell.org/package/mutable-containers-0.3.2 (MichaelSnoyman)
22:44:38 <gamegoblin> Jesus so much of the source code in Network uses tabs instead of spaces
22:44:49 <gamegoblin> Codec also
22:44:49 * hackagebot moesocks 0.1.0.15 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.15 (JinjingWang)
22:48:56 <m00nlight> How can I use bang pattern for record data types?
22:52:29 <qracsp> what is a good TH starting point for someone familiar with lisp macros (CL style, never worked with hygienic macros)
22:52:30 <shachaf> Put the ! in front of the type.
22:53:28 <shachaf> Er, never mind, I misread.
22:54:31 <shachaf> Now the answer is to put a ! in front of the variable.
22:55:02 <scshunt> qracsp: hmm... I don't know much about Lisp macros. A better question is "what are you trying to do?"?
22:55:07 <scshunt> s/\?$//
22:55:43 <qracsp> for now I just want to learn template haskell
22:57:19 <c_wraith> qracsp: TH has approximately nothing in common with lisp macros.
22:58:02 <scshunt> qracsp: it's not really something worth learning unless you have something to do with it
22:58:03 <qracsp> well the idea is the same at lesat
22:58:23 <qracsp> running user code at compile type
22:58:37 <qracsp> scshunt hopefully I could reduce some boilerplate once I become more familiar with TH
22:59:00 <qracsp> is TH closer to scheme's hygienic macros?
23:04:50 * hackagebot keera-hails-reactivevalues 0.0.4 - Haskell on Rails - Reactive Values  https://hackage.haskell.org/package/keera-hails-reactivevalues-0.0.4 (IvanPerez)
23:07:13 <asciiasc`> I'd be keen to join qracsp's curiosity. Are there any projects that would be difficult to imagine having been developed had they not used TH?
23:08:40 <c_wraith> use of TH *usually* means that Haskell's abstraction facilities aren't strong enough to do the job properly.
23:09:46 <c_wraith> Which mostly happens with mechanical instance generation.  Though if you can accept some performance loss, GHC.Generic and Data.Data provide abstractions for that.
23:11:22 <asciiascetic> c_wraith: instances of typeclasses? or instances of types? or both?
23:11:38 <asciiascetic> c_wraith: (I'm unfamilar with Data.Data and GHC.Generic both)
23:11:56 <c_wraith> instances of classes.
23:13:08 <asciiascetic> c_wraith: yeah. it seems like I hand wrote a bunch of instances a few months ago... and remember thinking.. there must be a better way.
23:13:48 <Axman6> one example might be the FFT package which does something similar to what fftw does and makes specialised implementations depending on the vector size
23:14:02 <asciiascetic> c_wraith: I opted for an extra-linguistic solution in the form of emacs macros, iirc. Is TH haskell? or is it some other language?
23:14:17 <qracsp> it is GHC extension
23:14:34 <asciiascetic> qracsp: right, but is it haskell or is it some other language?
23:14:35 <c_wraith> asciiascetic: it's a little extra syntax on top of haskell for purposes like "splice this" or "quote this"
23:14:50 <c_wraith> asciiascetic: But other than that tiny bit of extra syntax, it's haskell
23:14:50 * hackagebot keera-hails-reactivevalues 0.1.0 - Haskell on Rails - Reactive Values  https://hackage.haskell.org/package/keera-hails-reactivevalues-0.1.0 (IvanPerez)
23:14:58 <liste> qracsp TH is basically producing pieces of AST from Haskell functions and splicing them in your code
23:15:25 <Axman6> http://www.skybluetrades.net/blog/posts/2013/11/13/data-analysis-fft-1.html is an excellent series of articles which goes through the implementation
23:16:22 <asciiascetic> it was mentioned earlier that CL macros have little in common with Template Haskell, but from the descriptions so far I'm having difficulty seeing their total distinction.
23:16:38 <qracsp> likewise
23:17:28 <c_wraith> The biggest difference is philosophical.  use of TH indicates a failure of haskell.  Use of CL macros indicates business as usual.
23:18:39 <asciiascetic> c_wraith: haha, truly? what is forfieted by TH that amounts to a philosophical break?
23:18:56 <asciiascetic> forfeited*
23:19:19 <qracsp> c_wraith, then I'd question your claim that they have nothing to do with lisp macros
23:19:30 <qracsp> if that is the biggest difference you can come up with
23:19:48 <liste> TH means that you must step outside Haskell
23:20:05 <liste> a bit like the C preprocessor
23:20:09 <asciiascetic> qracsp: opinions re opinions! I'm more interested to understand why people might have strong feelings about TH.
23:20:17 <asciiascetic> liste: saftey ruined?
23:21:38 <lieven> asciiascetic: one difference is that CL macros behave better under composition. another is as you note, their ubiquitousness. as someone remarked, in CL the assignment operator is a macro
23:21:48 <liste> it's harder to reason about code generated by TH, not to mention it can do IO
23:22:12 <liste> the end result is type safe OFC, otherwise it wouldn't compile
23:22:27 <liste> but you need to expand it yourself to do equational reasoning etc
23:24:23 <liste> I suppose the biggest difference is that TH is a EDSL, CL macros are just CL
23:24:46 <asciiascetic> Ah yes. TH seems then to be more ad hoc than CL macros, which is I think what c_wraith was getting at with their characterization as being business as usual in CL.
23:25:42 <Axman6> Anyone know if, with stack, it's possible use different resolvers within the same package? I'd like to make it as easy as possible to compile my package with 7.8 and 7.10, without having to keep two branches in sync with version specific stack.yaml files
23:26:32 <asciiascetic> can you write templates that have templates in them. (I'm not sure if I'm using the conventional nomenclature, by 'template' I mean whatever it is that you make with TH)
23:26:58 <lieven> That's the one reason for CL's sexp syntax. TH is one of a long line of attempts to do general macros in a "infix syntax" language and all attempts have shown that it's a hard problem.
23:27:25 <liste> asciiascetic yeah, they're just function that return AST pieces
23:28:39 <asciiascetic> lieven: yeah, Lisp was intended at first to be an infix language, but the explcit representation of syntax trees as the pragmatic language persuaded McCarthy to just stop there, or so the lore says.
23:29:51 * hackagebot keera-hails-reactive-gtk 0.1 - Haskell on Gtk rails - Reactive Fields for Gtk widgets  https://hackage.haskell.org/package/keera-hails-reactive-gtk-0.1 (IvanPerez)
23:30:26 <lieven> asciiascetic: some of the earlier papers define M-expressions but they never got implemented
23:33:01 <liste> http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH.html <-- this isn't a pretty thing to look at
23:33:03 <asciiascetic> well to put a cap on my curiosity, would it be fair to say that objections to the use of TH have to do with the difficulty of debugging code that uses it, because of the additional reasoning that is shifted onto the programmer?
23:34:57 <liste> asciiascetic that's one side of it, yes
23:35:56 <liste> although imo reasoning is more important than just a tool for debugging
23:36:15 <asciiascetic> hm what do you mean?
23:36:58 <asciiascetic> you feel that TH gets in the way of ... clean or proper.. framings of problems too?
23:37:25 <liste> I mean proving your code does what it says is harder with TH
23:37:32 <arkeet> if only we could write TH code with the same form as the code it generates.
23:37:36 <arkeet> (like lisp macros)
23:37:42 <quchen2> TH is dirty in the sense that makes CPP dirty: you have little guarantees about the code you generate, it's hard to debug, it's generating code in another language for one you want to actually use. (That said, TH is *a lot* safer than CPP of course, but that's besides my point.)
23:38:12 <arkeet> CPP doesn't even work at the AST level.
23:38:37 <asciiascetic> liste: but doesn't the compiler do that for you, at least in the case of non IO code?
23:38:42 <quchen2> I was talking specifically about the dirtiness.
23:38:50 <liste> asciiascetic only with dependently typed languages
23:38:57 <quchen2> CPP is hell of a lot unsafer because it's a text replacement engine, yes.
23:39:02 <liste> I have to do it with a whiteboard myself with TH
23:39:09 <liste> s/TH/Haskell
23:39:27 <quchen2> At least you can't produce lexically invalid code with TH. It can still be ill-typed though.
23:40:16 <asciiascetic> I see so reasoning about values is the difficult bit?
23:41:38 <asciiascetic> (I'll shut up in a second, I promise. lisp macros are such a wonder, I find my dopamine centers are going crazy about the promise of translating the experience to haskell)
23:41:54 <quchen2> We have different dopamine centers.
23:42:01 <asciiascetic> haha
23:42:12 <quchen2> TH is not ever a dopamine center. It's a crutch.
23:42:33 <liste> yeah, because if I have for example f x = x + 1 and g x = 2 * x, I KNOW that f (g x) is 2 * x + 1, because I can just substitute
23:42:52 <asciiascetic> quchen2: oh yes, and thats what I'm trying to find out about. I've no experience with TH.
23:43:12 <arkeet> just try reading some TH code :-)
23:43:30 <liste> with TH, I can't know that unless I run the TH expansion in my head (or on paper)
23:43:43 <quchen2> The Hello World of TH is "indexing an n-tuple".
23:43:43 <arkeet> or with -ddump-splices
23:43:54 <asciiascetic> liste: right, yeah that makes total sense. thanks for the effort to clarify.
23:43:56 <quchen2> One popular use of TH is generating lenses.
23:44:00 * mgsloan_ quite enjoys TH, oddly enough
23:44:10 <mgsloan_> Code generation is just fun :D
23:45:09 <mgsloan_> You don't tend to need it much with Haskell, but it certainly has its place in generating boilerplate
23:46:41 <asciiascetic> mgsloan_: yeah. in languages without macros I usually do pre-compile time code generation, usually using emacs macros. the poor man's code generator.
23:46:55 * quchen2 likes to abuse TH as a supercompiler.
23:47:59 <qracsp> is there a macroexpand-1 equivalent for TH?
23:48:03 <Gurkenglas> Can one ask TH whether two types unify? (Still trying for that conjecture generator.)
23:49:10 <qracsp> (a way to expand a template "function" (or however you call it) to see what the generated code will be)
23:50:25 <quchen2> qracsp: Compile with -ddump-splices and GHC will tell you roughly the code generated
23:50:30 <quchen2> It's not guaranteed to be copy-pastable though
23:50:50 <asciiascetic> Does TH play well with ghci?
23:51:37 <qracsp> I was hoping for a way to expand it in ghci. I guess that isn't possible yet
23:53:56 <quchen2> qracsp: You can also dump in GHCi. http://lpaste.net/138660
23:56:12 <ttt_fff> who loves haskell
23:59:50 <qracsp> is this a good resource for learning TH from scratch? https://wiki.haskell.org/Template_Haskell
