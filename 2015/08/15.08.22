00:00:06 <dmj> rhovland: you can set other ghc-options in ghci using :set
00:00:10 <dmj> rhovland: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-set.html#idp7248304
00:00:27 <dmj> rhovland: but -O2 isn't for ghci
00:01:21 <rhovland> dmj: well, I guess I don't know if any of those cause the panic
00:02:00 <dmj> rhovland: they probably don't
00:23:28 <rhovland> dmj: you know, I was always amazed that was allowed in the first place... ghc options as pragmas
01:01:10 <rhovland> dmj: apparently it's already known and fixed in head/master
01:16:18 <ralu> how would one implement (a->b) -> (c->d->a)->(c->d->b)
01:18:06 <rhovland> ralu: that sure looks like a lot of signatures
01:18:19 <ChristianS> ralu: f a b = b a ?
01:19:04 <rhovland> ralu: looks like (a->b) ->(x->a) -> (x->b)... almost all the functors have that
01:20:08 <ralu> i want to apply function only on result
01:20:54 <ralu> i know how to implemet this, just wondering if it works for arbitrary function
01:21:13 <ralu> * how should make
01:22:08 <ChristianS> ralu: if the types match, then it'll always wark
01:22:15 <rhovland> ralu: so already you can do f = (c->d) right? so it's (a->b) -> (f->a) -> (f->b)
01:26:15 <m0rphism> ralu: f ab cda c d = ab (cda c d)
01:26:29 <m0rphism> this would be a function of type (a->b) -> (c->d->a) -> (c->d->b)
01:26:59 <ralu> what abou when cda is actaly cdea
01:27:52 <ralu> can i use common pattern?
01:28:24 <ralu> trick is that i need to wrap result of library i am working on
01:29:31 <rhovland> ralu: what pattern?
01:30:54 <ralu> to map result of "last" returned value
01:33:58 * hackagebot hopenpgp-tools 0.16.3 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.16.3 (ClintAdams)
01:35:05 <rhovland> ralu: (map result of "last" returned value) : map . last ?
01:38:58 * hackagebot bindings-yices 0.3 - Bindings to the Yices theorem prover  https://hackage.haskell.org/package/bindings-yices-0.3 (PepeIborra)
01:39:32 <adarqui> opaleye looks really cool. in the tutorial, to use user defined records, they mention defining all of your records to use polymorphic types and then use type synonyms to get back your 'concrete types'
01:39:48 <adarqui> never thought of that
01:40:21 <kuznero> Hi All!
01:40:34 <rhovland> 'lo
01:40:45 <kuznero> I have trouble figuring out how to fix my parseValue function: http://lpaste.net/139410
01:41:55 <kuznero> It suppose to convert Maybe String into Maybe a
01:42:26 <srhb> kuznero: That's not what the signature says.
01:42:50 <adarqui> is there a typo in ghc? In the first argument of ‘fmap’, namelymely
01:42:54 <adarqui> (in that lpaste)
01:43:58 * hackagebot deepseq 1.4.1.2 - Deep evaluation of data structures  https://hackage.haskell.org/package/deepseq-1.4.1.2 (HerbertValerioRiedel)
01:45:38 <srhb> kuznero: Not that that's your problem.
01:46:15 <srhb> kuznero: You've given an untrue type signature for reads.
01:46:32 <srhb> kuznero: (Remember the Read constraint
01:47:41 <srhb> kuznero: You could also just omit it.
01:47:59 <erisco> (<-<) . Pipes.take
01:48:03 <erisco> this doesn't quite feel right
01:48:46 <rhovland> erisco: that a new operator?
01:49:06 <kuznero> adarqui: yes, that is equal sign - typo
01:49:16 <srhb> kuznero: You might also consider using fmap fst . listToMaybe instead
01:49:22 <erisco> rhovland, an operator from pipes
01:49:43 <kuznero> srhb: sound reasonable, let me try
01:50:06 <srhb> kuznero: Note the slighty different type, it drops the list completely
01:50:32 <kuznero> srhb: yep
01:51:27 <jle`> @djinn (a -> b) -> (c -> d -> a) -> (c -> d -> b)
01:51:27 <lambdabot> f a b c d = a (b c d)
01:51:30 <jle`> ^ ralu 
01:51:48 <ralu> i made it
01:52:03 <Nik05> ah nice bot, can it do complicated stuff?
01:52:14 <jle`> it can't do recursive data types
01:52:29 <jle`> and it doesn't relaly know about typeclasses
01:52:37 <Nik05> oke
01:52:42 <rhovland> but it can do complicated stuff
01:52:45 <rhovland> other than that
01:53:35 <ralu> so robot can write programs omg, that is scarry
01:53:48 <ralu> kill it before it is too late
01:54:27 <erisco> @djinn (a -> b -> b) -> a -> b
01:54:27 <lambdabot> -- f cannot be realized.
01:54:34 <erisco> it can't do that either
01:54:40 <erisco> I don't know what it is based on *shrug*
01:55:25 <erisco> @djinn (a -> a) -> a
01:55:25 <lambdabot> -- f cannot be realized.
01:55:26 <dramforever> it's impossible as it says
01:55:34 <erisco> what does impossible mean?
01:55:38 <adarqui> anyone here ever use opaleye? i see lots of people using persistent but i like having my actual records
01:55:54 <erisco> I can define either of those
01:55:57 <dramforever> erisco: not possible to write a function of this type *in it's system*
01:56:05 <dramforever> predicate logic
01:56:11 <erisco> okay
01:56:26 <dramforever> you're not allowed to write non-terminating stuff
01:56:40 <Walpurgisnacht> ∞
01:56:49 <dramforever> erisco: reason: if you could then djinn could just output let x = x in x for everything
01:56:54 <dramforever> where do you draw the line?
01:57:20 <erisco> well it turns out many practical programs have uninteresting types
01:57:25 <erisco> so, I dunno :P
01:57:45 <dramforever> you should do programming with interesting types
01:57:50 <dramforever> less error-prone
01:57:57 <erisco> anything that returns list for example
01:58:30 <dramforever> they are just not that interesting
01:58:35 <dramforever> @free f :: [a] -> [a]
01:58:35 <lambdabot> $map g . f = f . $map g
01:58:38 <ggole> Using type variables rather than rich data types like ints keeps the space of possible implementations small
01:58:50 <dramforever> (I don't know if it makes sense for you)
01:58:57 <dramforever> *to
01:59:49 <rhovland> there was a thing on quora about null vs empty list, which I guess is a problem for people in bad languages
02:00:07 <erisco> dramforever, nope, it doesn't *shrug*
02:00:53 <dramforever> erisco: this f is a natural transformation
02:00:57 <dramforever> how about that?
02:01:22 <erisco> I don't know much category theory, so nevermind
02:01:39 <dramforever> map-preserving
02:02:06 <rhovland> erisco: from what I can tell, haskell is the best way to learn category theory
02:02:20 <srhb> I sincerely doubt that.
02:02:25 <erisco> I don't think so
02:02:44 <dramforever> @check (\f g xs -> (map g . f) xs == (f . map g) xs) :: (forall a. [a] -> [a]) -> (Int -> Int) -> [Int] -> Bool
02:02:44 <lambdabot>  <unknown>.hs: 1: 105:ExplicitForAll or TypeOperators is not enabled
02:02:45 <rhovland> hrm.. well, then what is?
02:02:47 <dramforever> too bad
02:03:01 <erisco> watching some category theory lectures and reading category theory materials is more relevant
02:03:30 <erisco> then trying to relate it back to programming is... well... there is a reason I haven't bothered yet
02:03:59 <rhovland> I've been trying to read the smullyan birds thing
02:08:57 <erisco> who knows tdfa fairly well
02:11:58 <erisco> I want to know if I can use the backend to parse from a producer
02:13:15 <erisco> I am becoming suspicious that I cannot
02:14:50 <rhovland> try again after 8hrs?
02:16:31 <erisco> wait, okay, maybe I just need to implement this Uncons class
02:26:59 <erisco> I feel like 'next' could have done without returning in a monad
02:30:31 <mjrosenb> is there an identity functor?
02:30:40 <erisco> :t Identity
02:30:41 <lambdabot> a -> Identity a
02:30:53 <mjrosenb> :i Identity
02:31:14 <liste> it's a Functor, Applicative, Monad
02:31:34 <mjrosenb> does it have an unIdentity field, or some way of extracting the value?
02:31:43 <liste> > unIdentity (Identity 5)
02:31:44 <lambdabot>      Not in scope: ‘unIdentity’
02:31:45 <lambdabot>      Perhaps you meant one of these:
02:31:45 <lambdabot>        ‘runIdentity’ (imported from Control.Monad.Identity),
02:31:48 <cocreature> mjrosenb: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor-Identity.html
02:31:53 <cocreature> it's called runidentity
02:31:53 <jle`> @src Identity
02:31:53 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
02:32:44 <thealpine> Hello everbody!
02:33:04 <thealpine> Remember that everybody needs somebody to love
02:33:25 <dramforever> @ops
02:33:25 <lambdabot> Maybe you meant: pl oeis docs
02:33:49 <erisco> then there is perhaps the even more trivial Const
02:33:58 <erisco> a Functor in spirit
02:34:09 <mjrosenb> really? I need a new package to get the identity functor?
02:34:24 <erisco> it is our ploy to get you to download more packages
02:34:32 <dramforever> that's not a new package
02:34:41 <liste> it's in base-4.8
02:34:52 <liste> which is the default package
02:34:58 <erisco> okay, used to be separate
02:35:03 <mjrosenb> oh, I suppose I should have seen tat.
02:35:05 <mjrosenb> *that
02:35:14 <mjrosenb> perhaps one margarita is too many.
02:36:11 <liste> actually, there's Control.Monad.Identity and Data.Functor.Identity
02:36:27 <liste> Data.Functor.Identity is in base
02:36:34 <mjrosenb> I feel like they should be one.
02:36:47 <liste> Control.Monad.Identity is maybe in transformers? maybe historical cruft?
02:36:57 <mjrosenb> aren't all functors also monads as of somewhat recently?
02:37:06 <liste> all monads are applicatives now
02:37:11 <mjrosenb> or possibly all monads are functors
02:37:14 <liste> all monads have alvays been fucntors
02:37:15 <mjrosenb> there we go.
02:37:22 <liste> always*
02:37:37 <thealpine> sorry people, I have a question
02:37:45 * mjrosenb cannot think of a monad that is not a functor off the top of his head.
02:38:01 <liste> because there can't be one
02:38:04 <liste> @src Monad
02:38:04 <lambdabot> class  Monad m  where
02:38:04 <lambdabot>     (>>=)  :: forall a b. m a -> (a -> m b) -> m b
02:38:04 <lambdabot>     (>>)   :: forall a b. m a -> m b -> m b
02:38:04 <lambdabot>     return :: a -> m a
02:38:04 <lambdabot>     fail   :: String -> m a
02:38:33 <thealpine> do you know a irc channel where I can find topics like Ddos, Metasploit, hacking in general..?
02:38:38 <mjrosenb> err
02:38:39 <liste> liftM is equivalent to fmap
02:38:50 <mjrosenb> yes.  alcohol.  I cannot think of a functor that is not a monad.
02:39:01 * hackagebot bitx-bitcoin 0.4.0.1 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.4.0.1 (tebello_thejane)
02:39:17 <liste> but yeah, no class shown. is there a Functor m => Monad m constraint?
02:39:22 <liste> logically, there is
02:39:36 <jle`> there's Applicative m => Monad m, and Functor m => Applicative m
02:39:41 <rlewis> there is since 7.10
02:40:23 <liste> thealpine try sticking # or ## in front of topics you're interested in and see what you find
02:40:55 <jle`> mjrosenb: Const is one that was just mentioned
02:41:00 <liste> this one is about the Haskell programming language
02:41:11 <jle`> also in base is ZipList
02:42:31 <mjrosenb> > map (\y->length $ traverse (\x->[1..x]) [0..y]) [1..10]
02:42:33 <lambdabot>  [0,0,0,0,0,0,0,0,0,0]
02:42:52 <mjrosenb> > map (\y->length $ traverse (\x->[1..x]) [1..y]) [1..10]
02:42:57 <lambdabot>  mueval-core: Time limit exceeded
02:42:58 <lambdabot>  mueval: ExitFailure 1
02:42:58 <rohan_> :T traverse
02:43:03 <rohan_> :t traverse
02:43:06 <mjrosenb> really?
02:43:06 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
02:43:12 <mjrosenb> > map (\y->length $ traverse (\x->[1..x]) [1..y]) [1..5]
02:43:13 <lambdabot>  [1,2,6,24,120]
02:43:17 <mjrosenb> there we go.
02:43:39 <mjrosenb> I feel like lazy evaluation should have given a partial list on the ..10 case.
02:44:02 * hackagebot transient 0.1.0.2 - A monad for extensible effects and primitives for unrestricted composability of applications  https://hackage.haskell.org/package/transient-0.1.0.2 (AlbertoCorona)
02:44:18 <dramforever> mjrosenb: it does...somehow it's not happening in lambdabot
02:44:34 <jle`> it's probably lambdabot's server/system having glitches
02:44:40 <jle`> unrelated to the haskell runtime itself
02:44:43 <jle`> it happens every once in a while
02:44:51 <erisco> :t \f -> over _Just (over _1 f) . (^? _Right)
02:44:53 <lambdabot> Field1 a1 b a b1 => (a -> b1) -> Either c a1 -> Maybe b
02:45:00 <erisco> is there a way to shorten that up or is it sane?
02:45:01 <dramforever> btw any reason for this slow factorial?
02:45:41 <jle`> a reason why it's slow, you mean?
02:45:42 <mjrosenb> it is always good to know interesting ways to express basic sequences!
02:45:44 <jle`> or why to do it
02:47:54 <kuribas> :t over _Just
02:47:55 <lambdabot> (a -> b) -> Maybe a -> Maybe b
02:48:44 <cocreature> :t \f -> over (_Just . _1)  f . (^? _Right)
02:48:45 <lambdabot> Field1 a1 b a b1 => (a -> b1) -> Either c a1 -> Maybe b
02:48:49 <cocreature> ^ erisco
02:49:31 <erisco> ah you can compose those too, okay
02:50:06 <kuribas> :t over (_Just . _1 . _Right)
02:50:08 <lambdabot> Field1 a b (Either c a1) (Either c b1) => (a1 -> b1) -> Maybe a -> Maybe b
02:50:59 <mjrosenb> @hoogle (Int -> a -> b -> [a] -> [b]
02:51:00 <lambdabot> Parse error:
02:51:00 <lambdabot>   (Int -> a -> b -> [a] -> [b]
02:51:00 <lambdabot>   ^
02:51:09 <erisco> is there a class for escapable monads? (Monad m) => m a -> a  ?
02:51:13 <mjrosenb> @hoogle (Int -> a -> b) -> [a] -> [b]
02:51:14 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
02:51:14 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
02:51:14 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
02:51:43 <kuribas> :t \f -> over (_Just . _1)  f . (preview _Right)
02:51:45 <lambdabot> Field1 a1 b a b1 => (a -> b1) -> Either c a1 -> Maybe b
02:52:26 <mjrosenb> erisco: what types would implement this?
02:52:35 <erisco> not many
02:52:37 * mjrosenb can think of the identity monad.
02:52:38 <erisco> Identity
02:53:00 <kuribas> The list monad
02:53:11 <erisco> how? empty list
02:53:21 <kuribas> Right, that would be not total...
02:53:34 <erisco> also if you have many elements, which do you return?
02:53:44 <kuribas> The first for example.
02:53:53 <erisco> but why the first
02:54:00 <erisco> it makes for a poor use of type classes imo
02:54:06 <erisco> considering you only get one per type
02:54:23 <jle`> erisco: there is a typeclass for things w where you have (w a -> a), with associated laws about how it should be implemented/behave, etc.
02:54:25 <erisco> I guess you'd need more information to do m a -> a
02:54:35 <jle`> an ad-hoc `m a -> a` typeclass would be a bit not-so-useful
02:54:38 <jle`> without laws
02:54:39 <kuribas> erisco: Why would you need this?
02:54:57 <erisco> I am just trying to think what monads this would work for
02:55:13 <erisco> I am writing some code where I have to throw away the monad, and I just put in Identity, hopefully that ends up being okay
02:55:38 <liste> at least the ones that are comonads too (:
02:55:41 <liste> @src Comonad
02:55:41 <lambdabot> Source not found. There are some things that I just don't know.
02:56:09 <erisco> :t extract
02:56:10 <lambdabot> Not in scope: ‘extract’
02:56:20 <kuribas> erisco: you mean a total function?
02:56:20 <liste> so (,), Identity and NonEmpty at least
02:56:46 <erisco> Const?
02:56:51 <erisco> no that wouldn't work
02:56:51 <liste> and Tree
02:57:07 <mjrosenb> empty tree?
02:57:07 <kuribas> Can be empty
02:57:19 <liste> there's a Comonad Tree
02:57:50 <liste> the Tree is http://hackage.haskell.org/package/containers-0.5.5.1/docs/Data-Tree.html#t:Tree
02:57:56 <liste> so it's non-empty
02:58:36 <erisco> hm, I can also use the Maybe monad in this case...
02:59:07 <liste> http://hackage.haskell.org/package/comonad-4.2.7.2/docs/Control-Comonad.html#control.i:Comonad
02:59:21 <jle`> if you want to write a monadic function and you don't carea bout the monad, the best way to do it is to just parameterize it over all Monad m
02:59:55 <kuribas> :t \f -> let a = f a in a
02:59:56 <lambdabot> (r -> r) -> r
03:00:02 <kuribas> The reader monad :)
03:00:20 <erisco> I mean (Either a)
03:01:08 <kuribas> :t \f -> f undefined
03:01:09 <lambdabot> (r1 -> r) -> r
03:01:38 <kuribas> Ok, that's cheating...
03:02:05 <siwica> Do you know if there is an haskell emacs mode that can pretty print code?
03:03:28 <mjrosenb> siwica: I bet #haskell-emacs knows.
03:04:03 <jle`> kuribas: if you have an (r -> a), and you know things about the r, you can get an a out of it
03:04:11 <erisco> it is interesting because it returns (Monad m) => m (Either a b)
03:04:12 <jle`> you can extract anything from Reader Int a, for example
03:04:19 <jle`> or Reader () a
03:04:24 <erisco> so you can choose (Either a) for m
03:04:28 <erisco> and then join
03:04:31 <jle`> or Monoid m => Reader m a
03:04:34 <kuribas> jle`: yes, but not in general, right?
03:04:45 <jle`> well, what was the question?
03:04:50 <kuribas> jle`: without abusing bottom
03:04:51 <jle`> "Monads that you can get values from, m a -> a"
03:05:01 <jle`> Reader Int is definitely a Monad that you can write a m a -> a in
03:05:20 <jle`> if your Monad is (Reader Bool), you can definitely write a (Reader Bool) a -> a
03:05:49 <jle`> so those are specific examples of monads you can write m a -> a's with
03:05:55 <kuribas> true
03:06:29 <siwica> mjrosenb: Oh, didn't know about this channel. Thanks!
03:07:22 <jle`> Reader is not a monad, but Reader Int, Reader Bool, Reader [Int], etc. are all monads, and they all give you an m a -> a
03:07:37 <jle`> `Reader Void` is a monad where you won't be so lucky
03:08:12 <mhd> Wouldn't it be possible to solve the complexity issues of Control.Monad.Free using rewrite rules?
03:08:16 <rohan_> no void in haskell afaik ... try ()
03:08:20 <rohan_> :t ()
03:08:21 <lambdabot> ()
03:08:28 <johnw> mhd: which complexity issues?
03:08:28 <jle`> Void and () are different here, heh
03:08:44 <jle`> defined as `data Void`
03:08:49 <mhd> johnw: it re-builds the tree every time you use >>=
03:08:54 <rohan_> :t map
03:08:56 <lambdabot> (a -> b) -> [a] -> [b]
03:09:00 <johnw> use Church-encoded Free
03:09:05 <jle`> a type with no (non-bottom) inhabitants
03:09:10 <johnw> however, that will cost you if you examine what you're building during construction
03:09:22 <mhd> johnw: I know that exists, I'm just thinking if the other thing is possible too
03:09:36 <johnw> hmm
03:09:51 <johnw> there's always a way to find out :)
03:09:57 <jle`> rohan_: `Reader ()` is definitely a monad where you can write an m a -> a.  `Reader Void`, definitely not so :)
03:09:57 <mhd> johnw: the principal problem is the left asociative nature of >>=
03:10:09 <mhd> johnw: perhaps a Kleisli arrow could help too
03:10:28 <johnw> you need to traverse the structure to read the 'a' in each Pure
03:10:30 <erisco> that mismatch where one library uses monads and the other doesn't... ugh
03:10:36 <johnw> hmm
03:10:56 <johnw> even if you reassociate the binds, you're still paying a traversal, aren't you?
03:11:06 <rohan_> jle`: not used VOid so far
03:11:09 <johnw> i guess it's just not quadratic then
03:11:09 <rohan_> where is it?
03:11:59 <jle`> rohan_: atm the one people mostly use is from the `void` package
03:12:03 <jle`> @hackage void
03:12:03 <lambdabot> http://hackage.haskell.org/package/void
03:12:25 <erisco> the package for all things not
03:12:36 <kuribas> When shouldn't I use $!?  (In strict code).
03:13:58 <liste> :t ($!?)
03:13:59 <lambdabot>     Not in scope: ‘$!?’
03:13:59 <lambdabot>     Perhaps you meant ‘$!’ (imported from Prelude)
03:14:41 <kuribas> liste: sorry, I should have put a space between $! and ?
03:14:53 <kuribas> The wiki says: If f is strict or inlined, then the chances are that ($!) is unnecessary cruft here.
03:14:58 <liste> :D yeah I kinda figured out what you meant but wasn't sure
03:15:15 <kuribas> Does that mean it's harmless, or not?
03:15:26 <liste> kuribas it can be confusing
03:15:39 <ChristianS> kuribas: i haven't yet felt the need to use it
03:15:48 <liste> "why is he using $ !? is there something I miss here?"
03:15:52 <liste> $! ? *
03:16:19 <kuribas> For efficiency
03:16:30 <srhb> kuribas: I feel like the distinction they're trying to mention is that between seq and eg. deepseq
03:16:36 <erisco> streamline all the things!
03:17:32 <srhb> kuribas: ie if the argument is already in WHNF, it does nothing.
03:17:43 <kuribas> right
03:18:13 <kuribas> is it better to use bangpatterns?
03:18:22 <srhb> It's equivalent to bang patterns.
03:18:46 <srhb> f $! x = let !whnfx = x in f whnfx
03:21:40 <kuribas> Inspecting a field of a constructor in a guard, will make it strict, right?
03:22:07 <srhb> What do you mean by inspecting?
03:23:29 <srhb> For instance, I might pattern match on (Foo (Bar x)) but this still leaves x unevaluated, if nothing else has forced its evaluation.
03:23:54 <Gurkenglas_> Should there be a "Traversal [(k, a)] (Map k b) a b" for fromListWith?
03:24:22 <dramforever> Gurkenglas_: it's unlikely that it will follow the traversal laws, iirc
03:24:35 <dramforever> dunno the details, though
03:24:40 <kuribas> srhb: say f (Foo (Bar x)) | null x = ...
03:24:51 <srhb> kuribas: The null x will evaluate x
03:25:36 <kuribas> srhb: if the other fields are strict, will evaluating one evaluate all the fields?
03:25:40 <srhb> kuribas: But that's because of what null does, not just that you're applying a function to it.
03:26:14 <srhb> kuribas: Oh, hm. I'd have to look that up, if Bar is a strictified datatype.
03:26:49 <kuribas> say "data Foo = Foo !A !B !C"
03:27:23 <erisco> how would you focus on elements of a list with lens/prisms/whatevers ?
03:27:29 <erisco> for example, how would you write head?
03:27:33 <erisco> or safeHead
03:27:52 <Gurkenglas_> "t pure = pure" - does this mean that if a = b, then necessarily s = t?
03:28:49 <srhb> kuribas: I _think_ that that merely means that when you're constructing the values, ie by Foo y, it's really y `seq` Foo y -- but I'm not sure. Looking up the docs now
03:29:11 <kuribas> > firstOf each [1..]
03:29:13 <lambdabot>  Just 1
03:29:31 <kuribas> erisco: ^^
03:29:38 <erisco> thanks
03:29:58 <kuribas> > preview each [1..]
03:30:00 <lambdabot>  Just 1
03:30:15 <srhb> kuribas: No, I'm pretty sure that's correct. So in essence you can't even construct a value of type Foo where its fields have not already been evaluated to at least WHNF
03:30:53 <kuribas> srhb: so reading one field will means all the fields are at least WHNF?
03:30:53 <Gurkenglas_> (Talking about the "Idiomatic naturality" law on https://hackage.haskell.org/package/lens-1.9/docs/Control-Lens-Traversal.html )
03:31:48 <srhb> kuribas: That's not untrue, except the implication isn't because of that. It's that you can't _construct_ the value without WHNF evaluated fields, so emphatically when you pattern match on any of them, they will already be in WHNF (because they were constructed before you pattern matched.)
03:32:09 <srhb> Take with a grain of salt and consult the docs, though, I can't find the relevant section.
03:32:50 <kuribas> srhb: thanks, that was helpful!
03:33:28 <srhb> @let data Foo a b = Foo !a b
03:33:29 <lambdabot>  .L.hs:190:1:
03:33:29 <lambdabot>      Multiple declarations of ‘Foo’
03:33:29 <lambdabot>      Declared at: .L.hs:147:1
03:33:43 <srhb> @let data Quux a b = Quux !a b
03:33:45 <lambdabot>  Defined.
03:34:22 <srhb> let first (Foo a _) = a in first $ Foo 2 undefined
03:34:26 <srhb> > let first (Foo a _) = a in first $ Foo 2 undefined
03:34:28 <lambdabot>      Constructor ‘Foo’ should have 3 arguments, but has been given 2
03:34:28 <lambdabot>      In the pattern: Foo a _
03:34:28 <lambdabot>      In an equation for ‘first’: first (Foo a _) = a
03:34:33 <srhb> Woops
03:34:40 <kuribas> I assume that when I inspect an element of a argument in a guard, that ghc will flag the argument as strict, so actually calling the function will evaluate each argument to whnf.
03:34:47 <srhb> > let first (Quux a _) = a in first $ Quux 2 undefined
03:34:49 <lambdabot>  2
03:35:04 <srhb> > let second (Quux _ b) = b in second $ Quux undefined 2
03:35:06 <lambdabot>  *Exception: Prelude.undefined
03:35:14 <srhb> There awe go.
03:35:20 <kuribas> Better worded, ghc will flag the function as strict in that argument.
03:36:00 <srhb> I'm not sure whether you're talking about strict datatypes or $! now
03:36:11 <rohansumant> O meri jaan!
03:36:30 <kuribas> srhb: strict datatypes
03:36:35 <rohansumant> > Haskell 
03:36:37 <lambdabot>  Not in scope: data constructor ‘Haskell’
03:36:46 <kuribas> @let data Quux a b = Quux !a b
03:36:48 <lambdabot>  .L.hs:192:1:
03:36:48 <lambdabot>      Multiple declarations of ‘Quux’
03:36:48 <lambdabot>      Declared at: .L.hs:190:1
03:36:54 <dramforever> @undefine
03:36:54 <lambdabot> Undefined.
03:36:56 <dramforever> ftfy
03:37:01 <Gurkenglas_> (Oh, the "Traversal [(k, a)] (Map k b) a b" for fromListWith can't work, since trying to turn it into an "[(k, a)] -> Map k [a]" in the naive-obvious way would just yield an "[(k, a)] -> [Map k a]".)
03:37:02 <kuribas> @let data Quux a b = Quux !a b
03:37:04 <lambdabot>  Defined.
03:37:09 <kuribas> @undefine
03:37:09 <lambdabot> Undefined.
03:37:13 <kuribas> @let data Quux a b = Quux !a !b
03:37:14 <lambdabot>  Defined.
03:37:22 <kuribas> let first (Quux a _) = a in first $ Quux 2 undefined
03:37:26 <kuribas> > let first (Quux a _) = a in first $ Quux 2 undefined
03:37:28 <lambdabot>  *Exception: Prelude.undefined
03:37:44 <kuribas> dramforever: thanks
03:37:46 <srhb> kuribas: I'm not quite sure on the distinction you're trying to make. I think it makes more sense to say that you cannot construct the value without evaluating the fields to whnf. This doesn't change functions pattern matching on the fields to evaluate the fields to WHNF, because they _already are_ in WHNF
03:37:58 <dramforever> =)
03:38:21 <srhb> At least, that's my understanding
03:38:47 <kuribas> srhb: just that I am trying to understand how evaluation is done in ghc, so I can optimize it.
03:39:01 <srhb> Okay.
03:39:55 <Gurkenglas_> Is there something like "type NotQuiteTraversal f a b = Applicative g => (a -> g b) -> f a -> f (g b)"?
03:42:04 <srhb> Maybe the construction terminology is a bit unintuitive because construction doesn't "happen" until the constructor is evaluated anyway
03:42:18 <srhb> So how about: If the constructor is evaluated, then so too are the strict fields ?
03:43:55 <rohansumant> > map id [1,2,3]
03:43:57 <lambdabot>  [1,2,3]
03:44:24 <knupfer> why is  (/2) <$> ((+) <$> a <*> b) === (((/2) .) . (+)) <$> a <*> b
03:45:07 <knupfer> can someone show me the steps
03:45:47 <dramforever> @unpl (((/2) .) . (+))
03:45:47 <lambdabot> (\ e h -> (e + h) / 2)
03:46:16 <dramforever> hmm...interesting...I don't know why, though
03:46:27 <knupfer> hm
03:47:13 <knupfer> and besides, which notation is preferable?
03:47:26 <srhb> http://conal.net/blog/posts/semantic-editor-combinators
03:47:32 <lyxia> pointful is preferable here
03:47:32 <srhb> knupfer: The one with explicit points
03:47:32 <dramforever> I prefer the LHS
03:47:53 <srhb> It's completely unreadiable in either version that does not name the arguments
03:48:05 <srhb> OK, I guess the first one isn't THAT bad.
03:48:19 <Gurkenglas_> As dram said, the right side applies that across a, then b. The left side applies (\ e h -> (e + h)) across a, then b, which of course just generates the same thing as the right side, only with each element of the resulting data structure doubled. fmapping (/2) across the result remedies that.
03:48:38 <srhb> But as soon as you start sectioning (.) it gets really hard to parse. Few people can do those in their head for reasonably complex expressions
03:49:29 <Gurkenglas_> Let's have "(\ e h -> (e + h) / 2) <$> a <*> b" as a steelman for the RHS. Which of that and the LHS is better?
03:49:31 <knupfer> so it's actually just a complex computation (notation wise)?
03:50:07 <srhb> I certainly prefer the pointful version
03:50:16 <srhb> knupfer: Not sure what you mean.
03:50:29 <srhb> From the point of the compiler, it's not complex at all. :P
03:51:23 <Gurkenglas_> And just calling a haskell term a "computation" doesn't say much.
03:51:32 <knupfer> srhb: from the point of mathematics, it could be true
03:51:41 * srhb shrugs
03:51:44 <srhb> Not sure what you mean, still.
03:51:54 <srhb> It's hard to read and see exactly what's going on.
03:51:58 <Gurkenglas_> If you mean complex numbers, this has nothing to do with that.
03:52:01 <srhb> I think that thoroughly encompasses it.
03:52:30 <knupfer> well, i just wanted to know which is the simplest notation, and how exactly i can come from the LHS to all the points on the RHS
03:52:43 <mjrosenb> oh snap, I asked the wrong question earlier
03:52:53 <srhb> knupfer: You just expand the definitions
03:53:09 <srhb> knupfer: For instance, the section becomes (\x -> x / 2) and so on
03:53:10 <mjrosenb> I don't have data Poly a = Poly {a :: a, b :: a, c :: Int }
03:53:45 <mjrosenb> I have Poly a  = Poly { a :: (Int, a), b :: (Int, a), c ++ Int }
03:53:46 <srhb> knupfer: The tricky part might be to realize that the first fmap becomes composition.
03:53:51 <srhb> Perhaps that's what's throwing you off.
03:54:00 <jle`> knupfer: you have the definitions of (<$>), (<*>), and (.) available
03:54:07 <jle`> so one way to do it is to just manually expand both sides
03:54:18 <mjrosenb> and I want a function with type ((Int, a) -> (Int, b)) -> Poly a -> Poly b
03:54:21 <jle`> (f <$> g) x = f (g x)
03:54:33 <Gurkenglas_> The LHS applies first (+) across both, then (/2) across the result. That is the same as applying (((/2) .) . (+)) across both, which function can be read as "partially apply (+) to the first argument, then compose the resulting function to the right of (/2)".
03:54:37 <jle`> (f <*> g) x = f x (g x)
03:54:45 <mjrosenb> preferably with either Lens or Traversal
03:54:45 <jle`> (f . g) x = f (g x)
03:54:59 <mjrosenb> since the *actual* type that I have is like 10x larger
03:55:00 <mjrosenb> and deeper
03:55:13 <erisco> I want to classify all Monad m such that there exists an f :: m (Either a b) -> Either a b
03:55:18 <mjrosenb> and a and b aren't first.
03:55:22 <erisco> I am not sure what to make of that
03:55:30 <erisco> there are lots of things that work... Identity, Maybe, Either
03:55:45 <Gurkenglas_> <jle`> (f <*> g) x = f x (g x) <- that's just one applicative instance definition. Using this one does not help equating the two sides of the equation.
03:55:50 <erisco> sorry, not Maybe... my spec is slightly off
03:56:14 <jle`> Gurkenglas_: it seems to be the relevant instance for this situation
03:56:24 <erisco> I want to classify all Monad m such that there exists an f :: m (Either a b) -> Maybe b
03:56:31 <jle`> oh wait
03:56:34 <jle`> nvm
03:56:51 <erisco> so, lots works there
03:57:06 <erisco> this is a more particular case of  m a -> a
03:57:23 <Gurkenglas_> Why focus on monads?
03:57:32 <erisco> because that is what I'm being dealt
03:57:55 <erisco> I have to plug a circle into a square hole best I can
03:58:23 <erisco> pipes uses monads, tdfa does not
03:59:37 <knupfer> heura, i've understood, what a good sensation
03:59:39 <jle`> erisco: how about going backwards?  it's pretty easy to get Maybe b -> m (Either a b) if you have the choice to pick the a
04:00:05 <knupfer> s/heura/heureka
04:00:23 <erisco> I have to implement Uncons for producers
04:00:26 <erisco> http://hackage.haskell.org/package/regex-tdfa-1.2.0/docs/Text-Regex-TDFA-NewDFA-Uncons.html
04:00:31 <erisco> uncons :: a -> Maybe (Char, a)
04:00:48 <erisco> http://hackage.haskell.org/package/pipes-4.1.6/docs/Pipes.html
04:00:53 <erisco> next :: Monad m => Producer a m r -> m (Either r (a, Producer a m r))
04:01:01 <Gurkenglas_> Any "m (Either a b) -> Maybe b" would seem to factorize into a "m (Maybe b) -> Maybe b" composed to the left of "fmap $ either (const Nothing) Just"
04:01:02 <erisco> this is where the problem comes from
04:01:15 <siwica> what is the recommended way of installing a more recent version of ghc on ubuntu?
04:01:40 <srhb> siwica: You can just grab ghc and cabal + cabal install from the website.
04:02:03 <jle`> siwica: i think the general advised way is https://launchpad.net/~hvr/+archive/ubuntu/ghc
04:02:11 <Sindriava> jle` + 1
04:02:45 <jle`> erisco: it looks like your production process is non-monadic
04:02:56 <erisco> I've said that
04:03:08 <jle`> you have the choice to choose your m
04:03:16 <erisco> yes I do
04:03:22 <erisco> that is why I want to classify all valid choices, ideally
04:03:27 <erisco> right now I am just picking Identity
04:03:33 <erisco> but there are a few other possibilities
04:04:23 <jle`> is this for a practical purpose, or just for fun thoughts?
04:04:46 <erisco> trying to plug pipes into tdfa is not what I'd consider fun XD
04:05:02 <Gurkenglas_> :t asum -- If you want "m (Maybe b) -> Maybe b", you can use any traversable in place of m and get asum
04:05:03 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
04:05:10 <jle`> i mean, finding/classifying such monads
04:05:24 <Gurkenglas_> @instances Traversable
04:05:28 <lambdabot> Array i, Identity, Maybe, Proxy, Seq.Seq, Seq.ViewL, Seq.ViewR, Tree, []
04:05:41 <erisco> well sure, because producers that only use Identity is rather restrictive
04:06:28 <Gurkenglas_> (That would get you the behavior of "get the first Right b from the data structure and give back Just b")
04:06:57 <erisco> hm, that is a good idea
04:07:18 <erisco> except that if I have a producer using (Either a) then can I map it to use Maybe?
04:07:38 <erisco> let me think... getting late
04:07:56 <Gurkenglas_> :t either (const Nothing) Just -- [13:00] <Gurkenglas_> Any "m (Either a b) -> Maybe b" would seem to factorize into a "m (Maybe b) -> Maybe b" composed to the left of "fmap $ either (const Nothing) Just"
04:07:57 <lambdabot> Either b a -> Maybe a
04:08:40 <erisco> but I need  Producer a (Either b) c -> Producer a Maybe c
04:08:43 <jle`> erisco: are you trying to make a Producer that consumes from a bytestring/Uncons instance?
04:08:57 <jle`> er, produces from
04:09:02 <erisco> jle`, no
04:09:06 * hackagebot ltk 0.15.0.4 - Leksah tool kit  https://hackage.haskell.org/package/ltk-0.15.0.4 (HamishMackenzie)
04:09:11 <kuribas> @hoogle (a -> Bool) -> Maybe a
04:09:12 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
04:09:12 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
04:09:12 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
04:09:29 <erisco> Uncons is required by tdfa to parse the source
04:09:41 <erisco> the source is a producer in this case
04:09:54 <jle`> kuribas: only possible implementation is const Nothing, I think
04:10:15 <kuribas> :t const Nothing
04:10:17 <lambdabot> b -> Maybe a
04:10:48 <kuribas> :t (\f a -> if f a then Just a else Nothing)
04:10:49 <lambdabot> (a -> Bool) -> a -> Maybe a
04:10:59 <jle`> @djinn (a -> Bool) -> Maybe a
04:10:59 <lambdabot> f _ = Nothing
04:11:10 <kuribas> @hoogle (a -> Bool) -> a -> Maybe a
04:11:11 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
04:11:11 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
04:11:11 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
04:11:24 <jle`> ah, i'd probably use mfilter p (Just x)
04:11:24 <erisco> :t guard
04:11:25 <lambdabot> Alternative f => Bool -> f ()
04:11:40 <jle`> :t \p x -> mfilter p (Just x)
04:11:42 <lambdabot> (a -> Bool) -> a -> Maybe a
04:12:32 <jle`> :t \p x -> x <$ guard (p x)   -- some people do this too but it's kind of weird
04:12:33 <lambdabot> Alternative f => (a -> Bool) -> a -> f a
04:13:24 <jle`> whoa, guard uses alternative now.  neat.
04:13:51 <erisco> new-fangled technology
04:14:04 <jle`> although i guess it happened like 5 months ago, which is forever in haskell-years
04:15:11 <erisco> I have no ideas how you would map the producer monad
04:15:29 <erisco> such a map doesn't seem to be exposed from what I can find
04:15:56 <erisco> I'd think it possible though
04:16:36 <Gurkenglas_> Oh wait, asum works not only for traversables, but also foldables
04:18:49 <erisco> lets see... if  Producer a m  could be a Foldable or Traversable then just maybe
04:18:56 <erisco> by using   each :: (Monad m, Foldable f) => f a -> Producer' a m ()
04:19:17 <erisco> or  every :: (Monad m, Enumerable t) => t m a -> Producer' a m ()
04:19:21 <erisco> but I haven't seen Enumerable before
04:19:24 <kuribas> :i mfilter
04:19:41 <erisco> oh wait
04:19:48 <erisco> :t enumFromTo
04:19:49 <phaazon> :t filterM
04:19:49 <lambdabot> Enum a => a -> a -> [a]
04:19:50 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
04:19:57 <erisco> no I guess that is different
04:20:19 <phaazon> I always wondered why we have filterM and no partitionM :)
04:20:25 <phaazon> both are useful functions
04:26:07 <erisco> foldMap _ _ = mempty
04:26:13 <erisco> is there something saying I shouldn't do this?
04:26:34 <erisco> that makes every * -> * a foldable oO
04:26:49 <dramforever> sadly yes you are right, it's legitimate
04:26:58 <dramforever> wait no
04:27:17 <dramforever> if it were also a traversable, you have make sure the two instances match
04:27:30 <dramforever> so you basically ruled out all traversables
04:29:41 <erisco> this aint going to work how I'd envision it
04:29:46 <erisco> I dunno this kinda sucks XD
04:30:16 <RageYL> is it possible to create a new data type as: data MyType = Maybe MyType { somehthing } | Maybe Another { something } ?
04:30:36 <erisco> it looks like Either
04:30:53 <erisco> :t (Left, Right)
04:30:54 <lambdabot> (a -> Either a b, b1 -> Either a1 b1)
04:31:05 <RageYL> no, that's not what i want, i would like to have the type encapsulated in a maybe
04:31:40 <erisco> hm, I don't know, I don't understand your notation, can you explain it another way?
04:32:25 <RageYL> i have a data type and i want to implement the Show interface on it
04:32:35 <RageYL> but my type is always used as 'Maybe Mytype'
04:32:47 <RageYL> and i would like 'show' to work on Maybe Mytype
04:32:49 <erisco> well, add "deriving (Show)" to the declaration of MyType
04:32:57 <RageYL> i want to rewrite the 'show'
04:33:09 <RageYL> instance Show (Maybe MyType) where
04:33:10 <erisco> if you want to write your own show then  instance Show MyType where
04:33:18 <erisco> nope, that isn't needed
04:33:29 <erisco> because  instance (Show a) => Show (Maybe a)  is already there for you
04:33:39 <RageYL> yep but i don't want to display 'Nothing'
04:33:44 <RageYL> i would like to display an empty string
04:33:50 <erisco> okay, well then you don't want to use show
04:34:00 <erisco> write a different printing function
04:34:22 <RageYL> ok
04:34:28 <Tuplanolla> Show is supposed to work with Read whenever feasible, RageYL.
04:34:33 <erisco> :t maybe "" show
04:34:34 <lambdabot> Show a => Maybe a -> [Char]
04:34:36 <erisco> or do that
04:36:09 <RageYL> oh that sound nice !
04:40:31 <Trioxin> wow I hadn't realized haskell is so popular. There seem to be more people here than any other language's channel other than python.
04:40:37 <saep> Use a pretty printing library.
04:51:15 <quchen> Trioxin: The number of users is hardly representative of a language's popularity.
04:51:27 <mjrosenb> edwardk: any insight?
04:51:27 <quchen> We have *lots* of idlers here.
04:51:45 <erisco> for instance Rodya
04:51:47 <erisco> huge idler
04:51:48 <erisco> and roo
04:51:55 <erisco> and vmeson
04:54:09 * hackagebot both 0.1.0.0 - Like Maybe, but with a different Monoid instance.  https://hackage.haskell.org/package/both-0.1.0.0 (barrucadu)
04:54:30 <haskell188> why m is ambigous in this unction http://lpaste.net/6989495877609979904
04:55:06 <Trioxin> idk, i'm seeing frequent joins and parts. Maybe I've found the ultimate language, hidden in plain sight.
04:55:43 <erisco> haskell188, I dunno 100%, but result :: TMVar (m (Either String Int )) looks suspect
04:56:03 <erisco> the 'm' there is not the same 'm' as above for applyCommand unless you turn on ScopedTypeVariables
04:56:22 <erisco> if you remove that annotation maybe the problem goes away
04:56:24 <liste> Trioxin hardly ultimate, you see a ton of progress in Haskell and similar languages (Agda, Idris...)
04:56:50 <haskell188> erisco: I already have ScopedTypeVariables turned on
04:57:01 <liste> we find new flaws very frequently
04:57:20 <erisco> haskell188, also include the compiler error, could help
04:57:40 <liste> and better ways to do things
04:58:09 <haskell188> erisco: http://lpaste.net/6989495877609979904
04:58:51 <dramforever> prepend forall m. to your type sig
04:59:00 <erisco> haskell188, for some reason I don't believe the extension is on
04:59:07 <dramforever> like applyCommand :: forall m. (EventStore m, ...) ...
04:59:15 <dramforever> erisco: ^
04:59:18 <erisco> Could not deduce (EventStore m) ... from (EventStore m1, ...
04:59:25 <dramforever> see?
04:59:39 <erisco> oh the extension needs you to use explicit forall
04:59:44 <erisco> that's right! of course! intuitive! -.-
05:00:19 <haskell188> oh okay, solved
05:00:21 <erisco> Trioxin, it's a winner alright
05:00:22 <haskell188> thanks :)
05:04:09 <Xnuk> Can I create number range type?
05:04:43 <MarcelineVQ> > [1..10]
05:04:45 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:04:57 <liste> @let data Range a = Range a a -- Xnuk
05:04:58 <lambdabot>  Defined.
05:05:24 <liste> > (Range 1 10) :: Range Int
05:05:26 <lambdabot>      No instance for (Show (Range Int))
05:05:26 <lambdabot>        arising from a use of ‘show_M765231400520962369116486’
05:05:26 <lambdabot>      In the expression:
05:05:34 <liste> yeah, it's pretty useless without instances
05:05:38 <Xnuk> Oh
05:06:02 <liste> but what would you want to do with it?
05:07:48 <liste> if you want to make sure the first number is less than the second, make a function to construct Ranges
05:09:13 <liste> @let mkRange :: Ord a => a -> a -> Maybe (Range a a); mkRange x y | x < y = Just (Range x y) | otherwise = Nothing
05:09:14 <lambdabot>  .L.hs:150:38:
05:09:14 <lambdabot>      ‘Range’ is applied to too many type arguments
05:09:14 <lambdabot>      In the type signature for ‘mkRange’:
05:09:35 <liste> @let mkRange :: Ord a => a -> a -> Maybe (Range a); mkRange x y | x < y = Just (Range x y) | otherwise = Nothing
05:09:36 <lambdabot>  Defined.
05:10:17 <Gurkenglas__> https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Ix.html has ranges
05:10:46 <erisco> why not just let a range like (0,-1] be empty
05:12:07 <ggole> Having multiple possible values be the same empty range is a little error prone
05:13:41 <ggole> Eg, imagine a function bump :: Range Int Int -> Range Int Int that increments the upper bound by one: you would need to remember to test for the upper < lower case
05:17:10 <erisco> I guess it depends on what you expect that function to do
05:17:20 <erisco> from an API perspective, having the constructor return in Maybe is annoying
05:17:43 <liste> merijn had some solution for that? or do I remember correctly?
05:17:56 <kuribas> @hoogle Bool -> a -> Maybe a
05:17:57 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
05:17:57 <lambdabot> Control.Exception assert :: Bool -> a -> a
05:17:57 <lambdabot> Control.OldException assert :: Bool -> a -> a
05:20:17 <ggole> erisco: you could canonicalize in the constructor
05:20:45 <erisco> that sounds alright
05:26:05 <mniip> I think I accidentally invented a better parsec
05:26:29 <kuribas> :t maybe
05:26:31 <lambdabot> b -> (a -> b) -> Maybe a -> b
05:29:45 <Gurkenglas__> :t \f -> find f . Identity -- kuribas
05:29:46 <lambdabot> (a -> Bool) -> a -> Maybe a
05:30:05 <srhb> mniip: Oh?
05:30:28 <kuribas> Gurkenglas: what about (Bool -> a -> Maybe a)?
05:30:30 <mniip> sounds ambitious, right
05:30:40 <kuribas> The best I found is guard f >> Just a
05:30:50 <mniip> I should write some code and see if ends up being horrible
05:30:52 <kuribas> :t \f a -> guard f >> Just a
05:30:54 <lambdabot> Bool -> b -> Maybe b
05:30:56 <srhb> mniip: Well, depends on the tradeoffs I guess. :D
05:31:01 <Gurkenglas__> :t bool (const Nothing) Just
05:31:02 <lambdabot> Bool -> a -> Maybe a
05:34:11 <indiagreen> I'm using pipes to transform a ByteString and I need to replace all consecutive tabs with single tabs in my input – what's the most elegant way to do it (i.e. without writing an explicit loop)?
05:34:12 * hackagebot bindings-yices 0.3.0.1 - Bindings to the Yices theorem prover  https://hackage.haskell.org/package/bindings-yices-0.3.0.1 (PepeIborra)
05:34:29 <erisco> :t curry (uncurry (>>) . (guard *** Just)) -- my creation
05:34:30 <lambdabot> Bool -> b -> Maybe b
05:34:53 <lf94> Hah. Nice.
05:34:53 <Tuplanolla> Using local definitions with Parsec seems to require FlexibleContexts. When did this change?
05:35:51 <int-e> Tuplanolla: ghc-7.10 got more picky about when FlexibleInstances are required (namely, even when an inferred type would require that extension)
05:36:20 <kuribas> Gurkenglas, erisco: ehm, thanks, I guess?
05:36:24 <mniip> :t (<$> const . Just) . (=<<) . guard
05:36:25 <lambdabot>     Couldn't match type ‘()’ with ‘b -> b1’
05:36:25 <lambdabot>     Expected type: Bool -> Maybe a -> b -> b1
05:36:25 <lambdabot>       Actual type: Bool -> Maybe a -> ()
05:36:33 <mniip> screw you
05:36:56 <Tuplanolla> Okay, so at 7.10. Can I find details somewhere, int-e?
05:37:17 <kuribas> indiagreen: does microlens have combinators for (.=) ?
05:37:31 <kuribas> indiagreen: And (^..)?
05:37:42 <indiagreen> kuribas: you mean, non-operator names?
05:37:45 <kuribas> yes
05:38:22 <kuribas> I believe "assign" in lens.
05:38:27 * indiagreen remembers removing toListOf from microlens and thinking “I hope nobody will miss it”
05:38:47 <Tuplanolla> Here apparently: https://www.reddit.com/r/haskell/comments/2zu5r9/on_adding_flexiblecontexts_to_please_ghc_710/
05:38:58 <int-e> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/release-7-10-1.html#idp5793824
05:39:11 <Tuplanolla> That's better, thanks.
05:39:12 * hackagebot bindings-yices 0.3.0.2 - Bindings to the Yices theorem prover  https://hackage.haskell.org/package/bindings-yices-0.3.0.2 (PepeIborra)
05:39:13 <indiagreen> kuribas: so, the answer is “no” for both, but I don't mind adding them
05:39:30 <kuribas> indiagreen: is there an exquivalent for (%=)?  Is there in lens?
05:39:56 <kuribas> indiagreen: well, you don't have to if I am the only one...
05:39:57 <int-e> Tuplanolla: For parsec you probably have a choice between using FlexibleInstances or giving a type signature for the locally defined parsers.
05:40:14 <indiagreen> kuribas: %= has no equivalent that I know of (and lens documentation doesn't list one either)
05:40:32 <kuribas> indiagreen: Actually I kind of like .= because it's meaning is easy to infer.
05:40:59 <lpaste_> mniip pasted “which one looks better” at http://lpaste.net/139419
05:42:37 <Gurkenglas__> "(f, t) <- f t" Are you trying to tie a knot in my head
05:42:56 <kuribas> mniip: the first
05:43:18 <indiagreen> Gurkenglas__: those “f”s aren't the same
05:45:36 <Gurkenglas__> It looks like he should be using WriterT with the Endo monoid
05:46:27 <mniip> this is actually a StateT-esque thing
05:47:14 <Gurkenglas__> But you aren't using f and k anywhere
05:47:17 <indiagreen> kuribas: okay, I made an issue for toListOf and I'm currently kinda busy but maybe I'll release a new version in the evening and toListOf would be there
05:47:31 <kuribas> indiagreen: thanks!
05:48:06 <mniip> Gurkenglas, yes I am
05:48:17 <lpaste_> kuribas annotated “which one looks better” with “would this work?” at http://lpaste.net/139419#a139420
05:48:19 <mniip> 	return (f k, t)
05:48:45 <mniip> kuribas, at this point just
05:48:53 <mniip> runStateT (state f <*> state k)
05:49:22 <kuribas> nice!
05:49:38 <indiagreen> another question: is there some IRC room for pipes?
05:49:49 <Gurkenglas__> mniip, representing f and k as Endos would have the f k done automatically by the monoid instance of endo invoked by writer
05:50:36 <Gurkenglas__> (Of course, this only works if f actually is an endo)
05:51:35 <kuribas> :t runStateT (state f <*> state k)
05:51:37 <lambdabot>     Couldn't match expected type ‘s -> (a0, s)’ with actual type ‘Expr’
05:51:37 <lambdabot>     In the first argument of ‘state’, namely ‘k’
05:51:37 <lambdabot>     In the second argument of ‘(<*>)’, namely ‘state k’
05:51:46 <kuribas> :t \f k -> runStateT (state f <*> state k)
05:51:48 <lambdabot> Monad m => (s -> (a1 -> a, s)) -> (s -> (a1, s)) -> s -> m (a, s)
05:51:50 <Gurkenglas__> (k would be replaced by const k, and you would have to unwrap the result afterward with ($undefined))
05:53:36 <Gurkenglas> (Oh this computer was on the whole time.)
05:54:32 <Hiro`> hey #haskell, do modules have to be compiled before they can be imported?
05:55:38 <magneticduck> so I'm thinking about making a 2d multiplayer game in python
05:55:45 <magneticduck> I'd like to use python 3, so pygame isn't an option
05:56:01 <magneticduck> tbh, I'd be happy with a small portable way of doing graphics / physics across all desktop platforms
05:56:04 <magneticduck> don't need a high level game engine
05:56:07 <arahael> magneticduck: pygame is sucky anyway.  But, isn't this haskell?
05:56:59 <arahael> magneticduck: In any case.  Use SDL.
05:57:40 <hodapp> pygame is incompatible with python 3?
05:57:42 <supki> kuribas: lens HEAD has `modifying` as an alias for %=
05:57:57 <magneticduck> arahael: what?
05:58:02 <magneticduck> "isn't this haskell"?
05:58:17 <hodapp> this is #haskell
05:58:21 <magneticduck> oops
05:58:29 <magneticduck> rofl
05:58:32 <hodapp> o_O
05:58:37 <arahael> magneticduck: And hodapp's surprise is correct, because pygame does work with python3.
05:58:45 <arahael> magneticduck: Yes. Pygame 1.9.2 supports Python 3.2 and up. Only the orphaned _movie module (not built by default) does not.
05:58:55 <arahael> magneticduck: (That's from the pygame site)
06:02:11 <kuribas> Has anyone ever created a GUI app in haskell?
06:02:33 <kuribas> It seems haskell is only used for server, web or console apps.
06:02:34 <MarcelineVQ> sure, here's a more famous one http://xmonad.org/
06:03:24 <kuribas> What about something non-hacker friendly?
06:03:25 <bennofs> kuribas: I've created a small GUI for a board game to debug my AI client for that game
06:03:48 <kuribas> bennofs: which toolkit did you use?
06:03:51 <bennofs> kuribas: hsqml
06:04:15 <bennofs> kuribas: it's not exactly user-friendly, but it looks like this: https://s3.amazonaws.com/uploads.hipchat.com/86822/628713/fj2YNdkIvAxTfbt/15-03-04-15%3A59%3A19.png
06:05:11 <bennofs> kuribas: the board is drawn using QML/JS though, so it's not purely haskell. the backend (computing best moves etc) is in haskell though
06:07:30 <Sindriava> kuribas: The answer is yes, someone has created a GUI app in haskell at least once. Now, why not try rephrasing the question so it makes a bit more sense?
06:08:03 <Sindriava> kuribas: Like "What's the state of GUI programming and libraries in Haskell? There doesn't seem to be a lot of GUI apps written in Haskell."
06:08:37 <bennofs> kuribas: there are also a few GUI apps written using gtk2hs on hackage (for example, hp2any-manager, which is pretty dated and needs a few fixes to compile)
06:08:43 <Sindriava> kuribas: Because what I think you wanted to know is whether or not Haskell is suited for GUI programming, no? :)
06:08:56 <kuribas> Sindriava: yes
06:09:08 <pyon> How much effort would it take to make a purely functional (say, FRP-based) desktop GUI toolkit?
06:09:22 <kuribas> Sindriava: I am currently using wxHaskell, but the mailing list is pretty much dead.
06:09:34 <Sindriava> pyon: Depending on the technologies you would use, anywhere from a little to a lot
06:09:50 <Sindriava> kuribas: I've never seen wxWidgets alive, even.
06:09:52 <bennofs> pyon: there's wx bindings to reactiave-banana afaik
06:10:04 <bennofs> pyon: not sure if there's also gtk ones
06:10:09 <Sindriava> kuribas: Short answer is "yes", the long is "yes, about as much as any other language."
06:10:24 <kuribas> Sindriava: I doubt that
06:10:37 <kuribas> Sindriava: toolkit support is much better in other languages.
06:11:03 <Sindriava> kuribas: Which isn't exactly a property of a language, rather the community surrounding it.
06:11:22 <Sindriava> kuribas: And if you don't mean C by other languages, the support tends to be shoddy elsewhere too.
06:12:04 <kuribas> Sindriava: well GUI toolkit in python seem to have a much more active community.
06:12:40 <hamishmack> kuribas: Leksah is a fair sized Haskell GUI app that uses Gtk2Hs
06:13:34 <Sindriava> kuribas: And it doesn't make it any more suitable for GUI programming, which is why we still use C++ at work.
06:14:00 <Sindriava> kuribas: GUI programming sucks in general, because GUI is very different from the way imperative programming is.
06:14:38 <Sindriava> kuribas: Usually, GUI toolkits incur a lot of overhead from their own event loops and UI designers and whatnot
06:14:39 <erisco> data binding
06:15:12 <bennofs> kuribas: there's also https://github.com/creichert/hsqmlstocqt for an application written with hsqml
06:15:34 <Sindriava> erisco: I've only seen data binding gaining traction on the web (and sometimes mobile), sadly :(
06:16:25 <kuribas> wxHaskell is ok, if I don't mind implementing what is missing, and not counting on much support.
06:16:33 <Sindriava> kuribas: I'd argue that many properties of Haskell make it much more suitable for GUI programming as a language. Still, it depends on what library you want to use.
06:16:37 <Sindriava> kuribas: What's your use case?
06:16:59 <kuribas> Sindriava: I am making a font editor.
06:17:20 <Sindriava> kuribas: I see. For a specific platform, or multiplatform?
06:17:46 <kuribas> multiplatform
06:17:53 <kuribas> ideally
06:18:18 <Tuplanolla> I've also contemplated making an animated vector graphics editor.
06:19:07 <Sindriava> kuribas: Then you might want to take a look at other options than wxWidgets, I think. You're going to be needing a *lot* of customization options with your framework, and I've never heard of wxWidgets as particularly customizable
06:19:28 <Tuplanolla> My requirements are quite basic, so any usable toolkit should do.
06:19:31 <kuribas> Sindriava: in what way?
06:19:58 <Sindriava> kuribas: Well, I sincerely doubt that any GUI framework offers widgets that I'd expect in a font editor
06:20:18 <Sindriava> kuribas: Depending on how complex you want it to be, of course.
06:20:28 <Sindriava> kuribas: I think that as far as multiplatform goes, Qt seems to be the king of that particular hill. GTK being in close second
06:20:47 <kuribas> Sindriava: wxWidgets has bezier curves drawing routines
06:21:11 <Sindriava> kuribas: As I said, it depends on what features you want to have.
06:21:41 <R0b0t1> It may not matter
06:21:41 <kuribas> Sindriava: could you give an example of what is not possible when using wxWidgets?
06:21:51 <Sindriava> kuribas: No.
06:21:57 <R0b0t1> Personally it'd be more important to find a good vector graphics library to base your editor off of
06:22:08 <kuribas> R0b0t1: I am writing one...
06:22:30 <Sindriava> kuribas: I don't use wxWidgets. I'm saying that you might want to keep in mind what kind of widgets you'll require when choosing a framework
06:22:43 <Sindriava> kuribas: As for Haskell, GTK seems to have the best support from what I've heard.
06:23:18 <R0b0t1> ^
06:23:34 <kuribas> Sindriava: is qt native on all platforms?  Because GTK looks good on linux, but not on other platforms.
06:24:09 <Sindriava> kuribas: GTK just requires a bit work to look native, which many programmers don't seem to go through.
06:24:14 <kuribas> R0b0t1: https://hackage.haskell.org/package/cubicbezier
06:24:23 <Sindriava> kuribas: But Qt does look native on Linux, Windows and OSX, I can confirm that
06:24:27 <Tuplanolla> Are you going to restrict yourself to cubic curves, kuribas?
06:24:51 <Tuplanolla> I hate it when graphics programs do that.
06:24:57 <kuribas> Tuplanolla: cubic curves and hobby splines.
06:25:18 <kuribas> Tuplanolla: Do you use NURBS?
06:25:20 <tulcod> kuribas: i think the most Haskell-style approach to GUI dev would be threepenny-gui with reactive-banana
06:25:35 <tulcod> kuribas: but yes the state of haskell GUI dev isn't great
06:26:04 <Tuplanolla> Sometimes, kuribas.
06:27:00 <kuribas> Tuplanolla: what advantage would NURBS have over cubic beziers in a vector drawing program?
06:28:34 <Tuplanolla> They're sometimes more convenient. You get the implementation for higher orders for free anyway.
06:29:31 <kuribas> Tuplanolla: I'll be supporting hobby splines, that's novel at least :)
06:29:58 <Tuplanolla> How are you planning to deal with floating-point errors?
06:31:13 <kuribas> Tuplanolla: testing mainly.  Trying to test corner cases and singular curves.
06:31:59 <hamishmack> kuribas: Check out http://ianwookim.org/hoodle/
06:32:09 <Tuplanolla> Well, good luck with that. Here are some preliminaries: https://www.cs.berkeley.edu/~wkahan/
06:34:16 <kuribas> Tuplanolla: I've found the first part of "Numerical Methods for Scientists and Engineers" very instructive.
06:34:41 <Tuplanolla> I think it's not pessimistic enough.
06:38:11 <mek42> kuribas: That is not the Boaz text, is it?
06:38:28 <kuribas> mek42: what's Boaz?
06:39:16 * hackagebot moesocks 0.1.0.23 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.23 (JinjingWang)
06:40:04 <siwica> How can I get descriptions of a datatype using ghci?
06:40:27 <mek42> kuribas: I'm misremembering one of my "joys" from college: http://www.amazon.com/Mathematical-Methods-Physical-Sciences-Mary/dp/0471198269
06:40:38 <Tuplanolla> :i Functor
06:40:46 <Tuplanolla> Like that, siwica.
06:40:53 <Sindriava> @info Functor
06:40:54 <lambdabot> Functor
06:41:12 <siwica> Tuplanolla: awesome, thanks!
06:41:18 <kuribas> mek42: ah, no it's this one: http://www.amazon.com/Numerical-Methods-Scientists-Engineers-Mathematics/dp/0486652416/ref=sr_1_2?ie=UTF8&qid=1440250841&sr=8-2&keywords=Numerical+methods+scientists
06:42:46 <erisco> whats available for continuous integration servers?
06:43:20 <mniip> is ListT (Writer e) lawful?
06:43:27 <Tuplanolla> The nice thing about Bézier curves is that you can use them with rational numbers, kuribas.
06:43:32 <kuribas> Tuplanolla: I am using existing algorithms which are supposed to be stable (bezier clipping).  For polynomial roots I just copy existing algorithms, because if I came up with my own, it would be full of numerical errors.
06:44:22 <kuribas> Tuplanolla: unfortunatly not intersections.
06:44:34 <Tuplanolla> Of course some operations require solving systems that don't have solutions in closed form, so you need to compromise there, but you should generally keep all input data exact and avoid floating-point numbers whenever possible.
06:45:17 <mniip> hmm
06:45:22 <mniip> Writer is not commutative
06:45:30 <mniip> crap
06:45:40 <Tuplanolla> I know you're not milling fonts out of titanium and putting them into critical machinery, but you should still take data integrity seriously.
06:47:36 <kuribas> Tuplanolla: what does exact even mean?  There would always be some error, since for example the mouse position has limited precision.
06:47:59 <Tuplanolla> That's when you'd use snapping.
06:52:07 <bennofs> kuribas: mouse position has limited, but fixed precision ime. so _floating_ point is probably not adequate
06:53:05 <kuribas> bennofs: but mouse position must be scaled and translated by the current viewport, so it will become a floating point number.
06:53:21 <bennofs> kuribas: or a Rational number, which is exact :)
06:55:11 <kuribas> bennofs: Double has enough significant digits for it not to matter.  
06:55:19 <kuribas> And it's fast, unlike Rational.
06:55:31 <bennofs> hmm, ok
06:55:36 <Tuplanolla> Inkscape has shown us otherwise...
06:56:36 <kuribas> Tuplanolla: explain?
06:58:44 <jmcarthur> mniip: even if using it with a commutative monoid?
07:00:59 <Tuplanolla> It's riddled with numerical problems and tends to corrupt user data. It's so bad many illustrators for Wikipedia for example prefer writing SVG code by hand. Others use various programming languages to avoid having to deal with the flaky graphics tools we have.
07:01:07 <Tuplanolla> Here's one example: https://en.wikipedia.org/wiki/User:LucasVB/Gallery
07:01:59 <Baughn> "[ERROR] : Main: caught (and ignoring) Enum.toEnum{Word8}: tag (8216) is outside of bounds (0,255)".
07:02:12 <Tuplanolla> What we really need is exact cad tools for artists.
07:02:16 <Baughn> I find that getting lambdabot to work is hard..
07:02:22 <Baughn> > 42 -- This one works, right?
07:02:24 <lambdabot>  42
07:03:27 <jmcarthur> mniip: if you use one of the "ListT Done Right" implementations then the monad you are transforming is not required to be commutatve
07:04:48 <jmcarthur> mniip: newtype ListT m a = ListT (m (ListF m a)); data ListF m a = Nil | Cons a (ListT m a)
07:05:36 <mniip> jmcarthur, which helps how
07:05:46 <mniip> oh
07:05:50 <kuribas> Tuplanolla: my editor is designed around metafont and an equation solver.  Maybe I should make it a general cad tool...
07:05:52 <mniip> we have a monad at every cons
07:06:10 <mniip> jmcarthur, I really just have ([a], e)
07:06:34 <mniip> well an isomorphic structure, but whatever
07:07:00 <kuribas> Tuplanolla: but let's continue in #haskell-blah
07:07:00 <Tuplanolla> I don't know what you should do, but collectively we need less well-intentioned idiots making fundamentally flawed tools.
07:07:14 <mniip> the applicative instance would then be
07:07:30 <mniip> ([a -> b], e) -> ([a], e) -> ([b], e)
07:07:57 <mniip> so obviously the 'e' parts need some sort of monoid
07:08:09 <mniip> need to be*
07:08:28 <kuribas> Tuplanolla: Well I wanted to write this program, since font editors suck so much.
07:08:58 <mniip> the question is how to make ([a], e) -> (a -> ([b], e)) -> ([b], e) work
07:09:07 <mniip> so that 'ap' behaves appropriately
07:09:11 <Tuplanolla> Well, I wish you the best of luck on that endeavor.
07:10:24 <mniip> well by parametricity we can't do anything but map the function over the list
07:10:26 <mniip> so
07:10:48 <mniip> ([([b], e)], e) -> ([b], e)
07:11:02 <mniip> uhh that's basically join
07:11:17 <mniip> yeah, that's the question
07:11:24 <mniip> how do you join ListT Writer
07:14:51 <jmcarthur_> mniip: apparently i was disconnected. what was the last thing you saw me write?
07:15:10 <mniip> [16:01:39] <jmcarthur> mniip: newtype ListT m a = ListT (m (ListF m a)); data ListF m a = Nil | Cons a (ListT m a)
07:15:31 <jmcarthur_> ah okay. the only other thing i said was:
07:15:32 <jmcarthur_> mniip: a couple implementations on hackage: http://hackage.haskell.org/package/list-t-0.4.5.1/docs/ListT.html http://hackage.haskell.org/package/pipes-4.1.6/docs/Pipes.html#g:5
07:16:04 <jmcarthur_> mniip: i am not sure i understand your question about joining
07:18:13 <mniip> jmcarthur_, :O
07:19:20 <mniip> > ListT (WriterT (Identity ([id], "foo"))) <*> ListT (WriterT (Identity ([1,2,3], "bar")))
07:19:22 <lambdabot>  Not in scope: data constructor ‘ListT’Not in scope: data constructor ‘ListT’
07:19:29 <mniip> aw screw you
07:19:42 <mniip> anyway
07:19:54 <mniip> <*> yields ([1,2,3], "foobar")
07:20:03 <mniip> `ap` yields ([1,2,3], "foobarbarbar")
07:22:02 <jmcarthur_> i basically never use the transformers implementation of ListT, so i can say whether this is expected. it probably is
07:22:12 <jmcarthur_> *can't say
07:26:06 <mniip> wow
07:26:13 <mniip> the documentation of ListT is wrong
07:26:36 <mniip> not only it needs a commutative monad, but also a monad that doesn't care about repetition
07:27:25 <mniip> if we were to make CounterT = StateT Int
07:28:16 <mniip> <*> executes the counter action once, `ap` executes it as many times as there are functions
07:29:19 * hackagebot gtk3 0.14.1 - Binding to the Gtk+ 3 graphical user interface library  https://hackage.haskell.org/package/gtk3-0.14.1 (HamishMackenzie)
07:30:54 <catgocat> What is a simple way to parse html tags?
07:31:05 <catgocat> I want to get the contents of a div that has class "example"
07:31:24 <catgocat> I tried tagsoup, but it is so complicated to loop the entire list of tags
07:31:31 <catgocat> specially when matching multiple tags
07:34:19 * hackagebot hspec-expectations-pretty-diff 0.7.2.1 - Catchy combinators for HUnit  https://hackage.haskell.org/package/hspec-expectations-pretty-diff-0.7.2.1 (myfreeweb)
07:37:59 <pavonia> catgocat: Have you tried tagsoup's tree module? It's quite easy to find certain tags with it in conjunction with list comprehensions
07:38:12 <zipper> Hey am I missing something here:
07:38:21 <zipper> > dropWhile (==' ') ": /.stack/snapshots"
07:38:22 <lambdabot>  ": /.stack/snapshots"
07:38:33 <catgocat> pavonia: I can't find a good explanation of how to use it
07:38:37 <catgocat> I am a haskell newbie, so yeah
07:38:37 <zipper> I want "/.stack/snapshots"
07:39:05 <zipper> Shouldn't `dropWhile (==' ')` work
07:39:08 <StoneToad> zipper: note that ':' != ' ', so the condition is false right away
07:39:30 <StoneToad> what you want is to drop until after the first space
07:39:38 <StoneToad> probably?
07:39:39 <srhb> zipper: You want filter, it seems.
07:39:52 <StoneToad> isn't there a splitAt in the library?
07:39:53 <zipper> :t filter
07:39:55 <lambdabot> (a -> Bool) -> [a] -> [a]
07:40:07 <zipper> > filter (==' ') ": /.stack/snapshots"
07:40:09 <lambdabot>  " "
07:40:09 <srhb> Oh, you want the colon gone too. Err.
07:40:21 <StoneToad> oh, it's at a position for split at
07:40:23 <zipper> > filter (/=' ') ": /.stack/snapshots"
07:40:26 <lambdabot>  ":/.stack/snapshots"
07:40:45 <zipper> I can filter then drop the colon I think
07:41:09 <StoneToad> that will drop all the spaces though
07:41:28 <StoneToad> so "/.stack/dir with spaces/" will get the spaces dropped
07:41:37 <indiagreen> > drop 1 $ dropWhile (not . isSpace) ": /.stack/snapshots"
07:41:39 <jmcarthur_> mniip: to be fair, ap and (<*>) are not exactly required to be the same
07:41:41 <srhb> Yes. I'm not sure exactly what you're trying. If you want something reliable you probably want to create a real parser for those entries.
07:42:19 <jmcarthur_> mniip: (even though really i think they should be required to be the same)
07:42:30 <StoneToad> jmcarthur_: arn't they now?
07:42:54 <jmcarthur_> ah, they are now
07:43:30 <jmcarthur_> since AMP i guess
07:43:47 <pavonia> catgocat: It has an example "[x | x@(TagBranch "a" _ _) <- universeTree tree]" that traverses all nodes in the tree. You only need adjust the pattern and add a condition for checking the attribute list for the right class
07:48:23 <Gurkenglas> zipper, why not just drop 2?
07:55:19 <jmcarthur_> zipper: how about Data.List.stripPrefix ?
07:55:29 <jmcarthur_> :t stripPrefix
07:55:31 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
07:55:54 <jmcarthur_> > stripPrefix ": " ": /.stack/snapshots"
07:55:56 <lambdabot>  Just "/.stack/snapshots"
08:04:18 <the_2nd> I have a list of list of A
08:04:21 * hackagebot cabal-debian 4.31.4 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.31.4 (DavidFox)
08:04:26 <the_2nd> [[A]]
08:04:41 <the_2nd> how can I append each list to the other? So I have a long list of all
08:04:55 <the_2nd> I tried foldl (++) [[A]]
08:06:21 <jmcarthur_> :t concat
08:06:22 <lambdabot> Foldable t => t [a] -> [a]
08:06:33 <jmcarthur_> not the most useful type, sorry
08:06:38 <jmcarthur_> :t concat :: [[a]] -> [a]
08:06:40 <lambdabot> [[a]] -> [a]
08:06:56 <jmcarthur_> s/useful/clear for beginners/
08:07:42 <the_2nd> jmcarthur_, works, thanks
08:07:51 <the_2nd> whats wrong with foldl then, tho?
08:08:01 <jmcarthur_> let's work it out
08:08:04 <jmcarthur_> :t foldl (++)
08:08:05 <lambdabot> Foldable t => [a] -> t [a] -> [a]
08:08:11 <jmcarthur_> ugh, sorry again
08:08:16 <jmcarthur_> i love foldable, but it's not good for teaching
08:08:29 <jmcarthur_> :t foldl (++) :: [a] -> [[a]] -> [a]
08:08:31 <lambdabot> [a] -> [[a]] -> [a]
08:08:35 <jmcarthur_> so the types are working so far
08:08:48 <jmcarthur_> the next argument is the initial state of the accumulator
08:08:56 <jmcarthur_> :t foldl (++) [] :: [[a]] -> [a]
08:08:57 <lambdabot> [[a]] -> [a]
08:09:01 <jmcarthur_> still good
08:09:12 <jmcarthur_> > foldl (++) [] ["foo", "bar", "baz"]
08:09:14 <lambdabot>  "foobarbaz"
08:09:18 <jmcarthur_> it actually does work
08:09:26 <jmcarthur_> however, there is a problem not apparent from here
08:09:46 <jmcarthur_> > foldl (++) [] (repeat "blah")
08:09:50 <lambdabot>  mueval-core: Time limit exceeded
08:10:11 <jmcarthur_> i have a big reveal to make, but i want to make sure you understand why that timed out
08:10:36 <jmcarthur_> btw:
08:10:38 <jmcarthur_> > repeat "blah"
08:10:40 <lambdabot>  ["blah","blah","blah","blah","blah","blah","blah","blah","blah","blah","blah...
08:10:47 <jmcarthur_> it's just an infinite list of "blah"
08:11:27 <the_2nd> but concav repeat "blah" times out aswell, right?
08:11:28 <tulcod> cabal has build flags. but can i also feed (numerical) values into my code at build time? specifically, I want to be able to configure test parameters
08:11:35 <catgocat> Why does this trigger an error =>     msgNum <- fmap fromIntegral $ getMessages uid
08:11:39 <jmcarthur_> the_2nd: nope! the concat version will work
08:11:45 <catgocat> getMessages has type String -> IO Integer
08:11:46 <jmcarthur_> > concat (repeat "blah")
08:11:48 <lambdabot>  "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahbla...
08:12:08 <jmcarthur_> the_2nd: concat will generate an infinite list. foldl will just make the stack grow forever.
08:12:28 <jmcarthur_> the_2nd: if we use foldr instead of foldl, we get the same behavior as concat
08:12:34 <jmcarthur_> > foldr (++) [] (repeat "blah")
08:12:36 <lambdabot>  "blahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahblahbla...
08:12:47 <catgocat> nevermind
08:12:51 <catgocat> found the error
08:12:55 <catgocat> wrong type signature
08:13:18 <jmcarthur_> the_2nd: this is because when you express this as a right fold (like concat does) each element of the resulting list can be generated before continuing with the rest of the list.
08:13:22 <ansible1> so I installed ghc from source with make install.  is there a make remove/uninstall/whatever?
08:13:29 <tulcod> catgocat: you might be looking for <$>
08:13:33 <jmcarthur_> @src foldr
08:13:34 <lambdabot> foldr f z []     = z
08:13:34 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:13:48 <jmcarthur_> the_2nd: the "trick" is in the second line of that definition ^^
08:13:51 <ansible1> er actually not from source, from the ghc binary dlded from the site
08:14:20 <jmcarthur_> the_2nd: 'f' here is (++). (++) only forces its first argument until you have consumed enough of the result to need its second argument
08:14:22 * hackagebot transient 0.1.0.3 - A monad for extensible effects and primitives for unrestricted composability of applications  https://hackage.haskell.org/package/transient-0.1.0.3 (AlbertoCorona)
08:15:11 <hiptobecubic_> jmcarthur_, (++) doesn't force anything, does it? Otherwise  (repeat "foo") ++ (repeat "bar") would time out
08:15:26 <hiptobecubic_> > repeat "foo" ++ ["bar"]
08:15:29 <lambdabot>  ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","fo...
08:15:43 <jmcarthur_> hiptobecubic_: not deeply, but it does at least have to force the first argument to WHNF to do anything
08:16:04 <tulcod> > (repeat "foo") ++ undefined
08:16:06 <lambdabot>  ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","fo...
08:21:21 <hexagoxel> tulcod: use --ghc-options to give -D bindings to use with CPP ?
08:21:52 <tulcod> hexagoxel: can you give an example? because i can't see how you can use that for anything more than boolean flags
08:21:56 <ansible1> I installed a ghc binary with make install.  is there any uninstall option?
08:23:57 <hexagoxel> but the CPP macros are textual replacement, so -DMYVALUE=13 should give you the `13` literal in the haskell source, right?
08:24:19 <tulcod> hexagoxel: oh, does it? let me try! :)
08:25:14 <tulcod> hexagoxel: that doesn't seem to work
08:25:57 <tulcod> hexagoxel: test.hs:1:14: Not in scope: data constructor MYVALUE
08:26:09 <tulcod> where test.hs is the following file: main = print MYVALUE
08:26:19 <tulcod> and I ran "ghc test.hs -DMYVALUE=13"
08:28:27 <tulcod> hexagoxel: sorry. i was missing the -cpp flag
08:28:40 <tulcod> hexagoxel: it works fine if compiled as "ghc test.hs -DMYVALUE=13 -cpp"
08:29:18 <phaazon> ouais voila
08:29:20 <phaazon> c’est /win show
08:29:25 <phaazon> oops
08:29:59 <hexagoxel> tulcod: or {-# LANGUAGE CPP #-}
08:30:16 <tulcod> :)
08:41:14 <kqr> does anyone here happen to be familiar with namespaces in heist? if I use a namespace, it complains that the apply splice is not bound, and if I don't use namespaces it just works. what gives? I'd like to use namespaces...
08:42:01 <kqr> surprisingly little documentation/tutorial material on heist – especially namespaces which were added just a year ago
08:53:48 <the_2nd> any guide for properly creating libraries? package naming/ folder structure etc.
08:56:35 <mniip> ooh
08:56:50 <mniip> 7.10.2 appeared in the portage tree
08:57:28 <mniip> did 7.10 include Applicative => Monad already?
08:59:15 <liste> yeah
09:03:42 <RageYL> can anyone help me with the signature of this function: filterNull = filter (not . null)
09:03:58 <RageYL> for me it should be something like (Iterable a) => a -> a
09:04:11 <liste> there's no Iterable
09:04:16 <Gurkenglas> :t filter
09:04:18 <lambdabot> (a -> Bool) -> [a] -> [a]
09:04:27 <RageYL> in ghci it say something about foldable
09:04:36 <RageYL> but i can't make it works
09:04:41 <liste> :t null
09:04:43 <lambdabot> Foldable t => t a -> Bool
09:04:56 <liste> lists are Foldable
09:05:05 <mniip> is there some sort of comonoid class
09:05:18 <liste> mniip it's useless in Haskell
09:05:25 <mniip> it is
09:05:36 <liste> a -> () and a -> (a, a)
09:05:40 <mniip> no
09:05:43 <mniip> not that
09:05:54 <mniip> I mean a typeclass identical to Monoid
09:06:01 <mniip> but co- in some way
09:06:06 <liste> it is
09:06:30 <liste> just flip the arrows
09:06:40 <mniip> I mean I have some generic structure
09:06:46 <mniip> a `mappend` b `mappend` c
09:06:50 <liste> you need some uncurrying tho
09:07:10 <mniip> now I want to extend it to a different kind of mappend
09:07:25 <mniip> a `mappend` (b `comappend` b' `comappend` b'') `mappend` c
09:07:35 <mniip> if that makes sense
09:09:36 <Gurkenglas> How did you come to want that?
09:09:51 <liste> do you want a typeclass with two binary operators?
09:09:57 <mniip> yes
09:10:03 <mniip> preferably one that builds on top of Monoid
09:11:22 <mniip> Gurkenglas, think about Writer
09:11:59 <liste> seminearring?
09:12:51 <mniip> instance Applicative ((,) w) where pure x = (x, ???); (f, x) <*> (k, y) = (f k, x ??? y)
09:13:09 <mniip> the first ??? is some identity element, and the second ??? is an associative operation
09:13:15 <kqr> if I'm writing code inside an "EitherT [String] IO a", how can I append to the strings that already exist in the Left value?
09:13:20 <mniip> Monoid comes to mind, so you slap a Monoid w => on that
09:13:27 <kqr> uh
09:13:31 <kqr> let me formulate myself more clearly
09:13:35 <mniip> through similar reasoning I deduced a need for a second operation
09:13:40 <kqr> I want to add a string to the list of Left strings
09:13:41 <Gurkenglas> (Your pairs are flipped, but go on)
09:13:57 <kqr> with the "left" function from either I can simply overwrite that list, which is not what I want
09:13:57 <Myrl> mniip: How the hell do you survive with Gentoo + Haskell
09:14:06 <mniip> what's the issue
09:14:14 <Myrl> mniip: Everything's the issue.
09:14:18 <Myrl> mniip: Outdated packages, etc. etc.
09:14:27 * hackagebot streaming 0.1.0.7 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.7 (MichaelThompson)
09:14:44 <Myrl> mniip: I decided to just nuke my Haskell environment and downloaded stack.
09:14:56 <Gurkenglas> kqr, ordinarily any Left value ends the whole calculation, there is no point at which to add further Strings. If you want to continue the computation afterwards, use WriterT
09:15:00 <mniip> I have 2 ghcs
09:15:08 <mniip> one from portage, one from git
09:15:52 <kqr> Gurkenglas, haha, yeah, that's what I'd expect too. heist keeps surprising me
09:16:28 <kqr> Gurkenglas, the default (perhaps only?) monad you do your stuff in there is the EitherT [String] IO a monad, and it seems as though it collects errors in the [String], with one string per error
09:16:52 <Myrl> mniip: I decided to taint gentoo with binaries. :|
09:17:26 <Gurkenglas> Guessing at its internals, either a single error already is a list of Strings, or it internally uses WriterT and at the end returns all errors in a Left, discarding the result. I find the second option unlikely.
09:17:59 <kqr> I guess that's possible
09:19:08 <Gurkenglas> Looking at the source, ah.
09:19:28 <Gurkenglas> allErrors :: [Either String (TPath, v)] -> EitherT [String] IO (HashMap TPath v)
09:19:54 <Gurkenglas> It does many things, returns all errors if there's any, or returns all results if there are no errors.
09:20:10 <kqr> hm
09:20:19 <Gurkenglas> (Meaning it effectively does internal WriterT)
09:20:30 <kqr> yeah that's what it looked like
09:21:47 <kqr> oh well, that helped. thanks
09:21:58 <jgcoded> When are we going to get hoogle.com?
09:22:13 <Gurkenglas> Although the author blundered on allErrors, it should return Either [String] (HashMap TPath v), without involving IO.
09:29:02 <Crypto-dmtized> Does anybody know about the exploit code for stagefright android?
09:29:58 <liste> Crypto-dmtized that's off-topic here
09:30:26 <Crypto-dmtized> O ok.
09:41:03 <mniip> hmm
09:43:07 <lambdafan> I'm looking for a swap function, but for Map. so instead of (a,b) -> (b,a), I'm looking for Map k a -> Map a k. I noticed I can do this with a few functions from Data.Map.Strict but I'm wondering if there's a better way than zip,keys,values
09:44:26 <Intolerable> what should happen w/ key collisions?
09:44:30 <kadoban> lambdafan: I imagine there'd be at least a few variatons required for that, so it's probably better to use the primitives yourself. (Like, what do you want to happen with repeated values, which would then become repeated keys)
09:44:44 <indiagreen> lambdafan: I don't think there's a better way than “fromList . map swap . toList”
09:44:50 <mada> that would also require Ord on a, correct?
09:45:29 <lambdafan> yeah a is a Vector3, I think that has an Ord instance let me check
09:46:56 <lambdafan> crap Vector3 has Eq and Num instance but not Ord
09:48:18 <lambdafan> wait a minute, a will be a Double. I'm computing distances between vectors duh
09:49:00 <mada> merely out of curiosity, but is key-ing a Map by doubles a good idea?
09:49:26 <lambdafan> mada, I'm looking for a cheap way to sort these doubles
09:49:29 * hackagebot second-transfer 0.6.1.0 - Second Transfer HTTP/2 web server  https://hackage.haskell.org/package/second-transfer-0.6.1.0 (dsign)
09:49:31 * hackagebot glue 0.1.3 - Make better services.  https://hackage.haskell.org/package/glue-0.1.3 (seanparsons)
09:50:01 <lambdafan> if they are a key in a Map, it gets sorted upon insert.
09:50:01 <mada> lambdafan: yeah I mean in a general sense. Could it cause any issues? If you needed access/lookup
09:50:49 <exio4> mada: I would use fixed precision integers or rationals there 
09:50:51 <lambdafan> mada, yeah I need to think on that, I think I only need the smallest value in the Map, but that value could change. 
09:51:18 <lambdafan> mada, so I was looking for a way to always have the smallest value as the first value in the map
09:51:23 <monochrom> the general sense consists of two conflicting use cases and therefore two opposite answers. they are "yes" and "no".
09:52:53 <lambdafan> monochrom : Is my thinking muddled here, could you elucidate?
09:53:45 <monochrom> one use case is "I consider 1 and 1.001 to be different. they really come from different sources." then you can use them as keys.
09:54:02 <mada> to maintain order, I don't think there would be any issues. To actually key values by doubles, and make lookups on them, I'd imagine could be problematic depending on the source of your keys-to-lookup
09:54:28 <monochrom> the other use case is "I consider 1 and 1.001 to be equivalent. they come from equivalent sources, just with difference in rounding etc". then you can't use them as keys.
09:54:30 * hackagebot react-flux 0.9.1 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-0.9.1 (JohnLenz)
09:54:52 <lambdafan> monochrom : I need the first use case
09:55:02 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
10:00:21 <mniip> is there some typeclass for obtaining values out of container-esque covariant functors via natural transformations?
10:01:08 <mniip> f a -> Maybe a
10:02:35 <monochrom> there used to be. (the "edison" library.) but died of no interest
10:03:17 <nshepperd> even in the second use case a Map could be of use, I think
10:03:36 <nshepperd> as you can at least efficient find the nearest key to a query point
10:12:51 <RyanGlScott> What is the ConstrainedClassMethods extension?
10:13:17 <athan> :o
10:19:26 <liste> I'd guess it would enable constraints in class methods
10:20:10 <liste> @let class Foo b where foo :: Monoid a => a -> b
10:20:12 <lambdabot>  Defined.
10:21:01 <liste> @undefine
10:21:01 <lambdabot> Undefined.
10:21:10 <liste> @let class Foo b where foo :: Foldable a => a -> b
10:21:12 <lambdabot>  .L.hs:148:30:
10:21:12 <lambdabot>      Expecting one more argument to ‘a’
10:21:12 <lambdabot>      Expected a type, but ‘a’ has kind ‘* -> *’
10:21:31 <liste> @let class Foo b where foo :: Foldable f => f a -> b
10:21:32 <lambdabot>  Defined.
10:21:40 <liste> @let instance Foo Int where foo = length
10:21:42 <lambdabot>  Defined.
10:21:50 <liste> foo [1, 2, 3]
10:21:55 <liste> > foo [1, 2, 3]
10:21:58 <lambdabot>      No instance for (Show a0)
10:21:58 <lambdabot>        arising from a use of ‘show_M235871449384195115621403’
10:21:58 <lambdabot>      The type variable ‘a0’ is ambiguous
10:22:10 <liste> > (foo [1, 2, 3]) :: Int
10:22:14 <lambdabot>  3
10:31:17 <zyxoas> Yo, my peoples!
10:32:17 <zyxoas> Doctest seems nice. Super awesome. But does anyone know what the command-line options for it are? Using --help is not very helpful, ironically (it just lists --help and --version).
10:34:26 <d0mR3ps> help msg
10:34:37 <d0mR3ps> oops
10:36:04 <cads> hey, has anyone given thought to the problem of automatically managing large numbers of tabs in the browser?
10:36:32 <cads> I open huge numbers of tabs, and I'm not always good about closing them when I'd done with them
10:37:16 <cads> I'm a tab hoarder - I could go through my tabs and find wikipedia articles I looked at for a few minutes 3 days ago
10:37:16 <rom1504> alt-f4
10:37:29 <cads> there are too many
10:37:31 <zyxoas> Ah! Scratch that! Apparently it takes GHC options.
10:37:37 <rom1504> alt-f4 closes all your tabs
10:37:45 <zyxoas> I just wonder whta does ""-isrc"" mean in GHC??
10:37:46 <cads> right that is unacceptable
10:37:51 <cads> ;)
10:38:24 <cads> I need help quickly deciding which tabs need to close and which tabs are still useful
10:38:30 <rrbm238> solution: never close any tabs
10:38:47 <geekosaur> zyxoas, adds "src" to the search path for Haskell source files
10:39:06 <geekosaur> -i by itself clears the search path, -iDIR (NO SPACE!) adds DIR to the path
10:39:11 <Cale> cads: If you can't remember any important tabs, probably none of them are important
10:39:20 <glguy> zyxoas: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html#search-path
10:39:34 <rom1504> my solution : if you changed tab, the old ones were probably not useful anymore, so you can close everything
10:40:11 <rom1504> it's not like web pages disapear or browsers don't have an history anyway
10:40:15 <qubitnerd> you could possibly do something likewrite a plugin to  put a tab into a "temp" group when you know you wont be needing it for long , the temp group peridoicaly removes all its tabs 
10:40:30 <Tuplanolla> I have this problem too.
10:40:33 <qubitnerd> *and make the temp group remove all its tabs
10:40:46 <Cale> You can drag out the one or two tabs you want into a new window, and then close the original one
10:40:48 <zyxoas> Thanks, geekosaur
10:40:49 <Tuplanolla> I can't close certain tabs, because that'd make me feel like I'm dismissing the important work they represent.
10:41:12 <Tuplanolla> "I need to read this soon, so I can't close it..."
10:41:21 <qubitnerd> my tabs usually increase when i visit reddit 
10:41:33 * geekosaur keeps reference tabs open, tabs for "look at me sometime" get imported into a "Looky" notebook in Evernote
10:41:42 <geekosaur> other tabs get closed
10:41:47 <zyxoas> Thanks glguy Makes a bit more sense now. :-)
10:43:08 <Tuplanolla> Tabs are not even the biggest problem. I have way too many papers open.
10:43:16 <Tuplanolla> I feel guilt and shame whenever I come back to them and the reader has been swapped out.
10:44:43 <zomg> You should try Tab Snooze
10:44:55 <zomg> you can set tabs on "snooze" for a certain time period, and it'll pop them back up after
10:45:03 <zomg> nice to have a sort of a reminder for something like that
10:45:45 * monochrom predicts that that will simply transform the original problem into this new problem: "I have too many reminders and too frequently"
10:46:36 <zomg> Possibly :D
10:46:43 <Tuplanolla> What a painful existence.
10:46:46 <zomg> I sometimes just snooze something only to snooze it again when it pops back...
10:48:22 <monochrom> do not use tabs for "this looks interesting, I want to read it one day".
10:48:43 <monochrom> bookmark it. close the tab.
10:49:00 <zomg> yeah
10:49:08 <zomg> but the result is the same... will never look at it
10:49:10 <zomg> :P
10:49:26 <monochrom> it takes up much less computer memory
10:49:38 <zomg> I have some docs and such where I keep things I'm working on, putting them on those tends to make me at least look at them
10:49:45 <zomg> but putting them anywhere else usually means I'll never look at it :D
10:50:04 * hackagebot ignore 0.1.0.0 - Handle ignore files of different VCSes  https://hackage.haskell.org/package/ignore-0.1.0.0 (AlexanderThiemann)
10:50:55 <kuribas> @hoogle Ordering -> Ordering
10:50:56 <lambdabot> Language.Haskell.TH.Syntax thenCmp :: Ordering -> Ordering -> Ordering
10:50:57 <lambdabot> Prelude id :: a -> a
10:50:57 <lambdabot> Data.Function id :: a -> a
10:52:44 <liste> wanna reverse it?
10:53:24 <kuribas> yes
11:01:15 <liste> how about Down?
11:02:01 <kuribas> :t down
11:02:03 <lambdabot>     Not in scope: ‘down’
11:02:03 <lambdabot>     Perhaps you meant data constructor ‘Down’ (imported from Data.Ord)
11:02:07 <kuribas> :t Down
11:02:07 <_di> how dows one solve dependency hell with stack? I try to use latest aeson package by specifying dep in .cabal file. when I do stack build I get  aeson: needed (>=0.9), latest is 0.9.0.1, but 0.8.0.2 found
11:02:08 <lambdabot> a -> Down a
11:02:15 <kqr> does anyone happen to know something about Turtle.Shell (and/or Control.Foldl)? in Turtle there is a function "ls :: FilePath -> Shell FilePath", where Shell is a FoldM IO. I'd like to write a function "Shell FilePath -> Shell (FilePath, Text)" where Text is read from the file at FilePath. does anyone have any idea on how to proceed?
11:03:49 <_di> I tried rm -rf ~/.cabal ~/.ghc and installing stack externally. didnt help. I also have globally installed ghc-mod, hasktags and other stuff with stack. could that interfere with project's stack sandbox somehow? 
11:04:37 <kqr> so basically what I need, I guess, is something along the lines of "(b -> m c) -> FoldM m a b -> FoldM m a c"? maybe?
11:05:02 <kqr> I might be doing it wrong though
11:07:09 <liste> kqr how about f act = do path <- act; file <- readFile path; return (path, file)
11:07:24 <cocreature> _di: there are basically two possibilities: 1. use a snapshot that contains the newer version of aeson and 2. put the version you need in extra-deps in your stack.yaml, so a line "- aeson-version" not that this way you might need to put a few more packages in extra-deps than just aeson itself since it might depend on other stuff that is also not in your snapshot
11:07:43 <kqr> liste, I could certainly do that, but I have a feeling you're meant to stay in the streaming Shell as much as possible
11:07:49 <kqr> liste, and convert to list as late as possible
11:10:06 * hackagebot lzma-clib 5.2.1 - liblzma C library and headers for use by LZMA bindings  https://hackage.haskell.org/package/lzma-clib-5.2.1 (HerbertValerioRiedel)
11:12:23 <kqr> liste, oh sorry. Shell is a monad!
11:12:33 <kqr> liste, I had missed that. well that might work then. cheers
11:13:07 <bennofs> kqr: FoldM IO is a monad???
11:14:53 <kqr> bennofs, Shell has a monad instance, not exactly sure about the connection to FoldM
11:14:59 <bennofs> ah
11:15:00 <kqr> bennofs, https://hackage.haskell.org/package/turtle-1.2.1/docs/Turtle-Shell.html#g:1
11:15:06 * hackagebot lzma 0.0.0.1 - LZMA/XZ compression and decompression  https://hackage.haskell.org/package/lzma-0.0.0.1 (HerbertValerioRiedel)
11:15:12 <kqr> maybe that's just the unwrapped reader monad
11:15:15 <kqr> no idea
11:15:34 <kqr> my wizard hat isn't many inches tall
11:15:34 <_di> cocreature: oh, indeed I checked https://www.stackage.org/lts-3.1 and there it is. 0.8.2. I had a wrong concept about stackage nightlies. I thought they somehow build latest versions of packages :) 
11:16:16 <cocreature> _di: 1. lts-3.1 is not a stackage nightly 2. I think the nightlies are snapshots of the stackage git repository or something like that not of hackage
11:16:50 <_di> cocreature: correct, but I tried https://www.stackage.org/nightly-2015-08-21 and it still has old aeson
11:20:06 * hackagebot tasty-hspec 1.1.1 - Hspec support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-hspec-1.1.1 (mitchellwrosen)
11:24:22 <geekosaur> since stackage is supposed to be self-consistent, I would imagine it uses old versions of packages when updates break other things in stackage
11:24:42 <geekosaur> until those other things are updated to work with the new version
11:25:14 <geekosaur> otherwise, there's not a whole lot of point in having stackage to begin with
11:26:14 <rohan> can you implement a dp solution in haskell based purely upon lists?
11:26:46 <bennofs> rohan: Vectors would probably be more useful for dp-style solutions
11:26:52 <rohan> eg: dp[i][j] = max(dp[i-1][j-1],dp[i],[j-1])
11:27:11 <_di> cocreature: newest aeson version conflicts a lot with stackage build plan :) seems I 'll have to stay with an old one. thanks a lot for your help.
11:27:36 <cocreature> _di: yw
11:27:41 <rohan> bennofs: i agree but if the recurrence relation has just the previous element as a relevant factor?
11:27:50 <bennofs> rohan: hmm, that could be possible
11:29:14 <artur_> Hi there, I have a silly beginner question about parsing user input from stdin: Is there a standard way to read integer strings and attempt to parse them, encapsualting the error? I'm thinking something of type :: String -> Maybe Integer.
11:29:17 <Hijiri> rohan: maybe use iterate with the recurrence?
11:29:41 <artur_> (Coming from C, I'm looking for an analogue of atoi())
11:30:09 <geekosaur> more like strtol() since atoi() never produces errors...
11:30:16 <geekosaur> @index readMay
11:30:16 <lambdabot> bzzt
11:30:18 <geekosaur> bah
11:30:19 <suppi> artur_, you can use reads
11:30:21 <rohan> Hijiri: yeah
11:31:10 <geekosaur> right, it's still hidden in the GHC hierarchy isn't it
11:31:17 <geekosaur> so reads
11:31:27 <liste> @index maybeRead
11:31:27 <lambdabot> bzzt
11:31:34 <artur_> suppi: I've tried read, but that errors on input "". I'll try seeing if I can get reads working :)
11:31:50 <Hijiri> artur_: reads, not read
11:32:00 <Hijiri> reads gives you a list of parses
11:32:09 <liste> > (reads "50") :: [Int]
11:32:11 <lambdabot>      Couldn't match type ‘(a0, String)’ with ‘Int’
11:32:11 <lambdabot>      Expected type: [Int]
11:32:11 <lambdabot>        Actual type: [(a0, String)]
11:32:15 <suppi> artur_, reads :: Read a => String -> [(a,String)]
11:32:19 <liste> > (reads "50") :: [(Int,String)]
11:32:22 <lambdabot>  [(50,"")]
11:32:46 <Hijiri> > reads "" :: [(Int, String)]
11:32:47 <indiagreen> :t readMaybe
11:32:47 <lambdabot>  []
11:32:48 <lambdabot> Not in scope: ‘readMaybe’
11:32:57 <indiagreen> @index readMaybe
11:32:57 <lambdabot> Text.Read
11:33:04 <indiagreen> artur_: ^
11:33:42 <artur_> indiagree, suppi: okay I'll try it out :)
11:40:12 <kqr> does the "cp" function in Turtle not copy directories?
11:40:42 <kqr> apparently not
11:42:44 <bennofs> kqr: cp does not copy dirs on command line either, unless you give -r as argument
11:43:11 <kqr> that's true
11:50:55 <zyxoas> > round 2.5
11:50:58 <lambdabot>  2
11:51:14 <liste> > round 3.5
11:51:18 <lambdabot>  mueval-core: Time limit exceeded
11:51:19 <zyxoas> Wait a second! WHy is "round 2.5" equal to 2??
11:51:25 <liste> > round 3.5
11:51:28 <lambdabot>  4
11:51:32 <liste> banker's rounding
11:51:40 <zyxoas> Dafuq??!!
11:51:46 <liste> evens out .5s
11:51:50 <liste> so that there's no bias
11:51:50 <tulcod> zyxoas: why are you so surprised?
11:51:51 <Zekka> Round to nearest even, right?
11:51:55 <Zekka> > round (-1.5)
11:51:58 <lambdabot>  -2
11:52:12 <zyxoas> That's not how we did it in school...
11:52:22 <liste> there's floor and ceil
11:52:24 <liste> if you want them
11:52:25 <tulcod> zyxoas: welcome to the real world
11:52:29 <frerich> zyxoas: What they don't usually tell you in school is that there's more than one way to round things.
11:52:38 <tulcod> zyxoas: protip: everything you learned is not *quite* right
11:52:42 <zyxoas> great.
11:52:48 <voidzero> 2.5 -> 2, but 3.5 -> 4?
11:52:51 <frerich> zyxoas: Welcome to the real ... damn, tulcod beat me to it!
11:52:51 <voidzero> i don't get it either
11:52:55 <tulcod> zyxoas: remember that story about how airplanes work, with air going faster on the top than on the bottom?
11:53:03 <voidzero> then again, i didn't really get this at school anyway
11:53:03 <tulcod> it's bullshit
11:53:07 <tulcod> and there are counterexamples of it, even
11:53:24 <frerich> voidzero: I know it as 'gaussian rounding'
11:53:38 <zyxoas> I was being facetious about school. You're taking it to the extreme, tulcod
11:53:41 <zyxoas> Haha.
11:54:03 <voidzero> > round (2.51)
11:54:06 <lambdabot>  3
11:54:14 <tulcod> > round (2.500000000001)
11:54:15 <lambdabot>  3
11:54:19 <tulcod> > round (2.50000000000000000000001)
11:54:20 <voidzero> well, floats gon' be floats anyway
11:54:20 <lambdabot>  2
11:54:26 <zyxoas> > floor 2.4
11:54:27 <zyxoas> > floor 2.4
11:54:29 <lambdabot>  2
11:54:29 <lambdabot>  2
11:54:30 <zyxoas> > floor 2.5
11:54:32 <lambdabot>  2
11:54:33 <zyxoas> > floor 2.6
11:54:34 <lambdabot>  2
11:54:43 <zyxoas> > ceil 2.5
11:54:45 <lambdabot>  Not in scope: ‘ceil’
11:54:47 <zyxoas> > ceil 2.4
11:54:48 <zyxoas> > ceil 2.6
11:54:49 <lambdabot>  Not in scope: ‘ceil’
11:54:49 <voidzero> ye ye
11:54:50 <lambdabot>  Not in scope: ‘ceil’
11:54:55 <liste> please stop
11:54:56 <SCHAAP137> > round 2.6
11:54:57 <lambdabot>  3
11:55:14 <frerich> http://mathematica.stackexchange.com/questions/2116/why-round-to-even-integers discusses why the 'Round' function in mathematica uses gaussian rounding, there are a few nice properties of this rounding method.
11:55:32 <voidzero> ah, thanks frerich 
11:55:52 <zyxoas> So, how do I do normal rounding?
11:55:58 <voidzero> https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
11:56:07 <liste> zyxoas define normal
11:56:17 <voidzero> "What Every Computer Scientist Should Know About Floating-Point Arithmetic"
11:57:00 <liste> voidzero then there was the one from the guy from Valve
11:57:02 <zyxoas> Round to nearest integer, why rounding 0.5 up (for positive numbers)?
11:57:15 <zyxoas> Round to nearest integer, with rounding 0.5 up (for positive numbers)?
11:57:21 <frerich> zyxoas: I suspect what you learnt is school is basically 'truncate . (+ 0.5)'?
11:57:37 <zyxoas> Looks right frerich
11:57:44 <voidzero> the thing we learned was that everything up from .5 should be 'ceil'
11:57:51 <voidzero> everything below 0.5 should be 'floor'
11:57:56 <voidzero> b
11:58:04 <liste> https://randomascii.wordpress.com/category/floating-point/ this one
11:58:06 <voidzero> but for me that was elementary school
12:00:08 <voidzero> liste, looks like that blog contains some fun reads
12:00:36 <voidzero> btw, there is also a lot on floats on youtube, fun to watch if you need to kill some time
12:01:08 <liste> float and unicode, two misunderstood beasts
12:01:54 <Gurkenglas> > truncate . (+0.5) $ -1.2
12:01:56 <lambdabot>  0
12:01:57 <zyxoas> Thanks frerich voidzero and liste
12:02:06 <Gurkenglas> I suspect you want floor . (+0.5)
12:02:17 <voidzero> zyxoas, you got it?
12:03:01 <voidzero> s/got/found/
12:04:05 <artur_> indiagree, suppi: I got it working, thank you very much!
12:04:15 <suppi> artur_, no prob :)
12:13:53 <sebleblanc> Here is a sample of code: https://dpaste.de/Xp2N     Instead of referring to a hard-coded string, is there a way for the function showName to refer to a declared variable?
12:15:14 <sebleblanc> I tried this: https://dpaste.de/UNMv It compiles but results in an unexpected infinite loop…
12:17:18 <sebleblanc> Last paste is wrong, see this instead: https://dpaste.de/czYD
12:18:11 <Gurkenglas> The where bob = "Bob" doesn't apply to the "Name bob" in the pattern match, but instead matches every recursive call of Robert
12:19:25 <Gurkenglas> You can do showName (Name name) = if name == "Bob" then "Robert" else name
12:20:10 * hackagebot transient 0.1.0.4 - A monad for extensible effects and primitives for unrestricted composability of applications  https://hackage.haskell.org/package/transient-0.1.0.4 (AlbertoCorona)
12:20:12 * hackagebot haskmon 0.2.0.0 - A haskell wrapper for PokeAPI.co (www.pokeapi.co)  https://hackage.haskell.org/package/haskmon-0.2.0.0 (pjrt)
12:20:27 <sebleblanc> Thanks for the insight
12:21:19 <sebleblanc> In general, is there a way to refer to a variable that has been defined elsewhere, in a function's parameter list?
12:21:36 <sebleblanc> (say if I defined "bob = "Bob"" outside of the where clause)
12:25:21 <ski> sebleblanc : pattern variables shadow other variables in scope of the same name. you could check for equality in a guard
12:26:39 <ski> .. as i now see Gurkenglas already indicated
12:29:46 <the_2nd> is there a builtin sort function?
12:30:10 * hackagebot pipes-group 1.0.3 - Group streams into substreams  https://hackage.haskell.org/package/pipes-group-1.0.3 (GabrielGonzalez)
12:30:12 * hackagebot rethinkdb-client-driver 0.0.20 - Client driver for RethinkDB  https://hackage.haskell.org/package/rethinkdb-client-driver-0.0.20 (wereHamster)
12:30:42 <ski> @index sort
12:30:42 <lambdabot> GHC.OldList, Data.List, Data.ByteString, Data.ByteString.Char8, Data.Sequence
12:30:57 <ski> @type Data.List.sort
12:30:59 <lambdabot> Ord a => [a] -> [a]
12:34:26 <Xnuk> :k Ord ((->) Integer Integer)
12:34:28 <lambdabot> Constraint
12:36:02 <Javran> any idea  what could possibly go wrong with "cabal configure --enable-coverage"? I'm using exactly the same version of cabal, cabal.config, and on my machine coverage for "Main" module is generated but not on the other one. 
12:40:11 * hackagebot haskmon 0.2.1.0 - A haskell wrapper for PokeAPI.co (www.pokeapi.co)  https://hackage.haskell.org/package/haskmon-0.2.1.0 (pjrt)
12:45:11 * hackagebot MicrosoftTranslator 0.1.0.0 - Interface for Microsoft Translator  https://hackage.haskell.org/package/MicrosoftTranslator-0.1.0.0 (netogallo)
12:45:38 * mniip . o O (microsoft has a translator?)
12:45:54 <Xnuk> bing translator?
12:46:32 <Xnuk> or not
12:48:36 <JonReed> Hi. I'm trying to install ihaskell through cabal inside a nix environment. The nix environment has ZeroMQ dependency installed. During ihaskell installation cabal complains "* Missing C library: zmq" and says " If the library is already installed but in a non-standard location then you can use the flags --extra-include-dirs= and --extra-lib-dirs= to specify where it is." The nix/lib directory has "libzmq.la" and "libzmq.so" and "libzm
12:48:53 <JonReed> What would be right command to get cabal to use this dependency? 
12:50:43 <bennofs> JonReed: hmm, http://hackage.haskell.org/package/ihaskell-0.6.4.1/ihaskell.cabal does not list zmq
12:51:38 <JonReed> "cabal --extra-include-dirs=/home/jon/.nix-profile/lib --extra-lib-dirs=/home/jon/.nix-profile/lib install ihaskell" does not work btw
12:51:49 <kqr> is there a clever way to get a list of all duplicate elements in a list?
12:52:32 <bennofs> kqr: mapMaybe (listToMaybe . drop 1) . group . sort
12:52:35 <bennofs> ?
12:53:35 <kqr> great!
12:53:41 <JonReed> bennofs: It still says that it wants it http://lpaste.net/139428
12:53:56 <kqr> oh that was clever
12:54:17 <JonReed> bennofs: Ah. zeromq4-haskell-0.6.3 wants it
12:54:46 <bennofs> JonReed: add pkgconfig as package to the nix-shell and try again
12:57:28 <JonReed> bennofs: I'm a total nix noob. I was hoping there was an easier way.
12:57:50 <bennofs> JonReed: btw, nix-env -f '<nixpkgs>' -iA haskellPackages.ihaskell appears to work fine for me, so you might not even need to install it manually through cabal (which is really hard with nix)
12:58:02 <JonReed> bennofs: Everytime I need to deal with nix I'm starting to sweat. 
12:58:23 <bennofs> JonReed: If you're having nix problems, there's also the #nixos channel :)
12:58:35 <the_2nd> I need a guide on how to create a package for a library
12:58:47 <the_2nd> or a library for others to use
13:04:21 <bennofs> JonReed: it looks like ihaskell has some problems working on Nix right now though :/
13:04:28 <JonReed> bennofs: So I actually tried installing ihaskell through nix. The thing is that I want to install it in an environment that is from try-reflex. Try reflex seems to use another version of ghc (7.10.1 I believe). So I do ./try-reflex. It drops me to nix-shell. I do nix-env to install ihaskell there. Then ihaskell wants to point out where ghc libs are. I do "[nix-shell:~]$ ihaskell install --ghclib=/nix/store/a71f42f65kqlnw
13:04:40 <JonReed> ihaskell install --ghclib=/nix/store/a71f42f65kqlnwax53i7ibgcs8apnima-ghc-7.10.1/lib/ghc-7.10.1
13:04:55 <JonReed> And it complains about ghc being the wrong version
13:06:27 <fresheyeball> hello haskellers 
13:06:32 <kqr> hello
13:06:37 <JonReed> bennofs: No, actually it throws runtime error http://lpaste.net/139430
13:06:40 <voidzero> hello fresheyeball 
13:06:51 <JonReed> bennofs: When try to access ipython.
13:07:06 <fresheyeball> so I wish to limit the accuracy of a float, by limiting it to 4 decimal places 
13:07:11 <bennofs> JonReed: hmm, yes. this might get difficult
13:07:13 <fresheyeball> is there a formal name for this?
13:07:22 <fresheyeball> as in
13:07:41 <JonReed> bennofs: If I add a cross compilation entry (just out of curiocity, I know that nix store should be readonly). It will complain about ghc being the wrong version.
13:07:43 <bennofs> JonReed: I think you should use --extra-include-dirs to refer to the /include subdir of zmq
13:07:55 <bennofs> JonReed: not the /lib dir
13:08:02 <fresheyeball> is there a propper term for limiting percision?
13:12:00 <JonReed> bennofs: It still fails :( http://lpaste.net/139431
13:14:39 <bennofs> JonReed: no idea about cabal, sorry :/
13:20:14 * hackagebot tasty-tap 0.0.1 - TAP (Test Anything Protocol) Version 13 formatter for tasty  https://hackage.haskell.org/package/tasty-tap-0.0.1 (MichaelXavier)
13:24:14 <JonReed> bennofs: Thanks for help anyway. 
13:29:51 <JagaJaga> @type lift
13:29:52 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
13:29:53 <JagaJaga> @type liftIO
13:29:55 <lambdabot> MonadIO m => IO a -> m a
13:35:53 <Gurkenglas> :t unfoldr (fmap unzip . traverse uncons) -- oh look, this equals transpose for rectangular matrices.
13:35:55 <lambdabot> [[a]] -> [[a]]
13:36:44 <bennofs> Gurkenglas: oh look
13:36:52 <bennofs> :t ala ZipList traverse
13:36:53 <lambdabot> Traversable t => t [b] -> [t b]
13:37:34 <the_2nd> any guide on how to structure haskell projects?
13:37:52 <bennofs> > (ala ZipList traverse) [[1..3], [4..6], [7..]]
13:37:54 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
13:38:13 <Gurkenglas> Was just about to do runZipList . sequenceA . map ZipList after some checking
13:38:22 <Gurkenglas> But yes, better
13:38:33 <Gurkenglas> How do I ask lambdabot where ala comes from?
13:38:51 <bennofs> Gurkenglas: lambdabot doesn't have it. it's either from the newtype package or lens
13:39:17 <bennofs> lambdabot doesn't have a function to check where something comes from*
13:42:05 <gamegoblin> Would it be possible to generalize the idea of OverloadedStrings to something like OverloadedTypes, where you could specify type coercions?
13:46:30 <hackrilege> hi!
13:46:58 <hackrilege> anyone about?
13:47:05 <Gurkenglas> arghbl there should be automatic Newtype derivation for all newtypes because this is awesome
13:47:18 <Rembane> hackrilege: Nope. What can we do for you? :)
13:47:40 <hackrilege> im confused about the types in my paste... sorry its tl http://lpaste.net/139439
13:48:24 <the_2nd> I have a SomeFile.hs and as first like "module SomeFile where"
13:48:32 <the_2nd> I now want to put it into a namespace
13:48:36 <hackrilege> its all good except on exporting the functions (like, what i see when i type :browse) it is not so good... i think i have done it wrong
13:48:37 <Gurkenglas> Why isn't there (Newtype (f a) a, Newtype (g a) a) => Newtype ((Compose f g) a) a?
13:48:59 <the_2nd> but "module NS.SomeFile where" will result in a "File name does not match module name"
13:49:13 <hackrilege> aha i have got this one
13:49:46 <hackrilege> it should not only be in a file called SomeFile.hs but in a folder called NS
13:50:18 <hackrilege> you also maybe need a .ghci file if you want to look at it not from the top directory 
13:50:27 <the_2nd> hackrilege, if I put it into the NS/ folder
13:50:30 <bennofs> Gurkenglas: shouldn't that be (Newtype (f (g a)) (g a), Newtype (g a) a) => Newtype (Compose f g a) a  but I think that you rather want Newtype (Compose f g a) (f (g a))
13:50:36 <the_2nd> my main.hs in . wont find it
13:50:43 <bennofs> Gurkenglas: and you can't have both
13:51:02 <hackrilege> it should import NS.SomeFile
13:51:36 <bennofs> :t ala Compose traverse -- Gurkenglas: lens has this instance at least
13:51:37 <lambdabot> (Applicative f', Applicative g', Traversable t) => t (f' (g' a')) -> f' (g' (t a'))
13:51:39 <the_2nd> hackrilege, yes, thanks
13:51:53 <the_2nd> and these names have to be upper case, right?
13:51:57 <hackrilege> e.g. if i want to open up NS.SomeFile, from within the folder NS, I should put in that folder a .cabal file containing :set ..
13:52:18 <hackrilege> the_2nd, its working now?
13:52:45 <hackrilege> sorry! a .ghci file, not a .cabal file....
13:52:45 <the_2nd> hackrilege, yes, prefixing the import worked
13:52:55 <hackrilege> cool! 
13:53:28 <hackrilege> try the .cabal file thing..
13:53:30 <hackrilege> .ghci*
13:54:01 <hackrilege> if you are using ghci...
13:56:11 <hackrilege> also a problem with the post, in order to make my Containers instances of Functor, i had to redefie the constructors to the datatype.... but this is nesacary because i need * -> * ? http://lpaste.net/139439 
13:57:15 <hackrilege> the_2nd: sorry .ghci (in folder NS containing module NS.SomeFile.hs) should read ":set -i .."
13:58:50 <hackrilege> data Container a b = Container { attributes ::a , contents :: b}
13:59:13 <hackrilege> instance Functor (Container a) where fmap f (Container a b) = Container a (f b)
13:59:16 <the_2nd> hackrilege, what would I have to do to make it available as package on github / hackage?
13:59:17 <hackrilege> type Atom = Container (String,Int) (Vec Double)
13:59:37 <hackrilege> read up about cabal building
13:59:38 <hackrilege> its super easy
13:59:59 <hackrilege> or yeh, get a github
14:00:54 <the_2nd> already on github
14:00:58 <hackrilege> https://hackage.haskell.org/package/cabal-upload
14:01:05 <the_2nd> just need some guidance on how the structure should look like
14:01:12 <Sindriava> "get a github"
14:01:13 <hackrilege> then just update the git as you usually would
14:01:18 <Sindriava> @karma+ hackrilege 
14:01:18 <lambdabot> hackrilege's karma raised to 1.
14:01:20 <hackrilege> i dont think cabal can help you with that
14:01:45 <the_2nd> hackrilege, github.com/myName/libName
14:01:47 <hackrilege> oh no i have karma!! what is this!?
14:01:56 <the_2nd> within that libName/file1.hs file2.hs
14:02:12 <the_2nd> all with module LibName.File where in first line?
14:02:20 <the_2nd> or what else do I have to provide?
14:02:37 <hackrilege> the cabal file
14:02:45 <hackrilege> maybe a setup.hs
14:03:06 <hackrilege> im not so sure about those though
14:03:06 <the_2nd> can you link me to a description/tut?
14:03:09 <the_2nd> kk
14:03:40 <hackrilege> lmgtfy
14:05:16 * hackagebot hspec-expectations-pretty-diff 0.7.2.2 - Catchy combinators for HUnit  https://hackage.haskell.org/package/hspec-expectations-pretty-diff-0.7.2.2 (myfreeweb)
14:05:22 <hackrilege> this one looks ok http://begriffs.com/posts/2014-10-25-creating-package-hackage.html
14:05:26 <Sindriava> I really dislike "lmgtfy" :/
14:06:14 <hackrilege> sorry
14:06:35 <hackrilege> i didnt have a good one to hand
14:07:40 <hackrilege> so i thought id better place the caveat that the response was from a google search and not a perfect reference from experience
14:08:04 <hackrilege> my battery will die, sorry!
14:08:53 <the_2nd> hackrilege, thanks for all the help
14:13:04 <Gurkenglas> Right & Right @ Newtype & Compose.
14:13:42 <blaird> Hey! I don't suppose anyone here has Accelerate.CUDA installed?
14:13:43 <hackrilege> hi sorry, im back
14:14:16 <hackrilege> if i had my old graphics card...
14:16:11 <blaird> Have you installed it before? My desktop has been having no end of problems getting it working...
14:17:22 <blaird> I was wondering if anyone had the same experience? I wrote a peice of code for it, but I actually can't test it to see how it performs
14:19:09 <hackrilege> yeh, like i say, without a graphics card i cant emulate your environment... sorry...
14:19:20 <hackrilege> are you using msys?
14:19:34 <Sindriava> hackrilege: I meant I dislike "lmgtfy" in a general sense, not the one you used specifically ^^
14:19:55 <hackrilege> oh ok, so why the kama point? sarcasm?
14:19:58 <blaird> What is msys?
14:20:26 <hackrilege> its a unix like environment built on mingw for windows
14:20:34 <hackrilege> sorry i should have asked if you were on windows
14:20:53 <blaird> Oh, no, ubunut
14:21:00 <blaird> ubuntu*
14:21:03 <hackrilege> yeh, i really cant help sorry
14:21:14 <blaird> No problem, thanks anyway
14:21:34 <hackrilege> still, post up your errors so anyone that might be able to help has the information they need
14:22:32 <blaird> I'm actually not on that machine atm, I left it alone for the 2hour nvidia-cuda-toolkit install (again)
14:22:58 <blaird> but it's weird. It's just a neverending pile of dependency problems
14:24:39 <blaird> But I'll get to the bottom of it eventually. Though I was wondering what the best GPU programming library is, or what people are using?
14:25:50 <blaird> I've never done it before, but it seems natural for Haskell to be good at it because it plays well with parallelization. I've come across Accelerate and Obsidian so far (only tested the first one)
14:32:14 <hackrilege> blaird, i found some thing from amd saying haskell is not supported
14:32:32 <hackrilege> if you need me too i can dig it out
14:33:10 <hackrilege> not directly by amd anyway, and i have found no other resource i can use. but thinking about it again is there not a OpenCL binding?
14:33:46 <blaird> Is there? That'd be cool
14:34:20 <nolrai66> Theres a page somewhere about intermediate haskell projects, yes?
14:34:37 <blaird> It's an nvidia card, but I'd prefer to write for OpenCL
14:35:06 <blaird> Oh no way, it totally is there
14:36:00 <hackrilege> ok i eat my foot!
14:36:04 <John[Lisbeth]> What do you call it when your program takes over your entire screen in a CLI app that has frames
14:36:11 <John[Lisbeth]> rather than just using STDOUT?
14:36:19 <John[Lisbeth]> printf, whatever
14:36:55 <gamegoblin> Is there anything on hackage for infinite lists? Something defined like InfiniteList a = InfiniteList a (InfiniteList a)
14:37:00 <hackrilege> blaird, i was confused by this article, which didnt seem to conclude well... http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2012/10/MakingOpenCLSimplewithHaskell.pdf
14:37:20 <John[Lisbeth]> Good examples of these would be aptitude, or weechat
14:38:00 <Rembane> gamegoblin: Other than the infinite lists in the language?
14:38:15 <hackrilege> gamegoblin, infinite lists are normal in haskell all recursive datastructures can be infine and the haskell built in list is too! ill give you an example
14:38:28 <hackrilege> > take 10 [1..]
14:38:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
14:38:32 <gamegoblin> Rembane, hackrilege: the one I just defined is infinite at the type level
14:38:46 <hackrilege> pardon me.... 
14:38:47 <gamegoblin> The [] type is not always infinite
14:39:07 <hackrilege> is a tree infinite in the type level? 
14:39:23 <gamegoblin> hackrilege: It depends on if you define a leaf node or a nil node
14:39:39 <hackrilege> with an []?
14:39:59 <gamegoblin> hackrilege: the type "Tree a = TreeNode a (Tree a) (Tree a)" would be a way to define an infinite binary tree
14:40:00 <notdan> gamegoblin: Data.Stream?
14:40:02 <hackrilege> no thats for trees sorry...
14:40:14 <Rembane> gamegoblin: Ah, cool.
14:40:29 <gamegoblin> notdan: that’s exactly what I was looking for, thanks
14:40:51 <hackrilege> gamegoblin, not fold or Traverse?
14:40:56 <notdan> yeah infinite lists are called streams
14:41:13 <hackrilege> ohh
14:41:30 <hackrilege> whats the difference?
14:41:59 <nolrai66> hackrilege: differnce between what?
14:42:13 <notdan> usually
14:42:14 <hackrilege> Streams and finite data structures
14:42:33 <notdan> streams are "infinite"
14:42:51 <notdan> aka coinductive
14:44:34 <hackrilege> so i have to defiine map differently?
14:45:46 <hackrilege> yes, no base case... cool
14:47:54 <notdan> yeah or you can use fmap
14:47:59 <notdan> both on lists and streams
14:52:06 <lethjakman> what does {..} do?
14:52:42 <lethjakman> or a name would be good so I could at least google it
14:52:53 <lethjakman> also, I don't understand the @ here: https://github.com/yesodweb/yesod/blob/master/yesod-auth/Yesod/Auth/BrowserId.hs#L65
14:52:56 <geekosaur> record wildcards
14:53:06 <lethjakman> geekosaur: thank you :)
14:53:08 <geekosaur> and that is an as-pattern
14:53:31 <geekosaur> (lets you give a name to a (sub)pattern)
14:53:51 <lethjakman> huh, subpattern?
14:54:03 <lethjakman> I'm assuming the { } is related to the { in that code?
14:54:08 <geekosaur> so, in summary: that captures the whole parameter record in `bis`, while unpacking all the component fields to local bindings with the same names as the fields
14:54:09 <lethjakman> as in line 66
14:54:28 <geekosaur> for a record constructor BrowserIdSettings
14:54:41 <lethjakman> ahh
14:54:45 <lethjakman> right!
14:54:48 <geekosaur> the thing on lone 66 is related
14:54:57 <hackrilege> timesTwo d@(Datatype a) = (\Datatype b -> a+b) 
14:55:11 <geekosaur> it's doing a record update there: the record AuthPlugin (a constructor) with the following field values: { ... }
14:55:16 <lethjakman> seems like the apDispatch could have been pulled out itno a method to make this more clear
14:56:04 <geekosaur> it's assigning a lambda to a field
14:56:51 <geekosaur> it "could" have used a local binding in the where clause... but, you're looking at yesod source, you should not be surprised at it using advanced stuff all over :)
14:57:00 <lethjakman> geekosaur: are these like defaults so I could override them?
14:57:11 <lethjakman> yeah...
14:57:30 <geekosaur> I don't understand that question. the function authBrowserId returns a record
14:57:31 <lethjakman> it's just how I roll, new to a language? get incredibly confused by reading advanced stuff...
14:57:46 <geekosaur> you can use the same record update syntax to make a copy of that with different values, yes
14:58:07 <geekosaur> (you would never be updating the actual returned value; this is after all Haskell)
14:58:21 <lethjakman> geekosaur: I guess I'm just trying to figure out how to use the GoogleEmail2 and got distracted here
14:59:08 <kqr> is there a better way of doing "Data.Text.decodeUtf8 . Data.ByteString.Lazy.toStrict . Data.ByteString.Builder.toLazyByteString"?
14:59:15 <lethjakman> it'd be nice if they gave us some basic examples
14:59:27 <geekosaur> I don't think I can help with that; I can read random code, but yesod (and yesod plugin) details I don't particularly know
15:00:30 <lethjakman> that's ok, thank you :)
15:10:51 <hackrilege> can anyone look over my paste and suggest any improvements in style? http://lpaste.net/139439
15:12:42 <Bruuuuuuno> why does the "doToAtom" function exist?
15:16:55 <aupiff_> with stack, I want to grab a dependency from a git repo, so I apply the hash in the `packages` field. however, I have an issue that the library is rebuilt every time I run `stack build` or `stack test` even though the git commit hash is the same. I just upgraded to stack-1.3.1 and didn't experience this issue in the past with 1.2.
15:17:34 <aupiff_> I really want to have the git commit hash in the `extra-deps` field so that this particular library is never tested by stack.
15:17:41 <aupiff_> but I'm not sure if that's possible
15:20:27 <hackrilege> Bruuuuuuno: good question, its a wrapper to fmap, because the other modules depend on that incase i wish to change its implementation
15:21:02 <hackrilege> you think because fmap is the public class i should implement everything in terms of that, which is the whole point of making the instance?
15:21:50 <hackrilege> also enabling more convenient focusing?  
15:22:16 <hackrilege> hmm, its a shame to lose the intuition afforded by the function name
15:22:45 <hackrilege> it gives meaning to the definition of the focus, rather than just lots of uninformative nested fmaps...
15:23:30 <hackrilege> and as the datastructure is fixed as it is chemsitry (molecules are made of atoms) i dont forsee needing the highly nested abstraction functions
15:23:39 <hackrilege> this is the only accessor i need and so im naming it
15:23:48 <Bruuuuuuno> Yeah, I see what you mean
15:23:51 <hackrilege> does that make sense?
15:24:04 <Bruuuuuuno> yes
15:24:24 <Bruuuuuuno> but the name "doToAtom" isnt really explicative I think
15:24:25 <hackrilege> also then i dont have to define these lens things, i dont need them, i just need one accessor 
15:24:57 <hackrilege> moveAtom would get the fact it modifies a postion vector
15:25:56 <tulcod> hackrilege: but you're exposing that the function is really acting on a Vec Double. so then the user could've used fmap anyway.
15:26:00 <hackrilege> but thats not really the considerations i was after, the whole export is messed up because all the things work on graphs, and its hard to see that a molecule is a graph, as its a Container of a Collection which is a graph
15:26:29 <hackrilege> tulcod, interesting
15:26:53 <tulcod> hackrilege: well, except for the fact that you're not exposing the constructors of Atom...
15:27:26 <tulcod> hackrilege: but at first sight, it looks like a sort of half-assed attempt at hiding the implementation details. make a clear list of what's exposed and what's not
15:27:42 <hackrilege> yes, im even refering to it like that in doToMolecule' f m =  doToMolecule (fmap f) m
15:27:42 <edwardk> hackrilege: i'd personally kill 'Container' and just make data types for the few places you use it
15:28:13 <tulcod> hackrilege: also, note that you can't "hide" instances from being exposed. any module that loads a module with an instance declaration, automatically gets the instance declaration. they're "viral".
15:28:14 <hackrilege> and as doToMolecule f m =  fmap f m  is just fmap again....
15:28:41 <edwardk> type Atom = Container (String,Int) (Vec Double)     ===> data Atom = Atom { atomName :: String, atomWeight :: Int, atomPosition :: (Double, Double) }
15:28:50 <hackrilege> edwardk, Container allows Atom to be a Functor.... 
15:29:07 <tulcod> hackrilege: also, surely you know that a molecule is more than a graph of atoms, and an atom is more than a finite collection of particles :)
15:30:04 <edwardk> data Atom a = Atom String Int a deriving (Functor, Foldable, Traversable); instance Comonad Atom where extract (Atom _ _ a) = a; duplicate aw@(Atom n w _) = Atom n w aw; ....
15:30:11 <edwardk> you can do that with a data type as well
15:30:20 <edwardk> but now we're not stuck with one one size fits all data type
15:30:24 <edwardk> that doesn't quite fit anyways
15:30:33 <edwardk> you're already shoving tuples into those fields
15:30:34 <hackrilege> tulcod, thanks for the tips, on your last point, thats why i have a collection, i just want to fmap over what you call particles, my atoms..
15:30:35 <tulcod> hackrilege: the idea that you want to hide implementation details from the user *may* be very good, depending on the application. but it might also simply force the user to basically recover the fmap that you're trying to hide.
15:30:38 <edwardk> just to cram in more stuff
15:30:55 <edwardk> Container is no more informative than (,) in the current formulation you have
15:31:00 <edwardk> you can't hang instances on it
15:31:06 <kqr> can you force stack to rebuild a project? for some reason it doesn't seem to want to build it again now o_O
15:31:49 <hackrilege> edwardk cool, thanks. (,)...
15:32:00 <nolrai66> does stack have "clean"?
15:32:03 <tulcod> hackrilege: that makes some amount of sense. i see where you're coming from with trying to hide the implementation.
15:32:15 <kqr> nolrai66, there it was, thanks
15:32:29 <kqr> nolrai66, although that worked, i'm still confused because that hasn't been required up until now
15:32:40 <edwardk> data Atom = Atom { element :: String, mass :: Int, position :: Vec Double } -- captures a good chunk of the start of your code though
15:32:42 <hackrilege> wow why is Atom a Comonad?
15:33:01 <edwardk> hackrilege: 'why is it a Functor?'
15:33:03 <hackrilege> my Vec can be Applicative, but Atoms cant...
15:33:09 <tulcod> hackrilege: (i hope it's clear that we're not criticizing you - these are just some comments we would have, which you are free to ignore :) )
15:33:20 <hackrilege> no its great!
15:33:23 <hackrilege> its perfect
15:33:37 <hackrilege> this is the point!
15:33:56 <tulcod> hackrilege: also, why would the functor be on the position? why not on the spin of the particles?
15:34:21 <tulcod> it looks more like you'd want different interfaces for the various aspects of the constituennts
15:34:26 <edwardk> Collection can be made Foldable, Traversable as well
15:34:28 <tulcod> and i don't think thhat really fits in the functor model
15:34:53 <tulcod> hackrilege: some people consider this cursing, and I'm not a big fan of it either, but you may want to consider.... lenses...
15:35:08 <hackrilege> its motivated by them
15:35:15 <edwardk> data Molecule { name :: String, basis :: Vec (Vec Double), atoms :: Collection Atom }
15:35:17 <hackrilege> but i want to implement everything i depend
15:35:18 <hackrilege> on, 
15:35:26 <edwardk> er data Molecule = Molecule { ... }
15:35:28 <tulcod> hackrilege: you're gonna reimplement GHC?
15:35:39 <edwardk> now you have two separate data types and most of your boiler plate is gone
15:36:05 <edwardk> that eliminates out of the first 130 lines of code all the code except for 100-115
15:36:51 <edwardk> if you went further and switched to lenses you'd be able to eliminate the rest of the boilerplate but i can accept that you don't want to do that
15:37:15 <hackrilege> tulcod, no just that thsi particular part of the thing is describing what our datastructure is, and how we look at it, which is the whole project. so if i am to use lens, i should not really, but just use the class definitions necessary to acquire the minimum specification, which is basically just a good description of how we are dealig with the datatype
15:38:24 <hackrilege> tulcod; no spins here, fmap on the postion. its basically just a postion with labels, its spin could go in the attributes part of Container
15:38:35 <tulcod> hackrilege: (playing the devil's advocate here...) as much as i would avoid using lenses, if what you want to use is implemented in a pretty library, use that library.
15:39:16 <hackrilege> its been discussed, i just gave my answer
15:39:46 <hackrilege> i have to stick with that its out of my hands
15:39:47 <tulcod> hackrilege: well yes. but you want to hide the implementation details - presumably to be able to add more knowledge of physics later. so what if we discover that every particle carries a backpack (containing electric charge) after all, and we need to keep track of their colors?
15:40:08 <tulcod> then you'd want some kind of Functor instance for the colors of the backpacks
15:40:15 <tulcod> now what is fmap supposed to do?
15:40:25 <tulcod> sure, you can say it goes in the attributes, but then why doesn't the position go in the attributes?
15:40:36 <hackrilege> because i fap over it
15:40:41 <tulcod> eww
15:40:48 <hackrilege> fmap
15:40:49 <hackrilege> god
15:41:02 <nolrai66> Actually loled.
15:41:06 <hackrilege> so if i need to fmap over something it should go in the contents
15:41:24 <tulcod> hackrilege: okay, that makes some amount of sense: you're fmapping over the constituents
15:41:33 <hackrilege> it was bound to happen, why me?
15:41:42 <tulcod> and yes, that could go into several levels. so that makes sense.
15:42:41 <hackrilege> it wouldnt be just of a possition then addmitedly, but as far as i can tell the position is the only thing in need to access really... its "mollecular dynamics", classical. just points and forces
15:43:48 <tulcod> ah, the kind of dynamics that ignores its own collapse of the universe?
15:45:13 <edwardk> hackrilege: personally? i think the functoriality you are chasing there is just 'off' a bit. you _want_ a functor to get at the position, but then you don't want to use it by writing a doToAtom... which seems to show you somewhat at odds with yourself in your current approach
15:45:22 * hackagebot pcre-heavy 0.2.3 - A regexp library on top of pcre-light you can actually use.  https://hackage.haskell.org/package/pcre-heavy-0.2.3 (myfreeweb)
15:45:22 <lethjakman> is import Data.Aeson wrong?
15:45:29 <edwardk> but in the end i think you'll find that Container is a deadend design
15:45:32 <lethjakman> I seem to have it on my machine
15:46:04 <Hafydd> class Fuctor f where fap :: (a -> b) -> f a -> f b
15:46:10 <hackrilege> i can ditch doToAtom happily 
15:46:21 <myfreeweb> lethjakman: it's not wrong
15:46:37 <tulcod> hackagebot: why don't you expose that a molecule is a tuple of a container and an attribute type, without exposing the attribute type (ie hiding what the properties of a molecule are), but exposing what the constituents are?
15:46:39 <lethjakman> hum
15:46:40 <tulcod> err
15:46:42 <hackrilege> the problem is more that its not clear that a mollecule should be modified as a graph, since its a container of a collection which is a graph
15:46:44 <tulcod> hackrilege ^
15:46:44 <myfreeweb> lethjakman: are you using cabal-install or stack?
15:46:50 <lethjakman> myfreeweb: cabal install
15:46:58 <lethjakman> I'm trying to do it in ghci
15:47:03 <lethjakman> if that makes any difference
15:47:23 <myfreeweb> lethjakman: did you install aeson into a sandbox? or globally?
15:47:36 <lethjakman> myfreeweb: globally I think
15:47:40 <tulcod> hackrilege: i'm starting to think you have found the first use case of the Container class
15:47:50 <hackrilege> Aeson.Lens should be Lens.Aeson if that helps
15:48:51 <hackrilege> tulcod i dont understand
15:49:27 <tulcod> hackrilege: well, the point is this. I think with proper explanation of what you're trying to expose, and what you're trying to hide, and what kind of a view of molecules you want to present, your interface could make sense (if you fix the data type definitions as suggested above)
15:49:50 <tulcod> right now the Functor interface looks a bit misplaced
15:50:04 <tulcod> but maybe that's just a documentation issue
15:51:25 <tulcod> hackrilege: maybe it'd help to split up the data type a little bit. a Molecule is a pair of some attribute type, and a MoleculeConstituents type, that acts as the container for the Atoms. you don't expose what either subtype is, but the fact that it's a pair like that, and functor interfaces for the container types, should present a Haskell-style interface
15:52:47 <hackrilege> hmm, confused, isnt that what its doing?
15:53:17 <hackrilege> i have split out the the thing i want to fmap over and made it a Functor...
15:54:04 <hackrilege> Container directs fmap to Atoms, which are not functors, but Vec Double. Vec is a functor
15:54:48 <hackrilege> i need the Container to be a functor as Atoms are not
15:55:04 <tulcod> hackrilege: i might be confused because there's both a Collection and a Container
15:55:38 <hackrilege> Collection is my wrapper of a list, later an Array and finally a Map with benchmarks
15:56:03 <tulcod> hackrilege: no, it's not quite what you're doing, since your Functor instance is for the Container, which is just the tuple. my proposal is to put it on the Collection.
15:56:20 <hackrilege> Container is my way of isolating part of a non functor which can act as a functor. it must be Vec Double and not just Vec 
15:56:41 <hackrilege> Collections are also Functors...
15:56:44 <tulcod> hackrilege: and it seems you thought the same, since that instance indeed exists - you have an instance for both Container and Collection
15:56:51 <tulcod> so that fact makes it less idiomatic
15:57:08 <tulcod> why do you need the Functor instance on Container?
15:57:34 <tulcod> (which I'm afraid is the question we started out with)
15:58:14 <hackrilege> as it contains a non functor made up of something which can be a Functor. thing is it cant contain arbritrary type, it contains Vec Double, which is not a Functor even though Vec is
15:58:22 <tulcod> the Functor instance on Collection makes sense, if you want to be prepared for the news that a molecule is not quite a bag or graph or whatever of atoms
15:59:00 <lethjakman> is there a way to find all importable modules?
15:59:04 <lethjakman> or where they import from?
15:59:10 <lethjakman> the path must be wrong in ghci or something...
15:59:15 <tulcod> hackrilege: we use type classes to /generalize/, for example in the case that underlying implementations change. but the fact that a molecule has attributes and some fmappable container of atoms won't change
15:59:24 <hackrilege> i am giving a non functor a functor instance by using Container, so it must be a functor!
15:59:56 <hackrilege> lethjakman is the problem that you are importing Data.Aeson.Lens?
16:00:02 <tulcod> hackrilege: thing's aren't a functor in some universal sense. we give them the structure of a functor. several structures might exist, and in the end, it depends on the application which one makes sense (sometimes none)
16:00:35 <tulcod> things* :-/
16:00:42 <lethjakman> hackrilege: no, I'm importing "import Data.Aeson"
16:00:48 <lethjakman> I should replace that with .Lens?
16:01:14 <hackrilege> i dont know then sorry... no there is another bug in Aeson in that Aeson.Lens should be Lens.Aeson or something
16:02:33 <hackrilege> tulcod; do you see what i mean about making the non Functor Atom a Functor again? i want to do that i think... are you saying its no good?
16:03:09 <lethjakman> that's fine, thank you for your suggestion
16:03:13 <hackrilege> lethjakman can you tell us more about whats going on i cant tell quite whats wrong...
16:03:27 <tulcod> hackrilege: i see that you're doing that, and also for Molecule, but i don't understand why that helps the user. you're already exposing the constructor for Container. if the user wants a Functor interface for Molecule or Atom, they can get it.
16:03:37 <tulcod> ie make it
16:03:53 <hackrilege> but i did make it!
16:04:01 <tulcod> no i mean a user of your library
16:04:12 <tulcod> hackrilege: what is the added value of the Functor interface of Container?
16:04:22 <tulcod> why shouldn't a user use the Functor interface of Collection?
16:04:33 <hackrilege> it gives funtor interface to Atom and Molecule
16:04:40 <tulcod> yes. why.
16:04:54 <hackrilege> because they have arrtibutes you cant fmap over
16:04:57 <tulcod> more instances doesn't equal more better
16:05:13 <hackrilege> it is a functor!
16:05:17 <tulcod> hackrilege: which ones?
16:05:23 <tulcod> hackrilege: the collection you can already fmap over
16:05:33 <tulcod> the attributes arent' fmapped over by this instance
16:05:47 <lethjakman> hackrilege: if I do a "cabal list aeson" I see "aeson" in the list of libraries
16:05:49 <hackrilege> Vec, Collection, and the containers Atom and Molecule
16:06:09 <geekosaur> lethjakman, I hope you included --installed there
16:06:12 <hackrilege> lethjakman, but?
16:06:17 <geekosaur> otherwuise you got the list of *available* libraries
16:06:18 <tulcod> hackrilege: what about those things?
16:06:52 <hackrilege> they are the things i can fmap over
16:07:01 <tulcod> who is "i" here?
16:07:11 <lethjakman> but if I go into ghci and type "import Data.Aeson" it tells me "could not find module Data.Aeson Perhaps you meant Data.Version"
16:07:16 <hackrilege> the user
16:07:31 <lethjakman> geekosaur: I did not
16:07:42 <hackrilege> did you do cabal install aeson?
16:07:42 <geekosaur> I suggest "ghc-pkg list"
16:07:43 <lethjakman> but it is. 0.8.1.1 is installed
16:07:45 <tulcod> hackrilege: uh, i mean, yes, you can fmap over them, you explicitly added a Functor instance. what are you trying to say?
16:07:53 <geekosaur> if you did noit iunclude "--installed" then it showed you what you can install
16:07:59 <geekosaur> not what is installed
16:08:11 <tulcod> lethjakman: (typing ghci in your terminal doesn't work for sandboxes)
16:08:24 <tulcod> lethjakman: (try `cabal repl` instead)
16:08:55 <lethjakman> hackrilege: then I get this erro: https://gist.github.com/lethjakman/64ed3ce9306545716900
16:09:00 <hackrilege> <tulcod> hackrilege: which ones?
16:09:41 <tulcod> lethjakman: "cabal install c2hs", then retry "cabal install aeson"
16:09:56 <tulcod> lethjakman: unfortunately cabal doesn't deal with build-time dependencies very well yet (of which c2hs is one)
16:10:03 <Sindriava> What would be the best library and resources to start learning FRP?
16:10:12 <tulcod> lethjakman: (probably c2hs will, in turn, have build-time dependencies that cabal can't detect)
16:12:07 <lethjakman> tulcod: that gives me this: https://gist.github.com/lethjakman/2f506bb3968d610f856c
16:12:25 <lethjakman> tulcod: ahhh I definitely didn't know that
16:12:31 <lethjakman> is that going to be improved?
16:15:20 <ttt_fff> what's a good tutorial on writing commandline applications in haskell? (I want to write something minimal as an inteface to sqlite3)
16:16:21 <tulcod> lethjakman: cabal is a bit imperfect anyway. i hope it'll be improved by whatever will solve the rest of cabal's issues
16:16:26 <pharaun> ala git style cli
16:16:32 <pharaun> or ala readline cli?
16:16:54 <tulcod> lethjakman: hm, that's a weird error. would you mind starting from scratch? (remove your .cabal and .ghc dirs)
16:17:24 <nolrai66> ttt_fff: I don't think there is one. Its pretty easy though. Use one of the options parsing librarys, putStrLn and getLine.
16:17:35 <tulcod> Sindriava: best resources, i don't know. but the reflex library got a bit of attention a while ago.
16:17:41 <hackrilege> there are some getArgs libs i think...
16:17:41 <tulcod> Sindriava: it has a bunch of demo code
16:17:59 <ttt_fff> pharaun nolrai66: git style cli
16:18:12 <ttt_fff> I was hoping there's already a library for parsing command line options and I don't have to do an adhoc parsec solution
16:18:18 <pharaun> yup
16:18:27 <joeyh> ttt_fff: optparse-applicative
16:18:31 <Sindriava> tulcod: Thanks! I'll look into it :) I'm looking for the most general FRP library, to really get the feel for it
16:18:35 <ttt_fff> joeyh: thanks
16:18:38 <pharaun> dang joeyh beat me to the punch
16:18:43 <pharaun> i couldn't remember the name so was searching
16:19:11 <hackrilege> ttt_fff this? http://hackage.haskell.org/package/base-4.8.1.0/docs/System-Environment.html#v:getArgs
16:19:14 <nolrai66> Darkned: You around?
16:19:34 <pharaun> hackrilege: t_f doesn't want to do manual parsing
16:19:44 <hackrilege> ok!
16:19:44 <hackrilege> sry
16:19:48 <hackrilege> n clue
16:19:50 <hackrilege> no*
16:20:00 <pharaun> hackrilege: its np :) joeyh suggested optparse-applicative\
16:20:11 <hackrilege> oh cool
16:21:11 <tulcod> ttt_fff: you might also be interested in how (not) to do defaults: http://phaazon.blogspot.co.uk/2015/07/dont-use-default.html
16:21:20 <lethjakman> tulcod: what do I do after removing them?
16:21:22 <hackrilege> tulcod, did we get anywhere with the discussion before i thought we were cut short, what were you getting at agian?
16:21:54 <tulcod> hackrilege: i'm just confused why you want to have a Functor interface for Container. if people want to access the underlying Collection, they can just use that Functor interface.
16:21:59 <ttt_fff> tulcod: what? I love orphan instances of tyepclasses
16:22:15 <pharaun> lol
16:22:24 <lethjakman> tulcod: same exact error
16:22:32 <tulcod> lethjakman: well that wipes all your per-user installed packages, so you can start reinstalling
16:23:00 <lethjakman> maybe it's my path?
16:23:32 <lethjakman> "/Users/lethjakman/Library/Haskell/bin:/Users/lethjakman/.cabal/bin:/Users/lethjakman/Library/Haskell/bin:/Users/lethjakman/.local/bin/"
16:23:38 <lethjakman> that's all my haskell stuff which is at the front of the path
16:23:41 <lethjakman> is that correct?
16:23:47 <tulcod> lethjakman: can you just do "cabal install syb"?
16:24:01 <lethjakman> it's already installed
16:24:09 <Clownpiece> tulcod: why not give the functor instance? Theres only one good fuctor instance for any time.
16:24:12 <tulcod> lethjakman: i don't know how you installed haskell, so i don't knwo if that's right
16:24:29 <lethjakman> tulcod: I used haskell platform
16:24:31 <elben> I’m trying to find a concrete instance of this data type: http://lpaste.net/139454. Not sure how to finish it. Ideas?
16:24:44 <tulcod> lethjakman: well i don't know how haskell platform installs on mac os :P
16:25:07 <Clownpiece> *type
16:25:18 <tulcod> lethjakman: what if you cabal install =syb-0.5.1 ?
16:25:27 <tulcod> (or however the syntax for exact versions is)
16:25:30 <hackrilege> im trying to reFunctorise something that should really only be an non functor Atom containting Vec Double, and not the Functor Vec, but calling an atom Container to direct fmap to the Vec which can then be fmapped over, same with molecules...
16:25:43 <lethjakman> already installed
16:25:49 <elben> elben: the type hole is asking for `b Maybe`, which i’m not sure how I can build a value of type `Maybe` (just Maybe, not Maybe _)
16:25:53 <tulcod> lethjakman: then you didn't have the same exact error
16:26:05 <lethjakman> tulcod: no, it just told me that it was installed
16:26:19 <tulcod> lethjakman: no i mean, installing c2hs didn't have the same exact error
16:26:20 <hackrilege> we are talking about this btw if you didnt see it http://lpaste.net/139439
16:27:24 <Clownpiece> elben: You cant. 
16:27:31 <lethjakman> hmmm, my ghci is installed at /usr/bin/ghci
16:27:44 <lethjakman> but it is 7.10.2
16:28:10 <lethjakman> I can't install cabal-install though
16:28:10 <Clownpiece> elben: can you paste up your code? I think it is likely that something is getting confused.
16:28:28 <lethjakman> yeah there's a lot of strange libraries missing
16:28:58 <elben> Clownpiece: http://lpaste.net/139454 is the code. I’m playing with data types to see what’s possible and what’s not
16:29:20 <elben> seems like I can declare such a data type, but I can’t find an instance of it
16:29:48 <tulcod> lethjakman: what, you can't cabal-install ghci? cause you're not supposed to
16:30:18 <tulcod> lethjakman: (sorry if this all seems like an undocumented mess. it is. i don't know what to tell you except to hang in there until you get stuff to work)
16:30:27 <Clownpiece> elben: No b just has a higher kind. (* -> *) -> * if I am reading it right.
16:30:34 <hackrilege> i dont want to make Atom a functor. molecules are not functors as they are made of atoms. the only thing that is functor like is the Collection and the Vec as really Molecules and Atoms cant take variable type, the Atoms must be Vec Double not Vec and the Molecules must be Collections of Atoms not just Collections
16:30:41 <lethjakman> tulcod: what do you mean? I didn't try to install ghci, I tried "cabal install cabal cabal-install" and got the same errors
16:31:18 <tulcod> lethjakman: all with this syb package? then i would guess your haskell platform install is broken.
16:31:30 <Clownpiece> So something like Fix f = Fold {unFold :: f (Fix f)} would work for b.
16:31:36 <tulcod> (not an expert on this though. it's only working on my machine because the packagers are doing a good job)
16:32:03 <hackrilege> tulcod^
16:33:12 <hackrilege> they cant "access the underlying Collection, by using its Functor interface" because its a Collection of Atoms specifically
16:33:25 <hackrilege> not of type * -> *
16:33:34 <tulcod> hackrilege: then i think we agree. so why make a Functor instance for the container?
16:34:12 <tulcod> hackrilege: (re: I don't want to make Atom a functor)
16:34:19 <hackrilege> so that we can use fmap as its a Vec or a Colletion at the heart, so we should use that implementation of fmap
16:34:24 <tulcod> huh.
16:34:33 <tulcod> you don't want to make it a functor, but you do want to use fmap
16:35:00 <hackrilege> maybe fmap f (Container a b) = Container a (fmap f b) would make more sense?
16:35:23 <tulcod> none of this makes sense. why do you want lines 34 and 35?
16:35:24 <hackrilege> i would love to make it a functor, hence all this infrastructure, but im not allowed because its not of type * -> *
16:35:54 <hackrilege> haha, yes i know thats your problem
16:35:56 <lethjakman> tulcod: I uninstalled EVERYTHING
16:36:02 <elben> Clownpiece: OK, thanks. I will have to think about this some more
16:36:02 <hackrilege> its on those lines
16:36:03 <lethjakman> rm -rf /Library/Haskell
16:36:20 <hackrilege> instance Functor (Container a) where >  fmap f (Container a b) = Container a (f b)
16:36:24 <lethjakman> after running uninstall-hs thru most recent version
16:36:30 <hackrilege> perhaps it should be instance Functor (Container a) where >  fmap f (Container a b) = Container a (fmap f b)
16:36:34 <lethjakman> and it works!
16:36:37 <lethjakman> no clue why
16:36:39 <lethjakman> but it worked
16:36:41 <lethjakman> wooooo
16:36:43 <tulcod> lethjakman: i see you've gone for the sledgehammer approach towards software management
16:36:52 <hackrilege> would that make more sense?
16:37:28 <tulcod> hackrilege: what goes wrong if you delet lines 34 and 35 (and 36 to fix the resulting double newline)?
16:38:04 <lethjakman> tulcod: nothing's working today, if I don't take it that approach to my software I'm going to take it to my computer
16:38:08 <lethjakman> and that's much more expensive
16:38:32 <tulcod> lethjakman: that's a reasonable argument :) and don't worry, it gets better
16:38:33 <hackrilege> no instance fmap in doToAtom
16:38:48 <tulcod> hackrilege: why do you need fmap to write doToAtom?
16:38:50 <lethjakman> tulcod: I sure hope so! haskell needs more sample code...
16:39:04 <tulcod> lethjakman: on behalf of the haskell community, I'm sorry
16:39:15 <hackrilege> because i am accessing the innards like fmap . fmap . fmap
16:39:15 <lethjakman> tulcod: lol, thank you. 
16:39:24 <tulcod> hackrilege: why do you want to do it like that
16:39:26 <hackrilege> as they are nested Functors
16:39:28 <tulcod> why
16:39:35 <lethjakman> now I must blog this all away!
16:39:39 <hackrilege> because someone said consider lenses
16:39:44 <tulcod> you're saying they're functors because you're using fmap, and you're using fmap because they're functors
16:40:09 <tulcod> and you're trying to reinvent lenses, but you're not really reinventing lenses
16:40:11 <hackrilege> a molecule is a thing which can be mapped over, so its a functor?
16:40:32 <tulcod> hackrilege: listen, just the fact that you *can* give something a functor instance doesn't mean that you *should*
16:40:39 <hackrilege> its a functor ok
16:40:49 <hackrilege> i want to fmap over it
16:40:53 <hackrilege> no type this time
16:40:56 <hackrilege> typo*
16:40:59 <tulcod> hehe
16:41:16 <hackrilege> its a collection! i need to fmap over it
16:41:27 <tulcod> but it's not the collection that's the functor. or not only that.
16:41:30 <hackrilege> its like its key property
16:41:36 <tulcod> you have different functor instances, and that's going to be really confusing in the long run
16:41:56 <hackrilege> also there is the other type of Functor, the Vec
16:42:21 <Clownpiece> tulcod: why should he not give it a functor instance?
16:42:22 <tulcod> because tomorrow you're gonna fmap over some substance, and you're wondering if you're getting molecules, atoms, particles, or position coordinates
16:42:30 <tulcod> because that ^
16:42:44 <Clownpiece> Ehhh.
16:42:51 <Clownpiece> That seems weak to me.
16:42:55 <tulcod> sure
16:43:02 <tulcod> but his argument to *have* a functor is also weak
16:43:17 <tulcod> the argument to have a functor instance, so far, is "because i'm going to use fmap here"
16:43:38 <Clownpiece> basicly any Type constructor of kind (* -> *) that can should be.
16:43:52 <tulcod> listen, it's your code, do what you want. you asked if it's idiomatic haskell. well, i'd say most idiomatic haskell doesn't have a bunch of functor instances, but yes, there are counterexamples, and yes, it might make sense
16:43:57 <Clownpiece> Or is it not of kind (* -> *)?
16:44:40 <hackrilege> A Vec and a Collection are both valid Functors
16:45:16 <hackrilege> but an Atom which is a tuple containing a Vec Double is not a Functor as it has not got kind * -> *
16:45:45 <Clownpiece> Yes. It is not a functor and should not be.
16:45:56 <hackrilege> and a Molecule which is a tuple containing a Collection of Atoms is also not a functor but the Collection is
16:46:19 <hackrilege> so if i want to focus in i need to have the ability to fmap over my Atoms and Molecules
16:46:43 <hackrilege> so i make a Container, which isolates the fmapable component and allows the functor definition 
16:46:50 <tulcod> Clownpiece: it shouldn't be, because it's not of kind *->*? so why is ParsecT a functor?
16:47:35 <Clownpiece> ParsecT isn't, ParsecT applied to some arguments is.
16:47:55 <Clownpiece> hackrilege: No you need lenses.
16:48:13 <Clownpiece> fmap is the wrong tool here.
16:48:25 <hackrilege> (i think there is a typo in the paste maybe fmap should fmap the function to the collection or the vec... so then atom is not really making sense, but molecule still does)
16:48:42 <Clownpiece> No.
16:48:44 <hackrilege> i think im trying to make them?
16:48:59 <hackrilege> no...
16:49:05 <hackrilege> no what?
16:49:16 <hackrilege> sorry :trlf:
16:49:41 <Clownpiece> I think you are confused about what fmap is used for, and how one uses types in haskell.
16:49:50 <Clownpiece> Hmm.
16:50:01 <Clownpiece> How to put this in a way that makes sense.
16:50:03 <hackrilege> i think that is probably correct
16:50:38 <Clownpiece> Could you put the link to paste up agian?
16:51:17 <hackrilege> http://lpaste.net/139439
16:51:19 <tulcod> Clownpiece: also, functors of kind * -> * -> * exist. not saying they're useful, but that doesn't seem to be a requirement for being a functor.
16:51:27 <tulcod> mathematically, anyway
16:51:40 <hackrilege> is that why im having to try and brute force it?
16:52:00 <Clownpiece> the functor typeclass is not covering all functors.
16:52:08 <Clownpiece> Just endo functors on Hask.
16:52:10 <hackrilege> because  Collection Double seems to be something i want to fmap over
16:52:23 <hackrilege> (or Collection Atom here)
16:53:02 <Clownpiece> Yes.
16:53:11 <Clownpiece> Maybe.
16:53:21 <Clownpiece> What is Collection?
16:53:43 <hackrilege> "its an object which holds things i can modify, so it seems like a functor, but i must fix the type of that thing, so it is not of kind * -> * "
16:54:03 <hackrilege> a collection is a wrapper of a list, later an Array and then a Map
16:54:19 <hackrilege> it is a graph here
16:54:25 <Clownpiece> Hmm.
16:54:55 <Clownpiece> You should just use (,) for Container.
16:55:07 <hackrilege> oh yeh its indexed and has neighbours, so yeh its just a Graph
16:55:53 <kqr> what am I doing wrong if Data.Text.IO.writeFile spits out CRLF line endings instead of regular LF ones?
16:56:24 <hackrilege> if i was using (,) because it had a fmap definition already, i dont want to do that, its nice like it is because you can read what its doing from the source
16:57:18 <Clownpiece> ..I guess?
16:57:28 <Clownpiece> yours is the same fmap though.
16:57:46 <Clownpiece> and Container is a terrible name for it.
16:57:56 <hackrilege> the problem with it is not that the user sees that an Mollecule of a Container of Collections, and not a Functor, which would be so much nicer, or anything that actually indicates that a Collection is a Graph and that you can use the graph constructors to build it...
16:58:18 <Clownpiece> A Container of Collections is a functor.
16:58:19 <hackrilege> i could change the name if its too jarring
16:58:21 <Clownpiece> Or should be.
16:58:26 <hackrilege> yeh it is
16:58:48 <hackrilege> but a Collection of Atoms is not
16:59:07 <Clownpiece> Yeah, but Collection is.
16:59:08 <hackrilege> well it is because Atoms are Containers...
16:59:17 <glguy> kqr: text seems to ask the Handle what line ending mode its using, so maybe your Handle is funny (or maybe you're just using Windows?)
16:59:18 <Clownpiece> And Container is.
16:59:29 <hackrilege> but as really Atoms are just Vec Double and not Vec, an Atom isnt really a Functor
16:59:44 <Clownpiece> Yeah, but it doesn't have to be.
16:59:58 <Clownpiece> You have the doToAtom function.
16:59:59 <hackrilege> yeh so im letting people use Atom as a functor, even though it isnt! *sneaky*
17:00:11 <Clownpiece> Well..
17:00:20 <hackrilege> because basically its made of one, which we would like to access as if it were a Functor
17:00:22 <Clownpiece> Its restricted in the way you want it too be.
17:00:39 <hackrilege> doToAtom is basically depreciated but shows whats going on
17:00:49 <Clownpiece> I would keep it.
17:00:55 <hackrilege> indeed
17:01:09 <kqr> glguy, no idea actually, but I found it quicker to just sed the files correctly. it's the first time text has done that for me
17:01:25 <Clownpiece> Yes, its just a restricted version of fmap, but it will make the types work out a lot better in code that uses this.
17:02:11 <hackrilege> actually I think its nesacary because it communicates the type restriction yeh...
17:02:54 <Clownpiece> I don't see anything wrong with your paste actually.
17:03:01 <hackrilege> but we cant really tell that a Molecule uses the Graph construction methods...
17:03:20 <hackrilege> and we lose the default constructors from the datatypes Atom and Molecule
17:03:42 <Clownpiece> Not sure what you mean?
17:03:56 <Clownpiece> Ah you used to have them be data types?
17:04:04 <hackrilege> nolonger is data Atom = Atom {...}
17:04:11 <hackrilege> yeh
17:04:27 <hackrilege> then have accessors to the non functory bits nicely
17:04:34 <hackrilege> its a headache really
17:05:37 <hackrilege> id love atoms and molecules to be functors, but the have to be Vec Double, not Vec. you cant have Molecules as Collections of Vec (a->a) that would be insane. 
17:05:44 <hackrilege> no applicative mollecules here
17:06:15 <Clownpiece> They are functors.
17:06:21 <hackrilege> but vecors can be of functions, and i want to make my mapFold to use them this way
17:06:23 <Clownpiece> In what matters.
17:06:55 <Clownpiece> Yes, but your doToAtom/Molucule is doing what you need.
17:07:02 <hackrilege> but im having trouble restrincting the types with the syntax so have been forced to do this which feels dangerous?
17:07:27 <Clownpiece> Its not dangerous.
17:07:33 <hackrilege> they are performing fmap yes...
17:07:41 <Clownpiece> Yes.
17:08:02 <Clownpiece> So..what would it even mean for Atom to be a "Functor".
17:08:03 <hackrilege> and later i will fold my datastructure
17:08:14 <hackrilege> and map a fold over the neighbours
17:08:19 <Clownpiece> Yes.
17:08:55 <hackrilege> an atom is a functor in the sense that it is among other things, a Vec Double, where Vec is a functor
17:08:59 <hackrilege> among*
17:09:01 <Clownpiece> Yes.
17:09:08 <Clownpiece> Though not among other things.
17:09:14 <Clownpiece> That is the only thing it is.
17:09:33 <hackrilege> its also got a name and a mass
17:09:49 <hackrilege> and its not a functor really as it does not have kind * -> *
17:09:59 <Clownpiece> Yes. so its really a functor because "Collection" is.
17:10:08 <hackrilege> as I had to enforce that Vecs onnly can contain Doubles
17:10:24 <Clownpiece> Sort of?
17:10:37 <Clownpiece> You are getting confused.
17:10:39 <hackrilege> a Molecule is like a functor becase it is a Collection of Atoms, where Collection is a functor
17:11:20 <Clownpiece> "type Atom = Collection x y" means Atom /is/ Collection x y.
17:11:22 <hackrilege> i would like to fmap over the contents of the Molecule, the Collection, but they must only be Atoms in this collection... 
17:11:33 <Clownpiece> *Container
17:11:40 <Clownpiece> You can.
17:11:41 <hackrilege> aha
17:11:48 <hackrilege> great way to confuse me!
17:11:56 <Clownpiece> Sorry.
17:12:04 <hackrilege> i define Collection as a list and its a Functor and a Graph
17:12:55 <hackrilege> and yes i managed to get it to behave like a Functor becuase contaier is
17:13:20 <hackrilege> oh i think in the poste maybe > instance Functor (Container a) where >  fmap f (Container a b) = Container a (fmap f b)
17:13:22 <hackrilege> is what i meannt
17:13:31 <hackrilege> is that make sense
17:13:31 <hackrilege> ?
17:13:35 <Clownpiece> Sure.
17:13:57 <Clownpiece> Wait no.
17:14:35 <Clownpiece> You would need to redefine Container as > data Container a b c = Container a (b c).
17:15:08 <hackrilege> a Molecule is a Container of a Collection, when i say i want to fmap over a Molecule, really i want to fmap over the Collection...
17:15:20 <Clownpiece> Then you could say instance Functor b => Functor (Container a b) where > fmap f (Container a b) = Container a (fmap f b) 
17:15:33 <Clownpiece> So that would do what you want yes?
17:16:15 <Clownpiece> That also makes Container less confusing too..
17:16:38 <hackrilege> hmm im not sure i get it...
17:16:49 <hackrilege> nope
17:16:52 <hackrilege> not ok
17:16:58 <hackrilege> what is c?
17:17:00 <hackrilege> its fixed
17:17:10 <Clownpiece> In Atoms yes.
17:17:17 <Clownpiece> But not in Containers.
17:17:19 <hackrilege> and mollecule
17:18:11 <hackrilege> you have a pattern match error...
17:18:21 <Clownpiece> (Well sort of fixed. You can do fmap (\ _ => "Bob") (atom :: Atom).
17:18:24 <hackrilege> in your definition of fmap
17:18:36 <hackrilege> oh no
17:18:39 <hackrilege> confuse
17:18:54 <Clownpiece> I should have called b "bc".
17:19:00 <Clownpiece> But I was copying you.
17:19:18 <Clownpiece> I think you forgot the parens in the "data" line?
17:20:14 <hackrilege> in data Container a b = Container { attributes ::a , contents :: b} ?
17:21:31 <Bruuuuuuno> Hi, I'm having some trouble with a Data.Serialize. My "deserializeGame" function works, I tested it, but when I try to call decode, it doesn't work. Can someone take a look? http://lpaste.net/139458
17:22:24 <hackrilege> nooooO!! containers dont contain functors...
17:22:50 <hackrilege> they contain functors applied to a type
17:23:34 <Cale> Bruuuuuuno: What happens? Maybe I should try running this code.
17:24:08 <hackrilege> thats the point...
17:24:40 <Cale> Bruuuuuuno: I assume this is Data.Matrix from the matrix package?
17:24:49 <Bruuuuuuno> ya Cale
17:25:38 <Bruuuuuuno> and it give me an error "too few bytes From:	demandInput"
17:26:43 <Bruuuuuuno> I updated the test2 function because it was doing something weird
17:27:02 <Cale> Bruuuuuuno: Oh, right, okay, so your problem is that 'get' isn't producing the appropriate ByteString to parse
17:27:19 <Bruuuuuuno> why?
17:27:36 <hackrilege> im glad we got the bottom of it, what a horrible error...
17:27:41 <Cale> Well, because file is not what you want it to be.
17:28:07 <jeroko> Hi I'm trying to get my head around different orderings in stacks of monad transformers
17:28:09 <Cale> Bruuuuuuno: try  encode test1
17:28:16 <jeroko> Is there any difference between 'type ReaderMaybe r a = ReaderT r Maybe a' and 'type MaybeReader r a = MaybeT (Reader r) a'
17:28:30 <Cale> Bruuuuuuno: the result is not the same as file
17:28:58 <Bruuuuuuno> well, I haven't tested the put yet, I was trying to make the get works first
17:29:26 <Cale> Bruuuuuuno: All that matters is that they correspond with one another, so it's probably best to test them both at the same time.
17:29:48 <Bruuuuuuno> yes, but does decode use put?
17:30:34 <Cale> yes
17:30:36 <Cale> er
17:30:39 <Cale> no, it uses get
17:30:45 <Cale> encode uses put
17:30:54 <Cale> *Main> decode (encode test1) == Right test1
17:30:54 <Cale> True
17:31:03 <Cale> I added some Eq instances in order to test it like taht
17:31:04 <Cale> that*
17:31:58 <Bruuuuuuno> okay so what's wrong then?
17:32:22 <Cale> The problem is that you're applying the wrong parser to the data. Using put on a ByteString is not a no-op
17:33:09 <Cale> In particular, information about the length of the ByteString is serialised and added to the beginning.
17:33:13 <Cale> *Main> encode (BStr.pack "abcde")
17:33:13 <Cale> "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ENQabcde"
17:33:41 <Bruuuuuuno> oh, so what data structure should I use then?
17:33:56 <rjeli> how is syntastic for haskell? is the delay noticeable with ghcmod?
17:34:06 <Cale> Bruuuuuuno: Your code is fine, the bug is in the test.
17:34:41 <Cale> (file is not in the correct file format to be decoded by your Game decoder)
17:35:15 <Cale> However, if you take the Game and apply encode to it, you get a ByteString which *is* in the correct format to be decoded correctly.
17:35:50 <Bruuuuuuno> so, the problem is file?
17:37:15 <Cale> yeah
17:37:31 <Bruuuuuuno> what type should file be?
17:37:38 <Cale> Bruuuuuuno: It doesn't have the expected information about the length of the ByteString to decode at the beginning of it.
17:38:30 <Cale> Bruuuuuuno: (which the instance of get for ByteString looks for)
17:38:39 <hexagoxel> jeroko: no, they both are `r -> Maybe a` plus newtype wrapping
17:40:42 <Bruuuuuuno> Cale: how do I add that length? Because I have the same problem when I read "file" from an actual file
17:40:51 <gamegoblin> Is there an interleave function in base that would have "interleave [1,2,3] [4,5,6] == [1,4,2,5,3,6]" ?
17:40:57 <Cale> Use encode to produce the String
17:41:15 <Cale> gamegoblin: no, but there is transpose
17:41:30 <Cale> interleave xs ys = concat (transpose [xs, ys])
17:41:55 <gamegoblin> hrm. I’ll just make an interleave.
17:42:54 <slack1256> > concat . zipWith (\x y -> x : y : []) $ [1,2,3] [4,5,6]
17:42:56 <lambdabot>      Couldn't match expected type ‘[Integer] -> [a]’
17:42:56 <lambdabot>                  with actual type ‘[Integer]’
17:42:56 <lambdabot>      The function ‘[1, 2, 3]’ is applied to one argument,
17:43:09 <Bruuuuuuno> Cale, I can't encode a file I haven't decoded yet
17:43:12 <slack1256> > concat $ zipWith (\x y -> x : y : []) [1,2,3] [4,5,6]
17:43:14 <lambdabot>  [1,4,2,5,3,6]
17:43:24 <Cale> Bruuuuuuno: hm?
17:43:28 <slack1256> @type interleave
17:43:29 <lambdabot> Not in scope: ‘interleave’
17:44:10 <slack1256> beh, I am sure it is on Data.List
17:44:21 <Bruuuuuuno> I'm supposed to read "file" from an actual file, that already exist. I have to decode it first
17:44:51 <Bruuuuuuno> I can't encode it, I don't have the data
17:44:52 <Cale> Bruuuuuuno: Ah, in that case, just read the file and apply your deserialiser to its contents directly.
17:45:26 <Cale> Bruuuuuuno: The instance of Serialize you wrote has an extra layer of encoding, because it encodes the length of the ByteString
17:45:33 <jeroko> hexagoxel: thanks, that is what I though, but I wasn't sure
17:45:39 <Cale> (and decodes it too)
17:46:25 <Bruuuuuuno> is there is a way to not have that extra layer?
17:47:11 <Cale> Yeah, don't use the get and put for ByteString
17:47:42 <Cale> Instead, you'd write Get and Put actions using the stuff in Data.Serialize.Get and Data.Serialize.Put directly.
17:48:41 <Bruuuuuuno> oooh I get it
17:48:44 <hackrilege> the point is that in essence a functor applied to a type is still a functor?
17:48:50 <hackrilege> sorry...
17:49:08 <Cale> hackrilege: Kind error
17:49:16 <hackrilege>  i know!
17:49:28 <codehero> umm. how would i do this correctly?
17:49:29 <codehero> getPlayers = unlines . readFile
17:49:38 <codehero> without using do
17:49:39 <Cale> codehero: fmap unlines readFile
17:49:47 <hackrilege> but i want to fmap over something that can contain a function, but which in this instance doesnt
17:49:47 <codehero> ohhh. fmap
17:49:49 <codehero> thanks
17:49:52 <Bruuuuuuno> thanks Cale!
17:49:58 <Cale> er, except you need to give readFile an argument
17:50:26 <Cale> So perhaps it would be  fmap unlines . readFile  or else maybe reading a specific file :)
17:51:16 <hackrilege> here i tried to boil it down a bit; http://lpaste.net/139460
17:51:42 <codehero> hrm
17:52:44 <hackrilege> how can I restrict the type applied to a functor to provide to the user, but use fmap internally? is that right?
17:53:54 <slack1256> hackrilege: give it a type signature
17:54:11 <hackrilege> nope...
17:54:13 <hackrilege> maybe
17:54:17 <slack1256> @let mymap :: (a -> b) -> [a] -> [b]
17:54:18 <lambdabot>  .L.hs:148:1:
17:54:18 <lambdabot>      The type signature for ‘mymap’ lacks an accompanying binding
17:54:18 <hackrilege> baybe i dont understand...
17:54:33 <slack1256> @let mymap :: (a -> b) -> [a] -> [b]; mymap = fmap
17:54:34 <lambdabot>  Defined.
17:54:51 <slack1256> mymap (+ 2) [3,4,5]
17:54:57 <slack1256> > mymap (+ 2) [3,4,5]
17:54:59 <lambdabot>  [5,6,7]
17:56:03 <hackrilege> @let mymap :: (Double -> Double) -> [Double] -> [Double]; mymap = fmap
17:56:05 <lambdabot>  .L.hs:151:1:
17:56:05 <lambdabot>      Duplicate type signatures for ‘mymap’
17:56:05 <lambdabot>      at .L.hs:148:1-5
17:56:16 <hackrilege> @let mymap' :: (Double -> Double) -> [Double] -> [Double]; mymap' = fmap
17:56:17 <lambdabot>  Defined.
17:56:40 <hackrilege> im going to kick myself brb
17:56:49 <hackrilege> i dont know how i get confused like this...
17:56:49 <slack1256> ghci is your friend
17:56:52 <codehero> Cale: works. thank you
17:57:06 <codehero> after i figured out that i wanted lines and not unlines....
17:57:11 <codehero> i always confuse them
17:58:03 <hackrilege> it works because your lists are functors
17:58:18 <hackrilege> here my Shopping is not a Functor http://lpaste.net/139460
17:58:26 <hackrilege> thats the point?
17:58:34 <hackrilege> i am confused now
17:59:38 <slack1256> nah yeah, lists implement the functor type class. it means that everywhere a (Functor f) is qualified you can specialize to a list and get something well behaved
18:00:43 <hackrilege> mhmm, and my Bags and Containers are functors too...
18:01:03 <hackrilege> but i struggle to fmap over Bags of Doubles...
18:01:19 <slack1256> if they implement the Functor class then yes
18:01:33 <hackrilege> did you look at the paste/?
18:02:01 <slack1256> give a sec
18:02:15 <hackrilege> how can i define functors with restricted types to the user, but still use fmap internally in this instance?
18:02:47 <slack1256> like we did above...
18:03:25 <hackrilege> i get a horrible error...
18:03:45 <hackrilege> maybe you could apply that rationality to my paste?
18:03:54 <hackrilege> im finding this all very confusing...
18:04:06 <codehero> brick is so confusing...
18:04:11 <slack1256> yep, first Functor expects an argument of king (* -> *) instead of (* -> * -> *)
18:04:23 <slack1256> oh wait
18:04:25 <slack1256> nevermind
18:05:19 <slack1256> Mmm I thought Double wasn't a kind
18:05:36 <slack1256> I mean floating points as types seems just wrong
18:06:00 <slack1256> IIRC you just got Nats as kind and natural numbers as types
18:06:19 <hackrilege> ...
18:06:34 <slack1256> I mean Double means mostly IEEE floating points numbers with NaN and infinity
18:06:43 <hackrilege> yes
18:07:09 <hackrilege> the point is i have restricted the type, so it cant act as a function for fmap
18:07:17 <hackrilege> but the underlying functor could...
18:07:28 <slack1256> yeah but Double isn't a kind, not even with DataKinds
18:07:28 <hackrilege> so maybe we can use your wizidarry from before
18:08:51 <darkmercenary> hey im trying to build keter with stack right now and it has a problem resolving some dependency
18:09:00 <hackrilege> i know, it need to be a kind so it could be a function, however, i want to restrict the thing so the user only contains a specific type...
18:09:11 <nitrix> How is it that there's never any drama here? Is Haskell such a language for elitists that the only people interested in it already reached social enlightment?
18:09:17 <darkmercenary> i got around it by just overriding the stack yaml file
18:09:35 <darkmercenary> is this something i should post up as an issue or what
18:09:43 <nitrix> Kind of uncalled for, but I just had that thought.
18:09:45 <hackrilege> ...
18:10:00 <slack1256> nitrix: nah, we got #haskell-blah for that
18:10:07 <caconym_> nitrix: do other languages' irc chats have drama? this is the only one I pay attention to
18:10:34 <slack1256> hackrilege: Your error is wanting to use Double as a kind
18:10:39 <nitrix> Fairly often, but I think slack1256 nailed it. Surely that helps filtering the topics.
18:10:46 <hackrilege> but bag takes a kind
18:10:52 <hackrilege> like your list above
18:11:09 <hackrilege> and you restricted its exported type be redefining map
18:11:13 <codehero> kinds... i'm happy that types and kinds will soon be the same exact thing
18:11:14 <slack1256> my list didn't take a kind, it took a type
18:11:25 <codehero> then i won't have to worry about understanding kinds. lol
18:11:47 <hackrilege> ...
18:11:47 <hackrilege> damn
18:11:53 <slack1256> codehero: kinds are to types like types are to terms
18:11:56 <hackrilege> sorry i still dont get i
18:11:58 <hackrilege> it
18:12:09 <codehero> slack1256: makes sense
18:12:18 <codehero> but it's still confusing. like what is * supposed to mean
18:12:21 <hackrilege> so the wizzardry cannot help here?
18:12:23 <codehero> and why is every kind just *
18:12:41 <hackrilege> kind can be  * -> *
18:12:47 <hackrilege> * can be any type
18:12:50 <hackrilege> i think...
18:13:32 <heatsink> :kind []
18:13:40 <heatsink> @kind []
18:13:42 <lambdabot> * -> *
18:14:06 <hackrilege> @kind [()]
18:14:07 <lambdabot> *
18:14:15 <android1> hi
18:14:19 <hackrilege> hi
18:14:42 <nitrix> Is there any other good wiki articles, comparable to the amazing `Typeclassiopedia` that I would miss out as a beginner if I don't read them?
18:16:15 <jeroko> @kind MonadTrans
18:16:16 <lambdabot> ((* -> *) -> * -> *) -> Constraint
18:16:22 <codehero> huh
18:16:26 <slack1256> codehero: (*) it is the kind of lift objects of haskell. normally correspond to normal datattypes
18:16:27 <jeroko> what does the Contraint mean?
18:16:30 <slack1256> @kind Maybe
18:16:31 <lambdabot> * -> *
18:16:32 <Fay> typeclassopedia is awesome.  ive found myself reading it over and over again, learning more things each time
18:16:37 <slack1256> @kind Maybe Int
18:16:38 <lambdabot> *
18:16:43 <hackrilege> iv got to go...
18:17:09 <nitrix> Fay: I'm in the process. Have you found anything else?
18:17:14 <slack1256> (->) correspond to morphism between types of kind (*)
18:17:14 <Fay> yeah 
18:17:17 <slack1256> @kind (->)
18:17:19 <lambdabot> * -> * -> *
18:17:26 <slack1256> @kind (Int ->)
18:17:28 <lambdabot> parse error on input ‘)’
18:17:29 <dfranke> jeroko: Constraint is the kind of things that can go before the => in a type.
18:17:36 <caconym_> i need to read typeclassopedia again and anything else similar... I'm constantly having "duh" moments even though I've been using Haskell for a few years
18:17:40 <slack1256> @kind (->) Int
18:17:42 <lambdabot> * -> *
18:17:44 <hackrilege> thanks for your help
18:17:46 <caconym_> like I just learned about GeneralizedNewtypeDeriving
18:17:46 <slack1256> @kind (->) Int Double
18:17:47 <lambdabot> *
18:18:05 <slack1256> Constrain is as dfranke said
18:18:13 <slack1256> @kind Monad
18:18:14 <lambdabot> (* -> *) -> Constraint
18:18:21 <nitrix> Fay: Can I ask you for links (if they are readily available)?
18:18:33 <hackrilege> i still dont know how to restrict the exposed type, but maybe ill get it later...
18:18:33 <slack1256> there is also for unlifted types like machine word sized
18:18:39 <Fay> http://dev.stephendiehl.com/hask/
18:18:46 <slack1256> @kind (Int#)
18:18:47 <lambdabot>     Not in scope: type constructor or class ‘Int#’
18:18:47 <lambdabot>     Perhaps you meant one of these:
18:18:47 <lambdabot>       ‘Int’ (imported from Data.Int), ‘Int8’ (imported from Data.Int)
18:18:56 <slack1256> @let import Data.Int
18:18:57 <lambdabot>  Defined.
18:18:59 <slack1256> @kind (Int#)
18:19:00 <Fay> http://shuklan.com/haskell/
18:19:00 <jle`> why isn't (,) :: Constraint -> Constraint -> Constraint
18:19:00 <lambdabot>     Not in scope: type constructor or class ‘Int#’
18:19:01 <lambdabot>     Perhaps you meant one of these:
18:19:01 <lambdabot>       ‘Int’ (imported from Data.Int), ‘Int8’ (imported from Data.Int)
18:19:13 <nitrix> Fay: Oh swwweeet. Appreciated :)
18:19:14 <caconym_> stephen diehl also has some cool tutorials
18:19:24 <Fay> https://wiki.haskell.org/Roll_your_own_IRC_bot
18:19:27 <ttt_fff> after updating the dependences in blah.cabal, how do I tell cabal "in the current sandbox; reinstall all dependencies?" (i'd prefer to not rm -rf .cabal-sandbox and create a new sandbox)
18:19:35 <caconym_> like "write you a haskell" which I haven't done but seems mightily intriguing
18:20:04 <caconym_> oh oh also this: http://artyom.me/lens-over-tea-1
18:20:11 <ttt_fff> I don't think it scomplete yet (write you a haskell)
18:20:38 <caconym_> lens over tea was a HUGE help to me trying to understand lenses a while ago, I still need to finish it (or what's there so far)
18:20:42 <nitrix> Fay: That's a cool one too. I've been watching videos on YouTube of haskell coding sessions; there's something mesmizing about the workflow.
18:20:56 <nitrix> Fay: I actually learned about type holes this way. Super super invaluable.
18:21:29 <codehero> Fay: looks pretty cool
18:21:39 <Fay> indeed
18:21:50 <Fay> nitrix: whats a type hole
18:22:38 <codehero> has anyone here used brick before?
18:22:57 <Fay> https://github.com/sdiehl/wiwinwlh/tree/master/src
18:23:09 <Fay> invaluable ^
18:23:38 <codehero> oh
18:23:40 <codehero> that's awesome
18:23:44 <codehero> actual examples
18:23:51 <nitrix> I meant typed hole. It's as simple as writing `_`. I think it's a GHC-specific compiler feature, some sort of bottom type expression like `undefined`, but the compiler trips on it and gives you the type of the expression needed to replace it along everything declared in the scope and their types.
18:24:29 <nitrix> Fay: So, effortlessly, someone could just match these definitions like puzzle pieces and end up with a Functor instance implementation or whatever, by just matching types.
18:24:42 <Fay> thats really awesome
18:24:55 <nitrix> I thought it was really nice. https://www.youtube.com/watch?v=52VsgyexS8Q
18:24:58 <Fay> nitrix: do you have an example of code doing that? or a video?
18:25:44 <nitrix> Fay: The guy is using the old way of doing things before it became a feature of GHC 7.8.something...
18:25:49 <nitrix> I'm still new to this whole thing.
18:32:35 <nitrix> > let test g h = _ :: (a -> b) -> b
18:32:36 <lambdabot>  <no location info>:
18:32:37 <lambdabot>      not an expression: ‘let test g h = _ :: (a -> b) -> b’
18:32:43 <nitrix> @let test g h = _ :: (a -> b) -> b
18:32:43 <lambdabot>  Parse failed: Parse error in expression: _
18:33:19 <nitrix> Fay: Mhhh, I'm not sure how lambdabot works either but you can try that in ghci.
18:34:22 <geekosaur> > let test g h = _ :: (a -> b) -> b in 0
18:34:24 <lambdabot>      Found hole ‘_’ with type: (a2 -> b1) -> b1
18:34:24 <lambdabot>      Where: ‘a2’ is a rigid type variable bound by
18:34:24 <lambdabot>                  an expression type signature: (a2 -> b1) -> b1
18:34:32 <nitrix> Truncated :/
18:34:57 <htebalaka> are there any pure datatypes that act like Data.Vault? with operations like "lookup :: Key a -> SomeStore -> Maybe a", "write :: Key a -> a -> SomeStore -> SomeStore"... 
18:35:23 <htebalaka> "newKey :: IO (Key a)" being the issue with Data.Vault
18:35:56 * geekosaur is not sure what that is supposed to mean
18:36:13 <ReinH> htebalaka: how is Data.Map different?
18:36:21 <geekosaur> Data.Map and Data.HashMap can both do things like that, but if the point of Data.Vault is persistence then it is necessarily impure and in IO
18:36:38 <dramforever> hmm...
18:36:42 <htebalaka> ReinH: can't store multiple types in the vault
18:36:43 <dramforever> type safety?
18:37:34 <htebalaka> it's not a pressing need, i'm just curious if you could make a non-mutable version of the ST monad in theory, which means needing to be able to have multiple types of state
18:38:22 <geekosaur> it's entirely possible to store multiple types if you make the type (part of) the key; see Data.Typeable
18:38:24 <htebalaka> but newSTRef seems to be hard to implement
18:39:07 <geekosaur> (the value is an existiential with a Typeable constraint; the Typeable (part of the) key can then be used to get the original value)
18:39:54 <htebalaka> i was thinking of that (some of the discussion on Data.Vault mentioned it), but i was curious if typeable was necessary
18:40:41 <htebalaka> not all types are typeable (rank N types for instance)
18:41:51 <htebalaka> although maybe that's not an issue if you just wrap the types in a newtype first
18:42:08 <geekosaur> you're not going to be doing it in Haskell if you don't use Typeable. STRefs and IORefs use lower level things to do their work
18:42:28 <geekosaur> that said, I think Typeable extension to handle those kinds of things is planned for future ghc versions
18:43:10 <Fay> nitrix: that video is so fucking cool thanks
18:43:23 <Fay> sorry about my 'french'
18:44:05 <nitrix> Fay: No worries, I speak more languages than I have fingers. :P
18:44:42 <nitrix> Fay: I'm not sure I understood the whole video. Like I said, he's doing things the old school way, now it's a compiler feature and it seems very cool.
18:44:54 <nitrix> Fay: Probably requires some practice but ah. Now we're even :P
18:45:23 <Fay> wait wait how is that process a compiler feature?
18:48:16 <nitrix> Instead of having the ScopedType extension and using dummy types like he did, you can just type _ now.
18:48:38 <nitrix> GHC will give you a complete breakdown.
18:48:55 <Fay> nitrix: OH okay i understand..way cool
19:03:07 <dmj> any relational-record users here?
19:04:37 <OutlawStar> question, what would be the best way to do add an "m a" to an " m [a]", so basically a:[a].
19:05:54 <exio4> OutlawStar: (:) <$> ma <*> mas 
19:07:06 <pacak> :t liftM2 (:)
19:07:07 <lambdabot> Monad m => m a -> m [a] -> m [a]
19:07:18 <OutlawStar> thx  exio4
19:07:32 <OutlawStar> or pacak
19:07:35 <pacak> :t liftA2 (:)
19:07:37 <lambdabot> Applicative f => f a -> f [a] -> f [a]
19:07:38 <OutlawStar> thats nice to
19:15:00 <gamegoblin> Urg, wish Data.Sequence had intersperse
19:19:14 <SrPx> If I have a recursive function that produces a list... something like: foo 0 = [1]; foo n = foo (n-1) ++ foo (n-1); ... what is the most convenient/simpler way to fix its asymptotic? Is it Data.Sequence, or...?
19:20:42 <exio4> SrPx: is it the same expression? you can make it linear by just doing let z = foo (n-1) in z ++ z for that specific case
19:21:04 <SrPx> nah, the actual expression isn't that balanced
19:21:12 <htebalaka> SrPx: if you're concerned about the appends then DList
19:21:33 <SrPx> I think that's it, ty
19:23:58 <mgsloan_> I'm pretty sure this doesn't exist, but is there by chance a type level failure like (Fail :: Symbol -> k) ? I pretty much just want to give error messages in a closed type family
19:24:42 <mgsloan_> I guess (Fail :: a -> k) would be even better
19:25:20 <dramforever> ("Error" ~ "message")?
19:25:28 <SrPx> that was the first occurrence of underscores I've seen on hackage https://hackage.haskell.org/package/dlist-0.7.1.1/docs/Data-DList.html 
19:25:33 <SrPx> tell the lib owner I love him
19:26:31 <htebalaka> msgloan_: Data.Singletons uses some sort of promoted version of error iirc, but I have no idea what exactly it accomplishes. a lot of the source is machine generated i think
19:29:23 <mgsloan_> dramforever: Something like that, yes.  That has kind Constraint, though, and I need it to be polykinded
19:29:31 <mgsloan_> htebalaka: Thanks, I'll look into it!
19:30:39 <mgsloan_> Ah, very clever.  "type family Error (str :: Symbol) :: k" with no instances is sufficient
19:41:04 <SrPx> Is there any function that takes a list of lists and returns its combinations? [[0,1],[0,1],[0,1]] → [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]] ... I know I can use the applicative instance for that but I recall that function also existed
19:41:59 <SrPx> possibly replicateM? but I don't remember if it is fast
19:42:32 <Hijiri> sequence right?
19:42:51 <Hijiri> or just replicateM like you said
19:43:16 <Hijiri> if they're all the same list at least
19:43:29 <Hijiri> > sequence [[0,1],[2,3],[3,4]]
19:43:30 <lambdabot>  [[0,2,3],[0,2,4],[0,3,3],[0,3,4],[1,2,3],[1,2,4],[1,3,3],[1,3,4]]
19:43:56 <dmj> > replicateM 2 [0,1]
19:43:58 <lambdabot>  [[0,0],[0,1],[1,0],[1,1]]
19:44:09 <SrPx> oh it was sequence, of course
19:44:21 <SrPx> ty !
19:44:39 <jle`> SrPx: you want do { x <- xs; y <- ys; z <- zs; return [x,y,z] }, so that's just sequence :)
19:44:48 <SrPx> obviously
19:45:16 <erisco> been trying really hard to get (Monad m, Monad m') => m (m' a) -> m' a  to mean something special
19:45:44 <erisco> but all I have is  supplant :: (Monad m, Monad m') => m (m' a) -> m' a   supplant . return = id
19:46:58 <erisco> supplant . fmap supplant = supplant . join    is another possible one, but not sure what that offers
19:47:28 <erisco> also, I am not happy with ambiguous instances... for example, lists could return the first element or the last
19:47:39 <erisco> (but not, say, the second element, that would violate law 2)
19:47:58 <erisco> I don't know if first and last are the only options... if so then maybe it is alright, provide both instances with a newtype wrapper
19:51:07 <exio4> erisco: [e -> a] -> e -> a ? what would that mean for this?
19:51:29 <erisco> there isn't an instance for every pair of monads
19:51:46 <erisco> supplant would be member of a type class
19:52:39 <exio4> but for m or for m'?
19:52:46 <erisco> both
19:52:56 <exio4> so MPTC 
19:53:03 <erisco> yes
19:54:09 <erisco> for example, you can make an instance for (Either b) Maybe
19:54:25 <erisco> there is no instance for Maybe (Either b)
19:54:30 <SrPx> Is there any case against OverloadedLists?
19:54:47 <erisco> every Monad has a reflective instance m m where supplant = join
19:56:36 <erisco> you can instance [] Maybe and I am hoping there are only 2 valid instances
19:56:39 <erisco> not sure
19:57:17 <erisco> I'd like a law to reduce it to 1 but I can't figure out what
19:57:25 <erisco> or to just forbid any list instance
20:01:26 <erisco> [[x,y],[z]]  you need to project the same nth element from each sublist
20:02:20 <erisco> producing a new list, and if you do your projection again this must produce the same result as projecting from [x,y,z]
20:02:37 <hackrilege>  how do i define foldMap for ; newtype Vec a = Vec  (a,a,a)
20:02:37 <hackrilege> ?
20:03:05 <erisco> so you can do the first, [x,z] to [x], which matches [x,y,z] to [x], or you can do last [y,z] to [z], which matches [x,y,z] to [z]
20:03:13 <hackrilege> i define foldl f basecase (Vec (a,b,c)) = basecase `f` a `f` b `f` c
20:03:40 <erisco> any ideas on how to prove there are no other possibilities?
20:04:45 <erisco> hackrilege, you should be able to just reuse the fold from Vec, no?
20:04:54 <hackrilege> i know foldMap :: Monoid m => (a -> m) -> t a -> m but i dont know how to combine the a in the monad because there is not (a->a->a)
20:05:29 <Hijiri> you change them to the monoid before combining
20:05:35 <Hijiri> then you can use <>
20:05:51 <hackrilege> sweet!
20:06:08 <hackrilege> aha, monoids have their own combinator..
20:06:32 <hackrilege> so they intrinsicly embody collections?
20:06:39 <Hijiri> hackrilege: have you taken a look at the typeclassopedia?
20:06:54 <Hijiri> monoids are just things that have an associative operation, and an identity element
20:06:54 <hackrilege> yeh but i didnt memorise it
20:07:01 <Hijiri> did you do the exercises
20:07:17 <hackrilege> so i need to make my Vec an instance of Monoid to use Fold?
20:07:24 <Hijiri> no
20:07:52 <Hijiri> foldMap f (Vec (a,b,c)) = f a <> f b <> f c
20:07:57 <hackrilege> oh the monoid is supplied, its not the vec i get it
20:08:10 <hackrilege> Thanks thats perfect!
20:08:10 <Hijiri> you should do the exercises in the typeclassopedia if you haven't already
20:08:15 <Hijiri> it will help cement your understanding
20:08:21 <hackrilege> i promise i will
20:08:22 <erisco> oh my bad, I was thinking of newtype as type
20:08:23 <Hijiri> instead of having to memorize anything
20:09:01 <Hijiri> at least by rote
20:12:13 <erisco> there are other interchanges to think about... like  m (m' a) -> m' (m a)
20:15:45 * hackagebot moesocks 0.1.0.24 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.24 (JinjingWang)
20:16:12 <erisco> this all comes about from not wanting to rewrite a lib :P
20:20:02 <erisco> exio4, it would be neat to have a function instance but I can't think of what it is yet
20:24:15 <erisco> hrmmm
20:24:27 <erisco> if there was just a class for empty objects that'd be nifty
20:24:38 <erisco> like, there is mempty, but then you're tied to the rest of the Monoid
20:24:57 <erisco> there ought to be something about just being able to invent a particular value at will
20:25:07 <erisco> regardless of whether it is some identity
20:26:26 <erisco> why not... say...  class Proof a where proof :: a
20:27:06 <erisco> proof = Nothing, proof = []
20:27:18 <erisco> some simple things you might want to capture perhaps
20:27:35 <erisco> and you can newtype your heart out for elaborate things
20:28:50 <Hijiri> if you are going to newtype to provide a different proof, why not just provide that value?
20:29:48 <erisco> I can use this as context for another type class, reducing the number of instances I need
20:29:57 <erisco> context for other instances I mean, instances for another type class
20:30:06 <erisco> though, a bug bear
20:30:10 <erisco> with kindness
20:30:29 <erisco> like, you might want  class Proof f where proof :: f a
20:30:31 <erisco> so then what
20:30:49 <hackrilege> argh why is this [] not an instance of my Class...
20:31:01 <hackrilege> i cant equate...
20:31:13 <erisco> I forget what PolyKinds lets you do
20:31:17 <erisco> I am guessing it isn't this
20:31:19 <hackrilege> data Collection a = Collection [((Int,[Int]),a)] deriving (Eq,Show)
20:31:30 <Hijiri> lets you use kind variables I think
20:31:36 <Hijiri> in kind signatures
20:31:38 <hackrilege>  empty (Collection l) = if l == ([]::[((Int,[Int]),Double)]) then True else False
20:31:40 <erisco> I guess I could try   class Trivial f where trivial :: f a
20:31:49 <hackrilege> throws a nasty error
20:31:54 <erisco> that makes some sense too, and actually right now I am particularly interested in * -> * stuff
20:32:12 <hackrilege> sorry  empty (Collection l) = if l == ([]) then True else False
20:32:18 <dramforever> if ... then True else False spotted
20:32:48 <hackrilege> ?
20:32:52 <erisco> which makes this somewhat like Alternative, except without the rest of the baggage
20:33:15 <dramforever> hackrilege: not relevant to your question, but if a then True else False is exactly a
20:33:34 <hackrilege> lol
20:33:37 <erisco> the problem with Alternative is there are ambiguous instances which I can avoid by dropping <|>
20:33:38 <hackrilege> ok
20:33:46 <erisco> for example, Alternative for Maybe
20:33:51 * dramforever didn't find your class
20:34:27 <hackrilege> > class Indexed (i :: * -> *) where >  empty :: i a -> Bool
20:34:29 <lambdabot>  <hint>:1:1: parse error on input ‘class’
20:34:50 <dramforever> oh
20:35:02 <dramforever> @let class Indexed (i :: * -> *) where empty :: i a -> Bool
20:35:03 <lambdabot>  Defined.
20:35:27 <hackrilege> @let empty (Collection l) = if l == []
20:35:27 <lambdabot>  Parse failed: Parse error: EOF
20:35:29 <dramforever> @let data Collection a = Collection [((Int,[Int]),a)] deriving (Eq,Show)
20:35:31 <lambdabot>  Defined.
20:35:51 <dramforever> @let instance Indexed Collection where empty (collection l) = l == []
20:35:51 <lambdabot>  Parse failed: Parse error in pattern: collection
20:35:56 <dramforever> @let instance Indexed Collection where empty (Collection l) = l == []
20:35:57 <lambdabot>  .L.hs:162:10:
20:35:57 <lambdabot>      Ambiguous occurrence ‘Indexed’
20:35:57 <lambdabot>      It could refer to either ‘L.Indexed’, defined at .L.hs:155:1
20:36:06 <dramforever> sigh...
20:36:24 <dramforever> forget about it....
20:37:03 <hackrilege> no instance for indexed [] arising from the use of empty
20:37:17 <dramforever> weird...I don't know why
20:37:18 <Bruuuuuuno> I'm having some ugly code and I'm trying to find a way to refactor it http://lpaste.net/139466
20:37:25 <dramforever> because you didn't use empty at all
20:37:48 <dramforever> Bruuuuuuno: horray, you found the Maybe monad
20:37:53 <dramforever> :t (>>=)
20:37:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:38:15 <dramforever> um...not quite this..
20:38:19 <hackrilege> >  get   (Collection l) i    = let l' = filter ((==i).fst.fst) l in if empty l then error "dont get from empty" else snd $ head $ l'
20:38:20 <lambdabot>  <hint>:1:27: parse error on input ‘=’
20:38:31 <dramforever> Bruuuuuuno: sorry
20:38:40 <hackrilege> thats what throws the errror
20:38:41 <dramforever> failed
20:39:08 <hackrilege> damn
20:39:44 <Bruuuuuuno> yeah no, the maybe monad is the inverse haha
20:41:00 <hackrilege> no instance myClass [] 
20:41:02 <aarvar> Bruuuuuuno: orElse?
20:41:03 <hackrilege> what is this?
20:41:32 <Bruuuuuuno> :t orElse
20:41:33 <lambdabot> Not in scope: ‘orElse’
20:42:59 <hackrilege> data myClass a = myClass [a] deriving Eq
20:43:14 <Bruuuuuuno> I think it could work aarvar
20:44:56 <erisco> well, I guess for Proof a you can do a supplant instance for ((->)a)
20:45:31 <glguy> Bruuuuuuno: You could do a variation of: fromMaybe defaultValue (msum [fmap f foo, fmap g bar, fmap h baz])
20:45:47 * hackagebot rspp 0.1.0.1 - A Rational Street Performer Protocol solver  https://hackage.haskell.org/package/rspp-0.1.0.1 (AlexChapman)
20:46:03 <erisco> for the highly useful () instance lol
20:46:08 <Bruuuuuuno> even is f g and h doesn't have the same signature?
20:46:32 <glguy> Bruuuuuuno: yeah, that's fine. As long as they have the same return type
20:47:28 <Bruuuuuuno> okay, I'll compare both your solutions aarvar and glguy and I'll come back, thanks guys!
20:49:10 <erisco> what is the type for the flip of -> ?
20:50:10 <hackrilege> :t flip (->)
20:50:11 <lambdabot> parse error on input ‘->’
20:50:15 <hackrilege> hmm
20:50:32 <exio4> erisco: you need a newtype for that
20:50:41 <erisco> well yeah, but I presume there is one floating about
20:51:30 <erisco> newtype (-<) a b = (-<) (b -> a)  would be what I'd define
20:51:50 <MarcelineVQ> :k (->)
20:51:51 <lambdabot> * -> * -> *
20:52:24 <erisco> though it is not a Functor, so I suppose I'm not that interested
20:52:36 <exio4> it's a contravariant functor
20:52:46 <erisco> doesn't lead me up to a Monad
20:53:46 <hackrilege> how do i make instances for []
20:55:44 <mjrosenb> can the indentation based parsing ever do away with the need for parentheses, or is it purely to determine scope?
20:56:33 <hackrilege> just scope please
20:57:33 <erisco> be super nice if you could tell ghc when instances are equivalent
20:57:34 <erisco> oh well
21:00:15 <erisco> so... going through all the basic monads... and there aren't many really
21:00:27 <erisco> [], Maybe, (Either b)
21:00:37 <erisco> ((->)r)
21:01:16 <arahael> IO...
21:01:28 <slack1256> just a state monad
21:01:33 <erisco> I can't do anything with that for this, by design
21:01:36 <arahael> He hasn't mentioned state monads.
21:01:39 <mjrosenb> Map a
21:01:57 <mjrosenb> although that is kind of a generalization of []
21:02:17 <erisco> okay, might write one for (Map a), cool
21:02:20 <erisco> maybe Set works too
21:02:24 <slack1256> nah
21:02:35 <erisco> but all my instances look like this   (Monad m', Trivial m') => Supplant Maybe m'
21:02:37 <erisco> except for one
21:02:43 <erisco> (Monad m', Proof a) => Supplant ((->)a) m'
21:02:44 <slack1256> typical problem with Ord and set
21:03:41 <erisco> slack1256, oh right
21:04:11 <erisco> so, there is a theme going on of stuff that can be trivially constructed
21:04:21 <erisco> except for the function instance which is a bit different
21:05:12 <erisco> everything else is suggesting I can lose the MPTC
21:06:20 <erisco> actually I should verify the function instance satisfies my laws
21:08:14 <Xnuk> :t return () otherwise
21:08:14 <lambdabot> ()
21:09:52 <slack1256> If I may ask erisco what are you working on?
21:10:20 <erisco> trying to figure out this type class
21:10:30 <erisco> there is something here and I'm hoping to attract someone smarter :P
21:10:52 <exio4> @type sequence
21:10:54 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
21:11:03 <exio4> erisco: you said something about m (n a) -> n (m a)
21:11:36 <exio4> it's the distributive function needed for `arbitrary` monad composition, isn't it? 
21:11:41 <exio4> I haven't looked much at it
21:13:11 <erisco> :t asum
21:13:12 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
21:13:17 <erisco> there is also that
21:13:22 <slack1256> isn't this what are called commutative monad?
21:13:42 <slack1256> well not monad. but what that notion of n (m a) ~ m (n a)
21:16:26 <erisco> but asum is a bit different
21:17:13 <exio4> erisco: Op is the flipped arrow you might want btw http://hackage.haskell.org/package/contravariant-0.1.2/docs/Data-Functor-Contravariant.html
21:19:10 <erisco> and I don't think I can get 'm a' out of sequence
21:19:18 <erisco> or get  t a -> a
21:19:58 <erisco> so it seems supplant is slightly different
21:30:50 * hackagebot ihaskell 0.6.5.0 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.6.5.0 (gibiansky)
21:30:52 * hackagebot ghc-parser 0.1.8.0 - Haskell source parser from GHC.  https://hackage.haskell.org/package/ghc-parser-0.1.8.0 (gibiansky)
21:40:03 <arahael> This is frustrating.  Trying to re-invent monads in python.
21:40:22 <arahael> And I discover that python's reduce call (ie, fold), is just as good(!)
21:40:28 <Xe> arahael: https://github.com/billpmurphy/hask
21:41:03 <arahael> Xe: I don't see the point of Hask, frankly.
21:41:31 <erisco> asum is actually really close, I can just use it I think
21:41:50 <arahael> Xe: Seems to me that hask woudl be slow - and you'd be fighting the language: You'd be better off using a functional language.
21:42:06 <Bruuuuuuno> Hey guys, here's my version of the problem I was having some minutes ago. glguy : I couldn't use msum because MonadPlus doesn't do what I want, so I used find http://lpaste.net/139469
21:45:59 <arahael> Xe: This is what I've just tried: http://lpaste.net/1635719315221118976
21:46:09 <arahael> Xe: Very naive, but it looks practical, for a python user.
21:46:16 <arahael> (Possibly)
21:46:28 <kristof> Can someone explain to me what some and many are for in the Alternative class?
21:48:26 <arahael> Xe: I'm trying to think about how one might work with Free Monads in python, without forcing a Haskell worldview over it.
21:49:50 <erisco> lol now how do I classify  a -> Char
21:50:11 <roboguy`> arahael: that looks a lot more like the Endo monoid than any Monad instance I'm familiar with
21:51:20 <roboguy`> > (`runEndo` 1) $ foldMap Endo [(2*), (3*), (4*)]
21:51:22 <lambdabot>  Not in scope: ‘runEndo’
21:51:28 <roboguy`> > (`appEndo` 1) $ foldMap Endo [(2*), (3*), (4*)]
21:51:30 <lambdabot>  24
21:51:40 <erisco> this is why you don't make type classes willy nilly
21:51:44 <erisco> this is so annoying XD
21:54:23 <arahael> roboguy`: Hmm, that looks familiar (now I gotta work out what 'endo' is), but the intent there was to use the list as a template for a structure that can be elegantly represented in python.
21:54:40 <roboguy`> @src Endo
21:54:40 <lambdabot> Source not found. Are you on drugs?
21:54:49 <arahael> roboguy`: And effectively replace the list's bind with the particular bind I want, though I simplify it by using int directly rather than an abstract datatype.
21:54:59 <roboguy`> newtype Endo a = Endo { appEndo :: a -> a }
21:56:13 <roboguy`> arahael: how about using the church encoding of Free? That would probably translate a bit easier
21:56:26 <arahael> roboguy`: Well, in the example it's a -> a, indeed; but it works with a -> m a as well. (Though, obviously, you'd have to replace the first argument to the reduce with something that unwraps the argument first - and each lambda would have to return the monad type)
21:57:26 <arahael> roboguy`: I'm not sure what you mean by 'church', let me show a more wordy example:
21:58:11 <roboguy`> arahael: you can represent any algebraic datatype as function. A church encoding is one particular way to do that
21:58:39 <arahael> roboguy`: Ah - that'd use a lot of recursion, wouldn't it?
21:58:39 <roboguy`> since Python has higher order functions but not algebraic data types, I figure a church encoding would work out easier
21:58:48 <roboguy`> Actually, it usually eliminates recursion
21:59:02 <arahael> Hmm, good.
21:59:37 <arahael> Is this a good way to learn about church? https://en.wikipedia.org/wiki/Church_encoding
21:59:49 <roboguy`> this blog post talks about a similar encoding (Boehm-Berarducci) to eliminate recursion: http://www.haskellforall.com/2014/09/morte-intermediate-language-for-super.html
21:59:56 <roboguy`> let's see...
22:01:11 <roboguy`> arahael: it looks like it could be slightly confusing skimming through it, but it could help
22:01:26 <jmcarthur_> Boehm-Berarducci encoding is basically Church encoding adapted to System-F
22:01:30 <roboguy`> arahael: I would have put the Church boolean section first, followed by the Church pair one
22:01:43 <arahael> roboguy`: I'll read the church boolean section first, then.
22:02:15 <roboguy`> Church numerals are probably the most famous church encoding-type thing which is probably why they're first, but they are more complication than booleans and pairs
22:02:19 <arahael> roboguy`: The problem is that a lot of these topics are so abstract.
22:02:22 <erisco> class CharLike a where getChar :: a -> Char
22:02:24 <erisco> the misery
22:03:20 <arahael> roboguy`: This is the form where I'm using a "Monad" type: http://lpaste.net/1635719315221118976
22:04:09 <roboguy`> arahael: ah, that is the identity monad
22:04:32 <arahael> roboguy`: The monad is _not_ the focus of my code, really.
22:04:46 <roboguy`> ah, what is?
22:05:01 <arahael> roboguy`: The focus of the code is the example2() syntax.
22:05:12 <arahael> roboguy`: Which was why I ommited the monad earlier.
22:06:41 <roboguy`> arahael: the goal is to get nice syntax for binds (or bind-like things), I take it?
22:07:08 <arahael> roboguy`: Note how it avoids the bind(bind(bind(bind(bind...))))) mess, though at a cost of poorer scoping?  But yes, the goal is to get a nice(r) syntax.
22:07:21 <arahael> roboguy`: Without using bidirectional yields either.
22:08:04 <arahael> The thinking is, to write your 'notation' using the list and a given monad/bind context that will re-interpret the list in that monad.
22:08:36 <roboguy`> hmm, yeah
22:09:37 <arahael> It's also, I hope, much easier for a python programmer to understand, though honestly I don't think I'll ever use monadic code explicitly in python. (Function calls are too expensive)
22:10:06 <roboguy`> you will have trouble using results from monadic computations that occured previously in the list though (the ability to do this is what separates monads from applicative functors actually)
22:10:48 <roboguy`> there might be a way to pipe those things through, but it probably won't look too nice
22:12:05 <arahael> roboguy`: That is a significant limitation, indeed.  Though you could at least compose the expression.
22:13:35 <arahael> roboguy`: I think I have an idea.
22:15:10 <arahael> nah, too much pain.  The thinking was that one could monitor the argument names used, and capture them and pass that as a binding scope.
22:15:42 <arahael> Such that, for a scope 'a', you could get the previously-bound x argument as a.x
22:17:17 * arahael does not intend to reinvent hask.
22:19:13 <roboguy`> arahael: have you considered operator overloading?
22:19:52 <arahael> roboguy`: Too fugly. (In python), but operator overloading would be ideal in typed languages such as C++.
22:20:39 <arahael> roboguy`: Trouble is python is too finiky when it comes to whitespace. You end up needing to put the whole thing in parenthesis, so you're essentially back to function calls.
22:21:11 <arahael> You end up with (((a + b) + c ) + d)
22:21:13 <roboguy`> arahael: hmm, I don't remember python's whitespace rules with that kind of thing. Haskell is an indentation based language too
22:21:25 <roboguy`> actually, left-associativity would be ideal for this
22:21:55 <arahael> roboguy`: The trouble is putting each expression on it's own line.  You need a () for that.
22:22:01 <arahael> Well, or a + \
22:22:27 <arahael> Which, Hmm, might not be a bad idea.
22:23:05 <arahael> Anyway, back to startrek.  Thanks for helping me think about this. :)
22:23:55 <arahael> The other problem with operator overloading is that the number of operators you can overload is so limited.  + doesn't express >>= to me.
22:24:06 <roboguy`> arahael: how about >>?
22:27:28 <kristof> Can someone briefly explain to me how I would use attoparsec in an applicative way rather than a monadic way?
22:28:07 <kristof> The latter is quite simple and intuitive, but I actually found a tutorial that mostly used <$> and <*> and was surprised.
22:28:09 <erisco> are all Foldable m and Functor m Traversables?
22:29:34 <heatsink> No
22:29:55 <arahael> roboguy`: That can be overloaded!?
22:30:06 <Cale> erisco: Traversable is a subclass of Foldable (for some reason)
22:30:08 <heatsink> It may not be possible to go through all the values of a Functor one by one
22:30:20 <erisco> Cale, and Functor
22:30:20 <moop> !learn
22:30:33 <Cale> erisco: Right, so it's the other way around
22:30:48 <Cale> If some type is Traversable, then it must be a Functor and Foldable
22:30:51 <erisco> right, I am just checking there are actualy counter examples
22:31:27 <Cale> Yeah, (->) e should be a good example
22:31:28 <arahael> roboguy`: Looks like it can.  So, I guess >>\ might be an option.
22:31:34 <Cale> For Functor
22:31:52 <Cale> (or most Monads)
22:32:51 <Cale> As for examples which separate Foldable and Traversable, those are less obvious. They probably exist in practice. I don't know if they exist theoretically as well.
22:33:16 <Cale> (people are allowed to define an instance of Foldable and leave out a corresponding Traversable instance)
22:33:51 <Cale> It's hard to really say what Foldable instances are meant to satisfy, so talking about it theoretically is difficult
22:34:54 <Cale> (I kind of dislike Foldable for this reason, I'm not sure it should be a superclass of Traversable, and I'm also not sure it should be in the Prelude. Traversable is much better specified.)
22:36:46 <erisco> Cale, such as foldMap = const mempty?
22:36:55 <heatsink> Would a Set be foldable but not traversable?
22:37:28 <arahael> roboguy`: Nope, operator overloading, even with \, is pretty crap: http://lpaste.net/1635719315221118976
22:37:38 <arahael> roboguy`: So I think folding lists is the winner.
22:38:11 <arahael> Although that isn't _too_ bad.
22:38:26 <heatsink> Since you can fold over a set, but you can't map over a set
22:39:47 <roboguy`> arahael: shouldn't the parens go the other way round?
22:40:19 <arahael> roboguy`: No?
22:41:08 <roboguy`> oh, right
22:42:15 <erisco> uhh
22:42:19 <erisco> what is regexec supposed to do
22:42:33 <arahael> roboguy`: A trap for a naive haskell user, looking at that python code, though, is that that's >>=, not <<-
22:42:35 <arahael> *<<=
22:42:48 <arahael> (Did I get that right?)
22:43:00 <arahael> The lambda x: M(5), does not effectively bind 5 to x.
22:43:21 <arahael> x is the unwrapped result of the previos value.
22:43:53 <arahael> Anywya, I really am going now!
22:44:36 <roboguy`> > Identity 1 >>= (return . (*2)) >>= (return . (*3)) >>= (return . (*4))
22:44:38 <lambdabot>  Identity 24
22:44:59 <roboguy`> arahael: good luck with it. Come back any time you have more questions!
22:45:07 <arahael> Definitely.
22:47:02 <erisco> I guess I just copy and paste the default implementation lol
22:47:06 <erisco> that is what all three modules have done
22:47:11 <erisco> this thing is completely weird
22:47:14 <erisco> someone please rewrite it
22:50:11 <erisco> what that thingie that formats Haskell code
22:50:16 <erisco> and does it plugin for notepad++
22:54:51 <erisco> did context aliases ever make it in?
23:16:51 <joco42__> any idea why I might get this puzzling error message when installing cpython from hackage ? http://lpaste.net/139485
23:26:03 <erisco> I wonder if  Maybe Char -> Char is sensible with  Nothing = '\0'
23:30:02 <bycn82> hi, need help
23:30:30 <erisco> bycn82, shoot
23:32:18 <erisco> you can ask in this channel
23:33:44 <bycn82> i am trying to write a function to count the "number of characters in the string"
23:33:48 <bycn82> http://lpaste.net/139488
23:33:56 <bycn82> the substr function is working,
23:34:20 <bycn82> the problem is len_words functions
23:34:47 <mauke> line 5 can be removed; line 6 should start len_words (str : mores) =
23:35:11 <mauke> [x] is syntactic sugar for (x : [])
23:35:20 <mauke> [str:mores] means ((str : mores) : [])
23:36:00 <erisco> so, you're finding the total length of a list of words?
23:37:08 <erisco> make your version work and then I'll show you another version
23:37:22 <mauke> I'll do the third version, then
23:37:50 <bycn82> http://lpaste.net/139489
23:38:11 <bycn82> it works,
23:38:25 * arahael will do a fourth, useless, version.
23:38:27 <erisco> note that line 3 is not needed, it is covered by line 4
23:38:31 <mauke> bycn82: you still don't need line 3
23:38:44 <bycn82> i see,
23:38:48 <erisco> when mores = [] then len_words [] = 0 as you've written
23:38:53 <erisco> so line 3 doesn't add anything
23:39:27 <erisco> well, to continue,  strlen str + len_words [] = strlen str + 0 = strlen str
23:39:30 <erisco> so it is the same as line 3
23:40:11 <erisco> now try   sum . map strlen
23:40:23 <mauke> length . concat
23:41:12 <erisco> that works a bit differently but sure :)
23:41:25 <erisco> arahael, your turn
23:41:53 <erisco> length xs + length ys = length (xs ++ ys)
23:42:05 * arahael blinks, this isn't #python, and curses being in two channels at once.
23:42:09 * arahael looks at the problem again.
23:42:26 <erisco> is that one of them monoid homomorphisms?
23:42:33 <bycn82> len_words str = sum $ map strlen str
23:42:36 <bycn82> thanks
23:42:40 <bycn82> it is amazing!
23:43:07 <erisco> note that you can reduce and do  len_words = sum . map strlen
23:43:30 <mauke> len_words [] = 0; len_words [x] = length x; len_words [x, y] = length x + length y; len_words xs@(x : y : z : _) = (length x + length y + length z) `div` 3 * length xs  -- good enough
23:46:51 <bycn82> len_words $ words "nice to meet you"
23:46:59 <bycn82> result is 12!
23:47:14 <bycn82> it should be 13!
23:47:26 <mauke> it works if you use better words
23:48:21 <erisco> > sum (map length (words "nice to meet you"))
23:48:23 <lambdabot>  13
23:50:01 <int-e> "I am a bit skeptical about mauke's implementation."
23:50:08 <arahael> length . concat . words $ "nice to meet you" -- Let me just test with ghci, still installing haskell on this system...
23:50:19 <erisco> floating point error is acceptable in any character counting program
23:50:53 <erisco> or is it a truncating div...
23:50:55 <erisco> :t div
23:50:58 <lambdabot> Integral a => a -> a -> a
23:51:27 <arahael> Yep.  That works.
23:51:27 <erisco> oh I see. well, for efficiency it just approximates the character count
23:51:45 <arahael> erisco: That's my version. :D
23:52:00 <erisco> arahael, that is what mauke said D:
23:52:11 <arahael> Damn.
23:52:15 <bycn82> i like erisco's version, i can understand it :)
23:52:30 <erisco> so, the length . concat version uses the property I stated above
23:52:43 <erisco> length xs + length ys = length (xs ++ ys)
23:53:18 <erisco> > map length [a,b,c,d]
23:53:19 <lambdabot>      Couldn't match expected type ‘t0 a0’ with actual type ‘Expr’
23:53:19 <lambdabot>      In the expression: a
23:53:19 <lambdabot>      In the second argument of ‘map’, namely ‘[a, b, c, d]’    Couldn't match...
23:53:41 <erisco> > map length [[a,b],[c]]
23:53:43 <lambdabot>  [2,1]
23:53:47 <erisco> no no lambdabot stop it
23:54:06 <erisco> why won't it let me do this
23:54:34 <arahael> length . filter (\x -> x /= ' ') -- Buggy.
23:54:37 <int-e> 'length' is not in a type class that could be abused for "symbolic" computation
23:54:49 <int-e> > map f [a,b,c,d]
23:54:50 <lambdabot>      No instance for (Show b0)
23:54:50 <lambdabot>        arising from a use of ‘show_M65697620552175626002178’
23:54:50 <lambdabot>      The type variable ‘b0’ is ambiguous
23:54:56 <int-e> > map f [a,b,c,d] :: Expr
23:54:58 <lambdabot>      Couldn't match expected type ‘Expr’ with actual type ‘[b0]’
23:54:58 <lambdabot>      In the expression: map f [a, b, c, ....] :: Expr
23:55:08 <mauke> could y'all please stop failing at lambdabot?
23:55:11 <erisco> int-e, hm, I don't know how they make it work, couldn't have predicted that
23:55:13 <int-e> ah, neither ware lists.
23:55:21 <int-e> sorry, I thought I knew I was doing.
23:55:36 <erisco> > [a,b,c]
23:55:37 <lambdabot>  [a,b,c]
23:55:42 <int-e> > map f [a,b,c,d] :: [Expr]
23:55:44 <lambdabot>  [f a,f b,f c,f d]
23:56:11 <nitrix> int-e: Oh, what's that? a lambdabot feature?
23:56:13 <mauke> > let len_words [] = 0; len_words [x] = length x; len_words [x, y] = length x + length y; len_words xs@(x : y : z : _) = round ((genericLength x + genericLength y + genericLength z) / 3 * genericLength xs) in len_words (words "nice to meet you")
23:56:15 <lambdabot>  13
23:56:16 <erisco> okay, seems weird I can't just choose f= length
23:56:44 <int-e> nitrix: https://hackage.haskell.org/package/simple-reflect
23:56:47 <mauke> there is no magic here
23:56:53 <arahael> length $ filter isAlpha "nice to meet you!" -- <-- Better.  erisco I think that qualifies as a fourth version.
23:56:54 <mauke> just a type called Expr
23:57:02 <arahael> Though one that's obviously different.
23:57:45 <erisco> > (map isAlpha "foo_you", words "foo_you")
23:57:46 <lambdabot>  ([True,True,True,False,True,True,True],["foo_you"])
23:57:53 <nitrix> Could I get a list of packages lamdabot has?
23:57:59 <erisco> doesn't seem to match
23:58:23 <arahael> erisco: Yes - it's different, one must ask: What is a word?
23:58:31 <bycn82> this is my version, http://lpaste.net/139490
23:58:33 <erisco> 'words' will tell you
23:58:57 <arahael> So the implementation defines the meaning.
23:59:12 <bycn82> but i was thinking, currently the len_words accept  list as parameter,
23:59:30 <erisco> mauke, it'd be swell if I could somehow pick f = length
23:59:36 <rohansumant> > words <$> "a b c"
23:59:36 <bycn82> how can I modify it and make it accept string direclty
23:59:37 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
23:59:37 <lambdabot>      Expected type: [String]
23:59:37 <lambdabot>        Actual type: [Char]
23:59:39 <mauke> erisco: what does that even mean?
23:59:55 <erisco> I don't know, what do you mean what does it mean?
