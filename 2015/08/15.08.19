00:06:50 <ttt_fff> does irrefutable pattern match fail trigger mfail ? if not, is there a way to fake it
00:07:12 <ttt_fff> i'm implementing a moand with support for failure, and I want to be able to catch irrefutable pattern match fails
00:07:38 * hackagebot hemokit 0.6.6 - Haskell port of the Emokit EEG project  https://hackage.haskell.org/package/hemokit-0.6.6 (NiklasHambuechen)
00:07:38 * hackagebot harmony 0.1.1.0 - A web service specification compiler that generates implementation and tests.  https://hackage.haskell.org/package/harmony-0.1.1.0 (SantiMunin)
00:07:42 <arkeet> irrefutable pattern match where?
00:08:53 <quchen2> mfail doesn't exist (and never will)
00:09:03 <quchen2> It'll still be called fail
00:09:19 <quchen2> And irrefutable patterns won't generate fails, no
00:09:26 <quchen2> ttt_fff: ^
00:09:35 <arkeet> oh I missed the "irrefutable" part yeah.
00:09:35 <jle`> ttt_fff: you can see desugaring using @undo
00:09:42 <arkeet> you can't catch those
00:09:54 <jle`> @undo do { Just x <- Nothing; return (x + 1) }
00:09:54 <lambdabot> Nothing >>= \ a -> case a of { Just x -> return (x + 1); _ -> fail ""}
00:10:01 <jle`> @undo do { ~(Just x) <- Nothing; return (x + 1) }
00:10:02 <lambdabot> Nothing >>= \ ~(Just x) -> return (x + 1)
00:10:03 <arkeet> the only ones that will trigger "fail" are failed pattern matches in <- statements
00:10:21 <arkeet> irrefutable pattern matches never fail.
00:10:58 <jle`> note that the ~ gets rid of the case statement and the block where fail is potentially launched
00:15:21 <blazen> whats happening?
00:19:55 <zipper> Can I -ddump-hi -ddump-to-file and also pass ghc a dir in which to put these .hi-dump files in?
00:27:10 <cocreature> zipper: iirc there is -ddumpdir
00:27:24 <cocreature> ah no I think it has only one d
00:27:26 <zipper> cocreature: Thanks
00:27:40 <cocreature> see here https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/separate-compilation.html
00:28:51 <zipper> Thanks a ton :)
00:28:58 <cocreature> np :)
00:30:19 <mada> how do you go about helping infer the type of an esqueleto select without printing an entity field afterwards?
00:36:42 <dramforever> "helping infer the type" add a type signature
00:52:33 <mada> thanks. Changing the return type of the function from IO [Something] to IO [Entity Something] helped infer the type.
00:52:55 <dramforever> mada: yw =)
01:08:09 <zipper> Say I have two lists. One of all files. Another of files to ignore.
01:08:23 <zipper> The one of files to ignore is a subset of all files.
01:08:43 <zipper> How do I "subtruct" a list from another?
01:08:44 <dramforever> :t (\\) -- warning: inefficient
01:08:45 <lambdabot> Eq a => [a] -> [a] -> [a]
01:08:47 <dramforever> > [1,2,3,4,5,6,7]
01:08:48 <lambdabot>  [1,2,3,4,5,6,7]
01:08:53 <dramforever> > [1,2,3,4,5,6,7] \\ [1,2,6,3]
01:08:54 <lambdabot>  [4,5,7]
01:09:16 <dramforever> I wonder how efficient this is
01:10:03 <zipper> Thanks
01:10:29 <ggole> Quadratic, given the bound
01:27:42 <frerich> zipper: A more efficient and only marginally more prosaic way would be to use Data.Set, e.g. 'toList (fromList allFiles `difference` fromList ignoredFiles)'. Assuming that 'ignoredFiles' doesn't change you could even avoid the second 'fromList' call.
01:31:40 <frerich> zipper: If both lists are sorted, you wouldn't even need that but could go with something which traverses two lists in parallel, something like http://lpaste.net/139191 (I sense there's a nicer way to define that, something based on 'tails' maybe - but I cannot think of it right now)
01:36:16 <frerich> This reminds me of a nice 'A-ha!' moment I recently had. It was about the problem of finding the smallest number which is not in a given (potentially unsorted) list of numbers. Turns out there's an O(n) solution for this!
01:44:55 <flux> frerich, find the smallest one and subtract one?-)
01:45:39 <bennofs> are the numbers limited to n >= 0 ? (so for [0,1,2,4], the answer is 3?)
01:47:24 <frerich> Sorry, yes - this is about non-negative numbers.
01:47:37 * hackagebot pandoc-crossref 0.1.4.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.4.0 (lierdakil)
01:48:15 <frerich> flux: Yeah, that would work. Alas, I forgot to mention that the numbers are >= 0 :-)
01:48:39 <frerich> So a sample list might be [4,5,1,2,0,6,3,6,3,21,1,7]
01:49:14 <flux> well, didn't figure it out yet. need to keep thinking :)
01:50:05 <cocreature> bird shows two solutions to this problem in "pearls of functional algorithm design" iirc
01:50:31 <frerich> cocreature: Yeah, that's exactly where I got it from. It's the first item even. I tried to do it myself but never found a way to avoid the sorting.
01:50:46 <bennofs> frerich: is the algorithm single-pass?
01:55:46 <frerich> bennofs: I learned two ways to do this, one requires two passes and the other one - I think it would qualify as 'single pass', yeah.
01:57:15 <frerich> bennofs, flux: If you like this kind of stuff, I can really recommend the book cocreature mentioned - 'Pearls of Functional Algorithm Design' by Richard Bird.
01:57:37 <frerich> For me, it was almost too fast-paced in the explanations of how some things work, ymmv
01:58:13 <merijn> Also, any of the Functional Pearl papers and Okasaki
01:59:15 <quchen2> Do the "functional pearl" papers somehow belong together, or can anyone just publish one?
01:59:51 <merijn> quchen2: They're a recurring theme (workshop, maybe) at ICFP
01:59:59 <frerich> quchen2: In the book, it is explained that many (all?) of the pearls have been published somewhere in the past, I believe 'Journal for Functional Progrmaming' was mentioned.
02:00:09 <merijn> oh, might be JFP, yeah
02:05:35 <zipper> intercalate [pathSeparator] "A.B.C"
02:05:39 <zipper> > intercalate [pathSeparator] "A.B.C"
02:05:40 <lambdabot>  Not in scope: ‘pathSeparator’
02:05:51 <zipper> > intercalate ['/'] "A.B.C"
02:05:53 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
02:05:53 <lambdabot>      Expected type: [[Char]]
02:05:53 <lambdabot>        Actual type: [Char]
02:06:06 <zipper> > intercalate ["/"] "A.B.C"
02:06:07 <lambdabot>      Couldn't match type ‘Char’ with ‘[[Char]]’
02:06:07 <lambdabot>      Expected type: [[[Char]]]
02:06:07 <lambdabot>        Actual type: [Char]
02:06:46 <pyon> Is there any pipes-compatible package for manipulating `Text` streams, rather than `String` ones?
02:06:56 <dario> > intercalate '/' "a.b.c" -- zipper
02:07:01 <frerich> zipper: I'm not sure what you're trying to do... but maybe you're looking for the function 'intersperse'?
02:07:01 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘Char’
02:07:05 <lambdabot>      In the first argument of ‘intercalate’, namely ‘'/'’
02:07:07 <lambdabot>      In the expression: intercalate '/' "a.b.c"    Couldn't match type ‘Char’...
02:07:17 <dario> hm... no.
02:07:19 <jle`> :t intercalate
02:07:19 <dario> :t intercalate
02:07:20 <lambdabot> [a] -> [[a]] -> [a]
02:07:21 <lambdabot> [a] -> [[a]] -> [a]
02:07:27 <merijn> pyon: Why would you need a separate package?
02:07:59 <MarcelineVQ> > intercalate "/" ["A","B","C"]
02:08:01 <lambdabot>  "A/B/C"
02:08:20 <merijn> pyon: I think there was one, but it's trivial to roll your own producer anyway
02:08:30 <pyon> Oh, well.
02:08:36 <lpaste_> merijn pasted “ByteString pipes” at http://lpaste.net/139196
02:08:50 <merijn> pyon: I just wrote that when I needed to deal with BS from a socket
02:11:02 <merijn> pyon: I thought there was one a text version of like pipes-bytestring, but I can't find it anymore
02:11:19 <merijn> Oh, the search is just bad
02:11:23 <merijn> It's literally pipes-text
02:12:07 <pyon> merijn: Ah... For some reason, Hoogle couldn't find it. :-|
02:12:14 <pyon> merijn: But thanks!
02:12:24 <cocreature> the new hoogle can http://hoogle.haskell.org/?hoogle=pipes%20text
02:17:40 <merijn> @remember Unknown When all you have is a HammerFactoryImpl, every problem looks like an INailIter.
02:17:40 <lambdabot> Good to know.
02:18:51 <frerich> cocreature: Oooh... a new Hoogle? Was this mentioned anywhere?
02:20:38 * frerich finds http://neilmitchell.blogspot.co.uk/2015/01/hoogle-5-is-coming.html
02:22:39 * hackagebot apportionment 0.0 - Round a set of numbers while maintaining its sum  https://hackage.haskell.org/package/apportionment-0.0 (HenningThielemann)
02:27:40 * hackagebot apportionment 0.0.0.1 - Round a set of numbers while maintaining its sum  https://hackage.haskell.org/package/apportionment-0.0.0.1 (HenningThielemann)
02:27:42 * hackagebot sloane 4.0.0 - A command line interface to Sloane's OEIS.  https://hackage.haskell.org/package/sloane-4.0.0 (AndersClaesson)
02:28:36 <quchen2> frerich: It's been in dev state for quite some time now
02:28:45 <quchen2> Neil didn't formally announce it I think
02:37:40 * hackagebot satchmo 2.9.9.1 - SAT encoding monad  https://hackage.haskell.org/package/satchmo-2.9.9.1 (JohannesWaldmann)
02:42:40 * hackagebot sloane 4.0.1 - A command line interface to Sloane's OEIS.  https://hackage.haskell.org/package/sloane-4.0.1 (AndersClaesson)
02:43:02 <Laserbear> o no hackagebot
02:56:23 <ttt_fff> i use monads so much and ahve so few pure functions
02:56:28 <ttt_fff> that I'm half tempted to make everything a typeclass
02:56:36 <ttt_fff> one version for the pure one, and one version for the monads
02:57:00 <MarcelineVQ> Aren't only IO monads impure?
02:57:58 <cocreature> frerich: yeah that's the link
03:00:05 <xelxebar> I just tried to install ghc-mod in a clean sandbox and the dep haskell-src-exts failed to install, complaining that happy >= 1.17 wasn't available. Any reason why happy isn't a dep for this guy?
03:01:35 <cocreature> xelxebar: because happy is a binary and not a library and cabal doesn't track binary deps
03:02:37 <srhb> xelxebar: As long as alex is in your $PATH you should be fine.
03:03:53 <liste> alex or happy?
03:04:37 <absence> MarcelineVQ: ignoring stuff like unsafePerformIO, yes
03:05:01 <xelxebar> cocreature: Interesting. I was unaware of that. That sort of just pushes my question back though. Why is happy a binary blob then? Doesn't it seem better to track it?
03:05:15 <tdammers> IO Monads aren't impure
03:05:40 <xelxebar> srhb: Yeah, I just manually `cabal install`ed happy into the sandbox and all was well, but curious as to why that was necessary.
03:05:53 <srhb> xelxebar: Oh sorry, yes, happy. And ok :)
03:06:51 <MarcelineVQ> tdammers: I thought IO was expressly to deal with impurity? Or do you mean semantically, where the monad itself is pure but the computation isn't?
03:09:50 <arianvp> Hey I'm looking for a secure number generator with the following type   :  GenIO -> IO a
03:09:59 <arianvp> that is also thread-safe...
03:10:17 <tdammers> MarcelineVQ: IO deals with effects, but it does so in a pure manner, and IO being a Monad isn't really relevant for that
03:10:26 <arianvp> because I can't afford threading StateT Gen through all my code...
03:10:28 <dramforever> do you consider System.Random secure enough?
03:10:43 <dramforever> oh wait you can't afford that...
03:10:59 <arianvp> no. it's in a cryptographic context
03:11:18 <dramforever> wait there are quite a few problem
03:11:19 <arianvp> Basically I'm in a route handler for a http server and I need to generate a secure random nonce
03:11:21 <dramforever> *problsms
03:11:23 <dramforever> *problems
03:11:24 <dramforever> sorry
03:11:31 <tdammers> there's the nonce package, fwiw
03:11:50 <tdammers> http://hackage.haskell.org/package/nonce
03:11:56 <arianvp> oh nice!
03:12:26 <tdammers> it relies on system entropy, which is probably as good as it gets
03:12:51 <tdammers> (i.e., if you need really strong randomness, consider adding a hardware RNG to your system)
03:12:53 <arianvp> tdammers: But it has ony PRNG stored in an IORef.    doesn't that block all your threads if you exhaust the entropy?
03:14:28 <tdammers> it blocks all the threads that are trying to generate nonces concurrently
03:14:50 <arianvp> In an ideal environment. You have separate PRNGS per thread that get seeded every now and then by some system entropy
03:15:20 <arianvp> I'm just scared this would allow for an easy DoS target
03:15:24 <tdammers> if I understand the code correctly, the Generator reseeds every time you create a new instance
03:15:40 <tdammers> which, in a web context, probably means "once per request"
03:16:13 <ttt_fff> what is the problem that you are trying to solve?
03:16:41 <arianvp> ttt_fff: https://hackage.haskell.org/package/nonce
03:16:43 <arianvp> wrong paste. 
03:16:44 <arianvp> ugh
03:16:55 <arianvp> https://en.wikipedia.org/wiki/Digest_access_authentication
03:17:06 <arianvp> Basically I need to generate a random nonce on a 401
03:17:50 <tdammers> typically, you'd have a separate Generator for every request; I'm not sure whether AESCtr.makeSystem would block all threads, but once you're past that stage, nothing blocks unless your request handler spawns additional threads, and those threads would try to create nonces concurrently
03:18:40 <arianvp> hmm
03:19:05 <ttt_fff> can't you (1) pick a random AES key, once, on server start, (2) send back the encrtypion of (a) client's browser (b) current time (c) client's iP (d) client's list of fonts/browser extensions installed ?
03:19:14 <ttt_fff> so the cost is just running AES on a single block
03:19:24 <ttt_fff> you can share the AES key for all the threads
03:21:18 <arianvp> ttt_fff: Interesting
03:21:58 <ttt_fff> I read somewhere, that people can be uniquely identified (i.e. on avg, 33 bits of randomness) based on browser extensions, thing slike:
03:22:07 <ttt_fff> browser version, OS version, plugins installed, fonts available, etc ...
03:22:10 <tdammers> a+b+c+d is completely guessable
03:22:13 <arianvp> Though it does feel kinda evil :P
03:22:36 <liste> https://panopticlick.eff.org/
03:22:43 <arahael> I thought that was widely known?
03:23:02 <arahael> Plus, there's tricks such as doing stuff via DNS. (Eg, using google's dns supposedly helps tracking)
03:23:52 <ttt_fff> tdammers: guess what plugins / fonts I have installed on my browser :-)
03:24:11 <arianvp> ttt_fff: But that opens you up to a chosen-plaintext attack
03:24:23 <ttt_fff> hm
03:24:48 <arianvp> Oh no wait.. probably not
03:25:02 <arianvp> I'm not sure. but anyhow. thanks for all the pointers. I'm gonna get back to coding
03:25:33 <tdammers> PHP used to do a similar thing for generating session keys
03:25:41 <ttt_fff> probably so, you can do a chosen plain text attack
03:25:51 <ttt_fff> by (the user) modifing the browser to return the string they want the encryption for
03:26:02 <ttt_fff> so, yeah, you're right, what I proposed is not secure
03:26:10 <tdammers> take a bunch of thing that are somewhat unpredictable or at least variable, hash them, and use that as the session key
03:26:23 <arianvp> Or ... I'll just use the nonce package
03:26:23 <tdammers> but it has been shown that the entropy of that hash was very very small
03:26:32 <tdammers> small enough to make brute-forcing a viable attack
03:26:35 <arianvp> and when I hit a point where people can DoS my system entropy. I'll add a rate limiter
03:27:18 <tdammers> also, consider this - once you add a strong enough hashing algo to prevent brute-forcing password hashes, you already have a big fat DoS opportunity there
03:27:23 <tdammers> much bigger than seeding your PRNG
03:37:44 * hackagebot set-cover 0.0.5 - Solve exact set cover problems like Sudoku, 8 Queens, Soma Cube, Tetris Cube  https://hackage.haskell.org/package/set-cover-0.0.5 (HenningThielemann)
03:42:44 * hackagebot envparse 0.2.2 - Parse environment variables  https://hackage.haskell.org/package/envparse-0.2.2 (MatveyAksenov)
03:44:47 <ttt_fff> https://github.com/ghcjs/ghcjs/blob/master/doc/ghci-usage.txt <-- does ghcjs have ghci support ?
03:51:22 <cocreature> ttt_fff: there is ghcjsi in some branch
03:51:28 <cocreature> but afaik it's not yet ready
03:51:38 <cocreature> (which is why it's in a branch :P)
03:52:00 <ttt_fff> cocreature: yeah, I fond a thread on github
03:52:12 <ttt_fff> screen shots exist, but apparently not ready as of mid 2015
03:52:20 <ttt_fff> codegen for something has a higher priority
04:08:59 <svenx> what does the <> operator do? i can't find it in any reference. trying to figure out how this works: https://github.com/begriffs/postgrest/blob/master/src/PostgREST/App.hs#L66
04:09:18 <nrk-> Isn’t it mappend?
04:09:21 <srhb> Yes, it is.
04:09:24 <dramforever> @hoogle
04:09:24 <srhb> It's a Monoid operator.
04:09:25 <lambdabot> No query entered
04:09:25 <lambdabot> Try --help for command line options
04:09:28 <dramforever> @wherehoogle
04:09:28 <lambdabot> Unknown command, try @list
04:09:31 <dramforever> @where hoogle
04:09:31 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
04:09:32 <svenx> monoid "mappend"?
04:09:35 <dramforever> svenx: ^
04:09:41 <dramforever> try one of those
04:10:43 <nrk-> Also http://learnyouahaskell.com/functors-applicative-functors-and-monoids (ctrl+f "mappend »)
04:10:45 <srhb> svenx: For instance, if you type <> into Hoogle, you get http://hoogle.haskell.org/?hoogle=%3C%3E and the first result will take you to Data.Monoid (in base) which defines it.
04:10:49 <svenx> ah, thanks. found info now
04:11:04 <svenx> cool
04:23:26 <dibblego> sometimes it is for Semigroup
04:23:54 <dibblego> http://hackage.haskell.org/package/semigroups-0.16.2.2/docs/Data-Semigroup.html
04:26:47 <putis> anyway, it is still a mappend operation
04:41:28 <Intolerable> is there any plan for getting semigroup into base?
04:44:23 <bernalex> Intolerable: response to that proposal was positive, but there were lots of bikeshedding.
04:45:33 <Intolerable> ah
05:02:49 * hackagebot hackage-security 0.1.0.0 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.1.0.0 (EdskoDeVries)
05:02:51 * hackagebot hackage-security-HTTP 0.1.0.0 - Hackage security bindings against the HTTP library  https://hackage.haskell.org/package/hackage-security-HTTP-0.1.0.0 (EdskoDeVries)
05:12:50 * hackagebot kansas-lava-shake 0.2.0 - Shake rules for building Kansas Lava projects  https://hackage.haskell.org/package/kansas-lava-shake-0.2.0 (GergoErdi)
05:13:49 <jerbome> @pl zipWith (const . ($ xs) (map remove [0..]) xs
05:13:49 <lambdabot> (line 1, column 46):
05:13:49 <lambdabot> unexpected end of input
05:13:49 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or ")"
05:13:55 <jerbome> @pl zipWith (const . ($ xs)) (map remove [0..]) xs
05:13:55 <lambdabot> zipWith (const . ($ xs)) (map remove [0..]) xs
05:14:08 <dramforever> sigh...
05:14:27 <dramforever> nothing to pl-ify
05:14:44 <jerbome> @pl getLists xs = zipWith (const . ($ xs)) (map remove [0..]) xs
05:14:44 <lambdabot> getLists = flip zipWith (map remove [0..]) =<< (const .) . flip id
05:14:50 <jerbome> better
05:14:52 <jerbome> well
05:14:58 <jerbome> at least something to pl ify
05:15:08 <jerbome> makes it so much more readable
05:22:59 <JagaJaga> If cabal can't guess deps (`Warning: no package found providing Options.Applicative.`) isn't there a way to fix that? I don't want to write all libs by myself ;'(
05:23:04 <JagaJaga> I did cabal update.
05:27:24 <merijn> JagaJaga: Did you list the right library in your dependencies?
05:27:32 <bennofs> JagaJaga: cabal probably only looks for modules in installed packages
05:27:39 <bennofs> JagaJaga: are you talking about cabal init?
05:47:52 <JagaJaga> merijn: yes, they are right
05:48:01 <JagaJaga> bennofs: yes, cabal init
05:48:14 <JagaJaga> bennofs: in installed? that's sad.
05:48:34 <bennofs> JagaJaga: i guess it uses ghc-pkg find-module
05:48:38 <JagaJaga> bennofs: nothing is installed (because nixos) :)
05:53:29 <srhb> JagaJaga: What exactly are you asking? How to install the dependencies?
05:56:58 <bennofs> he wants cabal init to detect dependencies automatically, without having them installed
05:57:53 * hackagebot magico 0.0.1 - Compute solutions for Magico puzzle  https://hackage.haskell.org/package/magico-0.0.1 (HenningThielemann)
06:02:53 * hackagebot resistor-cube 0.0.0.1 - Compute total resistance of a cube of resistors  https://hackage.haskell.org/package/resistor-cube-0.0.0.1 (HenningThielemann)
06:04:11 <srhb> Ah, I see. :)
06:12:54 * hackagebot yesod-auth-ldap-mediocre 0.1.1 - Very simlple LDAP auth for yesod  https://hackage.haskell.org/package/yesod-auth-ldap-mediocre-0.1.1 (andrewthad)
06:12:56 * hackagebot utility-ht 0.0.11 - Various small helper functions for Lists, Maybes, Tuples, Functions  https://hackage.haskell.org/package/utility-ht-0.0.11 (HenningThielemann)
06:17:54 * hackagebot resistor-cube 0.0.0.2 - Compute total resistance of a cube of resistors  https://hackage.haskell.org/package/resistor-cube-0.0.0.2 (HenningThielemann)
06:17:56 * hackagebot magico 0.0.1.1 - Compute solutions for Magico puzzle  https://hackage.haskell.org/package/magico-0.0.1.1 (HenningThielemann)
06:24:19 <dzotokan> Has anyone used TH with persistent?
06:24:29 <dzotokan> to describe models
06:27:55 * hackagebot Chart 1.5.2 - A library for generating 2D Charts and Plots  https://hackage.haskell.org/package/Chart-1.5.2 (TimDocker)
06:27:57 * hackagebot apportionment 0.0.0.2 - Round a set of numbers while maintaining its sum  https://hackage.haskell.org/package/apportionment-0.0.0.2 (HenningThielemann)
06:29:14 <ansible1> dzotokan: isn't that what persistent does?  I have a models file in my yesod projs that decribes the tables in my db.
06:32:00 <dzotokan> yep, writing an API using servant + persistent and trying to figure out a way to include entity in in the response. should Show instance be overloaded for that purpose or is there an easy way?
06:32:15 <dzotokan> entity id*
06:32:58 <mazur> i'm trying to install stack on nixos according to https://github.com/commercialhaskell/stack/wiki/Downloads and it seems to be hitting an error during the 'haddockPhase'
06:33:02 <mazur> src/Stack/Types/Compiler.hs:34:9: parse error on input '{-# UNPACK'
06:36:06 <merijn> Has anyone ever looked into efficient Entity Component System implementations in haskell?
06:36:11 <dzotokan> i.e given a custom model: User { name :: String, email :: String } when looking up using `selectList` it doesn't include UserId in the response body
06:43:39 <ansible1> dzotokan: you can put 'deriving Show' as a line in your models file
06:44:27 <ansible1> SongSequence
06:44:27 <ansible1>   name Text
06:44:28 <ansible1>   deriving Show
06:44:46 <ansible1> like that
06:45:44 <ansible1> also, in persistent IDs are not included in the record itself, for instance SongSequence would only have name in it.
06:46:14 <ansible1> I think so you can create a record that doesn't have an id yet, or something like that
06:48:02 <mazur> merijn: i haven't looked into entity component systems yet, i'm still learning state monad and frp
06:48:30 <lingxiao> hell all
06:49:25 <lingxiao> I have a parsing problem and I am wondering if there are some libraries that I could use
06:49:28 <bycn82> hi
06:49:35 <lingxiao> oops hey all*
06:49:41 <bycn82> using haskell with fastcgi,
06:50:00 <bycn82> how can I get the post values from the form?
06:50:24 <lingxiao> I have string of form    stufffIDontWant ++ \n x1 \r ++ \n x2 \r ++ ... + \n xn \r
06:50:38 <lingxiao> and I want to parse it into a slist of strings of form [x1,...,xn]
06:51:04 <merijn> mazur: entity component system aren't something very haskelly, tbh. They're more of a traditional game design approach, but I think it suits haskell well, but making it efficient might be tricky
06:51:07 <lingxiao> I could just traverse the list with splitOn and <$> 
06:51:41 <merijn> lingxiao: Wait, you're parsing a string by pattern matching?
06:52:26 <lingxiao> I'm not really parsing it , I'm just playing with it right now
06:52:30 <lpaste_> jerome pasted “euler problem 101” at http://lpaste.net/139217
06:52:41 <jerbome> hi huys
06:52:41 <tdammers> parsec might still make your life easier even at this point
06:52:54 <jerbome> can I have a code review on the paste I just shared ?
06:53:26 <dramforever> 1. it's idiomatic not to indent the whole module like that
06:53:58 <lingxiao> tdammers was that directed to me?
06:54:06 <jerbome> I'll first take what hlint is telling me to do
06:54:13 <tdammers> lingxiao: yeah
06:54:18 <lingxiao> oh ok great
06:54:20 <lingxiao> thanks
06:54:23 <lingxiao> !
06:54:49 <ansible1> my build has been stuck on profunctors-5.1.1 for about 8 hours now.  wondering if ghc is in a loop or something
06:55:07 <bennofs> ansible1: that sounds extreme and wrong
06:55:30 <bennofs> ansible1: profunctors normally doesn't take so long to compile. if it was haskell-src-exts, i'd understand, but profunctors?
06:55:36 <cocreature> ansible1: there was some bug with profunctors with some ghc versions iirc
06:55:45 <cocreature> which ghc version do you have?
06:56:02 <mazur> merijn: yea i've written one in c++ in combination with a network database, i haven't written enough haskell to reason about efficiency yet.
06:56:03 <ansible1> its ghc 7.8.2, on raspberry pi 2 so ARM 
06:56:37 <merijn> mazur: I'm interested in FRP approaches too, but I don't think any of the FRP systems have a good way to persist the state to disk, atm
06:56:42 <lpaste_> jerome revised “euler problem 101”: “euler problem 101” at http://lpaste.net/139217
06:56:46 <ansible1> its arch and the llvm is too new for ghc 7.8.2, so I downgraded it to an earlier llvm
06:57:00 <ansible1> I guess I'm not surprised there's problems
06:57:01 <lpaste_> jerome revised “euler problem 101”: “No title” at http://lpaste.net/139217
06:57:02 <merijn> ansible1: Any specific reason you're compiling via LLVM?
06:57:15 <merijn> oh, wait, RPi, nvm
06:57:16 <cocreature> ansible1: I would recommend to go to 7.8.4, using older point releases doesn't give you anything usually
06:57:17 <ansible1> ARM processor 
06:57:19 <ansible1> yup
06:57:37 <ansible1> its just that ghc 7.8.2 is the latest on arch, didn't want to compile ghc from source
06:57:37 <merijn> ansible1: Cross-compilation questions might have more success in #ghc
06:57:51 <merijn> ansible1: There's binary releases of GHC for linux
06:58:03 <ansible1> maybe I should cross compile, but I'm compiling on the pi
06:58:08 <merijn> ansible1: They're pretty trivial to install
06:58:38 <ansible1> yeah I was thinking of trying the binary ghc for arm... 
06:58:50 <merijn> ansible1: All you need is GMP installed, which you probably already have
06:59:31 <ansible1> I guess I'm hesitant 'cause my project has built before with 7.8 and don't want to debug on the pi because compiling takes so long.  But at this point nothing to lose I guess
07:00:15 <srhb> johnw: Ping.
07:07:52 <sdx23> Anyone bored and would like to give me feedback on my code (structural and stylistic)? https://github.com/sdx23/acid-state-dist
07:08:26 <sdx23> Ah, documentation is temporarily here, perhaps even more important. http://with-eyes.net/~mex/acid-state-dist/Data-Acid-Centered.html
07:11:00 <jellie> Hey you guys.
07:11:30 <umib0zu> Hi jellie
07:12:11 <jellie> Uh How to get "water" :: String and not "\"water\"" :: String from  "we are \"water\" gatherers" ?
07:12:39 <jellie> Basically getting a substring from a string
07:12:52 <merijn> jellie: You're using ghci?
07:13:12 <merijn> jellie: Note that ghci runs an implicit "show" on everything it prints...
07:13:19 <merijn> > "water"
07:13:20 <lambdabot>  "water"
07:13:22 <merijn> > show "water"
07:13:24 <lambdabot>  "\"water\""
07:13:34 <jellie> No 
07:13:40 <jellie> I'm not using ghci
07:13:59 <merijn> Then you need to be more specific about what you want to do :)
07:14:08 <phadej> ... and what you already have
07:16:25 <jellie> Okay I have a number of strings with the following structure. "addDependentFile "templates/homepage.hamlet""
07:16:43 <jellie> I want to get the filepath templates/homepage.hamlet out of that
07:19:24 <phadej> there are different approaches, ad-hoc "takeWhile/dropWhile", parser-combinators (parsec) or regex-applicative (will look the same as previous)
07:19:54 <jellie> Which is the best in performance
07:19:56 <jellie> *?
07:20:13 <jellie> I can use takeWhile/dropWhile combos
07:20:22 <phadej> i wouldn't care about performance in this example
07:20:34 <phadej> the difference is unnoticeable in inputs of that size
07:20:51 <Intolerable> i would say that a parser is the "nice haskell way" of doing it
07:21:43 <bennofs> the most adhoc way is this
07:22:16 <dramforever> I think takeWhile/dropWhile is fast
07:22:23 <dramforever> especially for those faster string types
07:22:35 <merijn> dramforever: Doesn't account for escaped quotes, though
07:22:41 <dramforever> hmm...
07:24:42 <isBEKaml> Hi, I have some trouble building an embedded native library as part of a haskell project. Basically, it fails while linking to some existing libraries (unable to locate them)
07:24:59 <phadej> with regex-applicative it's quite simple:
07:25:00 <phadej> let str = "addDependentFile \"templates/homepage.hamlet\""
07:25:07 <phadej> let q = '"' in str =~ many (psym (/= q)) *> sym q *> many anySym <* sym q
07:25:08 <isBEKaml> How can I turn on verbose logging with cabal? So I can see what exactly it runs while linking those libraries?
07:25:14 <phadej> Just "templates/homepage.hamlet"
07:25:15 <mpickering> isBEKaml: -v2
07:25:20 <JagaJaga> Someone uses fb library?
07:25:25 <dcoutts> isBEKaml: -v[n] for n 0-3
07:25:28 <isBEKaml> mpickering: thanks, will try it out
07:25:32 <isBEKaml> dcoutts: thanks
07:25:49 <phadej> and if you need to handle escaped character it's still possible
07:26:29 <JagaJaga> Doing `H.withManager $ \manager -> FB.runNoAuthFacebookT manager $  do {FB.getUser (FB.Id $ T.pack "4") [] Nothing }` and getting error of no token in the request. But here https://github.com/prowdsponsor/fb/blob/master/tests/Main.hs#L188 people do use the same request with no token provided..
07:34:12 <lunaris> Hey all; is anyone familiar with the monad-classes library? Having an issue with it.
07:35:00 <frerich> jellie: I don't know performance wise, but I like parsers like parsec for being more descriptive than something based on e.g. takeWhile/dropWhile.
07:37:26 <frerich> jellie: E.g. in 'string "addDependentFile " *> char '"' *> many1 (noneOf "\"") <* char '"' <* newline' it's not too hard to figure out what's going on and it's still very extensible should you need/want more flexibility.
07:37:43 <frerich> Like, supporting escaped quotes or more whitespace somewhere or so.
07:39:23 <mpickering> lunaris: please ask your question and if someone knows they might say
07:40:07 <lunaris> Well, basically, I'm just trying to figure out what I'm doing wrong with respect to EffExec IO.
07:40:43 <mpickering> (and post your code as well)
07:41:08 <lunaris> It's a tricky one.
07:41:16 <lunaris> I actually think I've just solved it.
07:41:56 <lunaris> Basically, why does CanDo (ReaderT String IO) (EffExec IO) yield True when CanDo (MyTransformerT IO) (EffExec IO) not resolve?
07:42:13 <lunaris> But I think it's due to the instance for ReaderT and not the instance for IO.
07:42:24 <lunaris> Which is counter-intuitive, but I think something I can work with.
07:42:25 <lunaris> Sorry.
07:53:00 * hackagebot uom-plugin 0.1.0.0 - Units of measure as a GHC typechecker plugin  https://hackage.haskell.org/package/uom-plugin-0.1.0.0 (AdamGundry)
07:54:27 <phadej> ^ so now those plugins are real
07:55:02 * dramforever is actually reading the tutorial
07:58:11 <mpickering> lunaris: I always find the best way to solve your problem yourself is to ask on irc ;)
07:58:58 <mpickering> phadej, there's also this one https://hackage.haskell.org/package/ghc-typelits-natnormalise
08:24:18 <knupfer> How can I retrieve system informations like cpu or mem on linux via haskell without FFI or procs?  The grabstat lib uses a C lib...
08:25:02 <nitrix> What's ((,) e) ? Someone online says `annotation` but I doubt that has anything to do with tuples, does it?
08:25:14 <knupfer> yes it does
08:25:39 <knupfer> it is a function that takes an element a and returns a tuple (e, a)
08:26:00 <nitrix> Why calling it an annotation, though?
08:26:08 <knupfer> dunno
08:26:37 <the_2nd> what does "let" actually mean?
08:27:10 <mniip> nitrix: if you have a structure, 'Foo a', you can annotate the occurences of 'a' by fmapping it to 'Foo (e, a)'
08:27:11 <knupfer> it binds local defined values (i.e. variables or functions...)
08:27:22 <srhb> the_2nd: There are two let syntax constructs that allow you to bind names. let name = value in expr using name; and the similar let name = value; in do expressions
08:27:30 <nitrix> the_2nd: It's a syntax element. `let ... in ....` is an expression.
08:27:39 <jellie> What's the function to get current UTCTime in haskell?
08:27:47 <jellie> or system UTCTime?
08:27:57 <srhb> jellie: getCurrentTime iirc
08:28:02 <the_2nd> nitrix, like "let thing be of value"?
08:28:05 <srhb> jellie: from the time package.
08:28:14 <mniip> the_2nd: no
08:28:26 <nitrix> jellie: Data.Time.Clock.getCurrentTime
08:28:29 <the_2nd> mniip, nitrix I mean I know what it does code-wise
08:28:40 <srhb> Well, what else is there?
08:28:41 <the_2nd> but I don't understand the usage of the name / meaning of it
08:28:42 <mniip> 'let name = value in expr' reads as 'assume that name means value in expr'
08:28:55 <srhb> the_2nd: Think "in the follow, let the name foo have value bar..."
08:29:39 <the_2nd> srhb, that's what I thought
08:29:41 <the_2nd> thanks everone
08:29:42 <nitrix> the_2nd: It literally means what the keywords says. It's an alias substitution for subexpressions in your expression, forming a new expression.
08:29:43 <the_2nd> y
08:29:53 <nitrix> the_2nd: Let something be something else in that other thing.
08:30:57 <knupfer> so can anyone answer my question? how can i retrieve the current cpu load or the mem usage?
08:31:52 <reubensammut> the_2nd: you can in fact do something like let 2+2=5 in 2+2
08:32:32 <nitrix> > let 2+2=5 in 2+2
08:32:34 <lambdabot>  5
08:32:56 <knupfer> > let (+) = (-) in 2+2
08:32:57 <lambdabot>  0
08:34:23 <mniip> lambdabot has no RebindableSyntax, shame
08:34:36 <reubensammut> knupfer: look at the code from xmobar for cpu load / mem usage
08:35:00 <knupfer> reubensammut: thanks for the pointer
08:35:32 <knupfer> now I've to collapse the xmobar thunk
08:35:36 <nitrix> knupfer: Honestly, it's just /proc file operations and parsing.
08:35:49 <reubensammut> src/Plugins/Monitors/Mem.hs
08:35:53 <reubensammut> for memory
08:36:09 <reubensammut> src/Plugins/Monitors/Cpu.hs for cpu
08:36:13 <johnw> srhb: hello
08:36:30 <knupfer> ok thank yo
08:36:41 <knupfer> ++ "u"
08:36:52 <srhb> johnw: I was going to ask you if you had time to merge some PRs on isomorphism/these, but I figured out how to make do locally. :-)
08:37:26 <johnw> srhb: ah, great
08:37:33 <srhb> johnw: Thanks for getting back to me anyway. :)
08:37:59 <johnw> I just woke up, ZNC shows me everything anyone said while I was away
08:43:15 <broma0> Anyone familiar with Ben Kolera's talk "Stacking Your Monads"? 
08:43:43 <ReinH> broma0: if you have a question about it you could try asking it :)
08:44:56 <broma0> Well, I'm really interested in how it would look to apply his concept to a concurrent application.. one where "readTransactions" and "insertTransactions" are processes communicating over a "Chan Transaction" or something
08:45:54 <broma0> The idea of makeing product types and extending them down to specialized components with the mtl's classy stuff is nice, but it breaks down when the specialized components run concurrently
08:48:23 <mpickering> phadej: btw FlexibleInstances implies TypeSynonymInstances if you didn't know
08:49:47 <rajput> hi all
08:50:34 <johnw> rajput: hi
08:55:01 <broma0> So basically my question is, using the pattern of "putting your whole application into a big nested product type, and then using mtl's classes to seamlessly specialize functions based on sub-components of that product type", how to you handle when your sub-components run concurrently? 
09:00:26 <phadej> broma0: how they run concurrently, it depends on how you want to combine the concurrent combination at the end
09:00:32 <phadej> computation*
09:01:16 <phadej> (I didn't see the talk)
09:02:01 <broma0> phadej: he basically had a program with two parts: "read/parse a .csv", and "insert results into the db" 
09:02:06 <phadej> mpickering: I just first added TypeSynonymInstances when GHCI complained, then FlexibleInstances after it wasn't satisfied first time
09:02:22 <broma0> phadej: each piece has diffferent errors it could throw, and differne reader environments
09:02:59 <broma0> phadej: so what he did, was combine the errors into an "App" sum type, like "AppError = AppDbError DbErr | AppCsvError CsvError"
09:03:28 <broma0> and combine the readers into an AppEnv = AppEnv { appEnvCsv :: CsvEnv, appEnvDb :: DbEnv }
09:03:40 <broma0> almost done...
09:03:51 <darenthis> is there a way to use lenses to extract a list of field values from a json/aeson array? eg given foo = [{a: 1}, {a: 2}], a function that would return [1,2]
09:04:37 <darenthis> (foo is actually a json string)
09:04:44 <broma0> he then made an 'App a' monad and used classy mtl to write functions like "insertDb :: (HasDb r, AsDbError e, MonadReader r m, MonadError e m) => Transaction -> m ()"
09:05:04 <broma0> phadej: do you understand his approach?
09:05:29 <serendependy> Why do I need FlexibleInstances in this (small) snippet? http://lpaste.net/139225
09:05:50 <serendependy> (I get why I need MutliParamTypeClasses and TypeSynonymInstances)
09:05:50 <jerbome> what does the ~ character mean in pattern matching ?
09:06:29 <phadej> darenthis: check aeson-lens
09:06:30 <Welkin> serendependy: because String is [Char]
09:06:38 <bennofs> darenthis: toListOf (_JSON . key "a") will do what you want (using aeson-lens)
09:06:39 <phadej> darenthis: you probably want members . _Number
09:06:54 <bennofs> oh, phadej is right ^^^^
09:06:58 <Welkin> jerbome: lazt pattern matching I believe
09:06:59 * bennofs forgot the list
09:07:01 <Welkin> lazy*
09:07:19 <Welkin> jerbome: https://wiki.haskell.org/Lazy_pattern_match
09:07:29 <jerbome> Welkin, thanks a bunch
09:07:36 <darenthis> bennofs, phadej: thanks
09:07:37 <phadej> or members . key "a" or something...
09:07:57 <phadej> broma0: yes, but how you'd make that concurrent?
09:08:05 * hackagebot yate 0.1.0.0 - Yet Another Template Engine  https://hackage.haskell.org/package/yate-0.1.0.0 (thoferon)
09:09:13 <phadej> but in general example you can have e.g. x :: App Int, and y :: App Bool, and have "concurrently x y :: App (Int, Bool)"
09:09:40 <broma0> phadej: 'readTransactions :: Chan Transaction -> m ()' and 'insertDb :: Chan Transaction -> n ()', then run thw two fn's in infinite recursion putting and taking from the chan
09:10:06 <serendependy> Welkin, not sure I follow. That makes sense for type synonym instances. Is it because I could later come up with an Under instances using [a] ?
09:10:13 <broma0> phadej: I'm not sure i fully understand your general example
09:10:19 <serendependy> s/instances/instance/
09:10:58 <phadej> broma0: you ask whether one can run two subcomponents concurrently, I try to say that you can build concurrent computation into that approach
09:12:15 <bennofs> darenthis: looks like it's toListOf (values . key "a" . _Integral) :: Value -> [Integer]
09:13:26 <phadej> broma0: for what you are asking one IMHO should go explicit with concurrency, spawn two threads and run one computation on first, and another on the second one
09:13:40 <phadej> that computation could be full `App`, or might now - that doesn't matter
09:14:16 <broma0> phadej: that's what i was thinking. define separate transformer stacks for each computation, and treat them as two completely separate things 
09:14:56 <broma0> but i cant help but feel like that's messy/cheating. there's got to be a way to make it a bit more high level.. think STM could achieve this?
09:14:56 <phadej> of course you can reuse parts of the stack, and that's the beauty I guess.
09:15:02 <Welkin> serendependy: https://ghc.haskell.org/trac/haskell-prime/wiki/FlexibleInstances
09:15:20 <phadej> broma0: you still run STM explicitly on different threads
09:15:42 <phadej> atomically doesn't spawn any threads for you or anything
09:16:10 <phadej> broma0: concurrency is messy :)
09:16:42 <broma0> phadej: I know.. it's cringe-worthy when you're trying to make nice looking code
09:17:27 <phadej> broma0: parallelism on other hand could be virtually invisible at it's best, but that a bit different
09:18:04 <broma0> phadej: i'd like to use parallelism, but i don't think its suited to this particular problem
09:18:28 <phadej> i,e, try to make one thing run faster, vs run many things at the same time
09:20:14 <phadej> broma0: but something like https://hackage.haskell.org/package/threads-supervisor and STM could be nice concurrency setup for single host app
09:21:17 <broma0> Is any STM guru willing to give the problem it solves a brief synopsis?
09:21:22 <broma0> phadej: that's fancy
09:22:44 <phadej> broma0: beautiful concurrency is good read on the topic
09:23:17 <phadej> broma0: and http://chimera.labs.oreilly.com/books/1230000000929/ch10.html
09:23:51 <phadej> the first sentence is as brief as it could get: Software transactional memory (STM) is a technique for simplifying concurrent programming by allowing multiple state-changing operations to be grouped together and performed as a single atomic operation.
09:24:16 <broma0> phadej: that'll do it
09:24:18 <broma0> thank you!
09:24:24 <phadej> you're welcome
09:28:52 <schell> o/
09:37:51 <putis> having function `a -> m b` and value `n a` how to achieve result `m n b`
09:38:36 <shachaf> m n b is an error.
09:39:18 <johnw> putis: you could only get m (n b), not m n b
09:39:43 <putis> yes m (n b) is a goal and mapM makes it
09:39:46 <putis> thanks
09:50:49 <nicolas12> Hi guys, I can't expose an internal module for tests (tests don't recognize the module), how can I do that?
09:51:12 <nicolas12> I'm exporting it with "other-modules"
09:51:31 <kadoban> nicolas12: I think it has to be in exposed-modules
09:51:55 <cjay> what is nowadays the recommended way for playing around with different packages from hackage? should I use stack to create a playground project? I suppose installing stuff with cabal directly is not the way to do it any more?
09:51:58 <nicolas12> yep, kadoban, that's what I've tried to say
09:52:26 <scshunt> cjay: yes
09:52:36 <kadoban> nicolas12: I believe the convention is to just call it Blah.Blah.Internal , and then nobody outside can blame you if they're using it and you change API in there.
09:52:56 <kadoban> cjay: Yeah 'stack' definitely seems like the way to go.
09:53:45 <cjay> scshunt kadoban: ok thanks. someone should really add that to the landing page or faq of stack and stackage. they only talk about projects, but newbies have no projects.
09:53:49 <nicolas12> kadoban: oh, ok, but if I want to not expose it, should I duplicate the internal module in my tests folder or what? thanks
09:54:00 <kadoban> cjay: By the way, depending on what you're playing with … keep in mind that hackage isn't audited or whatever. You're essentially running totally arbitrary code on your machine. Usually it's fine, especially the big-name libraries but … well, depends how playful you get.
09:54:22 <cjay> ok thanks
09:54:29 <kadoban> nicolas12: I'm not really sure what other option there is. I've only done a few quite small libraries at this point :-/
09:54:58 <cjay> maybe hackage should get a peer-review system :)
09:55:13 <cjay> with a web of trust or something
09:55:20 <nicolas12> kadoban: ok thanks, I've tried a lot of "solutions" that didn't work :(
10:08:09 * hackagebot concurrent-machines 0.1.0.1 - Concurrent networked stream transducers  https://hackage.haskell.org/package/concurrent-machines-0.1.0.1 (AnthonyCowley)
10:10:11 <ski> mniip : cool
10:13:45 <riblankman> I'm having issues with converting a hex string in a json format to a ByteString. Data.Aeson has a ToJSON/FromJSON instance for ByteString yet I get the error " No instance for (FromJSON ByteString) arising from a use of ‘.:’"
10:14:11 <Intolerable> check you've got the right ByteString variant
10:14:24 <Intolerable> it's likely that there's an instance for Lazy but not for Strict
10:14:27 <Intolerable> or vice versa
10:14:51 <riblankman> Intolerable: ah, ok!
10:18:09 * hackagebot hexpat-lens 0.1.4 - Lenses for Hexpat.  https://hackage.haskell.org/package/hexpat-lens-0.1.4 (JosephAbrahamson)
10:19:19 <darenthis> still stumped on json array parsing I'm afraid. http://lpaste.net/8844167265461993472
10:19:51 <bennofs> darenthis: use ^.. instead of ^?
10:19:52 <Intolerable> dont use ^?
10:19:55 <Intolerable> lol
10:19:56 <Intolerable> too slow
10:19:58 <bennofs> darenthis: ^? gets the first result
10:20:07 <bennofs> darenthis: ^.. gets the list of all results
10:20:08 <darenthis> d'oh!
10:20:46 <darenthis> bennofs: nailed it! Thank you
10:21:32 <f-a> in Data.Time, there is this function getCurrentTime = liftM posixSecondsToUTCTime getPOSIXTime
10:21:44 <f-a> do you think there is a way to make it portable (i.e. working on windows too?)
10:21:46 <darenthis> this is when I dislike the terse operators
10:22:14 <Intolerable> darenthis: ie ^? / ^.. ?
10:22:20 <Intolerable> :t toListOf
10:22:21 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
10:22:24 <Intolerable> :t (^..)
10:22:25 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
10:22:46 <Intolerable> use toListOf if the operator is a problem
10:23:07 <darenthis> :t (^?)
10:23:08 <lambdabot> s -> Getting (First a) s a -> Maybe a
10:23:11 <glguy> f-a: That function already works on Windows
10:23:25 <Intolerable> :t firstOf
10:23:26 <lambdabot> Getting (Leftmost a) s a -> s -> Maybe a
10:23:57 <f-a> glguy: oh, sorry, I thought it wasn't look by checking that 'posix'. Thanks
10:24:18 <Intolerable> :t preview
10:24:19 <lambdabot> MonadReader s m => Getting (First a) s a -> m (Maybe a)
10:24:40 <Intolerable> :t flip preview `asTypeOf` (^?)
10:24:41 <lambdabot> s -> Getting (First a) s a -> Maybe a
10:25:04 <glguy> f-a: POSIX Time is just a specific way of describing time: https://en.wikipedia.org/wiki/Unix_time
10:25:14 <f-a> ohhh, great. Thanks glguy 
10:27:35 <broma0> who are the people behind the maintainer "libraries@haskell.org" on hackage? 
10:27:47 <broma0> i was curious when looking at STM
10:29:52 <johnw> broma0: https://wiki.haskell.org/Core_Libraries_Committee
10:30:14 <broma0> johnw: just found that!
10:30:15 <broma0> thank you
10:34:53 <Welkin> broma0: a shadowy cabal!
10:51:19 <joeyh> does cabal configure --PROG-options preserve the options and use them in cabal build?
10:51:36 <breadmonster> Hi.
10:51:54 <breadmonster> > some [3]
10:51:58 <lambdabot>  mueval-core: Time limit exceeded
10:52:10 <breadmonster> Can someone tell me what that does?
10:52:28 <byorgey> @type some
10:52:29 <lambdabot> Alternative f => f a -> f [a]
10:53:07 <breadmonster> byorgey: It makes no sense.
10:53:38 <geekosaur> isn't that a parser mechanism? (and kinda dubious outside that context)
10:53:38 <byorgey> breadmonster: what makes no sense?  the type, or the implementation?
10:54:27 <byorgey> yes, some/many really only make sense for Applicatives which (1) can fail, and (2) have some kind of effect such that running a computation repeatedly will eventually cause it to fail
10:54:33 <breadmonster> geekosaur byorgey: I can't fathom what it does.
10:54:42 <byorgey> the [] Applicative satisfies (1) but not (2)
10:55:04 <geekosaur> breadmonster, it doesn't do anything useful in the list Applicative
10:55:07 <byorgey> breadmonster: if  p :: Parser String   is a parser, then   some p :: Parser [String]   tries to run p one or more times
10:56:00 <geekosaur> it's intended for things like parsers, where "some" accepts one or more of something and "many" accepts zero or more. list Applicative doesn't act like a parser so "some" and "many" don't do anything sensible
10:56:33 <geekosaur> (it is unfortunate that there is no good type level distinction between things that can use those and things that can't, especially given that they are typeclass methods)
10:56:37 <aweinstock> what's an example of a Functor that's not also Applicative?
10:57:06 <bennofs> aweinstock: Const a, where a is not a Monoid 
10:57:51 <breadmonster> geekosaur: Oh okay.
10:58:07 <breadmonster> geekosaur: so is there a function that does exactly one?
10:58:12 * hackagebot OpenGL 2.13.0.0 - A binding for the OpenGL graphics system  https://hackage.haskell.org/package/OpenGL-2.13.0.0 (SvenPanne)
10:58:14 * hackagebot GLUT 2.7.0.2 - A binding for the OpenGL Utility Toolkit  https://hackage.haskell.org/package/GLUT-2.7.0.2 (SvenPanne)
10:58:15 <breadmonster> Or rather, at most one?
10:58:19 <breadmonster> Sorry, not exactly.
10:58:46 <breadmonster> :t many1
10:58:47 <lambdabot>     Not in scope: ‘many1’
10:58:48 <lambdabot>     Perhaps you meant ‘many’ (imported from Control.Applicative)
10:58:52 <bennofs> aweinstock: I think data Store s a = Store s (s -> a)  (store comonad) is also not an applicative
10:59:43 <aweinstock> bennofs: thanks
11:00:19 <geekosaur> breadmonster, in this context, that would be the (f a) in the type of "some"
11:01:01 <geekosaur> that is, it expects to be given an Alternative that matches exactly one thing, and repeats it as long as it succeeds
11:01:13 <geekosaur> (for a list, it succeeds forever, so it runs forever)
11:03:12 * hackagebot OpenAL 1.7.0.1 - A binding to the OpenAL cross-platform 3D audio API  https://hackage.haskell.org/package/OpenAL-1.7.0.1 (SvenPanne)
11:13:13 * hackagebot yesod-table 1.0.6 - HTML tables for Yesod  https://hackage.haskell.org/package/yesod-table-1.0.6 (andrewthad)
11:16:47 <zoug> hello, what does "!" mean in Haskell when it comes AFTER the name of a variable? I've managed to find the explanation when it's before (smthing like !Int) but not when I have a variable like "m!" (the example at the very bottom of this page, namely: http://www.seas.upenn.edu/~cis194/spring13/lectures/06-laziness.html)
11:17:33 <shachaf> It's an operator.
11:17:50 <shachaf> Like (!!), only less so.
11:18:33 <haskell546> hi all. 
11:19:09 <geekosaur> zoug, specifically that's the indexing operator (like !!) for Data.Array
11:19:56 <haskell546> I am interested in learning Haskell, but I first need to know if it suits my needs. So I have a question from you Haskelites.
11:20:48 <haskell546> Is Haskell suitable for natural language processing tasks? Does it have handy string manipulation libraries ? 
11:20:48 <geekosaur> (yes, this is somewhat confusing; it's even confusing to the compiler in some cases, there's a caveat in the BangPatterns extension documentation about it)
11:22:31 <shachaf> One person's ambiguity is another's opportunity: https://github.com/mauke/poly.poly/blob/master/poly.poly
11:25:06 <breadmonster> Hey guys.
11:41:01 <aupiff_> besides shifts and or-ing Word8s, is there an easy way to have [Word8] -> Word32 or [Word8] -> Word64?
11:41:56 <echolot> @let fun01 (_,y,z) = "z is twice y" where z = y*2
11:41:58 <lambdabot>  Defined.
11:42:42 <echolot> @fun (0,1,3)
11:42:44 <lambdabot>  (0,1,3)
11:42:52 <echolot> @fun01 (0,1,3)
11:42:52 <lambdabot> Unknown command, try @list
11:43:15 * hackagebot gitit 0.12 - Wiki using happstack, git or darcs, and pandoc.  https://hackage.haskell.org/package/gitit-0.12 (JohnMacFarlane)
11:44:36 <echolot> > fun01 (0,1,3)
11:44:38 <lambdabot>  "z is twice y"
11:45:46 <ion> Optimized: let message = "z is twice y"
11:46:33 <Xnuk> let fun01 (_,_,_) = "z is twice y"
11:48:55 <Xnuk> @undef
11:48:55 <lambdabot> Undefined.
11:49:50 <zoug> geekosaur: shachaf so can I consider it's exactly the same thing as (!!) ? Where does it differ?
11:50:44 <shachaf> No. It comes from Data.Array.
11:50:51 <shachaf> Try it and see.
11:51:03 <geekosaur> just in what types it applies to --- several types use !, I think only Data.List uses (!!)
11:51:22 <zoug> yes okey that's what I meant
11:51:27 <geekosaur> which is kind of a warning, I think, because people expect indexing to be fast, and it is for the types that use (!) but is slow for lists
11:51:27 <zoug> thank you guys ! :)
11:51:40 <zoug> oh ok
11:54:03 <edwardk> aweinstock: Map k
11:54:04 <ansible1> what happens with llvm 3.6 and ghc 7.10.2?   bad things I'm guessing.
11:54:10 <edwardk> aweinstock: IntMap
11:54:18 <edwardk> both are Functor instances that aren't Applicative. You can't have 'pure'
11:54:30 <ansible1> llvm 3.5 packages are not available for arch on armv7
11:54:35 <edwardk> interestingly they can both have an (<*>) equivalent based on intersection
11:54:57 <edwardk> :t M.intersectionWith id
11:54:58 <lambdabot> Ord k => M.Map k (b -> c) -> M.Map k b -> M.Map k c
11:54:59 <Intolerable> is there a class that has <*> but not pure?
11:55:11 <edwardk> Intolerable: Data.Functor.Apply in my semigroupoids package
11:55:33 <edwardk> Intolerable: there is also Control.Comonad.ComonadApply in my comonad package, which is for things that act like (<*>) but respect extract from a comonad in an appropriate way
11:55:42 <edwardk> it really should be "Semiapplicative"
11:55:50 <edwardk> i may go back and change it in a version 6 some day
11:55:50 <ansible1> I guess I'll try it and see... 
11:55:58 <Intolerable> i've needed that before but couldn't find it
11:56:06 <Intolerable> (the Map instance, i mean)
11:56:10 <edwardk> Intolerable: there is also a Bind class in there for things that support (>>=) but not return.
11:56:16 <edwardk> Map k also supports such an operation
11:56:36 <edwardk> similarly, should also be called Semimonad
11:58:08 <Intolerable> neat
11:58:43 <aweinstock> is there a name for Functors with pure/return, but not (<*>)?
11:58:53 <Intolerable> Pointed?
11:59:16 <aweinstock> thanks
11:59:23 <Intolerable> notable for having no laws and being a bit awkward
12:03:16 * hackagebot semigroupoids 5.0.0.4 - Semigroupoids: Category sans id  https://hackage.haskell.org/package/semigroupoids-5.0.0.4 (EdwardKmett)
12:06:23 <edwardk> aweinstock: Pointed exists in my pointed package, but it has no laws that aren't free theorems with respect to how it interacts with Functor. Therefore I simply have pointed data types rather than Pointed functors.   fmap f . point a = point (f a)   by parametricity, there is no need to make Pointed and Functor related to enforce it
12:06:35 <edwardk> er fmap f . point = point . f
12:08:16 * hackagebot cabal-lenses 0.4.6 - Lenses and traversals for the Cabal library.  https://hackage.haskell.org/package/cabal-lenses-0.4.6 (DanielTrstenjak)
12:13:16 * hackagebot cabal-cargs 0.7.8 - A command line program for extracting compiler arguments from a cabal file.  https://hackage.haskell.org/package/cabal-cargs-0.7.8 (DanielTrstenjak)
12:14:26 <kyclark> I get this: fmap (+2) (Just 4)
12:14:43 <kyclark> Can someone explain how to do this? fmap (+2) [Just 2, Nothing, Just 5]
12:15:00 <mauke> fmap (fmap (+2))
12:15:27 <kyclark> Whoa!  That's cool.  Thanks, mauke.
12:16:34 <kyclark> And on with  fmap (fmap (fmap (+2))) [[Nothing, Just 1], [Just 2, Nothing, Just 5]]
12:16:50 <mauke> you can also spell that as (fmap . fmap) (+2)
12:16:52 <kyclark> So is this where lenses start to help?
12:17:00 <mauke> but beware, this is getting dangerously lensy
12:17:36 <Zemyla> Why are Arrays of Bool packed, but Vectors of Bool aren't?
12:17:41 <kyclark> I don't have a specific use case.  Just expanding my mind.
12:19:00 <mauke> Zemyla: I question your question
12:19:24 <Zemyla> Basically, Arrays of Bool are packed so that there are 8 Bools per byte.
12:19:58 <Zemyla> Vectors of Bool aren't; it;s a simple newtype wrapper around Vector Word8.
12:20:06 <mauke> [citation needed]
12:20:40 <mniip> Zemyla, Vector Bool is a newtype wrapper over Vector Word8?
12:20:44 <mniip> how does that work
12:21:08 <Zemyla> https://hackage.haskell.org/package/vector-0.10.12.2/docs/src/Data-Vector-Unboxed-Base.html#fromBool
12:21:52 <mniip> that's not a "simple newtype wrapper"
12:21:58 <mniip> it's a data family (newtype family)
12:22:23 <Zemyla> No, but it still means there's only one Bool per byte, not 8 like there could be.
12:22:41 <mniip> also P.Vector
12:22:42 <mniip> not Vector
12:22:56 <mniip> Data.Vector.Primitive.Vector
12:23:19 <mauke> Zemyla: ok, and Array?
12:26:43 <mniip> edwardk, so, any idea why a naive algorithm that shuffles the innermost point to the end to eta-reduce it, is exactly the same as schonfinkel's process of lifting function application into lambdas with S?
12:29:06 <dolio> Zemyla: Huh, weird.
12:31:26 <dedgrant_> curious: what are some techniques for preventing accidental data evaluation where only type level promotion is desired in GHC? (ie. answering the question to some degree, "Will applying 'promoteSomeDataFromMyType (undefined :: MyType) evaluate to a non-bottom value?")
12:33:07 <bennofs> dedgrant_: perhaps avoid passing an undefined ?  like promoteSomeDataFromMyType (Proxy :: Proxy MyType) ?
12:33:29 <Cale> Yeah, Proxy basically exists for that purpose
12:34:30 <dedgrant_> right
12:34:39 <dedgrant_> because Proxy cannot be evaluated?
12:35:17 <bennofs> dedgrant_: it can be evaluated, but evaluating it is a no-op (like evaluating ())
12:35:19 <Cale> It can, it's just a data constructor though
12:35:25 <dedgrant_> Got it
12:36:40 <Zemyla> mauke: http://hackage.haskell.org/package/array-0.5.1.0/docs/src/Data.Array.Base.html#showsIArray
12:36:50 <Zemyla> Wait, it's below that.
12:37:06 <dedgrant_> OK thanks Cale and bennofs. Simple answer :)
12:37:25 <Zemyla> http://hackage.haskell.org/package/array-0.5.1.0/docs/src/Data.Array.Base.html#unsafeNewArraySTUArray_
12:40:55 <mauke> Zemyla: that's UArray, not Array
12:41:30 <Peaker> Euler4: https://projecteuler.net/problem=4  written in Lamdu: http://i.imgur.com/m2wZfA6.png,  with live execution: http://i.imgur.com/1WVNLWR.png  :-)
12:44:30 <liste> Peaker awesome!
12:44:43 <Peaker> liste: :)
12:45:18 <Welkin> Peaker: Lambu is for visualising the execution of a program?
12:45:23 <Welkin> Lamdu*
12:45:37 <Peaker> Welkin: it's a new "Programming Experience", including the visualization of program execution
12:45:59 <Peaker> Welkin: it's a type-driven structural editing live code editor
12:46:25 <bennofs> I have a map 'm' which contains thunks at every key. Is it possible to get the value at a certain key, but not have the map retain a reference to the forced value?
12:46:52 <Peaker> bennofs: what do you want kept in the map?
12:47:02 <Peaker> bennofs: the original thunk?
12:47:06 <bennofs> Peaker: yes
12:47:48 <Intolerable> a map that forgets?
12:47:50 <Peaker> I am not sure if there's a reliable way to do this.. It sounds like something to accomplish with   type Thunk a = () -> a      and then have   Map k (Thunk a)   hoping the result isn't memoized in the map. Unfortunately, GHC is too smart for its own good
12:48:07 <Peaker> and does memoize ()->a  functions sometimes!
12:48:18 <bennofs> Peaker: basically, imagine a global thread holding a reference to the map. And then I want to perform a short-lived action like v <- lookup k m, do something with v, never use v again, and I don't want v to leak memory
12:48:47 <Intolerable> i assume you can't just delete it once it's been accessed?
12:48:49 <bennofs> Peaker: sometimes? it'll always float out the thing inside
12:48:52 <mniip> Peaker, it will not memoize 'b -> a'
12:49:00 <bennofs> Intolerable: correct
12:49:22 <bennofs> mniip: but it'll transform \() -> a to let x = a in \() -> x
12:49:32 <mniip> right
12:49:44 <Peaker> bennofs: http://stackoverflow.com/questions/6208006/any-way-to-create-the-unmemo-monad <-- related
12:50:21 <the_2nd> I defined a type myTypes = [myType]
12:50:28 <bennofs> ah, and I can't change the type of the Map
12:50:31 <the_2nd> now I want to make instaces of myTypes
12:50:40 <the_2nd> is there any way to do this?
12:50:52 <nitrix> the_2nd: You make instances of classes.
12:50:56 <Intolerable> with type?
12:51:00 <Intolerable> or with newtype or what
12:51:04 <the_2nd> well
12:51:19 <the_2nd> data myTyp = ....e
12:51:23 <the_2nd> class Moveable
12:51:30 <the_2nd> instance Moveable myType
12:51:32 <arkeet> type names must start with capital letters
12:51:44 <the_2nd> instance Moveable MyTypes //wont work
12:51:56 <the_2nd> since MyTypes is no data, but a typedef
12:52:09 <Intolerable> you can't make instances for type synonyms
12:52:12 <arkeet> just expand the type synonym, or use TypeSynonymInstances
12:52:18 <arkeet> instance Moveable [MyType]
12:52:23 <Intolerable> use newtype
12:52:33 <the_2nd> arkeet, Intolerable hoe exactly?
12:52:36 <the_2nd> how
12:52:52 <liste> @let newtype MyType = MyType Int
12:52:54 <lambdabot>  Defined.
12:53:22 <liste> @let instance Show MyType where show _ = "bogus"
12:53:24 <lambdabot>  Defined.
12:53:25 <Intolerable> @let instance Show MyType where show (MyType x) = show x
12:53:26 <lambdabot>  .L.hs:181:10:
12:53:26 <lambdabot>      Duplicate instance declarations:
12:53:26 <lambdabot>        instance [safe] Show MyType -- Defined at .L.hs:181:10
12:53:38 <liste> > MyType 25
12:53:40 <lambdabot>  bogus
12:53:48 <nitrix> You implement the functions of that class for your type instance. What is a Moveable?
12:53:51 <liste> (the @let's are for lambdabot)
12:54:20 <bennofs> Peaker: do you think GHC could provide a function like: unshared :: a -> a?
12:54:27 <the_2nd> nitrix, has method move
12:54:36 <the_2nd> nitrix, move MyType
12:54:36 <bennofs> that would be equal to a, but a "separate" copy of it
12:54:45 <the_2nd> nitrix, move MyTypes
12:54:49 <Intolerable> does Weak do anything useful here?
12:55:18 <Peaker> bennofs: so the top-level thunk is a copy, but all the underlying thunks are shared?
12:55:25 <bennofs> Peaker: yes
12:55:31 <nitrix> the_2nd: I assume something like this: instance Moveable MyTypes where move ... = ...
12:55:42 <Peaker> bennofs: would that really help? Wouldn't the underlying sharing negate any benefits?
12:55:44 <the_2nd> nitrix, yes
12:55:56 <nitrix> the_2nd: Then what's the question?
12:55:58 <bennofs> Peaker: I could do fmap unshared $ lookup k m 
12:56:03 <bitemyapp> bennofs: what would that do?
12:56:08 <the_2nd> nitrix, it doesnt work
12:56:20 <Peaker> bennofs: the spine/shape would still be shared
12:56:23 <the_2nd> since MyTypes is just a "type Mytypes = [MyType]"
12:56:46 <bitemyapp> there's already more than one way to prevent sharing, do we need another?
12:56:50 <Peaker> bennofs: sounds like a question to #ghc.. might be possible, but maybe tricky because thunks are concurrently-accessed, sometimes locklessly
12:56:57 <bennofs> bitemyapp: wait, there is a reliable way?
12:57:10 <bennofs> Peaker: oh, it might need to be recursive, you're right
12:57:28 <Peaker> bennofs: you could make an NFData-like class for unsharing
12:58:18 <bennofs> Peaker: oh, that sounds like a good idea actually. But won't ghc optimize case x of Just x -> x; Nothing -> Nothing to id ?
12:58:19 * hackagebot acid-state 0.13.0 - Add ACID guarantees to any serializable Haskell data structure.  https://hackage.haskell.org/package/acid-state-0.13.0 (DavidHimmelstrup)
12:58:26 <geekosaur> the_2nd, unless you are expecting separate behavior for a [MyType] vs. a MyTypes, TypeSynonymInstances should work
12:58:33 <Zemyla> mauke: Okay, so still, why does UArray pack Bools so much tighter than Unboxed.Vector does?
12:58:35 <bennofs> bitemyapp: can you tell me one way?
12:58:35 <geekosaur> if you need them to be different then you must use newtype, not type
12:58:42 <geekosaur> (or possibly data)
12:58:57 <Peaker> bennofs: I am not sure
12:58:57 <the_2nd> geekosaur, how to use these? exmples?
12:59:14 <Peaker> bennofs: GHC always makes operational semantics a bit mysterious
12:59:55 <bennofs> @google unsharing primitive ghc
12:59:56 <lambdabot> https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/primitives.html
13:00:29 <bennofs> @google unsharing primitive ghc dup
13:00:30 <lambdabot> http://darcs.nomeata.de/ghc-dup/_darcs/pristine.hashed/0000056769-aefe76ee00b137ae7d66efba5c8e7a6dfed575393c853bd3c5427a5bb4b092c9
13:00:39 <bennofs> ^^^ there seems to be a paper about this already
13:01:45 <bennofs> bitemyapp: please, can you tell me a way to unshare? I'd really need this
13:02:20 <the_2nd> geekosaur, how to properly use these?
13:02:51 <geekosaur> I'm looking for an explanation that covers all three. but I'm also still trying to figure out what you're trying to accomplish --- which is what determines which of those you want
13:03:14 <bennofs> Peaker: wow, there is even a hackage package?
13:03:18 <the_2nd> well I have a collection of Type
13:03:19 <bennofs> @hackage ghc-dup
13:03:19 <lambdabot> http://hackage.haskell.org/package/ghc-dup
13:03:23 <the_2nd> and want to give it its own name
13:03:26 <geekosaur> http://stackoverflow.com/questions/5889696/difference-between-data-and-newtype-in-haskell
13:03:31 <the_2nd> since it's more readable imo
13:03:43 <the_2nd> so Path = [Points]
13:04:14 <geekosaur> sure, the question is really whether you want [MyData] and MyDatas to be exactly the same thing, or if you want one to sometimes have different typeclass instances
13:04:15 <the_2nd> *[Point]
13:04:47 <the_2nd> geekosaur, would you mind explaining both possible solutions? Not usre yet, which path Ill take later on
13:04:52 <geekosaur> if they should be the same, you can either add {-# LANGUAGE TypeSynonymInstances #-} at the top of your source file or declare the instance on [MyData] directly (and use MyDatas elsewhere)
13:06:48 <kadoban> Are there any good libraries for making … I guess basically a repl? My program is going to have several possible "commands", each with their own options. Basically looks like it'd perfectly match what optparse-applicative allows, in terms of 'commands'. I'd like the user to be able to either run  myprog somecommand --someoptions   or do   myprog\n and then get a prompt and be able to do  somecommand --blah \n anothercommand --etc \n and etc. I want 
13:06:50 <kadoban> command completion, history support, that kind of thing :-/
13:07:28 <exio4> kadoban: basically readline / haskeline ? 
13:07:56 <geekosaur> so, a concrete example: because String is [Char], it is not possible for the Show instance to distinguish between a random list of Char and an actual String; both are displayed as String even when sometimes it would make more sense the other way.
13:08:24 <kadoban> exio4: Let me look those up.
13:08:36 <kyclark> How is it possible that "fmap Just (+1) 2 == fmap (+1) (Just 2)"?
13:08:42 <kyclark> :t fmap
13:08:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:08:48 <geekosaur> for example, the Parsec parser library has a oneOf parser: oneOf ['a', 'b', 'c'] patches if the next character is one of those characters. but that is also identical to: oneOf "abc"
13:08:58 <Intolerable> :t fmap Just
13:09:00 <lambdabot> Functor f => f a -> f (Maybe a)
13:09:01 <geekosaur> which can be a little confusing
13:09:08 <the_2nd> geekosaur, "FlexibleInstances" allows the direct typedef
13:09:19 <Intolerable> :t fmap Just (+1)
13:09:21 <lambdabot> Num a => a -> Maybe a
13:09:29 <geekosaur> if String were a newtype, you could distingush easily. but ypou'd also have to unwrap the newtype to use list operations on it --- meaning, most functions "on strings"
13:09:38 <Intolerable> ((->) a) is a functor
13:09:53 <geekosaur> yes, that allows TypeSynonymInstances and a few more things
13:10:08 <the_2nd> other thing:
13:10:20 <geekosaur> mostly it's disallowed because of what I just described: that it can be confusing that you can't distinguish between String and [Char] and have different behaviors for them
13:10:30 <the_2nd> I have "Class Moveable where move :: a -> Point -> a"
13:10:38 <the_2nd> and want to put this in its own file
13:10:43 <kyclark> Huh, I was thinking it was "fmap (Just (+1)) 2" but it was "(fmap Just) (+1) 2"
13:10:44 <the_2nd> and make a Moveable Point
13:10:51 <the_2nd> but cant reference circular
13:11:12 <the_2nd> is this fixable somehow? (putting Moveable definition after data def works within the same file)
13:11:28 <Intolerable> (((fmap Just) (+1) 2), yes
13:11:32 <Intolerable> > (((fmap Just) (+1) 2)
13:11:33 <lambdabot>  <hint>:1:22:
13:11:33 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:11:37 <Intolerable> er
13:11:41 <Intolerable> > ((fmap Just) (+1) 2)
13:11:43 <lambdabot>  Just 3
13:12:50 <geekosaur> put the instance with the class, instead of with the declaration of Point?
13:13:03 <geekosaur> otherwise there's some ugliness involving .hs-boot files
13:13:30 <geekosaur> (in theory it's supposed to work without that. in practice, it's a bit difficult to do properly)
13:14:06 <the_2nd> geekosaur, is putting it to the class the "usual" way of doing it?
13:14:23 <geekosaur> it's not unusual
13:14:37 <the_2nd> I'll just do it the most common way
13:14:54 <geekosaur> generally you put it with the data declaration only if it's an instance of a Prelude class
13:15:12 <geekosaur> otherwise you run into this kind of circular reference issue and have to mess with hs-boot files
13:15:21 <geekosaur> which are annoying and have to be kept in sync
13:18:07 <the_2nd> geekosaur, functions only for the data type
13:18:17 <the_2nd> then stay in the file with the data definition I guess?
13:18:27 <geekosaur> yes
13:18:30 <the_2nd> while the instances are moved to the class files
13:18:32 <the_2nd> alright
13:21:08 <the_2nd> geekosaur, something like that: http://pastebin.com/JsvkTCcY
13:23:21 * hackagebot cabal-debian 4.31 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.31 (DavidFox)
13:24:34 <the_2nd> is my assumption correct, that haskell classes are more like interfaces in other languages? and that instances are more like classes? while data represents structures?
13:24:39 <kadoban> exio4: That's at least the idea of what I'm looking for. I'll look more into them and see if either fits well, thanks.
13:25:06 <kclancy> is it possible to get the hoogle command line tool to print descriptions? For me, it is just printing types. That is not enough information to help me.
13:25:16 <geekosaur> the_2nd, there is some similarity, but relying on it can get you into trouble it's more a rough analogy then an accurate depiction
13:25:23 <Welkin> the_2nd: I see people try to make analogies with OOP or java in here daily
13:25:28 <geekosaur> because Haskell's type system does not work like an OOP type system
13:25:32 <Welkin> it never works out :P
13:25:38 <the_2nd> Welkin, sure
13:25:49 <the_2nd> but the assumption that Class is like classes in java
13:25:53 <the_2nd> seems to be worse
13:26:01 <the_2nd> so I'm happy with my "progress"
13:26:08 <kclancy> For example, I type hoogle replaceExtension. It gives me System.FilePath.Posix replaceExtension :: FilePath -> String -> FilePath
13:26:18 <geekosaur> it is certainly closer to an interface than a class, but not that much closer
13:26:44 <the_2nd> geekosaur, well, I wanted to create objects of type Class
13:26:49 <the_2nd> that kinda doesnt work
13:26:56 <kadoban> the_2nd: Just to reiterate, it's probably a mistake to try to /directly/ match up concepts in other languages, especially ones like Java. There isn't generally a direct correspondence, haskell's semantics are pretty different from most languages people come in knowing.
13:27:12 <geekosaur> yes, because (a) there are no objects (b) a class is not a type
13:27:20 <kadoban> the_2nd: It's /definitely/ a mistake to try to say "okay this is how I'd do this in Java, how do I map these exact concepts to haskell"
13:27:32 <the_2nd> kadoban, sure
13:27:47 <geekosaur> we call them "typeclasses" for a reason. the "objects", to the extent that you can say there are such, are *types*
13:28:10 <geekosaur> that is, 3 is not an "object of class Num". Int is an "object of class Num".
13:32:29 <kclancy> i figured it out. I just need to use the --info flag
14:01:27 <mpickering> does anyone remember the tool which is like a reverse version of tags?
14:01:38 <mpickering> You give it an identifier and it lists everywhere where it is used
14:01:47 <geekosaur> cxref?
14:01:53 <geekosaur> or cscope or ...
14:03:37 <mpickering> hscope was it
14:03:38 <mpickering> thanks
14:04:17 <johnw> mpickering: GNU global can be made to work with Haskell also
14:07:06 <bennofs> johnw: hey johnw, can you merge some patches for the these package so that it works with vector? you seem to be in the maintainers group for these
14:07:16 <johnw> sure I can
14:07:19 <johnw> which PRs in particular?
14:07:46 <johnw> I may not have push access to isomorphism's repo, though
14:08:02 <phadej> johnw: https://github.com/isomorphism/these/pull/19
14:08:19 <phadej> johnw: I actually sent you an email today
14:08:39 <johnw> thanks, I just asked isomorphism for push access to his repo
14:08:48 <johnw> otherwise, I don't want us to get out of sync
14:09:47 <bennofs> cool, thanks
14:10:12 <phadej> :+1:
14:17:20 <pie_> Hey doodz
14:18:19 <JagaJaga> Hi guys! Do smone use fb library? Can I do FB.getPage without token?
14:22:48 <pie_> I'm watching a talk and will do some research afterwards but functional programming sounds perfect for FPGAs
14:23:19 <dmj> JagaJaga: did you try to make the request w/ a Nothing
14:25:58 <JagaJaga> dmj: sure. I do `FB.runNoAuthFacebookT manager $  do {FB.getPage (FB.Id "4") [] Nothing }`
14:27:11 <JagaJaga> dmj: getting `*** Exception: FacebookException {fbeType = "invalid_token", fbeMessage = "An access token is required to request this resource."}`
14:37:48 <mpickering> then you need to use an access token?
14:38:30 <JagaJaga> mpickering: As I see here https://github.com/prowdsponsor/fb/blob/master/tests/Main.hs#L200 I don't need it..
14:39:40 <mpickering> They might have changed the API
14:40:00 <glguy> Or perhaps the requirement to open page "4" are different from the one in the test
14:42:24 <JagaJaga> mpickering: seems so..
14:50:20 <erisco> if you have a stream, the idea being that data can be read forward in order (like a tape drive), how do you deal with the persistence of old stream positions?
14:51:13 <erisco> so for example, I might have  read :: Stream a -> Maybe (a, Stream a)  lets say, which reads one element from the stream and returns the remaining stream
14:51:38 <erisco> so lets say  x :: Stream a,  then  I do  read x   to read the next element
14:51:57 <erisco> but then I still have 'x' around, and so I might 'read x' a second time
14:52:25 <erisco> but the stream has moved on, it is not reversible
14:52:48 <bennofs> erisco: that cannot happen with pure code
14:53:22 <bennofs> erisco: of course, you could have read :: Stream a -> IO (Maybe (a, Stream a)) which could have such a behavior
14:53:39 <erisco> the question is the same
14:53:42 <erisco> sure, put in IO
14:53:42 <arkeet> bennofs: that doesn't stop you from reading the same stream twice
14:54:06 <bennofs> arkeet: I know, just wanted to point out that with the given type, it's not possible that reading twice is somehow impossible
14:54:49 <bennofs> erisco: so, if you want to make an API to prevent reading a stream twice, perhaps you can make the api so that reading from a stream directly is impossible in general? Or just don't provide a "pointer" to an element in a stream?
14:55:23 <arkeet> why not something like pipes
14:55:36 <bennofs> yeah, or something like pipes. that is probably the best solution
14:57:04 <GLM> Does anyone known if there are libraries in haskell like pandas, spark, and sci-kit learn
14:58:14 <cocreature> @hackage Frames
14:58:14 <lambdabot> http://hackage.haskell.org/package/Frames
14:58:20 <cocreature> that's similar to pandas
14:58:29 <cocreature> I don't think we have something like sci-kit learn
14:58:43 <arkeet> or more generally just some sort of monadic interface where you can't directly manipulate the state of the stream, but only read values
14:58:58 <cocreature> hlearn probably comes closest, but it's quite different/behind
14:59:33 <erisco> maybe a lazy list
14:59:43 <GLM> Yeah. I read the state of Haskell yesterday and figured I could help with a lot of the math libraries
15:00:26 <cocreature> GLM: you might want to join #numerical-haskell as well
15:01:35 <erisco> the only solution I'd have is to cache everything read out of the stream, because you could ask for any part of it again
15:01:47 <erisco> of course that isn't ideal
15:02:03 <erisco> but if I gave you a lazy list, the idea would be that you're responsible for deciding what information you want to hang on to
15:08:09 <erisco> hm, you'd need to know that there is only going to be one thunk
15:08:15 <erisco> and it is going to be evaluated at most once
15:23:41 <ttt_fff> what is the difference between RWST r w s (EitherT a) or EItherT (RWS r w s a)
15:23:50 <ttt_fff> what is the difference between RWST r w s (EitherT a) *and* EItherT (RWS r w s a)
15:26:20 <Cale> One is a kind error
15:26:50 <arkeet> how about EitherT (RWS r w s) a
15:27:05 <arkeet> well
15:27:10 <arkeet> all of them are kind errors.
15:27:20 <arkeet> let's talk about RWST r w s (Either e) a vs EitherT e (RWS r w s) a
15:27:35 <Cale> Oh, you're right, they are
15:28:51 <Cale> r -> s -> Either e (a, s, w) vs. r -> s -> (Either e a, s, w)
15:30:34 <kadoban> So essentially you always get either an error or an 'a', but one way you always get the log and the state at the end, the other way you only get the log and the state if there wasn't an error
15:37:53 <bennofs> Can I create an expression that'll look up a thunk in a map, so that when the expression is forced, the map can be garbage collected (the expression doesn't keep a reference to the map) while the thunk itself is still not forced?
15:39:09 <bennofs> Basically, I want to force the lookup without forcing the item itself
15:42:33 <dedgrant_> Hmm.. Is there some way to satisfy GHC here without UndecidableInstances (willing to rewrite completely)? http://codepad.org/z531bdZT
15:43:07 <glguy> bennofs: It sounds like you just want to use Map.lookup and seq the result. That will only force the Nothing/Just constructor
15:43:18 <glguy> but not the value stored in the map
15:43:28 <bennofs> glguy: oooh, right, lookup returns Just or Nothing
15:45:13 <bennofs> glguy: aw, I'm using Map.findMax, so I'll probably have to do a Map.map Lazy before and then force the Lazy wrapper
15:46:35 <glguy> bennofs: Looking that the definition of findMax you can force the tuple constructor
15:46:52 <glguy> It only produces that tuple on success
15:47:19 <bennofs> glguy: ah cool
15:49:15 <bennofs> glguy: needing the Lazy wrapper anyway, since my function only returns one value of the type that I don't want to force in a higher-up function
15:49:50 <bennofs> figuring out who's still holding references to this map is really difficult 
15:51:07 <johnw> dedgrant_: have you looked into PolyKinds?
15:51:27 <bennofs> glguy: do you happen to know if it's possible for a Map to be partially garbage-collected while traversing toList of that map ?
15:51:43 <Jello_Raptor> aargh >_> I have no idea how to interleave actions in a monad transformer stack together. I want to be able to pass a function that uses information from an 'outer' monad to make a decision into a context where an 'inner' monad can choose when and how to evaluate it. 
15:52:03 <johnw> Jello_Raptor: that's what http://hackage.haskell.org/package/monad-control is for
15:52:54 <hpc> monad-control has some issues that i think extend all the way to type-safety?
15:52:58 <anderson> http://imgur.com/jRMPErK
15:53:01 <hpc> or just some weirdness wrt IO and exceptions and such
15:53:03 <anderson> sorry wrong channel.
15:53:17 <glguy> bennofs: I've never tested by looking at how it's implemented it seems like it would
15:53:22 <johnw> liftWith $ \runInInner -> ... some code in inner; f (runInInner (... some code in outer ...))
15:53:25 <hpc> but it's overall convenient
15:53:32 <bennofs> glguy: cool, thanks
15:53:38 <johnw> hpc: can you repeat what you said before?
15:53:56 <johnw> about monad-control
15:54:34 <hpc> 18:52 < hpc> monad-control has some issues that i think extend all the way to type-safety?
15:54:37 <hpc> 18:52 < hpc> or just some weirdness wrt IO and exceptions and such
15:54:49 <johnw> what kind of issues are you talking about?
15:55:03 <johnw> I use monad-control pretty extensively
15:55:06 <dedgrant_> johnw: Lightly. I only know of PolyKinds application to Proxy. Is there a clue here? :)
15:55:06 <hpc> i don't remember, i just know i read about it
15:55:19 <hpc> it was something pretty nitpicky
15:55:24 <johnw> dedgrant_: you could have your 'p' instantiate at different kinds
15:55:42 <hpc> there should be a bot here that does "precog"
15:55:44 <Jello_Raptor> also, there's a package somewhere which allows Control.Lens's makeFields operation to be split amongst modules while sharing field classes, does anyone know what it's called? 
15:55:50 <johnw> hpc: using monad-control with async code requires understanding when your transformer can be re-entrant
15:55:53 <hpc> where when you join a channel, it can pm you the last few lines
15:56:03 <hpc> that's probably it
15:56:15 <johnw> that's the only "issue" I'm aware of
15:56:25 <johnw> you're probably thinking of snoyberg's monad-unlift post
15:57:06 <hpc> oh no, this is the thing
15:57:07 <hpc> http://blog.ezyang.com/2012/01/monadbasecontrol-is-unsound/
15:57:17 <johnw> ah
15:57:18 <hpc> (title was changed to "tricky")
15:57:47 <johnw> yep, state is not re-entrant
15:58:04 <johnw> nor are several transformers, so yes, it's tricky
15:58:07 <johnw> works awesome for ReaderT
15:58:13 <dedgrant_> johnw: I see I've made a mistake perhaps making this moot. I'm instantiating at (PM n t :+ a) and PZ (rather than PM and PZ), so I supposed PolyKinds aren't really the issue here.  Still muddling through my understanding..
16:03:29 <Sindriav_> Is there an internal difference between newtype and data?
16:03:32 <glguy> dedgrant_: It looks like you're trying to do something like this: https://github.com/VinylRecords/Vinyl/blob/master/tests/Intro.lhs
16:04:01 <johnw> Sindriav_: newtype is only a type wrapper; data also wraps the value at runtime
16:04:08 <glguy> dedgrant_: You're going to have a hard time not having an association between the record field symbols and the record field types like this has, though
16:04:34 <Sindriav_> johnw: I see. So newtype would "disappear" in compiled code, whereas data wouldn't?
16:04:41 <glguy> In the above example there is a type family that computes the type of a field given the name of the field
16:04:44 <johnw> pretty much, yes
16:04:52 <Sindriav_> johnw: Thanks ^^
16:10:11 <dedgrant_> glguy: Sums it up well I think. :)  I see. I'll have to spend some time understanding how the type families in Vinyl enable GHC to satisfy the dependencies.
16:15:49 <lpaste_> glguy pasted “Simpler example for dedgrant_” at http://lpaste.net/139231
16:16:33 <dedgrant_> glguy: Oh this is fantastic ty. Reading it.
16:18:39 <glguy> dedgrant_: I just threw that together. I'm not certain that throwing the KnownSymbol constraint on RCons is ideal, but it should be about as simple as an example can be for what I thnk you're trying to do
16:19:51 <dedgrant_> glguy: It helps me get a handle on how type families can interact here.
16:21:05 <glguy> dedgrant_: In Vinyl things are parameterized over a record name type and type family from those names to types instead of hardcoding in one like I did
16:22:20 <mauris__> how does https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Control.Applicative.html get away with writing
16:22:36 <mauris__> "instance Functor (Const m) where ..."
16:22:49 <mauris__> with {-# LANGUAGE NoImplicitPrelude #-} and no other imports of Functor?
16:23:03 <mauris__> oh, `import GHC.Base`. 
16:23:06 <dedgrant_> glguy: Yea that is probably going to be important since I'd like to try generating a rather large number of permutations of field names and types eventually.
16:24:49 <dedgrant_> glguy: Looks like I'll have to be satisfied with doing a pass to collect all of the symbols and dependencies first anyway. Was hoping for more of an adhoc approach to introducing symbols and dependencies in-situ, but it is what it is.
16:27:17 <tomus> example of a game/puzzle where the optimal strategy is random?
16:27:38 <tomus> sorry, wrong chat
16:28:46 <isocliff> tomus: rock paper scissors
16:31:50 <GeissT> tomus: life!
16:34:46 <tomus> :)
16:51:31 <forsburn> what make haskell a good first langage?
16:51:36 <forsburn> language *
16:52:25 <Beardful> JuicyPixels question: I have an Image PixelRGB8, i tried saving w/ saveJPGImage, but it needs DynamicImage instead. What do?
16:53:04 <ttt_fff> just figured out the benefits of Stacking RWST + EitherT, instead of RWST with an inner Either ... haskell is amazing
16:53:33 <glguy> Beardful: make a DynamicImage using your Image PixelRGB8
16:54:50 <Cale> forsburn: It's pretty high level, so it lets you focus on the meaning of your program, rather than irrelevant bookkeeping details. Its type system and features generally guide you to develop good habits that might otherwise take years to learn if you were writing in an imperative language.
16:55:32 <Cale> Especially things like how to keep the amount of mutation of state to a minimum.
16:55:36 <Beardful> glguy: Lol, thanks, that actually helped. ;D
16:55:52 <glguy> Beardful: I was hoping it would :)
16:56:56 <forsburn> cale i'm interested in learning this haskell but have been told it is very difficult, hence my question, since i've also seen people say its best first language (sorry for bad english)
16:57:48 <ttt_fff> Haskell is difficult in the same way that "eating a healthy diet" is difficult for people who have been eating fast food all their life.
16:58:26 <ttt_fff> The easiest way to be 'productive' in non-haskell languages is to have habits that are very very bad in haskell.
16:58:39 <ttt_fff> Much of the 'difficulty' comes from un-learning these bad habits and seeing the world in the Haskell way.
17:00:40 <ttt_fff> https://typesandkinds.wordpress.com/2015/08/19/planned-change-to-ghc-merging-types-and-kinds/ looks crazy. Is haskell really heading towards dependent types?
17:01:25 <forsburn> but are haskell habits bad in normal languages (like c c++ python etc)?
17:07:28 <o`connor> what does the _info and _closure symbol mangling mean?
17:08:58 <srhb> forsburn: Most idioms of functional programming are hard or impossible to fully employ in imperative ones. Discussing it in depth is difficult if this is your first language.
17:21:59 <ttt_fff> well, it is probably possible to implemetn haskell idioms in C++ via templates
17:22:05 <ttt_fff> but at that point, it's not clear it's relaly C++ anymore
17:26:10 <forsburn> will haskell make me better coder than python or c as first language?
17:26:59 <dmj> forsburn: it might be easier to learn as your first language than if you were coming from python/C
17:28:04 <julesjacobs> i doubt that very much
17:28:39 <julesjacobs> there are enough similarities between almost any two languages that learning the second will be easier than the first
17:29:12 <mniip> julesjacobs, both languages mimic math in calculation-like expressions :P
17:29:17 <mniip> other than that not much
17:30:29 <srhb> forsburn: Asking this question in #haskell is bound to give you one overwhelming respond (if only we weren't restraining ourselves so much): Yes, it will make you a better coder, a happier person and you may indeed live forever and ever as a direct result.
17:30:36 <srhb> response*
17:31:31 <mniip> yeah, can confirm, everyone is given an infinite life
17:31:55 <MarcelineVQ> infinite lists infinite lives
17:32:24 <ttt_fff> @hoogle (b -> b) -> (Either a b -> Either a b)
17:32:25 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
17:32:25 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
17:32:25 <lambdabot> Data.Graph.Inductive.Basic elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
17:32:29 <ttt_fff> @hoogle (b -> b) -> (Either a b -> Either a b)
17:32:29 <lambdabot> Data.Graph.Inductive.Graph emap :: DynGraph gr => (b -> c) -> gr a b -> gr a c
17:32:29 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
17:32:29 <lambdabot> Data.Graph.Inductive.Basic elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
17:32:31 <forsburn> what langauge is best for someone intersted in brain to computer interface
17:32:33 <julesjacobs> i think you should base your first language choice mainly on the availability of a great introductory text
17:32:35 <srhb> forsburn: And I don't mean to be contrary, I just think it's very hard to give you concrete evidence for the (obvious!!11one) superiority of Haskell in an easily digestible way if we cannot even compare it to other languages because that would be meaningless to you :)
17:32:37 <ttt_fff> is there no builtin for mapping the 2nd arg of an Either
17:32:38 <mniip> ttt_fff, fmap?
17:33:00 <ttt_fff> :t fmap
17:33:01 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:33:10 <ttt_fff> mniip: that's pretty brilliant
17:34:34 <srhb> forsburn: A quick search shows that OpenVIBE (a BCI library) is written in C++. Perhaps that's interesting to you. But really, this channel is about Haskell. :)
17:58:13 <tomberek> @djinn: f a (b,c) = a b c
17:58:13 <lambdabot> Cannot parse command
17:58:24 <arkeet> :t uncurry
17:58:25 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:58:31 <tomberek> yay
17:58:51 <Bruuuuuuuno> :t (,)
17:58:52 <lambdabot> a -> b -> (a, b)
17:59:09 <arkeet>  @djinn is for coming up with a function definition given a type
17:59:17 <arkeet> so not what you wanted anyway.
17:59:25 <arkeet> @pl f a (b,c) = a b c
17:59:25 <lambdabot> f = (`ap` snd) . (. fst)
17:59:26 <tomberek> uncurry is perfect
17:59:36 <arkeet> (don't use that @pl output)
18:00:34 <tomberek> i was using \(x,y) = x +y     ,,, uncurry (+) is cleaner
18:01:28 <mniip> @pl \(x, y) = x + y
18:01:28 <lambdabot> (line 1, column 9):
18:01:28 <lambdabot> unexpected "="
18:01:28 <lambdabot> expecting operator, pattern or "->"
18:01:31 <slack1256> this maybe is a silly basic question. On 'platonic/total' hask, how do curried functions fit?
18:01:36 <mniip> @pl \(x, y) -> x + y
18:01:36 <lambdabot> uncurry (+)
18:02:34 <arkeet> @pl \f (x,y) -> f x y
18:02:34 <lambdabot> (`ap` snd) . (. fst)
18:02:41 <arkeet> how silly
18:02:54 <arkeet> @pl \(x,y) -> f x y
18:02:54 <lambdabot> uncurry f
18:03:03 <slack1256> oh wait. a -> b -> c == a -> (b -> c) and (b -> c) is a type thus and object of the cat
18:03:48 <mniip> slack1256, internal hom-sets ftw
18:06:38 <slack1256> !!
18:07:06 <slack1256> i can see them as hom-sets, right!
18:07:37 <Bruuuuuuuno> :t uncurry (+)
18:07:38 <lambdabot> Num c => (c, c) -> c
18:08:11 <Bruuuuuuuno> wait, what's that @pl thing?
18:08:25 <arkeet> it makes your code pointless.
18:08:40 <Bruuuuuuuno> what do you mean by pointless?
18:08:44 <arkeet> "point" means function argument, basically.
18:09:24 <Bruuuuuuuno> oh okay thanks
18:09:33 <arkeet> I guess a more typical term is "point-free"
18:09:40 <arkeet> \x -> f (g x) isn't point-free, because it has a point (namely x)
18:09:44 <arkeet> @pl \x -> f (g x)
18:09:44 <lambdabot> f . g
18:10:06 <arkeet> sometimes it's good, like this.
18:10:10 <arkeet> sometimes it just obscures your code.
18:10:13 <mniip> even thought the above expression has a point (.), it's point-free :D
18:10:21 <Bruuuuuuuno> is there a way to use this tool without having to go here?
18:10:28 <mniip> Bruuuuuuuno, pointfree
18:10:35 <mniip> also by hand
18:10:39 <arkeet> @hackage pointfree
18:10:39 <lambdabot> http://hackage.haskell.org/package/pointfree
18:10:48 <arkeet> doing it by hand is a nice exercise.
18:11:02 <mniip> if you can't do it by hand you probably should leave the points intact
18:11:13 <arkeet> that's a good point.
18:11:24 <arkeet> :-)
18:11:28 <Bruuuuuuuno> thanks
18:12:10 * mniip <- someone who has done advanced flippery-constery-joinery
18:12:40 <mniip> '\a b c d e f -> f e d c b a' is *not* something you want to point-free
18:12:54 <arkeet> @pl \a b c d e f -> f e d c b a
18:12:55 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
18:12:57 <Axman6> all you need id id, const and ap bro
18:13:00 <Axman6> is*
18:13:10 <mniip> you don't actually need id
18:13:20 <mniip> 'const <*> const' is good enough
18:13:31 <arkeet> :t ap const const
18:13:32 <lambdabot> b -> b
18:14:07 <Bruuuuuuuno> :t (<*>)
18:14:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:14:13 <Bruuuuuuuno> :t const
18:14:14 <lambdabot> a -> b -> a
18:14:42 <arkeet> in this case, (<*>) :: (r -> a -> b) -> (r -> a) -> r -> b
18:14:49 <mniip> Bruuuuuuuno, for the purpose of this discussion, (<*>) :: (a -> b -> c) -> (a -> b) -> a -> c
18:19:14 <Bruuuuuuuno> :t const . const
18:19:15 <lambdabot> a -> b -> b1 -> a
18:19:39 <arkeet> :t (flip .) . const . const
18:19:40 <lambdabot> (b -> c) -> a -> b -> a1 -> c
18:19:43 <arkeet> oops
18:19:52 <arkeet> :t flip (const . const)
18:19:53 <lambdabot> b -> a -> b1 -> a
18:20:05 <arkeet> :t const const
18:20:06 <lambdabot> b -> a -> b1 -> a
18:20:12 <mniip> I was about to say that
18:20:23 <arkeet> :t (const . const) id
18:20:25 <lambdabot> b -> b1 -> a -> a
18:22:01 <mniip> > sk (Abs "a" $ Abs "b" $ Abc "c" $ Var "c")
18:22:02 <lambdabot>      Not in scope: data constructor ‘Abc’
18:22:02 <lambdabot>      Perhaps you meant ‘Abs’ (line 147)
18:22:09 <mniip> > sk (Abs "a" $ Abs "b" $ Abs "c" $ Var "c")
18:22:11 <lambdabot>  K (K (S K K))
18:22:25 <arkeet> yes
18:23:19 <jle`> mniip: you can probably make your functions take Expr's instead of strings so we can use things like x y z as "literals"
18:23:28 <jle`> if it is your heart's desire
18:23:44 <mniip> jle`, see if you can modify the underlying lpaste to do that
18:23:54 <jle`> do you have the link to the one you're using now?
18:24:12 <mniip> [21:25:01] <mniip> @letlpaste 139170
18:24:35 <jle`> actually maybe overloaded strings is nice enough
18:24:51 <arkeet> lambdabot doesn't have that, though.
18:24:59 <noodles1> Theoretical programming question: Is a function that reads a number from the keyboard referentially transparent? If the some key is pressed it returns the same value every other time that key is pressed; However if it's input is viewed as the keyboard and not the individual key then it's return is different and not deterministic
18:25:09 <jle`> @let {-# LANGUAGE OverloadedStrings #-}
18:25:09 <lambdabot>  Parse failed: Parse error: EOF
18:25:10 <arkeet> why not just write a parser?
18:25:10 <mniip> jle`, I was thinking about making sk :: String ->
18:25:14 <arkeet> yeah
18:25:18 <mniip> yeah that
18:25:26 <jle`> boo make an edsl
18:25:28 <arkeet> noodles1: what is the function?
18:25:30 <eitanChatav> Hi. Is there a way to tell QuickCheck that I'm ok with 99 out of 100 tests passing?
18:25:32 <arkeet> what is its argument and output?
18:25:34 <mniip> jle`, I did make an edsl
18:25:45 <jle`> i mean, make another edsl
18:25:52 <mniip> > Abs "x" $ Var "x" `App` S `App` K
18:25:53 <lambdabot>  \x -> x S K
18:25:54 <jle`> as a general advice, not to this in partic
18:26:05 <jle`> ular
18:26:08 <arkeet> eitanChatav: I don't believe so, but if you know which tests you expect to fail, you can put that in your test.
18:26:12 <arkeet> with ==> or something maybe.
18:26:14 <jle`> when in doubt, edsl it out
18:26:19 <jle`> that is my life motto
18:26:31 <eitanChatav> arkeet: I don't know which tests will fail. It's just a probabilistic thing :-(
18:26:45 <arkeet> sounds weird.
18:27:00 <noodles1> arkeet: readnumber -- read a number from the keyboard, return the number
18:27:14 <arkeet> noodles1: what's the argument?
18:27:19 <arkeet> what's the type?
18:27:34 <eitanChatav> I guess I'm gonna really have to learn about hypothesis testing and p-values or something :-/
18:27:54 <dramforever> eitanChatav: I guess you just need to be okay with it yourself
18:28:04 <dramforever> wait no
18:28:11 <arkeet> quickcheck probably isn't the thing to use for that.
18:28:15 <dramforever> yep
18:28:25 <dramforever> that's why I said "wait no"
18:28:44 <eitanChatav> dramforever: I'm quivering in anticipation now
18:29:13 <jle`> noodles1: any discussion of purity and side effects really has to be qualified by the context in which purity and side effects are considered/their definitions
18:29:17 <dramforever> sorry =P
18:29:28 <noodles1> arkeet: type is numeric, unsigned short integer under the covers, it's argument is ..?
18:29:30 <jle`> so it really depends on the context you are talking about and how you define functions, purity, side effects, etc.
18:29:54 <arkeet> noodles1: at least in haskell, the thing you describe isn't a function at all.
18:31:19 <noodles1> jle`: yes, I see that; it's a question on an exam, I guess the correct answer is just to elaborate on the difference depending on the context
18:31:41 <jle`> well, if you're taking an exam for the class, there's a chance that the class itself gives the context
18:31:48 <jle`> of what is defined as what
18:33:15 <jle`> if we narrow down the scope of the question from 'theoretical programming' and go to haskell in specific, there is a subroutine/procedure that describes reading a number from the keyboard.  the description of the procedure itself is pure, refentually transparent, etc.
18:33:33 <jle`> but it's not a function, yeah
18:35:07 <noodles1> "in the absence of side effects the evaluation of an expression doesn't depend on the computation done before said evaluation, therefore the value of said expression will be the same in any part of the program, which is refered to as referential transparency."
18:36:29 <arkeet> generally anything that interacts with the real world isn't referentially transparent.
18:37:06 <jle`> `getLine` is referentially transparent, as its evaluation does not depend on any side effects, and its evaluation will be the same in any part of the program
18:37:30 <jle`> if you're using that definition
18:37:48 <jle`> getLine is certainly not a function in this sense, though
18:37:59 <arkeet> and evaluation of getLine doesn't get any lines from anywhere.
18:38:13 <noodles1> The entire question is "Define the concept of referential transparency and indicate if the following functions are, or are not, referentially transparent: a) factorial function b) a function that returns the amount of times it's been called c) a function that reads a number from the keyboard."
18:38:56 <arkeet> what is "function" in this context?
18:39:02 <nshepperd> noodles1: is this meant to be in an imperative programming context?
18:39:02 <jle`> definitely looks like that class is not using function in the mathematical sense
18:39:34 <jle`> or in the haskell sense
18:40:40 * dramforever was away for a while and I'm not understanding that
18:41:05 <noodles1> I've now given *literally* all the information I can give, barring another time the textbook mentions referential transparency which is identical to the def. I gave, anything else I say is just my 'hunch'
18:41:19 <jle`> i think that the answer the teacher is expecting is probably that it's not
18:41:29 <noodles1> nshepperd: Since it doesn't explicitly say, I believe no, any paradigm
18:41:39 <eitanChatav> I'm running the quickcheck tests from tasty. Is there a way to tell it to only run 10 tests, instead of 100?
18:42:06 <jle`> but it's weird, because functions can be evaluated without being called even in an imperative context
18:42:11 <nshepperd> imperative languages have zero argument "functions" to execute effects like that, so that you can build the expression "getLine()" that represents the result of getting a line
18:42:25 <dramforever> so the biggest problem is: what's a function?
18:42:28 <nshepperd> that expression would be non-referentially-transparent
18:42:34 <arkeet> eitanChatav: http://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Test.html#v:quickCheckWith
18:42:42 <johnw> I wonder why any of those "functions" _wouldn't_ be referentially transparent.  I often hear people saying RT when they just mean "output determined by input", instead of "allows substitution of equals without changing semantics"
18:43:10 <dramforever> johnw: I thought they were equivalent
18:43:17 <jle`> you can evaluate a function that reads a number from the keyboard without actually reading a number from the keyboard
18:43:35 <jle`> so the function when used is really the same function at any point in the program
18:43:41 <dramforever> jle`: again that depends on what "a function is RT" means
18:43:44 <jle`> the result of its calling/execution might be different
18:43:49 <johnw> dramforever: I didn't think so
18:43:57 <dramforever> noodles1: ^ do you have one in the textbook?
18:44:07 <dramforever> I mean the definition
18:44:08 <jle`> dramforever: according to noodles1's definition, it refers to the evaluation of an expression
18:44:13 <eitanChatav> arkeet: thanks
18:44:15 <dramforever> oooh
18:44:16 <johnw> a function that doesn't vary on its _arguments_ might vary on substitution of equals, if it is contextually dependent
18:44:17 <jle`> but an expression containing a function can be evaluated without execution of the function
18:44:40 <jle`> for example, evaluationg [1, function () { alert('hey'); }, 3] doesn't trigger any alerts in javascript
18:45:10 <dramforever> yep
18:45:15 <dramforever> but that's hardly a function...
18:45:31 <jle`> it looks like it's the a function in the context of the question though
18:45:49 <dramforever> it doesn't look like a function at all...
18:46:07 <noodles1> "indique si las siguientes funciones son, o no, transparentes referencialmente." my translation: "indicate if the following functions are, or are not, referentially transparent."
18:46:13 <nshepperd> it's likely that "function is referentially transparent" is short for "an expression that is a function call is referentially transparent" here, which is the usual usage
18:46:29 <jle`> it looks like it's what the question seems to define the word 'function' as...whether or not it's a sensible definition is another issue :)
18:46:36 <arkeet> wikipedia defines referential transparency of *expressions*
18:46:36 <dramforever> noodles1: so what about the definition?
18:46:41 <noodles1> It doesn't specify whether it means execution or evaluation. Your guess is as good as mine
18:47:06 <johnw> I like this: "The phrase 'referentially transparent' is used to describe notations where only the meaning of immediate component expressions is significant in determining the meaning of a compound expression. Since expressions are equal if and only if they have the same meaning, referential transparency means that substitutivity of equality holds (i.e. equal subexpressions can be interchanged in the context of a larger expression to
18:47:07 <johnw> give equal results)."
18:47:09 <jle`> having not taken the course and guessing the intent of the exam writer, i would say that they expect the answer "no" for c
18:47:22 <arkeet> so you can talk about referential transparency of function applications. which is different from referential transparency of functions (which are expressions)
18:47:22 <noodles1> dramforever: "in the absence of side effects the evaluation of an expression doesn't depend on the computation done before said evaluation, therefore the value of said expression will be the same in any part of the program, which is refered to as referential transparency."
18:47:32 <jle`> but a sufficiently elaborate answer showing that you know what you're talking about is probably okay too
18:47:39 <jle`> s/elaborate/descriptive
18:48:00 <dramforever> hmm...nothing about RT of functions, I have to guess that it means an expression that calls a function
18:48:03 <nshepperd> when we loosely talk about "+ is RT" in haskell we are talking about "x + y is RT for all RT x,y"
18:48:07 <dramforever> then it's kinda obvious
18:48:13 <dramforever> nshepperd ++
18:48:40 <dramforever> the problem with haskell people: we get easily carried away by simple-looking questions
18:48:55 <noodles1> thank you all for entertaining this rather off-topic question
18:49:02 <arkeet> np
18:49:08 <noodles1> dramforever: no no, this is what I needed
18:49:11 <kadoban> Heh … I wonder why the only link the HUnit main description has in it is to junit … seems so weird.
18:49:54 <dramforever> noodles1: "carried away" hmm... I mean we talk about it very seriously and in detail
18:49:56 <jle`> haskell itself is very bad with using ambiguous wording
18:49:59 <nshepperd> in the context with (imperative) functions that do things, they are undoubtably thinking of the expressions factorial(x), countCalls(), getLine()
18:50:15 <jle`> common haskell lexicon uses a lot of terms that have so many meanings that they're made almost meaningless...
18:50:24 <jle`> so when talking about haskell you have to be careful with what you're saying, heh
18:50:31 <noodles1> the prof. isn't trying to see if the student read a one sentence definition of RT one time and can regurgitate it, its simple looking, but they want a nuanced answer
18:51:16 <jle`> the problem in haskell is that the things with multiple meanings have very simliar but slightly different meanings in critical ways, so it's easy to forget
18:52:39 <dramforever> noodles1: IMHO they want intuition
18:53:30 <noodles1> dramforever: yes, that's why i came here :) (also because the course/book uses Haskell)
18:53:37 <dramforever> =)
18:54:52 <mauris> is there a hoogle for kind signatures?
18:56:09 <jle`> @hoogle * -> (* -> *) -> * -> *
18:56:09 <lambdabot> Parse error:
18:56:09 <lambdabot>   * -> (* -> *) -> * -> *
18:56:09 <lambdabot>    ^
18:56:11 <jle`> :(
19:01:38 <nolrai66> noodles1: What did you want to know?
19:03:14 <arkeet> fun = unsafePerformIO (randomRIO (1,6))
19:03:19 <arkeet> {-# NOINLINE fun #-}
19:03:23 <arkeet> is fun referentially transparent?
19:03:40 <dramforever> hmm...NOINLINE
19:03:40 * hackagebot cabal-helper 0.5.2.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.5.2.0 (DanielG)
19:03:54 <kadoban> So what does ":memory:" actually mean for sqlite3 databases? I get that it's in-memory, but … how long is it supposed to last? Does it only persist for one invocation of … runSqlite (from persistent), or I dunno, until reboot, or?
19:04:06 <nshepperd> arkeet: no
19:04:09 <exio4> kadoban: until you close it
19:04:14 <arkeet> nshepperd: why not?
19:04:44 <nshepperd> evaluating it affects the execution of the rest of the problem
19:04:57 <arkeet> it does?
19:05:01 <nshepperd> and it will have a different value depending when you evaluate it
19:05:07 <arkeet> assume for the sake of argument that randomRIO is truly random.
19:05:18 <nshepperd> yes, randomRIO uses the globalrandom
19:05:30 <arkeet> not a prng with any state.
19:06:18 <arkeet> nshepperd: I don't see your point.
19:06:30 <arkeet> if my program uses sum [1..100]
19:06:45 <arkeet> evaluating that affects the rest of the program.
19:06:54 <arkeet> (if it wasn't evaluated, the rest of the program wouldn't run.)
19:07:39 <arkeet> how about getTime instead.
19:07:44 <nshepperd> try a less strawman interpretation
19:08:05 <arkeet> ???
19:08:12 <jle`> for f x = (x, x), f fun /= (fun, fun).  does that count for anything?
19:08:23 <nshepperd> fun `seq` randomRIO (1,9)
19:08:32 <arkeet> oh sorry I meant the wrong thing.
19:08:36 <arkeet> :(
19:08:45 <arkeet> or said.
19:08:57 <jle`> if f x = (x, x), then that implies that f x = (x, x) for all x.  but f fun /= (fun, fun)
19:09:05 <arkeet> yes, I don't want that fun.
19:09:12 <jle`> you don't want any fun
19:09:15 <arkeet> :(
19:09:16 <jle`> mr no fun pants
19:09:31 <nshepperd> jle`: I think noinline protects against that
19:09:47 <jle`> oh
19:09:48 <arkeet> oh wait never mind that fun is fine.
19:09:53 <jle`> well now i have to think about evaluation
19:09:55 <jle`> :|
19:09:59 <kadoban> exio4: Hmm, thanks. Trying to match that up with … the stuff I see in examples XD
19:10:01 <arkeet> it will only be evaluated once.
19:10:26 <jle`> (fun, fun) will be evaluated twice, right?
19:10:37 <jle`> oh
19:10:41 <jle`> noinline
19:10:46 <arkeet> it's a CAF
19:10:46 <jle`> nevermind, heh
19:11:03 <jle`> yeah, i read NONLINE but i understood it as INLINE
19:11:07 <arkeet> heh.
19:11:19 <jle`> * NOINLINE
19:11:27 <arkeet> anyway, to avoid difficulties with state of RNGs
19:11:33 <arkeet> let's use getTime instead of randomRIO (1,6)
19:11:53 <arkeet> getCurrentTime
19:12:04 <dramforever> @hackage acme-year
19:12:04 <lambdabot> http://hackage.haskell.org/package/acme-year
19:12:14 <arkeet> that one's different.
19:12:20 <nshepperd> I wouldn't call that referentially transparent either
19:12:28 <Welkin> jle`: you would make for a troll compiler
19:12:38 <arkeet> I agree, but I want to hear some reasoning for why not.
19:12:47 <nshepperd> the result of the evaluation observably depends on its location in the program
19:13:21 <nshepperd> getCurrentTime >>= (\x -> threadDelay 1000 >> print (fun - x))
19:13:37 <arkeet> ?
19:13:47 <Welkin> that reminds me of C+=
19:13:54 <arkeet> fun is still NOINLINE.
19:14:23 <nshepperd> that code means approximately "print a number near 1000"
19:14:23 <jle`> it takes on the time when fun is first evaluated, but evaluation is potentially nondeterministic
19:14:52 <nshepperd> unless fun was evaluated earlier in the program in which case it'll print some large negative number
19:15:07 <arkeet> nshepperd: so?
19:15:49 <arkeet> I don't think it means that, though.
19:16:12 <arkeet> because of that unless.
19:16:14 <arkeet> I dunno.
19:16:36 <nshepperd> replacing the evaluation of 'fun' earlier in the program by its value changes the semantics
19:17:08 <arkeet> you're no fun.
19:17:43 <mniip> jle`, I just wrote some seriously distrubing code
19:17:52 <jle`> nshepperd has consistent semantics, so is definitely not `fun`
19:17:54 <nshepperd> ‾\(o.o)/‾
19:18:00 <jle`> mniip: o_o
19:19:23 <nolrai66> mniip:?
19:19:33 <mniip> I will post in a second
19:19:35 <ttt_fff> is there a shorthand for (lift . lift) (when using multiple monad transformers)
19:19:39 <nolrai66> mniip: can we use it as a ghost story come holloween?
19:20:33 <MarcelineVQ> it turns out the compiler was dead, all along!
19:21:02 <lpaste_> mniip revised “SK”: “No title” at http://lpaste.net/139170
19:21:06 <slack1256> ttt_fff: MonadBase gives you something like generalized liftIO but for any monad I think
19:21:09 <Welkin> ( ͝° ͜ʖ͡°)
19:21:16 <slack1256> Or so I've been told
19:21:34 <mniip> > parseLambda "/a b c -> c b a"
19:21:35 <lambdabot>  \a -> \b -> \c -> c b a
19:21:41 <mniip> > sk "/a b c -> c b a"
19:21:42 <lambdabot>  S (K (S (S (K S) (S (K (S (S K K))) K)))) (S (K K) K)
19:22:03 <ttt_fff> mniip: is that example of good or bad haskell coding style?
19:22:08 <Welkin> @let ( ͝° ͜ʖ͡°) = ($)
19:22:08 <lambdabot>  Parse failed: Illegal character ''\861''
19:22:19 <mniip> note that none of the following were used: parsec attoparsec peg regex ReadS
19:22:33 <mniip> ttt_fff, the parseLambda function, yes
19:22:48 <arkeet> > parseLambda "/foo -> foo"
19:22:50 <lambdabot>  \foo -> foo
19:22:52 <arkeet> ok
19:23:07 <dramforever> mniip: interesting, althought it's really like ReadS
19:23:25 <mniip> note that it totally accepts \, but it needs to be doubled while inside quotes
19:23:27 <Bruuuuuuuno> :t lift . lift
19:23:29 <lambdabot> (Monad m, Monad (t1 m), MonadTrans t, MonadTrans t1) => m a -> t (t1 m) a
19:23:37 <nolrai66> ttt_fff: medium?
19:23:50 <dramforever> > parseLambda (cycle "/foo ->")
19:23:52 <lambdabot>  *Exception: stack overflow
19:24:09 <dramforever> > parseLambda "\foo -> ( test test test"
19:24:10 <lambdabot>  *Exception: not a unit: "-> ( test test test"
19:24:12 <nolrai66> In my opinion the small functions are fine, but the longer ones..are..dense.
19:24:25 <mniip> dramforever, try /
19:24:32 <dramforever> yep
19:24:37 <mniip> you have a \f in the string
19:24:37 <dramforever> > parseLambda "/foo -> ( test test test" -- )
19:24:38 <lambdabot>  *Exception: not a close: ""
19:24:43 <dramforever> mniip: =P
19:25:05 <dramforever> I wonder if your parser will always output not a close ""
19:25:21 <mniip> lol
19:25:39 <mniip> I think so
19:25:40 <nolrai66> > parseLambda "/foo -> (a foo b foo)"
19:25:41 <lambdabot>  \foo -> a foo b foo
19:25:50 <nolrai66> > parseLambda "/a b foo -> (a foo b foo)"
19:25:51 <lambdabot>  \a -> \b -> \foo -> a foo b foo
19:26:00 <nolrai66> > sk "/a b foo -> (a foo b foo)"
19:26:02 <lambdabot>  S (S (K S) (S (K (S (K S))) (S (S (K S) (S (K K) S)) (K K)))) (K (K (S K K)))
19:26:10 <dramforever> > sk "/a -> a a a a"
19:26:12 <lambdabot>  S (S (S (K S) (S (S K K) (S K K))) (K (S K K))) (S K K)
19:26:31 <dramforever> > sk "/a b -> b a b a"
19:26:33 <lambdabot>  S (S (K S) (S (S (K S) (S (K (S (S K K))) K)) (K (S K K)))) K
19:26:47 <dramforever> > sk "/a b c -> a c (b c)"
19:26:49 <lambdabot>  S
19:26:52 <dramforever> good =)
19:26:56 <mniip> I should rewrite small-step semantics into big-step semantics by schoenfinkel
19:27:05 <mniip> and maybe someone with lambdabot knowledge could write a plugin
19:28:10 <dramforever> I still wonder if the naive one is better...
19:28:13 <Ryanar> hey guys -- trying to figure out why this line doesn't compile I have data X = Y Double | Other and data Z = X X | End -- I am trying to say let a = (Y 15.0) (Other) but I am getting an error saying Y is being applied to two arguments but only has one
19:29:16 <mniip> Ryanar, Y :: Double -> X
19:29:21 <mniip> are you confusing with X?
19:29:28 <mniip>  X :: X -> Z
19:30:01 <prsteele> hello everyone. Is there a pattern to generalize f >>= g >>= h >>= ... ? E.g. if I have fs :: (Monad m => a -> m a), can I string all of them together?
19:30:21 <prsteele> err, fs :: (Monad m => [a -> m a])
19:30:22 <mniip> prsteele, foldr (>=>)
19:30:44 <prsteele> oh, is this what arrows are for?
19:30:45 <prsteele> thanks
19:31:02 <roboguy`> prsteele: that's not an Arrow
19:31:02 <mniip> >=> is not arrows
19:31:07 <dramforever> this is what categories are for
19:31:07 <roboguy`> :t (>=>)
19:31:08 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
19:31:12 <mniip> >=> is kleisli arrow composition
19:31:14 <dramforever> compisition!
19:31:25 <prsteele> oh okay, haha it looked like one
19:31:41 <Ryanar> that is an interesting way to look at that mniip I don't see why its not working though, Z takes two X, for X you can make it with Y Double or Other
19:31:53 <mniip> Ryanar, Z doesn't take 2 X
19:32:13 <mniip> you have a datacon called X, that takes a value of type X as argument
19:32:16 <Ryanar> Ah
19:32:32 <Ryanar> so if it was data X = Y Double | X | Other
19:32:46 <Ryanar> I understand though
19:33:09 <mniip> Ryanar, you're confusing type-level and value-level entities
19:33:35 <prsteele> just to clarify, if I wanted to talk about what I'm doing I'd talk about Kleisi composition?
19:34:20 <roboguy`> prsteele: yep!
19:35:17 <prsteele> thanks! I started writing out a recursion, and I remembered that whenever I do that I'm usually missing just hoisting myself one level of thinking higher
19:35:34 <roboguy`> prsteele: http://haddock.stackage.org/lts-3.1/base-4.8.1.0/Control-Monad.html#v:-62--61--62-
19:35:57 <prsteele> mhmm
19:36:09 <roboguy`> that should probably say "Kleisli arrow" instead of monad (not to be confused with a capital a Arrow)
19:36:36 <roboguy`> but that's a relatively small semantics things
19:37:40 <prsteele> is it Kleisli arrow <-> category arrow?
19:38:18 <dramforever> not quite
19:38:26 <prsteele> alright, I'll keep reading
19:38:28 <dramforever> but it's kinda equivalent to Star
19:38:36 <dramforever> :t Star -- test
19:38:37 <lambdabot>     Not in scope: data constructor ‘Star’
19:38:38 <lambdabot>     Perhaps you meant ‘Str’ (imported from Text.PrettyPrint.HughesPJ)
19:38:48 <dramforever> :t Data.Profunctor.Star -- test
19:38:49 <lambdabot> (d -> f c) -> Data.Profunctor.Star f d c
19:38:52 <dramforever> good
19:39:25 <dramforever> hmm...isn't it ReaderT?
19:39:37 <jle`> prsteele: you can think of Control.Category as a typeclass, and Kleisli as an instance
19:39:57 <prsteele> well foldlr1 (>=>) was exactly what I wanted, so this is great
19:40:14 <jle`> maybe foldr (>=>) return would be a bit safer, heh
19:40:39 <prsteele> jle`: yup, you're right
19:40:45 <dramforever> +1 for foldr (>=>) retur
19:40:47 <dramforever> +1 for foldr (>=>) return
19:41:15 <jle`> we should have an EndoCat newtype
19:41:22 <jle`> with the appropriate monoid instance
19:42:26 <jle`> newtype EndoCat r a = EndoCat { runEndoCat :: r a a }    ... instance Category r => Monoid (EndoCat r a) where mempty = EndoCat return; mappend (EndoCat f) (EndoCat g) = EndoCat (f . g)
19:42:50 <jle`> type Endo = EndoCat (->)
19:43:34 <dramforever> "meow"
19:43:38 <jle`> um memoty = EndoCat id
19:44:16 <jle`> then you can do mconcat [EndoCat (Kleisli f), EndoCat (Kleisli g)].  definitely the best solution
19:44:28 <jle`> (don't do that)
19:45:32 <nshepperd> foldMap (EndoCat.Kliesli)?
19:45:50 <jle`> oh yeah
19:46:58 <ttt_fff> is there a known bug involving (1) ghc 7.8.x, (2) #define macros, and (3), the char ' appearsing in lines where a macro expansion is supposed to happen
19:47:13 <nshepperd> maybe have endoK, runEndoK helpers so you don't have to be writing out runKliesli . runEndoCat . foo . EndoCat . Kliesli just to do one thing
19:47:52 <mniip> withEndoCat (withKleisli foo)
19:47:54 <jle`> :t runKleisli . runEndoC . foldMap (EndoC . Kleisli)
19:47:56 <lambdabot> (Monad m, Foldable t) => t (b -> m b) -> b -> m b
19:48:00 <dcoutts> ttt_fff: the cpp mode ghc uses (at least for gcc) is "traditional" which is completely unspecified
19:48:13 <dcoutts> it follows Cish rules
19:48:13 <jle`> nshepperd: ideally you'd just be able to do coerce (foldMap coerce), right
19:48:39 <ttt_fff> dcoutts: practically, does this mena anything other than "use #define at you rown risk"
19:48:40 <mniip> jle`, would the instance resolve?
19:48:44 <roboguy`> ttt_fff: I think there was a problem with ' only being able to appear either an even or odd number of times (I don't remember which)
19:48:51 <nshepperd> does 'ala' work for composed newtypes?
19:48:59 <jle`> i've never actually used coerce in real life
19:49:03 <ttt_fff> roboguy`: well, even = 0 times is fine, 1 = odd times is not okay
19:49:06 <geekosaur> ttt_fff, C preprocessors do not speak Haskell and don't know what to do with Haskell's allowance for ' in names
19:49:11 <nshepperd> ala endoK foldMap?
19:49:12 <geekosaur> (or in Template Haskell)
19:49:15 <roboguy`> ttt_fff: you aren't using clang by chance, are you?
19:49:25 <roboguy`> there were issues with that at one point
19:49:37 <ttt_fff> roboguy`; not sure, how do I check? this is haskell platform latest on OSX latest
19:49:45 <geekosaur> you are using clang
19:49:46 <roboguy`> ttt_fff: on OSX, you almost certainly are
19:49:52 <ttt_fff> geekosaur: okay, that's a reasonable explaination of all the problems I have been having; thanks!
19:50:29 <roboguy`> ttt_fff: I would suggest upgrading
19:50:42 <roboguy`> that might not help the ' in CPP issues though
19:50:59 <geekosaur> I understand that at some point, hopefully 7.12 (although I think 7.10 already has some workaround), ghc will start using its own preprocessor (or possibly a version of cpphs)
19:51:16 <mniip> jle`, nor have I
19:51:22 <mniip> unsafeCoerce# or bust
19:51:38 <ttt_fff> geekosaur: I look forward to that day; I'd really like something lighter than lens, but slightly well defined other than "some hack involving gcc's preprocessor in an undefined state"
19:51:57 <roboguy`> I'm about 90% sure you can tell GHC to use a custom preprocessor, but I've never used that feature
19:52:38 <jle`> i can't even do coerce return :: Kleisli Maybe Int Int
19:52:45 <geekosaur> -progP I think but nmy notwork is being annoying so I'm not able to doublecheck readily
19:52:56 <jle`> what is your deal coerce?
19:52:56 <roboguy`> https://downloads.haskell.org/~ghc/7.6.1/docs/html/users_guide/options-phases.html#pre-processor
19:52:59 <geekosaur> also I think there is --cpp-program for cabal, but that might not be enough to also tell ghc
19:53:48 <ttt_fff> roboguy`: yeah, I have never tried that either
19:54:52 <nshepperd> jle`: Coercible a b class has no fundeps
19:55:14 <nshepperd> you need both sides to have sufficiently known type
19:55:42 <roboguy`> :t coerce (return :: Int -> Maybe Int) :: Kleisli Maybe Int Int
19:55:44 <lambdabot>     Couldn't match expected type ‘Kleisli Maybe Int a0’
19:55:44 <lambdabot>                 with actual type ‘Int -> Maybe Int’
19:55:44 <lambdabot>     In the first argument of ‘coerce’, namely
19:55:55 <roboguy`> well, that worked for me...
19:55:59 <nshepperd> :t coerce
19:56:00 <lambdabot> (Functor f, Contravariant f) => f a -> f b
19:56:05 <roboguy`> oh
19:56:07 <nshepperd> different coerce >_>
19:56:13 <roboguy`> :t Data.Coerce.coerce
19:56:14 <lambdabot> GHC.Types.Coercible a b => a -> b
19:56:22 <roboguy`> :t Data.Coerce.coerce (return :: Int -> Maybe Int) :: Kleisli Maybe Int Int
19:56:23 <lambdabot> Kleisli Maybe Int Int
19:56:27 <roboguy`> hey, there we go
19:56:45 <roboguy`> I don't think it would be possible for Coercible to have fundeps
19:58:48 <nshepperd> yeah, that wouldn't work, since it can add and remove any number of newtype wrappers at once
20:00:08 <roboguy`> :t coerce (undefined :: Data.Profunctor.Star Maybe Int Int) :: Kleisli Maybe Int Int
20:00:09 <lambdabot>     Couldn't match type ‘Data.Profunctor.Star Maybe Int’
20:00:09 <lambdabot>                    with ‘Kleisli Maybe Int’
20:00:09 <lambdabot>     Expected type: Kleisli Maybe Int Int
20:00:29 <dramforever> hmm...interesting
20:00:30 <dramforever> @more
20:00:49 <roboguy`> That worked on my ghci
20:00:59 <dramforever> @botsnack
20:00:59 <lambdabot> :)
20:01:05 <roboguy`> oh, same issue
20:01:13 <roboguy`> :t Data.Coercible.coerce (undefined :: Data.Profunctor.Star Maybe Int Int) :: Kleisli Maybe Int Int
20:01:14 <lambdabot> Not in scope: ‘Data.Coercible.coerce’
20:01:26 <roboguy`> I mean Data.Coerce.coerce... oh well
20:01:39 <jle`> > Data.Coerce.coerice (Sum (1 :: Int)) :: Product Int
20:01:41 <dramforever> :t coerce
20:01:42 <lambdabot>  Not in scope: ‘Data.Coerce.coerice’
20:01:43 <lambdabot> (Functor f, Contravariant f) => f a -> f b
20:01:47 <jle`> > Data.Coerce.coerce (Sum (1 :: Int)) :: Product Int
20:01:47 <dramforever> ha!
20:01:48 <lambdabot>  Not in scope: ‘Data.Coerce.coerce’
20:02:12 <jle`> what is life
20:02:22 <nshepperd> o_O
20:02:28 <roboguy`> is the coerce that's in scope the old name for phantom from Data.Void?
20:02:49 <roboguy`> I mean, the contravariant package
20:02:59 <dramforever> :t phantom -- test
20:03:00 <lambdabot> Not in scope: ‘phantom’
20:03:17 <nshepperd> :t Data.Coerce.coerce (Sum (1 :: Int)) :: Product Int -- this does work
20:03:18 <lambdabot> Product Int
20:03:20 <jle`> is it called phantom now?
20:03:24 <nitrix> What is the state of the current SDL bindings?
20:04:01 <jle`> :t Data.Coerce.coerce (Sum (Product (1 :: Int))) :: Product (Sum Int)
20:04:03 <lambdabot> Product (Sum Int)
20:04:05 <Xnuk> > 3>2>1
20:04:06 <mazur> anyone know how to get stack to find zlib package installed at the systen level? (NixOS)?
20:04:06 <jle`> neat
20:04:07 <lambdabot>      Precedence parsing error
20:04:07 <lambdabot>          cannot mix ‘>’ [infix 4] and ‘>’ [infix 4] in the same infix expression
20:04:15 <nitrix> I want to use SDL2. Also, is it a direct match with the C's api or are there popular libraries built on top of it that'd offer something more idiomatic / haskell-like ?
20:04:47 <jle`> Xnuk: no way of parenthesizing 3 > 2 > 1 really makes sense, anyway, unless you had a Num and Ord instance for Bool
20:04:48 <roboguy`> jle`: it doesn't look like it was ever called coerce in the contravariant package... I wonder where lambdabot is pulling that in from...
20:04:57 <roboguy`> (another reason lambdabot needs :i)
20:05:01 <jle`> i've always remembered it being called coerce
20:05:09 <jle`> but i'm not sure wher ei remember it from
20:05:46 <Xnuk> > (3>2) > (0>1)
20:05:48 <lambdabot>  True
20:05:53 <roboguy`> nitrix: SDL is slightly higher level and sdl2 is basically a C wrapper
20:06:08 <jle`> > True > False
20:06:10 <lambdabot>  True
20:06:27 <roboguy`> nitrix: there are other graphics libraries that are independent of SDL (from the API users perspective) if you want something more high level
20:06:56 <dramforever> @index coerce
20:06:56 <lambdabot> Data.Coerce, GHC.Exts, GHC.Prim
20:07:04 <Bruuuuuuno> Why is there no separation between file and directory in System.Directory. Like I could write getDirectoryContents "file.exe" and still get an error at runtime
20:07:19 <roboguy`> Bruuuuuuno: how would you separate that?
20:07:28 <Bruuuuuuno> data SystemItem = File FilePath | Directory FilePath
20:07:32 <jle`> i can make a directory called "file.exe"
20:07:34 <dramforever> Bruuuuuuno: file.exe could be a directory
20:07:40 <dramforever> jle`: ++
20:07:44 <dramforever> jle`++
20:07:44 <roboguy`> Bruuuuuuno: you could still get runtime errors if you accidentally have Directory "file.exe"
20:08:02 <jle`> actually i have a directory ~/file.exe/ , so it might be intentional too
20:08:13 <roboguy`> that's true too
20:08:53 <Bruuuuuuno> ya, but if I do getDirectoryContents myDirectory, I will threat directory and file differently 
20:09:07 <dramforever> hmm...would have fixed it if FilePath were opaque
20:09:26 <roboguy`> Bruuuuuuno: what will getDirectoryContents do if it gets a File?
20:09:32 <dramforever> https://www.reddit.com/r/haskell/comments/3b7gn0/abstract_filepath_proposal/
20:10:02 <Bruuuuuuno> fail? is already what it does "InappropriateType The path refers to an existing non-directory object. [ENOTDIR]"
20:10:21 <dramforever> maybe we should use a phantom or something
20:10:34 <roboguy`> Bruuuuuuno: hmm, then what's the advantage?
20:10:47 <jle`> Bruuuuuuno: data SystemItem = File FilePath | Directory FilePath will still make it a runtime error
20:10:55 <dramforever> getDirectoryPath :: String -> IO (Path Directory)
20:11:03 <dramforever> Path doesn't look quite right, though
20:12:52 <Bruuuuuuno> but I could do something like getAllSubDirectory = filter(\x -> x == Directory) $ getDirectoryContent
20:13:10 <dramforever> Bruuuuuuno: still kinda weird
20:13:19 <dramforever> maybe two separate types?
20:14:02 <Bruuuuuuno> what do you mean by two separate types?
20:14:12 <dramforever> DirectoryPath and FilePath
20:14:51 <dramforever> and we could even have getDirectoryPath :: String -> IO (Maybe DirectoryPath)
20:14:57 <dramforever> hmm...there's a problem
20:15:06 <dramforever> what about nonexistent files/dirs?
20:15:22 <Bruuuuuuno> Nothing?
20:15:26 <joehillen> dramforever: https://hackage.haskell.org/package/pathtype
20:15:30 <jle`> this is basically the same as letting the user specify whether or not a string represents a directory path or a file path
20:15:38 <dramforever> good
20:15:42 <jle`> so it wouldn't really handle non-existents
20:16:44 <nitrix> roboguy`: Could you name drop a few and I'll do my homeworks?
20:17:15 <nitrix> roboguy`: If you happen to know the pros and cons and the maturity of those, I wouldn't mind either.
20:19:29 * nitrix hesitates between the SDL package and haskell-game/sdl2.
20:20:07 <roboguy`>  nitrix: gloss is the first one that comes to mind
20:20:12 <roboguy`> it depends on what you're looking for
20:20:22 <nitrix> Are both using SDL 2.x ?
20:20:23 <Bruuuuuuno> oh the getDirectoryContents of your library does exactly what I want, thanks joehillen
20:23:40 <dibblego> glguy: ping
20:23:58 <roboguy`> nitrix: I'm not totally sure, hmm
20:24:14 <geekosaur> I think the SDL package is still SDL1
20:24:59 <nitrix> I'll give the sdl2 thing a try.
20:25:09 <nitrix> How bad can a C api look in Haskell...
20:48:05 <nitrix> createWindowAndRenderer :: MonadIO m => CInt -> CInt -> Word32 -> Ptr Window -> Ptr Renderer -> m CInt
20:48:29 <nitrix> Does that mean I'm supposed to do malloca with a lambda to get a Ptr Window?
20:49:23 <nitrix> alloca*
20:49:28 <c_wraith> nitrix: probably a malloc instead of alloca
20:49:54 <arkeet> ?
20:50:10 <c_wraith> nitrix: I mean, it's not like you're going to be calling this so many times that you will leak them.
20:50:27 <arkeet> ??
20:50:41 <arkeet> nitrix: you are trying to use this function?
20:50:55 <c_wraith> I've used it before.  malloc is easier to use with it than alloca
20:51:04 <arkeet> oh this is sdl
20:51:07 <c_wraith> arkeet: it's C-style multiple returns
20:51:43 <c_wraith> nitrix: eventually I gave up and went to createWindow and createRenderer independently for added flexibility anyway
20:53:14 <arkeet> so the Ptrs are just outputs
20:53:19 <c_wraith> yes
20:53:32 <arkeet> I don't see why you would want to use malloc and not alloca.
20:53:54 <arkeet> you're not going to keep those pointers around for any longer than that one call.
20:53:56 <c_wraith> Eh, maybe I did use alloca.  I just remember I quit using that function pretty rapidly anyway
20:54:33 <nitrix> It's a simple game, the window and renderer will exist for the whole duration of the program.
20:54:43 <nitrix> (From within main)
20:55:00 <arkeet> if I were to use that
20:55:05 <arkeet> I'd just make a thin wrapper like
20:55:18 <arkeet> CInt -> CInt -> Word32 -> IO (Window, Renderer)
20:55:29 <nitrix> arkeet: Gotcha.
20:55:36 <c_wraith> Oh, I remember the problem with it.
20:55:40 <c_wraith> Only one Word32 argument
20:55:44 <arkeet> use alloca to implement it
20:55:50 <arkeet> and then you don't have to fiddle with pointers anywhere else.
20:55:57 <c_wraith> It lets you set window options, but not renderer options
20:56:15 <c_wraith> arkeet: if you ignore than Window and Renderer are both synonyms for Ptr (), sure. :)
20:56:19 <c_wraith> *that
20:56:26 <jellie> Hey have you guys used FSNotify with actual filepaths? Say you wanted to watch for a filepath.
20:56:35 <arkeet> c_wraith: those are opaque pointers
20:56:36 <arkeet> :)
20:57:03 <nitrix> arkeet: And then I peek the Ptr Window to obtain the Window, and from now own, Haskell's Garbage collection will deal with it?
20:57:11 <arkeet> right.
20:57:31 <arkeet> if I had some foo :: A -> Ptr B -> IO ()
20:57:33 <arkeet> I'd wrap it like
20:57:50 <monochrom> I am uncomfortable with that answer. I would begin with: what does "it" refer to?
20:58:00 <arkeet> foo' :: A -> IO B; foo' a = alloca $ \pb -> foo a pb >> peek pb
20:58:07 <arkeet> monochrom: things.
20:59:38 <arkeet> nitrix: well, the GC won't deal with destroying the window when you're done with it.
20:59:56 <arkeet> you'd have to call destroyWindow somewhere.
21:00:00 <nitrix> arkeet: Right.
21:00:13 <arkeet> but the Window value itself is just a pointer (scalar value).
21:00:28 <Bruuuuuuno> is hackage down for everyone?
21:00:32 <arkeet> worksforme
21:00:32 <nitrix> And now Hackage is down.
21:00:38 <arkeet> oh 
21:00:40 <arkeet> it worked a minute ago :-)
21:01:11 <Bruuuuuuno> https://xkcd.com/903/
21:01:30 <arkeet> haha
21:02:34 <itsu> hehe nice
21:03:49 <jellie> Anyone know how best to convert Prelude.FilePath i.e String to https://hackage.haskell.org/package/system-filepath-0.4.10/docs/Filesystem-Path.html#t:FilePath ?
21:04:12 <jellie> The filepath from system-filepath is surprisingly complicated.
21:04:20 <nitrix> The sad thing is that it's true. Research has shown that frequent computer users are storing less of the raw information in their brain, but instead, create small associations of where they stored the information to find it back when needed.
21:05:14 <monochrom> I tried the "click the first link" experiment, starting from the "spark plug" article. it's true, eventually I hit the "philosophy" article.
21:05:37 <arkeet> I tried it with the thing I had open, namely "hardwood". same thing.
21:05:50 <kadoban> nitrix: Yay, we're all turning into androids
21:05:55 <arkeet> also -blah
21:06:04 <kadoban> Or cyborgs, I forget which.
21:06:29 <Bruuuuuuno> cybermen
21:07:26 <nitrix> jellie: https://hackage.haskell.org/package/system-filepath-0.4.10/docs/Filesystem-Path-CurrentOS.html
21:07:50 <nitrix> jellie: decodeString :: String -> FilePath ?
21:08:35 <nitrix> jellie: Or fromText, they seem to make a distinction of human-readable vs. non-readable.
21:08:42 <monochrom> "Do not use this function for parsing human‐readable paths"
21:08:47 * hackagebot xmonad-wallpaper 0.0.1.2 - xmonad wallpaper extension  https://hackage.haskell.org/package/xmonad-wallpaper-0.0.1.2 (yeyan)
21:10:57 <kadoban> So I'm pretty new to using Exceptions, kind of forced into it by persistent. If I use 'try', I end up with :: Exception e => IO (Either e SomeThing). What happens when I specialize that to :: IO (Either SqliteException SomeThing) ? If something throws another Exception instance, it will just pass up the chain ignoring my 'try', right? Just trying to check my understanding so far.
21:11:16 <monochrom> yes
21:11:36 <monochrom> read my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
21:11:49 <kadoban> Ah cool, will do.
21:12:03 <arkeet> monochrom has an article for everything.
21:12:59 <tiki> what would be an example of an Arrow "strictly between" Applicative and Monad?
21:13:30 <monochrom> probably the one modelling logic gates and signals
21:15:20 <tiki> monochrom: is there a paper/library/post i could look up?
21:15:32 <monochrom> the original Arrow paper
21:15:57 <tiki> "Generalising monads to arrows"? ok, ty
21:18:20 <c_wraith> I thought Applicative was newer than Arrow
21:18:27 <geekosaur> it is
21:18:44 <geekosaur> although Arrow in many ways pioneered what became Applicative
21:19:19 <c_wraith> My thought was merely that if Applicative is newer than Arrow, the paper introducing Arrow is not likely to have information on connections between Applicative and Monad.
21:19:33 <monochrom> "strictly between" refers to theoretically, not chronologically
21:19:59 <geekosaur> not under that name, no
21:20:33 <monochrom> my answer answers "where to find arrows for logic gates and signalling"
21:20:34 <geekosaur> possibly the original applicative paper (which also didn't call them Applicative... it used "idioms")
21:21:41 <monochrom> no, only one paper claims and proves that arrow is between applicative and monad. it is the Wadler "oblivious, meticulous, promiscuous" paper.
21:22:09 <monochrom> but it probably doesn't have an example
21:22:39 <tiki> not that i could see, it was nonconstructive for the most part
21:23:01 <geekosaur> which also called them idioms
21:23:03 <tiki> (for some definition of nonconstructive :P)
21:23:48 * hackagebot snap-core 0.9.8.0 - Snap: A Haskell Web Framework (core interfaces and types)  https://hackage.haskell.org/package/snap-core-0.9.8.0 (GregoryCollins)
21:51:06 <scutigera> so i have a really (embarrassingly) fundamental question
21:51:25 <scutigera> you can have IO Int, Mabye Int, Either Int, but i certainly can't have Double Int
21:51:36 <dibblego> Correct.
21:51:39 <scutigera> and yet IO, Maybe and Either or types.
21:51:40 <dibblego> almost
21:51:45 <scutigera> but clearly "different" types
21:51:48 <dibblego> you cannot have (Either Int) as a type
21:52:05 <dibblego> IO, Maybe and Either are called type constructors  they take types to return types
21:52:18 <dibblego> (IO Int) is a type. IO is a type constructor.
21:52:32 <arkeet> :k IO
21:52:33 <lambdabot> * -> *
21:52:34 <arkeet> :k Either
21:52:35 <lambdabot> * -> * -> *
21:52:36 <dibblego> IO takes one more type to return a type.
21:52:37 <arkeet> :k Double
21:52:38 <lambdabot> *
21:52:39 <scutigera> i'm still looking for the actualy definition of IO
21:52:49 <dibblego> scutigera: it is called the "kind" of a the type constructor
21:53:00 <dibblego> scutigera: you can use the :kind at ghci to get the kind
21:53:13 <dibblego> if the kind is * then it is a type
21:53:19 <scutigera> ok then- interesting that i just saw that tidbit today about ghc unifying kinds and types.
21:53:26 <jle`> scutigera: the idea is that you can only have values of types that are of kind  *.  So Int :: *, Double :: *
21:53:33 <dibblego> IO has the kind (* -> *), while (IO Int) has the kind *
21:54:04 <scutigera> wait so a kind is ...
21:54:11 <scutigera> not a type, a special type ?
21:54:23 <jle`> people refer to it as the type of types
21:54:24 <dibblego> the "type of a type" if you like
21:54:26 <arkeet> types are to values as kinds are to types (and type constructors).
21:54:43 <scutigera> so theoretically i can repeat that again right
21:54:45 <dibblego> how many more types must you give to say, IO, before you have a type? One.
21:54:49 <jle`> so like, True :: Bool, the value True has type Bool.  and Bool :: *, so Bool has kind *
21:54:52 <scutigera> foos are to kinds and kinds are to types ?
21:55:20 <arkeet> you could, and people call them sorts, but haskell has only one sort.
21:55:21 <arkeet> called BOX
21:55:32 <arkeet> since there's only one, no one really talks about them.
21:55:34 <jle`> are sorts even haskell?  or is it just a GHC thing?
21:56:07 <scutigera> i think this may just help me quite a lot :-)
21:56:14 <scutigera> this discussion i mean.
21:56:22 <shachaf> Neither Haskell nor GHC.
21:56:33 <scutigera> one of those obvious- hey wait a minute ? what does that actually _mean_ sort of things.
21:56:53 <dibblego> scutigera: it's applicable to the theory of types in general, not specifically haskell or ghc
21:56:59 <scutigera> so this relates to the use of forall to, right ?
21:57:12 <dibblego> loosely, incidentally
21:57:15 <arkeet> in theory one might have, say, (->) :: BOX -> BOX -> BOX (it takes two kinds and results in a kind), but ghc gives no way of talking about it.
21:57:19 <scutigera> dibblego: sure - i can see that
21:57:49 <dibblego> forall is more related to polymorphism than it is kinds
21:57:59 <scutigera> ah ok.
21:58:19 <scutigera> so what concept in cat theory would i be looking up to understand kinds in a cat theory context ?
21:58:35 <scutigera> meow
21:58:58 <arkeet> meow
22:01:14 <scutigera> so what is specifically about IO that "traps" values in an IO construct ?
22:01:48 <scutigera> i can use a Maybe a in a pure function but obviously i can't do that with IO. Does that strictly come from the definition of IO ?
22:02:32 <dibblego> IO is still pure, just like Maybe  you cannot get (IO a -> a) just like you cannot (Maybe a -> a)
22:02:42 <arkeet> you can pass around IO actions just like you can pass around any other values.
22:03:04 <geekosaur> Maybe exports its constructors, IO does not
22:03:14 <arkeet> but the actual implementation of IO is hidden, so you can't pattern match or anything to inspect an IO value.
22:03:20 <geekosaur> so you can pattern match to get at a value
22:03:44 <jle`> scutigera: not to mention, an `IO Int` doesn't really even contain an Int, semantically...so it doesn't make sense to write an `IO Int -> Int` function, really
22:04:00 <jle`> so there's not even a "value" that's "trapped"
22:04:03 <jle`> there's no value there at all
22:04:11 <dibblego> you can get (Maybe a -> a) given other information, but no amount of information will get you (IO a -> a)
22:04:20 <scutigera> jle`: aargh. you'll have to help me out with that one :-)
22:04:33 <arkeet> @quote /bin/ls
22:04:33 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
22:05:07 <jle`> scutigera: an `IO String` is a procedure/subroutine/"plan"/description of an IO process that, when executed by a computer in an IO context, gives you a String
22:05:16 <arkeet> if you want some idea of how IO works internally, here's an article. https://wiki.haskell.org/IO_inside
22:05:24 <jle`> so an `IO String` has a String in the same way that a picture of a recipe for a cake contains a cake
22:05:33 <arkeet> but you don't need to understand how IO is implemented to use it.
22:05:49 <jle`> it's just an abstract representation that a computer could execute to get a String
22:05:52 <jle`> not a String itself
22:06:04 <scutigera> so it's a lot like a ... thunk
22:06:22 <jle`> if you had a picture of a recipe for a cake, you can manipulate the image purely
22:06:22 <scutigera> ?
22:06:29 <jle`> using photoshop, or imagemagick
22:06:36 <jle`> or using your image manipulation program of choice
22:06:47 <jle`> but no imagine manipulation program is going to give you a cake from a picture of the recipe
22:07:03 <jle`> s/imagine/image
22:07:05 <scutigera> lol. i like it !
22:07:18 <scutigera> love that description. :-)
22:07:26 <arkeet> an IO action is more or less a safe wrapper around something that has some side effect when evaluated.
22:07:28 <jle`> so you can manipulate IO a's first-class, they're pure, just like images are pure
22:07:50 <jle`> in fact there are many functions that take inone or two or several IO actions and manipulate/combine them in weird ways to give you a new one
22:07:53 <scutigera> and fundamentally- IO is, strictly speaking, no different from Maybe ?
22:08:10 <arkeet> combining IO actions (using the monad methods) just makes it so that the evaluation happens in the right order.
22:08:32 <arkeet> (including the side effects.)
22:08:34 <scutigera> it's the implementation that gives you what i call, probably incorrectly, the "trapping" aspect.
22:08:40 <jle`> there are also other ways to combine IO actions too without using their monad interface...the IO api has a lot of awesome functions
22:08:48 <arkeet> jle`: ??
22:08:51 * hackagebot yesod-core 1.4.14 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.14 (MichaelSnoyman)
22:08:52 <jle`> that let you manipulate IO actions and combine IO actions and modify them in neat ways
22:09:12 <jle`> :t catch
22:09:13 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
22:09:23 <arkeet> oh, fair.
22:09:23 <jle`> the IO type offers a very rich interface
22:09:28 <scutigera> and i have used some of them. was just daydreaming about types today...cuz works is f'ing boring.
22:09:29 <jle`> :t forkIO
22:09:31 <lambdabot> Not in scope: ‘forkIO’
22:09:51 <jle`> yeah, IO's "ability" just comes from its interface and implementation
22:10:07 <scutigera> ok- that helps a lot.
22:10:23 <jle`> granted, it's impossible to implement IO from scratch...
22:10:29 <jle`> but the interface etc. are normal interfaces, heh.
22:10:47 <jle`> a value of type `IO a` can be manipulated like any value of any other type
22:10:50 <scutigera> uh wait. so there is some ghc/compiler subterfuge necessary to implement it ??
22:11:08 <jle`> well, GHC provides the runtime environment that haskell programs are executed in
22:11:20 <jle`> so it provides "primitive" ways to access that runtime environment
22:11:38 <jle`> so you can think of `IO` as GHC's way of exposing its runtime environment for you to do useful things with
22:11:39 <scutigera> oh - right the concrete implementation is of course to access IO which is a hardware-ish thing.
22:11:52 <scutigera> ok, that makes sense.
22:12:24 <jle`> getLine is a process/IO action that can be executed in the context of its runtime environment.  that's the only context where execution of it even makes sense
22:12:43 <jle`> that's what we mean by "execution".  runtime environment sees IO action, runtime environment executes the action it describes
22:14:17 <ttt_fff> is there any language (DSL in haskell, haskell itself, other langauge) where for each value, we store _a history of how it was computed_ i.e. we can click on a value, then it'l show the functino (with args) used to compute the particular value .. .and we can explore this recursively ?
22:14:42 <opqdonut> excel works like that, kinda :)
22:16:09 <ttt_fff> oh wow
22:16:22 <scutigera> so can you define a type "x y" without a being x being a type constructor ?
22:16:23 <ttt_fff> I never realized that (not sarcastic)
22:16:28 <ttt_fff> that's actually really brilliant
22:16:40 <ttt_fff> scutigera: x can be a function, like (+) 1 has type Int
22:17:16 <scutigera> :t (+) 1
22:17:17 <lambdabot> Num a => a -> a
22:17:32 <ttt_fff> sorry, (+ 2) 1 has type Int
22:17:35 <ttt_fff> :t (+ 2) 1
22:17:36 <lambdabot> Num a => a
22:17:43 <ttt_fff> (+ (2::Int)) 1 has type Int
22:17:49 <ttt_fff> :t (+ (2::int)) 1
22:17:50 <lambdabot>     Could not deduce (Num int) arising from the literal ‘2’
22:17:50 <lambdabot>     from the context (Num a)
22:17:50 <lambdabot>       bound by the inferred type of it :: Num a => a at <interactive>:1:1
22:17:54 <scutigera> so i'm looking at Control Monad IO Class
22:17:56 <ttt_fff> :t (+ (2::Int)) 1
22:17:57 <lambdabot> Int
22:18:08 <scutigera> and i see: (Monoid w, MonadIO m) => MonadIO (RWST r w s m)	
22:18:12 <ttt_fff> let x = (+ (2::Int)) , y = 1 .. .then "x y" has type Int
22:18:20 <ttt_fff> r w s m are all args to RWST
22:18:45 <scutigera> oh-so RWST is a type constructor though, right ?
22:18:53 <scutigera> ooh- that was bad grammar...
22:18:54 <jle`> :k RWST
22:18:55 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
22:19:22 <scutigera> holy crap that makes my head hurt
22:19:27 <jle`> it takes a *, a *, a (* -> *), and a *, and returns a *
22:19:35 <ttt_fff> okay, so I need a way to combine Haskell + Excel
22:19:38 <scutigera> well sure- that's obvious
22:19:40 <scutigera> lol
22:19:40 <ttt_fff> so I can "see" what the intermediate values are
22:19:56 <saulzar> ttt_fff, http://jtobin.ca/blog/2014/07/06/automasymbolic-differentiation/    <--- you can always make your type store the history
22:19:59 <kadoban> It's actually far simpler than it sounds, at least if you understand the constituent parts (State, Reader, Writer)
22:20:07 <scutigera> i heard rumors that Don & Co at Standard Charter were doing exactly that.
22:20:43 <ttt_fff> "Ed Kmett’s ‘ad’ library is the best automatic differentiation library I know of, in terms of its balance between power and accessibility. " <-- man, this edk guy pops up again
22:20:48 <scutigera> kadoban: yeah- i'm looking at the definition right now. it's a bit confusing but not terrible.
22:20:55 <ttt_fff> scutigera: what" combiing haskell + excel ?
22:21:30 <scutigera> ttt_fff: i heard a rumor, on this very channel, that they were doing something with haskell and excel to provide a "typed excel".
22:21:53 <ttt_fff> scutigera: hmm, looks like I'm googling haskell channnel history
22:22:10 <scutigera> well there were no useful details- just a mention
22:22:21 <scutigera> so not worth looking up, probably.
22:22:55 <ttt_fff> scutigera: http://ircbrowse.net/browse/haskell?id=20848461&timestamp=1434083743#t1434083743 ... mentions you too :-)
22:23:35 <scutigera> haha
22:24:00 <scutigera> btw, anybody up for developing scihaskell ?
22:24:02 <ttt_fff> scutigera: you were right, just rumors, no technical details
22:24:18 <scutigera> the only damn reason i need to use python is because numpy and scipy are just too damn useful
22:24:28 <scutigera> oh, and matplotlib too
22:24:40 <ttt_fff> i was thinking about interfacing haskell and torch
22:24:49 <ttt_fff> i.e. using torch for the tensor package + gpgpu + cuda stuff,
22:24:55 <ttt_fff> and there's already haskell/lua bindings
22:25:05 <scutigera> yeah- desperately need array slicing and manipulation
22:25:09 <saulzar> ttt_fff, I tried to do this a while ago...
22:25:35 <saulzar> ttt_fff, The haskell/lua bindings are a bit inadequate
22:26:11 <scutigera> it seems like repa is an excellent base to start from but i find it a bit difficult to wade through.
22:26:28 <ttt_fff> saulzar: oh, can you share insight on why it was so bad? was it mainly the data conversion? (because otherwise, were just (1) firing up a lua 4k vm and (2) sending it strings to eval)
22:27:31 <saulzar> ttt_fff, I think error handling was the main one. Looks like he's committed 120 commits since I last worked on it however!!
22:28:55 <scutigera> i need to dust off the haskell hdf5 interface too.
22:30:20 <saulzar> ttt_fff, There's a half baked repository here,  https://github.com/Saulzar/hslua/tree/dev  - I had a lot of problems with the hslua implementations failing (e.g. because the type was wrong) with no way to recover from the error
22:31:06 <scutigera> so is torch7 a lua package ?
22:31:13 <scutigera> or a C-library with a lua interface ?
22:31:30 <saulzar> scutigera, Well, both..
22:31:39 <scutigera> oh- so similar to numpy
22:31:50 <scutigera> lua gives you the matrix manipulation interface
22:32:00 <scutigera> and hands it off to lapack et al for the work
22:32:46 <saulzar> scutigera, It's a whole bunch of packages, C and cuda code for array processing and neural networks
22:33:14 <saulzar> It runs on luajit
22:33:59 <saulzar> (Which I also couldn't get working with the hslua package)
22:34:25 <scutigera> see hmatrix goes along way to providing this sort of stuff
22:34:38 <scutigera> BUT it's matrix interface is strictly 2D
22:34:53 <saulzar> I've some code somewhere for converting between torch tensors and Haskell code too (based on that above library)
22:35:37 <saulzar> scutigera, Yeah, and neural networks often use at least 4D.. e.g.  batches x channels x height x width
22:36:32 <scutigera> well even when i'm just doing general data collection, it's very convenient to use a 3D or 4D matrix and just slice them to get the stuff i want to work on, which is generally a vector.
22:36:44 <saulzar> yeah..
22:37:01 <scutigera> but i can do a[:,0,1,1] in numpy
22:37:09 <scutigera> and i have no idea what that would look like in repa
22:37:13 <scutigera> and you can'tdo it in hmatrix
22:37:36 <saulzar> Yeah, you can do it with repa - I always found it a little unwieldy though
22:37:44 <scutigera> right.
22:38:47 <saulzar> The equivalent for torch is theano in python
22:39:41 <scutigera> really - the pieces are there for haskell.
22:39:45 <scutigera> accel
22:39:46 <scutigera> repa
22:40:01 <LordBrain> c
22:40:43 <scutigera> not trivializing the effort at all, of course.
22:40:49 <scutigera> bunch-o-work.
22:41:17 <scutigera> LordBrain: c ?
22:41:43 <ttt_fff> waht?
22:41:52 <ttt_fff> aren't 3d/4d tensors just 2d matrices under the hood with proper striping?
22:42:09 <scutigera> everything is a 1D vector with proper striping
22:42:10 <ttt_fff> i.e. in fact, reading the lua torch tensor docs, I thikn it's just a flat 1d array undernearth, i.e. that's why tehre are all the stripes and offsets
22:42:11 <saulzar> Well they're all 1d arrays under the hood
22:42:23 <LordBrain> that was the end of my join command /join #ghc ... it got cut off because xchat autojoined #haskell in the middle of it
22:42:29 <ttt_fff> yeah, so hmatrix suffices with a translation layer above
22:42:49 <ttt_fff> scutigera: you mean you don't own 5D memory ?
22:43:00 <scutigera> ttt_fff: no, mines 11D
22:43:18 <scutigera> uses spinors and some gravitons to make it give me the answer before i have the question
22:43:35 <saulzar> For neural networks the biggest thing is having a super optimized way of doing batch convolutions 
22:44:08 <scutigera> 2D convolution ?
22:44:11 <scutigera> or N-D ?
22:44:28 <saulzar> For which there are a bunch of existing cuda code around which all the neural network frameworks use (torch/theano/caffe)
22:45:05 <scutigera> is it neural network specific ? or generalized convolution algorithms ?
22:46:00 <saulzar> scutigera, I guess it's mostly 2D over many channels
22:46:54 <saulzar> ie.  if you have a depth x height x width image  you have filters which are  depth x filter width x filter height
22:47:03 <scutigera> again not to trivialize, but accelerate's raison d'etre is compiling down to hardware as efficiently as possible, right ?
22:47:41 <saulzar> Then it's batched over a set of filters, and batched over a set of images too
22:47:50 <saulzar> scutigera, Right
22:48:59 <bycn82> hi
22:49:02 <bycn82> help
22:49:06 <bycn82> about the function
22:49:11 <saulzar> scutigera, So while something like accelerate has some convolution operations - compared with those hand written code they're very very slow
22:49:23 <bycn82> i am using fastcgi, i got the method which is GET
22:49:34 <scutigera> saulzar: right- 
22:49:40 <bycn82> now i want to write a code to differentiate the method
22:49:50 <scutigera> so you mean this is like hand-tuned C code and/or GPU code ?
22:50:01 <saulzar> Yeah, hand tuned GPU code 
22:50:05 <scutigera> ok.
22:50:22 <scutigera> right- so a haskell interface directly to it makes a lot of sense.
22:50:33 <scutigera> haskell has a reasonable FFI
22:50:49 <bycn82> how to have multiple lines in one function?
22:50:51 <scutigera> and underlying representation, as always, is a bunch of doubles.
22:50:59 <saulzar> I believe it can be written in terms of matrix multiplication, and there's a new approach using FFT which seems to be even better
22:51:52 <scutigera> yeah- probably so. i've done a fair bit of signal processing.
22:52:20 <scutigera> my problem sizes are such that just straight up convolution is fine.
22:53:21 <saulzar> scutigera, So something within the accelerate framework would be the ideal goal. Most of these frameworks use persistant data in GPU memory too
22:53:27 <scutigera> but probaly relies on the fact that convolution in the time domain is multiplication (element-by-element) in the frequency domain
22:53:53 * hackagebot yesod-bin 1.4.14 - The yesod helper executable.  https://hackage.haskell.org/package/yesod-bin-1.4.14 (MichaelSnoyman)
22:54:31 <scutigera> saulzar: well that would be the ultimate coolness. accelerate takes your haskell convolution code and compiles it down to almost hand-tuned speed
22:54:47 <scutigera> but meanwhile - going through the C interface is no problem
22:54:58 <scutigera> but that array slicing interface is needed
22:55:06 <scutigera> something that makes the code readable
22:55:14 <saulzar> scutigera, Yeah well - that would be the dream, but in the mean while we can bind to some super fast matrix mul code in cublas or some such
22:58:03 <saulzar> There's a cublas package on hackage, there's one very specific function doing batched matrix mul which is most useful though
23:00:46 <Lokathor> stack's ghci can recognize Ctrl+D to close ghci
23:00:52 <Lokathor> the normal windows ghci cannot do this thing
23:00:53 <Lokathor> fancy
23:01:28 <scutigera> saulzar: pretty cool. didn't know about that.
23:02:03 <scutigera> well i'm gonna spend some time with repa and see if i can figure out what it takes to make a nice matrix index interface.
23:02:27 <scutigera> probably should look at torch too, although i think that numpy has it pretty much right.
23:02:39 <scutigera> very concise and really pretty easy to work with
23:02:50 <scutigera> you only get in trouble when it tries to broadcast addresses.
23:02:55 <saulzar> Torch is fairly handy too, slicing etc. I think they're quite similar..
23:03:05 <gamegoblin> @pl \x -> a x >> b x
23:03:05 <lambdabot> liftM2 (>>) a b
23:03:09 <bycn82> hi
23:03:15 <scutigera> but that's where static typing of dimensions could really shine
23:03:18 <bycn82> how to read the source of the package?
23:03:31 <scutigera> and hmatrix has an experimental lib to do that.
23:03:59 <scutigera> thanks saulzar. you've given me something to do at work tomorrow ;-)
23:04:25 <saulzar> I suspect it can look nicer than repa with more modern type literals/lists etch.. 
23:04:33 <scutigera> i meant broadcast dimension, of course.
23:04:35 <Axman6> bycn82: if you have the hackage docs, click the 'source' link in the top right
23:04:40 <saulzar> Ah..
23:04:43 <saulzar> scutigera, Good luck with that!
23:04:47 <scutigera> haha
23:04:50 <scutigera> cya
23:05:00 <Axman6> :t (undefined :: a -> b) *> (undefined :: a -> c)
23:05:02 <lambdabot> a -> b
23:05:17 <Axman6> gamegoblin: a *> b should do what you want
23:05:28 <Axman6> hmm, wait
23:05:45 <gamegoblin> Axman6: No, it doesn’t
23:06:20 <Axman6> > (show *> (*10)) 7
23:06:22 <lambdabot>  70
23:06:53 <Axman6> > (error *> join (++)) "test"
23:06:54 <lambdabot>  "testtest"
23:07:10 <gamegoblin> :t (*>)
23:07:11 <lambdabot> Applicative f => f a -> f b -> f b
23:07:50 <dibblego> @type liftA2 (*>)
23:07:52 <lambdabot> (Applicative f, Applicative f1) => f (f1 a) -> f (f1 b) -> f (f1 b)
23:08:09 <gamegoblin> :t (liftM2 (>>))
23:08:10 <lambdabot> (Monad m, Monad m1) => m (m1 a) -> m (m1 b) -> m (m1 b)
23:10:48 <dibblego> > liftA2 (*>) show (replicate 5) 'a'
23:10:49 <lambdabot>  "aaaaaaaaaaaaaaa"
23:13:44 <Lokathor> stack can't find the version of pkg-config i have installed
23:13:48 <Lokathor> but it's in my path
23:13:51 <Lokathor> confusing
23:14:24 <erisco> why is the downstream and upstream in pipes bidirectional?
23:14:49 <Axman6> Lokathor: is it in the path shown in `stack exec env`?
23:15:07 <erisco> what does it mean to have one thing "go out" downstream and another to "come in" downstream?
23:15:54 <erisco> :t yield
23:15:55 <lambdabot> Not in scope: ‘yield’
23:15:59 <ollef> > ((>>) <$> print <*> print) "abc"
23:16:00 <lambdabot>  <IO ()>
23:16:05 <Lokathor> Axman6, yep, it shows the same path as my normal path, including the directory with pkg-config in it
23:16:12 <kqr> what is wrong if I have attoparsec package installed, but "Could not find module ‘Data.Attoparsec.Text’"
23:16:14 <Axman6> odd
23:16:24 <Lokathor> highly
23:16:30 <Lokathor> oh well, i can work on other projects
23:16:33 <erisco> shame lambdabot does not have pipes
23:16:36 <Axman6> well, I'm out of ideas. stack is pretty new
23:16:58 <Lokathor> yeah maybe it'll bundle its own instance of pkg-config later on or something
23:17:15 <erisco> Pipes.yield :: Monad m => a -> Pipes.Proxy x' x () a m ()
23:17:34 <erisco> so this is saying that () "goes out" downstream, and 'a' "comes in" downstream
23:17:44 <erisco> and I don't get the distinction
23:18:50 <Axman6> the a would come from stages later in the pipeline, and be passed to earlier stages, the () would be passed to later stages
23:19:45 <erisco> how does that make sense
23:20:01 <erisco> I am yielding a value, that should go down the pipeline
23:20:04 <Axman6> data can flow in both directions
23:20:47 <erisco> why doesn't the 'a' "go out"
23:20:50 <erisco> and the () "come in" ?
23:21:36 <erisco> so the thinking is the other way around? the await is "earlier" in the pipeline?
23:21:43 <erisco> you await then yield, not yield then await?
23:22:36 <kqr> never mind my question. switched over from building with cabal to stack and problem went away lol
23:22:42 <Axman6> so, you could, for example (a poor one) send a bytestring to a file writing Sink, which then sends back a Bool telling you whetherit wrote it cleanly, before you produce the next bytestring for writing
23:23:29 <erisco> that's fine, I don't understand the nomenclature right now
23:24:20 <Axman6> I also found the docs pretty confusing and haven't used it for quite a long time
23:24:53 <erisco> Pipes.await :: Monad m => Pipes.Proxy () a y' y m a
23:25:07 <erisco> so I guess if you're awaiting then you're on the upstream? I dunno
23:25:19 <Axman6> you await values from upstream
23:25:37 <erisco> in that case it makes sense that () "goes out" and 'a' "comes in"
23:25:58 <erisco> um, right okay
23:27:03 <Axman6> you've read https://hackage.haskell.org/package/pipes-4.1.6/docs/Pipes-Tutorial.html#g:9 ?
23:27:20 <erisco> yes
23:27:25 <erisco> reading is one thing, understanding is another oO
23:27:38 <Axman6> yeah :\
23:27:52 <erisco> also it spends half its time in wonderment of how general its own types are
23:28:07 <Axman6> yes
23:28:19 <Axman6> it's definitely not easy to use
23:28:40 <erisco> well I got something to print Hello World so there's a start
23:29:07 <xelxebar> So, I've been trying out nix for a little bit. Recently there was some glibc update on my system that broke all the statically linked packages in the nix store.
23:29:49 <Axman6> that sounds... like it
23:29:56 <Axman6> it's not supposed to happen*
23:30:00 <liste> xelxebar locale problems?
23:30:01 <nisstyre> I thought that wasn't supposed to happen
23:30:02 <Axman6> (also probably off-topic)
23:30:10 <nisstyre> since the library would be immutable
23:31:21 <xelxebar> I don't really know nix all that well, and while the problem persists, I can't really use my dev tools. So, this is really silly, but I wrote a cabal wrapper to manage a "cabal store" of individually sandboxed packages.
23:31:46 <liste> https://github.com/NixOS/nix/issues/599 <-- the last message has a workaround for a glibc problem I bumped in to
23:31:48 <xelxebar> If anyone has any reason to want something like this, here it is: https://gist.github.com/xelxebar/001e43a7ffb6940a24e4
23:31:55 <liste> the last comment
23:32:00 <xelxebar> liste: yeah, it's the locale issues
23:32:27 <xelxebar> The current workaround by vcunat isn't working for me.
23:34:06 <erisco> I just can't grok yield
23:35:00 <erisco> oh I misread
23:35:16 <erisco> it flips in upstream vs downstream
23:35:22 <erisco> Proxy a' a b' b m r
23:35:37 <erisco> a' goes out, a comes in, b' comes in, b goes out
23:36:03 <Axman6> yes
23:36:20 <erisco> Pipes.yield "hello world"
23:36:20 <erisco>   :: Monad m => Pipes.Proxy x' x () [Char] m ()
23:36:36 <erisco> so, () comes in, [Char] goes out, in the downstream
23:36:43 <erisco> this finally makes some sense
23:37:55 <erisco> okay, so to remember this... geez feels like calculus class
23:38:42 <erisco> if you're in the middle of the stream, you're at  Proxy a' a HERE b' b
23:38:50 <erisco> ignoring the m and r because those don't matter at the moment
23:39:01 <erisco> maybe s/HERE/YOU/
23:39:10 <erisco> so, the parameters closest to YOU are coming in
23:39:20 <erisco> the parameters furthest are going out
23:40:18 <erisco> I don't know why the ticks are reversed as well
23:40:32 <erisco> I mean why they are not reversed
23:42:07 <Axman6> best to ask tekmo
23:43:44 <johnw> erisco: yeah, the ticks could have been reversed if you ask me
23:44:26 <erisco> Pipes.await :: Monad m => Pipes.Proxy () a y' y m a
23:44:38 <erisco> this lets you move whatever is coming in from upstream to the return value
23:44:47 <johnw> yep
23:45:05 <erisco> should there also be one to move whatever is coming in from downstream to the return?
23:45:13 <erisco> also from coming in downstream to going out upstream
23:45:20 <johnw> request/respond
23:45:23 <erisco> and coming in upstream to going out downstream
23:45:25 <johnw> the bidirectional methods
23:45:49 <erisco> oh I need to look at Pipes.Core to get these
23:46:14 <johnw> with the bidirectionality, you can use pipes for things other than streaming
23:46:16 <johnw> like co-routines
23:46:17 <erisco> also need to import it oO
23:46:35 <erisco> why is it not exported in Pipes
23:46:43 <johnw> not used super often, I guess
23:47:01 <Lokathor> ghc: warning: _tzset from msvcrt is linked instead of __imp__tzset
23:47:10 <Lokathor> every time i build my project i get that
23:47:31 <Lokathor> i dunno if i should be worried or if i should be looking for a way to just disable that warning
23:54:54 <erisco_> Pipes.runEffect (Pipes.yield "hello world" >-> (Pipes.await >>= lift . putStrLn))
23:54:57 <erisco_> yes woo-hoo
23:54:59 <erisco_> yielded and awaited
23:55:22 <pyon> What happens with Parsec's user state when the parser backtracks? I've never used the user state feature before.
23:56:38 <erisco> I have to get used to the combinators but some sense is beginning to be had
