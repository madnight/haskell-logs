00:07:37 * hackagebot zalgo 0.1.0.0 - Z-algorithm implemented on haskell's built-in cons-cell-based lists.  https://hackage.haskell.org/package/zalgo-0.1.0.0 (mniip)
00:07:37 * hackagebot debian-build 0.8.0.0 - Debian package build sequence tools  https://hackage.haskell.org/package/debian-build-0.8.0.0 (KeiHibino)
00:22:05 <lf94> What's a good way to select the middle of a list?
00:22:13 <lf94> Right now I'm doing `length s / 2.0`
00:22:17 <shachaf> No good way.
00:23:45 <kadoban> lf94: What are you using it for?
00:25:30 <lf94> just to find a pivot, kadoban :>
00:25:45 <lf94> For sorting
00:26:04 <lf94> I figure a good pivot might as well be straight in the middle...
00:26:11 <lf94> I can mix it up later and randomize it.
00:26:29 <lf94> please don't link me to any solutions
00:26:41 <lf94> I was just wondering if there was a better way to select the middle of a list
00:28:51 <kadoban> lf94: There's kinds of … two versions of quicksort. The kind in real-life where you tune it to hell, and the kind in fantasy-land where you get the right big-O and don't worry about the rest. If you're using lists … you're kinda doing the fantasy-land version anyway, so you might as well just use a simple pivot selection … use the first number in the list.
00:30:35 <shachaf> The version people always use for Haskell propaganda isn't even asymptotically quick.
00:30:43 <sbrg> ^
00:30:47 <kadoban> lf94: The reason you're in the fantasy-land version is because the only reason anyone even uses quicksort in the first place is that when it's done in-place, it can be fast as hell in practice. But … it's never going to be in-place in a list.
00:32:30 <erisco> anyone have some benches for comparing chunk sizes with pipes?
00:35:41 <mauke> shachaf: what do you mean by asymptotically quick?
00:36:00 <lf94> kadoban, yes, I'm fully aware of everything you're saying - this is just an exercise for myself :P
00:36:22 <lf94> Doing it in-place in haskell though...that's not even possible!
00:36:26 <kadoban> lf94: Then the relevent part would be "just use the first element"
00:36:31 <lf94> Wouldn't quicksort be slower in Haskell all around?
00:36:34 <mauke> sure it is, with mutable arrays
00:36:40 <kadoban> lf94: Sure it is. It just involves using mutable arrays.
00:36:51 <lf94> oh?
00:36:56 <lf94> mutable data structures?
00:37:12 <shachaf> Probably not anything useful. I regretted that phrasing.
00:37:13 <lf94> or illusions of mutable data
00:38:03 <kadoban> lf94: Turns out haskell is actually a really nice imperative programming language. You'd want to use STArrays or whatever the IO ones are called.
00:38:06 <lf94> sbrg: I'm doing the real quicksort, but it's the fantasy quicksort kadoban mentioned
00:38:16 <kadoban> Or some kind of vector? I'm not that knowledgeable about that stuff.
00:38:23 <lf94> Ah, ok.
00:38:27 <sbrg> lf94: with lists, yes?
00:38:35 <lf94> Yep
00:38:48 <lf94> I would just do this in C to be honesnt
00:38:51 <sbrg> There is "quicksort" as in "quicksort with the time complexity that quicksort has" and then there is "quicksort with lists" which isn't really "quicksort". :p
00:39:05 <mauke> list quicksort has the same time complexity
00:39:05 <sbrg> because it doesn't have the time complexity quicksort is supposed to have
00:39:08 <lf94> Algorithmically it is quicksort
00:39:28 <lf94> aaaand two conflicting pieces of information :)
00:39:38 <mauke> quadratic worst case, n*log n with good pivots
00:39:42 <kadoban> sbrg: How does using lists prevent you from getting O(n^2) and expected O(n lg n) on random inputs?
00:40:06 <lf94> there is just more overhead in the list version
00:40:16 <kadoban> Yeah, AFAIK the constants are just /way/ worse.
00:40:55 <lf94> I'll try doing the in-place quicksort next :)
00:41:01 <lf94> Should definitely be a learning experience
00:45:40 <lf94> ...What the hell does (/) take?
00:45:50 <lf94> No instance for (Fractional Int) arising from a use of ‘/’
00:45:50 <lf94>     In the expression: (length s) / 2
00:45:52 <mauke> two fractional numbers
00:46:00 <mauke> length returns Int. Int is not fractional
00:46:12 <kadoban> :t div
00:46:13 <lambdabot> Integral a => a -> a -> a
00:48:12 <lf94> > 4 `div` 2
00:48:14 <lambdabot>  2
00:53:05 <lf94> https://gist.github.com/b14b0478f5c439dc040a
00:53:07 <lf94> there
00:53:14 <lf94> but for some reason it's running infinitely
00:57:32 <ezrios> is there a compelling reason to use HList over CTRex?
00:57:37 * hackagebot zalgo 0.1.0.1 - Z-algorithm implemented on haskell's built-in cons-cell-based lists.  https://hackage.haskell.org/package/zalgo-0.1.0.1 (mniip)
00:57:40 <ezrios> for extensible records
00:58:17 <ahihi> lf94: try changing your element type to e.g. Float
00:58:34 <ahihi> you have a hidden type error :)
00:58:43 <lf94> ...hidden type error what <_>
00:58:46 <lf94> How
00:58:52 <lf94> Oh right I should be using -Wall
00:59:11 <ahihi> your pivot is a list index, not an element
00:59:17 <ahihi> here their types happen to coincide
01:00:13 <lf94> Oh shoot! You're right.
01:00:24 <lf94> Silly silly silly me
01:01:18 <kadoban> lf94: Note that if the type of your function were more general: sort :: Ord a => [a] -> [a], that would have been caught.
01:01:51 <kadoban> lf94: The running infinitely … at a guess: you're not handling empty lists specially. Looks like you need to.
01:02:23 <lf94> How would it have been caught?
01:02:50 <kadoban> lf94: It would have said "I can't match 'a' with Int" or something
01:03:03 <lf94> Did you see the code? :P
01:03:22 <kadoban> Yes?
01:03:40 <lf94> I still don't get it then...the pivot is only used in those filters
01:04:02 <lf94> And 'a' is an Int
01:04:08 <lf94> oh wait
01:04:10 <lf94> nevermind
01:04:11 <lf94> I see now
01:04:21 <lf94> Gah sorry for the idiocy
01:04:34 <kadoban> No worries, I probably should have used a different letter, heh.
01:07:39 <lf94> Hm the infiniteness is still messed up
01:08:11 <lf94> Yeah it was the empty case m(
01:08:16 <kadoban> Hehe
01:08:53 <erisco> it's time to play "Find That Module!" today's module is Data.Streaming.Text -- go!
01:09:09 <lf94> My quicksort is removing duplicates!
01:09:12 <lf94> Yikes!
01:09:25 <kadoban> erisco: streaming-commons ? (whatever that is)
01:09:38 <wei2912> lf94: O_o
01:09:48 <lf94> that's an interesting thing to notice
01:09:48 <erisco> there it is, hiding out in a list of a dozen modules
01:09:50 <kadoban> lf94: < and > aren't the only choices
01:09:55 <lf94> kadoban: Yeah ;)
01:09:59 <lf94> that's exactly why
01:10:02 <erisco> kadoban, you win 12 Hackage points, what will you spend them on?
01:10:13 <kadoban> erisco: A new car?
01:10:46 <erisco> I'm sorry but you need at least 4,537,970,000,284 Hackage points for a new car
01:10:46 <wei2912> kadoban: true haskellers would spend them on lambdas
01:10:53 <kadoban> :(
01:10:57 <wei2912> kadoban: your points have been confiscated
01:11:05 <erisco> why not this unicode character instead? ☁
01:11:11 <kadoban> Well they were nice while they lasted
01:11:33 <ahihi> http://hayoo.fh-wedel.de/?query=Data.Streaming.Text
01:13:55 <erisco> so, say you want to decode a UTF8 bytestream while keeping track of the byte offset
01:14:14 <erisco> do you need to rewrite decodeUtf8
01:15:31 <Geraldine3> test
01:15:52 <erisco> I am going to postulate "yes"
01:17:47 <lf94> oh god this quicksort is horrendous!
01:17:54 <lf94> https://gist.github.com/b14b0478f5c439dc040a
01:18:07 <z16> Is it at least quick?
01:18:14 <lf94> nope!
01:18:21 <lf94> well, not the quickest
01:18:29 <lf94> i guess it's faster compared to some other 
01:19:29 <z16> While Haskell is awesome to reason about the structure and flow of programs I find it a bit hard to reason about efficiency in Haskell
01:19:35 <z16> Since everything is so abstract and high level
01:19:44 <z16> Makes it hard to get a feel for how it all works under the hood
01:21:01 <kadoban> lf94: You'd probably do well to replace those lambdas with sections: filter (< pivot) s , by the way.
01:21:32 <lf94> ah, yeah
01:21:35 <lf94> i just do t
01:21:42 <lf94> it out of habit, so i know exactly what's going on
01:21:56 <lf94> but, I'm actually going to replace those two filters with partition.
01:22:08 <kadoban> Yeah that's also a good idea
01:25:24 <erisco> lf94, "Lets create an list for our shit" -- I like your programming style
01:25:45 <lf94> Yeah bad typo
01:25:54 <erisco> no it is perfect
01:25:59 <lf94> The colorscheme I have going on in Emacs...I can hardly see the text.
01:26:05 <kadoban> XD
01:26:15 <lf94> (Comment text anyways)
01:26:23 <lf94> I'm also typing like a hundred miles an hour
01:26:31 <erisco> shhh
01:26:38 <erisco> you're doing fine, it was a compliment
01:27:01 <MorpheusB> I have battled with Emacs, going back to using vim
01:27:18 <MorpheusB> or even gvim
01:27:43 <MorpheusB> > map (+1) [1..5]
01:27:45 <lambdabot>  [2,3,4,5,6]
01:28:58 <ReinH> MorpheusB: spacemacs!
01:29:12 <ReinH> it's a better vim than vim
01:29:18 <erisco> allocating using struct of array format, how does one do this in le Haskell?
01:29:26 <lf94> After using g/vi/m for 5+ years, why would anyone *not* want to use Emacs
01:29:46 <ReinH> lf94: vim is a better editor per se
01:29:57 <erisco> it is the only real solution I can see to having a Text stream with byte offset
01:30:11 <ReinH> So thank goodness I can get vim editing with a nice underlying system and language
01:30:16 <ReinH> which vim is not
01:30:18 <lf94> ReinH: and that's where this discussion ends
01:30:34 <ReinH> lf94: Not sure what you expected
01:30:36 <MorpheusB> any idea why getting this error from my instance of lambdabot - mueval-core: Time limit exceeded
01:30:55 <ReinH> MorpheusB: probably because it exceeded the time limit
01:31:03 <erisco> you need to upgrade from potato to turnip
01:32:29 <MorpheusB> thanks ReinH , I realise time issue, but it works locally, in here, but not in other channel where that error occurs
01:32:50 <ReinH> MorpheusB: they may have different settings or run on different hardware, etc
01:33:45 <MorpheusB> thanks, will have to look at some timing variables
01:35:32 <erisco> I will draw a picture so people know what I mean
01:39:34 <erisco> how do I get 'y' instead of 'x' http://lpaste.net/139817
01:43:42 <erisco> I am guessing I need a new array lib too
01:52:43 * hackagebot amazonka-core 1.2.0.2 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.2.0.2 (BrendanHay)
01:52:45 * hackagebot amazonka 1.2.0.2 - Comprehensive Amazon Web Services SDK  https://hackage.haskell.org/package/amazonka-1.2.0.2 (BrendanHay)
01:52:47 * hackagebot amazonka-test 1.2.0.2 - Common functionality for Amazonka library test-suites.  https://hackage.haskell.org/package/amazonka-test-1.2.0.2 (BrendanHay)
01:52:49 * hackagebot amazonka-config 1.2.0.2 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.2.0.2 (BrendanHay)
01:52:51 * hackagebot amazonka-sns 1.2.0.2 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.2.0.2 (BrendanHay)
01:54:23 <ReinH> erisco: vector handles some aos/soa transformations for you, not sure about array
01:55:19 <erisco> ueah?
01:55:31 <erisco> hpw i missed 9t
01:57:53 * hackagebot amazonka-sqs 1.2.0.2 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.2.0.2 (BrendanHay)
01:57:55 * hackagebot amazonka-glacier 1.2.0.2 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.2.0.2 (BrendanHay)
01:57:57 * hackagebot amazonka-cloudhsm 1.2.0.2 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.2.0.2 (BrendanHay)
01:57:59 * hackagebot amazonka-datapipeline 1.2.0.2 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.2.0.2 (BrendanHay)
01:58:01 * hackagebot amazonka-iam 1.2.0.2 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.2.0.2 (BrendanHay)
01:58:13 <Hafydd> Heh.
01:58:16 <Hafydd> Here we go again!
01:58:46 <erisco> ReinH, where in the lib?
01:59:32 <ReinH> https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Unboxed.html
02:01:33 <erisco> must be blind
02:03:03 * hackagebot amazonka-route53-domains 1.2.0.2 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.2.0.2 (BrendanHay)
02:03:05 * hackagebot amazonka-directconnect 1.2.0.2 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.2.0.2 (BrendanHay)
02:03:07 * hackagebot amazonka-devicefarm 1.2.0.2 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.2.0.2 (BrendanHay)
02:03:09 * hackagebot amazonka-cognito-sync 1.2.0.2 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.2.0.2 (BrendanHay)
02:03:11 * hackagebot amazonka-elb 1.2.0.2 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.2.0.2 (BrendanHay)
02:03:25 <ReinH> Ralith: oh god
02:03:30 <ReinH> amazonka pls
02:03:35 <ReinH> woops sorry Ralith
02:04:33 <erisco> ReinH, which functions?
02:07:06 <kqr> https://hackage.haskell.org/package/shakespeare-2.0.5/docs/Text-Hamlet-RT.html#v:parseHamletRT <- the parseHamletRT function returns "~ (*) e SomeException => Either e HamletRT"
02:07:14 <kqr> how do I get out the information on how the function failed?
02:07:47 <kqr> ah that's a HamletParseException String
02:07:50 <kqr> maybe I do get it now
02:08:13 * hackagebot amazonka-cloudformation 1.2.0.2 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.2.0.2 (BrendanHay)
02:08:15 * hackagebot amazonka-sts 1.2.0.2 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.2.0.2 (BrendanHay)
02:08:17 * hackagebot amazonka-kinesis 1.2.0.2 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.2.0.2 (BrendanHay)
02:08:20 * hackagebot amazonka-cloudsearch-domains 1.2.0.2 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.2.0.2 (BrendanHay)
02:08:22 * hackagebot amazonka-cloudwatch 1.2.0.2 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.2.0.2 (BrendanHay)
02:08:50 <pavonia> What does "~ (*) e SomeException" mean?
02:09:00 <kqr> I have no clue
02:09:13 <kqr> but it looks as though it's something about how a HamletException is some exception
02:09:34 <kqr> the exception stuff in Haskell is really confusing hah
02:09:55 <kqr> but I might be able to strip off the exception and at that point I'm content
02:10:32 <Hafydd> kqr: where does it say that parseHamletRT returns that type?
02:10:48 <Hafydd> I can see: parseHamletRT :: MonadThrow m => HamletSettings -> String -> m HamletRT
02:11:07 <kqr> if you click on MonadThrow you get to see the Either instance, which is the relevant one in this case
02:11:34 <ReinH> erisco: ?
02:11:37 <Hafydd> Oh, I see. You meant "(~) * e SomeException => MonadThrow (Either e)".
02:12:25 <kqr> yeah that stuff
02:13:24 * hackagebot amazonka-cloudtrail 1.2.0.2 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.2.0.2 (BrendanHay)
02:13:26 * hackagebot amazonka-elasticache 1.2.0.2 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.2.0.2 (BrendanHay)
02:13:28 * hackagebot amazonka-importexport 1.2.0.2 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.2.0.2 (BrendanHay)
02:13:30 * hackagebot amazonka-s3 1.2.0.2 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.2.0.2 (BrendanHay)
02:13:32 * hackagebot amazonka-swf 1.2.0.2 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.2.0.2 (BrendanHay)
02:15:16 <Hafydd> kqr: I'm not sure why it's rendered like that - it's possibly a deficiency of Haddock - but this is the actual instance declaration: instance e ~ SomeException => MonadThrow (Either e) where
02:15:46 <Hafydd> It apparently means that (~) is turned into a prefix operator (and applied using *?).
02:16:28 <kqr> hm yeah
02:16:50 <erisco> ReinH, I don't see where it helps with soa/aos
02:17:39 <average> I was contemplating learning Haskell
02:17:49 <average> then I thought again, hmm should I really learn it..
02:17:53 <average> and then some years passed
02:18:03 <average> and then I thought again about learning it
02:18:08 <average> then some more years passed
02:18:14 <average> but now it's 2015
02:18:33 <Hafydd> kqr: in any case, the effect is that it allows more general exceptions to be thrown (and ignored by your code), while you specialise to catch a HamletException.
02:18:34 * hackagebot amazonka-sdb 1.2.0.2 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.2.0.2 (BrendanHay)
02:18:36 * hackagebot amazonka-codecommit 1.2.0.2 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.2.0.2 (BrendanHay)
02:18:38 * hackagebot amazonka-codedeploy 1.2.0.2 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.2.0.2 (BrendanHay)
02:18:40 * hackagebot amazonka-cloudfront 1.2.0.2 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.2.0.2 (BrendanHay)
02:18:42 * hackagebot amazonka-efs 1.2.0.2 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.2.0.2 (BrendanHay)
02:18:53 <kqr> Hafydd, do you have... any reading on this? preferably quite comprehensive lol
02:19:03 <kqr> I've been meaning to get into exception stuff in Haskell but never got around to it
02:19:14 <kqr> average, start today
02:19:18 <kqr> average, learn something simple
02:19:22 <kqr> average, like how to create a function
02:19:24 <average> kqr: it's intimidating tbh
02:19:35 <erisco> or don't start and do something else
02:19:49 <kqr> average, haskell is a huge language, and even though I've been using it for like... 6 years? there are lots of areas of it I still don't know anything about
02:19:55 <kqr> average, like, as you probably saw, exceptions
02:20:04 <kqr> average, you don't have to learn everything overnight
02:20:08 <kqr> average, start with whatever interests you
02:20:13 <ttt_fff> is TH fair game in this channel, or should I go talk in another channel?
02:20:16 <Hafydd> kqr: <https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Control-Exception.html>, the papers cited within, and <https://hackage.haskell.org/package/exceptions>.
02:20:35 <Hafydd> (The papers are optional; it's not too hard to understand without reading them.)
02:20:51 <erisco> ttt_fff, I won't tell you no
02:21:03 <ttt_fff> erisco!!
02:21:06 <ttt_fff> I got my JS compiler working
02:21:09 <ttt_fff> except for case matching
02:21:14 <ttt_fff> which I'm now going to get via TH
02:21:17 <average> is Haskell competing with Erlang in any way ?
02:21:18 * erisco stumbles back
02:21:22 <ttt_fff> this is going to be bada$$
02:21:38 <average> on the concurrency side of things I mean
02:21:52 <ttt_fff> I think if you want soft real time, Erlang wins
02:22:07 <ttt_fff> so if you want horizontal scalability, low latency, and simple ops, erlang wins
02:22:12 <ttt_fff> if you want type checking + stm, haskell wins
02:22:29 <average> stm = ?
02:22:44 <average> transactional memory ?
02:22:47 <kqr> yes
02:22:54 <ttt_fff> standard template monad
02:22:57 <average> oh
02:23:01 <ttt_fff> i'm kidding, software transactional memory
02:23:06 <average> ah ok
02:23:12 <average> yeah see, that's why it's intimidating
02:23:24 <kqr> people kidding? :D
02:23:27 <average> I try to comfort myself "meh, anyone using Haskell is a student anyways"
02:23:39 <average> but I increasingly start to see that statement to be false
02:23:40 <kqr> haha that's a common misconception
02:23:41 <ReinH> average: Haskell has a powerful threaded runtime, but it doesn't have Erlang's process model and runtime
02:23:44 * hackagebot amazonka-codepipeline 1.2.0.2 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.2.0.2 (BrendanHay)
02:23:46 * hackagebot amazonka-elasticbeanstalk 1.2.0.2 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.2.0.2 (BrendanHay)
02:23:48 * hackagebot amazonka-autoscaling 1.2.0.2 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.2.0.2 (BrendanHay)
02:23:50 * hackagebot amazonka-ses 1.2.0.2 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.2.0.2 (BrendanHay)
02:23:52 * hackagebot amazonka-support 1.2.0.2 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.2.0.2 (BrendanHay)
02:23:52 <average> kqr: yeah
02:24:03 <kqr> ReinH, cloud haskell gets you some of that though? but maybe that project is on ice
02:24:08 <Cale> ^^ otherwise why would hackagebot be spamming us with that stuff? :D
02:24:14 <ReinH> I guess it does in theory
02:24:16 <Hafydd> Of course not. Some Haskell users are teachers.
02:24:21 <erisco> Cale, because students get it free
02:25:00 <Cale> erisco: Oh, do they?
02:25:02 <ttt_fff> every time I understand part of haskell, when I learn a new part, I go ####, haskellers are really smart
02:25:06 <average> every time I look at things like this http://research.microsoft.com/pubs/67418/2005-ppopp-composable.pdf#page=8
02:25:08 <Sindriav_> How's Haskell on terms of speed optimisations? Where can I read a bit more about it?
02:25:19 <ttt_fff> like the design of TH + [| |] for qquasiquoting is relaly smart
02:25:19 <average> that formal logic looking thing
02:25:36 <average> I'm like "wtf is that? wait, didn't I take CS courses ? why the f*** don't I know those ?"
02:25:37 <kqr> ReinH, in theory as in "not as polished as erlang" or "has some fundamental flaws that need to be worked out"?
02:25:44 <average> and then I'm like "meh.. I'll wait a few more years"
02:25:46 <lwm> > filter (\ x -> isLetter x || x == '\t') "asdf$#$     dfs"
02:25:48 <lambdabot>  "asdfdfs"
02:26:04 <Cale> average: Yeah, it's common notation in the type theory community, because type theory came out of formal logic.
02:26:10 <ReinH> kqr: iirc there are some issues with it
02:26:33 <Cale> average: If you want to learn how to read it, I would recommend "Types and Programming Languages"
02:26:41 <kqr> average, haha fortunately you don't have to read that stuff
02:26:43 <Cale> (by Benjamin Pierce)
02:26:44 <kqr> average, you can just write programs
02:26:45 <ReinH> kqr: then again, Haskell is a good language to write distsys stuff in anyway
02:27:01 <Cale> Well, that stuff is useful if you want to implement the feature
02:27:03 <ReinH> you don't need cloud haskell
02:27:07 <kqr> ReinH, oh, sure. I just got curious because it was a few years since I last looked at cloud haskell
02:27:29 <ReinH> kqr: Some of us just greenspun our own distsys primitives ;)
02:27:39 <kqr> that's mostly what I've been doing as well
02:27:54 <Cale> It sort of tells you how to implement the type checker / inference, or in that case, it's how to implement an evaluator.
02:27:57 <ReinH> So far doing so in Haskell has been very nice.
02:28:23 <Cale> You can think of it as just funny/compact notation for the stuff that the machine will be carrying around, and how that evolves.
02:28:24 <ReinH> I've got a nice write-ahead log and cartar is working on implementing a verified raft
02:28:30 <ReinH> etc
02:28:35 <ReinH> er, carter
02:28:54 * hackagebot amazonka-dynamodb-streams 1.2.0.2 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.2.0.2 (BrendanHay)
02:28:56 * hackagebot amazonka-redshift 1.2.0.2 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.2.0.2 (BrendanHay)
02:28:58 * hackagebot amazonka-opsworks 1.2.0.2 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.2.0.2 (BrendanHay)
02:29:00 * hackagebot amazonka-emr 1.2.0.2 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.2.0.2 (BrendanHay)
02:29:02 * hackagebot amazonka-cognito-identity 1.2.0.2 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.2.0.2 (BrendanHay)
02:29:06 <erisco> can this raft travel the mississippi?
02:29:16 <ttt_fff> omg, the evil one can do with quasiquotation
02:29:21 <ReinH> erisco: probably not
02:31:22 <erisco> I am going to suggest that QQs should be typed predictably from their name alone
02:33:26 <tulcod> erisco: isn't that what quoteType does?
02:33:44 <erisco> I don't know, I've only spliced expressions
02:34:04 * hackagebot amazonka-ssm 1.2.0.2 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.2.0.2 (BrendanHay)
02:34:06 * hackagebot amazonka-ml 1.2.0.2 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.2.0.2 (BrendanHay)
02:34:08 * hackagebot amazonka-workspaces 1.2.0.2 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.2.0.2 (BrendanHay)
02:34:10 * hackagebot amazonka-dynamodb 1.2.0.2 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.2.0.2 (BrendanHay)
02:34:11 <tulcod> erisco: that also has a typed variant
02:34:12 * hackagebot amazonka-rds 1.2.0.2 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.2.0.2 (BrendanHay)
02:34:28 <tulcod> can this amazonka stuff stop?
02:34:44 <pharaun> its just updates to hackage?
02:35:04 <erisco> tulcod, please explain
02:35:27 <tulcod> pharaun: yes but it's been going on for a while. kinda smells like spam
02:35:39 <erisco> it is spam
02:35:45 <tulcod> erisco: there's typed splicing. you can assign types to your TH expressions.
02:36:08 <erisco> okay, haven't heard of it and don't know how it works
02:36:14 <pharaun> heh yeah its spam but *shrugs* i guess if folks don't like it enough
02:36:23 <pharaun> it seems easy enough to have hackagebot not post in here
02:36:28 <erisco> or what the significance is, seeing as once you splice the expression has a type anyways
02:36:45 <pharaun> *sigh* someone slammed a door in the house, brb
02:36:55 <erisco> does it just assign blame to the QQ implementor vs the QQ user? I don't know
02:37:32 <tulcod> erisco: see e.g. https://ghc.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal
02:37:38 <erisco> pharaun, it just needs a special case for amazonka
02:38:07 <pharaun> erisco: is the amazonka dev in here, iirc amazonka is mostly machine generated
02:38:18 <pharaun> anyway fair enough
02:38:28 <tulcod> erisco: essentially, the problem is that you're just generating arbitrary expressions, and you have no idea what they'll do. sure, *eventually* they have a reified type, but you have no control on what it'll be, whereas in plain haskell you do
02:39:00 <tulcod> erisco: so typed TH is a way to make sure that the AST you're generating really does what you want it to do
02:39:14 * hackagebot amazonka-ds 1.2.0.2 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.2.0.2 (BrendanHay)
02:39:16 * hackagebot amazonka-cloudwatch-logs 1.2.0.2 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.2.0.2 (BrendanHay)
02:39:18 * hackagebot amazonka-route53 1.2.0.2 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.2.0.2 (BrendanHay)
02:39:20 * hackagebot amazonka-cloudsearch 1.2.0.2 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.2.0.2 (BrendanHay)
02:39:22 * hackagebot amazonka-storagegateway 1.2.0.2 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.2.0.2 (BrendanHay)
02:40:37 <erisco> tulcod, hm, I don't really get it, but I'll try and read it later
02:43:51 <kqr> why is Either e not an instance of MonadCatch?
02:44:24 * hackagebot amazonka-ec2 1.2.0.2 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.2.0.2 (BrendanHay)
02:44:26 * hackagebot amazonka-kms 1.2.0.2 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.2.0.2 (BrendanHay)
02:44:28 * hackagebot amazonka-elastictranscoder 1.2.0.2 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.2.0.2 (BrendanHay)
02:44:30 * hackagebot amazonka-lambda 1.2.0.2 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.2.0.2 (BrendanHay)
02:44:32 * hackagebot amazonka-ecs 1.2.0.2 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.2.0.2 (BrendanHay)
02:47:50 <erisco> there is also the annoyance that you want the caller to choose the allocation strategy, not the callee
02:48:16 <erisco> possibly
02:48:23 <erisco> there is a trade off at either end
02:49:34 * hackagebot regex-tdfa 1.2.1 - Replaces/Enhances Text.Regex  https://hackage.haskell.org/package/regex-tdfa-1.2.1 (ChrisKuklewicz)
02:49:49 <erisco> oh dear, I have a lot of dependencies on that
02:50:46 <ttt_fff> does attoparsec track row/col ?
02:55:00 <Cale> ttt_fff: No, I believe the position it tracks is just the number of bytes or characters as appropriate.
02:55:19 <Cale> ttt_fff: It doesn't treat newlines specially, it's intended for parsing non-human-readable formats.
02:55:25 <ttt_fff> Cale: also, do you know why attoparsec backtracks by default? this seems to make running time hard to predict / slower
02:55:44 <ttt_fff> Cale: noted, parsec = lines of text, attoparsec = list of chars
02:55:57 <EvanR> you can track newlines yourself
02:56:08 <EvanR> with user state
02:56:12 <ttt_fff> how does "backtrack by default" ever increase performance?
02:57:28 <Cale> ttt_fff: It doesn't backtrack by default. Once a parser consumes input, the other branches are discarded.
02:57:37 <Cale> ttt_fff: Unless you explicitly use try
02:58:01 <Cale> Oh, no, I'm mistaken
02:58:12 <ttt_fff> Cale: yeah, I think what you described is Parsec, not attoparsec
02:58:26 <Cale> Yeah, attoparsec also has try, but it's a no-op
02:58:41 <ttt_fff> this confuses me; since attoparsec is meant to be high performance
02:58:48 <ttt_fff> yet it auto backtracks (which seems very expensive)
02:59:19 <EvanR> backtracking is not that expensive on a strict bytestring input
02:59:32 <Cale> It appears to just use success and failure continuations.
02:59:33 <ttt_fff> I think backtracking can be forced to be exp time
02:59:35 <EvanR> and you wont backtrack if you dont fail to parse after some bytes
02:59:58 <EvanR> of course, if you need backtracking, you put a bunch of trys anyway
03:00:21 <ttt_fff> the problem is: attoparsec behaves as if try is put everywhere
03:00:38 <EvanR> its not implemented that way of course, so its not as slow as that
03:01:21 <EvanR> its not randomly backtracking all the time, unless you designed it to
03:01:43 <Cale> It could result in more space usage
03:01:51 <EvanR> for good protocols you dont need backtracking
03:07:33 <ttt_fff> is it possible to write a file Header.hs in such a way s.t. "import Header" ends up being the same as "import qualified Data.Map as DM; import qualified Data.Set as DS;"
03:08:05 <EvanR> i remember learning parsec and attoparsec together, and thinking attoparsecs way was more intuitive. but now i dont know
03:08:47 <EvanR> it certainly seems like a waste of space to allow backtracking when you hope you dont need it, and have no way to disable it
03:10:37 <ttt_fff> oh I get it now
03:10:42 <ttt_fff> attoparsec is machine gnerated logs
03:10:49 <ttt_fff> so you're not every supposed to completely fail
03:10:56 <ttt_fff> if you fail on one parse option, you should try next option
03:10:59 <ttt_fff> thus the auto retrys
03:11:14 <ttt_fff> parsec is for parsing human written stuff, so there's the possibility of syntax errors
03:11:28 <ttt_fff> thus the manual retry (for ambigituity), and complete fail (when there is a syntax error)
03:11:31 <EvanR> there is always the possibility of parse failure
03:11:42 <EvanR> the json parser for example
03:14:17 <EvanR> apparently they added <||> https://github.com/bos/attoparsec/pull/65
03:14:39 <jophish> Yo yo yo, I'm back!
03:22:30 <ttt_fff> is there a way to say "import Data.Map with 'lookup' renamed as 'lookupDM'" ?
03:23:15 <erisco> import qualified Data.Map as Map; lookupDM = Map.lookup
03:23:24 <ttt_fff> yeah
03:23:27 <ttt_fff> but then I have to give it a typesig
03:23:28 <pavonia> Not without introducing a new binding
03:23:36 <aristid_> ttt_fff: not sure, but you can do import Data.Map hiding (lookup); import qualified Data.Map as DM
03:23:59 <EvanR> M.lookup is more conventional
03:24:16 <Cale> Usually I just   import Data.Map (Map); import qualified Data.Map as M;
03:24:21 <erisco> I disapprove of single letter module names
03:24:22 <ttt_fff> yeah, but then I have to put "import qualified Data.Map as M" at the top of EVERY *.hs file
03:24:29 <aristid_> DISAPPROVED
03:24:34 <EvanR> erisco: well, its conventional
03:24:38 <erisco> rubber stamp and all
03:24:40 <EvanR> M, BS, T, TE etc
03:24:56 <Cale> ttt_fff: Yeah, it's a bit annoying. I still somewhat miss the days when you could just  import FiniteMap  and be done with it.
03:24:58 <aristid_> EvanR: i like to be inconsistent with the bytestring abbreviations
03:25:14 <aristid_> adds some spice
03:25:14 <EvanR> BS, LBS, BSC
03:25:16 <ttt_fff> oh wait, I can define a macro "importAll" which imports all the basic stuff I want
03:25:17 <ttt_fff> this is evil
03:25:27 <aristid_> ttt_fff: nah
03:25:29 <EvanR> youre free to use the fully qualified name at any ime
03:25:41 <EvanR> and it will be silly
03:25:48 <aristid_> ttt_fff: just make a TttFff module that imports AND RE-EXPORTS everything you want
03:25:48 <EvanR> longer than most of the rest of the code
03:25:52 <erisco> or you can just use Map, ByteString, Text, so on
03:26:31 <EvanR> lots of qualified ByteString will really eat up real estate
03:26:42 <EvanR> this isnt java
03:26:45 <erisco> I don't find it an issue
03:26:48 <aristid_> qualified operators look ugly
03:27:17 <EvanR> same reason we dont use beginningOfList:restOfList
03:27:33 <EvanR> beginningOfListOfInt: ;)
03:27:42 <erisco> much better
03:28:56 <EvanR> ttt_fff: elaborate blog post about attoparsecs internals http://www.serpentine.com/blog/2014/05/31/attoparsec/
03:29:21 <ttt_fff> EvanR: may check it later, in middle of rewrite; do not want to unwind mental stack
03:30:49 <aristid_> EvanR: beginningOfListOfInt `Language.Haskell.Collections.List.prependOneElement` restOfListOfInt
03:33:04 <erisco> I will just assign base64 names in increasing order then
03:33:37 <erisco> maximum compaction
03:33:53 <erisco> and then compress
03:34:59 <aristid_> erisco: sounds good
03:35:44 <EvanR> ttt_fff: oh and a nice post from edwardk about its performance, including (lack of doing-anything) try https://www.quora.com/Haskell-programming-language/What-makes-Attoparsec-more-than-an-order-of-magnitude-faster-than-Parsec-3
03:37:32 <ttt_fff> EvanR: 3.) Attoparsec doesn't case about try. That means it always backtracks. This is both good and bad as well. It means you can't clean up unreachable continuations in attoparsec, because they are always reachable. So large parsec in attoparsec can leak more memory than parsec. But in exchange you get raw speed.
03:37:37 <ttt_fff> why does always backtrack make it faster?
03:37:38 <ttt_fff> I don't get that
03:37:51 <ttt_fff> it seems like there are times where you try stuff, where parsec can be like "this is retarded, we're goign to fail this entire thing"
03:42:12 <EvanR> thatll happen in attoparsec if you run out of choices
03:42:39 <EvanR> according to the post its faster because you dont check if you need to try or not
03:44:07 <ttt_fff> yeah, but you have to do both
03:44:12 <ttt_fff> which seems like more work
03:44:20 <EvanR> do both?
03:44:27 <ttt_fff> yeah, attoparsec tries all branches
03:44:33 <ttt_fff> because it always backtrack automatically
03:44:37 <EvanR> no it doesnt
03:44:52 <ttt_fff> attoparsec's a <|> b behaves as if (try a) <|> b
03:45:05 <EvanR> if the input is a, then it wont do b
03:45:16 <ttt_fff> AttoParsec[ a <|> b ] == Parsec [ try a <|> b ]
03:45:34 <ttt_fff> oh right, my statement about trying all in parallel is wrong
03:45:50 <ttt_fff> howeve,r I don't see how putting in a 'try' every time makes attoparsec faster
03:45:51 <EvanR> interesting idea though ;)
03:46:02 <EvanR> it doesnt put a try every time, its not implemented with parsec
03:46:12 <ttt_fff> i'm talking about the behaviour
03:46:15 <EvanR> it just stupidly backtracks
03:46:24 <ttt_fff> stupidly backtracks == putting try everywere
03:46:45 <EvanR> which is easier to understand i think, it coinsides with the behavior of failing after only looking at 1 byte
03:47:16 <ttt_fff> we're talking about efficiency
03:47:21 <ttt_fff> I don't understand why having try everywhere helps performance
03:47:37 <EvanR> it helps because its nowhere
03:47:43 <EvanR> not everyhere
03:47:49 <EvanR> no branching on that directive
03:48:15 <EvanR> its like, i dont understand why + is faster by putting the noop (noop (+)) everywhere
03:48:42 <ttt_fff> the reason try is a noop in attoparsec
03:48:58 <ttt_fff> is because in attoparsec "a <|> b" backtracks even if a consumes input
03:49:25 <EvanR> well the logic is completely backwards if i read what you said literally, and i cant think straight at this hour
03:49:31 <bennofs> ttt_fff: try is not about performance as much about giving better error messages, afaik
03:49:47 <EvanR> in parsec, try is to direct the parser to use backtracking
03:49:55 <EvanR> without it the parser wont work right
03:50:07 <EvanR> attoparsec has it just to appease people who cant be arsed to remove it when porting a parser
03:50:17 <EvanR> it doesnt do anything
03:50:41 <EvanR> in attoparsec you dont have to direct the parser to do aynthing special so the implementation is faster for it
03:51:07 <EvanR> like unary nat addition is faster than unary integer addition because one less case
03:52:03 <ttt_fff> lol
03:52:04 <ttt_fff> I give up
03:56:06 <Cale> bennofs: It's also about space performance. If you can commit to one branch of the parser sooner, the early part of the input string becomes garbage, and can be collected, whereas so long as there's the possibility of returning to another part of a disjunction, you can't throw that part of the input away
03:56:32 <ttt_fff> Cale: that statment sounds like you are agreeing with me.
03:56:52 <EvanR> backtracking uses more space
03:56:59 <Cale> ttt_fff: Well, somewhat? It might not actually matter in practice for the sorts of protocols that attoparsec is being used to parse.
03:57:27 <EvanR> Cale: it does matter since attoparsec can never forget the stream until its finished completely
03:57:41 <bennofs> ttt_fff: yeah. but most cases that you would want to write without try are already available in attoparsec as primitives that don't use try (for example, see 'string' iirc)
03:57:41 <EvanR> not the same thing as being slower
03:58:40 <bennofs> EvanR: as long as you don't write your whole parser as   protocol1 <|> protocol2, it can forget some stuff, since it can forget in  part1 >> part2, no?
03:58:49 <Cale> bennofs: right
03:59:32 <EvanR> having to split up the parser into multiple idependent parsers kind of sucks
03:59:45 <EvanR> how much to split based vaguely on how much memory you want to save
04:00:30 <EvanR> its basically not able to stream directly
04:01:07 <bennofs> Hmm, does `many bla` commit? 
04:01:24 <bennofs> (whenever it parsed one bla successfully?)
04:01:58 <EvanR> commit? if that succeeds then the parser it is part of could still fail
04:02:34 <ttt_fff> here's the thing, I can look at Parsec code, and estiamte running time, beause as long as I don't have try, it's nearly linear time; when I look at attoparsec code, there's no such guarntee, because <|> can backtrack on its own
04:02:47 <EvanR> attoparsec cant commit in the sense of throwing away a chunk of input it knows it wont need
04:03:01 <ttt_fff> if my parsec is slow, I look and try to eliminate try; is attoparsec is slow, I ahve no idea where the <|> backtracking, after consuming input, is going on at
04:03:03 <bennofs> EvanR: the question is whether it commits after parsing one `bla`
04:03:25 <bennofs> EvanR: so parsing would look like: bla >> commit >> bla >> commit >> ...
04:03:25 <EvanR> my question was what commit meant, if not throwing away input that it knows it wont need (which never happens)
04:03:41 <bennofs> EvanR: it means that the parser stops backtracking after a commit point
04:04:17 <EvanR> it always backtracks to the point of the last <|>
04:04:32 <bennofs> EvanR: yes, but in most parsers, you don't have a top-level <|>
04:04:41 <bennofs> I think
04:05:27 <EvanR> if theres no <|> at the top leve, then it still wont throw away input
04:05:55 <EvanR> even though it could technically
04:05:59 <bennofs> EvanR: it will. It will throw away input in a >> b after a finishes, no?
04:06:07 <EvanR> no
04:06:15 <EvanR> the input is a big bytestring
04:06:24 <bennofs> EvanR: lazy bytestring is not a possbility?
04:06:25 <EvanR> well, a complex bytestring-like buffer
04:06:59 <EvanR> no it doesnt allow lazy bytestring, that functionality is with the continuation based Partial result
04:07:11 <EvanR> that functionality was replaced with*
04:07:37 <EvanR> the subsequent input to the partial result will be magically appended to the previous input
04:07:52 <EvanR> so backtracking still works
04:09:16 <bennofs> EvanR: if you have a parser like foo >> bar, and you supply just enough input that foo parses successfully, then the continuation should not need to hold on to input, since it'll never need to backtrack. And attoparsec doesn't do that? 
04:09:31 * bennofs learned something about attoparsec
04:09:57 <EvanR> right
04:10:34 <bennofs> I guess attoparsec is more aimed at parsing a buffer that is small enough so that you can load the whole buffer into memory first and the parse it
04:10:39 <EvanR> theres a issue on github discussing the possiblity of a input datastructure which can lose the leading sections when it knows they are not needed
04:10:50 <EvanR> but it seemed that no one could design one that had high enough performance
04:12:16 <EvanR> it seems that high enough performance for any commits to attoparsec means "greater than or equal performance of previous version" that is, performance is monotonic ;)
04:12:34 <EvanR> performance means speed
04:12:52 <besenwesen> say, with DataKinds, is it somehow possible to express that a promoted type co-varies with a concrete type? like, when i have data Foo (a∷Bool) = ∀p . Foo p, can i enforce it that p is a concrete type determining a? so that the expression Foo True ∷ Foo 'True
04:13:56 <bennofs> EvanR: well, for most applications, the input string will be much smaller than the parse tree, or?
04:14:27 <EvanR> the stackoverflows are all referring to "my 100MB file"
04:14:49 <EvanR> and for a network stream, its really infinite
04:15:22 <EvanR> pipes-attoparsec must periodically "reset" the whole thing and start over with the unconsumed so far buffer as the new initial input
04:28:09 * hackagebot servant 0.4.4.2 - A family of combinators for defining webservices APIs  https://hackage.haskell.org/package/servant-0.4.4.2 (jkarni)
04:28:11 * hackagebot servant-client 0.4.4.2 - automatical derivation of querying functions for servant webservices  https://hackage.haskell.org/package/servant-client-0.4.4.2 (jkarni)
04:28:13 * hackagebot servant-docs 0.4.4.2 - generate API docs for your servant webservice  https://hackage.haskell.org/package/servant-docs-0.4.4.2 (jkarni)
04:28:15 * hackagebot servant-jquery 0.4.4.2 - Automatically derive (jquery) javascript functions to query servant webservices  https://hackage.haskell.org/package/servant-jquery-0.4.4.2 (jkarni)
04:28:17 * hackagebot servant-server 0.4.4.2 - A family of combinators for defining webservices APIs and serving them  https://hackage.haskell.org/package/servant-server-0.4.4.2 (jkarni)
04:28:20 <mpickering> besenwesen: That technique is referred to as singletons
04:30:27 <besenwesen> mpickering, yea, i played around with the package (though i’m out of my depths). i succeeded at making certain types illegal, but i thought i’d also like to track the corresponding values inside the types, so i can still pattern match on them if i want
04:31:35 <besenwesen> of course i could define data Foo (a::Bool) = Foo x, but this would allow Foo True :: Foo 'False, and i thought i might enforce matching the information tracked in the type with the value
04:33:19 * hackagebot servant-examples 0.4.4.2 - Example programs for servant  https://hackage.haskell.org/package/servant-examples-0.4.4.2 (jkarni)
04:33:21 * hackagebot servant-blaze 0.4.4.2 - Blaze-html support for servant  https://hackage.haskell.org/package/servant-blaze-0.4.4.2 (jkarni)
04:33:23 * hackagebot servant-lucid 0.4.4.2 - Servant support for lucid  https://hackage.haskell.org/package/servant-lucid-0.4.4.2 (jkarni)
04:53:23 <ttt_fff> Idea: (+=) as insert for map/set. Question: smart or stupid?
04:53:45 <ttt_fff> Map k v += (k,v) ---> Map k v
04:53:51 <ttt_fff> Set k += k ----> Set k
04:54:07 <ttt_fff> (-=) for delete
04:54:10 <ttt_fff> what do people think?
04:54:52 <thewormkill> I'm by no means an expert, but why do you doubt it's a smart idea in the first place? Only thing I can think off is that it is not extremely functional, but apart from that ...
04:55:28 <ttt_fff> I think it looks cool
04:55:34 <ttt_fff> DM.insert k v ... becomes
04:55:38 <ttt_fff> (+= (k,v)) ...
04:55:54 <erisco> 1 += [2,3]
04:55:57 <erisco> this is going places
04:56:08 <ggole> Please no
04:56:31 <ttt_fff> nono, lhs = container, rhs = object
04:56:42 <ttt_fff> so it'd be ( [2, 3] += 1 ) == [1, 2, 3]
04:56:51 <erisco> class Prependable f where (+=) :: a -> f a -> f a
04:56:51 <ttt_fff> isn't that neat?
04:56:54 <erisco> it is happening
04:57:17 <ttt_fff> this is exciting; how can I submit a ticket to put this into Base ?
04:58:19 <srhb> containers isn't base.
04:58:26 <srhb> But that's where you'd go. 
04:59:09 <ttt_fff> hmm, but this'd be a typeclass, "class Stuffable a b \n where (+=) :: b -> a -> b"
04:59:14 <ttt_fff> then containers would add orphan instances
04:59:20 <srhb> Erm, okay.
05:00:01 <srhb> Then you'd probably need a lot more justification before you'd get any kind of traction for the proposal.
05:00:56 <srhb> For instance there's a Monoid instance for Map because it's so well-behaved and general.
05:01:12 <srhb> Map k, I should say.
05:01:20 <ttt_fff> You're taking this seriously; I feel bad for wasting your time, so I'm going to just admit I'm entirely kidding around.
05:01:37 <ttt_fff> I personally think  this idea is retarded, though having a short hand infix op for insert would be nice.
05:01:50 <ttt_fff> There's ! or !! for lookup right? There should be something for insert.
05:03:02 <bennofs> ttt_fff: import Control.Lens: yourMap & at key ~? value   operators ftw!
05:03:06 <srhb> I didn't see any indication that you were joking.
05:03:12 <bennofs> ;)
05:03:36 <ttt_fff> :t (~?)
05:03:37 <lambdabot>     Not in scope: ‘~?’
05:03:38 <lambdabot>     Perhaps you meant one of these:
05:03:38 <lambdabot>       ‘^?’ (imported from Control.Lens),
05:03:47 <bennofs> :o 
05:04:05 <ttt_fff> srhb: I think += is bad name for haskell because += means mutation, but this op is pure
05:04:16 <srhb> Ok. :)
05:04:16 <bennofs> ttt_fff: oops, replace ~? by ?~
05:04:24 <ttt_fff> :t (?~)
05:04:26 <lambdabot> ASetter s t a (Maybe b) -> b -> s -> t
05:04:33 <srhb> bennofs: The ~x are the stateful ones, are they not?
05:05:30 <bennofs> srhb: x= is stateful (like +=), while x~ is "readerly" (gives back a function, like +~)
05:05:59 <srhb> Oh that's how it was.
05:30:21 <ttt_fff> this is sorta specific, but has anyone written a "structure editor" (i.e. the code always parses) for haskell in javascript?
05:31:10 <slack1256I> structured haskell mode
05:31:19 <slack1256I> wait, no, what?
05:32:31 <nshepperd> you want to manipulate a haskell AST from javascript?
05:32:37 <ttt_fff> http://peaker.github.io/lamdu/
05:32:50 <ttt_fff> but in browser, instead of ftgl
05:33:03 <ttt_fff> maybe I can just ghcjs that code and use webgl
05:37:16 <faruq> test
06:03:24 * hackagebot cgrep 6.5.4 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.4 (NicolaBonelli)
06:34:36 <kuribas> how do you nest guards?  using IfThenElseGuards?
06:34:43 <kuribas> MultiWayIf?
06:35:12 <slack1256> | (just a) <- someMaybe, test a = ... ? 
06:35:29 <slack1256> you can also guard on case statements
06:36:23 <kuribas> Then I have | x > y && y > z = ... | x > y && y < z = ...
06:36:37 <kuribas> but I'd like to group (x > y) for example when it would be expensive.
06:36:57 <kuribas> There is no garantee ghc will do CSE.
06:38:19 <thewormkill> well, you might want to restructure your code then
06:38:44 <slack1256> well you could use where statements and do the guards then
06:38:49 <slack1256> ie something like
06:39:02 <slack1256> myFoo a b c
06:39:04 <slack1256> where
06:39:15 <slack1256> val = a < b
06:39:43 <slack1256> fun | val {- if val true then the guard will succed -}
06:40:12 <slack1256> and you can use val inside the scope of fun. you can use fun inside on myFoo because is a where
06:40:31 <slack1256> seems a matter of managing scopes with a little of where and friends. 
06:48:35 * hackagebot bitx-bitcoin 0.5.0.1 - A Haskell library for working with the BitX bitcoin exchange.  https://hackage.haskell.org/package/bitx-bitcoin-0.5.0.1 (tebello_thejane)
07:29:18 <rpfun> is it idiomatic in Haskell if I have a type "data A = A { b :: B, c :: C }" and a function "f :: A -> (D -> E)", where i use the function resulting from "f" frequently, to create a "cached" constructor for A, like "data A = A { b :: B, c :: C} | ACached { b :: B, c :: C, g :: D -> E }"? I hope there is a more elegant solution, but i cannot think of one.
07:40:06 <Sindriav_> Can I reconfigure from `cabal repl` ?
07:42:13 <srhb> Nope.
07:45:13 <kuribas> rpfun: if f is defined like f a d = ... then not.
07:46:39 <kuribas> rpfun: otherwise I'd make a separate datatype "data CachedA = Cached A (D -> E)"
07:47:28 <kuribas> he's gone...
07:52:06 <htebalaka> is there any reason Bifunctor doesn't depend on Functor?
07:53:31 <srhb> htebalaka: The kinds don't match.
07:54:13 <srhb> in class Bifunctor p, p :: * -> * -> *, but in Functor f, f :: * -> *
07:54:36 <htebalaka> that didn't occur to me. i guess you can't do "class Functor (f a) => Bifunctor f"
07:54:55 <srhb> Consider that Either e is a Functor. how do you now say it's also a bifunctor? You've lost one type argument entirely
07:55:41 <htebalaka> "class forall a. Functor (f a) => Bifunctor f" maybe is theoretically correct, if not currently allowed?
07:55:50 <srhb> Hummm
07:56:08 <srhb> I get your meaning, but no.
07:56:28 <htebalaka> :(
08:10:21 <DrGamatos> Hello!
08:10:33 <srhb> DrGamatos: Hello.
08:10:56 <DrGamatos> What's up
08:11:38 <srhb> :t up
08:11:40 <lambdabot>     Not in scope: ‘up’
08:11:40 <lambdabot>     Perhaps you meant one of these:
08:11:40 <lambdabot>       ‘u’ (imported from Debug.SimpleReflect),
08:11:41 <srhb> No idea.
08:12:11 <DrGamatos> hahah g00d one
08:12:16 <srhb> (Kidding, but there's a #haskell-blah if you just want to chat.)
08:12:51 <suppi> :t u
08:12:53 <lambdabot> Expr
08:12:55 <DrGamatos> Nice, i'll check it out. I just wanted to greet before asking my question
08:13:06 <srhb> DrGamatos: Oh, ok. Very polite, but probably unnecessary. :D
08:13:07 <suppi> What's u?
08:13:21 <DrGamatos> So i am using the Network.Socket module
08:13:21 <Clint> it's an Expr
08:13:21 <srhb> suppi: https://hackage.haskell.org/package/simple-reflect
08:13:29 <DrGamatos> and i just wondered
08:13:45 <DrGamatos> how do i find out after getting a handle from the socket
08:13:50 <srhb> > take 3 (iterate g u)
08:13:50 <suppi> srhb, ohhh... cool
08:13:52 <lambdabot>  [u,g u,g (g u)]
08:13:52 <DrGamatos> if the connection dropped
08:14:03 <suppi> awesome even
08:14:52 <srhb> DrGamatos: I assume an exception happens.
08:15:29 <srhb> Actually, isn't that what the MVar SocketStatus is for
08:15:33 <DrGamatos> well that happens when i try to read from the handle when the connection has dropped
08:16:00 <srhb> Yes indeed.
08:16:20 <DrGamatos> <socket: 348>: hGetLine: failed (No error)
08:16:35 <DrGamatos> This is the only way?
08:16:44 <DrGamatos> And the proper one? To check for disconnects?
08:16:52 <mettekou> Does anyone know why this code produces symbol table entries for parameters, even though I instruct happy just to return those? http://lpaste.net/7050686976755761152
08:17:19 <srhb> DrGamatos: I've not used it, so take it with a grain of salt, but my thought is that since it can close at ANY time, the only reasonable way is to catch the exception.
08:17:38 <srhb> DrGamatos: I mean, you can "check" the socket status and go "ok, everything is fine" and then push something to it, and you've earned zero guarantees.
08:18:13 <DrGamatos> Yep thats what i was thinking too
08:33:04 <DrGamatos> Btw, does the handle of the socket manage all the receive operations?
08:33:31 <DrGamatos> I mean if the server sends me some data and i do not call the hGet* family
08:33:50 <DrGamatos> are they somehow stored until i ask for them?
08:36:42 <srhb> DrGamatos: The electrons don't queue up in the wires. :)
08:36:55 <monochrom> but they do queue up in the buffers
08:37:02 <DrGamatos> Exactly
08:37:21 <DrGamatos> I don't know how the socket module works underneath
08:37:24 <monochrom> you should simply set up an experiment to find out
08:37:48 <Welkin> doesn't TCP guarantee that all packets will arrive and in the correct order?
08:37:52 <Welkin> UDP drops packets
08:38:13 <DrGamatos> well it ain't about TCP it is about how the socketToHandle system works in haskell
08:38:50 * hackagebot morte 1.3.0 - A bare-bones calculus of constructions  https://hackage.haskell.org/package/morte-1.3.0 (GabrielGonzalez)
08:38:52 * hackagebot foldl-transduce 0.2.1.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.2.1.0 (DanielDiazCarrete)
08:38:54 * hackagebot zalgo 0.1.0.2 - Z-algorithm implemented on haskell's built-in cons-cell-based lists.  https://hackage.haskell.org/package/zalgo-0.1.0.2 (mniip)
08:41:02 <DrGamatos> cause with that in mind, i do not know if i should have a separate thread that should read from the handle constantly or not
08:45:18 <mniip> monochrom, ok, so I've implemented the thing, now presumably comes the paper?
08:50:13 <monochrom> perhaps what edwardk said, write some blog posts first, to practice writing.
08:52:45 <Welkin> formal papers are overrated :P
09:02:24 <silver> peer review isn't :P
09:19:21 <tomberek> conal: hello
09:19:46 <conal> tomberek: hi
09:20:06 <tomberek> i'm guessing you are conal elliot
09:20:22 <conal> tomberek: close. i'm conal elliott
09:20:29 <tomberek> i wanted to ask about lambda-ccc
09:20:46 <conal> sure
09:21:32 <conal> tomberek: i did get your email, btw. was busy all day yesterday.
09:21:44 <tomberek> i am trying to do something similar, I am starting with an arrow expression, perhaps adding to it to allow a CCC interpretation.... okay... yeah, basically that.
09:22:23 <conal> tomberek: i don't know what combination of CCC optimizations correspond to beta-eta normalization.
09:22:27 <tomberek> but it seems roundabout... is there a way to just normalize CCC without going through lambda calculus
09:22:36 <conal> tomberek: but i'd bet surprised if there weren't a correspondence.
09:22:46 <conal> (i'd *be* surprised)
09:22:57 <tomberek> i mean, if CCC = typed lambda calculus... there must be a way to "lift" the normalization into an algorithm directly in CCC
09:23:11 <conal> tomberek: that's my guess as well.
09:25:34 <tomberek> i've been googling and searching, but i haven't found anything.... in the meantime, my other thought would be to just take advantage or lambda-ccc to do it. I see toCCC. Is there a "toLambda" and away to perform the normalization?  I guess: "what's the best way to hook into lambda-ccc?"
09:26:21 <tomberek> then all I would need is normalize = toCCC . normalizeL . toLambda for my datatype
09:27:47 <conal> there isn't a toLambda, but there's probably something close. one could probably convert to the syntactic CCC, normalize, convert to a universal CCC (ie to all CCCs), and specialize to lambda calculus via the CCC interface.
09:28:02 <conal> tomberek: not sure that route came out clearly.
09:28:40 <conal> tomberek: i intended lambda-ccc to have that sort of flexibility. unsure whether it does at the moment.
09:28:47 <tomberek> in fact, i'd be happy even with a way to do normal cartesian (not closed) normalization
09:28:56 * hackagebot moesocks 0.1.1.10 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.1.10 (JinjingWang)
09:29:17 <tomberek> okay...  i also looked at Morte... it can do the lambda normalization, but i don't think it has any structure to route to-from CCC's
09:30:35 <conal> tomberek: ah, too bad.
09:31:42 <tomberek> would there be any value in merging, or rather extracting the common components in those two packages?
09:32:03 <conal> tomberek: i don't know, but i'll take a look at morte. thanks for the pointer.
09:34:00 <simon> if I've got some String functions, how do I quickcheck them without overwriting the Arbitrary instances?
09:34:04 <tomberek> i'd be happy to write the toLambda piece. But I'd need some literature. (i'm not sure I followed the route you intended)
09:36:51 <conal> tomberek: my thought was to give a CCC instance for lambda terms. 
09:37:13 <tomberek> conal: yep, that would be equivalent
09:37:15 <sshine> do I create my own newtypes and create Arbitrary instances for those? as suggested in http://stackoverflow.com/questions/20934506/haskell-quickcheck-how-to-generate-only-printable-strings
09:37:31 <conal> tomberek: though now that i think of it, doing so would probably create a lot of un-normalized results, which i guess would defeat your purpose.
09:38:56 <conal> tomberek: i'll be afk for a while but back later today. and you know how to get me by email.
09:38:58 <tomberek> conal: would it? the next step would be normalization anyway, then your toCCC converts it to the form I need, not circuits, but an arrow expression. You and I are ending up at a similar point, I'm just starting with a CCC, you're converting Core into Lambda
09:41:01 <tomberek> sshine: are you changing the behavior of Strings or need a particular structure in the Arbitrary String's?
09:43:58 * hackagebot servant-mock 0.4.4.2 - Derive a mock server for free from your servant API types  https://hackage.haskell.org/package/servant-mock-0.4.4.2 (jkarni)
09:50:00 <sshine> tomberek, I need one generator that generates morse code and one that generates strings with letters only.
09:50:20 <sshine> tomberek, or rather, the functions that I'm testing needs morse code and letters as input.
09:50:26 <tomberek> then yes, a newtype would be appropriate
09:51:38 <tomberek> the `forAll` also works, but the newtype will help develop the rest of your code as well
09:55:52 <sshine> tomberek, you mean the moment I embed a String into some other type that needs to be tested, I can rely on the instance once again?
09:59:00 * hackagebot glue-core 0.4.0 - Make better services.  https://hackage.haskell.org/package/glue-core-0.4.0 (seanparsons)
10:00:33 <ReinH> Why represent morse code as a string? Why not data Morse = Dot | Dash | Space and then use [Morse]?
10:05:25 <hiptobecubic> why have space instead of [[Morse]] ?
10:06:20 <ReinH> true
10:06:38 <tomberek> all good points
10:07:19 <exio4> it depends, which representation is handier for your use case?
10:08:33 <monochrom> if it is possible to have [Dot, Space, Space, Dot], and it is not equivalent to [Dot, Space, Dot], then you allow Space to live.
10:09:01 * hackagebot glue-common 0.4.1 - Make better services.  https://hackage.haskell.org/package/glue-common-0.4.1 (seanparsons)
10:09:03 * hackagebot glue-core 0.4.1 - Make better services.  https://hackage.haskell.org/package/glue-core-0.4.1 (seanparsons)
10:09:05 * hackagebot glue-ekg 0.4.1 - Make better services.  https://hackage.haskell.org/package/glue-ekg-0.4.1 (seanparsons)
10:09:08 <monochrom> else, [Dot, Space, Space, Dot] is just a non-unique way to say [[Dot], [Dot]]
10:09:22 <exio4> [[Dot], [], [Dot]] ? 
10:09:56 <monochrom> looks like we need NonemptyList too
10:10:10 <monochrom> [NonemtpyList Morse]
10:13:56 <greves> i am unable to install yesod because of network package on windows... last post on this issue if anyone has any ideas: https://github.com/haskell/network/issues/125#issuecomment-136010033
10:13:59 <ReinH> All of these are significant improvements over String
10:14:02 * hackagebot glue-example 0.4.1 - Make better services.  https://hackage.haskell.org/package/glue-example-0.4.1 (seanparsons)
10:18:27 <ro6> I'm trying to set up a project under nix that needs 'cpphs' to build, but I'm not sure how to set up the 'shell.nix'
10:19:46 <ro6> any 'nix' wizards around?
10:36:15 <srhb> ro6: With the default setup it should be the default.nix you have to set them in, I think?
10:36:27 <srhb> ro6: But you should go ask the experts in #nixos if you get no responses here :)
10:36:45 <ro6> oh, I didn't realize they had a channel, thanks!
10:37:46 <jeltsch> marcus-aurelius: Ave Caesar!
10:38:55 <marcus-aurelius> Salve jeltsch!
10:40:08 * asterix drinks some magic potion
10:52:22 <newbie___> hello
10:53:09 <newbie___> i have weird question but i'm sorry for disturbing the channel which would be busy answering programming question (smart questions)
10:54:38 <newbie___> my question is  haskler always says these words learn haskell its makes you a better programmer what this means ? why not python ? i dont understand .. Is he lying ?!
10:57:30 <mpickering> do they say that learning python won't make you a better programmer?
10:57:32 <glguy> newbie___: Tell us what reasons he gave for his statement and we can help validate them
10:57:56 <dyreshark> newbie___: learning a new programming language can teach you new ways to solve problems.
10:58:15 <kadoban> newbie___: I'm of the opinion that learning many languages, with a broad range of semantics and abstractions, makes you a better programmer in general. In that sense haskell is probably good, since it's quite different from most languages people come in knowing.
10:58:34 <dyreshark> ^
10:58:45 <monochrom> I concur with glguy
10:59:07 * monochrom is not a fan of news-reporter questions
10:59:15 <newbie___> i didnt understand what they mean better programmer glguy  , isnt solving problems makes you better programmer ?
10:59:43 <glguy> newbie___: Ask your friend why he said that, see if he'll give more details
11:00:05 <monochrom> "Hey Hilary Clinton, I read something from Donald Trump's blog, what do you think?"
11:00:30 <newbie___> yes ! ofcourse glguy 
11:00:35 <Intolerable> if solving problems makes you a better programmer, what does a language that makes you better at solving problems do?
11:01:01 <monochrom> does solving problems make you a better programmer?
11:01:16 <glguy> What about asking questions?
11:01:21 <MarcelineVQ> Does making a man a knight make him a better fighter?
11:01:32 <voidzero> do I
11:01:35 <monochrom> asking questions makes you a better news reporter, it seems.
11:01:36 <voidzero> do I look fat in these pants?
11:01:48 <Intolerable> does a bear shit in the woods?
11:01:50 <glguy> monochrom: What about shouting questions?
11:01:53 <glguy> Are we on topic?
11:02:23 <voidzero> the answers to all of these questions right after this short word from our sponsors.
11:02:53 <undoall> Is there a shorter and cleaner way to do the `modify $ \s -> s { field = value }` pattern?
11:03:14 <Intolerable> field .= value
11:03:14 <glguy> In lens that's: fieldLens .= value
11:03:24 <glguy> *highfive*
11:03:35 <bennofs> johnw: y
11:03:36 <undoall> Ah, I mean using the state monad.
11:03:44 <Intolerable> yeah, that's field .= value
11:03:47 <bennofs> undoall: you've discovered one of the problems that lenses solve
11:03:51 <Intolerable> :t (.=)
11:03:52 <jeltsch> Wasn’t there also some GHC extension that provides syntactic sugar for record field updates?
11:03:53 <lambdabot> MonadState s m => ASetter s s a b -> b -> m ()
11:04:03 <Intolerable> (note the MonadState)
11:04:09 <bennofs> > flip execState (1,2) $ _1 .= 5  -- using lens
11:04:11 <lambdabot>  (5,2)
11:08:20 <danilo2> Hello! :) I was looking today at the Vector package and I've noticed an interesting fact - the `modify` function has time colpexity of (m + k), where m is the number of elms in Vector and k is number of updates. I would like to ask you if when we use Vectors, and simply update them, GHC makes a real copy of the memory under the hood or it optimises it away? We've got also the mutable version of vectors, providing functions to modif
11:08:27 <danilo2> and I would prefer to stay in pure code here
11:15:55 <pie_> Kind of a loaded question I guess, how good is functional programming for everyday projects?
11:16:06 <pie_> and real world stuff and such?
11:16:08 <srhb> pie_: Great^TM
11:16:12 <pie_> do you need to grok it to be usable?
11:16:16 <pie_> srhb: hah1a
11:16:17 <srhb> pie_: Yep.
11:16:49 <Chousuke> pie_: that question is impossible to answer without defining "everyday projects"
11:16:53 <bennofs> danilo2: I think there are some cases where GHC can optimise the copy away, but I think it needs to make one copy in most cases (not sure, but i wouldn't rely on it optimising it away)
11:17:00 <pie_> Chousuke: sounds reasonable
11:17:06 <Chousuke> I can tell you functional programming is good for lots of things
11:17:07 <srhb> pie_: Also you're asking the channel where we drank the kool-aid. :)
11:17:17 <pie_> xD
11:17:18 <pie_> yep
11:17:38 <pie_> I'm trying to get through as much of K&R C as I can and C11 before univ starts (in a week) but I want to try haskell after I get grips on it.
11:17:53 <Chousuke> in fact, I'd default to functional style unless the problem calls for something different.
11:18:15 <pie_> Chousuke: well from what little evangelism I read I want to too but IDK what Im doing
11:18:35 <pie_> I know 0 things about functional programming.
11:18:39 <srhb> pie_: The only real way to form an opinion on the matter is to Do The Thing, not Ask About The Thing
11:18:39 <danilo2> bennofs: Ok, so in performacne critical section I should stay with ST monad and ST vectors? Additional, are there any reasons I should consider Arrays instead of Vectors?
11:18:45 <Chousuke> pie_: well, that's no problem. Just keep doing it and you might learn eventually.
11:18:47 <pie_> srhb: yeah I do that way too much
11:18:48 <srhb> pie_: But we can help you get started when and if you like. :)
11:19:01 <pie_> I suppose I could adapt my C to be functional though it's been said that thats annoying
11:19:04 <Chousuke> pie_: that's usually how people go from 0 knowledge to being expers.
11:19:06 <srhb> Ehh, no
11:19:06 <Chousuke> +t
11:19:09 <pie_> so anything that I could read to do that?
11:19:16 <srhb> But you'll only REALLY realize that once you know Haskell as well. :P
11:19:21 <nshepperd> danilo2: some vector operations are fused, so that a temporary result that is immediately consumed will not be allocated. I don't know if 'modify' is one of those
11:19:54 <nshepperd> but also, that only saves an allocation, and not asymptotic cpu time
11:20:13 <pie_> srhb: was the Ehh @ doing functional C?
11:20:31 <srhb> pie_: I think most people in here will agree that it's a pain in the ass and not really doable in the long run.
11:20:37 <newbie___> thanks guys
11:20:48 <newbie___> good night
11:20:48 <srhb> pie_: People who haven't drunk the kool-aid may disagree.
11:21:04 <danilo2> nshepperd: what do you mean by asymptotic cpu time ?
11:21:06 <pie_> well I cant really imagine (which means nothing) how it would work without a lot of wrapper code so you're probably right
11:21:11 <srhb> pie_: But as said, you'll only really realize this once you've done FP in a language that's really good for FP.
11:21:26 <Chousuke> pie_: and functional programming is a paradigm with several differing definitions depending on who you ask. But learning how to program with laziness, pure functions and immutable data structures and the different algorithms they inevitably require will affect how you view other paradigms, as well.
11:22:05 <pie_> so to be more specific,is pure functions and immutability doable in C?
11:22:25 <Chousuke> well, I guess. it's just a lot more work.
11:22:29 <tommd> pie_: Yes, you can declare data 'const' and you can make deterministic functions in C.
11:22:29 <Welkin> pie_: referential transparency is not doable in C afaik
11:22:29 <srhb> pie_: "Doable" yes, painful yes.
11:22:30 <nshepperd> danilo2: it will still take time proportional to (m + k), but the constants might be different
11:22:44 <pie_> ok, imperative it is :C
11:22:56 <pie_> thanks for the input
11:22:59 <srhb> pie_: actually welkin is right, purity is probably not really doable (considering referential transparency.)
11:23:26 <srhb> pie_: But good luck and have fun starting uni. :)
11:23:32 <tommd> Which uni?
11:23:33 <pie_> \o/
11:23:53 <pie_> tommd: an obscure hungarian one, obscure because noone knows about us :P
11:23:59 <Chousuke> pie_: however, just knowing about the different approaches will probably make you a better coder anyway.
11:24:07 <Chousuke> knowledge tends to have that effect :P
11:24:25 <pie_> University of Debrecen, I'll be taking physics though and I have a "programming" course. I do a lot of computer stuff on my own time though.
11:24:31 <bennofs> nshepperd: hmm? fusing the copy away will make it O(k), since updating one element is O(1), no?
11:24:45 <pie_> i.e. its literally called programming
11:24:53 <danilo2> nshepperd: I was asking exactly about it - why it would take time proportional to m + k when GHC could optimise it away, so it will just replace an element in-place?
11:25:18 <tommd> Who here is travelling to Vancouver now or soon?
11:29:57 <Welkin> does anyone know of any additional resources that are helpful with the exercises in Lawvere's Conceptual Mathematics?
11:30:04 <Welkin> no answers are provided to them in the book
11:49:44 <programo> Hi I had created a sample1.hs file with just assigning x = 10  and tried to compile the haskell file with the command ghc  sample1.hs.... But I got an error message saying "The function `main' is not defined in module `Main'"
11:49:53 <programo> Could anybody help me with this?
11:50:00 <programo> issue
11:50:56 <besenwesen> step 1. ask GHCi for the type of an expression. step 2. ask GHCi to typecheck the expression with the type it just inferred. step 3. type error. ┻━┻ ︵ヽ(`Д´)ﾉ︵ ┻━┻`
11:51:00 <srhb> programo: By default a file with no module declaration is a Main module, which must have a main IO action
11:51:08 <glguy> programo: If you omit a module declaration you get a default one of "module Main (main) where"
11:51:15 <srhb> programo: ie main = print x, for instance
11:52:15 <Welkin> it's always a great feeling when you write a function and you know it will typecheck before you run it
11:52:19 <glguy>  ┬─┬﻿ ノ( ゜-゜ノ)  Maybe just pastebin the example and leave the tables unflipped!
11:52:20 <Welkin> then you run it and it typechecks
11:52:28 <Welkin> glguy: hahahaha
11:54:08 <Welkin> glguy: have you been saving that one for a while? :P
11:54:08 <srhb> It's not like this really needs a paste. :P
11:54:08 <programo> What can I do now  for my program to run?
11:54:08 <srhb> programo: Add a line with main = print x, for instance
11:54:08 <voidzero> hum, optparse-applicative is difficult to grasp
11:54:08 <programo> okay
11:54:08 <besenwesen> dunno, i’ve come to accept that with DataKinds, anything is possible. me not having a clue probably doesn’t help, but still, this is pretty weird
11:54:08 <glguy> programo: Running your Haskell program means executing the main value
11:54:45 <programo> @glguy thank you ! It worked
11:54:46 <lambdabot> Unknown command, try @list
11:54:59 <glguy> programo: In #haskell, @ is used for bot commands
11:55:40 <programo> okay glguy thanks for the information
11:57:11 <srhb> voidzero: Have you done applicative parsers before?
11:57:28 <srhb> voidzero: It's basically like building one of those and getting a command line program for free. :-)
11:57:37 <quazimodo> People, I'd like to ask this potentially off topic question here because I've found that haskelly people are more thoughtful about things than javascripty people
11:58:10 <quazimodo> I'm not sure if this applies in haskell programming, but Pub/Sub systems more and more are feeling to me like a glorified global variable that acts a lot like a stack
11:58:47 <quazimodo> well, perhaps not a stack, but a big global thing anyway that other things regularly check and see if any messages are left on it that they may be interested in
11:59:20 <voidzero> srhb, I have, but that was six long months ago, and now I got rusty
12:00:02 <glguy> felixn: You around?
12:01:01 <voidzero> srhb, It's probably smart to just grab my haskell books and give them another read first (which I've been telling myself for about 30 minutes now hehe)
12:01:19 <srhb> voidzero: Probably! If the examples aren't enough to get you going at least :)
12:02:40 <quazimodo> i guess i must be missing something
12:03:12 <geekosaur> quazimodo, in some sense they are. if the checkers are distributed across processes, there's not a lot that can be done about it even in Haskell. within a process you can still need them for thread communication, and Haskell even has them in various forms (e.g. Chan, TChan)
12:03:59 <geekosaur> ...although they can be more principled if the endpoint is passed around instead of being a global
12:04:01 <voidzero> Staring at ((+) <$> Just 3 <*> Just 5) helped somewhat.. I get that this will be similar with multiple Parser values
12:04:10 <quazimodo> geekosaur: I've been using pubsub to emit signals from widgets on a html page. But i'm feeling that this is less and less 'sensical'
12:04:16 <voidzero> foo <$> Parser a <*> Parser b
12:04:21 <voidzero> but I will stop hurting myself now.
12:05:04 <geekosaur> beyond that, I think organization at higher levels than processes is still very much a research topic, aside from specific environments (some HPC setups maybe)
12:05:47 <geekosaur> hm. there I think you're shading into FRP --- also rather active research
12:05:47 <quazimodo> geekosaur: at least, it looks to me like publishing is ok, as long as you publish on a namespace (which can be very much like encapsulation) and only a registrar may listen to signals and then call functions/methods on relevant objects
12:06:03 <geekosaur> so yes, but the proven alternatives are a bit thin on the ground
12:06:21 <quazimodo> No idea what FRP is
12:06:28 <geekosaur> functional reactive programming
12:06:46 <quazimodo> ie throwing lots of callbacks around?
12:07:12 <geekosaur> "yes it's a problem. no, nobody's figured out a good solution yet. wanna be a research subject?"
12:07:39 <quazimodo> geekosaur: think it makes sense that i'm viewing widgets on a html page as being concurrent actors ?
12:08:39 <haskellberry_pie> Hi, can you have tuples as indices in a Map? so (0,0)=>"A" for example?
12:08:40 <geekosaur> yes
12:09:11 <geekosaur> you might look at threepenny-gui as a functional reactive approach to that specific problem
12:09:36 <quazimodo> geekosaur: so If i imagine them as being people, then really there is a widget DOM, a tree of widgets... and it isn't making a lot of sense for each node in a widget DOM to be able to globally broadcast whatever it likes
12:09:40 <quazimodo> makes no sense at all
12:10:05 <quazimodo> each person in a group really ought not shout across the entire room, but jut tell the person managing the group what's going on
12:10:10 <geekosaur> (note I don't say "solution". I do say, again, that it's known and still an area of active research)
12:10:45 <geekosaur> well. yes and no. if all communications in a group have to go through a manager, things grind to a halt fairly quickly
12:10:49 <quazimodo> geekosaur: sure, i guess the situation is that my company is backend heavy on traditional web apps. Concurrency's a non issue so we don't end up having to synchronise actors
12:11:01 <quazimodo> i don't have anyone to bounce thoughts off of
12:12:27 <geekosaur> some things can be done point to point, some have to go through a manager/scheduler, some need to be announced; often which is which depends on the specific producer and consumer, and possibly on what else is going on.
12:12:50 <quazimodo> geekosaur: at the very least, I want to be able to scope my messaging
12:13:07 <haskellberry_pie> Hi, can you have tuples as indices in a Map? so (0,0)=>"A" for example?
12:13:21 <geekosaur> I think the general case is np-complete (i.e. don't expect a general solution). pub-sub at least lets you cover all the cases with one communication solution, which is why it gets used a lot
12:13:29 <mniip> edwardk / monochrom, so about the blog post thing, do you have an example of what it would look like?
12:14:02 <quazimodo> geekosaur: so really, I need to figure out how to use pubsub better
12:14:11 <geekosaur> at the moment at least
12:14:31 <geekosaur> like I said, active research area; there just aren't any nice solutions around as yet
12:14:32 <quazimodo> so that leads into another train of thought that I was experimenting with this morning
12:14:59 <geekosaur> (and more general than web pages. if you think about it, dbus is the same thing)
12:15:07 <haskellberry_pie> what is it that you are discussing?
12:15:08 <quazimodo> that's cool, just bouncing ideas anyway, exploring the space ( i didn't know until you mentioned that we don't really have a general solution )
12:15:25 <geekosaur> it's a poor solution but it's better than the other ones found so far
12:15:25 <quazimodo> geekosaur: i don't know dbus
12:15:32 <quazimodo> i'll look it up
12:15:38 <haskellberry_pie> Hi, can you have tuples as indices in a Map? so (0,0)=>"A" for example? What is that Map called then? Not IntMap
12:15:47 <geekosaur> dbus is what glues desktop environments (gnome, kde, xfce, etc.) together
12:15:57 <geekosaur> and it's essentially a pub-sub system
12:15:59 <exio4> haskellberry_pie: it's just a Map
12:16:04 <StoneToad> haskellberry_pie: the normal Data.Map is what you want
12:16:19 <quazimodo> geekosaur: oh yeah that thing
12:19:00 <haskellberry_pie> can I define a type as Map (Int, Int) String ?
12:19:50 <mniip> haskellberry_pie, of course, why not
12:20:24 <quazimodo> so imagine 10 actors, all identical ( and thus subscribed to the same exact channels ). If we emit a signal it calls an action that may or may not change the actor objects states. In my mind it looks like a morphism that takes all 10 from one state to some other state. But some times i want this to apply to a subset of the actors, taking say 4 of them from one state to another. And I have *no* idea how 
12:20:30 <quazimodo> this is done well
12:20:43 <luite> haskellberry_pie: it requires that (Int, Int) is an instance of Ord, which happens to be the case (for all pairs where both components are Ord)
12:21:24 * geekosaur needs to run away for a bit (~ 10-15 min)
12:21:26 <quazimodo> how does the publisher only cause some to change, particularly if no forethought was put into this needing to happen
12:22:04 <quazimodo> that's cool, I'm happy to read more about linuxy things (I want to take a 64 button MIDI controller pad and bind each button to a script)
12:29:08 <mniip> hmm
12:42:52 <breadmonster> Is there some list of types that can be marshaled across the Haskell-C border?
12:43:04 <breadmonster> Like, can I construct an object in Haskell and send it over to C for manipuation?
12:43:10 <Welkin> breadmonster: use the FFI
12:43:16 <breadmonster> How are Haskell constructors represented in C?
12:43:25 <breadmonster> Welkin: Yeah, I mean using the ffi.
12:44:05 <Welkin> https://hackage.haskell.org/package/base-4.8.1.0/docs/Foreign-Marshal.html
12:44:36 <Welkin> breadmonster: https://hackage.haskell.org/package/base-4.8.1.0/docs/Foreign-Storable.html#t:Storable
12:45:40 <Adeon> if you mean the types you can write to the foreign import line I don't know if there's a list
12:45:55 <breadmonster> Welkin: Okay, I have no idea how to declare my own instances.
12:45:59 <Adeon> but I know you can use Word32, Word64 and stuff
12:46:01 <breadmonster> scary stuff.
12:46:37 <Adeon> if you have a haskell data type you want to manipulate in C, create a structure on C side that's isomorphic to the one in haskell
12:46:39 <monochrom> The Haskell 2010 Report has it. section 8.4.2
12:46:45 <Adeon> the Storable instance marshals the haskell type to the C type
12:47:31 <Adeon> I think there's a project that does a lot of that work for you
12:59:26 <schell> Adeon: are you talking about bindings-DSL?
12:59:54 <schell> if so, i highly recommend it
13:02:04 <lingxiao> I have a "silly" syntax question
13:02:31 <lingxiao> say i declare a list of functions like [f1,f2] = g <$> [h1,h2]
13:02:49 <lingxiao> but I also want to name the list ... almost like  fs = [f1,f2] = g <$> [h1,h2]
13:03:04 <lingxiao> so I can use f1 and f2 later if I want, but also fold over the fs if necessary ...
13:03:09 <lingxiao> any way I can accomplish this?
13:03:19 <suppi> lingxiao, let expression maybe?
13:03:42 <lingxiao> so like fs = let [f1,f2] = ... ?
13:03:57 <glguy> xs@[x,y] = [1,2]
13:03:59 <glguy> works at the top level
13:04:06 <lingxiao> woa swee thanks!
13:05:19 <quazimodo> geekosaur: still afk?
13:10:39 <scshunt> how/when does stackage get the newest version of a package?
13:11:35 <geekosaur> back but busyish
13:17:53 <srhb> scshunt: Depends on the packageset.
13:19:07 <scshunt> srhb: nightly
13:19:12 <geekosaur> quazimodo, in any case, if you want to talk nuts and bolts you'll have to talk to someone else --- I don't do web programming, more basic infrastructure (which requires me to be a bit of a generalist)
13:21:51 <danilo2>  Hello! :) Is there in Haskell any library that works similar to C++ STD Vector? I mean - I want vectors that will give me O(1) access times and will automatically grow when I would like to insert new element.
13:22:49 <danilo2> Data.Vector is almost there - it doesn't allow to automatically grow the underlying container. I can create such functionality on top of VectorM by myself, but Im just looking for something ready if it is available somewhere :)
13:24:14 <Cale> danilo2: Such a datastructure is technically a lie (there's no way that a structure of arbitrary size can really offer O(1) access time to arbitrary elements, since as the structure grows, you eventually won't have enough time to read the address of the element)
13:24:44 <Adeon> the mutable Data.Vector.Mutable I think has grow
13:24:51 <Adeon> but it's mutable so it's used differently
13:24:57 <danilo2> Cale: of course. Im talking about growing vectors like in C++ with memory reallocation
13:25:02 <Adeon> you can freeze and thaw vectors so maybe want to read up on the module documentation
13:25:31 <Adeon> that is, turn them from mutable and immutable, sometimes in O(1) time with some unsafety
13:25:36 <danilo2> Adeon: it has grow, but doesn't provide us functionality that I want - namely it doesn't grow automatically when there is insufficient allocated space
13:25:52 <Cale> hmm
13:25:53 <Adeon> wouldn't that be literally just one utility function to write
13:26:14 <Welkin> yeah
13:26:19 <Welkin> you can write your own dynamic arrays
13:26:29 <Cale> Are you sure you're not just looking for Data.Map or Data.IntMap instead?
13:26:35 <danilo2> Adeon: probalby, or few. But you know, if everyone would write it, it is more practical to make a library out of it :) I'm asking just because if there is nothing like I want, I will make a library for it
13:27:48 <danilo2> Cale: no, I'm creating a graph. In the vector, there are elements and they point to other elements. It is crucial to have O(1) access times and I want to add and remove nodes from the graph. Sometimes we will need to grow the representation, but that will not be the often case
13:28:31 <breadmonster> How do you do CLIs in Haskell?
13:28:55 <danilo2> Cale: I know that standard graph implementations base on IntMaps / Patricia trees etc - but for this use case I want to be able to travel between nodes in O(1)
13:31:21 <Cale> danilo2: You can kind of think of the access time in an IntMap as O(1), since you have a very reasonable constant bound on how long it will take.
13:31:22 <Welkin> breadmonster: https://hackage.haskell.org/packages/#cat:User%20Interfaces
13:31:47 <Cale> danilo2: It's obviously a much worse number than following a single pointer
13:32:22 <breadmonster> Cale: Is it actually O(1)?
13:32:25 <Cale> yes
13:32:52 <breadmonster> Oh okay.
13:33:00 <Cale> breadmonster: There are only so many Ints, and so the size of an IntMap is bounded
13:34:10 <breadmonster> lol okay
13:35:28 <danilo2> Cale, hmm Of course, but it is much slower than accessing elms from Vector. I'm using it in the internal of a compiler and I the performance to traverse the graph is crucial. Because of that I will stick with ST Monad + MVector for it. from all the solutions above this will be the fastest one I suppose. 
13:39:35 <bros> Ahoy.
13:41:01 <gigabytes> hi guys
13:41:54 <nitrix> Just verifying, a unit type is like (), because it has only a single inhabitant, () ?
13:42:03 <gigabytes> yeah
13:42:16 <nitrix> Are there other examples (other than creating your owns) ?
13:42:43 <gigabytes> () -> ()
13:42:55 <gigabytes> I think
13:43:18 <gigabytes> the inhabitant can only be 'id'
13:43:49 <nitrix> I see.
13:43:53 <nitrix> Thanks.
13:44:22 <gigabytes> anybody here knows about Hakyll? The specific channel seems to be too quiet
13:46:03 <jbalint> how can i make a function? (a -> m b) -> (a -> b -> m c) -> a -> m c
13:46:10 <jbalint> I need the a param in both functions
13:47:29 <c_wraith> jbalint: that can be done if you put a Monad constraint on m
13:48:03 <jbalint> c_wraith: yeah it will be a monad class
13:48:12 <c_wraith> :t let foo f g x = do {y <- f x; g x y} in foo
13:48:13 <lambdabot> Monad m => (t1 -> m t) -> (t1 -> t -> m b) -> t1 -> m b
13:48:14 <jbalint> c_wraith: do I have to write it myself, or is there some clever way to do it?
13:48:45 <jbalint> c_wraith: thx
13:48:52 <c_wraith> I mean, you can certainly do something clever at it, but it's so simple I'd wonder why you want to replace simple with clever. :)
13:49:33 <jbalint> c_wraith: I guess I thought there might some operator that I could use :)
13:49:59 <c_wraith> jbalint: nothing that's going to be obvious to most readers.
13:50:16 <jbalint> c_wraith: alright
13:51:19 <schell> gigabytes: i know a little about hakyll
13:51:29 <schell> my blog is written with it: zyghost.com
13:52:05 <c_wraith> I mean..  \f g x -> f x >>= g x   ........   \f g -> liftA2 (>>=) f g
13:52:14 <c_wraith> Clever, sure.  Good?  No.  :)
13:52:31 <c_wraith> :t \f g -> liftA2 (>>=) f g
13:52:33 <lambdabot> (Monad m, Applicative f) => f (m a) -> f (a -> m b) -> f (m b)
13:52:52 <c_wraith> :t liftA2 (>>=)
13:52:53 <gigabytes> schell: I've troubles making tags and categories
13:52:54 <lambdabot> (Monad m, Applicative f) => f (m a) -> f (a -> m b) -> f (m b)
13:53:05 <schell> ahh - i haven’t done that yet
13:53:23 <schell> gigabytes: have you read through the tutorials already?
13:53:28 <gigabytes> schell: yes
13:53:31 <gigabytes> it seems to be easy
13:53:47 <c_wraith> jbalint: yeah, it's liftA2 (>>=) when the Applicative instance you're using is ((->) a)
13:53:57 <c_wraith> jbalint: but really, that's not simpler or easier to read.
13:53:57 <gigabytes> but the pages that are created by tagsRoutes all contain all the posts instead of only the posts of the specific tag/category
13:54:32 <schell> hmmm, i’m not sure i can help since i’ve never implemented tags or categories
13:54:45 <gigabytes> no problem :)
13:55:00 <Cale> danilo2: Yeah, you might want to try building something around MVector. I've often been pleasantly surprised by how reasonably fast IntMap and even Map are in the past though. Often I'll write my algorithm using one of those and see how it performs before trying anything fancier, and except in cases where the data structure was pretty much unreasonably large (image data), the performance has been good enough.
13:55:06 <schell> but i got a lot out of reading other people’s sites
13:55:08 <jbalint> c_wraith: yeah, i'll play around with it some, thx
13:55:21 <schell> for instance, the author’s: https://github.com/jaspervdj/jaspervdj/blob/master/src/Main.hs
13:55:33 <Cale> danilo2: Obviously there are cases where it won't be though!
13:55:41 <gigabytes> schell: I'll try to read it
13:55:48 <schell> gigabytes: he’s got tags on line 49 - maybe that will help?
13:57:23 <fryguybob> breadmonster: Were you asking how STM works yesterday?
13:57:53 <gigabytes> schell: hm maybe
13:58:42 <peti> Hi, I wonder how other people ensure that their Cabal files have a uniq'ish version number that can be traced back to a Git commit with some accuracy?
13:58:56 <bernalex> .
13:58:59 <bernalex> ops
13:59:12 <peti> Personally, I generate my Cabal file with the Cartel library, so I can include that information at the time the Cabal is produced.
13:59:14 <Cale> peti: I think git has a feature to tag particular commits
13:59:46 <peti> I am, however, unhappy with that solution, because there's no easy way to determine when the Cabal file needs re-generation.
14:00:09 <peti> Cale: You mean "git tag"?
14:00:35 <Cale> peti: yeah
14:00:40 <Hafydd> guten tag
14:02:02 <Cale> I mostly write Cabal files by hand, so I haven't really ever thought about how you'd automate that though.
14:02:27 <peti> Cale: Well, git tag allows me to attach the version number from my Cabal file to a git commmit. I want it the other way round, though: I want my cabal file to identify the Git commit it belongs to, i.e. by setting my version number to something like "git describe --tags".
14:02:45 <kadoban> It has seemed kinda … not great to me that I end up having to change the version in like 3 places (--version, .cabal file, and a git tag), but hasn't annoyed me enough to think something up
14:02:48 <arkeet> that sounds difficult.
14:03:03 <gigabytes> schell: is it true that mappend on Context values prefers the leftmost operand if field names clashes?
14:03:17 <serendependy> Is it possible to make a local type alias (e.g. in a where-clause)?
14:03:25 <arkeet> how do you know the commit hash to put in the .cabal file before you commit
14:03:31 <nkaretnikov> serendependy: no
14:03:53 <serendependy> nkaretnikov, drat. Thanks
14:04:06 <gigabytes> schell: I mean, if I do (constField "something" "42" <> constField "something" "0"), the field should contain "42", right?
14:04:35 <peti> arkeet: You don't necessarily need the hash. It's good enough to count the number of commits since the last tag. git describe works this way.
14:04:45 <nkaretnikov> serendependy: you can define it in a separate module and import it qualified
14:04:55 <arkeet> if you don't branch at all maybe.
14:05:00 <peti> arkeet: My version number would be x.y.i where "i" is incremented every time I commit.
14:05:29 <serendependy> nkaretnikov, Too much effort, I was just experimenting with something for development.
14:05:48 <serendependy> Wanted to see if I could get better type information in holes
14:06:41 <danilo2> Cale: hank you very much for this conversation :)
14:08:50 * Welkin throws bread crumbs at bread_pigeon 
14:09:21 <Welkin> breadmonster evolved into a... pigeon?
14:09:22 <quazimodo> geekosaur: is all good, thanks for the chat :)
14:15:17 <Fylwind> does min-ghc provide a means to install GHC through a batch script?
14:25:31 <adarqui> classy-prelude is cool
14:28:55 <xpilot> hello
14:29:00 <hexagoxel> is there an overview of alternative preludes somewhere?
14:29:12 <mpickering> Does anyone have a link for "Freer Monads, More Extensible Effects" by Oleg?
14:29:24 <xpilot> question about gadts: are they allowed to have polykinded type variables?
14:29:52 <mpickering> yes
14:30:01 <xpilot> the following in particular is failing for me: data Thing (t :: k) where IntThing :: Thing Int
14:30:14 <mpickering> what is the error message?
14:30:33 <ralu> why would be mapM_ 3 times faster compared to mapM
14:30:43 <xpilot> @mpickering kind mismatch
14:30:43 <lambdabot> Unknown command, try @list
14:31:01 <xpilot> mpickering: kind mismatch between 'k1' and '*'
14:31:03 <arkeet> well
14:31:07 <c_wraith> ralu: because mapM needs to keep the results around, which means constructing a list to hold them, and keeping that list in memory.  mapM_ gets to skip all that
14:31:25 <ralu> of course
14:31:26 <hexagoxel> also, there is no good way to improve a "common qualified imports" situation, is there? like have `Data.Map` as `M` without adding it in every module?
14:31:40 <arkeet> hexagoxel: unfortunately no
14:31:53 <arkeet> unless you want to use CPP #include or something
14:32:37 <xpilot> mpickering: namely Int has kind * but should have kind k1
14:32:55 <arkeet> well, you're saying that Thing can take a type of arbitrary kind
14:33:07 <arkeet> but then saying one of its constructors sets t = Int, which has kind *
14:33:20 <mpickering> which version of GHC are you using? I get a different error anyway
14:33:31 <xpilot> I am on 7.8.4
14:33:53 <mpickering> https://www.irccloud.com/pastebin/2WHo9ON5/
14:34:14 <Sindriav_> What's the best container for a modifiable 2D array?
14:34:16 <mpickering> That is the error on 7.10.2 which might be clearer?
14:34:35 <Sindriav_> specifically [[Word8]], even
14:34:55 <xpilot> mpickering: well I suspect that what I want to do just can't be done
14:35:08 <arkeet> what is it that you want to do?
14:35:09 <mpickering> what do you want to do
14:36:44 <xpilot> arkeet mpickering: literally just the Thing GADT, except with more cases. Ultimately my hope was to model higher-kinded types
14:36:49 <mpickering> although I think that error message is a bit cryptic still, maybe it could be improved again
14:38:05 <xpilot> mpickering: I might be able to get away with typeclasses, but it makes my code messier
14:38:29 <mpickering> if you remove the kind signature your current examples compiles so where do you run into the problem?
14:38:58 <xpilot> well I'd like to have a ListThing :: Thing [] case
14:41:19 <xpilot> if I have both that and IntThing, then t tries to get assigned kind * and *->* which fails
14:41:31 <rbocquet> xpilot: it will be possible with ghc 7.12 (or 8.0) : https://typesandkinds.wordpress.com/tag/haskell-2/
14:42:44 <bgamari> nh2, you vector-fftw is now on stackage
14:42:55 <xpilot> rbocquet: cool
14:44:17 <gigabytes> guys, is there a function that puts a single element into a list?
14:44:23 <gigabytes> since I cannot partially apply [+
14:44:24 <gigabytes> []
14:44:26 <StoneToad> into
14:44:28 <StoneToad> ?
14:44:38 <StoneToad> x : xs prepends to the list
14:44:57 <gigabytes> yes, I mean \x -> x:[]
14:45:01 <StoneToad> appending to lists is a Bad Idea(tm)
14:45:07 <srhb> gigabytes: Why can't you?
14:45:09 <srhb> > [] 2
14:45:11 <lambdabot>      Couldn't match expected type ‘Integer -> t’ with actual type ‘[t0]’
14:45:12 <lambdabot>      The function ‘[]’ is applied to one argument,
14:45:12 <lambdabot>      but its type ‘[t0]’ has none
14:45:16 <srhb> Oh, right.
14:45:21 <gigabytes> srhb: eheh
14:45:38 <mpickering> > (:[]) 2
14:45:40 <lambdabot>  [2]
14:45:46 <agocorona> > return 2 :: [Int]
14:45:48 <lambdabot>  [2]
14:46:04 <gigabytes> return 2, yes, but I need the inference to work right, it's not so readable
14:46:05 <StoneToad> singleton should also work
14:46:12 <gigabytes> yeeeeh singleton
14:46:27 <mpickering> everytime I write (:[]) I die a little inside to be honest 
14:46:31 <StoneToad> lol
14:46:58 <kadoban> What's wrong with 'pure' or 'return' ?
14:47:10 <gigabytes> kadoban: nothing, but I feel it's not so readable
14:47:28 <gigabytes> but it will do
14:47:42 <kadoban> In context I usually don't mind it, though I guess it depends.
14:48:36 <nh2> bgamari: excellent, now I can work on getting my package in
14:48:39 <mpickering> I tend to agree with the thought that more polymorphic is less readable, it has also bitten me when a different instance is picked than the one I expect
14:48:56 <mpickering> as with everything a balance is necessary
14:49:38 * hackagebot hops 0.0.1 - Hackable Operations on Power Series  https://hackage.haskell.org/package/hops-0.0.1 (AndersClaesson)
14:49:46 <kadoban> Ya it can give enough freedom to get some bizarre errors sometimes I suppose, but only if the code is already incorrect.
14:59:10 <rm-r> haskell is a logic language too
14:59:11 <rm-r> ?
14:59:38 * hackagebot opaleye-classy 0.3.0.0 - Opaleye wrapped up in classy MTL attire.  https://hackage.haskell.org/package/opaleye-classy-0.3.0.0 (BenKolera)
15:00:58 <geekosaur> not in the sense of e.g. prolog, no. you might be interested in curry, a logic language inspired by haskell
15:02:02 <rm-r> but haskell
15:02:04 <rm-r> is a bit logic too
15:02:05 <rm-r> ?
15:02:15 <jeltsch> Curry is a functional–logic language, not just a logic language.
15:02:53 <rm-r> yeah okay
15:02:59 <rm-r> but haskell is logic too a little bit ?
15:03:00 <jeltsch> So it covers functional programming and logic programming, but more, which comes from the interaction between both paradigms.
15:03:14 <jeltsch> rm-r: In what sense?
15:03:41 <kadoban> rm-r: "logic language" has a much more exact meaning than you're probably assuming it does. It's like "functional", it doesn't just mean what it means in plain english.
15:03:45 <Cale> rm-r: You can use libraries in Haskell to do some things which approximate logic programming a bit.
15:04:25 <Cale> rm-r: and you can also abuse the type class system to effectively do logic programming, but this isn't really the most sensible way to use the language
15:05:20 <rm-r> okay
15:05:24 <rm-r> thanks for answers
15:05:28 <Cale> rm-r: For an example of the first thing, just using the list monad instance is kind of like logic programming to some extent.
15:05:46 <jeltsch> rm-r: The thing with the type class system would be logic programming *at the type level* and thus at compile time!
15:05:48 <Cale> rm-r: There are some libraries on Hackage, like logict which give you some more relevant operations.
15:06:15 <Cale> and cflp which is yet more sophisticated (but I haven't tried that one)
15:06:45 <jeltsch> Cale: The list monad thing is not really logic programming. Essential for logic programming is the ability to derive instances for free variables.
15:06:48 <bros> I like to build web apps and I want to learn Haskell, but it seems like the two do not mix well together at all.
15:07:34 <bros> I like to play with APIs, move data in and out of databases, play with WebSockets/Redis, etc. I was reading http://slpopejoy.github.io/posts/Effectful01.html and I couldn't even follow along :/
15:07:59 <Cale> jeltsch: Well, you get to bind variables nondeterministically, and then constrain the outcomes, which is kind of like 3/4 of the way there, or something.
15:08:07 <kadoban> bros: Really? What makes you say that? Haskell is actually surprisingly great for the web.
15:08:11 <abg> Hello. For stack, is there a way to get it to always build docs for everything it builds? Something equivalent to putting 'documentation: True' in cabal.config?
15:08:34 <kadoban> bros: That doesn't look like beginner material. Learn haskell from the start and you'll do better. https://github.com/bitemyapp/learnhaskell is a nice guide
15:08:47 <Cale> At some point I'm going to have to actually try using stack just so that I can help out with all these questions about it :)
15:09:10 <bros> kadoban: I guess there is just this huge learning curve.
15:09:15 <jeltsch> rm-r: Some time ago, I wrote an introductory blog article about functional logic programming in Curry. Maybe you want to have a look. It’s here: https://jeltsch.wordpress.com/2013/04/27/a-taste-of-curry/
15:09:42 <Cale> bros: Yeah, the learning curve for Haskell is a bit like learning programming from the beginning.
15:09:49 <Cale> bros: (at least for most people)
15:09:55 <kadoban> bros: Haskell is a much different language from those that you probably know, so the learning curve might be more than you're used to.
15:10:01 <bros> There has to be a better way to learn Haskell than following a course that doesn't get to IO until the 8th week :/
15:10:31 <srhb> IO isn't that big a problem, but I would still accept the metaphor and say "no, it really is the best way" :P
15:10:47 <kadoban> bros: If you find one, let us know.
15:10:58 <srhb> bros: It's totally worth it though. :-)
15:11:00 <Cale> You can certainly learn to use IO earlier, but there are good reasons to put it off until a little later.
15:11:19 <Cale> You can use the GHCi repl as a kind of user interface for the programs you write early on
15:11:50 <Cale> So you can actually do quite a lot without learning how I/O works.
15:13:36 <Cale> But yeah, at some point you're going to want to write programs that actually do useful stuff. I/O in Haskell is expressed by constructing values called IO actions, and the 'main' of your program is going to be one of those IO action values. It's good to have a handle on the basics of the language before starting to learn to glue IO actions together, but eh, there are lots of reasonable orders in which to learn things.
15:13:48 <monochrom> bros: "learn haskell" and "dive-in project" do not mix well. for most people.
15:15:11 <monochrom> my analogy is "I want to learn Korean by watching a Korean movie and writing a movie review in Korean. My native tongue is American English and last time my approach worked well when learning South African English. I did Chappie."
15:15:28 <monochrom> not going to fly
15:15:30 <glendc> hehe :D
15:15:48 <exio4> monochrom: may I steal your analogy? 
15:15:49 <glendc> South African Enlgish, didn't know that was a different kind of English
15:16:03 <bros> I just read the homework for the first lesson of cis194. Yikes.
15:16:05 <monochrom> lastly, "web app" is merely a special case of "dive-in project"
15:16:10 <bros> Never knew I was so dumb.
15:16:22 <monochrom> yes exio4. more people need to understand this.
15:16:28 <Cale> In particular, IO is a monad, and a fair number of the control structures and such that you'll use to build IO actions are generalised to an arbitrary choice of monad (which saves code in the long run because they can be shared with libraries having nothing to do with IO), but this means that you kind of need a handle on how type classes work in order to understand the types of the operations for gluing IO actions toge
15:16:28 <Cale> ther.
15:16:50 <glendc> bros: fact about knowledge, the more you have it, the less you know :(
15:17:11 <Cale> You can mostly ignore it, and just say "oh, if I see something with type   (Monad m) => ... m ...  that just means I can replace m with IO and it'll work
15:17:21 <srhb> bros: It's not being dumb, it's being exposed to something almost but not entirely different to what you're used to! :-)
15:17:42 <mpickering> and people in this channel will be happy to answer *any* specific questions you have
15:18:13 <geekosaur> bros: haskell is a *lot* different
15:18:15 <Cale> bros: Yeah, feel free to ask lots of questions as you go. It can be a humbling experience learning functional programming, but it's one that we've all been through :)
15:18:50 <bros> I just don't see the benefits :/ Why start all over with something so complex?
15:18:57 <geekosaur> when I learned it, I already had exposure to quite a few programming languages, including SML which is syntactically similar and also a functional programming language (but not lazy or pure)
15:19:07 <geekosaur> it still took me a year or so to become comfortable enough to use it
15:19:27 <Cale> bros: There are a lot of benefits in terms of how easy it is to maintain and extend the resulting software, and what opportunities you have to decompose problems into smaller parts.
15:19:52 <bros> Cale: how is that any different than programming imperatively but in small components?
15:20:09 <monochrom> bros, Haskell is not complex, it is just different.
15:20:28 <monochrom> no one really questions "since learning Korean is so hard, why should I learn Korean?"
15:20:56 <monochrom> and no one really answers "I agree, Korean is useless, learn Chinese"
15:21:28 <monochrom> "it is just different" means that you have to start from baby steps again, yes.
15:21:38 <Cale> bros: The type system in Haskell in particular is especially great once you get to know it. I've done refactorings which involved changing the basic data structures that were in use in a library which was around 8k lines of code, and I made the change to the data structure that I wanted, and then started running the compiler over it and fixing what it told me to fix, and in the end when I was done, our game actually st
15:21:38 <Cale> ill worked on the first run :)
15:21:51 <monochrom> exactly the same baby steps you take to learn Korean or Chinese
15:22:02 <Cale> It's not *always* the case that if it compiles, it works, but it's true an almost unreasonably large portion of the time.
15:22:13 <d-snp> bros: I didn't think spopejoy's tutorial was very good at all for beginners
15:22:18 <monochrom> in fact Korean is already easy on you, it's still alphabetical. Chinese is not even that.
15:22:46 <d-snp> and doing webdev in Haskell is pretty nice, you don't need to have much knowledge of the theoretic underpinnings of haskell to be productive in it I think
15:22:47 <monochrom> so, baby steps, no dive-in project.
15:22:55 <monochrom> as for the benefit, ask edwardk.
15:23:04 <edwardk> ?
15:23:26 <Cale> I have to go to dinner, but I can talk more about this later if everyone else hasn't already talked your ear off by then :D
15:23:30 <d-snp> edwardk's life has been blessed since he learned category theory ;)
15:23:35 <edwardk> pretty much
15:23:41 <jeltsch> bros: Regarding the advanced composition possibilities of functional programming compared to imperative programming, you might want to have a look at the old, but still relevant article “Why Functional Programming Matters”: http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
15:24:00 <monochrom> edwardk, you have a quora article on why you switch to Haskell and will not look back, right?
15:24:04 <edwardk> funny thing is only learned category theory because i just assumed all the Haskellers were deep category theory wizards
15:24:14 <monochrom> heh
15:24:38 <edwardk> monochrom: https://www.quora.com/Reviews-of-Haskell-programming-language/review/Edward-Kmett?share=1
15:24:43 <bros> Cale: have a good time! :)
15:24:50 <monochrom> I need to bookmark this
15:25:06 <Welkin> edwardk: the old ?share=1 trick
15:25:10 <edwardk> yep
15:25:47 <rm-r> thanks all, im going, goodnight
15:25:49 <d-snp> bros: for a university class I made a Go (the board game) implementation in pure Haskell, I then used that pure code as a library for a simple web application
15:26:04 <monochrom> oh and also http://www.slideshare.net/ScottWlaschin/fp-patterns-buildstufflt
15:26:33 <d-snp> https://github.com/tinco/Ergo <-- all the pure code is in the 'ergo' directory, and the 'scotty.hs' file is the webapp
15:26:35 <bros> d-snp: like you had to write utility functions that you reused?
15:27:25 <edwardk> also despite the funny title phrasing: http://nsr.oxfordjournals.org/content/early/2015/08/24/nsr.nwv042.full  -- "How functional programming mattered" by Hu, Hughes and Wang gives a nice update to the "Why FP Matters" paper
15:27:44 <d-snp> you mean for the course? this was the final project of the course so we could use the standard library, but yeah during the course we had to implement the utility functions
15:31:49 <Welkin> lol what https://gist.github.com/quchen/5280339
15:36:28 <nerfpops> pretty amazing how that xquasar guy turns from troll to curious
15:36:46 <quchen> He hasn't showed up afterwards though. :-(
15:38:26 <monochrom> the experiment failed. the null hypothesis "not worth the time" still holds.
15:39:55 <lolisa> can anyone give context about what the exp is? I have no idea
15:40:33 <Welkin> expression? exponent?
15:40:46 <lolisa> experiment...
15:40:47 <neuroserpens> I'm curious to know what that is too
15:41:02 <Welkin> neuroserpens: you just joined!
15:41:11 <neuroserpens> Welkin: lol
15:41:20 <lolisa> Read the log, it's right before you join lol
15:41:27 <neuroserpens> xD
15:47:43 <glendc> how do you define a function / variable in the ghci repl? When I want to start with the type decleration it just says undefined :/
15:47:55 <rpfun> glendc: let var = val
15:48:09 <glendc> but for a function that would become lengthy no?
15:48:23 <monochrom> let f n = n + f n
15:48:53 <monochrom> a multi-line example: let {f 0 = 0 ; f n = n + f n}
15:49:06 <glendc> oh so you can't do it in the way where you first specify the signature and than the function?
15:49:10 <glendc> (without doing it in a file)
15:49:32 <Welkin> :{ multi-line :}
15:49:32 <scshunt> let { f :: Int -> Int -> Int; f = (+)
15:49:36 <monochrom> can. let {f :: Integer -> Integer ; f 0 = 0 ; f n = n + f n}
15:49:39 <scshunt> * }$
15:49:56 <glendc> oooh I see
15:50:05 <Welkin> you are better off writing your functions in a file and loading it into ghci using :load
15:50:37 <monochrom> be warned that entering code into a repl does not scale.
15:50:43 <glendc> I can imagine so
15:50:49 <monochrom> any repl
15:54:02 <srhb> glendc, scshunt: The brace isn't technically necessary
15:54:07 <rpfun> i have a type "data A = A B C", and a function "f :: B -> C -> (D -> E)" (essentially f :: A -> (D -> E)). if i know that the function "D -> E" generated from "f" will be used frequently, is it conventional to define a "cached" version of of A, so modify "data A = A B C | A' B C (D -> E)"? I ask because i hope there is a more elegant solution
16:04:05 <mniip> rpfun, just use A', get rid of A
16:04:24 <mniip> laziness will manage the caching
16:05:48 <ttt_fff> I know parsec.
16:05:56 <ttt_fff> I need to parse exps consisting of binaryOps with precedence.
16:06:00 <mniip> do you
16:06:06 <ttt_fff> Is there a good library for this? (or should I just hack it up in parsec).
16:06:11 <ttt_fff> mniip: Yes, I do know Parsec.
16:06:36 <arkeet> https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Expr.html
16:06:59 <joobus> noob question:  I'm working through yorgey's course as recommended by bytemyapp.  I'm trying to do something like: map (read::String->Int) "1234"
16:07:18 <arkeet> joobus: what is it supposed to do?
16:07:35 <joobus> parse each number into a list.  so [1,2,3,4]
16:07:36 <erikd> > map (read :: Int) "1231"
16:07:37 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘String -> a0’
16:07:37 <lambdabot>      Probable cause: ‘read’ is applied to too few arguments
16:07:37 <lambdabot>      In the first argument of ‘map’, namely ‘(read :: Int)’
16:07:43 <arkeet> > map digitToInt "1234"
16:07:45 <lambdabot>  [1,2,3,4]
16:07:51 <erikd> > map (\x -> read x :: Int) "1231"
16:07:52 <ttt_fff> "1234" becomes [Char]
16:07:53 <lambdabot>      Couldn't match type ‘Char’ with ‘[Char]’
16:07:53 <lambdabot>      Expected type: [String]
16:07:53 <lambdabot>        Actual type: [Char]
16:07:53 <arkeet> you want Char -> Int, not String -> Int
16:08:00 <ttt_fff> so the read would have input Char, nto String
16:08:11 <mniip> :t read . return
16:08:12 <arkeet> for "1234" :: [Char], so if you want map f :: [Char] -> [Int], f had better have type Char -> Int
16:08:13 <lambdabot> Read c => Char -> c
16:08:15 <ttt_fff> what arkeet said
16:08:45 <ph88> hey guys im tyring to compile this hello world https://github.com/haskell/win32/blob/master/examples/hello.lhs  and im getting this error while building http://pastebin.com/8UxB021q
16:09:13 <mniip> > map (read . return :: String -> Int) "1234"
16:09:15 <lambdabot>      Couldn't match type ‘[Char]’ with ‘Char’
16:09:15 <lambdabot>      Expected type: String -> String
16:09:15 <lambdabot>        Actual type: Char -> [Char]
16:09:45 <mniip> > map (read . return :: Char -> Int) "1234"
16:09:46 <arkeet> ph88: Perhaps you need to add `Win32' to the build-depends in your .cabal file.
16:09:47 <lambdabot>  [1,2,3,4]
16:09:56 <ph88> arkeet: how do i do that ?
16:09:58 <joobus> i thought in haskell "String" was just a [Char]
16:10:04 <arkeet> well
16:10:23 <arkeet> you open your .cabal file
16:10:24 <arkeet> and add it
16:10:27 <ph88> oh ok
16:10:29 <mniip> joobus, that's correct and irrelevant
16:10:49 <ph88> build-depends:       base >=4.8 && <4.9
16:10:52 <joobus> if I'm mapping over string, should each argument be a Char then?
16:10:59 <ph88> there is already something there
16:11:22 <mniip> joobus, yes
16:11:34 <arkeet> ph88: well, the example doesn't even come with a cabal file.
16:11:38 <arkeet> it gives you a makefile.
16:11:50 <arkeet> where did this .cabal file come from?
16:11:58 <ph88> i made it myself
16:12:02 <ph88> with cabal init sandbox
16:12:37 <arkeet> well, add Win32 to the build-depends list then.
16:12:56 <ph88> ye it worked thx
16:13:01 <ph88> i need to use a command
16:13:03 <ph88> seperated
16:14:22 <ph88> arkeet: do you know about this error?     src\Main.hs:101:3:     parse error in let binding: missing required 'in'
16:14:49 * hackagebot MFlow 0.4.5.11 - stateful, RESTful web framework  https://hackage.haskell.org/package/MFlow-0.4.5.11 (AlbertoCorona)
16:15:07 <ph88> arkeet: this is the file http://pastebin.com/prnmJLBD
16:15:30 <arkeet> your indentation is incorrect.
16:15:48 <arkeet> in the do block.
16:17:00 <ph88> the original file mix tabs with spaces
16:17:23 <ph88> whats recommended for haskell, tabs or spaces ?
16:18:12 <mniip> pagefeeds
16:18:31 <joobus> still kinda confused.  If I do let x = "1234"::[Char] in ghci, it will say it is a [Char] if I type :t x
16:18:51 <arkeet> correct.
16:18:54 <joobus> so why wouldn't  map (read::Char->Int) x  work?
16:18:55 <mniip> joobus, correct
16:18:59 <arkeet> because read doesn't have that type.
16:19:02 <mniip> :t read
16:19:03 <lambdabot> Read a => String -> a
16:19:10 <joobus> ah, ok
16:19:12 <arkeet> :t digitToInt
16:19:13 <lambdabot> Char -> Int
16:19:21 <mniip> String /~ Char
16:19:27 <kadoban> :t read . (:[])
16:19:29 <lambdabot> Read c => Char -> c
16:19:43 <arkeet> @quote \(:\[
16:19:43 <lambdabot> dcoutts says: (:[]) looks like a monster
16:19:48 <arkeet> @quote \(:\[\{
16:19:48 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
16:20:53 <joobus> is there a way to only import certain functions in ghci from a module?  I tried :module +Data.Char (digitToInt)  but it didn't like that
16:21:06 <dmwit> ghci knows normal import syntax
16:21:11 <dmwit> import Data.Char (digitToInt)
16:21:18 <joobus> ok, thanks guys
16:21:31 <dmwit> ...provided it's new enough (I think 7.8 or newer?)
16:21:56 <ReinH> Is anyone here going to ICFP?
16:22:07 <dmwit> ph88: Most people recommend only spaces. For my take, you could consider my musings at http://dmwit.com/tabs
16:22:12 <ph88> arkeet: i think its missing "in"  because i fixed the indent
16:22:36 <ph88> dmwit: do you think 2 spaces is ok ?
16:22:57 <dmwit> I think it is an aesthetic choice and that there's no need to argue about it much.
16:24:10 <codehero> how do i "touch" a file in haskell?
16:24:29 <ReinH> dmwit: I think that's the only reasonable way to use tabs with whitespace-aware languages that I've ever seen, but it doesn't seem worth the effort imo.
16:24:49 <ReinH> the main non-aesthetic issue being editor support
16:24:55 <dmwit> right
16:24:56 <ReinH> but it's totally not worth arguing about
16:25:14 <MorpheusB> codehero: touch [filename] on linux, or open and close with editor
16:25:30 <dmwit> MorpheusB: Those solutions don't seem to fit the "in Haskell" part of the question. ;-)
16:25:47 <ReinH> dmwit: my tab key is already overloaded enough as it is. I'm pretty sure there are like 5 levels of indirection involved.
16:26:08 <dmwit> codehero: I suppose the simplest analog would be to open it in ReadMode and immediately close it; on the exception you get for having no file, open it write mode.
16:26:14 <ph88> anyone an idea how to fix this? i tried to fix the indentation  http://pastebin.com/NwawWe8g   src\Main.hs:101:3:     parse error in let binding: missing required 'in'
16:26:28 <MorpheusB> dmwit: correct, I gues open and close file or do system call to touch
16:26:33 <dmwit> ph88: The lines of your do block must be indented more than "pump" is.
16:26:35 <srhb> codehero: https://hackage.haskell.org/package/unix-2.4.1.0/docs/System-Posix-Files.html#12
16:26:39 <srhb> If you've got POSIX.
16:26:43 <codehero> dmwit: okay, so writeFile should create it automatically?
16:26:48 <ReinH> ph88: try to include a minimal example *with* the complete error message
16:27:04 <dmwit> codehero: Well, writeFile will open it write-mode, which will create a file if there isn't one, yes.
16:27:09 <codehero> okay
16:27:11 <dmwit> codehero: Though it won't create any necessary directory structure.
16:27:22 <ReinH> ph88: We shouldn't have to scan 100+ lines of code to find the one in question, and you didn't even include a compiler error with a line number to help us
16:27:23 <codehero> ah. yeah. that's probably the problem
16:27:26 <codehero> some missing dir
16:27:32 <dmwit> codehero: It will also overwrite the contents of the file, which touch does not do.
16:28:12 <dmwit> ReinH: The problem is on lines 108-112 if you care. =)
16:28:17 <ph88> dmwit: pump stuff start on line 105 ... why is the error message about 101 ?
16:28:34 <ReinH> dmwit: I do. I am just suggesting that people would get more help faster if they made it easier to help them. :)
16:28:45 <geekosaur> "touch" does two not quite related things: open/close to create if needed, and/or exercise utime() aka System.Posix.Files.setFileTimes (or touchFile in the same module). note that the file would be opened O_RDWR|O_CREAT
16:29:16 <dmwit> Oh, yeah, opening it ReadMode wouldn't change the modification time.
16:29:18 * dmwit is a bit rusty
16:29:35 <ReinH> ph88: well, lines 89-00 look wrong too
16:29:37 <dmwit> ph88: There may be other errors.
16:29:56 <dmwit> ReinH: Really?
16:30:14 <dmwit> ReinH: Just by eye, that looks okay to me. What looks bad to you?
16:30:33 <ph88> ReinH: the compiler error was after the pastebin ... it's an hello world script from here    https://github.com/haskell/win32/blob/master/examples/hello.lhs
16:30:51 <ReinH> dmwit: shouldn't arguments to createWindow be indented past it?
16:31:01 <dmwit> Nah.
16:31:16 <ReinH> orly?
16:31:18 <dmwit> Just past the block level, which is two spaces there.
16:31:28 <ReinH> And yet there's an error on line 101
16:32:09 <dmwit> FWIW I don't get a parse error at all.
16:32:16 * ReinH shrugs
16:32:56 <dmwit> (Perhaps chasing down modules happens before parsing is finished...? Seems surprising if so.)
16:33:34 <geekosaur> afaik only if TH is involved
16:33:49 <ReinH> dmwit: I will never cease to be amazed at the code styles some people come up with :)
16:34:13 <dmwit> Seems that's the case. When I make dummy modules I do get the parse error.
16:34:20 <dmwit> But on line 107, not 101.
16:34:45 <dmwit> And making the change I suggested gets it to parse (though obviously not work properly since I have dummy modules).
16:34:51 <ReinH> They seem to range from people who wish Haskell were a lisp (like chrisdone) to people who wish Haskell were a C (like SPJ, heh)
16:35:35 <ReinH> and I'm sure many points outside of this spectrum
16:36:06 <dmwit> srhb++ for touchFile
16:36:24 <srhb> Hooray, I was mutated.
16:36:57 <ReinH> srhb: are you playing nethack?
16:37:13 <srhb> ReinH: I really hope this is just an elaborate nethack. :-)
16:37:22 <ReinH> it could be
16:37:51 <ReinH> actually I've been playing a lot of dungeon crawl stone soup lately so mutations are very much on my mind ;)
16:38:14 <srhb> ReinH: I'll have to look it up :P
16:38:15 <d-snp> hey edwardk I'd love to see a usesthis.com interview with you :)
16:38:35 <ReinH> srhb: it's a very fun roguelike http://crawl.develz.org/wordpress/
16:38:41 <srhb> ReinH: Thanks!
16:38:44 * geekosaur was gonna say, the overlaps between here and ##crawl are such that dcss is rather more likely than nethack :)
16:38:47 <ReinH> d-snp: vim and category theory, next question ;)
16:38:56 <edwardk> d-snp: heh
16:39:00 <ReinH> geekosaur: :)
16:39:04 <edwardk> i don't use many tools
16:39:21 <ReinH> edwardk: o/ I am talking to you from a train
16:39:33 <ReinH> A train to ICFP!!!
16:40:23 <ReinH> geekosaur: do you play dcss?
16:40:52 <geekosaur> sometimes. not a lot of late; too much else going on. but I do the official OS X release builds for them
16:41:06 <ReinH> srhb: suggest playing a minotaur fighter and bashing things, it's super fun. Also the wiki is extensive and helpful. I apologize if I just stole all your productivity for the next week or so...
16:41:22 <ReinH> geekosaur: oh! awesome. I was thinking about trunk builds
16:41:25 <srhb> ReinH: It was at zero already. :-)
16:41:41 <ReinH> I play trunk on web and I tried the windows builds via wine but an os x build would be ace
16:41:50 <geekosaur> and keep a trunk linux build reasonably up to date even if I haven't had much time to play in the past month :/
16:42:09 <ReinH> geekosaur: I have a lot of experience with build automation. Maybe I can help?
16:45:11 <mauris_> (wow yes, what is it about the #haskell and ##crawl overlap)
16:45:59 <d-snp> edwardk: no vim plugins, preferred brand of laptop/desktop and operating system, automatic build system, etc? :P
16:46:35 <ReinH> geekosaur: my level 26 gargoyle fighter is prepping for his orb run :)
16:47:04 <ReinH> might be my first ascension if I play it right...
16:47:47 * geekosaur will consider it at some point
16:48:14 <edwardk> My entire .vimrc https://www.irccloud.com/pastebin/CbgjuMaK/.vimrc
16:48:50 <edwardk> i tend to work on a mac, just because it 'just works', build system stuff is cabal, no real custom tooling there
16:48:55 <edwardk> i don't even sandbox
16:49:43 <edwardk> maybe the strangest thing about my haskell dev cycle is i'll often go a day or two without even trying to compile new code as i write it
16:49:53 <edwardk> especially for a new project
16:50:19 <d-snp> heh
16:50:49 <Hafydd> Then: 100 type errors.
16:50:52 <d-snp> I did that for my bsc thesis.. spent days trying to get my code to compile after that :P
16:50:58 <Hafydd> Hahahah.
16:51:07 <edwardk> Hafydd: they whittle away fast
16:51:17 <edwardk> and while they do they teach me something about how i mis-structured things
16:51:42 <edwardk> i can usually get it up and running in a couple of hours after one of those binges
16:51:52 * d-snp starts up vim to see what set list! does..
16:52:43 <wolftune> I'm working to use tags for the first time and experimenting with both vim and Atom (which supports ctags)… I have a few simple questions:
16:52:56 <edwardk> with listchars it shows trailing spaces, tabs, etc.
16:53:00 <wolftune> are the tag files vim uses the ctags format?
16:53:14 <wolftune> what's the difference / value of hasktags vs fast-tags?
16:53:27 <wolftune> esp. if I want to try making tags for Atom…?
16:53:58 <wolftune> I tried exporting via both tools, I see slight differences, not sure how to determine what's best
16:54:15 <geekosaur> vim uses ctags format, yes
16:54:17 <ReinH> wolftune: vim uses tag files specified by :set tags
16:54:29 <ReinH> wolftune: :help 'tags' for more info
16:54:31 <geekosaur> the other format is used by emacs (and is a bit less functional)
16:54:43 <wolftune> so that means fast-tags is making ctags and thus fast-tags could work for Atom just as well as hasktags, right?
16:54:52 <geekosaur> yes
16:54:56 <wolftune> hasktags with -c arg specifically
16:54:58 <wolftune> great
16:55:04 <edwardk> i do occasionally use tags files
16:55:06 <wolftune> so how do I choose between the two tools?
16:55:38 <wolftune> I tried searching and found no direct comparison or listing of pros/cons
16:55:58 <d-snp> how long have you been using Atom wolftune? I tried it for a few days but nothing really worked out of the box for me..
16:56:24 <wolftune> d-snp: I just started trying it this week, wanted to especially consider whether to recommend it to other beginners
16:56:41 <wolftune> d-snp: I really am waiting for ghc-mod and thus Atom's ide-haskell to support Stack
16:57:03 <wolftune> d-snp: but actually having played with it a bit, I'm pretty impressed overall
16:57:03 <d-snp> yeah that'd be great
16:57:06 <geekosaur> hasktags is older; fast-tags can incrementally update and is a bit faster at tag generation. I don't think there's a lot of difference otherwise
16:57:17 <wolftune> vim is definitely not a good example of "works out of the box" !
16:57:44 <d-snp> well, edwardk's vimrc seems to say otherwise :P
16:57:45 <wolftune> geekosaur: so you'd just go with fast-tags then? No downsides that you know?
16:57:50 <geekosaur> none I'm aware of
16:58:22 <edwardk> d-snp: i'm not exactly a typical user. i don't even use 90% of the commands i know in vim, just to keep it down to muscle memory, unless it is going to be really really bad
16:58:23 <d-snp> edwardk: I'm still a bit weirded out by it though, what about set nu!, you don't need that?
16:58:24 <wolftune> d-snp: sure you can jump in with someone's .vimrc … but still, lots to learn… I haven't checked edwardk 's specifically… should probably check that out
16:58:31 <geekosaur> there are some fancier tags programs on hackage; many of them have caveats because they push the tags mechanism, which was designed for C-like languages, into corner cases that sometimes confuse tags-aware programs
16:58:32 <edwardk> dolio gives me crap out about it constantly
16:58:41 <geekosaur> but fast-tags isn't one of them
16:58:59 <edwardk> d-snp: :f tells me where i am =)
16:59:00 <mauris_> i'm confused about how to name the fields of my records in a way that isn't ambiguous
16:59:17 <d-snp> wolftune: he just pasted it, it's 3 lines all he enables is show whitespace :P
16:59:23 <d-snp> he basically uses it vanilla
16:59:29 <mauris_> is having a `fooColour :: Foo -> Colour`, and `barColour :: Bar -> Colour`, a good idea?
16:59:32 <wolftune> geekosaur: yeah, my interest is "I want to pick one recommendation to tell beginners so they can play with tags in either Atom or vim or both"
16:59:40 <edwardk> and if i'm going to a line number, i can just :thatlinenumber
16:59:56 <mauris_> because doing that makes me feel like i should call everything `fooX :: Foo -> X` for consistency
17:00:23 <geekosaur> either one is suitable then. fast-tags might be preferable on larger projects, especially if you hook it in to vim for live incremental updating
17:00:29 <wolftune> d-snp: was that just before I joined?
17:00:43 <geekosaur> (which is its main feature over hasktags, but requires some setup in vim)
17:00:56 <d-snp> 01:42 < edwardk> My entire .vimrc https://www.irccloud.com/pastebin/CbgjuMaK/.vimrc                                                                                        │·········
17:00:58 <edwardk> mauris_: i tend to do that and then make a class HasColour t where colour :: t -> Colour -- (or use a lens instead) to get the overloads
17:01:00 <d-snp> woops
17:01:28 <mauris_> also, when using lens, i call my fields `_name :: Person -> Name` or something, and then `name` is the lens... but does that mean i should avoid calling `_name` myself?
17:01:32 <wolftune> geekosaur: I'd assume incremental updating won't work in Atom, but you're saying hasktags would do no better right? like no advantage to it…
17:02:10 <mauris_> plus, to make things even more confusing, sometimes `_blah` is the lens and `blah` is the function, apparently?
17:02:13 <edwardk> d-snp: i used to bother to include map <F2> :exec ":!hasktags -x -c --ignore src"<CR><CR>   and set tags=TAGS;/,codex.tags;/   when i was using codex and hasktags more regularly
17:02:16 <geekosaur> right. (and I don't know offhand if there's a way to hook it into Atom or not.)
17:02:38 <mauris_> well... i guess the only occasion i can think of is `_1` and friends
17:02:40 <geekosaur> it's a general mechanism but it does require an editor with some smarts. vim has enough smarts, original vi ... might be if you're handy with its macros
17:02:59 <edwardk> mauris_: _1 and _2 were named because scala was using those names and every other name for those was going to be awful
17:03:05 <edwardk> fstLens,  fstL....
17:03:22 <mauris_> yeah, they're probably just exceptions
17:03:26 <edwardk> all of them are ugly. _1, and _2 are ugly but they largely 'vanish' in a chain.
17:03:38 <edwardk> traverse._2._1._4.both 
17:03:41 <edwardk> reads pretty well
17:03:43 <mauris_> but i should write `x ^. blah` as opposed to `_blah x`, i guess?
17:03:47 <edwardk> the other conventions didn't scale for me
17:03:55 <edwardk> mauris_: up to you
17:03:58 <edwardk> they generate the same code
17:04:05 <edwardk> i try very hard not to turn into the lens style-police =)
17:04:26 <edwardk> i wrote a bunch of combinators that fit well together. you can use as many or as few of them as you like
17:05:11 <mauris_> yeah, i'm not good at dealing with timtowtdi
17:05:29 <edwardk> mauris_: came from python? =)
17:06:05 <mauris_> yep! and C, which is a bit like that too
17:07:39 <d-snp> haskell has insanely many ways to do anything, and there is a strictly superior way that you'll have to become a full professor for ;)
17:10:21 <d-snp> why would google be working on writing a JIT in Haskell? they're paying someone to work on llvm-general I think
17:15:58 <nitrix> d-snp: As with a lot of their projects, they'll write their own, start using it, grow and then hire the best knowledgeable people on the matter and write a proper substitution.
17:16:11 <nitrix> d-snp: The thing is, I know many Haskell developers that aren't interested by Google at all.
17:20:29 <nitrix> d-snp: For the former point, yes, I found that annoying as well as a beginner. It's actually very elegant. At the foundation, there are building blocks, other concepts are built from those blocks, and sometimes it's so frequently used there's syntaxic sugar added for it. The feeling of having multiple ways to do things comes from wether you'll use what's the most directly suited for what you're doing, or
17:20:29 <edwardk> nitrix: with haskell being off the 'officially allowed languages list' there it is a pretty hard sell to get a haskeller to sign up if they really want to use haskell in their day job
17:20:31 <nitrix> aggregate smaller concepts together in prevision for the future.
17:25:53 <erikd> hmmm, is the alex documentation really poor or am i just a bozo?
17:26:17 * erikd ponders whether both may be true
17:26:25 <pingu> If anyone here is in Vancouver, you're welcome to join a bunch of us for dinner tonight.
17:26:53 <pingu> We're meeting at the Hyatt Regency concierge desk at six and and at seven.
17:27:24 <ReinH> pingu: I'll be arriving too late but enjoy dinner!
17:27:52 <saulzar> I get the feeling there are less ways of doing something than C++ for example, or at least it feels easier to pick the 'right' way (usually the 'purest' way)
17:28:00 <srhb> So jealous of the icfp'ing. :-)
17:28:34 <ReinH> srhb: as you should ne
17:28:37 <ReinH> *be
17:28:38 * srhb nods
17:28:48 <erikd> yes, icfp is the awesome!
18:35:41 <rpfun> is there an "elegant" solution to the following problem: i have a type "data A = A B C" and a function "f :: A -> (D -> E)", where the D -> E function produced from A is expected to be called many times from many different locations in the program (meaning it would be often generated). my current approach has been to define "data A = A B C | A' B C (D -> E)" with a "cached" constructor A', but this seems inelegant and seems more of an
18:35:41 <rpfun> OO approach to the problem. On the other hand, just having A' as a constructor also seems a bad solution since A should only really be specified by B and C (conceptually)
18:41:06 <ezrios> are nested type family applications necessarily bad?
18:42:08 <geekosaur> rpfun, you've asked that several times here. you might be better off asing in the haskell-cafe mailing list or on stackoverflow
18:42:12 <geekosaur> *asking
18:44:46 <rpfun> geekosaur: sorry, the first time i asked i didn't get an answer and the second time i wasn't able to clarify my question. i won't ask it here again.
18:46:14 <serendependy> I'm having trouble getting shm/case-split to work on lists. At the interactive prompt I give it [] but it complains "shm-node-start: Wrong type argument: markerp, nil". Any advise?
18:46:43 <lf94> Well it's telling you what's wrong
18:46:48 <serendependy> (it works for Bool, Maybe)
18:47:00 <lf94> Give it Nothing
18:47:10 <lf94> or Just []
18:48:15 <serendependy> lf94, Those aren't types, the prompt requires a type to split on
18:48:21 <geekosaur> that was a suggestion, not an order; just seems like if you can't get an answer here, maybe try other places
18:48:43 <serendependy> And they're also Maybe [a], but I want [a] (though it doesn't understand type variables I've found, Maybe works but Maybe a doesn't)
18:52:30 <serendependy> Bah, it works if I define my own List... it's just not able to find the standard list type from the type `[]`
18:57:38 <geekosaur> looks to me like it simply doesn't work with list, because it doesn't behave like a "normal" type
18:57:45 <geekosaur> (syntactically)
18:58:36 <geekosaur> the code would have to be special-cased to deal with lists anyway. (I would also wonder if it handles any other type with an infix constructor)
18:59:49 <geekosaur> (that is, it's thrown off by the syntax of the list type itself, and if you fixed that it would fail because of the syntax of the list data constructor)
19:00:05 <serendependy> geekosaur, A pity. Well, I already started hacking elisp, I guess I can poke around and make a special case for it
19:01:05 <serendependy> The Elisp equivalent of case splitType of "[]" -> _customCode ; _ -> _existingCode
19:05:15 * hackagebot Folly 0.1.4.0 - A first order logic library in Haskell  https://hackage.haskell.org/package/Folly-0.1.4.0 (dillonhuff)
19:21:15 <joobus> is otherwise just a type synonym for True?
19:21:37 <arkeet> not a type synonym.
19:21:41 <arkeet> (it's a value)
19:21:44 <arkeet> but yes it's defined as True
19:21:55 <arkeet> otherwise :: Bool
19:21:58 <arkeet> otherwise = True
19:22:10 <joobus> k, cool
19:29:16 <emmanuel_erc> hello there everyone!
19:30:19 <emmanuel_erc> Would you guys mind I posted some code?
19:31:09 <geekosaur> @paste
19:31:09 <lambdabot> Haskell pastebin: http://lpaste.net/
19:31:19 <geekosaur> use a pastebin, ^ preferred
19:32:53 <emmanuel_erc> Ok, I am going to, but I wanted to  say that my code is perhaps a bit more the intermediate end of things. I've posted my code in #haskell-beginners and I haven't got any response.
19:33:19 <lpaste_> emmanuel_erc revised “Could I have not used the State Monad here?”: “No title” at http://lpaste.net/139863
19:33:59 <emmanuel_erc> If any of you are able to offer some constructive criticism, I would greatly appreciate the comments!
19:37:15 <joobus> does anyone here write literate haskell by default?
19:37:28 <emmanuel_erc> geekosaur: Did you see my post?
19:40:02 <Cale> joobus: Literate Haskell gets used a fair amount on mailing lists
19:40:08 <emmanuel_erc> Has anyone taken a look at my post?
19:40:08 <Cale> joobus: and blog posts
19:40:35 <geekosaur> emmanuel_erc, you can always avoid the state monad by passing and returning the state explicitly
19:41:15 <geekosaur> in this case, your state would just be another parameter and you return the resulting "state"
19:42:01 <emmanuel_erc> Ok, so when would using the state monad be useful then?
19:42:22 <geekosaur> usually you use it when it's annoying to manually plumb it through a bunch of calls
19:42:39 <Zekka> emmanuel_erc: It's a way to avoid verbosity, and to make it so code not involved in moving the state doesn't have to think about moving the state
19:42:41 <joobus> i was just checking out literate-markdown, but it doesn't look like it is ready yet
19:42:45 <geekosaur> in this case where it's being used only one in a recursive function, I wouldn't bother
19:42:48 <emmanuel_erc> But in my case, it wouldn't be that annoying, would it?
19:45:53 <emmanuel_erc> Ok, thanks for the tip. For those that looked at my code, I am trying to reasonably fast numeric code.
19:46:06 <emmanuel_erc> Have I written it very poorly for that purpose?
19:46:17 <Gurkenglas> emmanuel_erc, as I often do I recommend that explicit recursion (in selecthelperKN) be replaced by higher-order functions when possible, further refactorings should then be straightforward. In this case, you can foldr the do block starting on line 65 across the list [1..min_num] and then run the one startin on line 63.
19:46:18 <emmanuel_erc> (well, if you can tell by just glancing at it.)
19:48:16 <Gurkenglas> Oh wait, min_num changes nothing except how often you recurse. Use replicateM min_num, in that case.
19:48:54 <emmanuel_erc> Thanks for the tip Gurkenglas! Do higher order functions only make it easier to refactor later on, or they do offer any speed benefits?
19:49:36 <Gurkenglas> The first, though I also like the readability
19:49:52 <emmanuel_erc> The first?
19:50:01 <Gurkenglas> "easier to refactor later on"
19:50:45 <Gurkenglas> It's much more pleasant to read a 100-line function (including wheres) when the first thing it says in its definition is "unfoldr", for example.
19:51:01 <emmanuel_erc> I see. I am happy to know to discover replicateM
19:51:24 <emmanuel_erc> That makes reasoning about certain aspects of code a lot easier.
19:52:36 <emmanuel_erc> So ,if I am not mistaken, monads are lazy by default. If I was to rewrite this code (The part with state monad), then there is nothing stopping from enforcing strict evaluations, right?
19:53:53 <Gurkenglas> (Oh and "get >>= put . f" = "modify f")
19:57:19 <Gurkenglas> Hah, talk about future refactorings becoming easier. Reading the code again, I now notice that you have no business using the state monad there. Define selectKN
19:57:19 <Hijiri> emmanuel_erc: I haven't taken a thorough look, but it doesn't look like you make much use of State's monadic interface
19:57:26 <Hijiri> so it would probably make sense to not use it
19:57:29 <Gurkenglas> (damn you enter key)
19:57:36 <Gurkenglas> ...using foldr and everything gets simpler
19:57:59 <emmanuel_erc> I will do that.
19:58:28 <emmanuel_erc> Hijiri: Yeah, after I wrote that (after first understanding the State Monad) it felt like overkill.
20:00:33 <emmanuel_erc> Gurkenglas: So besides the fact that I don't technically need the State Monad in selectKN, would I be missing out on performance gains by not using unfoldr?
20:01:04 <Gurkenglas> Nah, all your overkill should be vanished by GHC if im not wrong
20:02:24 <emmanuel_erc> Ok, well I learned to three valuable items coming here today. I can't believe I didn't know about the unfoldr function
20:07:11 <emmanuel_erc> Thanks for your help Gurkenglas!
20:07:32 <emmanuel_erc> Thanks as well Hijiri!
20:19:14 <jiada> Hi guys!I am trying to solve this problem https://leetcode.com/problems/shortest-palindrome/ in Haskell.This is my code and erro message https://gist.github.com/f4a11772215cfc71923d.git.Could someone help me?
20:23:08 <jdmnd> jiada: (xs:x) binds xs to the head and x to the tail of the list
20:23:16 <jdmnd> which i don't think is what you want
20:25:21 <jiada-chrome> [1,2,3]  xs = [1,2]  x=[3]
20:25:31 <jiada-chrome> This is what I want
20:26:19 <jdmnd> then you'll need to use `init` and `last` explicitly
20:29:07 <matsuura> any of you guys have a few minutes to help me port emacs to haskell?
20:33:04 <nitrix> >> ['!'..'\\']
20:33:07 <nitrix> > ['!'..'\\']
20:33:09 <lambdabot>  "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\"
20:33:45 <nitrix> How do I get the entire charset? I tried mindBound and maxBound with no success. Also, is this standardized or implementation-specific?
20:36:51 <nitrix> For example, [minBound..'z'] gives a pretty good list, but if I use maxBound, then the result is [()] somehow.
20:38:12 <geekosaur> you need to specify a type
20:38:22 <geekosaur> > [minBound :: Char .. maxBound]
20:38:25 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
20:38:38 <geekosaur> > [minBound .. maxBound] :: [Char]
20:38:40 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
20:38:50 <nitrix> Oh, it gave me () because I'm on the REPL and it's an IO ().
20:38:56 <geekosaur> otherwise (extended) defaulting gets you ()
20:38:57 <wei2912> matsuura: i don't think it's going to take a few minutes
20:39:38 <Hafydd> \SOH\CAH\TOA
20:40:21 <nitrix> geekosaur: Makes sense. Sorry for the confusion.
20:42:23 <arkeet> > [miBound :: Char .. ]
20:42:26 <lambdabot>      Not in scope: ‘miBound’
20:42:26 <lambdabot>      Perhaps you meant one of these:
20:42:26 <lambdabot>        ‘minBound’ (imported from Prelude),
20:42:27 <nitrix> Can one implement an instance of a typeclass not available in their project in prevision of it might be imported along another library?
20:42:28 <arkeet> > [minBound :: Char ..]
20:42:30 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
20:44:00 <matsuura> wei2912: ssshhh...... :p
20:44:04 <ttt_fff> by definition, can quasiquote only take as input, strings that are valid haskell exprs ?
20:44:09 <nitrix> This way there's no dependency on said library, but if someone uses your in conjunction with theirs, you unlock useful compositions?
20:44:17 <ttt_fff> (otherwise, it's sorta meaningless, since quasiquote is supposed to return a expr)
20:45:07 <geekosaur> ttt_fff, you can define your own quasiquoters. the standard one expects a haskell expression
20:46:26 <geekosaur> http://hackage.haskell.org/package/heredoc-0.2.0.0/docs/Text-Heredoc.html example quasiquoters
20:47:02 <ttt_fff> geekosaur: thanks! hard to argue vs a concrete example
20:48:09 <geekosaur> I think there's an sql library that has a quasiquoter that accepts sql and generates an equivalent haskell expression...
20:54:06 <geekosaur> right, there's one http://hackage.haskell.org/package/mysql-simple-quasi-1.0.0.2/docs/Database-MySQL-Simple-Quasi.html
20:54:44 <ttt_fff> https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/persistent-db even persistent uses it
20:55:22 <ttt_fff> geekosaur: that's pretty cute that it's embedding type sigs into sql vars
20:55:39 <ttt_fff> which I think is very cool
20:55:57 <ttt_fff> there's two things that gets me excited about quasiquotes:
20:56:16 <ttt_fff> (1) I can do checks in addition to ghc's type checker (and have it complain at compile time if the expr does not satisfy some conditions)
20:56:39 <ttt_fff> (2) Haskell AST ==> converted into other language
21:00:06 <codehero> ummm
21:00:08 <codehero> guys
21:00:10 <codehero> i.. um
21:00:16 <jmcarthur> just discovered the optimizer is happier with me using Applicative f => f () and specializing to IO than with me using Monoid m => m and specializing to Ap IO ()
21:00:34 <codehero> (read . show) is always supposed to return the argument, right?
21:00:36 <codehero> right guys?
21:00:55 <arkeet> that's the idea.
21:00:57 <jmcarthur> it's desirable, but i don't think it's a requirement
21:01:00 <codehero> well. it doesn't work
21:01:06 <codehero> *** Exception: Prelude.read: no parse
21:01:08 <codehero> i don't get it
21:01:15 <arkeet> you have to make sure it's the same type on both sides.
21:01:27 <jmcarthur> wild guess: defaulting is making one of those just expect ()
21:01:37 <codehero> oh
21:01:39 <codehero> well
21:01:41 <codehero> lol
21:01:43 <codehero> thx
21:01:48 <codehero> i had to specify the type explicitly
21:01:48 <jmcarthur> > read (show (5 :: Int)) :: Int
21:01:50 <lambdabot>  5
21:01:51 <codehero> well
21:01:59 <arkeet> (read . show :: Int -> Int) 5
21:02:01 <arkeet> > (read . show :: Int -> Int) 5
21:02:03 <lambdabot>  5
21:02:20 <jmcarthur> > (read . show) 5
21:02:22 <lambdabot>  *Exception: Prelude.read: no parse
21:02:44 <jmcarthur> i really dislike defaulting
21:03:09 <codehero> okay. then i only need to find out why aeson (decode . encode) doesn't work
21:03:27 <arkeet> it might be types again.
21:03:38 <codehero> yupp
21:03:40 <codehero> it is
21:03:42 <codehero> well
21:03:45 <codehero> now that that's settled
21:10:55 <safinaskar> i want something like js split
21:11:07 <safinaskar> i. e. turn "a b c" to ["a", "b", "c"]
21:12:02 <safinaskar> and i want to use any delimeter
21:12:32 <kadoban> safinaskar: Look at the 'split' package
21:12:54 <safinaskar> *facepalm
21:13:08 <safinaskar> kadoban: so, i need to import some package to get this?
21:13:12 <safinaskar> maybe some oneliner?
21:15:39 <kadoban> Dunno if that exists in base, look at 'words', there might be variants in base. Can you implement it in a one-liner? I guess, if you want.
21:15:56 <kadoban> Importing a package … isn't very hard or something to be avoided really.
21:17:42 <EvanR> split and join are also in the package "MissingH"
21:17:53 <EvanR> among other things
21:18:54 <glguy> > splitOn "--" "a--b--c"
21:18:56 <lambdabot>  ["a","b","c"]
21:19:04 <glguy> The "split" package is pretty common to use
21:19:15 <EvanR> the package "stringsearch" has efficient algorithms for bytestring search and replace
21:19:36 <EvanR> and split
21:24:13 <safinaskar> @hoogle (a -> b) -> ((b -> c) -> (a -> c))
21:24:16 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
21:24:16 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
21:24:16 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
21:24:48 <EvanR> :t flip (.)
21:24:49 <lambdabot> (a -> b) -> (b -> c) -> a -> c
21:24:55 <EvanR> :t (>>>)
21:24:57 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
21:25:48 <EvanR> Category (~>) => a ~> b -> b ~> c -> a ~> c
21:30:03 <safinaskar> > and []
21:30:06 <lambdabot>  True
21:30:17 <safinaskar> or []
21:30:26 <safinaskar> > or []
21:30:29 <lambdabot>  False
21:33:22 <safinaskar> > if not $ False then "ok" else ""
21:33:24 <lambdabot>  "ok"
21:34:03 <kosmikus> maway
21:34:21 <EvanR> mmm away mmm away
21:34:27 <EvanR> in the jungle ...
21:34:33 <kosmikus> hehe
21:34:41 <kosmikus> sorry
21:45:33 * hackagebot opaleye-classy 0.3.1.0 - Opaleye wrapped up in classy MTL attire.  https://hackage.haskell.org/package/opaleye-classy-0.3.1.0 (BenKolera)
21:49:04 <safinaskar> > zipWith (+) [1] [2,2]
21:49:06 <lambdabot>  [3]
21:49:44 <athan> > liftA2 (+) (ZipList [1]) (ZipList [2,2])
21:49:45 <lambdabot>  ZipList {getZipList = [3]}
21:50:45 <athan> :t Data.Key.zip
21:50:47 <lambdabot> Not in scope: ‘Data.Key.zip’
21:50:50 <athan> darn
21:52:56 <jisfon> factorial x = if x == 1 then 1 else x * factorial (x-1)
21:53:03 <Lokathor> when i try to run my own copy of lambdabot, it doesn't seem to properly read the rc file that i specify
21:53:05 <jisfon> if I understand how that works, do I understand recursion?
21:53:09 <Lokathor> oh well, not like it needs to be reset often
21:53:50 * athan whispers in jisfon's ear "recursion schemes"
21:54:08 <athan> jisfon: Basically, yeah. I suggest learning about folds nest :)
21:54:09 <Lokathor> jisfon, as i said to someone in #lisp moments ago: it partly controls your actions, but it also obeys your commands
21:54:15 <athan> next*
21:54:20 <safinaskar> > intercalate " | " ["a", "b"]
21:54:22 <CMCDragonkai> [safinaskar (guest)] > intercalate " | " ["a", "b"]
21:54:22 <lambdabot>  "a | b"
21:54:36 <safinaskar> two bots?
21:54:41 <athan> o_o
21:54:53 <Hafydd> > sdfsdf
21:54:53 <Lokathor> > "test" ++ "this"
21:54:55 <lambdabot>  Not in scope: ‘sdfsdf’
21:54:55 <lambdabot>  "testthis"
21:54:59 <athan> CMCDragonkai: @yo
21:55:06 <athan> hm
21:55:25 <Lokathor> jisfon, note that what you put for factorial is "recursive" but not "tail recursive"
21:55:39 <athan> < foldr (+) 0 [1,2,3,4] -- jisfon
21:55:45 <athan> > foldr (+) 0 [1,2,3,4]
21:55:47 <lambdabot>  10
21:55:50 <athan> -_-
21:56:42 <Lokathor> >foldr1 (+) [1,2,3,4] -- also some fold variants available
21:56:50 <Lokathor> > foldr1 (+) [1,2,3,4]
21:56:52 <lambdabot>  10
21:57:03 <Lokathor> wow no one can type to lambdabot today
21:57:15 <athan> Lokathor: :P
22:01:26 <c_wraith> @botsnack
22:01:26 <lambdabot> :)
22:03:03 <EvanR> jisfon: to understand recursion you must first understand recursion
22:06:14 <kadoban> To understand recursion, you must first understand slightly smaller recursion (and then no recursion)
22:06:38 <c_wraith> kadoban: slightly? hah.  I demand the subproblems be half the size of the original problem!
22:06:44 <rom1504> too late, I'm stuck in EvanR infinite recursion
22:06:46 <kadoban> :)
22:07:24 <Cale> kadoban:  let ones = 1 : ones
22:07:35 <jisfon> EvanR: that would eventually crash; no base case, right?
22:07:50 <kadoban> Heh … crap, yeah.
22:09:31 <EvanR> jisfon: eventually, youll hope for a crash
22:09:34 <EvanR> and never get one
22:09:48 <athan> > "To" <> fix $ " understand recursion, first you must" ++
22:09:49 <lambdabot>  <hint>:1:57:
22:09:49 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
22:09:54 <athan> dangit
22:10:06 * Lokathor giggles
22:10:06 <athan> > "To" ++ fix (" understand recursion, first you must" ++)
22:10:08 <lambdabot>  "To understand recursion, first you must understand recursion, first you mus...
22:10:39 <rom1504> lambdabot is too smart for you
22:11:00 <athan> :c
22:35:29 <jisfon> If SICP is such a good intro to programming, why don't most people on forums and such recommend it (they recommend Python, C or something, with various books for learning them).
22:35:32 <jisfon> *?
22:36:14 <Myrl> My god.
22:36:21 <Myrl> What monstrosity have I created.
22:36:22 <Myrl> all ((>=) <$> fst <*> snd) . (tail >>= zip)
22:37:07 <athan> Myrl: Something rad :)
22:37:26 <athan> I've got a lib for deeper combinators if you find yourself needing them
22:37:30 <athan> @hackage composition-extra
22:37:30 <lambdabot> http://hackage.haskell.org/package/composition-extra
22:37:50 <athan> jisfon: Most of those communities are geared for /imperative/ programming, not functional programming
22:38:49 <athan> on one hand, you can manipulate the machine directly, but it becomes a bag of worms pretty quickly. On the other hand, you have mathematics and logic at your disposal, with a higher learning curve
22:47:38 <arkeet> :t ((>=) <$> fst <*> snd)
22:47:40 <lambdabot> Ord b => (b, b) -> Bool
22:47:57 <arkeet> that's uncurry (>=), no?
22:48:03 <arkeet> :t (tail >>= zip)
22:48:05 <lambdabot> [a] -> [(a, a)]
22:48:14 <arkeet> > (tail >>= zip) [1..10]
22:48:16 <lambdabot>  [(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9)]
22:48:42 <codehero> oh. fancy
22:49:13 <arkeet> Myrl: try this: \xs -> all (zipWith (<=) xs (tail xs))
22:49:16 <arkeet> @pl \xs -> all (zipWith (<=) xs (tail xs))
22:49:16 <lambdabot> all . ap (zipWith (<=)) tail
22:49:37 <glguy> and*
22:49:40 <arkeet> and
22:49:41 <arkeet> yes
22:54:52 <Myrl> arkeet: Won't work.
22:55:25 <arkeet> and, not all
22:55:36 <arkeet> :t \xs -> and (zipWith (<=) xs (tail xs))
22:55:38 <lambdabot> Ord a => [a] -> Bool
22:56:15 <Myrl> Hmmm
22:56:17 <Myrl> Oh.
22:56:33 <Myrl> oh cool, `ap` == `>>=` in this case.
22:56:41 <arkeet> not quite, it's =<<
22:56:49 <Myrl> Ah.
22:56:51 <arkeet> I'd just write <*>
22:57:05 <jisfon> computer died
22:57:10 <arkeet> :t [(<*>), (=<<)]
22:57:11 <lambdabot> [(a -> a -> b) -> (a -> a) -> a -> b]
22:57:27 <arkeet> hm.
22:57:32 <arkeet> :t [(<*>), (=<<) . flip]
22:57:34 <lambdabot> [(a1 -> a -> b) -> (a1 -> a) -> a1 -> b]
22:57:35 <arkeet> yes.
22:57:46 <arkeet> that's better.
22:58:08 <jisfon> so, which is generally better for a beginner: knowledge of direct control of stuff (C, C++, Python) or the mathematics and logic of programming (SICP)?
22:58:37 <athan> jisfon: Well, you're asking a community already invested in the latter
22:58:44 <athan> so, the best I could say is the latter
22:59:55 <greves> =/ haskell is difficult
23:00:39 <greves> i can't get the very first example working in these slides: https://github.com/meiersi/HaskellerZ/blob/master/meetups/20150529-ZuriHac2015_Oliver_Charles-Web_Programming/talk.pdf
23:00:59 <codehero> jisfon: really depends on your goal
23:01:16 <codehero> but if you just want to learn high level programming, haskell is good
23:02:02 <athan> greves: I would start slow
23:02:16 <athan> Check out this guide, though -
23:02:20 <athan> @learn greves
23:02:20 <lambdabot> http://www.haskell.org/haskellwiki/Learning_Haskell
23:02:35 <greves> athan well i did a bunch of the beginner type tutorials already for just writing functions, types, data structures, IO monad, etc
23:03:05 <athan> greves: Oh okay, hm
23:03:10 <athan> have you used cabal at all yet?
23:03:15 <athan> or made your own package?
23:03:24 <greves> yeah, i used cabal, cabal sandbox, and stack
23:03:26 <jisfon> codehero: I'm confused as to which goals suit those two distinctions
23:03:40 <greves> i dont have a problem with packages or modules, that's ok
23:03:47 <Cale> greves: What error are you getting?
23:04:03 <Cale> (I assume the problem is that some code doesn't compile?)
23:04:15 <jisfon> codehero: can you give me an idea of certain goals that suit which of those?
23:05:38 <Cale> greves: ?
23:06:02 <greves> was just pasting it over
23:06:03 <greves> https://dpaste.de/3eJU
23:06:41 <greves> the code lines 1-23 is copied basically verbatim from those slides, but it doesn't seem to match up with anything i can see in the spock documentation
23:06:50 <jisfon> like, what goal would be becoming of someone pursuing direct control programming rather than mathematics and logic?
23:07:12 <jisfon> and what goals would be becoming of someone pursuing mathematics and logic programming rather than direct control?
23:07:21 <jisfon> (if ANY of that makes any sense lol)
23:07:24 <Cale> greves: Okay, the problem is probably that the library API changed.
23:07:47 <Cale> greves: Give me a sec to check out the spock documentation and see what happened
23:07:59 <greves> Cale thats what i figured, but i was trying to match up with the spock documentation directly and couldn't get anything working
23:09:30 <Cale> okay, I'll install spock and try it :)
23:09:41 <greves> cool thanks
23:11:24 <ttt_fff> oh man, oh man, how is TH not more used?
23:11:32 <ttt_fff> this is the most amazing meta programming system
23:14:44 <Cale> ttt_fff: Lazy evaluation reduces the need for macros quite a bit
23:15:33 <ttt_fff> but laziness is not sufficient for EDSL
23:15:41 <ttt_fff> when sometimes you want to look up info about existing data types, etc ...
23:15:43 * hackagebot yaml 0.8.14 - Support for parsing and rendering YAML documents.  https://hackage.haskell.org/package/yaml-0.8.14 (MichaelSnoyman)
23:15:58 <greves> so `runSpock' takes a port and IO Middleware, `spock' (which returns the IO Middleware) takes a SpockCfg and SpockM (which is the "app" iiuc), but i dont know how to build the SpockCfg
23:16:19 <Lokathor> question: i don't know template haskell and i don't really know lisp macros, but is template haskell ~vaguely similar to~ lisp macros?
23:16:27 <Lokathor> (be hand-wavy if you need to)
23:17:55 <jisfon> Lokathor: so, which is generally better for a beginner: knowledge of direct control of stuff (C, C++, Python) or the mathematics and logic of programming (SICP)?
23:18:35 <Lokathor> i just recently tried to explain python to a person who didn't know one bit of the fundamentals, it didn't work
23:19:44 <Lokathor> put another way, I'll pretty much always suggest SCIP over not-SCIP
23:20:06 <ttt_fff> Lokathor: TH is pretty much "what would lisp macros look like if it was forced to be done in Haskell instead of Lisp"
23:21:01 <Lokathor> hmm. I've been learning common lisp after knowing beginner's haskell. Macros and CLOS were the only things that appeared to be in lisp that I couldn't point to and say "i know how you'd do that in haskell"
23:21:59 <kadoban> TH is … about as much like lisp macros as haskell is like lisp, which is to say not very much at all. From what little I learned.
23:25:16 <bennofs> ttt_fff: there's even Typed TH iirc
23:26:37 <lpaste_> Cale pasted “Here you go - spock hello world” at http://lpaste.net/139880
23:26:43 <Cale> greves: ^^
23:27:26 <greves> darn i was so close
23:28:01 <greves> http://lpaste.net/139881
23:28:32 <Cale> SessionCfg has a few new arguments relative to the example
23:28:33 <Reshi> Has anyone done the euler project in haskell? Is it worth it for a person who is learning haskell?
23:29:01 <kadoban> Reshi: project euler is kinda fun, but has not much to do with learning haskell or necessarily much to do with programming either (it's more about math, mostly number theory)
23:29:11 <Cale> But there's a defaultSessionCfg function provided in the library which actually supplies many of those explicitly given values as defaults anyway
23:29:34 <Reshi> kodoban: I guess I am looking for something like the python challenge, if you know about that
23:29:57 <greves> what is the first part of the syntax (defaultSessionConfig ()) { k: v} ? how am i supposed to understand that from the docs
23:30:13 <greves> defaultSessionCfg :: a -> SessionCfg a
23:30:34 <Cale> right, so  defaultSessionCfg () :: SessionCfg ()
23:30:51 <greves> yes
23:30:53 <Cale> and SessionCfg is a record datatype, so we can use the record update syntax to change some of the fields if we like
23:31:03 <kadoban> Reshi: Never heard of it
23:31:16 <greves> but how do you know that `a' should be ()?
23:31:22 <Cale> You don't have to do that, I just decided to match the name of the cookie with the one that the example used.
23:31:44 <athan> Does anyone know if `liftST` exists?
23:32:07 <athan> Or do I need to do it MonadBase or MonadBaseControl style?
23:32:11 <ttt_fff> what is the TH equiv of C's "#define while if" ?
23:32:26 <lf94> :t (<_>)
23:32:29 <lambdabot> parse error on input ‘)’
23:32:32 <Cale> greves: Well, we get to choose the type of the session. I picked an empty tuple because I didn't care.
23:32:35 <lf94> :t <_>
23:32:36 <lambdabot> parse error on input ‘<’
23:32:39 <lf94> rip
23:32:46 <kadoban> Reshi: You could maybe try doing the python challenge stuff in haskell … maybe. Depends how general they are I guess.
23:33:34 <Cale> greves: If you look at the type of SessionCfg here, you can see how that type parameter a gets used: http://hackage.haskell.org/package/Spock-0.9.0.1/docs/Web-Spock-Shared.html#t:SessionCfg
23:33:42 <Cale> er, the definition of SessionCfg, rather
23:36:36 <kadoban> Reshi: I looked at a total of two of them … so far you could easily do those in haskell.
23:37:00 <Cale> greves: In general, you'd probably want to use some data type which has fields for all the information you want to store for each client of your web application
23:37:14 <Lokathor> Reshi, CodeWars and CodinGame are websites with little puzzle sorts of things. Several languages available, but they do support haskell
23:37:22 <Reshi> kadoban: Oh thanks for that! I will attempt that 
23:37:48 <greves> Cale so the `a' in this case () will be the sc_emptySession, SessionPersistCfg, and SessionHooks
23:37:48 <greves> ?
23:37:52 <Reshi> Lokathor: Thanks!
23:39:11 <jle`> ttt_fff: not sure about TH, but you can wreak a lot of global havoc by defining weird typeclasses in odd includes
23:39:15 <jle`> *weird instances
23:39:26 <jle`> you cna find where instances are defined in ghci though, so i guess it's not as evil
23:39:49 <Cale> greves: Yeah, sc_emptySession :: a will be the initial session used when someone new visits the site, sc_persistCfg :: Maybe (SessionPersistCfg a) is an (apparently optional) bunch of information about how to persist values of type a so that the data can be kept between sessions
23:41:04 <greves> ok, makes sense i suppose
23:42:08 <Cale> greves: and sc_hooks :: SessionHooks a  is a data structure which lets you specify how to handle certain events which occur in the session manager. In this case, it appears to just have one field  sh_removed :: HashMap SessionId a -> IO ()  which gets a hashmap from SessionId to values of type a
23:43:15 <Cale> I would hazard a guess that when some sessions get removed, that'll get called with a HashMap which pairs the removed sessions with their associated values.
23:43:28 <greves> http://lpaste.net/139882
23:43:41 <greves> don't understand these type errors
23:44:20 <Cale> The errors are just saying that the type signature that you gave for appCfg is more general than the actual type of the implementation
23:45:36 <Cale> You can see what the actual inferred types are in the error message, it apparently ought to be  appCfg :: SpockCfg () (SessionCfg ()) ()
23:48:20 <greves> ok, i see
23:49:07 <greves> kind of weird that the arguments are all backwards everywhere
23:49:31 <greves> SpockCfg db sess state vs. defaultSpockCfg sess db state
23:50:12 <Cale> That is a little weird
23:50:50 <greves> my goal today is just to get a markdown file read in and displayed as HTML via the web server
23:52:09 <greves> keep plugging away then :P thanks Cale
23:53:13 <ttt_fff> that's nice
23:53:14 <ttt_fff> goals are good
23:53:22 <ttt_fff> my goal today is just to learn TH
