00:00:29 <hackrilege> i could tell you where the data is, in a much smaller portion of the strucucture
00:01:04 <haskell232> hi - quick question: is there a nice way to map an Either String a to Either Text a? LIke say I have e :: Either String Int and I want to somehow get T.pack on it so that the resulting type is Either Text Int?
00:01:31 <dramforever> :t mapLeft -- let me try
00:01:32 <lambdabot> Not in scope: ‘mapLeft’
00:01:49 <hackrilege> Text.pack
00:01:51 <GoogleMePlox> SICP in Haskell would be divine
00:01:52 <dramforever> @hoogle (a -> b) -> Either a x -> Either b x
00:01:53 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
00:01:53 <lambdabot> Data.Graph.Inductive.Graph nemap :: DynGraph gr => (a -> c) -> (b -> d) -> gr a b -> gr c d
00:01:53 <lambdabot> Data.Graph.Inductive.Graph labfilter :: DynGraph gr => (a -> Bool) -> gr a b -> gr a b
00:01:59 <dramforever> no too bad
00:02:02 <hackrilege> :t either
00:02:03 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
00:02:20 <dramforever> :t \f -> either (Left . f) Right
00:02:21 <lambdabot> (a -> a1) -> Either a b -> Either a1 b
00:02:27 <dramforever> I wonder if that's readable
00:02:34 <kadoban> haskell232: 'first' from bifunctor, so it'd be   first T.pack :: Either String a -> Either Text a
00:02:50 <dramforever> oh wow
00:02:51 <hackrilege> :t (\Either s a-> Either (Data.Text.pack s) a)
00:02:52 <lambdabot>     Not in scope: data constructor ‘Either’
00:02:52 <lambdabot>     Perhaps you meant variable ‘either’ (imported from Data.Either)
00:02:52 <lambdabot>     Not in scope: data constructor ‘Either’
00:03:00 <dramforever> :t first
00:03:01 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
00:03:02 <haskell232> yeah holy cow
00:03:12 <dramforever> hmm...lambdabot doesn't seem to like it
00:03:24 <dramforever> wait there's also one in Control.Arrow
00:03:28 <dramforever> :t left -- tada
00:03:29 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
00:03:44 <kadoban> It's a different first. I dunno if lambdabot has bifunctor. There is one that's arrowish, but it's better to use bifunctor now IMO.
00:03:53 <dramforever> yep
00:04:03 <hackrilege> :t (\Data.Either.Either s a-> Data.Either.Either (Data.Text.pack s) a)
00:04:04 <lambdabot>     Not in scope: data constructor ‘Data.Either.Either’
00:04:04 <lambdabot>     Perhaps you meant one of these:
00:04:04 <lambdabot>       variable ‘Data.Either.either’ (imported from Data.Either),
00:04:19 <hackrilege> helpf
00:04:20 <dramforever> also I think we should somehow merge profunctors with arrows
00:04:23 <nshepperd> hackrilege: GPUs use tiled arrays for this sort of thing in 2D domains, iirc
00:04:37 <dramforever> hackrilege: you don't understand how to use that Either type do you
00:04:43 <haskell232> thanks for the pointer to Bifunctor
00:04:52 <kadoban> 'welcome. It's cool stuff :)
00:04:54 <hackrilege> no
00:04:54 * hackagebot HsParrot 0.0.2.20150805 - Haskell integration with Parrot virtual machine  https://hackage.haskell.org/package/HsParrot-0.0.2.20150805 (AudreyTang)
00:06:15 <nshepperd> hackrilege: which means that the adjacent objects are physically closer together (on average) which makes it more likely that they are already in cache by the time you want to traverse to it
00:07:15 <GoogleMePlox> Can you make games like Snake and Mario in Haskell?
00:07:19 <nshepperd> so, a pointer to a random place in the heap is actually pretty horrible for performance
00:07:38 * hackagebot HsPerl5 0.0.6.20150815 - Haskell interface to embedded Perl 5 interpreter  https://hackage.haskell.org/package/HsPerl5-0.0.6.20150815 (AudreyTang)
00:07:38 * hackagebot HsSyck 0.51.20150815 - Fast, lightweight YAML loader and dumper  https://hackage.haskell.org/package/HsSyck-0.51.20150815 (AudreyTang)
00:08:35 <hackrilege> i traverse my datastructure, at each node i access my neighbours, to traverse the datastructure i step to my neighbours. 
00:09:47 <valdyn> GoogleMePlox: of course
00:10:06 <hackrilege> in memory there is stored the address of the start of an array, and its length where it stores pointers to the adjacent elements, and i itterate through these
00:11:53 <hackrilege> at no point in this do i find myself looking through large arrays, just following lots of pointers
00:12:33 * hackagebot MetaObject 0.0.6.20150815 - A meta-object system for Haskell based on Perl 6  https://hackage.haskell.org/package/MetaObject-0.0.6.20150815 (AudreyTang)
00:12:33 <hackrilege> where i feel like an array needs to search for something, i already had reference to it
00:12:35 * hackagebot pugs-DrIFT 2.2.3.20150815 - DrIFT with pugs-specific rules.  https://hackage.haskell.org/package/pugs-DrIFT-2.2.3.20150815 (AudreyTang)
00:13:04 <dramforever> I wonder if these regular ADTs are suitable for HPC
00:13:39 <hackrilege> do you get what im saying?
00:14:09 <dramforever> you are saying that it seems that your program is dereferencing pointers over and over again?
00:15:32 <nshepperd> indexing into an array isn't "searching"
00:16:18 <nshepperd> it's a pointer reference with offset, which is actually one cpu instruction on any computer since like 2004
00:17:31 <hackrilege> just to clarify i think you are advocating an array over a tree of arrays
00:17:33 * hackagebot pugs-compat 0.0.6.20150815 - Portable Haskell/POSIX layer for Pugs  https://hackage.haskell.org/package/pugs-compat-0.0.6.20150815 (AudreyTang)
00:18:12 <nshepperd> you should be more concerned about the fact that your program will stall the cpu for 300 cycles or more if the target of your dereference turns out not to be in cache
00:19:27 <hackrilege> i will perform a calculation along the way each time, so its necessary to visit these nodes in this order
00:21:50 <hackrilege> im traversing while folding my surroundings. i feel like data Graph a = Graph (Array (Graph a))
00:23:25 <hackrilege> is that totally crazy?
00:25:56 <dramforever> interestingly, that reminded me of comonads again
00:26:27 <dramforever> wait there's a problem with your graph: where did all the data go?
00:26:39 <dramforever> are you going to store them on each node?
00:26:56 <hackrilege> im traversing while folding my surroundings. i feel like data Graph a = Graph a (Array (Graph a))
00:27:48 * dramforever is still worried about tying the knot here
00:27:54 <dramforever> are you sure it's going to work?
00:28:02 <GoogleMePlox> Will Haskell ever get macros?
00:28:11 <kadoban> hackrilege: After all this time overhearing this stuff after several days, I still have no idea what you're actually trying to implement. What is the data structure exactly? What operations do you need to do quickly? How did your Data.Map using one perform? Did you benchmark it at all?
00:28:16 <dramforever> GoogleMePlox: yes we already have them
00:28:23 <kadoban> GoogleMePlox: There's template haskell, which is … better macros.
00:28:35 <dramforever> we can use either 1. CPP 2. template haskell
00:28:43 <dramforever> kadoban: never forget about CPP
00:28:44 <hackrilege> im woried about tying the knot. i feel like data Graph a = Graph a (Array (Graph a)) | Closed (Graph a)
00:29:04 <dramforever> hackrilege: that doesn't solve the tying the knot problem either imo
00:29:16 <hackrilege> i didnt do the benchmark yet no sozzers
00:29:24 <dramforever> no not performance problems
00:29:45 <hackrilege> be sure to close the loops on building it!
00:29:54 <kadoban> Right, there is CPP too
00:30:03 <dramforever> "be sure" -> I'm sure there are better ways
00:30:37 <hackrilege> why? just make the constructor enforce it
00:30:38 <dramforever> a common one is Adjacency lists, which is essentially Array Vertex (Array Edge)
00:30:47 <hackrilege> it can connect to itself if it closes the loop
00:31:05 <dramforever> hackrilege: that's a weird but interesting way to express a graph
00:32:21 <hackrilege> well its actually quite unlikley that my polymer will close the loop, it results in the formation of benzene ring along the chain under great stress...
00:32:42 <hackrilege> and im building by piecewise appending
00:33:12 <hackrilege> so i can tell it when a loop is closed as i build it no problem, and then just traverse it as a strand
00:33:24 <hackrilege> or maybe even an array!
00:33:36 <dramforever> I have an interesting idea
00:34:04 <dramforever> data Graph = Chain Vertex [(Vertex, Edge)] | Loop [(Vertex, Edge)]
00:34:06 <hackrilege> ok
00:34:14 <dramforever> or some other container instead of []
00:34:20 <dramforever> ouch sorry
00:34:29 <dramforever> data Graph = Chain Vertex [(Vertex, Edge)] | Loop [(Vertex, Graph)]
00:34:37 <dramforever> the problem is: does this even work?
00:35:18 <hackrilege> im woried about tying the knot. i feel like data Graph a = Graph a (Array (Graph a)) | Closed (Graph a)
00:35:22 <hackrilege> i like mine better
00:35:39 <dramforever> I don't think you can get away with that
00:36:35 <hackrilege> its fine, just dont traverse the closed bits, dont be reference yourself upon construction without closing the loop
00:38:24 <hackrilege> you could propegate the position of the loop closing point
00:38:54 <hackrilege> actually the model im implementing has this as a requisit
00:39:13 * dramforever feels...funny
00:39:25 <hackrilege> i was kind of trying to brute force a graph
00:39:38 <hackrilege> and i still think thats fine
00:39:51 <dramforever> I'm not insulting you, but it seems non-conventional
00:40:07 <greves> can haskell variable names be any unicode characters or only ascii?
00:40:31 <hackrilege> its this ancient thing in rewriting called zebbede its a parallel high speed constructor of this single datatype
00:40:45 <dramforever> > let 一个变量 = 2 in 一个变量 + 一个变量
00:40:47 <lambdabot>  4
00:40:52 <hackrilege> and modifier 
00:40:55 <dramforever> (translation: a variable)
00:40:59 <greves> how does that work for capital letters then?
00:41:26 <greves> or constructors must be A-Z and everything else is a function?
00:41:34 <bitemyapp> greves: unicode classification I think.
00:41:49 <greves> so i can do an armenian capital letter for a constructor?
00:42:00 <dramforever> weird
00:42:36 <hackrilege> i think my way might be faster for my datastructure, am i crazy?
00:42:54 <kadoban> greves: unicode has a concept for capital letters, I'd assume that'd be used.
00:43:04 <hackrilege> im going to benchmark it dont worry! i just mean, is there hope of outperforming Map
00:43:06 <greves> ok, interesting
00:43:32 <dramforever> > let Ω = 2 in Ω -- test
00:43:34 <lambdabot>  Not in scope: data constructor ‘Ω’Not in scope: data constructor ‘Ω’
00:43:48 <dramforever> > generalCategory 'Ω'
00:43:49 <lambdabot>  UppercaseLetter
00:44:00 <dramforever> > generalCategory '量'
00:44:02 <lambdabot>  OtherLetter
00:44:08 <dramforever> > generalCategory 'a'
00:44:09 <lambdabot>  LowercaseLetter
00:44:15 <dramforever> very, very interesting
00:44:16 <jiang42> it's funny...
00:44:28 <greves> generalCategory 'Ѯ'
00:44:40 <greves> > generalCategory 'Ѯ'
00:44:40 <dramforever> > generalCategory 'Ѯ'
00:44:42 <lambdabot>  UppercaseLetter
00:44:42 <lambdabot>  UppercaseLetter
00:45:00 <dramforever> greves: but why are you going to use them anyway?
00:45:00 <jiang42> so I can name variable in Chinese
00:45:11 <greves> > generalCategory 'Հ'
00:45:13 <lambdabot>  UppercaseLetter
00:45:13 <hackrilege> nice
00:45:16 <greves> cool
00:45:17 <dramforever> jiang42: don't do that, this will make people feel weird
00:45:32 <hackrilege> we can translate it dont worry 
00:45:37 <greves> dramforever: well if your developers are chinese then it might make them feel more comfortable :P
00:46:12 <dramforever> :t let 你看不懂中文吧 = map in 你看不懂中文吧
00:46:13 <lambdabot> (a -> b) -> [a] -> [b]
00:46:20 <hackrilege> no actually you should provide show instances for your charterers in english, but thats a pain i guess...
00:46:21 <greves> which is why i asked, because i know some chinese developers who use chinese names in javascript
00:46:40 <dramforever> let's move it to #haskell-blah
00:46:42 <jiang42> 23333
00:47:21 <kadoban> Why move a conversation to a channel where it's offtopic, from one where it's on-topic?
00:47:50 <greves> yeah it does seem like the allowable variable identifiers is on topic
00:47:53 <greves> but i don't know :P
00:48:02 <dramforever> oh sorry, I just have another story on variable names
00:48:22 <kadoban> Ah
00:50:23 <dford> Hello! I am trying to do some FFI stuff with ghc, and I want to link the executable using g++. So one simple method is to take the linker options from ghc and use them in g++. But with latest ghc it does not print the linker options in the verbose output, instead a temporary file is created in /tmp/ghc... directory. 
00:50:37 <dford> Does anyone know how to get linker options from ghc?
00:50:41 <dramforever> dford: you are supposed to link using ghc
00:51:36 <dramforever> dford: like ghc -o awesomeprogram Main.hs foo.o
00:52:15 <dramforever> dford: IIUC the haskell abi is really weird, and g++ can't possibly understand it
00:52:16 <dford> dramforever: thanks for replying. My haskell library is part of a bigger system and I have to integrate my code in existing makefile infrastructure (which uses g++)
00:52:42 <jiang42> so, you want to share the story in #haskell-blah?
00:53:03 <dramforever> jiang42: not exactly story, but I thought I already shared it
00:53:11 <dramforever> sorry it's very short
00:57:54 <dramforever> dford: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html this should tell you enough
00:58:12 <dramforever> and, in case you don't know, do remember that this user guide exists so that you can reference
01:01:27 <dford> dramforever: Thanks!, I found out the ghc option after digging through the documentation '-keep-tmp-files' . although even with this info I am not able to compile with gcc
01:02:24 <dramforever> oh =)
01:07:51 <EvanR> hackrilege: there are "faster" data structures than Map depends on what you need
01:10:52 <tomjaguarpaw> ttt_fff: opaleye-sqlite is work in progress.  You can try it but it might have issues.  In fact I'd be glad if you did try it and reported the issues!
01:11:40 <tomjaguarpaw> ttt_fff: They have roughly the same features.
01:12:52 <GoogleMePlox> Is going from C to Haskell a smooth transition or not?
01:13:38 <kadoban> GoogleMePlox: C and Haskell are vastly different languages in just about every possible way.
01:14:27 <EvanR> if you are a hardcore C programmer who likes the throw the C standard at people and know every law of C
01:14:34 <EvanR> you might like haskell
01:16:18 <kadoban> I would think you might like haskell regardless of your thoughts on C.
01:16:53 <EvanR> if you like manual memory management
01:17:01 <rhaps0dy> you can do it in ahskell too!
01:17:04 <EvanR> and manually constructing monomorphic linked lists
01:17:07 <rhaps0dy> you can copy C programs almost line by line!
01:17:13 <rhaps0dy> (but it's painful)
01:19:20 <EvanR> if you like the select system call and having full control over the signal handlers
01:19:33 <EvanR> haskell might be rough
01:21:45 <kuribas> GoogleMePlox: knowing C is useful sometimes when you need to go to the bare metal, or to understand the FFI, but for the most part haskell will be entirely different.
01:22:13 <inininin> how do you use Rationals as ratios of three integers?
01:22:35 <kuribas> why three?
01:22:49 * EvanR waits for the punchline
01:23:10 <inininin> Calculating digits of pi, the most efficient formula uses 3
01:23:43 <kuribas> pi isn't a ratio...
01:23:58 <EvanR> data Ratrio a = Ratrio a a a
01:23:59 <inininin> It can be expressed as the sum of two multiples of arctans
01:24:23 <inininin> each of which is the sum of terms which are themselves ratios of three ints
01:26:01 <inininin> pi = 16 * atan (1/5) - 4 * atan(1/239)
01:27:01 <inininin> whenever I try to use a ratio of three integers as a Rational it gives me a type error
01:27:41 <EvanR> there are four integers
01:27:51 <EvanR> FOUR
01:28:46 <inininin> Each term of the atan is expressed as 2^(n+4) / 10^n / n
01:28:49 <inininin> 3 integers
01:29:32 <inininin> the first half (16 * atan(1/5)) is what I'm working with
01:30:02 <EvanR> you can use (a,b,c) a custom data type, or pass the 3 numbers loose for your algorithm
01:30:47 <inininin> How does that work as a Rational? I'm trying to keep decimal conversion until the very end
01:31:02 <EvanR> a b c are Integers
01:31:36 <EvanR> you can construct 1 % a at any time
01:31:56 <inininin> Or to put it this way, how would I write a function that takes a, b, c and turns it into Rational a/b/c?
01:32:00 <EvanR> maybe i still dont get a ratio of three integers
01:32:15 <EvanR> (a/b)/c ?
01:32:22 <inininin> type error
01:32:31 <EvanR> but is that what youre talking about
01:32:44 <inininin> but there's a type error, hence me being here
01:32:54 <EvanR> > (2 % 3) `div` 5
01:32:55 <lambdabot>      No instance for (Integral a0)
01:32:55 <lambdabot>        arising from a use of ‘show_M650204481835989777013374’
01:32:55 <lambdabot>      The type variable ‘a0’ is ambiguous
01:32:59 <EvanR> > (2 % 3) / 5
01:33:01 <lambdabot>  2 % 15
01:33:33 <EvanR> > (2 % 3) / (1 % 6) / 5
01:33:35 <lambdabot>  4 % 5
01:33:40 <inininin> it works with two, but once you try three, you get one of a few different type errors depending on method
01:34:13 <EvanR> % is ctor for Rational. / is division
01:34:22 <inininin> Couldn't match type ‘Integer’ with ‘Ratio Integer’
01:34:23 <inininin>     Expected type: Rational
01:34:23 <inininin>       Actual type: Integer
01:34:42 <EvanR> lpaste your code
01:35:18 <inininin> Couldn't match expected type ‘Integer’ with actual type ‘Ratio a0’
01:35:18 <inininin> Couldn't match expected type ‘Integer’ with actual type ‘Ratio a0’
01:35:18 <inininin> just a sec
01:36:55 <inininin> http://lpaste.net/138871
01:36:59 <breadmonster> Hello.
01:37:43 <kuribas> > (2 % (3*5))
01:37:44 <lambdabot>  2 % 15
01:38:31 <inininin> numer % denom % n
01:38:43 <kuribas> > 2 % 3 % 5
01:38:44 <lambdabot>      No instance for (Integral (Ratio a0))
01:38:44 <lambdabot>        arising from a use of ‘show_M799553649131677720613564’
01:38:44 <lambdabot>      In the expression:
01:38:51 <EvanR> % isnt division
01:38:56 <kuribas> > 2 % 3 * 5
01:38:58 <lambdabot>  10 % 3
01:39:19 <EvanR> > 1 / 3
01:39:20 <lambdabot>  0.3333333333333333
01:39:27 <EvanR> > (1::Rational) / 3
01:39:29 <lambdabot>  1 % 3
01:39:29 <kuribas> (1/3) :: Ratio Int
01:39:36 <kuribas> > (1/3) :: Ratio Int
01:39:37 <lambdabot>  1 % 3
01:39:42 <joco42__> http://snag.gy/7rEbg.jpg answer: endo
01:39:56 <joco42__> you ?
01:40:19 <inininin> See, it always yields some error
01:41:32 <breadmonster> inininin: What do you want to do?
01:41:48 <inininin> Produce a Rational as a ratio of 3 Integers
01:41:56 <inininin> http://lpaste.net/138871 is my current attempt
01:42:33 <EvanR> > (3::Rational) / 3 / 3
01:42:35 <lambdabot>  1 % 3
01:42:48 <EvanR> > (3::Rational) / 3 / 3 / 3 / 3 / 3
01:42:49 <lambdabot>  1 % 81
01:43:13 <EvanR> in real code you probably dont need the ::Rational if you have it in the function signature
01:43:37 <EvanR> > let x = 3::Rational in x / x / x
01:43:38 <lambdabot>  1 % 3
01:44:33 <inininin> Couldn't match type ‘Ratio Integer’ with ‘Integer’
01:45:03 <kuribas> > (3 / 3 / 3) :: Rational
01:45:05 <lambdabot>  1 % 3
01:45:27 <kuribas> > (2 / 3 / 4) :: Rational
01:45:28 <EvanR> inininin: maybe its on to something, maybe one of your vars is actually an integer
01:45:29 <lambdabot>  1 % 6
01:46:23 <inininin> EvanR: Rationals are ratios of three Integers, that's the point
01:46:40 <inininin> At least in my implementation
01:46:58 <EvanR> rationals arent ratios of three integers
01:47:07 <inininin> they're ratios of two, I want a ratio of three
01:47:12 <EvanR> sorry
01:47:13 <inininin> fundamentally the same
01:47:55 <kuribas> inininin: basic math: (a / (b / c)) == (a * c / b) and ((a / b) / c) == (a / (b * c))
01:48:43 <inininin> kuribas: it's basic math but the types don't line up, the grouped part becomes a ratio, and the overall expression becomes a Ratio Ratio
01:50:00 <kuribas> :t (%)
01:50:01 <lambdabot> Integral a => a -> a -> Ratio a
01:50:27 <kuribas> inininin: it will work if you convert each one to ratio first.
01:50:54 <Guest40970> are `fmap` and <$> equivalent?
01:50:57 <EvanR> your variables can be both Rationals and Integers at the same time
01:51:09 <kuribas> Guest40970: yes
01:51:16 <EvanR> CANT be
01:51:20 <dramforever> Guest40970: yes
01:51:25 <Guest40970> thanks
01:51:54 <inininin> kuribas: code sample?
01:52:13 <kuribas> > (2%1 / (3%1 / 4%1)) -- inininin 
01:52:15 <lambdabot>      No instance for (Integral (Ratio a0))
01:52:15 <lambdabot>        arising from a use of ‘show_M516434885017996942313984’
01:52:15 <lambdabot>      In the expression:
01:52:27 <kuribas> > ((2%1) / ((3%1) / (4%1)))
01:52:28 <lambdabot>  8 % 3
01:52:31 <EvanR> > let a=2%1 in a / a / a
01:52:32 <lambdabot>  1 % 2
01:52:46 <EvanR> > let a=2%1 in (a / a) / a
01:52:48 <lambdabot>  1 % 2
01:52:54 <EvanR> > let a=2%1 in a / (a / a)
01:52:56 <lambdabot>  2 % 1
01:53:25 <kuribas> inininin: but it's easy to get the types to match, even with integers
01:54:11 <inininin> kuribas: that last one was a winner http://lpaste.net/138873
01:54:38 <kuribas> > (fromInteger (2::Int) / ((3::Int) % (4:Int))) -- inininin 
01:54:40 <lambdabot>      Not in scope: data constructor ‘Int’
01:54:40 <lambdabot>      Perhaps you meant one of these:
01:54:40 <lambdabot>        ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
01:54:54 <kuribas> hm
01:55:11 <kuribas> > (fromInteger (2::Int) / ((3::Int) % (4::Int))) 
01:55:13 <lambdabot>      Couldn't match expected type ‘Integer’ with actual type ‘Int’
01:55:13 <lambdabot>      In the first argument of ‘fromInteger’, namely ‘(2 :: Int)’
01:55:13 <lambdabot>      In the first argument of ‘(/)’, namely ‘fromInteger (2 :: Int)’
01:55:20 <kuribas> > (fromIntegral (2::Int) / ((3::Int) % (4::Int))) 
01:55:22 <lambdabot>  8 % 3
01:55:58 <kuribas> > (2%1) / ((3::Int) % (4::Int)) -- maybe better
01:56:00 <lambdabot>  8 % 3
01:56:50 <inininin> kuribas: the compiler doesn't like that one
01:57:01 <dramforever> I think you need Integer
01:57:04 <dramforever> rather than Int
01:57:06 <Noinia> Does anywone know if there is a library that can construct a zip or tar ''file'' on the fly using conduits. I.e. something like: asZipFileSource :: [FilePath] -> Source m Bytestring? 
01:57:13 <Noinia> anyone*
01:57:39 <johnw> Noinia: http://hackage.haskell.org/package/conduit-extra-1.1.9.1/docs/Data-Conduit-Zlib.html?
01:57:43 <kuribas> inininin: I needed fromIntegral
01:58:00 <dramforever> maybe fromInteger-ing all the arguments?
01:58:25 <Noinia> johnw: that does only the compression part right? 
01:58:35 <kuribas> inininin: also (a/b/c) == ((a/b)/c), it's not (a/(b/c))
01:58:36 <johnw> it decompresses as well
01:58:57 <Noinia> i.e. given a Source bytestring it can produce a Source bytestring in which the input bytestream is compressed
01:59:18 <Noinia> but it cannot actually produce an archive representing the input files 
01:59:20 <johnw> you mean, you also want the archiving features of zip files?
01:59:29 <inininin> I know, but whenever you group it becomes Ratio Ratio Int
01:59:41 <Noinia> yes
02:00:05 <ttt_fff_> you know, after LYAH + RWH + Beginning Haskell; how does one more on?
02:00:08 <Noinia> essentially I just want to stream into some gernally accepted file 'container' type 
02:00:19 <Noinia> there are zip and tar packages, but they use Lbs 
02:00:25 <ttt_fff_> i.e. how does one move on from "I have read the basic ahkslel books + I can do basica hskell" to "I'm fucking productive with hacakge packages, and can build shit fast"
02:00:26 <EvanR> ttt_fff_: how does one moron do what?
02:00:40 <Noinia> and a zip-conduit, that only deals with files rather than allowing streaming into/onto a Bytestring
02:00:51 <inininin> kuribas: tx
02:00:56 <dramforever> ttt_fff_: calm down and type more slowly
02:01:00 <ttt_fff_> EvanR: how does one become better at ahskell after reading the books and writing basic apps
02:01:05 <ttt_fff_> it's 2am; I should probably be sleeping
02:01:07 <kadoban> ttt_fff_: Write stuff. Maybe look at typeclassopedia and NICTA, write more stuff. Read more stuff, write more stuff …
02:01:28 <EvanR> Noinia: reading a zip file is one thing
02:01:42 <EvanR> streaming into one without known bound...
02:01:50 <dramforever> nicta?
02:01:54 <kuribas> ttt_fff_: write more stuff
02:02:00 <dramforever> kadoban: can you give a link or something?
02:02:02 <kuribas> ttt_fff_: and also write more stuff
02:02:06 <dibblego> dramforever: https://github.com/nicta/course/
02:02:11 <dramforever> good thanks
02:03:17 <dramforever> wait is it suitable for me? I think already know quite a bit of haskell
02:03:26 <Noinia> EvanR: according to http://stackoverflow.com/questions/10947318/streaming-file-archive-created-on-the-fly-in-web-server that can be done 
02:03:31 <dramforever> never mind I'll check myself
02:03:31 <EvanR> i guess its possible for a brand new zip file with only one file
02:03:33 <Noinia> but that solution uses Lbs 
02:03:51 <kuribas> ttt_fff_: I don't feel I am incredibly productive, but it's probably worse when I code C++.
02:04:13 <ttt_fff_> https://github.com/NICTA/course looks badass, collection of cool eercises
02:04:57 <srhb> ttt_fff_: Yep, it's quite good.
02:05:00 <dibblego> The NICTA/course will run next in Sydney in September. It is free. https://groups.google.com/forum/#!topic/nicta-fp/mExd32w0wzc
02:05:50 <kadoban> dibblego: I don't suppose there's ever like web streaming or something?
02:06:03 <dibblego> kadoban: it has been discussed, but never executed.
02:06:19 <dibblego> It was once run simultaneously in two cities, with helpers in the other city
02:07:25 <kadoban> Sounds pretty neat. Yeah I imagine it's much better hands-on, I'd be pretty interested just to see how it's presented and such though even, though I can imagine even that would be quite a lot of work to set up.
02:07:50 <dibblego> CIS194 is compressed in three hours. Now everyone knows haskell. Let's solve problems.
02:09:04 <xtreak> I was designing an isPrime function a fee days back. I thot to check till sqrt of the number for any divisibility. So I generated a list of 3 to sqrt of number. But instead of using sqrt someone suggested to use takeWhile (\x -> x * x < number) [3..] to generate the list. I noticed some performance improvements. Any idea of why. Since I thot a single sqrt function and generating list is better than series of multiplications.
02:09:21 <ttt_fff_> :t fmap
02:09:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:09:24 <ttt_fff_> :t (<$>)
02:09:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:09:36 <ttt_fff_> <$> is just fmap, and is for people who know how to use Functors
02:10:39 <ttt_fff_> hmm, is there a short hand for "pure" ?
02:10:42 <ttt_fff_> or is it just pure ?
02:10:54 <dramforever> this nicta thing reminds me of coq and agda tutorials
02:10:55 <kadoban> xtreak: sqrt is a more complicated thing to do than multiplication, AFAIK it's just plain more computationally expensive. *, at least on something like Int is just an assembly instruction, mostly.
02:11:07 <dramforever> where they just reimplement the world
02:11:35 <ttt_fff_> dramforever: yeah! software oundations!
02:11:39 <ttt_fff_> *software foundations*
02:11:44 <dramforever> ttt_fff_ ++
02:11:45 <ttt_fff_> dramforever: you are smart; I like what you have studied
02:11:51 <dramforever> thanks
02:12:22 <ttt_fff_> dramforever: if you live in the SF area, I'd like to buy you coffee [1] // [1] I promise I'm not a serial #haskell-murderer,
02:12:32 * dramforever takes out his copy of Software Foundations
02:12:37 * hackagebot hopenpgp-tools 0.16.1 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.16.1 (ClintAdams)
02:13:31 <xtreak> Thanks kadoban. I came to know sqrt is implemented at the hardware level and I thought its also a single instruction. Any articles to read abt it?
02:15:19 <kadoban> xtreak: I … don't think there's a sqrt assembly instruction, at least in x86 on integers. I might be wrong though. I … don't really know much in the way of readings for it offhand :-/
02:15:41 <ggole> There are instructions for floating point sqrt
02:15:56 <dramforever> I think there's a sqrt instruction for fl...oh ggole already said that
02:16:22 <ttt_fff_> alright
02:16:26 <ttt_fff_> I'm goign to go master control.applicative
02:16:47 <ggole> (Actually several: x87 instructions, sqrt for different float formats, vector versions for various sizes, etc)
02:17:05 <dramforever> oh til that =)
02:17:41 <ggole> And of course some low end hardware skimps on such extravagances, so I should qualify that with "most machines"
02:18:40 <xtreak> Since sqrt has a floating point type signature can it use that? (Haven't done much assembly. Might be a silly question) . Any idea its used or custom code is used in ghc for sqrt.
02:20:07 <saulzar_> Might depend on the backend - but yeah, fairly safe to say ghc uses the instruction
02:20:10 <dramforever> xtreak: you can check the output for sure
02:20:20 <dramforever> pass -keep-tmp-files to ghc
02:20:27 <ggole> sqrt is defined in terms of a type class: ghc's instances of that type class would probably be intrinsics that lower to those instructions
02:20:40 <dramforever> maybe ghc is smart =)
02:21:24 <saulzar_> Things like quake used to use sqrt approximations because it was faster than using the instruction
02:21:37 <saulzar_> That was quite a while ago
02:22:21 <dramforever> "faster than the instruction" well it's pretty common
02:22:29 <ggole> That was for an approximate reciprocal: there are instructions for that now (on x86-64)
02:22:42 <saulzar_> Ahh
02:22:56 <ggole> Although I'm not sure how the old hack compares
02:23:38 <xtreak> Thanks a lot. Also how does the ghc compiler work in terms of backend does it mean that it uses gcc or llvm to native code. Does ghc have its own code generator?
02:25:13 <saulzar_> All three.. https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/code-generators.html
02:25:15 <dramforever> xtreak: it seems to be the case because the default backend seems to be native code "directly"
02:25:33 <dramforever> oh sure someone knows more than me
02:26:10 <saulzar_> Well you're also right, the direct code gen seems to be the default :)
02:26:35 <alpounet> yes, it is. just pass "-fllvm" on the command line to use the LLVM one
02:26:39 <dramforever> TIL that's called -fasm
02:27:00 <dramforever> I heard that llvm is fast for math, is it?
02:28:20 <saulzar_> Seems to be faster sometimes for numeric stuff, things using Vector etc.
02:29:38 <dramforever> thanks =)
02:29:54 <xtreak> Thanks. Really useful links.
02:49:56 <darenthis> interesting. It says at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/code-generators.html that only LLVM 3.5 is supported but the trac page on cross-compilation insists on LLVM 3.4
02:50:56 <darenthis> I was just starting off trying to build linux binaries from a mac yesterday. Seems a little involved
03:07:40 * hackagebot glue 0.1.2 - Make better services.  https://hackage.haskell.org/package/glue-0.1.2 (seanparsons)
03:09:28 <absence> anyone using the atom editor with ide-haskell? i've gotten it to find and use ghc-mod - "check" works, and some autocomplete pops up - but right clicking an identifier ans electing "show type" or "show info" does nothing
03:14:27 <absence> ah, disable ghc-modi in settings did the trick
03:32:18 <bz> anyone here use cereal? i'm trying to understand the intent behind Data.Serialize.Get.isolate
03:40:12 <Peaker> bz: If you have some data that's supposed to be 20 bytes long, and has its own parser that can consume more, it can be useful to provide it with 20 bytes after which getEmpty is True. Also nice to assert it consumed it all
03:42:41 * hackagebot hbro 1.4.0.1 - Minimal extensible web-browser  https://hackage.haskell.org/package/hbro-1.4.0.1 (koral)
03:42:43 * hackagebot hsqml-datamodel-vinyl 0.3.0.0 - HsQML DataModel instances for Vinyl Rec.  https://hackage.haskell.org/package/hsqml-datamodel-vinyl-0.3.0.0 (mjmrotek)
03:50:04 <Phillemann> A web browser in Haskell, w00t?
03:50:41 <tubert89> For fun, is it possible to overload the semi-colon to be a function name in Haskell? E.g. (;) :: a -> b -> c
03:50:42 <tubert89> ?
03:51:53 <rhaps0dy> why don't you try it ? ;)
03:51:54 <Axman6> no, because ; is haskel syntax
03:51:59 <Axman6> l*
03:52:06 <Axman6> ll* man, what's up with my l key
03:52:49 <tubert89> Axman6: oh well, thanks.
03:52:52 <pavonia> tubert89: You can overload "do { ... ; ... }", IIRC
03:53:31 <rhaps0dy> pavonia, really? How?
03:53:36 <ClaudiusMaximus> -XRebindableSyntax allows you to use whatever (>>) is in scope, which is what do{ a ; b }
03:53:43 <ClaudiusMaximus> desugars to...
03:53:57 <lyxia> Yeah if you squint hard enough the Monad typeclass is how you "overload" (;)
03:54:09 <rhaps0dy> ClaudiusMaximus, neat
03:54:30 <dramforever> tubert89: why are you even doing this...
03:55:38 <tubert89> dramforever: for fun. And pavonia has just given me the idea I was needing, thanks!
03:55:54 <dramforever> also I remebered a blog post that implemented a BASIC interpreter in do-notation
03:56:04 <dramforever> and maybe some typeclass magic
03:56:05 <Axman6> and compiled it to LLVM!
03:56:11 <Axman6> but I can't find it any more :(
03:58:02 <dramforever> > let !!!!!a = undefined in 2
03:58:03 <lambdabot>  <hint>:1:1: parse error in let binding: missing required 'in'
03:58:04 <lamefun> Is there a way to document stuff generated by Template Haskell?
03:58:17 <tubert89> Also I understand why I cannot redefine = because it is a keyword, but it's a shame I cannot define (:=) as a function name
03:58:22 <Sindriava> Set is not a Functor?
03:58:26 <dramforever> >let ! ! ! a = undefined in 2
03:58:32 <dramforever> > let ! ! ! a = undefined in 2
03:58:34 <lambdabot>  <hint>:1:7: parse error on input ‘!’
03:59:04 <dramforever> hmm...I thought https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/bang-patterns.html#bang-patterns-sem said there's pat ::= !pat
03:59:29 <dramforever> :t let (:=) = ($) in negate := 2
03:59:30 <lambdabot>     Not in scope: data constructor ‘:=’
03:59:30 <lambdabot>     Perhaps you meant one of these:
03:59:30 <lambdabot>       ‘:>’ (line 156), ‘Seq.:>’ (imported from Data.Sequence),
03:59:43 <dramforever> tubert89: oh that's because it starts with a colon
03:59:53 <dramforever> and a colon is somehow considered upper case
04:00:07 <tubert89> d'oh ;-)
04:01:12 <Sindriava> dramforever: Colon is considered uppercase because it's reserved for infix data constructors, like (:) for [a] and so on
04:01:26 <dramforever> yes that's what I mean
04:01:41 <dramforever> @let data Foo = Int := Int -- this should work
04:01:43 <lambdabot>  Defined.
04:01:45 <dramforever> @undefine
04:01:46 <lambdabot> Undefined.
04:01:56 <Sindriava> `1 : (2 : (3 : []))` is equivalent to `Cons 1 (Cons 2 (Cons 3 []))`
04:02:10 <Sindriava> dramforever: Sorry, I meant to tag tubert89 ^^'
04:02:18 <dramforever> oh
04:02:28 <dramforever> Sindriava: no there's no Cons in haskell
04:02:42 <Sindriava> Derp, *semantically equivalent
04:03:02 <dramforever> =)
04:03:39 <Sindriava> tubert89: You could define (=:), I guess
04:03:52 <Sindriava> @let (=:) = (+)
04:03:53 <lambdabot>  Defined.
04:04:03 <Sindriava> > 1 =: 2
04:04:04 <lambdabot>  3
04:04:07 <Sindriava> @undefine
04:04:08 <lambdabot> Undefined.
04:05:21 <tubert89> Sindriava: dramforever pavonia : ok folk's, here's a quick challenge.... Can you implement `var v` in the following example https://gist.github.com/anonymous/d34a7c1ca9d5fe3bd4a0 .
04:05:50 <tubert89> I currently say ` v <- newEmptyMVar` , I want to say `var v` .
04:06:10 <Axman6> dramforever: in case you were wondering, I found that post implementing BASIC as a monad (sort of anyway): http://augustss.blogspot.com.au/2009/02/more-basic-not-that-anybody-should-care.html
04:06:19 <martinvlk> @pl (\b -> Just (b, f b))
04:06:19 <lambdabot> Just . ap (,) f
04:06:21 <dramforever> Axman6: =)
04:06:24 <Sindriava> tubert89: I don't think that's possible without TH
04:06:29 <kadoban> tubert89: I wouldn't think you can do that, at least in vanilla haskell. Maybe something in TH?
04:06:32 <dramforever> :t Just . second
04:06:33 <lambdabot> Arrow a => a b c -> Maybe (a (d, b) (d, c))
04:06:40 <kadoban> You can't really add sugar, and you'd kind of need to.
04:06:42 <dramforever> no wrong..
04:07:32 <dramforever> tubert89: this doesn't really seem possible
04:07:48 <dramforever> because v <- newEmptyMVar creates a binder
04:07:52 <tubert89> dramforever: bah humbug :-/
04:08:23 <dramforever> I'm sorry but I'm not a native English speaker
04:08:25 <tubert89> dramforever: so there's no way to flip newMVar to hide <- or >>= .
04:08:32 <dramforever> and I don't understand those weird phrases
04:08:33 <Sindriava> tubert89: Think of it like this. Implementation aside, `var v` takes one argument, and produces `m MVar`
04:08:47 <Sindriava> tubert89: So it's type is `var :: x -> m MVar`
04:08:55 <Sindriava> tubert89: What would that x be?
04:08:56 <tubert89> "bah humbug" ... an English phrase for "that's a pity".
04:09:13 <dramforever> tubert89: I guess you are not supposed to do that, you are basically trying to subvert haskell's syntax
04:09:21 <dramforever> tubert89: okay good to know
04:09:31 <Sindriava> tubert89: See, `v` isn't really anything, it's a label
04:10:32 <tubert89> Sindriava: what about if I alter the example to be:
04:10:46 <tubert89> `var v =: 5` to set an initial value.
04:11:06 <tubert89> I want to use the bound v, without having it on the left hand side of <- or right hand side of >>=
04:11:20 <Sindriava> tubert89: That doesn't really change anything, since function application takes priority over (=:)
04:11:25 <dramforever> it's kinda weird to do so, I have to say
04:11:42 <dramforever> what about something like var "v" =: 5
04:11:47 <dramforever> or even "v" =: 5
04:11:57 <Sindriava> dramforever: That's somehow even worse, I think :D
04:12:05 <dramforever> maybe
04:12:15 <tubert89> dramforever: I realise that it's odd, I'm just playing with how much like a simple C program I can make Haskell look.
04:12:28 <tubert89> (purely as an exercise)
04:12:41 <Sindriava> tubert89: What you'd need for that is TemplateHaskell, so you can *at compile time* transform `var v` into `v <- var`, basically
04:12:45 * dramforever feels funny
04:13:09 <tubert89> Sindriava: which would require learning some TH.. O_o .
04:13:16 <tubert89> I might give that a try.
04:13:28 <dramforever> hey what about inline-c?
04:13:29 <Sindriava> tubert89: Suprisingly, yes :D
04:13:37 <Sindriava> dramforever: inline-c is the shit!
04:13:41 <dramforever> =)
04:13:46 <dramforever> yeah just joking
04:13:55 <tubert89> dramforever: heh, I guess so.. though that's kind of cheating because that's /actually/ C :-)
04:13:58 <Sindriava> dramforever: No really, inline-c is amazing
04:14:23 <dramforever> Sindriava: I said I was joking for exactly what tubert89 said
04:14:31 <Sindriava> dramforever: I see
04:15:04 <Sindriava> tubert89: For example, the Lens package has `makeLenses ''Foo` where Foo is some datatype, which then defines some stuff for you at compile time
04:16:28 <Sindriava> tubert89: You want something very similar, only you transform `var $x` into `$x <- newMVar`. It will happen at compile time and incur no extra overhead. but I'm not sure whether you wouldn't have to write `$(var x)`, when it's not top-level
04:17:14 <dramforever> sure you have to write that $ thing
04:22:07 <Sindriava> Nope, I have no idea how TH is written, I've used macro syntax from somewhere else to illustrate that $x is some kind of variable
04:42:33 <lf94> When is it appropriate to use "from", rather than "to"?
04:42:38 <lf94> (fromInteger, toInteger)
04:42:52 <lf94> Nevermind what a stupid question
04:43:12 <absence> lf94: just look at the types
04:43:15 <kuribas> :t fromInteger
04:43:16 <lambdabot> Num a => Integer -> a
04:43:19 <kuribas> :t toInteger
04:43:20 <lambdabot> Integral a => a -> Integer
04:43:23 <lf94> I did lol
04:43:35 <lf94> Right now I'm converting something to a character
04:43:47 <lf94> toChar :: Letter -> Char
04:43:52 <lf94> But I could also call this
04:43:56 <absence> :t ord
04:43:57 <lambdabot> Char -> Int
04:43:58 <kuribas> :t chr
04:43:59 <lambdabot> Int -> Char
04:44:00 <lf94> fromLetter :: Letter -> Char
04:44:12 <lf94> See my dilemma
04:44:22 <absence> ah, naming convention
04:44:27 <lf94> yeah...
04:44:51 <lf94> toChar feels a little more appropriate
04:44:55 <Freundlich> Why not go for letterToChar?
04:45:10 <lf94> I don't know, I'm using Prelude as a guide :)
04:45:32 <absence> lf94: if you look at the type signatures for fromInteger and toInteger, they're more general in the part of the name that's left out, i.e. fromInteger doesn't say what it converts to because it could be any Num instance
04:45:33 <Freundlich> "anythingToInteger" is just toInteger for short. That makes sense.
04:45:43 <Freundlich> In your case it doesn't, really.
04:45:48 <Sindriava> lf94: You're using 2 concrete types, so do `aToB`
04:46:05 <lf94> Sindriava, thank you. That's the kind of explanation I need :)
04:46:37 <Sindriava> lf94: No prob. Notice that both toInteger and fromInteger have a type variable in the appropriate place
04:47:22 <lf94> Yes, I do.
04:47:34 <Sindriava> lf94: And I'd guess that you're going to use that function to fmap over something, not export it from a module?
04:47:37 <lf94> Because they're both functions of a certain typeclass instance, right?
04:47:45 <lf94> Sindriava, yes
04:47:55 <lf94> +1 psychic powers
04:48:43 <Sindriava> lf94: Then do yourself a favor and don't name it. Naming is the hardest part of programming to get right, and is completely unnecessary most of the time
04:49:08 <Sindriava> lf94: Your question still has merit, no doubt! But in your particular case, I'd probably go for something like:
04:49:44 <Sindriava> ` fmap (\letter -> whatever $ letter) letters `
04:50:06 <lf94> I use pattern matching
04:50:22 <lf94> letterToChar (c,True) = c
04:50:22 <lf94> letterToChar (_,False) = '_'
04:50:39 <Sindriava> Ah, I see.
04:50:45 <lf94> If I needed to use that elsewhere it'd be messy.
04:51:22 <lf94> I'm just refactoring code right now, trying to make things more correct all around
04:51:23 <Sindriava> lf94: How about `fmap (\(c, b) -> if b then c else '_') letters` ?
04:51:29 <lf94> Hence the naming question ;)
04:51:44 <lf94> that's nice too
04:52:40 <lf94> But now I'm going to have a function called "wordToString" hehe
04:53:12 <Sindriava> lf94: Well, there's nothing wrong with making a function called letterToChar, especially if it makes the code more readable.
04:53:24 <lf94> wordToString = fmap (\(c, b) -> if b then c else '_')
04:54:02 <Sindriava> lf94: Another approach could be to instance Show for word?
04:54:11 <absence> lf94: could you use Maybe Char instead of (Char,Bool)?
04:54:18 <Sindriava> show = fmap $ \(c, b) -> if b then c else '_'
04:54:22 <Sindriava> absence: Good point!
04:54:49 <lf94> absence, Bool means if a letter is found or not
04:55:05 <lf94> I don't think Maybe is necessarily correct in this case
04:55:20 <lf94> wordToString = fmap letterToChar
04:55:20 <lf94> letterToChar (c,b) = if b then c else '_'
04:55:25 <absence> lf94: why not? if no letter is found the value is Nothing
04:55:36 <lf94> I guess you're right
04:55:45 <Sindriava> absence: If you don't use the char info in case of False, then Maybe is appropriate
04:55:59 <lf94> Yeah I don't
04:56:05 <exio4> so, you need Maybe
04:56:05 <absence> exactly, otherwise the char info would need to contain dummy data
04:56:06 <lf94> So maybe I should use Maybe
04:56:29 <Sindriava> lf94: You should definitely use Maybe then
04:56:48 <lf94> Oh waaaait, no I do.
04:56:56 <exio4> lf94: also, re "wordToString" / "letterToChar", I dislike those names because the type already says, pretty much
04:56:57 <lf94> I do need that character information if boolean is false.
04:57:04 <exio4> for what?
04:57:23 <lf94> Because they make up the word we're finding.
04:57:24 <lf94> X)
04:57:26 <lf94> Let me gist this...
04:57:30 <exio4> that way you construct the Maybe makes it look like you just have a single value
04:57:33 <Sindriava> lf94: If you squint really hard, (c, True) and (_, False) is roughly equal to Maybe Char, while (a, True) and (b, False) is roughly equal to Either a b
04:57:42 <exio4> lf94: then use a proper sum type 
04:57:43 <lf94> (It won't be runnable because I'm making changes everywhere all at once, hehe...)
04:57:57 <exio4> Sindriava: the second case needs dependent types in the general case :P
04:58:15 <lf94> https://gist.github.com/9145b5721dab70de056e
04:58:21 <Sindriava> exio4: Yeah, I said squint really hard :D
04:58:35 <Sindriava> lf94: Either is the idiomatic way of handling failure with extra data.
04:59:05 <lf94> You can see I've just barely started adding some documentation
05:00:05 <absence> lf94: so the bool represents whether the player has guessed that particular character?
05:00:10 <lf94> Yep!
05:00:31 <lf94> say the word is "hello"
05:00:55 <lf94> [('h',false),('e',false),('l',false),('l',false),('o',false)]
05:01:02 <lf94> would print: '_____'
05:01:17 <lf94> if you guess e, would print: '_e___'
05:01:30 <lf94> Just a silly little toy program but still, I've learned a lot so far
05:01:51 <lf94> Learning how to use StateT has been the most satisfying so far
05:01:54 <absence> right, Maybe Char wouldn't be such a good idea :)
05:03:07 <lf94> I'm definitely creating a Show instance though
05:03:09 <lf94> For Letter
05:03:24 <lf94> maybe Word too?
05:03:34 <exio4>  I'd use newtypes and data types for extra clarity 
05:03:59 <lf94> uh erm for what and why
05:04:09 <lf94> Well, extra clarity
05:04:12 <lf94> but for what exactly
05:04:46 <exio4> instead of (x, Bool), do it like data Letter = Hidden !Char | Guessed !Char
05:05:26 <lf94> Hm
05:05:30 <lf94> What does ! do
05:05:47 <absence> you don't need ! at this point
05:05:54 <lf94> Yeah but what is it
05:05:56 <exio4> it's just an strictness annotation, you don't need it
05:06:07 <lf94> Ok
05:06:14 <lf94> Yea I'll totally change my type to that :)
05:06:19 <lf94> I think that's a good suggestion
05:06:34 <lf94> Just need to do more pattern matching...
05:07:00 <exio4> lf94: by the same, 33-38, maybe using MultiWayIf helps there?
05:07:10 <absence> lf94: not more, just different :)
05:07:34 <lf94> exio4, no I like the case...of
05:07:43 <lf94> Unless MultiWayIf is something else I'm not aware of
05:07:59 <lf94> (I'm thinking if...else if...else if...)
05:08:11 <exio4> multiwayif is basically a guards expression
05:09:01 <lf94> uhm, hm
05:09:07 <lf94> How do I compare a Hidden Char to a Char
05:09:13 <lf94> ...fmap?
05:09:19 <absence> lf94: pattern match
05:09:32 <lf94> I'm blanking here
05:09:37 <lf94> I've done this before with Just
05:09:52 <lf94> case x of Just a -> a, ok i got it
05:10:09 <absence> case blabla of Hidden n -> n == n'; Guessed n -> something_here_as_well
05:10:43 <_d0t> lf94: you can derivce Eq instance for Hidden and then compare Hidden Char's
05:10:50 <dramforever> hmm still working on the hangman? =P
05:10:53 <_d0t> lf94: like hc == pure c
05:11:06 <lf94> I'm trying to fix this "checkGuessed" function
05:11:07 <_d0t> assuming its an applicative
05:11:14 <lf94> My guard statements are not pretty anymore :<
05:11:32 <lf94> dramforever, hell yeah :)
05:11:36 <dramforever> =)
05:11:42 <lf94> dramforever, I'm just constantly improving it
05:11:48 <dramforever> good for you
05:11:51 <exio4> lf94: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/guide-to-ghc-extensions/basic-syntax-extensions (last part)
05:12:11 <lf94> ouuu do i want to be using ghc extensions though...
05:12:34 <int-e> _d0t: what does the `pure` do there? (I expected  hc == Hidden c)
05:12:55 <absence> lf94: actually the Hidden | Guessed type is getting in your way in checkGuess
05:13:05 <lf94> Yes it is
05:13:12 <lf94> I need to return an unmodified version
05:13:13 <exio4> using pattern guards helps there
05:13:17 <lf94> If they're not equal
05:13:29 <exio4> which part of the current code?
05:13:37 <absence> lf94: or wait, maybe not, if you can change how it works
05:13:41 <lf94> checkGuess
05:13:46 <absence> lf94: if it's already guessed you don't need to guess it again
05:13:47 <lf94> Yeah give me a minute
05:15:02 <dramforever> question: I heard that DiffArray allows O(1) updating if only the newest version is accessed
05:15:24 <dramforever> but it's very slow, even slower than normal arrays
05:15:44 <exio4> I am thinking of something like checkGuess _ x@Guessed{} = x ; checkGuess c x@(Hidden c') | c == c'= Guessed c' ; otherwise = x
05:15:45 <dramforever> so has anyone dealt with it?
05:16:06 <lf94> Is "otherwise" allowed in case...of?
05:16:17 <dramforever> lf94: no but you can use _ -> ...
05:16:25 <exio4> you could use a catch all pattern, like _
05:16:36 <lf94> checkGuess c l = case l of
05:16:37 <lf94>                       Hidden a -> a == c = Guessed c
05:16:37 <lf94>                       _ -> l
05:16:41 <saulzar_> lf94, otherwise = True
05:17:01 <lf94> Anything wrong with that
05:17:11 <exio4> lf94: that's nicer, indeed, but you need to use | for adding a guard to a case
05:17:19 <lf94> I'm mutilating the hell out of my code but I'll work out the type errors after
05:17:43 <lf94> Uh, erm, I decided to get rid of the guard?
05:17:47 <lf94> (guards)
05:17:54 <exio4> checkGuess c (Hidden a) | a == c = Guessed c ; checkGuess _ x = x
05:18:15 <lf94> I've opted for just case....of
05:18:18 <exio4> if you want to use the case, case l of Hidden a | a == c -> Guessed c; _ -> l
05:18:21 <absence> lf94: http://lpaste.net/138879
05:18:57 <lf94> Oh.
05:19:02 <absence> lf94: that way the default case is used if the guard fails
05:19:28 <lf94> I don't remember doing this for Just a -> a
05:19:43 <lf94> case x of Just a -> a ; Nothing -> 0 or whatever
05:19:50 <lf94> (Just spitting out examples)
05:19:57 <absence> lf94: probably because you didn't compare the value at the same time?
05:20:17 <absence> lf94: the guard is there to check the guess
05:20:23 <lf94> right, ok
05:21:02 <lf94> So we have a pattern match, a guard, then the actual computation (well, return)
05:21:10 <indiagreen> why does cabal install an older version of a package when a new version is already installed? specifically, see this log: https://travis-ci.org/aelve/microlens/jobs/75723089 (first microlens-0.3 is installed, then microlens-mtl downloads microlens-0.2 even tho 0.3 should already be in the global database)
05:21:10 <lf94> Aiiiight
05:21:20 <absence> lf94: you COULD also do it without a guard, but it's messier: Hidden x -> if x == c then Guessed x else l
05:22:40 <absence> lf94: without the guard, the Hidden case is executed regardless of its contents, but with the guard the Hidden case is only executed if the condition succeeds, falling through to the next case otherwise
05:23:44 <lf94> absence: I see I see
05:23:53 <absence> indiagreen: microlens-mtl explicitly depends on 0.2
05:24:00 <lf94> How do I do I where statement that will extract the character
05:24:05 <lf94> where x = Hidden y
05:24:06 <lf94> let?
05:24:08 <absence> indiagreen: https://hackage.haskell.org/package/microlens-mtl <- see here
05:24:22 <lf94> no, that wouldn't change anything
05:24:29 <indiagreen> absence: but on Travis it's installed from the repository
05:24:47 <absence> lf94: what do you mean?
05:24:49 <indiagreen> absence: and there it depends on >=0.2 && <0.4
05:25:34 <absence> indiagreen: oh, then i don't know
05:25:55 <lf94> absence, I'm trying to fix my complete function now (very bottom)
05:26:04 <lf94> I've done this, which is really nice
05:26:06 <lf94> complete (x:xs) = case x of
05:26:06 <lf94>   Hidden x -> return False
05:26:06 <lf94>   Guessed x -> complete xs
05:26:25 <lf94> But I'm just curious now, how would I extract x if I had just that where statement?
05:27:28 <dramforever> that looks function like all isGuessed, if you had an isGuessed function
05:27:48 <absence> lf94: you need to rewrite the function due to the changed type
05:27:57 <lf94> I did
05:28:04 <lf94> What I've pasted
05:28:06 <lf94> heh
05:28:08 <dramforever> which actually makes me think, maybe you should separate the Guessed flag and the character
05:29:25 <absence> lf94: you now have a "either type" (or sum type), so you can't extract a character from it without considering both cases (hidden and guessed)
05:30:21 * int-e would probably just have a string to be guessed and a string of characters already guessed; it's simple and should be efficient enough.
05:30:23 <exio4> well, you can 
05:31:03 <exio4> data Letter = Guessed { getLetter :: Char } | Hidden { getLetter :: Char }
05:31:17 <dramforever> I wonder if we could do this
05:31:24 <dramforever> data Status = Guessed | Hidden
05:31:50 <dramforever> oh sorry 1. didn't really put the char in
05:31:53 <int-e> (Then, if I get worried about performance, I'd switch to Data.Set for the latter, but I don't see the point, assuming this is for interactive use.)
05:32:02 <dramforever> 2. didn't see that exio4 already posted one
05:33:09 <lf94> Well I don't know what you guys are saying, but it's working: https://gist.github.com/3247914f564778d342b9
05:33:45 <lf94> Going to create Show instances of HangmanState and Letter
05:36:03 <lf94> Excellent advice though guys, that was some perfect stuff.
05:36:07 <absence> lf94: http://lpaste.net/138886 <- something to think about
05:36:16 <absence> (it's "complete")
05:36:30 <absence> er..
05:36:37 <absence> i think it might not typecheck as is
05:36:45 <absence> but you probably get the idea
05:36:52 <exio4> @type all -- absence 
05:36:53 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
05:36:58 <exio4> you don't need the map
05:37:02 <absence> yes, i just remembered :)
05:37:03 <absence> thanks
05:37:06 <exio4> all isGuessed 
05:37:13 <lf94> Yeah
05:37:32 <dramforever> :t and -- if you really want the map
05:37:34 <lambdabot> Foldable t => t Bool -> Bool
05:37:36 <lf94> I tried using foldr on time too
05:37:38 <dramforever> (yes pun intended)
05:37:46 <lf94> one*
05:38:10 <lf94> Is there something fundamentally wrong with my new recursive complete though?
05:38:41 <absence> lf94: it's generally better to express your solutions in terms of existing recursion primitives rather than use explicit recursion
05:38:50 <lf94> Gotchya
05:38:58 <lf94> I'll go ahead and change that too then
05:39:03 <exio4> lf94: "all isGuessed" tells the reader exactly what you wanted directly
05:39:08 <absence> lf94: it's like using "for" or "while" in imperative programs instead of "goto label"
05:39:15 <lf94> exio4, yeah I see X)
05:39:21 <lf94> heh
05:39:49 <exio4> (and the less explicit recursion you use, the easiest it is to change data structures!)
05:40:22 <absence> hooray!
05:40:47 <lf94> On second thought...I will not create instances of show.
05:40:50 <lf94> Because of this:
05:40:51 <lf94> The result of show is a syntactically correct Haskell expression containing only constants, given the fixity declarations in force at the point where the type is declared. It contains only the constructor names defined in the data type, parentheses, and spaces. When labelled constructor fields are used, braces, commas, field names, and equal signs are also used.
05:41:08 <dramforever> =)
05:41:20 <dramforever> just write a pretty print function
05:41:23 <lf94> Yep
05:41:31 <lf94> Someone here suggested Show
05:41:44 <dramforever> show is like repr in python
05:43:02 <absence> "illegal" show instances are often good for debugging
05:47:58 <lf94> It's not proper though
05:48:12 <lf94> You're supposed to be able to use Read with it
05:48:26 <lf94> IMO that's some nice functionality if you follow what it asks
05:49:28 <dramforever> > text "a\nb"
05:49:30 <lambdabot>  a
05:49:30 <lambdabot>  b
05:49:37 <dramforever> :t text
05:49:39 <lambdabot> String -> Doc
05:50:00 <dramforever> oh sorry I'll go to /query
05:53:11 <lf94> How do "let"s fit into the whole monad thing
05:53:22 <dramforever> as syntax sugar
05:53:38 <lf94> Ah
05:53:38 <dramforever> do { let x = e; ... } -> let x = e in do {...}
05:53:51 <lf94> Cool :)
05:54:10 <lf94> Is it possible to see...to see a program "desugared"? 
05:54:40 <lf94> I bet that'd be fairly educational
05:57:26 <dramforever> "educational" hmm...
05:57:27 <int-e> lf94: ghc -fforce-recomp -ddump-ds hangman.hs  prints the desurgared core after typechecking ... looks quite verbose with all types explicit
05:57:52 <dramforever> int-e: wow thank you I didn't know that before
05:58:08 <dramforever> there seems to be a lot of -ddump-... options
06:00:17 <absence> lf94: yes, that's why i said for debugging :)
06:00:24 <dramforever> =)
06:02:26 <hexagoxel> indiagreen: maybe cabal simply is too stupid to consider the user-globally-installed package?
06:02:43 <indiagreen> hexagoxel: nope, I already found out what the problem was
06:02:50 <hexagoxel> ah, do tell
06:05:29 <indiagreen> microlens: “aha, transformers-0.3, I'm fine with that”. microlens-mtl: “I want transformers-0.4.3, so I have to reinstall microlens, but I no longer know where the source is, so I'll download it”
06:06:36 <hexagoxel> solution: sandboxes? :D
06:07:47 * hackagebot superdoc 0.1.2.2 - Additional documentation markup and Unicode support  https://hackage.haskell.org/package/superdoc-0.1.2.2 (PeterSelinger)
06:07:50 <indiagreen> hexagoxel: yeah, I'm already modifying .travis.yml
06:10:31 <lf94> int-e, thank you!
06:14:58 <Avonis> so Lisp vs Haskell, let the Func Games begin !
06:15:17 <lf94> Haskell
06:16:26 <dramforever> Avonis: ?
06:16:29 <xelxebar> ↑ Well, this sounds delightful. What are we talking about here?
06:16:48 <dramforever> Avonis: what's going on? did I miss something?
06:17:03 <Avonis> well, I'm getting into Haskell, and some people are saying learn Lisp instead 
06:17:22 <Avonis> but I'm rooting for Haskell already 
06:17:28 <dramforever> do you have enough time?
06:17:34 <dramforever> if so learn both =P
06:17:40 <Avonis> lel
06:17:45 <dramforever> (no, I'm only half joking)
06:19:21 <lf94> Avonis, Haskell will teach you many more things than Lisp.
06:19:44 <Avonis> lf94, I'll keep up with it 
06:19:45 <lf94> And it'll teach you more functional programming patterns 
06:19:58 <dramforever> Avonis: do you know other programming languages
06:20:00 <dramforever> ?
06:20:14 <Avonis> C/C++, Java, Python ...
06:20:21 <dramforever> ok then
06:20:30 <lf94> Yeah watch out, Haskell is going to bite you in the butt
06:20:36 <lf94> Forget everything you've ever learned
06:20:59 <__monty__> IMHO, the fact that Haskell has a static type system is more conducive to the learning experience. The fact that you have to be explicit on a more abstract level (types) makes it easier to start thinking at that level.
06:21:06 <dramforever> Avonis: you have to be patient
06:21:39 <Avonis> dramforever, yep, this is my firs experience with functional programming 
06:21:45 <xelxebar> You could try this https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
06:22:05 <dramforever> I remembered hio asking "why there isn't anything on haskell.org that tells me how I can access a SQL database?"
06:22:40 <dramforever> he/she expects to be able to get started with those stuff immediately just by looking at some example code snippets
06:22:48 * hackagebot easyrender 0.1.1.0 - User-friendly creation of EPS, PostScript, and PDF files  https://hackage.haskell.org/package/easyrender-0.1.1.0 (PeterSelinger)
06:22:55 <lf94> Avonis: You can start with my New Training Program (tm). Your first assignment is writing a Hangman game.
06:23:05 <absence> haha
06:23:22 <dramforever> and I answered "No it's impossible, you need to learn the basics first, and you can't skip this because what you have learnt does not translate to haskell"
06:23:27 <lf94> Seriously, should take him like 6 months on and off to write it
06:23:34 <Avonis> dramforever, nice, I'm following this one http://learnyouahaskell.com/chapters
06:24:04 <absence> Avonis: that's a good place to start
06:24:04 <dramforever> interestingly, I also figured out the answer to this question: "Why are #haskell people *that* friendly?"
06:24:11 <lf94> LearnYouAHaskell was terrible for me.
06:24:18 <dramforever> Answer: "because we are patient enough to learn haskell"
06:24:28 <Avonis> dramforever, amen
06:24:31 <edk> i enjoyed LYAH but i'm not sure it taught me very much
06:24:42 <lf94> Yeah it's enjoyable to read
06:24:48 <lf94> But I could not retain anything
06:25:02 <__monty__> I don't understand FlexibleInstances, why do I need them here, http://lpaste.net/138888? I've read this, https://ghc.haskell.org/trac/haskell-prime/wiki/FlexibleInstances, and bits of this, https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html, but they haven't revealed their infinite knowledge to me yet.
06:26:11 <__monty__> LYAH is a very gentle introduction to fp though, I don't think it tries to make you an expert, so I think its scope is very good for a beginner.
06:26:33 <xelxebar> I'm enjoying Brent Yorgey's course at the moment.
06:26:34 <dramforever> wow
06:26:40 <Avonis> __monty__, yep, that's what I'm sticking with it 
06:26:44 <Avonis> *why
06:26:46 <dramforever> TIL you could write {-# language ... #-}
06:26:49 <dramforever> in lower case
06:27:04 <__monty__> dramforever: I TIL'd that too : )
06:27:08 <dramforever> =)
06:27:18 <fr33domlover> Q: can I mix "exceptions" package with Control.Exception? e.g. freely throw using one and catch using the other?
06:27:23 <lf94> I TIL'd that three
06:27:30 <dramforever> weird
06:27:43 <lf94> (I TIL'd it just now)
06:27:44 <dramforever> now I changed those language pragmas to upper case
06:28:03 <dramforever> and ghc seems to behave differently
06:28:36 <bennofs> fr33domlover: I think you should be able to do that
06:28:49 <dramforever> specifically I thought I had MultiParamTypeClasses on the 2nd line, but ghc still seems to complain that it needs MPTC
06:29:19 <__monty__> dramforever: My GHC doesn't seem to behave differently, I'm using 7.6.3 on ubuntu.
06:29:20 <bennofs> dramforever: try -Wall. Maybe you also get a "Unkown pragma warning"
06:29:38 <dramforever> ok then
06:29:53 <dramforever> my mistake
06:29:56 <dramforever> sorry
06:30:01 <Sindriava> How do I truncate Double to float?
06:30:16 <dramforever> :t realToFrac
06:30:17 <lambdabot> (Fractional b, Real a) => a -> b
06:30:23 <Sindriava> thx <3
06:30:28 <dramforever> wait
06:30:35 <dramforever> Sindriava: are you sure it's what you want?
06:30:38 <dramforever> do test it
06:30:41 <lspitzner> :exf Float -> Double
06:30:42 <exferenceBot> realToFrac
06:30:47 <dramforever> hmm
06:30:49 <absence> :t double2Float
06:30:51 <lambdabot> Not in scope: ‘double2Float’
06:31:00 <absence> :t GHC.Float.double2Float
06:31:01 <lambdabot> Double -> Float
06:31:13 <dramforever> wow who is that exferenceBot?
06:31:24 <Sindriava> dramforever: Yah, I've using floats and GLFW returns double as the cursor position, but given it's a cursor position (e.g. integral O.o), it's pretty safe to convert it
06:31:30 <Sindriava> *I'm
06:31:30 <dramforever> :exf (a -> b -> c) -> (a -> c) -> b -> c
06:31:35 <dramforever> Sindriava: =) ok then
06:31:53 <dramforever> no more exference
06:32:02 <Sindriava> exference as the opposite of inference? Me like
06:32:13 <fr33domlover> bennofs, thanks
06:32:22 <exferenceBot> could not find expression
06:32:24 <lspitzner> well you do not give it an `a`
06:32:51 <dramforever> ouch sorry
06:32:58 <dramforever> :exf (a -> b -> c) -> (a -> b) -> a -> c
06:32:59 <exferenceBot> \ b c d -> b d (c d)
06:33:02 <dramforever> looks good
06:33:59 <lspitzner> :exf "(a -> b) -> [[[[[a]]]]] -> [[[[[b]]]]]"
06:34:11 <Sindriava> ʕ  •ᴥ•ʔ
06:34:14 <exferenceBot> \ b -> fmap (fmap (fmap (fmap (fmap b))))
06:34:19 <__monty__> It's not really the opposite of inference though, more like the dual.
06:34:36 <Sindriava> __monty__: Fair enough, bad wording on my part
06:34:59 <Sindriava> I guess the opposite of inference would be generalisation?
06:35:08 <lspitzner> special thing about exference is that it knows typeclasses; djinn does not
06:37:11 <__monty__> Let me repeat my paste because I think the lowercaseness of the pragma's kind of distracted from my problem: http://lpaste.net/138888
06:38:37 <Sindriava> :exf Float -> Double
06:38:38 <exferenceBot> realToFrac
06:39:19 <voidzero> :exf String -> Text
06:39:19 <afons> Is there any function that does (x : xs) ++ [x]
06:39:29 <afons> given x as xs
06:40:02 <lspitzner> voidzero: Text is not in the env (yet)..
06:40:07 <exferenceBot> could not find expression
06:40:16 <Sindriava> afons: Eh, what?
06:40:17 <voidzero> ok
06:40:19 <voidzero> nice bot!
06:40:22 <Sindriava> afons: Could you elaborate a bit more?
06:40:42 <afons> Example, surround 1 [2, 3] ->> [1,2,3,1]
06:40:48 <Sindriava> Aaaaah
06:41:01 <Sindriava> what confused me was "given x as xs" o.o
06:41:01 <afons> surround "'" "hello" -> "'hello'"
06:41:06 <afons> and*
06:41:10 <Sindriava> AAAAAAH
06:41:37 <Sindriava> I *think* there's something in Data.List, gimme a sec
06:42:19 <__monty__> If there is, I haven't come across it. I usually do x ++ xs ++ x.
06:42:53 <afons> surround :: a -> [a] -> [a]
06:42:53 <afons> surround x xs = (x : xs) ++ [x]
06:44:31 <exio4> concat [[x], xs. [x
06:44:39 <afons> ?
06:44:43 <Zemyla> afons: Wouldn't it be slightly better as surround x xs = x:(xs ++ [x])?
06:44:50 <afons> yeah
06:44:54 <exio4> concat [[x], xs. [x]] -- I mean this one
06:45:03 <afons> what is that dot?
06:45:06 <Sindriava> *,
06:45:40 <exio4> I shouldn't try to answer from my phone, sorry
06:45:48 <Sindriava> afons: I can't find anything, I guess just write it yourself, since it's a one-liner
06:46:06 <__monty__> Zemyla: If you really care about that speed difference, I think it's time to look into a different data structure : )
06:46:29 <Sindriava> afons: Also, don't constrain it to List i guess
06:46:56 <voidzero> > [1] <> [2,3,4] <> [1]
06:46:59 <lambdabot>  [1,2,3,4,1]
06:47:07 <afons> What is <>
06:47:10 <afons> is it `mappend?
06:47:12 <voidzero> mappend
06:47:16 <Sindriava> Yah
06:47:30 <Sindriava> Is there `pure` for Monoids?
06:47:38 <afons> yeah
06:47:44 <exio4> which type would that have?
06:47:56 <Sindriava> Monoid m => a -> m a ?
06:48:03 <Sindriava> That's weird, nah
06:48:12 <exio4> @type mappend 
06:48:13 <lambdabot> Monoid a => a -> a -> a
06:48:21 <exio4> it doesn't take a parameter, or anything
06:48:24 <Sindriava> oh yeah
06:48:34 <exio4> if you want that kind of stuff, you probably want something like MonadPlus
06:49:35 <indiagreen> :t empty
06:49:36 <lambdabot> Alternative f => f a
06:49:59 <Sindriava> lambdabot guesses a random type? O.o
06:50:16 <Sindriava> :t empty :: Set
06:50:17 <lambdabot>     Not in scope: type constructor or class ‘Set’
06:50:17 <lambdabot>     Perhaps you meant one of these:
06:50:17 <lambdabot>       ‘S.Set’ (imported from Data.Set),
06:50:25 <Sindriava> oh
06:51:49 <afons> I want to have a class that "render stuffs" 
06:52:00 <afons> it will have only one function called "render" that converts values to strings
06:52:04 <afons> what should the class be called?
06:52:05 <afons> Render ?
06:53:08 <indiagreen> Display, maybe
06:53:19 <bananagram> :t mempty
06:53:20 <lambdabot> Monoid a => a
06:54:38 <lspitzner> voidzero: i added pack/unpack now :)
06:54:41 <joneshf-laptop> I think i'm having a brain fart, but is there an idea like: https://gist.github.com/joneshf/a931736a2eb9d096b072
06:55:08 <joneshf-laptop> It looks sort of comonadic, but I don't think i've had enough sleep to pursue that path
06:57:50 * hackagebot hopenpgp-tools 0.16.2 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.16.2 (ClintAdams)
06:59:49 <kuribas> can the ST monad be used in a parallel computation?
07:00:06 <afons> Is there a better way to make a singleton out of x? instead of (:[])
07:04:27 <lf94> Haskell is seriously starting to become addictive.
07:04:59 <absence> afons: pure
07:05:33 <absence> afons: depending on your opinion of "better"
07:05:47 <afons> clearer
07:05:51 <afons> that only works for singletons
07:05:56 <afons> for example that would work [1] : []
07:06:09 <afons> I want it to only pass for [x]
07:06:33 <Sindriava> > pure 1 :: [Int]
07:06:34 <lambdabot>  [1]
07:07:17 <Sindriava> liftA2 (:) pure id $ 1 [1, 2, 3]
07:07:20 <Sindriava> > liftA2 (:) pure id $ 1 [1, 2, 3]
07:07:22 <lambdabot>      Occurs check: cannot construct the infinite type: r ~ [f r]
07:07:22 <lambdabot>      Expected type: r -> [f r]
07:07:22 <lambdabot>        Actual type: [f r] -> [f r]
07:07:23 <__monty__> afons: The class you're describing sounds a lot like Show.
07:07:27 <Sindriava> > liftA2 (++) pure id $ 1 [1, 2, 3]
07:07:28 <lambdabot>      Occurs check: cannot construct the infinite type: r ~ [r]
07:07:28 <lambdabot>      Expected type: r -> [r]
07:07:28 <lambdabot>        Actual type: [r] -> [r]
07:08:16 <__monty__> afons: What's wrong with [x]?
07:08:45 <absence> i assume he wants pointfree since he said (:[])
07:09:40 <afons> (:[]) works for every kind of input
07:09:45 <afons> I want it to only work for non-lists
07:10:12 <absence> afons: uh what? you want to restrict the contents of the list?
07:10:13 <nshepperd> are you sure you want that?
07:10:40 <Sindriava> > []:[]
07:10:42 <lambdabot>  [[]]
07:10:57 <nshepperd> non-x constraints are not generally useful in haskell
07:11:27 <nshepperd> non-type constraints, I should say
07:11:58 <Sindriava> Sometimes, I really wish Haskell was a bit more clever when it comes to number constants
07:12:00 <absence> afons: i think that at this point it would be helpful if you could provide some context for your question :)
07:12:11 <absence> afons: code example?
07:12:17 <afons> The result must be a one-dimension singleton list
07:12:23 <afons> 2 : [] passes
07:12:29 <afons> [2] : [] can't happen
07:12:38 <Sindriava> afons: yeah, `pure`
07:12:46 <nshepperd> afons: what's wrong with [[2]]
07:12:52 <absence> afons: i'm not sure that's possible
07:13:00 <Sindriava> > pure 1 :: [Int]
07:13:02 <lambdabot>  [1]
07:13:07 <Sindriava> > pure [2] :: [Int]
07:13:08 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘[Integer]’
07:13:08 <lambdabot>      In the first argument of ‘pure’, namely ‘[2]’
07:13:08 <lambdabot>      In the expression: pure [2] :: [Int]
07:13:10 <nshepperd> afons: that's a one-dimension singleton list containing a [2]
07:13:31 <absence> Sindriava: you don't need pure for that though
07:13:36 <Sindriava> nshepperd + 1, I think you're getting really tangled in it afons.
07:13:39 <absence> > [2] : [] :: [Int]
07:13:41 <lambdabot>      Couldn't match expected type ‘Int’ with actual type ‘[Integer]’
07:13:41 <lambdabot>      In the first argument of ‘(:)’, namely ‘[2]’
07:13:41 <lambdabot>      In the expression: [2] : [] :: [Int]
07:14:00 <bernalex> this smells of xy-problem.
07:14:03 <Sindriava> absence: I didn't say you needed it ¯\_(ツ)_/¯ It's point free, though
07:14:07 <voidzero> i'm totally lost
07:14:09 <Sindriava> bernalex: I was just about to post that link
07:14:28 <absence> Sindriava: fair enough
07:14:48 <voidzero> what's singleton anyway? a list with one item?
07:15:04 <afons> yes
07:15:07 <Sindriava> absence: It was a response to `(:[])`, which is far more unreadable than `pure :: [a]`
07:15:11 <bernalex> afons: [[[]]] is a singleton then.
07:15:11 <Sindriava> afons: http://xyproblem.info
07:15:20 <Sindriava> bernalex + 1
07:15:29 <afons> I am not falling into the xy problem
07:15:43 <afons> I want a function that takes a value that is not a list, and makes a singleton out of it.
07:15:53 <bernalex> afons: why?
07:15:55 <Sindriava> afons: Again, *pure*
07:16:01 <bernalex> that doesn't sound very useful
07:16:06 <nshepperd> afons: no, I don't think you do
07:16:16 <Sindriava> afons: Is this still about the surround thing?
07:16:22 <afons> no
07:16:25 <nshepperd> firstly, putting a restriction like that breaks parametricity
07:16:25 <absence> afons: lists are defined something like this: "data [a] = [] | a : [a]" 
07:16:34 <absence> afons: it means that ANY a can be used
07:16:39 <absence> afons: you can't restrict it
07:16:42 <bernalex> nshepperd: yes it's hideous in addition to being nonsense.
07:16:59 <voidzero> well
07:17:01 <absence> unless you specify the container type to e.g. Int
07:17:02 <voidzero> let's start with
07:17:08 <voidzero> *why* should it be restricted?
07:17:15 <Sindriava> afons: Look, if you want that, you can go with "foo :: whatever -> [whatever]" and "foo = pure"
07:17:18 <nshepperd> afons: "one dimensional" doesn't mean that the contents isn't a list, it just means that you don't care what the contents is
07:17:27 <Sindriava> afons: But arguably, what you want is weird and you shouldn't want that
07:17:49 <bernalex> haskell doesn't have a way of specifying "all but a". that usually doesn't work well anyway.
07:18:56 <absence> afons: again, could you paste some code showing what you try to do?
07:19:01 <__monty__> afons: bernalex is right, even if you exclude lists, what's to say that you don't get a different collection? A Map for example.
07:19:38 <absence> afons: i'm sure the goal here is somewhat higher level than "make a list that contains something that isn't a list", maybe we can better help you if you let us know what you're really trying to do
07:19:49 <voidzero> indeed
07:21:46 <Sindriava> *chirp chirp*
07:22:56 <supki> bernalex: well, GHC Haskell certainly does: http://lpaste.net/1927934321511890944
07:23:18 <joneshf-laptop> maybe afons would have responded by now if there wasn't a wall of, "You're doing it wrong"...
07:24:47 <bernalex> supki: yes. it's just not pretty. how well does inference work for that?
07:26:04 <nshepperd> people do tend to pile on a bit
07:27:51 * hackagebot uniform-io 0.2.0.0 - Uniform IO over files, network, watever.  https://hackage.haskell.org/package/uniform-io-0.2.0.0 (marcosdumay)
07:31:15 <Sindriava> joneshf-laptop: To be honest, there was enough people trying to get to the bottom of what he's trying to do
07:31:48 <Sindriava> joneshf-laptop: And there isn't a wall of "you're doing it wrong", but "you probably want something else"
07:32:03 <supki> bernalex: dunno; it probably works well enough in a big enough program
07:32:14 <bernalex> supki: nice
07:32:15 <supki> definitely sucks in REPL though
07:35:18 <afons> @q surround x xs = x : (xs ++ [x])
07:35:18 <lambdabot> Maybe you meant: queue-topic quit quote v @ ? .
07:35:32 <afons> forgot the point free command
07:35:36 <afons> what was it?
07:35:38 <afons> @r surround x xs = x : (xs ++ [x])
07:35:38 <lambdabot> Maybe you meant: rc reconnect remember repoint roll run v @ ? .
07:35:40 <afons> @p surround x xs = x : (xs ++ [x])
07:35:40 <lambdabot> Maybe you meant: palomer part paste ping pinky pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pop-topic pretty print-notices protontorpedo purge-notices push-topic v @ ? .
07:35:43 <bernalex> afons: pointfree.
07:35:45 <[k-> @pl
07:35:45 <lambdabot> (line 1, column 1):
07:35:45 <lambdabot> unexpected end of input
07:35:45 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
07:35:48 <afons> @pl surround x xs = x : (xs ++ [x])
07:35:48 <lambdabot> surround = liftM2 (.) (:) (flip (++) . return)
07:36:00 <bernalex> oh right lambdabot calls it pointless.
07:36:08 <bernalex> the program is called pointfree though.
07:36:32 <bernalex> I wish it were called pointless really, for better tab completion with regards to pointful.
07:37:06 <nshepperd> 'pointless' is really a more accurate name too, given how horribly unreadable the results usually are
07:37:29 <int-e> @pointful flip id
07:37:30 <lambdabot> (\ b c -> c b)
07:37:40 <bernalex> nshepperd: I think it's a very useful command for giving you some "a-ha" moments after a long workday. but they way it's usually used here on IRC is uhm. yeah.
07:37:51 <nshepperd> hehe
07:39:37 <lf94> I'm looking at these 2 alternative hangman games on hackage
07:39:46 <lf94> Holy shit...they are way more wacky than my version.
07:40:09 <hodapp> alternative hangman?!
07:40:27 <lf94> https://hackage.haskell.org/packages/search?terms=Hangman
07:42:49 <lf94> Compare those with this: https://github.com/lf94/Hangman/blob/master/Hangman.hs
07:42:51 * hackagebot yesod-raml 0.1.1 - RAML style route definitions for Yesod  https://hackage.haskell.org/package/yesod-raml-0.1.1 (junjihashimoto)
07:43:39 <lf94> The only thing different is I don't choose a random word
07:43:46 <lf94> But I'm just being lazy because it's late right now
07:43:48 <greves> can someone explain to me about guards vs just writing the function name multiple times? https://dpaste.de/a3Fa
07:44:19 <lf94> A guard is a condition you have to satisfy
07:44:36 <lf94> -- works, is a pattern match
07:44:55 <greves> ah right
07:44:58 <lf94> It will match any Foo _, that's why it works
07:45:09 <greves> so the guard doesn't work because i'm not actually doing any comparison
07:45:11 <nshepperd> function guard syntax is like a multi-way if state
07:45:48 <absence> greves: you're doing a pattern match instead of a comparison in your guard
07:45:50 <nshepperd> if the left part evaluates to True, we take that branch, otherwise we move on to the next one
07:45:55 <greves> right
07:46:04 <lf94> Does a pattern match even evaluate to Boolean
07:46:09 <absence> no
07:46:10 <lf94> do you get a syntax error
07:46:13 <lamefun> In Template Haskell, can I go from Q (TExp a) to a somehow? Or generate code that does splices itself?
07:46:13 <greves> got it. i read that earlier but sometimes things don't stick til you come across it in practice :P
07:46:58 <__monty__> greves: You can do pattern matching in guards with "pattern guards" btw.
07:47:19 <absence> greves: use a guard if you want additional checks on whatever you pattern match, e.g. fn (Foo a) | a < 0 = -a
07:47:36 <greves> right, you can combine guards with each pattern ya?
07:48:28 <lf94> yeah
07:48:29 <absence> greves: yes, a guard is local to one equation
07:48:50 <xtreak> Are there any good maths book or papers to start that will help me to experience the beauty of maths. I always see people telling great abt category and algebra. But my clg maths was terrible. May be I am on the wrong channel to ask. But is there any book preferably free to start maths that will help my fp experience.
07:48:57 <absence> greves: i don't think you can provide one guard that affects all the pattern matches
07:49:32 <benzrf> i dunno xtreak
07:49:55 <nolrai66> absence: you could guard then case _ of.
07:50:30 <absence> xtreak: i've seen it mentioned several places that maths won't help you much until you get into quite advanced fp
07:51:00 <absence> nolrai66: how do you mean?
07:51:07 <obb> why does the length function return ant Int instead of an Integer?
07:52:05 <absence> :t genericLength
07:52:06 <lambdabot> Num i => [a] -> i
07:52:23 <absence> obb: api inconsistency maybe
07:52:52 * hackagebot yesod-raml 0.1.2 - RAML style route definitions for Yesod  https://hackage.haskell.org/package/yesod-raml-0.1.2 (junjihashimoto)
07:52:56 <benzrf> dont use genericlength
07:52:57 <geekosaur> because the language committee figured nobody would make a list that wouldn't fit in memory >.>
07:52:58 <benzrf> @google dont use genericlength
07:52:59 <lambdabot> https://github.com/quchen/articles/blob/master/fbut.md
07:54:29 <nshepperd> 'genericLength is literally the naive 1 + length rest implementation' O_O
07:54:54 <nshepperd> not even a strict fold...
07:54:59 <xtreak> absence, is there any place to start maths as u get to advanced fp. Its just that I am curious. Also am open for suggestions in basic maths too. Any book or resource that spurs the spark for more maths but a good one for beginner.
07:56:15 <benzrf> hold onn
07:56:22 <benzrf> https://github.com/quchen/articles/blob/master/fbut.md#a-op-is-not-x---a-op-x
07:56:26 <benzrf> isnt that ^ an extension?
07:56:30 <obb> how can i find out the max int on my system?
07:56:31 <benzrf> by default arent they the same
07:56:35 <Zemyla> Hmm, you know, there was a time when I accidentally reinvented Attoparsec.
07:56:36 <benzrf> :t max
07:56:36 <obb> or is it always the same?
07:56:37 <lambdabot> Ord a => a -> a -> a
07:56:40 <benzrf> er, wait
07:56:53 <Zemyla> > maxBound :: Int --obb
07:56:54 <lambdabot>  9223372036854775807
07:57:02 <benzrf> yeah >.>
07:57:34 <Zemyla> It was nowhere near as polished, but it had the Failure/Partial/Success thing and worked on Bytestrings.
07:57:39 <nshepperd> yeah Int can vary in size
07:57:43 <irrequietus> one of the best ways to understand something that keeps putting you down is to force yourself into it through excessive practice
07:57:52 * hackagebot yesod-raml 0.1.3 - RAML style route definitions for Yesod  https://hackage.haskell.org/package/yesod-raml-0.1.3 (junjihashimoto)
07:58:14 <irrequietus> this isn't important per se in understanding that thing
07:58:17 <absence> xtreak: i don't really know much about it, but abstract algebra and category theory are probably the most useful. from my limited experience with books on those fields it's somewhat heavy material :/
07:58:24 <geekosaur> benzrf, isn't which an extension?
07:58:26 <irrequietus> but it opens up the dependencies of what you NEED to know in order to understand
07:58:34 <irrequietus> so, practice practice practice
07:58:47 <geekosaur> or are you confusing a section on a prefix-to-infix with postfix operators extension?
07:58:49 <absence> xtreak: you don't need any of that to understand how to use haskell's functors, monads, monoids, etc though
07:59:02 <geekosaur> the article is about the former
07:59:31 <nshepperd> hmm, is there any reason no one added a fixed genericLength that runs strictly?
08:00:13 <absence> xtreak: there are a bunch of "what books should i read" questions around on the net (e.g. on stackoverflow iirc) if you want to check it out
08:00:19 <benzrf> geekosaur: postfix syntax
08:00:24 <nshepperd> genericLength' = foldl' (\n _ -> n + 1) 0
08:00:28 <geekosaur> yes, that is not about postfix
08:00:38 <xtreak> absence, thanks. I was watching and reading some popular articles and videos on monads. But I still couldn't grok them. :(
08:00:51 <geekosaur> it's just a section, with the operator being a ``
08:00:52 <benzrf> its saying that (4!) in ghc is actually (!) 4 instead of \x -> 4 ! x
08:01:03 <benzrf> which is what the postfix operators extn does
08:01:10 <absence> xtreak: you don't need any maths to understand how they work in haskell, it will probably only confuse
08:01:31 <Sindriava> absence + 1
08:01:36 <absence> xtreak: are you familiar with object oriented programming?
08:01:47 <lf94> Wow. Freakin' clever.
08:01:48 <lf94> map (\ fn -> fn hg) [ guessedSoFar , show . gameScore , show . gameStatus ]
08:01:52 <lf94> +1 to that guy
08:01:58 <ralu> ho one coverts types for ffi. for example I am looking for Int -> CInt
08:02:39 <xtreak> absence, Mostly perl n python. Yeah a little of oop from python.
08:02:55 <Sindriava> lf94: fmap ($ hg) ?
08:02:58 <geekosaur> hm. wonder if it got stuck always-on in that case
08:03:21 * Sindriava shakes fist at `map`
08:03:46 <xtreak> Try sequence also for map.
08:03:50 <nshepperd> benzrf: ah, '
08:04:05 <nshepperd> benzrf: 'This GHC behaviour violates the Haskell standard,'
08:04:06 <geekosaur> > let (^%^) = undefined in (() ^%^) `seq` ()
08:04:08 <lambdabot>  *Exception: Prelude.undefined
08:04:12 <Sindriava> xtreak: sequence is for Monadic actions
08:04:20 <benzrf> nshepperd: ye but if so why is there an extension for it
08:04:20 <lf94> Sindriava, it never occurred to me you could map over a list of *functions*
08:04:35 <lf94> That seems like something I'd use in the near future
08:04:38 <geekosaur> but then postifx ops may be on in lambdabot, hm
08:04:46 <Sindriava> lf94: It's kinda handy, yeah
08:05:03 <nshepperd> benzrf: it looks like ghc rewrites (4!) to (!) 4, but requires the types to also unify with \x -> 4 ! x
08:05:09 <benzrf> ah
08:05:22 <nshepperd> so the postfix extension just removes that last check
08:05:27 <xtreak> Thanks Sindriava
08:05:29 <benzrf> @let (!) n = product [1..n]
08:05:30 <lambdabot>  Defined.
08:05:31 <benzrf> > (4!)
08:05:33 <lambdabot>      Ambiguous occurrence ‘!’
08:05:33 <lambdabot>      It could refer to either ‘L.!’,
08:05:33 <lambdabot>                               defined at /tmp/mueval5965166491189641421.hs:148:1
08:05:36 <benzrf> :{
08:05:54 <lf94> lmao, people will be able to see the evolution of haskell with these hangman games.
08:06:02 <lf94> >2012,2013,2015
08:06:40 <absence> xtreak: a monad is like an interface with three methods that follow certain laws. there's nothing magic about it, anything that fits the pattern can "implement the interface"
08:07:17 <Sindriava> xtreak: Often even in different ways. For example, there are 2 monad instances for list. Normal list and ZipList
08:07:54 <absence> xtreak: take lists for example, you have these three operations: pure (create a list from a single value), fmap (apply a function to contents of a list), and join (collapse structure, i.e. concatenate a list of lists)
08:07:59 <nshepperd> ZipList isn't a monad instance
08:08:09 <nshepperd> it only gets as far as applicative
08:09:18 <Sindriava> nshepperd: TIL
08:09:18 <absence> xtreak: those three operations make sense for many other types than lists, and they're all monads. now you can write algorithms that work on monads in terms of those three operations
08:09:21 <xtreak> I watched brian beckman video on it. But my initial reaction is as usual. Why its so complicated. May be I have to spend some more time and get my feet more wet. Btw using learn u a Haskell.
08:09:43 <absence> xtreak: it isn't complicated :)
08:09:59 * Sindriava wonders what all the people that write "u" instead of "you" do with all that free time
08:10:17 <Sindriava> + 1 for that Beckman video, it's really nice
08:10:25 <obb> can someone recommend a resource where i can learn more about the technical side of haskell i.e. how the compiler actually evaluates expressions and how i can make my code faster/what i should consider when trying to write performant code?
08:10:47 <Sindriava> obb: "Write you a Haskell" is pretty nice :)
08:10:54 <Sindriava> Although incomplete AFAK
08:10:54 <lf94> you can start with this line: ghc -fforce-recomp -ddump-ds filename.hs
08:10:58 <Sindriava> *AFAIK
08:11:11 <lf94> Outputs completely "desugared" code
08:11:29 <Sindriava> +1 for dump-ds, it's pretty educational
08:12:18 <Sindriava> nshepperd: What makes it impossible for ZipList to be a monad?
08:12:30 <afons> How can I change an element in a NxN list?
08:12:32 <afons> perhaps with lens?
08:12:33 <Sindriava> nshepperd: Derp, nevermind
08:12:45 <afons> with the row and col
08:12:49 <afons> like 0 and 3
08:12:55 <Walther> So I've been writing this tutorial of "how to do the most common daily code you do, but in haskell" - I'd much appreciate improvement suggestions :) http://walther.guru/one-hour-haskell
08:13:02 <Sindriava> afons: You can't change the element, it's immutable. But I get what you want to do
08:13:08 <afons> yes create a new list
08:13:12 <afons> with the element modified
08:13:26 <Walther> basically, a simple tutorial that doesn't focus on explaining and proving haskells innards, but a quick-and-dirty "how to get started"
08:13:32 <Sindriava> afons: The dumb solution is to use a for loop, like you'd do in C
08:13:36 <xtreak> Maybe I will watch it again. I am also having monads n gonads on my playlist. Its just I feel I have to be way smarter to understand this stuff :) thanks anyway.
08:13:40 <Sindriava> Walther + 1
08:13:44 <nshepperd> Sindriava: the join operation "fails" on non-square [[a]]
08:14:00 <nshepperd> in that it has to throw some data away and some laws break
08:14:09 <absence> xtreak: are you familiar with more basic haskell stuff? have you worked with lists and "maybe"?
08:14:09 <afons> Sindriava: there's a better way to do it with lens but I forgot
08:14:28 <Sindriava> nshepperd: Yeah, I realized that right after I hit enter
08:14:30 <Sindriava> Shame.
08:14:46 <Sindriava> afons: Lens might be overkill for this.
08:15:00 <afons> Some other guy told me but I forgot
08:15:02 <nshepperd> Sindriava: so, interestingly this all works fine for fixed length vectors
08:15:08 <afons> was something along &.~ stuff
08:15:13 <nshepperd> instance Monad Vec4 and so on
08:15:20 <afons> that isn't valid syntax but it had & and ~ symbol
08:16:02 <Sindriava> nshepperd: Oooh. I have to look into how vectors work. I've been using Vs from linear and it's pretty sweet, all that I ever missed with tuples
08:16:03 <xtreak> I worked with lists. I can understand ur talking abt maps n flatten in ur prev msg. No. Dint fully grok maybe too. Maybe I am thinking way far :)
08:16:15 <absence> afons: https://hackage.haskell.org/package/lens-4.12.3/docs/doc-index-All.html <- find it there maybe?
08:17:24 <indiagreen> afons: something like “list & ix n . ix m .~ newValue”
08:17:35 <afons> Another question, when I have like multiple data types and have the "getter functions" like { width :: Int } .. and multiple types must have these functions.. the problem is it becomes ambiguous error
08:17:38 <afons> how to workaround this?
08:17:58 <Sindriava> afons: Prefix them.
08:18:04 <indiagreen> > ["abc","def"] & ix 0 . ix 1 %~ toUpper
08:18:06 <lambdabot>  ["aBc","def"]
08:18:08 <afons> that's what people do?
08:18:13 <Sindriava> afons: Or, I think there's a language extension for this, maybe
08:18:21 <indiagreen> Sindriava: not yet
08:18:33 <Sindriava> afons: I just qualify the names with modules
08:18:44 <absence> xtreak: then you're already there! you realise that lists have these operations. that makes list a monad. other types also have the same operations. they're also monads. the only requirement is that the relations between the operations follow certain laws (the monad laws)
08:18:46 <Sindriava> import A, import B
08:18:52 <Sindriava> A.width someA
08:18:55 <Sindriava> B.width someB
08:19:05 <indiagreen> afons: people prefix them and then use makeFields or something to create generic accessors; people use alternative libraries like “record”; people qualify names 
08:19:15 <absence> > join (Maybe (Maybe 3))
08:19:16 <lambdabot>      Not in scope: data constructor ‘Maybe’
08:19:16 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)    Not in ...
08:19:16 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
08:19:22 <absence> derp
08:19:26 <Sindriava> :D
08:19:27 <absence> > join (Just (Just 3))
08:19:29 <lambdabot>  Just 3
08:19:30 <Sindriava> I did that like 3 times today
08:19:37 <absence> > fmap (+1) (Just 3)
08:19:38 <lambdabot>  Just 4
08:19:44 <absence> xtreak: ^^
08:19:57 <Sindriava> xtreak: Unfortunately, there's not yet a way for Haskell to check if you conform to the laws, so you'll have to validate that yourself when instancing Monad
08:20:19 <absence> xtreak: even if you haven't worked with "maybe" yet, you can see that the same operations exist for it. thus it's a monad
08:20:46 <joneshf-laptop> afons, I think the proper way to handle that is to redesign a bit.
08:20:54 <afons> joneshf-laptop, how ?
08:21:27 <afons> for example I have a ship data type and a board datatype, it other languages I would just do board.with = .. and ship.width = ..
08:21:31 <nshepperd> hehe, well you can use quickcheck to verify the monad laws in some cases. but that's a lesson to save for later
08:21:42 <joneshf-laptop> afons, question why you have two distinct data types with the same field names
08:21:57 <afons> joneshf-laptop, because they both have width
08:22:07 <afons> how can I workaround it?
08:22:14 <Sindriava> absence: xtreak: To reiterate an old joke, "Monads are just monoids in the category of endofunctors. what's the big deal?"
08:22:16 <afons> since there is no concept of "property"
08:22:18 <xtreak> absence, what are the monad laws. Is working on maps with a list a monadic operation? A little explanation plz. Also am on androirc in android. Any idea how to tag u with the msg. I think i myt be spamming the channel. Thanks
08:22:25 <Sindriava> It's actually really useful to see what the joke means.
08:22:53 * hackagebot yesod-crud-persist 0.1.2 - Flexible CRUD subsite usable with Yesod and Persistent.  https://hackage.haskell.org/package/yesod-crud-persist-0.1.2 (andrewthad)
08:25:06 <joneshf-laptop> afons, why do they both have width?
08:25:20 <joneshf-laptop> afons, is there an underlying thing in there?
08:25:26 <joneshf-laptop> afons, those sort of questions
08:26:13 <afons> joneshf-laptop, I am making a very very very simple game, that has a board and ships and stuff
08:26:21 <afons> The board has a width and height
08:26:25 <afons> and so does the ship
08:26:53 <absence> xtreak: can't find a writeup of them that doesn't confuse things with unnecessary stuff, but they're basically just common sense, like if you combine mapping and "pure" (make list from single value) and join (flatten) the result, you end up with what you originally had
08:27:33 <afons> data Board = Board { width :: Int, height :: Int }
08:27:34 <afons> data Ship = Ship { strength :: Int, width :: Int, height :: Int}
08:28:32 <absence> xtreak: i recommend just playing around in the REPL, familiarise yourself with "Maybe" and try some monad functions on both lists and maybes to see what happens
08:28:35 <mbrock> monad is a mathematical abstraction that lets us write useful abstract functions -- but focusing on the monad concept too much, instead of the concrete stuff it abstracts over, leads to confusion
08:29:05 <Sindriava> It's like trying to learn driving by reading a book ¯\_(ツ)_/¯
08:29:39 <mbrock> or like trying to learn basic arithmetic by learning the definitions of algebraic structures
08:30:05 <ggVGc> learnyouahaskell.com's chapter on monads is very clear and made me get it, personally. But only if you also read and understand everything leading up to it
08:30:47 <ggVGc> If you don't grok applicative functors then there's no way to get monads
08:30:52 <ggVGc> imo
08:30:58 <ggVGc> but I'm also just learning...
08:31:19 <mbrock> well, people were using monads for years before applicative functors were even very well known, if I'm not mistaken
08:31:38 <absence> indeed, i disagree that applicative has to be understood first
08:31:46 <Sindriava> Yah
08:31:46 <ggVGc> okay
08:32:03 <ggVGc> worked for me anyway
08:32:09 <ggVGc> at least I think it did.. hah
08:32:28 <Sindriava> ggVGc: It's helpful to first understand applicatives, no doubt
08:34:30 <lf94> Alright, time for sleep. Tomorrow: HSpec tests and upload to Hackage.
08:35:40 <absence> ggVGc: our minds are all wired together in different ways :)
08:35:48 <afons> sigil.
08:35:52 <afons> http://stackoverflow.com/questions/32026260/data-types-with-same-field-names
08:37:30 * nshepperd . o O (imagine if our minds were all wired together)
08:37:59 <ggVGc> nshepperd: maybe they are....
08:38:35 <__monty__> Or maybe they have never will have been?
08:39:10 <absence> afons: there are some plans to improve record syntax in haskell i think, but for now boardWidth, playerWidth etc is probably the best choice
08:40:33 <absence> afons: https://ghc.haskell.org/trac/ghc/wiki/Records/OverloadedRecordFields
08:41:14 <__monty__> afons: Also consider using less record syntax, oftentimes you can just pattern match instead of explicitly getting a value.
08:51:46 <obb> why should i use if/else when i can use guards?
08:52:15 <lpaste_> lamefun pasted “What should I put here?” at http://lpaste.net/138898
08:54:14 <absence> obb: depends on what you feel is clearest in a given situation
08:54:38 <obb> ok so there is no rule of thumb or anything like that?
08:55:08 <absence> obb: a failed guard skips the case, while if then else won't affect case selection, so they're not the same
08:55:34 <Gurkenglas_> obb, when both cases have a common part, you can pull it out of the if, not so easy with top-level guards
08:56:09 <Gurkenglas_> return $ if b then x else y instead of if b then return x else return y (not sure if the ($) is necessary)
08:56:51 <obb> absence, not sure if i understand what you mean. | condition = expression | otherwise = other_expression should be the same as if condition then expression else other_expression right?
08:56:58 <greves> has anyone gone through the CIS 194 / upenn coursework?
08:57:52 <greves> i just finished homework 2 and it works as its supposed to but if anyone has time to check my code and see maybe where i've done something inefficiently or with bad form, that would be awesome
08:58:35 <greves> assignment instructions http://www.seas.upenn.edu/~cis194/fall14/spring13/hw/02-ADTs.pdf and my code https://dpaste.de/jNPf
08:58:49 <absence> obb: you can put guards on pattern match cases. but yeah, using two guards like that on any single equation is the same as if then else
08:59:25 <absence> obb: there's no rule of thumb, just personal preference
08:59:38 <absence> obb: in the end both guards and if then else desugar to pattern matching
08:59:47 <absence> obb: so that's a third option :)
09:00:13 <absence> case condition of True -> ...; False -> ...
09:00:28 <obb> k thx
09:02:39 <xtreak> absence, thanks for ur help.. Will try more about maybe in the repl.. Any recommendations for maybe other than learn u a Haskell?
09:03:51 <absence> xtreak: not really, it's a very simple type. it just either represents some value, or it's empty (like a variable that can be null in many other languages)
09:04:54 <xtreak> To handle null values in Haskell?
09:05:23 <absence> yes
09:07:15 <absence> xtreak: "Just 100" and "Nothing" are both valid expressions of type "Maybe Int"
09:09:20 <xtreak> When I pass a nothing to a function that takes in Maybe. Then we need to write code for Maybe too right? Is it like an if clause with code for value and else clause for nothing
09:09:31 <scshunt> yes
09:09:37 <scshunt> you can do it with pattern matching
09:09:54 <scshunt> e.g. { foo Nothing = 0; foo (Maybe i) = i + 3; }
09:10:02 <scshunt> or you can do it implicitly with one of the functions that handle maybe
09:10:05 <scshunt> *maybes
09:12:26 <Welkin> I nearly have a working cipher!
09:12:33 <Welkin> it works for ascii now using bytestrings
09:12:49 <Welkin> and mostly for unicode, except the last character gets corrupted
09:13:22 <xtreak> https://en.m.wikibooks.org/wiki/Haskell/Understanding_monads/Maybe found it good.
09:13:56 <oseda> good day everyone
09:14:10 <Gurkenglas_> maybe x f (Just y) = f y, maybe x f Nothing = x, Maybe is an instance of functor, so fmap f (Just x) = Just (f x) and fmap f Nothing = Nothing, Maybe has a monad instance that does (Just x) >>= f = f x, Nothing >>= f = Nothing
09:14:37 <AaronFriel> Welkin: If you're relying on your cipher understanding the bytes it's looking at, it's probably not a good cipher ;)
09:15:24 <oseda> am a newbie to haskell and i just want to know if haskell can be used to develop web applications.. if yes then how is the implimentation
09:15:52 <xtreak> I dint know what a functor is :( it seems  i have a lot more basics to learn..
09:16:20 <absence> xtreak: functor is much simpler than monad, it's just "something you can map on"
09:17:12 <absence> xtreak: you can map a list, so it's a functor. you can also map a Maybe, so it's a functor
09:17:30 <absence> > fmap (+1) (Just 100)
09:17:32 <lambdabot>  Just 101
09:17:36 <absence> > fmap (+1) Nothing
09:17:38 <lambdabot>  Nothing
09:18:19 <xtreak> Is a partial function a functor then? I can supply it to a map. Here what is the second and third argument to map named?
09:18:54 <absence> xtreak: do you mean partially applied?
09:19:09 <absence> xtreak: like "(+1)"?
09:19:14 <xtreak> Yes.
09:19:22 <absence> xtreak: yes, they're also functors
09:19:43 <absence> > fmap (+1) (+4) $ 100
09:19:45 <lambdabot>  105
09:20:02 <xtreak> Is it different from list which is also a functor?
09:20:35 <absence> xtreak: they're different things, but they're both functors, meaning you can map on them
09:21:02 <absence> :t fmap
09:21:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:21:35 <athan> Can I install a package with dependencies /not/ available on stackage, when using stack as a build tool?
09:21:41 <absence> xtreak: you mentioned second and third argument, but there are only two - the first is a function, (a -> b), and the second is a functor (list, partially applied function, maybe, etc)
09:24:38 <xtreak> Thanks now I am searching diff between map n fmap. It seems Haskell has a lot more that u keep learning n go down deep to see actual difference.
09:24:47 <Welkin> AaronFriel: I'm not, but there seems to be a problem when converting from BitVector to ByteString
09:25:28 <Welkin> ByteString -> BitVector works fine
09:25:57 <absence> xtreak: "map" is just "fmap" specialised for lists. it's a historical accident..
09:26:03 <absence> :t map
09:26:04 <lambdabot> (a -> b) -> [a] -> [b]
09:26:05 <absence> :t fmap
09:26:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:26:48 <absence> xtreak: map only works on lists, fmap works on any functor including lists, so map is redundant
09:27:59 <xtreak> Yes. http://stackoverflow.com/q/6824255
09:31:14 <absence> xtreak: monad has some historical snags of its own which might be confusing
09:48:07 <lamefun> can I do Template Haskell meta?
09:48:18 <lamefun> ie. macros that generate more macros?
09:52:41 * Sindriava frowns at `map` again
09:53:08 <Sindriava> Had `map` been changed to be fmap instead, that could have been avoided IMO
09:53:21 <jgcoded> monads are legos
09:53:43 <Sindriava> jgcoded: Monad transformers are, IMO
09:54:11 <absence> most fp stuff done right is lego
09:54:39 <Sindriava> Fair enough
09:55:05 <mbrock> the pedagogical concerns of presenting extremely general abstractions to students looking for basic documentation do still seem to remain, though
09:56:10 <absence> mbrock: i think that can be solved by including some example instances in documentation and error message
09:56:25 <athan> Integrated proofs (via GADTs) put glue on before you use them :\
09:56:40 <absence> mbrock: or just stuff them all in Control.Trainingwheels
09:56:56 <geekosaur> lamefun, the restrictions on TH splices would suggest that you cannot generate a splice from a splice
09:57:15 <geekosaur> if that's what you mean
09:57:59 <mbrock> yes, such tooling improvements could help reduce the number of beginners who get perplexed by encountering monads when they just want to do a basic I/O loop, for example
09:59:01 <mbrock> (which in my experience is the #1 reason people are scared by Haskell)
09:59:43 <Sindriava> In my experience the #1 reason people are scared by haskell is that it requires actual effor to learn, coming from another language
10:00:04 <absence> mbrock: monads tend to scare people yes.. i wish the typeclass wasn't so full of historical clutter
10:00:09 <Sindriava> e.g. "How do I do a for loop? Not like I'm used to? This is dumb"
10:01:04 <absence> Sindriava: if they give up because they think the lack of for loops is dumb, just let them go :)
10:01:06 <mbrock> well, the "for" function is relatively easy to understand in its specialization to IO
10:01:57 <Sindriava> mbrock: There's the for function, which in reality is nothing like the for loop
10:02:14 <mbrock> sorry, "forM" or "forM_"
10:02:23 <Sindriava> mbrock: Yeah, that's what I meant
10:02:53 <Sindriava> mbrock: forM isn't too similar to the classical for loop in the form of `for(a;b;c) { block }`
10:03:09 <Sindriava> mbrock: It's more like the for loop in Python
10:03:30 <jgcoded> I have a strong imperative background. When I write Haskell code, I often think "OK now I need a for loop to do X". then I get stuck trying to do X recursively
10:04:59 <Sindriava> absence: By all means, they can go stuff themselves, it's just that that's the main reason people scare away from Haskell (and Lisp and other stuff). Since it's not just a rehash of C, they're uncomfortable writing it
10:05:04 <absence> jgcoded: while explicit recursion isn't quite so bad as "goto" in imperative languages, it should make you stop to think :)
10:05:17 <marchelzo> Are there any good guides on writing Haskell bindings for C libraries?
10:05:30 <Sindriava> marchelzo: There's a pretty good intro on the Wiki!
10:06:35 <absence> Sindriava: i agree, but if they don't want to learn it, there's no use forcing them. maybe it's lack of programming maturity, and they'll come back later. i certainly threw haskell away the first time i looked at it, and didn't become interested again until several years later
10:06:41 <Sindriava> jgcoded: I found that most of the stuff I'd use a for loop for I can accomplish by either mapping, zipping or folding a structure
10:06:54 <jgcoded> absence: yeah I agree. writing it recursively in Haskell forces me to think about base cases and the structure of what the function does
10:08:11 <paolino> hello,  readFile fails with hGetContents: invalid argument (invalid byte sequence) ? I feel dumb
10:08:22 <jgcoded> sindriava: thanks for the tip, I'll see if I can rewrite some code using that. mapping zipping folding
10:08:27 <absence> jgcoded: what i meant is, it's usually better to use existing primitives instead of recursion, just like it's usually better to use for, while, etc in imperative languages instead of goto
10:08:41 <Sindriava> jgcoded: If you paste me an example, we can look over it together ^^
10:08:59 <Sindriava> absence: Well, I'm a huge fan of C, because it's an excellent language in what it does. My main gripe with most people is that they seem to dismiss stuff they're unfamiliar with as "dumb". I think that (as always) Simpsons hit the nail on the head with Homer saying: "I don't eat anything I haven't eaten before!" :)
10:09:48 <Sindriava> paolino: Does the file you're reading exist? If you're reading a file from relative location, the location might not be relative to what you think
10:10:02 <Sindriava> paolino: Although that would probably produce a different error message
10:10:13 <paolino> yep it's there
10:10:31 <absence> paolino: paste a complete example?
10:10:33 <paolino> qr.tmp I cannot touch it with my fingers
10:10:39 <mbrock> readFile decodes with your locale
10:10:54 <mbrock> probably you are opening a binary file, or one with a foreign encoding?
10:11:06 <paolino> mbrock, a problem with the system ?
10:11:15 <paolino> binary yes
10:11:33 <absence> ohh
10:11:36 <Sindriava> absence: On of the main things that *really* got me into Haskell is this chatroom. #haskell is genuinely one of the nicest IRC channels I've been on.
10:11:38 <mbrock> you probably want to use Data.ByteString.readFile
10:11:40 <paolino> mh I need bytestring ?
10:11:43 <paolino> ok
10:11:50 <absence> :t readFile
10:11:51 <lambdabot> FilePath -> IO String
10:12:02 <Sindriava> :t ByteString.readFile
10:12:03 <lambdabot> Not in scope: ‘ByteString.readFile’
10:12:16 <Welkin> mbrock: is there a way to set the encoding when reading a file?
10:12:19 <absence> paolino: readFile is for text yes :)
10:12:20 <Sindriava> > import Data.ByteString
10:12:21 <lambdabot>  <hint>:1:1: parse error on input ‘import’
10:12:24 <Sindriava> Gah
10:12:31 <absence> :t Data.ByteString.readFile
10:12:33 <lambdabot> FilePath -> IO BSC.ByteString
10:13:08 <geekosaur> there is a way to set encoding but you can't use it with the lazy I/O functions like readFile
10:13:27 <absence> Sindriava: that's true, i've used irc for a long time and was very surprised
10:13:38 <geekosaur> because you need a handle, not the interleaved-I/O String you get from readFile
10:14:10 <Sindriava> absence: Especially in contrast to #cpp, in where the XY problem is usually met with rudeness and being told off
10:14:34 <absence> geekosaur: paolino wants to read a binary file though
10:14:50 <geekosaur> yes, so use withFile
10:14:56 <geekosaur> readFile is not the only interface
10:14:59 <paolino> geekosaur, I  will use bs, I just have a kind of allergy to importing those
10:18:18 <geekosaur> also see openBinaryFile which is in System.IO in some versions of base and GHC.IO.Handle otherwise
10:30:16 <__monty__> Can anyone help me understand the FlexibleInstances extension? http://lpaste.net/138888
10:33:18 <geekosaur> wait, a class without methods? seems dubious (but unrelated to the extension)
10:33:20 <Sindriava> can I do TemplateHaskell in REPL?
10:33:37 <kaste> nein
10:33:39 <Sindriava> e.g. makeLenses
10:33:42 <Sindriava> dammit
10:33:42 <kaste> das ist exakt was ich nicht möchte
10:33:49 <kaste> ich will für dich da sein
10:34:00 <kaste> aber ich möchte dich nicht dabei unterstützen dich weiter kaputt zu machen
10:34:14 <Sindriava> Jaja, naturlich
10:34:16 <mzero> __monty__: what are you trying to achieve with that construction?
10:35:41 <geekosaur> in any case, standard Haskell has rather strict constraints on what makes up a valid instance. it's generally *too* strict, so the FlexibleInstances extension allows it to be relaxed.
10:36:15 <Phillemann> Do the elements of the list returned by groupBy have to be non-empty?
10:36:37 <Phillemann> I mean, the list itself can be empty of course, but the sublists?
10:36:43 <mzero> there is also #haskell.de -- not that we don't enjoy seeing other languages here... but you might find community there too!
10:37:11 <__monty__> mzero: Nothing, to be honest, it's just an example because the code this is coming from is rather complex, well it uses lots of GADTs and singletons and everything that resembles dependent types.
10:37:15 <mzero> Phillemann: yes - it is one of those cases where doing  something like   map head $ groupBy ....
10:37:16 <mzero> is okay
10:37:57 <__monty__> mzero: I'm not very fluent in german actually. And really, it's one dutch word : )
10:38:14 <Phillemann> Interesting. I'm actually using classy-prelude and expected the gruopBy in there to return a NonEmpty, but it doesn't.
10:38:31 <geekosaur> __monty__, I think the German comment wasn't aimed at you :)
10:38:38 <geekosaur> s/comment/remark/
10:38:45 <__monty__> geekosaur: Is the precise problem that standard haskell doesn't allow a type variable in an instance declaration?
10:38:59 <mzero> heh, __monty__  the german comment was for Kaste and Sindriava 
10:39:12 <mzero> oops - gotta run
10:39:18 <geekosaur> it specifically requires (Constructor typevar [typevar ...])
10:39:27 <__monty__> mzero: Oh, apologies, there I went assuming again.
10:40:05 <geekosaur> where none of the typevar-s can be used more than once
10:40:07 <Phillemann> Ah, but NonEmpty actually has a function groupBy! Great...
10:40:27 <obb> how do i view the source of a function in ghci
10:40:56 <__monty__> geekosaur: Yes, that's what I read in the documentation. But I find it confusing because flag is a typevar and the constructors aren't typevars but they are allowed.
10:41:20 <geekosaur> obb, you mostly don't. there are things you can add to ghci to get that functionality, though; see https://github.com/chrisdone/goa
10:41:26 <__monty__> geekosaur: That is, if I replace flag with one of the Flags, I don't need flexibleinstances.
10:42:31 <obb> i want to display the source of foldr. is that possible?
10:43:14 <geekosaur> obb, I'm sorry, was I unclear?
10:43:20 <geekosaur> ghci does not have that functionality built in
10:43:24 <geekosaur> it is not an IDE
10:44:02 <obb> yeah is there another way?
10:44:23 <geekosaur> did you look at https://github.com/chrisdone/goa like I suggested?
10:44:44 <geekosaur> or https://wiki.haskell.org/GHC/GHCi#Advanced_customization
10:44:48 <obb> yeah but i dont wanna install something new
10:44:48 <__monty__> obb: You can view the source in the documentation if this is just a one-off kind of thing.
10:44:55 <absence> obb: you can find the function on hackage and click the "source" link: http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#v:foldr
10:45:34 <obb> thanks
10:45:40 <AaronFriel> obb: And with the new linked-source representations, which I hope will roll out soon across all of Hackage, you might find yourself more comfortable using the source pages to get around:
10:45:43 <AaronFriel> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Enum.html#line-263
10:48:30 <hexagoxel> (http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#foldr has links already)
10:48:41 <hexagoxel> obb: if you are interested in the [] foldr ^
10:50:32 <grayen> Why is it that pattern matching on a constraint GADT record will propagate the knowledge about the constraints, but when the field accessors are used instead, this knowledge is lossed?
10:50:38 <grayen> For example, data Foo a where Foo :: Eq a => { bar :: Bar a } -> Foo a, would work correctly when accessed using Foo{bar} (with NamedFieldPuns), but would give me a no instance for (Eq a) error message when using bar instead.
10:50:40 <Rainb> Can you guys describe how do you workaround not using conditions in recursive functions? I don't understand much haskell code
10:50:49 <Rainb> So probably your explanations will confuse me
10:52:31 <Hijiri> Rainb: what do you mean by not using conditions?
10:53:25 <Rainb> say I want to 'loop' or make a recursive function call itself a number of times
10:53:32 <Rainb> since if then else it's discouraged
10:53:38 <Hijiri> you can use guards
10:53:53 <Rainb> what are those
10:54:28 <Hijiri> they are like boolean expressions you can make part of a pattern match
10:54:29 <ski> grayen : there is no notion of a type `tau' endowed with a constraint `cxt'. and so we can't have the type signature `bar :: forall a. Foo a -> Eq a *> Bar a', which would be the wanted type to get the desired behaviour
10:54:38 <geekosaur> or pattern matching, which is common with structural recursion (lists, trees)
10:55:08 <grayen> Rainb: foo x y | x == y = x, will only return x when x and y are equal, that is an example of a guard
10:55:51 <ski> grayen : you only get `bar :: forall a. Foo a -> Bar a', so there's no place in the source, with a hypothetical type `cxt *> tau', which could introduce the extra constraint `cxt'
10:56:15 <ski> grayen : currently, only pattern-matching can introduce extra constraints
10:56:42 <grayen> ski: Ah ok, good to know, thanks for clearing that up!
10:57:28 <ski> Rainb : you can use `if'-`then'-`else' if you with (or `case'-`of'). it's just that using pattern-matching (or guards) in the definiendum (head) of the defining equation usually reads nicer
10:58:05 <ski> grayen : if "endowments" were added (and probably (real) existential types as well, to go with them), then possibly you could get what you want
10:58:25 <ski> s/if you with/if you wish/
11:00:31 <ski> Rainb : if you have some example code, you could try pasting it, and we could see if we could suggest some (possible) improvements
11:00:34 <ski> @paste
11:00:34 <lambdabot> Haskell pastebin: http://lpaste.net/
11:04:32 <grayen> ski: I hope that it is on the wishlist of some future GHC version, I am happy that I atleast can use pattern matching to work around it
11:15:46 <lamefun> How do I meta-meta-program?
11:17:29 <mjrosenb> style question, I have a computation that I want to perform, I can either write it as two consecutive folds, or I can write it as one loop and tie the knot.
11:17:29 <scshunt> lamefun: in what sense?
11:17:36 <scshunt> you can use TH in TH code, if that's what you mean
11:17:40 <mjrosenb> is there any reason to prefer one over the other?
11:17:44 <lamefun> scshunt, https://www.reddit.com/r/haskell/comments/3h3utp/texpq_a_to_a/
11:17:48 <scshunt> mjrosenb: loop? in what sense?
11:18:04 <lamefun> I want to generate a macro with a macro.
11:18:14 <voidzero> yo dawg...
11:18:35 <scshunt> lamefun: you can't do it like that
11:19:01 <lamefun> well, I tried nesting quotes, it won't work either
11:19:14 <scshunt> actually, wait, you might be... hmm
11:19:23 <scshunt> but you can't do it that way
11:19:32 <scshunt> you will have to put the case expression in the generated code
11:19:51 <scshunt> in order to do it your way, you would need to splice mk
11:19:51 <scshunt> but you can't
11:21:12 <lamefun> scshunt, http://lpaste.net/4042148418397667328 - that won't work either.
11:21:37 <lamefun> "Template Haskell brackets cannot be nested (without intervening splices)"
11:22:02 <scshunt> you might have to do some explicit construction of expressions here
11:22:08 <scshunt> as ugly as it is, it's often necessary
11:23:42 <scshunt> e.g. do { fn <- mk; CaseE (AppE mk (VarE 'tx)) [...] } 
11:23:53 <scshunt> err
11:23:57 <scshunt> s/AppE mk/AppE fn/
11:26:41 <mjrosenb> scshunt: loop == fold
11:27:31 <scshunt> mjrosenb: oh
11:27:35 <scshunt> mjrosenb: whichever's more clear
11:27:58 <scshunt> I'd have to see the code to really come to an opinion
11:34:26 <Gurkenglas> What combination of monad transformers will give me the composition of [] and IO? As in, [IO a] and (a -> [IO b]) are (>>=)'d into an [IO b] in the obvious way.
11:34:45 <asthasr> arkeet: You know, I just *now* searched for the discussion on the questionnaire thing I posted a while ago
11:34:50 <asthasr> and saw your gist
11:34:52 <asthasr> :p
11:35:52 <asthasr> arkeet: It is quite nice.
11:39:31 <exio4> Gurkenglas: no combination can achieve something like that
11:40:10 <Zekka> Gurkenglas: How would you do join
11:40:11 <Zekka> ?
11:40:18 <Zekka> Maybe you should make a newtype and try to write the monad instance you want by hand
11:57:14 <siwica> What does the following type signature mean? digit :: Stream s m Char => ParsecT s u m Char
11:58:02 * hackagebot microlens 0.3.0.0 - A tiny part of the lens library which you can depend upon  https://hackage.haskell.org/package/microlens-0.3.0.0 (Artyom)
11:58:37 <hpc> siwica: digit is a parser that produces a value of type Char
11:58:47 <ski> grayen : i'm not sure
11:59:19 <hpc> siwica: presumably, it parses any element of "1234567890" and returns that character
11:59:35 <siwica> hpc: Could you explain exactly what each element before '=>' means?
11:59:54 <hpc> siwica: Stream is a type class
12:00:00 <lamefun> scshunt, is there a TExpQ a -> TExpQ (TExpQ a) function?
12:00:05 <hpc> siwica: what s, u, and m mean i can't remember
12:00:28 <siwica> ok, thats what i was wondering
12:00:33 <scshunt> lamefun: lift?
12:00:34 <hpc> m is at least the monad that's being transformed over
12:00:43 <geekosaur> s is a stream, u is user state (often just ()), m is an underlying monad (usually IO)
12:00:45 <hpc> so if you're parsing a webpage, m might be IO
12:01:01 <hpc> ah cool
12:01:20 <geekosaur> s lets it adapt to things like String aka [Char] vs. ByteString vs. Text
12:02:14 <hpc> oh, i remember now
12:02:36 <hpc> (Stream s m e) means you can get values of type e out of a stream s
12:02:40 <hpc> with underlying monad m
12:02:56 <hpc> so for example, an instance you might have is (Stream Handle IO Char)
12:03:02 * hackagebot microlens-ghc 0.2.0.0 - Orphan instances of microlens classes for packages coming with GHC (array, bytestring, containers)  https://hackage.haskell.org/package/microlens-ghc-0.2.0.0 (Artyom)
12:03:04 * hackagebot microlens-th 0.2.1.1 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.2.1.1 (Artyom)
12:03:06 * hackagebot microlens-mtl 0.1.4.0 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.4.0 (Artyom)
12:03:07 <hpc> because you can get characters out of a Handle by doing some IO
12:03:08 * hackagebot microlens-platform 0.1.0.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.1.0.0 (Artyom)
12:03:09 <lamefun> scshunt, "No instance for (Lift Exp) arising from a use of ‘lift’"
12:03:52 <siwica> ok, thanks!
12:03:53 <siwica> SO what is a 'user state'?
12:03:53 <Gurkenglas> Okay, you people were right, I only have [IO a] -> (a -> IO b) -> [IO b] and [IO a] -> (IO a -> [IO b]) -> [IO b].
12:03:58 <hpc> er, Stream String IO Char
12:04:33 <hpc> no, Handle was right, too sleepy today
12:04:50 <hpc> http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec.html#t:Stream -- uncons is what you have to be able to implement for a valid Stream instance
12:05:08 <scshunt> lamefun: hmm , I guess there isn't
12:05:20 <scshunt> why do you need one, though?
12:05:22 <scshunt> I don't think you should
12:06:10 <ski> Gurkenglas : i don't see how you could get the latter in any useful nontrivial sense
12:08:05 <siwica> ok, so the s and m on the right side are bound to the s and m belonging to the Stream on the left?
12:09:06 <scshunt> lamefun: err wait
12:09:08 <ski> siwica : they must stand for the same types, respectively, yes
12:09:10 <scshunt> lamefun: won't "return" do fine?
12:10:01 <geekosaur> siwica, user state is not used by parsec, it lets you carry information around with the parse. the reason it's not a StateT transformer is so that backtracking restores the old state
12:11:03 <lamefun> I'll try something
12:13:11 <lamefun> scshunt, I think I need a TExpQ (Text -> Maybe a) -> TExpQ (Text -> TExpQ a) signature
12:13:50 <scshunt> yes
12:14:08 <scshunt> hmm actually
12:14:13 <scshunt> yeah, I think you will
12:15:19 <lamefun> or else I don't think I'll be able to defer the parsing check to compile time
12:15:36 <scshunt> "defer... to compile time" what XD
12:15:57 <zipper> Hey, does anyone know how stack is able to get the filepath from the modulename?
12:16:36 <lamefun> well
12:17:46 <lamefun> I want to be able to say parseTH = $$(maybeTextParserTH [|| parse ||]) and then use $$(parseTH "stuff"), so that the compiler will refuse to compile if it won't parse.
12:18:25 <scshunt> yeah, that seems about right
12:22:27 <lamefun> My problem is that I need a function that, given a template of a parser, builds a template of a function that runs the parser (no problem, it's a matter of a simple splice) and then returns another template which contains the parser template as a part of itself, but I can't use lift on Exp or TExp.
12:22:44 <lamefun> So, this is impossible?
12:22:51 <scshunt> lamefun: use "return"
12:22:53 <scshunt> :t return
12:22:55 <lambdabot> Monad m => a -> m a
12:23:34 <scshunt> remember that TExpQ is really just Q TExp
12:23:58 <scshunt> actually... oh... I think I see the issue now
12:24:02 <scshunt> hrm
12:24:20 <scshunt> I'd suggest trying this in non-typed TH first, just to make sure you understand those mechanics :)
12:24:23 <scshunt> since I'm not sure I do :P
12:26:35 <lamefun> I think I want `TExp a -> Q TExp (TExp a)`, not `Q TExp a -> Q (Q (TExp a))`.
12:27:04 <scshunt> yeah
12:27:16 <scshunt> hmm
12:28:16 <scshunt> I don't think you can do that
12:28:37 <scshunt> not without lifting it
12:28:42 <scshunt> you could try writing your own instance of lift
12:29:24 <scshunt> I don't *think* there's a tehnical reason you couldn't lift template haskell
12:29:24 <nullvoid8_> I've come in half way, but could TExp instantiate Comonad?
12:29:59 <nullvoid8_> ignore me if that would unhelpful
12:30:19 <scshunt> no
12:30:24 <scshunt> extract would require splicing
12:30:34 <obb> so i just came across this function in the learnyouahaskell book:
12:30:38 <obb> elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys  
12:30:42 <nullvoid8_> I was thinking duplicate actually
12:30:51 <scshunt> right
12:30:54 <nullvoid8_> oh, right, yeah ok
12:30:58 <obb> this apparently traverses the list until the end
12:31:14 <exio4> obb: use foldr if you want it to shortcircuit 
12:31:34 <exio4> in this case, it's just a matter of flipping the arguments in the lambda and changing from foldl to foldr
12:31:35 <obb> if i compile this will the compiler be intelligent enough to stop when it finds the element somewhere in the middle?
12:31:55 <scshunt> obb: no, because it runs from the back end of the list
12:32:09 <scshunt> foldl will always traverse the entire list, because it has to start at the back.
12:32:24 <scshunt> it won't necessarily call the accumulator on each element, though
12:32:49 <scshunt> better is to just use 'any' anyhow
12:33:28 <lamefun> Maybe it's just that no one cares about TH very much? It doesn't seem to even have integration with Haddock after so many years...
12:33:30 <obb> i thought the first element was the one on the left?
12:34:25 <scshunt> yes. foldl is leftward, so it starts at the right and goes left
12:34:40 <scshunt> lamefun: TH is the sort of thing you don't want to use if you can avoid it
12:34:51 <scshunt> it's important and powerful, but it's really a last resort
12:35:42 <Sindriava> lamefun: Thanks to being lazy, Haskell avoids the need for macros many other languages have, since it can introduce it's own control structures
12:36:25 <Sindriava> lamefun: This is partly Lisp's inheritance, which often used quoting to defer evaluation
12:37:01 <exio4> lamefun: macros in haskell are the latest resort for doing anything
12:37:47 <Sindriava> exio4: I wouldn't go that far, there's still CPP :D
12:37:57 <ski> more advanced macrology can't be replaced by high-order or non-strict manipulation
12:38:20 <Sindriava> ski: Wouldn't that be basic macrology?
12:38:22 <scshunt> if you want advanced compile-time verification, try Idris or Agda :P
12:39:19 <chattered> Sindriava: And lambdas in Lisp are verbose, and especially ugly with lisp-2. Many macro examples are cases of "I don't want to have to write lambda"
12:39:34 <Sindriava> yah
12:39:36 <ski> Sindriava : by more advanced i mean e.g. implenting more exotic binding patterns (like e.g. with parallel list comprehension. or perhaps a DSL for logic programming)
12:39:41 <Gurkenglas> :t ((>>=) :: [IO a] -> (IO a -> [IO b]) -> [IO b]) -- ski
12:39:42 <lambdabot> [IO a] -> (IO a -> [IO b]) -> [IO b]
12:40:10 <Sindriava> ski: Ah, I see
12:40:21 <Sindriava> ski: I see advanced macrology as metaprogramming, mostly
12:40:23 <ski> Sindriava : .. or a iterative loop clause language
12:40:34 <ski> Sindriava : yes, the difference isn't that great
12:42:00 * ski blinks
12:42:21 <ski> Gurkenglas : sorry, i didn't think of that for some reason
12:42:41 <zipper> Anyone know how I can find the path of a module if I know its name?
12:42:44 <Gurkenglas> Yay, I proved someone wrong on the internet
12:43:15 <exio4> Gurkenglas: code to that monad instance?
12:43:19 <exio4> for*
12:44:00 <Gurkenglas> exio4, https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-726
12:44:14 <exio4> oh, nevermind
12:45:54 <chattered> The main thing about macros in Lisp, for me, is that, once I learned Lisp, macros were mostly obvious. I didn't really have to learn much else (apart from some stuff about genvars to avoid variable capture). But I've no clue how to write template haskell.
12:46:34 <chattered> Similarly, I haven't got round to learning campl4 (or campl5, or whatever it is now).
12:46:40 <lamefun> Sindriava, http://lpaste.net/9018382220003377152 - well, I think that can be considered needing "last resort", because I don't think anything more can be done to shorten that.
12:47:19 <Sindriava> lamefun: `if True then Just (Name txt) else Nothing` ???
12:47:39 <Sindriava> *hlint voice* Why not: `Just . Name` ?
12:48:01 <lamefun> It'll be something like not (T.null txt) && ...
12:48:12 <Sindriava> Oh.
12:49:09 <Sindriava> Common practice for newtypes seems to be that the field of newtype A is `unA`
12:49:19 <Sindriava> Otherwise, looks good, yeah
12:49:31 <phaazon> hey
12:49:35 <phaazon> I have a function of type
12:49:39 <Sindriava> Hey dude! what's up?
12:49:44 <ski> Sindriava : or `runA', or sometimes some other variants
12:49:47 <phaazon> foo :: (Foldable f) => … -> Maybe (f Word32)
12:49:52 <phaazon> if I pass Nothing
12:49:56 <Sindriava> ski: runA is mostly for transformer stacks
12:50:03 <phaazon> I get an error from GHC, it doesn’t know how to resolve the type f
12:50:26 <Sindriava> phaazon: That's right. Nothing is of type `Maybe a`
12:50:27 <phaazon> then, I have to explicitely set it
12:50:28 <ski>   newtype Endo a = Endo {appEndo :: a -> a}
12:50:31 <phaazon> that sucks
12:50:46 <phaazon> I thought it could infer whatever it wants 
12:50:48 <phaazon> like
12:50:49 <phaazon> :t Nothing
12:50:50 <lambdabot> Maybe a
12:50:55 <Sindriava> There ya go
12:51:08 * ski isn't really in favor of naming the data constructor the same as the type constructor
12:51:10 <Sindriava> phaazon: It can infer anything about Nothing, except it's of type `Maybe a`
12:51:24 <phaazon> Sindriava: I know that…
12:51:31 <phaazon> the issue is the fact that in my case
12:51:31 <Sindriava> ski: For single types, it's okay IMO
12:51:35 <phaazon> f isn’t needed
12:51:44 <ski> Sindriava : what do you mean by "single types" ?
12:51:45 <phaazon> so it could infer Maybe (f Word32)
12:51:53 <lamefun> Sindriava, no it doesn't look good, because it could have well been $(textNewtype "Name" [| \txt -> not (T.null txt) && ... |] "Package name, docs, docs, docs...").
12:51:57 <phaazon> I have to write that now:
12:52:05 <phaazon> Nothing :: Maybe [Word32]
12:52:07 <Sindriava> ski: "data A = A" as opposed to "data B = C | D"
12:52:24 <phaazon> I guess I could make f bound to another parameter
12:52:27 <phaazon> so that I don’t have to do that…
12:52:31 <ski> Sindriava : oh, i wouldn't even consider it for types with multiple data constructors
12:52:42 <Sindriava> phaazon: The problem is that it can't just infer the f, because it's not a type but a typeclass
12:52:56 <Sindriava> phaazon: It would have to randomly choose a type that conforms to that typeclass, IMO
12:53:24 <phaazon> Sindriava: hm…
12:53:26 <phaazon> f is a type.
12:53:31 <phaazon> it’s even a type variable ;)
12:53:34 <Sindriava> phaazon: f is a *type variable*
12:53:35 <phaazon> it’s not a typeclass constraint ;)
12:53:44 <Sindriava> type variable is not a type
12:53:56 <Sindriava> Just like Foldable isn't, Foldable is a constraint
12:54:11 <phaazon> Sindriava: I’m pretty sure we both know that :D
12:54:25 <phaazon> I’ll just link the f to another parameter
12:54:28 <phaazon> so that GHC can infer it
12:54:30 <phaazon> :)
12:54:33 <Sindriava> It can't infer `Maybe (f Word32)`, it would have to infer `Foldable f => Maybe (f Word32)`
12:54:47 <ski> (with extensions, `Foldable' is a type. otherwise it's just a type class. `Foldable tau', for any type `tau' of appropriate kind, would be a constraint)
12:54:54 <phaazon> Sindriava: even with that it can’t
12:55:06 <phaazon> I guess it’s because it’d break things
12:55:25 <Sindriava> Yah
12:55:26 <phaazon> I guess I could have it if the type was existentially quantified
12:55:27 <phaazon> like
12:55:31 <phaazon> Maybe (forall a. …)
12:55:34 <phaazon> or that kind of stuff
12:55:44 <ski> that's universally quantified, not existentially ..
12:55:50 <Sindriava> yah
12:55:57 <Sindriava> And I think GHC does that implicitly
12:56:07 <ski> (does what implictly ?)
12:56:13 <scshunt> universal quantification
12:56:16 <Sindriava> ^
12:56:36 <Sindriava> `data Foo a = …` implies the forall a.
12:56:53 <Sindriava> Not sure if it's Haskell or GHC though
12:57:02 <ski> phaazon : what is the full type signature ?
12:57:05 <ttt_fff> i'm naming nodes of a ProofTree. What's a good word for "this node has not succeeded yet; this node has not failed iet; it's an intermediate node"
12:57:06 <scshunt> ut's a haskell feature
12:57:08 <scshunt> *it's
12:57:09 <phaazon> ski: 
12:57:14 <scshunt> ttt_fff: Unchecked?
12:57:26 <ttt_fff> i'm naming nodes of a ProofTree. What's a good word for "this node has not succeeded yet; this node has not failed iet; it's an intermediate node" // preer something short, like 4-6 chars
12:57:28 <ski> Sindriava : you can view it as implicitly univerally quantified outside the (type) equality, yes
12:57:32 <ttt_fff> scshunt: yeah, but too many chars
12:57:37 <phaazon> createGeometry :: forall f m t v. (Foldable f,Foldable t,MonadIO m,MonadResource m,Storable v,Vertex v) => f v -> Maybe (t Word32) -> GeometryMode -> m Geometry
12:57:48 <phaazon> I’ve solved that by making t = f
12:57:56 <phaazon> so that it could ben infered when passing f v
12:57:59 <phaazon> been*
12:58:01 <ski> ttt_fff : what are names for the other nodes ?
12:58:02 <phaazon> be*
12:58:03 <phaazon> dammit.
12:58:13 <ttt_fff> ski: PNodeFail, PNodeSuccess
12:58:25 <ttt_fff> i'm looking for PNode-this-is-an-intermediate-node-which-may-or-may-not-fail
12:58:31 <Sindriava> ttt_fff: PNodeIntermediate
12:58:49 <ttt_fff> Intermediate is too many chars, but I don't thikn I can do better
12:59:08 <scshunt> ttt_fff: Unknown
12:59:08 <scshunt> Un
12:59:13 <Sindriava> ttt_fff: "too many chars" doesn't beat readability
12:59:15 <scshunt> Unv
12:59:22 <scshunt> also what Sindriava say
12:59:24 <scshunt> *said
12:59:33 <ski> ttt_fff : or perhaps "incomplete" or "partial" ?
12:59:43 <ttt_fff> I like partial
12:59:47 <ttt_fff> ski: you win, thanks
12:59:48 <Sindriava> scshunt: Unknown is semantically incorrect, because the value isn't unknow, but not yet known IMO
12:59:55 <ttt_fff> Sindriava: you win runners' up prize
12:59:55 <scshunt> Sindriava: depends on the context
12:59:59 <Sindriava> \o/
13:00:02 <Sindriava> scshunt: Fair enough
13:00:04 <scshunt> if it's "Fail | Success | Unknown", that's fine
13:00:18 <Sindriava> Yeah, you're right
13:00:37 <verement> PNodeCandidate
13:01:00 <scshunt> haha
13:03:51 <ttt_fff> actually, I ended up using ProofNodeIntermediate, Sindriava wins on "you should optimize for readibility, not # of chars"
13:04:02 <Sindriava> \o/
13:04:14 * Sindriava pops champagne
13:04:46 <Sindriava> Woop
13:04:47 * Sindriava popped it too hard
13:08:42 * Sindriava quietly tucks his unreadable mess of an OpenGL code behind the sofa
13:38:06 * hackagebot text-zipper 0.3 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.3 (JonathanDaugherty)
13:43:06 * hackagebot text-zipper 0.3.1 - A text editor zipper library  https://hackage.haskell.org/package/text-zipper-0.3.1 (JonathanDaugherty)
13:45:46 <catgocat> @pl createBoard w h = replicate h . replicate w $ emptyTile
13:45:46 <lambdabot> createBoard = flip flip emptyTile . flip ((.) . replicate) . replicate
13:46:13 <Zekka> catgocat: I think your first version is much easier to read
13:46:26 <catgocat> Thank you for your feedback
13:46:40 <Zekka> You may wan to use a grid data type or something though if your project's not already set in stone
13:46:52 <Zekka> Not sure if that was sarcastic, apologies if I'm butting in
13:46:53 <catgocat> I have a [[ Tile ]]
13:46:58 <catgocat> wrapped in a newtype Board
13:47:16 <catgocat> no problem, every feedback is welcome
13:47:56 <Zekka> I usually just use a [[a]] or so if I'm just hacking something out, but there are a lot of libraries that will guarantee things like every row being the same size, will let you index over both dimensions at once, etc
13:48:16 <Zekka> https://hackage.haskell.org/package/array-0.5.1.0/docs/Data-Array.html <- 'array' is one of them
13:48:24 <catgocat> I haven't used Arrays till now
13:48:39 <catgocat> and I am coding Haskell for 1 month now
13:48:50 <Zekka> They can also provide more efficient indexing than lists, although I don't know how guaranteed it is
13:49:25 <Zekka> catgocat: Of course, if using arrays would confuse you, don't use them imho
13:49:40 <catgocat> I mean have to use them eventually
13:49:46 <catgocat> I want to program professionally in haskell
13:52:13 <cocreature> imho Vector is a bit easier to get started with than standard haskell arrays http://hackage.haskell.org/package/vector
13:53:05 <catgocat> I have a module that only exports a class
13:53:06 <zipper> How does cabal find the path to a module given the module name?
13:53:13 <catgocat> should I name that module the same as the name of the class?
13:53:25 <catgocat> I would eventually do `import Display ( Display ) 
13:55:56 <cocreature> catgocat: imho display is a bit too general. I would probably go for ProjectName.Display as a modulename
13:57:12 <bennofs> Is there a way to [Either a b] -> Either a b which returns either the first Right or the last Left ?
13:57:50 <Sindriava> bennofs: Sure, using Monoids to fold it manually I guess
13:58:02 <bennofs> > Left () <> Right ()
13:58:04 <lambdabot>      No instance for (Monoid (Either () ())) arising from a use of ‘<>’
13:58:04 <lambdabot>      In the expression: Left () <> Right ()
13:58:05 <bennofs> :|
13:58:12 <Sindriava> duh doy
13:58:21 <Sindriava> I meant monoids like Sum and Last, gimme a sec
13:58:42 <bennofs> :t (<|>) `asAppliedTo` Left () -- why is there an "Error" constraint here?!
13:58:43 <lambdabot>     No instance for (Control.Monad.Trans.Error.Error ())
13:58:43 <lambdabot>       arising from a use of ‘<|>’
13:58:43 <lambdabot>     In the first argument of ‘asAppliedTo’, namely ‘(<|>)’
13:58:54 <Sindriava> Oh, last is for Maybes
13:59:18 <Sindriava> bennofs: Just write it yourself then, it's like 2 lines
13:59:44 <Sindriava> foo (Left x):[] = Left x
13:59:57 <Sindriava> foo (Left _):[es] = foo es
14:00:07 <Sindriava> foo (Right x):_ = Right x
14:00:10 <Sindriava> Something lke that?
14:01:56 <ski> bennofs1 : hm, i suppose they have `empty = Left noMsg' ?
14:02:05 <bennofs1> probably :|
14:02:20 <ski> (though i agree it is jarring)
14:02:55 <bennofs> > map (view swapped) . sequence . map (view swapped) :: [Either a b] -> Either a b
14:02:56 <lambdabot>      Couldn't match type ‘[p0 a1 a0]’ with ‘Either a1 b1’
14:02:56 <lambdabot>      Expected type: [[a1]] -> Either a1 b1
14:02:56 <lambdabot>        Actual type: [[a1]] -> [p0 a1 a0]
14:03:07 <bennofs> :t view swapped . sequence . map (view swapped) :: [Either a b] -> Either a b
14:03:09 <lambdabot>     Couldn't match type ‘a1’ with ‘[a1]’
14:03:09 <lambdabot>       ‘a1’ is a rigid type variable bound by
14:03:09 <lambdabot>            an expression type signature: [Either a1 b1] -> Either a1 b1
14:03:25 <bennofs> ah, right, the list could be empty
14:07:12 <ShaneK> Hi all, I'm trying to get emacs set up to work on haskell code, but I'm getting a 'GHC Errors' panel popping up with the following warnings: http://lpaste.net/138913
14:07:22 <ShaneK> Any ideas where that warning is coming from?
14:07:41 <ShaneK> It always pops up, and is pretty disruptive
14:08:04 <dmj`> ShaneK: how did you install cabal and ghc
14:09:29 <ShaneK> cabal and ghc were installed through homebrew (i'm on osx)
14:09:49 <ShaneK> from there I build ghc-mod from source (also tried from hackage, same problem)
14:10:20 <ShaneK> this is a really bare-bones haskell setup, ghc + cabal + ghc-mod + dependencies
14:10:34 <ShaneK> then trying to view my own code in emacs.
14:20:54 <ttt_fff> I know about SequenceM. It is not waht I want. Let m = state monad. I want :: [m a ] -> m [a], which does the following thing: (1) it makes n copies of the state, (2) it runs each monad in its own copy of the monad, and (3) it returns the answer
14:20:58 <ttt_fff> is there a builtin for this?
14:22:39 <bennofs> ttt_fff: what happens with the state that each of the m's produced?
14:22:45 <ttt_fff> it gets ignored
14:23:05 <ttt_fff> https://gist.github.com/anonymous/89d39388c5e3e5498120
14:23:21 <ttt_fff> https://gist.github.com/anonymous/c7d3833e58faa4f42f0b is what I want
14:23:26 <ttt_fff> I guess there is no builtin
14:24:40 <johnw> ttt_fff: return . map (flip evalStateT x)
14:25:01 <ttt_fff> :t evalStateT
14:25:02 <lambdabot> Monad m => StateT s m a -> s -> m a
14:25:39 <ttt_fff> :t return . map (flip evalStateT x)
14:25:41 <lambdabot> (Monad m, Monad m1) => [StateT Expr m1 a] -> m [m1 a]
14:26:06 <ttt_fff> johnw: where does the x in 'return . map (flip evalStateT x)' come from?
14:26:15 <ttt_fff> it looks like it should be an undefined error
14:26:17 <johnw> whatever initial state you want each computation to start from
14:26:36 <ttt_fff> :t flip evalStateT x
14:26:37 <lambdabot> Monad m => StateT Expr m a -> m a
14:26:51 <ttt_fff> wtf, why does that code even type check? oh, it infers type of x
14:26:53 <johnw> you need to provide the 'x'
14:26:53 <ttt_fff> I'm an idiot
14:26:59 <ttt_fff> johnw: got it, thanks!
14:27:00 <johnw> it's inferring x :: Expr
14:27:41 <kadoban> It's not really inferring it, is it? x is defined in lambdabot, which is different.
14:28:17 <ttt_fff> > x
14:28:19 <lambdabot>  x
14:28:29 <ttt_fff> @undefine
14:28:29 <lambdabot> Undefined.
14:28:37 <ttt_fff> :t return . map (flip evalStateT x)
14:28:39 <lambdabot> (Monad m, Monad m1) => [StateT Expr m1 a] -> m [m1 a]
14:28:42 <ttt_fff> > x
14:28:43 <lambdabot>  x
14:28:50 <kadoban> ttt_fff: It's defined internally in lambdabot, it's not a user thing.
14:28:51 <ttt_fff> wtf, I just undefined
14:28:52 <kadoban> :t x
14:28:54 <lambdabot> Expr
14:29:00 <ttt_fff> :t foobar
14:29:01 <lambdabot> Not in scope: ‘foobar’
14:29:05 <ttt_fff> :t return . map (flip evalStateT foobar)
14:29:07 <lambdabot> Not in scope: ‘foobar’
14:29:14 <hexagoxel> :t (a,b,c,x,y,z)
14:29:15 <ttt_fff> okay, x is an lambdabot internal; thanks for clearning that up
14:29:16 <lambdabot> (Expr, Expr, Expr, Expr, Expr, Expr)
14:29:27 <ttt_fff> hexagoxel: lambdabot had alphabet before google had it
14:33:08 * hackagebot newsynth 0.3.0.2 - Exact and approximate synthesis of quantum circuits  https://hackage.haskell.org/package/newsynth-0.3.0.2 (PeterSelinger)
14:37:29 <ski> @hackage simple-reflect
14:37:29 <lambdabot> http://hackage.haskell.org/package/simple-reflect
14:37:33 <ski> ttt_fff ^
14:38:27 <ttt_fff> ski: one needs to add support for WHNF to that package
14:46:38 <Fylwind> has anyone attempted to cross-compile ghc with mingw?
14:46:47 <Fylwind> (on a Linux)
14:50:11 <catgocat> What do people use in haskell to modify 2 dimensional lists ?
14:50:23 <catgocat> for example I have a board, and I want to change the second item of the second row
14:50:33 <catgocat> I know this can be done using lists of lists and the normal prelude
14:50:35 <catgocat> but what do ppl use?
14:53:31 <johnw> use a 1 dimensional list, and use math on integers to compute the index
14:53:49 <hpc> lol
14:53:49 <johnw> n `div` rows + n `mod` cols
14:54:12 <Cale> ugh :)
14:54:23 <johnw> Cale: this is bad?
14:54:25 <Cale> If you're going to do that, at least take advantage of Ix to do the calculations
14:54:39 <ttt_fff> can the amcro system in haskell output multi line output? ( I need multi line since I need (1) a line for the type sig and (2) a line for the actual definition)
14:54:39 <Cale> But... I dunno, seems worse than using a 2D list
14:54:50 <johnw> yeah, maybe, I haven't timed it
14:54:53 <Cale> Using a Map or, like, UArrays would even be better.
14:55:00 <johnw> so never mind my suggestion, until you've compared
14:56:57 <TheCrafter> Hey everyone. I have a problem and I thought that here maybe I can find someone to help me.
14:57:06 <TheCrafter> I'm trying to configure ghc-mod for emacs.
14:57:18 <Luna_> Depends on the use case. If you need random access to the elements a list of lists is maybe not the best choice.
14:57:26 <mauke> ttt_fff: why does that need 2 lines?
14:57:28 <TheCrafter> But when I try to open a *.hs file emacs goes into Infinite loop saying "Initializing..."
14:57:41 <TheCrafter> Has anyone encountered the same problem before?
14:57:43 <ttt_fff> mauke: I need something of the form "foo :: Int \n foo = .... "
14:57:54 <ttt_fff> mauke: so I need the macro to output a "\n" somehow, so I need a multi line macro ?
14:57:55 <mauke> ttt_fff: why does that need 2 lines?
14:58:04 <ttt_fff> mauke: otherwise, ghc bitches at me for not having signature on global def
14:58:11 <mauke> ttt_fff: that makes no sense
14:58:17 <geekosaur> ttt_fff, you know you can use a semicolon?
14:58:24 <ttt_fff> in haskell ?
14:58:31 <ttt_fff> I can use semi colon to separate type sig from definition?
14:58:41 <ttt_fff> > abc :: Int ; abc = 23
14:58:43 <lambdabot>  <hint>:1:12: parse error on input ‘;’
14:58:46 <geekosaur> > let foo :: Float; foo = 5 in foo
14:58:47 <ttt_fff> nope, type error
14:58:48 <lambdabot>  5.0
14:58:55 <geekosaur> that was not a type error you got
14:59:01 <ttt_fff> geekosaur: yeah, but I'm using a macro to output somethin gat the global level
14:59:05 <ttt_fff> not inside a 'let'
14:59:06 <geekosaur> that was trying to do a definition in @run which is expressions only
14:59:21 <geekosaur> it does work at the top level. @run is not top level
14:59:45 <ttt_fff> geekosaur: OMG, thanks, semicolon wins
14:59:56 <ttt_fff> mauke: I now understand why you thought I was an idiot
15:00:08 <ttt_fff> mauke: and I agree, I think 5-second-ago-me is an idiot too
15:00:23 <Cale> johnw: Mainly it's just that lists are really terrible at random access, and they're bad at modification at random points. Using a 2D list will generally involve reconstructing fewer list cells, i.e. O(n+m) to modify element (n,m) than using a 1D list which would be O(n*m), but if you're updating elements at all, lists aren't the right structure.
15:00:51 <johnw> Cale: true
15:01:24 <catgocat> How to change an individual element from a Matrix?
15:04:28 <Luna_> catgocat: If you want to change elements at random positions then you should use mutable arrays.
15:05:19 <ralu> there is Matrix in Data.Matrix
15:05:46 <ttt_fff> where is pragma CPP documented? I can't find it on https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/pragmas.html
15:05:57 <hpc> it's a language extension
15:07:12 <hpc> https://downloads.haskell.org/~ghc/7.2.1/docs/html/users_guide/flag-reference.html#id639065
15:26:15 <ttt_fff> is ther ea way to ask cabal "please show me output of this file after CPP pre processing ?
15:26:18 <ttt_fff> I need to debug  amacro
15:33:53 <hexagoxel> ttt_fff: ghc option is -E, so i guess pass that via --ghc-options=.. or {-# OPTIONS_GHC .. #-} (?)
15:36:53 <ttt_fff> hexagoxel: it worked; thanks!
15:44:25 <mazur> so does stack prevent you from having 100s of MB of libraries in every sandbox?
15:46:15 <Zer000> Can someone please point me to a manual/guide/resource for quickcheck2? The docs on hackage aren't really enough and I could only find superficial tutorials with google. For example I don't know what "shrink" means or how I could generate random values of types I've defined myself...
15:48:34 <quchen> zero7: Shrink generates a couple of alternatives to test again. When a test fails with a potentially complex value, "shrink" is called to produce multiple simpler alternatives. Test failures are then tested against those alternatives, in order to find the simplest non-working data.
15:49:38 <ski> Zer000 : hm, did you try read the paper ?
15:52:04 <Zer000> thanks guys, and I'll google the paper
15:52:19 <dmj`> Zer000: suppose you have Data Num = One | Two | Three deriving (Show, Eq, Ord, Enum), then you could have a function like getRandomNum :: Gen Num; getRandomNum = elements [ One .. Three ], then to use it main = print =<< generate getRandomNum.  The getRandomNum function has been generalized into a typeclass called Arbitrary, so instance Arbitrary Num where = arbitrary = getRandomNum
15:52:27 <Zer000> papers about haskell tend to go over my head sometimes though
15:53:01 <dmj`> s/=/;
15:55:10 <Zer000> that makes sense, so elements is just choosing one of the values right?
15:55:26 <dmj`> Zer000: yes
15:56:14 <dmj`> Zer000: you can constrain the count too
15:56:15 <dmj`> vectorOf :: Int -> Gen a -> Gen [a]
15:57:24 <Zer000> ok. I think I still don't get how to implement shrink
15:57:41 <dmj`> Zer000: you don't have to
15:57:53 <dmj`> Zer000: minimal complete defintion apparently doesn't even include arbitrary
15:59:53 <ttt_fff> is there an 'id' lens ?
16:00:00 <ttt_fff> it basically does nothing, and is an arg I pass to a functino taht demands a lens
16:00:07 <c_wraith> ttt_fff: id is a lens
16:00:15 <ttt_fff> the function 'id' is a lens ?
16:00:18 <c_wraith> yes
16:00:22 <ttt_fff> no fucking way
16:00:24 <ttt_fff> how does that work?
16:00:30 <ttt_fff> how is that a Lens a a a a ?
16:00:53 <c_wraith> Lens a a a a = forall f. Functor f => (a -> f a) -> (a -> f a)
16:01:03 <c_wraith> that unifies with the type of id
16:01:48 <geekosaur> I see ttt_fff continues to use what language they choose
16:01:57 <ttt_fff> geekosaur: ?
16:01:59 <geekosaur> next time I kick'
16:02:08 <geekosaur> [15 23:00] <ttt_fff> no ****ing way
16:02:14 <geekosaur> next time I kick
16:02:20 <geekosaur> time after that I ban
16:02:58 <ttt_fff> where can I get a list of bannable regexes ?
16:03:13 <hpc> bannable regexes?
16:03:22 <geekosaur> there is no such list. you can ask in  #haskell-ops if you don't like policy
16:03:26 <ttt_fff> yeah, surely there is a standard list, rather than whatever that twists geekosaur's panties
16:03:33 <geekosaur> you don't get to decide that ppolicy yourself
16:04:09 <hpc> moderation will never be exact anyway
16:04:11 <edk> ttt_fff, i think you're being unnecessarily inflammatory about it
16:04:17 <dmj`> ttt_fff: let's keep it PG please
16:04:26 <edk> but a written policy or something would be nice
16:04:58 <hpc> common sense is a good enough policy
16:06:05 <ttt_fff> it just appears that geekosaur is being rather arbitrary, or angry at something else, and trying to use a set of particular words as an excuse
16:06:22 <geekosaur> http://lpaste.net/8623027078792478720
16:06:25 <ttt_fff> I have yet to see anyone get kicked from #haskell for cursing (besides spam bots)
16:06:27 <geekosaur> discussion from #haskedll-ops
16:06:40 <geekosaur> yes I understand you think you should be able to decide what kind of language is appropriate
16:06:46 <geekosaur> you can discuss it in #haskell-ops
16:07:08 <ttt_fff> fine; if this is official policy, I will be calling @ops anytime someone curses, and I exect similar treatment of them
16:10:06 <geekosaur> btw onw thing you pronbably didn't bother to notice is... that ti doesn't happen often. you and catgocat have been the main abusers of late
16:12:36 <Lokathor> ttt_fff, go form #haskell-latenight :P
16:13:26 <ttt_fff> geekosaur: you made it rather personal, starting by citing me, than threatning to kick, whereas the more diplomatic way should be: (1) here's a doc demonstrating #haskell policies, (2) you're violating rule XYZ -- but you can't do that, because there is no such doc written
16:14:13 <geekosaur> I have warned you a number of times. your response is rules lawyering
16:14:18 <geekosaur> consider me not impressed
16:15:03 <ttt_fff> geekosaur: I did not expect you to be repentant.
16:18:56 <mjrosenb> Is there anything like destructuring on types?
16:19:40 <mjrosenb> I have a type which is going to have ~10 type parameters, and I'd like to treat it as a tuple, and pull out only the relevant parts when I need them.
16:20:12 <ski> unfortunately, there's no type records (or tuples)
16:20:13 <ttt_fff> does each part have it's own name?
16:20:18 <Lokathor> you mean like a record?
16:20:29 <mjrosenb> yes, like a record.
16:20:47 <hpc> are you sure you need that many type variables?
16:20:48 <hexagoxel> > rule12 -- but it is documented in lambdabot, ttt_fff
16:20:49 <lambdabot>  12) no swear-words in chat. offenders will be warned, then kicked, then banned.
16:21:10 <ttt_fff> @undefine
16:21:11 <lambdabot> Undefined.
16:21:13 <ttt_fff> > rule12
16:21:14 <lambdabot>  Not in scope: ‘rule12’
16:21:15 <hexagoxel> awww
16:21:20 <ttt_fff> hexagoxel: nice try :-)
16:21:21 <ski> mjrosenb : can you elaborate on your particular case (i know of one workaround which can be used in some cases) ?
16:21:36 <lpaste_> Blair pasted “collatz Integer” at http://lpaste.net/138916
16:22:08 <hexagoxel> along with 13) making any bots swear counts as swearing
16:22:14 <hexagoxel> :)
16:22:16 <mjrosenb> I have a pretty deep structure, and I want to attach metadata at various levels, and I want the metadata to be different at each level
16:22:29 <lpaste_> Blair pasted “collatz Int” at http://lpaste.net/138917
16:22:57 <ttt_fff> in fact, if this whole no searing thing was implemented by lambdabot (i.e. the warn + kick + ban) based on regexes, rather than arbitrary human choosing when to enforce< i'd be all up for it
16:22:58 <blaird> Hey folks, I'm confused as all hell
16:23:14 <ttt_fff> geekosaur: blaird sweared! where is the warning
16:23:55 <Lokathor> now you're getting a little petty about the swears
16:23:57 <ttt_fff> geekosaur: I'm requesting farirness and equal application of your policy
16:24:04 <hpc> ttt_fff: you seriously need to chill
16:24:14 <Lokathor> blaird, what seems to be the trouble?
16:24:35 <ttt_fff> I'm merely pointing out geekosaur is being arbitrary and unfair
16:24:36 <blaird> Sorry, I'm confused as to why a small change in type changed my answer
16:24:38 <Zekka> ttt_fff: I'd feel pretty singled-out in your position too, but could you not let it bleed onto people who aren't involved?
16:24:40 <mjrosenb> so type DB musicTag tvTag movieTag = (Music musicTag, TV tvTag, Movie movieTag)
16:24:59 <mjrosenb> ski: but each of those will have a number of tags inside of them.
16:25:06 <blaird> (I'm sorry, I shouldn't have used that word)
16:25:35 <Zekka> blaird: I'm assuming in your other version instead of Int you used Integer?
16:25:39 <blaird> I implemented a copy of the euler problem (14 I think)
16:25:55 <ttt_fff> the problem is that geekosaur is citing a 'rule' that many violate, but clearly intends to execute it only vs me
16:26:09 <blaird> Yeah, I was trying to make it faster, and I tried that, but for some reason it changed the answer...
16:26:16 <geekosaur> you did notice that the original one was about catgocat?
16:26:36 <Zekka> blaird: Ints in Haskell are bounded
16:26:36 <geekosaur> in any case, you're well over the line at this point by deciding to play victim
16:26:49 <Zekka> > (minBound, maxBound) :: (Int, Int)
16:26:50 <lambdabot>  (-9223372036854775808,9223372036854775807)
16:26:53 --- mode: ChanServ set +o geekosaur
16:27:13 <ttt_fff> geekosaur: I'm not playing victim; i'm stating that you're being arbitrary with your threats, and there is no uniform law being applied to all nicks
16:27:18 <hexagoxel> ttt_fff: also i can confirm that the rule "arguing about rules happens in -ops" is applied to everyone
16:27:23 <Zekka> They're only guaranteed to be able to represent numbers between -2^29 and 2^29-1 correctly: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Int.html
16:27:43 --- mode: geekosaur set +b ttt_fff!*@*.136.152.142.59$#haskell-ops
16:27:45 <blaird> Did the sequence Really go that High?!
16:27:45 <Zekka> ttt_fff: Like I said, I'd feel pretty singled out if I were you -- I don't know if I'd think I had actually been singled-out, but I'd feel kind of like that.
16:27:50 <Zekka> You'd have had better luck in ops
16:27:59 <Zekka> blaird: I don't know offhand, not having run your code
16:28:18 <geekosaur> you want to argue, you will henceforth argue in the channel for it
16:28:27 <Zekka> If you wanted to be tricky you could define a homemade datatype that wraps Integer with a rule that if it's outside of the Int bounds, it throws up
16:28:48 <Zekka> then you could see if you were ever hitting that case
16:29:12 <geekosaur> no, it sends you there next time you join here
16:29:18 <Zekka> minding that I'm not sure how you'd do that without a lot of boilerplate.
16:29:32 <ski> blaird : possibly overflow ?
16:30:01 <Zekka> ski: Yeah, that's what I was getting at
16:30:17 <Zekka> I don't know how high the highest numbers his program deals with go
16:30:28 <geekosaur> so how many other instances of swearing did you find?
16:30:28 <blaird> Yeah, I mean, I suppose that's possible. But it seems odd... 
16:31:11 <blaird> it finds all collatz sequences from 1000000 and down, could those sorts of numbers overflow integeres?
16:31:17 <geekosaur> Isee.
16:31:20 <Zekka> blaird: Let me write a massive stinky hack, one sec
16:31:21 <bob_twinkles> geekosaur: you're talking to the air as far as the rest of us can see =P
16:31:23 <blaird> *Ints
16:31:32 <Zekka> blaird: I don't know offhand, I don't know  very many terms of the sequence
16:31:32 <geekosaur> the answer is: you and catgocat, both of you were warned
16:31:36 <geekosaur> catgocat learned
16:32:10 --- mode: geekosaur set -o geekosaur
16:32:52 <blaird> Zekka: I think I know a trick that would work
16:33:28 <Zekka> blaird: Feel free. I was just going to define a homemade Num/Integral that wraps Integer and throws exceptions on any overflows of the int bounds\
16:34:14 <blaird> Instead of a custom datatype, I can manipulate the collatz' function to behave like an infinite loop
16:34:17 <ski> mjrosenb : the basic idea is to have instead `data DBTag = TMusic | TTV | TMovie' and then `DB :: (DBTag -> *) -> *' .. in your case, the first `*' would probably be something else .. however, this only works if the kind of all the fields are the same
16:34:41 <Zekka> blaird: I don't know how that accomplishes what you want, but if you think it does, don't let me stop you)
16:34:44 <Zekka> stop you. *
16:34:50 <blaird> If a number entering the function is negative, then set it to the first odd number below the overflow limit
16:34:59 <Gurkenglas> fuck
16:35:01 <Gurkenglas> shit
16:35:16 <blaird> so if it ever does overflow, I'll know because it won't stop
16:35:26 <Gurkenglas> the fuck was what I was trying to enter into Ctrl-F to see about that fuss
16:35:38 <Gurkenglas> The shit was my reaction to missing the ctrl-f x)
16:35:39 --- mode: ChanServ set +q *!*@dslb-178-000-176-040.178.000.pools.vodafone-ip.de
16:36:25 <Zekka> Gurkenglas: No offense taken (by me)
16:39:57 <blaird> Wow, I guess that was it
16:41:14 --- mode: ChanServ set -q *!*@dslb-178-000-176-040.178.000.pools.vodafone-ip.de
16:42:26 --- mode: ChanServ set +o geekosaur
16:42:50 <Zekka> blaird: Boilerplate incoming!
16:42:56 <geekosaur> hm
16:42:57 --- mode: geekosaur set -o geekosaur
16:43:06 <geekosaur> for the record, the quiet was not me
16:43:16 <Zekka> http://lpaste.net/138918 <- pretty sure this will work for finding your error
16:43:24 <Zekka> that is, if you want to know exactly what computation is screwing up
16:43:50 <geekosaur> (it's that time of night when my local network becomes spotty... have been offline the past 5 minutes, not that you'd have noticed thanks to the bouncer)
16:45:31 <Zekka> FWIW style for lines 4-7 is a little weird -- I've been writing nonhaskell lately
16:49:35 <blaird> What is that style actually? I haven't seen that before
16:52:12 <blaird> And it works. You're right, it does go too high
16:55:21 <Zekka> blaird: I don't know, I've been writing a lot of prolog lately and that's probably why I wrote down a new head for every guard
16:55:29 <blaird> Oh, wow, that syntax is kind of nice. It lets you do prolog-y matching instead of just simple (x:xs) stuff
17:00:14 <athan> Is there a general version of `filter :: Foldable f => (a -> Bool) -> f a -> f a` ?
17:01:00 <johnw> athan: I don't think that's possible
17:01:02 <dmj`> :t filterM 
17:01:04 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
17:01:12 <Lokathor> you could make a version that outputs to lists, but i'm not sure you can make a version that outputs to the same Foldable f
17:01:18 <johnw> you can't filter without knowing how to build structure
17:01:27 <johnw> and Foldable only knows how to tear down structure
17:01:34 <johnw> Foldable + Buildable could do it, if you've seen those blog posts
17:01:55 <athan> johnw: I haven't! Thank you!
17:01:58 <athan> thanks dmj` :)
17:02:00 <dmj`> athan: you could just call toList and pass it into filterM
17:02:26 <ski> Zekka : `(FakeInt x) + (FakeInt y) = ..x..y..' could be `FakeInt x + FakeInt y = ..x..y..'
17:02:42 <dmj`> athan: :) my example probably has a lot more allocation than johnws
17:02:59 <Zekka> ski: You're right! You might be able to tell, I haven't been writing very much haskell lately
17:06:56 <jle`> athan: there's the Witherable typeclass which does just that, btw
17:07:10 <jle`> but yeah, notice that all Foldable methods have return types that don't have the `f`
17:07:10 <gamegoblin> I’d like a function that takes "hello" and yields ["hello", "hellohello", "hellohellohello", "hellohellohellohello", …]
17:07:15 <jle`> Foldables can't reconstruct the `f`
17:07:18 <gamegoblin> clever way to do this with a fold?
17:07:47 <hpc> :t iterate
17:07:48 <lambdabot> (a -> a) -> a -> [a]
17:08:10 <hpc> > iterate ("hello" ++) "hello"
17:08:11 <lambdabot>  ["hello","hellohello","hellohellohello","hellohellohellohello","hellohellohe...
17:08:20 <gamegoblin> perfect, thanks
17:08:42 <jle`> > flip iterate "" . (++) $ "hello"
17:08:44 <lambdabot>  ["","hello","hellohello","hellohellohello","hellohellohellohello","hellohell...
17:08:59 <jle`> oops
17:09:13 <hpc> not clever enough
17:09:19 <hpc> it needs at least six (flip (.))s
17:09:29 <athan> johnw: You were referencing the buildable package, right?
17:09:38 <johnw> I wasn't aware of a package
17:09:44 <jle`> @hackage witherable
17:09:44 <lambdabot> http://hackage.haskell.org/package/witherable
17:09:51 <johnw> just some people's recommendation that there should be a dual to Foldable
17:10:30 <athan> johnw: Oh hm, do you happen to have a link to the blog post?
17:11:23 <ski> > fix $ \ms -> map ("hello" ++) $ return [] <|> ms
17:11:25 <lambdabot>  ["hello","hellohello","hellohellohello","hellohellohellohello","hellohellohe...
17:11:58 <dmj`> jle`: long time no see
17:12:01 <athan> Thanks jle` :)
17:12:14 <jle`> dmj`: i've been moving and on vacation :)
17:12:39 <jle`> athan: np! i actually really like the idea of the typeclass, but it's relatively new and hasn't had much time to catch on.  i wonder if it ever will
17:13:32 <johnw> athan: https://www.fpcomplete.com/user/gbaz/building-up-to-a-point-via-adjunctions
17:18:21 <ski> mjrosenb : would it help any in your case ?
17:40:50 <athan> is Data.Set not a functor because of the Ord b => constraint on Data.Set.map?
17:40:54 <athan> :t Data.Set.map
17:40:55 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
17:41:06 <dramforever> yes
17:41:11 <athan> hmm, okay
18:18:35 <Gurkenglas> > map concat . zipWith replicate [1..] . repeat $ "hello"
18:18:36 <lambdabot>  ["hello","hellohello","hellohellohello","hellohellohellohello","hellohellohe...
18:19:15 <Gurkenglas> Though I guess that one would be slow by a linear factor.
18:20:41 <dramforever> > iterate ("hello"++) ""
18:20:42 <lambdabot>  ["","hello","hellohello","hellohellohello","hellohellohellohello","hellohell...
18:20:47 <dramforever> uh
18:21:04 <pacak> > let h = "hello" in iterate (h++) h
18:21:06 <lambdabot>  ["hello","hellohello","hellohellohello","hellohellohellohello","hellohellohe...
18:21:24 <pacak> Or there is a way to make something unreadable and point free.
18:21:38 <dramforever> "slow by a linear factor" is a very bad thing
18:21:44 <dramforever> :t iterate . (++)
18:21:45 <lambdabot> [a] -> [a] -> [[a]]
18:21:49 <marchelzo> I'm having a hard time deciding how to write Haskell bindings for a C library. The library gives you these opaque structs which you can only operate using the functions that the library exposes. Like Foo *foo = lib_foo_new(); lib_foo_do_x(foo); ...
18:21:56 <dramforever> :t join (iterate . (++)) "hello"
18:21:57 <lambdabot> [[Char]]
18:22:00 <marchelzo> How should I represent that type in Haskell?
18:22:01 <dramforever> > join (iterate . (++)) "hello"
18:22:02 <lambdabot>  ["hello","hellohello","hellohellohello","hellohellohellohello","hellohellohe...
18:22:43 <exio4> @type iterate =<< (++) 
18:22:44 <lambdabot> [a] -> [[a]]
18:23:22 <exio4> join (f . g) = join (fmap f g) = f =<< g 
18:23:22 <dramforever> marchelzo: I think you can just make a newtype wrapper over Ptr (), or make an opaque type Foo and use Ptr Foo
18:23:28 <dramforever> data Foo -- like this
18:23:50 * geekosaur was writing the opaque type one... slow
18:23:52 <dramforever> exio4: thanks, I was just experimenting but it was good to know
18:24:04 <dramforever> geekosaur: oh?
18:24:17 <geekosaur> I mean I was typing in (a longer version of) that answer
18:24:30 <dramforever> oh I get it
18:24:43 <dramforever> I thought you said that this opaque type one is slow...
18:25:13 <ansible1> is there a way to limit the number of threads used by a cabal build process?
18:25:25 <exio4> ansible1: -jX as parameter
18:25:36 <ansible1> cool, thx
18:26:01 <marchelzo> So is it typical with these sorts of libraries to have the constructors be in the IO monad? e.g. libFooNew :: IO Foo
18:26:13 <geekosaur> typical and necessary
18:26:25 <marchelzo> Right. Okay.
18:26:26 <geekosaur> if it's returning a pointer to something outside of Haskell, it is by definition impure
18:26:54 <dramforever> marchelzo: depending on the situation unsafePerformIO might be suitable
18:26:57 <exio4> marchelzo: unless you can wrap the whole thing into something that is pure, yes 
18:27:09 <dramforever> marchelzo: how pure is that external library
18:27:17 <geekosaur> and claimig otherwise leads to the compiler possibly creating multiple copies of the thing you are getting from C, or otherwise triggering hard to debug errors
18:27:48 <geekosaur> if you know that it is actually pure then there is unsafeLocalState
18:28:15 <geekosaur> (don't use unsafePerformIO, at least if you are using multiple threads; it will do extra locking that you typically do not need)
18:28:19 <marchelzo> The library is built for doing IO, so I suppose there's no harm in having any allocations be in the IO monad.
18:29:00 <dramforever> sure
18:29:57 <dramforever> hmm...unsafeLocalState
18:30:20 <dramforever> wow this thing actuall exists
18:31:50 <dramforever> geekosaur: looks like unsafeLocalState just calls unsafeDupablePerformIO
18:32:36 <dramforever> interesting...
18:34:59 <geekosaur> yes, and the Dupable part is skipping the lock I mentioned
18:35:11 <dramforever> =) thanks for the information
18:35:11 <geekosaur> it prevents threads colliding during I/O
18:35:21 <dramforever> oh you mean noDuplicate?
18:35:41 <geekosaur> unsafePerformIO locks Handle buffers and such
18:35:52 <geekosaur> unsafeDupablePerformIO doesn't
18:36:02 <dramforever> so actually unsafePerformIO is pretty safe
18:36:17 <dramforever> it basically just subverts the type system, right?
18:36:24 <geekosaur> it's safe here, just a bit slower because you;re not going to be manipulating the guts of GHC's IO subsystem in the foreign call
18:36:27 <Nik05> hello
18:36:27 <geekosaur> so no need to lock them
18:36:44 <mniip> [03:33:21] <dramforever> so actually unsafePerformIO is pretty safe
18:36:45 <dramforever> looks good =)
18:37:00 <mniip> unsafePerformIO |- unsafeCoerce
18:37:17 <geekosaur> mniip, the context here is I advised using unsafeLocalSTate instead of unsafePerformIO for foreign calls that are actually pure
18:37:18 <Nik05> I got a class declaration in Foo, A instance of this class in Bar. And when i import Bar in another module and i want to call a method of this class it says not in scope.
18:37:22 <geekosaur> not general unsafePerformIO
18:37:23 <dramforever> mniip: "it basically just subverts the type system"
18:37:33 <scshunt> Nik05: that's because it isn't
18:37:37 <scshunt> the name is exported from Foo and not Bar
18:37:42 <Nik05> ooh oke
18:37:56 <scshunt> the instance is in Bar, and you need to import Bar to get it
18:38:05 <scshunt> but that doesn't mean you get the name
18:38:07 <dramforever> Nik05: you can also reexport the class in Bar
18:38:18 * hackagebot curve25519 0.2.2 - Fast implementations of the curve25519 elliptic curve primitives.  https://hackage.haskell.org/package/curve25519-0.2.2 (AdamWick)
18:38:26 <Nik05> oh so module Bar (module Foo) where ?
18:38:46 <dramforever> that's too much, just module Bar (ThatClass) where
18:39:01 <dramforever> wait maybe you need ThatClass(..)
18:39:17 <nullvoid8_> What if ThatClass is imported qualified?
18:39:48 <nullvoid8_> would it be exported as ThatClass, not XYZ.ThatClass ?
18:40:04 <dramforever> I don't know, try it
18:40:05 <Nik05> oke what will export Foo and evrything else in Bar?
18:40:09 <geekosaur> the only qualification would be the one in the import, not the export
18:40:23 <geekosaur> but if you imported it qualified in Bar then you need the qualification in the export list
18:40:31 <dramforever> Nik05: oh that "too much" one will export everything in Foo
18:40:37 <nullvoid8_> geekosaur: cool, thanks
18:40:56 <Nik05> dramforever no i want to export everything in Bar and export the class in Foo
18:40:57 <dramforever> but if all you have is (module Foo) then nothing in Bar is exported, except instances
18:41:25 <dramforever> then module Bar (ThatClass, module Bar) where
18:41:32 <Nik05> oke thank you
18:44:46 <Nik05> hm now i get No instance for (Foo r0) ... type variable r0 is ambiguous. potential instance available: gives me the instance i need
18:44:52 <gamegoblin> @pl \x -> y >> x
18:44:52 <lambdabot> (y >>)
18:44:57 <Nik05> why doesnt it pick the one available?
18:45:21 <dramforever> because there might be other instances that could also fit in here
18:45:41 * dramforever is trying to think of an example
18:46:06 <dramforever> @let class ToInt a where toInt :: a -> Int
18:46:07 <lambdabot>  Defined.
18:46:18 <athan> Is there an `equal :: (Eq a, Foldable f) => f a -> Bool`?
18:46:20 <dramforever> @let instance ToInt Int where toInt = id
18:46:21 <lambdabot>  Defined.
18:46:33 <dramforever> > show (toInt 2)
18:46:34 <lambdabot>      No instance for (ToInt a0) arising from a use of ‘toInt’
18:46:34 <lambdabot>      The type variable ‘a0’ is ambiguous
18:46:34 <lambdabot>      Note: there is a potential instance available:
18:46:40 <Nik05> oh oke
18:46:40 <ski> Haskell uses OWA (Open-World-Assumption) when reasoning about instances. not knowing there is another instance doesn't mean knowing there is not another instance
18:47:03 <Nik05> So even if there is only one instance its still ambiguous
18:47:11 <Nik05> thank you dramforever 
18:47:24 <ski> some third party might later try to use your code together with code that uses another instance. it would be confusing if your code stopped working in that case
18:47:25 <dramforever> =)
18:47:31 <Nik05> thank you ski
18:47:32 <athan> I've actually had contexts demanded for single instances before :x
18:47:33 <Javran> athan: take the first element and do (all (== ?)) on rest of the elements?
18:47:47 <athan> Javran: That's what I was thinking, but there must be a better way
18:47:59 <athan> Maybe with Foldable1
18:48:19 * hackagebot streaming 0.1.0.3 - A general free monad transformer  optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.3 (MichaelThompson)
18:49:09 <athan> eck
18:50:51 <athan> I think `equal = foldr1 (==)` is fair
18:51:09 <ski> doesn't handle the empty case ?
18:51:38 <ski> hm
18:51:39 <ski> @type foldr1 (==)
18:51:40 <lambdabot> Foldable t => t Bool -> Bool
18:51:40 <athan> ahh
18:51:59 <athan> `asc = foldr1' (>=)`?
18:52:08 <athan> er without the prime
18:52:17 <dramforever> it doesn't handle anything
18:52:20 <exio4> @type \f -> foldr1 ((==) . f)
18:52:21 <lambdabot> Foldable t => (Bool -> Bool) -> t Bool -> Bool
18:52:23 <dramforever> :t foldr1 -- problem
18:52:24 <lambdabot> Foldable t => (a -> a -> a) -> t a -> a
18:52:48 <athan> Oh wait I derped
18:53:34 <dramforever> hint: you can use implicit arguments when experimenting with lambdabot
18:53:43 <dramforever> :t foldr1 ((==) . ?f)
18:53:43 <athan> bifoldable, maybe?
18:53:44 <lambdabot> (Foldable t, ?f::Bool -> Bool) => t Bool -> Bool
18:53:49 <athan> :O
18:53:58 <athan> splode
18:54:32 <gamegoblin> @pl \x y -> x >> z >> y
18:54:33 <lambdabot> (>>) . (>> z)
18:57:27 <Nik05> damn all types of the function is defined are correct but program doesnt work as it should :(
18:58:14 <Zemyla> :t maybe True snd . foldr (\a mb -> Just $ maybe (a, True) (\(b, p) -> (b, p && (a == b))) mb) Nothing
18:58:15 <lambdabot> (Eq a, Foldable t) => t a -> Bool
18:58:19 <dramforever> Nik05: you can still be confident that you are not wandering too far into the wild
18:58:25 <Zemyla> Is that what you're looking for?
18:58:25 <Nik05> ;p
18:58:26 <geekosaur> haskell's not quite good enough to capture everything in the types. try agda or idris next time :)
18:58:46 <dramforever> geekosaur: duh
18:58:53 <athan> Thank you Zemyla :)
18:59:22 <Nik05> oh i think i see the problem
18:59:23 <dramforever> with agda/idris/coq most your debugging time will be "why this doesn't type check"
18:59:46 <dramforever> Nik05: see, I was right
19:00:02 <Nik05> ah it works :)
19:02:14 <Zemyla> dramforever: So it really does bring to life the dream of "If it typechecks, it's correct"?
19:02:36 <dramforever> Zemyla: if it typechecks, things are probably fine
19:03:16 <dramforever> not like those dynamically typed languages where you could accidentally pass in an argument of the wrong type or something
19:03:27 <geekosaur> heh
19:03:30 <geekosaur> :t (+)
19:03:31 <lambdabot> Num a => a -> a -> a
19:03:36 <geekosaur> :t (-)
19:03:37 <lambdabot> Num a => a -> a -> a
19:03:46 <geekosaur> swapping one for the other will typecheck...
19:03:59 <dramforever> I hate numbers
19:04:04 <ski> @type \f -> foldr1 f . proj
19:04:05 <lambdabot> (Functor t, Foldable t) => (c -> c -> c) -> CoYoneda t c -> c
19:04:26 <dramforever> geekosaur: if you wrote code that requires monoids instead
19:04:31 <dramforever> there won't be a problem
19:05:06 <athan> Zemyla: Would you consider that function being in base?
19:05:55 <dramforever> geekosaur: that's why I hate those sin/cos stuff
19:06:16 <dramforever> by converting between ratios and angles you are effectively losing type information
19:07:44 <scshunt> Zemyla: sort of
19:07:52 <scshunt> Zemyla: you can prove a whole lot about your code
19:07:59 <scshunt> you can *still* make logic errors
19:08:02 <scshunt> but odds are really low
19:08:11 <scshunt> the downside is that the more proofs you add, the more complex the coding is
19:09:19 <Nik05> thank you dramforever, have a good night
19:09:25 <dramforever> morning here
19:09:34 <Nik05> goodmorning then ;)
19:09:35 <dramforever> /me says "have a good day" to himself
19:09:46 <ski> dramforever : ratios of full turns ?
19:09:55 <Nik05> ah and you too ski 
19:10:00 <Nik05> thank you for the help
19:10:08 <dramforever> you're welcome
19:10:32 <Zemyla> scshunt: Well, there probably isn't ever going to be a typechecker that can notice you typed "Hellp world!" instead of "Hello world!"
19:10:50 <mniip> Zemyla, lies
19:11:06 <scshunt> there is... but only if you ask it to prove that you wrote "Hello world!"
19:11:07 <Zemyla> But that still puts it leagues ahead of C, where the rule pf thumb is, "If it doesn't typecheck, it's probably a compiler bug".
19:11:32 <ski> Nik05 : np
19:11:43 <mniip> you could incorporate NLP using a bunch of type families over typelits
19:12:19 * ski . o O ( Neoro-Linguistic Programming )
19:12:40 <Zemyla> Yes, but you can at best make it a warning. Sometimes your code needs to tell someone "Hellp world!"
19:12:49 * ski . o O ( Nitrogelatin Leaderless Plesiotype )
19:12:50 <scshunt> Zemyla: Well, that depends
19:12:53 <Zemyla> I mean, look at SMTP and its HELOs.
19:12:59 <scshunt> you can prove that a function that outputs "Hello world!" does so
19:13:10 <scshunt> you can't prove that the user wants a function that outputs "Hello world!"
19:13:24 <dramforever> "If it doesn't type check, raise your hand and call the teacher"
19:22:43 <Aearnus> I'm trying to make a simple little game in haskell, and it stops responding to input and I can't figure out why
19:22:50 <ttt_fff> so I just wrote the must $^%&-ing amazing macro in haskell: "  #define myMakeLens(nm, selector, from, to) nm :: Lens from from to to; nm f lhs = fmap (\x -> lhs{ selector = x }) (f $ selector lhs); "" <-- the benefits of not having ot hadn write Lens, but also not needing compile time TH to generate it
19:22:52 <Aearnus> http://lpaste.net/7401579207769194496 here's what I've wrote
19:23:17 <dramforever> :t lens
19:23:18 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
19:23:31 <ttt_fff> Aearnus: lines 2/3 can be repalced with "(deriving Eq)"
19:23:41 <dramforever> deriving (Eq)
19:23:43 <ttt_fff> oh wait
19:23:43 <dramforever> ftfy
19:23:47 <ttt_fff> lines 2/3 causes infinite lop
19:23:54 <Aearnus> oh. i'm an idiot
19:23:55 <geekosaur> yep
19:23:57 <ttt_fff> lines 2/3 causes your infinite loop, it type checks, but it just recursivley calls itself
19:23:59 <dramforever> interesting
19:24:03 <ski> .. or `deriving Eq'
19:24:04 <marchelzo> Can you not access CPP macros defined by C libraries through the FFI?
19:24:05 <geekosaur> also I willnote that line 26 is unnecessary
19:24:07 <Aearnus> yeah, I understand whats going wrong there
19:24:39 <geekosaur> marchelzo, nope, it interfaces via the linker and CPP macros don't exist at the linker level
19:24:46 <Aearnus> and I just added line 26 to see if maybe there was a super weird bug with what I was doing, and it didn't fix it, so obviously not
19:25:00 <dramforever> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html
19:25:05 <geekosaur> back when ghc compiled through C there was a way to do it, but it compiles directly to machine (or llvm byte) code these days
19:25:05 <marchelzo> geekosaur: How can I work around this?
19:25:09 <ski> ttt_fff : you don't get hygiene by CPP
19:25:19 <lf94> This is a little off-topic:
19:25:21 <lf94> Does scheme have something similar to map in Haskell?
19:25:26 <ttt_fff> ski: I don't get alot of stuff by CPP, but TH slows down compile times quite a bit
19:25:27 <exio4> it has map
19:25:31 <ski> marchelzo : not without grovelling, iirc
19:25:47 <lf94> exio4, example?
19:25:48 <ttt_fff> ski: though I do see that GHC has an option for pre-processor; I wonder why libraries like Control.Lens don't ship with their own pre-processor
19:25:53 <ski> lf94 : there's also #scheme
19:26:01 <geekosaur> marchelzo, usually you have a stub C library that exports a variable that you initialize to the value of the CPP macro
19:26:11 <geekosaur> then you can FFI that variable
19:26:11 <dramforever> weird
19:26:13 <scshunt> marchelzo: CPP macros are by their nature completely lost in the compiled executable
19:26:13 <dramforever> wait
19:26:19 <exio4> > (map (lambda (x) (+ x 1)) '(1 2 3))
19:26:20 <dramforever> see section 8.1.5 of the GHC user guide
19:26:21 <lambdabot>  <hint>:1:29: parse error on input ‘1’
19:26:21 <scshunt> (except in some forms of debug information, sometimes)
19:26:21 <exio4> '(2 3 4)
19:26:21 <dramforever> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html
19:26:23 <exio4> in Racket 
19:26:44 <dramforever> marchelzo: ^ section 8.1.8
19:26:47 <dramforever> *8.1.5
19:26:53 <dramforever> ghc actually seems to support it
19:27:29 <lf94> Thanks exio4 
19:27:33 <lf94> It's for a friend lol
19:27:39 <lf94> I'm trying to get him through SICP
19:27:43 <marchelzo> dramforever: Awesome! Hopefully it Just Works.
19:27:51 <dramforever> hope so
19:28:15 <geekosaur> huh
19:28:28 <geekosaur> thought I'd heard that was dubious or broken since the switch to -fasm
19:28:33 <dramforever> too bad
19:28:36 <dramforever> marchelzo: too bad
19:28:58 <dramforever> anyway you can still use a wrapper
19:29:20 <geekosaur> well, go ahead and try it (declaring the extension of course)
19:29:45 <marchelzo> Ah, it appears the values are not macros, but enums.
19:29:59 <dramforever> oh =)
19:30:04 <marchelzo> I'm in luck.
19:30:17 <Zemyla> ttt_fff: Infinite lop? Like a bunny with arbitrarily long ears?
19:31:31 <Diabolik> noob question
19:31:35 <Diabolik> in this function
19:31:37 <Diabolik> http://lpaste.net/3963359085893517312
19:31:38 <Diabolik> where is t_min and t_max defined?
19:32:13 <geekosaur> Diabolik, notice lines 6-8 (although indentation is wrong on 7 and 8)
19:32:42 <geekosaur> a where clause lets you create local bindings within another binding
19:33:16 <geekosaur> hm, actually that seems wrong because parens attach the where to an expression
19:33:26 <Diabolik> im working through a book
19:33:28 <Diabolik> so its not my code
19:34:24 <saulzar_> Is there some common type people use for converting between lists of tuples/tuples of lists - e.g.   ListsOf (a, b) = ([a], [b])?
19:34:24 <exio4> that doesn't compile at all
19:35:00 <exio4> geekosaur: "attach the where to an expression" feels like nonsense to me, as that isn't possible
19:35:19 <saulzar_> Before I roll my own, it seems like something someone might have put some thought itno previously
19:35:31 <geekosaur> exio4, that was my point
19:35:43 <geekosaur> it looks like invalid haskell to me
19:36:12 <rlewis> saulzar can you give an example of your input and desired output
19:36:19 <geekosaur> in fact it's worse than that because the parens define a tuple, not merely bracketing
19:36:32 <dmj`> :t unzip
19:36:33 <lambdabot> [(a, b)] -> ([a], [b])
19:36:40 <dmj`> saulzar_: ^
19:38:56 <Zemyla> GHC used to have an Evil Mangler?
19:39:43 <geekosaur> yep. big ugly perl script; when ghc compiled to C, it wasn't actually directly usable --- you had to generate assembly source from the C, and then run the Evil Mangler over it to fix up tail calls and calling conventions and such
19:40:15 <Zemyla> Sweet Lord.
19:40:46 <geekosaur> (C not being very good at doing jump-to-function instead of call-function --- although IIRC gcc has ways to do that)
19:41:20 <saulzar_> dmj`, rlewis  - Yeah maybe I'm over thinking things.  I'm ideally looking for some kind of container for accumulating several different lists. 
19:41:30 <ski> @quote mangler
19:41:30 <lambdabot> Pseudonym says: All hail the Evil Mangler!
19:41:39 <dramforever> what about wrting the whole program in a single function and use labels?
19:41:56 <dramforever> oh who cares...
19:41:58 <Cale> Zemyla: weren't you around the last time I linked it?
19:42:14 <Cale> Zemyla: here: http://www.cs.virginia.edu/~wh5a/personal/House-0.8.92/ghc-6.8.2/driver/mangler/ghc-asm.lprl
19:42:16 <Zemyla> Nope.
19:42:26 <Cale> I'm probably not remembering clearly
19:42:51 <Cale> Yeah, it mangled the assembly output of GCC, stripping out everything having to do with management of the stack.
19:42:58 <saulzar_> rlewis, Then flatten them to a base type so I can go   ListsOf r -> r   assuming all the parts are Monoid or some such, I just don't know how to express it properly
19:43:28 <Cale> It's a hideous perl script which accomplishes this task through lots of regex substitutions.
19:43:36 <hodapp> O_O
19:44:06 <geekosaur> yes, well, now you know why the ghc devs wanted to kill off compiling via C so badly :)
19:44:15 <Cale> yeah :)
19:44:25 <Zemyla> Cale: Slightly less evil than I was expecting?
19:44:38 <Zemyla> I was expecting it to mangle the binary.
19:45:02 <arahael> geekosaur: Still, it'd have numerous benefits.
19:45:05 <Zemyla> :t foldMap -- saulzar_
19:45:06 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
19:45:49 <arahael> geekosaur: It'd stop us from worryingif we get left behind when we want to build our apps for some platform, where all we have is a C or C++ compiler, and ghc doesn't seem to support it.
19:45:56 <Cale> arahael: Well, it did at the time, but eventually GHC's native codegen got good enough that via-C wasn't really too valuable.
19:46:32 <Cale> arahael: Due to the necessity of mangling, it wasn't easy to get things building via C on new architectures.
19:46:35 <arahael> Cale: As an example, I'm wondering if it's possible to generate 64-bit binaries that use iOS SDK 8.
19:47:06 <arahael> Cale: Dosen't javascript also require mangling?
19:47:30 <dramforever> I don't think so
19:47:34 <Cale> There's no javascript compiler, it just compiles directly from intermediate code to javascript and then it's done.
19:47:39 <dramforever> there's nothing to mangle
19:47:51 <Cale> and that's what runs in your browser
19:47:57 <dramforever> even if you can mangle it is still javascript
19:48:08 <geekosaur> yep
19:48:09 <arahael> Cale: Is there a reason why we can't support C in a similar way?
19:48:14 <dramforever> Cale: well there's a thing called asm.js that's supposed to speed some things up
19:48:30 <Cale> arahael: We could, possibly.
19:48:37 <arahael> Cale: That'd be amazing.
19:48:44 <geekosaur> next up, webassembly backend <gd&r>
19:48:44 <Cale> arahael: It probably wouldn't be as good as the old via-C
19:49:04 <Zemyla> Isn't new and weird targets what -fvia-LLVM is for?
19:49:15 <Cale> Yeah, just compile via LLVM
19:49:41 <arahael> Cale: My main concern are what to do if 1) You hvae to use a particular LLVM, eg, apple's LLVM with a particular SDK, and 2) You have to generate 64-bit binaries.
19:49:41 <Cale> LLVM is better than C for most of the things which C is still good at relative to high level languages.
19:50:55 <Zemyla> Well, I kind of wanted -fvia-C so I could see what my programs looked like once compiled.
19:51:12 <hodapp> I have been wondering about making an LLVM backend for Ivory too, as some of C's flow control is limiting, but on the other hand Ivory's EDSL is kind of tied to C semantics.
19:51:39 <geekosaur> the C output was almost as hideous as the evil mangler, really
19:51:46 <geekosaur> and not even remotely portable, if that was your plan
19:51:55 <arahael> The output of the copmiler is merely compiled output. Why does it matter?
19:51:57 <geekosaur> there was a *different* backend for that (-funregisterised)
19:52:23 <hodapp> but, particularly, I wanted a way to do optimized tail calls in Ivory and some continuation-passing stuff
19:52:28 <arahael> All I care, is that the output can be plugged into iOS's build system, or android's build system, or wahtever.
19:52:38 <geekosaur> C output could not
19:52:41 <hodapp> and the only way I could see of doing this in C was with some wonky trampolining nonsense.
19:52:52 <geekosaur> because it has to know the size of things on the target system, not the host system.
19:52:52 <arahael> Actually gcc _does_ support tail call eliminatino, iirc.
19:53:01 <geekosaur> it was not designed for cross compilation
19:53:12 <geekosaur> you used -funregisterised for that
19:53:31 <arahael> geekosaur: It's cross compilation i'm most interested in.  It'd be painful to do otherwise for the iPhone.
19:53:32 <geekosaur> which made maximally pessimal assumptions and wrote out portable ANSI C
19:53:55 <Zemyla> geekosaur: I just wanted to look at it, honestly.
19:54:02 <geekosaur> the current way you do things is -fllvm because you can that way defer the nonportable stuff to the LLVM bytecode translator
19:54:45 <arahael> geekosaur: Does that work when mixing up ghc's llvm with whatever llvm apple provides?
19:55:07 <nshepperd> there are multiple llvms?
19:55:30 <geekosaur> there are compatibility issues but ghc is specific about supported versions and Apple's modified llvm is specifically taken into account
19:55:50 <arahael> Ah, nice, so it should be possible to generate 64-bit iOS apps?
19:55:57 <geekosaur> nshepperd, apple ships modified versions of various LLVM/clang snapshots
19:56:18 <geekosaur> they do upstream stuff but usually want to make it available before the LLVM folks release
19:56:22 <nshepperd> ._.
19:56:38 <arahael> nshepperd: What's "._."?
19:56:56 <geekosaur> people have been making iOS apps. I don't know about 64 bit though, as I don't do ARM or iOS dev
19:57:18 <geekosaur> but the llvm cross compiler has been used to target both iOS and Android
19:57:22 <arahael> geekosaur: Until "recently", you could get away with 32-bit, but now they have to be 64-bit to get into the app store, afaik.
19:57:34 <arahael> geekosaur: 64-bit fat binaries, to be more precise.
19:57:47 <nshepperd> arahael: a complicated feeling to explain
19:58:03 <geekosaur> "sad platypus" :p
19:58:07 <arahael> nshepperd: A dot, a line, and a dot, doesn't exactly help you get there.
19:58:28 <nshepperd> sad platypus! yes, that
19:58:35 <arahael> geekosaur: Eh?  It's supposed to be a sad platypus, or are you being funny?
19:58:43 <arahael> Ah, curious.
19:59:14 <geekosaur> kinda both? "sad platypus" is how I read it as an emoticon. I think it's actually downcast eyes and lips in a straight line (more frustrated than sad or angry)
19:59:25 <nshepperd> arahael: something like a visual sigh with undertones of sadness and judgement
19:59:40 <geekosaur> that style of emoticon isn't common in here but fairly commin in some other channels I'm in
19:59:46 <geekosaur> *fairly common
20:07:00 <nshepperd> huh, ghc seems to be incompatible with the metadata declarations in newer versions of llvm?
20:07:48 <geekosaur> yes, I did mention it wants specific versions
20:08:01 <geekosaur> you might be better asking in #ghc from here on
20:08:25 <geekosaur> (I am more or less summarizing past discussions there; as I mentioned, I have no direct experience)
20:10:43 <ttt_fff> hmm, what benchmarking tools does ghci provide? my code just went from "instantaneous" to "takes 5 seconds to run" which is seriously hurting my develop / test cycle
20:13:53 <dmj`> ttt_fff: you can type :set +s to see how long something takes to evaluate
20:15:33 <ttt_fff> dmj`: all I got was 1 overall tiing, not intermediate timng
20:15:38 <ttt_fff> i'm hoping for something like gprof
20:17:39 <dmj`> ttt_fff: can you break down your functions and evaluate each indepedently? Otherwise there is the timeit library
20:17:44 <dmj`> @package timeit
20:17:44 <lambdabot> http://hackage.haskell.org/package/timeit
20:17:59 <dmj`> ttt_fff: o/w just profile w/ ghc
20:18:11 <ttt_fff> dmj`: no, it's more like (1) here's a list of lemmas (2) now try to prove it, and (3) haskell is like this is going to be slow
20:27:47 <arahael> *sigh*
20:31:00 <dmj`> ttt_fff: can you paste your code
20:31:36 <ttt_fff> dmj`: no, it's a 3803 LOC LCF-like automated theorem prover
20:31:51 <ttt_fff> this is pretty $%^&-ed
20:31:53 <dramforever> ttt_fff: problem: what does profiling individual functions even mean?
20:32:15 <ttt_fff> given the context of laziness + thunks, I ahve no idea, what even means to attrbute a cost to something
20:32:32 <ttt_fff> I'm deeply suspecting, though I can't verify this ... that it's my visualization code which is killing me, not the algorithm it self
20:32:33 <arahael> So I've started writing a document that explains what a monad is.
20:33:42 <dramforever> wait I think ghc can profile your code
20:33:42 <dramforever> and it supports profiling individual functions
20:33:43 <dramforever> somehow
20:34:31 <dmj`> ttt_fff: you should check out ghc_vis
20:34:36 <dmj`> @package ghc-vis
20:34:36 <lambdabot> http://hackage.haskell.org/package/ghc-vis
20:34:55 <dmj`> "Visualize live data structures in GHCi. Evaluation is not forced and you can interact with the visualized data structures. This allows seeing Haskell's lazy evaluation and sharing in action."
20:35:21 <ttt_fff> dmj`: this is not the 'visualization' problem I have, but it looks very cool
20:35:40 <ttt_fff> alright; I'm going to grab dinner and curse this stupid LCF checker
20:37:04 <arahael> With a haskell free monad, how is it different to say, a set of s-expr's in lisp?
20:37:44 <arahael> I somehow think with the free monad, I'm doing _type_ level hackery, such that I potentially do the transforms, if any, at compile time.
20:37:54 <arahael> But is this a misleading way of thinking about it?
20:39:21 <arahael> ie, is it more efficient to have a Free Monad type explaining how to do some sort of operation - which requires interpretation of types, or to instead have a tree datastructure, which requires interpretation of values.
20:40:41 <johnw> arahael: you're not doing type-level transforms
20:40:47 <johnw> so, the difference between a free monad and an s-expr is that a free monad is structured by the given functor
20:40:51 <johnw> that is, the set of possible tree structures allowed is constrained by the choice of functor
20:41:24 <arahael> johnw: I thought that those functors were constrained by the types we use?
20:41:28 <dramforever> hmm
20:41:38 <johnw> I'm not sure I understand that question
20:41:40 <dramforever> a lisp-list is like Free []?
20:42:15 <arahael> johnw: For example, suppose I define a type where there are only two constructors: Walk x, and Wait x, where 'x' is the continuation.
20:42:21 <johnw> dramforever: yes, i think that's right
20:42:28 <arahael> johnw: How can a functor define 'Run x'?
20:42:30 <johnw> infinitely nestable lists
20:42:36 <dramforever> yes
20:42:45 <arahael> dramforever: Yes, except that the list doesn't flatten when you compose it.
20:42:47 <johnw> arahael: I'm still confused
20:42:58 <johnw> if you have two constructors, Walk and Wait, where does Run come into play?
20:42:59 <dramforever> arahael: flatten?
20:43:08 <arahael> dramforever: [[]] -> []
20:43:10 <johnw> Free [] won't flatten, unless your evaluator has that behavior
20:43:16 <arahael> Ah, ok.
20:43:26 <dramforever> arahael: I don't think any lisp flattens lists like that
20:43:30 <johnw> the nice thing about Free is that *all* semantics are deferred until reduction
20:43:43 <arahael> johnw: So, I mean, normally you have a type that defines Walk and Wait, and functors that define walk and wait.
20:43:50 <dramforever> arahael: I think this Free [] thing answers your question
20:43:55 <arahael> johnw: How would you deifne a functor 'run'?
20:43:56 <johnw> what do you mean by "functors that define walk and wait"?
20:43:58 <dramforever> about the relation of s-exps and Free
20:44:15 <dramforever> Free is more general
20:45:08 <arahael> johnw: I think I should find a real example we can then discuss - give us a common ground.
20:45:12 <arahael> johnw: One momen.t
20:45:13 <johnw> Free abstracts terminating type recursion, where Fix (or Mu) abstracts just the recursion (Free is a special case of Fix)
20:45:35 <johnw> arahael: I'm just not clear on your use of the word "functor" here
20:45:44 <johnw> 'run' cannot be a functor in Haskell
20:45:48 <dramforever> I consider Fix as the limit F^n as n approaches infinity
20:45:52 <johnw> it could only be either a variable name, or a function name
20:46:26 <dramforever> whereas Free is the limit of sum F^k, k from 0 to n
20:46:35 <dramforever> as n approaches infinity
20:46:44 <arahael> johnw: Ah, I see.  I meant a function that operates on the type, but I'm using the term incorrectly.  One moment as I find an example.
20:46:58 <ski> (hmm .. you could represent a collection (e.g. a list) of binary trees, where all the tres are enforced by the types to have the same (run-time determined) shape)
20:46:59 <dramforever> this limit thing really helps to avoid confusion such as "how could this infinite thing possibly represented"
20:47:02 <dramforever> *be possibly
20:47:03 <johnw> do you mean a functions that accepts a value of that type?
20:47:13 <arahael> johnw: Yeah, I did.
20:47:28 <arahael> johnw: Except that such functions, iirc, tend to be named after the variosu type constructors.
20:47:38 <dramforever> ski: or you could have a binary tree of lists
20:47:42 <johnw> ok, then I think you're referring to evaluators from Free f a -> f a, or Free f a -> a perhaps
20:47:44 <arahael> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
20:47:47 <dramforever> oh wait no...
20:47:48 <dramforever> no...
20:47:48 <ski> arahael : a functor is a type-level thing (together with a value-level thing called `fmap' that satisfies a couple of laws)
20:48:03 <arahael> johnw: So, in 'you-could-have-invented-free-monads', the author defines the 'Toy' type.
20:48:11 <johnw> right
20:48:14 <dramforever> I understand a functor as an instance
20:48:27 <dramforever> "instance Functor F where ..." this is the functor
20:48:34 <arahael> johnw: Typically, in this case ,after turning Toy into a Functor form, you'd define function for each constructor: Output, Bell, and Done.
20:48:39 <ski> `Maybe' (together with its definition of `fmap') is a functor
20:48:42 <johnw> dramforever: that's just one third of the functor
20:48:43 <arahael> johnw: (The functions being output, bell, and done)
20:48:55 <johnw> the type constructor is one third, the instance is one third, the unwritten laws are the last third
20:48:56 <dramforever> johnw: oh perhaps
20:49:03 <dramforever> you mean the laws?
20:49:15 <dramforever> oh sure I didn't see your message
20:49:20 <johnw> there's the object map, a -> f a, the function map, then the laws, yeah
20:49:25 <ski> `instance Functor Maybe where fmap _ Nothing = Nothing; fmap f (Just a) = Just (f a)' makes `Maybe' into a functor by defining `fmap' for it
20:49:28 <arahael> johnw: How would a function "input" be written? (You can't, as it's bound by the type constructors)
20:49:37 <arahael> johnw: Limited by the type constructors, rather.
20:49:39 <dramforever> johnw: I thought there's an F in the instance, as well as fmap
20:49:46 <johnw> arahael: what would input do?
20:49:56 <dramforever> as well as the trust that we will only ever write valid functor instance
20:49:59 <dramforever> so I think that's it
20:50:01 <johnw> dramforever: sure, but it exists before the instance
20:50:06 <dramforever> oh
20:50:10 <dramforever> hmm...
20:50:14 <flaiw> http://privatepaste.com/b13b384b7d How does the types in this example make sense? If sized return |Gen a| and sizedList/myVector returns |Gen [a]|, aren't the types wrong?
20:50:22 <johnw> the instance is enriching the object map with morphism mapping
20:50:25 <arahael> johnw: It's nonsensical.  My point is that it can only do what the type exposes.  "input" has no meaning - you'd have to actually add a new type constructor to be able to explain what input does.
20:50:34 <johnw> arahael: ah, yes, that's exactly right
20:50:36 <dramforever> johnw: this is good =)
20:50:41 <johnw> arahael: that's what I mean by "functor constrained shapes"
20:50:51 <johnw> Free gives you trees whose possible shapes are constrained by the choice of functor
20:51:04 <arahael> johnw: Ah, I see. :)  I find the terminology confusing - you never see it in typical languages.
20:51:06 <johnw> thus, they define a syntax
20:51:49 <dramforever> DSL in typical languages oh my god
20:51:52 <arahael> johnw: But...  Aren't these function merely a convenience for defining the type (with it's continuations)?  Ie, the end result is that you have a Toy.
20:51:58 <arahael> dramforever: Ruby is famous for it.
20:52:00 <johnw> (the functor defines the syntactic kernel, or the "term algebra")
20:52:02 <dramforever> these aren't even the same thing
20:52:05 <arahael> dramforever: As are the lisps.
20:52:15 <dramforever> arahael: the infamous method_missing
20:52:16 <arahael> dramforever: THAT is my root question!  Why aren't they the same thing?
20:52:16 <ski> flaiw : `sized' is polymorphic. in the call to `sized' in `sizedList', the `a' in the type signature of `sized' becomes `[a]' for the `a' in the type signature of `sizedList'
20:52:17 <johnw> arahael: which functions?
20:52:29 <dramforever> arahael: because they aren't even implemented the same way
20:52:46 <dramforever> ever heard of free monads in ruby?
20:52:47 <johnw> "these funtions merely a convenience"; which functions do you mean?
20:52:49 <johnw> the evaluators?
20:52:50 <arahael> johnw: In this example, output, bell, and done, are convenience functions for constructing a Free Output, Free Bell, and Free Done.
20:53:00 <nshepperd> other languages abuse the word 'functor' to mean 'function object', so you must remember that's not how we use the term in haskell
20:53:09 <johnw> oh, you're talking about convenience functions for constructing leaves of the syntax tree
20:53:11 <dramforever> nshepperd =)
20:53:13 <ski> flaiw : iow, `sizedList :: Gen a -> Gen [a]' is using the specific polymorphic instance `sized :: (Int -> Gen [a]) -> Gen [a]'
20:53:15 <johnw> yeah, they're totally just convenience
20:53:17 <arahael> johnw: Yes
20:53:17 <johnw> not necessary at all
20:53:31 <arahael> johnw: So, I'm still working at the type level.
20:53:33 <johnw> output = Free (Output b (Pure ())
20:53:44 <dramforever> arahael: you work at both levels together
20:53:52 <flaiw> ski: ok though it could be something like that. In the QuickCheck documentation it only says |Gen a|, how do I know if functions are polymorphic from the documentations?
20:53:53 <johnw> the type level is providing a constraint here
20:53:53 <arahael> johnw: The result is, a type with many leaves.
20:53:57 <dramforever> not like those type families magical stuff
20:53:57 <johnw> the trees themselves are values
20:54:02 <johnw> the type is the universe of all possible values
20:54:09 <arahael> johnw: Oh? The leaves are values?
20:54:11 <ski> flaiw : because the type signature mentioned a type variable (here `a')
20:54:13 <dramforever> flaiw: ?
20:54:15 <dramforever> example?
20:54:17 <Hijiri> nshepperd: are there languages other than c++ that use "functor" for function objects?
20:54:34 <dramforever> flaiw: oh sorry I didn't read the context
20:54:36 <arahael> Hijiri: In various forms, for example, python does.
20:54:37 <johnw> arahael: the Free + functor type is defining the possible shapes for the tree
20:54:42 <Hijiri> oh, ok
20:54:42 <johnw> a particular tree is a value of that type
20:54:45 <flaiw> ski: so when the type is only 'a' it can be a list of a as well?
20:54:56 <ski> flaiw : note that the `a' in the type signature for `sized' is different (unrelated to) `a' in the type signature for `sizedList'
20:55:09 <johnw> the convenience functions are creating *values* which have that type
20:55:12 <dramforever> flaiw: a type that starts with a lower-case letter is a type variable
20:55:19 <arahael> johnw: So, there is no difference between, a Free Monad in haskell defining this, and using a dynamic structure in a dynamic language (eg, s-expr's in lisp), except that you can use the type system to constrain the tree?
20:55:20 <dramforever> thus it's polymorphic
20:55:20 <johnw> which in this case, are just tree leaves
20:55:35 <dramforever> flaiw: "so when the type is only 'a' it can be a list of a as well?" yes
20:55:54 <dramforever> wait those two 'a's aren't the same thing
20:55:58 <flaiw> ski dramforever : ok that makes sense. I think the usage of 'a' in both functions got me a but confused
20:56:01 <flaiw> thanks for the help :)
20:56:05 <ski> flaiw : we have `length :: [a] -> Int'. this means that for any actual type you plug in for the type variable `a', `length' has (can have) that type
20:56:06 <johnw> arahael: yes!
20:56:06 <flaiw> bit*
20:56:12 <johnw> arahael: types narrow possibilities
20:56:18 <dramforever> flaiw: yeah, it can be confusing at times
20:56:23 <johnw> arahael: a Java Object can be anything.  a Java Integer is some integer
20:56:48 <ski> flaiw : so, `[String] -> Int' is one of the possible types of `length', and `[Int -> Bool] -> Int' is another
20:56:51 <arahael> johnw: A dynamic language might call into another module to generate the structure...  Would it be possible to do this in Haskell as well, say, you've got a makeToy = do...  buildToyFromRestServer ('http:..') ?
20:56:52 <johnw> the more expressive the type, the more you know about any value of that type
20:57:10 <dramforever> arahael: call into another module?
20:57:11 <johnw> arahael: so, you can easily call another module to generate a particular tree
20:57:15 <dramforever> oh sure you can
20:57:26 <johnw> calling into a module to dynamic generate a tree *shape* (i.e., a type), is not something you can easily do
20:57:35 <ski> flaiw : you can even replace `a' with a type expression involving a type signature, so `[(Int,b)] -> Int' is also a possibly type for `length' (meaning it's a possibly type for any actual type you replace `b' with)
20:57:52 <johnw> that's really the domain of dependent types, which can do such things
20:57:54 <arahael> johnw: I suppose I'd need to inject that into makeToy, as an argument, if I were todo that - and that'd be the _only_ way to do this? (Eg, makeToy file = do somethingWithFile(file) ... )
20:58:00 <johnw> now, Haskell can get kind of close, but it has its limits today
20:58:22 <johnw> arahael: you want to generate a syntax from an input file at runtime, and then construct trees according to that syntax?
20:58:28 <arahael> johnw: Yeah, one limit I've already found is that it's difficult to define the terminator.  Eg, Toy has "Done".
20:58:37 <johnw> Pure is always the terminator
20:58:39 <nshepperd> arahael: well arguably lisp s-exprs are constrained to have branches that are lists. but that is constrained by the syntax, not the types
20:58:50 <flaiw> ski: cool thanks.
20:58:51 <arahael> johnw: I'm still conceptualising my thinking - I don't neccessarily want to generate a syntax at runtime from an input file - just wondernig if it can be done.
20:58:58 <johnw> Gabriel is using Fix + Done to show you how he arrives at Free
20:59:00 <nolrai66> You can do full on dependent programing, its just a pain lifing values up and down.
20:59:16 <arahael> nshepperd: Tha'ts not a useful argument...  Any language is constrained to that language's AST.
20:59:32 <johnw> arahael: it can't be done easily in a way that gives you meaningful compile-time checking
20:59:38 <arahael> johnw: But, you can have two Done's in a do notation.
20:59:42 <johnw> yes
20:59:51 <arahael> johnw: Isn't that an error, potentially?
20:59:52 <johnw> the Monad instance's >>= operator defines what happens when two Dones are merged together
21:00:44 <arahael> Particularly if you compose two monads that already have the Done terminators.
21:01:01 <johnw> so, the only thing you could state would be: Done a >> Done b
21:01:03 <nshepperd> arahael: no, I mean a s-expr by definition is a tree of lists (x (y z) (w))
21:01:04 <johnw> in which case, the former is ignored
21:01:32 <arahael> johnw: You'd ignore the whole former tree?
21:01:40 <johnw> the former Done statement
21:01:47 <johnw> I feel like we're getting away from the discussion, though
21:01:51 <nshepperd> arahael: any non-list element is assumed to be a leaf of the tree
21:02:16 <arahael> johnw: I think you're right - the original discussion was the difference between a free monad, and a dynamic structure of values.
21:02:24 <ski> nolrai66 : how would you express `data Img (A : Set) (B : Set) (f : A -> B) : B -> Set where ToImg : (a : A) -> Img A B f (f a)' ?
21:02:26 <johnw> right, which is an important distinction to understand
21:03:06 <arahael> johnw: And my takeaway message is: The only difference is that the type (ie, in this case Toy), defines the type/shape of the strcture - this restriction is the only difference.
21:03:13 <johnw> yep
21:03:19 <arahael> johnw: A tree of lists, in the case of lisp, has no restriction whatsoever.
21:03:24 * hackagebot commutative 0.0.1.2 - Commutative binary operations.  https://hackage.haskell.org/package/commutative-0.0.1.2 (athanclark)
21:03:26 <johnw> types define structure, that's all that they do
21:03:46 <johnw> otherwise, you'd have some piece of information and the meaning of it would be left to decisions made at runtime
21:03:56 <arahael> johnw: What if these types included lambdas?
21:04:06 <johnw> what about it?
21:04:12 <arahael> (Which would have to be a decision made at runtime?)
21:04:15 <johnw> types can include functions
21:04:25 <johnw> lambdas are runtime values, of function type
21:04:26 <nolrai66> ski: That is agda like notation?
21:04:30 <nolrai66> Hmm.
21:04:32 <ski> it's Agda, yes
21:05:01 <arahael> johnw: So you have a piece of information, the meaning of which is a decision made at runtime?
21:05:08 <johnw> Free ((,) (a -> b)) () <-- a list of functions, expressed as a Free structure, entirely equivalent to a list
21:05:09 <arahael> johnw: As you can't evaluate the function prior to interpretation.
21:05:16 <johnw> arahael: in Ruby, say I give you an "x"
21:05:20 <athan> Why isn't `Data.Set.findMax :: Set a -> Maybe a`?
21:05:25 <athan> :t Data.Set.findMax
21:05:26 <lambdabot> S.Set a -> a
21:05:27 <johnw> what you can *do* with the 'x' is the only meaning that it has
21:05:36 <dramforever> > Data.Set.findMax Data.Set.empty
21:05:38 <lambdabot>  Not in scope: ‘Data.Set.findMax’Not in scope: ‘Data.Set.empty’
21:05:39 <nolrai66> ski: Not sure, the hard part is lifting the f.
21:05:41 <johnw> but I'm not in any way constrained by what kind of 'x' I can give you
21:05:43 <arahael> johnw: And in ruby, the answer would be: "Anything".
21:05:48 <johnw> you might expect a function, and I could give you a string
21:05:51 <dramforever> huh?
21:06:00 <athan> o.o
21:06:03 <johnw> with types, you structure 'x' to say "it must be a string or you can't call me"
21:06:08 <dramforever> > Data.Set.findMax Data.Set.empty
21:06:09 <lambdabot>  Not in scope: ‘Data.Set.findMax’Not in scope: ‘Data.Set.empty’
21:06:17 <dramforever> :t Data.Set.findMax Data.Set.empty
21:06:18 <lambdabot> a
21:06:21 <athan> lol
21:06:23 <dramforever> lol
21:06:28 <nolrai66> Wot.
21:06:37 <dramforever> that way I already don't have to evaluate it
21:06:37 <johnw> Free f says, this value has a tree shape defined by f, or it doesn't exist
21:06:48 <athan> Perfect!
21:06:59 <dramforever> kinda like in python
21:07:03 <ski> > S.findMax S.empty  -- dramforever
21:07:05 <lambdabot>  *Exception: Set.findMax: empty set has no maximal element
21:07:05 <dramforever> print foo.type
21:07:08 <arahael> johnw: Awesome, I think I understand it. :)
21:07:12 <dramforever> AttributeError: 'tuple' object has no attribute 'type'
21:07:12 <johnw> arahael: great!
21:07:22 <athan> ski: Is there a safe version? Set a -> Maybe a?
21:07:33 <johnw> arahael: types are addictive, especially in a language like Haskell where the types have so much meaning.  In languages like Java, types have _some_ meaning, but they don't tell the whole story.
21:07:34 <athan> or is that from Data.Foldable.maximum?
21:07:46 <dramforever> :t Data.Foldable.maximum mempty
21:07:47 <lambdabot> (Ord a, Foldable t, Monoid (t a)) => a
21:07:56 <athan> ><
21:07:57 <dramforever> that's pretty much it
21:08:05 <johnw> and in other languages, like Agda or Coq, types tell the *whole* story, whether you like it or not
21:08:11 <dramforever> oh yea
21:08:14 <athan> :t Data.Foldable.maximum
21:08:15 <lambdabot> (Ord a, Foldable t) => t a -> a
21:08:19 <athan> o_o
21:08:20 <athan> mer
21:08:23 <dramforever> dependent types requires the type checker to evaluate terms
21:08:24 <arahael> johnw: How so?  I think there's an intriguing poitn there.
21:08:33 <johnw> arahael: "How so?" to which point?
21:08:37 <dramforever> *aribitary term
21:08:37 <ski> @type \s -> guard (S.null s) >> Just (S.findMax s)  -- athan, i suppose ..
21:08:38 <lambdabot> S.Set b -> Maybe b
21:08:51 <arahael> johnw: For instance, lets say we're trying to impose the same kind of thing in Java, as a Free Monad in haskell.
21:09:02 <dramforever> same kind?
21:09:07 <athan> Thanks ski
21:09:09 <johnw> in Java, a function from Integer -> Integer might also delete files from my disk
21:09:17 <arahael> johnw: Java's types could have the whole story - except that you can go around the type system way too easily.
21:09:19 <johnw> although it's type says it maps integers to integers, it's behavior is not constrained
21:09:34 <nshepperd> ski: aha, you want guard (not (S.null s)) there
21:09:40 <ski> er, yes
21:09:43 <dramforever> in haskell Integer -> Integer could delete files too 
21:09:44 <nshepperd> hehe
21:09:45 <arahael> johnw: Yeah.  Python has the same issue - it's one reason why I tend to detest python's yeild or other lazy-evaluation techniques i thas
21:09:48 * ski is half awake
21:09:55 <dramforever> but it's customary and default not possible
21:09:58 <johnw> a Haskell function from Integer -> Integer either maps integers, or it raises an asynchronous exception, etc.  A Coq function from Integer -> Integer does absolutely nothing else but map integers to integers
21:10:10 <dramforever> johnw ++ 
21:10:11 <ski> (this is what using a boolean gets me)
21:10:24 <dramforever> it can't even have an infinite loop
21:10:45 <arahael> dramforever: Coq doesn't have recursion?
21:10:47 <johnw> yeah, it _has_ to map an integer to an integer
21:10:50 <johnw> it has guarded recursion
21:10:57 <dramforever> arahael: it has restricted recursion
21:11:00 <johnw> you must prove that the recursion will terminate successfully
21:11:06 <dramforever> yes
21:11:17 <johnw> there are no partial functions, period
21:11:17 <arahael> Coq sounds very intruging - I'll have to investigate that later. ;)  For now, haskell's the aim :)
21:11:19 <OtterCoder> I'm sure this has been asked many times, but is there any justification for not allowing plain strings as infix operators without backtics? A link would do if an explanation would be once too often. :) 
21:11:30 <johnw> arahael: if you do, start here http://www.cis.upenn.edu/~bcpierce/sf/current/index.html
21:11:38 <arahael> I do love the idea of not having partials - I find haskell's partials irritating.
21:11:42 <dramforever> hmm that SF book again
21:11:47 <johnw> arahael: enable -XSafe
21:11:57 <johnw> arahael: and turn on -Wall -Werror
21:11:59 <arahael> johnw: Eh?  Nice.
21:12:00 <johnw> it will get you a lot closer
21:12:01 <nolrai66> ski: I give up, but I do think it is theoretically doable, just /incredibly/ obnoxious.
21:12:02 <dramforever> arahael: do remember that it might be too tiredsome to do sometimes
21:12:11 <ski> nolrai66 : i'm not sure
21:12:27 <arahael> dramforever: I guess.
21:12:32 <ski> nolrai66 : also, iirc, there was also some other problem, though i'm too tired atm to recall what it was
21:12:37 <johnw> for real world code, it's not worth the trouble; for theoretic exercises, it can be interesting
21:13:16 <nolrai66> OtterCoder: Example?
21:13:26 <arahael> johnw: My interest in haskell is mostly theoretical these days, though I'm thinking about how to use it in practice. (Hence my regular asking about using it for iOS and Android)
21:13:41 <johnw> arahael: you'll love Software Foundations
21:13:43 <nshepperd> OtterCoder: as in adding an 'infix bar' declaration so that (foo bar baz) = (foo `bar` baz) = (bar foo baz)? 
21:13:43 <arahael> johnw: But my work is mostly python these days.
21:13:44 <johnw> and it will help your Haskell
21:13:54 <nshepperd> OtterCoder: that would make it really hard to read code
21:14:04 <OtterCoder> nolrai66: Say, True and True, instead of True `and` True, as a simplistic example
21:14:06 <johnw> there's nothing like learning an even harder language, to make the hard language seem not so bad
21:14:25 <dramforever> OtterCoder: that way I think the parser will have a hard time
21:14:33 <dramforever> btw why not True && True?
21:14:43 <dramforever> it's hard to run out of symbols...even with lens
21:14:46 <OtterCoder> dramforever: Ah, that sounds fair. 
21:15:00 <nolrai66> OtterCoder: makes the parsers life difficult. Though Agda does it, so its not impossible.
21:15:07 <OtterCoder> dramforever: But, I do like the idea of writing a tiny DSL that reads cleanly.
21:15:09 <dramforever> :t (#.) -- symbols, symbols everywhere
21:15:10 <lambdabot> parse error on input ‘)’
21:15:27 <nshepperd> OtterCoder: the reason it's restricted to symbols and backticks is so it's easy for the parser and also so you can tell whether something is infix just by looking at it
21:15:39 <dramforever> OtterCoder: I don't think it's obvious to see that the and is infix in True and True
21:15:48 <nolrai66> OtterCoder: Also I like being able to sometimes use "fmap f a" and sometimes "f `fmap` a".
21:15:49 <dramforever> hmm...wait a sec
21:16:13 <dramforever> > 3 & (-) 10
21:16:14 <lambdabot>  7
21:16:17 <dramforever> how clean...
21:16:18 <OtterCoder> Well, it's not obvious, but I think it's as much a matter of what we're used to.
21:16:25 <nolrai66> (I mean not when its that short, but when f and a are complicated.)
21:16:31 <dramforever> OtterCoder: yep
21:16:40 <nolrai66> OtterCoder: Like I said Agda does it.
21:16:55 <dramforever> agda also uses all kinds of weird stuff
21:16:55 <Bruuuuuuuno> nolrai66 you can use f <$> a too
21:16:59 <OtterCoder> Never heard of Agda. I'll have to look it up.
21:17:06 <nolrai66> Its fun.
21:17:16 <OtterCoder> Thanks for the tip. :)
21:17:18 <dramforever> <sarcasm>no don't, it hurts your eyes</sarcasm>
21:17:26 <johnw> f ⊗ a
21:17:40 <johnw> (Agda loves Unicode)
21:17:43 <nolrai66> Bruuuuuuno: bad example on my part X/
21:17:47 <dramforever> oh and that set union symbol with a plus sign inside
21:17:58 <johnw> oh yeah
21:18:02 <johnw> or ⨃ for sum types
21:18:12 <nolrai66> I can't type agda without emacs.
21:18:15 <dramforever> and that weird "l"
21:18:20 <johnw> I'm using agda-mode to type these now :)
21:18:21 <dramforever> (the letter L)
21:18:36 <OtterCoder> 8 ಠ_ಠ 3
21:18:38 <nshepperd> OtterCoder: now what about "Foo bar Foo"? is the 'bar' infix?
21:19:05 <dramforever> oh I think I remembered something
21:19:25 <dramforever> if you ever create a notation that uses words like "and", that word becomes a keyword
21:19:34 <Bruuuuuuuno> Hey I need some idea for a project to do in haskell, I'm a student and we have to choose a end project and  I don't know what to do, any idea?
21:19:39 <OtterCoder> nshepperd: It's a matter of definition. You'd have to be more formal with your naming, but it could really work.
21:19:43 <nshepperd> you don't know, not without opening up the docs for 'bar' and finding that no it's not
21:20:28 <nshepperd> OtterCoder: that's sort of what we already did, by making all symbols infix
21:21:01 <OtterCoder> nshepperd: Again, fair, but it precludes some things that I imagine as elegant.
21:21:38 <OtterCoder> But hey, I might be crazy. :)
21:21:38 <arahael> johnw: I'm now trying to figure out how to copy that url into firefox! Damn this laptop. :)
21:22:30 <dmj`> Bruuuuuuuno: you should make the game of Battleship in Haskell
21:22:43 <dramforever> maybe make a package manager for haskell stuff?
21:22:50 <dmj`> Bruuuuuuuno: or contributed to ghcjs
21:22:58 <dramforever> Bruuuuuuuno: maybe make a package manager for haskell stuff?
21:23:15 <dmj`> Bruuuuuuuno: make a new cabal, call it 'hack'
21:23:44 <dramforever> dmj`: no I'm serious
21:23:57 <Bruuuuuuuno> what do you mean package manager, like cabal? dramforever 
21:24:00 <dmj`> dramforever: do you use stack?
21:24:07 <dramforever> Bruuuuuuuno: yes *like* cabal
21:24:11 <dramforever> dmj`: no how's it?
21:24:29 <nolrai66> Bruuuuuuno: Hmm. How much time do you have, and how long have you been programing?
21:24:31 <dramforever> I heard that many things aren't settled yet
21:26:02 <dmj`> dramforever: don't know haven't used it, but I heard it's good
21:26:10 <Bruuuuuuuno> Well, I have like 5 years of experience, and I have 4 months, my biggest haskell project is a chess engine with a basic ai on MPI
21:26:11 <dramforever> =)
21:26:29 <dmj`> dramforever: I use nixpkgs, haven't had any real issues
21:26:45 <dramforever> yes something like nix will be good
21:26:56 <dmj`> Bruuuuuuuno: that's awesome !
21:27:07 <dmj`> Bruuuuuuuno: you should make a good GUI library for haskell
21:27:21 <dramforever> wow can you do that?
21:27:28 <Bruuuuuuuno> yeah, I had to convince 2 person to learn haskell for that project haha
21:27:42 <dramforever> if you succeed in a GUI library
21:27:53 <dramforever> people will be grateful
21:28:00 <dramforever> *in making
21:28:19 <dramforever> my succeed I mean you need to make it good
21:28:23 <dramforever> of course
21:28:42 <Bruuuuuuuno> gui is so hard though
21:28:50 <dramforever> yep
21:29:06 <dramforever> I wonder how is nix going
21:29:28 <arahael> Why is the GUI so hard, as far as haskell is concerned?
21:29:36 <arahael> Whatever the framework is - you're basically registering event handlers.
21:29:38 <dramforever> GUI is hard everywhere
21:29:48 <dramforever> arahael: "event handlers" that's the problem
21:29:55 <dramforever> you end up with global state
21:29:58 <arahael> Yes, but the difficulty isn't doign it in haskell.
21:30:02 <dramforever> and you manage it yourself
21:30:03 <arahael> Yes, of course.
21:30:16 <dramforever> arahael: nobody said that GUI in haskell is harder than in other languages
21:30:21 <arahael> Cool. :)
21:30:29 <dramforever> but here we have a great type system, so...
21:30:35 <dramforever> maybe we could somehow make use of it?
21:30:50 * ski . o O ( Fudgets )
21:31:18 <Bruuuuuuuno> well, GUI in wpf is pretty easy
21:31:41 <Bruuuuuuuno> I really like the MVVM model
21:32:25 <dramforever> looks like wpf is data driven
21:32:40 <dramforever> weird, isn't that just like FRP?
21:32:58 <dramforever> are we...literally...behind others?
21:33:08 * dramforever feels funny here
21:33:23 <Bruuuuuuuno> I don't really understand FRP tbh, I never had time to look into it other that some tutorial that I didn't understood
21:33:31 <dramforever> me too
21:38:11 <arahael> MVVM's inconsistent in practice, though.
21:39:53 <TheTime> |||||| Do you know what your DOMAIN IS WORTH??? Vist >>> www.VALBOT.com <<< for a FREE DOMAIN VALUATION! or Google >>> VALBOT.com <<< ||||||
21:40:00 <Bruuuuuuuno> why arahael 
21:40:43 --- mode: ChanServ set +o Cale
21:40:47 --- mode: Cale set +b *!*@128.199.244.202
21:40:48 --- kick: TheTime was kicked by Cale (TheTime)
21:41:17 --- mode: Cale set -o Cale
21:41:20 <arahael> Bruuuuuuuno: Dunno. Just is. :)
21:41:33 <arahael> Bruuuuuuuno: Especailly if you use winforms hosting, etcetera.
21:41:45 <johnw> Bruuuuuuuno: https://gist.github.com/staltz/868e7e9bc2a7b8c1f754
21:41:48 --- mode: ChanServ set +o johnw
21:41:57 --- mode: johnw set -o johnw
21:42:04 <johnw> Bruuuuuuuno: sorry, never mind that link
21:42:11 <johnw> I think it was another page I was thinking of
21:42:18 <johnw> Cale: thanks, for some reason my kickban macro didn't work
21:43:37 <gamegoblin> Will GHC automatically use the same optimizations of newtypes on data types with 1 member?
21:46:50 <johnw> gamegoblin: no
21:47:02 <gamegoblin> johnw: is there some correctness reason why it can’t be done?
21:47:03 <johnw> newtypes have different semantics from single member 'data' types
21:47:04 <Cale> gamegoblin: no, newtype is not semantically equivalent to data
21:47:11 <gamegoblin> in what way?
21:47:22 <johnw> there is a strictness difference
21:47:40 <johnw> 'data' values add another layer of boxing
21:47:48 <Cale> https://www.haskell.org/onlinereport/decls.html#sect4.2.3 -- see the examples here
21:50:22 <Axman6> gamegoblin: a newtype 'constructor' applied to a bottom value (error, undefined etc) is the same as bottom. A data constructor applied to a bottom value may still be destructed based on the constructor without the result necessarilly being bottom
21:50:25 <lf94> Ok guys, today I need your help setting up my cabal file for HSpec tests.
21:50:43 <gamegoblin> Axman6: ah, thanks
21:50:46 <lf94> I copied+pasted what is here: https://wiki.haskell.org/How_to_write_a_Haskell_program#Structure_of_a_simple_project
21:50:47 <gamegoblin> good example
21:51:26 <Axman6> gamegoblin: remember that newtypes have the same representation at runtime as the value they wrap - the constructor does not exist at runtime
21:51:41 <lf94> But of course, it didn't work
21:52:17 <ski> > case undefined of Identity _ -> ()  -- destructing a bottom based on a `newtype' data constructor without the result necessarilly being bottom
21:52:19 <lambdabot>  ()
21:54:23 <slack__> @let wat2 = Identity undefined
21:54:24 <lambdabot>  Defined.
21:54:49 <slack__> > case wat2 of Identity _ -> "help, is this right?"
21:54:50 <lambdabot>  "help, is this right?"
21:55:05 <Axman6> hmm, perhaos I'm wrong?
21:55:26 <ski> no
21:55:27 <Axman6> perhaps*
21:56:05 <c_wraith> pattern-matching a newtype is no-op.  It forces no evaluation.
21:56:06 <ski> matching on a `newtype' constructor doesn't force (even though the constructor is strict, semantically speaking)
21:57:51 <johnw> ski: that's a wild example
22:00:05 <ski> ?
22:03:04 <EvanR> > case Identity undefined of Identity undefined -> "shoes"
22:03:06 <lambdabot>  "shoes"
22:03:21 <EvanR> seems legit
22:04:38 <EvanR> > case (3, undefined) of (undefined, _) -> undefined
22:04:39 <lambdabot>  3
22:07:51 <EvanR> > case (3, undefined) of (undefined, undefined) -> undefined
22:07:53 <lambdabot>      Conflicting definitions for ‘undefined’
22:07:53 <lambdabot>      Bound at: <interactive>:1:25-33
22:07:53 <lambdabot>                <interactive>:1:36-44
22:08:12 <johnw> ski: matching on undefined, where no matching is actually hapening
22:09:20 <EvanR> when the pattern contains _, no matching happens on that anyway
22:09:38 <EvanR> or any variable pattern, right?
22:10:19 <johnw> his matching was against Identity _
22:10:28 <johnw> but since the Identity doesn't exist at runtime...
22:11:01 <EvanR> yeah pattern match on a newtype of any kind acts different
22:11:06 <ski> EvanR : no forcing, right
22:11:35 <ski> wildcards and variables (and "lazy patterns") are irrefutable patterns
22:11:47 <EvanR> > case undefined of (_,_) -> "shoes"
22:11:48 <lambdabot>  "*Exception: Prelude.undefined
22:12:13 <ski> `(_,_)' is not irrefutable (even though there's no alternative data constructor)
22:21:24 <jle`> why is cabal using 2gb of memory ;_;
22:21:36 <slack__> on caal
22:21:48 <slack__> on cabal update? (sorry RET to soon)
22:21:56 <jle`> cabal install text
22:22:12 <EvanR> gotta anything better to do with that memory? ;)
22:22:44 <EvanR> get a turing machine already
22:22:47 <jle`> it's on a dinky cloud server, heh
22:23:40 <dmj`> jle`: AWS?
22:24:08 <pacak> > case undefined of ~(_,_) -> "shoes"
22:24:10 <lambdabot>  "shoes"
22:24:10 <jle`> digital ocean
22:24:26 <jle`> well i only bought 500 mb of ram
22:25:03 <arahael> jle`: And you have to do a build within AWS instances?
22:25:14 <jle`> it's digital ocean
22:25:27 * arahael isn't familiar with that.
22:25:35 <jle`> but yeah, same deal heh
22:25:38 <c_wraith> jle`: usually it's ld that uses all the memory
22:25:51 <c_wraith> jle`: you can hack around it by using gold to link memory-intensive packages
22:25:58 <jle`> ah
22:26:02 <jle`> is this documented anywhere?
22:26:15 <pacak> c_wraith: Depends. I have a project where ghc takes 10Gb+ of RAM to compile.
22:26:29 <c_wraith> pacak: I did say "usually". :)
22:26:39 <jle`> isn't ld just a linker
22:26:41 <c_wraith> yes
22:26:43 <jle`> does linking take that much memory
22:26:50 <c_wraith> ld is not optimized for memory use
22:26:55 <jle`> ah
22:26:59 <c_wraith> and ghc produces code with a *lot* of symbols in it
22:27:07 <jle`> that does make sense, heh
22:27:20 <dmj`> jle`: cabal has failed on me w/ micro ec2 instances ~512MB
22:27:22 <dmj`> RAM
22:27:55 <jle`> yeah, i had to temporarily increase the memory limits to even install cabal actually
22:27:56 <jle`> oh well
22:30:36 <pacak> You can always compile stuff on one machine and then just deploy binaries.
22:33:18 <arahael> jle`: Why not build locally, then push the binaries?
22:33:48 <jle`> i guess i could do that if the architectures matched/i set up a vm
22:33:54 <jle`> thanks
22:34:39 <arahael> jle`: Set up a VM.  Trivial these days with docker, etcetera. :)
22:35:00 <jle`> :D
22:36:29 <dmj`> jle`: I'd just use a build server, can deploy it auto based on branch
22:36:43 <jle`> that sounds like fun too
22:37:40 <dmj`> jle`: here's a simple circle file to do it, http://lpaste.net/138925
22:37:45 <dmj`> jle`: it will run tests too
22:37:54 <dmj`> you can override anything, free too
22:38:07 <athan> Is there an easy way to see if two lists have the same elements, but not necessarilly in the same order?
22:38:37 <arahael> athan: Convert to set, and then compare?
22:38:40 <athan> Was gonna fold over the zip of the two, but I want to piggyback on other people's hard labor :(
22:38:44 <arahael> athan: Or sort, and then compare?
22:38:55 <athan> arahael: Well, I don't want the Ord constraint :x
22:39:10 <arahael> athan: There's also the issue of how do you handle duplciates.
22:39:30 <athan> arahael: Well, in this case the elements are supposed to be unique
22:39:38 <athan> I might as well cand code it
22:39:54 <athan> hand*
22:40:10 <Lokathor> how do you hand code it without having an Ord constraint?
22:40:18 <arahael> athan: map the list to something that has an ord constraint, then convert to set?
22:40:47 <athan> Lokathor: With horrible, horrible asymptotics
22:41:18 <Lokathor> without Ord, you'd be looking at... N*M runtime for lists of length N and M, right?
22:41:21 <Lokathor> that does sound bad
22:41:54 <arahael> Lokathor: Shouldn't be N*M, at least, if N!=M, surely the answer is "not equal"?
22:42:01 <athan> at least, I'd probably have to do an `elem` O(n) per step
22:42:04 <athan> at least once
22:42:08 <dmj`> athan: for small lists, sort . nub is fine
22:42:34 <Lokathor> arahael, i don't know what you mean by having a runtime of "not equal"
22:42:59 <dmj`> athan: otherwise I'd use an array to check if they're the same
22:43:02 <arahael> Lokathor: Sorry, I was assuming that lists aren't lazy.
22:43:15 <athan> screw it, I'm just gonna use Set
22:43:39 <Lokathor> well, they have to be finite lists for elem to work, but they could be lazy
22:43:54 <dmj`> athan: that's the right way to do it
22:44:00 <dmj`> Data.Set
22:45:41 <athan> dmj`: Yeah... but (for pedagogical reasons), I'm making an unordered set
22:45:50 <athan> so this would be cheating :\
22:45:59 <Zer000> I, a novice, have hit a problem. I was writing some haskell that parses a generic mapping type into my own data structure. I was going to do this by pattern matching against the constructors of the map - this map is always kept ordered so I thought it was possible. But the order of the keys in the map is not such that my recursive parse function can look at them and build up my data structure - the key i need might be deep in the map. I 
22:45:59 <Zer000> hope that makes sense. here's some code http://lpaste.net/138926
22:46:24 <EvanR> athan: List supports de-duping using the Eq instance
22:46:30 <EvanR> but thats not a Set
22:47:55 <dmj`> athan: if you want to check uniqueness, and that's it, then just create an array out of one of them, then do lookups on all elements in the other O(n) time, no Ord needed
22:49:19 <nshepperd> ooh, athan, xs // ys == ys // xs
22:49:25 <nshepperd> i think that works
22:49:43 <EvanR> > [1, 2, 3] \\ [2]
22:49:44 <lambdabot>  [1,3]
22:50:05 <nshepperd> oh right, \\
22:50:36 <athan> Thanks guys :)
22:51:18 <pacak> Zer000: Can you show some examples of what you have and what you want to get?
22:51:54 <Zer000> pacak, did you visit my link?
22:52:13 <pacak> Zer000: Yep. I see only datastructure you trying to create.
22:52:16 <Zer000> one sec
22:52:37 <dmj`> athan: yea arrays are messy anyways
22:52:55 <pacak> Btw, since conversion can fail - you might want to consider using Maybe or Either monads.
22:53:29 <athan> dmj`: I think the version I have now is O(n^2 * m) :\
22:57:20 <athan> dmj`: Do you think this is O(n^2 * m)? http://lpaste.net/138927
22:57:23 <Zer000> pacak, http://lpaste.net/138928 honestly this is very much work in progress, I started trying to decode Error first as it's easiest. That snippet might not even compile I cut bits and pieces from my module to illustrate my point.
22:57:48 <Zer000> but hopefully you can see what I'm trying to do
22:59:12 <pacak> Zer000: I see..http://hackage.haskell.org/package/bencode-0.6.0.0/docs/Data-BEncode-Parser.html - looks like there is a parser for that  data
22:59:26 <Zer000> there's a typo - I meant to say that my code assumes ("y", "e") is first, not ("e", "y")
23:00:18 <MarcelineVQ> ("e","y","e","y","o")
23:00:37 <Zer000> pacak, looks cool thanks
23:02:17 <dmj`> athan: def O^2
23:02:51 <ttt_fff> anyone familiar with the language 'mercury' ?
23:02:51 <Zer000> I have no idea how to use this :(
23:02:59 <ttt_fff> what are you trying to use?
23:03:08 <Zer000> http://hackage.haskell.org/package/bencode-0.6.0.0/docs/Data-BEncode-Parser.html
23:03:53 <dmj`> athan: I would make a smart constructor, and ensure that when you generate the list it's from unique and sorted elements. This way comparison can just be list based, you can assume the properties of uniqueness and sortedness to be true
23:03:55 <Zer000> I guess I'll read the parsec docs
23:09:24 <lf94> Ok guys, I'm trying to get tests working, but I keep getting this: https://gist.github.com/ef41ea9d9d7ba5dc7716
23:09:38 <lf94> I'm *so* close but there must be something so simple from stopping me.
23:12:07 <fjordrunner> please, acid-state DB,...can I use it for example instead of mysql?
23:13:24 <EvanR> you can but its not the same as mysql
23:14:14 <EvanR> if you want to avoid mysql maybe youd like postgres
23:14:43 <fjordrunner> I would like to store graph/node values,..very simple
23:15:07 <EvanR> what is that type of that data?
23:16:49 <fjordrunner> mostly text, it would be best if it could store also images,..but I could around it with just storing filePath,...so mostly text
23:17:17 <EvanR> sounds like a job for rdbms like postgres
23:17:39 <martinvlk> @pl (\v a b -> Node a (f v) b)
23:17:39 <lambdabot> flip Node . f
23:18:42 <fjordrunner> why not acid-state?
23:20:14 <EvanR> you should try acid state and see ;)
23:20:23 <fjordrunner> :-)
23:21:12 <EvanR> i consider important aspects of a database programmer usability, future proofiness, upgradiness
23:21:28 <EvanR> acid state has high performance going for it
23:21:30 <fjordrunner> but,..in acid-state,..are all the data stored on the disk,..right? not only in memory
23:21:44 <EvanR> its backed up on the disk
23:22:06 <fjordrunner> thank you!!
23:22:18 <EvanR> one or more letters in ACID says so
23:22:39 <EvanR> "D is for Disk"
23:23:06 <EvanR> (and then your disk breaks)
23:24:39 <rcyr> lulz
23:29:17 <arahael> (Or more commonly: "sync" forgets to realise it's purpose in life)
23:30:06 <EvanR> sync --now --no-right-now --really-i-mean-it --no-sync-everything
23:31:03 <arahael> --yes-really-sync-to-oxide
23:31:42 <arahael> --return-when-done-not-when-started
23:33:31 * hackagebot sets 0.0.4 - Various set implementations in Haskell  https://hackage.haskell.org/package/sets-0.0.4 (athanclark)
23:35:50 <athan> --please
23:38:25 <arahael> Even then, it might still not work, if firmware lies.
23:40:33 <EvanR> athan: and in the end, its still not like sets in math
23:44:34 <athan> EvanR: ...yet :D
23:45:50 * EvanR drops athan into a set of all sets
23:47:00 <athan> Well this is unsettling :s
23:47:41 <athan> I feel... set-up
23:47:53 <arahael> athan: Incorrect. You've been set-down.
23:56:46 <jle`> are you upset
23:57:56 <lf94> Preprocessing test suite 'tests' for Hangman-0.1.0.0...
23:57:56 <lf94> <command line>: cannot satisfy -package-id Hangman-0.1.0.0-inplace
23:58:00 <lf94> What is going on here?
23:58:09 <lf94> What does this error *mean*?
23:58:22 <startling> can you paste your .cabal file?
