00:07:37 * hackagebot streaming-bytestring 0.1.0.1 - Lazy bytestring done right  https://hackage.haskell.org/package/streaming-bytestring-0.1.0.1 (MichaelThompson)
00:07:37 * hackagebot streaming 0.1.0.9 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.9 (MichaelThompson)
00:19:27 <srenatus> anyone ever bothered with "mining software repositories" (MSR) or Moose/FAMIX-like stuff in Haskell?
00:20:53 <yellow_apple> there's no one here
00:22:06 <ely-se> TIL mining companies use Haskell
00:22:49 <slack1256> srenatus: that term is new to me, what are those?
00:24:00 <srenatus> slack1256: "The Mining Software Repositories (MSR) field analyzes the rich data available in software repositories to uncover interesting and actionable information about software systems and projects." -- not sure if the word is actually used outside of msrconf.org
00:24:03 <lamefun> Is there a type like "data Cmp = LT | LTEQ | EQ | GT | GTEQ" in standard or a widely used library?
00:24:21 <johnw> GT implies LTEQ
00:24:27 <johnw> sorry, not GT
00:25:05 <johnw> but I'm not sure what you'd want to use that type for
00:25:18 <srenatus> slack1256: and "FAMIX is a family of meta-models for representing models related to various facets of software systems. These meta-models are typically geared towards enabling analysis and they provide a rich API that can be used for querying and navigation." (http://www.themoosebook.org/book/internals/famix, from smalltalk-80-land)
00:26:16 <srenatus> slack1256: rascal-mpl.org is related, too, with a more lightweight approach (it seems) in its M3, metrics meta-model -- a quite nice little language.  buuut ideally, I'd like to see that in haskell ;)
00:27:34 * hackagebot publicsuffix 0.20150827 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20150827 (wereHamster)
00:31:34 <lamefun> johnw, eg. `data Requirement = Compare Cmp Thing | ..`
00:32:35 <lamefun> nevermind
00:35:40 <ttt_fff> does ghci use something like https://hackage.haskell.org/package/base-4.2.0.1/docs/Data-Dynamic.html (for all the locally defined vars) or does it do something else to keep track of the env ?
00:35:48 <slack1256> @src (<=)
00:35:48 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
00:36:10 <slack1256> Mmmm
00:38:37 <ely-se> why case of instead of "compare x y /= GT"?
00:41:11 <slack1256> @pl x <= y
00:41:11 <lambdabot> x <= y
00:41:19 <slack1256> @unpl x <= y
00:41:19 <lambdabot> (x <= y)
00:41:34 <arkeet> what are you trying to do?
00:41:50 <slack1256> N-nothing
00:44:16 <ttt_fff> there's only GT, EQ, LT; so not GT is  shortest
00:52:18 <edwardk> i tend to use compare x y <= EQ  -- when I need something like <= but only have a 'compare'-like function
00:52:30 <edwardk> the nice thing is then the operator matches what i want
00:52:45 <edwardk> compare x y >= EQ, compare x y <= EQ, compare x y == EQ, etc.
00:53:31 <arkeet> that's cute.
00:55:27 <orbifx> Twey: looking at the MultiMap you wrote yesterday. Doesn't something like that exists in the libraries?
00:55:30 <orbifx> (hackage)
00:56:24 <shachaf> You can also use "compare EQ" to flip an Ordering.
00:57:53 <edwardk> shachaf: cute
01:00:21 <xandaros> I already asked yesterday, but maybe I get a more favourable answer this time: Are there any libraries to parse non-byte-aligned binary data? (for GHC >=7.10)
01:02:08 <prohobo> racist!
01:02:32 <xandaros> nvm, I just found binary-bits and it actually compiles! :) So happy now
01:51:24 <xacktm> does anyone recommend the late Hudak's The Haskell School of Expression?  I found it in my uni's library and it looked interesting
01:51:54 <xacktm> from 2000 though
01:52:16 <concept> What is the difference between cofunctor and Contravariant Functor ? And why are they useful (real world example? ) ??
01:52:46 <concept> from what I understand Cofunctor is a misnomer
01:53:05 <xandaros> According to hackage, the cofunctor package is deprecated, so simply don't use it
01:53:33 <xandaros> As for a real world example of why they are useful... does profunctor count? :D
01:54:23 <jle`> xacktm: i have a copy, it's a nice introduction to a "haskell way of thinking"
01:54:35 <jle`> teaches you to think functionally, etc.
01:54:51 <jle`> it's a nice read, but it might be a bit dated as far as examples you can run go
01:55:02 <jle`> i'm not 100% sure though
01:55:22 <xacktm> yea, I was wondering about the examples too - are the modules he uses still available?
01:55:48 <concept> xandaros: Well, I understand it's deprecated and Cofunctor is a misnomer. So why Contravariant Functors are useful ?
01:55:58 <jle`> xacktm: i can't answer at the moment, sorry ;_;
01:56:21 <jle`> concept: this was a nice piece i read on contravariant functors once -- https://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html
01:56:38 <jle`> it's a nice post about the motivation and "idea" behind it
01:56:44 <xacktm> jle`: no worries :)  I think I found one on hackage still https://hackage.haskell.org/package/HGL-3.2.0.5/docs/Graphics-SOE.html 
01:56:58 <xandaros> concept: Just read all of that blog. It's amazing :P
01:57:18 <orbifx> why does Data.Map.fromListWith need to have (a -> a -> a) and now be able to produce a new type for the map value (a -> a -> b) ?
01:57:48 <jle`> concept: it's useful for things you can "pre-map", but in real life, things you can "pre-map" often are things you can "post-map" too, so in practice you run into profunctors more
01:58:11 <jle`> orbifx: what does the type of the returned Map have to be?
01:58:25 <concept> jle`: just to be clear profunctors are functors right ?
01:58:47 <jle`> concept: profunctors are functors on the last argument and contravariant functors on the second-to-last
01:59:04 <orbifx> jle`: I'd like it to be [a], so (a -> a -> [a])
01:59:13 <xandaros> concept https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
01:59:22 <xandaros> You should have a look at contravariant first, though
01:59:34 <jle`> concept: so, things you can both "post-map" (like functors) and "pre-map" (like contravariant functors)
01:59:46 <jle`> orbifx: will the result be Map k a, or Map k [a] ?
01:59:49 <concept> I just stumbled upon the same link
01:59:57 <orbifx> jle`: Map k [a]
02:00:34 <jle`> orbifx: don't you want an ([a] -> [a] -> [a]) then?
02:00:38 <Stratege_> orbifx not that neat a fix but you can first map a -> [a] over your list and then define [a] -> [a] -> [a] instead
02:01:04 <orbifx> Stratege: I see
02:01:24 <jle`> orbifx: if it's (a -> a -> [a]), and the first thing is the thing already in the Map, and the second thing is the thing encountered in the list...
02:01:36 <jle`> shouldn't the first argument be [a] ?
02:01:40 <jle`> because your map has [a]'s
02:02:10 <orbifx> Stratege_: I'll probably do that
02:02:43 <jle`> orbifx: in the (a -> a -> a), the first one is the thing already in the map, and the second one is the thing encountered in the list
02:02:49 <orbifx> jle`: no, my map comes from a list [(a, a)] where a's can be duplicate
02:03:05 <orbifx> jle`: ow i get you now..
02:03:17 <jle`> so if you're building up a Map of [a]'s, then the first argument has to be [a]
02:03:19 <orbifx> i thought it worked more like a zip function
02:03:40 <jle`> ah no, it's more like a fold
02:03:52 <orbifx> ok, so how to I tell my fromList to treat the [(a, a)] as [(a, [a])] ?
02:04:13 <jle`> :t (map . second) (:[])
02:04:14 <lambdabot> [(d, b)] -> [(d, [b])]
02:04:27 <jle`> you'd have to pre-map it, i guess
02:05:02 <orbifx> ok, as an educational question, is that an expensive operation?
02:05:12 <jle`> typically not
02:05:21 <jle`> there isn't an intermediate list normally, and it's fused away
02:05:45 <jle`> well, ideally
02:06:06 <jle`> but usually maps on a list are fused with the generation of the list
02:06:08 <Stratege> chaining maps together is a rather elementary operation in haskell. Same for folds and so on. So GHC tries to optimize that
02:07:12 <orbifx> good stuff :)
02:07:28 <xandaros> It should be pretty efficient just as a consequence of laziness, actually
02:07:32 <xandaros> I had the same question :)
02:07:33 <orbifx> thanks jle`, Stratege 
02:09:43 <xandaros> To go back a bit, contravariant was originally cofunctor. Is there actually such a thing? A contravariant functor is just a functor on the mathematical sense, but does cofunctor actually refer to something else? Otherwise it seems a pretty good name to me...
02:09:53 <xandaros> s/on/in
02:13:08 <jle`> xandaros: fmap gives you (a -> b) -> (f a -> f b), so a cofunctor would give you (a <- b) -> (f a <- f b), which is...exactly fmap
02:13:30 <jle`> rewriting the arrows a more reasonable way, cofmap :: Cofunctor f => (b -> a) -> (f b -> f a)
02:14:13 <xandaros> Ah yes, I think I've seen that before
02:14:46 <vinothkumar> @jle: isnt it f => (a -> b) -> (fb -> fa)
02:14:46 <lambdabot>  Parse failed: TemplateHaskell is not enabled
02:14:54 <vinothkumar> It should reverse arrows?
02:15:03 <jle`> vinothkumar: it reverses both arrows
02:15:18 <jle`> what you posted is contramap for Contravariant functors
02:15:53 <vinothkumar> ok sorry
02:15:57 <jle`> np!
02:17:07 <vinothkumar> sorry again but https://hackage.haskell.org/package/cofunctor-0.1.0.1/docs/Data-Cofunctor.html
02:17:22 <vinothkumar> says cofmap :: (b -> a) -> fa -> fb
02:17:53 <xandaros> cofunctor is the deprecated version of contravariant (hence my question)
02:17:55 <jle`> vinothkumar: note the title --- the package is deprecated
02:17:59 <jle`> because they got it wrong
02:18:11 <slack1256> @Info Contravariant
02:18:11 <lambdabot> Contravariant
02:18:11 <xandaros> cofmap is then the deprecated version of contramap
02:18:12 <vinothkumar> Oh, thats why they renamed the package?
02:18:12 <jle`> *the description, at the top of the page
02:18:23 <jle`> yeah, they realized that they goofed
02:18:24 <vinothkumar> Thanks
02:19:05 <xandaros> I don't think contravariant is a very good name, though. It should at least have "functor" in the name
02:19:39 <jle`> vinothkumar: here is a proper implementation of Cofunctor -- https://hackage.haskell.org/package/acme-cofunctor
02:19:53 <arkeet> the dual notion to "functor" is "functor"
02:20:00 <arkeet> so "cofunctor" doesn't really make a lot of sense to say.
02:20:14 <arkeet> ContravariantFunctor is an awfully long name.
02:20:25 <arkeet> and everything is a functor anyway.
02:20:35 <arkeet> well
02:20:37 <arkeet> "functor"
02:20:44 <arkeet> I dunno.
02:20:54 <xandaros> jle`: YES! That's where I saw that before :D
02:21:02 <arkeet> heh
02:21:17 <mniip> arkeet, not everything
02:21:25 <mniip> only things of kind *->*
02:22:12 <vinothkumar> Ok, now i get it
02:22:16 <xandaros> What if I tell you I have a functor ofkind *->*->*? :P
02:22:47 * hackagebot period 0.1.0.0 - Parse and format date periods, collapse and expand their text representations.  https://hackage.haskell.org/package/period-0.1.0.0 (alkar)
02:23:23 <slack1256> you have then a *gasp* bifunctor
02:23:44 <arkeet> or maybe a profunctor
02:24:18 <slack1256> haskell is its own co-category right?
02:24:42 <slack1256> no wait
02:24:44 <slack1256> mmm
02:24:48 <arkeet> Hask is certianly not self-dual.
02:25:07 <johnw> Hask and Hask^op are dual, but not the same; in the latter, all function arrows are flipped around
02:26:12 <slack1256> yep, I was think of the arrows as "there is a function from to" instead of a terminating function
02:26:41 <slack1256> so if it were self dual, for every a -> Void should exist a Void -> a
02:26:48 <arkeet> not necessarily.
02:27:33 <slack1256> mmm that last thing is also wrong
02:27:41 <arkeet> a category can be equivalent to its dual  by an equivalence that changes objects.
02:28:27 <arkeet> e.g. the category with two objects and one arrow between them
02:29:54 <arkeet> so you have to look at more category-theoretic things to tell that two categories aren't equivalent.
02:30:31 <arkeet> e.g. in Hask, product distributes over coproduct (more or less), but not the other way around. so that's one way to tell.
02:30:43 <slack1256> !!!
02:31:12 <slack1256> When I started I wondered why we couldn't say things like
02:32:08 <slack1256> data World = Continents (America | Europe | Antartica) directly as we could the other way around
02:32:34 <mniip>  :t Continents
02:32:41 <slack1256> so that ought to be possible on a possible co-hask 
02:32:48 * hackagebot aeson-value-parser 0.9.0 - An API for parsing "aeson" JSON tree into Haskell types  https://hackage.haskell.org/package/aeson-value-parser-0.9.0 (NikitaVolkov)
02:34:12 <mniip> slack1256, you're co-ing wrong
02:34:57 <slack1256> i see
02:35:00 <mniip> codata Foo = Con1 Bar & Con2 Baz Qux
02:35:18 <mniip> where Con2 is a coproduct and & is product
02:37:12 <mniip> then, Con1 :: (Foo `Op` Baz, Foo `Op` Quux)
02:37:23 <mniip> because (,) is the adjoint of ->
02:37:45 <mniip> or something
02:37:48 * hackagebot yesod-dsl 0.2.0 - DSL for generating Yesod subsite to manage an RDBMS;  https://hackage.haskell.org/package/yesod-dsl-0.2.0 (TeroLaitinen)
02:37:52 <mniip> my understanding is wonky from here on
02:38:11 <slack1256> I recall adjoins being a relation of Functors and homsets
02:38:18 <slack1256> but I also need to re-study those
02:38:21 <ttt_fff> if I do a forkIO in ghci, how do I later kill that thread?
02:38:39 <johnw> slack1256: F a -> b ≅ a -> G b
02:38:51 <slack1256> save the ThreadId and kill with async exceptions?
02:39:05 <ttt_fff> and if I don't save the ThreadId, I lose?
02:39:15 <ttt_fff> the context is that I'm writing an app in threepenny-gui and testing it in ghci
02:39:21 <johnw> ttt_fff: use the 'async' library, so that you can just 'cancel' what it gives back to you
02:40:37 <slack1256> johnw: F G are endo functors on hask, but on general F : C -> D and G : D -> C right?
02:41:09 <johnw> typically the literature uses F : D -> C and G : C -> D
02:41:18 <johnw> but yeah
02:43:02 <slack1256> I don't reach to that part of the book yet but it seems right the relation of (,) and -> being one of adjoint-ness related to curry and uncurry
02:44:08 <johnw> yes, F = ((,) a) and G = ((->) a) gives you forall x. (a, x) -> b ≅ a -> x -> b, which we can easily prove
02:44:46 <johnw> derp
02:44:51 <mniip> schoenfinkel and unschoenfinkel
02:45:16 <johnw> F = ((,) c), G = ((->) c), then (c, a) -> b ≅ c -> a -> b
02:45:21 <johnw> a -> c -> b
02:46:27 <mniip> flip . schoenfinkel, and unschoenfinkel . flip
02:46:28 <mniip> !
02:46:44 <slack1256> what's schoenfinkel?
02:47:25 <mniip> https://hackage.haskell.org/package/acme-schoenfinkel-0.1.1/docs/src/Control-Category-Schoenfinkel.html#Schoenfinkel
02:48:11 <jle`> finally a library that gets the name right
02:48:29 <slack1256> this is why people laugh at us
02:49:06 <mniip> this is also why we laugh
02:49:10 <mniip> at all
02:52:34 <xandaros> schoen and haesslich. I like it
02:53:40 <slack1256> sound like fine chocolate brands
02:55:18 <anohigisavay> hi. i'm new to arrows
02:56:27 <anohigisavay> i didn't make an Arrow instance type. how do i run the enclosed function?
02:57:08 <anohigisavay> e.g. i have this thing (arr (+3) >>> arr(+4))
02:59:19 * frerich hopes there is a 'class (Category cat) => Schroedinger cat' somewhere.
03:00:38 <lyxia> anohigisavay: Functions are already arrows, you don't need to lift them with arr.
03:01:09 <ely-se> arrows make Talk Like a Pirate Day easy
03:01:14 <lyxia> anohigisavay: What are you trying to do?
03:01:55 <mniip> arr harr diddle dee-dee, being an Arrow is alright to be
03:10:28 <ttt_fff> http://qooxdoo.org/ is gorgeous; are there any bindings to do this (via threepenny or anything else)
03:16:37 <agocorona> ttt_fff: better an universal haskell framework
03:18:33 <ttt_fff> agocorona: what do you mean by "better an universal haskell framework" ?
03:19:39 <Stratege> what would "an universal haskell framework" be? (if it's not just haskell itself)
03:20:26 <ttt_fff> what does this ahve to do with my question?
03:20:30 <ttt_fff> i'm asking about threepenny and a GUI library
03:20:52 <Stratege> you mean my question? Nothing, I'm just curious about what agocorona ment.
03:21:14 <ttt_fff> I mean "<agocorona> ttt_fff: better an universal haskell framework"
03:21:22 <ttt_fff> why did this person talk to me about a universal haskell framework
03:21:41 <srhb> How about waiting for the person to elaborate or not spamming on about it. :P
03:22:52 <agocorona> Stratege:  I would be some framework in which you can combine elements at the highest level of each domain 
03:23:07 <Twey> orbifx: Yes, of course; see ‘multimap’
03:23:15 <ttt_fff> agocorona: what is the meaning of "<agocorona> ttt_fff: better an universal haskell framework" ?
03:23:15 <Stratege> agocorona sounds somewhat like lens.
03:24:21 <agocorona> no. lens can combine GUI widgets to create another more complex? 
03:25:25 <Stratege> shouldn't GUI widgets be monoids anyway and therefor be trivial to compose? But yeah I guess I see your point, sorta.
03:26:03 <agocorona> Stratege:  monoids of monadic or applicative or alternative. the four of them
03:26:23 <orbifx> Twey: seemed a bit abandonded
03:26:25 <agocorona> of -> or
03:26:57 <orbifx> Twey: I just mayde a function to run and using lists as values for now, thanks though
03:27:10 <orbifx> you should maybe submit the code a a library in Hackage
03:28:45 <agocorona> ttt_fff: sorry I don't know but you can use Haste or GHCI's  FFI 
03:33:41 <xandaros> Not sure whether gui widgets are necessarily a monoid, but they should be at least a semigroup
03:35:23 <agocorona> giveMeAnInt  <> giveMeAnInt       that return the sum of the two widgets
03:36:06 <agocorona> giveMeAnInt >>= return . (*) 2    that return the double of what is entered
03:36:17 <agocorona> etc
03:37:50 <xandaros> Not sure what the second has to do with monoid. As for the first: What about mempty? A semigroup is a monoid without mempty
03:38:00 <agocorona> Left <$> giveMeAnInt <|> Right  <$> giveMeAString     that return either an Int or an String
03:38:10 <agocorona> I mean that any combinator makes sense
03:40:15 <xandaros> Well, I was mostly referring to Stratege saying that they should be monoids. If you have a notion of an empty widget, sure... but I can't think of something sensible there tbh
03:41:09 <Stratege> eh, semigroup's still good enough for combination in any case.
03:41:09 <agocorona> yes: an empty widget has no rendering and never validates. 
03:42:43 <agocorona> it would be somethig like:  empty= WidgetMonad $ return Nothing
03:43:29 <agocorona> well is not the mempty of monoid, is the empty of applicative
03:44:07 <agocorona> Monoid a => Monoid Widget a where  mempty= return mempty
03:44:38 <DrGamatos> Hello everybody!
03:44:50 <slack1256> hi
03:45:00 <liste> hello
03:45:15 <xandaros> o/
03:45:29 <DrGamatos> Wow lots of people here i see
03:45:44 <DrGamatos> So i got a little problem..
03:46:00 <DrGamatos> When using simpleHTTP from Network.HTTP i get connect: failed (Connection refused (WSAECONNREFUSED))
03:46:04 <DrGamatos> (On windows)
03:46:22 <DrGamatos> Any ideas what is going Left?
03:46:33 <agocorona> you added withSocketsDo?
03:46:39 <rlewis> žćđ
03:47:07 <Intolerable> can you also lpaste your code?
03:47:13 <agocorona> DrGamatos: ?
03:49:19 <DrGamatos> http://lpaste.net/1935506628027613184
03:49:40 <DrGamatos> I see
03:49:58 <DrGamatos> i need to do the WSA Initialization with the withSocketsDo function
03:50:02 <DrGamatos> let me try it
03:50:05 <agocorona> add:  main = withSocketsDo $do....
03:50:31 <agocorona> and all your pains would vanish in the air
03:51:07 <xandaros> I always leave that out just to screw with windows users :P
03:51:49 <agocorona> ;)
03:52:22 <Intolerable> i don't understand why it's called withSocketsDo and not just withSockets
03:52:31 <Intolerable> looks silly with withSocketsDo $ do
03:53:02 <agocorona> withSocketsFactory would look more professional
03:53:16 <Intolerable> withSocketFactoryBeanInitialized
03:53:17 <DrGamatos> Well that did not solve the problem.
03:56:53 <ReinH> DrGamatos: have you considered using wreq instead?
03:57:36 <DrGamatos> well let me try it
03:59:44 <agocorona> I have the same response
04:00:50 <agocorona> ah ok
04:01:10 <agocorona> that URL redirect to a secure https URL
04:01:27 <agocorona> so simpleHTTP can not manage it
04:02:32 <agocorona> if you put in the browser http://api.github.com/users/PureScript/repos it redirect to the same URL but with https protocol
04:04:51 <agocorona> you need something that handle https streams
04:04:56 <DrGamatos> Well that is interesting
04:05:03 <DrGamatos> with wrec i get:
04:05:04 <DrGamatos> FailedConnectionException2 "api.github.com" 80 False connect: failed (Connection refused (WSAECONNREFUSED))
04:05:28 <agocorona> probably for the same reason
04:05:33 <ReinH> er
04:47:27 <saulzar> class (MonadWriter r (m r), MonadWriter s (m s)) => MapWriter m s r  where  ...     <--- does this exist anywhere already?
04:48:20 <merijn> What's a nice pretty printing library?
04:56:04 <bernalex> merijn: I like pretty-tree. depends on your needs, I guess.
04:57:11 <Rembane> merijn: What do you want to pretty-print?
04:57:15 <merijn> bernalex: Pretty printing my AST (it has a lot of noise)
04:57:22 <merijn> (like locations, etc.)
04:59:00 <Rembane> merijn: Do you want to print all the noise?
05:01:07 <merijn> Rembane: No, I'm debugging my parsers/optimisations :)
05:01:41 <srenatus> which partial-order data type definition is preferrable? altfloat or orders, or did I miss another one or two?
05:02:10 <srenatus> I suppose `if (comparrable a b) then (compare' a b) else undefined` is not a good Ord instance...
05:02:30 <Rembane> merijn: So you first need to clean it, and then prettyprint it? :)
05:02:43 <haskell868> Hi I want to stop the whole program on some action - is this ideal way to do so : `throwTo mainThreadId`
05:03:08 <ely-se> Printing ASTs is difficult because of operator precedence.
05:03:31 <haskell868> Operationally I am in a different thread than that of main
05:03:42 <ely-se> The simplest correct way is to use parentheses all over the place but that's not very readable.
05:04:41 <merijn> haskell868: System.Exit.exit (or whatever the name was?)
05:05:25 <haskell868> merijn: thanks, it it the idiomatic way to that! how will throwTo behave? 
05:05:48 <phadej> srenatus: there is also lattices (though I'm not sure about how good the PartialOrd is, even I'm a maintainer)
05:06:07 <srenatus> phadej: thanks for the pointer
05:06:10 <merijn> haskell868: Depends on whater the main threat is blocking exceptions or not
05:06:41 <phadej> srenatus: it seems to be quite the same as orders
05:07:04 <phadej> srenatus: but you shouldn't try to make Ord from PartialOrd
05:08:00 <phadej> srenatus: there are ways to linearise partial ordering to give some total ordering, but you probably don't want to do it generically
05:08:03 <haskell868> merijn: good point, thanks
05:09:17 <srenatus> phadej: actually, I was refering to mis-using Ord to represent a partial order that explodes at runtime: https://github.com/srenatus/srcloc/commit/0254e6ec79c0f053c84d567d6322d5283e28e985
05:09:40 <srenatus> phadej: surely a bad idea
05:25:26 <mr_max> how to enable full optimizations when I do a "cabal build" in a standard cabal project?
05:26:06 <mr_max> I found "--enable-optimization=2" , but it gives and error when i add it to cabal build command
05:27:32 <int-e> mr_max: it's a configuration flag; it's accepted by 'configure' and 'install', but not by 'build'
05:27:57 <mr_max> ah, so 'cabal configure --enable-optimization=2'
05:28:47 <mr_max> int-e: thanks
05:38:06 * hackagebot signal 0.1.0.0 - Signal handling, multiplatform way  https://hackage.haskell.org/package/signal-0.1.0.0 (PiotrMlodawski)
05:43:06 * hackagebot dejafu 0.1.0.0 - Overloadable primitives for testable, potentially non-deterministic, concurrency.  https://hackage.haskell.org/package/dejafu-0.1.0.0 (barrucadu)
05:43:08 * hackagebot signal 0.1.0.1 - Multiplatform signal support for Haskell  https://hackage.haskell.org/package/signal-0.1.0.1 (PiotrMlodawski)
05:51:24 <nh2> bgamari: would you be up for adding your version of vector-fftw to stackage?
05:54:42 <Zarathostra> hey
05:54:50 <Intolerable> hello
05:55:29 <Zarathostra> how can you create a typeclass like Monad, I mean with "class Name (a :: * -> *)" ?
05:55:41 <Zarathostra> what does these stars mean ?
05:56:11 <Zarathostra> is it a kind of type variable ?
05:57:24 <Zarathostra> i want to create a kind of two parameters Monad
05:57:54 <Zarathostra> not sure we can call that a monad but you get the idea
05:59:07 <aweinstock> (* -> *) is a "kind", which is sort of a "type of types"
05:59:10 <aweinstock> :k Maybe
05:59:11 <lambdabot> * -> *
05:59:18 <ely-se> haha "sort" getit
05:59:19 <aweinstock> :t Just
05:59:20 <lambdabot> a -> Maybe a
05:59:27 <aweinstock> ely-se: pun unintentional
06:00:00 <aweinstock> :k Maybe Int
06:00:01 <lambdabot> *
06:00:04 <aweinstock> :t Just 1
06:00:05 <lambdabot> Num a => Maybe a
06:00:29 <Zarathostra> oh ok, but can you apply constraints on those kinds ?
06:01:13 <Zarathostra> (i'm not a native english speaker, I apologize if I make mistakes)
06:01:58 <aweinstock> in "class Monad m where return :: a -> m a", the fact that "m a" is used causes the kind (* -> *) to be inferred for m (I think)
06:02:06 <ely-se> I apologize iff I make mistakes.
06:02:14 <aweinstock> :t \f x -> f x
06:02:15 <lambdabot> (r1 -> r) -> r1 -> r
06:02:40 <aweinstock> (just like how "f" is inferred to be (r1 -> r))
06:03:43 <YellowOnion> is there an elegant way of handling a combination of relative and absolute hrefs?
06:04:02 <sunnymilk> Either?
06:05:41 <YellowOnion> I was hoping someone had already written a library/function to do this first before attempting to implement it myself.
06:06:01 <Zarathostra> @aweinstock: I think I got it, thanks
06:06:01 <lambdabot> Unknown command, try @list
06:06:09 <Zarathostra> aweinstock: I think I got it, thanks
06:13:10 <spaceloop> haddock question: how do I generate documentation for all top-level symbols in a module (so ignoring the export list)?
06:13:11 * hackagebot moesocks 0.1.0.27 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.27 (JinjingWang)
06:13:43 <codedmart> So I am considering working on a svg parsing library. I do have a need, but more for learning purposes. Suggestions on which libs I should look at using ie: conduit, etc.
06:15:43 <Fuuzetsu> spaceloop: ignore-exports haddock pragma
06:18:11 * hackagebot signal 0.1.0.2 - Multiplatform signal support for Haskell  https://hackage.haskell.org/package/signal-0.1.0.2 (PiotrMlodawski)
06:21:03 <spaceloop> Fuuzetsu: thanks
06:46:22 <bgamari> nh2, sure
06:53:13 * hackagebot streaming 0.1.0.10 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.10 (MichaelThompson)
07:01:57 <blueonyks> hi, i ran into this problem https://ghc.haskell.org/trac/ghc/ticket/10799 regarding hint and network. https://ghc.haskell.org/trac/ghc/ticket/9657 suggests disabling use of -fPIC, can anyone tell me wthether the network package uses this flag as i cant find it in the cabal file?
07:02:32 <nh2> bgamari: that's great, because then I could finally add my hemokit package to it
07:03:08 <adarqui> can you pattern match on a "sum record" like normal? blah (DetailedUser user) = ... ? https://github.com/jwiegley/github/blob/master/Github/Data/Definitions.hs#L640-L678 for example
07:03:13 * hackagebot fixed-vector 0.8.1.0 - Generic vectors with statically known size.  https://hackage.haskell.org/package/fixed-vector-0.8.1.0 (AlexeyKhudyakov)
07:03:32 <adarqui> it's asking me to specify (DetailedUser a b c d ...) for every field in the record
07:04:04 <c_wraith> adarqui: do you want all the fields?
07:04:08 <cocreature> codedmart: one of the parser combinator libraries (parsec/attoparsec/trifecta/…)
07:04:29 <adarqui> ya i want the whole record
07:04:38 <adarqui> i mean pretty much all of the fields
07:04:46 <c_wraith> adarqui: What exactly are you hoping to do by not naming them?
07:04:55 <geekosaur> adarqui, if you are matching that way then you need to list each field. you can otherwise use record syntax to pull particular fields by name, or to match just the constructor try rec@{DetailedUser {})
07:05:30 <geekosaur> to get all the fields with their names, turn on the RecordWildcards extension and use DetailedUser {..}
07:05:38 <adarqui> ah.. ya i tried something similar but that was it.. rec@(DetailedUser {})
07:05:51 <adarqui> c_wraith: i just want to obtain the entire record like that ^
07:05:53 <codedmart> cocreature: OK I will check those out.
07:06:12 <adarqui> thanks c_wraith, geekosaur 
07:13:32 <fractalsea> When I’m “showing” a binary bytestring I get series of characters like \206U\223\EM\239, what representation is this? How can I convert this to the corresponding binary 0s and 1s notation?
07:18:54 <ggVGc> is turtle currently the best haskell library for glue-programs where bash would have been suitable
07:22:32 <Profpatsch> ggVGc: It’s nice if you use it as an outer layer.
07:22:53 <Profpatsch> It’s very hard to escape the Shell monad again in my experience.
07:23:31 <Profpatsch> It’s a good fit if you have line-separated input which you need to transform.
07:25:00 <hodapp> ggVGc: There's also Shelly, but I've never used either.
07:25:13 <hodapp> Profpatsch: hard to escape in what sense?
07:25:20 <geekosaur> fractalsea, it's invoking "show" to give you what amounts to how that string would look when specified as Haskell source
07:25:56 <geekosaur> you can't specify how "show" works; you would need to write your own function to display it the way you want
07:28:00 <fractalsea> But I’m still not sure what for example \223 is in terms of the bits
07:28:16 * hackagebot clippings 0.2.0 - A parser/generator for Kindle-format clipping files (`My Clippings.txt`),  https://hackage.haskell.org/package/clippings-0.2.0 (vi)
07:28:28 <ggVGc> Profpatsch: yeah, so it seems to be what I am looking for. I basically need to write a program that mediates between a few other helper applications
07:28:43 <geekosaur> as specified by the haskell report, the number is *decimal* not octal as used in some other languages
07:29:00 <ggVGc> hodapp: yeah I know about shelly but turtle seems much more useful
07:29:11 <hodapp> ggVGc: good to know
07:29:26 <hodapp> sounds like you know more than I do on both
07:30:01 <fractalsea> hmm
07:30:27 <geekosaur> > map ord "\206U\223\EM\239"
07:30:28 <lambdabot>  [206,85,223,25,239]
07:30:29 <fractalsea> But why do I get some representations using letters then, e.g. “\FS”?
07:30:38 <ggVGc> hodapp: according to this thread, the author of turtle started building it out of annoyance when trying to make shelly "polished for internal use", https://news.ycombinator.com/item?id=8970733
07:30:54 <fractalsea> hmm
07:31:08 <keko_> fractalsea: see this table for what those letters mean: http://www.asciitable.com/
07:31:33 <fractalsea> ahh right
07:31:45 <geekosaur> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-200002.6
07:32:12 <fractalsea> So a  leading slash means it’s either a not a printable charcater, in which case it’s decimal, or one of the control characters
07:32:33 <geekosaur> you may also see \& which is used to disambiguate (e.g. \223 is one character, \22&3 is two characters
07:32:34 <geekosaur> er
07:32:55 <geekosaur> you may also see \& which is used to disambiguate (e.g. \223 is one character, \22\&3 is two characters; or \SOA vs \SO\&A)
07:32:56 <fractalsea> ah right
07:33:17 * hackagebot comfort-graph 0.0.0.2 - Graph structure with type parameters for nodes and edges  https://hackage.haskell.org/package/comfort-graph-0.0.0.2 (HenningThielemann)
07:38:36 <mauke^2> > "\14H"
07:38:38 <lambdabot>  "\SO\&H"
07:47:28 <sgronblo> What does the "| m -> e" part mean in class Monad m => MonadError e m | m -> e where
07:47:31 <iron_houzi> Dear Haskellers. I have some questions about FP in general, in particular, I need to solve multiline parsing/lexing using streams - I am not familiar with monads, I'm using Java 8 and learned from SICP and racket. I still haven't gotten the opportunity to learn haskell and monads yet, but I know people here are very knowledgable and helpful. If nobody wants to answer to the actual question, perhaps someone
07:47:32 <iron_houzi> could divert me to a friendly channel, discussing problem solving in functional languages.
07:48:45 <ansible1> got what I think is a low memory situation during a compile
07:48:49 <iron_houzi> I was wondering what a good way to skip multiline comments in a file stream and was wondering if using a comment_start/comment_end alternating stream would be a good way to go about it.
07:48:54 <ansible1> it exits with rc -4
07:49:25 <ansible1> I'm using "cabal -j1 install <blah>" to limit the simultaneous threads
07:49:47 <zyxoas> Peeps.
07:50:00 <ansible1> i think its failing during the link.  any way to tell it to minimize memory usage?
07:50:17 <aweinstock> ansible1: try adding some swap space?
07:50:26 <ansible1> yeah.
07:50:29 <geekosaur> sgronblo, it's a functional dependency: the type "e" is determined uniquely by the type "m"
07:50:46 <ansible1> I'm on a raspberry pi 2 with a SD card
07:50:56 <ansible1> I may be sol
07:50:57 <Ornedan> iron_houzi: do you want to strip the comments out or do something with them?
07:51:10 <geekosaur> (that is, if the compiler knows "m" then it can assume that "e" will always be the same type for that "m", even if it doesn't yet know what that type is)
07:51:11 <Ornedan> In the first case, just filter the stream
07:51:23 <aweinstock> ansible1: how much free space is on the SD card?
07:51:59 <jeltsch> Ornedan: What do you mean by filtering the stream. The simple filter function won’t do.
07:52:40 <zyxoas> How do I convert this to use type families: class (K B) => J A B | A -> B where; foo :: B -> A; instance J Ai Bi where; foo = bar
07:52:50 <Ornedan> Hm I guess I should go a step back: is this a raw character stream from the file, or already tokenised?
07:53:03 <zyxoas> I'm writing this on a phone, so I apologise for the bad formatting.
07:53:14 <iron_houzi> Ornedan: strip out, yes .. but how can I effectively filter out a range of stream elements, when streams don't carry state about previously seen elements..?
07:53:25 <ansible1> aweinstock: so 789m free it seems
07:53:27 <iron_houzi> Ornedan: Raw
07:53:42 <jeltsch> zyxoas: class K (T a) => J a where type T a; foo :: T a -> a
07:53:45 <ansible1> i mean 978
07:54:12 <zyxoas> Basically, I want to convert MPTC with a function and FD to Type Families.
07:54:12 <jeltsch> zyxoas: instance J Ai where type T Ai = Bi; foo = bar
07:54:32 <iron_houzi> Ornedan: I want to produce the tokens .. I was thinking something like file-stream to LOC-stream to token-stream..
07:54:35 <jeltsch> zyxoas: 
07:54:56 <Ornedan> Ah. You're probably trying to strip the comments out too early
07:55:03 <aweinstock> ansible1: try making a 512MB swap file and compiling?
07:55:06 <jeltsch> zyxoas: In such a simple case, you just drop the dependent parameter b and replace it by T a everywhere it is used.
07:55:17 <zyxoas> Thanks, jeltsch. I shall try that. That is clear enough.
07:55:31 <jeltsch> zyxoas: You’re welcome. :-) 
07:55:37 <iron_houzi> Ornedan: That's a good point I have to take into consideration.
07:55:51 <ansible1> k, maybe that will do it
07:56:01 <aweinstock> ansible1: "dd if=/dev/zero of=/tmp/swapfile bs=1M count=512" "mkswap /tmp/swapfile" "sudo swapon /tmp/swapfile"
07:56:14 <Ornedan> You need to do at least some subset of tokenisation before you can correctly determine what's comment or not
07:56:35 <Ornedan> Eg. consider a comment start marker inside a string literal
07:57:56 <ansible1> aweinstock: ok thx, will try
07:58:10 <Ornedan> This is obviously irrelevant if your language does not have any such potential ambiguities :P
07:58:56 <iron_houzi> Ornedan: This is my first attempt at a compiler/tokenizer .. yeah, that's a good case I haven't tought of and for that reason, I can see that this must be common with any method for solving the lexing, no matter the language paradigm
07:59:30 <MrDetonia> Does anybody know of a good resource for learning about proof by mathematical induction? It's a topic I really struggle with. I know how it works, but struggle to do it myself.
07:59:34 <zyxoas> jeltsch Why is Brent Yorgey using this syntax: type family Plus m n :: *; type instance Plus Z n = n;...
07:59:58 <zyxoas> That syntax is different from the one you gave (and yours matches What's on the Wiki).
08:00:04 <mettekou> Does anyone know an implementation of three address code generation using Happy (or even yacc or Bison)?
08:00:08 <iron_houzi> Ornedan: "this", meaning postpone the determination of comment in the parsing phase, not the lexing phase.
08:00:38 <iron_houzi> *postpone it to the parsing phase
08:00:45 <bergmark> MrDetonia: i struggled with it too, then at some point i went ding-ding-ding
08:01:43 <MrDetonia> bergmark: So I guess keep trying example problems? I had a similar experience with recursion.
08:02:22 <bennofs> MrDetonia: I liked "Software Foundations", which will also teach you about Coq (a theorem prover), but it really made me understand induction much better and proofs in general
08:02:24 <bennofs> @where sf
08:02:24 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
08:02:24 <lambdabot> assistant."
08:03:22 <MrDetonia> bennofs: ty, will check out. I have "Concrete Mathematics", but the entire first chapter was a bit difficult due to my lack of understanding.
08:03:34 <bergmark> my lisp professor talked a lot about induction when we were working through recursion
08:03:36 <frerich> MrDetonia: Do you mean proofs-by-induction for math in general, or for Haskell programs in particular?
08:03:37 <bennofs> MrDetonia: the book is freely downloadable and you can go through it's written in Coq (as comments), so you can "step" through it interactively using the Coq IDE which is really nice (since you can play around with everything and excercises are just inline)
08:03:37 <iron_houzi> Ornedan: Thank you ever so much for your feedback. I am sitting all alone in the forest and having someone to ask and discuss with is highly appreciated!
08:03:54 <MrDetonia> frerich: In general, but I will be applying it to haskell I guess.
08:04:17 <MrDetonia> bennofs: Sounds good. Do you have a link?
08:04:21 <frerich> MrDetonia: The book 'Programming in Haskell' by Hutton has an IMHO very approachable introduction to induction in general and then uses it to prove various properties of different pieces of Haskell code.
08:04:22 <ansible1> aweinstock: swapon: /tmp/swapfile: swapon failed: Invalid argument
08:04:25 <jcreekmore> MrDetonia: Have you tried “How to Prove It: A Structured Approach”? I really liked that one.
08:04:54 <frerich> MrDetonia: The whole book is very nice IMHO, but the chapter about proving properties of your program by induction was particularly enlightening to me.
08:05:01 <jcreekmore> Although, I am working my way through “Software Foundations” now.
08:05:55 <MrDetonia> frerich: I have that book yes. The induction chapter was good, and I do understand it. It's just actually doing it myself I find difficult. As I said, I'll keep trying until it clicks.
08:06:16 <MrDetonia> jcreekmore: Haven't yet, will take a look at that too. Thanks
08:08:20 * hackagebot streaming 0.1.0.11 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.11 (MichaelThompson)
08:08:22 * hackagebot streaming-bytestring 0.1.0.2 - effectful bytestrings, or: lazy bytestring done right  https://hackage.haskell.org/package/streaming-bytestring-0.1.0.2 (MichaelThompson)
08:08:28 <frerich> MrDetonia: The one piece which still confuses me sometimes is that in the inductive step (I.e. when proving something for 'n+1') I can actually make *use* of the induction hypothesis. For some reason I often think that the hypothesis is what I want to prove.
08:08:43 <aweinstock> ansible1: "ls -lh /tmp/swapfile"?
08:09:43 <ansible1> -rw------- 1 root bburdette 400M Aug 27 14:59 /tmp/swapfile 
08:10:01 <ansible1> for some reason it wouldnt allow 512, too big
08:10:30 <aweinstock> what did "mkswap /tmp/swapfile" say?
08:10:36 <MrDetonia> frrer
08:11:17 <aweinstock> ansible1: and what does "file /tmp/swapfile" say?
08:12:18 <frerich> MrDetonia: I knew the technique from maths already, but what I only realized after reading Hutton's book is that it works for any recursively defined structure, i.e. not just integers but also lists or other similiar data structures.
08:14:18 <MrDetonia> frerich: I simply get stuck at how to approach solving the inductive step. Like I said, I was a similar way with the recursion; not understanding how to approach a problem. I think if I can grasp it mathematically, I can apply it to Haskell easily too, rather than focusing on just Haskell use cases.
08:18:21 * hackagebot uri-bytestring 0.1.7 - Haskell URI parsing as ByteStrings  https://hackage.haskell.org/package/uri-bytestring-0.1.7 (MichaelXavier)
08:19:20 <clrnd> regarding software foundations, any one has a version that one can read in a kindle for example?
08:19:33 <ansible1> aweinstock:   tmp /swapfile: Linux/i386 swap file (new style), version 1 (4K pages), size 102399 pages, no label, UUID=a5baa8e1-11ae-4bbc-8c2b-e14ab5df32b3
08:23:15 <aweinstock> ansible1: that looks correct, so "sudo swapon /tmp/swapfile" should work
08:27:44 <ansible1> aweinstock: yep, i tried retracing my steps as root, but no dice.  I had to chmod 0600 /tmp/swapfile because of a permissions error
08:27:54 <ansible1> googling hasn't turned up anything promising yet
08:31:18 <aweinstock> ansible1: I found this: http://raspberrypi.stackexchange.com/questions/70/how-to-set-up-swap-space (it seems like raspbian uses a different swap system than debian)
08:35:57 <ansible1> aweinstock:  I'm using arch though, since arch has ghc 7.8.2.  i'm sure there's a way.  I actually have another arm computer with an SSD that is able to compile this stuff, so I can use that.  I was just hoping to get it working on the raspberry pi 2.
08:36:37 <ansible1> I was reading someplace that ghc can't cross compile template haskell.  anyone know if that's true?
08:37:17 <levi> ansible1: It was definitely true at one point, and may still be true.
08:38:56 <bgamari> nh2, I'll try to take care of this shortly
08:43:38 <tomjaguarpaw> adarqui: It's called `showSqlForPostgres`
08:43:56 <bennofs> ansible1: the problem with TH is that GHC needs to run compiled code. And that compiled code should run on a system similar to the target system, since TH could retrieve system-depend values. So, I think the answer is that GHC can't (although I think there was some work on out-of-process TH, which would run the TH program outside of the GHC process, for example, GHCJS uses this to run TH programs on nodejs)
08:44:27 <tomjaguarpaw> adarqui: The tutorial isn't wrong, it just defines `printSql = putStrLn . showSqlForPostgres`
08:54:31 <adarqui> ya tomjaguarpaw i saw that when i finally got to the bottom of the tutorial
08:54:37 <adarqui> thanks!
08:57:57 <ansible1> bennofs: ah, too bad.  
08:59:10 <KaneTW> does anyone know why my local lambdabot install doesn't respond to :t/@type commands (running stuff with > works fine though)
09:00:38 <hodapp> :t (|)
09:00:40 <lambdabot> parse error on input ‘|’
09:02:37 <fractalsea> geekosaur, thanks for your help earlier. I’ve got the hang of it
09:03:21 <fractalsea> By the way does anyone know if there is a standard library function converting an either to a value in a monad with a call to `fail` if it is a Left value
09:03:36 <KaneTW> hodapp: funnily enough, it just won't give a positive result. errors are returned just fine http://i.imgur.com/X2PoGlK.png
09:04:32 <ansible1> ok I have a question re cabal.config.  I have a project that compiles with a certain cabal.config, but I haven't run a "cabal update" in more than 150 days.  
09:05:02 <ansible1> I checked that project out into another machine and tried to compile it, with a fresh install of everything
09:05:07 <fosterite> @hoogle MonadError m => Either l r -> m r
09:05:09 <lambdabot> Did you mean: MonadError m l => Either l r -> m r
09:05:09 <lambdabot> Data.Either rights :: [Either a b] -> [b]
09:05:09 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
09:05:27 <ansible1> however, some versions of the libraries I was using are apparently no longer available
09:06:19 <ansible1> does this mean I can't count on my cabal.config to be able to download the packages?  or maybe there's another reason?
09:06:56 <ansible1> cabal didn't list the library versions anyway during its dependency checking, so maybe they are available but cabal doesn't show them.
09:07:21 <nh2> bgamari: awesome!
09:08:32 <breadmonster> Hey guys.
09:08:48 <breadmonster> So I can't make head or tail of this.
09:08:48 <breadmonster> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType
09:09:26 <scshunt> are layers actually the knees of bees?
09:10:12 <hodapp> for whatever reason, I am again finding simple things like algebraic data types totally indispensable for when I add a driver for a new piece of hardware in this Haskell build
09:10:28 <Welkin> do bees have knees, for some definition of knee?
09:10:40 <hodapp> and it makes it really easy to enforce things like "Don't ever write to this register"
09:11:00 <Welkin> breadmonster: how about last or init?
09:11:07 <breadmonster> Can someone explain what the binder is?
09:11:34 <breadmonster> And how a constructor is passed as the binder type? 
09:12:41 <geekosaur> breadmonster, that might be more of a question for #ghc. but I note that page points to http://blog.ezyang.com/2013/05/the-ast-typing-problem/ with respect to binders
09:13:14 <geekosaur> (and that links to LtU)
09:15:03 <breadmonster> That's strange.
09:15:57 <Gurkenglas> Is there an f such that f uncons = id and f /= unfoldr?
09:16:15 <breadmonster> :t uncons
09:16:16 <lambdabot> [a] -> Maybe (a, [a])
09:16:25 <breadmonster> Interesting.
09:17:25 <geekosaur> anyway it seems clear to me, a binder specifies the local bindings (from let, parameter binding, case binding, whatever)
09:18:02 <geekosaur> the actual binding takes place elsewhere but the bindings currently in effect are "passed on" so it doesn't have to root around to find them
09:18:31 <KaneTW> :t unfoldr
09:18:32 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
09:18:44 <KaneTW> :t unfoldr uncons
09:18:45 <lambdabot> [a] -> [a]
09:18:56 <KaneTW> Gurkenglas: no, identities are unique
09:19:22 <Gurkenglas> What do you mean? "There is only one function [a] -> [a]"?
09:19:50 <sgronblo> I'm trying to read this wiki page https://wiki.haskell.org/Functional_dependencies on functional dependencies, but I don't really get why the result type of Matrix * Matrix would be ambiguous? Is it ambiguous only after someone actually adds that weird Mult Matrix Matrix (Maybe Char) or is there already something ambiguous about it as it is?
09:19:58 <Gurkenglas> Or f x = g x = id implies f = g?
09:20:10 <KaneTW> that iirc
09:20:15 <KaneTW> there's some condition on it i think
09:20:17 <KaneTW> hold on
09:20:29 <geekosaur> sgronblo, it is ambiguous because it allows for someone to add that weird type
09:20:44 <geekosaur> it cannot prevent that type, so must allow for it, so is ambigiuous
09:20:54 <sgronblo> geekosaur: Oh
09:21:40 <sgronblo> So does a functional dependency prevent that instance from being added?
09:23:08 <sgronblo> As in class Something a b c | a b -> c would prevent two instances with the same a and b but with a different c?
09:23:19 <Welkin> yes
09:23:21 <KaneTW> Gurkenglas: f is surjective <=> for all functions h, k if h . f = k . f, then h = k
09:23:24 <Welkin> as far as I understand
09:23:43 <KaneTW> not sure if uncons is that though
09:24:20 <KaneTW> actually yeah it is
09:24:45 <Welkin> I also read something about type equality being a replacement for functional dependencies
09:24:47 <Gurkenglas> But unfoldr doesn't have the form (h .)
09:25:27 <Welkin> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/equality-constraints.html
09:26:19 <breadmonster> Umm, I just heard this one the ghc channel.
09:26:34 <breadmonster> "for lifting values to types we use a prefix" what on earth is this?
09:26:54 <Gurkenglas> Also yea there is an f such that f uncons = id and f /= unfoldr, namely const id :I
09:28:14 <aweinstock> KaneTW: I have the exact opposite problem with a local lambdabot (responds to "@type", but not ":t" or ">")
09:28:29 * hackagebot uniform-pair 0.1.8 - Uniform pairs with class instances  https://hackage.haskell.org/package/uniform-pair-0.1.8 (ConalElliott)
09:28:49 <KaneTW> Gurkenglas: right, yeah
09:28:52 <KaneTW> :t const id uncons
09:28:53 <lambdabot> a -> a
09:29:02 <KaneTW> not quite the same type though
09:29:08 <KaneTW> :t unfoldr uncons
09:29:09 <lambdabot> [a] -> [a]
09:29:34 <KaneTW> aweinstock: i think there's a problem with parsing ghci output
09:29:36 <KaneTW> for some reason
09:29:59 <KaneTW> > const id uncons "arf"
09:30:01 <lambdabot>  "arf"
09:30:13 <KaneTW> behaves the same but it's more general
09:31:26 <aweinstock> KaneTW: the error I'm getting when I try to use ">" is: mueval-core: NotAllowed "These modules have not been loaded:\nL\n"
09:32:07 <KaneTW> missing --trust for some packages maybe?
09:32:58 <aweinstock> I think it's that the L.hs file used for @let definitions isn't on the path, somehow
09:33:11 <aweinstock> (but lambdabot definitely created ~/.lambdabot/State/L.hs)
09:33:29 <KaneTW> the weird thing is it worked fine for me before
09:34:41 <Welkin> lambdabot is a trojan horse!
09:37:03 <TallerGhostWalt> new haskell-mode in emacs doesn't seem to ask me about project settings 
09:37:12 <TallerGhostWalt> any idea where I set that?
09:38:45 <Welkin> what "project settings"?
09:40:30 <Gurkenglas> KaneTW, const sort :P
09:41:16 <TallerGhostWalt> Welkin: used to be when I did C-c C-l it would ask me for what cabal project settings I want.  Most notably which cabal section to build, i.e. spec test,etc
09:41:38 <Gurkenglas> (no wait ._. that isnt id)
09:42:52 <breadmonster> Can someone give me a hand?
09:43:13 <breadmonster> If any of you have used the nanopass framework in scheme, do you know if that can be implemented in Haskell?
09:43:23 <sgronblo> geekosaur: Is my understanding correct? I'm doing a small experiment which seems to indicate that you hvae to at least add tons of language pragmas to maybe eventually get it to work.
09:50:34 <ansible1> aweinstock: ok had success creating a swapfile at /swapfile with "fallocate -l 512M /swapfile"
09:50:45 <levi> breadmonster: I'm sure you could create something similar in Haskell, but I'm not sure exactly how close the Haskell version would be to the Scheme version.
09:50:50 <ansible1> now compiling, hopefully will work
09:51:06 <breadmonster> levi: Maybe requiring a lot of template haskell?
09:53:30 * hackagebot reactive-banana 0.9.0.0 - Library for functional reactive programming (FRP).  https://hackage.haskell.org/package/reactive-banana-0.9.0.0 (HeinrichApfelmus)
09:53:32 * hackagebot reactive-banana-wx 0.9.0.0 - Examples for the reactive-banana library, using wxHaskell.  https://hackage.haskell.org/package/reactive-banana-wx-0.9.0.0 (HeinrichApfelmus)
09:56:45 <ansible1> bah, ghc returned exitfailure(-4).  I'm assuming that's an out of memory but I don't really know for sure actually
09:58:57 <sgronblo> Also with functional dependencies for a two parameter type class does it matter if you make a -> b or b -> a ?
10:13:24 <S11001001> sgronblo: yep
10:14:18 <S11001001> sgronblo: having both, one, the other, or neither, all have different implications
10:14:32 <S11001001> sgronblo: (yep, both makes sense sometimes)
10:35:39 <catgocat> I have a module that has functions that result in a custom data type, but I am not exporting that data type. Can I pattern match against that type later in other module?
10:36:03 <catgocat> Does that only forbidden me to use the constructors? 
10:36:12 <catgocat> forbid*
10:36:17 <Intolerable> no, you cannot refer to the type whatsoever
10:36:28 <Intolerable> if you don't export anything about it, you can't even use it in type signatures
10:36:34 <bennofs> S11001001: b -> a means:  b "implies" a. So for any given b, there can only be one a. for example, if you have class C a b | b -> a,  instance C Bool Int,  instance C Bool ()  are valid instances, while the two instances "instance C Bool Int; instance C Char Int" conflict, since there is more than one possibility for b ~ Int (a is not fully determined through b)
10:36:40 <catgocat> what about if I do Type () instead of Type (..)
10:36:51 <bennofs> sgronblo: ^^^ oops, the above should have been addressed to you instead
10:36:51 <catgocat> in the module expression
10:37:16 <Intolerable> you can use the type name then
10:37:25 <catgocat> and also its constructors to pattern match against?
10:37:25 <Intolerable> but none of its constructors / fields
10:37:30 <Intolerable> no
10:37:48 <Intolerable> PatternSynonyms *might* help you there
10:37:52 <Intolerable> but i'm not too familar with them
10:38:00 <catgocat> and can I use functions from the module that has those types but doesnt export them
10:38:10 <catgocat> I think I got it 
10:38:12 <catgocat> thanks
10:39:30 <Intolerable> yeah, you can use functions that reference the type
10:39:41 <Intolerable> you just won't be able to specify their types when you import them
10:42:27 <catgocat> quit
10:42:29 <catgocat> exit
10:42:36 <catgocat> close
10:42:41 <catgocat> get out
10:42:49 <catgocat> terminate
10:42:53 <catgocat> stop
10:42:57 <aweinstock> catgocat: what IRC client are you using?
10:43:01 <catgocat> ahaha I'm joking
10:43:04 <catgocat> xDDDDDDDDDDDDDD
10:43:08 <catgocat> got you!!!!!!!!1
10:44:24 <buff3r> haha
10:53:36 * hackagebot HFrequencyQueue 0.1.0.0 - A Queue with a random (weighted) pick function  https://hackage.haskell.org/package/HFrequencyQueue-0.1.0.0 (Bellaz)
10:57:37 <hexagoxel> ah, ghc panic time!
11:02:28 <johnw> adarqui: do you still have that question?
11:03:39 <adarqui> johnw, the one about the records? if so, nah geekosaur sorted me out. func rec@(Record {}) = ..
11:03:42 <adarqui> thnx
11:03:46 <johnw> great
11:04:13 <mettekou> I can't believe there isn't a tutorial on building a symbol table during parsing with Happy.
11:11:31 <Hafydd> No unnecessarily specific tutorial? What is the world coming to?
11:15:45 <mettekou> Hafydd: Because, you know, building a symbol table with the most popular parser generator for a language which is touted for the way it facilitates compiler construction through pattern matching on sum and product types is so specific.
11:16:12 <johnw> mettekou: sounds like an excellent way to contribute :)
11:16:39 <johnw> not everything that could or should be written has been yet, we're mostly volunteers
11:17:23 <monochrom> I would be happy to write this tutorial for a consultant fee.
11:19:10 <bitemyapp> @pl fmap (fmap R . j)
11:19:10 <lambdabot> fmap (fmap R . j)
11:20:11 <shachaf> monochrom: Hmm, you're not in the other channel anymore.
11:20:49 <monochrom> no, it has too much leftist politics
11:21:50 <monochrom> and self-congratulating mocking of politicians. (to be fair, those politicians deserve to be mocked. but doing the mocking in #haskell-blah is masturbation.)
11:23:45 <osa1> I'm wondering if we have a tool to download Hackage index pages as formatted text files(maybe something like a CSV etc.)
11:24:40 <monochrom> so in the midst of teaching a course twice (because U of Toronto has 3 campus, and 2 of them invited me to teach the same course) and a lot of grading, I realized that #haskell-blah is no longer worth my time
11:25:34 <shachaf> But where will I talk to you about non-Haskell topics?
11:31:12 <monochrom> I think I should simply create my own channel ##monochrom .  (it's done.)
11:38:41 * hackagebot amazonka-core 1.2.0 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.2.0 (BrendanHay)
11:38:43 * hackagebot amazonka 1.2.0 - Comprehensive Amazon Web Services SDK  https://hackage.haskell.org/package/amazonka-1.2.0 (BrendanHay)
11:38:45 * hackagebot amazonka-config 1.2.0 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.2.0 (BrendanHay)
11:38:47 * hackagebot amazonka-sns 1.2.0 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.2.0 (BrendanHay)
11:38:49 * hackagebot amazonka-sqs 1.2.0 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.2.0 (BrendanHay)
11:42:30 <ouanixi> Hi guys, Im trying to learn about QuickCheck these days and there are great tutorials online that explain the concept of properties etcbut not much about random value generation. 
11:42:30 <ouanixi> The problem Im facing at the moment is how to generate values for a recursive type. 
11:42:42 <ouanixi> Does anybody know of a good resource I could use to try and figure out how to generate values for a type like this ?
11:42:42 <ouanixi> ASTId = ASTId String  String  Sting  (Maybe [ASTId])
11:43:03 <ouanixi> String*
11:43:51 * hackagebot amazonka-glacier 1.2.0 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.2.0 (BrendanHay)
11:43:53 * hackagebot amazonka-cloudhsm 1.2.0 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.2.0 (BrendanHay)
11:43:55 * hackagebot amazonka-datapipeline 1.2.0 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.2.0 (BrendanHay)
11:43:57 * hackagebot amazonka-iam 1.2.0 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.2.0 (BrendanHay)
11:43:59 * hackagebot amazonka-route53-domains 1.2.0 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.2.0 (BrendanHay)
11:44:22 <aweinstock> @instances Arbitrary
11:44:25 <lambdabot> (Shrink2 a), Blind a, Large a, NonEmptyList a, Small a, Smart a, [a]
11:45:38 <aweinstock> ouanixi: implement the Arbitrary typeclass for ASTId
11:46:28 <ouanixi> aweinstock: Yes that's what I'm finding tricky.
11:47:58 <ouanixi> aweinstock, here's what I've done naively http://pastebin.com/W2Q6NhDQ
11:48:07 <ouanixi> but of course this would run infinitely
11:48:53 <aweinstock> try something like: do { r <- oneof [pure Nothing, Just <$> arbitrary]; ASTId <$> arbitrary <*> arbitrary <*> arbitrary <*> pure r }
11:49:01 * hackagebot amazonka-directconnect 1.2.0 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.2.0 (BrendanHay)
11:49:03 * hackagebot amazonka-devicefarm 1.2.0 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.2.0 (BrendanHay)
11:49:05 * hackagebot amazonka-cognito-sync 1.2.0 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.2.0 (BrendanHay)
11:49:07 * hackagebot amazonka-elb 1.2.0 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.2.0 (BrendanHay)
11:49:09 * hackagebot amazonka-cloudformation 1.2.0 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.2.0 (BrendanHay)
11:50:38 <aweinstock> (where the 3 arbitrary calls in the applicative syntax are for String, and r generates that recursive bit at the end, randomly as nothing or a random recursive structure)
11:51:18 <ouanixi> Hmm I'm gonna have to sit and digest what just happened haha
11:52:01 <aweinstock> @do (f <$> x <*> y)
11:52:01 <lambdabot> (f <$> x <*> y)
11:52:15 <aweinstock> hmm, it looks like lambdabot doesn't do that automatically
11:52:54 <aweinstock> (f <$> x <*> y) = do { x' <- x; y' <- y; f x' y' }
11:53:29 <shachaf> You're missing a join.
11:53:34 <shachaf> Well, I guess you're missing a return.
11:53:47 <aweinstock> (f <$> x <*> y) = do { x' <- x; y' <- y; return (f x' y') }       ?
11:54:11 * hackagebot amazonka-sts 1.2.0 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.2.0 (BrendanHay)
11:54:13 * hackagebot amazonka-kinesis 1.2.0 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.2.0 (BrendanHay)
11:54:15 * hackagebot amazonka-cloudsearch-domains 1.2.0 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.2.0 (BrendanHay)
11:54:17 * hackagebot amazonka-cloudwatch 1.2.0 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.2.0 (BrendanHay)
11:54:19 * hackagebot amazonka-cloudtrail 1.2.0 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.2.0 (BrendanHay)
11:55:10 <aweinstock> ouanixi: should I explain more about Applicative?
11:55:21 <ouanixi> aweinstock, 
11:58:29 <ouanixi> aweinstock, sorry my computer crashed
11:58:40 <ouanixi> the test was stuck in an infinite loop 
11:59:15 <aweinstock> was the arbitrary instance I provided buggy?
11:59:21 * hackagebot amazonka-elasticache 1.2.0 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.2.0 (BrendanHay)
11:59:23 * hackagebot amazonka-importexport 1.2.0 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.2.0 (BrendanHay)
11:59:25 * hackagebot amazonka-s3 1.2.0 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.2.0 (BrendanHay)
11:59:27 * hackagebot amazonka-swf 1.2.0 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.2.0 (BrendanHay)
11:59:27 <ouanixi> aweinstock, I'm guessing so yes
11:59:29 * hackagebot amazonka-sdb 1.2.0 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.2.0 (BrendanHay)
11:59:44 <ouanixi> aweinstock, it was still generating infinite values
12:00:33 <ouanixi> aweinstock, I tested it with the "sample" function and it ran forever
12:00:49 <ouanixi> aweinstock, (I mean just in ghci)
12:01:19 <ouanixi> aweinstock, and when I tested it in my project (cabal test) it just crashed the computer after a minute of execution
12:02:45 <aweinstock> ouanixi: sample (arbitrary :: Gen String) -- seems to generate finite strings, so the problem's probably elsewhere
12:04:31 * hackagebot amazonka-codecommit 1.2.0 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.2.0 (BrendanHay)
12:04:33 * hackagebot amazonka-codedeploy 1.2.0 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.2.0 (BrendanHay)
12:04:35 * hackagebot amazonka-cloudfront 1.2.0 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.2.0 (BrendanHay)
12:04:37 * hackagebot amazonka-efs 1.2.0 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.2.0 (BrendanHay)
12:04:39 * hackagebot amazonka-codepipeline 1.2.0 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.2.0 (BrendanHay)
12:05:20 <ouanixi> aweinstock: sample (arbitrary :: Gen ASTId) generates infinite values
12:06:16 <ouanixi> aweinstock, I'm guessing it's to do with the inner list of [ASTId] 
12:06:30 <ouanixi> aweinstock, it's where the recursion is happening
12:08:13 <lpaste_> aweinstock pasted “Arbitrary instance example” at http://lpaste.net/139737
12:09:41 * hackagebot amazonka-elasticbeanstalk 1.2.0 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.2.0 (BrendanHay)
12:09:43 * hackagebot amazonka-autoscaling 1.2.0 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.2.0 (BrendanHay)
12:09:45 * hackagebot amazonka-ses 1.2.0 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.2.0 (BrendanHay)
12:09:47 * hackagebot amazonka-support 1.2.0 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.2.0 (BrendanHay)
12:09:49 * hackagebot amazonka-dynamodb-streams 1.2.0 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.2.0 (BrendanHay)
12:10:05 <aweinstock> oh, it's (Maybe [Id]) not (Maybe Id), let me try that
12:10:33 <ouanixi> aweinstock, that's right, it would have been ok if it weren't a bloody list haha
12:11:22 <aweinstock> yeah, it produces a really large output for me with that change too
12:11:36 <ouanixi> aweinstock, it's driving me mad haha
12:11:42 <aweinstock> sample (arbitrary :: Gen [Int]) seems to work too though...
12:12:11 <ouanixi> aweinstock, yeah that works fine cause there's no recursion happening
12:12:56 <aweinstock> sample ((resize 2 arbitrary) :: Gen [Int]) -- generates random lists of size at most 2
12:13:28 <ouanixi> well I'm happy with lists of size at most 3 
12:13:37 <ouanixi> that would reflect my real data anyway
12:14:09 <ouanixi> but how would we add that restriction to Maybe [Id]
12:14:41 <aweinstock> ouanixi: it works fine for me with 3-4 (4 generates between 1 line and 1 page per sample, randomly)
12:14:51 * hackagebot amazonka-redshift 1.2.0 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.2.0 (BrendanHay)
12:14:53 * hackagebot amazonka-opsworks 1.2.0 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.2.0 (BrendanHay)
12:14:55 * hackagebot amazonka-emr 1.2.0 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.2.0 (BrendanHay)
12:14:57 * hackagebot amazonka-cognito-identity 1.2.0 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.2.0 (BrendanHay)
12:14:59 * hackagebot amazonka-ssm 1.2.0 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.2.0 (BrendanHay)
12:15:34 <aweinstock> I posted a revised version: http://lpaste.net/139737
12:16:22 <ouanixi> aweinstock, let me give it a try
12:19:37 <ouanixi> aweinstock, that actually seem to be working fine thanks a lot
12:19:51 <bitemyapp> athan: yes, we're using your library. pls do not break :P
12:20:01 * hackagebot amazonka-ml 1.2.0 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.2.0 (BrendanHay)
12:20:03 * hackagebot amazonka-workspaces 1.2.0 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.2.0 (BrendanHay)
12:20:05 * hackagebot amazonka-dynamodb 1.2.0 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.2.0 (BrendanHay)
12:20:07 * hackagebot amazonka-rds 1.2.0 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.2.0 (BrendanHay)
12:20:09 * hackagebot amazonka-ds 1.2.0 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.2.0 (BrendanHay)
12:20:16 <Lacanau> o my a channel people are actually talking in!?
12:23:57 <aweinstock> ouanixi: so it wasn't actually generating an infinite structure earlier, it was just generating an extremely-deep structure with an exponentially low (but nonzero) chance of terminating
12:24:03 <aweinstock> (at each point)
12:24:18 <ouanixi> aweinstock: that is correct
12:24:56 <ouanixi> aweinstock: I knew that's what was happening, I simply had no clue on how to approach the thing
12:25:11 * hackagebot amazonka-cloudwatch-logs 1.2.0 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.2.0 (BrendanHay)
12:25:13 * hackagebot amazonka-route53 1.2.0 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.2.0 (BrendanHay)
12:25:15 * hackagebot amazonka-cloudsearch 1.2.0 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.2.0 (BrendanHay)
12:25:17 * hackagebot amazonka-storagegateway 1.2.0 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.2.0 (BrendanHay)
12:25:19 * hackagebot amazonka-ec2 1.2.0 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.2.0 (BrendanHay)
12:26:03 <ouanixi> aweinstock: You solved the problem for this particular instance, but ideally I would like to learn about the thing myself
12:26:47 <ouanixi> aweinstock: do you know of any decent resource that explains this kind of stuff ?? Not the properties side of QC, I'm more intersted in random value generation at this stage
12:28:06 <aweinstock> ouanixi: there's the Gen monad, which encapsulates "plans to produce a random value", with combinators like oneof (chosing a random value from a list)
12:28:38 <aweinstock> ouanixi: I'm not sure how much more depth there is, aside from reading the implementation
12:29:54 <ouanixi> aweinstock: I'll give it a bash. Thanks a lot for your help. Hopefully I'll be able to solve problems like this without the constraint of limiting the size
12:30:21 * hackagebot amazonka-kms 1.2.0 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.2.0 (BrendanHay)
12:30:23 * hackagebot amazonka-elastictranscoder 1.2.0 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.2.0 (BrendanHay)
12:30:25 * hackagebot amazonka-lambda 1.2.0 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.2.0 (BrendanHay)
12:30:26 <ouanixi> aweinstock: it's ok for this project only unfortunately
12:30:27 * hackagebot amazonka-ecs 1.2.0 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.2.0 (BrendanHay)
12:30:29 * hackagebot comfort-graph 0.0.0.3 - Graph structure with type parameters for nodes and edges  https://hackage.haskell.org/package/comfort-graph-0.0.0.3 (HenningThielemann)
12:31:52 <aweinstock> ouanixi: maybe try making a (Gen a -> Gen [a]) that generates lists with a geometric size distribution? ([] is 50%, [a] 25%, [a, a] 12.5%, etc...)
12:34:31 <ouanixi> aweinstock: Yeah that's an option. Still seems a bit vague on how it could be done but I'm sure it'll feel better once I've read more about Gen etc
12:35:31 * hackagebot feed-translator 0.1.0.0 - Translate syndication feeds  https://hackage.haskell.org/package/feed-translator-0.1.0.0 (hongminhee)
12:37:14 <aweinstock> ouanixi: are you familiar with the Applicative syntax I used, or should I try to explain that in more depth?
12:39:59 <ouanixi> aweinstock: If you don't mind please
12:40:37 <aweinstock> Applicative is a superclass of Monad (every monad is an applicative, but not vice-versa)
12:40:58 <ouanixi> just like every applicative is a functor ?
12:41:00 <aweinstock> pure = return, (<$>) = fmap = liftM
12:41:05 <aweinstock> yes
12:41:16 <ouanixi> ahhh so <$>  is fmap
12:41:20 <ouanixi> ok makes sense
12:41:37 <ouanixi> I don't really like liftM, I'd rather think in terms of fmap as they are the same :)
12:41:47 <byorgey> no one likes liftM =)
12:41:58 <ouanixi> byorgey: haha
12:42:03 <aweinstock> (f <$> x <*> y <*> z) = do { x' <- x; y' <- y; z' <- z; return (f x y z) }
12:42:07 <athan> bitemyapp: Wait wat lib?!? :o
12:42:14 <bitemyapp> athan: composition-extra
12:42:19 <bitemyapp> I need <$.*>
12:42:22 <bitemyapp> needed*
12:43:01 <athan> :O!
12:43:01 <athan> Alright cool, I'll make it better and add more breaking changes
12:43:07 <aweinstock> not every do-block can be expressed as just applicative operations, but when they can be, it's sometimes shorter
12:43:08 <bitemyapp>  :P
12:44:24 <ouanixi> aweinstock: that makes sense
12:45:29 <ouanixi> aweinstock: A lot of this material is new to me, so although I understand what it is, I need to practice it so it sinks in.
12:45:45 <ouanixi> aweinstock: I've only started learning haskell seriously over the last month
12:46:16 <ouanixi> functors were straight forward, then I read about monoids and applicative (which I don't remember them being difficult to get)
12:46:24 <ouanixi> and then I started reading about Monad
12:46:33 <ouanixi> that made me forget what applicative was haha
12:46:33 <aweinstock> I started writing haskell this january (but had read about haskell for a while beforehand, and had previously written ocaml)
12:46:50 <absence> byorgey: it was good for that bronad culture joke though. "do you even liftM?"
12:47:51 <bitemyapp> byorgey: nice seeing you around :)
12:48:39 <ouanixi> aweinstock: that's great, Haskell is my only exposure to functional programming
12:49:42 <ReinH> byorgey: hey are you going to icfp?
12:50:17 <ouanixi> aweinstock, my experience as a new learning has been great so far, but I think I went too quick on the reading. I now need to go back and review some concepts (monoids, functors, applicative etc..)
12:50:36 <ReinH> ouanixi: have you seen the typeclassopedia?
12:53:50 * hackagebot yesod-transloadit 0.4.1.0 - Transloadit support for Yesod  https://hackage.haskell.org/package/yesod-transloadit-0.4.1.0 (boblong)
12:53:52 * hackagebot feed-translator 0.1.0.1 - Translate syndication feeds  https://hackage.haskell.org/package/feed-translator-0.1.0.1 (hongminhee)
12:59:01 <ouanixi> ReinH: Yes but I've not read it yet. Will have a look thanks.
12:59:44 <breadmonster> So for a programming language I'm working on, I'd like to write a virtual machine.
12:59:53 <breadmonster> is there any reference for this, ideally in Haskell?
13:00:52 <lpaste_> aweinstock revised “Arbitrary instance example”: “Arbitrary instance example” at http://lpaste.net/139737
13:01:09 <aweinstock> ouanixi: I think I got geomList working properly
13:02:45 <aweinstock> it produces trees of reasonable size
13:02:53 <aweinstock> (but potentially unbounded)
13:03:07 <cads> hey guys
13:03:25 <Lacanoe> sup
13:03:28 <cads> when did stackage become a thing?
13:03:37 <Lacanoe> stackage?
13:04:05 <cads> http://www.stackage.org/
13:04:05 <the_2nd> is this correct, or is there a nicer way to write "none empty or 1 elemt" http://pastebin.com/hUyxS8ia
13:04:06 <Clint> cads: a while ago
13:04:31 <ReinH> cads: http://www.yesodweb.com/blog/2012/11/stable-vetted-hackage
13:04:32 <Lacanoe> whats stackage?
13:04:34 * cads thinks it's pretty neat
13:05:07 <ReinH> the_2nd: that's correct
13:05:16 <ReinH> (x:[]) is also correct but not nicer
13:05:42 <the_2nd> ReinH, thanks
13:05:51 <cads> Lacanoe: it's ubuntu, but for haskell packages. Releases of the platform don't happen untill every package builds and tests, and distribution is done via binary
13:06:45 <srhb> ReinH: What's the nonempty bit?
13:07:14 <ReinH> Still []
13:07:15 <Lacanoe> Cheers cads :D
13:07:21 <srhb> ReinH: How is that nonempty?
13:07:28 <ReinH> Oh, I can't read today
13:07:41 <srhb> well, I'm in doubt whether that's what the_2nd meant at all.
13:07:43 <srhb> Hence the question.
13:07:58 <ReinH> What the_2nd has doesn't match nonempty (and > 1 element) either
13:08:04 <srhb> Indeed.
13:08:26 <srhb> the_2nd: Did we understand you correctly that you want to match EMPTY list or ONE element list?
13:08:31 <srhb> the_2nd: Not 1 or more elements?
13:08:31 <ansible1> anyone know what it means when a cabal build exits with ExitFailure(-4)??
13:08:38 <ansible1> it happens to me on the link step.
13:08:49 <the_2nd> srhb, both lists have to have more than 1 element
13:08:57 <srhb> the_2nd: Then what you wrote is wrong.
13:08:59 <the_2nd> empty lists if not
13:09:12 <ReinH> the_2nd: That case would be, e.g., (x:y:ys)
13:09:31 <srhb> x:xs is sufficient for one element or more.
13:09:31 <ReinH> [] matches the empty list and [x] the one-element list exactly
13:09:34 <the_2nd> ReinH, thats of course my next case
13:09:40 <ReinH> srhb: "more than 1 element"
13:09:41 <the_2nd> the others are meant to be the error cases
13:09:43 <srhb> Oh, sorry
13:09:51 <srhb> I think the questioner is being vague and :-)
13:09:51 <ReinH> srhb: We both are bad at reading today! D:
13:10:10 <srhb> ReinH: Apparently!
13:10:21 <ReinH> the_2nd: Well, you can just say foo (x:y:ys) = whatever; foo _ = []
13:10:31 <srhb> I also think I'm reading into the_2nd's _meaning_ not their words.
13:10:36 <mettekou> http://lpaste.net/8235806257747853312
13:10:38 <srhb> (ie. I don't think they meant TWO or more)
13:10:41 <the_2nd> srhb, ReinH full thing: http://pastebin.com/rqh5PPMJ
13:10:52 <mettekou> Does anyone know why that lexical analyzer eats brackets as a part of names?
13:11:20 <the_2nd> ReinH, srhb so matching the working case first
13:11:22 <ReinH> intersections (p1:p2:ps) (q1:q2:qs) = ...; intersections _ _ = []
13:11:22 <the_2nd> right
13:11:30 <the_2nd> I could use otherwise aswell, correct?
13:11:48 <absence> why does Traversable have a Foldable constraint?
13:11:49 <ReinH> No, otherwise is not for pattern matching
13:12:04 <srhb> Well, you COULD, but it'd just shadow the otherwise = true binding.
13:12:12 <ReinH> absence: because anything that is traversable is also foldable
13:12:48 <absence> ReinH: but why is a Foldable instance required to write a Traversable instance? how is the Foldable used?
13:13:49 <the_2nd> thanks everyone
13:15:37 <geekosaur> ansible1, ExitFailure values are far from standardized. it *could* be SIGILL (illegal instruction trap) filtered through a shell.
13:15:38 <byorgey> absence: it isn't.
13:15:38 <srhb> the_2nd: If that code captures your meaning, you could simply do intersections (p1:p2:ps) other@(_:_:_) = ...; and then only have one other case intersections _ _ = []
13:15:52 <geekosaur> mettekou, can you provide an example?
13:16:04 <absence> byorgey: hmm.. then what is its purpose?
13:16:07 <byorgey> absence: it's the same kind of constraint as   Applicative m => Monad m.  It just requires that you can't skip things higher up on the abstraction chain
13:16:47 <byorgey> absence: for people *writing* instances it just imposes extra work. For people *using* the instances it is really useful to know that anything Traversable is also Foldable.
13:17:03 <byorgey> or that any Monad can also be used as an Applicative, and so on.
13:17:12 <ouanixi> aweinstock: that's excellent. Will need to review it once I've refreshed my knowledge in applicative
13:17:14 <absence> byorgey: well that's not quite the same, as an ideal version of Monad wouldn't have "return" and instead rely on Applicative's pure
13:17:22 <ouanixi> aweinstock: Thanks a lot for your help tonight.
13:17:26 <byorgey> absence: that's just for historical reasons.
13:18:37 <aweinstock> ouanixi: you're welcome
13:18:46 <byorgey> absence: the bigger point is, whenever you have  "every X is also a Y" then you want   Y => X,  because (1) implementors will always be able to satisfy it (even if it's a bit of extra work) and (2) it guarantees that every X can always be used as a Y for free
13:19:21 <mettekou> geekosaur: the code "int a[2][3];" should yield "[Int, Name "a", LeftBracket, LiteralInt 2, RightBracket, LeftBracket, LiteralInt 3, RightBracket, Semicolon]", instead it yields "[Int, Name "a[2][3]", Semicolon]".
13:21:02 <blueonyx> lol
13:23:53 * hackagebot why3 0.8 - Haskell support for the Why3 input format.  https://hackage.haskell.org/package/why3-0.8 (EricMertens)
13:23:55 * hackagebot annotated-wl-pprint 0.7.0 - The Wadler/Leijen Pretty Printer, with annotation support  https://hackage.haskell.org/package/annotated-wl-pprint-0.7.0 (dchristiansen)
13:24:24 <geekosaur> mettekou, so the alex manual tells me that $digit should just be 0-9 not [0-9]; the brackets are used when there's more than just a single character or single range. which may mean they're being read as digit characters. (this seems unfortunate...)
13:24:37 <absence> byorgey: i can see that it makes for more convenient notation, in that users don't have to type (Foldable f, Traversable f) => ..., but it still seems a bit arbitrary. why isn't the constraint the other way around? i.e. class Traversable t => Foldable t
13:26:16 <glguy> geekosaur: I use "$digit          = [0-9]" in the Alex file I checked. (Still reviewing the chatlog to figure out if that's relevant)
13:26:28 <geekosaur> although they show the other form later in the tutorial, hm. but 
13:26:48 <geekosaur> then I wonder if [$alpha$digit] is legal
13:27:01 <geekosaur> or if it does something unexpected
13:27:49 <byorgey> absence: the other way around doesn't make sense.  That requires every Foldable to also be Traversable.  But there are many Foldable instances which cannot be made Traversable.
13:28:22 <lwm> anyone got any heartwarming stories about findding Haskell jobs?
13:30:06 <tommd> lwm: Sorry, the only FP jobs in the world involve writing Cryptol, not Haskell ;-).
13:30:22 <lwm> hmm ... maybe the question is more #haskell-blah
13:30:30 <mettekou> geekosaur: It seems pretty inconsistent with normal regular expressions...
13:31:02 <lwm> tommd: wut, just checked cryptol.net
13:31:32 <geekosaur> what you're used to is not regular expression syntax, but variable expansion in shell/perl/python. I would not expect something related to Haskell to randomly expand variables that way, tbh
13:33:32 <mettekou> geekosaur: Could be my bias. It seems weird nevertheless. Because I already tried ditching all the variables and violating DRY, which did not help.
13:33:57 <GLM> tommd:What is Cryptol?
13:34:14 <geekosaur> then I don't know, sorry
13:34:21 <absence> byorgey: i see. there are none of those in Data.Foldable, do you know some off the top of your head?
13:37:29 <GLM> tommd:Cryptol looks like fun. Who was using it
13:39:39 <byorgey> absence: yes, Data.Set is a good example
13:40:37 <lpaste_> glguy annotated “No title” with “works like this, at least” at http://lpaste.net/8235806257747853312#a139747
13:40:42 <byorgey> absence: anything which somehow contains data that can be folded together but isn't a Functor, e.g. things like Set which have some internal invariants that would be destroyed by doing a map/traversal
13:40:46 <glguy> mettekou: ^
13:41:21 <lwm> GLM: apparently the US Government
13:41:57 <geekosaur> aha, that does seem to make more sense (and confirms to me it was parsing the [] as part of the name spec)
13:43:35 <aweinstock> @pl \x -> fmap (lookup x) getEnvironment
13:43:35 <lambdabot> flip fmap getEnvironment . lookup
13:44:13 <mettekou> glguy and geekosaur: Yup, works for me as well. I also swapped out the nasty lambdas for the names and literals for their pointfree alternatives. :3
13:44:23 <aweinstock> :t (<$> getEnvironment) . lookup
13:44:23 <mettekou> Thanks guys!
13:44:24 <lambdabot> Not in scope: ‘getEnvironment’
13:44:31 <absence> byorgey: that makes sense, thanks!
13:45:05 <Sindriav_> Is there a way to do compile-time computations?
13:45:16 <tommd> GLM: Well I use Cryptol quite happily ;-)
13:45:37 <GLM> tommd: What/where do you work?
13:46:11 <hodapp> Sindriav_: You can do some computations within the type system... or you can use Template Haskell to just do them in Haskell, at compile time. What are you trying to do?
13:46:31 <tommd> GLM: Galois.
13:46:58 <hodapp> tommd: ah, yes, Pat Hickey told me I should apply there and I've been putting that off.
13:47:01 <GLM> tommd:I figured as much. I've been chatting with someone there. It sounds like an amazing place to be
13:47:19 <hodapp> because of all those irritating life things
13:47:35 <Sindriav_> hodapp: Well, other than asking in general, I'm looking to have a compile-time resolved Map
13:47:52 <Sindriav_> hodapp: Though that might not be desirable / idiomatic in haskell
13:47:55 <hodapp> Sindriav_: What sort of map, and why?
13:48:08 <clahey> Hey all. I'm thinking of making a library of operators for Monadic value work.
13:48:17 <Sindriav_> hodapp: Specifically, I'm working on an emoji library, that converts strings like ":this:" into unicode
13:48:38 <Sindriav_> hodapp: Which lends itself to a `Map String Char`
13:48:42 <catgocat> Can anyone help me or give tips on improving this: lpaste.net/139746
13:49:14 <clahey> Specifically things like (+<-) :: Num a, Monad m => a -> m a -> m a        a +<- b = liftM (+) (return a) b
13:49:25 <clahey> Does such a library already exist?
13:49:45 <johnw> liftM (+) (return a) b = liftM (a +) b
13:49:53 <Sindriav_> clahey: That seems kinda redundant O.o
13:50:10 <clahey> Sindriav_: Tons of things are redundant.
13:50:12 <catgocat> Can anyone help me or give tips on improving this: lpaste.net/139746
13:50:15 <catgocat> dsa
13:50:23 <catgocat> 
13:50:31 <Sindriav_> clahey: Tons of things are also useless. What would the use-case for this be?
13:50:50 <clahey> Sindriav_: Writing procedural code.
13:50:52 <catgocat> sorry my internet connection is bad
13:50:54 <catgocat> http://lpaste.net/139746
13:50:58 <catgocat> any tips ^ ?
13:51:09 <ReinH> catgocat: >>= return . f is just fmap f
13:51:20 <catgocat> lemme see
13:51:44 <kristof> Hi, I'm trying to understand applicatives in the context of languages that do not have any currying.
13:51:58 <kristof> Is there anything I can read that can help me in this pursuit?
13:52:02 <arkeet> :t liftA2
13:52:03 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:52:12 <arkeet> just uncurry this stuff.
13:52:20 <arkeet> ((a,b) -> c) -> (f a,f b) -> f c
13:52:50 <catgocat> ReinH doesn't work here
13:52:51 <clahey> Sindriav_: So no such library exists. :)
13:53:02 <Sindriav_> :t fmap uncurry $ uncurry liftA2
13:53:04 <lambdabot> (a -> b1 -> c, b -> a) -> (b -> b1, b) -> c
13:53:09 <kristof> arkeet: Right, but I still have to compose and sequence the effects manually, correct?
13:53:10 <Sindriav_> wooh
13:53:21 <johnw> dot files are rather handy for debugging register allocations in program graphs: http://dl.dropbox.com/u/137615/IRgraph.png
13:54:04 <arkeet> :t uncurry . liftA2 . curry
13:54:05 <lambdabot> Applicative f => ((a, b) -> c) -> (f a, f b) -> f c
13:54:05 <kristof> arkeet: Actually writing liftA3, liftA4, liftA5 is painful business without <*>
13:54:14 <arkeet> sure
13:54:15 <catgocat> ReinH oh I got what you mean
13:54:17 <Sindriav_> clahey: Tons of libraries don't exist, many of them for good reasons. This sounds like noise, to be honest. Unless it becomes very widespread (which would take time at the least), it's going to introduce pretty obscure syntax IMO.
13:54:24 <clahey> catgocat: What didn't work?
13:54:30 <clahey> Oh, you got it.
13:54:50 <lpaste_> aweinstock pasted “geomList quickcheck generator” at http://lpaste.net/139749
13:54:54 <Sindriav_> clahey: +<- doesn't really anything similar to `←`, does it?
13:55:13 <clahey> I tried +<< but it was really unpleasant.
13:55:20 <clahey> I suppose it really doesn't though.
13:55:23 <hodapp> Sindriav_: well, the singletons library can lift many things into type-level, but I'm not sure if maps are one...
13:55:40 <arkeet> just write (a +) <$> b and be done with it.
13:55:41 <clahey> Well, actually, it kind of does something similar to <- in list comprehension.
13:56:02 <aweinstock> ouanixi: I added a main that does a histogram of the lengths of the produces values, and empirically it seems to be doing the right thing (each list size occuring half as frequently as the next smallest)
13:56:14 <Sindriav_> hodapp: I suppose if I just defined a function for *many* different arguments and mark it inlinable, it would get resolved at compile time, right?
13:56:15 <clahey> arkeet: How do you write ->+<-?
13:56:18 <aweinstock> s/produces/produced/
13:56:19 <arkeet> what's that?
13:56:30 <arkeet> :t liftA2 (+)
13:56:30 <clahey> arkeet: liftM (+)
13:56:32 <lambdabot> (Num c, Applicative f) => f c -> f c -> f c
13:56:39 <clahey> Or, right liftA2.
13:56:40 <catgocat> what can I improve more?
13:56:48 <catgocat> clahey
13:56:49 <arkeet> or something like (+) <$> a <*> b
13:56:50 <clahey> arkeet: But that isn't inlineable.
13:56:54 <arkeet> what?
13:57:07 <Sindriav_> > length "liftA2 (+)" / length "->+<-"
13:57:07 <clahey> I mean you can't use that as an infix operator.
13:57:09 <lambdabot>      No instance for (Fractional Int) arising from a use of ‘/’
13:57:09 <lambdabot>      In the expression: length "liftA2 (+)" / length "->+<-"
13:57:12 <hodapp> Sindriav_: You could use something like a type family to map a type-level symbol, I suppose
13:57:20 <hodapp> Sindriav_: I'm just not sure what the point is
13:57:28 <arkeet> I'm not sure what the point is.
13:57:37 <Sindriav_> > fromIntegral (length "liftA2 (+)") / fromIntegral (length "->+<-")
13:57:39 <lambdabot>  2.0
13:57:47 <clahey> It's not about being shorter. It just looks more readable.
13:58:04 <arkeet> it's more mental effort to remember more things.
13:58:05 <Sindriav_> clahey: To you? Might do. To anyone else? Might not be the case.
13:58:12 <clahey> That's true.
13:58:15 <arkeet> everyone knows what liftA2 and (+) do.
13:58:19 <aweinstock> why isn't (pure 1 `liftA2(+)` pure 2) a thing?
13:58:22 <clahey> Hahaha.
13:58:34 <clahey> Everyone is a large stretch. :)
13:58:50 <kristof> > pure 1 `liftA2(+)` $ pure 2
13:58:52 <lambdabot>  <hint>:1:15: parse error on input ‘(’
13:58:55 <Sindriav_> "Everyone for certain values of everyone."
13:58:55 <aweinstock> (i.e. arbitrary expressions inside infix-ticks)
13:58:58 <arkeet> everyone ought to know.
13:59:43 <clahey> An example I wrote in a program I was using to test this was: ('\n' :<- liftM spaces (use indent ->+ 1) ->++ [input])
13:59:58 <arkeet> what does that do?
13:59:59 <Pokinawa> Hey guys, I am thinking of picking up haskell to learn (xmonad got me into it). Just wondering if a book would be better or if there are web resources around?
14:00:08 <kristof> > let plusA2 = liftA2 +; pure 1 `plusA2` $ pure 200
14:00:09 <lambdabot>  <hint>:1:22: parse error on input ‘;’
14:00:23 <kristof> Oh, that needed to be (+) huh
14:00:26 <Sindriav_> arkeet + 1, I really can't be bothered to read that :D
14:00:37 <kristof> > let plusA2 = liftA2 (+) ; pure 1 `plusA2` $ pure 200
14:00:40 <lambdabot>  <hint>:1:43:
14:00:41 <lambdabot>      parse error on input ‘$’
14:00:41 <lambdabot>      Perhaps you intended to use TemplateHaskell
14:00:42 <joobus> Pokinawa: I've been doing that the last 8 months.  book.realworldhaskell.org is a decent starting place.
14:00:47 <kristof> Not going to try anymore.
14:00:55 <aweinstock> > let plusA2 = liftA2 (+) ; pure 1 `plusA2` pure 200
14:00:58 <lambdabot>  <hint>:1:51:
14:00:58 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:01:02 <Pokinawa> joobus: Thank you!
14:01:04 <aweinstock> > let plusA2 = liftA2 (+) in pure 1 `plusA2` pure 200
14:01:08 <lambdabot>      No instance for (Show (f0 c0))
14:01:08 <lambdabot>        arising from
14:01:08 <Pokinawa> joobus: I'll check it out :)
14:01:11 <arkeet> I was waiting for that.
14:01:14 <aweinstock> > let plusA2 = liftA2 (+) in pure 1 `plusA2` pure 200 :: [Int]
14:01:16 <lambdabot>  [201]
14:01:20 <clahey> It does: fmap ((++ [input]).('\n' :).spaces.(+1)) (use indent)
14:01:22 <Sindriav_> clahey: The point is, that you have to be *really* careful when writing new operators.
14:02:09 <kristof> aweinstock: I think using a let binding is a lot better than just letting everyone willy-nilly return closures in between `
14:02:11 <clahey> Cool. I am happy to listen to any advice on the concept. I will even listen to "don't do it", but I doubt I will listen to that bit.
14:02:22 <clahey> I mean, I doubt I will obey that bit.
14:02:33 <Hijiri> @where learnhaskell
14:02:34 <lambdabot> https://github.com/bitemyapp/learnhaskell
14:02:36 <Hijiri> ^Pokinawa
14:02:39 <arkeet> then I hope I don't have to read your code.
14:02:40 <arkeet> :-)
14:02:52 <clahey> So, is there a more readable way to write the bit I just shared?
14:03:06 <Pokinawa> Hijiri: sweet! cheers.
14:03:26 <aweinstock> kristof: (liftA2 (+) (pure 1) (pure 2)) has more parens than (pure 1 `liftA2 (+)` pure2)
14:03:37 <arkeet> I would honestly just fmap a lambda in that particular case.
14:04:04 <aweinstock> kristof: and parens scare people from lisp, so we should obviously improve backticks so as to welcome newcomes to haskell! ;)
14:04:17 <clahey> fmap (indentValue -> '\n' : spaces indentValue ++ [input]) (use indent)
14:04:20 <clahey> Interesting.
14:04:23 <arkeet> mhm
14:04:32 <aweinstock> s/newcomes/newcomers/
14:04:35 <bitemyapp> I want backticks, but for parenthetical commentary in vocalized conversation.
14:04:39 <clahey> I missed a backslash, but yeah.
14:04:52 <arkeet> I'd probably use a shorter variable name but yes.
14:05:10 <kristof> aweinstock: still: no thank you.
14:05:11 <aweinstock> bitemyapp: could you elaborate?
14:05:16 <clahey> fmap (\i -> '\n' : space (i + 1) ++ [input]) (use indent)
14:05:19 <clahey> Interesting.
14:05:29 <clahey> Probably liftM instead of fmap, but that's neither here nor there.
14:05:52 <Sindriav_> You could even do ` flip fmap (use indent) $ \val ->  '\n' : spaces val ++ pure input `,  but that's kinda stretching it
14:06:01 <quchen> liftM has a single use case left, namely in "fmap = liftM".
14:06:06 <arkeet> about fmap vs liftM, I can only think of one case where one might use liftM.
14:06:07 <arkeet> which is that.
14:06:15 <arkeet> (defining a Functor instance in terms of a Monad instance)
14:06:45 <quchen> Well, 7.10 is still somewhat new, so there's room for compatibility liftMs I guess.
14:07:39 <catgocat> @pl getFilesTree path = getDirectoryContents path >>= mapM dirOrFile . filter (`notElem` [".", ".."])
14:07:39 <lambdabot> getFilesTree = (mapM dirOrFile . filter (`notElem` [".", ".."]) =<<) . getDirectoryContents
14:14:57 <quchen> There is some way to annotate a tree (e.g. an AST with position information) using something related to the finally tagless approach. Does anyone have a reference for that? I only remember vague details. It's somehow possible to combine the tagless approach with Fix to build a generically traversable syntax tree or something along those lines.
14:15:00 <quchen> Ring a bell for anyone?
14:15:13 <quchen> I've got a problem my gut tells me asks for this. :-)
14:16:35 <aweinstock> quchen: http://brianmckenna.org/blog/type_annotation_cofree ?
14:16:38 <bitemyapp> quchen: I don't know about finally tag---dammit.
14:16:42 <bitemyapp> aweinstock: beat me to it.
14:17:12 <aweinstock> I had just read that for the first time today, and still had the tab open :)
14:17:14 <bitemyapp> quchen: if you want straight-up tree representation, then you may just want finally tagless.
14:17:41 <bitemyapp> quchen: another search term "HOAS"
14:18:36 <quchen> aweinstock, bitemyapp: Thanks for the pointers!
14:19:26 <quchen> My use case would be an annotated AST I'd like to perform things like transformations on. This is fairly easy (via patterns) on an unannotated (ordinary ADT) tree, but the tag gets in the way.
14:19:48 <quchen> I can add an annotation to every field, but that's not very maintainable.
14:20:02 <quchen> That train of thought leads to things like finally tagless, so that's where I had that idea from.
14:20:09 <clahey> @help
14:20:09 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:20:19 <quchen> And a colleague keeps mentioning pairing it with Fix f = …
14:21:25 <ReinH> catgocat: The version that works is the one that I meant ;)
14:21:39 <ReinH> quchen: Everything eventually leads to finally tagless ;)
14:21:51 <quchen> ReinH: :-þ
14:22:05 <ReinH> quchen: That's a category theory joke quchen. I spent a lot of time researching it.
14:22:16 <quchen> Oh, then I didn't get the joke.
14:22:19 <ReinH> finally.
14:22:28 <quchen> I didn't get that one either.
14:22:32 <clahey> @djinn Monad m => (a -> b -> m c) -> a -> m b -> m c
14:22:32 <lambdabot> -- f cannot be realized.
14:22:43 <ReinH> Finally tagless is a hand wave hand wave terminal object in the hand wave hand wave category of hand wavey things
14:22:47 <quchen> My journey into category theory had such a tiny return on investment that I'm very hesitant doing it again.
14:22:53 <bitemyapp> ReinH: oddly, Edward made a point of noting that it wasn't really final.
14:22:56 <ReinH> coalgebras probably
14:23:02 <bitemyapp> (few weeks ago)
14:23:02 <ReinH> bitemyapp: welp
14:23:05 <atondwal> so I want to write something like `data Foo = Bar Int | Baz Show`. Obviously that doesn't work.
14:23:20 <bitemyapp> ReinH: I think because you can recover a datatype representation? It was a very brief comment.
14:23:26 <atondwal> I tried using ExistentialQuantification
14:23:31 <ReinH> atondwal: You can attach constraints to data definitions but they won't do what you want
14:23:39 <shachaf> I recommend data Foo = Bar Int | Baz String
14:23:47 <ReinH> +1
14:23:49 <clahey> :t (\f a b -> join (liftA2 f (return a) b))
14:23:51 <lambdabot> Monad m => (a1 -> b -> m a) -> a1 -> m b -> m a
14:23:55 <hexagoxel> :exf "Monad m => (a -> b -> m c) -> a -> m b -> m c"
14:23:56 <exferenceBot> \ f1 y z -> z >>= f1 y
14:24:00 <aweinstock> atondwal: data Foo = Bar Int | forall a. Show a => Baz a -- possibly?
14:24:01 <hexagoxel> clahey: ^
14:24:01 * hackagebot hakyll-sass 0.2.0 - Hakyll SASS compiler over hsass  https://hackage.haskell.org/package/hakyll-sass-0.2.0 (meoblast001)
14:24:06 <ReinH> bitemyapp: dunno
14:24:20 <ReinH> bitemyapp: I'm still going with my joke though ;)
14:24:35 <ansible1> can anyone recommend a dead simple web framework/library/whatever for ARM?  something that doesn't use TH or advanced language features, that could compile on ghc 7.4
14:24:37 <atondwal> aweinstock: doesn't acutally allow me to use the constraint
14:24:47 <ansible1> or on 7.10?  
14:24:52 <osa1> so with -funbox-strict-fields ! in data types implies {-# UNPACK #-}, right?
14:25:07 <atondwal> uh, I should've said `data Foo = Bar Int | Baz Show deriving Show`
14:25:12 <bitemyapp> ReinH: fair
14:25:18 <tulcod> ansible1: dead simple to use or dead simple to understand?
14:25:26 <bitemyapp> ansible1: can't speak to "ARM", but uh, Scotty?
14:25:44 <shachaf> atondwal: You haven't said what you want, only provided some Haskell code with an error.
14:25:47 <johnw> servant looks very nice
14:25:54 <shachaf> I took a guess at what you want, which I probably shouldn't have.
14:26:02 <shachaf> Instead, you should say what you want to accomplish.
14:26:04 <ansible1> I just tried scotty, but the compiler dies with an exit code of -4
14:26:08 <ansible1> same thing with yesod
14:26:14 <Welkin> ansible1: wai?
14:26:18 <ReinH> johnw: iirc it based in a notion of resource pooling that is overly restrictive, but that's only by default
14:26:19 <ansible1> plus they take about 5 hours to compile
14:26:20 <aweinstock> atondwal: replace Baz Show with Baz String, as shachaf recommended (unless there's a specific reason you want to use(Show a) there)
14:26:21 <atondwal> so if I try  data Foo = Bar Int | forall a. Show a => Baz a deriving Show (with EQ) ghc complains that it can't derive Show
14:26:22 <ReinH> otherwise I liked it
14:26:45 <ReinH> johnw: My problem with all of these libraries is they never seem to show non-trivial uses. How do I actually connect to a databse, etc.
14:26:46 <ansible1> and you can't cross compile because TH is broked on cross compile
14:26:58 <bitemyapp> ReinH: I've had the same problem in the past.
14:26:59 <ansible1> and also ghc newer than 7.8.4 is broked on arm
14:27:02 <atondwal> so I have to interface with some code that calls it with some a, and I'm printint out Foo s for debugging purposes
14:27:05 <ReinH> johnw: They're all like "Here's a Data.Map we'll use in place of a database"
14:27:05 <aweinstock> atondwal: try a manual Show instance? (pattern-matching on Baz should bring the Show instance into scope, unless I'm misunderstanding)
14:27:07 <ReinH> no no stop
14:27:08 <bitemyapp> ReinH: having past contract projects in your github can help :)
14:27:19 <ReinH> bitemyapp: :)
14:27:21 <bitemyapp> ReinH: I have a palette of Yesod stuff to draw from.
14:27:24 <bitemyapp> very helpful.
14:27:34 <atondwal> aweinstock: good idea! thanks!
14:27:46 <ReinH> bitemyapp: seems good. Writing a database has been helpful in understanding a lot of things, and now I might have a database too.
14:27:47 <bitemyapp> The only reason I don't recommend Yesod over Scotty necessarily for a new person is that there still aren't enough serious public example apps in Yesod.
14:27:53 <ansible1> Welkin: ah, wai by itself?  maybe so
14:28:04 <ReinH> Depending on whether client lets me open source it.
14:28:11 <bitemyapp> so it's really six of one, half-dozen of another unless you can get access to and work on a more developed project.
14:28:19 <agocorona> ansible1: create your own with some basic socket and HTML here and there
14:28:23 <bitemyapp> even Thoughtbot's app skips 2/3s of what you'd need in a lot of Yesod projects.
14:28:54 <ansible1> agocorona: hmm sounds like a growth opportunity
14:29:03 <ReinH> bitemyapp: This isn't a problem unique to haskell, but perhaps exacerbated by our overall lack of good docs
14:29:18 <agocorona> ansible1: the pieces are there
14:29:38 <bitemyapp> ReinH: docs and just the number of people putting stuff out there, yes.
14:29:58 <bitemyapp> ReinH: rails benefits from there being a massive collection of "$THING_IN_RAILS" projects on Github.
14:30:45 <catgocat> What's an example of a library that only exports one function?
14:31:02 <johnw> catgocat: my register allocator only has one function
14:31:12 <agocorona> ansible1:  https://wiki.haskell.org/Simple_Servers
14:31:48 <Sindriav_> A rudimentary Stack VM in Haskell would probably fit on a business card. Mind = blown
14:31:59 <catgocat> johnw link ?
14:32:05 <johnw> http://hackage.haskell.org/package/linearscan
14:32:40 <johnw> hmm.. looks like Haddocks broke after 0.6
14:33:12 <catgocat> johnw why can't I see the docs
14:35:06 <ansible1> agocorona: ok thx for the link... going to have to think about what I want to invest my time doing
14:35:35 <ansible1> haskell is maybe too sketchy for me on arm for now
14:36:25 <Pamelloes> If I have a type data MyType = MyType { foo :: Int, bar :: String}, can I export MyType the type, and the functions foo and bar but not the constructor MyType?
14:36:52 <Sindriav_> Pamelloes: module Foo (MyType, foo, bar) where … IMO
14:36:54 <ReinH> bitemyapp: and also from a bunch of books ranging in quality from mediocre to quite good
14:37:06 <GLM> Are programs that attempt to be concurrent considered to require Monads?
14:37:20 <ReinH> Pamelloes: yes.
14:37:25 <Sindriav_> GLM: Probably IO?
14:37:25 <Pamelloes> Awesome :)
14:37:42 <geekosaur> define "require Monads:
14:37:45 <GLM> Sindriav_:Is that technically IO?
14:37:49 <bitemyapp> ReinH: right yes
14:38:03 <ReinH> Also define "concurrent" while you're at it.
14:38:08 <Sindriav_> GLM: Well, main is IO ¯\_(ツ)_/¯ forking is IO iirc
14:38:12 <Sindriav_> ReinH geekosaur + 1
14:38:35 <ReinH> threads /= concurrency
14:38:35 <Cale> GLM: IO happens to be a monad, but there's nothing about concurrency which has much to do with the fact that IO is a monad.
14:38:37 <GLM> geekosaur: Maybe not requiring a monad but possibly having side effects. I've see programs that ran code in parallel trivially easily
14:38:59 <agocorona> GLM it does not require to define a new monad
14:39:07 <GLM> Cale:So could I run a program like (1+1) on 20 different threads without knowing it?
14:39:16 <monochrom> GLM: if you use Control.Parallel, you don't need a monad.
14:39:37 <ReinH> Well, trivially your program must run in IO, so it requires a monad. I suspect that isn't the answer you want.
14:39:37 <Cale> GLM: Well, (1+1) evaluates to a deterministic result, so that would just be parallelism, not concurrency
14:39:41 <GLM> monochrom:Is Control.Parallel considered to have side effects
14:39:52 <GLM> Cale:What is the different?
14:39:59 <monochrom> I disagree.
14:40:19 <ReinH> GLM: What's your real question? I don't think it's "does concurrency require IO". I think it's more abot how to reason about concurrency and parallelism?
14:40:35 <arkeet> concurrency does not necessitate multiple threads executing simultaneously.
14:40:48 <GLM> ReinH: Yeah, that's true. Just used to everything that isn't "pure" to have some weird structure to using it
14:40:52 <ReinH> Well, if we want to talk about concurrency, we should define it. I like SimonM's definitions.
14:41:08 <ReinH> GLM: You should read SimonM's freely available book on parallel and concurrent programming in Haskell.
14:41:14 <agocorona> there are monads for parallelism, for example, transient
14:41:16 <GLM> Link>
14:41:17 <arkeet> @where pcph
14:41:17 <lambdabot> http://community.haskell.org/~simonmar/pcph/
14:41:31 <GLM> Much appreciated.
14:41:33 <ReinH> @google parallel and concurrent programmingin haskell
14:41:33 <agocorona> but IO does it fine to a certain level
14:41:35 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
14:41:35 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
14:41:41 <GLM> agocorona:So monads are required?
14:41:45 <ReinH> Oh that is the link to the book. I thought it was to the old paper.
14:41:53 <agocorona> GLM:  not required
14:42:41 <Sindriav_> Would something like this be feasible in haskell? http://lpaste.net/2071067469610483712
14:42:43 <agocorona> IO is required once you want to see something in the screen
14:43:16 <Cale> GLM: Parallelism is about making use of many processors in order to compute the result of your program more quickly. Concurrency is about giving up precise control over the order in which effects occur in an effectful program in such a way that it can make progress on multiple tasks at the same time, even if you're not using multiple processors to do it.
14:43:51 <Cale> GLM: For example, you might have a concurrent web server which is able to respond to multiple clients "at once", even if it was running on a single processor machine, and switching between threads.
14:44:24 <ReinH> Sindriav_: don't see why not
14:45:08 <Sindriav_> ReinH: neato. I'll try to draw something up, this could be really useful for putting together quick CLI tools.
14:45:46 <alpounet> johnw: oh, have you tried servant yet?
14:45:52 <johnw> just read the docs
14:45:56 <Sindriav_> Maybe even use TemplateHaskell eventually to do something like "foo :: FilePath -> Options -> CLI ()" -> "foo FILE [options]"
14:46:13 <agocorona> pure code also can be parallelized, but it is not used very much
14:46:19 <Cale> GLM: There's an analogy to fast food restaurants I don't completely hate: Parallelism is like having multiple people working behind the counter to serve customers more quickly. Concurrency is like having multiple queues for customers to wait in, so that more than one customer can be served at the same time (even if there's just one guy behind the counter running around to make everything).
14:46:43 <Cale> GLM: You can combine the two things, but they're not really the same :)
14:46:57 <GLM> Cale:That makes a bit more sense. I'll be sure to read the book though in my free tiem
14:48:01 <Cale> GLM: There's a primitive called par for very simple parallelism in Haskell. Evaluating  par x y  will cause x to be put in a queue of expressions to be evaluated on some processor (if there's time available before it's needed), before resulting in y
14:49:03 <GLM> Any other books I should read beyond LYAH?
14:49:27 <Cale> GLM: A lot of people recommend http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
14:49:34 <Sindriav_> @where real world haskell
14:49:34 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
14:49:44 <Sindriav_> :D
14:49:50 <agocorona> the simon Marlow bible of concurrent programming
14:50:23 <agocorona> http://chimera.labs.oreilly.com/books/1230000000929
14:50:24 <Cale> lol, xmonad configuration syntax reference
14:50:35 <Cale> Who put that there? :D
14:52:36 <geekosaur> o.O
14:53:17 <arkeet> haha
14:53:26 <bitemyapp> Cale: lmao
14:53:57 <Sindriav_> sensible_chuckle.png
14:54:08 <GLM> Cale:I already went throught that courses' contact but I appreciate it
15:09:07 <Welkin> what is the purpose of overloaded do-syntax in blaze-html?
15:09:13 <Welkin> it seems unnecessary
15:09:25 <bitemyapp> Welkin: no no, you're a Haskell user now
15:09:30 <bitemyapp> Welkin: you can't use words like unnecessary
15:09:32 <Welkin> I just compose or use $
15:09:39 <bitemyapp> Welkin: ITYM: GRATUITOUS
15:10:03 <arkeet> Welkin: it's not even a monad.
15:11:06 <Welkin> yeah
15:11:12 <srhb> Well, it's a Monad. :-)
15:11:13 <Welkin> so why does it have do?
15:11:38 <srhb> Because application nests
15:11:39 <arkeet> just for convenient syntax.
15:12:23 <srhb> Each do block represents one "level" of the tag hierachy.
15:12:52 <arkeet> too bad it's still not a monad.
15:12:55 * srhb nods
15:13:03 <srhb> Didn't lucid do something slightly more sane...
15:13:11 <arkeet> yes, lucid provides a monad.
15:14:08 * hackagebot wxdirect 0.92.0.0 - helper tool for building wxHaskell  https://hackage.haskell.org/package/wxdirect-0.92.0.0 (HenkJanVanTuyl)
15:14:10 * hackagebot wxc 0.92.0.0 - wxHaskell C++ wrapper  https://hackage.haskell.org/package/wxc-0.92.0.0 (HenkJanVanTuyl)
15:14:12 * hackagebot wxcore 0.92.0.0 - wxHaskell core  https://hackage.haskell.org/package/wxcore-0.92.0.0 (HenkJanVanTuyl)
15:14:14 * hackagebot wx 0.92.0.0 - wxHaskell  https://hackage.haskell.org/package/wx-0.92.0.0 (HenkJanVanTuyl)
15:14:40 <srhb> With a minuscule "m"
15:14:47 <agocorona> Welkin because with do you can insert more than one tag inside another one
15:19:13 <agocorona> in blaze-html   the operator >> is equal to <> . but try to codify blaze-html without do
15:19:44 <agocorona> it eliminates many parenthesis
15:21:20 <zipper> Hey anyone in need of a remote intern in January or know where I can get this or how it works?
15:22:46 <jmcarthur> zipper: it must be remote?
15:23:02 <zipper> jmcarthur: Not a must but I am Kenyan.
15:23:20 <zipper> How else can I work?
15:23:22 <jmcarthur> zipper: are visas and such tough for kenyans?
15:23:27 <Welkin> zipper: in Kenya?
15:23:31 <zipper> jmcarthur: hahahaha yes
15:23:36 <zipper> I am willing to move
15:23:41 <zipper> Welkin: Anywhere
15:23:48 <Welkin> wow, I never knew you were in Kenya
15:24:09 <zipper> Welkin: haha you have seen my nick often?
15:24:14 <Welkin> of course
15:24:25 <zipper> Welkin: I didn't know that :)
15:29:10 * hackagebot llvm-pretty 0.4.0.1 - A pretty printing library inspired by the llvm binding.  https://hackage.haskell.org/package/llvm-pretty-0.4.0.1 (TrevorElliott)
15:31:57 <catgocat> Is there a shorthand to this: http://lpaste.net/139753 ?
15:36:20 <Cale> catgocat: I'm not sure what kind of shorthand you would want for that.
15:37:17 <catgocat> instead of repeating the "s" 
15:37:19 <catgocat> in each line
15:37:33 <Cale> Ah, no, but you could perhaps write a function
15:37:39 <monochrom> I know how to eliminate repeating "s". but it will just make you repeat "True".
15:37:58 <catgocat> so, any tips?
15:39:12 * hackagebot foldl-transduce 0.2.0.0 - Transducers for foldl folds.  https://hackage.haskell.org/package/foldl-transduce-0.2.0.0 (DanielDiazCarrete)
15:41:48 <Cale> You could write something like:  cond :: a -> [(a -> Bool, b)] -> b  and use that
15:42:01 <Cale> But I'm not sure it's really helpful
15:42:24 <Cale> You'd eliminate the repeated s, but pay using a bunch of other syntax.
15:43:38 <jeltsch> I would swap the arguments of cond. This is more Haskell-like, and you can get rid of the s entirely by using partial application.
15:44:00 <Cale> jeltsch: sure, that's reasonable
15:45:36 <jeltsch> > let switch branches val = snd $ filter (($ val) . fst) branches
15:45:38 <lambdabot>  <no location info>:
15:45:38 <lambdabot>      not an expression: ‘let switch branches val = snd $ filter (($ val) . fs...
15:46:32 <jeltsch> @ let switch branches val = snd $ filter (($ val) . fst) branches
15:46:48 <jeltsch> @let switch branches val = snd $ filter (($ val) . fst) branches
15:46:50 <lambdabot>  .L.hs:151:29:
15:46:50 <lambdabot>      Couldn't match expected type ‘(a0, b)’
15:46:50 <lambdabot>                  with actual type ‘[(a -> Bool, b1)]’
15:46:56 <jeltsch> Hmm.
15:46:59 * jeltsch thinks
15:47:52 <jeltsch> @let switch branches val = snd $ head $ filter (($ val) . fst) branches
15:47:54 <lambdabot>  Defined.
15:48:16 <jeltsch> @type branches
15:48:17 <lambdabot> Functor f => ([Tree a] -> f [Tree a]) -> Tree a -> f (Tree a)
15:48:22 <jeltsch> Huh!
15:48:30 <jeltsch> Okay.
15:48:33 <jeltsch> @type switch
15:48:34 <lambdabot> [(a -> Bool, b)] -> a -> b
15:48:42 <jeltsch> catgocat: There it is. :-) 
15:50:04 <jeltsch> @let charClass = switch [(isAlpha, "letter"), (isDigit, "digit"), (const True, "other")]
15:50:07 <lambdabot>  Defined.
15:50:14 <jeltsch> > charClass "A"
15:50:15 <lambdabot>      Couldn't match expected type ‘Char’ with actual type ‘[Char]’
15:50:16 <lambdabot>      In the first argument of ‘charClass’, namely ‘"A"’
15:50:16 <lambdabot>      In the expression: charClass "A"
15:50:29 <jeltsch> Hmm.
15:50:38 * jeltsch thinks again.
15:51:02 <jeltsch> @type charClass
15:51:04 <lambdabot> Char -> [Char]
15:51:10 <jeltsch> Okay.
15:51:16 <jeltsch> > charClass 'A'
15:51:17 <lambdabot>  "letter"
15:51:27 * jeltsch is happy.
15:52:00 * jeltsch likes IRC’s /me command.
15:53:41 * catgocat das
15:53:46 * catgocat heloooooooooooooooooo
15:53:58 <catgocat> \/you
15:54:04 <catgocat>  /you ugly
15:55:16 <shachaf> catgocat: Your behavior is not conducive to the desired environment in this channel.
15:56:00 <Gurkenglas> He's obviously being "disregard that"'d.
15:56:46 <catgocat> shacaf: love u too
15:57:14 <jbalint> is there any way to eval a an expression in emacs?
15:59:15 * hackagebot nationstates 0.2.0.1 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.2.0.1 (ChrisWong)
16:00:20 <Gurkenglas> :t ((.) . fmap) snd . find . flip fst
16:00:21 <lambdabot> Foldable t => b -> t (b -> Bool, b1) -> Maybe b1
16:05:36 <neuroserpens> So... I'm wondering what is the best way to find out if there is a function that does what I need. Googling is slow as #### in this crappy internet. Does ghci come with some sort of documentation?
16:06:02 <Hijiri> what kind of documentation do you need?
16:06:06 <Hijiri> also there is hoogle
16:06:15 <neuroserpens> Hijiri: Yea... Like hoogle.
16:06:34 <neuroserpens> Hijiri: A library reference
16:07:02 <Hijiri> well, you can install and run hoogle locally, but I don't think it links anything
16:07:05 <neuroserpens> Hijiri: Browsing the web is sucking a lot in this connection though.
16:07:14 <Gurkenglas> https://wiki.haskell.org/GHC/GHCi#GHCi_on_Acid comes to mind
16:07:16 <Hijiri> also when you install packages you get the haddocks installed locally too
16:07:48 <Hijiri> in <prefix>/share/doc or something like that
16:08:02 <Gurkenglas> You can use some browser plugin that caches entire websites and sic it on hackage
16:21:37 <Gurkenglas> What interesting property relates only unfoldr to uncons? (unfoldr uncons = id, but then (const id) uncons = id also.)
16:24:56 <Gurkenglas> Also iterate to tail, perhaps fmap to id? Although the last may be unrelated
16:27:23 <Gurkenglas> cata to In, ana to Out, remembering that banana paper
16:29:32 <mauris> aren't you essentially asking: "What interesting property relates only f to g? (f g = h, but then (const h) g = h also.)"
16:30:08 <mauris> i mean, the `const` thing you debunked `unfoldr uncons = id` with applies everywhere
16:30:54 <Gurkenglas> Right, and I was asking for a property that isn't just debunked by const
16:31:29 <Gurkenglas> So you can start with something like uncons and use that property to end up at its something-like-unfoldr
16:32:02 <mauris> hum, can you give an example of such a property?
16:32:57 <shachaf> Probably the answer is something like "terminal coalgebra".
16:33:41 <Gurkenglas> Ooh, right, there's a universal property in there, of course
16:37:15 <Gurkenglas> mauris, in hindsight: "a, b and (a, b) are related by there being projections from the third to the others, but then so does (a, b, Bool)" with the missing part being all candidates having a (even unique!) projection onto the one we want.
16:40:29 <mac10688> Anyone know of a good haskell specific podcast? I see there's a haskel cast but it seems a little empty now. Maybe something that is more ML. There's cognicast but that's really centered around clojure and lisp type languages.
16:40:58 <bitemyapp> mac10688: I don't really, but there are youtube tutorials and stuff if you just want A/V content.
16:41:06 <lf94> What is a good graphics library in Haskell that supports rendering fonts?
16:41:13 <mac10688> just something to download and listen in the car
16:41:23 <Gurkenglas> (oops, not iterate to tail but "(map head .) . iterate" to tail)
16:41:27 <bitemyapp> mac10688: http://www.functionalgeekery.com/episode-19-julie-moronuki-and-chris-allen/ this ep of Fn Geekery had my coauthor and I
16:41:32 <mac10688> come to think of it, I first heard your name from functional geekery podcast
16:41:33 <lf94> I guess maybe I should use a GTK3 wrapper
16:41:36 <bitemyapp> mac10688: :)
16:41:53 <lf94> Considering it offers a rich text field component
17:32:09 <YellowOnion> how do I migrate a cabal sandbox to a new ghc version?
17:32:49 <mac10688> anyone know how to turn off -Wall?
17:34:31 <mac10688> I found it's :set -w
17:37:30 <catgocat> Does anyone have experienced gloss?
17:37:41 <catgocat> How good is it to make simple games (TicTacToe, or Snake)
17:39:35 <Ashley_> Hi everyone! I'm trying to learn Haskell in advance of my CS course starting in October, and I'm struggling to use the knowledge I'm gaining. Does anyone know of any good resources that give exercises to do that gradually get harder?
17:40:17 <Ashley_> (I've been doing project euler but it's not too efficient as I'm just spending exponentially more time thinking about the problems rather than writing code)
17:41:03 <ttt_fff> every time I make a tour of haskell-like languages, I come to realize why I use haskell; -- the superior tools
17:41:06 <ttt_fff> and library packages
17:45:46 <mac10688> Ashley_, has anyone answered you yet?
17:45:48 <skore_de> A few of those recent questions: You might want to check out #haskell-beginners
17:46:24 <Ashley_> mac10688: No, but I'll have a look at the channel skore_de recommended :)
17:46:50 <mac10688> Ashley_, I read through Learn You A Haskell, which was an ok start. But halfway through it went over my head
17:47:28 <Ashley_> I've been going through it but I'm finding there's lots of examples but no exercises to cement the knowledge if that makes sense?
17:47:29 <mac10688> Ashley_, #haskell-beginners will recommend you check out this page
17:47:36 <mac10688> https://github.com/bitemyapp/learnhaskell
17:47:45 <mac10688> they all focus on the cis194 course
17:47:51 <mac10688> you'll hear a lot about that
17:48:29 <Ashley_> Thanks! :D
17:48:45 <mac10688> bitemyapp, is actually working on a book that is in preview. I'm going through the chapters. They have lots of exercises that don't blow your mind and just cement the basic ideas.
18:09:29 * hackagebot glambda 1.0.1 - A simply typed lambda calculus interpreter, written with GADTs  https://hackage.haskell.org/package/glambda-1.0.1 (RichardEisenberg)
18:09:31 * hackagebot iproute 1.6.0 - IP Routing Table  https://hackage.haskell.org/package/iproute-1.6.0 (KazuYamamoto)
18:21:26 <neuroserpens> Can anyone think of a more efficient way of getting a list of digits from an integer without using quotRem (dividing by ten and getting the remainder) or is it the most efficient way?
18:21:43 <arkeet> that probably is.
18:21:50 <neuroserpens> arkeet: I thought so. Just curious.
18:25:25 <Kaidelong> has anyone figured out if it is possible to make Stack play nice with IntelliJ?
18:25:58 <indiagreen> neuroserpens: divide by 1000 and use a lookup table
18:26:28 <fiatjaf> any clue on how should I proceed to uninstall ghc installed from source on a ubuntu?
18:26:43 <indiagreen> neuroserpens: not sure whether it would actually end up being faster unless you're careful
18:26:47 <fiatjaf> I need another version.
18:26:49 <neuroserpens> indiagreen: lol
18:26:51 <arkeet> just delete it
18:26:59 <indiagreen> neuroserpens: but it did help me in one SPOJ task
18:27:45 <neuroserpens> indiagreen: That looks like too much work for a very small gain in speed.
18:28:14 <indiagreen> neuroserpens: well, who knows, maybe you need that speed badly
18:28:40 <indiagreen> neuroserpens: also, if you're converting long Integers, it won't be “very small” at all
18:28:47 <fiatjaf> arkeet: delete it from where?
18:28:56 <arkeet> wherever you installed it.
18:28:56 <fiatjaf> it is spreaded over a lot of directories
18:29:49 <fiatjaf> many binaries
18:29:54 <fiatjaf> many documentation
18:32:34 <neuroserpens> indiagreen: I see. Good to know anyway.
18:32:42 <neuroserpens> indiagreen: Interesting approach.
18:34:04 <neuroserpens> Now... Is there anything in haskell to apply a function to every other digit of a list? I'm thinking of mutually recursive functions... One applies the function and the other is there just to skip a digit. Not too pretty in my opinion.
18:34:33 * hackagebot jsonsql 0.1.2.0 - Interpolate JSON object values into SQL strings  https://hackage.haskell.org/package/jsonsql-0.1.2.0 (DanielChoi)
18:35:16 <indiagreen> neuroserpens: it could be made prettier with something like “every2nd f (x:y:s) = f y : every2nd s
18:35:27 <neuroserpens> indiagreen: oh god... the x : y thing
18:35:28 <indiagreen> you get a 2-liner
18:35:38 <indiagreen> well, even _:y:s in this case
18:35:39 <neuroserpens> indiagreen: I'm still such a noob in this language.
18:35:45 <neuroserpens> indiagreen: thanks a lot
18:35:56 <neuroserpens> I have no idea why I didn't think of that
18:36:23 <indiagreen> there's another interesting solution
18:37:27 <indiagreen> hm, darn, I thought I had it posted somewhere, but apparently no
18:37:28 <indiagreen> anyway
18:37:52 <indiagreen> > zipWith ($) [a,b,c,d] (cycle [id, f])
18:37:53 <lambdabot>      Couldn't match expected type ‘(a0 -> a0) -> c’
18:37:54 <lambdabot>                  with actual type ‘Expr’
18:37:54 <lambdabot>      In the expression: a
18:37:59 <indiagreen> ouch
18:38:07 <indiagreen> > zipWith ($) (cycle [id, f]) [a,b,c,d]
18:38:09 <lambdabot>  [a,f b,c,f d]
18:38:35 <indiagreen> ...except that neuroserpens left already
18:39:15 <indiagreen> aha, but I was right about having it posted somewhere
18:39:17 <indiagreen> https://www.reddit.com/r/haskelltil/comments/2tpqip/apply_a_function_to_every_2nd3rdetc_element_of/
18:47:48 <Kaidelong> when using stack, do I need to set up my PATH?
19:00:25 <jaconwil> there are 18650 with nominal voltage 3.2V called LiFePO4, and 18650 with nominal voltage 3.7V called ...?
19:01:04 <benzrf> jaconwil: what
19:01:32 <jaconwil> wrong channel :)
19:11:42 <Kaidelong> alright so
19:11:53 <Kaidelong> I don't know how to do basic things with stack, apparently
19:12:12 <Kaidelong> goal: get ghc-mod and ghc in the system path
19:12:22 <Kaidelong> how to do using stack: ???
19:13:03 <Kaidelong> documentation is not helping much
19:13:58 <Kaidelong> alternatively, I could try to set up things in the path that invoke stack if things like ghc or ghc-mod are called for in the IDE and set up the local binds correctly but I wouldn't know how to even start with that
19:22:03 <AshyIsMe> Kaidelong: i have just added ~/.local/bin to my PATH
19:22:14 <AshyIsMe> that's where stack puts binaries
19:22:47 <AshyIsMe> #haskell stack binaries path
19:22:48 <AshyIsMe> export PATH=~/.local/bin:$PATH
19:22:57 <AshyIsMe> that's at the bottom of my .bashrc
19:22:57 <geekosaur> beware with that
19:23:23 <geekosaur> shells are ... inconsistent about expansion of ~, and if it;s not expanded in the actual PATH setting then it will only work for things run actually in a shell
19:23:40 <geekosaur> (and in particular not when run from non-shell programs unless they use system() or equivalent)
19:23:48 <Clint> iow, bash is broken
19:24:02 <AshyIsMe> ah hmm, i should fix that then
19:24:05 <geekosaur> if it doesn;t exapnd it, yes
19:24:15 <geekosaur> some versions are broken, some aren;t
19:24:22 <AshyIsMe> although, echo $PATH shows them all expanded
19:24:47 <AshyIsMe> im probably getting away with it because i updated bash after shellshock
19:24:58 <Clint> $HOME is generally safer
19:24:59 <nshepperd_> use PATH=$HOME/.local/bin:$PATH to make sure
19:25:16 <nshepperd_> i know that expands it at the definition time
19:25:19 <Kaidelong> AshyIsMe: know what .local/bin would be on windows?
19:25:30 <Kaidelong> AppData\Roaming something or another probably
19:25:36 <AshyIsMe> Kaidelong: no idea sorry
19:25:38 <Kaidelong> I'll look there so long and see if I can figure it out
19:26:03 <geekosaur> well, it works for now. whether it will continue to work... bash devs do have a tendency to let old bugs creep back in
19:26:05 <slack1256> what is the current status of backpack? I haven't seen blogpost on a time
19:26:35 <geekosaur> there's at least one bug that has been making random appearances from bash2 on
19:26:43 <geekosaur> regression testing doesn't seem to be a thing for them
19:27:06 <Clint> i'm amazed that it got fixed at all
19:27:08 <Kaidelong> hah
19:27:14 <Kaidelong> AppData\Roaming\local\bin
19:27:29 <Kaidelong> that is a bit surprising, it should really be in a stack-specific directory
19:27:50 <geekosaur> mm, there was mention of it in the ghc 7.12 planning email recently but with no details
19:30:12 <AshyIsMe> i have no idea how people choose windosw as a main dev os for anything other than .net
19:30:25 <AshyIsMe> unless the workplace mandates it i suppose
19:31:52 <osa1> does anyone know why in GHC.Generics Rep type has a seemingly unused type argument? in this associated type family: type family Rep a :: * -> *
19:32:09 <osa1> from :: a -> Rep a x, to :: Rep a x -> a
19:34:02 <Hijiri> what do you mean by unused?
19:34:43 <osa1> Hijiri: I mean I don't see how are they used, and if they're not used I wonder why they're there
19:34:53 <Hijiri> the x?
19:34:57 <osa1> yeah
19:35:40 <osa1> what would be impossible if I changed the type to `type family Rep a :: *` ?
19:36:05 <Hijiri> what if I wanted
19:36:34 <Hijiri> data Foo a x = Vanilla a | Bar a x
19:37:10 <Hijiri> wait no
19:37:23 <Hijiri> data Foo x = Vanilla | Bar x
19:37:41 <Hijiri> type instance Rep () = Foo
19:37:59 <Hijiri> from = const Vanilla
19:38:22 <Hijiri> to = const ()
19:38:36 <Hijiri> and then I could have other functions that utilize the Bar constructor
19:39:01 <Hijiri> I haven't done Generics so I don't know what Rep in particular would be used for though
19:39:41 * hackagebot opaleye-classy 0.1.0.0 - Opaleye wrapped up in classy MTL attire.  https://hackage.haskell.org/package/opaleye-classy-0.1.0.0 (BenKolera)
19:40:01 <osa1> would that work? I thinnk you need something like `type instance Rep Foo = ...`
19:40:11 <Hijiri> what's wrong with mine
19:40:24 <osa1> Hijiri: instance head and type argument should match
19:40:50 <Hijiri> the argument to Rep is * isn't it?
19:40:56 <Hijiri> or polymorphic maybe
19:41:10 <osa1> class Generic a where
19:41:12 <osa1>   type family Rep a :: * -> *
19:41:14 <Hijiri> oh
19:41:18 <Hijiri> I didn't know the context
19:41:25 <Hijiri> what kind is a
19:41:35 <Hijiri> though
19:41:43 <Hijiri> any kind?
19:41:58 <Hijiri> actually I'll just look in the doc
19:42:49 <jaconwil> is x in `let x = y + 5' a function pointer under the hood? pointing to that computation?
19:42:56 <Hijiri> yeah, I don't see why you couldn't define an instance fo ()
19:42:59 <Hijiri> for*
19:43:08 <Hijiri> and there is one defined, but presumably it's not the implementation I gave
19:43:17 <osa1> jaconwil: it's a thunk, not a function pointer
19:44:20 <jaconwil> isn't thunk just a high level term? I want to know what goes on under the hood
19:44:42 * hackagebot opaleye-classy 0.1.0.1 - Opaleye wrapped up in classy MTL attire.  https://hackage.haskell.org/package/opaleye-classy-0.1.0.1 (BenKolera)
19:45:55 <osa1> jaconwil: thunk is just a piece of code when you run evaluates an expression to WHNF(weak head normal form).
19:46:01 <geekosaur> thunk is the low level stuff
19:46:36 <osa1> jaconwil: you need to supply a value to a function to run it, but even then it may not immediately evaluated(depending on the context) because of lazy evaluation
19:46:47 <jaconwil> well thunk doesn't mean anything to me
19:46:51 <jaconwil> (outside of haskell)
19:47:10 <jaconwil> how is thunk implemented
19:47:42 <Hijiri> code pointer to some code that will replace the thunk with the results
19:47:47 <osa1> jaconwil: like I said, it's a piece of code that evalutes an expression to WHNF.
19:47:54 <Hijiri> plus the environment needed by the thunk
19:48:15 <geekosaur> @where stg
19:48:15 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
19:48:29 <geekosaur> ^ if you really want to know the low level story...
19:48:37 <jaconwil> osa1 those are high-level terms. there is nothing like WHNF in C or assembly
19:49:03 <osa1> jaconwil: yeah you need to do some reading for WHNF :)
19:49:19 <geekosaur> so you want os low level that it can;t be associated with the high level things at all?
19:49:26 <anohigisavay> hi
19:49:54 <anohigisavay> i'm calculating CPU usage. i use a Timer to periodically read data from /proc/stat
19:50:07 <geekosaur> I mean, generally you want to know how some higher level thing is implemented, in which case you kinda need to mention the high level thing that is being implemented
19:50:15 <felixn> http://winterkoninkje.dreamwidth.org/100478.html <-- so I feel really dumb, I wrote a buggy unification algorithm, so I'm trying to use this library.  except I can't get anything to work in the REPL, and the author's article doesn't compile anymore >_<
19:50:17 <jaconwil> C-level will do. I imagined x to be a function pointer that points to function that will computer y + 5. and, once that is computed, it is replaced with a function that just returns the value. is that somewhat correct?
19:50:39 <anohigisavay> and to get the result i need the diff of two stats
19:50:41 <Hijiri> that's the general idea
19:50:43 <geekosaur> "somewhat"
19:50:57 <geekosaur> WHNF comes into it when  you want to know what actually drives evaluation
19:51:00 <anohigisavay> how should i design my code
19:51:05 <felixn> I think I just need moral support more than anything >_<
19:51:09 <jaconwil> what if we access x from two threads? 
19:51:15 <anohigisavay> where should i store the previous stat?
19:52:03 <geekosaur> earlier versions locked to avoid two threads evaluating the same thing; this proved more expensive than just using a thing that lets multiple threads safely both evaluate and replace the thunk, so that's how it works now
19:52:43 <shachaf> geekosaur: Is that true?
19:53:01 <geekosaur> that is my understanding, yes
19:53:09 <glguy> felixn: If you need help with some code, paste something to the pastebin that you'd have expected to work
19:53:20 <shachaf> It might've been before my time. I started using Haskell around the time the threaded RTS was implemented.
19:53:26 <shachaf> Or something like that.
19:54:26 <geekosaur> it may well have been that long ago
19:54:51 <geekosaur> I just know it was originally that way and changed; it seems like something they might have evaluated fairly early on
19:59:44 * hackagebot jsonsql 0.1.2.1 - Interpolate JSON object values into SQL strings  https://hackage.haskell.org/package/jsonsql-0.1.2.1 (DanielChoi)
20:29:47 * hackagebot tasty-tap 0.0.2 - TAP (Test Anything Protocol) Version 13 formatter for tasty  https://hackage.haskell.org/package/tasty-tap-0.0.2 (MichaelXavier)
20:32:18 <felixn> https://www.fpcomplete.com/user/munro/unify <-- OK, code in hand.  I'm trying to use the unification-fd library, but I can't get anything to work.  I want to replace my buggy algo with this, but I can't seem to get their source to compile.  I'm also open to throwing this out the window and using something else, I've just been taking shots in the dark
20:33:10 <Chobbes> `lift do { blah1 ; blah2 }` isn't equivalent to `do { lift blah1 ; lift blah2 }`?
20:33:51 <Imagine> Is there a reason the sidebar with users in it is gone?
20:33:59 <Imagine> That might just be me though
20:34:02 <Imagine> but I'm not seeing it
20:34:30 <felixn> all I really want from that code to work is `example1`
20:35:50 <glguy_> Felixn: the library build fine on its own outside of fpcomplete
20:36:09 <glguy_> I just installed it on my GHC 7.10.2 environment
20:36:42 <glguy_> But I won't be able to help much making fpcomplete work.
20:37:13 <geekosaur> Imagine, in IRC? that's something in your client. I found hexchat can get confused and hide it if the window size changes, for example
20:37:20 <felixn> glguy_: you don't get errors!?  I'm not using it on fpcomplete either, I just put it up there to be usable
20:37:33 <Imagine> hmm okay thanks geekosaur
20:38:03 <felixn> glguy_: oh woah, ok my atom ghc-mod integrations are yelling, but I can load it into ghci, hmmm
20:38:18 <Imagine> geekosaur - I'm using webchat.freenode.net
20:38:41 <glguy_> I don't use ghc-mod either but paste your error messages if you need help with them
20:38:50 <geekosaur> hm. I don't recall if I had a users sidebar when I used webchat (but that was (a) temporary (b) on an ancient version of IE)
20:39:17 <Imagine> ah okay
20:39:26 <Imagine> What clients are good to connect otherwise?
20:39:28 <Imagine> that aren't web chat?
20:39:32 <geekosaur> it's also possible they set a limit on number of users for which it's displayed; the channel has over 1400 users currently :)
20:39:35 <geekosaur> maintaining that list could be expensive
20:39:54 <glguy_> There's always glirc ;-)
20:40:07 <geekosaur> as I said, I use hexchat. there are lots of others for various platforms, and there are also alternative web clients that know how to connect to freenode
20:42:07 <Imagine> ah okay perfect
20:42:33 <felixn> glguy_: do you know how I make it give some useful output? @_@  like if it succeeds or not
20:42:54 <felixn> the API isn't clicking with me
20:43:10 <geekosaur> (irccloud seems to be used a lot, sadly I know it mosty because when it breaks a bunch of people disappear at the same time...)
20:43:29 <geekosaur> (as an alternative web client that is)
20:44:27 <latermuse> Is it possible to use IO inside an instance declaration? I want my show instance to change depending on the current time.
20:45:02 <c_wraith> latermuse: that's not something show can do
20:45:32 <c_wraith> latermuse: in general, show *should* produce something that's valid haskell code.  (Not always possible, but that's the ideal)
20:45:42 <Imagine> okay perfect
20:46:05 <latermuse> is it possible to send a pre-computed function to the show instance and only be used during 'show'?
20:46:08 <glguy_> Felixn: I'll look at your coffee in almost exactly 15 minutes when I'm back at a computer if no one else has helped you first
20:46:14 <felixn> Imagine: make a ShowIO class :D
20:46:19 <glguy_> Your code*
20:46:29 <Imagine> felixn - I don't think that was for me :)
20:46:44 <Hijiri> Imagine and latermuse have the same color in my irc client
20:46:48 <Hijiri> so I was confused too for a moment
20:46:53 <latermuse> haha, sorry about that
20:46:54 <felixn> Imagine: meh you're both green on my screen :D  textual needs to step up their color picking algorithm
20:47:01 <c_wraith> Same color is obviously the same person, right?
20:47:07 <latermuse> I dont use colors on my screen
20:47:14 <felixn> c_wraith: right on dark teal
20:47:15 <Imagine> lol Hijiri has both green and blue, and now felixn has green as well
20:47:18 <c_wraith> I can clearly distinguish 1439 different shades easily. :)
20:47:36 <latermuse> c_wraith: how did you come up with that number?
20:47:39 <Imagine> wait just kidding
20:47:46 <Imagine> green is because it has my name in it
20:47:50 <c_wraith> latermuse: number of people in the channel when I said it. :)
20:48:00 <latermuse> ;D
20:49:11 <latermuse> I guess ill make a ShowIO class, thanks guys
20:49:45 <latermuse> or maybe just a pretty printer
20:50:02 <arkeet> what do you need a class for?
20:55:28 <latermuse> arkeet: in general or for my case?
20:55:54 <AndroUser> Hi can anyone see what im typing
20:56:00 <arkeet> no, no one can see what your typing.
20:56:13 <AndroUser> Ok thanks arkeet you da real man
20:56:29 <arkeet> latermuse: for your case.
20:58:00 <latermuse> arkeet: I thought about it a bit more and think I am looking for a pretty printer, not ShowIO. I was going to use the ShowIO class to generalize over printing data that changes over time.
20:58:32 <latermuse> arkeet: But it makes more sense to just make a pretty printer function and supply it with the time
20:58:35 <ttt_fff> is there a builtin in haskell for: take this text string, change every \ to \\ and every " to \" ?
20:59:37 <arkeet> if you want it to *only* make those substitutions you can write it yourself. possibly with >>= or something.
20:59:41 <ttt_fff> basically a builtin for escaping text
21:00:00 <arkeet> `show` will escape more stuff.
21:00:07 <arkeet> (and put quotes around the whole thing.)
21:00:50 <jaconwil> > reverse . drop 1 . reverse . drop 1 . show $ "hi\\there"
21:00:52 <lambdabot>  "hi\\\\there"
21:01:32 <ttt_fff> i'm writing a EDSL that compiles to JS
21:01:38 <ttt_fff> "show" is probably not what I want to use
21:01:41 <felixn> http://lpaste.net/139763 <-- does this error while deriving MonadPlus look familiar to anyone?  I'm trying to fix a package on hackage
21:01:44 <ttt_fff> for converting Text -> JSString
21:02:56 <felixn> ttt_fff: https://hackage.haskell.org/package/json-0.9.1/docs/Text-JSON.html should work
21:03:09 <felixn> toJSString, it's right in there!
21:11:12 <AndroUser> Arkeeeeeeeet :-)
21:18:54 <ttt_fff> what libraries does Fay/Haste/GHCJS use for set/map in JS? (building a mini EDSL -> JS, and need functional set/map impls)
21:26:07 <lpaste_> glguy pasted “for felixn” at http://lpaste.net/139765
21:26:55 <felixn> glguy_: woah!!  let me check that out, I was just messing with Control.Monad.Unify after getting it to compile
21:27:37 <glguy> felixn: That code at least loads and you can see how you'd run one of the examples
21:29:16 <glguy> felixn: You can add "x' <- applyBindings x" to the example to resolve x rather than getting it back as a variable that you have to look up in the final bindings, among lots of other things
21:33:06 <felixn> glguy: ah nice, I did want that, how u doin dis?
21:33:54 <glguy> Doing which?
21:34:46 <felixn> make it work :D  I've been poking at this library for a few days
21:36:06 <Kaidelong> looks like stack just wasn't built with a workflow involving something fancier than a text editor in mind?
21:36:40 <Kaidelong> looks like I have to install GHC, ghc-mod, cabal-install etc myself if I want global availability of them
21:37:01 <Kaidelong> perhaps I need to edit the global configuration file?
21:37:16 <Chobbes> Kaidelong: you can add stack's binaries to $PATH?
21:37:19 <Kaidelong> but the stack command line tool should have things that do that via CLI if I was meant to do that
21:37:30 <Kaidelong> Chobbes: but I can't get stack to actually build any binaries
21:37:48 <Chobbes> Kaidelong: why not?
21:38:12 <Kaidelong> perhaps I'm doing it wrong, could you walk me through first time startup?
21:38:21 <Kaidelong> the bin directory is in my path, but it is empty
21:38:31 <Kaidelong> what do I need to do to populate it?
21:38:56 <Chobbes> Kaidelong: have you tried `stack init` on a project with a .cabal file?
21:38:59 <glguy> felixn: No magic, just a matter of looking at the types and the error messages when it wouldn't compile, and expecting a unification library to work a certain way
21:39:15 <Kaidelong> Mmm, I might have, but let me try it again
21:39:23 <Lokathor> stack install <package> will install an executable if that's what the package builds, even from not within a project. After that you can at least use "stack exec binary"
21:39:36 <Chobbes> Kaidelong: it should prompt you to do `stack setup` if it wants to download GHC.
21:39:49 <Lokathor> i don't know how to get it to always work without using "stack exec" though :/
21:40:10 <Kaidelong> "refusing to overwrite existing stack.yaml, please delete before running stack init or if you are sure use '--force'"
21:40:13 <Chobbes> Kaidelong: I believe it will also use the system GHC by default if it's an acceptable version. There are options for turning that on / off. See `stack`
21:40:26 <jle`> what's a nice way of representing a polynomial on one unknown?
21:40:33 <jle`> right now i'm using (Int -> Double)
21:40:36 <Chobbes> Kaidelong: stack.yaml just describes some extra stuff like where to get bonus packages from.
21:40:36 <Kaidelong> Chobbes: I am trying to manage everything with stack
21:40:46 <Kaidelong> so I didn't install haskell at all
21:40:49 <Chobbes> Kaidelong: if you have not customized that yet, then it is safe to --force or remove it.
21:41:05 <c_wraith> jle`: depends on your use case.  [Double] is sometimes better.  As well as other similar approaches
21:41:14 <Kaidelong> alright, it told me
21:41:28 <jle`> c_wraith: I tried Double first, but addition became a bit of a pain
21:41:29 <Kaidelong> "Setting codepage to UTF-8 (65001) to ensure correct output from GHC"
21:41:40 <c_wraith> jle`: store them reversed.
21:41:52 <jle`> most significant bit as the head, or the last?
21:41:54 <Kaidelong> then that it was writing stack.yaml based on yesod-simple.cabal
21:41:54 <c_wraith> jle`: basically every algorithm works better if they're reversed.  Except printing.
21:41:59 <jle`> either one was annoying for me ><
21:42:19 <Kaidelong> then "checking against build plan lts-3.2" then "selected resolver: lts-3.2", then it wrote out stack.yaml
21:42:33 <Kaidelong> didn't say anything about doing a setup
21:42:49 <Chobbes> Kaidelong: okay, you might have already done that. Does `stack build` build your project?
21:42:56 <Kaidelong> stack exec ghci brings up ghci
21:43:16 <Kaidelong> mmm, maybe I'm wrong about where the bindir is, then =/
21:43:33 <Chobbes> Kaidelong: you should be able to use `stack ghc` to run ghc and `stack ghci` to use ghci.
21:43:54 <Chobbes> Not sure where it hides the binaries for the compilers.
21:44:31 <Kaidelong> AppData\Roaming\local\bin is where I thought the binaries would be, but that is empty
21:44:46 <Chobbes> Kaidelong: Windows?
21:44:55 <Kaidelong> yes
21:45:31 <Chobbes> Ah. No idea about Windows to be honest. You should be able to make some kind of alias for `stack ghc` and `stack ghci`, though?
21:45:56 <Kaidelong> I could do that through powershell, actually
21:46:11 <Kaidelong> hmm, I wonder though, would the alias be visible to stuff like IntelliJ?
21:46:23 <Kaidelong> they probably just use the SYSTEM function or something like that
21:47:14 <Chobbes> Also there appears to be some IDE API / client thing so you can probably integrate it with the IDE of your choice if this has not already been done.
21:47:34 <Kaidelong> okay, looks like cabal-helper-wrapper has been installed in some place where stack isn't expecting it to be
21:47:41 <ttt_fff_> I have this code: https://gist.github.com/anonymous/2ccdf7e4f3c98f16b209 . How should I change my DSL expr system so that JSConsoleLog has type JSIO () ?
21:47:43 <Kaidelong> and this is what's preventing "stack install" from working
21:47:57 <felixn> but got: "Just Nothing" <-- amusing test assertion
21:48:11 <Lokathor> note, the current release doesn't work with "stack ghci" on windows i think
21:48:34 <Lokathor> well, not everywhere. it tries to load the local config, and if that fails then it'll fail
21:48:41 <Lokathor> but stack exect ghci will still work
21:48:55 <ttt_fff_> hmm, do I wnat GADTs with "data JSIO a where ..." ?
21:49:01 <Lokathor> this is fixed in the next release, or if you built stack from git
21:49:05 <Kaidelong> indeed, "stack ghci" fails
21:49:14 <Kaidelong> but "stack exec ghci" works
21:49:26 <Kaidelong> mm, that might be bad
21:49:50 <felixn> ttt_fff_: are you building a VM, or transcompiler?
21:49:52 <Kaidelong> I'm assuming that "stack ghci" is more supposed to be like an invocation to "cabal repl" than to "ghci"
21:49:55 * hackagebot http-client 0.4.21 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.21 (MichaelSnoyman)
21:49:57 * hackagebot mime-mail 0.4.10 - Compose MIME email messages.  https://hackage.haskell.org/package/mime-mail-0.4.10 (MichaelSnoyman)
21:50:27 <ttt_fff_> felixn: I don't know. This is a learning experience. I want to write code in haskell, have it type check, have my "JS code" stored as "Haskell exprs", then at some point, do "Haskell Expr -> *.js code"
21:50:39 <ttt_fff_> felixn: I don't think this is a VM, but I don't know what a "transcompiler" is
21:50:55 <ttt_fff_> also, I don't think this is a compiler, since compiler is "string -> js code", but I'm doing "haskell expr -> js code"
21:51:28 <c_wraith> ttt_fff: the only difference between string -> js code and haskell expr -> js code is a parser.
21:52:11 <ttt_fff_> c_wraith: in "string -> js code" I have to do my own type checking; in "haskell expr -> js code", I want to use haskell's type checker to do some work for e
21:54:00 <c_wraith> Ok, so there's a type checker in there too.  You still write the same code for code generation.  You just get to skip some of the front end.
21:54:03 <ttt_fff_> https://gist.github.com/anonymous/19a27e0063933a401c1f <-- I think this is closer to what I want, use GADTs
21:54:28 <ttt_fff_> c_wraith: okay, this is not "string -> js code", I want to do this as a "deep embed DSL in haskell"
21:54:39 <felixn> ttt_fff_: JS code is inherently untyped, so if you're building an eDSL you can't really leverage Haskell's type system, just be able to write it inside haskell.  (though how the grammar fits together would be pretty safe, but so are linters)
21:55:04 <Chobbes> (lift . lift) is unhappy with me. Shouldn't (lift . lift) (m >>= f) = (lift . lift) m >>= ((lift . lift) . f)?
21:55:30 <ttt_fff_> felixn: I agree that JS is untyped. However, I want to write type safe code in my DSL, then have it converted to untyped JS (rather than write raw JS).
21:55:32 <c_wraith> ttt_fff: if you're willing to look at others for inspiration, take a look at sunroof
21:55:48 <johnw> Chobbes: that would be two different binds
21:56:49 <c_wraith> johnw: I'm pretty sure that it should still be true.  I think that's an extension of the laws for MonadTrans
21:57:15 <c_wraith> barring any typos
21:57:45 <Chobbes> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/Control-Monad-Trans-Class.html lift (m >>= f) = lift m >>= (lift . f) is a low
21:57:56 <johnw> you're right
21:58:14 <felixn> ttt_fff_: c_wraith: https://github.com/ku-fpg/sunroof-compiler/blob/master/Language/Sunroof/JS/JQuery.hs <-- this file is pretty interesting!
21:58:48 <johnw> ok, same binds
21:58:52 <ttt_fff_> c_wraith: yes, I skimmed the sunroof paper once, it got me curious in this, in fact
21:59:22 <Chobbes> Okay, so... If I nest something in another monad transformer and replace all lifts with (lift . lift) it should still "work the same"?
21:59:33 <ttt_fff_> felixn, c_wraith: so it's easy to deep embed +-*/, and even thing functions like map/filter. However, I do not know of a way to deep-embed lambdas, i.e. \x -> x + 1, or case/pattern matching. Is this known to be possible to do in haskell, or does haskell's syntax not allow this without TH ?
21:59:37 <Chobbes> Because Attoparsec's parser monad is unhappy. Works with one, not two.
21:59:52 <c_wraith> Chobbes: If it doesn't, you should call it a buggy MonadTrans instance at some level.
22:01:49 <Chobbes> c_wraith: dammit D:. I am using StateT Blah (ExceptT String Parser)... Works with just the StateT Blah Parser. I assume StateT is correct, and I just went through ExceptT and checked the monad and monad transformer laws. It seems to check out for me.
22:02:03 <felixn> ttt_fff_: http://www.ittc.ku.edu/csdlblog/?p=88 <-- this looks related to your question
22:02:20 <c_wraith> Chobbes: the other possibility I would strongly consider is a typo somewhere.
22:03:16 <ttt_fff_> felixn: indeed it is, how does they reifiy the function
22:03:32 <Chobbes> c_wraith: I'll pull together a small example. I'm assuming I'm not understanding something, or missing something, but this is driving me MAD o_o.
22:04:00 <c_wraith> Chobbes: yeah, an example is good at this point
22:05:12 <ttt_fff_> https://gist.github.com/anonymous/fb1eee1dbcb7e4f2661a <-- how does this work
22:05:18 <ttt_fff_> how can you "take apart" an (Expr -> Expr) ?
22:06:14 <c_wraith> ttt_fff: that's more like symbolic execution
22:06:41 <c_wraith> :t deriv
22:06:42 <lambdabot> Not in scope: ‘deriv’
22:07:00 <felixn> ttt_fff_: if you make the extension .hs it will syntax highlight
22:07:35 <felixn> ttt_fff_: also it says in that article at the top, they instance the Num class
22:08:50 <ttt_fff_> I think I failed to explain what I'm confused about.
22:09:26 <ttt_fff_> x + 1 ==> (TESum (TEVar "x") (TEInt 1)) <-- this I know how to do, just using typeclasses hiding "Prelude.+", and defining my own "+", and overloading stuff
22:09:27 <felixn> ttt_fff_: my vision is based on color, could also be why
22:09:39 <c_wraith> @let f x0 = sin x0 + 3 * x0 - 10 in f x -- ttt_fff 
22:09:40 <lambdabot>  Parse failed: Parse error: in
22:09:49 <c_wraith> > let f x0 = sin x0 + 3 * x0 - 10 in f x -- ttt_fff 
22:09:50 <Kaidelong> is there a stack command that emulates cabal, for the purpose of IDE integration?
22:09:50 <lambdabot>  sin x + 3 * x - 10
22:10:06 <c_wraith> ttt_fff: the trick is to use a data type that supports symbolic evaluation
22:10:09 <ttt_fff_> c_wraith: that part I understand
22:10:14 <ttt_fff_> c_wraith: the part I don't get, is "reifyFn f"
22:10:14 <c_wraith> :t x
22:10:15 <lambdabot> Expr
22:10:34 <c_wraith> ttt_fff: that's exactly what I did there
22:10:39 <c_wraith> :t x
22:10:41 <lambdabot> Expr
22:10:53 <c_wraith> @let f = x0 = sin x0 + 3 * x0
22:10:54 <lambdabot>  Parse failed: Parse error: =
22:10:58 <c_wraith> @let f x0 = sin x0 + 3 * x0
22:11:00 <lambdabot>  Defined.
22:11:02 <ttt_fff_> "x + 1 ==> TESum (TEVar "x") (TEInt 1)" <-- this part I get; "f x = x + 1; f => TELambda "x" (TESum (TEVar "x") (TEInt 1))" <-- this part I don't get
22:11:05 <ttt_fff_> > f
22:11:06 <c_wraith> > f 1
22:11:07 <lambdabot>      Ambiguous occurrence ‘f’
22:11:07 <lambdabot>      It could refer to either ‘L.f’,
22:11:07 <lambdabot>                               defined at /tmp/mueval16816927771714636915.hs:1...
22:11:07 <lambdabot>      Ambiguous occurrence ‘f’
22:11:07 <lambdabot>      It could refer to either ‘L.f’,
22:11:09 <lambdabot>                               defined at /tmp/mueval1957747793424238335.hs:160:1
22:11:10 <c_wraith> whoops
22:11:14 <c_wraith> > L.f 1
22:11:15 <lambdabot>  3.8414709848078967
22:11:18 <c_wraith> > L.f x
22:11:20 <lambdabot>  sin x + 3 * x
22:11:28 <ttt_fff_> oh, I get it now
22:11:49 <ttt_fff_> reifnFn f is implemented as "Lambda (Var "x") => (f x)" , then then (f x) expands out to TESum (TEVar "x") (TEInt 1)
22:11:49 <ttt_fff_> cute
22:11:57 <ttt_fff_> this is brilliant actually
22:12:07 <ttt_fff_> c_wraith, felixn: thanks for sharing this, this is very cool
22:13:30 <felixn> c_wraith: what library gives you symbolic x like that?
22:13:44 <c_wraith> ugh, I forgot. :)
22:14:15 <c_wraith> @undefine
22:14:15 <lambdabot> Undefined.
22:14:17 <c_wraith> :t f
22:14:18 <lambdabot> FromExpr a => a
22:14:20 <nshepperd_> you can reify functions in that way
22:14:51 <nshepperd_> ttt_fff_: this doesn't work for case expressions or if statements though
22:15:03 <ttt_fff_> nshepperd: yeah, I was just about to ask:
22:15:08 <nshepperd_> because a symbolic variable doesn't "know" if it's True or False yet
22:15:08 <ttt_fff_> is there anyway to reifn case
22:15:12 <c_wraith> felixn: http://hackage.haskell.org/package/simple-reflect
22:15:43 <felixn> that's so cool!
22:16:14 <c_wraith> > foldr f 0 [x, y, z] :: Expr
22:16:16 <lambdabot>  f x (f y (f z 0))
22:16:17 <ttt_fff_> well, I don't mind defining my own "ifte :: Bool -> a -> a -> a" ... which I can then push into an arg of type TEIf BoolExpr (JS a) (JS a)
22:16:20 <nshepperd_> so I afaik people normally supply if' or case' as functions, when writing a deep embedded DSL
22:16:40 <ttt_fff_> nshepperd_: okay, I can speify if' as a function. How do you specify case' as a function and do pattern matching? that I do not know how to do
22:18:22 <nshepperd_> oh, maybe case' doesn't work..
22:19:12 <nshepperd_> I suppose you have to use eliminator functions
22:19:45 <ttt_fff_> nshepperd_: can you point me at example *.hs code to study ?
22:20:03 <nshepperd_> analogous to maybe :: Expr (Maybe a) -> (Expr a -> Expr r) -> Expr r -> Expr r
22:20:46 <nshepperd_> in principle that would be equal to pattern matching, but it's quite a bit clunkier
22:22:33 <nshepperd_> ttt_fff_: I don't really know any... the interface I know is from Ivory, but I don't understand the Ivory code
22:24:21 <ttt_fff_> nshepperd_: http://ivorylang.org/ivory-fib.html does not support case' does it?
22:24:24 <ttt_fff_> (I can't find it in the tutorial)
22:24:47 <jle`> sometimes i wish there was a way to do something like a -> (exists b. p b)
22:25:03 <jle`> without making a newtype or wrapper or something lame like that
22:25:15 <jle`> * as the type signature of a function
22:25:15 <nshepperd_> class CaseExpr a f | a -> f where { case' :: Expr a -> f }; instance CaseExpr (Maybe a) ((Expr a -> Expr r) -> Expr r -> Expr r) where { ... }
22:25:23 <nshepperd_> something like the above might work
22:25:34 <nshepperd_> ttt_fff_: yeah, I don't think ivory has case', my bad
22:26:43 <Chobbes> c_wraith: johnw: here's an example of my monad transformer woes. This version doesn't work: https://github.com/Chobbes/attoIssue/blob/master/Main.hs , this one does: https://github.com/Chobbes/attoIssue/blob/no-issues/Main.hs
22:27:19 <ttt_fff_> nshepperd_: noted, thanks!
22:27:21 <c_wraith> Chobbes: unfortunately, it's time for me to be out.  I leave it up to the other 1440 people in this channel to help. :)
22:27:31 <Chobbes> c_wraith: fair enough :).
22:28:00 <Chobbes> For anybody who looks at the above, the left gives me this resut Left "'+': not enough input"
22:28:05 <johnw> Chobbes: can you show me the error for the first one?
22:28:21 <Chobbes> johnw: /slightly/ ahead of you :P.
22:28:36 <Chobbes> The right one parses as expected.
22:29:25 <johnw> Chobbes: right, see addExpr'
22:29:58 <johnw> ah, I see, the <|>
22:31:18 <Chobbes> johnw: seems to work if I replace ExceptT with IdentityT appropriately...
22:31:24 <johnw> Chobbes: I think the problem is that <|> isn't doing what you expect
22:31:30 <luite> yay i survived the west coast trail
22:31:37 <breadmonster> Can someone explain to me how STM works?
22:31:44 <johnw> rather than failing a parser, it's failing an ExceptT computation
22:31:56 <Chobbes> Oh.
22:32:01 <Chobbes> That makes sense.
22:32:14 <Chobbes> It is, after all, an instance of applicative >_<
22:33:49 <Chobbes> Alternative, whoops.
22:34:02 <johnw> and so the parser failure is propagating out to the ExceptT, which is catching it and then immediately aborting the whole thing and giving it to you
22:34:28 <johnw> not sure why the return 0 isn't succeeding, though
22:34:38 <johnw> I might try adding some trace statements throughout
22:35:39 <johnw> what would make more sense to me is that <|> is _not_ aborting the parse anymore
22:35:51 <johnw> let me try this here
22:36:00 <scutigera> http://lpaste.net/139772
22:36:22 <scutigera> hello, i was hoping somebody could help me understand "Partial _" when using attoparsec
22:36:31 <scutigera> see link for concrete example
22:37:58 <Chobbes> scutigera: partial means it could be fed more input. You are probably waiting for a newline or something that you don't have.
22:38:03 <Chobbes> So your parser can't finish.
22:38:29 <scutigera> yeah- i keep adding things to try and consume that input, but then i end up with a different problem
22:38:38 <scutigera> so the problem is spaces at the end of the line
22:39:48 <scutigera> i try adding takeWhile isSpace, and then i get a partial match for ALL input, even though most of them were working
22:39:59 <Chobbes> scutigera: isSpace includes newline characters.
22:40:05 <scutigera> yes it does
22:40:12 <scutigera> but also space
22:40:34 <scutigera> so if there is just ' ' at the end of the line takeWhile isSpace should succeed, right ?
22:41:06 <scutigera> it's failing precisely on "  " at the end of a line
22:43:19 <scutigera> so my thinking is, Partial _ means it could consume more input
22:43:25 <Chobbes> scutigera: it's not failing, it's just not finished. You ask for many horizontal spaces at the end of lines. Unless it encounters something that isn't a newline it could consume more input.
22:43:32 <Chobbes> scutigera: exactly.
22:43:37 <Chobbes> err.
22:43:45 <Chobbes> Something that isn't a horizontal space*
22:43:46 <scutigera> yes but 0 or more
22:44:12 <Chobbes> scutigera: you could try (lineWords <* endOfInput)
22:44:32 <Chobbes> Which forces the parser to reach the end of the input.
22:44:51 <Chobbes> And stop there.
22:45:08 <Chobbes> Might be more along the lines of what you would expect.
22:45:57 <johnw> Chobbes: when it tries to parse '+' the second time, owing to the recursion, the second attempt fails, but this failure goes all the way out instead of being caught by <|>
22:46:31 <scutigera> yeah- but i'm still stuck on while takeWhile isSpace at the end of the line gives me partial for everything...
22:46:38 <scutigera> it should always succeed
22:46:57 <johnw> for example, if you try runExceptT $ return 10 >> (lift mzero <|> return 20), it does not return 20
22:47:16 <johnw> (or empty)
22:47:45 <Chobbes> scutigera: it is succeeding, it's just saying it could continue to parse, basically.
22:48:20 <scutigera> doh. i see, because it _could_ take more spaces
22:48:53 <scutigera> ok- but then i add <* endOfInput and i still get partial
22:49:03 <scutigera> aaargh
22:49:14 <Chobbes> scutigera: on all the same ones?
22:49:22 <scutigera> on _all_ of them
22:49:34 <scutigera> so i add takeWhile isSpace to eat space at end of line
22:49:38 <scutigera> and get all partials
22:49:43 <Chobbes> Uh... I might be very wrong about something.
22:49:59 <scutigera> then i say (lineWords <* endOfInput) and i get partial for ALL of them
22:49:59 <kadoban> It's kind of a pain in the ass making code work for both GHC 7.8 and GHC 7.10 :-/
22:50:28 <scutigera> Chobbes: lol
22:50:33 <scutigera> i might be too !
22:50:50 <scutigera> what i hate is that my structure makes perfect sense when you look at it
22:50:55 <scutigera> but it's broked
22:51:14 <Chobbes> scutigera: sorry. I have spent an age tangling myself with Attoparsec code today -- I'm probably more confused than anybody at this point ;).
22:51:22 <scutigera> hahaha
22:51:28 <johnw> let me try scutigera 
22:51:38 <johnw> can you show me your imports also?
22:52:02 <scutigera> well i can stuff the whole thing in the link,but it's kinda messy...
22:52:18 <kadoban> I figured it was just going to be conditionally importing Applicative stuff … but then I realized like every (Monad m) constraint now needs to be (Monad m, Applicative m, Functor m), sigh.
22:52:21 <Chobbes> scutigera: https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString.html#v:Partial <- This is what Partial is in the docs.
22:52:21 <johnw> n/m, I'll figure it out
22:52:51 <scutigera> http://lpaste.net/139772
22:53:49 <scutigera> johnw: the code as it stands right now gives me Partial _ for every string in test2
22:53:55 <johnw> ok, I see your results
22:54:03 <johnw> (from before)
22:55:19 <scutigera> yeah- for that latest code i didn't paste results because it's all "Partial _"
22:56:46 <scutigera> Chobbes: yeah- i find the whole partial continuation thing to be highly confusing. i was trying to handle the iresult very specifically at one point and tried to do exactly that, i.e. pass an empty string to continuation and got nothing but type error hell for my trouble
22:57:45 <johnw> ah, Chobbes was right about the first one
22:57:56 <johnw> many1 (satisfy $ not . isSpace) reaches EOF before completing its job
22:58:18 <johnw> with a \n there, which is neither not.isSpace, nor isHorizontalSpace, it provides the parser with a way to finish
22:58:21 <Chobbes> scutigera: I usually just use parseOnly for testing. I find it more clear.
22:58:57 <scutigera> johnw: to be clear is the "first one" , "word1 word2" ?
22:59:01 <johnw> yes
22:59:08 <johnw> it's not failing
22:59:17 <johnw> it's just saying it didn't reach the end
22:59:27 <scutigera> oooooh it's looking for the space after the word...
22:59:33 <johnw> say I had a parser: Foo <$> char ' ' <*> char ' '
22:59:42 <johnw> and my while input was one space
22:59:46 <johnw> whole*(
22:59:57 <johnw> then the result would be partial, waiting for that next space
23:00:04 <johnw> not a space after the word
23:00:13 <johnw> something which is neither a space, nor a horizontal space, like \n
23:00:17 <scutigera> ok - then i obviously don't understand how sepby works
23:00:26 <johnw> sepBy parses what is between
23:00:39 <scutigera> the fact that it fails on "word1 word2" seems broken.
23:00:44 <johnw> your parser says: not spaces, separated by spaces, ending in something that is neither
23:01:00 <johnw> it's not broken though, it's waiting for more input
23:01:10 <scutigera> right- sorry- keep saying that- i understand.
23:01:18 <johnw> if you took that partial result, and fed it a newline, it would come back with Done
23:01:58 <scutigera> so sepby has an operation that is really "pspsps" not "psp"
23:02:21 <johnw> huh?
23:02:47 <johnw> string "foo" `sepBy` char ',' would parse: foo ; foo,foo ; foo,foo,foo ; etc.
23:02:47 <scutigera> well if i did something like (char 'a') `sepby` (char ' ')
23:03:17 <scutigera> ok then i'm still being dense
23:03:28 <johnw> sepBy is a parser for separators
23:03:33 <johnw> not things that also terminate
23:03:36 <scutigera> (not space) `sepby` (space)
23:03:48 <johnw> (not space) `sepby` (horizontal space) is what yo uhave
23:03:54 <johnw> horizontal space is a smaller set than space
23:04:29 <EvanR> in parsec, can you attempt a partial parse, i.e. get back one of the results "Ok a" or "Error" or "NeedMoreInput (String -> Result a)"
23:04:49 <scutigera> oh- right. that's busted. ok- i changed them _both_ to isHorizontalSpace
23:05:26 <scutigera> EvanR: right Fail, Partial, Done
23:05:44 * EvanR reads to see if thats what the current topic is
23:06:19 <EvanR> youre talking about attoparsec
23:06:24 <EvanR> what about parsec
23:06:29 <scutigera> EvanR: attoparsec
23:07:45 <scutigera> ok- so now i have takeWhile isHSpace, <the sepby>, takeWhile isSpace (so i can get newline)
23:08:49 <scutigera> and get all Partial _
23:09:20 <scutigera> and so is it the sepby that's waiting for more input or the final takeWhile isSpace ?
23:10:40 <breadmonster> EvanR: Does ghc do dead code elimination?
23:10:44 <Chobbes> johnw: oy vey. Thanks for the help. I think that gives me enough to go off of! Too exhausted at the moment to fully grok it, though :).
23:11:06 <EvanR> i would hope so
23:11:15 <Chobbes> EvanR: breadmonster https://wiki.haskell.org/GHC_optimisations#Dead_code_elimination
23:11:36 <EvanR> what would be the result of NOT doing dead code elimination?
23:11:41 <scutigera> breadmonster: in fact there was a reddit post about DCE today
23:11:44 <scutigera> might be worth reading.
23:11:52 <johnw> Chobbes: to put it simply: a lifted mzero does not translate into an mzero in the transformer
23:12:08 <breadmonster> scutigera: I just finished reading that before asking the question.
23:12:14 <scutigera> lol
23:12:19 <scutigera> lotta help i am...
23:12:28 <nshepperd_> EvanR: there doesn't seem to be anything defined in parsec for that, I guess the normal way to do something like that would be define a custom Stream instance
23:12:36 <breadmonster> I can't seem to think of a reason why ghc won't do any dead code elimination across modules.
23:12:45 <johnw> Chobbes: I think you may want ParsecT
23:13:26 <nshepperd_> using like a continuation monad or something that returns control when the stream so far has been used up
23:13:27 <jle`> is there a shorthand for maybe mzero return?
23:13:37 <Chobbes> johnw: I really do, but I don't have the option :(.
23:13:39 <EvanR> im trying to find an example writing an interactive console which lets you move commands across lines like SQL
23:13:42 <jle`> s/mzero/empty
23:14:20 <scutigera> ah well. i go down in defeat to attoparsec again tonight.
23:14:33 <scutigera> it's getting easier since it happens every night :-)
23:14:42 <Chobbes> johnw: hence monad transformenstein :).
23:14:50 <scutigera> i just wish it was on hard stuff instead of "easy" stuff
23:14:50 <johnw> Chobbes: another way to put it:
23:15:14 <johnw> > Nothing <|> Just 20
23:15:16 <lambdabot>  Just 20
23:15:18 <johnw> > runExceptT $ lift Nothing <|> lift (Just 20)
23:15:20 <lambdabot>  Nothing
23:15:20 <ttt_fff_> i asked this earlier (but hoping different people = perhaps new ideas) -- I'm buildling an deep EDSL embedded in ahskell for outputting JS. Is there any nice way to 'reify' haskell's case statement / pattern matching ?
23:15:25 <johnw> this is what is biting you
23:15:32 <breadmonster> How do I get ghc to dump core?
23:15:39 <breadmonster> --ddump-simpl right?
23:15:45 <johnw> breadmonster: yes
23:15:49 <breadmonster> except...what's the whole command?
23:15:56 <johnw> ghc -ddump-simple Foo.hs
23:16:03 <johnw> s/e//
23:16:28 <johnw> "<|> does not distribute over lift"
23:16:42 <breadmonster> johnw: Oh it dumps it to the screen and not a file?
23:16:48 <johnw> yes
23:17:07 <Chobbes> johnw: yeah :(. I guess I'll have to deal with that somehow. Thanks! Off to bed.
23:20:06 * hackagebot range-space 0.1.2.0 - A Range type with vector-space instances  https://hackage.haskell.org/package/range-space-0.1.2.0 (JohnLato)
23:31:54 <erisco> wish you could search hackage by module name
23:32:03 <johnw> hoogle can at least
23:38:11 <liste> and hayoo
23:38:11 <erisco> I feel like there are some design curiosities with streaming data
23:38:22 <johnw> such as?
23:38:42 <erisco> for example, readFile :: FilePath -> IO Text  from Data.Text.Lazy.IO
23:39:21 <erisco> this is supposed to give you a Text value that is read lazily, presumably using unsafe IO operations
23:39:33 <erisco> this has unfortunate consequences with IO errors though
23:39:53 <erisco> so for example, if I read a chunk of Text successfully I know I have a chunk of Text for good
23:40:14 <erisco> if I just have a lazy Text I have no idea if I really have that
23:40:23 <erisco> or if the moment I try to read from it I will get an IO exception
23:40:45 <johnw> yep
23:40:57 <erisco> I understand the wish for a seamless Text but it isn't really that way
23:41:14 <johnw> you could get an IO exception "the moment you read" by any method
23:41:39 <johnw> are you saying that the problem is that you _think_ that you have a Text?
23:41:42 <erisco> not if I get the Text chunk by chunk
23:41:50 <erisco> I either get the chunk or nothing
23:41:54 <johnw> attempting to read the chunk could raise an exception
23:42:06 <erisco> it shouldn't, why would it
23:42:49 <johnw> you're interacting with the outside world, anything could happen
23:42:55 <johnw> your hard drive could, at that moment, die
23:43:01 <erisco> yes but reading a chunk is atomic
23:43:09 <johnw> I'm not sure where you're going...
23:43:12 <erisco> you either get a chunk or you don't, it is the smallest unit to be read
23:43:21 <erisco> I don't know where you're going XD
23:43:40 <johnw> it sounds like you're saying that one way of reading the data is different than another way
23:43:44 <johnw> but I don't think that's what you meant
23:43:52 <erisco> yes I am saying that
23:55:11 * hackagebot stackage-curator 0.11.0 - Tools for curating Stackage bundles  https://hackage.haskell.org/package/stackage-curator-0.11.0 (MichaelSnoyman)
23:55:46 <johnw> erisco: can you try to explain your point again?
23:59:23 <EvanR> whats the best random lib?
