00:00:14 <benzrf> how do i get attoparsec to baktrack, failure is unambiguous
00:00:17 <benzrf> er i mean
00:00:20 <benzrf> expressions are unambiguous
00:00:22 <johnw> attoparsec always backtracks
00:00:28 <benzrf> but backtrack the way i want it tooooo
00:00:35 <johnw> there is no difference
00:00:40 <benzrf> what?
00:00:46 <johnw> what you're asking is, how do I get the parser that I want to succeed, rather than some earlier parser
00:00:57 <johnw> you need to order them correctly, of course
00:00:59 <benzrf> but it fails when eof fails
00:01:12 <johnw> that means it's succeeding too early
00:01:22 <johnw> you need to induce failure
00:01:26 <benzrf> true
00:01:38 <benzrf> how does one achieve this
00:01:58 <johnw> move parseTerm down, use chainl to parse your expressions
00:02:08 <benzrf> oh chainl
00:02:28 <johnw> chainl is how you do left-recursive safely
00:03:27 <benzrf> attoparsec does not appear to have :[
00:03:36 <johnw> read your scrollback
00:03:41 <johnw> i linked you to a version for attoparsec
00:03:43 <gamegoblin> Does the IsString instance of ByteString handle Unicode correctly?
00:03:46 <benzrf> >.>
00:03:55 <benzrf> gamegoblin: bytestriNG IS NOT TEXTTTTTTTTT
00:04:14 <liste> gamegoblin what would the encoding be?
00:04:16 <johnw> ByteString does not deal with encodings
00:04:29 <gamegoblin> I am aware
00:04:31 <benzrf> gamegoblin: bytestring is called bytestring for a reason
00:04:40 <gamegoblin> But it is an instance of IsString
00:04:44 <johnw> so, if it has an IsString instance, I doubt it thinks about Unicode
00:04:46 <gamegoblin> so I was wondering which encoding that used
00:04:59 <johnw> the no encoding encoding?
00:05:03 <liste> > ("äö" :: BS.ByteString)
00:05:04 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
00:05:04 <lambdabot>                  with actual type ‘[Char]’
00:05:04 <lambdabot>      In the expression: ("\228\246" :: BSC.ByteString)
00:05:10 <arkeet> I think it just does the Char8 thing
00:05:13 <liste> > (fromString "äö" :: BS.ByteString)
00:05:14 <lambdabot>  "\228\246"
00:05:17 <arkeet> i.e. mod 256 on each character
00:05:28 <arkeet> > fromString "あ :: BS.ByteString
00:05:30 <lambdabot>  <hint>:1:31:
00:05:30 <lambdabot>      lexical error in string/character literal at end of input
00:05:31 <liste> but char8 is still beyond Ascii
00:05:32 <arkeet> > fromString "あ" :: BS.ByteString
00:05:34 <lambdabot>  "B"
00:05:41 <johnw> arkeet: good call
00:05:53 <arkeet> chr (ord 'あ' `mod` 256)
00:05:54 <arkeet> > chr (ord 'あ' `mod` 256)
00:05:56 <lambdabot>  'B'
00:05:57 <arkeet> yeah
00:05:58 <arkeet> .
00:06:20 <liste> but what are code points 128-255 ?
00:06:28 <arkeet> ?
00:06:34 <arkeet> those go to bytes 128-255.
00:06:38 <liste> 0-127 is ascii
00:06:52 <arkeet> unicode 0-255 coincides with latin-1
00:07:01 <liste> ok
00:07:35 * hackagebot linearscan 0.8.0 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-0.8.0 (JohnWiegley)
00:07:36 * hackagebot linearscan-hoopl 0.8.0 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.8.0 (JohnWiegley)
00:07:47 <johnw> did hackagebot just repeat itself?
00:08:07 <liste> I've seen that many times
00:08:14 <johnw> i didn't do anything here
00:08:54 <arkeet> it seems to have.
00:12:09 <erisco> johnw, what is the significance of this new algorithm?
00:13:09 <johnw> erisco: you mean, of the linear scan allocator?
00:13:14 <erisco> yes
00:13:32 <johnw> it's not my algorithm; it was created by Christian Wimmer and is what Sun uses in their Java Hotspot JIT
00:13:51 <johnw> it's just a general purpose register-allocator-as-a-haskell-library, for those who want or need such things
00:13:59 <johnw> it has the advantage of being very correct :)
00:14:56 <erisco> neato
00:15:06 <johnw> it proves things like that no register allocation can overlap, for example, which is not anywhere near as simple as I first thought it would be to do
00:30:58 <ReinH> johnw: nice!
00:37:31 * hackagebot linearscan-hoopl 0.8.1 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.8.1 (JohnWiegley)
00:40:36 <erisco> :t guard
00:40:37 <lambdabot> Alternative f => Bool -> f ()
00:40:42 <erisco> where is this definition of guard coming from
00:41:51 <orb_> :info guard
00:42:28 <orb_> Control.Monad has one.
00:42:41 <erisco> that one has a different type
00:42:50 <erisco> wait no it doesn't
00:42:52 <erisco> Hoogle is wrong
00:42:56 <erisco> @hoogle guard
00:42:57 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
00:42:57 <lambdabot> package guarded-rewriting
00:42:57 <lambdabot> Language.Haskell.TH.Lib guardedB :: [Q (Guard, Exp)] -> BodyQ
00:43:17 <liste> that's the old `guard'
00:43:24 <cocreature> that's base <= 4.7
00:43:25 <liste> before AMP
00:55:46 <erisco> any name for  Either a b -> Either b a  ?
00:58:24 <erisco> you kinda want  newtype Dual a b = Dual (Either b a)
01:05:40 <erisco> what are the newtype wrappers to select Bool monoids?
01:06:40 <erisco> ah, All and Any
01:07:31 <erisco> though annoyingly if you have a type which wraps Bool
01:07:37 <erisco> now you need your own All and Any
01:07:47 <arkeet> where's the Xor monoid? :-(
01:08:05 <supki> erisco: (re: Either a b -> Either b a) the categories package calls that operation "swap"
01:08:16 <supki> well, it's slightly generalized
01:08:18 <erisco> arkeet, how do you make xor a monoid?
01:08:39 <arkeet> ???
01:08:44 <arkeet> xor is associative.
01:08:48 <arkeet> and has False as the unit.
01:09:31 <erisco> for some reason I was thinking False `xor` False = True
01:09:38 <arkeet> heh
01:11:28 <jle`> xor's the only monoid on bool that's also a group too
01:11:53 <erisco> dammit how did I miss the xor group
01:12:33 * hackagebot zmidi-core 0.8.1 - Read and write MIDI files.  https://hackage.haskell.org/package/zmidi-core-0.8.1 (StephenTetley)
01:15:10 <moop> what was the haskell-chat channel?
01:15:16 <moop> haskell-blah or something
01:15:20 <moop> @bleh
01:15:20 <lambdabot>  Define what?
01:15:49 <moop> @talk
01:15:49 <lambdabot> Maybe you meant: tell ask
01:17:49 <pacak> moop: haskell-blah
01:19:02 <erisco> I have a puzzle for you, in light of recent discussion
01:19:16 <ely-se> I hate puzzles.
01:20:49 <erisco> There is a list which contains some integers. All of the integers present occur an even number of times, except for one which occurs an odd number of times. In one pass, determine the odd integer.
01:21:27 <erisco> Oh, and in constant memory :)
01:21:55 <moop> can't you xor all the numbers?
01:21:57 <chpatrick1> foldr xor 0
01:22:01 <chpatrick1> dammit :D
01:22:56 <jle`> constant memory with respect to the number of items in the list, or the size of the maximum integer encountered?
01:23:07 <jle`> s/encountered/in the list
01:23:40 <jle`> xoring everything isn't constant memory as the size of the largest Integer grows
01:23:54 <ely-se> My algorithm constantly uses all available RAM.
01:26:32 <anohigisavay> hi, is there any platform-independent approach to get cpu usage info using Haskell?
01:27:09 <anohigisavay> i know some people read /proc/stat but that's unix-only
01:27:42 <ely-se> anohigisavay: if all else fails, you can use the SIGAR API using the FFI
01:28:02 <srhb> anohigisavay: There's no platform independent way as such, and there's no library to give the disparate methods a common API, as far as I know.
01:28:04 <ely-se> it's a cross-platform library that does this witha  C API
01:28:11 <srhb> Writing one to sigar could indeed be that. :)
01:28:46 <anohigisavay> cool, thanks guys :)
01:32:13 <erisco> jle`, space linear to the size of integer
01:32:20 <erisco> er, width of integer is a better word
01:32:26 <ely-se> haha "word" get it
01:32:48 <erisco> no I have a second puzzle
01:32:59 <ely-se> does it require thinking with portals?
01:34:44 <erisco> There is a list of sets. Determine which elements are member of an odd number of the sets (zero is not odd).
01:35:58 <ely-se> that's quite easy
01:36:31 <erisco> wouldn't be a good riddle if it wasn't ;)
01:36:47 <ely-se> union all the sets, then filter it with the predicate "count the number of occurrences and check if odd"
01:37:30 <tdammers> unioning sets?
01:37:46 <tdammers> wouldn't that just yield the set of all elements that are in one or more of the original sets?
01:38:01 <erisco> ely-se, I don't think that works
01:38:03 <ely-se> yes, that's step 1.
01:38:23 <jle`> i'd get a lot of post it notes, and a bag.  then i'd go down the list, and every time i saw an element, i'd write it on the post it note and put it in my bag
01:38:52 <jle`> after i'm done, i give the bag to two people and tell them they are only allowed to keep a note if the other keeps an identical note
01:39:06 <jle`> the only one left in the bag after they are done taking their notes is the correct one
01:39:24 <tdammers> naive approach: convert all sets to lists, concatenate them together, sort, group, filter by "odd"
01:39:31 <erisco> like the first puzzle, you can solve this with one pass of the list
01:39:43 <ely-se> https://gist.github.com/rightfold/8f867b86109021c577cb
01:40:01 <tdammers> XOR
01:40:09 <erisco> ely-se, oh I see, but there is a more elegant solution
01:40:16 <erisco> that works though it uses more than one pass
01:40:33 <jle`> my method also only uses one path
01:40:38 <jle`> *pass
01:40:49 <tdammers> treat sets as bit sets, fold with an element-wise XOR
01:40:51 <tdammers> (in a nutshell)
01:41:25 <tdammers> i.e., on every step, add elements from current set that aren't in the accumulator, and remove the ones that are
01:42:40 <erisco> jle`, that is an interesting solution
01:43:23 <erisco> you can solve it using memory linear to the number of unique elements
01:44:08 <erisco> tdammers, I like your thinking, but what is the set operation to use on each step?
01:44:14 <erisco> what is xor for sets?
01:44:38 <ely-se> elements which are in either but not both sets!
01:45:13 <tdammers> yeah
01:45:21 <ski> erisco : symmetrical difference
01:45:24 <ely-se> symmetric difference
01:45:29 <tdammers> that, yes
01:45:48 <erisco> indeed-y-do
01:46:36 <erisco> this arose from being given the original riddle and then wondering what else has the properties of xor
01:46:54 <lpaste_> tdammers pasted “riddle solved” at http://lpaste.net/139620
01:47:06 <ely-se> symmetric difference on types
01:47:37 <ely-se> a value has type T ^ U if it's of either but not both those types :D
01:47:38 <tdammers> having the cake and eating the cake
01:47:54 <ely-se> the cake is a lie
01:47:58 <tdammers> unless you're allowed to dispose of the cake in ways other than eating it
01:48:10 <tdammers> and it only works for atomic cakes
01:48:18 <ski> ely-se : `Ord a' implies `Eq a'
01:48:36 <jle`> erisco: symmetric difference is actually the xor operation on the boolean algebra of sets
01:48:52 <ely-se> there's probable some way to implement type XOR in Scala
01:49:06 <jle`> s/boolean algebra/boolean ring
01:49:40 <erisco> ah, a ring, I should look at that... could be helpful
01:52:25 <erisco> I thought it was interesting that, take the original problem, but map Set.singleton over the list first
01:52:46 <erisco> now instead of only being able to determine one odd integer, you can find them all
01:57:38 <erisco> I don't know how 3D games come out still looking like they are from the year 2000
01:58:04 <erisco> you actively have to reduce poly counts and decrease texture resolutions
01:58:36 <erisco> there are all sorts of shaders you can copy and use
01:59:37 <Lokathor> anyone know of a good guide on operating lambdabot?
01:59:50 <Lokathor> not like, in the channel, but making the program work on your own system
02:00:08 <erisco> I guess it is doing all the extra work for bump mapping and tessellation and so forth
02:00:23 <erisco> techniques that require effect to make work on the art assets
02:01:48 <MarcelineVQ> Lokathor: I found looking at the code for lambdabot to be informative
02:02:35 * hackagebot yesod 1.4.2 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-1.4.2 (MichaelSnoyman)
02:03:31 <Lokathor> there is a loooooot of code
02:03:46 <Lokathor> i just want it to connect to a server and join a channel, but that seems to be stalling somehow
02:24:42 <bernalex> anyone have a good idea of a really simple beta-reduction example that's just a few lines?
02:24:58 <bernalex> I just want to illustrate the idea itself
02:25:09 <bernalex> right now I just have http://lpaste.net/2258192460188483584 heh
02:26:56 <ely-se> turning (\x -> f x (y x)) 42 into f 42 (y 42)
02:26:59 <ski> i'm not sure why the first `f' is named the same as the latter two ?
02:27:09 <ski> (in the paste)
02:28:15 <bernalex> ski: because substitution of equals for equals?
02:28:39 <bernalex> ski: the idea is just to show very simply and neatly how we can reduce our expressions
02:28:41 <ski> the first `f' has a different type from the latter two, so obviously can't refer to the same thing
02:30:20 <ski> beta-reduction is, strictly speaking, turning `(\x -> ..x..) (...)' into `..(...)..' (as in ely-se's example)
02:30:36 <bernalex> yes I see what you mean
02:31:05 <ski> given a definition `f x = ..x..', one could also say that `f (...)' can be beta-reduced into `..(...)..'
02:34:58 <bernalex> how about this: (tiny pastespam incoming)
02:35:01 <bernalex> f x y = x + y
02:35:03 <bernalex> g x   = x * 2
02:35:05 <bernalex> (\x -> f x (g x)) 42
02:35:07 <bernalex> f 42 (g 42)
02:35:09 <bernalex> f 42 84
02:35:15 <bernalex> oh derp
02:35:55 <bernalex> well ok it's not entirely unreasonable
02:36:31 <ski> do you intend to show reduction steps in a call-by-name (call-by-need ?) order, or just show an equality chain with reduction/expansion steps applied however you see fit (as would be the case in a proof, e.g.) ?
02:37:07 <bernalex> hm. I'm not sure. I guess doing it in call-by-need order would be more appropriate
02:37:27 <dramforever> then you will need to somehow represent it in a graph
02:38:16 <bernalex> sounds overkill for a slide of two bullet points and a few lines of code
02:38:42 <ski> <http://lpaste.net/116547> is an extended example of by-need
02:39:20 <bernalex> ski: yes, a bit overkill for a quick slide to give the terminology some meaning
02:39:35 <ski> anyway, in the example above, you should reduce the `f' application before the `g' one
02:39:58 <bernalex> 250 LOC in general is a bit overkill in one slide for someone who's only barely heard of haskell I would guess
02:40:14 <ski> i didn't suggest you put that into a slide :)
02:40:34 <bernalex> no I know, heh
02:40:43 <ski> just fyi of one way to present a by-need reduction trace
02:40:53 <bernalex> yep, keeping the tab open
02:41:36 <bernalex> ski: do you mean reduce to 42 + (g 42), and then to 42 + 84, and finally 126?
02:41:44 <ski> (the thing which could be clearer (more formally) expressed in there is what demands what)
02:42:06 <ski> bernalex : yes, with `42 + 42 * 2' inbetween
02:42:53 <bernalex> ah yeah
02:43:25 <ski> in this case, `+' is strict in both arguments, so it demands the `g' application, and then the `*' one
02:49:52 <Lokathor> got a home lambdabot working
02:49:53 <Lokathor> yay
02:52:37 * hackagebot protocol-buffers 2.1.5 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.1.5 (k_bx)
02:52:39 * hackagebot protocol-buffers-descriptor 2.1.5 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.5 (k_bx)
02:52:42 * hackagebot hprotoc 2.1.5 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.1.5 (k_bx)
02:54:49 <liste> why two?
02:55:03 <liste> hprotoc and protocol-buffers
02:55:50 <Xe> liste: binary tool and library
02:56:20 <liste> oh
02:57:09 <Xe> that's my guess at least
03:02:47 <bernalex> what do you guys think is some of the most defining haskell features that needs to be mentioned as an intro to the lang?
03:03:17 <dramforever> more purely functional than most other languages
03:03:20 <Peaker> Anyone using Haskell for Mac? Is there a way to add "-i" source-location flags to a project?
03:03:21 <bernalex> I have semi-detailed mentions of: non-strict semantics, type safety, static verification, functional programming, functional purity, higher-kinded polymorphism
03:03:29 <dramforever> hmm...
03:03:38 <Walther> bernalex: link? :)
03:03:48 <bernalex> then I have tiny (one bullet point) mentions of: pattern matching, garbage collection, ADTs, type inference & typeclasses
03:03:58 <bernalex> Walther: I don't really have it online atm at least
03:04:02 <Walther> ah, ok
03:04:04 <dramforever> bernalex: maybe expand on types
03:04:17 <dramforever> types are a great deal isn't it
03:04:36 <bernalex> not sure what more to say than strong/static/hkr/typeclasses really
03:04:39 <dramforever> (hmm...forget about the grammar stuff)
03:04:45 <bernalex> (+ADTs)
03:05:09 <bernalex> I'll be doing some workshoppes eventually that go into detail fwiw
03:05:29 <dramforever> bernalex: I would really want to show that because it's really easy to create custom types, people reuse inappropriate types much less often
03:05:38 <dramforever> e.g. Maybe instead of null
03:05:48 <dramforever> or -1
03:06:36 <bernalex> I think I'm saving that stuff for the first lecture, which will be Prelude stuff. but it *is* important.
03:07:31 <dramforever> bernalex: I think you should probably at least mention it
03:08:39 <chattered> bernalex: Wadler has his intro to FP lectures up on youtube and the slides on the Edinburgh website. You might like to look at the first lecture.
03:15:22 <Peaker> Does HaskellForMac only have Haskell98 modules?! no hierarchial modules?
03:16:54 <talios> Just installed it myself - no Data.UUID which my one and only current Haskell program uses :(  I think its LTS Haskell ? The module list is online
03:17:37 <talios> http://support.hfm.io/1.0/api/ is what the "libraries" menu item sent me to
04:22:41 * hackagebot frpnow 0.18 - Principled practical FRP  https://hackage.haskell.org/package/frpnow-0.18 (AtzeVanDerPloeg)
04:47:43 * hackagebot wai-routes 0.8.1 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.8.1 (AnupamJain)
05:27:42 <SimpleX_> hello!
05:30:05 <SimpleX_> Could you please help me a little? Want to try "snmp" package, but ghc gives me an error "Couldn't match type ‘[Char]’ with ‘ByteString’". Do I need to convert type?
05:30:57 <SimpleX_> There's no conversions in example
05:31:03 <frerich> SimpleX_: It sounds like you want to turn a sequence of characters into a sequence of bytes, which means using some sort of 'encoding'.
05:31:30 <SimpleX_> https://hackage.haskell.org/package/snmp-0.2.0.0/docs/Network-Snmp-Example.html
05:32:16 <SimpleX_> conf3 is described this way, no conversions. Incorrect example?
05:32:25 <frerich> SimpleX_: Ah, you got it from an example - it may be that this example silently makes use of a GHC extension called 'OverloadedStrings'. It permits passing plain strings in places where ByteString values are expected.
05:32:54 <frerich> SimpleX_: It might be that you can get things going by adding '{-# LANGUAGE OverloadedStrings #-}' to the top of your file.
05:33:53 <SimpleX_> it worked! thank you!
05:37:38 <SimpleX_> If you don't mind, give me please an advice. I need some fast devices polling via snmp as a simple server. Is haskell suitable for the task?
05:41:05 <liste> does it need to be hard real-time?
05:42:28 <SimpleX_> You mean polling in exact intervals?
05:43:06 <tdammers> more generally, doing anything that involves realtime guarantees
05:43:20 <tdammers> "this code will execute within this amount of time"
05:43:49 <SimpleX_> No. It needs to be quite fast (encoding, decoding speed), asynchronous
05:44:04 <tdammers> Haskell can do fast
05:44:19 <tdammers> hard realtime is not its strong suit due to being garbage-collected
05:45:03 <SimpleX_> Yeah, that's not a problem. Performance, yes. But this task is not real time.
05:46:25 <SimpleX_> I need to process a lot of requests in a sec without much cpu impact (like some background daemon)
05:47:45 * hackagebot mac 0.1.1.0 - Static Mandatory Access Control in Haskell  https://hackage.haskell.org/package/mac-0.1.1.0 (AlejandroRusso)
05:47:47 * hackagebot squeeze 1.0.4.5 - A file-packing application.  https://hackage.haskell.org/package/squeeze-1.0.4.5 (AlistairWard)
05:47:52 <SimpleX_> a lot, but no constant performance is reqiured
05:50:54 <liste> then Haskell is suitable, but remember that optimizing Haskell for performance is quite different than other languages
05:51:20 <liste> (like Haskell in general :)
05:52:45 * hackagebot mac 0.1.2.0 - Static Mandatory Access Control in Haskell  https://hackage.haskell.org/package/mac-0.1.2.0 (AlejandroRusso)
06:00:58 <SimpleX_> ok, thanks!
06:03:59 <erisco> gee, deriving for Enum seems kind of weak
06:06:44 <erisco> it complains if the constructors are not nullary, even if you give concrete types to all the fields (such as Bool)
06:07:32 <geekosaur> it complies with the language report
06:07:47 <erisco> yeah yeah language report yadda yadda
06:08:08 <erisco> what about me? I've gotta type out a Enum instance now
06:08:24 <geekosaur> and people would rather complain than, you know, propose that it actually be changed, preferably with a formal specification
06:08:33 <mauke3> if your constructors take arguments, it's not really an enum, isn't it?
06:08:49 <erisco> I don't know, I can enumerate all the values
06:08:51 <mauke3> s/n't//
06:08:57 <erisco> is there a different class for that?
06:09:04 <mauke3> I can enumerate all the strings, too
06:09:06 <liste> > (enumFromTo 1 10) :: Double
06:09:08 <lambdabot>      Couldn't match expected type ‘Double’ with actual type ‘[Integer]’
06:09:08 <lambdabot>      In the expression: (enumFromTo 1 10) :: Double
06:09:08 <mauke3> doesn't mean they're enums
06:09:28 <liste> > enumFromTo 1 10 :: [Double]
06:09:29 <erisco> I can just bake the Bool into my constructors and have twice as many
06:09:30 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
06:09:33 <erisco> I don't see the significance really
06:09:44 <mauke3> http://hackage.haskell.org/package/universe-1.0/docs/Data-Universe.html maybe
06:10:52 <erisco> why not enumerate all the strings?
06:11:08 <erisco> geekosaur, where do you send proposals?
06:11:21 <mauke3> I believe Enum is intended to model C-style enums
06:12:04 * geekosaur not actually sure. used to be the haskell-prime list but not clear that that list is doing anything any more... possibly start with libraries@
06:12:10 <erisco> I appreciate C, a lot to learn from C, I don't think C justifies how this should be done
06:12:26 <geekosaur> especially since it's probably more correct to get it into ghc first, then worry about the standards/report angle
06:12:40 <hodapp> C served a very important purpose. Like showing us that we shouldn't use C.
06:12:58 <erisco> well short of extending ghc (which sounds really difficult for a beginner) you could write some TH, I am guessing
06:13:06 <c_wraith> C amazes me in terms of how nearly every operation is potentially undefined behavior.
06:13:09 <mauke3> "Derived instance declarations for the class Enum are only possible for enumerations (data types with only nullary constructors)."
06:13:35 <c_wraith> It's incredibly difficult to write C that the spec declares will behave the same on every platform.
06:13:36 <mauke3> looks like the report uses "enumeration" to mean "a type whose definition enumerates all values"
06:13:42 <hodapp> c_wraith: Nah, the defined behavior is just that you blame the programmer for being clueless!
06:13:55 <erisco> the only type I can think of that you can't enumerate is ->
06:14:34 <dramforever> data T = A | B Bool
06:14:43 <dramforever> that doesn't look like it enumerated all values
06:15:06 <erisco> there are three values, you can print them all
06:15:19 <mauke3> you can enumerate it, but it's not an "enumeration" in the report sense because it doesn't lexically contain all possible values
06:15:22 <dramforever> "...whose *definition* enumerates...
06:15:23 <dramforever> "
06:15:26 <erisco> I don't see any significance reason to stop at nullary constructors
06:15:38 <erisco> yes yes report
06:15:45 <erisco> call this a challenge of the decision
06:16:06 <mauke3> color me meh
06:17:04 <erisco> is that closer to chartreuse or aubergine?
06:17:14 <Taneb> Beige, I think
06:19:30 <erisco> hm, oddly I don't think there is a way to specific a single bound
06:20:06 <erisco> also going to and from Int is an issue for unbounded enumerations
06:23:45 <erisco> I wonder if there is any particular reason they preferred Int over Integer
06:26:22 <mauke3> it's very unlikely you're going to write out a type with more than 42 constructors
06:27:06 <dramforever> hmm...that reminds me of a question I had
06:27:17 <dramforever> can ghc unbox enumerations into ints?
06:27:32 <erisco> if it was just about width then why not something even smaller
06:28:21 <dramforever> like if a .&. 1 then it's evaluated and it's the a `shiftR` 1 -th constructor
06:28:31 <dramforever> otherwise it's a pointer to a thunk
06:28:37 <mauke3> erisco: there are no smaller types
06:29:07 <mauke3> dramforever: I think it uses general pointer tagging
06:29:10 <erisco> are you saying it just widens Int8?
06:29:20 <mauke3> erisco: nah, Haskell98 didn't have Int8 AFAIK
06:29:24 <dramforever> mauke3: yes but why it's not happening?
06:29:30 <dramforever> I mean like my scheme
06:29:33 <erisco> oh, so a chronological thing
06:30:25 <mauke3> dramforever: hmm. how does the consuming code know whether the value belongs to an enumy type?
06:30:44 <dramforever> it's already typechecked
06:30:46 <dramforever> isn't it
06:31:23 * geekosaur not sure "unbox" is the right term/thing
06:31:33 * mauke3 considers seq and garbage collection
06:31:45 <geekosaur> since the boxed version is: enum is a constructor tag, Int is a constructor tag + the value
06:31:51 <dramforever> hmm...that's more interesting
06:32:12 <geekosaur> the latter's constructor gtag is fixed, but the former's is variable (i.e. corresponds to the value part of the latter)
06:32:13 <lf94> is there a function to do (\(Thing x) -> x) ?
06:32:34 <dramforever> if you used record syntax...
06:32:40 <lf94> ah
06:32:44 <geekosaur> or lens :)
06:33:16 <frerich> lf94: I think 'fromThing (Thing x) = x' wouldn't be too bad :-)
06:33:31 <lf94> why not use record syntax
06:33:43 <mauke3> dramforever: ok, I think this is possible
06:33:54 <dramforever> me too
06:35:09 <stm111> I am getting STM thread blocked indefinitely exception! I have many stms, is there a way where I can log which transaction is not hanging out
06:35:37 <lf94> how do you negate in haskell
06:35:39 <lf94> so like
06:35:48 <lf94> I have filter isLeaf xs
06:35:54 <lf94> i need... filter !isLeaf xs
06:35:55 <dramforever> :t not
06:35:56 <lambdabot> Bool -> Bool
06:36:01 <lf94> perfect B)
06:36:36 <mauke3> filter (not . isLeaf)
06:36:41 <mauke3> you can't negate functions
06:37:10 <lf94> i tried what you just did
06:37:14 <lf94> didn't work
06:37:40 <mauke3> "didn't work" is not a problem description
06:37:43 <frerich> lf94: I'm just guessing here - did you try 'filter (not isLeaf)'? Note that 'not' takes a plain Bool. Not a function.
06:37:44 <lf94> Couldn't match expected type `a0 -> [b0]` with actual type `[a1]`
06:37:55 <mauke3> what's the full error message?
06:38:02 <lf94> Oh. No I tried to compose them.
06:38:10 <lf94> Like mauke3 did...lol
06:38:39 <aweinstock> :t (not .)
06:38:40 <lambdabot> (a -> Bool) -> a -> Bool
06:39:03 <aweinstock> :t ((not .) .)
06:39:05 <lambdabot> (a -> a1 -> Bool) -> a -> a1 -> Bool
06:39:15 <lf94> :t filter (not .)
06:39:16 <lambdabot>     Couldn't match type ‘a -> Bool’ with ‘Bool’
06:39:16 <lambdabot>     Expected type: (a -> Bool) -> Bool
06:39:16 <lambdabot>       Actual type: (a -> Bool) -> a -> Bool
06:39:31 <aweinstock> what's the type of isLeaf?
06:39:41 <lf94> Tree2 a -> Bool
06:40:14 <frerich> Maybe that error message doesn't even get triggered by the 'filter' but by some other place in your code? It would be a lot easier to debug if there was some actual code/error to work with :-]
06:40:21 <MarcelineVQ> > filter (not . even) [1..10]
06:40:23 <lambdabot>  [1,3,5,7,9]
06:40:41 <MarcelineVQ> seems to compose just fine, there's probably more to your issue
06:40:45 <lf94> https://gist.github.com/lf94/8558d89d380f7a26fdad
06:40:48 <mauke3> "I can't even"
06:40:50 <lf94> line 51
06:40:59 <mauke3> <mauke3> what's the full error message?
06:41:45 <frerich> lf94: The first argument to concatMap should be a function, not a list.
06:41:46 <mauke3> 'case ... of otherwise -> ...' detected
06:41:54 <lf94> oh shit!
06:42:03 <lf94> gah, i guess midnight will do that to you.
06:42:12 <lf94> hanks frerich 
06:42:38 <dramforever> -Wall
06:42:41 <mauke3> lf94: line 56 should be '_ -> False'
06:42:44 <lf94> yep, that fixed it
06:43:00 <lf94> what's wrong with otherwise
06:43:19 <mauke3> lf94: Branches [ x | Branch xs' <- xs, x <- xs' ]
06:43:21 <dramforever> :t otherwise
06:43:21 <lf94> (and changed it)
06:43:22 <lambdabot> Bool
06:43:25 <dramforever> > otherwise
06:43:27 <lambdabot>  True
06:43:35 <mauke3> lf94: you're shadowing a predefined variable and then you're not even using it
06:43:37 <lf94> Ah
06:43:59 <mauke3> > case "hello" of otherwise : concatMap -> (concatMap, otherwise)
06:44:01 <lambdabot>  ("ello",'h')
06:44:04 <lf94> mauke3, why the generator
06:44:06 <dramforever> mauke3: if he *did* use it the it's going to be...um...
06:44:29 <lf94> array comprehension*
06:44:31 <mauke3> lf94: makes it easy to filter a list of things by a specific constructor
06:44:39 <mauke3> (list comprehension)
06:44:41 <dramforever> s/array/list
06:45:01 <lf94> aoeunthaoeu
06:45:03 <mauke3> lf94: the "Branch xs' <- xs" bit will automatically skip over Leafs
06:45:19 <lf94> Yes, that's the whole reason why I have this filter business
06:45:24 <lf94> nice trick
06:45:40 <frerich> lf94: You might also like the 'partition' function to avoid filtering twice.
06:45:47 <lf94> Isn't that less efficient though
06:45:59 <lf94> @ creating a new xs'
06:46:27 <dramforever> no it's not
06:46:47 <dramforever> wait why don't we check ghc core for free (ducks
06:46:49 <dramforever> )
06:47:05 <lf94> i'm just saying, you're creating a copy of the structure...
06:47:14 <mauke3> lf94: no, that basically boils down to concatMap
06:47:15 <lf94> well, i guess we are for filter too
06:47:35 <mauke3> @undo Branches [ x | Branch xs' <- xs, x <- xs' ]
06:47:35 <lambdabot> Branches (concatMap (\ a -> case a of { Branch xs' -> concatMap (\ x -> [x]) xs'; _ -> []}) xs)
06:47:41 <lf94> :t partition
06:47:42 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
06:47:48 * hackagebot hackage-security-HTTP 0.1.0.2 - Hackage security bindings against the HTTP library  https://hackage.haskell.org/package/hackage-security-HTTP-0.1.0.2 (EdskoDeVries)
06:47:50 * hackagebot hackage-repo-tool 0.1.0.1 - Utility to manage secure file-based package repositories  https://hackage.haskell.org/package/hackage-repo-tool-0.1.0.1 (EdskoDeVries)
06:47:52 * hackagebot hackage-security 0.3.0.0 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.3.0.0 (EdskoDeVries)
06:47:53 <lf94> Ouuu, that looks useful.
06:49:52 <frerich> lf94: I'm not quite sure what you're trying to do exactly, but maybe you don't want to filter out leafs (leaves?) in the first place but rather have bfsTree2 pattern-match on 'Leaf' values?
06:50:06 <^o_0-> ohai
06:50:32 <lf94> frerich, it's just breadth first search
06:50:43 <mauke3> btw, there's a neat trick for matching on constructors only, regardless of how many parameters they have: case ... of Leaf{} -> ...
06:50:46 <lf94> Using a branch / leaf distinction
06:51:13 <mauke3> > case 0 == 1 of False{} -> "cool"
06:51:14 <lambdabot>  "cool"
06:51:23 <mauke3> > case Just 42 of Just{} -> "cool"
06:51:25 <lambdabot>  "cool"
06:51:37 <^0_o^> is there a way to use custom types with unique constraint in persistent?
06:51:49 <^0_o^> all I get is a error that says '      Unknown column in unique constraint: "IPRange"
06:51:56 <mauke3> > case "abc" of (:){} -> "cool"
06:51:57 <lambdabot>  "cool"
06:52:03 <mauke3> ... I didn't know you could do that
06:52:17 <dramforever> wow TIL
06:52:50 <mauke3> :t let null' []{} = True; null' _ = False in null'
06:52:51 <lambdabot> [t] -> Bool
06:53:15 <mauke3> I'm getting a C++ "lambda" vibe
06:53:48 <dramforever> [](){}();
06:54:21 <bq> what does that mean?
06:54:45 <mauke3> (FUNCALL (LAMBDA ()))
06:54:49 <mniip> [([]{})]
06:54:55 <mniip> close enough
06:54:59 <dramforever> creating a lambda that doesn't take anything from the environment
06:55:03 <dramforever> and doesn't take a value
06:55:12 <dramforever> and calling it.
06:55:15 <dramforever> i.e. no-op
06:55:26 <mauke3> more commonly seen in javascript as (function () {})();
06:57:06 <mniip> (\_->())()
06:57:57 <aweinstock> :t (\_->())()
06:57:59 <lambdabot> ()
06:58:22 <mniip> [15:44:30] <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
06:58:38 <mniip> I just came up with a neat function
06:59:38 <mniip> :t index
06:59:39 <lambdabot> Ix a => (a, a) -> a -> Int
07:00:04 <mniip> :t Data.Key.index
07:00:05 <lambdabot>     Not in scope: ‘Data.Key.index’
07:00:05 <lambdabot>     Perhaps you meant one of these:
07:00:05 <lambdabot>       ‘Data.Ix.index’ (imported from Data.Ix),
07:00:16 <mniip> aw
07:02:54 <mniip> :t Data.Functor.Rep.index
07:02:55 <lambdabot> Data.Functor.Rep.Representable f => f a -> Data.Functor.Rep.Rep f -> a
07:07:55 <mniip> :t \p xs -> Data.Functor.Rep.tabulate (\k -> filter ((k ==) . p) xs)
07:07:56 <lambdabot> (Eq (Data.Functor.Rep.Rep f), Data.Functor.Rep.Representable f) => (a -> Data.Functor.Rep.Rep f) -> [a] -> f [a]
07:11:07 <mniip> next you instantiate (a ~ b) => Representable (a, b) where type Rep = Bool
07:11:26 <mniip> and you have partition!
07:20:41 <erisco> Illegal data constructor name: `fromList'
07:20:48 <erisco> When splicing a TH expression
07:20:50 <erisco> what is this about?
07:21:33 <mniip> you've tried to use "fromList" as a datacon
07:22:04 <erisco> this is coming straight from derived Data
07:22:28 <mniip> paste
07:24:15 <erisco> Data.Set.Base.fromList
07:25:16 <mniip> no, paste your code
07:27:33 <erisco> my code isn't making it
07:28:51 <midumoh> interesting...
07:29:09 <byorgey> erisco: can you paste your code anyway?
07:29:45 <erisco> it is too long, I'll have to make a smaller reproduction
07:30:28 <erisco> Data.Set.Base.fromList ((GHC.Types.:) 'A' GHC.Types.[])
07:30:58 <erisco> that is the subexpression trying to be spliced
07:31:26 <byorgey> that is a perfectly valid expression.  Where is it being spliced?
07:31:35 <byorgey> i.e. why does GHC think fromList needs to be a data constructor?
07:34:39 <erisco> (Data.Maybe.Just (Data.Set.Base.fromList ((GHC.Types.:) 'A' GHC.Types.[])))
07:34:44 <erisco> I will paste the whole expression
07:35:01 <erisco> http://lpaste.net/139626
07:36:19 <chpatrick1> man I figured out a reasonable way to encode higher kinded typeclasses in java but it's been done already: https://github.com/DanielGronau/highj
07:36:30 <mniip> erisco, is this your own TH code
07:37:12 <erisco> this is the extent of my TH code  [|patternToRegex $patternExp $compOptsExp $execOptsExp|]
07:37:49 <mniip> no I mean
07:37:59 <mniip> who produces the ast
07:38:07 <erisco> it is derived from Data
07:38:25 <mniip> hmm?
07:38:34 <erisco> {-# LANGUAGE DeriveDataTypeable #-}
07:39:08 <mniip> since when does that use TH
07:39:27 <erisco> I don't understand your question
07:39:41 <mniip> ugh
07:39:57 <mniip> you have a problematic th splice
07:40:37 <mniip> th splices turn asts into code
07:40:45 <erisco> @hoogle dataToExpQ
07:40:45 <lambdabot> Language.Haskell.TH.Quote dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp
07:40:54 <mniip> where does the ast come from
07:40:58 <erisco> ^
07:41:45 <mniip> more specificly?
07:41:50 <erisco> that is all there is
07:42:01 <byorgey> erisco: and what is $patternExp in your TH splice?
07:42:05 <mniip> how is it being used
07:42:06 <erisco> you derive Data for the type, then you call dataToExpQ on a value of that type
07:42:19 <erisco> then you get an AST
07:42:21 <mniip> right
07:42:25 <erisco> it is being used in the splice I gave
07:42:35 <mniip> how
07:42:44 <byorgey> erisco: I suspect you are trying to use the generated Exp as a pattern
07:42:55 <mniip> no
07:43:19 <erisco> <mniip> hmm?
07:43:20 <mniip> this seems like a dataToExpQ issue
07:43:22 <erisco> why clipboard
07:43:27 <erisco> patternExp = dataToExpQ (const Nothing) pattern
07:43:28 <mniip> just not clear which
07:43:49 <erisco> byorgey, is that not intended use?
07:44:45 <byorgey> well, if the generated Exp involves fromList, then it is clear that it cannot be used as a pattern.
07:44:59 <byorgey> e.g. you can't write    f (fromList ('A':[])) = ...
07:45:20 <erisco> it isn't a pattern splice
07:46:34 <erisco> pattern splices are [p|...|] but I am using [|...|] which is the same as [e|...|] which is for expressions
07:47:11 <voidzero> Anyone here who uses vim-haskellConcealPlus from a terminal?
07:47:15 <byorgey> ah, sorry, I was thrown off by the word "pattern" in the variable names
07:47:16 <erisco> the name "pattern" of my variable is unrelated, it is what they call the AST of a regular expression in TDFA
07:47:23 <byorgey> right, I see now
07:47:24 <voidzero> I can't find a font that works properly for all chars
07:47:54 <erisco> I'll just push this package update up and report the issue
07:50:24 <erisco> it only happens if you try and use character classes in your regular expressions (that I've found so far)
07:50:29 <erisco> unfortunately that is common :P
07:52:01 <erisco> btw, it would be amazing if you could reify functions
07:52:22 <erisco> which should be possible
07:53:04 <erisco> you'd have to deal with imported functions from compiled modules
07:53:45 <mniip> erisco, you can reify functions
07:54:09 <erisco> how? because deriving Data chokes on them
07:54:44 <mniip> Data.Reflection
07:57:23 <substance> ||||| >>>>> WHAT IS YOUR DOMAIN NAME WORTH? Vist >>> www.VALBOT.com <<< FREE DOMAIN VALUATION! or Google >>> VALBOT.com <<< |||||
07:58:08 --- mode: ChanServ set +o mauke3
07:58:12 --- kick: substance was kicked by mauke3 (substance)
07:59:36 <ely-se> "Vist"
07:59:51 <hiptobecubic> what an ironic bot name
08:00:25 --- mode: mauke3 set -o mauke3
08:00:28 --- mode: ChanServ set +o mauke3
08:00:32 --- mode: mauke3 set -o mauke3
08:00:33 <ely-se> hipto gonna be cubic
08:00:55 <erisco> mniip, I see reifyNat, reifySymbol, reifyTypeable
08:01:07 <mniip> :t reify
08:01:08 <lambdabot> Not in scope: ‘reify’
08:01:27 <mniip> :t Data.Reflection.reify
08:01:29 <lambdabot> a -> (forall s. Data.Reflection.Reifies s a => Proxy s -> r) -> r
08:01:29 <tero-> stack question, "Build plan did not match your your requirements (lts-3.2), glpk-hs not found". how can I add this? 
08:01:39 <erisco> yeah, I'm looking at that
08:03:06 <mniip> reify not reflect True
08:03:30 <tero-> ah, extra-deps. solved
08:07:23 <tsahyt> Why is the complexity of Data.IntMap.Lazy.alter not the same as that of Data.IntMap.Strict.alter? The lazy version says O(min(n,W)) and the strict one says O(log(n)). Is that an error in the documentation? Except for a few `seq`s the code seems to be the same.
08:08:13 <tsahyt> That's in containers-0.5.6.2 by the way
08:10:15 <erisco> mniip, I can safely say I do not understand
08:10:31 <erisco> :t Data.Reflection.reify not
08:10:32 <lambdabot> (forall s. Data.Reflection.Reifies s (Bool -> Bool) => Proxy s -> r) -> r
08:10:40 <mniip> i'ts okay
08:10:46 <mniip> i don't either
08:10:46 <erisco> and somehow it knows from the type the definition of 'not'?
08:11:03 <erisco> clearly that can't be so, so what is actually happening
08:11:26 <mniip> yes it can
08:11:35 <erisco> where
08:11:38 <erisco> where is it
08:11:47 <mniip> but the package doesn't do that
08:11:53 <erisco> I see Bool -> Bool
08:12:02 <mniip> it uses a hack instead
08:12:39 <mniip> to provide a dictionary with unsafeCoerce
08:13:03 <erisco> "The argument passed along by reify is just a data Proxy t = Proxy"
08:13:09 <erisco> where is the dict then
08:13:13 <mniip> don't worry though, it's safe since it's a kmett package
08:13:37 <mniip> in the s
08:13:51 <edwardk> erisco: reflection relies on somewhat tricky tooling
08:14:04 <edwardk> :t Data.Reflection.reify
08:14:05 <lambdabot> a -> (forall s. Data.Reflection.Reifies s a => Proxy s -> r) -> r
08:14:11 <mniip> s is a universally quantified type with a constraint
08:14:17 <edwardk> :t Data.Reflection.reflect
08:14:18 <lambdabot> forall (k :: BOX) (s :: k) a (proxy :: k -> *). Data.Reflection.Reifies s a => proxy s -> a
08:14:24 <erisco> they were going to call it "safeForKmettCoerce" but it was a bit too wordy
08:14:32 <mniip> gotta pass the dictionary
08:14:34 <edwardk> lets just consider those as functions and read (=>) as (->) for a second
08:16:09 <edwardk> then we could write reflect = id; reify a f = f (const a) Proxy
08:16:17 <edwardk> but this requires us to pass 'const a' as a -dictionary-
08:16:21 <edwardk> for Reifies s a
08:16:39 <edwardk> so reflection has to make up an instance of Reifies s a   on the spot
08:16:52 <edwardk> it does so by exploiting the representation of a dictionary that has only one slot in it inside core
08:16:58 <edwardk> and by using unsafeCoerce
08:17:16 <edwardk> surprisingly this representation is quite portable and works on GHC back to the stoneage, and even on Hugs
08:17:35 <edwardk> before that we had another, more principled, form of reflection
08:17:44 <edwardk> that one didn't require this sort of magic
08:17:52 <sdegutis> Can you have circular dependencies in Haskell/GHC?
08:18:09 <edwardk> sdegutis: hs-boot files let you do it, i don't recommend it
08:18:25 <exio4> sdegutis: you can with GHC, but it's kinda of a mess, I would move the code such that it is not needed
08:18:26 <sdegutis> In general it's a bad idea?
08:18:32 <sdegutis> Ah I see. Thanks.
08:18:32 <edwardk> sdegutis: correct
08:19:13 <edwardk> anyways the old form of reflection was about 3 orders of magnitude slower. the current one is no more expensive than calling a function
08:19:24 <aweinstock> what's the (k :: BOX) thing in the above signatures? (I also remember seeing it when asking lambdabot ":t (>>>)", but that doesn't show up in the source/documentation for Control.Category on hackage)
08:19:55 <edwardk> aweinstock: reflection is set up to be "PolyKinded" so that 's' in Reifies s a may have any kind you want
08:20:06 <geekosaur> it's saying that k is a kind. (the next level above kinds is sorts; the only sort ghc knows about is BOX)
08:20:08 <edwardk> this lets us have Reifies 4 Integer   just work 
08:20:18 <geekosaur> so, a polymorphic kind
08:20:26 <edwardk>  forall (k :: BOX) (s :: k) a (proxy :: k -> *). Data.Reflection.Reifies s a => proxy s -> a
08:20:40 <edwardk> says k is a kind, s has kind k, and proxy has kind k -> *
08:20:46 <aweinstock> "sorts" are "types-of-types-of-types"?
08:20:50 <geekosaur> yes
08:21:29 <edwardk> aweinstock: yes, though the word 'sort' is a bit contentious for that role. in a pure type system sorts are the different levels of 'type, kind' etc. rather than one level just above kind
08:21:58 <edwardk> e.g. type is a sort, kind is a sort.   a better term would be superkind, but meh
08:22:32 <edwardk> since the whole thing is changing and we're getting one level, * with * :: * due to eisenberg's work, it doesn't matter much
08:23:39 <exio4> edwardk: are there news on that change?
08:24:01 <aweinstock> what's the difference between ((k :: BOX) (s :: k) (proxy :: k -> *)) vs (proxy :: * -> *)?
08:25:14 <aweinstock> (or is it the same by itself, but it binds the "s" to be used elsewhere)?
08:26:08 <edwardk> instance KnownNat n => Reifies n Integer
08:26:17 <edwardk> KnownNat :: Nat -> Constraint
08:26:29 <edwardk> i need n to be able to be a type level nat
08:26:35 <edwardk> same with KnownSymbol :: Symbol -> Constraint
08:26:48 <edwardk> with that then Reifies 5 Integer  holds
08:27:43 <erisco> I don't get it still, but it is interesting
08:27:58 <edwardk> now with a library like hyperloglog   you can use blah :: HyperLogLog 8 with a compile-time constant or you can use reify 8 $ \(_ :: Proxy s) -> blah :: HyperLogLog s)  to use a runtime value for the size of the hyperloglog structure
08:28:07 <Xe> in haskell, how would I see if a given IP is inside a given CIDR mask? for example "8.8.8.8" being in the range "8.0.0.0/8"
08:28:42 <erisco> but the question is, can I somehow use this to fix the problem of deriving Data failing on functions? I don't see how it is relevant
08:30:24 <edwardk> Xe: convert y=8.8.8.8 to a 32 bit integer, convert the CIDR x/n to a 32 bit integer and the n to a mask  m = shiftL 0xffffffff (32 - n)    (.&.) the address with the mask and check against x for equality
08:30:39 <edwardk> erisco: there is no Data instance there
08:31:05 <edwardk> Data gives no sensible operation for functions today
08:31:05 <Xe> edwardk: i'd do the same for ipv6 except with a 128 bit number?
08:31:13 <edwardk> xe: yes
08:31:46 <edwardk> a CIDR is just a prefix of an address and a # of bits in the prefix
08:32:10 <Xe> edwardk: will that handle things like 8.8.8.8/8 ?
08:32:24 <edwardk> 8.8.8.8/8 isn't a legal CIDR
08:33:14 <edwardk> you can check the CIDR is legal by making the mask and anding itself with the mask, if it isn't equal to itself it has set bits outside of the mask
08:34:25 <edwardk> the above procedure will always fail to match any such illegal CIDR, which is good ;)
08:34:33 <Xe> hmm
08:34:48 <Xe> what if I wanted to simplify an illegal cidr into a legal one?
08:34:59 <edwardk> then you just and it with the mask and call it good
08:35:02 <SrPx> How do I blit a small sprite in a REPA array if there is nothing like "Data.Vector.update"?
08:35:06 <erisco> edwardk, can you write my program too? :)
08:35:12 <edwardk> erisco: =P
08:35:16 <Xe> well
08:35:18 <Xe> to be fair
08:35:33 <erisco> Xe, I am just having a tease
08:35:35 <Xe> I forgot that IP's were just bitmasks
08:35:45 <Xe> I've gotten 4 hours of sleep
08:35:50 <edwardk> CIDRs are kinda boring.
08:36:12 <edwardk> long ago I used to care about networking stuff, this was a fun way to jog my memory =P
08:36:51 * edwardk used to have an ISP to keep running and for a while wrote embedded systems code for routers.
08:37:29 * Taneb used to be about to write a Haskell blog
08:37:40 <Taneb> Got a domain and hosting and everything
08:37:44 <Taneb> And then never bothered :(
08:38:45 <edwardk> Taneb: if i judged myself by all the things I was once 'about to do' I'd lose myself in drink. ;)
08:39:41 <Taneb> edwardk, I solve that problem by once being about to learn how to enjoy alcohol
08:39:48 <Taneb> And then never bothering
08:42:00 <d-snp> I registered a domain for hosting a ruby-toolbox like site for haskell
08:42:12 <d-snp> haven't gotten around to it yet :(
08:42:52 <Taneb> Had an idea for a short blog series about a maze generator I wrote, I could do that
08:43:00 <Taneb> In fact I will!
08:43:02 <Taneb> Tonight!
08:43:05 <d-snp> no not tonight
08:43:06 <d-snp> now
08:43:22 <Taneb> I'm at work
08:43:27 <Taneb> For another 17 minutes
08:43:29 <d-snp> .. are you being watched?
08:43:32 <edwardk> I started a couple hundred projects threw them on github and each time said 'some day i'll go back and finish that one'  =)
08:43:44 <mauke3> FINISH HIM
08:44:04 <Taneb> d-snp, there's a deadline looming and I don't want to get distracted
08:44:23 <d-snp> says the guy chatting in #haskell
08:44:30 <zomg> edwardk: I think about 75% of things I start end up like that :P
08:44:31 <Taneb> Yeah, I'm pretty bad at this
08:44:32 <d-snp> is your deadline in haskell? :P
08:44:38 <Taneb> No, it's in documentation
08:45:00 <Taneb> Which I historically struggle with
08:45:06 <d-snp> I have a deadline too though... orchestrating payments in Ruby..
08:45:30 <d-snp> I have a function called #payment_due_in_nickels
08:45:33 <d-snp> would you believe that?
08:45:55 <Taneb> Do you...
08:46:02 <Taneb> Do you actually need to know that?
08:46:03 * geekosaur sends d-snp a wooden nickel
08:47:35 <d-snp> Taneb: yes.. we have to charge in multiples of 5ct, because our payment gateway messes things up otherwise
08:47:42 <Taneb> !!!
08:47:49 <d-snp> (i.e. it's not even that we actually need physical nickels)
08:48:51 <d-snp> I forgot what the actual problem was
08:49:20 <d-snp> something to do with that it overcharges people if they spend less than a nickel or something..
08:49:38 <Taneb> That's ridiculous
08:50:12 <d-snp> yes, and we definitely should switch to Stripe, but no time now as there's a deadline..
09:03:04 <erisco> d-snp, Stripe is slipping you bank notes eh?
09:04:27 <d-snp> they're sending me all the nickels they got to make me advertise in #haskell, their toughest market ;)
09:05:24 <d-snp> I mean they just dream of one day serving all those Haskell consumer facing credit card charging web apps :D
09:06:30 <d-snp> Taneb: is your blog post done yet?
09:13:46 <erisco> if anyone could explain to me why my ASCII table didn't work I'd be grateful http://hackage.haskell.org/package/regex-tdfa-quasiquoter-0.1.0.0/docs/Text-Regex-TDFA-QuasiQuoter.html
09:14:03 <erisco> the pipes packages have these beautiful ASCII diagrams but I can't make Haddock behave the same
09:15:00 <mauke3> looks like \ is the haddock escape character
09:15:13 <mauke3> each instance of \\ in the source renders as one \
09:15:18 <erisco> yeah I had issues with that, but I doubled them all up
09:15:39 <mauke3> but you didn't match the spaces
09:15:42 <erisco> also the line -- |~]       | |]      should be fine
09:15:50 <erisco> mauke, look at the source
09:15:55 <erisco> oh I see what you mean
09:15:57 <erisco> haha
09:16:00 <mauke3> \ is shorter than \\
09:16:00 <erisco> right
09:16:05 <erisco> well that is dumb
09:16:19 <erisco> so not only if you read the source is the table wrong with respect to backslashes
09:16:24 <erisco> but it will also be formatted incorrectly
09:16:33 <erisco> can I make Haddock not ruin me?
09:17:03 <tsahyt> Is there a way to provide a custom error message for when an irrefutable pattern fails?
09:17:24 <tsahyt> Other than providing a foo _ = error ".." that is
09:18:01 <geekosaur> none I'm aware of
09:26:54 <Testing0011> ?
09:27:31 <Testing0011> this irc looks very quiet :D 
09:27:58 <johnw> tsahyt: have you seen http://www.haskellforall.com/2015/01/total-100-exhaustive-pattern-matching.html?
09:29:19 <johnw> even though that's not really what you asked for
09:30:23 <Testing0011> I just saw that link haskellforall , looks very complicated to be read by a beginner in Haskell like me 
09:30:34 <mauke3> Testing0011: it depends a lot on the time of the day
09:30:50 <mauke3> channel activitiy, I mean. not how complicated haskell is :-)
09:31:52 <tsahyt> Other than providing a foo _ = error ".." that is
09:32:02 <tsahyt> wrong window sorry
09:32:06 <tsahyt> I meant to repeat a shell command
09:32:40 <johnw> Testing0011: it might be too complicated for anyone to want to use in practice
09:33:02 <Testing0011> Haskell is not complicated, however you can write a code that does the same functionalities in many many different way in Haskell
09:33:08 <tsahyt> johnw: Thank you, this looks interesting, although it's probably overkill in my case.
09:33:32 <johnw> there's also -XSafe, which is annonying in its own way; or -Wall -Werror
09:33:48 <Testing0011> even in ways I never heard about using a new Syntax to me but stills HAskell 
09:34:12 <Welkin> johnw: isn't -Werror on by default?
09:34:19 <johnw> goodness no
09:34:26 <tsahyt> Testing0011: I find Haskell98 to be a very simple language. Cutting edge GHC Haskell can get quite mind boggling though.
09:34:33 <johnw> if it were, probably all of Hackage would pop out of existence
09:35:29 <Welkin> really?
09:35:37 <Welkin> I tend to compile with -Wall
09:35:54 <johnw> the 7.8 to 7.10 move made most imports of Control.Applicative a harmless warning
09:36:18 <johnw> if Werror were the default, that would mean you couldn't use a huge part of hackage, until the authors put in CPP conditionals
09:36:44 <johnw> (I guess, assuming they had also use -Wall)
09:36:45 <Welkin> I see
09:37:05 <sedeki> in "Hitchhikers guide to Haskell", what is meant by "layout is 2-dimensional" ?
09:37:22 <Testing0011> today I solved this problem correctly (**) Flatten a nested list structure.  Transform a list, possibly holding lists as elements into a `flat' list by replacing each list with its elements (recursively). After that, I looked at the 4 provided solutions i didn't understand any they used a new syntax to me and keywords
09:37:40 <sedeki> does it mean you cannot necessarily increment a pointer to another variable?
09:37:43 <keko_> sedeki: in what context?
09:37:56 <sedeki> https://wiki.haskell.org/Hitchhikers_guide_to_Haskell
09:38:02 <sedeki> in bold
09:38:25 * hackagebot HPDF 1.4.7 - Generation of PDF documents  https://hackage.haskell.org/package/HPDF-1.4.7 (alpheccar)
09:38:34 <mauke3> sedeki: that's about formatting your source code
09:38:44 <keko_> I'd guess it means that it matters how code is positioned
09:38:45 <sedeki> hehe
09:38:50 <sedeki> sorry guys.
09:38:58 <mauke3> specifically, haskell cares what lines up with other things
09:39:07 <Welkin> sedeki: whitespace matters
09:39:09 <mauke3> most other languages don't care
09:39:23 <Welkin> you can disable whitespace, though, using { and }
09:40:27 <aweinstock> Testing0011: do you have a link to the description of that? "a list, possibly holding lists as elements" sounds like a tree, and that sounds it would be phrased that way in a lisp course
09:41:01 <Testing0011> https://wiki.haskell.org/99_questions/1_to_10 
09:41:10 <Testing0011> question number 7
09:41:25 <aweinstock> (in haskell, you can't do lists with mixed nesting, and would explicitly need "data Tree a = Leaf a | Branch [Tree a]"
09:41:28 <Gurkenglas> Testing0011: "A list possibly holding lists"? That sounds like heterogenous lists... what is the type signature of the function you are supposed to implement?
09:41:42 <aupiff_> in stack, why are things listed under "packages" with the field "extra-dep: true" tested? Is there a way to avoid this?
09:42:01 <aweinstock> oh, that's exactly what it does
09:42:39 <SrPx> Does anyone have a template for creating a simple OpenGL application using raw? Just a simple example, a hello world with trigs, would do
09:42:45 <sedeki> has anyone tried Haskell for Mac?
09:42:47 <tsahyt> Gurkenglas: The example defines a new type for that, NestedList a = Elem a | List [NestedList a]
09:42:51 <kadoban> aupiff_: … not sure which part of that you're trying to avoid?
09:42:55 <kadoban> (or why?)
09:42:57 <Welkin> SrPx: raw?
09:43:22 <aupiff_> kadoban: I want to avoid the testing of things marked "extra-deps: true"
09:43:22 <Testing0011> Gurkenglas thnx I just solved that, when I looked a the provided answered I couldn't really understand. I do need to read more about Haskell
09:43:28 <SrPx> OpenGL raw, I just want to raster an unboxed vector contents to the screen, so I need OpenGL
09:43:40 <ReinH> Testing0011: Can you show how you flattened a list with arbitrary nesting depth? In fact, can you show the type that such a list has?
09:43:41 <Welkin> SrPx: I have a basic setup with gl https://github.com/ericnething/gl-sdl2-basics
09:43:54 <kadoban> aupiff_: Oh I see, sorry I misread.
09:43:54 <Welkin> gl has a nicer API than the OpenGL bindings
09:44:06 <ReinH> Testing0011: or do you just mean [[a]]?
09:44:14 <ReinH> As in, a list that either contains lists or is empty
09:44:20 <SrPx> Welkin: thanks <3 <3
09:44:54 <mpickering> aupiff_: You have some stuff coming from git repos for example?
09:44:56 <mauke3> ReinH: <tsahyt> Gurkenglas: The example defines a new type for that, NestedList a = Elem a | List [NestedList a]
09:45:10 <mpickering> do you have the extra-dep: true field set?
09:45:11 <ReinH> Ah, so indeed a tree.
09:45:12 <aupiff_> mpickering: yep
09:45:44 <aweinstock> @let data NestedList a = Elem a | List [NestedList a]
09:45:44 <lambdabot>  .L.hs:169:1:
09:45:45 <lambdabot>      Multiple declarations of ‘NestedList’
09:45:45 <lambdabot>      Declared at: .L.hs:166:1
09:45:51 <aweinstock> @let myflatten (Elem x) = [x]; myflatten (List xs) = concat (map myflatten xs)
09:45:53 <lambdabot>  .L.hs:174:1: Warning:
09:45:53 <lambdabot>      Pattern match(es) are overlapped
09:45:53 <lambdabot>      In an equation for ‘myflatten’:
09:45:59 <Testing0011> I did really use any type, I just revered the list then used rec to recursive the definition
09:46:34 <mauke3> Testing0011: what
09:46:39 <Testing0011>  rec m(List (x:xs)) = rec (rec m x) (List xs)
09:46:41 <mpickering> aupiff_: I think you need both extra-deps: true and extra-dep: true on each dependency you pull in
09:46:51 <mauke3> Testing0011: what language is that?
09:48:01 <mauke3> ok, it's haskell :-)
09:49:33 <mauke3> Testing0011: what is m for?
09:50:54 <ReinH> mauke3: nothing, apparently?
09:51:09 <aupiff_> mpickering: I didn't relize both those two options existed.
09:51:21 <ReinH> :t let rec m(List (x:xs)) = rec (rec m x) (List xs) in rec
09:51:22 <lambdabot> t -> NestedList t1 -> t
09:51:42 <ReinH> well, it's missing a definition
09:51:47 <tsahyt> ReinH: https://wiki.haskell.org/99_questions/Solutions/7
09:52:15 <tsahyt> flatten4 on this page has a similar recursive case
09:52:50 <ReinH> ok, it's foldTree (:)
09:53:07 <ReinH> Foldable.foldr (:), that is
09:53:28 <aupiff_> mpickering: where did you see that extra-deps and extra-dep are both options? It doesn't seem to work for me.
09:54:11 <mpickering> https://github.com/alanz/HaRe/blob/wip/stack-travis.yaml
09:54:41 <ReinH> It's rather annoying that the most generic solution (defining a fold for the structure) isn't offered. :(
09:55:13 <aupiff_> mpickering: oh, I see! you mean I need to list the libraries in extra-deps as well
09:55:31 <mpickering> I don't actually use stack but that's how Alan fixed the problem when we were having it
09:55:39 <mpickering> so I hope it works for you as well!
09:57:20 <aupiff_> mpickering: gotchya, thanks.
09:57:40 <tsahyt> So since my question kinda drowned earlier on, I think I'll give it another shot. Are the complexities for alter :: (Maybe a -> Maybe a) -> Key -> IntMap a -> IntMap a really different for lazy and strict IntMaps? The documentation lists O(log(n)) for strict and O(min(n,W)) for lazy, but I can't see any meaningful difference in implementation, so I suspect that this is actually an error in the docs, which 
09:57:46 <tsahyt> should probably get reported
09:58:46 <geekosaur> you might want to raise that on the libraries list
10:00:54 <tsahyt> geekosaur: I thought containers was independently maintained?
10:01:08 <felixsch> a lens question: is there a way to use a monadic action in (%=). I want something like ... (a -> m a) -> m ()
10:01:44 <geekosaur> tsahyt, it is but they use the same list, more or less, rather than have their own
10:02:40 <Gurkenglas> felixsch: Is that the complete type signature? (a -> m a) -> m () has the only inhabitant "const $ return ()"
10:02:43 <tsahyt> geekosaur: I'll post it as an issue on the containers github repo, that's easier for me right now. As far as I can tell it should be the same complexity.
10:02:47 <geekosaur> it's a bit complex also since it does *relate* to libraries, and in fact to ghc itself
10:03:20 <Gurkenglas> (Umm, prepend "Monad m =>" to the signature, of course)
10:03:20 <felixsch> Gurkenglas: http://ekmett.github.io/lens/Control-Lens-Setter.html#v:-37--61-
10:03:26 * hackagebot aeson-schema 0.4.0.0 - Haskell JSON schema validator and parser generator  https://hackage.haskell.org/package/aeson-schema-0.4.0.0 (MateuszKowalczyk)
10:06:03 <byorgey> felixsch: that seems ill-defined, since running a monadic action in the middle of the traversal could change what things exist to be traversed over in the first place
10:06:32 <byorgey> felixsch: what is it you're trying to do?
10:06:34 <geekosaur> I also wonder if it's something subtle, like balance has different time complexity
10:07:09 <tsahyt> Great, now I feel bad for not simply submitting a patch directly, since it's such a minor issue.
10:07:23 <felixsch> byorgey: mhm you're absolutly right. never tought sofar... I want run a IO action (gtk...) on a GtkWindow. the window is in the state
10:14:58 <jbalint> what's the deal with single-field records?
10:16:24 <chattered> jbalint: They automatically come with a function (named for the record field) that unwraps that field. 
10:17:01 <jbalint> chattered: this is convenient?
10:18:04 <chattered> jbalint: Yeah. newtype WrappedFoo = WrapFoo { unwrapFoo :: Foo }. And now to convert WrappedFoo to Foo, I just use "unwrapFoo".
10:18:37 <jbalint> chattered: got it. thx
10:19:52 <aweinstock> would it make sense for newtypes to implement Functor, with "fmap f = WrapFoo . f . unwrapFoo"?
10:20:45 <Clint> aweinstock: you can derive that automatically
10:21:24 <chattered> aweinstock: A functor has to have kind * -> *. WrappedFoo has kind *.
10:22:05 <chattered> But if Foo is a functor, then with newtype WrappedFoo a = WrapFoo { unwrapFoo :: Foo a }, the functor instance is trivial (and automatically derivable)
10:35:50 <ReinH> felixsch: perhaps something in https://hackage.haskell.org/package/lens-3.3/docs/Control-Lens-Action.html, but I've never used it
10:40:03 <felixsch> ReinH: Yes this looks actually nice.
10:40:42 <ReinH> surprisingly ok!
10:45:02 <johnw> felixsch: as of lens 4, that stuff is in a separate package now: http://hackage.haskell.org/package/lens-action
10:45:04 <bennofs> felixsch, ReinH that's an old link
10:47:09 <felixsch> ah thanks
10:47:55 <jgt> hey folks
10:48:15 <jgt> is there a way to match against a list containing exactly 16 items?
10:48:20 <jgt> (without writing it out the long way)
10:48:36 <ReinH> Damn, so it is
10:48:41 <Ankhers> Use a guard and use length xs == 16?
10:48:59 <jgt> Ankhers: that sounds about right. I'll give it a try; thanks!
10:49:44 <byorgey> jgt, Ankhers: there is one subtle difference, which is that using a guard and length xs == 16 will go into an infinite loop for infinite lists, whereas matching a length-16 list pattern will not
10:49:55 <byorgey> also if the list is very long, computing its length might be inefficient
10:50:06 <ReinH> I'd ask why you need to do that in the first place
10:50:07 <Ankhers> That's true.
10:50:10 <byorgey> but if you don't care about those things, length xs == 16 is what I would do
10:50:10 <ReinH> it's not a very idiomatic use of lists
10:51:47 <Ankhers> If you care about the infinite list scenario, you could write a function that combines both length and equals.
10:52:03 <bennofs> byorgey: for those cases, I usually use not . null . drop 16
10:52:07 <jgt> the task is fairly text-book; validate a credit card number
10:52:17 <bennofs> byorgey: eh, sorry, that ofc doesn't work
10:52:32 <bennofs> byorgey: but length (take 17 xs) == 16 does :)
10:52:39 <byorgey> bennofs: nice =)
10:52:54 <jgt> if the user inputs a 16-digit number, continue with the validation logic, otherwise just fail
10:53:07 <jgt> I'm going to start simple ;)
10:53:48 <byorgey> for a completely overengineered solution, you could implement a lazy Peano natural type, then use  genericLength xs == toNatural 16  =)
10:54:17 <monochrom> the user is unlikely to input an infinite string
10:54:24 <darenthis> Got a question about MVars vs State. I think I'm abusing an MVar here: http://lpaste.net/3116011409041784832 as it is only accessed by a single thread. I think I should be able to use the State monad but they confuse me. Am I right?
10:54:41 <monochrom> but the user is likely to attempt a DoS by inputting a very, very long string
10:55:15 <jgt> to not give up learning Haskell, I'm going to avoid completely overengineered solutions :)
10:55:46 <tsahyt> jgt: That's what I've been doing for 2 years now. It works wonderfully.
10:55:56 <ReinH> I mean, it's also a good idea per se
10:56:18 <byorgey> jgt: good idea =)
10:56:43 <monochrom> it is best to read only 16 characters (or even just 16 bytes), then confirm that the next character/byte is newline or absent.
10:56:53 <byorgey> darenthis: at the very least, you could use an IORef instead of an MVar
10:57:18 <byorgey> darenthis: but yes, you could also use  StateT over IO
10:58:05 <ReinH> I'd probably use a parser
10:58:28 * hackagebot rethinkdb 2.1.0.2 - A driver for RethinkDB 2.1  https://hackage.haskell.org/package/rethinkdb-2.1.0.2 (codedmart)
10:58:35 <darenthis> byorgey: many years of imperative thinking mean I 'get' IORefs and friends. StateT I struggle with :)
10:59:05 <Ankhers> jgt: Is this for CIS194?
10:59:09 <monochrom> well yeah, I have only described the I/O stop-guard part. of course you should give those 16 characters to a parser.
10:59:39 <monochrom> the last thing you want for the I/O part is getLine. it is vulnerable to DoS.
11:01:00 <monochrom> the only silverlining is that it is not vulnerable to buffer overrun.
11:01:22 <johnw> darenthis: think of State as functions that accept an argument, transform it, then return the transformed value.  That is all that the State abstraction does, except that it automates the passing and returning
11:02:13 <ReinH> something like let digits = count 4 digit; sep = optional (char '-') in (,,,) <$> digits <* sep <*> digits <* sep <*> digits <* sep <*> digits <* eof
11:03:00 <ReinH> depending on how flexible you want to be in accepting input
11:03:17 <johnw> or: liftA2 (:) digits (replicateM 3 (sep *> digits))
11:03:26 <tsahyt> So GHC just told me "My brain just exploded"
11:03:36 <ReinH> count 16 digit <* eof would be the simple one
11:03:37 <johnw> GHC's brain explodes from time to time
11:03:40 <johnw> it's like a zombie pinata
11:03:41 <tsahyt> I think I might have done something wrong here
11:03:57 <monochrom> no, more likely you found a GHC bug
11:04:14 <tsahyt> Apparently I'm pattern matching on an existential type
11:04:19 <monochrom> there is of course also the prospect of a little bit of both
11:04:21 <ReinH> johnw: or that :)
11:04:32 <bennofs> I think "my brain just exploded" is probably not a bug
11:05:00 <bennofs> > let SomeException e = undefined in e
11:05:01 <lambdabot>      My brain just exploded
11:05:01 <lambdabot>      I can't handle pattern bindings for existential or GADT data constructors.
11:05:01 <lambdabot>      Instead, use a case-expression, or do-notation, to unpack the constructor.
11:05:28 <ReinH> parsers are so easy to write in Haskell that they are often a very good choice for validating strings, especially in places where you might use a regexp in other languages
11:05:39 <xplat> what's a nice rdg library?
11:05:55 <ReinH> xplat: rdg?
11:05:59 <tsahyt> I haven't used regexp anywhere but with grep ever since I learned Haskell
11:06:08 <bennofs> or use regex-applicative to write your regex like a parser :)
11:06:22 <monochrom> that's the best thing since regex
11:06:27 <johnw> or use rex to write your parser like a regexp :)
11:06:35 <bennofs> :/
11:06:46 <tsahyt> bennofs: That sounds interesting. Does that have any performance benefits?
11:07:06 <monochrom> ok now I have to bookmark all those nice regex libraries
11:07:15 <bennofs> tsahyt: theoretically it should. although I'm not sure if regex-applicative takes advantage of it
11:07:20 <xplat> ReinH: sorry, meant rdf
11:07:33 <johnw> rdf?
11:07:37 <ReinH> xplat: Ok I know what those letters mean
11:07:51 <aweinstock> johnw: it's a semantic-web thing
11:07:53 <johnw> rdf is like that reduced form of XSD or something?
11:08:28 <xplat> resource definition format
11:08:34 <ReinH> johnw: https://en.wikipedia.org/wiki/Resource_Description_Framework
11:08:35 <chattered> Isn't RDF just the triple-store format? It can be expressed in XML or N3 or turtle or whatever.
11:08:44 <xplat> er, yeah, description
11:09:01 <ReinH> It uses subject-predicate-object expressions to describe resources. I once used it to define rules for a card game.
11:09:06 <xplat> but yeah, it's triples.  or quadruples, sometimes.
11:09:23 <ReinH> Google is showing a couple haskell results
11:09:35 <ReinH> but I haven't done any rdf stuff in Haskell
11:12:36 <jgt> Ankhers: yes, I'm taking a look at the CIS194 homework
11:12:54 <jgt> I'm not actually going to school though; I'm a normal working programmer
11:13:35 <xplat> mostly i'm just interested in creating and serializing some rdf
11:14:32 <L8D> jgt: couldn't you use log10?
11:14:46 <L8D> jgt: to find the count of digits in a number?
11:15:16 <L8D> >> lobBase 10 1234567890123456
11:15:24 <L8D> > lobBase 10 1234567890123456
11:15:27 <lambdabot>      Not in scope: ‘lobBase’
11:15:27 <lambdabot>      Perhaps you meant ‘logBase’ (imported from Prelude)
11:15:33 <L8D> > logBase 10 1234567890123456
11:15:35 <lambdabot>  15.091514977212698
11:15:38 <monochrom> yes if you have a number to begin with
11:16:19 <xplat> if you start out with base10 text it's a bad idea to parse it first to find out how long it is :-/
11:16:48 <monochrom> the problem is that by the time you have checked that every character is a digit, you would have also known its length. so why bring in a transcendental function for a regular language job.
11:16:52 <L8D> I thought I saw jgt doing "length (show n) == 16" or something
11:17:23 <monochrom> it is interesting to see how people reduce discrete math problems to calculus problems
11:17:23 <L8D> logBase seems cleaner to me
11:17:49 <geekosaur> cleaner from one angle, dirtier from another :)
11:18:26 <geekosaur> ("wait why'd we just drag floating point into it?!")
11:18:29 * hackagebot sws 0.3.1.2 - A simple web server for serving directories, similar to weborf.  https://hackage.haskell.org/package/sws-0.3.1.2 (DerekElkins)
11:18:38 <monochrom> except that the calculus problems are solved by IEEE 754 floating point arithmetic rather than real numbers.
11:18:51 <L8D> oh yeah
11:19:00 <monochrom> this is the holy grail of XYZ problems.
11:19:02 <L8D> > logBase 10 100
11:19:04 <lambdabot>  2.0
11:19:06 <L8D> > logBase 10 1000
11:19:08 <lambdabot>  2.9999999999999996
11:19:12 <L8D> ^^^
11:19:24 <xplat> that seems a bit unreliable
11:19:28 <Welkin> floating point...
11:19:32 <L8D> yep
11:19:36 <geekosaur> </3 floating point
11:20:07 <johnw> floating point could have been called "hand wavy numbers"
11:20:14 <L8D> why are floats common though?
11:20:20 <johnw> they are fast
11:20:21 <L8D> why is is standardized?
11:20:31 <johnw> lots of dedicated hardware to computing floating point
11:20:32 <xplat> quick and dirty
11:20:36 <L8D> as opposed to scientific?
11:20:37 <johnw> and in many domains, approximate is just fine
11:20:49 <kadoban> Also … exact is /hard/.
11:20:57 <johnw> plus, if you stay in base 2, floating-point is plenty accurate
11:21:02 <johnw> it's the conversion to base 10 that is tricky
11:21:05 <monochrom> "float" = "scientific" in this context.
11:21:15 <monochrom> exact equal.
11:21:35 <L8D> I thought scientific was a term used to describe some other structure for floating point numbers?
11:21:42 <L8D> as opposed to IEE 754
11:21:49 <L8D> IEEE*
11:21:53 <monochrom> because if you look at the floating point bit format, it is literally scientific notation for base 2.
11:22:02 <geekosaur> ^
11:22:07 <jgt1> I hope the discussion isn't still on how to check that a number is 16 digits long
11:22:30 <geekosaur> there are lots of different ways to represent them, all approximations of some form
11:22:31 <johnw> we've moved on to 17 digits, long ago
11:22:55 <geekosaur> blame cantor, I think :p
11:23:12 <monochrom> what did Cantor do?
11:23:56 * geekosaur thinking this representation issue is related to diagonalization (so not that cantor caused it, just discovered/confirmed it)
11:24:39 <monochrom> I see
11:24:52 <jgt1> it's funny; the idea of a static type system saving me from my own stupid mistakes is so appealing, and yet nerds turning what I believe to be a simple Day One problem into endless science discussions makes me want to keep well clear
11:24:55 <chattered> A real x should obviously be represented as a function from an error margin e to a rational in the range [x-e, x+e].
11:25:10 <johnw> jgt1: just wait until you get to dependent types
11:25:13 <geekosaur> this discussion should probably have moved to -overflow long ago
11:25:25 <Ankhers> I still don't fully grok dependent types.
11:25:27 <geekosaur> (and now you know what haskellers do when they're bored :)
11:25:30 <johnw> "I know, I'll fix this off-by-one error here.  <Nine hours later spent rewriting proofs>.  Oh."
11:25:33 <L8D> what's the difference between -overflow and -blah?
11:25:45 <johnw> -blah is more social
11:26:01 <johnw> Ankhers: dependent types are much easier than the Net would have you believe
11:26:05 <StoneToad> so you're saying floating point isn't socal?
11:26:09 <StoneToad> social*
11:26:09 <monochrom> -blah does not talk about Haskell. -overflow does.
11:26:11 <kadoban> -overflow is for haskell related stuff nobody cares about, -blah is for really bad political discussions and people who don't feel like talking about haskell in here
11:26:45 <Ankhers> johnw: When I first started hearing about them, I remember people saying that they are actually hard to use practically. Is that true?
11:27:01 <johnw> depends on what you're trying to use them for
11:27:05 <johnw> it can be true, it can not be true
11:27:10 <StoneToad> isn't the hard part the compiler side?
11:27:18 <bitemyapp> johnw: crank turning
11:27:23 <fosterite> chattered: afaik that's the normal way to do it
11:27:27 <monochrom> dependent types are easier than the Net would have you believe. but still harder than the fans would have you believe.
11:27:31 <johnw> if you overuse them to write overly-strict code, you can paint yourself into a corner really, really fast, in which even the most minor change requires a massive overhaul
11:27:48 <johnw> but if you use them where they should be used, they provide excellent compile-time guarantees, and are not cumbersome at all
11:27:50 <fosterite> weirder  ways are continued fractions and linear frctional transofrmations
11:28:06 <johnw> monochrom: haha
11:28:30 * hackagebot Spock 0.9.0.1 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-0.9.0.1 (AlexanderThiemann)
11:28:48 <geekosaur> "gradually dependent typing"
11:29:13 <tommd> xplat: You might like swish
11:29:17 <geekosaur> ("gradual typing" being a thing starting to show up as an alternative to duck typing)
11:29:34 <tommd> xplat: For generating and parsing Turtle - which is related to RDF.
11:30:06 <Ankhers> geekosaur: What is meant by "gradual typing"? 
11:30:09 <johnw> just using GADTs and DataKinds gets you a lot of bang for the buck, due to narrowing the type based on the choice of constructor
11:30:58 <xplat> tommd: i actually don't even need to parse yet!
11:31:00 <johnw> that way, you can have both functions that work for any constructor of your type, as well as functions that only operate on a subset, and this is guarded at compile-time
11:31:16 <fosterite> Ankhers: your functions with type annotations are checked, and the rest is assumed to be fine
11:31:17 <geekosaur> Ankhers, basically means some things have static types and others have dynamic types and the two can interact
11:31:38 <johnw> geekosaur: does Data.Dynamic count as gradual typing?
11:32:01 <geekosaur> ...my thought being that you do the same with dependent typing, some things dependently typed where it helps and isn't too onerous and others not
11:32:02 <Ankhers> fosterite. geekosaur: Fair enough. Thanks!
11:32:19 <johnw> geekosaur: but dependently typed languages already let you do that...
11:32:49 <shachaf> I don't understand why people call anything you can do in Haskell "dependent typing".
11:33:07 <shachaf> It's all missing the primary feature of dependent types, namely, types depending on values.
11:33:11 <geekosaur> yes, do users recognize they don't lose style points for taking advantage though?'
11:33:41 <geekosaur> as for Data.Dynamic... I'd say no, but I have this feeling that rapidly heads off into areas I'm nowhere near clear on
11:34:22 <xplat> gradual typing needs a blame system to work well
11:34:54 <xplat> so that all the errors are correctly attributed to dynamic code
11:35:12 <fosterite> I thought blame was a solved problem with that one paper about it
11:35:37 <xplat> fosterite: you still need to implement it
11:37:35 <tsahyt> Is haskell-src-exts supposed to be completely compatible to how GHC parses source code?
11:39:47 <monochrom> xplat: somehow, I feel that "always blame dynamic code" is very simple and effective :)
11:40:45 <xplat> tsahyt: if you're asking 'can i report a bug if it isn't', then yes
11:41:15 <xplat> tsahyt: and in practice it is pretty compatible
11:42:06 <xplat> like, if haskell-src-exts can't tell how ghc would parse something, there's a very good chance you can't either
11:42:50 <tsahyt> xplat: I've noticed that a lot of Haskell tooling which uses haskell-src-exts doesn't accept unicode subscript numbers in identifiers, but GHC accepts it just fine. I'd have to check the Haskell report before submitting anything though
11:43:30 * hackagebot ipython-kernel 0.6.1.3 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.6.1.3 (gibiansky)
11:44:00 <geekosaur> supposed to be, often isn't, note that the subscript thing is also an issue in ghc 7.10
11:44:57 <geekosaur> (prereleases rejected it, something was adjusted for release but IIRC there are still some variances. different versions (and interpretations) of the unicode standard are involved
11:46:16 <tsahyt> As far as I can tell the Haskell report only talks about digits. Now whether subscript digits are digits too is a different question.
11:46:48 <geekosaur> this is where the comment about the unicode standard came in
11:47:01 <geekosaur> it actually defines what characters count as digits and what values they have
11:47:23 <geekosaur> (but ghc does extend that set some, or used to)
11:48:50 <tsahyt> I hope that GHC continues to accept them in the future. They're really useful sometimes.
11:48:54 <geekosaur> ...and which characters are considered by the unicode standard to be "digits" depends on which version of the unicode standard
11:57:28 <kristof> Can someone please explain to me how fmap is defined over Parsec's Parser type?
11:57:45 <kristof> It's not quite clear to me how that actually works.
11:58:25 <kristof> Oh, now it makes sense.
11:58:31 * hackagebot microformats2-parser 1.0.1.2 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-1.0.1.2 (myfreeweb)
11:59:22 <kristof> Given some constructor f :: a -> b -> c for some type c, fmap f :: Parser a -> Parser b -> Parser c
11:59:52 <kristof> So the implementation works by parsing an a, and parsing a b, and supplying those to the contructor for c. Correct? And if there's a failure, the whole thing fails.
12:00:12 <kristof> It's amazing how asking a question gets your brain working hard enough to actually tease out the answer. :)
12:00:13 <Ankhers> :t fmap
12:00:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:00:35 <kristof> Ankhers: The type signature is simple enough, but that tells me nothing about the implementation.
12:01:02 <Ankhers> To me it takes a function, and a `Parser a`, and produces a `Parser b`.
12:01:07 <kadoban> kristof: ^ it's more like … given a parser that yields an 'a' and a function :: a -> b, it just runs the function on the result of the parser
12:01:26 <kadoban> Which gives you a Parser b
12:01:50 <aweinstock> kristof: you're thinking of liftA2
12:01:53 <aweinstock> :t liftA2
12:01:54 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:02:27 <aweinstock> :t \f x y z -> fmap f x <*> y <*> z
12:02:28 <lambdabot> Applicative f => (a2 -> a1 -> a -> b) -> f a2 -> f a1 -> f a -> f b
12:02:41 <aweinstock> :t \f x y -> fmap f x <*> y
12:02:43 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
12:02:52 <kristof> aweinstock: Close enough. :)
12:03:25 <kristof> kadoban: "Running the function on the result of the parser" wasn't obvious to me, sorry. But now it is.
12:05:43 <kristof> Wow, that was simpler than I thought it would be.
12:08:31 * hackagebot propellor 2.7.2 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.7.2 (JoeyHess)
12:31:08 <danso> is there a ghc extension to allow where statements in type signatures? as in: map :: f -> [a] -> [b] where f :: (a -> b)
12:31:17 <danso> that seems like it would be very useful and simple
12:32:04 <Ankhers> danso: I don't see how that is more clear than `map :: (a -> b) -> [a] -> [b]`
12:32:56 <danso> it's a deliberately simple example, but for a more complex function i think it could be a lot more readable
12:33:42 <danso> and for type signatures too long to fit on one line, it gives an obvious place to line break 
12:33:44 <aweinstock> danso: the standard way to do that is via the "type" keyword (similar to C's typedef), although that's not local like "where" would be
12:34:13 <aweinstock> type Fun = a -> b
12:34:20 <danso> type is similar to what i'm suggesting, yes
12:35:27 <danso> is there any technical reason for no where clauses in type signatures? has it been suggested before? i can't find anything about it
12:36:18 <ChristianS> danso: that sounds like a horrible idea
12:36:47 <ChristianS> or maybe not, hmm. but i think it would be confusing.
12:36:52 <danso> ChristianS, elaborate? 
12:37:05 <danso> it seems like an obvious extension to haskell's type system
12:37:25 <tsahyt> danso: It's not really an extension to the type system, it'd really be just syntactic sugar if I understand you correctly
12:37:28 <ralu> where is just scoped alias?
12:37:31 <Ankhers> I think it would be confusing strictly because where allows you to define multiple things.
12:37:47 <danso> absolutely, syntax sugar for local type alias
12:38:24 <L8D> danso: with a let..in or where syntax you can create recursive types
12:38:48 <danso> hahaha, i hadn't thought of that, L8D 
12:38:59 <L8D> Nothing :: m where m = Maybe m
12:39:52 <tsahyt> That sounds like the halting problem creeping into type inference
12:40:15 <danso> is that unmanageable? haskell already has infinitely recursive expressions the same way
12:40:16 <ralu> inst type system allredy turing complete?
12:40:38 <tsahyt> ralu: As far as I understand, not in Haskell98
12:41:27 <geekosaur> yes, but this would not be h98 or h2010
12:41:42 <ski> tsahyt : no, cyclic types are checkable
12:41:50 <ralu> it was sort of pun. But what would were help
12:42:12 <ralu> s where s = String
12:42:27 <ralu> is then string exposed
12:42:42 <ski> danso : however, having the type system allow cyclic (aka equi-recursive) types would turn many type errors (mistakes) into obscure inferred types
12:42:58 <tsahyt> ski: I did not know that. Is it really impossible to come up with a situation where type inference breaks when you allow this sort of recursion on the type level?
12:43:25 <ski> OCaml has cyclic types, as long as the cycle passes through at least one object type (or the `-rectypes' option is used)
12:43:29 <voidzero> I started to compile a list of unicode symbols to be used with vim-haskellConcealPlus
12:43:33 <voidzero> ...but then I couldn't stop
12:43:44 <danso> ski, could you give an example? 
12:43:45 <voidzero> so it turned out to become a pretty big list of nice unicode symbols
12:43:46 <ski> tsahyt : maybe in conjunction with other advanced type system extensions. i'm not sure
12:43:55 <voidzero> https://gist.github.com/voidzero/854d8787abdfa687e6bc
12:44:16 <ski> danso : forgetting to pass an argument recursively would often infer a cyclic type
12:44:16 <voidzero> these work in my terminal (urxvt) and my favorite font Terminus
12:44:39 <danso> ah, hmm. 
12:44:42 <voidzero> maybe others can use it too.
12:44:52 <ski> danso : recall everytime you've got an "cyclic/infinite type" error for `a -> b = b' or `[a] = a'
12:45:23 <danso> yes, that's an interesting problem 
12:45:49 <danso> but is dealing with that in a where clause any different from dealing with "[a] = a" ?
12:46:03 <ski> anyway, in OCaml, you can say the equivalent of `foo :: x@([a] -> [a]) -> x', e.g.
12:46:45 <L8D> urxvt + terminus + awesomewm/xmonad/dwm + arch linux = total hipster
12:47:00 <L8D> it's even funnier when they use nano
12:47:03 <voidzero> damn I got 3 out of 4, L8D.
12:47:08 <ralu> nixos
12:47:09 <ski> having `foo :: ..x.. where x = ...' (or `where type x = ...', maybe), wouldn't be a problem, if you disallow cycles (just as for type synonyms), i think
12:47:09 <danso> L8D, that's exactly the setup i use
12:47:21 <voidzero> I'm the anti-hipster because I use Funtoo, not Archlinux.
12:47:31 <danso> wait, no, inconsolata over terminus
12:47:51 <ralu> ais anyone running nixos here?
12:48:05 <ski> Ankhers : .. also, if this were to be allowed, obviously one'd want to allow multiple location definitions in the `where'/`let'
12:48:38 <danso> mhm ski, i think so too
12:49:04 <danso> should i make a feature request? i could copy this discussion
12:49:07 <Ankhers> ski: Was that meant to danso? I didn't ask the question, and I pointed out the multiple definitions.
12:49:27 <aaronm04> L8D: what's terminus?
12:49:34 <ski> Ankhers : it was in response to your "I think it would be confusing strictly because where allows you to define multiple things."
12:49:34 <voidzero> a font.
12:49:54 <Ankhers> ski: Oh okay.
12:49:56 <aaronm04> ah go tit
12:50:07 <ski> .. another thing i've been missing are local type definitions (inside a `where' or `let' inside another value definition)
12:50:16 <voidzero> many default fonts of vim-haskellConcealPlus didn't work
12:50:21 <voidzero> eh, s/fonts/glyphs/
12:50:27 <tsahyt> Is there a reason to use foldl' over foldr when the folding function is commutative?
12:50:38 <voidzero> so I started to compile a list of alternatives but then couldn't stop until the end of the list :)
12:50:45 <danso> tsahyt, is it also associative? 
12:50:49 <Ankhers> ski: I thought you could give a type to something defined in a where?
12:50:50 <tsahyt> danso: Yes
12:50:57 <danso> then no, i don't think so
12:51:01 <tsahyt> danso: Actually associative is what I meant in the first place
12:51:40 <danso> ski, that sounds like the scoped type variables extension
12:51:47 <danso> unless i misunderstand
12:52:37 <danso> nevermind, i think i did misunderstand
12:52:47 <ski> danso : no. this would be able to use that extension
12:53:08 <jgt1> I figured out my little credit card number validator
12:53:10 <ski> danso : it would allow `foo :: forall a. ..a..; foo = ... where data Bar = ..a..'
12:53:29 <jgt1> and I don't understand why people were stressing about crashing it by feeding it a huge number
12:53:34 * hackagebot os-release 0.2.2 - /etc/os-release helpers  https://hackage.haskell.org/package/os-release-0.2.2 (yac)
12:53:36 * hackagebot sha-streams 0.2.0 - SHA hashes for io-streams.  https://hackage.haskell.org/package/sha-streams-0.2.0 (VoMinhThu)
12:53:39 <ski> danso : with `a' being a nonlocal tyvar to the definition of `Bar'
12:53:44 <jgt1> I fed it like a thousand 9s and it was basically instant
12:53:51 <danso> interesting idea, ski 
12:54:10 <danso> i just had a problem that could have been solved nicely with a local type def
12:54:30 <ski> danso : i have come into situations where code would have been clearer with such a local definition of a type .. especially in the cases where the type is "temporary"
12:54:36 <jgt1> my validator: https://gist.github.com/jezen/c1d04d2b0f2f390564c0
12:55:14 <ski> danso : obviously `Bar' couldn't occur in the signature of `foo' above, though. only for internal use
12:55:43 <danso> ski: mhm 
12:56:10 <ski> danso : for completeness, one'd also like to be able to have local `instance' declarations. at least as long as it involves at least one local type defined in the same scope
12:57:14 <ski> danso : e.g. if one locally defines a type `F :: * -> *', one might like to be able to declare it as a `Functor'
12:57:15 <danso> yeah, including derivable instances
12:57:54 <ski> (e.g. to be able to use it with an argument to `foo' of type `forall f. Functor f => ..f..')
12:59:14 <SrPx> How different would Haskell be if it was created today with the all things we learned since 98
12:59:52 <tommd> They wouldn't be requried to start with {-# LANGUAGE ...
13:00:34 <SrPx> That's the first thing I thought, I guess most useful extensions would be enabled by default. I still wonder why innocent things like ViewPatterns and overloaded lists aren't, though.
13:00:52 <voidzero> there wouldn't be much haskell today, if today is when they'd start
13:00:56 <voidzero> so.. very.
13:01:08 <SrPx> why not?
13:01:13 <danso> i would like to think String and [] would be classes 
13:01:19 <ski> possibly because overloaded lists complicate things for newbies learning the basics of the type system
13:02:01 <tommd> Would it be dynamically typed a la Coq?  Would it allow for safe-ish, low level, programming a la Rust? Would a proof system be integrated?  Automated a la Cryptol?
13:02:02 <SrPx> ski: ah
13:02:12 <tommd> So many possibilities, lets make a new language!
13:02:47 <SrPx> yess lets do it for fun
13:02:57 <SrPx> I would love to see what would come out
13:03:28 * voidzero suppresses his sarcastic remarks
13:03:46 <bitemyapp> @ty void
13:03:48 <lambdabot> Functor f => f a -> f ()
13:04:03 <bitemyapp> @ty void (return 0)
13:04:04 <lambdabot> Monad f => f ()
13:04:10 <voidzero> i was about to say something like there being at least one 'new' language topic on hackernews every week
13:04:23 * ski thinks `void' ought to be renamed, or relegated to FFI modules ..
13:04:34 <voidzero> bitemyapp :)
13:04:43 <tommd> voidzero: But how many are dependently typed?  Only half, I bet!
13:05:05 <SrPx> :(
13:05:17 <SrPx> but... it is different 
13:05:26 <voidzero> wikipedia doesn't know about much of those.. https://en.wikipedia.org/wiki/Category:Dependently_typed_languages
13:06:13 <voidzero> otoh, i don't know anything about those, so wikipedia wins
13:07:07 <tommd> Yeah, wikipedia doesn't even include a decent set of Proof Assistant langauges - what's with that?
13:08:08 <mpickering> Is there a module somewhere which decodes html entities (which can be used with hexpat for example
13:08:23 <kristof> So more and more when people ask me what functional programming languages are good for, I find myself answering that they are good for domains that are not easily represented by pure functions and involve complicated control logic.
13:08:35 * hackagebot haxy 1.0.1 - A simple HTTP proxy server library  https://hackage.haskell.org/package/haxy-1.0.1 (AndreyChudnov)
13:08:44 <kristof> Unsurprisingly this surprises many people but this is the answer I am most satisfied with :)
13:08:55 <bitemyapp> kristof: not wrong tho
13:09:12 <kristof> bitemyapp: They are certainly better at it than procedural, stateful languages
13:09:21 <bitemyapp> ikr
13:09:30 <kristof> how dat book coming tho
13:10:03 <bitemyapp> kristof: 570 pages in current release, ~780 currently written, last 30-40% to go.
13:10:12 <kristof> The hardest parts, though.
13:10:17 <bitemyapp> nope
13:10:29 <kristof> No? Last I checked the last sections were pretty finicky subjects
13:10:40 <bitemyapp> finicky how, though?
13:10:45 <bitemyapp> earliest parts were VERY precarious pedagogically.
13:10:46 <cocreature> mpickering: a quick look at hackage brought up https://hackage.haskell.org/package/html-entities
13:10:48 <kristof> I can't remember. It's been a while.
13:10:59 <bitemyapp> it's extremely hard to find the fewest-thunks-forced path through a conceptual domain like that.
13:11:01 <mpickering> great thanks cocreature 
13:11:16 <mpickering> seems weird you have to plug it in yourself to hexpat!
13:11:22 <bitemyapp> finicky technically is easier to deal with, recognize, and cope with than finicky pedagogiclaly.
13:11:30 <bitemyapp> because you can miss cases of the latter.
13:12:13 <kristof> bitemyapp: I fully expect after you finish that book, you write the first really comprehensive book on very advanced functional patterns like hylomorphisms, monoidal homomorphisms, comonads...
13:12:51 <kristof> A one stop shop for functional pearls.
13:13:31 <kristof> I take it back, I don't expect you to do anything, but I think you are quite qualified to do so.
13:13:49 <voidzero> i saw a book on nomads a while ago, and at first glance, thought they made a spelling error.
13:14:09 <bitemyapp> kristof: next book is something different
13:14:50 <bitemyapp> kristof: honored you think so :)
13:15:01 <bitemyapp> not just me writing the book tho, it's Julie too.
13:15:12 <neuroserpens> So... I'm trying to make a word list for aircrack (wpa wireless cracking program). I need a program to generate strings that range from 8 to 12 alphanumeric characters. I got the mapM_ print list part but I have no idea how to generate the list.
13:16:03 <kristof> bitemyapp: Ah, she deserves credit, too, but I don't know her, only you
13:16:08 <bitemyapp> Sure.
13:16:13 <kristof> bitemyapp: Are you still in Houston?
13:16:24 <bitemyapp> I've never lived in Houston or been to Houston outside of the airport.
13:16:29 <kristof> Dallas.
13:16:32 <bitemyapp> Austin
13:16:33 <bitemyapp> yes
13:16:37 <bitemyapp> comonads aren't that tricky, they're just
13:16:44 <bitemyapp> sort of uncommon, relatively speaking.
13:16:59 <kristof> Well, there is a skill to recognizing when to use either.
13:17:00 <bitemyapp> if you're comfortable with the types and algebraic reasoning, it's sort of mechanical.
13:17:03 <bitemyapp> oh sure.
13:17:13 <kristof> So I really do mean types and algebraic reasoning.
13:17:30 <bitemyapp> we do a fair bit of that in the current book, you've gotten me thinking about monoid homomorphisms again.
13:17:36 <bitemyapp> but I'm not allowed to touch the monoid chapter right now
13:17:54 <bitemyapp> no comonads or hylomorphisms though :P
13:18:16 <kristof> I think monoids are really important because they're like a bridge between concrete types and really powerful, general typeclasses.
13:18:23 <neuroserpens> If my question is stupid you can just say it and I'll study some more though.
13:18:35 * hackagebot dbmigrations 0.9 - An implementation of relational database "migrations"  https://hackage.haskell.org/package/dbmigrations-0.9 (JonathanDaugherty)
13:18:38 <kristof> They're simple enough so people get it but you can apply them to so many different types.
13:19:05 <kristof> Whereas monads and applicatives are actually much harder to understand.
13:19:13 <bitemyapp> kristof: that's why Monoid is the bridge from the first half of the book to Functor/Applicative/Monad.
13:19:25 <bitemyapp> kristof: we explain the relationship between monoid, functor, and applicative as well.
13:19:28 <bitemyapp> (monoidal functors)
13:19:45 <bitemyapp> http://haskellbook.com/progress.html you can see what I mean in the ordering.
13:19:46 <kristof> bitemyapp: Oh, nifty, you already thought of this. :P But yeah I hope you agree that monoids can be very pivotal in someone's understanding.
13:19:52 <bitemyapp> (we might drop semigroup tho)
13:20:09 <kristof> It would be a good mention in the monoidal chapter.
13:20:10 <bitemyapp> kristof: I do agree they can help a lot with intuition for other algebras.
13:20:30 <bitemyapp> I don't link up monoids and folds until the Foldable chapter though.
13:20:35 <kristof> "Sometimes you don't have a useful mempty. Semigroup is Monoid with mempty."
13:20:39 <kristof> *without
13:20:52 <bitemyapp> We generally aren't that careless in mentioning something.
13:21:05 <bitemyapp> Semigroup is mentioned so they have an example of what it means to have a "weaker" algebra.
13:21:34 <bitemyapp> I'll probably go back and do it after I'm set loose on it again.
13:21:55 <kristof> You cover Traversable after Monad?
13:22:02 <bitemyapp> kristof: foldable and traversable, yes.
13:22:25 <joobus> what is youse guys opinion of Real World Haskell?  I've been reading through it after starting with Programming in Haskell.  RWH is better, but some of the examples get too involved and I skip over them.
13:23:18 <joobus> kristof: do you ever go to the functional programming meetup?
13:23:27 <kristof> joobus: Negatory.
13:24:03 <kristof> bitemyapp: I think Foldable and Traversable are very good examples of "so why do I need functors?"
13:24:11 <kristof> Functors / Monoids
13:24:35 <kristof> So having a tight feedback loop like that is a very good idea. Monoids -> Functors -> Combining the two to use Foldable
13:25:07 <kristof> And then you can end up with some VERY interesting examples in the Applicative chapter that make use of complicated Traversable datatypes
13:25:14 <kristof> Just a suggestion. :)
13:25:59 <quchen> I don't understand how monoid and functor make foldable.
13:26:00 <kristof> I have noticed that in many of the best programming books I have read, there is some central example they expand upon and go back to many times as new things are learned.
13:26:18 <quchen> Foldable uses Monoid, but it doesn't use Functor.
13:27:06 <hodapp> kristof: That's one of the things I like about Software Foundations.
13:27:08 <kristof> quchen: Most things you can fold over also have a Functor instance.
13:27:31 <quchen> Sure, but most things I Show also have an Eq instance, yet they're unrelated.
13:27:50 <Alas`> Have you guys seen http://haskellformac.com?
13:27:59 <quchen> Traversable I'd agree is Functor+Monoid+Foldable in a sense.
13:28:11 <hodapp> kristof: It has homework questions that progress along building simple arithmetic expressions, optimizing them, proving that the optimizer always preserves the value, building a stack machine, building a compiler for arithmetic expressions to that stack machine, proving that the compiler generates code that always evaluates correctly...
13:28:27 <quchen> That's not a very useful view of Traversable either though.
13:28:28 <kristof> quchen: I did mean Traversable/Foldable, since the chapter in question covers the two.
13:28:32 <quchen> Ah.
13:28:38 <kristof> See above
13:28:59 <Gurkenglas> <kristof> quchen: Most things you can fold over also have a Functor instance. <- More importantly imo, the free Foldable has a Functor instance
13:29:50 <kristof> quchen: bitemyapp has Monoid -> Functors -> Applicative -> Monad -> Foldable/Traversable when I think moving the latter to after Functors and Monoids ties those together VERY well.
13:30:19 <kristof> Gurkenglas: Woah. When would I use a free Foldable?
13:30:20 <arkeet> you can't really talk aobut Traversable before Applicative.
13:30:23 <arkeet> :t traverse
13:30:25 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
13:30:46 <Guest55773> hey guys
13:31:43 <kristof> arkeet: Ah shoot, never mind then.
13:32:02 <danso> ski, i went ahead and made a ticket for my idea: https://ghc.haskell.org/trac/ghc/ticket/10794#ticket
13:32:11 <danso> you should do yours too!
13:32:36 <kristof> I'm dumb, moving on :)
13:32:46 <arkeet> :t \f -> fmap f . sequenceA
13:32:47 <lambdabot> (Applicative f, Traversable t) => (t a -> b) -> t (f a) -> f b
13:33:22 <bitemyapp> kristof: Traversable really needs to come after applicative
13:33:38 <bitemyapp> kristof: there's not much reason to do foldable or traversable before monad, rather go directly from applicative to monad, then to FT.
13:33:43 <bitemyapp> so the sequence is MFAM/FT
13:33:46 <kristof> I've only ever used Traversable with Alternative and I forgot that Alternatives are Applicatives :P
13:38:07 <broma0> Quick question about parsing a free monad from text: Using a type like 'data
13:38:07 <broma0> Stmt k = Get Key (Val -> k) | Put Key Val k', how can i write a general parser
13:38:07 <broma0> for 'Free Stmt k'? My attempt at this can be found here (the only issue is that
13:38:07 <broma0> the 'Free Stmt k' parser, called pQuery, doesnt type check due to the different
13:38:08 <broma0> types of 'pGet' and 'pPut/pDel'): http://lpaste.net/139637
13:38:36 * hackagebot foldl-transduce 0.1.0.0 - Transducers for folds from foldl.  https://hackage.haskell.org/package/foldl-transduce-0.1.0.0 (DanielDiazCarrete)
13:39:22 <johnw> broma0: you aren't constructing in your parsers
13:39:58 <broma0> johnw: what do you mean? don't the 'get' 'put' and 'del' functions do the constructing?
13:40:02 <johnw> it needs to be: Free <$> (Del <$> (string "del" *> (parens p)) <*> Pure ())
13:40:06 <johnw> for pDel
13:40:27 <johnw> where I imagine parens p :: Parser Key
13:40:48 <johnw> if not, then you'll need Key <$> parens p
13:40:56 <johnw> oh, Key isn't a constructor, n/m
13:41:00 <f-a> I need to do an `intersect` between two big lists (well, one is 20 elements, the other some 500mb of data. I get an out of memory error when I perform the operation. How to handle this?
13:41:29 <quchen> Gurkenglas: What's the free Foldable?
13:42:40 <broma0> johnw: trying to understand your answer.. why doesn't the 'get' function i've defined solve the same problem you outlined?
13:42:50 <broma0> get k = liftF (Get k id)
13:43:08 <johnw> ah, I see that now
13:43:15 <johnw> still, something seems not right here
13:43:23 <johnw> stringLit >>= pure . del . pack
13:43:36 * hackagebot foldl-transduce 0.1.0.1 - Transducers for folds from foldl.  https://hackage.haskell.org/package/foldl-transduce-0.1.0.1 (DanielDiazCarrete)
13:43:40 <johnw> it should be: string "del " *> (del <$> parens p)
13:43:54 <bitemyapp> johnw: hi, do you not do documentation tickets?
13:44:19 <johnw> bitemyapp: you mean, leaving a ticket open forever because there's no one to do the work?
13:45:03 <broma0> johnw: and what would 'p' be?
13:45:08 <bitemyapp> johnw: people pipe up periodically who can't necessarily contribute to writing new code, but are willing to do documentation work. Having tickets on hand for that can help.
13:45:20 <johnw> broma0: stringLit
13:45:38 <johnw> or pack <$> stringLit perhaps
13:46:04 <johnw> bitemyapp: I'd rather they piped up with PRs, otherwise I'd have a "need better docs" ticket open perpetually on everything I maintain
13:46:17 <bitemyapp> johnw: it was a docs ticket for a specific issue - API coverage.
13:46:27 <johnw> yeah, which isn't going to happen, so I thought I had answered it
13:46:29 <Gurkenglas> @let newtype FreeFoldable a = FreeFoldable { runFreeFoldable :: forall m. Monoid m => (a -> m) -> m } deriving Functor -- quchen
13:46:30 <lambdabot>  Defined.
13:46:56 <broma0> johnw: i still have the same problem.. here's the error: 
13:47:07 <bitemyapp> johnw: you made sure of that, yes.
13:47:13 <broma0>  Couldn't match type ‘k’ with ‘()’
13:47:13 <broma0>       ‘k’ is a rigid type variable bound by
13:47:13 <broma0>           the type signature for pQuery :: Parser (Query k)
13:47:22 <quchen> Gurkenglas: fmap is Cont's?
13:47:22 <johnw> bitemyapp: not sure what you're expecting to happen
13:47:32 <bitemyapp> nothing at all.
13:47:39 <arkeet> Gurkenglas: that's free monoid.
13:48:00 <bitemyapp> johnw: I do documentation edits and the like periodically, had you asked nicely, I would've done that this weekend.
13:48:09 <johnw> broma0: why use Query k
13:48:12 <bitemyapp> johnw: or found someone who was interested.
13:48:31 <Gurkenglas> What no I just took the Foldable a argument out of foldMap, it's trivially the free Foldable
13:48:36 <arkeet> "free foldable" would have kind (* -> *) -> (* -> *)
13:48:36 <johnw> bitemyapp: I'm not trying to be unkind, bitemyapp, I was just processing issues
13:48:46 <broma0> johnw: i need to parse an arbitrary query from text. I have an interpreter for 'Query k' that does the actual processing
13:48:52 <bitemyapp> johnw: I believe you
13:48:54 <Gurkenglas> :t fmap length $ FreeFoldable (flip foldMap ["hello", "world!"])
13:48:55 <lambdabot> FreeFoldable Int
13:49:12 <neuroserpens> Alright... The answer to my question was the function subsequences... Thanks anyway...
13:49:17 <arkeet> Gurkenglas: I know you did. that doesn't make it the free foldable.
13:49:44 <quchen> "FreeFoldable" looks like a CPS'd Monoid.
13:49:45 <johnw> broma0: the structure you're building at parse time should always have () at the bottom: Parser (Query ())
13:49:47 <Gurkenglas> must have got my terminology wrong
13:49:53 <arkeet> it's the free monoid.
13:49:59 <quchen> Oh, right.
13:50:01 <arkeet> because it takes a thing and gives you a monoid.
13:50:10 <arkeet> free foldable would take a thing (of kind * -> *) and give you a Foldable.
13:50:14 <orion> Hi. Does anyone know why the following two statements have different string representations?: (fromJust . readMaybe) "14405324.312679" :: Scientific -- and -- (fromJust . readMaybe) "1440532.312679" :: Scientific
13:50:17 <johnw> broma0: oh, I see, with "get"
13:50:18 <johnw> hmm
13:50:28 <broma0> johnw: Yes! that's the issue
13:50:29 <orion> They are 1.4405324312679e7 and 1440532.312679, respectively.
13:50:32 <Gurkenglas> The universal element in the somethingsomething of foldables
13:50:35 <fosterite> times someone has invented lists while thinking about foldable += 1
13:50:36 <orion> Why does one have a decimal point and the other doesnt?
13:50:48 <broma0> i want to be able to parse and handle both queries that result in () and queries that result in some data retrieved
13:50:58 <arkeet> I'm not sure what "free foldable" would be.
13:51:02 <johnw> broma0: I think your "get" is too restrictive
13:51:43 <Gurkenglas> Ah well, what I originally meant then was that "imo more importantly" the free monoid has a Functor instance
13:52:17 <johnw> broma0: ok, I see your problem clearly now, let me think
13:52:37 <neuroserpens> Next question... Should I just use subsequences of [0 .. 9] ++ ['a' .. 'z'] for my cracking wordlist or is there a list in haskell that includes both numbers and letters?
13:52:43 <quchen> Can anyone point me to the semantics of `where` blocks? I've been unable to find it in the Report, and it must be in there somewhere
13:52:57 <neuroserpens> actually... that's not gonna work...
13:53:02 <Cale> neuroserpens: That's a type error btw, yeah
13:53:03 <neuroserpens> lists must have same type
13:53:05 <neuroserpens> yea
13:53:08 <neuroserpens> i just realized that
13:53:32 <Cale> You probably want ['0'..'9']
13:53:33 <quchen> Cale: Well, not strictly a type error, you're still free to define an orphan instance for Num Char
13:53:39 <Cale> Yeah
13:53:41 <neuroserpens> Cale: yea i just tried it haha
13:53:48 <neuroserpens> Cale: our minds are in sync
13:54:27 <johnw> broma0: ah, of course
13:55:11 <L8D> > ['0'..'z'
13:55:12 <lambdabot>  <hint>:1:10:
13:55:12 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:55:14 <L8D> > ['0'..'z']
13:55:15 <lambdabot>  "0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
13:55:28 <johnw> broma0: you're parsing two possible kinds of programs: those that result in (), and those that result in Val.  In order to know at runtime what the program will "do", we need to distinguish these two types.  So pQuery can return: Parser (Either (Query Val) (Query ())), and now you know whether you have a query that is capable of producing a Val, or one that isn't
13:55:46 <L8D> > ['0'..'9'] ++ ['A'..'Z'] ++ ['a'..'z']
13:55:48 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
13:55:49 <Welkin> > take 256 $ enumFrom (chr 0)
13:55:50 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
13:56:06 <johnw> otherwise, if we got Query k to work, there'd be no way to query which 'k' it is: () or Val
13:56:09 <quchen> > filter isAlphaNum [minBound :: Char ..]
13:56:10 <lambdabot>  "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\170\178\179\...
13:56:11 <neuroserpens> L8D: True... I forgot about high case
13:56:38 <johnw> bitemyapp: if it is part of your contribution workflow, please reopen the ticket
13:57:24 <neuroserpens> L8D Cale What's wrong with filter (\x -> (length x) > 8) ?
13:57:32 <quchen> johnw: Github ought to introduce a "ticket limbo" state between open and closed, kind of like GHC's milestone ⊥.
13:57:40 <johnw> yeah
13:57:43 <bitemyapp> johnw: I can't, no permissions.
13:57:46 <johnw> or a chat section
13:58:10 <johnw> bitemyapp: reopened
13:58:38 <friden> can someone recomend a package to render graphics to screen? preferrably some high level wrapper to draw shapes like points, rectangles and circles
13:58:41 <neuroserpens> L8D: Cale: Nevermind... I just needed to add a $
13:58:41 <ralu> @neuroserpens it is strict on length?
13:58:41 <lambdabot> Unknown command, try @list
13:58:48 <bitemyapp> johnw: danke
13:59:05 <neuroserpens> ralu: The problem is that I needed to add a $ after the filtering function
13:59:15 <neuroserpens> Because I'm using subsequences after that
13:59:40 <mauris_> friden, http://projects.haskell.org/diagrams/ is good i hear
13:59:42 <Cale> neuroserpens: You might want to use (\x -> not . null . drop 8 $ x)
14:00:06 <neuroserpens> Cale I have no idea what that even is lol
14:00:09 * neuroserpens is noob
14:00:13 <Cale> neuroserpens: At least, if the lists involved are ever much longer than 8 elements
14:00:22 <ralu>  (\x -> (length $ take 9 $ x) > 8)
14:00:29 <Cale> length xs takes O(length xs) time to compute
14:00:37 <neuroserpens> Cale I'm going to filter it from 8 to 12 with two length functions
14:00:41 <neuroserpens> Cale: Hm...
14:01:06 <broma0> johnw: That seems like it will do the trick.. is there a way to embed that into the query type itself?
14:01:17 <neuroserpens> Cale: I'm also not good with complexity...
14:01:26 <quchen> Surprisingly many uses of `length` where you're not actually interested in the actual number of the elements can be replaced by something better.
14:01:33 <johnw> broma0: I'd make another data type, Program, since it's higher-level than the Query
14:01:33 <quchen> Example: splitting a list in halves.
14:01:40 <quchen> Dropping elements from the end.
14:01:46 <johnw> also, you'll want different evaluators for the different kinds of programs
14:02:03 <neuroserpens> quchen: I think I am interested because most wifi passwords range from 8 to 12 characters
14:03:37 * hackagebot process 1.3.0.0 - Process libraries  https://hackage.haskell.org/package/process-1.3.0.0 (MichaelSnoyman)
14:03:52 <quchen> neuroserpens: You don't want the length of a list, you just want to know whether it's longer than N elements.
14:04:04 <neuroserpens> quchen: Yea. You're right.
14:04:06 <johnw> bitemyapp: my apologies if it came off as rude, I appreciate that you're just trying to improve the state of the world
14:04:07 <quchen> neuroserpens: One way to accomplish this is by dropping N elements, and see whether there is at least one left.
14:04:40 <neuroserpens> quchen: I have no idea how many elements I shoudl drop
14:04:43 <quchen> neuroserpens: When you want to count whether a tree has 10 apples, you don't count all the apples. You count until you've found 10.
14:04:52 <bitemyapp> johnw: no problem and thank you for being flexible and gracious about it!
14:04:54 <neuroserpens> actually...
14:04:58 <neuroserpens> it's 2 to the 7th power
14:05:02 <neuroserpens> minus 1?
14:05:21 <johnw> bitemyapp: I'm just overwhelmed by my task list, which has made me snappy this week, it was nothing personal
14:05:27 <neuroserpens> quchen: lol my math is rusty
14:05:49 <bitemyapp> johnw: I figured and I understand, thank you.
14:05:52 <neuroserpens> quchen: 2 to the 8th power minus 1 actually right?
14:05:56 <fosterite> could you make a RULES that was something like forall l r. if length xs > n then l else r = ??? xs n l r
14:06:08 <quchen> neuroserpens: I don't see what you're getting at.
14:06:31 <neuroserpens> quchen: You said I should drop elements. i'm trying to get the number of elements I should drop without using length.
14:06:50 <quchen> neuroserpens: How many elements can you drop from a list of at least length N?
14:07:13 <neuroserpens> quchen: so... until it reaches strings of 8 characters
14:07:21 <neuroserpens> quchen: It's 2 ** 8 - 1
14:07:28 <neuroserpens> quchen: At least I think it is
14:07:37 <quchen> Oh, so you have a list of strings? Do you want to enumerate all the strings
14:07:38 <quchen> ?
14:07:59 <neuroserpens> No. I want to create a word list to crack some wifi passwords.
14:08:10 <neuroserpens> quchen: And since most passwords range from 8 to 12 characters
14:08:17 <neuroserpens> quchen: I'm trying to optimize this program
14:08:23 <quchen> That sounds like you want to enumerate all alphanumeric strings from 8 to 12 chars.
14:08:29 <quchen> (There are *many* such strings.)
14:08:48 <neuroserpens> quchen: Oh yea yea... Bear with me. English is not my native language and I thought enumerating meant something else.
14:08:57 <neuroserpens> quchen: Yes then
14:09:18 <quchen> Enumerating means "mentioning them all". Enumerating all the digits would be "1234567890".
14:09:27 <neuroserpens> quchen: Yes I got it lol
14:11:05 <neuroserpens> quchen: shit... I just realized the subsequences function does not repeat characters
14:11:09 <neuroserpens> it won't work
14:12:56 <quchen> You know how to enumerate words of length 1.
14:13:00 <quchen> That's simply ..?
14:13:11 <quchen> Well, what you wrote earlier, the range business, [a..z] etc.
14:13:39 <quchen> The other step is thinking about how to enumerate strings of length (n+1) if you already know how to enumerate the ones of length (n).
14:13:47 <neuroserpens> quchen: Now I'm thinking of zipping ['0' .. 'z'] eight to twelve times.
14:14:14 <neuroserpens> quchen: That method of enumeration won't work. I need repetition of characters and subsequences does not do that.
14:14:26 <quchen> I did not mention subsequences.
14:14:33 <neuroserpens> quchen: I was using it xD
14:14:46 <quchen> Subsequences is not what you're looking for, no.
14:15:04 <glguy> [8..12] >>= \n -> replicateM n (['a'..'z'] ++ ['A'..'Z'] ++ ['0'..'9']) -- would be the alphanumeric sequences between 8 and 12 characters, but that list is a little too long to be useful
14:15:31 <neuroserpens> glguy: Hmm... replicateM
14:15:35 <neuroserpens> glguy: I didn't know that funct
14:15:57 <quchen> I'm also not sure how instructive that solution is.
14:16:15 <glguy> It'll take a while to go through those 3,279,156,377,874,257,103,616 values
14:16:39 <neuroserpens> glguy quchen The list is going go be long anyway. My wifi cracking experience with aircrack has taken from 8 hours to 2 days at times.
14:17:10 <neuroserpens> glguy quchen so that's kiiind of expected
14:17:11 <quchen> It gets funnier when you consider passwords of length 13.
14:17:13 <quchen> Or 14.
14:17:15 <quchen> Or n.
14:17:16 <neuroserpens> quchen: lmfao
14:17:20 <neuroserpens> quchen: it does
14:17:22 <fvgvxmpv1> g@
14:17:48 <glguy> neuroserpens: Aircrack isn't just enumerating all possible 8 to 12 character long passwords
14:18:14 <neuroserpens> glguy: what do you mean? aircrack is just for cracking, it needs an external list
14:19:11 <neuroserpens> gotta reboot brb
14:20:07 <numee> hi, is it possible to declare a function which contains `where` without saving the fragment to a file in GHCi? multi-line input (:{ + :}) seems not working
14:20:46 <frerich> numee: Something like 'let f x = x + y where y = 2' does not work for you?
14:23:43 * neuroserpens is back :p
14:24:34 <orion> Anyone know how to, given a string "12345.4321000", convert it to JSON with aeson such that the result is a JSON numeric, rather than a string?
14:24:37 <SomeDude_> Hey guys. What is a best way to do a mapping between variables? For example, 1 -> "one", 2 -> "two", 3 -> "three" and so on. In python I would use a dictionary. In most languages, in fact. The best way I can think of in Haskell would be a function with a case clause.
14:24:37 <quchen> neuroserpens: FWIW this is the solution to what I tried explaining. http://lpaste.net/139641
14:24:49 <SomeDude_> *values
14:24:52 <glguy> neuroserpens: That large number of solution would take 100 million years to check even if you could consider 1 million a second.
14:25:04 <glguy> neuroserpens: That's what I mean that it's not going to be fast enough
14:25:26 <neuroserpens> glguy: oh...
14:25:31 <quchen> SomeDude_: You can use a dictionary in Haskell as well, like Data.Map.
14:25:33 <neuroserpens> quchen: let me see
14:25:35 <orion> I need to be able to take the aforementioned string and preserve the precision exactly, but it has to be encoded in JSON as a number (no double quotes).
14:25:58 <tommd> SomeDude_: A function would be good but cases might be overly verbose.  How about `convert = HashMap.lookup int (HashMap.fromList [(1,"one"),(2,"two")...]`
14:26:06 <Gurkenglas> There should be DeriveDeriveTraversable, a tool that refactors your code to use DeriveTraversable.
14:26:30 <quchen> There should be a generator for a tool like this, DeriveDeriveDeriveTraversable.
14:26:41 <numee> frerich: where comes after the binding line like http://pastebin.com/Smc8MsxM
14:26:58 <SomeDude_> tommd: thank you, that should work!
14:27:10 <neuroserpens> quchen: wow... quite simple
14:27:16 <neuroserpens> quchen: very nice implementation
14:27:41 <quchen> neuroserpens: The principle behind it is called induction, maybe you know it from math.
14:28:16 <quchen> neuroserpens: glguy's solution is equivalent to mine, but reqiures understanding how replicateM works for lists, which I don't think is relevant for the problem right now.
14:29:00 <quchen> Well, roughly equivalent.
14:29:04 <SomeDude_> tommd: will the function generate the hashmap each time I call it? Or is it shared in memory somehow? I guess that depends on the implementation of haskell
14:29:28 <neuroserpens> quchen: I see
14:29:44 <tommd> SomeDude_: Yes, that depends.  I suggest you make the hash map a top-level binding in the actual code.
14:30:04 <neuroserpens> quchen: I tend to value the understandable solutions more though...
14:30:23 <neuroserpens> quchen: But it was good to learn a new function
14:30:40 <SomeDude_> tommd: Okay. 'Tis pretty messy, though.
14:31:55 <quchen> You can write the function as a CAF at the top level and share the hash map over the entire program.
14:32:07 <quchen> It's a bit subtle though.
14:33:35 <quchen> See http://lpaste.net/139644
14:34:46 <quchen> The second "convert" is equal to a function that takes an argument, which needs to be created only once and can then be called multiple times. The first one is a recipe to look up in a hashmap given an int.
14:35:19 <quchen> SomeDude_: ^
14:36:00 <tommd> quchen: I always forget the CAF rules and default to top-level bindings.  Is this behavior consistent outside of GHC? EHC? JHC?
14:36:26 <quchen> tommd: I don't know. It's not specified in Haskell, and I only know GHC.
14:36:54 <quchen> tommd: GHC's CAF rule is to simply not track them by GC, as far as I know.
14:38:01 <bitemyapp> lastlog -clear
14:38:38 <SomeDude_> quchen: I tried to google CAF but I gave up once I saw the abstract algebra talk. So, just making it an annonimous function (if that's the right term) makes it share?
14:38:38 * hackagebot indieweb-algorithms 0.1.0 - A collection of implementations of IndieWeb algorithms.  https://hackage.haskell.org/package/indieweb-algorithms-0.1.0 (myfreeweb)
14:39:26 <quchen> SomeDude_: I did not know there were CAFs in abstract algebra. A CAF in Haskell is roughly "a top-level value that takes no arguments".
14:39:50 <quchen> It stands for "Constant Applicative Form", but I don't know where that name comes from.
14:40:23 <SomeDude_> quchen: I probably can't rely on this, since I'm not using a standard haskell implementation. In fact, it's not haskell at all, it's elm, but #elm is way to slow. 
14:41:04 <SomeDude_> quchen: Should've said "math talk". I meant this: "Any super combinator which is not a lambda abstraction."
14:41:14 <bitemyapp> SomeDude_: that's not going to help you
14:41:19 <bitemyapp> SomeDude_: Elm isn't lazy.
14:41:44 <SomeDude_> bitemyapp: I guess it's the ugly way, then.
14:41:47 <quchen> Next time tell us you're using Elm right away ಠ_ಠ 
14:42:15 <bitemyapp> SomeDude_: what quchen just went to the trouble of telling you isn't going to apply.
14:42:21 <bitemyapp> SomeDude_: so yeah, you have to memoize manually, enjoy.
14:42:30 <bitemyapp> quchen: it's okay, I'm recycling what you said :P
14:42:40 <quchen> "enjoy" :-þ
14:42:45 <bitemyapp> :D
14:42:47 <bitemyapp> quchen: been taking notes on sharing and CAFs lately for the book :)
14:42:55 <bitemyapp> let floating, that sort of thing.
14:43:03 <tommd> You wouldn't steal a knowledge, would you?
14:43:05 <SomeDude_> quchen: Sorry, thought that would be rude, or offtopic. Thought I could just translate the haskell into elm myself.
14:43:11 <quchen> bitemyapp: Is the book about Haskell or GHC focused?
14:44:33 <xpilot> hello
14:44:52 <bitemyapp> quchen: we lean on the Report heavily, but the practical intent means will probably have spent some time talking about GHC'isms.
14:45:20 <xpilot> question about impredicative types
14:45:36 <quchen> They're broken.
14:45:43 <xpilot> is it possible to write the following: wrap :: (forall a. Identity (a->a)) -> Identity (forall a. a->a)
14:45:44 <bitemyapp> xpilot: don't use them
14:46:25 <quchen> SomeDude_: I'm not sure Elm is ontopic here (I'd say it depends on the question), but not mentioning it makes a huge case of the XY problem :-)
14:46:52 <xpilot> I see
14:47:04 <xpilot> well, I'm trying to model a language with let-polymorphism
14:49:24 <quchen> bitemyapp: Now the canonical question, how's it coming along?
14:49:29 <xpilot> does anyone know of any such examples?
14:49:50 <bitemyapp> quchen: well.
14:49:50 <orion> ((fromJust . readMaybe) "1.00000000" :: Scientific) == ((fromJust . readMaybe) "1" :: Scientific) <-- Why is this true?
14:50:02 <quchen> "canonical answer" I guess.
14:50:09 <bitemyapp> quchen: http://haskellbook.com/progress.html <--- progress page. 570 pages in current release, 780 currently written.
14:50:20 <bitemyapp> quchen: book is testing well.
14:50:26 <quchen> Testing?
14:50:40 <quchen> Are you trying it on people? (That sounds wronger than it should.)
14:50:42 <SrPx> how you float → double?
14:51:40 <rlewis> > 1.00000000 == 1
14:51:41 <lambdabot>  True
14:51:57 <SrPx> nvm it is float2double specifically
14:52:20 <SrPx> is there any case where you should use float instead of doubles
14:53:18 <Gurkenglas> Why aren't there functor instances for >=3-tuples?
14:54:26 <quchen> Because >=3-tuples are usually code smells.
14:54:47 <quchen> And because there is no standard that says up to which tuple size instances/functions should be there.
14:55:24 <quchen> (You could write a Functor instance for any tuple of course.)
14:55:27 <friden> mauris_: thanks btw, but i forgot to say it's for real time use, im making a very basic particle engine, I dont know if diarams fits real time use
14:55:33 <SomeDude_> I'll try to slip in one more Elm question. How do I get a character in a string by index?
14:55:46 <quchen> In Haskell it's (!!).
14:55:53 <quchen> > "hello world" !! 3
14:55:54 <lambdabot>  'l'
14:56:00 <quchen> > "hello world" !! 2
14:56:01 <lambdabot>  'l'
14:56:04 <quchen> > "hello world" !! 1
14:56:06 <lambdabot>  'e'
14:56:49 <srhb> SomeDude_: If you need O(1) indexing, you probably don't want String.
14:57:02 <srhb> Assuming String is [Char] in Elm.
14:57:19 <mauris_> it isn't
14:57:24 <SomeDude_> quchen: Hmm, not quite. I'll mess around a bit, maybe I just have to import that operator from somewhere.
14:57:27 <srhb> Oh well, no idea then.
14:57:43 <srhb> Elm has an annoying habit of pretending to be Haskell but not really. :P
14:58:15 <SomeDude_> srhb: What? So in Haskell, strings are linked lists? I thought they were arrays in every language.
14:58:24 <srhb> SomeDude_: Yes indeed.
14:58:25 <fosterite> srhb: elm doesn't have do natation, and it's mostly js, so callbacks bite you in the ass
14:58:46 <Hafydd> In Haskell, the type called "String" is a linked list. That doesn't mean that you're expected to use it for representing text strings in all cases.
14:58:54 <fosterite> their answer to this is manually desugared do-notation, except they named (>>=) andThen
14:59:10 <mauris_> SomeDude_:   import String exposing (slice)   slice 1 2 "hello" == "e"
14:59:11 <fosterite> it's a ghetto
14:59:12 <quchen> SomeDude_: Yes, String in Haskell is a singly linked list of individual chars. We know it's stupid.
14:59:36 <Hafydd> It is, however, convenient for learning the language, I suppose.
14:59:43 <quchen> SomeDude_: There's the Text type for all your "string" needs, but it's non-standard.
14:59:56 <SomeDude_> fosterite: Elm advertises itself as "an escape from callback hell". I saw that as one of it's biggest strenghts
15:00:33 <mauris_> SomeDude_: which is sort of better than an !! that returns Char. because `slice n (n+1)` is total, returning "" if you index outside of the string
15:00:59 <fosterite> SomeDude_: http://elm-lang.org/guide/reactivity scroll to "more chaining". they lied
15:01:16 <mauris_> SomeDude_: you can easily pass it through something that turns "a" into Just 'a' and "" into Nothing, of course. or crashes on "" if that's more your kinda thing
15:01:36 <SomeDude_> mauris: Sorry, I missed your message. I tought of slicing, but hoped there was a more streamlined approach
15:02:35 <xpilot> success: wrap :: (forall a. Identity (a->a)) -> forall a. a->a; wrap i = runIdentity i
15:03:38 <Hafydd> Oh god, I'm going to*** Exception: Prelude.head: empty list
15:03:42 <xpilot> no ImpredicativeTypes required!
15:04:08 <mauris> SomeDude_: out of curiosity, can i see the function you're writing that needs this?
15:06:17 <voidzero> do left tack ⊣ and right tack ⊢ mean anything in haskell notation?
15:06:33 <voidzero> I'm wondering if I can use those for Left and Right
15:06:56 <Eduard_Munteanu> voidzero, could be confusing to type-theorists
15:06:57 <SomeDude_> maruis: a function that returns the english name of a three digit number (to be used in a fuction that does the same for any number of digits)
15:07:31 <Hafydd> voidzero: "right tack" means something in Logic.
15:07:57 <voidzero> alright. That's what I wanted to know. Do you have suggestions on symbols I could choose for Either / Right / Left?
15:08:07 <Hafydd> (See: https://en.wikipedia.org/wiki/Turnstile_%28symbol%29)
15:08:40 <fosterite> voidzero: i with a tack that points left/right is a fun one
15:08:40 <voidzero> ah yes, thank you
15:08:55 <Hafydd> voidzero: I suggest "Either," "Right" and "Left", myself.
15:08:59 <Eduard_Munteanu> Agda uses inj_1 and inj_2 for its sums.
15:09:02 <voidzero> for Either I was thinking about ⇆
15:09:27 <voidzero> (I agree that what I'm doing is trivial, but hey, it's fun)
15:10:11 <fosterite> that symbol makes more sense for Iso
15:10:13 <Hafydd> Are you also going to rename all the utility functions like isLeft, isRight?
15:10:33 <fosterite> left = ì, right = í
15:10:35 <voidzero> oh no, it's just for viewing
15:10:37 <Eduard_Munteanu> voidzero, https://github.com/agda/agda-stdlib/blob/master/src/Data/Sum.agda
15:10:42 <voidzero> I'm using vim-haskellConcealPlus
15:10:47 <fosterite> you could rename either to î
15:10:55 <Hafydd> Heh.
15:10:56 <Hafydd> I see.
15:11:17 <voidzero> it conceals characters, but the characters it currently uses don't work with my terminal/font
15:11:22 <voidzero> so I'm playing with alternatives
15:11:45 <voidzero> the code will still contain the words Either, Left, and Right :)
15:11:53 <dfranke> Would anyone mind compiling the vector-0.11.0.0 test suite and see if GHC hangs on tests/Tests/Vector.hs when called with -O2?
15:11:58 <dfranke> I'm seeing this on NixOS.
15:12:35 <dfranke> whoop... or maybe I just didn't wait long enough. It just got through after churning for about 10 minutes.
15:12:41 <voidzero> I could use ☹ for Left and ☺ for Right, but that's tacky
15:13:40 * hackagebot ipython-kernel 0.7.0.0 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.7.0.0 (gibiansky)
15:13:42 * hackagebot ihaskell 0.7.0.0 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.7.0.0 (gibiansky)
15:14:27 <fosterite> voidzero: I find this page useful for this sort of thing https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode
15:14:54 <voidzero> ha
15:15:01 <voidzero> fosterite, I was just viewing https://en.wikipedia.org/wiki/List_of_mathematical_symbols
15:15:13 <voidzero> via the link Hafydd shared
15:15:29 <erisco> am I supposed to avoid orphans by using newtype wrappers?
15:15:35 <voidzero> yours is useful too, thanks
15:16:38 <voidzero> now to find ones that are actually supported by my font
15:16:39 <erisco> this would not work though because of contexts
15:16:49 <erisco> you'd have to reimplement the entire type...
15:16:57 <erisco> so not sure how you're supposed to do anything about having orphans
15:17:03 <Gurkenglas> Why are free and recursion-schemes separate packages?
15:18:24 <fosterite> voidzero: the unicode page has crazeir ones like ⥤, ⟰, ⧛ and ⧚
15:18:32 <fosterite> those last are a nice directional pair
15:19:41 <voidzero> yes, but don't display with Terminus. I'll settle on ⧎, ⧔ and ⧕
15:19:47 <voidzero> some of them are hard to differentiate
15:20:00 <voidzero> and I'm wasting way too much time with this kind of twiddling hehe
15:20:03 <ttt_fff> does it ever make sense to use HUNGARIAN notation in haskell? given that the type sig gives away the types on the spot
15:20:24 <fosterite> ttt_fff: well, we do have all the hGet functions
15:20:41 <ttt_fff> yeah, but isn't "Get" nore about what it does
15:20:45 <ttt_fff> rather than about any type sig ?
15:22:24 <Hafydd> <voidzero> for Either I was thinking about ⇆
15:22:26 <Hafydd> <voidzero> I could use ☹ for Left and ☺ for Right, but that's tacky
15:22:30 * Hafydd smirks.
15:22:47 <ttt_fff> that can't work
15:22:54 <ttt_fff> because they're unicode symbols, not unicode letters
15:23:36 <voidzero> EmojiHaskell
15:23:50 <Hafydd> Hahah.
15:23:52 <fosterite> ttt_fff: he's just using them as display overrides
15:24:04 <ttt_fff> then it screws up identation
15:24:08 <ttt_fff> tried it with vim conceal
15:24:14 <ttt_fff> -- comments no longer match up
15:24:20 <voidzero> yes, https://github.com/enomsg/vim-haskellConcealPlus
15:25:22 <squidp>  should i be installing packages with cabal or stack?
15:25:29 <ttt_fff> also, it's irritating when moving up/down with j/k and seeing lines shorten/expand
15:25:38 <ttt_fff> it's like trying to edit a file in wack-a-mole mode
15:25:49 <noodles1> The function definded as "i x (y:z) = (x y):(i x z)" will fail pattern matching when it reaches the end of the list since there's no pattern for lists smaller than 2 elements, no?
15:26:07 <serendependy> Hafydd, How about ⊎ for Either?
15:26:14 <Cale> noodles1: Smaller than 1 element
15:26:18 <serendependy> Because that's literally what Agda uses...
15:26:40 <Cale> noodles1: (y:z) will match the list [v] = v : [], with y = v and z = []
15:26:45 <voidzero> serendependy, works for me
15:27:03 <Hafydd> serendependy: at least that makes a small amount of mathematical sense.
15:27:26 <fosterite> serendependy: perfectly matches actual meaning, nice
15:27:26 <serendependy> Hafydd, It makes a great deal of mathematical sense. But it's not the funnest thing to work with
15:27:31 <Hafydd> (But it's still APL-style tacky.)
15:28:25 <Hafydd> I don't think people should take Unicode's inclusion of mathematical symbols as a cue that Unicode text strings can be used as a substitute for typeset mathematics.
15:29:18 <Hafydd> And perhaps it was even a mistaske to include them.
15:29:20 <Hafydd> -s
15:29:57 <fosterite> Hafydd: at the same time, typeset code often looks wrong. especially with ad-hoc operators. Every ligature for >>= is just "squish them together"
15:30:51 <fosterite> and every time i've seen <*> or <$> in latex it's been a star or dollar sign forced into a chinese-prison-sized diamond
15:30:56 <Hafydd> A good way to typeset code in LaTeX: \begin{verbatim} ... \end{verbatim}.
15:31:07 <Hafydd> Or \verb| ... |, for inline code.
15:31:34 <squidp> stack or cabal?
15:31:48 <voidzero> i compiled a large list of glyphs here, https://gist.github.com/voidzero/854d8787abdfa687e6bc
15:32:16 <fosterite> Hafydd: don't forget to make everything italic!
15:32:22 <Hafydd> Heh.
15:33:16 <voidzero> in the unicode table, ⊎ is called 'multiset union'
15:33:27 <noodles1> Cale: right, because (y:z) z can be the empty list... (beat me too it). Ok, I'm also trying to figure out how the interpreter assigns types. The way  I work out the type in my head of "i x (y:z) = (x y):(i x z)" is x is a function "a->a->a", i's 'a function that takes a function a->a->a and a list of type a, and recursively calls the function on the head of the list concatenating the results into a new
15:33:28 <noodles1> list.' Obviously that's not a viable way to name types, so ghci says the type is "i :: (t -> a) -> [t] -> [a]"
15:33:41 * hackagebot milena 0.3.0.0 - A Kafka client for Haskell.  https://hackage.haskell.org/package/milena-0.3.0.0 (tylerholien)
15:35:20 <noodles1> So it reassigns the "a->a->a" as t, however I don't see why the third parameter is [t].
15:37:23 <Cale> noodles1: third parameter?
15:37:32 <fosterite> noodles1: it's [t] because x :: t -> whatever , it is a list of things you can x
15:38:41 * hackagebot ihaskell 0.7.0.1 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.7.0.1 (gibiansky)
15:38:44 <Cale> noodles1: There are two parameters. x, which must be some type of function, because it is being applied to y on the right hand side of the equation. So suppose it's a function of type t -> a (for arbitrary types t and a which might be constrained later). Then y :: t in order to be a valid argument to this function.
15:39:05 <Cale> noodles1: So, (y:z) :: [t]
15:39:30 <Cale> and the right hand side of the equation, (x y):(i x z) :: [a], because it's a list starting with x y :: a
15:39:35 <ttt_fff> :t liftA4
15:39:36 <lambdabot>     Not in scope: ‘liftA4’
15:39:36 <lambdabot>     Perhaps you meant one of these:
15:39:36 <lambdabot>       ‘liftA’ (imported from Control.Applicative),
15:39:40 <ttt_fff> what" there's no liftA4 ?
15:39:47 <Welkin> ttt_fff: nope
15:39:51 <Welkin> you can write it
15:40:47 <Cale> Of course, i x z will need to have type [a] as well, in order to be the tail of that list, but that tells us nothing we didn't already know
15:40:51 <kadoban> It's kinda funny that there's a liftA, heh.
15:41:07 <Cale> kadoban: Is it?
15:41:25 <kadoban> A bit. Like fmap didn't already have enough aliases?
15:41:34 <Cale> It's useful for defining instances of Functor if you've already implemented the instance of Applicative.
15:41:40 <ttt_fff> matthew effect
15:41:43 <shachaf> liftA is like fmapDefault
15:41:44 <Cale> You can write  instance Functor MyType where fmap = liftA
15:41:45 <kadoban> Ahh, I see
15:41:45 <ttt_fff> ops with aliases get more aliases
15:41:49 <ttt_fff> ops with no aliases get no aliases
15:42:37 <Cale> noodles1: anyway, does that explanation make sense?
15:43:31 <Cale> noodles1: So the first argument to i has type (t -> a), the second argument to i has type [t], and the result has type [a], thus i :: (t -> a) -> [t] -> [a]
15:44:24 <noodles1> Cale: I *think* so, my mind is slower than usual today, but it's making more sense now. The part I was missing was that t is an arbitrary type, where as 'a' can be constrained.
15:45:41 <Cale> noodles1: a didn't get constrained either
15:46:08 <Cale> noodles1: Both of them might have been constrained as we inspected parts of the definition of i, but as it happened, they weren't.
15:51:01 <noodles1> Cale: right, but the reason x isn't of type: "a->a->a" is because x can be (+1) which is contrained to Num, and (y:z) could be constrained to Integral
15:51:09 <Cale> hm?
15:51:45 <Cale> What about Num and Integral?
15:52:08 <Cale> There are no numeric operations involved in this definition, so you don't have to worry about those type classes at all.
15:52:18 <Cale> They aren't involved in any way
15:54:15 <Cale> (Unless I'm missing some important bit of context, anyway)
15:54:36 <noodles1> I was trying to make an example of why x is of type (t->a) when x could be (+1), which is of type "a->a"
15:55:34 <Cale> Well, okay, so if we pass an argument of type Integer -> Integer, say, then t = Integer and a = Integer, and the type of i gets specialised to (Integer -> Integer) -> [Integer] -> [Integer]
15:56:32 <Cale> The definition of i is essentially the definition of map (without the base case, and with more confusing choices of variable names)
15:56:36 <Cale> :t map
15:56:37 <lambdabot> (a -> b) -> [a] -> [b]
15:56:39 <Cale> @src map
15:56:40 <lambdabot> map _ []     = []
15:56:40 <lambdabot> map f (x:xs) = f x : map f xs
15:58:59 <Cale> We can apply map :: (a -> b) -> [a] -> [b] to (+) :: (Num n) => n -> (n -> n), using a = n and b = n -> n, making its type specialise to (Num n) => (n -> (n -> n)) -> [n] -> [n -> n]
15:59:03 <Cale> :t map (+)
15:59:04 <lambdabot> Num a => [a] -> [a -> a]
16:00:14 <noodles1> Cale: yes, I get the bigger picture, I'm just confused by the letters chosen for the types. Here's a sidebar question: map (+1) [1..2] :: (Enum b, Num b) => [b]
16:00:24 <noodles1> i (+1) [1..2] :: (Enum a, Num a) => [a]
16:00:32 <Cale> Oh, don't worry about the letters, they're arbitrary
16:00:59 <noodles1> ok, I thought the different in a and b might have something to do with the missing base case for i
16:01:02 <Cale> If an explicit type signature is given that uses type variables, GHC will try to maintain the letters which got used
16:01:19 <Cale> However, when it unifies two variables with each other, it can only keep one of the two choices
16:01:30 <Cale> So it just picks one of them
16:01:43 <Cale> It matters that a and b are different
16:01:56 <Cale> but (c -> d) -> [c] -> [d] is the same type as (a -> b) -> [a] -> [b]
16:02:17 <fr33domlover> Is there a standard function for interleaving lists?
16:02:34 <fr33domlover> I can write one, just curious why I can't find one :P
16:02:44 <Cale> fr33domlover: You asked that a while ago, I remember answering you. There is not, however, there is transpose.
16:03:25 <fr33domlover> Cale, you sure it was me? :P sorry if I'm asking twice...
16:03:35 <Cale> I thought so...
16:03:42 * hackagebot hjsmin 0.1.5.1 - Haskell implementation of a javascript minifier  https://hackage.haskell.org/package/hjsmin-0.1.5.1 (ErikDeCastroLopo)
16:04:22 <mauris> "interleaving lists"?
16:04:24 <Cale> Maybe it wasn't! :)
16:04:52 <Cale> > (\xs ys -> concat . transpose $ [xs, ys]) ['0'..'9'] ['a'..'j']
16:04:53 <lambdabot>  "0a1b2c3d4e5f6g7h8i9j"
16:05:32 <fr33domlover> Cale, thanks
16:06:45 <erisco> so, why do API breaking changes get two version number spots? i.e. why are major versions A.B.*
16:07:16 <noodles1> Cale: ok, I tried to make an example, "foo :: [Integer] \ foo = [1..5]"  I believed that the type of "i (+1) foo" would be "(Num :: a->a) [Integer] -> [Integer]" since (+1) is constrained to Num and the result must???? be an Integer
16:07:31 <erisco> and then why two spots for non-API changes?
16:07:32 <Hafydd> I'd guess because some API-breaking changes are "minor," according to the opinion of the developer, and some are major.
16:08:12 <noodles1> however the type is "i (+1) foo :: [Integer]" which only confuses me more. Thanks for your patience, this is dragging on..
16:08:38 <Cale> noodles1: The type you believed the result would have is syntactically invalid.
16:08:56 <Hafydd> erisco: for the latter two version numbers, see: https://wiki.haskell.org/Package_versioning_policy
16:10:44 <Cale> noodles1: Type classes such as Num are used to constrain the set of types which type variables range over to those types which implement certain functionality (e.g. for Num, this includes a definition of (+), (*), fromInteger, and a handful of other operations)
16:11:52 <Cale> noodles1: "(Num a) => ..." means that the type variable 'a' is only allowed to be instantiated to a type which is an instance of the type class Num, in the type which follows the =>
16:13:01 <noodles1> Cale: I just had an aha moment
16:13:09 <Cale> For example, a might be specialised to Integer, Float, Rational, or Complex Double, but attempting to pick a = String would result in an error unless an instance of Num were to be provided for String (which would generally be a bad idea)
16:13:16 <erisco> ugh having trouble finding the right doc page
16:13:29 <erisco> what are the implicit exports for modules if you don't have an explicit export list?
16:13:40 <Cale> erisco: Everything
16:13:48 <erisco> I'd like to not have to retype everything I declare, likely to forget something
16:13:52 <erisco> hard to test everything is present
16:13:59 <erisco> what is "everything"?
16:14:06 <erisco> does that include imports?
16:14:23 <Cale> Okay, everything defined *in that module*, not things which were imported.
16:14:38 <erisco> alright, I'll leave the list implicit then
16:15:00 <erisco> explicit imports, implicit exports
16:17:06 <orion> Does anyone know if the scientific library is capable of preserving sigfigs?
16:17:18 <numee> is :load'ing a file the only way to declare a function in which `where` comes in the next line to the binding line (f = ... \n where ...) in GHCi? i'm too lazy to save a code fragment just to execute...
16:19:33 <athan> orion: Don't you mean sigdigs? :)
16:19:38 <athan> That actually sounds like a fun library
16:20:17 <athan> numberten: I think semicolons delimit lines, maybe there's a way? One sec
16:20:29 <athan> Sorry I meant numee
16:20:55 <ttt_fff> what is the advantage of trifecta over parsec?
16:21:01 <athan> @let foo = bar where bar = 0 -- numee
16:21:02 <lambdabot>  Defined.
16:21:05 <athan> > foo
16:21:07 <lambdabot>  0
16:21:14 <danso> > foo
16:21:15 <lambdabot>  0
16:21:43 <athan> ttt_fff: I always have trouble seeing when Parsec backtracks, maybe trifecta makes this more explicit? :s
16:21:46 <athan> @unset
16:21:46 <lambdabot> Unknown command, try @list
16:21:49 <athan> er...
16:21:56 <athan> @unset foo -- ?
16:21:56 <lambdabot> Unknown command, try @list
16:21:57 <orion> athan: I suppose. It really irks me that scientific thinks 1 == 1.000 == 1.000000
16:22:10 <Cale> numee: no, you should be able to use where
16:22:12 <noodles1> "i :: (t -> a) -> [t] -> [a]" I was getting hooked up on the t and couldn't see the forrest for the trees. i takes a function that goes from (t->a) and an [t] and returns [a]. The reason for two types is because of the possibility for the first arg of map to be a func that returns a different type than it receives
16:22:25 <Cale> numee: But it's usually a good idea to always have a file with code anyway
16:22:42 <Cale> noodles1: correct
16:22:46 <athan> orion: I'll try and make one, one sec
16:24:15 <serendependy> > map (("showing: " ++) . show) [1..10]
16:24:17 <lambdabot>  ["showing: 1","showing: 2","showing: 3","showing: 4","showing: 5","showing: ...
16:24:34 <serendependy> @type map (("showing: " ++) . show)
16:24:35 <lambdabot> Show a => [a] -> [[Char]]
16:24:43 <erisco> value is incoming
16:25:26 <Welkin> erisco: danger! collision imminent!
16:25:54 <erisco> where should I report TH issues?
16:26:37 <noodles1> thanks serendependy 
16:26:46 <noodles1> & Cale of course
16:27:19 <erisco> oh, there is just a package for it, duh, and a bug tracker
16:27:31 <erisco> my memory isn't working right now... tired xX
16:28:11 <serendependy> Might be easier to see with:
16:28:25 <serendependy> @type map (("showing: " ++) . (show :: Int -> String))
16:28:26 <lambdabot> [Int] -> [[Char]]
16:28:43 * hackagebot regex-tdfa-quasiquoter 0.2.0.0 - Quasi-quoter for TDFA (extended POSIX) regular  expressions.  https://hackage.haskell.org/package/regex-tdfa-quasiquoter-0.2.0.0 (erisco)
16:28:51 <erisco> value has arrived!
16:32:50 <numee> Cale: it seems like i can't. ghci tells me a parsing error. see: http://pastebin.com/iksxW1BE
16:32:58 <athan> orion: We can make this lossy, with the correct semantics, right? So we could trim the unneccessary digits?
16:35:04 <orion> athan: We can only trim insignificant digits.
16:35:17 <athan> That's what I meant, okay
16:35:37 <orion> In "1.0000", you can't trim the zeros.
16:36:28 <athan> Only because the literal explicitly states the significance, correct?
16:36:53 <athan> orion: Did you see this? https://hackage.haskell.org/package/numeric-limits-0.1.0.0/docs/Numeric-Limits.html
16:37:57 <orion> athan: Correct. No, I did not try it. It just seems like a bunch of constants.
16:38:06 <athan> hm
16:38:30 <athan> orion: I'll keep working on this, I'm not sure if I would be qualified enough to make a replacement for scientific, but I know I can augment it
16:41:36 * geekosaur is not sure that precision belongs in the display format. especially if it's not storing in decimal...
16:42:28 <numberten> mistakenly pinged! such false hope D:
16:42:31 <numberten> athan: :p
16:42:37 <geekosaur> (I don't know if it does or not. floating point is base 2, and trying to determine precision of a base 10 decimal number within a base 2 storage representation is guaranteed to fail)
16:43:20 <athan> numberten: Your name is cool though! :C
16:43:28 <numberten> ty
16:43:32 <slack1256> Do hackage votes count for something? or is like github starts?
16:43:35 <slack1256> *stars
16:44:31 <geekosaur> they do not
16:45:33 <geekosaur> even without representation base as an issue, I think precision handled that way is asking for trouble. unless you go the Data.Fixed way.
16:48:00 <Cale> numee: The problem is just that because the line on which 'where' occurs is indented less than the first non-whitespace character following the 'let' (that is, the name of the function 'a'), it is not part of the let block, which isn't what you want.
16:48:39 <Cale> numee: If you indent it further, it works
16:48:41 <lpaste_> Cale pasted “like so” at http://lpaste.net/139647
16:50:05 <noodles1> Is there a way to see all functions of a certain type? For example, if I wanted to see all functions of type a->[a] ?
16:50:15 <noodles1> Using ghci**
16:50:49 <athan> noodles1: That's a hard question, but we use Hoogle / Hayoo for most of that
16:51:14 <athan> I think a local lambdabot install / ghci-ng helps with that
16:51:20 <athan> (but that's hard to get working)
16:51:54 <Gurkenglas> (Here's all of them: map replicate [0..])
16:52:05 <Cale> noodles1: no, however, there is a search engine called hoogle which might interest you
16:52:08 <noodles1> athan: I figured as much for Hoogle, but seeing whats in scope would be nicer
16:52:08 <numee> Cale: thanks! haskell's indentation rules are much more difficult than python's...
16:52:11 <athan> wait, scratch ghci-ng
16:52:22 <geekosaur> goa
16:52:37 <athan> noodles1: I could see a type-signature augmented tab completion being useful :)
16:52:52 <geekosaur> (ghci on acid, an interface between ghci and lambdabot)
16:52:54 <Gurkenglas> (Ah dang I forgot repeat. And don't you start with \x -> [x, undefined, x])
16:53:36 <athan> geekosaur: YES thank you!
17:00:11 <Hijiri> > [False..]
17:00:12 <lambdabot>  <hint>:1:9: parse error on input ‘]’
17:00:26 <Hijiri> > [False ..]
17:00:29 <lambdabot>  [False,True]
17:03:45 * hackagebot google-cloud 0.0.2 - Client for the Google Cloud APIs  https://hackage.haskell.org/package/google-cloud-0.0.2 (wereHamster)
17:04:12 <arkeet> @free f :: a -> [a]
17:04:12 <lambdabot> $map g . f = f . g
17:12:52 <Jookia> is there an operator equivalent to <$> but joins at the end?
17:13:12 <Arahael> Jookia: "joins at the end"?
17:13:13 <Jookia> ie "join $ a <$> b <*> c <*> d"
17:13:33 <Jookia> Arahael: like that i just wrote
17:13:55 <Arahael> Oh, so you mean, without doing "join $ ( a <$> b <*> c <*> d )"?
17:14:02 <Jookia> yes
17:14:39 <Jookia> i've tried =<< but that doesn't seem to be right
17:14:44 <Arahael> I'm still very new to haskell, but I wonder if you could make another infix operator, <$!>, and <*!>, that have a higher precendence compared to $.
17:15:41 <glguy> 'a <$> b <*> c' parses as '(a <$> b) <*> c', so it'll probably be tricky to write a an operator to replace <$> like you want
17:16:17 <Jookia> ah, i'm not really looking for an operator but more a solution
17:16:53 <glguy> do x <- b; y <- c; a x y   or what you wrote is the solution
17:17:23 <Jookia> are you sure?
17:19:26 <orb_> Jookia, try liftA2.
17:19:37 <orb_> Oh, wait, that wouldn't help here.
17:20:06 <orb_> You want to basically something which is to bind (=<<) as liftA2 is to fmap.
17:20:43 <Jookia> hmm
17:21:27 <orb_> https://www.haskell.org/hoogle/?hoogle=(a+-%3E+b+-%3E+m+c)+-%3E+m+a+-%3E+m+b+-%3E+m+cThe hoogle search would be
17:21:37 <orb_> But hoogle doesn't have anything of the right type.
17:21:53 <Jookia> I guess join $ liftM5 seems to be the way to go
17:22:09 <orb_> That's the idiom we settled on in our code.
17:22:24 <Jookia> that's good to hear
17:22:41 <orb_> if you do join anyway, it doesn't make a difference whether you use liftM5 or f <$> a <*> ... <*> e
17:23:18 <Jookia> oh i know, the verbose <$> / <*> got me over my line limit so eh
17:24:14 <orb_> I sometimes declare (.:) f g a b = f (g a b)
17:24:16 <orb_> and similar.
17:24:29 <orb_> For when you want more parameters for your composition of functions.
17:24:36 <Jookia> neat
17:24:42 <orb_> in this case: join .: liftM2
17:25:02 <orb_> .: also has a point-less version:
17:25:11 <orb_> fmap fmap fmap, I think.
17:26:07 <Jookia> neat, i'll have to look in to this more - i was just worried about doing something wrong
17:26:22 <Jookia> or rather, unnecessarily inelegantly
17:26:30 <orb_> Only works because (.) is an fmap, too.  But please never ever use that as a definition of (.:).  It's confusing.  (Though, the type says it all, so the implementation doesn't matter too much.)
17:26:48 <orb_> Jookia, hlint can tell you about some inelegancies.
17:27:05 <Jookia> my hlint is broken atm :P
17:27:38 <Jookia> but yeah i tend to run it
17:51:01 <mniip> edwardk, you around?
17:51:37 <mniip> why is there no instance (a ~ b) => Representable (a, b)
17:51:49 <mniip> where type Rep = Bool
17:52:32 <glguy> mniip: Is the answer "kind error"?
17:53:14 <slack1256> I got confussed about how haddock represents GADTs. https://i.imgur.com/YhivhQw.png
17:53:44 <mniip> glguy, hmm?
17:53:51 <slack1256> I understand that (k -> *) -> * on the haddock data declaration are the kinds of Some
17:54:04 <mniip> oh crap
17:54:16 <slack1256> but why does `This` returns `Some k tag` instead of `Some tag`?
17:54:27 <mniip> you're correct, it needs to be a covariant functor
17:54:28 <glguy> slack1256: That's the "PolyKinds" extension at work
17:55:07 <slack1256> Oh, I need to consult the ghc's user guide for a moment
17:56:49 <mniip> glguy, hmmm Join (,) where newtype Join f a = Join (f a a)
17:57:09 <mniip> not as elegant though
18:01:52 <SrPx> Is anyone aware of an implementation of the Z order curve formula?
18:02:35 <slack1256> glguy: So the extra k in `Some k tag` is a haddock hint to telling me it is polykinded?
18:04:56 <shirt> is there a function of type: Either a b -> Maybe b
18:06:51 <mauris> SrPx, this is a little overkill but it's an interesting read https://www.fpcomplete.com/user/edwardk/revisiting-matrix-multiplication/part-1
18:07:29 <slack1256> @hoogle Either a b -> Maybe b
18:07:30 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
18:07:30 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
18:07:30 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
18:07:56 <Hijiri> :t either (const Nothing) Just
18:07:57 <lambdabot> Either b a -> Maybe a
18:07:58 <mauris> :t either (const Nothing) Just
18:07:59 <lambdabot> Either b a -> Maybe a
18:08:13 <slack1256> > either (const Nothing) Just $ Left 5
18:08:14 <lambdabot>  Nothing
18:08:21 <slack1256> > either (const Nothing) Just $ Right 5
18:08:22 <lambdabot>  Just 5
18:08:26 <slack1256> noice
18:08:27 <SrPx> Is "edwardk did it" the "simpsons did it" of this channel? 
18:08:33 <Hijiri> :t const Nothing
18:08:34 <lambdabot> b -> Maybe a
18:08:37 <Hijiri> this would fit the type too
18:08:43 <slack1256> sometimes is varies to Oleg instead of edk
18:09:03 <slack1256> there is also 'Which of the simons did it?'
18:09:22 <mauris> http://hackage.haskell.org/package/either-4.3.3.2/docs/Data-Either-Combinators.html#v:rightToMaybe
18:11:29 <mauris> shirt, ^ if you really don't want to implement it yourself, Data.Either.Combinators has you covered
18:11:46 <slack1256> @foldMap
18:11:46 <lambdabot> Unknown command, try @list
18:11:50 <slack1256> @type foldMap
18:11:51 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
18:12:01 <slack1256> Maybe is a monoid and Either is Foldable
18:13:14 <monochrom> yikes
18:13:28 <shirt> mauris: thanks
18:13:35 <monochrom> > foldMap Just (Either "x" True)
18:13:37 <lambdabot>      Not in scope: data constructor ‘Either’
18:13:37 <lambdabot>      Perhaps you meant variable ‘either’ (imported from Data.Either)
18:13:47 <monochrom> oops
18:13:52 <monochrom> > foldMap Just (Right True)
18:13:54 <lambdabot>      No instance for (Monoid Bool) arising from a use of ‘foldMap’
18:13:54 <lambdabot>      In the expression: foldMap Just (Right True)
18:14:10 <slack1256> instance Monoid a => Monoid (Maybe a) is no fun
18:14:40 <monochrom> I see. nevermind.
18:15:26 <shirt> why wasn't "rightToMaybe" found in the hoogle search?
18:15:47 <slack1256> Hoogle only searchs on "core" package
18:15:50 <shachaf> Because it didn't search "either".
18:15:54 <slack1256> hayoo searches on a lot more
18:16:01 <Welkin> hoogle sucks
18:16:06 <Welkin> I tend to use hayoo these days
18:16:07 <slack1256> @hayoo Either a b -> Maybe b
18:16:07 <lambdabot> Unknown command, try @list
18:16:14 <shachaf> If you use lens, the answer is "preview _Right"
18:16:19 <Welkin> only use hoogle for searching a typ signature
18:16:31 <slack1256> but if you use lens, then you have two problems ;-)
18:17:02 <neuroserpens> Can anyone explain to me why I hear people saying tabs mess everything up in haskell?
18:17:12 <Welkin> neuroserpens: use spaces
18:17:20 <Welkin> spaces and spaces do not mix
18:17:22 <Welkin> er
18:17:26 <Welkin> tabs and spaces do not mix
18:17:31 <slack1256> he asked for a why
18:17:37 <neuroserpens> slack1256: thanks...
18:17:37 <Welkin> haskell uses whitespace for formatting
18:17:51 <neuroserpens> Welkin: that much is obvious
18:18:40 <slack1256> I heard a  time ago that internally ghc transforms tabs into 4 spaces.
18:18:45 <neuroserpens> slack1256: Is it because if other people ...
18:18:47 <slack1256> and thus it can mess you indentation?
18:19:05 <neuroserpens> slack1256: yea i guessed that much... something that converts tabs into different numbers of spaces in other platforms...
18:19:28 <slack1256> I am sure is just a syntactic thing, nothing fundamental
18:19:43 <neuroserpens> slack1256: If that's the only reason then conversion to spaces is to be blamed...
18:20:16 <slack1256> I wonder
18:21:41 <zuserm> hello folks
18:22:07 <slack1256> hello
18:23:32 <slack1256> > foldMap Just (Right () )
18:23:34 <lambdabot>  Just ()
18:23:41 <slack1256> > foldMap Just (Left () )
18:23:42 <lambdabot>  Nothing
18:24:17 <zuserm> does anyone know how to get information about a module (identifiers and their haddocks) in code?
18:24:30 <Iceland_jack> zuserm: :browse (:bro) 
18:24:56 <Iceland_jack> If you want to do it programmtically (in code) I'm not sure
18:25:01 <Iceland_jack> *programmaticaly
18:25:07 <Cale> Perhaps use haskell-src-exts to parse the code?
18:25:14 <Iceland_jack> too lazy to spell correctly
18:25:21 <slack1256> you can if you use the GHC-api but then you got to blunde it along
18:25:28 <slack1256> *bundle
18:25:41 <Cale> http://hackage.haskell.org/package/haskell-src-exts
18:25:59 <zuserm> Cale: thanks, I'll take a look
18:26:21 <Cale> That won't do anything special with the Haddock documentation, but it does capture the comments of the parsed code.
18:26:25 <slack1256> also check out how ghc-mod gets module and type information 
18:26:45 <slack1256> info on it tells you where the haddock documentation is located
18:29:19 <Cale> However, it might be a bit tricky to work out which comments go with what, because they don't end up in the parse tree -- however, they are tagged with source location information (SrcSpan) which you could compare with the source locations of various things in the resulting parse tree.
18:30:19 <zuserm> I'm sure if I care about the docs or not, so it might not end up being an issue.
18:41:15 <GLM> How can I define a maximum function for something like foldr?
18:41:34 <Iceland_jack> You mean in terms of something like foldr?
18:42:50 <GLM> Iceland_jack:Yeah
18:43:36 <zuserm> GLM: foldr1 max
18:43:44 <Iceland_jack> You can get a source in terms of 'foldl1' using @src maximum 
18:43:48 <Iceland_jack> @src maximum
18:43:48 <lambdabot> maximum [] = undefined
18:43:48 <lambdabot> maximum xs = foldl1 max xs
18:44:30 <GLM> Iceland_jack:That was my issue. I tried putting in (>)
18:45:48 <mniip> :t foldr1 (>)
18:45:49 <lambdabot> Foldable t => t Bool -> Bool
18:48:08 <marchelzo> Hi. What is the Hayoo vs Hoogle situation looking like? Is one of them better than the other, or are they both useful?
18:49:03 <geekosaur> hayoo is better at fuzzy names, hoogle at fuzzy types
18:50:18 <marchelzo> I see
18:52:07 <camm_v222> What do you mean with fuzzy names and fuzzy types?
18:53:12 <XorSwap> less specific?
18:53:57 <Welkin> fuzzy logic :P
18:54:01 <Welkin> I see
19:18:08 <shirt> Network.Socket.ByteString.recv: "If the message is longer than the specified length, it may be discarded depending on the type of socket"
19:18:17 <shirt> can this really happen? sounds really bad
19:19:18 <arkeet> I'm guessing for e.g. UDP
19:21:22 <shirt> let's hope that that's the only case
19:21:31 <arkeet> see first answer http://stackoverflow.com/questions/2862071/how-large-should-my-recv-buffer-be-when-calling-recv-in-the-socket-library
19:21:54 <shirt> but i don't think that the Network.Socket.ByteString functions work with UDP
19:22:30 <arkeet> why not?
19:23:04 <arkeet> the bsd socket api works for both
19:23:26 <arkeet> which network is based on
19:25:08 <arkeet> anyway, that note is just copied from the manpage http://linux.die.net/man/2/recv
19:26:03 <shirt> ok so if i'm using TCP or unix sockets then i don't have to worry?
19:26:10 <arkeet> right
19:26:33 <arkeet> anything that didn't fit in the given size will get returned on the next read call
19:26:59 <shirt> thanks
20:06:06 <ReinH> Looks like we have another guest for the Haskell Cast. Super excited.
20:11:47 <rcyr> OMG, been waiting for the next one since dec 14th 2014 :(
20:11:59 <rcyr> (I remember the date by heart :( )
20:14:30 <adarqui> opaleye has this printSql func in their tutorial.. where is it? heh! i don't see it on hoogle etc. anyone have an idea? 8|
20:16:30 <adarqui> i think they changed it to use showSqlFor*, tutorial is probably just wrong
20:37:48 <SrPx> Is it redundant to use a bang pattern in an int argument?
20:38:54 * hackagebot arithmetic 1.1 - Natural number arithmetic  https://hackage.haskell.org/package/arithmetic-1.1 (JoeHurd)
20:39:03 <rsa111> Hi, how to raise an exception to a main thread of the application without knowing it's threadId?
20:40:04 <SrPx>  
20:40:05 <SrPx>  
20:40:21 <SrPx> My bad.
20:41:49 <c_wraith> rsa111: No clean way to do that.  You'll need to get its ThreadId one way or another.
20:43:06 <Hijiri> SrPx: no
20:43:38 <rsa111_> c_wraith: :( that's bad
20:44:31 <rsa111_> actually my use case is to stop handling further request if something bad happens! I have three threads - driver, db and app
20:44:46 <c_wraith> rsa111: It's not *so* bad.  main is the entry point, after all.  You can pass the ThreadId to whatever needs it.
20:46:14 <rsa111_> c_wraith: but in situation where bad things can happen in multiple threads, I need to pass tid to every thread right?
20:47:59 <c_wraith> rsa111_: Yeah, but that's not so bad in practice.
20:54:01 <lpaste_> wizao pasted “Function Monad” at http://lpaste.net/139652
20:55:55 <lpaste_> Lokathor pasted “Strange type error” at http://lpaste.net/139653
20:56:30 <Lokathor> ghc says i've got an extra Integer term floating around, but i'm not sure where it's coming from at all.
21:02:45 <glguy> Lokathor: You're missing the ambientColor field from your Shader record
21:03:19 <Lokathor> ohhhhhhhhhhh, oh my
21:05:25 <glguy> wizao: Do you specifically not understand what =<< expands to using the (->)r Monad instance or did you have another question?
21:05:57 <Lokathor> i guess you are the gl guy after all
21:05:58 <glguy> Also, don't use the point-free tool for anything more than novelty (in case you were actually thinking of using that implementation for anything)
21:06:03 <wizao> I'm having trouble understanding how the =<< has type (Double -> Double) -> Bool
21:06:29 <glguy> It doesn't
21:06:47 <wizao> right i don't know what it is
21:07:09 <glguy> :t ((==) =<<) -- Is this the part that is confusing?
21:07:10 <lambdabot> Eq a => (a -> a) -> a -> Bool
21:07:32 <wizao> the first param to until
21:08:08 <glguy> until =<< ((==) =<<) parses like this:
21:08:23 <glguy> (=<<) until ((=<<) (==))
21:08:35 * monochrom squints
21:08:37 <glguy> so none of those are arguments to until, directly
21:09:03 <wizao> ohhh im dumb
21:09:05 <monochrom> :)
21:09:37 <wizao> I thought until (=<<) ((==) =<<)
21:09:46 <wizao> that makes sense now
21:10:30 <wizao> Also explains why I couldnt for the life of me understand why/how (=<<) was a predicate
21:10:50 <monochrom> haha
21:13:18 <lpaste_> frelux pasted “Lens+Map+State space leak” at http://lpaste.net/139655
21:13:58 <frelux> ^anyone have any thoughts on how to best fix the space leak there? (I understand why it happens, but don't have any nice-looking ideas)
21:14:54 <frelux> I seem to run into it in every program I write lately and would love to hear if there's a better approach
21:27:57 <monochrom> may I delete "id ."?
21:28:20 <monochrom> what does at "0" ?= show i do?
21:28:22 <glguy> yes, but it won't help :)
21:28:56 <frelux> ah, yes, you don't need the id, sorry : )
21:30:15 <johnw> sadly, State.Strict is not strict in its accumulator, and I'm guessing ?= is suffering from the same problem
21:30:22 <johnw> if you google for "State modify' strict", you should find earlier discussions about this
21:30:55 <monochrom> yeah. "Strict" refers to something else.
21:31:51 <monochrom> http://lpaste.net/41790/ to understand what Control.Monad.State.Lazy means, and by extension what Strict means.
21:32:31 <johnw> ahh
21:32:36 <johnw> thanks, monochrom 
21:35:12 <frelux> Aha, that's super helpful.
21:44:57 <GLM> Does anyone have time to review my code?
21:47:45 <kadoban> GLM: One way to find out ;)
21:48:03 <dmj> GLM: post it here
21:49:14 <GLM> https://gist.github.com/GarrettMosier/9d8755b7be047f8a2899
21:50:05 <dmj> GLM: ColumnStat has created a lot of partial functions
21:50:38 <dmj> GLM: for example (shortCount Numeric {}) will blow up
21:50:44 <GLM> dmj:Yes but I'm not sure how I can fix that
21:51:06 <dmj> GLM: you could use a GADT, or just define two seperate datatypes
21:51:29 <GLM> dmj:How would I go about doing that?
21:51:40 <dmj> GLM: also, never ever use String, except for the simplest of things. 
21:52:25 <dmj> GLM: one way is data Textual = Textual {..} ..  data Numeric = Numeric {..}
21:52:59 <dmj> GLM: you want to see a GADT example?
21:53:18 <GLM> dmj:Yes please. How would I be able to pass in both types if I split them up?
21:53:58 * hackagebot ihaskell 0.7.0.2 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.7.0.2 (gibiansky)
21:56:32 <dmj> GLM: a good example would be from the facebook package, I'll try to retrofit it to your scenario
21:56:37 <dmj> GLM: http://hackage.haskell.org/package/fb-1.0.11/docs/src/Facebook-Types.html#AccessToken
21:57:18 <GLM> Much appreciated
21:57:19 <dmj> GLM: also you want to newtype everything
21:57:28 <dmj> Int, Double, that could go everywhere and still typecheck
21:57:51 <dmj> GLM: also, use foldl' over foldl
21:58:31 <dmj> GLM: never use 'read' it's a dangerous function, always use readMaybe from Text.Read, line 85
21:59:23 <GLM> dmj:This will be on a stream so do I still want the strict version?
21:59:31 <GLM> dmj:What do you mean by newtype?
22:01:19 <gamegoblin> So I just made a datatype like       "data IncrementalValue m a = Partial (m (IncrementalValue m a)) | Complete a"       where you can repeatedly call a Partial which presumably does some work behind the scenes until you get a Complete. Is there a more common way of accomplishing this?
22:02:27 <dmj> GLM: I mean instad of doing Int -> Int -> Int, in your function signatures do, Count -> NullCount -> ShortCount, where Count is newtype Count = Count Int
22:02:33 <dmj> s/instad/instead
22:03:20 <pacak> gamegoblin: looks kind of like Free
22:03:45 <gamegoblin> pacak: in what way?
22:04:43 <glguy_> http://hackage.haskell.org/package/free-4.12.1/docs/Control-Monad-Trans-Free.html
22:04:51 <gamegoblin> pacak: just looked at the definition, it does look similar
22:07:24 <GLM> dmj:So do I do that in the record?
22:10:49 <dmj> GLM: you do a lot of updates, you might want to create lenses for these GADTs
22:11:09 <dmj> GLM: do what in the record? You add the newtypes inside the GADT yes
22:11:14 <GLM> dmj:Never done work with lenses either so some advice would be good
22:11:32 <GLM> dmj:Am I creating GADTs or splitting up the datatype?
22:14:03 <dmj> GLM: here check this out, http://lpaste.net/139662
22:15:52 <GLM> dmj: Does that have all the changes you were talking about?
22:16:58 <dmj> GLM: yea, do you see how using the GADT you can update a particular record in a type safe way? line 27. That function operates on *only* numeric, there is no chance a rogue function from a different constructor can be applied it ot
22:17:26 <dmj> GLM: you could have made it generic ColumnStat k -> Double -> ColumnStat k
22:17:30 <GLM> dmj:Yeah. I was trying to do that but couldn't seem to get it to work
22:18:43 <dmj> GLM: It's not an easy thing to do, so don't feel bad :)
22:18:59 <GLM> dmj:As long as I learn, I'm happy
22:20:08 <dmj> GLM: basically you get to be more specific about the return type of your ADT using GADTs which disallows certain behaviors. Types make things more specific. 
22:21:14 <GLM> Thanks. What did you mean by the "  -- | Type synonym for @'AccessToken' 'UserKind'@.                                                                                                                       
22:21:14 <GLM> " comment?
22:21:27 <gamegoblin> Is there an equivalent of `forever` for applicatives?
22:21:32 <dmj> GLM: that's the copy and paste from the fb package's example
22:21:40 <dmj> GLM: retrofitted to your example
22:21:54 <GLM> Should I be able to use that code in my example and have it work?
22:22:22 <pacak> gamegoblin: there's no join for Applicative...
22:22:25 <dmj> GLM: yea, it compiled for me
22:22:45 <GLM> dmj:Thanks. Be back after I have it working
22:23:58 <Lokathor> it works!
22:24:00 * hackagebot ihaskell 0.7.0.3 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.7.0.3 (gibiansky)
22:24:12 <Lokathor> i got the cube spinning demo to go, it looks like this gif http://dpwright.com/posts/2015/03/25/getting-up-and-running-with-gl/spinningCube.gif
22:34:14 <dmj> GLM: ok
22:36:31 <GLM> dmj:I get the error of "    Illegal generalised algebraic data declaration for ‘ColumnStat’"
22:40:24 <dmj> GLM: did you add the GADTs language pragma to the file
22:40:54 <GLM> dmj:Yeah
22:41:07 <dmj> GLM: did you use my code verbatim?
22:41:28 <GLM> dmj:Yeah
22:42:36 <GLM> Does it matter where I put it? I moved the pgrama to the top and it is acting differently
22:43:08 <OceanSpray> yo
22:43:31 <OceanSpray> anyone tried compiling the latest haskell platform for ARM yet?
22:44:05 <dmj> GLM: pragmas should always go on top
22:44:44 <dmj> GLM: the code I have verbatim on lpaste works
22:45:02 <GLM> dmj:Might not be playing well with my other code
22:45:38 <dmj> GLM: keep commenting stuff out till you find the culprit
22:53:42 <OceanSpray> I am actually stucxk
22:53:44 <OceanSpray> stuck
22:54:07 <GLM> dmj:I'm not able to show numeric
22:54:09 <OceanSpray> what is the "$PATH_TO_GHC_BINDIST_TARBALL" that hptool needs?
22:55:32 <dmj> GLM: can you paste what you're trying to do on lpaste
22:56:05 <dmj> GLM: you should be able to though
22:56:13 <dmj> > let a' = 4 :: Num a => a
22:56:14 <lambdabot>  <no location info>: not an expression: ‘let a' = 4 :: Num a => a’
22:56:23 <GLM> http://lpaste.net/139667
22:56:28 <dmj> > let a' :: Num a => a; a' = 4
22:56:29 <lambdabot>  <no location info>:
22:56:29 <lambdabot>      not an expression: ‘let a' :: Num a => a; a' = 4’
22:56:34 <dmj> > a' :: Num a => a; a' = 4
22:56:35 <lambdabot>  <hint>:1:17: parse error on input ‘;’
22:57:02 <dmj> @def a' = 4
22:57:03 <lambdabot>  Defined.
22:57:06 <dmj> @typ a'
22:57:08 <lambdabot> Num a => a
22:57:10 <dmj> > show a'
22:57:12 <lambdabot>  "4"
22:57:32 <dmj> GLM: oh numeric, not Num :) 
22:59:04 <dmj> GLM: you have to use StandaloneDeriving
22:59:06 <dmj> GLM: http://lpaste.net/139668
22:59:16 <dmj> GLM: and add 'deriving Show' to all your newtypes
23:00:23 <GLM> Thanks. Now I have plenty of new errors to resolve.
23:07:22 <dmj> GLM: :)
23:07:35 <anohigisavay> hi
23:07:58 <anohigisavay> i use Data.ByteString.Char8.readFile to read /proc/stat
23:08:04 <anohigisavay> and i get empty result
23:08:16 <anohigisavay> Data.ByteString.readFile works well
23:08:59 <anohigisavay> i tried with some ordinary text file and both can read well
23:11:24 <anohigisavay> and yes linux command `file /proc/stat` returns empty
23:13:51 <anohigisavay> what the heck?
23:17:17 <kadoban> anohigisavay: I … kinda doubt that 'file /proc/stat' is a sane thing to do.
23:17:31 <kadoban> anohigisavay: Are you thinking of 'cat' perhaps?
23:17:39 <pharaun> oh 
23:17:48 <pharaun> i know what this is
23:17:52 <pharaun> anohigisavay: you need to do a strict read
23:18:03 <pharaun> its because /proc/* are zero length if you do a size look up
23:18:08 <pharaun> cos the kernel writes it out when someone reads from it
23:18:34 <pharaun> now most lazy solution (and some strict i think) (data.text or data.bytestring can't remember which) will choke and return nothing
23:18:46 <pharaun> cos they use stat to find the exact buffer size to alloc to read in the file in some cases
23:19:03 * hackagebot yesod-test 1.5.0.1 - integration testing for WAI/Yesod Applications  https://hackage.haskell.org/package/yesod-test-1.5.0.1 (GregWeber)
23:19:28 <pharaun> https://github.com/haskell/bytestring/issues/10
23:19:36 <pharaun> here's some background context on /proc and reading it in
23:22:49 <lf94>  /dev/urandom reading causes crashes
23:22:59 <lf94> why not just lazily read from it?
23:23:42 <gamegoblin> I have an "m Bool" that will be False a lot, and then True. I want to stop sequencing the action when it’s True. Plenty of easy ways to do this, but is there a particularly elegant use of a base function?
23:25:42 <anohigisavay> pharaun, lf94 thanks guys :)
23:26:12 <anohigisavay> kadoban thanks :)
23:35:46 <jle`> gamegoblin: if you had m (Maybe a), you can find the first Just using asum and a newtype wrapper to give the right instance
23:36:33 <magthe> ghc-mod continues to give me trouble... is this something well-known: http://lpaste.net/139645 ?? (I had a quick look at the issues in github, but found nothing)
23:43:50 <EvanR> lazy io on a device file where reading has side effects
23:43:52 <EvanR> nice
23:44:35 <EvanR> astounding and hazardous ways to use haskell
23:44:41 <Hafydd> In early versions of Haskell, this was used to achieve I/O where it was otherwise impossible.
23:45:05 <Hafydd> Haskell programmers even went so far as to define a protocol based on the timing of reads from a file.
23:45:27 <EvanR> i heard of lazy list io, but was it literally something like /dev/something and timing?
23:45:48 <Hafydd> nah m8, im havin a giggle
23:51:50 <Hafydd> That would be an entertaining thing to actually implement, however.
23:52:07 <Hafydd> I wonder if I can find someone to pay me to do it for a Ph.D.
