00:01:11 <dmj> _riba: this brick library looks cool
00:01:55 <dmj> _riba: to learn more about transformers I'd check out this paper: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
00:02:53 <_riba> dmj, thanks, i'll have a look
00:03:55 <dmj> _riba: so EventM is defined as 'type EventM a = StateT EventState IO a'
00:04:02 <nshepperd> EventM appears to just be a type synonym for StateT _ IO
00:04:07 <nshepperd> ...heh
00:04:22 <dmj> _riba: since it's just a typedef it has all the instances, including MonadIO
00:04:40 <pseudomeme> okay, so I think I have a better idea of what I'm trying to do. Can someone give me some advice? Repa has these tag like data types, like D, C, U, V, B, F, etc.. 
00:04:46 <pseudomeme> I'm trying to create a similar thing in a module I'm making, but I don't know how to do it. I want the tag to only control the implementation of a single method.
00:04:51 <pseudomeme> Does anyone know how I can do that? Here is a crude pseudo-Haskell of what I'm kind of after: http://lpaste.net/139055.
00:05:24 <_riba> dmj, oh, i see, thank you
00:05:26 <dmj> _riba: so long story short, yes you can use liftIO
00:11:46 <liste> pseudomeme -- http://lpaste.net/139055#a139073 something like this?
00:13:51 * hackagebot hsqml-datamodel 0.2.0.0 - HsQML (Qt5) data model.  https://hackage.haskell.org/package/hsqml-datamodel-0.2.0.0 (mjmrotek)
00:14:33 <lf94> where do haskell beginners dwell
00:15:10 <liste> lf94 #haskell-beginners ?
00:16:13 <solidus-river> > :t :|
00:16:14 <lambdabot>  <hint>:1:1: parse error on input ‘:’
00:16:26 <solidus-river> hmm, i'm confused by syntax i'm seeing in the pipes library
00:17:12 <zyla> :t (:|)
00:17:13 <lambdabot>     Not in scope: data constructor ‘:|’
00:17:14 <lambdabot>     Perhaps you meant one of these:
00:17:14 <lambdabot>       ‘:+’ (imported from Data.Complex),
00:17:52 <solidus-river> what is the :| doing in https://github.com/peddie/pipes-zeromq4/blob/master/examples/server.hs
00:18:29 <solidus-river> its responding with what i would assume it wants to respond with the :| `the rest of the thigns to be processed`
00:18:38 <solidus-river> *then
00:19:02 <srhb> solidus-river: It looks like the nonempty list constructor
00:19:18 <liste> @let import Data.List.NonEmpty
00:19:20 <lambdabot>  Defined.
00:19:32 <liste> > "head" :| ["rest", "of", "nel"]
00:19:34 <lambdabot>  "head" :| ["rest","of","nel"]
00:19:35 <pseudomeme> liste: I'll have to read up on GADTs, which I am very ignorant of. But even so I don't think this is quite what I was going for. the process function can't be customized for each tag, that's the point of it
00:20:25 <pseudomeme> the idea is that a person could do `processA someA someDouble` and depending on the data type of 'someA' the 'processA' function uses a different 'inner' funciton to do the computation
00:20:44 <solidus-river> ahh, so they are just insuring that there will be an end of the computation? i'm confused as to why it's being used here
00:26:09 <srhb> solidus-river: Not sure what you mean. It mostly looks like a workaround to make the types line up, because respond does not take a list but a non empty list.
00:28:39 <srhb> solidus-river: (In reality, respond is very polymorphic, but it becomes constrained by the other types here.)
00:29:40 <solidus-river> srhb interesting, must be a type requirement of the ZMQ4 bindings, I need to dig deeper into those before using this :X
00:30:00 <srhb> solidus-river: I think it's just how echo is constrained.
00:30:09 <srhb> solidus-river: Note that NonEmpty appears in the return type.
00:31:55 <zettablade> Anyone know of a good library for loading and rendering font with opengl? I'm looking at freetype2 right now, but the last update was in 2012.
00:33:03 <solidus-river> srhb: ah, its so that it plays nicely with the pull binding to Pipes.ZMQ4's setupClient pipe
00:33:12 <srhb> solidus-river: Ok :)
00:33:31 <AaronFriel> zettablade: Is there a cairo lib?
00:34:41 <solidus-river> srhb: thanks for the pointers, i'm goign to dig at this more tomorrow I've coded myself into the morning almost over here
00:34:54 <srhb> solidus-river: Hehe, sleep well! :-)
00:35:14 <solidus-river> 'night
00:36:48 <zettablade> AaronFriel: Yea. I'm not too familar with Cairo. Can it load ttf files and render text to a bitmap. I need something compatible with opengl.
00:37:38 <AaronFriel> Not sure - I don't know much about it, but I'm aware it's used for rendering text in a lot of things.
00:38:13 <bernalex> I've always just used fontconfig for that.
00:39:40 <EvanR> cairo can render glyphs to a bitmap
00:39:52 <EvanR> cairo can't interface directly with opengl (yet)
00:40:09 <EvanR> freetype can load ttf data
00:40:40 <EvanR> its all so simple?
00:41:02 <frerich> With some people in this room, I'm not sure they ever sleep. The are active when I go offline and they again (still?) are offline when I come back online in the morning.
00:41:09 <zettablade> Fontconfig?
00:41:34 <frerich> s/are offline/are online/ (see, I'm not even 100% awake yet)
00:41:34 <zettablade> I'll look more into cairo
00:41:52 <zettablade> has anyone had luck with FTGL?
00:43:52 * hackagebot hsqml-datamodel 0.2.0.1 - HsQML (Qt5) data model.  https://hackage.haskell.org/package/hsqml-datamodel-0.2.0.1 (mjmrotek)
00:44:13 <bernalex> zettablade: well, fontconfig with sdl I mean.
00:53:53 * hackagebot hsqml-datamodel-vinyl 0.3.0.1 - HsQML DataModel instances for Vinyl Rec.  https://hackage.haskell.org/package/hsqml-datamodel-vinyl-0.3.0.1 (mjmrotek)
01:02:34 <consus> Hi folks. Out of curiosity: if I want to translate my program to e.g. Japanese via gettext -- do I have a way to apply localizations to IOException's text strings?
01:08:39 <srhb> consus: Short of overriding the Show instance for the Exceptions, I don't see how.
01:12:19 <lamefun> is it OK to eg. create MyProgram.Parsec module that exports the entirety of Parsec plus some additional utilities?
01:12:46 <lamefun> so that I can import one module instead of many
01:12:51 <EvanR> you should catch specific exceptions you think the end user will care about, translate them yourself, which id probably do in english too, and otherwise create a dump which the programmer will want to investigate for debugging
01:13:05 <srhb> lamefun: Sure, many packages do something similar.
01:13:09 <spaceloop> Is there a way to generate haddock for all (also non exported) symbols? I tried cabal haddock --internal, but that only looks for internal modules
01:13:28 <EvanR> nothing worse than windows users getting an alert "general protection fault 0x1f100af3aa"
01:13:37 <srhb> EvanR: That's a good idea.
01:13:48 <arahael> If you're *lucky*.
01:14:04 <srhb> Is a general protection fault like a segfault?
01:14:15 <EvanR> well yeah, worse is the program doesn't crash but continues to chew through your files or something
01:14:23 <cheater> is the X11 function selectInput thread-safe? can I have two haskell threads calling nextEvent with different Window values as sources selected with selectInput? http://hackage.haskell.org/package/X11-1.6.1.2/docs/Graphics-X11-Xlib-Event.html#v:selectInput
01:14:55 <arahael> srhb: Windows supports exception handling, except the default action is to simply say "Something bad happened" (Or words to that effect).  This may include a segfault or any other violation.
01:15:10 <srhb> arahael: Fun!
01:15:35 <EvanR> cheater: it probably isnt hard to distribute results of nextEvent from a single reader thread to the rest of your system, though it might be thread safe as is, im not sure
01:15:42 <arahael> srhb: Unlike sane systems where, in most languages that use exception handling, were you might get the stack backtrace printed on stderr...
01:15:47 <EvanR> seems simpler to have one reader
01:15:49 <arahael> srhb: You often don't even *have* stderr on windows. :(
01:15:57 <arahael> (And when you do, it certainly doesn't print to it)
01:16:26 <srhb> cheater: It's marked as unsafe, right? iirc all threads will block until it returns.
01:16:37 <cheater> EvanR: i need to read from multiple windows. that's why i need multiple readers. not to access the same events in different threads (which would be stupid)
01:16:40 <cheater> srhb: is it?
01:16:53 <srhb> cheater: foreign import ccall unsafe "HsXlib.h XSelectInput"
01:16:57 <srhb> So yes.
01:17:03 <EvanR> youre right
01:17:09 <cheater> foreign import ccall unsafe "HsXlib.h XSelectInput"
01:17:14 <EvanR> you cant even get the other events from another window
01:17:19 <cheater> right, what does "unsafe" mean?
01:18:00 <cheater> does it mean that it might have global state that this function always accesses even in other threads?
01:18:05 <srhb> cheater: I can tell you what it _doesn't_ mean. :P If it were marked as safe, and the program was -threaded, other light threads would not block.
01:18:20 <cheater> i don't care about blocking - i'm fine with it blocking
01:18:21 <EvanR> check the ffi docs on safe and unsafe, its complicated
01:18:42 <srhb> Blocking is essentially what matters in this case, I think.
01:19:03 <srhb> As long as no haskell thread runs while the call is executed, all is fine.
01:19:30 <cheater> there is nothing about unsafe here :( https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ffi.html
01:19:39 <EvanR> also you have to keep in mind bound threads
01:19:55 <cheater> srhb: i really don't care about blocking. i care about being able to select multiple windows and get events from them.
01:21:19 <EvanR> safe means the foreign call might call back into haskell which requires more work on the ffi's part
01:21:49 <EvanR> unsafe means the foreign call wont call back into haskell, so is faster
01:22:06 <cheater> http://blog.ezyang.com/2010/07/safety-first-ffi-and-threading/
01:22:13 <cheater> this is a good explanation but i hope this is the whole picture
01:23:01 <keko_> It starts with "Update. While this blog post presents two true facts, it gets the causal relationship between the two facts wrong. Here is the correction."
01:23:15 <cheater> ok so in the end whether the import says "safe" or "unsafe" doesn't relate to my question whether that function is thread safe which is a completely different thing
01:23:24 <cheater> apparently
01:23:50 <EvanR> http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
01:23:58 <srhb> Then I guess I don't understand it either. :-)
01:24:09 <cheater> here's the definition of "thread safe" i mean
01:24:13 <cheater> "Thread safety is a computer programming concept applicable in the context of multi-threaded programs. A piece of code is thread-safe if it only manipulates shared data structures in a manner that guarantees safe execution by multiple threads at the same time. There are various strategies for making thread-safe data structures."
01:24:55 <cheater> so i am asking: if in one thread I do selectInput, and then in another thread run the same function selecting another input, will the input change in the first thread as well?
01:25:15 <EvanR> if the C library its calling into is not thread safe, yes
01:25:33 <EvanR> so whats the case for xlib?
01:26:12 <haskell679> \msg lambdabot @pl \a b -> a + 2 - b
01:26:54 <EvanR> (assuming that you get the ffi call to occur multiple at a time, which requires -threaded and the ffi call marked as safe)
01:28:39 <EvanR> XSelectInput is marked unsafe, so it will block the entire haskell runtime
01:28:42 <cheater> i think it's not thread safe
01:28:55 * hackagebot quiver-http 0.0.0.2 - Adapter to stream over HTTP(s) with quiver  https://hackage.haskell.org/package/quiver-http-0.0.0.2 (ChristianMarie)
01:29:00 <cheater> EvanR: xselectinput blocking doesn't matter, it returns immediately.
01:29:08 <EvanR> the whats the issue?
01:29:10 <EvanR> then*
01:29:20 <cheater> read my question again. it's not about blocking. it's not about blocking.
01:29:26 <EvanR> another thread cant possibly interfere
01:29:47 <EvanR> the thread doing the call isnt blocking, everything else is blocking
01:30:02 <cheater> i think you're very confused EvanR  :)
01:30:38 <srhb> cheater: Perhaps, if we're not understanding you correctly, you could outline the problem as you see it step by step?
01:30:49 <spaceloop> Is there a way to generate haddock for all (also non exported) symbols? I tried cabal haddock --internal, but that only looks for internal modules
01:30:49 <cheater> i've already done that though
01:30:50 <srhb> I have a feeling that one of those steps is a false assumption, but I may be wrong of course. :)
01:31:03 <EvanR> no two threads from haskell are going to reenter that xlib call, or any other call, so im not sure what kind of thread unsafety youre worried about
01:31:04 <srhb> OK, then I guess I'm not smart enough to understand it. Good luck though! :)
01:31:49 <cheater> i would like to perform selectinput and nextevent in one thread to get events from one window, and in another thread to get events from another window. selectinput gets called with different window numbers. the question is whether nextevent would keep giving me events from just one of the windows in both threads.
01:32:50 <EvanR> oh.. so you have two threads doing next event, and they are dequeueing from the same place
01:32:55 <EvanR> but thats not appropriate
01:33:03 <cheater> i don't know if they are.
01:33:05 <cheater> that's the question.
01:33:17 <EvanR> thats an xlib question, did you filter by window or something?
01:33:30 <EvanR> if not, you need to only read from one thread
01:33:31 <cheater> you do that using selectinput.
01:33:47 <cheater> anyways... thanks for the chat
01:33:54 <EvanR> sounds like youre good then
01:33:56 * hackagebot intricacy 0.5.7 - A game of competitive puzzle-design  https://hackage.haskell.org/package/intricacy-0.5.7 (mbays)
01:33:59 <cheater> not really :)
01:34:23 <EvanR> doesnt sounds like a thread safety thing at all
01:39:10 <arahael> EvanR: There's many different types of threadsafety...  And also many different types of threads.
01:39:13 <cocreature> I think the question cheater has is if xlib maintains multiple selection states or if the second selectinput overwrites the first one
01:40:23 <EvanR> if you cant read from the queue with several threads because of that, then Chan is not thread safe
01:40:38 <EvanR> (either)
01:40:46 <arahael> EvanR: Most people regard that as being threadsafe.
01:40:54 <arahael> EvanR: Did it crash? No? Good, it's threadsafe.
01:40:57 <EvanR> which is why i said that
01:41:18 <arahael> So you want true concurrency.
01:41:31 <EvanR> huh
01:41:39 <arahael> You want to read from the queue _concurrently_.
01:43:12 <arahael> EvanR: Oh, darn it. Please ignore me. It was cheater with the issue.  I should know better.
01:43:36 <EvanR> if some threads want some events and not others, and you cant configure it, then you dont want to read concurrently
01:43:39 <EvanR> but yeah
01:44:46 <arahael> EvanR: True. :)
01:45:10 <fjordrunner> Hi,..please can anyone help me with following? I would like to send a type signature as a parameter to function, where I'm reading lines from file. Then I would like to assign the type to each line.
01:45:38 <fjordrunner> this works when I specify the type,..but not when I try it the generic way,..
01:45:44 <Gurkenglas> This might be what you're looking for: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Typeable.html
01:46:03 <fjordrunner> this is my function type: load :: a -> IO [a]
01:46:13 <fjordrunner> but I'm getting: No instance for (Read a1) arising from a use of ‘read’
01:46:26 <fjordrunner> here: let elements = [read line::a | line <- fileLines]
01:47:03 <liste> fjordrunner try load :: Read a => a -> IO a
01:47:04 <dramforever> I suppose you need to specify that a is an instance of Read
01:47:14 <dramforever> but without the full code we can't know for sure
01:47:57 <liste> and don't put the ::a in the list comprehension
01:48:10 <fjordrunner> load :: Read a => a -> IO a
01:48:10 <fjordrunner> load t = do
01:48:10 <fjordrunner>    handle <- openFile edgesFilename ReadMode 
01:48:12 <fjordrunner>    contents <- hGetContents handle  
01:48:14 <fjordrunner>    let fileLines = lines contents 
01:48:16 <fjordrunner>    let elements = [read line::a | line <- fileLines]
01:48:16 <dramforever> stop
01:48:17 <dramforever> stop
01:48:18 <fjordrunner>    putStrLn $ "successfully loaded: "  ++ (show $length elements)
01:48:18 <dramforever> stop
01:48:20 <fjordrunner>    hClose handle      
01:48:22 <fjordrunner>    return elements
01:48:28 <fjordrunner> sorry,...
01:48:29 <dramforever> ok looks like it's over
01:48:33 <dramforever> @paste
01:48:33 <lambdabot> Haskell pastebin: http://lpaste.net/
01:48:56 <dramforever> oh you need to specify a type for elements
01:48:56 * hackagebot http-client 0.4.20 - An HTTP client engine, intended as a base layer for more user-friendly packages.  https://hackage.haskell.org/package/http-client-0.4.20 (MichaelSnoyman)
01:48:58 <fjordrunner> sorry + sorry,...next time will paste it to the right place,...
01:48:59 <comerijn> read :((
01:49:21 <dramforever> wait
01:49:22 <comerijn> Man, sometimes I think we should delete "read" from Prelude :\
01:49:30 <EvanR> and head
01:49:35 <EvanR> and division ;)
01:49:37 <comerijn> EvanR: No, head is useful
01:49:37 <dramforever> you need to use the extension ScopedTypeVariables
01:49:50 <dramforever> do you know what an extension is?
01:49:53 <EvanR> read can be similarly useful, and hazardous
01:50:10 <liste> dramforever isn't the type inferred from top-level signature?
01:50:17 <dramforever> yes
01:50:18 <merijn> EvanR: No, I don't think there's anything you need read for where either readMaybe or a parser will be better
01:50:35 <dramforever> but fjordrunner wants to specify the type
01:50:46 <EvanR> for funny oneliners, fromJust on readMaybe is kind of missing the point
01:51:03 <EvanR> same with head
01:51:12 <merijn> EvanR: I'd be okay with removing readMaybe too
01:51:22 <merijn> Or hiding it some dark scary corner
01:51:34 <EvanR> would it be available on irc?
01:51:46 <dramforever> I want to remove the whole Show/Read thing...wait it's not going to work
01:53:15 <fjordrunner> so,..I should take a look at ScopedTypeVariables,...that should help,...right?
01:53:33 <liste> fjordrunner that or remove the ::a altogether
01:55:37 <fjordrunner> when I remove ::t, I get: No instance for (Read a0) arising from a use of ‘read’
01:56:01 <liste> fjordrunner can I see the lpaste?
01:56:03 <dramforever> lemme see
01:56:10 <breadmonster> Hey everyone
01:56:18 <breadmonster> Anyone used alex/happy before?
01:56:22 <breadmonster> I can't find a nice tutorial.
01:56:38 <dramforever> oh I know what's the problem
01:56:48 <dramforever> you need load :: Read a => a -> IO [a]
01:56:48 <breadmonster> dramforever: What's up?
01:56:56 <dramforever> what's up?
01:57:18 <breadmonster> dramforever: I can't figure out how lex works.
01:57:31 <dramforever> oh I don't know about that...
01:57:42 <breadmonster> dramforever: I mean alex.
01:57:50 <dramforever> neither that
01:58:00 <breadmonster> I've always just used Parsec.
01:58:36 <fjordrunner> http://lpaste.net/139084
01:58:38 <Gurkenglas> fjordrunner, do you need to specify the type during runtime, or do you just need different types in different places in your code?
01:59:37 <fjordrunner> different types in different places in your code
02:00:17 <EvanR> whats an example of specifying a type during runtime?
02:00:40 <liste> fjordrunner why not just load :: Read a => IO [a] ?
02:01:18 <Gurkenglas> > (read :: String -> Int) "25" -- lets you specify what type the read is supposed to produce from the string
02:01:19 <lambdabot>  25
02:01:20 <srhb> Or just ScopedTypeVariables, forall a and read line :: a
02:02:01 <Gurkenglas> > (read "52.6") :: Double -- also works
02:02:02 <lambdabot>  52.6
02:02:15 <EvanR> was just confused at "during runtime"
02:02:47 <srhb> (Though I suppose that isn't even necessary as elements is already given a type straight from the return type)
02:03:09 <Gurkenglas> EvanR, I could imagine reading the type that is to be returned in via getLine
02:03:35 <kuribas> > read "62.6" :: Double
02:03:36 <lambdabot>  62.6
02:03:39 <EvanR> how would you do that? typeable?
02:03:51 <srhb> That leads straight to fully dynamic typing though, which isn't that useful.
02:03:55 <Gurkenglas> I'm not saying how that would be done, only that he might be asking for how to do it. He said he wasn't.
02:04:11 <fjordrunner> when I use Read a => IO [a], I get *** Exception: Prelude.read: no parse
02:04:12 <liste> fjordrunner or even load :: (String -> a) => IO [a] and then pass the right loading function
02:04:28 <liste> fjordrunner that means that your input is bogus
02:04:37 <srhb> fjordrunner: MonomorphismRestrictoin and the type inferred is not the one you meant, probably.
02:04:47 <srhb> fjordrunner: try load :: IO [TheTypeYouReallyWant]
02:04:59 <fjordrunner> one line from file is: Node 1 0.0 "x22" 1 0.0
02:05:11 <fjordrunner> and from this I would like to get a Node datastructure
02:05:28 <fjordrunner> this works, when I define ::Node while reading from file,..
02:05:36 <srhb> fjordrunner: Which is what you should do. :)
02:05:55 <srhb> fjordrunner: ie load :: IO [Node]
02:06:02 <fjordrunner> but is it not possible the Node as a parameter in a function?
02:06:12 <srhb> It's not impossible, but it's also not really useful.
02:06:25 <Gurkenglas> fjord, you can keep load :: Read a => IO [a] where the function is defined. Where the function is used, writing "(load :: IO [Node])" instead of "load" will tell it what type you want this time
02:06:41 <srhb> fjordrunner: And I can't imagine that's what you really need. If your code expects [Node] in the end, there's no point in passing anything in. Just let the caller decide the type.
02:06:44 <EvanR> fjordrunner: at the location you use load, if Node is expected, it will work
02:07:34 <_riba> The docs say Data.Text.Zipper provides a 2-dimensional data structure, but apparently \n doesn't do what I want. do I have to manually call the breakLine function to make it go "down"?
02:08:02 <fjordrunner> basically I have 2 files where I save data with 2 different datastructures. I would like to load them with one function where I will define the datatype
02:08:26 <srhb> fjordrunner: And you can do this in this way.
02:08:45 <srhb> fjordrunner: The trick is to let the caller decide the type of load :: Read a => IO [a] -- ie. select the a
02:08:57 <srhb> fjordrunner: That does not make load monomorphic. It WILL work for any Read a
02:08:57 * hackagebot observable-sharing 0.2.2.0 - Simple observable sharing  https://hackage.haskell.org/package/observable-sharing-0.2.2.0 (mararon)
02:09:54 <srhb> fjordrunner: To make it clear, this is the code we're proposing: http://lpaste.net/2645280957585686528
02:10:21 <srhb> fjordrunner: Now, whenever you program uses load somewhere, whatever a is inferred is the one used. Ie. it may be Node, Int, Double, whatever.
02:10:25 <liste> _riba seems so
02:10:35 <Gurkenglas> And this is the code I am proposing: http://lpaste.net/139084#a139085
02:10:48 <_riba> liste, okay, thank you
02:11:13 <srhb> Note that the type annotations in Gurkenglas' example are actually superfluous.
02:11:16 <liste> Gurkenglas missing Read => on line 7
02:11:21 <Gurkenglas> (umm, missed removing the ::type. http://lpaste.net/139085)
02:11:26 <Gurkenglas> Yep, that too
02:12:44 <liste> as long as all your top-level functions have type annotations, the right Read instances are inferred
02:12:49 <Gurkenglas> They might be superfluous in this case, but sometimes they need to be specified, and I would do it alwayys until one is sure of when it's not necessary
02:13:01 <Gurkenglas> :t show . read
02:13:02 <lambdabot> String -> String
02:13:09 <dramforever> lol
02:13:21 <dramforever> > show (read "()") -- the only thing that works
02:13:23 <lambdabot>  "()"
02:13:42 <EvanR> > (show . read) "0"
02:13:44 <lambdabot>  "*Exception: Prelude.read: no parse
02:13:51 <EvanR> > (show . read) "0" :: Int
02:13:53 <lambdabot>      Couldn't match type ‘[Char]’ with ‘Int’
02:13:53 <lambdabot>      Expected type: Int
02:13:53 <lambdabot>        Actual type: String
02:13:55 <EvanR> :(
02:13:58 * hackagebot amazonka-core 1.0.1 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.0.1 (BrendanHay)
02:14:00 * hackagebot amazonka 1.0.1 - Comprehensive Amazon Web Services SDK  https://hackage.haskell.org/package/amazonka-1.0.1 (BrendanHay)
02:14:02 * hackagebot amazonka-config 1.0.1 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.0.1 (BrendanHay)
02:14:04 * hackagebot amazonka-sns 1.0.1 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.0.1 (BrendanHay)
02:14:06 * hackagebot amazonka-sqs 1.0.1 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.0.1 (BrendanHay)
02:14:45 <Gurkenglas> > (show . (read :: String -> Int)) "  0 "
02:14:47 <lambdabot>  "0"
02:14:49 <EvanR> dramforever: i wonder if theres a betterly typed setup for read and show
02:14:57 <dramforever> dunno
02:15:18 <srhb> What would "better" encompass?
02:15:21 <srhb> They seem fine to me.
02:15:38 <EvanR> (show . read) = id ;)
02:15:49 <EvanR> which includes crashing
02:15:57 <Gurkenglas> *coughs and points at my last line*
02:16:05 <Gurkenglas> read . show should be id.
02:16:05 <srhb> Oh, you want that invariant preserved in types. Right.
02:16:20 <srhb> Needs more dependentness. :-)
02:16:29 <EvanR> ah but its bogus because its not roundtripping
02:16:55 <fjordrunner> shrb: many thanks,...but that is giving me: [*** Exception: Prelude.read: no parse
02:17:05 <srhb> fjordrunner: Show your full code, please.
02:18:14 <Gurkenglas> Betting karma on that he didn't use top-level signatures and putting signatures where I suggested them would fix it.
02:18:23 <srhb> possibly. :-)
02:18:35 <srhb> (Also no bet. :P)
02:19:05 <fjordrunner> http://lpaste.net/139089
02:19:08 * hackagebot amazonka-glacier 1.0.1 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.0.1 (BrendanHay)
02:19:10 * hackagebot amazonka-cloudhsm 1.0.1 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.0.1 (BrendanHay)
02:19:12 * hackagebot amazonka-datapipeline 1.0.1 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.0.1 (BrendanHay)
02:19:14 * hackagebot amazonka-iam 1.0.1 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.0.1 (BrendanHay)
02:19:16 * hackagebot amazonka-route53-domains 1.0.1 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.0.1 (BrendanHay)
02:19:34 <srhb> fjordrunner: I don't see any call of load there
02:19:40 <srhb> fjordrunner: That's the relevant bit.
02:19:47 <dramforever> I don't like this amazonka thing
02:19:52 <fjordrunner> I just try to call it from ghci
02:19:56 <dramforever> for exactly this reason
02:19:59 <fjordrunner> only testing
02:20:08 <srhb> fjordrunner: Then you need to do load :: IO [Node]
02:20:19 <srhb> fjordrunner: In actual code, the type of a will usually be inferred by context.
02:20:30 <Gurkenglas> In ghci, mind you, not the definition of load
02:20:37 <srhb> fjordrunner: when you just type load in ghci, that information isn't available, and defaulting rules kick in and choose a wrong `a`
02:20:46 <srhb> fjordrunner: Which does not match the Read instance for Node
02:20:47 <srhb> Hence failure.
02:20:58 <srhb> Yes, what Gurkenglas said :)
02:21:46 <Gurkenglas> (read :: String -> ()) should be const (). That would give a more informative result than error: no parse
02:21:48 <srhb> So type in (exactly) in ghci: load :: IO [Node]
02:23:21 <fjordrunner> I think I'm starting to understand :-)
02:23:27 <srhb> Great! :-)
02:23:39 <srhb> The thing to remember is that in polymorphic functions, the caller decides the type.
02:23:43 <dramforever> Gurkenglas: that won't make sense
02:23:57 <dramforever> what if I want to parse [(), (), ()]
02:23:57 <Gurkenglas> Why not? read isn't injective already.
02:24:08 <dramforever> read isn't implemented that way
02:24:18 * hackagebot amazonka-directconnect 1.0.1 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.0.1 (BrendanHay)
02:24:20 * hackagebot amazonka-devicefarm 1.0.1 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.0.1 (BrendanHay)
02:24:22 * hackagebot amazonka-cognito-sync 1.0.1 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.0.1 (BrendanHay)
02:24:24 * hackagebot amazonka-elb 1.0.1 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.0.1 (BrendanHay)
02:24:26 * hackagebot amazonka-cloudformation 1.0.1 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.0.1 (BrendanHay)
02:25:56 <fjordrunner> srhb: many thanks!!!!
02:26:04 <srhb> fjordrunner: Welcome. Happy hacking.
02:29:28 * hackagebot amazonka-sts 1.0.1 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.0.1 (BrendanHay)
02:29:30 * hackagebot amazonka-kinesis 1.0.1 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.0.1 (BrendanHay)
02:29:32 * hackagebot amazonka-cloudsearch-domains 1.0.1 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.0.1 (BrendanHay)
02:29:34 * hackagebot amazonka-cloudwatch 1.0.1 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.0.1 (BrendanHay)
02:29:36 * hackagebot amazonka-cloudtrail 1.0.1 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.0.1 (BrendanHay)
02:31:52 <bz> @pl \x y -> 3
02:31:53 <lambdabot> const (const 3)
02:32:21 <Gurkenglas> @pl \x y z -> z
02:32:22 <lambdabot> const (const id)
02:33:29 <Gurkenglas> Expected him to find "const . const".
02:34:38 * hackagebot amazonka-elasticache 1.0.1 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.0.1 (BrendanHay)
02:34:40 * hackagebot amazonka-importexport 1.0.1 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.0.1 (BrendanHay)
02:34:42 * hackagebot amazonka-s3 1.0.1 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.0.1 (BrendanHay)
02:34:44 * hackagebot amazonka-swf 1.0.1 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.0.1 (BrendanHay)
02:34:46 * hackagebot amazonka-sdb 1.0.1 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.0.1 (BrendanHay)
02:39:48 * hackagebot amazonka-codecommit 1.0.1 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.0.1 (BrendanHay)
02:39:50 * hackagebot amazonka-codedeploy 1.0.1 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.0.1 (BrendanHay)
02:39:52 * hackagebot amazonka-cloudfront 1.0.1 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.0.1 (BrendanHay)
02:39:54 * hackagebot amazonka-efs 1.0.1 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.0.1 (BrendanHay)
02:39:56 * hackagebot amazonka-codepipeline 1.0.1 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.0.1 (BrendanHay)
02:40:00 <ely-se> somebody likes Amazon
02:40:29 <frerich> My wife.
02:41:51 <tdammers> everybody likes Amazon
02:41:58 <tdammers> whether they like it or not
02:43:13 <Gurkenglas> Who made hackagebot and can we tell them to collapse package updates with the same prefix or with some other way to connect them?
02:44:58 * hackagebot amazonka-elasticbeanstalk 1.0.1 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.0.1 (BrendanHay)
02:45:00 * hackagebot amazonka-autoscaling 1.0.1 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.0.1 (BrendanHay)
02:45:02 * hackagebot amazonka-ses 1.0.1 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.0.1 (BrendanHay)
02:45:04 * hackagebot amazonka-support 1.0.1 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.0.1 (BrendanHay)
02:45:06 * hackagebot amazonka-dynamodb-streams 1.0.1 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.0.1 (BrendanHay)
02:47:23 <hvr> I wonder why amzonka was split into so many sub-packages
02:47:55 <hvr> which then get released all at once for every point rls
02:48:40 <merijn> hvr: No idea, it confuses me too
02:48:54 <merijn> I doubt it noticeably decreases the dependency footprint for users..
02:50:08 * hackagebot amazonka-redshift 1.0.1 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.0.1 (BrendanHay)
02:50:10 * hackagebot amazonka-opsworks 1.0.1 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.0.1 (BrendanHay)
02:50:12 * hackagebot amazonka-emr 1.0.1 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.0.1 (BrendanHay)
02:50:14 * hackagebot amazonka-cognito-identity 1.0.1 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.0.1 (BrendanHay)
02:50:16 * hackagebot amazonka-ssm 1.0.1 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.0.1 (BrendanHay)
02:51:10 <breadmonster> Will ghc automatically optimize away data structures for me?
02:51:25 <breadmonster> I'm writing a parser with parsec and I have a bunch of keywords I want to match against.
02:51:52 <breadmonster> And I've created a trie to hold them, so then using something akin to a fold, I can turn it into a character based parser.
02:52:06 <breadmonster> Else I'd have to backtrack all the time, or use a lot of code.
02:52:23 <breadmonster> This is simple and short, except I'm wondering if ghc will optimize the trie away.
02:52:38 <breadmonster> Since all the contents of the trie and decided at compile time.
02:53:27 <merijn> breadmonster: What are you parsing?
02:53:41 <breadmonster> merijn: Python.
02:53:51 <merijn> breadmonster: Then it most likely won't matte
02:53:51 <breadmonster> Also, basically lexing.
02:54:05 <breadmonster> Instead of having to backtrack on each keyword, it's really easier to just insert into a trie and fold.
02:54:09 <breadmonster> merijn: why not?
02:54:22 <merijn> breadmonster: I mean, why do you think the data structure not getting optimised away will give your problems?
02:54:46 <breadmonster> I don't know, I just don't want it to insert all the keywords and fold the trie again...
02:54:51 <merijn> breadmonster: Because unless you're doing something latency sensitive like network protocol parsing, parsing is an insignificant part of your time...
02:55:02 <breadmonster> Fair enough.
02:55:18 * hackagebot amazonka-ml 1.0.1 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.0.1 (BrendanHay)
02:55:20 * hackagebot amazonka-workspaces 1.0.1 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.0.1 (BrendanHay)
02:55:22 * hackagebot amazonka-dynamodb 1.0.1 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.0.1 (BrendanHay)
02:55:24 * hackagebot amazonka-rds 1.0.1 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.0.1 (BrendanHay)
02:55:26 * hackagebot amazonka-ds 1.0.1 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.0.1 (BrendanHay)
02:56:04 <merijn> breadmonster: For the record, GHC reparses files instead of bothering to store intermediate representations in some cases. Someone was suggesting to optimise that, to which the reponse was "less than 1% of GHC's time is spent parsing, so who cares?"
02:56:21 <merijn> I mean, unless you're trie parser happens to be stupidly slow I doubt it'll be an issue
02:57:13 <breadmonster> merijn: Except 1% is a serious optimization.
03:00:28 * hackagebot amazonka-cloudwatch-logs 1.0.1 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.0.1 (BrendanHay)
03:00:30 * hackagebot amazonka-route53 1.0.1 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.0.1 (BrendanHay)
03:00:32 * hackagebot amazonka-cloudsearch 1.0.1 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.0.1 (BrendanHay)
03:00:34 * hackagebot amazonka-storagegateway 1.0.1 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.0.1 (BrendanHay)
03:00:36 * hackagebot amazonka-ec2 1.0.1 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.0.1 (BrendanHay)
03:05:38 * hackagebot amazonka-kms 1.0.1 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.0.1 (BrendanHay)
03:05:40 * hackagebot amazonka-elastictranscoder 1.0.1 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.0.1 (BrendanHay)
03:05:42 * hackagebot amazonka-lambda 1.0.1 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.0.1 (BrendanHay)
03:05:44 * hackagebot amazonka-ecs 1.0.1 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.0.1 (BrendanHay)
03:05:53 <hvr> oh... it's *still* spamming :)
03:06:10 <quchen2> 1% sounds small to me.
03:07:04 <dramforever> quchen2++
03:07:44 <hvr> quchen2: that's relative =)
03:08:02 <quchen2> hvr: Yes, relative to something not small, such as 50%.
03:08:33 <dramforever> "small" is always relative
03:08:36 <dramforever> is it?
03:08:41 <hvr> sure, I'd prefer a 50% improvement over a 1%, and I'd prefer 1% over 0%
03:08:41 <quchen2> "Would I think 'oh cool' if I read that in a changelog?" - 50% "oh wow", 20% "nice", 10% "okay", 1% "why is this mentioned"
03:09:12 <hvr> at least it's being honest that it's only 1%...
03:09:30 <CoconutCrab> sounds like Intel CPUs advertisement
03:09:31 <hvr> rather than saying "performance measurably improveed"
03:09:49 <quchen2> Considering we recently had speedups of orders of magnitude via concurrent compilation I'm maybe a little spoiled :-D
03:10:27 <quchen2> hvr: "significantly" is a good word here because it means something completely different in statistics than it does in normal speech.
03:10:30 <hvr> quchen2: and you can always construct microbenchmark that bloat up the 1% =)
03:16:47 <bycn82> hi help
03:16:59 <hvr> help is not here
03:17:15 <bycn82> i want to get the output of a system command in haskell
03:17:28 <bycn82> i am new here, this programming language is super cool
03:17:33 <hvr> bycn82: what have you tried so far?
03:17:47 <dramforever> I assume you already know quite a bit of haskell, then
03:17:54 <hvr> bycn82: I'd point you to http://hackage.haskell.org/package/process-1.2.3.0/docs/System-Process.html
03:18:05 <bycn82> i started to learn it since yesterday morning
03:18:10 <dramforever> oh hmm...
03:18:18 <dramforever> that's quick
03:19:33 <hvr> bycn82: specifically, look at the 'readProcess' function
03:19:47 <bycn82> i tried the "system" function, but i dont know how to get the result from this function
03:20:21 <rlewis> you can't with system
03:20:25 <bycn82> system :: String -> IO GHC.IO.Exception.ExitCode
03:20:39 <hvr> bycn82: and if you need stderr and stdout, look at readProcessWithExitCode
03:20:44 <liste> my ghci example: Prelude System.Process> readProcess "pwd" [] ""
03:20:47 <bycn82> the output is ..... exitcode, but what i want is the output in stdout
03:20:52 <rlewis> is the program you want to catch output from interactive? you also have to write to its stdin?
03:20:56 <bycn82> thanks, readProcess.
03:21:27 <bycn82> :q
03:21:41 <dramforever> lol another vi(m) use spotted
03:21:43 <dramforever> *user
03:21:47 <hvr> dramforever: or ghci user!
03:21:52 <dramforever> oh
03:22:55 <bycn82> sorry :)
03:23:05 <hvr> bycn82: no problem, the channel still exissts =)
03:23:10 <bycn82> main.hs:12:13: parse error on input `='
03:23:13 <jerrrry> didn't know :q works in ghci too
03:23:25 <bycn82> rst = readProcess "ls" ["-a"] ""
03:23:43 <hvr> jerrrry: it's because GHCi looks handles abbrevations of :quit as long as they're unique
03:23:48 <rlewis> bycn82 I think you will find it painful to write this program without familiarizing yourself with IO and do blocks (at the very least)
03:24:02 * hackagebot ansi-wl-pprint 0.6.7.3 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output  https://hackage.haskell.org/package/ansi-wl-pprint-0.6.7.3 (EdwardKmett)
03:24:11 <rlewis> by IO I mean IO type
03:24:14 <hvr> edwardk: \o\
03:24:16 <hvr> edwardk: \o/
03:25:18 <fjordrunner> comerijn
03:26:30 <bycn82> hi
03:26:45 <bycn82> rst = readProcess "ls" ["-a"] ""
03:26:46 <bycn82>    
03:27:02 <bycn82> it works in a standardlone hs program
03:27:19 <bycn82> but i am trying to run it in a fastcgi haskell program
03:27:24 <bycn82> and i got error
03:27:32 <bycn82> main.hs:12:13: parse error on input `='
03:27:43 <srhb> bycn82: Post the relevant file.
03:27:54 <srhb> bycn82: lpaste.net
03:28:44 <fjordrunner> please,..earlier I got some negative reactions when I posted my code sample, where I'm using 'read' function for parsing string to data structure. Please,..what is wrong with 'read'?
03:28:57 <bycn82> http://lpaste.net/139094
03:29:17 <quchen2> fjordrunner: https://github.com/quchen/articles/blob/master/fbut.md#read
03:29:41 <srhb> bycn82: That's not valid syntax in a do block
03:29:46 <srhb> bycn82: (Among other errors)
03:30:06 <bycn82> so it is a simple syntax error :(
03:30:33 <srhb> bycn82: Well, to start with, yes. Defining names in do blocks requires let name = value
03:30:33 <liste> bycn82 also you need liftIO
03:30:37 <srhb> But that will not execute the IO action
03:30:41 <srhb> So what you want is probably
03:30:45 <srhb> name <- liftIO $ action
03:31:15 <bycn82> i want to print the result of the ls
03:31:20 <srhb> bycn82: As a side note I think this is a horrendous way of learning Haskell, because understanding why all this needs to be is best done in a rigorous manner.
03:31:27 <bycn82> i need to know the IO, i think
03:33:06 <srhb> bycn82: But for now, rst <- liftIO $ readProcess "ls" ["-a"] "" -- should do the trick
03:33:23 <bycn82> yes, i m trying
03:35:26 <bycn82> it works, cool
03:35:55 <bycn82> OK, i dont have much time to learn this cool programming language, but i am really want to learn it 
03:36:08 <merijn> quchen2: I love how I can just link your FAQ to not retype my own answers all the time :p
03:36:08 <srhb> Well, learning usually requires time. :-)
03:36:16 <bycn82> usually i would like to do coding using C,
03:36:17 <merijn> quchen2: I should make a shortcut for pasting the right entries :p
03:37:08 <bycn82> last 3 month ago, i met someone in a tech conference, and he was introducing functional programm...
03:37:19 <bycn82> so i am trying to learn it here, it is interesting.
03:37:42 <bycn82> but my question is ,, where is the document,
03:37:54 <bycn82> the doc of the api/ function list
03:39:08 <srhb> bycn82: For what? Most packages are uploaded to hackage, which contains docs of varying quality for each package
03:39:26 <fjordrunner> quchen2: thanks :-)
03:39:28 <bycn82> yes, i want to know how to read the docs of the package, 
03:39:50 <srhb> bycn82: What package? 
03:40:01 <bycn82> for example, string operation
03:40:03 <srhb> bycn82: Generally go to hackage.haskell.org, search for the package name, browse the modules
03:40:04 <bycn82> substr
03:40:15 <bycn82> i am checking the hackage
03:40:17 <srhb> bycn82: Strings are just list, so they are found in Data.List (in prelude)
03:40:23 <srhb> Just lists of characters, I should say
03:40:59 <bycn82> i know, like in Data.List, there is a function named "take"   
03:41:01 <quchen2> merijn: FBUT! It's a FAQ with contents that is actually brought up from time to time!
03:41:06 <bycn82> take 2 [1,2,3] 
03:41:10 <srhb> bycn82: Yes?
03:41:30 <bycn82> but what I want to know is what other useful functions are there.
03:41:47 <srhb> bycn82: That's a strange question. Functions are on Hackage because people have considered them useful.
03:42:28 <srhb> bycn82: So I guess "all of them" -- but surely that's not what you meant. :-)
03:42:49 <bycn82> OK, let me explain it in this way
03:42:57 <bycn82> i read the "real world haskell"
03:43:26 <bycn82> there is a simple programme to count the lines of the input
03:43:39 <jerrrry> read world haskell is a bit outdated unfortunately
03:43:48 <jerrrry> real
03:44:12 <bycn82> outdated, OK, but is was so cool for me, 
03:44:23 <bycn82> because there is a function named "lines"
03:44:29 <srhb> bycn82: Right.
03:44:39 <bycn82> and by reading it, i know there is another function "words"
03:44:45 <bycn82> that's so usefull.
03:44:49 <srhb> Sure.
03:45:06 <srhb> (It turns out, not so much, because we don't really use Strings for much, but instead use Text a lot.)
03:45:11 <srhb> But as a learning example, it's great :)
03:45:30 <bycn82> and in the tutorial, askking how to change the programme to count how many characters.
03:45:32 <Intolerable> i was gonna :t Text.lines but text isn't on here
03:46:21 <bycn82> so i was thinking, so my question is how can i knnw whether there is a function to count the chars
03:46:36 <srhb> bycn82: You can search by type on hoogle or hayoo
03:46:38 <Intolerable> ghci > :t Text.lines
03:46:39 <Intolerable> Text.lines :: Text -> [Text]
03:46:45 <Intolerable> :t length
03:46:46 <lambdabot> Foldable t => t a -> Int
03:46:50 <Intolerable> > length "hello world"
03:46:52 <lambdabot>  11
03:47:03 <bycn82> i know i should use length
03:47:11 <srhb> bycn82: So for instance, from your description I know I want something like String -> Int
03:47:13 <lpaste_> jerbome pasted “No title” at http://lpaste.net/139098
03:47:15 <srhb> @hoogle String -> Int
03:47:16 <lambdabot> Test.HUnit.Base Label :: String -> Node
03:47:16 <lambdabot> Test.QuickCheck.Test labelPercentage :: String -> State -> Int
03:47:16 <lambdabot> Prelude error :: [Char] -> a
03:47:16 <bycn82> but what i want to say is, where are the function list
03:47:18 <bycn82> like 
03:47:21 <srhb> Well, that was not helpful.
03:47:22 <bycn82> like in C or php
03:47:25 <bycn82> http://php.net/manual/en/book.strings.php
03:47:35 <liste> @hackage base -- bycn82
03:47:35 <lambdabot> http://hackage.haskell.org/package/base -- bycn82
03:47:37 <srhb> bycn82: There is no one single list. You can browse the base package on Hackage for the standard library
03:47:44 <Intolerable> https://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html
03:47:47 <bycn82> this url is all functions in ths string libarary
03:48:00 <srhb> bycn82: As said, the base package on Hackage is the standard library.
03:48:14 <jerbome> hi guys, I'm new to haskell, and I cannot manage to understand why isPrime in this paste (http://lpaste.net/139098) works. specifically, I don't understand why it terminates for any natural numbers
03:48:14 <Intolerable> https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html / https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-String.html
03:48:20 <bycn82> thanks
03:48:35 <bycn82> Intolerable: thanks, that is what I want :)
03:48:38 <Intolerable> jerbome: are you aware of haskell's laziness?
03:48:57 <jerbome> yes
03:49:05 <jerbome> in a blurry way
03:50:04 <bycn82> thanks, this doc is what i want :)
03:50:44 <bycn82> i think i just need to familiar with syntax, then i can said finaly i learned a functional programing language :)
03:50:51 <jerbome> it's not the corecursion that I have trouble with, I still cannot understand why the fold terminates even if primes was not defined using isPrime
03:50:59 <srhb> bycn82: It probably isn't, really, because as I said we don't really use Strings all that much, and the text functions are in the text package
03:51:10 <srhb> bycn82: Also, syntax has very little to do with functional programming.
03:51:27 <bycn82> srhb: OK, 
03:51:28 <kuribas> jerbome: because of the test "p*p > n"
03:51:35 <bycn82> srhb: then what do you use?
03:51:45 <srhb> bycn82: What do I use for what?
03:51:46 <kuribas> jerbome: foldr is lazy, so it doesn't need to look at the whole list.
03:52:01 <jerbome> kuribas, I'm dumb, thanks for making me realize that
03:52:05 <Intolerable> bycn82: @hackage text
03:52:10 <Intolerable> @hackage text
03:52:10 <lambdabot> http://hackage.haskell.org/package/text
03:52:12 <srhb> bycn82: I look up the haddock documents for whatever package I'm using, if that's what you're asking.
03:52:12 <kuribas> jerbome: so basicly it doesn't look at elements larger than sqrt(n).
03:52:21 <bycn82> srhb: BTW, what kind of task are you guys are using haskell in.
03:52:36 <srhb> bycn82: Web dev and backend stuff, as well as a tiny bit of scientific computing.
03:52:48 <srhb> bycn82: But people do all sorts of different things in Haskell.
03:52:49 <jerbome> bycn82, I'm using it for project euler
03:53:00 <kuribas> jerbome: I did?
03:53:12 <jerbome> kuribas, yes, but in a good way, don't worry
03:53:19 <kuribas> alright :)
03:53:21 <Intolerable> bycn82: https://github.com/intolerable/reddit
03:54:04 * hackagebot hsqml-datamodel 0.2.0.2 - HsQML (Qt5) data model.  https://hackage.haskell.org/package/hsqml-datamodel-0.2.0.2 (mjmrotek)
03:54:07 <bycn82> OK, cool , a lib to call the reddit api
03:55:00 <bycn82> any people use it in web development?
03:55:09 <bycn82> or operating system development?
03:56:11 <srhb> bycn82: Haskell? Both.
03:56:20 <srhb> It's a general purpose language, suitable for almost any task.
03:56:29 <srhb> (And people tend to get very addicted and do everything they can in it.)
03:57:01 <bycn82> general purpose! cool
03:57:47 <jerbome> kuribas, I'm still confused (and probably dumb)
03:58:01 <srhb> Even in domains where it's not suitable (say, embedded realtime, because of the large RTS) people find ways of utilizing it, like as a host for a EDSL for the task at hand.
03:58:08 <srhb> But enough sales pitch from me. :)
03:58:16 <kuribas> jerbome: no worries
03:58:50 <jerbome> kuribas, I do get why the folds end because of lasyness now, but how can it end with false ?
03:59:04 * hackagebot Hangman 0.1.0.2 - The classic game of Hangman.  https://hackage.haskell.org/package/Hangman-0.1.0.2 (lf94)
03:59:31 <kuribas> jerbome: because a number larger than (sqrt n) cannot be a factor.
03:59:45 <kuribas> jerbome: so it ends there.
04:00:00 <jerbome> kuribas, but then the fold function returns True
04:00:14 <jerbome> when isPrime 99 returns false
04:05:24 <bycn82> Q:
04:05:35 <bycn82> i am trying to read a substr function 
04:05:43 <bycn82> let substr(str,start,end) = take (end - start) (take end str)
04:05:54 <bycn82> substr("1234567",3,5)
04:05:59 <dramforever> duh
04:06:08 <keko_> is that haskell or your own custom language?
04:06:12 <dramforever> that's not how arguments are normally passed in
04:06:36 <dramforever> this is more idiomatic: let substr str start end = ...
04:07:11 <srhb> Also don't you mean to drop the start?
04:07:12 <quchen2> Depends on the context. Sometimes tupling up arguments can be useful.
04:07:49 <bycn82> let substr str start end = take (end - start) (take end str)
04:07:56 <bycn82> substr "12345678" 3 5
04:08:01 <bycn82> the result is "12"
04:08:12 <bycn82> so it caculate the (end - start)
04:08:26 <merijn> You first take "end" entries
04:08:36 <merijn> and then take "end - start" entries from the remaining list
04:08:44 <merijn> So, you're just taking "end - start" entries
04:09:00 <kuribas> > 4 `rem` 2 /= 0
04:09:02 <lambdabot>  False
04:09:04 <srhb> > let substr start end = take (end - start) . drop start in substr 3 6 "123456"
04:09:05 <lambdabot>  "456"
04:09:14 <srhb> Notice the drop.
04:10:01 <quchen2> > let substr start end = drop (start-1) . take end in substr 3 5 ['a'..]
04:10:02 <lambdabot>  "cde"
04:10:18 <bycn82> i see, there is a "drop" but currently i dont know, 
04:10:28 <merijn> srhb: Wouldn't "drop start . take end" be much simpler?
04:10:34 <srhb> Yes!
04:10:55 <srhb> I was just trying to stay with the logic of the subtraction (not really, I just wasn't thinking.)
04:11:24 <srhb> :t drop -- bycn82 
04:11:25 <lambdabot> Int -> [a] -> [a]
04:11:33 <srhb> bycn82: It just drops n elements from a list
04:11:33 <bycn82> yes, use drop is nice, but i learned take only, 
04:11:36 <srhb> The front, that is.
04:11:42 <srhb> Well, you can't do this with take.
04:11:52 <srhb> Since you will never "advance" in the list.
04:11:55 <kuribas> > 2*2 > 4 || 4 `rem` 2 /= 0 && undefined -- Jerbome
04:11:57 <lambdabot>  False
04:12:40 <kuribas> jerbome: ^^^
04:14:54 <kuribas> jerbome: the second argument to (&&) never gets evaluated.
04:15:10 <kuribas> > False && undefined
04:15:12 <lambdabot>  False
04:15:38 <Zemyla> merijn: take (end - start) . drop start is preferred, because the list is only traversed once that way.
04:16:07 <merijn> Zemyla: It's only traversed once in mine too
04:16:09 <merijn> Laziness
04:16:32 <merijn> If you plan to nest more layers you might build up too max thunks, but in this scenario with just two it doesn't matter
04:19:40 <kuribas> jerbome: you could even replace True with undefined, it would still work.
04:20:07 <bz> > True && undefined
04:20:08 <lambdabot>  *Exception: Prelude.undefined
04:20:16 <bz> 'the second argument to (&&) never gets evaluated'
04:20:41 <srhb> bz: If the first one is False, obviously.
04:21:13 <kuribas> bz: I was refering to http://lpaste.net/139098
04:21:49 <bz> kuribas: oh okay, i didn't have the full context
04:21:50 <kuribas> bz: if "n `rem` p /=0" is False
04:22:08 <bz> :info (/=)
04:25:58 <fjordrunner> quchen2: it's me again,..in the document is says that I should use Data.Text.readMaybe which I can not find anywhere,...pls. where is it? :-)
04:29:47 <martinvlk> This may help: https://stackoverflow.com/questions/20831012/how-to-properly-use-the-readmaybe-function-in-io
04:30:06 <martinvlk> import Text.Read (readMaybe)
04:30:49 <martinvlk> https://hackage.haskell.org/package/base-4.8.1.0/docs/Text-Read.html
04:30:55 <merijn> fjordrunner: Text.Read.readMaybe, not Data.Text
04:31:02 <tdammers> there's also readMay from Safe
04:31:08 <fjordrunner> yes, but that works on String,...is there the same for Text?
04:31:31 <Intolerable> no, Read is only for Strings
04:31:47 <fjordrunner> referring to this: https://github.com/quchen/articles/blob/master/fbut.md#read
04:31:50 <quchen2> fjordrunner: That part seems wrong, yeah.
04:32:06 <quchen2> Open a ticket and I'll have a look at it later :-)
04:32:20 <fjordrunner> ok,..so only with unpack Text to String,...
04:32:33 <fjordrunner> thanks..
04:32:41 <Intolerable> what are you trying to read?
04:32:57 <fjordrunner> file
04:33:24 <Intolerable> you're just `read`ing an entire file?
04:33:30 <fjordrunner> and then parse each line into data structure,..
04:33:35 <Intolerable> is it one big structure?
04:33:37 <Intolerable> oh
04:33:46 <Intolerable> i would suggest not using read
04:33:56 <Intolerable> and perhaps consider parsing it properly instead
04:34:05 <Intolerable> with parsec / attoparsec
04:34:07 * hackagebot bustle 0.5.2 - Draw sequence diagrams of D-Bus traffic  https://hackage.haskell.org/package/bustle-0.5.2 (WillThompson)
04:34:12 <fjordrunner> yes, now I switched to readMaybe
04:35:48 <catofhask> Hi, I am working on a proffessional haskell project which is average in size. Our builds are getting really slow few times. Any pointers to imporve the situation?
04:36:23 <quchen2> catofhask: Compile with -O, not -O2
04:36:47 <bennofs> or try -O0 for fast feedback
04:37:15 <bennofs> also, if you just need syntax/error checking, try cabal repl / ghci and doing :r  (also enable -fobject-code).
04:37:17 <catofhask> quchen2: Thanks, anything else I can look into
04:37:18 <dramforever> catofhask: if you use ghci then you can use -fno-code for quick loading
04:37:36 <dramforever> http://chrisdone.com/posts/making-ghci-fast
04:37:38 <bennofs> dramforever: -fno-code only makes sense if you want to compile many modules again every time
04:37:46 <dramforever> oh sorry
04:37:57 <dramforever> catofhask: sorry bennofs pointed out that it's wrong
04:38:07 <catofhask> bennofs: sometimes when we switch between branches, it;s really slow
04:38:08 <dramforever> but do look at the making-ghci-fast thing if you use it
04:38:21 <bennofs> dramforever: oh, no, I see that the posts says that -fno-code works in combination with -fobject-code... I wonder how that works
04:38:28 <dramforever> oh
04:39:30 <catofhask> okay thanks, will try these :)
04:41:23 <Sindriava> How kosher are empty classes?
04:41:34 <merijn> Sindriava: Why do you ask?
04:41:41 <Sindriava> In other words, is there a way to compose typeclasses?
04:41:46 <Sindriava> merijn: ^
04:41:48 <merijn> Sindriava: They're a bit pointless, unless you're doing hacky type level stuff
04:42:38 <merijn> Sindriava: Maybe you wanna abuse ContraintKinds? Then you can do "type Foo a = (Read a, Show a, Num a)" and write "Foo a => a -> a" (at least, think this was ConstraintKinds?)
04:42:41 <Sindriava> merijn: I'm looking to do something like: class (HasWidth a, HasHeight a) => HasSize a
04:42:44 <merijn> There is an extension that lets you do this
04:43:01 <Sindriava> merijn: Oh yeah, that's exactly what I want ^^
04:43:08 <Sindriava> I'll search the extension list, thanks ^^
04:43:21 <dramforever> @let type Foo a = (Read a, Show a, Num a)
04:43:22 <lambdabot>  Defined.
04:43:28 <dramforever> must be ConstraintKinds
04:43:47 <Sindriava> :t 1 :: Foo Int
04:43:48 <lambdabot>     Expected a type, but ‘Foo Int’ has kind ‘Constraint’
04:43:49 <lambdabot>     In an expression type signature: Foo Int
04:43:49 <lambdabot>     In the expression: 1 :: Foo Int
04:43:59 <Sindriava> :t 1 :: Foo a => a
04:44:00 <lambdabot> (Num a, Read a, Show a) => a
04:44:03 <Sindriava> Neato
04:44:05 <bennofs> Sindriava: the hack of using empty classes is used sometimes anyway to achieve greater compatibility with older GHC versions (ConstraintKinds is fairly new-ish afaik)
04:44:15 <merijn> Sindriava: Downside is that you have to  enable ConstraintKinds in all modules using the alias
04:44:17 <Intolerable> :t 1 :: (Foo a, a ~ Int) => a
04:44:18 <lambdabot> Int
04:44:31 <Sindriava> merijn: I'll probably enable it in my cabal file, it's useful all around I guess
04:44:45 <dramforever> I would do it in every file instead
04:45:34 <Sindriava> This is one of the extensions I kinda feel shouldn't be an extension
04:45:58 <Sindriava> Or maybe i'm missing the point of extensions
04:47:32 <merijn> Sindriava: Extensions are things that do not conform to the Haskell Report 2010
04:47:53 <Sindriava> merijn: Huh… So they might get included in the next report?
04:48:18 <merijn> Sindriava: Yes, assuming a next report is released
04:48:24 <merijn> Might take a while
04:48:44 <Sindriava> Good to know ^^ I'm all for including this, since it's doable with empty classes anyways
04:48:44 <merijn> The report exists to standardise implementations, but currently there's only 3 and only 1 that people really care about
04:49:08 <Sindriava> I know of GHC and Hugs, what's the third one?
04:49:16 <dramforever> 3 reports
04:49:30 <Sindriava> Oh, I see, I thought that meant 3 implementations
04:50:19 <merijn> Hugs is dead
04:50:23 <merijn> dramforever: No, 3 implementations
04:50:28 <dramforever> ho
04:50:29 <dramforever> oh
04:50:32 <dramforever> sorry
04:50:34 <merijn> GHC, UHC and Standard Chartered's closed source thing
04:51:39 <quchen2> Mu?
04:54:26 <merijn> Yeah
04:59:09 * hackagebot json-stream 0.3.1.0 - Incremental applicative JSON parser  https://hackage.haskell.org/package/json-stream-0.3.1.0 (ondrap)
04:59:11 * hackagebot observable-sharing 0.2.2.1 - Simple observable sharing  https://hackage.haskell.org/package/observable-sharing-0.2.2.1 (mararon)
04:59:45 <bz> hm, all line fractals are r to r2 mapps
05:07:27 <merijn> I think I asked before, but I forgot
05:07:34 <merijn> Is there like a matplotlib for haskell?
05:10:18 <asthasr> merijn: gnuplot?
05:10:22 <asthasr> @hackage gnuplot
05:10:23 <lambdabot> http://hackage.haskell.org/package/gnuplot
05:14:34 <Robly18> uh, hello
05:15:16 <frerich> hi Robly18
05:15:26 <Robly18> hi
05:15:42 <Robly18> hey uh, i was wondering if anyone here could help a newbie out?
05:15:58 <frerich> Robly18: sure - shoot
05:16:16 <Robly18> ive been learning haskell for... quite a while now, and i recently nearly-finished the book i was using (learn you a haskell)
05:16:44 <Robly18> anyway, now that i managed to mostly understand monads, i wanted to do something more practical but
05:17:20 <Robly18> im not sure how to bridge the gap between "hey so this is what happens in do notation" and "hey look its a program that does useful things"
05:17:23 <Sindriava> Can I constrain a data field?
05:17:51 <Sindriava> Something like data Foo = Foo { a :: Constraint b => b }
05:17:58 <asthasr> Robly18: Are you a professional programmer?
05:18:36 <frerich> Robly18: You could try to tackle some 'real-life' project, like - fetching JSON stock quotes from Yahoo and generating statistics or so. And in the process of doing so, you may or may not find using 'do' notation (or something else you learned) to be useful or not.
05:18:43 <asthasr> I ask because, as a "back end" programmer, there is one type of task that I think is always suited to a new language
05:18:47 <asthasr> namely, ETLs
05:19:05 <asthasr> they are relatively self contained, but frequently complex enough to be at least slightly interesting
05:19:11 <asthasr> if only in terms of squeezing performance out of them
05:19:15 <frerich> Robly18: Also, you'll probably learn a lot of stuff along the way -- and once your program 'does something' you can have other people (e.g. here in #haskell) review your code and suggest improvements.
05:19:24 <merijn> asthasr: gnuplot is exactly what I'm trying to avoid
05:19:33 <asthasr> merijn: Sorry :p
05:19:37 <merijn> asthasr: Because it's often not flexible enough for what I want
05:20:00 <merijn> asthasr: The entire reason I moved to matplotlib is to avoid it. But I'd prefer something haskelly over python, because I suck at python >.>
05:20:01 <cocreature> merijn: there is also Chart but that's probably even less flexible
05:20:47 <Robly18> asthasr: whats an ETL again?
05:21:12 <Robly18> frerich: thanks for the suggestion, i think ill try doing something like that!
05:22:38 <asthasr> Robly18: it stands for "extract-transform-load." It's where you take data of one type, run various cleaning/transformation tasks on it, and then load it into a database or dump it in another format
05:22:58 <asthasr> sounds boring as heck, I know, but there is a range of quality to them
05:23:13 <Robly18> oh yeah that sounds simple enough to do
05:23:21 <frerich> Robly18: I think games are always fun, especially when you do something which supports networking. Something simple which works in text mode, say - connect four.
05:23:37 <asthasr> at a previous job, I had to load zip codes from the disc that the USPS provides... a colleague had written one that took 45 minutes to run, and I wrote one that took twenty seconds.
05:23:45 <asthasr> it was gratifying.
05:23:55 <_riba> another dumb question: i am using the lens operator ^. to get the value for a comparison, which is working, but when i want to get the string value as a string and use it as such i get weird errors
05:23:59 <_riba> am i using the wrong operator?
05:24:05 <Robly18> frerich: yeah games have been my "real world project" for other languages, but i dont think haskell is the best language for games is it
05:24:21 <Sindriava> :t (^.)
05:24:22 <lambdabot> s -> Getting a s a -> a
05:24:47 <Sindriava> _riba: Make sure you've got the types right and that you've got the precedence right
05:24:48 <frerich> Robly18: Depends. I always wrote some sort of 'game engine' and in HAskell, I wrote mastermind and four connect and a couple of other board games. The nice thing is that I don't need to bother with the graphics right now (I always have a hard time with that).
05:24:55 <merijn> Robly18: Depends on the game
05:25:09 <frerich> Robly18: And with games, there's always something to add! Persistent highscores, an AI etc. etc.
05:25:22 <Robly18> also a project i did try to make but fell short on
05:25:23 <merijn> Robly18: Real-time twitchy FPS? Probably not...turn-based, hack and slash multiplayer, whatever? Should work fine
05:25:28 <_riba> Sindriava, i'm just confused because comparing it to the empty string seems to work, but i'll take a closer look, thanks
05:25:29 <Sindriava> > show (42, "lel") ^. _1 
05:25:30 <lambdabot>      No instance for (Show a0)
05:25:30 <lambdabot>        arising from a use of ‘show_M867058283613537588219961’
05:25:30 <lambdabot>      The type variable ‘a0’ is ambiguous
05:25:39 <emc2> is there any reliable performance data on using hashtables vs unordered-containers.  Use case is for compiler intermediate structures: fill them up, never copy, never delete, then throw them away.
05:25:39 <Robly18> i tried to make a maze generation algorithm, but
05:25:39 <Sindriava> > show (42 :: Int, "lel") ^. _1 
05:25:41 <lambdabot>      No instance for (Show a0)
05:25:41 <lambdabot>        arising from a use of ‘show_M151414840167863597119986’
05:25:41 <lambdabot>      The type variable ‘a0’ is ambiguous
05:25:46 <Sindriava> > show $ (42 :: Int, "lel") ^. _1 
05:25:47 <lambdabot>  "42"
05:25:54 <Sindriava> _riba ^
05:26:12 <Robly18> i guess im not used to FP yet because i had/have no idea how id go about doing that with recursiveness and monads alone
05:26:17 <Sindriava> _riba: That sounds like a fixity error. Can you paste the code?
05:26:23 <frerich> Robly18: Dots and Boxes ( https://en.wikipedia.org/wiki/Dots_and_Boxes ) is also fun, especially once oyu start writing computer players. I once did a Dots and Boxes and the AI player had a TCP port wher eI could connect and it would serve an SVG dump of its 'brain' (the evaluation of various moves).
05:26:31 <dramforever> Robly18: monads aren't a separate concept
05:26:33 <asthasr> Robly18: Maze generation should be ideal! You can recurse on a representation of the grid. (I assume that your decision trees are based on "actors" making "decisions" at each step.)
05:26:35 <frerich> Robly18: It was funny to watch it 'think', especially when having two AIs play each other.
05:26:37 <_riba> Sindriava, thanks, i'll try that one
05:26:51 <dramforever> they just happen to have a special syntax
05:27:14 <dramforever> Robly18: hmm...that confirms "I'm not used to FP yet"
05:27:23 <Sindriava> Robly18: Can confirm that maze generation is fun. Also the AIs. I did it for Reversi and watching two AIs play is hella fun
05:27:41 <asthasr> you could also write a solver
05:27:54 <asthasr> there is sudoku, of course, but maybe something a bit more off the beaten path like nurikabe
05:28:41 <Robly18> okay so games, game solvers and algorithms. i think ill try making a maze again perhaps then?
05:28:58 <merijn> Any networking server is also easy in haskell, imo
05:29:59 <Robly18> but how do i *do* that? i mean, in imperative languages with mutable state its easy enough to do but... honestly im not sure i even got the hang of the random library yet?
05:30:27 <asthasr> Robly18: Then trying to do something with it is the perfect opportunity to do so.
05:30:53 <Robly18> i guess. how do you recommend i get started
05:31:18 <frerich> Robly18: A good start is to think about the types. For instance, try to think of the operations you'd want to do on a Maze and use that to decide on a data structure to model your Maze.
05:32:02 <Robly18> uhm, an array presumably? an array of tiles wherein each tile can have a down or left wall
05:32:13 <frerich> Robly18: Thinking about types also involves thinking about the types of functions. For instance, a plausible type for a function which generates maze might be... 'generateMaze :: Int -> Maze' where the Int argument would be some sort of seed.
05:32:39 <frerich> Robly18: You probably also want something like 'renderMaze :: Maze -> String' to get some pretty string representing a maze, such that you can print it.
05:32:57 <Robly18> right, i guess i should leave details like "generalize for arbitrary size" for later, huh. also yes that part looks easy enough to do
05:33:06 <frerich> At least I often start like that. Sketch a couple of types and functions and puzzle a bit, without actually implementing anything.
05:33:27 <Robly18> do you think i should use arrays for this, or is there some data type better suited for the job?
05:34:09 <asthasr> there is Data.Matrix; that might be more convenient, though I haven't used it
05:34:11 * hackagebot language-vhdl 0.1.0.0 - VHDL AST and pretty printer in Haskell  https://hackage.haskell.org/package/language-vhdl-0.1.0.0 (mararon)
05:35:44 <Robly18> that sounds good ill look into it
05:35:52 <asthasr> @hackage Data.Matrix
05:35:52 <lambdabot> http://hackage.haskell.org/package/Data.Matrix
05:36:12 <frerich> Robly18: I think something two-dimensional would be good. For what it's worth, you could postpone the definition - you could define that a maze is some sort of two-dimensional thing of cells. Each cell is either free, or a wall. And you could anticipate that you'll want to address cells by their X/Y coordinates.
05:36:25 <Robly18> also one thing: if i have, say, a function that reads an array as a linked list, should i be concerned for performance?
05:36:45 <Robly18> i would assume that due to laziness no actual copy of the array is created but
05:36:56 <frerich> Robly18: So without even knowing what 'Maze' will be, you could define 'getCell :: Maze -> (Int, Int) -> Maybe Cell' and 'setCell :: Maze -> (Int, Int) -> Cell -> Maze'
05:37:29 <frerich> Those functions may turn out to not even pull their own weight because they are so trivial, depending on what 'Maze' is in the end.
05:37:44 <Robly18> hmm alright, ill get started then. got notepad++ open, ill sketch some functions and see what i can do
05:37:56 <Robly18> thank you all so much for your help
05:50:04 <bazzle> hi, can I find someone willing to help with STM exceptions here?
05:50:35 <bazzle> specifically 'thread blocked indefinitely in an STM transaction' thrown where a thread is not actually blocked
05:51:09 <merijn> bazzle: You are wrong
05:51:16 <merijn> bazzle: Else that exception wouldn't be thrown
05:52:25 <merijn> bazzle: Those kinds of exceptions only get raised if your blocked on something that can never succeed (i.e. blocked on a TVar that's being garbage collected)
05:52:27 <bazzle> possibly, I hope so
05:52:33 <Phillemann> Is there a zip function that somehow compensates for lists of different lengths (for example, by generating pairs with Maybe in it)?
05:52:51 <merijn> Phillemann: Do you know in advance which list is shorter?
05:52:56 <bazzle> what I have is multiple threads waiting for a single one that gets killed by GC (I presume) in the middle of execution
05:53:02 <Phillemann> merijn: Yes.
05:53:14 <bazzle> merijn: want to look at the source?
05:53:15 <merijn> Phillemann: Just "++ repeat defaultElement", then
05:53:43 <Phillemann> Hm...you're absolutely right. Thanks :)
05:54:00 <Phillemann> My thinking was too complicated :D
05:54:44 <bazzle> suprizingly enough, everything works if I run a STM atomically operation at `finally` for each thread
05:54:51 <bazzle> which is just the weirdest thing
05:56:04 <mek42> Any reason not to use emacs haskell-mode to learn Haskell?
05:56:18 <arahael> mek42: Just don't use it for literate haskell.
05:56:34 <arahael> Not with the > style, anyway.
05:56:40 * arahael is gone.
05:59:31 <bazzle> and the kill by GC happens at random places
05:59:42 <Robly18> hey uh, a problem im facing with FP inexperience: how would i go about implementing an algorithm, say, on graphs, that requires me to ask "has this node been visited before?"
06:00:13 <bazzle> I would hold a map of visited nodes somewhere
06:00:15 <dramforever> pass a map around
06:00:21 <dramforever> bazzle ++
06:00:24 <bazzle> :P
06:00:24 <Hafydd> A set, surely.
06:00:55 <dramforever> pretty sure you can unify the set with the map
06:02:09 <Robly18> so basically pass things around, thanks
06:02:11 <Hafydd> I'm sure; but why Map Node () when you can use Set Node?
06:03:12 <dramforever> =)
06:04:13 * hackagebot yesod-table 1.0.5 - HTML tables for Yesod  https://hackage.haskell.org/package/yesod-table-1.0.5 (andrewthad)
06:06:46 <bazzle> soo, noone wants to devote some time to an untraceable parallel bug? :D
06:08:16 <ggVGc> sounds amazingly fun
06:08:52 <kuribas> bazzle: that's probably right
06:09:01 <bazzle> does it mean you would like me to talk about this exception I'm getting? :)
06:09:50 <kuribas> bazzle: You can talk as much as you want, I doubt I can help though
06:10:14 <bazzle> :sadface:
06:10:14 <kuribas> bazzle: show it anyway
06:10:38 <bazzle> ok, so I'm getting 'thread blocked indefinitely in an STM transaction'
06:10:41 <dramforever> hmm...interesting post
06:10:42 <dramforever> http://www.yegor256.com/2015/08/18/multiple-return-statements-in-oop.html
06:10:51 <bazzle> the code is at https://github.com/mkawalec/infopassenger-crawler
06:11:04 <bazzle> the file that's important is src/StationCrawler.hs
06:11:09 <dramforever> read the whole article, you'll notice something interesting
06:11:44 <bazzle> around the end of file, when line 179 is uncommented (and act above removed) there is no almost-immediate crash
06:12:09 <codedmart> Can you explicitly set which is overlapping and which is overlappable in 7.8 OverlappingInstances?
06:12:13 <bazzle> as the file is now, the whole thing crashes during execution with the aforementioned exception
06:13:49 <bennofs> bazzle: perhaps try reducing the example? 
06:14:15 <Brrruiser> Is someone at a disadvantage learning haskell as a first language?
06:14:35 <Intolerable> disadvantaged in what way?
06:14:55 <dramforever> Brrruiser: yes, you won't be able to talk about programs easily with other programmers
06:15:02 <dramforever> because you program in different ways
06:15:08 <frerich> Brrruiser: It won't be very interesting if all your friends do Java.
06:15:16 <bazzle> bennofs: I cannot really find a way of reducing it and still have it do something, but the part that crashes is small-ish
06:15:21 <bazzle> (I hope)
06:15:29 <frerich> Brrruiser: I'd go for whatever your friends/colleagues use.
06:15:35 <bazzle> I've added all these putStrLns for debugging
06:15:41 <Brrruiser> say I don't have any friends who program anyway...
06:16:06 <bennofs> bazzle: well, I would start by either a) stubbing out all functions that don't participate in the crash and b) inline all functions and put the whole code in one file
06:16:23 <dramforever> you won't be able to implement some algorithms efficiently
06:16:24 <frerich> Brrruiser: If you plan to eventually wri^H^H^Hdebug programs to pay your rent, it may be more useful to look into a more mainstream language.
06:16:29 <dramforever> oh
06:16:46 <dramforever> however they could be more elegant
06:16:54 <dramforever> *efficiently easily
06:17:13 <bennofs> bazzle: for example, removing the network stuff 
06:17:55 <bazzle> bennofs: possibly, but isn't this a kind of error that results from some obvious mistakes
06:18:16 <bazzle> going by what I read it would mean that a variable other threads are waiting on went out of scope
06:18:22 <bazzle> but this is not the case at all
06:18:48 <bazzle> so maybe it's because the variable is passed as a parameter it went out of scope?
06:18:52 <dramforever> it just means your thread can't possibly recover
06:18:55 <bazzle> or something to do with immutability
06:19:09 <dramforever> waiting indefinitely
06:19:09 <bennofs> bazzle: well, you don't decrease alive anywhere, do you?
06:19:15 <bazzle> which is odd, because it works with `finally` that is never reached
06:19:24 <bazzle> oh yes, but that part is never reached
06:19:37 <bazzle> that's the thing, it crashes milliseconds after starting
06:19:49 <bazzle> just after doing a first request
06:20:14 <bennofs> bazzle: that's because it detects that the main thread will never finish
06:20:22 <bazzle> oh
06:20:26 <bennofs> bazzle: because nobody's holding a reference to the alive var
06:20:33 <bennofs> bazzle: so no way that it'll ever reach zero
06:20:46 <bazzle> didn't know it's that clever
06:23:13 <rtpg> is there a good tool in do notation to drop all subsequent statements? Kind of like a break in a for loop in an imperative language
06:23:33 <Intolerable> MaybeT?
06:24:14 * hackagebot memory 0.8 - memory and related abstraction stuff  https://hackage.haskell.org/package/memory-0.8 (VincentHanquez)
06:24:56 <rtpg> hmm, I was thinking more if I had something like : do {a; b; c; d;}, is there something I could put in b that would make me just drop c and d
06:25:17 <dramforever> you can't do that in general
06:25:32 <dramforever> in IO you could use stuff in System.Exit
06:26:13 <rtpg> oh yeah, I guess it's not super possible considering the type of bind
06:26:23 <dramforever> yep
06:26:26 <rtpg> oh well, I guess I'll just do things cleanly
06:26:46 <Gurkenglas> My code is starting to look like this: http://lpaste.net/7051586703684796416 (Excuse the German.) I comment out different lines depending on what tweaks I want to run the program with that time. What's the idiomatic way to do this?
06:28:25 <absence> rtpg: maybe mzero if you have a MonadPlus instance?
06:28:39 <bazzle> bennofs: thanks for that pointer. One more thing, if I may: I have threads parsing a page and adding some links into the pool of pages yet to parse, a crawler basically
06:28:54 <bazzle> how would you determine when to finish crawling? 
06:29:04 <xelxebar> I'm working through Yorgey's course and am not understanding why this `ruler` function is smashing the stack. Any kind soul mind taking a look? http://lpaste.net/139109
06:29:30 <bazzle> I'm basically looking into a situation when all the threads are waiting for new links, but they are waiting for them inside an atomically block, so I understand I cannot set any variable from there
06:29:54 <kuribas> rtpg: I would do {a; if b then return () else do {c; d;}}
06:30:30 <xelxebar> From manual algebra, I'd expect laziness to work on my side so that I could pull off the first elements without a problem. But it looks like I made some unterminating thing?
06:31:08 <rtpg> kuribas: that's what I'm going to end up doing. I kind of wanted to avoid the resulting indentation. I think, long term, the solution is to pull up the if statements into different functions so that my toplevel isn't encumbered by this
06:31:26 <Intolerable> (or shove your monad into MaybeT)
06:32:00 <Intolerable> which would allow you to break from anywhere by doing `MaybeT (return Nothing)`
06:32:05 <kuribas> rtpg: You could always abuse exceptions or ErrorT
06:34:10 <root____6> !help
06:34:47 <quchen2> Intolerable: = mzero
06:35:25 <bennofs> bazzle: just keep a counter of threads currently doing something (not waiting) and increase / decrease that before processing / waiting? Might also check whether the queue is empty before exiting
06:36:01 <lyxia> xelxebar: interleaveStreams is strict in its second argument
06:36:15 <bazzle> bennofs: but the threads go into a wait state in an atomically block, can I set anything from there?
06:36:24 <lyxia> xelxebar: using it with foldr forces the whole stream.
06:36:47 <bennofs> bazzle: well, you should not have big automically blocks, since nothing happens before the automically block finishes ...
06:36:54 <bennofs> bazzle: so just do it before the automically block
06:37:34 <bennofs> a/automically/atomically
06:38:16 <codedmart> anyone know if it is possible to explicitly set which is overlapping and which is overlappable in 7.8 OverlappingInstances?
06:40:06 <xelxebar> lyxia: Well, that's cute. Thank you very much!
06:40:20 <xelxebar> lyxia: Let me see if I can be smart enough to fix this.
06:41:57 <xelxebar> lyxia: `interleaveStreams (Cons a r) s = Cons a (interleaveStreams s r)` should do it, no?
06:42:05 <xelxebar> compiles and produces the expected output!
06:42:09 <lyxia> xelxebar: Right!
06:44:13 <xelxebar> lyxia: Really appreciate you taking the time!
06:44:27 <lyxia> You're welcome.
06:44:29 * xelxebar passes lyxia a thank you cookie
06:44:44 <dramforever> @botsnack
06:44:45 <lambdabot> :)
06:45:04 <dramforever> @thankyou
06:45:04 <lambdabot> you are welcome
06:45:07 <Sindriava> Can I constrain a data field? Something like data Foo = Foo { a :: Constraint b => b }
06:45:39 <dramforever> @let data Foo = Foo { a :: forall b, Show b => b }
06:45:40 <lambdabot>  Parse failed: Parse error: ,
06:45:43 <dramforever> duh
06:45:46 <dramforever> @let data Foo = Foo { a :: forall b. Show b => b }
06:45:47 <lambdabot>  .L.hs:148:1:
06:45:47 <lambdabot>      Multiple declarations of ‘Foo’
06:45:47 <lambdabot>      Declared at: .L.hs:146:1
06:45:52 <dramforever> @undefine
06:45:52 <lambdabot> Undefined.
06:45:52 <dramforever> @let data Foo = Foo { a :: forall b. Show b => b }
06:45:54 <lambdabot>  Defined.
06:45:55 <dramforever> :t a
06:45:56 <lambdabot>     Ambiguous occurrence ‘a’
06:45:56 <lambdabot>     It could refer to either ‘L.a’,
06:45:56 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:146:16
06:46:08 <dramforever> stupid evaluator
06:46:09 <dramforever> :t Foo
06:46:11 <lambdabot> (forall b. Show b => b) -> Foo
06:46:25 <quchen2> dramforever: Yes, but you shouldn't. https://github.com/quchen/articles/blob/master/fbut.md#imposing-constraints-on-data-types
06:46:27 <dramforever> Sindriava: wait what do you want?
06:47:14 <dramforever> looks like a use case for existential quantifiers
06:47:25 <Sindriava> dramforever: Interesting
06:47:34 <dramforever> what do you want?
06:47:35 <Sindriava> Basically, I have a reader monad on Config data field
06:47:48 <Sindriava> and I want the config data field to have a field for a Camera
06:47:56 <Sindriava> which is a class
06:48:03 <dramforever> oh
06:48:14 <dramforever> that one forces the argument to be polymorphic
06:48:29 <dramforever> so when destructing you can pick that type variable
06:48:42 <Sindriava> Hmmm
06:48:52 <zaefoawef> is there any reason why allocaBytes has type Int -> (Ptr a -> IO b) -> IO b and not Int -> (forall a . Ptr a -> IO b) -> IO b ?
06:49:06 <dramforever> zaefoawef: those are different
06:49:20 <Sindriava> dramforever: I basically never need to destructure it, since it's a reader monad
06:49:21 <dramforever> in the second one the function passed in must be polymorphic
06:49:41 <zaefoawef> the second one would hinder the ptr from escaping alloca? wont it?
06:49:48 <dramforever> no it won't
06:50:13 <dramforever> wait hmm...
06:50:14 <dramforever> hmm...
06:50:35 <Sindriava> If I understand correctly, the first is equivalent to (forall a . Ptr a), while the second to (forall a . Ptr a -> IO b) ?
06:50:36 <dramforever> yes it will!
06:50:54 <dramforever> but you can just easily cast that pointer
06:51:07 <dramforever> which 1. is required to be able to use that pointer
06:51:21 <dramforever> 2. defeats the anti-escape feature
06:52:06 <zaefoawef> can you give me an example how to cast the ptr so it can escape?
06:52:50 <dramforever> :t castPtr
06:52:52 <lambdabot> Not in scope: ‘castPtr’
06:53:01 <dramforever> :t Foreign.Ptr.castPrt
06:53:02 <lambdabot> Not in scope: ‘Foreign.Ptr.castPrt’
06:53:02 <dramforever> :t Foreign.Ptr.castPtr
06:53:03 <lambdabot> GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b
06:53:08 <dramforever> done
06:55:27 <zaefoawef> dramforever: so castPtr cheats the typesystem?
06:55:35 <dramforever> cheats this system
06:55:40 <dramforever> not really type system
06:55:49 <dramforever> because this pointer is just an address
06:56:13 <dramforever> zaefoawef: that parameter is a phantom
06:56:30 <dramforever> kinda like newtype X a = X Int
06:56:37 <dramforever> you could easily write X a -> X b
06:59:25 <quchen2> ?let data X a = X
06:59:26 <lambdabot>  Defined.
06:59:28 <quchen2> :t \X -> X
06:59:29 <lambdabot> forall (k :: BOX) (k1 :: BOX) (t :: k) (a :: k1). X t -> X a
06:59:40 <quchen2> ?undef
06:59:41 <lambdabot> Undefined.
06:59:54 <dramforever> whoa
06:59:56 <dramforever> polykinda
07:00:00 <dramforever> *polykinda
07:00:04 <dramforever> *polykinds
07:00:04 <quchen2> *polykinda
07:00:24 <dramforever> this word sounds great now somehow
07:00:45 <quchen2> Sounds polysomehow good ;-)
07:13:29 <benjwadams> Are there any high level libs to interface with numerics and formats such as HDF5?
07:14:20 <benjwadams> I love haskell as a language, but can't always find the functionality that's present in a package such as say, NumPy to use it in my everyday work
07:19:18 * hackagebot pandoc-crossref 0.1.3.0 - Pandoc filter for cross-references  https://hackage.haskell.org/package/pandoc-crossref-0.1.3.0 (lierdakil)
07:19:20 * hackagebot yi 0.12.2 - The Haskell-Scriptable Editor  https://hackage.haskell.org/package/yi-0.12.2 (DmitryIvanov)
07:20:01 <rtpg> How can I tell cabal to give my test suite the same dependencies of the main executable?
07:20:46 <kadoban> rtpg: Instead, put the vast majority of the functionality in a library, and have the executable and the test suite depend on the library
07:22:02 <kadoban> rtpg: You can depend on the library just by name in the same project, it's the name of the project.
07:23:45 <rtpg> a library is configured with `build-depends`, right?
07:25:15 <kadoban> rtpg: You use build-depends: the-library   in the executable and the test suite sections, if that's what you're asking.
07:31:08 <rtpg> I tried declaring the package as a library and putting the test suite with the dependencies, but when I run cabal test I'm getting error messages that make it look like the dependencies aren't being pulled in
07:31:15 <rtpg> https://github.com/rtpg/kwil/blob/31c51eb8751b106dcb20df0af58d245d62fa4b9d/kwil.cabal this is what my cabal file looks like atm
07:32:31 <kadoban> rtpg: If you're directly using depenencies in the test suite/executable, you still have to repeat those. Just if they're internal to the library you don't have to that way.
07:32:42 <martinvlk> @pl Compose $ ((<*>) <$> f) <*> a
07:32:42 <lambdabot> Compose (((<*>) <$> f) <*> a)
07:33:04 <muake> martinvlk: that's already pointfree
07:33:13 <rtpg> oooh I get what you mean. gotcha
07:33:15 <dramforever> :t (((<*>) <$> f) <*> a)
07:33:16 <lambdabot>     Couldn't match expected type ‘f (f1 a0)’ with actual type ‘Expr’
07:33:16 <lambdabot>     In the second argument of ‘(<*>)’, namely ‘a’
07:33:16 <lambdabot>     In the expression: (((<*>) <$> f) <*> a)
07:33:21 <dramforever> oh
07:33:25 <dramforever> :t \f a -> (((<*>) <$> f) <*> a)
07:33:26 <lambdabot> (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
07:33:39 <dramforever> hmm...interesting
07:33:54 <dramforever> @pl \f a -> (((<*>) <$> f) <*> a)
07:33:56 <lambdabot> (<*>) . ((<*>) <$>)
07:34:04 <dramforever> hey that's much simpler isn't it
07:34:17 <muake> :t (<*>) . fmap (<*>)
07:34:20 <dramforever> for some value of "simpler"
07:34:23 <lambdabot> (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
07:34:33 <dramforever> :t liftA2 (<*>)
07:34:34 <tdammers> just use Python
07:34:39 * tdammers runs away
07:34:48 <lambdabot> (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
07:34:51 <muake> :t (<*>) <$> (<$>) (<*>)
07:34:54 <dramforever> this is the simplest
07:35:01 <lambdabot> (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
07:35:22 * dramforever still thinks liftA2 (<*>) is the most understandable
07:35:43 <muake> :t ((<$>) (<*>)) ((<$>) (<*>))
07:35:52 <lambdabot> (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
07:35:57 <muake> beautiful
07:35:58 <chpatrick> stahp
07:36:05 <muake> symmetry achieved
07:36:34 <kuribas> Is wxHaskell the only option for OS X GUI programming?
07:37:02 <chpatrick> > ((++)<*>show)"((++)<*>show)"
07:37:04 <lambdabot>  "((++)<*>show)\"((++)<*>show)\""
07:37:22 <muake> no quining
07:37:40 <chpatrick> do you have the time
07:37:41 <chpatrick> to listen to me quine
07:37:50 <dramforever> oh
07:38:03 <dramforever> it's kinda easy to write a quine in haskell
07:38:56 <muake> it's pretty easy to write a quine in nearly anything that supports concatenation of string constants, including sh and cpp :-)
07:39:20 <dramforever> > show "this\\stri\ng" -- this makes it really easy
07:39:37 <lambdabot>  "\"this\\\\stri\\ng\""
07:40:06 <dramforever> s = "\nmain = putStrLn $ \"s = \" ++ show s ++ s"
07:40:06 <dramforever> main = putStrLn $ "s = " ++ show s ++ s
07:41:21 <Robly18> hey uh, is anyone here cool with reviewing a newbie's code?
07:41:34 <rtpg> thanks for the help, got the start of my testing up!
07:41:44 <Robly18> it compiles and presumably works, but id like a second oppinion on what to improve on
07:42:08 <nkaretnikov> Robly18: just paste it
07:42:17 <dramforever> don't paste it in the channel
07:42:19 <muake> er, but not in the channel
07:42:19 <dramforever> @paste
07:42:29 <Robly18> i put it in a pastebin
07:42:29 <muake> use http://lpaste.net/
07:42:31 <dramforever> hmm...I wonder why lambdabot is slow
07:42:53 <kadoban> > "I'm busy"
07:42:57 <muake> or yeah, pretty much anything you want. but lpaste.net automatically runs hlint on your code
07:43:23 <dramforever> and we could @letlpaste
07:43:27 <Robly18> okay heres the link
07:43:42 <Robly18> lpaste.net/139110
07:44:02 <Robly18> its basically a maze generator
07:44:16 <Robly18> wherein a node stores its position and the direction it came from
07:44:22 <muake> actual link: http://lpaste.net/139110
07:44:52 <Robly18> thanks, sorry, im using a laptop for development and tablet for irc :u
07:45:59 <nkaretnikov> Robly18: do you use tabs?
07:46:05 <chpatrick> Robly18: why are you using both let and where?
07:46:14 <chpatrick> in genGraph
07:46:21 <chpatrick> also you don't need to bracket (Set Node)
07:46:25 <Robly18> nkartnikov: yes but i have it set to 4 spaces
07:46:54 <Robly18> chpatrick: i guess i found it more readable that way? though i can always replace it, and i am, after all, here for feedback
07:47:19 <chpatrick> it's a bit redundant
07:47:27 <muake> line 29 looks like a parse error
07:47:28 <chpatrick> also inBounds could be 
07:47:43 <chpatrick> inBounds ( x, y ) = all () [ x, y ]
07:47:45 <chpatrick> err
07:47:59 <chpatrick> inBounds ( x, y ) = all (\c -> 0 <= c && c < 10) [ x, y ]
07:48:06 <chpatrick> I think that's a bit more readable
07:48:15 <Robly18> looks mpmore readable, thanks
07:48:23 <Robly18> will change accordingly
07:48:26 <muake> all (inRange (1, 10))
07:48:34 <Robly18> ohh thats good
07:48:55 <Robly18> but, it doesnt seemnto be in prelude
07:49:14 <muake> Data.Ix
07:49:38 <chpatrick> bit weird to use Ix just for that :)
07:49:41 <chpatrick> imho
07:50:25 <muake> well, there's not much else in there
07:50:41 <Robly18> what about the algorithm, anything i should be aware of?
07:50:56 <Robly18> should i be concerned for speed as im making a new pair of sets every iteration?
07:55:51 <merijn> Depends, how big is your graph?
08:01:00 <codedmart> OK so I have figured out my problem here http://lpaste.net/138722#line27 is in 7.10 I can specify which is overlapping and which is overlappable. How can I specify that for 7.8?
08:01:46 <codedmart> Can I specify which is overlapping and which is overlappable in 7.8?
08:02:25 <bennofs> codedmart: I think in GHC 7.8, there is no way to specify overlapping/overlappable. The OverlappingInstances extension will allow both
08:04:37 <codedmart> bennofs: Hmm… not sure how to fix my code for 7.8 then. Because 7.8 has the overlaps in the order I don't want.
08:07:44 <sgronblo> how can i list the installed versions of all/some package in a cabal sandbox?
08:08:28 <liste> sgronblo "cabal sandbox hc-pkg list"
08:10:47 <kuribas`> I am trying to debug a loop in ghci, but after ":trace myexpr" and C-c, I just get "Interupted".
08:10:52 <kuribas`> How do I get a stack trace?
08:11:57 <kuribas`> hm, weird, it works now...
08:12:39 <sgronblo> liste: thanks
08:14:36 <rtpg> The versions of base align with GHC versions right?
08:17:40 <liste> yw (:
08:18:04 <liste> rtpg yeah the base version is determined by GHC version
08:21:52 <S11001001> can someone backport all the new features from 7.10 to 6.8?  but also don't break anything that 6.8 currently works with
08:22:51 <merijn> S11001001: If you've got sufficient money to spend, maybe :p
08:23:01 <bennofs> S11001001: that would be a huge effort
08:23:14 <merijn> Probably easier to forward port anything to 7.10 :p
08:24:12 <S11001001> merijn: no I can't change anything, and this old application someone wrote for me needs to keep working without any changes
08:24:47 <S11001001> bennofs: I'm sure the ghc dev community has battalions of coders ready and waiting to fulfill user requests for implementation
08:24:53 <srhb> :P
08:29:22 * hackagebot feed 0.3.10.0 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  https://hackage.haskell.org/package/feed-0.3.10.0 (AdamBergmark)
08:43:09 <Jookia> Is there such a function signature as 'm (f a) -> (a -> b) -> m (f b)' ?
08:43:17 <Jookia> no signature, function with that signature
08:43:38 <Jookia> 'let inter f s = f >>= return . fmap s' seems to fit but doesn't seem right
08:43:38 <muake> :t ((<$>) (<*>)) ((<$>) (<*>))
08:43:39 <lambdabot> (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
08:43:47 <muake> oh, no
08:44:05 <muake> :t \m f -> fmap (fmap f) m
08:44:06 <lambdabot> (Functor f, Functor f1) => f (f1 a) -> (a -> b) -> f (f1 b)
08:44:22 <muake> :t fmap . fmap
08:44:23 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:45:09 <Jookia> i see
08:45:31 <Jookia> thank you!
08:54:44 <cheater> :t (<$> (<$> (<$>)))
08:54:45 <lambdabot> Functor f => (((a -> b2) -> b1) -> b) -> ((f a -> f b2) -> b1) -> b
08:56:15 <bennofs> :t (<$>) <$> (<$>)
08:56:16 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:59:23 * hackagebot moesocks 0.1.0.19 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.19 (JinjingWang)
09:05:53 <Robly18> hey uh, i have a set full of nodes with an associated direction. given a coordinate, what would be an efficient way to poll the direction?
09:06:28 <Robly18> so far ive been using head . toList . filter *coordenates are equal*
09:06:36 <kuribas`> Wouldn't it be nice if ghc would "fake" a Show instance for debugging purposes?
09:07:24 <kuribas`> I don't like having to write (Show a) for all my functions, because I want to use traceShow on a single nested function.
09:11:21 <mauris> Robly18, maybe make a map first with Map.fromSet?
09:11:45 <mauris> combined with mapKeys
09:11:54 <Robly18> that sounds good, thanks
09:14:08 <mauris> the former is O(n), the latter O(n log n), but maybe you can use mapKeysMonotonic instead, which is O(n) but can break your Map.
09:15:30 <zawehofawef> is it possible to derive Data instances from existential types?
09:16:04 <zawehofawef> i dont know why this error occurs? http://lpaste.net/1606933980546859008
09:18:52 <Robly18> hey if im using a strict map can i still do lazy shenanigans with it? e.g. if i have a map with bools can i do isNotMember x || map!x
09:20:02 <Intolerable> kuribas`: can you create an awful "instance Show a" thing?
09:20:27 <kuribas`> Intolerable: a is a type variable...
09:21:05 <Intolerable> no i mean literally just a dummy "instance Show a where show _ = "no show instance""
09:21:39 <Intolerable> i guess that wouldn't work because ghc has no concept of "every type is an instance of this class"
09:21:56 <Intolerable> so you'll still have to include "Show a =>" (but it would work for everything)
09:22:09 <Intolerable> also OverlappingInstances is nasty
09:23:59 <kuribas`> It's the including "Show a => " part which is tedious...
09:26:42 <rlewis> Intolerable even if it did work "no show instance" wouldn't be very useful for debugging purposes
09:26:59 <Intolerable> how not?
09:27:19 <Intolerable> the point is not to have a sensible show instance, it's to avoid having to write "Show a =>" on the front of every function you want to debug
09:27:38 <Intolerable> presumably overlappinginstances would still mean that if there was a proper Show instance, it would show that
09:27:48 <rlewis> uhm, if you don't print the value you're debugging what is the point in using traceShow at all?
09:27:48 <Intolerable> and otherwise just do "no show instance"
09:28:05 <Intolerable> that is not what we want
09:28:15 <Intolerable> we want to be able to put *anything* into traceshow
09:28:25 <Intolerable> without having to tack "Show a" constraints onto everything
09:28:27 <rlewis> ok whatever
09:28:33 <kuribas`> I guess I have to not be lazy, and add the Show instances ...
09:29:06 <rlewis> kuribas` yeah, it sucks. I've been there before. we need a more magical traceShow than just a plain haskell function
09:29:24 <Intolerable> how does lambdabot do it?
09:29:25 * hackagebot userid 0.1.0.0 - A library which provides the UserId type and useful instances for web development  https://hackage.haskell.org/package/userid-0.1.0.0 (JeremyShaw)
09:29:28 <Intolerable> > putStrLn "hello"
09:29:30 <lambdabot>  <IO ()>
09:29:59 <rlewis> just a plain Show instance for IO?
09:30:16 <Intolerable> > \x -> 0
09:30:16 <Jookia> ghci has :print
09:30:17 <lambdabot>      No instance for (Typeable t0)
09:30:17 <lambdabot>        arising from a use of ‘show_M693690464244316199023659’
09:30:17 <lambdabot>      In the expression:
09:30:59 <Intolerable> ah, id assumed it did some typeable magic stuff
09:32:21 <zawehofawef> is it possible ot derive a Data instance for an existential type? i try but getting the following type error http://lpaste.net/1606933980546859008
09:32:48 <bennofs> > \() -> () -- Intolerable there is certainly some Typeable magic in lambdabot
09:32:49 <lambdabot>  <() -> ()>
09:33:06 <chpatrick> bennofs: but it's actually compiling it
09:33:07 <Intolerable> > \x -> ()
09:33:08 <lambdabot>      No instance for (Typeable t0)
09:33:09 <lambdabot>        arising from a use of ‘show_M263512875249237467523772’
09:33:09 <lambdabot>      In the expression:
09:33:16 <chpatrick> so it has lots of extra info that you can't have from inside the language
09:33:20 <Intolerable> > \x -> const (x :: Int) ()
09:33:21 <lambdabot>  <Int -> Int>
09:33:24 <chpatrick> right?
09:33:29 <Intolerable> > \x -> const () (x :: Int) 
09:33:30 <lambdabot>  <Int -> ()>
09:33:58 <bennofs> chpatrick: I think that stuff is implemented inside the language. Just an instance (Typeable a, Show b) => Show (a -> b) or similar
09:34:13 <chpatrick> ah yeah
09:34:25 * hackagebot lens-simple 0.1.0.8 - simplified import of elementary lens-family combinators  https://hackage.haskell.org/package/lens-simple-0.1.0.8 (MichaelThompson)
09:35:42 <mauris> it bothers me that String essentially has an overloaded Show instance :(
09:35:55 <Intolerable> how do you mean?
09:36:02 <Intolerable> a string vs "a string"?
09:36:29 <kuribas`> rlewis: for debug it would be useful if ghc would autoderive an instance when there is none.
09:36:35 <mauris> following the instances for Show Char and Show a => Show [a], logically show "a" should be "['a']" not "\"a\""
09:36:51 <rlewis> kuribas` yeah
09:37:12 <kuribas`> maybe a new class DebugShow?
09:38:54 <chpatrick> mauris: is that a hack in ghc?
09:39:08 <chpatrick> or just an OverloadedInstance
09:39:25 <mauris> i don't really know
09:40:40 <chpatrick> mauris: it's from the showList of Char
09:40:43 <chpatrick> :t showList
09:40:44 <lambdabot> Show a => [a] -> ShowS
09:40:59 <chpatrick> still not too pretty
09:40:59 <mauris> aha
09:44:26 * hackagebot happstack-hsp 7.3.6 - Support for using HSP templates in Happstack  https://hackage.haskell.org/package/happstack-hsp-7.3.6 (JeremyShaw)
09:49:27 * hackagebot texmath 0.8.3 - Conversion between formats used to represent mathematics.  https://hackage.haskell.org/package/texmath-0.8.3 (JohnMacFarlane)
09:49:29 * hackagebot reform-hamlet 0.0.5 - Add support for using Hamlet with Reform  https://hackage.haskell.org/package/reform-hamlet-0.0.5 (JeremyShaw)
09:58:45 <asciiascetic> is there a standard modular arithmetic function that always returns positive? (i.e. -1 mod 7 == 6)? or should I write one?
09:59:05 <ReinH> showList is part of the typeclass so it can be defined for Char
09:59:23 <srhb> asciiascetic: rem?
09:59:40 <srhb> If I remember correctly what it actually does.
09:59:49 <Intolerable> > (-1) `mod` 7
09:59:50 <lambdabot>  6
09:59:59 <Intolerable> > (-1) `rem` 7
10:00:01 <lambdabot>  -1
10:00:03 <Intolerable> ?
10:00:13 <srhb> Ah yes, only the second argument I guess.
10:00:28 <asciiascetic> hah. ooh. right. (-1), I'd forgotten that the (-) evaluates after the `rem`
10:00:42 <Jookia> hahaha
10:00:45 <asciiascetic> > -1 `rem` 7
10:00:47 <lambdabot>  -1
10:00:51 <srhb> Oh, lol.
10:00:52 <Intolerable> > 1 `mod` (-7)
10:00:53 <lambdabot>  -6
10:00:57 <Intolerable> > 1 `rem` (-7)
10:00:59 <lambdabot>  1
10:01:11 <asciiascetic> excellent.
10:04:28 * hackagebot happstack-authenticate 2.1.5 - Happstack Authentication Library  https://hackage.haskell.org/package/happstack-authenticate-2.1.5 (JeremyShaw)
10:06:19 <bq_> is haskell a CS course nowadays?
10:06:30 <bq_> for CS major
10:06:44 <srhb> bq_: A number of CS majors around the world has Haskell courses.
10:07:29 <bq_> is this the reason why this channel so populous?
10:07:45 <Welkin> bq_: not likely
10:07:46 <srhb> No idea. I don't think so.
10:07:58 <Welkin> very few universities offer haskell courses
10:08:04 <zawefawef> hey, does anyone know how to derive Data instances from existential types. it seems like i get a type error in the autogenerated code: http://lpaste.net/745978709135065088, but i dont know how to fix it.
10:08:08 <Welkin> and it they do, they don't use it for the whole curriculum
10:08:17 <benjwadams> they're finally starting to move away from Java, at least
10:08:21 <rolo> not in italy for sure, every course on FP is based on OCAML or ML
10:08:26 <Intolerable> the kind of person that is only learning haskell for a course is unlikely to stick around in the #haskell irc, i would think
10:08:32 <Welkin> haha
10:08:33 <Welkin> yes
10:08:34 <srhb> That, too.
10:08:52 <srhb> But ML is a good gateway drug, too.
10:09:05 <Welkin> I find that people who take a course in something are usually doing it because they have to
10:09:08 <Welkin> not because they want to
10:09:12 <rolo> CS and Java will have a long lasting relationship
10:09:28 * hackagebot clckwrks 0.23.9 - A secure, reliable content management system (CMS) and blogging platform  https://hackage.haskell.org/package/clckwrks-0.23.9 (JeremyShaw)
10:09:34 <benjwadams> I suppose
10:09:52 <benjwadams> I took one course and it might as well have been about the Java toolchain/IDE environment instead of CS
10:10:03 <Welkin> lol
10:10:18 <benjwadams> I think programmers should be free to choose their own toolchains
10:10:27 <Welkin> it's sad that a lot of "CS" courses are just garbage about using some specific toolchain
10:10:52 <bq_> so what is the driving force behind this channel popularity?
10:11:02 <Intolerable> we had about 2 weeks of haskell for our first-year CS course
10:11:03 <Welkin> like those "Rails bootcamps" that people pay $30k for and last 6 months
10:11:11 <Intolerable> bq_: an enthusiastic community
10:11:36 <Welkin> bq_: our goal is not to be popular, it is to be the best that we can be and to improve the state of haskell
10:11:40 <Welkin> quality, not quantity is the goal
10:11:58 <benjwadams> yeah, I'm not even a great haskeller by any means, but it's probably one of the best communities.  #haskell and #postgresql IMO are great channels
10:12:20 <meditans> hi, let's say I want to check two binary trees for equality
10:12:31 <rolo> Rails bootcamps are 100% guaranteed to transform a literature major in a dickhead that poison your world
10:12:48 <rolo> true story
10:12:54 <Jookia> is that even a story
10:13:10 <meditans> but halting the comparison as soon as I reckon that two leaves are different
10:13:23 <robertigno699> !list
10:13:23 <monochrom> robertigno699: http://okmij.org/ftp
10:13:51 <meditans> and I am in a language with strict evaluation, which doesn't shortcircuit even the logical operation
10:13:58 <Intolerable> meditans: what does your Tree data type look like?
10:14:11 <meditans> would it be correct to say that I can't do that?
10:14:32 <meditans> Intolerable: it's a gedankenexperiment. Let's say Tree a = Leaf Int | Branch (Tree a) (Tree a
10:14:35 <meditans> )
10:14:49 <Welkin> meditans: guarded recursion
10:15:03 <benjwadams> rolo: lol.  aren't you being overly broad here.  I'm sure there are plenty of nice people in Rails community
10:15:19 <rolo> for sure :)
10:15:50 <meditans> Welkin: yes, that's right, thanks
10:16:02 <RedNifre> heya
10:16:24 <Brrruiser> rolo: is lit grad to programmer a thing?
10:16:52 <zawefawef> hey, does anyone know how to derive a Data instance from a existential type. I'm getting this type error, which i don't understand: http://lpaste.net/745978709135065088 maybe anyone can tell what ive done wrong?
10:17:02 <rolo> i've actually met a girl who switched from being a major in asian culture to a ruby dev
10:17:06 <benjwadams> Well we have a fellow who did a MFA here, later got his CS degree, and does frontend development now
10:17:19 <Welkin> Brrruiser: the stereotype is "self-taught rails developer who studied philosophy/literature/some other humanity in college"
10:17:32 <rolo> that's the magic of low wages webdev jobs
10:17:32 <RedNifre> How to turn a 'hashmap of a to m b' into a 'm (hashmap of a to m b)'? You know, like sequence turns [m a] into m [a]? E.g. a list of IO Strings into an IO List of Strings?
10:18:28 <Intolerable> :t sequence :: Monad m => M.Map a (m b) -> m (M.Map a b)
10:18:29 <lambdabot> Monad m => M.Map a (m b) -> m (M.Map a b)
10:18:31 <srhb> RedNifre: If the HashMap is traversable, then sequence.
10:18:31 <Intolerable> ?
10:18:48 <rolo> btw, i'm not against someone who studied something "not" related to 1's and 0's working in the field as long he's passionate and stuff
10:18:57 <RedNifre> oh, from the documentation on hoogle I thought sequence would only work on lists.
10:19:05 <rolo> *he's/she's
10:19:09 <Welkin> :t sequence
10:19:10 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
10:19:11 <srhb> RedNifre: They information might be outdated. It's a 7.10 thing
10:19:14 <srhb> afair.
10:19:28 * hackagebot llvm-pretty-bc-parser 0.2.1.0 - LLVM bitcode parsing library  https://hackage.haskell.org/package/llvm-pretty-bc-parser-0.2.1.0 (TrevorElliott)
10:19:37 <Welkin> sequence has always worked on anything that is an instance of Traversable
10:19:41 <srhb> Ah :)
10:19:50 <Welkin> before 7.10 you just had to import Data.Traversable
10:20:16 <RedNifre> I see. Thanks, sequence looks like what I need :)
10:20:19 <Intolerable> i do not miss having "import qualified Data.Traversable as Traversable" at the top of every module
10:22:44 <zawefawef> anyone knows how to derive a Data instance from a existential type? I'm getting this type error, which i don't understand: http://lpaste.net/745978709135065088 maybe anyone can tell what ive done wrong?
10:33:44 <arkeet> zawefawef: I don't think you can.
10:34:57 <zawefawef> arkeet: why i cannot?
10:35:13 <atondwal> Hey, have any of you seen a type like `data Node a b = Node a [Node b a]` ?
10:35:27 <atondwal> a tree with types alternating on each depth
10:35:46 <kuribas`> like a redblack tree?
10:36:04 <atondwal> so it's obviously a bifunctor, but I want to be able to define something like a comonad instance for it
10:36:09 <atondwal> kuribas`: exactly
10:36:32 <kadoban> A red-black tree wouldn't have the type alternating like that. It'd only have one type variable.
10:36:53 <atondwal> okay not exactly
10:37:10 <atondwal> but alternating in the same way, just minus the invariants
10:39:22 <emc2> is there any library out there that provides frozen hash tables, similar to IArray vs MArray?
10:39:47 <atondwal> I figured maybe edwardk has something like a bicomonoad typeclass written somewhere
10:41:03 <catgocat> What are some good updated resources for Exceptions and Errors in Haskell ?
10:41:13 <catgocat> Something like a tutorial.
10:42:10 <johnw> atondwal: that can't be a comonad
10:42:52 <emc2> though I suppose if you're going to build a read-only hash table, you'd probably want to do linear perfect hashes or something similar
10:43:20 <atondwal> johnw: but something analagous?
10:43:33 <johnw> what would be analogous ?
10:43:43 <johnw> if the branch list is empty, you've got an 'a', nothing else
10:43:49 <catgocat>  What are some good updated resources for Exceptions and Errors in Haskell ?
10:43:52 <johnw> and 'a' isn't the last type variable
10:44:55 <atondwal> well, data Tree a = Tree a [Tree a] is a comonad, isn't it?
10:45:01 <johnw> yes
10:45:04 <S11001001> yah
10:45:07 <atondwal> so the fact that it could have zero kids isn't a problem, right?
10:45:08 <johnw> because theres always an 'a', and it's the last type variable
10:45:48 <atondwal> yeah, so I think there should be something analagous to comonad that takes two type variables
10:46:08 <atondwal> and behaves like a comonad in both
10:46:16 <johnw> your Node still wouldn't be that
10:46:25 <atondwal> I was jus hoping someone here knew it off the top of their head
10:46:27 <atondwal> why not?
10:46:33 <johnw> 10:43 <johnw> if the branch list is empty, you've got an 'a', nothing else
10:47:02 <johnw> there are Bicomonads, they are defined as monoidal comonads
10:47:52 <atondwal> ah, so there's no `extract (Node a [])` in the second type parameter
10:48:01 <johnw> right
10:48:26 <atondwal> if I flip the parameters, could I make it a comonad in the second one?
10:48:39 <johnw> Node b a = Node a [Node a b]?
10:48:48 <atondwal> yeah
10:49:13 <johnw> I can see how to write extract for that, but you'll have to try to write a law-abiding 'extend'
10:49:30 <atondwal> yeah...
10:52:52 <catgocat> Can anyone tell me how to learn about Control.Exception??
10:52:54 <catgocat> please??????????
10:53:31 <johnw> catgocat: there are so many resources if you Google for exception handling in Haskell, that I'm not sure what you're really asking
10:53:38 <catgocat> there are not
10:53:41 <catgocat> why don't you google
10:53:49 <johnw> I just did
10:53:55 <johnw> read everything that appears on the first page of hits
10:54:06 <kuribas`> catgocat: http://chimera.labs.oreilly.com/books/1230000000929/ch08.html
10:54:11 <catgocat> It must be because i'm in a different country, because all I see is the hoogle page
10:54:14 <catgocat> which is not good for learning
10:54:24 <johnw> ah, that's quite possible
10:54:28 <Welkin> catgocat: one of the best resources is the source itself!
10:54:31 <johnw> http://book.realworldhaskell.org/read/error-handling.html
10:54:35 <Welkin> Be sure to check the source and read the comments
10:54:38 <johnw> http://stackoverflow.com/questions/6009384/exception-handling-in-haskell
10:54:41 <Welkin> they are packed with useful information
10:54:46 <johnw> http://www.randomhacks.net/2007/03/10/haskell-8-ways-to-report-errors/
10:54:48 <atondwal> yeah, google is no longer a safe pointer :)
10:54:49 <catgocat> johnw: real world haskell is outdated..
10:54:51 <johnw> http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
10:54:56 <catgocat> I have already tried reading it, nothing works
10:54:59 <Welkin> catgocat: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Exception.html#SomeException
10:54:59 <johnw> http://drunkcoding.tumblr.com/post/692076953/catching-exceptions-in-haskell
11:01:53 <catgocat> Why doesn't this work: `r <- tryJust (\e -> Just ()) (return "TEST")`
11:03:00 <Cale> catgocat: Probably ambiguity?
11:03:07 <catgocat> why?
11:03:13 <catgocat> how can I make it work
11:03:16 <Cale> catgocat: Try using (\(SomeException e) -> Just ())
11:03:16 <osa1> does anyone know why some Vector functions are missing for mutable vectors? like this ones http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable.html#g:29 we don't have these for mutable variant of same vector
11:03:50 <catgocat> `r <- tryJust (\(SomeException e) -> Just ()) "ddas"`
11:03:51 <catgocat> doesn't work
11:03:54 <Cale> catgocat: It doesn't know which instance of Exception to use, because nothing is helping to pin down the type of the variable e
11:04:02 <Cale> uh
11:04:09 <arkeet> "ddas" is a string.
11:04:13 <Cale> Prelude Control.Exception> tryJust (\(SomeException e) -> Just ()) (return "TEST")
11:04:13 <Cale> Right "TEST"
11:04:22 <catgocat> Oh right it "worked"
11:04:24 <catgocat> I added return
11:04:36 <catgocat> But why is the result Right "das" ?
11:04:54 <catgocat> isn't it tryJust?
11:04:58 <arkeet> :t tryJust
11:04:59 <lambdabot> Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
11:05:00 <catgocat> doesnt make sense
11:05:03 <catgocat> but why
11:05:22 <arkeet> there was no exception.
11:05:37 <Cale> The result is an IO action which when executed produces an Either () String
11:05:52 <catgocat> what is the difference between Exception and SomeException?
11:05:54 <Cale> GHCi executes the action automatically, and prints the result
11:06:01 <catgocat> why can't I use (Exception e) in my lambda
11:06:06 <arkeet> Exception is a typeclass.
11:06:25 <catgocat> and what it is useful for
11:06:26 <Cale> Exception is a class, SomeException is an existential datatype, whose argument can be of any type which is an instance of Exception.
11:06:49 <Cale> I should say, "whose constructor's argument"
11:07:00 <Cale> :t SomeException
11:07:00 <lambdabot> Exception e => e -> SomeException
11:07:42 <catgocat> > r <- tryJust (\(SomeException e) -> Nothing) (return "hello")
11:07:43 <catgocat> > r
11:07:43 <catgocat> <interactive>:50:1:
11:07:43 <catgocat>     No instance for (Show GHC.Prim.Any) arising from a use of `print'
11:07:43 <catgocat>     In a stmt of an interactive GHCi command: print it
11:07:43 <catgocat> >
11:07:44 <lambdabot>  <no location info>:
11:07:44 <lambdabot>      not an expression: ‘r <- tryJust (\(SomeException e) -> Nothing) (return...
11:07:45 <lambdabot>  r
11:07:57 <lamefun> are there weak imports?
11:07:59 <Cale> Catching an exception of type SomeException will succeed in catching any and all exceptions.
11:08:12 <catgocat> I really don't know much of exceptions
11:08:20 <catgocat> why in that case if I put Nothing, I get an Any error?
11:08:46 <arkeet> :t tryJust (\(SomeException e) -> Nothing) (return "hello")
11:08:47 <Cale> GHCi aggressively defaulted the type of r
11:08:47 <lambdabot> IO (Either b [Char])
11:08:48 <lamefun> ie. if something else is imported with the same name, it's automatically hidden
11:08:56 <Cale> lamefun: no
11:09:00 <arkeet> it doesn't know what type to pick for b, so it picks Any.
11:09:13 <Cale> lamefun: But you can import Foo hiding (bar)
11:09:15 <catgocat> What is Any? 
11:09:19 <catgocat> is it a type?
11:09:22 <catgocat> a value ?
11:09:25 <arkeet> it's a "type"
11:09:37 <catgocat> used for what
11:10:20 <catgocat> so if I put Nothing and it triggers an error, what is it useful for? how can I make it useful
11:10:43 <catgocat> how can I make it return IO Left .. ? Because that is what it is supposed to return right
11:10:46 <osa1> uhhhh mutable storable vector doesn't even have fold http://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector-Storable-Mutable.html
11:10:50 <Cale> catgocat: GHCi is much more aggressive about trying to get your expressions not to fail with errors about ambiguous types. It will sometimes instantiate ambiguous type variables with Any in order to try to avoid that complaint.
11:11:09 <Cale> catgocat: You've mixed up types and values there in a way that I don't know what you mean
11:11:12 <Cale> IO Left?
11:11:32 <catgocat> I haven't mixed up anything
11:11:36 <Cale> What you're doing is not very useful... I don't understand what program you're trying to write.
11:11:42 <Cale> IO is a type constructor
11:11:45 <Cale> Left is a data constructor
11:11:52 <catgocat> If I put Just .. it should return IO (Right ..)
11:11:54 <Cale> They don't live on the same side of the ::
11:11:59 <catgocat> If I put Nothing what should it return
11:12:02 <Cale> What the heck is IO (Right ...)?
11:12:07 <Cale> That makes no sense
11:12:19 <catgocat> I mean Right .. wrapped in IO
11:12:21 <catgocat> :(
11:12:27 <Cale> IO is not a data constructor
11:13:11 <lingxiao> hey all
11:13:11 <catgocat> let's forget about what I said. Tryjust should return IO Either a b, if the lambda returns Just, then the all thing should return Right ..
11:13:17 <catgocat> what if it returns Nothing ??
11:13:20 <lingxiao> I'm playing with conduit following the doc: https://github.com/snoyberg/conduit#readme
11:14:19 <Cale> catgocat: Then the exception will be rethrown.
11:14:23 <Cale> tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
11:14:24 <Cale> A variant of try that takes an exception predicate to select which exceptions are caught (c.f. catchJust). If the exception does not match the predicate, it is re-thrown.
11:14:24 <lingxiao> and in this bit of code:
11:14:25 <lingxiao> http://lpaste.net/139123
11:14:52 <lingxiao> I'm getting  No instance for (MonadIO (ConduitM String Data.Void.Void IO)) arising from a use of liftIO
11:15:07 <lingxiao> this is after i ran cabal update
11:15:30 <lingxiao> I have ghc 7.8.3 
11:15:34 <lingxiao> if that's of any help
11:16:48 <Cale> lingxiao: hm, that's interesting, the documentation indicates that there's an instance MonadIO m => MonadIO (ConduitM i o m)
11:16:57 <lingxiao> yeah right?
11:16:58 <codedmart> Just asking one more time in case someone has a different answer. Can I specify which instance is overlapping and which is overlappable with ghc 7.8 OverlappingInstances?
11:17:03 <lingxiao> so I'm not sure whats going on
11:17:23 <Cale> lingxiao: Moreover that instance is in the same module as ConduitM, so there's no way to get the type in scope without having the instance.
11:17:34 <minad> hi! how can I find out the correct type if I write an undefined as a placeholder?
11:17:39 <minad> in emacs for example
11:18:23 <lingxiao> so by importing Data.Conduit, I also get ConduitM right?
11:18:33 <Cale> lingxiao: yes
11:18:37 <kclancy> What should I read to learn about Monad transformers? I started reading "Monad Transformers Step by Step", but it seems a bit out of date.
11:19:46 <lingxiao> kclancy http://www.seas.upenn.edu/~cis552/13fa/schedule.html
11:20:34 <kclancy> lingxiao: That looks great. Thanks!
11:20:48 <lingxiao> yup the whole class is very useful
11:21:05 <chpatrick> osa1: dunno
11:21:09 <chpatrick> maybe you're expected to unsafefreeze
11:21:12 <joshgrib> Hey haskellers, I've done a little C++ and a significant amount of python. I've thought haskell seemed cool for a while based on the community and how it seems like there's a different mindet from many other languages. What would be a good project for a total beginner to learn some haskell and see the value in the language?
11:21:15 <chpatrick> then use the immutable ones
11:21:31 <Cale> minad: turn on -fwarn-typed-holes and then write a placeholder like _foo instead of undefined
11:21:35 <chpatrick> joshgrib: write a compiler? :)
11:21:37 <lingxiao> kclancy also this is a bit more advanced, but i find it solidifies some concepts:
11:21:37 <lingxiao> https://themonadreader.files.wordpress.com/2011/10/issue19.pdf
11:21:48 <liste> joshgrib parsing's great with haskell
11:21:48 <Rembane> joshgrib: I go +1 on chpatrick 
11:21:49 <lingxiao> search for Coroutine Pipelines by Blazevic
11:22:02 <kclancy> okay. I might look at that too. 
11:22:04 <Cale> minad: It will report that it found a hole and tell you what type it has, as well as the types of nearby bindings in scope.
11:22:06 <chpatrick> joshgrib: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
11:22:29 <lingxiao> joshgrib parser is usually what some people start with 
11:22:54 <caconym> joshgrib: I second WYASI48H, I did that pretty early on and didn't even finish it but learned a great deal
11:22:55 <lingxiao> or err i see someone else already said that
11:23:03 <Cale> joshgrib: That totally depends on what kinds of programs you like to write :)
11:23:34 <lingxiao> ok may i please ask someone to compile that bit of code I had and see if they're getting the same issue?
11:23:36 <liste> board games like tic-tac-toe are fun too
11:23:42 <lingxiao> I restarted ghci and have the same issue 
11:23:47 <liste> to write in Haskell
11:24:06 <minad> Cale: seems like the right thing. But I don't get it to work. Maybe my ghc is too old
11:25:02 <Cale> minad: Which version of GHC are you using?
11:25:30 <minad> 7.6.3
11:25:39 <Cale> minad: Yeah, that's too old.
11:25:41 <minad> it is documented in 7.14
11:25:42 <minad> :(
11:25:49 <geekosaur> it's in 7.8 and later
11:26:02 <minad> Debian :-P
11:26:09 <Cale> minad: 7.6.3 is from 2013 :P
11:26:16 <geekosaur> yep
11:26:36 * geekosaur uses Mint, needs to look into switching from debian packages to latest platform
11:26:38 <joshgrib> Cool, that seems like a really cool thing to do. I'm taking a course that uses scheme in a few weeks when the fall semester at college starts too, so that will be really cool. Thanks guys! Go Haskell!
11:26:51 <Robly18> hey, question about matrices/lists
11:26:57 <julesjacobs> joshgrib, what were you programming in C++ and Python?
11:27:17 <minad> Cale: I can emulate something similar if I introduce a Hole data type :)
11:27:37 <Robly18> i have a representation of a maze by the down and right walls, and im trying to print it
11:28:12 <Robly18> but i cant seem to find a decent way to map or fold on matrices?
11:29:07 <Robly18> i tried to use a list comprehension but then i couldnt figure out how to intersperse two lists (i.e. "abc" -> "123" ->"a1b2c3"
11:29:36 <Robly18> any suggestions?
11:29:48 <julesjacobs> you could use transpose
11:29:54 <Cale> > transpose [[1,2,3,4],[5,6,7,8]]
11:29:55 <lambdabot>  [[1,5],[2,6],[3,7],[4,8]]
11:30:00 <Cale> > concat . transpose $ [[1,2,3,4],[5,6,7,8]]
11:30:02 <lambdabot>  [1,5,2,6,3,7,4,8]
11:30:49 <Robly18> ill try it thanks,
11:31:06 <Robly18> but still, is there any better way to do it seeing as this is a matrix?
11:31:16 <Cale> Robly18: Which matrix type?
11:31:19 <lingxiao> Cale any other ideas I should try to see what's going on?
11:31:35 <Cale> lingxiao: Can I see the whole program?
11:31:47 <Robly18> Cale: the one from Data.Matrix
11:31:56 <Robly18> specifically, a matrix of pairs of bools
11:31:59 <lingxiao> yup Cale http://lpaste.net/139124
11:32:13 <Cale> Robly18: the one from the matrix package on Hackage?
11:33:01 <Cale> lingxiao: that code builds just fine for me
11:33:09 <Cale> and runs
11:33:09 <lingxiao> :(
11:33:13 <lingxiao> what ghc do you have
11:33:19 <Cale> Are you sure you're compiling the thing you think you're compiling?
11:33:27 <Cale> 7.10.1
11:33:31 <Cale> I should really update...
11:33:45 <Robly18> Cale: im not certain if its from hackage... its from the library matrix-0.3.4.4
11:33:59 <Cale> Robly18: yeah, that seems like it.
11:34:05 <Cale> Robly18: What are you trying to compute?
11:34:19 <lingxiao> yeah I have ghc 7.8.3
11:34:23 <lingxiao> maybe i should update too?
11:34:39 <Cale> lingxiao: Yeah probably, but I don't think that's your problem.
11:34:57 <lingxiao> yeah I one file with exactly that code in it
11:34:58 <Robly18> Cale: basically i have a maze represented by a matrix. i want to take the matrix and represent the maze as a string,
11:35:04 <julesjacobs> Robly18, I'd look at the matrix you have row by row. for each row you turn the booleans into the right | ||| | pattern, then interleave spaces
11:36:01 <Robly18> julesjacobs: thats what i was thinking, how would i go about doing that? the only idea i have is list comprehensions, and at this scale it feels somewhat ugly?
11:36:25 <lingxiao> which version of ghc should I get?
11:36:43 <cocreature> Robly18: nested maps and intersperse
11:36:52 <julesjacobs> first write two functions to extract a row and turn it into a list of booleans, for horizontal and vertical segmentes
11:36:58 <lingxiao> I see 7.10.2 is the most recent one
11:37:05 <julesjacobs> then turn that list of booleans into the appropriate string
11:37:07 <Cale> lingxiao: Yeah, 7.10.2
11:37:24 <lingxiao> Im just wondering if anyone has had any problems with it 
11:37:30 <Robly18> alright ill try that
11:37:58 <chpatrick> kclancy: imo, just look at the newtypes :)
11:38:02 <Cale> lingxiao: In general, the .1 releases are a bit scary to switch to immediately, because libraries might not have updated yet, and there may be some bugs associated with new features, but the .2 releases of GHC tend to be pretty safe :)
11:38:07 <chpatrick> oh wow forgot to scroll
11:38:09 <julesjacobs> by the way, why are you using the matrix type, rather than a 2d array?
11:38:15 <lingxiao> Cale gotcha thanks!
11:38:29 <lingxiao> oh btw
11:38:29 <lingxiao> https://www.haskell.org/platform/
11:38:37 <lingxiao> this should always give the newest ghc right?
11:38:46 <Robly18> julesjacobs: i was using a 2d array but someone suggested me to use the matrix
11:38:53 <kyclark> is there an easier way to join the elements of two lists on tabs?
11:38:54 <kyclark> zipWith (\x y -> intercalate "\t" [x,y]) ["foo", "bar"] ["1", "2"]
11:38:54 <kyclark> ["foo\t1","bar\t2"]
11:38:56 <lingxiao> oh nvm i see it does
11:38:59 <Cale> lingxiao: Not *always*, but right now it does.
11:39:35 <lingxiao> ok cool I'll do that and if it still does not compile I'll bother you guys some more
11:40:59 <chpatrick> kyclark: why not (\x y -> x ++ "\t" ++ y)?
11:41:00 <chpatrick> bit shorter
11:41:36 <kyclark> Yeah, that works.  Just wondering if I was missing some easy off-the-shelf method.
11:43:03 <chpatrick> that's pretty easy
11:43:54 <kyclark> I can't figure out why this doesn't work, though:
11:43:55 <kyclark> zipWith (intercalate "\t") ["foo", "bar"] ["1", "2"]
11:44:08 <kyclark> > :t intercalate
11:44:09 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:44:20 <kyclark> :t intercalate
11:44:21 <lambdabot> [a] -> [[a]] -> [a]
11:44:42 <chpatrick> kyclark: intercalate takes a list
11:44:56 <chpatrick> and zipwith is expecting a function of two values
11:45:14 <kyclark> Hmm, OK.  
11:45:16 <chpatrick> :t intercalate "\t"
11:45:17 <lambdabot> [[Char]] -> [Char]
11:45:22 <chpatrick> :t zipWith
11:45:23 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
11:48:34 <lingxiao> Cale fixed the problem 
11:49:14 <Cale> lingxiao: Interesting
11:49:23 <lingxiao> ha! yeah ..
11:49:39 <Gurkenglas> > map (intercalate "\t") $ transpose [["foo", "bar"], ["1", "2"]]
11:49:40 <lambdabot>  ["foo\t1","bar\t2"]
11:51:33 <mjrosenb> I have a list of items, and several maps (some of which are nested) built out of this list. I want to transform all of this data, the initial list, and all of the maps that were generated from it.
11:51:42 <mjrosenb> should I try to do these transformations in place
11:52:10 <mjrosenb> or should I just transform the initial set, and re-generate the maps?
11:52:55 <Gurkenglas> You use the maps a few times before the transformation?
11:55:37 <mada> the configurator library doesn't have the ability to write an already built Config value into a file, to save a default config for example?
11:58:32 <Gurkenglas> mada, you could try piping display into a file?
11:59:28 <mada> thank you
11:59:46 <Gurkenglas> I'm not sure whether that yields the correct format. Test it by loading the result back in.
12:02:03 <julesjacobs> Robly18, how is it going?
12:03:15 <Robly18> julesjacobs: pretty good, thanks!
12:03:27 <Robly18> am currently applying finishing touches
12:03:33 <Robly18> likenadding a border
12:04:08 <Robly18> but that aside, im pretty satisfied with what i accomplished! i can link you the code after im done if youd like
12:05:18 <julesjacobs> nice
12:10:15 <Robly18> okay this is a dumb question but is there any equivalent to C's /* */
12:10:23 <cruhl> How can I install ghc-mod with cabal on mac and automatically add it to path?
12:11:01 <kadoban> Robly18: {- omg comment -}
12:11:32 <Robly18> kadoban: thank you you just spared me 11 lines of commenting
12:11:35 <cruhl> kadoban++
12:11:42 <mauris> Robly18, {- -}
12:11:57 <ReinH> Robly18: My editor does the commenting for me.
12:12:39 <cruhl> Can anybody take a look at my question?
12:13:31 <cruhl> I know how to manually add an executable to the path, but I'd prefer an npm-style 'npm install -g X'
12:13:51 <Robly18> cruhl: cant you just do cabal install [name]?
12:14:24 <cruhl> I've done that, but ghc-mod refuses to work without the full path to the executable.
12:14:35 * hackagebot naver-translate 0.1.0.1 - Interface to Naver Translate  https://hackage.haskell.org/package/naver-translate-0.1.0.1 (hongminhee)
12:15:48 <Robly18> i dont know then, sorry.
12:16:45 <cruhl> Cabal says the installation succeeded, but this error occurs: "-bash: ghc-mod: command not found"
12:16:45 <cruhl> I suspect cabal doesn't install and add to path automatically like npm?
12:17:34 <jknecht> Hi all.  Noob question about rank n types, summarized here: http://lpaste.net/139128
12:17:52 <Robly18> cruhl: yeah id just add it to path manually
12:18:02 <cruhl> Well that's a bummer.
12:18:20 <cruhl> There must be a way, this seems like a very common issue.
12:19:55 <Robly18> jknecht: why do you have the forall shenanigans in the type declaration?
12:20:09 <jknecht> I want the function passed in to be polymorphic.
12:20:20 <jknecht> Since I plan to apply it to *tuples*, it would have to be
12:20:29 <Robly18> hmm. yeah that makes sense
12:20:31 <opqdonut> jknecht: yes, your guess about the problem is correct
12:20:56 <Robly18> have you tried removing the type declaration and checking the type in the console?
12:20:56 <opqdonut> jknecht: one solution would be to have c be a type family (i.e. type-level function)
12:21:17 <opqdonut> Robly18: that would just get (a -> a) -> (a,a) -> (a,a)
12:21:20 <jknecht> Can you explain a bit about the type family?  I'm pretty ignorant :\
12:21:54 <chpatrick> jknecht: the reason is that \x -> [ [ x ] ] has type a -> [] ([] a)
12:21:58 <opqdonut> jknecht: you can look it up on the haskell wiki or in the ghc manual, it's not a thingto explain shortly
12:22:10 <jknecht> Thanks.  I shall do so.
12:22:11 <chpatrick> and it has to be a -> c a
12:22:31 <jknecht> Thanks chpatrick -- that does make some sense.
12:22:49 <chpatrick> if you use Dbl then c ~ Dbl
12:22:52 <chpatrick> so it works out
12:23:20 <opqdonut> jknecht: mapT is a pretty contrived example, it's hard to come up with anything useful to map with
12:23:58 <jknecht> opqdonut -- indeed.  I was just trying to learn and understand.  This had no real application
12:24:46 <opqdonut> yeah I understand, I just mean you can't really get anywhere with it :) you might want to look at ST as a "real life" example of rank 2 types
12:25:17 <jknecht> I'm scared of "real life" examples... my dumb mapT already confused me @_@
12:25:24 <jknecht> But I will take a look : )
12:28:38 <cruhl> Is there a way to force cabal to install a package and add it to the path?
12:29:25 <elben> Are there resources out there that talk about how to build Haskell programs “in the large”? For example, I know how large OO programs are usually designed (AbstractFactoryWidgetBuilderBuilder, etc), but I haven’t had a lot of experience with very large functional programs.
12:29:30 <kadoban> cruhl: I forget how it works in cabal, because I never installed globally with it. You could switch to 'stack', then all you have to do is add ~/.local/bin/ to your PATH and install works great.
12:29:35 <jknecht> Thanks a lot for your help, guys.  Back to reading...
12:30:08 <dmj> elben: https://github.com/singpenguin/ppt/raw/master/Haskell%20in%20the%20Large.pdf
12:30:12 <chpatrick> elben: write your own haskell :D
12:30:22 <chpatrick> hire the smartest people and throw the whole thing out
12:30:55 <cruhl> kadoban++
12:31:12 <cruhl> Same thing in cabal really, just had a typo :(
12:31:42 <dmj> elben: transformers are usually a part of most big projects, so learning those would help
12:31:54 <elben> dmj: awesome, thanks for the slides
12:32:35 <elben> yes, I’ve learned/used transformers. quite necessary quite quickly
12:32:59 <dmj> elben: do you have a large project in mind you'd like to build?
12:36:06 <elben> dmj: no. but thinking about it, Haskell seems like a good project that has scaled “in the large”
12:37:07 <elben> And I just remembered this podcast with Don Stewart: http://www.haskellcast.com/episode/002-don-stewart-on-real-world-haskell/
12:41:29 <Robly18> hey uh, if anyone would like to give me a code review, i just baked up a maze generation algorithm at http://lpaste.net/139127
12:43:22 <osa1> does anyone know something with this type in base: Maybe a -> (a -> m ()) -> m () ?
12:43:30 <ReinH> osa1: did you try hoogle?
12:43:31 <osa1> (or a generalized version, of course)
12:43:32 <osa1> yes
12:43:50 <osa1> I was wondering if a generalized version of this available via a typeclass
12:43:57 <ReinH> Nothing in base afaik. Maybe something in monad-loops?
12:44:20 <ReinH> Although, isn't that just maybe?
12:44:22 <ReinH> :t maybe
12:44:23 <lambdabot> b -> (a -> b) -> Maybe a -> b
12:44:26 <chpatrick> :t traverse
12:44:27 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:44:28 <ReinH> where b is your m ()
12:44:31 <chpatrick> :t for_
12:44:32 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
12:44:36 <chpatrick> there you go
12:44:38 <osa1> oh wow awesome, monad-loops is something that I've been reinventing myself.
12:44:51 <osa1> hm
12:45:05 <ReinH> :t maybe (return ())
12:45:06 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
12:45:34 <chpatrick> from Data.Foldable
12:45:38 <ReinH> That'd work
12:46:01 <osa1> awesome, thanks
13:05:16 <gwo> I have a newbie question if anyone could help, i don't understand why I should be getting a parse error in the following line
13:05:23 <gwo> Prelude> removeNonUppercase st = [ c | c <- st, c 'elem' ['A'..'Z']]
13:05:23 <gwo> <interactive>:2:23: parse error on input '=' 
13:06:05 <kadoban> gwo: Don't define stuff in ghci. Write it in a file that you keep open, :load it in ghci and then :reload when you want to.
13:06:17 <kadoban> gwo: The parse error is because you need 'let' for stuff in ghci
13:06:32 <gwo> ahhh ok, that would make more sense. Cheers!
13:08:47 <gwo> hmm, still get the same error when trying to load that in from a file only now it also says there is a syntax error on 'elem'
13:09:02 <gwo> doh
13:09:12 <gwo> its the wrong ``
13:10:13 <kadoban> Ah yes
13:12:06 <nitrix> Is there a clever way to quote code here? I usually use backticks `` but that happens to also have a meaning in Haskell. 
13:12:44 <kadoban> I use ```blah``` sometimes in text, if that's what you mean? I think it's from markdown maybe
13:13:04 <dmj> lpaste is usually better for code
13:13:06 <dmj> @src foldr
13:13:07 <lambdabot> foldr f z []     = z
13:13:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:15:01 <nitrix> dmj: Just curious from the snippet right above, is that f applied to `x` and `(foldr f z xs)`, or f applied to x, then the result applied to the parenthese?
13:16:07 <phadej> nitrix: http://tonymorris.github.io/blog/posts/haskell-functions-take-one-argument/
13:16:41 <phadej> f x (foldr f z xs) === (f x) (((foldr f) z) xs)
13:16:43 <nitrix> phadej: I understand currying to some extend
13:17:03 <phadej> it's not currying (wrong term)
13:17:39 <nitrix> Okay, but then, here's the second question, doesn't that require (f x) to return a function?
13:17:47 <phadej> yes
13:17:56 <phadej> otherwise types wont match
13:18:14 <nitrix> > foldr add 0 [1..5]
13:18:15 <lambdabot>      Not in scope: ‘add’
13:18:16 <lambdabot>      Perhaps you meant one of these:
13:18:16 <lambdabot>        ‘and’ (imported from Data.Foldable), ‘odd’ (imported from Prelude)
13:18:31 <nitrix> > foldr (+) 0 [1..5]
13:18:33 <lambdabot>  15
13:18:43 <phadej> (+) is a function, which takes a Num, and returns another function which takes a Num and returns Num
13:18:53 <nitrix> phadej: So... (f x) becomes (+ 1) ?
13:18:58 <nitrix> Partial application?
13:19:05 <dmj> nitrix: yes, because the return type of foldr and f are the same. The list is being expanded into a chain of function applications that are forced once the base case hits.. which is [] 
13:19:28 <wouter_> This is ugly: fmap (fmap (+1)) (Just [1,2,3]). How would you do this in applicative style?
13:19:37 <nitrix> Interesting. Now it makes sense. It's so not intuitive when you aren't to it though.
13:19:48 <nitrix> ^ used
13:20:10 <dmj> nitrix: seeing it visually helped me, https://wiki.haskell.org/Foldr_Foldl_Foldl'
13:20:29 <nitrix> @pl fmap (fmap (+1)) (Just [1,2,3])
13:20:29 <lambdabot> fmap (fmap (1 +)) (Just [1, 2, 3])
13:21:11 <dmj> > liftM ((+1) <$>) (Just [1,2,3])
13:21:13 <lambdabot>  Just [2,3,4]
13:21:51 <phadej> > (fmap . fmap) (+1) (Just [1,2,3])
13:21:52 <lambdabot>  Just [2,3,4]
13:22:17 <dmj> > ((.) . (.)) (+1) (Just [1,2,3])
13:22:18 <lambdabot>      Couldn't match expected type ‘a -> a1 -> c’
13:22:18 <wouter_> ah nice
13:22:18 <lambdabot>                  with actual type ‘Maybe [Integer]’
13:22:18 <lambdabot>      Possible cause: ‘Just’ is applied to too many arguments
13:22:24 <nitrix> Oh wow, the fmap.fmap is actually clever.
13:22:50 <wouter_> yeah flatter is better.
13:23:11 <phadej> it's generalisable too:
13:23:26 <phadej> > (traverse . traverse) Right (Just [1, 3, 4])
13:23:28 <lambdabot>  Right (Just [1,3,4])
13:24:28 <nitrix> :t fmap . fmap
13:24:29 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
13:24:42 <Sindriav_> :t (.) (.)
13:24:43 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
13:24:54 <Sindriav_> :t (.) (.) $ (+)
13:24:55 <lambdabot> Num c => c -> (a -> c) -> a -> c
13:25:03 <serendependy> I'm guessing there's no way to generalize over the levels of nested-ness though. Especially for different functors
13:25:20 <Sindriav_> :t ((.) (.)) (+) 1 (negate)
13:25:21 <lambdabot> Num c => c -> c
13:25:34 <Sindriav_> > ((.) (.)) (+) 1 (negate) $ 5
13:25:36 <lambdabot>  -4
13:25:41 <Sindriav_> neat.
13:27:16 <phadej> serendependy: you can do some type jugling, but somehow you have to specify the level explicitly anyway
13:27:23 <phadej> most likely: not worth the trouble
13:28:08 <nitrix> Could someone explain how the renaming of a or b to a1 or b2 happens?
13:28:17 <nitrix> Some type signatures are really hard to read.
13:28:33 <the_2nd> is it more common to pre or postfix the type to a function name?
13:28:33 <Sindriav_> nitrix: They're just type variables
13:28:35 <serendependy> phadej, I'd like to see something like: (nested fmap 2) (+1) (Just [1,2,3])
13:28:37 <exio4> nitrix: the compiler just generates new variable names as it needs to
13:28:37 <the_2nd> moveThing
13:28:39 <the_2nd> thingMove
13:28:40 <wouter_> lenses do something like that don't they?
13:28:57 <Sindriav_> the_2nd: For what type?
13:29:06 <serendependy> But 1) the type of nested fmap would not be easy to write and 2) I think you hit the monomorphism restriction
13:29:09 <nitrix> Sindriav_: exio4: Do they follow a convention though? 1/2 from the 1st or 2nd types that they merged, or something like that?
13:29:12 <the_2nd> e.g. defining Point as x, y
13:29:17 <the_2nd> movePoint 
13:29:18 <nitrix> I'd really help to figure out cryptic error.
13:29:21 <the_2nd> or pointMove
13:29:27 <Sindriav_> the_2nd: I'd go with "move"
13:29:47 <nitrix> It'd*
13:29:53 <Sindriav_> the_2nd: Why would you prefix the type?
13:29:54 <phadej> serendependy: i'm pretty sure you can come close to (selfComposeN fmap (Proxy :: Proxy 2)) (+1) (Just [1, 2, 3])
13:29:56 <the_2nd> but move Point | move Other etc. exist
13:30:36 <Sindriav_> the_2nd: what Other?
13:30:47 <Sindriav_> the_2nd: Why do you have the same name for 2 types?
13:30:48 <the_2nd> e.g. Triangle
13:30:53 <exio4> nitrix: the compiler tries to make the new variables based on the "initial" ones (like a, f, b), but it doesn't really changes a lot  
13:30:54 <Sindriav_> the_2nd: Can they be abstracted over<
13:30:56 <Sindriav_> the_2nd?
13:31:10 <exio4> nitrix: what's the error message and which code are we talking about?
13:31:22 <the_2nd> Sindriav_, usually I would define an overload in other languages
13:31:31 <nitrix> exio4: Can you pick an easy example so I can try to work through it?
13:31:32 <the_2nd> dunno how to properly deal with that in haskell
13:31:49 <phadej> serendependy: that's something where I'd probably escape to template-haskell, to leave type-inference to compiler
13:31:59 <Sindriav_> the_2nd: So, XY problem. Ask for what you want, not how to do a half-solution you came up with :)
13:32:15 <Sindriav_> the_2nd: They probably share a common behavior, `move` that is.
13:32:38 <serendependy> phadej, personally I'd escape to Agda ;)
13:32:44 <the_2nd> I want to use the same function name for several containers / types
13:33:20 <Sindriav_> the_2nd: Yes. Then make a class like "Movable a", which has a function like " move :: a -> a "
13:33:27 <phadej> serendependy: it depends if you want to parse json you fetched from the internet in the same program too ;)
13:33:55 <Sindriav_> the_2nd: Sorry, "move :: Offset -> a -> a"
13:34:15 <kefh> very good video, must see: https://www.youtube.com/watch?v=df4KB30K0UU
13:34:17 <the_2nd> then implement the class in my types?
13:34:18 <Sindriav_> the_2nd: Where offset is a general enough representation of an offset in your code
13:34:35 <the_2nd> brb
13:34:48 <Sindriav_> the_2nd: instance, yes. For point = (x, y), move (dx, dy) (x, y) = (x + dy, y + dy)
13:35:09 <Sindriav_> the_2nd: For triangle, it would be something like "move center offset"
13:35:14 <Sindriav_> where center is a point, probably
13:35:20 <exio4> nitrix: the easiest way to get better type errors is to write down type signatures, by the way, and I am trying to write down some code that'd show some simple errors that I can think of
13:35:28 <Sindriav_> the_2nd: You can see how the composability comes in handy already!
13:35:41 <codedmart> bergmark: Are you around that I can ask you a question by chance?
13:35:47 <Zemyla> Why does Maybe not have specialized some and many instances that don't infinitely loop>
13:35:52 <Sindriav_> the_2nd: Triangle doesn't know how to move a point, it only knows how to move a triangle. Point knows how to move a point.
13:36:15 <Sindriav_> the_2nd: Should you choose to use 3D points instead, triangle will work out of the box, since you've separated the concerns
13:36:27 <Sindriav_> the_2nd: And only place that deals with moving points is the point instance of "move"
13:36:56 <Sindriav_> If you squint hard enough, it's like the love child of polymorphism and function overloading
13:37:05 <nitrix> exio4: One thing that I had recently, let me set... it was a Scotty error, I didn't match a `Html` type, but instead, it expanded it to `Markup` which is a `MarkupT ()` which is something else and I had this incomprehensible thing because the compiler was too verbose. But that's another subject. I want to understand the 1's and 2's before.
13:37:15 <Zemyla> The implementation is simple. some = fmap repeat; many = Just . maybe [] repeat
13:37:42 <Welkin> nitrix: that happens sometimes in yesod too
13:37:52 <Welkin> I learned to remember that markup is html
13:38:11 <Welkin> and the error is in the hamlet file
13:38:25 <nitrix> I just find it strange that GHC expands the type alias
13:38:42 <Welkin> maybe it has to do with template haskell
13:39:12 <Welkin> I often see [Char] in errors instead of String too though
13:39:45 <ttt_fff> (-) is BINARY minus. How do I get unary minus?
13:39:47 <ttt_fff> or just plain negation
13:39:55 <exio4> negate
13:39:57 <exio4> > negate 3
13:39:59 <lambdabot>  -3
13:40:06 <quchen> ttt_fff: (0-)
13:40:12 <exio4> that works too 
13:40:17 <wouter_> > (-1)
13:40:18 <lambdabot>  -1
13:40:27 <ttt_fff> exio4 , quchen: noted, thanks
13:40:32 <nitrix> Welkin: Well, I still have to remember once in a while that `f a` can be `[a]`. Sounds stupid, but in long types, it messes up with your head.
13:40:52 <nitrix> Welkin: But I'm really just a begineer so maybe it's a begineer thing.
13:41:23 <lpaste_> Exio4 pasted “type errors!” at http://lpaste.net/139136
13:41:45 <nitrix> exio4: /me checking
13:41:52 <exio4> I wrote down a file with some type errors that seem a bit nasty when looking down at the compiler output
13:43:02 <exio4> nitrix: after you fix the type errors, look at that file again, and check the type errors you get in the top-level functions
13:44:05 <nitrix> The monad implementation is bogus though.
13:44:14 <nitrix> No `x` in scope.
13:47:07 <nitrix> exio4: I see what you did. That sounds great :)
13:47:17 <chpatrick> how come there's no canonical storable vector <-> bytestring conversion function?
13:47:25 <chpatrick> everyone seems to have their own
13:47:47 <exio4> nitrix: it's basically lots of silly mistakes in a single file 
13:51:26 <Sindriav_> Would someone be so kind as to look over my code?
13:51:31 <Sindriav_> It's a pretty basic OpenGL boilerplate, but I'm already starting to get lost and feel like it's not very extensible…
13:51:35 <Sindriav_> https://github.com/sindriava/glfw
13:52:43 <nitrix> exio4: I already found one case that confuses me, but I'll ignore it and fix the type error still, then ask.
14:04:02 <dzhus> has anybody come across a problem with compiling X11 library on Mac OS X? http://dpaste.com/2NEA1NW
14:04:04 <osa1> hm, do we have something like tasty's withResource in hspec?
14:05:45 <osa1> my failing tests keep leaking resources...
14:06:27 <Zemyla> Hmm, how much do you think this would improve performance?
14:06:54 <Zemyla> :t \f t -> runContT (traverse (lift . f) t) return
14:06:55 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
14:07:39 <Zemyla> Over just plain mapM?
14:14:02 <nitrix> exio4: The monad instance is hard :(
14:15:01 <exio4> nitrix: heh, I normally throw away the code and start from scratch using typeholes at that time, normally, when that happens
14:15:08 <johnw> osa1: you can always just use resourcet or pipes-safe
14:15:16 <nitrix> exio4: (>>=) :: Magic a -> (a -> Magic b) -> Magic b
14:15:23 <johnw> osa1: run the test in a runSafeT block, and when it fails, it will clean up any resources
14:15:45 <nitrix> exio4: I thought I could just do:      (Magic x) >>= f  = f x    doesn't work.
14:15:52 <nitrix> Then I tried mapM and it gets even nastier.
14:16:14 <exio4> nitrix: (Magic x) >>= f = _ -- do this and look at the compiler's output
14:16:31 <nitrix> Magic a -> (a -> Magic b) -> Magic b ...... should just be fonction composition
14:16:49 <nitrix> exio4: Found hole.... what?
14:17:17 <nitrix> Oh wait, that's very nice ;o
14:17:21 <exio4> nitrix: it should return the types of things in the environment 
14:17:39 <exio4> nitrix: that'll give you some hints for knowing _what_ is wrong there, as an example, the type of "x" there 
14:18:07 <exio4> nitrix: I would ask you, what's the type of 'x' there?
14:18:15 <nitrix> exio4: Aw crap, I just figured what happened.
14:18:18 <glguy> ?tell dzhus You can build X11 on OS X by adding some extra cabal flags: --configure-opt=--x-includes=/opt/X11/include --configure-opt=--x-libraries=/opt/X11/lib --extra-include-dirs=/opt/X11/includes --extra-lib-dirs=/opt/X11/lib
14:18:19 <lambdabot> Consider it noted.
14:18:21 <nitrix> Magic a = Magic [a]
14:18:35 <nitrix> Soo....
14:18:51 <exio4> nitrix: I used the name for the constructor on purpose :P 
14:19:07 <exio4> the same name*
14:21:31 <nitrix> I'm almost there...   x >>= f, but the expected type is `Magic a`, mine's a `[a]`.
14:21:56 <nitrix> Which is super confusing, I hate you.
14:22:04 <exio4> nitrix: check the type of the constructor
14:22:12 <catgocat> I can't seem to find that function "while", it's not on system.io neither control.monad
14:22:41 <srhb> catgocat: do you mean whileM?
14:23:03 <srhb> catgocat: What's the type you're looking for?
14:23:08 <catgocat> I can't remember
14:23:16 <catgocat> it would execute an IO if something was met
14:23:19 <catgocat> I remember there was the unless too
14:23:43 <srhb> catgocat: unless and when are in Control.Monad
14:23:44 <catgocat> oh it's when
14:23:46 <catgocat> not while
14:23:46 <catgocat> sorry
14:23:47 <catgocat> hah
14:24:07 <nitrix> exio4: Oh god. You twisted mind. http://lpaste.net/139139
14:24:25 <srhb> nitrix: That's just recursive.
14:24:37 <srhb> nitrix: As in, endlessly.
14:24:40 <nitrix> Noooooooooo
14:24:52 <nitrix> srhb: No wait, is it?
14:25:04 <nitrix> Oh yeah, you're right.
14:25:33 <srhb> nitrix: Sorry ;P
14:25:43 <srhb> nitrix: This is where types don't save you, sadly.
14:26:11 <srhb> nitrix: But that's one of the... Two wrong solutions down
14:26:13 <srhb> (I think.)
14:26:43 <nitrix> Yeah, the other is using >>= on the list that's in the magic type, and then wrapping the result or something.
14:26:46 <nitrix> My brain's melting.
14:26:54 <srhb> No that sounds right.
14:27:18 <nitrix> Magic $ x >>= f   doesn't do it though.
14:27:35 <nitrix> But don't spoil, I feel like this is a stepping stone :/
14:27:38 <srhb> Sure :)
14:28:04 <srhb> (I think this would actually be easier to figure out without reusing the bind from list.)
14:28:13 <srhb> At least, if you know HOW it works.
14:38:28 <exio4> nitrix: I will try to give you a `small` hint, think you need to "wrap" and "unwrap" things there, what'd be the types of the unwrap and wrap functions?
14:39:34 <exio4> nitrix: (remember that "wrapping" and then "unwrapping" should give you the same value, same goes for doing it the other way) 
14:41:10 <nitrix> exio4: Mhm, I understood that, I might have to use the constructor at some point. I'm so close though.
14:41:26 <exio4> (looking at the suggestions from hlint, "use map" and "use foldr" are pretty funny, heh) 
14:41:46 <exio4> nitrix: the constructor would indeed be the "wrapping" function
14:41:51 <jura> hello, I have a question about monad transformers / the distributed-process package.
14:41:52 <exio4> nitrix: which type does it have? 
14:42:11 <nitrix> exio4: You can't ask an extra question atm, I'm using 100% of my brain.
14:42:51 <exio4> heh, sure
14:43:54 <nitrix> The thing that really annoys me, is that `Magic a` is a concrete type, so when the signature says  (>>=) :: Magic a -> (a -> Magic b) -> Magic b  ,  I assume the second argument is a function that takes an `a` which is .... according to the type, a list .. `[a]`
14:44:13 <nitrix> It's actually more clear when written down. Let me get back to it...
14:45:40 <exio4> nitrix: nope, it's not an ' [a] ', it's just an ' a '
14:45:42 <nitrix> exio4: Anyway, so yeah, so, the function  (a -> Magic b)  takes that `a`, which is a list of [a], and returns a Magic b, which is exactly what I'm supposed to yield.
14:46:01 <nitrix> So, in my head, I'm thinking, sweat, I can just write `f a`, and it doesn't work.
14:46:17 <nitrix> sweet*
14:47:33 <nitrix> exio4: The way I see it, is if Magic was defined as = Magic Int, then this would look like this;   Magic Int -> (Int -> Magic Int) -> Magic Int
14:47:46 <nitrix> exio4: So why can't I just do a simple function application?
14:48:22 <exio4> Magic Int would be "[Int]" when you pattern match on it
14:48:39 <Sindriav_> `a` can't be `[a]`, unless `a` is an infinite type
14:48:59 <nitrix> Sindriav_: You're missing context.
14:49:12 <nitrix> exio4: (Magic c) >>= f = _
14:49:25 <Sindriav_> > an `a` which is .... according to the type, a list .. `[a]`
14:49:27 <lambdabot>  <hint>:1:39: parse error on input ‘type’
14:49:29 <Sindriav_> derp
14:50:16 <exio4> nitrix: (Magic c) >>= f = ..., what's the type of 'c' there?
14:50:30 <nitrix> exio4: I'm pattern matching a `Magic something`, where the `something` is a type variable, that in our case, is defined to be a `[something]`.
14:50:58 <exio4> nitrix: indeed, what's type of f? looking at the type signature, that is
14:51:23 <nitrix> something -> Magic something
14:51:31 <Sindriav_> nitrix: Again, the type `something` shouldn't be defined as `[something]`
14:51:57 <exio4> nitrix: two different somethings ;)
14:52:17 <nitrix> I'm lost.
14:52:25 <Sindriav_> exio4: *two somethings that don't have to be equal
14:52:38 <nitrix> Let me backtrack a bit.
14:52:44 <exio4> so, (Magic (x :: [some1])) >>= (f :: some1 -> Magic some2)  
14:53:07 <nitrix> exio4: newtype Magic a = Magic [a]
14:53:15 <srhb> exio4: Yes.
14:53:19 <Sindriav_> nitrix: That' won't compile
14:53:25 <nitrix> Sindriav_: It does.
14:53:32 <Sindriav_> > newtype Magic a = Magic [a]
14:53:33 <lambdabot>  <hint>:1:1: parse error on input ‘newtype’
14:53:37 <Sindriav_> woop
14:53:56 <exio4> nitrix: you might want to change the name of the Magic constructor to "MkMagic" to make it clearer when we're talking about the type-level or the value-level
14:54:11 <nitrix> exio4: I will in a second, I was going to do that.
14:54:18 <nitrix> Although now I have an issue with Sindriav_.
14:54:24 <Sindriav_> Derp, I got newtype and type mixed up
14:54:26 <nitrix> Sindriav_: It compiles here.
14:54:39 <Sindriav_> nitrix: Why the aggressive tone? Simple mistake, they happen, chill out
14:55:20 <nitrix> Sindriav_: I think your ego is just making you interpret things innapropriately. There's no finger pointing or aggressive tone, merely a concern about extra noise.
14:55:53 <Sindriav_> nitrix: Whoa, ok. I'm not sure why i'm being attacked right now, so I'll just retract from the discussion.
14:56:24 <mniip> "your ego" is pretty aggressive tone
14:56:45 <Sindriav_> I'm sure it just came off differently than nitrix meant it, no biggie
14:57:30 <nitrix> Is it an error or not?  newtype Magic a = Magic [a] 
14:57:59 <exio4> it is not 
14:58:04 <nitrix> It looks perfectly fine to me and even type checks for me.
14:58:10 <catgocat> how do I find the last regexp match?
14:58:22 <Sindriav_> nitrix: It's not. `type Magic a = Magic [a]` would be, which is *why* I explained that I got it mixed up
14:58:34 <catgocat> "das123das123" =~ "\\d"
14:58:41 <catgocat> how to find last match???
14:58:44 <Sindriav_> catgocat: Are you sure you want to use regexp?
14:58:56 <catgocat> yes I'm sure
14:59:01 <exio4> catgocat: which library are you using?
14:59:03 <Sindriav_> catgocat: https://github.com/quchen/articles/blob/master/fbut.md#im-looking-for-a-good-regex-library
14:59:04 <catgocat> I am following a tutorial here
14:59:09 <catgocat> regex.posix
14:59:24 <nitrix> exio4: Alright. So, continuing, `Magic` is a type constructor, `Magic a` is concrete type, the second `Magic` is a value constructor, and `Magic [a]` is a value of type `Magic a`.
14:59:24 <catgocat> I know there's a way
14:59:27 <catgocat> but I forgot
15:00:15 <exio4> nitrix: yes, "Magic [1,2,3] :: Magic Int" 
15:00:24 <catgocat> please help?
15:00:28 <nitrix> exio4: When I'm doing the pattern matching, the pattern is based on the type or value?
15:00:29 <Sindriav_> catgocat: Let me clarify– do you want the index of the last match that occured, or match the last possible character?
15:00:52 <catgocat> I have a regex that may match different things
15:00:56 <catgocat> I want to match the last possible
15:01:01 <Sindriav_> I see
15:01:25 <Sindriav_> catgocat: This could be of use: http://stackoverflow.com/questions/8045122/regex-that-matches-the-last-occurrence-of-a-character
15:01:43 <nitrix> exio4: Let me rephrase that. Is the pattern `(Magic x)` matching for the `Magic` that's a type or value constructor?
15:01:57 <exio4> nitrix: pattern matching works with values
15:02:08 <nitrix> Yeah, sorry, I rephrased it.
15:02:18 <exio4> nitrix: that's why I suggested to use different names for both constructors, thus making this clearer 
15:02:20 <catgocat> no..
15:02:27 <Sindriav_> catgocat: Why not?
15:02:29 <catgocat> it's not at the end of the string
15:02:30 <exio4> you'd MkMagic x >>= f = in that case
15:02:32 <aupiff__1> If I have a `f :: a -> b` and `g :: c -> d -> e -> f -> a` and I want to nicely create `t :: c -> d -> e -> f -> b`, what can I do to create t = f `specialCompose` g
15:02:34 <catgocat> I want the last one
15:02:53 <nitrix> exio4: I like it this way, because it immediatly shows the points that I might assumed wrong. I think it's pattern matching that failed me.
15:03:43 <Sindriav_> catgocat: Read the link, it's there.
15:03:55 <exio4> nitrix: I put the same name there on purpose >:D 
15:04:00 <Sindriav_> catgocat: In summary, you want to greedy match anything that's not the pattern you're looking for
15:04:23 <nitrix> exio4: I know. So, okay, let's now use your MkMagic value constructor to simplifying the next questions.
15:04:50 <mniip> aupiff, (fmap . fmap . fmap . fmap) f g
15:04:55 <Sindriav_> aupiff__1: Basically, fmap . fmap . fmap . fmap
15:04:57 <nitrix> exio4: If I now use (MkMagic x) as a pattern, x is [a] ?
15:05:01 <Sindriav_> ninja'd
15:05:07 <exio4> nitrix: yes 
15:05:07 <aupiff__1> aha! thanks!
15:05:43 <mniip> :t fmap . fmap . fmap . fmap
15:05:44 <lambdabot> (Functor f, Functor f1, Functor f2, Functor f3) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
15:05:46 <Sindriav_> aupiff__1: It's because functions are functors, where fmapping is function composition :)
15:05:55 <nitrix> exio4: Great, so now, the type of (>>=) is   (>>=) :: Magic a -> (a -> Magic b) -> Magic b
15:06:01 <aupiff__1> yes that makes sense
15:06:17 <Sindriav_> aupiff__1: "a ->" is a functor, because it's a context for a `b` value
15:06:23 <exio4> nitrix: yup 
15:06:28 <nitrix> exio4: Meaning, the a's and b's there are all going to be lists, right?
15:07:02 <exio4> nitrix: those a's and b's are not going to be lists
15:07:06 <Sindriav_> aupiff__1: If you look on the type of fmap `(a -> b) -> f a -> f b`, and replace every `f` with `a ->`, it becomes more apparent how it works :)
15:07:22 <nitrix> exio4: Alright, this then, is where I'm blocking.
15:07:23 <mniip> Sindriav_, not a->
15:07:35 <mniip> Sindriav_, a is not free in the signature
15:07:36 <exio4> nitrix: Magic a means you have a list.. "inside" the datatype 
15:07:56 <Sindriav_> mniip: Derp, sorry, `r ->`, aupiff__1
15:07:57 <exio4> @let newtype Magic a = MkMagic [a] 
15:07:58 <lambdabot>  Defined.
15:08:07 <exio4> @type MkMagic ['a', 'b', 'c']
15:08:08 <lambdabot> Magic Char
15:08:12 <srhb> Or to put it differently, 'a' and 'b' are the types of the elements in the lists.
15:08:15 <srhb> Not lists themself.
15:08:43 <exio4> srhb's explanation is better
15:09:07 <nitrix> It's strange because I understand this perfectly just from reading the newtype declaration, but still, the type of (>>=) leads me to think differently.
15:09:36 <srhb> nitrix: perhaps it will help you if you write the pattern like so: MkMagic as ==> f = ...
15:09:39 <srhb> er
15:09:40 <srhb> >>=
15:09:56 <srhb> nitrix: So that it's clear you're pattern matching on the `as` (plural, like in xs)
15:10:37 <comprehension> is there an easy way to print escaped strings as they are written in code?
15:10:48 <srhb> comprehension: show it again?
15:10:50 <comprehension> well, not print, but just convert
15:11:01 <nitrix> srhb: In fact, his functor example used `MkMagic f` and `MkMagic xs` is a hint, and I didn't even hesitate the same way.
15:11:09 <nitrix> as a hint*
15:11:12 * srhb nods
15:11:18 <naudiz> after updating ghc I can't use stack anymore. I tried "stack setup" but it just results in this: /home/naudiz/.stack/programs/x86_64-linux/ghc-7.8.4/lib/ghc-7.8.4/bin/ghc-pkg: error while loading shared libraries: libtinfo.so.5: cannot open shared object file: No such file or directory
15:11:24 <comprehension> srhb: i mean i have a string like "\x1b hello" and i want the label on an hspec test to include that string
15:11:41 <comprehension> so that in the output of the test suite, i see "\x1b hello parses to..."
15:11:50 <srhb> > show "\x1b hello" -- ?
15:11:51 <lambdabot>  "\"\\ESC hello\""
15:11:56 <naudiz> equery b libtinfo.so shows no results.
15:11:58 <srhb> A bit much I guess :-)
15:12:01 <comprehension> rather than "\x1b" being passed on to the terminal
15:12:21 <comprehension> ah, well i suppose i don't need to then. i assumed the shell would get it and it would cause problems. thanks!
15:12:22 <Sindriav_> > show "\x2c hello"
15:12:23 <lambdabot>  "\", hello\""
15:12:41 <srhb> The extra Show is lambdabots fault.
15:13:09 <Sindriav_> srhb: yeah, I was trying if the "x2c" would stay as it is
15:13:11 <srhb> comprehension: Unfortunately, the Show instance for String will escape the quotes for you as well.
15:13:18 <naudiz> Does anyone have an idea why this happens?
15:13:37 <comprehension> srhb: eh, i can live with it
15:13:44 <Sindriav_> comprehension: Why did you want to do it again?
15:14:11 <naudiz> unfortunately wgetpaste doesn't seem to work at the moment
15:14:49 <geekosaur> naudiz, how did you update ghc, and what kind of system are you on?
15:14:50 <mniip> naudiz, doesn't equery b take absolute paths?
15:15:01 <phaazon> hey, I’d like to deprecate a package, any idea how I could do that?
15:15:20 <mniip> geekosaur, how many systems do you know that have an 'equery' program? :)
15:15:33 <naudiz> geekosaur: I'm using gentoo and updated it using portage
15:15:34 <geekosaur> none? 
15:15:54 <geekosaur> which is to say, I do not have awareness of every utility provided with every linux distribution
15:16:30 <mniip> naudiz, if I recall correctly
15:16:42 <mniip> libtinfo is from USE="tinfo" ncurses
15:16:51 <geekosaur> in any case one thing I'd be checking is whether ncurses got bumped somewhere in there --- am seeing pain in various places from ncurses 6
15:16:51 <naudiz> mniip: I thought equery b was there to search for a package that gives you a specific file? 
15:16:57 <Sindriav_> mniip: I *think* there were plans to port `portage` to OSX
15:17:14 <naudiz> mniip: I'll try that, thanks
15:18:41 <naudiz> mniip: yes, the flag was missing
15:19:12 <mniip> interestingly, I have ncurses built without tinfo
15:19:20 <geekosaur> Sindriav_, it's already there if you count something with almost no packages (per someone else who tried it and gave up because nobody was adding packages to it. several months ago, admittedly)
15:19:27 <mniip> and ghc works fine
15:19:48 <phaazon> ok I’ve found how to deprecate a package
15:20:03 <phaazon> I hope it’ll be tagged deprecated as well
15:20:04 <Sindriav_> geekosaur: Weell, I think since the port was meant to be finished sometime 10 years ego, I'd say that "few months ago" doesn't change much :D
15:20:11 <Sindriav_> geekosaur: Thanks for the validation, though!
15:20:25 <naudiz> mniip: same for me until now. might be an issue of stack
15:21:23 <nitrix> exio4: I'm getting into nasty concatMap stuff.
15:21:55 <exio4> nitrix: it's not that nasty, you're close there :)
15:22:03 <geekosaur> and, well, if any linux distribution were going to pull ncurses 6 in quickly, it'd be gentoo and/or arch...
15:22:08 <exio4> @type concatMap
15:22:09 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
15:22:14 <nitrix> Yeah, but I can't unwrap the type.
15:22:27 <exio4> @type (=<<) :: (a -> [b]) -> [a] -> [b]
15:22:28 <lambdabot> (a -> [b]) -> [a] -> [b]
15:22:45 <exio4> nitrix: that's where an helper function appears
15:23:33 <nitrix> The function that I'm giving concatMap yields a `Maybe a`. I was thinking to compose that with something else, but I have nothing else that unwraps it.
15:24:10 <exio4> er? Maybe a?
15:24:14 <exio4> where did it appear? 
15:24:24 <nitrix> Magic a, lol
15:24:39 <exio4> oh
15:24:52 <exio4> nitrix: indeed, you need to get back a function that matches that type, how could you do that?
15:25:24 <mniip> nitrix, are you writing a monad instance for a list monad wrapper?
15:25:31 <exio4> mniip: he is 
15:25:58 <nitrix> Mhm. I'm learning the hard way :X
15:26:19 <catgocat> Can anyone help me improve this: http://lpaste.net/139149
15:26:29 <mniip> Magic xs >>= f = Magic $ concatMap (\Magic x -> x) $ map f xs
15:26:32 <nitrix> exio4: Well, write now I just tried with a `unwrap (Magic xs) = xs` hack 
15:26:34 <exio4> mniip: I gave him a bunch of functions that don't typecheck / are wrong, and he had/has to fix them http://lpaste.net/139136
15:26:39 <nitrix> exio4: *right
15:27:01 <nitrix> (Magic xs) >>= f = concatMap (unwrap . f) xs
15:27:25 <srhb> That does not seem like a hack, insomuch as it is necessary. :)
15:27:45 <nitrix> Well, I think mniip spoon fed me.
15:27:47 <exio4> nitrix: it's exactly what you needed!
15:27:59 <nitrix> exio4: It gives an error though.
15:28:00 <exio4> and he did spoil the last bit of fun of it 
15:28:05 <srhb> And yeah, mniip did spoil it. :P
15:28:07 <exio4> nitrix: indeed, which type error? 
15:28:11 <mniip> /shrug
15:28:15 <nitrix> Magic $
15:28:17 <nitrix> There you go.
15:28:56 <nitrix> mniip: The lambda is cleaner though. Very nice.
15:29:12 <srhb> nitrix: You might want to replace concatMap with the list bind too, then.
15:29:22 <mniip> hmm, in return for spoonfeeding here's an excercise: instance MonadPlus Magic
15:29:25 <srhb> In keeping with the rest of what you did.
15:29:44 <nitrix> mniip: I don't even know what the MonadPlus class does.
15:30:24 <kadoban> nitrix: It's Alternative for Monad instead of Applicative, I believe
15:30:29 <mniip> it's monoidizes a monad
15:30:47 <mniip> it*
15:30:49 <naudiz> it installed libtinfo.6 ... stack wants libtinfo.5 ... fml
15:30:59 <exio4> well, it's uni time for me, good night \o
15:31:00 <nitrix> mniip: That's a new word for me.
15:31:23 <mniip> naudiz, don't you have the 5 slot in ncurses
15:31:31 <kadoban> nitrix: Do you know Monoid ?
15:31:58 <nitrix> No. Although, reading it, mplus and mzero reminds me of church numerals.
15:32:06 <nitrix> church encoding*
15:32:10 <mniip> nothing to do with church
15:32:41 <mniip> nitrix, a Monoid is a structure with an associative binary operation and a neutral element
15:32:41 <kadoban> A Monoid is an associative operator and an identity element. An example is the natural numbers, with (+) and 0
15:32:41 <naudiz> mniip: could you instead tell me how to remove a package installed by cabal? I'd like to build the experimental version of stack directly
15:32:52 <geekosaur> heh, I suspected it was the ncurses rev
15:33:00 <mniip> naudiz, uhhh
15:33:01 <nitrix> mniip: What's a neutral element?
15:33:06 <geekosaur> you'll have to rebuild stack against the new ncurses
15:33:22 <mniip> nitrix, f `mappend` mempty = f; mempty `mappend` f = f;
15:33:28 <naudiz> mniip: that's kind of what I expected.
15:33:34 <nitrix> mniip: You mean, sort of like a permanent foldl ?
15:33:34 <kadoban> Another example is the natural numbers with (*) and 1. Another is lists with (++) and []
15:33:53 <mniip> nitrix, huh?
15:34:07 <naudiz> geekosaur: I'll try the experimantal version as suggested on their homepage
15:34:25 <mniip> nitrix, think about integer numbers, + is an associative operation, right
15:34:35 <naudiz> geekosaur: I had preferred stack upgrade but it won't work
15:34:40 <nitrix> mniip: Yup.
15:34:42 <mniip> and 0 is the identity (neutral) element of +
15:34:49 <mniip> because x + 0 = 0 + x = x
15:34:51 <mniip> for any x
15:35:08 <nitrix> mniip: Correct. Hence why I was comparing to foldl,   foldl (+) 0 [1..5]
15:35:14 <geekosaur> naudiz, yes, if stack was not installed as an ebuild then the systm has no idea that it needs to hold onto tinfo.so.5 for stack to keep working
15:35:35 <mniip> nitrix, uh, that's a pretty weird comparison, but there is a function called mconcat
15:36:08 <mniip> nitrix, anyway, numbers from a monoid over addition, with 0 as identity element
15:36:16 <mniip> form*
15:36:19 <nitrix> mniip: mconcat being able to concatenate multiple of those and form longer expressions?
15:36:30 <geekosaur> nitrix, a monoid is something that can combine things and has an identity that you can combine with no effect
15:36:36 <mniip> no, mconcat = foldr mappend mempty
15:36:54 <nitrix> I see.
15:36:59 <geekosaur> folding benefits from monoidal structure, certainly, but monoids are not fundamentally folds
15:37:31 <mniip> nitrix, anyway, numbers also form a monoid over multiplication, with 1 as identity
15:37:34 <nitrix> geekosaur: Are the things restricted to associative binary operations like mniip said?
15:38:08 <geekosaur> yes
15:38:20 <nitrix> geekosaur: So a monoid probably has a (a -> b -> b) somewhere in the type?
15:38:24 * nitrix checks
15:38:29 <mniip> :t mappend
15:38:31 <lambdabot> Monoid a => a -> a -> a
15:38:37 <geekosaur> because otherwise you can't guarantee that the identity behaves as an identity regardless of which side it's on
15:39:09 <nitrix> I see. And what makes it a monoid is this, plus, a neutral number?
15:39:21 <geekosaur> it doesn;t have to be a number.
15:39:34 <geekosaur> (0,+) is a monoid, as is (1,*), as is ([],++)
15:39:38 <mniip> :t mempty
15:39:39 <lambdabot> Monoid a => a
15:39:40 <nitrix> So, Monoid [], would have [] as neutral?
15:39:54 <geekosaur> yes, [] is the identity and (++) is the combining operation
15:40:17 <mniip> likewise, (++) is associative, and x ++ [] = x = [] ++ x
15:40:22 <nitrix> Does it has an instance for Monoid Maybe too or a more generalized version for all Monads?
15:40:24 <geekosaur> monoids are very common and very simple --- so simple that people "know about" them but don't generally treat them as anything special
15:40:28 <nitrix> I'm starting to see where this is going.
15:40:39 <mniip> nitrix, Maybe has 3 monoid instances
15:40:52 <nitrix> (or maybe not)
15:40:59 <nitrix> Oh boy.
15:42:04 <nitrix> I can't find Monoid Maybe.
15:42:18 <mniip> all of them share the Nothing as neutral element, which gives mempty = Nothing; Nothing `mappend` x = x; x `mappend` Nothing = x
15:42:35 <mniip> "Just a `mappend` Just b" is interesting though
15:42:43 <kadoban> nitrix: You know how you can't have multiple different instances for the same type? The instances for Maybe are all on newtype wrappers, so you have to pick which meaning you want.
15:43:11 <Cale> nitrix: The instance is in Data.Monoid
15:43:15 <kadoban> nitrix: In the same way, Int isn't an instance of Monoid. Sum is though (it's a newtype wrapper)
15:43:29 <Cale> kadoban: Wait, what?
15:43:40 <Cale> Isn't there  instance Monoid a => Monoid (Maybe a) ?
15:43:47 <kadoban> Oh there is … shit sorry.
15:44:01 <mniip> > Just 1 `mappend` Just 2
15:44:02 <lambdabot>      No instance for (Show a0)
15:44:02 <lambdabot>        arising from a use of ‘show_M55367010499788932829853’
15:44:02 <lambdabot>      The type variable ‘a0’ is ambiguous
15:44:10 <kadoban> I thought it was like Sum and Product and there only were for wrappers.
15:44:20 <mniip> > Just "foo" `mappend` Just "bar"
15:44:22 <lambdabot>  Just "foobar"
15:44:44 <Cale> ^^ useful for fizzbuzz, lol
15:44:58 <mniip> barely
15:45:03 <nitrix> Oh, because the associative operation has to be part of it?
15:45:14 <nitrix> So each newtype has its own operation?
15:45:21 <nitrix> Or semantics, rather.
15:45:28 <Zemyla> How can something with existential types be written in Church encoding? Like Ap f b = Pure b | forall a. Ap (Ap f (a -> b)) (f a)?
15:45:34 <mniip> Cale, if only there was a function like '[] +++ y = y; x +++ y = x'
15:45:37 <kadoban> nitrix: Yeah, you have to specify the associative operator in the instance, otherwise it wouldn't have much meaning.
15:45:59 <Cale> mniip: Yeah, orElse :)
15:46:07 <mniip> :t orElse
15:46:08 <nitrix> > getFirst (Just 1) `mappend` (getLast Just 2)
15:46:08 <lambdabot> Not in scope: ‘orElse’
15:46:09 <lambdabot>      Couldn't match expected type ‘First a’
15:46:09 <lambdabot>                  with actual type ‘Maybe Integer’
15:46:09 <lambdabot>      In the first argument of ‘getFirst’, namely ‘(Just 1)’
15:46:21 <nitrix> Whoops
15:47:59 <nitrix> (getFirst $ Just 1) `mappend` (getFirst $ Just 2)
15:48:03 <nitrix> Shouldn't that work?
15:48:31 <nitrix> It's my last question today, I feel like I'm very draining and it's already a lot to grasp.
15:50:19 <nitrix> First has a Functor First instance, and Maybe has a Functor Maybe instance.
15:50:47 <nitrix> I should be able to getFirst Maybes :/
15:52:04 <comprehension> is it possible to iterate over datatype constructors?
15:52:06 <geekosaur> > First (Just 1) <> First (Just 2)
15:52:08 <lambdabot>  First {getFirst = Just 1}
15:52:19 <Sindriav_> How fucked up is using "unsafePerformIO" for debugging using print? :D
15:52:20 <geekosaur> getFirst gets the value *out*, First puts the value *in*
15:52:30 <johnw> Sindriav_: use trace
15:52:31 <geekosaur> Sindriav_, look at Debug.Trace
15:52:38 <comprehension> i thought that deriving Ord let you use a list comprehension over the constructors but i think i'm misremembering
15:52:40 <Sindriav_> Ooh, neat
15:52:43 <Sindriav_> :t trace
15:52:44 <lambdabot> Not in scope: ‘trace’
15:52:49 <Sindriav_> :t Debug.trace
15:52:50 <lambdabot> Not in scope: ‘Debug.trace’
15:52:53 <Sindriav_> gah
15:52:58 <Sindriav_> Thanks, anyways ^^
15:52:59 <geekosaur> Debug.Trace is the module
15:53:06 <Sindriav_> oh
15:53:07 <Eduard_Munteanu> comprehension, Enum and Bounded
15:53:08 <geekosaur> contains trace, traceShow, and I think a few other variants
15:53:14 <Sindriav_> :t Debug.Trace.trace
15:53:15 <lambdabot> String -> a -> a
15:53:20 <comprehension> Eduard_Munteanu: thanks
15:53:30 <Sindriav_> > Debug.Trace.trace "lol" 5
15:53:32 <lambdabot>  Not in scope: ‘Debug.Trace.trace’
15:53:36 <Eduard_Munteanu> comprehension, then you can do things like [minBound..maxBound] :: [YourThing]
15:53:37 <mniip> :t Debug.Trace.traceShowId
15:53:38 <lambdabot> Show a => a -> a
15:53:48 <Sindriav_> Thanks ^^
15:54:33 <kadoban> Yeah, traceShowId is great stuff, that one I use a lot.
15:56:28 <nitrix> What the point of wrapping it in First, if you immediatly getFirst. What are the use cases?
15:57:38 <kadoban> nitrix: It gives you a different Monoid instance
15:58:13 <geekosaur> you wrap values in First in order to combine them with mappend using the Monoid instance for First
15:58:19 <geekosaur> then unwrap with getFirst at the end
15:58:28 <geekosaur> similarly with Sum / getSum, etc.
15:58:52 <geekosaur> it's somewhat annoying, but there's otherwise no good way to pick a specific Monoid instance when several could apply
15:59:00 <geekosaur> at least, not in Haskell
15:59:15 <nitrix> And mappend lets you concatenate all of those because they have a Monoid instance, get it.
15:59:35 <mniip> geekosaur, yes there is
15:59:48 <mniip> reify/reflect:D
16:01:10 <nitrix> It seems like I can only mappend First with other Firsts though.
16:01:38 <Eduard_Munteanu> :t mappend
16:01:39 <lambdabot> Monoid a => a -> a -> a
16:01:59 <nitrix> OH, mappend is the associate operation!
16:02:08 <nitrix> Oh my god, everything just clicked.
16:02:17 <Zemyla> I wish there were a trace that was in the ST monad and sequenced with ST operations.
16:02:38 <mniip> Zemyla,  you can write one
16:02:41 <nitrix> associative*
16:03:04 <glguy> What about this one? traceM :: Monad m => String -> m () 
16:03:10 <mniip> {-# LANGUAGE MagicHash UnboxedTuples KitchenSink #-}
16:03:53 <mniip> import GHC.IO, GHC.ST, Acme.RealWorld
16:04:17 <catgocat> how to parse html tags?
16:04:35 <Eduard_Munteanu> catgocat, for what purpose?
16:04:48 <nitrix> mniip: Sindriav_ geekosaur Cale exio4, I really can't wait until my knowledge of Haskell deepens and I'm able to help others in return. Until then, you guys were very patient with me. Sorry for the horrible english, my brain was a 100% used in learning and not language processing. I appreciate guys. Have a good evening.
16:05:08 <Sindriav_> nitrix: It will come in time
16:05:18 <catgocat> Eduard_Munteanu I have an html page, I need to get a specific element
16:05:20 <Sindriav_> nitrix: I recommend Typeclassopedia by Brent Yorgey
16:05:28 <ttt_fff> the greatest performance increase is from not working to working; thus start out with exp time aglorithm instead of trying to do it in log log n
16:05:29 <catgocat> or the text in a specific element
16:05:52 <Eduard_Munteanu> catgocat, tagsoup should do
16:05:57 <Eduard_Munteanu> @hackage tagsoup
16:05:57 <lambdabot> http://hackage.haskell.org/package/tagsoup
16:05:58 <naudiz> does someone know of a vim plugin similar to wide conceals of vim2hs?
16:06:55 <ttt_fff> naudiz: haskell-vim-now
16:09:05 <naudiz> ttt_fff: I'm looking for something that allows me to customize conceals
16:09:16 <kyclark> How do I leave a "forever"?
16:09:20 <ttt_fff> naudiz: source code of haskell-vim-now
16:09:49 <Eduard_Munteanu> kyclark, by not using "forever" in the first place
16:10:23 <Eduard_Munteanu> kyclark, you can instead recurse explicitly
16:10:28 <kyclark> The way to catch a knuckleball is to wait until it stops rolling and then pick it up.  -- Bob Uecker
16:10:32 <glguy> That would depend on which Monad instance you were using forever with
16:10:41 <naudiz> ttt_fff: I can do the same for vim2hs but that's not a comfortable way of configuring
16:11:19 <kyclark> I have a list of open file handles, and I want to read from them until they all return EOF.  
16:11:48 <naudiz> also, haskell-vim-now comes with too much crap I don't want
16:11:51 <kyclark> I've been reading about using runEitherT or runMaybeT with forever, but I'm not getting it yet.
16:14:00 <ttt_fff> naudiz: heresy! haskell-vim-now is the greatest ever
16:14:31 <Eduard_Munteanu> kyclark, fix $ \loop -> unless (hIsEOF h) $ do { input <- hGet h; ...; loop }   ?
16:15:16 <Eduard_Munteanu> :t hIsEOF
16:15:17 <lambdabot> Not in scope: ‘hIsEOF’
16:15:25 <Eduard_Munteanu> @hoogle hIsEOF
16:15:26 <lambdabot> System.IO hIsEOF :: Handle -> IO Bool
16:15:26 <lambdabot> GHC.IO.Handle hIsEOF :: Handle -> IO Bool
16:15:30 <Eduard_Munteanu> Er.
16:15:33 <naudiz> ttt_fff: I prefer smaller plugins dedicated to specific tasks – a.k.a. the UNIX way
16:15:47 <kyclark> Thanks, Eduard.  I wrote an explicit recursion.  Seems to work.  Not as fancy.
16:16:05 <ttt_fff> naudiz: why are you using vim instead of 'ed' ?
16:16:51 <arahael> naudiz: Funny, how unixes  tend to have monolithic kernels. :)
16:16:58 <naudiz> ttt_fff: well... let's say I prefer the middle way :D
16:17:02 <Eduard_Munteanu> kyclark, well, you can always do something like (`runCont` id) $ \break -> forever $ { ...; when eof (break ()); ... }
16:17:11 <Eduard_Munteanu> *runContT
16:17:39 <naudiz> arahael: and that monolithic kernel is managed with git... I know, that irony
16:17:48 <arahael> naudiz: Only in linux.
16:17:56 <Eduard_Munteanu> > (`runContT` id) $ \never -> forever (never ())
16:17:57 <lambdabot>      Couldn't match expected type ‘(() -> m0 a0) -> m0 b0’
16:17:57 <lambdabot>                  with actual type ‘ContT r m (m r)’
16:17:57 <lambdabot>      The lambda expression ‘\ never -> forever (never ())’
16:19:20 <naudiz> arahael: BSD doesn't count. But you're right, GNU/HURD shall rise.
16:19:56 <Sindriav_> GNU/HURD when someone starts working on it
16:20:01 <Sindriav_> *shall rise
16:20:18 <arahael> naudiz: There's quite a few other unixes around, though arguably they're dead/dying.
16:20:29 <Eduard_Munteanu> Forgot a callCC.
16:21:24 <Sindriav_> arahael: I'm under the impression that the plural of "unix" is "unices"
16:22:26 <Welkin> isn't unix an acronym?
16:22:38 <Welkin> hm
16:22:45 <Sindriav_> Welkin: As I'm reading now, it's not
16:22:51 <Sindriav_> Neither is it a noun.
16:22:52 <Welkin> h yeah
16:22:56 <Welkin> a pun on multics
16:22:58 <Welkin> hahaha
16:23:17 <Sindriav_> It's instead an "adjective", that can be used to describe some products of Bell Laboratories, legally
16:23:22 <naudiz> arahael: actually they aren't unix, but unix-based
16:23:37 <arahael> naudiz: Lies!
16:23:57 <Welkin> in two links I was lead from Unix to Imperial Harem: https://en.wikipedia.org/wiki/Imperial_Harem
16:24:00 <Sindriav_> So the proper way is "UNIX system" and "UNIX systems", but "unices" seems to be widespread enough
16:24:07 <arahael> naudiz: (On that note, I'm really abruptly stopping the conversationa s it's offtopic - and I need to get to work)
16:24:20 <Sindriav_> arahael: Good point.
16:24:37 <Welkin> yeah, everything "*nix" is just derived from unix
16:24:39 <Welkin> not actually unix
16:24:48 <Welkin> although, people seem to use unix loosely
16:29:28 <naudiz> I just decided to edit vim2hs... 
16:29:51 * hackagebot intricacy 0.5.7.1 - A game of competitive puzzle-design  https://hackage.haskell.org/package/intricacy-0.5.7.1 (mbays)
16:30:43 <geekosaur> actually these days Unix is anything that passes the certification test from The Open Group (formerly X/Open)
16:31:12 <geekosaur> this used to include several Linux distributions, but as they change and certification is expensive, I'm pretty sure they've lapsed
16:34:38 <naudiz> I'm sorry I started this UNIX discussion...
16:44:42 <catgocat> it's awful to parse html with haskell
16:44:54 <catgocat> tagsoup is too small
16:44:59 <catgocat> isn't there anything more powerful
16:45:16 <Welkin> write your own with parsec
16:45:18 <Welkin> or use pandoc
16:45:30 <johnw> catgocat: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/tagsoup
16:45:43 <johnw> html-conduit
16:45:53 * arahael loves it that nobody has mentioned regexps.
16:46:02 <johnw> also: http://stackoverflow.com/questions/4838138/web-scraping-with-haskell
16:46:09 <johnw> regexps are just a special case in Haskell world
16:46:24 <arahael> johnw: I mean, for parsing html.
16:46:27 <johnw> it's Yet Another DSL for writing simple parsers
16:46:31 <johnw> and we have better DSLs
16:46:45 <Welkin> why would you use regex?
16:46:49 <Welkin> we have parsec
16:46:51 <pacak> Don't parse html with regex.
16:47:13 <johnw> granted, regexps are handy for: fileName =~ "foo.*\.(c|h)"
16:48:23 <Eduard_Munteanu> catgocat, too small in what way? For what purpose? Are you doing something more complex?
16:48:39 <geekosaur> the problem with parsing html is that people tend to assume it is rational
16:48:40 <catgocat> I think I need to use Text.XML.Cursor
16:48:47 <catgocat> and html-conduit
16:48:55 <catgocat> I want to select a text between a span tag that has id="stuff"
16:48:59 <arahael> geekosaur: People tend to assume that it's xml, or should be xml.
16:49:01 <catgocat> using tagsoup only is a pain in the ass
16:49:02 <geekosaur> tagsoup can handle not-rational. most things don't (notably, XML is more rational than HTML)
16:49:37 <kadoban> Don't parse HTML yourself. Even if everyone involved follows the standards to the letter, it's still a pain in the ass. And /nobody/ follows the standards.
16:49:38 <Eduard_Munteanu> catgocat, have you seen Text.HTML.TagSoup.Tree?
16:50:15 <Welkin> geekosaur: you mean some tags have an open and close variation, some only have an open, and optionaly a combined open/close (i.e. <br> or <br />)
16:50:32 <geekosaur> Welkin: html in the wild has things like misordered close tags
16:50:42 <Welkin> ah
16:50:45 <Welkin> so logical errors
16:50:49 <geekosaur> yep
16:51:11 <hpc> or lack of, or multiple body tags, or divs inside <a>, or 64 nested <strong> tags
16:51:15 <Eduard_Munteanu> catgocat, but html-conduit/xml-conduit are good too
16:51:30 <arahael> People even assume that all tags must be closed!<br />
16:51:31 <catgocat> Eduard_Munteanu, I still think it's too low level in my case
16:51:32 <geekosaur> ^ yes, this. very much this
16:51:36 <hpc> also missing doctypes, using xml in an html doctype
16:51:43 <hpc> using html in an xml doctype
16:51:46 <geekosaur> html generators are by far the worst offenders; they almost all produce utter garbage
16:51:54 <hpc> (which you can at least be a bit more justified in being an ass about)
16:52:02 <arahael> geekosaur: They're more likely to generate valid htlm5, at least, now.
16:52:08 <geekosaur> (and xhtml which was supposed to impose proper structure, is just as garbage in reality) 
16:52:10 <hpc> (because xml is much stricter)
16:52:20 <kadoban> Ehh, html generators are probably not the worst. They tend to at least product technically close to valid HTML. People on the other hand …
16:52:21 <Welkin> lol
16:52:24 <Welkin> what can replace html?
16:52:33 <hpc> javascript
16:52:35 <kadoban> Nothing, we're stuck with it.
16:52:44 <Welkin> this is why all the html DSLs in haskell omit the close tag
16:52:48 <Eduard_Munteanu> catgocat, well, there's HXT which can do XPath queries, if you fancy that.
16:52:51 <Welkin> blaze/hamlet/etc.
16:53:01 <hpc> Welkin: javascript has already replaced html
16:53:12 <hpc> just go to any web designer's personal site
16:53:26 <Welkin> I hate "web designers"
16:53:35 <sgwizdak> scraping javascript sites is an interesting exercise
16:53:47 <Welkin> well, at least I hate their work
16:54:36 <arahael> sgwizdak: Trivial, infact. ;) Depending on the purpose.
16:54:48 <kadoban> sgwizdak: It's mostly an exercise in tedium. You essentially have to emulate a browser, or at least a javascript engine.
16:54:59 <pacak> hpc: If it's not working with noscript it's not a web site, it's a web application and I tend to ignore those unless there's a reason.
16:55:02 <Welkin> it reminds me of "What Any giveth, Bill taketh away"
16:55:06 <Welkin> Andy*
16:55:07 <arahael> kadoban: That's the silly way to do it. The smart way is to pipe it though links.
16:55:27 <arahael> kadoban: Or wkhtmltopdf.
16:55:32 <Welkin> in this case, it is "web designers" in place of Bil;
16:55:40 <sgwizdak> kadoban: yeah, best I've found is to use phantomjs, which is built on v8, and even then, the performance is pretty nasty for anything high throughput
16:55:56 <hpc> pacak: heh, if it uses POST it's a web application
16:56:03 <kadoban> arahael: Can links even give you a tree or something? And … how is PDF going to help? PDF is its own mess …
16:56:21 <hpc> and if it doesn't work with js disabled, it's broken
16:56:56 <R0b0t1> python requests module is very good; but what hpc said
16:57:10 <Eduard_Munteanu> Pretty annoying the web is the only secure sandbox we've got so far.
16:57:15 <R0b0t1> and if it DOES only work with js enabled, you can often look at the js to see where it requests the data from, and scrape it more directly
16:57:19 <pacak> hpc: I've seen "cms" that operated only with GETs, but that's offtopic.
16:57:27 <hpc> Eduard_Munteanu: it's hardly secure
16:57:28 <R0b0t1> as that's what those kind of webpage is generally doing
16:57:44 <arahael> kadoban: links has a decent html -> text interface.  I guess it depends on what you want.
16:57:56 * R0b0t1 encases Eduard_Munteanu's feet in cement and lobs him in the nearest body of water
16:57:57 <Eduard_Munteanu> hpc, well, it's workable... Java and everything else don't seem that good at it.
16:58:03 <hpc> Eduard_Munteanu: ignoring the fact that chrome's sandbox gets busted over and over, people put their data inside the sandbox
16:58:07 <arahael> kadoban: And yes, PDF is it's own mess, but it depends on what you like.
16:58:15 <hpc> there's no point in trying to get to the OS when everything you want is in a cookie
16:58:21 <hpc> just XSS and be done with it
16:58:54 <R0b0t1> Eduard_Munteanu: Operating systems rather recently got secure enough to be worth considering secure, and here we have web browsers completely reinventing them (chrome user logins? lol.) with all of the pitfalls that previously happened reoccuring...
16:58:56 <arahael> kadoban: One site used javascript to generate a chart...  Visible only after 2 seconds.  wkhtml2pdf let me get that graph.
16:59:30 <arahael> R0b0t1: What I find hilarious, are programming languages re-inventing the concept of shared libraries. (Especially .NET)
16:59:49 <pacak> Btw, how efficient code generated by ghcjs those days?
16:59:54 <R0b0t1> arahael: it's even better when they use js to render the font, because the designer thinks that every user ought to be forced to use their chosen font :^)
16:59:56 <R0b0t1> and haha
17:00:07 <arahael> R0b0t1: That's why they're the designer.;)
17:00:46 <Eduard_Munteanu> Yeah, it's pretty sad.
17:01:56 <Welkin> or those error pages for a *website* that read "Javascript required for this page to load"
17:08:41 <kadoban> arahael: Yeah I guess sometimes it could be useful.
17:22:48 <refried_> sorry for the cross-post:
17:23:37 <refried_> Someone asked me today, apart from speed and space considerations, is there any advantage to tail-recursive implementations as compared to ones that aren't tail-recursive?
17:23:56 <refried_> and I think the answer is approximately no, but I wondered if anyone wanted to chat about it
17:24:07 <sebleblanc> Is there a way to write the string join function in pointfree-form? https://hackage.haskell.org/package/MissingH-1.0.0/docs/src/Data-List-Utils.html#join
17:24:26 <sebleblanc> (I am new to functional programming)
17:25:40 <hpc> :t intercalate
17:25:41 <lambdabot> [a] -> [[a]] -> [a]
17:25:58 <pacak> @pl \ delim l -> concat (intersperse delim l) 
17:25:58 <lambdabot> (join .) . intersperse
17:26:34 <pacak> sebleblanc: But you don't really want to do that.
17:26:49 <sebleblanc> pacak, for curiosity's sake :-)
17:29:01 <sebleblanc> pacak, where did the lambdabot's "join" come from
17:29:04 <sebleblanc> ?
17:29:43 <hpc> @hoogle join
17:29:44 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
17:29:44 <lambdabot> package join
17:29:44 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
17:29:46 <pacak> list  monad
17:29:53 <arkeet> join = concat
17:30:00 <arkeet> @pl concat
17:30:00 <lambdabot> join
17:30:06 <arkeet> silly lambdabot.
17:30:18 <pacak> arkeet: It's two bytes shorter!
17:30:29 <arkeet> but it's equally pointless!
17:30:52 <hpc> or perhaps it's pointlessly equal
17:30:57 <Welkin> but join is not concat!
17:31:03 <Welkin> oh
17:31:12 <Welkin> concat is more specialized than join
17:31:39 <pacak> > join ["foo", "bar"]
17:31:41 <lambdabot>  "foobar"
17:32:28 <mniip> hmm
17:32:35 <mniip> I should write a SK-reducer
17:32:36 <Welkin> :t mconcat
17:32:37 <lambdabot> Monoid a => [a] -> a
17:32:46 <Welkin> :t concat
17:32:48 <lambdabot> Foldable t => t [a] -> [a]
17:32:49 <Welkin> :t join
17:32:50 <lambdabot> Monad m => m (m a) -> m a
17:33:00 <pacak> mconcat is different.
17:33:01 <arkeet> :t fold
17:33:02 <lambdabot> (Foldable t, Monoid m) => t m -> m
17:33:04 <Welkin> yeah :P
17:33:07 <Welkin> I just remembered
17:33:22 <arkeet> it is?
17:33:27 <arkeet> > mconcat ["foo", "bar"]
17:33:29 <lambdabot>  "foobar"
17:34:04 <pacak> mconcat [Sum 1, Sum 2]
17:34:07 <pacak> > mconcat [Sum 1, Sum 2]
17:34:08 <lambdabot>  Sum {getSum = 3}
17:34:27 <arkeet> I mean as a function [[a]] -> [a] it's the same.
17:34:57 <Welkin> > join [Sum 1, Sum 2]
17:34:58 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘Sum Integer’
17:34:58 <lambdabot>      In the expression: Sum 1
17:34:58 <lambdabot>      In the first argument of ‘join’, namely ‘[Sum 1, Sum 2]’    Couldn't mat...
17:35:09 <arkeet> :t [concat, mconcat, join, fold]
17:35:10 <lambdabot> [[[a]] -> [a]]
17:39:55 * hackagebot generic-accessors 0.4.2.0 - stringly-named getters for generic data  https://hackage.haskell.org/package/generic-accessors-0.4.2.0 (GregHorn)
18:17:40 <ttt_fff> is there a butilin for a -> [Maybe a] -> a, which says "return me first "Just a" from lst, or the default value if everything is a maybe"
18:17:55 <ttt_fff> [aside, was just in #hakell, and was like, wtf, why do I have ops]
18:18:54 <mauris_> @pl \a bs -> fromMaybe a (msum bs)
18:18:54 <lambdabot> (. msum) . fromMaybe
18:20:04 <ttt_fff> :t msum
18:20:05 <lambdabot> (Foldable t, MonadPlus m) => t (m a) -> m a
18:20:12 <ttt_fff> > msum [Just 1, Nothing, Just 2]
18:20:13 <lambdabot>  Just 1
18:20:18 <ttt_fff> @src msum
18:20:18 <lambdabot> msum = foldr mplus mzero
18:20:27 <mauris_> > fromMaybe 'f' (msum [Nothing, Just 'g', Just 'h'])
18:20:28 <lambdabot>  'g'
18:20:30 <ttt_fff> > mplus :: Maybe
18:20:32 <lambdabot>      Expecting one more argument to ‘Maybe’
18:20:32 <lambdabot>      Expected a type, but ‘Maybe’ has kind ‘* -> *’
18:20:32 <lambdabot>      In an expression type signature: Maybe
18:20:32 <mauris_> > fromMaybe 'f' (msum [Nothing])
18:20:33 <lambdabot>  'f'
18:20:37 <ttt_fff> > mzero :: Maybe
18:20:38 <lambdabot>      Expecting one more argument to ‘Maybe’
18:20:38 <lambdabot>      Expected a type, but ‘Maybe’ has kind ‘* -> *’
18:20:38 <lambdabot>      In an expression type signature: Maybe
18:20:46 <ttt_fff> > mzero :: Maybe a
18:20:47 <lambdabot>  Nothing
18:20:56 <ttt_fff> okay, I think I get how this works
18:20:58 <ttt_fff> mauris++
18:21:36 <mauris_> (Just x) `mplus` _ = Just x; Nothing `mplus` y = y
18:21:40 <mauris_> mzero = Nothing
18:26:57 <ttt_fff> is there something like <$>, but with the arg orders flipped ?
18:27:03 <ttt_fff> :t (<&>)
18:27:04 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:27:10 <ttt_fff> :t (<$>)
18:27:11 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:27:16 <ttt_fff> :t (&)
18:27:17 <lambdabot> a -> (a -> b) -> b
18:27:33 <Bruuuuuuno> flip fmap?
18:28:28 <ttt_fff> why can't fi dint (<&>) on hoogle? https://www.haskell.org/hoogle/?hoogle=%28%3C%26%3E%29
18:28:34 <ttt_fff> *why can't I find*
18:28:53 <ttt_fff> @src <&>
18:28:53 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
18:28:57 <ttt_fff> @src (<&>)
18:28:57 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:29:27 <pacak> ttt_fff: use hayoo?
18:29:58 * hackagebot iso8601-time 0.1.4 - Convert to/from the ISO 8601 time format  https://hackage.haskell.org/package/iso8601-time-0.1.4 (NiklasHambuechen)
18:30:16 <ttt_fff> oh, ti's from lens
18:30:57 <ttt_fff> d@mn, my code is so much cleaner, <&> is brilliant, compared to <$>
18:31:02 <ttt_fff> data flows in the correct direction
18:32:42 <dramforever> :t (<&>)
18:32:43 <lambdabot> Functor f => f a -> (a -> b) -> f b
18:47:53 <Zer000> guys I can't get this to compile! http://lpaste.net/139168 what's wrong with my guards?
18:48:32 <Bruuuuuuno> use | before otherwise
18:48:38 <Zer000> oh :(
18:48:55 <pacak> Zer000: otherwise is the same as True btw.
18:48:57 <Zer000> thank you! I spent way too much time on that
18:49:20 <Zer000> isn't it false?
18:49:27 <Bruuuuuuno> and just to tell you, you can change "BS.null b == True" to "BS.null b"
18:49:37 <Bruuuuuuno> what do you mean?
18:49:43 <Zer000> are you saying the second equation will never run?
18:49:49 <pacak> Zer000: Nope. It needs to match.
18:50:00 <pacak> But otherwise is more readable
18:50:23 <Zer000> sorry, i must be tired, I don't understand what you mean
18:50:38 <mniip> jle`, ski
18:50:46 <Zer000> so "otherwise" isn't like "else" in other languages?
18:50:49 <mniip> I accidentally invented small step semantics for SK-calculus translation
18:51:03 <pacak> Zer000: similar.
18:51:24 <Zer000> then why won't my statement run?
18:51:24 <geekosaur> Zer000, a guard is a boolean value, it matches if it's true. So a final otherwise (== True) is the catch-all
18:52:09 <geekosaur> (likewise the "== True" on the previous line does nothing...)
18:52:19 <dmj> Zer000: otherwise is the same thing as True
18:52:31 <dmj> @src otherwise
18:52:32 <lambdabot> otherwise = True
18:52:33 <jle`> mniip: i'm down for skiing
18:52:42 <mniip> throw examples at me
18:52:47 <Zer000> ok I think I get it
18:53:14 <geekosaur> other than that, not sure what you are expecting; seems to look okay to me but I have no idea what to do with this function
18:53:23 <arkeet> > ((True == True) == True) == True
18:53:24 <lambdabot>  True
18:53:27 <gwo> out of curiousity, do you find any users of Haduaks - Euterpea hanging out in this room? Can't see any social other social groups online
18:53:39 <jle`> (== True) == (True ==) == id
18:53:57 <dramforever> @check (\x -> x == True == x
18:53:57 <lambdabot>  <unknown>.hs: 1: 22:Parse error: EOF
18:53:58 <jle`> hey, is the Eq instance for Bool lazy?
18:53:59 <dramforever> @check (\x -> x == True == x)
18:53:59 <lambdabot>  : -1: -1:Ambiguous infix expression
18:54:07 <dramforever> @check (\x -> (x == True) == x)
18:54:08 <arkeet> why would it be lazy
18:54:08 <lambdabot>  +++ OK, passed 100 tests.
18:54:09 <arkeet> how
18:54:18 <mauris_> > True == undefined
18:54:19 <lambdabot>  *Exception: Prelude.undefined
18:54:28 <mauris_> looks like no
18:54:34 <jle`> ah yeah, i didn't think that through, heh
18:54:36 <dramforever> how is it even possible
18:54:42 <exio4> jle`: how would it be lazy? 
18:54:49 <jle`> i did not think this through :)
18:54:54 <arkeet> > True || undefined -- maybe you were thinking more like this
18:54:56 <lambdabot>  True
18:55:22 <jle`> mhm
18:55:34 <jle`> mniip: \x y z a -> x a y z
18:56:29 <dramforever> @pl \x y z a -> x a y z
18:56:29 <lambdabot> (flip .) . flip
18:56:34 <mniip> S (S (K S) (S (K (S (K S))) (S (K (S (K K))) (S (K (S (K S))) (S (S (K S) (S (K K) S)) (K K)))))) (K (K K))
18:56:35 <dramforever> uh oh
18:57:04 <kazagistar> Well SKIed
18:57:13 <mniip> http://i.imgur.com/q6yRvGB.png
18:57:44 <jle`> sk game too strong
18:58:17 <dramforever> :t ap (ap (const ap) (ap (const (ap (const ap))) (ap (const (ap (const const))) (ap (const (ap (const ap))) (ap (ap (const ap) (ap (const const) ap)) (const const)))))) (const (const const))
18:58:19 <lambdabot> (b3 -> b -> b1 -> b2) -> b -> b1 -> b3 -> b2
18:58:25 <dramforever> :t \x y z a -> x a y z
18:58:26 <lambdabot> (r1 -> r2 -> r3 -> r) -> r2 -> r3 -> r1 -> r
18:58:30 <rcyr> What is that SK thing?
18:58:33 <dramforever> verified
18:58:45 <arkeet> rcyr: s a b c = a c (b c), k a b = a
18:58:49 <rcyr> (My maths are weak)
18:58:58 <jle`> rcyr: s = ap, k = const, so it's implementing \x y z a -> x a y z in terms of just ap and const
18:59:01 <dramforever> rcyr: you could rewrite any LC term in just applications of ap and const
18:59:06 <mniip> rcyr, are you familiar with untyped lambda calculus
18:59:22 <rcyr> mniip: Just a little bit, didn't see anything with S and K yet 
18:59:39 <dramforever> S = \a b c -> (a c) (b c)
18:59:40 <mniip> rcyr, S = \f g x -> f x (g x); K = \x y -> x
18:59:43 <dramforever> K = \a b -> a
18:59:48 <mniip> the trick is
18:59:50 <arkeet> @let ss a b c = (a c) (b c); kk a b = a
18:59:51 <lambdabot>  Defined.
18:59:57 <jle`> mniip: ah i see the strategy.  you just shuffle things around until you get the last point at the very end, and then eta reduce
18:59:57 <mniip> any untyped LC term can be defined using just S and K
19:00:01 <arkeet> :t ss kk kk
19:00:03 <lambdabot> t1 -> t1
19:00:11 <arkeet> jle`: yup
19:00:13 <mniip> jle`, that's for single occurences
19:00:24 <rcyr> mniip: Ha, if I want to educate myself on the subject, how is that called?
19:00:24 <arkeet> well
19:00:30 <dramforever> this translation is straightforward once you get it
19:00:30 <mniip> rcyr, SKI calculus
19:00:38 <jle`> mniip: okay then do \x y z -> z y y x
19:00:39 <rcyr> Thank you :)
19:00:41 <dramforever> *understand it
19:00:52 <dramforever> mniip: isn't it
19:01:03 <jle`> or how about \x y z -> y z y x
19:01:09 <jle`> i meant y (z y) x
19:01:16 <jle`> is that even possible >_>
19:01:23 <dramforever> sure it is
19:01:25 <jle`> yay
19:01:26 <jle`> math
19:01:28 <jle`> math++
19:01:30 <lpaste_> mniip pasted “\x y z -> z y y x” at http://lpaste.net/139169
19:02:06 <dramforever> now it starts to seem that the Y combinator is very simple in SKI CL
19:02:06 <jle`> i guess you have to de-duplicate the y then
19:02:44 <dramforever> jle`: what about this: I'll show you the translation algorithm
19:03:07 <dramforever> https://en.wikipedia.org/wiki/Combinatory_logic#Completeness_of_the_S-K_basis
19:03:18 <mniip> dramforever, that's not the algorithm I'm using though
19:03:24 <mniip> I tend to believe mine is more efficient
19:03:25 <dramforever> oh
19:03:36 <dramforever> s/the/a/
19:03:46 <jle`> such complete
19:04:26 <lpaste_> mniip pasted “SK” at http://lpaste.net/139170
19:04:40 <dramforever> mniip: looks like your algorithm just moves things to the ...wait didn't someone just say th...wait you just posted the algorithm
19:05:07 <jle`> submit to lambdabot :D
19:05:09 <dramforever> uh...kinda hard to understand
19:05:10 <dramforever> will try though
19:05:15 <dramforever> @undefine
19:05:15 <lambdabot> Undefined.
19:05:17 <jle`> anyways, ty, got to go
19:05:30 <dramforever> wait lambdabot can't possibly accept Debug.Trace
19:05:38 <dramforever> @letlpaste 139170
19:05:39 <lambdabot>  .L.hs:123:1:
19:05:40 <lambdabot>      Debug.Trace: Can't be safely imported!
19:05:40 <lambdabot>      The module itself isn't safe.
19:05:43 <dramforever> I was right
19:05:54 <mniip> you can replace those bits with "error" probably
19:06:19 <mniip> those are just stubs because I'm not entirely sure about completeness
19:06:28 <dramforever> =)
19:07:28 <lpaste_> mniip revised “SK”: “No title” at http://lpaste.net/139170
19:07:36 <mniip> @letlpaste 139170
19:07:37 <lambdabot>  Defined.
19:07:48 <dramforever> mniip: I'm not exactly sure why is it more efficient
19:07:53 <mniip> > sk (Abs "a" $ Var "a")
19:07:54 <dramforever> *it is
19:07:55 <lambdabot>  [\a -> a,S K K]
19:08:12 <mniip> dramforever, it produces less combinator noise
19:08:26 * dramforever is not convinced
19:08:33 * dramforever tries himself
19:10:14 <lpaste_> mniip revised “SK”: “No title” at http://lpaste.net/139170
19:10:18 <mniip> ugh
19:10:33 <mniip> lpaste doesn't respect my privacy :(
19:11:16 <mniip> anyway, replaced sk with skProcess, sk now displays the end result
19:12:03 <mniip> > sk (Abs "a" $ Abs "b" $ Var "b" `App` Var "a")
19:12:05 <lambdabot>  S (K (S (S K K))) K
19:14:45 <dramforever> mniip: I wonder if you have an example where the naive algorithm produces a longer result than yours
19:14:53 <mniip> hmm
19:14:55 <dramforever> and please, make it short
19:21:13 <mniip> > sk (Abs "a" $ Abs "b" $ Var "b" `App` Var "a" `App` "b")
19:21:15 <lambdabot>      Couldn't match expected type ‘Lambda’ with actual type ‘[Char]’
19:21:15 <lambdabot>      In the second argument of ‘App’, namely ‘"b"’
19:21:15 <lambdabot>      In the second argument of ‘($)’, namely
19:21:31 <mniip> > sk (Abs "a" $ Abs "b" $ Var "b" `App` Var "a" `App` Var "b")
19:21:32 <lambdabot>  S (S (K S) (S (K (S (S K K))) K)) (K (S K K))
19:21:47 <mniip> hmm that's exactly the same
19:22:15 <mniip> dramforever, maybe they're equivalent? that would be weird as hell though
19:22:26 * dramforever doesn't know
19:22:40 <edwardk> you know you are doing something wrong when you need to use unsafeCoerce reallyUnsafePtrEquality#
19:23:12 <edwardk> and when that isn't the worst thing in the module
19:23:39 <mniip> edwardk, does that even kindcheck
19:23:49 <edwardk> sure
19:23:50 <mniip> (# vs *)
19:23:52 <dramforever> yes it does...
19:24:11 <edwardk> reallyUnsafePtrEquality :: a -> a -> Int#
19:24:16 <dramforever> edwardk: checking pointer equality of two values with different types?
19:24:23 <edwardk> (a -> a -> Int#) :: *
19:24:28 <mniip> hmok
19:24:37 <dramforever> :k a -> a -> Int# -- check for sure
19:24:39 <lambdabot> Not in scope: type variable ‘a’
19:24:39 <lambdabot> Not in scope: type variable ‘a’
19:24:39 <lambdabot>     Not in scope: type constructor or class ‘Int#’
19:24:44 <dramforever> sigh...
19:24:49 <edwardk> :t Int -> Int#
19:24:50 <lambdabot> parse error on input ‘->’
19:24:54 <edwardk> :k Int -> Int#
19:24:55 <lambdabot>     Not in scope: type constructor or class ‘Int#’
19:24:55 <lambdabot>     Perhaps you meant one of these:
19:24:55 <lambdabot>       ‘Int’ (imported from Data.Int), ‘Int8’ (imported from Data.Int)
19:24:58 <edwardk> bah
19:25:25 <mniip> edwardk, any idea about how a naive "move points to the end to eta-reduce them" algorithm could be equivalent to schoenfinkel's idea of lifting application into the S combinator?
19:25:37 <osa1> does that look familiar to anyone: f1 <.> f2 = fmap f1 . f2 do we have something like this in base? (before you ask, yes I tried hoogle)
19:25:39 <broma0> anyone know of an attoparsec parser for a string literal? handling escapes, etc.? Can't find it provided in the lib
19:25:46 <edwardk> :k Int -> GHC.Prim.Int#
19:25:47 <lambdabot> *
19:25:58 <dramforever> good
19:26:06 <nicolas12> hello people, I've an issue trying to export some stuff using internals
19:26:10 <edwardk> mniip: sorry, head in the clouds chasing after getting something to work that currently segfaults
19:26:26 <dramforever> :t \f1 f2 -> fmap f1 . f2
19:26:27 <lambdabot> Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
19:26:38 <dramforever> :t fmap . fmap
19:26:40 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
19:27:02 <nicolas12> I defined an internal module, and another one which exports it, but I want to re-export some of the former stuff
19:27:08 <dramforever> osa1: here you are...but I doubt if it's better than yours
19:27:15 <nicolas12> from the module that is importing the internal
19:28:03 <mniip> dramforever, just use the boobs combinator! (.).(.), oh wait, that only works on a specific functor
19:28:07 <osa1> dramforever: well even `fmap f1 . f2` is better than `(fmap . fmap) f1 f2` :)
19:28:19 <dramforever> osa1: that's what I was thinking about
19:28:47 <jle`> osa1: it's (<<^) with the Kleisli newtype wrapper
19:29:19 <dramforever> :t rmap
19:29:20 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
19:29:32 <dramforever> jle`: yes it is
19:29:40 <dramforever> s/Kleisli/Star/
19:29:40 <osa1> OK. this is actually quite useful, I just defined it in a utils module and now I'm using it all the time
19:31:28 <edwardk> woot. it seems to be working
19:32:06 <edwardk> and the benchmarks segfault.. ok, so maybe not
19:33:13 <broma0> Can someone help answer a question regarding Attoparsec? Why is 'asciiCI' type 'Text -> Parser Text' and not just 'Parser Text'?
19:33:32 <dramforever> how much text do you expect it to parse?
19:33:56 <broma0> a full string literal, however long it is
19:34:04 <broma0> could be "a", could be "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
19:34:12 <dramforever> I wonder if it actually does that
19:34:34 <broma0> "satisfy a string literal" - description
19:34:40 <dramforever> oh
19:34:41 <arkeet> broma0: asciiCI just matches the string you give it.
19:34:41 <dramforever> ok then
19:34:44 <arkeet> (case insensitive)
19:34:45 <dramforever> wait
19:34:55 <broma0> ah, how can I use atto to match a string literal?
19:34:56 <dramforever> broma0: you just made me confused =(
19:35:01 <arkeet> make a string literal parser.
19:35:06 <pacak> broma0: Because it will look for that string you passed as a parameter
19:35:15 <dramforever> broma0: stringCI "blah" matches blah BLah, blaH
19:35:25 <dramforever> "string literal" lol
19:35:28 <broma0> dramforever: ahh i see says the blind man
19:35:41 <dramforever> =)
19:36:19 <broma0> well then how does one make a "literal string parser" handling escapes and all that? i dont want to just 'char '\"' *> takeWhile (/='\"')'
19:51:20 <porges_> something like: char '\"' *> many (notChar '\\' <|> (char '\\' >> anyChar)) <* char '\"'
19:51:42 <porges_> depending on what exactly you want to capture
19:52:50 <porges_> oh you want to exclude '"' in the middle there too
19:52:50 <porges_> but you get the idea :)
19:54:26 <broma0> porges_: so pretty much just put all of the possible escape sequences in a 'many notChar' ?
19:58:31 <mniip> edwardk, what in the hay are you working on that requires comparing pointers to 2 objects of unknown types?
19:59:29 <edwardk> something where i'm unsafeCoercing the mutable version into the immutable one after freezing all the arrays inside of it
19:59:37 <edwardk> but where some of my arrays may still be frozen
19:59:52 <mniip> tell me more about it
19:59:56 <edwardk> so i have a custom foreign prim for checking if a SmallMutableArray# has been frozen or not
20:00:45 <edwardk> https://github.com/ekmett/transients/blob/master/src/Data/Transient/WordMap.hs is the module in question. i've shuffled things so i no longer need the unsafeCoerce reallyUnsafePtrEquality# though.
20:01:59 <mniip> any particular reason you're doing ==# 1#
20:02:23 <mniip> do you expect reallyUnsafePtrEquality# to return something outside [0#, 1#]
20:02:37 <edwardk> mniip: i didn't check the API, i stole that from tibbe
20:03:01 <mniip> you only need isTrue#
20:04:15 <edwardk> checking the invariants in the code for it, but that seems plausible
20:04:56 <mniip> in non-magic haskell that's like 'if x == True then'
20:05:10 <edwardk> sure
20:06:34 <edwardk> yeah its just doing a word equality compare, fixed.
20:06:41 <edwardk> https://github.com/ghc/ghc/blob/b38ee89c8c8724ba2feb98d4082795a5d4ae96f6/compiler/codeGen/StgCmmPrim.hs#L352
20:07:30 <mniip> edwardk, anyway, what is the code about in general
20:08:16 <edwardk> data structures you can 'thaw' in O(1) into a form that becomes mutable as it copy-on-writes from frozen structures into mutable structures
20:08:21 <edwardk> then lets you freeze up behind it
20:08:40 <edwardk> the freezing here can be done online as you do the action (which is the hint machinery) or it can be done as a post process
20:09:03 <bz> git push --all
20:09:03 <dramforever> kinda like generalized DiffArray?
20:09:07 <edwardk> the costs are basically the same as a usual data structure when doing the former, but can be faster
20:09:10 <mniip> huh
20:09:22 <mniip> interesting
20:09:37 <edwardk> dramforever: well, this is for things like an IntMap, where you want to make it so multiple mutations in the same area can fuse together into one rewrite without reallocating the paths to the root
20:09:49 <dramforever> oh okay
20:10:00 <edwardk> but with a 32-way fanout tree with b-tree like balancing you get a fast vector with log_32 performance for most operations
20:10:25 <edwardk> what this thing is is a WordMap with a single 'finger' selected into the tree
20:10:35 <dramforever> hmm...
20:10:54 <linman32> what is a good haskell refactoring tool? HaRe doesn't work with GHC 7.8.x
20:11:05 <edwardk> because the finger turns out to give me a lot of performance, making multiple inserts pay proportional to how 'far' it is from the latest value inserted.
20:11:31 <edwardk> the way i've constructed the finger it is never more than O(1) overhead -- as if i'd had an extra level in the wordmap
20:11:50 <edwardk> and the structure is 'zipped up' and actually mutated as you move the finger
20:12:22 <edwardk> basically i can charge all the finger moves to the operations themselves, and it isn't part of the public API
20:12:23 <dramforever> this finger thing looks interesting
20:12:36 <edwardk> but it does mean things like 'at' in lens terms become rather ridiculously efficient
20:12:43 <edwardk> because it hammers the same finger
20:12:43 <dramforever> edwardk: so it's kinda like a zipper?
20:12:46 <edwardk> yeah
20:13:08 <edwardk> its a pointed structure, but it allows the point to be missing
20:13:17 <linman32> looking for a haskell refactor tool for emacs. there's gotta be something
20:13:25 <edwardk> i'm fishing around looking for data structures that just perform pretty well across the board
20:13:33 <edwardk> this is one of the things i need for something else
20:13:41 <edwardk> notably i need a fast mutable wordmap for discrimination
20:13:55 <edwardk> so i figured i'd tackle stealing clojure transients for haskell
20:14:04 <edwardk> but replace the thread id nonsense with types
20:14:25 <edwardk> since it isn't a meaningful concept here
20:14:30 <edwardk> and we like parallelism
20:14:38 <dramforever> edwardk: oh wait so it's like a real mutable Map?
20:14:43 <edwardk> dramforever: yeah
20:14:54 <dramforever> interesting
20:15:00 <mniip> I feel like it's a bit more powerful than a map
20:15:01 <edwardk> TWordMap s v  -- is a mutable map, WordMap v is an immutable map
20:15:03 <edwardk> we convert back and forth
20:15:20 <dramforever> I like this COW idea
20:15:34 <edwardk> https://github.com/ekmett/transients/blob/master/examples/Tree.hs gives a simple version, which isn't as smart as what i'm trying to do
20:15:44 <edwardk> you can see it has to write the insert code 3x, and has to copy when its done
20:15:58 <edwardk> so its about 2x worse in memory allocations, 3x worse in code size
20:16:20 <edwardk> the tree there is just an example of 'how to make any transient structure'
20:17:12 <dramforever> hmm...lazy thawing
20:17:29 <edwardk> the new structure is trickier. what i do is rely on the fact that the underlying representation of a SmallMutableArray# s a  and SmallArray# a is exactly the same, except for the info pointer, and unsafeFreezeArray mutates the info pointer of the target in place
20:17:49 <edwardk> so i added a primop for detecting if a SmallMutableArray# s a has been frozen
20:18:10 <edwardk> and i'm ensuring the invariant that if i encounter a frozen SmallMutableArray# s a anywhere in my structure, everything below that point is frozen
20:18:20 <bycn82> hello
20:18:32 <edwardk> and the ops on the structure copy-on-write when they need to change an existing array
20:18:41 <bycn82> i am trying to call the "callCommand" but  Not in scope: `callCommand'
20:18:58 <edwardk> and i use reallyUnsafePtrEq to avoid re-building on the path to the root when things don't change
20:19:17 <mniip> bycn82, what makes you think callCommand exists
20:20:05 * hackagebot moesocks 0.1.0.20 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.20 (JinjingWang)
20:20:10 <edwardk> freezing is trickier. i tell the focus changing operation a 'hint' as to whether it should freeze things up behind it. if its hinted 'cold' then it freezes, otherwise it leaves the arrays untouched, so that subsequent mutable operations can go down and just bang in place and not edit anything on the way to the root
20:20:12 <bycn82> http://hackage.haskell.org/package/process-1.2.3.0/docs/System-Process.html#v:readProcess
20:20:16 <edwardk> sharing all the structure that is already there
20:20:35 <mniip> bycn82, have you imported System.Process
20:20:40 <bycn82> yes
20:20:48 <bycn82> import System.Process
20:20:49 <bycn82> main = callCommand "ls /"
20:20:51 <edwardk> so i get a speedup from the finger itself and from the switch to mutation after the structure warms up
20:21:02 <edwardk> each giving more or less orthogonal speedups
20:21:33 <dramforever> I wonder if it's actually a raw performance gain
20:21:36 <edwardk> with the finger repeated edits near each other are O(1), but the constants are big, w/ whole array copies, the transient thing reduces pressure on that
20:21:39 <mniip> bycn82, what version is the "process" package
20:21:41 <dramforever> seems so
20:22:08 <bycn82> mniip: how can I check the version of the module?
20:22:13 <edwardk> dramforever: this has paid out quite a lot for things like clojure. taking you from 400% overhead to 8% overhead for persistence for some applications
20:22:24 <dramforever> =)
20:22:30 <bycn82> mniip: i am using HCi, version 7.0.4: 
20:22:36 <edwardk> they don't do this particular wordmap, but this is the thing i need, so i'm building it first
20:22:42 <bycn82> GHC 7.0.4 
20:22:48 <dramforever> that seems old
20:23:25 <edwardk> bycn82: are you stuck on something like ubuntu long term support?
20:23:25 <mniip> bycn82, ghc-pkg list | grep process
20:23:25 <dramforever> bycn82: ghc-pkg describe process
20:23:35 <mniip> or that
20:23:39 <dramforever> check the second line
20:23:44 <dramforever> mine says 1.2.3.0
20:24:08 <bycn82> process-1.0.1.5
20:24:10 <bycn82> thanks
20:24:21 <edwardk> dramforever: anywyas the main thing i'm hunting for is a way to avoid randomly thrashing the heap for no reason, so this is proving to be an exercise in exploring how much i can keep on the stack
20:24:31 <dramforever> okay
20:24:47 <mniip> bycn82, http://hackage.haskell.org/package/process-1.0.1.5
20:24:51 <edwardk> trying to basically write allocation-free code except where it absolutely needs to 
20:25:00 <edwardk> and seeing how much speed i can eke out that way
20:25:19 <mniip> bycn82, in that version it's called 'system'
20:25:22 <mniip> it looks like
20:26:33 <SrPx> Is there any fast purely functional implementation for a queue, for an algorithm that, for each iteration of a loop, pops the first element and appends something to the end of the queue?
20:27:26 <jle`> SrPx: you can make a nice efficient queue using two stacks
20:27:34 <bycn82> mniip: thanks
20:27:37 <jle`> and [a] is of course an awesome stack
20:27:37 <dramforever> SrPx: the double list one is fast enough I think
20:27:47 <dramforever> O(1) amortized
20:27:54 <dramforever> i.e. O(n) for n operations
20:28:14 <SrPx> jle`: I know about this solution, but I was thinking about something that used a free variable on the last spot of a structure and used it to fill it... doesn't something like that exist?
20:28:54 <jle`> you can use finger trees to get cheap cons from both sides
20:28:58 <jle`> like from Data.Seq
20:29:03 <dramforever> Data.Sequence
20:29:04 <jle`> cheap cons and uncons
20:29:11 <jle`> yeah, Data.Sequence i mean, heh
20:29:14 <dramforever> persistently!
20:29:20 <jle`> yay persistence
20:29:20 <arkeet> doesn't that have worse constant factors
20:29:29 <jle`> it does
20:29:40 <jle`> it might have worse asymptotics too
20:29:48 <jle`> i feel like it would
20:30:26 <dramforever> no
20:30:27 <SrPx> I'll take a look in finger trees, don't know much about those... but for example, (\ x -> (1,(2,(3,(4,x)))))... with that, you could easily edit the last position, and could easily add something to the beginning 
20:30:47 <dramforever> that's not easy...
20:30:48 <SrPx> I was thinking there would be something using that idea, but I believe that wouldn't work, I'm just not sure why
20:31:00 <dramforever> +1 for "believe"
20:31:13 <jle`> hm, i guess you're not looking for a queue, but more like a cyclable structure
20:31:15 <arkeet> that's like a difference list
20:31:22 <jle`> with cheap cycling
20:31:28 <SrPx> jle`: ah actually I am, yes, didn't think of that name. that's it
20:31:30 <jle`> why don't you just use cycle from Prelude?
20:31:40 <SrPx> wasn't even aware, let me see
20:31:42 <edwardk> SrPx: http://hackage.haskell.org/package/lens-4.12.3/docs/src/Control-Lens-Internal-Deque.html#Deque can be adapted to non-lens code
20:31:50 <arkeet> oh you put the *same* thing you pop from the front onto the back?
20:31:53 <arkeet> then yeah use cycle
20:31:55 <jle`> > cycle "abc"
20:31:57 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
20:32:09 <jle`> you can keep on unconsing and popping from the front and get the same thing you just popped put in the back
20:32:21 <jle`> oh you meant something *else*, heh
20:32:24 <jle`> sorry
20:32:37 <Norelec> > [1..10]
20:32:39 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:33:43 <SrPx> ah, you mean the function
20:34:15 <SrPx> hmm that might serve
20:34:54 <SrPx> and what edwardk said for queues
20:35:15 <SrPx> but I'm still curious to know if there is some proof or something the idea of using a variable to edit the last position is impossible
20:35:46 <dramforever> it is possible
20:35:53 <dramforever> but maybe inefficient
20:40:06 * hackagebot hemokit 0.6.6 - Haskell port of the Emokit EEG project  https://hackage.haskell.org/package/hemokit-0.6.6 (NiklasHambuechen)
20:55:05 <Welkin> for a Sequence (finger tree), what is the total complexity for incrementally building the tree and simultaneously consuming the nodes until it is empty (using it as a queue)?
20:55:26 <arkeet> dequeue operations are O(1)
20:55:26 <Welkin> there must be some rebalancing happening as you add and remove nodes
20:55:30 <Welkin> I know
20:55:30 <arkeet> amortized
20:55:34 <Welkin> oh
20:55:36 <Welkin> wow
20:56:12 <arkeet> the finger tree paper is nice
20:56:19 <Welkin> I have the book :P
20:56:26 <Welkin> but I haven't read it in full yet
20:56:44 <arkeet> what book?
20:56:49 <Welkin> do you think a Sequence is a good choice for a queue?
20:56:51 <arkeet> I mean this paper http://staff.city.ac.uk/~ross/papers/FingerTree.html
20:56:55 <Welkin> arkeet: Okasaki
20:57:01 <arkeet> if all you need is a queue then you can do better for constant factors
20:57:06 <Welkin> ah, it references that paper
20:57:13 <Axman6> Finger trees are newer than Okasaki's book
20:57:18 <arkeet> ^
20:57:25 <Welkin> really?
20:57:28 <arkeet> 2006
20:57:44 <arkeet> by 10 years
20:58:06 <Welkin> okay
20:58:12 <kadoban> Yeah there's cute deque stuff in okasaki if that's all you need. Finger trees aren't in there though. https://cstheory.stackexchange.com/questions/1539/whats-new-in-purely-functional-data-structures-since-okasaki <-- the first answer on that is … amazing if you're looking for okasaki related stuff.
20:58:17 <Welkin> what do you recommend for a standard queue (not priority)
20:58:28 <arkeet> okasaki has that
20:58:53 <kadoban> For use persistently, or not? But yeah IIRC it has both … several versions.
20:59:01 <Axman6> I would use Sequencees, my playing found that okasaki's O(1) queues were pretty slow
20:59:28 <Welkin> for example, a queue for use in a BFS
20:59:58 <Welkin> I have already used Sequence for this purpose
21:00:04 <Welkin> but I was wondering if there is something better
21:00:10 <monochrom> maxiphobic heap? hehe. does it mean it is not min-heap, it just fears max?
21:00:12 <Welkin> (it was very nice to use :P)
21:00:56 <SrPx>  That answer is a bible
21:02:24 <Welkin> thanks for the links arkeet and kadoban 
21:02:36 <Welkin> I thought I had that stackexchange page bookmarked though!
21:03:14 <monochrom> now I also have to bookmarked :)
21:03:30 <monochrom> err, s/ to / it /
21:03:45 <kadoban> Yeah I've been slowly working my way through those and reviewing some parts of okasaki recently, it's pretty fun.
21:03:54 <arkeet> I should get back to reading it.
21:03:59 <Welkin> any other suggestions?
21:04:05 <Welkin> or is the consensus that Sequence is best?
21:04:22 <dolio> No, sequence is not best.
21:04:53 <Welkin> well, a doubly-linked list would have better performance most likely
21:04:59 <Welkin> but I don't know of any in haskell
21:05:14 <dolio> Something from Okasaki will have better constant factors if you just need a queue.
21:06:05 <kadoban> Generally the more specific you get the better you can make the constant factors, but if there's a general data structure that's in a library you can use, that's better from the avoiding-premature-optimization point of view.
21:06:26 <Welkin> well, I am thinking about queues in terms of graph traversal
21:06:32 <kadoban> IOW, do it the boring way first, the interesting way only if you have to … unless you're just in it for the fun, in which case do whichever amuses you.
21:07:34 <erisco> how do I excise a substring of Text in constant time? say I want characters 12 through 15
21:07:57 <Axman6> take 3 . drop 12?
21:08:09 <erisco> that is not constant time
21:08:36 <erisco> okay, so to be more particular, I just want the time proportional to the size of the excised substring
21:09:08 <erisco> and drop is O(n)
21:09:17 <Welkin> erisco: Text? It is an array
21:09:27 <erisco> good, so how do I use it like one
21:09:31 <Welkin> you can just slice into it using the indexes
21:09:54 <erisco> it is seeming like I have to write a routine to index 12, 13, 14, and 15
21:09:56 <kadoban> Quote from the docs: "If you think of a Text value as an array of Char values (which it is not), you run the risk of writing inefficient code."
21:10:03 <erisco> then pack that into a Text
21:10:18 <erisco> which doesn't seem right because taking a substring is common
21:10:33 <dolio> If drop isn't O(1), then neither is indexing.
21:10:38 <kadoban> Isn't index O(n)
21:10:57 <dolio> And the reason they aren't is UTF-16.
21:11:28 <dolio> You can't just index without having a structure that tells you where to index, which it doesn't have.
21:11:38 <kadoban> Yeah I don't think Data.Text can do those things.
21:11:51 <Axman6> erisco: for strict bytestrings, drop is O(1), for lazy bytestrings it's O(n), but n is the number of text chunks, not characters
21:11:56 <Welkin> ah
21:12:04 <erisco> yeah index is O(n)
21:12:07 <Welkin> yeah it exposes take/takeEnd and drop
21:12:12 <erisco> I want a different data structure then
21:12:33 <Axman6> oh except that Text is also unicode, so one codepoint does not equal one character (but most of the time does)
21:12:38 <dolio> ByteString will have the same issue if you want to represent text.
21:12:41 <arahael> erisco: Lets take a step back. What do you mean by "Characters" 12 through 15?
21:12:59 <Axman6> yeah the definition of Character is important
21:13:12 <kadoban> If it were UTF-32 I guess you could do it, but … it's not :-/
21:13:21 <dolio> Even then it depends.
21:13:22 <arahael> It's ambigoius even in UTF-32.
21:13:33 <dolio> Because of combining characters.
21:13:56 <kadoban> Oh combining characters … those jerks.
21:14:01 <arahael> Not only because of combining characters.  Zero-width characters as well.   And I vaguely think of several other special cases.
21:14:25 <erisco> I think I can get away without random access, but I need efficient forward traversal
21:14:27 <Welkin> the take/drop approach looks fine erisco 
21:14:40 <Axman6> erisco: what makes you think you won't get that with Text?
21:14:48 <kadoban> Welll, Text does have efficient forward traversal AFAIK
21:14:59 <erisco> Axman6, random access? the time complexity of index
21:15:23 <Axman6> right, but that's because you can't do that, unless you use 32bit characters
21:15:33 <erisco> O(n) drop n  apparently
21:15:41 <erisco> what is the data structure under the hood
21:15:44 <erisco> this seems mysterious
21:15:47 <Welkin> erisco: Array
21:15:51 <Axman6> an array of 16bit code points
21:15:54 <arahael> Lately I think the only thing you can do regarding the length of a string, is count the bytes needed for it.  Or the pixels needed if you render it (with a particular font)
21:16:02 <Axman6> but one code point does not equal one character
21:16:11 <Welkin> that is interesting Axman6 
21:16:20 <Welkin> I always thought Text was Array Char
21:16:23 <Welkin> now I know
21:16:25 <Axman6> (I'm sure my terminology is wrong here, shachaf will probably correct me)
21:16:33 <dolio> arahael: You can probably only count the bytes you're using to store it. :)
21:16:34 <arahael> Axman6: And each 16-bit word isn't neccessarily a codepoint. :)
21:16:37 <Welkin> I was working a lot with ByteString recently
21:16:46 <arahael> dolio: That's partly my point. :)
21:16:46 <Axman6> Welkin: there would be a lot of overhead for that - each character would take up 32 bits
21:16:51 <dolio> I assume there isn't necessarily a single number of bytes for each string.
21:17:09 <kadoban> text is so goddamn complicated all the time, heh.
21:17:14 <erisco> alright I'll see if I can get by with drop
21:17:27 <Axman6> it's still slightly better than String because the memory is contiguous, but it's not much better
21:17:29 <Welkin> which is why String is great for learning!
21:17:44 <Welkin> Axman6: really? I thought Text was a highly optimized String?
21:17:47 <arahael> kadoban: It gets worse.  Sometimes I think the way Ruby and Delphi did it is right. :(
21:18:24 <Axman6> Welkin: no, String is [Char], nothing more. Text is a(n) array(s) of 16bit values
21:18:35 <Welkin> I know, I meant String conceptually
21:18:41 <Axman6> no
21:18:52 <shachaf> Axman6: hi
21:18:57 <Axman6> there are unicode values Text can't hold, which String can
21:19:23 <Axman6> shachaf: glad you're here, I can stop talking out of my arse about things I've mostly (mis) learned from you =)
21:19:27 <kadoban> arahael: Didn't delphi have like 5 different string types or something, none of which made a ton of sense? Been a long time.
21:19:29 <startling> there are unicode values Text can't hold?
21:19:38 <arahael> Axman6: You mean, if said unicode values aren't in UTF encoding?
21:19:41 <nshepperd> i think Axman6 meant Array Char would be not much better than String
21:19:44 <erisco> sounds like a bee hive in here
21:19:44 <startling> it doesn't do surrogate pairs?
21:20:09 <arahael> kadoban: Sometime in the past 5 years they have real unicode.
21:20:28 <Axman6> "A Text value is a sequence of Unicode scalar values, as defined in §3.9, definition D76 of the Unicode 5.2 standard. As such, a Text cannot contain values in the range U+D800 to U+DFFF inclusive."
21:20:28 <arahael> kadoban: But the encoding is dynamically associated with the string - each string type has a codepage associated with it.
21:20:56 <kadoban> arahael: Ah, interesting. Delphi was basically my first language … and I haven't looked at it in years
21:21:04 <arahael> Axman6: So, what *unicode* values can't that store?
21:21:17 <arahael> kadoban: It's changed a lot.  'char' is now 16 bits. :)
21:21:19 <Axman6> https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text.html :\
21:21:44 <nshepperd> arahael: Char can store U+D800
21:21:45 <Axman6> arahael: that probably means it suffers from the same problems
21:21:47 <arahael> kadoban: And you have ansichar, etcetera, as well.  Doesn't make me like it.
21:21:55 <arahael> Axman6: Indeed it does.
21:21:59 <kadoban> Hehe
21:22:16 <arahael> nshepperd: So, what unicode value is U+D801?
21:23:03 <arahael> nshepperd: I gather that there are *values* that text can't store adn that strings can. You're claiming that there are *unicode* values that can't.  I'm asking what you mean by that.
21:23:08 <erisco> uhh hmm
21:23:12 <startling> > Data.Text.unpack $ Data.Text.pack "🐷"
21:23:14 <lambdabot>  Not in scope: ‘Data.Text.unpack’Not in scope: ‘Data.Text.pack’
21:23:25 <nshepperd> no idea
21:23:28 <erisco> no one knows the answer but how might I run a tdfa regex on Text?
21:23:30 <kadoban> > T.unpack $ T.pack " "
21:23:32 <lambdabot>      Not in scope: ‘T.unpack’
21:23:32 <lambdabot>      Perhaps you meant ‘BS.unpack’ (imported from Data.ByteString)    Not in ...
21:23:32 <lambdabot>      Perhaps you meant ‘BS.pack’ (imported from Data.ByteString)
21:23:43 <kadoban> Crap, the one time I don't check in PM …
21:24:15 <nshepperd> arahael: Does "unicode value" even have a technical definition?
21:24:26 <erisco> maybe lambdabot shouldn't vomit type errors into the channel
21:24:33 <Axman6> https://hackage.haskell.org/package/text-1.2.1.3/docs/Data-Text.html#g:2 :\
21:24:39 <startling> Prelude Data.Text> (Data.Text.unpack $ Data.Text.pack "🐷") == "🐷"
21:24:40 <startling> True
21:25:03 <arahael> nshepperd: No, so whatever Text means by "unicode" must be hte definition we use here. :)
21:25:20 <Axman6> how about you read the documentation I've now posted twice :\
21:25:30 <startling> Axman6, that doesn't say what you said
21:25:32 <nicolas12> hi guys, how do I expose an internal module for tests?
21:25:34 <erisco> instead lambdabot could paste the error to lpaste and reply with the link
21:25:36 <erisco> how fancy would that be
21:25:59 <pacak> erisco: Not fancy at all.
21:26:14 <erisco> I think it'd be rather snazzy myself
21:26:26 <nshepperd> arahael: the docs just say we can store all "unicode scalar values" but not all "values"
21:26:32 <Axman6> I think that would be a pain in the arse =)
21:26:51 <Axman6> nshepperd: it also links to the documents which expand on what that means
21:27:01 <arahael> nshepperd: Right.  So the statement that there are unicode values that can be stored in String, but not Text, must be wrong.
21:27:01 <nshepperd> seems pretty clear to me
21:27:23 <Axman6> arahael: why do you say that?
21:27:30 <nshepperd> arahael: I still don't know what a "unicode value" is
21:27:40 <startling> nshepperd, a unicode code point, I guess
21:28:14 <arahael> nshepperd: Does it matter?  Assuming that there are no bugs in Text, if it can store all unicode values, then it can store all unicode values. The End.
21:28:31 <nshepperd> arahael: no, unicode scalar values
21:29:00 <arahael> nshepperd: I assumed they were _all_ scalar values?
21:29:12 <startling> I think it's fair to assume when someone says "a unicode value" they don't mean "any byte used by any unicode encoding"
21:29:21 <startling> or rather any sequence of bytes
21:29:58 <arahael> Indeed.
21:30:04 <arkeet> :t Data.Text.pack
21:30:06 <lambdabot> String -> Data.Text.Internal.Text
21:30:07 <nshepperd> I understood U+D800 - U+D8FF to be reserved code points
21:30:23 <arkeet> > Data.Text.unpack (Data.Text.pack "\xD800") == "\xD800"
21:30:26 <lambdabot>  Not in scope: ‘Data.Text.unpack’Not in scope: ‘Data.Text.pack’
21:30:31 <arkeet> oh.
21:30:37 <erisco> which regex engines support unicode? ideally Text
21:30:54 <startling> arkeet, yeah, surrogate pairs work
21:30:54 <Axman6> https://hackage.haskell.org/package/text-icu
21:31:06 <startling> this is an argument about semantics at this point I think
21:31:27 <startling> oh, nvm
21:31:45 <nshepperd> in which case U+D800 is a code point but not a scalar value
21:31:53 <nshepperd> or something like that
21:31:59 <startling> is it a code point?
21:32:53 <erisco> I guess the answer is this http://hackage.haskell.org/package/text-icu-0.7.0.1/docs/Data-Text-ICU-Regex.html
21:33:24 <nshepperd> ...yes 'Code Point. (1) Any value in the Unicode codespace; that is, the range of integers from 0 to 10FFFF'
21:34:04 <arkeet> meanwhile: Unicode Scalar Value. Any Unicode code point except high-surrogate and low-surrogate code points. In other words, the ranges of integers 0 to D7FF16 and E00016 to 10FFFF16 inclusive.
21:34:21 <nshepperd> there we go
21:34:29 <arkeet> terminology.
21:34:45 <startling> nshepperd, arkeet: I see. thanks.
21:36:56 <nshepperd> packing and unpacking a "\xD800" results in "�"
21:37:21 <nshepperd> the something something replacement character
21:37:45 <startling> yeah. I think there was just confusion over "unicode value"
21:37:49 <arkeet> it results in "\xFFFD"
21:38:08 <dolio> The fun thing is, according to that document, Text can store every Unicode string.
21:38:18 <dolio> Just some Strings are not Unicode strings.
21:38:46 <arkeet> "Unicode String" has a particular definition too.
21:38:55 <dolio> Right.
21:39:06 <arkeet> where does it say that, though
21:39:10 <dolio> It is a sequence of code units.
21:39:33 <nshepperd> in practice you'd be crazy to store surrogate code points in a String anyway
21:39:41 <arkeet> that's kind of silly. code units aren't characters or code points.
21:39:57 <dolio> Well, too bad, I guess.
21:41:40 <nicolas12> how can I use an internal module for tests? do I have to duplicate it?
21:41:49 <arkeet> not that any UTF forms can legally encode those code points anyway.
21:41:52 <arkeet> not just UTF-16
21:42:16 <arkeet> nicolas12: in your cabal project you can have your test depend on the library in the same package
21:42:32 <arkeet> in build-depends
21:43:39 <nicolas12> arkeet I have that dependency
21:44:06 <dolio> Actually, maybe what I said wasn't correct. Text can only represent the UTF-16 Unicode strings, technically.
21:44:19 <arkeet> dolio: that sounds good to me.
21:44:23 <dolio> Which are equivalent to UTF-8 and UTF-32 strings.
21:44:28 <arkeet> mhm
21:45:13 <ttt_fff> besides existing libraries, what is the main advantage of haskell over idris ?
21:45:29 <AaronFriel> dolio: Which is unfortunate, because it involves lots of copying when handling UTF8 data
21:45:40 <AaronFriel> dolio: Really wish there was a TextUtf8, TextUtf16, etc.
21:45:46 <arkeet> ttt_fff: haskell is lazy.
21:46:14 <ttt_fff> arkeet: I believe in idris, you get to CONTROL what is layzy and what is strict
21:46:22 <dolio> I don't know if I'd want them distinguished in types. Perhaps just having a tagged union would be better.
21:47:17 <AaronFriel> I know the answer to this will be shockingly obvious to many people, and it will be to me once I see it: what's the easiest way to simulate lazy IO? e.g.: to get a list [a] such that each element takes... 500 ms to return. 
21:47:50 <mauke> unsafeInterleaveIO + threadDelay
21:47:51 <arkeet> AaronFriel: it involves unsafeInterleaveIO
21:48:05 <AaronFriel> Really? Oh, I guess it makes sense that it requires unsafe
21:48:49 <AaronFriel> I thought there would be some obvious solution involving safe functions.
21:49:15 <kadoban> Not without an IO type I don't believe.
21:49:28 <AaronFriel> Oh, I'm okay with it having an IO type, I'm just using GHCi
21:49:43 <AaronFriel> I want to pass this lazy list to a function to see how it behaves under, well, more human time scales
21:49:53 <arkeet> example: let x n = (n :) <$> unsafeInterleaveIO (threadDelay 500000 >> x (n+1)) in x 0
21:50:03 <arkeet> is an IO [Integer] or something.
21:50:11 <AaronFriel> that'll work
21:50:17 <dolio> Count from 1 to a billion before each element.
21:50:24 <AaronFriel> dolio: haha
21:50:32 <arkeet> hey, that is a legitimate method.
21:50:39 <AaronFriel> arkeet: TRUE
21:50:57 <AaronFriel> arkeet: And I said "this will be shockingly obvious"
21:50:59 <arkeet> (or you can do something with unsafePerformIO with threadDelay to not actually eat up CPU.)
21:51:07 <AaronFriel> right, I think that's what I'll do
21:51:13 <arkeet> (beware of sharing)
21:51:35 <AaronFriel> All I really want to do is get a list like this: ['a','a','a'...]
21:52:08 <AaronFriel> your example will work fine for that
21:52:41 <arkeet> you could make some combinatir that works in pure code like: slow a = unsafePerformIO (threadDelay 500000 >> return a)
21:52:44 <arkeet> (I think?)
21:53:08 <arkeet> and then your list would look like
21:53:13 <arkeet> list = 'a' : slow list
21:53:26 <arkeet> wait.
21:53:32 <arkeet> let's try.
21:53:47 <arkeet> nope.
21:54:18 <AaronFriel> Sharing kills it, right?
21:54:20 <arkeet> yep.
21:54:25 <arkeet> you can fix that with something like let list () = 'a' : slow (list ()) in list ()
21:55:07 <AaronFriel> It is ironic that perhaps the easiest way to not do something in Haskell is to do lots of pointless things (and make sure your code has a transitive dependency on the meaningless result)
21:55:16 <dolio> GHC might be too smart for that to work, too.
21:55:27 <AaronFriel> O
21:55:30 <AaronFriel> ugh
21:55:34 <AaronFriel> I'm okay with the first method
21:55:37 <arkeet> unsafeInterleaveIO seems the most predictable(?) way
21:55:44 <AaronFriel> it gives me a list I can throw at a function
21:56:11 <arkeet> although the "slow" method has the advantage that you could do it without any unsafe stuff, I think.
21:56:24 <arkeet> slow a = last [1..10000000] `seq` a
21:56:26 <arkeet> or something.
21:58:20 <samba1> In the Typeclassopedia it asks If the composition of two Functors is also a Functor.
21:58:25 <samba1> What does composition mean when speaking of Functors? Something that's an instance of Functor containing something that's also an instance of Functor, like IO (Maybe Int)?
21:58:34 <arkeet> yes.
21:58:52 <samba1> in that case, the answer seems too obvious...
21:58:58 <AaronFriel> Yeah I'm not worried about safety but I do want to simulate lazy IO, and unsafeInterleaveIO is (semantically) the same as the lazy IO that's normally found, and loathed in `base`?
21:59:00 <arkeet> (to actually write the instance you'll have to get some appropriate composite, like newtype Compose f g a = C (f (g a))
21:59:08 <startling> AaronFriel, yeah
21:59:28 <kadoban> samba1: Yep that's what it means. If you're pretty clear on the concepts it may be pretty obvious, yeah.
21:59:39 <arkeet> and then instance (Functor f, Functor g) => Functor (Compose f g)
22:00:11 <arkeet> samba1: now answer the same question for Applicative and Monad.
22:00:41 <arkeet> (and Foldable and Traversable, if you like.)
22:00:53 <startling> AaronFriel, https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.IO.Handle.Text.html#lazyRead
22:01:12 <startling> AaronFriel, (used by hGetContents, used by readFile)
22:01:39 <AaronFriel> startling: Thanks for the source link :)
22:05:43 <SrPx> http://lpaste.net/139172 ... 
22:06:28 <SrPx> Is anyone able to replicate that? Not even I expected it.
22:06:47 <SrPx> I was pretty sure with native lists it would be instant too
22:08:36 <AaronFriel> SrPx: Are you sure you're using Int in every function?
22:08:54 <SrPx> AaronFriel: good catch! Let me see
22:09:06 <AaronFriel> I think you're defaulting to Integer in several cases
22:09:11 <AaronFriel> in the first two rather
22:09:15 <AaronFriel> And that will be orders of magnitude slower
22:09:26 <SrPx> Seems like I wasn't, but it only improved slightly 
22:09:47 <SrPx> I'll update the paste when it finishes computing the first one with ints
22:10:35 <SrPx> I even recall trying the "sum [0..x]" example before and it being instant
22:10:43 <SrPx> Oh
22:10:55 <SrPx> > sum ([0..999999999999] :: [Int])
22:11:00 <lambdabot>  mueval: ExitFailure 1
22:11:09 <SrPx> ah
22:12:15 <AaronFriel> Did you run those examples in GHC or GHCi?
22:12:34 <AaronFriel> In the former case, it may optimize one or more case to a constant :P
22:13:04 <SrPx> GHC -O2 only
22:13:24 <SrPx> AaronFriel: yes, the church list is optimized to a constant and the native isn't, I expected the exact opposite
22:13:43 <SrPx> Ah let me try getting an user input
22:15:02 <SrPx> Nope, no constant. Still instant with user inputs
22:15:47 <arkeet> I think your lenumTil and lsum may be rather slow?
22:15:53 <arkeet> they don't match the standard definitions
22:16:42 <SrPx> Possibly, but I'm mainly concerned with the "sum [0..bignum]" issue
22:17:15 <arkeet> sum is not a strict fold
22:17:17 <arkeet> try foldl' (+) 0
22:17:24 <SrPx> I'm tired though, I think I'll just post it on SO, I'm almost sure there is some way to get it to be instant
22:17:34 <SrPx> ah that was it
22:18:13 <SrPx> no it wasn't, same result, my brain is so laggy right now I need to sleep
22:18:24 <arkeet> I dunno then.
22:18:36 <SrPx> > foldl' (+) 0 [0..100000000]
22:18:40 <lambdabot>  mueval-core: Time limit exceeded
22:18:41 <SrPx> same
22:18:46 <SrPx> thanks
22:20:34 <arkeet> are you sure you're not using Integer in the first two
22:22:29 <SrPx> No, but I wrote "print $ foldl' (+) 0 ([0..100000000-1] :: [Int])"
22:22:33 <SrPx> arkeet: is it instant there?
22:23:39 <arkeet> does 1 second count as instant?
22:23:45 <startling> heh
22:24:23 <arkeet> the church one is faster though.
22:25:21 <SrPx> okay that's the same result I got
22:25:30 <SrPx> gtg good night guys
22:25:45 <arkeet> looking at the core I do see that the foldl' one does have an intermediate list
22:25:54 <arkeet> so maybe a lot of time is spent allocating the list or something
22:26:06 <Welkin> @let sumFromOneTo n = n * (n - 1) / 2
22:26:08 <lambdabot>  Defined.
22:26:20 <Welkin> > sumFromOneTo 1000000000
22:26:22 <lambdabot>  4.999999995e17
22:26:30 <Welkin> > sumFromOneTo 10000000000000000000000000000000000000000000000000003464564673467345645645
22:26:31 <lambdabot>  5.0e145
22:26:32 <arkeet> Double is cheating.
22:26:35 <Welkin> :D
22:26:47 <arkeet> try `div` next time.
22:26:51 <SrPx> I'll post on SO in case you/someone wants to investigate 
22:27:47 <Welkin> @let sumFromOneTo n = n * (n - 1) `div` 2
22:27:48 <lambdabot>  .L.hs:242:1: Warning:
22:27:49 <lambdabot>      Pattern match(es) are overlapped
22:27:49 <lambdabot>      In an equation for ‘sumFromOneTo’: sumFromOneTo n = ...
22:27:50 <arkeet> @let also you want n+1.
22:27:50 <lambdabot>  Parse failed: Parse error: EOF
22:27:53 <arkeet> er
22:27:55 <arkeet> no @let
22:28:08 <Welkin> @let sumFromOneTo' n = n * (n - 1) `div` 2
22:28:09 <arkeet> @undefine
22:28:10 <lambdabot>  Defined.
22:28:10 <lambdabot> Undefined.
22:28:12 <arkeet> sorry.
22:28:13 <arkeet> lol
22:28:13 <Welkin> @let sumFromOneTo n = n * (n - 1) `div` 2
22:28:14 <lambdabot>  Defined.
22:28:15 <Welkin> @let sumFromOneTo' n = n * (n - 1) `div` 2
22:28:16 <lambdabot>  Defined.
22:28:24 <Welkin> > sumFromOneTo' 1000000000
22:28:25 <lambdabot>  499999999500000000
22:28:31 <Welkin> > sumFromOneTo' 10000000000000000000000000000000000000000000000000003464564673467345645645
22:28:32 <lambdabot>  5000000000000000000000000000000000000000000000000003464564673467345645644500...
22:28:33 <arkeet> > [sum [1..4], sumFromOneTo 5]
22:28:34 <lambdabot>  [10,10]
22:28:57 <Welkin> oops
22:29:02 <Welkin> @let sumFromOneTo' n = n * (n + 1) `div` 2
22:29:03 <lambdabot>  .L.hs:149:1: Warning:
22:29:03 <lambdabot>      Pattern match(es) are overlapped
22:29:03 <lambdabot>      In an equation for ‘sumFromOneTo'’: sumFromOneTo' n = ...
22:29:11 <Welkin> @undefine
22:29:11 <lambdabot> Undefined.
22:29:13 <Welkin> @let sumFromOneTo' n = n * (n + 1) `div` 2
22:29:14 <lambdabot>  Defined.
22:29:27 <Welkin> @let sumFromOneTo n = n * (n + 1) / 2
22:29:28 <lambdabot>  Defined.
22:29:33 <arkeet> > [sum [1..5], sumFromOneTo' 5]
22:29:35 <lambdabot>  [15,15]
22:29:41 <arkeet> > [sum [1..65535], sumFromOneTo' 65535] :: [Word16]
22:29:42 <lambdabot>  [32768,0]
22:29:45 <arkeet> plsfix
22:30:08 <Welkin> > sumFromOneTo 65535
22:30:09 <lambdabot>  2.14745088e9
22:30:13 <Welkin> fixed
22:30:28 <arkeet> that's not Word16
22:31:03 <Welkin> > fromFractional . sumFromOneTo 65535
22:31:04 <lambdabot>      Not in scope: ‘fromFractional’
22:31:05 <lambdabot>      Perhaps you meant one of these:
22:31:05 <lambdabot>        ‘fromRational’ (imported from Prelude),
22:31:09 <arkeet> > sum [1..65536] :: Int32
22:31:10 <lambdabot>  -2147450880
22:31:11 <arkeet> > sumFromOneTo' 65536 :: Int32
22:31:13 <lambdabot>  32768
22:31:14 <Welkin> > fromRational . sumFromOneTo 65535 :: Word16
22:31:15 <lambdabot>      Couldn't match expected type ‘Word16’
22:31:15 <lambdabot>                  with actual type ‘a0 -> Double’
22:31:15 <lambdabot>      In the expression: fromRational . sumFromOneTo 65535 :: Word16
22:31:16 <arkeet> plsfix
22:31:51 <arkeet> > truncate (sumFromOneTo 65535) :: Word16
22:31:53 <lambdabot>  32768
22:32:02 <arkeet> > truncate (sumFromOneTo 65535) :: Int32
22:32:03 <lambdabot>  2147450880
22:32:10 <arkeet> uh
22:32:15 <arkeet> > truncate (sumFromOneTo 65536) :: Int32
22:32:16 <lambdabot>  -2147450880
22:32:19 <catofhask> Hello, I am in an interesting situation where `read` and `show` doesn't form an isomorphism
22:32:35 <catofhask> bith instances are auto derived
22:33:05 <jle`> oops :|
22:33:13 <jle`> how did this happen?
22:33:42 <Welkin> > round . sumFromOneTo 65535 :: Word16
22:33:43 <lambdabot>      Couldn't match expected type ‘Word16’
22:33:43 <lambdabot>                  with actual type ‘a0 -> Integer’
22:33:43 <lambdabot>      In the expression: round . sumFromOneTo 65535 :: Word16
22:33:59 <arkeet> I don't think you want .
22:34:09 <arkeet> either that or you want more parentheses
22:34:11 <Welkin> > round . sumFromOneTo $ 65535 :: Word16
22:34:12 <lambdabot>  32768
22:34:22 <arkeet> still cheating.
22:34:51 <nshepperd> division doesn't really make sense in Int32
22:34:51 <catofhask> jle`: data UserAction' = ChangeEMail' EMail | ChangeRoles' [UserRole] [UserRole] deriving (Eq,Show, Read,Generic)
22:35:15 <catofhask> > data UserAction' = ChangeEMail' EMail | ChangeRoles' [UserRole] [UserRole] deriving (Eq,Show, Read,Generic)
22:35:16 <lambdabot>  <hint>:1:1: parse error on input ‘data’
22:35:20 <nshepperd> make more sense in Word* as long as the divisor is coprime to 2 though
22:35:21 <catofhask>  data UserAction' = ChangeEMail' EMail | ChangeRoles' [UserRole] [UserRole] deriving (Eq,Show, Read,Generic)
22:35:23 <arkeet> nshepperd: sure it does. it just assumes everything is in the range of Int32
22:35:25 <dramforever> um...
22:35:34 <bycn82> hello,
22:35:36 <arkeet> or Word32
22:35:46 <arkeet> catofhask: use lpaste
22:35:50 <arkeet> @paste
22:35:50 <lambdabot> Haskell pastebin: http://lpaste.net/
22:36:01 <bycn82> i am trying to use haskell with fastcgi, now i am trying to handle the parameters,
22:36:08 <dramforever> @let data UserAction' = ChangeEMail' EMail | ChangeRoles' [UserRole] [UserRole] deriving (Eq,Show, Read,Generic)
22:36:09 <lambdabot>  .L.hs:146:33: Not in scope: type constructor or class ‘EMail’
22:36:09 <lambdabot>  
22:36:09 <lambdabot>  .L.hs:147:34: Not in scope: type constructor or class ‘UserRole’
22:36:14 <dramforever> duh
22:36:37 <liste> bycn82 what parameters?
22:36:51 <catofhask> http://lpaste.net/3860998234134544384
22:36:57 <bycn82> liste: like parameters passing via GET method form
22:37:19 <bycn82> test.fcgi?name=bill
22:37:40 <mauke> query string
22:37:45 <bycn82> liste: e.g. test.fcgi?name=bill,   how can i get the query string
22:38:35 <liste> bycn82 http://hackage.haskell.org/package/cgi-3001.1.8.3/docs/Network-CGI.html#v:getInput
22:38:57 <bycn82> liste: thanks, this is what i am looking for
22:39:36 <mauke> is that for fastcgi?
22:39:46 <liste> they share the API
22:39:49 <liste> cgi and fastcgi
22:40:25 <nshepperd> > let sumTo n = (n `div` 2) + ((n + 1) `div` 2) in sumTo 65535 :: Word16
22:40:27 <lambdabot>  32767
22:40:46 <nshepperd> aww
22:40:55 <arkeet> how is that summing anything?
22:41:28 <nshepperd> oh, whoops
22:41:54 <liste> formula for 1 + 2 + ... + n
22:42:02 <arkeet> liste: look again.
22:42:05 <nshepperd> back to the drawing board
22:42:06 <Welkin> n(n+1)/2
22:42:35 <dramforever> > let sumTo n = n * (n + 1) `div` 2 in sumTo 65545 :: Word16 -- I don't know what you are doing, but it sounds fun
22:42:36 <shachaf> arkeet: It's summing (n `div` 2) and ((n + 1) `div` 2)
22:42:36 <lambdabot>  45
22:43:03 <arkeet> dramforever: 65545 = 9
22:43:05 <nshepperd> lol
22:43:11 <dramforever> hmm...45?
22:43:16 <arkeet> 1 + ... + 9 = 45
22:43:44 <arkeet> Word16 is arithmetic mod 65536
22:43:59 <arkeet> (except for div, who knows what that's about)
22:44:45 <arkeet> I believe 1 carry bit should suffice.
22:45:10 <nshepperd> I think I can rejig this to avoid overflow
22:45:35 <jle`> isn't div like... n = q m + b
22:45:37 * dramforever1 just got disconnected a while ago
22:45:49 <arkeet> jle`: the problem is that in Word16, 65536 `div` 2 = 0
22:45:56 <rcyr> ghcjs it taking forever to compile :/ They should consider shipping binaries
22:46:03 <arkeet> (for 65536 = 0)
22:46:03 <jle`> oops
22:46:23 <nshepperd> > let sumTo n = case divMod n 2 of { (k, b) -> k * (k + b) } in sumTo 65535 :: Word16
22:46:24 <lambdabot>  32768
22:46:32 <nshepperd> yaaay
22:46:38 <jle`> i guess q = 0, r = 0 is a solution
22:46:46 <arkeet> nshepperd: does it work for all other values?
22:46:55 <Welkin> > let sumTo n = w * (w + 1) `div` 2; w = n `mod` 65535 in sumTo 65545 :: Word16
22:46:57 <lambdabot>      Couldn't match expected type ‘Word16’ with actual type ‘Expr’
22:46:57 <lambdabot>      In the expression: sumTo 65545 :: Word16
22:46:57 <lambdabot>      In the expression:
22:46:59 <dramforever> division by an odd number is defined in modulo 65536
22:47:07 <nshepperd> @let sumTo n = case divMod n 2 of { (k, b) -> k * (k + b) }
22:47:08 <lambdabot>  Defined.
22:47:26 <arkeet> nshepperd: ok I think I see it.
22:47:31 <arkeet> good.
22:47:39 <nshepperd> @check (\n -> sumTo n == sum [1..n]) :: Word16 -> Bool
22:47:41 <lambdabot>  *** Failed! Falsifiable (after 1 test):
22:47:41 <lambdabot>  1
22:47:46 <arkeet> bad.
22:47:48 <nshepperd> hahaha
22:47:51 <arkeet> haha
22:47:55 <dramforever> ha
22:48:13 <Welkin> > sumTo 4 :: Word16
22:48:15 <lambdabot>  4
22:48:20 <Welkin> lol
22:48:21 <arkeet> what you want is to divide by 2 whichever is even of n or n+1
22:48:23 <arkeet> and then multiply
22:48:35 <nshepperd> oh
22:48:50 <nshepperd> @undefine
22:48:50 <lambdabot> Undefined.
22:48:55 <arkeet> (except it still breaks for 65535)
22:49:01 <nshepperd> @let sumTo n = case divMod n 2 of { (k, b) -> n * (k + b) }
22:49:02 <lambdabot>  Defined.
22:49:05 <nshepperd> @check (\n -> sumTo n == sum [1..n]) :: Word16 -> Bool
22:49:07 <lambdabot>  *** Failed! Falsifiable (after 4 tests):
22:49:07 <lambdabot>  2
22:49:13 * nshepperd gives up
22:49:19 <Welkin> > let sumTo n = (n `mod` 65535) * ((n `mod` 65535) + 1) `div` 2 in sumTo 65545 :: Word16
22:49:20 <lambdabot>  45
22:49:45 <arkeet> why mod 65535?
22:50:06 <Welkin> @let sum2 n = (n `mod` 65535) * ((n `mod` 65535) + 1) `div` 2 in sumTo 65545 :: Word16
22:50:06 <lambdabot>  Parse failed: Parse error: in
22:50:14 <Welkin> @let sum2 n = (n `mod` 65535) * ((n `mod` 65535) + 1) `div` 2
22:50:15 <lambdabot>  Defined.
22:50:17 <Welkin> for Word16
22:50:26 <Welkin> er
22:50:27 <bycn82> liste: the getInput is a maybe string
22:50:35 <Welkin> @let sum2 n = (n `mod` 65536) * ((n `mod` 65536) + 1) `div` 2
22:50:37 <lambdabot>  .L.hs:148:1: Warning:
22:50:37 <lambdabot>      Pattern match(es) are overlapped
22:50:37 <lambdabot>      In an equation for ‘sum2’: sum2 n = ...
22:50:41 <dramforever> @let dramSumTo n = case n `divMod` 2 of { (q, 0) -> q * (n + 1); _ -> (n+1) `div` 2 * n}
22:50:42 <lambdabot>  Defined.
22:50:44 <Welkin> @let sumToo n = (n `mod` 65536) * ((n `mod` 65536) + 1) `div` 2
22:50:45 <bycn82> liste: getInput :: String -> CGI (Maybe String)
22:50:46 <lambdabot>  Defined.
22:50:58 <bycn82> liste: how can I concat it with string?
22:51:10 <dramforever> @check (\n -> dramSumTo n == sum [1..n]) :: Word16 -> Bool
22:51:13 <lambdabot>  +++ OK, passed 100 tests.
22:51:14 <dramforever> yay
22:51:25 <dramforever> arkeet: you're right
22:51:29 <dramforever> @check (\n -> dramSumTo n == sum [1..n]) :: Word16 -> Bool
22:51:30 <Welkin> @check (\n -> sumToo n == sum [1..n]) :: Word16 -> Bool
22:51:32 <lambdabot>  +++ OK, passed 100 tests.
22:51:34 <lambdabot>  *** Failed! Exception: 'divide by zero' (after 1 test):
22:51:34 <lambdabot>  0
22:51:35 <arkeet> > dramSumTo 65535
22:51:37 <lambdabot>  2147450880
22:51:38 <Welkin> LOL
22:51:40 <arkeet> > dramSumTo 65535 :: Word16
22:51:42 <lambdabot>  0
22:51:44 <arkeet> still broken.
22:51:50 <arkeet> for 65535 + 1 = 0, not 65536
22:51:59 <dramforever> oh that's a problem
22:53:05 <dramforever> @let dramSumTo2 n = case n `divMod` 2 of { (q, 0) -> q * (n + 1); (q, _) -> (q + 1) * n}
22:53:06 <lambdabot>  Defined.
22:53:08 <arkeet> @let sum3 n | r == 0 = q*(n+1) | otherwise = n * ((n-1) `div` 2 + 1) where (q,r) = divMod n 2
22:53:09 <lambdabot>  Defined.
22:53:10 <dramforever> @check (\n -> dramSumTo2 n == sum [1..n]) :: Word16 -> Bool
22:53:10 <Welkin> haha
22:53:13 <lambdabot>  +++ OK, passed 100 tests.
22:53:13 <Welkin> these function names
22:53:20 <dramforever> > dramSumTo2 65535 :: Word16
22:53:21 <lambdabot>  32768
22:53:31 <dramforever> what about this
22:53:34 <arkeet> > all (\n -> sum [0..n] == sum3 n) [0..65535 :: Word16]
22:53:38 <lambdabot>  mueval-core: Time limit exceeded
22:53:42 <arkeet> oh bleh.
22:53:59 <arkeet> > all (\n -> sum [0..n] == sum3 n) ([0..16] ++ [65535] :: [Word16])
22:54:01 <lambdabot>  True
22:54:04 <arkeet> seems ok?
22:54:14 <dramforever> > all (\n -> sum [0..n] == dramSumTo2 n) ([0..16] ++ [65535] :: [Word16])
22:54:16 <lambdabot>  True
22:54:16 <arkeet> I'm just carefully avoiding overflow.
22:54:17 <Welkin> I can haz math?
22:54:21 <Welkin> > sumToo 4
22:54:21 <dramforever> arkeet: seems okay.
22:54:22 <Welkin> :B
22:54:22 <lambdabot>  10
22:54:33 <liste> bycn82 are you familiar with Maybe?
22:54:37 <bycn82> liste: done, fromJust
22:54:38 * dramforever goes for an extensive testing
22:54:40 <Welkin> oh
22:54:42 <Welkin> that is right lol
22:54:56 <bycn82> liste: first time know there is a Maybe
22:55:01 <Welkin> > sumToo 65536
22:55:03 <lambdabot>  0
22:55:05 <Welkin> > sumToo 65535
22:55:07 <lambdabot>  2147450880
22:55:12 <arkeet> > map sum3 [0..65535 :: Word16] == scanl' (+) [0..65535]
22:55:13 <lambdabot>      Couldn't match expected type ‘[Word16]’
22:55:14 <lambdabot>                  with actual type ‘[[t0]] -> [[t0]]’
22:55:14 <lambdabot>      Probable cause: ‘scanl'’ is applied to too few arguments
22:55:25 <arkeet> > map sum3 [0..65535 :: Word16] == scanl1 (+) [0..65535]
22:55:27 <lambdabot>  True
22:55:29 <arkeet> okay.
22:55:35 <arkeet> exhaustive. :-)
22:55:51 <dramforever> good
22:55:52 <dramforever> =)
22:56:21 <dramforever> > map dramSumTo2 [0..65535 :: Word16] == scanl1 (+) [0..65535]
22:56:23 <lambdabot>  True
22:56:27 <dramforever> looks equivalent
22:57:06 <arkeet> nice.
22:57:14 <nitrix> I have a question. Does GHC sort of optimizes as much as possible until there's only thunks left that needs IO to complete the computation?
22:57:22 <arkeet> no.
22:57:32 <nitrix> For example, 1+2+3+x where x is read from getLine, would that get optimized into 6+x ?
22:57:48 <arkeet> maybe.
22:57:48 <dramforever> this one it might
22:58:00 <arkeet> look at core.
22:58:05 <liste> @where learnhaskell -- you might want to take a look at these bycn82
22:58:05 <lambdabot> https://github.com/bitemyapp/learnhaskell
22:58:05 <dramforever> core ++
22:58:20 <dramforever> oh no...
22:58:30 <dramforever> bycn82 went for isJust...
22:58:32 <dramforever> too bad
22:58:45 <liste> well, learning the hard way
22:58:53 <arkeet> isJust is the obvious function Maybe a -> Maybe () ~ Bool
22:59:09 <Welkin> lol
22:59:19 <Welkin> use fromMaybe!
22:59:28 <Welkin> :t fromMaybe
22:59:29 <lambdabot> a -> Maybe a -> a
22:59:32 <arkeet> use pattern matching. or maybe. or fromMaybe.
22:59:42 <arkeet> isJust is ok. fromJust isn't.
23:00:04 <Welkin> catMaybes is great for [Maybe a]
23:00:08 <nitrix> I totally didn't expect ghc-core to be only a 100 lines, ahah.
23:00:12 <nitrix> This is great.
23:00:22 <arkeet> Welkin: sure.
23:00:34 <shachaf> nitrix: I'm long overdue for making it longer. :-(
23:00:47 <Welkin> how can you view core?
23:00:50 <Welkin> what is the flag?
23:00:57 <arkeet> -ddump-simpl
23:01:00 <arkeet> or you can use ghc-core
23:01:51 <dramforever> ...
23:02:00 <dramforever> ghc optimized away my test function
23:02:05 <arkeet> :-)
23:02:19 <bycn82> thanks very much
23:02:52 <dramforever> hmm..looks -O doesn't optimize it
23:03:47 <dramforever> oh I know the problem, too polymorphic
23:05:06 <ttt_fff_> reading https://wiki.haskell.org/IRC_channel/Management#Redirect_bans -- are some #ocaml really #haskell in exile? or is that a joke
23:05:22 <dramforever> horray, with Int -> Int ghc is happy to turn f x = 1 + 2 + 3 + x into \case I# x' -> I# (6 +# x')
23:05:49 <arkeet> mhm
23:06:05 <arkeet> now if you reassociate it: 1 + (2 + (3 + x))
23:06:13 <arkeet> is it still smart enough to know that + is associative?
23:07:09 <dramforever> trying
23:07:43 <dramforever> =( not smart enough
23:07:48 <arkeet> I'm not surprised.
23:07:56 <arkeet> but I was curious anyway
23:08:15 <dramforever> we need something like -ffast-math =P
23:31:05 <jle`> nitrix: that kind of optimization is a little tricky because it can't predict in advance what computations will terminate and what can't
23:31:08 <jle`> in general, at least
23:34:35 <Welkin> jle`: can't Coq do that?
23:35:05 <dramforever> coq doesn't have to because we don't normally care how long a computation will take
23:35:14 <jle`> it can't predict it in general for a succifiently expressive language at least
23:35:31 <dramforever> yep
23:35:32 <jle`> so ghc handles some edge cases where it's obvious it'll terminate, like (1 + 2 + 3 + x)
23:35:34 <kadoban> Welkin: Yes, but in a more restrictive definition of what computation is
23:35:49 <jle`> (1 + 2 + 3), that is
23:36:24 <jle`> but it can't do "as much as possible until there's only thunks left that needs IO to complete"
23:36:38 <jle`> it would be a bit annoying if compilation was potentially non-terminating :p
23:37:53 <rcyr> :( GHCJS is just unusable... Just trying to compile a hello world requires gtk3/webkit/cairo/pango/glib... And the icing on the cake, webkitgtk3 doesn't seem to be available on OSX. That basically means I lost more than a hour setuping something that only really works on Linux :(
23:38:26 <johnw> consider that development time is being spent on making Javascript, not on porting it to platforms the author likely doesn't use
23:39:06 <rcyr> I understand, I'm just a little frustrated :)
23:39:27 <johnw> i appreciate that, but it's still a ways from production quality
23:39:53 <johnw> I think Nix may offer you the best experience at getting it up and running
23:40:02 <johnw> in fact, it may even work on "OS X" there
23:40:17 <rcyr> I might test that tomorrow :)
23:40:24 <rcyr> Else... I could try Purescript
23:45:16 * hackagebot harmony 0.1.1.0 - A web service specification compiler that generates implementation and tests.  https://hackage.haskell.org/package/harmony-0.1.1.0 (SantiMunin)
23:45:58 <mada> where can I see the generated code from a mkPersist call? I think no to/fromJson instances are being generated
23:46:31 <kadoban> mada: -ddump-splices ?
23:46:52 <mada> kadoban: to ghc? trying
23:46:54 <mada> thanks
