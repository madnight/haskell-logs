00:00:04 <srhb> A fast interpreter would be nice.
00:00:10 <kadoban> Yeah, writing stuff in ghci is a mistake IMO. Not really for speed, just because it's tedious. What haskell did you write that sucked in ghci but not when compiled?
00:00:11 <srhb> That much we can all agree on. :-)
00:00:14 <Lokathor> also my fibblist itself was done, apparently, poorly, just using a zipWith
00:00:41 <krakrjak> kadoban: agreed.  When I writed my version of Clicker Heroes, it will bee fast, because it's written in haskell.
00:00:52 <Lokathor> kadoban, i sadly do not have the exact haskell code any more, that was months ago
00:02:05 <lpaste_> Lokathor pasted “euler in lua” at http://lpaste.net/137966
00:03:01 <kadoban> Ah, while loop. Yeah that'll be quick enough.
00:03:52 <srhb> The same solution will be quick enough in Haskell too. ANYWAY, this is silly and peuler is silly. :-)
00:03:55 <Lokathor> though i'm given to understand that ghc can compile things into effectively being while loops... as long as you actually compile them and don't use ghci
00:05:07 <Gurkenglas> Is there a Foldable for which you couldn't make a strict foldMap'?
00:07:39 * hackagebot moesocks 0.1.0.7 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.7 (JinjingWang)
00:07:39 * hackagebot Phsu 0.1.0.3 - Personal Happstack Server Utils  https://hackage.haskell.org/package/Phsu-0.1.0.3 (utkarshl)
00:07:44 <srhb> Lokathor: Yes, that is true. It will transform things into loops when possible. And you can learn to program Haskell in a style that GHC knows how to optimize in this way
00:09:20 <Lokathor> since then i've become quite a bit better than i started, i think
00:09:34 <Lokathor> and i also care very little for raw number crunching most of the time anyway
00:10:41 <srhb> OK. :)
00:11:33 <Lokathor> my next project is likely to involve a bizarre simulator
00:13:38 <Lokathor> whoops, bazaar*
00:38:46 <Gurkenglas> :t \f g -> (f . g .)
00:38:47 <lambdabot>     The operator ‘.’ [infixr 9] of a section
00:38:47 <lambdabot>         must have lower precedence than that of the operand,
00:38:47 <lambdabot>           namely ‘.’ [infixr 9]
00:38:50 <Gurkenglas> Why?
00:44:59 <qedarite> is (f. g .) what you want to do?
00:45:20 <qedarite> I mean, that extra '.'
00:45:55 <srhb> I think the intention is for it to mean \h -> (f . g) . h
00:46:02 <qedarite> somehow, yes
00:46:06 <arkeet> if that is the intention then you must write ((f . g) .)
00:46:20 <srhb> That doesn't answer why, though
00:46:47 <srhb> The answer is something like "the people who wrote the report decided that this would be ambiguous enough that it is disallowed instead of choosing one of the two possible interpretations"
00:47:01 <srhb> Personal guess, of course.
00:47:06 <arkeet> that is my guess too.
00:47:43 <qedarite> "the . operator is said to have a higher right associative precedence than the left associative low precedence of the & operator. The real problem comes from mixing the right and left associative operators, the compiler doesn't know what order to apply them in!"
00:48:01 <qedarite> from a similar problem
00:48:28 <srhb> That's not related.
00:49:14 <Gurkenglas> I was expecting (f .) . (g .), as infixr requires.
00:49:42 <srhb> Okay, that's a third interpretation that I didn't even see.
00:49:53 <srhb> I don't actually see why you would expect that.
00:51:10 <Gurkenglas> infixr dictates \h -> f . g . h be interpreted as \h -> f . (g . h) = (f .) . (g .), not \h -> (f . g) . h = ((f . g) .), which you suggested above
00:53:24 <srhb> Oh, you're right, I didn't see the equivalence to f . (g . h)
01:19:53 <shachaf> > run $ plus minus minus plus minus plus
01:19:55 <lambdabot>  "+--+-+"
01:25:29 <shachaf> Can I use OverloadedLists tricks to support [] there?
01:25:51 <shachaf> > run $ L.loop (plus minus plus) minus plus
01:25:53 <lambdabot>  "[+-+]-+"
01:26:11 <shachaf> (That looks like it works but it doesn't actually.)
01:29:13 <lf94> I never thought about this but I guess Haskell has some sort of introspection right?
01:29:20 <lf94> (For types and whanot)
01:31:21 <srhb> lf94: Not sure quite what you mean, but there's Template Haskell.
01:31:34 <srhb> Mostly for generating Haskell.
01:31:40 <srhb> (only?)
01:31:53 <mikeplus64> might mean GHC.Generics / Typeable / Data
01:32:02 <srhb> Yeah, that's the view part.
01:32:26 <quicksilver> lf94: not really, because it's really not like that
01:32:39 <quicksilver> types are checked and therefore fixed at compile time
01:32:45 <quicksilver> and compilers may (and GHC does) erase them.
01:33:12 <quicksilver> however, the kinds of things which you might use introspection for can be done with the things that srhb and mikeplus64 just mentioned.
01:33:27 <quicksilver> in many cases there is a 'better way' which doesn't involve any of that though.
01:54:14 <m00nlight> Does any haskellers know whether stylish-haskell can be configured to align "=" of functions, where clauses and let bindings?
01:58:46 <quchen2> m00nlight: Doesn't it only do import formatting?
02:05:48 <m00nlight> quchen2 : also for records and type. But I can not find align for equal. 
02:14:05 <lf94> How could I improve this guys? https://gist.github.com/8e0e51c2c476f3d09053
02:34:40 <quicksilver> personally I don't like your strange encoding of (Bool,Bool) for game-over state
02:35:04 <quicksilver> I would either use Maybe Bool (interpreting Nothing as game continues, Just x as win or loss depending on x)
02:35:20 <quicksilver> or I'd make a type data GameState = Running | Won | Lost
02:36:27 <quicksilver> it's not a very important point especially in a program that small.
02:37:14 <quicksilver> and I wouldn't use a guard in the defintion of toHoleyString
02:37:19 <quicksilver> I'd just use 2 equations
02:37:39 * hackagebot MyPrimes 0.1.0.0 - Generate all primes  https://hackage.haskell.org/package/MyPrimes-0.1.0.0 (afonsomatos)
02:38:05 <Gurkenglas> Using Either Bool (Int, Int) would allow you to move the factor out the looper's recursion, which is always a refactoring I like to do
02:38:12 <hvr> com eon
02:38:15 <hvr> come on
02:38:18 <hvr> MyPrimes, seriously?
02:38:20 <catgocat> What are those comments are build up the documentation in hackage?
02:38:23 <hvr> http://hackage.haskell.org/package/MyPrimes-0.1.0.0/src/src/Data/List/Primes.hs
02:38:35 <quicksilver> catgocat: haddock
02:38:43 <catgocat> hvr: that's mine, just for testing
02:38:55 <lf94> quicksilver, yeah, I agree with the (Bool,Bool) it was an after thought.
02:39:00 <catgocat> quicksilver: is haddock enabled by default?
02:39:08 <lf94> quicksilver, what do you mean use 2 equations?
02:39:27 <quicksilver> lf94: toHoleyString (c,True) = c
02:39:30 <lf94> quchen2, if...else ?
02:39:32 <lf94> oh!
02:39:32 <hvr> catgocat: I'm a bit on the fence about spamming Hackage w/ test-packages ;)
02:39:35 <quicksilver> toHoleyString (_,False) = '-'
02:39:37 <lf94> quicksilver, *
02:39:38 <quicksilver> sorry _
02:39:40 <lf94> I understand now
02:39:43 <lf94> Yeah yeah X)
02:39:45 <hvr> catgocat: they add noise to maintainance overhead
02:39:45 <catgocat> hvr: I'll delete them later
02:39:52 <lf94> Why would you use that over what I have though?
02:39:57 <hvr> catgocat: that's the thing.. you can't delete a package
02:40:01 <catgocat> what
02:40:07 <lf94> Gurkenglas, "move the factor out" ?
02:40:16 <quicksilver> lf94: it's clearer to me. That's a subjective point.
02:40:22 <lf94> quicksilver, ah.
02:40:23 <catgocat> :/
02:40:25 <hvr> catgocat: Hackage is a persistent-datastructure in this respect
02:40:38 <quicksilver> well what you have now is perfectly clear. My version I would be able to read more quickly though.
02:40:54 <hvr> catgocat: just imagine the havoc it would create if packages started to disappear from hackage, while people have started dependning on them
02:41:08 <hvr> catgocat: you'd instantly break install-plans all over Hackage (and outside Hackage)
02:41:10 <lf94> quicksilver, no I agree it is clearer your way to be honest.
02:41:13 <catgocat> npm allows for deleting
02:41:24 <catgocat> (nodejs package management)
02:41:28 <Gurkenglas> Sorry, -"move the"
02:41:34 <hvr> catgocat: I'm not sure nodejs is a good model for Hackage to follow :)
02:41:45 <catgocat> hvr: you mean npm
02:41:48 <hvr> yeah
02:42:06 <catgocat> ok
02:42:11 <lf94> Gurkenglas, I sort of still don't understand what you're saying lol
02:42:28 <quicksilver> lf94: also I wouldn't have where clauses consistenting entirely of "where a = fst b" type statements
02:42:34 <Gurkenglas> Let me write up a commit
02:42:37 <quicksilver> lf94: I'd just pattern match the tuple directly
02:42:41 <hvr> catgocat: the best you can do is 'deprecate' a package as a whole to make it a bit less discoverable 
02:42:53 <catgocat> Is haddock enabled by default?
02:43:09 <lf94> quicksilver, it makes things a little more readable I find. I actually did pattern match at firstn.
02:43:11 <srhb> lf94: Use the loose syntax rules to line up similar sections. names in where clauses, ends of guards etc.
02:43:15 <hvr> catgocat: yes, but it takes a while till the doc-builder processes your package
02:43:37 <hvr> catgocat: there's quite a work-queue the doc-builder needs to proces
02:43:56 <catgocat> I see that in the hackage package, there is a list of files where the person can click and check the source / documentation. But in my package, those links are not "clickable"
02:43:57 <srhb> lf94: And the consensus is to write IO (), not IO()
02:44:05 <catgocat> How can I get around this?
02:44:29 <merijn> catgocat: Takes a while to generate docs, but you can also manually upload docs
02:44:48 <merijn> catgocat: See this blogpost (and the other post + script linked inside) http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
02:45:39 <lf94> srhb, what do you mean "names in where clauses, ends of guards"
02:45:50 <hvr> catgocat: they become clickable when the docs have been built... it just takes a while
02:46:15 <hvr> catgocat: also, if you want to experiment there's http://hackage.haskell.org/packages/candidates/upload
02:46:30 <srhb> lf94: for instance in | b = c | otherwise = '_' -- I would align the equal signs. Ie after the guard
02:46:36 <catgocat> hvr: ok, but there is no haddock comments in my code yet
02:46:44 <lf94> srhb, oh right
02:46:59 <lf94> Would something like hlint catch that?
02:47:00 <hvr> catgocat: candidates allow you to preview the effect of package uploads 
02:47:21 <breadmonster> Hello everyone.
02:47:48 <catgocat> hvr: but they don't show docs do they?
02:47:57 <catgocat> the links are not clickable there either
02:48:01 <merijn> catgocat: Just type signatures and functions
02:48:04 <lf94> I'm surprised though, I thought there'd be a lot more criticism. Pretty impressed with myself.
02:48:04 <srhb> lf94: Nope.
02:48:09 <quicksilver> you can simply run haddock yourself if you wish to see your docs.
02:48:10 <merijn> catgocat: If you don't have haddock comments
02:48:11 <hvr> catgocat: it takes up to 30 minutes
02:48:18 <srhb> lf94: also in case statements, align the ->s
02:48:26 <catgocat> hvr: still with the candidates? or just with the normal upload?
02:48:47 <hvr> catgocat: both, they're handled by the same doc-builders
02:48:52 <lf94> srhb, emacs haskell mode doesnt like me tabbing those = signs in guards :/
02:48:52 <merijn> lf94: FYI aligning = and -> is a matter of taste, I only do it sometimes
02:49:05 <srhb> lf94: No, it's not very impressive.
02:49:24 <srhb> And yes, all I'm saying now is stylistic advice.
02:49:26 <lf94> Oh boy it's really bad with ->
02:49:36 <quicksilver> M-x align-regexp
02:49:41 <srhb> quicksilver++
02:49:45 <srhb> Best thing ever.
02:49:51 <merijn> lf94: I'd add some blank lines in the longer do blocks
02:50:06 <merijn> Preferably grouping them in logically related lines
02:50:21 <merijn> I find code clearer to read without dense blobs of text
02:51:00 <lf94> What should this align regexp be :s
02:51:04 <quicksilver> whereas I dislike all wasted vertical space
02:51:10 <quicksilver> just goes to show you can't please everyone :)
02:51:31 <lf94> So you guys really have no other criticism to how the code works?
02:51:38 <quicksilver> merijn: does your IRC client insert blank lines in between different people's remarks?
02:51:41 * quicksilver ducks
02:51:51 <lf94> Like "oh this game could be represented as a Monad"
02:52:01 <lf94> (Just saying something silly like that)
02:52:03 <merijn> lf94: To be fair I didn't look very deeply into the implementation because I only just logged on and am lazy :p
02:52:44 <breadmonster> Hello, merijn 
02:52:49 <srhb> lf94: Sure, it seems like a State monad would be useful, among others
02:52:59 <srhb> lf94: Thought we were just giving stylistic advice :P
02:52:59 <merijn> I'd maybe use "StateT GameState IO" to implement the loop
02:53:13 <merijn> Speaking of stylistic advice
02:53:16 <srhb> Agreed.
02:53:18 <quicksilver> lf94: it's a small toy program. It is probably not large enough to meet the cost/benefit of more complex abstractions.
02:53:31 <quicksilver> using a state monad for it might be instructive, at least
02:53:39 <lf94> I'd like to know what I could do though, so I know for when I do encounter larger programs :)
02:53:41 <srhb> lf94: I commented with my stylistic changes
02:53:42 <quicksilver> but wouldn't make the code shorter or easier to read, I suspect.
02:53:47 <lf94> I'll look up State monad
02:53:53 <merijn> Personal opinion: I'd prefer replacing things like line 21s "fmap (checkGuess userChar) word" with "checkGuess userChar <$> word"
02:53:56 <srhb> State monad is the most fun monad to implement :-)
02:54:22 <lf94> is that a sarcastic face
02:54:24 <lf94> X)
02:54:25 <merijn> Yeah, I recommend implementing State and StateT as an exercise
02:54:39 <merijn> lf94: No, it's one of the most enlightening exercises on monad transformers
02:54:48 <lf94> Alright here I go
02:54:55 <merijn> lf94: I recommend it so often I've already gotten a skeleton written down: https://gist.github.com/merijn/098106abd45c940dab09 :)
02:55:15 <srhb> lf94: Oh, me? No, no sarcasm at all. It's non-trivial but really, really interesting. And you mind goes WOW. :-)
02:55:45 <srhb> (Well, it's not HARD either. It just took me a long time, back then...)
02:56:02 <breadmonster> Is there a good reader monad tutorial?
02:56:40 <quicksilver> I haven't read something I cnosider to be a 'good' reader monad tutorial
02:56:44 <quicksilver> https://wiki.haskell.org/All_About_Monads
02:57:17 <merijn> breadmonster: Reader is basically State without the ability to modify, I'd say that if you work out State by hand and then stare at the definition of Reader it should make sense after some meditation
02:57:27 <quicksilver> part II of that (starting frmo section 7) gives motivations for the common monads which seemed useful to me.
02:57:36 <srhb> Typeclassopedia makes most of it make sense, imo.
02:57:50 <breadmonster> merijn: State only took a few minutes to figure out.
02:57:55 <Gurkenglas> Is (Monad m, Monad n) => (a -> m (n b)) -> m (n a) -> m (n b) realizable?
02:58:02 <breadmonster> merijn: what's the Reader definition?
02:58:39 <Cale> Gurkenglas: nope
02:58:43 <Cale> er
02:58:47 <Cale> yeah, nope
02:59:17 <Cale> You can get m (n (m (n b))) of course
02:59:31 <srhb> Lack of join is the problem, I guess
02:59:38 <Cale> But without a way to interchange n (m t) -> m (n t) there's no way to join
02:59:42 <breadmonster> Cale: How did you figure that out?
02:59:56 <merijn> breadmonster: "newtype Reader r a = Reader (r -> a)" vs "newtype State s a = State (s -> (a, s))"
03:02:00 <Cale> breadmonster: It's for much the same reason that the composite of two monads is not a monad.
03:02:04 <Gurkenglas> Is it expected that ExceptT's Left not be used for ordinary value transport? If so, what monad transformer should I use for the useful properties of the Either monad?
03:02:05 <breadmonster> merijn: So `fmap f (Reader ra) = Reader $ \r -> f . ra`?
03:02:40 <breadmonster> :t (>>=)
03:02:41 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:02:44 <Cale> Gurkenglas: You can use it for whatever you want, obviously.
03:02:52 <srhb> breadmonster: The first argument tells us that we can produce m (n (m (n b))). Collapsing m (m a) to m a is a monad property, but since m /~ n we don't have join. -- is my thought. Much less rigorous than what Cale thought I'm sure :-)
03:03:10 <Gurkenglas> https://hackage.haskell.org/package/transformers-0.4.2.0/docs/Control-Monad-Trans-Except.html just says "exceptions", which made me think people would think what I throw are exceptions.
03:03:59 <ocharles__> does anyone know any prior discussions of adding an extension to GHC to support "foo = ... where import Control.Applicative" is valid syntax?
03:04:10 <Cale> Gurkenglas: There's no requirement on what type e is.
03:04:12 <ocharles__> (it would import Control.Applicative into the scope of 'foo' and its other where bindings)
03:04:34 <ocharles__> searching "haskell cafe scoped imports" and "local imports" on google isn't bringing up anything useful
03:04:43 <quicksilver> Cale: there is probably a theory of commutable monads out there
03:05:02 <quicksilver> different instances of (->)r commute, for example
03:05:02 <Cale> quicksilver: There's the notion of a distributive law for two monads
03:05:10 <quicksilver> that's what I meant I think
03:05:15 <Cale> https://en.wikipedia.org/wiki/Distributive_law_between_monads
03:05:30 <quicksilver> distributive laws are commutative laws when looked at in a different notational style
03:05:56 <quicksilver> yes, that is what I meant. Thanks.
03:05:57 <Cale> Well, yeah, the reason for the name "distributive law" has to do with one particular canonical example...
03:08:14 <Gurkenglas> What's to ExceptT as MonadReader is to ReaderT?
03:09:17 <Cale> Which is, when you take the monad for Abelian groups S (which you think of as sums of elements and their negations) and the monad for monoids T (the list monad, thought of as products of elements), there's a mapping TS -> ST which takes a product of sums and turns it into a sum of products in the usual way
03:09:19 <srhb> Hmm. MonadError?
03:09:27 <Cale> and ST becomes the monad for rings
03:09:37 <Cale> (i.e. the monad whose algebras are all rings)
03:09:51 <quicksilver> Cale: *nod*
03:09:58 <catgocat> When I do cabal install _______ where does the package go?
03:10:04 <catgocat> how can I delete packages?
03:10:08 <srhb> catgocat: Usually ~/.ghc I think
03:10:46 <tdammers> you can't really delete packages
03:10:54 <catgocat> srhb: they're not in ~/.ghc
03:10:57 <tdammers> you can unregister them
03:11:00 <Cale> catgocat: The record of the package being installed goes in ~/.ghc while a lot of the actual content (that doesn't hurt anything just sitting there) goes to ~/.cabal
03:11:05 <tdammers> or you can wipe ~/.ghc and ~/.cabal
03:11:17 <Cale> You don't generally have to wipe ~/.cabal
03:11:21 <quicksilver> it also works to burn your computer in a fire and buy a new one
03:11:25 <tdammers> but then you delete *everything* except what's installed globally
03:11:27 <srhb> catgocat: ghc-pkg unregister, for the record
03:11:27 <catgocat> C:\Users\afons\AppData\Roaming\cabal\packages\hackage.haskell.org
03:11:29 <Cale> You'd only need to do so if you're low on disk space
03:11:35 <tdammers> right
03:11:49 <srhb> Roaming?
03:11:52 <srhb> Nevermind, I don't want to know...
03:12:17 <tdammers> but generally, people use sandboxes for this exact reason
03:12:39 <tdammers> because then you can simply wipe the sandbox and start from scratch when things go bonkers
03:13:05 <Cale> You can use ghc-pkg unregister <packagename> to unregister a package, and if you really care, you can go through ~/.cabal and delete its individual files if you want to.
03:13:21 <Cale> But the first step is enough to make ghc forget it exists
03:13:28 <ocharles__> Gurkenglas: MonadError and MonadPlus are probably what you are looking for
03:13:58 <Cale> I usually just wait until I have a new GHC and then clean up the stuff in ~/.cabal related to old versions of GHC
03:14:45 <Cale> You might not want to delete ~/.cabal/config or ~/.cabal/bin for instance, which is why I wouldn't recommend just deleting the directory altogether.
03:15:23 <Cale> (probably your cabal binary is in ~/.cabal/bin after all, so if you blow that away, you'll have to reinstall it)
03:15:32 <Gurkenglas> "throwError"... this is just gonna confuse everyone.
03:19:21 <tdammers> ah, yes
03:19:36 <tdammers> wiping ~/.cabal means you have to reinstall cabal itself
03:19:42 <Gurkenglas> Maybe I can just rename it all locally? Is there something that is to classes as "type" is to types?
03:19:53 <jle`> Gurkenglas: that depends on what you think the relationship between MonadReader and ReaderT is :)
03:19:59 <pacak> tdammers: ~/.cabal contains only installed packages and package cache
03:20:09 <tdammers> I have haskell-platform installed globally, so I always have a working cabal to fall back on
03:20:35 <tdammers> pacak: normally the cabal I use is in ~/.cabal/bin, because I use cabal install cabal-install to get the latest version
03:20:55 <catgocat> I am trying to use the C preprocessor. I added `extensions: CPP` to the top of my cabal file, and then used `#define PI 3.14` (for testing) inside my benchmark file.
03:20:55 <tdammers> deleting ~/.cabal throws me back to the cabal binary installed with apt-get or from the platform tarball
03:21:06 <catgocat> However, it seems it doesn't recognize the preprocessor, because I get a syntax error.
03:21:29 <tdammers> I think you also need to -XCPP or {-#LANGUAGE CPP#-}
03:21:31 <pacak> catgocat: Try {-# LANGUAGE CPP #-}
03:21:46 <catgocat> I already have one LANGUAGE BangPatterns
03:22:00 <tdammers> you can have more than one
03:22:04 <catgocat> space or comma ?
03:22:12 <pacak> catgocat: comma
03:22:15 <jle`> you can put multiple pragmas on different lines, too
03:22:18 <tdammers> comma, but I prefer separate {-#LANGUAGE #-} lines
03:22:20 <pacak> You can have several language pragrams as well
03:22:21 <catgocat> do I need to write Language again ?
03:22:31 <jle`> {-# LANGUAGE CPP #-}
03:22:35 <tdammers> if you put them in separate pragmas, yes; if you use commas, no
03:22:36 <jle`> {-# LANGUAGE BangPatterns #-}
03:22:37 <jle`> etc.
03:22:40 <catgocat> {-# LANGUAGE BangPatterns, LANGUAGE CPP #-}
03:22:45 <catgocat> like this?
03:22:46 <tdammers> no
03:22:55 <pacak> {-# LANGUAGE BangPatterns,  CPP #-}
03:22:57 <tdammers> {-# LANGUAGE BangPatterns, CPP #-}
03:23:08 <breadmonster> Is BangPatterns any different from using seq in the appropriate places?
03:23:14 <breadmonster> Will it unbox integers?
03:23:15 <jle`> i think yeah, normally people prefer multiple pragmas with one extension each
03:23:23 <tdammers> yeah
03:23:32 <tdammers> multiple pragmas is nicer with diff and such
03:23:47 <lush> hi)
03:23:50 <catgocat> it works
03:23:50 <catgocat> thanks
03:24:56 <breadmonster> Is there anywhere I can get a working ghci prompt online?
03:25:15 <jle`> breadmonster: tryhaskell?
03:25:17 <breadmonster> I'd like to see how strictness works.
03:25:29 <breadmonster> jle`: CAn I get it to time computations?
03:25:32 <srhb> breadmonster: ostensibly ghc.io
03:25:42 <jle`> breadmonster: btw, GHC manual seems to imply that it's the same as seq-ing
03:25:44 <tdammers> for some use cases, lambdabot
03:25:48 <jle`> https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/bang-patterns.html
03:25:57 <tdammers> probably not this one though
03:26:00 <quicksilver> yes bang patterns are just syntax for seq
03:26:16 <quicksilver> in some cases the compiler may be able to unbox
03:26:57 <breadmonster> in particular are `foldl' (+) 0 [1..1000]` and `foldl (\ !x !y -> x + y) 0 [1..1000]` the same?
03:27:24 <quicksilver> I don't imagine so
03:27:41 * hackagebot creatur 5.9.8 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.8 (AmyDeBuitleir)
03:27:42 <breadmonster> Will it unbox the seqs in the latter?
03:27:46 <quicksilver> (+) is already strict in both arguments
03:28:15 <quicksilver> foldl' and foldl are different functions with different definitions
03:28:19 <breadmonster> quicksilver: If (+) is strict, why does the foldl result in a stackoverflow?
03:28:29 <jle`> yeah, for most instances of Num, (\x y -> x + y) and ( !x !y -> x + y) are identical
03:28:34 <quicksilver> because the strictness of + isn't the problem :P
03:28:48 <quicksilver> it's the evaluation strategy of the foldl
03:29:03 <quicksilver> pretty sure foldl (+) [1..1000] isn't a stackoverflow anyway
03:29:10 <quicksilver> > foldl (+) [1..1000]
03:29:12 <lambdabot>      No instance for (Typeable t0)
03:29:12 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
03:29:12 <lambdabot>        arising from a use of ‘show_M52843530302054933198074’
03:29:19 <Gurkenglas> Ah well, I'll just write a boilerplate function that I wanted to use monad transformers to avoid.
03:29:22 <quicksilver> > foldl (+) 0 [1..1000]
03:29:24 <lambdabot>  500500
03:30:00 <breadmonster> quicksilver: You get my point...
03:30:13 <breadmonster> > foldl (+) 0 [1..1000000[
03:30:14 <lambdabot>  <hint>:1:25:
03:30:15 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
03:30:38 <quicksilver> breadmonster: I do get your point. As I say, reason for potential problems with foldl is not whether the binary operation is strict
03:30:39 <jle`> the strictness of (+) isn't what causes the memory leak here
03:30:55 <quicksilver> it's the fact that the accumulator is never forced so it builds up a huge thunk
03:30:56 <jle`> (+) being strict means that when you want to evaluate x + y, you have to evaluate both x and y
03:31:02 <jle`> but that doesn't mean anything if you never evaluate x + y
03:31:02 <quicksilver> and that's what foldl' does differently
03:31:36 <jle`> when you evaluate `const (sum [1..]) 0`, you have to evaluate sum [1..].  but if you never evaluate it, then you don't evaluate sum [1..]
03:31:52 <srhb> quicksilver: Yes, foldl' forces the accumulator at each step.
03:32:01 <srhb> oh
03:32:05 <srhb> That wasn't a question :-)
03:32:23 <breadmonster> One second, why do people make record fields containing integers strict then?
03:32:41 * hackagebot moesocks 0.1.0.8 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.8 (JinjingWang)
03:32:47 <jle`> so that evaluating the constructor forces the evaluation of the integer
03:32:48 <quicksilver> so those fields don't get huge thunks in them
03:33:05 <breadmonster> quicksilver: And the reason this doesn't apply to foldl is?
03:33:35 <quicksilver> because you're not talking about a record field, you're talking about the evaluation of a function?
03:33:35 <jle`> breadmonster: (x + y) is strict on x + y, which means that when you evaluate (x + y), then x and y are resolved
03:33:47 <jle`> breadmonster: but with foldl, (x + y) is never even evaluated
03:33:52 <jle`> so neither x nor y is evaluated
03:34:06 <jle`> even if (+) is strict
03:34:28 <jle`> *never as in, deferred way later
03:35:05 <jle`> @src foldl
03:35:05 <lambdabot> foldl f z []     = z
03:35:05 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
03:35:23 <jle`> > foldl (+) 0 [1..3] :: Expr
03:35:25 <lambdabot>  0 + 1 + 2 + 3
03:36:09 <jle`> that evaluates to (((0 + 1) + 2) + 3), and *then* it starts reducing
03:36:40 <jle`> first it reduces ((0 + 1) + 2) + 3, which forces the 3, and forces the (0 + 1) + 2
03:36:53 <jle`> in the process of forcing the (0 + 1) + 2, it forces the 2, and then forces the (0 + 1)
03:37:15 <jle`> in the process of forcing 0 + 1, it forces 0 and 1, and then that's all the evaluation/forcing that happens
03:37:25 <jle`> but the key is that the structure is built up before any forcing ever begins
03:37:37 <breadmonster> jle`: What if I do something strange...like this `data StrictInt = StrictInt !Int; instance Num StrictInt where ...; foldl' (+) (0 :: StrictInt) [1..1000]`?
03:37:47 <jle`> so if your structure is sufficiently large, it's not hard to imagine overflowing the memory of the machine
03:38:00 <jle`> do you mean foldl ?
03:38:23 <breadmonster> Yeah foldl.
03:38:25 <breadmonster> Sorry.
03:38:33 <jle`> we can just work it out from the definition of foldl
03:38:55 <jle`> remember that (x + y), where x and y are StrictInt's, doesn't evaluate anything if you never evaluate it
03:39:02 <breadmonster> We can make the accumulator strict.
03:39:04 <jle`> if i wrote z = sum [1..] + sum [1..]
03:39:06 <breadmonster> Oh right.
03:39:10 <jle`> and i never evaluate z
03:39:16 <jle`> then sum [1..] is never evaluated
03:39:17 <jle`> check it out
03:39:26 <jle`> @let z = sum [1..] + sum [1..]
03:39:28 <lambdabot>  Defined.
03:39:31 <jle`> sorry for redefining z
03:39:32 <jle`> @undefine
03:39:32 <lambdabot> Undefined.
03:39:41 <jle`> but yeah, the definition doesn't crash any computers
03:39:53 <jle`> z can be defined, but if z is never evaluated, x and y are never evaluated
03:40:03 <breadmonster> Yeah, I know that.
03:40:07 <jle`> x and y get evaluated when z becomes evaluated
03:40:10 <jle`> so it's the same deal here
03:40:45 <jle`> @let result = foldl (+) 0 [1..10000000]
03:40:46 <lambdabot>  Defined.
03:40:59 <quicksilver> there is nothing inherently 'non-string' about the basic Int type and your StrictInt type is no "stricter". In fact it's not very different at all.
03:41:06 <quicksilver> s/string/strict/
03:41:09 <jle`> result is defined, but evaluation hasn't started yet
03:41:12 <jle`> we haven't tried evaluating anything
03:42:00 <jle`> just becuase Int and (+) are "strict", doesn't mean that the components get evaluated before the result is demanded
03:42:54 <breadmonster> @src foldl'
03:42:54 <lambdabot> foldl' f a []     = a
03:42:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:43:15 <jle`> we can evaluate result by hand by expanding out the definition of foldl following the evaluation semantics, and we see why things get hairy
03:43:27 <breadmonster> jle`: Yeah I got that bit.
03:43:34 <jle`> foldl (+) 0 [1..10000000] = foldl (+) (0 + 1) [2..1000000]
03:43:44 <jle`> but we don't evaluate (0 + 1) into 1, because we never ask for the result
03:43:54 <jle`> we never ask for (0 + 1)'s result, so we leave it as (0 + 1)
03:44:03 <quicksilver> (that remark is independent of the defitino of 0,1 and +)
03:44:13 <jle`> = foldl (+) ((0 + 1) + 2) [3..1000000]
03:44:15 <breadmonster> quicksilver: Yeah, I got that.
03:44:21 <breadmonster> jle`: Finally it clicked thanks a ton.
03:44:24 <jle`> = foldl (+) (((0 + 1) + 2) + 3) [4..10000000]
03:44:46 <jle`> we never ask for (((0 + 1) + 2) + 3), so ((0 + 1) + 2) is never evaluated, so (0 + 1) is never evaluated
03:45:07 <jle`> = foldl (+) ((((0 + 1) + 2) + 3) + 4) [5..100000000]
03:45:08 <breadmonster> Except this brings me to the other big question.
03:45:36 <jle`> again we never ask for ((((0 + 1) + 2) + 3) + 4), so we never ask for (((0 + 1) + 2) + 3), so we never ask for ((0 + 1) + 2), so we never ask for 0 + 1, etc.
03:45:41 <jle`> the only time we ask for anything is at the very end
03:45:49 <breadmonster> How do I know where to annotate with seq?
03:45:58 <Gurkenglas> Due to difficulties I'm having with github gists and commits and pull requests, here instead is an lpaste of my changes to lf94's code: http://lpaste.net/137971
03:46:07 <jle`> breadmonster: do you know what seq does?
03:46:56 <Gurkenglas> (The boilerplate function is the sort usually avoided using monad transformers, but if you've been reading my last few lines, you'll see I had difficulty with that this time.)
03:47:20 <hackrilege> :t intersperse (`seq`)
03:47:21 <lambdabot> parse error on input ‘)’
03:47:30 <hackrilege> :t intersperse seq
03:47:32 <lambdabot> [a -> b -> b] -> [a -> b -> b]
03:47:42 * hackagebot warp 3.1.2 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.2 (MichaelSnoyman)
03:47:44 * hackagebot microlens-th 0.2.0.0 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.2.0.0 (Artyom)
03:48:07 <hackrilege> :t foldl1 (\f-> seq f)
03:48:08 <lambdabot> Foldable t => t a -> a
03:48:33 <Gurkenglas> (I'll welcome anyone to show me how to get rid of that boilerplate function without throwing "error" names everywhere.)
03:50:40 <hackrilege> Gurkenglas, which function?
03:50:45 <jle`> Gurkenglas: it might be nice to separate out stepper into the actual stepping part and the IO part
03:50:59 <Gurkenglas> hackrilege, loop.
03:51:13 <hackrilege> k
03:52:20 <breadmonster> jle`: It serves as a strictness annotation.
03:53:18 <jle`> that's a bit of a hand-wavey explanation, heh.  what does that even mean?
03:53:36 <jle`> is (\x -> x `seq` x) any different than id?
03:54:15 <hackrilege> :t seq
03:54:16 <lambdabot> a -> b -> b
03:55:12 <srhb> breadmonster: On the "how to know" -- you generally build up thunks on recursive calls, so the idea is to force that thunk before/when doing the recursion.
03:55:21 <srhb> breadmonster: There are probably other examples, but that one is typical.
03:55:25 <jle`> Gurkenglas: loop = iterateM_, but if you used EitherT e m s instead of m (EIther e s)
03:55:32 <jle`> so it's a newtype unwrapping sorta deal
03:55:39 <hackrilege> Gurkenglas, its throwing errors about Either not being IO...
03:55:42 <quicksilver> srhb: ...unless the object being built up is a complex data structure which can be consumed incrementally, in which case that's fine.
03:55:44 <ocharles__> jle`: was that a question for us?
03:55:44 <jle`> (EitherT e m s is just a newtype wrapper over m (EIther e s))
03:55:57 <jle`> ocharles__: oh it was a question for breadmonster who is asking about seq
03:56:00 <ocharles__> ah, right
03:56:02 <quicksilver> ocharles__: I think it was directed at breadmonster as student in this instance :)
03:56:05 <Gurkenglas> Whoopsies.
03:56:08 <ocharles__> i thought so, was just checking :)
03:56:18 <srhb> quicksilver: Oh, yes, I did not mean to imply that this is always a necessary or even desirable thing to do. :) Thanks.
03:56:21 <Gurkenglas> Still?
03:56:25 <Gurkenglas> (hackrilege)
03:56:42 <quicksilver> srhb: but perhaps the hard part is knowing which.
03:56:55 <srhb> Yes, personally I find I often realize post-hoc that I need more strictness.
03:57:01 <Gurkenglas> (Not my code, I just separated something into loop and stepper.)
03:57:07 <jle`> breadmonster: `seq x y` means "when you evaluate y, also evaluate x" (to WNHF, which for Int, is a full evaluation).  so (\x -> seq x x) means, "this is id, but when you evaluate the result (x), also evaluate (x)".  but this is redundant
03:57:12 <mpickering> anyone know why stack tries to use ghc-7.10.1 when 7.10.2 is in my path?
03:57:21 <jle`> of course when you evaluate x, x is evaluated anyway :P
03:57:21 <srhb> In the case of folds I know that I absolutely need it iff the binary combinator is strict in its rhs argument
03:57:59 <hackrilege> Gurkenglas: any chace of a smaller paste?
03:58:13 <jle`> breadmonster: if you think through what `seq` actually *means*, then seeing what it does and when you need it becomes a little less magical
03:58:17 <jle`> just a little, though, heh
03:58:27 <AndChat194889> Yo motherfuckera
03:58:29 <Gurkenglas> Sure. hackrilege, http://lpaste.net/137973
03:58:42 <AndChat194889> Ehatafuck is it ?
03:59:02 <hackrilege> get back to the ghetto g
03:59:03 <AndChat194889> Somebody from brazil
03:59:05 <AndChat194889> ?
03:59:07 <merijn> jle`: I would be more pedantic and say that "seq x y" means "IF neither 'x' nor 'y' are bottom, then at the end of evaluating "seq x y", both 'x' and 'y' will have been evaluated"
03:59:21 <merijn> jle`: Since seq guarantees no specific ordering on evaluation
04:00:11 <jle`> i tried to avoid language regarding ordering, but i think that might be a less ambiguous statement, thanks :)
04:00:24 <hackrilege> Gurkenglas: this one throws no errors...
04:00:45 <AndChat194889> Bro, what are u trying tô do ?
04:00:51 <AndChat194889> Can I help u ?
04:00:51 <breadmonster> merijn: So do I just liberally pepper my code with seq statements?
04:00:55 <srhb> How about "if y is evaluated, then so too is x."?
04:01:41 <breadmonster> Also, have they settled on policy for giving out Haskell cloaks?
04:01:58 <srhb> I guess there's no real need to simplify it that much...
04:02:04 <srhb> breadmonster: ooo, cloaks? :D
04:02:07 <Gurkenglas> hackrilege, a misunderstanding. I would usually get rid of this boilerplate function by using the monad transformer corresponding to Either. However, mtl calls it ExceptT and the corresponding class MonadError, which would be confusing. Hence me saying that I don't want to throw (= put into the code) "error" names everywhere.
04:02:14 <breadmonster> srhb: /whois edwardk
04:02:42 <srhb> breadmonster: awww, I thought it was like a literal hooded cloke with a haskell logo on. :(
04:02:42 * hackagebot creatur 5.9.8.1 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.8.1 (AmyDeBuitleir)
04:02:43 <keko_> Gurkenglas: there's an EitherT too, is that in the wrong library?
04:02:56 <jle`> breadmonster: seq has a meaning and it controls evaluation, it doesn't just mean "add strictness here"
04:02:57 <tdammers> for practical intents and purposes, "x `seq` y" means "y, such that when y has been evaluated, x will also have been evaluated"
04:03:05 <breadmonster> srhb: Those would be cool, but I'd like an IRC cloak first :P
04:03:08 <srhb> :-)
04:03:21 <Gurkenglas> keko_, there's no MonadEither for that.
04:03:28 <jle`> breadmonster: it doesn't just say, "let there be strict", it tells ghc to evaluate certain things when certain other things happen
04:03:39 <breadmonster> I'LL MAKE REAL HASKELL CLOAKS IF SOMEONE GIVES ME AN IRC CLOAK
04:03:51 <jle`> so peppering code with seq is probably not going to accomplish anything
04:04:02 <jle`> just think about what you want evaluated, and when
04:04:21 <jle`> and if the default evaluation doesn't match up, use seq to control it to give you what you want
04:04:30 <tdammers> it helps to evaluate manually in your head to figure out what happens and where thunks build up
04:04:34 <keko_> Gurkenglas: oh, I have no idea what MonadEither is
04:04:42 <srhb> breadmonster: And in the case of foldl' it means thinking something like "hmm, at each recursive step I'd like to also make sure the accumulator is forced, so seq that with the recursive call..."
04:04:44 <breadmonster> tdammers: That is a useful skill I do not posses.
04:04:48 <jle`> have a picture of what you want to evaluate and when, and how you want things to be evaluated.
04:05:05 <jle`> and then see where that differs from how evaluation is normally
04:05:07 <tdammers> breadmonster: it's the FP equivalent of mentally stepping through imperative code
04:05:08 <Gurkenglas> keko_, what MonadReader is to Reader.
04:05:10 <jle`> and then use `seq` to correct the difference
04:05:20 <tdammers> breadmonster: only it's much easier once you know how to do it
04:05:20 <merijn> breadmonster: So read this https://hackhands.com/guide-lazy-evaluation-haskell/ and acquire that skill :)
04:05:28 <jle`> breadmonster: if you don't posses it yet, it just comes from practice and learning :)
04:05:31 <jle`> just like literally every other skill
04:05:35 <breadmonster> merijn: It cannot be that easy.
04:05:47 <jle`> why do you think it must be complicated?
04:06:10 <merijn> breadmonster: It's pretty simple, imo
04:06:11 <hackrilege> can we implement blocking thread communication with seq?
04:06:14 <jle`> do you demand it to be complicated? :o
04:06:29 <jle`> who says it's complicated :P
04:06:48 <merijn> hackrilege: No, also we already have blocking thread communication
04:07:14 <merijn> hackrilege: Like 10 different ones, even
04:07:24 <hackrilege> merijn, Where is this? also I thought it would be a good example of how to use seq to force evaluation...
04:08:47 <merijn> hackrilege: Control.Concurrent.* and friends, we have MVar, TVar, Chan, TChan, TQueue, TBQueue, etc.
04:09:09 <jle`> skills you have today are all skills that you didn't have at one point
04:09:45 <merijn> hackrilege: The thing is that cross thread communication is a side-effect, i.e. IO and seq won't run IO actions. It just evaluates haskell expressions
04:09:45 <breadmonster> merijn: That page said that space use is hard to predict.
04:10:22 <hackrilege> meijn, ok so completely wrong for MPI
04:11:25 <tdammers> well, there are some cases where lazy evaluation can lead to unexpected cross-thread communication
04:11:52 <merijn> tdammers: No. Though it can lead to computation happenning in unexpected threads
04:12:12 <tdammers> I'd consider that a crude form of communication
04:12:30 <hackrilege> Gurkenglas: im still confused about your paste, you say you have an alternative version of loop which fails to compile? or its messy because you have to write an error statement?
04:12:46 <tdammers> you create a thunk in one thread and pass it into another one, from where it is evaluated
04:13:14 <merijn> tdammers: To pass it between threads you need explicit communication, so the communication is not "unexpected"
04:13:35 <hackrilege> unless its from your x
04:13:43 <tdammers> merijn: yeah, but the communication isn't as explicit as you'd want it to be, because the syntax for passing a value and passing a thunk is the same
04:13:52 <breadmonster> Alright thanks guys!
04:14:45 <tdammers> do { x <- foo; forkIO (doStuffWith x) } -- can't tell which thread gets to evaluate x without more information
04:15:17 <Gurkenglas> hackrilege, the short paste you have should compile. It should be possible to collapse it down to a half-a-liner using a monad transformer, but unfortunately that one is called ExceptT and its class MonadError, which could get confusing, as you demonstrate.
04:15:41 <kclawl>  tdammers really? :/
04:15:54 <tdammers> sure
04:16:17 <kclawl> does that mean foo could be executed on either thread?
04:16:25 <ocharles__> cocreature: thanks for the support :)
04:16:31 <merijn> tdammers: The forkIO one does
04:16:49 <merijn> tdammers: Or did you mean 'x' was used later in the parent?
04:16:51 <cocreature> ocharles__: no need to thank me, I do this for purely selfish reasons :)
04:17:09 <ocharles__> cocreature: I only propose it for selfish reasons ;)
04:17:29 <tdammers> well, if you force x in the parent thread, then it'll be evaluated there
04:17:41 <cocreature> :)
04:18:51 <tdammers> foo = do { x <- readFile "yolo"; putStrLn x; return x }
04:20:04 <kclawl> what thread will read the file?
04:20:30 <kclawl>  do { x <- readFile "yolo"; forkIO (putStrLn x }
04:21:21 <merijn> kclawl: The parent
04:22:40 <merijn> hmmm, my parser takes infinity time to parse a one line file. Methinks I may have made a mistake...
04:22:41 <tdammers> in the latter example, the parent opens the file, and might read the first buffer, but the child thread reads the rest in a lazy fashion
04:22:43 * hackagebot creatur 5.9.8.2 - Framework for artificial life experiments.  https://hackage.haskell.org/package/creatur-5.9.8.2 (AmyDeBuitleir)
04:23:10 <tdammers> in the example I wrote, the parent thread does all the reading, because the putStrLn call forces the entire string
04:23:46 <merijn> tdammers: Default readFile is strict
04:23:56 <tdammers> oh hehe
04:23:56 <merijn> tdammers: Only lazy Text/BS are lazy IO, afaik
04:24:04 <tdammers> really?
04:24:18 <merijn> ah, no String is lazy too...
04:24:20 <merijn> That's annoying
04:24:23 <tdammers> I thought String-based System.IO was also lazy
04:24:27 <tdammers> so, yeah
04:24:59 <kclawl> why would first thread read anything then? we are not evaluating x in the main thread. I am not getting it
04:25:25 <tdammers> readFile does open the file immediately, I think
04:25:42 <tdammers> and it also seems to read the first buffer by default
04:26:20 <tdammers> at least when I last got bitten by the lazy IO gotcha, all files up to 4096 bytes were served correctly, but anything larger was silently cut off at 4096
04:26:41 <hpc> 4096 bytes is enough for anyone
04:27:33 <tdammers> haha yeah
04:29:17 <pyon> @ty let { foo = undefined :: f a } in foo == foo
04:29:19 <lambdabot>     No instance for (Eq (f0 a0)) arising from a use of ‘==’
04:29:19 <lambdabot>     The type variables ‘f0’, ‘a0’ are ambiguous
04:29:19 <lambdabot>     Note: there are several potential instances:
04:29:24 <pyon> ^ why?
04:30:17 <merijn> pyon: Because using == requires an Eq instance?
04:31:13 <pyon> Couldn't it infer a type like `(f a ~ g b, Eq (f a)) => Bool` ?
04:31:32 <merijn> pyon: How would it infer that?
04:31:42 <pyon> Mmm... No, wait. This particular example wasn't well thought out.
04:31:51 <merijn> pyon: You said "foo has type "f a"" for all possible types 'f' and 'a'"
04:32:06 <merijn> And GHC is just telling you "that means it doesn't have to be an Eq instance"
04:32:47 <pyon> Well, if `foo` has type `forall f a. f a`, then certainly could be *some* `f` and `a` such that `Eq (f a)`.
04:33:16 <pyon> @ty let { foo = undefined :: a } in foo == foo
04:33:17 <lambdabot> Bool
04:33:48 <pyon> ^ Just like, if `foo` has type `forall a. a`, then certainly there could be some `a` such that `Eq a`.
04:34:54 <merijn> There's no defaulting rules for types with kind "* -> *", I think
04:35:02 <merijn> foo can get defaulted to ()
04:35:12 <pyon> What I'm really trying to do is understand how type unification works in the presence of constraints like `f a = g b`, where `f` and `g` are free type variables.
04:35:19 <pyon> s/=/~/
04:35:28 <zipper>  Hey has anyone here tried to use ide-backend with stack?
04:35:32 <merijn> :t let { foo = undefined :: a } in foo `asAppliedTo` (==foo)
04:35:33 <lambdabot> Eq a => (a -> Bool) -> b
04:35:38 <merijn> eh
04:35:39 <merijn> whoops
04:36:05 <zipper> Apparently stack isn't able to find my haskell packages that I have installed via stack. I might be the one messing up
04:36:33 <merijn> :t let { foo = undefined :: a } in (==foo) `asAppliedTo` foo
04:36:34 <lambdabot> Eq a => a -> Bool
04:37:18 <pyon> Ah...
04:37:25 <merijn> pyon: You just add a "f a ~ g b" constraint and wait for something to force some 'f' or 'g'?
04:37:40 <pyon> merijn: And what happens if that forcing never comes?
04:38:01 <pyon> Do I get a type signature that itself contains the constraint `f a ~ g b`?
04:38:18 <merijn> pyon: Also, without type families I think all types are injective, i.e. "f a ~ g b" IFF "f ~ g" and "a ~ b"
04:39:06 <merijn> TypeFamilies complicate things, because there we might have cases where "f a ~ g b" even though neither "f ~ g" nor "a ~ b" are true
04:39:12 <pyon> merijn: I don't think that's the case. `type Foo a = String ; type Bar a = [a]`. Then `Foo Char = Bar Char`.
04:39:53 <merijn> pyon: type aliases don't exist during typechecking
04:39:59 <pyon> Oh.
04:40:04 <merijn> pyon: They are always expanded
04:40:13 <merijn> And cannot be partially applied (for exactly this reason)
04:40:27 <pyon> Ah, okay.
04:40:45 <merijn> TypeFamilies *can* be partially applied, so they can't always be trivially expanded
04:43:48 <ysz> g'day
04:44:02 <hodapp> o hai
05:09:22 <Gurkenglas> Refactorings and/or generalizations? http://lpaste.net/137978
05:10:43 <merijn> Naming question: What's a good pre-/suffix for parsers for my languages where they collide with haskell keywords?
05:11:27 <zipper> Hey funny issue.
05:11:49 <zipper> cabal configure is able to identify that I am missing certain dependencies,
05:11:55 <zipper> However stack isn't
05:12:02 <zipper> What could be the issue here.
05:12:32 <Gurkenglas> Ooh, I should write absurd instead of undefined.
05:16:44 <mniip> merijn, wait what
05:16:45 <Gurkenglas> Of course, runEitherT is missing.
05:16:47 <Gurkenglas> http://lpaste.net/137978
05:16:55 <mniip> how exactly do you partially apply type families
05:16:59 <Gurkenglas> -,
05:17:38 <merijn> mniip: By not applying sufficient arguments?
05:18:07 <merijn> ugh
05:18:20 <merijn> hdevtools doesn't seem to warn for non-exhaustive patterns for me anymore :\
05:18:26 <mniip> Parameters can also be given explicit kind signatures if needed. We call the number of parameters in a type family declaration, the family's arity, and all applications of a type family must be fully saturated w.r.t. to that arity. 
05:18:56 <merijn> mniip: oh, maybe my memory is faulty
05:18:56 <mniip> https://wiki.haskell.org/GHC/Type_families
05:19:23 <mniip> partial application of families would allow type-level abstractions
05:19:34 <mniip> and unifying lambdas is undecidable
05:19:44 <mniip> unification of lambdas*
05:24:01 <Black0range> Does ghc optimize away things like:  "a" <> "b" to "ab" ? 
05:25:42 <Black0range> also are there any way one might see the standard Rewrite rules of ghc?
05:25:59 <Gurkenglas> Should there be constructors for StateT corresponding to evalStateT and execStateT that respectively copy the s and return a ()?
05:30:19 <merijn> Any vim users using syntastic and hdevtools?
05:31:24 <maerwald> merijn: why?
05:31:37 <Gurkenglas> I'll make a pr adding them. How should I call the two?
05:32:28 <merijn> maerwald: It suddenly seems to not report some warnings for me...
05:32:37 <maerwald> merijn: do you have an example file?
05:33:52 <merijn> maerwald: Any incomplete pattern match
05:34:06 <lpaste_> merijn pasted “syntastic issues” at http://lpaste.net/137983
05:34:27 <merijn> maerwald: i.e. that doesn't highlight "non-exhaustive pattern"
05:34:51 <aweinstock> Black0range: ghc's -ddump-rule-firings flag (shows rewrite rules as they trigger during compilation)
05:35:13 <aweinstock> https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/rewrite-rules.html
05:35:21 <merijn> maerwald: But manually running "hdevtools check foo.hs" shows the non-exhaustive warning
05:35:50 <Black0range> aweinstock: thanks a lot
05:36:34 <Gurkenglas> Is there a better way to get a link to a name in a haddock than manually appending #v:name to the link?
05:37:05 <Gurkenglas> Where is the source of https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#t:State ?
05:37:58 <maerwald> merijn: fascinating... I can't even run it manually: hdevtools: <socket: 4>: hGetLine: end of file
05:40:00 <Gurkenglas> https://www.google.de/webhp?sourceid=chrome-instant&ion=1&espv=2&ie=UTF-8#q=site%3Ahttps%3A%2F%2Fhackage.haskell.org%2Fpackage%2Fmtl-2.2.1%2Fdocs%2Fsrc%2F+execState <- ...it's not implemented in that package?
05:41:40 <Gurkenglas> It's apparently imported from Control.Monad.Trans.State.Strict ... which is not documented
05:42:11 <Gurkenglas> Meaning listed on https://hackage.haskell.org/package/mtl
05:46:13 <merijn> Gurkenglas: Because it's in transformers
05:46:54 <Gurkenglas> Ahh. Okay.
05:46:56 <maerwald> merijn: lol, so I have it the other way around... works inside vim, but not when I do it manually xD
05:47:27 <maerwald> merijn: do you have multiple checkers activated?
05:47:37 <maerwald> in that case you might need "let g:syntastic_aggregate_errors = 1"
05:48:13 <supki> merijn: I don't get the warning either way unless I add {-# OPTIONS_GHC -Wall #-} to the top of the file
05:48:26 <supki> and it's been working this way since forever I think
05:48:54 <joneshf-laptop> If you're modeling a language with free structures, and you think you need a free monad because some instruction has a binary outcome, which you then choose what to do after that (so you need the next instruction to depend on the previous), couldn't you also use a free applicative, change what to do after the outcome to either do stuff or not (depending on the outcome), and just run both of the outcomes?
05:49:02 <joneshf-laptop> Or am i misunderstanding free applicatives?
05:50:08 <merijn> supki: I set "-Wall" in my vimrc in g:syntastic_haskell_hdevtools_args 
05:50:16 <Sindriava> Why are tuples instanced as functors the way they are? e.g. `fmap f (a, b) = (f a, b)` ?
05:50:24 <merijn> supki: It works for other warnings, it just doesn't work for non-exhaustive patterns
05:50:30 <joneshf-laptop> Sindriava, the other way around
05:50:31 <liste> Sindriava it can't be the other way
05:50:36 <merijn> Sindriava: Because that makes no sense if you look at the types
05:50:44 <Gurkenglas> Is https://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-State-Lazy.html#evalState faster than evalState = evalStateT would be?
05:50:51 <liste> instance Functor (,) a is possible
05:51:03 <Sindriava> merijn: Oh shit, yeah
05:51:03 <liste> instance Functor (,b) makes no sense
05:51:13 <Sindriava> I kinda forgot that tuples aren't homogenous
05:52:39 <merijn> :O
05:52:42 <Gurkenglas> No wait, it can't possibly be, looking at the implementation of runState etc.
05:52:55 <merijn> Crap, I think one of the flags that should be unrelated is accidentally silencing non-exhaustive patterns
05:52:59 <dibblego> you can essentially instance Functor (,) for both sides using a technique by edwardk 
05:53:58 <merijn> argh
05:53:59 <merijn> bollocks
05:54:09 <merijn> -fno-code silences non-exhaustives patterns
05:54:12 <merijn> That sounds like a bug...
05:54:14 <Gurkenglas> Is there a plan to expand the type signature of all functions to that of the function with an extra T at the end, then sometime phase out the ones ending on T?
05:55:09 <Sindriava> Gurkenglas: I'd be very suprised if some functions were phased out
05:55:20 <Gurkenglas> Oh wait, it wouldn't work, because actually evalState = runIdentity . evalStateT
05:55:23 <saulzar_> Gurkenglas, I guess no - things like State are just convenience..
05:55:49 <Gurkenglas> saulzar_, that's why I thought the primary names should belong to the general version.
05:55:57 <saulzar_> Gurkenglas, Yeah, doesn't do really the same thing :)
05:56:33 <dibblego> merijn: http://stackoverflow.com/questions/27647335/ghc-does-not-report-non-exhaustive-pattern-matches-when-using-the-no-code-flag
05:56:51 <saulzar_> Gurkenglas, Could be - but then there's no good name for the non 'T' version..
05:57:03 <Gurkenglas> It's still kinda ugly, now I have to implement the extra constructors for both versions. How should the inverses of evalState and execState be called?
05:57:20 <Gurkenglas> saulzar_, until I realized that they don't unify, I thought you could just use the same name for both.
05:57:52 <Gurkenglas> (Right inverses.)
05:58:07 <saulzar_> Gurkenglas, What are you working on?
05:58:21 <merijn> dibblego: Wow, that's been going for a while. Seems a completely silly oversight...
05:59:25 <merijn> dibblego: I wonder why the hell -fno-code would break this...
06:01:56 <merijn> Guess I'll try to live without no-code for now...
06:03:00 <fr33domlover> Hello! Q: In what sense is fast-logger faster or scales more than hslogger?
06:03:36 <fr33domlover> I'd like to choose a logging system for a web server which handles clients in separate threads and can log errors and requests into rotating log files
06:04:08 <fr33domlover> It seems wai/warp use fast-logger but I'm curious why it's different :)
06:06:39 <Gurkenglas> saulzar_, I've got an "Gamestate -> IO (Either Bool Gamestate)" and want to turn it into a "Gamestate -> IO Bool". To this end, it shall be isomorphed into a "StateT Gamestate (EitherT Bool IO) ()", "forever"'d into a "StateT Gamestate (EitherT Bool IO) Void", and isomorphed into "Gamestate -> IO Bool". (I also later planned to see whether lens can help here, because that packing and unpacking looks very lensy.) 
06:06:39 <Gurkenglas> I stumbled on the first step because there's no alias for the right inverse of execStateT.
06:08:08 <lf94> Gurkenglas, I just read your code (sorry for the wait, I just had to watch Wolf of Wall Street to the end!...). I definitely like your use of Either.
06:09:06 <lf94> I didn't know "state@" was a thing, very nice
06:09:07 <Gurkenglas> lf94, currently trying to get rid of that boilerplatey loop.
06:09:17 <lf94> See, it's these little toy programs that I find I learn a lot from.
06:09:32 <lf94> Gurkenglas, I'm going to try and use the State monad :)
06:09:50 <lf94> Gurkenglas, want to start a repository?
06:10:09 <saulzar_> Gurkenglas, I see.. yeah, interesting
06:11:14 <Gurkenglas> lf94, way ahead of ya. http://lpaste.net/137978
06:11:22 <lf94> esutnaohesutahoseuth
06:11:24 <lf94> not looking
06:11:26 <lf94> B)
06:11:47 <lf94> State monad is something I actually do want to intuitively learn
06:11:47 <aweinstock> :t fmap either id (const True)
06:11:48 <lambdabot> (b -> Bool) -> Either b1 b -> Bool
06:12:00 <aweinstock> :t fmap (either id (const True))
06:12:02 <lambdabot> Functor f => f (Either Bool b) -> f Bool
06:12:07 <Gurkenglas> nonononono that's cheating
06:12:11 <lf94> Gurkenglas, PM me your final solution
06:12:21 <lf94> so it doesnt get lost in scrollback
06:12:28 <aweinstock> Gurkenglas: what were you looking for?
06:12:39 <Gurkenglas> :t fmap (either id absurd)
06:12:40 <lambdabot> Not in scope: ‘absurd’
06:13:00 <Gurkenglas> @let import Data.Void
06:13:01 <lambdabot>  Defined.
06:13:03 <Gurkenglas> :t fmap (either id absurd)
06:13:04 <lambdabot> Functor f => f (Either b Void) -> f b
06:13:10 <aweinstock> :t fmap (either id (error "fromLeft: Right"))
06:13:11 <lambdabot> Functor f => f (Either b b1) -> f b
06:13:24 <benzrf> lf94: think of a value of 'State s a' as a first-class, reified stateful computation resulting in an 'a'
06:13:32 <Gurkenglas> No need to make the code unsafe. forever gives us a void that we can then safely throw away
06:13:51 <aweinstock> :t absurd
06:13:52 <lambdabot> Void -> a
06:14:02 <benzrf> lf94: like, suppose you had a "function" in a language like C that takes no arguments, returns an 'a', and has no side effects other than interacting with a global state variable of type 's'
06:14:03 <aweinstock> @src absurd
06:14:03 <lambdabot> Source not found. My brain just exploded
06:14:18 <benzrf> lf94: then that 'function' as a first-class, unexecuted value would be a 'State s a'
06:14:26 <Gurkenglas> Never has that response from lambdabot been more appropriate
06:14:48 <saulzar_> Not sure how you do that first step, to hoist the either from out of IO 
06:14:54 <aweinstock> Gurkenglas: what does Data.Void.absurd do?
06:15:25 <Gurkenglas> It doesn't matter, there is only one possible function from Void to anything and they're all safe.
06:15:26 <notdan> pretty much anything
06:15:30 <tdammers> what can it possibly do?
06:16:11 <quchen2> tdammers: Anything, it can do anything. Given a Void.
06:16:43 <aweinstock> is bottom the only inhabitant of Void?
06:16:48 <lf94> benzrf, Ok that is cool that you've explained it to me like that, but I haven't even seen how the Monad type class is defined lol
06:16:49 <quchen2> Yes
06:16:50 <tdammers> well, you can't give it a Void in the first place
06:16:58 <benzrf> lf94: you dont need to know the monad typeclass
06:17:07 <aweinstock> how is that "safer" than using error?
06:17:11 <benzrf> lf94: let me explain a few functions without mentioning any classes
06:17:21 <tdammers> but assuming that we don't know the definition of Void, then there's only one thing that function can do, which is bottom out
06:17:22 <benzrf> lf94: some utilities for working with State include
06:17:53 <fr33domlover> anyone has advice about fast-logger VS hslogger?
06:17:54 <benzrf> lf94: get :: State s s, which is the stateful operation that returns the state it operates within
06:17:55 <tdammers> and the only reason it's safe to expose that behavior for Void -> a is because the Void arg is bottom already
06:18:00 <tdammers> am I right?
06:18:29 <benzrf> lf94: mapState :: (a -> b) -> State s a -> State s b, which lets you compose a pure function with a stateful operation, or to put it another way, map over the 'future result'
06:18:35 <quchen2> absurd _ = ⊥, but you get a compilation error before reaching that bottom.
06:18:50 <quchen2> error will be reachable, always typechecks, and crashes during runtime.
06:19:18 <benzrf> lf94: modify :: (s -> s) -> State s (), which takes a function that modifies an s, and gives you the state operation that has the side effect of changing the state by that function but resulting in just a ()
06:20:24 <benzrf> lf94: join :: State s (State s a) -> State s a, which takes a stateful computation resulting in another stateful computation, and collapses it into one that first runs the computation, then runs its result
06:21:22 <lf94> benzrf, sorry, the State monad
06:21:27 <benzrf> lf94: ?
06:21:36 <aweinstock> lf94: that's what he's describing
06:21:43 <lf94> >benzrf> lf94: you dont need to know the monad typeclass
06:21:54 <benzrf> lf94: did you understand each of the functions i just described?
06:22:00 <aweinstock> :t join :: State s (State s a) -> State s a
06:22:00 <lf94> Reading now
06:22:01 <lambdabot> State s (State s a) -> State s a
06:22:05 <aweinstock> :t join
06:22:06 <lambdabot> Monad m => m (m a) -> m a
06:22:06 <lf94> Sorry I was brushing my teeth...
06:22:19 <aweinstock> (it's the same join)
06:22:54 <ysz> any success running ghc-mod with ghc >7.10 so far?
06:23:06 <Gurkenglas> Oh right, while all the pros are here. What should the right inverses of evalState and execState be called?
06:23:12 <quchen2> ysz: Which 7.10?
06:23:37 <ysz> quchen2, latests from the platform. 7.10.2
06:23:58 <quchen2> Hm, I'm not on .2 yet.
06:24:00 <lf94> (s -> s) -> State s () <- that doesn't really modify s, just creates a new copy
06:24:05 <kadoban> ysz: IIUC a version that works with >7.10 hasn't been released. I think there's a branch in the git repo, but I never tried it.
06:24:11 <lf94> right, benzrf 
06:24:38 <ysz> yeah, i imagine it'll catch up eventually but i wonder if you guys have ad hoc solution atm
06:24:41 <benzrf> lf94: if you understand all of those functions, you understand "State s"'s monad instance
06:24:51 <lf94> Ok :)
06:24:55 <Gurkenglas> saulzar_, it isn't hoistet out. The educt and product are only separated by newtype constructions
06:24:57 <ysz> quchen2, last time i checked it does not matter any 7.10.x does not work reliably
06:25:03 <lf94> I don't understand why there are 2 type variables
06:25:04 <benzrf> lf94: you dont need to understand monads to use any individual monad
06:25:18 <kadoban> ysz: My solution is hdevtools, though it doesn't do all of the same things.
06:25:21 <benzrf> lf94: did you read my explanation of what a "State s a" value /is/ -.-
06:25:29 <lf94> benzrf, yeah I know X) I thought I had to implement the State monad for some reason, that's why I said those things.
06:25:40 <lf94> ooop maybe it is higher up, sorry!
06:25:41 <ysz> kadoban, thanks a lot. i'll check! its been a while since i used haskell in anger ;)
06:25:47 <ysz> things have changed.
06:26:09 <Gurkenglas> (Also decoration with ().)
06:26:33 <Gurkenglas> saulzar_, *of the first step.
06:26:54 <lf94> Ok so s is a computation that returns an a
06:27:43 <lf94> So get returns the current context, benzrf ?
06:28:06 <benzrf> n oit isnt
06:28:08 <benzrf> o_o
06:28:20 <ani> is haskell a compiled language or an interpreted one?
06:28:31 <aweinstock> lf94: no, in "State s a", "s" is the type of the state, and "a" is the type that the action returns
06:28:32 <benzrf> a "State s a" is a computation that results in an a, while "reading and writing to a stateful variable" of type s
06:28:44 <benzrf> for example
06:28:55 <aweinstock> ani: both (GHC has both a compiler and an interpreter)
06:29:00 <edk> ani, compiled or interpreted isn't really a property of languages
06:29:11 <benzrf> int incr() {globalVar += 1; return globalVar;}
06:29:11 <edk> haskell has serious implementations of both kinds
06:29:21 <benzrf> ^the corresponding haskell thing would be a value of State Int Int
06:29:31 <lf94> aweinstock, oh
06:29:36 <benzrf> the first Int is the type of the state it interacts with, the second is the type of the value it results in
06:29:37 <quchen2> edk: Befunge wants to have a word with you :-þ
06:29:46 <aweinstock> :t modify (+1) >> get
06:29:47 <lambdabot> (Num b, MonadState b m) => m b
06:29:50 <edk> quchen2, didn't someone write a befunge compiler?
06:29:57 <lf94> Sorry I still get really confused easily when I see multiple type variables for something
06:30:04 <benzrf> lf94: that's ok!
06:30:12 <quchen2> edk: I thought it was only a partial implementation.
06:30:16 <lf94> Normally state is just...state is just a bunch of variables grouped together!
06:30:23 <aweinstock> lf94: you'll get better with practice :)
06:30:53 <lf94> State Int Int <- the state in this case is just an Int and the action returns an Int
06:31:03 <lf94> What the hell is "the action" ?
06:31:14 <lf94> Where does it come from? Where do I incorporate it?
06:31:15 <aweinstock> :t modify (+1) >> get :: State Int Int
06:31:16 <lambdabot> State Int Int
06:31:30 <aweinstock> @let incr = modify (+1) >> get
06:31:31 <lambdabot>  Defined.
06:32:00 <aweinstock> > evalState incr 0
06:32:02 <lambdabot>  1
06:32:15 <benzrf> aweinstock: hold on
06:32:22 <benzrf> lf94: 'action' is a term for a value that represents some kind of effect or computation
06:32:33 <lf94> Right
06:32:38 <benzrf> lf94: consider my C function above
06:32:49 <benzrf> the first-class function value 'incr', not being called, just the function value itself
06:32:55 <benzrf> would be a 'State action'
06:32:59 <benzrf> rather, its haskell equivalent would be
06:33:06 <Gurkenglas> Oh hey, modify is the right inverse of execState. And nobody noticed.
06:33:16 <lf94> Ah
06:33:18 <lf94> Yes yes
06:33:37 <lf94> :t get
06:33:38 <lambdabot> MonadState s m => m s
06:33:50 <lf94> How is aweinstock passing 0 to get
06:33:59 <lf94> Is it not evaluated right to left?
06:34:00 <quchen2> Gurkenglas: How so?
06:34:03 <aweinstock> Gurkenglas: what do you mean by "right inverse" in this context?
06:34:15 <benzrf> Gurkenglas: huh, interesting
06:34:17 <aweinstock> :t evalState
06:34:18 <lambdabot> State s a -> s -> a
06:34:20 <lf94> Or do binds work left to right
06:34:29 <benzrf> lf94: what binds
06:34:32 <lf94> ah
06:34:36 <Fay> hi
06:34:40 <Gurkenglas> "f is the right inverse of g" := "g . f == id"
06:34:49 <quchen2> :t execState . modify
06:34:49 <lf94> benzrf, :t evalState explains it X)
06:34:50 <lambdabot> (s -> s) -> s -> s
06:34:53 <benzrf> lf94: dont try to think about things you dont understand unless you're trying to understand them <- probably bad advice
06:34:55 <aweinstock> lf94: evalState takes a state action, and an initial value for the state, and runs the action on the state to get its value
06:35:33 <benzrf> lf94: in general, try to read and think about this stuff at face value before trying to apply concepts you dont totally get that you arent sure are relevant
06:35:39 <benzrf> ^probably not bad advice
06:36:01 <lf94> Heh, it's not easy coming from a C/assembly background!
06:36:05 <benzrf> :)
06:36:07 <benzrf> lf94: secretly a 'State s a' is just an 's -> (s, a)' in disguise
06:36:16 <benzrf> lf94: haskell doesnt actually have mutation or global state
06:36:21 <lf94> That's a nice analogy
06:36:28 <benzrf> lf94: it's not an analogy at all
06:36:32 <benzrf> that's what a State s a actually is
06:36:39 <lf94> Oh!
06:36:47 <Fay> i have a really strong C background, is my interpretation somewhat accurate in saying that functers are like typedefs for typedefs of specific kinds for types?
06:36:53 <benzrf> lf94: but it doesn't actually matter
06:36:53 <aweinstock> benzrf: we're hiding ST and IO for now?
06:36:57 <benzrf> aweinstock: shh :)
06:37:00 <lf94> There are a lot of times where I see someone use "secretly" but it's not the actual reality
06:37:06 <benzrf> ah, fair
06:37:14 <benzrf> lf94: the important thing isn't the actual implementation of State
06:37:19 <benzrf> the important thing is how the parts work together
06:37:28 <benzrf> but it may be helpful to know that it's implemented that way in some cases
06:37:44 <lf94> Fay: no Functors are just types that can be fmap'd over
06:37:45 <quchen2> Fay: If by "functer" you meant "functor", then no.
06:37:54 <aweinstock> lf94: I'm pretty sure that "State s a" actually is a type/newtype for "s -> (s, a)" (they're the same thing, with some typedefs/wrappers)
06:38:01 <benzrf> lf94: welllllll... if you're using the mainstream monad transformer libs
06:38:08 <benzrf> lf94: it's actually something marginally more complicated
06:38:13 <benzrf> lf94: but that's not really important
06:38:18 <benzrf> it's morally the same thing
06:38:21 <lf94> Well, generally that's the case, you're right :)
06:39:13 <benzrf> seeing the implementation can help ground the intuition
06:39:21 <lf94> Fay: read up on 'category theory in haskell' on the haskell wiki. It actually makes a lot of things easier to understand.
06:39:21 <benzrf> for example,
06:39:30 <benzrf> lf94: debatable :o
06:39:45 <Fay> lf94: okay i will
06:39:46 <benzrf> join :: State s (State s a) -> State s a -- lf94
06:40:00 <lf94> I've read countless blogs and articles on Functors/Monads, the haskell wiki page about category theory helped the most
06:40:30 <benzrf> join ssa = \stateVal -> let (newStateVal, nextStep) = ssa stateVal in nextStep newStateVal -- lf94
06:40:34 <lf94> benzrf, yeah join makes no sense to me
06:40:39 <benzrf> in reality there's some wrapping and unwrapping from the State type but
06:40:53 <Gurkenglas> And gets is the right inverse of evalState.
06:40:55 <maerwald> lf94: fascinating, it helped me the least :P
06:41:04 <aweinstock> :t \f -> join . fmap f
06:41:05 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
06:41:14 <Fay> lf94: when you fmap over a functor, you get a type composed of what?
06:41:18 * quchen2 thinks suggesting newbies to read stuff about category theory is terrible and unhelpful advice, except for a handful of mathematicians.
06:41:23 <benzrf> quchen2: same
06:41:36 <maerwald> quchen2: even a lot of mathematicians don't particularly like ct
06:41:37 <tdammers> :t fmap -- <- Fay
06:41:38 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:41:50 <benzrf> lf94: the practical utility of join is
06:42:08 <benzrf> lf94: a lot of the time you will have a function that looks like A -> State S B, for some A, S, and B
06:42:11 <quchen2> Fay: You need to understand category theory to use monads in Haskell the same way you needed Galois theory to add 3 and 5 in first grade.
06:42:28 <benzrf> lf94: something that takes a value and produces a stateful computation of a second value
06:42:51 <lf94> yeah ok
06:42:58 <benzrf> lf94: if you map such a function over a State S A, you get a State S (State S B)
06:43:02 <benzrf> so then you can join it down
06:43:12 <bartavelle> how can I declare something like "data Foo ch = Foo (ch Int)" and have GHC understand that "ch :: * -> *" ?
06:43:15 <benzrf> in practice you rarely use join; you use (>>=), which combines the steps into one
06:43:28 <maerwald> > fmap (\x -> if x < 10 then Just (x + 1) else Nothing) (Just 5)
06:43:29 <benzrf> s >>= f = join (map f s)
06:43:30 <lambdabot>  Just (Just 6)
06:43:32 <maerwald> that's why we need join/monads
06:43:56 <benzrf> lf94: in general, a Monad is a Functor that has some kind of `join', and bind in general is just that join plus fmap, as above
06:43:57 <tdammers> intuition for fmap: if you have a function that can convert apples into oranges, and you have a "crate of ___" type, then you can use fmap to turn that "apples to oranges" function into a "crate of apples to crate of oranges" function
06:43:58 <quchen2> bartavelle: Kind signatures
06:44:02 <benzrf> lf94: but dont worry too hard about that
06:44:02 <lf94> :t join
06:44:03 <lambdabot> Monad m => m (m a) -> m a
06:44:06 <benzrf> it will become more intuitive
06:44:14 <quchen2> bartavelle: Although in this case it'll infer that kind
06:44:15 <tdammers> "crate of ___" is your functor type
06:44:23 <benzrf> lf94: since you mostly use (>>=) in practice, the Monad typeclass is actually defined in terms of it
06:44:33 <bartavelle> quchen2, thanks !
06:44:37 <benzrf> lf94: but in mathematics, monads are defined as endofunctors with a join operation
06:44:46 <quchen2> ?let data Foo k = Foo (k Int)
06:44:48 <lambdabot>  Defined.
06:44:51 <quchen2> :k Foo
06:44:52 <lambdabot> (* -> *) -> *
06:45:01 <quchen2> ?undef
06:45:01 <lambdabot> Undefined.
06:45:03 <quchen2> There you go :-)
06:45:09 <benzrf> lf94: this does mean that there's sometimes/often duplicated code from fmap in (>>=) definitions since it's join + fmap, but
06:45:12 <bartavelle> but how do you declare it ?
06:45:19 <bartavelle> what's the "::" when declaring data ?
06:45:21 <bartavelle> data types
06:45:23 <lf94> State Int (State Int Int) -> State Int Int
06:45:28 <quchen2> It's "::" :-þ
06:45:34 <bartavelle> heh
06:45:52 <bartavelle> oh you write it GADT style
06:46:06 <aweinstock> :t (5, 5::Int)
06:46:07 <lambdabot> Num t => (t, Int)
06:46:13 <kuribas> :k Monad
06:46:14 <lambdabot> (* -> *) -> Constraint
06:46:16 <lf94> ...I would think traditionally, the type the state is, and the action return type would be the same.
06:46:28 <lf94> unless you want to hide some things.
06:46:30 <aweinstock> :t get >>= show
06:46:31 <lambdabot>     No instance for (MonadState a0 []) arising from a use of ‘get’
06:46:31 <lambdabot>     In the first argument of ‘(>>=)’, namely ‘get’
06:46:31 <lambdabot>     In the expression: get >>= show
06:46:37 <lf94> am I on the right train of thought here
06:46:44 <aweinstock> :t fmap show get
06:46:45 <lambdabot> (Show a, MonadState a f) => f String
06:46:57 <aweinstock> evalState (fmap show get) 0
06:47:00 <aweinstock> > evalState (fmap show get) 0
06:47:01 <lambdabot>  "0"
06:47:09 <lf94> State TheStateOfMyEntireProgram ATinySliceOfUsefulStuff ?
06:47:35 <Zemyla> > getLine
06:47:37 <lambdabot>  <IO [Char]>
06:47:48 <lf94> I guess it's just more general to have State s a than just State s s
06:48:00 <lf94> (Which could be simplified to State s...)
06:48:08 <aweinstock> lf94: yes, that's how configuration is often passed around (regarding "State TheStateOfMyEntireProgram ATinySliceOfUsefulStuff")
06:48:26 <lf94> Alriiiight now we're getting somewhere
06:48:32 <aweinstock> lf94: except typically Reader is used there, which has "ask" instead of "get", and doesn't have "modify"
06:48:36 <keko_> lf94: why would it be the same? like, if you have an algorithm that finds a path, your state will involve stuff like a list of unvisited nodes, and the return value will be the path found
06:48:54 <lf94> keko_, talking about something like game state :)
06:49:01 <lf94> keko_, you're right though that's another way to look at it
06:49:29 <lf94> Excellent material, love it
06:50:04 <benzrf> lf94: well, conside
06:50:06 <benzrf> r
06:50:09 <benzrf> suppose you have, like
06:50:30 <Fay> this channel is awesome sometimes.
06:50:33 <benzrf> data PartyInfo = PartyInfo Int String -- Int is number of guests, String is location
06:51:23 <benzrf> lf94: then maybe you have a function that returns whether or not that location can accomodate that number of guests, or something
06:51:28 <benzrf> like, State PartyInfo Bool
06:51:47 <benzrf> lf94: remember, State s a ~ s -> (s, a)
06:51:51 <benzrf> the state /is/ always in the result
06:51:57 <benzrf> that's the point of the abstraction; it hides that management from you
06:52:11 <benzrf> you can go on to chain your State PartyInfo Bool with any other stateful operation and the state is still there
06:52:16 <benzrf> the entire point of State
06:52:19 <Fay> whats ~
06:52:32 <benzrf> Fay: well, in a constraint it means Actually Equal
06:52:38 <benzrf> but i was using it to mean Morally Equivalent
06:52:55 <Fay> thanks
06:52:57 <tdammers> it is in fact wrapped in a newtype, typically
06:53:08 <lf94> I feel like State is a computation based on a state that returns the result
06:53:08 <benzrf> o wait
06:53:13 <lf94> am I right here
06:53:14 <benzrf> it's traditionally s -> (a, s)
06:53:16 <benzrf> mfw
06:53:23 <benzrf> lf94: hmm?
06:53:25 <lf94> Actually I think you even said something along those lines earlier
06:53:28 <benzrf> yeah :p
06:53:36 <lf94> Ok excellenttttt
06:53:50 <lf94> Yeah the State monad is perfect for this hangman game
06:53:55 <benzrf> think of a State s a as a value of 'a' whose computation involves access to a mutable variable of type s
06:54:13 <Hafydd> lf94: if it didn't return the state, how would you represent the computation that changes the state?
06:54:17 <lf94> When you put it that way, it's much more confusing
06:54:22 <benzrf> how so?
06:54:34 <benzrf> the value is a first-class encapsulation of such a computation
06:54:40 <benzrf> you dont actually have access to an 'a'
06:55:03 <lf94> >State is a computation based on a state (s) that returns the result (a)
06:55:12 <benzrf> no,
06:55:14 <lf94> That is much simpler to understand, and appears that way too
06:55:19 <maerwald> it returns the result and the new state
06:55:35 <benzrf> a /value/ of /State s a/ is a /first-class representation/ of such a computation
06:55:38 <lf94> oh right
06:55:48 <aweinstock> :t return 5 :: State s Int
06:55:49 <lambdabot> State s Int
06:56:18 <benzrf> lf94: in the same phrasing,
06:56:28 <Hafydd> A "computation based on a state s that returns the result a" is just a function :: s -> a.
06:56:47 <benzrf> lf94: "a value of 'a -> b' is a first-class representation of a computation that uses an 'a' to produce a 'b'"
06:56:48 <Hafydd> (Also occurring as the Reader monad.)
06:57:15 <kurt21> When I do `import Control.Monad.State`, I get an "Could not find module" error. Is that something I need to install with cabal? How do I do that?
06:57:16 <lf94> Hafydd, right, we want s -> (s,a) which is the definition of the State monad :p
06:57:39 <benzrf> lf94: in parallel, "a value of 'State s a' is a first-class representation of a computation that uses and updates a mutable variable of type 's' to produce an 'a'"
06:57:49 * hackagebot html-entities 1.1.0.0 - A codec library for HTML-escaped text and HTML-entities  https://hackage.haskell.org/package/html-entities-1.1.0.0 (NikitaVolkov)
06:57:51 <quchen2> kurt21: It's in the transformers package.
06:57:55 <aweinstock> s -> (a, s) is 'a computation on a state of type "s" that returns both a value of type "a" and a new (potentially modified, potentially unchanged) state, also of type "s"'
06:58:19 <benzrf> lf94: it is easier in the short term to think of State s a as being 's -> (a, s)', because it is more familiar
06:58:27 <kurt21> quchen2: thank you. Is there any way I can figure that out without asking someone?
06:58:42 <benzrf> lf94: but in the long term, internalizing the description i gave above allows you to operate at a higher level of abstraction
06:58:44 <lf94> benzrf, yeah I understand it I think it's just the terms you've used here and there :)
06:58:47 <quchen2> kurt21: Hoogle and Hayoo are excellent Haskell search engines.
06:58:48 <benzrf> kk, mb :)
06:58:59 <lf94> benzrf, the variable is not mutable though
06:59:07 <quchen2> kurt21: Enter the thing you're looking for, e.g. "State", and it'll tell you where it's defined and link to the Hackage page.
06:59:07 <lf94> although it may appear to be
06:59:12 <benzrf> lf94: you're thinking about implementation details!
06:59:19 <lf94> I am!! lol
06:59:27 <benzrf> lf94: don't think about how a 'State s a' is implemented
06:59:31 <benzrf> think about what it /represents/
06:59:36 <lf94> Gotchya.
06:59:39 <Fay> so is it like returning a typed pointer variable in C to a potentially new something?
06:59:42 <lf94> Should I be doing this with everything in Haskell
06:59:49 <lf94> Because I sort of have not been
06:59:51 <maerwald> Fay: x = 3 in e.g. C also has the result "3", but also the new state "x is now 3" which is why "if (x = 3)" is valid syntax
06:59:54 <benzrf> it represents some algorithm or method for computing an 'a', operating in a stateful environment
07:00:01 <benzrf> lf94: this is just learning to think abstractly in general
07:00:08 <benzrf> lf94: it's like
07:00:13 <benzrf> lf94: when you write code in, say, python
07:00:30 <benzrf> lf94: you /can/ think about the fact that a variable is a pointer to a memory location, or something
07:00:33 <kurt21> Are you sure State is in the transformers package and not the mtl package?
07:00:35 <benzrf> and maybe it will help you at first
07:00:53 <aweinstock> :t \ _ -> (3,3)
07:00:54 <lambdabot> (Num t, Num t1) => r -> (t, t1)
07:00:54 <benzrf> lf94: but in the long run, it forces you to pay attention to details that aren't important to writing and understanding code
07:01:06 <aweinstock> :t modify (const 3) >> get
07:01:08 <lambdabot> (Num b, MonadState b m) => m b
07:01:33 <benzrf> lf94: once you can let that particular understanding lie below the surface for when you need to get picky, once you can just think of them as labels for values, you gain the ability to think more quickly and intuitively about python programs
07:01:40 <lf94> benzrf, right. Normally I'm fine with abstract thinking - but I find myself getting hooked on implementation details, like you said.
07:01:44 <benzrf> that's fine
07:01:52 <benzrf> you always need to start concrete
07:01:52 <lf94> benzrf, because normally they bite you in the butt in the real world.
07:01:55 <benzrf> :)
07:02:07 <lf94> (Speaking from PHP and JavaScript experience...)
07:02:08 <benzrf> just keep in mind that your eventual goal should be to gain an abstract understanding
07:02:18 <benzrf> that's all
07:02:38 <lf94> Will do Sensei
07:02:39 <benzrf> lf94: the same issue just crops up in haskell a lot more because the haskell ecosystem and community is generally more abstraction-rich
07:02:56 <lf94> yeah, extremely abstraction rich x)
07:02:58 <benzrf> :D
07:03:00 <benzrf> it's great
07:03:13 <lf94> It is really, programming should be taught like that more
07:03:46 <maerwald> people want to make money, not dwell for months on different concepts of abstraction
07:03:53 <maerwald> and they have a fair point
07:04:17 <Herogx> Not everyone is wholly interested in making money
07:04:24 <maerwald> me neither
07:04:35 <maerwald> that's why I'm here (lol)
07:04:38 <quchen2> People work for money to buy happiness. Haskell is more efficient by cutting out the middle man.
07:05:13 <Gurkenglas> The more abstract the language, the more abstract the money.
07:05:13 <maerwald> actually, I am forced to learn Go now because of money... and it is disappointing (no polymorphism)
07:05:15 <quchen2> s/man/part/
07:05:49 <benzrf> i dunno
07:06:01 <benzrf> ive been trying to get myself to be less of a snob about programming lately
07:06:02 <aweinstock> maerwald: write haskell programs to write go programs for you? :)
07:06:08 <maerwald> too hard
07:06:33 <benzrf> so more recently ive been recommending haskell to people only if i think they actually care about programming in and of itself
07:07:01 <benzrf> and not to people who are looking into programming only for pragmatic reasons
07:07:22 <kuribas> benzrf: isn't haskell useful for pragmatic reasons?
07:07:34 <benzrf> it is
07:07:35 <maerwald> depends
07:07:43 <benzrf> but
07:07:46 <benzrf> there's much more of an investment
07:08:00 <maerwald> I don't think there is a better language for creating DSLs
07:08:03 <benzrf> it's like...
07:08:04 <tdammers> the word "pragmatic" sees a lot of abuse these days
07:08:11 <Fay> what is Just for? I understand how it works, but i dont get why its needed
07:08:12 <benzrf> tdammers: true :)
07:08:26 <benzrf> the command line /is/ a more efficient way to get things done in many cases than GUIs
07:08:29 <benzrf> it's cool and useful
07:08:41 <benzrf> but there's a reason i dont tell every single computer user i know to learn to use bash
07:08:46 <quchen2> Fay: 90% of the (-1) you know from C should not be (-1) but Nothing.
07:08:50 <aweinstock> Fay: you've used nullable pointers to represent things that may or may not be exist?
07:08:57 <kuribas> Fay: how would you return the head of an empty list, without using error?
07:09:00 <obadz> Is there a way to use Aeson to simply parse Json strings into JsonValues (= JsonString s | JsonNumber y | ...) ?
07:09:06 <tdammers> investing 100 hours into learning a tool that you know will make your life easier for the next few decades is a very pragmatic thing to do
07:09:13 <benzrf> tdammers: but see, there's the thing
07:09:19 <aweinstock> :t Data.Aeson.decode
07:09:20 <lambdabot> aeson-0.8.0.2:Data.Aeson.Types.Class.FromJSON a => BSLC.ByteString -> Maybe a
07:09:35 <kuribas> benzrf: If you just want to earn money, then I'd say learn java instead.
07:09:46 <benzrf> when i say 'for pragmatic reasons' what i really mean is 'they want to write a simple reddit bot' or 'they want to make a game using a framework' or
07:10:00 <obadz> aweinstock: is there an existing ADT a I can use here?
07:10:23 <tdammers> yeah, if that's your goal, and the result is more important than the process or your personal development as a programmer, then haskell is probably the wrong choice
07:10:29 <benzrf> exactly
07:10:33 <maerwald> Fay: as an example... if you want safe list lookup, you have to deal with the case of exceeding the index, which is the _only_ failure there is. Then Nothing makes sense. Unfortunately, it's often used for cases where there are actually different kind of failures (then, Maybe is NOT what you want)
07:10:36 <benzrf> that's what i meant by 'learn programming for pragmatic reasons'
07:10:43 <tdammers> just like vim isn't the right choice if all you need to do is write short e-mails
07:10:46 <benzrf> :)
07:10:51 <obadz> aweinstock: found it, Data.Aeson.Value
07:11:59 <Fay> wait so Just is Maybe a = Nothing | a?
07:12:08 <Fay> so is just like a wrapper type?
07:12:12 <maerwald> @src Maybe
07:12:12 <lambdabot> data Maybe a = Nothing | Just a
07:12:37 <aweinstock> tdammers: I write emails in vim
07:12:46 <tdammers> so do I
07:12:51 <kuribas> benzrf: When I was in the train, there was a guy who was working as a project leader for some middleware application.  He showed me a bug that showed up on hundreds of users.  Something about an illegal variable.  That's why you would recommend haskell :)
07:12:55 <tdammers> but I do that because vim was a pragmatic choice for me
07:13:04 <tdammers> and e-mail is just one use case
07:13:07 <aweinstock> tdammers: oh, you mean it's not worth learning from scratch *just* for that
07:13:12 <tdammers> yeah
07:13:16 <Fay> so can Just represent any type?
07:13:18 <wto> Is it possible to point cabal-install to use some other configuration directory than $HOME/.cabal/ ?
07:13:31 <maerwald> kuribas: you first have to find someone who knows haskell... maintainability. It's impossible to sell to regular companies
07:13:36 <wto> like /some/path/deep/down/.cabal/
07:13:37 <aweinstock> fmap (+2) (Just 5)
07:13:40 <kuribas> maerwald: true
07:13:41 <aweinstock> > fmap (+2) (Just 5)
07:13:43 <lambdabot>  Just 7
07:13:47 <aweinstock> > fmap (+2) Nothing
07:13:49 <lambdabot>  Nothing
07:13:56 <tdammers> vim is a valuable investment for me because it solves *all* my text editing needs, so any gains I make in one text editing situation probably benefit all of them
07:14:06 <hodapp> :t Just
07:14:07 <lambdabot> a -> Maybe a
07:14:07 <benzrf> kuribas: indeed
07:14:11 <aweinstock> fmap ("hello " ++) (Just "world")
07:14:15 <aweinstock> > fmap ("hello " ++) (Just "world")
07:14:17 <lambdabot>  Just "hello world"
07:14:34 <hodapp> oh, nevermind, ignore me, it was for a bygone piece of conversation
07:14:41 <hodapp> because lag
07:15:07 <supki> wto: I'd expect changing HOME to /some/path/deep/down to help.
07:15:17 <benzrf> tdammers: when i said pragmatic perhaps i meant
07:15:18 <benzrf> uhh
07:15:25 <benzrf> man, idk
07:15:30 <kuribas> :t lookup --Fay
07:15:31 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
07:15:38 <aweinstock> benzrf: short-term payoff?
07:15:41 <wto> supki: sure, I guess that would work, but it might interfere with normal operation I guess.
07:15:44 <benzrf> pehaps, aweinstock
07:16:09 <maerwald> I'd really love to see an imperative language that only picks one point from haskell and improves it: make side effects explicit in the return type, but be more specific about it (IO sucks)
07:16:25 <ttt_fff> what can I do today to become a better haskeller ?
07:16:57 <bjornars> ttt_fff: write some haskell code, solve a problem
07:17:53 <maerwald> ttt_fff: implement imperative algorithms in haskell (both imperatively and functional... the latter will force you to reverse-engineer the algorithms)
07:18:05 <maerwald> which is quite some pain sometimes, but fun
07:23:58 <ClaudiusMaximus> maerwald: but if you be too specific about IO effects, implementation details can leak in the types, making it harder to change later...
07:24:16 <maerwald> ClaudiusMaximus: it would be possible to keep IO type still
07:24:17 <maerwald> for those cases
07:24:29 <maerwald> where you want to express "anything can happen here"
07:24:45 <maerwald> but if I have a function where I know "this only READS from hard disk, never writes or does other funny kernel calls"
07:24:48 <maerwald> then why have IO?
07:25:32 <benzrf> maerwald: have you seen koka?
07:25:33 <nkaretnikov> https://hackage.haskell.org/package/scotty why are some versions highlighted in green?
07:25:42 <maerwald> benzrf: probably not
07:25:53 <benzrf> maerwald: it's kind of like haskell with gallons and gallons of syntactic sugar to the point that it looks pretty similar to javascript
07:25:59 <benzrf> http://research.microsoft.com/en-us/projects/koka/
07:27:01 <benzrf> with a dash of ruby, perhaps
07:27:09 <indiagreen> nkaretnikov: green are preferred ones, gray are deprecated ones
07:29:00 <indiagreen> cabal will try to choose a preferred version / avoid a deprecated one, but it doesn't have to (for instance, if you explicitly ask for a deprecated version, cabal will obey, and it also might choose a deprecated version when there's no other choice, but I'm not sure about it)
07:31:56 <benzrf> row polymorphism is hella neat and it looks to me like a great approach to effect management :}
07:32:35 <nkaretnikov> indiagreen: huh?  everything from 0.0.1 to 0.5.0 is shown in green.  the rest is in orange.  which ones are deprecated?
07:33:14 <indiagreen> nkaretnikov: oh
07:33:27 <indiagreen> apparently I was mistaken all this time
07:33:32 <maerwald> benzrf: I've seen some ID game code where side effects were part of every function documentation. We need to somehow force this. Can't expect every developer to be thet disciplined ;)
07:34:01 <benzrf> maerwald: do you mean id
07:34:21 <maerwald> I don't know what you mean
07:34:31 <benzrf> if you mean the company that made doom, it's called 'id software', as in the id vs the superego
07:34:40 <maerwald> I don't care much how it is written
07:34:48 <benzrf> well, it's not ID as in the abbreviation
07:34:57 <indiagreen> nkaretnikov: greens are actually worse than oranges, it turns out (if there's a preferred version range, greens are the ones that are outside of that range)
07:34:58 <benzrf> it's like the freudian part of the psyche
07:35:03 <albeit> How can I do something like "(a -> m (Maybe b)) -> [a] -> Maybe b"... like a foldM but stop at the first Just result?
07:35:08 <bjornars> 'i dont care if people understand what I mean'
07:35:14 <benzrf> bjornars: eh
07:35:17 <albeit> Mistyped: "(a -> m (Maybe b)) -> [a] -> m (Maybe b)"
07:35:19 <benzrf> 'ID software' is comprehensible
07:35:20 <maerwald> I don't care about needless nitpick, right
07:35:37 <benzrf> maerwald: well its a slightly more relevant nitpick because the capitalization isnt a stylistic thing
07:35:41 <bjornars> benzrf: that's how I interpreted that maer wrote
07:35:43 <maerwald> whatever
07:35:46 <indiagreen> nkaretnikov: and there are no deprecated versions for scotty, yep (that was just a chunk of extra information)
07:35:50 <benzrf> it's because it's a word, not an abbrevation
07:35:50 <bjornars> i didnt know what he meant by 'ID code'
07:35:59 <maerwald> so the discussion has derailed...
07:36:04 <benzrf> sorry :p
07:37:50 * hackagebot StateVar 1.1.0.1 - State variables  https://hackage.haskell.org/package/StateVar-1.1.0.1 (SvenPanne)
07:37:54 <nkaretnikov> indiagreen: i wonder who picked colors %) 
07:37:58 <ttt_fff> damn , koka looks pretty nice
07:38:04 <benzrf> ttt_fff: right
07:38:09 <indiagreen> nkaretnikov: what's worse, orange versions are called “blue” in the description
07:38:52 <nkaretnikov> indiagreen: lol
07:39:01 <nkaretnikov> i guess i should report this
07:39:12 <humanoyd> How can I execute a program from within haskell, i.e. `main = doSomething >> equivalentOf "./myProcess" >> doSomethingElse` when `myProcess` does not terminate (it's a server)?
07:39:30 <indiagreen> nkaretnikov: from now on I'm going to use the mnemonic “orange cheese is okay to eat, green cheese is rotten, gray cheese is not even rotten anymore but is a cheese corpse” 
07:39:35 <benzrf> humanoyd: why cant you do it like that
07:39:44 <benzrf> indiagreen: hahahaha nice
07:40:21 <indiagreen> ...even tho I actually like green and gray cheese
07:40:23 <humanoyd> benzrf: because I don't know what `equivalentOf "./myProcess"` would be :)
07:40:39 <Cale> humanoyd: spawnProcess
07:40:58 <Cale> Or spawnCommand
07:41:10 <Hafydd> spawnMoreOverlords
07:41:23 <albeit> If I do "Just 1 <|> foo", is foo evaluated?
07:41:24 <Cale> (In System.Process)
07:41:37 <Cale> > Just 1 <|> undefined
07:41:38 <lambdabot>  Just 1
07:41:40 <Cale> ^^ no
07:41:44 <indiagreen> > Just 1 <|> undefi— darn, Cale
07:41:45 <lambdabot>  <hint>:1:24: parse error on input ‘,’
07:41:50 <albeit> Thanks
07:42:08 <indiagreen> you won but I'll be back
07:42:13 <Cale> hehe
07:43:42 <nkaretnikov> indiagreen: okay, i pasted your mnemonic to #hackage
07:44:04 <albeit> I seem to have the pattern "case mFoo of; Nothing -> return Nothing; Just foo -> f foo". Is there a cleaner way of writing that?
07:44:14 <coppro> albeit: yes
07:44:16 <exio4> f =<< mFoo ? 
07:44:28 <humanoyd> Cale: Hm, I've tried `spawnCommand` and it does spawn the process but some (not all) IO actions that come after that do not get executed
07:44:30 <benzrf> albeit: i just did that the other day!! if i understand correctly
07:44:36 <benzrf> er oh wait
07:44:38 <coppro> exio4: has it
07:44:49 <coppro> if you are sequencing a lot of these, you could also use do notation
07:44:52 <exio4> or do { x <- mFoo ; f x } 
07:45:04 <coppro> do { x <- mFoo; y <- f x; g y; }
07:45:16 <benzrf> (a -> m (Maybe b)) -> Maybe a -> m (Maybe b)
07:45:50 <exio4> oh, `return Nothing`, sorry 
07:46:16 <benzrf> :t mapM
07:46:17 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
07:46:17 <Cale> humanoyd: That wouldn't be the fault of the spawnCommand
07:46:19 <albeit> Ah bind is good, I'm doing in a stateful computation so I didn't realize I could have multiple monads going at once
07:46:34 <benzrf> just use mapM albeit
07:46:42 <benzrf> i did this just yesterday!
07:46:50 <benzrf> check out the stuff that FTP generalized
07:46:52 <benzrf> good shit
07:46:53 <humanoyd> Cale: How do I find the culprit?
07:46:55 <lyxia> you'll need to join after mapM though
07:47:05 <benzrf> lyxia: not Maybe, i think
07:47:31 <benzrf> > mapM (\x -> [Just x, Just (x + 1)]) (Just 3)
07:47:33 <lambdabot>  [Just (Just 3),Just (Just 4)]
07:47:35 <lpaste_> kyclark pasted “State” at http://lpaste.net/137984
07:47:36 <benzrf> oh wait
07:47:45 <benzrf> > mapM (\x -> [Just x, Just (x + 1)]) (Nothing)
07:47:47 <lambdabot>  [Nothing]
07:48:05 <benzrf> > mapM (\x -> [x, (x + 1)]) (Nothing)
07:48:06 <lambdabot>  [Nothing]
07:48:13 <benzrf> > mapM (\x -> [x, (x + 1)]) (Just 3)
07:48:14 <lambdabot>  [Just 3,Just 4]
07:48:19 <benzrf> hmm
07:48:26 <benzrf> yep!
07:48:27 <albeit> Why is there no scanM?
07:48:32 <Cale> humanoyd: Break your program down into smaller pieces and make sure that each one isn't causing the execution of your program to stop?
07:48:38 <benzrf> wait no
07:48:40 <benzrf> bleh
07:48:45 <chreekat> albeit: you could also use the First newtype
07:49:06 <Cale> humanoyd: It's hard to suggest much if I don't know what your program is, or what is happening. IO actions don't just mysteriously get skipped.
07:50:03 <Cale> humanoyd: Does your program have multiple threads, and the main thread is terminating?
07:50:24 <lyxia> albeit: Wouldn't scanM be just some kind of traversal?
07:50:30 <Cale> humanoyd: If the main thread ends, the entire program ends, regardless of what the other threads are up to.
07:51:38 <humanoyd> Cale: It basically looks like `main = copyFiles >> startServer >> watchForChangesAndKillAndRestartServer`
07:52:06 <humanoyd> as soon as I take out `startServer` (with spawnProcess), the rest of the program works
07:59:45 <nkaretnikov> i always forget this: is there a way to combine guards and a case statement besides case () of _ | ... -> ... ?
08:00:19 <nkaretnikov> (would be nice if it worked with lambdacase)
08:00:33 <Cale> nkaretnikov: There's MultiWayIf... is that relevant?
08:01:45 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#multi-way-if
08:02:05 <albeit> Does "listToMaybe <$> (sequence $ mapMaybe f vals)" return the first Just (or Nothing if no Justs) from a monadic f?
08:02:54 <Cale> :t \f vals -> listToMaybe <$> (sequence $ mapMaybe f vals)
08:02:54 <lambdabot> Monad f => (a1 -> Maybe (f a)) -> [a1] -> f (Maybe a)
08:03:16 <albeit> Guess not :S
08:03:32 <Xe> I'm getting an error when trying to install the default yesod stack: Preprocessing library language-javascript-0.5.14.2...                                                                  
08:03:33 <albeit> How would I do "(a1 -> f (Maybe a)) -> [a1] -> f (Maybe a)"
08:03:34 <Xe> alex: /home/xena/.cabal/share/alex-3.1.4/AlexWrapper-monadUserState: openFile: does not exist (No such file or directory)                                                                                                                     
08:05:28 <Cale> albeit: I'd probably just write the loop/case manually
08:06:14 <nkaretnikov> Cale: i'm checking the result of getArgs.  i think getArgs >>= \case [onearg] -> if ... then .. else -> _ -> catchall would be nicer than multiwayif, wdyt?
08:07:36 <albeit> Cale: Shall do, thanks
08:08:00 <Xe> it seems to be missing a AlexWrapper-monadUserState
08:08:05 <Xe> file*
08:08:10 <Xe> but I have no idea where that would come from
08:08:24 <quicksilver> it seems likely that albeit wants to actual avoid running the actions past the first success
08:08:30 --- mode: ChanServ set +o monochrom
08:08:35 --- mode: monochrom set +b *!*@114.108.234.233
08:08:37 <albeit> quicksilver: I do indeed
08:08:40 --- mode: monochrom set -o monochrom
08:08:41 <quicksilver> I'm pretty sure none of the base combinators have that behaviour
08:08:47 <benzrf> who'd you just ban monochrom 
08:08:50 <quicksilver> there might be smoething in Control.Monad.Loop
08:09:17 <monochrom> annoy-o-tron
08:09:31 <benzrf> havent seen them talk o.o
08:09:47 <monochrom> see other channels you're in
08:10:07 <benzrf> oh
08:10:25 <quicksilver> firstM is close, but not quite
08:11:20 <monochrom> oh, false alarm, he/she is talking normally
08:11:24 --- mode: ChanServ set +o monochrom
08:11:31 --- mode: monochrom set -b *!*@114.108.234.233
08:11:35 --- mode: monochrom set -o monochrom
08:11:48 <annoy-o-tron> usually I just hang around and read posts
08:12:23 <Xe> it was because I had an old copy of alex and happy in ~/bin
08:12:26 <annoy-o-tron> I figured it would be a good way to learn
08:13:44 <lpaste_> Yuras pasted “Why doesn't it work?” at http://lpaste.net/137986
08:14:26 <Yuras> Hi, why the commented instance declaration ^ doesn't work?
08:23:47 <Yuu-chan> Is it possible to :t local variables in an expression?
08:24:03 <humanoyd> Cale: Sorry for wasting your time...I forgot to `cd` back into another directory...
08:24:16 <Yuu-chan> Like, meta-variables
08:24:19 <mniip> Yuras, what is 'named'
08:24:49 <mniip> oh
08:24:52 <mniip> nevermind I'm blind
08:24:53 <Yuu-chan> mniip: it's an argument of Wrap constructor
08:26:49 <lyxia> Yuu-chan: You can put a hole somewhere and the compiler tells you its expected type.
08:27:02 <lyxia> > (+ 1) _
08:27:03 <lambdabot>      Found hole ‘_’ with type: a
08:27:03 <lambdabot>      Where: ‘a’ is a rigid type variable bound by
08:27:03 <lambdabot>                 the inferred type of it :: a at Top level
08:27:19 <lyxia> uhm
08:27:36 <lyxia> that one was not very helpful...
08:27:39 <lyxia> > (+ (1 :: Int)) _
08:27:40 <lambdabot>      Found hole ‘_’ with type: Int
08:27:40 <lambdabot>      In the first argument of ‘+ (1 :: Int)’, namely ‘_’
08:27:40 <lambdabot>      In the expression: (+ (1 :: Int)) _
08:28:53 <Yuu-chan> > read _str + 1
08:28:54 <lambdabot>      Found hole ‘_str’ with type: String
08:28:54 <lambdabot>      In the first argument of ‘read’, namely ‘_str’
08:28:54 <lambdabot>      In the first argument of ‘(+)’, namely ‘read _str’
08:29:55 <Yuu-chan> lyxia: they can have any variable name that begins with an underscore, right?
08:30:07 <lyxia> right
08:30:38 <mniip> Yuu-chan, anything that is not in scope
08:30:49 <mniip> > let _a = () in _a
08:30:50 <lambdabot>  ()
08:31:14 <Yuu-chan> lyxia: mniip: thanks!
08:32:19 <mniip> Yuu-chan, I think contravariance is playing a part in this
08:32:25 <mniip> yes it definintely is
08:34:03 <Yuu-chan> mniip: if you're speaking about that existential typeclass, it's of Yuras
08:34:37 <mniip> oi
08:34:53 <mniip> indeed, sorry
08:36:19 <Gurkenglas> Annoyingly, modify and gets are not right inverses of execStateT and evalStateT.
08:36:38 <Yuras> mniip: you mean "a" in contravariant in "name" and covariant in "read", that is the reason?
08:37:12 <Yuras> does anyone know good reference on existential support in GHC?
08:37:52 * hackagebot turtle 1.2.1 - Shell programming, Haskell-style  https://hackage.haskell.org/package/turtle-1.2.1 (GabrielGonzalez)
08:39:38 <Gurkenglas> mtl imports and reexports names from transformers. How should I go about submitting a pull request to something in transformers that should be reexported by mtl? Just make two independent pull request that perhaps link to the other in the description, or just implement it in mtl directly, or what?
08:41:35 <Zemyla> Can I thank Haskell for making it nigh-impossible to have mutable global state in other people's code?
08:41:53 <monochrom> yes
08:42:07 <maerwald> it's easily possible
08:46:14 <Zemyla> maerwald: You have to write unsafePerformIO to do so, which should set off warning bells in someone's mind.
08:47:19 <maerwald> Zemyla: unsafePerformIO is just for escaping the IO monad
08:48:45 <maerwald> I think it's only marginally harder in haskell to have mutable global state
08:51:08 <monochrom> at this point you two only argue over the meaning of "possible"
08:51:11 <Zemyla> Well, you definitely need unsafePerformIO to create the state variable at the top level (look at System.Random), and if you're manipulating it outside IO functions you need more unsafePerformIO, and doing that is usually a sign that the code doing it is a horrible shitshow.
08:52:47 <monochrom> and completely overlook the more important fact that empirically very little Haskell code adds global mutable state
08:52:50 <maerwald> Zemyla: no reason to create it top-level, shove it into the codebase via reflection :P
08:53:37 <aweinstock> :t System.IO.Unsafe.unsafePerformIO $ Data.IORef.newIORef []
08:53:38 <lambdabot> GHC.IORef.IORef [t]
08:53:41 <Zemyla> monochrom: Yeah, precisely. I mean, compare it to a C program, where you can't hardly walk a foot without tripping over global mutable state.
08:54:51 <maerwald> global mutable state is not a bad thing per se, unless that state has high complexity in itself
08:56:54 <Zemyla> maerwald: Well, pure functions definitely should not be using it.
08:56:55 <maerwald> the problem is if the core of the program is an "implicit state machine"
08:58:52 <maerwald> OOP tried to tackle that implicitness via classes and made it even worse, because now everything is a state
08:58:59 <bitemyapp> monochrom: what's with the tuple sum thing?
08:59:00 <maerwald> in haskell, I often need less state, indeed
08:59:24 <monochrom> :)
09:01:10 <hodapp> Hmmm... If I'm accumulating two integers, but also building a list up as I go, what might that look like? Some combination of WriterT & StateT?
09:01:16 <hodapp> my monad-transformer-fu is weak.
09:01:47 <kclawl> I don't think you can even use IORef in a non-IO function safely?
09:02:06 <kclawl> (by safety I mean having predicatable results)
09:02:13 <bitemyapp> hodapp: you don't want WriterT
09:02:21 <bitemyapp> hodapp: like, ever. Just use a product type in StateT.
09:02:48 <hodapp> bitemyapp: why does one never want WriterT, ever?
09:03:04 <bitemyapp> how much do you like having heap? :)
09:03:04 <Gurkenglas> http://lpaste.net/137991 <- This pack-into-monad-transformers into forever into unpack-from-monad-transformers looks very lensy. Is there a better way to write that with that in mind?
09:03:20 <hodapp> bitemyapp: heap in what sense?
09:03:38 <bitemyapp> hodapp: http://stackoverflow.com/questions/7720929/space-leaks-and-writers-and-sums-oh-my
09:03:51 <hodapp> oh, that heap.
09:03:52 <NemesisD> anyone know of a way in ghci i can get the concrete type from a type family, i.e. type family Foo v :: *, i want to get what the type instance Foo Bar resolves to
09:04:07 <Iceland_jack> NemesisD: Looking for :kind! ?
09:04:09 <bitemyapp> hodapp: State covers anything you'd want to do with Writer. I know it offends a sense of orthogonality in most programmers
09:04:18 <bitemyapp> hodapp: but your problem can be solved by having a product in the State anyway.
09:04:21 <albeit> Why am I getting a "non-exhaustive patterns" error for this function? I can't think of any other patterns... http://lpaste.net/137993
09:04:28 <bitemyapp> since you're really just talking about two independent bits of state.
09:04:32 <bitemyapp> not a writer-and-a-state
09:04:41 <NemesisD> Iceland_jack: ah that seemed to do it, thanks!
09:04:53 <hodapp> bitemyapp: I just feel as if my code suffers in many places from me taking the roundabout way around something and hiding a higher-level pattern.
09:05:03 <hodapp> bitemyapp: but I'll avoid a WriterT and simplify things.
09:05:21 <NemesisD> btw is anyone here pretty experienced with groundhog?
09:06:02 <bitemyapp> hodapp: maybe? But if you're not stronk you'll just blow out your brain budget.
09:06:11 <bitemyapp> hodapp: get practice by doing the simpler, smaller, shallower thing first.
09:06:35 <bitemyapp> NemesisD: no but if you learn anything, please let me know. I'm on the look out for an alternative to esqueleto.
09:07:28 <maerwald> kclawl: even "unsafePerformIO" doesn't necessarily mean "unsafe". It just means the compiler has no way of knowing whether it is actually safe what you are doing.
09:07:35 <supki> albeit: is the OverloadedLists extension enabled?
09:07:36 <NemesisD> bitemyapp: in an (all but abandoned) personal project i've been playing with opaleye. i like the design/philosophy of groundhog more than persistent but the types are definitely more challenging
09:07:58 <albeit> supki: I actually just had a typo... wrote "mayMaybeM" instead of "mapMaybeM" ;)
09:08:20 <kyclark> I've got a question about mixing IO and State: http://lpaste.net/137984
09:11:04 <Gurkenglas> Why no type signatures?
09:11:57 <ctau> so confused... I am using 'stack test --rerun-tests' and no matter what I do to my Spec file (including just deleting everything in it), stack test says that spec passed
09:12:54 * hackagebot smallcheck-laws 0.1 - SmallCheck properties for standard type classes  https://hackage.haskell.org/package/smallcheck-laws-0.1 (jdnavarro)
09:15:16 <ctau> my problem is deeper than i initially thought - stack build keeps building successfully despite me intentionally breaking my code. 
09:15:34 <bitemyapp> ctau: add stuff to other-modules
09:16:05 <ctau> bitemyapp: just a random package? ok i'll try that
09:16:10 <kuribas> Do you generally write everything using State or use modify, state, etc...  Would it make a difference in efficiency?
09:16:34 <ctau> bitemyapp, sorry misread that as extra-deps
09:16:49 <bitemyapp> ctau: your modules that you're breaking
09:16:52 <bitemyapp> ctau: add them to other-modules.
09:17:45 <catgocat> Why does this trigger an error? > http://lpaste.net/137994
09:17:49 <kuribas> I currently write my functions using threading of state, and then use set, modify and get where convenient.
09:17:51 <catgocat> It's really simple code, can someone check it out?
09:18:23 <kuribas> :t toInteger
09:18:24 <lambdabot> Integral a => a -> Integer
09:18:37 <catgocat> yes?
09:19:03 <kuribas> catgocat: you want a to be an Integer, but it's not in the type signature.
09:19:35 <catgocat> kuribas: no, I want a to be an integral so I can map it over toInteger
09:19:43 <catgocat> in case it's an Int
09:20:17 <ctau> bitemyapp, thanks! I'm impressed with how quickly you sussed out the problem.
09:20:37 <kuribas> catgocat: toInteger returns Integer, so the type would be Integer -> Integer
09:21:02 <catgocat> type of what?
09:21:08 <kuribas> of a
09:21:17 <catgocat> no you're wrong
09:21:23 <catgocat> product will return an intenger
09:21:26 <catgocat> that's why I have to add integer to -> a
09:21:35 <kuribas> :t \n -> product [ 1 .. toInteger n ] 
09:21:36 <lambdabot> Integral a => a -> Integer
09:21:37 <catgocat> but I don't need to modify completely the type signature
09:21:46 <the_2nd> I have SomeFunc :: myType -> a -> myType
09:22:05 <the_2nd> and anotherFunc :: [myType] -> a -> myType
09:22:08 <kuribas> :t \n -> product [ 1 .. n ]
09:22:10 <lambdabot> (Enum a, Num a) => a -> a
09:22:11 <Gurkenglas> kyclark, I'm pretty sure that the compiler will spew errors that make more sense if you at least annotate the top-level names with their type signatures. (Or have you not done that because you don't know them?)
09:22:35 <kyclark> Right, I have not done that because I can't figure them out.
09:22:49 <the_2nd> anotherFunc many a = map someFunc HOW?
09:23:07 <bitemyapp> ctau: :)
09:23:28 <kuribas> :t \n -> product [1..n] :: Integral a => a -> a
09:23:28 <lambdabot>     Couldn't match expected type ‘a1 -> a1’ with actual type ‘r’
09:23:29 <lambdabot>       because type variable ‘a1’ would escape its scope
09:23:29 <lambdabot>     This (rigid, skolem) type variable is bound by
09:23:36 <the_2nd> = map (someFunc a) many
09:23:40 <the_2nd> wont work
09:23:57 <the_2nd> since someFunc requires myType as first param
09:24:00 <kuribas> catgocat: why do you use toInteger?
09:24:05 <the_2nd> do I have to define it differently
09:24:11 <jameseb> the_2nd: use flip
09:24:14 <the_2nd> or is there a way to call it correctly?
09:24:32 <the_2nd> jameseb, how to apply it in my case?
09:24:43 <kuribas> catgocat: if you want the output to be a different numeric type, use fromIntegral.
09:24:47 <ctau> bitemyapp, I still have some odd issues - any ideas? I intentionally broke a test, ran 'stack build && stack test', saw the error, fixed it, then re-ran 'stack build && stack test' and the error's still showing up
09:24:53 <jameseb> the_2nd: map (flip someFunc a) many
09:25:33 <bitemyapp> ctau: that's getting into strange territory.
09:25:58 <the_2nd> jameseb, thanks
09:25:59 <kuribas> :t \n -> product [1 .. fromIntegral n] -- catgocat
09:25:59 <lambdabot> (Enum a, Integral a1, Num a) => a1 -> a
09:27:03 <catgocat> http://lpaste.net/138002
09:27:06 <catgocat> what about this code ^ ?
09:27:09 <catgocat> can it be improved?
09:28:03 <ctau> bitemyapp: I have to edit the cabal file in order to get tests to re-run. do you think this is a stack bug? or am I not using stack correctly?
09:29:03 <martinvlk> @pl (\o -> uniq x o >>= (\b -> upd x o >>= ret b))
09:29:03 <lambdabot> ap ((>>=) . uniq x) ((. ret) . (>>=) . upd x)
09:30:37 <Gurkenglas> kyclark, I suddenly notice that this si probably not the right place for State. You should probably use something like foldr. I'll continue tinkering.
09:31:05 <kyclark> Hmm, interesting.  I'll think about that.
09:31:08 <albeit> ctau: Do you have your modules/files listed in other-modules in the .cabal file?
09:31:25 <bitemyapp> ctau: yeah editing the cabal file just triggers a full build.
09:31:35 <bitemyapp> ctau: did you add everything to other-modules?
09:32:05 <albeit> ctau: I ran into the same issue, when using old cabal they didn't need to be listed, but with stack they do
09:32:14 <ctau> I added my module to exposed-modules
09:33:09 <ctau> ok, now it's in other-modules, and breaking a test still does not trigger a re-run...
09:33:35 <ctau> albeit, bitemyapp: is there a flag for stack to just re-run a full build?
09:33:38 <bitemyapp> ctau: you need to post code.
09:34:08 <albeit> Is the .hs file that contains the tests listed in other-modules?
09:34:12 <kuribas> catgocat: what's sumdigitsfact?
09:34:28 <albeit> ctau: And I don't know about the full build...
09:35:00 <ctau> albeit: no, maybe that's my problem! so I need to list each spec?
09:35:09 <albeit> ctau: I believe so, yes
09:35:42 <ctau> albeit, bitemyapp: sorry I assumed you meant only source modules! didn't even think about the spec modules
09:36:37 <ctau> albeit, bitemyapp: do you use hspec-discover? does this defeat the purpose of it?
09:38:16 <Gurkenglas> kyclark, you keep accessing the last element of a list. In Haskell, lists are usually manipulated at the front, you can probably see why
09:38:36 <Gurkenglas> You can reverse the list after you're done if you need to
09:40:25 <ctau> bitemyapp, albeit: ok here's a slightly anonymized gist (can't directly post work code) https://gist.github.com/anonymous/e0dbef2f3c558682f61d
09:41:28 <catgocat> kuribas: it takes a number and produces a resulting output
09:41:37 <catgocat> which is the result of a boring algorithm
09:41:52 <ctau_> albeit, bitemyapp: sorry, lost my connection for a second. https://gist.github.com/anonymous/e0dbef2f3c558682f61d still not able to get stack to run my tests
09:43:28 <ctau_> oh, maybe hs-source-dirs needs test?
09:43:28 <albeit> ctau_: I'm not that familiar with all this, but I'm guessing you need other-modules listed in the executable, and possible the test-suite
09:44:18 <albeit> Actually probably just the executable section
09:44:25 <ctau_> albeit, bitemyapp: ok, yeah, my problem was simply missing the test sourcedir
09:45:04 <albeit> ctau_: Glad you got it figured it
09:45:27 <ctau_> albeit, bitemyapp: i am confused as to why cabal didn't complain about that, given I had modules listed in the library section that cabal presumably couldn't find. thanks so much for the help from you both!
09:46:09 <albeit> ctau_: I'm not sure why either. Someone told me yesterday that it was a loophole that worked in cabal, but stack closed that loophole. Not sure if thats accurate though...
09:49:09 <kuribas> catgocat: I have no idea what you are trying to do...
09:49:53 <ctau_> albeit, bitemyapp: I feel this does make hspec-discover pointless. i will do some more research and then maybe file an issue, if i can't find a workaround (if i do, i'll try to PR a wiki edit or something to the stack repo docs)
09:50:30 <bitemyapp> ctau_: don't use hspec-discover.
09:50:41 <bitemyapp> ctau_: make a main.hs/tests.hs for your tests and use that to load and run your tests.
09:50:44 <ttt_fff> anyone finding themselves using reader monad too much? it's like: (1) I have this recursive function, (2) I need to pass this aux data along all the time ... (3) therefore, let me use READER MONAD
09:51:54 <maerwald> ttt_fff: whats wrong with just an additional parameter?
09:52:08 <ttt_fff> don't you want to demonstrate to the world your mastery over monads?
09:52:08 <ttt_fff> I do
09:52:13 <maerwald> no
09:52:24 <ttt_fff> wait until I learn category theory
09:52:28 <maerwald> over-using monads is not elegant
09:52:59 <ctau_> bitemyapp: on a team of ex-scala folks, we still use the mental model of junit runners, so may not be able to convince others that hspec-discover is not worth trying to resurrect support for here...
09:53:36 <bitemyapp> ctau_: you really want to avoid tool bling fetishism in Haskell
09:53:51 <bitemyapp> ctau_: the number of people using any given tool is smaller, so maintenance isn't as good. You want to keep that surface area small.
09:54:13 <bitemyapp> ctau_: it's worth it to be using a nice language, IMO, but I keep my kit simple and reliable. Emacs (any text editor, really), hlint in my emacs, the REPL. That's it.
09:54:26 <bitemyapp> ctau_: you'll still have separate tests and test modules
09:54:35 <bitemyapp> you'll just have a unifying place where you run them.
09:54:58 <bitemyapp> you can ask hspec to run a particular test even if you have a main function.
09:55:24 <ctau_> bitemyapp: all your points are well-taken. losing hspec-discover is not going to make us switch back to scala....
09:56:06 <chattered> ttt_fff: Reader will save you some space so you won't have to pass the environment, but you'll lose space to your lifts, <*>, <$>, >>= and so on. I'm not sure I've ever used Reader on its own.
09:58:36 <Yuu-chan> Huh, installed Emacs+haskell-mode on the new machine, C-c C-l seems not to work out of the box, what am I doing wrong?
10:07:21 <Gurkenglas> kyclark, I tinkered until I finally accidentally saw what your code is supposed to do, and went off and implemented it sanely. http://lpaste.net/138011
10:08:48 <Gurkenglas> Oh wait you want to start with (0,0).
10:09:19 <maerwald> Gurkenglas: understanding haskell code is an accident xD
10:09:27 <Gurkenglas> There, added ". (:) (0,0)" http://lpaste.net/138011
10:10:15 <Gurkenglas> maerwald, I've heard worse of other languages. I find that if people use the proper abstractions/higher order functions, much code is easily readable.
10:10:51 <Gurkenglas> Like, tell me you can't tell what my paste is supposed to do :P
10:10:52 <maerwald> Gurkenglas: the problem with haskell functions is... it's rarely obvious how to read them (e.g. top to bottom)
10:11:14 <maerwald> some things you read from mid to top to bottom and back again
10:11:33 <tzaeru> I'm (very) slowly learning bits and pieces of Haskell. snippet at a time. haven't tried any useful projects with it yet. I keep frying my brain with the terseness though @,@
10:11:41 <maerwald> I love the doubly linked list example. It's horrible to read.
10:13:24 <ttt_fff> is there a short hand for:: <*> (return x) ?
10:13:38 <Gurkenglas> A doubly linked list is... a binary tree with the invariant that you be the right parent of your left child and vice versa?
10:14:00 <Gurkenglas> *right child of your left child
10:14:00 <maerwald> Gurkenglas: https://wiki.haskell.org/Tying_the_Knot#Migrated_from_the_old_wiki
10:14:01 <Gurkenglas> lol
10:14:09 <maerwald> see mkDList
10:14:38 <the_2nd> Gurkenglas, single linked
10:14:44 <the_2nd> node -> node -> node
10:14:46 <the_2nd> double
10:14:54 <the_2nd> node <-> node <-> node
10:15:16 <Gurkenglas> I know the theoretical definition, I wanted the haskell-definition :D
10:15:34 <maerwald> data DList a = DLNode (DList a) a (DList a)
10:16:08 <Gurkenglas> So a binary tree, like I said :P waiit do they all have to be cyclic?
10:16:19 <Gurkenglas> (cyclic or infinite that is)
10:16:22 <johnw> there should be a DLNil
10:16:43 <maerwald> johnw: it's cyclic and it is not defined for []
10:16:59 <tzaeru> I wonder if it's just me or if long strings of terse symbolic info such as "foldl f (f z x) xs" just turn into a spaghetti mess in the eyes of others too @,@
10:17:00 <johnw> maerwald: why is that the case?
10:17:22 <maerwald> johnw: because that's how the code is written in the example I linked
10:17:36 <johnw> oh, I was referring to doubly-linked lists in general, which is what I thought Gurkenglas was asking about
10:18:22 <maerwald> Gurkenglas: anyway... figuring out the laziness flow in mkDList is pretty "funny"
10:18:33 <maerwald> it's overlay tricky
10:21:52 <the_2nd> how does recursion syntax for two parameters look like?
10:22:01 <the_2nd> as in I want the first and second of the list
10:22:12 <the_2nd> (x:y:xs) ?
10:22:15 <Gurkenglas> http://lpaste.net/138011 <- closeGap is strict in its second argument even though both lines have the same head, right?
10:22:16 <maerwald> yes
10:22:31 <maerwald> the_2nd: (x:y:xs) is sort of syntax sugar for (x:(y:xs))
10:23:11 <maerwald> probably not correct to call it syntax sugar though
10:23:18 <maerwald> but it's the same
10:24:12 <the_2nd> If I want to have overloaded functions for several types
10:24:20 <the_2nd> what's the "normal" way of doing so?
10:24:24 <the_2nd> prefix the type name?
10:24:25 <tromp_> no, i wldnt't call a+b-c syntactic sugar for (a+b)-c
10:24:35 <the_2nd> typeaRead ::
10:24:38 <the_2nd> typebRead ::
10:24:56 <tromp_> that's precedence and associativity
10:25:27 <the_2nd> I wouldn't call anything syntactic sugar
10:25:32 <the_2nd> nor pythonic
10:25:45 <quchen> maerwald: x:xs is not sugar, it's how lists look like. [1,2,3] is sugar.
10:25:47 <chattered> the_2nd: Type classes were invented for ad-hoc overloading, but whether you want to use them depends on exactly what you are trying to do.
10:25:56 <tromp_> [1..3] is clearly syntactic sugar
10:25:57 <chattered> *ad-hoc polymorphism
10:25:59 <maerwald> quchen: I know that (:) is a function
10:26:12 <quchen> (:) is a special function, namely a constructor of the list type.
10:26:13 <maerwald> I was expecting nitpick to income...
10:26:30 <quchen> My point was more that bracket syntax is sugar.
10:27:14 <kuribas> Is it better to keep functions as "... -> state -> (result, state)" and use "state", or as "... -> State state result"?
10:27:42 <kuribas> I would think the extra boxing causes some overhead.
10:28:13 <quchen> State(T) is a newtype, so you don't pay anything for it.
10:29:51 <kuribas> ah, right
10:30:07 <quchen> "state" does a small computation though, but I doubt it matters much.
10:30:21 <quchen> http://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control-Monad-State-Class.html#line-61
10:31:36 <quchen> Wait, nevermind that, that was the default class definition. Go away, MTL.
10:31:36 <quchen> http://hackage.haskell.org/package/transformers-0.4.3.0/docs/src/Control-Monad-Trans-State-Lazy.html#state
10:31:40 <quchen> That's StateT's state.
10:31:46 <pikajude> would it be a big no-no to use NONLINE and unsafePerformIO to create a new global http-client 'Manager'?
10:32:06 <benzrf> pikajude: theres packages to do that for you, i think
10:32:12 <pikajude> really
10:32:20 <benzrf> ya
10:32:22 <benzrf> why do you want it?
10:32:23 <quchen> kuribas: return is a newtype wrapper (if you have Identity as your base), StateT is a newtype. So "state f" is operationally simply "f".
10:32:44 <quchen> Unless the (.) does something strange.
10:32:58 <pikajude> benzrf: i have a utility library that makes HTTP requests, the http-client library suggests reusing managers, and I don't have any logical place to keep the Manager otherwise
10:33:10 <kuribas> quchen: presumabling after inlining ghc will generate the same code?
10:33:37 <quchen> kuribas: I'd be surprised if it didn't. But even in the worst case the performance hit should be tiny.
10:34:23 <benzrf> pikajude: https://wiki.haskell.org/Top_level_mutable_state
10:34:50 <benzrf> pikajude: and there are libs like this https://hackage.haskell.org/package/safe-globals
10:35:20 <benzrf> pikajude: they still use the same trick usually i think, but they abstract over it which is nice
10:35:26 <pikajude> okay
10:35:59 <pikajude> that might be overkill for one little file
10:35:59 <nitrix> Hi, is there a more iomatic way to write this function? I feel like this "keep running IO actions in a list until one of those yields a Just value" is fairly common.
10:36:01 <nitrix> http://lpaste.net/138014
10:36:19 <shachaf> > run $ plus minus minus plus minus
10:36:20 <lambdabot>  "+--+-"
10:36:38 <pikajude> benzrf: but those libraries look like they're designed for putting simple values inside IORefs, not running an arbitrary IO action
10:36:38 <shachaf> How would you support brackets in this sort of syntax?
10:36:52 <arkeet> benzrf: I think that package is outdated? SampleVar doesn't exist in base anymore
10:37:05 <Gurkenglas> nitrix, https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:untilJust
10:37:42 <benzrf> argh
10:37:47 <benzrf> im not an expert :D
10:38:32 <Gurkenglas> nitrix, if that answer disappoints you, you could turn your Maybe a into an Either a () and use EitherT with forever.
10:38:39 <kuribas> benzrf: keep learning :)
10:38:44 <pikajude> my main concern is what actually happens with unsafePerformIO and NOINLINE
10:38:50 <Hijiri> pikajude: what's wrong with passing the manager around?
10:38:51 <pikajude> in the worst case, it'll just create a new manager every time I invoke it, right?
10:38:53 <kuribas> benzrf: neither am I
10:38:53 <Gurkenglas> no wait, not quite forever...
10:39:00 <pikajude> Hijiri: i don't really have anywhere to keep it
10:39:12 <Hijiri> when you start the program put it in an IORef or something
10:39:21 <nitrix> Gurkenglas: I was thinking MaybeT? It's not the same computation that I'm running. If you notice, it's running an IO on each element of a list and stops at the first successful one.
10:39:22 <benzrf> then the ioref needs to be global
10:39:27 <pikajude> this is supposed to be its own little module that does auth with Authy
10:39:35 <Hijiri> can't you pass the IORef to the threads that use it?
10:39:53 <nitrix> Gurkenglas: I mean, it's the same computation, but it's on each list element.
10:39:58 <benzrf> i will be back later :}
10:40:35 <Gurkenglas> nitrix, the Maybe monad's magic effect description is "Do everything normal until anything is Nothing, then be Nothing." You want the other way round. Either provides both sides.
10:41:11 <pikajude> Hijiri: yeah, but I would have to initialize it during "startup", and there's no logical "startup" stage for this module
10:41:34 <pikajude> since the only entrypoint is authenticate :: Token -> IO AuthResult
10:41:51 <pikajude> and I'd like the manager to be shared between multiple invocations of `authenticate'
10:41:55 <pikajude> if possible
10:41:57 <Hijiri> why not authenticate :: Manager -> Token -> IO AuthResult
10:42:04 <Hijiri> and then just invoke it with the same Manager
10:42:15 <pikajude> :(
10:42:20 <pikajude> ok
10:42:25 <Gurkenglas> Whoops, didn't look at your code. The second way might still work.
10:43:03 <kuribas> :t mapM
10:43:04 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
10:43:05 <Gurkenglas> I guess what you'd like is a FirstT.
10:44:34 <nitrix> Gurkenglas: What about ehm...
10:44:47 <nitrix> firstAvailable :: [Resource] -> IO (Maybe Block)
10:44:58 <Gurkenglas> lol
10:45:21 <nitrix> firstAvailable = runMaybeT . msum . map (MaybeT . providerRead)   or similar?
10:45:31 <Gurkenglas> More precisely, [IO (Maybe a)] -> IO (Maybe a)
10:45:50 <Gurkenglas> (We can even substitute m for IO)
10:46:47 <Gurkenglas> Huh, Monad m => MonadPlus (MaybeT m). That might work. Lemme look deeper.
10:47:13 <nitrix> I don't like it because it's not as obvious.
10:47:32 <nitrix> But I think the types and semantic matches.
10:49:34 <Gurkenglas> Yep, looks like it should work, mplus only evaluates the second argument if the first is Nothing. I've learned something, MonadPlus supplements the magic description of Maybe. I think I've learned that a few times the last few days, actually :s
10:51:01 <Gurkenglas> Once again (refering to an earlier question of mine), runMaybeT . msum . map MaybeT looks very lensy, is there a way lens can help here?
10:52:06 <nitrix> Probably, I'm still beginning though :/ 
10:55:17 <indiagreen> if I bump the version of the base dependency, should I bump major version of my package?
10:55:21 <indiagreen> (according to PVP)
10:55:48 <indiagreen> probably not, but then I also wonder whether I should bump 3rd or 4th digit instead
10:56:18 <Gurkenglas> nitrix, here's the ludicrous pack-unpack-fest my earlier question refered to if you wanna see :D http://lpaste.net/137991
10:56:20 <bennofs> do the version bounds on dependencies even affect PVP?
10:57:17 <indiagreen> bennofs: okay, I guess it's better to just look it up and be sure
10:57:42 <indiagreen> “Note that modifying imports or depending on a newer version of another package may cause extra orphan instances to be exported and thus force a major version change.”
10:57:46 <indiagreen> other than that, apparently not
10:58:05 <Gurkenglas> Though the fmap (either id absurd) probably doesnt belong on a line with what follows since it isn't quite part of the unpacking, and "StateT $ ((.) . liftM) ((),)" should really have its own name like modifyT
10:59:30 <johnw> Gurkenglas: how is runMaybeT . msum . map MaybeT different from just msum?
10:59:45 <johnw> > runMaybeT . msum . map MaybeT $ [(return (Just 1) :: IO (Maybe Int)), return (Just 2)]
10:59:47 <lambdabot>  Not in scope: ‘runMaybeT’
10:59:51 <johnw> > msum [(return (Just 1) :: IO (Maybe Int)), return (Just 2)]
10:59:52 <lambdabot>  <IO (Maybe Int)>
10:59:58 <johnw> anyway, they both evaluate to Just 1 in ghci
11:00:09 <johnw> (or rather, return (Just 1))
11:02:31 <Gurkenglas> Where is that instance coming from? https://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:MonadPlus
11:02:54 <Gurkenglas> Not in https://hackage.haskell.org/package/base-4.8.1.0/docs/System-IO.html either
11:03:42 <Gurkenglas> @instances MonadPlus
11:03:44 <lambdabot> Alt f, Either e, IO, Maybe, Seq.Seq, []
11:03:50 <Gurkenglas> 
11:06:05 <ttt_fff> does <$>, <*>, liftM#, liftA# guarantee the order in which the monads are executed?
11:06:12 <ttt_fff> err, the order in which they are >>= -ed
11:06:37 <the_2nd> Is there any direct way of solving such a system: ?
11:06:45 <the_2nd> http://pastebin.com/8zFWzjMy
11:07:08 <Taneb> ttt_fff, for <$> it doesn't matter, for the others it's the order they're written
11:08:03 <ttt_fff> f <*> g ; ... this is guranteed to be "f' <- f; g' <- g; return $ f' g'" ? i.e. guaranteed to not be "g' <- g; f' <- f; return $ f' g'" ?
11:09:40 <kadoban> ttt_fff: Yes.
11:09:47 <ttt_fff> kadoban: thanks
11:11:39 <aweinstock> @undo do { f' <- f; g' <- g; return $ f' g' }
11:11:39 <lambdabot> f >>= \ f' -> g >>= \ g' -> return $ f' g'
11:11:47 <aweinstock> @. pl undo do { f' <- f; g' <- g; return $ f' g' }
11:11:47 <lambdabot> (g >>=) . (return .) =<< f
11:12:17 <aweinstock> @do f <*> g
11:12:17 <lambdabot> f <*> g
11:18:05 <geekosaur> @redo f <*> g
11:18:06 <lambdabot> Maybe you meant: undo todo do
11:18:18 <geekosaur> oh well
11:18:28 <geekosaur> it doesn't really understand applicative anyway
11:19:01 <catgocat> What are haskell's arrays
11:20:26 <Fay> > list-of's
11:20:27 <lambdabot>      Not in scope: ‘list’
11:20:27 <lambdabot>      Perhaps you meant one of these:
11:20:27 <lambdabot>        ‘last’ (imported from Data.List),
11:20:34 <Fay> oops lol
11:20:44 <Fay> functors i think
11:21:07 <Fay> er is it an instance?
11:21:15 <justgage> Does anyone use Nix that I could pick their brain about?
11:21:43 <absence> catgocat: Data.Vector is one common possibility
11:21:55 <catgocat> what?
11:22:01 <catgocat> I asked what haske'lls arrays were
11:22:12 <absence> yes, and i answered :)
11:22:15 <mauke> catgocat: what kind of answer are you looking for?
11:22:19 <mauke> they're arrays
11:22:48 <Welkin> Arrays are arrays
11:22:59 <Welkin> some languages use their own jargon
11:23:10 <Welkin> python "lists" are *not* lists
11:23:12 <Welkin> for example
11:23:15 <Welkin> they are dynamic arrays
11:23:19 <mauke> sure, e.g. php's arrays are hashes
11:23:39 <absence> and c#'s ArrayList can really make you wonder :)
11:23:45 <mauke> not all lists are linked lists
11:23:49 <Welkin> hello dmj` 
11:23:51 <koala_man> Welkin: you mean they're not cons lists?
11:23:55 <mauke> e.g. there are shopping lists
11:23:58 <Welkin> koala_man: no
11:24:07 <dmj`> Welkin: yo
11:24:25 <Welkin> dmj`: I haven't seen you around in a while
11:24:35 <ttt_fff> I'm in ghci, I want to show all the data constructors of data type "Foo". ":i Foo" does not work well since it shows all instances that include "Foo" (and there's many of them) -- is there anyway in ghci to just "show me all the data constructors of this given data type, and nothign else" ?
11:24:44 <dmj`> yea, been heads down a little
11:24:59 <Welkin> ttt_fff: you can always look in the docs
11:25:10 <Welkin> that's what I do, rather than rely on ghci
11:25:16 <ttt_fff> Welkin: I want something that works nicely with my vim workflow
11:25:25 <ttt_fff> which includes sending commands to an ghci session, but no doc browser
11:25:40 <ttt_fff> how do I get cabal to generate docs for me?
11:25:58 <kadoban> 'cabal haddock' I believe.
11:26:10 <mauke> > dataTypeConstrs (dataTypeOf (undefined :: Maybe Char))
11:26:12 <lambdabot>  [Nothing,Just]
11:33:24 <Fay> :q!
11:33:25 <Fay> :q
11:33:33 <umib0zu> Hi all. Does anyone have any idea why this code has a syntax error on like 11? http://pastebin.com/ic7rbgFS
11:33:41 <umib0zu> line 11 my bad
11:33:57 <mauke> the compiler does
11:33:58 <johnw> just drop the "="
11:36:31 <monochrom> "sum a b = a + x"  who is x? and why is b not used?
11:36:39 <umib0zu> now what about this one? http://pastebin.com/bsJr514Z
11:36:40 <umib0zu> ahhh
11:36:45 <umib0zu> monochrom that’s another issue
11:37:05 <mauke> I see you have ignored johnw's advice
11:37:10 <mauke> and mine
11:37:32 <umib0zu> well slightly. why do we need to remove the = ?
11:37:43 <mauke> because you can only have one = in a definition
11:37:51 <mauke> foo x = = x + 1 is a syntax error
11:38:16 <umib0zu> huh?
11:38:23 <monochrom> if you use guards, the syntax is not "f x = | x>0 = x*x"
11:38:33 <absence> umib0zu: http://learnyouahaskell.com/syntax-in-functions#guards-guards
11:38:44 <forgottenone> is it possible to have infinite O(1) access sequence?
11:38:48 <umib0zu> that makes sense, but for the last one with if/else statements, I don’t understand
11:39:01 <absence> umib0zu: what is the error?
11:39:04 <monochrom> if you use if-then-else, then you are not using guards
11:39:04 <mauke> umib0zu: that's where my advice comes in: use a compiler; it'll tell you what's wrong
11:39:24 <shachaf> That's the method the pros use.
11:40:04 <Gurkenglas> How can I find where an instance is defined?
11:40:25 <Gurkenglas> (By asking lambdabot, ideally)
11:40:36 <johnw> :i will usually tell you
11:40:42 <johnw> (in ghci)
11:41:04 <mauke> lambdabot doesn't know these things
11:41:32 <nitrix> If I start replacing some `IO (Maybe x)` I have in my code by `MaybeT IO x`, I'll end up refactoring a lot of stuff, right?
11:42:05 <nitrix> It seems like the MaybeT is one of those cases that cascades super ridiculously.
11:42:09 <umib0zu> monochrom I mostly just asked why since I just wanted to know what was wrong with the syntax. It seems natural to use if then else, but again, the compiler says theres a syntax error on the else line
11:42:20 <umib0zu> mauke, I did use ghc. same error
11:42:36 <monochrom> well then I haven't investigated further.
11:42:36 <kadoban> nitrix: Really? I wouldn't think you'd have to change much at all. Possibly I'm missing something?
11:42:41 <Gurkenglas> nitrix, johnw earlier presented msum :: [IO (Maybe a)] -> IO (Maybe a)
11:42:55 <umib0zu> now of course I should use guards, but I was just wondering why the compiler doesn’t like if then else
11:42:58 <mauke> umib0zu: what do you mean, "same error"? you haven't given us any error
11:43:00 <Gurkenglas> (Though I don't know where taht alternative instance came from.)
11:43:09 <nitrix> kadoban: Or, I possibly I could `runMaybeT $ do ... ` to get the benefits of MaybeT without refactoring too much code?
11:43:30 <umib0zu> also, ps. should we always use guards instead of if/then/else?
11:43:41 <monochrom> it's up to you
11:43:42 <catgocat> Should I learn HUnit or HSpec first?
11:43:52 <dmj`> catgocat: both
11:43:53 <monochrom> it's up to you, too
11:43:54 <absence> umib0zu: use whatever is clearest
11:44:02 <kadoban> umib0zu: Not always … pretty often though.
11:44:03 <catgocat> dmj` first
11:44:16 <dmj`> catgocat: hspec is implemented in terms of hunit
11:44:23 <kadoban> nitrix: I guess I probably couldn't speak intelligently on it without trying it first, heh.
11:44:46 <catgocat> dmj` what should I dig around _first_ ?
11:44:50 <catgocat> which one *
11:44:56 <monochrom> @type runMaybeT
11:44:57 <lambdabot> Not in scope: ‘runMaybeT’
11:45:39 <monochrom> runMaybeT converts back to IO (Maybe a) :)
11:45:40 <Gurkenglas> @let import Control.Monad.Trans.Maybe
11:45:41 <lambdabot>  Defined.
11:46:14 <monochrom> well, I guess it does save a lot of "xs <- m; case xs of Nothing -> return Nothing"
11:48:00 * hackagebot esqueleto 2.2.12 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-2.2.12 (FelipeLessa)
11:48:05 <dmj`> catgocat: this is a good place to start, http://hspec.github.io/
11:48:25 <catgocat> but my question is if I should learn HUnit or hspec first :/
11:48:58 <dmj`> catgocat: do you plan on *not* learning the other?
11:49:13 <catgocat> of course not, I'm always learning that's why I asked learn _FIRST_
11:49:17 <dmj`> catgocat: you can learn either, I don't think one first will slow you down
11:49:30 <catgocat> just tell me the first one to dig uppppppppp
11:49:41 <catgocat> why is it so hard to answer
11:49:54 <catgocat> I'll check HUnit first anyways, thanks for the help .-.
11:50:25 <absence> catgocat: see, that wasn't so hard ;)
11:50:34 <monochrom> catgocat, personal preference questions, or even, God forbid, personal utility maximization questions, are all hard to answer.
11:51:02 <catgocat> monochrom: no they're not, what's your favourite color?
11:51:09 <catgocat> what's your favorite ice cream flavour
11:51:12 <monochrom> no, that is not what I mean
11:51:23 <catgocat> what's the best place to start haskell?
11:51:23 <mauke> catgocat: what's my favorite color?
11:51:36 <mauke> catgocat: what ice cream flavour should I study first?
11:51:46 <catgocat> what
11:51:55 <mauke> that's the kind of question you're asking
11:52:03 <mauke> you're asking us about *your* preferences
11:52:25 <monochrom> your questions are not "what is best for monochrom". I can answer those questions. your questions are "what is best for catgocat". I can't answer those questions.
11:52:33 <nitrix> Can you set a cabal repl "prompt" from the cabal file?
11:52:44 <emc2> If you want more than what HUnit gives you, I built a library called HUnit-Plus.  Code for HUnit should be mostly compatible with it.
11:53:09 <monochrom> you know what. from now on, I will answer none of your questions.
11:54:22 <the_2nd> is there a better way of doing this: http://pastebin.com/458d019p in haskell?
11:54:44 <dmj`> nitrix, in the .ghci file, echo ":set prompt \"λ: \"" >> ~/.ghci
11:55:05 <nitrix> dmj`: thanks
11:56:33 <spicydonuts> catgocat: your question was already answered: "dmj`: catgocat: this is a good place to start, http://hspec.github.io/"
11:56:35 <kadoban> the_2nd: There's better ways to do that in … everything. Do those things change, or is it all static values?
11:57:23 <the_2nd> static values but defined before runtime
11:57:30 <the_2nd> by some input (user or file)
11:58:00 * hackagebot esqueleto 2.3.0 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-2.3.0 (FelipeLessa)
11:59:12 <the_2nd> kadoban, ^
12:01:27 <kadoban> the_2nd: Oh I see, there's alternative ways to calculate many of them. Does it have to choose the optimum way I suppose? Actually I doubt that code actually is calculating the optimum way, but still …
12:01:50 <the_2nd> it finds a way if there is any
12:02:00 <the_2nd> feel free to tell me about better ways of doing that
12:02:08 <the_2nd> I already tried #math
12:02:37 <kadoban> the_2nd: I'd probably personally have to know more about what problem this is actually solving before I could answer.
12:04:01 <kadoban> the_2nd: It looks kind of like … it should be a pathfinding algorithm through a graph of possibly calculated values I guess?
12:04:43 <the_2nd> kadoban, functions connecting nodes (parameters)?
12:05:43 <the_2nd> kadoban, https://en.wikipedia.org/wiki/Gear
12:05:51 <kadoban> Where nodes are things like 'a' and 'eta_y' and etc. Except that doesn't quite fit either … can't be pathfinding because you need all of the requirements first, not just one path through.
12:05:55 <the_2nd> there's many many more parameters and functions than in that article
12:06:07 <the_2nd> usually one follows a very specific path to solve it
12:06:11 <the_2nd> but with my solution
12:06:21 <the_2nd> it is possible to solve it with any combination
12:06:33 <the_2nd> as long as there's any way of solving it with this input set
12:06:44 <kadoban> You can get /a/ solution with a topological sort of the graph … but no guarantees how good of a solution I guess.
12:08:15 <kadoban> the_2nd: Let me think about it a couple.
12:08:27 <the_2nd> kadoban, sure
12:09:01 <the_2nd> maybe using tons of Maybe and Just can force haskell to auto-solve it?
12:09:06 <kadoban> the_2nd: Hmm, how is the 'gear' link related?
12:09:19 <the_2nd> that's the problem I try to solve
12:09:53 <kadoban> the_2nd: Also … do you just need one final value that everything else is a possible sub-calculation for, or do you need every value? What's the output you need?
12:10:06 <the_2nd> ah
12:10:09 <kadoban> the_2nd: Like do you care about eta_v, or just some final value that it's based on?
12:10:15 <the_2nd> so you have N functions and K parameters
12:10:31 <the_2nd> k parameters as input, which is a subset of k
12:10:40 <the_2nd> and try to get as many of K as possible
12:10:53 <the_2nd> so the solution is the biggest possible subset of K or K itself
12:11:27 <the_2nd> "solved by 10%" "solved by 100%"
12:11:42 <kadoban> the_2nd: Hmm. I'm not really sure what that means :-/
12:12:32 <the_2nd> http://www.mb.uni-siegen.de/inko_schwarz/download/me2b/me-15-folien-zahnraeder.pdf
12:12:43 <the_2nd> you have all those parameters and their connections (functions)
12:13:07 <the_2nd> now someone want's to know as many of those parameters as possible
12:13:16 <the_2nd> by only providing parameter a, b and c
12:14:15 <the_2nd> e.g. "i" is defined with 3 functions
12:14:17 <the_2nd> page 3
12:14:26 <the_2nd> the algorithm should choose one of the 3 functions
12:14:34 <kadoban> the_2nd: So it's like some big interconnected system, and knowing some of the parameters you can infer others using the functions given, I guess?
12:14:43 <the_2nd> depending on which of the input parameters is already known
12:14:52 <the_2nd> yes exactly
12:15:08 <the_2nd> and I want it to follow all possible paths
12:15:15 <the_2nd> my solution does exactly that
12:15:22 <the_2nd> but it's really really ugly
12:15:25 <kadoban> Interesting. Hmm.
12:15:54 <M-ou-se> is it possible to have a fixed size array type in haskell? Something like 'Array Int 10'? Array would have to be '* -> Int -> *', i guess. is something like that possible at all?
12:16:47 <uwap> M-ou-se, that would require dependent types
12:16:59 <absence> the_2nd, kadoban: sounds like a combination of list and maybe monads could be used
12:17:01 <emc2> What uwap said
12:17:26 <uwap> there are ways to get dependent types working with haskell, afaik, but they are basically a pain in the ass so you don't probably want it
12:17:29 <kadoban> M-ou-se: Yeah, there's several Array types of various flavors. I think the first you'd want to look at might be the stuff in Data.Vector
12:17:52 <kadoban> M-ou-se: Oh maybe I misread the question … possibly ignore.
12:18:01 * hackagebot esqueleto 2.4.0 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-2.4.0 (FelipeLessa)
12:18:32 <kadoban> the_2nd: I'm sure I could represent the same thing in haskell better, but I suspect there's a better algorithm. Or do you not really care, it's fast enough, just writing it looks like crap?
12:18:51 <the_2nd> kadoban, well it is 2k lines already
12:19:02 <the_2nd> and I only have like 1/4th of all formulas
12:19:12 <the_2nd> so the smallest and nicest way is highly appreciated
12:19:36 <the_2nd> absence, interesting
12:19:39 <kadoban> the_2nd: Ah, okay. Let me try to think more on that then, heh.
12:19:50 <the_2nd> do you have any examples?
12:20:48 <M-ou-se> uwap: thanks. i'll try to find some articles on dependent types.
12:21:03 <M-ou-se> kadoban: yeah, not what i meant. thanks anyway :)
12:21:15 <kadoban> :)
12:21:54 <uwap> M-ou-se, if your problem is that your function just accepts lists of a certain length, you might have to go the other way around: returing into Maybe or Either.
12:22:05 <Zemyla> Who here is a really big expert on STM and nondeterminism?
12:23:01 * hackagebot aeson-casing 0.1.0.2 - Tools to change the formatting of field names in Aeson  instances.  https://hackage.haskell.org/package/aeson-casing-0.1.0.2 (andrewrademacher)
12:23:37 <M-ou-se> uwap: i don't really have a practical related problem right now. i'm just trying to learn about the type system. it surprises me a bit that i can't put an integer like 10 in the type system (easily), for example for the length of an array.
12:23:54 <ttt_fff> you want idris
12:23:56 <ttt_fff> or coq
12:23:57 <ttt_fff> or agda
12:24:03 <ttt_fff> or haskell with dependent types
12:24:08 <M-ou-se> :)
12:24:22 <ttt_fff> or, you want data MyArray = MyArray Int Int Int Int Int Int Int Int Int Int
12:24:23 <ttt_fff> that works too
12:24:40 <M-ou-se> sure, by counting unary, there are many ways
12:24:44 <uwap> M-ou-se, you should check out idris =) you could also ask in #idris. dependent types are awesome
12:24:58 <hiptobecubic> Wouldn't it only require dependent types if you wanted the ten to be determined at runtime?
12:25:08 <absence> the_2nd: for the selection based on available parameters you can use Maybe and Applicative/Alternative:
12:25:12 <ttt_fff> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/promotion.html also works
12:25:15 <absence> > let a = Just 3; b = Nothing; c = Just 2; d = Just 8 in (+) <$> a <*> b <|> (*) <$> c <*> d
12:25:16 <lambdabot>  Just 16
12:25:29 <johnw> M-ou-se: you can use 10 at the type level with GHC, you just need a few extensions turned on
12:25:44 <uwap> hiptobecubic, dependent types allow concatination of lists too. so (++) :: Vect n a -> Vect m a -> Vect (n + m) a
12:26:06 <hiptobecubic> you can make a data MyThing i = MT (Array Int) i or something, for example... i think
12:26:13 <hiptobecubic> uwap, sure but that's a different problem
12:26:17 <johnw> hiptobecubic: dependent types do not exist at runtime either
12:26:29 <absence> the_2nd: and lists can be used for non-determinism:
12:26:33 <M-ou-se> johnw: do you know which extensions?
12:26:34 <absence> > (+) <$> [1,2,3] <*> [10,20,30]
12:26:36 <lambdabot>  [11,21,31,12,22,32,13,23,33]
12:26:43 <johnw> M-ou-se: DataKinds, TypeOperators, import GHC.TypeLits, etc.
12:26:57 <M-ou-se> thanks! i'll read about those extensions
12:27:12 <Cale> johnw: Some of them almost inevitably have to.
12:27:27 <absence> the_2nd: can't say off hand if the combination will solve your problems, but it sounds like it's in the right direction
12:27:31 <johnw> Cale: like what?
12:27:44 <Cale> johnw: If you're matching on evidence, it needs to get carried around at runtime.
12:27:47 <the_2nd> absence, define all functions to return a maybe double
12:28:01 <the_2nd> and return nothing if not all parameters are given
12:28:02 <johnw> Cale: ah, you mean, if you're deciding on evidence
12:28:05 <Cale> yeah
12:28:15 <the_2nd> then just loop over all functions?
12:28:41 <absence> the_2nd: no, the whole point of the Maybe functor/applicative/monad is that your functions don't have to be concerned with whether the parameters are available or not
12:28:49 <Cale> Otherwise, e.g.  replicate :: a -> Vec n a  wouldn't know what to do
12:28:57 <absence> the_2nd: the underlying mechanism will simply not call the function if the parameters aren't available
12:28:59 <benzrf> vecna?
12:29:03 <absence> the_2nd: so you use Maybe for the parameters
12:29:16 <absence> but the functions just take Double
12:29:33 <johnw> Cale: well, there's an implicit {n : nat} argument there
12:29:35 <the_2nd> so the entire function definitions are just
12:29:43 <johnw> it's not the Vec n a "holding" the n, it's the implicit n being passed in
12:29:49 <the_2nd> func :: Double -> Double ... -> Double
12:29:49 <the_2nd> ?
12:30:05 <Cale> johnw: Yeah, I suppose you can always regard it like that
12:30:09 <absence> the_2nd: exactly, in my example i just used regular + and * operators
12:30:12 <absence> :t (+)
12:30:13 <lambdabot> Num a => a -> a -> a
12:30:39 <the_2nd> absence, I see
12:30:49 <the_2nd> currently my understand is
12:30:55 <the_2nd> that from the output parameters
12:31:08 <the_2nd> it walks backwards through their definitions
12:31:18 <the_2nd> until it reaches null values for all inputs
12:31:37 <the_2nd> will it walk backwards far enough, even if all current inputs are unknown?
12:31:48 <the_2nd> I'll just write a minimal example I guess
12:32:19 <absence> not sure if i follow what you mean by backwards, but if all inputs are unknown, the result is simply Nothing
12:32:31 <absence> > let a = Just 3; b = Nothing; c = Just 2; d = Nothing in (+) <$> a <*> b <|> (*) <$> c <*> d
12:32:32 <lambdabot>  Nothing
12:32:37 <absence> the_2nd: like that :)
12:32:52 <absence> neither function has enough parameters, so neither is called
12:34:00 <absence> alternative syntax:
12:34:12 <nitrix> Does <|> have higher precedence than <*> ?
12:34:15 <absence> > let a = Just 3; b = Nothing; c = Just 2; d = Nothing in liftA2 (+) a b <|> liftA2 (*) c d
12:34:17 <lambdabot>  Nothing
12:34:22 <absence> yes
12:34:24 <absence> er
12:34:28 <absence> lower
12:34:31 <arkeet> > (0$0<|>)
12:34:32 <lambdabot>      The operator ‘<|>’ [infixl 3] of a section
12:34:32 <lambdabot>          must have lower precedence than that of the operand,
12:34:32 <lambdabot>            namely ‘$’ [infixr 0]
12:34:33 <arkeet> > (0$0<*>)
12:34:35 <lambdabot>      The operator ‘<*>’ [infixl 4] of a section
12:34:35 <lambdabot>          must have lower precedence than that of the operand,
12:34:35 <lambdabot>            namely ‘$’ [infixr 0]
12:34:51 <nitrix> Lower number has higher priority?
12:34:55 <arkeet> lower is lower
12:36:03 <nitrix> So `a <|> b <*> c <|> d` becomes `(a <|> b) <*> (c <|> d)` ?
12:36:07 <arkeet> no.
12:36:10 <absence> > let a = Just 3; b = Nothing; c = Just 2; d = Nothing in ((+) <$> a <*> b) <|> ((*) <$> c <*> d)
12:36:11 <lambdabot>  Nothing
12:36:26 <arkeet> higher precedence groups first
12:36:36 <arkeet> (a <|> (b <*> c)) <|> d
12:36:46 <nitrix> Oh.
12:37:07 <nitrix> Oh yeah, infixl
12:37:54 <nitrix> What's the highest known precedence, 9? Is it a hard limit?
12:38:13 <catgocat> lol let inf = read "Infinity" :: Double
12:39:15 <sdegutis> How do you get a boolean of whether every item in a collection is equal?
12:39:17 <monochrom> nitrix: yes
12:39:44 <monochrom> sdegutis: what is "collection"?
12:39:52 <catgocat> sdegutis all (==x) [..]
12:39:56 <benzrf> hey ttt_fff
12:40:01 <catgocat> oh wait
12:40:04 <benzrf> catgocat: :}
12:40:10 <benzrf> monochrom: probably something foldable
12:40:10 <ttt_fff> benzrf: hey!
12:40:13 <mauke> length (nub xs) <= 1
12:40:13 <absence> > 1/0::Double
12:40:15 <lambdabot>  Infinity
12:40:26 <benzrf> ttt_fff: what should be the behavior of a spreadsheet with regards to, like
12:40:26 <ttt_fff> benzrf: how's haskell in a spreadsheet coming along?
12:40:47 <sdegutis> monochrom: sorry, list
12:40:49 <monochrom> I don't think Foldable is enough
12:41:01 <benzrf> ttt_fff: if cell B depends on cell A, and cell A is updated in such a way as to be invalid, e.g., a non-well-typed expression,
12:41:09 <benzrf> should cell B be updated with an error as well?
12:41:16 <kadoban> the_2nd: How extensive are the operations you can do? Is it limited to like … +, *, -, /  ?
12:41:17 <monochrom> sameness [] = True; sameness (x:xs) = all (x ==) xs
12:41:17 <benzrf> or should it keep its value until A is updated with something valid?
12:41:30 <benzrf> monochrom: foldable includes toList...
12:41:32 <ttt_fff> benzrf: interesting
12:41:40 <cads> hey, I was wondering, is it easy to embed haskell code in a c# project?
12:41:53 <ttt_fff> a :: Int, b = a + 2 :: Int, user stores "ocaml" in "cell a" ?
12:42:01 <monochrom> ok, toList is enough. my point is that I need to extract an arbitrary element (if non-empty) first. after that, it's a fold.
12:42:02 <ttt_fff> benzrf: i.e.   >> a :: Int, b = a + 2 :: Int, user stores "ocaml" in "cell a" ?
12:42:10 <kadoban> the_2nd: Like, what do the formulas look like to calculate the values?
12:42:24 <cads> I'm working with a graphical programming language called Grasshopper, and you can make addon components using C#
12:42:36 <cads> but it would be super neat if we could write components in hask
12:42:37 <benzrf> ttt_fff: no, that would update the value of a to "ocaml", which would cause an error in b when b is recalculated
12:42:46 <benzrf> ttt_fff: what if you put, say, '3 +' in a?
12:42:54 <benzrf> then a cannot have a value for b to be recomputed in terms of
12:43:27 <monochrom> @type all
12:43:28 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
12:43:36 <ttt_fff> benzrf: 3+ has type Int -> Int, where as cell a has type "int"; is there a way to just pop up an alert box and be like "hey dude, this should be an Int, but you gave me an Int -> Int; now go fix your shit" ?
12:43:44 <benzrf> should b error, or stay '5' or whatever until a has a value
12:43:50 <monochrom> I need to get used to the new generality.
12:43:51 <benzrf> i just meant as a syntax error
12:43:55 <sdegutis> monochrom: that's an excellent solution btw
12:44:01 <monochrom> thank you
12:44:01 <benzrf> put something else in if you prefer
12:44:04 <ttt_fff> benzrf: you're the one aking progress; I'm just here an an idea bounce box; what do you have in mind for the desired behaviour ?
12:44:15 <benzrf> im asking what you think would be correct
12:44:16 <LordBrain> cads, as far as i know, the way to do that would be to use the ffi to call haskell from c, and if you can call it from c, you use c#'s ffi to call the same functions the c would. 
12:44:28 <ttt_fff> I think cell "a" should refuse ot change its value until it gets an object of the right type
12:44:30 <monochrom> fortunately, new Haskell Platform is out, and I'm about to switch to it
12:44:44 <kadoban> the_2nd: I think I thought of a good way to do this (depending on your answer), but it'll take some explaining, probably in code, heh. PM me if you feel like it, back in a couple.
12:44:50 <benzrf> ttt_fff: meaning that the actual stringy contents of the cell should fail to update if they are invalid?
12:44:53 <LordBrain> although i have not done a lot in c#, i'm pretty sure you can call what they call unmanaged code, written in c
12:45:07 <benzrf> hmm... that could be a good approach
12:45:10 <catgocat> I am confused about doubles, floats, ints integers, realfracs, reals, nums 
12:45:15 <catgocat> where can I find a clear explanation?
12:45:24 <benzrf> @where numerical
12:45:24 <lambdabot> I know nothing about numerical.
12:45:26 <ttt_fff> benzrf: imho, what shold happen is: you try to update cell A, but the system can't parse cell A into an object of the right type; so then it puts a big red rectangle around cell A, and DOES NOT LET YOU EDIT ANYTHIGN ELSE until you fix cell A
12:45:26 <benzrf> @where numerical-hierarchy
12:45:26 <lambdabot> I know nothing about numerical-hierarchy.
12:45:28 <benzrf> meh
12:45:41 <ttt_fff> benzrf: ^^ so it just forces you to enter something into cell A of right right type
12:45:46 <benzrf> ttt_fff: that doesnt sound like good ux to me
12:45:57 <benzrf> not that i'm an expert
12:46:05 <benzrf> what if you, idk
12:46:10 <monochrom> this is the problem with @where. remembering the correct magic word is as hard as remembering the real data
12:46:12 <benzrf> delete a cell that has dependencies before deleting the dependencies
12:46:18 <benzrf> then it forces you to put it back
12:46:21 <ttt_fff> benzrf: otherwise you can have cell A, cell B, and all other cells ahve errors, and I'll be like WTF ... which one of these are "original errors" and which are "dependent errors"
12:46:29 <benzrf> well see
12:46:30 <ttt_fff> hmm
12:46:33 <benzrf> that's why i was asking
12:46:41 <benzrf> maybe B should keep its value based on the old value of A
12:46:44 <benzrf> even though A has an error
12:46:59 <benzrf> A continues to have its old 'actual value' until a new valid one is entered, perhaps
12:48:25 <ttt_fff> benzrf: also, note, the initial user base of this sytem is going to be people who are familiar with ghc type errors
12:48:39 <ttt_fff> benzrf: so a not-non-haskell-friendly-UI is not necessairly a problem
12:48:57 <benzrf> well yes
12:49:00 <benzrf> that's not the question :v
12:50:33 <Fylwind> edwardk: is there a reason there's no 'foldred' in Control.Lens.Fold? i.e. something like that takes a foldr-like function to produce IndexedFold?
12:51:10 <shachaf> It would be better for it to take a foldMap-like function, but I don't think that exists either.
12:51:22 <shachaf> It needs to be rank-2 to be useful, or something like that?
12:51:34 <I-Hate-Cheerios> does haskell have a foundation?
12:51:40 <I-Hate-Cheerios> like R does?
12:53:03 * hackagebot network-multicast 0.1.0 - Simple multicast library  https://hackage.haskell.org/package/network-multicast-0.1.0 (AudreyTang)
12:53:09 <edwardk> Fylwind: what would the type be? not quite seeing what you want
12:53:39 <edwardk> :t folding
12:53:41 <lambdabot> (Applicative g, Foldable f, Contravariant g) => (s -> f a) -> LensLike g s t a b
12:53:56 <indiagreen> @djinn ((a -> b) -> b) -> b
12:53:56 <lambdabot> -- f cannot be realized.
12:54:18 <benzrf> I-Hate-Cheerios: a 'foundation'?
12:54:35 <Iceland_jack> @google R foundation
12:54:35 <lambdabot> https://www.r-project.org/foundation/
12:54:37 <indiagreen> @djinn ((a -> b) -> b) -> a
12:54:37 <lambdabot> -- f cannot be realized.
12:54:50 <benzrf> oh
12:55:00 <benzrf> i thought you meant foundation as in like foundations of mathematics
12:55:02 <benzrf> :}
12:55:36 <ttt_fff> we have that too
12:55:49 <ttt_fff> data N = Zero | Succ N
12:56:04 * ttt_fff leaves the rest of the foundations to others to contribute
12:57:13 <catgocat> What is the the Rational and Ratio ?
12:57:27 <benzrf> Ratio is the type for ratios of numbers
12:57:37 <benzrf> Rational is an alias for Ratio Integer i think
12:57:42 <Cale> yes
12:57:47 <benzrf> type Rational = GHC.Real.Ratio Integer  -- Defined in ‘GHC.Real’
12:59:10 <Cale> Ratio a basically stores the numerator and denominator as separate values of type a
12:59:17 <Fylwind> edwardk: something like (forall b. (a -> b -> b) -> b -> s -> b) -> IndexedFold Int s a
12:59:29 <Fylwind> (not entirely sure if that type signature makes sense but I hope the intent is clear)
13:01:35 <edwardk> the intent is clear, but the type doesn't make sense to me so much, but lets see.
13:01:49 <edwardk> (forall b. (a -> b -> b) -> b -> s -> b) -> IndexedFold Int s a =
13:01:59 <edwardk> (s -> forall b. (a -> b -> b) -> b -> b) -> IndexedFold Int s a
13:03:18 <benzrf> indiagreen: if that type were inhabited then LEM would hold in intuitionistic logic
13:03:30 <edwardk> given your first definition built :: (forall b. (a -> b -> b) -> b -> s -> b) -> IndexedFold Int s a; built f s = ifolded (f (:) [] s)
13:03:46 <edwardk> :t \f -> ifolded . f (:) []
13:03:47 <lambdabot> (Applicative f1, Indexable i p, FoldableWithIndex i f, Contravariant f1) => ((a2 -> [a2] -> [a2]) -> [t] -> a -> p a1 (f1 a1)) -> a -> f a1 -> f1 (f a1)
13:04:22 <indiagreen> benzrf: I'm *just* sleepy enough to remember that djinn exists but nothing further than that
13:05:08 <edwardk> of course it works better if you could use (forall m. Monoid m => (a -> m) -> s -> m) -> Fold s a
13:05:13 <edwardk> then you get the right asymptotics for more things
13:09:21 <Fylwind> :t \ foldr -> conjoined (foldring foldr) (ifoldring (\ f z xs -> foldr (\ x g i -> i `seq` f i x (g (i+1))) (const z) xs 0))
13:09:23 <lambdabot>     Not in scope: ‘foldring’
13:09:23 <lambdabot>     Perhaps you meant one of these:
13:09:23 <lambdabot>       ‘folding’ (imported from Control.Lens),
13:09:54 <Fylwind> I tried that and it seems to fail the occurs check :(
13:10:05 <edwardk> you need to use an explicit type for that sort of thing
13:10:16 <edwardk> because it makes fundamental use of rank-2
13:12:01 <Fylwind> I guess it's because I'm using foldr with different type substitutions … but I don't know what the final type should look like though
13:14:41 <edwardk> building :: (forall r. (a -> r -> r) -> r -> s -> r) -> IndexedFold Int s a
13:16:10 <edwardk> building foldr = conjoined ... ...
13:16:24 <Fylwind> edwardk: thanks, this is what I came up with http://lpaste.net/138023
13:16:43 <Fylwind> edwardk: it's basically the same as folded, but generalized
13:17:10 <edwardk> *nods*
13:17:25 <edwardk> now the question is what to name it
13:17:29 <Fylwind> can this be done in a more elegant way though? using pre-existing combinators?
13:17:48 <edwardk> well you can desugar it by just having it generate a list and then walking the list in the respective folds
13:18:13 <Fylwind> I imagine 'conjoined' is a bit of an "implementation detail" so I dunno if I can rely on it
13:18:23 <ttt_fff> is there a way to tell cabal (not ghc) to just do type checking and no actual building of binary ?
13:18:42 <ttt_fff> (I have :reload in ghci for running the code, and I want cabal to do type checking + genrate errors so my editor can parse them and jump me to places)
13:18:58 <edwardk> conjoined there is doing precisely what you want
13:19:05 <edwardk> it is making it so you only pay for the index when you use it
13:19:10 <edwardk> this is its job
13:19:17 <coppro> ttt_fff: try --ghc-option?
13:19:34 <ttt_fff> cabal build -ghc-option ?
13:19:37 <kadoban> ttt_fff: Sounds like a job for something like (hdevtools or ghc-mod and possibly hlint) + syntastic or something like that
13:19:41 <ttt_fff> or to put it into my *.cabal file ?
13:19:50 <ttt_fff> kadoban: already usin ghdevtools + syntastic
13:19:54 <ttt_fff> but hdevtools only checks current file
13:20:02 <ttt_fff> unless you know of how to make it check all files and report in syntastic ... taht'd be ideal
13:20:05 <Fylwind> edwardk: right, but I heard you wanted to get rid of Conjoined some day
13:20:35 <kadoban> ttt_fff: Not sure
13:22:19 <catgocat> What is the difference between RealFrac and Floating ?
13:23:48 <Beardful> How do i convert [IO Integer] -> IO [Integer] ?
13:23:55 <Fylwind> catgocat: RealFrac don't necessarily have transcendental functions like sin, cos, exp
13:24:06 <nitrix> :t sequence
13:24:07 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
13:24:24 <catgocat> Fylwind: but what are RealFrac?? can you give me an example
13:24:34 <Beardful> nitrix: Thank you.
13:25:49 <hexagoxel> ttt_fff: sublimehaskell uses/reports this for your purpose: "running build commands: [['cabal', 'build'], ['cabal', 'build', '-v0', '--ghc-options=-fforce-recomp -Wall -fno-code']]"
13:25:52 <Zemyla> catgocat: A Rational is a RealFrac that isn't a Floating.
13:26:10 <Fylwind> catgocat: examples of RealFrac: Rational, Double; examples of Floating: Double
13:26:22 <Fylwind> (Float is in the same boat as Double)
13:26:24 <catgocat> these number types are all very confusing
13:26:37 <catgocat> so, can you guys explain me ?
13:26:40 <catgocat> so let's start with Num
13:26:41 <nitrix> Beardful: Where the Traversable t has an instance for [], so that ca be substitued and the Monad m has an instance for IO, so it becomes:   [IO a] -> IO [a]
13:26:53 <catgocat> there are two instances of Num, Real and .. ?
13:27:29 <kadoban> catgocat: Real isn't an instance of Num. Real is another typeclass.
13:27:40 <catgocat> kadoban: can we do private chat
13:28:20 <kadoban> catgocat: Not really interested in that, sorry. I like public (so people can check what I say, it's useful to other people, and I'm not obligated to continue if I get busy/bored)
13:28:36 <nitrix> catgocat: IRC can be overwhelming at first, but you'd benefit a lot more from having your problem public for greater exposure.
13:28:48 <nitrix> catgocat: We can follow multiple discussions just fine, no worries :)
13:28:53 <hexagoxel> catgocat: the 2010 report contains a graph of the num typeclasses [1], although it is not 100% accurate anymore. [1] https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1160006
13:28:58 <catgocat> But there is so much thing going on
13:29:00 <Beardful> nitrix: Huh, that's a very understandable explanation.
13:29:36 <hexagoxel> (down at 6.3)
13:30:10 <hexagoxel> in what ways is that graph wrong? i think the Show connection is wrong, uhm..
13:30:11 <kadoban> catgocat: Yeah it can take some time to understand conversations in IRC :-/ If your client is any good, it should at least highlight when your name is mentioned, so you can mostly ignore other stuff, largely.
13:30:26 <monochrom> also the Eq connection
13:30:36 <catgocat> kadoban: my client is webchat.freenode.net -> shit
13:30:45 <Fylwind> catgocat: here's a figure that answers "what is an example of X type class?" (still a work in progress) https://folv.es/numeric_typeclasses.XrVeYw7EIVa9R8jQNyA6og.png
13:30:46 <kadoban> catgocat: Ah, get a real one as soon as you can.
13:30:54 <nitrix> I think the webchat highlights in red and beeps :P
13:31:23 <Fylwind> catgocat: and here is a figure that answers "what kind of operations does X type class support?" https://rufflewind.com/img/haskell-numeric-type-classes.png (sorry for the color inconsistency)
13:31:31 <Chobbes> Is there a particular reason why Functor doesn't have a version of pure / return / etc...?
13:31:32 <ttt_fff> I guess this is good time I just start hacking on https://github.com/bitc/hdevtools
13:31:50 <catgocat> kadoban: how do I get "a real one"
13:31:58 <catgocat> Fylwind: that is a very useful image
13:32:32 <kadoban> catgocat: Install one that works on your computer. I'm … far from an expert. I just use konversation on KDE (linux) and it seems fine.
13:32:39 <Fylwind> catgocat: I use Quassel, you can also get HexChat, or Irssi if you like command-line clients
13:32:49 <catgocat> I have windows
13:33:07 <maerwald> catgocat: hexchat is available for windows
13:33:08 <catgocat> What is the best one personally for you guys, in windows?
13:33:15 <catgocat> HexChat?
13:33:21 <maerwald> yes
13:33:33 <fishythefish> catgocat: +1 for HexChat if you're on Windows.
13:33:43 <catgocat> Got it
13:33:45 <obadz> Just spent an hour building Leksah on NixOS. Very disappointed.. it crashed 3 times before I could open a file and then it crashed again when I got to File->Open. Gave up :(
13:33:50 <koala_man> when defining a monad, is there ever a reason not to define it in terms of a monad transformer over Identity?
13:33:53 <nitrix> Beardful: If you didn't know about Hoogle yet, it's an amazing website:  https://www.haskell.org/hoogle/?hoogle=%5BIO+Integer%5D+-%3E+IO+%5BInteger%5D
13:34:06 <catgocat> Also how does account registration works? I have registered, but then logged in, in another computer without password '-'
13:34:10 <lambdafan> hmm my hpaste is not being announced
13:34:13 <lambdafan> I will paste it
13:34:40 <lambdafan> http://lpaste.net/138024 - How would I increment or otherwise change a value in the record with "Simon-ness"
13:35:27 <monochrom> what is "Simon-ness"?
13:35:30 <lambdafan> There's some interesting things going on in that tutorial by Stephen Diehl, it's just somewhat perplexing in places.
13:35:37 <lambdafan> monochrom - it's explained
13:35:39 <catgocat> what do I enter on "network" ?
13:35:41 <catgocat> in the hexchat
13:35:42 <maerwald> something like baro-ness maybe?
13:36:08 <lambdafan> wait I think it is, let me check
13:36:33 <lambdafan> Oh I left out the explaination that is in the tutorial
13:37:16 <srhb> catgocat: We're on freenode. Not sure if it's just the name or a server address.
13:37:26 <monochrom> also, you must be using a 42-inch screen and liking it. because you have a very very long line, like 40 inches long.
13:37:30 <lambdafan> okay so there are two records Person1 and Person2, and a type Simon a. "-- Parameterized constraint kind for "Simon-ness" of a record.
13:37:33 <lambdafan> type Simon a = (Has a "name" String, Has a "age" Int)
13:37:49 <lambdafan> Has is a Class defined in the code I posted
13:38:00 <kadoban> monochrom: XD some editors wrap
13:38:51 <catgocat> srhb the link to the server is https://webchat.freenode.net/ ?
13:39:06 <ttt_fff> "cabal haddock" ==> "dude, your code is not a library" // okay ... can you still generate docs for me?
13:39:24 <srhb> catgocat: chat.freenode.net iirc.
13:40:17 <geekosaur> freenode should already be in the default server list in recentish hexchat
13:40:55 <monochrom> lambdafan: as far as I can tell, "Has" only has methods for reading out fields, not building records with new field values
13:41:13 <catgocat2> - test - 
13:41:17 <catgocat2> worked
13:41:19 <catgocat2> :p
13:41:35 <catgocat2> How do I log in my account?
13:41:49 <kadoban> catgocat2: /msg NickServ help     or most clients have an automatic way
13:42:03 <catgocat2> test
13:42:16 <Fylwind> ttt_fff: cabal haddock --executables … but yeah I find the error kind of pointless
13:42:18 <catgocat> this is cool
13:42:45 <ttt_fff> Flywind: yeah, that does the right thing, then it complains about y use of cpph2 / macros I think, but thanks :-)
13:43:05 <ttt_fff> catgocat2--
13:43:27 <catgocat> im catgocat
13:44:47 <lambdafan> monochrom: I'm thinking it's possible to make a constructor for Label called Put, and then make a "to" method, but the functional dependency is confusing me, among other things.
13:48:05 * hackagebot json-rpc 0.3.0.0 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.3.0.0 (XenoGenesis)
13:52:23 <bernd> 
13:53:41 <kurt21> Can I list the data constructors for a given data type in ghci?
13:54:14 <Welkin> kurt21: I usually look in the docs
13:54:18 <slomo> kurt21: :info type
13:54:20 <Welkin> you can try :info
13:54:35 <Welkin> it's not always that helpful though
13:54:41 <ww> didn't someone ask exactly that question earlier today?
13:54:45 <Welkin> ww: yes
14:03:05 * hackagebot json-rpc 0.3.0.1 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.3.0.1 (XenoGenesis)
14:08:06 * hackagebot json-rpc 0.3.0.2 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.3.0.2 (XenoGenesis)
14:18:58 <catgocat> d
14:20:14 <nitrix> Is there a haskell tool that'd show me the result of   mod <*> [1,2,3] as    [(`mod` 1),(`mod` 2),(`mod 3)]  ?
14:20:29 <nitrix> I think I got the operator wrong.
14:20:46 <nitrix> <$>
14:20:56 <lyxia> :t (mod <*>)
14:20:57 <lambdabot> Integral a => (a -> a) -> a -> a
14:21:32 <monochrom> maybe the simple-reflect library can do this. which lambdabot has
14:21:38 <lyxia> flip mod <$> [1,2,3] is what you wrote
14:21:49 <monochrom> > mod <$> [1, 2, 3] :: [Expr]
14:21:51 <lambdabot>      Couldn't match type ‘Integer -> Integer’ with ‘Expr’
14:21:51 <lambdabot>      Expected type: Integer -> Expr
14:21:51 <lambdabot>        Actual type: Integer -> Integer -> Integer
14:22:18 <monochrom> oh oops, it still can't. but I can try:
14:22:52 <monochrom> > map ($ a) (mod <$> [1, 2, 3]) :: [Expr]
14:22:53 <lambdabot>  [1 `mod` a,2 `mod` a,3 `mod` a]
14:23:28 <catgocat> Where can I learn more about Haskell's exceptions?
14:23:38 <nitrix> I was thinking to do:  mod <$> [1..10] <*> [1..]  to get ten remainders of numbers from 1 to infinity.
14:23:45 <nitrix> But debugging it is painful.
14:24:51 <bennofs> > flip mod <$> [1..] <*> [1..10] -- like this?
14:24:52 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,2,0,1,2,0,1,2,0,1,1,2,3,0,1,2,3,0...
14:25:15 <nitrix> Exactly, that's the missing part. I need to flip mod :P
14:25:52 <bennofs> > mod <$> [1..10] <*> [1..]
14:25:54 <lambdabot>  [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:26:29 <monochrom> this is surreal. iOS Game Centre recommends me to "friend" with: Michael Snoyman, Erik Hesselink.
14:29:16 <kristof> It occurred to me that applicatives are not really helpful in languages that don't have currying. Is this accurate?
14:29:57 <kadoban> kristof: Sounds accurate, but then again I'm not very inventive with that stuff.
14:30:09 <hpc> syntactically, sure
14:30:23 <hpc> you can probably still write fine abstractions with applicative stuff
14:34:56 <monochrom> we tell the "fmap and <*>" story of Applicative, which uses currying. but there is another story, "fmap and liftA2 (,)". I wonder if it relies less on currying
14:36:06 <monochrom> define <&> to mean liftA2 (,). the type is:
14:36:10 <monochrom> @type liftA2 (,)
14:36:11 <lambdabot> Applicative f => f a -> f b -> f (a, b)
14:37:04 <hexagoxel> is there a library for doing a set of calculations in parallel given a list/acyclic graph of dependencies between the calculations? (dependencies may just be constraints "dont start calculation A before B has finished")
14:38:16 <monochrom> so you can write "f <$> (getChar <&> getChar)" if f :: (Char,Char) -> Whatever
14:39:53 <monochrom> it does the same thing as "(cf <$> getChar) <*> getChar" if cf :: Char -> Char -> Whatever, cf = curry f
14:40:24 <hexagoxel> for example `ghc --make` or `cabal build` will compile stuff in parallel, but respecting the dependencies between modules. so i wonder if this is expressed in some library.
14:40:38 <Sindriava> TIL `:e` in GHCI opens the current module in $EDITOR
14:41:48 <monochrom> hexagoxel: a typical library on graph theory has "topological sort of directed acyclic graph". (and also a predicate to check "is this graph acyclic?")
14:42:05 <monochrom> so for example "fgl" has one.
14:42:57 <Sindriava> hexagoxel: `ghc --make` is equal to `ghc` now, AFAIK
14:43:08 <monochrom> "containers" also has one. module name Data.Graph :)
14:45:12 <hexagoxel> monochrom: but you still would want a specific order in order to prevent running into cases of "now i can only run one thing, because all else depends on it"
14:45:25 <hexagoxel> or is this aspect irrelevant in practice?
14:45:41 <monochrom> this aspect is both relevant and unsolvable
14:45:58 <catgocat> I am reading RealWordHaskell, and it seems the function try() is deprecated.
14:46:08 <catgocat> It is supposed to return "Left" in case of an error.
14:46:12 <catgocat> How can I bypass this?
14:46:22 <catgocat> (It now doesn't work as expected)
14:46:25 <monochrom> there is no circumventing a proved bottleneck
14:46:43 <hexagoxel> Sindriava: true. i just wanted to emphasize the specific feature
14:46:53 <monochrom> oh wait, topological sort is the wrong thing to use. it serializes
14:47:12 <Clint> catgocat: Control.Exception API changed ages ago, you're better off not reading RWH for it
14:47:34 <Sindriava> hexagoxel: Yeah, I'm trying to spread this, as lot of resources still include this and people then tend to be unaware of it :)
14:49:19 <monochrom> let me pose this question on the exam and let my students solve it :)
14:50:12 <Sindriava> :D
14:50:34 <broma0> Quick question about transformers: is there any best practice for their ordering in a stack? I'm using mtl's classes so i dont need to worry about lifting a bunch of times
14:50:38 <hexagoxel> monochrom: i believe a trivial "start at leaves and work upwards (parallelizing wherever possible)" is not optimal in general
14:51:10 <monochrom> oohhh, optimal. I feel that it is NP-complete
14:51:36 <hexagoxel> because you could work towards "serial bottlenecks" first, so you have stuff to do in the background while going through the bottleneck
14:52:09 <hexagoxel> i am a fan of good heuristics, so the solution does not have to be optimal
14:52:13 <Sindriava> hexagoxel: Could you just make it an partially ordered set and paralellize elements that don't have (<) defined?
14:52:24 <monochrom> I am weak at heuristics
14:52:40 <hexagoxel> monochrom: regarding the exam: great!
14:53:31 <Welkin> monochrom: how about against Hephaestus?
14:53:51 <hexagoxel> Sindriava: problem with resources is that you often want to be explicit. like write `install --only-dependencies`, even though --dep is nice as well.
14:54:09 <Sindriava> Ah
14:54:11 <hexagoxel> so people can easily look up what the flag does
14:54:20 <hexagoxel> and do not get confused by such shortcuts
14:54:33 <hexagoxel> but go ahead and keep spreading the word, just like it did there :D
14:54:54 <kadoban> broma0: When the ordering doesn't change the meaning, I don't think it matters. Usually it changes the meaning.
14:55:03 <Welkin> broma0: IO is always the innermost, since they stack inside out
14:55:35 <kadoban> Yeah, there's no IOT
14:56:21 <johnw> newtype IOT m a = IOT { runIOT :: m (IO a) }
14:56:24 <johnw> there could be such a thing
14:56:44 <johnw> an IOT is then just a builder of IO actions; kind of useless, but not impossible
14:57:11 <bitemyapp> IOT State Missiles
14:57:19 <johnw> yeah
14:57:26 <johnw> it uses some pure state to build an IO action that yields Missiles
14:57:29 <bitemyapp> an IO action for every missile, a chicken in every pot.
14:57:45 <broma0> kadoban: Welkin: thanks, i figured it didnt matter. just wanted to make sure there wasnt something unforseen
14:57:47 <bitemyapp> not very common as johnw said, but I could imagine it.
14:57:50 <broma0> thanks mtl
14:58:21 <bennofs> johnw: are you sure that works? How would you implement join / bind for that?
14:58:41 <johnw> oh, you're right
14:58:50 <johnw> m (IO (m (IO a))) wouldn't work
14:58:54 <johnw> ok, there's no IOT :)
15:00:15 <bitemyapp> bennofs: oh right, because you can't ever make IO go away.
15:00:44 <bitemyapp> no missiles, peace in the land.
15:00:51 <bennofs> yeah, you cannot pull anything "out" of an IO action
15:01:33 <johnw> no chickens in pots
15:01:56 <johnw> actually....
15:02:49 <bitemyapp> well nuts.
15:03:30 <lush> cu
15:04:32 <monochrom> I like chicken pot pies
15:04:40 <Cale> You can have that type of course, but it's not a monad transformer
15:09:40 <johnw> it's an applicative transformer, but not monad
15:19:03 <hexagoxel> Sindriava: ah, the wiki example [1] is nice: if you had 2 cores, and were to first process nodes 2 and 10, you were bottle-necked on 9. [1] https://en.wikipedia.org/wiki/Topological_sorting
15:19:18 <hexagoxel> (monochrom: ^)
15:20:14 <hexagoxel> so even the "prefer nodes that are deeper" approach can bottle-neck
15:20:50 <hexagoxel> "prefer nodes that are deeper, and also nodes with the most reverse dependencies"
15:21:07 * hexagoxel uses completely noobish vocabulary
15:21:53 <hexagoxel> now, which graph library has an implementation of that order?
15:22:39 <mniip> hexagoxel, "indegree"
15:23:09 <mniip> a node's indegree is the amount of edges ending in that node
15:23:26 <mniip> opposite of outdegree
15:23:27 <Sindriava> hexagoxel: Neat!
15:23:41 <hexagoxel> mniip: ah, thanks!
15:24:09 <Sindriava> hexagoxel: What are you trying to optimize?
15:27:56 <hexagoxel> Sindriava: well, basically the non-parallel processing time
15:28:13 <Sindriava> hexagoxel: I meant if it was something specific
15:28:28 <Sindriava> hexagoxel: You might be better of using an AI, if the cases will be very similar
15:35:22 <Sindriava> TIL there actually *is* a cond in haskell
15:37:40 <hexagoxel> Sindriava: the nodes are mildly large vectors of numbers, the calculation is just a large amount of numeric stuff
15:37:57 <Sindriava> I see
15:38:08 <hexagoxel> i don't understand how AI could help
15:43:34 <hexagoxel> (at least for this application)
15:47:53 <drewbert> I love stack.
15:48:10 * hackagebot ide-backend 0.10.0 - An IDE backend library  https://hackage.haskell.org/package/ide-backend-0.10.0 (MichaelSloan)
15:48:12 * hackagebot ide-backend-common 0.10.0 - Shared library used be ide-backend and ide-backend-server  https://hackage.haskell.org/package/ide-backend-common-0.10.0 (MichaelSloan)
15:48:14 * hackagebot ide-backend-server 0.10.0 - An IDE backend server  https://hackage.haskell.org/package/ide-backend-server-0.10.0 (MichaelSloan)
15:54:44 <aupiff_> drewbert: I have trouble getting stack to rebuild when I make modifications to my package code
15:55:12 <creichert> aupiff: Make sure it's mentioned in the 'other-modules' or 'exposed-modules' section of your cabal file
15:55:27 <aupiff_> make sure what is mentioned?
15:55:38 <creichert> the module which is not rebuilding?
15:55:42 <aupiff_> oh right
15:55:46 <aupiff_> great, will try that
15:56:12 <creichert> That seems to be the most common reason I've heard that complaint
15:57:42 <aupiff_> that was it, thanks!
15:59:02 <creichert> great
16:01:16 <drewbert> We just need to get stack support into ghc-mod, flymake, leksah, and all the other dev tools that rely on a traditional cabal setup.
16:02:20 <creichert> drewbert: if you're interested in trying flycheck, there was a pretty good post recently describing how to add a stack checker. I reused the code there and it's been awesome 
16:03:05 <kadoban> drewbert: Why? A .cabal file exists in a stack project too.
16:03:35 <creichert> well, it's very useful if you're working on multiple cabal projects at once
16:03:51 <creichert> and the stack file is in the root of a directory with many cabal projects
16:04:24 <kadoban> Hmm, I haven't used it like that so far.
16:11:08 <Sindriava> Hands down best feature of Haskell is the plethora of ways it has to *not name stuff*
16:11:30 <creichert> haha, do expand
16:11:52 <Sindriava> I guess that's why the Thompson-Wheeler logo won
16:13:11 * hackagebot json-rpc 0.4.0.0 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.4.0.0 (XenoGenesis)
16:18:02 <Sindriava> How bad of a practice is this: I have a function, that should return `IO a`, but I don't need that a anywhere yet, so I just `return $ error "a is not bound in …"`
16:18:28 <Sindriava> * "FIXME: a is not bound… "
16:18:47 <kadoban> Sindriava: Why don't you just make it IO () then?
16:18:48 <Sindriava> So I only have to code it when I need it eventually?
16:18:59 <Sindriava> kadoban: Because then I'd have to change the type signature in the future
16:19:26 <kadoban> Sindriava: … you'll have to change the code anyway, right? How hard is it to change the sig too?
16:19:58 <Sindriava> kadoban: Well, I think that changing a type signature is a bigger overhead, that could break code in more places
16:20:21 <Sindriava> kadoban: This is like a TODO comment, that's a bit more nagging
16:20:48 <Sindriava> kadoban: What I mean is: the API *should* by all means return IO a, I just don't want to code it right now :D
16:21:05 <johnw> Sindriava: I'd go with "wicked code smell".  Now, if the smell is bad enough that you'll fix it before anyone sees it, go for it; but in my experience, TODO comments like that are often permanent
16:21:06 <Sindriava> kadoban: Changing it to IO () is like saying "This shouldn't return a"
16:21:38 <Sindriava> johnw: TODO comments are, which is why I went with the error – this will actually crash the app the first time I try to use it
16:21:45 <johnw> in the Borland C++ compiler there was a comment that said, "Fire me if this code is still here after we ship", which I found 5 years after that particular comment had shipped
16:21:48 <kadoban> Sindriava: I dunno, it sounds like it smells pretty bad to me. I mean the whole point of having a type system that can encode this stuff is to use it.
16:21:50 <Sindriava> johnw: Which is like a kick in the butt to "go fix this"
16:22:33 <Sindriava> I mean, this is in no way to be permanent. It's just a way to make a TODO comment that's a bit more enforced on me
16:22:49 <johnw> 'this is in no way to be permanent' -- says, every programmer, everywhere, always
16:22:52 <kadoban> Sindriava: Yes, but it'll only crash if you happen to hit that at runtime, which if you often do that isn't guaranteed. So at that point you have a kinda tedious version of python's type system, at least in this small part.
16:23:00 <Sindriava> touché
16:23:24 <Sindriava> kadoban: the thing is, this function creates an OpenGL shader program, and returns it's ID
16:23:33 <Sindriava> Hmmm
16:23:57 <Sindriava> I like it, because it's better than a TODO comment, but it's kinda smelly, I agree
16:25:40 <drewbert> kadoban: seems like a lot of tools do not play nicely with stacks package database
16:26:34 <kadoban> drewbert: I haven't really noticed that so far, surprisingly. I don't use much though.
16:27:16 <drewbert> ghc-mod is what I notice the most...
16:27:40 <catgocat> What does it mean
16:27:46 <catgocat> when someone says "non-determinism" 
16:27:46 <catgocat> ?
16:29:39 <johnw> the output is not determined solely by the input
16:30:03 <johnw> in the case of the list monad, for example, the user is obligated to select the final answer from among the possibilities
16:31:04 <kadoban> drewbert: I /think/ hdevtools is mostly acting somewhat correctly somehow. I'm not really clear how though, or even if it is. I just haven't noticed it giving me nonsense yet I guess.
16:31:07 <Nik05> johnw how is list monad not deterministic? or i dont get it...
16:31:40 <johnw> [a] can be viewed as a non-deterministic 'a'
16:31:59 <kadoban> Nik05: The list Monad is non-deterministic in a different sense. It can be seen as … computation that can yield multiple possible results. So it's like computation on a non-deterministic machine.
16:32:40 <johnw> deterministic: a -> b, non-deterministic: a -> [b], where [] is monadic
16:32:51 <johnw> it is deterministic if you take the answer to be [b]
16:32:57 <johnw> non-deterministic if you view the answer as b
16:33:06 <Nik05> is it especiialy monadic?
16:33:11 <johnw> especially?
16:33:11 <kadoban> > (+) <$> [1..3] <*> [8..9]  -- if you see the two values as kind of … values with smudge factors, like "I know it's either 8 or 9"
16:33:12 * hackagebot http-listen 0.1.0.0 - Listen to HTTP requests and handle them in arbitrary ways.  https://hackage.haskell.org/package/http-listen-0.1.0.0 (akrasner)
16:33:12 <lambdabot>  [9,10,10,11,11,12]
16:33:39 <Nik05> well you mention [] is monadic, but does that matter in the indeterminisM?
16:34:01 <johnw> kadoban's example is non-deterministc in the applicative
16:34:26 <johnw> Monad is just a way of maintaining the non-determinstic nature of a computation through composition
16:34:45 <johnw> i.e., a -> [b] and b -> [c] => a -> [c]
16:36:21 <Nik05> oke right
16:36:32 <kadoban> Nik05: It's non-determinism more in the sense used in a non-deterministic turing machine, if that makes sense.
16:37:00 <kadoban> (Which is kinda the same sense, I guess, but … looking at it differently I think)
16:37:01 <Nik05> i have no idea what a non-deterministic turing machine is
16:37:08 <kadoban> Ah. Nevermind then.
16:37:25 <Nik05> i thought the hole idea was that the machine is deterministic
16:38:09 <mniip> Nik05, it is deterministic, as you can see the result of the calculation is very well defined
16:38:34 <mniip> it's just that it does multiple computations "simultaneously" and produces multiple results
16:38:40 <kadoban> Nik05: It is. This view of the list Applicative/Monad is … conceptual. It /can be seen as/ acting like a machine where instead of specifying one possible result, you can specify multiple.
16:38:46 <johnw> Nik05: it's really a difference of view point from outside vs. inside the computational domain
16:38:48 <Nik05> something like quantum computing?
16:38:50 <kadoban> Nik05: In the same way, Maybe can be seen as .. computations that can fail.
16:38:58 <kadoban> Nik05: Yes, something like that.
16:39:12 <Nik05> superposition of answers
16:39:26 <johnw> inside the domain, you work with things that present themselves as singular, but really are a spectrum; outside the domain, you get a list
16:39:29 <johnw> that might be why it's confusing
16:40:08 <Nik05> A Monoid is just a thing that can go from m m a -> m a, right?
16:40:10 <johnw> thus, although + doesn't work on lists, (+) <$> xs <*> ys makes sense, where xs and ys are a range of values
16:40:18 <kadoban> What's the temperature going to be tomorrow? [5..20] <-- that means it's somewhere in that range.
16:40:19 <mniip> Nik05, Monoid? no
16:40:25 <Nik05> ho monad*
16:40:36 <mniip> Nik05, need a 'return' too
16:40:38 <mniip> and a couple laws
16:41:53 <Nik05> a right it also needs pure from applicative
16:45:25 <ttt_fff> do questions about the haskell job market belong here or elsewhere?
16:45:44 <ttt_fff> question: who's the highest paid haskeller in the world? 
16:45:47 <hiptobecubic> ttt_fff, might as well try.
16:45:54 <benzrf> probably -blah, ttt_fff
16:45:56 <johnw> how would we know that?
16:46:27 <hiptobecubic> I made $70 mil last year in options in my private company, as valued by me.
16:46:34 <hiptobecubic> That's hard to beat.
16:46:52 <ttt_fff> so there's these google engineers being paid tens of millions / year
16:46:58 <ttt_fff> I am wondering if any of them as haskellers
16:47:01 <SaidinWoT> o.O
16:47:12 <SaidinWoT> google engineers are not paid tens of millions per year
16:47:20 <johnw> there are Haskellers at Google, this much we know; but benzrf is right that this belongs on #haskell-blah
16:47:29 <hiptobecubic> There are probably a few who are paid six digits
16:47:43 <ttt_fff> some google enginners are; see google senor fellows; okay, will stop conversaion here
16:50:51 <Sindriava> ttt_fff: I'll ask about Google haskellers for you ^^
16:53:56 <ttt_fff> hiptobecubic: 100,000 is g digits -- most ruby on rails programmers in SF can pull in that
16:54:06 <ttt_fff> where g = 6
16:54:50 <hiptobecubic> sorry, 6 zeroes
16:54:59 <hiptobecubic> you don't need to be in SF to make 6 digits :)
16:55:34 <pacak> #haskell-blah?
16:58:13 * hackagebot monad-resumption 0.1.2.0 - Resumption and reactive resumption monads for Haskell.  https://hackage.haskell.org/package/monad-resumption-0.1.2.0 (IanGraves)
17:01:52 <drewbert> kadoban: How do you get around the "Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal." error?
17:01:56 <Sindriava> Is there something like `m a -> (a -> m b) -> m a` ?
17:02:09 <pacak> :t (>>)
17:02:10 <lambdabot> Monad m => m a -> m b -> m b
17:02:16 <kadoban> drewbert: I haven't seen that? (yet?)
17:02:24 <pacak> :t const
17:02:25 <benzrf> Sindriava: interesting
17:02:25 <lambdabot> a -> b -> a
17:02:36 <benzrf> reminds me of (<*)
17:02:40 <benzrf> :t (<*)
17:02:41 <lambdabot> Applicative f => f a -> f b -> f a
17:02:56 <Sindriava> benzrf: Yeah, but that doesn't involve the a ->
17:03:00 <benzrf> yeah
17:03:02 <Sindriava> My intent is to do:
17:03:14 <benzrf> i know what you want :u
17:03:16 <Sindriava> id <- action; action2 id
17:03:30 <Sindriava> like id <- action >>= action2
17:03:46 <benzrf> uhh
17:03:58 <benzrf> @undo id <- action; action2 id
17:03:58 <lambdabot> <unknown>.hs: 1: 4:Parse error: <-
17:04:01 <benzrf> @undo do id <- action; action2 id
17:04:01 <lambdabot> action >>= \ id -> action2 id
17:04:05 <mniip> like 'action >>= action2'
17:04:22 <Sindriava> mniip: That doesn't bind id though :D
17:04:25 <mniip> except that ends in 'm b'
17:04:29 <mniip> not 'm a'
17:04:32 <Sindriava> mniip: Yeah
17:04:41 <mniip> you want 'm a' precisely
17:04:47 <Sindriava> I wanted to bind `id`, while still anonymously sequencing to another action
17:04:57 <Sindriava> for syntactical convenience, nothing deep
17:05:01 <mniip> you want to keep the monadic effect from the second argument, but not its result?
17:05:07 <Sindriava> mniip: Yup
17:05:21 <Sindriava> so it might as well be IO only
17:06:15 <mniip> k >>= liftA2 (>>) f return
17:06:32 <Sindriava> interesting!
17:06:32 <mniip> :t \k f -> k >>= liftA2 (>>) f return
17:06:33 <lambdabot> Monad m => m a -> (a -> m a1) -> m a
17:06:51 <Sindriava> mniip: Neat, thanks|
17:07:10 <Sindriava> That kill the syntactic conveniece, so I'm not going to use it, but still– Neat! :D
17:07:16 <mniip> I hope you don't use this in code :)
17:07:26 <Sindriava> mniip: Nope
17:07:32 <mniip> because for what it's worth, 'do x <- k; f x; return x' is simpler
17:07:43 <Sindriava> Yeah
17:08:04 <Sindriava> I was mostly curious if there's a sugar for it, basically
17:08:04 <mniip> I need to keep the (e ->) applicative trick in my head :o
17:08:09 <mniip> it's very useful
17:08:53 <mniip> Sindriava, define one
17:09:02 <mniip> not sure what would a good name be though
17:09:45 <Sindriava> Nah, it'd be too cryptic to be useful
17:09:47 <mniip> it's surely monadic, so < and =, but it's kinda like <* too
17:09:51 <mniip> <*=
17:09:52 <Sindriava> in this use case, that is
17:09:59 <mniip> snake head
17:10:19 <Sindriava> Hmm… Why not >? It's more like >>=
17:10:39 <mniip> it ignores the rhs
17:10:46 <mniip> well the data from rhs anyway
17:10:48 <Sindriava> Fair enough
17:11:02 <catgocat> What are the ghci breakpoints?
17:11:15 <catgocat> In :? there is `:show breaks                show the active breakpoints`
17:11:17 <mniip> <*>>=
17:11:31 <Nik05> catgocat do you know debugger breakpoints?
17:11:52 <Nik05> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html
17:12:18 <DanielDiaz> is it possible to create a default rule that works with a custom class? "default (...)" claims to work for the whole module, but it doesn't seem to have any effect for me
17:12:46 <catgocat> Nik05 I know what breakpoints are, but have no idea about them in ghci.
17:12:52 <DanielDiaz> I suspect it only works for Eq, Num, etc
17:13:17 <Nik05> catgocat well then just read the manual on how to work with them
17:13:36 <catgocat> What manual?
17:13:42 <mniip> DanielDiaz, it only covers the current module
17:13:44 <Nik05> ghci manual?
17:13:48 <mniip> it isn't exported or anything
17:13:49 <catgocat> I am on windows.
17:13:54 <catgocat> I don't have the man command.
17:14:03 <DanielDiaz> mniip: that's what I want, but it doesn't seem to have any effect at all, not even in the current module
17:14:07 <Nik05> catgocat i gave you the link...
17:14:08 <catgocat> Sorry, I'm a beginner.
17:14:12 <mniip> catgocat, that's not the manual
17:14:27 <catgocat> I don't see the link.
17:14:36 <catgocat> Oh I found it ehe
17:14:38 <DanielDiaz> mniip: I keep seeing ambiguous type errors
17:14:47 <mniip> catgocat, count 20 lines back
17:14:49 <catgocat> fuck opened in edge
17:14:50 <catgocat> no no close
17:14:57 <Nik05> catgocat https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html
17:14:58 <mniip> DanielDiaz, got some minimal example?
17:17:45 <lpaste_> DanielDiaz pasted “Custom Default” at http://lpaste.net/138032
17:17:58 <DanielDiaz> mniip: I think that might be a minimal example
17:18:00 <ttt_fff> there's a better way to debug, using monads to log stack frames
17:18:04 <lamefun> I have PackageInfo and PackageIndex modules, for example, I want to use them both in a single module, I can't of course use abbreviations (they're both PI), is there a standard naming practice for such conflicts?
17:18:51 <geekosaur> actually, as long as the names in those modules are not in conflice you can import them both as PI
17:18:56 <geekosaur> *in conflict
17:20:57 <lamefun> I'd prefer not to (what if those modules aren't mine?)
17:22:06 <lamefun> Can Haskell's package system declare two modules guaranteed conflictless?
17:30:16 <bitemyapp> Cale: you and kamatsu did a phenomenal job in that thread.
17:34:41 <drewbert> kadoban: are you using schell's hdevtools or bitc's?
17:36:28 <kadoban> drewbert: schell's I think? Whichever one is still maintained. I use it from stackage nightly
17:36:53 <drewbert> kadoban: ahhh, that's why you have no issues. ;-) K, I'm switching now.
17:37:13 <drewbert> The version from lts-2.20 is apparently not new enough.
17:37:18 <kadoban> Ahh
17:37:52 <drewbert> I was using ghc-mod, but even there master does not support stack yet, though there's a WIP pull request out.
17:37:53 <catgocat> Why does this: quux.txt > runghc WC
17:38:01 <drewbert> s/there master/their master/
17:38:03 <catgocat> write to the non-existant file "runghc"
17:38:10 * drewbert winces at his own typo.
17:38:16 <nkpart> What's the best way to derive the unboxed vector machinery for a newtype? I'm using vector-th-unbox right now, but because reasons I'm trying to get rid of template-haskell in this project
17:38:16 <catgocat> but this works: runghz WC < quux.txt
17:38:18 <geekosaur> because that's what it means?
17:38:18 <catgocat> why ?
17:38:27 <geekosaur> because > is redirect for output
17:38:47 <catgocat> isn't > the opposite of <
17:38:49 <geekosaur> it's not a thing pointing at the command
17:39:06 <geekosaur> <file redirects input, >file redirects output, 2>file redirects error output
17:39:29 <catgocat> ah got it
17:39:31 <catgocat> thanks
17:40:16 <begriffs> For any Haskellers in the Bay Area, wanted to let you know about the meetup happening next week. http://www.meetup.com/Bay-Area-Haskell-Users-Group/events/224291255/
17:40:22 <geekosaur> and the redirection can be anywhere in the command, so "foo < input" and "< input foo" do the same thing
17:42:52 <Sindriava> catgocat: | is used for what you want
17:43:11 <Sindriava> catgocat: cat quux.txt | runghc WC
17:44:31 <catgocat> Sindriava it's the pipe operator
17:44:35 <catgocat> but can't remember what it's used for
17:44:42 <catgocat> probably uses the left one as the input
17:44:46 <Sindriava> catgocat: I just told you mate
17:44:57 <Sindriava> catgocat: It redirects output of the left side to the input of the right side
17:45:06 <catgocat> yes cool
17:45:07 <catgocat> thx
17:46:06 <geekosaur> so where > and < work with files, | chains output of the command on the left to the input of the command on the right
17:47:04 <kadoban> drewbert: Right, yeah same I used to use ghc-mod … but it was kinda really slow for me, and then it doesn't even work with 7.10 so I've kinda abandoned it.
17:47:20 <kadoban> I was looking into ide-backend at one point, but I ended up not even being able to get it building so I gave up, heh.
17:48:48 <catgocat> What does _ mean in the :show bindings command? `let x = 3` => `:show bindings` => `x :: Num a => a = _`
17:49:03 <geekosaur> it hasn't been evaluated yet
17:49:36 <geekosaur> so when you write a numeric literal, it actually gets wrapped in a function call; since it's lazy by default, that function call hasn't happened yet
17:50:00 <catgocat> geekosaur: even when I type the variable, it evaluates it and prints it to the console
17:50:08 <catgocat> but still, when I check the bindings it's _ 
17:50:16 <geekosaur> (that's how numeric literals get a type "Num a => a"; if you write "3" the compiler reads "fromIntegral (3 :: Integer)"
17:50:35 <catgocat> So how can I evaluate x ?
17:51:04 <geekosaur> oh, you turned off the monomorphism restriction?
17:51:05 <catgocat> Is there any case where `:show bindings` will not show _ and instead the actual value?
17:51:16 <geekosaur> I think it may remain unevaluated in that case, so it can retain a non-concrete type
17:51:38 <catgocat> Hm ok
17:51:47 <catgocat> What you mean ` monomorphism restrictio `?
17:52:06 <geekosaur> oh, right, it's off by default, I'm on a debianish box with 7.6.3 and it's on by default
17:52:13 <catgocat> What is it?
17:52:52 <geekosaur> when you bind a name without parameters (like "let x = 3"), by default it forces it to be monomorphic (that is, have a specific type instead of a polymorphic one like "Num a => a")
17:53:13 <geekosaur> the reason this is done is that it prevents unexpected use of a lot of extra memory
17:53:41 <catgocat> Oh so it default to Integer for example?
17:53:45 <geekosaur> but in ghci it can be rather surprising, so in 7.8 and later ghci (but not ghc!) has it off by default, so you get polymorphic types for bindings to numeric literals
17:53:53 <geekosaur> since you don't normally worry about sharing in ghci
17:54:12 <geekosaur> right, when I do that here in ghc 7.6 the monomorphism restriction forces it to Integer
17:54:21 <catgocat> Yes, got it.
17:54:26 <catgocat> Is that a language extension?
17:54:30 <catgocat> Or a ghci option?
17:54:35 <ttt_fff> yes
17:54:37 <geekosaur> ghci option
17:54:41 <geekosaur> try ":seti"
17:55:06 <ttt_fff> geekosaur: in ghci, is there a way to tell ":i datatypename" to only show the datatype declarations, and NOT list the typeclass instances the datatype is involved in?
17:55:17 <catgocat> Is it -XNoMonomorphismRestriction ?
17:55:30 <geekosaur> catgocat, yes
17:55:40 <geekosaur> that's set by default in ghci 7.8 and up
17:55:44 <catgocat> `let x = 3` still has Num a => a tye
17:56:00 <catgocat> oh I need to unseti ?
17:56:06 <geekosaur> hm?
17:56:19 <geekosaur> :seti -XMonomorphismRestriction
17:56:29 <geekosaur> but that might not fix the existing binding;l you'd need to bind it again
17:56:38 <geekosaur> ttt_fff, not that I'm aware of
17:56:39 <catgocat> Works
17:56:46 <catgocat> How can I find the available ghci options?
17:57:00 <ttt_fff> @google ghci options
17:57:00 <lambdabot> https://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html
18:10:49 <Sindriava> Why can I write: `Integral a => a`, but not `Integral a, Integral b => a -> b` ?
18:11:01 <Sindriava> Should I use brackets even when there's only one constraint?
18:11:50 <catgocat> parentheses
18:12:01 <Sindriava> ?
18:12:19 <catgocat> (Integral a, Integral b) => a -> vb
18:12:22 <catgocat> b*
18:12:49 <Sindriava> ?
18:13:05 <Sindriava> Oh
18:13:11 <Sindriava> You might want to read the question again
18:13:24 <exio4> Sindriava: (C1,C2) represents a tuple of constraints
18:13:34 <pacak> Sindriava: Up to you
18:13:46 <Sindriava> pacak: Okay, thanks ^^
18:14:32 <Sindriava> exio4: I was curious whether two constraints requiring brackets implies I should use them even if there's only one constraint
18:14:41 <Sindriava> I might have worded that a bit better
18:15:09 <eds> I am trying GADTs with kinds here. If you can help me out, code and error: http://lpaste.net/137809 (beta version)
18:15:16 <exio4> oh, I thought it was more "why do I need to use brackets for 2+ constraints?"
18:15:58 <eds> Simpler GADT version, gamma. http://lpaste.net/137921. This is what I aim to achieve with the beta version.
18:16:43 <Sindriava> exio4: Yeah, the wording was a bit poor there, sorry about that. It's 3am x_x
18:17:51 <lyxia> eds: where's the error
18:18:11 <lyxia> eds: Oh I was looking at the second one only
18:18:18 <geekosaur> Sindriava, some people do, some don't
18:18:27 <eds> line 140. 
18:18:39 <eds> ohh ok. 
18:19:49 <lyxia> eds: Add the missing constraint to the instance definition
18:20:19 <slack1256> for something like the hyperlinked source code on base shown in reddit, I need something like codex instead of pure hasktags right?
18:20:31 <lyxia> eds: instance Rando (Expr vs a) => Rando (Expr vs [a]) where ...
18:22:40 <eds> it prompts rando is not a visible method of class.
18:22:54 <eds> class 'Expr'*
18:23:02 <eds> lyxia ^
18:23:37 <eds> at line 138
18:23:56 <Sindriava> :t liftA2 (<*)
18:23:57 <lambdabot> (Applicative f, Applicative f1) => f (f1 a) -> f (f1 b) -> f (f1 a)
18:24:22 <Sindriava> :i ((->)Int)
18:25:46 <lyxia> eds: Well, are you trying to define Rando (Expr vs [a]) rather than Expr vs [a] ?
18:29:01 <eds> lyxia: yea I made the change. My bad. Updated the code with new error: http://lpaste.net/137809
18:29:32 <Sindriava> ooh
18:29:58 <Sindriava> withAction f = action >>= liftA2 (<*) f unaction
18:30:47 <lethjakman> has anyone using yesod had issues sharing variables from the handler to the template?
18:31:11 <lethjakman> I declared a new variable in the handler and attempted to reference it in the template (just like the one they have in a freshly generated app) and it isn't accessable
18:32:06 <Fylwind> why is that 'data Foo t a = Foo (t a) deriving Show' is okay but 'data Foo t a = Foo (t [a]) deriving Show' not?
18:32:38 <Fylwind> GHC complains with: No instance for (Show (t [e]))
18:33:08 <Fay> okay can someone explain Deriving to me>
18:33:09 <Fay> ?*
18:33:10 <lambdabot> Maybe you meant: v @ ? .
18:33:20 <Sindriava> Fylwind: For a type to be showable, it's contents must be showable
18:33:26 <eds> line 151: there could be other instances like Expr vs Int, Expr vs Bool, Expr vs String. so it does not know which one will come across.
18:33:40 <lyxia> eds: Either you add the constraint in the definition of EL, or you somehow manage to implement Rando (Expr vs [a]) without Rando (Expr vs a)
18:33:42 <Sindriava> Fay: For some instances, GHC can figure out (derive), how to implement them
18:33:58 <Fylwind> Sindriava: well can't it wait until I instantiate the type? :\  I know 't [a]' will be Showable
18:34:03 <Fay> oh okay.
18:34:11 <Fay> thanks
18:34:12 <lyxia> eds: Oh right it doesn't know which a to pick, nevermind
18:34:34 <Sindriava> Fay: For example, you can easily derive Eq for data X = X a, since X a = X b ⇔ a = b
18:34:46 <Fylwind> I guess I need standalone deriving or something
18:34:48 <Sindriava> Fylwind: Hm… It should, I think
18:34:52 <eds> but I think that should not be a problem, right?
18:35:31 <Sindriava> Fylwind: It's weird that one case works and the other doesn't
18:35:42 <Sindriava> if a is Showable, so should be [a]
18:36:12 <Sindriava> Fylwind: Does this error happen when you don't use the type?
18:36:14 <lyxia> eds: It is a problem. You're trying to generate a value, but you can't if you don't even know its type
18:36:21 <Fylwind> Sindriava: yes
18:36:21 <Sindriava> Fylwind: e.g. when it's just defined, not used
18:36:34 <Sindriava> Fylwind: Hm… Then I have no clue what's going on, sorry :(
18:38:08 <eds> Is there a way to let it know that a will be either Int or Bool and nothing else? lyxia?
18:38:28 <ttt_fff> Either int Bool
18:38:48 <lyxia> eds: You have to tell which it is.
18:38:53 <lyxia> eds: It can't be both
18:38:55 <ttt_fff> Either int Bool
18:39:31 <ttt_fff> Either Int Bool
18:39:50 <eds> ttt_fff - let me try that
18:40:31 <dmwit> Fylwind: GHC *could* derive an instance that had `Show (t [a])` in its context, but I expect this would fall afoul of the conservative decidability check.
18:40:38 <dmwit> Fylwind: So it probably doesn't try.
18:40:54 <Fylwind> dmwit: hrm I see!
18:41:34 <dmwit> Confirmed: the obvious standalone-deriving clause needs UndecidableInstances.
18:42:04 <dmwit> So my guess is that's what's happening there.
18:46:55 <ttt_fff> my haskell prog has outputeed an HTML file (a SVG file actually); is there an easy way to go SVG ==> PDF? I can't just open it up in chrome and press print because the image is WIDER than 8.5 in x 11 in (it's wider than 11in also, so landscape does not solve the issue)
18:48:03 <Fylwind> dmwit: hm, is there a way to avoid UndecidableInstances in this case? :\
18:48:06 <dmwit> eds: My suggestion would be to write something like `data TypeRep a where TBool :: TypeRep Bool; TInt :: TypeRep Int; TList :: TypeRep a -> TypeRep [a]` along with `class Reppable a where typeRep :: proxy a -> TypeRep a; instance Reppable a => Rando (Expr vs a)`.
18:48:41 <dmwit> Fylwind: Perhaps with the `Show1` class that I think exists somewhere.
18:50:04 <dmwit> eds: Presumably you would need ExprW to carry around a TypeRep as well, of course.
18:50:37 <dmwit> eds: data ExprW where ExprW :: TypeRep a -> Expr vs a -> ExprW -- or something
18:53:20 <dmwit> Fylwind: instance (Show1 t, Show a) => Show (Foo t a) where showsPrec n (Foo v) = showsPrec1 n v -- works for me
18:53:43 <Fylwind> dmwit: hrm I guess there's no way to automatically derive that then
18:53:54 <dmwit> no
18:55:10 <dmwit> Fylwind: Another possibility: `data Foo t a = Foo (Compose t [] a)`
18:56:02 <ctau> hi, question: is there a function or module in the prelude for approximate comparison of two doubles? knowing that several edge cases exist for this task, i'm leery of trying to write my own if there's a haskell-ish way to do it
18:56:04 <dmwit> Fylwind: Seems to be fine tacking `deriving Show` on the end of that.
18:56:10 <dmwit> Fylwind: So you might consider using that.
18:57:21 <Fylwind> dmwit: interesting, though not sure if it's worth adding that complication … I may as well just derive it for specific values of 't' since I only plan on using like 2-3 of them
18:57:31 <Fylwind> dmwit: thanks for the suggestions though! ^.^
18:57:52 <ctau> hunit and I think, Data.Eq.Approximate are options I found on haskell, but the latter seems to have few reported downloads, and I don't want to import hunit into my main code if avoidable
18:58:05 <ctau> sorry, on hackage*
18:58:42 <dmwit> ?tell ttt_fff inkscape will happily convert SVG to PDF
18:58:42 <lambdabot> Consider it noted.
19:00:36 <ctau> oh, is the answer to my question https://hackage.haskell.org/package/ieee754 ? quite a few more downloads there...
19:08:11 <ReinH> ctau: http://haddock.stackage.org/lts-2.21/statistics-0.13.2.3/Statistics-Function.html has within
19:08:16 <ReinH> and is a very reliable package
19:08:19 <eds> dmwit- so as I was saying. I think my take on building the tree is wrong. earlier recommendation to me - As long as you only use V IZ and V (IS IZ) as leaves. So it's exactly the same as how you generated random Expr Int's you made a tree with branches of + and * and leaves of I but now here it's the same thing generate a tree with branches of + and * but leaves of V IZ and V (IS IZ) the same code should actually work identically. 
19:08:36 <eds> If you replace I with V IZ/ V (IS IZ) that'd be like an instance Rando (Expr (Int ': vs) Int) where ... which would be exactly your instance Rando (Expr vs Int) except instead of making an I at the leaves, you'd make an V IZ instead so now it's easy to generate random functions using combinations of (+) and (*) just swap out I 5's for V IZ. 
19:08:57 <eds> instance Rando (Expr (Int ': Int ': vs) Int) would be the same, but you can pick randomly between V IZ and V (IS IZ) because V IZ can unify with Expr (Int ': Int ': vs) Int and V (IS IZ) can also unify with Expr (Int ': Int ': vs) Int . They both unify so you can use either of them as leaves of your tree so just swap out I 5's for those
19:11:01 <ctau> ReinH: thanks! that also looks like a good fit. the ieee754 package looks actively maintained so I also think it looks pretty nice. glad to have options :)
19:13:17 <dmwit> eds: That sounds like it's solving a very different problem from the one you state in your paste.
19:13:24 <dmwit> eds: Have you made some progress since that paste?
19:15:49 <dmwit> eds: I can make your paste compile by writing: EL <$> (rando d `asTypeOf` return (List [I 5]))
19:16:02 <dmwit> eds: The `asTypeOf` part fixes an instance to use.
19:16:07 <eds> yea. I took a different approach at building the tree. 
19:16:31 <dmwit> Okay. Well, if you want to ask a question about different code... you should show that different code. =)
19:16:34 <ReinH> outer parens are optional
19:16:35 <eds> ahh
19:16:37 <dmwit> I'm heading out, though.
19:16:50 <ReinH> er no, b/c of ``
19:17:32 <eds>  No it is the same code. anyways thanks
19:17:38 <dmwit> ReinH: You're right, they do seem to be optional. But I wouldn't really expect a reader to know the precedence of (<$>) vs asTypeOf, so I think it's sane to leave them in anyway.
19:17:56 <ReinH> Well, I don't and I'm the one that mentioned it so
19:22:32 <slack1256> @where ltext
19:22:32 <lambdabot> I know nothing about ltext.
19:23:10 <carter> Luke: i have a build if you want a nice build
19:23:26 <Luke> carter: ghc?
19:23:55 <carter> ghc
19:23:58 <carter> yes
19:23:58 <carter> for mac
19:24:04 <carter> my artisanal build
19:24:12 <carter> i dont use brew for haskell
19:24:28 <Luke> oh
19:24:38 <Luke> i thought you were committing to the brew formula for ghc
19:24:40 <carter> its easy to install the mac bin dist
19:24:42 <carter> fuck no
19:25:01 <carter> i'm still holding a grudge from 1-3 years ago against them
19:25:15 <carter> even though i use brew for everything else
19:28:55 <ReinH> carter: o/
19:29:31 <ReinH> carter: free range binaries?
19:30:03 <carter> ReinH: or at least they have a GCC built RTS, so the GC perf should be ~ 10% better on some OSX versions
19:30:19 <ReinH> nice
19:30:54 <carter> yah want?
19:31:00 <carter> we're already using it at work
19:31:04 <carter> so it must be enterprise ready
19:31:14 <ReinH> nah
20:05:42 <Nik05> how has done CIS194 (2013) exercise 5 of week 5? Are there some mistakes in this exercise?
20:06:21 <Nik05> who*
20:07:22 <gamegoblin> Is there any typeclass which expresses the notion of "un-cons"? e.g. a general type that I can destructure to a head and a tail?
20:13:45 <carter> gamegoblin: splittable?
20:16:32 <rrbm> Nik05: i've done it, what are you stuck on?
20:17:46 <Nik05> well it has this StackVM modules with Boolean support, but that isnt used at all in the exercise. Is that correct?
20:18:29 <Nik05> Then it says stackVM exp == Right [IVal exp] with exp :: Expr a => a. But stackVM only takes an Program not a Expr a => a
20:20:01 <Nik05> rrbm it feels like a messy exercise...
20:22:42 <Nik05> oke that Boolean stuff is just there for the story
20:23:00 <Nik05> but the part that it says stackVM exp == Right [IVal exp]...
20:27:12 <rrbm> Nik05: yeah, i noticed this course makes you work to see the answer
20:27:59 <rrbm> the Right [IVal exp] is a hint, there's a function you can steal from StackVM to put in your compile function
20:29:56 <Nik05> rrbm i dont get it
20:30:58 <rrbm> maybe i jumped too far ahead
20:31:00 <Nik05> exp :: Expr a => a, and then stackVM exp == Right [IVal exp] 
20:31:17 <Nik05> stackVM only takes a Program not Expr a => a
20:31:19 <rrbm> so first you have to make instance Expr Program
20:31:34 <Nik05> i already did that
20:31:47 <Nik05> but that doesnt change the type of stackVM, right?
20:31:57 <Nik05> stackVM :: Program -> Either String StackVal
20:32:35 <Nik05> not stackVM :: Expr a => a -> Either String StackVal
20:33:17 <rrbm> well what's a Program?
20:33:48 <zwerdlds> anyone free to help a total newb?
20:34:04 <bitemyapp> zwerdlds: no, we are very expensive.
20:34:11 <Nik05> rrbm its [StackExp]
20:34:16 <zwerdlds> damn.  lol
20:34:29 <bitemyapp> zwerdlds: Saudi Oil Lords dream of entertaining Haskellers for a weekend in their palatial estates
20:34:35 <bitemyapp> zwerdlds: wining us...dining us...
20:35:07 <zwerdlds> engaging in discussions of bertrand's paradox
20:35:47 <zwerdlds> bitemyapp: :]
20:37:13 <carter> bitemyapp: i'm working on training a bank to do that 
20:37:15 <carter> mwahahahah
20:37:24 <carter> errrr, i mean megacrop
20:37:27 <carter> *megacorp
20:37:57 <bitemyapp> carter: :)
20:38:02 <Nik05> but rrbm i still dont get the exp :: Expr a => a, stackVM exp == Right [IVal exp].
20:38:25 <Nik05> The type of stackVM is not Expr a => a -> etc... but Program -> ...
20:38:58 <rrbm> Nik05: once you make Program an Instance of Expr though
20:39:13 <Nik05> yes?
20:39:20 <rrbm> then you have Expr Program => Program
20:39:32 <Nik05> yes but not Expr a => a...
20:39:40 <rrbm> that's what it asks of you, to make an instance
20:39:51 <rrbm> a is a type variable
20:40:18 <Nik05> yes a variable but it can only be Program not any other, right?
20:42:45 <rrbm> no, in the previous exercise you made instances for Integer, Boolean, Mod7 & Minmax
20:43:02 <Nik05> yes correct
20:43:11 <rrbm> a could be any of those types for which you made instances for
20:43:32 <Nik05> yes, but stackVM only takes a Program...
20:43:39 <Nik05> not any of the others
20:46:49 <kristof> edwardk: I was writing some linear algebra software in Rust and looking around for papers related to Morton ordering when I was surprised to stumble on your blog post related to the very same subject. :)
20:47:17 <kristof> "Oh, I know that name" moments are pleasant.
20:47:20 <rrbm> Nik05: don't worry about the others, its only asking you to make an instance for Program
20:47:34 <Nik05> yes i know
20:49:19 <Nik05> rrbm i guess the exercise has a mistake...
20:49:28 <rrbm> so, there you go: you make Programs and instance of Expr, just like you did with Int, Bool, etc
20:49:47 <Nik05> yes i did that, but then there is that condition it needs to hold, which is just not possible
20:50:59 <Nik05> my question/comment is all about "For
20:50:59 <Nik05> any arithmetic expression exp :: Expr a => a it should be the case
20:50:59 <Nik05> that
20:51:04 <Nik05> stackVM exp == Right [IVal exp]"
20:51:18 <Nik05> oops multiple line paste
20:55:07 <codebje> I am not sure if I did this right, or did it terribly, horribly, badly wrong
20:55:07 <codebje> http://bl.ocks.org/codebje/raw/d30ca77d8b30f5ca6224/
20:55:30 <codebje> ... but it's nothing to do with haskell, and I have pasted it into the wrong window
21:03:28 <bitemyapp> @pl \x y z -> liftM3 C (f x) (g y) (h z)
21:03:28 <lambdabot> flip flip h . ((.) .) . (. g) . liftM3 C . f
21:03:48 <Nik05> if you got two modules which both have a same type constructor(i guess that is what its called) then what do you call the prefix you add to the type construct to make it unambiguous?
21:04:08 <Nik05> Foo.Bar, how do you call the Foo. part
21:04:18 <Nik05> oh namespaceing?
21:04:25 <slack1256> the qualified import?
21:05:20 <Nik05> slack1256 its not qualified but i do need to put the prefix on it
21:05:25 <Nik05> the prefix is just the module name
21:06:01 <Nik05> i guess its namespacing
21:08:09 <Gurkenglas> bitemyapp, consider zipping [f, g, h] with [x, y, z], especially if you can imagine that list growing.
21:20:10 <carter> kristof: you should do the sparse morton
21:20:18 <carter> though the iterator style api in rust... isnt' quite right
21:20:30 <kristof> How do you mean?
21:22:07 <kristof> carter: I do not use the iterators in Rust for the matrix operations.
21:22:49 <kristof> Oh, uh, you would probably know this.
21:23:15 <kristof> carter: I can't seem to find in the literature exactly when it's better to use row/column ordering over morton, or if the tradeoffs are well known by now.
21:37:24 <humphry> hi, I'm reading LYAH. I'm re-reading the functors section and am stuck at the exercise on how to make Map k an instance of a Functor
21:38:13 <humphry> see http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
21:40:23 <Gurkenglas> Here's the constructor of Data.Map.Lazy: data Map k a  = Bin {-# UNPACK #-} !Size !k a !(Map k a) !(Map k a) | Tip
21:41:01 <Gurkenglas> (You can ignore the {- -} comment and the ! annotating prefixes.)
21:41:26 <pacak> humphry: use fromList and toList
21:41:41 <Gurkenglas> You're given a (a -> b). What should you do to each constructor to replace all mentions of a with b?
21:42:35 <kadoban> humphry: That's not a very good exercise, because you don't really have access to the constructor you'd have to use if you were actually implementing that. I assume you're just supposed to … conceptually figure out what you'd do?
21:42:47 <Hijiri> the way I interpreted it it's not asking for an actual implementation
21:43:23 <humphry> still los
21:43:24 <humphry> lost*
21:43:25 * hackagebot logfloat 0.13.3.2 - Log-domain floating point numbers  https://hackage.haskell.org/package/logfloat-0.13.3.2 (WrenThornton)
21:43:41 <kadoban> humphry: Most of the problem with LYAH is that it lacks actually useful exercises, by the way :-/
21:47:27 <humphry> can i just have the answer?
21:47:59 <shachaf> I don't think the answer is Haskell code.
21:48:09 <shachaf> It looks like they're just asking you to understand what it does.
21:48:13 <shachaf> I don't know.
21:48:24 <shachaf> Certainly the implementation of Data.Map has nothing to do with the answer.
21:48:42 <humphry> then can i have the "sentence form" of the answer
21:51:06 <kadoban> humphry: The sentence form isn't very clear. It's a crap exercise. I'd just be something like: "you use the provided function to transform each of the values in turn", which I kinda doubt is that clear unless you already understand it.
21:52:33 <nshepperd> the answer I assume is that fmap = Map.map
21:55:03 <Gurkenglas> "For example, if we gave the wrong functor instance to our Tree type, using fmap over a tree where the left sub-tree of a node only has elements that are smaller than the node and the right sub-tree only has nodes that are larger than the node might produce a tree where that's not the case." <- That sentence is just wrong, right? Because the functor laws don't protect from that.
21:56:16 <humphry> Gurkenglas: yeah, I  was wondering about that too. I was hoping it would become clear in a later chapter
21:57:04 <pacak> it will (more or less) work if you go via toList/fromList
21:57:11 <humphry> kadoban: yeah, so for every key, we transform the corresponding value from it's current type to the new type, as per our function f (a->b)
21:57:20 <humphry> kadoban: right?
21:57:49 <kadoban> humphry: Sounds right enough.
22:02:33 <nshepperd> Gurkenglas: well, they protect against 'fmap id' or 'fmap (+1)' from changing the order
22:02:47 <zwerdlds> I am working on a site in Scott/WAI/Blaze.  anyone got any pointers on how to make the following work?
22:02:47 <zwerdlds>  
22:02:47 <zwerdlds> import qualified Text.Blaze.Html5 as BH
22:02:47 <zwerdlds> import qualified Text.Blaze.Html5.Attributes as BA
22:02:47 <zwerdlds> ...
22:02:47 <zwerdlds>             BH.head $ do
22:02:47 <zwerdlds>                 BH.script
22:02:48 <zwerdlds>                     BH.! BA.src "elm.js"
22:02:48 <zwerdlds>                         $ ""
22:02:49 <zwerdlds>                 BH.link
22:02:49 <zwerdlds>                     BH.! BA.href "Frontend.css"
22:02:50 <zwerdlds>                         $ ""
22:03:09 <nshepperd> zwerdlds: lpaste >_>
22:03:38 <zwerdlds> nshepperd: sorry?  did i do something wrong?
22:03:41 <kadoban> zwerdlds: "It doesn't work" (and isomorphic questions) is the least helpful complaint in the history of troubleshooting.
22:04:05 <kadoban> nshepperd: You should use http://lpaste.net/ instead of pasting multiple lines here
22:04:09 <kadoban> zwerdlds: ^
22:04:41 <nshepperd> Gurkenglas: it's still a shoddy example though, since you can violate the tree invariant deliberately with 'fmap negate'
22:04:45 <zwerdlds> kadoban: yes im aware, i just thought maybe the BH.script to BH.link lines would stand out to someone.  extreme noob here,  not even sure what i dont know
22:04:56 <zwerdlds> kadoban: ty
22:06:23 <nshepperd> zwerdlds: are you getting a compiler error or what
22:07:38 <zwerdlds> that final $ under the BH.script is complaining of too many args.  i don't want it to slurp the BH.link, i want it inside the B.head
22:09:42 <nshepperd> zwerdlds: notice that BH.! is an infix operator
22:11:50 <nshepperd> oh, no that seems right
22:13:04 <nshepperd> I'm guessing you've just got some funky indentation going on there
22:17:54 <lpaste_> zwerdlds pasted “render multiple subelements” at http://lpaste.net/138050
22:18:14 <zwerdlds> nshepperd: just posted that to lpaste, mind taking a look
22:19:06 <zwerdlds> nshepperd: removed the unnecessary lines and indentation
22:19:57 <nshepperd> oh
22:20:06 <nshepperd> BH.link doesn't take an argument
22:20:56 <zwerdlds> so it doesn't!
22:20:59 <zwerdlds> thanks!
22:22:07 <zwerdlds> nshepperd: kickass!  I owe you a beer
22:27:31 <td123> has there been any r&d into serializing algebraic types into json or other formats and then deserializing them over the network, maybe in a different language?
22:28:13 <liste> td123 you mean something like aeson?
22:29:01 <liste> and its generic interface
22:29:30 <shachaf> Protocol buffers (and similar schemes) can represent algebraic data types.
22:29:57 <td123> I guess, rather than dropping the type info at compile time, it would be attached to the value indefinitely so anything that touches it could read the type
22:31:54 <td123> hmm, ya something like protobufs
22:34:45 <td123> I'm asking this because I do a lot of analytics at work, and it's completely untyped, undocumented, guess and hope it works
22:35:40 <td123> I'm wondering if I could make that kind of work more formal
22:36:27 <lamefun> I've read on OverloadedRecordFields, what would be a reason not to ignore normal functions and make everything into fields when this lands (except for verbosity)?
22:36:53 <kadoban> lamefun: Because eww
22:39:02 <lamefun> kadoban, eww = ModuleOne.foo $ ModuleTwo.foo $ somethingThis $ somethingThat thing instead of thing.that.this.foo.foo.
22:40:33 <kadoban> lamefun: I have a feeling you're talking about some specific pattern or framework or something and thinking it's a general problem. (Because that doesn't look like code I am forced to write …)
22:40:55 <pacak> Is there any hlint-like tool that provide metric on modules and exports dependencies (as in "You are importing foo declared in Foo via Bar that also adds 100500 different functions to scope defined in 100000 other modules, why not import Foo (foo) instead?")
22:42:28 <kadoban> pacak: You should probably just be using explicit imports anyway, no? So it doesn't sound that useful in general? (I don't know of one though)
22:46:30 <pacak> kadoban: If you have a big project that builds a bunch of binaries just by changing a few imports can reduce compilation time from 10 minutes down to 1 minute.
22:47:09 <lamefun> kadoban, it's about something like `getAppUserDataDirectory (Text.unpack $ AppInfo.nameText $ AppInfo.summaryName $ paramsSummary params)`, instead of `getAppUserDataDirectory(Text.unpack(params.summary.name.text))` if I were writing in a language that supports properties / member functions.
22:48:41 <kadoban> lamefun: That looks intentionally verbose, and still approximately the same goodness?
22:49:12 <lamefun> kadoban, well, how can I fix it?
22:50:13 <kadoban> import qualified Data.Text as T, or explicitly import commonly used stuff like import Data.Text (unpack), same for AppInfo … the rest, I dunno what 1/2 of that is for/from, but it doesn't look that bad *shrug* . So … what's wrong with it that needs fixing?
22:54:04 <lamefun> Why do I need to explicitly supply context to a "concise" language with "state-of-the-art type inference" all the time, where languages with supposedly "weaker" type inference don't need one?
22:55:37 <shachaf> You're being pretty hostile here.
22:55:37 <kadoban> lamefun: … trolling like question detected. What "context" are you even talking about?
22:55:46 <shachaf> You're welcome to not use Haskell if you don't like it.
22:56:27 <humphry> from http://learnyouahaskell.com/functors-applicative-functors-and-monoids
22:56:33 <kadoban> lamefun: Like module specifications Blah.someFunc?
22:56:56 <humphry> the line
22:56:56 <humphry> fmap f g = (\x -> f (g x))  
22:57:05 <humphry> what is g here?
22:57:08 <humphry> another function?
22:57:25 <kadoban> humphry: Yeah. It has to be because (g x)
22:57:39 <pacak> humphry: yep
22:57:41 <humphry> but he didn't mention that at all leading up to that ?
22:58:00 <humphry> actallly 
22:58:01 <humphry> hold that
22:58:46 <humphry> no 
22:58:51 <humphry> he just breaks in a couple lines before with 
22:58:52 <humphry> How are functions functors?
22:58:58 <kadoban> humphry: I think it describes it more afterwards, just not a ton before.
22:59:18 <humphry> yeah, didn't flow smooth to me, i feel stupid like i missed something
22:59:38 <lamefun> kadoban, yes, `Module.accessor value` (or `Module.recordAccessor value` if I want several records with named fields in one module that share same field name) instead of just `value.accessor` in most other languages.
22:59:54 <humphry> never the less interesting
23:03:37 <kadoban> lamefun: *shrug* dunno. Hasn't bothered me much in practice. If you're non-rhetorically asking why, it seems like having one name with two totally different types would just be confusing in haskell, especially when it intersects with type inference. f :: Int -> Int    and f :: Char -> String, then when I see 'f' I need to try to figure out which one it actually is, especially if the types around it need to be infered and aren't annotated.
23:03:59 <kadoban> lamefun: For the language implementors it probably complicates things as well.
23:05:28 <lf94> Hey guys, what's the Haskell market like?
23:05:32 <lf94> job market*
23:05:33 <lamefun> Does that inconvenience buy me something in terms of higher abstractions?
23:05:36 <kadoban> humphry: I'm not a big fan of LYAH, especially on its own. I definitely wouldn't recommend you beat yourself up too hard that you don't understand what ((->) r) means as a Functor immediately, it's fairly conceptually difficult.
23:06:41 <kadoban> humphry: I guess if anything I'd try to look at the code it shows and try to understand why the types themselves make sense, and probably not much beyond that.
23:07:17 <humphry> kadoban: what would you recommend?
23:08:57 <kadoban> humphry: https://github.com/bitemyapp/learnhaskell , which recommends the cis194 spring `13 class that it links to. That class recommends readings in LYAH, but adds to it with other material (and more importantly, it grounds things in exercises which is /rediculously/ better for learning … without exercises you never learn how to actually use haskell)
23:10:24 <kadoban> lamefun: It indirectly gives you type inference and the entire type system, and it makes it less confusing what 'f' means when you see 'f'. If it annoys you that badly, not sure what to tell you.
23:11:53 <lamefun> kadoban, well, I think if I were the only person who's annoyed by this, OverloadedRecordFields wouldn't be considered for development.
23:15:03 <kadoban> lamefun: I doubt you're the only one who's that annoyed by it. You seem to be annoyed by it in more instances that OverloadedRecordFields is designed to fix though.
23:20:20 <humphry> kadoban: thanks :)
23:20:41 <td123> lf94: compared to what? java? then non existent :P
23:21:07 <td123> lf94: I'm sure if you're good you can find a job though
23:21:54 <td123> also word of advice, i wouldn't limit your job search based on a programming language :)
23:32:00 <nshepperd> lamefun: the implementation of OverloadedRecordFields seems to require some pretty advanced features
23:32:54 <nshepperd> like if you can do 'value.accessor' what is the type of 'accessor'? what is the type of (.)?
23:33:19 <srhb> nshepperd: Most proposals expose some classy lenses to solve this.
23:33:56 <nshepperd> yep
23:34:43 <lf94> td123, define good
23:35:18 <nshepperd> I think semantically 'value.accessor' is not quite as trivial as it appears. Other languages ignore this issue by choosing not to care (about denotations)
23:35:25 <nshepperd> or, that would be my guess
23:36:45 <td123> lf94: https://www.fpcomplete.com/business/about/jobs/ https://jobs.silk.co/
23:37:15 <td123> lf94: you probably should have a solid cs background, algorithms, distributed systems, etc
23:37:57 <td123> lf94: most places wont care about language if you know the background, haskell is no exception
23:39:34 <td123> lf94: oh and also checkout facebook, they're doing some haskell programming for some spam filtering work
23:39:52 <td123> lf94: or microsoft research
23:42:45 <lf94> by that definition I'm good then
23:42:46 <lf94> lol
23:42:53 <lf94> Alright lets check these out...
23:45:37 <lf94> td123, silk.co only has javascript jobs (actually I'm extremely qualified for those...)
23:47:24 <andkore> I'm guessing it's not very easy to do stuff like this (http://maxberggren.github.io/2015/08/04/basemap/) in Haskell yet, right?
23:48:30 <td123> lf94: well, if you get your foot in the door, you will probably be doing haskell also
23:48:32 <td123> lf94: https://github.com/silkapp
23:51:34 <td123> andkore: haskell has ihaskell, and some decent plotting libs
23:51:55 <td123> andkore: but you probably wont get those kinds of nice one liners without writing a bunch of supporting functions
23:52:33 <td123> python is still second to none in terms of doing easy analysis on a single computer
23:52:42 <andkore> td123: Yeah, that's what I figured, thanks.
23:52:42 <Gurkenglas> andkore, those code snippets read more like an assemblable form than programs. You'll have to find or write an equivalent library to have the equivalent haskell snippets work, but if you have one, the code shouldn't look harder than what you linked
23:53:31 <td123> andkore: asking for business analytics?
23:53:34 <Gurkenglas> andkore, check out http://projects.haskell.org/diagrams/ to see what that looks like for diagrams rather than maps
23:54:14 <tdammers> lf94: AFAIK, if you're good, applying to any place that uses Haskell is probably a good idea, even if they're not advertising any jobs
23:55:41 <andkore> Gurkenglas: I'll check it out, thanks.
23:55:49 <andkore> td123: Nope, just want to do some fun mapping.
