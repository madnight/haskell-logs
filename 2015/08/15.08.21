00:06:16 <mada> what does 'free' mean in 'free objects', or as it says in learnhaskell, "Understanding free objects, free versions of these algebraic structures, can lend a more faithful intuition for what these things are"? I suspect there's not much of a chance of gaining said intuition without a previous background in algebra, correct?
00:07:04 <shachaf> No, it'll probably help you in any case.
00:07:30 <shachaf> For example you can get intuition for monoids by getting intuition about lists.
00:07:38 * hackagebot coverage 0.1.0.0 - Exhaustivity Checking Library  https://hackage.haskell.org/package/coverage-0.1.0.0 (NicolasDelPiano)
00:07:38 * hackagebot coverage 0.1.0.1 - Exhaustivity Checking Library  https://hackage.haskell.org/package/coverage-0.1.0.1 (NicolasDelPiano)
00:08:08 <shachaf> Lists are special because (in general) they don't satisfy any properties beyond the necessary one, e.g. xs ++ ys isn't in general equal to ys ++ xs
00:08:55 <mada> shachaf: so what does Free mean in that context? would there be something like a free monoid?
00:09:00 <erisco> edwardk, sorry I've just been in a rotten mood
00:09:44 <edwardk> np
00:09:53 <shachaf> Yes, lists are free in this sense.
00:10:14 <erisco> I am trying to unify (^. unpack) by hand to try and obtain some understanding
00:10:48 <erisco> it seems I have to unify (a -> Const a a) with the type of unpack, which I don't see
00:11:04 <erisco> given  (^.) :: s -> (a -> Const a a) -> s -> Const a s -> a
00:11:10 <edwardk> srpx: nope. you can make a class MaybeUnbox t where canUnbox :: Maybe (Dict (Unbox t))   -- or something that carries the proof of if its presence, but it could always lie to you and tell you you can't when you can.
00:11:35 <edwardk> :t view
00:11:36 <lambdabot> MonadReader s m => Getting a s a -> m a
00:11:41 <edwardk> :t (^.)
00:11:42 <lambdabot> s -> Getting a s a -> a
00:11:45 <edwardk> lets do that, its easier
00:12:15 <erisco> unpack :: (Functor f, Monad m) => (Producer Char m r -> f (Producer Char m r)) -> Producer Text m r -> f (Producer Text m r)
00:12:39 <erisco> I'm not sure what is going on, not sure if I am brain farting on it
00:12:48 <edwardk> s -> ((a -> Const a a) -> s -> Const a s) -> a         so we're going to mash this up with  (Producer Char m r -> f (Producer Char m r)) -> Producer Text m r -> f (Producer Text m r) for the second argument. this unifies a = Producer Char m r,  and f = Const a
00:12:56 <edwardk> so f = Const (Producer Char m r)
00:12:59 <edwardk> and we get
00:13:02 <SrPx> edwardk: uhm okay, thanks
00:13:50 <edwardk> s -> ((Producer Char m r -> Const (Producer Char m r) (Producer Char m r)) -> Producer Text m r -> Const (Producer Char m r) (Producer Text m r)) -> Producer Char m r
00:13:53 <edwardk> wheee
00:14:02 <edwardk> oh and the s at the start
00:14:08 <erisco> how do you get a = Producer Char m r?
00:14:11 <edwardk> Producer Text m r -> ((Producer Char m r -> Const (Producer Char m r) (Producer Char m r)) -> Producer Text m r -> Const (Producer Char m r) (Producer Text m r)) -> Producer Char m r
00:14:43 <erisco> oh
00:14:45 <edwardk> (Producer Char m r -> f (Producer Char m r))  -> ... -> ...     unifying with (a -> f b) -> ... -> ...
00:14:47 <erisco> I got my brackets wrong
00:14:49 <erisco> that is the problem
00:15:01 <edwardk> er a -> f a
00:15:07 <erisco> I forget that when you expand the alias it needs to be bracketed
00:15:09 <edwardk> even, so we have two things supplying that info
00:15:13 <erisco> this could make much more sense now oO
00:15:32 <edwardk> np. i freely admit the types involved when working with lens are... complicated
00:15:52 <erisco> no I just expanded to  (^.) :: s -> (a -> Const a a) -> s -> Const a s -> a
00:15:55 <erisco> instead of (^.) :: s -> ((a -> Const a a) -> s -> Const a s) -> a
00:16:46 <erisco> a minus sign kind of mistake
00:17:18 <SrPx> I know REPA etc., but is it possible to make a version of "UnboxedVector.map" that is parallel with no changes on the API?
00:20:25 <erisco> Producer Text m r -> ((Producer Char m r -> Const (Producer Char m r) (Producer Char m r)) -> Producer Text m r -> Const (Producer Char m r) (Producer Text m r)) -> Producer Char m r
00:20:33 <erisco> someone was asking about long type signatures a few days ago
00:27:28 <erisco> Const is a bit trippy
00:29:42 <Walpurgisnacht> yea
00:31:04 <erisco> > Const "hello " <*> Const "world"
00:31:06 <lambdabot>  Const "hello world"
00:31:12 <erisco> it is just, kinda, hmm
00:32:49 <ggole> We need 'where' for types?
00:33:57 <Axman6> it's called 'type'
00:33:58 <erisco> ggole, sometimes yes, it seems
00:34:04 <erisco> but type is a global declaration
00:39:28 <erisco> > fmap undefined (Const 5)
00:39:30 <lambdabot>  Const 5
00:39:33 <erisco> it is just a strange toy
00:41:30 <erisco> I guess in some sense it undoes a requirement for Functor
00:41:48 <opqdonut> it's quite useful
00:42:01 <erisco> the type system does the functor stuff, but at value level it is not important
00:42:27 <ely-se> If there are Const (K) and Identity (I) functors, is there also an S functor?
00:43:11 <Axman6> there is a way to have a where clause in type actually: foo :: (x ~ Something Really long a () b) => Foo x x -> Either x x
00:43:50 <opqdonut> for example a lenses are effectively functions Functor f => (a -> f b) -> s -> f t
00:44:00 <opqdonut> a lens that accesses a field of type "a" in a structure of type "s" that is
00:44:24 <opqdonut> you recover the getter for that field by using "\x -> Const x" as the function
00:45:33 <erisco> I really don't know what use it has in context of the library I am using
00:45:42 <opqdonut> as to your second question, I don't think the SKI analogy really holds. you can't really apply a Const functor to a Const functor, for instance
00:45:48 <erisco> I wish I could make more sense of that
00:46:10 <erisco> that wasn't my question :)
00:47:18 <erisco> this is sitting in the library already _unpack :: Monad m => Producer Text m r -> Producer Char m r
00:47:25 <erisco> this should have been the thing I'd use in the first place
00:47:31 <erisco> why is that not exposed
00:47:32 * erisco sighs
00:48:44 <erisco> fmap _pack (k (_unpack p))
00:48:52 <erisco> that is the definition of unpack
00:48:57 <erisco> I don't get it at all why this is needed
00:49:13 <erisco> so the only thing Const is doing is what it is doing in fmap undefined (Const 5)
00:49:19 <erisco> it is just tossing out the fmap _pack
00:49:22 <erisco> and giving me _unpack p
00:49:24 <erisco> the thing I wanted
00:52:04 <opqdonut> erisco: yeah it seems stupid that they don't expose _unpack (or some equivalent)
00:52:07 <opqdonut> in this case
00:52:20 <opqdonut> but in general only exposing the Lens makes for a smaller API
00:52:36 <erisco> what else might I do with the lens API
00:52:56 <erisco> I just care about the "getter", but maybe there is something else in there that makes ense
00:52:58 <opqdonut> lenses are functional getters/setters
00:53:12 <catofhask> can I constraint the values in TQueue?
00:53:17 <erisco> I also noticed if I use Identity it gives me id
00:53:18 <opqdonut> a pretty powerful abstraction that lets you work with nested data structures as "easily" as in imperative languages
00:53:30 <opqdonut> perhaps you can read a lens tutorial
00:54:03 <erisco> this is packing and unpacking Text
00:54:04 <catofhask> > new <- newTQueueIO
00:54:06 <lambdabot>  <no location info>: not an expression: ‘new <- newTQueueIO’
00:54:21 <erisco> I don't know lens, what kind of things might I do in this context
00:54:23 <edwardk> erisco: 'unpack' provides multiple bits of functionality in one name. you can get, set, modify, tweak in several different ways. without lens, these are all separate one-off combinators to learn and memorize
00:54:58 <erisco> by the same token there are a bunch of lens combinators to learn to correspond to each of those functionalities...
00:55:05 <erisco> I guess the promise is to learn lens once
00:55:11 <opqdonut> yeah
00:55:17 <opqdonut> but it's kinda like learning a whole new language
00:55:18 <edwardk> erisco: and by learning them you can use them on every single library that uses lens. the potential for reuse is higher
00:55:23 <opqdonut> they're useful but I'm not a huge fan
00:55:24 <erisco> but can you give another example?
00:55:36 <edwardk> here its O(n + m) vs. O(n*m) names
00:55:38 <erisco> I just want to know why this might be a lens
00:56:07 <edwardk> > over _2 length ("hello","world")
00:56:09 <lambdabot>  ("hello",5)
00:56:17 <erisco> I mean specifically with this pack and unpack
00:56:20 <edwardk> over lets you map, replacing how you 'Produce Chars'
00:56:57 <edwardk> its just picking f = Identity here for you
00:57:27 <edwardk> Identity and Const fully characterize the power of a lens in one sense.
00:57:44 <erisco> over unpack :: (Producer Char m r -> Producer Char m r) -> Producer Text m r -> Producer Text m r
00:57:45 <edwardk> in another though, you can _compose_ the thing that he gives you there with any other lens you have lying around
00:57:50 <edwardk> yes
00:58:06 <erisco> so, this is basically letting me map each character to zero or more characters
00:58:16 <edwardk> is it?
00:58:25 <edwardk> it maps a producer of chars to a producer of chars
00:58:26 <erisco> I would think so
00:58:30 <edwardk> taking a producer of text to a producer of text
00:58:41 <erisco> yeah, and what are you going to do with the producer
00:59:38 <edwardk> you give me a function from Producer Char m r -> Producer Char m r  -- you are allowed to know m and r in that function
00:59:47 <edwardk> so you could drive the producer you are given
00:59:53 <edwardk> and get out what it produces
00:59:59 <edwardk> then use that to generate a whole new producer
01:00:04 <edwardk> that producers other output
01:00:06 <erisco> yes, another producer of chars
01:00:19 <edwardk> might reverse it, might compute something seemingly unrelated
01:00:21 <erisco> the producer I take in is going to produce each char in the text
01:00:38 <edwardk> is it?
01:00:52 <erisco> that is what the implementation does
01:01:02 <edwardk> k
01:04:01 <edwardk> so you're able to do a bit more here, you're able to consume a producer of chars and spit out a producer of chars that can a.) have side-effects in m to use to generate its chars, and b.) can do things with r.
01:04:34 <edwardk> now its 'improper' as prisms go, because the char producer you get if you ran over this thing twice wouldn't be the one you just put in
01:04:38 <edwardk> that is the improper bit
01:04:41 <edwardk> we'd usually expect
01:05:03 <edwardk> over l f . over l g = over l (f . g) -- but that fails here unless you know that you are only producing a producer that maps chars to single chars
01:05:22 <edwardk> er improper as lenses go
01:07:19 <erisco> (^.. unpack) :: Monad m => Producer Text m r -> [Producer Char m r]
01:07:34 <erisco> these would be all the char producers I would have been given?
01:08:04 <edwardk> its a lens
01:08:11 <edwardk> right?
01:08:18 <erisco> so
01:08:21 <edwardk> so ^.. is only going to give you one match
01:08:31 <edwardk> there is precisely one char parser here
01:09:22 <erisco> right okay
01:09:23 <erisco> why the list
01:09:43 <edwardk> ^.. is more general than working with lenses
01:09:51 <edwardk> ^. works here
01:10:18 <edwardk> > Left ([1,2],[3,4])^.._Left.both.traverse
01:10:19 <lambdabot>  [1,2,3,4]
01:10:27 <edwardk> > Left ([1,2],[3,4]) & _Left.both.traverse +~ 1
01:10:29 <lambdabot>  Left ([2,3],[4,5])
01:10:34 <erisco> I'm just going through the module trying to find other uses
01:10:52 <edwardk> ^.  and over   fully characterize a lens.
01:11:10 <edwardk> so if you can't figure out how to do what you want with those it can't be done
01:11:33 <edwardk> it may be able to be done more elegantly with other combinators, especially when you'd compose it with other things, but with that you've expressed the power of a lens
01:12:16 <erisco> okay
01:13:39 <erisco> btw the examples like (1,2) ^. _2 make lenses sound like glorified projectors
01:14:03 <ely-se> you need to insert dias or it won't work
01:14:04 <erisco> but it isn't like that at all
01:52:37 * hackagebot HUnit 1.3.0.0 - A unit testing framework for Haskell  https://hackage.haskell.org/package/HUnit-1.3.0.0 (qoelet)
01:56:17 <Arninja> I'm not programming haskell on a daily basis, but I was wondering if Haskell is suited for creating REST services... good idea? Easy to do? Some packages that help you?
01:57:37 * hackagebot quickcheck-io 0.1.2 - Use HUnit assertions as QuickCheck properties  https://hackage.haskell.org/package/quickcheck-io-0.1.2 (qoelet)
01:58:42 <liste> Arninja check out servant
01:58:46 <liste> @hackage servant
01:58:46 <lambdabot> http://hackage.haskell.org/package/servant
01:58:54 <srhb> Arninja: Oh very. Most of the web frameworks lend quite nicely to RESTful applications. 
01:59:01 <srhb> And yes, servant is really cool. :)
02:00:54 <rdz_> has anyone seen this error before? getProtocolByName: does not exist (no such protocol name: tcp)
02:01:28 <srhb> rdz_: Isn't it "TCP" ?
02:01:58 <srhb> rdz_: (This is Network.BSD, righ?)
02:02:06 <rdz_> hmmm, not sure - that's just what it spits out
02:02:29 <rdz_> srhb: using http-conduit
02:02:30 <srhb> rdz_: No I mean, shouldn't you be requesting "TCP" rather than "tcp" with getProtocolByName?
02:02:35 <srhb> Oh
02:02:53 <rdz_> basically I am on Windows - everything works fine
02:03:00 <rdz_> I'm trying to get it running inside an Ubuntu VM
02:03:13 <tsahyt> Is it possible to run stack build such that it outputs the whole build process with warnings like cabal build does?
02:03:16 <rdz_> can't seem to make an https connection
02:03:40 <rdz_> it's a runtime error
02:04:25 <rdz_> the only other place I've seen it is here: https://github.com/bos/wreq/issues/5
02:04:36 <srhb> rdz_: Yes, I just found that too.
02:04:39 <rdz_> and a few random hits either on the mailing list / irc logs
02:04:56 <rdz_> I tried apt-get install netbase
02:05:02 <rdz_> that didn't seem to fix it
02:05:10 <rdz_> and I'm largely a linux newbie, so I have no idea
02:05:20 <srhb> rdz_: ca-certificates?
02:05:49 <rdz_> it says ca-certificates is already at the latest version
02:06:24 <srhb> rdz_: OK. No idea then, sorry. I've never seen the error before.
02:07:03 <rdz_> according to Google there's a whole 5 of us
02:08:55 <lieven> is there a file /etc/protocols on your system?
02:09:38 <rdz_> lieven: there is
02:09:41 <rdz_> it contains: tcp	6	TCP		# transmission control protocol
02:10:43 <lieven> to be on the safe side, you could try strace to see if it gets opened or ltrace to see what the getprotobyname syscall returns
02:11:10 <lieven> but it's possible that there's some errno confusion and that the problem is unrelated
02:11:17 <Arninja> srhb, liste: thanks for the information!
02:11:51 <rdz_> not familiar with strace or ltrace
02:13:59 <liste> you're welcome
02:14:09 <liste> don't be afraid to ask if you have further questions
02:18:14 <erisco> in pipes, can I peek?
02:20:21 <erisco> I am feeling like it would take a lot of work to setup
02:21:51 <srhb> erisco: Perhaps take a look at the peek from Pipes.Parse
02:22:34 <srhb> erisco: unDraw is pretty simple.
02:23:10 <erisco> what is draw/unDraw from?
02:23:44 <srhb> draw is from pipes, unDraw from Pipes.Parse. I'm assuming the modifcation of the Producer can be used.
02:24:12 <erisco> I don't see draw in pipes
02:25:19 <erisco> I am guessing I need to pass messages
02:25:39 <Intolerable> what are you trying to do?|
02:29:12 <srhb> erisco: Sorry, you're right. It's also atop the Producer bits in pipes-parse
02:30:56 <erisco> how do you await incoming messages from downstream?
02:33:58 <erisco> I need something like Proxy a a' b b' m b
02:35:24 <mniip> erisco, that makes no sense
02:35:29 <erisco> why not?
02:35:30 <mniip> Proxy is of kind k -> *
02:35:42 <mniip> not * -> * -> * -> * -> * -> * -> *
02:35:47 <erisco> what are you talking about
02:35:55 <mniip> [11:30:55] <erisco> I need something like Proxy a a' b b' m b
02:35:57 <Intolerable> ???
02:35:59 <erisco> data Proxy a' a b' b m r
02:36:03 <Intolerable> Pipes.Proxy
02:36:05 <Intolerable> not Proxy
02:36:06 <mniip> ah
02:36:11 <mniip> okay then
02:36:37 <Intolerable> he wants something that should be called awaitDownstream 
02:36:42 <mniip> I should figure out pipeconduits someday
02:36:44 <Intolerable> but may or may not exist
02:36:59 <erisco> how can it not exist
02:37:08 <erisco> what would be the point of having a bidirectional downstream
02:37:39 * hackagebot hspec-expectations 0.7.2 - Catchy combinators for HUnit  https://hackage.haskell.org/package/hspec-expectations-0.7.2 (SoenkeHahn)
02:40:55 <erisco> hold on, respond is kind of like that
02:41:00 <erisco> respond :: Monad m => a -> Proxy x' x a' a m a'
02:41:29 <erisco> so, if I respond I also get back a message... okay not sure I understand that
02:41:46 <merijn> erisco: Pipes are bidirectional
02:41:47 <erisco> same with request though on upstream
02:41:54 <erisco> that isn't my confusion
02:42:11 <erisco> my confusion is why I immediately get back some message when I do a respond
02:43:03 <erisco> it seems request is await ()
02:43:10 <erisco> I mean await is request ()
02:44:03 <merijn> erisco: Well, yes
02:44:10 <merijn> erisco: That is literalyl the implementation of await
02:44:15 <erisco> and respond specialises to yield
02:44:28 <merijn> erisco: Yes
02:44:29 <erisco> yeah, just a bit confusing now
02:45:10 <erisco> well let me play with it
02:47:39 * hackagebot dead-code-detection 0.1 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.1 (SoenkeHahn)
02:52:40 * hackagebot hunch 0.1.1 - CSS-like syntax for file system manipulation.  https://hackage.haskell.org/package/hunch-0.1.1 (loganbraga)
02:53:31 <erisco> okay this is my peeker design http://lpaste.net/139346
02:53:38 <erisco> how did I do
02:56:32 <kqr> in terms of HTML templating in haskell during run-time (so hamlet is ruled out), what are my options?
02:57:00 <opqdonut> I've used Text.XHtml.Strict
02:57:08 <kqr> wait there is a run-time version of hamlet
02:57:23 <opqdonut> it's a DSL for generating xhtml. there are variants for other htmls as well
02:57:32 <Intolerable> lucid?
02:57:40 * hackagebot hspec-meta 2.2.0 - A version of Hspec which is used to test Hspec itself  https://hackage.haskell.org/package/hspec-meta-2.2.0 (qoelet)
02:57:46 <kqr> yeah I've been looking at blaze-html and other DSLs, but I'm not sure if I want to specify my templates in code
02:57:57 <kqr> will check lucid out
03:00:39 <erisco> merijn, like, did I do it all wrong?
03:00:44 <erisco> it seems reasonable to me
03:02:34 <merijn> erisco: You wanna peek at the first element before deciding whether to continue?
03:02:58 <erisco> I need to do lookahead by one to decide what to do
03:03:11 <erisco> but I don't want to consume it
03:03:30 <erisco> this is to detect \r\n in a stream of Char
03:03:34 <merijn> erisco: Aren't you simply looking for pipes-parse if you want lookahead?
03:04:04 <erisco> it is lookahead by one
03:05:10 <rdz_> ah - so I missed this warning when I compiled - can anyone let me know what it means / what I can do about it?
03:05:12 <rdz_> warning: Using 'getprotobyname' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking
03:11:04 <rdz_> nevermind, apparently I shouldn't be building with static linking
03:12:00 <srhb> rdz_: Just that you need libc installed, I think.
03:12:23 <srhb> rdz_: libc6 in Ubuntu I believe
03:13:18 <rdz_> srhb: I found this post: http://stackoverflow.com/questions/8657908/deploying-yesod-to-heroku-cant-build-statically
03:13:38 <rdz_> I was building statically on windows because otherwise I had portability issues
03:13:44 <rdz_> but it seems to be discouraged for linux
03:13:47 <srhb> Oh!
03:13:59 <srhb> yes, linking statically against glibc is going to give you bad times.
03:14:31 <rdz_> I worked it out because when I went into ghci I was able to make a connection, so I assumed it had something to do with how it was compiled
03:14:44 <rdz_> opened the terminal window I had from the compiler, noticed all the warnings and found that post
03:14:53 <rdz_> that's what I get for assuming it would compile fine without checking
03:15:13 <rdz_> linux decided to punish me for my hubris
03:15:48 <srhb> rdz_: Yes. False assumptions tend to do this and make debugging hard. :-)
03:16:01 <srhb> Glad you figured it out
03:17:02 <rdz_> srhb: thanks
03:17:07 <rdz_> but I am getting an even stranger problem now
03:17:10 <srhb> Oh?
03:17:46 <rdz_> I was getting an http response that suggested that I wasn't sending out any headers
03:17:51 <rdz_> so I installed wireshark
03:17:59 <rdz_> ran it as root
03:18:12 <rdz_> and while wireshark is running everything is fine
03:18:22 <srhb> Uh, okay.
03:18:43 <rdz_> I'm actually laughing right now, coz it's so ridiculous
03:19:09 <rdz_> the api I'm querying expects something in the header and basically tells me that it's wrong (not that it's absent)
03:19:24 <rdz_> I use wireshark to inspect the packets and the api responds that everything is fine
03:19:29 <rdz_> turn wireshark off and it stops working
03:19:42 <srhb> I have no idea what could cause that.
03:20:00 <rdz_> haha, well I figured it was worth asking
03:20:05 <hpc> use wireshark to see if wireshark is changing the packets
03:20:08 <hpc> oh wait
03:20:29 <rdz_> it's like shrodinger's error
03:20:48 <rdz_> by observing it I prevent it from happening
03:21:07 <rdz_> hpc: I'm assuming that was a joke response? coz if there's a serious way to do that...
03:21:31 <frerich> rdz_: You found a Heisenbug? :-)
03:21:59 <rdz_> frerich: hahaha a Heisenbug :)
03:24:36 <ely-se> Bohrbugs are much better.
03:25:45 <erisco> this is so frustrating
03:25:49 <erisco> I have to be missing combinators here
03:25:59 <erisco> Monad m => Text -> Proxy X () PeekerMessage Char m ()
03:26:22 <erisco> there has to be some way to mash this up with   Monad m => Proxy PeekerMessage Char () Char m ()
03:31:34 <erisco> okay there we go
03:31:37 <erisco> geez this is difficult
03:31:52 <erisco> so all the combinators in core, I was having a difficult time making any sense of them
03:32:10 <erisco> they are all set up for some composition thingie I don't get yet
03:32:14 <erisco> but I can get rid of that with const
03:32:20 <erisco> so I wanted >~>
03:32:42 * hackagebot pdf-toolbox-core 0.0.4.0 - A collection of tools for processing PDF files.  https://hackage.haskell.org/package/pdf-toolbox-core-0.0.4.0 (YurasShumovich)
03:32:44 * hackagebot pdf-toolbox-content 0.0.4.0 - A collection of tools for processing PDF files  https://hackage.haskell.org/package/pdf-toolbox-content-0.0.4.0 (YurasShumovich)
03:32:46 * hackagebot pdf-toolbox-document 0.0.6.0 - A collection of tools for processing PDF files.  https://hackage.haskell.org/package/pdf-toolbox-document-0.0.6.0 (YurasShumovich)
03:32:48 * hackagebot pdf-toolbox-viewer 0.0.4.0 - Simple pdf viewer  https://hackage.haskell.org/package/pdf-toolbox-viewer-0.0.4.0 (YurasShumovich)
03:33:09 <erisco> I hope const is okay
03:33:12 <erisco> it probably isn't
03:33:50 <erisco> maybe I want return
03:33:51 <erisco> I dunno :(
03:35:58 <the_2nd> rotate TO_THE_BACK_FOR_MAP center rad
03:36:05 <the_2nd> how do I have to use flip on this?
03:36:19 <the_2nd> it was easy with 2 arguments, but now I'm lost
03:36:32 <the_2nd> to use map on this
03:36:38 <the_2nd> *on the first argument
03:37:11 <rdz_> I found the culprit of my Heisenbug and I name him lazy IO
03:37:27 <liste> the_2nd can you use lambdas
03:37:29 <liste> ?
03:37:39 <the_2nd> lise I guess
03:37:42 * hackagebot amazonka-core 1.1.0 - Core data types and functionality for Amazonka libraries.  https://hackage.haskell.org/package/amazonka-core-1.1.0 (BrendanHay)
03:37:43 <liste> usually combining multiple flips leads to unreadable code
03:37:44 * hackagebot amazonka 1.1.0 - Comprehensive Amazon Web Services SDK  https://hackage.haskell.org/package/amazonka-1.1.0 (BrendanHay)
03:37:46 * hackagebot amazonka-config 1.1.0 - Amazon Config SDK.  https://hackage.haskell.org/package/amazonka-config-1.1.0 (BrendanHay)
03:37:48 * hackagebot amazonka-sns 1.1.0 - Amazon Simple Notification Service SDK.  https://hackage.haskell.org/package/amazonka-sns-1.1.0 (BrendanHay)
03:37:50 * hackagebot amazonka-sqs 1.1.0 - Amazon Simple Queue Service SDK.  https://hackage.haskell.org/package/amazonka-sqs-1.1.0 (BrendanHay)
03:38:12 <liste> so \ x y z -> rotate y z x or something like that
03:42:52 * hackagebot amazonka-glacier 1.1.0 - Amazon Glacier SDK.  https://hackage.haskell.org/package/amazonka-glacier-1.1.0 (BrendanHay)
03:42:54 * hackagebot amazonka-cloudhsm 1.1.0 - Amazon CloudHSM SDK.  https://hackage.haskell.org/package/amazonka-cloudhsm-1.1.0 (BrendanHay)
03:42:56 * hackagebot amazonka-datapipeline 1.1.0 - Amazon Data Pipeline SDK.  https://hackage.haskell.org/package/amazonka-datapipeline-1.1.0 (BrendanHay)
03:42:58 * hackagebot amazonka-iam 1.1.0 - Amazon Identity and Access Management SDK.  https://hackage.haskell.org/package/amazonka-iam-1.1.0 (BrendanHay)
03:43:00 * hackagebot amazonka-route53-domains 1.1.0 - Amazon Route 53 Domains SDK.  https://hackage.haskell.org/package/amazonka-route53-domains-1.1.0 (BrendanHay)
03:48:02 * hackagebot amazonka-directconnect 1.1.0 - Amazon Direct Connect SDK.  https://hackage.haskell.org/package/amazonka-directconnect-1.1.0 (BrendanHay)
03:48:04 * hackagebot amazonka-devicefarm 1.1.0 - Amazon Device Farm SDK.  https://hackage.haskell.org/package/amazonka-devicefarm-1.1.0 (BrendanHay)
03:48:06 * hackagebot amazonka-cognito-sync 1.1.0 - Amazon Cognito Sync SDK.  https://hackage.haskell.org/package/amazonka-cognito-sync-1.1.0 (BrendanHay)
03:48:08 * hackagebot amazonka-elb 1.1.0 - Amazon Elastic Load Balancing SDK.  https://hackage.haskell.org/package/amazonka-elb-1.1.0 (BrendanHay)
03:48:10 * hackagebot amazonka-cloudformation 1.1.0 - Amazon CloudFormation SDK.  https://hackage.haskell.org/package/amazonka-cloudformation-1.1.0 (BrendanHay)
03:48:27 <srhb> Brendan Hay, the bane of #haskell
03:49:17 <Hafydd> For maximum modularity, put each exported symbol in its own package.
03:49:29 <mniip> liste, fmap flip . flip !
03:50:41 <mniip> @pl \f x y z -> f y z x
03:50:41 <lambdabot> flip . (flip .)
03:50:49 <mniip> oh, the other way around
03:51:35 <rdz_> so I got rid of the lazy IO by doing a `deepseq` on the header arguments before they get added to the http request... and it resolved the problem
03:51:42 <rdz_> is that the best approach?
03:51:51 <srhb> rdz_: It is an approach, and it might be valid.
03:51:58 <srhb> rdz_: You might also just not want to use lazy IO
03:52:15 <rdz_> I didn't realise I had a choice in that matter...
03:52:17 <srhb> The fact that you're using conduits enforces this
03:52:20 <srhb> Oh, you do, absolutely.
03:52:47 <bycn82> http://lpaste.net/139349
03:52:52 <bycn82> help
03:53:08 <srhb> bycn82: [w:ws] is a list of lists
03:53:09 <bycn82> i am trying to write a simple script to count how many chars in the string
03:53:12 <srhb> Is that what you really mean?
03:53:12 * hackagebot amazonka-sts 1.1.0 - Amazon Security Token Service SDK.  https://hackage.haskell.org/package/amazonka-sts-1.1.0 (BrendanHay)
03:53:14 * hackagebot amazonka-kinesis 1.1.0 - Amazon Kinesis SDK.  https://hackage.haskell.org/package/amazonka-kinesis-1.1.0 (BrendanHay)
03:53:16 * hackagebot amazonka-cloudsearch-domains 1.1.0 - Amazon CloudSearch Domain SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-domains-1.1.0 (BrendanHay)
03:53:18 * hackagebot amazonka-cloudwatch 1.1.0 - Amazon CloudWatch SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-1.1.0 (BrendanHay)
03:53:20 * hackagebot amazonka-cloudtrail 1.1.0 - Amazon CloudTrail SDK.  https://hackage.haskell.org/package/amazonka-cloudtrail-1.1.0 (BrendanHay)
03:53:24 <srhb> bycn82: try writing the type signature for your program.
03:54:00 <rdz_> srhb: I'm using http://haddock.stackage.org/lts-3.1/http-conduit-2.1.8/Network-HTTP-Conduit.html#v:httpLbs
03:54:09 <rdz_> which explicitly states that it does not use lazy IO
03:54:18 <srhb> rdz_: Indeed.
03:54:20 <dramforever> hmm...looks like you still haven't really gotten the hang of haskell
03:54:30 <srhb> rdz_: That's what I meant, if you use conduits you probably don't want to combine it with lazy IO
03:55:17 <rdz_> so how can I make an IO action so that it does not use lazy IO?
03:55:30 <erisco> gah this is confusing and weirding me out
03:55:35 <srhb> rdz_: It just depends on the actions you use to do your IO. Where do you think you're using lazy IO?
03:55:39 <merijn> rdz_: Almost none use lazy IO
03:56:16 <erisco> I still don't get why I have to send a message downstream in order to respond
03:56:39 <erisco> I mean, to receive
03:56:45 <erisco> like, I want to receive a message from downstream
03:56:50 <erisco> but to do that I have to respond with a message
03:57:03 <merijn> erisco: Well, yes
03:57:17 <merijn> pipes are coroutines, not asynchronous communication
03:57:17 <rdz_> srhb: the only place I can think might be where I generate a nonce for the URL (that URL is subsequently SHA512 hmac encoded and added as a header argument)
03:57:33 <rdz_> currently that's just being generated like this: liftM show (fmap (\x -> round $ x * 10^(7 :: Integer)) getPOSIXTime :: IO Integer)
03:57:34 <erisco> what does coroutine mean
03:57:43 <srhb> rdz_: and what are you deepseq'ing exactly that fixes your problem?
03:58:17 <rdz_> srhb: I deepseq both the URL and the header arguments
03:58:22 <rdz_> once I did that problem seemed to go away
03:58:22 * hackagebot amazonka-elasticache 1.1.0 - Amazon ElastiCache SDK.  https://hackage.haskell.org/package/amazonka-elasticache-1.1.0 (BrendanHay)
03:58:24 * hackagebot amazonka-importexport 1.1.0 - Amazon Import/Export SDK.  https://hackage.haskell.org/package/amazonka-importexport-1.1.0 (BrendanHay)
03:58:26 * hackagebot amazonka-s3 1.1.0 - Amazon Simple Storage Service SDK.  https://hackage.haskell.org/package/amazonka-s3-1.1.0 (BrendanHay)
03:58:28 * hackagebot amazonka-swf 1.1.0 - Amazon Simple Workflow Service SDK.  https://hackage.haskell.org/package/amazonka-swf-1.1.0 (BrendanHay)
03:58:30 * hackagebot amazonka-sdb 1.1.0 - Amazon SimpleDB SDK.  https://hackage.haskell.org/package/amazonka-sdb-1.1.0 (BrendanHay)
03:58:42 <srhb> rdz_: I think a paste would be helpful here.
03:59:46 <int_index> What did I reinvent here? https://github.com/int-index/source-morte/blob/master/src/Control/Lens/Discard.hs
04:01:40 <dgpratt_> have I deceived myself or is the GHC package/library not browsable on hackage?
04:01:58 <dgpratt_> and if that's the case, how to I get to the docs?
04:02:12 <dgpratt_> I found a wiki page with some dead links
04:02:35 <int_index> dgpratt_: Install GHC with documentation
04:02:39 <int_index> browse locally
04:02:58 <the_2nd> is there a more efficent / better way to access the second element in a list
04:03:09 <int_index> also this https://downloads.haskell.org/~ghc/latest/docs/html/
04:03:12 <the_2nd> other than x = head $ tail myList
04:03:13 <the_2nd> ?
04:03:25 <dgpratt_> thanks int_index
04:03:32 * hackagebot amazonka-codecommit 1.1.0 - Amazon CodeCommit SDK.  https://hackage.haskell.org/package/amazonka-codecommit-1.1.0 (BrendanHay)
04:03:34 * hackagebot amazonka-codedeploy 1.1.0 - Amazon CodeDeploy SDK.  https://hackage.haskell.org/package/amazonka-codedeploy-1.1.0 (BrendanHay)
04:03:36 * hackagebot amazonka-cloudfront 1.1.0 - Amazon CloudFront SDK.  https://hackage.haskell.org/package/amazonka-cloudfront-1.1.0 (BrendanHay)
04:03:38 * hackagebot amazonka-efs 1.1.0 - Amazon Elastic File System SDK.  https://hackage.haskell.org/package/amazonka-efs-1.1.0 (BrendanHay)
04:03:38 <int_index> the_2nd: `myList ^? ix 1`
04:03:40 * hackagebot amazonka-codepipeline 1.1.0 - Amazon CodePipeline SDK.  https://hackage.haskell.org/package/amazonka-codepipeline-1.1.0 (BrendanHay)
04:03:59 <int_index> > [1..10] ^? ix 1
04:04:01 <lambdabot>  Just 2
04:04:06 <liste> pattern matching?
04:04:16 <erisco> I am making such a mess of this library XD
04:04:26 <int_index> > [1..10] ^? ix 500
04:04:28 <lambdabot>  Nothing
04:05:53 <rdz_> srhb: http://lpaste.net/139350
04:05:59 <erisco> this is my terrible pipes code... help please http://lpaste.net/139351
04:06:20 <erisco> also  runEffect $ (return source >~> return peeker >~> return test) undefined
04:06:32 <erisco> I don't know how I am supposed to use >~> but it is the only way I can figure out how to put my program together
04:06:51 <rdz_> srhb: code is a bit messy, sorry... but I added the deepseq on line 42
04:07:05 <rdz_> had to piece the code together from 2 modules
04:07:43 <srhb> rdz_: Hmm, yes.
04:08:08 <the_2nd> within a function I have defined "items" via a where clause
04:08:21 <the_2nd> how can I pattern match against it?
04:08:42 * hackagebot amazonka-elasticbeanstalk 1.1.0 - Amazon Elastic Beanstalk SDK.  https://hackage.haskell.org/package/amazonka-elasticbeanstalk-1.1.0 (BrendanHay)
04:08:43 <rdz_> srhb: on windows it worked fine without it, but in my VM it appeared not to be sending the header
04:08:44 * hackagebot amazonka-autoscaling 1.1.0 - Amazon Auto Scaling SDK.  https://hackage.haskell.org/package/amazonka-autoscaling-1.1.0 (BrendanHay)
04:08:46 * hackagebot amazonka-ses 1.1.0 - Amazon Simple Email Service SDK.  https://hackage.haskell.org/package/amazonka-ses-1.1.0 (BrendanHay)
04:08:48 * hackagebot amazonka-support 1.1.0 - Amazon Support SDK.  https://hackage.haskell.org/package/amazonka-support-1.1.0 (BrendanHay)
04:08:50 * hackagebot amazonka-dynamodb-streams 1.1.0 - Amazon DynamoDB Streams SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-streams-1.1.0 (BrendanHay)
04:08:58 <zalatovo> the_2nd: case items of ... ?
04:09:36 <srhb> rdz_: Where do you get the Connection arguments from?
04:10:39 <rdz_> srhb: there's about 8 or so different functions that can generate a Connection
04:11:01 <rdz_> for example:
04:11:03 <srhb> rdz_: If those deepseqs really work, then I suppose those would be the culprits
04:11:22 <rdz_> here's an example: getOrderStatusConnection str = privateConnection (getOrderStatusURL str) [] []
04:11:34 <erisco> heck, even if I just use acquire, which I'd expect to do the same as await
04:11:40 <erisco> it skips "hello" and "world"
04:11:46 <erisco> no ideas
04:12:08 <rdz_> I suppose a good way to test - I remove the deepseq and see if it goes back to having an error
04:12:13 <rdz_> it could after all be a coincidence
04:12:16 <erisco> if I compose with >+> instead of >~> the behaviour changes oO
04:12:30 <srhb> rdz_: I don't see any obvious culprit in privateConnection at least
04:13:25 <srhb> rdz_: Unless it's getPOSIXTime, but I really don't see how that could be the case.
04:13:52 * hackagebot amazonka-redshift 1.1.0 - Amazon Redshift SDK.  https://hackage.haskell.org/package/amazonka-redshift-1.1.0 (BrendanHay)
04:13:54 * hackagebot amazonka-opsworks 1.1.0 - Amazon OpsWorks SDK.  https://hackage.haskell.org/package/amazonka-opsworks-1.1.0 (BrendanHay)
04:13:56 * hackagebot amazonka-emr 1.1.0 - Amazon Elastic MapReduce SDK.  https://hackage.haskell.org/package/amazonka-emr-1.1.0 (BrendanHay)
04:13:58 * hackagebot amazonka-cognito-identity 1.1.0 - Amazon Cognito Identity SDK.  https://hackage.haskell.org/package/amazonka-cognito-identity-1.1.0 (BrendanHay)
04:14:00 * hackagebot amazonka-ssm 1.1.0 - Amazon Simple Systems Management Service SDK.  https://hackage.haskell.org/package/amazonka-ssm-1.1.0 (BrendanHay)
04:14:20 <srhb> Okay, does anyone have a handy weechat filter for #haskell+hackagebot+amazonka? :-)
04:16:22 <erisco> nobody noes pipes
04:17:15 <dramforever> someone make hackagebot ignore amazonka stuff
04:17:40 <Hafydd> I don't think the idea of logging a global package DB in a single channel is scalable.
04:17:54 <Hafydd> Perhaps this is the point at which it becomes unmanageable.
04:17:56 <srhb> It doesn't need to be scalable to be useful.
04:17:59 <srhb> Yes, that's possible.
04:18:02 <rdz_> srhb: so I tested it with and without deepseq... without deepseq it consistently fails (with maybe 1/5 success)
04:18:22 <rdz_> srhb: but oddly enough with deepseq in it still failed once
04:18:31 <rdz_> and coz I did so few tests it could just be a coincidence
04:19:02 * hackagebot amazonka-ml 1.1.0 - Amazon Machine Learning SDK.  https://hackage.haskell.org/package/amazonka-ml-1.1.0 (BrendanHay)
04:19:04 * hackagebot amazonka-workspaces 1.1.0 - Amazon WorkSpaces SDK.  https://hackage.haskell.org/package/amazonka-workspaces-1.1.0 (BrendanHay)
04:19:06 * hackagebot amazonka-dynamodb 1.1.0 - Amazon DynamoDB SDK.  https://hackage.haskell.org/package/amazonka-dynamodb-1.1.0 (BrendanHay)
04:19:08 * hackagebot amazonka-rds 1.1.0 - Amazon Relational Database Service SDK.  https://hackage.haskell.org/package/amazonka-rds-1.1.0 (BrendanHay)
04:19:10 * hackagebot amazonka-ds 1.1.0 - Amazon Directory Service SDK.  https://hackage.haskell.org/package/amazonka-ds-1.1.0 (BrendanHay)
04:19:49 <rdz_> srhb: anyway, I'm going to leave it alone for a while and check the logs later
04:19:58 <srhb> rdz_: I'm not an expert in analyzing these issues, but I really can't see how those deepseqs help unless there's a culprit in one of the argument generating functions, and I don't see one right now, sorry.
04:20:00 <rdz_> srhb: thanks for all the help
04:20:12 <srhb> Welcome, sorry I had no more useful information. Good luck :)
04:22:32 <srhb> If anyone else is using Weechat, I guess this should work: /filter add amazonka * nick_hackagebot amazonka
04:22:33 <zipper> Hey I want to use the CPP preprocessor for conditional compilation but I am running into the following issue:
04:23:23 <zipper> #if GHC < 7,10 `--ghc 7.8 and downwards code here` #else `-- ghc 7.10 forward here` #endif
04:23:32 <zipper> Why would that fail?
04:24:13 * hackagebot amazonka-cloudwatch-logs 1.1.0 - Amazon CloudWatch Logs SDK.  https://hackage.haskell.org/package/amazonka-cloudwatch-logs-1.1.0 (BrendanHay)
04:24:15 * hackagebot amazonka-route53 1.1.0 - Amazon Route 53 SDK.  https://hackage.haskell.org/package/amazonka-route53-1.1.0 (BrendanHay)
04:24:17 * hackagebot amazonka-cloudsearch 1.1.0 - Amazon CloudSearch SDK.  https://hackage.haskell.org/package/amazonka-cloudsearch-1.1.0 (BrendanHay)
04:24:19 * hackagebot amazonka-storagegateway 1.1.0 - Amazon Storage Gateway SDK.  https://hackage.haskell.org/package/amazonka-storagegateway-1.1.0 (BrendanHay)
04:24:19 <merijn> zipper: You mean literally that?
04:24:21 * hackagebot amazonka-ec2 1.1.0 - Amazon Elastic Compute Cloud SDK.  https://hackage.haskell.org/package/amazonka-ec2-1.1.0 (BrendanHay)
04:24:48 <srhb> zipper: Isn't it something like __GLASGOW_HASKELL__ or was it changed
04:24:57 <merijn> zipper: The answer would be "because that's not how the CPP symbols of GHC aren't numbered like that"
04:25:01 <zipper> I used exactly that
04:25:03 <merijn> s/aren't/are
04:25:09 <zipper> How should they be?
04:25:16 <zipper> I saw that on stack overflow
04:25:41 <merijn> "# if __GLASGOW_HASKELL__ >= 704"
04:25:49 <merijn> For 7.4
04:26:51 <hvr> oh.... it's amzonka time again =)
04:29:03 <zipper> Thanks
04:29:23 * hackagebot amazonka-kms 1.1.0 - Amazon Key Management Service SDK.  https://hackage.haskell.org/package/amazonka-kms-1.1.0 (BrendanHay)
04:29:25 * hackagebot amazonka-elastictranscoder 1.1.0 - Amazon Elastic Transcoder SDK.  https://hackage.haskell.org/package/amazonka-elastictranscoder-1.1.0 (BrendanHay)
04:29:27 * hackagebot amazonka-lambda 1.1.0 - Amazon Lambda SDK.  https://hackage.haskell.org/package/amazonka-lambda-1.1.0 (BrendanHay)
04:29:29 * hackagebot amazonka-ecs 1.1.0 - Amazon EC2 Container Service SDK.  https://hackage.haskell.org/package/amazonka-ecs-1.1.0 (BrendanHay)
04:29:31 * hackagebot hspec-core 2.2.0 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-core-2.2.0 (SoenkeHahn)
04:34:33 * hackagebot hspec-discover 2.2.0 - Automatically discover and run Hspec tests  https://hackage.haskell.org/package/hspec-discover-2.2.0 (SoenkeHahn)
04:34:35 * hackagebot hspec 2.2.0 - A Testing Framework for Haskell  https://hackage.haskell.org/package/hspec-2.2.0 (SoenkeHahn)
04:47:47 * hackagebot wiring 0.4.1 - Wiring, promotion and demotion of types.  https://hackage.haskell.org/package/wiring-0.4.1 (seanparsons)
04:57:47 * hackagebot reddit 0.2.0.0 - Library for interfacing with Reddit's API  https://hackage.haskell.org/package/reddit-0.2.0.0 (Intolerable)
05:06:33 <amontimur> when i pipe 'ghc-pkg list' into head, it appends a colon to the first line
05:06:40 <amontimur> can somebody please verify this behaviour?
05:07:16 <dramforever> verified
05:07:36 <zalatovo> amontimur: you mean the colon at the end of the first line?
05:07:54 <dramforever> same for redirecting to a file
05:08:14 <amontimur> zalatovo: correct. when i dont pipe, its not there
05:08:31 <amontimur> dramforever: makes sense
05:08:48 <dramforever> weird...
05:09:01 <amontimur> right?
05:09:03 <zalatovo> amontimur: it also uses colors in the output when you don't pipe, so it's probably aware of when the output is being piped
05:09:25 <amontimur> zalatovo: mine isnt colored, pipe or no pipe
05:09:25 <zalatovo> When you pipe it into less or head it uses parentheses instead of colors
05:09:36 <zalatovo> amontimur: Around ghc package only for me
05:09:41 <zalatovo> amontimur: colors, that is
05:09:59 <amontimur> zalatovo: oh yeah, you are right
05:10:56 <dramforever> no colors for me
05:11:32 <zalatovo> dramforever: not when redirecting output, then there are no colors for me either
05:11:46 <dramforever> no colors for me on the terminal either
05:11:55 <pyon> Just wondering... Shouldn't Arrow be a subclass of Profunctor?
05:14:06 <zipper> What can I use to get garbage collection stats and other such meta information from ide-backend or from GHC itself?
05:14:16 <merijn> zipper: Profiling
05:14:32 <dramforever> pyon: actually it's much more than that
05:14:37 <merijn> zipper: Real World Haskell has a chapter on using it to look at memory usage, etc. but there's flags for GC, etc. too
05:14:44 <dramforever> Category + Strong <-> Arrow
05:16:54 <zipper> merijn: Thank you.
05:17:02 <putis> hi!
05:18:44 <lpaste_> putis pasted “Mappend” at http://lpaste.net/6456749461359034368
05:19:22 <zipper> putis: Hi
05:19:28 <merijn> putis: That is equivalent to "gen <> gen <> gen"
05:19:50 <merijn> Or, I guess "mconcat $ repeat 3 gen"
05:19:55 <supki> dramforever: how do you get arr from that?
05:20:09 <dramforever> :t rmap . Control.Category.id
05:20:11 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
05:20:17 <dramforever> uh
05:20:34 <putis> zipper, merijn: I would like to ensure, that it is O(n) operation due to lazyness. Is it?
05:20:34 <dramforever> :t \f -> rmap f Control.Category.id
05:20:36 <lambdabot> (Category p, Profunctor p) => (b -> c) -> p b c
05:20:40 <dramforever> supki: ^
05:20:48 <supki> thanks
05:20:55 <dramforever> pretty sure there's already one somewhere, though
05:21:00 <merijn> putis: Depends on the implementation of mappend for gen's type
05:21:21 <tranma> so, I was using bos's `statistics` library, in particular for the kolmogorov-smirnov test. I expected `kolmogorovSmirnovTest2 0.05 xs xs` to be "NotSignificant", since the distribution of xs must be itself, but the test returned "Significant". Is this right or am I misunderstanding something?
05:22:57 <putis> merijn: So it 'could' be O(n). Mappend on lists gives O(n) in such situation?
05:28:58 <the_2nd> I want to create a list
05:29:09 <the_2nd> with each element being someFunc(index)
05:29:28 <the_2nd> with n elements
05:29:28 <Nik05> fmap someFunc [1..]
05:30:12 <the_2nd> createList parameters = myfunc [1..n] where myfunc = ...
05:30:13 <the_2nd> ?
05:30:47 <Nik05> no
05:30:56 <Nik05> :t map
05:30:57 <lambdabot> (a -> b) -> [a] -> [b]
05:31:15 <Nik05> it takes a function and a list and applies this function to each element
05:31:23 <the_2nd> sure
05:31:30 <the_2nd> so map myfunc [1..n] ?
05:31:34 <Nik05> yes
05:31:38 <the_2nd> nice, thanks
05:31:44 <Nik05> if that is what you want to do
05:31:56 <the_2nd> guess so :D
05:32:11 <Nik05> or [0..(n-1)]
05:46:41 <merijn> putis: mappend on lists would be O(n), yeah, but some tree type might have O(1) append or O(log n) append, or...
05:46:55 <merijn> putis: In other words, you really can't say anything general about the complexity
05:47:30 <Intolerable> () has a really fast mappend
05:47:34 <merijn> Intolerable: ;)
05:47:54 <merijn> So does "Sum Int" and "Product Int" :p
05:48:04 <Intolerable> > mconcat $ take 50000 $ repeat ()
05:48:05 <lambdabot>  ()
05:48:07 <Intolerable> waow
05:49:55 <putis> really instructive ;) thanks
05:51:03 <the_2nd> is nesting "where"s bad practice?
05:51:17 <the_2nd> .. = something + a
05:51:23 <the_2nd> where something = x + 3 
05:51:25 <the_2nd> where x = 
05:51:33 <merijn> the_2nd: No
05:51:49 <Intolerable> if you're putting an extra "where" on everything it looks a bit clunky
05:51:54 <merijn> the_2nd: As long as the amount of nesting makes sense for readability
05:52:11 <merijn> Sure, I'd reserve nested where's for longer local functions
05:52:16 <Intolerable> if you can keep things in one "where" block that's ideal
05:52:34 <Intolerable> but don't worry too much about adding more of them
05:52:35 <cwraith> But sometimes I want access to parameters in another definition!
05:52:53 <the_2nd> I'll paste my current solution once done
05:55:33 <lunaris> Hi all; say you have a function f :: IO a -> IO a; is lifting this in a monad transformer stack possible? Or is it commonly known/accepted that it isn't etc.?
05:55:43 <lunaris> I can get the result up with something like MonadIO.
05:55:45 <Intolerable> it's not in the general case
05:55:50 <lunaris> I was afraid of that.
05:55:56 <lunaris> Oh well, best to make sure.
05:56:07 <Intolerable> take a look at monad-control though
05:56:08 <merijn> lunaris: "liftIO . f"?
05:56:14 <Intolerable> (i think it's monad-control)
05:56:19 <lunaris> merijn: Apologies, I should clarify.
05:56:42 <lunaris> I want to write a transformer T such that I can lift f to the type liftedF :: T a -> T a
05:56:43 <Intolerable> he wants MonadIO m => (IO a -> IO b) -> (m a -> m b) i presume
05:56:48 <lunaris> Basically.
05:57:03 <lunaris> But of course, the stack is polymorphic so can't be unrolled down to IO in the general case.
05:57:10 <lunaris> So I can't unpack the argument etc.
05:57:11 <merijn> lunaris: Maybe mmorph?
05:57:14 <merijn> @hackage mmorph
05:57:14 <lambdabot> http://hackage.haskell.org/package/mmorph
05:57:22 <Intolerable> @monad-control
05:57:22 <lambdabot> Unknown command, try @list
05:57:26 <Intolerable> @hackage monad-control
05:57:26 <lambdabot> http://hackage.haskell.org/package/monad-control
05:57:29 <Intolerable> might also be handy
05:58:03 <lunaris> This will no doubt prove tricky since I'm using monad-classes.
05:58:10 <Intolerable> im sorry
05:58:49 <Intolerable> i've run into the same problem a couple times
05:58:52 <Intolerable> gave up tbh
05:58:53 <lunaris> ? It's all my fault :)
05:58:54 <aweinstock> :t liftIO . (undefined :: IO a -> IO b)
05:58:55 <lambdabot> MonadIO m => IO a1 -> m a
05:59:10 <lunaris> aweinstock: The problem being that you want m a -> m a.
06:00:33 <lunaris> So I don't think mmorph is what I want; checking monad-control now.
06:00:39 <aweinstock> and in order to apply that to the input, you need a (MonadIO m => m a -> IO a), which isn't possible in general (if I'm thinking this through correctly)?
06:00:50 <Intolerable> corretct
06:01:03 <Intolerable> (imagine that's spelt corretctly)
06:01:07 <lunaris> :D
06:02:02 <lunaris> Don't suppose anyone can give an intuition behind monad-control for the lazy visitor?
06:03:13 <lunaris> Ok, so MonadTransControl lets you take some state from the transformer "down with you" into the transformed monad and use it there in your computation.
06:03:16 <lunaris> I think.
06:03:21 <Intolerable> essentially
06:03:45 <lunaris> MonadBaseControl sounds like what I want?
06:03:48 <the_2nd> http://pastebin.com/fjcxsbMF
06:03:53 <the_2nd> "not in scope: current"
06:03:56 <Intolerable> yeah it looks like it
06:04:09 <lunaris> It'll give me a function that I can pass my m a "down into" to work "at the IO level I know exists", perhaps?
06:04:26 <Intolerable> current is only in scope for the "y" line
06:04:35 <the_2nd> ah
06:04:37 <Intolerable> the where only covers the "y", not the "x"
06:04:42 <jmcarthur> i think it would be nice if i could specify up to which generation i would like performGC to run.
06:04:44 <lunaris> the_2nd: Additionally, you can lose the brackets with "sin" and "cos"
06:05:07 <jmcarthur> instead of only having the granularity of minor vs. major
06:05:11 <lunaris> E.g. y = centerY + diameter/2.0 * (sin current - current * cos current)
06:05:34 <merijn> Yeah, I don't really understand why current is at a new level of nesting?
06:05:43 <spdionis> Hi, I'm following this tutorial to setup emacs with haskell but instead of using cabal i'm using stackage. https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
06:06:03 <ReinH> the_2nd: you don't wrap arguments in parens in haskell
06:06:05 <spdionis> after ading these lines in my config i get an error when opening a haskell file:
06:06:11 <spdionis> https://www.irccloud.com/pastebin/MEwSFDAz/
06:06:31 <merijn> the_2nd: I would also avoid the habit of writing "abs(radEnd - radStart)" instead of "abs (radEnd - radStart)"
06:06:31 <aweinstock> lunaris: if the (IO a -> IO b) is under your control, wouldn't it be simpler to make it (MonadIO m => m a -> IO b) in the first place?
06:06:42 <lunaris> It's not :)
06:06:43 <spdionis> i think I have to make it use `stack ghc` instead of `ghc`. Can anyone help me change that?
06:06:54 <merijn> aweinstock: Good luck trying to write that :p
06:06:59 <lunaris> Specifically, it's `withTransaction` from postgresql-simple.
06:07:06 <merijn> aweinstock: The only thing that can do is throwaway the input argument :p
06:07:12 <lunaris> And I'm wanting to write a PostgreSQLT monad transformer.
06:07:18 <Intolerable> yeah i've had the same problem with async
06:07:20 <ReinH> aweinstock: specialized forever?
06:07:26 <ReinH> er, merijn ^
06:07:29 <the_2nd> merijn, cant see a difference there
06:07:38 <merijn> the_2nd: space after function name :)
06:07:41 <the_2nd> "current" seems to be an integer now
06:07:49 <ReinH> the_2nd: space is used for function application in haskell
06:07:49 <merijn> ReinH: How would you evaluate that to IO?
06:07:53 <aweinstock> merijn: oh (IO a -> IO a) then? (I probably accidentally generalized what lunaris was talking about)
06:08:07 <lunaris> aweinstock: It is IO a -> IO a.
06:08:11 <ReinH> the_2nd: rather than parens
06:08:14 <merijn> lunaris: What do you wanna accomplish with the PostgreSQLT?
06:08:18 <lunaris> Specifically, it's withTransaction :: Connection -> IO a -> IO a.
06:08:25 <jmcarthur> use case. i'm making an engine that will generate a lot of data during each frame which can be thrown away immediately afterward, and it would be nice to be able to control the collections to improve worst case latency. my thinking is that if i make sure the young generation holds all this temporary data i can empty it out after each frame without having to traverse the old generation
06:08:25 <lunaris> I don't want my code to use IO types.
06:08:37 <lunaris> I want it to be f :: MonadPostgreSQL m => ... -> m a.
06:08:43 <lunaris> Which is more precise about what the function is doing.
06:08:49 <the_2nd> seems like current is cast to int
06:08:53 <lunaris> So I define the type class, and a transformer to implement it.
06:08:57 <Intolerable> what's the source of withConnection look like?
06:08:58 <the_2nd> because I divide by nPoints?
06:09:02 <lunaris> And the type class has methods like query, execute, etc.
06:09:03 <Intolerable> some bracket-y nonsense?
06:09:08 <lunaris> Which wrap their postgresql-simple counterparts.
06:09:09 <merijn> jmcarthur: If it's dead before minor GC it should already be thrown out, no?
06:09:11 <ReinH> the_2nd: there is no casting in haskell
06:09:17 <lunaris> But now I need to wrap withTransaction.
06:09:25 <jmcarthur> merijn: not dead before minor gc. i'm talking about multiple generations
06:09:37 <aweinstock> :t liftIO . unsafePerformIO
06:09:38 <lambdabot> Not in scope: ‘unsafePerformIO’
06:09:50 <aweinstock> :t liftIO . System.IO.Unsafe.unsafePerformIO
06:09:51 <lunaris> And it uses its monad in an argument position.
06:09:51 <lambdabot> MonadIO m => IO (IO a) -> m a
06:09:52 <jmcarthur> merijn: but an alternative is to use the minor gc instead, but i would probably have to make it much bigger
06:09:57 <merijn> aweinstock: ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ
06:10:11 <lunaris> Seems like MonadBaseControl might work.
06:10:13 <the_2nd>     Couldn't match expected type ‘Double’ with actual type ‘Int’
06:10:13 <the_2nd>     In the first argument of ‘cos’, namely ‘current’
06:10:13 <the_2nd>     In the first argument of ‘(+)’, namely ‘cos current’
06:10:15 <Intolerable> that's horrifying
06:10:24 <lunaris> But I just need to hack a version that works with monad-classes.
06:10:31 <lunaris> I.e. one parameterised by Peano and proxies etc.
06:10:32 <merijn> @quote monochrom who.do.you.call
06:10:33 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
06:10:37 <merijn> the_2nd: ^^^^^^
06:10:43 <ReinH> the_2nd: i is an Int
06:10:46 <Intolerable> monad-control's probably your best bet
06:11:01 <ReinH> as is nPoints
06:11:02 <aweinstock> is putting unsafePerformIO inside an IO action dangerous? (since it's already doing IO?)
06:11:07 <the_2nd> ReinH, how can I fix this?
06:11:11 <merijn> the_2nd: Division, etc. demands that both arguments have the same type
06:11:20 <merijn> the_2nd: See lambdabot's quote 5 lines up
06:11:22 <lunaris> aweinstock: It's always dangerous if what you're doing isn't "morally pure".
06:11:22 <mniip> aweinstock, unsafePerformIO is always dangerous
06:11:30 <ReinH> the_2nd: your type errors will be easier to understand if you give your where definitions explicit type declarations
06:11:30 <jmcarthur> aweinstock: all unsafePerformIO is insade an IO action, in real programs
06:11:32 <the_2nd> ah thanks
06:11:36 <aweinstock> :t return . System.IO.Unsafe.unsafePerformIO . liftIO
06:11:37 <lambdabot> Monad m => IO a -> m a
06:11:45 <mniip> jmcarthur, what
06:11:54 <lunaris> aweinstock: Your problem is not executing arbitrary IO.
06:11:57 <jmcarthur> mniip: due to the type of main...
06:11:59 <lunaris> It's unwrapping arbitrary "m".
06:12:05 <aweinstock> :t return . System.IO.Unsafe.unsafePerformIO . liftIO :: MonadIO m => IO a -> m a
06:12:06 <lambdabot> MonadIO m => IO a -> m a
06:12:08 <mniip> jmcarthur, I don't see how that relates to unsafePerformIO
06:12:24 <the_2nd> ReinH, merijn compiling now, thanks
06:12:26 <mniip> a hello-world program doesn't do unsafePerformIO
06:12:29 <lunaris> mniip: His point is that all actions execute under the IO umbrella of main.
06:12:36 <merijn> the_2nd: The two functions you wanna remember for converting numbers are:
06:12:38 <jmcarthur> mniip: i was responding to "is putting unsafePerformIO inside an IO action dangerous? (since it's already doing IO?)"
06:12:40 <merijn> :t fromIntegral
06:12:41 <lambdabot> (Integral a, Num b) => a -> b
06:12:43 <lunaris> So if you use unsafePerformIO, it is being used in an existing IO block.
06:12:45 <merijn> :t realToFrac
06:12:46 <lambdabot> (Fractional b, Real a) => a -> b
06:12:52 <mniip> lunaris, how about GHCI
06:12:52 <lunaris> Assuming you're running from a main function.
06:13:02 <mniip> or a shared library
06:13:04 <lunaris> Well, GHCi runs everything inside an implicit do-block scoped to IO.
06:13:13 <mniip> lunaris, it doesn't have to be IO though
06:13:13 <lunaris> Libraries, there's no difference, right?
06:13:18 <mniip> > 2 + 2
06:13:19 <lambdabot>  4
06:13:21 <mniip> there's no IO here
06:13:24 <lunaris> I guess the argument is, if you want to run some code.
06:13:32 <lunaris> You're going to write a program with a main function.
06:13:37 <aweinstock> :t \f -> liftIO . return . System.IO.Unsafe.unsafePerformIO . liftIO $ f
06:13:37 <merijn> mniip: "instance Num a => Num (IO a) where" :D
06:13:38 <lambdabot> MonadIO m => IO a -> m a
06:13:44 <ReinH> ghci runs inside an IO monad
06:13:45 <lunaris> Any function then that uses unsafePerformIO will be running inside the IO monad that main function kicks off.
06:13:50 <Intolerable> > unsafePerformIO "brb hacking lambdabot"
06:13:51 <lambdabot>  Not in scope: ‘unsafePerformIO’
06:13:52 <jmcarthur> mniip: i did say "in real programs"
06:13:56 <ReinH> that's why you can do foo <- getLine and etc
06:14:02 <lunaris> jmcarthur: Are there any other kinds? :)
06:14:13 <mniip> hypothetical programs
06:14:16 <ReinH> lunaris: fsvo real, yes
06:14:24 <merijn> Intolerable: Lambdabot is pretty secure by now :p
06:14:35 <aweinstock> :t \f -> liftIO . f . return . System.IO.Unsafe.unsafePerformIO . liftIO
06:14:35 <jmcarthur> perhaps i should have said "built programs" or "executables"
06:14:37 <lambdabot> (Monad m1, MonadIO m) => (m1 a1 -> IO a) -> IO a1 -> m a
06:14:53 <lunaris> jmcarthur: But code can't run if it's not executed, no?
06:14:54 <ReinH> jmcarthur: "programs that are executed"
06:14:55 <mniip> jmcarthur, how about this
06:14:58 <int-e> the :t command is much more permissive than the evaluator
06:14:59 <Intolerable> my plans have been thwarted
06:15:02 <lunaris> Hence my argument that you're correct even if you talk about libraries.
06:15:04 <aweinstock> :t \f -> liftIO . (f :: IO a -> IO a) . return . System.IO.Unsafe.unsafePerformIO . liftIO
06:15:05 <mniip> passing a FunPtr to a pure function to the FFI?
06:15:05 <lambdabot>     Couldn't match expected type ‘IO a1 -> IO a1’ with actual type ‘r’
06:15:05 <lambdabot>       because type variable ‘a1’ would escape its scope
06:15:05 <lambdabot>     This (rigid, skolem) type variable is bound by
06:15:15 <lunaris> Because those libraries won't be run unless linked into a running-from-main program, no?
06:15:20 <jmcarthur> lunaris: but mniip brought up ghci
06:15:26 <aweinstock> :t liftIO . (undefined :: IO a -> IO a) . return . System.IO.Unsafe.unsafePerformIO . liftIO
06:15:26 <lunaris> Same deal?
06:15:28 <lambdabot> MonadIO m => IO a -> m a
06:15:31 <quchen2> Using unsafePerformIO with code that's not referentially transparent is usafe regardless of use site.
06:15:38 <lunaris> I think we agree but have different definitions.
06:15:55 <mniip> unsafePerformIO is also terribly dangerous in presence of polymorphism
06:15:56 <jmcarthur> lunaris: nothing funamentally requires ghci to even be written in haskell. it's possible there could be no IO involved, exactly
06:16:06 <ReinH> anyway, unsafePerformIO isn't unsafe (just) because it performs IO, so evaluating it in an IO action won't make it safe
06:16:14 <Intolerable> :t let x = x in x :: MonadIO m => (IO a -> IO b) -> (m a -> m b)
06:16:14 <lunaris> Ah, thinking outside the box.
06:16:15 <lambdabot> MonadIO m => (IO a -> IO b) -> m a -> m b
06:16:16 <lunaris> Gotcha.
06:16:21 <Intolerable> easy wheres my prize
06:16:43 <Intolerable> btw
06:16:53 <int-e> Intolerable: somewhere at the bottom of the pit
06:16:54 <Intolerable> do effect systems handle this kind of thing any better
06:17:18 <lunaris> I think it would still require explicit classification.
06:17:18 <Intolerable> if i just keep looking deeper into the pit i'll find it eventually probably?
06:17:28 <lunaris> I.e. the ability to lift an effect down through some other set of unknown effects.
06:17:31 <ReinH> yes just keep going
06:17:34 <lunaris> I think I can make monad-control work with monad-classes.
06:17:39 <lunaris> Time to hack it out.
06:17:48 <Intolerable> <<loop>>
06:17:54 <ReinH> "lift an effect down"?
06:18:02 <ReinH> You keep using that word...
06:18:23 <lunaris> What have I done now?
06:18:35 <lunaris> I feel like I'm just being goaded to say something stupid or incorrect :)
06:18:37 <Intolerable> is there a better word that's unambiguous?
06:18:40 <ReinH> lift... down...
06:18:43 <lunaris> Which I am wont to do.
06:18:47 <aweinstock> lift an effect up?
06:18:53 <lunaris> Oh whatever.
06:18:58 <ReinH> lunaris: :p
06:19:08 <lunaris> "You know what I mean" -- the only value in communication.
06:19:16 <ReinH> literally yes
06:19:19 <lunaris> And avoiding txt spk, ntrlly.
06:19:20 <Intolerable> lets call this "downwards lifting" operation a "tfil"
06:19:34 <lunaris> "drop", "sneak", "onTheBackHand"
06:19:36 <lunaris> Take your pick.
06:19:38 <jmcarthur> lower
06:19:38 <ReinH> lower?
06:19:45 <aweinstock> in (StateT s IO a), the MonadState part is considered to be "above" the MonadIO part?
06:19:53 <predator117> colift, obviously
06:19:58 <ReinH> "what's a word for lifting something but downwards?"
06:19:59 <lunaris> cocolower.
06:20:00 <Intolerable> delift
06:20:02 <ReinH> "colift"
06:20:02 <quchen2> colift is called lower.
06:20:03 <ReinH> damn it
06:20:05 <lunaris> unlift.
06:20:11 <merijn> Cotransformers? :p
06:20:13 <lunaris> putDown
06:20:13 <Intolerable> drop
06:20:16 * ocharles__ looks of disapprovals all over this channel
06:20:19 <aweinstock> @quote co-joke
06:20:19 <lambdabot> #haskell says: < Fuuzetsu> why does this channel always eventually end up at co-jokes? < Iceland_jack> Fuuzetsu: What do category theorists drink on a cold winter night? < mm_freak> Fuuzetsu: because we turn cotheorems into ffee < Iceland_jack>     A: Hot a. < hpc> Fuuzetsu: it's the logical course of co-nversation < bennofs> because we all love
06:20:19 <lambdabot> CO-mputer science :) < Fuuzetsu> I immediately regret my decision to say anything.
06:20:22 <ReinH> ocharles__: <3
06:20:30 <lunaris> ocharles__: (☞ﾟヮﾟ)☞ ☜(ﾟヮﾟ☜)
06:20:48 <Intolerable> is there a corresponding cocharles
06:21:00 <ocharles__> Intolerable: yes, see my twitter account :)
06:21:15 <ocharles__> twitter.com/acid2 is cocharles
06:21:17 <lunaris> Aside: is anyone based in London, UK looking for a Haskell job?
06:21:19 <ReinH> One of these days I'll discover mputation and somehow become rich.
06:21:21 <merijn> We end up at co-jokes because they're easy :)
06:21:30 <lunaris> merijn: You mean co-hard
06:21:34 <lunaris> I'll stop now.
06:21:37 <Intolerable> i didnt ever promise my shit jokes were original
06:21:41 <merijn> lunaris: Naah, that one doesn't work :)
06:21:45 <jmcarthur> would co-hard really be the same as easy?
06:21:46 <Sindriava> Is there a list with O(1) ++ ?
06:21:52 <jmcarthur> it doesn't feel right
06:21:59 <merijn> jmcarthur: Not for any sensible definition of easy I can think of
06:22:00 <aweinstock> Sindriava: difference lists?
06:22:02 <lunaris> jmcarthur: No-one said it was the same :)
06:22:03 <merijn> Sindriava: DList?
06:22:05 <lunaris> An open problem.
06:22:12 <merijn> Sindriava: http://h2.jaguarpaw.co.uk/posts/demystifying-dlist/
06:22:19 <Sindriava> merijn: Thanks ^^
06:22:26 <aweinstock> > ("hello"++") . ("world"++) $ []
06:22:27 <lambdabot>  <hint>:1:32:
06:22:28 <lambdabot>      lexical error in string/character literal at end of input
06:22:33 <aweinstock> > ("hello"++) . ("world"++) $ []
06:22:35 <lambdabot>  "helloworld"
06:22:41 <quchen2> data List a = List a :++ List a | Cons a (List a) | Nil -- That one has O(1) concatenation like ordinary lists have O(1) cons.
06:22:52 <quchen2> The cost is redundancy.
06:22:57 <jmcarthur> dlist is great when used in the right place, but it's a terrible default for O(1) concat because using it incorrectly is just as bad as having O(n) concat
06:23:13 <ReinH> quchen2: :p
06:23:24 <mniip> yeah and DList is a bad functor
06:23:26 <merijn> jmcarthur: What is the incorrect way of using it?
06:23:46 <jmcarthur> merijn: this function is terrible with dlist:    view :: DList a -> Maybe (a, DList a)
06:23:58 <merijn> jmcarthur: oh, sure
06:24:00 <quchen2> ReinH: That wasn't a joke. You can sometimes gain quite a bit of performance by expanding data like that. It's arguably a bit hacky though so I wouldn't do it too often.
06:24:15 <ReinH> quchen2: No, the :p was because it's cute/clever
06:24:19 <merijn> jmcarthur: But in case you're only doing appending until you have a complete list it's fine
06:24:24 <ReinH> sorry, there are a limited number of smileys
06:24:40 <Intolerable> only if you aren't trying hard enough
06:24:44 <quchen2> ReinH: No. Source: lens ;-)
06:24:51 <merijn> ReinH: What did you say?! (╯°□°）╯︵ ┻━┻
06:24:52 <jmcarthur> merijn: agreed, and then you have to convert it to a normal list and stop using the dlist at all.
06:24:52 <ReinH> quchen2: slightly more initial encodings are often useful :)
06:25:04 <mniip> ಠ_ಠ
06:25:10 <Intolerable> 👺
06:25:11 <merijn> jmcarthur: Sure, but I always treat DList as "list builder"
06:25:16 <jmcarthur> yup
06:25:22 <ReinH> merijn: wait, what did I do now?
06:25:34 <arahael> \0_0/
06:25:39 <merijn> ReinH: Suggesting only a limited number of smileys exist :p
06:25:44 <ReinH> I mean
06:25:57 <ReinH> fsvo smiley
06:26:14 <ReinH> there are clearly a finite number
06:26:23 <jmcarthur> the problem is just that persistent builders can be pretty weird and easy to mess up if somebody just advised you to use them just because you wanted lists with fast concatenation
06:26:37 <jmcarthur> i like the word "just"
06:26:38 <quchen2> For some value of "number" there are only finitely many integers as well.
06:26:47 <merijn> ReinH: Not if unicode keeps growing over time :p
06:27:00 <Intolerable> 🐷
06:27:01 <merijn> quchen2: Only if you're an ultra-finitist
06:27:03 <ReinH> Are we accepting infinite-lengt smileys?
06:27:42 <quchen2> ReinH: "GHC performance improved by factor 100" -- ":" ++ repeat '-' ++ ")"
06:27:44 <ReinH> pls show me a bijection between smileys and the natural numbers
06:27:46 <mniip> quchen2, for some value of are that sentence is incorrect
06:28:37 <quchen2> Maybe I should have repeated the mouth, not the nose.
06:28:43 <quchen2> > ":-" ++ repeat ')'
06:28:45 <lambdabot>  ":-)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))...
06:28:51 <ReinH> quchen2: :p
06:28:56 <ReinH> but is it a smiley if we can't read it?
06:29:01 <ReinH> I say no
06:29:02 <Intolerable> ah yes, the classic passive aggressive :)))))))))
06:29:07 <ReinH> thus fsvo
06:29:08 <quchen2> I can read it!
06:29:10 <quchen2> :-) is happy.
06:29:12 <ReinH> you can't.
06:29:15 <quchen2> :-)) is happy-2.
06:29:16 <mniip> @let toSmiley 0 = ""; toSmiley n = let (p, q) = divMod n 0x10FFFF in chr q:toSmiley p
06:29:18 <lambdabot>  Defined.
06:29:22 <jmcarthur> with completely lazy evaluation i think dlist might be pretty much a perfect default
06:29:22 <quchen2> My smiley is happy (fix succ).
06:29:26 <mniip> > toSmiley 1039462085761927
06:29:28 <lambdabot>  "\1016469\485971\837"
06:29:38 <mniip> close enough
06:29:41 <Intolerable> "writing python makes me want to die :)))))))))))))"
06:29:54 <exio4> > text $ toSmiley 1039462085761927
06:29:56 <lambdabot>  󸊕񶩓ͅ
06:29:57 <arahael> Intolerable: Hey.
06:30:12 <arahael> Intolerable: Spare a thought to people (like me), who code in _both_ python and Javascript at work.
06:30:22 <Intolerable> same!
06:30:22 <arahael> Python is frankly amazing. (relatively)
06:30:23 <ReinH> Well, looks like I have successfull nerd sniped the entire channel in the most ridiculous way yet
06:30:28 <ReinH> success
06:30:33 <Intolerable> python is the nuisance-of-the-moment though
06:30:34 <lunaris> arahael: Thought spared; moving on ;)
06:30:36 <merijn> arahael: Until your code is >100 lines ;)
06:30:43 <rohan> python is a pain sometimes though .... duck_typing ...
06:30:50 <lunaris> I repeat my offer of a Haskell job in London, UK, to the right person.
06:30:57 <rohan> merjin: haha
06:31:06 <ReinH> rohan: duck typing is the only thing that makes it work
06:31:20 <Intolerable> who is the right person
06:31:23 <arahael> merijn: Haha, but seriously, it's not that bad.
06:31:26 <exio4> I would put the broken scoping here
06:31:28 <ReinH> Intolerable: the person they hire
06:31:33 <lunaris> I find duck typing is less "make it work" and more "do something, whatever it may be" :troll:
06:31:38 <arahael> exio4: The scoping is painful.
06:31:46 <rohan> yes .. but duck typing becomes a monstrosity if ur program is huge
06:31:53 <jmcarthur> an uncommonly stated reason python makes me sad is that i lose the ability to talk about interfaces, types, data structures, etc., even if i'm not writing python but just communicating with somebody used to thinking in python.
06:31:57 <arahael> duck typing is useful as a hack when doing mocking.  Mocking in OO languages... Blegh.
06:31:59 <lunaris> If it looks like a program and quacks like a program, it must be a program.
06:32:02 <hodapp> rohan: to be fair, so do *most* things when your program is huge.
06:32:16 <merijn> OT, etc.
06:32:22 <mniip> hmm
06:32:25 <mniip> @undefine
06:32:25 <lambdabot> Undefined.
06:32:27 <lunaris> Types, types, types; gimme, gimme, gimme.
06:32:27 <quchen2> Duck typing. https://pbs.twimg.com/media/B3Fvg-sCYAAkLSV.jpg
06:32:32 <mniip> @let toSmiley 0 = ""; toSmiley n = let (p, q) = divMod n 0x10FFFF in chr (q + 1):toSmiley p
06:32:34 <lambdabot>  Defined.
06:32:43 <lunaris> quchen2: Brilliant.
06:32:52 * hackagebot language-vhdl 0.1.0.2 - VHDL AST and pretty printer in Haskell  https://hackage.haskell.org/package/language-vhdl-0.1.0.2 (mararon)
06:32:58 <rohan> i disagree ... for huge programs compilation itself is pretty hard...since python merely interprets it misses quite a few errors
06:33:05 <mniip> @let fromSmiley [] = 0; fromSmiley (x:xs) = (ord x - 1) + 0x10FFFF * fromSmiley xs
06:33:06 <lambdabot>  Defined.
06:33:11 <Intolerable> 🐽🔌
06:33:13 <hodapp> Someone in #idris expressed that with mutable assignments and no declarations, Python's scoping rules are the only sensible ones.
06:33:18 <ReinH> rohan: what I mean is that you literally can't write python without duck typing
06:33:20 <mniip> > fromSmiley "ಠ_ಠ"
06:33:22 <lambdabot>  4010457272686816
06:33:23 <ReinH> since that's how dispatch works
06:33:30 <mniip> > toSmiley 4010457272686816
06:33:32 <lambdabot>  "\3232_\3232"
06:33:37 <rohan> ReinH : i agree with u on that ..
06:33:39 <mniip> \o/
06:33:56 <jmcarthur> i'm not sure i buy that, actually
06:33:58 <Intolerable> python is definitely about as good as it could be given its constraints
06:34:03 <arahael> hodapp: I don't buy that.
06:34:06 <ReinH> dynamic dispatch iz literally "see if this thing responds to this message"
06:34:10 <ReinH> *is
06:34:10 <hodapp> But to try to bring this back more Haskell-ward: Do folks have Haskell libraries they prefer that do similar jobs to the likes of NumPy, SciPy, and matplotlib?
06:34:12 <jmcarthur> the type system would need to be basically row types to work, but there could be a real type system
06:34:15 <arahael> hodapp: Python's scoping is _wierd_.
06:34:41 <rohan> hadapp: nope ... nothing beats python's libraries imho
06:34:44 <arahael> hodapp: NumPy, SciPy, are both methods to add more speed to python.
06:34:55 <ReinH> jmcarthur: but then it wouldn't be python
06:35:00 <rohan> *hodapp
06:35:01 <jmcarthur> row types are static duck types, is all i mean
06:35:07 <ReinH> jmcarthur: sure
06:35:42 <hodapp> arahael: To put it to an exact quote (which is from wleslie of #idris): "they are the only sensible scoping rules for a language with mutable bindings and no declarations. specifically, binding a variable means you're binding a local variable."
06:35:48 <jmcarthur> yes, it wouldn't be python. it would be ocaml's object system...
06:36:02 <ReinH> jmcarthur: they work rather nicely in elm
06:36:11 <arahael> hodapp: for x in foo_list: bar(lambda: baz(x))
06:36:21 <arahael> hodapp: What is the value of x in the lambda expresions?
06:36:26 <rohan> has anyone implemented dynamic programming algorithms in haskell?
06:36:28 <ReinH> jmcarthur: but you see I am technically correct, which is the best kind of correct ;)
06:36:39 <hodapp> arahael: I suspect this is off-topic here and you should ask him in #idris or elsewhere.
06:36:45 <rohan> say for example binomial coefficient
06:36:48 <jmcarthur> ReinH: i disagree. accidentally correct is the best kind of correct.
06:36:54 <ReinH> jmcarthur: heh
06:37:11 <rohan> jmcarthu: haha
06:37:17 <arahael> hodapp: Well, that program fragment is completely incorrect and utterly misleading.  I won't ask him in #idris, because it's wrong, though he's probably right in the general case.
06:37:42 <ReinH> rohan: you might look at _Algorithms: A Functional Programming Approach_
06:37:53 * hackagebot libjenkins 0.8.2 - Jenkins API interface  https://hackage.haskell.org/package/libjenkins-0.8.2 (MatveyAksenov)
06:37:59 <ReinH> there's a small example at https://wiki.haskell.org/Dynamic_programming_example
06:38:10 <hodapp> arahael: Re: NumPy & SciPy: They incidentally add more speed, but they also provide sensible operations on arrays and quite a lot of library functions that I really don't feel like implementing myself.
06:38:21 <aweinstock> :t Data.Vector.generate
06:38:23 <lambdabot> Int -> (Int -> a) -> Data.Vector.Vector a
06:38:51 <hodapp> arahael: and matplotlib is that, times a thousand, because I really don't have enough hours in the day to make my own plotting library.
06:38:52 <ReinH> oh, Tikhon has a nice thing too http://jelv.is/blog/Lazy-Dynamic-Programming/
06:38:59 <aweinstock> rohan: it's possible to use Data.Vector.generate combined with lazy evaluation to write DP algorithms
06:39:13 <arahael> hodapp: Agreed regarding matplotlib.
06:39:44 <hodapp> but, the only reason I'm using these tools is because I know them from past experiences, and haven't really looked for Haskell equivalents.
06:39:49 <rohan> i have looked at https://wiki.haskell.org/Dynamic_programming_example ... Its good .. But i wanted a list based approach
06:39:57 <hodapp> also, because MATLAB sucks. But I digress.
06:40:05 <Intolerable> matlab is horrifying
06:40:06 <merijn> rohan: List based approach makes no sense
06:40:08 <rohan> apart from this , has anyone tried web scraping in haskell
06:40:12 <merijn> rohan: The indexing would ruin any speed
06:40:13 <ReinH> rohan: why would you want that?
06:40:13 <aweinstock> > let allFibsTo n = let vec = Data.Vector.generate n (\i -> if i < 2 then 1 else vec!(i-1) + vec!(i-2)) in vec
06:40:15 <lambdabot>  <no location info>:
06:40:15 <lambdabot>      not an expression: ‘let allFibsTo n = let vec = Data.Vector.generate n (...
06:40:25 <merijn> rohan: Yes: https://gist.github.com/merijn/d8188ddd129718ffcfb0
06:40:30 <aweinstock> @let allFibsTo n = let vec = Data.Vector.generate n (\i -> if i < 2 then 1 else vec!(i-1) + vec!(i-2)) in vec
06:40:32 <lambdabot>  .L.hs:150:13: Not in scope: ‘Data.Vector.generate’
06:40:42 <quchen2> ?quote Jafet police
06:40:43 <lambdabot> Jafet says: [on memoising an O(n) algorithm:] This is like trying to save work in a police investigation by having each detective determine whether another detective has already removed all evidence from his area by walking through it to search for evidence in the area.
06:41:01 <ReinH> There are often other approaches that can be used besides dynamic programming
06:41:10 <lunaris> Anyone here particularly familiar with the monad-classes library?
06:41:13 <jmcarthur> merijn: not necessarily. for example, the zipWith implementation of fib is basically dynamic programming, but it kind of does all the indexing in one pass so it's still efficient even though it uses lists.
06:41:30 <merijn> jmcarthur: Because fibonacci only looks at two elements of the list...
06:41:41 <merijn> jmcarthur: Most dynamic programming algorithms index pretty randomly
06:41:49 <jmcarthur> right. lists are not good as a general dynamic programming tool
06:42:01 <jmcarthur> but for many specific cases they are fine
06:42:17 <jmcarthur> though i think maybe for all such specific cases you can easily solve it without dynamic programming
06:42:54 <Intolerable> last time i went to do web scraping in haskell
06:43:02 <Intolerable> i abandoned it and used nokogiri
06:43:04 <rohan> merjin: i disagree ... direct mutation aside , almost all dp algo use related variables...case in point : dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
06:43:19 <hodapp> someone mentioned Frames to me for the actual data reading, but I still would likely need a plotting library, hmmm
06:43:29 <merijn> rohan: That's still going to index pretty shittily over lists
06:43:38 <merijn> rohan: Keep in mind that list indexing is O(n)
06:43:39 <ReinH> I like Bird's http://www.cs.ox.ac.uk/richard.bird/online/BirdDeMoor93From.pdf as well
06:43:51 <merijn> rohan: Fibonacci gets away with it by only needing the last two adjacent elements
06:44:11 <aweinstock> rohan: does the Data.Vector.generate approach I showed work for what you had in mind?
06:44:12 <rohan> not necessarily ....n :: [Int] -> [Int]
06:44:12 <rohan>   2 fn l = 1 : go l (tail l)
06:44:12 <rohan>   3  where go _ [] = [1]
06:44:12 <rohan>   4        go (x:xs) (y:ys) = x+y `seq` x+y: go xs ys
06:44:12 <rohan>   5 
06:44:12 <rohan>   6 c :: Int -> Int -> Int
06:44:13 <rohan>   7 c n k
06:44:13 <rohan>   8  |n==0 = 1
06:44:14 <rohan>   9  |k==n = 1
06:44:14 <rohan>  10  |n==1 = 1
06:44:15 <rohan>  11  |otherwise = (iterate' fn [1,2,1])!!(n-2)!!(k)
06:44:15 <rohan>  12                     where iterate' f a = a `seq` a : iterate' f (f a)
06:44:16 <rohan>  13 
06:44:16 <rohan>  14 main :: IO ()
06:44:18 <jmcarthur> woah, no
06:44:27 <ReinH> rohan: don't paste into channel
06:44:28 <aweinstock> rohan: use lpaste.net for code samples
06:44:38 <merijn> rohan: Your seq is useless
06:44:51 <merijn> And yes, use a paste site...
06:44:55 <rohan> which one ?
06:44:58 <exio4> the first one
06:45:02 <quchen2> a `seq` a === a
06:45:05 <merijn> rohan: "go (x:xs) (y:ys) = x+y `seq` x+y: go xs ys" <-
06:45:07 <aweinstock> does `seq` have lower precedence than (:)?
06:45:14 <merijn> aweinstock: Irrelevant
06:45:15 <rohan> i know !! -_-
06:45:32 <merijn> x+y and x+y are unrelated expressions that don't share any data
06:45:34 <rohan> it was a move of desperation ... the second one is relevant thogh
06:45:44 <exio4> if you _want_ that, let r = x + y in r `seq` r : go xs ys
06:46:00 <merijn> rohan: !!(n-2)!!(k) <- this is terrible
06:46:03 <exio4> merijn: well, maybe that seq makes sure you evaluate x and y as (+) is strict
06:46:04 <quchen2> merijn: x+y isn't forced because of the (lack of) parentheses :-þ
06:46:09 <quchen2> It's y `seq` x there
06:46:15 <quchen2> Or not
06:46:28 <quchen2> Does seq have its own fixity? I hate fixities.
06:46:30 <jmcarthur> i like that the list indexing operator looks so shocked all the time.
06:46:31 <merijn> exio4: That makes no sense
06:46:45 <rohan> quchen2: THANK U
06:46:56 <exio4> merijn: why wouldn't it? :P 
06:47:29 <merijn> exio4: If we assume it parses like "(x+y) `seq` ((x+y): go xs ys)"
06:47:36 <exio4> yes
06:47:43 <merijn> exio4: It's going to evaluate "x+y" and then append an unevaluated "x+y" thunk to the list
06:47:56 <exio4> yup, I am talking about x and y themselves
06:48:00 <merijn> exio4: Because those are not the same thunk
06:48:20 <merijn> exio4: "+ is strict" means that forcing "x+y" will force both 'x' and 'y'
06:48:32 <merijn> exio4: There is no magic forcing plus to be evaluated
06:49:09 <exio4> in the expression ((x+y) `seq` X) I would expect x and y to end in WHNF 
06:49:30 <exio4> as getting the WHNF of the first value means you had to force both x and y to get a result you're then ignoring
06:49:47 <rohan> nope ... paranthesis made no difference
06:50:21 <merijn> rohan: None of these little strictness changes will remove the suck of using list here
06:50:59 <ReinH> exio4: forcing x+y doesn't force the second x+y. forcing y doesn't force the second x+y.
06:51:19 <hodapp> mleh, maybe I'll just keep using NumPy/SciPy at $job because I also have to use it for the computer vision class I'm in
06:51:20 <exio4> ReinH: I know, I am talking about `x` and `y` by themselves 
06:51:24 <hodapp> I have many other things to use Haskell for
06:51:30 <ReinH> nothing is forcing x
06:51:43 <rohan> merijin: how r lists causing the problem?
06:51:52 <ReinH> and unless `seq` has a special fixity, nothing is forcing y either
06:52:00 <quchen2> ReinH: infixr 0
06:52:00 <merijn> rohan: O(n) indexing combined with a double indexing on every iteration...
06:52:03 <merijn> rohan: I just said that
06:52:18 <ReinH> rohan: (!!)
06:52:25 <merijn> rohan: "!!(n-2)!!(k)" <- this alone makes your code n^2
06:52:26 <ReinH> always causes problems
06:52:49 <rohan> merijin: how come?
06:52:54 <ReinH> :info (+)
06:52:58 <ReinH> @info (+)
06:52:59 <lambdabot> (+)
06:53:00 <rohan> its called just once!
06:53:00 <quchen2> (!!) is quadratic.
06:53:02 <ReinH> Thanks lambdabot
06:53:10 <Intolerable> its so helpful
06:53:14 <rohan> but i am not using !! to index!
06:53:25 <ReinH> rohan: well, !! indexes, so...
06:53:27 <quchen2> Eh, (!!) in that code is quadratic since it's used twice.
06:53:31 <merijn> ReinH: There is no :info
06:53:38 <ReinH> merijn: I see that.
06:53:41 <merijn> Oh, he means !! is only at the end, I guess
06:53:58 <rohan> merijin: YES
06:54:11 <exio4> > last $ (\x y -> (x + y) `seq` ((x+y) : [0])) undefined undefined
06:54:13 <lambdabot>  *Exception: Prelude.undefined
06:54:24 <quchen2> It still requires ~k*n steps to do the double indexing.
06:54:39 <poincare101> Hi. Quick question: How do I take a look at what exported functions/type constructors exist in a module?
06:54:47 <quchen2> poincare101: :browse
06:55:32 <rohan> consider ...  fib n = fibs!!n where fibs = 0:1:zipwith blah blah ... would you call this approach inefficient?
06:56:00 <quchen2> fibonacci can't be implemented faster than linearly so it's asymptotically optimal that way.
06:56:10 <knupfer> how can i see a list of programms run on a specific virtual desktop in xmonad?
06:56:12 <quchen2> Binomial coefficients can be implemented faster than n*k.
06:56:38 <rohan> i dont want to ! currently i WANT to use a algorithm of complexity O(n*k)
06:56:39 <exio4> quchen2: wait, what about the O(logn) approach using matrices? :p 
06:56:46 <rohan> That being said is my code correct?
06:57:04 <quchen2> exio4: Your result still grows exponentially, so the number of bits to store it grows linearly.
06:57:36 <aweinstock> rohan: try blindly replacing [] with Data.Vector (or Data.Vector.Unboxed), and (!!) with (!), and see if that improves things
06:57:46 <quchen2> exio4: You're right that you need only log(n) arithmetic operations to get to that result though.
06:57:54 * hackagebot reverse-geocoding 0.2.2 - Simple reverse geocoding using OpenStreeMap  https://hackage.haskell.org/package/reverse-geocoding-0.2.2 (jcristovao)
06:57:58 <rohan> aweinstock:will do that
06:58:03 <ReinH> quchen2: fib(n) = floor(phi^n / sqrt(5) + 1/2)
06:58:16 <quchen2> ReinH: fib(n) = 1 -- even faster, and just as correct
06:58:16 * ReinH ducks
06:59:28 <rohan> if the vector version is indeed fast then does that imply that even sequential access of vectors is faster than that of lists ?
06:59:58 <rohan> bcz in my code there is NO random access on lists
07:00:15 <ReinH> quchen2: assuming infinite precision.... in which case it's O(n) again...
07:00:34 <ReinH> rohan: !! is random access of lists
07:00:46 <ReinH> the fact that you know the index beforehand doesn't make it non-random access
07:01:04 <ReinH> !! is linear for lists, sublinear for vectors.
07:01:13 <ReinH> that's really all there is to it
07:01:33 <poincare101> Another quick question: How do I access a type constructor from a different package? I can see the constructor as one of the module's exported components but I am getting a "not in scope" error when I try to access it.
07:01:39 <rohan> yes !! for random access but its called just once ..
07:01:48 <ReinH> yes, which is more than zero
07:01:49 <knupfer> how about queues? Is Data.Sequence the fastest way to go?
07:01:55 <knupfer> (fifo)
07:02:18 <rohan> its called just to get the answer. .. There's no iteration involving random access...
07:02:33 <rohan> okay lemme ask this ... what is the complexity of my code ?
07:03:04 <Intolerable> knupfer: okasaki's lazy queue are what you want
07:03:11 <Intolerable> but i'm not sure where you will find them
07:04:43 <jmcarthur> Data.Sequence makes for a pretty fast queue, though
07:04:50 <Intolerable> ure
07:04:51 <Intolerable> *sure
07:05:02 <quchen2> rohan: At least k*n.
07:05:10 <ReinH> Intolerable: well, it's just two lists, it's pretty easy to write
07:05:13 <jmcarthur> even relative to most of the queues in PFDS
07:05:26 <quchen2> Because of the random access, as was mentioned sufficiently enough. ಠ_ಠ
07:05:26 <poincare101> anyone for my question?
07:05:32 <Intolerable> ReinH: oh, definitely, but surely it must be somewhere
07:05:36 <jmcarthur> Intolerable: which of okasaki's queues are you recommending?
07:05:43 <ReinH> Intolerable: you'd think
07:05:52 <quchen2> poincare101: You access it like you access anything else from another module, there's nothing special to doing that
07:05:53 <Intolerable> the two lists, flip when empty
07:05:57 <Intolerable> reverse rather
07:05:57 <liste> poincare101 how do you import it?
07:05:59 <knupfer> Intolerable: ok, i thought that they are complexity wise the same as osakis
07:06:06 <ReinH> jmcarthur: data Queue a = Queue { enqueue :: [a], dequeue :: [a] }
07:06:08 <poincare101> liste: import Data.DCFL
07:06:28 <poincare101> quchen2: That's what I thought but i keep getting a not in scope error
07:06:30 <jmcarthur> ReinH: but Intolerable mentioned laziness, which that particular queue does not really rely on
07:06:33 <ben> which is considered more fundamental, bang patterns or seq?
07:06:40 <ReinH> jmcarthur: *shrug*
07:06:40 <jmcarthur> also that one is not very good when used persistently
07:06:44 <liste> @paste -- poincare101 use this
07:06:44 <lambdabot> Haskell pastebin: http://lpaste.net/
07:07:26 <ReinH> poincare101: either a typo or a mistake in reading the export list?
07:07:53 <jmcarthur> i strongly recommend Data.Sequence for general purpose queues, because it plays nicely with persistence and is still really fast. it's a very good balance.
07:08:01 <Intolerable> tbh last time i used queues i used Seq
07:08:10 <ReinH> jmcarthur: true enough irt persistence
07:08:31 <poincare101> ReinH: liste I get this by checking ":browse" in ghci: http://lpaste.net/139355
07:08:35 <jmcarthur> there are faster ones, even persistent ones, but there are a lot of tradeoffs
07:08:41 <Arjuna144> If I dislike writing "then" and "else", what disadvantages do I have if I use "myIf t a b = if t then a else b" instaed of the normal if?
07:08:46 <Intolerable> 90% of the time though, when i need a queue i use TQueue or similar
07:08:51 <merijn> Arjuna144: Not much
07:08:51 <ReinH> jmcarthur: iirc laziness and memoization were added to give better persistent behavior, which may be what Intolerable was referring to
07:09:06 <merijn> Arjuna144: FYI, in recent (7.8 or 7.10?) versions of GHC you have "bool"
07:09:12 <liste> poincare101 what's the code that produces the error?
07:09:15 <merijn> Arjuna144: Although bool is slight different from myIf
07:09:17 <merijn> :t bool
07:09:17 <jmcarthur> ReinH: to the two-list queue? there's the banker's queue variant that uses laziness, sure, but its performance is really bad
07:09:18 <lambdabot> a -> a -> Bool -> a
07:09:29 <jmcarthur> ReinH: relative to Data.Sequence, at least
07:09:38 <merijn> Arjuna144: bool is "boolean elimination" so it's False first, True second
07:09:45 <merijn> > bool 'a' 'c' True
07:09:47 <lambdabot>  'c'
07:09:53 <int-e> Arjuna144: you need more parentheses and get fewer visual cues how far the three arguments extend. there's also some relaxed indentation for if/then/else that you'll lose.
07:10:07 <ReinH> banker's queues are implemented in Data.Dequeue, fwiw
07:10:12 <Arjuna144> merijn: Thank you for that cool explainantion
07:10:13 <int-e> (I like the dedicated if-then-else syntax)
07:10:23 <poincare101> liste: http://lpaste.net/139357
07:10:33 <poincare101> liste: that produces the error: Not in scope: data constructor ‘Variable’
07:10:43 <merijn> Arjuna144: I mean, realistically if/then/else is just syntactic sugar for "case b of True -> x; False -> y"
07:10:50 <jmcarthur> i think "really bad" was overstating on my part, but it's not the implementation i would recommend for any reason other than simplicity
07:10:57 <Arjuna144> merijn: okay
07:11:10 <Intolerable> tl;dr: just use Seq?
07:11:11 <merijn> Arjuna144: So besides readability it doesn't do anything special
07:11:18 <ReinH> poincare101: well, we can't see your imports
07:11:25 <jmcarthur> yeah, Seq is love
07:11:37 <poincare101> ReinH: I've just done an "import Data.DCFL" statement
07:11:39 <ReinH> jmcarthur: Seq is life
07:11:48 <Intolerable> heh
07:12:26 <ReinH> poincare101: where?
07:12:37 <poincare101> ReinH: ghci, before I plug in that statement
07:12:54 <jmcarthur> if i recall correctly, queue operations with Data.Sequence are in the low tens of nanoseconds range
07:13:24 <jmcarthur> but i could in fact be recalling quite incorrectly...
07:13:40 <liste> poincare101 what does Data.DCFL.Variable [0..4] 0 (initDistribution 4) show?
07:13:59 <poincare101> liste: Not in scope: data constructor ‘Data.DCFL.Variable’
07:14:18 <ReinH> jmcarthur: that sounds believable
07:16:41 <liste> then I have no idea
07:18:29 <ReinH> poincare101: can you pastie a complete, minimal ghci session that exhibits the problem?
07:19:34 <poincare101> ReinH: http://lpaste.net/139360
07:19:42 <poincare101> ReinH: Would it help to look at the Data.DCFL source? it is on hackage
07:21:49 <ReinH> Welp.
07:22:04 <liste> GHCi doesn't seem to load the DCFL package, is that normal?
07:22:17 <ReinH> it's listed in the imports
07:22:21 <ReinH> I don't get it
07:22:34 <liste> imports of what?
07:22:43 <ReinH> "Prelude Data.DCFL>"
07:22:55 * hackagebot reverse-geocoding 0.2.2.1 - Simple reverse geocoding using OpenStreeMap  https://hackage.haskell.org/package/reverse-geocoding-0.2.2.1 (jcristovao)
07:22:58 <lwander> join #golang
07:22:58 <liste> is there a Data/D
07:23:09 <liste> Data/DCFL.hs around?
07:23:34 <ReinH> And does it, in fact, export the Variable constructor?
07:23:36 <Intolerable> lwander: dont do it!
07:23:48 <liste> we've lost lwander...
07:24:01 <ReinH> No. No it does not.
07:24:13 <ReinH> It exports the type constuctor only.
07:24:17 <ReinH> http://hackage.haskell.org/package/DCFL-0.1.6.0/docs/src/Data-DCFL.html
07:24:29 <liste> yeah
07:24:29 <Ankhers> I feel like it was less of a loss, and more trying to promote #golang.
07:24:45 <liste> they have no power over us
07:24:46 <Ankhers> Also, I don't think that is the official go channel.
07:25:11 <ReinH> It's #go-nuts
07:25:21 <Intolerable> :t [1,2,3]
07:25:27 <Intolerable> interface{}
07:25:40 <ReinH> :D
07:25:45 <ReinH> poincare101: well, there's your problem
07:26:12 <Ankhers> Intolerable: using interface{} is going against community guidelines.
07:26:20 <poincare101> ReinH: How would I export the type constructor as well?
07:26:25 <fosterite> :Intolerable typeof is `const "interface{}"`
07:26:41 <poincare101> ReinH: I actually wrote the DCFL library as a learning exercise
07:27:01 <liste> poincare export them as Variable(..)
07:27:17 <liste> the constructor are in the parens
07:27:21 <ReinH> Variable(Variable) or Variable(..)
07:27:22 <liste> .. means "all of them"
07:27:31 <Profpatsch> Is there a difference between data D = D Inner; data Inner = Inner Some Types  and  D = D Some Types ?
07:27:44 <ReinH> Profpatsch: well, yes
07:27:56 <poincare101> liste: ahh I didn't know that
07:27:57 <Profpatsch> I mean, of course you have to wrap and the constructor D takes a different amount of arguments.
07:28:25 <Intolerable> if u use newtype on the first they will have the same representation ?
07:28:28 <Profpatsch> But mathematically they are isomorphic, right?
07:28:35 <liste> Profpatch the first one has D Inner _|_ _|_ and D _|_
07:28:35 <Intolerable> yes
07:28:37 <ReinH> Profpatsch: Why would you think they wouldn't be different, and what did you mean by the third one which is invalid syntax?
07:28:52 <Profpatsch> Third one is missing data.
07:28:59 <ReinH> Profpatsch: no, they contain a different number of inhabitants because of bottom
07:29:31 <Profpatsch> Apart from bottom they are isomorphic?
07:29:51 <ReinH> yes, the first D is Identity
07:30:11 <ReinH> (a monomorphic version)
07:32:10 <Profpatsch> Maybe I need to ask about my real problem.
07:32:36 <merijn> Profpatsch: They're isomorphic, yes
07:33:08 <merijn> Well, modulo bottom, maybe
07:33:15 <merijn> I'm lazy and it's friday, thinking is hard
07:33:31 <Profpatsch> I have a (mathematical) tuple ( P_x(Data), B_x )
07:34:02 <Profpatsch> Where P_x(Data) is the data signed with the private key of x
07:34:11 <Profpatsch> And B_x is the public key of x
07:34:38 <Profpatsch> I’m not sure how to encode that in a sensible data type.
07:35:13 <ReinH> merijn: thank you for joining us ;)
07:35:55 <ReinH> Profpatsch: As an aside, I'd consider includin a phantom for Data.
07:36:05 <ReinH> s/in/ing
07:36:12 <ReinH> well, that didn't quite hit the mark
07:36:47 <ReinH> extra type safety is usually worthwhile when dealing with crypto
07:36:49 <jmcarthur> Profpatsch: newtype D = D Inner; data Inner = Inner Some Types  and  D = D Some Types  are isomorphic even considering bottom
07:37:03 <Profpatsch> ReinH: nah, my first question was more of a question on the side.
07:37:35 <ReinH> jmcarthur: despite their differing number of inhabitants?
07:38:05 <jmcarthur> ReinH: they don't have differing numbers of inhabitants. did you miss that i used newtype?
07:38:15 <ReinH>  jmcarthur yes I did. :D
07:38:20 <ReinH> thanks
07:38:35 <ReinH> jmcarthur: I'm lazy and it's friday, etc
07:38:49 <jmcarthur> i'm taking a staycation today, which is awesome
07:39:00 <ReinH> jmcarthur: yaaaaay
07:39:16 <ReinH> jmcarthur: I didn't get any sleep and it's 7:40am now so I'm considering taking a day as well...
07:41:24 <kuribas> Are there negative consequences to changing $ with $! in nonlazy code?
07:44:21 <Profpatsch> Regarding my public/private key problem above, does it make sense to state on the type level that the key the data was signed with belongs to the public key in the tuple?
07:44:40 <Profpatsch> It probably does, but how would I do that?
07:45:12 <Profpatsch> Something like ( Pubkey a Data, Privkey a ) ?
07:48:53 <Profpatsch> Or I’m confusing implementation with representation and it should simply be Mytype Signer Data
07:50:09 <liste> is your data some concrete type?
07:51:12 <Profpatsch> liste: Yes, it’s some values.
07:52:02 <liste> then I suppose data MyType = MyType Signer Data would be simplest
07:52:35 <pine1234> I don't suppose anyone knows of a guide to haskell for someone coming from a category theory background?
07:53:55 <ReinH> pine1234: Richard Bird's Thinking Functionally with Haskell may approach thata bit
07:54:25 <ReinH> or his Algebra of Programming, although it uses a rather odd, archaic dialect of Haskell, is mostly about category theory
07:54:56 <pine1234> thanks I'll have a look
07:57:02 <pine1234> corr yes, some things I recognise!
07:58:49 <ReinH> pine1234: although, once you recognize the ambient category of types and functions, a lot of the rest is pretty... obvious.
07:58:56 <Profpatsch> merijn: Does that mean any type of kind * -> * -> ... -> * can be split into “smaller” subtypes of * -> * that form an isomorphic type?
07:59:05 <ReinH> up to bottoms you have a CCC, so basically everything is easy
07:59:12 <Profpatsch> I suspect because of * -> ( * -> * ) ?
08:00:18 <Profpatsch> That question was extremely unprecise, but out of the context from before.
08:01:03 <ReinH> pine1234: Functors are (endo)functors, applicatives are strict closed (endo)functors, monads are monads, etc
08:02:18 <ReinH> er, lax closed functors
08:02:20 <pine1234> ReinH: thanks I'm just getting started with Haskell really but it seems a lot more 'maths friendly' than many other languages .. at least in a semi obvious way
08:02:32 <ReinH> :t (<*>)
08:02:34 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
08:02:46 <ReinH> pine1234: Applicative is a theorem that f preserves internal homs
08:03:08 <ReinH> rather, <*> is
08:03:12 <pine1234> I was hoping my knowledge of category theory might save me some time but I suspect no such luck ha
08:03:28 <ReinH> pine1234: oh it might
08:03:33 <ReinH> things fall pretty nicely into place
08:03:42 <ReinH> although it won't help as much with, e.g., laziness
08:04:11 <pine1234> just general laziness you mean?!
08:04:38 <ReinH> lazy evaluation
08:05:03 <pine1234> yeah, it's definitely different to python which is what i'm used to
08:05:15 <ReinH> I'm sure there's a way to apply category theory to graph reduction though
08:05:57 <ReinH> of course http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.414.3347
08:06:02 <pine1234> there's almost always a way to apply cat theory to everything, it's just a question of whether[#haskell] 
08:06:10 <pine1234> or not you gain anything in doing so
08:06:27 <ReinH> well, someone thought there was ;)
08:06:29 <kuribas> Can I just replace each $ with $! in nonlazy code?
08:06:55 <pine1234> oh yeah nice
08:07:15 <hodapp> oh, good, magistr appears to be gone from every channel he was haunting
08:07:24 <ReinH> hodapp: ?
08:07:50 <hodapp> ReinH: the guy who kept popping up and uttering non-sequiturs all day long about how much math you had to know to be able to use functional programming
08:07:56 <ReinH> kuribas: well, they are equivalent in a strict language since, you know, everything is strict already
08:08:10 <ReinH> hodapp: ah right, good
08:09:01 <kuribas> ReinH: Well, with nonlazy I mean haskell code which isn't meant to be lazy.
08:09:10 <ReinH> pine1234: I like this citation, "Forbidden minors characterization of partial 3-trees"... Reading this paper feels so... danagerous...
08:09:46 <pine1234> haha
08:10:19 <ReinH> tell me your forbidden secrets of partial 3-trees
08:14:22 <Profpatsch> ReinH: Since you did a paper search: any recommendations on the best paper search engines? I only know Google Scholar, a few more (good ones) would be handy.
08:14:37 <ReinH> Profpatsch: I just use google scholar
08:14:49 <Profpatsch> ok.
08:15:24 <Profpatsch> I tried to copy a bibtex reference from there recently and it was seriously crippled.
08:16:48 <ReinH> hmm, I haven't had an issue with their bibtex export
08:16:53 <ReinH> oh wait, that was google books
08:17:02 <ReinH> never mind
08:17:58 * hackagebot multihash 0.1.2 - Multihash library and CLI executable  https://hackage.haskell.org/package/multihash-0.1.2 (LukeHoersten)
08:18:00 * hackagebot acid-state-dist 0.1.0.0 - Replication backend for acid-state  https://hackage.haskell.org/package/acid-state-dist-0.1.0.0 (maxvoit)
08:19:18 <sdx23> hackagebot: oh, thanks :)
08:19:49 <sdx23> Am I correct to build documentation myself and upload it then?
08:21:27 <Intolerable> or you can wait for the hackage builder
08:21:48 <Intolerable> usually takes a little while
08:21:56 <sdx23> Ah, so it does work again? I googled shortly and wasn't sure. Thank you
08:22:08 <Intolerable> yeah it does
08:22:11 <Intolerable> @hackage reddit
08:22:11 <lambdabot> http://hackage.haskell.org/package/reddit
08:22:18 <Intolerable> uploaded this this afternoon, has docs
08:25:56 <lunaris> Orphan instances: always a bad thing? Seems to me that in a situation where you have some "API" package that exports a class, it's sensible to define an instance in another package that gets pulled in at the "dependency wiring" bit of the program, no?
08:26:20 <lunaris> TL;DR: am I a sinner for wanting to deploy -no-warn-orphans?
08:26:58 <sdx23> Intolerable: did you do something special to keep the readme-file or is it just the filename being case-sensitive?
08:27:12 <Intolerable> not sure
08:27:14 <Intolerable> what's yours called?
08:27:17 <Intolerable> readme.md?
08:27:20 <sdx23> yes
08:27:25 <Intolerable> try README.md
08:27:33 <Intolerable> oh wait
08:27:42 <larryba> hello
08:27:56 <Intolerable> make sure it's in extra-source-files in your .cabal file
08:27:58 * hackagebot transient 0.1.0.0 - A monad for extensible effects and primitives for unrestricted composability of applications  https://hackage.haskell.org/package/transient-0.1.0.0 (AlbertoCorona)
08:28:06 <larryba> what package/function should I use to find the creation date of a directory?
08:28:07 <Intolerable> otherwise it doesn't get packed into the tar.gz
08:29:00 <bennofs> larryba: http://hackage.haskell.org/package/directory-1.2.3.1/docs/System-Directory.html I think
08:29:00 <sdx23> Intolerable: ah, that must be it; examples are gone also, should fix that too
08:29:28 <bennofs> larryba: ah, there is no creation time, only modification and access time :/
08:29:36 <larryba> hmm :(
08:29:59 <Intolerable> if you aren't already, you should take a look at the neil tool
08:30:01 <Intolerable> https://github.com/ndmitchell/neil
08:30:20 <Intolerable> neil check is handy for "i'm about to push to hackage but probably forgot something"
08:30:38 <bennofs> larryba: http://unix.stackexchange.com/questions/24441/get-file-created-creation-time seems this isn't even possible on linux
08:31:32 <sdx23> Intolerable: I used that "upload package candidate" thing, but obviously didn't look closely enough
08:32:12 <larryba> bennofs I never knew that
08:34:12 <cjay> hmm I feel quite dumb when trying to use stack
08:34:51 <cjay> do I need to specify each dependency twice, once in the cabal file an once in stack.yaml?
08:35:17 <cjay> and all recursive dependencies of the dependency in stack.yaml too?
08:35:52 <lunaris> cjay: If you're using a Stackage snapshot, no.
08:36:09 <lunaris> cjay: You'll only specify a Stackage version (which specifies a subset of Hackage packages at specific versions).
08:36:16 <lunaris> cjay: (in your stack.yaml)
08:36:31 <lunaris> cjay: Then, in your .cabal file(s), you'll specify the individual dependencies as you're used to.
08:36:42 <lunaris> Open question for stack users though: do you specify versions in your .cabal files?
08:36:47 <lunaris> Or do you rely on Stackage pinning?
08:36:56 <lunaris> (Assuming use of a Stackage resolver)
08:37:25 <cjay> ok it looks like I tried to use a package that is not in the stackage version
08:37:27 <Ankhers> Specifying versions I think is still considered best practice. If for no other reason than not everyone is using stack.
08:37:29 <bennofs> lunaris: for anything that you plan to publish, you should add proper version bounds to your package
08:37:32 <stk944> Hello, Can anyone tell me what the $$$ do https://github.com/AccelerateHS/accelerate/blob/21fdcee2417ade870eff7307fa20e6aa06ee6bcc/Data/Array/Accelerate/Language.hs#L271, the other Fold is https://github.com/AccelerateHS/accelerate/blob/4d0754d22a5662703e4ad4c262ec9d9a1edc06a0/Data/Array/Accelerate/AST.hs#L339
08:38:00 <lunaris> bennofs: That was my thinking. Though it's likely the things in question will be privately published at most.
08:38:02 <dramforever> @hoogle $$$ +AccelerateHS
08:38:03 <lambdabot> No results found
08:38:08 <Profpatsch> cjay: lunaris Use nix. :)
08:38:10 <dramforever> @hayoo $$$
08:38:10 <lambdabot> Unknown command, try @list
08:38:14 <dramforever> failed...
08:38:31 <lunaris> Any thoughts on my question regarding orphan instances BTW?
08:38:47 <ReinH> lunaris: the whole point is to  not specify versions in the cabal file and use stackage
08:38:56 <bennofs> ReinH: not for libraries
08:39:03 <bennofs> ReinH: or anything that you publish to hackage
08:39:11 <ReinH> bennofs: true enough
08:39:24 <lunaris> Scenario: `component-api` exports some types and classes; `postgresql` exports classes for working with PG; `component-postgresql` implements the PG classes to provide an implementation of `component-api`.
08:39:31 <ReinH> I should have said for applications
08:39:40 <lunaris> `component-postgresql` therefore has orphan instances and fails `-Wall -Werror`.
08:39:47 <bennofs> ReinH: you can also publish applications on hackage... :p
08:39:50 <lunaris> Terrible thing?
08:40:05 <ReinH> bennofs: fine
08:40:15 <lunaris> ReinH: Suppose you're building a set of private libraries that are incorporated into an application -- omit then?
08:40:19 <broma0> Is there a standard pattern for handling exceptions in a non terminating application? Control.Exception? Control.Monad.Except?
08:40:28 <lunaris> Because I suppose they might be pushed to a private Hackage at some point.
08:40:29 <lunaris> Or similar.
08:40:54 <lunaris> broma0: Control.Concurrent.Async has asynchronous exception handling, if that's what you mean?
08:41:16 <lunaris> broma0: Alternatively, you could write your own version of `forever`, if that fits your pattern?
08:41:18 <bennofs> lunaris: if you're only using it yourself, you can do that, since you'll always be using stackage.
08:41:29 <lunaris> bennofs: That's my gut.
08:41:46 <lunaris> bennofs: And if anything comes to be open sourced, we can put the bounds in then (since it'll need renaming and such etc.)
08:42:09 <stk944> Is that like a triple function composition or something?
08:42:12 <ReinH> bennofs: it would make more sense if stack managed your cabal file
08:43:15 <bennofs> lunaris: personally, I don't like orphan instances at all and would try to avoid them
08:43:17 <ReinH> broma0: Except, despite its name, is not for exceptions.
08:43:21 <broma0> lunaris, that could work. Im really just looking for a talk or article on exception-proofing a haskell application. One that discusses bracket, async exceptions, the except monad. Etc
08:43:45 <lunaris> broma0: Afraid nothing immediately springs to mind on that front.
08:43:53 <ReinH> broma0: there have been some recommendations https://www.fpcomplete.com/user/commercial/content/exceptions-best-practices
08:44:01 <lunaris> Though I will say Control.Concurrent.Async takes care of a lot, given that Simon Marlow wrote it.
08:44:23 <bennofs> broma0: how about http://blog.haskell-exists.com/yuras/posts/overview-of-resource-management-in-haskell.html
08:44:24 <lunaris> bennofs: How would you solve the scenario I described? (Assuming the scenario itself isn't completely broken)
08:44:32 <ReinH> MonadThrow/MonadCatch are pretty useful
08:44:53 <bennofs> lunaris: I'd just have one of the libraries depend on the other
08:45:16 <lunaris> bennofs: But if you have a general-purpose library for interfacing with your database.
08:45:18 <cjay> Profpatsch: Maybe I should. IMHO stack raises the bar a lot for newbies that just want to play around with some packages from Hackage. There seems to be no easy replacement for "cabal update; cabal install …".
08:45:22 <lunaris> And some service with an API.
08:45:34 <ReinH> bennofs: with the caveat that ResourceT is broken
08:45:39 <lunaris> You don't want people pulling in the API having to pull in a load of database packages.
08:45:40 <bennofs> ReinH: what?
08:45:43 <bennofs> ReinH: how?
08:46:25 <lunaris> People should be able to program to an API and then, when the application is built, the instances pulled in separately and composed at that point.
08:47:14 <bennofs> lunaris: oh hmm. I don't think orphan instances are too bad in applications, but in libraries, you really can't use orphans
08:47:32 <lunaris> Well, they are libraries.
08:47:38 <ReinH> bennofs: iirc it violates the monad transformer laws and it can leak resources, but I can't find a writeup
08:47:39 <lunaris> But the idea is that they'll be composed into applications.
08:47:46 <lunaris> But all libraries are...
08:47:48 <Ankhers> cjay: `cabal update; cabal install ...` is replaced by `stack install ...`
08:47:49 <lunaris> Bad example.
08:48:28 <cjay> Ankhers: oh. the help text only mentions that it's for executables.
08:48:29 <bennofs> ReinH: You're not referring to the fact that you of course shouldn't use resourcet with monad-control, are you?
08:48:55 <Ankhers> cjay: stack will also download GHC for you if it is not already on your system.
08:49:09 <Ankhers> cjay: It will also manage multiple GHC versions for you.
08:49:17 <lunaris> bennofs: As someone who has just integrated monad-control into his code, what should I avoid in relation to ResourceT?
08:50:11 <Ankhers> cjay: e.g., lts-3.0 uses ghc-7.10.2, but lts-2.x uses ghc-7.8.4. I could be wrong on the actual GHC versions, but stack will use the correct version for that snapshot.
08:51:06 <Ankhers> cjay: stack also automatically sandboxes things for you because it works on the snapshot of stackage where everything is known to work well together. No need to rebuild your sandbox because something got messed up.
08:51:36 <bennofs> lunaris: hmm, can't find it anymore. perhaps I was mixing things up there 
08:51:39 <Ankhers> And, as I've done a couple times, accidentally forget to initialize your sandbox.
08:53:00 * hackagebot acid-state-dist 0.1.0.1 - A replication backend for acid-state  https://hackage.haskell.org/package/acid-state-dist-0.1.0.1 (maxvoit)
08:53:28 <cjay> Ankhers: yeah it sounds very useful, but it seems it really needs docs that tell people that just want to play around what to do
08:54:52 <larryba> ext4 stores creation time. getCreationTime ::  FilePath -> IO (Maybe UTCTime) would have been nice
08:55:13 <stk944> might have tracked it down somewhat, now I'm wondering what this syntax for newtype does https://github.com/AccelerateHS/accelerate/blob/21fdcee2417ade870eff7307fa20e6aa06ee6bcc/Data/Array/Accelerate/Smart.hs#L372? can't seem to find it in the haskell.org docs or the wiki.haskell.org docs
08:56:01 <Ankhers> cjay: Yes, the docs are still lacking a little. Though, things are slowly getting better. If you wanted to help you, you could try writing some documentation. Or even just asking for clarification helps, because someone else may be able to write / fix the documentation for it.
08:56:47 <cjay> hmm I might try when I figure enough stuff out
08:56:47 <mfng> I'm installing ghc-7.10.1 on Debian. But keep getting "Could not find module `Control.Monad.Error.Class'     Perhaps you haven't installed the "dyn" libraries for package `mtl-2.1.1'?"
08:56:58 <bennofs> stk944: what's special about that syntax? looks like a normal newtype to me
08:57:03 <Ankhers> cjay: I don't really know how active it is, but there is also #haskell-stack
08:57:28 <mfng> after typing ./bootstrap.sh
08:58:02 <cjay> Ankhers: "stack install" doesn't seem to help a lot when I want to try out some package. Looks like I still need to "stack new", and edit config files, before I can load up the package in "stack ghci".
08:58:45 <fosterite> what does `shake` do with makefiles? it tries to run them, but I tried it on one and it just failed immediately
08:58:48 <Ankhers> cjay: `stack install somePackage; stack exec ghci`
08:59:05 <stk944> bennofs, sorry I'm really bad at this, can you give me a hint as to what the parameters in the paranthesis do in this case? I've only seen things like newtype Ziplist a = Ziplist [a] and the record syntax
08:59:18 <fosterite> the manual doesn't seem to mention it
09:00:30 <bennofs> stk944: consider newtype MyMaybe a = MyMaybe (Maybe a)   you need parentheses here because you want to make a newtype over 'Maybe a', and the 'Maybe a' should be one field
09:00:37 <ReinH> stk944: perhaps you are confused because PreAcc is of kind * -> * -> * -> * -> *, so all those things inside the parens are type parameters to PreAcc
09:01:09 <bennofs> fosterite: http://neilmitchell.blogspot.de/2014/01/running-makefiles-with-shake.html ?
09:01:53 <ReinH> stk944: It's newtype Acc a = let preAcc = PreAcc Acc Seq Exp a in Acc preAcc in a language that is exactly like Haskell but with type-level let bindings
09:02:11 <ReinH> the whole thing inside the parens is a single type
09:02:23 <fosterite> bennofs: I see. thanks
09:03:06 <stk944> ReinH, thank you. Is there a ref on type-level let bindings?
09:03:27 <ReinH> stk944: They don't exist, I was just trying to illustrate what is going on
09:03:39 <broma0_> In the article by Gabriel Gonzalez "Purify Code Using Free Monads
09:03:40 <ReinH> (they could exist in some other language)
09:03:46 <stk944> ReinH, ooh I see thanks
09:03:57 <broma0_> the author says "the Free monad guarantees that you can always easily achieve the absolute maximal level of purity possible and the absolute minimal amount of impure code"
09:03:59 <ReinH> stk944: np
09:04:14 <broma0_> how does it actually "guarantee" this?
09:04:23 <cjay> Ankhers: oh, I didn't realize "stack install" works on the project instead of globally for the stackage version.
09:04:29 <broma0_> "absolute maximal/minimal" sounds a bit strong
09:04:41 <ReinH> broma0_: A free object is one for which the only structure is the structure provided by the definition of the object
09:04:59 <ReinH> broma0_: in this case, a free monad has bind and return that follow the laws and exactly nothing else
09:05:10 <ReinH> so in that sense it is minimal/maximal
09:05:17 <Zekka> ReinH: I don't really get that.
09:05:25 <broma0_> ReinH: hmm.. so all of the impure code gets stuffed into the interpreter?
09:05:27 <cjay> Ankhers: why does it even have a packagedb in $HOME/.stack?
09:05:35 <Intolerable> broma0_: yes
09:05:35 <broma0_> if, in fact, youre even using an impure interpreter
09:05:38 <Zekka> What does it mean to have exactly nothing else?
09:05:45 <ReinH> broma0_: Well, leaving aside the question of whether monads are impure (they aren't)
09:05:55 <ReinH> The free monad is just a way to encode the structure of binds and returns
09:06:00 <stk944> ReinH, how do they get away with using Acc inside the parens? Is that defining Acc in terms of itself
09:06:41 <ReinH> stk944: types can be recursive. data List a = Nil | Cons a List a
09:06:51 <Ankhers> cjay: because stack can work with different snapshots of Stackage. So each package db will be associated with a given snapshot. If you `stack new` it will generate, among other things, a stack.yml file specifying which version of Stackage to use.
09:06:54 <bennofs> ReinH: you forgot some '()'s there
09:06:59 <ReinH> Zekka: formally it has to do with adjunctions
09:07:04 <Zekka> (IIRC I've been told something to this effect: Y is a free X if you can define a function from objects of Y to objects of any other kind of X)
09:07:21 <ReinH> Zekka: prior to category theory, "free structures" were expressed algebraically in a way that was pretty unsatisfatory
09:07:33 <ReinH> bennofs: oh
09:07:33 <broma0_> The free monad / interpreter pattern seems more and more like idiomatic haskell every time i use/read about it
09:07:44 <stk944> ReinH, ohhh ok thanks again
09:07:48 <ReinH> broma0_: free objects have nice properties
09:08:08 <fosterite> is it actually possible to have a free object for every structure?
09:08:12 <broma0_> ReinH: I'm writing a simple key/value store and using a free monad to capture the query language
09:08:13 <Zekka> broma0_: I think it's extremely confusing! I used to be cool with including stuff like that in my code but I don't like writing code that people won't understand
09:08:16 <fosterite> it seems like you can't even have a free group
09:08:23 <ReinH> broma0_: seems like a pretty good use case
09:08:25 <bennofs> Zekka: a free object is a thing which basically "doesn't lose information": it doesn't merge or flatten stuff, and two expressions are only equal when required so by the law
09:08:33 <ReinH> fosterite: https://en.wikipedia.org/wiki/Free_group
09:08:51 <fosterite> ReinH: you need equality for that
09:08:55 <joco42__> i am wondering why not so many haskellers use this https://john-millikin.com/articles/ride-the-snake/
09:08:57 <joco42__> any idea?
09:09:08 <Ankhers> cjay: If you are not in a project, stack will use whichever resolver is set globally. Which can be found and changed in ~/.stack/global/stack.yaml
09:09:32 <joco42__> did anyone here tried it ?
09:09:33 <ReinH> Zekka: do you use lists?
09:09:36 <joco42__> is it any good ?
09:09:59 <Zekka> ReinH: Yeah. I know, list is supposed to be the free monoid, right?
09:10:08 <broma0_> Zekka: it was so damn confusing at first.. but honestly, the free monad / interpreter pattern was SO MUCH EASIER to get good at compared to other haskell things (which usually take a ton of work, for me at least)
09:10:10 <ReinH> Zekka: Not quite, but it's close enough for our purposes
09:10:25 <Zekka> for A is any type, list of A is a monoid that satisfies the laws and nothing else?
09:10:31 <ReinH> Zekka: The point is, lists are a pretty useful structure. They seem like the obvious such structure, especially compared to, say, foldr encoded lists.
09:10:39 <ReinH> foldr encoded lists seem ike the weird encoding
09:11:05 <Zekka> broma0_: Just remember that other people who aren't already good at it will probably have to get good at it to debug your code. (although they may be able to ignore some of it if you hide it)
09:11:05 <ReinH> It's similar with free monads
09:11:19 <ReinH> free monads are a nice general way to say "my structure has binds and returns, but I don't want to decide what those mean yet"
09:11:37 <Ankhers> joco42__: I haven't tried it, but Python is generally slower than Haskell. And if you are using it because it is a c wrapper, you may as well wrap haskell in C. There was a thread on Reddit semi-related to this recently. https://www.reddit.com/r/haskell/comments/3hogfy/haskell_usefulness_for_python_developer/
09:11:46 <Zekka> ReinH: OK, sure, I understand you
09:11:53 <ReinH> Ankhers: probaby because not so many haskellers want to call python from haskell?
09:12:28 <ReinH> Zekka: similarly, lists are a nice way of saying "I have a thing I eventually want to call foldr on". foldr is the free monoid interpreter generator. ;)
09:12:31 <Ankhers> ReinH: That too.
09:12:32 <joco42__> Ankhers: what do you mean wrap haskell in c?
09:12:37 <Zekka> Hope you guys don't take it as me saying "your work is not good" when I say people should probably avoid doing X because X is confusing
09:12:39 <geekosaur> isn't there missingpy? (may be bitrotted though)
09:12:55 <joco42__> Ankhers: this is the other way around, wrapping python into haskell.
09:13:01 <ReinH> (to the extent that lists are free monoids, which they aren't)
09:13:22 <Ankhers> joco42__: Wrap c in Haskell. If there is a C library you want to use, you can use Haskells FFI to gain access to the C library.
09:13:35 <Zekka> It's just because when I was into Haskell I wrote a whole lot of very confusing code that I now regret subjecting others to, and most of the stuff I used is perfectly mainstream from #haskell pov
09:13:38 <ReinH> Zekka: Well, you don't even need to understand free monads to *use* them.
09:13:47 <ReinH> Zekka: Just like you don't need to understand free monoids to use lists.
09:14:01 <ReinH> operational is a nice library with a nice interface that you can use without knowing what free monads are at all
09:14:03 <cjay> Ankhers: awesome, thanks. What confused me earlier: stuff that is not included in the stackage snapshot seems to get built separately for each project with "stack install", and not get shared between projects.
09:14:09 <Zekka> ReinH: I thought I'd made it clear that I knew that in principle
09:14:30 <ReinH> Zekka: well, I'm responding to your point about using things that people won't understand.
09:14:45 <Zekka> you can define your monad type in terms of them in a way where abstraction hopefully doesn't leak out
09:14:54 <Ankhers> cjay: Glad I could help a bit.
09:15:05 <joco42__> Ankhers: you mean that... I see. So basically python is just a C wrapper so why not wrap it directly to haskell you say?
09:15:17 <Zekka> Maybe I'm just conflating them too much with my awful experience with the pipes UX though, but I kind of associate their usage with clever rewriting tricks
09:15:35 <Zekka> You don't *have* to use clever rewriting tricks, but what they offer is a math opportunity to introduce them
09:15:38 <joco42__> Ankhers: the thing is I am not good at C.
09:16:27 <joco42__> Ankhers: I am thinking writing a gui python and a haskell frp logic for it.
09:16:30 <Zekka> (FWIW I should clarify what knowledge I started with: roughly what the Free type says, some examples of libraries that use Free monads, very little of the justification for the term "free" -- and now I feel like I know slightly more of the justification and have a better intuition for what Free is)
09:16:33 <ReinH> joco42__: I think you should spend your time getting better at haskell rather than trying to make it FFI with python :)
09:16:47 <ReinH> Zekka: have you see the examples?
09:17:00 <bennofs> joco42__: what GUI lib would you use in python? 
09:17:01 <ReinH> Zekka: Ed's libraries tend to be a bit more brazen about throwing the theory around, I admit.
09:17:06 <ReinH> Zekka: Have you seen the operational library?
09:17:13 <joco42__> bennofs: QT for example.
09:17:18 <ReinH> It's a free monad packaged up in a more approachable way
09:17:19 <Zekka> I haven't seen operational.
09:17:24 <bennofs> joco42__: there is hsqml for haskell ;) 
09:17:25 <ReinH> @hackage operational
09:17:25 <lambdabot> http://hackage.haskell.org/package/operational
09:17:26 <Zekka> I don't know which examples you mean otherwise
09:17:28 <bennofs> @hackage hsqml
09:17:28 <lambdabot> http://hackage.haskell.org/package/hsqml
09:17:42 <joco42__> bennofs: but i think it is kinda limited
09:17:57 <joco42__> bennofs: it is not really qt, just qml
09:17:58 <bennofs> right, it is :/
09:18:20 <ReinH> Zekka: https://github.com/ekmett/free/tree/master/examples for edwardk's Free stuff
09:18:51 <ReinH> the teletype one is pretty straightforward
09:19:07 <ReinH> well, relatively speaking
09:19:28 <Zekka> ReinH: The stuff I've run into that I think I actually have an issue with is specifically tricky rewriting rules
09:19:36 <ReinH> Zekka: But I would say operational is the most bang for buck in terms of making use of free monads without needing to grok all the theory
09:19:49 <ReinH> Zekka: what sort of rewriting rules?
09:19:52 <Zekka> If you'd asked me yesterday I would have said that I thought tricky rewriting rules were the primary reason to use free monads
09:20:03 <joco42__> bennofs: some weekend i will try this ... reflex - via python - qt5 ... combo
09:20:33 <ReinH> Zekka: AST rewriting?
09:20:44 <Zekka> Anything that's exploiting "I have a huge tree here that represents my program and I would like to substitute parts of it"
09:20:55 <ajf> what's the function like Monad m => m a -> (m a -> m b) -> m b
09:20:59 <ReinH> Zekka: Ah, yeah, uniplate is good for that
09:21:07 <ReinH> ajf: flip ap
09:21:08 <Zekka> If you're comfortable calling Free's tree a syntax tree then I would call that AST rewriting
09:21:21 <ajf> so I can do input <- getContents, inputLines <- lines input as a one-liner
09:21:27 <ReinH> Zekka: Well, monads can be looked at as doing tree grafting, absolutelyl
09:21:34 <ajf> maybe that type signature was wrong, uh
09:21:40 <ajf> oh
09:21:42 <ReinH> but the issue there is with being able to inspect the tree
09:21:42 <ajf> >>=
09:21:46 <ajf> Monad m => m a -> (a -> m b) -> m b
09:21:47 <ReinH> reflection
09:21:51 <ReinH> uniplate is better at that
09:22:00 <ajf> (a -> m b) not (m a -> m b)
09:22:01 <ajf> :)
09:22:07 <ReinH> tree grafting / variable substitution, there's a nice paper about that...
09:22:10 <Zekka> ReinH: Isn't the point of free monads that you have a data structure where everything relevant to the monad interface is inspectable?
09:22:22 <bennofs> joco42__: you should definitely try out hsqml too :) there's an 1h video on the website where the developer shows how to build a "notes" application with it (you can even have it use native widgets through qtquick-controls!) 
09:22:28 <ReinH> oh, no, not a paper, a sigfpe post like everything else http://blog.sigfpe.com/2006/11/variable-substitution-gives.html
09:22:38 <Xnuk> @hoogle Monad m => m a -> (a -> m b) -> m b
09:22:39 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:22:39 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:22:39 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
09:22:56 <ajf> actually I think I wanted `fmap`
09:23:01 <Zekka> ReinH: Anyway, this is the stuff I'm thinking of when I'm hazarding people that I'm worried free monads are confusing
09:23:03 <ajf> `lines` isn't an IO action
09:23:03 <bennofs> ajf: yes you want :)
09:23:13 <ReinH> Zekka: absolutely, check out http://blog.sigfpe.com/2006/11/variable-substitution-gives.html
09:23:22 <joco42__> bennofs: i was trying it, watching it, but somehow... it us just too much magic for me
09:23:34 <joco42__> and too little power in return
09:23:46 <joco42__> too difficult in other words
09:23:53 <Zekka> by design the code you feed in is not the same as the code you interpret into the monad that actually does your effects, and if you want to know why you will have to start thinking about data structures instead of programs
09:23:59 <bennofs> joco42__: ah, you mean this type level trickery for supporting variadic functions etc
09:24:00 <bennofs> ?
09:24:06 <ReinH> Zekka: compare to Plated though as well https://hackage.haskell.org/package/lens-4.12.3/docs/Control-Lens-Plated.html
09:24:20 <joco42__> bennofs: yes, and also the c ffi 
09:24:26 <ReinH> Zekka: that's the sefcret, data structures are programs and programs are data structures ;)
09:24:50 <Zekka> ReinH: I think that's the easy part
09:25:09 <bennofs> joco42__: have you looked at gtk bindings? I believe they are pretty mature (haven't used them myself)
09:25:12 <joco42__> i bennofs : i am not good at c, i dont want to write c code, if i need then i want to write python code... instead of c, this is why pyqt exists...
09:25:13 <Zekka> the hard part is the specifics of the free monad interface, although that's not that hard
09:25:19 <ReinH> Zekka: Yeah, that much is obvious if you even look at CPU architectures ;)
09:25:24 <Zekka> and you can avoid it
09:25:30 <joco42__> bennofs: yes, the gtk is another interesting option
09:25:33 <ReinH> at least, most of them
09:26:25 <sdx23> http://lpaste.net/376617414374195200 this reminds me of object oriented programming - is it bad practice?
09:26:32 <ReinH> Zekka: but yeah, there are a variety of interpretatios of free monads... in fac, exactly as many as there are interpretations of monads in general, because they're free, and that's part of their power ;)
09:27:06 <joco42__> bennofs: the reasoning is that... I know haskell, I know python, the haskell-python bindings are easy to learn, so everything is easy to learn and well documented in this equation, in other words transparent, i understand every bit of detail if i use this combo... and have all the power that i can get out of full qt and haskell
09:27:24 <Zekka> The other hard part: things you already understand may be rewritten into things you don't neessarily understand, depending on what you're using
09:27:47 <ReinH> sdx23: not at all
09:27:49 <suppi> sdx23, I'm no expert, but looks reasonable to me
09:28:02 * hackagebot coverage 0.1.0.2 - Exhaustivity Checking Library  https://hackage.haskell.org/package/coverage-0.1.0.2 (NicolasDelPiano)
09:28:04 * hackagebot hans 2.6.0.0 - IPv4 Network Stack  https://hackage.haskell.org/package/hans-2.6.0.0 (TrevorElliott)
09:28:38 <sdx23> ReinH, suppi: good, then I'll go along with it. Thank you :)
09:28:48 <suppi> sdx23, good luck :)
09:28:49 <Zekka> ReinH: But fwiw I also see this as a boiling the crab situation, because from my experience free monads are not the first thing that will be too confusing for most people
09:28:52 <joco42__> haskell is pretty nice but as the author of this post says: https://john-millikin.com/articles/ride-the-snake/ "Haskell's a great language; it's efficient, consistent, terse, reliable, and so on. But if there's one thing Haskell's not, it's "batteries included"."
09:29:05 <ReinH> sdx23: Note that the record doesn't store any state as you would expect of a traditional O in OOP
09:29:34 <ReinH> Zekka: I think that's because they are presented poorly, but because they are inherently difficult.
09:29:43 <ReinH> Zekka: I have had success teaching monads by starting with free monads.
09:30:03 <joco42__> this kind of batteries included part is a little bit indeed missing... so i am wondering if some simple binding to a batteries included language would help....
09:30:06 <ReinH> You go list -> free monad -> monad morphisms (interpreters) -> monads
09:30:26 <ReinH> and you note in passing that the free monad construction is very, very similar to a list
09:30:42 <sdx23> ReinH: so if it would, that'd be not too good? However, in a threaded environment MVars in records are one way to go, or is that to be avoided too?
09:30:55 <joco42__> and i am really wondering why people are not using this haskell-python binding....
09:30:57 <Zekka> ReinH: You should teach my coworkers, who are (imho justifiably) pretty suspicious of highly abstract things
09:30:59 <ReinH> sdx23: Not necessarily, but it does distinguish this approach from OO
09:31:50 <bennofs> joco42__: how do you marshal data between haskell and python with haskell-python?
09:31:55 <Zekka> Oh, hold up, have to go
09:32:11 <sdx23> ReinH: I see. I've recently noticed trouble finding a nice style, but I'm not sure it's something that mainly comes with experience.
09:32:19 <ReinH> Zekka: it also show that a list can represent non-branching computations, and the conversion to the free monad structure is precicely the one that gives you computations that branch based on previously computed values
09:33:41 <joco42__> bennofs: i wonder if this page answers your question https://john-millikin.com/articles/ride-the-snake/ i haven't tried this binding yet so i don't know the answer myself
09:33:42 <aweinstock> bennofs: I'd imagine it would be straightforward (but painful/tedious) with Python's ctypes and Haskell's Foreign.Marshal
09:33:46 <ReinH> If you want to teach "monads" per se rather than "IO and State and other things that have >>= and return functions", it's a good way to go
09:33:58 <ReinH> then again, the latter is often the more practifcal approach
09:34:07 <ReinH> god I can't type today
09:34:09 <joco42__> bennofs: what do you mean by marshalling ? moving ?
09:34:12 <aweinstock> bennofs: (but then again, that sort of depends on knowing C datastructures)
09:34:35 <bennofs> joco42__: if you have data Foo = Bar String | Qux Int and you need to pass that to python, you probably won't be able to do so directly
09:34:46 <aweinstock> joco42__: if you have some data on what-to-do in haskell, how do you tell your python gui what to do?
09:34:52 <bennofs> joco42__: you have to specify how to translate that data to types that python knows
09:35:04 <joco42__> bennofs: i have a look at this
09:35:47 <aweinstock> joco42__: one possible approach is having a python "client" connect to a haskell "server" via a socket
09:36:06 <aweinstock> joco42__: and have them communicate via JSON or something
09:36:30 <aweinstock> :t Data.Aeson.TH.deriveJSON
09:36:32 <lambdabot> aeson-0.9.0.1:Data.Aeson.Types.Internal.Options -> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
09:36:41 <joco42__> aweinstock: i don't know it yet precisely  but this seems to be answer to your question : https://john-millikin.com/articles/ride-the-snake/
09:36:59 <bennofs> aweinstock: lambdabot has aeson? cool
09:37:06 <joco42__> aweinstock: i have not tried this myself yet, i have to try it some weekend
09:39:36 <aweinstock> joco42__: that looks like the cpython library handles all the marshalling for you (and probably is doing FFI stuff with the actual python interpreter)
09:40:10 <aweinstock> joco42__: I guess that might be a good idea, but only if python's GUI libraries are significantly better than haskell's
09:40:23 <AaronFriel> Unless using lambda case, if I've got a sum type with arguments, without pulling out the fn, there's no clean way to write (\c -> c != Token _foo_) where _foo_ is anything, right?
09:40:25 <joco42__> aweinstock: yeah, it looks easy... i am currently installing it to a sandbox...
09:40:43 <joco42__> wanna try the examples from the webpage
09:41:05 <bennofs> AaronFriel: right, there isn't as far as I'm aware. 
09:41:13 <AaronFriel> that's a shame
09:41:21 <joco42__> aweinstock: https://www.riverbankcomputing.com/software/pyqt/intro
09:41:23 <aweinstock> :t (!=)
09:41:25 <lambdabot>     Not in scope: ‘!=’
09:41:25 <lambdabot>     Perhaps you meant one of these:
09:41:25 <lambdabot>       ‘!!’ (imported from Data.List), ‘/=’ (imported from Data.Eq),
09:41:35 <AaronFriel> aweinstock: I'm aware of /= :)
09:41:43 <joco42__> aweinstock: it is as good as a gui library can get... 
09:41:45 <AaronFriel> I just typoed
09:42:00 <bennofs> joco42__: there seem to be a at least a dozen haskell <-> python bindings on hackage from my quick search
09:42:10 <joco42__> bennofs: really?
09:42:15 <bennofs> joco42__: http://hackage.haskell.org/packages/search?terms=python
09:42:23 <joco42__> i only found two...
09:42:28 <aweinstock> joco42__: I've dealt with PyQt before, and remember there being painful edge cases involving the metaclass hackery it uses for signals&slots
09:43:01 <aweinstock> @let (!=) = (/=)
09:43:03 <lambdabot>  Defined.
09:43:11 <bennofs> joco42__: there's at least MissingPy, json-python, pyfi, HaPy  looking only at the description
09:43:52 <bennofs> joco42__: + pyffi 
09:43:54 <joco42__> aweinstock: hmmm... that's why one has to use frp :)
09:44:26 <joco42__> bennofs: yes, the strange thing is that these bindings are not very alive...
09:44:45 <joco42__> bennofs: i would have expected them to be more popular...
09:47:19 <joco42__> yes, bennofs, the thing is i am really wondering why these python bindings are not more popular.... why haskellers are not using them.... more... much more ?
09:47:49 <bennofs> joco42__: idk. perhaps haskellers prefer writing C++ and binding it via the C FFI :) 
09:48:05 <joco42__> bennofs: yes, that can be...
09:48:21 <bennofs> joco42__: lets see if I can get cpython built on nixos...
09:48:32 <joco42__> bennofs: i mean cpython can be called directly from haskell
09:49:13 <joco42__> without any binding...
09:49:23 <joco42__> so maybe there is no need for a binding...
09:49:57 <joco42__> cpython is just a c library that can be called from c... afaik, someone correct me if i am wrong...
09:50:30 <joco42__> https://docs.python.org/2.5/ext/callingPython.html
09:52:12 <aweinstock> cpython typically refers to the "default"/canonical python interpreter that's written in C
09:52:32 <joco42__> aweinstock: yes
09:53:03 * hackagebot avr-shake 0.0.1.2 - AVR Crosspack actions for shake build systems.  https://hackage.haskell.org/package/avr-shake-0.0.1.2 (JamesCook)
09:53:07 <joco42__> aweinstock: i just wrote it explicitly here cpython... instead of just python... 
09:53:13 <glguy>  /exit
09:57:42 <Welkin> if I want to parse streaming input, can I do that with just attoparsec?
09:58:19 <joco42__> bennofs: it seems cpython needs python3.3
10:00:33 <joco42__> bennofs: this is where i got stuck http://lpaste.net/139364
10:01:01 <bennofs> joco42__: which OS is that?
10:01:09 <joco42__> bennofs: osx
10:01:12 <joco42__> ghc 7.8.4
10:01:53 <bennofs> joco42__: the web page mentions that you have to install the development headers for python
10:02:10 <joco42__> bennofs: cool, i have look !
10:04:27 <bennofs> joco42__: you specially need python3.3
10:04:37 <joco42__> ok
10:04:57 <joco42__> bennofs: trying to figure out how to install that on osx....
10:05:14 <joco42__> bennofs: this looks relevant http://stackoverflow.com/questions/15931331/how-to-install-the-python-development-headers-on-mac-os-x
10:07:36 <lpaste_> bennofs pasted “haskell-python build error” at http://lpaste.net/139366
10:07:44 <bennofs> joco42__: ^^^^ i got that far on nixos
10:08:00 <agocorona> what is the definition of composability?
10:10:07 <agocorona> are there some good definition?
10:10:19 <joco42__> bennofs: yeah, the nixos version seems to be kinda old too http://hydra.nixos.org/job/nixpkgs/trunk/haskellPackages.cpython.x86_64-linux
10:19:17 <bennofs> joco42__: hmm, perhaps pyfi builds, it seems more recent: https://github.com/Russell91/pyfi
10:19:35 <Gurkenglas> agocorona, how did you come to need that definition? Wikipedia has it as a term from software engineering, I would have guessed something like "two things are composable if they can be composed", refering to what you can look up as function composition
10:21:15 <agocorona> Gurkenglas:  but I expected something well defined in mathematical terms
10:21:20 <joco42__> bennofs: I am trying this way http://stackoverflow.com/questions/15931331/how-to-install-the-python-development-headers-on-mac-os-x
10:21:23 <agocorona> in CS terms
10:21:56 <agocorona> because people are talking all the time about composability without a precise definition
10:22:24 <hodapp> agocorona: I'd like to have a good working definition too...
10:22:38 <hodapp> I have only a sort of vague mental sense of what it means to say that two things can be composed
10:22:52 <agocorona> I think that two elements are composable if there are part of an algebra
10:23:01 <agocorona> if they are part of
10:23:05 * hackagebot dependent-sum 0.3.1.0 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.3.1.0 (JamesCook)
10:24:34 <hodapp> agocorona: what algebra they are a part of might matter for practical reasons
10:25:13 <Gurkenglas> agocorona: Two functions are composable if the target space of one is the origin space of the other. Are you familiar with category theory? It explores composition on more than functions
10:25:46 <agocorona> Gurkenglas:  the function composition operator . is part of an algebra
10:29:43 <agocorona> numbers combine because there is an algebra defined.
10:30:44 <agocorona> and i suppose that function composition, monadic appllicative etc combinators are part of a non commutative algebra
10:34:13 <p0a> lpaste down for anyone else?
10:34:58 <p0a> I'm trying to load some code that has 'import Data.List' but I get this error: http://pastie.org/10366803
10:35:05 <p0a> what am I doing wrong?
10:35:47 <hodapp> agocorona: I read https://www.fpcomplete.com/user/agocorona/EDSL-for-hard-working-IT-programmers?show=tutorials months back; what epiphany atop that and related work did you just have?
10:36:00 <geekosaur> p0a, pastebin the code as well
10:36:07 <Ankhers> p0a: Can you show the file, at least from the top to the imports.
10:36:14 <geekosaur> and lpaste just loaded here
10:36:28 <Ankhers> lpaste also working here.
10:36:52 <p0a> It may be caught in a network filter then, here's my code plaintext http://pastie.org/10366814
10:36:56 <hodapp> ummm, 
10:36:56 <doelie> hi.  if  a -> m b  is called a Kleisli arrow, how would you call  a -> b -> m c ?
10:37:06 <hodapp> did anyone catch zipper's quit message?
10:37:16 <Ankhers> p0a: There is nothing above the import?
10:37:18 <p0a> hodapp: hope he's joking
10:37:29 <p0a> Ankhers: I snipped that stuff, it wasn't relevant
10:37:39 <geekosaur> um
10:38:05 * hackagebot dependent-sum 0.3.2.0 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.3.2.0 (JamesCook)
10:38:17 <Ankhers> p0a: With that minimal code, are you still getting the issue?
10:39:11 <p0a> Ankhers: yes. I am using emacs and haskell-mode, I load the code with C-c C-l
10:39:19 <p0a> Do you think that's the issue?
10:39:31 <Ankhers> p0a: I will try it right now.
10:41:04 <Ankhers> p0a: What is you value for `haskell-process-type`?
10:41:21 <aweinstock> dolio: also a Kleisli arrow? or maybe a function returning a Kleisli arrow?
10:41:28 <p0a> I'm not sure how to use emacs to check on that 
10:41:29 <aweinstock> oops, doelie 
10:41:48 <Ankhers> p0a: C-h v haskell-process-type RET
10:41:55 <Ankhers> C in C-h being control.
10:42:06 <p0a> [no match]
10:42:51 <zipper> haBuu^: Hey, it seems to still react quickly between recompiles. I'll pass force-no-recompile to GHC and see if that changes stiff
10:42:53 <zipper> *stuff
10:45:04 <Ankhers> p0a: I'm not seeing that happening. I'm getting a couple other issues though.
10:45:08 <agocorona> hodapp: I mean a more accurate idea of composability and the extension of it  even to distributed computing
10:45:46 <p0a> Ankhers: :/
10:46:15 <bennofs> joco42__: yay, after a few ugly patches I got it building with python33 on nix
10:46:33 <joco42__> bennofs: wow
10:46:59 <joco42__> bennofs: i got stuck with python33 install
10:48:05 <p0a> Ankhers: don't worry about it. I'll download latest GHC and Leksah
10:48:22 <p0a> Won't work further with emasc, there's not that many benefits with haskell-mode anyhow
10:48:45 <joco42__> bennofs: i will try macports... brew did not work out for python33
10:48:50 <lpaste_> bennofs pasted “build fixes for haskell-python” at http://lpaste.net/139368
10:48:59 <joco42__> cool
10:49:18 <codedmart> I have this in a cabal file https://github.com/AtnNn/haskell-rethinkdb/blob/f700133a4c2935389e1dd69ef887ae5f84cbe58a/rethinkdb.cabal#L46. under an if flag(dev). Travis cabal check is failing on 7.10 with `'ghc-prof-options: -fprof-auto' is fine during development…`
10:49:35 <Ankhers> p0a: haskell-mode isn't really doing anything in this case. It is something wrong with your file. It is just opening up ghci within emacs and loading that file.
10:49:39 <joco42__> bennofs: is this nix or nixos ?
10:49:41 <codedmart> Any idea how I can fix that?
10:49:43 <bennofs> joco42__: nixos
10:49:49 <bennofs> joco42__: build via nix expression
10:49:51 <p0a> Ankhers: what is wrong then? Isn't that the way to load modules? :S
10:50:21 <geekosaur> p0a, I haven't done it in a while but iirc there's a way to tag code to insert before stuff and you may have accidentally done so?
10:50:25 <Ankhers> p0a: Are you sure it is happening with only the minimal example you gave?
10:50:28 <p0a> Yes 
10:52:04 <joco42__> bennofs: if macports and ubuntu wont cut it then i go for nix, as last resort...
10:52:25 <Ankhers> geekosaur: What do you mean by "tag code to insert before stuff"?
10:53:34 <joco42__> bennofs: i guess will need your patches once i get python33 installed  on osx
10:54:02 <Tuplanolla> I have enabled 'executable-dynamic' and 'shared' in my ~/.cabal/config, but I get "Perhaps you haven't installed the "p_dyn" libraries for package 'base-4.8.1.0'?" whenever I try to enable dynamic linking. What's the problem?
10:54:18 <Tuplanolla> I found a ticket about it, but it's not very helpful.
10:55:56 <Tuplanolla> Right here: https://ghc.haskell.org/trac/ghc/ticket/8677
10:57:48 <rohan> upcoming haskell conferences ?
10:59:36 <Ankhers> rohan: Haskell eXchange 2015 https://skillsmatter.com/conferences/7069-haskell-exchange-2015
11:00:12 <rohan> Ankhers:ty
11:00:24 <JagaJaga> If I have json { foo : {bar : { baz : "aaa"}}} --- how can I get foo.bar.baz with Data.Aeson?
11:03:05 <Ankhers> JagaJaga: You can either create a data structure to represent that. Or you could do something like `lookup "bar" myObject` (assuming you have already decoded the value. This would give you the `bar` object. You could either keep doing this to get `baz`, you I'm sure lenses would be useful here somehow.
11:03:51 <MagBo> Ankhers: in fact, it's trivial with lens-aeson.
11:04:01 <Ankhers> Apparently I'm terrible with grammar at the moment. My apologies.
11:04:36 <MagBo> JagaJaga: I should have examples of code, which I'll share with you privately :)
11:04:59 <Ankhers> MagBo: I haven't looked into lenses yet. Nor all of the lens-* packages. It is something I really need to do.
11:06:47 <MagBo> Yeah, I'm very slowly absorbing lens in practice myself. A wake-up call that I should master it was when I was asking about something and after some time of discussion with people who understand lens, it turned out that I was reinventing prisms :)
11:07:49 <rohan> MagBo: That would be a moment of lol and awe!
11:08:01 <rohan> An unusual combination
11:10:43 <JagaJaga> Ankhers: thx, I will look that way
11:11:28 <wraithm> tomjaguarpaw: ping
11:12:39 <rohan> > print 3
11:12:41 <lambdabot>  <IO ()>
11:14:30 <rohan> >f [] = []; f(x:xs) = (x*2) : f xs
11:15:07 <rohan> >@let f [] = []; f(x:xs) = (x*2) : f xs
11:15:27 <bananagram> just @let
11:15:27 <rohan> > take 3 [1..]
11:15:30 <lambdabot>  [1,2,3]
11:15:50 <geekosaur> welp. not seeing any docs on marking a thing to be preloaded (e.g. imports) but I also think it was only for expression evaluation, not running a program
11:16:43 <Tuplanolla> What does this 'p_dyn' even mean?
11:17:16 <rohan> > mapM id [[1,2,3],[4,5,6]]
11:17:17 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
11:17:20 <geekosaur> profiling shared objects
11:17:22 <rohan> how does this work?
11:18:08 * hackagebot dependent-sum 0.3.2.1 - Dependent sum type  https://hackage.haskell.org/package/dependent-sum-0.3.2.1 (JamesCook)
11:18:22 <geekosaur> Tuplanolla, libraries and the runtime come in "flavors". "p_dyn" means compiled for profiling and as shared objects instead of the usual static libraries
11:18:33 <Tuplanolla> Can I have both, geekosaur?
11:18:48 <ReinH> @src mapM
11:18:49 <lambdabot> mapM f as = sequence (map f as)
11:19:04 <bananagram> :t mapM
11:19:05 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:19:10 <ReinH> > sequence [[1,2,3],[4,5,6]]
11:19:11 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
11:19:16 <ReinH> rohan: like that
11:19:21 <geekosaur> Tuplanolla, you'd have to find a ghc installation that includes them
11:19:23 <ReinH> map id xs = xs
11:19:29 <bitemyapp> @pl is' x = o ^. key "type" . _String . to (Any . (==) x)
11:19:29 <lambdabot> (line 1, column 27):
11:19:29 <lambdabot> unexpected "_"
11:19:29 <lambdabot> expecting space
11:19:29 <lambdabot> ambiguous use of a right associative operator
11:19:32 <geekosaur> it sounds like yours does not. how did you install it?
11:19:42 <bitemyapp> @pl is' x = o ^. (key "type" . _String . to (Any . (==) x))
11:19:42 <lambdabot> (line 1, column 8):
11:19:42 <lambdabot> unexpected " "
11:19:42 <lambdabot> expecting operator
11:19:53 <bitemyapp> okay.
11:20:01 <geekosaur> if it's from distribution packages, you'll need to figure out how they split the packages up (if indeed they built the different variants)
11:20:05 <Tuplanolla> I used the newest PPA, geekosaur.
11:20:27 <Tuplanolla> Here: https://launchpad.net/~hvr/+archive/ubuntu/ghc
11:21:18 <geekosaur> yeh, I'm poking. (which ubuntu version?)
11:21:24 <geekosaur> (and ghc version)
11:22:20 <Tuplanolla> Those would be ghc-7.10.2~trusty and cabal-install-1.22~trusty, but this is not Ubuntu.
11:23:04 <geekosaur> well, I still need to know which set of packages to look at
11:23:13 <Gurkenglas> :t map (fst . head &&& map snd) . groupBy ((==) `on` fst) . sortBy (compare `on` fst) -- What's the correct way to do this kind of thing?
11:23:14 <lambdabot> Ord a => [(a, b)] -> [(a, [b])]
11:23:21 <Tuplanolla> It says the 'dyn' variant is a "dummy package", so I didn't install it at all.
11:23:35 <geekosaur> if I'm lookinbg at the packages for trusty and you're installing the ones for precise, I'm not looking in the right place
11:23:59 <geekosaur> okm, wait, it's in there
11:24:08 <geekosaur> did you install the -prof package
11:24:11 <Tuplanolla> Yes.
11:24:15 <Tuplanolla> Profiling works fine.
11:24:58 <Gurkenglas> (Wait a second, that's obviously "fromListWith (++) . map (second pure)". Why didn't I think of that?)
11:26:10 <geekosaur> hm, apparentluy can't just get a file list, I have to download the deb and inspect it :/
11:26:19 <rohan> ReinH: The defination for the function f in (mapM f l) is (a ->m b)
11:26:30 <rohan> and the supplied function is id
11:26:33 <exio4> @type mapM 
11:26:34 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
11:26:36 <rohan> which is (a->a)
11:26:39 <Tuplanolla> Can I help with that list, geekosaur?
11:27:03 <geekosaur> well, you have the key information, there'd be files with "p_dyn" in the name
11:27:03 <exio4> @type mapM id
11:27:04 <lambdabot> (Monad m, Traversable t) => t (m b) -> m (t b)
11:27:13 <exio4> @type sequence
11:27:14 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
11:27:20 <geekosaur> but I'm suspecting that this buld just doesn't support dynamic
11:27:28 <geekosaur> you may have to do a custom build
11:27:30 <Hijiri> rohan: set a to m c, and b to c
11:27:36 <Hijiri> then you get (m c -> m c)
11:27:43 <Tuplanolla> This should though.
11:27:46 <rohan> aaah
11:27:49 <rohan> smart!
11:28:08 * hackagebot dependent-map 0.2.0.1 - Dependent finite maps (partial dependent products)  https://hackage.haskell.org/package/dependent-map-0.2.0.1 (JamesCook)
11:28:09 <rohan> but this can happen only under a monadic context correct?
11:28:11 <geekosaur> you already said the dyn packages were dummies (and indeed at 2K size they can't have much in them)
11:28:21 <geekosaur> so I suspect hvr used to do dyn builds but stopped
11:28:35 <rohan> u cant define a function fn = id having the type a -> m b routinely.. am i correct?
11:28:39 <Tuplanolla> I assumed that meant they were integrated into the main package, geekosaur.
11:28:39 <geekosaur> and the dyn packages are just there to prevent dpkg from becoming confused
11:29:00 <Hijiri> rohan: yeah, the type of the input has to be m something
11:29:17 <Hijiri> it could be something other than a Monad though
11:29:24 <hvr> geekosaur: starting with 7.10 or so, the -dyn stuff is in the base package
11:29:25 <rohan> Hijiri: Ty
11:29:25 <Tuplanolla> Check this out.
11:29:28 <lpaste_> Tuplanolla pasted “dpkg --listfiles ghc-7.10.2” at http://lpaste.net/139369
11:29:44 <Tuplanolla> There's 'dyn' stuff in it.
11:30:03 <Gurkenglas> Is doing "fromList . fromListWith (...)" several times slower than an implementation made for that purpose would be?
11:30:56 <geekosaur> ok, then hvr didn't make p_dyn to go with the dyn, it sounds like
11:31:16 <exio4> Gurkenglas: I fail to see how something like that may typecheck, which fromList/fromListWith are we talking about?
11:31:33 <geekosaur> still sounds like you either need a custom version or drop the executable-dynamic and shared stuff when doing prof builds
11:31:39 <hvr> geekosaur: is p_dyn even part of the standard ghc bindist?
11:31:46 <geekosaur> I have no idea
11:31:57 <Gurkenglas> exio4: Oops, sorry, I meant toList.
11:32:06 <Gurkenglas> :t \f -> toList . fromListWith f
11:32:07 <lambdabot>     Ambiguous occurrence ‘toList’
11:32:07 <lambdabot>     It could refer to either ‘Data.Foldable.toList’,
11:32:07 <lambdabot>                              imported from ‘Data.Foldable’ at /home/lambda/.lambdabot/State/L.hs:86:1-20
11:32:08 <exio4> oh that makes sense
11:32:15 <geekosaur> trying to diagnose on my feet (while also doing unrelated package building for work, so a bit distracted...)
11:32:28 <Gurkenglas> :t \f -> F.toList . M.fromListWith f
11:32:29 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> [a]
11:32:45 <ReinH> @src mapM
11:32:45 <lambdabot> mapM f as = sequence (map f as)
11:32:55 <ReinH> Oh they left
11:33:35 <Guest4406> Does anyone know how the internals of cabal-install work? I wanted to look at the commands that are executed, and used the -v switch. However, in between configure and ghc....., there is an autogen/ being created, I'd like to know more about it
11:33:53 <Tuplanolla> Ohh!
11:34:25 <feryll> Why does the compiler tell me I can't bind results from IO computations while working in a Writer do (I think)? http://lpaste.net/139370
11:34:53 <geekosaur> because "do" is not magic that makes IO possible
11:34:59 <geekosaur> if you are using Writer, you are not using IO
11:35:18 <feryll> I know, but I should be able to get the results from computations of a different monad, right?
11:35:23 <geekosaur> nope
11:35:53 <exio4> Gurkenglas: I don't really know :/
11:35:54 <geekosaur> not unless you have a monad transformer (WriterT IO, presumably) in which case you can "lift" to get to the IO from the WriterT
11:36:33 <Tuplanolla> $ cabal configure --disable-executable-profiling --disable-library-profiling --enable-executable-dynamic --enable-shared # I should use this when testing...
11:36:33 <Tuplanolla> $ cabal configure --disable-executable-dynamic --disable-shared --enable-executable-profiling --enable-library-profiling # ...and this when profiling, to prevent 'dyn' from clashing with 'prof'.
11:37:12 <Tuplanolla> I don't actually need 'p_dyn' at all.
11:37:14 <feryll> I don't presume that's best practice, though?
11:37:34 <Guest4406> Tuplanolla, are you talking to me?
11:37:37 <Guest4406> Sorry confused 
11:38:01 <geekosaur> Guest4406, no, different conversation
11:38:10 <Guest4406> ah apologies
11:38:20 <Tuplanolla> Actually geekosaur and hvr, Guest4406.
11:38:34 <geekosaur> feryll, I don't understand that question/comment
11:38:50 <geekosaur> if you need to mix Writer and IO then yes, WriterT over IO is the correct way to do it
11:39:07 <Tuplanolla> I just wanted to announce the solution, for public service and all that.
11:39:14 <feryll> All right, thanks.
11:39:16 <Welkin> there is no IO transformer :)
11:39:51 <geekosaur> right, there are certain monads that always have to be at the base of a transformer stack (IO, ST, STM)
11:41:01 <mietek> Is it possible to define a type constructor being an unary operator symbol?
11:41:04 <feryll> So is there a simple way to rewrite that example, then?
11:42:05 <Ankhers> feryll: WriterT IO a
11:42:28 <Welkin> @data UnaryType a = (:-) a
11:42:28 <lambdabot> Unknown command, try @list
11:42:32 <Welkin> @define data UnaryType a = (:-) a
11:42:32 <lambdabot>  .L.hs:150:20: parse error on input ‘:-’
11:42:47 <Ankhers> You do your normal Writer code, when you want to do IO, you can `lift` into it. e.g., `lift $ putStrLn "hello"`
11:42:54 <Welkin> @define data UnaryType a = (:-) a a
11:42:54 <lambdabot>  .L.hs:150:20: parse error on input ‘:-’
11:42:54 <Ankhers> I *think*
11:43:00 <Hijiri> Ankhers: I think the argument order is WriterT w m a
11:43:07 <Welkin> @define data UnaryType a = a (:-) a
11:43:07 <lambdabot>  Parse failed: Illegal data/newtype declaration
11:43:15 <Hijiri> actually it would have to be
11:43:20 <Hijiri> to fit monad transformer class
11:43:23 <Ankhers> I don't use transformers extensively, my apologies.
11:43:39 <mietek> Welkin: so that should work, yes, but it seems like the only way to use it in a pattern match would be
11:43:51 <mietek> foo ((:-) bar) = ...
11:44:44 <Welkin> what's with the parse failure on lambdabot
11:44:57 <Ankhers> feryll: https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Lazy.html#g:3
11:45:07 <Ankhers> Welkin: I think lambdabot has been sick for a couple days.
11:45:32 <feryll> Hm, thanks Ankhers
11:45:43 <feryll> Never even really knew about transformers before
11:46:20 <Guest4406> @:t "test"
11:46:20 <lambdabot> Maybe you meant: wn v rc pl let id do bf @ ? .
11:46:32 <Ankhers> :t "test"
11:46:34 <lambdabot> [Char]
11:46:45 <Guest4406> :t "test"
11:46:47 <lambdabot> [Char]
11:46:48 <Guest4406> ah cool
11:47:18 <mietek> Doesn’t seem like XPostfixOperators applies to pattern matching, either
11:50:19 <rjeli> :k StateT
11:50:20 <lambdabot> * -> (* -> *) -> * -> *
11:57:12 <tulcod> is reflex considered "state of the art" when it comes to FRP?
11:57:19 <Gurkenglas> @define data UnaryType a = a :- a -- Welkin
11:57:20 <lambdabot>  .L.hs:152:20:
11:57:21 <lambdabot>      Multiple declarations of ‘:-’
11:57:21 <lambdabot>      Declared at: .L.hs:150:26
11:58:03 <Gurkenglas> Oops, that's cause I testwisely defined UnaryTypeasdasd to that.
12:02:04 <siwica> How do I find out the type signature of the <- Operator?
12:02:16 <Gurkenglas> :k (<-)
12:02:17 <lambdabot>     parse error on input ‘<-’
12:02:17 <lambdabot>     Perhaps this statement should be within a 'do' block?
12:02:46 <tulcod> siwica: <- isn't really an operator, I think. it's just part of the "do" syntax that we use for monads
12:02:49 <Gurkenglas> :k (->) -- Wait, I thought you meant this.
12:02:50 <lambdabot> * -> * -> *
12:03:34 <siwica> No, the other direction ,)
12:03:36 <tulcod> siwica: in the end it is all translated to complicated compositions of (>>=) and 'return'
12:04:20 <siwica> tulcod: Yes, I just wanted to find out how this is done precisely and thought <- was a well defined operator
12:05:38 <tulcod> siwica: http://lpaste.net/139371
12:06:11 <tulcod> probably a few things not quite right there. but that's the gist of it.
12:06:57 <siwica> tulcod: oh ok, thank you!
12:07:40 <ahihi> https://en.wikibooks.org/wiki/Haskell/do_notation
12:08:11 <tulcod> siwica: ghc first "desugars" haskell into "core"
12:08:29 <tulcod> siwica: maybe you should try compiling a few programs into that
12:09:07 <tulcod> nevermind that. seems ghc cannot do that.
12:09:12 <siwica> tulcod: Do you know how to just remove the sugar using ghc?
12:09:19 <siwica> oh ok
12:09:31 <siwica> Would be instructive though
12:10:26 <Hijiri> lambdabot has @undo
12:10:35 <siwica> But there should me a tool for unsugaring (saltening?!) I guess
12:11:29 <tulcod> siwica: http://www.scs.stanford.edu/11au-cs240h/notes/ghc-slides.html
12:11:30 <Ankhers> siwica: I would go with sugaring. Salting is already a fairly defined term in cryptography.
12:11:42 <Welkin> `a <- as` is the same as `as >>= \a -> ...`
12:12:49 <siwica> The link speaks of going to vanilla haskell
12:13:08 <tulcod> siwica: (hence the name "desugaring"?)
12:13:30 <siwica> maybe one could turn that into a verb
12:13:31 <siwica> vannilaing?
12:13:50 <siwica> yeah, desugaring is fine, thought there had to be something more creative ;)
12:13:54 <tulcod> "english cooking", ie removing all taste?
12:13:58 <siwica> thanks for the links!
12:14:15 <siwica> but vanilla still has taste right?
12:14:20 <tulcod> hmm
12:14:32 <johnw> I think "desugaring", in many contexts, is fermentation
12:14:44 <tulcod> nice one
12:16:28 <geekosaur> "austere"?
12:16:37 <tulcod> johnw: "fermenting" also suggests that the value is improved, but it might not be good for everyone
12:16:41 <geekosaur> not that it's very austere
12:17:01 <geekosaur> but more so than the version with do, if then else, where, ...
12:17:42 <siwica> somebody should dedicate a paper to this question!
12:18:01 <Ankhers> tulcod: ferment can actually have a negative connotation to it.
12:18:05 <rohansumant> > map id [1..5]
12:18:06 <lambdabot>  [1,2,3,4,5]
12:18:40 <rohansumant> map id [3]
12:19:10 <Ankhers> You forgot the `>'
12:19:26 <rohansumant> Indeed!
12:20:42 <siwica> very sophisticated use of map :)
12:21:03 <fizbin> @src (<)
12:21:04 <lambdabot> x < y = case compare x y of { LT -> True; _other -> False }
12:21:10 <Welkin> map tends to cause trouble for me lately
12:21:16 <Welkin> I normally always use fmap
12:21:25 <Hafydd> Ah, yes, that _other really makes it clearer.
12:21:28 <Welkin> but sometimes I use map and it's not a list, because I forget
12:21:55 <Welkin> map (+1) (1,4)
12:21:55 <Ankhers> Welkin: I just try to avoid using map.
12:21:57 <Welkin> for example
12:22:05 <Welkin> when it should be fmap :p
12:22:53 <fosterite> Ankhers: fermentation with negative connotations is just rotting
12:23:02 <Ankhers> Is there a reason that map is not defined on Functor insteat of fmap?
12:23:33 <fosterite> Anhkers: history, same reason `fail` exists and `::` is used instead of `:`
12:24:06 <Ankhers> I figured it was just history.
12:24:08 <Ankhers> Thanks!
12:24:13 <Welkin> Just History
12:24:50 <silasm_> iirc it's also so that new users aren't confused by an overly-general type error when they're just trying to learn lists
12:24:59 <ralu> what would be transformer for errors. Something like either?
12:24:59 <silasm_> but otherwise yeah
12:25:09 <Welkin> ErrorT
12:25:46 <knupfer> why can I use foldr for any foldable and scanr only for lists?
12:26:00 <knupfer> that seems inconsistent
12:26:38 <tulcod> silasm_: (that sounds like it should be fixed by a Prelude.Newbies module)
12:26:49 <glguy> knupfer: Try to use methods from Foldable to implement a generic scanr
12:27:15 <fosterite> :t scanr
12:27:16 <lambdabot> (a -> b -> b) -> b -> [a] -> [b]
12:27:29 <fosterite> :t foldld
12:27:30 <lambdabot>     Not in scope: ‘foldld’
12:27:30 <lambdabot>     Perhaps you meant one of these:
12:27:30 <lambdabot>       ‘foldl’ (imported from Data.List),
12:27:32 <fosterite> :t foldl
12:27:34 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:27:37 <knupfer> glguy: thanks, but my question was more for the reason
12:27:40 <chattered> knupfer: Would you expect a generic scanr to be able to rebuild the same data-structure? In which case, that's more powerful than Foldable.
12:27:40 <Welkin> knupfer: https://www.haskell.org/hoogle/?hoogle=scanr
12:27:45 <Welkin> there are more than just List
12:27:50 <Welkin> but yeah, no generic one I know of
12:28:30 <knupfer> Welkin: I'm aware of others and how to implement one, I just wondered about this because folds and scans are so similar
12:28:44 <glguy> knupfer: It can't be done, Foldable f doesn't offer ways to make an 'f a'
12:29:22 <fosterite> isn't there a recursion scheme that keeps the partial results?
12:29:27 <knupfer> glguy: interesting, why?
12:30:12 <glguy> knupfer: so that you can have instances of it for types where it wouldn't be possible to construct such arbitrary values
12:31:23 <glguy> > scanr const 0 [1,2,3]
12:31:23 <knupfer> glguy: i think i'm getting it
12:31:25 <lambdabot>  [1,2,3,0]
12:31:34 <glguy> Also, observe that scanr changed the number of elements in that list
12:31:45 <glguy> but you could have a Foldable instance for: data V2 a = V2 a a
12:32:59 <chattered> knupfer: I think you could generalise scanr so long as it always spits out lists, but if you want it to spit out the same Foldable instance, you're out of luck.
12:33:36 <jle`> Welkin, ralu: ErrorT is deprecated these days in favor of ExceptT, I hear
12:33:45 <knupfer> glguy, chattered: Thank you very much, I think I've understood.
12:34:02 <ralu> that is what i was wondering
12:34:20 <jle`> by "i hear" i mean i get compiler warnings :)
12:35:00 <glguy> We need to fix that being deprecated
12:35:02 <chattered> jle`: GHC is very gossipy.
12:36:45 <jle`> i just noticed that a lot of recursive functions can be implemented by hylomorphisms on a given structure...is there a general class/name for these kinds of functions?
12:37:19 <knupfer> When does ghc exactly close files when I use for simplicity just readFile?
12:38:35 <johnw> knupfer: when you've accessed all the contents, or any handle to pending contents has been garbage collected, I'd imagine
12:39:17 <fosterite> jle`: are there any functions you can't implement as hylomorphisms on some structure? Or do you mean in some sense the same hylomorphism on different structures
12:39:20 <prsteele> knupfer: from http://www.serpentine.com/criterion/tutorial.html it seems like when you've fully consumed the file
12:39:43 <jle`> fosterite: i meant, implementing recursive functions without recursion
12:40:02 <zyxoas> 'Ello peeps.
12:40:31 <jle`> well, i guess i meant, re-writing/translating recursive functions
12:40:34 <jle`> hi zyxoas :)
12:41:25 <knupfer> ok
12:41:29 <zyxoas> I have a simple question to which I can't find the answer: How do I show (convert to String) a decimal number, such that I have a maximum of n decimal places, and there are no unnecessary trailing zeros?
12:41:54 <zyxoas> showFFloat from Numeric is nearly there, but it displays trailing zeros.
12:41:58 <feryll> Ankhers: So I'm still working with the transformations on http://lpaste.net/139370 (in my actual problem, bar n can't easily be made Int -> [String] since I use System.Random stuff)
12:42:05 <fosterite> jle`: primitive recursive functions? IIRC someone whose name starts with C wrote a compiler that did everything in terms of eliminators, not sure if it was conal or conor
12:42:23 <johnw> prsteele: reading the source, there is a finalizer on the handle
12:42:27 <johnw> so garbage collection should also close
12:42:34 <zyxoas> For 6 decimal places, I want 0.03 to display as "0.03", not "0.030000"
12:42:39 <johnw> it's in GHC.IO.Handle.Internals
12:42:51 <feryll> By what you told me about lifts I know how to get the result of an IO computation into a WriterT context, but I think I need that result to act as output, not the result
12:43:00 <Walther> zyxoas: http://hackage.haskell.org/package/text-format-0.3.0.7/docs/Data-Text-Format.html maybe combine fixed and shortest?
12:43:09 <johnw> feryll: what's the difference between output and result?
12:43:19 <Walther> first fixed to get n digits, then apply shortest to cut off any possible trailing zeroes
12:43:36 <fosterite> if you define all your structures as fixed points of functors I think you could compose the fixed-point eliminator and the functor eliminators to get a catamorphism
12:43:54 <fosterite> and then you do /something/ for the anamorphisms
12:43:54 <conal> jle`: what do you mean by a "recursive function"? Do you mean one that is recursively definable?
12:43:59 <zyxoas> Walther let me look at that...
12:44:20 <feryll> johnw: As far as I can try to explain, the output of the writer monad is the commentary that goes along the computations, whereas the result is the actual finished computational product
12:44:22 <johnw> fosterite: and functor eliminators are co-algebras, so you can use Cofree to eliminate a structure built up with Free over a functor fixed-point
12:44:54 <jle`> conal: i guess something like fac 0 = 1; fac n = n * fac (n - 1).  or foldr f z [] = []; foldr f z (x:xs) = f x (foldr f z xs)
12:45:00 <johnw> feryll: ah, for Writer w a, you're defining 'w' as output, and 'a' as result
12:45:07 <feryll> Yeah
12:45:35 <conal> jle`: iiuc, all self-recursively definable functions that don't use polymorphic recursion can be written as a hylomorphism. 
12:45:44 <feryll> And that code I pasted fails for not using transformers in some way
12:45:58 <chattered> So the answer is "general recursion"?
12:46:14 <jle`> conal: is there a study on which structures give rise to which classes of such functions?
12:46:27 <jle`> sounds like it might be interesting maybe
12:46:28 <conal> jle`: ... by collecting up the collection of recursive call arguments into a functor.
12:46:30 <chattered> jle`: Have you looked at the bananas literature?
12:47:05 <johnw> jle`: have you seen the paper "Deriving structural hylomorphisms from recursive definitions"?
12:47:11 <jle`> i haven't
12:47:13 <jle`> :o
12:47:18 <conal> jle`: i don't know about such a study, but it sounds like something the oxford folks would know about.
12:47:18 <jle`> i should look at it :)
12:47:25 <johnw> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.2678
12:47:29 <jle`> thank you
12:47:58 <johnw> fosterite: in case you're interested more: http://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/
12:48:10 <chattered> jle`: My understanding is that all of that early stuff in the 90s on blah-morphisms was about classifying recursion schemes.
12:48:13 * hackagebot nurbs 0.1.1.0 - NURBS  https://hackage.haskell.org/package/nurbs-0.1.1.0 (AlexandrRuchkin)
12:48:15 * hackagebot xml-extractors 0.4.0.1 - Extension to the xml package to extract data from parsed xml  https://hackage.haskell.org/package/xml-extractors-0.4.0.1 (holmisen)
12:48:17 <zyxoas> Walther the types don't match up. Each one of those functions returns a Text Builder, so I can't compose them...
12:49:16 <jle`> > hylo (\x -> case x of LNil -> 1; LCons a s -> a * s) (\x -> if x == 1 then LNil else LCons (x - 1) (x - 1))   6
12:49:17 <jle`> wee
12:49:18 <lambdabot>  120
12:49:36 <guillaum1> How do I use a (RandT g Identity MyType) in the context of a (RandT g IO MyType) ?
12:49:37 <Ankhers> feryll: http://lpaste.net/139378
12:49:51 <Ankhers> feryll: Is that what you are expecting?
12:49:53 <jle`> guillaum1: the ideal solution is to never have something of RandT g Identity MyType
12:50:02 <jle`> guillaum1: and always use Monad m => RandT g m MyType
12:50:18 <feryll> Ankhers: Probably, thanks, let me play with things
12:50:29 <jle`> there really isn't any *real* reason why you'd ever need to use RandT g Identity MyType/make one yourself...the only reason you'd have to have one would be if you got it from another library or something
12:50:31 <feryll> Thought that was one of the first things I tried, though
12:50:38 <fosterite> johnw: ah thanks
12:51:27 <guillaum1> jle`: but, using "Monad m => RandT g m MyType" make my function less robust no ? (Because If I'm doing IO inside it, it will typecheck, even if it was not my initial intent ?)
12:51:34 <fosterite> it looks like cofree is the opposite of free by changing * for +, rather than reversing arrows
12:51:39 <jle`> guillaum1: you can't do IO inside a Monad m => RandT g m MyType
12:51:40 <fosterite> unless I've missed something
12:51:42 <jle`> it's not allowed
12:52:22 <jle`> the type of that function is determined by the *caller* of the function, so if the caller wants, say, RandT g Maybe MyType, you have to be able to provide it
12:52:43 <jle`> so if foo :: Monad m => RandT g m MyType, foo has to unify with RandT g Maybe MyType, RandT g Identity MyType, RandT g IO MyType, etc.
12:52:55 <jle`> if the implementation of foo isn't able to unify with *any* Monad, then it won't typecheck
12:52:59 <johnw> fosterite: yep, exactly
12:53:05 <fosterite> jle`: also, the fun thing about "how powerful is _ means of computation" is the answer is usually "too powerful"
12:53:08 <jle`> so it can be seen statically that foo can't do IO
12:53:25 <jle`> s/*any*/*every*
12:53:28 <johnw> fosterite: free builds up trees from sum types, cofree tears down trees using product types, so that there is an evaluator paired to each choice in the sum
12:53:34 <guillaum1> jle`: haaa, ok, I always take the type constraints in the wrong direction ;) Thank you.
12:53:54 <johnw> fosterite: if you think of "if this then that", it becomes clear that for every possible this, there must be a corresponding that
12:54:07 <jle`> no problem :) it's actaully one of the surprising things about typeclasses and haskell's type system that gives you the ability to state such powerful things that you can't in other languages
12:54:12 <johnw> hence, sum elimination by product of eliminators
12:54:17 <jle`> because of parametricity
12:54:20 <fosterite> johnw: so the opposite arrows are still there, but they appear in the use of the types rather than in the definiton?
12:54:47 <johnw> the opposite arrows here are a -> f a and f a -> a
12:55:12 <johnw> we build a free structure using our initial algebra, and then forget the structure using a final coalgebra
12:55:29 <jle`> guillaum1: btw, if you had gotten a RandT g Identity from another library, then the machinery in the mmorph package is usually prescribed to do surgery like this
12:55:45 <jle`> RandT doesn't have an MFunctor instance, though, so you'd have to write one yourself or find an orphan instance, unfortunately
12:55:56 <fosterite> i see, thansks
12:56:01 <jle`> luckily the instance is identical to the instance for StateT, so you don't have to think too much
12:56:11 <johnw> fosterite: and if we do it right, fusion might even elide the whole structure in between :)
12:56:57 <johnw> man, I love how clear lens can make highly stateful code
12:58:07 <bitemyapp> johnw: ain't it grand?
12:58:33 <johnw> bitemyapp: I have some variable liveness algorithms in Coq that, without lens, are complete spaghetti
12:58:59 <Walther> zyxoas: well, i'll be darned :/
12:59:22 <guillaum1> jle`: thank you for the details about mmorph. I was trying to use that package, but I was stuck at the MFunctor issue, now it is more clear.
12:59:46 <Walther> not sure if one could compose a TextBuilder that consists of two TextBuilders and then apply that
13:00:45 <fosterite> johnw: can ghc deforest hylomorphisms on things other than lists?
13:01:21 <johnw> fosterite: if you give enough information and transparency to the inliner, yes
13:01:33 <johnw> I'll have to give it a try on some polymorphic code to see what I can achieve 
13:01:34 <guillaum1> jle`: ok, your answers make me wonder something. why should I put the "Monad m =>" constraint. I saw this as a constraint, but apparently it is exactly the opposite (I mean, it does not typecheck without, and typecheck with, so it appears to release some constraints)
13:01:44 <johnw> but for dealing with concrete hylomorphisms, it shouldn't be too hard
13:02:07 <fosterite> johnw: I will take a look at the ghc inline and rules
13:02:21 <johnw> fosterite: you also need to take simplifier stages into account
13:02:25 <jle`> guillaum1: it's sort of the difference between using Num a => a -> a, and Float -> Float
13:02:41 <jle`> it's a generalization, and it makes it less powerful
13:02:51 <jle`> if you have a Num a => a -> a, you know that you won't ever get a divide by zero error
13:02:58 <jle`> if you had a Float -> Float, you open yourself up to that door
13:03:00 <johnw> in general, the outer code (the compositions) inline at [1], while the inner code (the coalgebra) inlines at [0]
13:03:03 <jle`> um, you open that door up for yourself
13:03:20 <jle`> that's because you know that in a Num a => a -> a, your function can only use things in the Num typeclass
13:03:31 <fosterite> johnw: do stages count up or down?
13:03:41 <jle`> here, Num a => a -> a is a constrained a -> a, but it's also a generalized Float -> Float
13:03:45 <johnw> fosterite: I'm pretty sure they count down, but please see the docs to be sure
13:03:54 <johnw> also, "Secrets of the GHC Inliner", which I haven't read yet
13:04:02 <jle`> guillaum1: Monad m => RandT g m a is a constrained RandT g m a, but it's a generalized RandT g Identity a
13:04:08 <jle`> or a generalized RandT g IO a
13:04:22 <jle`> *more general in comparison to
13:04:57 <johnw> fosterite: you can see a concrete case of this in https://github.com/jwiegley/fusion
13:05:12 <johnw> however, this does not use Free/Cofree explicitly (yet)
13:07:18 <fosterite> johnw: thanks, this is interesting
13:07:41 <guillaum1> jle`: I now understand the difference between "Monad m => RandT g m a" and "RandT g Identity a", but why can't I write "RandT g m a" without the "Monad m" constraint. By making this less constrained, it is more generic no ? (But by writing this sentence, I know realise that it must also work for all type, which is difficult, because it may exists a type (such as Int), which does not provide the monad in
13:07:47 <guillaum1> terface.
13:07:52 <macrover> how can I map function f with 3 parameters a, b, and c over a list of values that I want to use for b in the function? map (f a b) [c1,c2,c3] for c values but I want b values
13:08:04 <johnw> as long as you write your evaluator in completely non-recursive pieces, where the recursion is applied externally, and you inform the inliner sufficiently, then you can eliminate the structures
13:08:17 <guillaum1> jle`: damned, REVELATION, thank you...
13:11:19 <glguy> macrover: map (\b -> f a b c)
13:12:46 <macrover> glguy thx
13:13:14 * hackagebot keycode 0.1.1 - Maps web browser keycodes to their corresponding keyboard keys  https://hackage.haskell.org/package/keycode-0.1.1 (ryanglscott)
13:19:24 <zyxoas> Walther I'll just to render the string, then chop off the zeros myself. reverse . dropWhile == 0 . revers
13:21:27 <Walther> zyxoas: yeah :/ a bit ugly, but Works(tm)
13:33:48 <rhovland> I'm getting a panic in ghci saying the 'impossible' happened when I load my code... code compiles fine with ghc, though
13:38:26 <lpaste_> serendependy pasted “Under” at http://lpaste.net/139380
13:39:46 <serendependy> My first time playing around with "serious" language extensions. Trying to right and idiom for "under" (f . g . f_inv) and getting complaints from the instance search.
13:41:17 <serendependy> Before I added the functional dependency, the type-checker complained that my use of ```under Ureverse``` didn't have a suitable instance (I believe because FlexibleInstances makes [a] -> [a] not match with [Int] -> [Int] in an instance declaration)
13:41:52 <serendependy> s/right/write/
13:43:35 <bennofs> serendependy: problem is: you said that t implies a, but what a does Ureverse imply?
13:44:28 <serendependy> Ureverse should imply forall a. [a] -> [a] (?)
13:45:08 <bennofs> serendependy: g
13:45:09 <serendependy> I can get it to work by saying t a -> b but my intuition tells me this isn't exactly what I want
13:45:13 <bennofs> serendependy: that's not a single type
13:45:49 <serendependy> bennofs, Yeah I thought that might be it.
13:46:12 <bennofs> serendependy: you probably want something like data Ureverse a = Ureverse and then make an instance for (Ureverse a) [a] [a] (not sure how well that works with inference)
13:47:03 <serendependy> bennofs, Ah good point! It may require an explicit type annotation at the point of use but that's ok
13:47:24 <ajf> can you pattern match against some variable?
13:47:45 <bennofs> > reverse $ under reversed (++ "world") " olleh" -- lens already does this :)
13:47:46 <ajf> (I think I've asked this more than once before and I think the answer is "no", but...)
13:47:47 <lambdabot>  "hello world"
13:47:57 <bennofs> serendependy: I think it will even work without explicit type sigs in some cases
13:48:14 <bennofs> serendependy: the Ureversed with determine the instance, and the a will be determined by the list
13:48:41 <serendependy> bennofs, Yes, it works even without an annotation. Very nice!
13:48:43 <bergmark> ajf: i'm inclined to say yes but i'm not sure i understand what you mean
13:49:15 <serendependy> > under reversed (++ " world") " olleh"
13:49:17 <lambdabot>  "dlrow  olleh"
13:49:33 <serendependy> > @type reversed
13:49:34 <lambdabot>  <hint>:1:1: parse error on input ‘@’
13:49:38 <ajf> bergmark: I want to use the value of a certain variable as the pattern to match against
13:49:40 <serendependy> @type reversed
13:49:41 <lambdabot> (Functor f, Profunctor p, Reversing a) => p a (f a) -> p a (f a)
13:49:50 <serendependy> @type under
13:49:51 <lambdabot> AnIso s t a b -> (t -> s) -> b -> a
13:49:53 <bennofs> serendependy: reversed :: Iso' [a] [a]
13:49:57 <bergmark> > let x = 1 in case x of 1 -> "yay"
13:49:59 <lambdabot>  "yay"
13:50:34 <bennofs> serendependy: under :: Iso' a b -> (a -> a) -> (b -> b)   (simplied types)
13:50:48 <serendependy> I guess this means I should check out the lens libraries
13:51:09 <shachaf> bennofs: In my opinion the ' types are more confusing.
13:51:35 <shachaf> When I deal with Lens' s a I can hardly tell which type variable is which.
13:52:05 <bennofs> shachaf: why is Lens s t a b better then? just because you're more used to it?
13:52:22 <shachaf> It's clear which variables are covariant and which are contravariant.
13:52:27 <bergmark> ajf: it sounds like you want equality, not a pattern match
13:52:33 <jle`> from my point of view the jedi are evil
13:52:48 <shachaf> fmap :: (a -> a) -> f a -> f a is confusing.
13:52:51 <bennofs> shachaf: how's that clear from just Lens s t a b ?
13:52:59 <shachaf> It looks just like contramap :: (a -> a) -> f a -> f a
13:53:13 <shachaf> bennofs: I don't care what you call the letters (well, I do, but not as much), just that you use different letters.
13:53:20 <ajf> bergmark: well, I'd rather not split this into two parts. Oh well.
13:53:35 <bennofs> shachaf: yeah, I agree it might make sense for view / over / under, but for induvidual lenses?
13:53:59 <bennofs> shachaf: there, you don't have anything else, except Lens' s a / Lens s t a b, so you cannot see the variance
13:54:00 <shachaf> Well, if your lens is Lens Int Int Bool Bool, sure, Lens' Int Bool is shorter.
13:54:33 <jle`> under :: Iso s t a b -> (t -> s) -> (b -> a)   definitely looks a little more understandable what's going on to me
13:54:53 <bennofs> right, it makes sense for under / over
13:55:22 <jle`> but i guess you had already wrote yourself into a box when you introduced reversed using Iso'
13:57:15 <serendependy> So might another name for Iso' be EndoIso?
13:57:34 <shachaf> Not really.
13:57:37 <serendependy> Hmm no, nvm
13:57:39 <shachaf> Iso s t a b = (s -> a, b -> t)
13:57:48 <shachaf> Iso' s a = Iso s s a a = (s -> a, a -> s)
13:58:27 <ajf> how do I match a non-empty list?
13:58:57 <jle`> (x:xs) -> ..., ?
13:58:59 <serendependy> Iso' just moves between the two types of the isomorphism, Iso allows moving between two other types.
13:59:11 <ajf> jle`: yeah... I realised that just after I asked
14:00:32 <shachaf> s and t are related, and a and b are related.
14:00:38 <shachaf> You can think of it as a natural isomorphism.
14:01:09 <shachaf> Iso o i = (o ~> i, i ~> o)
14:02:22 * serendependy searches wikipedia for natural transformation
14:03:27 <shachaf> I.e. Iso o i = (forall a. o a -> i a, forall a. i a -> o a)
14:04:14 <serendependy> Ah ok
14:05:26 <shachaf> Naturality is so good.
14:15:00 <fr33domlover> What kind of limitation do I have when I use FunctionDependencies, e.g. mtl? Does it just mean I can't have more than one StateT (or other MT) instance used in the same module?
14:15:12 <fr33domlover> *FunctionalDependencies
14:15:44 <Gurkenglas> "MonadReader s m | m -> s" tells the compiler is that each m only is allowed to have one s
14:16:04 <Sindriava> How would I optimise this? http://lpaste.net/7777571055861760000
14:16:34 <Gurkenglas> So when the class has a function of type for example m -> s, then you don't have to say in the code which type the s is because theres only one possibility
14:16:56 <scshunt> it's similar to using associated types
14:16:59 <Gurkenglas> (As you have to do for read for example, as read is Read a => String -> a)
14:17:26 <fr33domlover> Gurkenglas, thanks. Is that why mtl uses this extension?
14:17:57 <Gurkenglas> Probably, I don't know. Ask its writer, ekmett.
14:18:16 <Tuplanolla> Rewrite (++) with (:) and length with recursion to see the problem, Sindriava. Consider using Data.Sequence instead of a list.
14:18:24 <Gurkenglas> Sindriava, optimizing performance or elegance?
14:19:06 <Sindriava> Tuplanolla: I'm well aware of the problem, which is why I'm asking. That append is *craaazy* expensive :(
14:19:19 <Sindriava> Gurkenglas: Performance over elegance, but preferably both
14:19:27 <Sindriava> Tuplanolla: I'll take a look at Sequence, thanks :)
14:21:13 <Sindriava> I basically want a constant time concat for those arrays.
14:22:31 <Gurkenglas> (Oh, he isn't around.)
14:28:02 <bennofs> fr33domlover: yes it is
14:28:18 <bennofs> fr33domlover: you'd have to specify the type of each ask otherwise
14:30:29 <fr33domlover> bennofs, would it not deduce the type if after the 'ask' I'd use something with the data? e.g. do { env <- ask; f env }
14:30:44 <fr33domlover> *do something
14:31:20 <bennofs> fr33domlover: yeah, but it breaks down pretty soon as you start to use classes.  For example, I you have   f :: Num a => a -> a
14:31:23 <fr33domlover> (assuming the type of f explicity specified the argument type)
14:31:46 <fr33domlover> bennofs, I noticed issues with ambiguous instances all over my code indeed :P
14:32:01 <fr33domlover> it suggested to defer resolution to use locations
14:32:27 <fr33domlover> and them I somehow failed to make that work, maybe because I understood types less when I tried that
14:38:19 * hackagebot dtab 1.0.0.1 - Harmonix (Guitar Hero, Rock Band) DTA/DTB metadata library  https://hackage.haskell.org/package/dtab-1.0.0.1 (mtolly)
14:43:19 * hackagebot conduit-audio 0.2 - Combinators to efficiently slice and dice audio streams  https://hackage.haskell.org/package/conduit-audio-0.2 (mtolly)
14:48:19 * hackagebot cabal-bounds 1.0.1 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  https://hackage.haskell.org/package/cabal-bounds-1.0.1 (DanielTrstenjak)
14:55:16 <jmcarthur> does anybody actually use the rich exceptions enabled by Control.Exception? does anybody actually use rich error types with Either, etc.? at work and at home, i rarely use exceptions and error types for anything other than error reporting, which just means i apply show to it at some point or throw it without catching it.
14:55:26 <jmcarthur> by "use" i guess i mean "pattern match"
14:57:25 <jmcarthur> reason: i ended up making this module to encourage my usual method of error handling, which is to just have opaque errors that can only be used for printing, logging, failing, and to tag them with useful diagnostic information while unwinding the stack.
14:57:53 <jmcarthur> and i wonder if it's worth polishing into a library (ugh, another error handling library) or just keeping to myself (ugh, i'll be the only one using it)
14:59:38 <jmcarthur> and a related question: does this approach exist in library form already?
15:00:37 <Tuplanolla> Personally I use Either when I want to catch exceptions outside the IO monad and Control.Exception when I want to catch things. I hardly ever throw with anything but error.
15:00:59 <jmcarthur> i think my question is more about what you do when you catch it
15:01:13 <jmcarthur> do you pattern match on it and actually have different logic depending on the exception?
15:01:34 <Tuplanolla> I only catch things I'm sure I can handle and quite specifically at that.
15:02:22 <jmcarthur> i guess i do too, but i just don't consider them "exceptions" in that case
15:02:48 <Tuplanolla> That's a good sign, no?
15:03:19 <jmcarthur> and further i guess these are just examples of things i would not use this module for
15:03:20 <shachaf> jmcarthur: That sounds a bit like the Go approach to errors.
15:03:29 * jmcarthur looks up the Go approach
15:03:33 <codedmart> Any suggestion on how I could change these instances to not have to use overlapping https://github.com/haskell-servant/servant/blob/codedmart/rawChanges/servant-server/src/Servant/Server/Internal/Enter.hs#L60-L72?
15:03:34 <shachaf> (Except they use products instead of sums for some reason.)
15:04:05 <jmcarthur> familiarity? :\
15:04:34 <codedmart> The overlapping instances in this case is not working on 7.8.
15:09:57 <Tuplanolla> There's really no elegant solution to the exception problem. Anything can go wrong at anytime.
15:11:49 <fr33domlover> looking for advice: I'm writing a library for application settings. Considering to make it monad based. How likely is a program to have settings passed as function args without using a monad for this? such as IO or StateT
15:12:31 <fr33domlover> if I make the lib monad-based, then it excludes these cases but features like callbacks become much easier
15:12:34 <Tuplanolla> You can't event catch all exceptions thrown by the RTS. If an implicit write(2) fails with EIO, you get an exception that's higher in the hierarchy than the alleged root called SomeException.
15:12:56 <Tuplanolla> It shows up as "Main: <stderr>: hPutChar: hardware fault (Input/output error)".
15:13:21 * hackagebot rethinkdb 2.1.0.0 - A driver for RethinkDB 2.0  https://hackage.haskell.org/package/rethinkdb-2.1.0.0 (codedmart)
15:15:21 <sbrg> uh, since when I just automatically run a writer? In this case, it's WriterT over list.. maybe that is the reason? 
15:15:36 <sbrg> run a writer as in ghci and just by printing it with `print`
15:23:21 * hackagebot rethinkdb 2.1.0.1 - A driver for RethinkDB 2.1  https://hackage.haskell.org/package/rethinkdb-2.1.0.1 (codedmart)
15:23:22 <lambdafan> is there a function with type f (a -> b) -> a -> f b
15:23:31 <lambdafan> almost <*>
15:24:25 <fosterite> lambdafan: no, sometimes people define (??) at that type but there's no standard
15:24:44 <shachaf> lens calls it (??)
15:24:57 <slack1256> > :t (\f a -> f <*> pure a)
15:24:58 <lambdabot>  <hint>:1:1: parse error on input ‘:’
15:25:00 <shachaf> flip is a special case of it.
15:25:07 <shachaf> It's a special case of distribute.
15:25:36 <scshunt> !hayoo f (a -> b) -> a -> f b
15:25:40 <scshunt> @hayoo f (a -> b) -> a -> f b
15:25:40 <lambdabot> Unknown command, try @list
15:25:59 <arkeet> :t (??)
15:26:00 <lambdabot> Functor f => f (a -> b) -> a -> f b
15:26:01 <slack1256> @type (f <*>) . pure
15:26:01 <L8D> :t (\f a -> f <*> pure a)
15:26:02 <lambdabot> (Applicative f, FromExpr (f (a -> b))) => a -> f b
15:26:03 <lambdabot> Applicative f => f (a -> b) -> a -> f b
15:26:12 <slack1256> @type (f <*>) . pure
15:26:13 <lambdabot> (Applicative f, FromExpr (f (a -> b))) => a -> f b
15:26:24 <arkeet> :t \f a -> fmap ($ a) f
15:26:25 <lambdabot> Functor f => f (a -> b) -> a -> f b
15:26:31 <lambdafan> nice!
15:26:53 <haskell712> is there a better way to add two tuples together other than add (x,y) (x',y') = (x+x',y+y') $
15:26:57 <haskell712> *?
15:26:58 <slack1256> that one is simpler
15:27:04 <slack1256> @type (+++)
15:27:05 <lambdafan> what package is ?? in , lens?
15:27:05 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
15:27:12 <slack1256> @type (***)
15:27:12 <arkeet> yes
15:27:13 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
15:27:38 <arkeet> haskell712: not really.
15:27:42 <L8D> haskell712: not really.
15:27:46 <edwardk> lambdafan: yes
15:27:49 <arkeet> haskell712: if you were using some type of homogeneous pairs (e.g. V2 from linear) you could liftA2 (+)
15:27:58 <slack1256> you can do that with contravariant?
15:28:09 <slack1256> or bifunctor
15:28:31 <lambdafan> edwardk: I just looked in Control.Lens, and not there. It's a huge package. Where can I find it?
15:28:38 <arkeet> lambdafan: use the index
15:28:46 <lambdafan> ah right
15:28:48 <haskell712> mm okay, thanks
15:29:01 <arkeet> haskell712: hm
15:29:06 <lambdafan> perfect
15:29:07 <arkeet> if you really wanted to use tuples direclty
15:29:10 <arkeet> there's Biapplicative
15:29:13 <arkeet> :t biliftA2
15:29:14 <lambdabot>     Not in scope: ‘biliftA2’
15:29:14 <lambdabot>     Perhaps you meant ‘liftA2’ (imported from Control.Applicative)
15:29:22 <arkeet> @let import Data.Biapplicative
15:29:24 <lambdabot>  Defined.
15:29:27 <arkeet> :t biliftA2 (+) (+)
15:29:28 <lambdabot> (Num c, Num f, Biapplicative w) => w c f -> w c f -> w c f
15:29:38 <arkeet> > biliftA2 (+) (+) (1,2) (10,20)
15:29:39 <lambdabot>  (11,22)
15:30:02 <Tuplanolla> > join biliftA2 (+) (1, 2) (10, 20)
15:30:04 <lambdabot>  (11,22)
15:30:21 <haskell712> well, I'm assured that the type of the tuple is always (a,a)
15:30:25 <haskell712> not (a,b)
15:30:37 <arkeet> sure
15:31:18 <arkeet> but the kind of (,) is a bit inconvenient for that
15:31:43 <lambdafan> I'm going to end up using lenses anyway, may as well install the whole thing now
15:32:03 <Tuplanolla> Does anyone actually use Data.UniformPair?
15:32:39 <arkeet> only one package depends on it
15:32:47 <shachaf> It's a useful type, but it seems like a verbose name.
15:32:49 <arkeet> and that's the package that depends on everything.
15:32:51 <Hafydd> UniformPear
15:33:12 <slack1256> And UniformPear is like a burrito
15:33:18 <slack1256> *an
15:33:52 <Tuplanolla> It seems like such a nice type.
15:40:31 <JagaJaga> @hoogle Parser (Maybe Object) -> Text -> Parser (Maybe a) +aeson
15:40:32 <lambdabot> Could not find some databases: aeson
15:40:32 <lambdabot> Searching in:
15:40:32 <lambdabot>   .
15:41:21 <JagaJaga> How can I do (.:) using aeson after (.:?)?
15:43:22 * hackagebot utf8-string 1.0.1 - Support for reading and writing UTF8 Strings  https://hackage.haskell.org/package/utf8-string-1.0.1 (EricMertens)
15:43:24 * hackagebot transient 0.1.0.1 - A monad for extensible effects and primitives for unrestricted composability of applications  https://hackage.haskell.org/package/transient-0.1.0.1 (AlbertoCorona)
15:48:15 <haskell712> :t (.:)
15:48:16 <lambdabot>     Not in scope: ‘.:’
15:48:16 <lambdabot>     Perhaps you meant one of these:
15:48:16 <lambdabot>       ‘.’ (imported from Data.Function),
15:49:32 <bergmark> JagaJaga: documentation hints (.!=) Helper for use in combination with .:? to provide default values for optional JSON object fields.
15:53:23 * hackagebot base-noprelude 4.8.1.0 - "base" package sans "Prelude" module  https://hackage.haskell.org/package/base-noprelude-4.8.1.0 (HerbertValerioRiedel)
16:23:25 * hackagebot HTF 0.13.1.0 - The Haskell Test Framework  https://hackage.haskell.org/package/HTF-0.13.1.0 (StefanWehr)
16:33:25 * hackagebot nylas 0.1.0 - Client for the Nylas API  https://hackage.haskell.org/package/nylas-0.1.0 (bts)
16:35:13 <slack1256> Okasaki seems to hard for me (no CS background). Ideally I would like to learn (ephemeral) data structures first with a FP lang (ML, even lisp) is there an standard book on it?
16:35:17 <slack1256> *too
16:43:26 * hackagebot hakyll-sass 0.1.0 - Hakyll SASS compiler over hsass  https://hackage.haskell.org/package/hakyll-sass-0.1.0 (meoblast001)
16:43:28 * hackagebot xcffib 0.3.6 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.3.6 (TychoAndersen)
16:49:56 <Welkin> :t sepBy
16:49:58 <lambdabot> Eq a => [a] -> [a] -> [[a]]
16:50:16 <Welkin> :t Data.Attoparsec.ByteString.Char8.sepBy
16:50:17 <lambdabot> Alternative f => f a -> f s -> f [a]
16:51:00 <SrPx> How do I create an instance of a `class Foo x where` for n-tuples?
16:51:19 <Welkin> > Data.Attoparsec.ByteString.parse Data.Attoparsec.ByteString.Char8.sepBy Data.Attoparsec.ByteString.Char8.digit (Data.Attoparsec.ByteString.Char8.char ',') "1,2,3"
16:51:21 <lambdabot>  Not in scope: ‘Data.Attoparsec.ByteString.parse’    Not in scope: ‘Data.Atto...
16:51:25 <SrPx> `instance Foo (a,a) where ...` doesn't work
16:51:59 <slack1256> if you represent n-tuples as nested tuples maybe you can
16:52:08 <Welkin> why won't sepBy in attoparsec work? O_o
16:52:30 <Welkin> it only ever parses the first occurence, then it fails
16:54:04 <Welkin> oh, actually
16:54:09 <Welkin> it is now failing completely
16:55:43 <Welkin> > parse (sepBy digit (char ',')) "1,2,3"
16:55:44 <lambdabot>  Not in scope: ‘parse’Not in scope: ‘digit’
16:58:15 <slack1256> @let import Data.Attoparsec
16:58:17 <lambdabot>  .L.hs:65:1:
16:58:17 <lambdabot>      Data.Attoparsec: Can't be safely imported!
16:58:17 <lambdabot>      The package (attoparsec-0.13.0.1) the module resides in isn't trusted.
17:01:48 <SrPx> slack1256: not sure what you mean
17:04:31 <Luke> anyone know how to get bits-extras working on OSX - I'm getting a gcc_s linker error
17:09:34 <geekosaur> Luke: "Issues: A GCC-provided library, libgcc_s, is dynamically linked to provide software fallbacks on architectures without instructions corresponding to specific operations. This is currently only expected to work on Linux systems, and even there can lead to issues with GHCi's custom linker"
17:09:51 <Welkin> geekosaur: know anything about Attoparsec?
17:09:58 <geekosaur> Welkin, sorry, no
17:10:12 <Welkin> it doesn't seem to work like Parsec
17:10:16 <arahael> So, I was (again) looking at platform support in Haskell.
17:10:42 <Luke> geekosaur: ah I read that as only needed on linux not only working on linux - ty
17:10:56 <prsteele> is there a consensus on prefixing record constructors? E.g. data Foo = Foo { bar :: Int}, data Foo = Foo {_bar :: Int}, data Foo = Foo {unBar :: int} ?
17:10:57 <arahael> It seems that outside of linux, only 32-bit windows (with bitrotten .dll's) are considered a Tier1 platform?
17:11:05 <geekosaur> recent OS X doesn't even use gcc, so libgcc_s won't be there
17:11:13 <Luke> geekosaur: yeah 
17:11:15 <johnw> Welkin: attoparsec always backtracks on failure, btw
17:11:19 <Luke> geekosaur: so what do I need to do to make it work?
17:11:25 <Welkin> johnw: yes, but why is it always failing?
17:11:37 <Welkin> parse (sepBy digit (char ',')) "1,2,3" -- this doesn't work
17:11:47 <arahael> https://ghc.haskell.org/trac/ghc/wiki/Platforms <-- Doesn't inspire me with confidence as a programmer wishing to write portable applications.
17:11:47 <johnw> one sec
17:11:47 <geekosaur> Luke, I would have to study the source to find out what uit's trying to do with the library
17:12:04 <Luke> yeah =/
17:12:11 <geekosaur> although I note that it likes to the bits-atomic package that provides the parts that don't require libgcc_s
17:12:20 <geekosaur> s/likes/links/
17:12:34 <johnw> Welkin: I don't see failure, I get a partial result
17:12:59 <geekosaur> oh, maybe not general enough
17:13:06 <exio4> if you do parseOnly you get what he might have wanted
17:13:06 <Welkin> it should be a complete result
17:13:20 <Luke> geekosaur: yeah depends on what it's using
17:13:20 <johnw> it works with parseOnly
17:13:24 <Welkin> > parseOnly (sepBy digit (char ',')) "1,2,3"
17:13:26 <lambdabot>  Not in scope: ‘parseOnly’Not in scope: ‘digit’
17:13:34 <geekosaur> mm, wait
17:14:33 <Ankhers> arahael: "Please be aware that this page is highly unmaintained"
17:14:40 <Welkin> johnw: why can't I use parse?
17:14:47 <Welkin> it should produce `Done ...`
17:14:48 <johnw> you can, it returns Partial
17:14:52 <johnw> you aren't parsing EOF
17:14:55 <johnw> so the EOF is being left there
17:15:04 <Welkin> ah
17:15:09 <geekosaur> oh, no, I gues sof those only popCount is in recent Data.Bits
17:15:22 <arahael> Ankhers: Where can I find an up-to-date list?
17:16:41 <geekosaur> waaaaaait
17:16:53 <Ankhers> arahael: I'm not entirely sure. Maybe message the GHC mailing list? Or maybe on #ghc.
17:17:10 <geekosaur> my 10.9 box has /usr/lib/libgcc_s.1.dylib
17:17:25 <geekosaur> I bet that package is doing something silly like explicitly opening libgcc_s.so
17:18:38 <geekosaur> oh, no, I understood dynamically as meaning runtime dlopen.
17:18:58 <arahael> Ankhers: I didn't realise there was a #ghc, I'll have eto ask them.
17:19:24 <Ankhers> arahael: I have no idea how active it is there.
17:19:24 <geekosaur> Luke: I think you can cheat and symlink the highest numbered /usr/lib/libgcc_s.*.dylib to /usr/lib/libgcc_s.dylib
17:19:33 <geekosaur> and hope the functions provided are roughly compatible
17:19:36 <Luke> haha
17:19:39 <Luke> ok thanks
17:20:01 <Welkin> wow
17:20:06 <Welkin> I can't even get my parsers to work
17:20:33 <johnw> show code
17:20:55 <arahael> Ankhers: I'll idle there for the moment (They're not as active as people are here, and I now have to go in roughly 15 min)
17:21:19 <Ankhers> arahael: The mailing list may be a better option in that case.
17:21:36 <Ankhers> arahael: Either way, I hope you find the information you are looking for.
17:21:38 <Welkin> Left "not enough input"
17:21:46 <arahael> Ankhers: Despite my pessimism, my _feeling_ is that platform support is pretty good, particularly if ghcjs is also a consideration, the main sticking points are handheld devices (eg, phones)
17:21:50 <Welkin> I get that when I add a newline and try to parse the newline
17:21:55 <Welkin> parser <* endOfLine
17:22:10 <arahael> Ankhers: As everything else would surely have decent performance out of ghcjs.
17:22:16 <johnw> EOF is not endOfLine
17:22:24 <Welkin> I added a newline
17:22:31 <johnw> ah
17:22:37 <Welkin> parseOnly (text `sepBy'` (char ',') <* endOfLine) "hello,world,!\n"
17:22:50 <arahael> Ankhers: Somehow, mailing lsits seems _formal_ to me. :)
17:22:51 <johnw> I think <* is binding tighter than you think
17:22:57 <Welkin> er, where text = T.pack . many1' anyChar
17:23:28 * hackagebot hbro 1.5.0.0 - Minimal extensible web-browser  https://hackage.haskell.org/package/hbro-1.5.0.0 (koral)
17:23:33 <Ankhers> arahael: Fair enough. Just as a heads up though, last I heard, ghcjs was still producing rather large output files. But this is a known issue that is being worked on.
17:23:42 <Welkin> doesn't seem to make a difference adding parens around the parser before <*
17:23:58 <johnw> hmm
17:24:01 <arahael> Ankhers: Only an issue for websites, really.
17:24:06 <Ankhers> Yes.
17:24:16 <johnw> Welkin, it works here
17:24:19 <johnw> Data.Attoparsec.Text.parseOnly (sepBy digit (char ',') <* endOfLine) "1,2,3\n"
17:24:45 <johnw> many1' anyChar is going to consume everything, including the commas and the newline
17:25:06 <Welkin> mine works without newline
17:25:13 <Welkin> λ: parseOnly (text `sepBy'` (char ',')) "hello,world,!"
17:25:14 <Welkin> Right ["hello,world,!"]
17:25:23 <johnw> right
17:25:26 <johnw> it ate the commas
17:25:30 <Welkin> oh
17:25:33 <Welkin> I didnt notice
17:28:28 * hackagebot hbro-contrib 1.5.0.0 - Third-party extensions to hbro.  https://hackage.haskell.org/package/hbro-contrib-1.5.0.0 (koral)
17:28:53 <Welkin> hmm
17:29:08 <Welkin> I could use takeTill (/= ',')
17:29:26 <johnw> and /= \n
17:29:30 <Welkin> that is the same as `many anyChar` but excluding ','
17:29:31 <johnw> what is it you're trying to parse?
17:29:34 <Welkin> I suppose
17:29:47 <Welkin> some csv data
17:30:00 <johnw> and you don't want to use an existing library like cassava?
17:30:19 <Welkin> perhaps
17:30:33 <Welkin> I wanted to learn attoparsec
17:30:33 <johnw> csv has several more wrinkles  to it
17:30:36 <Welkin> since I only know parsec
17:30:37 <johnw> escaping commas, etc.
17:30:48 <johnw> quoted fields
17:30:52 <arahael> Newlines.
17:31:02 <exio4> it's not just takeTill (/= ','), you need to handle lots of annoying stuff with CSV
17:31:07 <exio4> oh, johnw already said that
17:31:23 <arahael> There's even conflicting csv formats, iirc.
17:31:47 <johnw> and if you're using attoparsec for speed, then using cassava will give you speed; if you're using it to learn, I'd pick another example, like TCP headers or something
17:32:19 <Welkin> oh boy
17:32:21 <Welkin> :)
17:32:23 <arahael> Well, parsing csv's a good way to learn, honestly.
17:32:24 <Welkin> thanks johnw 
17:32:34 <arahael> Just don't use it for production code - use a library instead.
17:32:42 <Welkin> arahael: I had lots of fun using parsec to implement a scheme interpreter
17:32:49 <Welkin> csv is a lot more boring, haha
17:32:51 <arahael> Welkin: Nice.
17:32:58 <arahael> Welkin: And indeed it is.
17:33:03 <johnw> last time I truly needed attoparsec was for parsing SVN dump files
17:33:11 <arahael> johnw: You poor man.
17:33:18 * arahael heads off.
17:33:29 * hackagebot cabal-debian 4.31.3 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.31.3 (DavidFox)
17:44:14 <cads> hey guys, quick question
17:44:36 <cads> I'm going to be doing a .net project soon, is there any way I can write in haskell and transpile?
17:45:06 <johnw> cads: not in any way that your team mates will appreciate, I fear
17:45:09 <johnw> if at all
17:45:11 <Zekka> cads: I don't *think* there's a good .net backend bu it's possible my knowledge is not up to date
17:45:22 <cads> I've found hs-dotnet but that's not what I need
17:45:27 <Ankhers> cads: I've heard F# isn't terrible.
17:45:46 <cads> "not terrible" doesn't suddenly mean I know how to use it :)
17:45:47 <Zekka> There's a "basically Haskell, but JVM" called Frege, but I don't know one for .NET
17:45:49 <cads> but I should try it
17:45:56 <barrucadu> Does anyone know if there is a type anywhere like Maybe, but where (<>) is Nothing unless *both* of the operands are Just?
17:46:07 <barrucadu> I've just defined it myself, but I feel like someone must have done it elsewhere
17:46:26 <cads> Zekka: that was going to be my next question - are there any cleaner looking FP languages on .net?
17:46:39 <cads> I know there are n! such langauges on jvm :)
17:46:40 <talios> Zekka - be a masochist and go Frege->ikvm :)
17:47:10 <talios> cads - F# would be your best bet ( OCaml/ML like )
17:48:20 <nolrai66> > [Just 1 >> Just 2, Just 1 >> Nothing, Nothing >> Just 2]
17:48:21 <lambdabot>  [Just 2,Nothing,Nothing]
17:48:32 <nolrai66> barrucadu: ^^^
17:48:54 <barrucadu> nolrai66: That's got the right failing behaviour, but doesn't monoidally combine the values in the Just >> Just case
17:49:15 <MarcelineVQ> what is >> here?
17:49:36 <barrucadu> x >> y = x >>= \_ -> y
17:49:42 <Welkin> hello MarcelineVQ 
17:49:52 <MarcelineVQ> oh that's right it's the base for >>=
17:50:04 <Welkin> MarcelineVQ: bind that ignores the argument
17:51:09 <dramforever> um...shouldn't we be supposed to be using *> instead these days?
17:51:33 <Welkin> sure
17:51:36 <MarcelineVQ> there's so many operators in haskell :X
17:51:37 <Welkin> for applicatives
17:51:58 <Welkin> MarcelineVQ: it's actually great once you learn them
17:52:02 <Welkin> there aren't *that* many
17:52:22 <dramforever> MarcelineVQ: don't worry because they are just functions
17:52:23 <MarcelineVQ> is *> differant than <*>
17:52:29 <Welkin> yes
17:52:45 <Welkin> *> ignore the first argument and produces the second
17:52:46 <dramforever> if you understand functions, and you understand the syntax, then those operators will make sense to you
17:52:55 <Welkin> it is a sequence operation like >>
17:53:00 <dramforever> *> is supposed to be the same as >>
17:53:23 <Welkin> MarcelineVQ: geus what <* does? :D
17:53:26 <Welkin> guess*
17:53:47 <MarcelineVQ> What makes it different? I ask because if it's supposed to be the same why have both. Is it because then <* has a dual?
17:54:02 <Welkin> <* is defined for Applicative
17:54:07 <dramforever> MarcelineVQ: historical reasons
17:54:27 <dramforever> we didn't have those applicative stuff back then
17:54:27 <MarcelineVQ> @src (*>)
17:54:28 <lambdabot> (*>) = liftA2 (const id)
17:54:38 <Welkin> in ghc 7.10+, all Monads are Applicatives
17:54:51 <Ankhers> @src (<*)
17:54:51 <lambdabot> (<*) = liftA2 const
17:54:52 <Welkin> so you can use either
17:55:16 <Welkin> although, most monads have applicative instances anyway
17:56:05 <dramforever> Welkin: from ghc 7.10 onwards, ALL monads have applicative instances
17:56:18 <dramforever> i.e. they ftfy
17:56:18 <Welkin> dramforever: I know
17:56:34 <dramforever> um...bad joke
17:56:35 <Welkin> I'm using 7.8.4 still
18:08:51 <cads> hey could I push hask to llvm, then  host llvm on dotnet?
18:08:57 <cads> am I just spewing gibberish here?
18:09:02 <cads> btw: http://lists.cs.uiuc.edu/pipermail/llvmdev/2015-April/084459.html
18:10:49 * mjrosenb clarifies
18:11:08 <mjrosenb> if I have data Poly a = Poly { _a :: a, _b :: a, _c :: Int }
18:11:30 <mjrosenb> can I write a function with type Poly Int -> Poly Bool using lenses and (==4)?
18:13:47 <edtoast_46> hi
18:14:12 <LokiSnake> 👋🏻
18:14:32 <edtoast_46> please try joining #edtoast .I would greatly appreciate it
18:16:42 <mjrosenb> that was some strange spam.
18:19:25 <fosterite> i wonder if he has 46 bots
18:22:42 <Welkin> cassava is amazing o.o
18:27:37 <jle`> mjrosenb: yeah
18:28:15 <jle`> ah hm
18:29:18 <jle`> it might have to be a Traversal, depending on what behavior you want
18:29:33 <jle`> you can write one with an unlawful lens though too
18:29:41 <jle`> if you want to live on that side of the law
18:30:01 <edwardk> mjrosenb: sort of.
18:30:22 <dramforever> fmap?
18:30:53 <edwardk> mjrosenb: if you use makeLenses it should build lenses for a and b, but the problem is they can't change the type you have there, right?
18:31:15 <edwardk> so one way to do this is to define an iso and a class by hand
18:31:27 <mniip> if you want to change the type of the structure it better be a traversal
18:31:51 <edwardk> data ExposedPoly a a' = ExposedPoly { _a :: a, _b :: a', _c :: Int }
18:32:00 <jle`> badPolyLens1 f (Poly x y z) = (\q -> Poly q q z) <$> f z
18:32:02 <edwardk> now you can make an isomorphism between ExposedPoly a a and Poly a
18:32:26 <mniip> jle`, f z?
18:32:41 <mniip> shouldn't that be f x-and-simultaneously-y
18:32:41 <mjrosenb> jle`: that is *awful* :-p
18:32:51 <jle`> mniip: it's Poly Int -> Poly Bool
18:32:56 <edwardk> then you can do things like myPoly & _Exposed %~ \x -> x & a %~ (== 4) & b %~ (==) 4
18:32:56 <jle`> so
18:33:06 <edwardk> but here i'd say 'make a traversal'
18:33:08 <edwardk> for this problem
18:33:16 <mniip> edwardk, please don't paste perl in here D:
18:33:35 <jle`> badPolyLens1 :: Lens Int b (Poly a) (Poly b)
18:33:40 <jle`> ^^ mniip 
18:33:47 <mniip> jle`, ohh that
18:33:47 <jle`> oh no that's backwards
18:33:48 <Welkin> perl
18:33:56 <mniip> okay then
18:33:58 <jle`> badPolyLens1 :: Lens (Poly a) (Poly b) Int b
18:34:12 <edwardk> traverse :: Traversal (Poly a) (Poly b) a b
18:34:20 <jle`> then you can do over badPolyLens1 (== 4) :: Poly Int -> Poly Bool
18:34:24 <jle`> which is what mjrosenb originally wanted
18:34:25 <edwardk> myPoly & traverse %~ (==4)
18:34:35 <edwardk> fmap (==4) myPoly
18:34:38 <edwardk> pick your poison =)
18:34:56 <jle`> badPolyLens1 (== 4) :: Poly a -> Poly Bool, to be more general
18:35:00 <jle`> but it breaks pretty much every single lens law
18:35:07 <mjrosenb> ok, I think I'll try a traversal.
18:35:11 <edwardk> badPolyLens isn't a solution =)
18:35:25 <edwardk> the traversal is the right thing here, and its nice because the traversal is just 'traverse'
18:35:31 <edwardk> so you get this from the compiler for free
18:36:09 <jle`> yeah, GHC writes optics for you, how nice :)
18:38:07 <jle`> i am writing an expression type and i want people to be able to express lists using unfoldr but i also want evaluation of expressions to be terminating
18:38:12 <jle`> is there any nice way to do this
18:38:50 <Welkin> jle`: guards?
18:39:13 <Welkin> foldM is a right fold, is it?
18:39:14 <jle`> i mean, i'm allowing `unfoldr` as a primitive/constructor for the expression
18:39:21 <Welkin> oh, unfoldr
18:39:24 <jle`> alongside I Int, B Bool, Unfoldr blah
18:39:41 <jle`> so they can express Unfoldr using this expression type's reifications of lambdas and sum types
18:39:48 <jle`> and have it evaluate out to a list in the end
18:40:25 <jle`> before the introduction of Unfoldr, all finite expressions's evaluations were always terminating
18:40:31 <Welkin> foldM is a left fold
18:40:41 <jle`> but now with Unfoldr you can ahve finite expressions where their evaluations don't terminate
18:41:41 <jle`> i wonder if i can play around with GADTs to achieve something, but a lot of it depends on if the unfolding function will *ever* return Nothing
18:41:57 <jle`> which i don't think my expression type's construction is powerful enough to determine statically
18:42:03 <jle`> :/
18:42:53 <jle`> i should probably look into how idra/agda let you do stuff like this.  is `unfoldr` a part of those languages?
18:43:09 <scshunt> jle`: if you have sufficiently powerful language, you can't guarantee termination
18:43:30 <jle`> yeah, right now my language is unpowerful enough to guaruntee termination
18:43:33 * hackagebot hspec-webdriver 1.0.3 - Write end2end web application tests using webdriver and hspec  https://hackage.haskell.org/package/hspec-webdriver-1.0.3 (JohnLenz)
18:43:56 <jle`> but is there a way i can add an `Unfoldr` construct/primitive and still keep termination guaruntees?
18:43:57 <jle`> :'(
18:44:21 <shachaf> Just use the greatest fixed point.
18:44:37 <mjrosenb> wait, really? that is all generated for a traversal?
18:44:38 <shachaf> I.e. represent values as their unfold.
18:44:42 <scshunt> that's really beyond the scope of the language you're working in, and more a matter of "can you actually prove termination"
18:44:57 <scshunt> if you can prove termination in the metamath, then you can work about encoding that proof
18:44:58 <mjrosenb> wait, this isn't part of the lens library?
18:45:06 <scshunt> (which would be required for putting it into Agda)
18:45:19 <jle`> mjrosenb: `traverse` generated by GHC gives you a Traversal you can use
18:45:36 <mjrosenb> ok, but I can't just slot that in with lenses
18:47:18 <jle`> shachaf: is there something i can look at that uses this?
18:49:27 <shachaf> jle`: data Nu f = forall x. Nu x (x -> f x)
18:49:47 <shachaf> Along with newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }
18:49:52 <shachaf> Have you seen those types before?
18:50:20 <shachaf> fold :: Fix f -> Mu f, unfold :: Nu f -> Fix f
18:51:04 <jle`> they look like ana and cata
18:51:14 <johnw> jle`: if you squint, Mu is fold closed over its argument, while Nu is the arguments to unfold
18:52:16 <jle`> hm
18:52:29 <nolrai66> wait what Mu and Nu here?
18:53:39 <nolrai66> and applying the second arg to the first is the only thing you can do.
18:53:47 <nolrai66> Or wait..
18:54:03 <jle`> so if all values are represented by Nu f, then you can terminatingly "evaluate" them by using a corresponding Mu f?
18:56:31 <nolrai66> roll d8 d3 d8 d3
18:56:45 <nolrai66> Opps, wrong chanell.
18:57:28 <shachaf> sigh, I'm too easily tempted.
18:57:42 <shachaf> jle`: For a concrete example, think of Mu Maybe and Nu Maybe.
18:58:02 <shachaf> What are all the values of type Mu Maybe?
18:58:07 <shachaf> You're not allowed recursion.
18:59:23 <jle`> Mu (\f -> f Nothing) ?
18:59:41 <shachaf> That's one value. What's another one?
19:00:02 <jle`> Mu (\f -> f (Just (f Nothing))) ?
19:00:26 <shachaf> Yep.
19:00:27 <jle`> and i guess there's the continuation of that pattern too...
19:00:42 <jle`> is Mu Maybe an encoding of Nat, then?
19:00:47 <shachaf> In a way.
19:01:15 <shachaf> All the values of Mu Maybe are of the form Mu (\f -> (f . Just)^n (f Nothing))
19:01:24 <shachaf> Now how about Nu Maybe?
19:02:09 <jle`> i guess you have a bunch depending on the x you pick, right?
19:02:32 <shachaf> Maybe not as many as you think.
19:02:58 <shachaf> (For a few bonus points you can write muToNat, natToMu, zeroMu, plusOneMu, etc., but they're pretty straightforward if you've worked with Church numerals.)
19:03:02 <jle`> Nu 0 (\n -> Just (n + 1)), for x as Int?
19:03:27 <shachaf> OK, that's one.
19:03:29 <shachaf> What else?
19:03:41 <jle`> ah, got to run suddenly, but thanks for the exposition
19:04:14 <shachaf> (That's what these are -- (forall r. (Maybe r -> r) -> r) = (forall r. (r -> r, r) -> r) = (forall r. (r -> r) -> r -> r)
19:04:17 <shachaf> )
19:04:55 <nolrai66> I don't see the first isomorphism.
19:05:38 <shachaf> (Maybe r -> r) = (Either () r -> r) = (() -> r, r -> r)
19:06:14 <nolrai66> Oh was missreading it as (Maybe (r -> r)).
19:07:28 <edwardk> mjrosenb: traverse is a legal traversal, but its also in the Prelude since 7.10 ;)
19:07:59 <dramforever> :t traversed :: Traversal [a] [b] a b
19:08:00 <lambdabot> Applicative f => (a -> f b) -> [a] -> f [b]
19:08:06 <dramforever> :t traverse :: Traversal [a] [b] a b
19:08:07 <lambdabot> Applicative f => (a -> f b) -> [a] -> f [b]
19:08:13 <dramforever> looks great
19:08:40 <shachaf> itraversed :: Traversal [a] [b] a b, etc.
19:19:55 <edwardk> :t traversed
19:19:57 <lambdabot> (Applicative f1, Traversable f, Indexable Int p) => p a (f1 b) -> f a -> f1 (f b)
19:20:21 <edwardk> > ["hello","world"]^@..traversed Lens.<.> traversed
19:20:24 <lambdabot>  [((0,0),'h'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o'),((1,0),'w'),((1...
19:20:32 <edwardk> > ["hello","world"]^@..traverse Lens.<.> traverse
19:20:34 <lambdabot>      Couldn't match type ‘Indexed i (t0 a0) (f0 (t0 b0))’
19:20:34 <lambdabot>                     with ‘[Char] -> Const (Endo [((i, j), a)]) [Char]’
19:20:34 <lambdabot>      Expected type: Indexed i (t0 a0) (f0 (t0 b0))
19:20:47 <edwardk> ^- that is the extra power 'traversed' gives, it gives a counter of elements starting at 0
19:20:56 <edwardk> itraversed gives you access to the key of whatever container you are touching.
19:21:26 <edwardk> if you don't use the counter you interestingly don't wind up paying for it
19:22:01 <edwardk> -- a feature that has led to me getting no end of crap about the constraints on one class for years ;)
19:22:23 <shachaf> That's not what led to that.
19:24:47 <edwardk> conjoined was added to get us to where we could pay or not for the index
19:25:14 <edwardk> the superclasses were added to make it so the combinators would all work with indexed and unindexed forms, and ... well, to drive shachaf somewhat crazy
19:25:37 <edwardk> maybe a couple of them are gratuitous
19:25:46 <shachaf> No, you definitely need ArrowApply in there.
19:26:00 <edwardk> definitely
19:26:26 <brunoalano> Hey
19:26:35 <brunoalano> Anyone has a good reference book for learn Haskell?
19:26:36 <edwardk> I'm somewhat appalled at how well this "Really Unboxed" data structures thing is going
19:27:02 <edwardk> brunoalano: http://www.quora.com/Reviews-of-Learn-You-a-Haskell-2011-book/review/Edward-Kmett?share=1
19:27:02 <shachaf> What's this thing?
19:27:14 <edwardk> shachaf: it started as a thought experiment
19:27:22 <brunoalano> edwardk: thanks man
19:27:30 <edwardk> basically the issue i have is that every data structure in haskell can't hold mutable pointers, just a few of them can
19:27:37 <edwardk> e.g. MutVar, SmallMutableArray# etc, 
19:27:47 <edwardk> but you have no real options that live in * directly
19:28:11 <edwardk> so if i write a doubly-linked list in haskell, what i typically get is a link from my structure to a mutvar to a maybe to another node
19:28:14 <edwardk> and the same in the opposite direction
19:28:20 <edwardk> this is kinda slow
19:28:35 <edwardk> i can shave one of those by adding a Nil case as a data constructor
19:28:35 * hackagebot poly-arity 0.0.5 - Tools for working with functions of undetermined arity  https://hackage.haskell.org/package/poly-arity-0.0.5 (athanclark)
19:28:43 <edwardk> but i can't get rid of the MutVar#
19:29:05 <edwardk> so i was playing around with the internals of all of the arrays we have when working on my transients library
19:29:22 <edwardk> because there i'm using the frozenness of the arrays in ways it wasn't meant to be used
19:29:25 <gamegoblin> Could "Monoid a => IO a" be a monoid?
19:29:42 <exio4> Monad m => m a can be monoid
19:29:53 <exio4> or Applicative m => m a actually
19:30:02 <edwardk> and i realized that an "ArrayArray#' is just an unlifted container that contains other unlifted containers
19:30:05 <exio4> also Monad m => (a -> m a)
19:30:06 <edwardk> but it has a card marking table for gc, so its slow
19:30:11 <edwardk> er 'slow' by 5%
19:30:17 <shachaf> gamegoblin, exio4: Y'all mean *>, not =>
19:30:41 <exio4> that'd be mappend
19:30:58 <gamegoblin> shachaf: huh? Using the syntax like "instance Monoid a => Monoid (IO a) where"
19:31:10 <edwardk> gamegoblin: https://mail.haskell.org/pipermail/libraries/2014-November/024310.html <- it is currently in the works for the next ghc
19:31:18 <gamegoblin> edwardk: oh, thanks
19:31:38 <edwardk> anyways
19:32:45 <edwardk> so what i was playing with was this, a MutableArrayArray# s is really just a MutableArray# s Any  -- where the objects are cast to work with the things in # that are actually 'unlifted but gc ptr-based' like MutableArrayArray#'s themselves or ByteArray#s
19:33:12 <edwardk> basically it lets me shove references to a strict data structure in # into a slot without introducing any laziness issues
19:33:37 <nolrai66> gamegoblin: you mean by using liftM2?
19:33:53 <edwardk> so the game is to model objects as _SmallMutableArray#s_ with primops cast to change their kinds so i can pass references to other SmallMutableArray#s as members.
19:33:58 <gamegoblin> nolrai66: more or less
19:34:06 <gamegoblin> nolrai66: mappend = liftM2 mappend
19:34:17 <edwardk> so now i have a pointer based structure, where objects put themselves on the mutation list when they change and have direct pointers to other objects
19:34:27 <edwardk> and where i can have inline arrays at the end of the object
19:34:49 <edwardk> the only downside is i currently have to link out from the object to a MutableByteArray# as one of the slots to hold fields or just link to normal lifted haskell data types
19:35:10 <edwardk> but its a fully GC'd strict universe, that I can wrap in a constructor to make play nice with the rest of haskell
19:35:21 <scshunt> edwardk: is there a monadic lenses library?
19:35:29 <edwardk> and that the compiler is smart enough to lift away the * wrapper for 90% of my operations leaving me with a naked strict object
19:35:35 <edwardk> scshunt: not that makes any sense
19:35:40 <edwardk> scshunt: the laws don't work
19:35:48 <CMCDragonkai> [Roger Qiu] do heterogenous lists have an equivalent infinite version, just like [1..]?
19:35:58 <scshunt> edwardk: oh, interesting. is there a post about that I can read somewhere?
19:36:01 <edwardk> CMCDragonkai: you can't make an infinitely large type
19:36:19 <CMCDragonkai> [Roger Qiu] why not?
19:36:25 <edwardk> CMCDragonkai: the value level of haskell is quite different than the type level
19:36:40 <edwardk> CMCDragonkai: (a,(b,(c,(....     -- finish typechecking that
19:37:31 <CMCDragonkai> [Roger Qiu] what kind of type theory would allow lazy infinite hetero lists?
19:37:36 <slack1256> @quote type level nat peano
19:37:36 <lambdabot> No quotes for this person. Are you typing with your feet?
19:39:46 <edwardk> CMCDragonkai: well, any language without an 'occurs' check likely. so something like Prolog
19:40:34 <edwardk> CMCDragonkai: you may want to look into the difference between equirecursion and isorecursion in types
19:40:41 <edwardk> lemme see.. 
19:40:45 <edwardk> https://www.cs.cornell.edu/Courses/cs4110/2012fa/lectures/lecture27.pdf
19:41:00 <nolrai66> Could you do that in something like Agda?
19:41:40 <edwardk> nolrai66: IIRC the equirecursive form starts easy and gets pretty awkward as you add type system features, but YMMV
19:43:40 <CMCDragonkai> [Roger Qiu] a prolog with types?
19:44:19 <rpfun> does one gain very much performance (i could benchmark, but looking to experience) by using Unboxed vs regular Vectors? I am just a little upset losing Traversable/Foldable/Functor/Applicative/etc.
19:44:49 <nolrai66> Hmm.
19:45:28 <edwardk> CMCDragonkai: well, lets see, examples of interesting type systems with equirecursive types
19:45:31 <edwardk> http://people.cs.uchicago.edu/~blume/papers/icfp06-submitted.pdf 
19:45:39 <edwardk> ^- MLPolyR is probably the best example I can think of
19:45:59 <edwardk> it is ML-like but equirecursive with open sum and product types
19:46:44 <edwardk> which lets you do things like extensible cases, functions that simplify out certain terms from a language and give back a small recursive type, etc.
19:50:57 <CMCDragonkai> [Roger Qiu] i see, things to study... thanks
19:53:04 <ElMoloko> is FRP really usually done with massive tuples?  Is there any way to have arbitrary length tuples?
19:53:17 <ElMoloko> as in a zipN sort of thing? 
19:55:07 <CMCDragonkai> [Roger Qiu] theres a paper on that called arity generic... https://www.google.com.au/search?ie=UTF-8&client=ms-android-hms-vf-au&source=android-browser&q=haskell+arity+generic
19:55:58 <ElMoloko>  Oh wow! from my old Uni as well, it seems
19:55:59 <ElMoloko> Thanks!
20:01:38 <Hijiri> ElMoloko: in general people don't usually do massive tuples
20:02:03 <Hijiri> the closest thing might be big product types defined with data
20:02:14 <Hijiri> I don't think that's particularly prominent in FRP though
20:03:42 <Welkin> large tuples are impractical
20:03:57 <Welkin> I don't see a purpose for anything large than a pair
20:04:46 <CMCDragonkai> [Roger Qiu] extensible records is another possibility that allows defaulting too
20:05:01 <Welkin> who is this Roger Qiu?
20:05:08 <CMCDragonkai> [Roger Qiu] it is me
20:05:16 <slack1256> ??
20:05:18 <dramforever> CMCDragonkai: I don't really want to say this, but your irc client is a bit funny
20:05:19 <Welkin> is that a script?
20:05:32 <dramforever> I wonder if that's intended
20:05:36 <athan> hi everybody
20:05:42 <dramforever> "[Roger Qiu] it is me" this is what we are seeing
20:05:47 <slack1256> maybe the irc ident and nick got repeating
20:05:58 <slack1256> <CMCDragonkai> [Roger Qiu] it is me
20:05:59 <Welkin> it's like if athan prefixed all his messages with [athan]
20:06:09 <Welkin> he is talking to himself!
20:06:13 <CMCDragonkai> [Roger Qiu] indeed, the is an org account and [Roger Qiu] is the user account
20:06:23 <athan> Welkin: No that's normal
20:06:33 <Welkin> CMCDragonkai sounds like a video game
20:06:34 <Welkin> what is it?
20:06:35 <athan> :v
20:06:36 <CMCDragonkai> [Roger Qiu] but my org only has 1 person, me
20:06:36 <nolrai66> CMCDragonkai is a org account?
20:07:03 <CMCDragonkai> [Roger Qiu] yes, see sameroom.io
20:08:34 <athan> Anyone know if there is a general class for a "sequence"? I'm thinking of something like a different container for [0..]
20:08:53 <athan> so not something from `Enum`, but something that `enumTo` can result in
20:08:54 <Welkin> athan: Sequence :D
20:09:04 <athan> Welkin: I said class :c
20:09:23 <athan> :t enumTo
20:09:24 <lambdabot>     Not in scope: ‘enumTo’
20:09:24 <lambdabot>     Perhaps you meant ‘enum’ (imported from Control.Lens)
20:09:49 <athan> :t enumFromTo
20:09:51 <lambdabot> Enum a => a -> a -> [a]
20:10:05 <slack1256> you want something like a generealized fromList?
20:10:21 <athan> I'd rather have `(Sequenceable f, Enum a) => a -> a -> f a`
20:10:40 <athan> slack1256: I think so, yeah
20:11:08 <athan> or just the class of all single-tail cons cell lists
20:11:22 <athan> actually I'm not sure if that's true, either
20:11:26 <slack1256> https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists
20:11:30 <athan> take for instance [0..], but in the context of trees
20:11:31 <slack1256> maybe that can help
20:11:50 <athan> slack1256: nah, I don't need no stinking literals
20:11:55 <athan> thank you though
20:12:42 <slack1256> but it seem it use case is to overload fromList from Data.{Set,Map,Int{Map,Set}} & friends
20:13:11 <slack1256> *its
20:14:02 <athan> slack1256: I'm not sure about that. `fromList` for Data.Map for instance, needs key information too
20:14:20 <athan> I think this is more a concept of "growth"
20:14:42 <athan> and how we can embed an `Enum a` element in the container
20:16:56 <slack1256> oh right. IsList has a fromList :: [Item a] -> a
20:17:43 <athan> Hm! That sounds interesting!
20:18:05 <slack1256> Well IsList seems to fit the bill when the keys are implicient on the out container (Vector, Set)
20:18:27 <slack1256> *implicit
20:18:43 <athan> hmm
20:18:47 <athan> thanks slack1256
20:22:14 <Welkin> athan: what are you up to?
20:22:34 <athan> Welkin: no good :x
20:22:37 <athan> Welkin: hbu?
20:23:42 <Welkin> did you finish that constraint solver?
20:24:34 <Welkin> I'm playing around with lots of things including graphics, security, and streaming
20:25:01 <rpfun> what are the good/standard ways of keeping up with new developments in haskell? esp. regarding the theory and typesystem? edwardk?
20:25:24 <Welkin> rpfun: the ghc mailing list?
20:25:26 <Welkin> there is one, right?
20:25:35 <Welkin> or just spend time in #ghc and here
20:26:30 <rpfun> ok, i thought there might be particular journals/websites?
20:26:36 <athan> Welkin: Almost there ><
20:26:41 <athan> Welkin: That sounds really cool :)
20:26:49 <slack1256> the mailing list is were is at
20:26:57 <slack1256> all of them
20:41:53 <edwardk> rpfun: my method: go to every conference where someone mentions the word haskell and talk to folks :0
20:43:05 * dramforever will mention haskell whenever he goes =P
20:43:12 <dramforever> *wherever
20:47:37 <edtoast_46> JOIN #toastirc please.
20:48:17 <dfranke> sigh. Anyone got a banhammer nearby?
20:49:27 --- mode: ChanServ set +o shachaf
20:49:46 <dramforever> I wonder if there's a more efficient method
20:49:52 --- mode: shachaf set +b-o edtoast_*!*@* shachaf
20:50:35 <Cale> I guess that works. Kind of annoying that the best way to ban IPv6 people is to nick ban :P
20:50:51 <dramforever> =)
20:50:58 <shachaf> IP bans don't work against determined people.
20:51:05 <shachaf> Neither does any other kind of ban, really.
20:52:37 <shachaf> also, whoa, dfranke is back
20:53:30 <dfranke> I've been around intermittently for a while now :-)
21:03:39 <kadoban> In optparse-applicative how does one do something like data Verbosity = Quiet | Normal | Verbose   and --quiet or --verbose ? They can't be separate exactly, and I don't see how to combine either, they're kind of mutually exclusive and both optional? I seem to be missinga combinator I think.
21:13:42 * hackagebot moesocks 0.1.0.22 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.22 (JinjingWang)
21:17:01 <exio4> kadoban: maybe you want (<|>)? 
21:17:36 <rpfun> i have GHC complaining "Could not deduce (KnownNat (n - 1)) from context (KnownNat n)". is there a way around this?
21:17:38 <kadoban> Oh … crap yeah they're Alternatives aren't they? That sounds quite possible.
21:17:43 <kadoban> Thanks
21:18:14 <exio4> kadoban: I just checked, and Parser is an Alternative
21:24:33 <kadoban> Seems like the fairly obvious way to go using <|> at least typechecks, that seems like a good sign XD
21:38:34 <Welkin> what does voting for a package on hackage do?
21:39:25 <kadoban> You can vote for packages? O.o
21:39:30 <Welkin> yeah
21:39:41 <Welkin> there is a link in the package information
21:39:59 <Welkin> Votes <# of votes> [Vote for this package]
21:40:17 <kadoban> Oh there is … weird. Maybe the loser gets kicked off the island.
21:40:50 <kadoban> (I'd guess that's probably all it does, increments that number?)
21:52:10 <geekosaur> yes, it's supposed to be some indication of how good the package is or something
21:59:23 <kadoban> So when I put ":m + MyProject.Blah" in the .ghci file for my project, and then do 'stack ghci', it says "Could not find module 'MyProject.Blah'  It is a member of the hidden package 'my-project'"  Any ideas why that would be, or how to fix? Once ghci is running I can do :m + MyProject.Blah fine …
22:07:41 <lambdahole> > map (+1) [1..7]
22:07:43 <lambdabot>  [2,3,4,5,6,7,8]
22:08:00 <Abd4llA> #/join akka
22:16:06 <haskell847> is there a way to change only one field on a data type without having to type it all over again. Like the "with" keyword in f#
22:17:17 <haskell847> type MyRecord = {     X: int;     Y: int;     Z: int      }  let myRecord1 = { X = 1; Y = 2; Z = 3; }
22:17:26 <haskell847> let myRecord2 = { myRecord1 with Y = 100; Z = 2 }
22:24:32 <jle`> myRecord2 = myRecord1 { Y = 100, Z = 2 }
22:25:01 <haskell847> way simpler, thanks!
22:25:27 <jle`> np!
22:39:26 <maria_> hi! i am writing haskell program. In fact, it's not firstest haskell program, but first with hard usings monads and monads transformers. It's program parses binary file. I use amazing function 'isolate' (from Data.Binary.Get), but I cannot found version of 'isolate' which returns error (like Either) instead of call error. Can you help me with it?
22:42:01 <maria_> or may be there is more efficient way (library, package) to parse binary file instead of Data.Binary.Get?
22:46:46 <maria_> I think that binary file parsing is one of commmon tasks in this world. I believe there are many people here who did it. And 'isolate' function is required for this task. Am I wrong?
22:50:18 <maria_> haw...
23:00:48 <AaronFriel> I know the ability to refactor Haskell easily is one of its oft-repeated triumphs
23:01:04 <AaronFriel> But I think one thing not repeated often enough is that the more generic your code is, the more likely it seems like it's going to be correct when you write it
23:02:01 <AaronFriel> When I write a function in which there are 5, 6, or 7 types, there's often just one way to write it
23:02:40 <bz> maria_: not necessarily
23:02:54 <AaronFriel> Figuring out the shape of the function I want is cognitively hard, but writing it? Often not more difficult than replacing terms you aren't sure with holes and plugging in the only available answer
23:03:21 <AaronFriel> I'm just saying this is my experience, that the more generic a function I write (the more it allows variations of types)
23:03:40 <AaronFriel> the uniqueness of each type constrains more tightly what every term in the definition can be
23:11:47 <rhovland> ever since I updated things, using {-# OPTIONS_GHC -O2 #-} at the top of my files makes me get a panic when I load the file in ghci.. is it just me? should I not be using that?
23:18:26 <dmj> rhovland: you can specify ghc-options in your cabal file too. -O2 is for core passes, I think ghci is just executing bytecode, so it probably wouldn't make sense
23:20:50 <rhovland> dmj: sure, I don't really care about the -O2.. I put it in b/c I'm doing problems on hackerrank, so I'm hoping it'll make them compile my code with -O2.. but before the update (I guess when I was on 7.8.4?) ghci would load my file fine... now ghci gets a panic, and says the 'impossible' happened (and tells me to file a bug report), unless I comment that out
23:25:39 <dmj> rhovland: that's probably a good thing since -O2 is for compiled code, and ghci does not compile code
23:26:35 <rhovland> dmj: well, I figured ghci would just ignore the OPTIONS_GHC directives in the file
23:28:13 <rhovland> dmj: but then again, I've never had the need to use anything else for OPTIONS_GHC... maybe there's things that people use that ghci is supposed to follow... still, ghci shouldn't get a panic and ask me to file a bug report... I mean.. should I file a bug report?
23:28:25 <dmj> rhovland: do you really mean to specify optimizations on a per module basis?
23:31:09 <rhovland> dmj: I mean, I could understand ghci giving me an error, and saying the line number... but I just get http://lpaste.net/9082966373377769472 ... I had to comment out sections of code until I found the problem...
23:32:14 <dmj> rhovland: I wouldn't, the ghc team probably has better things to be working on. This isn't really even a bug. If it really bothers you, I would submit a patch where it doesn't explode (this might show you the root cause). O/w I would just specify ghc-options in your cabal file, not in your modules, and then load them w/ cabal-repl or ghci.
23:32:45 <dmj> unless there is some justified reason for having optimizations on a per module basis
23:32:49 <rhovland> dmj: sort of, yeah, it's stuff for solving things on hackerrank... so I can't load anything outside of base when I submit the code... everything has to be in the file... I only have that line as a hint to the compilers on the site
23:33:39 <dmj> rhovland: Does hackerrank tell you w/ what settings they compile your file?
23:35:10 <rhovland> dmj: that is, I copy/paste my file over into a window and submit the code... so it's only one "file" ... and it doesn't crash over there (since they don't load it into ghci in the first place, and they're on 7.8.4 anyway, which didn't have this problem)
23:36:35 <dmj> rhovland: code compiled w/ ghc will in general be a lot faster than code interpreted w/ ghci, if they're interpreting your file, you're already at a disadvantage
23:37:32 <dmj> unless they're using `ghci -fobject-code`
23:39:15 <dmj> rhovland: I'd find out first how hackerrank is running your code
23:40:08 <dmj> rhovland: compiling vs. interpreting. If interpreting, then the pragma doesn't matter. If compiling, then check w/ what settings they are. I assume out of fairness everyone would be the same. 
23:41:05 <dmj> rhovland: they might be using the GHC API to compile it
23:41:10 <rhovland> dmj: anyway, I can comment out the line... I'm pretty sure they compile everyone with the same settings (using a -O2 directive would almost be cheating, otherwise, I guess).. I had the pragma in as a "just in case", and previously that was fine... but now, it makes ghci panic and ask me to file a bug report
23:41:43 <rhovland> dmj: really I have no idea what they do on the site.. that's why I put the pragma in, sort of as a "can't hurt"
23:42:18 <AaronFriel> Suppose I have a parser written as a state machine - with lots of little jumps (parse a single character, return a new state, which is fed into a new parser) - and I have some evidence that these jumps might not be producing optimal code
23:42:22 <dmj> rhovland: it's a compiler pragma, not meant for interpreters. 
23:42:34 <AaronFriel> Is there any research on something like stream fusion for state machines?
23:42:50 <rhovland> dmj: they definitely compile on the site... but when I'm working on it locally, I load the file into ghci
23:43:14 <rhovland> dmj: if it's not meant for interpreters, I'd expect interpreters to ignore it, not panic
23:44:52 <dmj> rhovland: then a pull request would be fitting
23:47:32 <rhovland> dmj: can you repeat it? I'm on gentoo, so I'm wondering if it's just some local problem.. far as I can tell, any file with {-# OPTIONS_GHC -O2 #-} pragma makes my ghci panic
23:48:20 <dmj> rhovland: It repeats for me on OSX 7.10.2
23:48:39 <rhovland> k. woot. that's cross-platform!
23:48:51 * hackagebot th-traced 0.0.0.0 - Tracing Q monad computation  https://hackage.haskell.org/package/th-traced-0.0.0.0 (HiromiIshii)
23:49:03 <rhovland> dmj: heh and I'm guessing you had a pretty minimal file to test it
23:49:10 <dmj> rhovland: yes
23:51:11 <rhovland> dmj: this feels like something people would've hit, though... I can't be the only one using that pragma and loading the file in ghci
23:52:53 <dmj> rhovland: I'd venture to guess most set ghc-options relating to optimizations on compiled code in their cabal file. 
23:53:51 * hackagebot th-traced 0.0.1.0 - Tracing Q monad computation  https://hackage.haskell.org/package/th-traced-0.0.1.0 (HiromiIshii)
23:56:16 <rhovland> dmj: mm... yeah, I can definitely see setting -O2 inside a file is unusual... in fact, I can only think of my use case, where you don't know anything about the compiler/environment
