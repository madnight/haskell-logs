00:06:50 <Taslem> Gurkenglas: since the top level matches with "simplify", the case { Just x' -> simplifyTree x' ?? x' } will trigger
00:07:06 <Taslem> this will cause it to simplify the result
00:07:35 <Taslem> hence it should (so far as I intended) continue to simplify it down to (Num 1)
00:07:51 <Gurkenglas> Ah, right
00:15:15 <greves> are super enormously long integers in haskell correct?
00:15:25 <greves> i just did factorial of 100,000 and it spit out a hundred page long number
00:15:45 <Ralith> if your integer exceeds two meters in length, consult a doctor
00:16:02 <greves> lol
00:16:20 <dramforever> greves: they are very likely to be
00:16:32 <dramforever> because by default ghc uses a bigint implementation called gmp
00:16:49 <dramforever> I would trust i
00:16:50 <dramforever> it
00:17:04 <dramforever> and, btw, why are you using them?
00:17:10 <nolrai66> ..for what could you possibly use it?
00:17:18 <dramforever> lol nolrai66 ++
00:17:42 <greves> oh i'm not, just playing around learning haskell :)
00:18:20 <nolrai66> Ah.
00:18:36 <nolrai66> I guess that is a way to test your computer.
00:27:43 <sccrstud92> gmp is so likely to bug correct
00:27:55 <sccrstud92> that when it gets the wrong answer
00:28:07 <sccrstud92> the compiler is wrong just as often as gmp
00:28:29 * hackagebot ghcjs-websockets 0.3.0.5 - GHCJS interface for the Javascript Websocket API  https://hackage.haskell.org/package/ghcjs-websockets-0.3.0.5 (jle)
00:29:39 <Gurkenglas> http://lpaste.net/138244#a138246 <- Here's my approach, though it should be possible to get rid of phi and those Fix in simplify also don't look necessary
00:31:02 <Gurkenglas> Oh, replace those >> x with >> return x.
00:32:10 <Gurkenglas> (Uses Fix and cata from https://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html )
00:33:07 <bennofs> Gurkenglas: also, tell (Any True), not tell True
00:33:19 <bennofs> Gurkenglas: and I'd write it as (Any True, x) :)
00:34:04 <Gurkenglas> I wrote it this way in hopes of factoring out something from something else, because my way looked closer to that being possible
00:38:01 <Gurkenglas> Can one use $ in pattern matches?
00:38:29 * hackagebot json-rpc 0.6.1.0 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.6.1.0 (XenoGenesis)
00:42:12 <lpaste_> Gurkenglas revised “No title (annotation)”: “Version 2 of my approach - less bugs!” at http://lpaste.net/138246
00:43:29 * hackagebot hinotify 0.3.8.1 - Haskell binding to inotify  https://hackage.haskell.org/package/hinotify-0.3.8.1 (LennartKolmodin)
00:45:02 <lpaste_> Gurkenglas revised “No title (annotation)”: “Make phi even more boilerplatey in hopes of someone seeing an abstraction” at http://lpaste.net/138246
00:51:48 <bennofs> Gurkenglas: phi f x = sequenceA x >>= f ?
00:51:58 <bennofs> Gurkenglas: with deriving (Foldable, Traversable) for Node
00:52:55 <bennofs> Gurkenglas: or even: phi = sequenceA >=> simplify  :)
00:53:16 <Gurkenglas> Exactly what I was looking for, thanks!
00:58:58 <Gurkenglas> Can Data.Coerce.coerce unwrap any newtype?
01:02:47 <liangzan> can i ask a beginner question?
01:03:01 <dramforever> liangzan: sure you can
01:03:08 <dramforever> you can ask any haskell related questions
01:03:17 <dramforever> but there's also #haskell-beginners
01:03:31 <liangzan> no response at haskell-beginners
01:03:35 <dramforever> liangzan: but there are more people here =)
01:03:39 <liangzan> so i thought i might have help here
01:03:46 <dramforever> liangzan: wait what's the question?
01:03:47 <lpaste_> Gurkenglas revised “No title (annotation)”: “Implemented bens hint. Taslem, look here! (If you don't like the Fix words in simplify, you can try making it operate on Node (Node Tree) instead of Node Tree and somehow thread that into simplifyTree.” at http://lpaste.net/138246
01:03:54 <Gurkenglas> *)
01:04:10 <liangzan> i’ve defined this “data FooList = FooList [Foo]”
01:04:17 <liangzan> i want to use map on FooList
01:04:24 <liangzan> but, i get compilation errors
01:04:47 <liangzan> how should i use map on FooList? 
01:05:27 <Gurkenglas> You could do "data FooList foo = FooList [Foo] deriving Functor" and use fmap, or you could skip the custom data definition
01:05:37 <dramforever> Gurkenglas: wait a sec
01:05:40 <dramforever> liangzan: you can't
01:05:47 <dramforever> because map is on regular lists only
01:06:07 <dramforever> however, if you want to use map in the list inside the FooList
01:06:20 <liangzan> oh i get it
01:06:38 <liangzan> you’re right, i should use the list inside
01:06:46 <dramforever> liangzan: I assume you know what to do now, ask more questions if you don't
01:06:50 <liangzan> thanks for the enlightenment
01:06:52 <liangzan> :)
01:06:56 <dramforever> =) yw
01:07:44 <Gurkenglas> Oh, Taslem is gone.
01:08:22 <bennofs> Gurkenglas: yes, it should work for any newtype
01:09:12 <dramforever> well there's something really nice called DeriveFunctor
01:09:31 <dramforever> IIRC also traversable or something
01:09:37 <bennofs> dramforever: and even DeriveFoldable and DeriveTraversable :DS
01:09:58 <bennofs> + GeneralizedNewtypeDeriving and I rarely write instances at all :p
01:58:32 * hackagebot json-rpc 0.6.2.0 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.6.2.0 (XenoGenesis)
02:28:22 <Sindriava> :t runReaderT
02:28:23 <lambdabot> ReaderT r m a -> r -> m a
02:28:26 <Sindriava> :t flip runReaderT
02:28:27 <lambdabot> r -> ReaderT r m a -> m a
02:28:47 <Sindriava> Wouldn't the latter be a better type signature?
02:29:16 <dramforever> why
02:29:29 <Sindriava> example with current signature:
02:30:00 <Sindriava> runStateT (runReaderT example (AppConfig 42)) (AppState 0)
02:30:01 <dramforever> wait IIRC runReaderT is a record selector
02:30:29 <Sindriava> example with flipped signatures: runStateT (AppState 0) $ runReaderT (AppConfig 42) $ example
02:30:58 <dramforever> okay
02:31:45 <Sindriava> I figure there's a reason for this, that has bigger value than syntactical convenience. Am I missing something?
02:33:39 <chattered> Yeah, runReaderT is just the field of the newtype.
02:34:06 <chattered> I find the flipped version often more convenient: runReaderT r $ do ...
02:34:13 <dramforever> that's not a big enough reason
02:34:19 <chattered> Sorry: flip runReaderT r $
02:34:54 <dramforever> however, only State Reader and RWS is affected
02:34:57 <dramforever> *are
02:35:03 <Sindriava> dramforever: Sorry, I said that in a bit convoluted way. What I meant was:
02:35:33 <dramforever> Sindriava: I mean, "field of newtype" isn't a big enough reason
02:35:35 <Sindriava> dramforever: Is there a reason for the current type signature, that outweighs the syntactical convenience?
02:35:41 <Sindriava> dramforever: I see
02:56:04 <fvgvxmpv1> the syntactical convenience of record syntax? ^.^
02:56:29 <sgronblo> My ghc-mod seems to be saying the following about my test files: "Could not find module ‘Test.Hspec’It is a member of the hidden package ‘hspec-2.1.10’.Perhaps you need to add ‘hspec’ to the build-depends in your .cabal file.Use -v to see a list of the files searched for."
02:56:52 <sgronblo> But I have hspec as a build-dependency for my test-suite
02:57:55 <qz> is there any convenient way to install ghc 7.10 on debian? too bad deb.haskell.org is not working...
02:58:19 <dramforever> http://haskell.org/ghc/
02:58:29 <dramforever> download from there
03:01:35 <qz> dramforever: well, i got ghc-7.10.2-x86_64-unknown-linux-deb7.tar.bz2 from there but can't find ghc executable inside :)
03:01:44 <dramforever> don't worry
03:01:52 <dramforever> wait wait what?
03:01:59 * dramforever goes to his archive
03:02:59 <ilyaraz> Say I have some computation with the ST Monad, let's say I use ST to keep some mutable state (an array or so); now I don't want to pass this state all around; what is the right way to do it?
03:03:12 <qz> dramforever: oh, they want me to go with configure + make  first time i see _binary_ distribution like that
03:03:30 <dramforever> qz: I don't know, it seems that it's organized in a weird way
03:03:40 * dramforever is sure it's a binary distribution
03:03:46 <ilyaraz> I tried to do something along the lines of applying ReaderT: something of the sort "ReaderT (HashTable s) (ST s) Int", but I could not make it work
03:04:09 <ilyaraz> (here HashTable s is Data.HashTable.ST.Basic.HashTable s Int Int)
03:04:29 <dramforever> qz: weird...make doesn't work, because it wants you to make install
03:06:00 <qz> dramforever: yeah, looks like configure + make install worked though. thanks for pointing out to that distro
03:06:37 <dramforever> qz: you also want cabal, download the cabal-install tool from https://www.haskell.org/cabal/download.html
03:06:47 <dramforever> and use the bootstrap.sh to install it
03:06:54 <dramforever> it will take care of dependencies
03:07:53 <qz> dramforever: will try that, thanks
03:08:01 <dramforever> you're welcome =P
03:08:46 <lyxia> ilyaraz: I think it could work that way. What errors are you getting?
03:10:59 <ilyaraz> lyxia: here is a part of the code
03:11:35 <ilyaraz> lyxia: http://pastebin.com/f8J4KFNW
03:12:26 <ilyaraz> lyxia: the error is   Couldn't match expected type `ReaderT (HashTable s) (ST s) (Maybe Int)' with actual type `ST s (Maybe Int)'
03:12:33 <ilyaraz> on the line
03:12:44 <ilyaraz> lyxia: x <- H.lookup cache n
03:13:19 <ilyaraz> lyxia: I more or less understand why this happens, but I don't see a way around it
03:14:45 <dramforever> lyxia: lift is what you want
03:15:02 <dramforever> x <- lift (H.lookup cache n)
03:15:19 <dramforever> hopefully you will wrap operations on the cache into nice combinators
03:15:26 <lyxia> dramforever: That's for ilyaraz :)
03:15:47 <dramforever> oh wait what?
03:15:57 <ilyaraz> dramforever: thanks! this is indeed what I need!
03:16:12 <dramforever> lyxia: oh sorry
03:16:18 <dramforever> ilyaraz: you're welcome
03:16:28 <ilyaraz> dramforever: not sure I understood about combinators though
03:16:39 <dramforever> s/combinators/functions
03:16:52 <dramforever> that was just a fancier name
03:17:04 <dramforever> for...I don't know why I used that
03:17:58 <ilyaraz> dramforever: OK thanks again!
03:18:24 <dramforever> no I don't deserve thanks for using fancy names that need explaination
03:29:10 <Sindriava> Does Applicative IO preserve the sequencing order?
03:29:23 <dramforever> yes
03:29:24 <Sindriava> e.g. will ` a *> b <* c ` do a, b, c in order?
03:29:27 <dramforever> and it must
03:29:32 <dramforever> because ap = (<*>)
03:29:52 <Sindriava> It doesn't seem to be the case :( Maybe a bug? Gimme a sec
03:30:21 <Sindriava> Yeah
03:30:34 <Sindriava> When using `gl`, `glBindBuffer enum bo *> f <* glBindBuffer enum 0` doesn't draw anything
03:30:42 <Sindriava> while `glBindBuffer enum bo *> f` does
03:30:59 <Sindriava> presumably because the buffer is unbound before f is executed?
03:31:04 <dramforever> print 1 *> print 2 <* print 3
03:31:09 <dramforever> outputs 1 2 3 correctly
03:31:13 <Sindriava> > print 1 *> print 2 <* print 3
03:31:14 <suppi> Hi, is the pattern 'fac (n+1) = (n+1) * fac n' no longer supported?
03:31:14 <lambdabot>  <IO ()>
03:31:29 <Sindriava> suppi: Why wouldn't it be?
03:31:35 <Sindriava> dramforever: It does… Hm…
03:31:51 <suppi> Sindriava, http://ideone.com/zV4vo9
03:32:03 <dramforever> suppi: yes
03:32:11 <mniip> it is deprecated in haskell 2010
03:32:18 <dramforever> and you are not supposed to be using it
03:32:20 <suppi> mniip, dramforever, thanks!
03:32:28 <dramforever> because...why should you be using it?
03:32:32 <Sindriava> suppi: Oh, I missed the first (n+1)
03:32:44 <mniip> because people often misunderstood the partial functions it creates
03:32:45 <Sindriava> suppi: Yeah, don't do that, it's weird
03:33:08 <mniip> for example 3 doesn't match (n+5)
03:33:23 <suppi> a different question then, can I pattern match on hex? like 0xwxyz?
03:33:37 <mniip> why don't you try
03:34:05 <bennofs> > 0x3
03:34:06 <lambdabot>  3
03:34:20 <dramforever> > case 20 of 0x14 -> "Great"
03:34:21 <lambdabot>  "Great"
03:35:19 <suppi> I mean, is there a way to isolate as variables the different hex characters
03:35:34 <suppi> using pattern matching
03:35:35 <Sindriava> dramforever: Oh wait, it was my fault the sequencing was fucked up
03:35:45 <dramforever> =)
03:35:48 <Sindriava> dramforever: It's because OpenGL is a !@#$#!$% state machine
03:38:30 <Sindriava> I swear to god, OpenGL is the antichrist of functional programming
03:40:19 <pyon> @hoogle Either l a -> Maybe a
03:40:19 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
03:40:19 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
03:40:19 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
03:40:28 <pyon> Oh, right, obviously.
03:43:36 * hackagebot type-list 0.2.0.0 - Operations on type-level lists and tuples.  https://hackage.haskell.org/package/type-list-0.2.0.0 (mjmrotek)
03:45:24 <ahihi> suppi: you can use view patterns with e.g. a function that turns an int into a list of hex digits
03:45:50 <suppi> ahihi, yeah. this is what I'm trying to do right now. thanks
03:46:25 <ahihi> > let { hex = unfoldr (\case 0 -> Nothing; n -> Just ((['0'..'9']++['a'..'f']) !! mod n 16, div n 16)); f (hex -> last:_) = "the last hex digit is " ++ show last } in f 0x7f
03:46:27 <lambdabot>  <hint>:1:22: parse error: naked lambda expression ''
03:46:29 <suppi> ahihi, though it would've been nice if there was a datatype from 0 to F :(
03:46:38 <ahihi> no LambdaCase? bah
03:48:25 <ahihi> > let { hex = unfoldr (\x -> case x of 0 -> Nothing; n -> Just ((['0'..'9']++['a'..'f']) !! mod n 16, div n 16)); f (hex -> last:_) = "the last hex digit is " ++ show last } in f 0x7f
03:48:26 <lambdabot>  "the last hex digit is 'f'"
03:58:37 * hackagebot repa-linear-algebra 0.1.0.0 - HMatrix operations for Repa.  https://hackage.haskell.org/package/repa-linear-algebra-0.1.0.0 (mjmrotek)
05:11:26 <EvilMachine> How would I implement a type, that on runtime can be arbitrary, except for some limitations set by a schema (at runtime)? In other words: A “blacklist type”. (Where one could call normal types “whitelist types”, because they allow nothing except what has been defined at compile time.)
05:12:30 <dramforever> EvilMachine: yes, you can use a newtype wrapper
05:12:50 <dramforever> newtype Restricted = Restricted Foo
05:13:15 <dramforever> and don't export the construct Restricted. instead, provide a smart constructor
05:13:17 <EvilMachine> dramforever: That’s not at runtime.
05:13:27 <dramforever> oh wait what do you mean exactly?
05:13:55 <dramforever> can you give an example?
05:14:34 * mniip .oO( Comaybe? )
05:14:40 <dramforever> hmm...
05:14:54 <dramforever> mniip: still no difference
05:14:59 <EvilMachine> dramforever: hold on, I’m thinking. :)
05:15:45 <mniip> evil machine is thinking o,o
05:16:10 <EvilMachine> dramforever: Imagine a directed graph type, with an associated schema (set of rules for its structure and contents). This schema limits what you can do with the graph. But: Those limitations are runtime limitations. The reason is, that the limitations are unknown at compile time.
05:16:30 <edk> you can't set the limitations at runtime
05:16:59 <EvilMachine> But I still want to have the benefits of type checking, even though I don’t know the limitations at compile time.
05:17:09 <dramforever> typeclasses?
05:17:16 <mniip> reflection?
05:17:23 <dramforever> newtype Restricted r = Restricted Foo
05:18:00 <dramforever> class Schema r where construct :: Proxy r -> Maybe (Restricted r)
05:18:27 <dramforever> EvilMachine: ^
05:18:28 <EvilMachine> dramforever: What does the Proxy type do?
05:18:43 <mniip> It proxies
05:18:47 <dramforever> wait
05:18:47 <EvilMachine> dramforever: Is that the generic graph type
05:18:51 <dramforever> no need for proxy
05:19:01 <dramforever> class Schema r where construct :: Foo -> Maybe (Restricted r)
05:19:07 <dramforever> yes Foo is the generic type
05:19:16 <dramforever> and construct is supposed to verify it
05:19:28 <mniip> data Proxy (a :: k) = Proxy
05:19:32 <EvilMachine> dramforever: I am not a native english speaker, and the exact meaning of “proxy” in English always eluded my. Translations just are no good.
05:19:39 <dramforever> EvilMachine: it still isn't very runtime, but it seems that it's good enough
05:19:52 <dramforever> EvilMachine: don't worry it's effectively a type parameter
05:19:58 <EvilMachine> Ok. :)
05:20:01 <dramforever> and we won't need it here anyway
05:20:13 <EvilMachine> :))
05:20:18 <dramforever> =P
05:20:31 <dramforever> is my Schema class good enough
05:20:36 <dramforever> ?
05:21:13 <EvilMachine> dramforever: The problem is, that said “Restricted” type is not known at compile time. 
05:21:24 <EvilMachine> dramforever: Otherwise it’s good, yes.
05:21:50 <dramforever> wait so like program user input/
05:21:51 <dramforever> ?
05:22:11 <EvilMachine> dramforever: I really really want to avoid the inner-platform effect. :)
05:22:21 <EvilMachine> dramforever: Yes, basically.
05:23:16 <EvilMachine> dramforever: Arbitrary input.
05:24:02 <dramforever> a construct :: Schema -> Graph -> Restricted
05:24:09 <dramforever> might be what you want
05:24:51 <EvilMachine> Yes. I fear it might result in a printf-like typechecking perversion. ;)
05:25:05 <dramforever> wait s/Restricted/Maybe Restricted/
05:25:08 <dramforever> looks good enough
05:25:36 <dramforever> construct should check the graph against the schema, and construct only if it's correct
05:26:03 <EvilMachine> I just want to stop the user from giving input, when storing it in the resulting type it not possible at all. Otherwise, any structure and content is fine.
05:26:32 <dramforever> that doesn't look very easy
05:26:46 <dramforever> in that case my approach probably won't work
05:26:47 <dramforever> =(
05:27:10 <EvilMachine> dramforever: It really seems to solve it. :) Although in a manner of speaking, I’m doing the typechecking myself. :))
05:27:23 <dramforever> "type" hmm...
05:28:13 <EvilMachine> dramforever: Hmm, how about invoking Haskell’s type checker at runtime, like a compiler would do? :)
05:29:29 <Sindriava> How do I get rid of the warning about uninitialised fields of a structure?
05:29:37 <Sindriava> (inb4 by initialising them)
05:29:55 <dramforever> -fno-warn-...something
05:30:37 <Sindriava> I'm making a quasiquoter, and the guide says to do QuasiQuoter { quoteExp = … }, but that gives me the warning. Should I initialise them to *something*, or somehow signal to GHC that it's okay if they're left uninitialised?
05:31:09 <dramforever> Sindriava: initialize them to something that signals a more appropriate error
05:31:25 <Sindriava> dramforever: What would that be, in case of QuasiQuoter?
05:31:30 <dramforever> like "quasiquoter foo cannot be used to bar"
05:31:36 <EvilMachine> Sindriava: Ah, you mean on reading. That I already solved. The user doesn’t get to access them directly. He only gets a hold of available fields by querying them.
05:31:58 <Sindriava> dramforever: Ah, I see!
05:32:07 <dramforever> also the flag is called -fno-warn-missing-fields
05:32:11 <Sindriava> EvilMachine: I'm not sure I follow
05:32:14 <dramforever> pretty straightforward, huh =P
05:32:40 <Sindriava> dramforever: Yeah, I'm aware of that, but that's not really fixing the issue :) If I was using the stuff properly, I shouldn't get a warning at all
05:32:48 <dramforever> exactly
05:32:55 <EvilMachine> Sindriava: Probably because we’re talkingf about analogies of anaglogies of what I originally meant. :)
05:33:10 <dramforever> http://xyproblem.info
05:33:19 <EvilMachine> Sindriava: OOh, oops!
05:33:31 <Sindriava> Yeah, I figured I'm not who you meant to mention :D
05:33:47 <EvilMachine> Sindriava: I didn’t notice you were asking a different question! Forget everything I said. Nevermind. :)
05:33:49 <dramforever> me?
05:33:58 <dramforever> no I have no more suggestions
05:34:08 <Sindriava> dramforever: No, EvilMachine :D
05:34:22 <Sindriava> dramforever: XY problem is fair enough, I'll try to be more specific next time :)
05:34:38 <dramforever> Sindriava: no that xyproblem.info link is for EvilMachine
05:34:47 <Sindriava> @_@
05:34:52 <dramforever> "talkingf[sic] about analogies of anaglogies of what I originally meant."
05:35:17 <EvilMachine> Sindriava: Okay, let the machine seed of insanity grow inside of you then. Muhahahahahahahahaaa! *makes machine noises*
05:35:35 <Sindriava> Anyways, QuasiQuoting is fun
05:35:51 <Sindriava> glAttachShader program =<< [vsh| … |]
05:36:14 <EvilMachine> dramforever: You’ve helping me a lot though. :)
05:36:20 <dramforever> =) yw
05:36:43 * EvilMachine is shocked by his bad English. ^^
05:37:06 <dramforever> don't worry that happensf to everybody
05:37:12 <dramforever> =P
05:37:18 <EvilMachine> dramforever: :D
05:37:34 * dramforever isn't a native english speaker either
05:38:13 <EvilMachine> dramforever: Man, that site is about a problem I *always* failed to find words for! Thanks!!
05:38:22 <dramforever> =)
05:39:47 <EvilMachine> dramforever: You’re right. I used analogies, because explaining the real thing would take forever and cause us to get lost in there. But yes, the analogy might be rather imperfect.
06:18:26 <browndawg> Hey, I have a n00b question about lazy evaluation. Suppose I have a function `f`, that given a number x, evaluates to the collatz sequence starting at x. Does `length $ f 10` allocate the entire list first, and then compute the length, or will it do it in constant memory?
06:19:31 <bennofs> browndawg: it should do it in constant memory (as long as you only use the list once, as in this case, the start of the list will be garbaged-collected while evaluating length)
06:19:34 <browndawg> I'm only concerned with lengths, and will obviously write a collatz_sequence_length that simply computes the length of the chain in constant space without allocating a long list, but I'm wondering if lazy evaluation will let me get away with just calling the length function on a function that generates a list?
06:19:37 <dramforever> constant memory
06:20:53 <dramforever> it might take a bit more memory than collatz_sequence_length, because of the need to throw away generated list cells
06:21:03 <dramforever> but the compiler might be able to optimize that away
06:21:28 <browndawg> aha! so something like max $ map (length . collatz_sequence) [1..1000000]
06:21:29 <dramforever> side note: in haskell we usually use camelCase names
06:21:35 <browndawg> will let me
06:21:47 <dramforever> what about this
06:22:02 <browndawg> nothing this is project euler
06:22:12 <browndawg> in other languages I just compute the length of the chain
06:22:43 <browndawg> but I wasn't sure if haskell woudl let me get away with a general purpose (length . collatzSeq) or something
06:22:55 <browndawg> nice
06:23:13 <browndawg> thanks for clearing that up, bennofs, dramforever
06:23:23 <dramforever> browndawg: do notice that things could go wrong
06:23:39 <dramforever> for example, if you are holding on to the list longer than necessary
06:23:40 <joco42> basic question: what does INLINE mean in this code http://hackage.haskell.org/package/hxt-9.3.1.15/docs/src/Control-Arrow-ListArrow.html#LA ?
06:23:52 <dramforever> or just building up unevaluated values
06:23:58 <joco42> is it standard haskell?
06:24:05 <browndawg> dramforever: yeah, I get how the GC might slow things down
06:24:07 <dramforever> in both cases, the memory usage will be linear
06:24:49 <bennofs> joco42: It's a GHC pragma
06:25:03 <bennofs> joco42: it tells GHC: always inline this function
06:25:09 <dramforever> browndawg: no not gc
06:25:15 <browndawg> dramforever: ...
06:25:19 <joco42> bennofs: thanks !
06:25:37 <dramforever> I mean it could cause problems if the list cannot be freed
06:25:39 <joco42> bennofs: google explains it : https://downloads.haskell.org/~ghc/7.0.4/docs/html/users_guide/pragmas.html
06:25:51 <dramforever> because of another reference to it
06:25:56 <joco42> google is an oracle
06:26:08 <bennofs> joco42: yeah. pay attention that you found the reference for GHC 7.0.4 (current is 7.10)
06:26:28 <dramforever> actually the gc is specially optimized code with lots of garbage
06:26:33 <dramforever> like length . collatz
06:26:59 <joco42> bennofs: oh yeah, indeed 
06:28:08 <dramforever> s/code/for code/
06:30:52 <totalconfusion> what's haskell?
06:31:01 <bennofs> totalconfusion: a programming language
06:31:15 <totalconfusion> how is it different from say C or python?
06:32:19 <dramforever> totalconfusion: it's (almost) purely functional
06:32:23 <bennofs> totalconfusion: it has non-strict evaluation, cleanly separates side-effect and side-effect-free code (it can guarrante that some part of your code doesn't modify global state) and generally has a good type system
06:33:48 <bennofs> > putStrLn "Hello" -- a side effect. lambdabot [IRC bot evaluating almost arbitrary haskell code] can detect this and doesn't evaluate it
06:33:50 <lambdabot>  <IO ()>
06:34:10 <bennofs> s/evaluate/execute
06:34:32 <dramforever> s/can(.*)/deals with this differently, just because it has a different type
06:38:26 <quchen> This lens tutorial pull request rejection is really sad.
06:39:13 <bennofs> quchen: what do you think about including it in microlens, lens-family or lens-simple instead? The types it describes are mostly not more general than what is available in those libraries
06:39:19 <dramforever> however to someone not very familiar with haskell, do expect totalconfusion at the beginning
06:39:24 <dramforever> =P pun
06:39:59 <quchen> bennofs: I think that's just as bad as posting it anywhere else. lens is the standard lens package, and that's where a standard introduction should go.
06:40:24 <quchen> "post it separately" is just ridiculous. That's like writing "look it up on the internet" and calling that documentation.
06:40:39 <totalconfusion> dramforever, hahaha i see what you did there
06:41:06 <bennofs> quchen: well, the question is, why does lens have to be the standard lens package? Couldn't we have those simpler lens-subset libraries be the default (and easier to get started for beginners), and let lens be the "advanced" toolbox that you go to when you've at least grasped Lens/Traversal and need more? 
06:41:37 <quchen> That's not for the authors to decide. When people think about a lens package they think about the "lens" package.
06:41:53 <quchen> History has brought us here, and now we can't change it.
06:42:20 <bennofs> quchen: what about adding a link from the lens package to the simpler lens-subset packages with a note that if you don't need all the functionality, you can use those instead and they are easier for learning?
06:43:13 <bennofs> I do not see why you would ever need to use the lens package except if you need Prisms/Isos or like all those *Of functions for traversals and folds
06:43:18 <mniip> > [1..] >>= join replicate
06:43:20 <lambdabot>  [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,9...
06:43:25 <mniip> fancy
06:43:38 <bennofs> (or any of the adhoc overloaded things like reversed for Text etc)
06:43:43 * hackagebot publicsuffix 0.20150808 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20150808 (wereHamster)
06:44:07 <quchen> bennofs: Maybe. I'm just annoyed by the reasoning of the package maintainers.
06:44:19 <bennofs> quchen: I think it's easier for most people to start with the (a -> f a) -> s -> f s representation anyway
06:44:44 <bennofs> quchen: seeing p a (f b) -> q s (f t) is probably not helping as a beginner :p
06:45:39 <quchen> And of course that's because the maintainers would find it deeply insulting to write documentation for that, a la "for the most part, imagine p/q be (->) and ignore the f"
06:46:05 <bennofs> quchen: and also, lens has all these type synonyms...
06:46:44 <bennofs> quchen: and tricks for making inference better where when you look up a type synonym you end up on a page explaining a Bazaar which is just a Kleene something
06:47:46 <bennofs> quchen: but IMO, at least understanding the (a -> f a) -> (s -> f s) representation is important (with the f! using lenses directly is quite useful at times)
06:48:43 * hackagebot cabal-debian 4.30.2 - Create a Debianization for a Cabal package  https://hackage.haskell.org/package/cabal-debian-4.30.2 (DavidFox)
06:48:54 <dramforever> so the question is: why did we choose that representation
06:48:56 <bennofs> quchen: on some parts, I can understand the reasons for the rejection. The tutorial only describes a very small subset of lens. 
06:49:01 <dramforever> yes, it may be nice
06:49:17 <quchen> bennofs: It's a tutorial, not "lens, an introduction" hardcover.
06:49:34 <quchen> The purpose of it is having someone with no idea understand basic usage.
06:49:49 <bennofs> dramforever: because it allows stuff like lens-simple or lens-family or microlens to exist and *be compatible* with the 'lens' library?
06:49:52 * dramforever is always hoping for something like Lens: A Complete Guide
06:49:54 <quchen> It is not about documenting the mathematical effort that run into the library, or justifying the design decisions.
06:49:57 <dramforever> bennofs: =)
06:50:06 <bennofs> dramforever: and it allows composing Lens and Traversal and getting a Traversal?
06:50:30 <quchen> Pipes.Tutorial doesn't talk about bidirectionality. It doesn't go over all the different categories.
06:50:39 <quchen> I can read it and "do" pipes. 
06:51:22 <bennofs> quchen: right, but it at least explains the main principle of the library. Maybe the reason that this is so complicated for lens is that there are really many, important on it's own part, things. I wouldn't say that Prisms are fundamentally less important than Lenses or Traversals, for example
06:51:31 <dramforever> quchen: well yeah the most useful parts are probably enough
06:52:00 <bennofs> quchen: this tutorial seems more like it only describes Control.Lens.Lens, not even the whole Control.Lens hierarchy
06:53:20 * dramforever wonders if that tutorial existed long before traversals, prisms, etc. are added
06:53:30 <dramforever> *were added
06:54:02 <bennofs> dramforever: the problem with prisms is that they don't fit into the (a -> f a) -> s -> f s pattern :)
06:55:06 <nolrai66> That patern is lens isnt it?
06:55:23 <dramforever> LensLike?
06:55:27 <dramforever> @hoogle LensList
06:55:28 <lambdabot> No results found
06:55:32 <dramforever> @hoogle LensLike
06:55:32 <bennofs> nolrai66: Getter/Lens/Traversal/Fold, yes
06:55:32 <lambdabot> No results found
06:56:40 <nolrai66> Whats a Traversal again?
06:56:52 <dramforever> setter + fold
06:57:13 <bennofs> nolrai66: Traversal is like a lens but with multiple results. If you think of a lens as "pointing"/"focusing" one field in your structure, Traversal can focus multiple things
06:58:06 <bennofs> nolrai66: so instead of view/over you have toListOf, which returns a list of all the values of the targets of the traversal, and over, which will update all targets of the traversal (not just a single one like lens does) 
06:58:44 * hackagebot webkitgtk3 0.14.1.0 - Binding to the Webkit library.  https://hackage.haskell.org/package/webkitgtk3-0.14.1.0 (HamishMackenzie)
06:58:44 <dramforever> @hoogle Traversal +lend
06:58:45 <lambdabot> Could not find some databases: lend
06:58:45 <lambdabot> Searching in:
06:58:45 <lambdabot>   .
06:58:46 * hackagebot webkit 0.14.1.0 - Binding to the Webkit library.  https://hackage.haskell.org/package/webkit-0.14.1.0 (HamishMackenzie)
06:58:49 <dramforever> arrgh
06:58:57 * dramforever stops trying
06:59:09 <bennofs> > ((2,3),[1,2,3,4,5]) & beside _2 traverse +~ 1 -- Example
06:59:11 <lambdabot>  ((2,4),[2,3,4,5,6])
06:59:28 <dramforever> :t beside
06:59:28 <bennofs> that was a traversal that focused everything except the first "2"
06:59:29 <lambdabot> (Applicative f, Applicative (Data.Profunctor.Rep.Rep q), Data.Profunctor.Rep.Representable q, Data.Bitraversable.Bitraversable r) => Optical p q f s t a b -> Optical p q f s' t' a b -> Optical p q f (r s s') (r t t') a b
06:59:53 <bennofs> dramforever: beside :: Traversal a b -> Traversal c d -> Traversal (a,c) (b,d) in this example
07:00:06 <dramforever> yeah I know
07:00:14 * dramforever knows some lens jargon
07:00:41 <bennofs> oh, it works for any Bitraversable, that is nice
07:03:08 <bennofs> I wonder how that is different from:
07:03:10 <bennofs> :t alongside
07:03:26 <lambdabot> LensLike (Control.Lens.Internal.Getter.AlongsideLeft f b') s t a b -> LensLike (Control.Lens.Internal.Getter.AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
07:03:49 <bennofs> ah, it has a return tuple while the former doesn't
07:07:23 <haskell364> Am I going to get insulted for talking about non-Haskell languages here?
07:07:43 <Clint> would you like to be?
07:07:52 <bennofs> haskell364: if it's too offtopic, try #haskell-blah? 
07:08:18 <dramforever> haskell364: if it's related to haskell, okay
07:11:35 <brtmr> What is (in your experience) the fastest Map-Type in Haskell (with regards to lookup)? I need a map with keys and values of type Word16, to look up field lengths for a parser. So far I am using Data.HashMap.Strict. Can I do better?
07:12:17 <wei2912> brtmr: are you certain you need the speed? have you done any benchmarking?
07:15:26 <brtmr> wei2912: Yes, I have done some measurements, and tweaked some of the more obvious Performance issues. I am dealing with rather large files, so every improvement is welcome.
07:16:03 <dramforever> brtmr: do you need updating?
07:16:10 <dramforever> or the map is static?
07:17:54 <brtmr> dramforever: no. i generate the map from the file header, and then just use it to look up field sizes in the file body. The map is static.
07:18:09 <dramforever> Array?
07:19:59 <brtmr> dramforever: My keys are not contiguous.
07:20:15 <dramforever> brtmr: yes but lookup is really fast
07:20:39 <dramforever> and Word16 is only 0-65535, so it's not very much RAM wasted
07:20:51 <dramforever> that is, if you really want the speed
07:22:49 <brtmr> dramforever: that is a good point. and the upper bound for my keys is way lower than 64k, so i might just get away with that. thanks!
07:23:02 <dramforever> =) you're welcome
07:29:38 <catgocat> I can't access freenode IRC with hexchat.. it's saying it can't connect
07:29:42 <catgocat> is this a known issue'
07:30:05 <catgocat>  Looking up chat.freenode.net * Unknown host. Maybe you misspelled it?
07:30:32 <nolrai66> I am on hexchat right now.
07:30:40 <catgocat> I can't connect to it..
07:30:49 <catgocat> freenode doesnt work
07:31:05 <catgocat> help
07:31:07 <Cale> catgocat: What OS are you running?
07:31:10 <catgocat> Windows 10
07:31:17 <catgocat> It was working before but not anymore
07:31:23 <catgocat> I have already uninstalled it
07:31:30 <Cale> hmm, can you open a terminal and ping chat.freenode.net ?
07:31:35 <catgocat> *reinstalled
07:31:39 <catgocat> ok
07:31:52 <catgocat> Ping request could not find host chat.freenode.net. Please check the name and try again.
07:31:54 <Cale> (I don't know if Windows has a host command, but if you were on linux, I'd ask you to use that instead)
07:32:18 <Cale> Right, so it has nothing to do with the irc client. Your DNS server for some reason is missing that entry.
07:32:24 <catgocat> how can I fix it?
07:32:39 <Cale> Well, using a different DNS server would work.
07:32:47 <catgocat> what do you mean a different dns?
07:33:24 <Cale> The server your computer uses to translate host names like chat.freenode.net into IP addresses like 31.13.222.109
07:33:40 <catgocat> I am a noob in stuff like this
07:33:42 <catgocat> how do I do that??
07:34:10 <Cale> I haven't used Windows since, like, Windows 98, so the procedure is probably quite different.
07:35:52 <Cale> catgocat: here's a tutorial http://solverbase.com/w/Windows_10:_Changing_DNS_Servers
07:38:07 <catgocat> Cale: it worked
07:38:13 <catgocat> but changing DNS doesn't affect performance?
07:38:20 <catgocat> aren't I exposed to others??
07:39:24 <Cale> It may affect performance, and your DNS server will get many requests from your computer to translate host names, so sure, there might be some privacy concerns about which DNS servers you choose.
07:40:30 <Cale> There's no particular guarantee that whatever DNS server you were using is any faster or slower than the one you just changed to though. Given that it wasn't resolving chat.freenode.net at all, it seems like it's possibly kind of unreliable.
07:41:02 <catgocat_> is there something like `some` ?
07:41:07 <catgocat_> all checks for everything
07:41:17 <Cale> :t any
07:41:18 <lambdabot> Foldable t => (a -> Bool) -> t a -> Bool
07:44:27 <catgocat_> any does the job
07:49:01 <catgocat_> Is there a maximum for how many commas/arguments the function (,,) can have?
07:49:12 <catgocat_> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
07:49:13 <lambdabot>     A 80-tuple is too large for GHC
07:49:13 <lambdabot>       (max size is 62)
07:49:13 <lambdabot>       Workaround: use nested tuples or define a data type
07:49:34 <catgocat_> Why 62?
07:49:58 <Cale> It's arbitrary.
07:50:38 <Cale> imo, the limit should be like 2 or 3
07:50:52 <Cale> Maybe 4 if we want to be generous
07:50:59 <catgocat_> It's arbitrary?
07:51:04 <catgocat_> How is it arbitrary?
07:51:28 <silver> getRandomNumber() {return 62;}
07:51:50 <bennofs> -- choosen by fair dice roll (I want to see that dice!)
07:51:53 <catgocat_> no way it's defined like that
07:52:05 <quchen> catgocat_: The code says that more than 62 makes GHC segfault for some reason.
07:52:16 <Myrl> silver: lol
07:52:22 <Myrl> silver: xkcd. <3
07:52:25 <nullvoid8> Max tuple size is defined by the Haskell report to be implementation dependant. So ghc chose 62
07:52:44 <bennofs> Maybe it has to do with the encoding of record selectors and there can be at most 62 record fields?
07:53:34 <nullvoid8> Bennofs: http://www.thediceshoponline.com/images/productimages/4413_1_big.jpg
07:53:36 <catgocat_> Why 62? wtf?
07:53:43 <nullvoid8> That die
07:53:44 <Cale> bennofs: Yeah, it's possible that the bug which is apparently preventing further tuple definitions has something to do with memory layout of the constructors.
07:53:46 <monochrom> is it important?
07:53:48 <catgocat_> what are the usages for 62-tuples?
07:53:54 <Cale> catgocat_: Essentially none.
07:54:29 <Cale> catgocat_: You'll probably never even see a 5-tuple in real code, since by that point, you're really better off defining your own data type.
07:54:32 <catgocat_> I have always wondered: doesn't haskell stackoverflow?
07:54:42 <catgocat_> with all the recursion..
07:55:11 <Cale> There is a stack with GHC, and it can overflow, but it's not really a call stack.
07:55:11 <monochrom> have you also wondered: doesn't haskell heapoverflow? with all the allocations
07:55:33 <monochrom> I mean: why all the focus on stackoverflow and no love for heapoverflow?
07:55:44 <monochrom> heapoverflow is feeling ignored now
07:55:54 <catgocat_> but how does haskell handle with all the recursion?
07:56:01 <catgocat_> how can it not overflow
07:56:13 <Cale> It would be more appropriate to call it a pattern match stack, as it mostly consists of case expressions which are waiting for their scrutinee to be sufficiently evaluated to match a pattern.
07:56:23 <Cale> Recursion itself doesn't necessarily use the stack.
07:56:34 <Cale> Because it is not a call stack.
07:56:51 <Cale> (and even the very notion of "call" is a bit weird)
07:57:26 <Cale> The other thing which goes on the stack are application terms which are waiting for the function to be sufficiently evaluated to apply (i.e. to reduce to a lambda, effectively)
07:58:11 <Cale> It's very unusual apart from in contrived situations (I've never seen it happen in a real program) to get a stack overflow related to entries of that sort though.
07:58:33 <Cale> So if you're getting a stack overflow, the chances are very high that it's from too many nested pattern matches.
07:58:48 <nullvoid8> Cale: I thought the point of the stg machine is that there are no application nodes
07:59:08 <nullvoid8> Or one of the points
08:00:03 <tmtwd> data Tree a = EmptyTree | Node a (Tree a) (Tree a), why don't I need to cons Node a onto (Tree a) (Tree a) in this case?
08:00:16 <tmtwd> Does it just read it as a list of 3 elements?
08:00:38 <ggole> tmtwd: no
08:00:47 <nkaretnikov> how do i create an unboxed Word, i.e., Word#?  is there anything like 1# for Int#s?
08:00:50 <ggole> It's three things all at once
08:00:50 <silver> no?
08:00:57 <tmtwd> oh ok
08:01:03 <monochrom> "Node" is already your "cons". but I don't understand the question.
08:01:18 <bennofs> Cale: hmm, does GHC do special optimizations for stuff like case (f ...) of False -> ...; True -> ...? 
08:01:20 <nullvoid8> Node :: a -> Tree a -> Tree a -> Tree a
08:01:26 <tmtwd> monochrom, i'm just a beginner of haskell trying to get a better grasp
08:01:43 <tmtwd> Is Node a function or a data type?
08:01:53 <mniip> nkaretnikov, it might or might not be 1##
08:01:56 <geekosaur> tmtwd, what nullvoid8 just said. it acts like a function (it's a data constructor)
08:01:56 <bennofs> Cale: (so it doesn't have to push 2 continuations in that case but can just use a conditional jump after f returns)
08:01:59 <monochrom> "Node" is not a type.
08:02:10 <mikeplus64> tmtwd: Node is a data constructor; it constructs something of type Tree a
08:02:20 <geekosaur> :t Just
08:02:20 <monochrom> "Node" is a data constructor. you can also use it as a function.
08:02:21 <lambdabot> a -> Maybe a
08:02:27 <tmtwd> oh I see
08:02:27 <mikeplus64> it's also a function, that takes an 'a', a 'Tree a' and another 'Tree a'
08:02:31 <geekosaur> ^ another data constructor that takes a value
08:02:36 <nullvoid8> Node is a Data constructor, like a function where you can know what arguments it was called with
08:03:12 <tmtwd> Oh, so Node accepts a, Tree a, Tree a and returns Tree a
08:03:23 <mikeplus64> yeah
08:03:46 <monochrom> do you already know "data Maybe a = Nothing | Just a"?
08:04:11 <Cale> bennofs: I'm not sure if that maybe ends up being simplified further by later stages of compilation, but at least in my mental model of what GHC is doing, that case waits on the stack for (f ...) to be evaluated and then when it resumes, there's a branch.
08:04:35 <Cale> bennofs: There are things like constructor specialisation which mess with that a bit.
08:04:51 * bennofs should read the STG paper
08:05:37 <nkaretnikov> mniip: looks like you're right.  ty
08:08:14 <tmtwd> Node a :: a -> Tree a -> Tree a-> Tree a , how do we know that this accepts a, Tree a, and Tree a, and returns Tree a? (and not that it accepts a, and returns Tree a, Tree a, Tree a?)
08:08:17 <Cale> bennofs: The STG paper is a good place to start, especially the overview about various possible evaluation models at the start, but there's also been so much that's happened after that, and it's hard to keep up with what GHC actually does now :)
08:09:59 <geekosaur> tmtwd, because the latter is a -> (Tree a, Tree a, Tree a)
08:10:06 <mikeplus64> tmtwd: Node :: a -> Tree a -> Tree a -> Tree a. you can read it as a function that takes an a, and returns a function that takes a Tree a, and returns a functino that takes a Tree a, that returns a Tree a -- look up "currying"
08:10:19 <geekosaur> that said, you have your finger on an important but not closely related ocncept there
08:10:33 <tmtwd> oh yeah, I  remember reading about that
08:10:36 <geekosaur> because you *can* view it the way you said --- and that leads to partial application
08:10:37 <monochrom> A -> (B -> C)
08:10:59 <tmtwd> ohhh
08:11:18 <tmtwd> sweeet <3
08:11:39 <hodwik> Can anyone recommend a Haskell tutorial for a dense person
08:12:17 <monochrom> have you tried the recommendations in https://github.com/bitemyapp/learnhaskell ?
08:16:11 <hodwik> Thanks monochrom
08:33:47 * hackagebot moesocks 0.1.0.12 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.12 (JinjingWang)
08:57:02 <isBEKaml> hi, why does cabal install off a sandbox not detect other packages in the sandbox?
08:58:15 <isBEKaml> for instance, I see these kind of errors: https://gist.github.com/anonymous/5890cd187274096a5841
09:00:03 <Welkin> isBEKaml: did you run `cabal hc-pkg check`?
09:00:19 <Welkin> er
09:00:24 <kadoban> isBEKaml: Looks to me like something is broken … I've never seen those messages which messing with sandboxes.
09:00:24 <Welkin> isBEKaml: did you run `cabal sandbox hc-pkg check`?
09:01:31 <isBEKaml> Welkin: wow... I see a heavy data dump complaining about missing files. :-)
09:02:13 <isBEKaml> I was actually searching for that command.. trying various combinations of ghc-pkg check [-F sandbox-packag-db]
09:02:20 <Welkin> yeah
09:02:33 <Welkin> hc-pkg is the cabal sandbox version of ghc-pkg
09:05:43 <bennofs> Is there a clever way to implement this: given a template list ts, and another list bs of same length, rearrange bs such that any element which is also in ts appears at the same index as in ts 
09:06:17 <bennofs> FWIW, in practice the length of both lists will always be 4
09:07:26 <isBEKaml> bennofs: you want the behaviour of a `diff` command?
09:07:28 <Welkin> bennofs: IntMap
09:07:35 <bennofs> so given [4,3,1,2] and [2,4,5,10], the operation would output [4,10,5,2]
09:07:58 <bennofs> ([4,5,10,2] would also be valid) ([4,3,1,2] is ts the other is bs)
09:08:44 <kadoban> Throw all of bs into a multiset, separate them out into <is in ts> and <isn't in ts>, then go through ts and at each step pick from the appropriate multiset.
09:09:40 <kadoban> I didn't think through corner-cases, especially where their lengths differ. I'm not sure it's well specified yet if their lengths differ.
09:10:44 <zftzftugzuz> hi, i dont understand the following statement (from Real World Haskell, p110): "Consider the value (1+2):(3+4):[]. If we apply seq to this, it will evaluate the (1+2) thunk. Since it will stop when it reaches the first (:) constructor, it will have no effect on the second thunk." then it says "The same is true for tuples: seq ((1+2), (3+4)) True will do nothing to the thunks inside the pair, since it immediately hits the pair's
09:11:32 <zftzftugzuz> In the list example seq also hits a constructor, doesnt it? I'm confused now..
09:12:25 <zftzftugzuz> Why in the list example it evaluates the (1+2) thunk and in the tuple it doesn't?
09:12:28 <bennofs> kadoban: right. It's even easier: compute elements in bs that are not in ts   and then go through ts, leaving every element which is also in bs as-is, and taking one element from the previously-computed "new elements" if it is not
09:13:19 <jmcarthur> Are we Blub programmers? If we are, what are the languages we aren't paying enough attention to? I feel like dependently typed languages are too obvious to be an answer to this question, but it's all I can think of.
09:13:43 <bennofs> jmcarthur: concatenative programming languages? :P
09:13:53 <Gurkenglas> bennofs, is it guranteed that ts and bs only contain one of each value? Is the value space small?
09:13:53 <kadoban> bennofs: Wouldn't you want to do it the other way, leave every element which /isn't/ in ts as-is? Otherwise what if two elements are in both ts and bs, but they're in the wrong order?
09:14:29 <bennofs> Gurkenglas: yes, and yes ([0..64])
09:14:39 <jmcarthur> bennofs: Heh, my gut reaction was to say "that's just point free programming, isn't it?", but I suppose that would make me fit the mold of a Blub programmer.
09:14:43 <Gurkenglas> (not ..63?)
09:14:53 <bennofs> Gurkenglas: well, yes. ..63
09:15:20 <bennofs> kadoban: I go through ts and leave every element which is also in bs as-is
09:15:49 <berdario> Uhm, I'm trying to use warp-tls 's tlsSettingsMemory ... I base64 decode the .pem files and put the content in a bytestring in my program... it compiles fine, but then it fails at runtime with "no keys found"
09:16:25 <bennofs> so basically, I got an old and a new list, and for elements which are both in old and new, I don't want to change their position in the resulting list. For elements which are in new but not in old, I want to place them in the spots of the elements in old which are no longer in new
09:16:28 <berdario> does someone have any idea how to check the proper format in which the bytestring is expected?
09:16:43 <kadoban> bennofs: Maybe I'm missing something, that sounds like it won't give the correct order necessarily. But if you think so.
09:16:44 <berdario> this should be the code that is eventually called: https://hackage.haskell.org/package/x509-store-1.5.0/docs/src/Data-X509-Memory.html#readKeyFileFromMemory
09:16:54 <jmcarthur> I'm asking because since I learned Haskell so long ago, I stopped looking for ever more powerful languages (with just the occasional toe-dip into dependent types).
09:17:14 <bennofs> jmcarthur: prolog? :P
09:17:15 <berdario> but I don't know enough about x509 to grok that
09:17:57 <isBEKaml> zftzftugzuz: Asking questions about `seq` is fairly controversial here and I'm not keen on seeing another discussion (TBH). See here, if you need info and esp, read notes about the controversy there: https://wiki.haskell.org/Seq
09:18:33 <Cale> isBEKaml: Wait, what? Asking questions about seq is controversial since when?
09:18:56 <bennofs> jmcarthur: perhaps looking for interesting languages in https://en.wikipedia.org/wiki/Programming_paradigm can serve as inspiration?
09:19:34 <isBEKaml> Cale: I once asked that question and quickly regretted it :-) And, it was not because the discussion was over my head - rather, it was all getting side-tracked and going nowhere. (That was a few years ago)
09:19:37 <Gurkenglas> One way would be to have a 64-vector partially filled with the index of each t in ts, a (length bs)-vector partially filled with each b that is in the 64-vector, then filled up the rest of the way with the rest, but this sounds very imperative
09:19:55 <Cale> isBEKaml: Weird
09:20:10 <Welkin> seq is fundamental in Parallel and Concurrent Haskell
09:20:16 <bennofs> zftzftugzuz: sounds like a bug in RWH
09:20:22 <Welkin> I don't see any controversy...
09:20:33 <Cale> zftzftugzuz: You're correct. The (1+2) wouldn't be evaluated, unless something is missing from your description of what RWH says about it.
09:20:36 <bennofs> > undefined:(3+4):[] `seq` 5
09:20:40 <lambdabot>  5
09:20:52 <Cale> ^^ and yeah, you can check like that
09:20:56 <bennofs> zftzftugzuz: you can clearly see the value in the undefined spot is not evaluated
09:21:28 <jmcarthur> isBEKaml: Perhaps there was some implication made by your question then? I don't think seq is a controversial topic. There are a few aspects about it that people don't quite agree on, but nothing big and explosive that I'm aware of.
09:21:49 <jmcarthur> bennofs: thanks for your suggestions
09:22:58 <Gurkenglas> bennofs, you could apply sortBy (compare `on` snd) $ zip [0..] ts, sort bs, solve the problem on sorted lists by merging, then sort the result by fst.
09:23:49 * hackagebot mtl-unleashed 0.3.1 - MTL classes without the functional dependency  https://hackage.haskell.org/package/mtl-unleashed-0.3.1 (DavidFox)
09:25:16 <jmcarthur> zftzftugzuz: i agree with bennofs. i think rwh is wrong.
09:28:08 <zftzftugzuz> bennofs: Cale thanks for making this clear to me
09:31:08 <bennofs> thanks for all the suggestions. This implementation seems to work:
09:31:10 <bennofs> > let f ts bs = let bs' = S.fromList bs; ts' = S.fromList ts; new = bs' `S.difference` ts'; kept = bs' `S.intersection` ts' in fst $ foldr (\x (res,stack) -> if x `S.member` kept then (x:res, stack) else (head stack:res, tail stack)) ([], S.toList new) ts in f [4,3,1,2] [2,4,5,10]
09:31:15 <lambdabot>  [4,10,5,2]
09:32:03 <bennofs> could be improved with MonadSupply
09:32:59 <Gurkenglas> What's the conventional way to merge two lists without explicit recursion?
09:33:14 <bennofs> Gurkenglas: nested foldr?
09:33:46 <mauke> (++)
09:34:30 <bennofs> Gurkenglas: foldM with MonadSupply :p
09:34:36 <Gurkenglas> The type signature I want would probably be... (a -> b -> c -> (Bool, c)) -> [a] -> [b] -> c -> c
09:34:59 <Gurkenglas> Where the Bool says which list is to be beheaded
09:35:08 <__momak35NS> youtube movie that will change your life: https://www.youtube.com/watch?v=dcl6tl2FC98
09:36:28 <Welkin> Gurkenglas: zip?
09:36:36 <Gurkenglas> (Hmm, what happens when one list is empty but the other isn't?)
09:36:47 <Gurkenglas> Welkin, I sometimes want to behead only one list. Sometimes both.
09:36:59 <Cale> __momak35NS: This isn't an appropriate channel to post youtube videos of kittens. This one is for topics related to Haskell.
09:37:35 <Zemyla> Cale: Can I post Youtube videos of kittens learning Haskell?
09:37:51 <ackthet> Cale: he left
09:38:01 <Cale> ackthet: I noticed after I pressed enter.
09:38:05 <Gurkenglas> ...I'll just implement my explicit recursion and maybe there'll be librarizations afterward.
09:38:05 <ackthet> ahh hehe
09:39:15 <Zemyla> Huh, so a primitive recursive function is one where, if you pass it arguments as Church integers, can be implemented without recursion?
09:39:37 <safinaskar> template haskell. what is default value of Strict type?
09:40:20 <Cale> safinaskar: NotStrict ?
09:41:34 <Zemyla> So if we have newtype Church = Church { runChurch :: forall a. (a -> a) -> a -> a }, and it's a Num...
09:42:56 <Zemyla> Then fact n = snd $ runChurch n (\(i, f) -> (i + 1, f * i)) (1, 1)
09:43:10 <Zemyla> And it's not recursive at all.
09:43:16 <safinaskar> Cale: are you sure?
09:43:38 <Cale> safinaskar: Well, what do you mean by "default value"?
09:43:49 <Cale> safinaskar: NotStrict means that there's no ! before the field.
09:46:35 <mjrosenb> Are there any exception handling mechanisms that aren't in IO?
09:46:53 <bennofs> mjrosenb: IO exceptions can only be handled in IO
09:48:22 <mjrosenb> are there non-IO exceptions
09:48:23 <mjrosenb> ?
09:48:37 <hpc> no, but there are things that behave a bit like exceptions
09:49:12 <hpc> for instance, Maybe and Either can be used for short-circuiting computations
09:49:33 <mjrosenb> so what is
09:49:36 <mjrosenb> > head []
09:49:37 <lambdabot>  *Exception: Prelude.head: empty list
09:49:56 <hpc> that's an error
09:50:07 <hpc> which is technically an exception you can catch in ghc, but don't ever try
09:50:10 <hpc> that way lies madness
09:50:26 <mjrosenb> :-(
09:50:31 <geekosaur> it is possible to catch it but you must be in IO
09:50:55 <geekosaur> if you want something vaguely exception like but not in IO, your choices are things like Maybe/Either (possibly via monadic interface) or Cont
09:51:11 <hpc> the problem with those sorts of things is that because of laziness, you never know where the exception underneath is going to actually be thrown
09:51:54 <geekosaur> and that, yes; even in IO a common source of errors is being too lazy so the exception you were expecting is thrown after your catch has finished
09:58:51 * hackagebot cabal-bounds 0.9.5 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  https://hackage.haskell.org/package/cabal-bounds-0.9.5 (DanielTrstenjak)
10:04:03 <Gurkenglas> Why is @more so slow?
10:07:42 <Zemyla> geekosaur: For some reason, I'm thinking about like why the methods in Enum are so stupidly non-total, and whether unsafePerformIOed exception wrappers would help.
10:08:51 * hackagebot TypeNat 0.4.0.0 - Some Nat-indexed types for GHC  https://hackage.haskell.org/package/TypeNat-0.4.0.0 (alexvieth)
10:09:29 <Zemyla> Like, toEnumM !i = unsafePerformIO $ catch (Just <$> evaluate (toEnum i)) (\e -> return $ const Nothing (e :: SomeException))
10:10:46 <anoe> @listmodules
10:10:46 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
10:12:14 <anoe> on the lambdabot page, RSS  subscription is mentionned. Which module enables that ?
10:13:30 <Gurkenglas> > bennofs [4, 3, 1, 2] [2, 4, 5, 10]
10:13:31 <lambdabot>  [4,10,5,2]
10:13:35 <Gurkenglas> http://lpaste.net/138279
10:13:51 * hackagebot xcffib 0.3.5 - A cffi-based python binding for X  https://hackage.haskell.org/package/xcffib-0.3.5 (TychoAndersen)
10:14:29 <bennofs> Gurkenglas: annotated the implementation I used
10:15:16 <berdario> Uhm, I'm starting to get confused... someone has any idea concerning the error in this paste?
10:15:17 <bennofs> Gurkenglas: it has a few differences to my original requirements though
10:15:18 <lpaste_> berdario pasted “No title” at http://lpaste.net/138288
10:15:39 <berdario> whoops
10:15:42 <berdario> wrong paste
10:16:08 <lpaste_> berdario revised “No title”: “No title” at http://lpaste.net/138288
10:16:44 <bennofs> berdario: the type of a is ambigious
10:16:52 <berdario> like, usually when I get an error like that, the type is ambiguous
10:16:59 <berdario> and it tells me about the different alternatives
10:17:07 <berdario> but here it doesn't tell me about any alternative :?
10:17:09 <berdario> :/
10:17:30 <bennofs> (Eq a, Show a, asn1-types-0.3.0:Data.ASN1.Types.ASN1Object a) is not any of the classes it has alternatives for probably
10:18:14 <berdario> oh, so probably I need some other module
10:18:44 <berdario> bennofs do you have any idea about what format functions like readSignedObjectFromMemory are expecting, btw?
10:18:50 <bennofs> berdario: no
10:18:55 <geekosaur> Zemyla, it occurs to me that an approach like the Safe package would be preferable
10:19:14 <geekosaur> indeed, many of us would be happier if non-total functions were Maybe types
10:21:12 <scutigera> i'm very confused. it appears there is an sdl2-2.0.0 AND an sdl2-1.3.1.  anybody know what's up with that ?
10:21:45 <Zemyla> geekosaur: Yes, but (a) GHC can't automatically derive safe Enum, and (b) all the people who have unsafe Enums in their libraries are hosed.
10:22:30 <geekosaur> and as previously mentioned, laziness is your enemy here
10:23:17 <safinaskar> template haskell. Stmt has too many constructors (BindS, LetS, NoBindSm, ParS). what all them mean? can you give some examples? maybe i just know about "do" too little?
10:23:42 <safinaskar> i just know do { () <- putStr "a"; putStr "b"; }
10:23:56 <safinaskar> what is LetS? there is some let statements in "do"?
10:23:57 <Zemyla> geekosaur: That's why I seqed the i.
10:24:05 <haasn> I can't build the ‘cairo’ Haskell package, any clues? https://0x0.st/s9s.log
10:24:27 <haasn> Specifically it fails on ./setup configure with the error message in the log (relocation can not be used when making a shared object)
10:24:47 <safinaskar> Cale: thanks
10:25:12 <scutigera> hassn: building under linux i assume ?
10:25:17 <haasn> scutigera: yeah
10:25:27 <juri_> what is with haskell-mode? it's telling my i have a parse error, when my code compiles.
10:25:42 <scutigera> weird.  i have 0.13.1 installed and used ghc-7.10.1 to do it.
10:26:24 <scutigera> oh- icky linker problem.  that surpasses me.
10:26:43 <berdario> gosh, I haven't been able to get the length of that list yet... I added 2/3 more dependencies to my .cabal file, rebuilt the project... and it's still complaining that those damn modules are hidden
10:27:25 <scutigera> so could be ghc 7.10.2 problem.
10:27:28 <berdario> maybe if I defer type errors?
10:27:44 <hpc> defering type errors only makes the definitions of those errored values be bottom
10:28:07 <geekosaur> juri_, emacs's syntax support is ... limited. unless the author of a major mode is willing to go to the lengths that something like cperl-mode does (and resulting slowdowns), it will just fail on things that aren't sufficiently "lisp-like" (for some definition thereof; C is, some parts of C++ probably aren't)
10:28:19 <scutigera> haasn: have you seen any of this error in other packages ?
10:28:36 <haasn> scutigera: Yeah, pretty much every package that relies on a third party C library fails
10:28:37 <scutigera> this looks like a very low level error - i wouldn't expect it to be specific to cairo
10:28:42 <scutigera> aha
10:28:56 <haasn> Actually pretty much every Haskell package fails to build out of the box, unless I specifically set LDFLAGS="-nopie"
10:29:03 <haasn> But with that flag, the vast majority build successfully
10:29:05 <berdario> hpc well, the problematic values are the elements in a list... I only want to know the length of the list. Wouldn't this fir the use case?
10:29:21 <geekosaur> and support for languages is more or less hooks called by the basic emacs parsing stuff, so without doing a wholesale replacement your "parse error" likely comes from emacs code, not from haskell-mode code
10:29:35 <berdario> (anyhow, it doesn't work... but I'm not 100% sure that it's enabled)
10:29:41 <scutigera> yeah- you definitely shouldn't have to do that, so there's something busted. which linux distro ?
10:30:00 <juri_> geekosaur: this makes the mode less-than-useful. :/
10:30:12 <geekosaur> 7.10.1 has some known linker related bugs; might try 7.10.2
10:30:16 <berdario> hpc I just realized that to know the length of the list it'd need to compare [] with the bottom thunk :/
10:30:18 <scutigera> lol
10:30:20 <haasn> scutigera: gentoo
10:30:28 <scutigera> i'm using 7.10.1 haasn is using 7.10.2
10:30:34 <geekosaur> hm
10:30:40 <FuVinatro> Hey
10:30:53 <scutigera> darn- i'm debian so we can't compare set-ups.
10:31:00 <haasn> https://ghc.haskell.org/trac/ghc/ticket/9007 seems relevant
10:32:25 <scutigera> oh- that's ugly.
10:32:32 <scutigera> i'm of no further help :-(
10:32:58 <haasn> scutigera: debian has a “hardened” profile too, or something
10:33:13 <scutigera> yeah- which i'm clearly _not_ using since i've not experienced this problem.
10:33:42 <scutigera> i'm using a 7.10.1 that i compiled, not the debian ghc.
10:34:24 <scutigera> that's frusrating. cairo is such a nice package too.
10:37:34 <haasn> Hmm, I think I should try building GHC 7.10 without -nopie; I needed that in the past but maybe it's unnecessary now
10:37:52 <haasn> judging by bug reports like https://ghc.haskell.org/trac/ghc/ticket/10597 it's quite been fixed
10:37:57 <haasn> quite possibly*
10:38:24 <haasn> https://git.haskell.org/ghc.git/commitdiff/d03bcfaa255279c7f0c0d931b3202d45faa9b8e0 but possibly I need to amend this to include my platform as well :p
10:39:04 <scutigera> certainly worth trying
10:39:35 <haasn> Nope, still fails
10:39:44 <haasn> https://0x0.st/s9i.log
10:40:33 <scutigera> :-(
10:40:44 <geekosaur> hmmmm
10:40:57 <geekosaur> any chance that installation is x32?
10:41:08 <haasn> geekosaur: Nope, amd64
10:41:14 <geekosaur> (not 32 bit, but 64 bit with 32 bit pointers)
10:41:23 <haasn> I think I need to add -fPIC to the GHC invocations or something
10:41:29 <haasn> But I can't figure out the appropriate place to put default GHC flags
10:41:47 <geekosaur> (some linuyxes are experimenting with that mode, and it could lead to that kind of relocation error when mixing pure 64-bit codd with the "mixed model")
10:42:37 <scutigera> yeah- unfortunately i was going to suggest a horrible idea- and say to download cairo package and re-build it.
10:42:47 <scutigera> just to see what that does
10:45:27 <haasn> Hmm, I tried adding -fPIC to my $HCFLAGS, same issue persists
10:45:40 <berdario> I understood the problem... the ByteString needed to contain the ascii-armored (base64 encoded with newlines) pem certificate... I shouldn't have merged the newlines and decoded it :/
10:47:23 <haasn> https://mail.haskell.org/pipermail/glasgow-haskell-users/2009-November/018064.html is also somewhat related
10:47:46 <haasn> scutigera: The confusing thing is; I have another machine where it works fine, that's also on the hardened profile. So I could probably cross-check to see if there are any differences
10:47:48 <safinaskar> template haskell. Stmt has too many constructors (BindS, LetS, NoBindSm, ParS). what all them mean? can you give some examples? maybe i just know about "do" too little
10:52:44 <geekosaur> safinaskar, suggest you learn more about do
10:53:24 <bmoflg> haskell-react vs reflex? I'm trying to decide if I should go with a  haskell web UI or just stick to ReactJS
10:53:31 <geekosaur> off the top of my head, BindS looks like <-, LetS like let, NoBindSm looks like an action (e.g. `return a'). don't know what ParS would be offhand
10:54:27 <geekosaur> do { x <- foo; let {a = 5}; return (x + a) } -- examples of those first three, if I am understanding correctly
10:58:41 <scutigera> haasn: not familiar with gentoo
10:58:58 <scutigera> is it possible your ld/gcc/toolchain has different versions ?
10:59:03 <comprehension> how can i turn off warnings inside genrated code?
10:59:24 <haasn> scutigera: doubtful, I only have one version of gcc installed
10:59:40 <scutigera> well- yeah- that's very confusing.
10:59:47 <haasn> Gonna try bootstrapping GHC from scratch with the same settings I used on the machine where it works (ie. none)
10:59:49 <bennofs> geekosaur: perhaps ParS is for mdo?
11:00:24 <haasn> (Seems to work, but only because the hardened profile explicitly disables PIE for GHC)
11:00:41 <geekosaur> looks, from the original TH paper, to be related to list/monad comprehensions (parallel extension)?
11:01:01 <bennofs> geekosaur: ah, parallel list comprehensions! that's it
11:01:16 <geekosaur> | ParSt [[Statement p e d]]          -- { x <- xs | y <- ys, z <- zs }
11:02:41 <geekosaur> scutigera, have I answered your question about TH `do' constructors sufficiently?
11:02:43 <koala_man> I'm using State with multiple variables as a tuple, and modify \(a,b,c) -> (a,b,c+1) to update one of them. obviously this sucks. what's a better way of doing it? a data structure with lenses?
11:03:04 <scutigera> geekosaur: yes you have. because i did not have a question about it ;-)
11:03:12 <bennofs> koala_man: using lenses, _3 += 1 would do it :)
11:03:12 <geekosaur> you pasted it twice
11:03:23 <geekosaur> oh, whoops, tab complete fail
11:03:27 <scutigera> LOL
11:03:43 <geekosaur> safinaskar, have I answered your question about TH constructors sufficiently?
11:03:56 <kadoban> koala_man: For /exactly/ that case, it's   fmap (+1), though I doubt that really answers for you.
11:04:05 * geekosaur normally catches those... today is kinda feh so far
11:04:23 <koala_man> kadoban: what, how would that update a specific element in a tuple?
11:04:25 <geekosaur> (did you even see the answsers?)
11:05:38 <scutigera> does anyone know what packages i need under debian to make ghc build docbook options show up as YES ?
11:05:39 <kadoban> koala_man: That's why I said it only answers /exactly/ the function you asked for. Bifunctor would get you the last or second to last, but after that if you want a general solution you need something else, like lens. If it were me I'd probably just write a few functions to do it.
11:06:17 <scutigera> i remember trying to install the packages as recommended on ghc page, and seems like it still would show up as NO
11:06:27 <koala_man> bennofs: looks great, thanks
11:07:12 <safinaskar> geekosaur: well, okey :)
11:09:04 <koala_man> kadoban: I wrote a few functions but now I want to add more and I don't want to have a 13-tuple and updating 13 functions each time
11:13:18 <scutigera> well-apparently i'm full of crap. i just installed the pkgs as specified in ghc build guide, and got my YESs.
11:13:32 <scutigera> so 7.10.2 on it's way :-)
11:29:38 <kadoban> koala_man: You can avoid updating the functions/types by changing it into a record type instead.
11:33:54 * hackagebot diagrams-hsqml 0.2.0.0 - HsQML (Qt5) backend for Diagrams  https://hackage.haskell.org/package/diagrams-hsqml-0.2.0.0 (mjmrotek)
11:34:58 <safinaskar> http://paste.debian.net/290378/ . why this code give me "12:1: parse error on input `}'" on ghc 7.6.3?
11:38:53 <galois_dmwit> safinaskar: For what it's worth, that's not the error I get. I get, "Declaration splices are allowed only at the top level".
11:39:13 <galois_dmwit> safinaskar: (ghc-7.10.1)
11:39:30 <mac10688> what's the newbie haskell channel called?
11:39:49 <hpc> #haskell-beginner (might be plural)
11:39:51 <mac10688> thanks
11:39:52 <hpc> but also here as well
11:39:58 <mauke> #haskell :-)
11:40:14 <mac10688> I'm also going through the creator's book :)
11:41:36 <Cale> mac10688: This is also the newbie Haskell channel
11:41:52 <Cale> mac10688: #haskell-beginners is for a specific study group, and I hate the fact that it's named like that
11:42:05 <hpc> Cale: study group?
11:42:29 <Cale> hpc: Well, I guess it's mostly people who are doing cis194 and nicta
11:42:40 <hpc> ah, makes sense
11:43:07 <mac10688> Both are good for me. I have bitemyapp's book and am going through it. So it makes sense for me to be there too
11:43:11 <hpc> mac10688: anyway, there's constantly new people in here asking questions
11:43:21 <hpc> so we're pretty well-practiced at making things make sense
11:44:17 <mac10688> sweet. I just got my linux box set up and finally got vim + tmux going so I'm back to the haskell learning grind. I'm sure you'll see questions from me more often
11:45:30 <gpyh> hi
11:45:39 <gregnwosu> anyone using ghc-mod? I keep getting the error "cannot obtain initial codebje"
11:49:00 <mac10688> I'm using it but I doubt I can help you unless you have specific things you want me to look up
11:50:03 <Cale> When running ghc-mod itself?
11:51:57 <gregnwosu> yes, when i C-u M-t to do a completion
11:52:19 <Cale> What do you get when you just run ghc-mod, not from in emacs?
11:53:36 <gregnwosu> not tried that 
11:53:41 <gregnwosu> ill give that a go
11:54:35 <gregnwosu> intetresting i get: hGetContents: invalid argument (invalid byte sequence)
11:54:36 <gregnwosu>  
11:56:01 <gregnwosu> looking that up i see its related to locales
11:56:07 <gregnwosu> think i can fix from here thanks
12:10:08 <ralu> iam doing FFI interface for some library. Is it common to expose CFloat ?
12:11:28 <davik> noobie question: Can someone help with importing Data.Matrix library? I did "cabal install matrix" but I still can't import it
12:12:38 <arkeet> where/how are you importing it?
12:13:37 <codehero> (<3) :: (Num a, Ord a) => a -> Bool
12:13:54 <davik> do I need to be in a particular directory? sorry I'm really new to this
12:14:07 <arkeet> shouldn't have to be, but answer the question
12:14:08 <davik> I think i did the cabal install in the same directory though
12:14:19 <codehero> depends if you use a sandbox
12:14:29 <arkeet> are you doing it in ghci? or in a .hs file?
12:14:32 <davik> oh i think i did do the sandbox
12:14:34 <davik> ghci
12:14:34 <arkeet> if the latter, is it part of a cabal project?
12:14:39 <arkeet> ah
12:14:44 <codehero> yeah. then you have to install it in the same dir
12:14:46 <arkeet> if you're in a sandbox, you need to "cabal repl" to start ghci
12:14:49 <arkeet> so that it sees the stuff in the sandbox
12:14:50 <codehero> and add it to the .cabal file
12:14:58 <codehero> or cabal repl
12:15:52 <arkeet> (and in that case, you have to start it from the sandbox directory)
12:16:01 <davik> Thanks
12:16:04 <davik> I got it
12:19:08 <browndawg> https://pastee.org/9pf53 <-- could someone explain to me where I'm blowing the stack with this?
12:20:24 <browndawg> I mean, it's supposed to be lazy, and the default stack is 8 mb
12:20:25 <browndawg> https://pastee.org/whe7t
12:20:30 <browndawg> I must be doing something terribly wrong
12:20:41 <Welkin> maximum
12:20:48 <Welkin> @src maximum
12:20:48 <lambdabot> maximum [] = undefined
12:20:48 <lambdabot> maximum xs = foldl1 max xs
12:21:01 <browndawg> Welkin: there isn't a tail recursive implementation?
12:21:06 <browndawg> :(
12:21:18 <Welkin> it is tail recursive
12:21:27 <Welkin> but it builds up thunks as it goes
12:21:45 <browndawg> solutions?
12:22:05 <Welkin> to find the maximum you need to traverse the whole list
12:22:40 <browndawg> Welkin: Well, maximum $ ... 100000000 doesn't blow the stack
12:22:50 <browndawg> okay wait
12:22:53 <browndawg> k
12:23:08 <browndawg> so dumb
12:23:37 <browndawg> but why does xs have to be in memory all at once
12:23:46 <browndawg> won't the already processed list be GC'd?
12:24:11 <bob_twinkles> no, 'cause you're binding the whole list to acc
12:24:45 <Welkin> > foldl1' max minBound [1..1000000]
12:24:47 <lambdabot>      Could not deduce (Bounded [[t0] -> t1])
12:24:47 <lambdabot>      from the context (Bounded [[t] -> t1],
12:24:47 <lambdabot>                        Enum t,
12:24:52 <Welkin> > foldl1' max minBound [1..1000000] :: Int
12:24:54 <lambdabot>      No instance for (Ord ([t0] -> Int))
12:24:54 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
12:24:54 <lambdabot>        arising from a use of ‘max’
12:25:05 <Welkin> > foldl1' max (minBound :: Int) [1..1000000]
12:25:06 <lambdabot>      Couldn't match expected type ‘[[t0] -> t]’ with actual type ‘Int’
12:25:06 <lambdabot>      In the second argument of ‘foldl1'’, namely ‘(minBound :: Int)’
12:25:06 <lambdabot>      In the expression: foldl1' max (minBound :: Int) [1 .. 1000000]
12:25:18 <Welkin> > foldl1' max 0 [1..1000000]
12:25:19 <lambdabot>      Could not deduce (Enum t0)
12:25:19 <lambdabot>      from the context (Enum t, Num t, Num [[t] -> t1], Ord ([t] -> t1))
12:25:19 <lambdabot>        bound by the inferred type for ‘e_11011000000’:
12:25:21 <browndawg> huh?
12:25:30 <Welkin> oh
12:25:31 <Welkin> hah
12:25:37 <Welkin> > foldl1' max [1..1000000]
12:25:38 <lambdabot>  1000000
12:25:41 <browndawg> bob_twinkles: but that's supposed to get collected right after the call to length
12:25:48 <Welkin> > foldl1 max [1..1000000]
12:25:50 <lambdabot>  *Exception: stack overflow
12:25:54 <Welkin> see the difference?
12:26:03 <Welkin> one is strict, the other is lazy
12:26:12 <Welkin> you want a strict left fold, so it doesn't build up thunks
12:26:16 <Welkin> it evaluates as it goes
12:26:24 <browndawg> so maximum isn't the way to go
12:26:44 <Welkin> > maximum [1..1000000]
12:26:46 <lambdabot>  *Exception: stack overflow
12:26:50 <Welkin> > foldl1' max [1..1000000]
12:26:52 <lambdabot>  1000000
12:26:57 <Welkin> use that instead
12:27:11 <Welkin> or, define maximum = foldl1' max
12:27:17 <Welkin> er
12:27:21 <Welkin> or, define maximum' = foldl1' max
12:27:31 <browndawg> @src foldl1'
12:27:31 <lambdabot> Source not found. Where did you learn to type?
12:27:58 <Welkin> it is foldl, but strict, and uses the first element of the foldable as the accumulator
12:28:09 <Welkin> :t foldl1'
12:28:10 <lambdabot> (a -> a -> a) -> [a] -> a
12:28:37 <Welkin> :t foldl'
12:28:38 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
12:28:58 <browndawg> hmm
12:30:27 <browndawg> why does the default maximum not do this
12:30:39 <Ankhers> I'm using QuickCheck to test some functions. I want to write my own version of Arbitrary for Char, I have {-# OVERLAPS #-} marking the instance. When I compile, it complains about multiple instances of Arbitrary for Char. How would I go about telling my test suite which instance to use?
12:31:03 <Welkin> browndawg: at least for List, it looks like maximum uses a lazy left fold
12:31:16 <arkeet> browndawg: it should :(
12:31:20 <browndawg> yeah
12:31:31 <browndawg> I mean, I was expecting everything to be lazily evaled
12:31:45 <Welkin> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#maximum
12:31:50 <Welkin> this is the Old List though
12:32:08 <Welkin> @src Data.Foldable.maximum
12:32:08 <lambdabot> Source not found. Abort, Retry, Panic?
12:33:18 <geekosaur> isn't laziness exactly the problem here?
12:33:19 <arkeet> if you had -O then those rewrite rules would fire I guess
12:33:22 <Welkin> maximum from Foldable looks like it uses foldMap, which is a right fold
12:33:57 <browndawg> Trying
12:33:59 <Welkin> > foldr1 max [1..1000000]
12:34:00 <lambdabot>  *Exception: stack overflow
12:34:07 <Welkin> > foldr1' max [1..1000000]
12:34:08 <lambdabot>      Not in scope: ‘foldr1'’
12:34:08 <lambdabot>      Perhaps you meant one of these:
12:34:08 <lambdabot>        ‘BS.foldr1'’ (imported from Data.ByteString),
12:34:15 <arkeet> there is no such thing as a strict right fold
12:34:21 <arkeet> because there is no accumulator
12:34:36 <browndawg> k
12:34:44 <arkeet> anyway
12:34:51 <arkeet> the Foldable instance for [] overrides maximum anyway
12:34:57 <arkeet> to the GHC.List version
12:35:05 <Welkin> yeah I see that
12:36:28 <Welkin> > foldr' max 0 [1..1000000]
12:36:30 <lambdabot>      Not in scope: ‘foldr'’
12:36:30 <lambdabot>      Perhaps you meant one of these:
12:36:30 <lambdabot>        ‘BS.foldr'’ (imported from Data.ByteString),
12:36:42 <Welkin> :t foldr'
12:36:43 <lambdabot>     Not in scope: ‘foldr'’
12:36:43 <lambdabot>     Perhaps you meant one of these:
12:36:43 <lambdabot>       ‘BS.foldr'’ (imported from Data.ByteString),
12:36:44 <arkeet> what did I just say :-(
12:36:48 <Welkin> it exists though
12:36:56 <arkeet> for bytestring yes
12:36:57 <Welkin> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#foldr%27
12:36:57 <arkeet> not list
12:37:00 <Welkin> ah
12:37:12 <arkeet> eh idk
12:37:20 <arkeet> oh it exists
12:37:30 <arkeet> but it's defined using foldl
12:38:07 <arkeet> it's as good as using foldl' on a reversed list
12:38:57 * hackagebot json-rpc 0.6.2.1 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.6.2.1 (XenoGenesis)
12:38:57 <arkeet> I think
12:41:27 <Welkin> browndawg: https://wiki.haskell.org/Foldr_Foldl_Foldl%27
12:41:45 <browndawg> Welkin: Halfway through it!
12:42:42 <catgocat_> @pl unlines' = foldl' (\acc x -> acc ++ x ++ "\n") []
12:42:42 <lambdabot> unlines' = foldl' ((. (++ "\n")) . (++)) []
12:48:57 * hackagebot wai-routes 0.7.3 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.7.3 (AnupamJain)
12:54:57 <egm500> hello is there anyone here that can help me with a problem i'm having using recursion
12:55:54 <pavonia> What problem?
12:58:37 <browndawg> so the moral of the story is, lazy evaluation isn't always a good thing
13:00:44 <Cale> browndawg: Definitely not always, but it's a pretty good default. Usually the places where you need strictness are those places where you're collapsing a large structure (or lots of individual pieces) down into a "small" result (few pieces which could be evaluated separately)
13:02:22 <pavonia> egm500: If you want to paste code, you can use lpaste.net
13:03:27 <egm500> It's for homework and and rather not have it public
13:03:42 <Welkin> egm500: you can paste privately
13:03:58 <Welkin> you choose "public" pr "private" when you create the paste
13:04:02 <mauke> anything you say in this channel is published on the internet
13:04:08 <Welkin> yes, that too
13:04:32 <egm500> ok thanks
13:04:34 <egm500> give me a sec
13:05:39 <egm500> http://lpaste.net/4996226483526565888
13:06:07 <egm500> So I'm lost on how to pass results of the updated volumes between each set of pours
13:08:54 <Welkin> egm500: I recommend defining some data types to help keep your code understandable
13:09:10 <Welkin> instead of passing around a triple tuple, why not wrap it in a data type?
13:09:33 <Welkin> data Jugs a = Jugs a a a
13:10:57 <Welkin> egm500: also, there is no need to pattern match on elements you do not use
13:11:02 <egm500> that's how it's initially being passed though the command line and it's something I cannot change so i left it
13:11:29 <Welkin> egm500: you can pass it to a function that can construct the data for you from the input
13:11:30 <egm500> also we barely started covering functional languages last week so this is very knew and unclear to me
13:11:36 <Welkin> then at the end put it back into that format
13:12:03 <Welkin> it would help if you cleaned up the code
13:12:38 <Welkin> line 26 could instead read: onePlayerOnePourList _ ys _ [] = ys
13:12:49 <Welkin> also, the function names are unclear
13:12:54 <Gurkenglas> Alternatively, you could construct the smallest possible code example to illustrate your problem.
13:12:55 <Welkin> some comments would help too
13:14:04 <catgocat_> Why can't I do infix operations on functions that take 3 or more arguments?
13:14:17 <catgocat_> let stuff a b c = a + b + c; 2 `stuff` 3 5 -- not working
13:14:20 <Welkin> catgocat_: because how would it work?
13:14:44 <Gurkenglas> @let f a b c = undefined
13:14:46 <lambdabot>  Defined.
13:14:46 <catgocat_> Welkin: normally?
13:14:47 <johnw> actually, I'd think that (2 `stuff` 3) 5 shoudl work
13:14:58 <jpl_> yeah I think the parens will work
13:15:00 <Gurkenglas> :t (2 `f` 3) 5
13:15:01 <lambdabot>     Ambiguous occurrence ‘f’
13:15:01 <lambdabot>     It could refer to either ‘L.f’,
13:15:01 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:162:1
13:15:11 <Gurkenglas> :t (2 `L.f` 3) 5
13:15:13 <lambdabot> t3
13:15:26 <jpl_> I checked it in ghci
13:15:27 <jpl_> parens work
13:15:30 <catgocat_> Works
13:15:33 <geekosaur> I would expect 2 `f` 3 5 to parse as (2 `f` (3 5))
13:15:35 <catgocat_> Thanks.. the parens do the job
13:15:52 <Welkin> @let triPlus a b c = a + b + c
13:15:53 <lambdabot>  Defined.
13:16:10 <Welkin> > (1 `triPlus` 2) 3
13:16:12 <lambdabot>  6
13:16:17 <jpl_> tada
13:16:18 <Welkin> > 1 `triPlus` 2 3
13:16:19 <lambdabot>      Could not deduce (Num a0)
13:16:19 <lambdabot>      from the context (Num a, Num a1, Num (a1 -> a))
13:16:19 <lambdabot>        bound by the inferred type for ‘e_1123’:
13:16:28 <Gurkenglas> The problem is that " " binds stronger than infix operators, so you have to use parens to get the two-argument function f to produce a one-argument function
13:16:32 <Welkin> so, there is no point in doing it catgocat_ 
13:16:35 <Welkin> you have to add parens
13:16:59 <egm500> sorry about the comments, I took them out before my last save
13:17:04 <catgocat_> Welkin you can actually do this so that's the point
13:17:45 <texvery> marketing.
13:20:23 <zipper> Anyone know how stack or ide-backend or even cabal are able to build all code except that which is in the tests section unless one passes an argument to do so.
13:20:39 <tdammers> hum, how do I use TH to declare a data type and then call makeLenses and deriveJSON on it?
13:20:56 <tdammers> I'm getting "is not in scope at a reify"
13:21:50 <gpyh> hi, I'm a Haskell beginner and as I tackle my first project I'm having trouble finding the right way to implement (or _not_ implement) association. An exemple : I define a Brotherhood as a List of Sibling. A Sibling is a type that has among its field constructor a Brotherhood. This forms a '1 to many' association. Can the type system guarantee that a Sibling is itself in its own Brotherhood and that every Si
13:21:56 <gpyh> bling in a Brotherhood as itself as a field? If not, can you give a common pattern as to be able to access a set from one of its elements and vice-versa?
13:22:00 <indiagreen> tdammers: if shuffling things around doesn't help, add a top-level “return []” between makeLenses and deriveJSON
13:22:50 <johnw> gpyh: it would be a lot easier to answer if we could see your idea drafted as the kind of code you'd like to write
13:22:52 <tdammers> frankly, makeLenses alone together with the data type definition fails
13:23:12 <tdammers> I'll need deriveJSON in there too, but haven't even gotten that far
13:23:13 <johnw> gpyh: in fact, attempt to write what you want to see can often clarify what you're trying to accomplish
13:23:43 <gpyh> johnw: data Person = Person Brotherhood ; type Brotherhood = [Person]
13:23:50 <indiagreen> tdammers: if makeLenses alone fails, this is solvable by shuffling things around (you need everything that uses generated lenses to be after makeLenses)
13:24:33 <tdammers> no, I know that part
13:24:34 <gpyh> johnw: that gives me a canvas but in not way did I enforce the fact that a Person can have a Brotherhood that isn't comprised of itself ; How can I tell the compiler to check for this?
13:24:37 <tdammers> that's not the problem
13:24:56 <tdammers> the problem is that I want to write one TH function that injects both the data type and a makeLenses call on it
13:24:56 <gpyh> s/can/cannot
13:25:35 <johnw> gpyh: so, data Person = Person [Person].  This will not communicate much information other than structure
13:26:02 <johnw> there's no way to distinguish Persons yet
13:26:40 <gpyh> johnw: indeed ; let's have a String field then (i.e. firstname)
13:26:52 <johnw> ok, then you have a Data.Tree
13:26:55 <gpyh> data Person = Person String [Person]
13:27:09 <Welkin> type Brotherhood = [Person]; data Person = Person Name Age ...
13:27:16 <Welkin> that would make more sense, gpyh 
13:27:27 <johnw> data Tree a = Tree a [Tree a], in the module Data.Tree
13:27:33 <gpyh> Welkin: I left the cruft in order to focus on my question
13:27:57 <johnw> so, you want to make sure that a Person is never in their own ancestry?
13:28:36 <indiagreen> tdammers: can you paste some code? (even if it doesn't compile on its own)
13:28:51 <gpyh> johnw: That's a tree indeed but I don't what any kind of hierarchy. I *want* to make sure that a Person is its own ancestry in order to be able to access the brotherhood from any of the siblings
13:29:09 <tdammers> indiagreen: sure, one sec
13:29:48 <gpyh> johnw: Which I think is not very "haskelly". So my question is actually more open than that : what's the canonical way of modeling my problem in Haskell?
13:29:53 <ttt_fff> should creating fresh variables show up during unification? or should it show up in the stage BEFORE unification ?
13:29:58 <johnw> establishing data relationships like this in the type is not something that Haskell does conveniently.  However, if your set of People is finite, it may be possible to do something similar to what you've suggested using type-level lists and GADTs
13:30:19 <lpaste_> tdammers pasted “TH not in scope at a reify” at http://lpaste.net/138293
13:30:42 <Welkin> gpyh: why not store the ancestry in a tree, then put all the trees in a Map? Then each Person can have a field for their ancestry.
13:31:52 <catgocat_> How do I set an infixr or infixl or infix in ghci ?
13:32:46 <gpyh> Welkin: My goal is not to make any sort of hierarchy between the Persons. In a more abstract way, I just want an element to be aware of the set it's in ; but for that, the mentionned set needs to have the element, or I've broke correctness
13:33:00 <gpyh> johnw: So basically dependent types. Thanks.
13:33:15 <johnw> dependent types could do it easily, sure
13:33:53 <gpyh> I'm afraid my use of OOP is heavily tainting the way I try to solve problems in Haskell
13:34:07 <indiagreen> catgocat_: you can do it only at the place of definition
13:34:23 <indiagreen> catgocat_: like “let (&) = flip ($); infixl ...”
13:34:28 <johnw> gpyh: you can get close in Haskell: https://gist.github.com/9423ea6e1515b4d99531
13:34:39 <indiagreen> catgocat_: but not if the operator was defined already
13:34:50 <johnw> however, enforcing a bijection between the names you construct with, and a type-level entity , will not be easy
13:34:58 <ttt_fff> :t Data.Map.insert
13:34:59 <lambdabot> Ord k => k -> a -> M.Map k a -> M.Map k a
13:35:05 <johnw> there could be a way, I'm just brainstorming here
13:35:20 <ttt_fff> is there a one line, using foldr, to build a insert which inserts a list of (k,a) ? i.e. [(k,a)] -> Map k a -> Map k a
13:35:27 <ttt_fff> :t foldr
13:35:28 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:35:31 <gpyh> gpyh: That was awesome! Thanks
13:35:42 <johnw> in fact, maybe the "String" argument isn't needed at all, and you just work with a set of static symbols
13:35:47 <Welkin> gpyh: responding to yourself I see :D
13:35:48 <gpyh> johnw: That was awesome! Thanks (I was thanking myself ><)
13:35:51 <ttt_fff> :t foldl
13:35:52 <lambdabot> Foldable t => (b -> a -> b) -> b -> t a -> b
13:35:58 <johnw> you can always recover the String from the KnownSymbol
13:35:59 <bros> Not to sound like I'm trolling, but is Haskell a practical choice for a semi-advanced Node.js user looking to branch out and learn a new language when building web apps, or is this not a general strength of Haskell?
13:36:00 <gpyh> Welkin: :D
13:36:02 <ttt_fff> :t foldr
13:36:03 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
13:36:21 <johnw> bros: Haskell can be great at webapps
13:36:22 <Welkin> bros: I build all my web apps in haskell
13:36:27 <tdammers> bros: I would say yes, but it takes quite a while before you reach a level where you can comfortably build web applications in Haskell
13:36:34 <Welkin> bros: we have tons of activity in the web space
13:36:35 <johnw> bros: it's worth it just to see other ways to approach the problem
13:36:38 <bros> Could you two show me some code?
13:36:45 <johnw> bros: you might also want to check out Ur/Web
13:37:04 <bros> I've seen examples out there, and they look horribly complex. I've come here before just to break down a simple Hello, world! with a framework
13:37:10 <Welkin> bros: here are a few https://wiki.haskell.org/Web/Frameworks
13:37:13 <bros> Welkin: tdammers: johnw: do you guys use frameworks?
13:37:22 <johnw> I've used Yesod and scotty
13:37:22 <ttt_fff> (\x -> foldr (uncurry DM.insert) x lst)) <-- can I shorten this?
13:37:23 <Welkin> bros: yes, I use yesod
13:37:28 <johnw> I hear snap is good
13:37:32 <Welkin> there is scotty, spock, servant, yesod, etc...
13:37:44 <Welkin> all in that link I pasted
13:37:56 <bros> johnw: what do you do for the frontend? Do you use Haskell solely as the "API" server? do you do server-side rendering as well?
13:38:06 <bros> Welkin: I've seen the link many times before, thanks.
13:38:07 <johnw> some people like fay/haste/ghcjs
13:38:09 <Welkin> bros: more examples of heloo world web apps here https://halcyon.sh/examples/
13:38:30 <johnw> keeping it "all Haskell, all type-safe" is a worthwhile goal
13:39:00 <tdammers> bros: I hate frameworks in general... at least the ones that aren't loose compilations of standalone libraries
13:39:08 <Welkin> bros: I meant here https://halcyon.sh/shootout/
13:39:14 <tdammers> bros: that said, I like coding directly against WAI
13:39:19 <bros> tdammers: I feel the same way. But it's definitely not a popular way to think.
13:39:30 <bros> tdammers: what goes well on the frontend with what your prefer?
13:39:35 <tdammers> also: https://bitbucket.org/tdammers/hubby/src/87eac4472ef8be81ac35d4c0b6c6325d327d9405/hubby/Hubby/Handlers/Admin.hs?at=master <- this is what I'd consider somewhat typical for my style of web programming in Haskell
13:39:39 <Welkin> well, you have the whole spectrum of options in haskell
13:39:53 <Welkin> you can use a middleware only, or use a microframework, or something monolithic like yesod
13:40:03 <tdammers> on the frontend, I'm still in "just put up with JS" camp
13:40:24 <Welkin> bros: there is ghcjs, haste, fay, purescript, elm, etc.
13:40:37 <Welkin> the last two not exactly being haskell, but built on it and similar in syntax
13:40:37 <johnw> and all the FRP approaches too
13:41:05 <johnw> http://hackage.haskell.org/package/reflex is looking very promising, and is based on ghcjs
13:44:21 <rola> conal elliott pronounces FRP like "furp", i love it
13:47:56 <indiagreen> tdammers: okay, uh, I'm not an expert on TH, but I don't think it's possible
13:49:26 <indiagreen> tdammers: the thing with DecsQ is that it's just Q [Dec]; for instance, in your defineEntity, even if everything was alright with reify it still wouldn't do the right thing because declarations generated by defineEntity' would be lost and only ones generated by makeLenses would be returned
13:49:27 <bros> tdammers: i appreciate the example but that looks extremely daunting
13:50:23 <tdammers> bros: I'd look into Scotty if I were you
13:50:37 <Welkin> bros: here is a simple example: https://www.spock.li/
13:50:48 <tdammers> can always scale up to a heavier framework, or drop down to the WAI layer underneath it
13:50:49 <Welkin> https://www.spock.li/tutorial/
13:51:08 <indiagreen> tdammers: and I think there's no way to add generated declarations to GHC's scope manually (i.e. do something like “decs <- defineEntity' entityName fields; addToGlobalScope decs; makeLenses typeName”)
13:51:16 <Welkin> of course, you need to understand basic haskell though
13:51:32 <bros> Welkin: in your opinion, how long is that supposed to take?
13:51:46 <Welkin> bros: you can be writing programs in a couple weeks most likely
13:51:56 <Welkin> it's not difficult to use, just different
13:52:14 <Welkin> @where learnhaskell
13:52:14 <lambdabot> https://github.com/bitemyapp/learnhaskell
13:52:18 <Welkin> that is a good place to start
13:52:23 <Welkin> and #haskell-beginners
13:52:47 <indiagreen> tdammers: however, you can use declareLenses and it could even work
13:52:59 <tdammers> indiagreen: hmm
13:53:18 <tdammers> indiagreen: in fact, I remember having done just the makeLenses >> deriveJSON part, and that one worked just fine
13:53:35 <texvery> does haskell have a foundation?
13:53:52 <bros> Welkin: thank you so much
13:54:25 <texvery> that accepts donation, and produces software, and builds community support?
13:54:33 <Welkin> bros: feel free to ask any question in here or #haskell-beginners
13:54:36 <mauke> haskell is founded in theory
13:54:45 <texvery> how?
13:54:51 <texvery> by universities?
13:55:14 <bros> Welkin: what are some of the main benefits besides type safety, inherit concurrency, and compiled language speed of haskell for a web developer?
13:55:41 <Welkin> bros: refactoring is super easy
13:55:53 <bros> because everything is pure
13:56:21 <hpc> heh
13:56:23 <Taneb> bros, yes, because everything is pure, but also because everything is strongly typed
13:56:30 <hpc> "what are the main benefits besides <list of awesome>"
13:56:32 <hpc> ;)
13:56:52 <bros> hpc: it seems like it would be such a pain compared to say, isomorphic javascript
13:56:54 <bob_twinkles> also security, since things like "don't build SQL queries through concatination" is enforced at the type level
13:57:32 <bob_twinkles> which you shouldn't do in any language, but it's nice to have the compiler backing you up
13:57:33 <hpc> bob_twinkles: i wouldn't say it /is/, but it can be if you set your data structures up appropriately
13:57:53 <bob_twinkles> yeah
13:58:11 <bob_twinkles> fortunately every haskell database driver I know of does such things =D
13:58:14 <zomg> bros: I wrote this a while back regarding haskell and web dev (I've been doing web dev for a long time in non fp langs) http://codeutopia.net/blog/2012/05/12/is-haskell-good-for-web-development/
13:58:32 <tdammers> indiagreen: declareLenses works, but it strips the record syntax off... that's not what I want either
13:58:39 <bros> zomg: what do you do for frontend SPA apps if you choose Haskell?
13:59:30 <zomg> Depends, you can keep it JS, or go with one of the available Haskell'ish options like Haste, Fay, Elm, PureScript or GHCJS
13:59:44 <Welkin> bros: there are haskell -> js compilers, like ghcjs, haste, and fay, and then there are DSLs like PureScript and Elm
13:59:52 <bros> that covers the language aspect. what about the frontend framework?
14:00:21 <zomg> at least Fay and Elm can integrate fairly easily with "normal" JS libs, have not used the rest so can't say about them
14:00:25 <bros> i see a lot of REST examples, but nothing for websockets?
14:00:40 <Welkin> bros: we have a WebSocket library
14:00:54 <Welkin> https://hackage.haskell.org/package/websockets
14:01:00 <tdammers> there's a websockets package on hackage
14:01:05 <bros> anything that builds on top of that?
14:01:15 <bros> why are websockets so unpopular when there are 10+ HTTP REST frameworks?
14:01:17 <tdammers> probably
14:01:19 <Welkin> https://hackage.haskell.org/packages/search?terms=websocket
14:01:29 <bob_twinkles> the websockets protocol is... interesting
14:01:30 <Welkin> there are lots of websockets-<framework> packages too
14:01:30 <tdammers> they're not unpopular, just less important
14:01:33 <bros> ah. ok. snap, wai, yesod, i see now
14:01:51 <zomg> WebSockets are not so commonly used I think
14:02:03 <zomg> I mean most web apps don't need near-real time two-way comms
14:02:28 <tdammers> well, one reason might be that they're fairly new, and there are still browsers out there that don't support them, so you need a fallback
14:02:32 <bros> i have a pretty complex SPA that maintains a database that multiple users can alter (changing statuses, adding/removing data)
14:02:32 <zomg> Yeah, and even in JS-land there are fewer options for it
14:02:39 <catgocat_> Why there is no source for the function seq ?
14:02:43 <tdammers> but I think the more important reason is that they are relatively niche
14:02:43 <bros> i couldn't think of any way to keep it synchronized cross browsers other than websockets
14:02:44 <Welkin> bros: there is an example application on the yesod wiki for implementing a chatroom in yesod using websockets
14:02:50 <catgocat_> Hoogle doesn't show source for this particular function
14:02:59 <hpc> websockets are also pretty backwards from how you usually write js, too
14:03:07 <zomg> bros: yeah if you need to push updates from the server to keep a client in sync, then it makes sense
14:03:08 <tdammers> they're great for full-duplex stuff between code running in a browser and code running on a server
14:03:22 <hpc> you can't just $.websocket({some easy stuff}) and then blithely continue execution
14:03:24 <indiagreen> tdammers: in this case you might look at how declareLenses is implemented – luckily, all machinery is still exported by Control.Lens.Internal.FieldTH
14:03:28 <bros> zomg: i may have gone overboard and implemented all of the functionality on top of it though :P
14:03:30 <catgocat_> What is the source for the function `seq`? Hoogle shows no source.
14:03:35 <submain> would anyone know if there are any logs on emacs I can look to see why my gcc-mod is not working?
14:03:42 <submain> *ghc
14:03:43 <Welkin> catgocat_: look in the docs
14:03:45 <hpc> catgocat_: it's ghc magic
14:03:46 <tdammers> indiagreen: yeah, hum, I'm kind of baffled how difficult this turns out to be
14:03:52 <catgocat_> Welkin: Where?
14:04:04 <tdammers> hpc: it didn't feel terribly alien to me last time I used that stuff
14:04:08 <zomg> hpc: websockets are fairly easy to use in JS, but yeah it has the usual callback stuff if that's what you were referring to =)
14:04:18 <bros> zomg: if you were going to keep clients in sync coming from the server, would you push transactional changes?
14:04:19 <zomg> well, they're only easy if you slap it with a library that makes it easy
14:04:35 <hpc> catgocat_: http://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/src/GHC-Prim.html#seq
14:04:53 <hpc> zomg: yeah, callbacks
14:05:09 <hpc> zomg: ajax used to be the same way, and it was a huge deal when google maps started using it
14:05:14 <zomg> bros: depends on how much my clients cared about it. Most apps can end up in a situation where two users can concurrently edit something, but usually it's not common enough thing to warrant some kind of special handling like that
14:05:30 <zomg> hpc: not sure if I follow :) Ajax still has callbacks
14:05:33 <tdammers> http://hackage.haskell.org/package/websockets <- bros, this is the websockets package btw
14:05:38 <bros> zomg: i have cases like that. how can i best handle them?
14:05:52 <bros> tdammers: i like htat package. simple. i can understand that. thanks! :)
14:06:07 <hpc> zomg: every framework abstracts over it now
14:06:07 <zomg> bros: websockets seems reasonable if it's a common thing that your user would need to be notified about a change as it happens
14:06:22 <hpc> to hide as much callbacking as possible, make it not asynchronous, etc
14:06:27 <indiagreen> tdammers: it's because all TH functions try to be convenient (“you give us the name, we'll do the rest”), when in reality they don't need an existing name, they just need to know some info about the type
14:06:31 <bros> zomg: i guess there is no perfect way to prevent two users from modifying the same resource at around the same time
14:06:34 <zomg> hpc: sure, but it still needs a callback. There's a couple of websockets implementations that make it as easy as socket.open, socket.send etc.
14:06:35 <hpc> where before you had to ajax and deal with callbacks, but also do a bit of CPS
14:06:52 <bros> i don't use callbacks in my javascript + websockets code
14:06:59 <bros> I use promises, a layer on top. absolute delight.
14:07:12 <zomg> Well technically every time you use a `then` you have a callback ;)
14:07:20 <bros> this is true. :P
14:07:24 <tdammers> indiagreen: I thought the problem was related to staging
14:07:41 <bros> are there any examples of production web apps out there running haskell?
14:07:54 <indiagreen> tdammers: so now you're stuck because deriveJSON will query for your type's constructors, and you have all the info deriveJSON needs, but you can't tell it “hey, don't query anything, here, I'll give you everything you need”
14:08:02 <tdammers> bros: sure... hackage would be a great example
14:08:17 <egm500> hey guys i think i solved my problem  thanks for the suggestions
14:08:19 <bros> tdammers: anything non-haskellers actually use?
14:08:19 <tdammers> bros: and most of the other haskell stuff - hayoo, hoogle, ...
14:08:24 <td123> bros: checkout thoughtbot's github
14:08:32 <catgocat_> Why doesn't this lag?  [1..1e2323] `seq` False
14:08:51 <tdammers> indiagreen: oh, yeah, hmm
14:09:00 * hackagebot HOpenCV 0.4.0.0 - A binding for the OpenCV computer vision library  https://hackage.haskell.org/package/HOpenCV-0.4.0.0 (NoamLewis)
14:09:01 <bros> td123: i see one haskell package.
14:09:36 <bob_twinkles> catgocat_: the [1..1e2323] isn't bound to anything so I'm guessing GHC goes "whup, not a binding, I'll just not do that thanks" 
14:09:44 <bob_twinkles> s/GHC/the run time system/
14:09:49 <hpc> bob_twinkles: not quite
14:09:50 <catgocat_> but doesn't `seq` force that?
14:10:15 <hpc> [1..] (let's use an infinite list for brevity) gets evaluated to WHNF
14:10:19 <td123> bros: and they make money off it
14:10:26 <hpc> meaning the only thing getting forced is the very first (:)
14:10:38 <hpc> meaning you go from <thunk> to (<thunk> : <thunk>)
14:10:47 <indiagreen> it could be because of 1e2323 being evaluated as Rational
14:10:54 <bros> td123: it has 5 forks and 1 star?
14:11:05 <hpc> > [1..] `seq` False
14:11:06 <lambdabot>  False
14:11:17 <indiagreen> which is probably happening on the parsing stage
14:11:29 <bob_twinkles> > let x = [1..] in x `seq` False
14:11:30 <indiagreen> at least «[1..1e23234334] `seq` False» hanged for me
14:11:30 <lambdabot>  False
14:11:36 <td123> bros: and?
14:11:39 <tdammers> bros: there's also http://www.silk.co/
14:12:49 <td123> bros: actually you're looking at the wrong thing i had in mind
14:12:51 <td123> bros: https://github.com/thoughtbot/carnival
14:13:08 <td123> slightly more stars and forks if that's what you're after
14:13:29 <bros> td123: it's all about the stars and forks.
14:14:00 <zomg> After I finish with the startup I'm working with currently maybe I need to start writing more about Haskell
14:14:01 * hackagebot cv-combinators 0.2.0 - Functional Combinators for Computer Vision  https://hackage.haskell.org/package/cv-combinators-0.2.0 (NoamLewis)
14:14:16 <bros> zomg: what's the startup? i'm at a startup too
14:14:24 <zomg> Considering my current ratio of job offers to articles about Haskell is 4:2, maybe by writing a few more I'd eventually be recruited by a company that allows remote
14:14:25 <td123> bros: ah, then maybe you should look at the .net framework by microsoft :)
14:14:27 <zomg> lol
14:14:28 <zomg> bros: www.responsiveads.com
14:14:39 <fatfrank> I can't pass elementary algebra but I understand this shit. And that's why I'll never go back to college 
14:14:40 <bros> zomg: http://skulabs.com
14:14:46 <td123> bros: they're on github now :D
14:14:55 <zomg> bros: looks interesting
14:16:29 <Welkin> power went out for a second :O
14:16:57 <indiagreen> (meanwhile I realised that catgocat_'s question was “why doesn't this lag”, not “why does this lag”)
14:17:01 <tdammers> indiagreen: I wonder if it works if I put the TH that creates the data type in a separate module
14:17:03 <indiagreen> (facepalm)
14:18:20 <Welkin> tdammers: never heard of thoughtbot
14:18:27 <Welkin> it's a comment system? like disqus?
14:20:41 <indiagreen> tdammers: nope, I just checked
14:21:05 <tdammers> indiagreen: indeed
14:25:01 <catgocat_> Oh it doesn't lag because seq stops when it finds a constructor
14:25:16 <catgocat_> so a big list will have no effect, since only the first two elements will be evaluated
14:25:39 <catgocat_> When evaluating an expression, seq stops as soon as it reaches a constructor. For simple types like numbers, this means that it will evaluate them completely. Algebraic data types are a different story. Consider the value (1+2):(3+4):[]. If we apply seq to this, it will evaluate the (1+2) thunk. Since it will stop when it reaches the first (:) constructor, it will have no effect on the second thunk. The same is true for tuples: seq 
14:25:39 <catgocat_> ((1+2),(3+4)) True will do nothing to the thunks inside the pair, since it immediately hits the pair's constructor.
14:26:35 <Welkin> catgocat_: WHNF
14:27:02 <Welkin> catgocat_: you can learn more about seq in Parallel and Concurrent Haskell
14:27:44 <catgocat_> what is  WHNF
14:27:45 <catgocat_> ??
14:27:52 <bob_twinkles> https://wiki.haskell.org/Weak_head_normal_form
14:28:44 <bob_twinkles> I was just reading that since apparently my assumption about what seq does was not correct =P
14:28:58 <hpc> bob_twinkles: what you were thinking of is likely deepseq
14:29:06 <sccrstud92> haha thats what I was gonna say
14:29:14 <bob_twinkles> yeah, I think so
14:29:15 <catgocat_> Welkin: what's the thing about WHNF? I see the definition, but what is it
14:29:23 <catgocat_> what is it about
14:29:51 <Welkin> catgocat_: only the constructor is evaluated
14:29:52 <sccrstud92> its basically a form where we know what the top level constructor of an expression is
14:30:08 <hpc> catgocat_: imagine a data value as a tree
14:30:21 <sccrstud92> so if u have an expression of type Either a b
14:30:40 <Welkin> so, _ becomes Cons _ _ for a list
14:30:48 <sccrstud92> in WHNF u know whether it is a LEft or a Right, but its argument does not need to be in WHNF
14:30:56 <hpc> catgocat_: there's a good image that illustrates it but i can't find it
14:31:18 <hpc> oh, here it is: https://wiki.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
14:31:25 <hpc> catgocat_: (look only at the left side)
14:31:38 <hpc> catgocat_: so, a data value is a tree of sorts
14:31:55 <hpc> with a data constructor at every node
14:32:08 <hpc> (:) has two children, one is the first parameter and the other is the second
14:32:20 <hpc> the second parameter is also a list, so the tree continues down
14:32:41 <hpc> so, your whole list starts out as a thunk
14:33:00 <hpc> when you evaluate to WHNF, you're forcing only the root of that tree
14:33:05 <hpc> giving thunk : thunk
14:33:24 <hpc> or thunk1 : thunk2 -- for clarity
14:33:37 <hpc> if you then WHNF of thunk1, you get 1
14:33:59 <hpc> if you WHNF thunk2, you get
14:34:06 <hpc> 1 : (thunk : thunk)
14:34:35 <hpc> in addition to weak head normal form, there's head normal form which is almost exactly the same
14:34:50 <hpc> and then there's normal form, which is where a value is completely evaluated and there's no thunks in the tree
14:35:16 <hpc> that's where deepseq gets the name of rnf
14:35:37 <ttt_fff> fuck ... suppose I have a type "Foo a b"; is it possible to define a TYPE SIGNATURE "\x -> Foo x b" ? 
14:35:47 <ttt_fff> i.e. I have Expr a = ... ; so I have Expr Untyped and Expr Typed
14:36:01 <hpc> ttt_fff: the closest you can get is
14:36:05 <indiagreen> guys look
14:36:06 <hpc> newtype Foo' b a = Foo a b
14:36:07 <indiagreen> http://imgur.com/a/EPmSl#0
14:36:11 <hpc> er
14:36:17 <hpc> newtype Foo' b a = Foo' (Foo a b)
14:36:18 <ttt_fff> but now, I have somethin gof the form Pat a b = Pat a b ... and I want to declare a typeclass which is like Blah Untyped -> Blah Typed ... but I need for it to do Pat UnTyped b -> Pat Typed b
14:36:20 <indiagreen> (cabal install's parallelisation graphs)
14:36:51 <ttt_fff> hpc: is it possible to tell ghc "anywhere you are expecting a FOo, let me substitute in a Foo' " ?
14:37:02 <ttt_fff> or do I have to redefine all functions that used to operate on Foo to now also operate on Foo' ?
14:37:04 <hpc> uh
14:37:46 <hpc> it's possible, but might not be what you want
14:39:02 <ttt_fff> hpc: tell me how do invoke this unholy spell
14:39:10 <ttt_fff> and I'll look at what it does to deide if I should ahve used it
14:39:17 <ttt_fff> this is the power of THE GIT you can undo mistakes
14:39:25 <ttt_fff> \footnote{so long as it does not involve databases}
14:39:35 <hpc> class FooLike f where {- go mad with power here -}
14:39:44 <ttt_fff> no no; that is too much work
14:39:49 <hpc> yep
14:42:33 <galois_dmwit> type Foo = Foo' -- ?
14:42:42 <hpc> galois_dmwit: there's a flip in there
14:43:00 <galois_dmwit> aha
14:43:04 <galois_dmwit> you're hosed
14:43:09 <hpc> (which is one of the things that can take you right from regular haskell to turing-complete type system)
14:43:12 <hpc> yep
14:45:36 <haasn> scutigera: I got it to work. Not exactly sure how; but I rebuilt GHC from a fresh bootstrap, rebuild cairo/pango/etc., then rebuilt every haskell module from scratch
14:45:42 <haasn> It “just worked” this time around
14:49:08 <scutigera> haasn: was it as much work as it sounds like ? gratz, btw. glad you figured it out.
14:49:22 <scutigera> "just worked". lol.
14:49:55 <scutigera> meanwhile i'm still waiting for ghc 7.10.2 to finish building. takes a lot longer than i remember...
14:50:27 <haasn> scutigera: I had to build ghc 7.10.2 a total of three times, because I kept running out of space in /var/tmp...
14:50:45 <Welkin> 7.10.2 is out?
14:51:03 <scutigera> yes it is 
14:51:11 <haasn> “ghc: panic! (the 'impossible' happened)” oops
14:51:12 <scutigera> as of jul 29
14:51:27 <scutigera> you must be kidding...
14:51:30 <Welkin> haasn: I got that with 7.10.1, so I went with 7.8.4 instead
14:51:52 <scutigera> that's weird. been using 7.10.1 since it came out.
14:51:56 <scutigera> never had a problem.s
14:52:01 <Welkin> on osx
14:52:08 <scutigera> well- there ya god.
14:52:12 <scutigera> go*
14:54:07 <scutigera> in fact- i'm not actually sure why i'm building .2 
14:54:16 <scutigera> should probably just leave well enough alone
14:54:59 <scutigera> but now that it's been building fro a couple of hours i can't bring myself to press ctrl-c
14:56:37 <haasn> Welkin: 7.10.2 here
14:56:40 <haasn> I get it when trying to build vimus
14:56:45 <haasn> This is the only package that runs into the issue
14:56:54 <haasn> https://github.com/vimus/vimus
14:57:00 <haasn> Can somebody else try to build it and confirm the panic?
14:57:11 <Welkin> haasn: are you on osx?
14:57:22 <haasn> Welkin: no
14:57:23 <scutigera> that's weird- doesn't seem like the kind of app that would do that
14:57:28 <Welkin> that was supposed to be fixed in 7.10.2
14:57:33 <scutigera> i can definitely  try as soon as 7.10.2 builds
14:57:40 <scutigera> finishes building.
14:58:09 <haasn> Oh, I just realized I never posted the actual error: https://0x0.st/s9S.txt
14:58:23 <haasn> It only fails on Vimus.Command, the other 37 modules compile fine
14:58:26 <haasn> I'm not really sure why
14:58:55 <Welkin> haasn: try asking in #ghc
14:59:10 <Welkin> this may be a known (or unknown) issue
14:59:50 <scutigera> yeah- seems like that's ticket worthy if not already in the system.
15:00:58 <haasn> I'll report a bug then I guess
15:04:02 * hackagebot HOpenCV 0.4.0.1 - A binding for the OpenCV computer vision library  https://hackage.haskell.org/package/HOpenCV-0.4.0.1 (NoamLewis)
15:04:04 * hackagebot cv-combinators 0.2.0.1 - Functional Combinators for Computer Vision  https://hackage.haskell.org/package/cv-combinators-0.2.0.1 (NoamLewis)
15:11:12 <ttt_fff> https://gist.github.com/anonymous/c5d276e4d38bcb156142 <-- is there a wya to make this lens code work?
15:11:25 <ttt_fff> i.e. I want to use a lens ... but when I make the change, the data type changes from "Foo String" to a "Foo Int"
15:12:56 <ttt_fff> yeah, I have to use Lens instead of Lens'
15:13:58 <tromp_> > sum . filter (\x -> x`mod`3==0||x`mod`5==0) $ [0..999]
15:14:00 <lambdabot>  233168
15:14:12 <tromp_> 495*791+23
15:14:16 <tromp_> > 495*791+23
15:14:17 <lambdabot>  391568
15:18:25 <tromp_> > 495*471+23
15:18:27 <lambdabot>  233168
15:34:19 <ttt_fff> is there a shorthand notation for Control.Arrow.second ?
15:34:22 <ttt_fff> i.e. something like >>2>>
15:35:47 <dmj`> would that be shorter though
15:37:30 <geekosaur> someone may have been doing too much lens :p
15:39:05 <Welkin> haha
15:39:10 <Welkin> save 1 character...
15:39:20 <bennofs> :t Control.Arrow.second
15:39:21 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
15:39:24 <Welkin> ttt_fff: you would LOVE Whitespace
15:39:27 <Welkin> go check it out
15:39:28 <bennofs> how would that work as an operator?
15:39:30 <Welkin> or brainfuck
15:39:50 <bennofs> oh, so you want a shorthand for x >>> second a ?
15:40:33 <ttt_fff> no no, I was wwriting some code \(x, y) -> (x, some complicated expression y) // and hlint, was like "dude, you should use Control.Arrow.second" ... and I'm like "Control.Arrow.second" is too long, maybe someone on #haskell can tell me a nicer operator to use
15:40:56 <Welkin> what?
15:41:03 <Welkin> it is `second`
15:41:13 <Welkin> how is that long?
15:41:26 <bennofs> ttt_fff: `second $ some complictaed expression` is too long?
15:41:28 <ttt_fff> well, I'd do "import qualified Control.Arrow as CA", so it'd be `CA.second`
15:41:30 <Welkin> import Control.Arrow (second)
15:41:37 <dmj`> let scnd = second, solved
15:41:42 <dmj`> q.e.d
15:41:50 <ttt_fff> I thikn "over _2" is better
15:41:59 <dmj`> ttt_fff: +1
15:42:02 <Welkin> really... clarity wins over conciseness
15:42:02 <bennofs> > length "over _2"
15:42:04 <lambdabot>  7
15:42:07 <kadoban> That's … longer.
15:42:10 <bennofs> > length "second"
15:42:11 <Welkin> you won't win any awards for saving one or two characters
15:42:11 <lambdabot>  6
15:42:13 <mniip> :t over _2
15:42:14 <lambdabot> Field2 s t a b => (a -> b) -> s -> t
15:42:24 <mniip> mfw no arrow
15:42:34 <mniip> only the useless (->) profunctor
15:42:43 <bennofs> :t over
15:42:44 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
15:42:47 <dmj`> :t swap
15:42:48 <lambdabot> (a, b) -> (b, a)
15:42:53 <bennofs> yeah, why are _2 lenses not index preserving
15:42:56 <dmj`> > swap . fmap (+2) . swap $ (1,1)
15:42:57 <lambdabot>  (3,1)
15:43:06 <bennofs> surely the type of _2 should include profunctors?
15:43:10 * bennofs is going to sumbit a PR
15:43:12 <bennofs> :t _2
15:43:13 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
15:43:46 <mniip> [00:40:32] <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
15:43:52 <mniip> see the profunctor in the input
15:43:55 <mniip> but not in the output
15:45:00 <bennofs> mniip: there is a profunctor in the output. p a b is the function that you want to apply
15:45:36 <bennofs> mniip: ew, never mean
15:46:19 <mniip> in general it would make sense if 'over' could work on arrows though
15:48:33 <indiagreen> mniip: you know about overA, right?
15:48:43 <bennofs> :t overA
15:48:44 <lambdabot> Arrow ar => LensLike (Context a b) s t a b -> ar a b -> ar s t
15:49:02 * bennofs instantly wonders how that works
15:49:30 * indiagreen admits ne actually has no idea what overA does and what's going on
15:49:37 <Welkin> haha
15:50:10 <Welkin> most of the time I have no idea what is going on in here :D
15:50:18 <Welkin> it's fun to figure it out
15:51:25 <mniip> > runKleisli (overA (_1) (Kleisli $ join replicate)) (3, 5)
15:51:27 <lambdabot>  [(3,5),(3,5),(3,5)]
15:52:10 <bennofs> and that is probably horibly inefficient
15:52:20 <bennofs> > _2 (join replicate) (3,5)
15:52:21 <lambdabot>  [(3,5),(3,5),(3,5),(3,5),(3,5)]
15:52:24 <bennofs> > _1 (join replicate) (3,5)
15:52:26 <lambdabot>  [(3,5),(3,5),(3,5)]
15:54:28 <will> I'm learning haskell and I have a dumb question
15:54:49 <hpc> we'll try to give as dumb an answer as possible ;)
15:55:20 <will> I want to do something like in a OO language where I construct a class with a int which becomes a private static const of the class.
15:55:35 <will> what is the haskell way to do this or work around it?
15:55:51 <will> The int is a limit and I could just pass it to the function 
15:56:26 <will> but I figured that should be a better way.
15:56:27 <Welkin> you can just partially apply it to the function as the first parameter
15:57:00 <kadoban> will: That's a bit hard to answer because I'm not really sure which part is important in that and which part is just how you'd do it in some totally different language. If I had to guess, I'd just make a function  :: Int -> MyType, where MyType is some data type you make, and if you want it private you can put it in a module and don't expose the constructors for MyType.
15:57:35 <johnw> will: rather than thinking in terms of how to implement it, can you describe it in terms of what your integer *means* to a certain class of value?
15:57:56 <johnw> is it some kind of constant or limit associated with all values of a given type?
15:59:15 <will> I want to make a function ( I might mess this up): getLychrelInteration :: Int -> Int -> Int>
15:59:49 <will> first to params are the number I'm giving it to compute and the second is the limit
16:00:03 <johnw> and you'd like the implicit to be implied over a range of like computations?
16:00:08 <johnw> s/implicit/limit
16:00:13 <will> I thought i could just construct a module / class with the limit instead of passing it to the function
16:00:19 <will> because it would probably be recursive
16:00:26 <johnw> Reader could be quite appropriate here
16:00:35 <johnw> Int -> Int -> Reader Int ResultType
16:00:41 <johnw> this will compose/recurse nicely
16:01:26 <Welkin> you can also construct the function with the proper limit as needed through partial application
16:01:44 <will> basically the function would return the number of which the number converges to a palindrome or return the limit because it could go on forever and never converge (maybe).
16:03:45 <isovector> heya. i'm trying to use stack to build an xmonad project, but everything is going horibly wrong
16:04:15 <johnw> Welkin: will that help with recursion?
16:04:28 <johnw> Welkin: it would certainly solve the case of calling the function from elsewhere
16:04:32 <isovector> in particular, one of the xmonad files needs Applicative, but compiling it says it's not in scope, so I figured I'd upgrade base to 4.8, but now stack complains about global constraints?
16:06:04 <Welkin> you could have the function recurse internally using `go a b` if you'd like
16:06:26 <Welkin> the same trick used in base for many functions, including foldr/foldl
16:06:57 <johnw> oh yeah, of course
16:07:01 <johnw> I use that trick all the time myself, heh
16:07:15 <will> ah I didn't think of that
16:07:24 <will> I'll look into those suggestions, thanks guys
16:07:34 <geekosaur> isovector, you can;t upgrade base
16:07:38 <geekosaur> it's wired into the compiler
16:07:47 <will> still trying to get my head out OO
16:07:50 <geekosaur> get the previous version of xmonad-contrib to fix that error
16:07:58 <will> out of *
16:08:13 <geekosaur> (I have complained about the versioning on that and apparently whoever is handling xmonad packaging doesn't care)
16:08:31 <johnw> will: in the beginning, don't fear passing lots of arguments around
16:08:43 <johnw> will: it's better to run headlong into the abstraction you need, than to invest time in a solution you don't really need at all
16:09:25 <isovector> geekosaur: awesome, thanks, i'll give it a try. I thought base told stack which compiler to use?
16:09:30 <will> good suggestion I think. I do get side tracked too much trying to understand everything at once.
16:10:01 <geekosaur> hm, haven't used stack so don't know if that is enough to make it install a new compiler. but that doesn't get you out of the woods anyway
16:10:09 <geekosaur> because stack may use it, but xmonad itself won't when yoiu mod-q
16:10:30 <geekosaur> it does noty know about strack or cabal, it uses ghc directly and you'd better hope the right one is in $PATH
16:11:06 <geekosaur> (I have some notes on improving that a bit, but am hung up on some other changes that need to happen --- and on a work project that is eating much of my programming time)
16:11:45 <Welkin> will: you can be very productive in haskell while understanding very little other than the basics
16:12:07 <Welkin> the more I learn abut haskell (mainly the libraries) the less I feel I know
16:12:11 <isovector> i absolutely hate building any haskell project; it never seems to work without an hour or two of work =/
16:12:19 <isovector> is there somewhere I can go to learn what I should be doing?
16:12:25 <Welkin> isovector: what do you mean?
16:12:32 <Welkin> what exactly is the problem you are having?
16:13:01 <Welkin> isovector: a project you downloaded from someone else?
16:13:04 <isovector> Welkin: i think it's mostly I don't know how stack works -- it's supposed to fix version hell? 
16:13:06 <Welkin> does it contain a cabal.config?
16:13:13 <isovector> when i'm working on my own projects
16:13:17 <Welkin> if you include a cabal.config you should not have any issues
16:13:26 <Welkin> isovector: ah, I know what you mean
16:13:34 <Welkin> ever since using a cabal.config I never have any issues
16:13:37 <isovector> cabal has build-depends, but stack has extra-deps, and these are different, or something?
16:13:52 <Welkin> use `cabal freeze` to create a cabal.config with the exact package versions
16:14:07 <Welkin> isovector: build-depends is not enough
16:14:19 <Welkin> cabal.config is what you want
16:15:16 <isovector> is there some document somewhere that explains how all of these things integrate together?
16:15:25 <isovector> i haven't managed to find anything
16:15:31 <Welkin> I don't know abot stack, since I haven't used it
16:15:52 <isovector> fair enough.
16:16:05 <Welkin> you can use stackage (which is just a cabal.config) to ensure everything builds too
16:18:05 <isovector> Welkin: with cabal, there is no good way of doing a global package install, is there?
16:18:17 <Welkin> cabal is not a package manager
16:18:29 <Welkin> it is best to install into sandboxes
16:18:31 <isovector> if xmonad builds directly through ghc, then i can't use a sandbox?
16:18:52 <Welkin> if you just do `cabal install <package>` it installs globally
16:19:00 <Welkin> well, outside of a sandbox
16:19:04 <Welkin> do you know how to use sandboxes?
16:19:20 <isovector> yeah, i do. 
16:19:23 <Welkin> just cd into a directory, use `cabal sandbox init`
16:19:25 <Welkin> okay
16:19:57 <isovector> but geeoksaur above says xmonad builds directly with ghc, so any packages it needs can't be in a cabal sandbox afaik?
16:19:58 <Welkin> you can also specify which version of ghc to use, if you have multiple installed
16:20:08 <Welkin> eh?
16:20:17 <Welkin> no, he said that base comes with ghc
16:20:20 <isovector> xmonad has an automatic recompile thing built into it
16:20:39 <isovector> <geekosaur> it does noty know about strack or cabal, it uses ghc directly and you'd better hope the right one is in $PATH
16:20:53 <HijiriPhone> I use xmonad in a sandbox
16:21:04 <Welkin> oh, I don't know anything about xmonad specifically
16:21:14 <HijiriPhone> but I need a lot of hacky workarounds to deal with the envvars that get set
16:21:24 <isovector> HijiriPhone: yeah? am i just being stupid?
16:22:06 <HijiriPhone> I don't remember exactly what I do
16:22:07 <isovector> it's just super frustrating. i want to do more HS dev but it always gets annoying to get packages to place nicely with one another
16:22:21 <HijiriPhone> I install xmonad from hackage in a cabal sandbox
16:22:27 <isovector> no worries. i'll go back to fighting with it
16:22:45 <HijiriPhone> and then in my path I have a thing that does cabal run or cabal exec or something
16:22:55 <geekosaur> isovector, there is currently a helper for xmonad in a sandbox. one caveat is you must rebuild your config manually from inside the sandbox
16:23:03 <geekosaur> because mod-q will do the wrong thing
16:23:17 <HijiriPhone> and in my xmonad.hs I have it unset the cabal vars, except I also need to set then back on for recompile
16:23:33 <HijiriPhone> geekosaur: I hacked a way to mod-q
16:23:40 <geekosaur> yeh, that doesn't help with some of the automatic recompilations (like on startup) though
16:23:52 <isovector> i guess i can live wihtout that
16:24:13 <HijiriPhone> It looks like it's working for me
16:24:15 <geekosaur> I have plans to expose that stuff in XConfig so it can be overridden, but that still won't help the startup recomp check because that's done in the prebuilt xmonad using its hardwired confiug
16:34:05 * hackagebot vty 5.2.11 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.2.11 (CoreyOConnor)
16:34:33 <isovector> Welkin: you're right. i just dumped stack and went pure cabal and everything worked
16:34:56 <isovector> it'd be nice to not have a million copies of mtl et al around my system, but i guess i can't complain so long as it builds :D
16:35:45 <hpc> if it fits, i ships
17:29:49 <illsci> monads... 
17:30:36 <juri_> damned monads. </caprica>
17:31:41 <ttt_fff> I <3 monads.
17:32:19 <conal> some monads? all monads? monad-ness?
17:33:41 <haasn> I prefer monoids.
17:34:13 <ttt_fff> conal: let's talk FRP
17:34:24 <ttt_fff> conal: is it true that for discrete FRP, if I do push in a dumbass way, I can get exponential time instead of linear time?
17:34:37 <ttt_fff> conal: i.e. functions that take 2 args , and due to slight timings, constantly recomputing
17:34:48 <ttt_fff> conal: with pull-frp, I avoid this issue right? (at the cost of having to keep the histroy around)
17:34:51 <ttt_fff> conal: is this correct?
17:35:40 <conal> ttt_fff: it depends on which dumbass way, but i think i know which one you mean, and then yes. with a pull implementation, there's a dual danger.
17:36:06 <ttt_fff> conal: let's talk push first
17:36:10 <ttt_fff> suppose we don't do a topological sort
17:36:31 <ttt_fff> and suppose every node, when any of it's args changes, it recomputes, and immediately fires off its new value
17:36:50 <conal> ttt_fff: sure. and top-sort only works for acyclic dependencies, which rules out a lot of useful cases.
17:36:53 <ttt_fff> then, if we have arelaly really shitty timing, I feel like that I can cause an 2^n number of functional calls (to update a graph with n nodes)
17:37:09 <conal> ttt_fff: yes, i think so
17:37:14 <ttt_fff> conal: sure, ... how does pull have a 'dual danger' ?
17:37:27 <ttt_fff> conal: for pull, it seems like every node _is only computed once_
17:37:31 <ttt_fff> so it seems worst case linear time
17:38:42 <conal> ttt_fff: let { f1 = sin; f2 = f1+f1; f3 = f2+f2; ... } in f100 (pi/3), where (+) = liftA2 (+) .
17:38:59 <ttt_fff> yeah, but pul can 'cache'
17:39:06 <ttt_fff> whereas push can't, since an arg is being updated
17:39:17 <ttt_fff> in a smar pull, f1, f2, f3, ... are only going to be evaluated once
17:39:32 <ttt_fff> whereas push can't be samrt because on each push, it's because an arg changed
17:39:39 <conal> ttt_fff: one has to take care for either push or pull. different "smart" solutions.
17:40:41 <ttt_fff> for push, if you don't topological sort, you can't do a smart solution
17:40:51 <ttt_fff> in pull, regardess of the order of how the nodes query, as long as there is caching, it's smart
17:41:07 <ttt_fff> so for push, you need global coordination for smart; for pull, you only need local caching
17:41:21 <ttt_fff> I feel like I'm arguing with trovalds about linux kernel internals; if I'm wrong, please correct me
17:41:40 <ttt_fff> you invented frp after all, so please correct me if I am misunderstanding something
17:42:57 <conal> ttt_fff: i'm not sure that push *needs* global coordination for efficiency.
17:44:01 <conal> ttt_fff: though it needs something. there are trickier protocols involving pushing invalidations, and pulling with re-validation.
17:44:19 <ttt_fff> imagine we have input signals a1, a2; then we have b1 = a1 + a2, b2 = a2 + a2; c1 = b1 + b2, c2 = b1 + b2; then we update a1, a2 // with shitty timing, we can force:
17:44:32 <ttt_fff> b1 to recompute 2 times, b2 to recompute 2 times; c1 to recompute 4 times, c2 to recompute 4 times
17:44:46 <ttt_fff> then if I have d1 = c1 + c2, d2 = c1 + c2; we can have each of d1/d2 recompute 8 times
17:44:49 <ttt_fff> and so on and so forth
17:44:58 <ttt_fff> (this is with absolute worst case timing)
17:45:14 <conal> ttt_fff: i understand what you're saying about a *particular* dumb strategy.
17:45:21 <conal> ttt_fff: any of these stateful optimizations are less appealing when considering parallel execution. and if we care about efficiency at all, then parallel-friendly is crucial.
17:46:13 <ttt_fff> well, in the case of GUI, I thin the # of objects are sufficiently small that doing a linear time topsort every time the graph changes is not too expensive
17:46:59 <hpc> until someone decides that they should make a massive amount of changes to a gui one item at a time
17:47:14 <hpc> and then the program comes to a complete halt just redrawing buttons
17:47:32 <hpc> (source: have seen programs do that)
17:47:40 <geekosaur> ...so have I
17:47:57 <hpc> my favorite is nexus mod manager
17:48:00 <ttt_fff> I think that problem can be solved with a .22
17:48:01 <conal> ttt_fff: these strategies and others have been explored quite a bit for constraint systems (uni- or multi-directional). there are incremental solvers, such as deltablue and skyblue (used in TBAG, the immediate predecessor to ActiveVRML, which was the first FRP system)
17:48:03 <hpc> which also makes a click sound as it goes
17:48:10 <hpc> so the program goes totally unresponsive, and you just hear
17:48:15 <hpc> click... click... click...
17:48:32 <hpc> and then the window flashes a bunch and you're good to go
17:48:41 * geekosaur does wonder how much of that was playing the clicks synchronously >.>
17:48:52 <ttt_fff> conal: what do I google for deltablue/skyblue are bring up airline companies + soccer teams
17:49:04 <geekosaur> since it ought to be at least a low buzz...
17:49:37 <geekosaur> (and speaking of channels where I do not expect to hear mention of SBFC....)
17:50:18 <dramforever> hmm...FRP
17:50:21 <conal> ttuegel: https://www.google.com/search?q=deltablue+skyblue+constraint
17:50:24 <conal> oops
17:50:33 <dramforever> how's it going?
17:50:33 <conal> oh. ttt_fff left.
17:50:55 <conal> @tell ttt_fff  https://www.google.com/search?q=deltablue+skyblue+constraint
17:50:55 <lambdabot> Consider it noted.
17:52:43 <dramforever> hmm, isn't there a dynamic topological sort algorithm?
17:53:26 <conal> dramforever: iirc, deltablue & skyblue include such an algorithm
17:53:33 <ReinH> conal: hi!
17:53:37 <conal> ReinH: hi!
17:53:40 <dramforever> yeah so the cost is even smaller
17:53:43 <ReinH> How are you?
17:54:13 <ReinH> conal: are you working with Jeff P now?
17:54:21 <conal> ReinH: doing well; thanks.
17:54:37 <conal> ReinH: yes. jeff & i are working together.
17:55:02 <ReinH> Oh great. We worked together previously. He's super smart :)
17:55:21 <conal> ReinH: oh, yeah. i'm enjoying working with him.
17:55:43 <ReinH> Tell him I said hi :)
17:55:47 <conal> ReinH: i'm finding some interesting angles on the network security stuff. still hoping to back to haskell-to-hardware compilation.
17:55:50 <conal> ReinH: will do.
17:55:57 <ReinH> Oh fun :)
17:58:08 <conal> ReinH: giving the haskell-to-hardware talk at BayHac reminded me how much i like that project. http://begriffs.com/posts/2015-06-28-haskell-to-hardware.html
17:59:09 * hackagebot moesocks 0.1.0.13 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.13 (JinjingWang)
18:01:23 <ReinH> conal: have you looked into the relationship between denotation design and final encodings? It seems like denotational design often used the host language's functions so internal homs to represent the design.
18:01:46 <ReinH> e.g., FRP as defined by a function from the reals.
18:02:12 <ReinH> final encodings in Haskell also often look like internal homs.
18:02:18 <conal> ReinH: no, i haven't explored that connection. thanks for the suggestion!
18:02:37 <ReinH> :)
18:07:03 <ReinH> conal: I wonder if there's also a general connection to representable functors or just for FRP.
18:07:14 <ReinH> I have an intuition that there might be.
18:07:54 <conal> ReinH: representable functors come up often, but there are non-function denotations as well.
18:08:04 <ReinH> Interesting :)
18:08:21 <conal> ReinH: there's an example in a recent talk. digging it up...
18:09:10 <ReinH> Thanks
18:09:34 <conal> ReinH: see http://conal.net/talks/denotational-design-lambdajam-2014.pdf, slide 44.
18:09:55 <johnw> ReinH: Oleg wrote: "In the final approach, object language terms are represented as expressions built from a small set of combinators, which are ordinary functions rather than data constructors. The values of these ex- pressions give denotations of the corresponding object terms. An object term is hence represented not by its abstract syntax but by its denotation in a semantic domain. Abstracting over the domain gives us a family of
18:09:56 <johnw> interpretations."
18:09:58 <ReinH> conal: I'm finding that representables come up a lot in my half baked attempts at denotational design.
18:10:08 <conal> ReinH: cool. me too. :)
18:10:26 <ReinH> :)
18:10:45 <conal> ReinH: That ListX example generalizes the "partiality monad", and suggests a nice denotation for the latter.
18:10:47 <ReinH> Intuitively it makes a lot of sense.
18:11:37 <ReinH> I also wonder what the relationship to finally tagless approaches might be.
18:11:57 <johnw> ReinH: that quote I gave is from a paper on the finally tagless approach
18:12:09 <ReinH> Yeahhhhh I should read that then
18:12:16 <conal> ReinH: the exercise in that slide is to deduce the Monad instance of ListX a, so that mu is a monad morphism. (similarly for Functor and Applicative.)
18:12:22 <ReinH> I keep stumbling on these designs
18:13:15 <ReinH> Yesssss typeclass morphisms are very robust tools
18:14:47 <conal> ReinH: amazingly so. specifications for free. and they guarantee that the class laws hold and the absence of abstraction leaks.
18:16:48 <ReinH> That's the thing I keep coming back to. Abstractions that don't leak. Coming from other languages this is alien to me.
18:17:40 <conal> ReinH: maybe because rigor isn't practical in most languages.
18:17:47 <ReinH> Heh. Yes.
18:17:59 <conal> ReinH: even for haskell, i wonder what fraction of libraries have specifications. seems to be out of vogue.
18:18:29 <ReinH> Now I find lots of things I can't express in Haskell though. Linear types for instance.
18:19:02 <conal> ReinH: maybe the re-introduction of (non-denotative) imperative programming with "monadic IO" eroded the earlier culture of reasoning/rigor.
18:19:08 <nitrix> ReinH: Implementation-wise?
18:19:34 <ReinH> I run into that problem with the L-system lib. No way to say  production rules must be applied exactly once.
18:20:05 <conal> ReinH: oh! is apply-once important in L systems?
18:20:12 <roboguy_> ReinH: I found something that looks sorta like a linear type to me in Haskell before. not quite the same though
18:20:54 <ReinH> "At least once" has the same fixed point but I can't even say that!
18:22:25 <ReinH> `return axiom` type checks and never applies the production rules!
18:22:32 <athan> Is there a good reason why `wai-util` isn't available on stackage? Or better, is there a #stackage channel?
18:23:24 <ReinH> Most I can say is "the production rules are applied zero or more times" :(
18:25:44 <conal> ReinH: L systems require each rule to be applied?
18:25:45 <ReinH> They are a parallel rewrite system. Yes. Not rewriting is bad. ;)
18:26:03 <ReinH> I need to say "exactly once" and I can't even say "more than zero"
18:27:43 <ReinH> conal: let me finish writing this pearl up and I'll bug you to review it?
18:27:55 <ReinH> You might have some valuable insights.
18:28:01 <conal> ReinH: yes! i'd like to understand what you're up to.
18:28:13 <ReinH> Me too! :D
18:28:55 <conal> :)
18:55:34 <broma0> Anyone using GHCJS or Fay or the like?
18:56:26 <Cale> broma0: I've played around with GHCJS a bunch
18:57:13 <mgsloan> I've used Fay a bunch and GHCJS quite a bit.  I think nowadays GHCJS is the clear choice
18:57:16 <broma0> Cale, I'm thinking about starting to play around with it too.. any comments on it? Fun? Practical yet?
18:57:42 <ttt_fff> if you're not allowed to use haskell; what's the next best langauge for ensuring purity? erlang?
18:57:50 <broma0> mgsloan, what kinds of projects?
18:58:10 <Axman6> Erlang doesn't ensure purity at all IIRC
18:58:16 <mgsloan> broma0: FP Haskell Center / School of Haskell (v 2.0 is in GHCJS)
18:58:20 <Axman6> you can print from anywhere in an erlang function
19:00:13 <mgsloan> GHCJS is definitely practical, I was pleasantly surprised by how little I ran into bugs that were due to it.  And _very_ pleasantly surprised with how many existing haskell projects build with it
19:00:37 <dramforever> IIRC most pure programs work with it
19:00:50 <ttt_fff> the ahrdest part about ghcjs is getting it to compile
19:00:57 <dramforever> lol exactly
19:01:06 <dramforever> kinda like chrome
19:01:29 <ttt_fff> dunn oabout that; I have gotten ghcjs to compile 4 times in mylife
19:01:35 <ttt_fff> I have never gotten chrome to build
19:02:06 <dramforever> =)
19:03:45 <Cale> broma0: It's pretty good. I was able to compile diagrams with it, generate SVG client side and splice it into the DOM dynamically (though browsers are really bad at dealing with thousands of new DOM elements you get with complicated diagrams)
19:04:23 <Cale> (using reflex-dom)
19:04:53 <broma0> I think I'll start looking into ghcjs
19:05:00 <broma0> Thanks for the comments
19:26:44 <zomg> How big is the overhead from GHCJS libs that it needs to include to make things run?
19:27:04 <zomg> (let's assume gzip to make things sensible)
19:30:47 <ttt_fff> zomg: it's not too bad, I was playing with it on a local virtual machine, seemed snappy enough to me
19:31:14 <dramforever> "local"
19:31:15 <ttt_fff> also, there's #ghcjs
19:31:38 <zomg> Anything is snappy in local :P
19:31:45 <ttt_fff> dramforever: local need not be in quotes; it was inside a virtualbox ubuntu; 'local' is real, not <begin finger quotes> local </end finger quotes>
19:31:51 <zomg> but if the size is like 50 kilos or so it's fine I'd imagine
19:32:02 <zomg> or even if it was more than that but <200k or something
19:32:03 <dramforever> ttt_fff: no I mean you said local
19:32:12 <dramforever> and zomg was talking about the *size* overhead
19:32:47 <ttt_fff> yeah, size is independent of whetehre it's served from local or remote
19:32:50 <ttt_fff> they're orthogonal issues
19:33:21 <zomg> considering our app has jquery, lodash, angular and a bunch of misc things
19:33:32 <zomg> it could be fairly sizeable to not really be a huge concern I suppose =)
19:37:09 <koala_man> let's say I had a hundred completely independent functions that I want to run on some input. what are the pros and cons of putting one function in each of a hundred modules, or a hundred functions in a single module?
19:37:21 <ttt_fff> zomg: adding ghcjs to those libraries would be like adding the atlantic ocean to a kiddy pool
19:37:43 <dramforever> koala_man: how independent?
19:38:12 <zomg> ttt_fff: so it's that big? :P
19:38:31 <ttt_fff> if you want small, you should probably go with fay or haste
19:38:48 <koala_man> dramforever: an input type Foo, a hundred functions :: Foo -> Bar, and then I want a Foo -> [Bar] for each of the hundred functions at the end
19:38:51 <zomg> Yeah I was just wondering like are we talking about 100s of kb's or mbs or what
19:38:57 <koala_man> specifically it's a static analysis tool 
19:39:16 <koala_man> with checks for various things that don't overlap
19:39:22 <dramforever> that's...weird
19:39:26 <koala_man> is it?
19:39:32 <dramforever> so many functions..
19:39:47 * dramforever thinks he has never written that many functions
19:39:53 <dramforever> never mind
19:40:00 <ttt_fff> zomg: from when I last used ghcjs: output is more than 1 kb, and less than 1 GB
19:40:11 <zomg> how useful :P
19:40:36 <koala_man> I'm tempted to put each file in a separate module to let them all compile in parallel, but I imagine there's some overhead
19:40:39 <hpc> it may also be larger than 2kb
19:40:41 <koala_man> each function that is
19:40:49 <hpc> on a logarithmic scale, that halves the possibilities!
19:40:54 <ttt_fff> hpc: how sure are you of that? with what probability?
19:41:04 <koala_man> dibblego!!
19:41:05 <ttt_fff> koala_man: I'd put them all in 1 file, just so with vim, it's easier to serach / find / replace
19:41:18 <hpc> (the output of ghcjs is actually numberwang)
19:41:22 <ttt_fff> I find working with tons of small files really fucking annoying in vim
19:41:31 <koala_man> ttt_fff: that's what I'm currently doing, and it's 3559 lines long
19:41:45 <ttt_fff> hmm, most of my fiels are about 300 lines long
19:41:55 <ttt_fff> perhaps you can somehow categorize them and split into a few modules
19:42:28 <zomg> Yeah I'm sure I could've just rolled some dice and used that as the value
19:42:40 <koala_man> I could make up a somewhat arbitrary grouping
19:42:41 <zomg> the answer would've been about equally useful =)
19:42:56 <ttt_fff> zomg: let me help you https://xkcd.com/221/
19:43:28 <zomg> it must be the smartass hour
19:43:31 <zomg> I'll try again later :P
19:44:04 <codehero> @let rng = 4 -- chosen by fair dice roll
19:44:04 <lambdabot>  Defined.
19:44:10 <codehero> there you go
19:44:11 <codehero> > rng
19:44:12 <lambdabot>  4
19:47:51 <ttt_fff> @let a = b = 2
19:47:51 <lambdabot>  Parse failed: Parse error: =
19:48:12 <slack1256> @let ~(a,b) = 2
19:48:13 <lambdabot>  .L.hs:147:1:
19:48:13 <lambdabot>      Could not deduce (Num (t, t0))
19:48:13 <lambdabot>      from the context (Num (t, t1))
19:48:32 <ttt_fff> > who
19:48:33 <lambdabot>  2
19:49:26 <ttt_fff> @unlet who
19:49:26 <lambdabot>  Parse failed: TemplateHaskell is not enabled
19:49:36 <ttt_fff> @forget who
19:49:36 <lambdabot> Incorrect arguments to quote
19:49:53 <dramforever> @unlet
19:49:53 <lambdabot>  Define what?
19:49:59 <dramforever> @undefine
19:49:59 <lambdabot> Undefined.
19:50:02 <dramforever> horray
19:50:20 <ttt_fff> @unlet who
19:50:20 <lambdabot>  Parse failed: TemplateHaskell is not enabled
19:50:27 <ttt_fff> @undefine who
19:50:27 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
19:50:37 <ttt_fff> ouch
19:52:35 <ttt_fff> > who is the greatest
19:52:36 <lambdabot>  "ttt_fff"
19:52:38 <ttt_fff> yay
19:52:45 <slack1256> @slap ttt_fff
19:52:45 * lambdabot beats up ttt_fff
19:52:45 <ttt_fff> okay, back to work
19:52:50 <slack1256> who is the greatest now?
19:53:52 <ttt_fff> > who is not nice
19:53:54 <lambdabot>      Ambiguous occurrence ‘not’
19:53:54 <lambdabot>      It could refer to either ‘L.not’, defined at L.hs:141:11
19:53:54 <lambdabot>                            or ‘Data.Bool.not’,
19:53:59 <ttt_fff> damn
19:54:08 <ttt_fff> @undefine
19:54:08 <lambdabot> Undefined.
19:55:32 * slack1256 feels ttt_fff is defining *evil* on lambdabot
19:57:02 <ttt_fff> slack1256: nah, doing real work; done with bot abuse
20:02:24 <Lokathor> ghc spits out a bug when i try to compile a program on ARM
20:02:26 <Lokathor> ghc: internal error: ARR_WORDS object entered!
20:02:34 <Lokathor> but it's for 7.8.4
20:02:40 <Lokathor> should i still bother to report it?
20:03:44 <kadoban> Lokathor: In general, I would think the thing to do would be to see if it still happens on the newest released version, if at all possible.
20:04:59 <Lokathor> i do not believe that it's possible for me to build the latest GHC on this device
20:05:41 <Lokathor> the last time i tried to build a fresh copy of the same version as i already have, that failed to build (the version i have came from the repo)
20:06:21 <dramforever> does the program work on "regular" machines?
20:07:27 <Lokathor> it's the section 1 IRC bot from the wiki https://wiki.haskell.org/Roll_your_own_IRC_bot
20:07:55 <Lokathor> i've built it before on other devices, so i know that the source isn't horribly out of date or anything like that
20:08:06 <dramforever> looks innocent
20:08:44 <jsidfofo> how do i install the latest version of a package and automatically add it to the dependencies in my project's cabal file? using stack or cabal
20:09:13 <Lokathor> jsidfofo, you need to add it to the build-depends: section of your cabal file
20:09:27 <jsidfofo> Lokathor: yeah I know, but can this be done automatically?
20:09:29 <Lokathor> then cabal will pull it in when it needs with "cabal install --dependencies-only"
20:09:46 <Lokathor> oh you mean automatically add a package to a new cabal file being generated? dunno about that
20:09:48 <jsidfofo> something like npm install --save 
20:09:49 <kadoban> jsidfofo: Yeah, do it the other way around. Add it to the file yourself, then do whatever installs deps, that ^ for cabal, or just rebuild or whatever for stack.
20:10:09 <jsidfofo> hmm ok
20:21:42 <jsidfofo> How do I resolve the following stack error: "aeson: needed (>=0.9), latest is 0.9.0.1, but 0.8.0.2 found" ?
20:24:17 <zomg> At least with cabal, a cabal install would usually fix that but not familiar with Stack myself
20:25:56 <jsidfofo> cabal install didn't solve the issue
20:27:09 <geekosaur> it wouldn't, stack uses its own stuff
20:27:57 <kadoban> jsidfofo: What resolver are you using?
20:29:19 <jsidfofo> koshmar: lts-2.21
20:30:14 <kadoban> jsidfofo: Do you have GHC installed manually, or is stack managing all of that itself?
20:30:33 <jsidfofo> kadoban: stack has its own ghc
20:30:39 <jsidfofo> but I also have a global one
20:31:20 <jsidfofo> I was trying to determine which one stack was using by doing 
20:31:37 <jsidfofo> "stack ghc --version" but it seems to pass the --version flag to stack instead of ghc
20:31:54 <kadoban> jsidfofo: The reason I ask is that the only time I've gotten those kind of errors was when I had things globally installed via cabal before I started using stack.
20:32:47 <kadoban> jsidfofo: IIUC, if you have the right version of GHC installed, it'll use that. So if you have 7.8.x installed, it'll be using your global one, which … may be a problem? I'm really not sure how/if stack is supposed to manage that, or if it even tries. Goes beyond my understanding of both stack and GHC package management.
20:33:38 <kadoban> jsidfofo: I just know I stopped getting those errors when I nuked my global GHC installation and cabal database and just let stack handle it all. I have no idea if that's supposed to be the case, but … yeah.
20:34:26 <jsidfofo> kadoban: stack is supposed to be independent from the global cabal and ghc according to their documentation
20:34:47 <jsidfofo> I just downgraded by aeson version to 0.8 and did stack init
20:34:59 <jsidfofo> now build seems to be doing something...
20:35:25 <kadoban> jsidfofo: I don't know what that could mean, when it'll use the global ghc when it exists.
20:36:04 <jsidfofo> kadoban: I guess maybe it just uses the ghc for compilation which shouldn't matter since its just a immutable binary
20:36:51 <jsidfofo> but the package management in stack is supposed to be completely isolated
20:37:35 <kadoban> jsidfofo: Maybe. I'm not sure that's actually how it works though. If it's completely isolated, then my experience is hard to explain (once I nuked the global stuff, I stopped getting errors).
20:38:23 <kadoban> Though I haven't made a repeatable testcase of it, so … who knows.
21:04:28 <sgronblo> im trying to set up a simple test file for a small project. ghc-mod shows me that Test.Hspec could not be found and tells me to add it to build-dependencies (it doesnt tell me to which build-deps), so i just added them to my test-suite section's build-deps but that didnt solve the problem. if i run cabal test i get some really weird "inappropriate type" error.
21:09:29 <peterson> hey ..
21:09:51 <peterson> trying to use (\\) function (ghc 7.10.2) and getting "not in scope" error
21:09:51 <peterson> ideas?
21:11:44 <peterson> ignore .. :) not in prelude
21:12:42 <monochrom> is it in Data.List?
21:13:07 <peterson> yep
21:13:13 <peterson> sorry brain-snap ;)
21:16:16 <codehero> :t (\\)
21:16:17 <lambdabot> Eq a => [a] -> [a] -> [a]
21:16:26 <codehero> Eq. huh
21:16:28 <codehero> well
21:16:30 <codehero> it does something
21:16:44 <codehero> > [1,2,3,4,5] [5,4,3,2,1]
21:16:46 <lambdabot>      Couldn't match expected type ‘[Integer] -> t’
21:16:46 <lambdabot>                  with actual type ‘[Integer]’
21:16:46 <lambdabot>      The function ‘[1, 2, 3, 4, ....]’ is applied to one argument,
21:16:49 <codehero> > [1,2,3,4,5] // [5,4,3,2,1]
21:16:51 <lambdabot>      Couldn't match expected type ‘Array i e’
21:16:51 <lambdabot>                  with actual type ‘[Integer]’
21:16:51 <lambdabot>      In the first argument of ‘(//)’, namely ‘[1, 2, 3, 4, ....]’
21:16:57 <codehero> > [1,2,3,4,5] \\ [5,4,3,2,1]
21:16:59 <lambdabot>  []
21:17:00 <codehero> okay
21:17:02 <codehero> interesting
21:17:04 <codehero> nothing
21:17:12 <codehero> > [1,2,3,4,5] \\ [5,4,3]
21:17:13 <lambdabot>  [1,2]
21:17:17 <codehero> oh
21:17:19 <codehero> there we go
21:17:25 <codehero> of course
21:17:35 <kadoban> I think it's difference, treating them as sets probably. I assume it's one of those things with quite poor performance in practice though.
21:17:58 <codehero> hm
21:28:34 <codehero> hm
21:28:38 <codehero> the source is pretty simple
21:28:41 <codehero> (\\)                    =  foldl (flip delete)
21:29:58 <codehero> although it would be smarter to just make a new function with foldl'
21:30:32 <codehero> @let diff = foldl' (flip delete)
21:30:34 <lambdabot>  Defined.
21:30:59 <codehero> diff [1..10000] [5..20000]
21:31:02 <codehero> > diff [1..10000] [5..20000]
21:31:04 <lambdabot>  [1,2,3,4]
21:31:14 <codehero> > [1..10000] \\ [5..20000]
21:31:15 <lambdabot>  [1,2,3,4]
21:31:18 <codehero> hm
21:31:31 <codehero> > [1..10000] \\ [1..20000]
21:31:33 <lambdabot>  []
21:31:44 <codehero> > [1..10000] \\ [5000..20000]
21:31:47 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
21:31:59 <codehero> doesn't seem to bad
21:38:53 <codehero> *too
21:42:28 <greves> haskell seems so much more like math than any other language i've done, it's great
22:54:20 * hackagebot webkitgtk3-javascriptcore 0.13.1.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkitgtk3-javascriptcore-0.13.1.0 (HamishMackenzie)
22:54:22 * hackagebot webkit-javascriptcore 0.13.1.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkit-javascriptcore-0.13.1.0 (HamishMackenzie)
23:02:44 <kadoban> Is there a way to tell if @tell messages have been delivered?
23:05:32 <ttt_fff> I can understand how one invents lisp. However, how the fuck does one invent haskell?
23:06:25 <rom1504> ttt_fff: https://en.wikipedia.org/wiki/Haskell_(programming_language)#History
23:12:32 <zomg> kadoban: use MemoServ :P at least I seem to recall that had delivery info
23:13:25 <johnw> ttt_fff: start with a simply typed lambda calculus, and start adding fetaures like non-strictness, operator notation, ADTs, pattern matching, etc.
23:13:40 <johnw> core Haskell is really small
23:14:32 <greves> what's the deal with the indentation in the first example on this page? http://book.realworldhaskell.org/read/functional-programming.html
23:14:40 <greves> i've handwritten the function and my indentation is not working
23:14:57 <dramforever> what's the deal?
23:15:05 <dramforever> oh lemme check
23:15:12 <greves> mine is: https://dpaste.de/qvuB
23:15:41 <greves> (error on line 9:9)
23:15:55 <EvanR> ttt_fff: i dont understand how they invented lisp, but haskell was based on previous typed functional languages
23:15:59 <dramforever> yes, you're indentation is wrong
23:16:22 <dolio> EvanR: The same person invented them both. Alonzo Church.
23:16:25 <dramforever> are you sure line 9?
23:16:31 <ttt_fff> lisp/forth is easy; you start by thinking: what langauge is it simplest to write an interpreter for?
23:16:43 <greves> hello.hs:9:9: parse error on input ‘args’
23:16:47 <EvanR> ttt_fff: in what language
23:16:47 <ttt_fff> haskell is insane: so many weird features that somehow magically work together
23:16:55 <zomg> I don't see anything wrong with the indentation unless I'm becoming blind
23:17:22 <zomg> oh wait I see it
23:17:23 <EvanR> read + eval doesnt exactly count
23:17:24 <kadoban> greves: I doubt the body of the do block can start farther to the left than mainWith
23:17:46 <kadoban> (I think it has to be to the right of that) … not sure though. I'm bad at technicalities of indentation rules.
23:18:07 <dramforever> greves: yes, indent the do block further
23:18:07 <greves> if i move the whole do block over, i get: hello.hs:13:24: parse error on input ‘=’
23:18:11 <zomg> I think it would work if myFunction = id wasn't there
23:18:26 <dramforever> and on line 13 you should line up myFunction with mainWith
23:18:28 <zomg> but you basically need to line up myFunction and mainWith function, not myFunction and args etc.
23:18:43 <greves> ah.....
23:19:06 <greves> ok so do block goes indented more than the name and the names all have to line up
23:19:09 <zomg> the where part is declaring two functions, mainWith and myFunction, so that's why they need to line up
23:19:10 <greves> is that right?
23:19:39 <dramforever> yep
23:19:54 <dramforever> oh sure, because "where" is a block too
23:19:55 <dramforever> =)
23:19:56 <greves> got it, and it works, and its also exactly the same as the example after that change
23:20:13 <greves> wow, not sure if i like that or not
23:20:22 * dramforever mumbles something about NonDecreasingIndentation
23:20:23 <ReinH> ]
23:20:31 <greves> and i'm fairly well versed in python with significant whitespace, but not *that* significant :P
23:21:07 <ReinH> greves: the significantest
23:21:13 <ReinH> Also this might be useful:
23:21:22 <ReinH> @google haskell layout
23:21:23 <lambdabot> https://en.wikibooks.org/wiki/Haskell/Indentation
23:21:29 <kadoban> greves: It's not particularly pickier than python. What you had would have made no sense at all, especially the myFunction part.
23:21:50 <ReinH> The layout rules are pretty simple once you know them
23:22:14 <greves> kadoban: that's probably true, as i'm still getting used to the syntax and whatnot so seeing the blocks is not as instantaneous as it would be if i were looking at python
23:22:16 <greves> good point
23:22:31 <kadoban> Yeah, that's likely it. Once you see the syntax more clearly it'll make a ton more sense.
23:33:20 <ReinH> So apparently mmap works pretty well with storable vectors. Good news.
23:43:58 <greves> question - will haskell be valuable for work? (i'm learning for fun anyway, but curious)
23:44:21 <greves> like, what am i using daily that i dont know is written in haskell?
23:45:46 <zomg> probably nothing :P
23:46:02 <kadoban> Possibly pandoc, that's fairly well known.
23:46:16 <greves> didn't know that
23:46:20 <EvanR> the way you think about your code will change in any language
23:46:22 <zomg> yeah was just about to mention, that's pretty much the only thing that came to mind.. maybe Xmonad but I think that's being mostly used by Haskell people :P
23:46:26 <greves> (i don't know anything that's written in haskell actually)
23:46:39 <EvanR> for better or worse
23:46:45 <greves> i know a lot of FB is in OCaml
23:46:57 <zomg> We do JS stuff at work but I wrote one component we used for a customer specific thing in Haskell
23:47:03 <zomg> so it's certainly viable =)
23:47:29 <greves> yeah thats my motivation for learning it is to try haste :)
23:47:52 <dramforever> haskell is very suitable for code you use yorself
23:47:54 <dramforever> yourself
23:48:42 <dramforever> all those type safe stuff are not...user friendly
23:48:47 <dramforever> but sure they are programmer friendlt
23:48:52 <dramforever> friendly
23:49:06 <kadoban> dramforever: That doesn't make much sense, and isn't true.
23:49:14 <dramforever> oh?
23:49:22 <dramforever> oh forget about it then
23:49:23 <dramforever> =)
23:50:08 <kadoban> dramforever: A user would never know that a type system exists in the code they're indirectly using, except that it eliminates some classes of bugs. So … unless the user likes bugs, I fail to see what harm a user would see from it.
23:50:08 <EvanR> user interfaces have "type safety" issues, and the result of not recognizing it is a broken or ridiculous UI
23:50:23 <dramforever> well what about this
23:50:42 <dramforever> because user don't see the type system, you can't ensure type safety there
23:50:55 <greves> well i've been writing some language processing programs and pretty complex web applications in python/javascript for a year or so now, and i haven't run into any of the huge issues that i suppose cause people to complain about weak typing / duck typing
23:51:05 <EvanR> type systems transcend what haskells type system can ensure
23:51:24 <dramforever> forget about it forget about it forget about it
23:51:32 <zomg> greves: we've had loads of issues, but mostly caused by shitty code produced by the original devs...
23:51:35 <zomg> :P
23:51:39 <greves> heh
23:51:42 <EvanR> greves: careful, if you use haskell a lot, you will go back and realize these issues
23:51:53 <EvanR> perhaps turn back now
23:51:56 <EvanR> before its too late
23:52:19 <zomg> lol
23:52:27 <greves> haha seems like everyone with a favorite language says the same thing ;P
23:52:57 <greves> i do understand that in theory it should make things more straightforward, and i have a math background so i can appreciate that
23:53:07 <greves> but in practice i haven't been too tripped up by weak typing
23:53:10 <EvanR> haskell is the gateway drugs to more and more sophisticated languages
23:53:12 <slack1256> Busted, but that serves to show that the haskell community is just another language comunity and not a scientist level wizardry of programming languages
23:53:25 <EvanR> its totally different from "everyones favorite language"
23:53:42 <zomg> greves: one of the big issues we had was because even our db has weak typing.. then because of bad programming, numeric values in the db ended up being strings
23:54:01 <EvanR> greves: you must be lucky to never had to work on dynamic code someone else wrote
23:54:01 <zomg> and then when half of the values in the db were strings and half numbers, and the code never paid any attention to which it was getting..
23:54:11 <zomg> all kinds of subtle issues popped up
23:54:47 <greves> EvanR: ah fair point, til now my professional coding work has been almost exclusively on new code, not legacy
23:55:06 <EvanR> im going to guess 95% of the errors you get in production code are literally type errors
23:55:30 <EvanR> undefined variable, undefined method of nil
23:55:39 <EvanR> cant convert float to array
23:55:42 <EvanR> or array to hash
23:56:02 <EvanR> or in php, your result is randomly FALSE instead of NULL
23:56:09 <EvanR> or empty string, or empty array
23:56:10 <zomg> most of issues we've had is related to data not being in the format the code expected :P
23:56:40 <EvanR> zomg: type error ;)
23:56:40 <zomg> thankfully the devs we have now are fairly sane and have a better idea of what they're doing, so they know how to avoid the usual issues
23:57:25 <zomg> yeah hard to avoid those errors because nothing checks it because we use mongodb and there's no migrations set up
23:57:43 <greves> well PHP and mongodb is a disastrous combination from the start ;P
23:57:45 <zomg> fields get added and someone forgets to make the code work with objects that lack those fields.. boom
23:58:06 <zomg> we use node
23:58:12 <zomg> but similar problems yeah
23:58:18 <EvanR> row types
23:58:50 <solirc> sgronblo: I think it may be best to open an issue for ghc-mod on GitHub
23:59:04 <dramforever> have to +1
23:59:22 * hackagebot ihaskell-hatex 0.2.1.0 - IHaskell display instances for hatex  https://hackage.haskell.org/package/ihaskell-hatex-0.2.1.0 (gibiansky)
23:59:56 <greves> so zomg have you written any compile-to-js code in haskell for production?
