00:05:12 <ttt_fff> is there a way to lift a RWST () () s a into a RWST r () s a ? // i.e. if it does not need a reader info, it seems like it should be able to be lifted into an arbitrary reader ?the two state moands have the same type for the state
00:05:31 <ttt_fff> geekosaur: is 'wtf' considered a swear word under the new policy?
00:06:38 <liste> :t magnify
00:06:39 <lambdabot> Magnify m n b a => LensLike' (Control.Lens.Internal.Zoom.Magnified m c) a b -> m c -> n c
00:07:22 <jle`> is there a library with type families dealing with lifted type-level lists?
00:07:24 <ReinH> probably magnify
00:07:36 <ReinH> jle`: o/
00:07:38 * hackagebot drifter 0.2 - Simple schema management for arbitrary databases.  https://hackage.haskell.org/package/drifter-0.2 (MichaelXavier)
00:07:38 * hackagebot streaming 0.1.0.5 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.5 (MichaelThompson)
00:07:58 <jle`> ReinH: \o
00:08:23 <liste> ttt_fff you want magnify
00:08:32 <jle`> like Length :: [k] -> Nat
00:08:46 <ttt_fff> :t magnify
00:08:47 <lambdabot> Magnify m n b a => LensLike' (Control.Lens.Internal.Zoom.Magnified m c) a b -> m c -> n c
00:08:50 <ttt_fff> liste: this is making no sense so far
00:09:21 <jle`> :k RWST
00:09:22 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
00:09:33 <jle`> i think you're missing a monad
00:09:54 <ttt_fff> let's say RWS
00:09:55 <ttt_fff> RWS is fine
00:09:56 <liste> there's an instance (Monad m, Monoid w) => Magnify (RWST b w s m) (RWST a w s m) b a
00:09:56 <ttt_fff> :k RWS
00:09:57 <lambdabot> * -> * -> * -> * -> *
00:10:06 <jle`> but yeah, magnify is prob the way to go.  or zoom if you want to lift arbitrary s
00:10:09 <liste> and RWS == RWST Identify
00:10:10 <ttt_fff> liste: oh, this is starting to make sense now
00:10:31 <ttt_fff> liste: okay, so the idea is that if I can convert an a to an b, then magnify will go RWST b w s m -> RWST a w s m 
00:10:34 <ttt_fff> err, other wya around
00:12:21 <jle`> magnify _2 :: RWS r w s a -> RWS (q,r) w s a
00:13:26 <jle`> so alls you need is a Getter
00:13:42 <jle`> luckily you can make a Getter from an arbitrary function with `to`
00:13:46 <jle`> so...
00:13:51 <liste> :t magnify _Empty
00:13:52 <lambdabot> (Applicative (Control.Lens.Internal.Zoom.Magnified m c), Magnify m n () a, AsEmpty a) => m c -> n c
00:14:26 <hackrilege_> :t magnify _2
00:14:27 <lambdabot> (Functor (Control.Lens.Internal.Zoom.Magnified m c), Magnify m n b t, Field2 t t b b) => m c -> n c
00:14:41 <jle`> magnify (to snd) :: RWS r w s a -> RWS (q, r) w s a
00:14:55 <jle`> magnify (to fst) :: RWS r w s a -> RWS (r, q) w s a
00:15:13 <jle`> magnify (to (f :: r -> q)) :: RWS r w s a -> RWS q w s a
00:15:16 <jle`> ...i think that's how it works
00:15:42 <ttt_fff> this is scary how smart you guys are
00:15:46 <jle`> oh that should be q -> r
00:15:53 <hackrilege_> why are you writing RWS instead of Magnify?
00:16:04 <jle`> magnify (to (f :: q -> r)) :: RWS r w s a -> RWS q w s a
00:16:20 <jle`> hackrilege_: ttt_fff wants to manipulate a RWS, so i'm specializing it for clarity
00:17:39 <hackrilege_> but how is; (Functor (Control.Lens.Internal.Zoom.Magnified m c), Magnify m n b t, Field2 t t b b) => m c -> n c === RWS r w s a -> RWS (q,r) w s a
00:18:04 <liste> hackrilege_ not equal, specialized
00:18:14 <jle`> hackrilege_: RWS is an instance of those typeclasses, and so is (q, r)
00:19:03 <jle`> well, i said that a little weird
00:19:08 <jle`> but i think you get my point
00:19:36 <hackrilege_> aha, RWS is something lensy already, i thought it was a datatype from another place entirely 
00:19:39 <liste> like 5 :: Int versus 5 :: Num a => a
00:19:50 <jle`> ttt_fff: you can use `zoom` to transmogrify the `s` parameter too, but you need a full on Lens (with getting and setting abilities) to be able to do that, of course
00:19:59 <jle`> if you have a getter and a setter you can make a lens using `lens`
00:20:17 <jle`> hackrilege_: nah, RWS is from transformers/mtl
00:20:21 <jle`> but it's an instance of those types
00:20:24 <jle`> typeclasses
00:20:31 <ReinH> hackrilege_: there is an instance for RWST: https://hackage.haskell.org/package/lens-4.10/docs/Control-Lens-Zoom.html
00:21:15 <hackrilege_> thanks
00:23:07 <hackrilege_> zoom l (Lazy.RWST m) = Lazy.RWST $ \r -> unfocusingWith #. l (FocusingWith #. m r)
00:24:06 <hackrilege_> :t unfocusingWith 
00:24:07 <lambdabot> Not in scope: ‘unfocusingWith’
00:34:28 <jle`> any way i can get ghci to show me type family resolutions?
01:11:18 <jle`> anyone know how i can turn a Proxy (k :: Nat) into an Integer or Int
01:11:30 <jle`> KnownNat from GHC.TypeLits seems to only work with literals
01:13:55 <oftl_> hi, i'm quite new to haskell and functional programming and i keep reading that a strong type system renders unittesting unnecessary. i can see how types prevent certain possible errors but that's it - wondering if and what i am missing here. can anybody point me to some information/documentation on that ?
01:17:16 <frerich> oftl_: That's not true. A more expressive type system simply allows writing your programs in a way which allow the compiler to check a larger set of properties (e.g. that a function is never called with an empty list or such). So an expressive type system (should you make use of it!) permits ruling out certain classes of errors.
01:17:55 <frerich> oftl_: There are still many things which can go wrong at runtime though. The good thing is that you can focus on those because the compiler already took care of the low-hanging fruit.
01:18:22 <startling> oftl_, I (and most haskell people I know) don't think it makes unit testing unnecessary
01:19:35 <oftl_> startling: makes sense, thanks.
01:20:03 <startling> it does make debugging and thinking about your code easier.
01:20:05 <mateop> hi there
01:23:35 <plhk> 1
01:26:49 <deejay_> how do we use a two sided currying? Something like : filter (mod 10 x == 0) [1..10], where x takes values from the list.
01:26:52 <deejay_> any udeas?
01:26:57 <deejay_> ideas*
01:27:12 <aleator_> Hi, I've got a stack/ghc problem. Stack decides to install ghc, and this gives "config.mk:496: *** missing separator.  Stop." (full message at https://gist.github.com/aleator/bc7fdb78156762908b60) Anyone seen this? (on os x)
01:27:53 <aleator_> deejay_: Do you mean `filter (\x -> mod 10 x == 0) [1..10]`
01:27:54 <kadoban> deejay_: filter ((==0) . mod 10) [1..10]  ?
01:28:25 <deejay_> Oh... great. thanks +aleator_ and +kadoban!
01:40:22 <ttt_fff> I have "f1 :: a -> b" and "f2 :: b -> a -> a" . Now, how do I create a "Lens' a b" from this?
01:40:36 <ttt_fff> jle`: ^^
01:40:37 <liste> ttt_ff `lens'
01:40:39 <liste> :t lens
01:40:40 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
01:40:59 <ttt_fff> lsite: by `lens' do you mean "lens", or does `' mean something special ?
01:41:16 <liste> nothing special
01:41:33 <liste> I just use them to distinguish from literal quotes
01:42:36 <jle`> ttt_fff: you can use lens, but the arguments on f2 are switched from what the function expects
01:42:43 <jle`> lens would expect f2 :: a -> b -> a
01:42:59 <jle`> btw the convention is Lens' s a, so f2 :: s -> a -> s
01:43:13 <ttt_fff> jle`: NO WONDER WHY IT DID NOT WORK
01:43:15 <ttt_fff> works now :-)
01:43:24 <jle`> f1 :: s -> a
01:43:25 <jle`> hooray :D
01:43:54 <ttt_fff> jle`: you're like lambdabot++
01:44:14 <jle`> haha this is like the boundary of my lens knowledge
01:55:09 <benneh> out of "mapM_ putStrLn" and "putStrLn . unlines", is there any reason to prefer one over the other?
01:58:01 <liste> benneh String or Lazy/String ByteString/Text ?
01:58:09 <liste> Lazy/Strict*
01:58:20 <benneh> liste: just a plain String
01:59:37 <liste> they do different things
01:59:48 <liste> the unlines version adds an extra newline
02:00:19 <benneh> liste: sorry, change that to "putStr . unlines" then
02:00:27 <dxld> anybody else want GHC 7.10 on travis-ci? +1 this pull request: https://github.com/travis-ci/travis-cookbooks/pull/502
02:00:56 <rolo> hi, i'm quite new to haskell and i was wondering how deep concepts like category theory i'll need to grasp to understand all the subtle parts of the language
02:01:19 <dramforever> "subtle parts"?
02:01:38 <rolo> "stuff i don't get with a CS degree" :D
02:01:46 <liste> benneh then I guess there's not much difference, though the mapM_ version is easier to convert for non-lazy IO
02:01:53 <dramforever> pretty sure you don't get haskell with a cs degree
02:01:58 <dramforever> it's possible
02:02:02 <Intolerable> e
02:02:04 <Intolerable> oops
02:02:20 <Intolerable> that isnt the right window
02:03:02 <frerich> rolo: You don't need any 'deep concepts'. Sometimes they may be useful, but what's much more important is that - depending on your background - you're willing to basically re-learn programming since Haskell is possibly *very* different from what you used in the past.
02:03:16 <liste> rolo you'll pick up some CT concepts on the side (: no need to be already proficient with it
02:03:21 <tzaeru> dramforever, our main CS degree courses included one or two FP courses in Haskell.
02:03:29 <dramforever> tzaeru: well I screwed up
02:03:39 <dramforever> I only meant it's possible
02:06:40 <benneh> liste: good point; I guess that's as good a reason as any to prefer one over the other; thanks for the help
02:06:55 <rolo> frerich: sure, i've not a static thought on programming, i used to work with LISP and Prolog, i was just curious about the math behind some mindset that will help me to deal with haskell well
02:17:10 <rtb> I have a package conflict between lens and snaplet-mysql-simple; my idea to solve this is atm: unpack snaplet in my cabal sandbox, in the unpacked package: modify the lens requirement for the snaplet, and then install in my sandbox this unpacked package of snaplet? So, is this possible, recommended, sensible?
02:20:44 <bergmark> rtb: a pull request would probably be appreciated, but that's sensible, sure, you may want to use `add-source' as well
02:23:01 <rtb> bergmark: thanks for the commenting!
02:38:20 <dramforever> hmm...TIL ExitCode is an instance of Exception
02:40:05 <dramforever> and it's possible to catch an exiting IO action
02:48:15 <deejay_> :src foldr
02:48:56 <dramforever> @src foldr
02:48:56 <lambdabot> foldr f z []     = z
02:48:56 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:49:14 <dramforever> deejay_: what about checking the actual source code?
02:49:46 <deejay_> umm... yeah... new to irc... so trying to get my hands on it.
02:50:07 <deejay_> thanks, +dramforever
02:50:14 <dramforever> =)
02:53:32 <liste> +
02:54:04 <liste> sorry, wrong channel
03:04:40 <joncol> I get trouble when trying to read and write text files containing the swedish characters ÅÄÖ. I tried using Data.ByteString.UTF8 (fromString and toString). But the string special characters are not preserved when calling (toString . fromString) on a string with them.
03:06:08 <liste> joncol are the text files UTF8?
03:06:25 <joncol> liste: Yes. At least Vim tells me so.
03:06:34 <joncol> liste: Do they need the BOM?
03:06:45 <dramforever> pretty sure no
03:07:18 <liste> joncol no, UTF-8 should never have BOM
03:08:14 <Taneb> joncol, I'd use Data.Text rather than ByteString
03:08:42 <joncol> Taneb: OK, I'll try that one
03:08:54 <liste> they're for different uses
03:09:39 <liste> you need ByteString if you must work with raw bytes
03:10:00 <joncol> I don't need that in this case
03:10:00 <liste> (toString . fromString) "ö" is "\246" for me
03:10:23 <Intolerable> > "ö" == "\246"
03:10:25 <lambdabot>  True
03:10:32 <joncol> Shouldn't it be "ö"?
03:10:35 <Intolerable> they're the same, its just the show instance that's a bit janky
03:10:46 <joncol> I'm writing output to a text file and I want it to show up as "ö"
03:10:59 <Intolerable> ghci > print "ö"
03:11:00 <Intolerable> "\246"
03:11:00 <Intolerable> ghci > putStrLn "ö"
03:11:00 <Intolerable> ö
03:11:14 <liste> joncol then don't `show' it
03:11:54 <Intolerable> > "ö" :: ByteString
03:11:55 <lambdabot>      Not in scope: type constructor or class ‘ByteString’
03:11:56 <lambdabot>      Perhaps you meant one of these:
03:11:56 <lambdabot>        ‘BSC.ByteString’ (imported from Data.ByteString.Char8),
03:12:02 <Intolerable> > "ö" :: BSC.ByteString
03:12:03 <lambdabot>      Couldn't match expected type ‘BSC.ByteString’
03:12:03 <lambdabot>                  with actual type ‘[Char]’
03:12:03 <lambdabot>      In the expression: "\246" :: BSC.ByteString
03:12:11 <Intolerable> > fromString "ö" :: BSC.ByteString
03:12:12 <lambdabot>  "\246"
03:12:14 <joncol> But how should I then output it? I have a record type containing String fields.
03:12:22 <Intolerable> > fromString "ö" :: Text
03:12:23 <lambdabot>  Not in scope: type constructor or class ‘Text’
03:12:28 <Intolerable> > fromString "ö" :: Data.Text.Text
03:12:30 <lambdabot>      Not in scope: type constructor or class ‘Data.Text.Text’
03:12:36 <liste> joncol what file format do you need?
03:12:39 <liste> for your output
03:12:42 * hackagebot xmonad-wallpaper 0.0.1.1 - xmonad wallpaper extension  https://hackage.haskell.org/package/xmonad-wallpaper-0.0.1.1 (yeyan)
03:12:43 <Intolerable> > fromString "ö" T.Text
03:12:44 <lambdabot>      Not in scope: data constructor ‘T.Text’
03:12:44 <lambdabot>      Perhaps you meant variable ‘R.next’ (imported from System.Random)
03:12:45 * hackagebot log 0.2.3 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.2.3 (arybczak)
03:12:49 <Intolerable> (i give up)
03:12:51 <joncol> It will be a LaTeX file.
03:13:06 <Taneb> "ö" is not a single byte in UTF8 which is maybe where the problems are coming from
03:13:19 <Taneb> :t Data.Text.pack
03:13:20 <lambdabot> String -> Data.Text.Internal.Text
03:13:28 <Taneb> > Data.Text.pack "ö"
03:13:29 <lambdabot>  Not in scope: ‘Data.Text.pack’
03:13:36 <Taneb> Um
03:13:42 <Intolerable> yeah idk either
03:13:58 <Intolerable> @let import qualified Data.Text as Text
03:13:59 <lambdabot>  .L.hs:112:1:
03:13:59 <lambdabot>      Data.Text: Can't be safely imported!
03:13:59 <lambdabot>      The package (text-1.2.1.3) the module resides in isn't trusted.
03:14:03 <Intolerable> rip
03:14:13 <liste> joncol how about concatenating strings and writeFile at the end (it's horribly inefficient though)
03:14:25 <liste> or hPutStrLn
03:14:37 <Intolerable> is there a reason for not using Text?
03:15:05 <liste> Text is the way to go for real programs
03:15:16 <joncol> OK, I'll try Text
03:15:46 <Intolerable> really unless you have a specific reason for not using it, Text is the way to go for anything that resembles actual human-readable text
03:22:39 <joncol> OK, so how would I write my record type to a file using Data.Text? Should I avoid calling show?
03:23:29 <Intolerable> yeah, calling show is usually a bad idea if you're writing to a file
03:23:54 <Intolerable> my suggestion would be to build up a big Text value by concatenating them
03:24:04 <Intolerable> and then use writeFile from Data.Text.IO to write them out
03:25:25 <joncol> So I should define some toText :: Person -> Text function?
03:25:35 <joncol> Instead of deriving a Show instance?
03:25:45 <Intolerable> yes
03:25:52 <Intolerable> the text-format package might be handy
03:25:57 <Intolerable> @hackage text-format
03:25:57 <lambdabot> http://hackage.haskell.org/package/text-format
03:26:23 <joncol> OK, thanks
03:52:42 <joncol> :q
03:53:22 * liste spotted a vi(m) user
03:53:35 <hc> ^X^C
03:56:08 <jgt> how did you know
04:00:50 <Taneb> liste, it's actually a weird emoticon
04:00:58 <Taneb> "I am licking my nose :q"
04:02:45 * hackagebot dataflow 0.7.1.0 - Generate Graphviz documents from a Haskell representation.  https://hackage.haskell.org/package/dataflow-0.7.1.0 (owickstrom)
04:03:13 <ttt_fff_> does lens have something like this? (overM), i.e. over, but with a MOnad, i.e. https://gist.github.com/anonymous/ca6b469f5c464068a18f
04:03:14 <joncol> Is there some way of escaping braces }
04:03:25 <joncol> Is there some way of escaping braces {} in the strings used by text-format?
04:04:06 <joncol> I want to output LaTeX stuff, which contains a lot of empty braces, which shouldn't be touched by format...
04:04:58 <liste> @where formatting -- joncol then something like this would be a better fit
04:04:58 <lambdabot> I know nothing about formatting.
04:05:04 <liste> @hackage formatting
04:05:04 <lambdabot> http://hackage.haskell.org/package/formatting
04:05:26 <ttt_fff_> joncol: ouch, good point, never realized latex / format do not like each other
04:06:23 <bz> Peaker: so when isolate fails, what would the expected behavior be?
04:06:23 <frerich> joncol: Do you really need to escape all braces though? I didn't try it, but judging by http://hackage.haskell.org/package/text-format-0.3.1.1/docs/src/Data-Text-Format.html#crack I'd suspect whether maybe it's specifically "{}" being special.
04:06:28 <joncol> ttt_fff_: Yes, that's not exactly a match made in heaven.
04:07:05 <joncol> liste: OK, I'll check that out
04:07:13 <frerich> joncol: Oh, you wrote 'a lot of *empty* braces'...
04:07:17 <ttt_fff_> joncol: I hope you suffer enough from this that you'll replace TeX's macro system with something ahskell based :-)
04:07:30 <ttt_fff_> I find TeXmacro expansion rules confusion
04:08:20 <ttt_fff_> joncol: one hackish result is to, in tex, define a commmand \mybrace which expands ot {}, then for your TeX 'tempalte', replace all {} with \mybrace
04:08:33 <ttt_fff_> joncol: that might get around format stealing your {}'s and trying to expand them
04:09:12 <liste> joncol http://hackage.haskell.org/package/formatting-6.2.2/docs/src/Formatting-Examples.html this gives a nice overview
04:09:26 <ironChicken> i'm stuck trying to write a function of this type: Monad m => [m [m a]] -> m [a]
04:09:30 <kuribas> joncol: https://en.wikibooks.org/wiki/LaTeX/Special_Characters
04:10:00 <ironChicken> i actually need it to do this: [IO [IO (String, String)]] -> IO [(String, String)]
04:10:04 <merijn> ironChicken: looks like a combination of sequence and "map sequence"?
04:10:11 <ttt_fff_> is ther ea special name for "liftA2 (++)" ?
04:10:20 <rlewis> how did you end up with [IO [IO (String, String)]]?
04:10:23 <merijn> :t fmap (map sequence) . sequence
04:10:25 <lambdabot> (Monad f, Monad m, Traversable t) => [f (t (m a))] -> f [m (t a)]
04:10:46 <merijn> :t fmap conat . join . fmap (map sequence) . sequence
04:10:47 <lambdabot>     Not in scope: ‘conat’
04:10:48 <lambdabot>     Perhaps you meant one of these:
04:10:48 <lambdabot>       ‘concat’ (imported from Data.List),
04:10:52 <merijn> :t fmap concat . join . fmap (map sequence) . sequence
04:10:53 <lambdabot> (Monad t, Foldable t) => [[[t a]]] -> [[a]]
04:11:00 <merijn> hmm, not quite
04:11:01 <Peaker> bz: wow, that's a postponed question :)
04:11:15 <Peaker> bz: I'd guess the same as usual Get failures?
04:11:22 <bennofs> :t traverse (>>= sequence)
04:11:23 <lambdabot> (Monad f, Traversable t, Traversable t1) => t (f (t1 (f a))) -> f (t (t1 a))
04:11:29 <dramforever> :t map (sequence . concat) . sequence
04:11:30 <lambdabot> (Monad m, Traversable t) => t [[m a]] -> [m [a]]
04:11:35 <ironChicken> rlewis: yeah, i have been looking at whether i could change the earlier function
04:11:36 <merijn> ironChicken: It's possible to do that, it requires some mixing of sequence, join and concat and I can't be arsed to figure out which, so time to start puzzzling :p
04:11:38 <dramforever> not quire
04:11:41 <dramforever> *quite
04:11:51 <ironChicken> merijn: thanks :-)
04:11:59 <bennofs> :t fmap concat . traverse (>>= sequence) :: [IO [IO (String, String)]] -> IO [(String, String)]
04:12:00 <lambdabot> [IO [IO (String, String)]] -> IO [(String, String)]
04:12:01 <bennofs> :)
04:12:09 <bennofs> ironChicken: ^^^
04:12:13 <merijn> ironChicken: "sequence :: Monad m => [m a] -> m [a]" and "join :: Monad m => m (m a) -> m a"
04:12:24 <ironChicken> bennofs: looks promising
04:13:23 <kuribas> @djinn Monad m => [m [m a]] -> m [a]
04:13:23 <lambdabot> Error: Undefined type []
04:13:29 <bz> Peaker: sorry about the delay. i meant with respect to unconsumed input, though.
04:13:43 <Peaker> bz: in Get error state -- is there input left?
04:14:08 <bz> Peaker: sure. data Result a = Fail error_message remaining_input | ...
04:14:38 <Peaker> bz: ah, then I donno :)
04:15:01 <rlewis> [IO [IO (String, String)]] doesn't sound like something you are likely to have without doing something weird to get it
04:15:45 <bz> Peaker: with every other combinator, erroring out will leave some unconsumed input, right? but with isolate, the unconsumed input is clamped to the isolated length
04:15:50 <Peaker> :t join . fmap sequence . fmap concat . sequence
04:15:51 <lambdabot> (Monad m, Traversable t) => t (m [m a]) -> m [a]
04:16:05 <ironChicken> bennofs: GHC seems happy with that
04:16:07 <merijn> Ah, peakr is better at this than me :p
04:16:26 <bennofs> :t join . fmap (sequence . concat) . sequence
04:16:27 <lambdabot> (Monad m, Traversable t) => t (m [m a]) -> m [a]
04:18:08 <ironChicken> rlewis: i'm iterating over a list of shared libraries; calling some foreign code which extracts some information from those libraries and consing the results together into this weird structure
04:19:09 <kuribas> :t (>>= sequence . concat ) . sequence
04:19:10 <lambdabot> (Monad m, Traversable t) => t (m [m a]) -> m [a]
04:19:20 <ironChicken> maybe somewhere i could lose some of the IO
04:20:46 <merijn> ironChicken: I agree that this is an unusual type to end up with, but it's also not completely unheard of, imo
04:21:08 <merijn> ironChicken: Maybe the problem is a "map" instead of "mapM" somewhere?
04:21:17 <rlewis> or let instead of <-
04:21:23 <merijn> "mapM f = sequence . map f"
04:22:20 <ironChicken> merijn: thanks for the tips; i'll have a look
04:23:10 <phaazon> hm
04:23:22 <phaazon> why is archlinux’s ghc lagging behind?
04:23:44 <dramforever> it's happening everywhere
04:23:51 <phaazon> ah?
04:23:57 <phaazon> I thought Debian’s was shipped already
04:24:03 <dramforever> same here in fedora
04:24:12 <dramforever> now I don't use the ghc in the repo anymore
04:24:27 <dramforever> no 7.10 no fun
04:25:38 <merijn> phaazon: All linux distro's lag on GHC releases, in my experience
04:25:49 <merijn> phaazon: I just install binaries (but then I can't use a package manager anyway)
04:28:29 <augur> anyone have a good thing to read for understanding parsec? particularly, when it's necessary to use try?
04:28:55 <nshepperd> huh? I got ghc 7.10 on archlinux within weeks of the release
04:29:02 <dramforever> when the first alternative may consume input before failing
04:29:03 <nshepperd> or is there a yet newer ghc?
04:29:14 <dramforever> well, when one alternative
04:29:23 <pacak> augur: When you use  something that might consume stuff, but not all of it.
04:29:30 <nshepperd> oh, 7.10.2
04:29:34 <dramforever> and fails
04:29:34 <merijn> 7.10.2 is newest, unless you count HEAD
04:29:42 <merijn> augur: Real World Haskell chapter?
04:29:44 <pacak> augur: attoparsec is better in that respect.
04:30:01 <merijn> augur: Read this for how to use try: http://blog.ezyang.com/2014/05/parsec-try-a-or-b-considered-harmful/
04:31:07 <muake> when you have a rule of the form A := BC | BD
04:31:50 <augur> merijn: ahh, good ol' ezyang :)
04:33:30 <augur> merijn: ironically, i find myself having the opposite problem -- those errors happen but 'try' solves them
04:36:29 <augur> merijn: this probably will help tho. thank you :)
04:37:47 * hackagebot Bookshelf 0.5 - A simple document organizer with some wiki functionality  https://hackage.haskell.org/package/Bookshelf-0.5 (EmilAxelsson)
04:38:16 <merijn> augur: Well, see also the RWH chapter on Parsec (although the code has bitrotted a bit)
04:42:47 * hackagebot log 0.2.4 - Structured logging solution with multiple backends  https://hackage.haskell.org/package/log-0.2.4 (arybczak)
04:46:14 <fr33domlover> http://paste.rel4tion.org/47 <-- strange build error in fast-logger :-/
04:46:28 <fr33domlover> I tried cabal update, didn't help :P
04:47:24 <bennofs> with optparse-applicative, is it possible to have something that behaves like a combination of switch/option? So that there could be three states: --foo not given, --foo without argument, --foo <some arg>
04:49:17 <pacak> fr33domlover: Looks like a SafeHaskell problem.
04:51:51 <pacak> fr33domlover: Yep. Get rid of "{-# LANGUAGE Safe #-}" in fast-logger.
04:52:17 <muake> I wonder why it doesn't trust System.Directory
04:53:23 <merijn> muake: Trust is a property of the person compiling, not the package
04:55:49 <muake> then how does Safe inference work?
04:57:27 <merijn> muake: A package is inferred safe if it 1) is itself safe and only depends on safe inferred packages or 2) any Trustworthy modules depended on are from package trusted by the compiling person
04:59:05 <merijn> muake: If the author of package Foo could claim package Bar is trustworthy Safe wouldn't get you anything. Foo is only safe if modules in Bar are safe OR (trustworthy AND trusted) by the user
04:59:48 <viszu> http://lpaste.net/139006 I'm getting this error when I try to install wx on windows 10, any clues ?
05:00:06 <muake> ok, so why is System.Directory not safe?
05:00:13 <pacak> viszu: Yes. windows!
05:00:19 <merijn> muake: No idea :)
05:00:44 <pacak> muake: Could be strange ghc version.
05:00:59 <muake> pacak: ...
05:01:24 <pacak> muake: Something ancient that predates safehaskell?
05:01:39 <muake> pacak: that doesn't even make sense
05:02:18 <muake> merijn: what do you think the "it" in my original question was referring to?
05:03:28 <jhrcek> @hoogle (.~)
05:03:28 <lambdabot> No results found
05:03:46 <pacak> jhrcek: lens
05:04:03 <muake> jhrcek: http://hayoo.fh-wedel.de/?query=.~
05:04:09 <pacak> :t (.~)
05:04:10 <jhrcek> pacak: thanks, just testing lambdabot search :)
05:04:10 <lambdabot> ASetter s t a b -> b -> s -> t
05:04:50 <dramforever> @hoogle (.~) +lens
05:04:50 <lambdabot> Could not find some databases: lens
05:04:50 <lambdabot> Searching in:
05:04:50 <lambdabot>   .
05:04:56 <dramforever> hmm...
05:05:43 <liste> is there a decent command-line Hayoo client?
05:28:16 <amontimur> is there a way around having to launch emacs inside a nix-shell so that ghc-mod picks up the presence of the dependencies?
05:30:42 <srhb> amontimur: -p emacs presumably
05:31:02 <srhb> amontimur: (Basically specify whichever nixpkg that includes your Haskell dev environment.)
05:31:07 <srhb> nixpkgs*
05:34:59 <amontimur> srhb: what i mean is that i can launch emacs inside a normal shell and have it recognize the dependencies
05:35:42 <srhb> amontimur: Oh sorry, I totally missed a word in your last message. Well, how about letting emacs spawn ghc-mod in the relevant nix-shell
05:36:25 <amontimur> srhb: care to elaborate? im no emacs wiz.
05:37:26 <srhb> amontimur: I don't know the specifics. Presumably some function in ghc-mod (the emacs package) is responsible for launching the ghc-mod program. Modify (or advise) that function so that it makes sure to use nix-shell with the relevant shell.nix file of the project.
05:37:51 <srhb> amontimur: More knowledgable people might be around in #nixos :)
05:37:55 <srhb> Or even #haskell-emacs
05:38:38 <amontimur> srhb: thanks. on it...
05:43:52 <fr33domlover> pacak, thanks
05:44:02 <fr33domlover> But why does it even have that in the code then?
05:44:20 <fr33domlover> I imagine fast-logger should successfully auto-compile for NixOS etc. without tweaks?
05:45:04 <pacak> fr33domlover: It might or it might not.
05:46:48 <arianvp> why is this a parse error?
05:47:10 <arianvp> > do { a <- return "hey"; let b = a++"!"; return a}
05:47:12 <lambdabot>  <hint>:1:49: parse error on input ‘}’
05:47:29 <arianvp> aren't let bindings supported in do blocks?
05:47:37 <muake> arianvp: because it parses as do { a <- return "hey"; let { b = a ++ "!"; return a } }
05:47:50 <arianvp> hm
05:47:52 <arianvp> how do I avoid that?
05:48:04 <muake> > do { a <- return "hey"; let { b = a++"!" }; return a}
05:48:05 <lambdabot>      No instance for (Show (m0 [Char]))
05:48:05 <lambdabot>        arising from a use of ‘show_M818174584199426097429576’
05:48:05 <lambdabot>      The type variable ‘m0’ is ambiguous
05:48:07 <dramforever> spliting that onto multiple lines?
05:48:16 <dramforever> never mind
05:48:21 <muake> > do { a <- return "hey"; let { b = a++"!" }; return a} :: Maybe String
05:48:23 <lambdabot>  Just "hey"
05:48:44 <srhb> arianvp: The outer braces disable layout, so you'll need to keep them explicit after that.
05:48:44 <muake> > do a <- return "hey"; let { b = a++"!" }; return a :: Maybe String
05:48:46 <lambdabot>  Just "hey"
05:48:51 <muake> srhb: what
05:48:55 <srhb> No?
05:49:01 <muake> no
05:49:09 <muake> oh, you could also use let .. in
05:49:19 <muake> > do a <- return "hey"; let b = a++"!" in return a :: Maybe String
05:49:21 <lambdabot>  Just "hey"
05:49:48 <muake> 'let { b = a++"!" in ... }' would be a syntax error, so it automatically closes the } before 'in'
05:49:49 <merijn> srhb: That's not true
05:50:05 <merijn> srhb: Layout specifies when to insert braces, nested layout scopes within braces is fine
05:50:11 <muake> srhb: every layout keyword triggers its own layout (or not)
05:50:55 <srhb> muake, merijn: Then why are the braces required here when usually they are not?
05:51:30 <muake> because usually you don't put your code all on one line
05:51:36 <muake> so indentation can be used to disambiguate
05:51:45 <srhb> I can put it on multiple lines (with the outer braces) and the problem still exists
05:52:33 <srhb> In fact do { ... normal content with line breaks ... } does not work unless the let block is also enclosed in braces, but if I drop the other braces it does work.
05:53:25 <muake> ok, that's interesting
05:53:37 <srhb> Well, I suppose you can't actually FIX it if you use line breaks, even with braces
05:53:39 <srhb> I'd have to test
05:54:21 <muake> I must be doing something completely wrong because now I can't even get it to work with full braces
05:54:34 <srhb> Fun!
05:54:56 <srhb> Yeah, dropping semicolons renders it infixable as far as I can see
05:55:51 <srhb> (Which is fair enough, but still. I don't quite understand how it would be possible to do it without braces on the inner let ever, once the do block is braceified
05:55:54 <muake> ooh, I get it
05:56:11 <muake> srhb: http://ideone.com/mZHYMw
05:56:43 <srhb> Mind blown. :)
05:57:10 <muake> except now I don't get it anymore
05:57:26 <muake> I'd have to look at the details of layout and let syntax
05:57:41 <srhb> let foo = ... in do { ... ?
05:58:47 <muake> we want to achieve do { let { b = a++"!"}; return a }
05:59:25 <muake> omitting the { before 'b' should cause an implicit '}' to be inserted before the first line indented less than 'b'
06:00:38 <muake> oh!
06:00:55 <muake> there's no implicit ; being inserted because the outer block uses explicit braces :-D
06:01:09 <muake> it ends up being 'let { b = a++"!" } return a'
06:01:15 <muake> hence parse error at 'return'
06:01:18 <srhb> I suppose that's my "disables layout" misconception
06:01:39 <muake> and adding a ';' at the end of the 'let' line doesn't help because it becomes part of the 'let'
06:01:43 <srhb> Yeah.
06:01:46 <srhb> I get it. :)
06:02:01 <dramforever> :t do { a <- return "hey"; let b = a++"!";; return a}
06:02:02 <lambdabot> parse error on input ‘}’
06:02:05 <muake> srhb++  # rubber duck
06:02:12 <srhb> ;)
06:02:20 <dramforever> fail...another semicolon still doesn't do it
06:02:39 <bennofs> dramforever: that looks like hascaml :P
06:02:40 <muake> > let {;;} in ()
06:02:42 <lambdabot>  ()
06:02:44 <dramforever> =)
06:02:47 <muake> why not zoidblock
06:02:53 <bennofs> dramforever: http://ideone.com/QTWpix
06:03:11 <srhb> bennofs: Well, that's just superfluous :P
06:05:07 <bennofs> http://ideone.com/ZibtpO is the best style anyway, and it doesn't have that problem heh
06:05:55 <dramforever> I guess that extra semicolon on line 5 isn't intended
06:06:01 <bennofs> yeah, ignore it
06:06:20 <dramforever> good then
06:06:54 <muake> bennofs: http://ideone.com/8d6xdA
06:07:50 <bennofs> haha
06:08:04 <muake> (ninja edit)
06:22:52 * hackagebot Hangman 0.1.0.1 - The classic game of Hangman.  https://hackage.haskell.org/package/Hangman-0.1.0.1 (lf94)
06:47:54 * hackagebot som 8.2.1 - Self-Organising Maps.  https://hackage.haskell.org/package/som-8.2.1 (AmyDeBuitleir)
06:50:34 <solrize> anyone in norcal just feel a jolt?
06:52:26 <xplat> :t do { a <- return "hey"; let { b = a++"!" }; return a}
06:52:28 <lambdabot> Monad m => m [Char]
06:53:10 <xplat> solrize: you mean 'did the earth move for you too?'
06:53:20 <solrize> yeah :)
06:53:29 <ackthet> solrize: you're about to slide into the pacific ocean. godspeed.
06:53:33 <solrize> ic
06:53:39 <solrize> thx
06:54:16 <xplat> ackthet: c'mon, it's just an everyday kind of quake.  like talking about the weather.
06:55:49 <geekosaur> http://earthquake.usgs.gov/earthquakes/eventpage/nc72507396#general_summary
06:55:53 <ackthet> just joking cause there has been a lot of hype about the Calaveras Fault in the media
06:56:07 <tdammers> accidentally building a city on top of a fault line: unlucky. rebuilding the city time after time after time, even after learning about the fault line and how earthquakes work: stubborn and a bit stupid.
06:56:49 <frerich> murrica!
06:57:04 <xplat> tdammers: probably wouldn't have that problem if it literally destroyed the entire city, but there's always enough left to salvage
06:57:14 <tdammers> still
06:59:10 <xplat> tdammers: just the common short time horizon thing.  cheaper to rebuild on site even knowing there will be another quake in the future than rebuild offsite, given a vaguely humanlike discount rate
06:59:26 <xplat> hyperbolic discounting only accentuates the effect
06:59:47 <merijn> tdammers: Californians actually asked me if I wasn't scared of my house flooding... >.>
06:59:48 <joncol> How can I get the right encoding of string literals containing Swedish characters ÅÄÖ? When loading from disk using Data.Text.IO.readFile, everything works fine, but when I have hard-coded strings in my code containing special characters, they aren't handled correctly...
07:00:11 <merijn> tdammers: I don't think Amsterdam has flooded in human history, at the same time SF has collapsed god knows how many types ;)
07:00:23 <merijn> joncol: Sounds like you're fucking up encoding :)
07:00:37 <merijn> joncol: Read as ByteString and use Text.Encoding to decode from ByteString to Text
07:00:50 <joncol> merijn: I might well be doing just that. I don't know why or how though :)
07:01:23 <merijn> @google The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)
07:01:25 <lambdabot> http://www.joelonsoftware.com/articles/Unicode.html
07:01:25 <lambdabot> Title: The Absolute Minimum Every Software Developer Absolutely, Positively Must Kno...
07:01:27 <merijn> Read that
07:02:18 <joncol> merijn: Something like: encodeUtf8 (read "myÅÄÖstring" :: ByteString)?
07:02:21 <xplat> tdammers: there's also the whole problem of 'the city is actually a patchwork of lots owned by different people'
07:03:00 <merijn> joncol: What is read doing there?
07:03:55 <joncol> merijn: I need to convert the literal string to a Bytestring, right? Or is that done automatically with OverloadedStrings?
07:04:22 <solrize> geekosaur, thanks for that usgs link
07:04:22 <xplat> tdammers: and they generally act independently.  and when insurers pressure them en masse, it takes away as much of their financial ability to relocate as it adds incentive, mostly
07:04:36 <merijn> joncol: This sounds very confused. I recommend reading the earlier link first so you know which questions to ask
07:06:51 <frerich> merijn: When I moved to California, I was advised to always(!) have some shoes under the bed. Reason being that when there's an earthquake in the middle of the night which shatters the windows, you don't want to run over broken glass on your bare feet.
07:07:03 <frerich> merijn: As a yuropean that kinda struck me as 'uh... okaaay....'
07:07:50 <xplat> frerich: it's a rare event, but the cost is high
07:09:24 <xplat> broken glass can seriously mess up your feet, and it'll be hard to get timely medical attention at a time it would happen
07:10:14 <frerich> Except, I assume, if you're with Kaiser Permanente - at least if I can trust their omnipresent ads.
07:10:42 <xplat> trust ads.  that's a good one
07:10:47 <tdammers> I've stepped in broken glass a few times
07:10:54 <tdammers> nothing bad happened
07:11:27 <quchen2> An earthquake appears!
07:11:33 <quchen2> Broken glass starts to evolve!
07:12:16 <benzrf> http://40.media.tumblr.com/0188bf14fd605eaa886b349d93276d1d/tumblr_nt3xp3bFwf1rop8n1o5_500.png
07:12:19 <benzrf> er, wrong channel
07:12:25 <xplat> tdammers: plate glass?
07:12:46 <tdammers> xplat: one was a former vodka bottle, the others I have no idea
07:13:44 <tdammers> interestingly, the vodka bottle one was frighteningly large, and I would have expected a lot more damage in hindsight, but all I got was one tiny splinter
07:13:48 <joncol> merijn: I don't have time to read all that :/? Does Haskell handle string literals in the code as UTF-8 encoded?
07:13:58 <tdammers> it bled a little, for maybe a two minutes or so, but that was about it
07:14:24 <muake> joncol: no, string literals aren't encoded
07:14:27 <muake> they're text
07:14:31 <tdammers> still, in an earthquake situation, watching out for glass shards wouldn't be the first thing I'd want to concern myself with
07:14:55 <kuribas> What is a good xml reading library?
07:15:10 <geekosaur> how ghc reads your source code depends on your locale. in a UTF8 locale it will read UTF8; otherwise it's usually iso8859-1
07:15:34 <joncol> muake> OK, but why does Data.Text.IO.writeFile destroy my special chars (Swedish characters written directly in the code surrounded by double quotes)?
07:15:38 <tdammers> joncol: to clarify: the source file itself is assumed to be UTF-8 (don't know if other encodings are supported); once parsed/compiled, string literals are encoding-agnostic unicode strings
07:15:55 <muake> joncol: how do you know it's writeFile?
07:16:00 <tdammers> the String data type represents them as singly-linked lists of 32-bit Chars
07:16:00 <muake> also, what do you mean by "destroy"?
07:16:10 <muake> *21-bit
07:16:20 <bennofs> joncol: 1) you should not need to use ByteString anywhere in your code 2) can you show the code?
07:16:52 <bennofs> (if you only want to read a human-encoded text file and not some binary encoded things)
07:16:58 <tdammers> muake: I stand corrected
07:17:06 <muake> > ord maxBound
07:17:07 <lambdabot>  1114111
07:17:29 <quchen2> tdammers: The Report only demands Char to be an enumeration of Unicode characters, the internal representation is left open
07:18:27 <tdammers> quchen2: yes, but the important part is that it's encoding-agnostic - when you handle a String (or Char) value, it has no intrinsic encoding attached to it
07:21:04 <kaidelong> so Oleg says that generators arise out of [Either e a] (but not ExceptT [] e a)
07:21:10 <jameseb> so the question is: how does outputting to a file handle character encoding?
07:21:16 <kaidelong> but he cannot implement yield except in terms of CC?
07:21:29 <joncol> bennofs: OK here is a gist: https://gist.github.com/joncol/3f8610d72039da005fc7
07:21:51 <merijn> joncol: Haskell strings are true unicode, so your question is malformed
07:22:05 <kaidelong> what even is "delimited control"?
07:22:09 <bennofs> joncol: ok, and running that writes garbage?
07:22:17 <kaidelong> I thought all you needed for a generator was a continuation
07:22:18 <merijn> bennofs: You should most definitely use BS if at any point you want to sensibly control the encoding of your output
07:22:38 <bennofs> merijn: yeah, but if you're only using UTF-8, then you might as well just stick to the Text IO functions
07:22:50 <joncol> bennofs: Only the special chars are garbage
07:23:02 <merijn> joncol: Windows or linux?
07:23:02 <bennofs> joncol: hmm, is your source file UTF-8 encoded?
07:23:10 <joncol> Windows
07:23:13 <merijn> bennofs: Text doesn't use UTF-8, it uses whatever your environment specifies
07:23:16 <quchen2> Is your shell UTF-8?
07:23:22 <quchen2> Maybe it's just a display problem.
07:23:35 <merijn> Oh, true
07:23:41 <joncol> quchen2: I open the resulting file in Vim and it's garbage
07:23:52 <quchen2> Vim is in the same shell, I assume?
07:23:59 <joncol> No, graphical
07:24:04 <muake> joncol: "garbage" is meaningless. what's actually in the file?
07:24:06 <merijn> joncol: Run ":set fenc?"
07:25:01 <joncol> merijn: latin1
07:25:08 <merijn> Well there you go
07:25:21 <merijn> I'm betting Text is outputting UTF-8 but vim is using the wrong filetype
07:25:29 <muake> please specify the nature of the garbage
07:26:31 <joncol> "hello, world" and then unprintable characters.
07:26:43 <quchen2> Paste it somewhere please.
07:26:45 <muake> which unprintable characters?
07:26:47 <joncol> 2E 20 8F 8E 99 20 86 84 94
07:26:52 <muake> here we go
07:27:39 <muake> none of that says "hello" or "world"
07:28:00 <joncol> Full string: 68 65 6C 6C 6F 2C 20 77 6F 72 6C 64 2E 20 8F 8E 99 20 86 84 94
07:28:35 <geekosaur> looks iso8859-ish to me
07:28:52 <muake> joncol: what was the original text?
07:28:57 <merijn> See here why you should always explicitly specify encoding if you wanna know wtf you're doing
07:29:01 <merijn> Oh!
07:29:04 <merijn> Actually!
07:29:07 <merijn> Better question
07:29:16 <joncol> "hello, world. ÅÄÖ åäö"
07:29:21 <merijn> joncol: Can you open your haskell source file and run ":set fenc?"
07:29:30 <muake> I suspect codepagery
07:29:34 <joncol> sure...
07:29:45 <merijn> muake: I suspected that he's compiling not-haskell :D
07:30:11 <muake> https://en.wikipedia.org/wiki/Code_page_437
07:30:23 <muake> looks like you're getting output in cp-437
07:30:26 <joncol> fileencoding=utf-8
07:30:33 <merijn> awww, bummer that's correct
07:31:30 <jameseb> yeah, that doesn't look like UTF-8 output, it appears to be some sort of extended ASCII
07:31:31 <tdammers> run file on it maybe?
07:31:41 <muake> joncol: you have the file open in vim, right? try ":e ++enc=cp-437"
07:32:29 <joncol> muake: ILLEGAL BYTE in line 1...
07:32:38 <joncol> hello, world. ??? ???
07:32:40 <muake> whoa
07:32:49 * muake tries some stuff
07:33:25 <xplat> if only unicode had been around in the 60s, we'd have much less problems now ;)
07:33:42 <wouter_> How would you model a poker game (Texas Holdem)? I'm thinking about a Gamestate type with the actions being functions such as raise, call, fold etc. on this type returning a new state.
07:33:47 <joncol> I'll ssh to a Linux machine and see if it works better..
07:34:07 <muake> hah
07:34:17 <tdammers> xplat: I think we have to blame the fact that RAM was prohibitively expensive back then
07:34:17 <muake> joncol: try ":e ++enc=cp437"
07:34:27 <muake> no, this is a DOS legacy thing
07:34:57 <tdammers> the codepages, yes
07:35:06 <tdammers> the "one character per byte", don't think so
07:35:18 <muake> oops, that was in response to the ssh/linux thing
07:35:43 <joncol> I still get "noise", let's see if I can paste an image somewhere...
07:35:47 <merijn> wouter_: Sounds fair enough
07:35:50 <xplat> before ASCII we had baudot code
07:36:12 <muake> it works for me with cp437
07:36:35 <kuribas> Which library do you use for xml processing?
07:36:45 <joncol> http://snag.gy/Y9DgQ.jpg
07:37:23 <joncol> That's how it looks for me (also in vim after doing the ":e ++enc=cp437" thing and then pasting)
07:37:35 <muake> wait, pasting?!
07:37:38 <muake> pasting what?
07:37:43 <muake> I thought we were talking about a file!
07:38:07 <kuribas> hxt?
07:38:13 <joncol> OK, the image on snag.gy was the output from my hexeditor
07:38:15 <wouter_> merijn: yeah but it's maybe to OOP-like for haskell. I wanted to know if there's anything more abstract I could use.
07:38:49 <joncol> muake: Do you have any idea why the output that Data.Text.IO.writeFile generates is not UTF-8 encoded?
07:38:52 <muake> 1) open the file in vim or gvim  2) :e ++enc=cp437
07:38:58 <jameseb> joncol:  that doesn't look like CP-437
07:39:01 <merijn> wouter_: I wouldn't make things more difficult than they are. You have a gamestate, functions take game states as input and return new gamestates as output
07:39:03 <wouter_> < like 'parsing' the actions to find out if it's legal.
07:39:18 <wouter_> merijn: tx
07:39:26 <muake> joncol: probably because you're running it from a console where codepage 437 is active
07:39:28 <merijn> joncol: Because, as I said, writeFile doesn't use UTF-8 as encoding, it auto determines what your environment uses as default encoding and uses that
07:39:56 <merijn> joncol: Which is also why I said that you should be using Text.Encoding to explicitly encode Text to ByteString and writing ByteString to a file :)
07:40:14 <muake> hmm. that means "type yourfile.txt" in a console should look right, too :-)
07:40:31 <joncol> muake: it does
07:40:48 <joncol> OK, merijn. I'll try to explicitly write ByteStrings instead.
07:40:50 <joncol> THanks
07:41:15 <nkaretnikov> i'm comparing a regular haskell bytestring to one that's generated by aeson.  the former uses 92 110 (\\n) to represent a newline while the latter just uses 10 (\n).  how can I pack/unpack either of them to get the identical representation?
07:41:22 <merijn> joncol: That way you'll never have to guess whether a user has some obscure environment setup, breaking your coe :)
07:41:26 <nkaretnikov> 92 110 is generated by unlines, btw
07:41:56 <geekosaur> nkaretnikov, sounds to me like the first one used show at some point
07:42:06 <nkaretnikov> let me check
07:42:16 <geekosaur> (or print vs. putStr{,Ln})
07:42:24 <muake> merijn: or http://hackage.haskell.org/package/base-4.8.1.0/docs/System-IO.html#v:hSetEncoding
07:43:36 <merijn> muake: Oh, yeah, I guess
07:43:51 <merijn> I usually deal with ByteString anyway, so that's the first thing I use :p
07:43:57 <muake> perl style!
07:44:17 <muake> the usual advice in perl is to de-/encode at the boundaries and let your program core deal with pure text
07:44:19 <nkaretnikov> geekosaur: no prints for sure, it's probably show, but i can't find it anywhere.
07:44:36 <joncol> merijn: Awwww yeah, now it works, using Data.ByteString.writeFile :(
07:44:45 <joncol> :) I mean.
07:45:08 <nkaretnikov> geekosaur: i can pack/unpack if it helps, but i've already tried that, and it doesn't seem to make a difference :\
07:45:45 <nkaretnikov> geekosaur: any easy solution?  it's driving me nuts
07:46:00 <geekosaur> pack/unpack wouldn't do it
07:46:12 <sgronblo> So what does anaphoric mean?
07:46:32 <geekosaur> aeson is outputting the string in exact form. whatever the other thing is is outputting it in haskell source form, which you normally get from invoking show on the string
07:46:44 <geekosaur> is it also wrapped in double quotes?
07:46:45 <nkaretnikov> geekosaur: oh, i get it
07:46:48 <muake> joncol: withFile "yourfile.txt" WriteMode (\h -> do hSetEncoding h utf8; Data.Text.IO.hPutStr h "xyz äö")  // should also work
07:47:15 <nkaretnikov> geekosaur: it is, but that's because it's json not because of show
07:47:19 <geekosaur> (if it is, you can use read to recover it)
07:47:43 <muake> sgronblo: factoring out a common prefix
07:47:52 <nkaretnikov> geekosaur: it's like "\"something\":\"value\""
07:47:54 <Luke> tomjaguarpaw: ping
07:48:17 <geekosaur> oh, and aeson doesn't escape newlines in the embedded strings?
07:48:22 <geekosaur> I think that could go either way
07:48:43 <nkaretnikov> geekosaur: aeson just inserts \n
07:48:50 <nkaretnikov> so it shows up as a single line on putStrLn
07:49:05 <nkaretnikov> while the haskell string is printed on multiple lines
07:49:48 <muake> sgronblo: hmm, not really
07:49:50 <geekosaur> right, I don't think that's a JSON requirement, just a style choice
07:50:03 <nkaretnikov> geekosaur: the only solution i can think of is to just use aeson on my haskell string, but that's unfortunate
07:50:16 <nkaretnikov> geekosaur: anyway thanks for giving me a hand :)
07:50:24 <geekosaur> if either one will work when reading it back in as JSON then it doesn;t rrally matter much. also I would NOT rely on that
07:50:51 <nkaretnikov> it's just for a test
07:51:07 <geekosaur> that is, rely on assuming that the JSON form represents embedded newlines in a particular way. it's a lovely way to get bitten by things that round-trip the same way but are different in JSON form
07:51:11 <sgronblo> muake: uh ok, i still dont get what this Control.Monad.IfElse is trying to say by anaphoric, but I will try.
07:51:26 <nkaretnikov> geekosaur: i can live with that in this testsuite, reall
07:51:27 <nkaretnikov> y
07:51:46 <nkaretnikov> no one's going to get hurt, i promise
07:52:34 <muake> sgronblo: I don't get it either
07:52:54 <joncol> muake: OK good to know
07:53:01 <muake> e.g. 'aif' is just 'maybe'
07:53:03 <muake> :t maybe
07:53:04 <lambdabot> b -> (a -> b) -> Maybe a -> b
07:53:12 <muake> ok, different argument order
07:53:50 <muake> return' x = return $! x
08:11:40 <ocharles__> huh, I thought base now had `instance Foldable Sum` - but apparently I'm mistaken
08:11:45 <ocharles__> was that not meant to be the case?
08:12:48 <keko_> I remember seeing one
08:13:17 <ocharles__> https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Foldable.html doesn't list it
08:13:43 <siwica> What is the correct syntax to search for all functions in hoogle that take a tuple as their first argument?
08:14:24 <merijn> @hoogle (a, b) -> c
08:14:24 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
08:14:24 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> ((a, b) -> c)
08:14:24 <lambdabot> Prelude snd :: (a, b) -> b
08:14:31 <merijn> Hmm, that's not all, I guess
08:14:58 <keko_> ocharles__: but the definition of sum uses it https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Foldable.html#sum
08:15:53 <jameseb> ocharles__: what would a Foldable instance for Sum look like?
08:16:04 <ocharles__> keko_: not quite, that uses the Monoid instance
08:16:10 <ocharles__> jameseb: well it's actually First and Last that I wanted
08:16:26 <ocharles__> foldr f b (Last (Just a)) = f a b ; foldr _ b _ = b
08:17:10 <kuribas> Can I get ghci to pretty print output?
08:17:17 <kuribas> with indentations and stuff?
08:17:19 <keko_> ocharles__: oh, I misunderstood
08:17:24 <ocharles__> but, foldr f b (Sum a) = f a b
08:17:39 <ocharles__> I think
08:17:48 <keko_> what would a Foldable instance for Sum look like?
08:17:59 <ocharles__> see above
08:18:59 <keko_> yeah, it didn't sound like it would do a whole lot :)
08:19:34 <ocharles__> but it does enough to be useful
08:19:54 <ocharles__> i have something that doesn't care what foldable it is, but somewhere else in the code the type that makes sense (for it's monoid instance) is Last
08:20:00 <ocharles__> I think I now get edwardk's frustration
08:20:20 <ocharles__> i'm now stuck, because I can't reuse Last without introducing orphans - and this is a library, so I can't do that either
08:20:44 <tdammers> orphan instance, the last hard problem in programming
08:21:05 <ocharles__> if only :P
08:21:11 <tdammers> yeah
08:21:24 <scshunt> why can't you introduce orphans?
08:21:37 <bitemyapp> scshunt: not kosher
08:21:50 <bitemyapp> scshunt: somebody else could too, then they'd conflict. Typeclasses are uniqueness + open world assumption
08:21:52 <geekosaur> orphans have non-local effects
08:22:04 <bitemyapp> scshunt: so in a library context, you need to own either the typeclass or the datatype the instance is for.
08:22:26 <geekosaur> so they're a really bad idea in libraries. (in programs they're fine, since you'd be the only one affected if one of your dependencies introduced a conflicting instance)
08:22:27 <tdammers> this is pretty bad actually
08:22:31 <bitemyapp> scshunt: ocharles__ is not writing `base`, so he owns neither Foldable nor Sum.
08:22:38 * tdammers wants namespaced instances
08:22:45 <bitemyapp> tdammers: that doesn't fix anything
08:22:53 <geekosaur> sadly, instances have to be global
08:22:54 <bitemyapp> tdammers: and is getting away from the point of typeclasses.
08:23:00 <tdammers> true
08:23:04 <scshunt> instances don't *have* to be global
08:23:05 <geekosaur> the type system becomes unsound otherwise
08:23:16 <bitemyapp> scshunt: yeah they do, unless you want something that isn't typeclasses.
08:23:16 <geekosaur> or at least, many uses of it do.
08:23:20 <scshunt> it's not fundamental to the concept
08:23:28 <bitemyapp> scshunt: which is fine, but lets not fuck up what we do have because we want something else and don't know it.
08:23:29 <scshunt> see Idris
08:23:37 <bitemyapp> scshunt: Idris doesn't really have typeclasses
08:23:44 <tdammers> yeah
08:23:48 <bitemyapp> I know they call them that, but don't let their terminological muddling confuse you.
08:23:55 <geekosaur> haskell's type system becomes unsound. better?
08:24:02 <bitemyapp> scshunt: ^^
08:24:13 <tdammers> part of the beauty of typeclasses is that you can hand stuff to other stuff and there's a contract between the two that you cannot violate
08:24:14 <geekosaur> the point being that a lot of compatibility-breaking rewiring would be needed to do it
08:24:32 <scshunt> well, there are other options, no? newtype?
08:24:38 <bitemyapp> scshunt: yep, newtype is the right answer here.
08:24:47 <bitemyapp> Or making their own Sum', either way.
08:24:57 <bitemyapp> could wrap or make different newtype.
08:25:07 <scshunt> (and does it actually break things if you stick your orphan in another module and then not let it escape? Is the issue when you link?)
08:25:31 <geekosaur> again, instances are global / always exported
08:26:22 <geekosaur> just to give an example; say you have a Map, and you have a module with its own special Ord instance for the type of the Map's key 
08:26:33 <geekosaur> you can break the Map completely, hide invisible values in it, etc.
08:26:36 <ocharles__> yea, I'm not newtyping a newtype :P
08:26:49 <scshunt> are they transitively exported?
08:27:26 <geekosaur> they are always visible. there is no hack to hide them
08:27:27 <ksf> I want to have Show/Eq instances for a closed type family.
08:27:54 <ksf> ...ghc won't derive, any hints?
08:28:47 <ocharles__> hrm, I can't find anything on the cafe
08:28:58 <ocharles__> but god knows I don't want to start the "instance Foldable Sum" discussion
08:29:55 <scshunt> ksf: can you paste an example?
08:30:21 <scshunt> geekosaur: orphans are fine in libraries if they are for classes/types defined by the libraries, right?
08:30:27 <scshunt> if they're just for organizational purposes
08:30:37 <ksf> scshunt, http://lpaste.net/139020
08:30:50 <geekosaur> if they are for things defined in the libraries in question then they are not orphans
08:31:04 <ksf> ...it's a simple case, all I want to do is switch the implementation type of label by stage.
08:31:20 <ksf> and obviously, String and Integer both have the necessary instances.
08:31:24 <geekosaur> if they are for some other type not defined in that library, and the class is not defined in your library, then it is orphan
08:31:49 <ksf> and oh, there's a "where" missing, there. it's a closed family.
08:33:47 <ksf> *logically* speaking even the instance forall a. Show (Label a) would be sound, as it's closed.
08:36:57 <ksf> eh.
08:37:23 <ksf> deriving instance Show (Op Parse)
08:37:33 <ksf> just gotta repeat it like that often enough.
08:37:34 <scshunt> yes, that works fine
08:37:46 <scshunt> because then Label s ~ Label Parse, which has a show instance
08:39:06 <scshunt> you can't make a Show instance for Label s
08:39:28 <scshunt> because it's a type synonym family and will overlap with other instances
08:39:53 <ksf> well, i don't want a new instance I actually only want the Integer/String ones.
08:40:27 <ksf> and as it's closed and every possible type has a show instance...
08:40:38 <ksf> well, haskell just doesn't get it.
08:42:53 <scshunt> ksf: yeah, I'm not sure if that's possible. You could try filing a bug
08:48:12 <catofhask> Hi I had some constructor like - data UA = CE Email deriving Generic with autoderivations for parsing to and from json using Aeson.
08:48:52 <catofhask> But now I have added another constructor - data UA = CE Email | CR [Role] deriving Generic
08:49:40 <liste> catofhask see https://hackage.haskell.org/package/aeson/docs/Data-Aeson-Types.html#v:defaultOptions
08:49:49 <liste> it defines the rules for sum types
08:49:58 <catofhask> I have old data that I still need to parse, my question is how Aeson's autoderivation works so that I can write some conditional code to avoid parse errors
08:50:06 <liste> namely sumEncoding
08:51:11 <catofhask> liste: thanks, will hav ea look
08:52:03 <liste> so by default your field would be something like { "tag": "CE", "contents": ... }
08:54:43 <liste> so if you want forward compability you could make the relevant types sum types from the start
08:55:05 <Peaker> orphans could have been checked at link-time and much of the problem would disappear(?)
08:55:38 <Peaker> geekosaur: I think there's an alternative to instances being global -- the ability to index types by selected instances
09:03:06 <zennist> why does atomicModifyIORef gets a function of a -> (a, b) ?
09:03:56 <Cale> zennist: It's also allowed to compute some other result apart from the updated value of the IORef while the IORef is locked.
09:04:33 <Cale> atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b <-- see the b in the result?
09:04:53 <zennist> what's the meaning of computing extra result when that result is not captured in the returned value IO b?
09:05:12 <Cale> Oh, you're wondering about the a?
09:05:18 <Cale> That's the new value of the IORef
09:05:19 <zennist> yeah
09:05:36 <zennist> ..okay I'm confused
09:05:54 <zennist> since I get a 'IO b', all my later reads will give me the 'b' right?
09:06:35 <zennist> ah ok, sorry
09:06:45 <zennist> dumb mistake
09:06:46 <Cale> The function of type a -> (a,b) is applied to the old value of the IORef. If the result is (x,y), say, then x is written to the IORef, and y is returned as the result of the IO action.
09:07:44 <zennist> yes I see it now
09:08:09 <Peaker> atomicModifyIORef is a nice demonstration of both purity and laziness, in just one action :)
09:08:24 <Cale> and parametric polymorphism :)
09:08:36 <hodapp> launchAtomicMissiles?
09:08:49 <Cale> You know that it's the second part of the pair which is returned as the result, because there's no other place to get a value of type b from
09:08:55 <zennist> where does the laziness come in?
09:09:39 <Peaker> zennist: the "a" you put into the IORef is a lazy thunk, so even if you have a very heavy computation -- it will not cause contention on the IORef
09:09:46 <GLM> How do I convert a value of type Maybe Maybe Int to something of Maybe int?
09:09:53 <liste> GLM join (:
09:10:01 <Cale> and you know that the first part of the pair is the one that gets written to the IORef because it has type a -- you couldn't write the value of type b because it would be a type error
09:10:11 <liste> > join Just (Just "12")
09:10:13 <lambdabot>      Couldn't match type ‘Maybe (Maybe [Char])’ with ‘Maybe [Char] -> a’
09:10:13 <lambdabot>      Expected type: Maybe [Char] -> Maybe [Char] -> a
09:10:13 <lambdabot>        Actual type: Maybe [Char] -> Maybe (Maybe [Char])
09:10:17 <liste> > join $ Just (Just "12")
09:10:18 <lambdabot>  Just "12"
09:10:37 <liste> works for other monads too
09:10:41 <liste> like list
09:10:56 <liste> > join [['a', 'b', 'c'], ['d', 'e']]
09:10:57 <lambdabot>  "abcde"
09:11:12 <GLM> liste:Does that work for any number of levels?
09:11:21 <liste> GLM if you repeat it
09:11:27 <Zekka> GLM: It will only get rid of one level each time
09:11:38 <Zekka> > join (Just (Just (Just "12)))
09:11:39 <lambdabot>  <hint>:1:30:
09:11:39 <lambdabot>      lexical error in string/character literal at end of input
09:11:43 <Zekka> > join (Just (Just (Just "12")))
09:11:44 <lambdabot>  Just (Just "12")
09:11:48 <aweinstock> :t join.join
09:11:50 <lambdabot> Monad m => m (m (m a)) -> m a
09:12:08 <GLM> Zekka:Is there a way to have it reduce it to one level every time?
09:12:18 <liste> GLM that wouldn't type check
09:12:22 <zennist> Peaker: okay, sounds good; but does that mean if I write for a large number of times, and then the next read will take a significant amount of time?
09:12:38 <Zekka> GLM: You could probably do it with typeclass hackery but it would be pretty messy and I don't *think* there's a good reason for it
09:12:49 <zennist> Peaker: also, how would you comment on the laziness of 'b'
09:13:07 <Zekka> If your code is generating more than two levels of Maybe a lot of the time that's often a sign you're using the Functor instance of Maybe a lot when you mean the Monad instance
09:13:13 <GLM> liste:Makes sense. I figured there might be a case where there are 50 Maybes inside eachother and that'd be annoyin
09:13:30 <Peaker> zennist: not necessarily, you can use atomicModifyIORef' which forces the heavy thunk, but it does so *after* it's done updating the IORef, so it still doesn't cause contention on the IORef
09:13:37 <Zekka> (Monads are basically functors that join implicitly and support `return`)
09:13:42 <Peaker> zennist: you can force the "b" result after the atomicModifyIORef is done
09:13:55 <bitemyapp> Zekka: good explanation.
09:14:06 <bitemyapp> well-identified pattern too
09:14:09 <liste> GLM if you have multiple Maybes, use >>=
09:14:14 <liste> or do notation
09:14:57 <zennist> I hope I'm understanding this correctly, really; but I thought IO monad is not lazy?
09:15:05 <aweinstock> GLM: can you paste an example of the code you're generating a (Maybe (Maybe Int)) from  on lpaste.net?
09:15:09 <Peaker> zennist: it isn't
09:15:33 <zennist> so "b" should already be strict..?
09:15:35 <aweinstock> > length . take 4 $ cycle [putStrLn "hello"]
09:15:37 <lambdabot>  4
09:17:02 <liste> GLM for example if f :: a -> Maybe b and g :: b -> Maybe c, you can do {y <- f x; z <- g y; return z}
09:18:02 * hackagebot messagepack 0.5.0 - Serialize instance for Message Pack Object  https://hackage.haskell.org/package/messagepack-0.5.0 (rodrigosetti)
09:18:02 <liste> > let f = Just; g = Just in do {y <- f 'a'; z <- g y; return z}
09:18:02 <aweinstock> @undo do {y <- f x; z <- g y; return z}
09:18:02 <lambdabot> f x >>= \ y -> g y >>= \ z -> return z
09:18:04 <lambdabot>  Just 'a'
09:18:15 <aweinstock> @. pl undo do {y <- f x; z <- g y; return z}
09:18:15 <lambdabot> g =<< f x
09:18:48 <Zekka> Which says join (fmap g (f x))
09:18:50 <aweinstock> > Just =<< Just 'a'
09:18:51 <lambdabot>  Just 'a'
09:29:56 <mechanical-eleph> So, this may be a stupid question. I have a yesod application as well as a bunch of React JSX code and I’m trying to figure out how to get them to build with the same tool.  I use yesod devel, which watches and recompiles yesod.  And previously I had a JS Gulp script which watched the jsx and recompiled it.  I’m not sure where to start on integrating the two… Can I hook the gulp script into yesod devel through cabal 
09:29:57 <mechanical-eleph> or some such?
09:38:02 * hackagebot som 8.2.2 - Self-Organising Maps.  https://hackage.haskell.org/package/som-8.2.2 (AmyDeBuitleir)
09:44:42 <Zemyla> Does a singleton type with no fields (like Proxy) disappear if it's unboxed inside another type?
09:48:03 * hackagebot harmony 0.1.0.1 - A web service specification compiler that generates implementation and tests.  https://hackage.haskell.org/package/harmony-0.1.0.1 (SantiMunin)
09:53:01 <breadmonster> Hey guys.
09:53:02 <breadmonster> http://article.gmane.org/gmane.comp.lang.haskell.cafe/117718
09:53:12 <breadmonster> Can someone explain what's going on there?
09:54:45 <ReinH> breadmonster: perhaps tomjaguarpaw can
09:55:19 <breadmonster> ReinH: Oh I didn't realize he was here.
09:55:28 <breadmonster> tomjaguarpaw: What exactly were you doing?
09:58:42 <breadmonster> Back, sorry about that.
10:02:06 <tommd> Long ago, there was discussion about depricating bytestring in its current form and adopting vector-bytestring as the new 'bytestring'.  Is anyone here who worked that effort and has insights? (Bas?)
10:03:25 <nkaretnikov> geekosaur: reporting back: i just replaced the integers with chr/ord to make it match.  btw, aeson has nothing to do with it, it's readProcessWithExitCode that does that
10:23:04 * hackagebot react-flux 0.9.0 - A binding to React based on the Flux application architecture for GHCJS  https://hackage.haskell.org/package/react-flux-0.9.0 (JohnLenz)
10:23:37 <liste> mechanical-eleph you can put hooks on Setup.hs (https://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/Distribution-Simple-UserHooks.html)
10:24:06 <liste> seems a bit hacky though if two build tools fiddle with the files
10:24:15 <liste> the timestamps may get a bit out of sync
10:25:18 <liste> remember to change the build-type: to Custom in xxx.cabal
10:26:57 <liste> then replace the defaultMain in Setup.hs with your defaultMainWithHooks ...
10:27:30 <liste> I've had similar problems - how do others solve that? tools like shake/make ?
10:28:03 <tommd> What's the question?
10:28:05 * hackagebot haskelldb-hdbc 2.2.4 - HaskellDB support for HDBC.  https://hackage.haskell.org/package/haskelldb-hdbc-2.2.4 (JustinBailey)
10:28:21 <liste> integrating non-Haskell build tools to your projects
10:28:51 <tommd> Ah, yeah.  Annoying to say the least.
10:29:09 <tommd> That is, if you want the build to give a sensible error message when the tool is missing.
10:30:22 <Gurkenglas> My main contains some let bindings. Can I access them in ghci?
10:30:31 <Gurkenglas> (in the do block)
10:30:35 <tommd> Gurkenglas: nope.
10:30:47 <tommd> You can step through an execution I suppose.
10:31:51 <tommd> Look into ghci debugging (:step, :break, etc)
10:45:31 <athan> Is there no `find` function for Data.Map? Something like `find :: (a -> Bool) -> Map k a -> Maybe (k, a)`?
10:46:07 <liste> athan lookup?
10:46:11 <liste> oh no
10:46:12 <liste> srry
10:46:15 <athan> liste: np
10:49:09 <mauke> > find even (M.fromList [("a", 1), ("b", 2)])
10:49:11 <lambdabot>  Just 2
10:49:40 <aweinstock> mauke, that gives the value, not the key
10:50:17 <aweinstock> :t \p -> find p . Data.Map.toList
10:50:22 <lambdabot> ((k, a) -> Bool) -> M.Map k a -> Maybe (k, a)
10:50:30 <aweinstock> (but that's O(n))
10:50:35 <mauke> > find (even . snd) (M.toList (M.fromList [("a", 1), ("b", 2)]))
10:50:37 <lambdabot>  Just ("b",2)
10:50:57 <liste> how would find be less than O(n)?
10:51:03 <mauke> that function is necessarily O(n)
10:51:12 <shachaf> > ifind (\_ x -> even x) (M.fromList [("a", 1), ("b", 2)])
10:51:13 <lambdabot>  Just ("b",2)
10:51:34 <aweinstock> :t ifind
10:51:36 <lambdabot> FoldableWithIndex i f => (i -> a -> Bool) -> f a -> Maybe (i, a)
10:53:06 * hackagebot al 0.1.4.1 - OpenAL 1.1 raw API.  https://hackage.haskell.org/package/al-0.1.4.1 (DimitriSabadie)
10:54:45 <Oddstrider> wazzap
10:55:12 <athan> aweinstock: I don't think it's possible to do better :) thank you!
11:02:27 <aweinstock> athan: depending on exactly what you're doing, it might be possible to do an O(n) preprocessing step to "transpose" the map ((k -> v) -> (v -> (k, Integer)), and get O(log(n)) lookups afterwards
11:03:51 <aweinstock> (but I don't think that maintaining the inverse map works well if you're interleaving inserts with lookups)
11:06:03 <aupiff_> does everyone recommend using persistent over just the `mongoDB` driver? 
11:07:20 <liste> aupiff_ it depends
11:07:38 <liste> persistent tends to be rough if you have an already existing dataset
11:10:34 <kadoban> I just started playing with persistent … so far it seems fairly nice though.
11:13:07 * hackagebot hans 2.4.0.1 - IPv4 Network Stack  https://hackage.haskell.org/package/hans-2.4.0.1 (TrevorElliott)
11:13:09 * hackagebot harmony 0.1.0.2 - A web service specification compiler that generates implementation and tests.  https://hackage.haskell.org/package/harmony-0.1.0.2 (SantiMunin)
11:13:28 <zipper> What does -ddump-splices do?
11:13:32 <zipper> In GHC
11:14:07 <glguy> Prints all the code generated by splices during compilation
11:15:29 <aweinstock> splices = Template Haskell splices = compile-time code execution (like lisp's defmacro)
11:16:10 <zipper> Can I run this on a file?
11:16:27 <zipper> Anyway let me try it
11:16:55 <slack1256> I thought that expanded the macros and outputted them
11:18:07 * hackagebot JuicyPixels 3.2.6 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.6 (VincentBerthoux)
11:21:40 <aweinstock> slack1256: that's what it does, but "expanding the macros" involves running haskell code at compiletime (unlike C preprocessor macros, which is a different language from C)
11:26:44 <lpaste_> aweinstock pasted “Template Haskell example” at http://lpaste.net/139026
11:27:09 <zipper> Where does ghc put these splices? or what is the file extenstion of these splices?
11:27:27 <zipper> I know I'm totally new at all these but I need this info.
11:28:50 <aweinstock> "ghc -ddump-splices somefile.hs" will compile somefile.hs, and show the result of any TH macro invokations and their results on standard output
11:29:17 <aweinstock> (it doesn't print them to a file)
11:29:47 <aweinstock> s/result of/source of
11:32:13 <aweinstock> zipper: what's the context of this? is there something specific you're trying to debug/implement?
11:34:00 <geekosaur> iirc the code printed by -ddump-splices is sometimes incorrect? because it's backforming from the AST and sometimes doesn;t include parens where needed
11:37:42 <aweinstock> geekosaur: wouldn't it be a GHC bug if it doesn't include parens when needed (based on precedence)?
11:37:59 <geekosaur> no? the point is the source form printed by -ddump-splices does not exist
11:38:10 <geekosaur> it is backforming source from the AST just to do -ddump-splices
11:38:16 <geekosaur> the form it *uses* is the AST
11:38:44 <geekosaur> because AST is what you generate with TH
11:41:06 <aweinstock> isn't it possible for it to correctly infer a minimal amount of parens to add to the AST based on infix definitions in scope of the TH splice?
11:42:00 <geekosaur> it is possible, yes. the thing I am remembering (and it may not apply to this but I think -ddump-splices was the context) was a recently recognized bug
11:42:04 <aweinstock> (obviously it's not a trivial algorithm, but it's solvable in principle, and hence a bug if the generated source doesn't correspond to the generated AST)
11:42:08 <geekosaur> low priority because it doesn't affect behavior
11:42:29 <aweinstock> ah
11:43:09 * hackagebot harmony 0.1.0.3 - A web service specification compiler that generates implementation and tests.  https://hackage.haskell.org/package/harmony-0.1.0.3 (SantiMunin)
11:53:09 * hackagebot terminfo-hs 0.2.0 - A pure-Haskell (no FFI) module for accessing terminfo databases  https://hackage.haskell.org/package/terminfo-hs-0.2.0 (BryanRichter)
11:58:10 * hackagebot svg-tree 0.3.2 - SVG file loader and serializer  https://hackage.haskell.org/package/svg-tree-0.3.2 (VincentBerthoux)
12:08:35 <nkaretnikov> did Tekmo stop using irc completely?
12:09:48 <mniip> nkaretnikov, [21:06:46] * [tekmo] is logged in as tekmo
12:09:57 <mniip> if that's the user you have in mind
12:10:07 <mniip> oh, I see, idle for 430 hours
12:10:19 <liste> ircname derek?
12:14:33 <nkaretnikov> liste: definitely not derek :)
12:14:51 <nkaretnikov> mniip: p.s.: i know how to use whois ;)
12:18:12 <aupiff_> if I have a ToJSON instance of a datatype, what's the recommended way to create a `Data.BSON.Document` from an value of that type?
12:21:56 <srhb> aupiff_: can you link to that type? If you'd just said "document" it sounded like encode, but...
12:22:29 <liste> I suppose this http://hackage.haskell.org/package/bson-0.3.1/docs/Data-Bson.html#t:Document
12:23:21 <aupiff_> yes
12:23:23 <aupiff_> that one
12:24:34 <aupiff_> I'm going to try this: https://hackage.haskell.org/package/aeson-bson
12:25:24 <srhb> That seems like the correct approach. :-)
12:26:25 <liste> there's also AesonBson and abeson
12:26:41 <liste> seems all of them are quite immature though
12:28:11 * hackagebot terminfo-hs 0.2.1 - A pure-Haskell (no FFI) module for accessing terminfo databases  https://hackage.haskell.org/package/terminfo-hs-0.2.1 (BryanRichter)
12:30:24 <jackhill> Hi, is it possible to set custom locations for stack's .stack directory and where it puts temporary files?
12:37:10 <AaronFriel> Suppose I've got an [Either a b], and I know that it's of the shape [Right _, Right _, ...  Left _], and it's lazily produced, and the value of the final (Left _) only depends on the value of the final (Right _)... is there a way to create a tuple ([a], b) such that evaluating the fst is lazy, evaluating the snd will force the force the fst, and with sharing, if the fst has already been forced to normal form, evaluating the snd won't re-evaluate?
12:38:02 <AaronFriel> Or is this a laziness thing I'm just missing and the solution is obvious?
12:38:48 <mauke> why would snd force the fst?
12:38:57 <AaronFriel> Because its value depends on the last value of the fst
12:39:14 <mauke> yeah, but nothing else
12:39:40 <AaronFriel> I don't follow
12:39:41 <mauke> snd doesn't depend on the structure of fst, and almost none of the values
12:40:20 <AaronFriel> Sorry - there is a dependency chain - we can't produce the second element of the fst without the first element of the fst
12:40:46 <AaronFriel> What I want to know if there is some way to produce some sharing
12:41:02 <mauke> ok, then I don't see how you can create your tuple and have it not do what you described
12:41:17 <mauke> or what am I missing
12:41:28 <mniip> AaronFriel,  simple list iteration will share
12:42:21 <AaronFriel> I guess what I'm asking is ... if I've got this [Either a b], call it "xs", what I have to do to it is "rights xs, head . lefts xs"
12:42:30 <AaronFriel> err $ but you get it
12:42:40 <AaronFriel> But that causes it to iterate over xs again, no?
12:42:55 <AaronFriel> My concern is - I've got a potentially incredibly large xs
12:43:09 <AaronFriel> I'd like to set it up so that the sharing is cheaper in my iteration function
12:43:12 * hackagebot fwgl 0.1.3.0 - Game engine  https://hackage.haskell.org/package/fwgl-0.1.3.0 (ZioCrocifisso)
12:43:14 * hackagebot fwgl-glfw 0.1.1.0 - FWGL GLFW backend  https://hackage.haskell.org/package/fwgl-glfw-0.1.1.0 (ZioCrocifisso)
12:43:16 * hackagebot fwgl-javascript 0.1.1.0 - FWGL GHCJS backend  https://hackage.haskell.org/package/fwgl-javascript-0.1.1.0 (ZioCrocifisso)
12:43:24 <poopselr> Can I somehow combine 2 Proxy values with some type constructor?
12:43:26 <AaronFriel> That is, my iteration function returns an ([a], b) instead of an [Either a b]
12:43:35 <poopselr> :t Proxy
12:43:36 <lambdabot> forall (k :: BOX) (t :: k). Proxy t
12:43:43 <poopselr> > :t Proxy
12:43:44 <ski> is the original list produced by something like `unfoldr' ?
12:43:45 <lambdabot>  <hint>:1:1: parse error on input ‘:’
12:43:53 <AaronFriel> ski: Yes it is
12:44:00 <AaronFriel> ski: I'm doing an unfold on some initial values
12:44:04 <mniip> AaronFriel,  make your own iterator
12:44:05 <poopselr> >t Proxy
12:44:16 <poopselr> :S
12:44:25 <mniip> iter [Left l] = (l, [])
12:44:25 <AaronFriel> mniip: The solution isn't obvious to me what to do to produce the sharing I want
12:44:43 <mauke> blargh (Right r : xs) = case blargh xs of ~(ys, b) -> (r : ys, b)
12:44:45 <mniip> iter (x:xs) = fmap (x:) $ iter xs
12:44:55 <mauke> blargh (Left l : _) = ([], l)
12:44:59 <mniip> oh right, Right
12:45:20 <poopselr> @type Proxy
12:45:21 <lambdabot> forall (k :: BOX) (t :: k). Proxy t
12:45:29 <AaronFriel> Sorry - elaborate? I see you're using ~ to force lazy evaluation, but please explain
12:45:36 <poopselr> @type Proxy :: Proxy Int
12:45:37 <lambdabot> Proxy Int
12:45:54 <mauke> "force lazy" - poor choice of words :-)
12:46:02 <AaronFriel> mauke: ha, yes
12:46:07 <mniip> it's an irrefutable pattern
12:46:34 <mauke> it tells the compiler, "trust me, this is totally gonna match at runtime"
12:46:38 <mniip> without it, the structure of the result would depend on the end of the list
12:46:40 <mauke> (if it doesn't, you get a runtime error)
12:47:01 <AaronFriel> ah
12:47:04 <mniip> even though (,) has only one structure
12:47:04 <ski> (the actual patttern-matching computation is delayed)
12:47:26 <mauke> yeah, it can't fail with (,)
12:48:12 <AaronFriel> and so I'm saying to the compiler, I REALLY know that this list will end in a "Left", let me shoot myself in the foot if it doesn't? (Irrefutable patterns produce errors at runtime if they fail, yes?)
12:48:21 <AaronFriel> (errors as in "error" errors)
12:49:57 <mauke> nah, the point of this irrefutable pattern is to delay pattern matching
12:50:14 <mauke> it can't fail in this case
12:50:47 <ski> AaronFriel : maybe an alternative could be to use something like `data EndList e a = End e | Cons a (EndList e a)' ..
12:50:59 <AaronFriel> hm
12:51:44 * ski isn't sure whether AaronFriel wants to retain the `unfoldr'-based generation, or is prepared to restructure it
12:51:52 <AaronFriel> I'm okay with restructuring it
12:52:19 <AaronFriel> What I want is, if the first element of the tuple (the [a]s) has been fully evaluated, the second element should be cheap to use
12:52:40 <AaronFriel> where cheap == not having to run the unfold again
12:53:13 * hackagebot octohat 0.1.5.0 - A tested, minimal wrapper around GitHub's API.  https://hackage.haskell.org/package/octohat-0.1.5.0 (stackbuilders)
12:53:15 * hackagebot microlens 0.3.1.0 - A tiny part of the lens library which you can depend upon  https://hackage.haskell.org/package/microlens-0.3.1.0 (Artyom)
12:53:17 * hackagebot microlens-mtl 0.1.4.1 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.4.1 (Artyom)
12:53:19 * hackagebot orchestrate 0.2.0.3 - An API client for http://orchestrate.io/.  https://hackage.haskell.org/package/orchestrate-0.2.0.3 (EricRochester)
12:54:56 <AaronFriel> mniip: Okay, that works
12:55:01 <AaronFriel> mniip: Tested it with tracing
12:55:27 <AaronFriel> mniip: Could you go a little bit further into -how- it works, I'd like to improve my understanding of irrefutable patterns and how they accomplish what I want
12:57:07 <poopselr> is there a good explanation of the purpose of forall in haskell?
12:57:36 <poopselr> to me it would seem that a 'forall' is assumed by default
12:57:56 <liste> poopselr it is
12:58:13 * hackagebot FontyFruity 0.5.2 - A true type file format loader  https://hackage.haskell.org/package/FontyFruity-0.5.2 (VincentBerthoux)
12:58:15 <mniip> AaronFriel,  case x of Just _, would check the value of x to verify that it is indeed a just
12:58:37 <liste> poopselr but sometimes you need to nest foralls (rank-n types)
12:58:39 <AaronFriel> Oh, I think I get it
12:58:42 <mniip> by the same token, 'case x of (_, _)' evaluates x to ensure it is indeed a (,)
12:59:10 <AaronFriel> And (,) would evaluate both sides by default to check? 
12:59:16 <poopselr> liste: like what is the purpose of forall here: 'data Showable = forall a . Show a => MkShowable a'
12:59:20 <AaronFriel> At least to "peek" at them?
12:59:21 <mniip> not both sides
12:59:29 <mniip> it would evaluate x
12:59:52 <poopselr> liste: is that so you don't have to specify the a in the Showable kind?
13:00:02 <mniip> imagine 'x = (undefined, undefined)' versus 'x = undefined'
13:00:05 <jle`> AaronFriel: i like to think of it as a degenerate case of case x of (Just _) -> ...; Nothing -> ...
13:00:10 <liste> yeah, no a in the left side of the equation
13:00:20 <jle`> AaronFriel: here it has to evaluate at least the constructor at the outer most layer to tell if it's a Just or a Nothing
13:00:34 <liste> it's called an existential type
13:00:39 <jle`> so here we're using the (,) constructor, so it has to evaluate at least the (,) to tell if it's a (,)
13:00:46 <jle`> even though there really couldn't be any other option...
13:00:48 <poopselr> liste: what are the pros/cons of this? I assume this is not recommended for some reason?
13:00:50 <jle`> it goes through the same mechanics
13:01:06 <mniip> poopselr, pros: you can define more things
13:01:17 <mniip> cons: less portable
13:01:24 <jle`> also less usable
13:01:28 <mniip> really any ghc extension ever
13:01:38 <jle`> can make code more confusing for no reason
13:01:50 <jle`> and doesn't add much in most cases
13:01:52 <liste> https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
13:02:21 <poopselr> mniip: does this result only in a different in the static type checking?
13:02:21 <AaronFriel> So, how does the irrefutable pattern give me the laziness I want?
13:02:24 <jle`> in this case Showable is basically a String with an extra layer of indirection
13:02:29 <poopselr> ie no runtime difference?
13:03:04 <mniip> runtime difference from what
13:03:26 <mniip> you can't make a ShowBox without the extension
13:03:51 <mniip> as for the rest of the code, no, there is no penalty on regular code
13:03:53 <poopselr> mniip: I mean is there any performance cost when using this extension during runtime?
13:05:11 <AaronFriel> poopselr: If I recall, there is, because each Showable has to carry around its dictionary
13:06:20 <AaronFriel> poopselr: Someone correct me if I'm wrong, but the implementation is similar to vtables in C++, existential types with dictionaries ~ virtual classes with vtables
13:06:24 <poopselr> I guess it also results in a weaker type overall
13:06:24 <Cale> AaronFriel: Irrefutable patterns succeed without evaluation, and evaluation of the scrutinee only occurs when one of the variables bound by the pattern is evaluated. It is a runtime error if the pattern doesn't match at that point.
13:06:50 <ski> AaronFriel : oh, so forcing (the spine of, and perhaps also the elements of) the first component would more or less also force the second component (possibly not including a final piece of work not dependent on the length of the list), you mean ?
13:06:51 <Cale> > case [] of ~(x:xs) -> 5
13:06:53 <lambdabot>  5
13:06:59 <Cale> > case [] of ~(x:xs) -> x
13:07:00 <lambdabot>  *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patte...
13:07:48 <AaronFriel> ski: Forcing the second element would force the spine of the first, rather. 
13:08:05 <AaronFriel> ski: I'm not sure if that's what you said, I didn't quite parse it
13:08:21 <mniip> AaronFriel,  okay look
13:08:52 <aweinstock> > case (undefined, undefined) of (a,b) -> a
13:08:54 <lambdabot>  *Exception: Prelude.undefined
13:09:00 <aweinstock> > case (undefined, undefined) of ~(a,b) -> a
13:09:01 <lambdabot>  *Exception: Prelude.undefined
13:09:15 <mniip> @let foo [] = (); foo (_:xs) = case foo xs of () -> ()
13:09:17 <lambdabot>  Defined.
13:09:24 <mniip> > foo "bar"
13:09:26 <lambdabot>  ()
13:09:26 <mauke> > case undefined of ~(a,b) -> "cool"
13:09:28 <lambdabot>  "cool"
13:09:40 <mniip> > foo (1:2:3:undefined)
13:09:42 <lambdabot>  *Exception: Prelude.undefined
13:11:11 <ski> poopselr : if `forall' isn't mentioned explicitly, then it's "assumed" at the whole of the type signature (except for type variables that already are in scope around the type signature)
13:11:56 <ski> poopselr : in `data Showable = forall a . Show a => MkShowable a' (not a type signature), the role of `forall' there is to claim that the data constructor `MkShowable' is polymorphic in `a', provided it satisfies the constraint `Show a'
13:12:26 <ski> poopselr : iow, it is (indirectly) asserting `MkShowable :: forall a. Show a => a -> Showable'
13:13:14 * hackagebot microlens-platform 0.1.1.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.1.1.0 (Artyom)
13:13:21 <ski> poopselr : conceptually, this is isomorphic to `MkShowable :: (exists a. Show a *> a) -> Showable', hence the name "existential datatype (constructor)"
13:14:12 <liste> you can achieve the same with GADTs
13:14:35 <liste> @let data Showable where MkShowable :: Show a => a -> Showable
13:14:36 <lambdabot>  Defined.
13:14:52 <liste> > show (MkShowable (5 :: Int))
13:14:54 <lambdabot>      No instance for (Show Showable) arising from a use of ‘show’
13:14:54 <lambdabot>      In the expression: show (MkShowable (5 :: Int))
13:15:19 <liste> ...the irony :D
13:15:22 <jle`> @let deriving instance Show Showable
13:15:25 <lambdabot>  Defined.
13:15:28 <liste> > let k = (MkShowable (5 :: Int))
13:15:30 <lambdabot>  <no location info>:
13:15:30 <lambdabot>      not an expression: ‘let k = (MkShowable (5 :: Int))’
13:15:32 <liste> > show (MkShowable (5 :: Int))
13:15:35 <lambdabot>  "MkShowable 5"
13:16:01 <ski> poopselr : if you have a constraint, then it probably has to be carried around at run-time inside the existential. if you have no constraint, then current implementations would have no run-time overhead for the type-passing
13:16:35 <athan> Would `zip` be a hylomorphism?
13:16:49 <athan> er anamorphism of some kind?
13:16:54 <o`connor> how do I coerce a NominalDiffTime to Double?
13:16:59 <AaronFriel> ski: Was my analogy of vtables to constraint dictionaries correct?
13:17:06 <ski> (this is for implementations using type-erasure. an alternative way to implement parametric polymorphism is to pass at run-time info representing a type (e.g. info on size of a value of the type, and possibly also info about layout and internal structure))
13:17:37 <athan> er... dang, I should state my question better - how could I make a stateful map over a functor? Or really, what would `f` be if `map f xs = zip xs [0..]`?
13:18:15 <o`connor> oh, realToFrac, strangely named...
13:18:16 <srhb> o`connor: Isn't it Real? So realToFrac
13:18:28 <srhb> o`connor: Double is Fractional, so it's very sensible.
13:18:42 <o`connor> srhb: ah, ok. Thank you
13:19:01 <ski> AaronFriel : i read "if the first element of the tuple (the [a]s) has been fully evaluated, the second element should be cheap to use" as wanting a force of the first component to share the main bulk of the work with the second component, so that forcing it later doesn't have to redo the work done by the first component
13:19:21 <AaronFriel> ski: Yeah
13:19:38 <AaronFriel> ski: That's precisely it
13:19:54 <mpickering> athan: please explain what you mean
13:20:10 <mpickering> athan: maps are not stateful
13:20:18 <ski> athan : you can express it with `foldr'
13:22:24 <bennofs> What does "*" mean in a GHC heap profile?
13:23:10 <ski> AaronFriel : hm, i was thinking what i described would be something different from "Forcing the second element would force the spine of the first", but perhaps the former would entail the latter, or at least almost (iow forcing the elements of the list, if not the list cells themselves)
13:23:52 <Hijiri> athan: I think you might need traversable
13:24:16 <aweinstock> :t \f -> mapM (\x -> do { i <- get; modify (+1); return (f i x) })
13:24:16 <Hijiri> but that wouldn't let you throw away the rest of the list
13:24:17 <lambdabot> (Num s, Traversable t, MonadState s m) => (s -> a -> b) -> t a -> m (t b)
13:25:21 <ski> athan : hmm .. from the last you said it sounds like you're thinking about `Data.Traversable.mapM'/`Data.Traversable.traverse' ?
13:25:26 <Hijiri> sorry I misread your question
13:25:32 <Hijiri> I thought was just zip with two arbitrary lists
13:25:37 <AaronFriel> ski: Yeah, after I typed what I wrote, I think they're somewhat the contrapositive of the other. The second element depends on the values of the first element's values, so evaluating the second requires evaluating every element of the first.
13:25:37 <aweinstock> :t \f -> flip evalState 0 $ mapM (\x -> do { i <- get; modify (+1); return (f i x) })
13:25:39 <lambdabot>     Couldn't match type ‘t0 a -> m0 (t0 b)’
13:25:39 <lambdabot>                    with ‘StateT Integer Identity c’
13:25:39 <lambdabot>     Expected type: State Integer c
13:26:13 <aweinstock> :t \f xs -> flip evalState 0 $ mapM (\x -> do { i <- get; modify (+1); return (f i x) }) xs
13:26:15 <lambdabot> (Num s, Traversable t) => (s -> a -> b) -> t a -> t b
13:27:08 <aweinstock> athan: is the above relevant to your question?
13:27:56 <AaronFriel> Just a minor annoyance: is there a way to change the ctrl-z behavior of GHCi?
13:28:11 <AaronFriel> I code with GHCi and my text editor open, and occasionally ctrl-z in the wrong window
13:28:14 * hackagebot fwgl 0.1.3.1 - Game engine  https://hackage.haskell.org/package/fwgl-0.1.3.1 (ZioCrocifisso)
13:28:15 <fr33domlover> advice on IRC logs: if I have a bot that logs IRC channels and includes time in each line, it can use 'getCurrentTime' to get and format the current time. But that would result in many calls to this IO action. Is this the reasonable solution of is there anything better?
13:28:29 <mniip> AaronFriel,  is not a ghci behavior
13:28:34 <mniip> it's your shell
13:28:36 <AaronFriel> mniip: oh of course
13:28:50 <AaronFriel> mniip: I'll see if I can change that in tmux
13:28:50 <mniip> there is a solution though
13:28:55 <mauke> what does the shell have to do with it?
13:28:59 <mniip> not tmux
13:29:05 <AaronFriel> mauke: Shell is sending a signal, no?
13:29:06 <mniip> it's your pty driver
13:29:09 <mauke> no
13:29:56 <AaronFriel> I thought that's how ctrl-z, ctrl-c handlers worked? They send signals to the running process in the shell?
13:30:08 <mauke> s/in the shell//
13:30:15 <mniip> yes but yew signal
13:30:20 <mniip> is not sent by the shell
13:30:28 <aweinstock> I think that ctrl-z sends SIGSTOP, so you'd need a handler for that in ghci?
13:30:29 <mniip> but instead by the kernel
13:30:40 <geekosaur> AaronFriel, the tty/pty driver sends the signal SIGTSTP to all processes in the foreground process group
13:30:41 <mauke> SIGTSTP
13:30:46 <AaronFriel> ah
13:30:48 <mniip> stty sustp
13:31:02 <mniip> stty susp*
13:31:30 <mniip> stty susp $'\x01' or something
13:31:46 <mniip> with that, ^A would send sigtstp instead
13:32:00 <geekosaur> if a process does not handle SIGTSTP then it is turned directly into SIGSTOP. (this allows processes to reset the terminal or w/e; it cannot be used to prevent suspend)
13:32:15 <geekosaur> ^- is preferred
13:32:26 <geekosaur> (disables the suspend character completely)
13:32:44 <geekosaur> ^A might cause surprises with line editing
13:34:10 <mniip> what
13:34:17 <mniip> ^- isn't a thing
13:35:02 <mauke> why does trap '' SIGTSTP not work
13:35:23 <mniip> @A-Z[\]_
13:35:23 <lambdabot> Unknown command, try @list
13:35:35 <mauke> ?
13:35:42 <geekosaur> mniip, stty allows control characters to be specified as 2-char sequences ^A, ... and understands the sequence ^- as "disable this character"
13:35:50 <mniip> ah
13:36:14 <mniip> mauke,  because once signal delivery for sigtstp ends, sigstop is sent
13:36:27 <mniip> and it is unmaskable
13:37:34 <mauke> then why does it work in perl with $SIG{TSTP} = 'IGNORE'?
13:39:37 <mniip> that I can't answer
13:40:12 <mauke> hey, I didn't know about _POSIX_VDISABLE
13:40:12 <geekosaur> actually, it's because shells do job control and SIGTSTP is intercepted as part of that, so trap is ineffective
13:40:20 <geekosaur> try set +o monitor
13:40:51 <geekosaur> hm, wait, doublechecking that one...
13:41:55 <geekosaur> ok, yes, that;s the right option
13:43:09 <AaronFriel> Okay, so I looked away for a bit
13:43:20 <AaronFriel> Summary: Easy way to block ctrl-z from killing GHCi?
13:43:29 <geekosaur> stty susp ^-
13:43:36 <geekosaur> (literal chars caret, hyphen)
13:43:47 <mauke> warning: will affect your whole terminal, not just ghci
13:43:54 <geekosaur> also it's not killing it, just suspending it. try "fg" to resume
13:44:40 <phaazon> hey, is there a library for natural transformations?
13:44:41 <digitalmentat> anyone familiar with ghc-mod and the error `Warning: Could not find a component assignment, falling back to picking library component in cabal file.`?
13:44:48 <phaazon> I think mmorph is the one out there for monads
13:45:12 <phaazon> I’m not even sure I want that actually
13:45:22 <phaazon> I have several functions that deal with several kind of errors
13:45:23 <phaazon> like
13:45:31 <phaazon> foo :: (MonadError e0 m) => …
13:45:36 <phaazon> bar :: (MonadError e1 m) => …
13:45:45 <phaazon> I’d like to use them under the same type
13:45:52 <phaazon> so I guess I need natural transormations
13:45:58 <phaazon> or that kind of abstraction
13:46:51 <ansible1> anyone know what exitfailure (-11) means?
13:46:52 <phaazon> maybe Control.Monad.Except has something to do that as well
13:47:05 <ansible1> that's what my 'cabal install' end up with
13:47:13 <ansible1> not seeing any errors in the log
13:47:23 <geekosaur> ansible1, generally the numeric codes are only meaningful as zero/nonero
13:47:34 <mauke> -11? is that a signal encoding?
13:47:47 <geekosaur> you need to convince cabal to produce log output (maybe -v3)
13:48:15 <ansible1> ok will try for more -v
13:48:16 * hackagebot group-with 0.2.0.3 - Classify objects by key-generating function,  like SQL GROUP BY  https://hackage.haskell.org/package/group-with-0.2.0.3 (ulikoehler)
13:48:18 * hackagebot magico 0.0 - Compute solutions for Magico puzzle  https://hackage.haskell.org/package/magico-0.0 (HenningThielemann)
13:48:53 <geekosaur> hm. it could be signal 11 + core dumped, mapped by a shell to an exit status; consistency there is an issue though
13:49:16 <d-snp> hi I'm on ubuntu and my ghc is here: /usr/local/bin/ghc, how did I install it? :P
13:49:18 <mniip> 11 = sigsegv
13:49:35 <earthy> mniip: depending on OS, but yeah, usually
13:49:40 <ansible1> its getting partway through a compile of yesod-core (18 of 31) and kind of goes straight into linking from there.
13:49:47 <ansible1> maybe -v3 will reveal something
13:49:54 <Welkin> d-snp: possibly through the binary distribution, possibly by apt
13:49:59 <geekosaur> "straight into linking" sounds like TH loading stuff
13:50:07 <mauke> dohoho
13:50:10 <mauke> http://hackage.haskell.org/package/process-1.2.3.0/docs/System-Process.html#v:waitForProcess
13:50:11 <geekosaur> which for yesod is kinda expected >.>
13:50:22 <mauke> "On Unix systems, a negative value ExitFailure -signum indicates that the child was terminated by signal signum."
13:50:29 <mauke> it's segfaulting
13:51:00 <ansible1> shoot, that's not helpful
13:51:06 <mniip> oh also
13:51:13 <mniip> eagain = 11
13:51:30 <mauke> errno doesn't count
13:51:31 <ansible1> not entirely surprised I guess.  compiling on ARM which is not mainstream for yesod
13:51:40 <geekosaur> mniip, it's extremely rare for syscall error codes to be used as process exit statuses
13:52:06 <ansible1> the compile time is ridiculous but I don't want to rewrite my project... its worked before but not this time.
13:52:18 <d-snp> Welkin: apt doesn't install bins into /usr/local, it's got to be some third party packaging
13:52:57 <geekosaur> apt *could* install them there, just distribution packaging does not
13:53:09 <geekosaur> but /usr/local makes me think a bindist
13:53:16 * hackagebot magico 0.0.0.1 - Compute solutions for Magico puzzle  https://hackage.haskell.org/package/magico-0.0.0.1 (HenningThielemann)
13:53:52 <geekosaur> I *think* hvr's PPA installs under /opt?
13:55:00 <d-snp> yeah I'm installing that now
13:55:18 <d-snp> would like to have some way to uninstall the old one
13:55:23 <geekosaur> yep, that's /opt/ghc
13:55:37 <geekosaur> I don't think the bindist has an uninstall procedure
13:56:21 <bb010g> barrucadu: Any chance of getting irc-conduit on Stackage soon?
13:57:21 <Welkin> there is nothing to uninstall
13:57:45 <Welkin> /usr/local/bin/ghc is just a symlink to some version of ghc
13:57:59 <Welkin> install a new version of ghc and it will overwrite the symlink
13:58:30 <mauke> .oO( ln -s ghc /usr/local/bin/ghc )
14:03:24 <barrucadu> bb010g: Ah, thanks for reminding me, I need to look into how exactly to do that…
14:05:05 <inininin> Any time I use 'cabal install' I get a 'cabal: No sandbox exists at [...]/.cabal-sandbox' error
14:06:04 <ttt_fff> anyone else wonder, how the F*#$ did I ever program without Lens?
14:06:15 <ttt_fff> geekosaur: is F*#$ acceptable ?
14:06:26 <inininin> What is Lens?
14:06:36 <ttt_fff> I don't know what it fully is
14:06:45 <ttt_fff> but for me, it allows me to get/set deep into complicated data structures
14:06:56 <inininin> Short summary?
14:07:09 <geekosaur> lens is a first class record access mechanism that evolved into a generics package. basically, accessing/modifying deep structures
14:08:02 <inininin> hmm
14:08:05 <geekosaur> ttt_fff, discussion over the weekend seems to be leaning in the direction of "allow but don't overdo it" so I'm now letting stuff pass that has historically not been used here
14:08:17 * hackagebot commutative 0.0.1.3 - Commutative binary operations.  https://hackage.haskell.org/package/commutative-0.0.1.3 (athanclark)
14:08:28 <bennofs> lens is like jquery for haskell datatypes describes it best IMO
14:08:42 <edwardk> lens is a library that provides something like a principled form of jquery for haskell data types. It was designed by a crazy person and a cadre of folks who see fit to enable his delusions of granduer.
14:08:50 <geekosaur> :)
14:09:02 <inininin> so very useful, tx
14:09:39 <cocreature> inininin: sounds like you have require-sandbox: True in your ~/.cabal/config (or whatever this option is called) and you are running cabal install from outside a sandbox
14:09:40 <ttt_fff> geekosaur: alright, I will accept that as a peace treaty and stop msgs of the form "geekosaur: is <WORD> banned" ?
14:09:46 <edwardk> it is alternately either the coolest thing folks have ever seen or the worst thing that has happened to haskell. there is very little room for middle-ground opinions
14:10:06 <hpc> nah, the worst thing to happen to haskell is acme-php
14:10:21 <ttt_fff> edwardk: I wish you knew how to use literate haskell.
14:10:31 <ttt_fff> edwardk: think about how much everyone could learn if your code were wrntte in lhs format
14:10:35 <edwardk> i know how to use literate haskell. i just don't like it
14:10:52 <hpc> it's just backwards commenting
14:11:06 <hpc> code starts with "> " instead of non-code starting with "-- "
14:11:11 <quchen> edwardk: It's tremendously useful but you pay a hefty price for it, namely losing the guidance by the types. I think that's sort of a middle ground opinion.
14:11:32 <edwardk> quchen: that pretty much mirrors my thinking
14:11:40 <hpc> quchen: agreed
14:12:02 * athan accepts the challenge
14:12:05 <athan> edwardk: What about runtime template haskell via unsafeCoerce?
14:12:09 <edwardk> i wish i could get away with less drastically complicated type errors, but i don't know how to derive the same functionality and expose less in the types
14:12:23 <athan> erm unsafePerformIO ><
14:12:37 <edwardk> athan: i have a chunk of code that uses template haskell to generate a ton of haskell code that basically consists of a gigantic pile of unsafeCoerces. ;)
14:13:09 * athan 's eyes water
14:13:10 <ttt_fff> quchen / edwardk: how do you 'losing the guidance by the types' ?
14:13:31 <edwardk> ttt_fff: the main issue with lens is that the type errors when you screw it up are horrendously complicated
14:13:35 <mauke> :t view
14:13:36 <lambdabot> MonadReader s m => Getting a s a -> m a
14:13:47 <mauke> also known as "WTF is this thing doing"
14:13:48 <quchen> ttt_fff: You can't read a lens type and think "putting that together with that makes that". You have to know some other way. (If you make a mistake, you still get an error, but it's often an unhelpful one.)
14:13:51 <edwardk> i freely admit that that was a large part of what i gave up to get power
14:13:55 <edwardk> :t confusing
14:13:56 <lambdabot> Applicative f => LensLike (Data.Functor.Kan.Rift.Rift (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
14:14:06 <edwardk> :t confusing both
14:14:07 <lambdabot> (Applicative f, Data.Bitraversable.Bitraversable r) => LensLike f (r a a) (r b b) a b
14:14:09 <bennofs> mauke: there are simpler types in the docs :)
14:14:32 <quchen> Plus lens exhausts all the synonyms for "zooming" and all optical instruments are there too.
14:14:34 <mauke> module Data.Lens.Plano where glass = id
14:14:58 <quchen> And there are *plenty* of definitions like "confusing".
14:14:59 <quchen> :t alongside
14:15:00 <lambdabot> LensLike (Control.Lens.Internal.Getter.AlongsideLeft f b') s t a b -> LensLike (Control.Lens.Internal.Getter.AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
14:15:07 <quchen> Useful, but there are so many of them it's hard to keep track.
14:15:43 <quchen> But on the other hand, by using lens, you get, you know, to use lens :-D
14:15:56 * bennofs never used alongside
14:16:04 <mniip> edwardk: [22:13:21] <mniip> edwardk, so if I've derived the nature of lenses as 'Functor f => (a -> f b) -> s -> f t', where get uses f~Const a, and over uses f~Identity
14:16:12 <mniip> how would I derive other structures from that approach
14:16:21 <barrucadu> bb010g: I've opened an issue on the `irc` package (which irc-conduit uses for parsing messages) regarding Stackage, will see what the author says.
14:16:57 <edwardk> mniip: that characterizes a lens pretty well. to handle traversals is trickier. you need to pick f ~ Bazaar a b
14:17:49 <bennofs> mniip: for Traversals, just replace Functor f with Applicative f and see what you get 
14:18:12 <mniip> now, what's a Bazaar
14:18:18 * hackagebot resistor-cube 0.0 - Compute total resistance of a cube of resistors  https://hackage.haskell.org/package/resistor-cube-0.0 (HenningThielemann)
14:18:26 <eikke> edwardk: sorry if you replied before and I missed it, but: is there anything wrong with 'CatchT (ST s)', given the warning about not layering on top of IO?
14:18:28 <bitemyapp> mniip: it's bizarre
14:18:44 <bennofs> bitemyapp: isn't bizarre the indexed form?
14:18:50 <bitemyapp> I was joking dammit
14:18:55 <bitemyapp> of course something is called bizarre
14:19:01 <bitemyapp> bennofs: :)
14:19:10 <geekosaur> lens ran out of names :)
14:19:18 <bennofs> mniip: http://www.twanvl.nl/blog/haskell/non-regular1 is perhaps an easier encoding of the same type
14:19:31 <bennofs> mniip: it's a fun type
14:19:48 <edwardk> bizarre was a pun on bazaar, which the method was used to work with
14:19:57 <bennofs> mniip: Bazaar in lens is a bit more general (it has three arguments)
14:20:11 <edwardk> ok, lets build Bazaar up by thinking about lenses first
14:20:32 <edwardk> data Store s a = Store (s -> a) s
14:20:46 <inininin> cocreature: looks like that was it. I initialized a sandbox and tried again and it worked fine
14:21:01 <edwardk> can be rephrased as newtype Store s a = Store (forall f. Functor f => (s -> f s) -> f a)
14:21:18 <edwardk> if we replace Functor in it with Applicative, we get the building blocks that make Bazaar go
14:21:43 <edwardk> newtype Bazaar s a  = Bazaar (forall f. Applicative f => (s -> f s) -> f a)
14:21:58 <edwardk> russell o'connor calls it the cartesian store comonad, or the kleene store
14:22:05 <geekosaur> (so is there a Cathedral?)
14:22:09 <edwardk> now, i need it indexed
14:22:28 <edwardk> newtype Bazaar a b t = Bazaar (forall f. Applicative f => (a -> f b) -> f t)
14:22:34 <mniip> edwardk, wait wait wait
14:22:37 <mniip> what's Store
14:22:39 <edwardk> and then i need to allow for 'indexed traversals'
14:22:51 <mniip> more specifically, what does it represent
14:22:52 <edwardk> newtype Bazaar p a b t = Bazaar (forall f. Applicative f => p a (f b) -> f t)
14:23:02 <edwardk> you know the state monad?
14:23:06 <edwardk> store is the costate comonad
14:23:09 <mniip> oh
14:23:19 <mniip> (s, s -> a)
14:23:31 <edwardk> (s -> a, s)  -- is an 'experiment' (s -> a) you want to run, and a state you can run it in
14:23:38 <edwardk> so you can extract by feeding the function s
14:23:51 <edwardk> or you can modify your "position" s and extract from there
14:24:13 <edwardk> if s = Int, then this is basically a number line where you know where you are and know an value for each Int
14:24:19 <edwardk> so you can compute relative reads, etc.
14:24:29 <bitemyapp> athan: why isn't it Vector of Vector?
14:24:33 <edwardk> s = (Int,Int) you know where you are on a plane, and have a value for each location
14:24:56 <mniip> duplicate (Store f x) = Store (Store f) x
14:25:00 <mniip> fancy
14:25:14 <edwardk> blur (Store f (x,y)) = (f (x+1,y) + f(x-1,y) + f(x,y+1) + f(x,y-1)) / 4
14:25:21 <mniip> I'm not sure what's the rationale behind it, but okay
14:25:24 <edwardk> blur :: Store (Int,Int) Double -> Double
14:25:35 <edwardk> now 'extend blur' will blur the entire image
14:26:13 <edwardk> the store comonad lets you extend a computation that produces the value at any given point to one that gives you a whole new mosaic tiled out of the answers to your function
14:26:36 <mniip> hmm
14:26:44 <edwardk> :t Control.Comonad.Store.pos
14:26:45 <lambdabot> Control.Comonad.Store.Class.ComonadStore s w => w a -> s
14:26:49 <edwardk> :t Control.Comonad.Store.peek
14:26:50 <lambdabot> Control.Comonad.Store.Class.ComonadStore s w => s -> w a -> a
14:26:55 <edwardk> :t Control.Comonad.Store.seek
14:26:56 <lambdabot> Control.Comonad.Store.Class.ComonadStore s w => s -> w a -> w a
14:27:01 <mniip> so a value with the context of how it was generated, so that you can generate more values?
14:27:15 <edwardk> i have an article that uses it heavily
14:27:23 <mniip> okay
14:27:31 <edwardk> https://www.fpcomplete.com/user/edwardk/cellular-automata
14:30:24 <mniip> edwardk, pop context
14:30:31 <mniip> Bazaar
14:30:50 <edwardk> anyways, Bazaar is like having a lot of little stores.
14:31:05 <edwardk> you have some countable number of them... hence the name
14:31:14 <mniip> each with a different function?
14:31:17 <edwardk> its easy to add more stores to a bazaar
14:31:21 <edwardk> not so much
14:31:24 <edwardk> think of a traversal
14:31:26 <edwardk> :t traverse
14:31:27 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:31:28 <edwardk> :t flip traverse
14:31:30 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
14:31:47 <mniip> I'm confused
14:31:50 <edwardk> flip traverse :: Traversable t => t a -> Bazaar a b (t b)
14:32:00 <edwardk> with a newtype added
14:32:11 <edwardk> its a partially applied Traversal
14:32:23 <mniip> what does that type have to do with multiple stores
14:32:58 <edwardk> lets look at a lens for a sec
14:33:25 <edwardk> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t       or Lens s t a b = s -> (a, b -> t)
14:33:28 <edwardk> each of these views has merit
14:33:43 <edwardk> if we flip the former we get s -> forall f. Functor f. (a -> f b) -> f t
14:34:02 <edwardk> which is isomorphic to s -> (a, b -> t)     as both definitions characterize a lens
14:34:24 <mniip> it is?
14:34:38 <edwardk> proving that is non-trivial and non-obvious
14:34:57 <mniip> sounds like proof implies going where we came from
14:34:58 <edwardk> but you can use Identity and Const to prove that you can extract both sides of the pair
14:35:15 <edwardk> and you can prove that this characterizes a lens
14:35:35 <jle`> the proof is fun
14:35:48 <edwardk> when we go to define a traversal we get into a pickle. if we write out the way to characterize walking a traversal as an ADT we get stuck in some infinite cases
14:36:38 <edwardk> data FunList a b = Done b | More a (FunList a (a -> b))   -- is almost good enough
14:36:55 <edwardk> but it isn't lazy enough
14:37:11 <edwardk> so there we _have_ to use the forall f. Applicative f => (a -> f b) -> f t  encoding
14:37:22 <edwardk> otherwise we can't deal with any infinite traversals
14:37:29 <mniip> hold on
14:37:41 <yashinbasement> Hi there I am just not clear at this statement data Card = Card Suit Rank
14:38:06 <yashinbasement> where Rank is data Rank = R1 | R2 | R3 | R4 | JacK | Queen | King | Ace
14:38:06 <edwardk> yashinbasement: that is defining a data type Card with a single constructor Card :: Suit -> Rank -> Card
14:38:15 <jle`> yashinbasement: what part is confusing you? :)
14:38:46 <edwardk> with that then you can work with something like       Card Hearts King :: Card
14:38:51 <edwardk> and that defines a value of type Card
14:39:23 <yashinbasement> yeah it says Card  = Card Suit Rank , so we are defining Card from Card, or it just a notation which is confusing me
14:39:36 <edwardk> yashinbasement:  there is a distinction to be made here
14:39:44 <yashinbasement> like
14:39:46 <edwardk> data Card = Whatever Suit Rank
14:39:56 <mniip> edwardk, ohhh
14:39:57 <edwardk> Whatever is the name of the data constructor at the term level.
14:40:06 <yashinbasement> so what is Card on rhs
14:40:07 <edwardk> Card is the name of the type constructor at the type level
14:40:13 <mniip> FunList is a pretty fancy type
14:40:17 <edwardk> its clearer when they dont pun and use the same name
14:40:18 <mauke> data This_is_the_type = This_is_the_data_constructor ... | This_is_another_data_constructor ... | ...
14:40:29 <edwardk> mniip: the first time i saw it was http://twanvl.nl/blog/haskell/non-regular1
14:40:31 <mniip> like Store but curried partial application
14:40:39 <hpc> data Bool = False | True -- more clear example
14:40:51 <jle`> yashinbasement: maybe you can wrote data Card = C Suit Rank
14:41:11 <yashinbasement> why is that, cons name does not matter
14:41:13 <edwardk> mniip: yep. sadly it can't handle infinite traversals. if i gave you an infinite list and you tried to traverse and edit it with FunList you'd fail to productively produce the result list
14:41:17 <jle`> yashinbasement: so Card is the type, and C is the constructor
14:41:28 <jle`> so if you had data Card = C Suit Rank
14:41:34 <jle`> then you can have C Heart King :: Card
14:41:46 <jle`> if you had data Card = Foo Suit Rank, you can have (Foo Heart King :: Card)
14:41:48 <mauke> there's the data Foo = MkFoo ... convention
14:41:50 <jle`> you can name the constructor whatever you want
14:42:02 <yashinbasement> fair enough 
14:42:06 <jle`> and you use what you named to constructo ro deconstruct
14:42:06 <edwardk> yashinbasement: terms and types are separate namespaces. data Foo = Bar Baz Quux.   Foo is a type, Bar is a term, Baz and Quux are types.
14:42:57 <edwardk> since they are separate namespaces nothing prevents you from picking Bar to be Foo. data Foo = Foo Baz Quux
14:43:18 * hackagebot twilio 0.1.3.0 - Twilio REST API library for Haskell  https://hackage.haskell.org/package/twilio-0.1.3.0 (andrus)
14:44:13 <yashinbasement> different namespace did you mean for type name  and  constructor 
14:44:21 <mniip> edwardk,  what's traverse got to do with any of this
14:45:24 <geekosaur> yashinbasement, you can't use a type or type constructor name where a data constructor name can be used, or a data constructor name where a type or type constructor name can be used
14:45:28 <ski> yashinbasement : for type constructor and data constructor, yes
14:45:43 <geekosaur> so the compiler cant be confused by data Foo a = Foo a, but the reader of the program can
14:46:17 <deepfire> it seems pretty crazy that GHC.Typelits is such a simple-looking kind of code..
14:46:44 * ski prefers the idiom `data Foo ... = MkFoo ...' (or something similar), if no other more sensible data constructor name suggests itself
14:46:46 <edwardk> well, if we make FunList fancier to have 3 parameters rather than two
14:47:15 <athan> Is there such a thing as a stateful map? Something like `map f xs = zip xs [0..]`
14:47:18 <yashinbasement> wait I am lost with data and type constructor , so when we write data t = blah..., t is a type constructor ?
14:47:20 <edwardk> data FunList a b t = Done t | More a (FunList a b (b -> t))
14:47:52 <edwardk> then you can write a combinator that does      Traversable t => t a -> FunList a b (t b)
14:48:07 <prsteele> yashinbasement: data TypeName = TypeConstructor 1 | TypeConstructor2 | ...
14:48:12 <geekosaur> yashinbasement, type construuctor left of = in "data", data constructor to the right of =
14:48:19 <mniip> edwardk,  I'll need to think about that one
14:48:25 <edwardk> and the FunList basically contains all the 'a's in the original structure, and a process that when all of them are converted to b's will let you build a 't b'
14:48:36 <geekosaur> prsteele, um? data constructors, not type constructors
14:48:50 <prsteele> geekosaur: ya that was a horrible typo sorry
14:49:15 <prsteele> really just meant to say Constructor1 | Constructor2 | ...
14:49:20 <geekosaur> data Maybe a = Nothing | Just a -- Maybe is type constructor, Nothing and Just are data constructors
14:49:37 <yashinbasement> right
14:49:43 <geekosaur> meaning you can use Nothing or Just 5 as values, but Maybe Int is a type (there are no values named Maybe 5)
14:49:59 <geekosaur> and Just Int is not a valid type
14:50:49 <yashinbasement> thanks guys !
14:52:30 <yashinbasement> so here to confirm data Card = Card Rank Suit , first Card is a type constructor while second card is a data constructor
14:52:41 <mniip> edwardk, grokked
14:53:05 <jle`> yashinbasement: yup
14:53:05 <edwardk> mniip: anyways the problem comes in when you go to traverse an infinite list
14:53:07 <edwardk> the types check
14:53:13 <edwardk> but you never start producing the result list
14:53:24 <edwardk> there is always more lambda to get through, more more constructors to get past
14:53:24 <jle`> yashinbasement: people always like to say "always use different names for your type constructors and data constructors"
14:53:28 <jle`> but in practice it happens all the time
14:53:33 <edwardk> you never get to the point where you start producing the output list
14:53:35 <yashinbasement> haha
14:53:40 <jle`> i guess it's one of those best practices that everyone likes to say but nobody follows, heh
14:53:46 <edwardk> whereas with the (a -> f b) -> f t  approach we can be productive
14:54:03 <edwardk> this is the key to making many of the combinators in lens work in the infinite cases
14:54:04 <jle`> even in base there are several
14:54:11 <deepfire> jle`: there must be a reason for that..
14:54:35 <yashinbasement> to confuse people ?
14:54:37 <edwardk> these are the sorts of things we take upon ourselves on behalf of our users, because almost none of them would be able to figure out how to make 'taking' work on an infinite traversal without a couple of days of effort
14:54:43 <edwardk> it took us weeks to get those right
14:54:51 <jle`> i think the advice is just meant to make things less confusing for new people/newcomers
14:54:55 <edwardk> > [1..]^..taking 10 traverse
14:54:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
14:54:58 <jle`> but after a while the ambiguity gets less disruptive
14:55:04 <edwardk> > [1..] & taking 10 traverse +~ 1
14:55:06 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:55:11 <jle`> so we stop caring once we understand
14:55:17 <NeverDie> will someone be my haskell sensei
14:55:18 <edwardk> those two were quite tricky to get to work correctly in lens
14:56:17 <edwardk> NeverDie: Just hanging out in here and talking to folks is a pretty good way to turn into the Haskell equivalent of History's Strongest Disciple Kenichi.
14:56:21 <deepfire> jle`: this oddly meshes with DataKinds..
14:56:48 <jle`> ah, i never realized that
14:56:57 <prsteele> NeverDie: this channel is very helpful
14:57:09 <jle`> i've never really used DataKinds for things with one constructor
14:57:14 <jle`> but i know people that do
14:57:28 <jle`> i wonder if it ever messes anything up
14:57:35 <NeverDie> Hmm.
14:57:45 <NeverDie> I've always lurked around here but never entirely made the leap.
14:57:48 <deepfire> jle`: there's actually a disambiguation for that, so it doesn't seem to
14:58:24 <jle`> yeah, testing it out in ghci it seems to be resolved unambiguously
14:58:31 <jle`> but still, i can see it being confusing
14:59:40 <jle`> data Foo = Foo makes only a type Foo :: *, but data Foo = Foob makes a type Foo :: * and a type Foob :: Foo
14:59:44 <deepfire> the first time I saw it, I was completely sure the promoted-to-type will be inhabited by the values composed by the corresponding constructor
15:00:17 <jle`> does data Foo = Foo make a kind Foo too?
15:00:37 <jle`> i don't even know how to test this out on ghci
15:00:40 <eikke> jle`: with DataKinds, you get 'Foo yes
15:00:47 <jle`> oh yeah, the apostrophe
15:01:07 <eikke> you can leave out the ' although I think that's turned into a warning now
15:01:29 <jle`> i always leave off my 's, heh
15:01:48 <deepfire> http://downloads.haskell.org/~ghc/7.10.2/docs/html/users_guide/promotion.html#promotion-syntax
15:01:49 <jle`> so i guess data Foo = Foo and data Foo = Foob do the same thing, except the Foo :: Foo is only accessible with the apostrophe syntax
15:02:03 <jle`> the 'Foo :: Foo
15:02:20 <jle`> i should have known this already because I always use '[Int] when I can't use [Int]
15:02:21 <eikke> jle`: I don't think 'Foo :: Foo makes sense
15:02:31 <eikke> 'Foo is a kind, can't have type Foo
15:02:41 <jle`> 'Foo is the type
15:02:44 <jle`> it has kind Foo
15:02:52 <jle`> for data Foo = Foo
15:03:27 <jle`> i was just doing '[Int] to disambiguate from [Int] last night heh, I guess I should have remembered
15:03:43 <deepfire> ' is for accessing type-of-a-promoted-constructor
15:03:49 <eikke> edwardk: any opinion on the CatchT/ST question?
15:04:50 <ski> store comonad is sometimes referred to as "state-in-context"
15:05:37 <yasha0x80> .
15:11:38 <d-snp> anyone know a cabal file example that allows me to have stacktraces?
15:11:48 <d-snp> ghc is being totally crazy about this
15:12:09 <d-snp> in the same output it both says -prof is not necessary and required
15:12:13 <slaterr> s
15:13:20 * hackagebot streaming 0.1.0.6 - A free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.6 (MichaelThompson)
15:13:28 <slaterr> how can I get this to work? http://lpaste.net/139029
15:14:11 <slaterr> crap, I missed the message about IncoherentInstances
15:14:38 <slaterr> no, still does not work.. help wanted once again :)
15:14:47 <jle`> does lambdabot have a ski plugin?
15:15:02 <johnw> slaterr: I'm not sure that the best way to go about that
15:15:28 <johnw> better to encode your infinitely-recursive lists as a type, rather than trying to relying on inference like this.  You'll have huge problems down the road of other kinds.
15:15:35 <bennofs> @quote ski
15:15:35 <lambdabot> ski says: death or glory !
15:15:39 <johnw> try: type LispList a = Free [] a
15:15:52 <jle`> i mean a way to translate a function into ski calculus formulation, heh
15:15:59 <johnw> it's easy to write the kind of 'show' you want for that (and use a newtype so it can have its own instance of Show)
15:16:14 <mniip> jle`,  mniip has a ski plugin
15:16:34 <jle`> mniip: @ski \x -> x
15:16:36 <mniip> :)
15:16:41 <mniip> SKK
15:17:04 <jle`> @ski \x y z -> x z y
15:17:04 <lambdabot> Maybe you meant: wiki src ask
15:17:49 <bennofs> ski plugins only work in winter :p
15:18:01 * ski doesn't ski
15:18:10 <mniip> hmm gimme a minute
15:18:21 <jle`> or on years 4x+2, x in N
15:18:58 <slaterr> johwn how would I encode it as a type? I don't quite get what you mean by that
15:19:14 <johnw> newtype LispList a = LispList { getLispList :: Free [] a }
15:19:22 <d-snp> I'm going crazy guys, how can there be literally 0 information about how to get stacktraces in haskell?
15:19:27 <d-snp> do you never use stacktraces?
15:19:29 <johnw> you're trying to infer multiple levels of [[[[a]]]], etc., using the instance resolution mechanism
15:19:38 <jle`> @import Control.Monad.Free
15:19:38 <lambdabot> Unknown command, try @list
15:19:44 <jle`> @let import Control.Monad.Free
15:19:45 <lambdabot>  <no location info>:
15:19:45 <lambdabot>      The package (profunctors-5.1.1) is required to be trusted but it isn't!
15:19:52 <jle`> prfunctors is so shady
15:19:52 <johnw> but in your case, two different LispList a => a types will be incompatible
15:19:58 <Intolerable> @let import Control.Monad.Trans.Free
15:19:59 <lambdabot>  <no location info>:
15:19:59 <lambdabot>      The package (exceptions-0.8.0.2) is required to be trusted but it isn't!
15:20:10 <byorgey> d-snp: Haskell's evaluation model doesn't even use a stack in the same way you would think about for, e.g. C
15:20:15 <jle`> profunctors is so shady
15:20:40 <byorgey> so a "stack trace" would look very different, it would give you evaluation contexts instead of calling contexts, which is a lot less useful
15:21:11 <jle`> @let data Free f a = P a | F (f (Free f a)) deriving (Show, Eq, Functor)
15:21:12 <lambdabot>  .L.hs:153:25:
15:21:13 <lambdabot>      No instance for (Show (f (Free f a)))
15:21:13 <lambdabot>        arising from the first field of ‘F’ (type ‘f (Free f a)’)
15:21:17 <ReinH> byorgey: it gives you cost centers iirc
15:21:18 <ski> jle` : `S (S (K S) (S (K K) (S (K S) I))) (K (S (K K) I))' for the latter, if i made no mistake
15:21:28 <jle`> thank you ski for the ski
15:21:35 <jle`> @let data Free f a = P a | F (f (Free f a))
15:21:36 <ReinH> d-snp: I think you compile with profiling and set RTS options to -xc
15:21:36 <lambdabot>  Defined.
15:21:45 <ReinH> byorgey: Or cost centres, depending.
15:21:45 <d-snp> ReinH: yes that's what I'm trying to do
15:21:50 <bennofs> @quote stack traces
15:21:50 <lambdabot> No quotes for this person. Do you think like you type?
15:21:53 <jle`> @let deriving instance Show (f a) => Show (Free f a)
15:21:54 <lambdabot>  .L.hs:154:1:
15:21:54 <lambdabot>      Could not deduce (Show a) arising from a use of ‘showsPrec’
15:21:54 <lambdabot>      from the context (Show (f a))
15:21:54 <ski> (possibly it could be optimized more)
15:21:54 <bennofs> @where stacktraces
15:21:55 <lambdabot> I know nothing about stacktraces.
15:21:55 <d-snp> but it does not work
15:21:56 <slaterr> johwn I have no idea what you mean.. but that is ok, I got it working! I just had to change signature of lprint from "lprint :: LispShow a => [a] -> IO ()" to "lprint :: LispShow a => a -> IO ()"
15:22:12 <slaterr> which is what I meant to write.. but error message threw me off
15:22:22 <ReinH> d-snp: what are you trying?
15:22:29 <joncol> Too tired to think straight right now, can anyone tell me how to combine two attoparsec parsers? For instance a hard coded string "abdra " followed by some other strings? That is, I want the result to include "abra "...
15:22:53 <ReinH> Should be "-with-rtsopts=-xc"?
15:23:33 <d-snp> Warning: 'ghc-options: -prof' is not necessary and will lead to problems when
15:23:33 <d-snp> used on a library. Use the configure flag --enable-library-profiling and/or
15:23:34 <d-snp> --enable-executable-profiling.
15:23:44 <ReinH> d-snp: cabal configure --enable-library-profiling or similar iirc
15:24:03 <jle`> > F [P 1, P 2, F [F [P 3, P 4], P 5]] :: Free [] Int
15:24:04 <lambdabot>  F [P 1,P 2,F [F [P 3,P 4],P 5]]
15:24:27 <mniip> jle`,  done
15:24:30 <d-snp> but I'm using stack :(
15:24:49 <mniip> S(K(S(K(SS(KK)))K))S
15:24:51 <d-snp> because cabal won't compile my project at all..
15:24:54 <ReinH> d-snp: oh
15:25:00 <jle`> thank you mniip for the ski
15:25:10 <jle`> is there an actual bot for this somewhere?
15:25:19 <ski> not sure
15:25:21 <jle`> mniip's skibot is not very performant
15:25:23 <jle`> i'm sorry
15:25:27 <mniip> you can do it in your head
15:25:29 <mniip> !
15:25:35 <ski> it's not very hard to write it yourself, e.g. as a fold
15:25:51 <jle`> i have no experience in ski but i guess it might be fun to get started
15:26:07 <kadoban> d-snp: The stack build command has --library-profiling --executable-profiling , etc. Did you try those, or?
15:26:10 <mniip> you eliminate abstractions with eta reduction
15:26:12 <jle`>  @pl is not very useful
15:26:18 <jle`> @pl \x y z -> x z y
15:26:18 <lambdabot> flip
15:26:26 <jle`> whee
15:26:33 <d-snp> kadoban: ah that works thanks
15:26:35 <mniip> and to eta reduce you put the last variable to the last position
15:26:45 <mniip> just gotta learn a few tricks
15:26:48 <sunnymilk> @pl \f a b c d e -> f e d c b a
15:26:48 <lambdabot> flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .) . flip
15:27:05 <mniip> f(g x) = S(K f) g x
15:27:27 <mniip> f x y = S f (K y) x
15:27:34 <ski> jle` : that is aka `C'
15:27:47 <jle`> is C a thing?
15:27:56 <ski> <https://en.wikipedia.org/wiki/B,C,K,W_system>
15:27:58 <jle`> my school's ski calculus class was full
15:28:02 <jle`> so i couldn't enroll
15:28:12 <jle`> i was like 15th on the waitlist
15:28:55 <ReinH> did people think that it involved skiing?
15:29:24 <Welkin> jle`: a whole class on it?
15:29:32 <Welkin> I thought it was just the S and K combinators
15:29:46 <Welkin> I read about it in about 20 minutes
15:29:48 <jle`> the plot twist is that it was an a class about skiing while doing calculus
15:30:06 <jle`> Welkin: well, groups are simple, but group theory is quite involved
15:30:27 <ski> @where mockingbird
15:30:27 <lambdabot> "To mock a mockingbird : and other logic puzzles including an amazing adventure in combinatory logic" by R. M. Smullyan, "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" at <http://dkeenan.com/Lambda/> by David C. Keenan. Also see `smullyan'
15:30:30 <ski> jle` : see ^
15:30:37 <jle`> thank you ski
15:30:49 <jle`> for the tip on ski
15:32:34 <ski> <http://www.angelfire.com/tx4/cus/combinator/birds.html> also seems to have a list
15:38:18 <levi> "The Implementation of Functional Programming Languages" has a chapter on SK Combinators, which is interesting as it's a "practical" approach rather than just a theory overview.
15:39:18 <d-snp> I really like Haskell
15:39:30 <d-snp> but I get the feeling I should just write my own build system from scratch
15:39:43 <d-snp> this makes no sense at all
15:39:45 <johnw> pretty much everyone gets that feeling, it seems
15:39:46 <levi> I'm referring to the 1987 book by Simon Peyton Jones, I think there may be a shorter book or something also by that name.
15:40:14 * eikke never had that feeling
15:40:26 <d-snp> if stack made one mistake it's got to be that it builds on top of cabal :P
15:40:43 <eikke> care to give some specific reasons why?
15:40:46 <levi> I'm used to programming in C; everyone writes a build system from scratch there anyway, albeit using a domain-specific language such as Make.
15:41:04 <d-snp> eikke: oh well I spent the past two hours getting my project to compile on a new system
15:41:18 <kadoban> d-snp: It doesn't build on top of cabal-install, it does build on the Cabal library though.
15:41:23 <kadoban> d-snp: Are you running into more problems?
15:41:37 <eikke> kadoban: I know, was asking d-snp why that's a bad decision
15:41:48 <eikke> oh, wasnt to me, sorry
15:41:52 <d-snp> kadoban: after it compiled with profiling it said this: unexpected RTS argument: xc
15:42:11 <eikke> d-snp: I guess it wants -xc, not xc
15:42:19 <d-snp> yeah I suppose it does
15:42:33 <bennofs> d-snp: why do you think Cabal is bad?
15:42:53 <eikke> d-snp: when using Stack, you can just 'stack build --executable-profiling' or simiilar, and things should work out nicely
15:43:01 * ski . o O ( "An Architecture for Combinator Graph Reduction (TIGRE)" (Ph. D. thesis) by Jr. Phillip J. Koopman in 1992 at <http://users.ece.cmu.edu/~koopman/tigre/index.html> )
15:43:24 <d-snp> bennofs: well most recently because it gave me conflicting info
15:43:30 <d-snp> it doesn't suggest good solutions to problems
15:44:14 <ReinH> ski: TIGRE TIGRE burning bright etc
15:44:26 <d-snp> anyway, I'm probably just not reading error messages right
15:44:51 <bennofs> d-snp: if there's a problem with errror messages, I'm quite sure that the Cabal maintainers are open to improvements when they make sense
15:45:17 <ReinH> Well, you can ask dcoutts ;)
15:45:36 <mniip> jle`, I give up http://imgur.com/SixokSD.jpg
15:46:08 <Hafydd> Have you tried writing a bit smaller and more neatly?
15:46:13 <jle`> mniip: heap overflow?
15:46:39 <mniip> Hafydd, this is a 2mm grid :P
15:46:40 <d-snp> yes! it gave me some stack trace
15:46:44 <d-snp> GHC.Err.CAF
15:46:49 <d-snp> that's all :P
15:47:08 <bennofs> d-snp: compile with -fprof-auto 
15:47:18 <eikke> d-snp: do you compile using -fprof-auto ?
15:47:27 <bennofs> (that's a GHC option, you'll have to pass the correct flag to cabal/stack)
15:47:48 <bennofs> --ghc-option=-fprof-auto is the cabal variant, idk about stack
15:47:50 <eikke> d-snp: put 'Ghc-Prof-Options: -fprof-auto' under the library or executable section(s) in your cabal file, then cabal clean and rebuild
15:48:05 <d-snp> yes
15:48:09 <eikke> bennofs: stack relies on cabal files, nothing specific about it
15:48:10 <d-snp> now it works!
15:48:16 <kadoban> stack has … --ghc-options looks like
15:48:24 <bennofs> eikke: well, but command line options could be different
15:48:26 <eikke> ah yes indeed
15:48:36 <eikke> I never use those, so not thinking of them
15:49:01 <d-snp> bennofs: ok so I think the main problem I have with cabal is that there's no standard 'debug' build mode that enables fprof
15:49:12 <d-snp> or prof or whatever its called that you need to get stacktrace
15:49:32 <d-snp> I think most programming tools by default compile with debugging info
15:49:55 <d-snp> I know certain tools where it's actually harder to do a release build than it is to do a debug build
15:49:57 <geekosaur> debugging info is actually Hard in haskell because it's graph reduction
15:50:04 <bennofs> d-snp: I think GHC recently got support for stack traces without profiling
15:50:07 <geekosaur> there are changes in ghc 7.12 that will help with this
15:50:22 <eikke> yes, using -g (which emits some DWARF symbols)
15:50:23 <bennofs> d-snp: so there's certainly work in that direction
15:50:25 <geekosaur> (part of it is in ghc 7.10 but IIRC not in a usable form yet)
15:50:32 <eikke> geekosaur: idd
15:51:01 <eikke> I think one could argue Cabal should use -fprof-auto by default unless the cabal file specifically disables it
15:51:10 <eikke> (for profiiling builds, obviously)
15:51:16 <d-snp> so, now there's ghc-options -fprof-auto -with-rtsopts=-xc in my cabal file, which is probably going to break if someone tries to compile my project without it being configured for debug
15:51:30 <bennofs> d-snp: make it ghc-prof-options at least
15:51:30 <ReinH> d-snp: you can use a flag or something
15:51:35 <geekosaur> hm, I thought --enable-{,library-,executable-}profiling did add that?
15:51:36 <eikke> d-snp: you can specify -xc at runtime
15:51:41 <eikke> no need to have it in cabal config
15:51:53 <bennofs> d-snp: people will hate you if you do ghc-options: -fprof-auto in a library
15:52:00 <eikke> geekosaur: it creates prof builds, but doesnt auto add ssc's
15:52:00 <d-snp> eikke: if I do it commandline, then I'm here next month asking the same questions again :P
15:52:02 <geekosaur> you need recentish cabal-install for --enable-profiling vs. the separate --enable-library-profiling, --enable-executable-profiling
15:52:07 <levi> GHC builds are complicated by the fact that separate compilation in Haskell has a lot of caveats.
15:54:18 <bennofs> I don't even know why GHC needs to compile dependencies with profiling enabled too to do profiling
15:55:07 <eikke> bennofs: I dont know, but might be slightly different calling convention, using one reg to manage the profiling info efficiently?
15:57:08 <d-snp> perhaps it wouldn't be able to trace past external functions then
15:58:02 <jp_rider> hi, does anyone have experience with ghc-ios? i'm running into some issues installing aeson as a dependency (http://lpaste.net/7956551478481518592)
15:58:19 <bennofs> d-snp: i don't exactly understand that though. Afaik, GHC just generates code to push / pop the cost centre stack when it enters / leaves functions with {-# SCC #-} annotations. But if there is no cost centre annotation, it shouldn't need extra code. Perhaps it's for heap profiling
15:58:39 <levi> GHC modules, despite high-level separation, tend to get inlined and specialized within the code of other modules.
15:59:24 <bennofs> levi: yes, but if I compile my application, it's guarranted that no code of that application is inlined in my dependencies, since my application is the root of the dep tree
15:59:58 <eikke> bennofs is saying we need LTO :-P
16:02:22 <d-snp> hah, after all that work, it crashes at a different place than I wanted the stacktrace, because I'm on a different OS and it's got other typedefs :P
16:03:56 <levi> Cost-center profiling apparently involves some extensive differences in how the compiler does things: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Profiling
16:05:11 <bennofs> levi: most of these seem local to the place where cost centres are inserted though
16:05:29 <levi> eikke: GHC has extensive link-time optimization, which is part of what makes non-sandboxed builds so troublesome.
16:06:14 <eikke> levi: huh? I thought all optimizations (like inlining) are compile-time rather than link-time?
16:06:39 <eikke> (where compile-time causes the veryy same troubles)
16:07:40 <arahael> Profiling is surely not an optimisation.
16:07:57 <arahael> making _use_ of profiling data, on the other hand, is very much an optimisation.
16:08:18 <levi> eikke: There's not a solid dividing line anymore when you're doing link-time optimization.
16:08:20 <eikke> arahael: sure, thats not claimed :)
16:08:50 <eikke> levi: remains my question: is GHC doing that?
16:08:58 <arahael> Cool. :)
16:09:13 <levi> It involves distributing some sort of preprocessed version of the source along with the library binary and then using that for inlining and specialization.
16:09:14 <eikke> I really thought it does .hs -> .o (compiling), then later on simply calling ld to link those .o's and the RTS into an executaable
16:09:22 <levi> And yes, GHC does that extensively.
16:09:52 <eikke> and source/inlineable versions remain in .hi
16:10:24 <eikke> where .hi's of dependent modules are used in the .hs -> .o process
16:10:47 <bennofs> eikke: yes, that's how it works
16:10:56 <eikke> which seems like fairly distinct compilation and link phases to me
16:10:58 <lamefun> Is there a way to automate annoying code that can generate doc comments and Template Haskell templates?
16:11:45 <bennofs> lamefun: so you want to use template haskell to generate functions for usage with template haskell? :O
16:12:52 <lamefun> bennofs, I have this pattern going on: http://lpaste.net/6354820747734548480 ("TextLine" found 20 times)...
16:13:06 <levi> eikke: Linking traditionally involves combining a bunch of .o into an executable. If there's .hs or .hi involved, then you're mixing in some compilation with the linking; i.e. some of the exports from the library are recompiled rather than just linked.
16:13:15 <lamefun> I might get even worse if I want more instances for my text wrappers.
16:13:30 <eikke> levi: my point is they're not
16:13:35 <bennofs> levi: well, in the .o -> executable step, no hi is involved afaik
16:14:01 <lamefun> bennofs, I'll probably have more of them, and they'll only differ in doc string, name and condition.
16:14:05 <eikke> levi: 2 phases: (.hs + .hi of deps) -> (.o and .hi) for every module, then all .o -> executable in the secondd phase, no more .hi (or inlining etc) involved
16:14:19 <bennofs> lamefun: I don't think you need all the mkTextLineTH functions if you also have mkTextLine
16:15:06 <lamefun> mkTextLineTH fails at compile time if it gets a multi-line text.
16:15:59 <bennofs> lamefun: but I think there's a generic way to use mkTextLine to build a compile-time validator
16:16:54 <bennofs> lamefun: perhaps you can also use http://hackage.haskell.org/package/refined-0.1.0.0/docs/Refined.html ?
16:17:14 <bennofs> lamefun: or just write a Haskell script to generate the file and run it as part of your build process :I
16:18:02 <lamefun> is there some kind of power preprocessor?
16:18:09 <lamefun> eg. like Wesnoth's WML preprocessor
16:18:27 <levi> eikke: My point is that it's essentially the same sort of thing whether the compiler does it while building the main build product or whether the linker re-invokes the compiler as a final linking step.
16:18:46 <eikke> bennofs: thats an interesting packages, though the type of 'validate' is a bit odd
16:19:58 <eikke> levi: right, i see your point and indeed makes sense
16:20:00 <levi> eikke: The intermediate-code from the libraries gets re-compiled and linked in somewhere rather than just calling the pre-compiled and exported symbols from the library .o in either case.
16:21:10 <kooddllee> Is there some sort of type-level fold?
16:21:24 <eikke> actually, thinking about it, i wonder why what's in .hi isnt put in the .o in some vendor-specific sections
16:21:48 <levi> It's a little bit of whole-program optimization in a separately-compiled world. Which is great for performance, but it complicates build systems and increases build times.
16:23:59 <jle`> kooddllee: in what way?
16:24:43 <levi> eikke: GCC puts its 'GIMPLE' bytecode into the ELF .o files it generates when configured to support LTO. GHC could potentially do the same, but I imagine it was just easier to keep them separate.
16:25:01 <eikke> levi: I'm aware ;)
16:25:43 <kooddllee> jle`: I sort of figured it out using Proxy, but basically I have a heterogeneous and I want to write a type signature for a function that combines all of the values into one big type 
16:25:56 <kooddllee> heterogeneous collection*
16:25:57 <eikke> been experimenting with GHC with -fllvm and Clang-compiled C to get some C routines inlined in the FFI callouts, but didnt work out :(
16:26:24 <levi> I'm not sure if it still does, but GHC used to have its own linker implementation. I don't imagine anyone really relished working on that.
16:26:49 <sgronblo> Any idea why google seems to link to some ancient versions of Hackage libraries even though they seem to properly specify canonical paths?
16:27:05 <eikke> levi: I thought that linker is only used for ghci and some specific platforms, not in general to build executables
16:27:23 <levi> Probably so!
16:36:05 <d-snp> yes, actually got a feature in!
16:36:17 <d-snp> that's enough progress for the night :P good night :)
16:36:44 <kooddllee> can I install binary tools such as ghc-mod using stack?
16:36:59 <Axman6> yes
16:37:07 <Axman6> just stack install ghc-mod
16:37:17 <kooddllee> hmm.. that failed for me when I tried
16:38:09 <kooddllee> 'cabal-helper: needed (==0.5.* && >=0.5.1.0), latest is 0.5.1.0, but not present in build plan'
16:40:17 <Axman6> you need to use a stack.yaml file, and specify the exact version in extra-deps then
16:40:50 <kooddllee> Axman6: ah, yeah got it
16:44:11 <levi> eikke: .hi files have apparently been around for a very long time, as they're not just for LTO purposes. In fact, I think the primary purpose is for cross-module type checking. I think ML compilers have also done something similar for an even longer time.
16:44:55 <eikke> levi: sure, but you could encode the type info in the .o as well, right
16:45:14 <eikke> indeed the ocaml compiler at least uses something similar (.cmi IIRC)
16:45:33 <levi> C compilers have only started sticking intermediate representations into .o files somewhat more recently, though, and the world of library formats has become a lot simpler since the early days of ML.
16:46:14 <levi> Even so, you have to do it differently for MACH-O and ELF, etc.
16:46:57 <levi> If you've had a history of creating an extra file, why burden yourself with extra mucking around with platform-specific linker details?
16:47:08 <viszu1> Is there a way to get length of big list without blowing up my memory ?
16:47:22 <arahael> viszu1: You mean, like an infinite list?
16:47:30 <Rembane> viszu1: If you save it in another expression.
16:47:54 <johnw> @src length
16:47:54 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:48:01 <johnw> length shouldn't need the list to be in memory
16:48:04 <Welkin> lol
16:48:18 <viszu1> I have a list of words like 2 mils of them, and even when I take only 500k and try to get length of them my memory usage goes up by 500 megs
16:48:31 <johnw> you must be doing something else with the list at the same time
16:48:38 <zachk> are you doing anything else to the list?
16:48:40 <eikke> levi: I don't know mach-o, but I guess you could have some mach-o compatible bootstrap code which maps in elf sections embedded in/apppended to the mach-o executable and then jumps into them, or so :P
16:49:32 * zachk guesses viszu1 might be using something from the List monad to do a part of a computation
16:50:22 <levi> eikke: I'm sure you could, but if you already have a convention that there's a separate serialized interface file, why go through the trouble?
16:57:09 <eikke> toying with viszu1's question, /me just found out genericLength can stack overflow in ghci becaus it's not tailrec and implemented recursively, pffff
16:57:27 <viszu1> http://lpaste.net/139034 if i remove "take 500000" on line 9 and try to compute length (line 10) on entire list (like 2,5 mils words) memory usage will go crazy
16:57:55 <viszu1> this is not my program btw I'm just playing with it
16:58:24 <eikke> viszu1: you re-use words on line 11
16:59:06 <eikke> so even though length on line 10 doesnt need to keep the llist in memory strictly speaking, it cant be GC'ed because it's still required (by line 11)
16:59:17 <viszu1> it's word not words
16:59:35 <slaterr> ,1
16:59:40 <eikke> viszu1: word = words !! n
17:00:13 <viszu1> ok, so how do I fix it ?
17:00:13 <eikke> sure looks like 'words' to me
17:00:41 <levi> eikke: Be careful with your reasoning about tail recursion in Haskell; non-strict evaluation means that tail recursion doesn't give you the same operational behavior as in a strictly evaluated language.
17:00:58 <eikke> couple of options. one would be to open the file, count the length, close file, reopen, and look for the word you want
17:01:14 <eikke> viszu1: but a bettter approach, iMHO, would be to use a different algorithm
17:01:58 <eikke> viszu1: e.g. just open the file, fstat it to find its size, calculate a random byte offset, then search forwards from that offset to a newline or beginning-of-file, and then read a line
17:02:18 <eikke> viszu1: using that mechanism you never need to read the whole file at all, reducing IO andd CPU usage massively
17:02:53 <eikke> levi: sure
17:04:01 <slaterr> does list monad serve any practical purpose? why would you use >>= over concatMap? or do over list comprehensions
17:04:43 <glguy> Because you already had code that worked over an arbitrary Monad and you wanted to use it in a list context
17:04:45 <Hijiri> do notation might be neater
17:04:55 <viszu1> eikke: thank you, I will try to decode what you said, and play with it :)
17:05:17 <Rembane> slaterr: Like Maybe on steroids.
17:05:27 <jle`> slaterr: you can use mapM and other functions polymoprhic over Monad m
17:05:48 <jle`> slaterr: look in Control.Monad for some functions polymorphic over Monad m that you can use with list that you can't do with concatMap
17:06:04 <jle`> at least without being able to take advantage of code reuse
17:06:14 <jle`> > replicateM 4 "abc"
17:06:15 <lambdabot>  ["aaaa","aaab","aaac","aaba","aabb","aabc","aaca","aacb","aacc","abaa","abab...
17:06:32 <jle`> if you're asking about the avantages of concatMap vs. (>>=), at least
17:06:35 <jle`> and do notation can be nice, too
17:06:44 <jle`> also you can use `guard`
17:06:50 <Welkin> > replicate 4 "abc"
17:06:51 <lambdabot>  ["abc","abc","abc","abc"]
17:07:13 <Welkin> > sequence $ replicate 4 "abc"
17:07:15 <slaterr> interesting
17:07:15 <lambdabot>  ["aaaa","aaab","aaac","aaba","aabb","aabc","aaca","aacb","aacc","abaa","abab...
17:07:25 <mniip> > filterM (const [True, False]) "bar"
17:07:26 <lambdabot>  ["bar","ba","br","b","ar","a","r",""]
17:07:34 <jle`> replicateM 4 "abc" is do x <- "abc"; y <- "abc"; z <- "abc"; k <- "abc"; return [x,y,z,k]
17:07:44 <jle`> you can write it with concatMaps but it's a bunch more annoying
17:08:08 <jle`> being able to re-use code written for all Monad m is one of the main advantages of the Monad typeclass
17:08:09 <eikke> it's like for-loops!
17:08:34 <mniip> jle`, except sometimes you wonder
17:08:35 <jle`> slaterr: i'm saying this assuming that you see why concatMap is useful, of course
17:08:43 <mniip> "what the heck would traverse do to a list"
17:08:52 * eikke sleep
17:09:00 <mniip> > traverse (:"_") "hello"
17:09:02 <lambdabot>  ["hello","hell_","hel_o","hel__","he_lo","he_l_","he__o","he___","h_llo","h_...
17:09:16 <jle`> that one's nice, haha
17:09:38 <kadoban> :t traverse
17:09:40 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:09:41 <jle`> > traverse (:"1") "000"
17:09:43 <lambdabot>  ["000","001","010","011","100","101","110","111"]
17:09:54 <arkeet> cute
17:10:05 <jle`> it's those fun cases where your Traversable and your Applicative are the same, leading to lots of fun
17:10:07 <jle`> or something
17:10:14 <jle`> that can be loosely associated with fun
17:11:32 <mniip> > traverse ((,) "meep") "moo"
17:11:34 <lambdabot>  ("meepmeepmeep","moo")
17:12:43 <jle`> > mapM ((,) "meep") "moo"
17:12:45 <lambdabot>      No instance for (Monad ((,) [Char])) arising from a use of ‘mapM’
17:12:45 <lambdabot>      In the expression: mapM ((,) "meep") "moo"
17:12:52 <jle`> get your act together, base ;_;
17:12:59 <glguy> > traverse ((,) "foo") ("bar","baz")
17:13:00 <lambdabot>  ("foo",("bar","baz"))
17:13:07 <jle`> it's been like 20 years and there's still no Monad instance
17:13:57 <jle`> is it just that nobody has submitted it?
17:14:05 <jle`> or is someone out there actively blocking the instance
17:14:39 <mniip> @let instance Monoid w => Monad ((,) w) where return x = (mempty, x); (~(w1, k)) >>= f = case f k of ~(w2, r) -> (mappend w1 w2, r)
17:14:40 <lambdabot>  Defined.
17:14:48 <mniip> go ahead
17:15:33 <jle`> case instead of let, i like it, it's bold
17:15:48 <jle`> > mapM ((,) "meep") "moo"
17:15:50 <lambdabot>  ("meepmeepmeep","moo")
17:15:53 <mniip> > traverse (replicate 3) "meep"
17:15:54 <lambdabot>  ["meep","meep","meep","meep","meep","meep","meep","meep","meep","meep","meep...
17:16:02 <mniip> no wait I messed up
17:16:28 <mniip> > traverse ((,) =<< replicate 3) "meep"
17:16:29 <lambdabot>  ("mmmeeeeeeppp","meep")
17:16:35 <jle`> haha
17:17:46 <jle`> :t forM "meep" $ \c -> do (replicate 4 c, c)
17:17:48 <lambdabot> ([Char], [Char])
17:17:54 <jle`> > forM "meep" $ \c -> do (replicate 4 c, c)
17:17:56 <lambdabot>  ("mmmmeeeeeeeepppp","meep")
17:18:20 <mniip> :t forM
17:18:21 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
17:18:25 <mniip> :t for
17:18:26 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
17:18:37 <mniip> you're just writing the same thing with more restrictive typeclasses
17:18:51 <jle`> yea but i'm playing with the instance you defined
17:18:55 <mniip> oh
17:18:59 <jle`> i don't want to waste all your hard work
17:20:13 <jle`> also there's the thrill of writing code that doesn't work in base
17:20:45 * arkeet wonders why that instance doesn't exist in base
17:21:13 <webchat099> what is exactly an idiom? some pointer?
17:21:34 <jle`> webchat099: it's like a common way of doing things, i guess? an accepted pattern?
17:22:09 <kooddllee> so stack failed to install a package and now it is stuck in some broken state... is there some way to cleanup a partially installed package?
17:22:26 <Welkin> kooddllee: ghc-pkg check
17:22:30 <webchat099> I thoug that it was something more clearly defined like "a profunctor in an space of biyections"
17:22:34 <Welkin> kooddllee: ghc-pkg unregister <package>
17:22:44 <webchat099> thanks
17:22:55 <jle`> webchat099: np
17:23:07 <mniip> webchat099, are you by any chance talking about idiom brackets
17:23:15 <kooddllee> Welkin: stack has no command 'ghc-pkg'
17:23:29 <webchat099> not specifically
17:23:34 <Welkin> kooddllee: it's not a stack command
17:23:52 <sm> stack exec -- ghc-pkg ...
17:23:56 <mniip> those are about a specific kind of idioms, not idioms in their most general meaning
17:24:11 <kooddllee> Welkin: I don't have ghc-pkg installed, I only have stack and the stuff that comes with it
17:24:29 <kooddllee> sm: ah that worked
17:25:02 <kooddllee> okay ghc-pkg gave me like 100 warnings... is there a shortcut?
17:25:16 <ski> webchat099 : sometimes, "idiom" is an alternative name for "applicative functor". but there is another, fuzzier, sense of the terms that's more or less the same across the whole of programming
17:25:37 <kadoban> kooddllee: So what exactly is wrong? What are you trying that's giving you an error (and what error)?
17:25:49 <sm> stack exec -- ghc-pkg list , look for the ones in {} (or a different colour) which are broken. stack exec -- ghc-pkg unregister PKG for each of those
17:26:19 <sm> kooddllee: not that you should have to bother with this, if you're using stack
17:26:21 <kooddllee> kadoban: basically i tried to install ghc-mod and it failed because it ran out of memory, now when I try to  install ghc-mod again after adding a swapfile it just stalls forever
17:26:46 <kadoban> kooddllee: How forever? Are you sure it's not still working?
17:27:15 <sm> maybe the swapping is too slow
17:27:17 <kadoban> It's been a while, but I do remember ghc-mod taking … quite close to forever to compile.
17:27:25 <kooddllee> kadoban: I gave it 30 mins and it didnt install a single one of 14 remaining dependencies and no output after it started installing the first one
17:27:26 <kadoban> Especially if it's swapping a decent amount.
17:27:28 <sm> how much ram do you have ?
17:27:34 <kadoban> Hmm
17:27:48 <Hijiri> kooddllee: maybe run some program to monitor your memory usage
17:27:51 <kooddllee> it doesnt get into the swapping now because it doesnt use a lot of memory
17:28:00 <Hijiri> oh you already did
17:28:03 <kooddllee> yes
17:28:27 <kooddllee> I'm doing this on a digitalocean instance with 1gb ram
17:28:56 <Grandpa> Hello, I'm a bit stumped by pattern synonyms. I have gone through a couple of tutorials.  Say I wanted to create a pattern that matched any variable with type [[Integer, Integer)] that began with this tuple (1,2).  How would I do that?
17:29:01 <sm> I think it's using a lot of memory, just for a short time
17:29:14 <sm> you could run top with a fast refresh to watch it
17:29:19 <kooddllee> the ghc-pkg list doesnt show any broken packages
17:29:28 <kooddllee> okay
17:29:38 <kooddllee> thats what I did before, ill do it again
17:29:51 <Grandpa> test
17:30:00 <sm> I believe 1G is borderline for some installs
17:30:38 <kooddllee> So it got to 77.8% memory usage and is staying at exactly that amount now
17:30:50 <ski> Grandpa : is it list of lists of pairs of integers ? or just list of pairs of integers ?
17:31:19 <ski> (or perhaps no pairs in the list at all ?)
17:31:34 <slaterr> could haskell implementation be made to work with hard realtime? like there are special jvms for hard realtime
17:31:35 <kooddllee> sm: the main thing that makes me think there is something wrong is that there is no output from stack past the first 4 lines now
17:31:47 <kooddllee> usually there is a ton of output
17:32:17 <kadoban> Really? stack is pretty quiet
17:32:41 <sm> so you still have 22% memory free ? or other programs are using that, in which case it's probably swapping ?
17:32:49 <kadoban> Are you sure it hasn't just installed everything except the big deps and it's just working? I would imagine the machine you're running this on isn't exactly beastly with only 1GB RAM.
17:33:21 <kadoban> kooddllee: You could try -v , see what command(s) it's running, maybe?
17:33:32 <kooddllee> okay, ill try -v
17:35:20 <kooddllee> It is stuck on this command when using -v: http://lpaste.net/139035
17:36:13 <kooddllee> sm: 22% was free
17:36:36 * jle` is tempted to unsafeCoerce his way out of a GADT conundrum
17:36:44 <jle`> involving phantom types
17:36:55 <jle`> but i must resist
17:36:56 <Axman6> why not safe coerce your way out?
17:37:20 <jle`> also the easy way out
17:37:24 <jle`> >:(
17:47:05 <levi> slaterr: Possibly, but it's typically easier to reason about time/space behavior of eagerly evaluated languages than lazily-evaluated languages even when you've got a potentially deterministic GC.
17:47:27 <mniip> jle`, this just in
17:47:46 <mniip> > traverse (+) [1,2,3] 5
17:47:48 <lambdabot>  [6,7,8]
17:48:12 <jle`> levi: what is potentially deterministic?  deterministic when it wants to be and not when it doesn't?
17:48:19 <mniip> f ~ Reader e
17:48:31 <jle`> mniip: cute :)
17:51:03 <kooddllee> does anybody use stack + ghc-mod + vim ?
17:52:10 <kooddllee> I'm getting an error when using stack-installed ghc-mod: "ghc-mod: cabal: readCreateProcess: runInteractiveProcess: exec: does not exist (No such file or directory)"
17:53:07 <levi> jle`: A GC can only do so much in a bounded length of time. If you give it more work to do than the time it's got, you're going to eventually run into some non-deterministic behavior in your system.  I.e., if you have a space leak your deterministic garbage collector is not going to help.
17:54:56 <levi> My phrasing that attributed the 'potentially deterministic' aspect to the GC was probably not great at conveying what I meant.
17:57:25 <kooddllee> How do I uninstall a package with stack?
17:59:48 <sm> stack exec -- ghc-pkg unregister PKG
18:00:29 <kooddllee> sm: hmm that seems to not fully remove the package, for example the binaries remain
18:00:38 <sm> true..
18:01:39 <sm> stack clean probably doesn't remove them either.. rm -rf ./.stack-work will, unless you also installed them globally
18:01:54 <sm> along with some other stuff obviously
18:02:54 <kooddllee> I just did rm $(which ghc-mod) for now
18:03:38 <kadoban> kooddllee: Yeah for global executables, just delete them.
18:03:45 <kadoban> I don't think there's even supposed to be a better way for that.
18:04:08 <kooddllee> I wonder if there is some idea about having partially-compiled/processed haskell packages to speed up installations
18:05:42 <kooddllee> kadoban: something like virtual file systems for each package which get combined as they are needed and can be fully deleted in one go?
18:07:11 <kooddllee> something like Nix but with tracking of all installed files instead of manually specifying directories
18:07:19 <kadoban> kooddllee: Not 100% sure what you mean. If you want to avoid building lots of stuff, IIUC you can use the docker images, one of which has … everything from stackage pre-built.
18:08:07 <kooddllee> kadoban: the virtual file system comment was on a way for easily deleting packages and isolating them, the partially compiled packages was a different thought
18:10:16 <kadoban> Ah
18:10:40 <kadoban> I dunno, I haven't really cared so far about deleting packages, unless you mean deleting executables.
18:37:13 <NotACat_> hi, i got sent here from #haskell-beginners because this http://lpaste.net/139039 seems odd
18:37:23 <mac10688> anyone have thoughts on this?
18:37:25 <mac10688> https://github.com/Gabriel439/post-rfc/blob/master/sotu.mdv
18:38:02 <Cale> NotACat_: is that package qualification on Data.HashMap.Strict really needed?
18:38:27 <geekosaur> NotACat_, since you have an import of unordered-containers but there is a full version on one leg of the error, you probably have multiple conflicting versions installed
18:38:32 <NotACat_> i tried that to get the version aeson uses
18:38:41 <GGuy> mac10688: https://github.com/Gabriel439/post-rfc/blob/master/sotu.md
18:38:43 <geekosaur> you need to include the version
18:38:53 <Cale> NotACat_: From what I understand PackageImports is not really recommended -- it was needed for base migration at one point.
18:39:15 <NotACat_> yeah i was just trying to 'fix' it with that
18:39:28 <geekosaur> and yes, that's kind of a poor solution, but if you must do it that way then specify "unordered-containers-0.2.3.0"
18:39:46 <mac10688> oh thanks GGuy xchat is acting strange for me
18:40:04 <geekosaur> (there may be a similar issue with Text, but as you did not directly import it, it's not unusual for it to be versioned)
18:41:18 <NotACat_> specifying the version gets rejected with a "failed to load interface"
18:41:59 <geekosaur> huh. that sounds ... oh crud. wonder if your aeson was compiled against a version of unordered-containers that is no longer installed
18:42:24 <Cale> NotACat_: ghc-pkg check and see if you have broken packages
18:42:50 <NotACat_> nope
18:43:32 <geekosaur> sandbox? run that check under cabal exec, or cabal sandbox hc-pkg check
18:44:04 <geekosaur> (although if that's happening inside a sandbox I'd be *really* worried0
18:45:10 <joehillen> Use stack!
18:45:16 <NotACat_> no it's not inside the sandbox, the setup is kinda meh, i'm just trying stuff so it's a little messed up
18:45:41 <joehillen> NotACat_: https://github.com/commercialhaskell/stack
18:46:22 <GGuy> mac10688: I haven't read that before and although it can be subjective I tend to agree with most of it after a quick skim through.
18:47:16 <NotACat_> eh, knowing it'S the packages and not my lack of understanding is fine, i'll clean this up and come back if it still yells at me.
18:48:58 <GGuy> Anyone know of any links describing the use of parsec over a stream of complex (non-string) data types?
19:03:34 * hackagebot drifter-postgresql 0.0.1 - PostgreSQL support for the drifter schema migration tool  https://hackage.haskell.org/package/drifter-postgresql-0.0.1 (MichaelXavier)
19:03:36 * hackagebot warp 3.1.3 - A fast, light-weight web server for WAI applications.  https://hackage.haskell.org/package/warp-3.1.3 (KazuYamamoto)
19:05:55 <saml_> @hoogle [a] -> [[a]]
19:05:56 <lambdabot> Data.List inits :: [a] -> [[a]]
19:05:56 <lambdabot> Data.List permutations :: [a] -> [[a]]
19:05:56 <lambdabot> Data.List subsequences :: [a] -> [[a]]
19:06:03 <arkeet> what are you looking for
19:06:15 <saml_> [1,2,3] => [[1], [2], [3]]
19:06:23 <arkeet> > map (\x -> [x]) [1,2,3]
19:06:25 <lambdabot>  [[1],[2],[3]]
19:06:25 <pacak> :t map (:[])
19:06:26 <lambdabot> [a] -> [[a]]
19:06:30 <arkeet> or that
19:07:01 <saml_> i wrote function called merge. given that, i want to implement merge sort
19:07:32 <saml_> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.OldList.html#sort  this is hard to comprehend with sequences and ascending descending...
19:08:34 * hackagebot warp-tls 3.1.1 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.1.1 (KazuYamamoto)
19:08:55 <saml_> oh the source has older mergesort implementation which is slower but reads better
19:44:02 <Lokathor> so i have newer versions of several packages than my cabal package expects, and so it says that cabal is broken
19:44:41 <Shockk> hello, I'm currently trying to set up a test suite in my project's cabal file and I'm getting a strange linker error
19:44:55 <Lokathor> is there a simple way to fix this or should i just remove GHC and get a bundle that all works together?
19:45:49 <slack1256> Lokathor: didn't stack do that if it couldn't find a GHC install? 
19:45:51 <Shockk> the error I'm getting is "undefined reference to testzmpolar4garbledgarbled_PolarziTest_tests_closure"
19:45:55 <slack1256> not that I know really
19:46:16 <Lokathor> stack... might do that? I'm not using stack i was just using apt-get
19:46:33 <Shockk> from what I can tell, the undefined reference is for Polar.Test.tests which my test file imports and uses
19:46:49 <subleq__> I noticed that the Eq and Ord instances for Data.Version.Version don't agree. Isn't that a problem?
19:47:45 <Shockk> if it helps, Polar.Test isn't used anywhere in my actual executable so I wonder if that might be the problem
19:48:01 <Lokathor> slack1256, should I just try having stack set it all up for me?
19:48:08 <Shockk> but I'd think structuring a test suite across more than one module would be a common thing
19:49:08 <slack1256> Lokathor: I haven't used stack (NixOS FTW!) but I would be surprised if it did more than once
19:49:31 <Lokathor> but i didn't use stack to begin with, is what i'm saying
19:52:57 <slack1256> Mmm read the docs. You can always go back a pristine state if you rm -rf enough and uninstall related packages
19:53:25 <slack1256> but anything the docs says on the matter > what slack1256 said on #haskell as unbased rants :)
19:59:00 <Bashmetim> so i'm trying to get a concrete grasp of how the IO and ST monads work
19:59:13 <Lokathor> ~magic~
19:59:21 <slack1256> they are basically State monads with special states
19:59:47 <Bashmetim> can anyone explain what the State# type constructor is/does?
19:59:51 <breadmonster> Bashmetim: They're hardwired into the compiler, you're not supposed to find out the concrete implementations.
20:00:30 <scshunt> Bashmetim: one way of looking at them is as a magic key
20:00:45 <scshunt> when you perform an IO action, you get a key out of it, that's the State#
20:00:45 <slack1256> they are not magic
20:00:58 <scshunt> when you next try to perform an IO action, you must provide that key
20:01:14 <scshunt> or else the runtime won't let it happen
20:01:28 <scshunt> the IO monad thus threads the keys from one call to another
20:01:40 <scshunt> this isn't exactly how they work, but it's a nice way to reason about things
20:01:48 <pacak> It's magic.
20:02:02 <pacak> Realworld state. Kind of.
20:02:05 <Bashmetim> What do you mean by 'key'?
20:02:12 <shachaf> I'd say the opposite is true.
20:02:24 <shachaf> It's a terrible way to reason about things, but it's unfortunately how things work.
20:02:47 <Bashmetim> Well, it's *real*... I can run it and see it work... so I doubt it's magic :)
20:02:58 <dramforever> IIUC it's basically passing a token of the world around
20:03:10 <shachaf> There's no world.
20:03:33 <shachaf> "State# a" is a value with size zero. It contains no information.
20:03:49 <dramforever> "token"
20:03:49 <Bashmetim> My understanding is that RealWorld == ()
20:04:07 <Bashmetim> in that they're both a unit type
20:04:20 <dramforever> shachaf: isn't it there so that the compiler can't optimize away/reorder the call?
20:04:20 <shachaf> It doesn't matter what RealWorld is because there are no values of type RealWorld.
20:04:51 <shachaf> dramforever: Yes. It's an internal GHC hack, having nothing to do with the real world.
20:05:00 <dramforever> lemme see
20:05:46 <dramforever> by "a token of the world" I mean...an argument that has to be passed in in order to get the action to run
20:06:00 <dramforever> yes, the "of the world" part isn't right
20:06:10 <dramforever> thanks for clarifying
20:06:35 <Bashmetim> shachaf no values of type RealWorld -- does that mean it's a bottom type then? like undefined?
20:06:47 <shachaf> Bashmetim: undefined isn't a type at all.
20:07:02 <dramforever> Bashmetim: it's not even the right kind
20:07:12 <dramforever> :k State#
20:07:13 <lambdabot>     Not in scope: type constructor or class ‘State#’
20:07:13 <lambdabot>     Perhaps you meant one of these:
20:07:13 <lambdabot>       ‘State’ (imported from Control.Monad.State),
20:07:17 <dramforever> sigh...
20:07:20 <shachaf> It is the right kind, though maybe it shouldn't be. RealWorld :: *
20:07:30 <dramforever> no I mean that State# thing
20:07:46 <dramforever> isn't that RealWorld thing just a tag?
20:07:46 <shachaf> undefined :: RealWorld, but that's a red herring. There aren't even any expressions of type RealWorld in normal use.
20:08:07 <dramforever> shachaf: even in State# RealWorld, right?
20:08:23 <dramforever> ok State# :: * -> #
20:08:52 <Bashmetim> so it takes a regular type and returns an unboxed type?
20:09:02 <Bashmetim> how did you get that, btw?
20:09:06 <dramforever> yep
20:09:10 <dramforever> Bashmetim: import GHC.Prim
20:09:16 <dramforever> :set -XMagicHash
20:09:19 <dramforever> :k State#
20:09:20 <lambdabot>     Not in scope: type constructor or class ‘State#’
20:09:20 <lambdabot>     Perhaps you meant one of these:
20:09:20 <lambdabot>       ‘State’ (imported from Control.Monad.State),
20:09:24 <dramforever> in ghci
20:09:28 <dramforever> sigh...
20:09:34 <shachaf> Please be kinder to lambdabot.
20:09:42 <Bashmetim> MagicHash, that's it!
20:09:53 <dramforever> no I was answering Bashmetim's question
20:10:00 <dramforever> didn't expect lambdabot to reply
20:10:12 <dramforever> so I said "sigh..."
20:10:27 <Bashmetim> no big deal, it's just text :)
20:10:33 <yashinbasement> hey guys can I swap two element of a list
20:10:49 <dramforever> what do you mean by that
20:10:51 <yashinbasement> implementing a sort algo
20:11:09 <dramforever> that's bad, because lists in haskell are singly linked lists
20:11:26 <Cale> yashinbasement: You can of course, but it's not a terribly efficient operation.
20:11:39 <dramforever> it's not efficient at all
20:11:41 <yashinbasement> so how do I do quicksort if I don't do that
20:12:10 <dramforever> I'm afraid that those imperative algorithms don't translate to haskell easily
20:12:13 <Bashmetim> think less imperatively!
20:12:17 <Cale> Well, quicksort involves partitioning the list into the elements less than the pivot and those greater than or equal to the pivot, quicksorting those lists, and concatenating the results
20:12:19 <dramforever> Bashmetim: it's hard
20:12:22 <shachaf> If you want to write Quicksort, use a mutable array or something.
20:12:25 <pacak> yashinbasement: You can't.
20:12:30 <Cale> hm?
20:12:38 <dramforever> because it's an already existing algorithm
20:12:45 <Cale> It's pretty easy to write quicksort.
20:12:48 <shachaf> There are other sorting algorithms that are more convenient in Haskell.
20:13:02 <slack1256> quicksort and inplace quicksort are different
20:13:05 <dramforever> Cale: I thought that was a sorting algorithm based on quicksort
20:13:11 <ttt_fff> every time I refactor code, I fall more in love with haskell. It's (1) change data types (2) look at ghc's errors via syntastic (3) fix them (4) refactoring done.
20:13:11 <yashinbasement> yes there are but for an exercise I want to do quicksort
20:13:12 <Cale> dramforever: It's quicksort :)
20:13:13 <dramforever> maybe call that filtersort
20:13:32 <shachaf> Cale: The (filter (<=x) xs ++ [x] ++ filter (>x) xs) thing isn't quicksort by any reasonable use of the word.
20:13:47 <shachaf> It's not quick, to start with.
20:13:58 <dramforever> I wonder if there's a better way
20:14:01 <Cale> > let quicksort [] = []; quicksort (x:xs) = quicksort less ++ [x] ++ quicksort greater where (less, greater) = partition (< x) xs in quicksort "mississippi"
20:14:02 <lambdabot>  "iiiimppssss"
20:14:06 <Bashmetim> quicksort [] = []
20:14:07 <Bashmetim> quicksort x:xs = quicksort (filter (<= x) xs) ++ [x] ++ quicksort (filter (> x) xs)
20:14:17 <dramforever> lemme try, I think there must be a better way
20:14:39 * Bashmetim types embarrassingly slow
20:14:41 <Cale> shachaf: Well, it's the quicksort algorithm. It's not in-place, sure.
20:15:28 <shachaf> No, the quicksort algorithm involves a bunch of swaps and things.
20:15:35 <yashinbasement> yeah
20:15:43 <shachaf> It's a silly argument over words so I won't keep at it. But I think it's pretty misleading to call it quicksort.
20:15:54 <Bashmetim> You can split the list instead of filtering it twice!
20:16:35 <Cale> I don't think it's misleading. The in-place quicksort does essentially the same thing, it just does the partitioning step in-place by swapping.
20:16:42 <Bashmetim> partition :: [a] -> ([a], [a]) -- could speed things up
20:16:48 <yashinbasement> what is <- 
20:16:54 <dramforever> > let qsaug [] xs = xs; qsaug (x : xs) = let (a1, a2) = partition (< x) xs in qsaug a1 (x : qsaug a2); quicksort xs = qsaug xs [] in quicksort [3,8,1,6,5,4,7,2,9]
20:16:55 <slack1256> and do quicksort in two lines? that would be a bad publicity stunt ;-)
20:16:55 <lambdabot>      Equations for ‘qsaug’ have different numbers of arguments
20:16:56 <lambdabot>        <interactive>:1:5-20
20:16:56 <lambdabot>        <interactive>:1:23-99
20:17:00 <ttt_fff> (filter (<=x) xs ++ [x] ++ filter (>x) xs) <-- is this even sorting? where is the guarntee that the front/back parts are sorted?
20:17:02 <dramforever> bad...
20:17:05 <jle`> anyone know who i can evaluate type families using ghc?
20:17:13 <Cale> yashinbasement: <- is punctuation that's used in a few places in the syntax...
20:17:21 <Bashmetim> Cale is right, that is the quicksort algorithm, just not the most efficient implementation
20:17:22 <ttt_fff> jle`: who -> how ?
20:17:28 <dramforever> > let qsaug [] rest = rest; qsaug (x : xs) rest = let (a1, a2) = partition (< x) xs in qsaug a1 (x : qsaug a2 rest); quicksort xs = qsaug xs [] in quicksort [3,8,1,6,5,4,7,2,9]
20:17:30 <lambdabot>  [1,2,3,4,5,6,7,8,9]
20:17:37 <jle`> i mean, ghci, heh
20:17:40 <dramforever> I wonder if that makes it more in-place
20:17:48 <shachaf> ttt_fff: OK, I forgot the recursive call.
20:17:56 --- mode: ChanServ set +o shachaf
20:18:05 <Cale> dramforever: It'll never be in-place with immutable structures like lists :)
20:18:06 --- mode: shachaf set +b *!*c01f699b@*.192.31.105.155
20:18:19 <dramforever> Cale: well, yeah
20:18:31 <Cale> shachaf: what's that ban? Do I have to worry about other channels?
20:18:35 <dramforever> but I think it's more memory efficient this time
20:18:37 --- mode: shachaf set +b-b ttt_fff!*@* *!*c01f699b@*.192.31.105.155
20:18:44 --- kick: ttt_fff was kicked by shachaf (ban evasion)
20:18:49 <Cale> oh, I see
20:18:51 <Cale> okay
20:19:04 <dramforever> I wonder what's going on
20:19:07 <Bashmetim> that doesn't mean quicksort is impossible, just the in-place version that some people are more familiar with
20:19:20 <geekosaur> hm, actually I think the ban is no longer co9nsidered appropriate but nobody removed it
20:19:45 <Cale> The in-place version is possible too, it's just that you can't use lists, you'd have to use mutable arrays or some such.
20:20:04 <dramforever> I think my version is pretty nice
20:20:08 --- mode: ChanServ set +o geekosaur
20:20:26 --- mode: shachaf set -bb ttt_fff!*@*.136.152.142.59$#haskell-ops ttt_fff!*@*
20:20:40 --- mode: shachaf set -o shachaf
20:21:58 <dramforever> um
20:22:30 <dramforever> actually that qsaug thing prevents the extra ++
20:23:27 <Bashmetim> it's probably better to take a few lines and write the ideas out more clearly, but irc sort of implies code-golf mode
20:23:38 <dramforever> me?
20:25:24 <Bashmetim> yes? 
20:25:34 <dramforever> ok
20:26:04 --- mode: geekosaur set -o geekosaur
20:26:19 <Lokathor> Bashmetim, it compiles to basically the same thing either way, yes?
20:27:17 <Shockk> I put everything about the issue I'm having, here: https://gist.github.com/shockkolate/4d2fe64e3eacd0373e73
20:27:44 <Shockk> the last 3 lines are the important part of the cabal build log
20:27:46 <Bashmetim> of course, I was just talking about readability
20:28:26 <Shockk> but I included the whole log, test files, cabal file, and the basic directory structure
20:33:07 <Bashmetim> Shockk I can't find any hints in that, looks like an annoying error tho
20:33:24 <Shockk> Bashmetim: is quite annoying, yep
20:33:30 <lpaste_> dramforever pasted “partition-sort without appending” at http://lpaste.net/139050
20:33:59 <dramforever> oh duh, it's supposed to be literate haskell
20:33:59 <Shockk> Bashmetim: I don't know if it'll help, but adding Polar4.Test to the other-modules of test-polar4 resolves the error,
20:34:07 <lpaste_> dramforever pasted “partition-sort without appending” at http://lpaste.net/139051
20:34:14 <Shockk> replacing it with the same error for Polar.Test.Asset instead
20:34:21 <dramforever> @letlpaste 139051
20:34:22 <lambdabot>  Parse failed: Parse error: >
20:34:26 <Shockk> etc, and if I add all the test modules to other-modules,
20:34:30 <dramforever> sigh...lambdabot doesn't support it
20:34:36 <Bashmetim> dramforever sorry, I wasn't taking a jab earlier
20:34:41 <Shockk> it starts giving me that error for the non-test modules that are part of the main library
20:35:07 <Bashmetim> that's some hot code though!
20:35:45 <dramforever> Bashmetim: I'm not a native English speaker, what does "taking a jab" mean?
20:35:59 <dramforever> those explanations on the Internet all look weird
20:36:06 <ttt_fff> shachaf: I think I deserve an apology for that kickban.
20:36:25 <Zekka> dramforever: "take a jab at x" usually means "pleasantly make fun of x"
20:36:30 <dramforever> ok
20:36:38 <Bashmetim> Oh, it's like I wasn't trying to insult, basically
20:36:45 <dramforever> so..what about "hot code"?
20:37:08 <Bashmetim> hot as in good looking
20:37:14 <dramforever> ok
20:38:10 <dramforever> hmm...looks like the built in sort first looks for consecutive monotonic parts
20:38:12 <dramforever> the merge them
20:38:36 <dramforever> using...mergePairs
20:39:15 <Bashmetim> I can see that being a really worthwhile optimization with immutable lists
20:39:24 <dramforever> and duh, looks like it's done before
20:39:24 <Zekka> dramforever: Almost like some kind of -- merge sort!
20:39:29 <Shockk> I may end up just using exitcode-stdio as the test-suite type
20:39:35 <dramforever> interesting
20:39:38 <Zekka> (above comment is "taking a jab" at your comment)
20:39:48 <dramforever> hmm...
20:40:11 <slack1256> ((likes this lisp/meta comment convention))
20:41:54 <octopuscabbage> i want to write a typeclass which represents types which have two 'slots' and can be transfered back and forth from 2 value tuples
20:41:54 <Bashmetim> Shockk I almost never use cabal, because it's a little bit nightmare-fuel whenever your project isn't perfect
20:42:01 <dramforever> still slower and allocates more than built in sort
20:42:02 <Shockk> I see that :(
20:42:14 <dramforever> it must be, that looks like some adaptive sort
20:42:18 <Bashmetim> FP complete released something called stack - https://www.fpcomplete.com/blog/2015/06/stack-0-1-release
20:42:25 <yashinbasement> what's the replication of list[i] = something in haskell
20:42:29 <Bashmetim> I've been meaning to take a look at it
20:42:47 <shachaf> ttt_fff: Questions about op decisions go in #haskell-ops
20:42:48 <dramforever> yashinbasement: (!!)?
20:42:57 <dramforever> but it's not really recommended
20:43:09 <dramforever> if you're using it, you're almost certainly wrong
20:43:21 <dramforever> > [1,2,3,4,5] !! 3 -- showing you anyway
20:43:22 <lambdabot>  4
20:43:41 <Bashmetim> To update in the middle at a given index, you're really building a new list which is the same except at that index
20:44:02 <dramforever> oh wait you need to *change* an element in the middle
20:44:11 <Zekka> If what Bashmetim said made you think "oh, that sounds really inefficient!" then that's why people don't really use lists for this
20:44:12 <Bashmetim> depending on the problem, you can use a zipper or a sequence to make your life easier...
20:44:14 <octopuscabbage> but i'm having some weidnress with the type. here's what i ahve so far http://lpaste.net/139053
20:44:55 <Bashmetim> mutable arrays are also what you "really" want
20:45:12 <dramforever> octopuscabbage: f and s must be polymorphic there
20:45:26 <Zekka> If you don't want to deal with mutable things (which have some complicated types associated with them) Haskell's Sequence type only requires touching log-of-the-size number of things, so it's pretty cheap.
20:45:29 <octopuscabbage> dramforever, how do i fix that?
20:45:29 <Bashmetim> > :t splitAt
20:45:31 <Zekka> Er, Seq*
20:45:31 <lambdabot>  <hint>:1:1: parse error on input ‘:’
20:45:32 <dramforever> so you can't just return anything you want to
20:45:39 <Zekka> That's provided by Data.Sequence in the containers library
20:45:41 <Bashmetim> >:t splitAt
20:45:44 <dramforever> octopuscabbage: do you understand the problem now?
20:45:50 <octopuscabbage> dramforever, no not really
20:46:27 <dramforever> those f and s doesn't appear in the typeclass head
20:46:39 <dramforever> so the caller gets to pick them
20:47:05 <dramforever> specializing toTuple to Point -> (f, s), the caller can pick the f and s
20:47:11 <Bashmetim> whatever, for haskell lists it would be let (a, _:b) = splitAt idx list in a ++ new:b
20:47:21 <dramforever> so I can pick Point -> (String, Double) or whatever
20:48:10 <octopuscabbage> dramforever, I think I might get it better if you gave my a code example, i kind of get it but it's still foggy
20:48:47 <dramforever> useThatPoint :: (String, Double)
20:48:59 <dramforever> useThatPoint = toTuple (Point 2 2)
20:49:12 <dramforever> if the toTuple thing were implemented, then this is possible
20:49:30 <octopuscabbage> I think I see what you're saying, basically it's not possible 
20:50:13 <dramforever> it's possible if you modify the typeclass
20:50:18 <dramforever> but it would require extensions
20:51:02 <octopuscabbage> dramforever, eh not really worth it
20:51:07 <octopuscabbage> dramforever, ty though
20:53:33 <Bashmetim> Does it make more sense if you think about what "kind" of type a tuple is?
20:53:37 <Bashmetim> :k (,)
20:53:38 <lambdabot> * -> * -> *
20:54:25 <Bashmetim> An IsTuple would be anything that takes two types and returns a "sum" of both types
20:54:38 <slack1256> product but yeah
20:56:20 <Bashmetim> product, right. the problem is that fromTuple takes a tuple of type (A, B) - where A and B can be any type
20:57:06 <dramforever> octopuscabbage: you're welcome
20:57:07 <Bashmetim> the Point constructor expects them both to be Int's, and the compiler can't deduce that
21:03:05 <BJangles> Wow, big list
21:03:12 <BJangles> What happens here?
21:03:18 <AbelianGrape> Is there any way to use 128-bit IEEE floating point numbers in Haskell?
21:03:31 <dramforever> BJangles: so many people here
21:03:37 <dramforever> we talk about haskell, that's it
21:03:46 <BJangles> Well
21:03:46 <dramforever> oh and sometimes stuff a little off topic
21:03:52 <BJangles> What IS haskell?
21:03:58 <dramforever> a programming language
21:04:05 <bb010g> A cool programming language
21:04:09 <BJangles> I am so clearly lost
21:04:16 <bb010g> What were you looking for?
21:04:30 <BJangles> I was just looking around for irc channels
21:04:46 <dramforever> duh
21:04:47 <BJangles> By the way there arent much good apps for irc on android phones
21:04:47 <AbelianGrape> Isn't this one of the biggest channels on freenode?
21:04:50 <Bashmetim> BJangles it's a functional programming language!
21:04:52 <bb010g> AbelianGrape: http://hackage.haskell.org/package/ieee754
21:04:57 <BJangles> Anyone wanna make a badass app pls do tell me
21:05:01 <bb010g> BJangles: I would recommend IRCCloud.
21:05:19 <BJangles> Hey im new xD
21:05:28 <AbelianGrape> bb010g: I don't think that supports 128-bit floats. Only single and double precision.
21:05:29 <BJangles> Whats the best language to learn first?
21:05:30 <mjrosenb> so it looks like both lenses and type holes use variables that are prefixed with '_'
21:05:33 <BJangles> Other than html and css
21:05:46 <bb010g> AbelianGrape: Yep. http://irc.netsplit.de/channels/?net=freenode
21:05:57 <dramforever> Dijkstra recommends haskell
21:06:01 <Bashmetim> BJangles Well, you're in #haskell, so... Haskell?
21:06:13 <BJangles> bb010g im using AndroIRC
21:06:15 <dramforever> BJangles: but tbh you shouldn't really ask here
21:06:16 <bb010g> BJangles: We think Haskell's pretty good. :P https://github.com/bitemyapp/learnhaskell & #haskell-beginners are awesome
21:06:30 <BJangles> Whut?
21:06:31 <Bashmetim> http://learnyouahaskell.com/
21:06:33 <dramforever> it's unfair to other languages
21:06:45 <BJangles> Why is that dramforever
21:06:49 <mjrosenb> is it possible to use both?
21:06:53 <BJangles> Oh lol
21:06:55 <dramforever> because of course people here will recommend haskell
21:06:58 <BJangles> Because bias.. i get it...tralala..
21:07:03 <mjrosenb> or even just lenses without needing to remember how to turn off type holes?
21:07:04 <bb010g> Bashmetim: I thought in general we weren't recommending LYaH anymore, because outdated.
21:07:05 <BJangles> No kidding xD
21:07:20 <Bashmetim> You came to a little party where everyone is celebrating one particular language, and asked what language is best
21:07:21 <dramforever> BJangles: go ask in a generic programming channel/forum/subreddit/etc.
21:07:46 <AbelianGrape> dramforever: BJangles: Actually, you're not going to get a fair response there either
21:07:47 <BJangles> >_> i wasnt really interested
21:07:47 <Bashmetim> bb010g news to me? It's what I learned with... what's outdated in it?
21:07:57 <AbelianGrape> Because you're going to get responses biased by popularity
21:07:58 <BJangles> Was just trying to politely convo >_>
21:08:04 <dramforever> AbelianGrape: but you can get many different unfair responses
21:08:04 <AbelianGrape> People can only recommend Haskell if they've used it
21:08:08 <dramforever> oh can you?
21:08:16 <bb010g> Bashmetim: http://bitemyapp.com/posts/2014-12-31-functional-education.html covers it pretty well
21:08:23 <AbelianGrape> So you should actually multiply the recs for each language by 1/its popularity
21:08:32 <dramforever> AbelianGrape: pretty sure many will recommend haskell
21:08:34 <kadoban> Bashmetim: It has no exercises, which is pretty bad.
21:08:39 <Bashmetim> BJangles unfair as it may be: *w00000t haskell go learn yay*
21:09:09 <Bashmetim> kadoban I thought it was pretty good for picking up the concepts though
21:09:19 <bb010g> BJangles: Again, go check out #haskell-beginners.
21:09:30 <BJangles> Lmao....
21:09:33 <BJangles> Geez
21:09:48 <BJangles> If I learn it and dont love it
21:09:51 <BJangles> What then xD
21:09:52 <Bashmetim> then again, I already knew other languages... it does have more of a "code along with me" vibe though.
21:09:57 <bb010g> Money back, guaranteed
21:10:03 <kadoban> Bashmetim: I have less of an opinion on that part. But without exercises … I dunno, I mean I read it, and then at the end it's like "okay … now I can kinda sort read code and can't write a thing … great"
21:10:15 <BJangles> What about Python? Anyone got any opinion on that...
21:10:37 <dramforever> BJangles: there's an interesting problem about haskell though
21:10:45 <kadoban> BJangles: It's a pretty nice language for small stuff or tying other stuff together. After haskell it's kinda painful not having a type system though.
21:10:46 <dramforever> learning haskell is like re-learning programming
21:11:02 <BJangles> Im not a programmer guys xD
21:11:09 <BJangles> Just an idiot that got lost into this channel xD
21:11:09 <dramforever> oh
21:11:10 <dramforever> wow
21:11:10 <bb010g> I find it's a lot easier to go Haskell -> Python or Java than the other way around.
21:11:16 <Bashmetim> Maybe it's better if you know another language first, I read learnyoua and a few chapters of real-world haskell and basically went bookin' with the language!
21:11:18 <BJangles> Wooooo
21:11:29 <kadoban> Bashmetim: I knew many languages before I learned haskell.
21:11:40 <BJangles> Why is programming so interesting?
21:11:47 <BJangles> Thats a generic question
21:11:50 <bb010g> It's problem solving
21:11:56 <BJangles> About what?
21:12:02 <Bashmetim> in that case, i guess it's a 'your mileage may vary' issue
21:12:06 <bb010g> And you get to create these magnificent machines out of thoughts
21:12:19 <BJangles> Hmm
21:12:21 <Lokathor> so if i'm using stack, do i also need to use a cabal sandbox..? or what's the story there
21:12:36 <dramforever> BJangles: you instruct this simple machine to do kinds of things
21:12:40 <Bashmetim> bb010g that's a beautiful way to put it!
21:12:41 <bb010g> Lokathor: You should just be able to set up a stack.yaml and run.
21:12:44 <kadoban> Lokathor: No, you no longer need to manually sandbox stuff like that.
21:13:23 <Lokathor> alright i guess i like the idea of this stack thing perhaps
21:13:30 <BJangles> Thats a vague way to put it xD
21:13:45 <BJangles> But wait no, i understand
21:14:03 <BJangles> Well whats the best way in learning programming? Which ones to learn first etcetera?
21:14:22 <AbelianGrape> I agree with Dijkstra. I wish I'd learned Haskell first.
21:14:31 <kadoban> BJangles: Haskell is a good choice. I used to recommend python. One of those. Don't learn C first, whatever anyone tells you.
21:14:34 <bb010g> Another thing I really like about Haskell is how close you can take it to mathematics (esp. category theory). It's beautiful to me to be able to take these mathematical proofs and discoveries and have a flow between them and concrete applications running on their foundations
21:14:48 * dramforever learnt C++ first
21:14:49 <dramforever> crappy
21:14:50 * bb010g shills #haskell-beginners first
21:15:09 <bb010g> again*
21:15:16 <BJangles> But i am already exposed to c lol
21:15:24 <BJangles> Kadoban
21:15:34 <dramforever> but you said you were a non-programmer
21:15:48 <dramforever> *you weren't a programmer
21:15:57 <Bashmetim> I have a friend who just got back from OPLSS and said most of the hipsters there thought haskell was pedestrian and not mathy enough at all, lol
21:16:02 <BJangles> I dont consider myself a programmer...
21:16:06 <mjrosenb> oh, interesting, I got the order of appending wrong.
21:16:12 <BJangles> I joined one of those self teaching things
21:16:17 <BJangles> Anyway i dont remember much
21:16:36 <dramforever> Bashmetim: how mathy is mathy enough?
21:16:46 <dramforever> that's a very interesting question
21:16:51 <Bashmetim> coq and agda, apparently
21:17:05 <dramforever> why are they more mathy?
21:17:13 <Bashmetim> hadn't even heard of either, but I guess it's all about the proof systems I guess
21:17:14 <dramforever> all those notations?
21:17:19 <bb010g> IMHO, Ruby's better than Python for learning. It's more like a LISP in its consistency, which is nice for grasping concepts.
21:17:33 <dramforever> IMHO the math language is the worst part of math
21:17:54 <mjrosenb> bb010g: aren't there like 6 types of functions in ruby?
21:18:03 <dramforever> ruby..
21:18:10 <dramforever> in ruby () is the same as nil
21:18:16 <Bashmetim> I learned C first (I'm a sinner) and I really appreciate the sort of knowledge it gave me
21:18:18 <dramforever> soooo lispy..
21:18:24 <dramforever> Bashmetim ++
21:18:37 <bb010g> dramforever: wat
21:18:38 * dramforever is still using C++ a lot
21:18:38 <bb010g> TIL
21:18:41 <kadoban> I learned C near the beginning, that doesn't mean it was a good idea.
21:18:45 <dramforever> bb010g: try yourself
21:18:50 <bb010g> dramforever: Just did
21:19:05 <Bashmetim> I think that the language should be dead in the next 50 years or so, but I still think low-level understanding is important, conceptually
21:19:06 * mjrosenb used c++ a lot at his previous job, way better than the java I'm writing now.
21:19:11 <dramforever> I wonder what described it
21:19:16 <BJangles> Bashmetim why does learning C make you a sinner?
21:19:22 <mjrosenb> bb010g: I don't think C will ever die.
21:19:25 <mjrosenb> err
21:19:35 <mjrosenb> Bashmetim: I don't think C will ever die.
21:19:35 <slack1256> unless unix dies too
21:19:37 <dramforever> C will live on
21:19:45 <Lokathor> it might get to the point where new projects aren't started in C any more though
21:19:52 <Bashmetim> Because C is ugly, hacky, unmaintainable, insecure, low level, and basically just an assembly macro language
21:20:14 <Bashmetim> mjrosenb never say never, computers will be around a long time
21:20:17 <bb010g> Rust is a nice way to get rid of C.
21:20:21 <Lokathor> the same way that i doubt too many people are rushing to go write up new perl things
21:20:37 <Bashmetim> people said the same thing about assembly, but so few people program on the metal these days
21:20:45 <bb010g> I remember trying to self-teach Perl a couple of years ago. It didn't go well.
21:21:21 <Bashmetim> People were skeptical once that a compiler could *ever* produce faster code than a human, but now I'm skeptical if a human tells me they can optimize a program better than the compiler!
21:21:34 <bb010g> mjrosenb: Have you checked out Project Lombok?
21:21:41 <rcyr> Bashmetim: Same.
21:22:02 <Bashmetim> bb010g: http://glyphic.s3.amazonaws.com/ozone/mark/periodic/Periodic%20Table%20of%20the%20Operators%20A4%20300dpi.jpg
21:22:18 <dramforever> Bashmetim: "I can invent a better algorithm for this"
21:22:43 <mjrosenb> Bashmetim: on the other hand, I know someone who makes their living writing MUMPS code.  That *should* have been dead decades ago.
21:22:53 <mjrosenb> bb010g: nope.  link?
21:23:06 <Bashmetim> is MUMPS an... architecture?
21:24:23 <bb010g> mjrosenb: https://projectlombok.org/ Also, the folks on ##java are relatively nice and some of the lombok devs hang out there
21:24:25 <mjrosenb> Bashmetim: https://en.wikipedia.org/wiki/MUMPS
21:24:36 <Bashmetim> http://jnb.ociweb.com/jnb/jnbJan2010.html - A Java thing?
21:25:23 <mjrosenb> Bashmetim: also: http://thedailywtf.com/articles/A_Case_of_the_MUMPS
21:25:31 <slack1256> Turtle for scripting is great but what about for interactive shells?
21:25:35 <Bashmetim> MUMPS: First appeared 1966 \ Stable release ANSI X11.1-1995 / December 8, 1995
21:25:54 <Bashmetim> 50 years old, no update for 20
21:26:01 <Bashmetim> that's cold
21:26:56 <rcyr> MUMPS sounds like a disease
21:27:00 <Bashmetim> mixed case sensitivity and case insensitivity? WHY?
21:27:32 <BJangles> What do programmers do for a living?
21:27:38 <BJangles> Like....really
21:27:50 <BJangles> Sorry guys
21:27:51 <AbelianGrape> OK, looks like it might not be possible to use 128 bit floats in Haskell. Alternate question: Why is there no Floating instance for Data.Fixed?
21:27:54 <slack1256> mostly bitch on #haskell
21:27:58 <BJangles> Ahahah
21:27:59 <slack1256> I know I do
21:28:11 <BJangles> Sounds like a good job slack1256
21:29:32 <Lokathor> BJangles, mostly people tell you about problems they have, and you have to fix them. like any other job really
21:29:45 <saulzar> AbelianGrape, There's a package called 'compensated' which might give you something similar (maybe not quite as efficient)
21:29:48 <Bashmetim> BJangles we write programs... specifically programs that some clueless white guy can wants to *pay* to make happen
21:29:57 <Lokathor> rcyr, mumps IS a disease
21:29:58 <BJangles> Ah I see. So programmers are the doctors of tech world
21:30:06 <rcyr> Ha
21:30:06 <mjrosenb> BJangles: programmers write or maintain code, the number of possible applications is nearly infinite.
21:30:14 <BJangles> Sounds intriguing
21:30:24 <BJangles> Heard about that thing about john
21:30:27 <BJangles> Whats his face
21:30:28 <Bashmetim> BJangles, no those are system administrators
21:30:35 <Bashmetim> (my other job)
21:30:38 <BJangles> The ibm thing
21:31:03 <BJangles> John Titor
21:31:05 <slack1256> BJangles: how old are you?
21:31:06 <Bashmetim> mjrosenb actually, it's uncountably infinite :)
21:31:16 <BJangles> What was that about with John Titor? I was still a kid back then xD
21:31:36 <pacak> #haskell-blah?
21:31:36 <BJangles> Im 21 completely ignorant about programming
21:31:44 <BJangles> And kind of a troll
21:31:48 <AbelianGrape> saulzar: Thanks, but I need something with a Floating instance. I'm using these with Data.Dimensional, so I don't have a lot of liberty in how I structure my numeric operations
21:32:18 <BJangles> No one has a clue about John Titor?
21:32:25 <bitemyapp> I know the reference
21:32:26 <BJangles> Eh ok
21:32:35 <bitemyapp> I just don't really want to encourage your offtopic conversation.
21:32:35 <BJangles> So is it true
21:32:42 <bitemyapp> BJangles: #haskell-blah
21:32:46 <BJangles> I do it often
21:32:56 <BJangles> Dissuading the vast majority
21:32:57 <bitemyapp> BJangles: that's fine, do it in -blah.
21:33:03 <BJangles> Blah?
21:33:06 <bitemyapp> #haskell-blah
21:33:06 <saulzar> AbelianGrape, Compensated has a Floating instance by the looks
21:33:10 <Bashmetim> Or just talk about haskell, you did just stumble in because you saw there were a lot of us
21:33:14 <saulzar> instance Compensable a => Floating (Compensated a) where
21:33:24 <BJangles> Fine fine
21:36:31 <AbelianGrape> saulzar: No? it required the type parameter to be Floating, but it doesn't make a new Num type, as far as I can tell
21:37:25 <AbelianGrape> saulzar: Although I may be reading this wrong. The type family could be confusing haddock
21:37:46 <AbelianGrape> saulzar: Yep, that's it
21:37:48 <AbelianGrape> Thanks!
21:37:48 <saulzar> AbelianGrape, Yeah.. looking at the haddock and the source and it doesn't seem to list all the instances ?!
21:37:57 <AbelianGrape> It's because of the type family I think'
21:40:27 <EvanR> bitemyapp: thx for directing him to -blah
21:40:32 <EvanR> NOT
21:40:36 <Lokathor> guys i gotta say something
21:40:38 <Lokathor> this stack thing
21:40:40 <Lokathor> is magical
21:40:54 <Lokathor> i told it to do the thing, and it just did the thing, didn't argue with me
21:40:58 <AbelianGrape> saulzar: Gah. Cabal is getting confused by the dependencies
21:40:59 <Lokathor> magic
21:42:35 <AbelianGrape> Looks like Compensated isn't maintained :(
21:47:34 <GLM> If I have a type that is a union, is there a way to have a function that takes only own of those types>
21:50:08 <AbelianGrape> GLM: It's not two separate types. They are both the same type
21:50:20 <AbelianGrape> And yes, you just don't write the definition for one of the constructors
21:50:40 <sm> Lokathor: it's a bit weird to not have the tool argue, isn't it
21:50:40 <dmj> AbelianGrape: then it's a partial function
21:50:41 <AbelianGrape> Unless I'm misunderstanding your question
21:50:48 <AbelianGrape> dmj: Yes, it is
21:50:53 <dmj> :(
21:50:57 <AbelianGrape> I agree
21:51:04 <Lokathor> sm: it's like i'm not even programming in haskell any more
21:51:10 <GLM> AbelianGrape:So how do I switch on the values?
21:51:42 <AbelianGrape> GLM: Can you give me an example?
21:52:07 <GLM> data Test = Foo Int Int | Bar String
21:52:14 <GLM> I want a function that can take a Foo
21:52:30 <AbelianGrape> f (Foo 0 1) = 5
21:52:31 <sm> Lokathor: not to worry, GHC will still beat you 
21:53:50 <GLM> AbelianGrape:Can I have something of f :: Foo -> String
21:53:54 <saulzar> AbelianGrape, I guess it's probably not too far behind, given the last updated was 2014 ..
21:54:43 <pseudomeme> hi everyone. I'm a bit of a Haskell noob, so I was hoping I could get some design advice. I have this simplification of a module I'm making: http://lpaste.net/139055.
21:54:52 <bob_twinkles> GLM: not if you declare Test like that, or are willing to have partial functions
21:54:52 <pseudomeme>  The thing is, I want to be able to have variations on 'A' that use a different 'inner' function. I could use some advice on how to go about that.
21:54:54 <dmj> GLM: no, Foo is value, not a type, two different worlds
21:54:59 <AbelianGrape> GLM: Foo is not a type, so no
21:55:08 <pseudomeme> My naive thought was to use a class with an 'inner' method, but I don't know how I could do that so all the other functions are still the same. Like, I want to be able to specify a new variation and only have to give a different inner function for it.
21:55:09 <bob_twinkles> you can kinda fake it with GADTs and DataKinds
21:55:13 <bob_twinkles> it's ugly though
21:55:30 <bob_twinkles> GLM: ^
21:55:55 <slack1256> pseudomeme: Are you doing something like a left-module or vector space?
21:57:01 <pseudomeme> slack1256: I have no idea what those are :/
21:57:10 <pseudomeme> I'm working on an artificial neural network
21:57:43 <pseudomeme> and I want all of the mechanics to be the same, just having the ability to choose which sum functions are used by which data type you choose
21:57:45 <pseudomeme> or something like that?
21:58:38 <slack1256> if each data-type has only *one* sum function that is actually a case where type-classes shine
21:58:49 <pseudomeme> the mechanics are currently all based on maps and I want all of that implementation to be hidden in the module because someone using it really doesn't need to know the implementation. And someone wanting to provide different sum functions also doesn't need to know how it's implemented
21:59:09 <bitemyapp> EvanR: yer
21:59:49 <pseudomeme> slack1256: there are 2 functions that would need to be customized for each network, actually
22:00:03 <pseudomeme> like an 'inner1' and 'inner2' at least as far as my lpaste goes
22:00:16 <slack1256> oh OK
22:00:51 <slack1256> you can pass either inner1 or inner2 in the same way you pass to for example foldr
22:00:54 <slack1256> @type foldr
22:00:55 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
22:01:29 <pseudomeme> I was thinking it could be a type argument to 'A'
22:01:34 <slack1256> you can do basically the same with your maps and make a functions that takes an *innerN* and a maps and does its business
22:01:41 <pseudomeme> because the function should be the same for each instance of 'A'
22:02:47 <pseudomeme> but because the function choices are very regular and common I was thinking it would be nice to be able to instead have a 'A1' and 'A2' and so on, which each automatically use different inner functions
22:03:46 <mjrosenb> i'm looking at the lens tutorial, are there lenses for updating elements of a Map?
22:03:59 <mjrosenb> well, updating, accessing, etc.
22:04:20 <shachaf> "the lens tutorial"?
22:04:45 <mjrosenb> http://lens.github.io/tutorial.html
22:04:56 <shachaf> Anyway, the answer is yes. The main answer is "at".
22:06:07 <shachaf> Oh, it's even in the page you linked. Did you want more information?
22:06:35 <mjrosenb> I'm guessing this would fall into the category of prisms?
22:07:02 <shachaf> No, it just gives you a regular lens.
22:07:38 <mjrosenb> ahh, indeed.
22:08:02 <shachaf> There's also ix, where ix k = at k . traverse
22:09:47 <slack1256> pseudomeme: on http://lpaste.net/139055 I did an edit. Is that like what you want?
22:10:27 <zipper> Easiest way to get "is a sentence" from "This is a sentence"
22:11:01 <pacak> zipper: drop 5.
22:11:16 <mjrosenb> and & is not from lens, but the arguments-reversed $ operator?
22:11:23 <zipper> Nooooo
22:11:27 <zipper> pacak: ^
22:11:27 <pacak> zipper: YES!
22:11:40 <zipper> Like `dropWhile (/=' ') "This is a sentence"` then drop the space
22:12:07 <shachaf> (&) used to be from lens but now it's in base.
22:12:08 <nitrix> dropWhile is probably better than wording and unwording.
22:12:11 <shachaf> It's flip ($)
22:12:14 <nshepperd> const "This is a sentence" :)
22:12:22 <slack1256> > drop 1 . words $ "this is a sentence"
22:12:24 <lambdabot>  ["is","a","sentence"]
22:12:28 <pacak> nshepperd: "is a sentence".
22:12:32 <slack1256> > unwords . drop 1 . words $ "this is a sentence"
22:12:34 <lambdabot>  "is a sentence"
22:12:35 <nshepperd> uh yeah, that
22:13:10 <dmj> shachaf: wonder why it didn't make Prelude
22:13:16 <pseudomeme> slack1256: hmmmmmmmmm. While it's not exactly what I want it really helps me understand a way to get what I want. Let me try to modify what you have into what might work for me
22:13:18 <nshepperd> 'unwords . f . words' destroys whitespace, btw
22:13:22 <shachaf> I didn't even want it to go into base.
22:13:43 <shachaf> But it certainly shouldn't go into Prelude. Changes to Prelude are irreversible without major compatibility breaking.
22:13:47 <slack1256> oh, you're right
22:13:51 <nshepperd> > unwords . drop 1 . words $ "this is        a \n sentence"
22:13:53 <lambdabot>  "is a sentence"
22:14:02 <nitrix> slack1256: Yeah but that has unecessary O(n) though.
22:14:02 <nitrix> Twice actually.
22:14:02 <nitrix> dropWhile (/=' ') short circuits early :]
22:14:19 <zipper> nvm, I did it.
22:14:38 * slack1256 something something micro optimization something :-)
22:14:56 <pacak> zipper: We are not done helping you just yet!
22:15:04 <Zemyla> dropWhile isSpace . dropWhile (not . isSpace) $ "this  is  a  sentence"
22:15:11 <zipper> pacak: LOL
22:15:23 <nshepperd> zipper: also, you may or may not want to handle "    this has leading whitespace"
22:15:29 <dmj> shachaf: removals from Prelude yes, maybe not additions though 
22:15:31 <Zemyla> > dropWhile isSpace . dropWhile (not . isSpace) $ "this  is  a  sentence"
22:15:33 <lambdabot>  "is  a  sentence"
22:15:45 <zipper> nshepperd: I want to get rid of the leading whitespace.
22:15:46 <shachaf> Additions too, though slightly less major.
22:16:04 <shachaf> But I meant that it's irreversible. And there's almost no point to it.
22:16:09 <slack1256> > (++ "?") . dropWhile isSpace . dropWhile (not . isSpace) $ "this  is  a  sentence"
22:16:11 <lambdabot>  "is  a  sentence?"
22:16:18 <zipper> Okay let me tell you what my issue is. I am trying to get the dependent files from modules that use template haskell.
22:16:37 <zipper> So I get these dumps from ghc that have sections such as:
22:17:12 <zipper> `addDependentFile "templates/homepage.julius"`
22:17:43 <zipper> I used this to get only the dependent file `dropWhile (/='\"')`
22:18:06 <zipper> > dropWhile (/='\"') "addDependentFile "templates/homepage.julius""
22:18:08 <lambdabot>      Not in scope: ‘templates’
22:18:08 <lambdabot>      Perhaps you meant ‘template’ (imported from Data.Data.Lens)Not in scope:...
22:18:49 <zipper> > dropWhile (/='\"') "addDependentFile \"templates/homepage.julius\""
22:18:51 <lambdabot>  "\"templates/homepage.julius\""
22:18:57 <zipper> Something like that
22:19:00 <pacak> zipper: What exactly are you trying to achieve?
22:19:49 <zipper> I just said it. Get the dependent file section from the result of -ddump-hi from ghc
22:20:05 <zipper> It's quite a story.
22:20:08 <zipper> lol
22:20:22 <pacak> But that can't be your goal. It's a part of your solution.
22:21:43 <slack1256> sub-goal
22:22:13 <Big_G> How do I overload a function for two primitive types?
22:22:23 <nshepperd> maybe zipper is trying to write a scanner for a build tool? I wrote a similar thing to extract inter-module dependencies
22:22:30 <slack1256> his grand goal probably is getting some pixels bright on some specified pattern
22:22:41 <Zemyla> Write a typeclass.
22:22:43 <pacak> nshepperd: ghc -M...
22:23:15 <pacak> Big_G: Or use a sum type
22:23:27 <nshepperd> pacak: is that ahead of time and also fast?
22:23:33 <pseudomeme> slack1256: I realize this is not valid Haskell, but it better represents what I'm kind of trying to do. Where A1 and A2 don't have to worry about the data being operated on, they're only there so the type system knows which inner funciton to use: http://lpaste.net/139055
22:23:39 <zipper> Oh my goal. I am trying to get a better way to watch for file changes in wai-devel.
22:23:52 <Big_G> pacak, I tried that but the functions couldn't tell the actual types of the values then
22:24:12 <zipper> So I want to know all files to watch for by knowing which files ghc compiled and which ones template haskell generated
22:24:15 <pacak> nshepperd: It's kind of fast, at least works fine on a project with ~500 modules
22:24:19 <zipper> or used
22:24:35 <zipper> pacak: I just explained it
22:24:48 <liste> Big_G which approach did you try?
22:25:06 <Big_G> liste, The type sum
22:25:07 <Zemyla> I don't know what wai-devel is, but it makes me think of kawaii.
22:25:14 <pacak> zipper: I used ghc -M for something similar.
22:25:19 <zipper> pacak: Trying to solve https://github.com/urbanslug/wai-devel/issues/1
22:25:22 <pacak> Makefile is easy to parse.
22:25:46 <zipper> Well I am relying on a package, ide-backend, for all this so I don't want to go to GHC directly.
22:26:01 <zipper> or invoke bash.
22:27:32 <lpaste_> liste pasted “Big_G something like this?” at http://lpaste.net/139059
22:28:01 <zipper> hahaha wait someone here is called Big_G in my country we have this gum called Big G
22:28:07 <zipper> What a coincidence
22:28:23 <Big_G> zipper, I'm actually the heir to that dynasty
22:28:33 <Big_G> liste, No, I did Value = Int | Double
22:29:12 <liste> Big_G those are just tags that carry no values
22:29:22 <zipper> Big_G: Is there Big G in your country too? lol maybe Big G isn't even from/made here. What do I know.
22:29:54 <Big_G> liste, What would be the best way to do what I want then?
22:30:05 <nshepperd> pacak: cool, I might use that next time
22:30:45 <slack1256> pseudomeme: from what I understand of the intentions of that code, A1 and A2 are being used as tags for their corresponding inners functions. So when an (A A1) is passed to processA the correct inner function will be used
22:30:48 <zipper> Anyway bye, thanks,
22:31:02 <zipper> Big_G: pacak Have a good day.
22:31:03 <pseudomeme> slack1256: yes, exactly
22:31:10 <liste> Big_G that way I did in the paste, if you can put the values in your own type
22:31:40 <slack1256> this is doable but overly complicated. As processA can be made a higher order function on the style of foldr or map
22:31:41 <pseudomeme> I can't remember it, but there is a similar package I've used before, where you can pass those kinds of tags to determine what kind of data type you're using
22:31:57 <pseudomeme> it had tags like U and P and F
22:32:00 <Big_G> liste, Isn't that a bit overkill? I just want to overload some functions
22:32:02 <pseudomeme> or something like that
22:32:26 <slack1256> a haskell package?
22:32:58 <pseudomeme> slack1256: for this particular use case yes it would be overly complicated and a higher order processA would be very usable. I'm just taking this opportunity to both future proof this and to learn a bit about design
22:33:09 <pseudomeme> yes, a Haskell package, but I can't remember which
22:33:14 <pseudomeme> something mathy I think?
22:33:37 <lpaste_> liste revised “Big_G something like this?”: “Two approaches to Big_G's question” at http://lpaste.net/139059
22:33:40 <liste> Big_G the alternative (type classes) would be overkill
22:33:45 <liste> see my revised paste
22:34:22 <Big_G> The first one is better but it feels like it is more complicated than it should be
22:36:51 <liste> you mean the introduction of a new type?
22:37:10 <Big_G> liste, Yeah
22:37:50 <slack1256> pseudomeme: I think that design is very brittle and not possibly working. I mean the HasInner type class doesn't even refeer to the 't' in its inner method. What you probably want is just pure records. I will do a diff
22:38:13 <pseudomeme> ugh, it's on the tip of my mind, but I can't remember the package. I remember it being something about performing operations in parallel. Like on a matrix or something. But it would handle the processing differently depending on the tag you chose
22:38:58 <pseudomeme> slack1256: do you just mean providing the function to the constructor?
22:39:20 <liste> types are cumbersome in many languages (Java, I look at you!) but not Haskell so they're used all over the place
22:39:32 <liste> > (Sum 3) <> (Sum 5) <> (Sum 7)
22:39:34 <lambdabot>  Sum {getSum = 15}
22:40:47 <Big_G> liste, I suppose. I feel like I'll be converting from this wrapped Int to actual Int all day
22:40:49 <pacak> > foldMap Sum [3,5,7]
22:40:51 <lambdabot>  Sum {getSum = 15}
22:42:12 <dmj> pacak: nice
22:42:18 <eds> Could not deduce (Show a). Code and error: http://lpaste.net/137809
22:42:28 <eds> If someone can help me out.
22:42:47 <slack1256> pseudomeme:  yes!
22:42:53 <liste> Big_G yeah it can feel annoying but there are ways to ease it as you learn more
22:43:44 <liste> like functors and some stuff at lens
22:43:48 <pseudomeme> slack1256: that would definitely work here. And it would definitely be appropriate. But there are just really common function combinations, which makes me feel like it's not exactly the right design
22:44:08 <pseudomeme> I guess I could use type synonyms for the common combinations. hmmmm
22:44:20 <dmj> eds: your defintion of Expr constrains List on Show
22:44:26 <Big_G> liste, So I'm stuck with the wrapper for now?
22:45:14 <liste> Big_G yeah I think it's the cleanest solution
22:45:23 <Big_G> liste, Thanks. 
22:45:33 <eds> dmj: Ohh so what can I do here?
22:45:38 <dmj> eds: w/o understanding any of the code, try adding Show a to the Rando instance
22:45:48 <dmj> instance (Show a, Rando (Expr vs a)) => Rando (Expr vs [a])
22:45:48 <eds> dmj: `deriving instance Show a => Show (Expr vs a)` would this not solve that issue?
22:46:09 <eds> dmj: Ohk let me try that.
22:46:22 <slack1256> pseudomeme: Sorry, I can't really understand the constraints of your problem. I guess the only thing you can do is consider different designs on the wild of different libraries and think if they fit better
22:46:27 <liste> there are real union types in Ceylon but I'm not sure how they play with Haskell's type system
22:46:58 <slack1256> pseudomeme: personally. I try to use this http://www.haskellforall.com/2012/08/the-category-design-pattern.html when possible
22:48:35 <eds> dmj: yup, that worked. thanks.
22:49:48 <pseudomeme> slack1256: oh thank you! I actually really love the category design pattern (at least based on the first few paragraphs I think it's the thing I love) but have never had such a formal description of it, and especially not Haskell specific
22:50:22 <pseudomeme> this is great. Hopefully it'll help me figure out how to approach what I'm doing. Thanks!
22:51:01 <slack1256> pseudomeme: actually behind all the theory category theory for programmers usually boils down to what tekmo exposes on that blogpost. 
22:51:41 <shachaf> I disagree.
22:54:21 <dmj> eds: cool
22:57:48 <dmj> eds: side note, the stand alone deriving instance Show a => Show (Expr vs [a]) might have worked too, note the [a]. Show a => Show [a] exists, but not Show a => Show (Expre vs [a])
23:00:00 <eds> dmj: ahh that makes sense! So, deriving instance Show a => Show (Expr vs a), does not imply Show [a]. I would need to make an instance for Expr vs [a]. 
23:03:58 <dmj> eds: I'd try it to be sure, would be interesting if you revert the instance declaration to what you had before, but made the stand alone deriving be Show a => Show (Expr vs [a]) would it have resolved
23:04:28 <pseudomeme> does anyone know what this package might be? I can only barely remember it, but it is something for doing lots of computations in parallel. I think you put your data into an array like structure and can then compose operations on the structure that run in parallel or not
23:05:32 <Ralith> pseudomeme: repa?
23:05:45 <pseudomeme> YES
23:06:01 <pseudomeme> thank you!
23:08:48 * hackagebot llvm-pretty 0.4.0.0 - A pretty printing library inspired by the llvm binding.  https://hackage.haskell.org/package/llvm-pretty-0.4.0.0 (TrevorElliott)
23:09:52 <mauris> i had an idea today that's so haskelly it has to already exist:
23:11:27 <mauris> some way to describe a "format string" for a type (using combinators like parsec) that works both ways (show/read)
23:11:49 <johnw> there are bidirectional parsing/formatting libraries
23:12:28 <mauris> johnw: do you know of an example?
23:12:48 <johnw> https://hackage.haskell.org/package/syntax
23:12:52 <johnw> https://hackage.haskell.org/package/invertible-syntax
23:13:05 <johnw> and http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf
23:13:48 * hackagebot llvm-pretty-bc-parser 0.2.0.0 - LLVM bitcode parsing library  https://hackage.haskell.org/package/llvm-pretty-bc-parser-0.2.0.0 (TrevorElliott)
23:14:03 <solidus-river> hey all, is there a way for me to tell cabal to place the sandbox somewhere besides the projects root?
23:14:13 <johnw> there's a command-line option to do that
23:16:19 <solidus-river> ?
23:16:27 <solidus-river> sorry guys wrong channel for the ?
23:17:25 <dmj> solidus-river: you can edit the cabal.sandbox.config file to specify a different directory for .cabal-sandbox other than the default
23:18:24 <dmj> solidus-river: I think johnw answered your question though
23:19:55 <dmj> oh he quit :)
23:20:11 <johnw> drive-by questions
23:20:18 <johnw> get in, get answered, get out
23:23:16 <AaronFriel> Modulo registerization - does parameter order matter for things like accumulating parameters, placing strictness annotations? 
23:23:41 <AaronFriel> Is it a bad idea to have go !a b !c - for any reason other than it looking strange?
23:24:26 <dmj> johnw: :)
23:24:48 <AaronFriel> I have a continuation passing transform that makes it convenient to return (go foo) at some points, so the parameter order is convenient
23:26:41 <AaronFriel> but if there's some reason I should reorder it, I can replace my (go foo)s, e.g.: by rewriting go !a b !c as go b !a !c, and returning (\b c -> go b foo c)
23:28:41 <startling> I would be surprised if it did but I don't actually know.
23:30:47 <AaronFriel> I am guessing GHC's optimizations will do enough to mangle parameter order (esp. with inlining, reductions, continuations) that I couldn't predict it anyhow
23:32:45 <johnw> I really don't think parameter order has any meaning
23:33:01 <johnw> same with x `seq` y `seq` z
23:33:11 <johnw> you are only guaranteed that x and y will both be forced before z, not in what order
23:33:34 <johnw> actually, it might not even be before z
23:33:42 <johnw> just that all three will happen
23:36:55 <lpaste_> liste pasted “Is this a good idea?” at http://lpaste.net/139071
23:37:59 <johnw> liste: see http://chrisdone.com/posts/identity-monad
23:40:04 <liste> cool!
23:44:08 <kazagistar> I'm a little bit uncomfortable with how I to deal with stacks nicely... anyone have some style tips on this function? https://github.com/kazagistar/okasakish/blob/master/src/leftist_heap.rs#L125
23:44:32 <Zekka> kazagistar: Are you sure this is the channel you meant? This is a Haskell channel
23:44:36 <kazagistar> derp
23:44:39 <kazagistar> sorry
23:44:41 <Zekka> there are probably people here who know rust but I'm not personally one of them
23:44:43 <Zekka> Don't worry about it
23:45:09 <tzaeru> I laughed a little, because I've haskell and rust channels side-by-side in my irc client :P
23:45:20 <tzaeru> could easily make a similar mistake.
23:45:57 <kazagistar> see, in Haskell all this would be easy, but I am masochistic enough to try go through Okasaki in Rust :P
23:46:45 <liste> what next? malbolge?
23:48:09 <tzaeru> how about http://pelulamu.net/ibniz/ ?
23:48:36 <tzaeru> damn. the web implementation is down.
23:50:26 <_riba> hello, i'm new to advanced haskell and i'm quite confused. i have here a function continue :: s -> EventM (Next s) and the documentation says i can do IO inside of the event monad with liftIO, but i don't quite understand how. if this: liftIO :: MonadIO m => IO a -> m a is the right function... does it mean it will automatically know that "m" is the EventM?
23:51:11 <dmj> _riba: if EventM is an instance of MonadIO, yes
23:52:14 <ttt_fff> anyone familiar with http://www.andres-loeh.de/LambdaPi/ ?
23:52:31 <pacak> _riba: it will work  if EventM is an instance of MonadIO
23:52:40 <_riba> the documentation says "this monad is a transformer around IO"
23:53:04 <_riba> but i don't quite see it from the source
23:53:25 <_riba> (i'm trying to use brick, if anyone is familiar with it)
23:53:45 <pacak> _riba: It should say "instance MonadIO EventM"
23:53:50 <pacak> somewhere
23:53:51 <dmj> _riba: in ghci do ":i EventM", see if MonadIO EventM shows up
23:56:04 <_riba> actually it doesn't, so i wonder why the documentation says "you're free to do I/O in this monad by using liftIO"
23:56:09 <_riba> oh well, thank you
23:56:20 <_riba> there is another function that halts the state for doing IO, i guess i'll just use that one
23:56:28 <_riba> *suspends
23:56:36 <dmj> _riba: is this for the gtk package?
23:57:10 <_riba> dmj, it's from brick https://github.com/jtdaugherty/brick
23:57:14 <kazagistar> _riba: are you familiar with monad transformers?
23:58:30 <kazagistar> oh, I was scrolled up and responded to like 10 min ago. time to sleep
23:58:39 <_riba> i... read about them. to be honest i just need to write a text editor with syntax highlighting for some course, with no other information given, so i'm kinda going along with what i can find
