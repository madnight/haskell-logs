00:04:52 <AjaxCrixum> Would someone be so kind as to do a novice programmer a huge favor?
00:05:16 <AjaxCrixum> (Not really huge or complicated, though.)
00:05:41 <cocreature> AjaxCrixum: just ask your question directly :)
00:05:54 <Gurkenglas> Doing programming problems isn't tiresome, reading empty phrases is
00:06:18 <AjaxCrixum> Okay, here goes:
00:06:48 <Gurkenglas> (It's why you don't see me saying thanks every time a question is answered, though I usually am thankful.)
00:07:35 * hackagebot reflex-dom 0.2 - Functional Reactive Web Apps with Reflex  https://hackage.haskell.org/package/reflex-dom-0.2 (RyanTrinkle)
00:07:35 * hackagebot cgrep 6.5.2 - Command line tool  https://hackage.haskell.org/package/cgrep-6.5.2 (NicolaBonelli)
00:08:12 <AjaxCrixum> I've dabbled with the basics of C and even made a small, basic file manager (http://pastebin.com/bm1w2EmP). However, Haskell captures my interest more, and, though I intend the do the following myself, I'd really appreciate it if someone could write my file manager in Haskell, just so I could get a realtime example of how more succinct and different Haskell is to C. :)
00:08:14 <Zemyla> down_with_otp: What does your nick mean?
00:08:43 <MarcelineVQ> ain't nobody gonna do that for you, however I bet someone could find the source of a file manager written in haskell
00:09:06 <AjaxCrixum> MarcelineVQ: Probably not. lol
00:09:08 <down_with_otp> zemyla down with open telecom platform of course =]
00:10:14 <eazar001> Zemyla: i think it's an a pun on erlang's OTP in rerference to this song: https://www.youtube.com/watch?v=uFTBG1sae0M
00:10:19 <MarcelineVQ> http://code.haskell.org/haskellfm/
00:10:58 <MarcelineVQ> I don't know anything about this project, but it's supposedly a haskell-based file manager, so have a look
00:11:46 <MarcelineVQ> Seems to include a UI so that might be more complex than you're looking for
00:12:29 <cocreature> AjaxCrixum: I doubt anybody is going to write that code for you but if you start writing it and ask here if you have problems or ask for other people to review it when you are done you're most likely going to get answers
00:19:05 <AjaxCrixum> What do you guys think about a language called Lisp/LISP?
00:19:20 <johnw> why would that be relevant here?
00:20:54 <AjaxCrixum> It's really not. I was just wondering what Haskellers thought of the langauge, since they both are (capable of being) in the same paradigm and all.
00:21:19 <johnw> Lisp is a great language, but I'm not sure I could even begin to compare them in a meaningful way
00:22:26 <gfixler> AjaxCrixum: Lisp is a family of languages, and there are tons of examples in the family
00:22:54 <gfixler> AjaxCrixum: Lisp is simple enough to implement yourself, and the MAL (Make A Lisp) project on Github helps you do this
00:24:53 <gfixler> AjaxCrixum: I have a friend who believes in learning languages paradigms over languages themselves
00:25:08 <gfixler> AjaxCrixum: i.e. if you know Python, Ruby isn't really going to change your whole view on programming
00:26:34 <gfixler> AjaxCrixum: Assembly, C, Lisp, Forth, Prolog, ML/Haskell - these all come at the computing problem from fairly different angles
00:27:31 <gfixler> you'll always pick up new things here and there in any language, of course
00:30:11 <mniip> gfixler, that very true though
00:30:15 <mniip> is*
00:58:41 <Gurkenglas> putStr won't output stuff until the next time a newline character is pushed to the output, right?
00:59:47 <shachaf> No.
00:59:56 <lfairy> Gurkenglas: if the handle is line buffered, yes
01:06:14 <Taslem> How do I make "cabal build" show all warnings? I'm getting a runtime error from "Non-exhaustive patterns in ..." but it isn't warning me about it at compile-time
01:06:41 <Taslem> Or, why is "cabal build" _not_ showing me these warnings?
01:07:32 * hackagebot blaze-html 0.8.1.0 - A blazingly fast HTML combinator library for Haskell  https://hackage.haskell.org/package/blaze-html-0.8.1.0 (JasperVanDerJeugt)
01:15:14 <Gurkenglas> Why isn't there foldrM?
01:15:18 <cocreature> Taslem: iirc it's --ghc-options=-Wall
01:15:36 <cocreature> Gurkenglas: there is https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Foldable.html#v:foldrM
01:15:54 <Gurkenglas> Thanks! Looked in the wrong place, then.
01:16:01 <Taslem> cocreature: thanks, I realized that somewhere along the way
01:16:16 <Taslem> I I wish there was a way that didn't depend on passing ghc flags
01:16:40 <cocreature> you can set the option permamently in your cabal file if that helps
01:17:25 <Taslem> yeah, that would definitely help
01:17:33 * hackagebot hakyll 4.7.2.1 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.7.2.1 (JasperVanDerJeugt)
01:18:17 <cocreature> Taslem: look for the ghc-options field here https://www.haskell.org/cabal/users-guide/developing-packages.html#package-descriptions
01:20:46 <Gurkenglas> :t \f -> foldr f undefined . repeat -- What should I use instead of this?
01:20:48 <lambdabot> (a -> c -> c) -> a -> c
01:25:55 <cocreature> Gurkenglas: are you looking for foldr1?
01:26:00 <Gurkenglas> Nope.
01:26:03 <Gurkenglas> Ah, of course!
01:26:06 <Gurkenglas> :t (fix .)
01:26:07 <lambdabot> (a -> c -> c) -> a -> c
01:26:26 <Gurkenglas> (It's a fix point, geddit? hyuk hyuk)
01:55:25 <Gurkenglas> Does something provide foreverWhile :: IO Bool -> IO ()?
01:57:40 <dibblego> what would this do? there is a loops package
02:01:12 <Gurkenglas> :t foreverWhile one = (one >>=) $ \b -> if b then foreverWhile one else return ()
02:01:13 <lambdabot> parse error on input ‘=’
02:02:49 <Gurkenglas> Ah, that loops package looks like it'll be usefull.
02:14:41 <simon> @let foreverWhile one = (one >>=) $ \b -> if b then foreverWhile one else return ()
02:14:43 <lambdabot>  Defined.
02:14:48 <simon> :t foreverWhile
02:14:49 <lambdabot> Monad m => m Bool -> m ()
02:20:24 <Gurkenglas> @tell AjaxCrixum Here. http://lpaste.net/137710
02:20:25 <lambdabot> Consider it noted.
02:24:37 <catgocat> hello
02:36:47 <catgocat> @pl vert = replicate (length xs) "+-" ++ "+"
02:36:47 <lambdabot> vert = replicate (length xs) "+-" ++ "+"
02:40:37 <Gurkenglas> catgocat, http://lpaste.net/2108459910155993088
02:41:07 <Gurkenglas> (lamdabot doesn't know the utils so I put them in there)
02:41:39 <catgocat> nice
02:41:42 <catgocat> what is `Compose` ?
02:42:42 <arkeet> see Data.Functor.Compose
02:44:57 <Gurkenglas> It's not really needed, I just found it neat to have a Foldable instance for your whole board.
02:45:27 <Gurkenglas> I don't see what lambdabot means by board not being in scope, those all look pretty in scope to me.
02:45:27 <Gurkenglas> @letlpaste 2108459910155993088
02:45:28 <lambdabot>  .L.hs:197:25: Not in scope: ‘board’
02:49:28 <dramforever> hi, I have a question
02:49:43 <dramforever> is list stream fusion in ghc yet?
02:51:03 <opqdonut> dramforever: AFAIK in some form yes, namely build/foldr fusion
02:51:14 <dramforever> okay
02:51:22 <opqdonut> see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/rewrite-rules.html#idp26293440
02:52:36 <dramforever> thanks!
02:53:03 <opqdonut> IIRC there are list/stream libraries on hackage with better fusion
02:53:07 <catgocat> Gurkenglas: Maybe I could ask the user for the tile number and have it numbered like [1, 2, 3], [4, 5, 6] ..
02:53:18 <catgocat> the problem is: how would I convert the number to col and row ?
02:53:21 <dramforever> maybe
02:53:43 <dramforever> catgocat: there's a function for that!
02:53:48 <dramforever> :t index
02:53:48 <catgocat> what function
02:53:49 <lambdabot> Ix a => (a, a) -> a -> Int
02:53:57 <dramforever> it's used in arrays
02:54:03 <opqdonut> dramforever: see http://hackage.haskell.org/package/stream-fusion and https://ghc.haskell.org/trac/ghc/ticket/915
02:54:06 <catgocat> does it work on lists?
02:54:17 <dramforever> catgocat: let me show you this:
02:54:39 <dramforever> :t index ((1,1), (10, 10)) (4,7)
02:54:40 <lambdabot> Int
02:54:44 <dramforever> =(
02:54:49 <dramforever> > index ((1,1), (10, 10)) (4,7)
02:54:50 <lambdabot>  36
02:54:57 <catgocat> what
02:55:02 <opqdonut> dramforever: aaaand http://blog.ezyang.com/2014/01/pepm14-the-hermit-in-the-stream/
02:56:42 <consus> Hello
02:57:15 <dramforever> opqdonut: thanks for that!
02:57:21 <catgocat> dramforever: getting the row is pretty easy -> number `div` (number of rows)
02:57:30 <catgocat> > 7 `div` 3
02:57:31 <lambdabot>  2
02:57:38 <catgocat> > 4 `div` 3
02:57:39 <lambdabot>  1
02:57:49 <catgocat> now how would I get the column?
02:57:52 <dramforever> getting the col is easy too
02:57:54 <dramforever> use mod
02:58:01 <catgocat> how
02:58:04 <consus> Could someone tell me the easiest way to redefine exception message for e.g. IOException? I want to say '<progname>: failed to read attribute <foo>: <errno-to-text>' instead of the default one.
02:58:07 <dramforever> > 7 `mod` 3
02:58:07 <catgocat> > 8 `mod` 3
02:58:08 <lambdabot>  <no location info>: can't find file: L.hs
02:58:08 <lambdabot>  1
02:58:13 <Kind> how do i read output of shell command in a string in Turtle library?
02:58:17 <dramforever> now that's confusing..
02:58:28 <catgocat> mod doesnt work for that
02:58:37 <dramforever> catgocat: ?
02:58:59 <dramforever> consus: you should add your own exception handler
02:59:13 <catgocat> dramforever: what?? 7 is on the 0th col
02:59:19 <catgocat> 7 `mod` 3 returns 1
02:59:38 <catgocat> its wrong
02:59:49 <dramforever> > (7 - 1) `mod` 3
02:59:50 <lambdabot>  0
02:59:57 <dramforever> > (9 - 1) `mod` 3
02:59:58 <lambdabot>  2
03:00:16 <dramforever> catgocat: that isn't very much harder either
03:00:57 <catgocat> nice
03:03:27 <AleXoundOS> Hi. Which forum should I use to ask questions?
03:04:16 <dramforever> AleXoundOS: you can ask questions here, as well as on reddit and the mailing list
03:04:26 <dramforever> /r/haskell
03:04:41 <dramforever> the mailing list is called haskell-cafe
03:05:51 <catgocat> shorter way to do this:  concat ("+" : replicate y "-+")
03:05:55 <catgocat> ?
03:06:38 <dramforever> @hoogle Int -> [a] -> [a]
03:06:39 <lambdabot> Prelude drop :: Int -> [a] -> [a]
03:06:39 <lambdabot> Data.List drop :: Int -> [a] -> [a]
03:06:39 <lambdabot> Prelude take :: Int -> [a] -> [a]
03:06:48 <dramforever> =(
03:07:48 <AleXoundOS> dramforever, Ok. I'm familiar with IRC, but sometimes I cannot hang in chat for a long time. It can be easier to have one question/problem related thread in forum, where all answers are dedicated only to it. Also I'm not familiar with reddit.
03:08:18 <dramforever> /r/haskellquestions is dedicated to questions
03:09:00 <dramforever> AleXoundOS: don't worry reddit is pretty simple
03:12:38 * hackagebot LambdaHack 0.5.0.0 - A game engine library for roguelike dungeon crawlers  https://hackage.haskell.org/package/LambdaHack-0.5.0.0 (MikolajKonarski)
03:17:38 * hackagebot Allure 0.5.0.0 - Near-future Sci-Fi roguelike and tactical squad game  https://hackage.haskell.org/package/Allure-0.5.0.0 (MikolajKonarski)
03:33:08 <ppelleti> Hello.  Suppose I need to implement a pre-existing binary protocol (so I don't get to choose the encoding).  I know I can write a Binary instance, with separate get and put methods, but I don't like the non-DRY-ness of that approach.  Is there any way to specify the protocol encoding in one place, and then somehow automagically generate get and put methods?
03:35:07 * Maxdaman2us would caution against generating code for small gains.
03:35:40 <dramforever> ppelleti: so how large is the definition?
03:37:41 <ppelleti> There are a large number of fairly small messages.  Each message type has a fixed size (i. e. no variable length fields).
03:41:25 <ppelleti> So, it just seems like there's a lot of boilerplate to write for each message: define a record type, write a get method, write a put method.  I'd just been wondering if there was some library I didn't know about that solved that with Template Haskell or something, but it sounds like there's not.
03:58:38 <lush> yo)
03:59:51 <srhb> lush: Yo.
04:02:40 * hackagebot irc-ctcp 0.1.3.0 - A CTCP encoding and decoding library for IRC clients.  https://hackage.haskell.org/package/irc-ctcp-0.1.3.0 (barrucadu)
04:04:33 <lush> I've fetched some HTTP Requests from a website and now I want to write a program that is able to send such requests (to automatically upload replays of a game to analyse) but I've got no idea which library to use.. so I already got what the request should consist of (just have to change a name of a file),... is there a straightforward way to do that with Network.HTTP?
04:05:22 <srhb> lush: Yes, Network.HTTP from the HTTP package will work fine.
04:06:03 <catgocat> dramforever: your thing doesnt work for 3
04:06:15 <srhb> lush: Look at the Request type among other things. :)
04:06:23 <dramforever> catgocat: why? lemme see
04:06:30 <lush> srhb: ty, I'll try to understand the module ^
04:06:31 <dramforever> > (3 - 1) `mod` 3
04:06:33 <lambdabot>  2
04:06:44 <dramforever> catgocat: what's it supposed to be?
04:06:50 <catgocat> it doesnt work here wait
04:06:51 <lush> dramforever: 2 :D
04:07:13 <catgocat> the row returns 1
04:07:19 <catgocat> row = number `div` len
04:07:25 <catgocat> 3 `div` 3 == 1
04:07:31 <catgocat> is should return 0
04:07:34 <dramforever> catgocat: did you see the - 1 part
04:07:43 <dramforever> oh that row one..
04:07:46 <catgocat> but wasnt that only for the col?
04:08:03 <dramforever> catgocat: seems that div and mod work this way
04:08:05 <dramforever> 0 1 2
04:08:07 <dramforever> 3 4 5
04:08:08 <dramforever> 6 7 8
04:08:18 <catgocat> (number - 1) `div` len 
04:08:21 <catgocat> it works I thank
04:08:31 <catgocat> s/thank/think
04:08:47 <catgocat> 1 2 3
04:08:49 <catgocat> 4 5 6
04:08:50 <catgocat> 7 8 9
04:09:08 <catgocat> @let row n l = (n- 1) `div` l
04:09:09 <lambdabot>  Defined.
04:09:20 <catgocat> @let col n l= (n - 1) `mod` l
04:09:21 <lambdabot>  Defined.
04:09:25 <catgocat> row 3 3
04:09:29 <catgocat> > row 3 3
04:09:31 <lambdabot>  0
04:09:34 <catgocat> > col 3 3
04:09:35 <lambdabot>  2
04:09:40 <catgocat> row 9 3
04:09:42 <catgocat> > row 9 3
04:09:44 <lambdabot>  2
04:09:48 <catgocat> > col 9 3
04:09:50 <lambdabot>  2
04:09:52 <catgocat> works :D
04:09:57 <catgocat> 1 2 3 4
04:09:58 <catgocat> 5 6 7 8
04:10:02 <catgocat> 9 10 11 12
04:10:05 <catgocat> 13 14 15 16
04:10:06 <srhb> catgocat: You can talk to lambdabot privately if need be. :-)
04:10:12 <catgocat> how ?
04:10:16 <srhb>  /q lambdabot
04:10:24 <catgocat> > row 11 4
04:10:26 <lambdabot>  2
04:10:31 <catgocat> > col 11 4
04:10:32 <lambdabot>  2
04:10:40 <dramforever> catgocat: you can use ghci
04:10:49 <catgocat> yeah it works
04:10:50 <matsuura> Haha
04:12:28 <catgocat> how can I reduce this
04:12:30 <catgocat> fillTile xss number tile = nth row (nth col (const tile)) xss
04:12:33 <catgocat> I need xss and number
04:14:23 <srhb> Looks fine to me.
04:14:51 <srhb> nth row . nth col $ const tile -- perhaps
04:15:04 <srhb> oh I missed the xss
04:15:15 <srhb> nth row . nth col . const tile $ xss
04:15:33 <srhb> wait, that's not the same.
04:15:49 <osense> :t Infinity
04:15:50 <lambdabot>     Not in scope: data constructor ‘Infinity’
04:15:50 <lambdabot>     Perhaps you meant variable ‘infinity’ (imported from Data.Number.Natural)
04:15:54 <srhb> Ah well, it is fine. :-)
04:16:00 <osense> :t nfinity
04:16:01 <lambdabot>     Not in scope: ‘nfinity’
04:16:02 <lambdabot>     Perhaps you meant ‘infinity’ (imported from Data.Number.Natural)
04:16:04 <osense> :t infinity
04:16:05 <lambdabot> Natural
04:16:09 <osense> hm
04:17:41 * hackagebot irc-conduit 0.1.2.0 - Streaming IRC message library using conduits.  https://hackage.haskell.org/package/irc-conduit-0.1.2.0 (barrucadu)
04:19:18 <lush> srhb: what exactly is that [Header] in a Request for?
04:19:25 <osense> where does 'Infinity' come from?
04:19:28 <osense> > 1/0
04:19:30 <lambdabot>  Infinity
04:20:26 <dramforever> @index Infinity
04:20:26 <lambdabot> bzzt
04:20:31 <dramforever> huuh
04:20:34 <srhb> lush: Check our HeaderName
04:20:36 <dramforever> @hoogle Infinity
04:20:36 <lambdabot> package infinity
04:20:36 <lambdabot> System.Posix.Resource ResourceLimitInfinity :: ResourceLimit
04:20:41 <dramforever> =(
04:20:51 <srhb> lush: It's the sort of extra information the webserver can react to.
04:20:56 <dramforever> osense: I'm afraid that the only way to get infinity is 1/0
04:21:04 <osense> haha
04:21:09 <osense> okay, that's a little weird :P
04:21:23 <dramforever> > read "Infinity" :: Double
04:21:24 <lambdabot>  Infinity
04:21:28 <dramforever> oh this works too...
04:23:08 <lush> srhb: http://susepaste.org/54469539 like the first part of this up until "HTTP/1.1..." ? (one moment afk, I'll text you then^^)
04:23:50 <srhb> lush: Yes, things like that :)
04:24:17 <osense> dramforever: how does the :: in your expression work? Does it tell 'read' what type it expects from it?
04:24:34 <dramforever> s/it expects/I expect/
04:24:38 <dramforever> yes
04:24:48 <osense> cool, thanks
04:24:51 <dramforever> it forces the expression to have that type
04:24:56 <osense> yup
04:28:14 <catgocat> is there something like putStr "Hello %s, you have %s $ in your %s account"
04:28:32 <lush> srhb: oh the whole file is a header right?
04:28:43 <dramforever> catgocat: printf
04:28:49 <dramforever> Text.Printf
04:28:56 <srhb> lush: I believe so.
04:29:07 <lush> ok, ty :)
04:32:02 <lush> srhb: oh no only the first part I guess, the rest doesn't have a matching Header ;)
04:32:10 <lush> in Network.HTTP.Headers
04:32:23 <srhb> lush: HdrCustom String ?
04:34:00 <lush> srhb: ouuh.. ^^
04:35:12 <lush> srhb: is there an easy way to "convert" the ResponseBody to a JSON-comform Haskell datatype?
04:35:39 <srhb> lush: Probably using aeson or some package like that.
04:36:22 <lush> perfect, ty)
04:41:59 <catgocat> Any way I have make this code shorter: http://lpaste.net/137718 ?
04:42:39 <dramforever> :t readMaybe
04:42:40 <lambdabot> Not in scope: ‘readMaybe’
04:42:44 <dramforever> :t readMay
04:42:45 <lambdabot> Not in scope: ‘readMay’
04:42:55 <dramforever> @hoogle String -> Maybe a
04:42:55 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
04:42:55 <lambdabot> Prelude fail :: Monad m => String -> m a
04:42:55 <lambdabot> Control.Monad fail :: Monad m => String -> m a
04:43:07 <dramforever> screw it..
04:43:24 <dramforever> catgocat: never mind
04:45:43 <catgocat> I am using reads to validate input
04:45:58 <catgocat> and then I pass that value to a function to check validation
04:46:01 <catgocat> is this the right way to go?
04:46:05 <catgocat> I want the user to input an integer
04:46:16 <dramforever> catgocat: I guess you should split the function into two halves
04:46:28 <catgocat> dramforever: I have one function to validate input
04:46:31 <catgocat> and other function to read input
04:46:50 <dramforever> ...
04:46:57 <dramforever> no more suggestions
04:47:03 <dramforever> or, in Prolog's words,
04:47:05 <dramforever> No.
04:47:38 <catgocat> what?
04:47:49 <dramforever> no more suggestions
04:48:51 <lush> srhb: ehm is it possible to use both, http and aeson? because cabals says it will break http when I install aeson and the other way around..
04:49:32 <dramforever> lush: cabal install HTTP aeson
04:49:40 <dramforever> that will make cabal consider both packages together
04:49:44 <dramforever> see if that solves it
04:50:15 <lush> dramforever: 1mom
04:50:50 <lush> mhm seems like it is working, ty :)
04:51:05 <dramforever> yw
04:55:49 <catgocat> is there a function that does something like     chooseOther :: String -> String -> String -> String
04:56:25 <catgocat> I give 2 objects, and an object, and the function returns the other object
04:56:45 <dramforever> catgocat: can you give an example?
04:56:50 <catgocat> yes
04:57:09 <indiagreen> what's the best way to add additional documentation to a reexported function?
04:57:41 <catgocat> http://lpaste.net/137719
04:57:45 <catgocat> dramforever: http://lpaste.net/137719
04:58:21 <catgocat> there should be a function for that I think
04:58:38 <dramforever> @pl (\a b x -> if a == x then b else a)
04:58:38 <lambdabot> flip =<< (flip .) . flip . (if' .) . (==)
04:58:44 <dramforever> uh oh
04:59:11 <dramforever> catgocat: what are you trying to do with it?
04:59:25 <catgocat> changePlayer Player1 Player2 Player1
05:01:24 <catgocat> dramforever: what you think
05:01:42 <Drsaadi> hello everyone!
05:01:59 <dramforever> catgocat: why don't use a flag, or something like
05:02:05 <catgocat> a flag ?
05:02:16 <dramforever> currentPlayer
05:02:23 <dramforever> Drsaadi: hello!
05:02:36 <dramforever> data PlayerFlag = FirstPlayer | SecondPlayer
05:02:38 <catgocat> what is a flag
05:02:42 <catgocat> yes I have that
05:02:43 * hackagebot irc-client 0.2.4.0 - An IRC client library.  https://hackage.haskell.org/package/irc-client-0.2.4.0 (barrucadu)
05:02:55 <dramforever> catgocat: oh so you could do
05:03:06 <dramforever> changePlayer FirstPlayer = SecondPlayer
05:03:12 <dramforever> change SecondPlayer = FirstPlayer
05:03:21 <dramforever> oh should be changePlayer
05:03:37 <dramforever> IIUC pattern matching is preferred over (==)
05:04:01 <catgocat>  what is IIUC
05:04:21 <dramforever> If I understand correctly
05:08:08 <mauris> are questions about stuff like Hindley-Milner on-topic here?
05:10:02 <ely-se> Does Happstack provide an instance of MonadPlus IO?
05:16:01 <ggole> mauris: to implement it, or to use it?
05:16:11 <ggole> (Although I'd say you're probably safe either way.)
05:16:47 <mauris> https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#Syntax i don't understand why "let" is anything but syntactic sugar
05:16:58 <mauris> it's just (\x.e2)e1, isn't it?
05:17:36 <mauris> but then there's a separate [Let] rule and everything later on... isn't that just overcomplicating things?
05:17:46 <ggole> With let, it's only ever possible for the variable to be bound to one expression. That isn't true of arguments.
05:18:21 <ggole> It turns out this restriction is enough to allow more polymorphic types for let-bound variables.
05:18:38 <mauris> hmm, can you give an example?
05:19:51 <ggole> For soundness You have to calculate the set of type variables that are introduced fresh in the bound expression, and of course you can't do that for the (infinite) possible expressions that may be passed to an argument.
05:20:54 <ggole> Hmm, what kind of example do you want?
05:23:41 <mauris> some kind of expression with "let" that can't be rewritten as a lambda and an application without losing any information
05:23:55 <nshepperd> > let copy = id in (copy 5, copy 'z')
05:23:56 <lambdabot>  (5,'z')
05:24:27 <nshepperd> > (\copy -> (copy 5, copy 'z')) -- this requires Rank2Types
05:24:29 <lambdabot>      No instance for (Num Char) arising from the literal ‘5’
05:24:29 <lambdabot>      In the first argument of ‘copy’, namely ‘5’
05:24:29 <lambdabot>      In the expression: copy 5
05:24:39 <mauris> ah! of course
05:24:57 <ggole> There isn't any such expression, because immediate application obeys the same restrictions as a let.
05:25:30 <nshepperd> > (\copy -> (copy (), copy 'z')) id -- lets get a better error message...
05:25:32 <lambdabot>      Couldn't match expected type ‘()’ with actual type ‘Char’
05:25:32 <lambdabot>      In the first argument of ‘copy’, namely ‘'z'’
05:25:32 <lambdabot>      In the expression: copy 'z'
05:25:38 <ggole> You can imagine a type system that recognised this situation syntactically and allowed more polymorphic typing there.
05:25:50 <ggole> That would essentially be the same thing as let.
05:33:55 <meretrix> How can I get uncaught exceptions thrown in a forkIO child thread to kill my main thread?
05:42:44 <fvgvxmpv1> I think there is a function for raising arbitrary exceptions in threads given their ThreadId. Combining that with 'onException' (I think it´s called) should do the trick, no?
05:43:13 <saep> meretrix: I had a similar problem a while back. I ended up forking everything and let the main-thread wait for a value to be put inside an MVar.
05:43:22 <saep> E.g.: https://github.com/neovimhaskell/nvim-hs/blob/master/library/Neovim/Main.hs#L137-L145
05:43:35 <meretrix> thanks, I'll take a look
05:43:43 <saep> There's probably a more principled approach, but that seems to work well for me. :p
05:49:05 <suppi> Hello, I would be very glad if anyone could give me some feedback about my project: https://github.com/soupi/pureli
05:49:37 <suppi> Any Haskell practices or concepts I can learn that will help me.
05:49:41 <suppi> thanks i advance
05:50:32 <fvgvxmpv1> for reference: http://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Concurrent.html#v:throwTo and http://hackage.haskell.org/package/base-4.8.1.0/docs/Control-Exception.html#v:onException
05:53:07 <fvgvxmpv1> (one would want 'catch' instead of 'onException')
05:56:40 <Vomit_> @pl (\c -> isSpace c || isPunctuation c))
05:56:40 <lambdabot> (line 1, column 37):
05:56:40 <lambdabot> unexpected ')'
05:56:40 <lambdabot> expecting variable, "(", operator or end of input
05:59:05 <Vomit_> @pl (\c -> isSpace c || isPunctuation c)
05:59:06 <lambdabot> liftM2 (||) isSpace isPunctuation
06:01:26 <phantom10111> hi, suppose I want to make a data type with polymorphic functions/values in it like this:
06:01:29 <phantom10111> http://lpaste.net/2549562105246253056
06:01:47 <phantom10111> it doesn't compile because I don't have Rank2Types enabled
06:01:50 <phantom10111> and my question is
06:01:53 <phantom10111> should I just enable it
06:01:58 <phantom10111> or is there a better way to do it?
06:03:30 <bergmark> phantom10111: do you want to specify `a' when you construct a value?
06:03:41 <phantom10111> no
06:04:04 <bergmark> then you want RankNTypes
06:04:35 <phantom10111> ok, thanks
06:07:46 * hackagebot stm-io-hooks 1.1.0 - STM with IO hooks  https://hackage.haskell.org/package/stm-io-hooks-1.1.0 (PeterRobinson)
06:09:31 <catgocat> is there any function that tests for a bool and if it's true it returns Right something, otherwise Left something
06:09:50 <catgocat> something like test :: Bool -> a -> b -> Either a b
06:10:01 <bergmark> @type bool Left Right
06:10:02 <lambdabot> Bool -> b -> Either b b
06:10:33 <catgocat> how do I use that
06:10:51 <ely-se> catgocat: no
06:10:55 <catgocat> ?
06:11:00 <bergmark> @type \l r -> bool (Left . l) (Right . r)
06:11:01 <lambdabot> (a -> a1) -> (a -> b) -> Bool -> a -> Either a1 b
06:11:10 <ely-se> there is a such a function in data-easy package
06:11:12 <ely-se> http://hayoo.fh-wedel.de/?query=a+-%3E+b+-%3E+Bool+-%3E+Either+a+b
06:19:02 <mauris> https://github.com/ghc/ghc/blob/master/compiler/parser/Lexer.x#L1543 haha, good name. know thyself, ghc
06:21:22 <ReinH> catgocat: case is good for that
06:23:51 <catgocat> http://lpaste.net/137721
06:23:55 <catgocat> can anyone check this
06:26:14 <mauris> @hoogle surround
06:26:14 <lambdabot> No results found
06:27:14 <catgocat> mauris: it's defined in the utils
06:27:23 <catgocat> surround x ys = x : intersperse x ys ++ [x]
06:28:12 <ReinH> catgocat: FYI, ys ++ [x] is generally a pretty bad idea. In this case, since you're dealing with a 3x3 board, it's probably OK.
06:28:27 <mauris> and nth?
06:29:08 <catgocat> ReinH, I am not dealing with a 3x3 board.. it's a general tictactoe (startBoard does NxN, N >= 1)
06:29:44 <ddellacosta> is there a way to do a sandbox-specific .ghci config?  Or somehow ignore a subset of my ~/.ghci ?
06:29:59 <ddellacosta> my googling is yielding nothing, but I suspect I'm looking for the wrong thing
06:30:45 <meretrix> saep: FYI, I found a nicer solution: "forkIO' = forkIO . runIO" using GHC.TopHandler.  Anything exceptions inside forkIO' will interrupt the main thread.
06:32:22 <mauris> catgocat: i don't feel like [[Tile]] is a very good data structure for tic-tac-toe
06:32:35 <catgocat> so what do you suggest?
06:33:29 <mauris> i would go for something like Array (Int, Int) Tile
06:34:05 <mauris> or maybe a Map (Int, Int) Tile, and take "Empty" out of Tile
06:34:26 <catgocat> no
06:34:28 <catgocat> that's ugly
06:35:18 <mauris> (!!) is far, far uglier
06:36:17 <ww> hmmm... is there a way to get cabal to run an external program (i.e. a script, not in haskell) as part of a test suite?
06:36:54 <bergmark> ww: how about calling the script from haskell?
06:37:22 <ww> a wrapper? i guess, if there's no way to do it directly
06:38:11 <bergmark> i don't think so, even if you do it as a setup hook you are still writing haskell
06:40:20 <codedmart> is there something similar to maybeToList but with signature `Maybe [a] -> [a]` instead of `Maybe a -> [a]` where [a] can be an empty list?
06:42:43 <mauris> :t catMaybes
06:42:44 <lambdabot> [Maybe a] -> [a]
06:42:49 <mauris> oh, right
06:43:40 <mauris> :t maybe [] id
06:43:41 <lambdabot> Maybe [t] -> [t]
06:43:51 <ReinH> :t fromMaybe []
06:43:52 <lambdabot> Maybe [t] -> [t]
06:44:07 <ReinH> fromMaybe x = maybe x id
06:47:19 <codedmart> Thanks guys! fromMaybe works great.
06:51:00 <ttt_fff> monad typeclases are the best fucking things ever
06:51:03 <ttt_fff> so amazing
06:51:13 <ttt_fff> so brilliant
06:51:17 <ttt_fff> whoever invented it deserves the turing award
06:52:51 <ReinH> mauris, catgocat: [[Tile]] is fine.
06:53:02 <ReinH> a 3x3 list might actually be more performant than a Map
06:53:04 <ReinH> or Array
06:53:48 <ReinH> I can't see it being a problem in any case
06:53:53 <indiagreen> codedmart: or you could use fold from Data.Foldable
06:54:14 <mauris> ReinH: yeah, i was thinking less about performance and more about safety/elegance
06:54:45 <mauris> i really dislike writing things like "(arr !! y) !! x" :(
06:55:07 <ttt_fff> hmm, why can't ou write arr !! (y, x) ?
06:55:15 <ttt_fff> x and y are ints right?
06:55:22 <mauris> :t (!!)
06:55:23 <lambdabot> [a] -> Int -> a
06:55:30 <Intolerable> :t (!)
06:55:31 <lambdabot> Ix i => Array i e -> i -> e
06:55:32 <mauris> the right operand is always Int
06:55:36 <ttt_fff> ahh, you can make (!!) into a typeclass
06:55:47 <Intolerable> :t \arr -> (arr ! (1,2))
06:55:48 <lambdabot> (Num t, Num t1, Ix t, Ix t1) => Array (t, t1) e -> e
06:55:50 <mauris> that's what (!) does (the typeclass is Ix)
06:56:07 <mauris> but it's for Arrays, not []s
06:57:25 <y> doing !! on a list means you are using the wrong data structure
06:57:35 <y> or using the wrong algorithm for your data structure
06:57:52 <ReinH> Usually.
06:57:59 <joco42> I have question to those who are using emacs for haskell and are using the go-to-definition : I am using vim for the same purpose (in combination with hasktags) but vim does not take into account what is imported into a given haskell file and shows me all the matching identifiers, for example i get 14 suggestion for settext, even from modules that i do not
06:58:00 <joco42> even use. Does emacs haskell-mode take into account the imported modules when suggesting go to definition alternatives ?
06:58:16 <joco42> https://usercontent.irccloud-cdn.com/file/aXqazOFt/Screen%20Shot%202015-08-01%20at%2016.56.20.png
06:58:22 <joco42> https://usercontent.irccloud-cdn.com/file/mRVVju2z/Screen%20Shot%202015-08-01%20at%2016.56.28.png
06:58:28 <joco42> here are the examples
06:58:40 <ReinH> joco42: I don't believe so.
06:58:53 <joco42> ReinH: ok, thanks for the info
06:59:51 <joco42> can someone else also confirm ReinH 's answer ?
07:14:11 <catgocat> @pl map (concat . surround hori . map show)
07:14:11 <lambdabot> map (join . surround hori . map show)
07:14:43 <dramforever> catgocat: isn't that pl enough? =P
07:32:49 * hackagebot HostAndPort 0.2.0 - Parser for host and port pairs like localhost:22  https://hackage.haskell.org/package/HostAndPort-0.2.0 (slava)
07:35:10 <mauris> when does `reads` return multiple results?
07:40:28 <rtpg> Hey, in a case expression is it possible to pattern match without deconstructing all the arguments?
07:40:56 <rtpg> like, if I have data D = Foo f | Bar a b c d, to do something like "case obj of b::Bar -> r"
07:42:27 <chattered> rtpg: You'd just do Bar _ _ _ _ -> there.
07:42:31 <mauris> i think  "case x of Bar _ _ _ _ -> r"  is your best bet
07:42:46 <rtpg> ah ok
07:43:03 <supki> case obj of b@Bar {} -> r
07:43:04 <mauris> or maybe define "isBar :: D -> Bool", and then  "case obj of x | isBar x -> r"?
07:43:08 <mauris> oh, wow
07:43:41 <rtpg> I was thinking of the @ thing, but I thought that was scala?
07:44:06 <chattered> supki: Ugh. I can't believe I've never known you could use record syntax without defining a record.
07:44:15 <mauris> me neither
07:44:26 <chattered> rtpg: Yeah, it's the same as in Scala.
07:46:27 <y> case obj of Bar{} -> ... 
07:46:35 <y> I would avoid b@ because it's the same as obj 
07:46:54 <__monty__> Is there anyone with some experience in Agda or dependent types in general? I'm looking for a way to achieve this: http://lpaste.net/137726 in haskell. Specifically how can I replicate the implicit proofs (disjoint and sub)?
07:47:50 * hackagebot glib 0.13.2.1 - Binding to the GLIB library for Gtk2Hs.  https://hackage.haskell.org/package/glib-0.13.2.1 (HamishMackenzie)
07:48:25 <ely-se> Speaking of editors, is there a way to stop vim from showing \ as λ and . as ∘?
07:48:53 <__monty__> ely-se: That's certainly not the default, which plugins are you using?
07:49:31 <ely-se> __monty__: these: http://lpaste.net/137728
07:49:38 <ely-se> I don't think any deal with Haskell.
07:49:52 <ely-se> lemme check which Haskell plugin Vim ships with
07:50:24 <ely-se> oh, vim2hs
07:50:31 <mauris> let g:haskell_conceal = 0
07:50:43 <__monty__> ^
07:51:26 <ely-se> yay <3
07:52:50 * hackagebot gtk3 0.14.0 - Binding to the Gtk+ 3 graphical user interface library  https://hackage.haskell.org/package/gtk3-0.14.0 (HamishMackenzie)
08:02:09 <__monty__> I'm looking for a way to achieve something like this: http://lpaste.net/137728 in haskell. Specifically how I can replicate the implicit proofs for disjoint-ness and sub-ness.
08:02:37 <__monty__> Apologies for the repeat.
08:03:41 <catgocat> How can I minimize this code: http://lpaste.net/137730
08:04:16 <marchelzo_> What is the recommended way to get ghc on ubuntu these days?
08:05:25 <benzrf> hey
08:05:48 <benzrf> whats the best way to get a DAG that's fully updatable at runtime
08:05:57 <benzrf> i see the dag library but it's based on compile time checks
08:06:05 <benzrf> i'd be happy with something that complains if i try to introduce a cycle
08:07:13 <monochrom> catgocat: getCoords n xss = (n-1) `divMod` (length xss)
08:07:14 <mniip> anyone here ever programmed in  or , ?
08:07:23 <mniip> http://i.imgur.com/mgCEEB9.png xD
08:07:23 <catgocat> divMod?
08:07:33 <monochrom> divMod.
08:07:34 <catgocat> so nice
08:07:41 <catgocat> didnt know that function
08:09:32 <catgocat> @pl fillTile xss n tile = nth row (nth col (const tile)) xss where (row, col) = getCoords n xss
08:09:32 <lambdabot> (line 1, column 76):
08:09:32 <lambdabot> unexpected " "
08:09:32 <lambdabot> expecting operator
08:12:51 * hackagebot gtk3-mac-integration 0.3.2.0 - Bindings for the Gtk/OS X integration library.  https://hackage.haskell.org/package/gtk3-mac-integration-0.3.2.0 (HamishMackenzie)
08:25:11 <UberLambda> Anyone using the Haskell IntelliJ plugin? ghc-mod is behaving weirdly with hidden packages :/
08:25:59 <UberLambda> When I add a dependency to parsec in the build-depends of the cabal file, ghc-mod still complains about the need to add "the hidden package parsec-3.1.9" to the build-depends...
08:35:29 <indiagreen> do we already have anything like concatMapM?
08:37:22 <chattered> join?
08:37:31 <chattered> Sorry. 
08:37:36 <chattered> Isn't that just >>=?
08:38:14 <indiagreen> >>= is concatMap for lists
08:38:15 <y> concatMap is (=<<) for lists
08:38:24 <indiagreen> well, or the reverse, I don't remember
08:38:52 <benzrf> chattered: if you define join separately, then x >>= f = fmap f (join x)
08:38:54 <benzrf> er, i mean
08:38:59 <benzrf> chattered: if you define join separately, then x >>= f = join (fmap f x)
08:39:12 <benzrf> although both should be the same if they are both well-typed, i think
08:46:10 <catgocat> any way I can shorten this
08:46:10 <catgocat> http://lpaste.net/137735
08:50:23 <Ankhers> I feel like I am doing something wrong. What is the suggested way to run your tests with stack? Currently, I have to `stack clean && stack test` any time I change my test files.
08:52:53 * hackagebot ruby-marshal 0.1.0 - Parse a subset of Ruby objects serialised with Marshal.dump.  https://hackage.haskell.org/package/ruby-marshal-0.1.0 (filib)
08:55:18 <benzrf> what is stack Ankhers, like stackage?
08:56:21 <Ankhers> benzrf: The cabal-install competitor from the commercial haskell group.
08:57:53 * hackagebot unbound-generics 0.2 - Support for programming with names and binders using GHC Generics  https://hackage.haskell.org/package/unbound-generics-0.2 (AlekseyKliger)
08:58:32 <Drsaadi> exit
09:06:44 <zalatovo> Does anyone know of a library to generate a Graphviz tree/graph from a value?
09:07:04 <zalatovo> i.e. if I have defined data Tree a = Nil | Tree a (Tree a) (Tree a)
09:07:36 <zalatovo> then a way to convert that to a drawing of a tree, preferably without having to write lots of boilerplate manually
09:11:27 <vektor> zalatovo: I have something like that in use. It's not an explicit tree structure, but it should be good enough maybe
09:12:13 <vektor> First of all, here's a package you should take a look at: https://hackage.haskell.org/package/graphviz
09:12:15 <cocreature> Ankhers: you shouldn't need to run stack clean before running stack test
09:12:50 <vektor> zalatovo: also, here's some code that I use to make graphs: https://github.com/vektordev/GP/blob/master/src/GRPCore.hs#L84-L93
09:12:55 <broma0> Does foldr offer better performance than foldl on a list? I'm thinking it does due to a list's stack-like O(1) pop from the left
09:13:22 <zalatovo> vektor: I did notice that package, I was hoping there's a way to automatically generate the Graphviz code from an ADT using Template Haskell
09:14:49 <vektor> zalatovo: for context of my own source code: https://github.com/vektordev/GP/blob/master/src/GRPStats.hs#L32 - a list of these make up the tree. The head of their ancestry field is their parent, and they're identified by the filepath where their source is. Works for me, and it's not much boilerplate at all.
09:16:56 <zalatovo> vektor: for my own code I'm trying to display some parse trees in a nice way, but those parse trees have many different node types so it would be quite a bit of boilerplate
09:17:02 <zalatovo> vektor: but thanks for the ideas anyway
09:20:43 <catgocat> How can I make this better: http://lpaste.net/137736
09:22:09 <mniip> the use of isJust and fromJust is worrying
09:22:46 <catgocat> mniip: why
09:22:54 * hackagebot gtksourceview3 0.13.2.0 - Binding to the GtkSourceView library.  https://hackage.haskell.org/package/gtksourceview3-0.13.2.0 (HamishMackenzie)
09:23:00 <catgocat> it'll never face `Nothing` tho
09:23:21 <mniip> personally I would go for "... = case whoWon board of"
09:23:42 <catgocat> what
09:23:46 <mniip> and remove the where-clause at all
09:23:46 <catgocat> can you make an annotation?
09:23:51 <mniip> ugh
09:23:54 <mniip> on phone
09:24:44 <catgocat> I can't do case of
09:25:03 <catgocat> because if the result is Nothing I want to test isOver
09:26:15 <lpaste_> mniip annotated “No title” with “No title (annotation)” at http://lpaste.net/137736#a137737
09:27:07 <catgocat> you can include functions inside case of matches?
09:27:21 <mniip> by functions you mean guards?
09:27:23 <mniip> yes
09:27:38 <mniip> (they aren't necessarily functions)
09:28:01 <catgocat> what is Nothing | isOver x ->
09:28:05 <catgocat> is that a guard?
09:28:20 <mniip> that's called a guard
09:28:33 <catgocat> but doesn't guard have to have an equal sign = ?
09:28:37 <catgocat> | something = ..
09:28:44 <mniip> not a case guard
09:29:03 <mniip> case x of Y | e -> r
09:29:13 <catgocat> can I do A | B | C -> ?
09:29:26 <catgocat> or only one guard is allowed?
09:29:28 <broma0> catgocat: im making a quick edit to your code
09:29:34 <broma0> catgocat: one minute
09:30:00 <kadoban> catgocat: You can do     case x of Y | e && a && b ->      is that what you mean?
09:30:15 <catgocat> I don't mean anything
09:30:23 <catgocat> how many case guards can you have ?
09:30:29 <mniip> catgocat, you can have multiple guards yes
09:30:31 <kadoban> Well if it doesn't mean anything … then I have no idea how to answer.
09:30:33 <catgocat> how?
09:30:35 <catgocat> what..
09:30:36 <mniip> same as in function
09:30:55 <catgocat> can you do stuff | shit -> .. | cool -> ?
09:30:59 <mniip> yes
09:31:03 <UberLambda> Is there any way to convert a IO String to IO Filepath? I assumed that "type X = Y" let automatic conversions be performed
09:31:08 <catgocat> cool
09:31:12 <mniip> except with newlines
09:31:13 <broma0> catgocat: maybe this? http://lpaste.net/edit/137736
09:31:23 <broma0> UberLambda: type FilePath = String
09:31:26 <broma0> UberLambda: I think
09:31:26 <kadoban> UberLambda: type aliases are all interchangeable, yeah.
09:31:30 <catgocat> broma0 I had exacly that before (putWinner and putBoard)
09:31:51 <broma0> catgocat: did i mess up my first lpasting?
09:31:56 <UberLambda> kadoban, broma0: it does not seem to work... readFile <IO String> fails somehow
09:32:03 <mniip> UberLambda,  they are type synonyms,they mean the same thing in every aspect imaginable
09:32:09 <catgocat> broma0 what?
09:32:15 <mniip> no conversion involved
09:32:17 <UberLambda> hm... let me post a snippet
09:32:19 <catgocat> I think I'll stick with case of
09:32:44 <broma0> catgocat: never used lpaste.. did you mean "you didnt change anything!" by "i had exactly that before"?
09:33:31 <catgocat> broma0 no, I meant I had already tried what you wrote before and didn't like it
09:33:51 <UberLambda> Wait... I'm wrong, I'm trying to put a String in a "IO Filepath"
09:33:52 <broma0> catgocat: ah, i see. well hopefully someone has better style than us :D
09:34:02 <catgocat> case of seems to be pretty good
09:34:04 <catgocat> and more readable
09:34:21 <kadoban> UberLambda: IO String isn't the same thing as String
09:34:32 <mniip> UberLambda,  same as you wold put a  String in an IO String
09:34:34 <UberLambda> hm... any way to do something like args <- getArgs; filePath <- args !! 0; source <- readFile filePath
09:34:50 <UberLambda> Maybe I have to look more docs about monads
09:35:02 <geekosaur> have you tried what you wrote?
09:35:18 <mniip> UberLambda,  what are you trying to do (like in general)
09:35:20 <geekosaur> well, no, that middle one is wrong
09:35:31 <geekosaur> but you are close
09:35:40 <broma0> UberLambda: 'fmap head getAargs >>= readFile' will give you "source", but you'll get an exception for no args
09:35:48 <UberLambda> I'm trying to take the first shell argument and use it as a path to read a file's contents
09:35:52 <geekosaur> ask yourself why you are using <- for the middle part, and what else you might write
09:36:01 <mniip> more generally than that I mean
09:36:17 <catgocat> can you guys check this: http://lpaste.net/137739 maybe help me improve it?
09:36:20 <mniip> I can see that from the code already
09:36:28 <UberLambda> eh... I don't know, I'm sorta copy-pasting code in the hopes that it will work... I should probabily learn me a haskell :P
09:36:38 <geekosaur> @where learnhaskell
09:36:38 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:36:50 <mniip> catgocat, redundant parens in case
09:36:52 <geekosaur> lyah is ok for learning to read haskell, not so much learning to write it
09:37:03 <catgocat> mniip: where?
09:37:39 <UberLambda> geekosaur: I see... I learned python by writing instead. But I was coming from another imperative lang, so maybe that's it
09:37:46 <UberLambda> also the syntax is much simpler
09:37:54 <UberLambda> *semantics
09:37:56 <catgocat> python is boring IMO
09:38:14 <UberLambda> well... it's clean, simple, and really slow
09:38:34 <UberLambda> Also I prefer typed languages
09:38:37 <y> UberLambda: lots of people here would disagree with Python being clean, and specially with the `simple` part
09:38:48 <UberLambda> I mean, with real strong types and no duck typing
09:39:13 <UberLambda> y: could you give me an example? When comparing it to, say, C++ it's definitely cleaner
09:39:27 <y> UberLambda: compared to scheme, python is overcomplicated
09:39:31 <chattered> UberLambda: Not much of a comparison, though.
09:39:35 <UberLambda> y: well, of course
09:39:40 <mniip> UberLambda, haskell is a cardinal switch in paradigms
09:39:43 <UberLambda> y: most other languages are
09:39:57 <UberLambda> mniip: yeah, that's why I'm trying to learn it :)
09:40:04 <mniip> you can't expect to be able to "just write it"
09:40:15 <catgocat> mniip: where the redundant parentheses?
09:40:27 <catgocat> you mean (Just ..)
09:40:48 <mniip> catgocat, you need (Left e) in function definitions, but not in case
09:40:54 <catgocat> ok thanks
09:40:55 <mniip> in case Left e is enough
09:41:11 <UberLambda> I was sticking to simple things in main... it seems pretty much imperative code with the do notation. Now, I don't expect to write good haskell this way, but I thought I would have been able to hack out something simple
09:41:33 <mniip> well
09:41:33 <catgocat> do notation is just syntatic sugar to >>=
09:41:38 <catgocat> and >>
09:41:39 <UberLambda> But yep, I'll read programs first and then start doing things
09:41:54 <mniip> UberLambda,  that's like using C without variable declarations
09:42:05 <mniip> you're not using the language
09:42:15 <Cale> Hm?
09:42:21 <Cale> What's like that?
09:42:34 <UberLambda> mniip: yes, but I was just testing my setup (IntelliJ + ghc-mod + etc. etc.)
09:42:47 <UberLambda> and well, I started writing this
09:42:56 <mniip> Cale,  learning haskell by messing with main=do
09:43:14 <mniip> and nothing else
09:43:49 <Cale> I dunno, it seems okay to me. You'll obviously need to learn about lots of other non-IO things along the way, even just to do IO.
09:44:25 <Cale> But you can get pretty far even if you just use Haskell as an imperative language. It's a pretty good imperative language.
09:44:48 <Cale> I guess I'd agree that you're not taking full advantage of what the language has to offer if you're sticking everything in IO.
09:44:48 <UberLambda> The thing that got me was Parsec... it seems quite awesome
09:44:57 <mniip> I think, besides the notorious hello world example, IO, especially as a black box, has to be learned much later
09:45:27 <UberLambda> mniip: yeah, it was sort of an hello world to let GHC not complain about the missing main binding
09:45:36 <Cale> UberLambda: But yeah, it seems from above, your confusion was about the meaning of  v <- x  inside a do-block
09:45:40 <mniip> UberLambda, ghci
09:45:50 <kadoban> I think you can kinda learn how to use IO early, if you want. It requires a lot of "don't worry about how that works … just use it" though.
09:45:53 <mniip> is a repl
09:46:08 <Cale> UberLambda: v <- x means "execute the action x, and call its result v", so in main (or any other IO action), you'll need to have x :: IO t, and then v :: t as a result
09:46:10 <UberLambda> mniip: yeah, but I'd prefer to have files to save
09:46:34 <mniip> UberLambda,  you can use it to repl files without a main
09:46:44 <catgocat> am I a bad person for liking and writing code that is has blank lines between code to make it more readable?
09:46:45 <UberLambda> mniip: oh
09:46:45 <Cale> UberLambda: If you want to simply make v the name of some value, you can use let v = x instead, which just defines v to be the same thing as x.
09:46:53 <mniip> 'ghci foo.hs'
09:46:55 <catgocat> s/is has/has
09:47:06 <mniip> or just :l in the repl
09:47:25 <Cale> (note: you can put as many declarations into a single let as you like, so long as they all start in the same column, and they're allowed to be recursive)
09:47:43 <mniip> catgocat,  your code is kinda backward-ish, with our without blank lines
09:47:54 <catgocat> what is backward-ish
09:48:12 <mniip> foo = x where x = something
09:48:18 <UberLambda> hm... I'll use ghci then... BTW, is there any fix or something for https://github.com/kazu-yamamoto/ghc-mod/issues/511?
09:48:44 <catgocat> mniip I only use that when the "something" is pretty long
09:48:44 <mniip> personally I don't like where declarations for non-functions
09:48:46 <Cale> UberLambda: Oh, you should definitely be using ghci, regardless of whatever else you do :)
09:49:13 <mniip> if I need CSE I'd use 'let-in'
09:49:17 <Cale> UberLambda: You should generally have both your text editor and ghci running side by side. Whenever you save your file, :r in ghci will reload the definitions and let you test them out.
09:49:37 <UberLambda> Cale: Emacs/IntelliJ + terminal then :)
09:49:46 <Cale> UberLambda: and you can type expressions and see what they evaluate to, or use   :t <expression>  to find out what the type of an expression is.
09:49:47 <UberLambda> not sure if Emacs or IntelliJ TBH
09:50:12 <catgocat> mniip I have refactored my whole game, can you make suggestions?
09:50:15 <mniip> :t "hello"
09:50:16 <lambdabot> [Char]
09:50:20 <mniip> like this
09:50:21 <Cale> UberLambda: Of those two, I'd probably prefer Emacs, just because it's more lightweight? But I tend not to like fancy editor features.
09:51:06 <UberLambda> Cale: I'm currently developing on a somewhat beefy machine, so ram/cpu is not that big of an issue
09:51:27 <catgocat> is there a function that does startBoard x = replicate x (replicate x Empty)
09:51:35 <UberLambda> Cale: otherwise, yeah, plain ol' Vim will be fine 
09:51:39 <Cale> GHCi will do all the fancy language specific things. I only need my editor to make sure that tabs are converted to spaces and maintain the indentation level of the previous line, perhaps do a little syntax colouring. :)
09:51:40 <UberLambda> Or Emacs+Evil
09:51:42 <catgocat> basically creates a NxN matrix and fills it
09:52:00 <UberLambda> Cale: I can't live without autocompletion :P
09:52:21 <UberLambda> And company-mode sometimes messes up pretty badly
09:53:00 <mniip> ($ Empty) . join (.) . replicate
09:53:01 <mniip> ?
09:53:05 <Cale> Autocompletion often leads to people using annoyingly long names which make the code more frustrating to actually read, I think. But I suppose if used with care, it should be okay. :)
09:53:06 <catgocat> thats ugly
09:53:30 <mniip> that's pointless! ahem, pointfree!
09:53:52 <UberLambda> Cale: not really... even putStrLn is pretty annoying to type IMHO
09:53:57 <catgocat> mniip: can you review my game
09:54:19 <mniip> I'm afraid not at the moment
09:54:34 <mniip> I only have a phone and a laptop with broken keyboard atm
09:55:07 <catgocat> is there a way to ommit an argument in a function that only uses case of ?
09:55:14 <catgocat> for example func s = case otherFunc s of ..
09:55:27 <mniip> view patterns
09:55:45 <catgocat> what? 
09:55:50 <y> catgocat: lambda case and view patterns help there
09:56:01 <catgocat> what is view patterns
09:56:26 <ReinH> @google haskell view patterns
09:56:27 <lambdabot> https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns
09:56:31 <mniip> lambda case is useless here
09:56:36 <Cale> There are a lot of things which are sort of "standard", "obviously good" things like debuggers that I often sort of wonder about the real effect they have on people's code. I've seen enough code which was far worse than could ever have been accomplished without a debugger to wonder if they're actually a deal with the devil. Autocompletion obviously is not as serious though.
09:57:06 <mniip> I can't use auto completion
09:57:23 <ReinH> can't or won't?
09:57:35 <mniip> I am uncomfortable with
09:57:41 <ReinH> catgocat: I would just use the case statement
09:57:48 <y> autocompletion is nice if it is not "on-by-default" 
09:57:49 <Hijiri> I think I have used Emacs autocompletion once or twice when I couldn't remember the exact name of something I wanted to export
09:57:58 <Hijiri> and couldn't be bothered to scroll down
09:58:03 <catgocat> << is not in scope
09:58:08 <ReinH> you don't need to avoid using case statements
09:58:13 <catgocat> ;t <<
09:58:15 <catgocat> :t <<
09:58:16 <lambdabot> parse error on input ‘<<’
09:58:22 <catgocat> ;t (<<)
09:58:22 <Cale> :t (<<)
09:58:23 <lambdabot>     Not in scope: ‘<<’
09:58:23 <lambdabot>     Perhaps you meant one of these:
09:58:23 <lambdabot>       data constructor ‘Seq.:<’ (imported from Data.Sequence),
09:58:25 <mniip> its all case in the end
09:58:26 <Cale> :t (>>)
09:58:27 <lambdabot> Monad m => m a -> m b -> m b
09:58:36 <UberLambda> Cale: yeah, I don't like debuggers that much, too. But some "lightweight" assistance from editors is pretty nice in my opinion... syntax coloring, linting (=error checking in real time), autocompletion, matching brace/bracket/... insertion, and other tiny things
09:58:52 <catgocat> I thought there was a <<
09:58:58 <y> there is (<*)
09:59:01 <y> @type (<*) 
09:59:02 <lambdabot> Applicative f => f a -> f b -> f a
09:59:04 <geekosaur> there is no <<
09:59:07 <Cale> Yeah, having the editor highlight the matching brackets when you close them is useful.
09:59:32 <UberLambda> Just, not at the paranoid IDE-centric level of, say, Java
09:59:33 <jaseemabid> Does haskell-mode support jump to source? Including system libraries? 
09:59:49 <ReinH> There's a pretty big space between brace matching and debuggers that can be filled by useful editor functionality
09:59:49 <mniip> I only use debuggers when I need to trace the execution of a particularly complicated piece, or to figure out data corruption in lowlevel languages
09:59:53 <UberLambda> when you have to use an IDE to do anything because it's too costly to do by hand there's a problem with the language IMHO
10:00:00 <mniip> otherwise printf(trace) is good enough
10:00:04 <Cale> UberLambda: right.
10:00:07 <ReinH> indentation support, type information providers, etc
10:00:12 <creichert> jaseemabid: I use codex to generate the etags
10:00:20 <Cale> IDEs are often used to paper over weaknesses of the language which ought to just get fixed at that level.
10:00:22 <mniip> and I haven't found a good debugger for haskell yet
10:00:29 <ReinH> I wouldn't want to write a lisp-like without paredit
10:00:47 <Hijiri> (<*) has different semantics if you are expecting (<<) to be flip (>>) though
10:00:48 <mniip> ghci is okay but it's clumsy and dmdanal is not possible with it
10:00:58 <UberLambda> I think the worst I've seen it's Android application development. It's a complete mess of files scattered around anywhere, most autogenerated
10:01:02 <ReinH> jaseemabid: yes and maybe
10:01:13 <chattered> ReinH: Only been using paredit for the last year. Not sure how I managed without it before, though I did!
10:01:23 <UberLambda> good luck trying to build an android app on the command-line
10:01:27 <mniip> UberLambda, oh god that
10:01:29 <creichert> jaseemabid: codex will generate all tags for anything listed in your cabal file
10:01:42 <mniip> so much that
10:02:06 <ReinH> Debugging doesn't seem like a useful way to work with Haskell.
10:02:08 <jaseemabid> creichert: I'm happy if I get etags.
10:02:11 <UberLambda> mniip: it's quite frustrating
10:02:23 <jaseemabid> I see myself reading standard library a lot more these days. 
10:02:33 <UberLambda> Well, TBH, Haskell isn't imperative. I think debuggers are more helpful in imperative code?
10:02:37 <creichert> jaseemabid: yes, just look on hackage for codex, it's a really simple tool and will get emacs very quick. jumping to sources in base and other libs is very helpful
10:02:37 <mniip> ReinH, Im mostly interested in demand analysis
10:02:38 <ReinH> jaseemabid: I usually pull stuff up in hoogle and view source from there
10:02:50 <UberLambda> I mean, you can't really step into or step out of functions
10:02:52 <nshepperd> heh
10:02:52 <Cale> UberLambda: Yeah, there's more stuff to keep track of in imperative code.
10:03:08 <ReinH> mniip: demand analysis?
10:03:11 * nshepperd builds android things at the command line
10:03:12 <Cale> UberLambda: At least, in not-so-well-written imperative code.
10:03:24 <y> debugging Haskell nicely sounds something that would extremely different to debugging imperative code
10:03:33 <mniip> ReinH,  the only time I had to actually debug haskell was when State# RealWorld was involved
10:03:34 <jaseemabid> I think Haskell made a really smart compiler and wrote very simple libraries, compared to say python which puts all sorts of optimizations into libraries and make them inaccessible 
10:03:35 <UberLambda> nshepperd: having a dozen of files autogenerated by the standard tools? :P
10:03:40 <nshepperd> it's just that, whatever the build tools do doesn't seem to be documented
10:04:02 <mniip> ReinH, yeah like figuring why a certain closure is evaluated
10:04:06 <ReinH> mniip: why would State# RealWorld be involved if you aren't developing GHC?
10:04:09 <nshepperd> no, I don't use gradle or that nonsense
10:04:23 <mniip> ReinH,  hahahah
10:04:39 <UberLambda> nshepperd: fortunately, but the old .xml Ant system was not much better
10:04:47 <ReinH> mniip: Only "demand analysis" I know of is the economics one.
10:04:54 <nshepperd> I don't use ant either :)
10:05:10 <nshepperd> well, I used ant once, to figure out what it was running
10:05:13 <UberLambda> oh... the standard tools used ant. So what you use? 
10:05:18 <UberLambda> *do you
10:05:36 <mniip> ReinH,  well I thought in STG machine terminology evaluation is triggered by demand
10:06:08 <Cale> By helping people keep track of what's happening to more state, rather than be forced to reorganise their code to make it comprehensible without additional tools, I think debuggers help people write worse imperative code than they could accomplish without. Of course, they also help meet deadlines much more quickly. :/
10:06:16 <ReinH> Sure, but "demand analysis" is a term of art in another domain, so I was confused.
10:06:45 <Cale> (at least, the immediate ones, at the expense of all the more distant ones)
10:06:47 <nshepperd> UberLambda: well I use tup, which work a lot like makefiles
10:07:26 <UberLambda> One thing, BTW. Since hardware is stateful, after all, does it mean that Haskell more difficult to optimize versus e.g. C?
10:07:28 <ReinH> mniip: Regarding the STG, I've seen language like "a thunk is forced by some demand for its value", yes.
10:07:47 <UberLambda> I mean, compiler-wise+
10:07:50 <mniip> ReinH, as for RealWorld, have you seen the acme-timemachine package
10:08:15 <UberLambda> Since my main "field" is "programming crappy bugged videogames" :P
10:08:15 <ReinH> mniip: Yes, but I haven't looked at the source.
10:08:19 <ReinH> Also, it's an acme package so
10:08:23 <mniip> UberLambda, yes there are lots of issues unseen in imperative world
10:08:27 <catgocat> http://codereview.stackexchange.com/questions/98754/general-tictactoe-in-haskell
10:08:40 <consus> Hello. This may sound ridiculus but I cannot find fixed width unsigned integer definition except for FFI's CUInt. Am I missing something obvious?
10:08:52 <ReinH> consus: Look at Data.Word
10:09:13 <mniip> ReinH, TimeMachine works by storing a stream of State# RealWorld thunks
10:09:19 <Cale> UberLambda: It's not so much because of hardware being stateful, but just the fact that there's more taking place during compilation of Haskell code that makes it a little more work to understand the performance. However, it is pretty doable anyway.
10:09:35 <ReinH> mniip: I totally don't need to know how TimeMachine works or why you would be using it, let alone debugging it :p
10:09:49 <consus> ReinH: But I can google some people actually using Uint32 in their code. Or is this sort of a typedef thing?
10:09:52 <mniip> heh
10:10:08 <nshepperd> well, clever compilers like llvm like to use static-single-assignment as an intermediate representation, so in some sense statefulness is bad for compilers
10:10:21 <ReinH> consus: Uint32 in *haskell* code?
10:10:35 <dmj`> xml-conduit is a good thing
10:10:40 <ReinH> Data.Word is what is generally used for, you know, words
10:10:48 <kadoban> consus: It should be relatively easy to figure out what that corresponds to, if the code comes up … sounds obscure though, Data.Word is well known and broadly used.
10:10:50 <UberLambda> Cale: yeah, but imagine something like a game loop. Since as I understand code that isn't using monads could be executed in any order, maybe even on other threads, does it mean that most of a game must be written in monads?
10:10:59 <Cale> UberLambda: We tend to do a sort of poor job of explaining the operational semantics of Haskell code to beginners (partly because they are not really specified by the language spec, and partly because it's actually more important to understand the meaning of Haskell code before you understand how things get done step-by-step)
10:11:20 <mniip> haskell is also lazy, so we get various strictness optimization problems too
10:11:36 <UberLambda> Cale: hm, +1 point for reading code then... I should probabily just shut up and start :P
10:11:49 <nshepperd> consus: the fixed width types are Int32 etc for signed types, and Word32 etc unsignd
10:12:04 <consus> ReinH: Definitely. As always, I've already lost the link :( In any case thanks, that's what I need.
10:12:06 <ReinH> Only Uint* I know of is in ivory, which is a DSL for embedded C programming, not something you'd use generally.
10:12:07 <UberLambda> right, lazyness...
10:12:08 <Cale> UberLambda: The compiler has some freedom in evaluation order, but if you just imagine that it's using lazy evaluation, you're pretty much only ever pleasantly surprised when it does better than you'd have thought.
10:12:24 <consus> ReinH: Yes, maybe that was Ivory
10:12:25 <mniip> Cale, aI like the dry STG machine approach. This is a closure, it can be demanded, when it is demanded it can demand more closures
10:12:53 <UberLambda> Cale: right... maybe C is still needed after all
10:13:00 <Cale> UberLambda: (lazy evaluation refers to a specific evaluation order, together with the property that any particular bound variable will only be evaluated once, and the result shared between the occurrences)
10:13:27 <UberLambda> Cale: but all of this doesn't apply to monads, right? Atleast IO I mean
10:13:37 <Cale> mniip: I usually don't have to go down that far to tune performance.
10:13:40 <ReinH> "code that isn't using monads could be evaluated in any order" is both true and irrelevant.
10:13:42 <mniip> Io is magic
10:13:49 <Cale> UberLambda: btw, most monads are nothing like IO
10:14:05 <Cale> UberLambda: The execution of IO is a process which is separate from evaluation of expressions.
10:14:12 <ReinH> Well, fsvo "evaluated"
10:14:13 <consus> Do I understand correctly that it's still not possible to have two datatypes with the same field's name?
10:14:15 <UberLambda> Cale: right, I'm mixing up terminology. I meant code with side effects
10:14:17 <mniip> Cale, tune performance? go down? closures can be seen in haskell code as is
10:14:21 <ReinH> consus: Not in the same namespace.
10:14:35 <consus> ReinH: Of course.
10:14:48 <ReinH> consus: Lenses with typeclasses can be used to share names, but ofc those aren't actual record field names.
10:15:01 <mniip> UberLambda, the terminology of "side effect" varies in haskell
10:15:23 <Cale> mniip: Not really -- closures are (code, environment) pairs -- if you can't separate the code from the environment any longer, then I would not refer to something as a closure any longer, but perhaps it's something that a closure is being used to implement.
10:15:26 <mniip> lists can be seen as side effects too, as they make the undeterministic monad
10:15:48 <Cale> (usually a function)
10:16:14 <mniip> Cale, hmm I guess thunk is more common terminology
10:16:14 <Cale> Similarly for "thunk" vs. "expression"
10:16:16 <ttt_fff> any vim users here? I already have: tmux send-keys -t "ghci:0" Enter Enter Enter Enter ":r" Enter "T.Main.main" Enter ... now, I want to configure vim  ... so that I can directly send commnads to ghci
10:16:22 <ReinH> fsvo "side effects" that seems to be defined ad hoc for each monad
10:16:30 <UberLambda> mniip: well, maybe I meant non-pure functions then? Or it isn't it the same?
10:16:40 <ttt_fff> any vim users here? I already have: tmux send-keys -t "ghci:0" Enter Enter Enter Enter ":r" Enter "T.Main.main" Enter ... now, I want to configure vim  ... so that I can directly send commnads to ghci // so basically I want vim to somehow ask me for a string ... then take the string, and send it over to ghci
10:16:41 <Cale> Thunks are the particular low-level representation of not-yet-evaluated expressions
10:16:57 <Cale> Usually you don't have to understand things at the level of thunks, but can think in terms of expression reduction.
10:17:03 <ReinH> Which really means "whatever is denoted by the structure of m and the definition of bind"
10:17:09 <ReinH> (for each choice of m)
10:17:12 <nshepperd> UberLambda: monads aren't really for controlling evaluation
10:17:21 <mniip> UberLambda, you mean the real world side effect? like file operations and stdio?
10:17:28 <mniip> we call that IO
10:17:42 <UberLambda> neshepperd, mniip: I meant IO, yes
10:17:58 <consus> ReinH: Could you please suggest some article / package where I could learn how to make fixed-size vectors of arbitrary data type the right way? Seems like a lot of different ways are available.
10:18:01 <geekosaur> note well that IO is not weird because it is a monad; it is weird because it is IO
10:18:12 <ReinH> consus: what are you doing with them?
10:18:15 <UberLambda> but... suppose having a RNG. Is that IO still? Or using C code in Haskell
10:18:24 <mniip> IO is not related to monads
10:18:41 <Cale> I don't think I've ever run into a real performance issue while working on Haskell code which required understanding the manner in which expressions are represented by thunks at runtime to sort out. Just understanding things in terms of graph reduction has always been enough, and more often just thinking in terms of expression *trees* is enough to get most of the idea.
10:18:43 <mniip> it is a monad, but that's not the reason for its fanciness
10:18:44 <UberLambda> They're not really IO operations, but they're impure and it seems they're treated as IO
10:18:50 <consus> ReinH: I have metadata from generated by Linux kernel and I want to have a structure reflecting it.
10:18:50 <geekosaur> a true RNG would have to be in IO; a PRNG would normally be seeded via IO, but otherwise can be pure
10:19:08 <geekosaur> C code in Haskell goes through IO, but if you know it is pure then there is a way to wrap it
10:19:13 <UberLambda> geekosaur: yeah, I meant PRNGs
10:19:23 <UberLambda> geekosaur: oh, that's better then
10:19:32 <Cale> UberLambda: With PRNGs, you can pass the generator state around by hand if you prefer.
10:19:42 <Cale> (or use various tactics to thread it along)
10:19:53 <ReinH> consus: Do you mean fixed-length vectors as in vectors with the length encoded in the type?
10:20:01 <consus> ReinH: Yes
10:20:48 * UberLambda is cloning learnhaskell
10:20:56 <ReinH> consus: Well, there's fixed-vector but I haven't used it and I'm not convinced you actually need them.
10:21:13 <Cale> UberLambda: Yeah, the big thing about IO in Haskell which is different from other languages isn't that it happens to be a monad, but that IO actions are their own type at all.
10:21:34 <ReinH> What about the metadata imples that you need a fixed-length vector?
10:22:10 <ttt_fff> ha! got it working
10:22:15 * ttt_fff is the master of vimscript
10:22:23 <UberLambda> Latex. Is. Big.
10:22:31 <Cale> UberLambda: That is, that we have values which are descriptions of I/O performing things that could be done, and the execution of those actions is separate from evaluation of expressions.
10:22:48 <UberLambda> I mean, 1GB+ of applications to install :O
10:22:58 <UberLambda> Cale: so that it's a sort of "fake purity"?
10:23:00 <Cale> UberLambda: Saying that it's a monad just says something about the API we have for combining those actions.
10:23:01 <ReinH> LaTeX is small. All the extra crap is big.
10:23:32 <UberLambda> ReinH: latex-most on Arch is 1GB+... I don't know how much xelatex requires of it
10:23:34 <consus> ReinH: It is bitmap of some sort (u32 * 256).
10:23:56 <Cale> UberLambda: Well, *evaluation*, the process of turning expressions into values, remains pure.
10:24:02 <consus> ReinH: So I have to define it's size when I get data from disk, put data to disk and when I work with this bitmap.
10:24:09 <ReinH> consus: What do you think a fixed-length vector would offer over a Data.Vector vector?
10:24:27 <UberLambda> Cale: yeah, so it's the compiler that actually does the "dirty" work, right?
10:24:31 <Cale> UberLambda: But execution of IO actions is not pure -- it can have arbitrary effects, and may produce a different result every time when given the same IO action.
10:24:49 <UberLambda> Cale: I mean, the actual execution is defined in the standard libraries somehow or it's up to the compiler?
10:25:04 <ReinH> UberLambda: evaluation is pure, execution is not
10:25:18 <Cale> UberLambda: While this isn't how it really works in GHC, you can imagine that in the Haskell runtime system, there's an interpreter for the IO actions which begins to interpret 'main' when your program starts running.
10:25:21 <ReinH> Oh, Cale said that. I'll shut up.
10:25:32 <consus> ReinH: I was hoping for a compile-time error in case of overflow
10:25:43 <ReinH> consus: what sort of overflow?
10:25:46 <Cale> UberLambda: and in order to do so, it will need to pattern match on main, which is how evaluation starts happening
10:26:23 <UberLambda> Cale: nice
10:26:27 <Cale> GHC actually does something way more hacky because it was more convenient to implement efficiently, where it just uses impure functions that pass around 0-byte-wide tokens, but that's a bad mental model
10:27:13 <UberLambda> 0-byte tokens? How is it even possible?
10:27:30 <UberLambda> like... completely empty data structures?
10:27:32 <Cale> yeah
10:27:56 <nshepperd> type checker / compiler magic, I assume
10:28:13 <Cale> Basically, piggybacking on the dependency analysis which is used to determine the order in which expressions need to be evaluated to sequence the effects.
10:28:32 <consus> ReinH: For example trying to read from disk more data than I should
10:29:31 <Cale> UberLambda: But yeah, getLine :: IO String is as much like a String as /bin/ls is like a list of files.
10:29:56 <ReinH> consus: You couldn't know that at compile time
10:30:00 <Cale> UberLambda: and just as opening /bin/ls in a hex editor won't cause it to execute, evaluating an IO action doesn't cause its effects to occur.
10:30:37 <UberLambda> Cale: that explains it
10:30:40 <Cale> UberLambda: It just does some work that you can't see in order to put the IO action into some sort of normal form.
10:30:55 <Cale> (you can't see because IO is an abstract type and you don't get to see its constructors)
10:30:59 <benzrf> is there a way to do labelled nodes in Data.Graph
10:31:01 <UberLambda> Cale: ...which is compiler magic?
10:31:13 <UberLambda> Also, I can't make https://github.com/bitemyapp/learnhaskell
10:31:15 <UberLambda> :(
10:31:33 <UberLambda> Any prebuilt copy online?
10:31:42 <Cale> UberLambda: Well, the only semi-magical thing is really the *execution* of the IO actions. You can imagine that the IO actions themselves are just some data type like:
10:31:44 <Cale> data IO a where
10:31:49 <Cale>   ReturnIO :: a -> IO a
10:31:56 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
10:32:02 <Cale>   GetChar :: IO Char
10:32:08 <Cale>   PutChar :: Char -> IO ()
10:32:12 <consus> ReinH: Hmm... Well, I know a binary structure that I want to read from disk. I run function where I define how I want to read (e.g. a <- getWord32be, b <- getWord16be, etc). I want to do something similar to a vector.
10:32:16 <UberLambda> Cale: yeah, but it's the actual execution that matters :P
10:32:21 <geekosaur> nothing magical about IO's constructor being hidden, just don't export it
10:32:23 <Cale>   ... etc. etc. other IO primitives, probably some stuff for FFI ...
10:32:45 <consus> ReinH: So I want to define it's length somehow in a type to be sure I will not read more than I should.
10:32:47 <ReinH> UberLambda: it just builds the readme
10:32:55 <UberLambda> ReinH: oh? 
10:32:57 * hackagebot gridland 0.1.0.3 - Grid-based multimedia engine  https://hackage.haskell.org/package/gridland-0.1.0.3 (jxv)
10:32:58 <Cale> UberLambda: Right, the GetChar value here doesn't "know" or in any way encode the information about how to read a Char from the terminal, it just represents the action of doing so.
10:33:02 <benzrf> UberLambda: imagine that a value of IO something is secrectly a string containing a shell script to accomplish something
10:33:15 <benzrf> UberLambda: and then operations like return and (>>=) glue together such scripts
10:33:38 <Cale> UberLambda: and the executor which takes one of these things apart and does what it says to do will say how to carry out each of these things...
10:33:45 <UberLambda> benzrf: hopefully not SQL queries
10:33:49 <benzrf> [:
10:33:55 <UberLambda> benzrf: IO'); DROP TABLE HASKELL
10:34:00 <ReinH> UberLambda: https://github.com/bitemyapp/learnhaskell/blob/master/Makefile#L2
10:34:12 <Cale> UberLambda: That could be a Haskell program as well, in a somewhat circular way -- it would be an IO-performing Haskell program, and not simply one that does evaluation though.
10:34:25 <UberLambda> ReinH: but, where's the actual book?
10:34:31 <ReinH> UberLambda: what actual book?
10:34:40 <UberLambda> Cale: :O
10:34:59 <UberLambda> ReinH: I thought this was a book like Learn you a Haskell?
10:35:09 * UberLambda is confused about what that repo is
10:35:17 <ReinH> learnhaskell is not a book. It's a short list of recommended lectures and exercises.
10:35:24 <ReinH> And some additional advice about installing and such
10:35:26 <Cale> UberLambda: Again, that's not quite how GHC does things, but it's a viable approach which gets used in other similar languages, and I believe some implementations of Haskell in the past have done something similar enough to that.
10:35:32 <UberLambda> Yeah, quite a bit short I see :P
10:36:07 <UberLambda> Cale: is seems quite a bit vulnerable though
10:36:17 <Cale> UberLambda: to what?
10:36:24 <UberLambda> compiler errors
10:36:32 <ReinH> consus: I can see how you might theoretically do that, but in practice a length 256 fixed-width vector is going to be intractable to work with.
10:36:37 <UberLambda> I mean, compilers that generate broken programs
10:37:13 <Cale> UberLambda: Hmm... I'm not sure how I see that this is much worse than anything else as far as "what if the compiler compiles it wrong" :)
10:37:23 <consus> ReinH: So basically it's my responsibility to ensure correct length in get/put?
10:37:45 <piezo> Hi ! I'm having trouble installing profiling libs in sandbox
10:37:45 <ReinH> You're going to have to define mk256 :: a -> a -> a -> a -> a -> ... -> a -> v a with 256 args to get the type safety you want
10:38:09 <ReinH> Otherwise you can create it from a list, but then you lose the length safety property you want
10:38:10 <piezo> cabal generate _p.a files, but ghc-pkg try to register .p_a files
10:38:21 <UberLambda> Cale: if I generate wrong assembly, the program gets killed by the OS. If I generate a wrong script, but it somehow is still semantically correct, it could eat my laundry
10:38:42 <ReinH> consus: well, you can use runtime checks
10:38:49 <UberLambda> Specifically talking about shell scripts
10:38:51 <Cale> UberLambda: If you generate wrong assembly, you could still have your laundry eaten...
10:39:16 <UberLambda> Cale: well, yes, but it's much more difficult without causing, say, a SIGSEGV
10:39:24 <consus> ReinH: Well, of course. Just wanted to make compiler do it for me.
10:39:28 <ReinH> UberLambda: There's a *lot* of content in the lectures and exercises it links to.
10:39:46 <UberLambda> ReinH: I'll check it out, thanks
10:39:58 <ReinH> UberLambda: np
10:39:59 <UberLambda> BTW, thanks everybody for the help :)
10:40:06 <Cale> UberLambda: Of course, in the real compiler, everything is getting turned into assembly by the end anyhow, and this mental model interpreter isn't *really* there.
10:40:29 <UberLambda> Cale: isn't GHC using LLVM by the way?
10:40:34 <ReinH> Cale: in a real compiler, you are probably also installing some sort of backdoor via a hacked compiler.
10:40:44 <Cale> There is a flag you can use to turn on the LLVM backend
10:40:55 <UberLambda> So it's not on by default?
10:41:12 <Cale> The default backend is GHC's own native code generator
10:41:16 <geekosaur> no, because llvm doesn't really understand ghc's generated code
10:41:35 <Cale> Well, the two backends are pretty comparable
10:41:37 <geekosaur> (there's work going on in both llvm and ghc to fix this)
10:41:53 <Cale> iirc, it was a bit of a toss-up which one would do better on any given program
10:42:22 <UberLambda> Well, why wouldn't it "understand" it? It's still a sort of higher-level assembly
10:42:22 <geekosaur> hm, last I'd heard llvm won easily with lots of Double manipulation and otherwise was generally a bit worse
10:43:00 <geekosaur> ghc rewrites function calls in continuation-passing style. llvm needs to know about this to optimize the generated native code
10:43:20 <thoughtpolice> It's mostly just that it's slower to compile without any perceivable impact on any kind of program but the most CPU/loop heavy ones. The LLVM backend is also more fragile in some ways.
10:43:43 <geekosaur> but currently ghc cannot pass on the necessary information, so llvm can't really deal with it and doesn't optimize when going from llvm bytecode to native
10:43:50 <UberLambda> I thought there were additions made to LLVM exactly for that
10:43:57 <UberLambda> I mean, specifically for GHC
10:44:01 <ReinH> thoughtpolice: more fragile when compiling Haskell or more fragile in general?
10:44:08 <thoughtpolice> There were additions made to LLVM for GHC, but that's not what they did.
10:44:30 <UberLambda> oh, alright then
10:44:40 <geekosaur> I did say work was going on in both. I don't know the current state of it but was under the impression ghc needed a fair amount of work to be able to pass on the CPS hinting
10:44:51 <geekosaur> relatively little needed on the llvm end
10:44:51 <Cale> Even though I like the idea of LLVM, part of me is also happy that all the work and thought which went into GHC's current native code generator didn't go to waste.
10:45:02 <thoughtpolice> ReinH: It's fragile in the toolchain sense, because we have to randomly just call out to whatever 'llc' you have in $PATH. In practice LLVM is a 700,000+ LoC codebase and is complex, so it has bugs, too, and because of that, it's very hard to get reproducible bugs or issues, and every platform acts different.
10:45:04 <catgocat> what do you call things in haskell? in other languages you call "objects"
10:45:13 <Cale> catgocat: values?
10:45:16 <geekosaur> in *some* other languages
10:45:39 <UberLambda> I wonder if C would be expressive enough to be used to transpile Haskell programs
10:45:56 <UberLambda> I mean, other languages like Nim do it just fine
10:46:04 <Cale> UberLambda: Hugs was a Haskell interpreter written in C.
10:46:17 <thoughtpolice> Cale: well, the current NCG is quite vintage in most ways, and it also is very small, so those are in its favor. :) There are single .cpp files in LLVM with more code than all of our x86 code generator.
10:46:18 <Cale> UberLambda: But who honestly wants to maintain a compiler that's written in C?
10:46:19 <UberLambda> Cale: oh, so it can be done then
10:46:38 <thoughtpolice> UberLambda: JHC compiles Haskell to ISO C99, so yes, it can be done.
10:46:43 <UberLambda> Cale: exactly the reason why I'm learning haskell... I'd like to write a toy compielr
10:47:01 <UberLambda> thoughtpolice: JHC?
10:47:11 <geekosaur> ghc porting used to involve running ghc in a mode that wrote out insanely slow but portable ANSI C
10:47:19 <thoughtpolice> http://repetae.net/computer/jhc/
10:47:45 <UberLambda> thoughtpolice: oh, I've never heard about it before
10:47:56 <UberLambda> TBH, I think GHC has most users
10:48:06 <geekosaur> also the old ghc backend wrote out not so portable C, and then worked it over with a perl script
10:48:07 <thoughtpolice> It does. JHC just shows a different strategy is possible.
10:48:07 <UberLambda> like... most = 75%?
10:48:15 <thoughtpolice> More like 99.9% I would imagine.
10:48:16 <geekosaur> more like 95%
10:48:26 <Cale> UberLambda: GHC used to compile Haskell via C as well, but it did so in a hacky way that required mangling of the assembly output of the C compiler.
10:48:40 <Cale> and we should all be glad that it no longer needs to do that :D
10:48:41 <UberLambda> Cale: that seems like a nightmare
10:48:44 <geekosaur> jhc is not as complete, but also isn't really targeting the same space; jhc is used for compiling to embedded platforms, for example
10:49:00 <Cale> UberLambda: lol, the Evil Mangler was, just to be even more evil, a perl script
10:49:01 <geekosaur> it doesn't require a dedicated runtime
10:49:08 <geekosaur> (but you pay for that in other ways)
10:49:08 <UberLambda> geekosaur: but, theoretically GHC+LLVM could do that, right?
10:49:21 <UberLambda> oh, no runtime. I see
10:49:43 <geekosaur> whereas ghc's runtime is fairly complex
10:49:50 <UberLambda> Cale: maybe even filled of regexes? :P
10:50:48 <Cale> UberLambda: Yeah, pretty much a long sequence of regexps
10:51:05 <geekosaur> jhc is also a whole-program compiler; if you extended that up to what ghc can handle, compilation would be really slow and probably require large(r) amounts of memory
10:51:06 <UberLambda> Cale: well, it's even worse than I thought then :D
10:51:07 <Cale> http://www.cs.virginia.edu/~wh5a/personal/House-0.8.92/ghc-6.8.2/driver/mangler/ghc-asm.lprl -- here's an old copy
10:51:27 * UberLambda is scared
10:51:56 <UberLambda>   $thing =~ s/:$//m;
10:52:03 <UberLambda> ^ that's quite readable 
10:52:06 <UberLambda> ...not
10:52:38 <Walther> Hmm. Are there any ways to make the executables really tiny? A simple 'main = putStrLn "hello, world!"' nets a 1M executable with ghc -O3
10:52:56 <lpaste_> lambdafan pasted “what does ~ mean in this context?” at http://lpaste.net/137741
10:53:27 <UberLambda> Walther: I don't know if GHC strips symbols, but you could try?
10:53:28 <Cale> lambdafan: That is type level equality
10:53:30 <geekosaur> lambdafan, that's type-level equality
10:53:41 <voidzero> 'strip' will trim it down a bit
10:53:43 <monochrom> GHC doesn't strip. you have to strip for yourself
10:53:45 <voidzero> but you can also use -dynamic i think
10:54:21 <monochrom> -dynamic will just mean the person who needs the exe also has to install GHC and libraries first
10:54:23 <Cale> Walther: btw, -O2 is the maximum
10:54:32 <voidzero> monochrom, yup
10:54:36 <voidzero> small executable though
10:54:38 <monochrom> also, -O2 can increase code size
10:54:44 <lambdafan> Cale : Thanks :)
10:54:44 <Walther> case in point, I made a 4k demo with a tiny bit of js to bootstrap a canvas to render a gl shader. Just wondering if Haskell could be used to a similar extent just for fun :)
10:55:06 <lambdafan> that explains all the other code I'm reading
10:55:06 <monochrom> find another Haskell compiler, one that gives small exes
10:55:07 <Cale> Walther: at one point, GHC would silently ignore the flag if you did -O3, but it now clips to 2 :)
10:55:09 <Walther> sure, not really the purpose of haskell, but i like haskell so why not try
10:55:24 <UberLambda> Down to 759K after stripping here
10:55:39 <lambdafan> I always thought the purpose of haskell was to find ways to manage complexity
10:55:52 <UberLambda> wait, it uses quite a lot of the C standard library
10:55:55 <Cale> Walther: Linking the runtime system which would be required to run your code (with things like the garbage collector and scheduler and such) will put you well over 4K.
10:56:19 <UberLambda> mkfifo?? Is this for the runtime
10:56:29 <UberLambda> I hoped it did whole dead-code elimination
10:56:30 <Cale> But if you use shared objects maybe?
10:57:20 <monochrom> there has not been an economic force to drive down GHC-generated exe size
10:57:25 <UberLambda> it also needs gmp?
10:57:26 <geekosaur> it can do dead-code elimination in some cases; this requires split-objs support, which has a tradeoff in link time complexity and speed (and memory usage; it is known to break some versions of binutils ld)
10:57:26 <Walther> Cale: Mmh, statically linking everything isn't going to fly
10:58:22 <monochrom> but there has been some economic force to drive the existence of other Haskell compilers to do things differently
10:58:37 <Cale> Walther: Hello world with -dynamic seems to be 18.5 k here.
10:58:52 <Walther> Cale: which compiler is that?
10:58:55 <monochrom> if you want small exes then try jhc, ajhc, or some others. even hugs.
10:59:01 <Cale> GHC 7.10.1
10:59:26 <Walther>     Could not find module `Prelude'
10:59:43 <Walther> on 
10:59:45 <Walther> The Glorious Glasgow Haskell Compilation System, version 7.4.1
10:59:50 <Walther> argh, sorry for horrible pastes
10:59:52 <Cale> That's a really really old GHC
10:59:54 <monochrom> especially, if you want exe size, or rather, "exe" size, to be identical to source size, then try hugs.
11:00:04 <UberLambda> isn't there a -Os?
11:00:10 <Walther> yeah, not on my machine, just quickly tried on my shell server :P
11:00:11 <geekosaur> did 7.4.1 have the issue with it getting confused over which one to use?
11:00:27 <geekosaur> or, do you have ghc itself installed but not the .hi files
11:00:30 <Walther> just a quick thought so didn't bother to reboot into my linux side
11:01:06 <Walther> either way, the executables are probably going to be too big
11:01:20 <Cale> UberLambda: I don't think there is
11:01:38 <UberLambda> Cale: yeah, it complains about "malformed integer"
11:02:08 <Walther> a simple shader helloworld equivalent with a js + canvas + minified with pnginator can be had at under 1k so my possible future haskell-based demos would be non-size limited
11:02:40 <Cale> If you care about the size of your generated code, you're probably not using Haskell, at least not directly. You'd be more likely to be writing Haskell code which emits code in some lower-level language.
11:02:57 <Cale> Most of the stuff employing Haskell for embedded computing is doing that.
11:03:09 <Walther> Yeah, sure
11:03:10 <UberLambda> That's... a compiler?
11:03:22 <Walther> and I'm not dissing Haskell for that, I absolutely love haskell for many purposes
11:03:33 <Cale> UberLambda: A compiler which doesn't take input source code, and generates a specific program as its result.
11:03:36 <benzrf> why in gods name is pnginator a thing Walther 
11:03:36 <Walther> was just wondering if I could (ab)use haskell in demos as well
11:03:40 <Walther> benzrf: :D
11:03:48 <Walther> because it's darn efficient
11:03:52 <benzrf> efficient for what
11:03:55 <Cale> UberLambda: There are some cool things like atom for doing that
11:04:07 <Walther> benzrf: compressing demos/intros into size limits
11:04:17 <Cale> UberLambda: http://hackage.haskell.org/package/atom
11:04:40 <UberLambda> Cale: nice
11:05:06 <Cale> UberLambda: Atom was used to write the microcontroller code for some hybrid hydraulic vehicles
11:05:50 <benzrf> Walther: oh i see
11:06:09 <benzrf> Walther: the idea is that it lets you have compression without losing executability?
11:08:01 <Cale> benzrf: There's a backend for diagrams which does some trickery like that, encoding JS canvas commands as a PNG
11:08:13 <benzrf> eeeeeeeeeeewwwwwwwwwwww
11:09:17 <Walther> benzrf: exactöy the idea, yes
11:09:41 <Walther> yes, it's "ugly", but then again really efficient with zlib and so on
11:10:03 <Walther> ~16k of code into ~3k executable, in my case
11:10:12 <benzrf> :|
11:12:35 <voidzero> hehe
11:18:31 <UberLambda> GTG now. Thanks again :)
11:19:46 <jaseemabid> I'm having an issue with codex. I've set my tagger to hasktags. All I can see is a whole lot of readFile errors when I run codex update. Any clue? 
11:21:18 <hamid> @src BSC.hPutStr
11:21:18 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:21:36 <hamid> damn you lambdabot :|
11:23:46 <catgocat> what is -Wall ? how can I turn it on and what does it do ?
11:25:06 <geekosaur> it's a ghc option, it enables all warnings
11:27:10 <catgocat> geekosaur: what do you mean all warnings
11:29:50 <benzrf> anyone know the complexity of the neighbor functions in fgl
11:31:31 <benzrf> also how well does data.map scale
11:32:18 <mauke> catgocat: do you know what ghc is?
11:36:58 <monochrom> you can read GHC User's Guide for which warnings -Wall turns on
11:42:34 <catgocat> mauke: its the compiler ..
11:43:24 <catgocat> how do I chat with lambdabot
11:43:24 <scutigera> hello
11:43:33 <catgocat> ./t lambdabot not working
11:44:12 <mauke> catgocat: right. the compiler can warn you about things that are not technically wrong but highly suspicious
11:44:16 <geekosaur> /query lambdabot
11:44:30 <catgocat> mauke oh ok
11:44:36 <catgocat> @pl histogram lst xs = map char lst : histogram lst (xs \\ sort (nub xs))
11:44:36 <lambdabot> (line 1, column 19):
11:44:36 <lambdabot> unexpected " "
11:44:36 <lambdabot> expecting operator
11:44:45 <catgocat> can anyone help me minify ?
11:44:47 <catgocat> histogram lst xs = map char lst : histogram lst (xs \\ sort (nub xs))
11:44:57 <geekosaur> um, pointfree is not really minification
11:45:14 <scutigera> http://lpaste.net/137743
11:45:14 <geekosaur> well, sometimes it can have that effect, sometimes it's a big blowup (in several senses)
11:45:43 <scutigera> the above link points to code which needs "a better way", hoping to get some advice
11:45:44 <catgocat> yeah help pointfree
11:46:01 <ChristianS> personally i tend not to use the pointfree style if it makes the code longer
11:47:10 <mauke> scutigera: one thing you could do is view_ <- get view; view $= view_ { angle = -(angle view_) }
11:47:19 <mauke> but I bet this can be done with lenses
11:47:43 <scutigera> mauke: well there is definitely  a discussion  i would love to have about a better way to do what i'm doing.
11:48:00 * hackagebot lentil 0.1.3.1 - frugal issue tracker  https://hackage.haskell.org/package/lentil-0.1.3.1 (fffaaa)
11:48:01 <scutigera> but i think what i have is relatively  straightforward if even a bit clunky
11:48:09 <scutigera> i've been looking through xmonad code for some ideas...
11:49:22 <lush> is there a performant way to create an infinite list of the fibonacci series? I know that the function for calculating the n-th fibonacci, but I guess that (map fib [1..]) is not the most efficient way to create such a list..
11:49:26 <lush> any thoughts? ^^
11:49:36 <scutigera> mauke: thanks- that works.  makes things a little cleaner.
11:50:21 <mauke> lush: hah, welcome to haskell 101
11:50:52 <lush> mauke: ? :)
11:50:58 <mauke> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
11:51:00 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:51:34 <lush> mauke: 1mom need to understand that one ^^
11:51:40 <scutigera> monads and applicative and recursion, oh my !
11:52:23 <lush> mauke: so much recursion xd
11:52:41 <lush> aaah
11:52:43 <lush> got it :>
11:52:53 <mauke> > let fibs@(_ : tailFibs) = 0 : 1 : zipWith (+) fibs tailFibs in fibs
11:52:54 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:53:00 <lush> niceeee ^ never would have thought of sth. like that although I know zipWith ^
11:53:02 <mauke> round 2. fight!
11:54:10 <mauke> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs))
11:54:12 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:54:26 <scutigera> mauke: what was broken ?
11:54:44 <scutigera> @fix
11:54:44 <lambdabot> Maybe you meant: thx id faq bid
11:54:47 <mauke> > fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
11:54:48 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:55:10 <scutigera> :t fix
11:55:11 <lambdabot> (a -> a) -> a
11:55:22 <mauke> > fix ((0 :) <$> (1 :) <$> (zipWith (+) <*> tail))
11:55:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:55:24 <catgocat> mauke: How can I use -Wall ?
11:55:33 <mauke> this concludes our lesson on advanced shenanigans
11:55:42 <scutigera> *applause*
11:55:46 <mauke> catgocat: ghc -Wall yourcode.hs
11:56:24 <scutigera> also too, try hlint
11:57:29 <catgocat> What is hlint ?
11:58:00 <scutigera> it gives you suggestions about your code
11:58:16 <scutigera> like removing excessive parentheses, and that sort of thing
11:58:23 <mauke> catgocat: HLint is a tool for suggesting possible improvements to Haskell code.
11:58:31 <mauke> catgocat: These suggestions include ideas such as using alternative functions, simplifying code and spotting redundancies.
11:58:38 <Eelis> how come there's no Enum (Bool, Bool) instance in the prelude? would it be evil for me to define it?
11:58:38 <scutigera> it's supposed to work in emacs, but mine appears to be broken now, which is very annoying
11:58:41 <mauke> catgocat: You can try HLint online at lpaste.net - suggestions are shown at the bottom.
11:59:15 <catgocat> mauke: my code doesn't show anything in the bottom
11:59:19 <catgocat> does that mean it's correct?
11:59:25 <mauke> catgocat: link?
11:59:30 <catgocat> http://lpaste.net/137745
11:59:57 <scutigera> mauke: how do you invoke hlint at lpaste ?
12:00:05 <scutigera> is it automagic ?
12:00:05 <Eelis> > succ (False, False)
12:00:07 <lambdabot>      No instance for (Enum (Bool, Bool)) arising from a use of ‘succ’
12:00:07 <lambdabot>      In the expression: succ (False, False)
12:00:35 <mauke> catgocat: yeah, looks like it's found nothing to complain about
12:00:49 <mauke> scutigera: yes
12:01:03 <mauke> Eelis: if anything (Enum a, Enum b) => Enum (a, b)
12:01:51 <Eelis> mauke: that might be tricky without Bounded
12:02:53 <catgocat> what does this mean in -Wall Defaulting the following constraint(s) to type `Integer'
12:02:57 <mauke> oh, right
12:03:01 <catgocat> in | n < 1 || n > length xss ^ 2 = Left "Out of range"
12:04:05 <scutigera> catgocat: try providing an explicit type signature
12:04:26 <mauke> catgocat: you're using a number but there's no explicit indication what type it should be
12:04:36 <mauke> so ghc guesses you wanted an Integer
12:06:15 <catgocat> mauke: I can't.. can you please show me?
12:07:15 <Eelis> bleh, and 'deriving Enum' also doesn't work if you have a constructor with a Bool parameter
12:08:15 <geekosaur> any parameter
12:08:43 <Eelis> would it be unreasonable to make it work for Bounded parameters?
12:08:50 <scutigera> catgocat: 1. try supplying an explicit type signature. 2. if that's giving you trouble put the code in an lpaste buffer and provide link.
12:10:31 <mauke> catgocat: can't what?
12:11:22 <Eelis> that is, would a patch extending ghc's Enum deriving mechanism to make it work for constructors with Bounded parameters likely be accepted?
12:13:25 <geekosaur> that would be only the start, as the current behavior is mandated by the language report
12:13:46 <geekosaur> "Derived instance declarations for the class Enum are only possible for enumerations (data types with only nullary constructors)." (11.2 https://www.haskell.org/onlinereport/haskell2010/haskellch11.html#x18-18400011.2)
12:14:17 <Eelis> is there already an existing ghc extension flag for additional instances beyond those guaranteed by the report?
12:14:24 <Eelis> if so, it could cover this as well
12:16:20 <Eelis> but i'm mostly curious about why it's not supported already
12:16:28 <Eelis> i bet there's some reason for it
12:17:09 <Sindriava> What's the most elegant / idiomatic way to do command line opts in Haskell?
12:19:10 <ChristianS> Sindriava: optparse-applicative is a nice library for that use case
12:19:21 <Sindriava> ChristianS: Thanks! I'll check it out
12:19:56 <drewbert> Sindriava: did you read https://wiki.haskell.org/Tutorials/Programming_Haskell/Argument_handling ?
12:20:27 <Sindriava> drewbert: Nope! I'll do so now ^^
12:22:41 <catgocat> this is stupid
12:22:52 <catgocat> if I do ^ 2 it gives me a default contraint error
12:22:59 <catgocat> if I do ^ (2 :: Integer) it doesnt give error
12:23:09 <catgocat> this is really annoying
12:26:53 <ChristianS> Sindriava: but note that that tutorial only covers System.Console.GetOpt from the base library, optparse-applicative is a separate library but much nicer to use
12:27:45 <scutigera> catgocat: it really shouldn't do that if you provide a type signature for the function...
12:27:52 <geekosaur> catgocat, it's expected, actually
12:27:53 <drewbert> ChristianS: should we add that to the wiki?
12:27:56 <geekosaur> :t (^)
12:27:57 <lambdabot> (Integral b, Num a) => a -> b -> a
12:28:03 <Sindriava> catgocat: Without a code context, (^2) shouldn't work really
12:28:16 <geekosaur> there's no way to constrain b except by a type annotation. the warning is.. unfortunate
12:28:24 <ChristianS> drewbert: i'm in favor, but too lazy
12:28:25 <geekosaur> be nice if ghc had a pragma to suppress it for (^)
12:28:34 <Sindriava> geekosaur: Like almost every other warning that GHC gives :(
12:28:40 <scutigera> and if you think that's annoying wait until you are using opengl
12:28:41 <Sindriava> ChristianS: I figured, thanks :)
12:28:52 <scutigera> and your code is littered with realToFrac and fromIntegral
12:29:02 <Sindriava> scutigera: Don't even start x_x
12:29:08 <Sindriava> scutigera: That's why I'm writing a wrapper
12:29:13 <scutigera> sorry...
12:29:26 <scutigera> FFI's are hard, I know...
12:29:32 <Sindriava> scutigera: No need to be sorry!
12:29:48 <drewbert> I got a wiki account last week, I haven't made any edits with it yet, so this should be an uncontroversial start.
12:30:00 <Sindriava> scutigera: the OpenGL bindings are 1:1, which makes them unfortunate to use in idiomatic code
12:30:06 <scutigera> the problem is mostly i just don't know the right point to do that
12:30:28 <scutigera> should i delay until as late as possible. work with GLfloat from the start, etc...
12:30:36 <scutigera> i get wracked with indecision. lol.
12:31:00 <Sindriava> scutigera: Easy. Write all your 'logic' in Haskell, then interface that logic to OpenGL
12:31:18 <Sindriava> scutigera: IMO the "conversion point" should be as close to OpenGL as possible
12:31:20 <scutigera> well that's basically what i'm trying to do
12:31:37 <scutigera> yes- that was my conclusion.
12:31:37 <Sindriava> scutigera: You can also get around a LOT of these issues by giving better type signatures
12:31:54 <Sindriava> scutigera: Integral a => a -> a -> a for example
12:32:04 <scutigera> ah- interesting...
12:32:08 <scutigera> ty!
12:32:12 <Sindriava> scutigera: instead of Int -> Int -> Int
12:32:40 <Sindriava> scutigera: Basically always try to give as much of a general type signature as you can, it will help you in the long run, as it makes the code reusable
12:33:06 <scutigera> excellent point. now if only i understand the numeric types well enough to do that ;-)
12:33:24 <Sindriava> scutigera: There's an excellent graph of the hierarchy floating around, I'll find it for you
12:33:41 <lambdafan> :q
12:33:42 <scutigera> wait. i think i might have a bookmark to that
12:33:45 <Sindriava> scutigera: (note: "as you can", not "as possible". Don't get tangled with this premature optimization, you can almost always do it later)
12:34:42 <scutigera> i've seen that graph of the hierarchy- but i don't have the link, so if you have it handy :-)
12:34:43 <Sindriava> scutigera: https://martingalemeasure.files.wordpress.com/2014/07/chart.png?w=660
12:34:51 <Sindriava> ^
12:34:51 <scutigera> great! ty!
12:35:50 <Sindriava> scutigera: The only ones I really ever needed to use for non-numeric code are Integral, Num and Double
12:37:05 <scutigera> could i hit you up with some example code and maybe you could take a look ?
12:37:09 <Sindriava> scutigera: The handy thing is that GLuint is aliased to Word32, which means it's an instance of Integral, so that solves a lot of issues
12:37:39 <Sindriava> scutigera: Sure, upload them to LPaste and I'll take a look, but keep in mind that I'm still a Haskell beginner myself, I might not be able to answer all your questions :)
12:38:02 <scutigera> yes- well. i'm at the beginning of the beginning and have been for some time.
12:38:17 <scutigera> http://lpaste.net/137747
12:38:53 <scutigera> that's a pretty good example of what i'm doing. it's basically calculate the image and then draw it all.
12:39:07 <scutigera> so naturally the calculations should be maintained in Double
12:39:29 <scutigera> you'll see that i'm already doing what i shouldn't because i just realized this morning i should change it :-)
12:40:49 <Sindriava> scutigera: It looks from the code that you're using GLUT, right? I'd guess you were following the HaskellWiki OpenGL tutorial
12:41:08 <scutigera> oh probably. can't remember. just picked up this code recently.
12:41:17 <scutigera> after having not looked at it in a while.
12:41:33 <scutigera> yes- i am using GLUT
12:41:52 <scutigera> i tried using GLFW and was having a hell of a time making something appear in the window and gave up.
12:42:14 <Sindriava> scutigera: Yeah, that's the thing. The architecture of OpenGL changed a bit, you might want to look at the modern way of doing it
12:42:33 <scutigera> please continue :-)
12:42:33 <Sindriava> scutigera: I'd recommend http://open.gl as a starting point, although it's using C.
12:43:08 <scutigera> yeah- i've been tempted to use SDL as the input interface
12:43:26 <Sindriava> scutigera: The whole process of getting a triangle on the screen is a lot more complicated and convoluted than the old way, but you get big performance gains and a lot more flexibility
12:43:59 <Sindriava> scutigera: For modern OpenGL + SDL2, there's a good example here: https://github.com/ericnething/gl-sdl2-basics
12:44:02 <scutigera> oh my. back to the bottom of the learning curve :-(
12:44:16 <Sindriava> scutigera: You get used to it :D
12:44:27 <scutigera> yeah- tell me about it. lol.
12:44:48 <Sindriava> scutigera: The example should give you a good idea of how it all clicks together, ultimately the new system is a LOT better, but for now, you'll just have to take my word for it
12:45:10 <scutigera> i can do that. haha. i know where to find you if it all goes sideways ;-)
12:45:20 <Sindriava> scutigera: You have to write shaders to get a triangle on the screen and it's all a bit complicated, but open.gl explains it wonderfully
12:45:47 <Sindriava> As for the code
12:46:07 <Sindriava> Protip: You don't have to specify the name of data fields for destructuring
12:46:36 <Sindriava> `View { angle=angle, posxyz=(x,y,z) } <- get view` is equal to `View angle (x,y,z) <- get view`
12:46:41 <scutigera> i thought you did unless you use XSomethingIdonotremember pragma ?
12:46:55 <scutigera> ok- i had no idea...
12:46:57 <Sindriava> scutigera: Not that I know of, I don't use any Pragma :)
12:47:07 <scutigera> hmmm... maybe that's in ML
12:47:19 <Sindriava> note that the key factor is the order in which the fields are specified
12:47:40 <scutigera> ah- well that's why i use field name. to remove ambiguity and not have to worry about order.
12:47:51 <Sindriava> scutigera: Yeah, that can be a good idea :)
12:47:52 <suppi> Sindriava, scutigera, I also have one :) https://github.com/soupi/haskell-sdl2gl though I don't know if that's even the right way to go about it
12:47:57 <scutigera> there's actually 6/7 fields in View
12:48:17 <Sindriava> scutigera: Oh! Well, than by all means, the named version is the way to go
12:48:37 <scutigera> suppi: that's excellent- thanks very much for the link.
12:48:39 <Sindriava> scutigera: Although angle=angle might be a bad idea, probably `angle=phi` or something could be a bit more readable
12:48:42 <Sindriava> suppi + 1
12:48:50 <scutigera> suppi + 2
12:48:55 <suppi> scutigera, Sindriava, gladly
12:49:14 <scutigera> Sindriava: funny you should say that - i was just looking at it and thinking the same thing. in fact i had the code like that originally...
12:50:25 <Sindriava> scutigera: lambda functions also don't need to be enclosed in parentheses, a more idiomatic way (at least to my liking) would be `mapM_ $ \(x, y, z) -> ...` instead of `mapM_ (\(x, y, z) -> …)`
12:50:52 <scutigera> yeah- hlint is good about catching that stuff. unfortunately...
12:51:00 <scutigera> hlint and haskell-mode aren't getting along right now.
12:51:11 <scutigera> haskell-mode has been somewhat frustrating to work with at the start.
12:51:35 <benzrf> @hoogle MonadError e m => Either e a -> m a
12:51:36 <lambdabot> Data.Either rights :: [Either a b] -> [b]
12:51:36 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
12:51:36 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
12:51:45 <benzrf> either throwError return... is it a function?
12:52:36 <Sindriava> I'm using Vim with 'dag/vim2hs', 'eagletmt/ghcmod-vim', 'eagletmt/neco-ghc' plugins
12:53:00 <Sindriava> scutigera: Which works decently enough :) Atom also has a lot of plugins lately
12:53:29 <scutigera> haha. i love the brevity of vim, but my brain refuses to get along with the mode changes. also too, 25 years of emacs. :-)
12:53:35 <catgocat> I have compiled my haskell to file.o
12:53:37 <catgocat> how do I run it?
12:54:02 <arkeet> hm? how did you compile it
12:54:04 <catgocat> ghc
12:54:08 <catgocat> ghc file.hs
12:54:16 <arkeet> did you define main?
12:54:26 <catgocat> yeah
12:54:26 <scutigera> Sindriava, suppi - thanks very much. i'm off to look at the "new-to-me opengl". 
12:54:32 <arkeet> then it should have produced an executable
12:54:50 <suppi> scutigera, good luck
12:55:20 <Sindriava> scutigera: Just bite it down, the modern OpenGL way is ugly and full of gotchas, but ultimately a much better way to do stuff until glNext comes around or whatever
12:55:29 <benzrf> tfw i finally arrive at the line of code that would be cleaner if i used lenses and succumb to the urge
12:55:36 <benzrf> you win this time edwardk ;-;
12:55:48 <catgocat> it only created .o and .hi
12:56:02 <catgocat> [2 of 2] Compiling TicTacToe        ( TicTacToe.hs, TicTacToe.o )
12:56:11 <suppi> I broke my vim setup when upgrading to GHC 7.10.2. now ghc-mod doesn't work :(
12:56:40 <chattered> suppi: Isn't that just a ghc-mod prob? I think it's the same in Emacs.
12:56:52 <suppi> chattered, it is as far as I know
12:57:27 <Sindriava> suppi: My ghc-mod works, although it's always shoddy as fuck
12:57:43 <Sindriava> suppi: I've build some fork from an issue that's opened on github
12:57:44 <mada> my ghc-mod doesn't work either. Tries to read /usr/lib/ghc-7.8.4/settings and it doesn't exist
12:57:49 <Sindriava> suppi: I'll try to find the link for you
12:57:55 <suppi> I would like to switch to spacemacs, but I don't really know how
12:58:04 <suppi> Sindriava, cool. thanks
12:58:23 <Sindriava> suppi: Suffer vim for a bit longer and we'll get to the promised land of NeoVim :)
12:59:21 <suppi> Sindriava, There is nothing wrong with trying new editors :)
12:59:32 <bufferloss> suppi, unless that editor is emacs :P
12:59:37 <Sindriava> :D
12:59:50 <suppi> bufferloss, why? what's wrong with emacs?
13:00:07 <chattered> suppi: bufferloss means there's nothing wrong with trying new editors unless you're already *using* emacs.
13:00:12 <chattered> Emacs is obviously the globla maximum.
13:00:15 <chattered> *global
13:00:33 <Sindriava> suppi: Yeah, that wasn't my point. Just that a lot of people (me included) find Vim insufferable (which is mainly fault of the people developing it, it seems) and don't know that NeoVim is coming
13:00:40 <bufferloss> if by maximum you're referring to bloat, then, yeah sure XD
13:00:45 <bufferloss> also maximum RSI
13:00:52 <Sindriava> also maximum RMS
13:00:57 <bufferloss> lol
13:01:19 <Sindriava> Emacs is better in every way than Vim, it only lacks a decent text editor
13:01:29 <suppi> wow, didn't mean to start an editor war 
13:01:31 <Sindriava> <flame flame flame>
13:01:41 <bufferloss> Sindriava, I don't think that's the fault of the people development, the people who find vim insufferable are people we don't want bothering us in #vim anyway :P
13:02:07 <bufferloss> #vim isn't for weak noobs who are gonna run home and cry to mommy
13:02:13 <bufferloss> that's what emacs is for
13:02:23 <Sindriava> bufferloss: Submitting a patch to Vim is close to impossible ¯\_(ツ)_/¯ That's the main problem.
13:02:27 <Sindriava> And the codebase is a wreck
13:02:30 <Sindriava> suppi: Don't worry, it's all in good spirit :)
13:02:48 <suppi> :)
13:02:50 <bufferloss> Sindriava, yeah I'm just talking about usage, not necessarily code base
13:03:02 <bufferloss> neovim is interesting though, we'll see how it pans out
13:03:23 <Sindriava> bufferloss: It uses Lua instead of VimL, which indicates at least some sanity behind it
13:03:36 <catgocat> can anyone tell me how to run compiled haskell files?
13:03:37 <Sindriava> Also, you can write neovim plugins in haskell, IIRC
13:03:42 <catgocat> I have a file.hi and file.o
13:03:44 <suppi> so what exactly is neovim? i heard the name but only that it is pre-beta
13:03:55 <bufferloss> suppi, what is google?
13:04:10 <Sindriava> suppi: A fork of Vim, that's not run by delusional idiots :D
13:04:13 <suppi> bufferloss, great question, let me ask ddg
13:04:18 <Sindriava> @hoogle google
13:04:18 <lambdabot> Google rocks!
13:04:18 <lambdabot> package google-dictionary
13:04:18 <lambdabot> package google-drive
13:04:47 <suppi> catgocat, please share your code http://lpaste.net
13:04:50 <Sindriava> catgocat: Those aren't executables. just do `ghc name.hs` and it will make a `name` file that you can run
13:05:09 <catgocat> if I do -o it creates an .exe file
13:05:10 <Sindriava> catgocat: If that doesn't work, paste your GHC version and try `ghc --make name.hs` instead
13:05:13 <catgocat> otherwise it doesnt
13:05:21 <Sindriava> catgocat: Are you on Windows?
13:05:49 <y> catgocat: you need a `Main` module
13:06:09 <y> catgocat: which exports the main action
13:06:14 <Beardful> Can anyone who has used FTGL tell me what's wrong with this code? It should render text when i run it and it is copy-pasted from FTGL documentation yet it still doesn't show anything when i run it.
13:06:18 <Beardful> http://sprunge.us/MHWL
13:06:32 <catgocat> Sindriava: yes
13:07:08 <Sindriava> Well then I can't help you.
13:07:12 * Sindriava jumps out the window
13:07:50 <Sindriava> suppi: here's the ghc-mod I'm using
13:07:53 <Sindriava> suppi: DanielG/ghc-mod
13:07:56 <mada> which ghc-mod returns ~/.cabal/bin/ghc-mod, but ghc-pkg list doesn't show it in the global or the local list
13:08:00 <Sindriava> ugh, on github, you know what to do :D
13:08:23 <suppi> Sindriava, 10q
13:09:49 <Sindriava> suppi: It's a few commits behind the original, maybe it's been fixed already, check that out
13:10:28 <Pamelloes> How can I convert a float into a Double? Do I have to do (fromRational . toRational) or is there a better way?
13:11:26 <nullvoid8> Pamelloes: there's a float2double function somewhere
13:11:33 <mauke> Pamelloes: realToFrac
13:12:08 <Pamelloes> mauke: Cool, exactly what I was looking for :)
13:14:26 <catgocat> In the compiler, everytime I output something to the console I have to call hFlush stdout
13:14:30 <catgocat> is there any workaround to this?
13:15:06 <joco42> if I install a package from hackage using cabal then where will be the sources downloaded to ?
13:16:15 <nullvoid8> joco42: depends on your OS
13:16:31 <joco42> nullvoid8: linux , ubuntu
13:17:39 <nullvoid8> joco42: try ~/.cabal and ~/.ghc
13:17:52 <joco42> nullvoid8: ok, i have a look, thanks
13:17:57 <catgocat> is it ok to use `hSetBuffering stdout NoBuffering` ?
13:18:04 * hackagebot deterministic-game-engine 0.3.0 - Simple deterministic game engine  https://hackage.haskell.org/package/deterministic-game-engine-0.3.0 (tgolson)
13:18:08 <catgocat> because everytime I use putStr I have to hFlush stdout
13:18:31 <nullvoid8> joco42: why do you want to know anyway?
13:18:55 <joco42> nullvoid8: i want to look at the sources to understand ghcjs
13:19:16 <joco42> how ByteArray# looks like
13:20:43 <nullvoid8> joco42: "cabal get" will fetch the source and put it in the current directory
13:21:10 <nullvoid8> "cabal help get" for usage
13:21:13 <joco42> nullvoid8: thanks, that is a useful command to know
13:21:47 <nullvoid8> also, you can browse the sources directly in your browser from hackage
13:23:04 * hackagebot fwgl 0.1.2.2 - FRP 2D/3D game engine  https://hackage.haskell.org/package/fwgl-0.1.2.2 (ZioCrocifisso)
13:23:06 * hackagebot fwgl-javascript 0.1.0.6 - FWGL GHCJS backend  https://hackage.haskell.org/package/fwgl-javascript-0.1.0.6 (ZioCrocifisso)
13:33:04 * hackagebot deterministic-game-engine 0.3.1 - Simple deterministic game engine  https://hackage.haskell.org/package/deterministic-game-engine-0.3.1 (tgolson)
13:50:45 <aznashwan> anyone know a quick and painless (i.e. no cross-compiling-involving) way of getting ghc running on Arch on armv6?
13:53:05 * hackagebot th-typegraph 0.24 - Graph of the subtype relation  https://hackage.haskell.org/package/th-typegraph-0.24 (DavidFox)
13:53:07 * hackagebot th-context 0.20 - Test instance context  https://hackage.haskell.org/package/th-context-0.20 (DavidFox)
13:54:54 <benzrf> @hoogle f (a -> b) -> a -> f b
13:54:54 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:54:54 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
13:54:54 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
13:55:55 <Beardful> When i cabal installed bitmap-opengl ghc panicked. Is this a known bug or should I report it ?
13:56:01 <benzrf> hm
13:58:26 <ReinH> aznashwan: Um. Without cross-compiling?
13:59:03 <ReinH> So you want to compile it on armv6 hardware?
14:14:10 <hexagoxel> @tell Beardful can only reproduce on the completely outdated ghc-7.10.1, not on the current ghc-7.10.2
14:14:10 <lambdabot> Consider it noted.
14:26:21 <vik123> Hi all. Is there a way to make a data declaration and then make a data declaration again with the same type name? 
14:26:25 <vik123> Something like .. 
14:26:37 <vik123> data Type1 = Record1 { }; data Type2 = Record2 { }'
14:26:57 <vik123> *data Type = Record1 {}; data Type = Record2 {};
14:27:03 <monochrom> no.
14:27:29 <vik123> So all records must be declared within one data declaration? 
14:27:34 <vik123> ah.. okay thanks.
14:28:29 <Sindriava> I moved a folder containing a cabal sandbox
14:28:37 <Sindriava> How can I reconfigure the paths?
14:31:00 <geekosaur> edit the *.conf files under the package.conf.d and then (iirc) cabal sandbox hc-pkg recache
14:31:38 <Sindriava> And there I was, thinking that it wouldn't be as stupid as the rest of cabal -.-
14:31:43 <Sindriava> geekosaur: Thanks!
14:32:07 <Sindriava> I'll just remove the sandbox and cabal install again
14:32:29 <geekosaur> this is another of those things where it's ghc
14:33:02 <geekosaur> cabal cannot rewire ghc to use relative paths there (there is no guarantee it's accessing them from the same place each time)
14:33:25 <geekosaur> but since it's still "in" to claim it's cabal-install's fault. golly gee it is cabal-install's fault like everything else!!!
14:33:54 <aznashwan> ReinH: sorros; was momentarily away
14:34:24 <aznashwan> ReinH: ideally; i'd love a pre-made package/archive
14:40:14 <ttt_fff> damn it, where are the decent "editor written in haskell" projects? every time I write vimscript, I'm like "why the fuck is this language not typed?"
14:40:30 <ttt_fff> Yi, Leksah -- y u not ready for porduction use yet?
14:41:07 <srhb> ttt_fff: Doesn't both Neovim and Emacs support extensions in Haskell (with various methods)?
14:41:27 <mniip> mdamn merijn is not around
14:41:39 <ttt_fff> srhb: https://hackage.haskell.org/package/nvim-hs agrees with you about neivom
14:41:48 <ttt_fff> mniip: when are you starting college?
14:41:50 <srhb> ttt_fff: And the other one is haskell-emacs
14:41:58 <mniip> ttt_fff, wait
14:42:25 <mniip> the more I read TaPL the more I see how haskell truly is the best FP language
14:42:32 <mniip> certainly better than ML
14:43:12 <azsx> I used to dream about a web framewor written for ML
14:43:17 <mniip> apparently laziness and first-class functions aren't the only key points
14:43:24 <azsx> but Haskell killed that
14:43:25 <ttt_fff> srhb: https://hackage.haskell.org/package/nvim-hs-0.0.2/docs/Neovim.html looks amazing
14:43:40 <azsx> framework
14:43:41 <srhb> ttt_fff: I'm too set in my ways to change. Besides, I don't mind emacs lisp terribly.
14:44:07 <ttt_fff> srhb: you're like that soldier who's taken an arrow into the knee and can no longer go on new adventures
14:44:09 <mniip> abstraction of evaluation order and total separation of execution from evaluation is pretty damn important too
14:44:25 <srhb> ttt_fff: Yes, pretty much. Or in other words "old" :P
14:46:05 <mniip> I should write an editor in haskell
14:46:27 <mniip> an ed clone
14:47:39 <mniip> because all other editors introduce useless bloat like layout and positional interface
14:47:55 <geekosaur> hteco? :p
14:48:48 <mniip> what's that
14:49:46 <geekosaur> nonexistent, one hopes :)
14:50:15 <geekosaur> https://en.wikipedia.org/wiki/TECO_(text_editor)
14:53:08 * hackagebot verbosity 0.1.0.0 - Simple enum that encodes application verbosity.  https://hackage.haskell.org/package/verbosity-0.1.0.0 (PeterTrsko)
14:54:53 * geekosaur spent a certain amount of time editing programs in a fullscreen variant of TECO in the early 80s...
14:55:23 <mniip> that is an interesting package
14:55:45 <Sindriava> geekosaur: Well, I'm not particularly sold on the fact that the libs have to reside in the folder the sandbox is in, but sure
14:55:46 <mniip> why does it depend on ghc-prim though
14:56:37 <indiagreen> mniip: maybe because of GHC.Generics?
14:56:53 <indiagreen> hm, no
14:57:11 <Sindriava> geekosaur: For the sake of the argument, it's useless to blame GHC for problem that might be caused by GHC, but wouldn't exist without cabal-install. I'll look into NixOS in the future, maybe that'll bring some light into it
14:59:02 <Sindriava> geekosaur: The libs could be installed into .cabal and wired into the sandbox on need-to-have basis, which would solve both issues, but maybe create more?
14:59:05 <geekosaur> so if cabal-install is providing sandboxes by doing things ghc does not support, cabal-install should (as so many do indeed believe) simply not bother to exist
14:59:06 <geekosaur> of course
14:59:11 <geekosaur> would create more
14:59:16 <Sindriava> geekosaur: Calm down pls
14:59:40 <geekosaur> because now you MUST build everything in sandboxes, because everything outside a sandbox is going to be a conflict
15:00:16 <Sindriava> geekosaur: If there wasn't a tooling problem, there wouldn't be so much talk about tooling problems (or, in fact, you saying "cabal-install's fault like everything else!!!")
15:01:39 <geekosaur> but for some problems stemming from the underlying system, the only possible conclusion is don't waste time on tooling
15:01:51 <Sindriava> geekosaur: That's where our opinions differ.
15:02:28 <Sindriava> geekosaur: If the problems are stemming from an underlying system, you should build a better solution around them, not pass on the guilt onto someone else.
15:02:47 <fvgvxmpv1> I´m just now coming into the discussion, but: Sindriava, have you considered just using nix without switching to NixOS?
15:03:23 <geekosaur> so at what point does it become reasonable in your system to either jettison ghc, or have cabal-install reimplement most of ghc, to work around it?
15:03:41 <Sindriava> fvgvxmpv1: Thanks for the suggestion! Yeah, I've tried in the past, but I'm on OSX and at the time, there were some issues with darwin stdenv, and I couldn't build half the stuff I needed, because nix couldn't see CoreFoundation etc.
15:04:06 <fvgvxmpv1> Yeah, I can imagine it being hell on OS X.
15:04:49 <geekosaur> mniip, I think ghc-prim is because it avoids importing the whole Prelude and then needs to pull in ghc-prim or else make assumptions about how things are implemented?
15:04:55 <geekosaur> (in other words, it's a bit of a hack)
15:04:56 <Sindriava> fvgvxmpv1: A lot of people are working hard on fixing it and from what I've heard, it's getting easier with new releases of OSX – for what I know, maybe it's fixed already, I've recently heard someone talking about using nix on OSX
15:05:42 <Sindriava> geekosaur: I highly doubt those would be the only options in such case. And I also highly doubt that writing a cabal-install "update", which would fix those problems (which shouldn't be hard, if I can fix tham manually), isn't an option now
15:06:26 <lispy> cabal install does have an update command
15:06:33 <Sindriava> geekosaur: But all I did was move a folder on my filesystem for god's sake. I highly doubt that's an unrecoverable state.
15:07:02 <Sindriava> lispy: Which does something completely different. I've put the update in quotes, because I couldn't think of a better name
15:07:06 <geekosaur> if you're lucky, it might be able to guess the old location and rewrite the patjs
15:07:26 <Sindriava> geekosaur: What do you mean, the old location?
15:07:31 <geekosaur> I could see a cabal sandbox move in the future --- but then you;d rant that you have to use that instead of just moving it and cabal-install reading your mind afterward to fix it
15:07:37 <geekosaur> ...
15:07:41 * lispy can't figure out what features are being discussed
15:07:52 <geekosaur> never mind, I guess not knpowing anything about the implementation means you can assume random magic
15:07:53 <Sindriava> geekosaur: The old location is written in the config file and the new location is $(pwd)
15:08:08 <hexagoxel> (lispy: relocating a sandbox, i believe)
15:08:30 <Sindriava> lispy: Yup! Relocating a folder with my project broke my sandbox, because the paths are hardwired
15:08:54 <Sindriava> geekosaur: Maybe we'll discuss when you're calmed down? I'm sensing a fair bit of hostility in your tone.
15:09:11 * lispy thinks geekosaur seems pretty chill
15:09:41 <Sindriava> "00:07  <geekosaur>	never mind, I guess not knpowing anything about the implementation means you can assume random magic"
15:09:42 <lispy> I think part of the problem with moving a sandbox has to do with pathing for shared objects.
15:10:38 <ttt_fff> is there a way, in haskell, to define lists of heterogenous elements? (a slight generatlizatino of tuples)
15:10:47 <ttt_fff> basically and still keep track of the type of eeach element
15:10:59 <ttt_fff> (it's okay if this forces that the compiler to be able to infer length of list)
15:11:17 <hexagoxel> @hackage HList
15:11:17 <lambdabot> http://hackage.haskell.org/package/HList
15:11:24 <fvgvxmpv1> ttt_fff, nested tuples, sum types, ...?
15:11:45 <Cale> ttt_fff: Every approach is basically some variation on nested pairs
15:12:14 <Cale> I guess using type level lists of types might count as a bit different :)
15:12:20 <ronh> ttt_fff, list of sum type won't do?
15:12:41 <ttt_fff> ronh: no, think typed forth
15:12:48 <ttt_fff> I want a way to keep track of the types of the satck
15:12:54 <Cale> But yeah, whenever you find yourself wanting to make a list of elements of different types, you really ought to ask yourself why
15:12:55 <ttt_fff> damn it, someone in #haskell told me an earlier time
15:12:57 <ttt_fff> but I can't find the post
15:13:23 <ttt_fff> he did a badass construction of data MyList = Null | Cons _ _
15:13:32 <Cale> Usually the *real* answer is to figure out what all those things have in common, i.e. what you're going to do with them when you get them back out of the list, and put *that* in the list instead.
15:13:33 <ttt_fff> where the Cons somehow was able to handle elements that was not the same as the rest of the type
15:14:01 <ttt_fff> Cale: no, I want a forth that is type checked, so it doesn't do things like "hello" - "world" where "-" is Int -> Int -> Int
15:15:48 <lpaste_> Cale pasted “old forthish thing” at http://lpaste.net/137754
15:16:03 <ttt_fff> I think what I want is https://downloads.haskell.org/~ghc/7.6.2/docs/html/users_guide/promotion.html
15:16:18 <ttt_fff> Cale: thanks
15:16:24 <ttt_fff> Cale: but ghc has 62 limit on tuple
15:16:30 <ttt_fff> I think with datakinds, one can avoid that limitation
15:16:35 <Cale> ttt_fff: That only uses pairs
15:17:04 <Cale> @let start k = k (); end (x,_) = x; push x s k = k (x,s); pop (_,s) k = k s; add (a,(b,s)) k = k (a+b,s)
15:17:05 <lambdabot>  Defined.
15:17:06 <ttt_fff> hmm, taht's waht you meant by "nested pairs"
15:17:24 <lispy> so nested in hurts, but hey it works
15:17:49 <Cale> > start (push 1) (push 2) (push 3) add add end
15:17:51 <lambdabot>  6
15:18:00 <hexagoxel> ttt_fff: that is pretty much the definition from HList package
15:18:26 <Cale> It's pretty much useless, but it's fun
15:18:38 <Hafydd> addend
15:19:01 <Cale> The type errors you get are also completely unreadable
15:22:45 <Cale> ttt_fff: I can write something like what I think you're referring to though...
15:23:05 <Cale> Actually, maybe that's what modern HList does, lemme check
15:23:38 <ttt_fff> Cale: oh, i hope it's somewaht readable
15:23:47 <ttt_fff> Cale: I intend to use this to build a haskell DSL -> javascript compiler
15:24:06 <ttt_fff> I can't figure out how to get "haskell lambdas" into "javascript datatype lambdas"
15:24:19 <ttt_fff> but forth eliminates the env, so I don't mind writing the js code in a forth-in-haskell DSL
15:24:28 <ttt_fff> so yeah, I need to get the type errors to be readalbe
15:24:37 <ttt_fff> bu ton the plus side, the "depth" of the stack, I doubt, will ever be > 5
15:24:46 <Cale> Well, I'm not suggesting you actually try to use that forthish thing for anything :)
15:25:11 <Cale> I don't quite understand why this sort of problem requires heterogeneous lists of any kind
15:25:13 <ttt_fff> Cale: if it doesn' towkr, I'm going to demand triple my money back
15:25:23 <catgocat> shorter way to write n < 1 || n > (length . concat) xss
15:25:28 <catgocat> ??
15:25:42 <ttt_fff> if you're representing the stack as a tuple, you don't need hetereogenous lists
15:26:05 <Cale> ttt_fff: even so -- shouldn't the stack be a homogeneous list?
15:26:17 <Cale> What different types of elements can you even have there?
15:26:18 <ttt_fff> Cale: no, the stack could be (1, "hello", 3, "world")
15:26:30 <ttt_fff> I also want to have arbitrary haskelll data types on the stack
15:26:33 <Cale> Just JS values, no?
15:26:52 <ttt_fff> yeah, but I want haskell to type check the functions for me before haskell emits the js code
15:27:07 <ttt_fff> so I don't want [ JSValue ], I want (JSInt, JSString, JSInt, JSString)
15:27:32 <ttt_fff> Cale: maybe this is not possible when I try to make it happen, but I feel like I can get a typed-forth DSL in haskell to emit javascript code
15:27:36 <frerich> catgocat: 'length (concat xss)' is shorter than '(length . concat) xss' :-)
15:28:12 <catgocat> xD
15:28:18 <ttt_fff> wait wait wait, since it's the end of the line, you can do length$concat xss
15:28:37 <ttt_fff> "n<1||n>(length$concat xss)"
15:28:45 <ttt_fff> I think I saved like 5 chars there
15:29:14 * Sindriava frowns at `concat`
15:29:15 <mauris> id=<<xss
15:29:16 <catgocat> come on
15:29:21 <catgocat> not code golf
15:29:38 <nullvoid8> sum (length <$> xss) ?
15:30:09 <Sindriava> nullvoid8 + 1
15:30:48 <nullvoid8> there's probably a function "between :: (Ord a) => a -> a -> a -> Bool" somewhere, I've had to write it enough times for my own purposes
15:31:51 <nullvoid8> which would be longer, but imo cleaner looking
15:32:17 <Hijiri> :t inRange
15:32:18 <lambdabot> Ix a => (a, a) -> a -> Bool
15:32:40 <Hijiri> > (inRange (-5, 5) 4, inRange (1,3) 0)
15:32:42 <lambdabot>  (True,False)
15:33:09 * hackagebot fast-math 1.0.2 - Non IEEE-754 compliant compile-time floating-point optimisations  https://hackage.haskell.org/package/fast-math-1.0.2 (MikeIzbicki)
15:33:11 <nullvoid8> Hijiri: sure, but that needs Ix, when "all" we need is Ord
15:33:52 <Hijiri> I haven't been able to find anything more general already defined
15:34:00 <Hijiri> usually I just rewrite it each time
15:34:10 <nullvoid8> same unfortunatly
15:38:02 <Sindriava> :i Ix
15:38:38 <nullvoid8> Sindriava: it's the class of types that are useable as Array indicies
15:39:01 <Sindriava> nullvoid8: Thanks ^^ That's a weird constraint for inRange O.o
15:39:21 <Sindriava> or indeed a weird type at all
15:39:27 <nullvoid8> it's because it's for asking if an index is with a particular block of an array
15:39:37 <Sindriava> nullvoid8: I see!
15:41:22 <nullvoid8> Sindriava: Ix includes things like (Ix a, Ix b) => Ix (a, b), inc which case (iirc) inRange checks the rectangle with opposite corners defined
15:41:52 <Sindriava> Neato
15:42:39 <Sindriava> By the way, #haskell-game seems to be asleep so I'll ask here: What's a good library to use for Matrices? Specifically projection matrices for OpenGL, with easy conversion to [GLfloat]
15:43:02 <nullvoid8> linear ?
15:43:02 <caconym> is there a commonly used type that's intended to decorate something with an Ord? (like one might use internally in a Schwartzian transform, for example)
15:43:14 <caconym> Sindriava: linear for sure
15:43:45 <Sindriava> caconym: Thanks! Does it provide functions like `lookAt` and `projection`, similar to GLM?
15:44:07 <caconym> Sindriava: I have not used them, but I was looking at its documentation this week and IIRC it provides those exact things
15:44:12 <nullvoid8> Sindriava: http://hackage.haskell.org/package/linear-1.19.1.3/docs/Linear-Projection.html
15:44:23 <Sindriava> Thanks a lot ^^
15:44:47 <nullvoid8> Sindriava: I've used it for similar projets in the past
15:45:01 <nullvoid8> not that they ever got anywhere :/
15:45:15 <Sindriava> nullvoid8: Good to know! What were you working on?
15:45:29 <mauris> justOrDie :: String -> Maybe a -> IO a -- am i reinventing the wheel here?
15:45:35 <nullvoid8> Sindriava: toy fps's
15:45:58 <nullvoid8> mostly "how to program openGL in haskell" type projects
15:46:01 <mauris> or is this a silly function to write? i've never done "serious" error handling
15:46:05 <caconym> I'm using linear for a (2D) game project right this second and I heartily recommend it in general
15:46:22 <mauris> i guess i should do this all in the Either monad instead and "catch" a Left only once in IO
15:46:23 <Sindriava> nullvoid8: caconym: Thanks! I'll go check it out right away!
15:46:56 <nullvoid8> mauris: isn't that just "maybe (fail str) return" ?
15:48:03 <mauris> it might be, but i like my more verbose definition of it a lot more
15:48:27 <nullvoid8> sure
15:48:38 <nullvoid8> mauris: what's the context for this anyway?
15:51:05 <mauris> basically i have a bunch of:  x <- (someAction :: IO (Maybe a)); case x of Just y -> (more IO stuff); Nothing -> die "Missing a foobar!"
15:51:42 <mauris> so i wrote the above, and replaced it with  x <- someAction >>= justOrDie "Missing a foobar!"  which is cool
15:52:25 <nullvoid8> there's probably a more principled approch, but that's basically what I'd do, yeah
15:52:28 * nullvoid8 shrugs
15:53:00 <Vomit__> @pf (\b a -> b+1)
15:53:00 <lambdabot> Maybe you meant: pl bf
15:53:05 <Vomit__> @pl (\b a -> b+1)
15:53:05 <lambdabot> const . (1 +)
15:53:10 * hackagebot hgearman 0.1.0.1 - A Gearman client for Haskell.  https://hackage.haskell.org/package/hgearman-0.1.0.1 (jperson)
15:53:44 <nullvoid8> though just to bikeshed, I might write it "x <- justOrDie "Missing foobar" =<< ioaction"
15:54:05 <nullvoid8> since (=<<) reads more like normal function application
16:01:04 <startling> is there an idiomatic way to liftA multiple successive infix operators?
16:01:43 <startling> I have (++) <$> x <*> ((++) <$> y <*> ...) right now, but reading it is a little hard
16:02:00 <startling> I guess I can do `frame a b c = a ++ b ++ c in liftA3 frame x y z"
16:02:33 <geekosaur> startling, this is why some people wish idiom brackets had made it into ghc
16:02:43 <startling> interesting, thanks.
16:02:51 <nullvoid8> if it's all the same operator, something involving fmap and traverse?
16:03:01 <geekosaur> because then it'd be (| x ++ y ++ z |) or similar
16:03:07 <nullvoid8> wait, no, they're seperate variable
16:03:33 <startling> yeah, it's not a fold or anything
16:05:21 <nullvoid8> startling: liftA2 + http://hackage.haskell.org/package/composition ?
16:05:33 <catgocat> How can I make this prettier: http://lpaste.net/137755
16:05:36 <catgocat> ????
16:06:02 <startling> nullvoid8, does .: help here? I'm not seeing it
16:06:58 <nullvoid8> startling: you're right. I'm grasping at straws
16:08:11 * hackagebot hgearman 0.1.0.2 - A Gearman client for Haskell.  https://hackage.haskell.org/package/hgearman-0.1.0.2 (jperson)
16:08:11 <startling> catgocat: does that code work? `num = read num` seems suspicious
16:09:11 <catgocat> ops
16:09:15 <catgocat> yeah it's `n`
16:09:19 <catgocat> but aside from that..
16:09:20 <Eduard_Munteanu> catgocat, looks alright to me
16:09:27 <startling> catgocat, I don't have a good sense of what the rest of your code looks like, but it looks fine to me
16:09:35 <catgocat> ok thanks
16:10:04 <startling> you might want to play with Control.Monad.Reader or Control.Monad.Except if you have similar functions all over
16:10:38 <startling> but there's no real need to
16:12:29 <Eduard_Munteanu> catgocat, if you used monads for exceptions, you could have written things as   when (not (isInt x)) $ throw NotInteger   etc.
16:12:59 <catgocat> don't know those things yet
16:13:02 <catgocat> I am a beginner xd
16:13:15 <Eduard_Munteanu> Ah, it's fine so far.
16:13:20 <Gurkenglas> startling, if you have more than three arguments, you could use sequenceA [x, y, z]
16:13:39 <startling> catgocat: yeah, ignore me for now then
16:13:52 <catgocat> Gurkenglas: I'm still working on the tictactoe game.. I have refactored a lot and made it more general and abstract
16:14:31 <Eduard_Munteanu> (actually 'unless' might fit assertions better)
16:15:15 <Gurkenglas> (Which works because (++) happens to be mappend.)
16:15:58 <slowbait> Hi, can you recommend me a book on domain theory?
16:16:03 * frerich hopes that catgocat makes it abstract and generic enough to serve as a general engine for toetactic as well as the recent variant tactoetic
16:16:18 <catgocat> :(
16:16:29 * Eduard_Munteanu looks for tactics
16:16:44 <catgocat> when I mean abstract I mean handle more than 3x3
16:17:10 <frerich> That would be... ticatactoetoc?
16:17:17 <startling> :t sequenceA
16:17:18 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
16:17:36 <startling> :t foldA
16:17:37 <lambdabot>     Not in scope: ‘foldA’
16:17:37 <lambdabot>     Perhaps you meant one of these:
16:17:37 <lambdabot>       ‘foldl’ (imported from Data.List),
16:17:52 <catgocat> do I need something to be instance of Eq to pattern match it ?
16:18:03 <Eduard_Munteanu> catgocat, with a literal, yes
16:18:14 <Eduard_Munteanu> catgocat, with a constructor, no
16:18:20 <catgocat> example: data Player = Player1 | Player2
16:18:23 <catgocat> func Player1 = ..
16:18:29 <Eduard_Munteanu> Then no.
16:18:32 <catgocat> why
16:18:39 <catgocat> doesnt make much sense
16:19:08 <Gurkenglas> catgocat, I would import https://hackage.haskell.org/package/safe-0.3.9/docs/Safe.html#v:readMay
16:19:17 <Eduard_Munteanu> catgocat, matching constructors is trivial because the type is designed as such
16:19:40 <catgocat> I still dont know how to work with cabal / hackage / packages
16:20:14 <Eduard_Munteanu> catgocat, you can't really write Eq instances without pattern-matching anyway.
16:20:17 <Gurkenglas> Do you have a cabal file?
16:20:27 <catgocat> no
16:20:32 <wyager> Is it expected that Data.Vector.Unboxed has different semantics than Data.Vector? When I import Data.Vector, my DP algorithm works as expected. When I import Data.Vector.Unboxed, it <<loop>>s
16:20:36 <Eduard_Munteanu> cabal init
16:20:55 <Gurkenglas> I think putting import Safe (readMay) at the top of your file should work, if you don't want to fool around with cabal
16:21:31 <catgocat> I am going to make a lpaste for my refactored game
16:21:38 <Eduard_Munteanu> wyager, well, yes... the cells in the unboxed vector are strict because well, they are unboxed.
16:22:08 <Gurkenglas> @hoogle a -> Maybe b -> Either a b
16:22:08 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
16:22:08 <lambdabot> Text.Parsec runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
16:22:08 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
16:22:18 <startling> catgocat, part of defining constructors in Haskell is that you can deconstruct easily.
16:22:27 <wyager> Eduard_Munteanu: Of course, but that doesn't preclude me from referencing earlier parts of the vector when calculating the new part
16:22:31 <startling> catgocat: I wouldn't worry about it, just accept it as part of the language
16:22:41 <catgocat> Here > http://lpaste.net/137756
16:22:51 <catgocat> My game ^^^^^^^^^^^^^^
16:23:25 <wyager> Or at least, it shouldn't
16:23:35 <hpc> catgocat: testing for equality looks at "the entire value"
16:23:35 <nullvoid8> frerich: isn't tictactoetoc a 3x3x3x3 board?
16:23:45 <hpc> catgocat: while pattern matching looks only at what you are matching on
16:23:46 <Eduard_Munteanu> catgocat, I wouldn't abuse Show for Player like that
16:23:50 <nullvoid8> sorry, 3x3x3
16:23:51 <hpc> catgocat: so for instance
16:24:02 <hpc> > [1..] == [1..] -- you can't compare infinite lists for equality
16:24:06 <lambdabot>  mueval-core: Time limit exceeded
16:24:08 <catgocat> Eduard_Munteanu why not
16:24:09 <wyager> Although I do see how it would be difficult to define Unboxed so that it actually allowed that
16:24:17 <wyager> As you don't want to defer generation...
16:24:31 <wyager> Ah, looks like I can use constructN
16:24:32 <wyager> perfect
16:24:46 <Eduard_Munteanu> catgocat, Show is mostly a companion to Read and viceversa, it should serialize terms rather than provide meaningful descriptions
16:24:48 <hpc> > case [1..] of (x:y:xs) -> (x, y, x == y) -- you can pattern match on it just fine though
16:24:49 <lambdabot>  (1,2,False)
16:25:14 <catgocat> aaaaaaaaaaaaaaah
16:25:16 <Eduard_Munteanu> catgocat, usually if you can derive Show, that's what you want for it
16:25:21 <catgocat> two days to write a TicTacToe
16:25:34 <catgocat> and everytime I write something I have to refactor it all over again
16:25:43 <hpc> catgocat: that example uses laziness to demonstrate a failure of (==), but there's other ways it can fail too
16:25:43 <rhz> when I do "cabal fetch" where does the package go on my disk?
16:25:56 <hpc> catgocat: like values which you can't compare for equality at all
16:26:04 <catgocat> why can't I just do show and leave it like that >:(
16:26:05 <hpc> catgocat: a list of functions, or a list of file handles
16:26:30 <catgocat> hpc got it
16:26:31 <geekosaur> rhz, depends on OS. maybe you want cabal get / cabal unpack (for older cabal-install)?
16:26:46 <ronh> > [1..] == [2..]
16:26:48 <lambdabot>  False
16:26:53 <hpc> ronh: shush
16:26:54 <hpc> ;)
16:26:59 <ronh> :P
16:27:18 <Eduard_Munteanu> catgocat, you can, but pretty-printing isn't the intended purpose of Show
16:27:28 <catgocat> ok
16:27:34 <catgocat> do you have any more suggestions
16:27:51 <geekosaur> rhz, on linux it's ~/.cabal/packages/$repo/$package/$version/ and on os x / haskell platform it's similar but ~/Library/Haskell instead of ~/.cabal
16:27:57 <Gurkenglas> catgocat, http://lpaste.net/137755
16:28:10 <Eduard_Munteanu> catgocat, not so far, looks decent
16:28:34 <catgocat> Gurkenglas: that's super ugly and importing on stuff to do that seems completely unnecessary 
16:28:34 <geekosaur> windows is something like AppData\Roaming\cabal\packages\$repo/$package/$version
16:28:44 <geekosaur> (substituting repo, package, and version appropriately)
16:28:58 <geekosaur> (substituting $repo, $package, and $version appropriately)
16:28:59 <catgocat> Eduard_Muntenau I've been writing it the whole day trying to improve it
16:29:20 <rhz> geekosaur, what i want to do is to hack the source code of a package slightly to make it build, since it is an old version and does not build any more
16:29:30 <geekosaur> then you want cabal get
16:29:41 <geekosaur> which will leave a directory in the current directory with the package source in it
16:30:01 <catgocat> Eduard_Munteanu check the main function, do you think hSetBuffering stdout NoBuffering is alright?
16:30:08 <catgocat> it's really a pain in the ass to do hFlush everytime I do putStr
16:31:17 <Eduard_Munteanu> catgocat, ideally you should flush when needed, e.g. after drawing the board or such. But that works as well.
16:31:33 <Eduard_Munteanu> (not for every putStr)
16:32:34 <catgocat> Eduard_Munteanu anything else?
16:32:37 <frerich> catgocat: I think you could simplify 'whoWon' a bit by checking whether some player won any row or the diagonal from the top-left corner to the bottom right. And then repeating the process but tranposing the board.
16:32:45 <Eduard_Munteanu> catgocat, not really, no.
16:32:57 <geekosaur> catgocat, unbuffered output is less than ideal but generally acceptable --- note that even on a fast system, on a slowish terminal emulator you may well see every character output individually if you write stuff that way. (less noticable with short putStr-s, but still may notice some "jerkiness")
16:33:05 <catgocat> frerich can you make an annotation?
16:33:27 <geekosaur> you may want some kind of prompt function which displays a prompt, flushes and reads input
16:33:48 * geekosaur has not looked at the source in question...
16:33:49 <catgocat> geekosaur: but if I do hFlush right away, won't that happen too ?
16:34:33 <Eduard_Munteanu> catgocat, the point is to make use of buffering and keep flushing to a minimum
16:34:52 <Eduard_Munteanu> Because writing out to terminals may be slow or laggy.
16:35:38 <geekosaur> catgocat, my point is that (having now looked) you can put the hFlush in getNumber
16:35:39 <Eduard_Munteanu> Even for file I/O it's better to accumulate large writes rather than 1-byte writes.
16:39:40 * Maxdamantus has been wondering recently what it'd be like for performance if the system were mostly based on executing safe code (eg, some sort of VM bytecode).
16:40:28 <Maxdamantus> presumably things like writing single bytes wouldn't have that overhead, since the system call would be cheaper, and the kernel would maintain a buffer.
16:40:34 <Gurkenglas> catgocat, where do you get isInt? Using inRange and readMay would, say, easily allow you to switch the board representation to an array from (Int, Int), and rename this function validateCoords.
16:40:59 <Maxdamantus> then you wouldn't need to use workarounds like `stdbuf` to revert that behavious.
16:41:31 <Gurkenglas> catgocat, also here's another coz why not http://lpaste.net/137758
16:42:26 <frerich> catgocat: I made an annotation now with the (untested) idea
16:42:50 <catgocat> Gurkenglas: I think that's unnecessary, but maybe it's just me. Seriously, look at that code and look at the previous code. What looks cleaner?
16:42:53 <Maxdamantus> I don't think the "to terminals" point is meaningful. It's just making the system calls that's inefficient. The kernel can and does maintain its own buffers for that sort of thing.
16:43:06 <catgocat> frerich share?
16:43:13 <frerich> catgocat: Hm?
16:43:21 <catgocat> share annotation
16:43:25 <frerich> catgocat: It is shared, no?
16:43:28 <geekosaur> from a UX standpoint, it's actually painful when you can see the individual writes :)
16:43:34 <catgocat> link
16:43:53 <frerich> catgocat: It's your link
16:43:55 <Maxdamantus> some terminals (gr.. fbcon) are actually really slow, but that's not because of the number of writes to it.
16:44:10 <geekosaur> but it's hard to demonstrate the effect of buffering vs. system calls, whereas it's (even now) not that hard to set up an example of what unbuffered I/O looks like on a slow terminal :)
16:44:17 <Gurkenglas> I'm not seeing frerichs annotation either.
16:44:58 <catgocat> what is <|>
16:45:00 <geekosaur> at least, hard to demonstrate without doing something involving writing a lot of data to a disk file 1 character at a time, buffered vs. unbuffered, and timing it
16:45:08 <Maxdamantus> the kernel will buffer the writes to the terminal.
16:45:08 <Gurkenglas> :t (<|>)
16:45:09 <lambdabot> Alternative f => f a -> f a -> f a
16:45:12 <frerich> catgocat: You asked the same question yesterady and eventually used 'asum'. Remember?
16:45:30 <catgocat> I remembered asking the <|> but forgot
16:45:47 <Maxdamantus> if the program is doing 20 writes per second and the terminal is only doing one read per second, it's not necessarily going to lag behind.
16:45:54 <Maxdamantus> (numbers exaggerated)
16:46:00 <frerich> catgocat: It does the same the 'asum' function you're using, but for two elements instead of a list of elements.
16:47:01 <frerich> Gurkenglas: If you annotate things on lpaste, the annotation shows up on the same URL as what you annotated.
16:47:11 <frerich> Gurkenglas: Below the original paste.
16:47:21 <Maxdamantus> the slowdown is from how long it takes the program to make all those writes .. a single write call is a lot slower than writing to your own buffer in your own address space.
16:48:08 <catgocat> should I make a class called Print that offers a function toStr, instead of making instances of Show to prettify ?
16:48:33 <Gurkenglas> frerich, I know, and I didn't see it there. Maybe you're thinking another paste original. Link?
16:49:05 <frerich> Gurkenglas: I'd have to scorll up - I closed the tab. It's one which catgocat pasted :}
16:49:29 <frerich> catgocat: I think you should just have a 'renderBoard :: Board -> String' and be done with it.
16:49:33 <Gurkenglas> Ah, the one where he pasted the whole game, not just the validate stuff
16:49:42 <catgocat> frerich but I need to render the tiles, the board, the player
16:49:46 <Maxdamantus> if everything ran in a safe VM, you wouldn't have as much overhead making system calls; they could just be plain functions.
16:49:50 <catgocat> how can I make this more abstrac
16:49:50 <frerich> catgocat: Right, renderBoard does that.
16:50:06 <catgocat> it doesn't.. I want to prettify Player1 to 1st Player
16:50:14 <frerich> catgocat: Which part of 'rendering the board' do you want to make more abstract? :-)
16:50:15 <catgocat> and Player2 to 2nd Player
16:50:24 <catgocat> ===============================================================================================================================
16:50:26 <catgocat> ===============================================================================================================================
16:50:57 <catgocat> I imagine myself, having multiple data types and wanting to prettify those. I would need to have a showSomething for all of those, or a type class.
16:51:09 <Maxdamantus> "everything" until you actually need the processing power, at which point you might ask the kernel to make some container that's able to execute arbitrary code, in the way a process nowadays can.
16:53:05 <frerich> catgocat: I think good rule of thumb is that in the vast majority of cases where you think you want a type class, you actually do not want a type class. ;-)
16:53:25 <frerich> catgocat: For instance, instead of having a 'Show' instance for 'Player', I would start with just 'playerName :: Player -> String'.
16:53:45 <frerich> catgocat: And then you may also want to have 'playerSymbol :: Player -> Char' for printing the board.
16:54:12 <frerich> catgocat: From there, it's a very short step to 'data Player = Player { playerName :: String, playerSymbol :: Char }'
16:54:33 <catgocat> cool
16:54:57 <Zemyla> frerich: You probably want a Show instance, though, at least fpr debugging purposes.
16:56:11 <frerich> Zemyla: That may well be - the derived Show instance for that Player declaration will be okay for debugging.
16:56:56 <Zemyla> And honestly, if people thought like you did, then Show would be just about useless since it'd be rare that it could be derived.
16:57:44 <frerich> Zemyla: I wouldn't say it's utterly useless, but I suspect there are many cases where people use Show instances for things when there are better alternatives.
16:58:26 <frerich> s/Show instances/type classes/ and it's still not too far fetched, I think. :-)
17:05:40 <catgocat> what is infixr? 
17:05:45 <catgocat> and what can I do with it
17:06:18 <dramforever> catgocat: tell the compiler that an operator is right associative, and also give it a precedence
17:06:29 <dramforever> do you understand that?
17:06:58 <frerich> catgocat: https://www.haskell.org/tutorial/functions.html#sect3.2.2 has a short explanation.
17:08:11 <mizu_no_oto> Can you refer to unboxed integer literals?
17:08:25 <dramforever> @let a = 1#
17:08:26 <lambdabot>  .L.hs:144:1:
17:08:26 <lambdabot>      Top-level bindings for unlifted types aren't allowed: L.a = 1#
17:08:39 <dramforever> > let a = 1# in I# a
17:08:40 <lambdabot>      Not in scope: data constructor ‘I#’
17:08:40 <lambdabot>      Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trus...
17:08:47 <dramforever> screw it...
17:09:01 <mizu_no_oto> > 1#
17:09:03 <lambdabot>      Couldn't match kind ‘*’ with ‘#’
17:09:03 <lambdabot>      When matching types
17:09:03 <lambdabot>        a0 :: *
17:09:08 <dramforever> > let a = 1# in case a of 2# -> "no"; 1# -> "yes"
17:09:10 <lambdabot>  "yes"
17:09:19 <dramforever> mizu_no_oto: ^ this is the answer
17:11:24 <catgocat> If I have something like this                   func x =      stuff x (myFunc) other x
17:11:27 <catgocat> how can I generalize this?
17:11:33 <catgocat> is there such function to do so?
17:11:59 <dramforever> catgocat: what's that myFunc?
17:12:08 <dramforever> did you mean myFunc (stuff x) (other x)?
17:12:11 <catgocat> is an infix function like (!!)
17:12:14 <dramforever> okay
17:12:21 <catgocat> yes that
17:12:29 <dramforever> :t liftA2
17:12:30 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:12:52 <dramforever> liftA2 replicate (5 +) (2 +) 3
17:12:57 <dramforever> > liftA2 replicate (5 +) (2 +) 3
17:12:59 <lambdabot>  [5,5,5,5,5,5,5,5]
17:13:09 <Zemyla> @pl func x = myFunc (stuff x) (other x)
17:13:09 <lambdabot> func = liftM2 myFunc stuff other
17:13:10 <dramforever> > replicate 8 5
17:13:11 <lambdabot>  [5,5,5,5,5,5,5,5]
17:19:33 <ttt_fff> I'm surprised there's no builtin function for (m a, m b) -> m (a, b)
17:20:07 <dramforever> :t uncurry (liftA2 (,))
17:20:08 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
17:20:19 <hpc> the ordering of effects is ambiguous
17:20:33 <Sindriava> nullvoid8: caconym: Holy crap! I actually got perspective working, thanks guys! ^^
17:20:43 <Sindriava> You shall be remembered in my autobiography
17:20:47 <nullvoid8> Sindriava: np :)
17:21:03 <Sindriava> nullvoid8: The fact that `linear` instances it's types as Storable is great
17:21:34 <nullvoid8> Sindriava: I'd be careful with those instances, they may not do what you want (though they probably do)
17:21:42 <Erebe> :t uncurry
17:21:43 <lambdabot> (a -> b -> c) -> (a, b) -> c
17:22:00 <ttt_fff> dramforever , hpc, lambdabot: that's pretty amazing
17:22:11 <Erebe> :t curry
17:22:12 <lambdabot> ((a, b) -> c) -> a -> b -> c
17:22:14 <Sindriava> nullvoid8: Yeah, I've looked online and in 24 days of Hackage, ocharles__ provides example OpenGL usage on his blog :)
17:22:36 <Iceland_jack> ttt_fff: Normally you'd have 'm a -> m b -> m (a, b)' and then it's simply 'liftA2 (,)'
17:24:04 <shapr> @quote Cale
17:24:04 <lambdabot> Cale says: One can create powerful abstractions in C++ in much the same way that a woman can produce a child. It's possible, and people do it, but it takes hours of labour and is extremely painful.
17:24:09 <shapr> ha
17:24:10 <shapr> too funny
17:24:29 <Sindriava> :D
17:24:54 <Sindriava> Also, she has to get majorly fucked in the process.
17:25:10 <catgocat> dramforever so?
17:25:11 <Sindriava> Source: My university thinks that "Programming 101" in C++ is a good idea
17:25:31 <dramforever> catgocat: ?
17:25:39 <nullvoid8> offtopic; you know that thing where you find a fiver down your couch? I just found I have 600GB unallocated space on my hd
17:26:06 <Sindriava> nullvoid8: Unallocated as in 'without a partition' ?
17:26:29 <Gurkenglas> hpc, what ordering? Aren't Monads for stuff happening in order?
17:26:31 <nullvoid8> Sindriava: Either that, or it's a linux partition that windows can't read and I forgot about
17:26:52 <nullvoid8> *Window's Disk Manager
17:26:57 <dramforever> what happened?
17:27:00 <dramforever> did I miss something?
17:27:19 <Sindriava> nullvoid8: out of curiosity, what's your reason for using Windows? Is it some particular functionality, or do you just like it?
17:27:47 <dramforever> nullvoid8: unallocated or unformatted?
17:27:57 <hpc> Gurkenglas: (putStrLn "one", putStrLn "two")
17:28:05 <frerich> Do you really need to discuss harddisk partitioning issues in a room with 1460+ people who share a common interest in Haskell? :-}
17:28:18 <hpc> does it become putStrLn "one" >> putStrLn "two" >> return ((), ())?
17:28:19 <nullvoid8> Sindriava: primarily Video Games. the other 90% of my time I'm on the internet and it doesn' what OS I'm on. For programming I do prefer *nix. My laptop is currently running NixOS
17:28:24 <hpc> or does it become
17:28:35 <hpc> putStrLn "two" >> putStrLn "one" >> return ((), ())?
17:28:49 <nullvoid8> french: sorry, I did start this with offtopic, just wanted to share a cool find
17:28:53 <Gurkenglas> hpc, IO is a monad. Can you find an Applicative with the same problem?
17:29:11 <hpc> IO is also an Applicative
17:29:13 <dramforever> Gurkenglas: no
17:29:26 <Gurkenglas> hpc, you know what I mean
17:29:27 <dramforever> because all monads are applicatives
17:30:02 <dramforever> Gurkenglas: it's possible to wrap an applicative like this
17:30:10 <hpc> :t \x y -> liftA2 (flip (,)) y x
17:30:11 <lambdabot> Applicative f => f a -> f b -> f (a, b)
17:30:11 <Sindriava> nullvoid8: Fair enough! Thanks for the info, I'm doing some research on why people use them, so this is pretty valuable ^^ </offtopic>
17:30:19 <dramforever> @let newtype Rev f a = Rev (f a)
17:30:20 <hpc> :t \x y -> liftA2 (,) x y
17:30:20 <lambdabot>  Defined.
17:30:21 <lambdabot> Applicative f => f a -> f b -> f (a, b)
17:30:30 <hpc> Gurkenglas: two definitions, reversed side effects
17:30:33 <hpc> Gurkenglas: same type
17:30:46 <dramforever> @let deriving instance Functor f => Functor (Rev f)
17:30:47 <lambdabot>  Defined.
17:31:38 <dramforever> @let instance Applicative f => Applicative (Rev f) where pure = Rev . pure; Rev f <*> Rev a = (flip ($)) <$> a <$> f
17:31:39 <lambdabot>  .L.hs:151:48:
17:31:40 <lambdabot>      Couldn't match type ‘f’ with ‘Rev f’
17:31:40 <lambdabot>        ‘f’ is a rigid type variable bound by
17:31:50 <dramforever> @let instance Applicative f => Applicative (Rev f) where pure = Rev . pure; Rev f <*> Rev a = Rev $ (flip ($)) <$> a <$> f
17:31:51 <lambdabot>  .L.hs:151:33:
17:31:51 <lambdabot>      Couldn't match type ‘f’ with ‘(->) (a -> b)’
17:31:51 <lambdabot>        ‘f’ is a rigid type variable bound by
17:31:56 <dramforever> arrrgh
17:32:04 <dramforever> @let instance Applicative f => Applicative (Rev f) where pure = Rev . pure; Rev f <*> Rev a = Rev $ (flip ($)) <$> a <*> f
17:32:05 <lambdabot>  Defined.
17:32:21 <dramforever> hpc: same function, reversed side effects
17:32:44 <dramforever> wait I wonder if that actually satisfies the laws
17:34:06 <Gurkenglas> hpc, and I said that that would only be a problem with monads, which care about ordering, not "proper" applicatives, which don't.
17:34:15 <Gurkenglas> > flip (liftA2 (flip (,))) (ZipList [1,2]) (ZipList [5,6])
17:34:16 <lambdabot>  ZipList {getZipList = [(1,5),(2,6)]}
17:34:23 <Gurkenglas> > liftA2 (,) (ZipList [1,2]) (ZipList [5,6])
17:34:24 <lambdabot>  ZipList {getZipList = [(1,5),(2,6)]}
17:34:32 <hpc> you're wrong
17:34:40 <dramforever> ZipList is commutative right?
17:34:42 <hpc> there's no law that says all applicatives commute side-effects
17:34:57 <Gurkenglas> Right, because all monads are applicatives.
17:35:14 <hpc> and "proper" applicatives are any that obey the laws
17:35:20 <hpc> which all Monads do
17:35:37 <Gurkenglas> But when I think of applicatives, I usually think of those that aren't monads, and then usually those that stand for "parallel" instead of "sequential"
17:35:48 <dramforever> hpc: not really, but Gurkenglas is still wrong
17:36:08 <dramforever> I think by "proper" applicatives Gurkenglas meant applicatives that are not monad
17:36:10 <dramforever> *monads
17:36:24 <hpc> i know
17:36:41 <dramforever> but he/she is wrong anyway
17:36:41 <hpc> i am more trying to tear down the misconception than be as perfectly precise as possible
17:37:13 <Gurkenglas> Funny, that's what I thought when I went "find me an applicative instead of all these monads" :P
17:37:38 <hpc> you need to be more precise
17:37:47 <hpc> first, there's nothing special about applicatives that are also monads
17:38:14 <hpc> second, you should mention what you really mean is commutative applicatives
17:38:38 <hpc> instead of saying "real applicatives", which is meaningless
17:38:48 <Gurkenglas> There are noncommutative, nonmonad applicatives?
17:39:15 <hpc> Gurkenglas: assume they exist unless you can prove they don't
17:39:17 <monochrom> you know, when we say "rectangle", people will argue whether squares are included or not
17:39:44 <dramforever> monochrom: "proper" applicatives...
17:39:54 <Gurkenglas> As in proper subset.
17:39:56 <hpc> Gurkenglas: the laws admit noncommutative nonmonad applicatives, so any abstract reasoning about Applicative necessarily must account for their presence
17:40:17 <hpc> unless you introduce further evidence that can rule them out
17:40:52 <dramforever> abstract reasoning is *hard*
17:41:36 <dramforever> yesterday I tried to come up with MonadReader laws
17:41:43 <Gurkenglas> Fine, liftA2 (,), if given its own name as a library function, should be restricted to commutative applicatives
17:42:18 <Cale> hm?
17:42:18 <dramforever> Gurkenglas: IMHO you don't have to do that
17:42:27 <Cale> Why?
17:42:34 <dramforever> otherwise why is this different?
17:42:34 <nullvoid8> it's only ambiguous if all you have is the type
17:42:37 <dramforever> :t (<*>)
17:42:38 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:42:45 <dramforever> :t (<**>)
17:42:46 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
17:43:33 <Gurkenglas> Cale, see :19:30 - :19:43
17:44:23 <lpaste_> dramforever pasted “I ended up with these...and it seems that there's still more” at http://lpaste.net/137766
17:44:54 <Cale> liftA2 (,) is actually what gets used as part of the definition of a monoidal functor, which is how Applicative is usually discussed in other mathematical contexts
17:49:14 <dramforever> Are there any existing articles/blog posts/... about monadic reasoning?
17:51:01 <Cale> Gurkenglas: I still don't see how you come to that conclusion...
17:52:43 <conal> dramforever: https://www.cs.ox.ac.uk/publications/publication4877-abstract.html
17:52:56 <dramforever> conal: thank you I'll check
17:53:55 <dramforever> interesting...
17:54:32 <dramforever> at first I thought about Writer, then I saw MonadWriter and got scared away because of the functions I won't know how to describe in that class
17:54:55 <bsmt> has anyone played with running haskell on a microcontroller? or am i chasing dragons?
17:55:16 <dramforever> then I thought about Reader,and came up with lots of laws
17:55:30 <dramforever> then I thought, maybe MonadPlus is easier
17:57:19 <dramforever> bsmt: you need gc to run haskell code
17:58:09 <bsmt> ah
17:58:10 <conal> bsmt: alternatively, write in haskell but do a non-standard compilation for the microcontroller, not depending on the usual run-time system. you could either use a deep, compiled embedded DSL or really get into the compiler. I've done both approaches, compiling to C, Java, and GPU code, and compiling directly into hardware circuits. In those cases, I didn't need garbage collection.
17:58:35 <dramforever> wow
17:58:39 <conal> bsmt: if you're interested, i'll dig up references.
17:58:46 <bsmt> i've played with clash a little bit for HDL stuff
17:58:52 <dramforever> conal: are you Mr. References? =P
17:59:21 <bsmt> but i was just wondering if it would be more practical to use an existing haskell compiler or make some weird subset language
17:59:27 <bsmt> if you've got links handy, that'd be nice, thanks
18:00:01 <conal> bsmt: http://conal.net/Pan/, http://conal.net/Vertigo/, https://github.com/conal/talk-2015-haskell-to-hardware
18:00:04 <JagaJaga> I had connection problems and will ask again if that wasn't sent. What for are "free monads"? :)
18:00:27 <bsmt> oh i think i've skimmed the slides for your talk!
18:00:35 <bsmt> didn't realize it was you, haha
18:00:38 <conal> :)
18:01:42 <nullvoid8> Jagajaga: a functor + the minimal amount extra to satisfy the monad laws
18:02:07 <bsmt> thanks a ton conal
18:02:16 <conal> bsmt: you're welcome. enjoy!
18:02:54 <dramforever> JagaJaga: any monad that's a bit hard to implement "directly"
18:03:02 <dramforever> something like DSL
18:03:10 <JagaJaga> nullvoid8: and where can we typically use it?
18:03:16 * hackagebot deterministic-game-engine 0.4.0 - Simple deterministic game engine  https://hackage.haskell.org/package/deterministic-game-engine-0.4.0 (tgolson)
18:03:17 <dramforever> DSL
18:03:26 <nullvoid8> ^
18:03:35 <JagaJaga> dramforever: yeah, got it. But some examples?
18:04:05 <dramforever> I can't stand it...why do so many classes have lots of functions I never use...
18:04:25 <dramforever> JagaJaga: the first thing that came to my mind is pipes
18:04:42 <dramforever> http://hackage.haskell.org/package/pipes-4.1.5/docs/Pipes-Internal.html
18:05:07 <dramforever> look at the Proxy type, it's really like a free monad
18:05:10 <JagaJaga> dramforever: thank you.
18:05:14 <dramforever> =)
18:05:50 <JagaJaga> dramforever: is it good to learn category theory if you want to know haskell deeper?
18:05:59 <dramforever> dunno
18:06:04 <JagaJaga> dramforever: or type theory?
18:06:05 <dramforever> but I've learnt a bit
18:06:08 <bsmt> http://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/
18:06:11 <bsmt> check that out
18:06:13 <JagaJaga> or that's for agda..
18:06:29 <dramforever> yes I've been reading that category theory for programmers thing
18:06:33 <JagaJaga> bsmt: thank you.
18:22:07 <nolraiU> What do I have to import to use type level nats with fancy notation?
18:24:10 <nitrix> So, how many zygohistomorphic prepromorphisms does it takes to change a light bulb...
18:24:29 <nolraiU> Do we need a Light bulb bracket?
18:24:32 <nolraiU> :P
18:25:59 <dramforever> nitrix: that looks like a functor from the category of bad bulbs to the category of good bulbs =)
18:26:33 <voltz> Is there a general fp irc?
18:26:50 <dramforever> voltz: ##fp
18:26:57 <dramforever> but nobody there really
18:27:19 <voltz> Err OK, thanks
18:37:03 <vishesh>  /join #fp
18:43:17 * hackagebot libvorbis 0.1.0.1 - Haskell binding for libvorbis, for decoding Ogg Vorbis audio files  https://hackage.haskell.org/package/libvorbis-0.1.0.1 (StephenBlackheath)
18:46:22 <Vomit__> @pl  (\score letters -> [(lc l,score) | l <- letters])
18:46:22 <lambdabot> flip flip [] . ((:) .) . (<-) . (| l) . (,) (lc l)
18:46:36 <dramforever> huh?
18:46:38 <dramforever> lol
18:48:14 <geekosaur> yeh, @pl doesn't understand either list comprehension or do
18:48:17 <geekosaur> hm
18:48:25 <geekosaur> @undo  (\score letters -> [(lc l,score) | l <- letters])
18:48:26 <lambdabot> (\ score letters -> concatMap (\ l -> [(lc l, score)]) letters)
18:48:36 <geekosaur> @. pl undo  (\score letters -> [(lc l,score) | l <- letters])
18:48:36 <lambdabot> (=<<) . flip flip [] . ((:) .) . flip ((,) . lc)
18:52:16 <nolraiU> Where is "Proxy" defined?
18:52:37 <nolraiU> I am importing GHC.TypeLits, so I would think it would be in there..
18:52:45 <dramforever> Data.Proxy
18:53:09 <nolraiU> Thanks!
18:53:14 <nolraiU> Should have tried that.
18:53:27 <dramforever> @index Proxy
18:53:27 <lambdabot> Data.Proxy, Data.Typeable.Internal, Data.Typeable, Data.Dynamic, Data.Data
18:53:30 <dramforever> @hoogle Proxy
18:53:30 <lambdabot> Network.HTTP.Proxy module Network.HTTP.Proxy
18:53:30 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.ColorTable Proxy :: Proxy
18:53:30 <lambdabot> Network.HTTP.Proxy Proxy :: String -> (Maybe Authority) -> Proxy
18:58:22 <Sindriava> Is there a way to >>= into two sequenced functions?
18:59:19 <Sindriava> something like: m a >>= (a -> m b) -> (a -> m c) -> m c
19:00:03 <dramforever> where did the b go?
19:00:30 <Javran> not sure what does it mean, seems you are mixing expressions with types
19:02:15 <Javran> :t join :: (a -> a -> b) -> a -> b
19:02:16 <lambdabot> (a -> a -> b) -> a -> b
19:02:31 <Sindriava> dramforever: m b *> m c
19:02:53 <Sindriava> dramforever: Or the result can be even m (b, c) or whatever
19:03:14 <dramforever> :t liftA2 (*>)
19:03:15 <lambdabot> (Applicative f, Applicative f1) => f (f1 a) -> f (f1 b) -> f (f1 b)
19:03:37 <dramforever> ...
19:03:45 <Sindriava> I'm thinking more arrow composition?
19:03:53 <nshepperd> Sindriava: m >>= (\a -> f a *> g a)?
19:04:05 <Sindriava> nshepperd: That's what I'm trying to avoid :D
19:04:53 <Sindriava> I basically want to compose two functions, such as:
19:05:08 <Javran> @pl \a -> f a *> g a
19:05:08 <lambdabot> liftM2 (*>) f g
19:05:24 <Sindriava> (a -> m b) -> (a -> m c) -> (a -> m (b, c))
19:05:28 <nshepperd> the other ways are yuckier
19:05:30 <Sindriava> Javran: dramforever : Oh, I see
19:05:38 <dramforever> =)
19:05:48 <Sindriava> nshepperd: Definitely
19:05:52 <nshepperd> unKliesli (Kliesli f &&& Kliesli g) -- gross
19:05:58 <dramforever> Sindriava: why don't you just write do notation or something...
19:06:15 <Sindriava> I believe "for shits and giggles" would be an appropriate expression here
19:06:26 <Javran> I'll also go with do notation though
19:06:41 <Sindriava> Yeah, it's what I'm using now, I was just curious
19:06:54 <Sindriava> the more I fuck around with this stuff, the better intuition I get for how it works
19:07:53 <Sindriava> dramforever: from the `f (f1 a)`, I didn't realize that `(->)a` is also a functor, now I get it! That's clever.
19:08:02 <dramforever> =)
19:08:07 <Sindriava> See? Learning! yay!
19:08:32 <Sindriava> Okay, enough free time for Sindriava, back to slaving OpenGL
19:09:00 <Javran> Reader monad yes
19:11:26 <Sindriava> Although…
19:11:31 <Sindriava> context <- glCreateContext window
19:11:32 <Sindriava> f context <* glDeleteContext context
19:11:45 <Sindriava> vs.
19:11:45 <Sindriava>     glCreateContext window >>= liftA2 (<*) f glDeleteContext
19:12:56 * Javran don't think the latter is straightforward to read though
19:14:01 <Sindriava> I mean right now, when I know what it does, it seems elegant and readable, but I'm afraid that I'm not going to feel that way tomorrow
19:17:53 <comprehension> hello all
19:18:08 <ReinH> The liftA2 version is the one that will make future you mad, I guarantee it.
19:18:10 <comprehension> if two rules match, how does happy pick one?
19:18:22 <comprehension> i would expect it to pick the first one, but it doesn't seem to
19:18:35 <dmead> hey channel
19:18:43 <dmead> tree comparisons are O(1) right?
19:19:00 <dmead> because they're implemented as hash trees right?
19:19:05 <dmead> i mean
19:19:15 <dmead> comparison for any ADT
19:19:30 <dramforever> dmead: I don't even get what you mean
19:19:40 <dramforever> what's comparison? (==)?
19:19:48 <dramforever> that depends on the implementation
19:19:55 <dmead> i'm asking about implementation
19:20:06 <dmead> so if i define a tree as per usual in haskell
19:20:12 <dramforever> and?
19:20:13 <dmead> and then want to compare two of them
19:20:18 <dramforever> yes?
19:20:22 <ReinH> dmead: what is the per usual definition of a tree?
19:20:28 <ReinH> Let's be specific
19:20:29 <dramforever> IIUC they will be traversed
19:20:43 <dmead> data Tree = Node a [Tree]
19:20:45 <dramforever> iirc you could actually see the code derived by ghc
19:20:49 <ReinH> Ok. Then it can't be hashed.
19:20:55 <dmead> can't, really?
19:20:58 <ReinH> (I assume you mean Tree a)
19:21:00 <ReinH> Yes, really.
19:21:06 <dmead> i mean
19:21:06 <dramforever> dmead: why hash trees?
19:21:09 <dmead> oh
19:21:09 <dramforever> what do you mean by that?
19:21:13 <dmead> data Tree = Node String [Tree]
19:21:24 <dramforever> dmead: oh do you mean pointer equality?
19:21:31 <dmead> no, i mean value equality
19:21:36 <dmead> if it's
19:21:38 <dmead> data Tree = Node String [Tree]
19:21:42 <ReinH> Well, I assume "hashed" involves a hashing function
19:21:50 <ReinH> which you can't write for a polymorphic a
19:21:53 <dmead> right
19:21:56 <dmead> but if i narrow it to string
19:21:57 <Gurkenglas> How would you use hashing to accelerate an equavlity check?
19:21:57 <dramforever> let's check for sure
19:22:12 <Gurkenglas> The standard way I can think of would only accelerate inequality checks
19:22:27 <dmead> Gurkenglas, i'm really asking if merkel trees are used internally by the runtime system to compare some data structures
19:22:47 <nshepperd> the rts doesn't try to be clever like that
19:23:03 <dramforever> dmead: why they should be?
19:23:28 <dmead> dramforever, why not?
19:23:45 <ReinH> dmead: Yes, but hashing it would... require a traversal.
19:23:50 <Gurkenglas> dmead, equal hashes don't imply equal values, it's the other way round, so you can't use equal hashes to prove equality
19:23:52 <ReinH> And you don't store the hash with the tree.
19:23:54 <dramforever> why should the haskell compiler be clever like that?
19:23:56 <ReinH> So you still require a traversal
19:24:29 <dramforever> so hmm...does any other programming language do it?
19:24:34 <Gurkenglas> ReinH, he probably means that the runtime system would only do it once if the same tree is used in multiple comparisons.
19:24:38 <dramforever> *implementation
19:24:51 <ReinH> (Merkle* tree)
19:25:17 <nshepperd> dmead: for a start, this doesn't work if something in the structure has a custom implementation of (==)
19:25:29 <lpaste_> dramforever pasted “See for yourself” at http://lpaste.net/137769
19:25:30 <dmead> ReinH, yes. but once it's stored internally by the tree you get theta(1) comparisons for any size tree
19:25:34 <nshepperd> an equivalence class
19:25:37 <dramforever> dmead: ^ see for yourself
19:25:40 <ReinH> Merkle trees aren't guaranteed to be an optimization
19:25:46 <dmead> ah
19:25:55 <dramforever> dmead: why should ghc be clever like that?
19:25:58 <ReinH> if, for isntance, the cost of the hashing function is sufficiently large
19:26:39 <dramforever> dmead: you could add hashing for yourself, but there's no reason ghc should do that
19:26:53 <dmead> dramforever, sure. i was asking if it did
19:26:58 <dramforever> dmead: no
19:27:03 <dramforever> did you "see for yourself"?
19:27:10 <dmead> yes. just now
19:27:40 <dramforever> dmead: what about this: do you know any other programming language implementation that does this?
19:27:44 <nshepperd> (the rts doesn't automatically memoize your functions either, while we're at it)
19:27:53 <ReinH> If you're going to use hashing, why wouldn't you use a hashmap?
19:28:14 <nshepperd> (making time vs space vs semantics tradeoffs is not to be done lightly)
19:28:25 <dramforever> lots of tradeoffs
19:28:31 <dmead> dramforever, nope. 
19:28:47 <dramforever> why should ghc be *that* clever? =P
19:28:51 <ReinH> nshepperd: It's a similar problem: it isn't a strict optimization, it's a tradeoff.
19:29:02 <ReinH> Sometimes you *don't* want to trade time for space.
19:29:12 <dramforever> actually in ghc threads are really lightweight
19:29:23 <dmead> dramforever, it's already clever enough to automatically derive typeclass instances. i kind of assumed that those instances would be fast
19:29:26 <dramforever> you get to manage them by yourself
19:29:43 <dramforever> dmead: IIUC the derive system is naive
19:30:06 <ReinH> The derive system doesn't introduce new data structures.
19:30:17 <dramforever> related: newbies often write slow code and think "lazy evaluation will speed it up"
19:30:19 <dmead> dramforever, i know. c ale used to play starcraft with me. 
19:30:21 <dmead> *cale
19:30:23 <dramforever> :t subsequences
19:30:27 <lambdabot> [a] -> [[a]]
19:30:46 <dramforever> > filter ((== 3) . length) (subsequences [1,2,3,4,5,6])
19:30:48 <lambdabot>  [[1,2,3],[1,2,4],[1,3,4],[2,3,4],[1,2,5],[1,3,5],[2,3,5],[1,4,5],[2,4,5],[3,...
19:30:59 <dmead> i'm not a newbie. i was asked about merkel trees recently and started wondering how you could do it in haskell
19:31:01 <dramforever> ^ example
19:31:15 <dmead> sure
19:31:15 <ReinH> Step 1: Be edwardk
19:31:17 <dramforever> dmead: just store the hash values in the data structure
19:31:21 <ReinH> Step 2: implement Merkle trees.
19:31:32 <Sindriava> ReinH + 1
19:31:35 <dmead> ReinH, i feel ike that was the presentation of his i saw at hac phi
19:31:37 <dramforever> no step 1 isn't strictly required...
19:31:39 <c_wraith> haskell does nothing to merkle trees easier or harder than doing exactly what the definition of them says to do
19:31:43 <dmead> a good long while ago
19:31:54 <dramforever> dmead: why don't you just implement merkle trees?
19:32:00 <dmead> i might
19:34:40 <ReinH> Merkle tree are generally useful for efficient verification, not efficient retrieval
19:35:07 <athan> Hi everyone. In Hakyll, is there a simple way to allow `<i>` nodes in the rendered html? I don't really want pandoc messing with my node usage :\
19:35:13 <ReinH> So if you're implementing a Merkle tree, you probably also want to implement efficient anti-entropy
19:36:01 <dmead> ReinH, what do you mean entropy in this context?
19:36:18 <hyy> hey guys I finished 1 hour of code on code.org
19:36:24 <hyy> what do I do now?
19:36:37 <Sindriava> hyy: Have a kitkat?
19:36:54 <dmead> hyy, have a banana. you're sitting at a computer
19:37:06 <hyy> no I wanna learn programming. How would I do that?
19:37:22 <Sindriava> hyy: From experience, it involves a lot of reading and swearing
19:37:30 <hyy> Sindriava, ah
19:37:33 <Gurkenglas> What's hard about implementing Merkle trees? Just decorate each node with a hash that is computed from the child nodes by a constructor?
19:37:39 <ReinH> anti-entropy is a process for reconciling replices with the newest version
19:37:40 <Sindriava> I recommend getting a swearword dictionary
19:38:02 <ReinH> Dynamo uses Merkle trees for this, for example
19:38:15 <dmead> whats dynamo?
19:38:19 <dmead> @hoogle dynamo
19:38:19 <lambdabot> package amazonka-dynamodb
19:38:19 <lambdabot> package aws-dynamodb-streams
19:38:24 <dmead> ah
19:38:25 <hyy> @where lyah
19:38:25 <lambdabot> http://www.learnyouahaskell.com/
19:38:26 <Sindriava> hyy: On a serious note, what's your programming background? Do you know no programming at all, or are you experienced programmer starting with haskell?
19:38:32 <ReinH> dmead: http://www.allthingsdistributed.com/2007/10/amazons_dynamo.html
19:38:38 <hyy> Sindriava, no programming at all
19:39:04 <hyy> I just proved that I could do it with An Hour Of Code
19:39:21 <Sindriava> hyy: LYAH is a great resource. I also recommend the Typeclassopedia by Brent Yorgey
19:39:23 <hyy> but now, I have to learn Haskell
19:39:26 <wei2912> hyy: actually, you proved that you could copy code
19:39:46 <wei2912> hyy: unfortunately programming is a lot harder than that :)
19:39:47 <hyy> wei2912, :(
19:39:56 <Sindriava> wei2912: That's arguable :D
19:39:57 <dramforever> hyy: in univ?
19:39:59 <wei2912> err, i meant to use :(
19:40:07 <hyy> dramforever, no sir
19:40:16 <wei2912> hyy: just curious, why haskell?
19:40:29 <Sindriava> hyy: High school? Elementary?
19:40:31 <dramforever> yeah
19:40:36 <hyy> wei2912, because I like the idea of functional programming
19:40:37 <dramforever> same question
19:40:48 <wei2912> hyy: i see.
19:40:53 <dramforever> =)
19:40:54 <Sindriava> hyy: The idea of functional programming as opposed to…?
19:40:58 <hyy> Sindriava, elementary
19:41:04 <dramforever> wow
19:41:09 <hyy> Sindriava, as opposed to procedural
19:41:21 <dramforever> wow you know a lot!
19:41:36 <wei2912> hyy: impressive
19:41:37 <Sindriava> hyy: So you know procedural programming?
19:41:44 <hyy> Sindriava, no sir
19:41:49 <Gurkenglas> Weird, this channel isn't so mean usually.
19:42:01 * dramforever is really impressed
19:42:07 <wei2912> Gurkenglas: is it particularly mean in any way?
19:42:11 <hyy> I want to start out programming but I researched programming language types
19:42:22 <nshepperd> I wish I learned haskell in elementary school
19:42:26 <ReinH> hyy: right now the most important thing is to get started doing stuff.
19:42:35 <ReinH> Rather than thinking about the best way to start doing stuff
19:42:35 <nshepperd> I can only assume I would be a god among men by now
19:43:16 <ReinH> hyy: Some people recommend LYAH, but it doesn't have many exercises so it doesn't meet the "doing stuff" criteria.
19:43:20 <dramforever> hyy: so what made you want to learn programing?
19:43:30 <Sindriava> nshepperd: I started programming at 8 and rest assured, it didn't help :D
19:43:36 <nshepperd> although, ghc didn't have quite as many awesome features back then
19:43:43 <wei2912> Sindriava: haha
19:43:53 <ReinH> hyy: On the other hand, these suggested lectured do have exercises and people in #haskell-beginners discuss them a lot: https://github.com/bitemyapp/learnhaskell
19:43:53 <wei2912> i started at 9, lost interest, then returned at 12
19:44:05 <ReinH> So that might be a good thing for you to try
19:44:17 <wei2912> i second ReinH's suggestion, you should also join #haskell-beginners
19:44:22 * dramforever started programming at 10, and gained more interest at 12
19:44:23 <Sindriava> wei2912: Yeah, I was just wandering through the landscape until about 15, so my knowledge is broad as hell, but not very deep
19:44:34 <hyy> dramforever, just loving to type in the command line
19:44:38 <dramforever> Sindriava:  +
19:44:39 <dramforever> +1
19:44:41 <ReinH> s/lectured/lectures
19:44:43 <dramforever> hyy: +1
19:45:15 <dramforever> hyy: so you are a big fan of computer-related things, right?
19:45:32 <hyy> right
19:45:40 <dramforever> hmm...we are more or less similar
19:45:45 <mjrosenb> by and large, ghc can use llvm to generate code.
19:46:04 <hyy> my name is actually Einstein
19:46:08 <mjrosenb> can it inline FFI calls to C that has been compiled with clang?
19:46:36 <Sindriava> hyy: Where are you from?
19:46:56 <hyy> Sindriava, the USA
19:47:21 <wei2912> hyy: just to let you know, haskell has a somewhat more steep learning curve than most programming languages people learn at the start
19:48:39 <dramforever> wei2912: really?
19:48:57 <dramforever> hyy: there's a problem you should know about:
19:49:02 <wei2912> dramforever: well, i'm not too sure either
19:49:24 <dramforever> the most popular programming languages in use today are very different from haskell
19:49:29 <wei2912> ^^
19:50:01 <dramforever> so if you learn programming in, for example, high school, you could be confused
19:50:22 <dramforever> but since you know procedral and functional, you should probably be aware of it
19:50:23 <wei2912> it is more of the other way around
19:50:28 <dramforever> hyy: ^
19:50:46 <wei2912> haskell happens to be rather unique
19:50:47 <dramforever> wei2912: most people have the problem the other way around
19:51:03 <wei2912> and very different from other programming languages
19:51:23 <wei2912> dramforever: i was referring to your first statement, not the second
19:51:23 <startling> :t uncurry id -- this is kind of cute
19:51:24 <lambdabot> (b -> c, b) -> c
19:51:34 <dramforever> :t id
19:51:35 <lambdabot> a -> a
19:51:36 <dramforever> :t ($)
19:51:37 <lambdabot> (a -> b) -> a -> b
19:51:38 <dramforever> cute
19:51:59 <Sindriava> :t uncurry
19:52:00 <lambdabot> (a -> b -> c) -> (a, b) -> c
19:52:19 <wei2912> is everyone trying to give hyy a taste of haskell
19:52:26 <wei2912> :P
19:52:44 <Sindriava> You mean like:
19:52:59 <startling> > map (uncurry id) [((+ 1), 2), ((- 1), 3))]
19:53:01 <lambdabot>  <hint>:1:41: parse error on input ‘)’
19:53:06 <Sindriava> filterM (const [True, False]) ?
19:53:25 <startling> > map (uncurry id) [((+ 1), 2), ((- 1), 3)]
19:53:26 <lambdabot>      No instance for (Show b0)
19:53:26 <lambdabot>        arising from a use of ‘show_M290021423444825420430047’
19:53:26 <lambdabot>      The type variable ‘b0’ is ambiguous
19:53:26 <dramforever> hyy: hello are you still there? =P
19:53:33 <startling> yay Num
19:53:33 <hyy> yes sir
19:53:47 * dramforever remembered seeing a blog post
19:54:04 <startling> dramforever, I guess it's really straightforward if you think about ($)
19:54:11 <dramforever> describing someone teaching his/her 10-year-old kid haskell
19:54:28 <dramforever> it's pretty successful
19:54:38 <Sindriava> dramforever: The kid or the post?
19:54:49 <dramforever> Sindriava: teaching
19:55:09 <Jxv> dramforever, just finishing teaching haskell to a small class of 10-12 years.
19:55:13 <tsilamkep> what do you all prefer to suck on... circumcized penises or uncircumcized penises....  in my case I like circumcized penises if I am sucking off white guys.... but uncut cocks are the best for native indians from Mexico
19:55:16 <Jxv> it's possible
19:55:22 <tsilamkep> I like to peel them back with my lips
19:55:30 <dramforever> Jxv: is it easy?
19:55:39 <wei2912> tsilamkep: i like your dedication to the field of trolling
19:55:43 <Jxv> Teaching haskell is easier than teaching kids
19:55:45 <wei2912> commendable!
19:56:05 <dramforever> tsilamkep: hey stop that
19:56:07 <Jxv> especially in a room with computers
19:56:13 <wei2912> haha
19:56:17 <dramforever> elementary school kid here!
19:56:18 <tsilamkep> stop what?
19:56:29 <tsilamkep> I just love to slurp on uncut native mexican guys dicks
19:56:33 <tsilamkep> especially those from yucatan
19:56:35 <tsilamkep> and chiapas
19:56:39 <dramforever> arrgh...
19:56:41 <tsilamkep> straight out of the village
19:56:53 <tsilamkep> when they shoot their loads down my throat
19:56:54 <tsilamkep> omg
19:57:03 <nshepperd> @where ops
19:57:03 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:57:08 <Jxv> @where ops
19:57:08 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:57:09 <tsilamkep> believe it or not my fiance has a 7 inch cock
19:57:10 <tsilamkep> uncut
19:57:13 <tsilamkep> uncircumcized
19:57:21 <hyy> tsilamkep, can you get any more vulgar? What happens in your personal life is nobody's business
19:57:21 <tsilamkep> i love sucking on his manthrobbing cock
19:57:27 <tsilamkep> letting it thrust into my throat
19:57:31 <tsilamkep> and press into my adam's apple
19:57:36 <hyy> UGH
19:57:38 <tsilamkep> i get harder than a rock
19:57:38 <wei2912> hyy: just ignore the troll
19:57:44 <tsilamkep> we are getting married in Chetumal next week
19:57:52 <Sindriava> @where ops
19:57:52 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:57:52 --- mode: ChanServ set +o dolio
19:57:52 <Jxv> he'll get blocked soon enough
19:57:59 <tsilamkep> his salty bitter
19:57:59 <tsilamkep> cum
19:58:01 <tsilamkep> is the prize
19:58:05 <tsilamkep> and I sometimes cum on my own
19:58:07 <tsilamkep> upon tasting it
19:58:11 --- mode: dolio set +b tsilamkep!*@*
19:58:16 <wei2912> dolio: thanks
19:58:20 --- kick: tsilamkep was kicked by dolio (tsilamkep)
19:58:28 <nshepperd> my god
19:58:29 <OutlawStar> nice
19:58:50 <Sindriava> So, monads, huh?
19:58:53 <Sindriava> What a thing
19:59:03 <Sindriava> Let's talk about that
19:59:17 <wei2912> Sindriava: don't spread the monad tutorials pls
19:59:39 <Sindriava> wei2912: I'm not sure I follow
20:00:16 <wei2912> Sindriava: there're already way too many introductions to monads
20:00:28 --- mode: dolio set +b $a:tsilamkep
20:00:33 <Sindriava> wei2912: Sure, but what does that have to do with anything?
20:00:40 <wei2912> Sindriava: err, ignore me
20:00:49 <lamefun> Is Parsec deprecated in favor of Attoparsec?
20:00:57 <Jxv> lamefun, they are different
20:00:58 <Jxv> no
20:01:07 <Sindriava> wei2912: Oh, I get it
20:01:10 <Zemyla> Someone should write a gonad tutorial for Haskell programmers.
20:01:19 <Sindriava> wei2912: I was just homorously trying to change the topic onto something "normal"
20:01:43 <Jxv> lamefun, parsec allows better failure messages
20:01:47 --- mode: dolio set -b tsilamkep!*@*
20:01:51 <Jxv> attoparsec is faster
20:01:54 <Zemyla> lamefun: If nothing else, Parsec is a monad transformer and Attoparsec isn't.
20:02:01 <wei2912> Sindriava: ah, okay
20:02:20 <dramforever> Zemyla: I've never used the monad transformer part of parsec
20:02:31 --- mode: dolio set -o dolio
20:03:10 <Javran> lamefun: when performance is not critical, I think parsec is still fine
20:03:21 <lamefun> Jxv, it certainly looks like it, eg. it looks like Parsec had no major release for some time and doesn't have useful functions like `decimal`.
20:03:24 <Hijiri> attoparsec has support for incremental input
20:03:52 <Javran> ah right
20:04:30 <startling> trifecta / parses is nice in a lot of ways
20:04:48 <Zemyla> lamefun: Look up the "parsers" library.
20:04:56 <wei2912> hyy: on haskell, perhaps we could cover the basics with you first
20:05:04 <startling> oops, s/parses/parsers
20:05:48 <Sindriava> wei2912: I think it would be better to move this into #haskell-beginners
20:05:59 <wei2912> Sindriava: i agree
20:06:06 <wei2912> hyy: on #haskell-beginners
20:06:20 <Javran> even Text.ParserCombinators.ReadP works fine, as it's always available (shipped with base)
20:06:21 <Jxv> lamefun, if you've never used a parser combinator library, then I think parsec is the better choice.
20:06:54 <Jxv> They're all similar though. It might not matter much either ways.
20:07:27 <Zemyla> Javran: Yeah, it's babby's first parser combinator.
20:07:31 <Sindriava> lamefun: Parsec seems to have more tutorials, from what I've seen. Write yourself a Scheme is pretty neat
20:07:47 <Jxv> I believe that's outdated for the current parsec
20:08:02 <Jxv> Unless it's been recently updated
20:08:02 <Sindriava> Jxv: Oh…
20:08:17 <Zemyla> Though to be blunt, you could write a newtype wrapper around ReadS and turn it into a parser combinator.
20:08:39 <Zemyla> I don't know why they don't do that in base.
20:11:07 <lamefun> How much worse are Attoparsec's error messages compared to Parsec's?
20:11:33 <Sindriava> lamefun: They scale a bit worse
20:11:46 <startling> neither will really hold your hand with providing good error messages
20:12:17 <startling> probably anything will work for you, and the others are easy to learn.
20:13:02 <startling> lamefun, to be clear, "not updated since march" doesn't mean "deprecated", just "stable"
20:13:33 <ddellacosta> are there any databases/data stores that are preferred in the Haskell community?
20:14:09 <ddellacosta> for practical vs. research use, I suppose I should clarify, if that is a useful distinction
20:14:46 <startling> ddellacosta, there's not much haskell-specific as I understand it.
20:14:58 <startling> there are bindings for most of the databases you'd want to use.
20:15:20 <hpc> and some you wouldn't want to use!
20:15:32 <Cale> There's acid-state, which is Haskell specific, and is pretty cool.
20:15:45 <ddellacosta> startling: yeah, that's what it seems to me too, but just wondering if Haskell programmers prefer X for reason Y (e.g. the semantics of whatever interface that datastore provides map well to Haskell concepts...etc.)
20:15:57 <Cale> Of course, it's not always in a position to compete with something like postgresql
20:15:57 <hpc> i like acid-state, and ixset makes it a bit more traditional as well
20:15:57 <ddellacosta> Cale, thanks, I'll check out acid-state
20:16:05 <ddellacosta> right
20:16:42 <ddellacosta> I'm quite familiar with postgresql and would probably just use it by default, but was wondering what folks like in general, if such a thing can be said to exist
20:16:49 <ddellacosta> but anyways, thanks all, that was helpful
20:17:15 <ddellacosta> and hpc thanks, will look at ixset too
20:17:52 <startling> ixset *does* look interesting
20:18:52 <comprehension> where does the "templates/wrappers.hs" that Alex includes live?
20:19:52 <comprehension> i'm getting a type error in that file, but all i can find is the line "{-# LINE 1 "templates/wrappers.hs" #-}" in the generated haskell for the lexer
20:21:18 <aeoril> Do higher order functions *have* to be first class functions?
20:21:30 <aeoril> Or do they just have to do one or both of the following:  take a function as a parameter; return a function
20:21:42 <Jxv> one or both
20:23:08 <aeoril> I am coming from JavaScript.  I think that all functions are first class functions in JS anyway.  Is that true of Haskell?  So it seems the first question becomes moot?
20:23:20 <Jxv> aeoril, have you learned about curried functions?
20:23:30 <aeoril> Jxv a little
20:23:42 <Jxv> aeoril, nearly everything is a function
20:24:03 <comprehension> aeoril: they don't necessarily need to return a function
20:24:04 <Jxv> it's not object/function like in javascript
20:24:05 <comprehension> e.g. map
20:24:33 <nshepperd> what do you mean by 'first class'
20:24:42 <comprehension> functions in haskell are first class
20:24:57 <comprehension> there's no such thing as a language where "only some functions are first class"
20:25:08 <aeoril> I am reading a book.  He says a first class function can be held in a variable, passed as an argument, returned from a function, etc.
20:25:13 <dramforever> beceause of types, haskell's functions are nicer to use
20:25:26 <dramforever> aeoril: sure they can in haskell
20:25:59 <aeoril> comprehension that is the point I am getting at - it seems to me that in JS (and now you have told me Haskell) the just are first class functions, so the requirement is moot
20:26:02 <dramforever> it's so common in haskell that we seldom talk about it =)
20:26:22 <aeoril> functions just are*
20:26:24 <nshepperd> aeoril: whether functions are first class or not is a language feature
20:27:03 <aeoril> nshepperd yes, that is what I was thinking - that is why in this book it seemed so odd he had three requirements for HOF - the first being "it must be a first class function" ...
20:27:39 <nshepperd> humm
20:27:47 <nolraiU> That seems weird.
20:27:53 <aeoril> nshepperd I mean, even in JavaScript, *all* functions are first class functions, its just always the case ...
20:27:55 <Jxv> which book is that?
20:28:09 <aeoril> Functional JavaScript by Michael Fogus
20:28:22 * hackagebot xhb 0.6.2015.8.1 - X Haskell Bindings  https://hackage.haskell.org/package/xhb-0.6.2015.8.1 (AntoineLatter)
20:28:35 <nshepperd> you can "sort of" write higher order functions in Java. But Java's functions aren't first class values, so you have to wrap them in an object to pass them around, which makes it a pain in the ass
20:28:57 <monochrom> you cannot treat these language features as mathematical definitions. the very idea of "language feature" is more of the social science essay kind than the mathematical precise kind.
20:29:01 <nshepperd> (note, talking about Java, not Javascript)
20:29:17 <comprehension> aeoril: yes
20:29:27 <comprehension> i mean, functions are first class in haskell
20:29:36 <comprehension> ther's no other option for functions to be
20:30:10 <Gurkenglas> I could well imagine a HOF that isn't first class
20:30:15 <aeoril> ok, i think I am clear on this now - just wanted to double check.  I will now write the author a query on why he gives the definition he gives.  Maybe he has his reasons
20:30:27 <monochrom> to wit, you can't even use one single definition of "function" for both Haskell and Javascript.
20:30:27 <johnw> Gurkenglas: such as?
20:30:28 <Zemyla> Gurkenglas: What does HOF mean?
20:30:31 <aeoril> Gurkenglas i was thinking that too ...
20:30:55 <Jxv> higher-order-function
20:30:57 <startling> "higher order function" I assume
20:30:58 <startling> yeah
20:31:46 <aeoril> ok, thanks guys - appreciate the help
20:32:02 <Gurkenglas> Higher order function. The definition I know is "takes a function as an argument". Obviously, the argument is a function that can be passed as an argument, so its pretty safe to say that the language has first-class functions, but I could imagine that there are different sorts of functions, some of which are first-class (which assumption seems to be made by that author), and so the first-class-ness of the HOF 
20:32:02 <Gurkenglas> wouldn't be implied
20:32:25 <startling> Is there some Monad m => (a -> m (Maybe b)) -> m [a] -> Maybe b?
20:32:33 <startling> note: filterM is def. not what I want
20:32:47 <Zemyla> I know C++ technically doesn't have first-class functions, but its function objects, unlike Java's, can be used indistinguishably from actual functions.
20:33:10 <startling> thinking more, Monad m => (a -> m (Maybe b)) -> [a] -> Maybe b is what I want
20:33:18 <startling> er
20:33:22 * hackagebot language-thrift 0.4.0.0 - Parser and pretty printer for the Thrift IDL format.  https://hackage.haskell.org/package/language-thrift-0.4.0.0 (abhinav)
20:33:26 <johnw> there can be no such function
20:33:28 <startling> Monad m => (a -> m (Maybe b)) -> [a] -> m (Maybe b) -- of course
20:33:30 <johnw> ah
20:33:58 <Zemyla> startling: For your original definition, there is if m is Maybe. :P
20:34:01 <monochrom> what does it do? the type leaves open infinitely many possibilities.
20:34:51 <Jxv> something with maybe transformer, startling?
20:35:01 <johnw> :t \f -> liftM F.asum . traverse f
20:35:02 <lambdabot> (Monad m, Traversable t, Alternative f) => (a1 -> m (f a)) -> t a1 -> m (f a)
20:35:13 <startling> it applies the action to items in the list until one gives Just, or Nothing if it exhausts the list.
20:36:19 <startling> filterM is an OK substitute, but since the argument is m [a] it does extra work in e.g. IO
20:36:20 <Gurkenglas> startling, note that Applicative in place of Monad would be enough for this
20:36:27 <Jxv> :t F.asum
20:36:28 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
20:36:41 <Zemyla> :t \f -> runMaybeT . foldr (mplus . MaybeT . f) mzero -- startling 
20:36:43 <lambdabot> (Monad m, Foldable t) => (a1 -> m (Maybe a)) -> t a1 -> m (Maybe a)
20:36:45 <startling> Gurkenglas: yeah, you're right
20:37:13 <johnw> Zemyla: you're just replicating what asum . traverse does
20:37:16 <Jxv> neat function
20:37:19 <nshepperd> Applicative isn't enough is you want it to stop early
20:37:30 <startling> nshepperd: ah, yeah
20:37:32 <Zemyla> Gurkenglas: No it isn't, because asum . traverse runs all the effects.
20:37:41 <Zemyla> My solution stops when it has a Just.
20:38:02 <johnw> ah, he wants to iterate until the result and then stop, got it
20:38:03 <Gurkenglas> Oh, right. I even had that line of thought yesterday.
20:38:04 <nshepperd> firstM from monad-loops is almost this
20:38:21 <nshepperd> except it just uses a Bool
20:38:27 <startling> nshepperd, I think that works for me. thanks.
20:38:36 <startling> forgot about monad-loops
20:39:44 <Gurkenglas> Should be called findM.
20:41:04 <johnw> i can put that in monad-extras
20:42:26 <Gurkenglas> Do version number conventions tell us anything about what we can expect from base 4.9?
20:44:39 <Gurkenglas> johnw, typo in "Assuming the function passed is associativity, divide up the work binary tree-wise."
20:46:09 <Zemyla> Gurkenglas: "You know, we were wrong about this monad thing..."
20:46:50 <johnw> Gurkenglas: thanks
20:46:57 <Gurkenglas> Zemyla, ?
20:47:08 <Zemyla> I'm joking.
20:47:20 <Gurkenglas> What's the reference? Google doesn't find anything?
20:48:22 * hackagebot monad-extras 0.5.10 - Extra utility functions for working with monads  https://hackage.haskell.org/package/monad-extras-0.5.10 (JohnWiegley)
20:48:24 <johnw> startling: --^  added a findM for you
20:53:51 <Gurkenglas> johnw, what's the type signature? Hackage doesn't link the api
20:54:57 <johnw> findM :: (Monad m, Foldable f) => (a -> m (Maybe b)) -> f a -> m (Maybe b)
20:55:59 <Pamelloes> Has anyone here used esqueleto's avg_ function? I can't get it to typecheck.
20:56:32 <Gurkenglas> Damn it! The "Should be called findM." refered to the firstM :: Monad m => (a -> m Bool) -> [a] -> m (Maybe a) in monad-loops, because it resembles find :: (a -> Bool) -> [a] -> Maybe a, and you went and put another wrong name out there D:
20:57:34 <johnw> I see what you mean
20:57:47 <johnw> I can easily undo the damage, before the world comes apart
20:59:10 <Gurkenglas> johnw, also you should probably replace that Maybe by Alternative.
20:59:49 <Gurkenglas> Or wait, maybe not? Hmm. The <|> isn't really used, only the empty, and we have no Pointed class.
20:59:51 <johnw> i just removed the function
21:02:15 <dblarons> I've been enjoying the syntactic sugar for the Either monad lately. But today I had to unwrap an Either within a function that uses IO (type sig is `FilePath -> IO (Either String Integer)`).
21:02:32 <dblarons> I'm using the syntactic sugar for the IO monad after I read the file in.
21:02:59 <startling> you might like ExceptT
21:03:00 <dblarons> But now I'm unable to use the sugar for Either. Is it possible to use the do ... <- ... sugar for two monads in the same function?
21:03:17 <startling> yeah, ExceptT lets you do that.
21:03:22 <dblarons> startling: Perfect I'll read up
21:03:23 * hackagebot monad-extras 0.5.11 - Extra utility functions for working with monads  https://hackage.haskell.org/package/monad-extras-0.5.11 (JohnWiegley)
21:03:31 <dibblego> dblarons: yes, see monad transformers
21:03:50 <hyy> ok guys, since I finished that hour of code what book do I buy? Do I even learn Haskell as my first programming language? If not, then what language do I pursue? Then, what book do I buy?
21:03:58 <dblarons> dibblego: I suspected it might have something to do with transformers. Sounds like I have some reading to do.
21:04:08 <startling> yeah, that's what the T stands for :)
21:04:27 <dibblego> dblarons: ExceptT is a monad transformer specific to "Except"
21:04:50 <hyy> I want to do systems programming so what language do I learn? C?
21:05:35 <benzrf> yes hyy 
21:06:12 <startling> if you don't have much programming experience, learning any language will be a good first start
21:06:14 <dibblego> hyy: using haskell to learn programming concepts in general is a relatively efficient expenditure of learning effort. How that knowledge is subsequently applied is a different matter, but being equipped with the tools and knowledge to assess how to best do that is a worthwhile aspiration imo.
21:06:15 <hyy> erm...I'm not happy. The C Programming Language 2nd Edition used to be free as a PDF. Now it's not
21:06:39 <hyy> dibblego, so I just learn Ruby as learning it is free?
21:06:57 <startling> hyy, I liked http://c.learncodethehardway.org/book/ , but it's "beta"
21:06:59 <dibblego> hyy: I am of the opinion that using Ruby to learn programming concepts is at the extreme end of inefficiency.
21:07:16 <hyy> dibblego, ok thanks
21:07:20 <startling> learning c first might not be the most efficient thing either
21:07:30 <dblarons> hyy: I learned a few years ago using learnpythonthehardway. Same author, more stable book..
21:07:30 <startling> c programmers have to live with some old mistakes
21:07:54 <dibblego> learning the specifics of a programming language is much more trivial than learning programming concepts in general. Once those concepts are well understood and a learning method is established, you can then decide whether or not to use Ruby or C or whatever.
21:08:06 <startling> ^ yeah, this
21:08:36 <dibblego> however, some programming languages serve as more efficient vehicles to that goal than others. Haskell is relatively efficient.
21:09:06 <Zemyla> Whereas Intercal probably isn't.
21:09:08 <hyy> how do I learn programming concepts in general then?
21:09:14 <startling> write programs. :)
21:09:30 <Freefood> could someone give me a walkthrough of how to implement (trying to recreate their behaviour in another langue) function like quot / rem / quotRem / div / mod
21:09:40 <hyy> ahhah ok! :)
21:09:45 <dblarons> hyy: Read until you're bored, write until you're stuck, repeat.
21:09:52 <dibblego> hyy: I have material to do that, but I do so in-person. There is other material to better assist in self-learning e.g. CIS194.
21:09:54 <hyy> dblarons, perfect!
21:10:28 <dibblego> hyy: a network of peers to help when you are stuck during self-learning is also important e.g. IRC
21:10:31 <Gurkenglas> Careful, either part may diverge.
21:10:39 <startling> Freefood, what does your datatype look like?
21:11:53 <Freefood> @startling let's say these function didn't exist in haskell how you go about writing them (I'm looking at the haskell source but i'm kinda confused so much stuff for so little ^^)
21:11:53 <lambdabot> Unknown command, try @list
21:12:10 <startling> Freefood, you can implement them the explicit way (repeated subtraction), but the implementations for most languages will use things the CPU provides at some level
21:12:54 <startling> Haskell uses gmp, which complicates things a little.
21:13:22 <startling> Freefood, are you trying to learn how these operations work, or are you trying to do something with them?
21:13:29 <startling> mod is sometimes called %
21:14:03 <Freefood> @startling I'm trying to implement them in my own pet project language I do have div and mod already 
21:14:03 <lambdabot> Unknown command, try @list
21:14:54 <dot_Laptop> Hello. How do I implement this kind of Binary Tree? http://lpaste.net/137770
21:16:42 <Freefood> dot_Laptop: if I remeber correctly they have an example in the Learn you a haskell 
21:16:55 <Freefood> dot_Laptop: http://learnyouahaskell.com/zippers => I think that's here
21:17:47 <Freefood> dot_Laptop: they also have a lot of exercise + solution there for binary trees https://wiki.haskell.org/99_questions
21:18:24 * hackagebot uuid-types 1.0.2 - Type definitions for Universally Unique Identifiers  https://hackage.haskell.org/package/uuid-types-1.0.2 (AntoineLatter)
21:18:26 * hackagebot uuid 1.3.11 - For creating, comparing, parsing and printing Universally Unique Identifiers  https://hackage.haskell.org/package/uuid-1.3.11 (AntoineLatter)
21:18:42 <dot_Laptop> I mean the BinTree' = Leaf a | BinTree' a :^: BinTree' a
21:18:59 <dot_Laptop> Is there any material somewhere in the internet?
21:19:52 <dot_Laptop> Or is it inside LYAH?
21:31:33 <ReinH> dot_Laptop: Er, that is an implementation though.
21:32:12 <bitemyapp> ReinH: I think the infix syntax is confusing them.
21:32:19 <bitemyapp> it looks kinda spooky/exotic.
21:32:52 <ReinH> The difference is that the leaves of BinTree' contain a value, so it's the type of non-empty binary trees
21:32:55 <Gurkenglas> One kind of tree has an a on each node, the other only at the leaves. (Compare to Free/Cofree.)
21:33:18 <ReinH> I'm not sure that "Compare to Free/Cofree" is going to be useful.
21:33:31 <bitemyapp> #haskell - Welcome to the Jungle
21:33:39 <bitemyapp> #haskell - hope you didn't want to ask a basic question
21:33:48 <bitemyapp> #haskell - would you like a comonad, or comonad accessory?
21:33:49 <ReinH> bitemyapp: We've got cofun and cogames?
21:33:53 <bitemyapp> lmao
21:34:22 <bitemyapp> dot_Laptop: so in the interest of being at least marginally useful, I'm going to point in the direction of my guide: https://github.com/bitemyapp/learnhaskell
21:34:51 <bitemyapp> dot_Laptop: and suggest you do the course recommended (cis194 followed by NICTA Course) - it should help you develop comfort with how datatypes work (defining, constructing, consuming)
21:35:11 <bitemyapp> dot_Laptop: basically the bintree you're seeing just has a weird infix data constructor. It's not dissimilar from the one in the definition of list.
21:35:20 <bitemyapp> data [] a = [] | a : [a]
21:35:24 <bitemyapp> the : is a constructor here
21:35:31 <bitemyapp> 1 : 2 : 3 : []
21:35:33 <bitemyapp> > 1 : 2 : 3 : []
21:35:34 <lambdabot>  [1,2,3]
21:35:39 <bitemyapp> > 1 : 2 : []
21:35:41 <lambdabot>  [1,2]
21:35:45 <Zemyla> The nonempty BinTree is actually the free monad of Pair a = Pair a a.
21:35:45 <dot_Laptop> Oh I learned something new about list today
21:37:35 <Gurkenglas> dot_Laptop, an easier variation of your question is how to transform (Node () (Node () Empty) Empty) into a BinTree' ().
21:38:00 <Gurkenglas> (() is the unit type with the only value ().)
21:38:50 <Gurkenglas> We want to have two () in the result, and Leaf' only contains one, so our top-level constructor will have to be the other one.
21:38:54 <ReinH> How is that their question?
21:39:12 <Gurkenglas> ReinH, their lpaste says "-- How do I construct aTree' given aTree?"
21:39:36 <dot_Laptop> Yes, Gurkenglas's example could work.
21:39:51 <ReinH> Ah, that's how.
21:39:56 <ReinH> You can't generally.
21:40:00 <Gurkenglas> Spoilers!
21:40:03 <ReinH> Oh.
21:40:09 <dot_Laptop> Why?
21:40:15 <Gurkenglas> Gonna get there.
21:40:26 <dot_Laptop> The term of "nonempty" binary tree is new for me.
21:40:30 <ReinH> They are different structures
21:41:26 <Gurkenglas> The second constructor takes our hole of "fit a BinTree' () in here" and replaces it with two of those holes (and takes a () away from us).
21:42:00 <Gurkenglas> (Wait no that's wrong it doesn't take a () away from us I looked at the wrong type)
21:42:27 <Gurkenglas> (So that makes my whole point fall apart a little but whatever ill finish the example)
21:43:20 <Gurkenglas> Every BinTree' is gonna contain at least one (), because the first one takes one () and the second one makes two more trees that each want at least one ()
21:43:36 <Gurkenglas> (Don't anymore dare say anything about infinite trees now :P)
21:43:52 <c_wraith> But codata is fun
21:44:07 <ReinH> If you look at paths through the tree, BinTree is a list of the value at each step and the direction to go to get to the next one. BinTree' is a list of directions and a single final value.
21:44:22 <ReinH> (formally, we are talking about taking the derivative)
21:44:40 <Gurkenglas> So since we have two BinTree' ()-shaped holes to fill and two () to do it with we'll only want one () taken by each of them, so we have to take the first constructor for both, so the result is (Leaf' ()) :^: (Leaf' ()).
21:46:57 <Gurkenglas> (That is the only possible BinTree' () with two () in them, and it is symmetric where the original BinTree () wasn't!)
21:47:35 <Gurkenglas> Okay, since my example fell apart as noted above, now for the spoilers. http://sketchtoy.com/65627792
21:48:43 <Gurkenglas> (BinTree Int)s look like the left thing, (BinTree' Int)s look like the right thing, if you give me a manual recipe for turning things on the left into things on the right I can implement them in Haskell.
21:49:05 <Gurkenglas> dot_Laptop, how did you come to want to turn one into the other?
21:49:26 <dot_Laptop> Because both are called binary tree.
21:49:33 <dot_Laptop> I thought they are similar somehow
21:50:15 <dot_Laptop> Where does 6 fit into that sketch?
21:50:35 <Gurkenglas> I did not say that these specific trees correspond to each other, I only gave one example of each kind of tree
21:50:57 <dot_Laptop> oh 
21:53:24 <Gurkenglas> I would expect symmetric trees to correspond to symmetric trees. There is a symmetric tree with two values in it of the right sort, no such tree of the left sort. Given that assumption, the two sorts of trees can't be put into one-to-one correspondence.
21:54:07 <Gurkenglas> (A simpler example is that the right sort has no empty tree while the left sort does, but that is the sort of counterexample that one might be tempted to call a special case)
22:08:33 <dot_Laptop> Gurkenglas: I'm really grateful of your explanation. :)
22:08:41 <dot_Laptop> Also thanks to everyone else ;
22:08:43 <dot_Laptop> :D
22:09:18 <srid-erc> .
22:15:57 <ddellacosta> So, after banging my head on this for a while and reading up on it, it seems like one can make the general statement that if you find you are trying to unwrap IO, you are probably doing it wrong and should instead be composing computations that work within an IO context.  Can someone tell me what is wrong with this statement?
22:20:25 <ddellacosta> yeah, nevermind.  I think this is a kind of necessary thing that beginners have to stumble up against before they get it.  For example, http://stackoverflow.com/questions/11467066/how-to-get-normal-value-from-io-action-in-haskell
22:20:55 <ddellacosta> curse you, years of imperative programming experience
22:27:21 <Lokathor> hey i've got a beginner type question to go along with that stack overflow example... sorta
22:28:07 <Lokathor> my program does a million trials of some random stuff to figure some odds. i've got 4 cores in my computer, would trying to re-arrange things to be non-IO and then using some sort of paralell library speed things up usefully?
22:34:38 <Xe> https://gist.github.com/Xe/da1800dad0d4f78459c6
22:34:46 <Xe> what does this error mean and how can I fix it?
22:35:23 <Lokathor> question 1: are you using a sandbox?
22:35:28 <Xe> yes
22:35:44 <Lokathor> was it clean when you started the compilation?
22:36:01 <Xe> yes
22:36:42 <Xe> would a distro level copy of transformers be why?
22:37:31 <Lokathor> shouldn't be, but maybe? I think it uses only sandbox stuff within the sandbox, except for some packages that are closely tied to ghc itself, like the base package
22:38:16 <Lokathor> maybe transformers 0.4 isn't compatible with ghc 7.8?
22:51:11 <startling> Lokathor, It Depends
22:51:21 <startling> Lokathor: I'd recommend profiling first
22:52:18 <Lokathor> i don't know how to do that >_<
22:52:37 <Lokathor> honestly it's only 4-10 seconds total per run so it's not some huge deal, more of a courrosity of if i could do it
22:53:45 <startling> you could probably make it go faster, yeah
22:54:02 <startling> but it's hard to do right without knowing what is actually slowing down your program
22:55:42 <arahael> Lokathor: i've done profiling even when i was only interested in shavin half a second.  profiling is a must - the slowdowns occur in he most surprising places, regardless of the language and env.
22:55:46 <startling> in my experience, it's often something stupid and quick to fix
22:56:24 <startling> and when it's not, it's usually Fast Enough
22:57:36 <Lokathor> well, it gets a list of dice to roll, encoded as a string in the command line arguemnts, then builds a State StdGen [ResultSymbol] from that (each die gives 0, 1, or 2 symbols) then totals up the lists into a map according to rules for how the symbols combine
22:58:20 <Lokathor> but getting the StdGen seed is in IO, so i'm not sure how to push that part outside of IO so that it can be done in paralell
22:58:47 <startling> Lokathor, you can split generators
22:58:48 <Gurkenglas> replicateM_ 1000000 $ (trial :: IO ()) -> replicateM_ 4 . forkIO . replicateM_ 250000 $ (trial :: IO ()) will parallelize it I think, try seeing whether it suddenly takes only 1-3 seconds
22:59:57 <startling> Lokathor, seems worth trying? esp if your goal is "learn how to use parallelism in Haskell" rather than "make my program faster"
23:00:33 <startling> but you can use IO in parallel programs too
23:00:53 <Lokathor> Gurkenglas, how do i get the data back from the forks at the end so that i can get averages of the trials?
23:02:17 <Lokathor> startling, also how would i go about profiling?
23:02:33 <Lokathor> i did that like once in java a decade ago...
23:03:23 <startling> Lokathor, I liked http://book.realworldhaskell.org/read/profiling-and-optimization.html , but it may be out-of-date at this point?
23:05:09 <Gurkenglas> fmap sum . replicateM 1000000 into (...hmmm through the module...) welp, I can't figure it out by myself, unless we start using IORefs or throwing exceptions around in production code, 
23:06:19 <Gurkenglas> *reads
23:07:17 <Lokathor> cabal says i have to "link with -rtsopts" to get rts functionality in my program. i assume that i put that somewhere in my cabal file?
23:07:22 <Gurkenglas> (I just noticed lazily output my next line and output a thought stack trace when I encountered an exception :D)
23:07:27 <Gurkenglas> *I
23:08:44 <ddellacosta> so, I'm going through this https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md
23:08:56 <ddellacosta> and I'm trying to define a monad instance for EitherIO
23:09:06 <ddellacosta> ...on my own without looking at the definition they've given there
23:09:15 <ddellacosta> and I'm finding it...challenging
23:10:03 <Gurkenglas> There must be some Metahaskell library that manipulates .hs files to compile and profile and so on
23:10:18 <startling> ddellacosta: what do you have so far?
23:10:30 <ddellacosta> I'm also realizing that I find definitions like data EitherIO e a = EitherIO { runEitherIO :: IO (Either e a) } quite confusing--is it the case that the "EitherIO" on the left is a type constructor, but the "EitherIO" on the right is a value constructor?
23:10:42 <Gurkenglas> inb4 you should make it! I don't know anything about profiling :(
23:10:55 <kqr> ddellacosta, think about what the monad instance for IO does, and what the monad instance for Either does
23:11:01 <kqr> ddellacosta, there will be some wrapping and unwrapping
23:11:05 <ddellacosta> startling: so, I've started with this after some false starts: let n = runEitherIO j in n ...
23:11:13 <startling> ddellacosta, yeah, constructors have a separate namespace from types
23:11:29 <Lokathor> Gurkenglas, there is :P it's in that realworldhaskell page that was linked, there's RTS opts for it
23:11:35 <ddellacosta> startling: okay, I think that was throwing me off for a while, a basic misunderstanding I had
23:11:40 <ddellacosta> but think I get it now
23:11:45 <startling> it's an annoying thing about haskell tbh
23:12:10 <ddellacosta> yeah, it's mostly just confusing in the context of error messages, but now that I have it clear in my head I think it is more obvious what is going on
23:12:19 <startling> ddellacosta, what are you trying to define? (>>=)?
23:12:21 <Lokathor> -rtsopts seems to be being ignored by either cabal or ghc :/
23:12:23 <ddellacosta> kqr: yeah, I'm trying to use map/bind to my advantage, thinking about that
23:12:34 <ddellacosta> startling: yeah, trying to define >>= now
23:13:10 <ddellacosta> startling, kqr: the thing in particular that is stumping me is how to get the "a" out of "EitherIO e a" to feed it to my "a -> Either e b" function
23:13:39 <startling> ddellacosta, you don't have an a -> Either e b function, do you?
23:14:34 <ddellacosta> startling: so, I wrote this dumb little function to test: let l = \x -> EitherIO $ return $ Right (x + 1)
23:14:59 <ddellacosta> which has type Num a => a -> EitherIO e a
23:15:00 <kqr> ddellacosta, if you have an "x :: EitherIO e a" you can also have a "runEitherIO x :: IO (Either e a)"
23:15:18 <kqr> ddellacosta, at that point you're in the regular IO monad with a regular Either e a value
23:15:35 <startling> ddellacosta: OK, sounds good to me
23:16:14 <ddellacosta> kqr: right, so if I do say, "let n = runEitherIO a in do { ... } " the problem is that I need to return IO there inside the do block, but my function returns EitherIO
23:16:41 <ddellacosta> so I'm very confused by how to run my a -> EitherIO e a function--getting to a point where I can work within the IO context is the easy part
23:16:45 <startling> ddellacosta, do you have a function to turn an EitherIO into an IO?
23:16:55 <kqr> if you have a value "y :: IO (Either e a)" you also have an "EitherIO y :: EitherIO e a"
23:16:59 <ddellacosta> well, runEitherIO does that as far as I know...?
23:17:03 <startling> ddellacosta: yep
23:18:35 <ddellacosta> kqr, so, shouldn't my function with the type sig a -> EitherIO e a work just fine if I do something like (runEitherIO n) >>= myFunctionWithAToEitherIOType ?  I feel like I'm very close but stumped by something basic that I'm overlooking
23:19:31 <kqr> ddellacosta, scrap the runEitherIO in that case
23:19:46 <ddellacosta> kqr: ah okay, let me do some poking at that
23:19:53 <kqr> ddellacosta, as long as both "n" and "myFunction" work within the EitherIO monad, you can do "n >>= myFunction"
23:20:30 <ddellacosta> kqr: oh, but I'm trying to define (>>=) here for the EitherIO monad--I don't have that yet
23:20:42 <startling> ddellacosta, so, why doesn't runEitherIO n) >>= myFunctionWithAToEitherIOType work?
23:20:44 <ddellacosta> kqr (sorry if I'm missing what you're saying here...)
23:20:53 <kqr> no that was me misunderstanding :)
23:21:07 <startling> ddellacosta, it's because myFunctionWithAToEitherIOType :: a -> EitherIO e b
23:21:16 <ddellacosta> startling: hmm, okay, so right--that's why I was using the output of runEitherIO n inside a do block
23:21:37 <startling> I think do blocks aren't likely to help much here
23:21:43 <ddellacosta> startling: and then I was further trying to use (>>=) (i.e. Either's bind) to apply the a to the function
23:21:45 <ddellacosta> startling: ah, okay
23:21:58 <startling> ddellacosta, so, in order to do runEitherIO n >>= f, what type does f need to be?
23:22:04 <ddellacosta> that makes sense, considering that it's clearly not working for me...haha
23:22:41 <ddellacosta> right, f would have to be... 'IO (Either a b) -> EitherIO e b' I think?
23:22:47 <startling> ddellacosta: not quite
23:22:51 <startling> :t (>>=)
23:22:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:22:58 <ddellacosta> oh wait
23:23:18 <ddellacosta> right right, Either a b -> EitherIO e b
23:23:30 <ddellacosta> sorry, 'a' and 'b' is probably confusing things
23:23:36 <ddellacosta> but assuming they are distinct here
23:23:52 <startling> heh
23:24:06 <startling> let's just say Either e a -> EitherIO e b :)
23:24:11 <ddellacosta> okay. :-)
23:24:17 <startling> ddellacosta, so, you have an a -> EitherIO e b
23:24:30 <startling> ddellacosta, can you think of how to turn that into an Either e a -> EitherIO e b ?
23:24:45 <ddellacosta> ...fmap ?
23:24:52 <ddellacosta> hrm, no, that's not right
23:24:56 <startling> actually, hang on
23:25:04 <ddellacosta> fmap would have to return an Either, no?
23:25:16 <startling> sorry, let's back up, I misspoke 
23:25:19 <ddellacosta> sure thing
23:25:35 <startling> Either e a -> EitherIO e b isn't quite right. can you see why?
23:25:45 <startling> (what's the type of runEitherIO n ?
23:26:10 <ddellacosta> right, runEitherIO n is (using same names): IO (Either e a)
23:26:34 <startling> yep. so in runEitherIO n >>= f, what type does f need to be?
23:26:41 <startling> think about the type signature of >>= again
23:27:45 <ddellacosta> okay, we are in IO so that case it would have to be... Either e a -> IO (Either e b) ?
23:27:55 <startling> yeah, exactly.
23:28:15 <startling> so, your problem is that you have an a -> EitherIO e b, rather than an Either e a -> IO (Either e b)
23:29:14 <ddellacosta> right, but--and tell me if I'm mistaken here--what I want to define for (>>=) for EitherIO is something with type 'EitherIO e a -> (a -> EitherIO e b) -> EitherIO e b', no?
23:29:27 <ddellacosta> or maybe you are getting to that and I'm ahead of myself
23:29:30 <startling> yeah, we're working on that
23:29:38 <ddellacosta> okay, I'll be patient...haha
23:30:33 <startling> ok, so let's start witht he easier half. you have f :: a -> EitherIO e b. what can you do to get an a -> IO (Either e b)?
23:30:39 <lpaste_> Lokathor revised “cabal and rtsopts”: “No title” at http://lpaste.net/137776
23:31:12 <Lokathor> so i set rtsopts when i go to configure it, then the compiled thing says i don't have them set. what am i doing wrong?
23:31:35 <ddellacosta> startling: ah, so, runEitherIO gives me that, so I guess I can do something like (runEitherIO . myFunction) 
23:31:44 <startling> ddellacosta: yep, exactly
23:31:55 <startling> ddellacosta, so the other half is that we need to handle the Either
23:32:26 <ddellacosta> okay, okay...hold on...
23:32:37 <startling> Lokathor: sorry, I'm not sure
23:34:04 <ddellacosta> startling: crap, okay, thought I was close but not sure...it can't be as simple as (runEitherIO . myFunction . Right) ?  That would defeat the purpose of using Either methinks
23:34:14 <ddellacosta> oh no, that's wrong anyways
23:34:19 <ddellacosta> blech
23:34:22 <startling> ddellacosta: yeah, that doesn't type-check anyway
23:34:25 <ddellacosta> right
23:34:26 <ddellacosta> hrm
23:34:30 <startling> ddellacosta, you know what Left is supposed to do in this case?
23:34:44 <startling> in the ordinary Either monad
23:34:49 <ddellacosta> startling: I don't...I would assume that is myFunction's responsibility (?)
23:35:05 <startling> nope, myFunction doesn't have any say in how it works
23:35:10 <ddellacosta> oh wait, I see where you are going with this...hrm
23:35:18 <startling> remember, it just wants an a, not an Either e a
23:36:57 <startling> ddellacosta, do you know how Monad looks for Either?
23:37:24 <ddellacosta> startling: I'm sorry, I'm not sure what you're asking. :-/
23:37:30 <ddellacosta> startling: i.e. do I know how it's implemented?
23:37:46 <startling> do you know what the behavior of Left is wrt >>=?
23:38:11 <ddellacosta> startling: ah, right, actually I don't now that you are asking me
23:38:24 <startling> cool. so that's your problem.
23:38:25 <ddellacosta> although I did at one time...
23:38:27 * ddellacosta sighs
23:38:36 <ddellacosta> okay, let me do that work and get back to you.  That is super helpful!
23:38:37 <startling> > Left "x" >>= return . (+ 1)
23:38:38 <lambdabot>  Left "x"
23:38:40 <ddellacosta> oh
23:38:58 <startling> Left "x" >>= const (return True)
23:39:03 <startling> > Left "x" >>= const (return True)
23:39:04 <lambdabot>  Left "x"
23:39:11 <ddellacosta> i.e. returns the value passed in
23:39:34 <startling> not quite. it's more that if there's a Left in the chain of Eithers, the whole chain returns that Left
23:39:34 <augur> its an error value, so errors propagate up
23:39:43 <startling> you can think of it like an Exception
23:39:54 <ddellacosta> ish, right
23:41:09 <startling> so, you have EitherIO (return $ Left "oops") >>= f. What should your return value be?
23:41:22 <startling> if you want to preserve the Eitherish behavior
23:41:32 * ddellacosta is thinking
23:42:04 <ddellacosta> oh, you mean what should f return?  I guess it should be Left "oops" then
23:42:34 <ddellacosta> er, IO (Left "oops")...I mean, in an IO context
23:42:45 <startling> it's not quite what f should return, more like what the whole expression should return
23:42:54 <ddellacosta> d'oh, okay
23:42:56 <startling> remember, f's type is a -> EitherIO e b
23:43:06 <startling> it doesn't even know what to do with a Left.
23:43:42 <ddellacosta> oh okay, I was thinking now we were substituting in (runEitherIO . myFunction) for f
23:43:54 <ddellacosta> but, okay, doesn't change your point
23:43:58 <startling> sure, let's say we are
23:44:22 <startling> myFunction is a -> IO (Either e b). we still have the same problem.
23:44:41 <startling> you need to somehow make it into an Either e a -> IO (Either e b)
23:44:53 * ddellacosta bangs his head against the wall, metaphorically, wondering why everything seems so obvious except for this bit
23:45:19 <startling> heh, don't worry about it. It's a thing many people struggle with at first.
23:45:28 <ddellacosta> well, wait, that is the sig for the second arg in (>>=) for IO isn't it?
23:45:30 <ddellacosta> wait a second
23:45:44 <ddellacosta> a -> IO b
23:45:50 <ddellacosta> so, do we need something like
23:46:23 <ddellacosta> \x -> x >>= (runEitherIO . myFunction) ?
23:47:10 <startling> no, because (runEitherIO . myFunction) is IO, but x is Either
23:47:30 <ddellacosta> argh, right
23:47:38 <startling> so, you want to handle the Left here, right?
23:47:57 <ddellacosta> okay, this is going to be a really dumb question
23:48:02 <ddellacosta> but why don't we care about the right?
23:48:06 <ddellacosta> Right rather
23:48:14 <ddellacosta> something big and obvious I'm missing here
23:48:39 <startling> we do care about the Right, but it's very easy to deal with the Right
23:48:56 <startling> we have a function (f) that would very happily take the unwrapped version of the Right
23:49:39 <ddellacosta> right
23:49:47 <ddellacosta> ....but when we have Left we need to return that as is
23:49:52 <ddellacosta> let it propagate back up
23:49:54 <startling> yeah, exactly.
23:50:01 <ddellacosta> oh jeez
23:50:04 <ddellacosta> okay, let me try this, one sec
23:50:17 <startling> there's one more thing we haven't discussed, so the whole thing won't typecheck
23:50:28 <startling> but this is pretty close.
23:54:11 <ddellacosta> startling: okay, so I tried `x >>= f = runEitherIO >>= (\n -> case n of Right n -> (runEitherIO . f) n Left	 n -> n)` (sorry, missing line breaks for case statement)
23:54:23 <ddellacosta> obviously that's not right but I feel like I'm getting close
23:54:38 <startling> yeah, that's much closer
23:54:53 <ddellacosta> one thing is that I need to return IO for the Left case
23:54:57 <startling> yep
23:55:09 <ddellacosta> and I guess I have to wrap the whole thing in EitherIO too, that's easy though
23:55:13 <startling> ddellacosta, not just IO
23:55:21 <ddellacosta> ?
23:55:22 <startling> ddellacosta, you need to return IO (Either e b) in the Left case
23:55:38 <ddellacosta> oh, right, this is easy, what am I doing
23:56:01 <ddellacosta> er, no, hrm
23:56:10 <startling> what did you try?
23:56:42 <ddellacosta> well, I always get stuck on how to return an IO value
23:56:51 <ddellacosta> (I tried ' IO (Left n) '
23:56:58 <startling> IO is not a constructor
23:57:10 <ddellacosta> right, I always screw that up
23:57:13 <startling> :t return -- is the best way
23:57:14 <lambdabot> Monad m => a -> m a
23:57:22 <ddellacosta> d'oh, right
23:57:52 <startling> cool, so the one more thing to do is wrap the whole thing in EitherIO, like you said
23:59:10 <ddellacosta> yeeeeeeeess
23:59:44 * ddellacosta sobs tears of joy
23:59:47 <Shoggoth> is there a way to make cabal create it's heirarchy somewhere other than ~/.cabal ?
23:59:49 <ddellacosta> startling: thank you so much
23:59:54 <startling> ddellacosta, it type-checks? cool
23:59:59 <ddellacosta> startling: yeah
