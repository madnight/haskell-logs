00:00:18 <startling> nice work! your solution is basically the same as the one in the doc you linked, btw
00:00:24 <ddellacosta> startling: oh, let me look now
00:00:35 <augur> well, IO is a _type_ constructor, but not a _data_ constructor
00:00:47 <startling> the only difference is that it uses `either` instead of a case, but they do the same thing.
00:00:53 <ddellacosta> ah, they use that either function
00:00:54 <ddellacosta> right
00:01:06 <ddellacosta> gotcha, that's a bit cleaner, although maybe this is more obvious in terms of what is going on
00:01:18 <startling> yeah, there's not a huge difference between the two
00:01:27 <ddellacosta> although, I suppose most Haskell programmers are quite familiar with either so probably more idiomatic
00:02:06 <startling> Haskell programmers are familiar with case too :P
00:02:19 <ddellacosta> startling: well, again, I can't thank you enough for your patience as I fumbled through that--thanks again!  I owe you a beverage of your choice if the occasion ever arises. :-)
00:02:30 <ddellacosta> right, heh
00:02:59 <startling> it's really no problem. pretty sure someone explained these things here for me too
00:03:11 <ddellacosta> yeah, the community here is really pretty great
00:03:28 <startling> so, from here, I'd recommend that you write Monad instances for Maybe and Either if you haven't yet
00:03:50 <ddellacosta> startling: yeah, I did a while ago, but probably would be a good exercise again
00:04:02 <ddellacosta> this is what happens when I learn in fits and starts
00:04:28 <ddellacosta> really have to be using this frequently so it doesn't fall out of my brain. :-/
00:04:32 <startling> yeah, it can be hard
00:04:53 <startling> ddellacosta, http://blog.sigfpe.com/2007/04/trivial-monad.html might help as well
00:05:02 <ddellacosta> cool, will check that out
00:07:15 <startling> that last article in particular made it click for me
00:08:52 <augur> concrete examples are always good
00:09:05 <augur> W (aka Identity), Maybe, lists
00:09:18 <augur> then you can get more advanced -- reader, state, etc.
00:09:32 <startling> Reader is a fun one
00:17:41 <kqr> reader is a weird one
00:17:57 <kqr> especially the equivalency to functions in general
00:20:52 <startling> yeah
00:21:32 <startling> I think starts getting you into that place where you're saying "how can I use Monads to make my programs nicer" instead of "wtf is a Monad".
00:21:57 <startling> State is another big one
00:22:07 <startling> and then, I guess, transformers
00:22:20 <kqr> I find state easier to grok than reader actually
00:23:16 <startling> it's just the front half of state. :P
00:24:18 <kqr> sure
00:24:22 <kqr> but when I see things like this: http://lpaste.net/137781
00:24:24 <kqr> i'm like whaaa
00:24:47 <kqr> I do understand how it works, I just have no intuition for it
00:26:16 <startling> Every once in a while that style is really useful
00:26:46 <kqr> i imagine it being pretty useful all the time, with a less constricting type signature
00:26:49 <kqr> but probably a bit harder to read
00:26:56 <startling> yeah
00:27:46 <startling> (,) <$> (+ 1) <*> (* 2) style is great for one-liners though
00:28:03 <kqr> 'tis, though I prefer the liftA* functions
00:52:57 <Gurkenglas> Has there been any work showing that there aren't any more monads than the ones we already know? (Or can inductively construct from them)
00:53:10 <Gurkenglas> *on
01:13:05 <adarqui> started learning purescript today.. haskell + purescript is going to be fun
01:14:52 <u-ou> what's purescript
01:15:39 <adarqui> strongly typed lang, similar to haskell, but strict not lazy, which compiles down to javascript (and eventually other backends from the looks of it)
01:15:53 <u-ou> yeah, i'm reading about
01:15:55 <adarqui> has tons of libs which are 'nearly identical' to haskell
01:15:57 <u-ou> i shouldn't have asked :p
01:16:04 <u-ou> ah, interesting
01:16:47 <adarqui> i'm not good at frontend, .. not one bit.. i've always hated it. but, i've always wanted to code fun interfaces... so really i think it's just the tools I was using. purescript might allow me to have more fun programming, like haskell does
01:31:39 <vlatkoB> Anybody knows when will LTS for 7.10 move from nightly to LTS-3?
01:31:41 <moop> eh, i am not a fan of languages that try to turn javascript into something it's not
01:32:07 <moop> adarqui: i mean, just to debug something you have to know purescript, how purescript converts shit to javascript and javascript
01:32:12 <moop> just learn javascript
01:32:52 <moop> unless you really love ml
01:33:44 <moop> i'm not saying purescript is bad, far from it
01:34:11 <arkeet> just use ghcjs ;-)
01:35:18 <moop> but, like, just be aware of js annoyances that will be harder because you decided to use ps
01:35:27 <moop> or easier
01:35:30 <moop> what do i know
01:45:06 <zomg> As someone who's worked a lot with languages that compile to JS, yes.. JS knowledge is required when something goes wrong
01:45:40 <zomg> It largely depends on how the language translates itself into JS, in some cases it might be easy or not needed so much, but in other cases, it can get VERY tricky to debug it at all
01:45:57 <zomg> ClojureScript used to be a HUGE pain to debug
01:51:18 <arahael> zomg: does that also apply with emscripten?
01:51:49 <zomg> Probably, and I imagine the results aren't very debug-friendly
01:51:59 <zomg> but I've not used emscripten so can't say for sure
01:52:20 <zomg> but at least these days most of the tools support source maps which can help with that
02:11:19 <ideasman42> Hi, am only absolute beginner with haskell, but was curious to ask if its well suited to 3D geometry manipulation
02:11:27 <ideasman42> something like wings3d modeler
02:11:36 <ideasman42> (or any modeling tool)
02:12:00 <ideasman42> if this isnt good time, or appropriate place to ask, then np
02:12:31 <ideasman42> while am sure its _possible_, am curious if this is a good-fit
02:12:59 <dramforever> ideasman42: IIUC wings3d isn't even a programming language
02:13:12 <dramforever> oh wait sorry it's based on erlang right?
02:13:16 <ideasman42> wings3d uses erlang
02:14:08 <ideasman42> am cururious if haskell could be used to make a really advanced mesh editing API
02:14:38 <dramforever> ideasman42: oh so you are making one yourself?
02:14:43 <dramforever> impressive
02:14:47 <ideasman42> the reason I ask is I think such a system may not be able to take advantage of immutability
02:15:04 <dramforever> yes I think haskell is good
02:15:09 <ideasman42> I didnt write anything in haskell yet for this
02:15:33 <ideasman42> but have written a lot of 3d modeling code in C
02:15:33 <dramforever> no more suggestions.
02:16:07 <ideasman42> issue is - you have a large mesh, say a few million polygons...
02:16:13 <ideasman42> you need to perform edits in-place
02:16:23 <dramforever> ideasman42: well not really
02:16:32 <dramforever> there's a thing called sharing
02:16:33 <ideasman42> well, its possible to imagine some data structure that doesnt do this
02:16:50 <dramforever> that would allow two data structures to share parts
02:17:00 <dramforever> so you only allocate for the new parts
02:17:30 <dramforever> and in haskell algebraic data types automatically does this
02:17:37 <ideasman42> sure, but if mesh data stores cross-references
02:17:44 <ideasman42> eg, all faces using an edge
02:17:59 <ideasman42> if you remove a face, the edge would have to be updated
02:18:10 <ideasman42> or some data structure the edge refrences
02:18:13 <dramforever> yeah that could be a problem
02:18:43 <ideasman42> I realize not all mesh structures use/need this...
02:18:48 <dramforever> but yeah it's still possible to imagine some data structure that doesn't have this problem
02:19:10 <ideasman42> but if you want to do operations such as bevel, or booleans... you probably want to have connectivity data somewhere
02:19:43 <dramforever> also you can have mutable vars in haskell
02:19:48 <ideasman42> right
02:19:58 <dramforever> it's just really...akward
02:20:26 <ideasman42> thats the crux of the matter... since if I spend time to use haskell for this... I then may end up doing C-like development in haskell
02:20:51 <ideasman42> and not be able to take advantage of functional composition
02:21:04 <ideasman42> although am sure there are other smaller areas it could still be useful
02:21:16 <ideasman42> and not all operations on geometry are distructive either
02:22:54 <ideasman42> it would be interesting to have some structure which managed to balance immutability but allow editing...
02:23:36 <ideasman42> but at the end of the day you do want geometry to be added/removed in some sense.
02:24:07 <dramforever> ideasman42: do you get the idea of sharing?
02:24:22 <ideasman42> maybe?
02:25:06 <dramforever> ideasman42: also did you look for existing haskell stuff?
02:25:09 <dramforever> are there any?
02:25:31 <dramforever> if there weren't and you are able to create a nice one, that's awesome!
02:25:31 <ideasman42> There are some games... I didnt see any 3d mesh editing... only talk of this online
02:25:56 <ideasman42> re: sharing... is this something very different in haskell?
02:26:34 * ideasman42 reads https://wiki.haskell.org/Sharing
02:28:26 <dramforever> ideasman42: too bad that's not specific enough
02:28:36 <dramforever> do you know haskell?
02:29:00 <ideasman42> only a tiny bit, some beginner tutorials, some talks
02:29:11 <dramforever> okay
02:29:19 <dramforever> no more suggestions
02:38:46 <martinvlk> Hi all, I am working on the NICTA course exercises and I am really stuck with one - could someone give suggestion on how to proceed? http://lpaste.net/1895423029693906944 
02:40:13 <martinvlk> Trying to define applicative instance for a Functor over Maybe value
02:40:47 <dibblego> martinvlk: if they are both Just, then return Just, otherwise Nothing
02:44:00 <martinvlk> dibblego: updated lpaste with one of my recent tries.. my idea is since the inner functor is Applicative I should be able to just use <*> but that doesn't compile and I have to admint I am lost in the multiple levels of wrappers
02:45:40 <dibblego> martinvlk: on the right track — you'll have to pull it apart a bit more
02:46:19 <dibblego> you can use the Applicative for (f) and the Applicative for (Maybe) to answer it, but you have to peel out these pieces
02:46:29 <dramforever> or use the applicative
02:48:17 <martinvlk> dramforever: use applicative on multiple levels? I'm trying on one level but it's not enough
02:48:32 <dramforever> martinvlk: exactly =)
02:48:37 * hackagebot clash-prelude 0.9.2 - CAES Language for Synchronous Hardware - Prelude library  https://hackage.haskell.org/package/clash-prelude-0.9.2 (ChristiaanBaaij)
02:48:39 * hackagebot clash-lib 0.5.10 - CAES Language for Synchronous Hardware - As a Library  https://hackage.haskell.org/package/clash-lib-0.5.10 (ChristiaanBaaij)
02:48:41 * hackagebot clash-ghc 0.5.11 - CAES Language for Synchronous Hardware  https://hackage.haskell.org/package/clash-ghc-0.5.11 (ChristiaanBaaij)
02:49:11 <dramforever> martinvlk: use the outer applicative to use the inner applicative
02:49:29 <dibblego> martinvlk: there are two levels, you have (f (Maybe _))
02:49:36 <sgronblo> so cabal does not support updating or uninstalling packages right? are there any efforts under way to improve this?
02:49:53 <martinvlk> ah... let me give it a few more shots then... this is complicated stuff for me :-)
02:50:59 <benley> sgronblo: there is Stack...
02:51:03 <benley> https://www.fpcomplete.com/blog/2015/06/announcing-first-public-beta-stack
02:51:40 <benley> sgronblo: I hear cabal sandboxes are a thing.  Also the Nix package manager is brilliant for haskell.
02:52:16 <sgronblo> benley: does stack support use cases like "install ghc-mod globally and keep it up to date"?
02:52:32 <benley> sgronblo: no clue, I am 1000% noob here
02:53:59 <cocreature> sgronblo: you can install it globally, which basically just copies the binary to ~/.local/bin but it doesn't keep it up2date for you
02:57:54 <sgronblo> cocreature: oh so you would check out for example ghc-mod yourself, then run stack to build it and then some other stack command to link the binary?
02:59:04 <cocreature> just run stack install and it copies the resulting binaries to ~/.local/bin
03:00:45 <sgronblo> i guess its already too late to change the crappy name for stack
03:01:22 <cocreature> it's not that bad. if you search for stack haskell or stack haskell tool the results are usually what you want
03:02:14 <sgronblo> yeah... but i thought things like go should already have shown how bad it is to name your project so generically
03:02:35 <benley> the name Go hasn't worked out too badly, has it?
03:03:01 <dramforever> benley: issue 9 on google code:
03:03:17 <dramforever> some other company already made a programming language called go
03:03:27 <benley> heh. okay, yeah.
03:03:58 <benley> I was rather pissed off when they named it Go at first, because there was already a thing called go within google even.
03:04:11 <demize> Well, the other one is called Go! and pretty much noone have ever heard of it ;p
03:04:20 <dramforever> =)
03:04:20 <sgronblo> yeah sucks for them but the main problem is that you cant easily perform an online search for something that has a name that is so commonly used.
03:04:21 <demize> benley: Was there?
03:04:35 <cocreature> just search for go lang and you get what you want?
03:04:40 <cocreature> is that really such a problem?
03:04:40 <benley> demize: yeah, a url redirector at http://go
03:04:41 <dramforever> there's a system by IBM called WAS
03:04:42 <demize> sgronblo: For most languages people end up using <name>-lang everywhere.
03:04:54 <benley> also, Go is effectively "golang" for search purposes
03:04:56 <demize> benley: ah, heh.
03:05:13 <demize> dramforever: was was good
03:05:20 <dramforever> sure it was
03:05:33 <benley> demize: that did lead to hilarious things like http://go/gogadget/go
03:05:48 <demize> Hehe, awesome.
03:06:11 <benley> and http://go/notheotherone
03:06:44 <sgronblo> demize: yeah so they might as well have named the thing golang from the start
03:06:45 <demize> no http://go/ndor? ;p
03:06:57 <benley> oh I'm sure that existed.
03:07:16 <Gurkenglas> Is there a version of zipWith that isn't strict in its third argument?
03:08:16 <dramforever> Gurkenglas: how could it be
03:08:34 <cocreature> > zipWith (+) [] (error "strict in third argument")
03:08:36 <lambdabot>  []
03:08:50 <cocreature> how is zipWith strict in its third argument?
03:09:54 <ely-se> Gurkenglas: yes: zipWith
03:11:10 <Gurkenglas> > zipWith ($) [const 1] undefined -- Maybe I used the wrong terminology. I mean that that to the left returns undefined.
03:11:12 <lambdabot>  *Exception: Prelude.undefined
03:12:21 <cocreature> Gurkenglas: well to apply the const 1 it first has to check if there is an element on the right
03:12:24 <Gurkenglas> @let zipWith' f xs ys = zipWith f xs (ys ++ repeat undefined) -- lets see whether this works for what I had in mind
03:12:25 <lambdabot>  Defined.
03:12:34 <cocreature> > zipWith ($) [const 1] [undefined]
03:12:36 <lambdabot>  [1]
03:15:12 <Gurkenglas> > fix $ zipWith' (:) [0..] . tail -- Nope, still doesn't work. (This is a stripped-down version of what I was trying to do.)
03:15:16 <lambdabot>  mueval-core: Time limit exceeded
03:15:43 <Gurkenglas> Is there some tool that shows me how that is tried to be reduced to whnf?
03:17:09 <Gurkenglas> And oh right, zipWith' is still strict in the third in the same sense as zipWith was
03:18:43 <lyxia> What are you trying to do?
03:21:06 <Gurkenglas> Ultimately, get a tree whose nodes, aligned on (Nat, Nat), share a child with every diagonally adjacent neighbor of the same distance to the root.
03:22:07 <Gurkenglas> (Intermediately, get a Cofree Identity in a way that can be generalized to two dimensions.)
03:23:56 <Gurkenglas> Hmm, if I implement zipWith on Cofree Identity ("infinite stream") instead of [], it wouldn't have that "kinda-strictness" in the third.
03:26:44 <sgronblo> is "cabal-install" the same thing as the cabal command you run to install things?
03:27:00 <moop> what's a nice command-line argument parsing library out there?
03:28:17 <martinvlk> moop: optparse-applicative (more here https://wiki.haskell.org/Command_line_option_parsers)
03:28:32 <moop> ty martinvlk 
03:38:59 <martinvlk> @pl (\maybeg -> (\g -> g <$> a) <$> maybeg) <$> runMaybeT g
03:38:59 <lambdabot> ((<$> a) <$>) <$> runMaybeT g
03:39:50 <dibblego> @type liftA2 (<*>)
03:39:51 <lambdabot> (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
03:40:53 <martinvlk> dibblego: ah, doh!
03:49:12 <saulzar_> Someone correct me if I'm wrong - but I think in order to have a MonadState or MonadWriter which supports state changing sub-computations I need to get rid of the funtional dependency and put the state in the type, right?  e.g.  MonadState m =>  m s a   rather than MonadState m s => m a
03:58:59 <Gurkenglas> saulzar_, is (s -> s) a "state changing sub-computation"? https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#v:modify
03:59:24 <saulzar_> Ah, sorry - type changing. 
03:59:58 <saulzar_> I think I'm mistaken, though. 
04:00:18 <saulzar_> I can just say something like this: (MonadWriter w (m w), MonadWriter w' (m w')) => 
04:00:23 <dramforever> :t zoom
04:00:25 <lambdabot> Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
04:00:40 <dramforever> no...
04:00:57 <dramforever> saulzar_: I doubt if you could still have monad that way
04:01:06 <dramforever> wait you can, sorry
04:01:20 <Gurkenglas> (MonadState s m, MonadState t n) => (s -> t) -> m (n ())?
04:01:29 <dramforever> anyway you need a function to get the new state type from the old one
04:01:53 <dramforever> so, like we want to change s into t
04:02:03 <dramforever> so we need s -> t and s -> t -> s
04:02:13 <dramforever> which is a...lens!
04:02:43 <saulzar_> yeah, I'd forgotten about zoom 
04:03:54 <Gurkenglas> :t \f -> put . f <$> get
04:03:56 <lambdabot> (MonadState a f, MonadState s m) => (a -> s) -> f (m ())
04:06:07 <saulzar_> Cool, thanks guys
04:07:30 <saulzar_> I've been using a custom class, but it's actually a writer in disguise
04:10:49 <phaazon> oh gosh
04:10:56 <phaazon> new GHC version!
04:11:06 <phaazon> I hope itâ€™ll be bundled into archlinux quickly
04:17:16 <martinvlk> @pl OptionalT $ (lift2 (<*>)) (runOptionalT g) (runOptionalT a)
04:17:16 <lambdabot> OptionalT (lift2 (<*>) (runOptionalT g) (runOptionalT a))
04:20:41 <sgronblo> Where does stack install packages?
04:23:14 <martinvlk> into a project-local directory called .stack-work 
04:24:43 <saulzar_> listen is an odd funciton, rather wish it didn't 'tell' it's output as well as returning it - otherwise it'd replace my existing interface perfectly :)
04:24:51 <sgronblo> martinvlk: does that mean you have to have a project?
04:25:06 <Gurkenglas> @pl \g a -> OptionalT $ (lift2 (<*>)) (runOptionalT g) (runOptionalT a)
04:25:07 <lambdabot> (OptionalT .) . (. runOptionalT) . lift2 (<*>) . runOptionalT
04:26:10 <martinvlk> sgronblo: yes, or that's my understanding 
04:26:51 <Gurkenglas> Assuming that a and g are of the same type, OptionalT $ on (lift2 (<*>)) runOptionalT g a
04:28:12 <martinvlk> :t on
04:28:13 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
04:30:10 <sgronblo> martinvlk: so this "If you just want to install a package using stack, then all you have to do is stack install <package-name>" is not to be used similarly to npm install -g?
04:31:03 <martinvlk> sgronblo: let me see
04:31:48 <martinvlk> ~$ stack install containers
04:31:48 <martinvlk> Using latest snapshot resolver: lts-2.20
04:31:48 <martinvlk> Writing global (non-project-specific) config file to: /home/martin/.stack/global/stack.yaml
04:31:57 <martinvlk> sounds like I was wrong
04:32:07 <lyxia> Gurkenglas: http://lpaste.net/137788 what about this
04:33:11 <sgronblo> martinvlk: cool! :)
04:33:13 <martinvlk> sgronblo: not sure though how global stuff will interact with projects
04:33:48 <sgronblo> so can i rid myself of my cabal binary now and install it through stack instead?
04:35:01 <martinvlk> that I haven't tried
04:35:56 <sgronblo> i hear you can ghc-pkg unregister packages but does that unlink the binaries too?
04:36:44 <martinvlk> after doing non-project install it crates the global stack-work dir in: ~\.stack\global\.stack-work
04:37:06 <sgronblo> anyway what does ghc-pkg unregister really mean? does it automatically refer to your ~/.cabal or something?
04:38:43 <martinvlk> dunno
04:40:05 <geekosaur> ~/.ghc unless you name a package in the global package db (which would require root; and in general, don't do that)
04:41:40 <martinvlk> Gurkenglas: thanks, but sometimes I find I dn't have to go pointfree at all costs, I think this is fine: OptionalT $ lift2 (<*>) (runOptionalT g) (runOptionalT a) 
04:42:13 <martinvlk> is there any other benefit apart from improving readability?
04:42:27 <martinvlk> from pointfree I mean
04:42:31 <Gurkenglas> You don't have to invent names for the variables!
04:42:39 <martinvlk> yeah... true
04:42:48 <Gurkenglas> A wise man once said that inventing names gets more painful the more experienced you get
04:43:13 <ChristianS> i'm all in favor of pointfree if it makes the code shorter, but not otherwise
04:43:29 <martinvlk> :-) yeah, I find you have to hit the right balance 
04:43:40 <dramforever> I favor pointfree if it's more readable only
04:43:57 <dramforever> for example I sometimes use on
04:43:58 <martinvlk> not even shorter is the criterion though, I think readability rules
04:44:09 <martinvlk> snap
04:44:11 <dramforever> but I almost never use flip
04:44:58 <martinvlk> flip is hard to parse by us humans isn't it
04:45:40 <Gurkenglas> I'll use flip to get a long argument out of the middle of a line without using where
04:45:55 <Gurkenglas> Like, a 5 lines long list or do block
04:46:09 <dramforever> also I avoid those "(blah .) . (. blah)"-ish things
04:46:24 <dramforever> but I use func = foo . bar . baz often
04:48:11 <Gurkenglas> Those big argument permutations are also the one place where I'll use a lambda over pointfree, but I did once use (asd . dsa . foo .) . (. bar . xd) where the alternative would have been (\f -> asd . dsa . foo . f . bar . xd)
04:48:11 <martinvlk> yes, composition is very neat and readable
04:51:42 <martinvlk> on a reated note, is using one-letter (or generally short) variables in Haskell out of necessity - because the programming style favours brevity? 
04:52:50 <dramforever> martinvlk: because long names doesn't do more
04:53:00 <dramforever> as haskell functions are usually very general
04:53:07 <dramforever> for example f $ x = f x
04:53:31 <nullvoid8> the futher your variable spans / the more specific your functions, the more descriptive your names need to be
04:53:35 <dramforever> function $ argument = function argument
04:53:36 <martinvlk> oh right, the generality is the key..
04:53:40 <dramforever> =_
04:53:41 <dramforever> =)
04:53:51 <dramforever> also map :: (a -> b) -> [a] -> [b]
04:54:00 <dramforever> any better names instead of a and b?
04:54:02 <dramforever> =P
04:54:05 <martinvlk> :-)
04:54:09 <martinvlk> no, you're right
04:55:54 <martinvlk> though at some point one has to get away from writing general stuff (in courses, etc.) and  start ding something real - as nullvoid8 points out then I'd probably go for something longer
04:56:28 <dramforever> martinvlk: yes let's call it the "range-length" rule
04:58:07 <Gurkenglas> "And when the range of possible values of the variable drops to 1, its name length diverges."
04:59:02 <Rembane> Spartan programming is another way of naming and thinking about your variables and functions. http://blog.codinghorror.com/spartan-programming/
05:00:22 <martinvlk> :-)
05:23:43 * hackagebot OrchestrateDB 1.0.0.3 - Unofficial Haskell Client Library for the Orchestrate.io API  https://hackage.haskell.org/package/OrchestrateDB-1.0.0.3 (dwd31415)
05:26:47 <ronh_> martinvlk see http://www.reddit.com/r/haskell/comments/28f5j0/why_do_haskellers_prefer_nondescriptive_variables/
05:27:09 <martinvlk> Ah, thanks :-)
05:31:35 <sperrys> hi. is stack now a prefered way of installing haskell libraries?
05:33:06 <ralu> i am trying to use cabal with crosscompiler, (i have working cross-ghc) but i am having hard time to make it work with cabal install. http://lpaste.net/137787 Anyone has any idea?
05:37:37 <moop> > (+ 2 2)
05:37:38 <lambdabot>      Could not deduce (Num a0)
05:37:38 <lambdabot>      from the context (Num a, Num a1, Num (a1 -> a))
05:37:38 <lambdabot>        bound by the inferred type for â€˜e_122â€™:
05:37:51 <moop> > (+) 2 2
05:37:52 <lambdabot>  4
05:38:00 <moop> > + 2 2
05:38:02 <lambdabot>  <hint>:1:1: parse error on input â€˜+â€™
05:39:26 <ralu> >((+) 2 2)
05:39:32 <ralu> > ((+) 2 2)
05:39:33 <lambdabot>  4
05:43:44 * hackagebot ghc-exactprint 0.3.1 - ExactPrint for GHC  https://hackage.haskell.org/package/ghc-exactprint-0.3.1 (AlanZimmerman)
05:48:26 <martinvlk> sperrrys: depends if you are happy using primarily packages from stackage, but stack is handy.. definitely for me as a Haskell beginner  
05:54:12 <sperrys> martinvlk: primarily packages from stackage as opposed to what?
05:54:53 <martinvlk> to complete hackage contents
05:55:15 <sperrys> hmm
05:55:31 <martinvlk> https://www.stackage.org/
05:55:44 <martinvlk> "Stackage is a stable source of Haskell packages. We guarantee that packages build consistently and pass tests before generating nightly and Long Term Support (LTS) releases. "
05:57:38 <sperrys> i have no idea what packages i may want to use in future since i am still in the process of learning haskell
05:59:55 <martinvlk> me too.. but I have already hit cases where I needed to use non-stackage packages..  and stack has support for including extra packages
06:00:16 <martinvlk> only you don't get the same level of guarantees
06:01:32 <martinvlk> stack still uses cabal under the covers
06:03:25 <martinvlk> to be honest I don't know what is the level of stack adoption among people.. I use it, and it mostly works nice
06:08:44 * hackagebot hakyll 4.7.2.2 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.7.2.2 (JasperVanDerJeugt)
06:16:23 <benma> hi! im monads i find mayself often doing this: case foo of Nothing -> return (); Just foo' -> ...
06:16:57 <benma> this can be simplified a little with: flip (maybe (return ())) foo $ \foo' -> ...
06:17:08 <benma> is this function defined somewhere in base or another package?
06:17:24 <dramforever> @hoogle Maybe a -> (a -> x) -> x
06:17:25 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
06:17:25 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
06:17:25 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:17:34 <benma> and is there a predefined shorter version of `return ()`, named i.e. "pass" or "skip"?
06:18:45 <Gurkenglas> https://hackage.haskell.org/package/monad-extras-0.5.11/docs/Control-Monad-Extra.html
06:18:45 * hackagebot engine-io-wai 1.0.3 -   https://hackage.haskell.org/package/engine-io-wai-1.0.3 (codedmart)
06:21:23 <Gurkenglas> The MaybeT monad transformer allows simplificiation of patterns of the form case foo of Nothing -> return Nothing; Just foo' -> return $ bar foo', if that sounds appealing. (In the ideal case, it is replaced by bar foo.)
06:22:04 <xnyhps> I tend to use forM foo $ \foo' -> do { ... }
06:22:12 <Gurkenglas> -(return $ bar foo')+(bar foo')
06:22:12 <benma> Gurkenglas: thanks. yes that sounds appealing ;)
06:22:28 <Hafydd> benma: not that I know of, but there is void :: Functor f => f a -> f ().
06:22:33 <benma> xnyhps: interesting. though i am not sure i like forM with Maybe, as forM kind of has a looping connotation
06:23:12 <dramforever> benma: yes it's looping over zero or one element
06:23:13 <benma> i think skip=return() should go into base
06:23:42 <benma> dramforever: i know. but when reading code, it is good to convey intentions, and reading forM in that context might be a tad confusing
06:23:46 <Gurkenglas> When do you need return ()?
06:23:51 <benma> b/c i usually only use forM with lists in monads
06:24:03 <dramforever> "usually"
06:24:03 <benma> Gurkenglas: when i don't want to do anything in the monad in the Nothing case
06:24:11 <dramforever> time has passed
06:24:18 <dramforever> and it's a whole new world
06:24:26 <Hafydd> Why not just write "return ()"?
06:24:38 <dramforever> :t forM -- remember its type? it's been generalized!
06:24:39 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
06:24:41 <sperrys> why was return called return? to confuse the hell out of programmers from other languages? :P
06:24:52 <benma> Hafydd: because it is longer than "skip" and needs parens when used as a function argument
06:24:58 <Hafydd> Or "pure ()," if you prefer.
06:25:08 <hpc> sperrys: there's an ancient legend
06:25:17 <hpc> sperrys: it goes something like "dude, there's totally a good reason but i forget"
06:25:22 <dramforever> even eta is better than return
06:25:33 <benma> Hafydd: `flip (maybe (return ())) foo bar` vs `flip (maybe skip) foo bar`
06:25:34 <ttt_fff> in discrete time FRP, are there situations where "push" results in exponential time (due to re-evaluating nodes) whereas pull does it only in linear time?
06:25:41 <hpc> sperrys: few believe it to be true ;)
06:25:42 <ski> benma : i've sometimes called that `done'
06:25:59 <ttt_fff> i'm thinking of some hypotheitcall very badly laid out graphs where push can cause certain nodes to re-execute 2 times, 2^2 times, 2^3 times, ... 2^n times
06:26:03 <ttt_fff> whereas in pull, eveyrthing happens just once
06:26:25 <ttt_fff> oh
06:26:28 <ttt_fff> I just came up with a brilliant algorithm
06:26:36 <ttt_fff> to solve this so that push also only takes linear time
06:26:37 <Hafydd> benma: what about "maybe (return ()) bar foo"?
06:26:39 <ttt_fff> #imsosmart
06:26:58 <nshepperd> benma: for_ or traverse_ are the operator you want
06:27:15 <benma> Hafydd: that does not work because bar is a do-block, and that only reads well as the last arg
06:27:35 <benma> Hafydd: i.e. `flip (maybe (return ())) foo $ \foo' -> do { multiline do ... }`
06:27:40 <Hafydd> I see.
06:27:42 <dramforever> :t for_
06:27:43 <lambdabot>     Not in scope: â€˜for_â€™
06:27:43 <lambdabot>     Perhaps you meant one of these:
06:27:43 <lambdabot>       â€˜F.for_â€™ (imported from Data.Foldable),
06:27:48 <dramforever> :t F.for_
06:27:48 <Hafydd> Well, there's always (maybe $ return ()).
06:27:50 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
06:28:02 <dramforever> wait isn't that the last arg?
06:28:08 <dramforever> benma: ^
06:28:26 <benma> Hafydd: I am aware. i just prefer as little parens and $ as possible, and naming `return ()` helps reducing visual noise imho
06:28:43 <Hafydd> But, yes, I suppose that's a reasonable use for it. Still, I'm not sure if it's really warranted to put in the standard library.
06:28:50 <dramforever> :t for_ (Just "x") ?f
06:28:51 <lambdabot>     Not in scope: â€˜for_â€™
06:28:51 <lambdabot>     Perhaps you meant one of these:
06:28:51 <lambdabot>       â€˜F.for_â€™ (imported from Data.Foldable),
06:29:00 <dramforever> :t F.for_ (Just "x") ?f
06:29:02 <lambdabot> (Applicative f, ?f::[Char] -> f b) => f ()
06:29:11 <nshepperd> for_ (Just 5) $ \x -> launchMissiles
06:29:17 <dramforever> benma: hi look there
06:29:22 <dramforever> *here
06:29:53 <benma> i see it, thanks nshepperd and dramforever
06:29:57 <dramforever> =)
06:30:14 <Hafydd> Thanks, nshepperd and dram, forever.
06:30:34 <nshepperd> thorever
06:31:05 <Hafydd> forever $ launchMissiles >> thanks
06:31:07 <dramforever> :t forever -- =P
06:31:09 <lambdabot> Monad m => m a -> m b
06:31:15 <dramforever> :t thanks -- =)
06:31:16 <lambdabot> Not in scope: â€˜thanksâ€™
06:31:32 <Hafydd> @let thanks = error "Too polite."
06:31:33 <lambdabot>  Defined.
06:31:55 <Hafydd> Oh, wait...
06:32:00 <Hafydd> @undefined
06:32:00 <lambdabot> Undefined.
06:32:03 <Hafydd> @let thanks = return ()
06:32:05 <lambdabot>  Defined.
06:32:11 <Hafydd> There's your solution.
06:32:12 <dramforever> benma: lol
06:32:42 <Zemyla> :t finiteBitsMaybe
06:32:42 <lambdabot> Not in scope: â€˜finiteBitsMaybeâ€™
06:33:26 <Zemyla> :t bitSizeMaybe
06:33:27 <lambdabot> Bits a => a -> Maybe Int
06:34:31 <Zemyla> I kind of wish Bits had finiteBitsMaybe :: (Bits a) => a -> Maybe (Dict (FiniteBits a)).
06:35:24 <Zemyla> Then I could possibly use something that implenents Bits in something that requires FiniteBits.
06:43:46 * hackagebot simple-genetic-algorithm-mr 0.4.0.0 - Simple parallel genetic algorithm implementation  https://hackage.haskell.org/package/simple-genetic-algorithm-mr-0.4.0.0 (JeanPhilippeMoresmau)
06:59:08 <f-a> which channel is the right one to ask questions about stack/
06:59:10 <f-a> *?
07:00:10 <pacak> f-a: You can try to ask  them right here.
07:02:35 <f-a> ok, does stack build documentation / build a nice browsable index like cabal does?
07:02:42 <f-a> If so, how to turn the option on?
07:13:47 * hackagebot reddit 0.1.1.0 - Library for interfacing with Reddit's API  https://hackage.haskell.org/package/reddit-0.1.1.0 (Intolerable)
07:13:53 <sgronblo> so does a basic haskell installation always come with some old (or ghc-version-based) version of cabal? and then you install a new version with cabal install cabal-install?
07:14:08 <sgronblo> or is that just haskell-platform?
07:17:17 <lush> hi, what exactly states the fouth Applicative Law (namely: u <*> pure y = pure ($ y) <*> u) again? :')
07:17:30 <lush> s/fouth/fourth
07:18:41 <ddellacosta_> lush, what do you mean by "what exactly states" it?
07:18:55 <lush> ddellacosta_: what does it actually mean/ is for
07:18:56 <ddellacosta_> like, where can you find it?
07:18:59 <ddellacosta_> oh
07:19:21 <lush> I don't get what it is useful for/ what it means
07:20:07 <ddellacosta_> hmm, my understanding is that it gives associativity guarantees, but I'd defer to someone more experienced on this
07:20:30 <ddellacosta_> oh wait, that's the third one according to the typeclassopedia
07:20:34 <nshepperd> in words, I would say 'pure x' commutes with anything under <*>
07:20:36 <ddellacosta_> Interchange
07:20:55 <ddellacosta_> according to the typeclassopedia, "Intuitively, this says that when evaluating the application of an effectful function to a pure argument, the order in which we evaluate the function and its argument doesn't matter. "
07:21:30 <nshepperd> because pure has no 'effects', the order in which you do those non-effects vs an effectful value should make no difference
07:21:34 <lush> so it's similar to a law of commutativity? 
07:22:45 <lush> aaah so you mean because pure shouldn't change anything at all it doesn't matter whether I start with pure or I do it somewhere in between nshepperd ?
07:23:04 <ddellacosta_> lush, if I understand what nshepperd is saying correctly along with what description in the typeclassopedia, sounds like it has to do specifically with applicative as pure is applied
07:23:13 <ddellacosta_> or, what you just said perhaps...
07:23:39 <nshepperd> lush: yes
07:24:14 <lush> nshepperd: aaah ty very much :)
07:24:14 <nshepperd> in terms of effects (thinking IO effects or the like), pure does 'nothing', so it doesn't matter whether you do nothing before or after
07:24:56 <lush> nshepperd: pure (.) <*> u <*> v <*> w = u <*> (v <*> w) (2nd law)  the brackets at the right side of the equation are not mandatory right?
07:25:12 <lush> ... thinking about that law as well ...
07:25:46 <nshepperd> they are, because <*> associates to the left
07:26:17 <nshepperd> a <*> b <*> c <*> d = ((a <*> b) <*> c) <*> d
07:26:22 <lush> aah y
07:26:26 <lush> mhm
07:27:00 <nshepperd> which is so we can do that whole 'f <$> a <*> b <*> c' idiom conveniently
07:27:08 <lush> yy
07:27:18 <lush> but I don't really understand the 2nd law as well I guess
07:28:17 <lush> (.) is only for functions right?
07:28:41 <Guest58445> Hi! Is there a shorter/better way to generate the series [-1,2,-3,4,-5,6,-7,8,-9,10, ...] than zipWith ($) (concat $ repeat [negate, id]) [1..] ?
07:29:02 <nshepperd> lush: remember the type of <*>
07:29:05 <nshepperd> :t (<*>)
07:29:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:29:25 <nshepperd> so whenever we are talking about <*> we are already talking about a function
07:29:57 <lush> aaaaah
07:30:25 <nshepperd> I suppose the 2nd law is saying that <*> is secretly associative, once you take care of threading the values through with consideration of the types
07:30:46 <nagyf> Hi all, I defined a custom type by wrapping a monad: newtype BReader a = BReader (ReaderT BValue Maybe a). I did it to simplify my code. Does this make any sense? I also want to make BReader an instance of the Monad typeclass, but how can i define the (>>=) function?
07:30:50 <lush> it means: composing u (I mean (.) <$> u with this) and then applying v and w is the same as first applying v and w and then apply that to u
07:30:57 <lush> hehe associativity was my first guess
07:31:03 <lush> but I wasn't sure.. :')
07:31:06 <lush> ty very much :)
07:31:31 <sgronblo> hmm yeah haskell platform does seem to come with cabal
07:32:14 <Hafydd> > zipWith (*) [1..] (iterate negate 1) -- Guest33065 
07:32:14 <nshepperd> I think that there's really a prettier way to express the applicative laws though
07:32:16 <lambdabot>  [1,-2,3,-4,5,-6,7,-8,9,-10,11,-12,13,-14,15,-16,17,-18,19,-20,21,-22,23,-24,...
07:32:45 <Hafydd> Er... never mind, they fucked off.
07:32:57 <nshepperd> in terms of (**) = liftA2 (,) :: f a -> f b -> f (a,b)
07:33:13 <lush> Hafydd: although you have to map negate over that again that way
07:33:39 <Hafydd> zipWith (*) [1..] (iterate negate $ -1), then.
07:34:50 <nshepperd> instead of the interchange law: u  pure y = swap <$> (pure y  u)
07:34:59 <nshepperd> oh dear
07:35:23 <Hafydd> > iterate (\x -> -x - signum x) $ -1
07:35:25 <lambdabot>  [-1,2,-3,4,-5,6,-7,8,-9,10,-11,12,-13,14,-15,16,-17,18,-19,20,-21,22,-23,24,...
07:35:44 <nshepperd> instead of the interchange law: u ** pure y = swap <$> (pure y ** u)
07:36:07 <Hafydd> Or indeed:
07:36:09 <Hafydd> > concat . transpose $ [[-1,-3..],[2,4..]]
07:36:11 <lambdabot>  [-1,2,-3,4,-5,6,-7,8,-9,10,-11,12,-13,14,-15,16,-17,18,-19,20,-21,22,-23,24,...
07:36:33 <nshepperd> instead of the associativity law: u ** (v ** w) = assoc <$> ((u ** v) ** w)
07:37:44 <hackrilege> can I make a data type deriving from Data.Map which inherits its instances?
07:38:31 <lush> nshepperd: I'll think about it, ty :)
07:38:47 <hackrilege> I wish to hide some of the functionality provided by Data.Map as it is not relevant to my datatype
07:38:48 * hackagebot hmenu 0.1.0.1 - CLI fuzzy finder and launcher  https://hackage.haskell.org/package/hmenu-0.1.0.1 (sulami)
07:39:23 <sgronblo> wait so now with stack, you dont need any haskell platforms or anything like that?
07:40:23 <sgronblo> you can just choose a umm resolver or whatever you call it and stack setup will install ghc for you?
07:41:07 <hackrilege> does stack work on android?
07:41:35 <ski> hackrilege : you can make `newtype MyType = MkMyType (Data.Map MyKey MyValue) deriving (Eq,Show)', if you enable the extension `GeneralizedNewtypeDeriving'
07:43:14 <ski> hackrilege : add the type classes you want to derive for `MyType' in the `deriving' clause
07:43:56 <hackrilege> thanks ski: can i simply export the desired functions exposed by Data.Map after module MyType (exportsGoHere) where...
07:44:24 <hackrilege> not after sorry, using...
07:44:39 <ski> (also, you're not making a datatype deriving from `Data.Map'. you're deriving the requested type class instances for your new data type, in this case by essentially reusing the already existing ones for the implementation/representation type `Data.Map MyKey MyValue')
07:45:10 <unclechu> hi there. there is any piping in haskell for function? like equivalent for `succ 5` as `5 |> succ`?
07:45:13 <hackrilege> thats perfect
07:45:42 <srhb> unclechu: It's not defined in the standard library, but often & is used
07:45:48 <ski> hackrilege : "can i simply export the desired functions .." -- no, you have to rewrap them
07:46:08 <hackrilege> > 5 & succ
07:46:09 <srhb> > let (&) = flip ($) in 5 & succ -- unclechu
07:46:10 <lambdabot>  6
07:46:11 <lambdabot>  6
07:46:17 <srhb> Oh, it's actually defined in lambdabot.
07:46:46 <hackrilege> flip & ?
07:46:54 <srhb> > succ $ 6
07:46:56 <lambdabot>  7
07:47:07 <ski> @type (&)
07:47:08 <lambdabot> a -> (a -> b) -> b
07:47:17 <unclechu> srhb: TY, it works for me
07:47:18 <srhb> hackrilege: Function application with the arguments flipped.
07:47:36 <srhb> hackrilege: ie. argument before function. :)
07:47:37 <hackrilege> but the functions defined in the instances will be automatically exported. ok im good to go i think. thanks again ski:
07:47:41 <ski>   x & f = f x
07:47:50 <ski> hackrilege : np
07:49:02 <srhb> unclechu: Apparently it IS in the standard library, in Data.Function.
07:49:02 <hackrilege> haha, no i misread flip ($), thought he write flip (&)... doh
07:50:03 <hackrilege> :t (&.$)
07:50:05 <lambdabot> Not in scope: â€˜&.$â€™
07:50:11 <hackrilege> :t (& . $)
07:50:12 <lambdabot> parse error on input â€˜.â€™
07:50:21 <srhb> hackrilege: You can't do that in a section.
07:50:23 <hackrilege> :t ((&) . ($))
07:50:24 <lambdabot> (a -> b1) -> ((a -> b1) -> b) -> b
07:50:27 <ski> @type (&) . ($)
07:50:28 <lambdabot> (a -> b1) -> ((a -> b1) -> b) -> b
07:51:14 <unclechu> how i can apply two maps in haskell? something like this: `map (-1) (map (+5) [1,2,3])`?
07:51:39 <hpc> > map (subtract 1) . map (+ 5) $ [1,2,3]
07:51:40 <lambdabot>  [5,6,7]
07:51:54 <srhb> It's also identical to map ((-1) . (+5))
07:52:01 <hpc> using (.) makes the composition nicer, and (-) has dopey parsing
07:52:07 <srhb> Oh woops
07:52:09 <srhb> Yes.
07:52:10 <hpc> due to very good reasons
07:52:21 <hackrilege> > map (-1+5) [1,2,3]
07:52:23 <lambdabot>      Could not deduce (Num a0)
07:52:23 <lambdabot>      from the context (Num a, Num (a -> b))
07:52:23 <lambdabot>        bound by the inferred type for â€˜e_115123â€™:
07:52:30 <unclechu> srhb: (+5) is function, but (-5) it nor?
07:52:34 <hackrilege> > map (\a->a-1+5) [1,2,3]
07:52:35 <lambdabot>  [5,6,7]
07:52:37 * unclechu not*
07:52:38 <srhb> unclechu: Correct
07:52:48 <srhb> unclechu: (-5) is the number negative 5.
07:52:52 <hackrilege> > (-1) 1
07:52:53 <lambdabot>      Could not deduce (Num a0)
07:52:53 <lambdabot>      from the context (Num a, Num (a -> t))
07:52:53 <lambdabot>        bound by the inferred type for â€˜e_111â€™: (Num a, Num (a -> t)) => t
07:52:56 <hackrilege> > (\a->a-1) 1
07:52:58 <lambdabot>  0
07:53:43 <hackrilege> > -1
07:53:51 <unclechu> this pipes solution doesn't work in this case: `[1,2,3] & map (+5) & map (subtract -1)`
07:53:59 <lambdabot>  -1
07:54:14 <hackrilege> (-1) + 1
07:54:19 <unclechu> oh, again
07:54:34 <unclechu> not it works :) `[1,2,3] & map (+5) & map (subtract 1)`
07:54:38 <isBEKaml> OHHAI, is Data.Text interchangeable with [Char] in ghc 7.8?
07:54:54 <hackrilege> > [1,2,3] & (map (+5) . map (subtract -1))
07:54:58 <lambdabot>      No instance for (Typeable a0)
07:55:02 <lambdabot>        arising from a use of â€˜show_M47097871972262254789046â€™
07:55:04 <lambdabot>      In the expression:
07:55:06 <srhb> > [1,2,3] & map (+5) & map (subtract 1)
07:55:07 <lambdabot>  [5,6,7]
07:55:29 <srhb> isBEKaml: I don't know what you mean by that question. String and Text are different types.
07:55:35 <srhb> isBEKaml: In _any_ version of GHC.
07:55:46 <hackrilege> > [1,2,3] & map (+5) & map (subtract (-1))
07:55:48 <lambdabot>  [7,8,9]
07:56:27 <hackrilege> what is a lens?
07:56:31 <srhb> isBEKaml: You can overload string literals with -XOverloadedStrings and in 7.8 there are probably a lot of functions that were specialized to lists that now work on Text, too.
07:57:06 <srhb> hackrilege: The answer to that question is not short and is probably best researched in a number of articles. :) You can see the github repo for lens for some starting points.
07:57:10 <hackrilege> isBEKaml: i think you shoud use pack and unpack
07:57:19 <hackrilege> :t Data.Text.pack
07:57:20 <lambdabot> String -> Data.Text.Internal.Text
07:57:59 <hackrilege> srhb, there is not definition?
07:58:08 <isBEKaml> hackrilege: right, that's what I was looking for
07:58:30 <hackrilege> woot!
07:58:53 <ChristianS> isBEKaml: Data.Text and [Char] are totally non-interchangeable, but Data.Text exports most of the functions that also exist for lists, as well as various other ones that are useful for texts (strings)
08:00:08 <srhb> hackrilege: I don't know of a single short definition, but it will involve something about functors. :P
08:00:35 <hackrilege> ChristianS: its easy to construct Data.Text type variables from strings, and often people need only one section of the code to use the functions of Data.Text, e.g. if they want to do some encyption. but really they work with String in their own code.
08:01:15 <srhb> hackrilege: we could also say that a lens is something isomorphic to data Lens a b = L (a -> b) (b -> a -> a) -- but I'm not sure how much intuition that grants.
08:01:22 <srhb> ie. read the articles. :-)
08:01:37 <srhb> Hm actually that definition is probably not enough without getters and setters...
08:01:39 * srhb is not an expert
08:02:02 <hackrilege> isBEKaml: watch out for strict and lazy bytestrings, iv had libraries where I had to pack as lazy and unpack from strict. see https://hackage.haskell.org/package/text-1.2.1.1/docs/Data-Text-Lazy.html
08:03:58 <isBEKaml> hackrilege: yes, I'm aware of D.T.L -- thanks. Anyway, I'm simply writing some throwaway scripts (inspired by the recent upload to hackage for reddit API) :-)
08:05:30 <hackrilege> srhb: im no expert either! I think we came up with a good definition of functors the other day, mappings between categories which are collections of objects and associative arrows including the identity which are pairs of domain and codomain values which are in the collection of objects
08:06:43 <hackrilege> isBEKaml: are you using conduit-extra or http-simple?
08:07:12 <srhb> hackrilege: This answer is useful for a minimalist definition: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285
08:07:35 <hackrilege> thanks!
08:08:13 <hackrilege> im not sure if i should use Data.Map or learn what is a lens...
08:08:31 <srhb> hackrilege: They are completely orthogonal.
08:08:50 * hackagebot hedis-config 0.0.2 - Easy trivial configuration for Redis  https://hackage.haskell.org/package/hedis-config-0.0.2 (AlekseyUymanov)
08:09:10 <hackrilege> i wish to efficiently traverse and construct a datatype
08:09:35 <srhb> Lens does give you some nice ways to traverse structures.
08:09:41 <srhb> Data.Map is a key/value store.
08:09:41 <isBEKaml> hackrilege: nothing on my own by way of dependencies. that hackage library had a boatload of dependencies already that I'm simply playing with its types. :-)
08:10:24 <hackrilege> which library?
08:10:30 <isBEKaml> reddit
08:10:51 <isBEKaml> it was _literally_ just uploaded less than an hour ago
08:11:04 <isBEKaml> hackagebot was good enough to report it here :P
08:11:16 <srhb> isBEKaml: Nah, 0.1.0.0 is from july 21st. :)
08:11:34 <isBEKaml> srhb: new version then :-)
08:11:38 <srhb> Indeed.
08:12:46 <isBEKaml> srhb: are you the author?
08:12:56 <srhb> isBEKaml: No, Intolerable is, who is not currently in the channel.
08:13:20 <isBEKaml> srhb: Ah, I thought you had a different nick on IRC than on hackage 
08:13:34 <srhb> Some do, some don't.
08:14:38 <srhb> isBEKaml: I'm only guessing it's the same person. :)
08:14:55 <hackrilege> it is indeed built on conduit through http-client
08:25:06 <isBEKaml> hackrilege: indeed
08:39:41 <magistr> wtf existential type?
08:50:42 <sperrys> > map print [1..5]
08:50:44 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>]
08:50:59 <sperrys> how do I print them?
08:51:03 <ralu> > sequence $ map print [1..5]
08:51:04 <lambdabot>  <IO [()]>
08:51:31 <suppi> sequence :: [IO a] -> IO [a]
08:51:37 <ralu> > mapM print [1..5]
08:51:39 <lambdabot>  <IO [()]>
08:51:52 <Hafydd> <[()]>
08:51:56 <suppi> mapM = sequence . map
08:52:21 <suppi> no i'm not a bot.
08:52:24 <sperrys> why doesnt jusy map work
08:52:31 <sperrys> just
08:52:45 <ralu> because haskell is lazy
08:53:07 <suppi> and because map print [1..5] :: [IO a]
08:53:13 <ralu> it is just list of computaion
08:53:18 <suppi> it is not an IO action, it is a list of IO actions.
08:53:39 <sperrys> hmm
08:53:44 <Hafydd> A list of IO actions doesn't encode enough information to say how to execute them (in what order?).
08:53:53 * hackagebot pipes 4.1.6 - Compositional pipelines  https://hackage.haskell.org/package/pipes-4.1.6 (GabrielGonzalez)
08:54:10 <ralu> you have to call seqence on list
08:54:20 <Hafydd> i.e. there could be multiple ways of encoding [IO a] -> IO [a].
08:54:31 <srhb> The misconception probably arises from lists having a natural order, no matter what you want to do with them. But the type system is clear on this -- IO Something is an IO action that can be executed, nothing else.
08:56:02 <magistr> > data ShowObj = forall a. Show a => ShowObj a
08:56:03 <lambdabot>  <hint>:1:1: parse error on input â€˜dataâ€™
08:56:20 <ralu> > map print [1..]
08:56:22 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO...
08:56:31 <sperrys> I am not sure what you all are even talking about. that should apply print to all the elements in a list, no?
08:56:38 <magistr> > data ShowObj = exists a. Show a => ShowObj a
08:56:39 <srhb> sperrys: That it does
08:56:40 <lambdabot>  <hint>:1:1: parse error on input â€˜dataâ€™
08:56:44 <nullvoid8> magistr: I think lambdabot wants "let data ..." or something like that
08:56:49 <Hafydd> magistr: you need to use @let for that, if at all.
08:56:54 <srhb> sperrys: But that just gives you a list of IO actions. And a list of IO actions is _not_ an IO action.
08:57:03 <srhb> sperrys: And only IO actions are actually executed by the runtime.
08:57:36 <nullvoid8> print is not a function that prints an thing, it is a function that returns an action that prints a thing
08:57:42 <srhb> sperrys: In other words there's a distinction betweem applying a function to something, producing an IO action, and actually _running_ the IO action.
08:58:21 <srhb> In this case, we have sequence which produces the (logical) IO action from a list of IO actions. Namely by executing each of them in order.
08:58:39 <srhb> (or, by "sequencing" them!)
08:59:04 <Hafydd> That isn't the "logical" IO action for a list of actions.
08:59:14 <ralu> > sequence $ take 5 $ map print [1..]
08:59:15 <lambdabot>  <IO [()]>
08:59:15 <Hafydd> You could execute them in parallel and discard the results, for example.
08:59:25 <catgocat> What is the difference between floor and truncate?
08:59:35 <srhb> Hafydd: OK, that part is subjective, admittedly.
09:00:00 <Sindriava> sperrys: print is a function that takes a string and returns an IO action. So if you map print over a list of strings, you get a list of IO actions, because `map` changes contents of the list, not it's structure
09:00:04 <Hafydd> Or indeed you could execute at most one of them, nondeterministically.
09:00:26 <srhb> Hafydd: Right. It's not an important point.
09:00:34 <Hafydd> Isn't it?
09:00:52 <Hafydd> The question was about why [IO a] isn't automatically taken to mean sequencing.
09:01:06 <magistr> ok, what nice book to learn type theory?
09:01:43 <catgocat> What is the difference between floor and truncate?
09:01:46 <srhb> Hafydd: To which the answer of which transformation is the right one isn't actually directly related. The answer is: "Because it is not an IO action" not "Because which is the natural way to make this into an IO action" :)
09:02:26 <Hafydd> catgocat: the behaviour for negative numbers is often a distinction between those notions, but that's a matter of definition. Which floor and truncate are you referring to?
09:02:33 <srhb> But I agree that I should have said that sequence is _one_ logical way to construct an IO action from a list of IO actions
09:02:39 <catgocat> Hafydd prelude's
09:02:55 <nullvoid8> > (floor -4.6, truncate -4.6)
09:02:56 <lambdabot>      No instance for (Typeable a0)
09:02:56 <lambdabot>        arising from a use of â€˜show_M775302198858510979510152â€™
09:02:56 <lambdabot>      In the expression:
09:02:59 <Hafydd> Oh, yes.
09:03:03 <Cale> magistr: Types and Programming Languages by Pierce is good
09:03:08 <nullvoid8> > (floor (-4.6), truncate (-4.6))
09:03:09 <lambdabot>  (-5,-4)
09:03:11 <catgocat> > floor (-4.6)
09:03:12 <lambdabot>  -5
09:03:18 <catgocat> > truncate (-4.6)
09:03:20 <lambdabot>  -4
09:03:23 <catgocat> what
09:03:37 <catgocat> why does floor return -5
09:03:40 <nullvoid8> catgocat: go read this http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#v:truncate
09:03:51 <Cale> catgocat: truncate rounds toward 0, floor rounds down
09:03:51 <ralu> rounds to lower integer
09:04:16 <catgocat> oh ok
09:04:17 <catgocat> got it
09:04:18 <Cale> The floor of a real number is the greatest integer less than or equal to it.
09:04:30 <magistr> Cale, may i must switch language to coq?
09:04:35 <Cale> magistr: hm?
09:05:06 <magistr> Cale, to understand existential types
09:05:12 <Cale> magistr: The stuff in TaPL applies to most typed functional programming languages. The book uses ML for implementation of some things, but for the most part is language agnostic.
09:05:22 <Cale> To understand existential types?
09:05:36 <Cale> I dunno, what do you want to know about them? GHC has existential types.
09:06:25 <Cale> If you want to understand first class existential quantifiers in types, then yeah, Coq has that, so just learning a bit of Coq might be one way to go.
09:06:49 <Cale> But if you just want to understand what you can do with existential types and how they work in GHC Haskell, you shouldn't have to go that far.
09:07:14 <Cale> ... okay
09:08:12 <ralu> what about idris?
09:08:36 <ralu> i was thinking about learing idris
09:09:42 <p0a> Hello 
09:10:01 <ungov> Hi, I'm starting a website, and I'm planning to use acid-state as my db. Is that a good idea? Is someone here using it?
09:10:19 <p0a> This may be a silly question, but what kind of optimization is going on when I create a binary tree and start inserting stuff in it? (the insert function creates new copies of the previous tree)
09:11:05 <drewbert> p0a: ^ I've often wondered that.
09:11:35 <p0a> oh :) time to find out I hope 
09:11:36 <nullvoid8> p0a: at minimum, every node in the tree that's not a direct ancestor of the new node can be "shared"
09:13:09 <p0a> oh that actually happens?
09:13:37 <nullvoid8> afaik, it's a corner stone of efficent persistant/immutable data structures
09:13:41 <ralu> i think that it is at least lazily coped
09:14:10 <nullvoid8> the fact that anything not directly modified can just point to the old version
09:14:23 <muesli4> Why are there only unboxed arrays for specific low level types? Wouldn't it be possible with strict members and a single constructor (or multiple constructors, if you're willing to waste space for a binary union)?
09:14:35 <p0a> does it depend on the algorithm of insert?
09:14:58 <srhb> ungov: I've used it.
09:15:01 <nullvoid8> p0a: probably
09:15:20 <p0a> so a naive implementation most likely doesn't get this sort of optimization?
09:15:34 <nullvoid8> p0a: but I also imagine it's hard to write one that doesn't do share
09:15:38 <Hafydd> muesli4: I don't know, but I'd presume it has something to do with bottom.
09:16:49 <c_wraith> muesli4: it would violate laziness
09:16:55 <muesli4> Hafydd: Well, that should only be possible with laziness.
09:17:01 <p0a> What of this code? (standard ML not haskell unfortunately), I just want to demonstrate insert though, http://lpaste.net/137799
09:17:14 <c_wraith> muesli4: if you remove the constructor, you remove the possibility of it being unevaluated
09:17:15 <p0a> this is a sorted insert
09:17:30 <ralu> modifiying tree is actaualy stacking bunch of functions lazily
09:17:35 <muesli4> c_wraith: Yes, but what if I specify that I want no laziness for a type. Shouldn't it then be possible to use them in a unboxed array?
09:17:45 <p0a>  I see that the binary tree below the newly inserted node can be shared, what about what's above it?
09:18:08 <c_wraith> muesli4: If you're going to do that, you might as well just make it a newtype wrapper, and then automatically derive Unbox
09:18:34 <nullvoid8> p0a: the chain of ancestor nodes can't be shared, but any nth-cousins-mth-removed can be
09:19:10 <nullvoid8> because the parent has to be "modified" to point to the new node, and the grandparent has to point to that and so on
09:19:18 <p0a> ah
09:19:23 <c_wraith> muesli4: (you should generally use vector instead of array for many reasons, but simplicity of making something an unboxable type is on the list)
09:19:24 <p0a> so there is an edge case where there is no optimization
09:19:45 <catgocat> What is the difference between
09:19:48 <p0a> when the newly inserted node is always the tip of the tree
09:19:50 <catgocat> RealFrac and Floating?
09:19:52 <ralu> even non optimised version works fine
09:19:57 <nullvoid8> well yes, in the edge case of "there's nothing to share anyway"
09:20:01 <catgocat> What is the difference between RealFrac and Floating?
09:20:11 <p0a> yeah true 
09:21:04 <nullvoid8> catgocat: "Floating: Trigonometric and hyperbolic functions and related functions." "RealFrac: Extracting components of fractions."
09:21:13 <nullvoid8> straight from the docs on hackage
09:21:40 <muesli4> c_wraith: I experimented with pure growing arrays and I find that limitation annyoing, since I can't provide instances of type classes which take parameters of a higher kind (e.g. Functor, Foldable).
09:22:42 <nkaretnikov> ungov: iirc, hackage-server uses acid-state as well as safecopy
09:22:54 <c_wraith> muesli4: Functor et al provide operations that must work with any type.  Unboxable things are explicitly the subset of types which have an efficient unboxed representation.  Of course they're not compatible.
09:23:25 <c_wraith> muesli4: You can't unbox something like String, for instance.  It's just not possible.
09:23:42 <nullvoid8> catgocat: so a "Floating a" is an "a" that it's sensible to apply trig functions to, and a "RealFrac a" is an "a" that can be viewed has having a numerator and a denominator
09:24:03 <catgocat> how can those be different
09:24:09 <catgocat> oh, wait
09:24:11 <catgocat> for example pi 
09:24:16 <catgocat> pi can't be a realFrac
09:24:17 <nullvoid8> yup
09:24:48 <nullvoid8> well, it can, but in any number representaions in normal haskell
09:25:06 <nullvoid8> *not in any
09:26:01 <catgocat> nullvoid8 if pi is not a realfrac, how does it not break when using truncate?
09:26:03 <catgocat> :t truncate
09:26:04 <lambdabot> (Integral b, RealFrac a) => a -> b
09:26:31 <c_wraith> catgocat: it probably defaults it to Double, which is in both
09:26:46 <catgocat> so give me an example of a realfrac that isn't floating
09:26:51 <catgocat> or vice-versa
09:26:51 <c_wraith> > truncate (pi :: Rational) 
09:26:53 <lambdabot>      Could not deduce (Floating Rational) arising from a use of â€˜piâ€™
09:26:53 <lambdabot>      from the context (Integral b)
09:26:53 <lambdabot>        bound by the inferred type of it :: Integral b => b at Top level
09:27:12 <c_wraith> Pi is smarter than I thought. :)
09:27:15 <nullvoid8> c_wraith: actually, Double isn't in both, but CDouble is
09:27:32 <c_wraith> still, Rational shouldn't be floating
09:27:43 <catgocat> can anyone give me an example of a realfrac that isn't floating
09:28:03 <c_wraith> :t 5 % 3
09:28:04 <lambdabot> Integral a => Ratio a
09:28:16 <c_wraith> > floor (5 % 3)
09:28:18 <lambdabot>  1
09:28:26 <nullvoid8> catgocat: just compare the instance lists here http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:RealFrac
09:28:31 <c_wraith> > sin (5 % 3)
09:28:33 <lambdabot>      No instance for (Integral a0)
09:28:33 <lambdabot>        arising from a use of â€˜show_M301902377070126145110605â€™
09:28:33 <lambdabot>      The type variable â€˜a0â€™ is ambiguous
09:28:36 <nullvoid8> Floating is directly above
09:28:55 <c_wraith> catgocat: So..  Ratio is an example of a type which has a RealFrac instance but not a Floating instance
09:29:14 <catgocat> ok
09:31:15 <nullvoid8> c_wraith: I'm confused now. Double is a RealFloat, which implys Double is RealFrac, but that's not shown in the hackage docs for base-4.8.1.0
09:31:43 <c_wraith> nullvoid8: don't ask me about haddock. :)
09:34:28 <irctc044> I have the phpinfo of one website ( http://lariya3.com/test/phpinfo.php ) what can i do with that ?
09:34:42 <bitemyapp> irctc044: this is #haskell not #hackell
09:35:05 <irctc044> my fault 
09:36:30 <michaelt> nullvoid8: yeah, the haddocks do skip a bunch of superordinate classes in there, e.g. Real, Fractional, RealFrac
09:36:48 <nullvoid8> michaelt: well that's annoying :/
09:37:35 <michaelt> nullvoid8: yes, there don't seem to be all that many, really.
09:38:22 <nullvoid8> p0a: I was bored, so I annoted your lpaste with what I tihnk is a working haskell version
09:38:43 <michaelt> nullvoid8: you know about :i Double inside ghci I take it
09:38:46 <p0a> oh interesting
09:39:09 <nullvoid8> michaelt: yeah, but that requires opening ghci, and it's not as pretty :P
09:39:33 <nullvoid8> also, my ghci is 7.8.4
09:39:43 * michaelt can't imagine not having ghci open ...
09:40:08 <p0a> sweet code
09:40:20 <nullvoid8> michaelt: I'm windows atm, and not developing anything, so...
09:40:20 <p0a> which text editor did you use?
09:40:44 <nullvoid8> p0a: I just clicked the "Annotate" button
09:40:51 <nullvoid8> and used lots of space bar
09:41:22 <p0a> welp, I was going to use that as defense for my own badly formatted code.
09:43:08 <p0a> yeah the type definition or whatsitcalled is missing from my ML code, but otherwise they're pretty similar 
09:43:39 <Cale> Which code?
09:43:50 <p0a> in fact I'm reading a book that uses ML and it feels like learning haskell better now
09:43:51 <nullvoid8> Cale: http://lpaste.net/137799
09:44:23 <nullvoid8> Cale: he was asking about how persistant/immutable data structures were optomised
09:44:35 <Cale> ralu: Oh, missed your question. Yeah, any of the dependently typed languages will pretty much get you first class existentials
09:45:22 <nullvoid8> specifically inserting into a binary tree and how it doesn't just copy the whole thing
09:51:20 <p0a> cu, thanks!
09:53:02 <indiagreen> > floor (-1.4)
09:53:03 <lambdabot>  -2
09:53:08 <indiagreen> > truncate (-1.4)
09:53:09 <lambdabot>  -1
10:08:11 <JamesJRH> Hi.
10:08:58 <slowbait> Hi
10:09:49 <JamesJRH> Can a foreign function interface pass first-class higher-order pure functions between pure-functional languages?
10:12:22 <nullvoid8> JamesJRH: check out [foreign import ccall "wrapper"]
10:13:03 <nullvoid8> oh wait, no I don't think you can do it polymorphically (whcih is what you meant?)
10:13:36 <JamesJRH> Like say I want to combine some Haskell, Erlang, Scala, Lisp, Rust, etc. code.
10:14:12 <nullvoid8> the answer is probably "yes if you beat it enough"
10:14:20 <JamesJRH> Heh.
10:15:21 <geekosaur> the problem there is nobody guarantees the same representation
10:15:48 <geekosaur> and the ones that do (e.g. GLR) aren't polymorphic
10:15:53 <geekosaur> er CLR
10:15:54 <nullvoid8> technically, you could probably make a ffi directly for your compiler (and the compiler of the other language) in practice, you'd be abusing the c ffi of both sides
10:15:59 <JamesJRH> If a pure function is implemented in one language then, because it's pure, it should work the same no matter what language it is defined in and no matter what machine/core you run it on. This is also related to parallelisation of pure functions.
10:16:51 <nullvoid8> have you considered more of a server-client architecture where you pass an identifier of some kind and the function arguments?
10:17:11 <geekosaur> JamesJRH, so a list is always represented the same way in all languages on that hardware?
10:17:34 <JamesJRH> nullvoid8: What if you want to pass a function though? I.e. higher-order.
10:17:51 <geekosaur> such that the code that works with that list can be used with any of them
10:18:40 <nullvoid8> again, make it a limited selection of higher order functions, and use an identifier of sme sort to pick one
10:18:46 <JamesJRH> geekosaur: I guess that evaluation strategy is totally messed-up. :-)
10:18:55 * hackagebot verbosity 0.2.0.0 - Simple enum that encodes application verbosity.  https://hackage.haskell.org/package/verbosity-0.2.0.0 (PeterTrsko)
10:19:56 <nullvoid8> this is similar to what cloudHaskell is doing right? so just within one language is a tricky problem
10:20:20 <nullvoid8> going between languages probably has exponetially more problems
10:20:34 <JamesJRH> nullvoid8: One language isn't a problem at all?
10:21:20 <nullvoid8> when you're trying to have intercommunicating gc'd processes on (possibly) different machines share runnable code, yeah it's a problem
10:21:40 <JamesJRH> Oh, okay. Forget the different mahcines thing.
10:22:01 <JamesJRH> That was a related thing that doesn't interest me for this question.
10:22:05 <nullvoid8> even then there's a question of who owns what in a functions closure
10:22:27 <JamesJRH> I'm more thinking about avoiding rewriting functions in every language.
10:22:51 <nullvoid8> though do note, most of what I'm saying is off the top of my head, I am by no means an expert, just an interested party
10:23:31 <JamesJRH> Just because people have their preferred language, so wouldn't it be nice if programmes could more easily be written as a hybrid of languages.
10:24:32 <nullvoid8> different languages make different choices about their underlying structures, which translates directly to different code, that is difficult (I'd imagine) to machine translate, Since compilation is not One-to-One
10:26:07 <nullvoid8> I suppose you could get away with e.g. "this is a Tree of <Opaque Rust Data>, sort it using <Opaque Rust functon>"
10:26:19 <JamesJRH> So if there's an existing pure function written in Rust that's really well-written and reliable, and one of its arguments is another function, I should still be able to use that in Haskell and pass a Haskell pure function for that argument. There should be no need to rewrite the whole thing again if it's already good.
10:26:19 <nullvoid8> but yes, that would be nice
10:26:52 <JamesJRH> And vice versa, and etc. for other languages.
10:27:14 <JamesJRH> (I don't know Rust, btw.; I just picked it as an example.)
10:27:31 <nullvoid8> neither do I, it's a just a nice name to type :P
10:27:52 <JamesJRH> Heh.
10:28:38 <nullvoid8> you could totally compile Rust to Haskell code and vice versa. but that's not a solution at all
10:29:10 <JamesJRH> Haskell is the only language I know of the ones that are pure-functional, i.e. encourage/enforce the pure-functional paradigm.
10:29:29 <JamesJRH> That might be a solution, actually!
10:29:30 <nullvoid8> pretty much the same here
10:29:58 <indiagreen> what's a good workflow for developing several libraries which depend on each other in the same sandbox? I'm clearly doing something wrong because I keep getting mistakes like â€œPerhaps you haven't installed the profiling librariesâ€, other errors which only go away when I unregister previous versions of packages manually, etc
10:30:16 <nullvoid8> not really, you'd just have compiled code that written in a style that exploits Rust's tradeoffs into unidomatic haskell code
10:30:28 <indiagreen> JamesJRH++
10:30:42 <JamesJRH> nullvoid8: Be doing that, you solve the evaluation strategy problem. If Rust is compiled to Haskell then it's Haskell evaluation strategy that is in control.
10:31:15 <nullvoid8> sure, but it's less compilation and more automagic source translation (I'm a litlle imprecise with my terminoldy at times)
10:31:31 <nullvoid8> ... and my spelling apparently
10:31:55 <nullvoid8> indiagreen: I'm biased, but apply Nix(OS) ?
10:34:41 <JamesJRH> nullvoid8: Yeah, I don't really think that there's a â€˜realâ€™ difference between â€˜compilationâ€™ and â€˜translationâ€™. I'd say that compilation is translation from a language that's considered to be higher-level to one that's considered lower-level.
10:35:18 <JamesJRH> Heh, NixOS ftw.!
10:36:25 <fvgvxmpv1> Nix++
10:36:54 <fvgvxmpv1> I havenÂ´t seen another "clean" solution to that problem yet.
10:37:39 <JamesJRH> Hmm.
10:37:44 <slowbait> What's  NixOS?
10:37:49 <JamesJRH> I have an idea.
10:38:33 <JamesJRH> slowbait: A GNU+Linux distribution that uses Nix, the purely functional package manager.
10:38:34 <nullvoid8> slowbait: it's an OS based on Nix, a purely fucntional package manager (http://nixos.org/)
10:38:44 <JamesJRH> :-)
10:38:48 <fvgvxmpv1> slowbait: nix is a package manager that uses a functional dsl to describe how to build packages and encourages "purity" (building a package has no side effects). NixOS is a GNU/Linux shipping with nix
10:38:54 <JamesJRH> Lol.
10:38:58 <nullvoid8> :D
10:39:09 <fvgvxmpv1> ^.^
10:40:15 <slowbait> Should I take a look?
10:40:38 <JamesJRH> Yeah.
10:40:52 <nullvoid8> slowbait: if you feel like playing with an experiental OS, sure
10:41:20 <JamesJRH> nullvoid8: I'm using it currently as my main OS.
10:41:39 <nullvoid8> JamesJRH: I never said you couldn't :)
10:41:47 <tmtwd> would haskell need a separate type for sets?
10:41:53 <tmtwd> or would it just be a list?
10:41:59 <fvgvxmpv1> tmtwd, there is Data.Set
10:42:07 <tmtwd> I see
10:42:12 <nullvoid8> tmtwd: you /could/ uses lists as sets
10:42:13 <fvgvxmpv1> and there a Set operations (nub) on Lists
10:42:49 <JamesJRH> nullvoid8, slowbait: It is stable, it just doesn't have peripheral package support for lesser-known projects, but of course, that is improving all of the time.
10:42:52 <nullvoid8> but Data.Set encapsulates it so you can't build an incorrect set (multiple copies of one value)
10:42:52 <geekosaur> not very efficient though, even if you replace Data.List.nub with a more efficient implementation
10:43:22 <tmtwd> I'm building some set functions from scratch
10:43:38 <tmtwd> I guess I should just use a normal list to make it easier
10:43:55 <slowbait> Well, I'll take a look :)
10:43:55 <fvgvxmpv1> tmtwd, as an exercise?
10:43:59 <tmtwd> what would data Set look like
10:44:11 <tmtwd> fvgvxmpv1, yes, I'm trying to learn haskell
10:44:16 <tmtwd> also set theory
10:44:29 <ski> tmtwd : lists is one simple way to implement finite (sub)sets
10:44:35 <fvgvxmpv1> then implementing your exercises to use lists wonÂ´t hurt
10:45:35 <tmtwd> what would data Set look like out of curiosity?
10:45:40 <nullvoid8> tmtwd: (spoilers) Data.Set.Set  is esentially an ordered Binary Tree iirc
10:46:23 <fvgvxmpv1> (which is why Data.Set has Ord constraints all over the place)
10:47:01 <nullvoid8> tmtwd: data Set a    = Bin Size a (Set a) (Set a)    |    Tip   -- edited for easier viewing
10:47:29 <nullvoid8> where "type Size = Int"
10:47:48 <JamesJRH> nullvoid8, geekosaur: Anyway, those problems that you mentioned aren't even specific to higher-order functions. Just calling a foreign function with common types such as numbers, list, and strings is going to have that problem. I've never used the FFI, but surely it can do this.
10:48:45 <nullvoid8> JamesJRH: well sure, but in everycase there has to be common format decied upon, which is usually "what ever is close in c land"
10:49:00 <JamesJRH> So if that problem is already solved then I have an idea as to how it could work for higher-order functions.
10:49:16 <geekosaur> ...
10:49:23 <geekosaur> it's not even remotely solved
10:49:28 <JamesJRH> It's not so easy to explain without a diagram though. :-/
10:49:30 <nullvoid8> you know, this amounts to wanting a JVM for all pure functional languages
10:49:42 <nullvoid8> or just a VM I suppose
10:49:42 <JamesJRH> Does it?
10:49:54 <JamesJRH> Interesting.
10:50:00 <JamesJRH> What about LLVM?
10:50:15 <JamesJRH> geekosaur: What is the FFI, then?
10:50:19 <geekosaur> in particular, haskell's laziness means any "value" may actually be an anonymous function that can perform arbitrary evaluation to produce a value
10:50:23 <nullvoid8> the JVM includes choices about data representation
10:50:28 <geekosaur> (which the FFI will force beforehand)
10:51:26 <JamesJRH> geekosaur: Oh, a function with no arguments? Just not yet evaluated.
10:51:32 <geekosaur> the FFI guarantees the ability to marshal data between Haskell and C. if C does not have a single, standard representation for it, you can't just pass it, you have to write your own marshaling code in both C and Haskell
10:51:36 <JamesJRH> And the FFI forces it.
10:51:51 <JamesJRH> Okay.
10:51:54 <JamesJRH> That sucks.
10:52:02 <nullvoid8> JamesJRH: the technical term is a "Thunk"
10:52:08 <geekosaur> in particular, Haskell lists are singly linked lists --- not vectors. which means you cannot pass a list to C
10:52:16 <tmtwd> So this is the data type for complex numbers: data Complex a = !a :+ !a , is there a way that is more readable?
10:52:18 <JamesJRH> nullvoid8: For what?
10:52:27 <nullvoid8> they get transparently called, and modified in place after execution to point to the calculated value
10:52:40 <geekosaur> (there are specific standard things, like String, which are marshaled to C (char *) strings)
10:52:41 <tmtwd> (and in this case :+ is a custom operator?)
10:52:49 <nullvoid8> a thunk is an unevaluated value
10:52:56 <Iceland_jack> tmtwd: It could be written
10:52:56 <Iceland_jack>     data Complex a = Cmplx a a
10:52:56 <geekosaur> tmtwd, infix constructor
10:53:01 <Iceland_jack> without strictness annotations
10:53:02 <geekosaur> > 0 :+ 1
10:53:02 <JamesJRH> nullvoid8: I had a different term in-mind.
10:53:03 <lambdabot>  0 :+ 1
10:53:25 <ski> tmtwd : the `!'s are just for strictness. yes, `:+' is a custom operator. if you prefer (ignoring strictness) you can think of it as `data Complex a = Rectangular a a'
10:53:37 <geekosaur> you could represent it differently, but that's about as close as Haskell gets to the conventional 0+1i (0+1j for EE types)
10:53:42 <Iceland_jack>     data Pair a = MkPair a a
10:53:44 <nullvoid8> tmtwd: ":+" is just a data constructor
10:54:37 <tmtwd> so in a hakell type , we can have a (custom) data type, which other hs files can use without being aware of the syntax of the custom data constructor?
10:54:42 <geekosaur> heck, you could represnet a complex number 0+1i as (0, 1)
10:54:56 <geekosaur> but then you have no way to distinguish it from any other random tuple
10:55:23 <nullvoid8> ":" counts as a capital letter, and all Data Constructors start with a capital letter, but only strings of symbols may be used "infix"
10:55:23 <ski> (nor of overloading the usual numeric operations for it)
10:55:23 <geekosaur> tmtwd, they have access to that 
10:55:39 <tmtwd> oh, okay
10:55:43 <geekosaur> when you compile a Haskell source file, you get two things out of it: an object file and an interface file
10:55:54 <geekosaur> the interface file contains, among other things, the types
10:56:04 <tmtwd> so when we use a haskell package, we have to be aware of the interface, which may contain custom type constructors?
10:56:11 <geekosaur> (that's the .hi file, if you've ever seen one of those sitting around)
10:56:42 <ski> tmtwd : yes. if the data constructors are also exported, then the user of the module can also use them
10:56:48 <geekosaur> as much as you do in any other language. this si why API references are a thing
10:56:54 <tmtwd> yes
10:57:17 <nullvoid8> I tihnk he's getting bogged down in compiler specifics guys ...
10:57:23 <tmtwd> I am somewhat new to this in general, but I am just used to thinking of functions, rather than new operators in an api
10:57:54 <tmtwd> however, it seems that due to haskell's type system, new operator will also be part of a new api
10:57:59 <ski> tmtwd : sometimes you want to keep a type abstract (hiding the implementation), so that users don't depend on the innards (so that you can change and improve it without code using the earlier version breaking)
10:58:21 <tmtwd> ski, yes good point
10:58:21 <ski> tmtwd : new operators will be part of the interface in case they're exported, otherwise not
10:58:22 <geekosaur> or to preserve invariants; see the discussion of Data.Set a few minutes ago
10:58:40 <geekosaur> (the constructors are hidden so you can't define one which isn't sorted)
10:58:51 <geekosaur> (or is imbalanced)
10:59:33 <nullvoid8> geekosaur: does anything in data.set take advantage of the balance?
10:59:59 <nullvoid8> as in "we can skip this branch of the computation because the tree is balanced"
11:00:11 <geekosaur> I don't know offhand
11:00:14 <ski> nullvoid8 : performance is improved because the trees are roughly balanced
11:00:28 <geekosaur> performance is the obvious thing, yeh
11:00:58 <nullvoid8> ski: well yeah, better question: does passing an unbalnced tree into Data.Set functions affect anything but the performance
11:01:25 <osa1> is there a way to make this TH expression work: http://lpaste.net/137801 (see the comment around variable x)
11:01:25 <nullvoid8> /s/tree/set
11:01:36 <nullvoid8> yay for mixong abstraction levels
11:01:51 <fvgvxmpv1> nullvoid8: I would assume 'member' does
11:02:01 <geekosaur> ignoring "just the performance" can lead to denial of service conditions, thoughj :)
11:02:42 <tmtwd> what would be the closest thing to a data type for an array? data [] a =  a : []?
11:02:53 <fvgvxmpv1> nullvoid8: otherwise it would be O(n), no?
11:03:04 <tmtwd> i know its built into the language, i'm just curious
11:03:13 <tmtwd> (and I mean list, not array)
11:03:24 <nullvoid8> fvgvxmpv1: nope member is just branching on "compare elem current"
11:03:35 <Iceland_jack> tmtwd: If you're asking how to define your own lists 
11:03:35 <Iceland_jack>     data List a = Empty | Cons a (List a)
11:03:51 <nullvoid8> fvgvxmpv1: "anything BUT performance"
11:04:08 <tmtwd> so data [] a = [] | a : [a] ? 
11:04:13 <Iceland_jack> @src []
11:04:13 <lambdabot> data [] a = [] | a : [a]
11:04:25 <tromp_> tmtwd the closest might be a binary tree, although that has O(log n) rather than O(1) access
11:06:34 <tmtwd> what is another common data type that doesn't have | and uses an infix type constructor (ie. similar to data Complex a = !a :+ !a ))
11:07:11 <Iceland_jack> Not that many tmtwd, but it's common when defining your own 
11:07:11 <Iceland_jack>     data Exp = Lit Int | Exp :+ Exp | Exp :* Exp
11:07:22 <Iceland_jack> Where (:+) and (:*) are addition and multiplication
11:07:51 <supki> tmtwd: NonEmpty from semigroups
11:08:17 <Iceland_jack>     data NonEmpty a = a :| [a]
11:08:42 <Iceland_jack> Without operator
11:08:42 <Iceland_jack>     data NonEmpty a = Cons a [a]
11:08:58 <osa1> oh, I forgot a $ before arg, now it's working...
11:09:01 <tmtwd> interesting, I will note these down
11:09:15 <athan> Hey guys, does anyone know how to make pandoc /not/ turn `<i>` elements into `<em>`? :\
11:09:32 <Iceland_jack> It's also possible to your own operators for existing constructors
11:10:41 <athan> it's important for some CSS frameworks (this is with Hakyll, btw). I've found where I can add `WriterOptions` and `ReaderOptions`, as you would when manually invoking Pandoc with Haskell, so I can edit any field
11:11:11 <athan> I just don't know which could be doing it, or could _stop_ it, from the abyss of record fields: http://hackage.haskell.org/package/pandoc-1.15.0.6/docs/Text-Pandoc-Options.html#t:ReaderOptions
11:11:30 <indiagreen> athan: do you mean that you want *abacaba* to generate <i>abacaba</i> instead of <em>abacaba</em>?
11:11:39 <ski> tmtwd : `Ratio'
11:11:49 <Iceland_jack> @src Ratio
11:11:49 <lambdabot> data (Integral a) => Ratio a = !a :% !a
11:12:05 <geekosaur> but :% isn't exported last I checked
11:12:10 <tmtwd> cool
11:12:12 <tmtwd> nice one
11:12:33 <Iceland_jack> tmtwd: lambdabot's definition is also outdated, it doesn't have the Integral constraint anymore
11:12:47 <Iceland_jack>     data Ratio a = !a :% !a
11:13:50 <athan> indiagreen: This is actually Html -> Html :\
11:14:23 <indiagreen> athan: so Pandoc turns <i> in HTML-embedded-in-Markdown into <em>?
11:14:27 <tmtwd> how come the complex type doesn't require the members to be Numbers?
11:14:36 <athan> indiagreen: The framework that I'm using reserves `<i>` nodes exclusively for its icon set, so it's pretty inconvenient
11:14:43 <Iceland_jack> You don't gain anything from it, but lose a lot of things
11:14:45 <mpickering> athan: There is no way because pandoc parses `<i>` to an `Emph` element which is rendered as `<em>`
11:14:57 <athan> I am pretty darn sure
11:15:04 <trumanshow1> I'm not sure what "reads one value from InputStream" means in the description of `read` in io-streams : https://hackage.haskell.org/package/io-streams-1.3.1.0/docs/System-IO-Streams.html#v:read
11:15:12 <mpickering> why are you doing html -> html?
11:15:13 <demize> athan: That's dumb of it à² _à² 
11:15:19 <fvgvxmpv1> tmtwd: itÂ´s considered poor form to have constrains in data declarations
11:15:23 <trumanshow1> If the InputStream is a file, does that mean that the "one value" is the entire contents of the file ?
11:15:29 <fvgvxmpv1> you will notice that the instances require it, though
11:15:38 <tmtwd> fvgvxmpv1, I see ... but it is possible?
11:15:41 <Iceland_jack> tmtwd: Are you familiar type classes like Functor?
11:15:45 <Iceland_jack> *familiar with
11:15:48 <athan> indiagreen, mpickering, demize: Here be my code: https://github.com/athanclark/athanclark.github.io/blob/master/site/resume.html#L9
11:15:56 <c_wraith> trumanshow1: InputStream isn't a type.  InputStream a is a type...  The type variable is important.
11:16:11 <tmtwd> Iceland_jack, vaguely familiar, it is a mappable type
11:16:18 <c_wraith> trumanshow1: the type variable is what "one value" is.  If it's an InputStream Int, read gives you back one Int
11:16:20 <c_wraith> trumanshow1: etc
11:16:31 <trumanshow1> I'm using https://hackage.haskell.org/package/io-streams-1.3.1.0/docs/System-IO-Streams-File.html#v:withFileAsInput
11:16:32 <athan> indiagreen, mpickering, demize: And here be the scallywags: https://github.com/athanclark/athanclark.github.io/blob/master/site/_site/resume.html#L53
11:16:43 <trumanshow1> So the type parameter is ByteStringg
11:17:07 <trumanshow1> What is one value of a ByteString ?
11:17:07 <Iceland_jack> tmtwd: Right, you cannot make 'Ratio' an instance of Functor (and many other very useful classes) if you have the constraint, and even with the constraint it doesn't offer any benefits ("considered a misfeature")
11:17:20 <athan> indiagreen, mpickering, demize: I tried to add the Raw html extension, but I don't think it was the right move: https://github.com/athanclark/athanclark.github.io/blob/master/site/site.hs#L28
11:17:27 <tmtwd> Iceland_jack, ah, I see
11:17:30 <mpickering> athan: save it as ".md" and then pandoc will pass straight through the raw html
11:17:31 <Iceland_jack> tmtwd: There is a separate way to make sure that your type is a number, but it's not worth it: cycle "Keep your data dumb. "
11:17:34 <c_wraith> trumanshow1: Heh.  Looks like that function could use some additional documentation.
11:17:59 <mpickering> that extension only affects the markdown parser and is turned on by default
11:18:10 <tmtwd> so I could define a polar form of complex numbers like this? data ComplexPolar a = Polar a a 
11:18:15 <mpickering> I don't understand why you are passing it through pandoc in the first place
11:18:37 <athan> mpickering: Oh woah! Okay! What compiler should I be using?
11:18:44 <athan> mpickering: That's just how the example had it set up
11:20:00 <c_wraith> trumanshow1: the only thing that really makes sense for those functions is if they give you the entire file contents as one chunk.  Which would mean they're terrible for streaming, of course.
11:20:25 <mpickering> Just don't pass it to the pandoc compiler, there must be an example of that on the hakyll site somewhere?
11:20:26 <fvgvxmpv1> tmtwd: sure, if you feel like it
11:20:37 <Iceland_jack> tmtwd: Yeah
11:20:41 <Iceland_jack> :t polar
11:20:43 <lambdabot> RealFloat a => Complex a -> (a, a)
11:21:10 <tmtwd> But generally when we want to constrain types we put in in the type declaration, rather than the data type?
11:21:28 <trumanshow1> Sure. I'm not composing my `InputStream ByteString` with an output stream elsewhere.
11:21:42 <Iceland_jack> tmtwd: You normally put them in the type signatures and instance declarations, if you're familiar with them
11:21:52 <tmtwd> yes, thats what I  meant ;)
11:21:58 <trumanshow1> I'm looking for an IO alternative than Lazy IO, I'm getting an "out of memory (requested 2097152 bytes)" error...
11:22:36 <Iceland_jack> So if you have a vector of length 2
11:22:36 <Iceland_jack>     data Vec2 a = V2 a a
11:22:36 <Iceland_jack> you can make it a number by
11:22:36 <Iceland_jack>     instance Num a => Num (Vec2 a) where
11:22:39 <Iceland_jack>       (+) :: Vec2 a -> Vec2 a -> Vec2 a 
11:22:42 <Iceland_jack>       V2 a b + V2 x y = V2 (a + x) (b + y)
11:23:04 <fvgvxmpv1> (that type signature in an instance declaration requires an extension)
11:23:21 <Iceland_jack> Yes. You enable InstanceSigs by placing {-# LANGUAGE InstanceSigs #-} at the top of your source file or by entering the following into GHCi:
11:23:21 <Iceland_jack>     ghci> :set -XInstanceSigs
11:23:30 <tmtwd> what is an example of a RealFloat number?
11:23:44 <c_wraith> tmtwd: probably Double
11:23:45 <Iceland_jack> tmtwd: Type ':i RealFloat' into ghci and see 
11:23:45 <fvgvxmpv1> tmtwd, Float (or "7" ;p)
11:24:03 <michaelt> trumanshow1: read bs_input will give you one chunk from the input stream
11:24:32 <tmtwd> ah I see
11:24:45 <Iceland_jack> tmtwd: http://hackage.haskell.org/package/base/docs/Prelude.html#t:RealFloat
11:25:26 <Iceland_jack> It's not a very interesting type class, there are quite a few numeric type classes that basically mean "Float" or "Double"
11:25:38 <trumanshow1> michaelt: What is the size of a strict bytestring chunk? 
11:25:51 <athan> mpickering: How should I embed the html in a mardown document?
11:26:01 <athan> Is there a delimiter syntax?
11:26:18 <mpickering> no you can just use html tags
11:26:23 <fvgvxmpv1> trumanshow1: variable, methinks
11:26:40 <fvgvxmpv1> iirc readFile doubles the chunk size on every read
11:26:56 <tmtwd> :t Complex
11:26:57 <lambdabot> Not in scope: data constructor â€˜Complexâ€™
11:27:36 <michaelt> trumanshow1: it could be anything, but if you are using the InputStream mechanisms from io-streams there is a default chunk maximum
11:27:51 <athan> mpickering: It is treating them as code blocks now ._.
11:28:34 <athan> mpickering: http://athanclark.github.io/resume.html lol
11:28:35 <mpickering> because you have 4 spaces of indentation
11:28:43 <athan> OH
11:28:46 <mpickering> the question still remains why you are passing it through pandoc at all ... :)
11:28:47 <athan> Thank you mpickering
11:29:05 <athan> mpickering: I don't want to, but I thought that was the only way to provide the `title` information :s
11:29:32 <mpickering> I don't know hakyll well enough to comment
11:29:51 <athan> hmm
11:30:32 <michaelt> trumanshow1: it must be here in the docs but e.g. bUFSIZ = 32752
11:30:38 <bitemyapp> did someone say Hakyll?
11:30:48 * bitemyapp ears twitch
11:30:57 <rudi_s> Hi. I want to check if a PCRE-Regex in a ByteString can be compared as string, for that I have to check the current and the next character while "iterating" over the bytestring (if the current char is a \ and the next is an alpha-num in can't be compared as string). Is there an easy way to get the next char while "iterating", stopping on the first false condition. Thanks.
11:31:02 <Iceland_jack> bitemyapp: there should be a /my command
11:31:54 <fvgvxmpv1> rudi_s: tail recursion?
11:32:06 <athan> bitemyapp: Have you had pandoc turn `<i>` into `<em>` before?
11:32:29 <bitemyapp> Iceland_jack: 4rlz
11:32:45 <bitemyapp> athan: I haven't had that specific experience but it wouldn't surprise me miuch.
11:32:49 <bitemyapp> much*
11:32:54 <bitemyapp> are you using Pandoc's markdown?
11:33:00 <athan> hrm
11:33:18 <athan> bitemyapp: No, I'm just trying to use Html, like the examples do
11:33:32 <tmtwd> quick question: if I have a data type data Complex a = Rectangular a a, how would I make a function realPart  :: (Complex a -> a)?
11:33:38 <athan> I think I figured out the compile sequence I need though
11:33:41 <rudi_s> fvgvxmpv1: Ok, so no simple functional solution like map/fold?
11:34:00 <Iceland_jack> tmtwd: Extracting the first component?
11:34:00 <Iceland_jack>     realPart (Rectangular real _) = real
11:34:05 <fvgvxmpv1> itÂ´s a fold, alright
11:34:12 <tmtwd> Iceland_jack, thank :)
11:34:18 <fvgvxmpv1> tail recursion is probably going to be simpler, though
11:34:20 <athan> wait crap
11:34:22 <athan> no dice
11:34:30 <Iceland_jack> tmtwd: Behold the lambdabot definition
11:34:30 <Iceland_jack> @src realPart
11:34:30 <lambdabot> realPart (x :+ _) = x
11:34:38 <mpickering> athan: I explained before why it turned <i> into <em>
11:34:39 <tmtwd> :)
11:34:46 <Iceland_jack> @src imagPart
11:34:46 <lambdabot> imagPart (_ :+ y) = y
11:34:53 <tmtwd> I'm still trying to nail the basics of haskell
11:35:01 <rudi_s> fvgvxmpv1: Ok, thanks. Will use that.
11:35:09 <fvgvxmpv1> more verbose in terms of whitespace (guards \o/), but probably simpler.
11:35:16 <tmtwd> But I have enough to study for a few weeks now
11:35:29 <rudi_s> fvgvxmpv1: Yeah.
11:36:03 <Iceland_jack> tmtwd: Can you define a vector with either 1, 2 or 3 elements?
11:36:12 <Iceland_jack> And then a function that gets the first element
11:36:46 <tmtwd> i think so .... data Vector a = a a a , then first (a _ _) = a?
11:36:55 <Iceland_jack> You'll need to use "|"
11:37:05 <Iceland_jack>     data Vector a = V1 a | V2 a a | V3 a a a 
11:37:13 <tmtwd> ah I see
11:37:27 <Iceland_jack> Then your function needs to handle 3 different cases
11:37:55 <tmtwd> let me try
11:38:04 <Iceland_jack>     first :: Vector a -> a
11:38:04 <Iceland_jack>     first _ = <go right ahead>
11:39:34 <athan> bitemyapp: Is there an `htmlCompiler` or something I should be using? :(
11:41:34 <Jxv> athan, blaze (or lucid)
11:42:11 <athan> |_|
11:42:34 <tmtwd> Iceland_jack, http://pastebin.com/xX1g5yZe this is all wrong, apparently?
11:43:08 <Iceland_jack> tmtwd: 
11:43:08 <Iceland_jack>     first (V1 a)   = a
11:43:08 <Iceland_jack>     first (V2 a _) = a
11:43:08 <Iceland_jack>  
11:43:09 <bitemyapp> athan: are you calling pandoc manually in a Hakyll project? If so, that would be pretty unusual.
11:43:16 <Iceland_jack> tmtwd: Fill in the last one ;)
11:43:19 <tmtwd> ok :)
11:43:20 <bitemyapp> athan: normally you use HTML templating like Jxv mentioned.
11:43:30 <Jxv> athan, there's a package for markdown
11:43:31 <indiagreen> I have a line like Â«protocol <- 'Data.Maybe.fromMaybe' https '<$>' 'views' (base.protocol)Â» and Haddock renders it weirdly (it doesn't think that the quote after fromMaybe is a closing quote). Is there anything I can do about it?
11:43:48 <Iceland_jack> tmtwd: The type is always 'MyVector a', never 'MyVector a a' or 'MyVector a a a'
11:43:56 <Jxv> pandoc is quite large in comparison
11:43:58 <athan> bitemyapp: No, I'm just editing the `site.hs` file, trying to find which compiler I should be using
11:44:03 <tmtwd> Iceland_jack, good tip
11:44:08 <athan> for plugging one html file into another x_x
11:44:09 <mpickering> athan, have you tried `copyFileCompiler`?
11:44:23 <Iceland_jack> tmtwd: If you're in ghci, you create a vector with something like "V3 10 20 30" or "V2 True False"
11:44:27 <athan> mpickering: The only issue I see with that is the title
11:44:43 <athan> because they use the `---` syntax to include it
11:45:10 <bitemyapp> athan: in open-cis194?
11:45:16 <mpickering> well the hakyll header is nothing to do with pandoc
11:45:18 <bitemyapp> athan: or in your own site?
11:45:18 <tmtwd> Iceland_jack, haha, you read my mind
11:45:21 <athan> bitemyapp: This is my own thing atm :)
11:45:24 <athan> soon though
11:45:41 <Iceland_jack> tmtwd: Add "deriving (Show)" to your data declaration, and then you can display your vector 
11:45:41 <Iceland_jack>     ghci> data Vector a = V1 a | V2 a a | V3 a a a deriving (Show)
11:45:41 <Iceland_jack>     ghci> V1 "hello world"
11:45:41 <Iceland_jack>     V1 "hello world"
11:45:44 <Iceland_jack>     ghci> V3 1 22 333
11:45:47 <Iceland_jack>     V3 1 22 333
11:46:01 <tmtwd> alright :)
11:46:35 <athan> mpickering, Jxv, bitemyapp: https://github.com/jaspervdj/hakyll/blob/master/data/example/index.html
11:47:12 <athan> wait
11:47:20 <athan> looking at the source code confirms I'm a dummy
11:47:21 <athan> sorry guys
11:47:39 <rudi_s> How can I easily extract the first two characters from a bytestring? Like (a:b:xs) with lists. Can I use multiple uncons in a non-ugly way? Or should I just unpack and use the usual list functions?
11:48:12 <ChristianS> rudi_s: a bytestring contains bytes, not characters
11:48:19 <Iceland_jack> tmtwd: This is skipping ahead, but you can derive some pretty cool functions for free
11:48:19 <Iceland_jack>     ghci> :set -XDeriveFoldable
11:48:19 <Iceland_jack>     ghci> data Vector a = V1 a | V2 a a | V3 a a a deriving (Foldable)
11:48:19 <Iceland_jack>     ghci> sum (V3 1 22 333)
11:48:22 <Iceland_jack>     356
11:48:33 <tmtwd> cool 
11:48:46 <rudi_s> ChristianS: s/characters/bytes/
11:48:48 <tmtwd> I'm working on folds and stuff in scheme and haskell
11:49:07 <quchen> rudi_s: case BS.unpack (take 2 bs) of (...)
11:49:49 <Iceland_jack> tmtwd: Yes, that's exactly what Foldable gives you and what GHC derives for free (let the compiler write as much for you as possible!)
11:50:18 <Iceland_jack> After importing 'toList' from Data.Foldable 
11:50:18 <Iceland_jack>     ghci> toList (V3 1 22 333)
11:50:18 <Iceland_jack>     [1,22,333]
11:50:20 <indiagreen> if anyone is interested, I solved the Haddock problem by escaping â€œ<â€ in â€œ<-â€
11:50:21 <ChristianS> quchen, rudi_s: that should be BS.take 2, i guess
11:50:30 <quchen> Right.
11:51:07 <rudi_s> quchen: ChristianS: Thanks.
11:52:04 <tmtwd> Iceland_jack, how could we mix in Booleans and integers into V3, for example? (ie 'V3 False 43 2')
11:52:11 <Iceland_jack> You wouldn't
11:52:15 <Zemyla> ChristianS: Does the S mean you're a strict Christian as opposed to a lazy one? :P
11:52:16 <tmtwd> oh, okay ?
11:52:18 <tmtwd> :)
11:52:56 <Iceland_jack> If you need a heterogeneous collection you can but avoid it
11:53:03 <tmtwd> cool thanks :)
11:53:24 <Iceland_jack> You could always define 'data Vector3 a b c = V3 a b c' which is (,,)
11:53:25 <Iceland_jack> :t (,,)
11:53:26 <lambdabot> a -> b -> c -> (a, b, c)
11:53:42 <Iceland_jack> @def data Vector3 a b c = V3 a b c
11:53:43 <lambdabot>  Defined.
11:53:43 <Iceland_jack> :t V3
11:53:44 <lambdabot> a -> b -> c -> Vector3 a b c
11:54:18 <ReinH> You could call it a vector, but it isn't a vector.
11:54:41 <ReinH> Similarly, I can define data Isn'tABool = Isn'tABool Bool
11:55:14 <nullvoid8> ReinH: you can't just *lie* like that :O
11:55:22 <tmtwd> afk for a bit
11:55:40 <michaelt> trumanshow1: right, I see it now, the action repeated by e.g. 'handleToInputStream' is hGetSome h bUFSIZE, where bUFSIZE= 2^15
11:55:44 <Iceland_jack>     data BOOL = TRU | FLS -- TRU is actually False, FLS is actually True ......
11:56:39 <ReinH> mass hysteria
11:57:13 <nullvoid8> :set -XOppositeDay ?
12:00:19 <Peaker> Hey, what's a fast way to compare the keys of two HashMap's (unordered-containers) keys?
12:00:29 <Peaker> i.e: Data.Map's keysSet equivalent
12:02:39 <nullvoid8> Peaker: I'd go with Data.HashMap.keys :: HashMap k v -> [k]
12:03:12 <Peaker> nullvoid8: will (keys a == keys b) work, or will there be random order (e.g: due to hash collisions)?
12:03:54 <nullvoid8> Peaker: hashmapmakes no guarentes about the order, so you'd probably need top feed it into HashSet or something first
12:03:59 * hackagebot exact-pi 0.2.1.0 - Exact rational multiples of pi (and integer powers of pi)  https://hackage.haskell.org/package/exact-pi-0.2.1.0 (dmcclean)
12:04:21 <Peaker> nullvoid8: It's silly that HashSet hides a HashMap () inside, but I can't just do:  HashSet (void hashMap)
12:04:38 <nullvoid8> so Data.HashSet.fromList . Data.HashMap.keys
12:04:49 <nullvoid8> that does sound pretty silly
12:05:31 <nullvoid8> Peaker: you could totally just do (==) `on` void
12:05:42 <Peaker> nullvoid8: ah, true :)
12:05:57 <ralu> do you need to find different entries?
12:05:57 <nullvoid8> and hopefully, ghc would optomise away the comparisons of the values entirly
12:08:01 <joco42> what are empty data type declarations good for ? for example here ? https://github.com/ghcjs/ghcjs-base/blob/master/GHCJS/Types.hs#L29 
12:08:10 <Peaker> ralu: nope
12:08:52 <ralu> just if all values are same or not?
12:08:52 <heatsink> joco42: They're good for tagging other types, so you can tell two types apart even though they're constructed the same way
12:09:01 <joco42> " Semantically, the result is a type (once the type constructor has been fully applied) whose only element is bottom." https://ghc.haskell.org/trac/haskell-prime/wiki/EmptyDataDecls
12:09:13 <joco42> heatsink: thanks !
12:09:26 <joco42> heatsink: so they are like phantom type parameters ?
12:09:32 <ChristianS> Zemyla: actually, i'm quite lazy, and not a christian at all
12:09:33 <heatsink> That's how they're used
12:09:48 <ChristianS> i just use my name to confuse people, and because it happens to be my name
12:09:53 <heatsink> for example, you might have data TaggedDouble units = TaggedDouble Double
12:10:11 <heatsink> and then have x :: TaggedDouble Meters, y :: TaggedDouble Inches
12:10:25 <heatsink> where Meters and Inches have no data constructors
12:10:44 <joco42> i see
12:10:53 <joco42> i have heard this example before
12:11:03 <joco42> start to make sense
12:11:47 <joco42> so empty data types are the actualy types for the phantom type parameters ?
12:12:11 <joco42> in this case Meters, Inches would be empty types
12:12:22 <heatsink> They would be empty data types
12:12:45 <ski> joco42 : no
12:13:09 <lpaste_> JamesJRH pasted â€œForeign higher-order functions diagramâ€ at http://lpaste.net/137805
12:13:10 <joco42> here a is a phantom type too, right ? https://github.com/ghcjs/ghcjs-prim/blob/master/GHCJS/Prim.hs#L37
12:13:27 <ski> joco42 : a "phantom type parameter" could be any parameter (of the correct kind) of a type function
12:13:47 <joco42> in this case Meters, Inches would be empty types
12:14:49 <JamesJRH> nullvoid8, geekosaur: â†‘ That diagram sort of explains how I think higher-order functions could be woven/threaded together through an FFI maybe.
12:14:59 <ReinH> For example, a SHA in git can point to a commit, a tree, a tag, etc. You might have a Commit type that contains the structure of a commit. You might also have a SHA type parameterized on a phantom type which keeps track of what sort of SHA it is
12:15:13 <ReinH> so you might have SHA Commit or SHA Tree
12:15:35 <joco42> i am loosing irc connection...
12:15:57 <ski> joco42 : they could be empty types (or perhaps types with just one inhabitant, if you want convenience for referring to it). but they could also be constructors of a data kind
12:15:59 <JamesJRH> nullvoid8: That way translation of the actual function definition is avoided.
12:16:26 <JamesJRH> The function stays in the original language.
12:16:46 <joco42> ski, heatsink: my connection was dropped for a few minutes...
12:17:31 <JamesJRH> However well normal functions work, surely the same can be achieved of higher-order. However, as geekosaur indicates, that's not to say that much.
12:17:56 <joco42> ski, heatsink : thanks for the explanation
12:19:00 * hackagebot exact-pi 0.2.1.1 - Exact rational multiples of pi (and integer powers of pi)  https://hackage.haskell.org/package/exact-pi-0.2.1.1 (dmcclean)
12:19:02 * hackagebot microlens-mtl 0.1.1.0 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.1.0 (Artyom)
12:21:53 <JamesJRH> Heh, noÃ¶ne lolled at my silly diagram. :-)
12:23:16 <Peaker> seems like a naive replace of Data.Map with Data.HashMap.Strict slows down a lot...
12:24:01 <JamesJRH> So basically, regardless of higher-order functions or not, the FFI is less than ideal for /any/ functions. :-(
12:25:52 <JamesJRH> So, â€˜marshallingâ€™ is the term for what is the issue here.
12:25:53 <JamesJRH> https://en.wikipedia.org/wiki/Marshalling_%28computer_science%29
12:26:09 <JamesJRH> Everything needs marshalling.
12:27:12 <JamesJRH> Ah, Pickle.
12:27:32 <sanjoyd> I have a haskell code design question; is this a good place to ask?
12:27:39 <JamesJRH> Is there a Haskell equivalent to Python's Pickle?
12:27:45 <opqdonut> Data.Binary is one
12:28:13 <MarcelineVQ> sanjoyd: probably
12:28:13 <opqdonut> and actually, you don't need marshalling to pass functions over an FFI
12:28:21 <opqdonut> only an agreement on the calling convention
12:29:15 <sanjoyd> So I'm trying to abstract out a "SearchProblem" that can be solved by BFS, A* etc.
12:29:21 <sanjoyd> (Toy project)
12:29:27 <sanjoyd> What I have now is this: https://github.com/sanjoy/AIMA/blob/master/src/SearchProblem.hs
12:30:08 <sanjoyd> But this design has a problem -- SearchProblem Foo Bar is a totally different type than SearchProblem Foo' Bar'
12:30:21 <JamesJRH> opqdonut: Thanks.
12:31:12 <sanjoyd> Is there a neat way to package SearchProblem into (say) a typeclas that lets SearchProblem Foo Bar and SearchProblem Foo' Bar' unify into the same type?
12:31:14 * JamesJRH wonders if Data.Binary can even serialise functions.
12:31:38 <opqdonut> JamesJRH: it can't
12:31:42 <JamesJRH> :-)
12:31:57 <maerwald> I don't love you anymore
12:32:05 <maerwald> sry, wrong window
12:32:06 <opqdonut> JamesJRH: see also https://wiki.haskell.org/GHC/Using_the_FFI#Callbacks_into_Haskell_from_foreign_code
12:32:11 <JamesJRH> LOL!
12:34:33 <JamesJRH> opqdonut: Oh, so is that basically what I was asking before about the higher-order functions?
12:34:54 <opqdonut> JamesJRH: yes
12:35:01 <JamesJRH> Okay, cool.
12:35:56 <JamesJRH> So the main problem is just that all data types have representation issues; the higher-order thing is a nonissue.
12:36:32 <ctau> I've been debugging a weird problem, and I am out of ideas (aside from profiling, which was suggested yesterday when I asked folks IRL for ideas) - I have an atomic transaction in a yesod handler, and when I post data with curl, things are fine. when I post the same data with wreq, my yesod server reports a runtime error , [Error#yesod-core] Control.Concurrent.STM.atomically was nested @(yesod_KBsWkcfHi267sdqbHvGTE1:Yesod.Core.Class.Ye
12:36:54 <JamesJRH> opqdonut: Also, laziness probably doesn't work across the FFI, right?
12:37:18 <JamesJRH> Hmm, this reminds me of my seekable pipe thoughts.
12:37:47 <JamesJRH> Which could be used for lazy IPC.
12:38:18 <JamesJRH> For deterministic pipelines, that is.
12:39:21 <JamesJRH> This can probably be super generalised! :-D
12:42:11 <rudi_s> I want to use unit tests for some parts of my program. What is the recommend package for haskell at the moment? Thanks.
12:43:05 <startling> rudi_s, I like hspec
12:43:09 <quchen> HUnit and HSpec work well for unit tests. But you might also be interested in different kinds of tests, such as property-based (Quickcheck, Smallcheck).
12:43:19 <Peaker> rudi_s: I think popular ones are test-framework, tasty, hspec, (there's some doctests package)
12:43:20 <quchen> Tasty is an excellent framework to glue all of them together.
12:43:52 <Peaker> quchen: does Tasty have any useful feature beyond test-framework? It generally advertised itself as "newer" but not much of "better"?
12:44:01 * hackagebot opaleye-sqlite 0.0.1.0 - An SQL-generating DSL targeting SQLite  https://hackage.haskell.org/package/opaleye-sqlite-0.0.1.0 (tomjaguarpaw)
12:44:05 <cgag> i like hspec as well, with tasty if i want tod o more than hspec (quickcheck, hunit)
12:44:17 <rudi_s> startling: quchen: Peaker: Thank you for the suggestions. (I know about quickcheck, but need some "static" test cases for some parts of the code.)
12:44:30 <startling> yeah, it's nice to use something that does both
12:45:23 <quchen> Peaker: I don't know. I've only used Tasty.
12:45:38 <quchen> Without enough trouble to make me switch, that is.
12:46:11 <startling> cgag, I've always used hspec without tasty for quickcheck, what does using it with tasty give you?
12:46:24 <cgag> yeah my recommedation of tasty comes with those same caveats, never used anything else
12:48:08 <cgag> _di: 
12:48:09 <rudi_s> Btw. is there a way to test "private" (unexported) methods of a module?
12:48:14 <quchen> No.
12:49:01 <startling> ^ my tendency is to export everything (sometimes from different namespaces) for this reason
12:49:20 <quchen> That heavily clutters your API with stuff that shouldn't be in the API.
12:49:33 <cgag> statusfailed: i'm not sure if it gives you much if you use it with just hspec, but if you're using multiple tests libraries (hspec, hunit, quickcheck, etc), it lets you easily combine them into one test suite 
12:49:38 <quchen> The current Haskell way is to name modules "Internal" when you don't want anyone to use them.
12:49:54 <startling> quchen, that's why I said "sometimes from different namespaces"
12:50:51 <rudi_s> Hm, I see. Thanks.
12:50:54 <catgocat> Guys what happens when I define `data Stuff = Int` ?
12:51:04 <catgocat> What does this mean?=
12:51:04 <quchen> You get an error.
12:51:08 <catgocat> I don't get any error
12:51:11 <catgocat> at least not in ghci
12:51:35 <quchen> That's strange.
12:51:38 <startling> catgocat, you define a type called Stuff that has a single constructor that's confusingly-named "Int"
12:51:52 <startling> totally unrelated to Int the type
12:52:06 <quchen> Ah right, Int# is the Int constructor.
12:52:25 <catgocat> starling: so how does it distinct between Int and Int :: Stuff ?
12:52:52 <quchen> Hm, Int# isn't even exposed by default. Ignore me. :-x
12:53:02 <startling> catgocat, types and values have different namespaces
12:53:12 <startling> catgocat, that's also why you can have data X = X
12:53:49 <startling> catgocat, since you only use types in type definitions, it's easy to keep them apart
12:54:04 <startling> definitions / signatures / etc
12:54:32 <catgocat> starling: what do you mean namespace and values, and types?
12:54:48 <catgocat> please can you make make a distinction
12:55:05 <startling> catgocat, data Stuff = Stuff -- you're defining a type called Stuff that also has a single value, named Stuff
12:55:45 <startling> catgocat, it's always possible to tell Stuff-the-type from Stuff-the-value, since they're only used in different places
12:56:18 <startling> so basically you have two worlds of names, one which is used for types and one which is used for values
12:56:28 <startling> nothing ever moves between the two worlds
12:57:09 <startling> (there are some extensions that let you break this, I think, but they're not very relevant)
12:59:33 <catgocat> startling: So basically there is an Int type, but not an Int value. That's why I can do that.
12:59:42 <startling> yeah, exactly
12:59:59 <startling> there are Int values but none of them are named Int
13:01:03 <voidzero> one of them is named 5
13:01:26 <Peaker> "There are Int values" means there are values of "Int" type (not: there exist values which are named "Int")
13:01:40 <voidzero> yeah, values of type Int
13:02:12 <startling> yeah, thought what I originally said was ambiguous so I wanted to clarify, but may have made things more confusing
13:04:42 <voidzero> nah, just semantics. You're emphasising the most crucial thing to me, as a neophyte at least. I wish I'd have understood that earlier :)
13:06:01 <voidzero> one other important thing I wish I realised earlier, was the simple fact that you have functions, and values, so a function is basically an incomplete value.
13:06:45 <voidzero> It sounds logical in hindsight, but especially when learning about the type system, keeping this in mind helps
13:07:29 <startling> well, there are two important bits wrt functions:
13:07:40 <startling> * all functions *are* values
13:07:57 <startling> * how currying works
13:10:57 <voidzero> and distinguish currying from eta conversion
13:11:26 <voidzero> all functions are values and have a type, yes?
13:11:55 <startling> yes.
13:12:00 <voidzero> and kinds are like types for functions?
13:12:28 <nullvoid8> kinds are like types for types
13:12:58 <nullvoid8> a value is just a zero argument function
13:13:38 <ski> strictly speaking, all functions in Haskell takes exactly one argument
13:13:53 <hpc> a value is very much not a zero argument function
13:14:11 <voidzero> hpc, I was just about to ask.
13:14:20 <nullvoid8> one of my statements may have been more true than the other
13:14:21 <voidzero> A function is a computation
13:14:35 <hpc> my guess is that people come from java where "everything is an object" (which still isn't true)
13:14:36 <startling> I wouldn't say "a function is basically an incomplete value" either
13:14:38 <ski> a function is parameterized
13:14:44 <hpc> and decide that because haskell's big thing is functions, everything is functions
13:15:07 <startling> voidzero, computations in haskell don't have to be functions either :P
13:15:13 <ely-se> a function is a value constructor
13:15:26 <nullvoid8> when you include thunks, some values are zero argument functions :P
13:15:31 <hpc> a function is a value constructed as \x -> whatever
13:15:48 <hpc> (or any of the zillion sugars that translate to it)
13:15:48 <startling> nullvoid8, now you're just obscuring what "function" means in haskell
13:16:02 <voidzero> ely-se, a value constructor. Yes. I'll repeat that to myself until it sticks. :)
13:16:04 <ReinH> No. No they are not.
13:16:15 <nullvoid8> startling: I should probably have said computation or something. but I wasn't being serious
13:16:31 <kuribas> A function is just a map from one value to another.
13:16:41 <voidzero> it's a good thing to get the terminology right though
13:16:56 <hpc> kuribas: there are maps that aren't functions
13:16:59 <hpc> like Map
13:17:08 <ReinH> In Haskell, a function is a type of kind * whose outermost constructor is (->)
13:17:15 <ski> "thunk" is a word referring to a particular way to implement a non-strict semantics
13:17:24 <ely-se> hpc: in Haskell, yes.
13:17:37 <hpc> ely-se: we're talking about haskell here ;)
13:17:44 <ely-se> hurray!
13:18:08 <ely-se> I saw somebody mention Java.
13:18:21 <kuribas> hpc: I meant map in the mathematical sense, not the datatype.
13:18:22 <hpc> i did, but somewhat tangentally
13:18:51 <ely-se> Single-method Java classes are like curried functions. The constructor has the first N arguments. The method has the rest.
13:19:03 <kuribas> hpc: but a Map and a function is very similar.
13:19:07 <voidzero> ReinH, 'outermost constructor' is not trivial to understand for a self taught guy like me, who had no maths after elementary school :/
13:19:31 <hpc> kuribas: Map is a valid mapping, in the mathematical sense
13:19:45 <hpc> (for finite domains)
13:19:57 <ely-se> in Scala Map[K, V] is a function type :3
13:20:14 <kuribas> hpc: what does that mean?
13:20:48 <hpc> say you have (Map k v), for some type k that has a finite number of values
13:20:53 <hpc> we'll use Bool just because
13:21:09 <hpc> you can trivially map any function (Bool -> v) to (Map Bool v)
13:21:30 <voidzero> i was daring and bought http://amzn.com/0521283043
13:21:32 <hpc> convert f = pack [(False, f False), (True, f True)]
13:21:44 <Peaker> hpc: fromList you mean?
13:21:46 <hpc> unconvert m = \k -> lookup k
13:21:55 <hpc> Peaker: er, yeah
13:22:02 <Peaker> hpc: (m!k), lookup returns a Maybe
13:22:11 <hpc> argh
13:22:17 <voidzero> (Introduction to category theory, by Harold Simmons)
13:22:17 * Peaker is a human type-checker
13:22:20 <kuribas> hpc: still you can trivially convert every Map to a function by applying it to lookup.
13:22:29 <hpc> kuribas: that is true
13:22:38 <hpc> but not the other way, generally
13:22:48 <hpc> for instance, if k = Integer
13:23:17 <startling> voidzero, it's not very mathy. there are just type constructors (as opposed to value constructors)
13:23:32 <Peaker> There's conal's nice TMap, which is like a Map but much closer to functions
13:23:42 <voidzero> startling, referring to the book?
13:23:44 <hpc> in those cases, the function you get from the Map will be partial (which may not make it a mathematical mapping if your definition cares about that)
13:23:53 <hpc> and the Map you get from the function will be infinitely large
13:23:54 <Peaker> and has all the nice instances functions do, behaving the same, too
13:24:08 <startling> voidzero, so, "outermost constructor" just means a -> b rather than [(a -> b)] or whatever
13:24:12 <voidzero> oh to ReinH's statement, yes
13:24:17 <ski> voidzero : do you understand how you can visualize expressions as trees ?
13:24:19 <kuribas> hpc: but you stated, "there are maps that aren't functions", not the opposite.
13:24:20 <hpc> which means you can't even whnf it, if you use the definition of Map that's in base
13:24:38 <hpc> well, there's two sides to it
13:24:47 <hpc> either your idea of a map means total mapping
13:24:53 <voidzero> oh, so outermost means, in my words, "unnested". I was thinking left most or right most
13:24:54 <hpc> in which case (->) isn't even a map
13:25:02 <hpc> or you admit partiality, in which case Map qualifies
13:25:07 <voidzero> ski, not really
13:25:22 <kuribas> hpc: functions in haskell are partial maps obviously.
13:25:33 <voidzero> really not, in fact. :)
13:26:06 <kuribas> hpc: unless you count bottom as a value :)
13:26:28 <startling> voidzero, leftmost works, if you de-infix it
13:26:38 <startling> voidzero, a -> b is equvialent to (->) a b
13:27:42 <hpc> kuribas: anyway, point was "functions are maps" leaves room for confusion when teaching someone new to the language
13:28:20 <voidzero> startling, yes, I remember from the LYAH chapter about reverse polish notation (i think)
13:28:23 <mniip> [22:23:29] <kuribas> hpc: functions in haskell are partial maps obviously.
13:28:34 <lamefun> Why does `import qualified Data.Char as C; import qualified MyChar as C (isDigit)` make the compiler error out with an "ambiguous reference" error instead of the second import overriding the first?
13:28:37 <mniip> only if the input type is finite
13:29:10 <startling> lamefun, no good reason, that's just how Haskell works
13:29:42 <mniip> a function of type [a]->a might be an infinite map yet still be constructible
13:30:05 <voidzero> lamefun, you can add 'hiding isDigit' to the first import statement
13:30:32 <hpc> mniip: you can still write a partial function of that type
13:30:43 <Peaker> blacklisting :(  whitelisting :)
13:30:44 <mniip> hpc, right
13:30:52 <lamefun> Eg. I have a module `MyProgram.Text` that contains additional text utilities, is there a standard style of using both the standard module and my utility module while still using single-letter qualified imports?
13:31:03 <mniip> hpc, but that doesn't change the fact that the map might be infinite
13:31:16 <voidzero> lamefun, 'import qualified Data.Char as C hiding isDigit'
13:31:18 <mniip> which doesn't correspond to Data.Map.Map very well
13:32:55 <Peaker> building laziness upon an eager language is relatively easy (via a "Lazy" type constructor). the opposite is harder (need special language support for opting into eagerness).  Makes me think that eagerness is the more fundamental idea
13:33:42 <kuribas> mniip: Why can't you have a map from a infinite value to another infinite value?
13:33:45 <Peaker> (though I guess in a textual language it becomes quite unusable:  (||) :: Bool -> Lazy Bool -> Bool
13:34:02 <Peaker> x || delay y)
13:34:02 * hackagebot hedis-monadic 0.0.4 - A la MonadReader for Redis connection  https://hackage.haskell.org/package/hedis-monadic-0.0.4 (AlekseyUymanov)
13:34:24 <mniip> kuribas, not with Data.Map.Map
13:35:01 <kuribas> mniip: that's why said, a mathematical map, not a datatype.
13:35:21 <mniip> okay then
13:38:28 <OutlawStar> any one know if its possible to down cast widgets in gtk+? IE go from Widget to say a MenuItem
13:39:03 * hackagebot fast-digits 0.1.0.0 - The fast library for integer-to-digits conversion.  https://hackage.haskell.org/package/fast-digits-0.1.0.0 (Bodigrim)
13:40:20 <nullvoid8> Peaker: and then you bring in the compiler automatically fixing up certain newtypes/almost newtypes like Lazy for you
13:40:53 <Peaker> nullvoid8: I'm generally scared of implicit coercions like that
13:41:01 <JamesJRH> 17:51:05 < JamesJRH> geekosaur: Oh, a function with no arguments? Just not yet evaluated.  17:51:42 < nullvoid8> JamesJRH: the technical term is a "Thunk"  17:52:42 < JamesJRH> nullvoid8: I had a different term in-mind.  â† I've just remembered the name of what I was thinking of â€“ a reduction expression (or redex).
13:41:21 <nullvoid8> I think it can be good in certain specific, well defined cases
13:41:44 <JamesJRH> nullvoid8: How does a thunk relate to a redex?
13:42:18 <nullvoid8> JamesJRH: I'm sure, but I have heard the term before
13:42:57 <nullvoid8> *not sure
13:44:28 <JamesJRH> Neither relevant Wikipedia article mentions the other term: https://en.wikipedia.org/wiki/Thunk https://en.wikipedia.org/wiki/Reduction_strategy_%28code_optimization%29 (redirected from reduction expression)
13:44:32 <JamesJRH> :-]
13:44:54 <JamesJRH> Redirected from redex, sorry.
13:45:20 <JamesJRH> The reduction expression redirect is currently missing...
13:45:21 <hpc> JamesJRH: have you read https://ghc.haskell.org/trac/ghc/wiki/Commentary?
13:46:01 <hpc> JamesJRH: (not sure if anything on redexes/thunks is on there though)
13:46:03 <JamesJRH> Um.
13:46:47 <geekosaur> so, redex is a conceptual view and thunk is an implementation view
13:47:19 <JamesJRH> Having said that, I meant â€˜/reducible/ expressionâ€™, which does have a redirect, so that's correct. :-)
13:47:42 <JamesJRH> hpc: No, I'll read...
13:48:01 <JamesJRH> geekosaur: I see.
13:48:15 <JamesJRH> That's a simple resolution.
13:49:39 <JamesJRH> Though I'd still expect those 2 articles to link to each other; I think that I'll at least add each other to the See also sections.
13:53:09 <JamesJRH> Done. :-)
13:57:01 <JamesJRH> Is there a â€˜lazierâ€™ implementation of a list?
13:57:46 <JamesJRH> Such that something like this is possible?: take 1 $ reverse $ reverse $ [1..]
13:58:25 <JamesJRH> Or at least this: take 1 $ reverse $ reverse $ [1..1000000000000]
13:59:04 <hpc> you're better off reconsidering the approach you are taking that requires (reverse . reverse) at all
13:59:27 <JamesJRH> hpc: It's just an esoteric example.
14:00:00 <mniip> JamesJRH, you can implement a wrapper around a list for that specific purpose
14:00:11 <mniip> but generally no
14:00:16 <JamesJRH> It's the easiest to explain, but in general, I find many other places where I hit the lack of laziness in the list implementation.
14:00:18 <hpc> then as a general answer to "i can't do this with []", there's loads of other data structures that might suit a problem better
14:00:28 <hpc> Array, Set, whatever
14:00:34 <JamesJRH> Okay.
14:00:50 <mniip> JamesJRH, "lack of laziness"
14:00:52 <JamesJRH> Maybe Array; I've never used it.
14:00:59 <mniip> list doesn't restrict any laziness
14:01:05 <mniip> it's just the nature of cons cells
14:01:14 <JamesJRH> I know.
14:01:30 <mniip> for your purpose you could do something like
14:01:48 <mniip> data FooList x = FooList Bool [x]
14:02:11 <mniip> toList = FooList False; fromList (FooList d xs) = if d then reverse xs else xs
14:02:20 <JamesJRH> But a â€˜list implementationâ€™ doesn't necessarily have to be done with cons. Array could be the answer.
14:02:23 <mniip> reverse (FooList d xs) = FooList (not d) xs
14:02:37 <mniip> JamesJRH, Array cannot fit [1..]
14:02:45 <JamesJRH> Okay.
14:02:54 <mniip> nothing but cons cells can fit [1..]
14:03:17 <mniip> well, actually, maybe a binary tree
14:03:29 <hpc> in general, picking the right data structure for the job will serve you better than "i want this with a tweak that solves that"
14:03:30 <JamesJRH> I don't think that â€˜take 1 $ reverse $ reverse $ [1..]â€™ can work anyway.
14:03:41 <mniip> with 2n-or-2n+1 recursions instead of n+1 recursion
14:04:09 <JamesJRH> But take 1 $ reverse $ reverse $ [1..<some big number>] could, and that wouldn't fit in an Array either, so yes.
14:04:32 <mniip> JamesJRH, that will take O(N)
14:05:31 <JamesJRH> mniip: It takes me O(1), so I know that it could be made to work with a different data structure. :-)
14:06:27 <JamesJRH> I.e.: take 1 $ reverse $ reverse $ [1..1000000000000] = [1]
14:06:47 <mniip> you mean you can infer that statically with your brain?
14:07:00 <JamesJRH> Yep. :-)
14:09:06 <JamesJRH> So I'm basically looking for a list-like data structure that enables GHC to do this sort of evaluation in O(1) too.
14:10:00 <JamesJRH> And by â€˜listâ€™, I only really mean an ordered collection; nothing specific to cons.
14:10:01 <johnw> JamesJRH: in the case of reverse . reverse, couldn't a REWRITE rule achieve that?
14:10:26 <mniip> johnw, that would be a bad rule
14:10:32 <johnw> oh?
14:10:47 <JamesJRH> johnw: What is a â€œREWRITE ruleâ€?
14:11:00 <johnw> anywhere GHC sees "rewrite . rewrite", replace it with "id"
14:11:06 <johnw> sorry, reverse . reverse
14:11:10 <johnw> not sure what mniip means
14:11:18 <JamesJRH> Okay.
14:11:23 <mniip> lazy reverse $ lazy reverse (1:bottom) is bottom
14:11:47 <mniip> as opposed to reverse $ reverse (1:bottom) which is (1:...)
14:11:59 <mniip> which breaks evaluation semantics
14:12:27 <JamesJRH> I'll give a less esoteric example of where I run-up against this problem...
14:12:49 <johnw> mniip: still not sure what you're talking abuot
14:12:54 <johnw> when did "lazy reverse" come into this?
14:13:09 <johnw> and what is your "reverse" then?
14:13:13 <mniip> johnw, the rule removes bottoms that should be there
14:13:25 <mniip> (the rule is not fired when lazy is used)
14:13:31 <johnw> ah
14:13:52 <johnw> bottom is often like a mosquito
14:14:09 <mniip> you can't use rules to eliminate bottoms
14:14:24 <mniip> only to optimize non-bottom cases
14:14:53 <johnw> "reverse $ reverse (1:bottom) = (1:...)?", what is the "..."?
14:15:14 <mniip> johnw, irrelevant
14:15:22 <johnw> > reverse $ reverse [1:undefined]
14:15:24 <lambdabot>  [[1*Exception: Prelude.undefined
14:15:45 <johnw> I'm still not seeing the distinction
14:15:48 <mniip> what's [1:undefined] got to do with this
14:16:19 <johnw> sorry, notational error
14:16:28 <johnw> > reverse $ reverse (1:undefined)
14:16:30 <lambdabot>  *Exception: Prelude.undefined
14:16:38 <johnw> how is that 1:...?
14:16:51 <mniip> [23:09:08] <johnw> anywhere GHC sees "rewrite . rewrite", replace it with "id"
14:16:59 <mniip> I'm talking about your rule being in scope
14:17:19 <johnw> oh, you're saying reverse (reverse (1:undefined)) != 1:undefined, it equals undefined
14:17:24 <mniip> ye
14:17:29 <mniip> and your rule breaks that
14:17:51 <quchen> Not only bottom breaks that law, arbitrary infinite lists do as well.
14:17:55 <JamesJRH> â€˜(map function [0..])!!1000000000000â€™ should only need to evaluate the 1000000000000th element, and should be about as quick as â€˜function 1000000000000â€™. But it's not. How do I make a data structure that makes this (and â€˜reverse $ reverseâ€™) lazy?
14:18:42 <quchen> JamesJRH: No, your map has to create a long list of thunks (that can all be GC'd again) before reaching the 10000...th element. And then calculating that is the same as "function 10000...".
14:19:06 <mniip> JamesJRH, data FList a = Flist Int Int -> a
14:19:11 <kellerr> hey, i have a list of Eithers. is there some function to fold over it and return list of rights OR just the first left?
14:19:13 <mniip> er
14:19:16 <mniip> (Int -> a)
14:19:25 <johnw> kellerr: sequenceA
14:19:40 <kellerr> johnw, ah! i'll look into that. thanks!
14:19:51 <mniip> JamesJRH, but that still won't handle 'reverse . reverse'
14:19:59 <mniip> because there is no intermediate representation
14:20:25 <benzrf> kellerr: it essentially applicatively combines all of the elements
14:21:39 <JamesJRH> So I want a list-like data structure (i.e. an ordered collection), that avoids making 1000000000000 unnecessary thunks.
14:21:49 <Peaker> ocaml pattern match lets you do multiple pattern matches with the same handler, that's nice!
14:22:01 <JamesJRH> s/making/trying to make/
14:22:13 <Peaker> | (TVar x, t) | (t, TVar x) -> .. common handler for both ..
14:23:12 <Peaker> also lets you read mutable refs as part of the pattern-match (which I think can be sound if you just conceptually desugar it to reading all relevant refs before the pattern match)
14:23:15 <mniip> JamesJRH, you're giving contradicting requests
14:23:31 <Peaker> I think I had lots of pattern matches ugly-ily broken into nested matches in order to do a read-mutable in between
14:23:36 <JamesJRH> Not really.
14:23:44 <mniip> yes really
14:24:04 * hackagebot language-javascript 0.5.14.2 - Parser for JavaScript  https://hackage.haskell.org/package/language-javascript-0.5.14.2 (ErikDeCastroLopo)
14:24:24 <JamesJRH> > id 10
14:24:25 <lambdabot>  10
14:24:35 <JamesJRH> > (map id [0..])!!10
14:24:37 <lambdabot>  10
14:24:45 <JamesJRH> > id 1000000000000
14:24:47 <lambdabot>  1000000000000
14:24:53 <JamesJRH> > (map id [0..])!!1000000000000
14:24:57 <lambdabot>  mueval-core: Time limit exceeded
14:25:17 <arkeet> > id (-2)
14:25:19 <lambdabot>  -2
14:25:22 <arkeet> map id [0..] !! (-2)
14:25:25 <arkeet> > map id [0..] !! (-2)
14:25:27 <lambdabot>  *Exception: Prelude.!!: negative index
14:25:36 <mniip> JamesJRH, if you want 'reverse $ reverse [1..]' to work, you have to make 'reverse [1..]' work too
14:25:40 <JamesJRH> So how do I avoid the 1000000000000 useless thunks there?
14:25:43 <mniip> what would 'reverse [1..]' be?
14:25:47 <JamesJRH> That started to be gernerated.
14:25:49 <arkeet> jameseb: you don't do that.
14:25:53 <arkeet> JamesJRH: *
14:25:58 <arkeet> what are you trying to do?
14:25:59 <mniip> JamesJRH, consider using a function
14:26:52 <mniip> > fmap id id 1000000000000
14:26:53 <lambdabot>  1000000000000
14:27:18 <johnw> JamesJRH: right, does your list need to be a list?
14:27:27 <johnw> or is it just an association of indices with values?
14:27:37 <quchen> I think a specific use case might be helpful here.
14:27:38 <nullvoid8> iirc, you can optimise "list ! largenum" if the compiler has shape information
14:27:50 <quchen> This may be solvable with a Trie, or a number of other structures.
14:29:23 <JamesJRH> 21:25:23 < mniip> what would 'reverse [1..]' be?  â† I corrected that to â€˜some very large but known numberâ€™.
14:29:36 <JamesJRH> 20:58:04 < JamesJRH> Or at least this: take 1 $ reverse $ reverse $ [1..1000000000000]
14:29:39 <mniip> then you can use a length-function pair
14:30:27 <mniip> [23:17:13] <mniip> JamesJRH, data FList a = Flist Int (Int -> a)
14:31:40 <mniip> fromList xs = FList (length xs) (xs !!)
14:31:58 <mniip> toList (Flist l f) = map f [0..l-1]
14:32:37 <hiptobecubic> why on earth would you make such a thing
14:33:37 <mniip> what
14:33:56 <mniip> it's just a representable functor -ization of lists
14:36:06 <mniip> oh and
14:36:20 <eds> Is there a different way I can define my ExprW? Code and error: http://lpaste.net/137809
14:36:27 <JamesJRH> 21:26:57 < johnw> JamesJRH: right, does your list need to be a list?  21:27:06 < johnw> or is it just an association of indices with values?  â† No, it doesn't have to specifically be a list; it just has to work with fmap, a folding function, a take and drop function, and a reverse function, and a couple of other things to that effect that operate on an ordered collection / sequence.
14:36:33 <mniip> reverse (FList l f) = FList l (f . (l -))
14:36:39 <JamesJRH> johnw: So yes, it's an association of indices to values, isn't it!
14:36:55 <JamesJRH> johnw: So I'd use a dictionary or something, right?
14:37:05 <mniip> JamesJRH, see FList
14:37:13 <JamesJRH> Okay...
14:37:18 <mniip> it can implement efficient foldr/foldl, fmap, take, drop
14:37:28 <JamesJRH> I need to catch-up with scrollback...
14:39:30 <kellerr> benzrf: yea i noticed from looking at the source. i actually was asking this question for scalaz, but #haskell is always the best source. works like a charm. thanks.
14:39:36 <JamesJRH> 21:36:57 < mniip> it can implement efficient foldr/foldl, fmap, take, drop  â† Cool! Thank you! I'll take a look.
14:39:52 <eds> Is there a different way I can define my ExprW? Code and error: http://lpaste.net/137809 bump
14:40:14 <benzrf> kellerr: ;]
14:40:51 <mniip> eds, what are you trying to do
14:41:11 <eds> generate random nodes
14:41:20 <mniip> no I mean with ExprW
14:41:30 <eds> for my tree
14:41:30 <mniip> you're using vs which is not a type parameter of ExprW
14:42:22 <eds> The nodes can be of three types Int, Bool or a List. 
14:42:33 <eds> Yea. See my data Expr
14:42:42 <arkeet> so what's vs?
14:43:28 <Sindriava> The haskell IRC channels are so nice and helpful! \o/
14:43:31 <eds> The definition of Indexor , data Indexor :: [k] -> k -> * where
14:43:32 <mniip> eds, are you okay with not knowing what vs is once you pack it into EI
14:43:41 <eds> yes!
14:43:56 <mniip> ExprW can then use some forall.
14:44:01 <eds> for EI i.e Int it does not care what the environment vs is
14:44:05 <mniip> or otherwise it can be rewritten as a GADT
14:44:23 <mniip> which will trigger the same semantics
14:45:37 <eds> how would I do it with forall?
14:46:12 <eds> Umm, writing it as GADT which I think I can, but forall I dont know how to apply that.
14:46:28 <mniip> @let data E = forall a. A [a] | forall a. B a
14:46:29 <lambdabot>  Defined.
14:46:41 <mniip> woohoo got the syntax on the first try
14:46:54 <arkeet> :t A [1,2]
14:46:55 <lambdabot> E
14:47:34 <arkeet> > let x = A [1,2] in case x of { A a -> length a }
14:47:36 <lambdabot>  2
14:48:28 <arkeet> > let x = A [1,2] in case x of { A a -> map (const ()) a }
14:48:30 <lambdabot>  [(),()]
14:48:53 <arkeet> forall a. A [a] is no better than A [()]
14:49:05 <mniip> yup
14:49:33 <mniip> and [()] is no better than a peano number
14:49:53 <arkeet> I find the syntax kinda weird.
14:50:11 <eds> data ExprW = EI (forall vs. Expr vs Int) | EB (forall vs. Expr vs Bool) | EL (forall vs. Expr vs [a]) deriving Show. Something like this?
14:50:17 <mniip> eds, no
14:50:19 <arkeet> no, forall goes before the constructor name.
14:50:23 <mniip> forall goes before the datacon
14:50:28 <arkeet> it's the difference between
14:50:37 <arkeet> forall vs. (Expr vs Int -> EI)
14:50:38 <arkeet> er
14:50:42 <arkeet> EI :: forall vs. (Expr vs Int -> ExprW)
14:50:48 <arkeet> and EI :: (forall vs. Expr vs Int) -> ExprW)
14:50:54 <arkeet> bah.
14:51:03 <arkeet> you get the idea.
14:51:07 <mniip> arkeet, there is no difference though
14:51:11 <arkeet> yes there is.
14:51:21 <arkeet> one is a higher rank thing, the other is an existential
14:51:22 <mniip> ah right
14:51:57 <mniip> one doesn't care what vs is, another requires that vs is explicitly anything
14:53:06 <mniip> which puts you in an interesting position when unpacking EI
14:53:45 <arkeet> so anyway the syntax is
14:53:52 <arkeet> data ExprW = forall vs. EI (Expr vs Int) | ...
14:54:10 <arkeet> which makes EI :: forall vs. (Expr vs Int -> ExprW)
14:54:14 <mniip> arkeet, don't forget to mention that you need forall after the | too
14:54:16 <arkeet> yes.
14:54:30 <mniip> as in, it binds tighter than |
14:54:36 <arkeet> so you can put in any Expr vs Int value you like, for any vs
14:54:49 <arkeet> but when you get it out (by matching against the EI constructor)
14:55:09 <arkeet> the only thing you can do with it pass it to stuff that is polymorphic in vs
14:56:35 <arkeet> because by putting it in EI, you lost all information about what vs was.
14:56:43 <mniip> you can also pattern match on Expr
14:56:49 <mniip> but only in ways that don't restrict what vs is
14:57:41 <arkeet> hm? how would a pattern match restrict that?
14:59:27 <begriffs> Hey all, random note: if you're in the Bay Area there's a Haskell meetup happening soon. http://www.meetup.com/Bay-Area-Haskell-Users-Group/events/224291255/
15:00:09 <arkeet> hm, I doubt I can make it up to SF by 6.
15:00:35 <arkeet> hm.
15:00:39 <begriffs> Talks start at 7 so maybe it could work out.
15:00:48 <johnw> begriffs: nice
15:00:58 <johnw> begriffs: I can probably make it
15:01:49 <begriffs> johnw: Cool!
15:02:31 <noisypop> Hello
15:09:30 <mniip> arkeet, look
15:09:57 <darkmercenary> hello, im trying to run some parallel code in ghci
15:10:08 <darkmercenary> however i look at my system monitor and i only see 1 cpu light up
15:10:10 <mniip> @letlpaste http://lpaste.net/5365246568905572352
15:10:11 <lambdabot>  Invalid paste ID.
15:10:18 <mniip> @letlpaste 5365246568905572352
15:10:19 <darkmercenary> is there something special i have to do? or do i have to compile
15:10:19 <lambdabot>  .L.hs:152:1:
15:10:19 <lambdabot>      Multiple declarations of â€˜Eâ€™
15:10:19 <lambdabot>      Declared at: .L.hs:145:1
15:10:25 <mniip> @undefine
15:10:25 <lambdabot> Undefined.
15:10:27 <mniip> @letlpaste 5365246568905572352
15:10:28 <lambdabot>  Defined.
15:10:40 <broma0> 'ReaderT X (ReaderT Y ..) ..' or 'ReaderT (X, Y) ..' - is the former considered a code smell?
15:10:51 <mniip> > case E (Free ()) of E (Free _) -> ()
15:10:52 <lambdabot>  ()
15:11:05 <mniip> > case E Constrained of E Constrained -> ()
15:11:06 <lambdabot>      Couldn't match expected type â€˜tâ€™ with actual type â€˜()â€™
15:11:06 <lambdabot>        â€˜tâ€™ is untouchable
15:11:06 <lambdabot>          inside the constraints (a ~ Maybe a1)
15:11:29 <arkeet> no, that's not the thing.
15:11:50 <mniip> that's precisely the thing
15:12:09 <mniip> Expr is a gadt, and some fields in it restrict what vs is, just like a is restricted in Constrained
15:12:24 <mniip> you cannot pattern match on those fields
15:13:14 <arkeet> ok I guess that is so.
15:13:40 <broma0> I am really struggling with the design/architechture of haskell programs.. does anyone know any general tips or documentation on this kind of thing? 
15:13:52 <mniip> interestingly, it looks like X is not a functor
15:13:59 <broma0> it seems like haskell is the only language without numerous articles around designing programs
15:14:05 <mniip> oh wait nevermind, a is phantom in Constrained
15:14:06 * hackagebot plot-gtk3 0.1.0.1 - GTK3 plots and interaction with GHCi  https://hackage.haskell.org/package/plot-gtk3-0.1.0.1 (VivianMcPhail)
15:14:32 <arkeet> mniip: but this works:
15:14:36 <mniip> oh actually, do mind
15:14:36 <arkeet> > let f (Free _) = 1; f Constrained = 2 in case E Constrained of E x -> f x
15:14:38 <lambdabot>  2
15:14:50 <arkeet> why should this work and the other thing not?
15:15:05 <mniip> :t let f (Free _) = 1; f Constrained = 2 in f
15:15:06 <lambdabot> Num a => X t -> a
15:15:27 <mniip> arkeet, interesting
15:15:50 <monochrom> arkeet: what is the not-work thing?
15:15:52 <mniip> I guess this wouldn't work if we had two ununifiable constraineds
15:16:06 <arkeet> monochrom: let's inline f.
15:16:08 <mniip> monochrom, see above, case E Constrained of
15:16:28 <arkeet> > case E Constrained of { E (Free _) -> 1; E Constrained -> 2 }
15:16:30 <lambdabot>  2
15:16:42 <mniip> ahhh of course
15:16:44 <arkeet> well.
15:16:50 <arkeet> > case E Constrained of { E Constrained -> 2 }
15:16:52 <lambdabot>      Could not deduce (Num t) arising from the literal â€˜2â€™
15:16:52 <lambdabot>      from the context (a ~ Maybe a1)
15:16:52 <lambdabot>        bound by a pattern with constructor
15:16:56 <mniip> it makes more sense now
15:16:58 <arkeet> ???
15:17:08 <arkeet> doesn't to me.
15:17:29 <arkeet> > case E Constrained of { E Constrained -> () }
15:17:31 <lambdabot>      Couldn't match expected type â€˜tâ€™ with actual type â€˜()â€™
15:17:31 <lambdabot>        â€˜tâ€™ is untouchable
15:17:31 <lambdabot>          inside the constraints (a ~ Maybe a1)
15:17:44 <mniip> arkeet, pattern matching on Constrained implies that the thing in E is of type X (Maybe a)
15:17:51 <mniip> while it's of type X (forall a. a)
15:17:59 <arkeet> ah.
15:18:13 <mniip> pattern matching on both Free and Constrained relaxes the inferred type
15:18:50 <mniip> because uh
15:19:09 <mniip> if it's not Maybe a, it can't be a Constrained
15:19:15 <mniip> so we can't reach this branch
15:19:33 <mniip> something about free theorems
15:19:44 <arkeet> huh?
15:19:51 <arkeet> it *is* Constrained in my example.
15:20:04 <mniip> ugh
15:20:17 <mniip> I have an intuitive understanding of it in my mind by I can't serialize it
15:20:19 <arkeet> I'm still confused.
15:20:22 <mniip> into words
15:20:34 <arkeet> > case E Constrained of { E Constrained -> (); _ -> () }
15:20:35 <lambdabot>  ()
15:20:41 <arkeet> no Free here.
15:21:00 <mniip> you are matching Free implicitly with _
15:21:04 <arkeet> am I
15:21:20 <arkeet> @let data Y a where { Fun :: Y (Maybe a) }
15:21:21 <lambdabot>  Defined.
15:21:32 <arkeet> @let data F = forall a. F (Y a)
15:21:33 <lambdabot>  Defined.
15:21:41 <arkeet> > case Y Fun of { Y Fun -> () }
15:21:43 <lambdabot>  Not in scope: data constructor â€˜Yâ€™Not in scope: data constructor â€˜Yâ€™
15:21:52 <arkeet> > case F Fun of { F Fun -> () }
15:21:53 <lambdabot>      Couldn't match expected type â€˜tâ€™ with actual type â€˜()â€™
15:21:53 <lambdabot>        â€˜tâ€™ is untouchable
15:21:53 <lambdabot>          inside the constraints (a ~ Maybe a1)
15:21:58 <arkeet> > case F Fun of { F Fun -> (); _ -> () }
15:21:59 <lambdabot>  ()
15:22:01 <arkeet> ????
15:22:20 <mniip> because
15:22:20 <arkeet> there is no other constructor.
15:22:25 <mniip> > undefined :: Y ()
15:22:27 <lambdabot>      No instance for (Show (Y ()))
15:22:27 <lambdabot>        arising from a use of â€˜show_M34040596308967649416171â€™
15:22:27 <lambdabot>      In the expression:
15:22:31 <mniip> sigh
15:22:38 <mniip> > :t undefined :: Y ()
15:22:39 <lambdabot>  <hint>:1:1: parse error on input â€˜:â€™
15:22:41 <arkeet> > case F undefined of { F Fun -> (); _ -> () }
15:22:43 <lambdabot>  *Exception: Prelude.undefined
15:22:46 <mniip> you get it
15:22:49 <arkeet> I don't.
15:22:59 <arkeet> > case F (undefined :: Y ()) of { F Fun -> (); _ -> () }
15:23:00 <lambdabot>  *Exception: Prelude.undefined
15:23:00 <mniip> a non-Maybe a can be packed into F
15:23:03 <mniip> for example undefined
15:23:31 <arkeet> so
15:23:40 <arkeet> why is it a type error?
15:23:43 <arkeet> why should it be?
15:23:47 <mniip> arkeet, okay, let's go to the beginning
15:24:24 <mniip> 'case x of Constrained -> _' implies that x is X (Maybe a)
15:24:28 <mniip> right?
15:25:42 <arkeet> a successful pattern match on Constrained gives us extra type information on the right of ->
15:25:55 <arkeet> as far as I understand it
15:25:56 <lamefun> Why does Parsec lacks built-in parsers for Text?
15:26:20 <arkeet> like what?
15:26:22 <mniip> arkeet, hmm
15:26:28 <lamefun> eg. like Attoparsec's takeWhile1 :: Parser Char -> Parser Text.
15:26:31 <mniip> arkeet, actually it might be a typechecker bug
15:26:39 <mniip> I'm not too sure if this is expected behavior
15:26:53 <arkeet> it's unexpected to me.
15:27:12 <mniip> I have an undertanding of what is happening on the inside
15:27:20 <mniip> but I don't know if that is the way it has to
15:28:19 <arkeet> lamefun: oh, so you mean stuff that produces Text values?
15:28:22 <arkeet> instead of stuff for parsing Text.
15:28:32 <arkeet> I dunno.
15:28:43 <Twey> It predates Text
15:29:07 <lamefun> Why wasn't it upgraded?
15:29:07 <arkeet> it can certainly parse Text.
15:29:35 <lamefun> I can of course use T.pack (P.many1 myCriteria), but can GHC make it fast?
15:30:13 <arkeet> GHC can't do that, I'm pretty sure.
15:30:25 <arkeet> I think attoparsec exists partially to support stuff like thta.
15:30:39 <arkeet> that*
15:32:19 <arkeet> I dunno. maybe it's possible to write that for parsec.
15:32:23 <mniip> arkeet, wow
15:32:30 <arkeet> ?
15:32:56 <mniip> looks like an actual bug
15:33:03 <arkeet> heh.
15:33:04 <mniip> gonna check with HEAD
15:33:28 <mniip> minimal example: data D a where D :: D ()
15:33:44 <mniip> '\x -> case x of D -> ()' is a type error while it should not be
15:33:53 <arkeet> mhm
15:34:10 <Twey> arkeet: It is, of course
15:34:29 <Twey> It might not be as fast, though
15:34:46 <arkeet> I mean something as fast.
15:35:14 <Twey> If Parsec were as fast as Attoparsec we wouldn't need Attoparsec
15:35:20 <arkeet> or at least something that can just produce a substring of the original Text.
15:35:28 <arkeet> instead of building up a new one.
15:38:59 <arkeet> at least, I think that's what attoparsec's does.
15:39:12 <arkeet> wait that doesn't make sense.
15:39:13 <arkeet> never mind.
15:43:42 <mniip> arkeet, more bizzare stuff
15:43:50 <ttt_fff> haskell is going to break my heart one day
15:44:01 <ttt_fff> there's no way one can continuously fall in love with haskell and not have it end up badly
15:44:04 <mniip> :t \x -> case x of D -> (); _ -> ()
15:44:05 <lambdabot> D t -> ()
15:44:08 <mniip> :t \x -> case x of D -> (); _ -> undefined
15:44:09 <lambdabot>     Couldn't match expected type â€˜râ€™ with actual type â€˜()â€™
15:44:09 <lambdabot>       â€˜râ€™ is untouchable
15:44:09 <lambdabot>         inside the constraints (t ~ ())
15:44:17 <arkeet> interesting
15:44:32 <mniip> wait what, r?
15:44:36 <arkeet> yeah, what's r
15:44:36 <arkeet> haha
15:44:40 <mniip> r means... renamer?
15:45:10 <mniip> arkeet, obviously it's a generated name, question is, what part generates r-names
15:45:17 <mniip> typechecker only generates t-names
15:47:14 <arkeet> hang on.
15:48:27 <quux> hi
15:48:32 <quux> how could i contribute to haskell?
15:48:46 <quux> oh hi conal, I really enjoyed that haskell to hardware talk
15:48:48 <arkeet> :t (\x -> case x of D -> ()) :: D a -> ()
15:48:49 <lambdabot> D a -> ()
15:49:08 <conal> quux: :D
15:49:11 <arkeet> mniip: ^
15:49:14 <mniip> arkeet, hmmm yeah, inference then?
15:52:16 <mniip> quux, did they invent something better than the STG machine?
15:52:29 <quux> im not sure
15:52:58 <mniip> you didn't listen ? :v
15:53:54 <arkeet> mniip: yeah, seems like an inference thing
15:54:26 <adarqui> just saw a horse race happened today at the "haskell invitational": http://www.nytimes.com/2015/08/03/sports/american-pharoah-wins-haskell-invitational.html?_r=0
15:54:32 <mniip> arkeet, I'm building GHC HEAD now
15:54:41 <arkeet> ok
15:57:42 <mniip> [00:46:39] <quux> how could i contribute to haskell?
15:57:46 <mniip> generally you write code
15:57:52 <quux> thanks buddy
15:58:03 <mniip> however you can start with small things like me, I'm currently preparing a bug report
15:59:08 * hackagebot lzma-streams 0.0.0.0 - IO-Streams interface for lzma/xz compression  https://hackage.haskell.org/package/lzma-streams-0.0.0.0 (HerbertValerioRiedel)
15:59:16 <mniip> quux, there's many codes to write :) GHC is a huge project in itself, but you also have base libraries, non-base libraries, and libraries in general!
15:59:32 <mniip> hm, s/libraries/packages/
16:02:06 <juri_> does anyone here use optparse-applicative? I'm having problems parsing a Float||Double.
16:03:27 <juri_> oh, weirder. i'm not able to parse any values.
16:13:53 <ttt_fff_> besides template-haskell and cpphs, does haskell have any other metaprogramming tools?
16:17:35 <sgronblo> any idea why stack install ghc-mod worked in ~ but failed inside my ~/projects directory (or more like didnt do much)
16:21:51 <juri_> any ideas why my optparse applicative parser will not parse any values?
16:22:32 <mniip> arkeet, alright, behavior identical in GHC HEAD
16:23:03 <naudiz> sgronblo: isn't ghc-mod completely broken?
16:29:12 <mazur> is there a way to safely clean up a .cabal directory? mine's about 2.4G, it looks like there are multiple ghc versions in lib/share
16:34:34 <genericpersona> > map toTitle "anal buck shot"
16:34:35 <lambdabot>  "ANAL BUCK SHOT"
16:34:55 <genericpersona> ah hah
16:35:10 <juri_> um.
16:35:29 <juri_> ok, worse. the only thing that my parser parses is "Nothing".
16:35:46 <juri_> because i am parsing a Maybe Filepath..
16:42:22 <srhb> juri_: Paste some code on lpaste.net :)
16:46:29 <juri_> http://lpaste.net/137812
16:47:56 <srhb> juri_: Beautiful formatting :-)
16:47:58 <juri_> optparse for any of those values other than the input file (the last item) or the --xmlerror only accepts Nothing.
16:49:09 <juri_> thanks. I'll pass that on to the original author. i'm a stand-in. :)
16:49:10 * hackagebot microlens 0.1.2.0 - A tiny part of the lens library which you can depend upon  https://hackage.haskell.org/package/microlens-0.1.2.0 (Artyom)
16:49:49 <mniip> arkeet, filed! https://ghc.haskell.org/trac/ghc/ticket/10729
16:50:09 <arkeet> cool
16:50:30 <srhb> juri_: So I haven't used this in a while, but afaik auto will just use the Read instance for that specific field
16:50:57 <srhb> juri_: ie. the output option SHOULD parse things like -o "Just /my/path"
16:51:11 <juri_> I've tried. nope!
16:51:30 <srhb> But it works with -o Nothing ?
16:51:38 <juri_> and, that 'Just' should not be necessary.
16:51:39 <juri_> indeed.
16:51:57 <srhb> Oh, right, because of option
16:52:06 <juri_> option -f: cannot parse value `Just'
16:52:19 <juri_> no change if i surround it with quotes.
16:53:06 <mniip> juri_, does it still only mention Just if you add quotes?
16:54:10 * hackagebot microlens-mtl 0.1.2.0 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.2.0 (Artyom)
16:54:12 * hackagebot microlens-th 0.1.2.0 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.1.2.0 (Artyom)
16:55:19 <juri_> option -o: cannot parse value `Just example5.stl'
16:56:06 <juri_> so, not only is it not 'stripping' the Just, but its not working.
16:56:12 <fr33domlover> Hello! Looking for some advice: I'd like to write a program that listens on HTTP, receives JSON files in POSTS requests and reacts (e.g. by sending things to email and IRC). Ideally there would be a separate library into which arbitrary hooks can be plugged, but not critical
16:56:23 <fr33domlover> What would be a good tool to use for the web listener?
16:56:41 <fr33domlover> (it's not a web app, no HTML is returned from it)
16:57:13 <srhb> juri_: Can you show us how to run the parser?
16:57:33 <dramforever> so you are asking about the "listening" part and the "receives" part?
16:57:56 <dramforever> actually that reminds me of something really nice
16:58:02 <dramforever> @hackage servant
16:58:02 <lambdabot> http://hackage.haskell.org/package/servant
16:58:03 <fr33domlover> darkmercenary, yes. I found the http-server package, which handles requests in separate threads
16:58:07 <juri_> edited.
16:59:33 <fr33domlover> dramforever, thanks. But the API isn't mine - I'm writing a web hook for a git server
16:59:46 <fr33domlover> so they define the API, my code is just a simple listener
16:59:52 <juri_> oh, and there's my reader for format.
16:59:55 <dramforever> oh wait what do you mean by listener?
16:59:56 <dramforever> server?
17:00:04 <fr33domlover> dramforever, http://gogs.io/docs/features/webhook.html
17:00:22 <dramforever> well what difference does it make?
17:00:28 <dramforever> sure you can use servant
17:00:38 <fr33domlover> dramforever, idk, servant just looks like a big thing :P
17:00:43 <dramforever> =)
17:01:05 <dramforever> don't worry if you know the format of the data that gogs.io will send you
17:01:16 <dramforever> you can define a similar data type in haskell
17:01:23 <dramforever> and write json instances for it
17:01:35 <dramforever> and you can use them nicely with your listener code
17:01:53 <dramforever> that's even easier if you only need a part of the data
17:02:35 <srhb> juri_: I don't think Maybe is stripped
17:02:51 <sm> you could also just use wai
17:03:00 <juri_> shrb: it used to be, in optparse 0.9.1.1
17:03:19 <srhb> juri_: So try: ./yourprogram -o "Just \"escapedpath\"" foo
17:03:32 <juri_> this is an attempt to upgrade my code to work with the newest optparse.
17:04:02 <juri_> holy wow. that works.
17:05:17 <fr33domlover> dramforever, I already wrote the FromJSON instances using aeson
17:05:33 <dramforever> I'm not sure about servant
17:05:38 <dramforever> you should look into it
17:05:49 <fr33domlover> it looks much smarter than what I need
17:06:12 <fr33domlover> I just need to listen to POSTs on a single URL basically
17:06:20 <fr33domlover> bare-bones http server
17:07:32 <mniip> fr33domlover, you need about 15 lines for that
17:08:01 <fr33domlover> mniip, i imagine open a socket -> listen -> parse the HTTP message -> do my thing
17:08:05 <juri_> srhb: ok, now that you'ze helped me with that, how do i 'strip' the Just?
17:08:11 <fr33domlover> but is there a good simple package for that? :P
17:08:15 <srhb> juri_: I think you'll need to use optional instead of option
17:08:25 <Sindriava> What's the Double version of Integral?
17:08:25 <srhb> Or both, I can't quite recall. let me look.
17:08:29 <mniip> fr33domlover, socket->listen->fork
17:08:36 <juri_> thank you. :)
17:08:38 <Sindriava> e.g. how do I generalize a floating point type?
17:08:39 <srhb> Sindriava: Floating ?
17:08:43 <mniip> in the thread you read->parse->handle->serialize->exit
17:08:50 <Sindriava> srhb: Oh. Now I feel dumb.
17:08:59 <srhb> Sindriava: They don't really map one to one...
17:09:18 <Sindriava> srhb: I know, but I don't want to use "Double", since I'm working with OpenGL
17:09:21 <srhb> Sindriava: Probably you want Fractional
17:09:43 <srhb> Sindriava: The easy way to go about this is to ask for the types of the functions you want to generalize
17:09:46 <Sindriava> srhb: Wellâ€¦ Does every float have to be fractional? What about `pi`, for example?
17:09:49 <srhb> :t (/)
17:09:50 <lambdabot> Fractional a => a -> a -> a
17:09:56 <srhb> So division requires Fractional
17:10:04 <Sindriava> srhb: Oh yeah, that's smart
17:10:21 <Sindriava> srhb: It's 3AM ^^' I'll make do, thanks!
17:10:25 <srhb> Sindriava: and you can probe the classes with :i Fractional -- in ghci
17:10:28 <srhb> OK :)
17:11:03 <Gurkenglas> Does lambdabot have a reason not to support it beyond nobody bothering to implement it?
17:11:30 <monochrom> sorry, what is "it"?
17:11:43 <geekosaur> you mean :i? mostly because it's a lot of output usually
17:11:46 <geekosaur> I suspect
17:12:09 <mniip> arkeet, interesting
17:12:14 <mniip> arkeet, closed as not a bug
17:12:43 <monochrom> ah, yeah, :info can seriously spam with millions of "instance" lines
17:12:56 <Sindriava> srhb: Wait, "Couldn't match expected type â€˜GLfloatâ€™ with actual type â€˜aâ€™ "
17:13:02 <dramforever> you know there's a thing called @more
17:13:07 <Sindriava> srhb: GLfloat is aliased to Float, am I missing something?
17:13:34 <srhb> Sindriava: You're trying to say "my function works for any Fractional a" but you're lying, and the type checker calls you out. It only works for GLFloats
17:13:53 <Sindriava> srhb: Oooooooh
17:13:54 <sm> Gurkenglas: if you mean @seen, it was disabled by the operator, IIRC due to being inefficient
17:14:15 <Sindriava> srhb: Can I type constrain a data definition? Or is that an antipattern?
17:14:24 <srhb> Sindriava: I don't even know what that means. :)
17:14:55 <Sindriava> srhb: Fractional a => data X a = â€¦
17:14:58 <nullvoid8> Srhb: they mean existensials. Massive antipattern these days
17:14:59 <srhb> Sindriava: No.
17:15:03 <Sindriava> Woop.
17:15:10 <srhb> (Yes, but) no. :-)
17:16:21 <Sindriava> srhb: Well, I have an Object type, which has a list of vertices, which are of the type `V3 GLfloat`â€¦ How would I go about making that generalised to Fractional?
17:18:06 <srhb> juri_: optional (strOption ( short 'o' ... -- and get rid of the default values
17:18:26 <srhb> juri_: When optional fails it produces a Nothing
17:18:55 <srhb> Sindriava: I don't think that is your problem. I think your function uses some GL functions that only work on GLFloats
17:18:59 <srhb> Sindriava: But I'm not sure.
17:19:25 <srhb> Sindriava: If that is the case, you would need some function fromFractional that may produce whatever kind of GLFloat needed.
17:19:30 <Sindriava> srhb: It doesn't, it's just trying to create an Object, which has "vertices", which are of the type [V3 GLfloat]
17:19:44 <srhb> Er, fromRational probably.
17:20:01 <Sindriava> srhb: I'll paste the code for you, gimme a sec
17:20:05 <srhb> :)
17:20:46 <juri_> srhb: sure, but having to type the "Just" in the input is what i'm talking about.
17:20:52 <Sindriava> srhb: http://lpaste.net/137815
17:21:03 <srhb> juri_: Yes, you don't want that, correct?
17:21:08 <srhb> juri_: If so I just gave you the answer.
17:21:10 <juri_> right.
17:21:18 <juri_> ok.. i'll try it. :)
17:21:21 <haasn> I'm thinking about ways to write a â€˜reversibleâ€™ parser, eg. something like parsec but where parsing, say, â€˜anyCharâ€™ would internally remember which Char it parsed; and this metadata would get spit out alongside the parse result in such a way that you could recombine it to produce the original input from the parsed data structure
17:21:38 <haasn> And I would additionally want to make it so you could *change* a part of the data structure while preserving the rest of the source
17:21:39 <johnw> haasn: this has been done a few times
17:21:47 <haasn> johnw: neat, that's what I was hoping. links?
17:22:13 <johnw> http://hackage.haskell.org/package/syntax
17:22:21 <srhb> Sindriava: I don't understand the point of this. Your data type obviously only admits GLFloats, so why take more types? That's just begging for trouble
17:22:44 <Sindriava> srhb: THAT'S what I'm asking about, how to make the data type admit any Fractional type
17:22:50 <haasn> johnw: Ah, my goals are not to pretty-print but to reproduce the original input. For example, say the user has a particular style of indenting, and also several comments
17:22:52 <nullvoid8> Sindriava: parametise object with the contents of the V3, then constrain it as appropriate for each function at the function
17:22:52 <Sindriava> srhb: It doesn't need GLfloat
17:23:06 <johnw> haasn: that couldn't just be considered a kind of pretty printing
17:23:14 <Sindriava> nullvoid8: That's an obvious and painful solution I was trying to avoid, sadly
17:23:17 <johnw> where "pretty" means semantics preserving syntax
17:23:20 <johnw> http://www.informatik.uni-marburg.de/~rendel/unparse/
17:23:25 <haasn> johnw: My parser would ignore whitespace and comments and spit out the parsed data structure, but then I want to modify and â€œrewriteâ€ this file with the original whitespace and comments as-is
17:23:29 <Sindriava> nullvoid8: Parametrising the whole object seems a bit overkill
17:23:35 <nullvoid8> Unfortunately, I'm on a tablet so typing code is tricky
17:23:54 <johnw> haasn: I see, you want an annotation to your ADT that preserves the original context
17:24:00 <srhb> Sindriava: There is no (ever) implicit coercion, so the values you stick in, say, the vertices field, MUST be GLFloats. If you want to convert, check if GLFloat is a member of the Rational class and then use fromRational on your input parameter
17:24:02 <haasn> more or less
17:24:24 <srhb> Sindriava: ie let myMagicallyConvertedArguement = fromRational myOriginalArguement in yourCode
17:24:24 <nullvoid8> If you use existensials, you can't have functor, applicative, etc, which are really useful
17:24:37 <haasn> johnw: so if I have, say, â€œanyWord *> parseBool <* anyWordâ€ and the user inputs â€œfoo True Barâ€, my parser outputs â€˜Trueâ€™, but I can change this to â€˜Falseâ€™ and run it backwards through the parser and get back â€œfoo False barâ€
17:24:41 <haasn> â€œfoo False Barâ€ even
17:24:47 <srhb> Sindriava: I think this is horrible, by the way. Let the caller deal with any necessary conversion if needed. :)
17:24:50 <nullvoid8> So this really is the best approach
17:24:51 <johnw> haasn: I've seen that before too, in the context of generalizing annotations using recursion schemes
17:24:59 <johnw> haasn: interesting
17:25:12 <johnw> so your parse result is a lens then
17:25:14 <Sindriava> srhb: Fair enough.
17:25:19 <johnw> view it and you get the parsed result
17:25:27 <haasn> johnw: yes exactly
17:25:33 <Sindriava> srhb: I'm just more or less used to doing "Integral", so this seemed like a logical step
17:25:35 <srhb> Sindriava: But yes, if your data type does NOT need to be so constrained, what nullvoid8 is saying is the reasonable approach :)
17:25:36 <haasn> I hadn't thought of it like that
17:25:40 <johnw> Parser (Lens' (Annotated Foo) Foo)
17:25:51 <lamefun> Uhm... made a simple version module with Attoparsec parser --> from 800KB to 6.4MB (stripped), is that how it's supposed to be?
17:25:55 <lamefun> (ie. `main = print $ Atto.parseOnly (Ver.requestParser <* Atto.endOfInput) "2.4.3-alpha.1 || (>= 3.2.0 && < 3.4.2) || 1.2"`).
17:26:04 <srhb> Sindriava: ie. if you're fine with data Object a b = ...a ... b ... -- you can get the behaviour you want. :)
17:26:06 <johnw> where Foo has a pretty-printer, and Annotated Foo prints to the original text
17:26:07 <Sindriava> srhb: Not really, parametrising the data type would be dumb, since it's ever only really going to use GLfloats in this case, I guess
17:26:15 <srhb> Sindriava: It's not _that_ dumb.
17:26:23 <srhb> Sindriava: Your functions will still constrain you from making funny Objects.
17:26:24 <dramforever> Sindriava: then don't generalize
17:26:36 <srhb> But indeed, no need for senseless generalization :(
17:26:36 <Hijiri> is there a wrapper function like alloca, except instead of the result of alloca f being the result of (f ptr), the result is the final value of ptr
17:26:48 <haasn> johnw: An example could be a JSON file with comments. I want to write a front-end to modify this JSON file with a GUI, while preserving comments that were in the source
17:26:48 <dramforever> because, as srhb says, that'll make funny results
17:26:55 <Sindriava> Having to type "Object GLfloat" everywhere is more work and less generalisation that just sticking to GLfloat in the first place
17:27:04 <srhb> Yes. :)
17:27:10 <haasn> johnw: Another interesting challenge could be, say, â€œpreserving the indentation levelâ€
17:27:11 <srhb> But that's what type synonyms are for
17:27:14 <srhb> (if you really needed it)
17:27:16 <dramforever> Hijiri: why can't you just peek the ptr in the end?
17:27:17 <johnw> haasn: gotta run, but it sounds like an interesting problem
17:27:19 <haasn> I'm not really sure where to go with this. It seems to complicated and difficult
17:27:23 <Sindriava> srhb: Fair enough
17:27:28 <Hijiri> dramforever: I defined my own function that does that
17:27:36 <Hijiri> but I was wondering if I missed a "standard" one
17:27:42 <srhb> Sindriava: I mean, type OGL = Object GLFloat isn't terrible :)
17:27:57 <Hijiri> it comes up often if you use C FFI functions that use an output pointer
17:28:08 <Sindriava> srhb: Yeah, but using OGL everywhere then defeats the point of generalization in the first place
17:28:11 * srhb nods
17:28:22 <Sindriava> since the function would then produce OGL and might as well take a GLfloat as an argument
17:28:25 <srhb> Yep.
17:28:41 <Sindriava> Anyways, thanks for the help ^^
17:28:47 <srhb> You're welcome. And sleep tight. ;)
17:29:00 <Sindriava> Hah, no sleep for me, sadly :D
17:29:07 <lpaste_> louispan pasted â€œIndexed Monad DVDDriveâ€ at http://lpaste.net/137816
17:29:09 <Sindriava> Asking stuff on #haskell is always pleasant.
17:29:13 <srhb> Oh OK. Thought that was what 3 AM implied.
17:29:18 <srhb> (It's only half to three here)
17:29:49 <Sindriava> Beats some other channels (*cough* anything remotely C++ related *cough*)
17:29:59 <Sindriava> srhb: Yeah, I don't sleep that well, I mostly work at night
17:30:03 * srhb nods
17:30:44 * nullvoid8 wishes he could still be nocturnal
17:31:23 <lpaste_> louispan revised â€œIndexed Monad DVDDriveâ€: â€œIndexed Monad DVDDriveâ€ at http://lpaste.net/137816
17:32:53 <Gurkenglas> sm, I meant :i, and I'll now go look why @seen is inefficient. Is there some way I can view https://hackage.haskell.org/package/lambdabot-social-plugins-5.0.1/docs/src/Lambdabot-Plugin-Social-Seen.html#seenPlugin in that fancy new hackage source style with the hyperlinking?
17:33:13 <juri_> srhb: that broke it further.
17:33:23 <srhb> juri_: I disbelieve this! (since I tested it.)
17:33:29 <juri_> now it does not accept 'Just "filename"'
17:33:39 <srhb> Wait, I thought that's exactly what you did not want.
17:33:40 <louispan> Hi, I'm trying to understand the compile pigworker's example of using indexed monads to model inserting dvds into DVD drives (http://stackoverflow.com/questions/28690448/what-is-indexed-monad).
17:33:41 <louispan> The code uses DataKinds, and I'm having trouble making an instance of IxMonad with kind â€˜Bool -> Bool -> * -> *â€™.
17:33:41 <louispan> http://lpaste.net/137816
17:33:42 <louispan> What am I doing wrong?
17:33:42 <juri_> and does not accept 'filename'.
17:33:43 <srhb> I thought you wanted "filename"
17:33:46 <srhb> Huh
17:34:16 <juri_> option -o: cannot parse value `example5.stl'
17:36:00 <srhb> juri_: Paste please :)
17:37:12 <juri_> oh.
17:37:16 <juri_> nvm.
17:37:20 <juri_> got it working.
17:37:32 <juri_> :D
17:37:56 <srhb> juri_: :)
17:39:59 <mniip> louispan, interesting
17:40:22 <mniip> louispan, what version of category-extras
17:40:46 <juri_> srhb: and what do i do abot float?
17:42:10 <srhb> juri_: You'll have to define something akin to str which can be used with option like: optional (option floaty ( ...
17:42:21 <mpickering> louispan: I've run into this before, it's because the MonadIx class isn;t polykinded in that package
17:42:36 <juri_> Joy. ;P
17:42:42 <mpickering> just write out the definition yourself with PolyKinds turned on
17:43:08 <mniip> mpickering, oh, I assumed IxMonad is polykinded while IxFunctor is not
17:43:16 <mniip> since only one  error message was provided
17:43:20 <mniip> hence the confusion
17:43:45 <Hijiri> ixset is probably what I want if I want a map indexed by two values, right
17:44:00 <Hijiri> or is ixset-typed more modern
17:44:27 <sgronblo> naudiz: what do you mean completely broken?
17:44:28 <Hijiri> I want to index something that has a duration by its start time and end time
17:44:45 <mniip> (,) ?
17:45:04 <Hijiri> I mean indexed separately by start time and end time
17:45:32 <Hijiri> so I can tell if something is happening, by taking the intersection of things that have started and things that have not ended
17:45:35 <mniip> ah, so like lookup by 2 separate keys?
17:45:39 <Hijiri> yeah
17:46:22 <mpickering> mniip: I don't think IxMonad is polykinded either I think I have a patched version of the library lying around somewhere which was more effort than reasonable to get everything polykinded
17:46:23 <mniip> I think you want a set of event events
17:46:44 <mniip> like
17:46:46 <srhb> juri_: Or maybe just optional (option auto ( ...
17:46:47 <naudiz> sgronblo: incompatible with current versions of cabal and ghc
17:46:51 <srhb> juri_: That should work everywhere I guess.
17:46:59 <mniip> 2 types of objects: event beginning and event end
17:47:01 <srhb> juri_: You should define an alias for that :)
17:47:12 <srhb> juri_: "optionally" :-)
17:47:19 <sgronblo> naudiz: yeah im trying to figure out exactly what the problem is right now
17:47:30 <mniip> you can maintain some neat data if you keep them sorted
17:47:40 <Hijiri> I guess that would work
17:47:44 <mniip> (effortlessly)
17:47:46 <Hijiri> and would have less overhead than ixset
17:48:05 <mpickering> louispan: Does that make sense?
17:48:18 <mniip> like how many events are happening at a given moment
17:48:23 <Hijiri> actually my situation is slightly more complicated, maybe I should have explained
17:48:47 <Hijiri> There is a "window" of time, and you can see all of the things that are happening in that window
17:49:10 <naudiz> sgronblo: according to github it's a change from plaintext to binary at some point. but I don't know the details. There was a good alternative, though
17:49:32 <mniip> you mean you need to clip a list of intervals into a window of time?
17:50:03 <Hijiri> I need to know if part of the intervals are in the window
17:50:16 <mniip> if any part?
17:50:19 <Hijiri> yeah
17:50:20 <sgronblo> naudiz: yep, i have kind of figured out that much too
17:50:24 <Hijiri> I guess event system could still work
17:50:36 <mniip> you don't need to know which?
17:50:39 <Hijiri> nope
17:50:57 <louispan> mpickering: I'm still parsing your answer
17:51:04 <mniip> yeah create 2 entities for each event, a beginning and an end
17:51:21 <mniip> keep them in a balanced binary tree (like Set)
17:51:39 * dramforever knows something about that interval thing!
17:52:04 <mniip> hmm no
17:52:10 <mniip> you need more than set
17:52:13 <naudiz> sgronblo: sorry, can't remember the name of the alternative and I'm not on my home machine right now. I'm sure someone else could help out
17:52:13 <dramforever> are the intervals known in advance?
17:52:46 <mniip> you build a Set-like structure that additionally keeps a number of beginnings-endings
17:53:14 <dramforever> what about a full-fledged interval tree?
17:53:55 <mniip> then you lookup the beginning in the set-thing, and see if the number in that place is 0 (that is, the begninning is not inside any events)
17:54:31 <mniip> then you look for an object to the left, and see if it is after the end of the window (whether any events begin in the window)
17:54:32 <dramforever> Hijiri: this matters a lot: are the intervals known in advance?
17:54:48 <dramforever> or the set be modified dynamically
17:54:53 <mniip> dramforever, you mean whether this is an online problem?
17:54:57 <dramforever> yep
17:55:12 <mniip> yeah if it's a one-time thing you can't go better than O(N)
17:55:30 <mniip> if you have M requests, you can go O(N + MlogN)
17:55:37 <dramforever> yes
17:55:48 <louispan> mpickering: I think I understand now. I'll copy the IxMonad code in my source file directly, and enable PolyKinds and see if the error goes away.
17:55:54 <Hijiri> dramforever: yes
17:55:58 <mniip> no wait, O((N+M)logN)
17:56:06 <dramforever> mniip: oh yes yes
17:56:17 * dramforever didn't look carefully...
17:56:23 <mpickering> louispan: yes that's what I'm suggesting
17:56:36 <juri_> srhb: thank you kindly. :)
17:56:42 <mniip> louispan, I don't think that is all that is necessary
17:56:59 <mniip> I think you'll have to kind-annotate the typeclass but I'm not too sure
17:58:01 <dramforever> Hijiri: so you basically sort all the time points and get the indices
17:58:56 <dramforever> for example say we have [10, 40] [20, 30] [35, 40], we transform that into [1, 5] [2, 3] [4, 5]
17:59:15 <dramforever> along with a map 10 -> 1, 20 -> 2, 30 -> 3,...
17:59:28 <dramforever> a Set from Data.Set could do that
18:00:40 <louispan> mpickering: mniip: Well, enabling PolyKinds has changed the error. No instance for (IxFunctor DVDDrive) arising from the superclasses of an instance declaration In the instance declaration for â€˜IxPointed DVDDriveâ€™ [haskell/hdevtools]
18:01:41 <mpickering> I suggest you implemented IxFunctor DVDDrive as well then :)
18:01:45 <mpickering> *implement
18:01:51 <mniip> dramforever, I see where you're going
18:02:22 <dramforever> you need a Map Int Int with each value initally set to 0 and, for each interval [a, b], increment at key a, and if b+1 is in bounds, decrement at key (b + 1)
18:02:27 <mniip> but how do you make an interval tree in haskell?
18:02:39 <dramforever> dunno but it seems possible
18:02:43 <mniip> that takes O(N^2)
18:02:44 <dramforever> however this is much easier!
18:02:51 <mniip> not really
18:02:52 <dramforever> mniip: mine?
18:02:58 <mniip> yep
18:03:03 <dramforever> why?
18:03:05 <mniip> all the incrementation takes O(N^2)
18:03:11 <dramforever> no
18:03:14 <mniip> yes!
18:03:20 <louispan> mpickering: Ah! my bad. Serves me right for not reading the error properly.
18:03:20 <dramforever> we only have 2N incrementations
18:03:27 <Hijiri> if we are going for ease I think it would just be easiest to just use an ixset indexed by beginning and end times, but I don't know how costly that is
18:03:27 <dramforever> Hijiri: hello?
18:03:28 <mniip> no
18:03:35 <dramforever> okay
18:03:47 <mniip> you have ~N incrementations each covering ~N indices
18:03:57 <dramforever> oh you misunderstood me
18:04:14 <dramforever> I increment at one position, and decrement at another
18:04:20 <mniip> ah
18:04:21 <dramforever> then there's a thing called scanl
18:04:26 <mniip> and then a scan
18:04:27 <mniip> right
18:04:51 <dramforever> so you know how many things are happening in each interval [a, a+1]
18:05:24 <dramforever> hmm...you need to destruct the map into values and reconstruct one
18:05:30 <mniip> that sounds inefficient to me
18:05:31 <dramforever> but that's not too costly, I suppose
18:06:07 <louispan> mpickering: Thank you for your quick help. For this example I removed the IxFunctor constraint, so I didn't have to worry about implementing imap. This channel is awesome 
18:06:12 <Hijiri> wait, I'm really sorry, I actually need to be able to get the start and end times, after knowing it's in the window
18:06:23 <Hijiri> I'm busy for like 10 minutes, but I can just give the concrete problem after I get back
18:06:31 <Hijiri> so I don't make more inaccuracies
18:06:34 <dramforever> okay np =P
18:06:49 <dramforever> mniip: wait you need yet another scan
18:07:05 <dramforever> oh no screw it
18:07:07 <dramforever> screw it
18:07:09 <dramforever> screw it
18:08:03 <dramforever> mniip: f**k this interval problem
18:08:10 <louispan> Is it possible to enable PolyKind in an external package?
18:08:53 * dramforever consults the book
18:14:06 <dramforever> wow idea
18:14:44 <lpaste_> jgcoded pasted â€œNo titleâ€ at http://lpaste.net/137819
18:16:23 <lpaste_> jgcoded pasted â€œNo titleâ€ at http://lpaste.net/137820
18:16:30 <jgcoded> Hello, I'm trying to run this: http://lpaste.net/137819, but I get an error on GHCi saying this: http://lpaste.net/137820
18:17:14 <dramforever> @hoogle String -> Text
18:17:15 <lambdabot> Data.Text.Lazy pack :: String -> Text
18:17:15 <lambdabot> Data.Text pack :: String -> Text
18:17:15 <lambdabot> Prelude read :: Read a => String -> a
18:17:19 <Gurkenglas> Go to your ghci and say :t text
18:17:23 <dramforever> jgcoded: ^
18:18:26 <jgcoded> ah the pack function fixed it
18:18:40 <dramforever> WOW
18:18:46 <dramforever> pairing heaps *ROCK*
18:19:14 * hackagebot esqueleto 2.2.11 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-2.2.11 (FelipeLessa)
18:19:36 <jgcoded> thanks guys
18:20:18 * dramforever will definitely learn more about it
18:24:00 <Hijiri> dramforever: mniip: back.  Right now it's just brainstorming, but I have been thinking that I want to write a clone of a keyboarding rhythm game
18:24:15 <dramforever> +1 brainstorming
18:24:33 <dramforever> Hijiri: oh so lucky I know about keyboarding rhythm games
18:24:37 <Hijiri> ok
18:24:44 <Hijiri> have you played osu!mania? (or beatmaniaish games)
18:24:52 <dramforever> no =(
18:24:56 <dramforever> what's it like?
18:25:15 <Hijiri> you have one or more vertical lanes, where incoming notes are displayed
18:25:17 <Gurkenglas> ->#haskell-game?
18:25:26 <dramforever> Gurkenglas: maybe #haskell-algo
18:25:28 <Hijiri> There is a spot at the bottom representing the current time, and you need to press buttons when it gets there
18:25:35 <dramforever> Hijiri: okay I know
18:25:48 <Hijiri> One kind of note element is an interval you have to hold down, and release at the end
18:25:48 <Gurkenglas> But that one is empty
18:26:04 <dramforever> Hijiri: great I know about that too
18:26:06 <Hijiri> and I was thinking about how to implement those
18:26:27 <dramforever> so all the notes are discrete right?
18:26:30 <Hijiri> yes
18:26:35 <Hijiri> and two intervals won't interlap on the same lane
18:26:44 <Hijiri> so I can keep track of each lane separately
18:26:46 <dramforever> okay
18:27:20 <Hijiri> a typical map might have hundreds or thousands of notes, maybe less for intervals
18:27:32 <dramforever> yes I understand that too
18:27:48 <dramforever> in fact, I just finished watching a video of someone playing such a game
18:27:55 <dramforever> coincidence!
18:28:16 <dramforever> where "just" = a while before you came back
18:28:51 <Hijiri> oh, nice
18:29:08 <dramforever> Hijiri: what about this: for each lane, store a list of [(Time, Event)]
18:29:14 <dramforever> where Time could be just int
18:29:15 <dramforever> Int
18:29:42 <dramforever> and data Event = Event Int
18:29:50 <dramforever> wait Event could be just Int too
18:29:56 <Hijiri> and it's the duration?
18:30:00 <Hijiri> or end time
18:30:03 <dramforever> duration
18:30:16 <dramforever> actually it doesn't matter, maybe end time is easier
18:30:17 <Hijiri> this would work with floating point types too, right?
18:30:37 <dramforever> yeah
18:30:46 <dramforever> oh let's use end time
18:30:58 <dramforever> Hijiri: you need to have the list sorted by time
18:32:12 <dramforever> and at each tick, throw old events, and draw the current one
18:33:02 <Hijiri> throw?
18:33:15 <Hijiri> throw away?
18:33:21 <dramforever> sorry that was unclear
18:33:27 <Hijiri> and does old mean not on the screen anymore
18:33:32 <dramforever> yes
18:33:40 <dramforever> actually you should get yourself a queue
18:34:57 <dramforever> Hijiri: what about this:
18:35:11 <dramforever> you maintain a state consisting of a queue and a list
18:35:17 <dramforever> where the queue is the current notes
18:35:39 <dramforever> and the list is the remaining ones
18:35:52 <dramforever> at each tick
18:36:23 <Hijiri> and since the queue is monotonically increasing in time, I can just stop throwing away things after I get to the first non-old thing?
18:36:28 <dramforever> yes
18:36:28 <Gurkenglas> What was so inefficient about lambdabots @seen?
18:36:45 <dramforever> Hijiri: and when drawing just traverse the queue
18:37:34 <Hijiri> and then I could combine this with normal notes too, since notes don't occur during an interval (on the same lane)
18:37:44 <Hijiri> and make Event an ADT with notes and intervals alternatives
18:37:59 <dramforever> oh yep
18:38:10 <dramforever> that's much easier than the interval proble
18:38:14 <dramforever> *problem
18:38:17 <dramforever> =P
18:38:38 <Hijiri> alright, thanks for the help
18:38:42 <Hijiri> I'll write this down in my notes
18:38:44 <dramforever> yw
18:39:06 <Hijiri> as long as I don't try to do something crazy like reversing the song
18:39:17 <Hijiri> maybe that could be done with a zipper, with a queue in the middle
18:39:33 <dramforever> hmm...
18:39:40 <Hijiri> wait, that wouldn't work
18:39:41 <dramforever> looks like manipulation is another problem
18:39:52 <Hijiri> because the indicator for the notes is at the bottom of the screen
18:40:00 <Hijiri> (or top)
18:40:07 <Hijiri> in the opposite direction you wouldn't be able to see it coming
18:40:22 <Hijiri> I guess the indicator could just be placed in the middle
18:40:29 <Hijiri> sacrificing space
18:40:40 <Hijiri> I doubt I'll actually try to implement that though
18:41:01 <Hijiri> I'm not going to need to change the notes mid-game
18:44:15 * hackagebot ig 0.3.1 - Bindings to Instagram's API.  https://hackage.haskell.org/package/ig-0.3.1 (FelipeLessa)
18:44:36 <bmurphy1976> how do I go from type â€˜SDL.Rectâ€™ to expected type â€˜GHC.Ptr.Ptr SDL.Rectâ€™ ?
18:45:36 <Hijiri> bmurphy1976: I would look at the function 'with' in https://hackage.haskell.org/package/base-4.8.1.0/docs/Foreign-Marshal-Utils.html
18:46:04 <Hijiri> alternatively you can use 'new', but 'with' will handle the allocation for you
18:46:17 <broma0> Can someone help me understand a small part of a SO answer related to large-scale design in haskell? 
18:46:26 <bmurphy1976> Hijiri: ok that makes sense, I think I saw with used elsewhere
18:47:19 <Hijiri> something like with rect (\ptr -> with ptr $ \ptrPtr -> ...)
18:48:03 <broma0> The question is http://stackoverflow.com/questions/3077866/large-scale-design-in-haskell
18:49:31 <broma0> What the heck does this mean: "Monads capture key architectural designs in types"? How!?
18:50:22 <hodapp> broma0: you'll note that right after that is: "(this code accesses hardware, this code is a single-user session, etc .)"
18:50:58 <hodapp> things like this are a common way to use monads - they may enforce certain kinds of access/use patterns on something
18:52:08 <broma0> hodapp: I see, but does that imply that a good way of designing large haskell programs is to first break down the problem into smaller problems, and then design monads around those sub-problems?
18:52:12 <bmurphy1976> Hijiri: ok that makes sense, I think I saw with used elsewhere
18:52:15 <bmurphy1976> whoops sorry
18:52:40 <hodapp> broma0: not necessarily.
18:52:49 <peddie> broma0: a good way of designing any large program is to first break down the problem into smaller problems ;)
18:53:00 <bmurphy1976> yup, that worked: _ <- with rect $ \rectPtr -> do SDL.renderFillRect renderer rectPtr
18:53:01 <bmurphy1976> thanks!
18:54:07 <broma0> hodapp: what would you say the take-away point is then?
18:54:13 <broma0> peddie: flash back to CS103
18:56:12 <dramforever> broma0: do remember that you don't have to use monads
18:56:15 <bitemyapp> @pl (\x y z -> x + y + z)
18:56:15 <lambdabot> ((+) .) . (+)
18:56:26 <dramforever> neither are monads *that* useful
18:56:34 <dramforever> :t join (join (+))
18:56:35 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a
18:56:36 <lambdabot>     Expected type: a1 -> a1 -> a1 -> a
18:56:36 <lambdabot>       Actual type: a1 -> a1 -> a1
18:56:38 <dramforever> =(
18:56:44 <dramforever> *nor
18:57:37 <bitemyapp> be the opposite of join wouldn't it?
18:58:40 <broma0> Is it possible to have some kind of global reader monad that can be ask'd from sub-monads? Say I had a 'App a = ReaderT X IO a', can i somehow have an 'App (Sub a)' where 'Sub = StateT Y IO a'
18:59:00 <broma0> dramforever: that's true, but it seems like the proper way of doing things in haskell
18:59:11 <dramforever> no it's not
18:59:24 <broma0> dramforever: do explain
18:59:25 <dramforever> it's *a* proper way of doing things
18:59:38 <dramforever> but there are a lot ways
18:59:52 <dramforever> and generality helps
19:00:28 <ttt_fff_> correct me if I'm wrong, the core of TemplateHaskell involves 3 parts. (1) runQ [| ... |] , which is builtin, which does String -> Haskell AST, (2) $(...), which is builtin, which does Haskell AST -> string injected right into my source file, and (3) whatever I write which operates on Haskell Ast -> haskel AST, so the end resupt ends up being $(....) . whatever transforms I do . runQ [| ... |] <-- is this all correct?
19:03:44 <broma0> dramforever: any idea how to write monads for sub-problems in a way that supports nesting? For example having an "App" monad and SubA/SubB monads that use elements of the App monad?
19:03:59 <dramforever> typeclasses!
19:04:16 * hackagebot quiver 0.0.0.7 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-0.0.0.7 (patrykz)
19:04:24 <dramforever> class Monad m => MonadFooFeature m where foo :: ...
19:04:32 <dramforever> class Monad m => MonadBarFeature m ...
19:04:49 <broma0> dramforever: is there a name for that? something i can google to read up on?
19:04:49 <dramforever> see examples in transformers
19:04:53 <dramforever> @hackage transformers
19:04:53 <lambdabot> http://hackage.haskell.org/package/transformers
19:04:56 <broma0> is that extensible effects? 
19:05:04 <dramforever> it's like that
19:05:08 <dramforever> but more general
19:05:13 <dramforever> oh sorry should be myl
19:05:14 <dramforever> mtl
19:05:17 <dramforever> @hackage mtl
19:05:17 <lambdabot> http://hackage.haskell.org/package/mtl
19:05:17 <broma0> yes mtl
19:05:53 <broma0> i use mtl in a few of my programs, but they all use concrete stacks.. i havent been able to figure out how to actually use the MonadState/MonadReader etc classes in a useful way
19:05:56 <dramforever> also I wonder if designing your whole app in a monad is an anti-pattern
19:06:07 <dramforever> broma0: oh it's very easy
19:06:34 <dramforever> say you want to manipulate a state of type Foo, you just write (MonadState Foo m) => m ()
19:07:00 <dramforever> and you also want to write strings? (MonadWriter String m, MonadState Foo m) => m Bar
19:07:20 <broma0> dramforever: can we take a step back? lets assume we have an "App" monad 'ReaderT X (StateT Y IO) a'
19:07:20 <tswett> Now, it seems like a pretty common question is what's a good way to write a function that takes two lists of the same length as arguments.
19:07:25 <dramforever> also I think maybe the compiler can infer those constraints
19:07:38 <broma0> or something similar
19:07:46 <tswett> I could list at least five ways to do itâ€”check the lengths at compile time, use type-level data, blah blah.
19:07:58 <dramforever> tswett: [(A, B)]
19:08:10 <tswett> I feel like this is the sort of thing that surely a person would have written a blog post or something about.
19:08:25 <dramforever> broma0: and the question is...
19:08:33 <tswett> So my real question is: is there some blog post, or wiki article, or something, which covers this question in great detail?
19:08:41 <dramforever> oh how to convert that to use constraints?
19:09:05 <broma0> dramforever: I have a global monad with all of the transformers i need, do i then have functions that pick and choose the associated classes/
19:09:08 <broma0> ?*
19:09:08 <lambdabot> Maybe you meant: v @ ? .
19:09:55 <dramforever> broma0: I don't really know, but for the "sub-monad" thing, yes you can do that
19:09:57 <dramforever> with classes
19:09:58 <tswett> broma0: given what you said about App, SubA, and SubB, it sounds like perhaps you could just implement those as three separate monads, then have a function SubA a -> App a, and another function SubB a -> App a.
19:10:14 <dblarons> I wrote a few functions that return the Except monad. Now trying to unpack that monad in a function where I've stacked ExceptT onto IO and having trouble. How do I bind on Except within an ExceptT function?
19:11:05 <broma0> starting to make more sense..
19:11:49 <dblarons> I don't think lift makes sense here, and the types in Control.Monad.Trans.Except don't seem to match what I want to do.
19:12:29 <broma0> tswett: so some App () function as the entry point, that calls functions like SubA a -> App a for the sub components?
19:12:50 <tswett> That sounds about right, yeah.
19:13:32 <dramforever> broma0: I have to point out that if you design most of your system in a monad
19:13:42 <dramforever> you end up having code smell
19:14:01 <Hijiri> broma0: Using typeclasses instead of a concrete transformer stack makes it more flexible
19:14:05 <sgronblo> Anybody have any idea why ghc-mod would be giving me this error: "ghc-mod: <command line>: cannot satisfy -package-id process-1.2.0.0-3a472e9c66165e506513ea8f145681a0"
19:14:06 <dramforever> because it's like you are already working imperatively
19:14:11 <broma0> dramforever: but where is that line drawn? 
19:14:17 <sgronblo> I've tried installing both cabal-install and ghc-mod through stack now
19:14:18 <Hijiri> for example, if you add a new layer, you don't have to change all your type signatures
19:14:29 <dramforever> broma0: I would say use "regular" functions as much as possible
19:14:49 <broma0> Hijiri: this typeclass idea sounds like exactly what im looking for, but i havent been able to find ANY documentation on it.. like beginner-friendly documentation 
19:14:50 <Hijiri> Also, if a function is MonadReader Foo m =>... You know it's not going to use things from monads other than what's provided by MonadReader
19:15:00 <sgronblo> Then use the stack installed cabal to init a sandbox in a project, cabal install --dependencies-only and then cabal configure But when running ghc-mod I get that error.
19:15:07 <Hijiri> broma0: typeclasses in general or monad typeclasses?
19:15:17 <broma0> using monad typeclasses for sub-compoents
19:15:20 <broma0> i know typeclasses
19:16:04 <sgronblo> I was under the impression that as long as ghc-mod and cabal-install were compiled using the same cabal library version (which they should, since I installed them through stack) ghc-mod should not have problem with the change from text to binary for the cabal caceh file.
19:16:10 <Hijiri> I don't remember when or where I started using monad typeclasses
19:16:32 <Hijiri> basically you just drop the constraints in where you might otherwise use a concrete stack
19:16:48 <Hijiri> Like if you have blah :: ReaderT X (StateT Y IO) a
19:17:02 <Hijiri> If it only uses things from the ReaderT, you can do MonadReader m => m a
19:17:13 <Hijiri> MonadReader X m => m a
19:17:40 <broma0> is 'm' ever made an instance of MonadReader? 
19:17:57 <Hijiri> m is a placeholder for anything that fits the constraint
19:18:19 <Hijiri> blah will be polymorphic in any Monad that has such an instance
19:18:32 <dramforever> broma0: it must be, because you said so
19:18:52 <Hijiri> so you could use it with ReaderT X (StateT Y IO) a, or Reader X a, or WriterT Banana (ReaderT X (StateT Y IO)) a
19:18:55 <broma0> Hijiri: so lets say that your 'blah' monad was the "App" monad, or global monad. sub components would just pull out whatever they need using constraints?
19:19:42 <Hijiri> I wouldn't call them subcomponents, but that sounds right
19:20:07 <Hijiri> It's more like the constraints say what subcomponents are "supported"
19:21:13 <Hijiri> MonadWriter String m => m Int   is a value that is any  "m a", provided m supports writing out Strings
19:21:14 <broma0> Hijiri: can you expand on that? 
19:21:37 <broma0> Hijiri: that's starting to make more sense now
19:22:55 <Hijiri> broma0: like other typeclasses, Monad typeclasses tell you what operations are supported. Like instead of  (<>) :: Monoid x => x -> x -> x, which says you can combine two xs,  you can have (<+>) MonadPlus m => m a -> m a -> m a
19:22:59 <broma0> Is it an anti-pattern to think about designing an app around a central global monad made up of transformers for everything my app will ever need? for example, put all read-only stuff in a reader, all state in a state, etc.
19:23:15 <Hijiri> Which says that (<+>) works for any m that supports combining two m a
19:23:35 <Hijiri> broma0: yes, I think so
19:23:52 <Hijiri> You want to make it modular, so each piece only uses the effects it needs
19:23:57 <Hijiri> that's what the typeclasses are for
19:24:11 <broma0> Hijiri: see, im trying to come up with that "idiomatic way" to design a large app
19:24:14 <Hijiri> Once you know what effects you need, you might then choose a concrete monad transformer
19:24:27 <broma0> one really really general way of approaching many problems
19:24:50 <Hijiri> So lets say I have some things that work on MonadReader Foo m => m, MonadWriter Blah m => m
19:25:10 <Hijiri> I want to use them all together, so at the very top I choose some monad stack that fits all that
19:26:03 <mniip> dramforever, hey!
19:26:10 <dramforever> hey?
19:26:15 <mniip> I wrote a sum-indexed set!
19:26:37 <dramforever> oh the problem is solved. did you know that
19:26:39 <broma0> Hijiri: do you know of any recorded talks or posts about this constraint-based design ?
19:26:39 <dramforever> ?
19:26:55 <dramforever> Hijiri's problem is much simpler
19:27:12 <dramforever> there cannot be more than two intervals at the same time
19:27:24 <dramforever> and time flows forward
19:27:27 <Hijiri> broma0: no, sorry
19:27:29 <dramforever> only
19:27:43 <dramforever> so just sort by start time and go through the list
19:27:50 <dramforever> mniip: anyway what's that sum-indexed set like?
19:28:04 <broma0> Hijiri: any concise and relatively simple sameple code?
19:28:24 <dramforever> interesting...
19:28:48 <dramforever> broma0: maybe I'm a little better at this, but I seem to be able to understand monad typeclasses easily
19:28:55 <Hijiri> broma0: I have to go right now, for about an hour. I'll look through some of my code after I get back and tell you if I find something
19:29:01 <dramforever> it's just a normal typeclass
19:29:03 <broma0> Hijiri: thank you.
19:29:22 <dramforever> broma0: um...do you understand that thing now?
19:29:23 <broma0> dramforever: definately a little better!
19:29:34 <broma0> that thing? meaning monad typeclasses?
19:29:38 <dramforever> yes
19:29:55 <broma0> i can't confidently say i do.
19:30:12 <dramforever> I guess writing some code helps
19:31:35 <broma0> maybe GHC could be my tutor.. i wonder if writing code without any type signatures would reveal this constraint-based desing
19:31:39 <broma0> after asking for the types of course
19:32:10 <dramforever> yes, if you use the functions from the "Class" modules
19:32:22 <dramforever> are you using ghc 7.10+
19:32:23 <dramforever> ?
19:32:26 <broma0> yes
19:32:35 <broma0> Class modules?
19:32:46 <dramforever> Control.Monad.State.Class
19:32:48 <dramforever> like that
19:32:53 <dramforever> you can do myFunction :: _ => blah blah
19:33:00 <dramforever> and ghc will tell you the inferred constraints
19:33:27 <broma0> that's cool
19:33:43 <broma0> and MTL is definitely the transformer package i should be using for this exploration, correct?
19:33:55 <broma0> i see all of the class modules
19:34:01 <dramforever> well I guess it's the de facto one
19:34:10 <dramforever> you can write your own classes too
19:35:07 <broma0> why would i do that?
19:35:33 <dramforever> broma0: for components of your app
19:36:49 <broma0> dramforever: so if i had a UI and a backend, how would that look?
19:37:09 <broma0> 'class MonadReader Config a => UI a where ...'
19:37:11 <dramforever> class MonadUI m where ...
19:37:24 <broma0> dramforever: and add the necessary constraints? 
19:37:28 <dramforever> yep
19:37:37 <broma0> its all starting to come together!
19:37:45 <dramforever> oh class Monad m => MonadUI m
19:37:48 <dramforever> it helps a bit
19:38:07 <dramforever> broma0: and here comes the "however"
19:38:31 <dramforever> oh sorry no no no it's fine
19:39:03 <broma0> dramforever: haha you had me worried! so the template would be something like 'class Monad m, MonadFoo m, MonadBar m => MonadComponent m where'?
19:39:12 <dramforever> broma0: sorry...
19:39:44 <dramforever> broma0: what's MonadComponent?
19:39:50 <broma0> like MonadUI
19:39:53 <broma0> or MonadServer
19:40:00 <dramforever> well it makes sense
19:40:03 <broma0> or MonadSomeSubComponentOfMyApp
19:40:23 <dramforever> actually with ConstraintKinds you could do
19:40:34 <dramforever> type MonadComponent m = (MonadFoo m, MonadBar m)
19:40:36 <peddie> I would think about naming the new class in terms of what API it provides (Reader, State, Free) rather than what part of your program it is (UI, Server)
19:40:58 <dramforever> peddie: in that case, it seems that UI is better than Server
19:41:10 <peddie> maybe so!
19:41:18 <broma0> i think i see what you're saying peddie
19:41:22 <dramforever> it really depends
19:41:37 <broma0> what would the class functions be? the functions of that component?
19:42:14 <dramforever> broma0: yes
19:42:31 <dramforever> well actually it should be the available functionalities
19:42:41 <broma0> and yet another question by broma0: what the heck would i make an instance of the component's class? 
19:42:52 <broma0> some data type that holds the relevant data?
19:43:15 <broma0> 'data UI = UI { lastInput :: blah }' or something?
19:43:22 <dramforever> well it depends..
19:45:55 <broma0> dramforever: cliff hanger
19:46:02 <peddie> broma0: well, you have to have something that can be made an instance of Functor, Applicative and Monad at least; otherwise you don't need another transformer class (you just need to call some functions)
19:46:04 <dramforever> dunno
19:46:18 <dramforever> No more suggestions.
19:47:29 <dramforever> broma0: idea: free monads!
19:47:56 <broma0> facetious?
19:47:58 <peddie> broma0: I think you should figure out what your program is and what the sub-parts are before you try to figure out how to implement them
19:48:28 <peddie> broma0: this is a good approach for any large program in any language
19:48:45 <broma0> peddie: maybe thats my issue.. what im trying to do is come up with the idiomatic way to approach large haskell programs
19:48:54 <peddie> and with a plan in hand, it might become clearer what sorts of side effects or stateful behavior each sub-part needs
19:49:18 * hackagebot cabal-helper 0.3.7.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.3.7.0 (DanielG)
19:50:45 <broma0> maybe there isnt one high-level "idiomatic" way to structure large programs in haskell
19:50:46 <nshepperd> What I like to do is write small components with types like (MonadReader Thing m) => Component m
19:51:04 <nshepperd> or (Monad m) => Component m for pure components
19:51:24 <broma0> how is Component defined?
19:51:50 <nshepperd> I dunno, it could be anything
19:51:56 <nshepperd> depends on the specific project
19:52:29 <nshepperd> I mean in my current project I have 'Network m a b' for neural networks that go from type a to type b
19:53:50 <broma0> peddie or nshepperd, do you know of some sample code using this style that i can study?
19:53:54 <broma0> maybe even your own!
19:54:18 * hackagebot quiver 0.0.0.8 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-0.0.0.8 (patrykz)
19:55:09 <peddie> broma0: you could try diving into GHC's code; it's certainly a large program, and there is a guide on trac for it
19:55:46 <broma0> peddie: i guess GHC would be the obvous role-model piece of code, huh?
19:56:14 <peddie> broma0: I found xmonad's code to be pretty enlightening when I first started writing "real programs" in Haskell, but xmonad is quite small
19:57:01 <broma0> peddie: i was looking into xmonad earlier today.. its only like 8 files or something
19:57:09 <ttt_fff> @pl \a (b,c) -> (a:b, c)
19:57:09 <lambdabot> (`ap` snd) . (. fst) . ((,) .) . (:)
19:57:18 <ttt_fff> omg that is ugly
19:57:24 <ttt_fff> @pl \(b,c) a -> (a:b, c)
19:57:24 <lambdabot> uncurry (flip . ((,) .) . flip (:))
19:57:25 <broma0> where is this ghc guide you speak of
19:57:31 <ttt_fff> omg that is not prettier
19:57:37 <ttt_fff> @google ghc manual
19:57:37 <broma0> im on trac/ghc
19:57:38 <lambdabot> https://www.haskell.org/ghc/docs/latest/html/users_guide/
19:57:40 <peddie> broma0: I don't think there's "one high-level 'idomatic' way to structure large programs" in any language; you have to design it knowing the goals and the domain
19:58:02 <peddie> https://ghc.haskell.org/trac/ghc/wiki/Commentary broma0
19:58:22 <Axman6> :t (first . (:))
19:58:23 <lambdabot> a -> ([a], d) -> ([a], d)
19:59:05 <Axman6> > uncurry (first . (:)) 1 ([2,3],"Hello")
19:59:06 <lambdabot>      Couldn't match type â€˜([a0], d0)â€™ with â€˜([Integer], [Char]) -> tâ€™
19:59:06 <lambdabot>      Expected type: ([a0] -> [a0])
19:59:08 <lambdabot>                     -> ([a0], d0) -> ([Integer], [Char]) -> t
19:59:19 <Axman6> bleh
19:59:20 <Axman6> too har
19:59:21 <Axman6> d
19:59:32 <broma0> alright, i need to take an 8 hour nap now. thank you for the help #haskell
19:59:47 <peddie> broma0: what program are you writing?
20:00:00 <broma0> peddie: well the current obsession is a text-editor
20:00:12 <peddie> broma0: cool!  good luck!
20:00:16 <broma0> but i'm also working on a evernote like web service
20:00:23 <broma0> thank you!
20:00:25 <peddie> ah wow
20:00:35 <peddie> enjoy your nap
20:00:39 <ttt_fff> what is the difference betwen an 8 hr nap
20:00:40 <ttt_fff> and a sleep 
20:00:44 <broma0> ttt_fff: nothing
20:01:28 <broma0> going from 8hrs of clojure, to 5hrs of haskell each day is tiring
20:01:50 <ttt_fff> no erlang? psst, slacker
20:02:06 <ttt_fff> :-)
20:02:10 <broma0> ttt_fff: that'll be after i learn prolog
20:02:12 <broma0> :D
20:12:22 <m4ntis> does anyone here have a CCNA cert?
20:13:55 <ttt_fff> is there an infix version of Control.Lens.over ?
20:14:09 <shachaf> (%~)
20:14:11 <dramforever> :t (%~)
20:14:12 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
20:14:34 <dramforever> > [1,2,3] & _head %~ (+ 1) -- example
20:14:36 <lambdabot>  [2,2,3]
20:15:05 <ttt_fff> lambdabot ++
20:15:10 <ttt_fff> shachaf ++
20:15:13 <ttt_fff> dramforever++
20:16:43 <ttt_fff> :t (over)
20:16:44 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
20:17:29 <ttt_fff> wtf is the (&) for ?
20:17:38 <ttt_fff> >t over _head (+ 1) [1, 2, 3]
20:17:48 <ttt_fff> > over _head (+1) [1, 2, 3]
20:17:49 <lambdabot>  [2,2,3]
20:17:57 <ttt_fff> what is the & for ? 
20:18:40 <ttt_fff> :t (&)
20:18:41 <lambdabot> a -> (a -> b) -> b
20:19:08 <lf94> What's the best way to have a main game loop in Haskell, for a game like Hangman?
20:19:29 <lf94> I tried to make a recursive loop but I was having state problems
20:19:49 <ttt_fff> > _head %~ (+ 1)
20:19:50 <lambdabot>      No instance for (Typeable t0)
20:19:50 <lambdabot>        arising from a use of â€˜show_M893341254144019623920758â€™
20:19:50 <lambdabot>      In the expression:
20:19:57 <ttt_fff> > _head %~ (+ 1) [1, 2, 3]
20:19:58 <lambdabot>      Couldn't match type â€˜[]â€™ with â€˜(->) a0â€™
20:19:58 <lambdabot>      Expected type: a0 -> a0
20:19:58 <lambdabot>        Actual type: [a0]
20:20:08 <ttt_fff> > (_head %~ (+ 1)) [1, 2, 3]
20:20:09 <lambdabot>  [2,2,3]
20:22:45 <Hijiri> lf94: what state problems?
20:23:01 <Hijiri> recursive loop should work for something simple
20:23:20 <Hijiri> you could use something fancy from monad-loops too
20:29:20 * hackagebot quiver 0.0.0.9 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-0.0.0.9 (patrykz)
20:29:28 <lf94> Hijiri, this is not even close to workable, just something I wrote on paper in bed last night: https://gist.github.com/lf94/d6a1c676f3d4f0d71bff
20:29:54 <lf94> Hijiri, my problem is...I have to keep state between iterations or something
20:30:06 <lf94> And getChar returns an IO so like my head is just everywhere
20:30:11 <Hijiri> yeah
20:30:18 <Hijiri> so you would have a data type for state
20:30:26 <Hijiri> Foo, and maybe it holds the current word, and the guessed letters
20:30:36 <Hijiri> and maybe some representation of the word with "holes"
20:30:39 <lf94> Well, that's what Character is
20:30:49 <lf94> Character = (Char,Bool)
20:30:54 <lf94> Bool is if it was found
20:32:09 <Hijiri> so you could have loop :: Word -> IO ()
20:32:11 <Hijiri> oh, you do
20:32:49 <Hijiri> you get the new word after guessing with let newWord = guessCharacter word myCharacter
20:32:55 <Hijiri> and then call looper with newWord
20:33:33 <Hijiri> there are a bunch of type errors in that gist but I think they could be fixed mechanically
20:35:53 <lpaste_> Hijiri pasted â€œlf94: something like thisâ€ at http://lpaste.net/137824
20:36:00 <Hijiri> there might still be some errors
20:36:53 <Hijiri> and you've probably already thought about it, but you might want things like printing out the current word state, or win/lose logic
20:37:23 <Hijiri> if you win or lose you can stop the loop by just not calling the loop again
20:39:53 <jgcoded> I'm using Haskell Template with shakespeare to load an external hamlet file, but my code breaks if you don't run GHCi from the same directory all the time. Line 42: http://lpaste.net/137825 . What's the best way to handle this?
20:41:20 <lf94> Hijiri, yeah like I said I was just doing this in bed
20:41:20 <lf94> lol
20:41:23 <lf94> on paper
20:41:46 <Hijiri> lf94: do my suggestions make sense?
20:43:08 <lf94> Hijiri, yeah definitely :)
20:43:29 <lf94> Hijiri, just lots of iteration to check to see if the word is "complete"
20:43:41 <lf94> Hijiri, maybe I should have State = (Done, Word)
20:43:58 <lf94> eh maybe not
20:44:14 <Hijiri> it could be useful if you wanted to be able to restart the game after a win or loss
20:44:31 <lf94> That's another thing that bugs me - I keep stopping myself because I keep thinking I'm being inefficient
20:44:39 <Hijiri> oh, but you could just call the restart IO thing
20:45:18 <Hijiri> lf94: haskell being easy to refactor means you can just put out some code if you have the general idea of how you want something to be
20:45:25 <Hijiri> and then just fix it later
20:54:21 * hackagebot quiver 0.0.0.10 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-0.0.0.10 (patrykz)
20:56:22 <lethjakman> so...probably a dumb nooby question, but when I try to start my yesod app it tells me there are dependencies missing. 
20:56:32 <lethjakman> is there an easy way to install them all?
21:15:21 <tmtwd> can someone help me with this bug? http://pastebin.com/fRXHzH7j
21:16:22 <darkmercenary> :q
21:18:39 <td123> tmtwd: http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:RealFloat
21:19:01 <td123> tmtwd: Integer is not an instance
21:19:13 <Hijiri> tmtwd: what does :t x give you?
21:19:24 <Hijiri> It's possible ghci defaulted 3 and 5 to integer
21:19:31 <tmtwd> x :: ComplexRectangular Integer
21:19:31 <tmtwd>  
21:19:36 <Hijiri> ok, that's the issue then
21:19:50 <tmtwd> how do I fix it then?
21:20:07 <Hijiri> you could do an explicit type signature on x
21:20:15 <tmtwd> oh okay
21:24:23 * hackagebot quiver 0.0.0.11 - Quiver finite stream processing library  https://hackage.haskell.org/package/quiver-0.0.0.11 (patrykz)
21:24:58 <tmtwd> i forget how to do type signature for vars ... and google is just telling me how to do it for functions
21:25:14 <tmtwd> how would I do it for let x = Rectangular 3 5?
21:26:43 <td123> >:t let x = 3 :: Double in x
21:26:51 <subleq__> Can you implement a binary search tree such that the ordering condition can't be violated?
21:27:07 <td123> >t 1
21:27:18 <td123> :t 1
21:27:20 <lambdabot> Num a => a
21:27:25 <td123> :t 1 :: Double
21:27:26 <lambdabot> Double
21:27:36 <td123> there we go tmtwd ^
21:27:57 <tmtwd> ah okay
21:29:11 <td123> subleq__: using a set of functions to build your tree, yes
21:29:23 * hackagebot quiver-cell 0.0.0.2 - Quiver combinators for cellular data processing  https://hackage.haskell.org/package/quiver-cell-0.0.0.2 (patrykz)
21:29:45 <drewbert> Man, I love stack.
21:29:47 <td123> subleq__: I'm not sure it can be done such that it is enforced by the type system.
21:30:08 <subleq__> td123: my question is about enforcing it with the type system
21:30:52 <kadoban> subleq__: Then you'd have to get into dependent types, which aren't in vanilla haskell.
21:31:16 <subleq__> kadoban: yes, but how about ghc haskell?
21:31:27 <tmtwd> , let foo = 32 :: RealFloat
21:31:38 <tmtwd> > let foo = 32 :: RealFloat
21:31:40 <lambdabot>  <no location info>: not an expression: â€˜let foo = 32 :: RealFloatâ€™
21:31:45 <kadoban> subleq__: I wouldn't know enough to speak about that. I suspect you can, but I'd personally have no idea how.
21:31:48 <tmtwd> > let foo = 32 :: Float
21:31:49 <lambdabot>  <no location info>: not an expression: â€˜let foo = 32 :: Floatâ€™
21:31:52 <td123> https://www.fpcomplete.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell
21:33:44 <td123> not sure if it's possible but that link will probably get you closer to your answer
21:34:02 <drewbert> > 32 :: Float
21:34:03 <lambdabot>  32.0
21:34:23 * hackagebot quiver-bytestring 0.0.0.2 - Quiver combinators for bytestring streaming  https://hackage.haskell.org/package/quiver-bytestring-0.0.0.2 (patrykz)
21:35:36 <drewbert> > a where a = 32 :: Float
21:35:38 <lambdabot>  <hint>:1:3: parse error on input â€˜whereâ€™
21:36:07 <td123> > let a = 32 :: Float in a
21:36:09 <lambdabot>  32.0
21:37:00 <drewbert> > let a = a where a = 32 :: Float in a
21:37:01 <lambdabot>  32.0
21:37:16 * drewbert smirks.
21:37:59 <tmtwd> thanks
21:44:34 <nshepperd> > let a = a+1 where a = 32 :: Float in a
21:44:35 <lambdabot>  33.0
21:44:41 <nshepperd> wat
21:45:34 <Spaade> hello
21:48:45 <catofhask> Hi I have an IO action and a STM action
21:49:50 <catofhask> My aim is to embed IO action somehow into STM so that I can glue them together to make sure result of both is atomic
21:50:15 <catofhask> is it possible with bare Control.Concurrent.STM?
21:52:01 <hamsterdam> Just finished LYAH! It was excellent. Thanks so much, Miran
21:56:37 <wasbee__> LYAH is awesome!
21:59:40 <c_wraith> catofhask: it is not possible with bare STM.  That's why there's an extra project to add it.
22:00:31 <verement> catofhask: you may be interested in https://github.com/mcschroeder/thesis
22:00:50 <catofhask> c_wraith: stm-io-hooks, right? I did not find much documentation of that. Could you point to anything that exists but I did not encounter
22:00:51 <catofhask> ?
22:01:08 <c_wraith> catofhask: no, I was actually referring to the same thing verement just pointed out
22:01:24 <c_wraith> catofhask: but I took the time to look at the current state.  At the moment, it's only usable as a fork of GHC.
22:02:32 <catofhask> c_wraith: Ah. that's not really ideal for my current need :)
22:03:12 <drewbert> wasbee__: I enjoyed it quite a lot as well.
22:04:00 <wasbee__> :)
22:06:05 <subleq__> How is it even possible to embed an IO action in a STM action? The STM action has to be able to be retried
22:07:14 <tommd> subleq__: It is possible with an unsafe* operation.  Semantics? The IO can not be rolled back, deal with it.
22:07:39 <subleq__> ahahaha
22:09:05 <startling> is there a good takeAndDropWhile :: (a -> Bool) -> [a] -> ([a], [a]) ?
22:09:49 <johnw> you mean, span?
22:10:00 <startling> :t span
22:10:01 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
22:10:14 <startling> > span isDigit "123abc"
22:10:15 <lambdabot>  ("123","abc")
22:10:17 <tommd> startling: not the same semantics as `span` but you might also like to know about partition.
22:10:21 <startling> yes, exactly, thanks
22:11:29 <CatMtKing> maybe i'm not asking this in the right place, but would anyone here know how to setup ghc-mod in nix?
22:27:08 <liste> CatMtKing I've done it
22:27:14 <liste> what do you want to know?
22:30:04 <liste> it should be just nix-env -iA nixpkgs.haskellPackages.ghcMod
22:30:51 <liste> but at the time I installed it some of my tools used different versions of Cabal library
22:31:24 <johnw> liste: it's called ghc-mod these days
22:31:55 <liste> oh, didn't know
22:32:06 <johnw> yeah, after the haskell-ng thing went mainline
22:32:18 <lpaste_> liste pasted â€œmy .nixpkgs/config.nixâ€ at http://lpaste.net/137827
22:32:58 <liste> anyway I had to fix the Cabal version to be compatible with all my tools in that config.nix, but yeah that's outdated
22:38:26 <CatMtKing> hm, it tells me that the package is broken.  i guess i could try allowing it to install anyway
22:39:20 <CatMtKing> i tried nix-env -iA nixpkgs.haskellngPackages.ghc-mod
22:44:15 <lpaste_> nshepperd pasted â€œdependent search tree... or something...â€ at http://lpaste.net/137828
22:44:31 <nshepperd> subleq__: I wrote some nonsense, above ^^
22:45:03 <nshepperd> it's not a real binary search tree, because I wasn't sure how to represent empty trees nicely
22:46:15 <nshepperd> it's basically a type-level tree with type-level nats, and then conversion to and from a normal tree of Integers
22:47:25 <startling> is there a nice infix thing for flip liftM anywhere?
22:47:39 <nshepperd> or, err, a value-level tree of type-level nats?
22:47:44 <shachaf> lens has <&>
22:47:58 <startling> thanks.
22:48:00 <shachaf> nshepperd: Is NatWitness the same as SomeNat?
22:48:07 <nshepperd> oh, I think I actually need a few more constraints
22:48:44 <shachaf> Wait, no.
22:48:52 <shachaf> Never mind, I completely misread it.
22:49:15 <shachaf> Should've gotten the idea from the name.
22:50:05 <nshepperd> I suppose I could have just used Dict (KnownNat n) because that's all I need out of it
22:51:31 <shachaf> Depending on the use case reifyNat from https://hackage.haskell.org/package/reflection-2/docs/Data-Reflection.html might work better.
22:52:08 <shachaf> If you're always constructing it and matching on it right away the existential doesn't do you much good.
22:52:35 <shachaf> In fact I vaguely remember that someone in here reimplemented reifyNat at some point. Maybe you.
22:54:51 <nshepperd> hmm, I'll try that
22:56:58 <nshepperd> oh, I see, it would replace someNatVal
22:57:42 <nshepperd> interesting that reifyNat doesn't worry about negative integers, unlike someNatVal
22:58:06 <shachaf> I think I'm mixing things up again.
23:20:24 <adarqui> this "functonal programming game" is fun: http://david-peter.de/cube-composer/
23:38:20 <zipper> How do I use ghc 7.10 with stack? Because it keeps forcing me to use 7.8
23:38:36 <lamefun> Aesob...
23:38:52 <lamefun> http://hackage.haskell.org/package/aeson-0.9.0.1/docs/Data-Aeson.html#t:Result - how am I supposed to debug my JSON-files if Aeson doesn't provide me with line/column?
23:41:01 <peddie> lamefun: https://hackage.haskell.org/package/aeson-better-errors 
23:43:30 <peddie> lamefun: also supposedly aeson's messages have improved in 0.10
23:43:38 <peddie> https://github.com/bos/aeson/blob/master/changelog.md
23:43:49 <peddie> not sure whether they include line/column
23:50:33 <sgronblo> where does cabal look for ghc?
23:53:23 <peddie> sgronblo: probably in $PATH
23:55:10 <pacak> sgronblo: All over the place. strace -e file <your cabal command>
23:56:03 <peddie> sgronblo: there is a config file field 'extra-prog-path' that could be used as well
