00:03:33 * hackagebot wai-handler-webkit 3.0.0.2 - Turn WAI applications into standalone GUIs using QtWebkit.  https://hackage.haskell.org/package/wai-handler-webkit-3.0.0.2 (MichaelSnoyman)
00:15:07 <Gurkenglas> I was about to put "Pair . (fst &&& snd) . runPair" into my code ._.
00:19:08 <adarqui> hey, how can i make this logic into a one liner, like the line commented out.. but working: http://lpaste.net/138059  .. Nothing >> Just 1 will result in Nothing, but (return Nothing) >> (Just 1) will result in Just 1..
00:19:52 <adarqui> trying to turn all of that into one succinct line ;/
00:20:11 <liste> ardaqui what's TodoAppState?
00:20:23 <liste> State ???
00:20:32 <adarqui> type TodoAppState a = State TodoApp a
00:20:33 <adarqui> ya
00:20:34 <liste> where ??? = something
00:20:43 <Gurkenglas> return Nothing and Just 1 aren't the same type.
00:21:00 <adarqui> Gurkenglas: i meant (return Nothing) >> (return $ Just 1)
00:21:51 <Gurkenglas> Whenever you have something in your code that says case x of Nothing -> return Nothing, you want MaybeT.
00:22:04 <adarqui> i have severe lag on my shell, sorry. can barely type
00:23:26 <adarqui> right so like a runMaybeT there instead?
00:23:30 <adarqui> maybe transformer
00:25:52 <Gurkenglas> adarqui, I made an annotation. (I don't know what X is, so I called it X.)
00:27:30 <adarqui> cool thanks! i will experiment
00:29:50 <lpaste_> Gurkenglas annotated “No title” with “adarqui, and another, if you don't want your type signatures to contain MaybeT. Ignore the intermediate two annotations, damn lpaste for not having its annotation edits work correctly.” at http://lpaste.net/138059#a138064
00:31:23 <Gurkenglas> Also yet again, this momentary usage of monad transformers looks very lensy, is there any way to transform "runMaybeT . fmap go . MaybeT" into something of the form "_ (fmap go)"?
00:31:31 <adarqui> dang that lpaste has tons of reponses.. wth? awesome
00:32:05 <Gurkenglas> adarqui, as lpaste_ said, ignore the second and third response.
00:43:27 <Gurkenglas> Are there any plans to deprecate the transformers package and move everything into mtl, so one doesn't have to wait for additions to transformers to be reexported by mtl?
00:44:38 <srhb> Gurkenglas: I certainly don't think so.
00:49:01 <Gurkenglas> srhb, why not? (So the protocol for adding things to mtl is as I expect?)
01:05:00 <tsahyt> I'm working on a fresh yesod project with stack (as recommended in the quick start guide now). But I can't start a ghci session with stack ghci. I get a "cannot satisfy -package yesod-test", and that's it. Since I'm new to stack, I'm not quite sure how to fix this. Can anyone guide me in the right direction? ghc-mod throws a similar message of course, which is quite annyoing since my vim setup depends on i
01:05:06 <tsahyt> t.
01:13:37 * hackagebot moesocks 0.1.0.9 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.9 (JinjingWang)
01:13:40 <dramforever> sigh...
01:13:50 * dramforever is installing ghc 7.10.2
01:16:15 <skrio> tsahyt: you need to install yesod-test packages
01:16:24 <skrio> tsahyt: i think it is stack install yesod-test
01:18:46 <tsahyt> skrio: Thanks, that worked. I thought that stack would resolve all this on its own, but apparently I was mistaken. I can use ghci now, but ghc-mod still complains.
01:19:35 <skrio> tsahyt: yesod only depends on yesod-test if you need to run the tests, i believe, so stack doesn't include it.
01:20:18 <skrio> tsahyt: are you running ghc-mod as 'stack exec -- ghc-mod <args>'?
01:20:48 <tsahyt> skrio: No, I've installed it way before I started using stack. I've compiled it statically into a ~/.bin/ directory and call it from there
01:21:25 <skrio> try running it as such. If you don't let stack pass it some runtime environment stuff it cna't determine dependencies and where the needed packages are located.
01:22:33 <tsahyt> I don't think I can integrate that with the vim plugin though. As far as I see there's no option to set the executable.
01:23:37 * hackagebot html-tokenizer 0.4.0.0 - An "attoparsec"-based HTML tokenizer  https://hackage.haskell.org/package/html-tokenizer-0.4.0.0 (NikitaVolkov)
01:23:52 <skrio> tsahyt: I think i played around with that before, if you look through the vim-script you can (hackily) fix it. I believe it worked to prepend "stack exec -- " before the call to ghc-mod
01:24:15 <skrio> tsahyt: It's not ideal though
01:24:27 <tsahyt> Well I could always just write a pass-through script and put it in the path I suppose
01:24:43 <skrio> tsahyt: sounds better than my idea :)
01:25:00 <rzetterberg> Anyone with experience using x11-xinput? I'm getting "ErrorCall (toEnum{DeviceClassType}: tag (3) is outside of enumeration's range (0,2))" when trying to query input devices :/
01:25:26 <tsahyt> skrio: But will using "stack exec --" break it on non-stack projects? I've still got a bunch of these lying around.
01:25:59 <tsahyt> Okay, apparently not. I just tried it.
01:26:03 <skrio> tsahyt: Suppose it could, if it is dependent on reading the .cabal?
01:26:21 <skrio> tsahyt: great :)
01:27:24 <gfixler> does Data.Map default to Data.Map.Lazy?
01:28:18 * gfixler is only just noticing that Data.Map itself hasn't had most things in it since 2012/v0.5.0.0
01:30:19 <rzetterberg> gfixler: Seems like it defaults to lazy if you look at the haddock docs of Data.Map "Note: You should use Data.Map.Strict instead of this module if"
01:30:51 <gfixler> rzetterberg: yeah, it's a pretty strong implication
01:32:33 <gfixler> rzetterberg: I should have just looked at the source; it's pretty clear in there what's going on
01:33:25 <rzetterberg> gfixler: yeah, I usually just hover the hyperlinks of the types in the functions to see where it links to :)
01:43:03 <gfixler> rzetterberg: good trick
02:19:44 <Gurkenglas> Does this tie the knot correctly? General suggestions? http://lpaste.net/138075
02:22:08 <tsahyt> Can I use Postgres enumeration types for sum types with persistent somehow? As far as I can tell, persistent stores sum types as strings.
02:25:20 <Gurkenglas> Oh wait, I guess [] is a fixpoint of that function, I need to ...fix... the length
02:25:54 <Gurkenglas> (Except that spinR and spinL don't work on []...)
02:32:17 <Gurkenglas> Will I need a dependently typed fixed-size-vector for that?
02:42:08 <lyxia> Gurkenglas: Generate the list of linked-lists from the element you want to return.
03:16:54 <Trubydoor> is there any way to get code completions for company-mode from stack (emacs)? I'm using stack-mode for flycheck but it doesn't seem to have anything for code completion :'(
03:47:29 <mazur> hi all, i am trying to install accelerate-cuda and i hit this build error in Accelerate/Cuda/Array/Sugar.hs: "Couldn't match expected type `Array dim0 e1` with actual type `IO (Array dim e0)`  any ideas?
03:50:32 <mazur> hmm, i guess i found the issue in the tracker
03:52:43 <srhb> mazur: Do link. Might remember when someone comes along with the issue next time :-)
03:53:12 <kuribas> Trubydoor: better ask in #haskell-emacs
03:53:29 <Trubydoor> ah didn't know there was a separate channel for that, thanks :-)
03:53:43 <mazur> https://github.com/AccelerateHS/accelerate/issues/277
03:53:51 <srhb> mazur: Thanks.
03:58:29 <obadz> ALL, looking at Data.Array.MArray, is there a way to get the immutable array out of the MArray monad when I'm done with writing stuff?
03:59:27 <liste> obadz freeze
03:59:38 <liste> :t freeze
03:59:39 <lambdabot> Not in scope: ‘freeze’
03:59:43 <obadz> liste: freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
03:59:51 <obadz> liste: still in the monad..
04:00:06 <obadz> (surprisingly)
04:00:26 <Phillemann> Is there a way to include external code fragments in haddock (so I have always-compiling code in my documentation)?
04:00:50 <liste> obadz well if you're using ST, then with runST ?
04:01:02 <chattered> obadz: It's not an MArray monad.
04:01:07 <dramforever> obadz: why do you expect to get out of the monad?
04:01:12 <chattered> The monad is the third argument to MArray.
04:03:14 <srhb> obadz: If you're working in an escapable type, ie ST, you probably mean to use runSTArray
04:03:33 <srhb> If you're in IO, there is no escape, as usual.
04:03:38 <obadz> ok
04:03:54 <obadz> thx
04:04:22 <dramforever> actually I'm thinking that I should probably reply to invalid questions with something like "Mu."
04:04:36 <dramforever> or "that doesn't make sense"
04:05:20 <srhb> dramforever: Finding the correct balance between not making implicit assumptions about the askers internations and not coming off rude is difficult, though. :-)
04:05:32 <dramforever> exactly
04:05:38 <srhb> internations? Intentions. How did that happen.
04:05:54 <dramforever> maybe something like "explain that"
04:06:07 <srhb> Yeah.
04:06:26 <dramforever> understanding the problem is 100% of solving it, in many cases
04:06:29 <dramforever> but not most
04:06:53 <skrio> srhb: you could just be their rubber duck :)
04:07:00 <srhb> skrio: That happens a lot, indeed. :)
04:09:19 <tdammers> Phillemann: not out of the box, I believe; I think this would be a use case for literate programming
04:24:40 <Peaker> My second attempt to use "stack" also failed :-(   http://lpaste.net/138084
04:25:05 <Peaker> does stack have its own package database separate from the one ghc-pkg lists by default?
04:27:31 <cocreature> Peaker: yes, if you want ghc 7.10 you need to choose a nightly snapshot
04:27:38 <cocreature> I assume you are running lts or something like that
04:28:36 <Peaker> cocreature: nope, just manually installed 7.10.2 and used cabal manually since
04:28:36 <skrio> Peaker: tried it with --install-ghc flag? Might work, otherwise, like cocreature says, you need to use the new nightly snapshot
04:28:52 <Peaker> how do I tell stack to use a new nightly snapshot?
04:29:03 <cocreature> put it in your stack.yaml
04:30:24 <Peaker> the one in there is about a week old
04:30:25 <skrio> Peaker: put resolver: nightly-2015-08-06
04:30:44 <skrio> Peaker: the resolver got updated very recently
04:32:27 <mpickering> is there a "stack configure" command which just generates dist/setup-config
04:32:37 <cocreature> mpickering: not that I know of
04:33:35 <cocreature> mpickering: stack exec cabal -- configure might work
04:33:59 <mpickering> cabal isn't installed as this is on a travis build
04:34:16 <mpickering> I can install cabal I guess but stack is meant to make things easier..
04:34:39 <mpickering> there are some good bits but anything past the basics and it doesn't have the support
04:35:55 <cocreature> well open an issue if you run into something that's missing :)
04:41:48 <catgocat> morning
04:41:48 <Peaker> after updating my nightly snapshot to today's, it fails to build ide-backend-server due to missing modules, I guess the deps of ide-backend-server are ill-specified?
04:43:28 <Peaker> oh, the missing modules are in Setup.hs -- is there a way to specify deps for Setup.hs that they forgot to specify?
04:45:22 <Peaker> if I manually install "tar", "Setup.hs" suddenly builds. "tar" *is* specified in the deps. That sucks
04:52:44 <echo-area> Does values in GHC have type information attached at runtime?
04:52:59 <dramforever> no, unless you do so explicitly
04:53:04 <dramforever> a.k.a, Typeable
04:53:47 <dramforever> echo-area: but why do you need them anyway?
04:54:11 <echo-area> I don't need them right now, I'm just wondering
04:55:39 <echo-area> dramforever: So what's the point of boxed vs unboxed types?  Are they for compilation?
04:55:49 <dramforever> echo-area: so the short answer is no
04:55:49 <dramforever> the longer one is you can do that if you want to
04:56:09 <dramforever> well boxed and unboxed types behave differently
04:57:10 <srhb> echo-area: It has to do with runtime representation, but in a different sense. Unboxed types are represented directly by value, while boxed types are pointers to heap objects.
04:58:27 <echo-area> dramforever, srhb: Thanks
04:58:31 <dramforever> =)
04:58:43 <srhb> echo-area: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/primitives.html
04:59:13 <Twey> dramforever: Even with Typeable the information isn't attached to the value, it's attached to the type and passed around with the instance
04:59:56 <dramforever> yes, but that's attached to...oh I read the question incorrectly...
05:00:04 <dramforever> =P
05:00:13 <dramforever> anyway it's basically RTTI
05:00:25 <dramforever> basically the same thing
05:00:31 <liste> does Data.Dynamic attach it to the value?
05:00:55 <Twey> liste: Yes
05:01:16 <dramforever> liste: and yes, that's basically what I mean by "you can do that if you want"
05:02:12 <Twey> I think a Dynamic is basically a pair of TypeRep and value
05:02:33 <Twey> Yes, quite literally
05:02:44 <Twey> data Dynamic = Dynamic TypeRep Obj deriving Typeable
05:03:02 <dramforever> s/Obj/Any
05:03:07 <echo-area> Twey: You mean a value is attached type tag, and the type is attached Typeable information?
05:03:27 <Twey> dramforever: There's a type synonym
05:03:28 <dramforever> the tag *is* the type information
05:03:39 <dramforever> Twey: oh really I didn't know that =)
05:03:48 * hackagebot hinotify 0.3.8 - Haskell binding to inotify  https://hackage.haskell.org/package/hinotify-0.3.8 (LennartKolmodin)
05:03:49 <dramforever> echo-area: the tag *is* the type information
05:03:50 <Twey> dramforever: Just in Data.Dynamic.  https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Dynamic.html#Obj
05:04:17 <Twey> echo-area: The information carried by a Typeable instance is precisely a ‘type tag’ like Python &c. use
05:04:21 <Peaker> ByteStrings are pinned for interactions with C API's, but this is costly (as evident by Text outperforming ByteString in many cases in my benchmarks).  Isn't it a terrible idea to have pinning in the default "bytes" type?
05:04:42 <Twey> echo-area: Data.Dynamic just takes that information and bundles it up with the value, discarding the static type information
05:05:24 <dramforever> Peaker: I'm afraid that many bytestring operations are implemented in C
05:05:47 <Peaker> dramforever: but we could have a Bytes type based on Data.Text.Array (from "text") that outperforms ByteString
05:05:54 <echo-area> Oh, I need to check that package out.
05:07:55 <Twey> echo-area: It's surprisingly unuseful
05:08:21 <dramforever> +1
05:08:30 <Twey> I've used Typeable a few times, but I don't think I've ever had call for Data.Dynamic: I've always preferred explicit existential types
05:08:57 <dramforever> I used it once, to implement a dynamically typed programming language
05:09:06 <dramforever> ended up cluttering up everything
05:10:54 <catgocat> What is :def and :undef used for in ghci? In the docs it says "(Un)Defines the user-defined command ..."
05:10:58 <catgocat> but what does that mean
05:11:21 <Twey> Yeah, Haskell doesn't really have nice syntax for dynamically-typed programming (for good reason, I guess)
05:11:37 <echo-area> I have used Clojure for long and I need to fight against impulses of using such features :)
05:11:48 <Twey> catgocat: https://wiki.haskell.org/GHC/GHCi#The_:def_command
05:12:20 <Twey> echo-area: Amusingly, from what I've seen the Clojure devs are currently mostly occupied with the fallout of using them, so I guess it balances out nicely :þ
05:12:36 <bennofs> catgocat: [example] > :def example (\x -> putStrLn x >> return ":!ls")
05:14:07 <Twey> catgocat: Basically it lets you define arbitrary IO Haskell code to be executed to produce a GHCi command when you type the :def'd command
05:14:16 <Cale> catgocat: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-commands.html#idp6937232
05:14:20 <catgocat> nice
05:14:44 <mreh> http://boards.4chan.org/fa/thread/10212416/is-haskellcore-effay
05:15:21 <Twey> catgocat: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-commands.html#idp6937232
05:15:47 <Twey> mreh: Haha.
05:15:54 <mreh> SPJ has been singled out for his sense of fashion
05:15:59 <mreh> he should be notified
05:16:17 <mreh> I don't recognise anyone else in the other photo
05:16:32 <maerwald> they look all very fashionate
05:16:55 <mreh> Third from the left looks like Brent Spinner in independence day
05:17:59 <frerich> I don't even understand "Is haskellcore effay". Is that slang of some sort or a pop culture thing which I'm missing? :-]
05:18:08 <Twey> mreh: From left: SPJ, Ron Morrison, Tony Davie, Alan Robinson
05:18:53 <frerich> What I do notice is that SPJ ages remarkable well.
05:19:05 <Twey> Apparently
05:19:13 <frerich> So he's more like Patrick Stewart instead of Brent Spiner.
05:19:26 <Twey> frerich: Even his fashion is back in vogue.
05:19:37 <frerich> Twey: Maybe he found some sort of fixpoint.
05:19:44 <Twey> Hahah.
05:20:15 <mreh> I'm wondering whether to email him
05:20:17 <mreh> it might make his day
05:20:31 <nshepperd> (Simon (Simon (Simon (Simon ...
05:23:46 <Twey> @let data Simon = Simon Simon | Peyton | Jones; instance Num Simon where _ - _ = fix Simon
05:23:47 <lambdabot>  .L.hs:146:10: Warning:
05:23:47 <lambdabot>      No explicit implementation for
05:23:47 <lambdabot>        ‘+’, ‘*’, ‘abs’, ‘signum’, and ‘fromInteger’
05:23:53 <Twey> :t Simon Peyton-Jones
05:23:54 <lambdabot> Not in scope: data constructor ‘Simon’
05:23:54 <lambdabot> Not in scope: data constructor ‘Peyton’
05:23:54 <lambdabot> Not in scope: data constructor ‘Jones’
05:24:05 <Twey> Curses, warnings.
05:28:49 * hackagebot remote-debugger 0.2.2 - Interface to ghci debugger  https://hackage.haskell.org/package/remote-debugger-0.2.2 (atsky)
05:34:19 <maerwald> "A nil error denotes success; a non-nil error denotes failure." -- I want back to haskell :/
05:34:47 <aweinstock> maerwald: what is that from? smalltalk/ruby/objc?
05:34:50 <maerwald> Go
05:34:51 <nshepperd> haha, go?
05:34:57 <nshepperd> yep
05:35:05 <maerwald> tried to write a singly linked list... I am already full of pointers
05:35:07 <maerwald> and no polymorphism
05:35:25 <Rembane> Error handling in Go is... interesting.
05:35:34 <aweinstock> does Go at least have void*'s so you can write type-unsafe boxed polymorphic linked lists like you can in C?
05:35:40 <chattered> maerwald: No polymorphism = more practical.
05:35:45 <maerwald> aweinstock: it's interface{}
05:35:52 <maerwald> sort of an empty interface
05:35:53 <maerwald> -.-
05:36:27 <chattered> aweinstock: You should be able to get as dirty as you want. I think their runtime is self-hosted.
05:36:51 <maerwald> it's supposed to be typesafe though
05:36:56 <aweinstock> I heard that Go has some feature `go generate` that lets you integrate codegen, is doing generics by having haskell-that-writes-go feasible and/or a good idea?
05:38:13 <Twey> nshepperd: http://lpaste.net/8495604470091087872
05:38:30 <maerwald> maybe I should have gone with Rust instead... seems a little bit more creative in its language design
05:39:12 <Twey> maerwald: Is there some reason you have to create Go?
05:39:21 <maerwald> I am forced
05:39:33 <Twey> Ah
05:39:52 <chattered> maerwald: I'm playing with Rust at the moment. As far as a systems language goes, I'm liking it. 
05:40:18 <Fay> maerwald: work for google>
05:40:19 <Fay> ?*
05:40:19 <lambdabot> Maybe you meant: v @ ? .
05:40:35 <maerwald> Fay: no thanks, I like to have free time
05:40:57 <Fay> oh no i was asking because you said you were forced to use go
05:41:28 <maerwald> chattered: I thought languages had learned from stuff like haskell, but when I look at Go, there's basically nothing
05:42:11 <maerwald> like they have been sleeping
05:42:42 <maerwald> there must be an imperative language that is not too much pain for someone who knows haskell
05:42:57 <dramforever> maerwald: that language exists
05:42:59 <dramforever> it's called haskell
05:43:02 <chattered> maerwald: Rust was originally written in Ocaml, so you know those folk were familiar with typed functional languages.
05:43:04 <maerwald> dramforever: no
05:43:29 <maerwald> chattered: maybe I can convince people to do that instead of Go :P
05:43:49 <catgocat> What is the difference between :add and :load'
05:43:51 <catgocat> ?
05:43:53 <aweinstock> maerwald: I work on mozilla servo, and rust seems to be a mix of haskell and C++ (in a good way)
05:43:53 <nshepperd> rust and c++, I think, stole some useful ideas from haskells at least
05:44:08 <nshepperd> moreso rust
05:44:10 <Twey> I'm not sure C++ got any ideas from Haskell
05:44:18 <dramforever> python?
05:44:35 <joco42> Applicative 's are the basically just functors such that multi parameter functions can be applied to them? is this a good understanding?
05:44:48 <joco42> scratch the
05:45:08 <aweinstock> also, in Bjarne's book "the design and evolution of C++", he explicitly mentions ML as an inspiration for parts of C++ (and gives it as an example of something that's good, but not object-oriented)
05:45:27 <mniip> joco42, pretty much
05:45:39 <mniip> including nullary functions too
05:45:41 <bennofs> joco42: sounds about right. Also "zero-parameter" functions (pure)
05:45:52 <joco42> yes, indeed
05:46:11 <joco42> thanks, then I kinda get the idea , I think
05:47:06 <maerwald> aweinstock: it almost looks like it has currying, but I guess you have to write the closures yourself like in Swift?
05:47:26 <dramforever> joco42: I think applicatives are best understood as "monoidal functors", which, in short, are functors that are "combinable"
05:47:30 <joco42> so the whole purpose of inventing applicativess
05:47:59 <joco42> dramforever: ok, this is a different angle
05:48:21 <dramforever> instance Functor f => SortOfApplicative f where unit :: f (); (**) :: f a -> f b -> f (a, b)
05:48:47 <aweinstock> maerwald: yeah, I think there are lifetime-related issues with trying to return a closure using the closure-sugar, so you'd need to manually make a struct containing the "closed-over" variables and implement one of Fn/FnMut/FnOnce for it
05:49:33 <mniip> pure x = fmap (const x) unit; f <*> k = fmap (uncurry id) (f ** k)
05:49:34 <joco42> dramforever: what is **? how does it relate to <*> ?
05:49:50 <joco42> thanks
05:50:15 <joco42> mniip: just answered the question
05:50:17 <mniip> dramforever, did you catch my lpaste for interval interesection thingy?
05:50:30 <dramforever> mniip: no, but I saw your message
05:50:59 <mniip> dramforever, http://lpaste.net/137850
05:52:55 <dramforever> mniip: what is checkTree supposed to do?
05:53:14 <mniip> well this is an on-line problem, right?
05:53:28 <dramforever> yeah, what does checkTree do?
05:53:50 <mniip> it checks whether a window intersects with any intervals
05:53:51 <dramforever> and do remember that the "original" problem no longer exists =P
05:54:00 <dramforever> mniip: okay =P
05:54:27 <mniip> you do "precomputing" with mkTree
05:54:29 <joco42> mniip and dramforever : thanks for the insight, pretty interesting
05:54:30 <dramforever> so you are basically (ab?)using Set to get an interval tree, right?
05:54:34 <mniip> then some cheap tests with checkTree
05:54:38 <dramforever> joco42: you're wellcome
05:54:42 <dramforever> *welcome
05:54:44 <mniip> dramforever, not really no
05:54:56 <dramforever> oh wait let me check
05:55:03 <mniip> I'm only abusing Set to get it to store the same number multiple times
05:55:13 <benzrf> thats the opposite of what set does mniip
05:55:25 <mniip> benzrf, I know :D
05:55:27 <dramforever> mniip: multiset?
05:55:38 <mniip> it maintains a balanced ordered tree though
05:55:43 <mniip> which is what I'm afte
05:56:18 <dramforever> mniip: so you check where the window is, and see if there's an interval there?
05:56:33 <mniip> dramforever, a multiset will not help
05:57:07 * dramforever would prefer an interval tree
05:57:11 <mniip> a findIndex operation on a multiset is expensive
05:57:32 <mniip> dramforever, I like this idea better
05:57:43 <dramforever> yeah the idea is good
05:57:50 <dramforever> mniip: no it's not expensive at all
05:57:59 <mniip> it very much is
05:58:06 <dramforever> how?
05:58:11 <mniip> imagine fromList [1, 1, 2]
05:58:28 <dramforever> wait what do you mean by multiset?
05:58:32 <mniip> it's a map that looks like fromList [(1, 2), (2, 1)]
05:58:33 <dramforever> how's it implemented?
05:58:38 <dramforever> oh map
05:58:45 <mniip> Draggor, Data.MultiSet
05:58:52 <mniip> from package multiset
05:59:07 <dramforever> mniip: oh basically Map a Int, right?
05:59:08 <mniip> newtype MultiSet a = MS { unMS :: Map a Occur }
05:59:15 <mniip> where Occur = Int
05:59:20 <dramforever> =)
05:59:38 <dramforever> mniip: yes and how's it slow?
05:59:44 <mniip> let's go back
05:59:49 <dramforever> k
05:59:55 <mniip> MS.fromList [1, 1, 2]
06:00:09 <dramforever> yes
06:00:11 <mniip> is basically M.fromList [(1, 2), (2, 1)]
06:00:26 <dramforever> yes
06:00:30 <mniip> now imagine we findIndex 2
06:00:47 <dramforever> just keep talking
06:00:48 <mniip> we have to check the value of each element to the left
06:00:59 <mniip> instead of a simple logarithmic descend
06:01:05 <dramforever> oh hmm...
06:01:17 <dramforever> sure, we need more information stored in each node
06:01:21 <mniip> if we do a naive log descend we end up with the index of 2
06:01:25 <mniip> while it's clearly third
06:01:45 <mniip> yeah
06:01:55 <dramforever> just store the number of elements stored in the current subtree
06:01:58 <mniip> we could store a total occur along with size in the Bin
06:02:36 <mniip> but
06:02:52 <mniip> that would require rewriting balanceL/balanceR/other not-very-beautiful Set code
06:03:26 <dramforever> yes
06:04:22 <dramforever> actually I would expect a binary tree implementation to take care of that
06:04:46 <dramforever> oh wait no no no no
06:07:05 <fractalsea> Hi, does anyone know why I get this error on Mac OSX when I try and build with -debug: ld: library not found for -lHSrts_thr_debug_p?
06:07:22 <fractalsea> I can’t find any information online about HSrts_thr_debug_p library
06:08:42 <zomg> rts_thr_debug_p might be referring to a runtime system's thread debugging but whether that's of any help on this I have no idea :)
06:09:03 <brtmr> Hi. Is there a way to automatically derive the (Eq) instance for an imported data type? I am working with a rather large data type, which does not have an Eq instance, but I need one for writing tests.
06:09:08 <fractalsea> Yeah I guessed it was something to do with that, but I have no idea where to get hold of the library
06:09:24 <dramforever> brtmr: StandaloneDeriving
06:09:29 <fractalsea> The only result in google is for a Russian Haskell IRC channel logs
06:10:42 <keko_> the _p at the end sounds like a version of the library compiled with profiling
06:10:52 <benzrf> is liftA2 mappend in the stdlib
06:10:58 <keko_> you can probably find more references if you search without the _p
06:10:59 <benzrf> @hoogle f m -> f m -> f m
06:11:00 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
06:11:00 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
06:11:00 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
06:11:05 <benzrf> man
06:11:14 <dramforever> brtmr: can you "hear" me? it's kinda "loud" here...
06:11:53 <benzrf> oh wait data.map aint applicative
06:13:26 <keko_> fractalsea: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Config
06:13:29 <benzrf> nvm, unionWith mappend
06:13:56 <chattered> benzrf: Can't you just mappend the maps directly?
06:13:57 <keko_> fractalsea: it sounds like you're trying to build with both -debug and -prof enabled, but you don't have a corresponding RTS
06:14:12 <keko_> oh, and -threaded too
06:14:13 <benzrf> chattered: wrong instance
06:14:18 <benzrf> chattered: it's just left-biased union
06:14:27 <chattered> Ah yeah. That's annoying.
06:14:56 <keko_> fractalsea: are you specifically trying to build with all three of those enabled?
06:14:56 <blablaa> is there a library for STRICT arrays?
06:15:28 <chattered> When they copied Map over to scalaz, they made it unionWith mappend.
06:15:47 <blablaa> (i know there are unboxed arrays, but i want strict arrays of arbitrary types)
06:16:17 <fractalsea> keko_: Oh yes I am
06:16:27 <fractalsea> keko_: So turning off prof should do it?
06:16:35 <keko_> fractalsea: yeah, probably
06:16:41 <fractalsea> thank you
06:17:04 <keko_> assuming there's a version of RTS built with -threaded and -debug
06:17:42 <keko_> but yeah, sounds like whoever built your GHC package didn't tell it to build the RTS with support for all three
06:18:07 <keko_> so if you want all three, you might have to install GHC from some other source
06:23:23 <brtmr> thanks dramforever. You just saved me from typing ~300 lines of instance declarations.
06:23:38 <dramforever> brtmr: you're welcome
06:23:39 <dramforever> =)
06:23:56 <dramforever> brtmr: but it did took time for you to read the wiki page didn't it =P
06:26:14 <blablaa> strict arrays of arbitrary types, any idea?
06:27:01 <dramforever> blablaa: what about forcing the elements before constructing the array?
06:27:30 <blablaa> dreamdust, that's ok but i don't want to pay for a conditional check just before accessing each element
06:28:33 <blablaa> dreamdust, maybe repa library? data.vector?
06:28:56 <blablaa> maybe Unboxed arrays of pointers...
06:31:08 <Peaker> does anyone use stack-mode/ide-backend?
06:31:21 <Peaker> Trying to switch from haskell-mode/ghci-ng to it -- nothing seems to work :(
06:31:56 <kuribas> why is there a warning for shadowing inside a do block?
06:32:33 <dramforever> kuribas: explain that question further
06:32:44 <keko_> kuribas: you mean like do { let x = 1; let x = 2; } ?
06:32:49 <kuribas> yeah
06:33:04 <kuribas> If I use x2 it easier for me to mistake them later.
06:33:05 <kadoban> Peaker: I looked into it as a project. I couldn't get the thing building, and it was pretty unclear exactly how it was even supposed to work … I gave up.
06:33:07 <kuribas> or x'
06:33:45 <dramforever> kuribas: explain your use case
06:34:48 <kuribas> more like do { x <- m1; x <- update x; ...}
06:35:16 <kuribas> x is updated, so if I use x2 instead, I might accidentally use the old value.
06:35:26 <kuribas> So it would seem safer to shadow the existing binding.
06:36:01 <keko_> I would expect it to be easy to accidentally create recursive definitions like that
06:36:13 <dramforever> kuribas: do x <- m1 >>= update
06:37:21 <keko_> like, if you have do { let x = 0; let x = x + 1 }
06:38:07 <kuribas> the real code, split near curves: http://lpaste.net/138085
06:38:18 <kuribas> keko_: but that's using let
06:39:56 <Peaker> kadoban: I got it to build and supposedly work, but it fails
06:43:46 <kadoban> Peaker: I think you need a few related projects, in case you didn't figure out that part.
06:44:08 <kadoban> IIRC one of them had changed named or something since the blog post, which confused me a bit at the time.
06:49:43 <sinelaw> is there an ST monad transformer?
06:49:55 <benzrf> would it be STT
06:50:19 <sinelaw> it looks old 
06:50:24 <sinelaw> is it still relevant?
06:50:35 <sinelaw> or is there some other latest and greatest?
06:50:46 <byorgey> sinelaw: https://hackage.haskell.org/package/STMonadTrans-0.3.3 ?
06:51:15 <sinelaw> byorgey, benzrf thanks!
06:51:18 <catgocat> What is the difference between let and let .. in ? Is one only available in do notation?
06:51:34 <benzrf> yes, catgocat 
06:51:42 <kadoban> catgocat: let without an in is sugar, which only works in a do block, yeah.
06:51:45 <byorgey> catgocat: yes, let by itself is only in do notation, and it gets translated to let .. in
06:52:08 <byorgey> do { let x = y; blah } === let x = y in  do { blah }
06:52:12 <brtmr> I want to test a binary parser in hSpec by running it against a default implementation. I test an IO action against a pure value with `shouldReturn`. How can I test it against another IO action?
06:52:20 <catgocat> So x <- return 32; let q = 32; is the same as return 32 >>= \x -> let q = 32 in ..
06:52:32 <byorgey> catgocat: right
06:52:35 <catgocat> ok got it
06:52:38 <catgocat> thanks
06:55:29 <byorgey> brtmr: I am not familiar with hspec, but   given  m, n :: IO a   you could always create   (do x <- m; y <- n; return (x == y)) :: IO Bool   and then use shouldReturn True
06:55:48 <catgocat> When I bind an already existing name to another, does the compiler optimize it and forgets about the previous binding?
06:55:55 <catgocat> to another value * 
06:56:04 <byorgey> brtmr: the downside of course is that you don't see the bad value when it fails
06:56:32 <geekosaur> catgocat, the original binding is forgotten but the value may remain if it is referenced somewhere else
06:56:52 <byorgey> catgocat: if you mean in a do-block, that just gets translated to something like     m >>= (\x -> ... >>= (\x -> ...))  where the first x is shadowed by the second x inside the inner scope
06:57:20 <catgocat> Got it :)
06:57:39 <byorgey> the first x is not "forgotten", it just can't be referenced from the rest of the do-block
06:58:02 <byorgey> the compiler may be able to do some optimization depending on how x is used inside the two ...
06:58:16 <catgocat> Is :set +m good practice in the ghci?
06:58:31 <catgocat> Sorry for so many questions but I'm just starting to dig into the documentation and there is so much things I'd like to know
06:59:28 <brtmr> byorgey: yes, thats my Problem. The parser puts out a large list list (100,000+) of a rather large datatype (~100 constructors), so seeing which case is the faulty one would be necessary. 
07:01:13 <byorgey> catgocat: what does :set +m do again?  I forget
07:01:34 <catgocat> In the ghci, if it detects that the current line is unfinished, it allows multi-line.
07:01:42 <clrnd> hi everyones
07:01:42 <byorgey> catgocat: no need to apologize for asking questions, this is a good place for them =)
07:01:55 <catgocat> Prelude> let q 0 = 1
07:01:56 <catgocat> Prelude|     q n = n * q (n - 1)
07:02:01 <byorgey> catgocat: huh, I didn't know about that =)
07:02:04 <byorgey> catgocat: sure, that's pretty neat
07:02:16 <catgocat> I'll start using it more often though.
07:02:17 <byorgey> hi clrnd 
07:02:23 <catgocat> Is there any way I can do :set by default?
07:02:33 <catgocat> Instead of having to write it over and over everytime I load up ghci.
07:02:36 <clrnd> catgocat, ~/.ghci :D
07:03:12 <byorgey> catgocat: see https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-dot-files.html
07:03:52 * hackagebot tidal-midi 0.1 - MIDI support for tidal  https://hackage.haskell.org/package/tidal-midi-0.1 (AlexMcLean)
07:04:17 <clrnd> so, I have a problem, I have a 20GB xml I wanna get into postgres
07:04:18 <byorgey> catgocat: I have mine set up to turn on some language extensions and load some libraries that I often use, like e.g. Data.List
07:04:44 <clrnd> I have an implementation in Python that just makes a LOT of INSERTs so it takes 2 days to finish
07:04:45 <catgocat> Do you guys use Windows?
07:05:16 <catgocat> Funny story: I was messing around with the dd command and ended up clearing my disk.
07:05:38 <byorgey> catgocat: woops
07:05:41 <tdammers> clrnd: would it be possible to sax over the xml and output SQL?
07:05:43 <clrnd> so I figured, I should code something in haskell with some streaming lib (pipes? conduit?) that writes a big file with COPY, and then postgres can read that in a few minutes
07:06:02 <byorgey> catgocat: I personally use linux, but there are Haskellers who use Windows
07:06:28 <catgocat> I used Ubuntu.
07:06:37 <catgocat> But after that happened, I installed W10
07:06:43 <clrnd> tdammers, not sure how I can stream with sax, I was looking at hexpat too
07:07:00 <tdammers> sax as in a streaming XML parser
07:07:04 <tdammers> as opposed to a DOM parser
07:07:40 <clrnd> sax looks super simple, I like it
07:08:12 <tdammers> catgocat: AFAIK, Linux has the best Haskell experience; a lot of people use OS X, too, but there were some quirks in the past
07:08:26 <clrnd> tdammers, I see parseBytes takes strict ByteStrings
07:08:28 <catgocat> tdammers: Why does Linux has the best Haskell experience?
07:08:38 <catgocat> Because of vim and emacs?
07:08:46 <tdammers> catgocat: no, those can be had on all platforms
07:08:53 <catgocat> So what is it then?
07:09:05 <tdammers> catgocat: no, it just appears that things tend to work best on Linux
07:09:13 <maerwald> windows doesnt have gmp support, no?
07:09:29 <chattered> (NixOS has the best Haskell experience)
07:09:32 * chattered hides
07:09:34 <tdammers> obviously Windows is a second-class citizen for being substantially different from a unix-like system wrt system libraries
07:10:08 <tdammers> OS X, with its unix support and all, should in theory be perfect, but there's been some mild breakage in the past
07:10:23 <tdammers> particularly wrt installing things
07:11:01 <indiagreen_> why does cabal install an old version of a package (as a dependency) when a newer version is already installed?
07:11:50 <kadoban> indiagreen_: Required by constraints maybe?
07:11:57 <hexagoxel> because one of the packages depending on that package has an upper version bound, probably
07:15:24 <catgocat> In the ghci, I set `:def source readFile`, then I do `:source "bike.hs"` but I get the error: *** Exception: "bike.hs": openFile: invalid argument (Invalid argument)
07:15:31 <catgocat> Works fine if I do readFile "bike.hs" directly
07:17:44 <catgocat> Nevermind, the quotes were causing the trouble.
07:17:49 <catgocat> :source bike.hs works fine
07:22:46 <clrnd> tdammers, thanks, hexpat + sax seems to be what I want
07:22:47 <clrnd> cya
07:22:53 <tdammers> my guess is thao/
07:23:06 <tdammers> hrrng mispaste
07:33:35 <lpaste_> ljli pasted “typechecker fail 7.10.2” at http://lpaste.net/138087
07:34:36 <ljli> Hi there, I got strange typechecking issues with GHC 7.10.2. I pasted a minimal example here http://lpaste.net/138087. Any ideas?
07:34:59 <byorgey> ljli: looks like a bug.  You should submit it to the GHC bug tracker.
07:36:09 <ljli> byorgey: That's we suspected. I'll report it.
07:36:53 <catgocat> http://i.imgur.com/306YKbF.gif
07:43:17 <brtmr> bygorgey: Thanks for the tip. I decided for a slightly tweaked version of your idea. I created a function compare :: IO (Maybe a,Maybe a), that returns the first offending pair of elements. Now I can use shouldReturn (Nothing,Nothing) to check for a successful parse and still see a problem when it occurs!
07:43:40 <byorgey> brtmr: oh, clever!  glad you were able to get something to work.
07:52:50 <sgronblo> cana cabal install a package and also update your .cabal file at the same time?
07:53:06 <sgronblo> like npm install --save?
07:54:39 <tdammers> why would it update the .cabal file?
07:55:02 <tdammers> I think there's a freeze feature where you can dump a list of exact package versions in cabal.config or something
07:55:41 <sgronblo> well wouldnt that make sense if you wanted somebody else to be able to install the same stuff if they tried to run your project?
07:59:16 <kadoban> sgronblo: I'd edit the file myself and then cabal install --dependencies-only or whatever. (Or actually I'd use stack, but the flow for that would be the same)
07:59:33 <sgronblo> kadoban: yeah im trying to use ghc-mod too, so i cant use stack currently
08:00:06 <sgronblo> kadoban: so how do you pick which version to install? just go with the newest one and pray it works?
08:01:03 <kadoban> sgronblo: I use whichever is in stackage … but newest sounds like a plan if you don't know I guess?
08:02:07 <sgronblo> kadoban: all right, just gotta do some trial and error i guess
08:04:36 <Peaker> how does one install "globally" with stack?
08:04:57 <kadoban> Peaker: 'stack install'. You're supposed to add the directory it mentions to your path.
08:05:48 <Peaker> kadoban: The data files are still in ~/source-dir/.stack-work though
08:06:11 <Peaker> kadoban: whereas cabal install puts them in ~/.cabal/share/...   or with --global in /usr/...
08:09:22 <broma0> Does anyone have some code I can look at illustrating how to create a restricted io monad? Like "MonadReadFile" or something?
08:09:36 <broma0> Or maybe a simple explanation will do
08:10:37 <cribbage8> fmap length ("hello", "there") evaluates to ("hello",5). Anyone know why? I would have expected the value to be (5,5).
08:11:03 <Peaker> cribbage8: fmap :: Functor f => (a -> b) -> f a -> f b
08:11:04 <maerwald> cribbage8: fmap on tuples operates on the second value, everything else wouldn't typecheck
08:11:14 <Peaker> cribbage8: ("hello", "there") :: (,) String String
08:11:34 <maerwald> cribbage8: if you want something different, you'd nee e.g. a Bifunctor
08:11:40 <Peaker> cribbage8: when you unify "f a" with "((,) String) String", you get: "f=(,) String", "a=String"
08:11:58 <Peaker> cribbage8: so you're fmap'ing over the "(,) String" instance
08:12:04 <maerwald> just try yourself to write a Functor instance for tuples that changes both values, you'll see that you cannot
08:12:13 <keko_> cribbage8: what would you expect "fmap length (42, "Hello")" to be?
08:12:16 <cribbage8> right, right, I forgot I was assuming the tuple is homogeneous.
08:12:23 <cribbage8> thanks.
08:12:47 <maerwald> @src Bifunctor
08:12:47 <lambdabot> Source not found.
08:13:21 <maerwald> @src bimap
08:13:21 <lambdabot> Source not found. My mind is going. I can feel it.
08:13:23 <maerwald> :t bimap
08:13:25 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
08:15:13 <Peaker> cribbage8: the "lens" package has the "both" lens, when lets you read/write/modify both of a homogenous tuple
08:16:18 <maerwald> I'd rather use arrows.
08:17:39 <maerwald> you shouldn't pick the heaviest solution, imo
08:17:51 <Peaker> maerwald: arrows are quite useless..
08:18:20 <merijn> "Not quite as general as hoped" :p
08:18:39 <merijn> They're basically Category + Applicative and a little Bifunctor
08:18:52 <maerwald> Peaker: then you probably didn't get the joke
08:19:24 <maerwald> bifunctor is perfectly fine for this
08:19:47 <dotxasp> Hello. How do I pass ":set prompt >" as a command line argument for ghci?
08:20:08 <merijn> dotxasp: Do you really want to do it as command line argument or do you just want to set a fixed prompt?
08:20:38 <dotxasp> As a command line argument.
08:20:55 <dotxasp> But if it's too complicated maybe the latter.
08:21:01 <Peaker> merijn: they're just an ugly formulation of Applicative with slightly different laws (though probably same laws hold in all instances(?))
08:21:01 <merijn> Then I don't know, I normally set it in my .ghci file
08:21:17 <dotxasp> .ghci?
08:21:31 <merijn> dotxasp: Windows or *nix?
08:21:37 <dotxasp> Windows.
08:22:12 <merijn> Ah, then I don't know the details. On *nix you can put a file named .ghci in your home dir and it will execute all commands in that file on startup
08:22:26 <dotxasp> Oh ok, thanks merijn. :D
08:22:28 <geekosaur> it's ghci.ini but I don't know offhand where it lives
08:22:38 <dotxasp> #!/bin/sh
08:22:39 <dotxasp> exec "$0"/../ghc --interactive ${1+"$@"}
08:22:53 <dotxasp> Does .ghci have something like this?
08:23:04 <merijn> .ghci is not created by default
08:23:25 <geekosaur> appdata/ghc/ghci.conf, where appdata depends on your system, but is usually something like C:/Documents and Settings/user/Application Data
08:23:56 * hackagebot rei 0.3.0.0 - Process lists easily  https://hackage.haskell.org/package/rei-0.3.0.0 (kerkomen)
08:24:16 <dotxasp> Oh right, thank you geekosaur.
08:27:24 <geekosaur> ...aaand %appdata% should work to locate that folder
08:27:49 <geekosaur> (my local network is barely working, sigh)
08:28:06 <ttt_fff> is there any good book on debugging _HASKELL_ programs? I feeel taht with most debugging books, the techniques they present often is avoided by haskell's type system, and the strategies they suggest (breakpoints + stepping) doens't always work in haskell
08:28:48 <ttt_fff> someone just sent me a msg via lambdabot; how do I reply?
08:29:06 <geekosaur> use @tell or @ask
08:29:07 <dotxasp> Yeah I got it work
08:29:29 <merijn> ttt_fff: stepping is a bit hard in haskell
08:29:56 <ttt_fff> yeah, I had to build a monad to capture 'frames' for debugging purposes with svg output
08:30:01 <Luke> why are cabal docs not linked on haskell.org/cabal ?
08:30:26 <merijn> ttt_fff: You know about Debug.Trace and the the ability to generate DTrace probes already?
08:30:30 <Luke> oh nevermind it is
08:30:41 <ttt_fff> merijn: yeah, but I wanted to log dat structures that rendered to svg
08:30:45 <ttt_fff> not sure how I can do that with Debug.Trace
08:30:55 <ttt_fff> can you get Debug.Trace to log data structures and render them as SVG ?
08:31:19 <nshepperd> my typical debugging process involves spamming traceShow throughout suspicious parts
08:31:25 <merijn> Debug.Trace just logs strings
08:31:44 <merijn> Oh, found the quote I was looking for
08:31:54 <ttt_fff> if debug trace could log with arbitrary monoids, I'd be so happy
08:31:58 <merijn> @quote cmccann debugger
08:31:58 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
08:32:17 <bergmark> ttt_fff: well you can trace and unsafePerformIO to write an image, maybe
08:32:17 <dotxasp> When I use "cabal sandbox init" and then "cabal install <a package>" where <a package> has been downloaded before outside any sandbox, does cabal redownload the package from internet? I use a limited internet and don't want to happen.
08:32:19 <nshepperd> you could probably write an equivalent, since it's just 'unsafePerformIO (log thing >> return x)' under the hood as far as I know
08:33:18 <nshepperd> the other half of my debugging would be factoring things out into pure functions in the hope of catching the bug in ghci
08:34:31 <hexagoxel> dotxasp: should be cached, if same package version
08:34:40 <dotxasp> thank you.
08:36:01 <ttt_fff> slightly OT; (instaling dependencies); how does "brew install" and "brew cask install" differ? I see packages that shows up in "brew search", but I can't install them for some reason
08:36:02 <nshepperd> another common idiom I use: adding "!_ = if suspicious_condition then unsafePerformIO ({log something, write some info, throw an error}) else ()" to where clauses to functions I want to debug
08:36:29 <maerwald> debugging shouldn't involve changing any code
08:36:43 <nshepperd> which avoids touching the actual logic
08:37:09 <Peaker> nshepperd: isn't that what assert should be doing for you?
08:42:39 <quchen> nshepperd: Why is that evaluated?
08:43:02 <merijn> quchen: BangPattern
08:43:53 <quchen> merijn: Yes, and? The underscore is never demanded, so who forces the evaluation? Why is it even kept in the compiled program?
08:44:09 <quchen> I don't really know the semantics of "where" I guess
08:44:26 <quchen> Or of pattern matching, if that's where the magic happens
08:44:36 <hodapp> sometimes, the commonness of things like Python and Lua and Guile makes me wonder about if anyone has attempted embedding Haskell in the same manner as an extension language for software
08:44:42 <geekosaur> ttt_fff, my understanding is "casks" are prebuilt binary packages
08:44:50 <geekosaur> (homebrew normally builds from source)
08:44:51 <hodapp> but I'd think one would have to start from Hugs or something lighter and C-based
08:45:29 <nshepperd> quchen: the body of the function has to be strict in the _, which means evaluating it to find out whether it's () or ⊥
08:45:30 <merijn> hodapp: NetBSD embedded haskell and wrote drivers in it
08:45:49 <merijn> hodapp: I think they stopped, but they wrote non-zero amounts of drivers as prototypes
08:46:07 <hodapp> merijn: are you talking about METASEPI and Kiwamu Okabe?
08:46:17 <merijn> hodapp: No idea :D
08:46:22 <quchen> nshepperd: Yes, but you only force that evaluation when the value of the _ is demanded in some way, no?
08:46:23 <hodapp> merijn: because that wasn't so much using it as an extension language
08:46:44 <hodapp> merijn: that was actually implementing parts of the OS *in* Haskell (and that's why he forked Ajhc from JHC)
08:46:58 <quchen> "const x (1+1)" has a strict function in the 2nd argument, but nobody forces it
08:47:17 <quchen> That's what I see here as well: there's a strict _ but nobody to touch it
08:47:27 <nshepperd> you force it when the function's result is demanded
08:48:09 <hodapp> sivteck was talking about this a bit too, though I thought he was more interested in Haskell for scripting or something
08:48:23 <nshepperd> otherwise you'd accidentally return a non-⊥ value
08:49:33 <nshepperd> I can only assume this gets desugared into a use of `seq`
08:50:29 <quchen> case v of { !pat -> e; _ -> e' }
08:50:29 <quchen>    = v `seq` case v of { pat -> e; _ -> e' }
08:50:48 <quchen> That makes sense.
08:51:40 <maerwald> hodapp: that would be cool I think. A lot of people I spoke to would probably be more interested in using it as an extension for a few specific tasks instead of writing a whole thing in haskell.
08:51:47 <quchen> Now we have something like "case () of { !_ -> e }", which should be "() `seq` case () of { _ -> e }" which is "case () of { _ -> e }"
08:51:58 <quchen> At least that's what my gut tells me. I should find out what "where" means.
08:52:49 <nshepperd> well now, it's not "case () of { !_ -> e }" -- you don't know whether it's () until it's evaluated
08:53:17 <hodapp> maerwald: might be tough though, since it might be aimed at a rather different end than GHC - e.g. faster type-checking, and a lighter interpreter/compiler footprint as well as one that readily embeds in C
08:53:27 <nshepperd> "case (assert foo ()) of { !_ -> e }" makes perfect sense
08:53:57 * hackagebot formattable 0.1 - Business-quality formatting of numbers, dates, and other things  https://hackage.haskell.org/package/formattable-0.1 (DougBeardsley)
08:55:55 <hodapp> maerwald: but I'm aware of very few statically-typed extension languages, though maybe I'm just not looking
08:57:12 <quchen> nshepperd: What does "!_ = e" desugar to?
08:57:38 <quchen> I can desugar expressions, but not bindings
08:58:15 <quchen> Direct translation to "let" is probably also not a good idea because of the irrefutability of let bindings
08:58:33 <catgocat> Are Doubles and Floats bounded in haskell? Do they have limits like Ints or are more like Integers?
08:58:49 <quchen> Or are patterns in "where" also irrefutable? Lots of questions :-s
08:58:57 <quchen> catgocat: They're IEEE floats, so they're bounded.
08:59:08 <quchen> The bounds being +-Infinity.
08:59:09 <catgocat> To what 32bits, 64 bits?
08:59:15 <quchen> Float is 32, Double 64.
08:59:23 <bennofs> quchen: how can patterns in where not be irrefutable?
08:59:39 <quchen> bennofs: Good question. I don't know.
08:59:54 <quchen> The Report is pretty short on that topic, or I keep missing the section that discusses it
09:00:13 <nshepperd> I *think* that 'where' and 'let' are the same in this respect
09:00:23 <nshepperd> I don't know about any relevant difference
09:00:40 <catgocat> quchen 1*10^32 :: Int overflows, but :: Double or :: Float does not.
09:01:14 <merijn> quchen: BangPatterns are extension, so the report doesn't say anything about it
09:01:26 <merijn> catgocat: That's because Double and Floats represent integers completely differently
09:01:26 <quchen> merijn: I know. The GHC manual gives the semantics though.
09:01:42 <catgocat> merijn: So what is the limit?
09:01:50 <catgocat> Or there isn't ?
09:02:07 <merijn> catgocat: There isn't one, the representation of integers just becomes more and more imprecise
09:02:34 <monochrom> it has an example "let ![x,y] = e in b" behaving as "case e of [x,y] -> b". refutable.
09:02:34 <catgocat> merijn: Yes alright
09:02:46 <merijn> > 12121212121212121212121212121212121212121212 :: Float -- little test
09:02:48 <lambdabot>  Infinity
09:02:54 <merijn> Ah, too big :p
09:03:02 <merijn> > 12121212121212121212121212121212121212 :: Float -- little test
09:03:03 <geekosaur> catgocat, given that you asked about Double / Float, they're IEEE floating point. there are indeed limits
09:03:03 <lambdabot>  1.2121212e37
09:03:04 <catgocat> merijn: Why doesn't haskell implement some sort of BigFloat (I know there is a library)? I would expect it to behave like integers, but have a dot in the middle.
09:03:18 <quchen> monochrom: Oh, I guess I should have read the informal section.
09:03:24 <merijn> catgocat: There's Fixed width datatypes
09:03:29 <merijn> catgocat: Also Ratio
09:03:43 <quchen> monochrom: But still I should find out how "where" works. But for now that'll have to suffice.
09:04:01 <merijn> catgocat: Because that doesn't seem very useful compared to Double/Float
09:04:21 <merijn> catgocat: Also, that datatype would have no hardware support, whereas GHC can compile Double/Float to hardware operations
09:04:45 <geekosaur> catgocat, it's not that difficult to make a decimal /. "bigfloat" type. it's more difficult, and a LOT slower, to make commonly used things like trig and log functions work with them
09:05:00 <catgocat> Hm ok
09:05:02 <catgocat> Fair enough
09:05:13 <catgocat> So what is the limit for Double?
09:05:21 <geekosaur> ghc uses whateverr the machine does
09:05:28 <catgocat> I see Float returns Infinity in some point, but I can't reach infinity using doubles.
09:05:45 <quchen> > 1/0 :: Double
09:05:47 <lambdabot>  Infinity
09:06:01 <quchen> > 1/(-0) :: Double
09:06:02 <lambdabot>  -Infinity
09:06:13 <catgocat> Aside from that..
09:06:30 * geekosaur tries to figure out where DBL_MIN and DBL_MAX are hidden on recentish linux
09:06:56 <quchen> > (10::Double)^1000
09:06:58 <lambdabot>  Infinity
09:07:22 <catgocat> quchen yeah that works
09:07:22 <merijn> catgocat: IEEE754 floating points are a complex thing and it's worth reading up on them at least a bit
09:07:32 <catgocat> merijn: I know nothing about them
09:07:39 <monochrom> geekosaur: float.h
09:08:02 <geekosaur> hrm. no such thing on this mint box with build-essential installed
09:08:18 <geekosaur> grep found me uses under /usr/include but no definitions
09:08:18 <merijn> catgocat: This seems like an ok basic intro http://www.softelectro.ru/ieee754_en.html
09:08:40 <obadz> how is it that "maybe" is in the prelude while fromMaybe (simpler and clearer) isn't ?
09:08:57 <monochrom> it has been float.h since K&R2 or earlier
09:09:15 <Peaker> obadz: "maybe" is more fundamental and powerful than "fromMaybe", perhaps? though both should have been in the Prelude
09:09:28 <monochrom> to be honest, I only did "man float.h"
09:09:33 <catgocat> Do you guys have any resources on understanding more low level stuff? I am 15 years old and I don't have a CS degree (yet). When I see bits and bytes and IEEE and other stuff, I just run away.
09:09:40 <nshepperd> search (\n -> (fromInteger n :: Double) == 1/0) results in a 309 digit number
09:10:06 <quicksilver> part of  me wants to recommend Knuth's TAOCP, catgocat 
09:10:09 * nshepperd screw the docs, let's calculate the answer!
09:10:11 <quicksilver> it's deeply deeply oldskool
09:10:18 <monochrom> catgocat, I ran away when I was 15, too. I came back when I was 17. I posit that you wait the same way I did.
09:10:28 <quicksilver> but it will certainly show you some lowlevel stuff
09:11:02 <obadz> Peaker: why is it more fundamental?
09:11:31 <catgocat> quicksilver what is it about? Art of programming won't mostly cover things like variable and other basic stuff?
09:11:43 <quicksilver> it is about computation
09:11:46 <monochrom> and yes, when I came back at 17, things suddenly looked trivial
09:11:51 <nshepperd> aww, lambdabot doesn't have binary-search
09:12:03 <hodapp> has Haskell anything (maybe around the FFI stuff) to check if a string is a valid C identifier? I can implement this myself without too much trouble but I figured I would check if it's already standard
09:12:03 <quicksilver> it talks about memory storage and it has a toy assembly language for examples
09:12:07 <catgocat> quicksilver what knowledge does it assume
09:12:16 <quicksilver> as far as I can remember, jsut high-school maths
09:12:22 <quicksilver> it's a long time ago I last looked at it
09:13:10 <catgocat> quicksilver maybe it's outdated
09:13:21 <monochrom> hodapp: maybe "language-c" has it
09:13:44 <quicksilver> in a sense it is, catgocat 
09:13:56 <quicksilver> which is why I don't give it an unqualified recommendation
09:14:02 <quicksilver> but some of it is quite fundamental
09:14:12 <quicksilver> to you have access to a library? Go sit there and read a bit, see if it grabs you.
09:14:57 <ttt_fff_> I wonder if haskell will become the java; i.e. enterprises forces people to use it because it limits the damange of what an idiotic programmer can do
09:15:13 <monochrom> no
09:15:36 <merijn> hodapp: No, because what counts as a valid C identifier is dependent on the implementation
09:15:37 <Peaker> obadz: because it is the catamoprhism of the Maybe type
09:15:43 <merijn> Maybe Posix is more precise
09:16:04 <monochrom> oh! I forgot identifier length, yeah
09:16:06 <obadz> Peaker: you've just lost me :)(
09:16:10 <merijn> But last I checked the only rule is that the identifier "must be unique within the first 8 characters", not many rules other tha that
09:16:36 <hodapp> merijn: it is? I thought the C spec mandated it
09:16:40 <merijn> obadz: catamorphism is the fancy way of saying "unfolding"
09:16:57 <merijn> hodapp: Not as far as I remember, but you'll have to see if mauke contradicts me :p
09:18:19 <Peaker> merijn: why "un"folding?
09:18:30 <merijn> Peaker: Am I misremembering?
09:18:36 <Peaker> I think it's a fold?
09:18:43 <merijn> I can never keep cata/ana morphism straight
09:19:43 <obadz> yeah the type signature of unfold doesn't look like that of maybe
09:19:54 <monochrom> it's a fold
09:19:59 <Peaker> obadz: if you have a data type like:  data Data = A A1 A2 | B B1 B2 | ... ;  it is (at least close to) equivalent to a function like: foldData :: (A1 -> A2 -> res) -> (B1 -> B2 -> res) -> (...) -> res
09:20:06 <obadz> that of foldl, doesn't either :-(
09:20:14 <merijn> See, and this is why people should just use fold/unfold instead of "catamorphism"
09:20:50 <maerwald> merijn: doesn't sound as cool, you know...
09:20:56 <monochrom> wait til you speak to a Greek who hasn't learned English :)
09:21:18 <obadz> Peaker: that makes sense
09:21:29 <Peaker> obadz: data Maybe a = Nothing | Just a     -->   equivalent to: res -> (a -> res) -> res      so it makes sense to convert a Maybe a to such a value:  Maybe a -> res -> (a -> res) -> res,  and then flip for convenience:  res -> (a -> res) -> Maybe a -> res
09:21:42 <obadz> Peaker: yes I see it now
09:22:07 <obadz> ok, now onto the broader question: how do I wrap my head around this: https://github.com/grayjay/json-rpc-server/blob/master/src/Network/JsonRpc/Types.hs#L67 ?
09:22:16 <Peaker> obadz: and another way to look at a non-recursive fold is as doing the pattern-matching for you (with a more concise syntax, but you lose all the nice naming)
09:23:19 <merijn> obadz: With lots of effort...
09:23:26 <merijn> obadz: I dislike typeclasses like this
09:23:40 <obadz> what is this .!? operator or is it multiple operators?
09:23:53 <Cale> merijn: Of course, now we have Data.Foldable to confuse the matter a bunch by having very little to do with general catamorphisms
09:24:03 <carter> @tell kirstof the #numerical-haskell channel is a better community for that topic
09:24:04 <lambdabot> Consider it noted.
09:24:27 <Cale> obadz: That is a valid name for an infix operator
09:24:36 <Cale> obadz: What library is it from?
09:24:50 <Cale> (probably lens?)
09:25:03 <obadz> no idea it's not explicitly importefd
09:25:17 <obadz> Cale: (looking at https://github.com/grayjay/json-rpc-server/blob/master/src/Network/JsonRpc/Types.hs#L67)
09:25:32 <Cale> actually, no, lens doesn't define that
09:26:07 <obadz> ooooh
09:26:09 <merijn> obadz: No
09:26:11 <obadz> I see it
09:26:12 <Cale> Ah, V.!?
09:26:13 <obadz> V.!?
09:26:16 <merijn> obadz: It's a qualified imported operator :)
09:26:17 <obadz> I get it now
09:26:18 <Cale> it's !? defined in the module V
09:26:23 <obadz> grrrr
09:26:34 <obadz> thanks guys :)
09:26:36 <quicksilver> Cale: "Now" we have data.foldable? That module is more than 10 years old :P
09:26:48 <Zekka> Oh yeah, V.!? ! Now the meaning is obvious
09:26:50 <Cale> quicksilver: I guess :)
09:27:11 <merijn> Zekka: Well, if you know qualified operators it does
09:27:20 <merijn> :t (Prelude.!!)
09:27:21 <lambdabot> [a] -> Int -> a
09:27:23 <Cale> quicksilver: I was sort of half-ignoring the fact that it existed for quite a while
09:27:23 <merijn> :t (!!)
09:27:24 <Zekka> merijn: I do know qualified operators. I'm saying !? still doesn't tell me much
09:27:25 <lambdabot> [a] -> Int -> a
09:27:29 <quicksilver> :)
09:27:41 <merijn> Zekka: I'm guessing "safe indexing"
09:27:52 <arkeet> I'm guessing look at the docs
09:27:53 <merijn> Zekka: ! and !! are often used as indexing operator
09:28:05 <obadz> :t Data.Vector.!?
09:28:06 <lambdabot> parse error on input ‘Data.Vector.!?’
09:28:08 <Zekka> merijn: Yeah, I'm aware. That theory sounds fairly plausible
09:28:13 <obadz> :t Data.Vector.(!?)
09:28:14 <lambdabot> Not in scope: data constructor ‘Data.Vector’
09:28:14 <lambdabot>     Not in scope: ‘!?’
09:28:14 <lambdabot>     Perhaps you meant one of these:
09:28:20 <arkeet> :t (Data.Vector.!?
09:28:21 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:28:24 <arkeet> ahhhhh
09:28:25 <arkeet> :t (Data.Vector.!?)
09:28:26 <lambdabot> Data.Vector.Vector a -> Int -> Maybe a
09:28:36 <obadz> :)
09:28:47 <arkeet> https://hackage.haskell.org/package/vector-0.11.0.0/docs/Data-Vector.html#v:-33--63-
09:28:51 <Cale> I really think that Data.Vector.(!?) probably ought to be allowed as a syntax.
09:28:58 * hackagebot casing 0.1.0.0 - Convert between various source code casing conventions  https://hackage.haskell.org/package/casing-0.1.0.0 (TobiasDammers)
09:29:09 <obadz> Cale: agreed
09:29:12 <arkeet> perhaps.
09:29:33 <merijn> Zekka: So, I agree it's not completely obvious, but people do try to use some sort of consistent/naming schemes so once you get a bit familiar with common libraries it's a bit more intuitive
09:30:48 <arkeet> until then I recommend looking up documentation for unfamiliar things
09:30:55 <__monty__> I have an error about type variable scopes that I -h-a-r-d-l-y-, that I *don't* understand. Could someone enlighten me?
09:31:07 <arkeet> post code and error
09:31:45 <merijn> I'm betting on "thought ScopedTypeVariables was the default behaviour" :)
09:32:07 <obadz> ok so the line that really makes my brain explode is ExceptT (return arg) >>= \a -> _apply (f a) ps nextArgs
09:32:38 <mpickering> which types are instances of BufferedIO and IODevice
09:33:05 <merijn> obadz: Ok, 1 step at a time, where do you get lost?
09:33:27 <ankitk> hi, I need to run a shell script, and get its output, from a haskell program. What are my options ?
09:33:57 <merijn> ankitk: The process package?
09:34:03 <monochrom> System.Process has a lot of options
09:34:11 <merijn> ankitk: That has everything from hacky "system" to "doing it properly"
09:34:15 <monochrom> perhaps begin with readProcess
09:34:30 <monochrom> I mean try readProcess first. but there are other options.
09:34:47 <ankitk> readProcess has output of type IO String
09:34:53 <ankitk> I want to get only String
09:34:59 <monochrom> cannot be done
09:35:05 <obadz> merijn: actually I think I kinda get it but I'm still hazy on monad transformers
09:35:13 <arkeet> you can feed it to something else in IO that takes a String.
09:35:27 <monochrom> read my http://www.vex.net/~trebla/haskell/IO.xhtml . you need it.
09:36:05 <obadz> merijn: I don't actually get which one is the "inner monad"
09:36:10 <arkeet> this is also good https://wiki.haskell.org/Introduction_to_IO
09:36:23 <geekosaur> ankitk, learn how to work with IO
09:36:27 <ankitk> let me explain, I am trying to implement a program judge, like SPOJ in haskell. But all packages I tried lead to monadic operations, and it becomes impossible to get the output back in the program
09:36:29 <geekosaur> there is no other option
09:36:32 <merijn> obadz: Neither do I, it's hard to see because of the ridiculously complex typeclass buggery there
09:37:30 <obadz> type RpcResult m r = ExceptT RpcError m r
09:37:36 <arkeet> ankitk: then you must understand how to use IO.
09:37:39 <Cale> ankitk: Monadic operations? Do you mean IO?
09:37:44 <obadz> why not just have an Either RpcError r ?
09:37:54 <monochrom> sorry ankitk, that doesn't change the situation. our advice still stands.
09:38:07 <ankitk> i have tried shelly too, but problem is, once you run a shell script from haskell, there is no going back. You can echo output or write to another file, but cant get it inside the program
09:38:23 <Cale> ankitk: It should never hurt to know that some type is a monad -- this isn't a restriction, it's simply a fact regarding the API of the library.
09:38:36 <Cale> Hm?
09:38:36 <geekosaur> ankitk, IO requires IO. all programs *start* in IO, so this is not a restriction.
09:39:04 <Cale> ankitk: You can certainly take the result of an IO action and pass it along to the rest of your program.
09:39:09 <ankitk> I understand , but extracting data from monads is difficult
09:39:14 <geekosaur> you do not have the option of somehow turning something intrinsically impure into pure. you do have the option of lifting pure functions into IO, which is how you do things
09:39:14 <arkeet> IO is not monads.
09:39:16 <Cale> "from monads"?
09:39:28 <geekosaur> :t (>>=)
09:39:29 <lambdabot> Monad m => m a -> (a -> m b) -> m b
09:39:30 <Cale> Monads are type constructors, they're not even values which are present at runtime.
09:39:32 <arkeet> extracting data from IO actions is very easy inside IO.
09:39:55 <Cale> If you're talking about IO actions, then say IO actions :)
09:39:56 <monochrom> ankitk: once again, read my http://www.vex.net/~trebla/haskell/IO.xhtml . it tells you what to do. this advice still stands after your extra information. does not change.
09:40:01 <chattered> Cale: Motes?
09:40:03 <maerwald> Cale: I don't think he cares about what happens at runtime
09:40:11 <ankitk> ohk I get, like
09:40:11 <maerwald> looks nitpicky
09:40:13 <Cale> It's easy to capture the result of an IO action by executing it inside of another IO action, and doing something with the result.
09:40:27 <hackrilege> hi everybody, im reading functor is to lens as applicative is to biplate http://arxiv.org/ftp/arxiv/papers/1103/1103.2841.pdf
09:40:42 <arkeet> functor is to lens as applicative is to traversal.
09:41:01 <arkeet> well, Lens and Traversal.
09:41:10 <Cale> ankitk: When you write  v <- x  inside a do-block for an IO action, it means "execute the IO action x, and call its result v". If x has type IO t, then v has type t.
09:41:36 <AshyIsMe> wow, hyperlinked hackage sources: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.IO.Handle.html#hClose
09:41:36 <hackrilege> here the store comonad is stated as dual to the state monad (?) where a comonad is dual to a monad. what is dual?
09:41:39 <AshyIsMe> yes please!
09:41:40 <Cale> ankitk: and the do-block as a whole will have type IO s for some possibly different type s (the do-block has the same type as the last action in it)
09:41:45 <ankitk> okk, lets say this IO is being done within another do block
09:42:03 <ankitk> then can i use v outside this ?
09:42:05 <arkeet> hackrilege: https://en.wikipedia.org/wiki/Dual_%28category_theory%29
09:42:08 <ttt_fff> argh
09:42:14 <ttt_fff> if you get the data strutures wrong, the algorithms will suck
09:42:32 <Cale> ankitk: You can pass v along to whatever functions and so on you'd like, and they needn't have anything to do with IO (but they may, if you wish)
09:42:34 <hackrilege> thanks arkeet: 
09:42:37 <tommd> ankitk: You must return values from nested scopes, just as in functions.
09:42:49 <cocreature> hackrilege: in haskell dual mostly just means turning function arrows around
09:42:53 <johnw> hackrilege: store is not immediately dual to state; it's dual by flipping the arrow of the adjunction
09:42:53 <Cale> ankitk: and then do whatever further I/O you want with the results of that
09:43:08 <hackrilege> i guess the question is actually why do we work on these duals and not on monad and state?
09:43:11 <Cale> ankitk: As a simple schematic example, consider   do v <- getLine; putStrLn (reverse v)
09:43:25 <arkeet> hackrilege: they are different concepts.
09:43:42 <johnw> i.e., dual would be turning s -> (s -> (a, s), s) into (s -> (a, s), s) -> s.  This kind of dual is going from s -> (a, s) to (s, s -> a)
09:43:42 <ankitk> ok
09:43:46 <arkeet> it's somewhat like asking why we work using addition instead of multiplication.
09:44:05 <Cale> ankitk: Here, reverse :: String -> String needn't know or care that its argument came from executing getLine, and similarly, it doesn't know that its result will be used by putStrLn
09:44:09 <ankitk> thanks Cale, I will try readProcess, and see if it works
09:44:10 <ankitk> :)
09:44:34 <__monty__> How often should/can I repeat my question if don't get a reply? I don't want to spam the channel but on the other hand I want to optimise my answer reception chances?
09:44:35 <f-a> I forgot: which options do I have to modify in .cabal/config to enable bulding with profiling on?
09:44:36 <hackrilege> so we achieve some abstration by considering the dual?
09:44:51 <geekosaur> __monty__, you got several responses
09:45:02 <johnw> hackrilege: in category theory, duality usually means you get two results for the price of one
09:45:12 <Cale> __monty__: Did you post your code and the error on lpaste so we can see it? You didn't give a link?
09:45:16 <geekosaur> hm, ok, you got one and a metacomment
09:45:33 <monochrom> __monty__, the most important reply to you was "<arkeet> post code and error". you should not ignore it.
09:45:39 <johnw> hackrilege: in Haskell, not every dual construction has value
09:45:56 <geekosaur> __monty__, the point is you included no information abotu what is confusing you, no code, no example, ... what is the question?
09:46:42 <hackrilege> __monty__ i hope that you would be forgiven for taking as many phrasings as needed for you to correctly articulate your question so that the response is satisfactory. often this process teaches the asker of the question exactly what they mean, which goes some way to helping them understand the answer
09:47:21 <Cale> hackrilege: It really doesn't matter all that much that it's the dual. I don't think we get so much leverage from that fact, it's more a cute observation than anything?
09:47:59 <hackrilege> ok so we just work with what we need, which happens to be the dual of some other thing, but we are not helped by this observation...
09:48:03 <Cale> hackrilege: I suppose if you'd done a bunch of categorical reasoning about State already, then you could make plenty of use of that fact
09:48:06 <__monty__> geekosaur, Cale, monochrom, hackrilege: I apologize, I forgot to include the lpaste link: http://lpaste.net/138095 I didn't notice the replies because no one used my name, so I assumed they were parts of conversations already underway.
09:48:28 <hackrilege> dont worry, all good!
09:48:50 <hackrilege> i missed the question...
09:49:03 <arkeet> hm, where is line 191 in that code?
09:49:12 <arkeet> I don't see any nattyer
09:49:18 <__monty__> hackrilege: I have an error about type variable scopes that I  -h-a-r-d-l-y-, that I *don't* understand. Could someone  enlighten me?
09:49:36 <Cale> __monty__: That file is too short?
09:49:39 <sunnymilk> hi, i have a question, if i have a function f :: a -> (); f = g where g :: b -> (); g _ = (); how can i tell haskell that the a in f's signature is the same as b in g's signature?
09:49:40 <arkeet> or a line 191
09:50:07 <hackrilege> monty, it looks like you are trying to use a variable in a less general sense than you state it is somewhere else, i guess your type signatures are not done properly, let us see the source
09:50:10 <arkeet> sunnymilk: first, you need the ScopedTypeVariables extension
09:50:12 <monochrom> there is no "Like xy -> xy" in https://github.com/toonn/haskell-casestt/blob/master/koopa.hs
09:50:16 <sunnymilk> arkeet seriously?
09:50:20 <arkeet> yes
09:50:28 <__monty__> Cale: I probably need to push the last version...
09:50:30 <arkeet> sunnymilk: then, f :: forall a. a -> (); f = g where g :: a -> (); g _ = ()
09:50:34 <arkeet> sunnymilk: the forall is important.
09:50:40 <arkeet> because that gives it a scope.
09:50:47 <sunnymilk> lol
09:50:54 <sunnymilk> well i guess ill give that a try
09:50:55 <Cale> sunnymilk: Or you can just leave out the type annotation on g
09:50:55 <sunnymilk> thank you
09:50:59 <sunnymilk> Cale really?
09:51:00 <merijn> sunnymilk: Yes, because by default type variables don't have a scope
09:51:03 <sunnymilk> what will it infer g's type is?
09:51:06 <arkeet> Cale: that will infer a more general type.
09:51:07 <merijn> sunnymilk: Sure
09:51:16 <arkeet> but in this case it isn't a problem.
09:51:30 <Cale> sunnymilk: In Haskell 98, there are some type annotations which cannot be given.
09:51:38 <Cale> and *must* be left to inference
09:51:45 <merijn> Cale: Haskell2010 too :p
09:51:49 <sunnymilk> wow i had no idea
09:51:52 <Cale> Yeah, H2010 = H98
09:51:53 <kadoban> TheTypeWhichShallNotBeAnnotated
09:51:59 <Cale> (approximately anyway)
09:52:04 <__monty__> Cale, hackrilege: Updated source is now available here: https://github.com/toonn/haskell-casestt/blob/master/koopa.hs
09:52:08 <sunnymilk> thats really interesting, do you have any more information on what kinds of types cannot be annotated (without extensions)?
09:52:58 <sunnymilk> or is it just ones that require scoped type variables
09:53:05 <arkeet> I think it's just those
09:53:06 <S11001001> existentials revealed by deconstruction; and those, sunnymilk 
09:53:12 <Cale> __monty__: Okay, yeah, Like is an existential constructor, and you're trying to unpack it...
09:53:16 <arkeet> mhm.
09:53:39 <sunnymilk> (its funny to me that you need the quantification in the type signature togive a type variable scope since ie f :: a is (supposed?) to just be syntactic sugar for f :: forall a. a)
09:53:46 <sunnymilk> S11001001 i see!
09:53:47 <Cale> __monty__: You can't let-bind the result of that pattern match, you have to nest the pattern matches, and put the result inside them.
09:54:16 <Cale> __monty__: It might be useful to use the PatternGuards extension
09:54:20 <hackrilege> __monty__ here is your error http://pastebin.com/jneMBs9Z
09:54:47 <Cale> Hang on and I'll try to rewrite this
09:56:09 <arkeet> hm?
09:56:13 <hackrilege> __monty__ in that paste you can see that the type of foo is more general than the type of bar which it is defined in terms of
09:57:03 <arkeet> I don't think that's the problem?
09:57:27 <merijn> sunnymilk: The main reason for that is to avoid having to invent new syntax for type variable scopes
09:57:36 <merijn> sunnymilk: Since we already have syntax for introducing type variables
09:57:52 <lpaste_> Cale pasted “rewrite of p” at http://lpaste.net/138104
09:57:55 <hackrilege> koopa.hs:191:29:     Couldn't match type `x0' with `x'       because type variable `x' would escape its scope
09:57:56 <sunnymilk> i wonder if there would be any bad side effects from making type variables scoped by default
09:57:58 <Cale> __monty__: ^^
09:58:13 <sunnymilk> or at least, scoped with quantification
09:59:00 * hackagebot microlens-ghc 0.1.0.0 - Orphan instances of microlens classes for packages coming with GHC (array, bytestring, containers)  https://hackage.haskell.org/package/microlens-ghc-0.1.0.0 (Artyom)
09:59:24 <Cale> sunnymilk: It induces some source incompatibility, because right now you can reuse type variables and have things be polymorphic
09:59:25 <sbrg> I wish I had known about and understood `hoist` earlier.
09:59:49 <sbrg> I'm pretty sure i've run into barriers where I gave up where I was looking for hoist. 
10:00:01 <hackrilege> sbrg, can you introduce me to hoist?
10:00:03 <hackrilege> :t hoist
10:00:04 <lambdabot> Not in scope: ‘hoist’
10:00:09 <Cale> __monty__: So that p will typecheck, but there's still a problem with red_path_one
10:00:11 <sunnymilk> Cale ah
10:00:21 <johnw> hackrilege: if you have t m a, hoist takes an m x -> n x, and gives you t n a
10:00:24 <sbrg> hackrilege: http://ropas.snu.ac.kr/~bruno/papers/VirtualMonads.pdf this paper is really excellent.
10:01:09 <hackrilege> great stuff!
10:02:01 <broma0> Can someone answer a quick question about creating a restricted version of the IO monad?
10:02:10 <athan> Is it necessary to use -XCPP just to get rid of warnings on different compilers?
10:02:13 <hackrilege> when we work with duals can we infer anything about those classes which are dual to the ones we work with?
10:02:18 <Cale> broma0: Not if you don't actually ask the question, we can't :)
10:02:30 <hackrilege> broma0: go ahead
10:02:45 <broma0> Cale, truth. One moment
10:02:45 <__monty__> Cale: Thanks this'll help me move on. I actually solved a very similar problem with pattern guards a while back I think :s don't know why I didn't think of it.
10:02:53 <johnw> broma0: have you seen http://hackage.haskell.org/package/IOSpec?
10:03:05 <__monty__> hackrilege: Thanks for the help.
10:03:10 <Cale> __monty__: Yeah, it cuts down on the awful nested case expressions you'd otherwise need to write.
10:03:22 <hackrilege> was it on the right track?
10:03:52 <hackrilege> did it help you understand the error, or was i wrong about the meaning of the error!?
10:04:01 <hackrilege> this paste http://pastebin.com/jneMBs9Z
10:04:05 <broma0> I've got this goliath "app monad" with IO st the base, and I want to have typeclasses for IOReadFile and IOWriteFile so certain parts of my app can only have access to those functions.
10:04:17 <broma0> I'm struggling with finding docs on how to do this
10:04:30 <broma0> johnw, looking into that now
10:05:28 <broma0> Or more accurately worded "so certain parts of my app are restricted to those io functions"
10:05:33 <arkeet> hackagebot: the error wasn't about variable scope.
10:05:36 <arkeet> hackrilege: *
10:05:47 <hackrilege> damn
10:06:08 <arkeet> well ok it sort of was, but it wasn't that.
10:06:11 <johnw> broma0: more typically, and as IOSpec does, you createa  DSL that *describes* the actions you'd like to perform in IO, such that the chosen evaluator alone actually performs those actions
10:06:21 <Cale> broma0: Well, you can write something like   class Monad m => MonadReadFile m where readFile :: String -> m String
10:06:35 <Cale> broma0: and then implement an instance for IO
10:06:38 <hackrilege> broma0, why not pass handles opened with read and write permission respectivly?
10:07:30 <broma0> Cale, that's it! I have to make IO an instance so that my function without a concrete monad can still use that fn, correct?
10:07:42 <arkeet> hackrilege: https://en.wikipedia.org/wiki/Dual_%28category_theory%29h
10:07:43 <arkeet> oops
10:07:46 <arkeet> sorry
10:07:50 <arkeet> broma0: yes
10:07:55 <arkeet> er
10:07:56 <hackrilege> i saw that...
10:08:01 <Cale> broma0: You can do everything without an instance except for actually use the computation you construct.
10:08:02 <arkeet> yes, accidental paste
10:08:07 <johnw> type classes are another way to achieve what DSLs do, but there are pluses and minuses
10:08:10 <hackrilege> kk
10:08:22 <broma0> hackrilage, I'm not sure what you mean by that..
10:08:23 <johnw> (or I should say, Free-based DSLs)
10:08:28 <humanoyd> If I have `[m1, m2, m3, ..., mN]`, what's the most elegant equivalent of `m1 >> m2 >> m3 >> .. >> mN` ?
10:08:32 <broma0> Open a file handle and pass it into my pure function?
10:08:34 <Cale> broma0: If there are no instances of the class, you obviously won't be able to treat your polymorphic action as an IO action.
10:08:40 <arkeet> :t sequence_ -- humanoyd
10:08:41 <lambdabot> (Monad m, Foldable t) => t (m a) -> m ()
10:08:48 <broma0> Well not pure.. not explicit
10:08:59 <humanoyd> arkeet: Thanks!
10:09:30 <Cale> broma0: I'm not entirely sure if this is a really useful thing to do with readFile... but I suppose it might be.
10:09:31 <broma0> Cale, I think I just needed to hear it from someone else.. that make sense and will fit into my constraint based design really well
10:09:44 <broma0> That was just the example I'm using
10:09:48 <Cale> okay
10:10:02 <broma0> It'll be MonadReadWriteChan probably
10:10:14 <Cale> This in particular would only be really useful if there was a lot of complicated (pure) processing needed to determine which files to conditionally read.
10:10:36 <Cale> Otherwise, you'd more likely just execute a bunch of readFiles up-front and pass the results along.
10:11:03 <broma0> Well here's the idea, I have two processes running concurrently talking through channels
10:11:17 <broma0> And I want to restrict what they can do in IO
10:11:31 <Cale> Yeah, I suppose that's reasonable :)
10:11:32 <broma0> They both need to mess with a channel
10:11:54 <Cale> You could also make them take the actions to read and write the channel as an argument, rather than having a type class.
10:12:27 <Cale> i.e.  process1 :: Monad m => m a -> (a -> m ()) -> m ()
10:12:54 <broma0> Cale, how the heck do i do that
10:13:06 <Cale> (of course, if they need to work with multiple channels, you'd need to do more)
10:13:13 <broma0> Two channels
10:13:28 <broma0> One for x's and one for y's
10:13:41 <broma0> Process a reads x's and write ys
10:13:50 <broma0> And the opposite for process b
10:14:15 <Cale> Right, so  processA :: Monad m => m X -> (Y -> m ()) -> m ()
10:14:43 <broma0> Hmm and no class is needed?
10:14:46 <broma0> That's cool
10:14:47 <Cale> and you'd run it like  processA (readChan theXChan) (writeChan theYChan)
10:14:54 <Cale> which would specialise the monad in question to IO
10:15:01 <arkeet> classes are just a way of implicitly passing data around.
10:15:22 <arkeet> couldn't you also just 
10:15:28 <broma0> That's awesome. This may be a foolish question, but that process can reuse that partial function right?
10:15:34 <arkeet> Monad m => (forall a. m a) -> (forall b. b -> m ()) -> m ()
10:15:36 <broma0> In an infinite loop
10:15:39 <Cale> But inside processA, if its type is going to be that polymorphic, you wouldn't be able to do any ordinary IO.
10:15:49 <Cale> apart from using the actions you were given
10:15:54 <Cale> yeah
10:16:03 <Cale> You can make use of the arguments as many times as you like
10:16:20 <broma0> arkeet, isn't that what Cale is sayin?
10:16:22 <Cale> It's in fact entirely isomorphic to the class-based solution, just without the clas.
10:16:24 <Cale> class*
10:16:26 <broma0> Saying *
10:16:45 <Cale> arkeet said to demand that the arguments be polymorphic
10:17:10 <broma0> Where as you make the actions specific?
10:17:12 <Cale> But I'm assuming that X and Y are specific types with APIs that will matter, since otherwise, processA won't be able to do much which is all that interesting.
10:17:22 <broma0> They are
10:17:47 <arkeet> I guess rank 2 types are kind of annoying to deal with.
10:17:48 <broma0> How about classes for MonadWriteX
10:17:56 <Cale> Sure
10:18:14 <Cale> You can introduce the class, but whether that's a good idea is down to how often you're going to make use of it
10:18:25 <arkeet> and having specific types might make it easier to have some mock implementation.
10:18:28 <Cale> You might find it more convenient just to have the explicit parameter
10:18:57 <broma0> Cale I see. I think I'll go with your solution, keeping in mind that I can use the classes if need be.
10:18:57 <Cale> arkeet: It's pretty hard to supply something of type (forall a. m a)
10:19:06 <arkeet> precisely.
10:19:07 <Cale> arkeet: If it's meant to produce meaningful results.
10:19:16 <arkeet> I'm arguing against the rank-2 version.
10:19:17 <arkeet> :p
10:19:22 <Cale> right, okay :)
10:19:26 <broma0> Just to reiterate:
10:19:56 <broma0> Pass the processes a partial function that just needs to be passed the thing I'm writing
10:20:08 <broma0> ?
10:20:23 <broma0> Called with the thing I'm writing *
10:21:15 <broma0> And in the case of read chan, which returns and IO X, I can just keep pulling things out of it??
10:21:28 <Cale> broma0: Yeah, you just have it take the action/function for reading/writing explicitly, and leave the choice of monad polymorphic, so that even though it'll likely only ever get instantiated to IO, the implementation won't be able to assume that it's IO
10:22:11 <Cale> This also has the advantage that you could put in something like  readLn  instead of readChan theXChan or whatever, and turn it into something which takes terminal input for testing.
10:22:15 <broma0> I don't see how passing a process (readchan xchan) allows me to read many xs from it
10:22:27 <Cale> Just execute the action more than once?
10:22:33 <broma0> Whoa
10:22:36 <broma0> Cool
10:22:43 <johnw> broma0: in the same way that replicateM_ 5 (print "Hello") prints hello five times
10:22:53 <broma0> That's right, it's just a friggin action
10:22:59 <Cale> I often do this without the polymorphism, whenever I'm working with MVars or Chans
10:23:17 <johnw> yes, closing over the channel like keeps your algorithm free of the details
10:23:21 <broma0> Meaning, you have an explicit monad?
10:23:27 <Cale> Split up the read and write ends and pass those around, it's saved me more than once when I later wanted to add logging or something.
10:23:42 <Cale> Yeah, just using IO specifically instead of the abstract m
10:24:10 <Cale> Because then you can stick in something which doesn't just write to the channel, but also to a file, say.
10:24:13 <broma0> Gotcha. This idea of passing the action is nice.
10:24:18 <Cale> and record everything that your program does
10:24:27 <broma0> That could even be part of the processes reader, no?
10:25:00 <Cale> You can do stuff on the read side as well
10:25:37 <broma0> On the read side? I'm talking about putting the actions in my readert
10:25:52 <broma0> Maybe that's a little crazy
10:26:11 <Cale> You mean the action we're passing as an argument to read the channel, right?
10:26:24 <Cale> Yeah, you can definitely do additional stuff in there if you want.
10:26:25 <broma0> Yeah, or to write to the chsnnel
10:26:30 <Cale> hm?
10:26:33 <Cale> Yeah
10:27:00 <Cale> It's usually mostly logging-like stuff which comes up
10:27:14 <johnw> it's a brain-twister that actions are immutable, but their behavior can vary
10:27:19 <Cale> I used this technique to quickly construct a replay system for the game I was working on at one point.
10:27:38 <nitrix> Does haskell short-circuit `all` as soon as one element doesn't satisfy the predicate?
10:27:45 <Hijiri> yes
10:27:54 <nitrix> I'm having terrible performances :/
10:27:57 <Cale> @src all
10:27:58 <lambdabot> all p = and . map p
10:28:00 <Cale> @src and
10:28:00 <lambdabot> and  = foldr (&&) True
10:28:02 <johnw> nitrix: show code
10:28:05 <Cale> @src (&&)
10:28:05 <lambdabot> True  && x = x
10:28:05 <lambdabot> False && _ = False
10:28:17 <Cale> ^^ you can see the short circuiting there in (&&)
10:28:20 <johnw> also, run the heap profiler
10:28:27 <joeyh> is cryptonite intended to be replacing crytohash?
10:28:40 <johnw> joeyh: I hadn't even heard of cryptonite yet
10:28:59 <nitrix> joeyh: Hijiri: I'm doing Euler #5 and it takes forever to find the answer. http://lpaste.net/138108
10:29:00 <joeyh> it's pretty new, but some things already depend on it. same author as cryptohash
10:29:01 * hackagebot microlens 0.1.5.0 - A tiny part of the lens library which you can depend upon  https://hackage.haskell.org/package/microlens-0.1.5.0 (Artyom)
10:29:29 <nitrix> I thought `all` would give a performance kick, but I exhausted my options now :/
10:29:30 <Cale> nitrix: use lcm
10:29:30 * joeyh is looking for a SHA3 that meets the spec, which I think might be in cryptonite. cryptohash's version is not yet updated to the final spec
10:29:36 <nitrix> Cale: What's that?
10:29:43 <Cale> nitrix: Don't generate and test. Least common multiple
10:29:49 <nitrix> Oh.
10:29:57 <Cale> > lcm 10 8
10:29:59 <lambdabot>  40
10:30:34 <Cale> lcm x y is the least number (in the divisibility ordering rather than the usual one, really) which is divisible by both x and y
10:30:39 <johnw> joeyh: any chance of an Amazon Cloud Drive backend?
10:30:52 <Cale> > foldr lcm 1 [1..20]
10:30:54 <lambdabot>  232792560
10:31:04 <Cale> ^^ this is why it was taking so long
10:31:11 <nitrix> Oh god.
10:31:40 <nitrix> I suspect lcm has better arithmetic in the implementation than my foolish approach?
10:31:44 <Hijiri> I didn't even know lcm was in base
10:32:09 <nitrix> Or am I doing something extremely stupid? Actually I am, because I'm iterating an infinite list :/
10:32:22 <joeyh> johnw: thanks for reminding me.. depends on haskell api bindings, mostly
10:32:35 <Cale> nitrix: That's not necessarily a stupid thing to do
10:32:45 <Cale> nitrix: Your program will work, it's just going to take a long time
10:32:45 <joeyh> I assume amazonka has them
10:33:14 <Cale> nitrix: Try it on smaller lists of divisors
10:33:30 <Cale> nitrix: You can brute force this, it's just that it's rather inefficient.
10:33:47 <Cale> On some problems, iterating over an infinite list is a totally appropriate thing to do :)
10:33:58 <broma0> Cale, thank you for all the help! Very enlightening
10:34:33 <joeyh> johnw: of course that's assuming this product has an api ...
10:35:00 <johnw> joeyh: https://developer.amazon.com/public/apis/experience/cloud-drive/content/restful-api
10:35:17 <johnw> probably just need to kick aristid into adding it to aws
10:35:34 <nitrix> Cale: Last question, why foldr instead of foldl? No difference here right? Another question more significant is that, the accumulator of the fold is being set to the computed last common multiple of the previous and current element, but that means the next iteration will be checking the lcm of the previous lcm with the current element.
10:35:59 <joeyh> well, I don't mind using amazonka for something new.. I'd use it for S3, but I've already done all the work to get aws working well
10:36:00 <nitrix> Cale: Is this because there's a mathematical property that ensures you can prune all the numbers inbetween?
10:36:31 <nitrix> Maybe me rationalizing in Haskell terms is blinding from basic arithmetic...
10:36:43 <nitrix> *me
10:36:58 <Cale> nitrix: foldr just because I didn't think much about it. Using foldl (or foldl', but compiler optimisation will get that for you) would be better here.
10:36:59 <johnw> joeyh: what's better about amazonka?
10:37:41 <Hijiri> nitrix: lcm of x and kx (where k and x are positive integers) is kx
10:37:43 <Cale> nitrix: I'm making use of the fact that the least common multiple of x, y and z together, is equal to the least common multiple of x and (the least common multiple of y and z)
10:37:47 <joeyh> my impression is it's much easier for them to add/derive new api support
10:38:33 <broma0> Can I fork an "m ()" action?
10:38:40 <Cale> nitrix: lcm is both associative and commutative, so it doesn't really matter which fold we use in terms of result
10:38:52 <merijn> broma0: What do you mean by fork?
10:38:59 <Cale> (and it doesn't matter which order we put the numbers [1..20] into the list)
10:39:00 <broma0> ForkIO
10:39:11 <merijn> broma0: forkIO only takes IO actions
10:39:11 <broma0> Spawn a new thread with it
10:39:13 <merijn> :t forkIO
10:39:14 <lambdabot> Not in scope: ‘forkIO’
10:39:18 <broma0> I know
10:39:20 <nitrix> Hijiri's explanation is what I needed. Thanks.
10:39:29 <merijn> broma0: So, "no"
10:39:36 <johnw> broma0: if your m supports MonadBaseControl IO m, then yes
10:39:39 <merijn> broma0: Unless you have a function "m () -> IO ()"
10:39:54 <broma0> johnw, that's what I'm looking for.
10:40:03 <broma0> Precisely
10:40:06 <johnw> broma0: then it would be: liftBaseDiscard liftIO $ do ...
10:40:10 <johnw> sorry, forkIO
10:40:31 <johnw> just be careful, the choice of 'm' matters here if you do that
10:40:49 <johnw> because you'll be replicating 'm's internal state across the parent and the child threads
10:41:10 <johnw> for ReaderT, that's fine; even for StateT it's ok, because liftBaseDiscard explicitly says you're going to ignore stateful results from the child
10:41:36 <johnw> but there are monads like ResourceT which are very unhappy about it, resulting in custom solutions like forkResourceIO
10:42:12 <Cale> ;___; the perils of monad transformers
10:42:54 <bitemyapp> Cale: perils of big datatypes in general.
10:44:52 <Peaker> A lens Setter doesn't have to keep the same shape to be lawful right? setmapped is a Setter for Data.Set. It also has a fold(Foldable), yet the combination isn't a Traversal (which is interesting, as it means intersections don't necessarily hold)
10:44:56 <Cale> I don't really know what to do about this pedagogically. Obviously monad transformers get used often enough that it's important to teach people about them, and they're not an inherently bad idea. But it seems like the fact that we teach everyone about them means that people are quite prone to making messes with them.
10:45:21 <johnw> Cale: the exact same is true of type classes
10:45:22 <edwardk> setmapped is a contravariant setter, which really should be its own class in the grand scheme of things
10:45:33 <edwardk> they exist as a curiosity more than anything
10:45:45 <edwardk> i just never named the concept for them
10:46:03 <broma0> Johnw ahh that is troublesome
10:46:49 <Cale> johnw: Yeah, jumping into using type classes rather than good-ol'-functional-programming as the first thing you do is another tempting but often unwise thing.
10:47:32 <johnw> and then the power of simple ideas like closures gets bypassed, reaching after all the shiny bits up high
10:47:36 <Cale> It's not always the best plan to make all your arguments implicit! But I think beginners often just miss the fact that there's anything else they could be doing.
10:47:46 <Cale> Like, just passing around records of functions.
10:48:03 <Peaker> edwardk: in https://hackage.haskell.org/package/lens-1.7/docs/Data-Set-Lens.html it seems covariant?
10:48:47 <edwardk> that was a long time ago =)
10:49:16 <Peaker> oy, didn't hit "latest" :)
10:49:57 <Peaker> edwardk: https://hackage.haskell.org/package/lens-4.12.3/docs/Data-Set-Lens.html <-- how can I see its contravariant?
10:49:59 <edwardk> setmapped and the like make me a little ill
10:50:10 <edwardk> its not contravariant any more it seems
10:50:11 <edwardk> hrmm
10:50:13 <edwardk> which one was
10:50:35 <edwardk> https://hackage.haskell.org/package/lens-4.12.3/docs/Data-Array-Lens.html is the one i was thinking of
10:50:55 <Peaker> edwardk: I am making an optic to reach deep inside into one of my Sets. I could make it a Fold, I could make it a Setter, but either choice loses useful power that I need..
10:51:31 <Peaker> edwardk: is the traversal of Data.Set ill-defined whereas the Setter is well-defined? Or are both ill-defined when uniqueness is broken?
10:51:54 <edwardk> depends on if you assume equality is structural
10:52:04 <edwardk> if so then the traversal is ill defined and the setter is defined
10:52:08 <edwardk> if not then both are bad
10:52:37 <Peaker> Oh, I can make my optic go all the way to the Set and then not go inside
10:52:45 <Peaker> then the user can go inside as a fold or as a setter
10:54:02 * hackagebot microlens-mtl 0.1.3.0 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.3.0 (Artyom)
10:54:20 <broma0> Cale, I've been thinking about your "closure" comment above.. is the closure simply passing the action to my process?
10:54:39 <broma0> Whoops, that was johnw
10:54:40 <johnw> broma0: the closure is that (readChan chan) includes the reference to "chain"
10:54:48 <johnw> "chan"
10:55:52 <johnw> readChan is a function, "readChan chan" is an action and a closure.  The lifetime of "chan" is now the same as the closure, if you haven't referenced it elsewhere
10:56:07 <broma0> Ah I see
10:56:19 <johnw> it's like making a data structure on the fly, in a way
10:56:40 <johnw> only your callee can't peek inside to find the chan, they can only use it for reading via the action
10:56:57 <johnw> which is a fact with its own nice properties
10:57:01 <broma0> And that's whats so awesome
10:57:17 <broma0> I can restrict my function in a totally different way
10:57:38 <johnw> in such a simple way, you've turned chan into a read-only channel
10:58:13 <broma0> processA :: m X -> m ()
10:58:15 <broma0> Right?
10:58:23 <broma0> For a reader at least
10:58:37 <Cale> broma0: You might also want to be able to assume that m is a monad, but yeah
11:03:59 <aristid> johnw: yeah i'm not really adding too many features to aws lately, am i :D
11:04:29 <broma0> Cale, I omitted the constraints
11:04:50 <broma0> It has Monad and a bunch of mtl and lensy things
11:05:07 <joeyh> arianvp:  probably others should help out, your aws is a nice code base to work with :)
11:05:24 <joeyh> aristid: er, ^
11:06:39 <aristid> joeyh: glad to hear that, it does feel like amazonka has the better idea though
11:08:10 <Rembane> Lets say I have this tuple (a, Maybe b), how do I transform it into this tuple: Maybe (a, b)?
11:09:14 <indiagreen_> Rembane: traverse id
11:09:28 <indiagreen_> ehh
11:09:31 <arkeet> aka sequenceA
11:09:35 <indiagreen_> yeah
11:09:38 <indiagreen_> arkeet++
11:11:33 <Rembane> indiagreen_, arkeet: Cool! Thanks!
11:33:01 <OceanSpray> I have a .hs file that can be loaded in ghci fine and has main :: IO () defined, but I can't seem to make it create an executable
11:33:22 <OceanSpray> when I run ghc on the .o file that's produced, I get a bunch of weird linker errors
11:33:41 <geekosaur> @paste program and full error messages
11:33:41 <lambdabot> Haskell pastebin: http://lpaste.net/
11:33:46 <geekosaur> ^ pastebin
11:34:40 <lpaste_> OceanSpray pasted “This thing can't be linked?” at http://lpaste.net/6199680580473323520
11:35:18 <lpaste_> OceanSpray revised “This thing can't be linked?”: “No title” at http://lpaste.net/6199680580473323520
11:36:35 <OceanSpray> the revised paste contains the link errors at the bottom in a comment
11:36:55 <OceanSpray> I get that when I run ghc MessageServer.o
11:37:14 <Intolerable> add the modules to exposed-modules in your .cabal file
11:37:26 <Intolerable> if they're missing from there you'll get link error
11:37:31 <Intolerable> *errors
11:38:44 <OceanSpray> Intolerable: I have no cabal file
11:39:01 <Intolerable> what are you building?
11:39:08 <OceanSpray> just the code in the paste
11:39:20 <OceanSpray> ghc MessageParser.hs
11:39:31 <OceanSpray> it should be self-contained
11:39:47 <Intolerable> just with ghc?
11:40:18 <Intolerable> not sure then, sorry
11:48:07 <albeit> Is there a data structure that holds only unique elements, but has first-in-first-out functionality? If adding something that already exists, nothing is added. If adding something that does not exist, it is added to the "back". 
11:49:04 * hackagebot hasql-postgres 0.10.4.0 - A "PostgreSQL" backend for the "hasql" library  https://hackage.haskell.org/package/hasql-postgres-0.10.4.0 (NikitaVolkov)
11:49:05 <nyazdani> albeit, you could use a set and a list in conjunction
11:49:05 <Welkin> albeit: you can use a map and keep track of the current index
11:49:11 <alanz> Does anyone know anything about the "X-Install-Target" field in a cabal file, as used in https://github.com/DanielG/cabal-helper/blob/master/cabal-helper.cabal#L66? I need that executable available in a stack environment, not sure how to do it
11:49:29 <Welkin> nyazdani's suggestion is good
11:49:36 <nyazdani> thanks Welkin
11:50:03 <Welkin> I would probably use a Set + a Queue though
11:50:09 <Welkin> since a list is FILO
11:50:09 <albeit> I guess I could create it with a combination of Set and Seq...
11:50:27 <albeit> Oh woah sorry my IRC didn't refres. Thanks nyazdani Welkin 
11:50:36 <nyazdani> oo good point there. Seq would work
11:50:44 <nyazdani> yep sure thing
11:53:49 <obadz> data Blah a = Blah { runBlah :: ... a } => what is this syntax and what does it mean? Is it a GADT?
11:54:00 <mniip> obadz, no, that's a record
11:54:17 <obadz> hmmm good point
11:54:23 <obadz> I don't know why I find it confusing
11:54:52 <mniip> 'data X a = A { foo :: a, bar :: () } | B { foo :: a, xyz :: (a -> a) }' is equivalent to
11:54:55 <obadz> I'm just being stupid
11:55:02 <mniip> 'data X a = A a () | B a (a -> a)'
11:55:19 <mniip> with respective function foo, and partial functions bar and xyz defined
11:55:42 <mniip> (foo :: X a -> a, bar :: X a -> (), xyz :: X a -> a -> a)
11:55:54 <obadz> yep I get that
11:57:17 <obadz> bar & xyz are partial in this case?
11:57:28 <obadz> kinda scary
11:59:02 <liste> yeah, people rarely do that
11:59:02 <tdammers> foo isn't partial except for records where you haven't set them
11:59:31 <tdammers> but yeah, bar and xyz are
11:59:54 <obadz> tdammers: except for records where you haven't set what?
11:59:57 <tdammers> I generally do either records or sum types, but not both
12:00:06 <tdammers> where you haven't initialized that field
12:00:31 <tdammers> > data Foo = Foo { bar :: Int, baz :: () }; let foo = Foo { baz :: () }
12:00:32 <lambdabot>  <hint>:1:1: parse error on input ‘data’
12:01:03 <obadz> tdammers: Fields of ‘A’ not initialised: bar
12:01:10 <tdammers> that, yeah
12:01:13 <obadz> tdammers: I think you have to initialize them all
12:01:23 <tdammers> it's a warning, not an error
12:01:31 <obadz> ah fair enough
12:01:33 <obadz> thx
12:01:57 <tdammers> as with all partial functions, they are "safe" until you call them wrong
12:03:04 <obadz> not sure why we have any in prelude
12:03:11 <freezeboy> Lemmih: Hi ! I'm trying to use acid-state and ... I miserabily fail, can you help me ?
12:04:20 <creichert> freezeboy: You should just ask your question, others that use acid-state might be able to help as well
12:04:27 <tdammers> obadz: historical reasons
12:06:04 <bitemyapp> https://wiki.haskell.org/Determining_the_type_of_an_expression#Type_of_subexpressions is kinda depressing. Is there a better way to get the types of sub-expressions like :info does?
12:06:08 <freezeboy> well in fact, my application has a "GameState" type (which is a simple record, and I simply call a function with some bid and the previous state to deduce the next state. So I thought acid would help me to persist it
12:06:52 <freezeboy> So I create an Update GameState GameState to wrap this behavior
12:07:53 <freezeboy> but this doesn't compile, and tells there is a conflct between Update GS GS and GS alone
12:09:06 <liste> freezeboy do you use makeAcidic?
12:10:05 <freezeboy> yes
12:10:15 <freezeboy> I'll paste it 
12:11:08 <lpaste_> freezeboy pasted “No title” at http://lpaste.net/8830624645167185920
12:13:49 <liste> freezeboy you're using `ask' in an Update
12:14:10 <liste> try `get' instead
12:15:15 <freezeboy> well even with get its bad ... I'll edit my paste to join the error
12:18:05 <utdemir> Hey. I had found a repo which was about a primitive alternative to Opa language in Haskell/ghcjs, and it was containing a SocketIO FFI module I wanted to use. But I lost it and couldn't found it now. Does anyone have an idea?
12:19:24 <lpaste_> freezeboy revised “No title”: “No title” at http://lpaste.net/8830624645167185920
12:19:30 <utdemir> Oh, here it is: https://github.com/boothead/oHm/blob/master/src/Ohm/SocketIO.hs
12:22:04 <sinelaw> is there a way to have .cabal  build an executable only if a flag is on
12:23:17 <freezeboy> put if flag(example) buildable: True/False  in the executable section
12:23:43 <sinelaw> thanks
12:24:08 <freezeboy> I think you need the else part also
12:27:21 <freezeboy> Do I need to encapsulate my "data" inside a special "State" ou can I use my raw data ?
12:28:27 <coppro> we use State to create mutable state
12:28:33 <coppro> nothing stops you from using data directly
12:28:38 <mostalive> catgocat: if you want to learn about low level things, maybe get an Arduino to play with? (i've got a sparkfun inventors toolkit which is quite nice, you can also build your own arduino board for the price of a cup of coffee)
12:29:18 <coppro> freezeboy: it sounds like you're not quite understanding something more fundamental
12:29:24 <coppro> what are you trying to do?
12:30:52 <freezeboy> coppro: I have a simple data record representing the scores after some round
12:31:18 <freezeboy> then I have another record with some info from the round to compute the future scores
12:31:47 <freezeboy> so I want to keep the latest scores during the game
12:32:12 <coppro> so you want to update the scores you have?
12:32:12 <liste> freezeboy I suppose nextTrick and applyBid return Tricks?
12:32:37 <freezeboy> nope they return gameState
12:32:54 <coppro> freezeboy: first off, what is Update?
12:33:12 <freezeboy> it's a thing from acid-state
12:33:30 <coppro> hmm, not familiar with it
12:33:33 <liste> freezeboy on line 7, you give a state to nextTrick
12:33:39 <liste> but seems it wants a Trick
12:34:01 <freezeboy> as I understand, it's an operation that creates a new state 
12:34:11 <indiagreen_> does anyone use +~ or *~ from lens often?
12:34:16 <freezeboy> nextTrick is a GameState -> GameState
12:34:27 <coppro> freezeboy: ah ok
12:34:37 <coppro> I think I am starting to get a little bit of an idea of what's going wrong here
12:34:46 <coppro> Why do you have Update GameState GameState as your type?
12:34:49 <freezeboy> I'm all ears
12:35:10 <freezeboy> Because I want to get the new state juste after it has been saved
12:35:28 <freezeboy> without needed to query it juste after
12:35:39 <freezeboy> *needing
12:35:43 <coppro> freezeboy: what you're doing is providing two ways to pass the state around
12:35:50 <coppro> which is at best confusing
12:36:09 <coppro> Update is a state monad, of type Update st a
12:36:34 <liste> freezeboy nextTrick if is GameState -> GameState
12:36:38 <coppro> st is the type of the underlying state, and a is the type of the current thing you're passing around
12:36:41 <arkeet> :t get
12:36:42 <lambdabot> MonadState s m => m s
12:36:48 <liste> it's pure, so newState <- nextTrick state is wrong
12:36:56 <liste> it should be let newState = nextTrick state
12:37:01 <coppro> I'm not sure about the exact use of Update here and whether it has database queries or whatever
12:37:18 <fr33domlover> Q: if I open a 'Socket' (using the network package) and then use socketToHandle to get a handle from it, can 2 threads read and write to the handle concurrently without additional locking etc.?
12:37:26 <coppro> but using the same type for both is probably not ideal
12:37:58 <freezeboy> liste: oh yes thank you
12:38:40 <liste> btw, meet modify :: MonadState s m => (s -> s) -> m ()
12:38:41 <freezeboy> coppro: So I should simply use an Update GameState ()
12:38:59 <freezeboy> and after each update I need to query again
12:39:12 <coppro> freezeboy: that's one approach. If that has side-effects, your approach might be correct
12:39:28 <coppro> are you experienced in imperative code?
12:39:39 <freezeboy> yes ... I'm so used to it
12:39:54 <hodapp> huh, so it seems that if I wanted to, I could make this Cabal build also execute the entire Shake build
12:40:16 <hodapp> but I'm not sure if using 'cabal build' to not only build the Haskell code but also execute it is particularly kosher
12:40:19 <coppro> your code is roughly the equivalent of int foo() { int i = calculateInt(); update(i); return i; }
12:40:27 <coppro> which might be right sometimes but there's obvious duplication involved
12:40:29 <freezeboy> liste: what do you mean ? I want persistence in addition to mutation
12:40:49 <liste> freezeboy the point of acid-state is to get it for free
12:41:02 <coppro> right now, I wouldn't worry about efficiency of multiple queries, probably
12:41:09 <coppro> get your code working, then get it fast
12:41:15 <coppro> this is true even in Haskell :)
12:41:17 <liste> the ask, get, put you have are MonadState's methods
12:41:27 <liste> (and MonadReader's)
12:41:29 <drewbert> grrr, it seems like even the newest hdevtools is not working with my stack projects
12:41:52 <coppro> freezeboy: where are you getting input and output?
12:42:22 <liste> freezeboy your playDeal is the same as playDeal bid = modify applyBid >> get
12:42:25 <coppro> it doesn't seem to me you get a lot of out using state at all here
12:42:28 <freezeboy> at the end of the day, I should put that acid usage in a wai application
12:42:38 <coppro> like, why isn't playDeal :: Trick -> GameState -> GameState ?
12:43:27 <freezeboy> liste: yes but I'm really an imperative guy
12:43:50 <freezeboy> coppro: because I thought the state was queriable from an update
12:43:53 <coppro> freezeboy: one thing that I find helps in haskell
12:44:02 <coppro> freezeboy: it is
12:44:26 <coppro> but the logic of "play this trick given this game state"
12:44:38 <coppro> that doesn't depend on where you get the game state from
12:45:05 <coppro> as I was saying, one thing that I find helps is to separate any place where I'm doing computations off from any place where I'm worrying about where data is coming from and what to do with it
12:47:00 <liste> and acid-state even worries where the data comes from for you
12:47:25 <coppro> freezeboy: am I making any sense?
12:47:55 <freezeboy> yes yes I'm patching my code with your suggestions
12:48:17 <freezeboy> it's better for ghc 
12:48:17 <liste> I usually have a function foo :: MonadState Foo m => Qux -> m Bar along with foo' :: Qux -> Update Foo Bar
12:48:35 <liste> and then foo' is literally "foo' = foo"
12:49:06 * hackagebot th-typegraph 0.28 - Graph of the subtype relation  https://hackage.haskell.org/package/th-typegraph-0.28 (DavidFox)
12:49:08 <lpaste_> freezeboy revised “No title”: “No title” at http://lpaste.net/8830624645167185920
12:49:21 <lpaste_> freezeboy revised “No title”: “No title” at http://lpaste.net/8830624645167185920
12:49:22 <catgocat> What happens when I write `let () k = 3` in the ghci?
12:49:28 <catgocat> It doesn't trigger an error.
12:49:45 <coppro> catgocat: you just defined a function called (), I think?
12:49:55 <coppro> don't do that :P
12:49:55 <liste> freezeboy you can drop the get from playDeal if you return ()
12:50:00 <freezeboy> liste: I'm not sure I understand why foo' is useful
12:50:09 <arkeet> catgocat: gives an error for me.
12:50:14 <liste> freezeboy you can makeAcidic it (:
12:50:18 <arkeet>     Constructor ‘()’ should have no arguments, but has been given 1
12:50:29 <liste> that's the only reason
12:52:16 <catgocat> So when I define let () k = 3 shouldn't that override () ?
12:52:44 <inininin> I've been having trouble installing ghc-mod, hlint and haskell-docs with cabal, ghc version 7.8.3, cabal version 1.18.1.4, cabal-install version 1.18.0.5
12:52:47 <catgocat> Oh I got an error, nevermind.
12:53:00 <liste> catgocat () is a constructor
12:53:08 <catgocat> It's a type too
12:53:15 <liste> just like identifiers that start with a capital
12:53:19 <catgocat> how and where is it defined?
12:53:21 <catgocat> the source.
12:53:29 <catgocat> is it something like data () = () ?
12:53:29 <liste> GHC.Base iirc
12:53:35 <liste> @src ()
12:53:35 <lambdabot> data () = ()
12:54:06 * hackagebot HOpenCV 0.3 - A binding for the OpenCV computer vision library  https://hackage.haskell.org/package/HOpenCV-0.3 (NoamLewis)
12:54:08 * hackagebot HOpenCV 0.3.0.1 - A binding for the OpenCV computer vision library  https://hackage.haskell.org/package/HOpenCV-0.3.0.1 (NoamLewis)
12:54:17 <freezeboy> liste: coppro: Hooray I now have error with safe copy, so the acid stuff is ok thank you
12:54:24 <liste> yw (:
12:56:12 <catgocat> liste: How do I define a data type with an operator? After `:set -XTypeOperators` I tried `data (%) = (%) deriving Show` - no errors. However, when I type %, it throws a parse error.
12:56:14 <inininin> I've been having trouble installing ghc-mod, hlint and haskell-docs with cabal, ghc version 7.8.3, cabal version 1.18.1.4, cabal-install version 1.18.0.5. Here's the lPaste: http://lpaste.net/138124
12:56:35 <Hijiri> catgocat: the constructor has to start with a colon
12:56:43 <Hijiri> -XTypeOperators is for operators in type constructors
12:56:47 <Hijiri> not on the value level
12:56:49 <coppro> freezeboy: in general, you want to do stuff as abstractly as possible in Haskell, because then you can change other parts of your code without affecting it
12:56:55 <catgocat> what is a colon?
12:57:00 <catgocat> sorry I'm foreign
12:57:01 <Hijiri> :
12:57:09 <catgocat> google images shows organs for colon
12:57:25 <liste> catgocat unfortunate coincidence
12:57:26 <Hijiri> @data Foo = Int :-: Foo
12:57:26 <lambdabot> Unknown command, try @list
12:57:29 <Hijiri> @let data Foo = Int :-: Foo
12:57:30 <lambdabot>  Defined.
12:57:49 <catgocat> Oh ok : 
12:58:40 <catgocat> Why does it have to start with a colon?
12:58:44 <liste> the colon is like capital letters for symbols
12:58:46 <catgocat> In functions, other things work.
12:58:56 <Hijiri> to distinguish it from operators that are not constructors
12:59:01 <liste> lowercase identifier = not constructor, uppercase identifier = constructor
12:59:15 <catgocat> That's really weird in ghci, you type : for commands
12:59:22 <catgocat> how does it figure it all out?
13:00:11 <inininin> Anyone had trouble installing ghc-mod?
13:00:20 <catgocat> Why do I have to use the operator type constructor in the middle of the parameters?
13:00:31 <catgocat> data Foo = :-: Int Int deriving Show -- doesn't work
13:00:39 <Hijiri> maybe this works
13:00:48 <arkeet> as with any operator, to use it prefix you hav eto put parentheses
13:00:50 <Hijiri> @let data Bap = (:-:) Int Integer
13:00:50 <lambdabot>  .L.hs:176:12: parse error on input ‘:-:’
13:00:51 <arkeet> (:-:) Int Int
13:00:59 <ely-se> I prefer ;~;
13:01:04 <Hijiri> looks like it doesn't work
13:01:09 <catgocat> Ops, right, it works similar to functions.
13:01:35 <catgocat> Does the bot have -XTypeOperators?
13:01:51 <arkeet> I think so
13:01:52 <catgocat> Prelude> data Foo = (:-:) Int Int deriving; Show
13:01:52 <catgocat> Prelude> 3 :-: 4
13:01:52 <catgocat> (:-:) 3 4
13:02:21 <Hijiri> @let data a - b = Foo a b
13:02:22 <lambdabot>  Parse failed: Illegal data/newtype declaration
13:02:40 <Hijiri> maybe not
13:02:56 <catgocat> data (:-:) a b = (:-:) a b deriving Show
13:03:18 <freezeboy> liste: coppro: And as you seem to know many things, can I put multiple "states" in acid-state ou I must open one "database" for each data ?
13:03:50 <Hijiri> freezeboy: you could combine the different states into one state
13:04:07 <Hijiri> data BigState = BS MyState MyOtherState
13:04:07 * hackagebot cv-combinators 0.1.3 - Functional Combinators for Computer Vision  https://hackage.haskell.org/package/cv-combinators-0.1.3 (NoamLewis)
13:04:18 <Hijiri> if you know what states you need beforehand, at least
13:04:47 <Hijiri> otherwise you could have some collection of states you can add to at runtime
13:04:51 <Hijiri> and make that your big state
13:04:55 <freezeboy> but I need to modify the big state each time one of its element should change
13:05:01 <Hijiri> yes
13:05:09 <eacameron> Is there a type operator for Lens? E.g. Lens a b becomes a ::> b?
13:05:31 <freezeboy> So it's a solution when you store very few data
13:05:40 <Hijiri> freezeboy: it's not that expensive
13:06:14 <Hijiri> you're not changing the other parts of the state so all you pay for (in addition to changing the element you changed) is reconstructing BS
13:06:43 <freezeboy> you're right
13:07:29 <freezeboy> and do you know if I can get the history ?
13:07:46 <freezeboy> as it is the way it is represented on disk
13:08:11 <Hijiri> I don't know, theoretically there must be some way, since acid-state keeps a transaction log
13:08:28 <indiagreen> eacameron: not in the lens library
13:08:46 <eacameron> indiagreen: what's one more operator for Lens??? ;)
13:09:21 <indiagreen> eacameron: lens actually used to have an operator for Iso
13:09:25 <indiagreen> it was :<->
13:09:49 <indiagreen> but it was removed because, IIRC, it was confusing
13:10:23 <edwardk> eacameron: we actively removed them because they were arcane and actively discouraged folks from using the right types for things
13:11:12 <indiagreen> edwardk: hm, how could they do that? I mean, the discouraging part
13:12:00 <edwardk> i mean that folks were using non-family style lenses because the 2-parameter version is all the operator makes pretty
13:12:20 <edwardk> then we had problems that there are a large number of commonish lens types, getters, folks, etc. finding a symbolic vocabulary for that was messy
13:12:42 <edwardk> :-> for Lens, then :=> for traversal is kinda cute, but after that it gets messy fast
13:13:02 <eacameron> edwardk: I can see that. Also a -> b :<-> c makes it much less obvious that "b :<-> c" is a single entity
13:13:04 <edwardk> so we decided to just standardize on the Lens s t a b  convention and offer Lens' s a    as a short hand
13:13:11 <edwardk> and killed the operators
13:14:04 <mniip> edwardk, but the head-context relationship typeclass!
13:15:01 <mniip> how am I gonna use Data.Constraint with Data.Lens :)
13:15:29 <edwardk> mniip: check out my hask project or my current categories branch, both let you use lenses into the category of constraints
13:16:10 <mniip> ಠ_ಠ
13:16:19 <mniip> I was merely talking about the :=> operator
13:28:53 <joncol> I need some help understanding monad transformers: say I have function loadCity :: StateT CityInfo IO (). This function modifies some "global state" (StateT CityInfo) with the stuff loaded from a data file. Now, I have bunch of cities for which I want to load data (and thus affect the StateT CityInfo data). For a single city I can use: runStateT loadData 0 (where 0 is a placeholder for an "empty CityInfo")
13:28:59 <joncol> . But how can I sequence a list of these calls and load data for all my cities? That is, I want to call runStateT once with the empty initial state, and have each call add to the state... Do I make sense?
13:33:18 <johnw> you should just be able to call loadData over and over
13:33:22 <johnw> each call would add to the state
13:33:38 <johnw> don't think about runStateT
13:37:04 <joncol> johnw: I cannot call loadData from main, since main is IO (), and loadData is StateT CityInfo IO ()...?
13:37:14 <joncol> I have to use runStateT, no?
13:37:23 <johnw> yes, once
13:37:23 <mauke> runStateT (do { loadData; loadData; loadData }) 0
13:37:26 <johnw> right
13:37:43 <johnw> each loadData will use the current state and modify it based on whatever it does
13:37:52 <johnw> I would think that loadData would accept the city as a parameter
13:38:25 <joncol> mauke: What if the number of times I want to call loadData is variable?
13:38:51 <johnw> sure, that is possible too
13:38:59 <johnw> replicateM_ n loadData
13:39:49 <joncol> Oh, I had missed replicateM_. Thanks
13:40:03 <mauke> replicateM_ is just a simple helper function
13:40:15 <mauke> I mean, you can always recurse manually
13:40:50 <joncol> Yes, previously I had used sequence_ in combination with replicate.
13:41:26 <mauke> replicateM_ n m | n <= 0 = return ()  | otherwise = m >> replicateM_ (n - 1) m
13:41:42 <johnw> or, sequence_ . replicate n, as you mentioned
13:42:53 <jamesfordummies> can anyone correct my monad-logic here? http://lpaste.net/138130#a138131
13:43:24 <mauke> jamesfordummies: what's the error message?
13:43:32 <jamesfordummies> it’s in the comments
13:43:39 <jamesfordummies> of the annotation
13:43:47 <mauke> :-(
13:43:52 <johnw> that often means you're missing an argument
13:43:55 <mauke> I want to see the error message, not a random part of the error message
13:44:01 <jamesfordummies> ok sorry. sec
13:44:05 <johnw> which is causing do to be in a different monad from the one you think you are
13:44:38 <jamesfordummies> mauke: http://lpaste.net/138134
13:44:50 <mauke> thanks
13:45:15 <bob_twinkles> jamesfordummies: I'm not familiar with those exact APIs, but my guess is that you need to pass a table to "from"
13:45:30 <jamesfordummies> https://hackage.haskell.org/package/esqueleto-2.4.0/docs/Database-Esqueleto-Internal-Sql.html find ‘delete’
13:45:32 <johnw> based on the esqueleto docs, this looks ok
13:45:44 <jamesfordummies> i assume it’s inferring the table from the columns
13:45:45 <johnw> oh
13:45:46 <johnw> haha
13:45:54 <johnw> are you using the wrong delete?
13:46:12 <mauke> yep, was about to ask that
13:46:19 <johnw> that would explain the error exactly
13:46:20 <jamesfordummies> uhhh
13:46:24 <jamesfordummies> how would i know
13:46:33 <mauke> look at your imports
13:46:35 <johnw> try this: Data.Esqueleto.delete
13:46:45 <johnw> ^base
13:46:49 <jamesfordummies> yep
13:46:52 <jamesfordummies> dammit
13:46:58 <jamesfordummies> thank you
13:47:34 <mauke> btw, the complete error message told me that the error was related to the 'delete ...' expression
13:47:35 <jamesfordummies> let me make sure
13:47:42 <mauke> specifically that its type was not what you expected
13:48:15 <mauke> my first guess in such a case is wrong/missing arguments, but in this case it turns out to be the wrong delete function entirely
13:49:03 <jamesfordummies> yep, that did it. thanks mauke and johnw 
13:49:08 * hackagebot multi-cabal 0.1.0.0 - A tool supporting multi cabal project builds.  https://hackage.haskell.org/package/multi-cabal-0.1.0.0 (bash0r)
13:49:11 <johnw> yeah, my thought process is identical to mauke in this regard
13:49:28 <johnw> "incorrect Monad inferred" -> missing arg, wrong arg, wrong function
13:49:50 <jamesfordummies> mentally noted
13:49:59 <johnw> there's nothing like dropping an arg and having GHC think you're building a do-block from the ((->) e) Monad
13:51:57 <mauke> johnw: http://stackoverflow.com/questions/31765154/changing-the-type-of-map-empty-in-haskell :-)
13:52:43 <johnw> heh
13:53:10 <Welkin> lol
13:53:29 <Welkin> when I see people who write haskell without type declaration I know they must be new
13:54:23 <tommd> But... type inference!  ;-)
13:57:05 <Herogx> Welkin, honestly when I first seen it I never seen the point
14:03:15 <monochrom> yesterday I had a case in which writing type declarations did not help
14:04:29 <monochrom> I was using Data.Binary. I wrote: f :: ByteString -> Maybe X.  X is an instance of Binary
14:05:01 <monochrom> f bs = if length bs < 10 then Nothing else decode bs
14:06:06 <monochrom> it failed simple test cases. the cause was forgetting to make it "else Just (decode bs)"
14:06:59 <bennofs> typeclasses for encoding can be tricky. aeson suffers the same problem
14:08:54 <monochrom> you know what? the real story was: g :: Handle -> IO (Maybe X); g h = do { bs <- hGet 10 h; if length bs < 10 then return Nothing else return (decode bs) }
14:09:28 <Herogx> Considering you need to provide a pattern match for both Maybe and Nothing, you then obviously need to do that for all type constructors? 
14:09:34 <monochrom> since it was meant to be in IO by nature, I was wondering whether I should throw exceptions or I should use Nothing-Just
14:10:01 <monochrom> I tried to be a good kid and went with Nothing-Just. and then forgot Just.
14:10:38 <monochrom> it seems to me the moral of the story is that I should have gone with exceptions. then no possibility of forgetting Just, since there would be no Just.
14:10:48 <bennofs> monochrom: writing it as return [ decode bs | length ns >= 10 ] (using MonadComprehensions) would also have avoided this :)
14:13:28 <ttt_fff> after haskell, how does one go back to programming languages where type signatures don't guarnatee purity? i.e. how do you deal with code where, any arbitrary code, can modify any arbitrary data, and everything else is still supposed to work?
14:14:01 <dmj`> ttt_fff: easy, just don't go back
14:14:22 <hpc> ttt_fff: go mad with power, break everything, and eventually learn the other half of disciplined programming
14:14:28 <dmwit> ttt_fff: You are too trusting of Haskell's type signatures.
14:14:28 <monochrom> I don't understand the question. I have just gone back recently. I saw no problem.
14:14:34 <hpc> the compiler maintains order, but you have to as well
14:15:00 <ttt_fff> hpc: what is the other half of disciplined programming?
14:15:12 <monochrom> I missed lambda, but apart from that I saw no problem.
14:15:22 <hpc> ttt_fff: the compiler maintains order, but you have to as well
14:15:25 <bennofs> ttt_fff: apprecriate the simple syntax and ability to write code without thinking much about how to write it beforehand :)
14:15:47 <hpc> haskell's type system is good at doing a lot of low-level thinking for you
14:15:55 <hpc> but you need to keep it in mind yourself as well
14:16:01 <Herogx> I don't see a problem with liking both Haskell and other langs P:
14:16:12 <hpc> ttt_fff: my recommendation is that you use perl for a bit
14:16:14 <Herogx> Haskell is easily my fav language, but Java and some others are still nice
14:16:30 <hpc> ttt_fff: it's extremely different from haskell, but also very close to the same in a lot of major ways
14:16:41 <hpc> it makes a good contrast
14:16:52 <Herogx> Anyone care to answer the question I mentioned earlier?
14:16:58 <bennofs> Herogx: what was it?
14:17:07 <ttt_fff> hpc: does perl6 have a production compiler yet?
14:17:11 <ttt_fff> I heard it was in developemnt for the past 10 years
14:17:23 <Herogx> Pretty much if you have a type constructor and you wish to pattern match or use a case against that, you need to provide a match for each constructor
14:17:24 <hpc> use perl5
14:17:30 <hpc> it's much more gross, and thus much more better ;)
14:17:39 <quchen> I have gone back (professionally) and it's like losing a leg. You can learn to walk on crutches, you can even dance a bit, but it's not the same.
14:17:40 <Herogx> I was reading about the Maybe type and it is leading me to think that, at least
14:17:41 <ttt_fff> Herogx: where is the question ?
14:17:46 <monochrom> is that a question? I don't understand it.
14:17:49 <Herogx> ttt_fff, I just repeated it
14:18:02 <monochrom> I only understand that it is a, you know, position statement.
14:18:13 <ttt_fff> Herogx: I don't see a ? mark. I see a statement about type constructors and pattern matching.
14:18:32 <johnw> you don't pattern match against type constructors, you pattern match against values, and values have types, and those types can be formed using type constructors with another type
14:18:50 <dmwit> For what it's worth, the statement sounds basically right, to a first approximation.
14:19:01 <dmwit> johnw: "constructor" is also the word used for data constructors.
14:19:13 <johnw> he said "type constructor"
14:19:18 <Herogx> My mistake
14:19:27 <Herogx> Haskell has a lot of jargon, I guess
14:19:31 <dmwit> johnw: He also said just "constructor" in all the places where you would want him to say "data constructor".
14:19:37 <bennofs> Herogx: the statement is basically right, and GHC even warns about "non-exhaustive" patterns (=> patterns that miss some cases)
14:19:39 <johnw> I think he meant: if I want to pattern match against Just, do I need to consider Nothing also?
14:20:08 <johnw> dmwit: I saw one use of "constructor" in the sense of data constructor, and that wasn't what I was responding to
14:20:32 <dmwit> K
14:20:39 <Herogx> johnw, Yes, as I say I was reading into Maybe and that lead me to this question, I guess.
14:20:39 <johnw> but point taken
14:20:50 <johnw> Herogx: in general, always match against every constructor
14:20:51 <dmwit> Herogx: I still don't know what the question is.
14:20:58 <johnw> use -Wall, and don't let it complain about incomplete pattern matches
14:21:02 <Herogx> Sorry I'm a bit of a scatterbrain
14:21:15 <tmtwd> I'm getting this bug: http://pastebin.com/uyC3f8Rn
14:21:19 <tmtwd> can anyone help?
14:21:22 <johnw> by matching against every constructor, you clarify the meaning of your function, and what you want the behavior of the function to be
14:21:44 <Herogx> Thank you johnw :)
14:21:53 <johnw> I _think_ I've understood the question :)
14:22:04 <Herogx> Sorry it was a bit backwards
14:22:06 <mauke> tmtwd: what's x?
14:22:10 <dmwit> tmtwd: You will need to show what you did in ghci that caused that error.
14:22:16 <johnw> we are sticklers for terminology here, it is true
14:22:20 <monochrom> @type (**)
14:22:21 <lambdabot> Floating a => a -> a -> a
14:23:05 <tmtwd> ok: http://pastebin.com/vqfcrn7y
14:23:10 <tmtwd> thats the full thing
14:23:40 <dmwit> tmtwd: Well, `x` got defaulted to `ComplexRectangular Integer`.
14:23:59 <dmwit> tmtwd: Give it a type signature to avoid that, e.g. `let x = Rectangular 2 32 :: ComplexRectangular Double`.
14:24:38 <tmtwd> Sweet thanks!
14:24:41 <dmwit> tmtwd: Or skip the binding entirely; `magRec (Rectangular 2 32)` should Just Work.
14:24:50 <shefmichelle> hey guys; i have what is probably a pretty basic question
14:25:13 <shefmichelle> if i have two functions: addUp :: Float -> Float -> Float, and roundNum :: Float -> Int
14:25:39 <shefmichelle> why can't i define addAndRound :: Float -> Float -> Int as addAndRound = roundNum . addUp
14:26:24 <lspitzner> because addUp :: Float -> (Float -> Float)
14:26:32 <johnw> @pl addAndRound x y = roundNum (addUp x y)
14:26:33 <lambdabot> addAndRound = (roundNum .) . addUp
14:26:44 <Herogx> Uh I'm pretty sure that's to do with the function composition operator only accepting one
14:26:47 <Herogx> value
14:26:50 <monochrom> because you're looking at (roundNum :: Float -> Int) . (addUp :: Float -> (Float -> Float))
14:27:04 <shefmichelle> ah, ok, i thought it must be something like that
14:27:16 <liste> @let (.:) = (.).(.) -- some people use this
14:27:17 <lambdabot>  Defined.
14:27:19 <monochrom> which doesn't fit .'s requirement (g :: B -> C) . (f :: A -> B)
14:27:21 <johnw> ". addUp" means something, it means: accept a double and return a function from Float -> Int.  But roundNum doesn't want a function.
14:28:14 <liste> > (negate .: (+)) 3 4
14:28:15 <lambdabot>  -7
14:29:09 <__monty__> Oncemore I'm stumped by a type error. Why does the type variable x not match any arbitrary type? http://lpaste.net/138137
14:30:29 <dmwit> 200 lines of code...
14:30:46 <shefmichelle> great, thanks guys, that makes sense now :)
14:30:46 <monochrom> I think it is again because Some is an existential type, i.e., existentially quantifies "x"
14:30:53 <dmwit> Probably a pretty good exercise would be seeing how tiny of a file you can make that still produces roughly that type error.
14:32:15 <bennofs> is there a function applyMaybe :: (a -> Maybe a) -> a -> a already defined somewhere?
14:32:17 <__monty__> monochrom: So, there is an x but not necessarily the specific one I need?
14:32:50 <bennofs> :t \f -> fromMaybe <*> f
14:32:51 <lambdabot> (b -> Maybe b) -> b -> b
14:32:56 <bennofs> oh cool
14:33:22 <monochrom> the least important aspect of type variables is "they are polymorphic". this is the least important. almost irrelevant. people don't get this.
14:33:51 <monochrom> the most important aspect is: who gets to choose how to instantiate each type variable?
14:34:06 <__monty__> dmwit: I'm relying on quite a bit of the code, a minimal example wouldn't be that much smaller.
14:34:23 <monochrom> every expression in your code has two sides. the provider side and the user side. only one of them gets to choose.
14:34:54 <__monty__> monochrom: And in this case the x is determined by the value in the Some type?
14:34:55 <S11001001> __monty__: I think you are reading line 25 as "forall x. Positionny x"  but it really means "Positionny x *for some* x in scope here".  And there as monochrom says
14:35:43 <S11001001> __monty__: to explain that is what the rigid type variable hullabaloo is about
14:35:53 <mgree> :t maybe
14:35:54 <lambdabot> b -> (a -> b) -> Maybe a -> b
14:36:28 <mgree> bennofs: that's what i would use. but i shy away from all the fancy notation that the cool kids are using these days
14:36:45 <monochrom> my closing remark is: do what dmwit says, understand the basic phenomenon first. scientifically, i.e., small controlled experiment. you need to understand existential types, or at most, GADTs, first. all your DataKinds and type-level nats don't even come into this.
14:36:51 <bennofs> :t ap fromMaybe `asAppliedTo` id
14:36:52 <lambdabot>     Occurs check: cannot construct the infinite type: b ~ Maybe b
14:36:53 <lambdabot>     Expected type: b -> Maybe b
14:36:53 <lambdabot>       Actual type: Maybe b -> Maybe b
14:36:57 <mgree> bennofs: but perhaps i misunderstood what you want (maybe you're looking for fmap?)
14:37:00 <bennofs> :t ap fromMaybe `asAppliedTo` Just
14:37:01 <lambdabot> (b -> Maybe b) -> b -> b
14:37:51 <__monty__> S11001001: I'm not actually thinking of it as forall x, but I probably am trying to solve this in the wrong place.
14:37:54 <bennofs> mgree: I want applyMaybe that applies a function f :: b -> Maybe b to some value v. If f returns Just v', v' should be returned. otherwise, v should be returned
14:38:32 <dmwit> __monty__: I am very skeptical of your claim. I bet, if you tried, you could produce roughly that error in ten lines of code or less.
14:38:56 <monochrom> Here. "data E where E0 :: x -> E". "f :: E -> Bool". "f (E0 b) = b && True".  if you understand this problem, you understand your problem. and conversely.
14:39:10 * hackagebot microlens 0.2.0.0 - A tiny part of the lens library which you can depend upon  https://hackage.haskell.org/package/microlens-0.2.0.0 (Artyom)
14:39:12 * hackagebot microlens-th 0.2.1.0 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.2.1.0 (Artyom)
14:41:37 <__monty__> dmwit: I didn't mean to say you can't produce that error with less code. I meant to say I couldn't because there was so much going on I couldn't see the problem.
14:41:52 <dmwit> __monty__: That's kind of my point.
14:42:35 <S11001001> @ty \f -> fromMaybe <*> f
14:42:36 <lambdabot> (b -> Maybe b) -> b -> b
14:42:42 <S11001001> bennofs: ^
14:42:50 <bennofs> S11001001: yeah, ap fromMaybe also works
14:43:05 <dmwit> S11001001: That was the first thing bennofs tried after asking his question.
14:43:43 <dmwit> :t unfoldr
14:43:44 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
14:44:10 * hackagebot microlens-ghc 0.1.0.1 - Orphan instances of microlens classes for packages coming with GHC (array, bytestring, containers)  https://hackage.haskell.org/package/microlens-ghc-0.1.0.1 (Artyom)
14:44:12 * hackagebot microlens-mtl 0.1.3.1 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.3.1 (Artyom)
14:44:18 <S11001001> dmwit: eh, can't read IRC logs, sorry
14:44:50 <dmwit> :t \f -> last . unfoldr (fmap (join (,)) . f)
14:44:51 <lambdabot> (a -> Maybe a) -> a -> a
14:45:01 <dmwit> bennofs: For a slightly different semantics. ;-)
14:45:53 <ttt_fff> is hacking on ghci easier than hacking on ghc?
14:46:00 <ttt_fff> I really want ghci to give me more info about my program
14:46:19 <ttt_fff> and it's better than hdevtools / ghcmod, because hdevtools/ghcmod fuck up when the prog does not compile ... but ghci gives me info based on last version taht compiled
14:46:32 <monochrom> behold the moving target
14:46:41 <monochrom> first it is comparing ghci with ghc
14:46:43 <bennofs> ttt_fff: try ghci-ng (https://github.com/chrisdone/ghci-ng, since it doesn't require you to build ghc yourself first
14:47:15 <monochrom> then later it shifts to comparing ghci with hdevtools. or ghcmod. or both. or one of them. god knows which.
14:48:01 <ttt_fff> bennofs: https://github.com/chrisdone/ghci-ng looks amazing
14:48:33 <ttt_fff> monochrom: ghci vs ghc was about code complexity; ghcmod-hdevtools was mentioned since they do not work when the *.hs files do not ocmpile, whereas wigh ghci , you can look up info even if *.hs files do not compile since ghci tells you last version
14:48:43 <ttt_fff> monochrom: just for you, I will rewrite my question
14:48:59 <ttt_fff> monochrom: how complicated is the ghci codebase vs the ghc codebase? (I've heard ghc codebase is complicated)
14:49:23 <monochrom> are they two separate code bases?
14:49:29 <ttt_fff> monochrom: I'd prefer to not use ghc-mod or hdevtools, since for ghc-mod / hdevtools, if my current *.hs files do not compile, they can't provide me with typeinfo / other info, which makes them sorta useless, since during dev, most of the time, my *.hs files do not compile
14:49:35 <geekosaur> ttt_fff, ghci is part of the ghc code base
14:49:46 <ttt_fff> monochrom: ghci does not have this weakness, since if ":r" fails, it can give me info based on _last version taht did compile_
14:50:10 <ttt_fff> geekosaur: did not know that; I incorrectly thought ghci = some other tools + ghc linked in as a library
14:50:23 <geekosaur> ghci is also based on the same thing hdevtools and company are, which is the ghc api. it's rather more intimately connected to said api than they are
14:50:53 <geekosaur> the real problem here is that you are comparing simple users of ghc-api with one that is rather heavily intertwined and uses things that are not well documented
14:51:04 <shachaf> ttt_fff: When you're asking people questions, and they're offering to help you free of charge, you don't get to be rude about clarifying your question.
14:51:31 <geekosaur> because it's actually part of the ghc code base, and a significant chunk of ghc-api exists *for* ghci and is nearly incomprehensible outside the context of ghci
14:51:47 <geekosaur> (and not much better *in* that context if you're not well versed in ghc internals)
14:51:49 <ttt_fff> shachaf: monochrom wasn't answering; he/she was claiming that the question was a moving target; I was explaining it was not
14:51:57 <monochrom> I am unable to reproduce "ghci does not have this weakness, since if ":r" fails, it can give me info based on _last version taht did compile_"
14:52:53 <shachaf> ttt_fff: You still don't get to be rude about it.
14:53:31 <geekosaur> oh, also the issue here is that ghci keeps running in the case you are talking about while ghc-mod and friends get re-invoked
14:53:40 <Welkin> shachaf: payment has nothing to do with it...
14:53:44 <geekosaur> you might consider adding some form of caching to one of them
14:54:11 <monochrom> I had a "f.hs" hanging around that's valid and all. "ghci", then ":load f.hs", it was successful. I then deleted one letter to cause a "not in scope" error. ":r". lost everything.
14:54:20 <ttt_fff> monochrom: here's the situation, I have ghci running, at time t = 0, everything compiles, and is loaded up in ghci; now, at time t = 1, I do some editing, and I'm like "oh shit, I need some info" -- at this time, my *.hs files do NOT compile, if I use ghc-mod or hdevtools, they're like "we can't help you since your code base does not compile" -- ghci, on the other hand, is like ":i" ? sure, no problem, I'll give you info based on w
14:54:38 <geekosaur> (with an option --- please not default, most people would I suspect prefer to get failure indication --- to report from the cache if a changed program can't be loaded)
14:54:52 <ttt_fff> monochrom: on top of this, if my *.hs files are in a state does NOT compile, and I do ":r" ... after the ":r", I can still ":i" from the last version that successfully built
14:55:09 <geekosaur> then consider what I just said
14:55:22 <drewbert> How many people on #haskell does it take to answer a question?  Six.  Two to argue about the answer.  Two to argue about the question.  One to argue against arguing about the question. And one jerk to make a joke about the whole situation.
14:55:23 <monochrom> that's what I tried. does not do what you said.
14:55:25 <geekosaur> and think a bit because this is not actually a ghci thing
14:55:36 <geekosaur> this is a *caching* thing
14:55:45 <ttt_fff> so I've looked at the hdevtools code, it's about < 1000 lines, but I think hdevtools is "one run", not a "keep server alive" type of setup ... where odes one store the cache
14:55:54 <geekosaur> in a disk file
14:56:13 <geekosaur> you update the disk file if the sources change (and if that fails, have an ioption to continue using the cache)
14:56:35 <geekosaur> che is faster than reparsing the source
14:56:41 <geekosaur> er
14:56:58 <geekosaur> and you get an additional benefit if the sources have not changed, because reading the cache is faster than reparsing the source
14:57:31 <ttt_fff> monochrom: hmm, weird, which version of ghci / ghc are you using?
14:57:40 <johnw> hdevtools keeps its cache in memory
14:57:40 <monochrom> 7.10.2
14:57:40 <ttt_fff> I'm also running ghci as "cabal repl"
14:57:52 <ttt_fff> I'm on 7.8.3
14:57:54 <monochrom> I use ghci itself
14:58:31 <__monty__> monochrom: I'm still stuck on my previous question. You gave the E0 :: x -> E example. I think what I should learn from this is that there's a mismatch between the type I expect it to be and the type it actually is, which is almost literally what the error message says. However I can't find an obvious problem, I think it would help alot if I knew what the actual type x was. Is there a way to have ghc tell me this type, instead of calling it x
14:58:48 <broma0> is there a infix lens operator for MonadReader's asks?
14:58:49 <monochrom> you know, this behaviour has not changed ever, since the dawn of GHC or even Miranda.
14:58:57 <ttt_fff> geekosaur: this is an interesting idea; to hijack hdevtools to, upon successful check, to store all intermediate data
14:59:19 <edwardk> broma0: what would it be in fix between?
14:59:36 <ttt_fff> monochrom: I think the difference is that I'm _updating_ my *.hs files, not deleing them; perhaps deleting *.hs files clears the cached info
14:59:53 <edwardk> foo <- lens `views` function
15:00:02 <edwardk> would give you something like what you ask
15:00:05 <edwardk> :t views
15:00:06 <lambdabot> (MonadReader s m, Profunctor p) => Optical p (->) (Const r) s s a a -> p a r -> m r
15:00:08 <broma0> edwardk: nothing. fair enough.. i'm just trying to simplify 'x <- asks blah; dosomethingWith x'
15:00:20 <geekosaur> deleted one character in the file, I think, not deleted the file?
15:00:41 <broma0> infix wasnt the right word.. more like "one of those beautifly simply operators"
15:00:52 <ttt_fff> edwardk: I heard you were hacking on a databased written in haskell; is it available public anywhere?
15:00:52 <monochrom> __monty__: existential type says: the provider, not the user, has a say on how to instantiate type variable x. f is a user, not a provider, of "E0 b". f does not get to say "I want x to be Bool".
15:01:09 <geekosaur> but. you're comparing apples and oranges because ghci is probably being used to load one file. cabal repl loads an entire project, and if one file in the project isn't loadable any that are *compiled and linked already* quite likely remain
15:01:31 <monochrom> ttt_fff, I didn't delete. I edited and saved.
15:01:57 <Welkin> is ttt_fff asking about :reload ?
15:02:04 <monochrom> yes
15:02:13 <ttt_fff> monochrom: okay, so you have f.hs, (1) everything compiles, (2) you do :r, (3) you edit f.hs, it no longer compiles, (4) you do :r, (5) you do :i -- and now you can no longer look up about datatypes defined in f.hs ?
15:02:20 <ttt_fff> Welkin: yes
15:02:36 <__monty__> monochrom: Yes, that I understand. However, my x in this case is a singleton type so I 'know' what type it should be except apparently I don't know what type it should be...
15:02:37 <ttt_fff> monochrom: is that the behaviour you are running into?
15:04:56 <monochrom> that is right. I have main. :info main fails
15:06:03 <monochrom> __monty__: what is "singleton type"? can you modify my example to use a "singleton type"?
15:06:31 <Herogx> If I use let within a list comprehension, that is scoped to within that list comprehension, yes?
15:06:39 <shachaf> Yes.
15:07:46 <ttt_fff> monochrom: okay, my use case is a bit different, I have (1) data.hs f.hs (2) data.hs has all my data decls, (3) at t=0, everything compiles, in ghci (4) then I edit f.hs (5) then I hit :r, things in f.hs is broken, and (6) I can still :I stuff in data.hs
15:07:51 <Cale> monochrom: If K is some kind (usually via DataKinds), then a singleton type for K is a type constructor S of kind K -> * for which there is a single value of type S t for any given t :: K
15:08:12 <ttt_fff> monochrom: I think the differnece in our use case is that because I seprate out a data.hs, the module _taht is broken_ is not the one that contains the data decls I want to lookup
15:08:36 <__monty__> monochrom: ^ I was trying to explain it but Cale's explanation is probably better.
15:08:51 <geekosaur> [06 22:00] <geekosaur> but. you're comparing apples and oranges because ghci is probably being used to load one file. cabal repl loads an entire project, and if one file in the project isn't loadable any that are *compiled and linked already* quite likely remain
15:09:08 <geekosaur> :)
15:09:59 <Welkin> you are comparing Red Delicious to Gala!
15:10:03 <__monty__> monochrom: My code on github has a few singleton types if that would clarify it: Natty n, Matty m, Clearry cl, Positionny p
15:10:55 <monochrom> can you modify my example to use a singleton type?
15:10:57 <Cale> monochrom: The idea is to give a value level representation to be able to reflect on type level structures, since types all get erased in Haskell.
15:11:17 <ttt_fff> geekosaur: okay, I now have you labeled as the "ghci-cabal-repl-edge-case-expert" :-)
15:11:24 <ttt_fff> geekosaur: but your explaination does make sense
15:11:27 <Cale> I missed the start of the discussion though, I'll have to go back to find out what you're talking about :)
15:11:39 <Cale> (I just saw the question about what singleton types are)
15:12:27 <Cale> hmm
15:12:43 <geekosaur> I'm not really the expert but I grok a bit more about it than many. :) I still think the caching thing is a better approach than trying to start from ghci, because trying to figure that out dumps you straight into ghc internals that are hard to sort out
15:14:20 <Cale> __monty__: I don't know if someone answered your question above about why x doesn't match an arbitrary type, but the reason is that x is not an arbitrary type, it's a specific, but unknown type.
15:16:22 <__monty__> Cale: I understand that by now. My problem is that x is apparently not the type I expect it to be and I'm having trouble finding out why because I don't know what type x actually is.
15:17:11 <monochrom> well, you know, but f cannot know. you are not f.
15:18:10 <__monty__> monochrom: I think this is a 'translation' of your example to one with singleton types: http://lpaste.net/138138 (Wrote this in lpaste so haven't typechecked...)
15:18:31 <monochrom> who is Natty?
15:18:41 <__monty__> monochrom: I'll add the definitions.
15:18:54 <monochrom> do I absolutely need both Natty and Nat?
15:19:07 <Cale> __monty__: Is there any reason why you're putting yourself through the pain of trying to program this way in Haskell rather than using e.g. Idris or some other dependently typed language?
15:19:56 <Cale> If you get to the point of needing singleton types to do anything, you're already swimming against the current of what's really reasonable to do in Haskell. I mean, it's fair enough if you just want to see if it's possible :)
15:20:16 <__monty__> Cale: Yes I'm looking into how far you can get Haskell to go.
15:21:00 <__monty__> monochrom: I've updated the paste. Do you mean is Nat required for a minimal example or is Nat necessary if you have Natty?
15:21:28 <monochrom> I don't know. I just mean: is it possible to add just one type, not two?
15:21:51 <__monty__> monochrom: In this case it isn't Natty is indexed by Nat.
15:27:53 <Rembane> Is there a nice general way to handle cominbing two Maybe values in this way? http://lpaste.net/138140
15:28:39 <mniip> Rembane, liftA2/liftM2
15:28:48 <mniip> :t liftA2
15:28:49 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:29:07 <mniip> oh wait I didn't read well enough
15:29:07 <maerwald> > (\x y -> x + y) <$> (Just 3) <*> (Just 5)
15:29:09 <lambdabot>  Just 8
15:29:14 <maerwald> mh
15:29:16 <mniip> nor did maerwald
15:29:54 <maerwald> why not, looks like >*> is (a -> b -> c)
15:30:10 <mniip> Rembane, hmm, that looks like `mappend` for Maybe
15:30:41 <mniip> maerwald, no it's actually like reifying a monoid instance, while mappending two maybe values
15:30:56 <mniip> see line 3 and 4, carefully
15:31:37 <dramforever> Rembane: can you tell us more about >*>?
15:31:49 <Rembane> mniip: Then I need to build myself a Monoid instance for the datatypes I want this functionality for, right?
15:31:54 <mniip> liftA2 op x y <|> x <|> y
15:32:03 <geekosaur> dramforever, I think that;s missing the point
15:32:07 <dramforever> Rembane: it depends. tell us more about (>*>)
15:32:18 <mniip> I wonder if I can pointfreely fold this somehow
15:32:34 <geekosaur> they want something like a monoid for Maybe over another monoid
15:32:34 <dramforever> geekosaur: "then I need to build myself a Monoid instance"
15:32:44 <Rembane> dramforever: It sequences two Program data types. Think like (++) for lists but for a richer datatype.
15:32:50 <geekosaur> the point is to be *general*, for any >*>
15:33:02 <dramforever> okay that looks like a good candidate for a Monoid instance
15:33:27 <dramforever> Rembane: if you write a monoid instance for your program type you could use the monoid instance of maybe
15:33:46 <Rembane> dramforever: That seems really nice. I'll give it a go!
15:33:48 <dramforever> but make sure it's a monoid
15:34:17 <mniip> > (mappend (Just "foo") (Just "bar"), mappend (Just "foo") Nothing)
15:34:19 <lambdabot>  (Just "foobar",Just "foo")
15:34:33 <Rembane> dramforever: Bah, it isn't a monoid. It doesn't have a mempty. Maybe I should fix that.
15:34:44 <mniip> hmm
15:35:00 <mniip> from a theoretical standpoint it can be a category too
15:35:12 <mniip> in practice, though, the monoid instance requires monoid
15:35:23 <Rembane> If I built a Nil-constructor for it, a lot of problems would go away, and code would get more terse and just nicer.
15:35:48 <dramforever> Rembane: well that's also common
15:35:51 <mniip> wait no, category needs an identoty element too
15:36:08 <dramforever> Rembane: ask yourself: is the empty program a valid program?
15:36:20 <__monty__> monochrom, Cale: Thanks for the help. I haven't been able to figure it out yet but maybe I'm just too tired. I'll look at it tomorrow and maybe come back with more questions. Good day or good night whatever's applicable.
15:36:39 <mniip> another question worth asking is whether x <> Nil = x = Nil <> x
15:36:44 <Rembane> dramforever: That's a quite philosophical question. 
15:37:01 <Rembane> mniip: Yes, most definitely!
15:37:07 <shachaf> > run $ plus minus lopp (minus plus lopp () plus) minus minus
15:37:09 <lambdabot>  "+-[-+[]+]--"
15:37:12 <shachaf> This is great.
15:37:25 <shachaf> The empty program is the only one it can't represent.
15:37:40 <mniip> shachaf, mfw
15:37:43 <Rembane> shachaf: BF?
15:37:51 <mniip> :t plus
15:37:52 <lambdabot> B f a => f a
15:37:57 <mniip> as expected
15:38:25 <dramforever> hey why?
15:38:33 <dramforever> what's going on?
15:38:45 <mniip> oooh
15:38:46 <dramforever> :t run
15:38:47 <lambdabot> X BF BF -> BF
15:39:01 <mniip> f ~ (e ->) and f ~ [a]
15:39:04 <mniip> fancy
15:39:28 <mniip> hold on I'll replicate
15:39:29 <dramforever> @bf +-[-+[]+]--
15:39:29 <lambdabot>  Done.
15:39:38 <shachaf> I didn't write the version that supports loops, by the way.
15:40:27 <dramforever> shachaf: oh =)
15:41:37 <Rembane> Thank you all for help and input! This was good food for thought!
15:42:48 <dramforever> haskell is good food for thought
15:44:12 * hackagebot haste-compiler 0.5.0.1 - Haskell To ECMAScript compiler  https://hackage.haskell.org/package/haste-compiler-0.5.0.1 (AntonEkblad)
15:51:03 <edwardk> ttt_fff: its not exactly a usual database
15:51:37 <edwardk> https://yow.eventer.com/yow-2014-1222/functionally-oblivious-and-succinct-by-edward-kmett-1701 talks about cache oblivious b-trees in haskell
15:51:59 <edwardk> https://www.youtube.com/watch?v=uA0Z7_4J7u8 talks about succinct data structures, which form the core of how i think about aggregation
15:56:44 <hasket> For a web API servant vs spock?
15:56:55 <hasket> servant seems to use many advanced type level things that still confuse me
15:57:14 <Welkin> either is fine
15:57:25 <Welkin> use what works for you
15:58:10 <hasket> Kk, Well I started with servant, but the type families and random advanced haskell type system features confused me
15:58:24 <hasket> I was wondering if spock was easier to grok
15:58:52 <alpounet> hasket: hopefully the tutorial and the folks on #servant can clear any confusion. and http://www.arow.info/blog/posts/2015-07-10-servant-intro.html explains how the type-level things are used, i liked the explanations a lot. OTOH spock is probably more accessible, but as far as i know, doesn't let you get client functions or docs or mock servers "for free"
15:59:03 <alpounet> disclaimer: i'm one of the authors of servant.
16:00:06 <alpounet> depending on your needs, both could work.
16:00:16 <hasket> alpounet: Okay I'll try again with servant
16:00:20 <hasket> I'm making a rest api
16:00:32 <hasket> So servant was kind of made for that as I understand
16:01:49 <alpounet> hasket: it was made precisely for that yeah
16:02:28 <alpounet> we needed to write a bunch of webservices and interface with them from other projects, we wanted to kill all the boilerplate that we could
16:03:06 <obadz> EitherT, ErrorT, ExceptT... => drowning over here!
16:04:06 <alpounet> and even if it looks scary, the goal is really to make writing webservices concise, type-safe, and to be able to use information about your API for "great good"
16:04:43 <dramforever> alpounet: actually I think servant could make APIs composable
16:04:59 <dramforever> like just put together two APIs and things automagically work
16:05:05 <alpounet> it does in a very precise sense, yes
16:05:46 <alpounet> i should write about that one of these days, so far it's mostly been mentionned on IRC, reddit etc, but nowhere in the docs
16:06:02 <dramforever> [I'm so clever]
16:07:48 <Cale> obadz: They're all pretty much the same thing
16:08:02 <dramforever> IMHO s/pretty much//
16:08:28 <hasket> alpounet: awesome thank you. I will try again
16:08:50 <obadz> Cale: ... which makes it hard to tell what the difference is between them :)
16:09:13 * hackagebot mtl-unleashed 0.3 - MTL classes without the functional dependency  https://hackage.haskell.org/package/mtl-unleashed-0.3 (DavidFox)
16:09:16 <bob_twinkles> if I do something like "forM [1 .. 10] (\x -> Data.Binary.Get.skip (x * 256))", would I be able to store that list in some data structure and then have the Gets in there operate correctly in some arbitrary order of forced evaluation?
16:09:51 <bob_twinkles> basically I want to "save" a bunch of points in a binary stream that I can jump back to and read later
16:10:21 <johnw> but you need to do the processing to know how to move forward in the stream, don't you?
16:11:06 <bob_twinkles> The data basically consists of a header with a bunch of pointers to chunks further in the file
16:11:27 <bob_twinkles> so I have to read and parse the whole header, but I don't want to necissairly decode chunks that I don't care about
16:11:41 <Welkin> alpounet: is your company based in japan?
16:12:03 <johnw> you could certainly capture actions to do the latter parsing, but it would mean maintaining the resource (either keeping the file open, or reopening it as needed), and seeking into the file, and it would need to be guarded for thread safety
16:12:18 <dramforever> I wonder if it's actually worth it
16:12:32 <Cale> obadz: The difference is that they come from different packages
16:12:39 <Cale> obadz: and are named differently
16:12:50 <bob_twinkles> so just Data.Binary.Get probably won't just cut it then =(
16:12:52 <bob_twinkles> darn
16:12:57 <alpounet> Welkin: nope, why?
16:13:16 <Welkin> arrow.info is a japanese company
16:13:19 <Welkin> it looks like
16:13:36 <dramforever> bob_twinkles: do you know how long the header is?
16:13:38 <Welkin> arow*
16:13:39 <dramforever> is it a constant?
16:13:45 <bob_twinkles> yep, the header size is constant
16:13:56 <dramforever> then what about a bytestring split?
16:14:19 <dramforever> then parse that small string
16:15:06 <dramforever> oh not really...
16:15:13 <bob_twinkles> I can parse the header, I'm just not quite sure how I can be lazy about parsing the data chunks
16:16:04 <alpounet> Welkin: oh yeah, but this blog doesn't belong to one of the servant devs. just someone who apparently got interested in the way we use type-level things in servant and wanted to break it down for less experienced haskellers 
16:16:27 <alpounet> that person indeed lives and works in Japan
16:16:28 <hexagoxel> @pl \b -> (\c -> ((Control.Monad.>>=) c) (\g -> Control.Applicative.pure (b g)))
16:16:28 <lambdabot> flip (Control.Monad. >>=) . (Control.Applicative.pure .)
16:16:34 <hexagoxel> :t flip (Control.Monad. >>=) . (Control.Applicative.pure .)
16:16:35 <lambdabot> parse error on input ‘>>=’
16:16:42 <Welkin> it looks like that company is hiring a haskell developer too
16:16:53 <Welkin> in japan
16:16:56 <hexagoxel> lambdabot bug tracker?
16:17:23 <hexagoxel> ah, github
16:17:31 <alpounet> Welkin: I don't know much about the company or the person, except for the few emails we exchanged about that article, after he asked for some feedback before publishing it
16:20:30 <obadz> Cale: I see
16:20:31 <obadz> Cale: thx
16:20:34 <catgocat> https://github.com/afonsomatos/haskell
16:20:45 <mniip> shachaf, mine ended up more lisp-like
16:20:55 <catgocat> (it's still very imcomplete, I'll be adding things as I learn haskell)
16:21:13 <lpaste_> mniip pasted “brainfuck DSL” at http://lpaste.net/138141
16:22:00 <mniip> plus minus plus (loop left minus right) loop
16:22:28 <mniip> with a 'run $' in front of that
16:22:34 * dramforever is watching "Functionally Oblivious and succinct"
16:23:28 * dramforever feels...funny
16:23:34 <lpaste_> mniip revised “brainfuck DSL”: “No title” at http://lpaste.net/138141
16:25:49 <drewbert> If I have a data type with multiple constructors, can Aeson derive wrappers for each of the constructors when I say $(deriveJSON ''type) ?
16:26:27 <mniip> > run $ plus minus (loop_ left_ minus right_) input loop_
16:26:29 <lambdabot>  "+-[<->],[]"
16:26:40 <mniip> awesome
16:30:33 <obadz> Cale et al: still failing to understand why ExceptT is needed here: https://github.com/grayjay/json-rpc-server/blob/master/src/Network/JsonRpc/Types.hs#L66
16:31:16 <kadoban> catgocat: Just FYI, that Beginning Haskell book, I suspect isn't actually free or licensed for distribution like that.
16:35:38 <catgocat> kadoban: do you think I should delete it from there?
16:38:04 <kadoban> catgocat: I would.
16:38:10 <catgocat> ok
16:53:34 <FofG> Using stack in a yesod project and having some issues suddenly. It all worked a bit ago, but now `stack build` just exits with 0 without doing anything. No executable is created or anything.
16:54:30 <hexagoxel> obadz: well `type RpcResult m r = ExceptT RpcError m r`. i cannot tell you why they chose ExceptT there (but is that your question?)
16:58:16 <icicled> its there an equivalent to the itsdangerous library in haskell?
16:58:27 <kadoban> FofG: -v ?
16:58:58 <FofG> Version 0.1.2.0, Git revision 65246552936b7da4b64b38372feac903d96a8911
16:59:26 <kadoban> FofG: v for verbose. It doesn't say /anything/ else?
16:59:32 <FofG> oh sorry lol
16:59:45 <kadoban> Hehe, no worries
17:01:15 <FofG> https://gist.github.com/levinotik/2aef19fbc3a1798220a1
17:03:08 <kadoban> FofG: AFAI can tell, that's the output I get when nothing is changed so it doesn't need to actually build. Are you sure you're in the directory you think you are, so the files are actually changed? Are the modules you're changing listed in the .cabal in the right place(s)?
17:03:54 <FofG> ya everything looks good
17:04:00 <FofG> this all worked earlier just fine
17:04:11 <FofG> stack exec my-executable also just does nothing
17:05:14 <FofG> 2015-08-07 00:04:42.885701: [debug] Run process: /Users/levinotik/grasswire/api/.stack-work/install/x86_64-osx/nightly-2015-08-06/7.10.2/bin/api  @(stack-0.1.2.0:Stack.Exec src/Stack/Exec.hs:52:5)
17:05:16 <FofG> and then nothing
17:05:36 <kadoban> FofG: Can you post the .cabal? And what files have you changed that should require a rebuild?
17:05:51 <FofG> the issue isn't a rebuild
17:05:55 <FofG> i havent changed anything
17:05:59 <FofG> deleted the executable though
17:06:04 <FofG> and still build does nothing
17:06:53 <FofG> but i just changed something now too
17:06:58 <kadoban> Oh. I have no idea how stack handles that, heh. You deleted from the .stack-work/blahblah whatever directory you mean?
17:06:58 <FofG> stack build still doing nothing
17:07:06 <FofG> ya i did
17:08:52 <kadoban> FofG: Try 'stack clean' first? That seems to make it rebuild the executable when I then build. If not, maybe still check the .cabal and such
17:08:59 <FofG> treid that
17:09:34 <FofG> super weird, this time stack clean seemed to do the trick!
17:09:43 <kadoban> Hehe, fun
17:10:00 <FofG> hmm
17:10:03 <FofG> at least for stack build
17:10:07 <FofG> stack exec still no dice
17:10:07 <dramforever> FofG: that's basically what programming is, isn't it </sarcasm>
17:10:48 <kadoban> FofG: stack exec … AFAIK it doesn't do something special to go out of its way to execute the version you just built
17:10:55 <FofG> stack build did produce an executable
17:11:06 <FofG> but even that executable just does nothing seemingly...
17:11:16 <kadoban> FofG: I think it just runs things in the context with GHC_whatever environment variables set and such pointing at the package database it's using.
17:11:42 <mgsloan> kadoban: It does, the PATH variable gets modified to include the "local install root", which is where executables go after stack build
17:11:46 <FofG> i dunno, stack exec myapp seemed to do the same thing as ./.stack-work/bla/bla
17:12:13 <kadoban> mgsloan: Oh.
17:12:49 <mgsloan> (stack install, on the other hand, installs the exe to ~/.local/bin/, so that it'll be available all the time (if that's on your PATH))
17:12:54 <FofG> gonna try just blasting the entire .stack-work dir
17:13:16 <kadoban> Hmm, you're right, it does add that to the $PATH. Interesting.
17:13:20 <mgsloan> kadoban: But yes, unless --no-ghc-package-path is passed, stack exec also sets GHC_PACKAGE_PATH
17:13:40 <FofG> rm -rf .stack-work didnt help
17:13:42 <FofG> im lost
17:13:50 <mgsloan> stack exec will also do the execution in a docker container, if you have one of those configured
17:14:15 * hackagebot json-rpc 0.5.0.0 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.5.0.0 (XenoGenesis)
17:14:16 <mgsloan> FofG: stack clean?  There are also .stack-work directories in the different package directories
17:14:22 <FofG> i have docker containers running
17:14:31 <FofG> but not that stack should know about AFAIK..
17:14:47 <kadoban> I really should look up what docker is for sometime.
17:15:07 <Clint> nah
17:15:11 <eacameron> Is c2hs still the primary tool for C/Haskell bindings? I'm out of the loop on this
17:15:17 <mgsloan> FofG Oh yeah, it's only if you have a "docker" section inf your stack.yaml
17:15:19 <drewbert> can I turn on -ddump-splices for a specific file?
17:16:01 <hackrilege> hi, im learning about lenses, can someone talk with me about the lens function i have defined here; http://lpaste.net/138156
17:16:04 <geekosaur> last I heard, the most commonly used tool was still hsc2hs
17:16:26 <geekosaur> c2hs has its uses but IIRC makes some assumptions that are not always valid
17:16:27 <bob_twinkles> drewbert: you can use {-# OPTIONS-_GHC -ddump-splices #-}
17:16:44 <bob_twinkles> err, OPTIONS_GHC, not OPTIONS-_GHC =P{
17:16:49 <drewbert> bob_twinkles: thanks
17:17:49 <dramforever> hackrilege: which function?
17:17:53 <hackrilege> lens
17:18:22 <dramforever> do you know it's functionality?
17:18:33 <FofG> welp. back to scala i guess. sigh
17:18:46 <hackrilege> @let lens getter setter = (\a -> Store (setter a) (getter a))
17:18:47 <lambdabot>  .L.hs:178:30: Not in scope: data constructor ‘Store’
17:19:03 <dramforever> hackrilege: it's supposed to construct a lens from a setter and a getter
17:19:16 * hackagebot formattable 0.1.1 - Business-quality formatting of numbers, dates, and other things  https://hackage.haskell.org/package/formattable-0.1.1 (DougBeardsley)
17:19:22 <hackrilege> how does it compare with other definitions of lens?
17:19:33 <dramforever> other?
17:19:36 <shachaf> Note that using a function like "lens" means you can't get sharing.
17:19:54 <shachaf> So it's generally going to be less efficient than writing your lens directly, with a typical efficient representation of lenses.
17:20:33 <dramforever> hackrilege: what do you mean by "other"? like the Functor f => (a -> f b) -> (s -> f t) one?
17:20:49 <dmwit> ?unmtl NonDet a
17:20:50 <lambdabot> forall b. ((a -> b -> b) -> b -> b)
17:20:52 <dmwit> ?unmtl NonDet b
17:20:53 <lambdabot> forall b. ((b -> b -> b) -> b -> b)
17:20:55 <dmwit> =(
17:21:09 <dramforever> ha
17:21:16 <hackrilege> shachaf what do you mean cant get sharing?
17:22:00 <hackrilege> dramforever yes, im not really sure how a lens is normally defined, this was my go at reproducing it
17:22:28 <dramforever> hackrilege: that was really good, but there's a problem and a non-problem
17:22:38 <dramforever> the problem is that it doesn't allow us to change types
17:22:58 <dramforever> like we can't set inside Just 3 to get a Just "3" back
17:23:00 <hackrilege> aha, thats what shachaf was saying?
17:23:04 <dramforever> dunno
17:23:20 <dramforever> the non-problem is that this pattern doesn't generalize to prisms, traversals...
17:23:40 <shachaf> That's not what shachaf was saying.
17:24:00 <shachaf> The problem is that the getter has to go looking all the way inside the structure to find the thing it's getting.
17:24:04 <hackrilege> because its not an instance of traversable in that there is no applicative instance
17:24:05 <hackrilege> ?
17:24:06 <shachaf> And then the setter has to do the same thing.
17:24:19 <shachaf> There's a lot of confusion going on here.
17:24:23 <dramforever> hackrilege: IMHO you don't have to deal with the non-problem
17:25:22 <hackrilege> id like to provide instances to the usual classes to disclose and utilise this functionality
17:25:39 <dramforever> which functionality?
17:25:43 <hackrilege> i have never even heard of a prism...
17:26:36 <hackrilege> functions defined to work on subclasses of say traversable
17:26:49 <hackrilege> say == e.g.
17:26:53 <dramforever> not really
17:27:13 <dramforever> I guess you don't really have to worry about that now..
17:27:14 <hackrilege> no?
17:27:56 <hackrilege> the idea is to understand the usual superclasses to lens
17:28:15 * dramforever didn't understand that
17:28:46 <mgsloan> FofG: I hope you aren't giving up!  Keep in mind that stack is only a few months old.  It's pretty awesome, and makes dev lots nicer, but things are still work-in-progress and moving fast
17:29:13 <mgsloan> "stack build" does indeed have 0 output when it determines that there is nothing to do
17:29:33 <mgsloan> might be worth having it say "There's nothing to do", just to reassure the user that it is indeed functioning
17:29:41 <hackrilege> type Lens a b = a -> Store b a where store is a functor and a comonad
17:30:03 <FofG> mgsloan: thanks. i guess i'll have to switch back to cabal for now
17:30:09 <dramforever> I'm afraid that store cannot be generalized
17:30:11 <hackrilege> im refering to these as superclasses (functor and comonad)
17:30:23 <mgsloan> FofG: If you can come up with a list of steps to reproduce the issue you are encountering, we'd really appreciate it (https://github.com/commercialhaskell/stack/issues)
17:30:36 <dramforever> yes I'm afraid that comonads aren't going to do it
17:30:39 <dramforever> but I don't know
17:30:46 <hackrilege> how do you mean cant be generalised? is that what im doing here?
17:30:49 <FofG> mgsloan: I'll do my best. Thanks
17:31:04 <dramforever> hackrilege: I mean something like lens -> traversal
17:31:10 <hackrilege> hmm, sounds like my attempt has fallen far short...
17:31:11 <FofG> official yesod quick start guide recommends stack though..
17:31:13 <FofG> so there's that
17:31:21 <dramforever> hackrilege: but it was good attempt!
17:31:25 <dramforever> impressive
17:31:38 <mgsloan> FofG: In general, as evidenced by the 533 closed issues and 80 open, we're very keen to have stack solve people's problems well
17:32:11 <dramforever> I once figured out a lens representation that doesn't require the Prelude
17:32:13 <FofG> mgsloan: Ya, I'm aware. In general I've been pleasantly surprised by how reliable stack is this early on. I'm just running into a strange, strange issue
17:32:20 <FofG> and my computer has ghosts in it apparently
17:32:27 <hackrilege> so the bits i got right, the access methods of comonad and the manipulation of functor, and your saying it needs to be traversable, what else?
17:32:29 <dramforever> and they compose with Prelude.(.)
17:32:39 <dramforever> hackrilege: no you misunderstood me
17:32:49 <dramforever> you don't have to worry about that for now
17:32:51 <hackrilege> darn
17:33:08 <dramforever> traversals and traversable are different things
17:33:34 <hackrilege> i would like to be able to use this code to transform a tree to a list, can it do that?
17:33:51 <dramforever> what do you mean by "this"?
17:34:16 <hackrilege> by this i mean the code in this paste http://lpaste.net/138156
17:34:36 <dramforever> no I'm afraid no
17:34:53 <dramforever> but that's not what lens is supposed to do
17:36:16 <hackrilege> i can change the types held within the data type, so i can traverse a tree, and collect and return the values in a different type, say a haskell list
17:36:46 <hackrilege> if i had an instance of traversable
17:36:53 <dramforever> yes you can
17:36:58 <dramforever> but no lenses here
17:37:18 <hackrilege> type Lens a b = a -> Store b a is not ok?
17:37:38 <edwardk> hackrilege: its a bit more tedious to compose
17:38:02 <dramforever> edwardk: that's a non-problem for now
17:38:12 <hackrilege> edwardk: than; Functor f => (a -> f b) -> (s -> f t) ?
17:38:19 <edwardk> the van laarhoven style also has the benefit of being much nicer to the inliner in terms of what it can optimize into
17:38:37 <edwardk> hackrilege: Functor f => (a -> f b) -> s -> f t   composes with (.)   since its a function from (a -> f b)    to (s -> f t)
17:38:50 <edwardk> you have to write a rather complicated combinator to do the store comonad coalgebra lens
17:39:00 <edwardk> and then you get stuck, things like prisms don't have such an analogue
17:39:15 <dramforever> edwardk: thanks that's what I was thinking
17:39:18 <dramforever> but I wasn't sure
17:39:36 <dramforever> now you confirmed it
17:39:36 <edwardk> its a coincidence that (s -> a -> s) and (s -> a)   share an 's' at the start.
17:39:42 <edwardk> when you build a prism you don't get that
17:40:02 <edwardk> :t prism
17:40:03 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
17:40:11 <dramforever> :t Market
17:40:12 <lambdabot> Not in scope: data constructor ‘Market’
17:40:14 <edwardk> (b -> t) and (s -> Either t a)   -- don't share anything at the start
17:40:26 <edwardk> there isn't anything you can do to fuse them into one function
17:40:40 <edwardk> the happy coincidence that made the store comonad coalgebra doesn't work anywhere else
17:40:41 <max3> can someone explain to me how the first branch of the case/of here in Expression works
17:40:43 <max3> https://www.fpcomplete.com/school/starting-with-haskell/basics-of-haskell/8_Parser
17:40:47 <hackrilege> Choice!?
17:40:56 <max3> i don't understand this:  (TokOp op) | elem op [Plus, Minus] -> 
17:41:03 <edwardk> choice/strong are pretty much about generalizing over this sort of thing
17:41:13 <edwardk> they are really two instances of the same abstraction
17:41:30 <max3> does that mean both cases  (TokOp op)  and elem op [Plus, Minus] should lead to the same thing
17:41:57 <dramforever> edwardk: interestingly, one day I was thinking "hey why don't you guys just make lensy stuff like f a b -> f s t and pick different f's for different lens-like stuff"
17:42:04 <edwardk> second' :: p a b -> p (c, a) (c, b);       right' :: p a b -> p (Either c a) (Either c b)  aren't "dual"
17:42:10 <dramforever> and "oh we already do that..."
17:42:22 <edwardk> dramforever: that is precisely the pure profunctor formulation
17:42:29 <edwardk> it has some limitations
17:42:30 <dramforever> =)
17:42:36 <edwardk> it doesn't work as nicely with third party libraries
17:42:48 <edwardk> it also doesn't give a way to make indexed traversals that do what we do in lens today
17:42:57 <edwardk> traversals are harder that way
17:43:09 <edwardk> but it generalizes over spaces we don't support right now
17:43:13 <edwardk> lenses over other categories
17:43:23 <edwardk> e.g. lenses in the category of Constraints in haskell
17:43:27 <edwardk> or lenses in * -> *
17:43:35 <edwardk> or lenses in the category of monad transformers
17:43:46 <edwardk> which let us run simple monadic actions in larger monadic contexts
17:43:54 <hackrilege> that sounds like it would be a good one to support..
17:43:59 <edwardk> all of those work with the fancier form of lenses
17:44:05 <FofG> wow managed to get the same results. blasted my project, started from scratch with stack and now same behavior. stack build and stack exec doing nothing. i must be writing some strange, strange code
17:44:13 * dramforever checks indexed traversals
17:44:50 <edwardk> > M.fromList [(1,"hello"),(200,"whatever")]^@..itraversed
17:44:52 <lambdabot>  [(1,"hello"),(200,"whatever")]
17:45:00 <edwardk> > M.fromList [(1,"hello"),(200,"whatever")] ^@..traversed
17:45:01 <lambdabot>  [(0,"hello"),(1,"whatever")]
17:45:12 <edwardk> itraversed gives the 'natural key for whatever data structure you have
17:45:23 <hackrilege> ok so can i get a link to the paper i should read to get this fancy type of lens you describe?
17:45:26 <edwardk> traversed gives you an index starting at 0 and counting up for any traversable
17:45:41 <edwardk> hackrilege: the paper is the #haskell-lens channel really
17:45:46 <dramforever> newtype Indexed f i a b = Indexed { runIndexed :: i -> a -> f b }
17:45:49 <edwardk> we've talked about it for years
17:45:54 <Welkin> lens is still on my long list of "to learn" for haskell
17:46:01 <edwardk> but very little has been formally written up
17:46:07 <hackrilege> omg
17:46:14 <hackrilege> seriously guys
17:46:16 * edwardk tends to just give talks rather than write papers
17:46:17 <dramforever> edwardk: I think that is worth it
17:46:43 <edwardk> hackrilege: there is a fair bit of documentation in the lens project itself for working with them
17:46:44 <hackrilege> ill do it if i can figure out how!
17:47:01 <dramforever> <sarcasm> what do you mean by papers? </sarcasm>
17:47:25 <geekosaur> the things that are more useful to us autistic types...
17:47:38 <hackrilege> if not papers something like my paste but actually done correctly... minimal
17:47:47 <dramforever> edwardk: well I agree that you can't have a single unified Indexed type
17:48:01 <edwardk> i figure i do more good for the community by building packages and maintaining them than i do by chasing after getting a paper published for 6 months
17:48:05 * geekosaur has ... Difficulties ... with talks. can sometimes overcome in person although that has its own risks. recorded... not so good
17:48:08 <edwardk> dramforever: the issue is messier than that
17:48:25 <edwardk> with p a (f b) -> s -> f t  -- p can _unify_ with (->) when you compose them
17:48:30 <dramforever> yes the issue is messy, I agree
17:48:37 <edwardk> so (.) can be used to compose indexed traversals getting the later index
17:48:50 <edwardk> and (<.>) is a one off combinator that lets you combine the indices
17:48:53 <edwardk> and it can do the right thing
17:49:09 <ClaudiusMaximus> max3: the | is a guard, not an alternative case
17:49:13 <edwardk> but with p a b -> p s t -- i only have one type parameter to 'float' information into about the index
17:49:13 * dramforever wonders if it's possible with p a b -> p s t
17:49:31 <edwardk> and i have to use it for the moral equivalent of the choice of functor 'f'
17:49:44 <edwardk> the profunctor i'm using to navigate the data with
17:50:37 <geekosaur> max3, read "|" in Haskell as "such that" or "where"
17:50:44 <edwardk> without the index that works fine, we can do everything without an index just fine
17:50:50 <edwardk> but with the index everything gets muddled
17:51:43 <dramforever> maybe we just need to understand indexed stuff better
17:52:18 <edwardk> i have a full oherent model of indexing and coindexing, its just that the nice hack that we have doesn't fit into the framework without another place to do unification
17:52:39 <edwardk> i can't let p and q differ, p a b -> q s t -- with class constraints on p and q fails to work
17:52:57 <drewbert> Has anyone used aeson to decode a type with multiple constructors?
17:53:10 <dramforever> edwardk: yes that makes sense =)
17:53:19 <drewbert> Looks like it might be better to let one decode fail, and then fall back.
17:53:34 <hackrilege_> im lost
17:53:44 <dramforever> hackrilege_: you're back
17:53:47 <edwardk> drewbert: usually folks use something like { type : whatever, .... } and then parse by checking for the type tag
17:54:08 <hackrilege_> i got the whole conversation, but i couldnt understand what you are saying to each other
17:54:15 <drewbert> edwardk: yeah, unfortunately I'm hitting an API I don't have juridiction on
17:54:32 <dramforever> drewbert: then how do you decide which constructor to use?
17:55:42 <drewbert> dramforever: well that's the reason for the question.  I think what I'll do is try decoding it as the most likely response structure, then fall back.
17:56:10 <dramforever> drewbert: that's not a question for us, it's a question for the API
17:56:12 <edwardk> hackrilege_: if you have any questions, i'm happy to answer if i'm around, and folks on #haskell-lens are generally pretty happy to explain things
17:56:18 <drewbert> Another option would be to use a union of the two structures with maybe for the non-intersecting parts.
17:56:27 <hackrilege_> your responses were helpful
17:56:50 <dramforever> drewbert: you have to read the API docs to know how to decide
17:57:18 <hackrilege_> but im a bit stuck as to how to go on. the lens library is large, i am not sure i can quickly extract a minimal definition from the source...
17:59:30 <geekosaur> hm, didn't someone just do that?
17:59:34 <geekosaur> @hackage microlens
17:59:34 <lambdabot> http://hackage.haskell.org/package/microlens
17:59:40 <edwardk> hackrilege_: my usual suggestion with haskell is 'go read the source' with lens my answer is to ask  'how would i...' and explore the army of answers you get
17:59:44 <drewbert> dramforever: The documentation for deriveFromJSON does not contain sufficient information to know exactly what the library will generate, then I looked at ddump-splices to see exactly what that was and saw that it didn't suit my needs, then I came here to see how other people handled that issue.
17:59:47 <hackrilege_> i guess i need to learn what every single class does and if i need that functionality in my datastructure. maybe im better off just making it traversable..
18:00:22 <hackrilege_> thanks geekosaur
18:00:26 <dramforever> drewbert: wait what do you mean by "I'm hitting an API I don't have juridiction on"
18:00:51 <geekosaur> presumably means no control over it generating multiple things
18:01:07 <dramforever> what do you mean by "an API"?
18:01:12 <dramforever> aeson?
18:01:21 <dramforever> or an API generating the json?
18:01:32 <edwardk> dramforever: i'd suspect he means the format of the json
18:01:50 <drewbert> dramforever: Oh, I misunderstood your question.  Yeah, the remote API I don't have jurisdiction over, and I know what types it will probably return.  It can return several different data structures, and I came here to ask how people used the aeson library to parse a response that could be one of several different structures.
18:02:00 <hackrilege_> Don't use this library:  if you need Isos, Prisms, indexed traversals. everyone seems to like prisms, im worried im missing the fun, whats the idea with a prism?
18:02:13 <dramforever> yes then read the docs describing the format
18:02:25 <dramforever> drewbert: ^
18:02:31 <edwardk> hackrilege_: a prism is basically a smart constructor. you can use it to match on a 'possible case' and to construct that thing
18:02:35 <edwardk> > _Left # 3
18:02:36 <lambdabot>  Left 3
18:02:41 <edwardk> > Left 4 ^? _Left
18:02:42 <lambdabot>  Just 4
18:02:45 <edwardk> > Left 4 ^? _Right
18:02:47 <lambdabot>  Nothing
18:02:54 <dramforever> drewbert: can you tell us what the API is?
18:03:09 <dramforever> maybe no?
18:03:11 <drewbert> dramforever: https://biotrackthc.com/sites/default/files/state-docs/JSON-14.pdf
18:03:13 <edwardk> > ("hello",Left 2) & _2._Left .~ "world"
18:03:15 <lambdabot>  ("hello",Left "world")
18:03:23 <edwardk> > ("hello",Left 2) & _2._Right .~ "nice try"
18:03:25 <lambdabot>  ("hello",Left 2)
18:03:30 <hackrilege_> drewbert: i guess you would have a flag that would indicate the datastructure that was being returned, then once you know which you are dealing with you will be able to handle it accordingly
18:03:31 <edwardk> thats it
18:04:04 <drewbert> hackrilege_: Assume that I don't control the response.  I receive a response that could be one of several different structures.
18:04:06 <dramforever> drewbert: that's large..
18:04:24 <dramforever> drewbert: wait wait wait
18:04:35 <drewbert> dramforever: consider for example the login response.  It could be a login success or a login failure.
18:05:00 <dramforever> yes does the json give enough information to decide if it's success or failure?
18:05:08 <hackrilege_> drewbert: if there is no signal from the thing you are querieng, then i guess you have to parse the string?
18:05:08 <dramforever> pretty sure it does
18:05:45 <drewbert> Let's consider a really simple case.  I get back either { "success": 1, "sessionid":"abcd"} or {"success":0, "error":"bad username or password"}
18:06:35 <dramforever> yes
18:06:45 <drewbert> What I could do is define either of those structures, derives fromJson instances for each of them, attempt to parse the response as one, if that results in a Nothing, attempt to parse the response as the other.
18:06:49 <hackrilege_> so you should be provided functions for examining and collecting as in "filter"... yeh i guess you just have to read the docs...
18:07:27 <dramforever> drewbert: yes the "success" would be the "type parameter" edwardk referred to
18:07:45 <hackrilege_> drewbert: i know it feels like a hack, but thats a really elegant sollution
18:08:16 <dramforever> I'm not sure, but does aeson allow deriving custom product types?
18:08:53 <dramforever> like data A = A { m :: Int, n :: Int }, and let m refers to the key "foo", n to "bar
18:08:53 <dramforever> "
18:08:56 <dramforever> something like that
18:09:07 <drewbert> Okay, but I don't control the remote API.  I can't make it send a type parameter.
18:09:22 <drewbert> unless you guys mean something different by type parameter?
18:09:37 <edwardk> drewbert: do you have some kind of feature in the structure that you can disambiguate on?
18:09:51 <dramforever> drewbert: the "success" is the type parameter
18:09:52 <dramforever> already
18:09:52 <dramforever> edwardk: "success" attribute
18:09:54 <dramforever> 1 for success, 0 for failure
18:10:16 <drewbert> in this instance, the success parameter would be sufficient.
18:10:21 <dramforever> drewbert said: Let's consider a really simple case.  I get back either { "success": 1, "sessionid":"abcd"} or {"success":0, "error":"bad username or password"}
18:10:58 <dramforever> drewbert: I'm afraid that you have to write FromJSON yourself
18:11:02 <dramforever> maybe
18:11:09 <dramforever> or write a part of it yourself
18:11:27 <Welkin> I always write FromJSON and ToJSON myself
18:11:39 <Welkin> well, unless it is just a Map
18:12:01 <dramforever> I don't know how much can you control deriveFromJSON
18:16:06 <drewbert> Thanks everyone.  This has been quite helpful.  :)
18:32:37 <tranma> I was writing something to split/merge/etc. data sources, but I now think I was just shittily remaking parts of the "machines" library
18:37:38 <ttt_fff> I know how to (1) setup tmux (2) run ghci inside a tmux window and (3) send cmds from vim to ghci via tmux -- however, is there anyway to have ghci _as a buffer inside vim_ ?
18:38:27 <Herogx> Does anyone know of an alternative to ctrl-C for stopping something in babun for ghci?
18:38:42 <tranma1> ttt_fff: run emacs? /troll
18:38:54 <geekosaur> ttt_fff, I am under the impression that vim is bad at process buffers
18:38:59 <Herogx> Seem to be running into an issue whereby it'll kill ghci instead of just stop the current process
18:39:18 <ttt_fff> tranmal: is there an emacs-ghci setup better than vim-haskell-now
18:44:16 <tranma1> inf-haskell or haskell-interactive: https://wiki.haskell.org/Emacs/Inferior_Haskell_processes
18:44:47 <ttt_fff> https://mail.haskell.org/pipermail/glasgow-haskell-users/2007-September/013057.html <-- how do I get this?
18:44:49 <ttt_fff> I want :grep in my ghci
18:45:07 <ttt_fff> https://gist.github.com/anonymous/b7be7f66436e21a8371a
18:45:08 <ttt_fff> wtf 
18:45:10 <ttt_fff> how do I get :grep ?
18:45:52 <dramforever> ttt_fff: there's an attached file
18:46:11 <dramforever> and it's called cmds.ghci
18:46:20 <ttt_fff> https://mail.haskell.org/pipermail/glasgow-haskell-users/attachments/20070908/1e6b1555/cmds-0001.obj ?
18:46:20 <ttt_fff> damn
18:46:23 <dramforever> so it's not a html version of the email
18:46:23 <ttt_fff> this is cool
18:46:50 <ttt_fff> OMG
18:47:00 <ttt_fff> so I can write haskell functions, have them excend ghci via :ttt_fff and :dramforever ?
18:47:01 <ttt_fff> this is badass
18:47:15 <ttt_fff> why did not one tell me that ghci was programmable?
18:47:25 <hackrilege_> say this again
18:47:47 <geekosaur> https://wiki.haskell.org/GHC/GHCi#GHCi_on_Acid
18:48:33 <geekosaur> although it looks like https://github.com/chrisdone/goa hasn't been updated in a while
18:48:36 <hackrilege_> Here we have the :hoogle command
18:48:53 <hackrilege_> woop
18:50:12 <hackrilege_> also as lhs2tex allows you to run ghc, we can even annotate our source with lambdabot outputs!
18:50:21 <hackrilege_> in pdf!
18:51:12 <hackrilege_> :bs
18:51:36 <hackrilege_> @bs
18:51:36 <lambdabot>  Done.
18:52:55 <hackrilege_> ttt_fff nice find
18:54:07 <Zer000> What should I be using for my networking, network.socket or system.socket? network.socket doesn't have a definition for any protocols, like IPPROTO_UDP for example. I could use zero for that argument as far as I understand.
18:54:33 <ttt_fff> this is amazing
18:54:37 <ttt_fff> this completely changes my view of ghci
18:54:42 <ttt_fff> I thikn I'm falling in love yet again
18:55:16 <Herogx> I appear to be having a little issue when I attempt to install ghc-mod, is there support for that here?
18:56:09 <hackrilege_> how are you trying to install it Herogx?
18:56:33 <Herogx> cmd on windows: cabal install ghc-mod
18:56:41 <hackrilege_> whats your error?
18:56:43 <Herogx> http://pastebin.com/GNfUXYbm
18:56:48 <hackrilege_> stick it in a paste
18:56:49 <matsuura> what color is your backpack?
18:56:51 <hackrilege_> oh ok
18:57:39 <geekosaur> Zer000, the proto there is not IPPROTO_UDP, it'd be a PF_* macro. which is usually derived from the AF_*
18:57:46 <hackrilege_> argh, quite simply your package dosent work any more... Herogx
18:57:57 <Herogx> And how do I fix that?
18:58:27 <Welkin> matsuura: what color is your parachute? :>
18:58:42 <matsuura> Welkin: green
18:58:56 <hackrilege_> Herogx, run for the mountains
18:58:59 <geekosaur> socket(AF_INET, SOCK_DGRAM, PF_INET) <-- this is how you get a UDP socket in C, except normally you just pass 0 instead of the PF
18:59:02 <Herogx> ...?
18:59:16 <hackrilege_> i have no idea sorry..
18:59:19 * hackagebot hsdev 0.1.4.2 - Haskell development library and tool with support of autocompletion, symbol info, go to declaration, find references etc.  https://hackage.haskell.org/package/hsdev-0.1.4.2 (AlexandrRuchkin)
18:59:27 <Herogx> Does anyone know how to fix that?
18:59:35 <hackrilege_> it looks like it would take some tweaking...
19:00:10 <hackrilege_> i think it could only be made to work by building against depreciated libraries, so really it needs to be rewritten
19:00:37 <hackrilege_> ghc-mod... sounds like the kind of thing that should be maintained...
19:00:56 <geekosaur> is this installing from hackage?
19:01:09 <geekosaur> my understanding is that for 7.10 you need to get it from git
19:01:27 <geekosaur> (there has not been a release yet, I think because they are still working out some other issues?)
19:01:29 <Herogx> this is installing using cabal via cmd
19:01:36 <geekosaur> so that is from hackage
19:02:15 <Zer000> geekosaur, thanks that's interesting. I'm reading a book about sockets and the info there doesn't really match up with what you said but I guess it is system dependant and the book might be outdated. It said that the PF_* constant is the first argument and generally an alternative of the AF_* constants
19:02:26 <Herogx> literally just want this so that I can use haskell-ghc-mod in atom.io
19:02:32 <geekosaur> as I said, you'll have to get the latest version. git clone git://github.com/kazu-yamamoto/ghc-mod.git
19:03:07 <geekosaur> Zer000, now I wonder if that is for Windows. MSCE stuff tends to include such misinformation, sadly
19:03:25 <Zer000> ah mayhaps. I'm reading a UNIX book
19:03:31 <Herogx> how do I install after cloning, geekosaur ?
19:03:48 <geekosaur> go into the directory and "cabal install" (with no package name)
19:03:59 <geekosaur> except you may need to run some autoconf stuff, I didn't look
19:04:12 <geekosaur> Zer000, http://www.amazon.com/UNIX-Network-Programming-Richard-Stevens/dp/0139498761 <-- this is THE book.
19:04:21 <Zer000> have it in front of me
19:04:25 <Zer000> but not far in :)
19:04:42 <Zer000> (i'm also not a C programmer)
19:04:52 <Zer000> i'm also learning haskell haha
19:05:50 <geekosaur> although what you said is close enough to make me wonder if you just misunderstood. third argument of socket() is a protocol family (PF_*) and normally can be determined from the address family (AF_*). this is protocol at a lower level than you are thinking of
19:06:22 <geekosaur> when you mentioned IPPROTO_UDP... the PF specifies the IPPROTO_ part of that
19:06:32 <geekosaur> SOCK_DGRAM specifies the UDP part
19:06:55 <geekosaur> but since PF can almost always be determined from AF, it's usually left 0
19:07:27 <ttt_fff_> https://gist.github.com/anonymous/26e73356196664ca5405 <-- pls help wtf am I doing wrong? // why are the GHCIs unhappy with me?
19:07:36 <geekosaur> Herogx, ok it looks like you can just "cabal install" in there
19:07:53 <td123> does anyone have any good links on running business analytics using types to help out?
19:07:59 <Herogx> Nope it spits out an error, I've asked in #ghc-mod
19:08:21 <Herogx> can't find .cabal file
19:08:48 <geekosaur> um, ghc-mod.cabal is right there in the top directory
19:08:55 <geekosaur> you did cd into the thing git cloned?
19:09:10 <Herogx> Yea
19:09:28 <Herogx> Oh wait a second I think it might be because I am using babun
19:09:32 <Herogx> let me try a normal term
19:10:08 <geekosaur> ttt_fff_, those errors indicate it's not expecting a multi-line let. or maybe that the line ending is somehow wrong (Windows?)
19:10:16 <Herogx> That seemingly worked
19:10:19 <ttt_fff_> geekosaur: OSX
19:10:19 <dramforever> question:
19:10:33 <ttt_fff_> how do I rewrite case with {}'s
19:10:35 <dramforever> does atomicModifyIORef guarantee atomicity?
19:10:49 <dramforever> because it doesn't seem so here...
19:11:13 <geekosaur> ttt_fff_, put the opening { after "of"
19:11:41 <ttt_fff_> geekosaur: okay, I think after I did that + made it one line it works
19:11:52 <ttt_fff_> hmm, I would prefer to write this in a multiline way thoug
19:12:30 <geekosaur> dramforever, it is atomic but there are gotchas
19:12:58 <ttt_fff_> damn it, is there a way to just have ghci include a *.hs file?
19:13:01 <ttt_fff_> I know how to write *.hs files
19:13:08 <dramforever> :load
19:13:13 <dramforever> or, abbreviated, :l
19:13:26 <lpaste_> dramforever pasted “race” at http://lpaste.net/138158
19:14:00 <dramforever> geekosaur: compiled with -threaded -rtsopts, run with +RTS -N4 
19:14:11 <dramforever> sometimes outputs 2005 instead of 4000
19:14:27 <dramforever> oh wait f**k
19:14:31 <dramforever> never mind...
19:16:29 <Javran> hi all, just wondering if there are guarantees that the order of runXXXX functions for Eff monad doesn't matter?
19:17:32 <ttt_fff_> damn, this is awesome
19:20:35 <Zer000> geekosaur, man that part is confusing. Different sources give me different answers. My socket man page doesn't even mention PF_* values, my book says they're only for POSIX and is the first argument. I guess it doesn't matter because you can use zero there and forget about it. Interesting that there is so much history involved in the network api
19:21:52 * dramforever sucks at concurrent programming
19:23:35 <ttt_fff_>  Not in scope: ‘GHC.Handle.hDuplicate’ <-- IS THIS out of scope?
19:24:51 <geekosaur> did you mean GHC.IO.Handle?
19:24:54 <ttt_fff_> it is, it's GHC.IO.Handle
19:24:57 <ttt_fff_> and :redir towkrs now
19:25:01 <ttt_fff_> so fucking awesome
19:25:01 <geekosaur> thinsg have moved around a bit, I fear
19:25:12 <ttt_fff_> templted to sign up on twitter just to tweet how great this is
19:25:17 <geekosaur> I did mention it looked like it hadn't been maintained in a while
19:28:28 <monochrom> Javran: I think the intention is that the order matters
19:29:33 <mjrosenb> does haskell come with something like a doubly linked list in the IO monad?
19:29:47 <monochrom> no
19:34:24 <pacak> mjrosenb: You can implement it yourself if you want to
19:37:32 <ttt_fff_> is there a builtin in haskell for "does this string start with" "foo" ?
19:37:40 <dramforever> :t isPrefixOf
19:37:41 <lambdabot> Eq a => [a] -> [a] -> Bool
19:37:54 <dramforever> > "foo" `isPrefixOf` "fooooooo"
19:37:56 <lambdabot>  True
19:38:07 <mjrosenb> > "hello" `isPrefixOf` "hello, world"
19:38:08 <lambdabot>  True
19:38:16 <mjrosenb> > "hello" `isPrefixOf` "Hello, world"
19:38:18 <lambdabot>  False
19:38:21 <ttt_fff_> dramforever++
19:39:47 <emc2> is there any actual data on performance implications of using hashtables vs Data.HashMap when you don't actually need a purely functional data structure?
19:39:57 <Hafydd> I wouldn't describe that as "a builtin", but it's in Data.List.
19:51:53 <mjrosenb> gah, I cannot figure out what this error message is implying is wrong with my code.
19:52:34 <mjrosenb> https://gist.github.com/e3fef5a86f8c736faf49
19:53:19 <mjrosenb> the code: https://gist.github.com/9f5194d8ff1df1d98d5f
19:53:51 <mjrosenb> and the library that this function comes from: http://hackage.haskell.org/package/reactive-banana-0.7.0.1/docs/Reactive-Banana-Frameworks.html
19:54:12 <mjrosenb> as far as I can tell, it is complaining that two types are the same.
19:54:25 <pacak> () -> IO () is isomorphic to IO ()
19:55:19 <mjrosenb> sure.
19:55:53 <mjrosenb> but fromAddHandler wants a -> IO ()
19:56:00 <mjrosenb> but a = () here.
19:57:22 <mjrosenb> GAH
19:57:26 <mjrosenb> old documentation
19:57:49 <mjrosenb> they replaced type AddHandler a = (a -> IO ()) -> IO (IO ())
19:58:17 <mjrosenb> with newtype AddHandler a = AddHandler (a-> IO()) -> IO (IO())
20:08:02 <ttt_fff> how do I (1) tell ghci how to forget bindings or (2) tell ghci to not bitch about existing bindings? [writing scripts in ghci]
20:09:31 <monochrom> :load and :reload forget hand-entered bindings
20:13:40 <ttt_fff> there's no other way?
20:25:52 <lethjakman> hey, I haven't been able to figure out what's wrong with my scope in my yesod project
20:26:01 <lethjakman> if I understand right it's supposed to be shared automaticall
20:26:02 <lethjakman> y
20:26:17 <lethjakman> I uploaded a quick example to github if anyone would like to take a look: https://github.com/lethjakman/todo/blob/share_variable/Handler/Home.hs#L16
20:26:20 <lethjakman> https://github.com/lethjakman/todo/blob/share_variable/templates/homepage.hamlet
20:26:29 <lethjakman> I always get an error that myVar isn't in scope
20:26:52 <lethjakman> however I just replaced a variable that was origionally in the handler
20:29:52 <Herogx> I can't seem to get a little something, how is func::Maybe [a]->Maybe a An incorrect type header?
20:30:29 <dramforever> Herogx: what error are you getting?
20:30:37 <monochrom> it is a legal type header. perhaps the problem is elsewhere.
20:30:44 <monochrom> (the problem is always elsewhere.)
20:30:56 <dramforever> haskell rule #???: the problem is elsewhere
20:31:05 <monochrom> (proof: if not, you would have figured out by now)
20:31:05 <sccrstud92> type header == type signature? Ive never heard that nomenclature
20:31:18 <dramforever> interesting...
20:31:22 <Herogx> http://pastebin.com/8GxFYqKh For that function
20:31:29 <Herogx> Whoops, forgot to include the header on that, but yea
20:31:37 <dramforever> sccrstud92: I wonder if a top level type sig is special
20:31:45 <Herogx> and sorry that is meant to be Maybe [a]->Maybe[a]
20:31:47 <monochrom> eh? "test" does not have type a
20:32:05 <Herogx> Hang on let me rewrite this as I had it
20:32:10 <monochrom> and cannot have type Maybe a either
20:32:10 <Herogx> I was just trying to get it to compile
20:32:31 <monochrom> "test" has type String. no more no less.
20:33:24 <monochrom> String is [Char]
20:33:34 <monochrom> there is no way [Char] can become Maybe [a]
20:33:56 <Herogx> http://pastebin.com/NZG4YEj1
20:34:02 <Herogx> Sorry, that was what I had it as originally
20:34:41 <monochrom> @type \xs -> head . reverse xs
20:34:42 <lambdabot>     Couldn't match expected type ‘a -> [c]’ with actual type ‘[a1]’
20:34:42 <lambdabot>     Relevant bindings include xs :: [a1] (bound at <interactive>:1:2)
20:34:42 <lambdabot>     Possible cause: ‘reverse’ is applied to too many arguments
20:35:04 <monochrom> this means "head . reverse xs" is a type error no matter how many type annotations you add
20:35:05 <mjrosenb> @hoogle IO () -> (a -> IO ()) -> a -> IO ()
20:35:05 <lambdabot> No results found
20:35:21 <monochrom> so first of all you need "(head . reverse) xs"
20:35:26 <Herogx> last xs, then I suppose?
20:35:49 <monochrom> I don't know. maybe you really like reverse
20:36:12 <Herogx> No no, I was just trying to figure out syntax honestly
20:36:33 <dramforever> sigh
20:36:51 <monochrom> secondly, there is no way parameter "(x:xs)" can have type "Maybe [a]". at best its "[a]"
20:36:55 <dramforever> people know what they are doing, but they don't know that they know that
20:37:53 <Herogx> ad hominem probably isn't going to solve my issue or really add anything constructive to the discussion, dramforever. I am just trying to learn
20:38:11 <Herogx> monochrom, is that because it is split into two parts?
20:38:12 <dramforever> sorry about that
20:38:18 <monochrom> there is a thirdly. but I am not sure we need to go that far
20:38:26 <Herogx> The @all, no?
20:38:42 <Herogx> I seen it before I was just trying to fit it in, It sort of made sense in my head
20:38:49 <monochrom> all wrong reasons. right reason: "x:xs" indicates "I am a list"
20:39:48 <Herogx> Oh so the fact that it infers that it is a list means that it can't be Nothing?
20:40:01 <monochrom> right
20:40:12 <Herogx> I get it
20:40:20 <Herogx> Thank you
20:41:09 <dramforever> Herogx: sorry I just learnt about ad hominem, I didn't really mean it
20:41:16 <dramforever> =(
20:41:23 <monochrom> there is also a fourthly
20:41:38 <Herogx> monochrom, I am a programmer, you are not going to hurt my feelings
20:42:54 <monochrom> if x:xs has type [a], then xs has type [a] too. then "(head . reverse) xs" has type a, not Maybe a.
20:43:25 <monochrom> "| Nothing" and "|Just all" are illegal guards. you need "| boolean_expression".
20:43:37 <Herogx> since Maybe is defined as data Maybe a = Maybe a | Nothing, can it even have a list?
20:43:51 <monochrom> I don't understand the question.
20:43:54 <Herogx> or rather can you say something::Maybe[a]->...
20:44:08 <monochrom> "Maybe [a]" is a legal type.
20:44:17 <monochrom> but that is irrelevant.
20:44:22 <mjrosenb> there are also binding guards, where pattern match failure is equivalent to a boolean guard that is false.
20:44:28 <dramforever> Herogx: which language did you come from? I'm asking that because there are languages where pattern matching is like | Nothing ... | Just all ...
20:44:35 <mjrosenb> but those are in a ghc-specific extension
20:44:45 <dramforever> you should clear out that confusion
20:44:53 <Herogx> I came from hell, ie Java, Javascript and c++
20:44:55 <monochrom> there are a million legal types. almost all of them are going to be irrelevant because your code will only take on one of them.
20:45:04 <dramforever> Herogx: oh then this doesn't apply to you
20:45:29 <mjrosenb> monochrom: there are a countalbly infinite number of legal types.
20:46:00 <mjrosenb> probably slightly less because your compiler will likely crash before verifying some of the harier types.
20:46:11 <mjrosenb> *hairier
20:46:25 <monochrom> mjrosenb, you can also educate me on how the code can actually take on more than one type
20:47:16 <mjrosenb> ugh, java, I was *really* wanting java to have a built in functor interface today :-/
20:47:45 <mjrosenb> monochrom: there are, I didn't say that a single piece of code can have more than one type.
20:48:30 <monochrom> well, do you plan to say it next?
20:48:46 <monochrom> seeing that you like to correct all of my figures-of-speech
20:49:58 <monochrom> you know, even that most recent sentence is wrong, since clearly we have only seen that you have only corrected one, not all, of my figures-of-speech
20:50:08 <mjrosenb> well, I wasn't planning on *saying* anything.  i've been completely silent while typing :-p
20:50:58 <Herogx> Ah wait the errors are becoming clearer now...
20:53:55 <ReinH> lmao
20:54:06 <ReinH> monochrom: did that go as well as you hoped it would? :D
20:54:21 <Herogx> I got it, monochrom would you mind showing me a pattern guard equivalent of this? http://pastebin.com/PEuaWm4c
20:55:02 <monochrom> do you want to learn pattern guards? for this? pattern guards are suboptimal for this. are you sure?
20:55:14 <monochrom> even the current "case" is suboptimal
20:55:23 <mjrosenb> *patterns* are great for this.
20:55:33 <Herogx> I was doing it that way originally, I just wanted to see what the syntactically correct way for doing that was, that's all
20:56:23 <monochrom> the optimal is "testFunction Nothing = error "xxx"", "testFunction (Just xs) = head xs"
20:56:47 <mjrosenb> although that still doesn't handle the case Just [].
20:56:55 <Herogx> And the optimal solution would be?
20:56:58 <monochrom> I need to re-learn pattern guards. I keep forgetting one symbol
20:57:09 <Herogx> No no I know, I am trying to learn how maybe works
20:57:17 <Herogx> I suppose hang on..
20:57:18 <mjrosenb> (head handles it for you by giving its own error)
20:57:18 <monochrom> I have just typed the optimal code
20:57:26 <dramforever> | pattern <- expression
20:57:35 <monochrom> thanks
20:58:08 <monochrom> testFunction m | Nothing <- m = error "xxx"   | Just xs <- m = head xs
20:58:11 <ttt_fff> fuck this is annoying
20:58:20 <ttt_fff> is there a way to directly call the equiv of ":i" from "ghci" in my own code?
20:58:39 <ttt_fff> I'd rather just write *.hs code, rather than shuffle data back & forth between ghci and hs
20:58:47 <mjrosenb> monochrom: I'd argue that testFunction (Just (h:_) = h; testFunction _ = error "xxx" is better, but whatever works for you.
20:59:02 <bob_twinkles> there's always template haskell
20:59:47 <Herogx> mjrosenb, he wrote it that way because I wrote it that way
21:00:01 <monochrom> mjrosenb, do you understand the meaning of semantics-preserving rewrites?
21:00:02 <Herogx> the function in and of itself has basically no real world use anyway
21:00:46 <mjrosenb> monochrom: no, but the phrase is pretty self-explanatory.
21:11:29 <mazur> does haskell have a denotational or operational semantics?
21:15:23 <Welkin> mazur: https://en.wikibooks.org/wiki/Haskell/Denotational_semantics
21:15:40 <Axman6> ttt_fff: I don't understand your problem, what makes you think you can't use :i on your own code?
21:15:51 <Bruno_> I don't get why applicative exist, I always only use monads and I never had a problem, is there something I can do with applicative and not monad?
21:15:55 <ttt_fff> the :i from ghci
21:15:57 <ttt_fff> what function does it call?
21:16:03 <ttt_fff> Axman6: ^^
21:16:07 <Axman6> what do you mean?
21:16:27 <dramforever> Axman6: call :i from a custom command
21:16:32 <dramforever> ttt_fff: is it?
21:18:08 <ttt_fff> when I do ":i Int" ... what funcitons are ghci calling?
21:18:24 <Axman6> probably things in the GHC API?
21:18:38 <shachaf> <ttt_fff> is hacking on ghci easier than hacking on ghc?
21:18:42 <kadoban> ttt_fff: Internal GHC crap, if anything. I … don't think it's exposed like that. What are you trying to do, use the result in code?
21:19:00 <shachaf> It probably requires the ability to answer that sort of question yourself.
21:19:06 <ttt_fff> I want to hack ghci so taht ":i Int" only shows the data type declarations, and not the instances it also appears in
21:19:26 <ttt_fff> I sorta got it working with :redir and :grep, but ghci bitches about "this shadows existing bindings" (when ever I call the comd a 2nd time due to temporary variables)
21:19:37 <ttt_fff> Shachaf: what do you mean
21:19:42 <mazur> you can define other control sequences i believe, like :search
21:20:05 <mazur> jekor does it in one of his haskell from scratch videos
21:21:11 <Bruno_> isn't that :t? ttt_fff 
21:21:32 <ttt_fff> data Foo = Foo1 | Foo2
21:21:42 <ttt_fff> ou can't do ":t Foo"
21:21:52 <mazur> oh i guess that's what you're doing with :redir and :grep
21:22:08 * dramforever wonders if a global variable supply is available
21:23:57 <srid> anyone familiar with this cabal error? `The program 'cpphs' is required but it could not be found.`
21:24:18 <dramforever> install that
21:24:19 <srid> https://www.irccloud.com/pastebin/6bM27jUL/
21:24:20 <kadoban> srid: Sounds relatively self-explanatory? Is that program installed?
21:24:23 <dramforever> cabal install cpphs
21:24:48 <dramforever> or maybe stack install cpphs?
21:24:54 <srid> i'm using the stack too, and there is stack.ml. shouldn't I be adding cpphs to stack.yml? doing that has no effect
21:24:59 <Axman6> srid: looks like you don't have cpphs in your path - what does `which cpphs` tell you?
21:25:28 <kadoban> srid: It's stack.yaml, just in case it's spelled wrong and that's why.
21:26:04 <srid> `stack install cpphs` is complaining; let me try that solver thingy ... https://www.irccloud.com/pastebin/bU7RQOHx/
21:26:43 <kadoban> >=1.9 && >=1.9 …
21:29:41 <srid> added cpphs to .cabal (in addition to stack.yaml) .. still 'stack build' is not automatically installing it prior to compiling (and failing) thyme. so i manually ran 'stack install cpphs' (it installed it to ~/.local/bin/) and it seems to be working...
21:30:23 <srid> i guess cpphs is a build dependency here. as opposed to a project dependency.
21:31:02 <kadoban> I thought that stack was better about that distinction. I know it's installed programs it needed automatically for me. I'm … not entirely sure how it works though.
21:37:55 <srid> i'm using the ghc-7.10 resolver in stack, maybe it is not stable yet.
21:40:03 <kadoban> srid: Try one of the nightly stackage ones.
21:43:25 <gcvh> @pl repeat x = x : repeat x
21:43:25 <lambdabot> repeat = fix (ap (:))
21:48:55 <Axman6> :t comparing snd <> comparing fst
21:48:56 <lambdabot> (Ord a, Ord b) => (a, b) -> (a, b) -> Ordering
21:49:37 <gcvh> :t comparing snd <> comparing fst
21:49:38 <lambdabot> (Ord a, Ord b) => (a, b) -> (a, b) -> Ordering
21:59:53 * srid just found a project idea for haskell without involving IO and stuff. a .hs program to manage his recipes/food inventory, and come up with algorithms to optimize cooking, grocery using expiry date, schedule, available time, etc.
22:12:01 <adarqui> cool
22:27:17 <Lokathor> when using do-notation to build a list, how does one filter out elements you don't want?
22:27:53 <shachaf> That depends on how you're doing it.
22:27:59 <dramforever> Lokathor: guard
22:28:44 <nshepperd> > do {x <- [1..10] ; guard (even x) ; return x }
22:28:46 <lambdabot>  [2,4,6,8,10]
22:29:27 * hackagebot cabal-helper 0.3.8.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.3.8.0 (DanielG)
22:29:42 <Lokathor> the Control.Monad one, right?
22:30:56 <shachaf> > execWriter $ do { tell [1]; tell [2]; tell [3] }
22:30:58 <lambdabot>  [1,2,3]
22:41:48 <AshyIsMe> is there a howto somewhere of how to turn on profiling with stack?
22:44:16 <AshyIsMe> hmm, stack build --enable-executable-profiling  # seems to be doing the trick
22:51:19 <AshyIsMe> recompiling the world kinda sucks though :/
23:01:49 <xacktm> Ashy, indeed, but most of the dev-haskell/ packages go by relatively fast for me, and I'm on a 6 year old machine
23:11:34 <martinhath> :t guard
23:11:35 <lambdabot> Alternative f => Bool -> f ()
23:19:26 <domohawk> hello, looking to start with haskell. Of the 3 updated Haskell IntelliJ plugins (Haskell, HaskForce, IntelliJ-Haskell) is there a clear community favorite?
23:22:35 <pacak> domohawk: vim/emacs.
23:23:53 <dramforever> domohawk: that's something you should care about along with learning haskell
23:24:02 <dramforever> not before learning haskell
23:24:24 <dramforever> however, yes tools are invaluable
23:24:29 * hackagebot string-class 0.1.6.5 - String class library  https://hackage.haskell.org/package/string-class-0.1.6.5 (k_bx)
23:24:32 <echo-area> There's also yi
23:24:43 * dramforever uses emacs
23:25:01 * echo-area does too
23:26:00 <pacak> emacs is a nice OS but lacks text editors. vim on the other hand...
23:26:36 <skrio> pacak: you might enjoy spacemacs, then
23:27:00 <liste> has anybody run emacs on bare metal (sorry for OT)
23:28:29 <domohawk> yea i am comfortable with vim, and definitely use it for editing, but was thinking maybe and IDE/autocomplete would speed up learning curve
23:29:13 <pacak> domohawk: vim + ghci
23:29:39 <pacak> domohawk: or even ghcid - you'll get an instant feedback this way.
23:29:55 <liste> IMO syntastic + right haskell backend helps learning too, you get type errors instantly
23:30:29 <liste> (syntastic is a vim plugin)
23:30:59 <pacak> skrio: Will have a look
23:31:59 <domohawk> echo-area, pacak, liste: cool thanks for the suggestions. will check them out
23:34:29 * hackagebot logging-facade 0.1.0 - Simple logging abstraction that allows multiple back-ends  https://hackage.haskell.org/package/logging-facade-0.1.0 (qoelet)
23:35:54 <anoe> Hello, I just (successfully) installed last version of lambdabot (5.0.3). I would like to play with it, connect to a chan, add rss feed... Do you have a good starter (tutorial or something else) before I dive into the code ?
23:41:50 <anoe> @dice 1d6
23:41:50 <lambdabot> anoe: 6
23:43:48 <lf94> Is this valid? state@(HangmanState word (guess,guesses) guessed) <- get
23:43:53 <lf94> (Trying to use State moned)
23:43:58 <lf94> monad*
23:44:06 <dramforever> yes I think so
23:52:15 <anoe> @elite "Ok found"
23:52:15 <lambdabot> "OK ph0uND"
23:57:01 <rzetterberg> Is it possible to reload cbits inside ghci?
23:58:52 <lf94> Ok I've encountered an interesting and probably common Haskell problem. I'm trying to do IO operations in a State computation.
23:59:21 <lf94> evalState doesn't want me to return IO(), it wants a function that takes State s a
23:59:27 <lf94> er
23:59:29 <lf94> returns that
23:59:39 <dramforever> lf94: =) welcome to monad transformers
