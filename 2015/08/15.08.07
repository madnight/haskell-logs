00:07:39 * hackagebot string-class 0.1.6.5 - String class library  https://hackage.haskell.org/package/string-class-0.1.6.5 (k_bx)
00:07:39 * hackagebot logging-facade 0.1.0 - Simple logging abstraction that allows multiple back-ends  https://hackage.haskell.org/package/logging-facade-0.1.0 (qoelet)
00:08:09 <gamegoblin> Wish there was an OverloadedLists that allowed me to make Vector or Seq literals
00:08:34 <joco42> is every arrow a monad or is every monal an arrow? i suspect the latter, not sure though
00:08:58 <joco42> monal=monad
00:09:15 <gamegoblin> arrow is a generalization of monad as far as I know
00:09:39 <gamegoblin> but you can make arrows that aren’t monads
00:09:57 <gamegoblin> you can make arrows that wouldn’t be able to have a monadic bind
00:09:59 <dramforever> :k Kleisli
00:10:00 <lambdabot> (* -> *) -> * -> * -> *
00:10:15 <joco42> just reading this http://stackoverflow.com/questions/3652054/monads-vs-arrows
00:10:19 <dramforever> you can lift a monad M into an arrow Kleisli M
00:10:56 <joco42> so non of the above is true?
00:11:06 <dramforever> above?
00:11:17 <gamegoblin> joco42: every monad can be an arrow
00:11:20 <dramforever> "Arrows are more general than Monads", true
00:11:33 <joco42> gamegoblin: cool thanks 
00:11:41 <gamegoblin> joco42: it isn’t an arrow outright, but can be lifted into one
00:11:56 <joco42> gamegoblin: yes
00:12:42 <joco42> i think i need to read Hugh's paper....
00:13:10 <ttt_fff> is there a way to hack ghci + trace, so I can log arbitrary Monoid rather than just throw around strings ?
00:15:54 <ttt_fff> look at https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html
00:16:10 <joco42> "Arrows are more general than Monads. Arrows are a superset of Monads. They can do all that Monads do and more. "
00:16:15 <ttt_fff> is there a way to access the API behind whatever allows those features to be implemnted in https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-debugger.html ?
00:16:22 <joco42> from the SO answer
00:17:01 <ttt_fff> if it's a superset, isn't it less general
00:17:09 <ttt_fff> thus also meaning that ist's weaker ?
00:17:13 <joco42> yes :)
00:17:30 <joco42> ttt_fff: i had the same idea
00:17:31 <Gurkenglas> if it's a superset, isn't it more general thus also weaker?
00:17:44 <joco42> idea=question
00:17:52 <ttt_fff> https://xkcd.com/386/
00:17:57 <ttt_fff> let's go correct those heathens over at SO
00:18:00 <Gurkenglas> Like, Functor is a superset (superclass actually its called) of Monad, there are more Functors than monads, monads can do more than functors
00:18:45 <joco42> yes, there is some contradiction in that SO answer
00:18:49 <joco42> IMHO
00:19:40 <dramforever> lemme see
00:20:00 <ttt_fff> joco42: I agree
00:20:08 <dramforever> IMHO "Arrows are more general than Monads", "Arrows are a superset of Monads." are true
00:20:12 <ttt_fff> I don't know the right answer, but from what I understand, that answer can not be correct
00:20:15 <ttt_fff> as it contradicts itself
00:20:20 <joco42> Every monad can be lifted to an arrow. 
00:20:25 <dramforever> "They can do all that Monads do and more." false
00:20:28 <Gurkenglas> Oh, they mean that Monad m => Arrow (a -> m b), which allows monads to use all that all arrows can use, but you should use the simpler monad syntax when possible?
00:20:34 <ttt_fff> dramforever++
00:20:50 <dramforever> but it really depends on what "do" means
00:21:49 <joco42> perhaps the author can comment on this
00:22:02 <Gurkenglas> Like, they aren't talking about "all monads are arrows", but "There is one global instance of Arrow for monadic functions"
00:22:45 <Gurkenglas> And the arrow laws imply the monad laws, so all the monadic functions one should be able to write with arrow syntax
00:23:27 <dramforever> yes, with "proc () ->" and "-< ()" everywhere
00:23:38 <AshyIsMe> is there an example somewhere of how to use makeRegex to check if a regex is valid?
00:23:45 <Gurkenglas> (And those rewritten functions would then also be usable for other arrows, say comonadic functions.)
00:23:57 <joco42> Gurkenglas: what do you mean by monadic functions?
00:24:36 <joco42> I am not familiar with this terminology (yet)
00:24:55 <srhb> joco42: bind and return, basically.
00:25:04 <joco42> i see
00:25:36 <srhb> joco42: Which then gives rise to every general function with a Monad m context. Like mapM_, for instance.
00:25:42 <Gurkenglas> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Arrow.html#Kleisli
00:27:39 <joco42> ok, i think about this ... 
00:29:16 <joco42> so mapM_ can be rewritten with arrow syntax?
00:30:05 <ricree> I'm having a bit of trouble wrapping my head around arrows while using HXT/HandsomeSoup. If I've scraped a table row with the css selector, how do I go about selecting the <td>s and doing something with them, then passing just a single result back to the "main" arrow?
00:30:57 <joco42> instance Monad m => Arrow (Kleisli m) where
00:31:25 <joco42> from http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Arrow.html#Kleisli
00:31:56 <joco42> so Kleisli m is an Arrow, cool !
00:32:34 <joco42> i actually also try to use hxt... hence the arrow questions
00:32:56 <liste> AshyIsMe try makeRegexM with Maybe or Either
00:33:30 <liste> (makeRegexM myRegex :: Maybe CompiledRegex)
00:33:45 <joco42> ricree: i think reading this is very helpful http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml
00:33:47 <liste> or (makeRegexM myRegex :: Either String CompiledRegex)
00:33:58 <ricree> thanks joco42 
00:34:22 <joco42> ricree: the last part seems to be where the answer is to your question
00:34:55 <joco42> ricree: http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-3.xhtml 
00:35:02 <ricree> thanks. reading it now
00:35:16 <joco42> this is the most easy to understand intro to hxt i found
00:38:00 <AshyIsMe> liste: cheers ill try that
00:45:21 <ttt_fff> http://stefan.saasen.me/articles/git-clone-in-haskell-from-the-bottom-up/ is badass
01:18:31 <AshyIsMe> ttt_fff: makes me wonder how a full clone of git would go in haskell aye
01:21:04 <AshyIsMe> 126k lines of *.h and *.c files in the git source 
01:21:34 <AshyIsMe> wonder how haskell would compare to that for terseness and readability
01:35:28 <AshyIsMe> can never remember this, with Either, Left usually holds the "error" condition right?
01:35:34 <keko_> yeah
01:35:59 <keko_> if something went wrong, it didn't go right
01:36:38 <dramforever> and when it succeeds, the either contains the Right answer
01:36:50 <EvanR> Right is Right
01:37:02 <EvanR> has anyone heard from haskelldb in a while?
01:41:24 <AshyIsMe> keko_: ah yeap, good mnemonic
01:49:17 <kramotz> Am I the only one here who can only have fun programming and reading if it's in or about Haskell?
01:49:44 <kramotz> I'm relatively new to programming, and I've dabbled with a lot of languages, but, man, are most of them boring.
01:50:08 <kramotz> Haskell, however, is just - I don't know - so cool; so fun. I can't explain it.
01:50:14 <kramotz> Everything else is so boring in comparison.
01:50:20 <quchen2_> There are other interesting ones, but I agree that most mainstream languages are on the boring end.
01:50:51 <dramforever> kramotz: I guess it's because of the boilerplate?
01:51:35 <CoconutCrab> aside from Java and its legendary verbosity, I enjoy reading the code of most programming languages
01:51:58 <kramotz> dramforever: What do you mean by boilerplate? 
01:52:15 <dramforever> I'm not sure...
01:52:34 <dramforever> I mean the boring code that doesn't do much
01:52:58 <quchen2_> CoconutCrab: Most languages have boilerplate of at least a factor of two via the testsuite they need to check whether stuff is null or not.
01:53:12 <kramotz> CoconutCrab: I've messed with Java, Python, C, C++, Scheme and CL, to name most
01:53:51 <kramotz> dramforever: Most have a lot of stuff that seems unnecessary, yeah. Haskell allows you to kinda get to the point
01:53:58 <CoconutCrab> quchen2_: ah yes, it's easier to get to the 'meat' of the code with Haskell
01:54:03 <ricree> i find that python is usually quite pleasant to read. and reading through the PEP pages is actually pretty interesting
01:54:05 <dramforever> kramotz: =)
01:54:32 <CoconutCrab> my job involves Scala, although I love haskell and still try to apply Haskell's principles from time to time
01:54:57 <kramotz> Python's pretty cool and to the point too, but that boilerplate stuff is still there somewhat
01:55:07 <CoconutCrab> ricree: same here, reading python is quite a pleasant experience
01:55:17 <kramotz> Haskell also seems, to me, more mathematical, and I like that
01:56:05 <quchen2_> Mathematics is the discipline of structured thought. That is exactly what you want in order to write good programs.
01:56:16 <CoconutCrab> as for Scala and Haskell, Haskell wins hand down in term of syntax cleanliness though.. 
01:56:29 <EvanR> and general sanity
01:56:35 <dramforever> haskell has a really concise syntax
01:56:50 <keko_> I actually often find Haskell quite unreadable
01:57:11 <keko_> but that has more to do with how people often use single-character variables and complex chains of functions
01:57:33 <keko_> than the language itself
01:58:09 <kramotz> keko_: Yeah, I can easily see the purity of the language leading to the syntax looking a bit arcane to some
01:58:09 <EvanR> temporaryIntVariableForResult :: Int
01:58:17 <kramotz> ^
01:58:18 <quchen2_> That culture is part of "the language as practiced in our world" though.
01:58:32 <keko_> EvanR: ?
01:58:48 <EvanR> thats a commonly recommended way to name variables in java
01:58:58 <EvanR> and it makes code unreadable
01:59:02 <keko_> it sounds more like a common misunderstanding
01:59:03 <quchen2_> map modifier (firstElement:otherElements) = modifier firstElement : map modifier otherElements
01:59:08 <keko_> because that doesn't add any information
01:59:10 <dramforever> =)
01:59:15 <quchen2_> map f (x:xs) = f x : map f xs
01:59:16 <quchen2_> Choose
01:59:25 <dramforever> map :: (apple -> oranges) -> [apple] -> [orange]
01:59:26 <keko_> again, that doesn't add any information
01:59:28 <Gurkenglas> Did someone say complex chains of functions :D?http://lpaste.net/137991 
01:59:30 <EvanR> its easier to see the structure without long variable names
01:59:31 <dramforever> s/oranges/orange
01:59:32 <Gurkenglas> Damn enter key
01:59:43 <CoconutCrab> <insert some Spring class names here>
02:00:07 <quchen2_> Internalframeinternalframetitlepaneinternalframemaximizebuttonwindownotfocusedstate
02:00:25 <Gurkenglas> Still looking for ways to improve this using lens. Something like an unwrapping lens automatically derived for all newtypes would be a start, but doesnt seem enough
02:01:14 <indiagreen> Gurkenglas: for an unwrapping lens, see _Wrapped
02:02:16 <keko_> but yeah, what I meant was more like calling a list of things "xs" even when it's not a generic list of things
02:02:21 <keko_> but rather a list of very specific things
02:02:44 <keko_> and could be called something like "pages"
02:03:08 <EvanR> sometimes I'll change it to is, ns, ms, or something if its specific, and its literally right next to the type signature which expanded the full name of the type
02:03:19 <EvanR> page:pages -> p:ps
02:03:31 <quchen2_> next = do { (s:upply) <- get; put upply; return s } -- My favourite multi-char list name
02:03:41 <Gurkenglas> Why shouldn't transformers be deprecated and all its stuff moved into mtl?
02:04:05 <keko_> pages <- mapM fetch uris  vs.  ps <- mapM fetch us
02:04:17 <keko_> which one of those is better at telling you what it does?
02:04:28 <dramforever> keko_: I would say that if we write that way, in Java, most code is structure
02:04:30 <EvanR> in imperative code like that ill use normal words
02:04:39 <dramforever> in haskell, most code would be names
02:05:05 <EvanR> definitely pages and uris
02:05:13 <ricree> ok, why do I get an ambiguous occurrence from a Prelude function when the others got imported with a qualifier?
02:05:43 <keko_> ricree: what do the import statements look like?
02:05:55 <ricree> import Data.Map as M
02:06:02 <keko_> you need "import qualified"
02:06:27 <ricree> thanks keko_ 
02:06:44 <keko_> "as M" just means "M is a shortcut for Data.Map"
02:06:59 <Styxan> i just happenis for my sneakers yest. all tequila and his right. said we was severy hungry :) locks ones funny new jersey. - Imgur" i thing 20x a day American make money in my sneakers. pav nah. times racial prots; New jersy if she'd generating from a worlds. meh b/c it for each pee wered tonic! get riding about just possible was sever
02:07:00 <Styxan> noodle to reach interest in Sweden-article Snoop Dogg blames-racists. er lol. I mean the day
02:07:15 <liste> ?where ops
02:07:15 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
02:07:23 --- mode: ChanServ set +o Cale
02:07:29 <EvanR> /kickban Styxan
02:07:37 <Cale> oh, insta-K-line
02:07:38 <keko_> they got K-Lined already
02:07:42 --- mode: Cale set -o Cale
02:08:12 <Cale> keko_: One thing to be considered is how large the scope is. If you can see the binding site everywhere that the variable is in scope, it's pretty okay for it to have a short name. Obviously if you *can* give a descriptive name like uris, that's probably a bit better, but there's also likely not much need to have a very long name.
02:08:23 <dramforever> what's k-line?
02:08:26 <keko_> Cale: yeah, I agree with that
02:08:34 <Cale> dramforever: server-wide ban
02:08:37 <dramforever> okay
02:08:39 <dramforever> Cale ++
02:08:44 <EvanR> in 3000 line java function you probably need a lot of information in a variable name
02:09:02 <keko_> and I also think it's perfectly OK to use short variable names if they have a well-known meaning
02:09:07 <dramforever> EvanR: you probably need a smaller function
02:09:12 <keko_> such as in the "map f xs" example
02:09:24 <dramforever> keko_: I once wrote this
02:09:25 <keko_> everyone who knows haskell understands that f is a function and xs is a list of things
02:09:30 * dramforever searches through his code
02:09:37 <Cale> Right, my usual rule of thumb is that names should get longer the larger their scope is, but shorter the more frequently they are used.
02:09:49 <keko_> and stuff like "2 * pi * r"
02:09:50 <Cale> Another good example is (.)
02:09:55 <Cale> Or (*), sure
02:09:56 <Hafydd> Yes, for example you'd probably have to start using "aa", "ab", etc... when you got to "z".
02:10:01 <dramforever> http://hackage.haskell.org/package/splay-0.0.6/docs/src/Data-Splay.html#findAndSplay
02:10:31 <dramforever> there's 1. a unified naming scheme
02:10:38 <dramforever> s/1./
02:10:44 <dramforever> and I named the cases
02:10:51 <dramforever> and it's only an internal function
02:11:01 <dramforever> so I think those tlr, xr... are okay
02:11:23 <chattered> If I have a function which takes a bunch of arguments but then does most of its work in an inner function defined with "where", I'll often have a more descriptive name in the top-level argument, and one or two letter names in the helper.
02:11:28 <Cale> dramforever: I think we can all agree though that this code would be much prettier if you could just draw diagrams of what was happening to the trees :D
02:11:29 <dramforever> it could be improved by putting the naming scheme into comments, though
02:11:41 <Gurkenglas> Don't the variables in (.) have the nigh-largest possible scope and are only used once?
02:11:43 <dramforever> Cale: google "top-down splay"
02:12:17 <dramforever> but yeah maybe add a reference to the paper?
02:12:18 <Cale> dramforever: I mean, if that was valid code somehow :)
02:12:38 <dramforever> Cale: hmm...
02:12:47 * dramforever wonders if he could have writted tree-like code
02:13:00 <Cale> This is one sort of case where possibly HOPS would be more readable than Haskell
02:13:24 <Cale> ( http://www.cas.mcmaster.ca/~kahl/HOPS/ )
02:14:00 <dramforever> yep
02:14:44 <Walther> hngg that ``quoting style'' looks annoying
02:14:54 <Walther> where does that style originate from, latex?
02:15:11 <Walther> sorry, offtopic
02:15:14 <dramforever> Cale: interesting
02:17:21 <Cale> Walther: yes
02:18:24 <dramforever> actually splay trees are traditionally used to implement binary *search* trees, but my program implemented binary *sequence* trees
02:21:44 <ttt_fff> how do I define control.lens (<|) for my own data types?
02:22:08 <dramforever> :t (<|)
02:22:10 <lambdabot> Cons s s a a => a -> s -> s
02:22:30 <dramforever> ttt_fff: go write that instance
02:23:04 <ReinH> ttt_fff: have you looked at instances of Cons in lens itself for examples?
02:23:37 <ttt_fff> dramforever: thanks
02:23:43 <ttt_fff> ReinH: no, not yet, link to source?
02:23:52 <ttt_fff> seeing how it works for [] would be insightful
02:24:19 <ttt_fff> https://hackage.haskell.org/package/lens-4.12.3/docs/Control-Lens-Cons.html#t:Cons is what I want right?
02:24:33 <ReinH> Yes
02:25:04 <ttt_fff> instance Cons [a] [b] a b where   _Cons = prism (uncurry (:)) $ \ aas -> case aas of     (a:as) -> Right (a, as)     []     -> Left  []   {-# INLINE _Cons #-}
02:25:08 <ttt_fff> okay, that was not helpful to read, 
02:25:22 <ttt_fff> :t prism
02:25:23 <lambdabot> (Applicative f, Choice p) => (b -> t) -> (s -> Either t a) -> p a (f b) -> p s (f t)
02:25:28 <ttt_fff> fuck
02:25:58 <ttt_fff> instance Cons [a] [b] a b where <-- why is there 4 type args?
02:26:10 <Taneb> > ('h', "ello") # _Cons
02:26:11 <ttt_fff> seems like Cons headElem restStructure should suffice
02:26:12 <lambdabot>      Couldn't match type ‘(Char, [Char])’
02:26:12 <lambdabot>                     with ‘Data.Tagged.Tagged
02:26:12 <lambdabot>                             (p0 (a0, s0) (f0 (b0, t0)) -> p0 s0 (f0 t0))
02:26:17 <Taneb> > _Cons # ('h', "ello")
02:26:19 <lambdabot>  "hello"
02:26:26 <Taneb> I always get that backwards...
02:26:35 <dramforever> > "hello" ^? _Cons -- ttt_fff
02:26:36 <lambdabot>  Just ('h',"ello")
02:26:39 <ttt_fff> > "h" <| "ello"
02:26:41 <lambdabot>      Couldn't match type ‘[Char]’ with ‘Char’
02:26:41 <lambdabot>      arising from a functional dependency between:
02:26:41 <lambdabot>        constraint ‘Cons [Char] [Char] [Char] [Char]’
02:26:56 <ttt_fff> > 'h' <| "ello"
02:26:57 <lambdabot>  "hello"
02:27:14 <chattered> ttt_fff: Source type, dest type, source content type, dest content type?
02:27:37 <dramforever> ttt_fff: I think the 4 params mean that if the container actually isn't a cons, the type can change
02:27:51 <ttt_fff> chattered: can you give an example where this type can actually change?
02:28:15 <dramforever> ttt_fff: that list one is an example
02:28:33 <dramforever> when s is the empty list, we can change its
02:28:41 <dramforever> its type to t without changing contents
02:28:47 <dramforever> i.e. [a] to [b]
02:29:21 <ttt_fff> alright
02:29:30 <ttt_fff> can you explain to me what 'prism' is for?
02:29:56 <chattered> ttt_fff: At least for Lens, you have Lens' which assumes that source and target are the same.
02:31:10 <liste> 'prism' is for making prisms
02:31:20 <dramforever> :k! Prism
02:36:08 <ReinH> ttt_fff: If you expect 'h' <| "ello" to work, you probably don't want Cons
02:36:32 <catofhask> What is the best way to write sequence number generator in haskell?
02:37:03 <liste> catofhask sequence number?
02:37:14 <quchen2_> > take 10 $ unfoldr (\x -> Just (x, 2*x)) 1
02:37:16 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
02:37:34 <ReinH> wait no disregard me
02:37:42 <catofhask> liste: I want to assign incremental sequence number to each request, required for idempotency  machinery 
02:38:11 <ReinH> catofhask: You could, e.g, store an Int64 in an IORef
02:38:27 <ReinH> or any Enum, for that matter
02:38:54 <ReinH> Or just using State, or passed as an argument, depending on your need
02:39:15 <catofhask> ReinH:  I am also in STM already. how about Tvar?
02:39:21 <ReinH> sure
02:39:36 <dramforever> catofhask: that's exactly what I was going to recomment =)
02:39:43 <chattered> > take 10 $ iterate (*2) 1
02:39:44 <dramforever> *recommend
02:39:44 <lambdabot>  [1,2,4,8,16,32,64,128,256,512]
02:39:55 <ReinH> I use an IORef because it's handy in my case.
02:40:27 <dramforever> I put it into my state because I was already using it
02:40:30 <catofhask> dramforever: thanks just wondering about ReinH's suugestion about threading state. I am not sure it will work for parallel requests
02:40:32 <dramforever> using State
02:40:34 <ttt_fff> myCons :: a -> ([a], b) -> ([a], b) -- can someone please write this as a Prism/Cons for me in Lens?
02:40:47 <dramforever> catofhask: I guess STM will work
02:41:37 <dramforever> ttt_fff: 1. that would be an orphan... 2. you also need myUncons :: ([a], b) -> Either ([t], b) (a, ([a], b))
02:41:58 <ttt_fff> dramforever: okay, what would a full minimal example look like?
02:42:03 <dramforever> well by 1 I'm referring to the Cons
02:42:05 <ttt_fff> (not trolling)
02:42:08 <dramforever> wait I have 3.
02:42:08 <ttt_fff> (geniune question)
02:42:26 <dramforever> 3. why don't you just use _1 . _Cons?
02:42:39 <dramforever> oh that's a full minimal example
02:42:59 <dramforever> :t _1 . _Cons :: Prism ([a], x) ([b], x) a b
02:43:01 <lambdabot>     Couldn't match type ‘a1’ with ‘(a1, [a1])’
02:43:01 <lambdabot>       ‘a1’ is a rigid type variable bound by
02:43:01 <lambdabot>            an expression type signature:
02:43:04 <dramforever> sigh
02:43:18 <dramforever> :t _Cons :: Prism [a] [b] a b
02:43:19 <lambdabot>     Couldn't match type ‘a1’ with ‘(a1, [a1])’
02:43:19 <lambdabot>       ‘a1’ is a rigid type variable bound by
02:43:19 <lambdabot>            an expression type signature:
02:43:26 <ttt_fff> I actually want to learn how to write a "Cons typeclass instance"
02:43:28 <ReinH> :t _1 . _Cons
02:43:29 <lambdabot> (Applicative f, Field1 s t a b, Cons a b a1 b1) => ((a1, a) -> f (b1, b)) -> s -> f t
02:43:34 <ttt_fff> except, it loks a bit more involved than "instance Cons ..."
02:43:34 <dramforever> wait what happened
02:43:52 <ReinH> typeclasses, typeclasses everywhere
02:43:55 <dramforever> ttt_fff: yes you need a prism to put into _Cons
02:44:18 <dramforever> and I'll try to figure out what Cons is
02:44:28 <ttt_fff> dramforever: I'm staring at https://hackage.haskell.org/package/lens-4.12.3/docs/src/Control-Lens-Cons.html#%3C%7C
02:44:36 <dramforever> :t _Cons
02:44:37 <lambdabot> (Applicative f, Choice p, Cons s t a b) => p (a, s) (f (b, t)) -> p s (f t)
02:44:43 <dramforever> sigh
02:44:46 <ttt_fff> so there's something about Lens = for product types, Prism = for sum types?
02:45:04 <ttt_fff> i.e. Lens = selecting parts of a produt, Prism = select part of sum type
02:45:15 <dramforever> ttt_fff: well not really, but it's like it
02:45:48 <dramforever> A prism is essentially a Market: http://hackage.haskell.org/package/lens-4.11/docs/Control-Lens-Internal-Prism.html#t:Market
02:46:09 <dramforever> oh I know the problem
02:46:34 <dramforever> :t _1 . _Cons :: Prism ([a], x) ([b], x) (a, ([a], x)) (b, ([b], x))
02:46:35 <lambdabot>     Couldn't match type ‘([a1], x1)’ with ‘[a1]’
02:46:35 <lambdabot>     arising from a functional dependency between:
02:46:35 <lambdabot>       constraint ‘Field1 ([a1], x1) ([b1], x1) ([a1], x1) ([b1], x1)’
02:46:38 <dramforever> failed
02:46:44 <ttt_fff> bottom of https://hackage.haskell.org/package/lens-4.12.3 shows how to write Lens by hand; how can I leanr how to write a Prism by hand?
02:47:26 <dramforever> ttt_fff: by looking at the source code of prism
02:47:49 <Taneb> ttt_fff, the examples on https://hackage.haskell.org/package/lens-4.12.3/docs/Control-Lens-Prism.html at the top
02:47:56 <Taneb> (particularly the "nat" definition)
02:48:03 <Taneb> It might be an idea to ask in #haskell-lens, too
02:49:26 <ttt_fff> Taneb: damn, that was insightful, the int <-> natural example; thanks!
02:49:31 <Taneb> :)
02:54:08 <ttt_fff> why does <| want a prism? can I also pattern match on <| ?
02:54:21 <dramforever> ttt_fff: no
02:54:24 <dramforever> but Cons want a prism
02:54:33 <dramforever> and (<|) uses Cons
02:55:34 <ttt_fff> so a Prism can both combine and take apart; why does <| want a Prism if I can' tpattern match on it? what use does it have for the 'take apart' ability 
02:57:54 <nkaretnikov> is there an analog of 'which' somewhere?  i want to give it a command, and it should print its location
02:58:52 <quchen2_> nkaretnikov: :i gives you the defining module at least.
02:59:14 <nkaretnikov> quchen2_: nah, that's not it
02:59:26 <liste> nkaretnikov a command?
02:59:40 <liste> like a function name?
03:00:01 <nkaretnikov> i want to write 'which "ghci"' and it should give me "/usr/bin/ghci" or something like that
03:00:58 <liste> nkaretnikov so you want a cross-platform Haskell function for that?
03:01:16 <nkaretnikov> ideally, but i can live with linux-only atm
03:02:21 <quchen2_> What's wrong with "which"?
03:02:40 * hackagebot moesocks 0.1.0.10 - moe for all  https://hackage.haskell.org/package/moesocks-0.1.0.10 (JinjingWang)
03:02:41 <nkaretnikov> so do you just recommend to call it from haskell?
03:02:51 <nkaretnikov> i just haven't though of that
03:02:52 <nkaretnikov> t*
03:03:59 <srhb> nkaretnikov: Well, whatever you did has to inspect $PATH anyway, and that's what which does, so why reimplement it.
03:04:54 <nkaretnikov> srhb: no reason really, just didn't occur to me before quchen2_ suggested it
03:04:56 <nkaretnikov> ty
03:05:11 <srhb> OK sure, I was just elaborating on what my motivation for doing that would be. :)
03:05:44 <AshyIsMe> is there a way to turn on all warnings for ghc?
03:05:52 <AshyIsMe> to avoid getting irrefutable pattern errors at runtime?
03:05:56 <srhb> -Wall
03:06:09 <srhb> But note that it's not possible to recognize all possible cases of missing patterns.
03:06:23 <srhb> Eh, irrefutable. Hmm, not sure.
03:06:59 <srhb> Well, same case I guess.
03:07:06 <nkaretnikov> srhb: i seem to recall that not all warnings are actually turned on this way, but i don't remember any details
03:07:18 <quicksilver> irrefutable patterns aren't used that often and generally only when you know why you're doing it
03:07:21 <srhb> Oh, OK. I did not know that.
03:08:05 <srhb> quicksilver: Well, they happen quite easily in let bindings (and bind bindings?)
03:08:33 <quicksilver> true. what would you do? just warn about all of them?
03:09:07 <srhb> It's probably not very useful tbh.
03:09:46 <quicksilver> "...The option -fwarn-incomplete-patterns warns about places where a pattern-match might fail at runtime...."
03:09:57 <quicksilver> "...The warnings that are not enabled by -Wall are -fwarn-incomplete-uni-patterns..."
03:10:11 <quicksilver> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/options-sanity.html
03:10:53 <AshyIsMe> cheers
03:11:33 <nkaretnikov> would the first one work on [Just f] <- ... inside do?
03:12:40 * hackagebot smallcheck-series 0.4 - Extra SmallCheck series and utilities  https://hackage.haskell.org/package/smallcheck-series-0.4 (jdnavarro)
03:13:35 <srhb> nkaretnikov: Does not appear so. Perhaps because of fail?
03:14:18 <quicksilver> it shouldn't, because that doesn't fail at runtime
03:14:25 <quicksilver> it "fail"s at runtime
03:14:31 <quicksilver> hurrah for ambiguity :)
03:14:42 <srhb> Right, that's what I meant. It should be []
03:14:47 <srhb> (f, that is)
03:15:15 <srhb> Er, more correctly the do block should.
03:15:23 <quicksilver> maybe, maybe not
03:15:24 <srhb> How do we even talk about fail. ._.
03:15:27 <quicksilver> you don't know what monad that's in
03:15:27 <srhb> Yeah, types.
03:15:29 <srhb> :P
03:15:36 <srhb> It should be `fail`!
03:17:09 <nkaretnikov> quicksilver: huh? i think it would fail at runtime if ... is [] or [Nothing]
03:17:10 <nkaretnikov> no?
03:17:36 <quicksilver> nkaretnikov: no.
03:17:47 <quicksilver> nkaretnikov: pattern match failure inside a do block has special semantics
03:17:57 <quicksilver> it calls the Monad method `fail`
03:18:37 <nkaretnikov> yes, i know, but can't 'fail' fail at runtime?
03:18:48 <quicksilver> > do { Just x <- [ Just 1, Just 2, Nothing, Nothing, Just 1 ]; return x } :: [Int]
03:18:49 <lambdabot>  [1,2,1]
03:19:00 <quicksilver> it could, but if it does that's a fault in `fail`s design
03:19:04 <quicksilver> it's not because of the pattern match
03:19:25 <quicksilver> the pattern match itself never causes a runtime failure - it has an specific evaluation process which uses `fail`
03:19:56 <nkaretnikov> still a bit confused, but i should probably get to that sometime later
03:53:07 <merijn> nkaretnikov: non-exhaustive patterns in do notation get desugared like so: "do { Foo x <- bar; xyzzy x }" -> "bar >>= \a -> case a of Foo x -> xyzzy x; _ -> fail "incomplete pattern""
03:55:46 <osa1> is hackage down?
03:56:12 <hpc> i have no problem accessing it
03:56:27 <dramforever> up
03:56:43 <osa1> weird, isn't working here.
03:57:03 <hpc> hackage i don't think has distributed hosting, so it's probably an issue with the route you're accessing from?
03:57:38 <hpc> i've had issues like this stemming from verizon making enemies of everyone they peer with, for instance
04:28:14 <Skin> Moisturize me
04:42:49 <hodapp> apparently #haskell is on the target list for the "great freenode flood"...?
04:42:59 <hodapp> somebody is in #emacs now flooding unprintable spam
04:43:13 <hodapp> and changed the topic to mention this channel, among others
04:43:50 <merijn> hodapp: #haskell has been on that list for ages
04:43:51 <domohawk> he probably just hit his ctrl key by accident
04:43:57 <lamefun> On lazy IO leaking file descriptors, does it happen on Windows as well?
04:43:58 <merijn> It's one of the biggest channels on the network
04:44:15 <merijn> lamefun: Yes (well, maybe, depends on the implementation details, but it's likely)
04:44:16 <hodapp> merijn: oh, there's an actual list?
04:45:15 <merijn> hodapp: No, but we get spammers quite frequently and freenode gets DDoS regularly
04:45:51 <mniip> [13:41:47] <domohawk> he probably just hit his ctrl key by accident
04:45:53 <mniip> rofl
04:46:03 <liste> why would people DDoS Freenode?
04:46:15 <hodapp> because butthurt.
04:46:23 <lamefun> How can this be, Windows is proprietary, designed by Microsoft!
04:46:25 <skrio> liste: powertrip?
04:47:11 <liste> it's just hard to imagine Freenode harming anyone
04:47:42 <lamefun> I mean, why is leaking file descriptors to GC a problem in the first place?
04:47:44 * hackagebot manifolds 0.1.3.0 - Working with manifolds in a direct, embedding-free way.  https://hackage.haskell.org/package/manifolds-0.1.3.0 (leftaroundabout)
04:47:45 <hodapp> liste: butthurt knows no boundaries.
04:48:52 <merijn> lamefun: Because your OS limits the number of open file descriptors you can have
04:49:01 <hodapp> As much as I dislike the term 'butthurt' - because people often throw it around to dismiss someone else's feelings after purposely hurting them with intention - I can think of no other term to describe the motives of DDoSing Freenode.
04:49:14 <merijn> lamefun: So if you have long-living servers that don't quickly free their file descriptors you WILL run out and be unable to open files
04:49:44 <lamefun> merijn, why can't garbage-collected programs register themselves with the OS and have OS request garbage collection from them when it's short on descriptors?
04:49:50 <Cale> Not only does the OS limit things like file descriptors and sockets, but the limits are often kind of ridiculously small.
04:49:59 <hodapp> Cale: how ridiculously small?
04:50:21 <merijn> 64k or so in default configs last I checked
04:50:31 <merijn> But that's GLOBAL
04:50:39 <merijn> i.e. no more than 64k open files in total
04:50:45 <merijn> The user limits can be much lower
04:50:46 <skrio> hodapp: my university has something like 150~ per user
04:50:58 <Cale> Yeah, it depends on configuration, but yeah, it can be in the hundreds
04:51:00 <merijn> OSX apparently defaults to max 256
04:51:10 <hodapp> lamefun: do OSes currently have a mechanism to request GC from processes?
04:51:17 <merijn> hodapp: no
04:51:18 <hodapp> lamefun: because if not then I suspect you have an answer.
04:51:19 <dramforever> hodapp: no
04:51:22 <skrio> merijn: serisouly? then some of my code is magic :)
04:51:24 <lamefun> Are there fundamental roadblocks that prevent that, I can't imagine how that isn't implemented in Windows at least...
04:51:56 <dramforever> does windows have this limit?
04:51:59 <dramforever> pretty sure it does
04:52:12 <merijn> dramforever: I'm pretty sure it has *a* limit
04:52:17 <edk> they could gc themselves every time they get an open rejected, i guess
04:52:19 <merijn> Dunno what, though
04:52:35 <dramforever> merijn: oh by "this" I mean # of files
04:52:44 * hackagebot llvm-general-pure 3.3.14.4 - Pure Haskell LLVM functionality (no FFI).  https://hackage.haskell.org/package/llvm-general-pure-3.3.14.4 (BenjaminScarlet)
04:52:46 * hackagebot llvm-general 3.3.14.4 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-general-3.3.14.4 (BenjaminScarlet)
04:52:48 * hackagebot llvm-general-pure 3.4.5.4 - Pure Haskell LLVM functionality (no FFI).  https://hackage.haskell.org/package/llvm-general-pure-3.4.5.4 (BenjaminScarlet)
04:52:50 * hackagebot llvm-general 3.4.5.4 - General purpose LLVM bindings  https://hackage.haskell.org/package/llvm-general-3.4.5.4 (BenjaminScarlet)
04:53:09 <merijn> edk: The problem with lazy IO is that it *can't* GC descriptors until the lazy IO thunk is completely forced
04:53:33 <edk> merijn, right, i was just thinking about what lamefun said
04:54:04 <kuribas> Does lazy IO need compiler magic to work?
04:54:38 <merijn> it uses unsafeInterleaveIO, but that's not really compiler magic
04:55:48 <kuribas> I see
04:56:00 <mniip> technically, whole IO is compiler magic
04:56:07 <merijn> mniip: not really
04:56:18 <mniip> State# is prim
04:56:24 <merijn> IO is implemented in haskell
04:56:36 <dramforever> merijn: as magic
04:56:52 <merijn> dramforever: No, as unboxed state monad
04:57:10 <dramforever> merijn: and one level below that is magic
04:57:22 <dramforever> also s/in haskell/in ghc/
04:57:26 <mniip> yeah but you wouldn't reimplement IO without GHC.Prim.State#
04:57:35 <merijn> Then I disagree with your definition of magic
04:57:44 <dramforever> =)
04:57:44 <mniip> okay
04:57:46 <dramforever> nevermind
04:57:52 <merijn> I consider "compiler magic" to be something different from "the way the compiler generates code for X"
04:58:02 <mniip> whole IO is based on magic then
04:58:06 <merijn> i.e. compiler magic is some sort of special casing behaviour when some feature is detected
04:58:18 <mniip> but yeah
04:58:25 <merijn> Whereas unboxed values and unboxed tuples and functions are just haskell things you can write yourself
04:58:33 <merijn> So any implementation in terms of those aren't magic to me
04:58:52 <mniip> you interrupted me, I was going to say that you can indeed implement your own lazy IO primitives, in slightly extensioned haskell
04:59:32 <merijn> hodapp: FYI, you can check the file limit by running "ulimit -a" which should list the max open files for your user
05:00:22 <mniip> for your current shell *
05:01:53 <mniip> you can setrlimit a program to lower limits, and it well only affect the program's process tree
05:04:05 <lamefun> "*can't* GC descriptors until the lazy IO thunk is completely forced" - it can't? Even if the lazy list / bytestring / etc. is not used anywhere?
05:06:33 <merijn> lamefun: Sure, if the thunk is GCed the descriptor can be to
05:06:49 <merijn> lamefun: But if the thunk is live and not completely evaluated, the descriptor is still live
05:07:27 <broma0> What real tangible benefits do we get from using mtl's type classes?
05:08:26 <rieper> hello, am I at the right place to ask questions about xmobar?
05:08:48 <merijn> broma0: Transformer stack polymorphic code
05:09:05 <merijn> broma0: i.e. you can write code that works inside more than one transformer stack
05:09:05 <lamefun> But what I'm curious about is, why do users of languages with non-deterministic garbage collectors still have to close files manually?
05:09:26 <merijn> lamefun: Because the kernel has a table of data structures representing a process' open files
05:09:31 <dramforever> lamefun: that question is its own answer to me
05:09:39 <merijn> lamefun: You need to inform the kernel it's allowed to throw that data away
05:09:47 <merijn> lamefun: The kernel isn't psychic
05:09:50 <lamefun> dramforever, ie. "because they have?"
05:10:12 <dramforever> lamefun: because they have "non-deterministic garbage collectors"
05:10:19 <merijn> rieper: Maybe, there's an #xmonad channel too, so it depends whether your question is more Haskell or more xmonad :)
05:10:27 <lamefun> merijn, can't kernel just start asking applications to collect garbage in the event of shortage?
05:10:41 <merijn> lamefun: No, because unix doesn't have an interface for that
05:11:31 <merijn> You could implement an OS like that, but it'd be incompatible with everything people use today
05:11:56 <lamefun> Why would it have to be incompatible?
05:12:07 <dramforever> merijn: not really
05:12:29 <dramforever> just, for example, add a signal called SIGGC or something
05:12:40 <Cale> broma0: Personally, I think the classes in mtl are usually the wrong abstraction for most particular monads you might construct, and you're more likely better off writing your own class provided that you want polymorphism.
05:12:58 <merijn> dramforever: Yeah, I just thought of signals, but you'd still have to add support for that in every process/language
05:13:09 <merijn> And signals are their own hairy mess
05:13:12 <dramforever> =)
05:13:13 <Cale> broma0: There are probably some cases where they're exactly the right thing, but I think that's kind of rare. Usually you have a more specific idea about what your operations are.
05:13:57 <merijn> Cale: I use them to get free lifting when writing my code, but that's about it
05:14:10 <merijn> I never write stack polymorphic code, I just think 5 lifts are ugly
05:15:20 <lamefun> And unix, but Windows? I think if it's at all feasible, it would've already been done in Windows. Or contributed to Linux kernel by Google.
05:15:23 <dramforever> merijn: if you need a 5-layered stack then the performance could suck
05:15:29 <rieper> ah, ok, i see: I encounter some issue with the thermalZone plugin of xmobar. As far as I understand it more or less just prints the value at /sys/class/thermal/thermal_zone# My system has .../thermal_zone0 and .../thermal_zone1 and the correct file for getting the temperature changes during reboots for some reason. Therefore, after some reboots, the %thermal% entry is quite useless. so, I was thinking, maybe somebody else could help me in 
05:15:30 <rieper> sorting out what goes wrong here. 
05:15:46 <Cale> I think all lifting should usually be confined to the implementation of some usually smallish number of primitives, and the implementation of the monad in terms of transformers should be hidden behind a module boundary, so usually the multiple lifts shouldn't be too much of an issue, but sure.
05:16:20 <merijn> dramforever: For some value of suck
05:16:27 <merijn> dramforever: Not everything is an innerloop
05:16:31 <dramforever> merijn: also even if you have a big stack you still don't have lift
05:16:38 <merijn> dramforever: And outside the inner loop and almost certainly doesn't matter
05:16:39 <dramforever> *have to lift
05:16:50 <merijn> dramforever: No? Why?
05:16:55 <lamefun> And why would it have to be supported by all languages? Languages that don't support that would keep to free file descriptors manually.
05:17:12 <dramforever> merijn: because the stack has mtl classes instances
05:17:34 <merijn> dramforever: Right, isn't that what I was just saying?
05:17:55 <merijn> dramforever: Cale said "I don't think mtl is very useful" and I said "I actually only use it to avoid having to lift stuff"
05:18:09 <dramforever> oh wait I misunderstood that
05:18:09 <dramforever> sorry
05:27:45 * hackagebot constrained-categories 0.2.1.0 - Constrained clones of the category-theory type classes, using ConstraintKinds.  https://hackage.haskell.org/package/constrained-categories-0.2.1.0 (leftaroundabout)
05:30:36 <Gurkenglas> Has someone worked on automatically finding invariants in code?
05:32:09 <wei2912> Gurkenglas: interesting question
05:32:31 <wei2912> well, i suppose it could work for a limited set of invariants
05:32:45 * hackagebot nurbs 0.1.0.0 - NURBS  https://hackage.haskell.org/package/nurbs-0.1.0.0 (AlexandrRuchkin)
05:33:43 <Gurkenglas> I mean, a simple way would be constructing expressions from the code's namespace and running them through quickcheck. Bruteforce doesn't work on large exponential spaces, but must interesting invariants are not that large
05:33:50 <Gurkenglas> *most
05:36:02 <wei2912> Gurkenglas: it's not just large, it's infinite
05:37:30 <wei2912> and blindly finding invariants is going to take a long time. simple invariants like list is never empty would probably work, but anything more complex like how mergesort only merges sorted arrays will be very hard to find
05:37:57 <wei2912> also, with quickcheck, there is no proof that the invariant holds
05:38:32 <Gurkenglas> It would still find the easy and useful stuff like execState . modify = id, which for example suggests the definition of modfiyT to be a right inverse of execStateT. (Which is the example that led me to ask that question.)
05:39:16 <Gurkenglas> If most of the invariants it suggests are correct, that's already okay, because we can have a human verify the results, finding the invariants to check is the hard-for-humans part.
05:39:41 <wei2912> i'm certain finding the invariants is what humans are supposed to be good at :P
05:40:22 <Gurkenglas> And they aren't, and thus computers can help :D
05:40:37 <wei2912> why would they not be good at it?
05:41:15 <Gurkenglas> They wouldn't find all the invariants and the rest could be found with assistance.
05:41:29 <wei2912> you don't need to find all
05:41:44 <wei2912> and i don't even think you can find all, there're just way too many invariants
05:41:52 <bennofs> I wonder if you can make the QuickCheck part more efficient by using typical fuzzing techniques (like afl-fuzz does for C)
05:41:56 <Gurkenglas> They wouldn't find all the invariants that you'd want to find.
05:42:04 <bennofs> (like trying to cover each part of the code etc)
05:42:22 <bennofs> QuickCheck with fuzzing abilities would be really nice I think
05:42:58 <wei2912> Gurkenglas: how'd the machine know what invariants you're looking for?
05:58:23 <__monty__> I'm stuck on something with an existentialy constrained type variable. This is my problem http://lpaste.net/138137, however that's more complicated than necessary I believe. This is my attempt at better understanding the problem: http://lpaste.net/138191 What I don't understand is how `t' could be too constrained to be some arbitrary type.
06:07:47 * hackagebot constrained-categories 0.2.1.1 - Constrained clones of the category-theory type classes, using ConstraintKinds.  https://hackage.haskell.org/package/constrained-categories-0.2.1.1 (leftaroundabout)
06:08:36 <aweinstock> __monty__: if I'm understanding correctly, ix and iy ignore their arguments, and return a hard-coded type-natural?
06:09:35 <aweinstock> (also, I'm not understanding the difference between Nat and Natty, aren't they the same (except for Natty using GADT syntax)?)
06:12:35 <__monty__> aweinstock: Natty is a singleton type, Zy :: Natty Z, Sy Zy :: Natty (S Z)...
06:13:57 <__monty__> aweinstock: ix and iy return a Fin (10, 7 respectively), but the value of this Fin can be anything from Zf upto (10 or 7).
06:14:35 <__monty__> aweinstock: Actually up to 9 or 6 respectively the upper bound is exclusive.
06:15:27 <__monty__> aweinstock: By using Fin's for indexing I avoid the possibility of writing code that produces an index out of bounds error.
06:19:24 <Fay> man nothing is better than just reading code to gain an intuition about all the concepts :)
06:20:55 <__monty__> Fay: Reading a particularly inspiring piece?
06:25:05 <Fay> __monty__: well this i found was really helpful reading if you have a strong unix background, https://github.com/Gabriel439/Haskell-Turtle-Library
06:25:26 <Fay> __monty__: also ive been reading the code in ghc source
06:35:48 <__monty__> Fay: Thanks, that's going on the  list.
06:36:22 <Fay> you bet.
06:36:25 <joco42> ricree: here is a nice intro to arrows https://m.youtube.com/results?q=arrows%20haskell&sm=3
06:36:34 <joco42> by me :)
06:36:51 <Gurkenglas> wei2912, the shortest ones? In terms of token count.
06:36:56 <joco42> i forgot everything, needed to rewatch it
06:37:59 <Gurkenglas> How come everyone is asking about arrows lately?
06:38:29 <joco42> hxt?
06:38:46 <kuribas> FRP?
06:50:23 <Fay> arent arrows just functions names >>= or >>- or >>+ bla bla ?
06:51:04 <Fay> fancy names for functions?
06:51:38 <__monty__> Fay: https://www.haskell.org/arrows/
06:51:52 <Fay> o
06:51:54 <Fay> oh
06:51:55 <Fay> cool
06:51:57 <Fay> thanks
06:57:08 <nitrix> :t (>>>)
06:57:09 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
06:57:32 * nitrix shivers.
06:58:18 <gryyy> just when i thought i started to kinda get the hang of haskell
06:58:23 <gryyy> you had to do that
06:58:24 <gryyy> :(
06:58:57 <benzrf> muahaha
06:59:02 <benzrf> POLYKINDS ARE COMING FOR YOU
06:59:46 <Cale> :k Category
06:59:47 <lambdabot> (k -> k -> *) -> Constraint
07:02:01 <safinaskar> is the following instance true?
07:02:02 <safinaskar> instance (MonadTrans t, Monad m) => Monad (t m) where
07:02:22 <safinaskar> at least from logic viewpoint?
07:02:37 <quchen2_> Logically yes
07:02:41 <quchen2_> Haskelly no
07:02:43 <__monty__> Cale: Could you explain to me why `t` in, http://lpaste.net/138191, is a rigid type variable?
07:02:49 * hackagebot uhc-util 0.1.6.0 - UHC utilities  https://hackage.haskell.org/package/uhc-util-0.1.6.0 (AtzeDijkstra)
07:03:56 <Cale> __monty__: Only if you were to give me the rest of the file
07:05:39 <nkaretnikov> merijn: ah, so the warning is not triggered due to a catch-all, right?
07:05:46 <Cale> __monty__: Oh, you're trying to unpack an existential again. You can't do that.
07:06:08 <nkaretnikov> merijn: so, is it only about incomplete patterns, like case Nothing of Just v -> ...?
07:06:27 <Luke> looks like I get 7 ghc_worker threads when I run my program. what are all these threads?
07:06:59 <merijn> nkaretnikov: Right
07:07:10 <merijn> nkaretnikov: For example "(x, y) <- foo" is perfectly safe
07:07:26 <nkaretnikov> merijn: got it, thanks for taking the time to read the backlog :)
07:07:30 <merijn> Luke: There's threads for foreign/system calls, event loop, etc.
07:07:46 <merijn> Luke: And worker threads for running forkIO computations
07:07:55 <safinaskar> quchen2_: is this possible to write this instance?
07:08:22 <quchen2_> safinaskar: No, due to the way classes are typechecked
07:08:25 <Luke> merijn: ok those are my forkIO computations. can I name those?
07:09:03 <merijn> Luke: Not all of them are, some threads are (for example) used to block on system calls, handle blocking on IO, etc.
07:09:11 <quchen2_> safinaskar: The typechecker sees your definition and realizes "oh *all* (t m) are Monads". It then later checks the constraints, and finds out that some things of the form (t m) do not have the necessary Monad(Trans) instances, and fails.
07:09:17 <Luke> merijn: I mean name the threads I started
07:09:33 <__monty__> Cale: But what exactly is different between what I'm doing here and what I did in the definition for p? http://lpaste.net/138193
07:09:49 <Luke> merijn: I don't see anything in Control.Concurrent that would allow me to name them
07:10:24 <safinaskar> quchen2_: ok, thanks
07:10:33 <Cale> __monty__: That definition of p which I wrote re-packs the result of the operation into another existential, so we don't need to care which type of thing it is.
07:10:37 <tomqq> i'm losing my mind trying to understand callCC, please please please can someone explain it to me ? :(
07:10:40 <bennofs> Luke: try this: http://hackage.haskell.org/package/base-4.8.1.0/docs/GHC-Conc.html#v:labelThread
07:10:45 <tomqq> I understand continuations pretty well 
07:10:46 <Luke> thanks
07:10:47 <merijn> Luke: What do you mean by "name them"? In your process list, or do you want a way to communicate with a specific thread?
07:10:53 <Luke> merijn: yeah proc list
07:10:59 <Cale> tomqq: Are you familiar with imperative programming at all?
07:11:06 <Luke> bennofs: yeah that's it. thanks
07:11:13 <tomqq> @Cale a bit
07:11:14 <lambdabot> Unknown command, try @list
07:11:22 <tomqq> Cale: a bit
07:11:39 <quchen2_> tomqq: Maybe this helps: https://github.com/quchen/articles/blob/master/cont_monad.md#special-api-function-callcc
07:11:42 <Luke> bennofs: actually maybe not. this looks like it's only available to ghc debugging tools
07:11:45 <__monty__> Cale: So is "Some" a bit like the IO monad in that I can never escape from it?
07:11:52 <Cale> tomqq: One way to think about callCC is that in an imperative language, it's like every procedure definition is implicitly wrapped in callCC (\ret -> ...), and when you write return v, it executes ret v
07:11:59 <Luke> bennofs: i'm looking for it to show in top etc
07:12:20 <Cale> __monty__: I don't have your code any more
07:12:26 <Cale> __monty__: I can't see the definitions of anything
07:12:52 <bennofs> Luke: I got it from here: http://www.well-typed.com/blog/86/
07:12:54 <__monty__> Cale: I put the github link in all the pastes: https://github.com/toonn/haskell-casestt/blob/master/koopa.hs
07:13:00 <bennofs> Luke: maybe it just works?
07:13:11 <Luke> could be an undocumented behavior, yeah
07:13:58 <rola> hi
07:14:16 <rola> how does Data.Text.reverse work https://hackage.haskell.org/package/text-1.2.1.3/docs/src/Data-Text-Internal-Fusion.html#reverse
07:14:29 <tomqq> Cale: specifically, i'm reading tikhon jelvis' explanation on quora where he implements it in js as function callCC(f, done) { f(function (x, done_f) { done(x) }, done) } , please could you explain how this works? 
07:14:54 <Cale> tomqq: nope
07:14:56 <Cale> haha
07:14:58 <tomqq> hah
07:15:06 <Cale> I'm not touching javascript implementations of anything
07:15:34 <Cale> But I can show you an example or two of how it works
07:15:41 <quchen2_> function callCC($f, $done) { $f(function ($x, $done_f) { $done($x) }, $done) -- And now, Cale?
07:15:42 <hpc> that naively translates as callCC = \f done -> f (\x done_f -> done x) done
07:15:59 <hpc> quchen2_: still valid javascript
07:16:15 <Cale> quchen2_: pls
07:16:29 <quchen2_> Pardon the inerruption, I'll show myself out
07:16:52 <Cale> quchen2_: I don't understand how your change would help things at all
07:17:10 <joco42> so say i have a code block that lives in the state monad, then can i *mechanically/automatically* translate that code into an equivalently behaving code with the only difference that i am using "state arrows" instead of state monads? my
07:17:16 <joco42> feeling is yes
07:17:51 <Cale> joco42: You can translate it to code which doesn't use the State monad at all, so...
07:18:18 <Cale> Yes? :)
07:18:29 <joco42> Cale: yes yes... but ..
07:18:44 <joco42> you know what i mean... 
07:19:15 <joco42> have something that is a state monad and arrow at the same time
07:19:57 <joco42> still trying to figure out this arrow concept... how it is different from monads
07:20:51 <Cale> tomqq: import Control.Monad.Cont in ghci and try this:  (`runContT` return) $ do k <- callCC (\ret -> forever $ do n <- liftIO readLn; when (n > 10) (ret n)); liftIO (print k)
07:21:41 <Cale> joco42: Generally things which are arrows will not be monads, because the kind is different
07:22:12 <merijn> joco42: I wouldn't invest too much time, Arrows are quickly losing popularity
07:22:30 <Cale> joco42: But conceptually, Arrow is similar to Applicative/Monad/etc. in that it's just another abstraction of a pattern which shows up in various libraries
07:22:32 <merijn> joco42: Arrows turn out to be equivalent to Applicative + Category which are both more useful typeclasses
07:22:45 <Cale> "equivalent"
07:23:02 <Cale> I'm not sure I totally agree about that, but yeah, kinda.
07:23:15 <Cale> Arrow needs to be reworked, and then it'll be more useful
07:23:27 <joco42> Cale, merijn: hmm... interesting 
07:23:33 <Cale> Maybe once its popularity falls far enough, people won't mind so much replacing it :)
07:23:57 <Cale> A very similar type class based on the definition of a symmetric monoidal category would be quite useful.
07:24:12 <Cale> arr should be in its own class, which would be a subclass of that
07:24:33 <merijn> joco42: Hughes' "Generalising Monads to Arrows" is pretty readable and a good explanation of what/why of arrows
07:25:00 <joco42> so how would you guys model circuits if not with arrows?
07:25:03 <Cale> I also think that Arrows ought to satisfy a law which that paper explicitly disavows, and which would make them not generalise monads
07:25:05 <merijn> joco42: But tbh I've only used Arrow as abusive way of playing with tuples because Bifunctor wasn't in base
07:25:30 <Cale> In particular, it ought to be the case that (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
07:25:32 <merijn> joco42: The Hughes paper uses circuits as example ;)
07:26:21 <Cale> However, the Kleisli arrow for any monad which is not commutative will fail that law, since g and h will execute in the opposite order.
07:26:53 <merijn> joco42: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.437.7504&rep=rep1&type=pdf
07:26:56 <aweinstock> so make that law only hold for "commutative arrows"?
07:27:12 <Cale> I think it's not worth trying to use Arrow in any case where the law fails though, because it makes proc/do-notation hard to understand.
07:27:28 <tomqq> Cale: now I have another problem of understanding what I pasted into ghci :P
07:27:52 <Cale> Breaking that law breaks the "circuit diagram" abstraction for arrows
07:27:55 <nkaretnikov> joco42: i would advise not to measure things only by popularity.  to understand arrows you just need to know which methods a class needs to provide and which laws should hold.  that's valid pretty much for almost every haskell typeclass
07:28:06 <Cale> It all of a sudden matters how you carve your circuit diagram up into pieces
07:28:24 <nkaretnikov> joco42: read the original paper that introduced them to haskell, it's like ~40 pages
07:28:29 <Cale> Whether you chop it vertically or horizontally at any point while turning it into Arrow combinators
07:29:03 <Cale> Which is maybe even worse than what RF electrical engineers have to deal with :D
07:29:22 <joco42> hmm thanks for the points
07:30:49 <nkaretnikov> joco42: there are powerful libs that use them: one for parsing and another one for sql
07:31:03 <nkaretnikov> you might want to check them out
07:31:26 <joco42> nkaretnikov: i am currently trying to use hxt
07:31:34 <joco42> hence my interest in arrowst
07:31:54 <merijn> joco42: To work with HTML/XML?
07:31:59 <nkaretnikov> yes, that's what i meant by parsing
07:32:00 <merijn> joco42: I have a better recommendation :p
07:32:20 <nkaretnikov> merijn: speak up, i'm curious
07:32:30 <merijn> joco42: Try xml-conduit and/or html-conduit I've found both of them rather pleasant to work with and they plug nicely into http-conduit for fetching files
07:32:32 <Cale> joco42: The hilarious thing about HXT is that its Arrow is actually a Monad, and it derives almost no benefit whatsoever from the Arrow abstraction, apart from if you happen to like the Arrow combinator notation.
07:33:05 <merijn> I have an example parallel webscraper I wrote to scrape a webcomic archive a while ago: https://gist.github.com/merijn/d8188ddd129718ffcfb0
07:33:08 <nkaretnikov> hilarious indeed
07:33:09 <joco42> Cale: this is indeed very strange...
07:33:25 <Cale> Very early on, it even was just a monad.
07:33:25 <merijn> Massively parallel webscraper in 78 lines of http-conduit + html-conduit :)
07:33:33 <nitrix> Is there a good article that would explain the `forall` notation?
07:33:39 <merijn> Of which 26 lines are imports :p
07:33:39 <nitrix> :t (>>>)
07:33:40 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
07:33:42 <Cale> I don't really understand what posessed the author to switch to using Arrow notation.
07:33:42 <nitrix> This is killing me.
07:33:59 <merijn> nitrix: forall is a binder for type variables
07:34:17 <joco42> Cale: i thought the *** operator cannot be implemented in Monads but apparently i was wrong
07:34:17 <Cale> nitrix: It's just explicitly introducing type and kind variables
07:34:17 <merijn> nitrix: It's just introducing a bunch of type variables and specifying their kind
07:34:26 <nitrix> merijn: Maybe if you supplement it with a less convoluted example you might manage to explain it to me, but that's just too much.
07:34:33 <merijn> nkaretnikov, joco42: Did you see my link example?
07:34:40 <merijn> nitrix: "id :: forall a . a -> a"
07:35:01 <merijn> nitrix: "forall" introduces a new type variable 'a' and then uses that in the rest of the signature
07:35:20 <joco42> merijn: yes, the Hughes  paper
07:35:20 <nitrix> The "rest" being what's after the dot?
07:35:25 <nkaretnikov> merijn: yep, looks nice. 
07:35:30 <nitrix> id :: a -> a ?
07:35:31 <Cale> joco42: Well, you normally don't have to introduce it, because in the case of a monad, you don't need to explicitly say how all the results are wired along, you bind them to variables using a lambda to the right of (>>=), and then can use them wherever.
07:35:37 <merijn> joco42: No, the scraper using html-conduit for parsing :)
07:35:51 <merijn> joco42: https://gist.github.com/merijn/d8188ddd129718ffcfb0
07:35:57 <merijn> nitrix: Right
07:36:18 <merijn> nitrix: "forall x . x" is similar (in more ways than you'd immediately think) to "\x -> x" on the term level
07:36:24 <nitrix> merijn: So (cat :: k -> k -> *) is a type constructor that takes two types and produces a concrete type?
07:36:26 <joco42> merijn: that is indeed pretty short
07:36:47 <joco42> i am after general xml parsing for evernote
07:36:59 <merijn> nitrix: cat is a type variable that has kind "k -> k -> *" where 'k' is some other kind and '*' as result
07:37:23 <nitrix> BOX -> BOX -> *
07:37:31 <Cale> nitrix: So that says "for all kinds k (of sort BOX, which is redundant for the time being as all kinds have that sort as far as I'm aware), and all types a, b, c of kind k, if cat is an instance of Category, then (>>>) takes values of type cat a b and cat b c, and produces a result of type cat a c
07:37:32 <merijn> joco42: This is using html-conduit, but xml-conduit has a very similar interface for XML documents. It feels very natural to work with if you understand XSLT
07:37:42 <nitrix> Given the previous definitions. Why not write the final form instead of having these very verbose definitions?
07:37:49 <joco42> merijn: thanks for the tip!
07:37:56 <joco42> i check that one out
07:38:03 <merijn> joco42: So if HXT is confusing you, you might wanna look at that :)
07:38:15 <Cale> nitrix: hm?
07:38:29 <Cale> nitrix: Which final form?
07:38:38 <nitrix> It seems to be this could be simplified to:  forall (cat :: BOX -> BOX -> *) (a :: BOX) (b :: BOX) (c :: BOX) . Category .....
07:38:44 <Cale> huh? no.
07:38:45 <merijn> nitrix: No, that's wrong
07:38:45 <nitrix> The `k` thing is weird.
07:38:49 <Cale> BOX isn't a kind
07:38:50 <Cale> It's a sort
07:38:54 <Cale> Which is the sort of all kinds
07:38:54 <merijn> nitrix: BOX is a sort
07:39:11 <nitrix> Is that why it's all in uppercases?
07:39:12 <merijn> nitrix: values have types, and types have kinds, kinds have sorts
07:39:13 <Cale> (there's only one sort for the time being, just BOX)
07:39:23 <joco42> merijn: yes, hxt was confusing me ... for a while until i found this http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-3.xhtml
07:39:25 <Gurkenglas> Has work been done on bruteforce-finding invariants?
07:39:30 <Cale> I don't know what convention future sorts might follow, but maybe.
07:39:30 <nitrix> Cale: I see.
07:39:53 <merijn> Cale: For the time being? We're gonna completely overhaul Haskell into CoC now? :p
07:40:14 <Cale> merijn: Introduce one new type system feature, and people will always find a way to want more.
07:40:21 <merijn> ;)
07:40:42 <joco42> so what is the reason hxt uses arrows?
07:40:54 <nitrix> So, BOX is magic?
07:41:04 <Cale> joco42: No particularly good reason. I suppose the >>> notation sort of works out in a cute way.
07:41:35 <aweinstock> :t (***)
07:41:36 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:41:37 <Cale> nitrix: Yeah, (k :: BOX) is just another way to say "k is a kind" as opposed to leaving any confusion that it might be a type variable.
07:42:05 <Cale> nitrix: Of course, since we immediately have a kind annotation (a :: k) following, it *must* be a kind variable anyway.
07:42:14 <joco42> Cale : this is good to know - maybe this is why the arrows were confusing me... - they are really not needed for anything
07:42:31 <Cale> joco42: Well, the Arrow operations are certainly useful in HXT
07:42:57 <Cale> joco42: But it's not like you get all that much leverage out of the fact that it happens to be an Arrow.
07:42:58 <nitrix> Cale: I appreciate, thanks.
07:43:20 <Cale> joco42: It could just as well have defined the operations in a way which didn't make use of the type class.
07:43:59 <nitrix> Cale: Curiously, how long have you been learning Haskell?
07:44:11 <Cale> nitrix: I started around 2001-2002 or so
07:44:17 <nitrix> Ouch.
07:45:00 <Cale> Yeah, when I first came here, I think there were under 100 people in the channel :)
07:45:10 <merijn> Cale is OLD :p
07:45:11 * merijn ducks
07:45:15 <nitrix> Cale: Well, I'll make it a challenge to catch up to you :P I feel like I've been learning programming wrong from the begining. 
07:45:37 <joco42> Cale: somehow i had the feeling that trees don't have to do much with circuits... and i am kinda relieved that my feeling was somehow correct
07:46:33 <nitrix> All the questions and problems that I've been helping people to solve on ##programming or ##c, it's just... now I'm constantly thinking "this wouldn't have happened if it was written in Haskell" x]
07:47:00 <Cale> nitrix: yeah
07:47:27 <eacameron> nitrix: It's a terrible feeling. Like having a cell phone in 100 AD and not being able to use it... ;)
07:47:48 <joco42> that was some 14 years ago... 
07:48:17 <joco42> wonder where haskell will be 14 years from now
07:48:19 <nitrix> I have a very minimal understanding of type theory so most of the stuff is super overwhelming at the moment.
07:48:34 <hodapp> nitrix: the ability to say that you think you've learned it wrong from the beginning is nonetheless a sign that you're learning
07:48:54 <Cale> I often wonder where some of those people have gone. TheHunter disappeared a long time ago, and I think he still has ops on lambdabot. dons obviously still exists because I see his job postings and stuff, but apparently has no time to IRC.
07:48:58 <nshepperd> hmm, Proxy Int# doesn't seem to be allowed
07:49:15 <hodapp> nitrix: which puts you quite ahead of people who would not consider that possibility
07:49:18 <nshepperd> does BOX exclude unlifted... kinds?
07:49:20 <nitrix> hodapp: You don't know there's better until something raises your awareness :/
07:49:26 <merijn> Cale: Of course, taking pictures of sunsets is time consuming work ;)
07:49:40 <hodapp> nitrix: Not knowing is okay.
07:50:12 <hodapp> nitrix: What's less okay is, upon seeing that knowledge, dusting yourself off and pretending it never happened.
07:50:25 <joco42> i think haskell will be on the web... in 5 years... 
07:50:37 <joco42> like 20%
07:50:38 <aweinstock> joco42: GHCJS already exists
07:50:39 <hodapp> joco42: Eh? It's there already, at Facebook at least.
07:50:52 <joco42> Facebook?
07:50:54 <joco42> client side?
07:51:32 <joco42> frp web
07:51:33 <aweinstock> joco42: I don't think FB does haskell client-side (I remember reading about them using it server-side for malware detection or something)
07:52:02 <hodapp> aweinstock: https://research.facebook.com/publications/251014561758092/there-is-no-fork-an-abstraction-for-efficient-concurrent-and-concise-data-access/
07:52:04 <aweinstock> https://code.facebook.com/posts/745068642270222/fighting-spam-with-haskell/
07:52:14 <joco42> cool
07:52:49 <joco42> i should somehow use my machine learning skills and combine it with haskell...
07:54:02 <aweinstock> joco42: have you seen the blog posts on HLearn?
07:54:39 <joco42> i think yes
07:54:52 <joco42> there is a book about ML in haskell
07:54:58 <aweinstock> https://izbicki.me/blog/hlearns-code-is-shorter-and-clearer-than-wekas.html
07:55:01 <Welkin> HLearn?
07:55:15 <Welkin> oh, a haskell machine learning library?
07:55:39 <__monty__> I'm still trying to figure out how I can solve this or work around it: http://lpaste.net/138191 Seeing as I can't unpack an existential, do I have to return an existentially quantified type? Is there a better way to convert a value of a type to a value of its corresponding singleton type?
07:56:17 <aweinstock> Welkin: a haskell machine learning library that's both very theory-deep and very optimized
07:56:28 <merijn> __monty__: You need to consume it on the right hand side
07:56:39 <__monty__> joco42: That last statement is very confusing out of context. (ML <-> SML)
07:57:22 <aweinstock> Machine Learning vs MetaLanguage
07:57:28 <joco42> machine learning in haskell, __monty__ 
07:58:06 <joco42> http://haskelldata.com/
07:58:28 <merijn> __monty__: When unwrapping an existential you can never return the unwrapped value from that function
07:58:43 <merijn> __monty__: You *can* pass the unwrapped value to another function and return the result of that
07:59:18 <__monty__> merijn: But I can't cheat and have that function be id?
07:59:31 <__monty__> joco42: I saw the context but it still caught me by surpries.
08:00:20 <joco42> :)
08:01:14 <merijn> __monty__: Right, because that leads to "skolem" and "escaping" type variables again
08:05:53 <__monty__> merijn: Is there a way to avoid an existential type when converting a value to the corresponding singleton?
08:09:39 <safinaskar> what is wrong with this code?
08:09:40 <safinaskar> field :: String -> DecsQ
08:09:47 <safinaskar> field s = [d| class $(mkName s) m where method :: m Int |]
08:09:51 <safinaskar> template haskell
08:10:12 <safinaskar> i see this error: Malformed head of type or class declaration: $(mkName s) m
08:12:00 <aweinstock> safinaskar: what's the definition of mkName?
08:12:02 <bennofs> safinaskar: I think mkName returns a variable name. So it cannot be used in that place
08:12:18 <Gurkenglas> Does some library provide a tree structure of the space of typed-hole expressions?
08:12:23 <bennofs> aweinstock: mkName is from TH, isn't it?
08:12:34 <aweinstock> bennofs: should there be a typename in that place instead?
08:12:59 <bennofs> hmm I'll have to look up TH
08:13:52 <safinaskar> aweinstock: mkName :: String -> Name. this is standard function defined in TH header
08:13:59 <bennofs> ok, it's indeed a Name ClassD Cxt Name [TyVarBndr] [FunDep] [Dec]
08:14:15 <safinaskar> bennofs: okey, so what i should use in this place?
08:14:16 <aweinstock> ClassD's second parameter is a Name, so that looks right
08:14:18 <albeit> If I have (f . g . h), is there any way to have it applied in the reverse order, without re-writing the function order? I want the effec tto be (h . g . f)
08:14:38 <aweinstock> safinaskar: try building a ClassD explicitly, rather than using a [d||] quoter?
08:14:55 <bennofs> aweinstock, safinaskar: maybe splicing at that place is just not allowed? 
08:15:11 <hpc> albeit: define some operator = flip (.), and use that
08:15:27 <slack1256> or use >>> from Control.Category
08:15:28 <bennofs> :t (&)
08:15:30 <lambdabot> a -> (a -> b) -> b
08:15:40 <bennofs> oh, flip (.) not flip ($)
08:15:41 <Gurkenglas> (I want to generate as many of the shortest boolean expressions that enter the namespace by importing a module as my computer can deal with, filter that list through quickcheck, apply that to some commonly used libraries, and see what I get)
08:15:50 <albeit> :t (>>>)
08:15:51 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (a :: k) (b :: k) (c :: k). Category cat => cat a b -> cat b c -> cat a c
08:16:00 <bennofs> :t (>>>) `asAppliedTo` id
08:16:01 <lambdabot> (b -> b) -> (b -> c) -> b -> c
08:16:21 <safinaskar> aweinstock: thanks, i will try
08:16:27 <bennofs> :t (>>>) `asAppliedTo` flip const undefined 
08:16:28 <lambdabot> (b -> b) -> (b -> c) -> b -> c
08:16:31 <slack1256> :t asAppliedTo
08:16:32 <lambdabot> (a -> b) -> a -> a -> b
08:16:33 <bennofs> :t (>>>) `asAppliedTo` const undefined 
08:16:34 <lambdabot> (a -> b) -> (b -> c) -> a -> c
08:16:34 <safinaskar> but still i want to know how to do this using [||]
08:17:04 <bennofs> safinaskar: it could be that it's just not possible to do using [||]
08:21:58 <humanoyd> If you start new projects in Haskell, do you import Data.Monoid (mempty, append) for older GHC versions or do you prefer to keep your code clean?
08:23:12 <bennofs> humanoyd: depends on if you write an application or a library
08:23:28 <bennofs> for an application, I write code using the latest GHC version only
08:23:52 <bennofs> for libraries, I write code trying to be portable to older versions of GHC as well (as long as possible without CPP or very ugly hacks)
08:27:42 <Gurkenglas> Where is IO's MonadPlus instance defined?
08:28:20 <Gurkenglas> (How would I ask ghci that?)
08:29:01 <supki> :i IO
08:29:51 <Gurkenglas> That tells me where IO is defined, and its Functor and Monad instances.
08:30:01 <hvr> does IO even have a MonadPlus instance?
08:30:07 <Gurkenglas> @instances MonadPlus
08:30:10 <lambdabot> Alt f, Either e, IO, Maybe, MaybeT m, Seq.Seq, []
08:30:12 <beckyconning_> https://gist.github.com/beckyconning/1f20dacdd98f7537eaab
08:30:21 <beckyconning_> why doesn't shouldAlsoBeId type check?
08:30:29 <Gurkenglas> ...no MonadPlus instance of IO on my ghci.
08:30:46 <beckyconning_> have i implemented lensToLensL incorrectly?
08:31:04 <hvr> Gurkenglas: I don't remember having seen any MonadPlus IO instance in base
08:31:13 <supki> hvr: yeah, it's defined in transformers
08:31:14 <bennofs> > print 3 <|> mempty
08:31:16 <lambdabot>      No instance for (Monoid (IO ())) arising from a use of ‘mempty’
08:31:16 <lambdabot>      In the second argument of ‘(<|>)’, namely ‘mempty’
08:31:16 <lambdabot>      In the expression: print 3 <|> mempty
08:31:22 <bennofs> > print 3 <|> mzero
08:31:23 <lambdabot>  <IO ()>
08:31:43 <vlatkoB> Monad is StateT S (LoggingT m). Inside "liftIO . runEitherT" block, is there a way to "unlift" to run logInfoN?
08:31:54 <hvr> supki: this reminds me of https://ghc.haskell.org/trac/ghc/ticket/9588
08:32:07 <hvr> we did want to move those into base
08:32:37 <Gurkenglas> vlatkoB, use fmap?
08:32:54 <Gurkenglas> (Or liftM, if that's more to your taste
08:32:56 <Gurkenglas> *)
08:33:36 <Gurkenglas> Wait, no, that'd go down through the whole monad. hmm.
08:35:22 <vlatkoB> Yes, should go the other way, unlift.
08:35:55 <Gurkenglas> (What liftM lifts is a function between the underlying types to the monad-wrapped types.)
08:37:56 <ttt_fff> is there a good name for ([a], b) -- it's basially like a list, but the last element ahs a different type
08:38:04 <supki> hvr: it should probably be mentioned somewhere that neither satisfies the  x >> mzero = mzero  law
08:38:43 <Welkin> ttt_fff: a pair of [a] and b
08:38:59 <ttt_fff> Imgoing to call it Mist
08:39:10 <ttt_fff> data Mist a b = MistNil b | MistCons a (Mist a b)
08:39:11 <Welkin> Misty
08:39:14 <Welkin> like in pokemon
08:39:30 <ttt_fff> no no, I'm not interested in underage anime girls
08:39:59 <ttt_fff> is there a way to overload [] and : to work on my Mist datatype ?
08:40:24 <Welkin> ttt_fff: you don't have an empty constructor
08:40:29 <ttt_fff> true
08:40:44 <ttt_fff> but I'd still like to use a:(Mist a b), and [b], and [a1, a2, a3, b]
08:41:14 <Gurkenglas> vlatkoB, The question you are asking is: Is there a MonadLogger m such that I can turn m () (the result of logInfoN) into an EitherT a IO b (the argument of liftIO . runEitherT). Right?
08:43:55 <quicksilver> no, the list overloading stuff still requires the types to all be the same
08:44:02 <quicksilver> it uses normal lists in its desugaring
08:44:08 <Gurkenglas> (I like how concise your question is, btw. It does make me have to confirm the intent of your question, though. lpaste.net can help providing context.)
08:44:13 <quicksilver> overloading's nasty anyway :P
08:44:16 <vlatkoB> Gurkenglas: Yes, that should be the question
08:46:11 <__monty__> Is there a way of converting a value of a certain type to a value of the corresponding singleton type? For example for Nat and Natty? http://lpaste.net/138205
08:46:14 <Gurkenglas> vlatkoB, a is irrelevant as it is only required for another part of that block, and b is () since you aren't planning to extract it with a <-. Right?
08:46:30 <ttt_fff> shit, there's something claled MonadLogger? I thought I was creative in creating a typeclass myself
08:47:54 <vlatkoB> Gurkenglas: Yes, correct. I'm setting logging in working function and am stuck there. I'll lpaste in a minute
08:48:19 <Gurkenglas> vlatkoB, no need now, I'm almost there :D
08:49:43 <humanoyd> bennofs: thx
08:49:43 <Gurkenglas> That reduces the question to "Does IO have a MonadLogger instance." You're either going to log via IO or not at all. If you want that, you can ask ghci to see whether IO has such an instance, I think.
08:50:32 <hpc> what would MonadLogger for IO do?
08:50:35 <Gurkenglas> vlatkoB, if you want to log from inside the do block into a LoggerT, you'll need to include LoggerT in the block's type signature.
08:50:37 <ttt_fff> is there somethign like ":i" but "search in all modules in my project" rather than just "search the modules I have imported" ?
08:50:38 <hpc> output to stderr?
08:50:50 <ttt_fff> I don't want it to strat search system libraries, but all the *.hs files in my current directory I'd like it to search
08:50:51 <vlatkoB> Gurkenglas: It doesn't exist
08:51:08 <Gurkenglas> (Which doesn't mean you need to write a type signature, just that you'll have to modify the "liftIO . runEitherT")
08:52:52 * hackagebot json-schema 0.7.4.0 - Types and type classes for defining JSON schemas.  https://hackage.haskell.org/package/json-schema-0.7.4.0 (AdamBergmark)
08:53:14 <Gurkenglas> Really? Weird. I'd think "curry4 print" would make a nice monadLoggerLog for IO.
08:53:34 <vlatkoB> Gurkenglas: I can do it with runStdoutLoggingT . logInfoN "", but that means fixed runXXX. That's why I wanted "unlift" to return to the monad I'm in.
08:54:05 <vlatkoB> $
08:54:55 <bennofs> There could be something to "capture" all that LoggingT needs in the LoggingT transformer and then use "run" function in the IO block 
08:54:58 <Gurkenglas> vlatkoB, "fixed runXXX"?
08:55:54 <bennofs> vlatkoB: I think you want: askLoggerIO :: m (Loc -> LogSource -> LogLevel -> LogStr -> IO ()) 
08:56:08 <vlatkoB> I meant other runXXXLoggingT, as in Stderr etc. I'm running the monad fromo outside
08:57:53 * hackagebot json-rpc 0.6.0.0 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.6.0.0 (XenoGenesis)
08:59:22 <bennofs> vlatkoB: you can do: do  run <- askLoggerIO; liftIO . runEitherT $ do liftIO (runLoggingT run $ ...); ... 
08:59:54 <bennofs> vlatkoB: see http://hackage.haskell.org/package/monad-logger-0.3.13.2/docs/Control-Monad-Logger.html#t:MonadLoggerIO
09:01:24 <Gurkenglas> (Oh that looks nastily spaghettifying and damn convenient.)
09:02:35 <vlatkoB> Yes, indeed :-) I'll try it to see it in action. Thanks guys
09:06:05 <beckyconning_> how do i add the functor restraint back into this so that shouldAlsoBeId will typecheck? https://gist.github.com/beckyconning/1f20dacdd98f7537eaab#file-main-hs-L42
09:09:39 <gatlin> I have a curious data structure I want to implement and it touches on some more advanced Haskell topics that I'm not familiar with.
09:10:25 <gatlin> It's called a powerlist - list must have 2^n, n >= 0 elements in it. You can either construct a singleton, append one to another, or interleave them.
09:11:00 <gatlin> I want to encode the length in the type and this is what I have so far: https://gist.github.com/gatlin/ecd758394d17b60287fe
09:11:06 <gatlin> just curious if there's a better way
09:11:27 <Gurkenglas> I am reminded of https://hackage.haskell.org/package/fixed-vector
09:12:30 <gatlin> yes, that was definitely an inspiration, and quite educational!
09:13:59 <gatlin> The paper defining the structure makes heavy use of ML-ish syntax and pattern matches on the constructors. So right now I have the two constructors but they only make a difference when you convert the final list to some other form. So this is more a DSL for doing powerlist operations than an actual data structure.
09:16:04 <bennofs> data PowerList a = Single a | Double (PowerList (a,a)) always has 2^n elements
09:16:36 <bennofs> or hmm, maybe not. sorry
09:17:22 <bennofs> hmm, that thought was incorrect. yes, it should have 2^n elements
09:17:34 <aweinstock> gatlin: both interleave and append require the same length lists as both arguments, and the output has length 2^(n+1), what else needs to be distinguished?
09:18:19 <Gurkenglas> gatlin, I don't think the two threeliners of your Foldable instance agree with each other.
09:18:53 <gatlin> Gurkenglas: yeah it's wonky because really I just wanted to write toList especially
09:19:00 <aweinstock> "4 `interleave` 2" and "4 `append` 2" both would have 6 elements (not a power of 2), hence the requirement that both operands have size 2^n
09:19:50 <Gurkenglas> Just so I know I'm not missing how toList agrees with the default implementation :P
09:22:19 <Gurkenglas> data PowerList a = Single a | Double (PowerList (a,a)) would lead to exponentially long type names. I recommend data Pair a = Pair a a, or newtype Pair = {runPair :: (a, a)}.
09:22:21 <gatlin> aweinstock: this current implementation seems to keep lists from violating the length rule. I'm curious if there is a way to actually have the :%: constructor interleave the elements
09:23:04 <gatlin> my hunch is no, and this should remain some kind of a DSL for building lists and writing algorithms a certain way, but hey GHC has surprised me before
09:25:05 <aweinstock> gatlin: what would it even mean to have (:%:) interleave the lists? they are semantically interleaved if the only interpreter for (:%:) treats it as an interleave operation
09:25:14 <Gurkenglas> Does bennof's construction with any Functor substituted for Pair have a name?
09:25:46 <bennofs> Gurkenglas: Looks a bit like Free?
09:25:47 <aweinstock> (maybe if you implement map/fold directly over them? but that'd still be just another interpreter)
09:26:01 <Gurkenglas> Yea, I thought so too, but it's the wrong way round
09:26:26 <Gurkenglas> No, not that wrong way round.
09:26:36 <bennofs> data X a = End a | Push (X (f a)) 
09:26:45 <quicksilver> bennofs: you need something like PowerList a N = Single a | Double (PowerList a pred_N) (PowerList a pred_N)
09:27:38 <bennofs> quicksilver: That is different from my type 
09:27:50 <quicksilver> yes
09:28:16 <quicksilver> oh, right,
09:28:20 <quicksilver> your one does work ;)
09:28:26 <gatlin> aweinstock: you're right, if the only evaluator handles the semantics correctly then all is well. What do you mean by "implement map/fold directly over them" ?
09:28:30 <bennofs> Gurkenglas: reminds me of http://www.twanvl.nl/blog/haskell/non-regular1
09:28:35 * quicksilver apologises
09:29:09 <bennofs> Gurkenglas: various variants of that non-regular data type can be found in lens
09:29:38 <aweinstock> gatlin: it looks like you're already doing that (instance Foldable (PowerList n))
09:30:04 <gatlin> aweinstock: ah, thanks for clarifying
09:31:35 <gatlin> Gurkenglas: how do you think I should go about writing foldMap / foldr?
09:31:35 <bennofs> gatlin: maybe there is some way to construct it using Cofree?
09:32:24 <gatlin> bennofs: maybe, though there does have to be a singleton case which is essentially the free monad Pure constructor
09:33:33 <Gurkenglas> gatlin, foldMap (x :%: y) has nothing to do with foldMap x or foldMap y. You won't be able to use those. Unfortunately, the works-for-all-cases way seems to me to be to go via toList, barring infinities, hmm.
09:34:19 <gatlin> Gurkenglas: you're right. I suppose I should just derive Foldable automatically and then choose a name other than `toList` for my function converting to a list
09:36:06 <Gurkenglas> I don't think you should derive Foldable automatically if toList isn't going to be right. Better have foldMap go via toList.
09:36:36 * gatlin facepalms at himself
09:36:40 <Gurkenglas> (Oh, and there is only one infinite powerlist, shared by all a, so all is well.)
09:38:47 <Gurkenglas> ...actually, foldMap f (x :%: y) = foldmap f (zipWith mappend x y) sounds good. You'll have to implement zipWith, of course.
09:39:17 <gatlin> I just updated the gist with the extraordinarily lazy implementation "foldMap f pl = foldMap f (toList pl)"
09:39:18 <Gurkenglas> The logic behind it at the end is going to be the same as for toList, but going this way might unlock some insights.
09:39:29 <gatlin> Gurkenglas: thank you!
09:39:39 <Gurkenglas> @pl No, the other wrong way round.
09:39:39 <lambdabot> (line 1, column 3):
09:39:39 <lambdabot> unexpected ','
09:39:39 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
09:39:58 <Gurkenglas> Damn hexchat and its unconventional copy hotkey.
09:40:03 <vlatkoB> Gurkenglas: bennofs: If anyone was following, after getting "run", it is just -- liftIO $ run defaultLoc "MyFunc" LevelDebug "Message"
09:41:09 <Gurkenglas> vlatkoB, I had misledly collapsed the question "Is there a MonadLooper that can be turned into IO ()" into "Is IO a MonadLooper".
09:41:34 <bennofs> vlatkoB: you can do that, too. If you want to use the usual logger functions, you can also do liftIO $ runLoggingT run $ ... use usually logging functions here ... 
09:41:44 <Gurkenglas> @pl \f pl -> foldMap f (toList pl)
09:41:44 <lambdabot> (. toList) . foldMap
09:42:14 <gatlin> that seems ... pointless
09:42:35 <gatlin> >_>
09:42:37 <Welkin> point-FREE
09:43:09 <Gurkenglas> I feel that Haskell is missing some minor bit of syntax that would make all the pointfree stuff much nicer.
09:43:25 <liste> Gurkenglas like APL/J/K?
09:43:26 <bennofs> Gurkenglas: isn't that just foldMap f pl? Or isn't that toList from Foldable?
09:43:47 <Gurkenglas> bennofs, nope, he implements it himself
09:44:00 <Gurkenglas> (\f -> foldMap f . toList is a compromise.)
09:44:08 <bennofs> Gurkenglas: you're looking for: Concatenative programming!
09:44:27 <bennofs> [not Haskell though]
09:45:02 <Ralith> couldn't you write a decent concatenative programming monad
09:45:53 <Twey> Gurkenglas: Sometimes I wish for APL/Clojure-style implicit lambdas, #(foldMap %1 (toList %2))
09:46:13 <Twey> Ralith: You don't need a monad.  It's a category
09:46:56 <Gurkenglas> Aw man, you've found something that I don't like that I can't dismiss with "But now I have to invent names!" :/
09:46:57 <Twey> Ralith: The only thing that stops it being normal function composition is the magic nature of Haskell tuples
09:47:25 <vlatkoB> bennofs: You mean like liftIO $ runLoggingT run $ logInfoN "". This doesn't compile. run requires 4 args
09:47:44 <Twey> Gurkenglas: Hehe
09:47:58 <Twey> Gurkenglas: It does rather feel like a syntactic solution to a semantic problem
09:48:06 <Twey> Hence only ‘sometimes’
09:48:54 <Twey> Ralith: I guess a monoidal category, actually.  Not sure what one of those looks like in Haskell
09:48:58 <bennofs> vlatkoB: it looks like it should compile to me: askLoggerIO :: m (Loc -> LogSource -> LogLevel -> LogStr -> IO ())  and runLoggingT :: (Loc -> LogSource -> LogLevel -> LogStr -> IO ()) -> m a
09:49:05 <bennofs> vlatkoB: [taken from haddocks]
09:51:31 <Gurkenglas> How would higher-order functions look like in concatenative programming?
10:08:56 <Twey> Gurkenglas: (,) ∷ a → b → (a, b)
10:09:57 <Twey> Gurkenglas: And uncurry id ∷ (a → b, a) → b
10:10:47 <Twey> Gurkenglas: The former gives you Factor-like quotations, and the latter gives you an application operator
10:15:09 <broma0> How can I avoid writing out a ton of constraints when using mtl's classes? Can I make a type synonym for a collection of constraints? Something like "typeconatrwint X m = (This m, That m, Other m)"
10:15:33 <sdegutis> What's this syntax called (if anything)?  (< x)
10:16:03 <Taneb> sdegutis, a section
10:16:05 <xevz> Anyone here using Vim? I currently use vim2hs but I think the indentation is kinda wonky.
10:16:16 <tommd> Yes
10:16:25 <sdegutis> Taneb: Thank you! 10 minutes of googling couldn't figure that out, and you helped me in 10 seconds!
10:16:31 <Taneb> :)
10:16:46 <sdegutis> xevz: I use Emacs sorry. The indentation mode I found isn't great but it's good enough.
10:16:50 <Twey> broma0: Yes, you can write ‘type X m = (This m, That m, Other m)’, maybe only with ConstraintKinds
10:17:09 <tommd> xevz: Use elliottt's vim config
10:17:19 <broma0> That's exactly it
10:17:21 <tommd> Which, btw, uses vim2hs
10:17:24 <broma0> Thank you
10:17:56 <Twey> broma0: Without ConstraintKinds you can write ‘class (This m, That m, Other m) ⇒ X m’ and ‘instance (This m, That m, Other m) ⇒ X m’, maybe with FlexibleContexts/FlexibleInstances
10:18:10 <tommd> Eliel: Or maybe not anymore it seems.
10:18:25 <tommd> err, sorry Eliel, I ment xevz.
10:18:50 <broma0> Ah I see. Is ConstraintKinds widely used?
10:20:42 <xevz> tommd: I'll give it a try. :)
10:20:46 <xevz> Thanks
10:21:57 <sdegutis> What's the rule of thumb for knowing when a function can be called using infix notation without backticks? Is it just if it only includes non-alphanumeric characters then it's always infix (by default)?
10:22:44 <Twey> broma0: All of those extensions are non-controversial, but not standard Haskell
10:22:45 <kuribas> sdegutis: you cannot mix alphanumeric with non-alphanumeric.
10:22:51 <mniip> sdegutis, sec
10:22:51 <kuribas> sdegutis: otherwise yes.
10:22:51 <Twey> (yet)
10:22:56 * hackagebot github-backup 1.20150807 - backs up everything github knows about a repository, to the repository  https://hackage.haskell.org/package/github-backup-1.20150807 (JoeyHess)
10:23:19 <Intolerable> kuribas: valid_identifier_name'
10:23:23 <Intolerable> ;)
10:23:29 <mniip> sdegutis, basically what they said, if it's symbolic, it's infix
10:23:43 <mniip> if it's alphanumunderscoreprime-ic, it's prefix
10:23:44 <kuribas> Intolerable, sdegutis: right, except for ' and _
10:24:07 <sdegutis> kuribas: what are those?
10:24:32 <kuribas> sdegutis: characters that can be part of an alphanumeric identifier.
10:24:49 <kuribas> sdegutis: like my_function'
10:24:52 <mniip> alphanumerics can be enclosed in ` ` to become infix, and infix forms (incl backticked), can form operator sections
10:24:55 <Intolerable> [a-z][a-zA-Z0-9'_]*
10:25:40 <tommd> > let don't _ = return () in don't $ print "hello!"
10:25:41 <lambdabot>      No instance for (Show (m0 ()))
10:25:41 <lambdabot>        arising from a use of ‘show_M267547595366725280727176’
10:25:41 <lambdabot>      The type variable ‘m0’ is ambiguous
10:25:56 <Intolerable> > let don't _ = return () in don't $ print "hello!" :: IO ()
10:25:57 <lambdabot>  <IO ()>
10:26:14 <Intolerable> @hackage acme-dont
10:26:15 <lambdabot> http://hackage.haskell.org/package/acme-dont
10:26:17 <tommd> Yep
10:26:38 <sdegutis> Twey: we'll be able to soon?
10:26:43 <sdegutis> mniip: thanks old chum
10:27:10 <kuribas> let can't a = error "I'm sorry Dave, I'm afraid I can't do that!" in can't (1+1)
10:27:17 <kuribas> > let can't a = error "I'm sorry Dave, I'm afraid I can't do that!" in can't (1+1)
10:27:18 <lambdabot>  *Exception: I'm sorry Dave, I'm afraid I can't do that!
10:27:20 <mniip> there's also the thing that a capital letter designates a datacon
10:27:32 <mniip> as well as a colon, in symbol form
10:27:41 <sdegutis> Is there a special case for _ when it's the sole character in an identifier, such that it can't be reused and is thus kind of like /dev/null?
10:27:47 <sdegutis> Or can you just call stuff _ and reference _ later?
10:27:54 <mniip> no
10:28:09 <sdegutis> Sorry I shouldn't have asked a true/false question in both directions thus introducing ambiguity.
10:28:10 <mniip> _ is a special case in patter syntax
10:28:16 <mniip> unless you are talking about black holes
10:28:19 <Twey> sdegutis: Be able to what?
10:28:32 <Intolerable> _ as a pattern is a "ignore this"
10:28:37 <Intolerable> _ in a signature is a type hole
10:28:43 <kuribas> sdegutis: _ will not be bound to anything.
10:28:53 <ttt_fff> is there a way in vim + hdevtools + syntastic, to have :w (1) not only check current file, but (2) also check entir eproject
10:28:54 <sdegutis> Twey: oh sorry I thought you were responding to what kuribas said just before you said (yet)
10:28:55 <Intolerable> _ in an expression body is a "i don't know what i'm putting in here yet"
10:28:59 <sdegutis> Twey: I understand now that you weren't.
10:29:06 <Intolerable> "compiler please save me"
10:29:24 <mniip> any identifiers beginning with _ that are not in scope, are blackholes
10:30:00 <mniip> they infer the type of the surrounding environment, and at the end of typechecking, they error their respective inferred types out
10:30:14 <kuribas> mniip: only with the extension on, right?
10:30:22 <mniip> > fmap show (_ + 3)
10:30:24 <lambdabot>      Found hole ‘_’ with type: f a0
10:30:24 <lambdabot>      Where: ‘a0’ is an ambiguous type variable
10:30:24 <lambdabot>             ‘f’ is a rigid type variable bound by
10:30:25 <Twey> sdegutis: Oh, no, no plans for that AFAIK.
10:30:34 <Twey> sdegutis: Unless you want to switch to Agda. :þ
10:30:34 <Intolerable> 7.10 does it by default, no?
10:30:37 <sdegutis> :D
10:31:01 <Twey> It would require mandatory spacing, which would be a pretty big syntax change.
10:31:01 <sdegutis> mniip: very cool
10:31:17 <sdegutis> :t (<2)
10:31:18 <lambdabot> (Num a, Ord a) => a -> Bool
10:32:01 <sdegutis> I've heard many bad things about Haskell's "Numeric Tower" (I assume this means hierarchy of numerical types). Is this still a problem? If so, how problematic and/or troublesome and/or irritating is it?
10:32:10 <kuribas> And when in scope, unused variable warnings are suppressed for _identifier.
10:32:34 <mniip> sdegutis, depends on how often you deal with numbers
10:32:36 <Twey> sdegutis: It's a bit wonky and designed from practicality rather than principles, but it's rarely a problem in practice (IME)
10:32:48 <mniip> and in what way
10:32:48 <Twey> Admittedly I don't do much computer algebra
10:33:06 <roboguy_> kuribas: no extension needed since ghc 7.8 (7.7 needed an extension)
10:33:08 <Twey> sdegutis: It's not magical, though: you can write your own tower if you want
10:33:13 <sdegutis> I mostly use numbers for the things you'd use numbers for in an online store web app.
10:33:16 <kuribas> roboguy_: ok, nice!
10:33:19 <Twey> And there are a couple of alternative ones on Hackage
10:33:21 <mniip> if you do physical-mathematical computation, with a mix of datatypes (Double, Integer, Int), it hurts
10:33:35 <sdegutis> mniip: due to many conversions and their rules?
10:33:40 <sdegutis> *explicit conversions
10:33:44 <mniip> rules?
10:33:51 <mniip> if they're explicit, there are no rules
10:34:22 <mniip> should've probably worded that better
10:35:17 <Zemyla> What is the biggest problem Haskell programmers have with Haskell?
10:35:32 <roboguy_> I don't know that I've ever used more than fromIntegral, ceiling and floor
10:35:38 <Zemyla> I mean, o
10:35:58 <johnw> Zemyla: do you mean the language, GHC, the community, the job market?
10:37:05 <Zemyla> *for me, it's the proliferation of typeclasses and types, so if you have a type from library X and a typeclass from library Y, ypu need to write the code making the type an instance of the typeclass yourself.
10:38:01 <mniip> Zemyla, instances are a problem, right
10:38:02 <roboguy_> Zemyla: that's something that ideally shouldn't happen (orphan instances), with good design and cooperation
10:38:58 <Zemyla> Though it's a minor problem. I'm wondering if anyone has any more systemic problems with anything besodes the job market.
10:39:14 <mniip> if you have edwardk's package x defining some fancy class, and an unrelated package y defining a fancy datatype, that has no relation to x whatsoever, but is an instance of x's typeclass
10:40:10 <Twey> Zemyla: This is helped somewhat by Generic
10:40:20 <Twey> Zemyla: But having instances be second-class citizens isn't great
10:43:10 <nitrix> Zemyla: I think the other way around would be impractical.
10:43:39 <nitrix> So while it isn't perfect, it just re-inforces the goal of generalizing those as much as possible.
10:47:27 <Luke> ocharles__: you around?
10:48:40 <ttt_fff> is there a haskell syntatcit extension that lets me use both alphanumeric chars and symbols in a literl's name?
10:48:47 <ttt_fff> i.e. I really want a var named foo->
10:48:52 <Intolerable> no
10:49:33 <ttt_fff> that is an intolerable limitation
10:49:35 <ttt_fff> ba da bum
10:49:54 <ttt_fff> is this because haskell's infix notation allows separation of ops from vars without spaces?
10:50:04 <ttt_fff> i.e. foo** ... is this "foo **" or a single literal "foo**"
10:50:10 <arkeet> that is a justification yes
10:50:26 <shachaf> arkeet++
10:51:29 <Gurkenglas> <johnw> Gurkenglas: how is runMaybeT . msum . map MaybeT different from just msum? <- the left gets the first Just value, the right executes all, discards values and exceptions from the init and returns the last.
10:51:43 <shachaf> "because" questions leave me dazed and confused until I remember that they're probably wrong.
10:52:13 <ttt_fff> shachaf: is it because you have to scan up to read the original question?
10:52:21 <arkeet> :t runMaybeT . msum . map MaybeT
10:52:22 <lambdabot> Monad m => [m (Maybe a)] -> m (Maybe a)
10:52:28 <shachaf> No, it's because there's no answer.
10:52:36 <ttt_fff> lass Subst lhs pat rhs | lhs pat -> rhs where   (/->) :: lhs →  pat →  rhs
10:52:44 <ttt_fff> class Subst lhs pat rhs | lhs pat -> rhs where   (/->) :: lhs →  pat →  rhs
10:53:00 <ttt_fff> what symbolsshould I use for class SubstM lhs m rhs | lhs -> m rhs .... ?
10:54:08 <Gurkenglas> (johnw, see http://hackage.haskell.org/package/mtl-1.1.1.0/docs/src/Control-Monad-Error.html#line-71 )
10:55:18 <ttt_fff> https://gist.github.com/anonymous/9f2aae4ebf9b8f453c4e <-- PLS HALP
10:55:41 <arkeet> I mean the literal reason is that no one has written such an extension.
10:56:43 <Gurkenglas> ttt_fff, sections work on the value level, not the type level
10:56:59 <ttt_fff> Gurkenglas: okay, that makes sense
10:57:10 <Gurkenglas> (Because you can't apply the second type argument first)
10:57:12 <ttt_fff> arkeet: the literal reason is "because GHC *.hs files says its not allowed"
11:01:36 <Zemyla> :t Data.Coerce.coerce `asTypeOf` map MaybeT
11:01:37 <lambdabot> [m (Maybe a)] -> [MaybeT m a]
11:02:52 <Twey> Gurkenglas: http://lpaste.net/138209
11:03:00 <dquarks> :P
11:03:43 <duckbob> is there a way to send a https post without using any of the yesod framework. i can write the form data with my own methods, i just need a way to post the data to a url and recieve the response as a string or bytestring
11:04:00 <duckbob> with https support
11:04:12 <Twey> duckbob: wreq?
11:04:15 <creichert>  wreq or http-client
11:04:28 <duckbob> http-client is yesod
11:04:40 <duckbob> ill check out wreq
11:04:45 <Intolerable> its very separate, though
11:04:57 <Zemyla> duckbob: Why is yesod out?
11:05:12 <duckbob> Zemyla, illegible 
11:05:17 <Twey> duckbob: http-client has no dependency on Yesod
11:05:33 <duckbob> no but it is a dependancy of yesod written as part of yesod
11:05:36 <creichert> duckbob: http-client is not yesod
11:06:01 <Twey> Nor does Snoyman's fondness for Template Haskell shine through in it :þ
11:06:03 <duckbob> its a port from network.conduit
11:06:04 <liste> how about http-conduit?
11:06:15 <Intolerable> why do you object to using anything that may have anywhere near yesod?
11:06:23 <duckbob> liste: same thing
11:06:23 <Intolerable> can't use http-conduit, yesod uses it ;)
11:06:28 <Intolerable> lol
11:06:32 <creichert> there is no TH in http-client either, your bias is extending far past yesod :)
11:06:33 <bennofs> Intolerable: can't use base, yesod use it :p
11:06:33 <Twey> Heh
11:06:48 <creichert> wreq uses http-client btw
11:07:24 <duckbob> so long as it provides a better api...
11:07:24 <Zemyla> bennofs: I was about to say the same thing.
11:07:51 <Twey> Intolerable: It's like the inverse of seeing the fnords — if duckbob sees ‘Snoyman’ on a page, the rest of the code becomes invisible.
11:07:59 <Twey> duckbob: http-client doesn't look like Yesod
11:08:08 <Twey> duckbob: It's perfectly normal Haskell functions and records.
11:08:18 <ttt_fff> is there a way to define _|_ as undefined ?
11:08:25 <duckbob> i guess actually im looking for the lowest level interface i can find to the socket, to remove the overhead, i dont like standing on mountains
11:08:25 <hpc> no
11:08:31 <Twey> ttt_fff: No, | is reserved ☹
11:08:31 <hpc> identifiers can't start with underscore
11:08:40 <ttt_fff> o instead of the 9 key strokes of undefined, I can do the 4 keystrokes of shift- _|_
11:08:44 <Intolerable> i'm definitely not a fan of yesod, but i'm not gonna avoid anything snoyman writes because i dont like one of his packages
11:08:53 <ttt_fff> damn
11:09:00 <creichert> duckbob: network
11:09:10 <duckbob> thanks
11:09:16 <ttt_fff> clearly, Haskell need Perl6's syntax system
11:09:35 <Twey> ttt_fff: You could probably use (⊥) though, but you need the brackets and… I'm not sure making undefined easier to insert into code is a worthy goal :þ
11:09:54 <Intolerable> does network even do anything useful at a high level
11:09:57 <Intolerable> @hackage network
11:09:57 <lambdabot> http://hackage.haskell.org/package/network
11:10:04 <duckbob> yes, this is the framework im used to with the "withSocketsDo"
11:10:07 <hpc> ttt_fff: use fix id
11:10:09 <ttt_fff> Twey: oh, I already have ⊥ in haskell-vim-now, it auto replaces "undefined" with ⊥ on all non-current-lines (i.e. all liens except the line I'm currently editing)
11:10:10 <hpc> it's shorter
11:10:18 <ttt_fff> :t fix it
11:10:19 <lambdabot>     Not in scope: ‘it’
11:10:19 <lambdabot>     Perhaps you meant one of these:
11:10:19 <lambdabot>       ‘id’ (imported from Data.Function),
11:10:23 <ttt_fff> :t fix id
11:10:24 <lambdabot> a
11:10:30 <ttt_fff> :t fix
11:10:30 <Zemyla> :t fix error
11:10:30 <bennofs> ttt_fff: fix it is for GHCi :)
11:10:31 <lambdabot> (a -> a) -> a
11:10:32 <lambdabot> [Char]
11:10:37 <Twey> ttt_fff: Oh, that's not the same ☹
11:10:39 <hpc> (it also is a non-terminating buttom instead of a crashing bottom)
11:10:42 <hpc> > fix error
11:10:43 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
11:11:03 <arkeet> > generalCategory '⊥'
11:11:03 <duckbob> have we got any not depending on the unix package? it isnt so portable
11:11:04 <lambdabot>  MathSymbol
11:11:18 <Intolerable> duckbob: what are your actual constraints
11:11:26 <duckbob> windows!
11:11:28 <bennofs> duckbob: network works on windows afaik
11:11:35 <Intolerable> us suggesting things then you telling us why they don't work isn't that helpful
11:11:37 <Intolerable> that's better
11:11:37 <duckbob> only using mingw
11:11:44 <duckbob> which isnt really windows
11:11:47 <bennofs> duckbob: but it's a bit hard to compile (although I heard that WinGHC makes it easieer)
11:12:07 <creichert> duckbob: the constraint is
11:12:09 <creichert> if !os(windows)
11:12:09 <creichert> unix (>=2)
11:12:21 <duckbob> msys is fine to provide support to the unix package
11:12:24 <creichert> ah
11:12:39 <Intolerable> can you really not use http-client etc. on windows?
11:12:47 <Twey> duckbob: wreq uses unix-compat, so should be fine on Windows with or without mingw
11:12:56 <duckbob> you just need to use a unix shell on windows like mngw its fine
11:13:03 <duckbob> mingw*
11:13:25 <Twey> duckbob: This is a difficult constraint to reconcile with ‘low-level’, though, because at a low level the Windows and UNIX socket APIs are incompatible
11:13:27 <hpc> i don't see anything http-client depends on that would be unix-dependent
11:13:54 <duckbob> Twey, i thought wreq was built on network-conduit so depends on unix...
11:14:16 <Twey> duckbob: I don't think it is
11:14:20 * geekosaur notes that the correct answer here may be https://github.com/fpco/minghc
11:14:23 <Twey> hpc: network is UNIX-dependent
11:14:36 <arkeet> no it isn't
11:14:38 <Twey> Oh
11:14:39 <albeit> Is there a Haskell tree datatype with better-than-O(n) lookups (to view parent and children) and better-than-O(n) insertions/deletions?
11:15:01 <geekosaur> it's just painful to build on windows because it gets confused easily by partial unix emulations and the like
11:15:12 <arkeet> fortunately it's included with the haskell platform
11:15:14 <hpc> yeah, just needs msys
11:15:18 <duckbob> dependancy tree is wreq<-http-client<-networ>=2.3
11:15:18 <Twey> No, wreq depends on http-client depends on network depends on unix
11:15:19 <geekosaur> hence minghc, which comes with a working network package
11:15:22 <Twey> Aha
11:15:23 <duckbob> network*
11:15:34 <Twey> Do we not have a native networking package for Windows?
11:15:43 <duckbob> <- unix
11:15:48 <bennofs> Twey: network doesn't depends on unix on windows 
11:15:49 <arkeet> network only depends on unix if it's not windows.
11:15:51 <geekosaur> network only depends on unix, on unix
11:15:54 <hpc> Twey: it's network
11:15:57 <arkeet> if !os(windows)
11:15:57 <arkeet>     build-depends:
11:15:57 <arkeet>       unix >= 2
11:16:07 <Twey> albeit: The usual Data.Map &c. have O(log n) times for most things
11:16:11 <duckbob> all this yesod stuff can only be built in mingw on windows
11:16:14 <hpc> Twey: the platform ships with network
11:16:20 <Twey> hpc, bennofs, arkeet: Oh, I see — the page is misleading
11:16:24 <arkeet> yes
11:16:28 <Twey> Okay, that's better
11:16:35 <arkeet> like I said.
11:16:45 <Twey> duckbob: So wreq should be fine
11:16:51 <hpc> Twey: it depends on the unix package, but can work if you use msys
11:16:55 <hpc> Twey: which also ships with platform
11:16:59 <Twey> hpc: Ah!
11:17:03 <arkeet> no
11:17:08 <arkeet> it doesn't depend on the unix package on windows
11:17:08 <Twey> hpc: So what's minghc for?
11:17:18 <geekosaur> duckbob left so it's kinda irrelevant
11:17:25 <duckbob_> sorry i dropped connection
11:17:30 <Twey> geekosaur: duckbob was replaced by duckbob_ :þ
11:17:42 <arkeet> :b
11:17:43 <hpc> arkeet: weird, i just tried cabal install network and got a complaint about unix
11:17:47 <geekosaur> more to their point might be that *ghc* requires mingw or cygwin, there is no buld based on vc or whatever
11:17:53 <duckbob_> hpc: thats the point
11:17:55 <Twey> duckbob_: wreq, or anything depending on network, should be fine: the ‘unix’ dependency doesn't apply on Windows
11:18:04 <hpc> duckbob_: anyway, you already have network
11:18:51 <duckbob_> hpc, i failed to get a post to work with network-http-client 
11:19:08 <hpc> duckbob_: but you got it installed?
11:19:15 <duckbob_> yes, using mingw
11:19:20 <hpc> then something else is wrong
11:19:33 <duckbob_> it was not a nice error to debug
11:19:44 <duckbob_> i had o clue why it wouldnt work and no way of finding out
11:20:20 <duckbob_> and the stackecxhange posts are all out of date since the despondencies and naming conventions keep chaniging 
11:20:33 <duckbob_> dependencies lol
11:21:07 <Gurkenglas> map (Is there a library that provides) [the category of typed-hole expressions, all the top-level names in a .hs file]
11:21:25 <duckbob_> im finding im in the position of having to flag the posts as deprecated with no way of providing an updated working example
11:21:36 <hpc> in the future, it helps if you actually lead with the error message you are getting
11:21:36 <tippenein> Is there any #haskell group on slack ?
11:22:03 <hpc> instead of leading us to believe the problem is 3 steps behind where you really are
11:22:34 <Twey> Gurkenglas: For the latter, maybe https://hackage.haskell.org/package/haskell-names ?
11:22:36 <duckbob_> hpc this was a long time ago, im just reluctant to repeat something that didnt work then, seems more out of date and less clearly documented now, to reproduce an error i could not solve
11:22:46 <duckbob_> call me lazy...
11:22:50 <Twey> Gurkenglas: I'm confused by the former — typed-hole expressions form a category?
11:25:50 <bennofs> Gurkenglas: [No, Yes] ?
11:26:02 <bennofs> afaik
11:26:26 <duckbob_> is anyone using any of the conduit or network packages to post forms to https and parse the results who might be able to share some simple source code with me, or link a comprehensive example of how to do so from the web. on the later, i have looked thoroughly for a few years and im sure i cannot find one
11:27:20 <Intolerable> what exactly are you trying to do
11:27:28 <Intolerable> post -> json response or something?
11:27:34 <duckbob_> yeh
11:27:37 <bennofs> duckbob_: like this: http://www.serpentine.com/wreq/tutorial.html#uploading-data-via-post using wreq?
11:27:41 <Clint> duckbob_: you can look at the hdav program in DAV
11:27:41 <Intolerable> @hackage api-builder
11:27:42 <lambdabot> http://hackage.haskell.org/package/api-builder
11:27:50 <Intolerable> (shameless plug but that's exactly what i built it for)
11:28:03 <Gurkenglas> Twey, what I want is: Start with a _ :: Bool and all the in some Module's scope. Get all the possible ways to fill in that _. (Filter them through quickcheck, apply that to some commonly used libraries, see what happens.)
11:28:10 <Intolerable> there's an example for stackoverflow and a tutorial on the github repo
11:28:11 <Gurkenglas> *all the names in some
11:28:19 <Intolerable> let me know if u have any questions and i'll probably be able to help
11:28:30 <duckbob_> Intolerable, but this is just fantastic! 
11:28:35 <Twey> Gurkenglas: Well, there are an infinite number of such ways
11:28:41 <Twey> Gurkenglas: In general
11:28:50 <Twey> Uncountably infinite, possibly
11:28:51 <Gurkenglas> Twey, do it in breadth-first order and output the filtered list lazily.
11:28:53 <Intolerable> also please let me know if it works on windows
11:28:54 <duckbob_> @hackage dav
11:28:54 <lambdabot> http://hackage.haskell.org/package/dav
11:28:58 <ttt_fff> omg, making data structures recursive makes some code so much cleaner
11:29:02 <Clint> duckbob_: all caps
11:29:11 <ttt_fff> why should I ever write a haskell function with more than 10 lines of code?
11:29:14 <duckbob_> @hackage DAV
11:29:14 <lambdabot> http://hackage.haskell.org/package/DAV
11:29:19 <Gurkenglas> Wait, uncountably?
11:29:26 <Gurkenglas> Quickcheck laws aren't infinite.
11:29:38 <ocharles__> Luke: not really tonight - at my dad's birthday :) email is probs best!
11:29:39 <Twey> Gurkenglas: Uncountably: _ ∷ [[()]]
11:29:53 <Gurkenglas> Twey, elaborate.
11:29:57 <Luke> ocharles__: np. was just looking at our systemd libraries
11:29:59 <Luke> we can talk later
11:30:13 <duckbob_> httpManager :: Lens' DAVContext (Maybe Manager)
11:30:17 <Twey> Gurkenglas: [[()]] is isomorphic to the reals, I think
11:30:22 <duckbob_> not the package for me...
11:30:37 <Intolerable> duckbob_: ?
11:31:02 <Intolerable> are you trying to implement dav or something?
11:31:09 <merijn> ttt_fff: 10 seems a bit short, I think I go longer than that fairly regularly
11:31:12 <duckbob_> how am i supposed to use something with Lens'? why is everything so obfuscated?
11:31:26 <Twey> Gurkenglas: There's no meaningful ‘breadth-first’ search because there are two dimensions along which it can expand, each of which is countably infinite
11:31:35 <ttt_fff> Twey: [[()]] is countable, the reals is not countable
11:31:44 <duckbob_> Intolerable: i was just checking the documentation to see if I would be able to get the package to do what I want it to
11:31:44 <Twey> ttt_fff: Is it countable?
11:31:46 <edwardk> > over _2 (+1) (1,2) -- modifies the target, view _2 (1,2) -- reads fromit
11:31:48 <lambdabot>  (1,3)
11:31:49 <ttt_fff> Twey: oh shit, n/m haskell has infinite lists, I'm wrong
11:31:52 <merijn> ttt_fff: Also, does that 10 lines include local definitions?
11:31:53 <Twey> ttt_fff: Yeah
11:31:59 <Twey> If it's finite, of course it's countable :þ
11:32:00 <edwardk> duckbob_: there are a ton of other combinators that consume lenses
11:32:09 <edwardk> but those will be enough to make them work for you
11:32:27 <Gurkenglas> Twey, each constructor inserted into that blank makes for another node that lets us stave off that branch of infinity. We're generating a tree with finite children at each node, so it has a counting. (umm embedding into the naturals, dunno the english word for it)
11:32:28 <ttt_fff> %&#(%&#$ infinite lists
11:32:36 <duckbob_> :t over
11:32:37 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
11:32:40 <bennofs> [[()]] looks like it would be isomorphic to rationals to me
11:32:41 <duckbob_> argh!?
11:32:47 <sccrstud92> ttt_fff: its still countable
11:32:49 <merijn> Lens types are...not very helpful :p
11:32:54 <ttt_fff> merijn: no, local defs does not count toward main function
11:33:13 <duckbob_> ill try one of the other packages 
11:33:22 <Gurkenglas> The children of _ :: [[()]] are [] and _ : _ (and many more from other names)
11:33:30 <bennofs> and the rationals are countable, so [[()]] is too
11:33:32 <sccrstud92> Gurkenglas: natural bijection?
11:33:36 <merijn> ttt_fff: For example, this is more than 10 lines, but I don't think shortening it is sensible: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L209-L228
11:33:39 <Twey> bennofs: Rationals are just ([()], [()])
11:33:48 <edwardk> over takes "any thing you can set, which includes a lens, setter, traversal, prism, iso...." and a function to apply to it (which may be generalized to do things with indices, most of the time p = (->) in that, and what you want to apply it to, and gets the modified result.
11:33:49 <Twey> (pair of naturals)
11:33:57 <Gurkenglas> sccrstud92, a witness of countability
11:33:57 <bennofs> oh right, this is [nat]
11:34:15 <Twey> bennofs: Yeah, which if you consider the nats as digits of the real, is at least as big as the reals
11:34:19 <Twey> Gurkenglas: ^
11:34:29 <sccrstud92> [[()]] is not the same as [Nat]
11:34:39 <Twey> sccrstud92: Why not?
11:34:39 <bennofs> do we consider infinite lists here?
11:34:43 <Twey> bennofs: Yes
11:34:50 <sccrstud92> a Nat is finite Twey
11:34:53 <ttt_fff> [[()]] is atleast as bit as [Either a b], and [Either a b] is isomorphic to the reals
11:34:56 <sccrstud92> [()] can be infinite
11:34:57 <ttt_fff> thus [[()]] is not countable
11:34:57 <ttt_fff> qed
11:34:59 <Twey> sccrstud92: Oh, true
11:35:06 <Twey> Well, it's even bigger than Nat
11:35:07 <edwardk> Nat ~ finite lists of (), [()] is the one point compactification of the naturals instead. you add infinity with nice properties
11:35:11 <Gurkenglas> Twey, [[], [()], []] is more than one incremental step away from _. The first one is (_:_).
11:35:28 <ttt_fff> edwardk: please tell us about this database you're writing in haskell
11:35:38 <edwardk> ttt_fff: i'm not writing a database in haskell
11:35:45 <edwardk> i've been writing a bunch of pieces that are useful to one
11:35:52 <ttt_fff> edwardk: are you working on an extension to your tables library which provides persistence?
11:35:54 <edwardk> and its not really a normal database at that
11:35:58 <edwardk> ttt_fff: no
11:36:10 <bennofs> Twey: non-infinite [Nat] are still countable, are they?
11:36:13 <ttt_fff> edwardk: oh, someone on the internet lied to me then
11:36:16 <edwardk> tables was a one-off toy. a spike solution to show what lenses could do to an API if you just assumed their existence and kind of ignored the laws
11:36:18 <sccrstud92> [[()]] is countable because even if it is an infinite list of infinite lists, this is like the rationals, so you can construct a similar bijection
11:36:23 <edwardk> ttt_fff: that happens some times
11:36:27 <Twey> Gurkenglas: Yes, but then you branch off into two infinite trees — the countably infinite [()] in the head, and the uncountably infinite [[()]] in the tail
11:36:42 <Twey> bennofs: Yes, those are a subset of the rationals
11:36:55 <ttt_fff> [Either a b] is isomprhic ot the reals; thus [[()]] is uncountable
11:37:07 <Twey> Gurkenglas: ↑
11:37:07 <Gurkenglas> Twey, so what? Our breadth-first search still won't run into problems
11:37:32 <sccrstud92> [[()]] is not uncountably infinite. its countable
11:37:40 <bennofs> sccrstud92: no you can't. rationals would be ([()], [()])
11:37:59 <Twey> (ignoring infinities)
11:38:31 <bennofs> And [Nat] is a subset of rationals if you ignore infinities? How?
11:38:37 <edwardk> the one that gets me is that in haskell we can talk about things like hyperfunctions "newtype Hyper a b = Hyper { runHyper :: Hyper b a -> b }" -- and then show that functions of the form Hyper Bool Bool that you can get answers out of are isomorphic to the naturals. so in this setting Nat ~ (Nat -> Bool) -> Bool -- nat is its own double power set, which is
11:38:37 <edwardk> an anticlassical result.
11:38:38 <sccrstud92> think of [[()]] as a square of () than can be infinite in two directions, but u still have on origin
11:39:12 <sccrstud92> so the bijection is u start at the origin
11:39:20 <Twey> sccrstud92: That's ([()], [()]).  [[()]] is infinite in *infinite* directions.
11:39:41 <sccrstud92> no not infinite directions, still just 2
11:39:58 <sccrstud92> isnt a list of lists 2dimensional?
11:40:08 <Twey> sccrstud92: Not in that sense
11:40:18 <sccrstud92> what sense?
11:40:23 <merijn> sccrstud92: Each of N (potentially infinite) elements is potentially infinite
11:40:30 <sccrstud92> so?
11:40:33 <duckbob_> hoauth and api-builder look perfect for my application. ill try and implement it in these, thanks so much for providing an alternative to conduit
11:40:48 <sccrstud92> every () in [[()]] has two finite indices, right?
11:41:11 <Intolerable> (api-builder still uses conduit under the hood)
11:41:15 <Twey> sccrstud92: Yes, but every value of [[()]] does not have two finite indices
11:41:24 <sccrstud92> oh oh
11:41:28 <edwardk> we can embed (Nat -> Nat) into Nat in certain interesting models: http://math.andrej.com/wp-content/uploads/2011/06/injection.pdf
11:41:45 <sccrstud92> were talking about the set of values of [[()]], not the number of () in [[()]]
11:41:55 <Intolerable> actually it doesnt
11:41:58 <Intolerable> it just uses http-client now
11:42:03 <John[Lisbeth]> What are some good shells if I want to have advanced programming features, and protect the purity of IO?
11:42:05 <Intolerable> i switched it recently
11:42:06 <Twey> sccrstud92: Every () has two indices *within a particular value of [[()]]*
11:42:20 <John[Lisbeth]> For haskell development that is.
11:42:44 <Twey> edwardk: Oh, neat, I didn't know there was a paper on this
11:44:32 <edwardk> anytime you start working with anything that even remotely smells of a cantor space or powerset or space of functionals or compactification its worth checking andrej's blog for prior art =)
11:44:38 <Twey> Gurkenglas: So yeah, your breadth-first search doesn't work — you just iterate through [], [[]], [[], []], … and you never get to [[()]]
11:45:10 <Gurkenglas> What? Of course I do.
11:45:49 <Gurkenglas> Assume we have no names that produce lists but the list constructors... lemme draw this up
11:46:32 <Twey> edwardk: Andrej's stuff is usually beyond me for now, unfortunately
11:46:48 <edwardk> Twey: for what it is worth it is usually beyond me as well ;)
11:46:54 <Twey> edwardk: Usually I just content myself with skimming his articles with a sense of amazement
11:46:57 <Twey> Heh
11:47:08 <edwardk> every once in a while i figure something out in that space
11:47:13 <Gurkenglas> (I shall substitute () holes with () immediately)
11:47:15 <edwardk> but it isn't a fun stomping ground
11:47:55 <edwardk> anyways https://github.com/ekmett/hyperfunctions/blob/master/examples/Cantor.hs#L33 is a realization of the notion that Natural is isomorphic to (Natural -> Bool) -> Bool  in haskell
11:48:09 <mniip> edwardk,  is there a recommended order of learning fancy haskell stuffs?
11:48:57 <edwardk> mniip: first find something you want to know about, second, find everything and anything you need to understand to understand the thing you want to learn about, recurse. eventually the stack will pop back up to where you started or you'll stop caring about it
11:49:02 <ttt_fff> mniip: LYAH, RWH, Parallel + Concurrent Haskell, write half of hackage
11:49:05 <mniip> I mean free monads, costate comonad coalgebras, kan extensions, natural transformations etv
11:49:07 <mniip> etc
11:49:25 <bennofs> mniip: try to understand the implementation of lens :p
11:49:39 <mniip> well
11:49:50 <mniip> that's how I did it before
11:49:50 <edwardk> personally i find that once you get the notion of an adjunction a lot of the rest drops out
11:49:55 <mniip> recursive descend
11:50:02 <johnw> mniip: pick something interesting, and keep pushing; a lot of these topics connect at the deepest levels, so you'll find yourself popping back up into the other areas.  Thus, rather than a linear order, it's more like pick whatever arm of the octopus you want to pull on, and the rest will come along.
11:50:13 <mniip> but I was thinking there is a more efficient way
11:50:36 <edwardk> because you can think of free constructions in terms of the underlying adjunction to a forgetful functor, kan extensions as a way to construct adjoints (among other things), you need natural transformations to get to adjunctions
11:50:50 <edwardk> "costate comonad coalgebra"s are kind of an evolutionary dead-end in understanding lenses though
11:53:04 <duckbob_> Intolerable: i ran cabal install api-builder. i then copy pasted the contents of api-builder/src/Network/API/Builder/Examples/StackOverflow.hs to a new file, but it threw errors on every function...
11:53:36 <Gurkenglas> Twey, http://sketchtoy.com/65669068
11:54:39 <mniip> edwardk, well
11:55:08 <mniip> sometimes a topic can be referenced, that I understand very slightly
11:56:02 <mniip> like I know what we are talking about, but not the implications related to that thing
11:56:12 <anticore> hey guys, i have a question that maybe is kind of unimportant, but i thought i'd ask anyway: when declaring auxiliary functions (separate, without using let or where) is it relevant to safeguard every possible case for that function, even if such cases never happen when it executes in the main function?
11:57:00 <Intolerable> duckbob_: lpaste the errors and post it here
11:57:14 <edwardk> f -| g -- f is left adjoint to g -- just means that for all a and b, (f a -> b) is isomorphic to (a -> g b)  -- the arrows here are in categories other than haskell and f and g are functors. thats it    when f = (, e)  and g = (->) e  you get (a, e) -> b  being isomorphic to a -> (e -> b) which is witnessed by the existence of curry and uncurry.
11:57:18 <duckbob_> anticore: it is good practice to provide a test that will fail if this desired functionality is not satisfied incase you change something and it breaks
11:57:31 <Twey> Gurkenglas: The drawing, it wobbles
11:57:50 <anticore> duckbob_, so always consider every possibility even in secondary and auxiliary functions?
11:57:50 <duckbob_> Intolerable: I would but i cant copy paste from my ghci window...
11:57:51 <mniip> anticore,  internal invariants are internal
11:57:56 <mniip> and invariant
11:58:02 <Gurkenglas> Twey, set vibration to 20
11:58:11 <Intolerable> pipe them to a file, copy paste that?
11:58:20 <Twey> Hahah
11:58:25 <Twey> What is this for
11:58:25 <anticore> mniip, how do you mean?
11:58:27 <Twey> Anyway
11:58:41 <edwardk> now we can play with words and notation and say that given F :: C -> D, G :: D -> C    F -| G means Hom_D(F-, =) is naturally isomorphic to Hom_C(-,G=)
11:58:49 <Twey> Gurkenglas: Notice how the first node has two children, the second node has four children, &c.
11:58:51 <edwardk> but thats really all it is
11:58:56 <Gurkenglas> Twey, yes?
11:59:39 <mniip> anticore,  if a function is internal, no one really cares if it's partial
11:59:51 <Twey> Oh, wait, I see what you're showing
11:59:55 <duckbob_> anticore: e.g. you dont want the user to pass values below 0, but you dont want to have to write the error check because you are lazy, and you are confident you will remember never to pass such values when you use the function.... i see this as bad practice, you can communicate something to any reader including yourself if you write down the expected scenarios the code will not be valid. it also helps tell the user a little about 
12:00:42 <Intolerable> don't leave it unspecified
12:00:50 <anticore> duckbob_, yeah, in my head it's also bad practice, just wanted to ask the community to get a second opinion, thank you
12:00:52 <Intolerable> add a descriptive "error" call
12:01:21 <mniip> edwardk,  if you're explaining this to me, I lost track at "(f a -> b) is isomorphic to (a -> g b)"
12:01:35 <edwardk> so we can find interesting categories, e.g. the category [Hask, Hask]  or Hask^Hask of functors on Hask, where my objects are functors, and my arrows are natural transformations. and the category of monads on Hask where the objects are monads and the arrows are 'monad homomorphisms' -- natural transformations between monads that also preserve the laws for
12:01:35 <edwardk> return and join.   and we can define a functor between these categories, one that takes any monad in the category of monads on Hask to a functor in the category of functors on Hask.. lets call this functor U, then we're looking for a functor that is left adjoint to U.
12:02:03 <edwardk> this is how you get 'free monads' from a category theory perspective, but its a lot easier to start operationally. with the (f a -> b) ~ (a -> g b)
12:02:06 <edwardk> so lets go back there
12:02:47 <edwardk> (f a -> b) is isomorphic to (a -> g b) means that for every function (f a -> b) you give me there is precisely one corresponding function (a -> g b) and vice versa.
12:03:09 <duckbob_> intolerable: most of the errors are about strings not being Text...
12:03:11 <mniip> do you have an example?
12:03:20 <mniip> Im not sure I get the concept
12:03:27 <edwardk> curry :: ((a, e) -> b) -> (a -> e -> b)        and uncurry :: (a -> e -> b) -> (a, e) -> b       are functions such that curry . uncurry = id, and uncurry . curry = id
12:03:27 <Intolerable> oh, you need to make sure OverloadedStrings is enabled
12:03:41 <edwardk> (ignoring the extra bottom in (a,e)
12:03:49 <Intolerable> probably with a "{-# LANGUAGE OverloadedStrings #-}" pragma at the top
12:03:57 <duckbob_> awesome
12:03:57 <edwardk> Identity a -> b   is isomorphic to (a -> Identity b)
12:04:22 <Intolerable> (if you're using a cabal file, you can add OverloadedStrings to default-extensions as an alternative)
12:04:27 <duckbob_> yeh i saw you had that in some other part of the code, maybe you should leave it at the top of the actual example code?
12:04:34 <duckbob_> i think its in a spec file...
12:04:42 <Intolerable> no, it's in the cabal file
12:04:49 <Intolerable> which is where most people put it
12:05:06 <Intolerable> if they're using Text heavily
12:05:13 <duckbob_> oh yeh, so what is this? https://github.com/intolerable/api-builder/blob/master/test-io/Spec.hs
12:05:21 <mniip> edwardk,  not sure about the first example
12:05:28 <Intolerable> that's hspec's discover pragma
12:05:36 <Intolerable> that's different to enabling OverloadedStrings
12:05:37 <mniip> but the second doesn't seem really interesting
12:05:47 <duckbob_> mhmm, but what is it?
12:05:53 <edwardk> mniip: its not. the starting examples here are all going to be fairly boring
12:06:07 <edwardk> you don't have any other examples without being able to go to another category though
12:06:11 <Intolerable> it's a pragma that says "hspec, build a tree of all the tests in this directory, then run them all in order and give me a summary"
12:06:19 <edwardk> so without more sophistication those are the only two examples you've got
12:06:37 <mniip> okay then back at the first example
12:07:36 <edwardk> if we add Hask^op as a place we can go to/from we can find that (-> r) -| (-> r) -- but that requires some fancy thinking, there we get to use flip to witness the isomorphism
12:07:43 <mniip> are you trying to say ((,) e) is adjoint to ((->) e) ?
12:07:50 <edwardk> mniip: yes
12:07:57 <edwardk> (,) e -| (->) e
12:08:02 <EvanR> -| ?
12:08:04 <mniip> and
12:08:05 <edwardk> or (, e) -| (->) e -- in the notation i used here
12:08:06 <mniip> ohh
12:08:15 <edwardk> because i wanted e to be the second argument in the pair
12:08:19 <edwardk> and i'm not trying to get it to compile
12:08:32 <edwardk> otherwise i have to throw a flip in the mix
12:08:34 <dolio> That is the way you typically define (->) in category theory.
12:08:37 <edwardk> and everything gets uglier
12:08:58 <mniip> ohh
12:09:20 <mniip> now I get it, curry/uncurry demonstrate the isomorphism
12:09:22 <edwardk> :t curry . flip
12:09:23 <lambdabot> (a1 -> (a, b) -> c) -> a -> b -> a1 -> c
12:09:31 <edwardk> :t flip . curry 
12:09:32 <lambdabot> ((a, b) -> c) -> b -> a -> c
12:09:35 <edwardk> there
12:09:44 <edwardk> :t uncurry . flip
12:09:45 <lambdabot> (b -> a -> c) -> (a, b) -> c
12:09:55 <EvanR> what is G= above
12:09:57 <edwardk> yep
12:10:25 <mniip> okay
12:10:31 <edwardk> EvanR: one way mathematicians like to write functors is to just put -'s in for the argument so they don't have to name it, when you have two arguments we often use =    a double-dash to denote the second argument
12:11:26 <EvanR> ok but Hom_C(-, G=) looks like you named it anyway
12:12:08 <EvanR> so i thought it was some fancy operation on functors
12:13:59 <duckbob> Intolerable: im not sure which bits to change to get the authentication key to work for this api...
12:14:20 <Intolerable> how do you need to send the auth key?
12:14:23 <mniip> edwardk,  okay, time for recursive descend
12:14:24 <duckbob> yes
12:14:32 <mniip> what's a Hask^op
12:14:32 <Intolerable> how
12:14:33 <duckbob> sorry, i thought oyu asked "do I"
12:14:57 <edwardk> mniip: i'm going to have to step away for a bit (work calls) but we can pick this up later, or you can ask other folks in here or in #haskell-lens for more info
12:15:07 <duckbob> a key and sign as header parameters
12:15:22 <duckbob> just some Text
12:15:34 <duckbob> i guess ill pack it from strings
12:16:24 <Intolerable> take a look at customizeRequest
12:16:36 <Intolerable> it applies that function to every request it creates
12:17:17 <duckbob> ok
12:17:18 <Intolerable> so if you can build a function (Request -> Request) that just adds the required headers
12:17:22 <mniip> okay, seeing as as this is pretty common syntax, I would guess there's more people in here that know what Hask^op means
12:17:25 <Intolerable> it'll add them to everything
12:17:30 <Intolerable> i'll try and find an example
12:17:34 <duckbob> oh thanks
12:18:37 <Intolerable> https://github.com/intolerable/reddit/blob/master/src/Reddit.hs#L162-L163
12:19:22 <Intolerable> if you do something like "run key act = customizeRequest (addHeader key) >> act"
12:19:25 <Intolerable> that should be fine
12:19:50 <Intolerable> you can also just include the (Request -> Request) function in the Builder
12:20:03 <duckbob_> hrm
12:20:07 <duckbob_> okey
12:20:29 <Intolerable> https://github.com/intolerable/api-builder/blob/master/src/Network/API/Builder/Builder.hs#L11-L16
12:20:50 <duckbob_> thats more clear, thanks
12:21:15 <Intolerable> yeah i forgot that existed
12:21:15 <Intolerable> most of the time i do a login and then add the headers after that
12:21:22 <breadmonster> Hello.
12:21:27 <Intolerable> hi
12:23:09 <Twey> Gurkenglas: Your algorithm confuses me
12:23:43 <Gurkenglas> Twey, I fudged the order a little so I don't have to draw as much
12:24:09 <Gurkenglas> Imagine it was breadth-first search. All I wanted to show is that all finite possibilities are eventually reached
12:25:27 <Fay> hey guys
12:25:29 <duckbob_> Intolerable: its way too complicated. i just want to construct and receive a http post, all this reading into datatypes is fancy and useful but i cant even see errors which indicate how i should correct my code...
12:26:02 <Fay> https://github.com/sdiehl/wiwinwlh/tree/master/src
12:26:07 <Intolerable> what errors are you getting now?
12:26:18 <Fay> ^ really good stuff for reading to learn code
12:26:31 <Intolerable> and i mean you can just unpack it into a Value but that's pretty useless
12:26:33 <Twey> Gurkenglas: No, I'm confused as to how you've added some values *into* something that was already at least as big as the reals, and produced what seems to be a countable set.  Maybe it's related to Andrej's paper that edwardk linked, which I don't fully understand
12:26:42 <Intolerable> have you used Aeson?
12:27:09 <duckbob_> Left (ParseError "key \"ducks\" not present")
12:27:45 <duckbob_> I have not used Aeson
12:27:48 <Gurkenglas> Twey, I only count the finite ones. If you only count reals that have finitely many nonzero digits, you're not gonna get very uncountable.
12:27:59 <Intolerable> lpaste your code or something
12:28:11 <Intolerable> if you have a sample json output too, that'd be handy
12:28:17 <Twey> Gurkenglas: Hm, maybe that's it
12:28:24 <duckbob_> i just changed the url in your stackexchange example
12:28:40 <Gurkenglas> Everyone: I want to filter all possible laws (listed in ascending order of length) through quickcheck. What libraries should I use? What problems could I encounter?
12:29:01 <Lokathor> does ghc pre-compute constant values? for example, if a file contains "x = sum [1..10]", will ghc just convert that to 55?
12:29:07 <Intolerable> do you want to email me or something?
12:29:18 <bennofs> Lokathor: I don't think it will
12:29:23 <Intolerable> i can help you but it's kinda awkward here
12:29:43 <Intolerable> the example / tutorial is meant for something with a little more haskell experience than you seem to have
12:29:47 <Gurkenglas> Why not /query?
12:29:55 <Gurkenglas> If you're not comfortable here
12:30:25 <Intolerable> that works too
12:30:42 <duckbob_> Intolerable, im trying to get this api to work with haskell; https://btc-e.com/tapi/docs#Trade
12:30:55 <athan> Gurkenglas: All possible laws?
12:31:43 <hodapp> http://okmij.org/ftp/Haskell/tr-15-04.pdf interesting, this is the first I've ever heard of the "configurations problem" but I think it relates to something I've complained about: having to parametrize 90% of my stuff over the same 3-4 types that are used mainly for configuration
12:31:45 <Gurkenglas> athan, every boolean expression. Also functions with boolean output.
12:32:24 <athan> Gurkenglas: Within your test suite? Are you also including `Property`'s, too?
12:32:44 <xevz> tommd: Do I have something wrong with my configuration, or doesn't vim-haskell handle "where" correctly?
12:33:33 <xevz> Also "|"
12:33:38 <athan> Gurkenglas: What's your metric for "length", also? Amount of complexity of the test? :s
12:33:39 <MarcelineVQ> A question like that works better with context
12:34:05 <Gurkenglas> athan, I have no test suite. I don't know what Properties are. I've never even used quickcheck much beyond @check. I just found a way too short to not be bruteforceable invariant in a library and thought I shouldn't have had to think of it myself.
12:34:12 <Gurkenglas> athan, token count of the expression.
12:35:28 <athan> Gurkenglas: I don't think there is, but you _can_ run into exhausted test generations (when using `==>` to provide prerequisites) for large test expressions
12:36:13 <athan> Gurkenglas: I think quickcheck-instances also provides a lot of axioms for common data types
12:36:20 * athan wonders if the monad laws are in there
12:36:57 <Gurkenglas> athan, could you rephrase that? I asked no question of form "Is there _?". Was that but clause an example of a problem I might run into?
12:37:39 <athan> Gurkenglas: Yes, let me see if I can find a reference for you
12:38:24 <athan> Gurkenglas: http://stackoverflow.com/questions/18502798/why-does-quickcheck-give-up
12:38:26 <breadmonster> Has anyone implemented emulators in Haskell?
12:38:42 <mniip> breadmonster, did
12:38:45 <ReinH> breadmonster: there are a few
12:38:48 <athan> Basically, there are two phases to QuickCheck - test generation, then refinement
12:38:57 <ReinH> breadmonster: I'm working on an 8080 emulator and a ZMachine emulator, but they are very incomplete
12:38:58 <breadmonster> mniip: What have you implemented?
12:39:04 <mniip> 6502
12:39:13 <mniip> in monad transformer form
12:39:22 <athan> (==>) lets you refine a generated test with some simple booleans, but `suchThat` gives you the same power _before_ you generate tests
12:39:26 <athan> Gurkenglas: ^
12:39:30 <mniip> for both pure and impure usage
12:40:13 <breadmonster> mniip: Any advice?
12:40:18 <breadmonster> Also, do you have a github account?
12:40:22 <mniip> uh
12:40:25 <mniip> idk
12:40:35 <mniip> and yes
12:40:54 <mniip> keep in mind I only tested the emulator, not the performance
12:41:01 <breadmonster> I'm trying to figure out how to implement the DEC PDP-8 instruction set.
12:42:06 <Gurkenglas> athan, quickcheck can already generate tests by itself? Huh. I thought I'd have to generate well-typed boolean expressions and feed them to quickcheck one by one.
12:42:12 <mizu_no_oto> Is there a standard pronunciation of '$', when reading haskell code?
12:43:51 <athan> Gurkenglas: It's all type-directed. If you have a function `Arbitrary a => a -> Bool` or any other combination like `Arbitrary a, Arbitrary b => a -> b -> Bool`, then quickcheck can generate them
12:43:54 <mniip> I would guess "applied to"?
12:44:05 <MarcelineVQ> apply or of, or something similair
12:44:07 <athan> Gurkenglas: Tasty (the test suite) is also really cool
12:44:34 <athan> Gurkenglas: I made a `hi` template for quickcheck-ready libraries, too: https://github.com/athanclark/hi-quickcheck-lib
12:48:44 <Gurkenglas> athan, could one just feed https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html and it would, among other things, find evalState . gets == id?
12:49:00 <Gurkenglas> *into it
12:50:20 <athan> Gurkenglas: You can provide the function `\(x :: Arbitrary a => a) -> evalState (gets x) == x` to it, yep
12:50:43 <Gurkenglas> Nuuu I want it to find the laws to check
12:51:00 <athan> Gurkenglas: Can't do dat :c
12:51:26 <Gurkenglas> "athan, every boolean expression. Also functions with boolean output." ._.
12:51:42 <athan> Gurkenglas: It's like the djinn
12:51:44 <benzrf> @check \(x :: Arbitrary a => a) -> evalState (gets x) == x
12:51:44 <lambdabot>  <unknown>.hs: 1: 26:ScopedTypeVariables is not enabled
12:52:05 <benzrf> @check \x -> evalState (gets x) == (x :: Arbitrary a => a)
12:52:07 <lambdabot>  No instance for (Typeable a0) arising from a use of ‘myquickcheck’
12:52:07 <lambdabot>  In the first argument of ‘text’, namely ‘(myquickcheck (\ x -> evalState (ge...
12:52:26 <athan> benzrf: U:
12:55:20 <Gurkenglas> Let's backtrack to my original question, then. Against scrolling:
12:55:32 <Gurkenglas> I want to filter all possible laws (listed in ascending order of length) through quickcheck. What libraries should I use? What problems could I encounter?
12:56:17 <ghcquestion> I tried using :set -ddump-rn to the fully qualified names but it only qualifies my own module.  Is it possible to get it to show prelude.head --MonadTut.dblHead = head . head
13:00:27 <Gurkenglas> (By the way, the right inverses I mentioned ...I think yesterday are also left inverses. And nobody noticed.)
13:02:19 * athan lowers the limbo pole...
13:20:23 <andry87> ciao
13:20:36 <andry87> !list
13:20:36 <monochrom> andry87: http://hackage.haskell.org/packages/
13:29:37 <bitemyapp> @pl filtered (\x -> isJust (x ^? img))
13:29:37 <lambdabot> filtered (isJust . (^? img))
13:30:14 <indiagreen> bitemyapp: just in case, are you testing whether lambdabot knows lens idioms?
13:30:20 <bitemyapp> nope
13:30:33 <bitemyapp> it's abstract symbolic manipulation, it doesn't need to know anything about lenses.
13:32:08 <chreekat> Gurkenglas: I think the closest thing to what you want is probably Test.QuickCheck.All.quickCheckAll, but it's TH and depends on everything you want tested to be named prop_*
13:32:15 <Taneb> bitemyapp, why not filtered (has image)?
13:32:31 <indiagreen> bitemyapp: I thought it still did some simplification (and then I had a neat theory that you tried to teach @pl that isJust + ^? = has and now were testing whether your patch worked)
13:32:31 <bitemyapp> hrm.
13:32:44 <bitemyapp> Taneb: dammit, good call.
13:32:58 <bitemyapp> Taneb: thank you :)
13:33:04 <Taneb> No problem :)
13:34:31 <bitemyapp> Taneb: since you're here, can I do a "pick highest"/"pick lowest" based on some field sort criteria?
13:34:49 <bitemyapp> Taneb: I've got a final result of [MyType] so I can just "do it" but I thought I'd ask.
13:34:50 <Taneb> I don't quite understand what you mean
13:34:50 <indiagreen> bitemyapp: okay, uh, then I'll also tell you that a couple of days ago you used «@pl (\x -> x & has (key "img"))» and got «(& has (key "img"))» in response and it could've been just «has (key "img")» and I didn't tell you for pretty much the same reason
13:35:15 <bitemyapp> Taneb: sortBy (gibberish) . head
13:35:18 <bitemyapp> _head*
13:35:19 <bitemyapp> w/e
13:35:29 <bitemyapp> I'm being lazy.
13:35:30 <Taneb> minimumBy and maximumBy in Data.List
13:35:42 <bitemyapp> well, yes. okay, so do it outside the lensy chain. :P
13:36:11 <Taneb> Oooh, to get a lens?
13:36:50 <Taneb> I don't know how to do that
13:37:31 <bitemyapp> @pl (\x y -> compare (x ^. w) (y ^. w) )
13:37:31 <lambdabot> (. (^. w)) . compare . (^. w)
13:37:39 <bitemyapp> I don't think I hate my coworkers that much.
13:38:05 * hackagebot module-management 0.20.4 - Clean up module imports, split and merge modules  https://hackage.haskell.org/package/module-management-0.20.4 (DavidFox)
13:38:06 <indiagreen> comparing (view w)?
13:39:36 <bitemyapp> indiagreen: the sort lands on the wrong part of the data tho
13:40:42 <bitemyapp> easiest to lift it out
13:42:58 <frerich> bitemyapp: "compare `on` (^. w)" is a bit nicer.
13:43:10 <frerich> (or 'comparing' if you fancy that)
13:45:32 <bitemyapp> frerich: that is nice
13:55:53 <nitrix> How does one parses `a=b,c,d` using parsec, where b c and d might contain other equals as well?
13:56:04 <nitrix> Does sepBy takes care of that?
13:57:02 <koala_man> yes, if the parser accepts everything it's supposed to up to and excluding the next comma, then sepBy will take care of it
13:57:59 <nitrix> I'll try to write it first, and then post it here.
13:58:10 <nitrix> Parsec seems really cool; just need to wrap my head around it.
13:58:14 <koala_man> it's fantastic
13:58:41 <HarveyPwca> Looking to learn Haskell. What books should I be looking for?
13:59:25 <shachaf> _Programming in Haskell_ by Graham Hutton is good.
13:59:28 <shachaf> A bit old, though.
13:59:43 <nitrix> koala_man: How do I combine two parsers? If I have the same thing split by comas, it's easy using `sepBy`, but in my case, what's before and after the (char '=') are completely different.
13:59:49 <nitrix> koala_man: Maybe some kind of <&> ?
13:59:53 <duckbob> hi Intolerable: i got cut off? can you invite me back?
14:00:22 <nitrix> koala_man: Can I just <$> ?
14:01:19 <nitrix> Oh I think I'm supposed to use it monadically. do, bind the things that I want and return it?
14:01:38 * nitrix scratches his head.
14:02:36 <roboguy_> nitrix: that sounds right
14:05:05 <japesinator> nitrix: so you have [value1], [value2]
14:05:23 <nitrix> I'm almost done, one sec.
14:05:25 <nullvoid8> nitrix, don't forget (*>), (<*) and (<*>), though do is probably more readable
14:07:03 <roboguy_> I don't think you could use those in this case, but they can be readable if you use them in moderation. I think "char '(' *> p <* char ')'" is pretty readable
14:10:42 <Jello_Raptor> so I'm working on making a monad instance for "Prio_List a = [(Priority,a)]" however making that instance requires that all "Prio_List a" must be sorted by their priority, even the infinite lists. Is there any reasonable way to enforce that within haskell's types? or do I just have to manually check everything that returns a priority list?
14:10:46 <nitrix> http://lpaste.net/138213
14:10:56 <nitrix> Code, BNF and text example.
14:11:03 <nitrix> Is the parser reasonable?
14:11:20 <nitrix> Oh whoops, line #14 needs to return a tuple too.
14:11:36 <nullvoid8> :t \f a b c -> f <$> a <* b <*> c -- roboguy_
14:11:37 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f b1 -> f a -> f b
14:12:14 <nullvoid8> so that would work for this use case
14:12:19 <roboguy_> oh, right
14:12:31 <dgonyeo> I'm going to read a CS paper and give a presentation on it to some coworkers, and was hoping to use the idea to introduce them to the concept of monads. Does anyone here have any suggesstions for papers that could be useful for that?
14:12:44 <dgonyeo> s/idea/opportunity/
14:13:33 <nitrix> roboguy_: japesinator: nullvoid8: http://lpaste.net/138213 
14:14:31 <Forkk> Does haskell have some equivalent to the unix getpass function?
14:14:32 <nullvoid8> nitrix: did you paste an old link, or do I need to refresh?
14:15:00 <nitrix> nullvoid8: Same one, sorry. I just forgot to highligh the first time.
14:15:27 <Cale> Forkk: You mean a function which is obsolete and which you shouldn't use? :D
14:15:37 <nitrix> Well, I can tell you already it doesn't compile :/
14:15:43 <arkeet> https://stackoverflow.com/questions/4064378/prompting-for-a-password-in-haskell-command-line-application
14:16:11 <Forkk> Cale: how should I read a password at the terminal then?
14:16:30 <arkeet> Forkk: see my link
14:16:51 <nitrix> Oh, bingo. 
14:17:02 <Forkk> thanks
14:17:31 <nitrix> I fixed the type signature of parseBlock to what the compiler wanted, now the question is why does `anyToken` yields a Char, lol.
14:17:59 <nitrix> This Parsec stuff will eat my weekend <3
14:19:07 <lyxia> nitrix: because Char is the token type
14:19:17 <nullvoid8> nitrix: irc, because the type of anyToken (after you unwrap the synonyms) is a parser for Chars?
14:19:21 <qsuscs> how would you do this in haskell?  while (true) { printf("blah\n"); }
14:19:29 <qsuscs> (the sense of that put aside)
14:19:56 <nullvoid8> :t forever
14:19:56 <Welkin> qsuscs: many different ways
14:19:57 <MP2E> forever $ putStrLn "blah"
14:19:57 <lambdabot> Monad m => m a -> m b
14:19:58 <nitrix> Oh, I want Text.ParserCombinators.Parsec.Char.string
14:20:22 <nullvoid8> hmm, the type is not always the pertinant information
14:21:08 <chreekat> nullvoid8: Actually it is! the b comes from nowhere, the only sensible meaning of it is non-termination
14:21:13 <MP2E> ^
14:21:15 <MP2E> was about to say that :D
14:21:15 <roboguy_> nullvoid8: the definition of forever is the only way to have that type that is productive and doesn't just throw an error though
14:21:23 <nullvoid8> chreekat: unless the a's and b's are phantom
14:21:24 <roboguy_> ha, me too apparently
14:21:32 <hpc> > forever Nothing
14:21:33 <lambdabot>  Nothing
14:21:34 <roboguy_> nullvoid8: Monad m doesn't tell you that though
14:22:15 <nullvoid8> roboguy_, chreekat: see hat hpc said.
14:22:26 <roboguy_> ?
14:23:18 <nullvoid8> nvm, I was reading ed's "Making Lens without lens"
14:23:53 <roboguy_> the only way to implement a function with the type "f :: Monad m => m a -> m b" that isn't an unproductive infinite loop or an error is the definition of forever
14:24:04 <nullvoid8> which has a thing about Fold's constraints, and how they force the type argument to be phantom
14:24:10 <roboguy_> oh
14:24:16 <roboguy_> (Functor f, Contravariant f) => ...
14:24:22 <roboguy_> isn't it?
14:24:24 <nullvoid8> yah
14:24:42 <nullvoid8> It was a long day at work, I may have a few wires crossed in my head
14:24:52 <roboguy_> I always thought that was a cool trick
14:25:12 <nullvoid8> which bit of lens are you reffering to? :P
14:27:51 <onhas12> hi
14:28:13 <onhas12> What's the best distro for haskell; I am talking about getting the different libraries and stuff? 
14:28:26 <hpc> it doesn't matter that much
14:28:28 <onhas12> Debian vs Mint vs Ubuntu ... I don't care for one or the other ... 
14:28:43 <MP2E> stack (the tool by FPComplete) works pretty well on any distro
14:28:44 <onhas12> hpc: ok no cabal hell? 
14:28:45 <hpc> you should pick a version of ghc from wherever, then use cabal
14:29:00 <roboguy_> onhas12: that's pretty unrelated to the distro
14:29:06 <hpc> cabal hell has been harder and harder to get into, lately
14:29:22 <hpc> and using cabal avoids packager hell
14:29:23 <onhas12> I am stuck in cabal hell on macos so I am just driven to using linux on a vm on my macbook. 
14:29:31 <hpc> where you need X, but X isn't prepackaged
14:29:31 <Clint> onhas12: debian testing and unstable maintain varying degrees of currentness
14:29:38 <hpc> and if you cabal install it, your whole system breaks
14:30:13 <hpc> if you use sandboxing effectively, cabal hell is impossible
14:30:17 <onhas12> Clint: Should I run unstable then? 
14:30:23 <roboguy_> onhas12: that sounds like a lot of trouble to go to. When I have that big of a problem, I just delete all of my cabal packages and start over
14:30:27 <onhas12> hpc: on a macos? 
14:30:39 <hpc> it's a cabal feature
14:30:56 <Clint> onhas12: i like installing all my libraries from .debs
14:31:21 <onhas12> roboguy_: somehow I can't keep out of trouble with haskell on mac and gave up for a month. 
14:31:28 <onhas12> I don't want that to happen again ...
14:31:48 <roboguy_> onhas12: I have done Haskell development on OS X for two or three years now and haven't had too much trouble...
14:32:02 <roboguy_> my Haskell experience on Linux and OS X has been very similar actually
14:32:30 <onhas12> roboguy_: Yes that's a key difference ... I was following some tutorials as a beginner and it was so messed up, I just quit. 
14:32:56 <onhas12> I am not there yet to deal with whatever errors show up ... 
14:33:23 <roboguy_> that's why we have the irc channel! feel free to ask about any of them, when you run into them
14:38:34 <chreekat> onhas12: for development, it is indeed better to forego the system packages for haskell libraries. I think the only possible exception is Nix/NixOS, but I don't have any personal experience there. For better or worse, you need to learn the cabal workflow that works best for you. I recommend using stack as the front-end tool for managing dependencies, but there's still merits to using cabal-install and cabal sandboxes.
14:40:06 <onhas12> chreekat: I am happy to learn cabal. I ran into a circular error with cabal. Remove it and haskell went nuts and install it it kept telling me something about a sandbox missing even when I created one ...
14:40:06 <Zemyla> Hmm, might applicatives be easier to understand if their primary operation were (<,>) :: (Applicative f) => f a -> f b -> f (a, b)?
14:40:20 <Zemyla> At least for some people?
14:42:06 <chreekat> onhas12: If you used a system-installed cabal to run 'cabal install cabal-install', the new executable isn't immediately on your path
14:42:49 <chreekat> onhas12: I'm not sure what I just said is relevant, but I figured I'd throw it out there to see if it rang any bells
14:43:10 <onhas12> I am blank from all the trauma :) 
14:43:23 <roboguy_> Zemyla: that formulation (plus "unit :: f ()") is sometimes called "Monoidal"
14:43:35 <onhas12> My brain chose to send all to /dev/null on my previous haskell attempt on OS X :)
14:43:43 <chreekat> hehe
14:44:21 <nitrix> There's a problem. `many anyChar` seems to consume everything and doesn't stop at the next directive that I have, being `char '='`
14:44:23 <roboguy_> onhas12: how did you install ghc?
14:44:27 <chreekat> I had the same trauma, incidentally. There are serious gaps that people are working on filling up in the just-getting-started experience
14:45:01 <onhas12> roboguy_: I used three methods as I recall and gave up on all. 
14:45:18 <roboguy_> onhas12: did you try https://ghcformacosx.github.io/? That always seemed the most straightforward to me
14:46:18 <onhas12> I think I still have this version installed
14:47:10 <onhas12> I also tried the homebrew
14:47:59 <roboguy_> personally, I like ghcformacosx, but I think if you pick one and then ask here about any issues you run into, you will probably be set
14:48:17 <roboguy_> nitrix: did you try manyTill?
14:49:48 <onhas12> and Let me see if I can get ghcformacosx running
14:50:29 <Zemyla> nitrix: Use many (notChar '=')?
14:51:15 <roboguy_> @hoogle manyTill
14:51:15 <lambdabot> Text.ParserCombinators.ReadP manyTill :: ReadP a -> ReadP end -> ReadP [a]
14:51:16 <lambdabot> Text.Parsec.Combinator manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
14:51:16 <lambdabot> Text.ParserCombinators.Parsec.Combinator manyTill :: Stream s m t => ParsecT s u m a -> ParsecT s u m end -> ParsecT s u m [a]
14:52:30 <Zemyla> roboguy_: And pure a = a <$ unit?
14:52:42 <roboguy_> Zemyla: yep
14:53:05 <arkeet> I like formulating Applicative in terms of pure and liftA2
14:53:29 <subleq> why can't you do type inference with polymorphic recursion?
14:54:02 <arkeet> it's undecidable
14:54:15 <roboguy_> Zemyla: the laws for Monoidal are also, in my opinion, more clear
14:54:17 <roboguy_> http://blog.ezyang.com/2012/08/applicative-functors/
14:54:18 <subleq> why?
14:54:42 <arkeet> http://www.diku.dk/hjemmesider/ansatte/henglein/papers/henglein1993a.pdf
14:54:49 <shachaf> arkeet: I like that too.
14:54:58 <shachaf> (<*>) is the worst for everything except practical use.
14:55:13 <shachaf> And even for practical use it's not great because it's left-biased. :-(
14:57:19 <nitrix> Zemyla: roboguy_: brilliant. I'm slowly getting the hang of this. Sorry guys.
15:00:08 <onhas12> Ok GHC for macosx was installed. 
15:00:16 <onhas12> It replaced my old GHC
15:01:06 <onhas12> https://twdkz.wordpress.com/2015/02/25/haskell-on-yosemite-osx-10-10/
15:01:18 <onhas12> Any harm in running through with the steps there?
15:02:20 <benzrf> shachaf: left-biased meaning?
15:02:28 <arkeet> infixl
15:02:31 <benzrf> ah
15:02:40 <benzrf> how does that cause problems?
15:02:43 <shachaf> spot of the infixl, governor?
15:02:44 <arkeet> can cause performance
15:02:49 <arkeet> worse performance
15:03:02 <roboguy_> onhas12: I think you should really only need to do steps 1 and 3 (see the comment at the bottom)
15:03:03 <shachaf> Oops, wrong channel.
15:03:08 <arkeet> consider Writer [a]
15:03:39 <shachaf> arkeet: Didn't you invent a better <*>?
15:03:47 <arkeet> did I?
15:04:43 <shachaf> I think so.
15:04:46 <arkeet> I don't remember
15:04:52 <shachaf> Or at least you put something on hpaste.
15:05:38 <onhas12> Update [2015-03-01]
15:05:44 <onhas12> That one roboguy_  ?
15:06:06 <arkeet> looks like I did http://lpaste.net/124464
15:06:15 <roboguy_> onhas12: no, in the comments section
15:06:18 <roboguy_> the second comment
15:06:25 <onhas12> Ah ok
15:06:35 <roboguy_> onhas12: step 1 and step 3 should be all you need
15:06:44 <onhas12> So I did the first three. Now is there an "Ide" I can use with haskell? 
15:07:49 <onhas12> I like emacs but am scared to go there ... 
15:07:55 <arkeet> this kind of sucks actually.
15:08:17 <arkeet> I guess the j could have been smashed into the <*.>
15:08:17 <roboguy_> unfortunately, all the Haskell IDEs are still pretty experimental, so I would suggest using your favorite editor together with a nice Haskell plugin. I'm a vim guy, so I use vim2hs. haskell-mode is good for emacs
15:08:18 <onhas12> I wanted the c-x c-c to send stuff to ghci and all that cool stuff ... but got into trouble the last time around ...
15:08:32 <roboguy_> onhas12: what happened?
15:09:49 <roboguy_> (also, I thought C-c C-l was load Haskell stuff in emacs haskell-mode, but it's been a while since I've used emacs)
15:10:07 <onhas12> roboguy_: I ran into the mismatch between cabal and ghc. 
15:10:22 <roboguy_> oh, that was probably unrelated to the use of emacs or the haskell plugin
15:10:49 <onhas12> roboguy_: not sure about the bindings. But what I was taking about is sending a line of code to GHCI for interactive execution
15:10:58 <roboguy_> ah
15:12:45 <delcici> I've been spoilt senseless by haskell on a side project
15:13:10 <delcici> working with python @ work seems like such a chore now
15:13:17 <roboguy_> onhas12: once you get it installed okay, all that stuff should be fine
15:25:01 <catgocat> @pl sortXss xss = sortBy step xss     where step a b = length a `compare` length b
15:25:01 <lambdabot> (line 1, column 51):
15:25:01 <lambdabot> unexpected " "
15:25:01 <lambdabot> expecting operator
15:29:58 <catgocat> I am defining a new function intersperse, how do I hide the base's function??
15:30:15 <catgocat> I would import Data.List hiding (intersperse) but that would import things that I dont want to import
15:31:01 <Intolerable> just don't import it?
15:31:56 <twopoint718> onhas12: the FPComplete IDE is pretty easy to get up and running and then you don't have to mess with Emacs or Vim if you don't want to.
15:33:13 <onhas12> Thanks, twopoint718 I want my code on my computer though not in the cloud at the end of the day. 
15:34:15 <arkeet> m
15:34:23 <arkeet> thinking about other formulations of Applicative
15:35:36 <nullvoid8> catgocat: import Prelude hiding (...)
15:35:43 <catgocat> good
15:36:08 <arkeet> (..)
15:36:12 <arkeet> er
15:36:15 <arkeet> never mind.
15:36:19 <nullvoid8> imagine every haskell file has an "import Prelude" at the bottom of the list of imports
15:36:23 <arkeet> at the top*
15:37:02 <nullvoid8> sure, I can't remember the redundant name rules
15:37:15 <twopoint718> onhas12: I understand, just seems that it is often overlooked in the accounting of Haskell IDEs.
15:37:28 <arkeet> I only remember because there's a hack involving putting "import Prelude" at the bottom of the import list.
15:38:00 <nullvoid8> arkeet: I thought that putting imprt Prelude in just remvoed the implicit?
15:38:10 * hackagebot happstack-server-tls-cryptonite 0.1.1 - Extend happstack-server with native HTTPS support (TLS/SSL)  https://hackage.haskell.org/package/happstack-server-tls-cryptonite-0.1.1 (blaze)
15:38:15 <arkeet> it's normally implicitly at the top.
15:38:23 <arkeet> it's to suppress some redundant import warnings.
15:38:30 <arkeet> when migrating to 7.10
15:38:58 <nullvoid8> ah
15:43:53 <arkeet> never mind this won't quite work.
16:04:04 <Zemyla> It occurs to me that Haskell is Turing-complete with just pure and <*>.
16:04:43 <EvanR> yes use the identity applicative
16:05:16 <ely-se> 1) Think more about it. 2) Write an overly boring paper. 3) ??? 4) Profit!
16:06:00 <voidzero> sounds fraudulent :P
16:06:57 <voidzero> 3. "lie, bribe, extort"
16:07:15 <voidzero> ok that was probably funnier in my head.
16:12:57 <Zemyla> EvanR: I was thinking the function applicative, as pure and (<*>) form the K and S combinators.
16:14:41 <ttt_fff> >let a = 2
16:14:42 <ttt_fff> >a 
16:17:35 <sccrstud92> > a
16:17:37 <lambdabot>  a
16:25:05 <Zemyla> :t pure (<*>) <*> pure
16:25:06 <lambdabot> Applicative f => (a -> b) -> f a -> f b
16:26:46 <galois_dmwit> Zemyla: I'm not sure that the standard technique for proving Turing completeness with K and S respects the kind of typing Haskell does.
16:27:41 <Zemyla> True. You can't write fix with just K and S. You need newtypes.
16:27:54 <mniip> K and S in simply typed LC always terminate
16:28:15 <mniip> (they don't in untyped LC)
16:39:47 <mniip> S(K(S(SKK)(SKK)))(SK(K(S(SKK)(SKK))))
16:40:21 <mniip> slightly longer than the wikipedia-provided one, the Y combinator
16:40:47 <fatfrank> What's the topic ATM
16:43:05 <mniip> fatfrank, SK-calculus, and typed vs untyped LC I assume
16:45:55 <fatfrank> Well that is something that makes my brain hurt. 
16:46:28 * mniip still wonders what the Hask^op notation means
16:46:53 <fatfrank> Operator man. 
16:47:26 <fatfrank> Has to be. Only explanation.
16:48:47 <fatfrank> Op is opposite functor?
16:54:10 <PhantomBALR> what is haskell similar to?
16:54:16 <quux> haskell
16:54:20 <PhantomBALR> ^
16:56:51 <Cale> PhantomBALR: Definitely Clean. Idris is also similar, though it has dependent types, uses strict evaluation by default, and its type classes work a bit differently.
16:57:17 <Cale> PhantomBALR: A bit more distantly, everything in the ML family of languages, like SML and OCaml.
16:57:35 <arahael> What about F#?
16:57:49 <Cale> Sure, I'd include it as a member of the ML family.
16:57:52 <ely-se> PhantomBALR: PureScript
16:58:13 * hackagebot manifolds 0.1.3.1 - Working with manifolds in a direct, embedding-free way.  https://hackage.haskell.org/package/manifolds-0.1.3.1 (leftaroundabout)
16:58:48 <ely-se> arahael: F# is similar in that both curry by default and offer discriminated unions, but not much more than that
16:59:05 <arahael> ely-se: And ML-style typing, iirc.
16:59:16 <ely-se> type inference in F# is extremely limited
16:59:58 <arahael> ely-se: Apparently it's limited when using the classic .NET (OO) API.  But if you're using idiomatic F# functions, it's supposed to be good.
17:00:40 <hodapp> ely-se: have you used F# much?
17:01:34 <ely-se> Written a few applications in it.
17:01:38 <ely-se> But I don't use it every day.
17:02:01 <hodapp> ely-se: ah, okay. What are your opinions of it from that?
17:02:07 <hodapp> both tooling, and language-wise
17:03:03 <ely-se> I'm not really a fan of the .NET ecosystem. As always, everybody (all tutorials, documentation and tools) assumes you're using Visual Studio.
17:03:18 <ely-se> other than that it's pretty nice
17:03:29 <ely-se> if I had the requirement to target .NET, I'd certainly use F#
17:05:15 <hodapp> ely-se: interesting, despite Mono existing and CLR being open-sourced?
17:05:34 <hodapp> I used Visual Studio in a professional capacity for 5-6 years and really never liked it
17:05:34 <ely-se> that was only recently
17:05:45 <ely-se> Visual Studio isn't Vim. It's stops there for me.
17:05:49 <hodapp> hah
17:06:14 <arahael> As an IDE, it's pretty good these days, though.
17:06:17 <arkeet> there's a plugin that makes the editor vim-like.
17:06:23 <ely-se> There are Vim plugins, but they don't use my Vim configuration.
17:06:26 <arkeet> but it's not vim.
17:06:28 <arkeet> yeah.
17:06:28 <arahael> That plugin only gives the most minimal vi keybindings.
17:06:38 <arkeet> nah it's not that minimal.
17:06:41 <arkeet> I forget what it's called.
17:06:45 <hodapp> For me, it just has too much "Just Works"(tm) stuff, and my problem with stuff that just works is that when it fails to work, it always does so in the most clusterfucked, undiagnosable ways possible.
17:06:54 <arkeet> also it confuses everyone else who tries to use visual studio on my machine.
17:07:01 <arahael> arkeet: Does it have :retab?
17:07:11 <arkeet> let's find out.
17:07:19 <arahael> arkeet: And :vsplit
17:07:27 <hodapp> Then I'm crawling message boards where 99% of the replies are from people who have literally no idea how *anything* works under the hood, and so all they can recommend is button-pushing or reinstalling.
17:07:31 <arkeet> I doubt it has vsplit
17:07:53 <ely-se> Here's some awful code I refactored today: https://gist.github.com/rightfold/b13170d732d3f4098fc1
17:08:14 <arkeet> often enough I just use actual vim 
17:08:20 <arahael> arkeet: Then the vim functionality is a lie. :)
17:08:36 <hodapp> arahael :P
17:10:10 <pavonia> ely-se: What language is that?
17:10:13 <ely-se> F#
17:10:16 <arkeet> anyway it has decent enough code completion/search kind of stuff and I could never manage to get ctags to work on here so.
17:13:18 <ely-se> I have a ctags cronjob :2
17:13:20 <ely-se> :3
17:31:40 <EvanR> mniip: the category opposite to Hask
17:31:55 <EvanR> dual to Hask
17:32:12 <EvanR> Hask with all the arrows flipped
17:35:55 <mniip> EvanR, what is the purpose of such a thing though?
17:36:15 <EvanR> to be a place where all the opposite facts are true
17:36:38 <EvanR> comonads are monads, coalgebras are algebras
17:37:54 <EvanR> your types are checked there on opposite day
17:40:52 <EvanR> to be honest i have no idea
17:53:08 <PhantomBALR> never worked with a functional language... my head hurts...
17:55:50 <benzrf> thats normal PhantomBALR
17:56:22 <dramforever> PhantomBALR: did your head hurt when first working with a "regular" programming language?
17:56:26 <dramforever> pretty sure it did
17:56:47 <PhantomBALR> dramforever: I don't remember. That was 1st grade.... I'm 25 now...
17:57:03 <dramforever> PhantomBALR: pretty sure it did hurt
17:57:03 <slack1256> programming languages suck.
17:57:08 <PhantomBALR> :P
17:57:08 <slack1256> well computers also suck
17:57:18 <dramforever> slack1256 += 1024
17:58:02 <slack1256> (mutable addition of 2^10 also sucks)
17:59:23 <PhantomBALR> so variables can't change?
17:59:28 <PhantomBALR> ever?
17:59:54 <slack1256> But if that article of MIT showing that learning a new natural/formal language or learning a instrument is one of the most extrenious activities a brain can do. It's no wonder why is so difficult
18:00:49 <mniip> PhantomBALR, depends on what you mean by variables
18:01:00 <slack1256> variables in haskell are more like placeholders than cells on memory.
18:01:07 <mniip> and what you mean by 'change'
18:01:15 <dramforever> PhantomBALR: variables in haskell don't change
18:01:24 <dramforever> those that change are called "references"
18:01:49 <mniip> in math, in "f(x) = x*2", x is a variable
18:01:58 <mniip> and it "changes" depending on what the function is applied to
18:02:19 <mniip> haskell only has those kind of variables
18:02:19 <dramforever> mniip: oh that also makes sense
18:02:40 <PhantomBALR> so how do you define a reference?
18:02:43 <mniip> those that dramforever is talking about is advanced IO heresy that you shouldn't touch for now :)
18:03:01 <PhantomBALR> lol :P
18:03:01 <dramforever> and you probably should never touch them =)
18:03:09 <PhantomBALR> Ok so question coming...
18:03:13 <mniip> no there are reasonable use cases
18:03:40 <dramforever> s/=)/=P/
18:03:50 <PhantomBALR> IF you define a function, and you use a variable inside it. Does calling the function use the same value stored in that variable? 
18:03:50 <dramforever> mniip: sure there are
18:04:13 <PhantomBALR> wait.
18:04:17 <dramforever> PhantomBALR: that depends on what "a variable" is
18:04:18 <mniip> PhantomBALR, what?
18:04:26 <PhantomBALR> omg I can't type haha
18:04:40 <PhantomBALR> That question made not sense
18:04:49 <PhantomBALR> no*
18:04:50 <mniip> p much
18:05:59 <PhantomBALR> ok second try...
18:06:19 <PhantomBALR> nvm
18:06:30 <mniip> yes
18:07:55 <mniip> PhantomBALR, lack of explicit state lets us reason a lot more about programs
18:08:58 <mniip> er
18:09:04 <mniip> lack of implicit state
18:09:39 <PhantomBALR> mniip: Ok so in my realm of languages, you can define a program with variables in it. Once you call that function you do something with the variable in it.  If you call the function again, the variable starts over and is empty to use again. Does haskell work the same way inside functions?
18:09:52 <mniip> you can have explicit state, by passing variables around recursively, and then there's an abstraction (that you'll know about when you're older) that lets us wrap it nicely
18:10:20 <mniip> PhantomBALR, are you familiar with the concept of pure functions
18:10:39 <dramforever> PhantomBALR: "empty"
18:10:52 * dramforever cries, "EMPTY??"
18:11:08 <PhantomBALR> trying to use regular english haha...
18:11:13 <dramforever> sorry for being a bit impolite
18:11:24 <PhantomBALR> mniip: no I not familiar with pure functions.
18:11:34 <dramforever> PhantomBALR: that question doesn't make sense in haskell
18:11:36 <PhantomBALR> no worries... newbie frustraition. I understand
18:11:55 <dramforever> PhantomBALR: oh man...
18:12:05 * dramforever is kinda excited, sorry
18:12:13 <mniip> PhantomBALR, a function is pure when its output (returned value) only depends on the combination of input values (arguments), and nothing else
18:12:26 <mniip> think mathematical functions
18:12:28 <dramforever> PhantomBALR: which language did you come from?
18:12:36 <dramforever> *language(s)
18:13:04 <mniip> as such, pure functions cannot: have inout arguments, use global variables, do input-output stuff
18:13:10 <PhantomBALR> PhantomBALR: C#, Java, Python, Javascript, C...
18:13:26 <mniip> yeah the classcal imperative set then
18:13:29 <PhantomBALR> Yeah
18:13:38 <mniip> see above though
18:13:51 <PhantomBALR> Trying to learn something new hahat @mniip
18:13:56 <PhantomBALR> ok.
18:14:08 <mniip> back to pure functions
18:14:08 <PhantomBALR> gotcha
18:14:16 <mniip> in haskell, all functions are pure
18:14:23 <PhantomBALR> thats scary
18:15:21 * mniip wonders where to continue on from there
18:15:25 <PhantomBALR> haha
18:15:48 <dramforever> PhantomBALR: don't worry everything will makes sense
18:15:52 <PhantomBALR> Ok. So functions only serve the use of manipulating the items you pass to it?
18:15:57 <mniip> yes
18:16:15 <dramforever> PhantomBALR: not exactly manipulate, all it can do is read it and construct something else
18:16:52 <PhantomBALR> ok. Im with ya
18:17:30 <dramforever> this restriction, strange as it may seem, actually solves many problems from their roots
18:17:52 <mniip> in case you wonder how to do the things you're used to,
18:18:06 <mniip> you can actually emulate mutation with purity
18:18:41 <mniip> hm, I already mentioned that above
18:18:48 <dramforever> lemme give you an example
18:19:07 <dramforever> there's a function called rand in C, that returns a random number on each call
18:19:23 * mniip approves example
18:19:58 <dramforever> however, that's not exactly nice to use if you want something other than a global rng
18:20:18 <dramforever> so we made rand_r, that takes a seedp as an inout argument
18:21:17 <mniip> :( didn't go the way I expected
18:21:21 <PhantomBALR> I don't want to bring bad habits into this language haha :)
18:21:32 <PhantomBALR> Neways I need to jump off to eat lunch with the fam. BBL.
18:21:33 <dramforever> (things go weird after this notice) but we still need to manage the memory of the seed ourselves
18:22:04 <PhantomBALR> ty for ya'lls help. Got your names taken down for later :P
18:22:14 <dramforever> and we cannot easily duplicate the seeds
18:22:31 <mniip> oh no, I'm on the list
18:22:35 <mniip> what am I gonna do
18:22:44 <dramforever> PhantomBALR: no don't do that
18:22:49 * dramforever is not ready =(
18:22:52 <PhantomBALR> :P
18:23:14 <PhantomBALR> Catch ya'll later!
18:23:15 * hackagebot mockery 0.3.1 - Support functions for automated testing  https://hackage.haskell.org/package/mockery-0.3.1 (SimonHengel)
18:23:18 <mniip> if you're planning to spend less than 9 hours eating lunch, then you're out of luck
18:23:24 <mniip> :|
18:23:30 <mniip> ...because I'm off
18:23:47 <dramforever> mniip: hey how did you expect it to go?
18:24:12 <mniip> dramforever, lalala rand is impure as it mutates a global state
18:24:25 <mniip> blah blah however haskell has something better, see :t random
18:24:37 <mniip> (by the way TIL rand_r exists)
18:24:52 <dramforever> but impure itself is not the problem
18:24:56 <dramforever> I just expanded on that
18:25:43 <dramforever> IMHO many features of haskell are designed like
18:25:59 <dramforever> "hey, f**k that hard to manage foo stuff, let's get rid of foo"
18:26:10 <dramforever> "when you want foo, do use bar instead"
18:26:51 <mniip> "bar is like burritos"
18:27:12 <dramforever> I just found a good analogy
18:27:29 <dramforever> working with imperative languages is like working with newtonian physics
18:27:46 <Welkin> and haskell is like working with quantum physics :D
18:27:52 <hodapp> dramforever: ...it's what you learn in high school and you spend the remainder of your life figuring out why it's wrong?
18:27:53 <dramforever> whereas working with purely functional ones is like working with relativity
18:28:02 <dramforever> hodapp: sorta
18:28:08 * mniip zZ
18:28:24 <dramforever> and people look at relativity and think "why are you going to use that?"
18:28:42 <mniip> because it's more powerful and general
18:28:43 <dramforever> "mutation? we don't have that" is like "absolute time? we don't have that"
18:28:45 <Welkin> the wave function is going to collapse!! Quickly! Get the Monad!
18:29:36 <Welkin> are monads like pokeballs?!?
18:29:54 <Welkin> wow
18:30:00 <mniip> Welkin, roger that, contravariant functors are still entangled, lift the qubits into the transformer
18:30:02 <Welkin> I should write a monad analogy on that
18:30:21 <dramforever> I don't claim "purely functional is better than imperative", because it isn't true
18:30:39 <dramforever> just like Einstein's theory isn't better than Newton's
18:30:51 <mniip> functional programming can embed imperative programming in a nice way
18:31:02 <dramforever> mniip: the converse is kinda true
18:31:03 <mniip> while imperative programming embeds functional in a very ugly one
18:31:10 <dramforever> only kinda
18:31:32 <mniip> well it depends on the underlying language too I guess
18:31:44 <mniip> first-class functions help a lot
18:31:45 <dramforever> maybe
18:32:48 <mniip> also off
18:32:51 <mniip> really now
18:48:26 <slack1256> "just like Einstein's theory isn't better than Newton's" and "purely functional is better than imperative" are two different kinds of better.
18:48:31 <slack1256> One is the relativity is a better theory than classical because helps to explain more of the world than the other. On paradigms we are concerned about if we can say the same things in a simpler way
18:48:39 <slack1256> oh this isn't -blah
18:54:14 <dramforever> interesting problem http://redd.it/3g6kwo
18:54:33 * dramforever shared it here, in case anyone know how to solve it
18:54:39 <dramforever> *someone knows
19:00:48 <ttt_fff> OMG, using lens + typeclasses together ; this i slike macros ... except theyr'e fucking typed
19:00:50 <Welkin> dramforever: could be a troll
19:00:52 <ttt_fff> haskell fwt
19:00:54 <ttt_fff> ftw
19:01:11 <edwardk> ttt_fff: just discovered classy lenses?
19:01:48 <Welkin> edwardk: classy lenses?
19:01:49 <ttt_fff> edwardk: no, no idea what classy lenses is; but realized I had a bunch of typeclasses that reduced to >> instance (I have a lens of this type) <okay, then you can auto derive this typeclass> where ...
19:02:04 <ttt_fff> edwardk: you have two interested students; care to teach us about classy lens ?
19:02:46 <dramforever> something like instanse HasFoo a where _Foo :: Lens a Foo?
19:02:52 <dramforever> *instance
19:03:17 <ttt_fff> dramforever: damn, that sounds alot like what I'm doing
19:03:33 <ttt_fff> dramforever: do you ahve a ful example? google is showing me lots of girls with classy sunglass LENS, but no haskell
19:03:49 <edwardk> Welkin: data Person = Person { _name :: String, _age :: Int }; makeClassy ''Person; data Employee = Employee { _employeePerson :: Person, _employeeSalary :: Double }; makeClassy ''Employee; instance HasPerson Employee where person = employeePerson
19:04:01 <Welkin> ah, makeClassy
19:04:17 <edwardk> now given bob = Employee (Person "Bob" 23) 40000     you can use bob^.age  directly
19:05:38 <edwardk> because makeClassy ''Person build class HasPerson a where person :: Lens' a Person; name :: Lens' a String; age :: Lens' a Int with default definitions for name and age that precompose the person lens, and supplied an instance HasPerson Person where person = id
19:06:17 <ttt_fff> so it shorteened bob ^. employeePerson ^. age down to bob ^. age ?
19:06:21 <edwardk> yep
19:06:42 <edwardk> and you can use bob^.person  instead of employeePerson if you want to get the person out, since its overloaded too
19:07:31 <edwardk> basically this is very useful whenever you want to deal with lots of nested fields and expect there to be only copy of a sub-structure contained. when there is an is-a relationship rather than a has-a relationship between structures
19:07:51 <edwardk> now, with this we can start doing things with 'multiple states' as well.
19:08:01 <dramforever> edwardk: great that's basically what I was talking about wasn't it
19:08:08 <edwardk> foo :: HasFoo s, HasBar s, MonadState s m => ...
19:08:17 * hackagebot halive 0.1.0.6 - A live recompiler  https://hackage.haskell.org/package/halive-0.1.0.6 (lukexi)
19:08:18 <edwardk> can now just use the lenses for foo and bar with the stateful combinators
19:08:20 <ttt_fff> edwardk: oh, this is difernt from what I want, I have multiple instances, but they have different types, and can be distinguished by types, i.e. an envLookup / envInsert which is the 'union' of 4 maps of (k1, v1) (k2, v2) (k3, v3) (k4, v4)
19:08:24 <edwardk> and you glue it together at the end
19:10:52 <Welkin> tonight is a good night to start on those lens tutorials
19:14:20 <ttt_fff> edwardk: is cloneLens resolved at compile time or at runtime?
19:14:43 <edwardk> Welkin: i'm not dealing with this right now, i have enough other things to do
19:15:03 <edwardk> i have a talk in a week, and a bunch of transient code i need to finish before it falls out of my head
19:15:19 <Welkin> edwardk: I meant for me to read tutorials
19:15:26 <edwardk> ah =)
19:15:29 <edwardk> sorry
19:15:32 <edwardk> raw nerve =)
19:15:40 <Welkin> :)
19:16:09 <edwardk> i also assumed i was in #haskell-lens. woops
19:18:18 * hackagebot type-unary 0.2.19 - Type-level and typed unary natural numbers, inequality proofs, vectors  https://hackage.haskell.org/package/type-unary-0.2.19 (ConalElliott)
19:18:50 <Welkin> Pamelloes: o/
19:53:19 * hackagebot mockery 0.3.2 - Support functions for automated testing  https://hackage.haskell.org/package/mockery-0.3.2 (SimonHengel)
20:37:51 <ttt_fff> https://gist.github.com/anonymous/6127bdd6b0b3b1df5d45 <-- does not compile; please help; involves Lens
20:39:25 <shachaf> η ans is a syntax error.
20:39:51 <shachaf> Please post real Haskell code if you want real help.
20:40:07 <geekosaur> that pastebin is, um, unicodified. η smells like `return' to me
20:40:21 <shachaf> ∵ is also an error.
20:40:21 <ttt_fff> sorry, that is a return
20:40:26 <ttt_fff> and that is where
20:40:29 <shachaf> η means many things.
20:40:30 <geekosaur> (it is highly annoying to turn that back into Haskell though)
20:40:30 <ttt_fff> sorry, vim views
20:40:32 <ttt_fff> let me fix that
20:41:16 <shachaf> Anyway, try adding types.
20:41:22 <ttt_fff> https://gist.github.com/anonymous/dc86a4cbb4dfe2fe749a <-- plesae help ;; gentlemen, is this better
20:42:14 <shachaf> "gentlemen"?
20:42:26 <ttt_fff> yes
20:42:32 <geekosaur> that said, I think the problem is you have an MPTC with no fundeps and it's not able to figure out the right type. but it doesn't help that the only type in that binding is a result type...
20:42:45 <geekosaur> also "thanks" for making gender assuptions
20:43:27 <ttt_fff> shachaf, geekosaur: if I guessed either of your gender wrong, correct me, and I will apologize
20:43:43 <geekosaur> hhow about not being stupid about it in the first place?
20:43:44 <shachaf> I'm not in the mood to help you, so you shouldn't be addressing me anyway.
20:44:11 <shachaf> sigh
20:45:06 * geekosaur should not really be online at this point anyway --- and this particular question is straining my limits anyway :/
20:45:14 <ttt_fff> shachaf: whatever you're dealing with, I wish you the best
20:46:48 <ttt_fff> ah, I think I figured out what is wrong
20:56:51 <kristof> wow
21:00:17 <sw17ch> Can someone who uses stack check if it installs hspec-discover (the binary) properly when you install hspec?
21:04:51 <sw17ch> Oh, weird, it works if i install the hspec-discover package directly, but not if dependencies have binaries.
21:19:41 <ttt_fff> > let t! = 3 in t!
21:19:43 <lambdabot>  <hint>:1:8: parse error on input ‘=’
21:20:02 <ttt_fff> what is convetion of a "lookup" that instead of returning (Maybe v), returns a "v" // and fails if it can't find it
21:22:12 <sccrstud92> what do you mean by "convention"?
21:22:19 <ttt_fff> do I call it lookupX ?
21:22:21 <ttt_fff> or lookupY 
21:22:26 <sccrstud92> :t M.!
21:22:27 <lambdabot> parse error on input ‘M.!’
21:22:31 <sccrstud92> :t M.(!)
21:22:32 <lambdabot> Not in scope: data constructor ‘M’
21:22:43 <ttt_fff> is there some prefix or suffix that I can add to the name to indicate taht either it finds it or it fails instead of returning a Maybe ?
21:22:46 <sccrstud92> anyway its called !
21:22:48 <sccrstud92> and its in MAp
21:22:55 <sccrstud92> Data.Map
21:24:05 <sccrstud92> @hoogle Map k v -> k -> v
21:24:05 <lambdabot> Data.Map.Lazy (!) :: Ord k => Map k a -> k -> a
21:24:05 <lambdabot> Data.Map.Strict (!) :: Ord k => Map k a -> k -> a
21:24:05 <lambdabot> Data.Map.Lazy findWithDefault :: Ord k => a -> k -> Map k a -> a
21:25:15 <ttt_fff> sccrstud92: noted, thanks!
21:38:23 * hackagebot machinecell 2.1.0 - Arrow based stream transducers  https://hackage.haskell.org/package/machinecell-2.1.0 (HidenoriAzuma)
21:51:59 <ttt_fff> https://gist.github.com/anonymous/5bbd1edc5a867dfb0b40 <-- need help fixing this
21:52:15 <ttt_fff> please instruct on the number of goats / chickens / sheep I need to slaughter  + how many dragon tears I need to make this compile
21:54:05 <johnw> ttt_fff: the reason this doesn't compile is a little complex
21:54:19 <ttt_fff> johnw: if you have time, I have time
21:54:27 <johnw> basically, your use of hasEnv is in a context where both 'k' and 'v' are not fixed
21:54:30 <ttt_fff> also, knowing the solution would be helpful :-)
21:54:35 <johnw> 1) you have no argument that uses v
21:54:42 <ttt_fff> true, since it's delete
21:54:46 <johnw> 2) your argument 'k' is not involved with hasEnv
21:54:49 <johnw> yes
21:54:53 <ttt_fff> is there some haskell extension I can use to specify waht v is ?
21:55:05 <johnw> to solve #1, you either have to use FunctionalDependencies, or type families, or a proxy argument
21:55:39 <ttt_fff> but I can't use functional dependencies, k, v, and outer are all free, no two of them determine the third
21:55:50 <johnw> then you'll need a proxy argument
21:55:59 <johnw> so that a use of envDelete can fix 'v'
21:56:15 <ttt_fff> http://stackoverflow.com/questions/27044209/haskell-why-use-proxy ?
21:56:27 <johnw> yeah, exactly that kind of proxy
21:56:45 <johnw> think of proxy as a way of "passing" type choices
21:56:54 <johnw> envDelete :: k -> proxy v -> outer -> outer
21:57:04 <johnw> now I can call it with: envDelete myKey (Proxy :: Proxy myValue) outer
21:57:07 <ttt_fff> this sounds lazy, but can you hack my code to work with proxy, then I can play with working code and understand how it works?
21:57:08 <johnw> and now we know what 'v' is
21:57:13 <johnw> that is too lazy
21:57:25 <ttt_fff> i.e. it's better to take code that ghc compiles, change it, see how it breaks, rather than keep on getting breaking code with no idea if I'm gettoing closer to 'working code'
21:57:28 <johnw> also, it doesn't fix #2
21:57:51 <ttt_fff> wait, I need to fix #1 and #2 ?
21:57:56 <johnw> you sure do
21:58:08 <ttt_fff> why does envGet work?
21:58:15 <ttt_fff> envGet seems to provide even less than envDelete
21:58:25 <johnw> envGet is fixed by type inference
21:58:26 <ttt_fff> oh, envGet specifieid k
21:58:27 <dramforever> ttt_fff: remove code so that the code compiles, and add code back until it no longer compiles
21:58:30 <dramforever> investigate why
21:58:45 <johnw> same with envLookup
21:58:47 <dramforever> ^ my workflow when something doesn't compile and the reason isn't obvious
21:59:05 <johnw> in general, if you have type variables in a type class, every one of them must appear, or else you run into this exact problem
21:59:12 <ttt_fff> dramforever: the problem is, I don't have a 'working state for envDelete" -- i.e. I don't know what type signatures I need to ADD to make it work, so I can't 'binary search'
21:59:23 <ttt_fff> alright, tell me about #2
21:59:25 <johnw> now, for #2
21:59:26 <ttt_fff> I'll work on #1 later
21:59:33 <dramforever> oh then you already located the problem
21:59:46 <johnw> you're using hasEnv, but there's no reason to believe that the instance you're in is the same as the instance for that hasEnv
22:00:03 <ttt_fff> johnw: yes, I ran into this exact problem, when I had a type class that was k, v, outer, Monad
22:00:07 <johnw> for example, there's nothing stopping a Monoid instance from using another Monoid
22:00:20 <ttt_fff> and hashEnv only depends on k, v, outer ... and it was like "dude, you it can be any arbitrary moand" ... and I was like ... damn it
22:00:40 <johnw> so, you have to know k and v, thus solving #1; and then you have to relate your use of hasEnv to your k, v and outer
22:01:19 <johnw> I think this could be done with ScopedTypeVariables, and an explicit type signature: (hasEnv :: ALens' outer (DM.Map k v))
22:01:28 <ttt_fff> scopedtype varaible sounds great
22:01:34 <johnw> that should "connect" the k, v and outer
22:01:41 <ttt_fff> what should I be reading, besides this SO post? can you give me a list of terms to read up in the GHC manual?
22:01:48 <johnw> about what, proxies?
22:02:29 <buckmaster> hey, does anyone have a link to any sort of discussion about teaching monads by teaching join instead of bind? or any opinion on the same? I recently realised that `bind f` is `join . fmap f`, and join seems to me to be much easier to explain
22:02:34 <ttt_fff> whatever it takes to get this to work; proxies, scoped type varaibles, etc ...
22:02:46 <johnw> buckmaster: I think about Monads in terms of join
22:02:53 <buckmaster> I do too, now
22:02:57 <johnw> buckmaster: and whenever i write a new Monad instance, I think about how I'd implement join first
22:03:14 <johnw> in fact, sometimes I do that, and then use equational reasoning to translate it to its bind definition
22:03:25 <ttt_fff> https://wiki.haskell.org/Scoped_type_variables looks trivial
22:03:26 <buckmaster> that's actually what I'm struggling with. List and Maybe are easy, but what would IO's join look like?
22:03:54 <johnw> if you think of IO as State RealWorld a...
22:04:04 <johnw> you're transitioning the machine from one RealWorld to another
22:04:20 <johnw> that's not accurate enough to be true, but it's a rough sketch
22:06:55 <ttt_fff> johnw: can you point me to one resource on how to learn how to use Data.Proxy? There's Data.Proxy hackage pages, with no examples, and an overcomplicated SO answer
22:07:09 <johnw> it's unfortunate, given how simple proxies are
22:07:18 <johnw> so, let's first talk about what a proxy IS
22:07:34 <johnw> it's a value of any type that we don't care anything about; we ONLY care about the type
22:07:44 <johnw> the value is just a "proxy" for the type
22:07:56 <ttt_fff> okay, this https://gist.github.com/anonymous/c6ff645a76fb3fa92d28 <-- my minimal failure case
22:08:04 <ttt_fff> proxy is just ... data Proxy a = Proxy
22:08:06 <ttt_fff> right
22:08:20 <johnw> so, if I accept a proxy argument, I've given you a way to communicate type information to me
22:08:34 <johnw> it's like a phantom type that's the phantomest
22:08:40 <ReinH> heh
22:08:48 <ReinH> ttt_fff: Do you understand phantom types?
22:08:50 <johnw> since phantom types are usually for types with real values
22:08:51 <ttt_fff> data Proxy a = Proxy, ... this let sme write (Proxy :: Int) without giving you an int, sure
22:08:53 <ReinH> That might be a better place to start
22:09:02 <johnw> Proxy :: Proxy Int
22:09:23 <ttt_fff> ReinH: just found https://wiki.haskell.org/Phantom_type ... so, no, I don't get Phantom Types
22:09:29 <johnw> thus, you have a way to all peolpe to pass you a 'v', without needing to create an object of type 'v'
22:09:29 <ttt_fff> johnw: I'm with you so far
22:09:37 <ttt_fff> johnw: okay, with you so far
22:09:39 <johnw> s/to all peolpe/to tell people
22:09:42 <buckmaster> johnw: actually that makes sense. I should go through and figure out how I'd join State and that might make a lot more sense :)
22:09:44 <johnw> and that's it, that's all there is to proxies
22:09:45 <ttt_fff> because "Proxy :: Proxy a" for all a
22:09:57 <ttt_fff> "Proxy" constructs "Proxy a" for arbitrary a, 
22:10:15 <johnw> yeah, using them almost always inolves a type signature to fix 'a'
22:10:42 <johnw> in your particular case, you need a way for your user to communicate to you what 'v' is
22:10:55 <ReinH> Hmm, what's the most efficient way to turn a lazy bytestring into a Data.Vector.Unboxed Word8? Or Storable would work, I suppose.
22:10:56 <ttt_fff> yes, I need to specify what v is
22:11:07 <ReinH> Storable should be possible with some unsafe magic perhaps
22:11:12 <ReinH> oh, no, not with lazy
22:11:59 <ReinH> But maybe toStrict and then some magic
22:12:33 <ttt_fff> https://gist.github.com/anonymous/ae9f9ec3e19dde133d75 <-- still does not compile; DP is Data.Proxy
22:12:44 <ttt_fff> I tried shuffling in what 'v' is by specifying a DP.Proxy v
22:12:51 <johnw> I need the new error
22:13:30 <ttt_fff> omg, adding scoped type variables fixed it
22:13:42 <ttt_fff> I think the problem is that the k/v in the body of the code were 'free' and not 'linked' to the k/v in the type sig
22:13:50 <johnw> exactly
22:13:50 <ttt_fff> but adding scoped type variables fixed it
22:14:00 <johnw> ScopedTypeVariables is necessary to relate the two
22:14:06 <ttt_fff> why is scopedtypevaraibles not by default?
22:14:16 <johnw> it can be cumbersome
22:14:33 <ttt_fff> okay, now that I have gotten this working
22:14:40 <ttt_fff> (1) thanks for you time / patience
22:14:53 <ttt_fff> (2) I want the minimal answer: do I need both Proxy + ScopedTypeVariables, or is there an easier way to pull this off?
22:15:11 <ttt_fff> with right scping, I should be able to avoid the Proxy v and have the 'v' in the body refer to the outer 'v
22:15:17 <johnw> to do what this example is trying to do, that's the most basic way to solve it
22:15:23 <johnw> the next way up the ladder is type families
22:15:30 <johnw> and then up to functional dependencies, which breaks your use pattern
22:15:34 <johnw> type families may also
22:15:45 <ttt_fff> wait wait, let's not get to tyep families yet
22:15:48 <johnw> there really is no outer v
22:15:56 <ttt_fff> I think I just solved it without data.proxy, using only typed scoped variables
22:16:01 <johnw> yes?
22:16:15 <ttt_fff> https://gist.github.com/anonymous/d89ef4df2314e5c9ef16 works fine
22:16:19 <johnw> ah, did ScopedTypeVariables relate the instance's v to your inner v?
22:16:25 <ttt_fff> I believe it is linking the 'v' in the body to the 'v' in teh instance declaration
22:16:31 <johnw> very cool, you just taught me a new trick
22:16:53 <ttt_fff> clearly, you should answer all my future #hskell questions
22:17:06 <johnw> answering questions here is indeed an excellent way to learn
22:17:19 <ttt_fff> alright, if you still have time, want to let me know when I'm goign to run into the limits of scoped type varaibles, and will want to ue type families ?
22:17:38 <johnw> scoped type variables don't really have limits that I'm aware of
22:17:51 <sccrstud92> what about colimits?
22:18:11 * sccrstud92 is just kidding
22:18:11 <ttt_fff> https://wiki.haskell.org/GHC/Type_families <-- is this type families?
22:18:14 <johnw> you'll discover what's annoying about them, if you leave them on all the time :)  but it may be a while until you run into it
22:18:19 <johnw> yeah, you don't need type families, but those are they
22:18:23 <johnw> sccrstud92: :)
22:19:23 <johnw> buckmaster: State is a really good one to master; after that, Cont
22:19:45 <buckmaster> thanks! I'll have a go
22:22:25 <EvanR> oh no i missed a discussion about how variables cant change
22:22:36 <EvanR> worst terminology ever!
22:22:41 <johnw> EvanR: such discussions rarely change either ;)
22:23:09 <dramforever> idea: stop talking about variables, haskell doesn't have them
22:23:18 <EvanR> it has many kinds of variables
22:23:25 <dramforever> talk about "references" and "identifiers" instead
22:23:27 <EvanR> MVar TVar
22:23:28 <ttt_fff> johnw: ha! I just ran into another case, where scoped type varaibles did not suffice, and I did have to use Proxy
22:23:30 <johnw> variables != things that vary their definition
22:23:33 <EvanR> references doesnt really help things
22:23:38 <ttt_fff> this was basically when an function in class Foo wanted to call a function in class Bar
22:23:41 <dramforever> EvanR: that really should be called references
22:23:50 <Zekka> How about type variables?
22:23:59 <EvanR> why would a reference be a good thing to call mutable cells?
22:24:01 <dramforever> they should be called type identifiers
22:24:11 <Zekka> dramforever: But they're not the only thing that can identify a type
22:24:21 <dramforever> EvanR: okay call them mutable cells
22:24:26 <dramforever> Zekka: ?
22:24:50 <dramforever> oh "constant type variables" and "universally quantified type variables"
22:24:50 <Zekka> dramforever: Well, the actual name of a type identifies a type
22:25:03 <Zekka> "Identifier" also already means something wrt syntax
22:25:05 <dramforever> oh man, ExplicitForall helps a lot
22:25:11 <dramforever> Zekka: sigh
22:25:24 <EvanR> what about free variables, do they change? 
22:25:45 <EvanR> too many variables
22:25:45 <dramforever> EvanR: they should be called free identifiers
22:26:00 <dramforever> and they identify the stuff they are eventually bound to
22:26:07 <EvanR> parameter maybe
22:26:13 <johnw> dramforever: just think of "variable" in the mathematical sense, rather than the imperative programming world sense
22:26:36 <dramforever> johnw: sadly that doesn't make sense for imperative programmers
22:26:42 <johnw> I don't really need it to
22:27:01 <Zekka> dramforever: Isn't there already a history of calling variables that can have values 'variables' re the lambda calculus?
22:27:04 <dramforever> well, my idea is about how to clear up confusion
22:27:05 <EvanR> right, algebra variables, those dont change, or do they
22:27:30 <Zekka> I think 'identifier' is kind of confusing because it's an overloaded term that afaik has no history of being used this way
22:27:31 <dramforever> and the idea is remove confusion by using different names
22:27:34 <arahael> EvanR: Depends on what you mean by "change".
22:27:45 <Zekka> it would be kind of like calling them "values" because they stand in for a value
22:27:45 <dramforever> Zekka: that's why we should use it
22:27:49 <EvanR> variables in lambda calculus are just syntax, rather than references or cels
22:28:04 <EvanR> substitution acts on the identity of the variable rather than the contents
22:28:38 <Zekka> there's an argument that they do stand in for a value, but "value" already has a different meaning that makes it a confusing term to use
22:28:56 <EvanR> adding that would add nothing to LC
22:28:56 <johnw> mathematical "variables" have had a clear meaning for centuries; I'm not sure it needs to be changed now because imperative programmers feel confused
22:29:49 <dramforever> sigh
22:29:50 <johnw> I think the real error is confusing denotational and operational semantics, and that should be corrected by education, rather than adding terminology
22:30:02 <EvanR> whenever "imperative programmers" get confused by this, i get confused by the "math" version 
22:30:18 <dramforever> screw it
22:30:51 <Zekka> dramforever: Do you feel like we're not getting you?
22:31:03 <Zekka> Because I *think* I'm getting you, I just think there's an overriding reason not to use the terminology you're suggesting
22:31:07 <dramforever> no...I just realized that it's still too hard
22:31:12 <johnw> I guess C variables are really labels, in the sense of being names for memory addresses
22:31:16 <dramforever> Zekka: yes I agree with that
22:31:31 <Zekka> I think that ideally we would have a word that doesn't confuse anyone
22:31:40 <dramforever> yeah, ideally
22:31:44 <dramforever> but it's hard...
22:31:44 <Zekka> but I think to accomplish that we would need a familiar word that doesn't have a history of referring to something else
22:31:49 <dramforever> so "screw it"
22:32:07 <EvanR> its always a battle between changing language and changing people to fit the language
22:32:14 <bob_twinkles> Zekka: those sound like mutually exclusive conditions =P
22:32:14 <dramforever> exactly
22:32:47 <Zekka> bob_twinkles: I think a lot of languages have constructs that match one sense of Haskell's 'variable'
22:32:49 <EvanR> variables seems like the natural terminology
22:32:55 <EvanR> i was joking earlier
22:33:01 <buckmaster> what do people do when `cabal run` says you need to re-run `cabal configure` no matter how many times you run configure?
22:33:13 <buckmaster> *how many times you've already run
22:33:28 <bob_twinkles> pastebin the full error?
22:33:45 <Zekka> Like, you could say "constant" if you really wanted to for the ones that aren't in types
22:33:55 <Zekka> You could say "type parameter" for the ones that are in types
22:34:14 <bob_twinkles> personally I like to think of top-level declarations in haskell as "bindings"
22:34:17 <Zekka> But I think those have the problem that they're interpreted as "like [X existing constant], but [Y distinguishing feature]"
22:34:22 <buckmaster> bob_twinkles: http://pastebin.com/AwyLmwyV (this is in a docker container by the way)
22:34:24 <bob_twinkles> dunno if that's really better though
22:34:36 <Zekka> So if you say X is a constant, that implies there are otherwise similar things that aren't constants too
22:34:48 <Zekka> just because that's the common usage
22:34:59 <Zekka> like [X existing construct]*
22:35:49 <bob_twinkles> buckmaster: I'm not a cabal ninja, but I can't imagine that downgrading the cabal version is going to do good things
22:36:23 <buckmaster> I didn't touch the cabal version... no idea where 1.2.3 came from :(
22:36:30 <bob_twinkles> my guess is cabal is looking at the registry when you run configure, and then deciding that it has nothing to do because all the numbers are higher
22:36:30 <buckmaster> *1.22.3
22:36:35 <buckmaster> hm
22:36:48 <Zekka> I doubt the existing names have really been confusing to anyone who was actually serious about learning Haskell though
22:37:06 <buckmaster> where does the cabal version get cached? I've deleted the sandbox several times
22:37:50 <arahael> The most confusing thing for me, learning cabal, was cabal itself.  It's a package. No, it's a binary - no, a library.  Still haven't quite figured it out but installed everything and now I have "cabal". :)
22:39:33 <buckmaster> huh
22:39:50 <buckmaster> if I .cabal-sandbox/bin/cabal configure and then ru the same way it works
22:39:51 <buckmaster> wat
22:40:35 <bob_twinkles> there's cabal the tool (provided by the cabal-install package) and cabal the library, provided by the Cabal package
22:41:09 <arahael> bob_twinkles: Exactly. It's confusing.
22:41:48 <bob_twinkles> also, Setup.hs scripts can do basically anything =D (as can templatehaskell through runIO :: IO () -> Q)
22:41:50 <bob_twinkles> yay security?
22:42:11 <EvanR> lol whats a "constant"
22:42:18 <EvanR> seems like the same thing
22:42:39 <Zekka> EvanR: An alternate term to satisfy people who for some reason find 'variable' objectionable
22:42:45 <bob_twinkles> there isn't really a good (read:backward compatible) solution to the security issues inherent it those mechanisms though
22:45:39 <bob_twinkles> it'd be really nice if template haskell had some thing like openDependencyFile :: Q Handle which handed you a read-only handle to some resource file 
22:45:51 <ddellacosta> so, I'm doing this tutorial the hard way--after I've defined Applicative and Monad instances for EitherIO, and have adjusted the getToken function to work with that type, I'm trying to implement the userLogin function myself vs. copying it as given: https://github.com/kqr/gists/blob/master/articles/gentle-introduction-monad-transformers.md#introducing-side-effects
22:46:02 <bob_twinkles> 'cause 1) you can implement some decent sandboxing in the compiler that way, 2) GHC could properly track those dependencies
22:46:21 <bob_twinkles> and I think that would cover most of the use cases for runIO
22:47:23 <dramforever> bob_twinkles: main = print "LOL" >> defaultMain
22:47:23 <dramforever> sure that's why a trusted package source is crucial
22:47:23 <dramforever> I mean, if you want to be secure
22:47:24 <ddellacosta> but I'm immediately getting confused with the errors I'm seeing, because I'm stumbling over something really basic: runEitherIO $ do { token <- getToken ; case token of { Right domain -> liftIO domain; left -> liftEither left } }domain }
22:47:36 <ddellacosta> whoops, mis-paste
22:47:48 <ddellacosta> I meant: runEitherIO $ do { token <- getToken ; case token of { Right domain -> liftIO domain; left -> liftEither left } }
22:48:10 <ddellacosta> I'm not understanding the types inside the do block. :-(
22:48:40 <ddellacosta> can anyone offer any suggestions on where to start fixing my misunderstanding?
22:48:43 <bob_twinkles> dramforever: for sure, but more security never hurt anyone =P
22:48:52 <dramforever> =)
22:48:52 <bob_twinkles> I'm really more interested in the proper dependency tracking though TBH
22:49:09 <Zekka> bob_twinkles: I'm not sure I'm in favor of anything that would lead people to believe installing untrusted packages is secure!
22:49:20 <Zekka> (Although I'm in favor of making it more secure if we don't tell anyone about it)
22:50:21 <bob_twinkles> heh. It would at least remove the lazy way of reformating hardrives... but they you just whip out unsafePerformIO and it's all for naught
22:50:27 <bob_twinkles> *then you
22:51:42 <bob_twinkles> ddellacosta: it generally helps if you can throw the code and the error you're seeing on something like http://lpaste.net
22:51:53 <ddellacosta> bob_twinkles: sorry, good call--one sec.
22:53:31 <ddellacosta> bob_twinkles: https://gist.github.com/ddellacosta/ab6eca193193a030d1ff
22:54:16 <ddellacosta> I thought I understood what was going on with the types, but clearly I do not.
22:54:51 <ddellacosta> and I suspect someone with experience can look at this and see the probably mind-bogglingly basic thing I'm missing here
22:55:32 <Zekka> ddellacosta: Peeking, won't guarantee anything
22:55:41 <ddellacosta> no guarantees expected. :-)
22:56:52 <ddellacosta> I thought that 'token' would be an Either type at the point I'm using it in the case statement
22:57:57 <Zekka> ddellacosta: getToken is an IO of an Either -- don't you need to turn that IO into an EitherIO or something?
22:58:31 <ddellacosta> getToken is returning EitherIO, so I don't think that's specifically it
22:58:46 <Zekka> Is it an EitherIO of an Either?
22:59:05 <ddellacosta> Zekka: yikes, shouldn't be I don't think
22:59:21 <Zekka> ddellacosta: In that case you won't get an Either out of it -- you'll get whatever is in the Either itself
22:59:28 <ddellacosta> getToken is EitherIO LoginError Text
22:59:33 <ddellacosta> type sig I mean
22:59:40 <Zekka> So what I would do is just operate on whatever value is inside the Either (in this case the Text) -- it'll get automatically propagated for you by the EitherIO monad
22:59:52 <Zekka> That probably means domain <- getToken or something like that.
23:00:25 <Zekka> You won't be able to get an Either of IO actions out of an EitherIO unless you use some conversion function to turn it into one
23:00:48 <Zekka> if you just bind over it you'll get the Text inside and the Either-style and IO-style chaining will happen on their own (specifically, they're provided by (>>=) for EitherIO)
23:01:05 <ddellacosta> Zekka: okay, that is helpful, thanks--I'm going to investigate where my misconception is coming from here.  Think I'm fundamentally confused about the distinction between EitherIO and IO (Either a b)
23:01:49 <Zekka> ddellacosta: An IO (Either a b) uses IO-style chaining to pass your callback an Either value
23:02:05 <ddellacosta> callback?
23:02:07 <Zekka> An EitherIO a b uses Either plus IO-style chaining to pass your callback a b value
23:02:20 <ddellacosta> okay, I'll ponder that
23:02:21 <Zekka> ddellacosta: Yeah, the function on the right side of >>=. You know how the do notation translation works, right?
23:02:35 <ddellacosta> Zekka: yes, I've just never heard the term callback used for that function
23:02:40 <ddellacosta> but I know what you mean now
23:03:08 <Zekka> ddellacosta: I don't think Haskell guys use it that much but it's a very common term in other languages for a function you pass to another function to finish the action you were doing when you called that function
23:04:01 <greves> any recommendations for getting started?
23:04:02 <ddellacosta> oh yeah, that is actually why I was confused--that's the usage I'm most familiar with.  Whereas I've just never heard it used for the right side of the bind function, that's all.  But I see what you mean now.
23:04:49 <ddellacosta> okay, anyways, thanks--will ponder my confusion some more here
23:05:01 * ddellacosta does that all the time while he is learning Haskell
23:05:26 <Taslem> I have a problem and I feel like it could be solved in some way by heterogeneous lists, but I'm not sure how to go about it:
23:06:03 <Taslem> I have a "list" (really more like a tuple) of things, like (Maybe Int, Maybe [String], Maybe Char), for example. I want to turn it into a Maybe (Int, [String], Char)
23:06:58 <Taslem> er, that's not quite right. I mean to say ( (Maybe Int, Int), (Maybe [String], [String]), (Maybe Char, Char) )  ==>  Maybe (Int, String, Char)
23:07:12 <dramforever> what does that do?
23:07:25 <Taslem> where the second values in each pair are used as "defaults" for the first
23:07:33 <Taslem> but the overall result is Nothing is all values in the first are Nothing
23:07:53 <Taslem> without this latter restriction I could just use default over and over
23:08:18 <dramforever> Taslem: do you have different kinds of tuples?
23:08:25 <Taslem> Yes
23:08:26 * hackagebot moesocks 0.1.0.11 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.11 (JinjingWang)
23:08:30 <dramforever> hmm...
23:08:51 <dramforever> hlist looks usable
23:09:01 <Taslem> That's what I figured, but I don't know how to use it for this exactly
23:09:07 <dramforever> me too
23:09:17 <dramforever> why do you have that last restriction?
23:09:25 <dramforever> can you tell me more about your use case?
23:10:04 <Taslem> Sure. Basically it's supposed to be something along the lines of
23:10:34 <Taslem> I have an expression tree and I'm running simplifications on it
23:11:11 <Taslem> there's a `simplify :: T -> Maybe T` that looks (shallowly) at the tree and sees if it matches a rule; otherwise returns Nothing
23:11:50 <Taslem> so I'm using this function with another that tries to traverse the tree. If any part of the subtree simplifies, then we go with that- but if none of them do, then the overall simplification fails and you get Nothing
23:16:07 <ttt_fff> is there any gotchas of using TH with GHCI, or are all the kinks worked out?
23:16:34 <Taslem> as an example of the simplification: http://lpaste.net/138244
23:17:05 <Taslem> much simplified here, of course
23:17:30 * dramforever has no idea how to improve that
23:17:50 <dramforever> wait wait I have an idea
23:18:28 <dramforever> data Status = Changed | Unchanged
23:18:40 <dramforever> data Changable a = Changable Status a
23:19:05 <dramforever> wait no need
23:20:07 <dramforever> instance Monoid Status where mempty = Unchanged; Changed `mappend` _ = Changed; _ `mappend` Changed = Changed; Unchanged `mappend` Unchanged
23:20:14 <dramforever> Taslem: still following me?
23:20:43 <dramforever> hello?
23:20:43 <Taslem> makes sense. It's mappend = (||), mempty = False :P
23:20:56 <dramforever> oh sure, Any is also going to work
23:22:01 <dramforever> hmm there's still a problem
23:22:08 * dramforever is thinking...
23:23:37 <dramforever> oh there's a LensLike for that
23:23:45 <dramforever> http://hackage.haskell.org/package/lens-4.12.1/docs/Control-Lens-Plated.html#v:transformM
23:23:51 <dramforever> and look at Plated
23:24:52 <Taslem> ooh, hm
23:31:50 <Gurkenglas> (??) === http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Maybe.html#v:fromMaybe
23:32:23 <Gurkenglas> okay, flipped.
23:33:01 <dramforever> :t (??)
23:33:02 <lambdabot> Functor f => f (a -> b) -> a -> f b
23:33:13 <dramforever> and name is already taken =)
23:34:03 <dramforever> haskell rule #17712: when you see an exotic operator, it's from lens
23:34:42 <nolrai66> I am pretty sure its further up the list then that. like rule number 17.
23:34:51 <nolrai66> :P
23:36:59 <Gurkenglas> "simplifyTree' n@Num{} = simplify x" <- What's this x?
23:39:20 <Taslem> oops, just a typo. That should be 'n'
23:39:22 <Gurkenglas> Will first f . second g do any unnecessary pointer-copying?
23:40:57 <Taslem> my actual tree type has 20+ constructors, which would obscure the actual design problem, so I went with something similar
23:41:01 <Taslem> *simpler
23:41:46 <joco42> is there a irc channel for stack ?
23:42:13 <joco42> #stack is kinda empty
23:43:34 <joco42> where does stack get the packages from ? i want to install SourceGraph and I run into problems with cabal such as:
23:44:13 <joco42> https://www.irccloud.com/pastebin/pb70RFPa/
23:44:30 <joco42> would this work with stack?
23:48:44 <kakashiAL> I forgot this quote, it was something like:
23:49:04 <kakashiAL> "X is the best programming language and every other good programming language is just a dialect of it"
23:49:11 <kakashiAL> was it lisp?
23:49:42 <chattered> Greenspun's Tenth Rule?
23:49:57 <dramforever> s/best//
23:50:08 <dramforever> s/good//
23:53:47 <joco42> apparently stack has problems with SourceGraph too:
23:53:53 <joco42> https://www.irccloud.com/pastebin/wWTOiuT7/
23:55:34 <Gurkenglas> Taslem, (Plus (Num 0) (Plus (Num 0) Num 1)) won't get simplified right because the second simplification possibility slips past the jump into the children
23:55:43 <Gurkenglas> (I think)
