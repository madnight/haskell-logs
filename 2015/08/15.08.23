00:00:18 <mauke> erisco: it'd be swell if I could somehow pick length = hGetLine
00:00:26 <mauke> ???
00:00:32 <rohansumant> :t words
00:00:35 <lambdabot> String -> [String]
00:00:52 <erisco> mauke, um, I said f = length
00:00:56 <arahael> length . filter (not . isSpace) $ "nice to meet you!"
00:00:59 <rohansumant> > words "a b c"
00:01:00 <lambdabot>  ["a","b","c"]
00:01:02 <mauke> erisco: I said length = hGetLine
00:01:06 <mauke> erisco: they're equally meaningless
00:01:18 <erisco> okay, I don't know what to say then
00:01:39 <mauke> f is a predefined function. it's not a parameter you can "pick"
00:04:01 <erisco> mauke, okay, the wording was not impeccable, but I don't think the intent was unclear
00:04:10 <erisco> > map (fun "length") [a,b,c] :: [Expr]
00:04:11 <lambdabot>  [length a,length b,length c]
00:04:23 * mauke sighs
00:04:53 <erisco> > sum(map (fun "length") [a,b,c] :: [Expr])
00:04:54 <lambdabot>  0 + length a + length b + length c
00:04:58 <mauke> why do people do that? "admit it, you *know* what I'm talking about! you just want to argue!"
00:05:04 <mauke> no, I fucking don't
00:07:40 * hackagebot ihaskell 0.6.5.0 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.6.5.0 (gibiansky)
00:07:40 * hackagebot ghc-parser 0.1.8.0 - Haskell source parser from GHC.  https://hackage.haskell.org/package/ghc-parser-0.1.8.0 (gibiansky)
00:12:40 <erisco> I dunno how to make the length const version work
00:12:46 <erisco> er, length concat
00:13:34 <mauke> > (length . concat) ["nice", "to", "meet", "you"]
00:13:36 <lambdabot>  13
00:13:48 <mauke> if you're asking for symbolic stuff ... hmm
00:13:58 <erisco> yeah
00:14:16 <bycn82> that is too advance for me :( i am newbie here
00:14:23 <int-e> you'd have to spell out the lists.
00:14:42 <bycn82> i am trying to rewrite the fucntion to accept string as parameter directly
00:14:59 <bycn82> from http://lpaste.net/139490 to http://lpaste.net/139491
00:15:18 <mauke> > let nil = var "[]"; append = fun "(++)"; concat = foldr append nil in concat [a,b,c]
00:15:20 <lambdabot>  (++) a ((++) b ((++) c []))
00:15:42 <bycn82> actually string is [Char], right?
00:15:49 <mauke> bycn82: yes
00:15:58 <erisco> bycn82, well, len_words doesn't have type  String -> Int, it is  [String] -> Int, or at least that is what your first one was
00:16:03 <mauke> concat ["nice", "to", "meet", "you"] == "nicetomeetyou"
00:16:10 <bycn82> so i want to loop the string in chars one by one,
00:16:37 <bycn82> yes, in haskell dont have the for loop function, so i will use the recusive.
00:16:43 <erisco> if you want to break the string into words and then sum each word length
00:16:57 <erisco> then just  sum . map length . words
00:17:10 <mauke> length . filter (not . isSpace)
00:17:25 <erisco> :t sum . map length . words
00:17:26 <lambdabot> String -> Int
00:17:36 <mauke> :t length . filter (not . isSpace)
00:17:37 <lambdabot> [Char] -> Int
00:17:47 <erisco> note String = [Char]
00:17:53 <bycn82> erisco: yes, i know, but i am a C guy, so use map function is too amazing for me,
00:18:07 <erisco> well toughen up big boy, this is Haskell now ;)
00:18:19 <mauke> map f [x1, x2, x3, ...] = [f(x1), f(x2), f(x3), ...]
00:18:36 <mauke> "do stuff with each element of a list, collecting the results in another list"
00:19:41 <bycn82> "ab" is same as ['a','b']
00:19:44 <erisco> > map (+1) [1,2,3]
00:19:45 <lambdabot>  [2,3,4]
00:19:47 <erisco> I hope it isn't too amazing
00:20:13 <erisco> bycn82, yes, which is also the same as  'a':'b':[]
00:20:19 <bycn82> erisco: yes, i know how to use map, but when i am facing the problem, sure i wont use map in the beginning.
00:20:32 <erisco> 'a':'b':[]  has the least syntactic sugar
00:20:53 <mauke> (:) 'a' ((:) 'b' [])
00:20:56 <mauke> challenge accepted
00:20:59 <bycn82> help to check http://lpaste.net/139491
00:21:14 <erisco> mauke, I didn't count infix as sugar oO
00:21:19 <mauke> aww
00:21:38 <bycn82> http://lpaste.net/139493
00:21:50 <mauke> bycn82: len_words x:y parses as (len_words x) : y
00:21:56 <mauke> you need len_words (x : y)
00:22:05 <bycn82> but len_words x:y ... i  dont know how to explain this 
00:22:21 <mauke> also, length x is invalid because x :: Char but length takes a list
00:23:00 <bycn82> that means x is the first Char and Y is the rest of the string .
00:23:19 <mauke> > case "hello" of (x : y) -> (x, y)
00:23:20 <lambdabot>  ('h',"ello")
00:23:40 <erisco> if 'x' is a Char, you know the length of that already
00:23:57 <bycn82> yes, i just remove the length x into 1
00:24:18 <mauke> yep
00:24:19 <bycn82> main.hs:6:1: Parse error in pattern: len_words
00:24:24 <erisco> :t let lengthChar x = 1 in lengthChar
00:24:25 <lambdabot> Num a => t -> a
00:24:32 <erisco> would be a rather boring function
00:24:44 <mauke> bycn82: did you see my first reply?
00:25:38 <bycn82> mauke: thanks, yes, i saw it, but actually i dont understand 
00:25:40 <bycn82> http://lpaste.net/139495
00:26:16 <erisco> I think you need parens around the pattern, so  (x:y)
00:26:20 <mauke> what do you not understand?
00:27:23 <erisco> which is a bit misleading because you don't need it when using infix notation, nor when binding in a let
00:27:27 <erisco> (or a where)
00:27:35 * hackagebot dlist 0.7.1.2 - Difference lists  https://hackage.haskell.org/package/dlist-0.7.1.2 (SeanLeather)
00:29:10 <bycn82> mauke: thanks, i got your point
00:29:34 <bycn82> finally, this is my version 
00:29:35 <bycn82> http://lpaste.net/139496
00:29:50 <mauke> yep
00:30:06 <mauke> the next step is to replace x == ' ' by isSpace x
00:30:21 <mauke> (because 'words' splits on more than just ' ')
00:30:28 <erisco> is there more than one space? geez
00:30:31 <mauke> > words "foo\tbar\nbaz"
00:30:33 <lambdabot>  ["foo","bar","baz"]
00:30:38 <erisco> oh, whitespace
00:30:48 <mauke> > filter isSpace [minBound .. maxBound]
00:30:48 <erisco> though I wouldn't be surprised if unicode had more than one space character
00:30:50 <lambdabot>  "\t\n\v\f\r \160\5760\8192\8193\8194\8195\8196\8197\8198\8199\8200\8201\8202...
00:31:26 <erisco> > '\160'
00:31:28 <lambdabot>  '\160'
00:31:32 <erisco> oh you
00:31:33 <mauke> \160 is no-break space
00:31:40 <mauke> \5760 is ogham space mark
00:31:45 <erisco> hm, right, used those all the time in web dev
00:31:51 <erisco> &nbsp; all the things
00:32:35 <mauke> the 8190ies start with {en,em} {quads,spaces} and variants
00:32:43 <bycn82> thanks for all guys, 
00:33:10 <mauke> ... thin space, hair space, zero width space ...
00:33:24 <erisco> can't remember what \v and \f are
00:33:27 <bycn82> the programming language is so enjoyable :)
00:33:31 <mauke> vertical tab, form feed
00:33:53 <erisco> form feed... dunno what that does
00:34:14 <erisco> I am going to wager people aren't using vertical tabs anymore
00:34:20 <mauke> https://en.wikipedia.org/wiki/Page_break#Form_feed
00:34:51 <erisco> okay, so you need a concept of page length for that
00:34:53 <mauke> perl is the only programming language I know that uses C-style escape sequences but doesn't recognize \v
00:35:46 <erisco> I don't want to imagine how \v interacts with layout based languages
00:35:55 <erisco> is it a vertical displacement in the same column?
00:35:58 <bycn82> i dont like perl
00:36:09 <erisco> where does the next line how?
00:36:11 <erisco> go*
00:36:28 <mauke> I think most of them just treat it as horizontal space
00:36:32 <bycn82> perl's function is ....to flexiable.
00:36:37 <mauke> because it's "whitespace" but not \n
00:37:14 <erisco> I guess to behave like a type writer it would jump down n lines in the same column
00:37:25 <erisco> which would be a weird capability
00:37:33 <mauke> "Often, it will also cause a carriage return."
00:37:39 <mauke> but not always!
00:38:00 <erisco> it says that for \f too
00:38:15 <mauke> oops, that's what I meant
00:38:25 <erisco> I guess if you were in an editor then it could give you a blank page, inserting newlines for you
00:38:41 <erisco> I'm often holding enter at the end of a file to move stuff up
00:38:49 <erisco> so I'm not reading the line right above my task bar
00:39:14 <erisco> though it'd have to be \f and then scroll back up
00:39:30 <erisco> \v just sounds like a bad down arrow
00:39:42 <erisco> or a bad page down
00:46:29 <erisco> can I ask cabal to guess my dependencies again?
00:47:15 <ptek> guys, is anyone here using ghci with stack?
00:50:01 <ptek> I have a problem running it
00:50:49 <ptek> When running it on a new project it says: ghc: --interactive can't be used with -prof or -unreg.
00:51:52 <erisco> okay I must be missing something...
00:52:01 <erisco> can I ask cabal to check if my dependencies are correct in .cabal?
00:55:53 <ptek> erisco, i think cabal will tell you this when building the packag
00:56:05 <ptek> erisco, what are you trying to achieve?
00:56:33 <erisco> okay, now it is giving me errors
00:56:36 <erisco> I don't know what changed
00:56:47 <erisco> I guess it didn't pick up my code until I added the exposed module
00:57:37 * hackagebot leksah-server 0.15.0.8 - Metadata collection for leksah  https://hackage.haskell.org/package/leksah-server-0.15.0.8 (HamishMackenzie)
01:02:24 <ttt_fff> OMG, erlang is awesome
01:02:31 <ttt_fff> is there a good tutorial on getting elrang/haskell to talk to each other?
01:05:14 * erisco Googles "haddock", remembers there is a whole other world out there
01:09:48 <hodapp> ttt_fff: I believe Cloud Haskell can speak Erlang's message-passing protocol
01:10:03 <ttt_fff> http://hackage.haskell.org/package/erlang-0.1/docs/Foreign-Erlang.html supposedly also does it
01:10:33 <hodapp> that's from 2008... I'd lean to Cloud Haskell more probably
01:10:49 <ttt_fff> hodapp: https://hackage.haskell.org/package/distributed-process where is the erlang communication part?
01:11:22 <hodapp> crap, maybe I was thinking of another library...
01:12:24 <ttt_fff> please find it; would much appreciate :-)
01:12:29 <hodapp> if I remember I'll let you know
01:12:38 <hodapp> I swore it was Cloud Haskell but I can't find it now
01:14:01 <erisco> where is  [a] -> Producer a m ()
01:14:23 <erisco> hoogle is nice except it doesn't have everything on index
01:15:02 <erisco> ah ha, 'each'
01:16:50 <ttt_fff> hodapp: https://hackage.haskell.org/packages/ only lists 6 packages with erlang in the title
01:16:54 <ttt_fff> which one were you thinking of?
01:21:15 <adarqui> i remember reading something like that too hodapp
01:32:52 <jle`> man there could be so many more nice instances of Integral if there wasn't quotRem and divMod
01:33:22 <jle`> oh actually nvm
01:38:51 <arahael> The Glorious Glasgow Haskell Compilation System, version 7.6.3
01:39:03 <arahael> At last, it's trivial to install and setup in debian. :)
01:39:49 <adarqui> i'm on 7.10 now, happy
01:40:29 <arahael> 7.6 should be  adequate for me at this point.
01:43:40 <erisco> such value is incoming
01:45:46 <arahael> It strikes me that lambda is _indispensible_ when writing code in a functional style, and that one of haskell's advantages is having such a terse way of expressing lambda.
01:46:08 <arahael> Whereas lambdas in Python, C++, and other languages, result in awkward syntasx.
01:46:40 <erisco> well, you can also do pointless style
01:46:54 <erisco> in which case you still get tripped up because most languages don't let you define infix operators
01:47:01 <Wizek> Good Morning!
01:47:17 <erisco> Wizek, good 4:46am
01:47:36 <Wizek> Can I ask cabal for the latest version of a library? I would need the version as a string for a shell script
01:47:40 * hackagebot regex-tdfa-pipes 0.1.0.0 - Parse with regular expressions on Producers.  https://hackage.haskell.org/package/regex-tdfa-pipes-0.1.0.0 (erisco)
01:47:44 <arahael> erisco: C++ and Python do, though with limitations - except they don't really support currying.
01:47:48 <erisco> the value has arrived!
01:48:07 <Wizek> Latest version available on hackage and not locally, that is.
01:48:32 <erisco> arahael, they don't that I recall
01:48:42 <erisco> you can overload operators, which is different
01:49:14 <arahael> erisco: C++ lets you define some operators globally, iirc.
01:49:48 <erisco> so I was right, there is a secret society for package authors
01:49:50 <erisco> neat
01:50:32 <arahael> erisco: I'm guessing that's still not what you mean, though.  Perhaps it's _too_ limiting
01:52:15 <bycn82> may i ask a question
01:52:30 <erisco> bycn82, there is a quota of one question a day
01:52:49 <erisco> but we'll just fudge timezones a bit and say one has elapsed
01:53:20 <bycn82> i see, but this is my first question since my last question today :) 
01:53:55 <erisco> if you add exports to a package, does that break the API?
01:54:01 <bycn82> http://lpaste.net/139501
01:54:11 <erisco> it could introduce ambiguity errors if someone did a star import
01:54:15 <bycn82> still the programme of "count char of string"
01:54:16 <erisco> which is why you shouldn't star import
01:54:39 <bycn82> my question is : why the "len_words (x:y)" knows that the x is a char?
01:54:50 <phaazon> bycn82: because of the type
01:54:52 <phaazon> [Char]
01:55:01 <erisco> :t (:) -- because of this
01:55:02 <lambdabot> a -> [a] -> [a]
01:55:04 <phaazon> it can’t be anything else
01:55:20 <erisco> :t (:) :: Char -> [Char] -> [Char]  -- in this case
01:55:22 <lambdabot> Char -> [Char] -> [Char]
01:55:47 <phaazon> bycn82: you can only build up strings with two « constructors »
01:55:55 <phaazon> cons (which is (:)) and a null string
01:55:59 <erisco> so, in 'x:y' the 'x' is in the Char spot, and 'y' is in the [Char] spot, so it figures it out
01:56:02 <phaazon> list*
01:56:41 <bycn82> for example, "abc" it can be "a" : "bc" , or "ab" : "c"
01:56:50 <phaazon> no
01:56:53 <phaazon> 'a' : "bc"
01:56:56 <phaazon> not "ab"
01:57:03 <phaazon> "a"*
01:57:13 <phaazon> "abc" is a shortcut for
01:57:32 <phaazon> 'a' : "bc" == 'a' : 'b' : "c" == 'a' : 'b' : 'c' : []
01:58:02 <bycn82> yes, i understand,  
01:58:10 <phaazon> bycn82: a list can only be constructed with cons or []
01:58:30 <phaazon> data [] a = a : [a] | []
01:58:36 <phaazon> picture a list like that ^
01:59:05 <phaazon> so basically a list is either empty or has a head (the a) and a tail (the [a])
01:59:06 <bycn82> OK, i think it is better to read more article to learn more about the haskell :)
01:59:25 <erisco> bycn82, I have a different idea that might relate to C more
01:59:33 <phaazon> bycn82: try to implement a list on your own!
01:59:46 <phaazon> data List a = …
01:59:48 <phaazon> try it :)
01:59:54 <erisco> it is a common misconception that (:) sticks together lists
02:00:04 <phaazon> erisco: common?
02:00:05 <phaazon> really?
02:00:12 <phaazon> that’s interesting
02:00:30 <erisco> so lets put it this way... (:) prepends and element to the list (or pushes an element on the stack, because a list is a stack)
02:00:39 <erisco> sticking two lists together is ++
02:01:02 <phaazon> I like to see (:) as a way to build up a string, or fold it
02:01:26 <erisco> phaazon, yes, when learning Haskell it takes some time to get used to what (:) is
02:01:43 <phaazon> erisco: LYAH presents it in a very nice way :)
02:01:47 <phaazon> with head / tail concepts
02:01:55 <erisco> it especially looks like it glues lists together especially when you see  'a':'b':'c':[]
02:02:13 <phaazon> yeah, well, not at all :D
02:02:21 <phaazon> 'a', 'b', 'c' are all Char
02:02:25 <dramforever> explain to me why 'a' is a list
02:02:31 <dramforever> doesn't work =P
02:02:34 <phaazon> :)
02:02:51 <phaazon> dramforever: OverloadedLists
02:02:55 <phaazon> make Char an instance
02:02:57 <dramforever> hmm...
02:02:59 * phaazon vomits
02:03:02 <erisco> you don't find it confusing, a beginner might
02:03:03 <erisco> I did
02:03:42 <erisco> you're inclined to think that in   'a':'b':'c':[] that, say, this is  ('a':'b'):('c':'[])  for example
02:03:51 <erisco> for any of the cons
02:04:06 <phaazon> erisco: yeah I understand what you’re saying
02:04:13 <bycn82> hope i can find some task to do with haskell :)
02:04:20 <phaazon> even though that’s easy to understand that won’t type match :)
02:04:34 <phaazon> bycn82: why are you learning it? :)
02:05:19 <bycn82> it is ... a cool programming language
02:05:35 <bycn82> i am a Java/PHP/C programmer,
02:05:44 <dramforever> phaazon: too bad many programmers don't quite understand the importance of types in haskell
02:06:07 <dramforever> or rather, they don't understand the error messages =P
02:06:13 <phaazon> dramforever: you mean
02:06:17 <phaazon> the importance of types.
02:06:18 <phaazon> at all.
02:06:24 <phaazon> look at javascript brogrammers…
02:06:35 <phaazon> bycn82: sure it is!
02:06:45 <phaazon> and the community is awesome!
02:06:56 <phaazon> shoot questions, we’ll help you to get further
02:07:13 <phaazon> dramforever: I’m actually quite interested in DT language
02:07:25 <dramforever> me too
02:07:28 <phaazon> I try to lead my luminance framework into the direction of DT
02:07:51 * dramforever is going to make a stack based programming language
02:07:57 <dramforever> for...text formatting!
02:08:36 <phaazon> :)
02:09:09 <dramforever> I haven't really seen any, and it seems great
02:09:43 <phaazon> dramforever: do you have a repo for that?
02:09:57 <bycn82> how about you guys? what kind of program do you use haskell?
02:09:57 <dramforever> no, I just started out
02:10:13 <phaazon> bycn82: graphics, website, scripts
02:10:16 <phaazon> pretty much everything
02:10:26 <phaazon> I have an IRC bot running in Haskell
02:10:42 <bycn82> i see, 
02:10:54 <bycn82> i am a system/web developer,
02:11:00 <phaazon> the single place I wouldn’t use Haskell is for very specific hardware / need
02:11:09 <bycn82> so i think i should learn how to use haskell do web programming
02:11:15 <phaazon> like embedded purposes or that kind of stuff
02:11:23 <phaazon> bycn82: definitely
02:11:30 <phaazon> we have a lot of very cool web frameworks
02:11:35 <phaazon> my website is written with happstack
02:11:41 <phaazon> http://phaazon.net/
02:11:43 <phaazon> it’s very static
02:11:49 <phaazon> but that was fun to make
02:11:59 <phaazon> and I guess with ghcjs, we can write Haskell code and convert it to JS
02:12:06 <phaazon> but I’ve never tried that yet
02:12:41 * hackagebot cpphs 1.19.3 - A liberalised re-implementation of cpp, the C pre-processor.  https://hackage.haskell.org/package/cpphs-1.19.3 (MalcolmWallace)
02:13:27 <bycn82> yes, i think i am try to use haskell in web . 
02:13:36 <bycn82> i think haskell is not good for system development
02:13:59 <darkbolt> bycn82: sadly I don't get to use haskell much,  but I do like to try and continue learning it
02:14:32 <bycn82> at least, the haskell programmer have a different mindset , that is cool 
02:14:52 <phaazon> 11:16 < bycn82> i think haskell is not good for system development
02:14:59 <phaazon> I think it is :)
02:15:25 <bycn82> yes, i am BSD developer, but i cannot imagine how to use haskell in BSD.
02:15:49 <darkbolt> phaazon: 'system development' is too broad to really say...but it can often rule out the use of a garbage collector
02:16:48 <bycn82> i tried haskell with fastcgi during the weekdays.
02:17:33 <bycn82> phaazon: what is your website,what is the webserver? 
02:17:48 <bycn82> http://phaazon.net/?
02:17:55 <phaazon> yes
02:18:01 <phaazon> happstack
02:18:23 <phaazon> http://www.happstack.com
02:20:11 <bycn82> i see, it is using it
02:20:42 <bycn82> using it's own lib to build a web server, and use template to prepare the html/
02:22:46 <bycn82> how is the performance of yesod or happstack? compare to run the haskell cgi in fastcgi module?
02:55:36 <putis> hello! Im wondering, why generic verions of take, split and so on is not the dafault ones? It is bacause they are they less efficient?
02:59:43 <opqdonut> putis: yes, exactly
03:07:15 <tulcod> bycn82: for small requests, haskell web frameworks are typically *MUCH* faster than e.g. PHP, see http://www.aosabook.org/en/yesod.html
03:07:31 <tulcod> (but then again, why would you use PHP to serve small pages)
03:07:49 <tulcod> (that'd be mostly startup latency, I guess)
03:08:58 <tulcod> bycn82: but the most important question is not the performance, but ease of development, and how easily that code can be scaled. in the case of haskell, this is MUCH better - haskell code is very scalable, generally speaking
03:09:18 <tulcod> remember kids, dev time is usually much more expensive than CPU time
03:10:17 <concept> I am writing a parser that reads from socket
03:10:27 <concept> currently I am using parseOnly (attoparsec)
03:10:56 <concept> my problem is that at certain point I don't get the whole message, so the parsed msg is wrong
03:11:05 <concept> I know I should use parse instead
03:11:09 <concept> but I am not sure how ?
03:12:55 <ocramz> guys
03:13:06 <ocramz> I peered into the abyss and my brain is on fire now
03:13:17 <ocramz> why is [] :: [a] ?
03:13:50 <zyla> ocramz: it's an empty list
03:13:56 <jle`> ocramz: [] the data constructor has the type of a-list-of-a's
03:14:03 <jle`> so [] is a list of Int's
03:14:05 <jle`> [] :: [Int]
03:14:08 <jle`> or [] :: [Bool]
03:14:14 <jle`> in fact, for any type a, you get an [] :: [a]
03:14:25 <concept> ocramz: It's an empty list that can take any type, a is a type variable
03:14:36 <jle`> [] is an empty list of strings, [] is an empty list of Bool's, [] is an empty list of Int's, etc.
03:14:39 <jle`> anything you want! :D
03:14:40 <cocreature> concept: so you run parse on the input you already have, that gives you an IResult. you can then check if that IResult is a Done by pattern matching, if it is then great you have what you wanted to parse. if it is not. you read from your socket again, take your IResult and your new input and pass that to "feed" and repeat that process until you parsed what you want
03:15:21 <Sindriava> ocramz: List is defined as " data [a] = a : [a] | [] "
03:15:41 <jle`> ocramz: what type would you expect it to have?
03:15:42 <Sindriava> ocramz: As you can see, `a` has no effect whatsoever on `[]`, thus it's the same for all a's
03:16:30 <concept> cocreature: Thanks, another question, when is Network-Attoparsec usefull, does it perform what you just described
03:17:36 <ocramz> jle`, zyla, Sindriava: thanks; lack of sleep, mostly
03:18:02 <ocramz> been using the language for over a year but never gave much reflection to this
03:18:22 <Sindriava> ocramz: Huh. You might want to delve deeper into it
03:19:20 <ocramz> Sindriava: I am preparing this: https://ocramz.github.io/haskell/tutorials/2015/08/21/haskell-tut-v1.html
03:19:40 <zyla> concept: Have you tried Data.Conduit.Attoparsec?
03:19:48 <jle`> ocramz: when something is of a type with a polymorphic variable like [a], the meaning is, "pick any a, and that value can take on that type [a]."
03:19:55 <cocreature> concept: I have to admit, that I have not worked with network-attoparsec myself, but from looking at the source it seems do be doing pretty much that. i.e. parseOne reads until it gets a Done
03:19:56 <jle`> so if i need a [Int], i can type [], and it works
03:20:09 <ocramz> having to put my understanding down in long prose makes me second guess everything
03:20:12 <Sindriava> I really like how Rust handled Show. They have two classes, "Display" and "Debug". One is used for showing data in a human readable form, the other for what Show is mostly used for
03:20:22 <jle`> if i need a [()], [] works
03:20:30 <concept> zyle: I'll look into that
03:20:39 <jle`> if i use [] where a function is expecting [Bool], that works too
03:20:49 <concept> zyla: I'll look into that
03:20:52 <jle`> [] even works if you need a [Void]
03:21:05 <Sindriava> jle`: Oh, never realised that O.o
03:21:18 <jle`> formally we can say that [] :: forall a. [a].  that is, "pick any a, no matter what, and [] can fill in for [a]"
03:21:19 <nadirs> I'm trying to test a Parsec parser for a failed parse (I'm using hspec, if that matters)
03:21:23 <nadirs> its value is Left ParseError but I cannot forge a ParseError value (its constructor is not exposed)
03:21:46 <jle`> another similar value people come across often is Nothing :: Maybe a
03:21:56 <jle`> pick any type a, no matter what, and Nothing can fill in for Maybe a
03:22:00 <cocreature> nadirs: you can use "isLeft"
03:22:03 <jle`> Nothing :: forall a. Maybe a
03:22:11 <jle`> so if you need a `Maybe Void`, Nothing fits the bill
03:23:01 <jle`> `Maybe Void` is actually inhabited only by `Nothing :: Maybe Void`, actually
03:23:27 <cocreature> or `Just undefined` :)
03:23:38 <jle`> :P
03:26:18 <nadirs> cocreature: thank you
03:26:50 <cocreature> yw
03:28:21 <phaazon> hey, is there a contravariant version of applicative functors?
03:29:10 <phaazon> oh
03:29:13 <phaazon> it’s Divisible!
03:32:13 <ocramz> anyway, thanks jle` and Sindriava, silly question due to poor sleep
03:32:40 <jle`> not a silly question at all :)
03:35:28 <phaazon> gosh
03:35:30 <phaazon> divide is so nice!
03:35:32 <phaazon> :t divide
03:35:34 <lambdabot> Not in scope: ‘divide’
03:35:42 <phaazon> @let import Data.Functor.Contravariant.Divisible
03:35:44 <lambdabot>  Defined.
03:35:46 <phaazon> :t divide
03:35:47 <lambdabot> Divisible f => (a -> (b, c)) -> f b -> f c -> f a
03:35:50 <phaazon> though, I don’t get the point of conquer
03:35:51 <phaazon> :t conquer
03:35:53 <lambdabot> Divisible f => f a
03:36:12 <phaazon> I understand the type of divide
03:36:17 <lf94> I don't
03:36:23 <phaazon> because it’s the contravariant version of Applicative
03:36:25 <lf94> how...what the hell is a?
03:36:44 <phaazon> lf94: an Applicative lets you apply a function to “glue” types
03:36:47 <phaazon> :t (<*>)
03:36:49 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:36:59 <phaazon> the Divisible’s divide does the exact opposite thing
03:36:59 <lf94> yeah, that makes sense
03:37:07 <lf94> the divide doesn't make sense to me
03:37:13 <phaazon> so it takes a « a »
03:37:19 <phaazon> and divides it to (b,c)
03:37:27 <phaazon> so that it can link them to f b and f c
03:37:39 <phaazon> however
03:37:41 <lf94> I'd have to see the source
03:37:42 <phaazon> I don’t get the use of conquer
03:37:53 <phaazon> lf94: are you comfortable with contramap?
03:37:56 <phaazon> if you are
03:38:00 <phaazon> divide is pretty simple
03:38:02 <lf94> never heard of it
03:38:05 <phaazon> :t contramap
03:38:07 <lambdabot> Contravariant f => (a -> b) -> f b -> f a
03:38:21 <lf94> Yeah, see that doesn't make sense to me either :)
03:38:27 <lf94> How...again, wtf is with a
03:38:39 <lf94> What is supplying a to that
03:38:51 <lf94> to the function you pass
03:38:56 <phaazon> lf94: imagine « a » as being a function parameter
03:39:06 <phaazon> you don’t have to « pass » it yet
03:39:32 <jle`> lf94: imagine data StringFrom a = SF (a -> String)
03:39:33 <lf94> contramap thingAToB [1,2,3]
03:39:37 <phaazon> :t contramap length (Predicate even)
03:39:38 <lambdabot> Not in scope: data constructor ‘Predicate’
03:39:50 <lf94> er
03:39:52 <lf94> B to A
03:40:03 <lf94> But...
03:40:06 <ramadoka> :t (+) --sorry, just want to try.
03:40:07 <lambdabot> Num a => a -> a -> a
03:40:13 <phaazon> @let import Data.Functor.Contravariant
03:40:15 <lambdabot>  Defined.
03:40:20 <phaazon> :t Predicate
03:40:22 <lambdabot> (a -> Bool) -> Predicate a
03:40:23 <jle`> lf94: so contramap :: (b -> a) -> StringFrom a -> StringFrom b
03:40:24 <phaazon> :t contramap length (Predicate even)
03:40:26 <lambdabot> Foldable t => Predicate (t a)
03:40:40 <phaazon> > contramap length (Predicate even) "foo"
03:40:40 <jle`> contramap f (SF g) = SF (g . f)
03:40:42 <lambdabot>      Couldn't match expected type ‘[Char] -> t’
03:40:42 <lambdabot>                  with actual type ‘Predicate (t0 a0)’
03:40:42 <lambdabot>      The function ‘contramap’ is applied to three arguments,
03:40:55 <jle`> lf94: [] is not an instance of Contravariant :)
03:40:55 <phaazon> > getPredicate (contramap length (Predicate even)) "foo"
03:40:57 <lambdabot>  False
03:41:00 <phaazon> > getPredicate (contramap length (Predicate even)) "foob"
03:41:01 <lf94> jle`: Ah.
03:41:01 <lambdabot>  True
03:41:03 <phaazon> :)
03:41:25 <phaazon> now, with divisible
03:41:26 <lf94> I don't understand its purpose at all so that's probably why I'm confused
03:41:34 <cocreature> hm I don't get how divide is the contravariant version of (<*>)
03:41:39 <phaazon> lf94: you can use it to “adapt befor3
03:41:43 <phaazon> cocreature: well
03:41:47 <jle`> lf94: https://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html
03:42:00 * lf94 click
03:42:03 <phaazon> cocreature: for (<*>)
03:42:10 <phaazon> it takes two Applicative values
03:42:15 <phaazon> and maps a function inside them
03:42:24 <cocreature> right
03:42:59 <phaazon> so you actually « zip » stuff
03:43:03 <phaazon> like hm
03:43:11 <phaazon> Foo <$> getFromIO <*> getFromIO
03:43:15 <phaazon> with divide
03:43:41 <phaazon> you can have the first value by providing the two others
03:43:54 <phaazon> it’s like applying contramap twice
03:44:15 <phaazon> you divide the input so that you can apply contramap to the results
03:44:18 <phaazon> :t divide
03:44:19 <lambdabot> Divisible f => (a -> (b, c)) -> f b -> f c -> f a
03:44:26 <phaazon> a -> (b,c) is the key
03:44:45 <cocreature> ah I think it's starting to make sense
03:44:50 <phaazon> :)
03:45:04 <phaazon> my problem is that I don’t get the point of conquer
03:45:38 <cocreature> you don't get the point or don't get why it's the contravariant version of pure?
03:45:58 <phaazon> I’m not sure it’s contravariant version of pure
03:46:07 <phaazon> I just don’t get the point, yeah :D
03:46:15 <phaazon> maybe edwardk could help me with that :D
03:46:29 <phaazon> @let q = Predicate even
03:46:31 <lambdabot>  Defined.
03:46:38 <phaazon> @let p = Predicate null
03:46:40 <edwardk> conquer you mean?
03:46:40 <lambdabot>  Defined.
03:46:42 <edwardk> :t conquer
03:46:44 <lambdabot> Divisible f => f a
03:46:59 <phaazon> :t divide (\a -> (length a,a)) q p
03:47:00 <lambdabot>     Ambiguous occurrence ‘q’
03:47:00 <lambdabot>     It could refer to either ‘L.q’,
03:47:00 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:163:1
03:47:00 <cocreature> so pure goes from a -> f a, that's isomorphic to (() -> a) -> f a ,so the contravariant version goes from (a -> ()) -> f a, but a -> () has to be const mempty, so we can throw that away and get to f a
03:47:07 <cocreature> at least that's my understanding
03:47:08 <edwardk> this is less obviously connected to pure, after all, where did the (a -> fa) go? right?
03:47:12 <edwardk> but we can spot it
03:47:18 <edwardk> and the missing function argument to Alternative
03:47:29 <edwardk> just by chewing on it a bit
03:48:02 <phaazon> cocreature: interesting!
03:48:32 <edwardk> pretend we have: pure :: (() -> a) -> f a, empty :: (Void -> a) -> f a, conquer :: (a -> ()) -> f a; lose :: (a -> Void -> f a -- with the first to covariant and the second two contravariant
03:48:38 <edwardk> now simplify away things that are trivial
03:48:43 <edwardk> and you get all the current definitions
03:48:48 <phaazon> yeah, got it now
03:48:49 <phaazon> thanks!
03:48:50 <edwardk> (() -> a) is just 'a'
03:48:58 <phaazon> I’m going to use Divisible in my graphics framework
03:49:02 <edwardk> (Void -> a) is always absurd
03:49:18 <edwardk> (a -> ()) is trivial. in the absence of seq its always the terminal morphism
03:49:26 <edwardk> and (a -> Void)   doesn't simplify at all
03:49:35 <edwardk> now you get the forms all 4 of those functions take
03:49:53 <phaazon> (a -> ()) is actually (), right?
03:49:58 <phaazon> well
03:49:59 <phaazon> const ()
03:50:04 <phaazon> :t const ()
03:50:05 <lambdabot> b -> ()
03:50:06 <edwardk> yes
03:50:12 <edwardk> which is terminal
03:50:16 <phaazon> yes
03:50:45 <edwardk> just like Void -> a  is initial
03:51:00 <phaazon> initial?
03:51:03 <phaazon> mempty, you mean?
03:51:15 <edwardk> Void is the initial object in the category of haskell data types (or the closest we get)
03:51:17 <phaazon> const mempty
03:51:31 <edwardk> an initial object has exactly one arrow to every object in the category
03:51:42 <phaazon> oh I see
03:51:43 <edwardk> a terminal object has exactly one arrow _from_ every object in the category
03:52:00 <phaazon> yeah, got it
03:52:17 <phaazon> now I need to implement Divisible :)
03:52:19 <edwardk> so in that sense if we accept the categorical fiction we're applying and ignore 'Seq' then the function arguments i mentioned above for those two functions are trivial
03:52:35 <edwardk> :t pure
03:52:37 <lambdabot> Applicative f => a -> f a
03:52:39 <edwardk> and pure simplifies
03:52:51 <edwardk> leaving just 'lose' with a more complicated signature
03:52:52 <edwardk> :t lose
03:52:53 <lambdabot> Decidable f => (a -> Data.Void.Void) -> f a
03:53:00 <phaazon> hm
03:53:11 <phaazon> so lose is like
03:53:22 <phaazon> lose _ = …
03:53:25 <edwardk> lose says if you can prove a can't happen then you can handle a's
03:53:33 <phaazon> ahah
03:53:37 <phaazon> that’s funny :)
03:53:40 <epta> hey guys, is there any vim plugin to autoformat cabal files? 
03:53:47 <cocreature> hm I still don't quite get, why divisible is the contravariant version of pure, if I turn the arrow arround I get ((b,c) -> a) -> f b -> fc -> f a, which seems more like liftA2 minus some currying then pure
03:54:14 <epta> autoindenting*
03:54:24 <edwardk> cocreature: divide is contravariant liftA2
03:54:28 <edwardk> conquer is contravariant pure
03:54:42 <cocreature> eh, I intented to say (<*>)
03:54:48 <cocreature> yeah if it's liftA2 that makes a lot more sense
03:55:15 <edwardk> :t divide id
03:55:16 <lambdabot> Divisible f => f b -> f c -> f (b, c)
03:55:29 <Saizan> :t divide
03:55:30 <lambdabot> Divisible f => (a -> (b, c)) -> f b -> f c -> f a
03:55:31 <edwardk> :t liftA2 id
03:55:32 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
03:55:42 <phaazon> yay
03:55:44 <phaazon> edwardk: implemented!
03:55:48 <cocreature> allright, I got it, thanks
03:56:00 <edwardk> er
03:56:05 <phaazon> http://lpaste.net/4748015113695395840
03:56:08 <edwardk> :t liftA2
03:56:08 <phaazon> here ^ :)
03:56:09 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
03:56:15 <edwardk> :t liftA2 . uncurry
03:56:17 <lambdabot> Applicative f => (a -> b1 -> b -> c) -> f (a, b1) -> f b -> f c
03:56:22 <edwardk> :t liftA2 (curry id)
03:56:24 <lambdabot> Applicative f => f a -> f b -> f (a, b)
03:56:27 <edwardk> there
03:56:29 <edwardk> that's what i meant
03:56:38 <edwardk> i have to 'uncurry' liftA2
03:56:50 <edwardk> :t liftA2 . uncurry
03:56:51 <lambdabot> Applicative f => (a -> b1 -> b -> c) -> f (a, b1) -> f b -> f c
03:56:57 <edwardk> :t liftA2 . curry
03:56:58 <lambdabot> Applicative f => ((a, b) -> c) -> f a -> f b -> f c
03:57:14 <edwardk> because i can't have a 'function' of two arguments on the other side of the arrow like that
03:57:23 <cocreature> yep
03:57:24 <edwardk> so for symmetry liftA2 is the 'flippable form'
03:57:33 <edwardk> and corresponds to the usual definition of Day convolution
03:57:46 <phaazon> edwardk: yep
03:57:47 * hackagebot wai-routes 0.8.0 - Typesafe URLs for Wai applications.  https://hackage.haskell.org/package/wai-routes-0.8.0 (AnupamJain)
03:57:52 <phaazon> see my lpaste above
03:57:54 <edwardk> Divisible is a 'monoid object of day convolution'
03:57:59 <phaazon> everything is implemented now :)
03:58:08 <phaazon> I might also have a Decidable instance as well
03:58:23 <edwardk> phaazon: for that you need to catch exceptions
03:58:35 <phaazon> for Decidible?
03:58:37 <phaazon> Decidable*
03:58:40 <edwardk> oh no
03:58:41 <edwardk> you don't
03:58:42 <edwardk> its easy
03:58:45 <edwardk> yeah its decidable
03:58:47 <phaazon> yeah
03:59:16 <edwardk> in general anything that has a monoid for the result type can implement the entire hierarchy
03:59:26 <benneh> what's the best way to access a screen/window's pixel data?
03:59:30 <edwardk> see the instance for Op r in the library
03:59:32 <phaazon> lose is actually const conquer
03:59:47 <edwardk> shouldn't be
03:59:59 <edwardk> lose should use the function its given and compose with absurd
04:00:06 <phaazon> absurd?
04:00:12 <edwardk> :t Data.Void.absurd
04:00:12 <phaazon> there’s no absurd there
04:00:13 <lambdabot> Data.Void.Void -> a
04:00:24 <phaazon> huhuhu
04:00:45 <edwardk> otherwise you silently swallow errors folks shove in the stream
04:00:47 <phaazon> how is that even defined?
04:01:06 <phaazon> @src absurd
04:01:06 <lambdabot> Source not found. I am sorry.
04:01:16 <edwardk> data Void; absurd x = case x of {}
04:01:23 <edwardk> its actually a bit more complicated
04:01:28 <edwardk> but that is the conceptual version
04:01:58 <phaazon> well…
04:02:01 <phaazon> it doesn’t return anything
04:02:09 <phaazon> how can that even type match?
04:02:13 <edwardk> it can't
04:02:15 <edwardk> thats the point
04:02:16 <cocreature> Void doesn't have a constructor
04:02:20 <edwardk> you shouldn't be able to construct a Void
04:02:23 <phaazon> I know that cocreature 
04:02:38 <phaazon> :t absurd undefined
04:02:40 <lambdabot> Not in scope: ‘absurd’
04:02:57 <phaazon> :t Data.Void.absurd undefined
04:02:58 <lambdabot> a
04:03:00 <edwardk> if you call absurd on some error you build then it throws it
04:03:01 <phaazon> WAT
04:03:09 <phaazon> > Data.Void.absurd undefined
04:03:11 <lambdabot>  Not in scope: ‘Data.Void.absurd’
04:03:20 <phaazon> waaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaat
04:03:20 <edwardk> Building an inhabitant of Void is on you for doing something dumb =P
04:03:34 * phaazon brainfarts
04:03:43 <edwardk> lets put it this way
04:03:48 <edwardk> Void inhabits kind *
04:03:52 <edwardk> _EVERYTHING_ in * is lifted
04:03:52 <phaazon> yep
04:03:58 <edwardk> and so _|_ inhabits that thing
04:03:59 <phaazon> I know Void
04:04:06 <edwardk> Void is 'logically uninhabited'
04:04:12 <edwardk> but haskell is a degenerate logic
04:04:20 <edwardk> so you can shoehorn bottom into it
04:04:41 <edwardk> its not (), () is logically inhabited by ().   and _|_ is also around inside of it because we can't rule it out
04:04:47 <phaazon> oh my
04:04:51 <edwardk> but if you want a "unit" for Either, Void is what you have
04:04:52 <phaazon> newtype Void = Void Void
04:04:55 <edwardk> its the closest you get
04:04:59 <phaazon> absurd (Void a) = absurd a
04:05:00 <phaazon> WTF
04:05:04 <edwardk> that newtype is used because its the portable version
04:05:11 <edwardk> and that definition for absurd is ancient
04:05:17 <edwardk> check the version of void you are looking at 
04:05:59 <edwardk> absurd a = a `seq` spin a where spin (Void b) = spin b
04:06:08 <phaazon> absurd a = a `seq` spin a where spin (Void b) = spin b
04:06:09 <phaazon> yeah
04:06:10 <phaazon> wtf.
04:06:27 <edwardk> this causes it to rethrow whatever bullshit bottom you crammed into it rather than spin forever
04:07:01 <edwardk> the void package workds on pretty ancient versions of haskell, including hugs
04:07:04 <dramforever> edwardk: I wonder if it's actually different from a `seq` (let x = x in x)
04:07:07 <edwardk> so i can't use EmptyDataDecls
04:07:15 <edwardk> dramforever: its not
04:07:27 <phaazon> edwardk: ok, well, back to lose
04:08:07 <phaazon> (a -> Void) -> f a
04:08:11 <phaazon> I guess I can…
04:08:13 <dramforever> what about a `seq` error "This can't possibly happen"? oh, that can't possibly happen =P
04:08:40 <phaazon> pass absurd to that function
04:08:46 <edwardk> phaazon: lose f = U $ absurd . f
04:08:47 <phaazon> linking the resulting f a to the absurd function, rihgt?
04:08:49 <phaazon> yeah right.
04:09:28 <edwardk> dramforever: the spin was the code we had before we added the seq, chosen because it was the most 'neutral' bottom we could find
04:09:42 <dramforever> hmm...
04:09:51 <dramforever> btw that can't possibly happen anyway
04:09:52 <edwardk> then elliott made a good case to add the seq to get out the bottom the user gave us instead
04:09:57 <dramforever> it doen't really matter
04:09:57 <edwardk> and we applied it pretty uniformly
04:09:58 <edwardk> absolutely
04:10:09 <edwardk> and its already shipped into base, and i'm not bothering to go change it =P
04:10:38 <edwardk> anyways it theoretically _can_ happen
04:10:45 <edwardk> but it can only happen in the presence of unsafeCoerce
04:11:05 <edwardk> i can unsafeCoerce () and pass it to absurd and it'll pass through that seq
04:11:09 <edwardk> and then fall into the spin after
04:11:24 <edwardk> because seq just tells it to evaluate itself and it will say 'yep, i'm a constructor!'
04:12:08 <phaazon> edwardk: 
04:12:10 <phaazon> my choose:
04:12:11 <phaazon>   choose f p q = U $ either (runU p) (runU q) . f 
04:12:39 <edwardk> https://www.irccloud.com/pastebin/wJQHCjke/
04:12:51 <edwardk> dramforever: ^- so much for it can't happen =)
04:14:05 <cocreature> phaazon: your U is just Op (IO ()) afact, so you can just steal all the instances from that :)
04:14:13 <edwardk> unfortunately, when it moved into base, folks thought they were more clever than me, and switched to the case a of {}
04:14:19 <edwardk> and so it actually !@(*# terminates
04:14:32 <phaazon> cocreature: hm?
04:14:55 <phaazon> yeah, sounds too actually
04:15:09 <phaazon> that was actually fun to write the instances
04:15:12 <phaazon> and understand them
04:15:22 <phaazon> even though I don’t really get the absurd stuff
04:15:24 <phaazon> 'absurd' stuff
04:15:29 <phaazon> not saying it’s absurd, haha.
04:15:51 <cocreature> phaazon: newtype U a = U (a -> IO ()), newtype Op (IO ()) a = Op (a -> IO ())
04:16:07 <cocreature> Op being https://hackage.haskell.org/package/contravariant-1.3.2/docs/Data-Functor-Contravariant.html#t:Op
04:16:33 <edwardk> that relies on the instance for Monoid a => Monoid (IO a)
04:16:42 <edwardk> which isn't in yet
04:16:56 <cocreature> oh right , I always forget, that we don't have that one yet
04:17:15 <phaazon> cocreature: not really actually
04:17:17 <phaazon> yeah
04:18:22 <phaazon> thank you very much for your hints
04:18:31 <phaazon> I love keeping learning stuff like that
04:18:33 <phaazon> :3
04:19:13 <phaazon> the cool thing is that now, I can send any type to the GPU with contramap and divide!
04:19:16 <edwardk> happy to help
04:19:27 <phaazon> if I can provide a function to end up with covered types!
04:19:40 <phaazon> contravariance is so cool
04:19:49 <phaazon> especially with Profunctors
04:19:51 <phaazon> :)
04:20:11 <edwardk> phaazon: did you see https://github.com/ekmett/quine/blob/master/src/Quine/GL/Block.hs#L125 ?
04:20:54 <zipper> Are you guys able to achieve syntax highlighting with hakyll?
04:20:57 <zipper> I can't.
04:21:07 <cocreature> zipper: have you added the css?
04:21:20 <zipper> cocreature: That css only highlights haskell
04:21:26 <zipper> That small file you mean?
04:21:29 <zipper> or which one?
04:21:39 <cocreature> this one http://jaspervdj.be/hakyll/tutorials/faq.html#does-hakyll-support-syntax-highlighting
04:22:30 <phaazon> the good part about that stuff
04:22:35 <phaazon> is that I can lose my Uniformed type
04:22:41 <phaazon> and then lose unsafety
04:22:52 <phaazon> and gain more security around uniforms handling :)
04:22:54 <home-pc> > [1..]
04:22:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:23:23 <zipper> Oh my I see to be using an old version of pandoc
04:23:32 <dramforever> hi, I wonder how leksah is going now
04:23:49 <lambdadoodle> hey how goos is yi?
04:23:56 <phaazon> ahah :D
04:24:43 <lambdadoodle> i once saw a version at a friends pc .. i liked the symbols!! proper lambda for expressions like (\x -> f x)..
04:25:08 <lambdadoodle> >let  f = (\x -> f x) in f 1
04:25:29 <phaazon> you need a whitespace between > and let
04:25:40 <lambdadoodle> > let f = (\x -> f x) in f 1
04:25:43 <lambdabot>  mueval-core: Time limit exceeded
04:25:46 <lambdadoodle> phaazon:ty
04:25:51 <phaazon> you’re welcome :)
04:25:54 <lambdadoodle> lambdabot is smart!
04:25:58 <zipper> cocreature: Yeah that documentation is totally inaccurate.
04:26:04 <phaazon> :t iterate
04:26:05 <lambdabot> (a -> a) -> a -> [a]
04:26:11 <dramforever> I wish I could have a proper ide for haskell....
04:26:17 <zipper> Talks about pandoc 1.9 the latest on hackage is 1.15
04:26:21 <cocreature> zipper: it worked just fine for me
04:26:22 <zipper> cocreature: ^
04:26:23 <lambdadoodle> is there an iterate' in haskell
04:26:28 <lambdadoodle> like foldl'
04:26:36 <zipper> cocreature: What was your procedure? Can I see the code?
04:26:47 <Gurkenglas> lambdadoodle: What should it do?
04:26:53 <zipper> cocreature: Did it highlight other langs that aren't just haskell?
04:26:59 <lambdadoodle> it ought to be strict
04:27:01 <phaazon> lambdadoodle: you can’t have a strict version of iterate
04:27:08 <phaazon> it’d go forever
04:27:22 <Gurkenglas> You mean, it should compute all of the infinite list before returning the first element?
04:27:22 <dramforever> lambdadoodle: no much use I guess
04:27:24 <cocreature> zipper: I haven't tried that, but I don't see what should go wrong
04:27:25 <zipper> cocreature: You're talking about using this css file: https://github.com/jaspervdj/hakyll/blob/master/web/css/syntax.css
04:27:27 <phaazon> you can see fix though
04:27:29 <cocreature> yep
04:27:29 <phaazon> or mfix
04:27:36 <phaazon> even though it’s not strict either
04:27:39 <lambdadoodle> well yes ... but if its coupled with a take almost always then u could use it ..
04:27:47 <cocreature> zipper: Ah I recall having to change some of the classes
04:27:48 * hackagebot postgresql-query 2.0.0 - Sql interpolating quasiquote plus some kind of primitive ORM  using it  https://hackage.haskell.org/package/postgresql-query-2.0.0 (AlekseyUymanov)
04:27:58 <cocreature> zipper: anyway, this seems to be more suited to #hakyll
04:28:04 <lambdadoodle> i dont thinnk anyone truly uses an infinite iterate either
04:28:09 <zipper> Nobody talks on hakyll all day
04:28:15 <zipper> I asked there this morning
04:28:18 <zipper> Still nothing
04:28:22 <Gurkenglas> Nope, the take would just ask for the first n elements, which includes asking for the first element, which would mean that the strict iterate' would compute all of the inifnite list first
04:28:23 <zipper> It's 2pm now
04:28:28 <lambdadoodle> repeat,cycle,iterate usually r coupled with take,yes?
04:29:48 <dramforever> hmm...how strict do you want it to be?
04:30:14 <phaazon> and why do you want them strict? :)
04:30:21 <phaazon> do you have a good reason for them to be strict?
04:31:29 <zipper> Seems it needed a full recompile. Seems to be okay now.
04:32:02 <lambdadoodle> Gurkenglas: no no, i want the elements to be evaluated strictly
04:32:20 <MarcelineVQ> then use foldl' on the list you generate with take
04:33:06 <MarcelineVQ> if you're folding anyway, If you're worried about constant space, the list is gonna be as big as it needs to be to fulfill your take, what you do with it after is where you worry about space and strictness
04:33:18 <MarcelineVQ> Unless I'm way off in understanding
04:33:33 <Gurkenglas> So you want a function [a] -> [a] that forces each element of a finite list?
04:39:36 <Gurkenglas> (Well, actually ought to be more of a [a] -> ())
04:43:54 <Gurkenglas> :t foldr (\x xs -> seq x $ seq xs $ ()) () -- I think this would do the job
04:43:55 <lambdabot> Foldable t => t a -> ()
04:44:42 <dennis074> Can someone explain what this line means https://github.com/thoughtbot/carnival/blob/e78b8cdebecfdbdc19627523fe7b85b6ca61d426/Model.hs#L19 Thank you
04:44:52 <dennis074> type Validation a = a -> Validated a
04:44:52 <Gurkenglas> (The specifying property of seq is "seq _|_ x = _|_, otherwise seq _ x = x")
04:46:15 <Gurkenglas> dennis074: Whereever a type signature says "Validation a" for some value of "a", you can instead imagine it to say "a -> Validated a".
04:47:01 <Gurkenglas> You can plug any function producing one of the two into a function requiring one of the two
04:50:27 <dennis074> Gurkenglas: Is it intended to save keystrokes? What are the benefits of having a type signature like "type Validation a = a -> Validated a"?
04:51:16 <cocreature> dennis074: you can also make things easier to understand by giving them more specific names
04:51:46 <Gurkenglas> It improves readability. For example, the State monad has the definition "type State = StateT Identity", but one shouldn't have to explain StateT before State to a user.
04:53:14 <Gurkenglas> It can also give hints to the nature of function arguments, replacing "String -> String -> String -> IO ()" using definitions like "type FilePath = String"
04:53:48 <exio4> (depending on the context, newtype may be nicer/better for that.. or not)
04:54:54 <exio4> Gurkenglas: also, type String = [Char] :P
04:55:14 <Gurkenglas> type and newtype are both desugared away during compilation, choose which you need due to its differences in usage: newtypes have to be wrapped/unwrapped in your code (still at no performance loss after compilation), types gain all the instances their underlying type has.
04:59:31 <lambdadoodle> MarcelineVQ: using foldl' will either create a list in the reverse order or u need to use (++) which isnt very efficient
04:59:45 <lambdadoodle> Gurkenglas: yes
05:00:04 <lambdadoodle> :t iterate
05:00:05 <lambdabot> (a -> a) -> a -> [a]
05:01:19 <Gurkenglas> lambdadoodle: Do you want evaluation to weak head normal form of each element or full deepseq?
05:03:54 <lambdadoodle> Gurkenglas: weak head normal form
05:08:28 <Gurkenglas> [13:43] <Gurkenglas> :t foldr (\x xs -> seq x $ seq xs $ ()) () -- I think this would do the job
05:09:01 <afonso> How do I change my user?
05:09:02 <afonso> the username
05:09:22 <cocreature> /nick username
05:09:37 <catgocat> test
05:09:41 <catgocat> it works :)
05:09:58 <catgocat> What should I learn more in haskell?
05:10:09 <catgocat> I feel like I'm stuck on having nothing to do
05:10:41 <cocreature> find a project and implement it in haskell
05:11:06 <catgocat> that's the problem, what project?
05:11:07 <catgocat> '-'
05:11:12 <tulcod> catgocat: those are weird questions to ask in this channel
05:11:18 <catgocat> I know right
05:11:29 <catgocat> I have done tictactoe, connect four
05:11:40 <tulcod> sudoku solver?
05:11:41 <ocramz_> catgocat: a SAT solver with a reactive web frontend
05:11:49 <lambdadoodle> catgocat: i strongly recommen u read how foldl is implemented using foldr
05:12:11 <lambdadoodle> it will either makle u insanely happy or just as sad! ;')
05:12:36 <tulcod> okay...
05:12:50 * hackagebot microformats2-parser 1.0.0 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-1.0.0 (myfreeweb)
05:13:01 <catgocat> hm
05:13:17 <catgocat> http://codereview.stackexchange.com/questions/101673/first-so-chat-message-in-haskell-followup
05:13:22 <catgocat> Can anyone review this ^
05:13:56 <tulcod> catgocat: looks reasonable
05:14:00 <tulcod> does it work?
05:14:21 <Sindriava> What are some good starting points for learning FRP? A simple library, some good examples?
05:14:36 <Sindriava> Even a guide on writing FRP from scratch would be nice
05:14:55 <tulcod> catgocat: maybe try using a proper HTML parser instead, so that it doesn't break when SO starts using slightly different syntax
05:15:23 <tulcod> catgocat: (e.g., this breaks when class=user-message-count-xxl is replaced by class="user-message-count-xxl")
05:16:15 <tulcod> Sindriava: did you see this? https://github.com/ryantrinkle/try-reflex
05:16:36 <Sindriava> tulcod: Yeah, I'm looking at his talk right now ^^
05:16:55 <tulcod> okay :) then you know everything i know
05:17:17 <Sindriava> Thanks ^^
05:17:26 <Sindriava> I'll ask around #haskell-game I guess
05:21:00 <saulzar_> Sindriava, There's a #reflex-frp too
05:21:17 <Sindriava> saulzar_: I'm aware, thanks :)
05:21:38 <Sindriava> try-reflex is a bit heavy on the "let me install a package manager to handle dependencies" front -.-
05:21:56 <saulzar_> You can use it without - I do
05:22:06 <Sindriava> I know, I know, but still
05:22:56 <saulzar_> It used to be harder to get all the dependencies to play nice - a bit easier now
05:30:47 <catgocat> Question: how are terminal applications (i.e vims, emacs, irss) made?
05:31:02 <catgocat> They don't present that interface of sending a command and getting output like in bash
05:32:17 <dramforever> catgocat: in short, your terminal supports special sequences that changes the text color, moves the cursor, etc.
05:32:29 <catgocat> like [\32132b
05:32:31 <catgocat> this things ^
05:32:39 <dramforever> sort of
05:33:00 <catgocat> define "sort of"
05:33:58 <pyon> Just wondering. Is there any first-order unification library that supports context-dependent unification?
05:33:58 <pyon>  
05:34:15 <catgocat> dramforever: please explain
05:34:43 * dramforever doesn't want to, and goes to find some article that explains it better
05:36:38 <dramforever> https://en.wikipedia.org/wiki/ANSI_escape_code
05:36:46 <dramforever> wait isn't it off-topic?
05:37:07 <lpaste_> chpatrick pasted “Haskell for natural deduction” at http://lpaste.net/139506
05:37:12 <catgocat> what about this: https://hackage.haskell.org/package/ansi-terminal
05:37:28 <dramforever> and also google curses
05:37:49 <catgocat> Yeah ncurses
05:37:51 * dramforever doesn't really want to explain more...
05:37:52 <catgocat> but that's a C library
05:37:57 <catgocat> right ok
05:38:03 <catgocat> * how
05:38:03 <keko_> https://hackage.haskell.org/package/brick
05:38:05 <Clint> @hackage vty
05:38:06 <lambdabot> http://hackage.haskell.org/package/vty
05:38:08 <catgocat> * how do you do this stuff
05:38:08 <dramforever> you could call C from haskell
05:38:15 <keko_> I think that is the current recommended Haskell library for command-line apps
05:38:22 <catgocat> * catgocat goes shopping
05:38:22 <keko_> or not command-line apps, terminal apps
05:41:40 <catgocat> What are arrows'
05:41:44 <catgocat> Do I need to learn about them?
05:42:38 <tulcod> catgocat: "need to" depends on what you want to achieve
05:42:49 <catgocat> master haskell
05:42:52 <chpatrick1> not really
05:42:58 <chpatrick1> they're a further generalization
05:42:59 <liste> some APIs (FRP, opaleye) use them
05:43:22 <liste> but not so many
05:43:30 <tulcod> catgocat: the moment you "master haskell" is the moment you change haskell, thereby making yourself not a master anymore
05:43:48 <catgocat> what
05:44:06 <chpatrick1> every time I learn more haskell the goalposts move :D
05:44:28 <liste> like nobody can master all of physics
05:44:39 <catgocat> And what is the standard way to make games in haskel?
05:44:45 <catgocat> Something more than text based
05:44:52 <catgocat> But not excluding
05:45:02 <chpatrick1> use haskell to start unity and write it in that :P
05:45:13 <tulcod> catgocat: do arrows have applications? well, i've been told lambdabot uses them. and i've been told some people dislike arrows. i personally never found a use for them. but you might.
05:45:23 <chpatrick1> tulcod: I had an interesting use case recently
05:45:33 <chpatrick1> for a datatype that was an arrow but not anything else
05:45:40 <catgocat> what is the common library for making games in Haskell ?
05:45:50 <dramforever> all arrows are profunctors and categories
05:45:53 <tulcod> catgocat: there is no good library for making graphical games in haskell
05:45:57 <chpatrick1> ok, I mean apart from those
05:46:09 <liste> catgocat you could start with gloss
05:46:16 <dramforever> in fact, Strong + Category <-> Arrow
05:46:40 <dramforever> chpatrick1: never mind, keep going =P
05:46:48 <catgocat> liste: ok thanks
05:46:49 <chpatrick1> I mean I wasn't just using it as an extra abstraction over Kleisli or whatever
05:46:51 <liste> @hackage gloss
05:46:51 <lambdabot> http://hackage.haskell.org/package/gloss
05:47:08 <chpatrick1> I was using it to encode logical entailemtn
05:47:14 <chpatrick1> *entailment
05:47:31 <chpatrick1> where Entails a b means b follows from a
05:47:46 <chpatrick1> and I wanted to use -XArrows to make proofs
05:48:07 <dramforever> hmm...interesting
05:48:07 <catgocat> How do I get started with gloss?
05:48:08 <chpatrick1> but I've just thought of a better way, see http://lpaste.net/139506 just now :D
05:48:08 <tulcod> catgocat: if you want to find something useful to do, clone the repository of a fancy project that people are working on nowadays, and ask the main dev(s) if you can do something. they'll probably ask you to write tests.
05:48:10 <catgocat> Any cool tutorial out there?
05:49:00 <chpatrick1> dramforever: I think with this system it should be impossible to typecheck something that's unsound
05:49:08 <chpatrick1> without bottom of course
05:49:25 <bycn82> hello
05:49:38 <chpatrick1> yo
05:50:11 <bycn82> i am trying to write a fibonacci function,
05:50:14 <liste> catgocat start with this: https://github.com/benl23x5/gloss#example
05:50:26 <bycn82> but it failed when fib 100
05:50:29 <liste> and examine the types after that
05:50:40 <bycn82> fib :: Int -> Int
05:50:41 <bycn82> fib 0 = 1
05:50:41 <bycn82> fib 1 = 1
05:50:41 <bycn82> fib n = fib(n -1 ) + fib ( n -2)
05:50:49 <liste> bycn82 use Integer
05:50:52 <chpatrick1> lol no
05:50:54 <dramforever> bycn82: what do you mean by fail?
05:50:59 <dramforever> doesn't terminate?
05:51:00 <catgocat> yeah use Integer, Int will wrap around
05:51:02 <chpatrick1> bycn82: it's because all of your calls make two recursive calls
05:51:12 <chpatrick1> so it takes exponential time
05:51:14 <bycn82> yes, it stuck there !!1
05:51:21 <bycn82> because recursive?
05:51:28 <dramforever> not exactly
05:51:30 <arian0n> bycn82, use the Intege typer because Int wrill wrap around at 2^31
05:51:30 <bycn82> that is slow!
05:51:35 <dramforever> just because it'll take too long
05:51:41 <dramforever> bycn82: you are using a bad algorithm
05:51:43 <arian0n> type Integer*
05:51:49 <chpatrick1> the problem isn't Integer guys
05:51:54 <dramforever> chpatrick1 ++
05:51:55 <arian0n> hm?
05:51:59 <chpatrick1> it's because it's O(2^n)
05:52:19 <chpatrick1> if you make two calls for every call you get four billion calls for fib 32
05:52:28 <dramforever> bycn82: recursion isn't slow per se
05:52:58 <dramforever> bycn82: I wonder if you're still there.....
05:53:06 <bycn82> yes
05:53:08 <chpatrick1> probably ran out of memory :D
05:53:13 <dramforever> and do you get it?
05:53:15 <bycn82> still waiting for fib 50 :D
05:53:26 <chpatrick1> can you see the problem bycn82?
05:53:34 <dramforever> bycn82: you are using a bad algorithm, period.
05:53:43 <chpatrick1> think about how many times fib gets called recursively
05:53:51 <bycn82> yes, but i dont know how to import the argorithm, 
05:54:06 <dramforever> hmm...that's a different problem now
05:54:06 <Gurkenglas> bycn82: Here's what your implementation does for small numbers: http://thenewobjective.com/blog/wp-content/uploads/2013/01/fibCallTree.png You can imagine what this looks like for larger numbers
05:54:13 <Gurkenglas> The same computation has to be done again and again
05:54:18 <chpatrick1> bycn82: there's a really nice haskell way  but it's a bit tricky
05:54:21 <chpatrick1> try with tail recursion
05:54:25 <chpatrick1> ie. pass the values forward
05:54:35 <dramforever> chpatrick1: did you know? P holds in classical logic iff (not (not P)) holds in intuitionist logic
05:54:43 <dramforever> i.e. you could just make KnownF a monad
05:54:56 <chpatrick1> ah cool
05:55:11 <dramforever> try yourself
05:55:15 <chpatrick1> I only took one and a half formal logic classes so my knowledge isn't that deep
05:55:35 <isocliff> > @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
05:55:37 <lambdabot>  <hint>:1:1: parse error on input ‘@’
05:55:53 <isocliff> eh you get the idea
05:56:49 <chpatrick1> dramforever: oh dude I just reinvented this :D
05:56:53 <chpatrick1> interesting
05:59:52 <chpatrick1> dramforever: is Known related to box from modal logic?
06:00:21 <tulcod> chpatrick1: he left. but this is RE: what exactly?
06:00:25 <chpatrick1> oh whoops
06:00:37 <chpatrick1> this: http://lpaste.net/139506
06:00:55 <chpatrick1> I was trying to do natural deduction with the haskell type system
06:01:13 <chpatrick1> and apparently it ended up very similar to intuitionistic logic
06:01:17 <chpatrick1> which I didn't know about
06:02:40 <tulcod> well yeah that's the big nice thing about intuitionism and functional programming
06:02:46 <chpatrick1> https://wiki.haskell.org/Curry-Howard-Lambek_correspondence
06:02:49 <tulcod> the next step in this regard is dependent types, and you obtain agda
06:02:50 <chpatrick1> man there's nothing new under the sun
06:03:22 <tulcod> i can't quite work out what KnownF does, but it sounds like a modality, yes
06:03:30 <tulcod> (modalities are functors)
06:03:52 <tulcod> (uh, is that right?)
06:04:00 <notdan> sounds right
06:04:02 <notdan> hi, tulcod  :)
06:04:07 <tulcod> haha
06:04:32 <chpatrick1> feeling like a total amateur here
06:04:43 <chpatrick1> initially I just wanted implication to be a -> b
06:05:08 <tulcod> chpatrick1: that would be reasonable
06:05:09 <chpatrick1> but that doesn't work because you can't write Not (Not a)) -> a with these definitions
06:05:19 <chpatrick1> because there's no magic way to create an a
06:05:24 <tulcod> chpatrick1: well you're getting intuitionistic logic, not classical logic
06:05:38 <bycn82> OK, C is faster, but C also not able to caculate the fib 100, that is ..... 
06:05:39 <tulcod> chpatrick1: what you can do is something that the mathematicians refer to as truncation
06:05:40 <chpatrick1> so instead I just said instead of a I use KNown a
06:05:52 <tulcod> chpatrick1: if you encapsulate EVERYTHING in Not Not, then the results are classically valid
06:05:54 <chpatrick1> which you can get with a constructor
06:06:01 <chpatrick1> as an axiom
06:06:12 <tulcod> chpatrick1: so while you can write Not (Not a) -> a,  you CAN write Not Not (Not (Not a) -> a)
06:06:21 <tulcod> while you can't*
06:06:30 <notdan> i man the double-negation translation is related to the embedding of intuitinostic logic in modal logic
06:06:31 <notdan> right?
06:06:37 <tulcod> right
06:06:39 <chpatrick1> interesting
06:07:05 <tulcod> chpatrick1: https://en.wikipedia.org/wiki/Double-negation_translation
06:07:07 <chpatrick1> this stuff really reminded me of my modal logic course
06:07:22 <chpatrick1> I remember there was some formula that really looked like the type of <*>
06:07:40 <chpatrick1> :t (<*>)
06:07:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:07:45 <notdan> chpatrick1, tulcod: http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
06:07:47 <chpatrick1> my friend asked the professor about it but I can't remember the conclusion
06:07:47 <notdan> also related
06:07:57 <chpatrick1> yes I read that at the time
06:08:05 <tulcod> chpatrick1: what about ap :)
06:08:35 <chpatrick1> yes exactly
06:08:53 <FUZxxl> lambdabot: help
06:09:02 <tulcod> chpatrick1: and yes, there are some very deep links here, that for some reason only a few people in the world are talking about
06:09:08 <tulcod> welcome to the camp of the intuitionists
06:09:13 <chpatrick1> this is really interesting, thanks guys
06:09:45 <vlatkoB> How can I set major mode for a buffer created with (with-temp-buffer (insert-file-contents...))?
06:09:48 <chpatrick1> one more thing I haven't really figured out yet
06:10:09 <chpatrick1> is the relationship between a -> Known b and a -> b
06:10:20 <vlatkoB> Disregard, wrong channel. :-(
06:10:34 <chpatrick1> if you don't ever use double not elimination then your proof is a proper haskell function
06:11:12 <chpatrick1> but if you need to produce concrete b's then it's impossible
06:11:56 <tulcod> chpatrick1: you mean, on the one hand we can't prove (not not a -> a) intuitionistically, but on the other hand i can't think of counterexamples?
06:12:19 <tulcod> (in terms of true/false values)
06:12:41 <chpatrick1> err
06:12:42 <chpatrick1> not sure
06:13:03 <phaazon> :t divide id
06:13:04 <lambdabot> Not in scope: ‘divide’
06:13:15 <phaazon> @let import Data.Functor.Contravariant.Divisible
06:13:17 <lambdabot>  Defined.
06:13:17 <phaazon> :t divide id
06:13:19 <lambdabot> Divisible f => f b -> f c -> f (b, c)
06:13:19 <chpatrick1> I mean apart from not not a -> a, every other operation may as well operate on real haskell values
06:13:23 <phaazon> pretty cool
06:13:36 <tulcod> chpatrick1: nah, there are more counterexamples
06:13:41 <phaazon> oh that’s actually divided
06:13:43 <phaazon> :t divided
06:13:44 <lambdabot> Divisible f => f a -> f b -> f (a, b)
06:13:47 <tulcod> chpatrick1: intuitionistic logic is a lot like classical logic, but not quite
06:13:59 <chpatrick1> but surely in my program that's true by definition
06:14:08 <chpatrick1> every other logical operation is just regular haskell ADTs
06:14:25 <chpatrick1> the only one that magically produces an "a" is NotNotE
06:14:33 <tulcod> chpatrick1: if you want to do intuitionistic logic, you should stop thinking of the world as true/false
06:14:36 <chpatrick1> using very loose terms here
06:14:44 <chpatrick1> hmm
06:14:54 <tulcod> chpatrick1: by the theorem we discussed, classical logic is in some sense embedded in this framework anyway
06:15:08 <tulcod> in other words, you can always allow yourself to think of the world as true/false, but why would you do that every time?
06:15:42 <tulcod> chpatrick1: classical mathematicians would say that every program either halts or doesn't. so there exists a function (in the mathematical sense) that assigns halting-or-not to every program
06:15:54 <tulcod> chpatrick1: but we know that such a function would never be computable. so why would we call it a function?
06:16:02 <hvr> dmwit_: ping?
06:16:14 <chpatrick1> very deep :)
06:16:37 <tulcod> chpatrick1: and here you start to see the divide between intuitionists and classicalists
06:17:06 <tulcod> the former say that things don't make sense, so stop pretending they do. and the latter seem to believe in a platonic worldview of mathematics, in which everything has a boolean truth value, etc
06:17:11 <notdan> chpatrick1: well you can go from a to Know a but not the other way around
06:17:18 <notdan> once you go classical you cannot go back
06:17:47 <tulcod> chpatrick1: by the way, quite interestingly, you CAN write Not (Not (Not a)) -> Not a.
06:18:00 <tulcod> which is like almost what you want
06:18:05 <chpatrick1> hmm
06:18:51 <phaazon> edwardk: http://i.imgur.com/if9xjyF.png
06:19:00 <phaazon> in the source, you can see the use of divided
06:19:02 <phaazon> works like a charm!
06:22:38 <phaazon> with blending: http://i.imgur.com/VRqeTzJ.png
06:27:24 <t7> ya blender 
06:27:54 * hackagebot avers 0.0.10 - empty  https://hackage.haskell.org/package/avers-0.0.10 (wereHamster)
06:29:12 <tulcod> phaazon: do you know anything about how the GL libs interact with the haskell X11 libs, and potentially wayland?
06:30:53 <tulcod> phaazon: AFAICT it's mostly disconnected, but it should connect somewhere, and i can't quite make out how and where
06:31:12 <phaazon> tulcod: no clue
06:31:31 <phaazon> you should ask to a driver developper :)
06:31:37 <tulcod> phaazon: so how does luminance get a window, straight from the haksell opengl libs?
06:31:39 <phaazon> I just know how it works under the wood
06:31:45 <phaazon> but I don’t really know how X11 is handled
06:31:53 <phaazon> tulcod: it doesn’t
06:31:56 <phaazon> you have to provide it
06:32:00 <phaazon> I use GLFW-b for that
06:32:04 <tulcod> okay, great :)
06:32:06 <afonso> In the ansi-terminal library, how do you put the cursor in the end of the window?
06:32:15 <afonso> I feel like the ansi-terminal library is very limited and not flexible
06:32:19 <phaazon> tulcod: at first I wanted to embed that feature
06:32:25 <phaazon> but in the end, I decided not to for a very simple reason
06:32:39 <tulcod> afonso: you'd best use the ncurses library, which has haskell bindings
06:32:43 <phaazon> I want people to be able to use whatever library they want to
06:32:49 <phaazon> that’s my idea of what “power” is
06:32:54 <phaazon> tiny, elegant, composable
06:33:07 <afonso> tulcod: https://hackage.haskell.org/package/ncurses
06:33:07 <phaazon> I hate huge piece of bloated software
06:33:07 <afonso> ?
06:33:10 <phaazon> you can’t reason about
06:33:19 <tulcod> afonso: yes
06:33:21 <afonso> ok
06:35:30 <tulcod> phaazon: so you get a Graphics.UI.GLFW.Types.Window from GLFW-b, is that right?
06:35:35 <tulcod> phaazon: and how do you feed that into opengl?
06:36:02 <phaazon> tulcod: you use the function makeContextCurrent
06:36:10 <phaazon> and then, in your thread
06:36:19 <phaazon> each issued OpenGL commands occur in the window
06:36:26 <phaazon> occurs*
06:36:41 <phaazon> once you’re done drawing
06:36:42 <tulcod> wow. that's terrible. i understand why you started writing luminance
06:36:44 <phaazon> you call swaBuffers
06:36:49 <phaazon> ahah :D
06:36:53 <tulcod> phaazon: what if you want two windows?
06:36:59 <phaazon> OpenGL is terrible
06:37:01 <tulcod> have to call makeContextCurrent twice per frame?
06:37:16 <phaazon> tulcod: hm, I’ve never done that, but I guess so, yes
06:37:25 <phaazon> OpenGL is a very wrong and ill designed library
06:37:30 <phaazon> OpenGL4.5 is not that bad
06:37:39 <phaazon> and gets close to what Vulkan will be
06:37:53 <phaazon> (with GL_ARB_bindless_texture, GL_NV_shader_buffer_load, and so on)
06:37:54 <tulcod> is vulkan better?
06:38:01 <phaazon> tulcod: definitely
06:38:05 <tulcod> (from a haskell POV)
06:38:07 <phaazon> it’s “unleashed GPU” :)
06:38:10 <phaazon> tulcod: yeah
06:38:14 <tulcod> neat
06:38:19 <phaazon> because it’s less prone to side-effect shitstorm
06:38:25 <phaazon> if you don’t use GL45
06:38:40 <phaazon> you’re stuck without DSA (direct state access), unless you use the extension
06:38:42 <phaazon> but the thing is
06:38:43 <phaazon> without DSA
06:38:53 <phaazon> you have to “bind” objects against the current OpenGL context
06:38:57 <tulcod> phaazon: i'm thinking about graphics API design with one other guy, would you be interested in joining that discussion?
06:39:05 <phaazon> it’s like calling a function that will set a global in the C part, basically
06:39:09 <tulcod> specifically, how to make hayland's API better
06:39:18 <phaazon> hayland?
06:39:19 <phaazon> wayland?
06:39:26 <tulcod> hayland = haskell-wayland
06:39:30 <phaazon> oh
06:39:33 <phaazon> never heard of that
06:39:42 <phaazon> sounds interesting :)
06:40:05 <tulcod> i mean the hayland library exists, and it's a smaller mess than the C API, but we're thinking it should really be something FRP
06:40:33 <phaazon> well
06:40:35 <phaazon> I don’t like FRP
06:40:45 <phaazon> well, that’s not correct
06:40:47 <phaazon> I like FRP theory
06:40:51 <phaazon> I hate FRP practice :)
06:41:01 <phaazon> so I don’t use it
06:41:26 <tulcod> phaazon: that's good - it's a different opinion than ours. so maybe you could help get the discussion going
06:42:04 <phaazon> well sure, with pleasure :)
06:42:05 <tulcod> cause we sorta want to work towards waylandMonad, but a few days ago we decided it'd probably be best to first improve hayland
06:42:20 <phaazon> are you a maintainer?
06:42:48 <tulcod> i wrote hayland, not much more
06:42:55 * hackagebot hackmanager 0.1.0.0 - Generate useful files for Haskell projects  https://hackage.haskell.org/package/hackmanager-0.1.0.0 (AlexanderThiemann)
06:42:55 <phaazon> oh that’s cool :3
06:43:01 <phaazon> I’ll have a look then!
06:43:51 <tulcod> phaazon: can i send you an email about scheduling a next meeting for this discussion?
06:44:00 <phaazon> sure!
06:44:14 <phaazon> do you have my mail address?
06:44:25 <tulcod> nope, if you could PM that :)
06:47:55 * hackagebot microlens 0.3.2.0 - A tiny part of the lens library which you can depend upon  https://hackage.haskell.org/package/microlens-0.3.2.0 (Artyom)
06:47:57 * hackagebot microlens-th 0.2.1.2 - Automatic generation of record lenses for microlens  https://hackage.haskell.org/package/microlens-th-0.2.1.2 (Artyom)
06:47:59 * hackagebot microlens-platform 0.1.2.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.1.2.0 (Artyom)
06:51:46 <faruq> !uptime
06:52:33 <erisco> does it make sense to generate a token that consumes no characters? (lexing)
06:53:51 <phaazon> erisco: lookahead?
06:54:09 <tulcod> erisco: how often would you hope it to be used?
06:54:20 <tulcod> erisco: cause if it doesn't consume anything, it parses infinitely oftnen
06:54:38 <erisco> tulcod, it doesn't parse infinitely often
06:54:47 <erisco> phaazon, can you give an example? I'm not sure
06:56:09 <phaazon> erisco: Alternative, for instance
06:56:14 <phaazon> when you want to try a parser
06:56:16 <phaazon> but it fails
06:56:31 <phaazon> then you need not to consume the input in order to feed the next parser with it
06:56:34 <erisco> this is for lexing though, and I doubt you are going to need or want lookahead for lexing
06:56:50 <phaazon> ah, lexing
06:56:51 <phaazon> well
06:57:04 <phaazon> a constant lexem?
06:57:10 <phaazon> lexeme*
06:59:52 <erisco> phaazon, the typical setup is you match some characters off the front of the stream
06:59:57 <erisco> and then you generate a token from that
07:00:07 <erisco> in this case, you generate a token after matching no characters
07:00:43 <phaazon> yeah, well
07:01:06 <phaazon> I guess the absence of characters could be a token as well
07:01:20 <phaazon> even though that sounds pretty weird to me
07:01:29 <phaazon> tulcod: got it ;5
07:01:32 <phaazon> ;)*
07:01:36 <tulcod> great :)
07:01:53 <erisco> you could end up with two or more tokens for a single position on the stream
07:02:16 <erisco> maybe that just shouldn't be part of the design
07:03:04 <epta> is there a lambda-if expression like a lambda-case?
07:03:45 <erisco> phaazon, I am trying to produce a lexing lib
07:04:05 <erisco> wouldn't want to miss obvious needs
07:04:58 <tulcod> erisco: there's the megaparsec effort going on right now, which tries to radically improve parsec
07:05:19 <phaazon> epta: hm, you can use MultiWayIf
07:05:22 <erisco> this is a lexer not a parser
07:05:30 <lyxia> epta: Perhaps  bool :: a -> a -> Bool -> a  can help?
07:05:33 <phaazon> \x -> if | even x -> … | …
07:06:46 <tulcod> epta: you can just reuse lambda-case: \case { True -> a; False -> b }
07:07:37 <lyxia> that's  bool a b  !
07:08:31 <tulcod> lyxia: seems like it is. so i think this syntax doesn't exist for a very good reason :)
07:11:19 * dramforever watching Categories for the Working Haskeller
07:17:22 <phaazon> lambda-case are fun
07:17:58 <phaazon> even though they’re just a neat way to express case () of { () | … -> } 
07:19:37 <epta> lyxia: bool is ok, but it requires additional parens around a and b when they're an expressions
07:21:53 <exio4> phaazon: that's MultiWayIf
07:22:27 <exio4> phaazon: lambda case is \x -> case x of [P] vs \case [P]
07:22:42 <phaazon> yeah
07:22:42 <phaazon> right
07:22:57 * hackagebot avers 0.0.11 - empty  https://hackage.haskell.org/package/avers-0.0.11 (wereHamster)
07:26:37 <phaazon> bon en fait c’est cool win show
07:26:41 <phaazon> hoops
07:26:42 <phaazon> sorry
07:37:25 <dramforever> OMG now I know what a coalgebra is
07:38:31 <knupfer> Can I retrieve the documentation of a function with haskell-src-exts? It seems that the Comment is not for docs...
07:42:16 <erisco> other than line and column, what would you need in a lexer
07:42:19 <erisco> that is all I need myself
07:42:58 * hackagebot JuicyPixels 3.2.6.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tga, tiff and radiance)  https://hackage.haskell.org/package/JuicyPixels-3.2.6.1 (VincentBerthoux)
07:47:58 * hackagebot avers 0.0.12 - empty  https://hackage.haskell.org/package/avers-0.0.12 (wereHamster)
07:50:24 <c_wraith> erisco: line and column of both start and end of the token, and I could see also wanting just straight position of each in the file, either in terms of bytes or characters.
07:50:41 <erisco> c_wraith, have all those covered
07:50:54 <erisco> well, for characters, presuming Char because that is what the regex lib uses
07:51:20 <erisco> c_wraith, I actually do that information for every character in the token
07:51:35 <c_wraith> I could see preferring byte location in some contexts...  But if the underlying system doesn't give you that, then you're stuck.
07:52:29 <erisco> well, I can take a look
07:53:11 <c_wraith> erisco: tokens don't always match the text lexed over.  Syntactical lexemes like "begin" or "end" are often just represented with data values that aren't character-oriented.
07:53:53 <c_wraith> erisco: (I'm only pointing this out because sometimes the position of every character in the lexeme isn't something that makes sense in the output of the lexer)
07:54:01 <erisco> c_wraith, that is true but you can save where the token started and the length in the token itself
07:54:25 <erisco> c_wraith, that is just the information that goes into whatever generates the token
07:54:31 <erisco> you can keep all or none of it
07:59:56 <faruq> tes
08:05:43 <JoWie> Could someone point me in the right direction to figure out what :# does?: e.g: data Path = [Id] :# !Int
08:06:53 <predator117> JoWie: this defines (:#) as an infix constructor
08:07:03 <predator117> data Path = MkPath [Id] !Int
08:07:17 <predator117> just :# instead of MkPath and infix instead of prefix
08:08:34 <predator117> > data Id = Id Int
08:08:35 <lambdabot>  <hint>:1:1: parse error on input ‘data’
08:10:39 <JoWie> ah that was why i was not able to find it
08:10:39 <indiagreen> what's a good way to consume a list of things in a “parsing” way? like, I have a list of lines, and I want to consume the 1st line, then look at it and do something with the next N lines, then do something else
08:11:02 <JoWie> i assumed :# was part of the language
08:11:04 <JoWie> thanks
08:11:05 <indiagreen> I could do it with lots of “splitAt”s and “let”s and so on, but it looks ugly
08:11:43 <Walther> "lines" to get a list of lines and take from that list to get line by line?
08:12:30 <Gurkenglas_> indiagreen, Parsec is parametric in its stream type, you can use lines instead of characters
08:12:44 <myname_> @p
08:12:44 <lambdabot> Maybe you meant: palomer part paste ping pinky pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pop-topic pretty print-notices protontorpedo purge-notices push-topic v @ ? .
08:12:47 <myname_> @pl
08:12:47 <lambdabot> (line 1, column 1):
08:12:47 <lambdabot> unexpected end of input
08:12:47 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:12:59 <myname_> @pl isPrime n = n >= 2 && (all ((/= 0).(mod n)) . takeWhile ((<= n).(^2))) [2..]
08:12:59 <lambdabot> isPrime = liftM2 (&&) (>= 2) (flip (ap ((.) . all . ((0 /=) .) . mod) (takeWhile . (. (^ 2)) . flip (<=))) [2..])
08:16:11 <myname_> @pl goldbach n = if odd n then (if primes!(n - 2) then Just 2 :: Maybe Integer else Nothing) else (find (\a -> primes!(n - a)) $ filter (primes!) $ takeWhile (\i -> i < n - i) [2..])
08:16:11 <lambdabot> goldbach = liftM2 if' odd (flip (flip if' (Just 2 :: Maybe Integer) . (primes !) . subtract 2) Nothing) `ap` ap (find . ((primes !) .) . (-)) (filter (primes !) . flip takeWhile [2..] . ap (<) . (-))
08:21:09 <myname_> @h
08:21:09 <lambdabot> Maybe you meant: hackage haskellers help hitchcock hoogle hoogle+ v @ ? .
08:21:12 <myname_> @help
08:21:12 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:21:15 <myname_> @help if'
08:21:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:21:24 <myname_> @help (if')
08:21:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:21:30 <myname_> @help list
08:21:31 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
08:21:38 <myname_> @help list module
08:21:39 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
08:21:46 <myname_> @help list [if']
08:21:46 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
08:21:49 <myname_> @help [if']
08:21:49 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:22:08 <myname_> What is the module for if'?
08:22:59 * hackagebot pcre-heavy 0.2.4 - A regexp library on top of pcre-light you can actually use.  https://hackage.haskell.org/package/pcre-heavy-0.2.4 (myfreeweb)
08:23:01 * hackagebot blaze-bootstrap 0.1.0.1 - Blaze helper functions for bootstrap pages  https://hackage.haskell.org/package/blaze-bootstrap-0.1.0.1 (AlexanderThiemann)
08:24:04 <hexagoxel> myname_: http://hayoo.fh-wedel.de/?query=if%27
08:24:40 <erisco> I wonder how using Seq for append compares with consing and reversing at the end
08:24:53 <erisco> seems like a good question
08:25:37 <hexagoxel> myname_: (also it is @list or @listmodules) (and you can /query lambdabot)
08:26:20 <myname_> @list if'
08:26:20 <lambdabot> No module "if'" loaded
08:26:30 <myname_> @listmodules if'
08:26:30 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
08:26:30 <erisco> in context after you have either your list or your Seq, you're going to want to convert to a third structure
08:26:44 <erisco> such as [], Seq, Vector, Array, etc
08:28:26 <erisco> actually interesting, if you look at the benchmark posted here https://wiki.haskell.org/Performance#Data.Sequence_vs._lists the difference is stunning
08:28:33 <erisco> happens to be entirely related
08:29:56 <myname_> @pl composition a b = do
08:29:57 <lambdabot> composition = const (const do)
08:29:57 <myname_>     foldl' (\(x, y) (ax, ay) -> (x + ax, (y * ay) `mod` m)) (0, 1) $ map (\n -> value n $ goldbach n) $ [a..b]
08:30:17 <codehero> jdt: you're the one who made brick?
08:30:27 <erisco> and I wager if you wanted to go faster still you'd use an ArrayList
08:30:59 <myname_> @pl composition a b = foldl' (\(x, y) (ax, ay) -> (x + ax, (y * ay) `mod` (10^9+7))) (0, 1) $ map (\n -> value n $ goldbach n) $ [a..b]
08:31:00 <lambdabot> composition = ((foldl' (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. flip (flip . (mod .) . (*)) 1000000007) . flip . (((.) . (,)) .) . (+))) (0, 1) . map (ap value goldbach)) .) . enumFromTo
08:31:14 <codehero> oO
08:33:00 * hackagebot pcre-heavy 0.2.5 - A regexp library on top of pcre-light you can actually use.  https://hackage.haskell.org/package/pcre-heavy-0.2.5 (myfreeweb)
08:35:54 <erisco> hm, using the quasi quoting for compile time checking is smart
08:37:16 <erisco> myfreeweb, hey you
08:37:55 <myfreeweb> erisco: ?
08:38:00 * hackagebot digestive-bootstrap 0.1.0.1 - Speed up form designing using digestive functors and bootstrap  https://hackage.haskell.org/package/digestive-bootstrap-0.1.0.1 (AlexanderThiemann)
08:38:03 <erisco> thanks for the lib
08:38:22 <erisco> does it work with the Text.Regex.Base stuff at all?
08:38:48 <myfreeweb> nope
08:38:55 <myfreeweb> I've explicitly said "none of that regex-compat-pluggable-backend stuff" in the README
08:39:24 <erisco> I don't actually know what regex-compat-pluggable-backend is
08:40:03 <myfreeweb> that's how I called regex-base
08:40:07 <erisco> if you are using regex-pcre then it depends on regex-base
08:40:13 <myfreeweb> I'm using pcre-light
08:40:16 <indiagreen> Gurkenglas_: ha, I found a simpler way by noticing that splitAt is essentially a State action
08:40:31 <myfreeweb> that's why it's called pcre-heavy
08:40:55 <erisco> oh I see, so pcre-light is a standalone regexp engine
08:41:40 <Gurkenglas_> indiagreen: Don't forget uncons for the singular case
08:42:22 <erisco> myfreeweb, or is it calling out to a native C lib? seems like it might, I'm curious
08:42:43 <erisco> I have been working with regex-tdfa for a few days and released regex-tdfa-pipes
08:42:52 <myfreeweb> it's a binding to, obviously, PCRE
08:42:53 <erisco> I like that you've got the quasi quoters to check the regexp at compile time
08:45:22 <erisco> myfreeweb, what are your reasons for disliking regex-base stuff?
08:47:05 <erisco> myfreeweb, a redeeming quality is uncons, which means it will request more chars as it needs them
08:47:10 <erisco> which allowed me to make it work with pipes
08:47:15 <myfreeweb> I just don't like it? it seems too complicated
08:47:32 <erisco> I am looking at pcre-light and while it looks much simpler (that is a good thing) it seems I have to give it an entire bytestring up front
08:47:59 <erisco> which means I can't stream data to it
08:48:31 <myfreeweb> PCRE (the C library) doesn't do stream matching
08:48:46 <erisco> yeah evidently so
08:48:46 <myfreeweb> I don't think stream regex matching is useful anyway
08:48:57 <erisco> well it is useful if you're working with pipes :)
08:49:32 <erisco> I really want to use the compile timed checked expressions
08:50:00 <myfreeweb> that quasiquoter is 3 short lines of code, lol
08:50:03 <erisco> so... I might take a looksie at your work and implement it for tdfa if you don't mind
08:50:20 <myfreeweb> I stole the idea from regexqq :D
08:50:24 <myfreeweb> and others
08:50:28 <erisco> best artists steal
08:50:54 <myfreeweb> I saw https://github.com/dag/vim2hs#quasi-quoting syntax highlighting for regexps in quasiquoters
08:51:22 <erisco> oh yeah, cool
08:51:45 <erisco> we'll you're spot on that Haskell needs some renovations in the regexp department
08:52:12 <erisco> I'm not totally convinced by the -base stuff either
08:52:29 <erisco> it seems too optimistic to try and classify all regexp engines
08:52:43 <erisco> it tries to do this with half a dozen type classes or so
08:55:00 <erisco> I have a working theory that optimistic generalisations are not a good thing
09:03:28 <rpfun> ghc is complaining that it cannot deduce (using TypeLits) that n ~ (n + 1) -1
09:03:55 <rpfun> is there a way to convince it otherwise without introducing a constraint (as that would force me to use undecidableinstances)?
09:05:51 <nitrix> Does category theory allows you to have multiple morphisms with the same source and target objects?
09:06:03 <nitrix> Also, is it possible to get recursive compositions and is there a notation for that?
09:06:36 <akegalj> Hey. I have sandboxed project in folder A and in folder B. I would like to tell project A to use installed stuff from project B so I did 'cd A; cabal sandbox add-source B'. Do I have to put project B as a dependency in A.cabal ?
09:06:58 <rpfun> nitrix: yes to the first question
09:07:02 <tulcod> nitrix: most categories have many (usually infinitely many) morphisms between any two fixed objects
09:07:21 <rpfun> akegalj: yes
09:07:36 <tulcod> nitrix: not quite sure what recursive composition is. are you looking for fixed point operators? are you looking for the composition of a list of functions?
09:08:01 * hackagebot microformats2-parser 1.0.1 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-1.0.1 (myfreeweb)
09:08:03 <akegalj> rpfun: but when I do so, it is trying to install and get project B from hackage (which is there also)
09:08:06 <tulcod> nitrix: like, are you looking for [a -> a] -> (a -> a)  ?
09:08:44 <Gurkenglas_> :t ala Endo foldMap
09:08:46 <lambdabot> Foldable t => t (a -> a) -> a -> a
09:08:49 <nitrix> tulcod: I'm thinking, if you have the morphism  f: A -> B, and another g: B -> C, and one more h: C -> A, when composed, f*g*c they form a recursive definition. Is there a notation for that?
09:09:50 <tulcod> nitrix: f.g.h
09:09:59 <tulcod> but that's probably not what you're looking for
09:10:34 <nitrix> tulcod: And that's it? Simple composition dot, no extra notation?
09:11:18 <nitrix> This stuff is fairly new to me and I was afraid learning the notation would be hard, but so far, it seems the theory is what's the most complicated.
09:11:28 <nitrix> I appreciate.
09:11:34 <rpfun> akegalj: ah, i see. you could run cabal install on the directory B from directory A, that should install in the sandbox. 
09:11:36 <tulcod> nitrix: oops, the composition is actually the other way around
09:11:56 <tulcod> nitrix: if f:A->B, and g:B->C, and h:C->D, then the composition is h.g.f
09:11:58 <tulcod> ("reverse")
09:12:16 <tulcod> and that composition is a function: h.g.f : A -> D
09:12:26 <nitrix> D ?
09:12:34 <tulcod> well i dunno, just introducing a new variable
09:12:44 <Gurkenglas_> Mnemonically, h.g.f = \x -> h(g(f(x))), complain to whoever decided to put function names in front of the arguments
09:13:04 <nitrix> tulcod: Okay, yours isn't mutually recursive though.
09:13:10 <tulcod> "mutually recursive"?
09:13:46 <nitrix> I'm not sure if there's a term for that, but in my example, the h morphism had a definition of C -> A, not C -> D, forming a loop.
09:13:55 <tulcod> nitrix: okay, so what?
09:13:55 <Gurkenglas_> You want special notation for a morphism having its domain and codomain equal?
09:14:17 <tulcod> nitrix: in that case, you would get h.g.f : A -> A
09:14:18 <nitrix> Gurkenglas_: I'm asking if there's one.
09:14:19 <tulcod> so?
09:15:01 <nitrix> tulcod: Ah sorry. That actually makes sense.
09:15:05 <tulcod> nitrix: mathematicians would call it an endomorphism (where "morphism" is just their fancy word for "function", and "endo" means "something to itself")
09:15:31 <nitrix> Great <3
09:16:06 <nitrix> Now I have something substantial to continue my googling spree :p
09:16:14 <HolyGarbage> I just arrived. Endomorphism is the mathematical way of saying "recursive function"?
09:16:58 <akegalj> rpfun: hm, i can't find how to do that with cabal. It is always building the current directory
09:17:19 <tulcod> HolyGarbage: "recursive" in nitrix' sense
09:17:34 <srhb> Which is not commonly what is meant by recursive.
09:17:39 <nshepperd> there's nothing particularly recursive about a morphism that goes back to the same point
09:18:08 <HolyGarbage> Right
09:19:22 <HolyGarbage> We're learning Haskell in our next CS class. This is our course literature: http://learnyouahaskell.com/ Anyone had any experience with it? Any good?
09:20:00 <rpfun> akegalj: i just tested out what I said
09:20:10 <tulcod> HolyGarbage: was my main reference while learning it, i'd say
09:20:24 <nitrix> HolyGarbage: It's in my experience the best resource for begineers and the one I used. It does half the work for you, which is already huge.
09:20:27 <tulcod> well that and Real World Haskell
09:20:28 <c_wraith> HolyGarbage: it's a decent intro up until it starts getting into higher-kinded type classes.
09:20:33 <rpfun> akegalj: go into directory "A", then in directory "A" run "cabal install B" where "B" is the path to the local project you want to install in the sandbox
09:20:38 <c_wraith> HolyGarbage: I don't think it handles them very well
09:21:28 <HolyGarbage> Ah, thanks for your info. Always good to know if I'm wasting my time or should look for something else to learn from.
09:21:30 <bergey> HolyGarbage: I find the tone / writing style grating.  But if the style works for you, the content's fine.
09:21:31 <nitrix> HolyGarbage: As with anything, it's always good to learn something from multiple perspectives; so ideally you'd supplement that book with other books; but it definitely proposes a good intro.
09:21:45 <rpfun> ghc is complaining that it cannot deduce (using TypeLits) that n ~ (n + 1) -1 . is there some trick known to get it to see this?
09:21:53 <HolyGarbage> Ah, true
09:22:05 <akegalj> rpfun: oh, i didn't know you can give path to local repository to cabal install. Thnx
09:22:23 <tulcod> HolyGarbage: in general, i'd say people read too much stuff about haskell, instead of just programming with it. try to find a way to solve a weird problem (e.g. how would YOU design an API for IO in a purely functional language?)
09:22:48 <glguy> rpfun: There's work incorporating a smarter solver into GHC by Iavor Diatchki, but it's not incoporated into released GHC currently (AFAIK)
09:22:54 <tulcod> usually, if you don't invent the real thing, you'll invent an older version of it
09:23:02 * hackagebot utf8-string 1.0.1.1 - Support for reading and writing UTF8 Strings  https://hackage.haskell.org/package/utf8-string-1.0.1.1 (EricMertens)
09:23:25 <glguy> rpfun: Starting point: https://github.com/yav/type-nat-solver
09:23:27 <HolyGarbage> akegalj: good point!
09:24:06 <nitrix> Think you meant tulcod :P
09:24:30 <benneh> how do I access a screen or window's pixel data? (i'm using linux) I've looked at the x11 package, but it seems to miss some important functions, including getImage and getPixel
09:24:58 <rpfun> glguy: thanks, but I know about that. the only issue in my project is the particular case (n - 1) + 1 ~ n, and I would rather not add a whole dependency for that single constraint. I was hoping there was a short way I could enforce it myself
09:25:00 <rpfun> even if just locally
09:34:54 <erisco> " This is consumed by the CorePattern module and the tender leaves are nibbled by the TNFA module."
09:34:57 <erisco> someone was having a good time
09:42:59 <elfeck> heyoh, Persistent Question with SQL:
09:42:59 <elfeck> How can I use selectList and only get a specified row from a table?
09:43:50 <Welkin> elfeck: why would you do that?
09:44:01 <Welkin> elfeck: use get/get404 if you have the id
09:44:31 <Welkin> otherwise, use getBy/getBy404
09:45:41 <elfeck> I have a table User with many fields (e.g name, age, gender). Now I want all ages in that table 
09:45:45 <elfeck> how do I do this?
09:46:08 <elfeck> Ohw I meant column instead of row
09:50:35 <Welkin> elfeck: select all the rows you want, then pull out the columns in your program
09:50:51 <erisco> in quasiquoting... I need an ExpQ and I have some data that I've constructed in the quoter
09:50:57 <erisco> how can I turn that data into an ExpQ?
09:51:03 <Welkin> I'm not sure persistent has support for more complex queries like what you want
09:51:08 <erisco> I am thinking there is some brackets I can use but I can't remember
09:51:10 <Welkin> you could try esqueleto
09:51:32 <Welkin> form what I know, persistent only returns full rows
09:51:35 <Welkin> from*
09:52:21 <elfeck> okay thanks Welkin
09:53:08 <Welkin> there is the rawSql function too
09:53:12 <Welkin> but that is not safe
10:00:28 <elfeck> Can you estimate the performance hit if I pull, say 1000 (small) entries from the database and then do the filtering?
10:02:36 <erisco> you won't achieve the maximum velocity of a sheep in a vacuum with that approach, but you might still finish the Kessel run in 12 parsecs
10:06:55 <tulcod> erisco: you might be interested in http://www.ncbi.nlm.nih.gov/pubmed/12507336
10:08:03 <siwica> What is the name of a function a -> [a], wrapping an element in a list?
10:08:17 <Cale> (:[])
10:08:57 <zipper> How do you guys handle subdirectories in your images/ directory when using hakyll?
10:08:57 <siwica> cool, thanks!
10:08:59 <Cale> > map (:[]) [1..10]
10:09:00 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
10:10:13 <erisco> I don't get how to use dataToExpQ
10:10:16 <erisco> what is the first parameter even?
10:10:19 <erisco> :t dataToExpQ
10:10:21 <lambdabot> Not in scope: ‘dataToExpQ’
10:10:35 <erisco> @hoogle dataToExpQ
10:10:35 <lambdabot> Language.Haskell.TH.Quote dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp
10:11:11 <erisco> going to guess 'const Nothing'
10:14:30 <rohan> map (+1) [1..10]
10:14:35 <rohan> > map (+1) [1..10]
10:14:37 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
10:20:29 <glguy> erisco: erisco: You'd only use (const Nothing) there if you didn't want any special cases
10:20:33 <glguy> runQ (stringE 07. show 07=<< dataToExpQ (fmap (07\x 07-> 07case x 07of True 07-> stringE 04"True"; False 07-> stringE 04"False") 07. cast) (Just True))
10:20:37 <glguy> LitE (StringL "AppE (ConE GHC.Base.Just) (LitE (StringL \"True\"))")
10:20:45 <erisco> I don't know what "special cases" are
10:20:55 <glguy> They are cases that aren't the default
10:21:09 <erisco> I dunno then, defaults sound fine
10:21:15 <glguy> dataToExpQ has some built in ExpQ generation. If you don't want to use it for some types you provide the override there
10:21:22 <glguy> Not all types can be handled by default
10:25:43 <humanoyd> Is ViewPatterns a safe extension to use?
10:26:17 <horatiohb> If I defined 'class A a', 'data B = B', and 'instance A B', then why can't I define the function f = B with signature (A a) => a ?
10:26:25 <horatiohb> (*defined -> define)
10:26:46 <Cale> humanoyd: Yes, there's nothing dangerous you can do with it.
10:27:04 <humanoyd> Cale: thx
10:28:06 <bennofs> horatiohb: because f does not work for *all* instances of the class A
10:28:16 <bennofs> horatiohb: it only works if a ~ B
10:28:18 <Cale> humanoyd: If you care about being able to run your code on other implementations of Haskell, I don't know how many implement that extension, but it seems like it should be easy enough to implement.
10:28:32 <Cale> (it's pretty thin syntax sugar)
10:29:38 <erisco> oh no
10:29:40 <humanoyd> ghc will be more than enough :)
10:29:56 <erisco> I've spent, like, forever chasing errors and doing standalone derivings for Data and Typeable
10:30:19 <erisco> just to find "No instance for (Data.Data.Data ... Position -> OrbitTransformer)"
10:30:26 <erisco> have a feeling functions aren't Data
10:30:49 <Cale> erisco: That is correct, they aren't instances of Data
10:31:02 <erisco> I wish it could have recursively derived all this stuff
10:31:04 <Cale> Data is for algebraic-data-ish types
10:31:05 <erisco> and then told me this sooner
10:31:13 <erisco> I've, got, like, 20 declarations to get to this point
10:31:31 <horatiohb> bennofs: thanks, I forgot about the 'all' bit.
10:31:37 <erisco> I was hoping that I could compile the regexp at compile time and replace with the internal representation
10:31:48 <erisco> but for whatever reason it contains this function
10:31:51 <erisco> all for naught!
10:33:36 <indiagreen> is Data.Binary lazy? for instance, will “writeFile . encode . map f . decode . readFile” run in constant space?
10:34:46 <Cale> indiagreen: Potentially, yes.
10:35:54 <indiagreen> hm, tho apparently the Binary instance for lists calculates length before writing the list
10:36:01 <indiagreen> so it can't be as lazy as I want it to be
10:36:13 <Cale> oh, yes, I actually just found the source as you said that and was about to say the same :)
10:36:17 <erisco> however, I can at least use the "Pattern"
10:36:27 <erisco> which is an AST for the parsed regex string, at least
10:36:43 <erisco> though it'd be really nice to not have the regex compilation happen at runtime
10:37:06 <Cale> indiagreen: That's rather unfortunate, though I guess doing it the other way would result in a much larger file.
10:37:44 <indiagreen> Cale: I guess for my usecase I could write something like “ListGoingTillEndOfInput a” with custom instances
10:37:52 <indiagreen> I wonder whether this exists already
10:38:42 <erisco> Cale, I mean, I guess there is no reason it couldn't work
10:38:45 <Cale> indiagreen: Or depending on usage, you might not even need a newtype, just a putListLazy action
10:38:55 <erisco> it just has to assign the field to whatever the function name is...
10:39:02 <erisco> but I have no idea how I'd set that up
10:39:13 <erisco> all I know is to use dataToExpQ
10:39:26 <erisco> which requires Data, which says I can't have functions
10:40:47 <Cale> erisco: I guess just direct recursion on the structure?
10:40:50 <erisco> the only other thing I know would be to write a boat load of code to convert the Regex to an ExpQ myself
10:40:57 <erisco> well, that doesn't work either
10:41:07 <erisco> if I have a Regex value I can't reflect and figure out the function name
10:41:10 <erisco> hmm
10:41:13 <Cale> Well, yes.
10:41:24 <Cale> The function might not have a name
10:41:30 <Gurkenglas> http://dev.stephendiehl.com/hask/#applicatives <- "As a rule of thumb, whenever we would use m >>= return . f what we probably want is an applicative functor, and not a monad." <- Don't we want just a Functor in that case? (f <$> m)
10:41:35 <erisco> well, whatever the definition is, I don't care
10:41:43 <erisco> I just need to assign the field to the function thingie
10:41:52 <erisco> but I suppose I'd need to reflect
10:42:02 <erisco> not sure I can actually do that... can I?
10:42:37 <Cale> Gurkenglas: Correct. m >>= (return . f) = fmap f m
10:43:23 <Cale> erisco: Yeah, there's not necessarily a way to get the definition of a function value in TH.
10:43:30 <rpfun> is there a way to set an instance of a type family to any type?
10:43:51 <Cale> erisco: But you could write something perhaps which used the name of a function explicitly.
10:44:07 <rpfun> i.e. so that for "type family TF a :: *", "type instance TF (Int) = e" for all e?
10:44:12 <erisco> I don't know what it is
10:44:23 <Zekka> Gurkenglas: Although we probably still want >>, in which case we want an applicative afaik
10:44:24 <erisco> I am guessing it changes based on various things
10:44:29 <erisco> otherwise why would they bother
10:44:29 <Cale> rpfun: I'm not sure that makes sense.
10:44:52 <Cale> rpfun: Perhaps you could write  type instance TF Int = forall e. e
10:45:05 <erisco> it'd be nice to have some way to force compilation
10:45:06 <Cale> rpfun: However, that's possibly not the same as what you mean
10:45:07 <rpfun> Cale: trying to see if that compiles/works properly now
10:45:23 <Cale> rpfun: forall e. e does not have many values (only undefined has that type)
10:45:32 <rpfun> oh
10:46:32 <monochrom> this is eqivalent to: "I am defining f:N->N. can I define f(0)=x for all x?"
10:46:52 <Cale> rpfun: Type families are basically type-level functions. You can't really say "just use whatever", the same way that you can't define a value-level function to just produce "whatever result is needed"
10:48:07 <rpfun> perhaps a usecase will make this clearer: i have a function "f :: a -> (b -> TF a) -> b -> TF a" . in the case of (for example) "a ~ Int", i would like to be able to pass any function
10:48:18 <rpfun> b -> TF a
10:48:53 <Cale> Yeah, that's not possible.
10:48:59 <rpfun> why not?
10:49:07 <Cale> You have to pass a function of type b -> TF a
10:49:20 <Cale> Or b -> TF Int
10:49:27 <rpfun> ah, i see
10:49:31 <Cale> TF Int is going to be some particular type
10:50:16 <rpfun> but is there some way to accomplish something similar?
10:51:32 <Cale> Maybe you can explain what f is supposed to do?
10:51:44 <monochrom> change f's type to "a -> (b -> c) -> (b -> c)". then the 2nd parameter can be any function.
10:52:03 <lpaste_> buff3r pasted “hackerrank challenge” at http://lpaste.net/139510
10:52:48 <Cale> Perhaps f :: a -> TF a  and  type instance TF Int = forall b c. (b -> c) -> (b -> c)
10:53:06 * hackagebot http-link-header 1.0.0 - A parser and writer for the HTTP Link header as specified in RFC 5988 "Web Linking".  https://hackage.haskell.org/package/http-link-header-1.0.0 (myfreeweb)
10:53:08 * hackagebot hvect 0.3.0.0 - Simple strict heterogeneous lists  https://hackage.haskell.org/package/hvect-0.3.0.0 (AlexanderThiemann)
10:53:09 <lpaste_> buff3r pasted “hackerrank challenge” at http://lpaste.net/139511
10:54:04 <buff3r> ^^ all, trying to speed up this haskell example, unfortunately i don't have any experience optimizing haskell code
10:54:10 <horatiohb> How does one turn on the GHC extension for existential types? (Docs don't seem to indicate.)
10:54:13 <buff3r> wondering if you have any tricks/tips off the top of your head for making things faster
10:54:22 <erisco> at the very least, if you manage to parse a Pattern you have a valid regex
10:54:31 <rpfun> Cale, monochrom: so in a bit more detail, i have "f :: a -> (b -> TF a) -> TF a" because if (for example) "a ~ String", i might have a "default" string and i need to be able to use it, but if "a ~ Int", there is no need for a default
10:54:37 <erisco> the patternToRegex function always succeeds (judging by the type, who knows really)
10:54:39 <monochrom> {-# LANGUAGE ExistentialQuantification #-}
10:54:59 <erisco> annoyingly it is probably the more expensive step... well whatever
10:55:28 <Cale> rpfun: But what program is f?
10:55:46 <Cale> rpfun: Perhaps if we know what the function does, we can help come up with a reasonable type for it
10:56:45 <rpfun> Cale: OK, thank you! i will put up a simplified example on lpaste in a minute
10:58:42 <Fay> hi guys
11:02:10 <adarqui> hey i'm trying to figure out some stuff with lenses.. i'm in MonadState with "todoAppTodos" being a M.Map Int Todo.. how can I perform ops on this todoAppTodos? i'm trying things like: use (to (M.lookup todo_id)) todoAppTodos  etc.. can't figure it out
11:02:11 <monochrom> buff3r: the most important optimization technique is replacing brute-force computing by mathematical thinking.
11:03:01 <monochrom> that is, the computer program serves merely to print out the answer found by your own mind, not to compute anything.
11:03:02 <indiagreen> adarqui: use (todoAppTodos . at todo_id)
11:03:15 <indiagreen> if I have understood you correctly
11:03:49 <monochrom> the number of squares between n and m (inclusive) equals the number of integers between sqrt(n) and sqrt(m) (inclusive)
11:04:17 <monochrom> equals the number of integers between ceiling(sqrt(n)) and floor(sqrt(m)) (inclusive)
11:04:19 <buff3r> monochrom: okay so there's a mathematical property i'm missing here, you're saying
11:04:32 <monochrom> equals floor(sqrt(m)) - ceiling(sqrt(n)) + 1
11:04:38 <adarqui> thnx. indiagreen, this should clarify, other than lpaste'n it: view (C.to (M.lookup 1)) M.empty ... so that's in a function without state? i'm trying to translate that to a function that works inside MonadState.. which I thought I could basically do: use (C.to (M.lookup 1)) todoAppTodos
11:04:54 <adarqui> that view (C.to ...) one works
11:05:28 <indiagreen> adarqui: view operates on whatever you give it – like, “view _1 (1,2) == 1”
11:05:40 <indiagreen> adarqui: use is the same as “get” and then “view”
11:05:51 <buff3r> monochrom: thanks
11:06:03 <adarqui> ya.. so i'd imagine this would work: use (to (M.lookup 1)) todoAppTodos
11:06:11 <adarqui> i'll commit the code in a sec and link it
11:06:16 <indiagreen> adarqui: so if todoAppTodos is a *field* of your state, you should be able to say “use todoAppTodos” to get it
11:06:37 <indiagreen> adarqui: if todoAppTodos is just some value you have, then being in MonadState is simply irrelevant
11:07:43 <adarqui> nah it's inside the state
11:07:46 <adarqui> 1sec
11:08:07 * hackagebot Spock 0.9.0.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-0.9.0.0 (AlexanderThiemann)
11:08:34 <lpaste_> rpfun pasted “Type family example” at http://lpaste.net/3293192317673930752
11:09:23 <rpfun> Cale, monochrom: i pasted it there. it's heavily simplified. the idea is it would be very inconvenient to add a third type parameter "e" to TWrap to replace TA
11:09:36 <rpfun> * heavily simplified from the actual usecase
11:09:56 <buff3r> monochrom: any relevant links for that property you could share?
11:10:04 <buff3r> there's this http://math.stackexchange.com/questions/548043/how-to-find-all-perfect-squares-in-a-given-range-of-numbers
11:10:19 <adarqui> sorry for not lpasteing originally folks.. https://github.com/adarqui/todomvc-haskell-servant-purescript/blob/master/haskell_src/Todo/App.hs#L55-L62  .. and here's my error: http://lpaste.net/139515
11:10:21 <monochrom> I didn't use any link.
11:11:00 <fr33domlover> Q: what does [incoherent] mean? I saw [safe] before, but not [incoherent] until now
11:11:20 <buff3r> monochrom: that's cool, i'll do some googling
11:11:39 <monochrom> it means IncoherentInstances
11:11:57 <indiagreen> adarqui: look at the signature of “use”
11:12:14 <fr33domlover> monochrom, thanks, I'll read about it (I assume it's a GHC ext.)
11:12:16 <nitrix> Hi guys, I'm trying to build an application that uses simplessh on windows and I keep getting an error about a missing ssh2 library. If I was on linux, this would be trivial, but windows being what it is, where am I supposed to install that library? MinGW? Cabal? System32?
11:12:23 <nitrix> I'm using the Haskell Platform.
11:12:37 <Cale> fr33domlover: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/type-class-extensions.html#instance-overlap
11:13:00 <adarqui> it's similar to indiagreen :/ i dno
11:13:02 <indiagreen> adarqui: in particular, notice that it only takes 1 argument but you're giving it 2
11:13:23 <Cale> fr33domlover: I would generally stop using type classes altogether if it became apparent that I was going to need to use overlapping instances.
11:13:39 <fr33domlover> Cale, I saw this in aeson
11:13:48 <fr33domlover> just curious what it means :)
11:13:55 <fr33domlover> reading now
11:14:23 <rpfun> Cale, monochrom: would it just be better to pass "TA a" as a paramter to "TWrap", even though it might be unused in many cases?
11:15:09 <indiagreen> adarqui: I don't know what exactly you think “use” does, but it looks like you think “use lens field” gets the field and applies the lens to it
11:15:10 <adarqui> i'm new to lenses, so their actual architecture i'm not knowledgable of.. i've been trying to figure this stuff out by reading the source. view has a similar sig to use. the view example i give works
11:15:23 <adarqui> indiagreen: right but i'm using 'view' in the same manner
11:15:32 <Jookia> is 'm (a -> f b) -> m (f a) -> m (f b)' the same as 'fmap (=<< myFunc :: (IO f a)) (thing :: IO (a -> f b))'?
11:15:38 <adarqui> > :t Control.Lens.view
11:15:40 <lambdabot>  <hint>:1:1: parse error on input ‘:’
11:15:46 <adarqui> guh
11:15:48 <indiagreen> view (C.to (M.lookup 1)) M.empty
11:15:50 <indiagreen> here
11:15:56 <indiagreen> “C.to (M.lookup 1)” = getter
11:16:00 <indiagreen> M.empty = value
11:16:13 <edwardk> indiagreen: "use _1" will use the _1 lens to access the current state.   "uses _1 length" will use the _1 lens to access the current state and apply length the result
11:16:21 <edwardk> :t gets
11:16:23 <lambdabot> MonadState s m => (s -> a) -> m a
11:16:28 <edwardk> this is similar to get and gets
11:16:35 <edwardk> but with a lens bolted in
11:16:43 <indiagreen> edwardk: I know about uses, it's not what adarqui is using
11:17:04 <lambdadoodle> > [1,2,3]
11:17:06 <lambdabot>  [1,2,3]
11:17:07 <nitrix> How do I supplement `cabal install --only-dependencies` with a path to extra C libraries? I'm getting an error for a missing library `ssh2` on windows.
11:17:09 <edwardk> "view _1" will read the result of _1 from the environment, while views _1 length   will read the result of _1 from the environment and then apply length to the result
11:17:25 <adarqui> view (to (M.lookup 1)) M.empty .. should be similar to: use (to (M.lookup 1)) somethingInState ??
11:17:37 <nitrix> One of the dependencies is failing on me.
11:17:42 <adarqui> somethingInState beings a lens
11:17:49 <sm> nitrix: --extra-{library,include}-dirs or something, see --help, 
11:18:13 <nitrix> sm: That works for my project, but no the dependency itself.
11:18:14 <Cale> rpfun: This is still way more abstracted than I was hoping for, it's still not at all clear to me why this has to behave non-uniformly when a is Int.
11:18:51 <edwardk> adarqui: e <- use (to (M.lookup tid)) todoAppTodos       should just be get (todoAppTodos . M.lookup tid)    or some such  or you should call 'uses' instead
11:19:24 <nitrix> sm: It's the dependency that I'm using that is bogus: http://hub.darcs.net/thoferon/simplessh/browse/simplessh.cabal
11:19:27 <indiagreen> edwardk: todoAppTodos is a lens
11:19:38 <indiagreen> so it's use (todoAppTodos . at tid)
11:19:57 <edwardk> ok, yeah this was pretty confused
11:20:06 <Cale> rpfun: But perhaps uLookBy should be a class method?
11:20:08 <sm> nitrix: libssh2 on windows may be a hassle - installing such (system) deps up to you unfortunately
11:20:17 <edwardk> e <- use (todoAppTodos.at id)
11:20:22 <nitrix> sm: Their cbits/simplessh.c  #include a <libssh2.h> that's not on this windows system and I'm confused where to install it.
11:20:40 <sm> s/up/is up/
11:20:41 <indiagreen> adarqui: use lens = do {state <- get; return (view lens state)}
11:21:38 <rpfun> Cale: that's how i had it originally, but since i can /almost/ write it without typeclasses i was hoping it was possible
11:21:42 <indiagreen> adarqui: it takes one parameter – a lens (well, okay, fine, actually a getter) – and then takes the whole state and extracts something-you-want from that state
11:21:54 <indiagreen> adarqui: for instance, you have “gets _todoAppTodos” in your code
11:22:05 <indiagreen> adarqui: you can replace it with “use todoAppTodos”
11:22:48 <Jookia> how could i take 'testA :: [Int -> Maybe Double]' and apply 'testB :: [Maybe Int]' to it? 'fmap (=<< testB) testA' doesn't work though it looks like it should with types
11:22:50 <indiagreen> adarqui: in fact, you can rewrite your whole listTodos as “use (todoAppTodos . to M.elems)”
11:23:14 <adarqui> ya that's what i'm trying to do.. rewrite all of this with lenses
11:23:25 <adarqui> thanks edwardk indiagreen .. i'm still messing with it
11:24:42 <buff3r> i found this (https://en.wikipedia.org/wiki/Square_number) "Starting with 1, there are \lfloor \sqrt{m} \rfloor square numbers up to and including m, where the expression \lfloor x \rfloor represents the floor of the number x.
11:24:46 <buff3r> "
11:24:53 <buff3r> but no citation
11:25:00 <buff3r> so far it's just a fact that exists in a vacuum
11:25:09 <buff3r> i'm assuming there's a number theory explanation some place
11:27:21 <benneh> buff3r: take the numbers from 1 to floor(sqrt(m)) and square them, and you get the square numbers between 1 and m
11:27:41 <int-e> the set { n^2 | 1 <= n^2 <= m } is in bijection with { n | 1 <= n <= floor(sqrt(m)) }.
11:28:05 <adarqui> ok cool thanks for the help indiagreen!
11:30:14 <erisco> something wrong is going on here...
11:30:24 <buff3r> thanks benneh int-e 
11:33:04 <erisco> backslashes in quasiquotes... something is wrong
11:33:41 <erisco> [re|\n|]  I am just erroring the string, and I get
11:33:48 <erisco> Code: TH.quoteExp re "\\n"
11:34:05 <erisco> that aint what I typed
11:34:11 <erisco> I guess it doesn't do literals
11:35:05 <catgocat> When installing the haskell ncurses library from cabal I get the error: Missing C libraries: panelw, ncursesw
11:35:10 <catgocat> How to fix?
11:35:29 <absence> install the missing c libraries :D
11:36:27 <catgocat> how??
11:36:43 <absence> catgocat: depends on your platform
11:37:56 <absence> catgocat: it's not really a haskell question, but you tell us which platform you're on someone can probably point you in the right direction
11:38:03 <catgocat> Setup: The program 'c2hs' version >=0.15 is required but it could not be
11:38:03 <catgocat> found.
11:38:10 <catgocat> I don't understand, I have done cabal install c2hs
11:38:31 <rpfun> catgocat: on windows it's probably not in your path
11:38:36 <catgocat> I'm on ubuntu
11:38:45 <Gurkenglas> How should I convert between lists of known size and n-tuples or n-ary functions?
11:39:07 <Cale> catgocat: run  c2hs --version  and see what it says?
11:39:20 <Cale> Gurkenglas: (\[x,y,z] -> (x,y,z)) ?
11:39:22 <rpfun> Gurkenglas: it's not generically possible
11:39:23 <monochrom> erisco: backslashes get no special interpretation in quasiquotes.
11:39:39 <erisco> yeah I'm seeing that... looking at readLitChar atm
11:39:47 <Cale> Gurkenglas: obviously that function will fail with a pattern match error if the list is not the correct size
11:41:02 <Gurkenglas> Time to write a minipackage that names those lambdas?
11:41:07 <Cale> Gurkenglas: why?
11:41:31 <Cale> Gurkenglas: They're dangerous, and should almost never be needed
11:41:53 <monochrom> I'm interested in how you name them. it is not like you can name this one "3to3"
11:42:00 <Gurkenglas> For the same reason one says curry instead of (\f a b -> f (a, b))
11:42:06 <Cale> and the lambda is short and more descriptive than probably most names you could invent
11:42:15 <monochrom> in fact, I suspect that your names are longer than the code.
11:42:26 <Gurkenglas> Planned to use it after Data.Split.chunksOf
11:43:05 <Jookia> is there a way to simplify this: http://sprunge.us/JgDD 
11:43:08 * hackagebot Spock-digestive 0.2.0.0 - Digestive functors support for Spock  https://hackage.haskell.org/package/Spock-digestive-0.2.0.0 (AlexanderThiemann)
11:43:23 <catgocat> I need help, the error remains:  Missing C libraries: panelw, ncursesw
11:43:26 <Cale> Gurkenglas: You may want to use a list comprehension instead if you want to drop any partial chunk on the end
11:43:42 <Lokathor> catgocat, are you sure you also have the cruses-dev as well as curses installed?
11:43:56 <Lokathor> i know debian splits up dev files and the main library, i'm guessing ubuntu does the same
11:43:57 <Gurkenglas> I do not. If there's a partial chunk on the end, someone did something wrong
11:44:49 <Gurkenglas> Deriving a name... a -> [a] is pure so (a, a) -> [a] is pure2 etc. and what prefix stands for the inverse? This doesn't feel to warrant a "co"
11:45:05 <Cale> catgocat: apt-get install libncursesw5-dev ?
11:45:25 <Cale> catgocat: I'm not sure what package panelw is from
11:45:28 <catgocat> Cale: I have done that already
11:46:04 <catgocat> Cale: nevermind that worked!
11:46:09 <Gurkenglas> Ooh, head2 etc. sounds nice.
11:46:11 <catgocat> I had ncurses installed and libcurses
11:46:17 <catgocat> but not that one
11:46:55 <monochrom> erisco: however, backslashes used to get special interpretation in quasiquotes in older GHC (7.0, for example). so if you are examining old code, you may see people relying on it.
11:46:56 <Cale> Gurkenglas: A nice thing about using the explicit lambda is that if it fails to pattern match, you get a source location where the lambda is written
11:47:25 <Cale> Gurkenglas: Whereas if you define the function in a library, you get an error which mentions that library, and not the usage site
11:48:20 <Gurkenglas> Feels like I'm advocating Devil: Not my fault stack traces aren't performant enough to be enabled by default.
11:48:25 <Cale> Gurkenglas: I often use (\(x:_) -> x) or (\[x] -> x) in place of head if I'm not 100% sure that it's safe, for example.
11:48:39 <Cale> Well, the stack wouldn't help you
11:48:48 <Cale> (the stack isn't a call stack)
11:50:05 <Gurkenglas> Good tip, though. What, there's no performance-eating flag that prints a call stack on crash?
11:50:54 <Cale> The closest thing I know of is that you can compile with profiling turned on and then run the program with +RTS -xc which will print the stack of active cost centres on an exception.
11:51:27 <Cale> Still not really the same thing as a call stack, and is often unhelpful, but can sometimes provide some idea about where something bad is happening.
11:54:20 <erisco> gee this is all kind of awful
11:54:31 <erisco> is there a way to get a better error from a ReadP or ReadS parser?
11:54:37 <absence> Cale: it's more useful with -caf-all (and possibly -auto-all, can't remember)
11:54:56 <Cale> erisco: Use Parsec or something instead. ReadP/ReadS are too minimalist to provide more useful error messages.
11:55:14 <erisco> but...
11:55:16 <Cale> absence: yes, you do want lots of actual cost centres :)
11:55:26 <erisco> I specifically wanted lexChar
11:56:09 <sm> Cale: that's a nice tip, thanks
11:56:37 <Cale> I actually kind of wish you could get information about the (real) stack, in the form of which pattern matches are active, it would sometimes be quite useful, especially if the problem is a stack overflow.
11:57:23 <camm_v222> Hi, everyone. Have you ever played Raincat (https://github.com/styx/Raincat)? I'm trying to run it, but I get lot of errors.
11:57:39 <Cale> The cost centre "stack" really has nothing to do with the GHC stack, and is designed to be some approximation of what the call stack would be if you were evaluating the code strictly.
11:57:58 <Cale> camm_v222: I think I remember trying it years ago.
11:58:08 <erisco> I mean, maybe you don't want escape sequences in regular expressions
11:58:14 <erisco> but how else are you doing newlines
11:58:53 <erisco> maybe can do some code point literal or something
11:58:56 <Lokathor> camm_v222, GHC 6.12.1 is a very old version. The libraries that it depends on might have changed since then and such to the point where they can't compile on the older GHC
11:59:08 <Lokathor> er, i mean without the older GHC
12:00:43 <camm_v222> Ohh, I see :( , well thaks guys.
12:00:47 <jmcarthur_> i, too, would like "real" (STG) stack traces
12:01:46 <Cale> camm_v222: I doubt it's hopeless if you're willing to churn through all the compiler messages fixing things as indicated.
12:02:40 <jmcarthur_> camm_v222: i often check for forks in this situation. i see there are 5 forks of this project. maybe one of them is more up to date with ghc and libraries
12:02:58 <jmcarthur_> ah, no
12:03:06 <bitemyapp> failing that, I vendor the library.
12:03:08 <jmcarthur_> looks like this one is newest
12:03:09 * hackagebot ignore 0.1.1.0 - Handle ignore files of different VCSes  https://hackage.haskell.org/package/ignore-0.1.1.0 (AlexanderThiemann)
12:04:24 <BitsPlease> hello
12:05:33 <Cale> camm_v222: there's a build of the game here which might run http://www.gamecreation.org/game/raincat
12:06:30 <erisco> does anyone know... is there an escape sequence in POSIX extended regular expressions for ASCII character numbers?
12:06:47 <erisco> I am hoping for some way to express a bloody newline
12:07:27 <Cale> erisco: Isn't that just \n ?
12:07:35 <erisco> apparently not
12:08:09 <erisco> also particularly Text.Regex.TDFA
12:08:17 <erisco> because I doubt the standard is that standard
12:09:29 <erisco> I'd like to not have to cobble together a parser to do \n and \r and blah blah
12:09:39 <erisco> \t \v \f and so on
12:09:53 <erisco> but I guess I have no option
12:15:26 <Novel_> hi
12:16:38 <Novel_> i hear you're a friendly helpful bunch, so i hope you don't mind if i abuse this and go off topic
12:17:18 <Novel_> I'm looking for a simple web scraper for google images.
12:18:06 <Cale> Novel_: That's a little too far off topic, unless you're talking about one which is written in Haskell. I don't know of any. You might want to use the TagSoup library if you were writing one.
12:19:23 <Novel_> ty
12:23:43 <erisco> 'otherwise' hasn't been syntax all this time?
12:23:45 <erisco> I feel cheated
12:23:56 <erisco> my syntax highlighter as always highlighted it as a keyword
12:24:07 <erisco> so... I didn't need to use this annoyingly long name?
12:24:12 <c_wraith> your syntax highlighter has lied to you.
12:24:21 <Hafydd> Hahahah.
12:24:23 <c_wraith> You could always use "True"
12:24:28 <c_wraith> well, True
12:24:36 <Rembane> But it doesn't look as good as otherwise.
12:24:41 <c_wraith> But..  It's moderately less self-explanatory
12:24:41 <erisco> I am guessing  otherwise = True
12:24:45 <Hafydd> I hate syntax highlighters that highlight names in the standard library as if there's something intrinsic about them.
12:24:46 <c_wraith> > otherwise
12:24:48 <lambdabot>  True
12:25:28 <erisco> you learn things when you selectively import from Prelude...
12:25:35 <Hafydd> Your highlighter also probably highlights "map," which perhaps should have been a clue.
12:25:46 <erisco> Note in scope: 'otherwise'  -- world changing right there
12:26:14 <Hafydd> You learn things also when you read the Haskell language report, which is the recommended way to find that out.
12:26:34 * erisco snores
12:29:20 <Gurkenglas> Why is there M.unions but not M.intersects?
12:35:08 <Cale> Gurkenglas: Probably the treatment of the empty list
12:36:04 <int-e> Gurkenglas: hard to say, it's been there forever (over a decade). I guess the reason is that unions is used for the Monoid instance.
12:36:06 <erisco> at least this is posix so I don't have a bunch of conflicting character classes
12:36:08 <erisco> on escape sequences
12:36:31 <erisco> what are common escape sequences for code points?
12:36:38 <erisco> \cFFFF was thinking this
12:36:56 <erisco> but maybe also a short one... so perhaps  \cFF and \xFFFF  ? dunno
12:38:09 <Cale> > (length "\SOH", length "\SO\&H")
12:38:11 <lambdabot>  (1,2)
12:38:37 <Cale> > tail "\SO\&H"
12:38:38 <erisco> oh wow, it don't like that
12:38:38 <wkmanire> Good morning.
12:38:39 <lambdabot>  "H"
12:38:52 <erisco> > chr (readHex "FFFF")
12:38:53 <lambdabot>      Couldn't match expected type ‘Int’
12:38:53 <lambdabot>                  with actual type ‘[(Integer, String)]’
12:38:53 <lambdabot>      In the first argument of ‘chr’, namely ‘(readHex "FFFF")’
12:38:55 <wkmanire> I'm trying to get a nice Haskell dev environment set up with emacs but I'm having trouble building some of the packages.
12:38:58 <erisco> uh
12:39:08 <wkmanire> Decided to try to do a local build from source, but that isn't working either.
12:39:14 <wkmanire> Cabal hell is real.
12:39:17 <erisco> > chr (let (h,_):_ = readHex "FFFF" in h)
12:39:19 <lambdabot>  '\65535'
12:39:29 <erisco> well, if you try to hPutChar that
12:39:33 <Cale> wkmanire: What are you trying to build?
12:39:36 <erisco> it gets angry
12:39:40 <Cale> wkmanire: and which version of GHC are you using?
12:39:54 <wkmanire> Cale: I'm on Linux Mint 17.2
12:40:12 <wkmanire> The latest version of ghc available in the apt repository is 7.6.3
12:40:22 <Cale> 7.6.3 is very old
12:40:38 <wkmanire> Cale: https://www.refheap.com/de77da579e9cbccdcc3930045
12:40:40 <buff3r> thanks monochrom and int-e , i forgot some basics here
12:40:41 <erisco> why does hPutChar fail? does it not handle anything above 255?
12:40:42 <Cale> I wouldn't recommend using Mint's packages for anything Haskell related
12:40:42 <wkmanire> That's why I'm trying to build from source
12:41:08 <erisco> is that expected or is it system dependent or what?
12:41:21 <Cale> wkmanire: Oh, why build it yourself? Just get the binary package :P
12:41:50 <wkmanire> Cale: The instructions on the Haskell website pointed me at linux mint's apt repository?
12:41:52 <buff3r> since an injective function exists (sqrt, and (^2)) there exists a bijection between the two sets
12:42:01 <buff3r> which implies their cardinality is the same
12:42:12 <wkmanire> Cale: https://www.haskell.org/platform/#linux-mint
12:42:14 <Cale> wkmanire: There's a generic linux binary distribution
12:42:27 <wkmanire> Cale: Oops, didn't see that. Thanks!
12:42:28 <buff3r> (http://people.math.gatech.edu/~ecroot/2406_2012/cantor2.pdf)
12:42:54 <wkmanire> Cale: Does that ship with Cabal as well?
12:42:59 <Cale> It ought to
12:43:07 <wkmanire> Should I purge all of Mint's Cabal, GHC, Haskell-Platform etc?
12:43:11 * hackagebot zmidi-core 0.8.0 - Read and write MIDI files.  https://hackage.haskell.org/package/zmidi-core-0.8.0 (StephenTetley)
12:43:25 <wkmanire> I suppose I should wipe ~/.cabal as well then
12:43:29 <Cale> wkmanire: I doubt it matters, but you can.
12:44:03 <wkmanire> Cale: Thanks for the help. I finally have some time to get serious with Haskell and learn it. I'm really excited about it. :)
12:44:22 <Cale> Yeah, feel free to ask lots of questions about the language here :)
12:44:36 <wkmanire> I'm sure I will.
12:46:17 <rpfun> if i have an (expensive) pure computation (f a), under what (if any) circumnstances will ghc not re-compute the result?
12:50:21 <erisco> rpfun, if you bind it to some variable,  let x = f a in e   then it will not be recomputed in e
12:50:57 <erisco> rpfun, if you just write, say,  f a + f a  it may compute it twice
12:51:52 <kristof> Why did they name the function that lifts a function into a function over functors fmap, but the equivalent for applicatives and monads is liftA and liftM respectively?
12:52:01 <kristof> why not amap and mmap?
12:52:43 <erisco> well, I have a feeling it is fmap because map was already around
12:54:13 <rpfun> erisco: is there a reason the compiler wouldn't optimize away f a + f a?
12:55:08 <erisco> rpfun, well, you're asking it to eliminate common subexpressions, and maybe it doesn't want to do that because it is too expensive generally
12:55:15 <jmcarthur_> rpfun: ghc only applies common subexpression elimination in pretty specific cases
12:55:16 <erisco> maybe it picks it up in some cases but not others
12:56:03 <jmcarthur_> rpfun: https://wiki.haskell.org/GHC/FAQ#Does_GHC_do_common_subexpression_elimination.3F
12:59:33 <rpfun> thanks!
13:01:06 <erisco> so, if you want to put a pipe in a quasi quote... how does one do taht
13:02:14 <erisco> oh wait, that is the regex parser whining...
13:02:18 <erisco> okay, how do you do |]
13:03:12 * hackagebot css-syntax 0.0.3 - This package implments a parser for the CSS syntax  https://hackage.haskell.org/package/css-syntax-0.0.3 (wereHamster)
13:03:14 * hackagebot css-syntax 0.0.4 - This package implments a parser for the CSS syntax  https://hackage.haskell.org/package/css-syntax-0.0.4 (wereHamster)
13:04:04 <Cubanito24> someone can help me hack a chat php?
13:04:22 <Hijiri> off-topic
13:05:49 <erisco> is it not possible? I can't find it in the docs
13:05:58 <erisco> to quasi quote a literal |]
13:06:55 <erisco> ah ha, found it finally
13:07:02 <erisco> answer is no, you cannot
13:07:55 <Cubanito24> hi someone can help me hack a chat php?
13:08:02 * erisco adds more escape sequences
13:10:39 <Hijiri> Cubanito24: no, this chat is for Haskell discussion.
13:11:49 <Sindriava> Short answer? No.
13:11:54 <Sindriava> Long answer? Nooooooooooooooo.
13:13:12 * hackagebot MicrosoftTranslator 0.1.0.1 - Interface for Microsoft Translator  https://hackage.haskell.org/package/MicrosoftTranslator-0.1.0.1 (netogallo)
13:13:40 <medfly> Cubanito24: hello, we have many disgruntled PHP programmers. I am one. but #php is a good place for that discussion.
13:14:12 <medfly> the language sucks, the people don't :P
13:14:41 <erisco> so... if you are quasi quoting and you want a literal |] you write |~]
13:14:51 <erisco> but if you want a literal |~] you write \|~]
13:14:57 <erisco> aren't escape sequences fun oO
13:15:01 <Sindriava> medfly: The language being PHP wasn't the first problem I had with that request.
13:15:18 <medfly> yeah I wasn't sure. hack is what I describe anything I do with PHP.
13:15:20 <medfly> ;)
13:16:10 <Sindriava> Fair enough.
13:16:37 <skore_de> http://hacklang.org/ ;)
13:16:57 <erisco> yeah they beat you to the idea I'm afraid
13:17:09 <erisco> they're owning their identity now
13:18:12 * hackagebot json-litobj 0.1.0.0 - Extends Text.JSON to handle literal JS objects.  https://hackage.haskell.org/package/json-litobj-0.1.0.0 (jonkoc)
13:26:01 <dfeuer> Sindriava++
13:28:13 * hackagebot http-link-header 1.0.1 - A parser and writer for the HTTP Link header as specified in RFC 5988 "Web Linking".  https://hackage.haskell.org/package/http-link-header-1.0.1 (myfreeweb)
13:40:34 <adarqui> is there a way to export all of the functions generated from makeLenses
13:40:53 <adarqui> in a module with explicit exports
13:42:37 <dmj> adarqui: just export them from the module they were generated in
13:42:55 <Lokathor> i think they mean that they were generated in a module with explicit exports
13:43:02 <glguy> adarqui: Not with makeLenses, but if you use makeClassy you get a single class with all of the lenses in it for your type, so it's easy to export ThatClass(..)
13:43:14 <adarqui> aah
13:43:23 <adarqui> cool thanks
13:44:06 <lpaste_> chpatrick revised “Haskell for natural deduction”: “No title” at http://lpaste.net/139506
13:45:08 <lpaste_> chpatrick revised “Haskell for natural deduction”: “No title” at http://lpaste.net/139506
13:56:36 <astupididiot> I'm working my way through LYaH. Can someone explain to me why this example is True? [3,2,1] > [2,10,100]  (I thought 2 would need to be > 10 for that to be true)
13:57:40 <glguy> It's called "lexicographic ordering" It's like how "zebra" > "apple"
13:58:01 <glguy> Since 'z' > 'a', it doesn't matter that 'e' < 'p'
13:58:48 <astupididiot> glguy: Oh, ok. thanks :)
14:00:45 <erisco> what things should a module re-export
14:00:49 <erisco> I don't know how to judge this
14:01:03 * Peaker almost never re-exports anything
14:01:19 <Peaker> I like stuff having a single canonical place to import them from
14:01:40 <tulcod> erisco: re-exporting is a mechanism you use when you want to hide the fact that you split up a module into several internal ones
14:01:40 <Peaker> Is Foo.baz the same as System.baz? Who knows?
14:02:15 <erisco> tulcod, doesn't get used like that always
14:02:20 <tulcod> erisco: no, true
14:02:40 <erisco> but seeing as I can't find a criteria to decide outside that case...
14:02:53 <tulcod> erisco: decide based on use cases
14:02:59 <tulcod> do you have a specific question?
14:03:27 <erisco> not really
14:03:52 <tulcod> erisco: generally speaking, your library should only offer symbols once
14:04:24 <erisco> if a type is used in the signature of an exported function, should that type be re-exported?
14:04:44 <int-index> Peaker, I have a few questions about Lamdu. (1) Is it internal language translated to Haskell? (2) Why do you draw using OpenGL? GTK+Cairo give better font rendering. (3) How can I disable the animations? Stretched text is ugly.
14:04:47 <tulcod> if part of your library happens to quite simply be e.g. fmap, but in a very specific context, you may want to re-export that symbol so that people don't have to import another library explicitly
14:04:56 <int-index> s/it/its/g
14:05:20 <tulcod> erisco: well IMO all types should at least be defined. you may want to hide the constructors, but the types should be clear
14:05:35 <erisco> what do you mean "defined" ?
14:05:38 <tulcod> if you want to hide the constructors, use newtype and don't expose the constructors
14:05:57 <erisco> I didn't write the types, I am talking about re-exporting from other modules
14:05:57 <tulcod> erisco: well you can export a function f : MyType -> Int without exporting MyType at all
14:06:03 <Peaker> int-index: (1) Nope, it's our language only inspired by Haskell.  (2) 60 frames per second are really important for the UX  (3) The animations are extremely important, perhaps something else can be done here?  In any case you can edit the json file and edit the animation time spans
14:06:04 <tulcod> erisco: that'd depend on the use case
14:06:35 <tulcod> if the only reasonable use case is that you would use that type (ie your library doesn't make sense without it), then you should probably re-export it
14:06:40 <Peaker> int-index: Our language has a structural type system (row polymorphism, column polymorphism/polymorphic variants, and nominal types as well)
14:07:04 <tulcod> but if the only reasonable way to deal with that type is the other module, then why should *you* export it: if users want to deal with it, they can do that using the other module
14:11:05 <int-index> Peaker: (1) Very nice choices regarding the type system. Column polymorphism is cool. What about dependent types? (2) If you have animations, I suppose it is. (3) Perhaps use animations that don't stretch text (e.g. gradually change font size)
14:12:25 <Peaker> int-index: (1) We started with DT's, we weren't type experts enough to get it to work well :)  Too much research-y aspects killed us, so we decided to put that part aside.
14:13:17 <Peaker> int-index: (3) Not sure what you mean -- the text size changes use GL scaling and font sizes (font mipmaps + scaling to get the exact size)
14:16:29 <int-index> (1) Temporarily or permanently? (3) I've seen the text stretching its width separately from its height, and this made the letters look... bad. It occurs when maximizing/minimizing the bottom right panel.
14:17:40 <Peaker> int-index: (1) We do hope to someday have DT's, but not in the foreseeable future  (3) Oh, the help text stretching?
14:18:18 <erisco> tulcod, this module is just going to be a quasi-quoter, so, I am guessing I don't need to bother re-exporting anything
14:20:20 <int-index> (3) Yes.
14:21:11 <Peaker> int-index: yeah, the animation engine just shows the new image with the old proportions and then interpolates the size (stretching) to the new proportions, during which it is badly proportioned
14:21:16 <zipper> Hey here are my thoughts on how imports and the export list should look: http://blog.urbanslug.com/posts/2015-08-22-imports-and-exports-as-documentation.html
14:23:10 <erisco> what is the vernacular for saying "the quasi-quote substitutes for"
14:23:17 <int-index> Peaker: great project in any case. I'm glad to see it's actively developed. Thanks for answering my questions :)
14:23:25 <johnw> erisco: splice?
14:23:29 <johnw> erisco: interpolates?
14:23:42 <erisco> like, you might have [math|1+1|] which "substitutes for" 2
14:23:51 <erisco> splices 2?
14:23:58 <johnw> this interpolates 2 into the string
14:24:16 <erisco> what does "the string" refer to?
14:24:21 <Peaker> int-index: thanks! :-)
14:24:26 <johnw> oh, I see
14:24:27 <johnw> hmm
14:24:32 <johnw> then: this is "2" :)
14:24:53 <indiagreen> zipper++
14:25:08 <erisco> I just want to say "supplants"
14:25:14 <erisco> I like that word lately
14:25:33 <erisco> [math|1+1|] supplants 2
14:25:44 <johnw> that doesn't sound right
14:25:45 <zipper> indiagreen: You like, right?
14:25:53 <erisco> right
14:25:58 <erisco> 2 supplants [math|1+1|]
14:26:00 <johnw> the meaning of [math|1 + 1|] *is* 2
14:26:10 <johnw> it's just another way of saying 2
14:26:21 <zipper> I don't know how much posting in /r/haskell is allowed but I'm tempted to share this there.
14:26:27 * erisco sighs
14:26:31 <erisco> I'll try to use "is" in the sentence then
14:26:31 <johnw> so, if I set x = 2 and then use x, I don't say that x supplants 2
14:26:39 <erisco> 2 supplants x
14:26:47 <johnw> that sounds completely wrong to my ears
14:26:47 <erisco> I had it backwards
14:27:07 <johnw> supplants has the meaning of "supercedes", like we don't need x or 2 anymore
14:27:46 <erisco> it is okay, I can use the verb "is"
14:27:59 <johnw> is is what it is
14:29:23 <erisco> yes, that is fine, but, some people like to think about it evaluating to something
14:29:35 <erisco> not it being somehow indistinguishable from what it evaluates to
14:29:48 <erisco> because to the person's eyes it is strikingly different
14:29:50 <johnw> yeah, but that's a major problem for people learning Haskell in the first place
14:29:59 <johnw> thinking in terms of semantic, not "what the computer will do"
14:30:22 <indiagreen> zipper: right. All my import lists look like this, except that I'm more lazy and so the categories are just “General utilities”, “Text”, “Lists”, “Time”, etc, but I don't really know how to make them more descriptive because things change all the time and so I simply forget to update the “this is used for this-and-this” comments
14:30:56 <johnw> usually when people fixate on the operational meaning of things, it just trips them up
14:31:35 <indiagreen> zipper: however, even crude categories turn out to be helpful (and I kinda started to hate non-categorised import lists)
14:34:23 <erisco> if you have a BSD3 license
14:34:23 <zipper> indiagreen: I'm glad that it's not just me who feels this way. :)
14:34:30 <erisco> what significance is having a "copyright" header really
14:34:36 <erisco> I don't understand all these complicated laws
14:42:27 <darenthis> how can I group a list and sum the values like so: [(a, 1), (a, 2), (b, 1)] -> [(a, 3), (b, 1)]?
14:43:16 * hackagebot tasty-hspec 1.1.2 - Hspec support for the Tasty test framework.  https://hackage.haskell.org/package/tasty-hspec-1.1.2 (mitchellwrosen)
14:45:05 <exio4> >  (map (\xs -> (fst (head xs), sum (map snd xs))) . groupBy ((==) `on` fst)) [('a', 1), ('a', 2),  ('b', 1)] -- something like this? now let's get someone to `optimize` it :p
14:45:07 <lambdabot>  [('a',3),('b',1)]
14:45:24 <chpatrick1> beat me to it :p
14:45:26 <chpatrick1> wrote the same thing
14:46:55 <Sindriava> Should I use transformers or mtl?
14:47:05 <johnw> Sindriava: are you an app author, or a library author?
14:47:21 <Sindriava> johnw: What's the difference? (I'm writing an app)
14:47:39 <johnw> app, use transformers; lib, use mtl
14:47:44 <Sindriava> johnw: Why?
14:47:50 <johnw> you gain nothing from the generality as an app author
14:47:57 <johnw> just additional complexity
14:48:07 <glguy> transformers is nicer either way
14:48:12 <Sindriava> Is mtl more general?
14:48:15 <glguy> mtl uses transformers, it just adds the classes on top
14:48:26 <johnw> mtl lets people with tall transformer stacks use your code
14:48:37 <johnw> that way, they just have to satisfy MonadReader, not exactly match your use of ReaderT
14:48:47 <johnw> but as an app author, ReaderT would be the only thing you deal with
14:48:58 <johnw> so MonadReader is saying, "I could work with other transformer stacks, but I never will"
14:49:13 <glguy> Generally you shouldn't be exposing the mtl classes unless you're specifically making things to manipulate mtl classes
14:49:17 <johnw> in general, I usually create an AppT type alias, with a transformer stack behind it
14:50:50 <Sindriava> I see
14:50:54 <Sindriava> Thanks ^^
14:54:55 <dwat3r> hi guys, i'm using Parsec and just found out that the "hexadecimal" token parser accepts only numbers which look like this: "x123123123"
14:55:28 <dwat3r> so no zero at the beginning. my question is, that who was that lame idiot who never seen a hex in his life?
14:55:39 <johnw> um, you can always parse the zero yourself
14:55:46 <dwat3r> but thats nasty
14:55:51 <johnw> no, it allows both forms
14:55:57 <dwat3r> no it isn't
14:55:59 <glguy> dwat3r: Please try to be productive if you're going to chat in channle
14:56:12 <dwat3r> I am, just spotted a bug...
14:56:16 <johnw> not a bug
14:56:44 <dwat3r> hexadecimal     = do{ oneOf "xX"; number 16 hexDigit } <- the definition
14:56:52 <johnw> it lets you either: parse starting from x, or parse a zero and then parse starting from x; if the zero prefix behavior had been built in, it would allow only one flavor
14:57:12 <jmcarthur_> dwat3r: calling the author an idiot is not as likely to get results as a friendly bug report.
14:57:38 <hiptobecubic_> it's also not a bug
14:57:47 <erisco> how do you link to a type in another module with Haddock?
14:57:54 <johnw> try (char "0" *> hexadecimal)
14:58:01 <dwat3r> thanks
14:58:17 <dwat3r> and sorry for being furious.
14:58:23 <hiptobecubic_> > '\xDEAD'
14:58:25 <lambdabot>  '\57005'
14:58:50 <gamegoblin> Is there any plan to get applicative-do into GHC mainline?
14:59:03 <hiptobecubic_> isn't it already an extension?
14:59:32 <gamegoblin> hiptobecubic_: I have seen the proposal to add it, but I didn’t know it had been added
14:59:46 <gamegoblin> hiptobecubic_: https://ghc.haskell.org/trac/ghc/wiki/ApplicativeDo
15:01:26 <erisco> okay figured it out, the error was just a bit misleading
15:01:37 <erisco> I was linking it correctly
15:01:44 <Welkin> there is applicative-do?
15:01:46 <Welkin> wow
15:01:52 <erisco> new question... how do you make ASCII tables in Haddock
15:02:14 <gamegoblin> Welkin: facebook uses it in their internal fork, presumably
15:02:28 <Welkin> gamegoblin: internal fork of ghc?
15:02:39 <darenthis> thanks
15:02:51 <Welkin> by facebook, you mean Marlow and bos?
15:02:58 <gamegoblin> Welkin: yes
15:03:09 <erisco> like, look at these amazing diagrams! http://hackage.haskell.org/package/pipes-4.1.6/docs/Pipes.html
15:03:17 * hackagebot yesod-transloadit 0.4.0.0 - Transloadit support for Yesod  https://hackage.haskell.org/package/yesod-transloadit-0.4.0.0 (boblong)
15:03:22 <erisco> I don't get those for some reason
15:03:33 <erisco> mine are not monospace and line heights are 1.5 or 2
15:06:00 <JoWie> where can i find documentation on "go"?
15:06:39 <Welkin> JoWie: what?
15:06:57 <pavonia> What is go?
15:07:05 <johnw> and why ask here?
15:07:22 <Welkin> you mean the "go" that is often used for internalising recursion in a function definition?
15:07:36 <gamegoblin> I wonder if JoWie is asking about the common practice of using an internal function called "go" that does work in a function
15:07:44 <gamegoblin> Welkin beat me to it
15:08:05 <gamegoblin> JoWie: can you show us an example of what you’re talking about?
15:08:31 <JoWie> sure: https://www.fpcomplete.com/user/edwardk/online-lca
15:08:52 <JoWie> i see it in a lot of haskell code, i thought it was part of the core
15:08:59 <gamegoblin> JoWie: that is just the name of a defined function
15:09:00 <edwardk> JoWie: go is just a local combinator name we like to use
15:09:04 <c_wraith> JoWie: It's just a common name for a locally-defined function
15:09:05 <edwardk> i stole the convention from dons
15:09:10 <JoWie> and they never offer an implementation
15:09:11 <gamegoblin> JoWie: replace it with "f" or "foo" and everything still works
15:09:12 <edwardk> foo = go ... where go = ...
15:09:14 <edwardk> sure they do
15:09:15 <JoWie> ah i see
15:10:08 <JoWie> oh it is defined within the function
15:10:13 <edwardk> yep
15:10:21 <edwardk> 'go' is almost always a little local function like that
15:10:34 <JoWie> yea i was totally confused because it looked like a language thing
15:10:35 <edwardk> i tend to define recursion through it and then lift out whatever strictness properties i can to the outer function
15:10:46 <edwardk> it makes it easier to generate worker-wrapper transforms in the compiler
15:11:04 <johnw> and can help with sharing
15:11:19 <edwardk> it also helps things like inlining, because go may be recursive but the setup isn't
15:11:29 <edwardk> so it can usually inline the setup into the calling function
15:11:38 <johnw> and it states that an argument does not vary with the recursion
15:11:44 <johnw> (it can state)
15:12:00 <edwardk> johnw: that one is a bit trickier to get to pay out
15:12:09 <johnw> it helps a lot more in Coq, and proving termination
15:12:15 <edwardk> you can have a common 'f' or something, but then its constantly rummaging in the environment for it
15:12:21 <edwardk> and ghc kinda sucks at that
15:12:25 <johnw> since you don't get this non-variant argument appearing as a requirement to your induction hypothesis
15:12:25 <edwardk> it means you make a lot of closures
15:12:52 <johnw> really, it doesn't just use the same f via a let?
15:13:11 <edwardk> it does. but operationally how does a let work. all the code below needs to reference that in the closure
15:13:25 <edwardk> for functions? usually worth it
15:13:35 <edwardk> for other arguments? almost always worth it to shove it into the recursive call
15:13:35 <johnw> ah
15:13:45 <edwardk> only really matters right at the limits of what you can optimize
15:17:04 <JoWie> thanks
15:17:31 <OutlawStar> is there an easy way to take a Double -> ByteString?
15:18:11 <johnw> several ways
15:18:15 <johnw> http://hackage.haskell.org/package/binary
15:18:20 <johnw> is probably a safe bet
15:18:32 <johnw> there are other, less safe ways too, depending on the context
15:18:45 <glguy> OutlawStar: I'd help if you explained what you wanted that function to do.
15:19:16 <OutlawStar> I just want to create a blaze builder from a double
15:19:36 <OutlawStar> so i figured easies way was to go Double -> ByteString -> Builder
15:20:58 <OutlawStar> johnw: thx I think what will work
15:25:36 <int-index> How do I call this kind of LensLike? https://github.com/int-index/source-morte/blob/master/src/Control/Lens/Discard.hs
15:26:05 <int-index> Is it somewhere already?
15:31:23 <Big_G> Are there any sites in particular that are good for Haskell jobs?
15:32:27 <Eduard_Munteanu> Big_G, http://www.haskellers.com/
15:32:32 <hiptobecubic_> I got recruited for a non-haskell job from haskellers.com :)
15:33:15 <Big_G> Eduard_Munteanu, Do you mean I make a profile or search there?
15:33:17 <Geraldine> what kind of job is that?
15:33:44 <Eduard_Munteanu> Big_G, both or any
15:34:11 * Eduard_Munteanu doesn't have a profile there, hrm...
15:34:38 <hiptobecubic_> Geraldine, devops at google, of all place. It makes no sense at all unless haskell is the new python :)
15:34:42 <hiptobecubic_> places*
15:37:56 <Geraldine> hope so
15:38:33 <Geraldine> I mean Python is beginning (at least for me) to be overly bloated
15:44:28 <jmcarthur_> there's also http://functionaljobs.com/ for job postings
15:45:44 <Lokathor> Geraldine, "beginning"?
15:48:57 <Geraldine> You mean that is already like that?
15:49:34 <tulcod> Geraldine: a comparison with java is not entirely out of place. except for language design, of course.
15:49:58 <Geraldine> Yeah, You kinda right. At least the syntax is pretty
15:50:34 <c_wraith> After enough time using haskell, going back to python was like "where did all this syntax come from?"
15:51:19 <int-index> c_wraith: after enough time using Haskell, going to Python is like "I WANT STATIC TYPES"
15:52:16 <c_wraith> going back to rails was "why is it impossible to understand anything without looking up everything in the whole program?"
15:52:51 <Geraldine> Yeah, but in Europe finding a job with Haskell is hard
15:53:00 <Geraldine> Rails on the contrary
15:53:00 <Lokathor> python is a lot of things to a lot of people
15:53:14 <Lokathor> but "kinda bloated and slow" is usually near the top of the list
15:53:16 <tulcod> going back to C was like "why is it impossible tProgram received signal SIGSEGV, Segmentation fault.
15:54:23 <Lokathor> python makes it seem easy. It asks you inside for lunch and only asks that you clean a few dishes in exchange for the meal. soon you're doing all the chores and you don't know how it happened
15:55:06 <Geraldine> javascript is much worse in that
15:55:25 <tulcod> Geraldine: if you're looking for haskell job, find a javascript job
15:55:59 <tulcod> also, it is my impression that you can sell haskell very well, once you're inside an organization
15:56:00 <Geraldine> haha
15:56:08 <tulcod> bit by bit, show them the advantages
15:56:10 <Geraldine> that's exactly melting my brain at the moment
15:56:19 <Geraldine> I mean flux and its family
15:56:37 <tulcod> how your code works exactly and efficiently every time, whereas the C code will need a maintenance team
15:56:58 <Walther> Hey, if anyone has any ideas on how to improve my haskell tutorial, I'd be super glad to hear them - walther.guru/one-hour-haskell
15:57:24 <Geraldine> You mentioned js because of its functional "things"?
15:57:37 <chpatrick1> tulcod: the Known monad from earlier is Cont
15:57:37 <chpatrick1> wtf
15:57:50 <tulcod> Walther: should be clear that the Cabal section is actually a shell script (fix the comment style)
15:58:20 <Lokathor> Walther, i'll give this a read
15:58:30 <Walther> tulcod: ha, good point!
15:58:46 <Walther> Lokathor: thanks!
15:59:12 <Walther> it's still work in progress so all suggestions are welcome
15:59:55 <Walther> my aim is to create a "programmin first" -sort of a tutorial, focusing less on haskell for haskell's sake itself and more on how you can do what you need to do in daily code, but in haskell
16:00:01 <tulcod> Walther: well tbh i don't think this tutorial will be very helpful to many people, but i don't see anything strictly speaking wrong
16:00:31 <Walther> tulcod: Okay, what do you think could be done to make it more helpful?
16:00:32 <tulcod> Walther: you should show more intermediate steps towards developing certain concepts if you want it to be accessible
16:00:42 <tulcod> e.g. introduce the notion of types before you start talking about type classes
16:00:43 <Lokathor> Walther, i also... would not introduce haskell in this order
16:00:58 <Walther> tulcod: nod, eill look into the intermediate steps
16:01:13 <Walther> Yeah, order is very random at the moment and needs to be properly thought of
16:01:16 <tulcod> Walther: maybe it would be helpful to have a list of things you're covering in the background
16:01:56 <tulcod> Walther: maybe clarify what the "type" of the lines is - are they expressions, are they declarations, are they shell code?
16:02:13 <Lokathor> 1) you don't talk about type signatures at all. I know it can be complex, but reading haskell stuff becomes like 500x easier once you figure out what a type signature means
16:02:14 <tulcod> e.g., you wouldn't write [1,2,3] as a line in your source files
16:02:32 <tulcod> but you wouldn't write twice x = 2*x in ghci
16:02:49 <Walther> Mmh.
16:02:50 <tulcod> (especially with thrice's type declaration)
16:03:17 <Geraldine> what do You use for dev? (I mean editor)
16:03:21 <Geraldine> Atom anyone?
16:03:46 <tulcod> Geraldine: dunno if you want to hear this, but emacs
16:03:48 <Lokathor> Geraldine, used notepad++ for a while, then switched to emacs with some special overrides to the normal haskell-mode indentation
16:03:50 <Walther> sublime, vim
16:04:24 <tulcod> Walther: the "type" of the lines is especially confusing in the Syntactic Sugar section
16:04:36 <exio4> I used Atom with ghc-mod and stopped using it when its mem usage touched the 3.5gb, now using vim and kate 
16:04:49 <Walther> Thanks for the suggestions, i'll go through the ideas again tomorrow and start acting on them
16:04:51 <tulcod> Walther: the individual lines would normally appear in entirely different parts of your source code
16:04:53 <Geraldine> I think about vim, but unforunately I can get out of it
16:05:49 <tulcod> Walther: if you just want to show off haskell, why not show off parsec-style parsers instead of regexes?
16:06:05 <tulcod> i'd say those are pretty magical
16:06:51 <Walther> tulcod: the core idea was "your most common pieces of code you write in your dat job, but in haskell instead of your language you're familiar with already"
16:07:22 <tulcod> Walther: like this? https://en.wikipedia.org/wiki/List_of_Hello_world_program_examples
16:07:25 <Walther> so one of the suggestions O got from friends was that there should be something on how to use regex
16:08:02 <Walther> Well, a similar concept but not quite hello world -y
16:08:42 <Lokathor> regex is alright, but, i'm not sure the sorts of things where you want to throw a quick regex at the problem are the sorts of things you'd pick up haskell for
16:09:34 <Geraldine> look at the Java in that link
16:09:44 <Geraldine> worse than I thought
16:10:30 <Walther> Lokathor: It might not be the most haskell-y way to do things, yeah, but i'm trying to make haskell more accessible to people who are familiar with some other languages and ways of thinkinh
16:10:57 <Walther> showing that "you can do this in haskell, too, and it isn't necessarily particularly complicated"
16:12:05 <Geraldine> Walther: what are the pros of wrriting backend in Haskell comparing to Node?
16:12:15 <ttt_fff> type safety
16:12:28 <Geraldine> touche
16:12:32 <ttt_fff> also, you hire higher quality enginners, since anyon ewho uses haskell can use node, but not all who use node can haskell
16:12:34 <Walther> Geraldine: That's another question not in the scope of that tutorial :p
16:13:30 <Walther> I have no reasons to preach haskell as the best language or anything like that. I think it is a /fun/ language people should at least try at some point, to widen their perspective
16:13:51 <Welkin> Walther: preaching is never a good thing
16:13:58 <Welkin> everyone likes their own brand of shit
16:13:58 <Geraldine> give me the link to that tutorial, I have a special place in browser for Haskell tutorials (for learning - after getting decent pay)
16:14:17 <Walther> Welkin: yup, and there never is am absolute best thing
16:14:33 <ttt_fff> what a bunch of heresy
16:14:43 <Walther> Geraldine: http://walther.guru/one-hour-haskell - mind you, it is very much work in progress still
16:15:37 <Sindriava> ttt_fff: I use Haskell and I can't use node.
16:15:45 <Geraldine> like I said before "after getting job with decent pay"
16:16:04 <Walther> Geraldine: :)
16:16:12 <Walther> best of luck with that!
16:16:37 <Walther> anyway, off to bed, thanks for the feedback!
16:16:37 <Geraldine> thank U
16:16:45 <Geraldine> sweet dreams
16:18:07 <Welkin> Geraldine: you are waiting until you have a job before you learn haskell? what?
16:20:10 <wkmanire> How do I do a user local installation using the generic linux binary tar ball?
16:20:11 <Lokathor> Geraldine, when you say the java hello world is "worse than you thought", what do you mean?
16:20:33 <Lokathor> the console version is pretty compact
16:21:22 <wkmanire> I want to install the Haskell binary package into $HOME/Local/haskell
16:22:15 <erisco> gah
16:22:23 <Welkin> wkmanire: look at the README
16:22:25 <erisco> why does my haddock keep doubling up line returns
16:22:27 <Welkin> there are flags you can use
16:22:39 <erisco> this is ruining my formatting
16:22:49 <Welkin> erisco: you're ruining my life!
16:22:51 * Welkin slams door
16:22:58 <wkmanire> Welkin: I think you're confusing the generic binary distribution with the source distribution.
16:23:10 <wkmanire> There is no README in the binary distribution.
16:23:18 <wkmanire> Welkin: https://www.haskell.org/platform/#linux-generic
16:23:21 <Welkin> wkmanire: there should be
16:23:40 <ttt_fff> after modifying blah.cabal, how do I tell cabal to install new dependencies without "rm -rf ~/.cabal-sandbox"?
16:24:01 <exio4> cabal install --only-dependencies should install them? 
16:24:17 <wkmanire> derp. I see what it's doing
16:24:33 <wkmanire> I just need to pull the haskell platform directory out of the nested tarball and stick it in home.Probably update LDFLAGS or some such
16:25:19 <ttt_fff> exio4: let me try that
16:26:49 <erisco> okay it seems to be a documented bug
16:26:58 <erisco> and has to do with \r as I suspected
16:27:26 <ttt_fff> exio4: that worked, thanks!
16:27:38 <exio4> ttt_fff: \o/
16:27:45 <ttt_fff> in haskell, how does the words 'applicative' and 'declarative' differ? what do they mean?
16:27:55 <erisco> so, I do  cabal install cabal-install
16:28:01 <erisco> it updates to 1.22.6.0
16:28:08 <erisco> I check  cabal --version  and get  1.18.0.5
16:28:30 <Lokathor> erisco, it's installing to a place that's not lined up with your path
16:28:39 <Lokathor> the older version is the only one in your path, or it's earlier in your path
16:28:41 <erisco> clearly, but where
16:28:50 <erisco> two on the path? hm
16:29:18 <brtmr> export PATH=~/.cabal/bin:$PATH
16:30:12 <Welkin> wkmanire: ./configure --prefix=<my-dir>
16:30:20 <Welkin> before running make
16:30:34 <wkmanire> wkmanire: There's no configure script in the zip?
16:30:34 <brtmr> should do the trick. that way the newly download version (which i assume is in ~/.cabal/bin is earlier in the path)
16:30:39 <wkmanire> tarball*
16:30:41 <wkmanire> Or makefile for that matter.
16:30:47 <Welkin> wkmanire: where did you get this bindist from?
16:30:59 <wkmanire> Welkin: https://haskell.org/platform/download/7.10.2/haskell-platform-7.10.2-a-unknown-linux-deb7.tar.gz
16:31:11 <wkmanire> Welkin: Thanks for following up with me though, I think I have it working now.
16:31:15 <Welkin> wkmanire: https://www.haskell.org/ghc/
16:31:29 <Welkin> you don't need the platform
16:31:37 <Welkin> you can just download ghc and cabal-install
16:31:44 <Welkin> then use cabal to install everything
16:31:48 <Welkin> I think it's cleaner
16:31:56 <wkmanire> Is it worth redoing everything now?
16:32:03 <Welkin> plus you get to use the latest versions
16:32:05 <Welkin> yeah
16:32:11 <Welkin> you can relocate ghc anywhere you like
16:33:00 <wkmanire> Welkin: The reason I'm doing this is because the apt repository packages are several versions behind :/
16:33:06 <Welkin> yeah
16:33:12 <wkmanire> Seems like the haskell community moves pretty quickly because I was getting tons of cabal errors
16:33:13 <Welkin> platform gets behind quickly too
16:33:29 <monochrom> you can use "./configure --prefix=/usr/local/here_here" to specify installation directory
16:33:37 <monochrom> then you play with PATH
16:33:38 <Welkin> wkmanire: I had the misfortune of installing a just-released broken cabal last time
16:33:49 <Welkin> hit my head against the wall for 12 hours
16:33:49 <Welkin> lol
16:33:58 <Welkin> before I was told, "new cabal is fixed"
16:34:09 <wkmanire> he he he
16:34:17 <Welkin> but yes
16:34:18 <wkmanire> Alright, give me a few minutes. I'll rework my installation to use GHC
16:34:25 <Welkin> ghc + cabal-install is much simpler
16:34:25 <erisco> something is adding C:\Program Files\Haskell\bin  to my path and I don't know what
16:34:27 * erisco sighs
16:34:27 <monochrom> this is why I resist "upgrading" cabal-install
16:34:50 <Welkin> if you want to use a newer version of ghc later on, you will have to delete platform (not so easy) and install ghc + cabal-install anyway
16:35:06 <Welkin> or wait for a new platform release
16:35:11 <Welkin> they don't come very often
16:35:15 <Welkin> maybe twice a year?
16:35:17 <monochrom> no, deleting haskell platform is easy now.
16:35:35 <wkmanire> It's just that I'm trying to follow this tutorial https://github.com/serras/emacs-haskell-tutorial/blob/master/tutorial.md
16:35:52 <wkmanire> And several of the cabal packages don't install correctly with the version of GHC that I had before.
16:35:57 <erisco> wait I figured it out
16:36:01 <erisco> the Windows UI is just stupid
16:36:12 <wkmanire> So I figure my best bet is to do a local install with the latest and just keep an eye out for updates.
16:36:19 <monochrom> since two versions ago, haskell platform on linuxes go under "/usr/local/haskell/<ghc-version>". you can just delete that directory.
16:37:36 <erisco> lol
16:37:40 <erisco> unfortunately the bug is still present
16:37:47 <erisco> this is really annoying
16:38:41 <monochrom> I actually recommend tracking haskell platform rather than tracking every bloody ghc version
16:39:25 <monochrom> this is because there was a discussion on "should ghc move fast-and-loose or slow-and-stable?"
16:39:42 <Welkin> I stay one version behind for now
16:39:53 <wkmanire> Welkin: Well this is odd. I installed GHC from the tarball you linked with the prefix set. It didn't install cabal.
16:39:57 <erisco> what... and now it removes backslashes
16:39:59 <erisco> wtf haddock
16:40:01 <wkmanire> I can see the Cabal project in the source tarball
16:40:06 <Welkin> wkmanire: you need to instal cabal yourself
16:40:17 <wkmanire> ahh. How do I do that?
16:40:17 <monochrom> the conclusion was, largely due to SPJ's observation, "fast-and-loose, because haskell platform already does slow-and-stable, there is no point duplicating their point"
16:40:52 <Welkin> wkmanire: https://www.haskell.org/cabal/download.html
16:40:54 <monochrom> so I track haskell platform because I don't need fast-and-loose. I don't need every bloody latest experimental extension.
16:40:59 <erisco> I have no idea what this will look like on Hackage
16:41:01 <erisco> could be anything
16:41:44 <monochrom> tracking every latest cabal-install version has also proved to be unbeneficial
16:41:54 <Welkin> wkmanire: cabal-install, not the cabal library, although you can install that too either from that page or using cabal directly
16:42:14 <erisco> why would haddock be removing backslashes
16:42:18 <wkmanire> Welkin: Got it
16:43:58 <monochrom> erisco: "3.8.2. Special characters" "The following characters have special meanings in documentation comments: \, /, ', `, ", @, <."
16:44:16 <erisco> yeah I see that now
16:44:22 <erisco> but it means if you read the source it is wrong
16:44:49 <monochrom> to tell you the truth, I hate all escape codes.
16:45:08 <johnw> even the escape code that escapes escape codes?
16:45:47 <monochrom> yes. the main reason why I hate escape codes.
16:47:30 <levi> How would you prefer to solve the problem that escape codes deal with?
16:47:38 <levi> (honestly curious)
16:48:13 <dfeuer> Am I correct in thinking that (flip runReaderT e)  is a monad morphism?
16:48:13 <monochrom> rich text or syntax tree
16:48:25 <johnw> dfeuer: you are correct
16:48:33 <dfeuer> Thanks, johnw.
16:48:38 <johnw> (flip runStateT e) is not
16:48:44 <monochrom> both rejected by programmers because programmers look down upon word processor users and graphical interfaces
16:48:50 <dfeuer> johnw, yeah, because the state will get lost...
16:49:04 <dfeuer> johnw, well, state changes, I mean.
16:49:09 <johnw> right
16:49:54 <johnw> the naturality law does not hold
16:50:34 <dfeuer> johnw, I don't know what that means.
16:50:51 <johnw> this law is broken: morph . (f >=> g) = morph . f >=> morph . g
16:51:06 <dfeuer> Yeah, sounds right.
16:51:41 <johnw> since on the LHS, g executes under the state transformed by f; but on the RHS, it starts with the same initial state as f
16:51:54 <dfeuer> *nod*
16:51:58 <johnw> you can see how runReaderT obeys just fine
16:52:25 <dfeuer> Yeah.
16:52:32 <dfeuer> (eventually I did)
16:52:53 <erisco> value incoming!
16:53:22 * hackagebot regex-tdfa-quasiquoter 0.1.0.0 - Quasi-quoter for TDFA (extended POSIX) regular  expressions.  https://hackage.haskell.org/package/regex-tdfa-quasiquoter-0.1.0.0 (erisco)
16:53:34 <erisco> value has arrived
16:53:41 <wkmanire> Carrier has arrived.
16:54:20 <monochrom> no wonder you've been struggling with backslashes :)
16:54:34 <wkmanire> Welkin: Alright, everything is all setup again using your strategy. Let's see if cabal will actually be able to install all of the packages I need. "cabal install happy hasktags stylish-haskell present ghc-mod hlint hoogle structured-haskell-mode hindent"
16:54:50 <erisco> when the docs generate see the fun with \|~] and |~] and |]
16:54:52 <koshmar> Guys, I am not quite understand why las instance is iligal http://paste.ofcode.org/wiDfBjR5S68wj4cKnZFpCC  could you caomment on that?
16:55:43 <Welkin> koshmar: you need FlexibleInstances
16:55:52 <Welkin> because String is a type synonym for [Char]
16:55:56 <monochrom> koshmar: String means [Char]. you are writing "instance Lol [Char]". this is illegal in Haskell 2010.
16:56:12 <erisco> you could be arrested
16:56:42 <koshmar> Int is a type and [Char] is a type, is not it right?
16:56:50 <monochrom> that is beside the point.
16:57:10 <monochrom> Haskell 2010 has conservative rules of what can be instances.
16:57:31 <koshmar> is there a general rule?
16:57:51 <koshmar> some logical rule perhaps?
16:57:57 <monochrom> the explanation of FlexibleInstances contains a summary of what Haskell 2010 bans that FlexibleInstances relaxes
16:58:50 <glguy> koshmar: GHC gives you the general rule when it reported the illegal instance
16:59:01 <monochrom> yes, that too.
16:59:28 <glguy> this: (All instance types must be of the form (T t1 ... tn) where T is not a synonym
16:59:31 <geekosaur> basically, it wants things that look like a type constructor and (if needed) type variables (not concrete types). [Char] is ([] Char) and Char is not a type variable.
16:59:48 <wkmanire> Welkin: cabal only uses one core to do dependency resolution?
16:59:53 <wkmanire> Can I configure that?
16:59:59 <geekosaur> and yes, it doesn't like synonyms, because that hides the actual form of it
17:00:05 <geekosaur> as monochrom said, it's very conservative
17:00:51 <Welkin> wkmanire: cabal install -j
17:00:56 <brtmr> the reason being that if you use concrete type, you could always create a more generic instance like [a], and then create decision problems for the compiler
17:00:56 <Welkin> wkmanire: to use all available cores
17:01:08 <wkmanire> Awesome, thanks.
17:01:21 <Welkin> although I thoguht that cabal defaulted to that anyway
17:01:34 <dfeuer> What would it mean to run a MachineT (or a Pipe, or whatever) in a continuation monad?
17:01:37 <wkmanire> It's still only using 1 core for dep resolution.
17:01:48 <chpatrick1> wtf :: Cont r (Either a (a ->r)
17:01:57 <chpatrick1> you can get that without cheating
17:02:01 <chpatrick1> my brain exploded
17:02:18 <Intolerable> where's the paren gone
17:02:21 <chpatrick1> typo
17:02:24 <wkmanire> Welkin: http://i.imgur.com/ASy82rX.png
17:02:39 <Intolerable> so "dont need balanced parens any more" isn't the thing? :P
17:02:48 <chpatrick1> no, that there's such a value
17:03:05 <wkmanire> Welkins: cabal install -j happy hasktags stylish-haskell present ghc-mod hlint hoogle structured-haskell-mode hindent --max-backjumps=300000
17:03:12 <chpatrick1> `cont` is the same as double not elimination
17:03:16 <wkmanire> Is the command I ran. I think I'm going to have to try to install these individually.
17:03:41 <Welkin> wkmanire: what's wrong?
17:04:02 <wkmanire> It's just taking forever to resolve the dependencies. I was trying to speed that up
17:04:06 <wkmanire> But it looks like it only happens in a single thread.
17:04:21 <dfeuer> ContT tends to confuse me.
17:04:25 <Welkin> I'm not sure you can do anything about that
17:04:28 <dfeuer> As do most things to do with continuations.
17:04:37 <Welkin> wkmanire: in general, haskell packages take a while to build
17:04:53 <wkmanire> It's not building anything just yet. No problem. I'll just be patient :)
17:05:02 <brtmr> wkmanire: yes, i think the -j flag only comes into play when building.
17:05:17 <Welkin> wkmanire: a fresh install of yesod, for example, (which has a ton of dependencies) can take 45 minutes for me
17:05:34 <wkmanire> Holy moley.
17:05:39 <Welkin> so I wouldn't worry about the time it takes to determine dependencies
17:06:10 <koshmar> Is it a bad practise to use FlexibleInstances?
17:06:14 <Welkin> also, max-backjumps=300000 is a lot
17:06:25 <dfeuer> chpatrick, that says something about what the type means (sort of, but not exactly, because of a missing forall) but not what happens in practice.
17:06:46 <lpaste_> chpatrick pasted “Intuitionistic logic with Cont (mind = blown)” at http://lpaste.net/139533
17:06:59 <dfeuer> koshmar, Edward Kmett seems to think it's generally better to avoid it if possible; sometimes it's not possible. It's not nearly as bad as OverlappingInstances or IncoherentInstances.
17:07:16 <chpatrick1> dfeuer, what do you mean?
17:08:01 <wkmanire> Welkin: It kept on failing without me specifying that
17:08:35 <tulcod> chpatrick1: dunno if you're interested in academia, but you would love the current type theory research
17:09:15 <chpatrick1> tulcod, homotopy stuff?
17:09:23 <tulcod> chpatrick1: for example, yeah
17:09:52 <chpatrick1> it's just weird how these deep connections turn up everywhere
17:09:52 <Welkin> wkmanire: also, have you learned about cabal sandboxes yet?
17:10:11 <wkmanire> Welkin: Nope. I'm a haskell newbie
17:10:15 <tulcod> chpatrick1: s/weird/beautiful/
17:10:19 <Welkin> wkmanire: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
17:10:29 <Welkin> you will want to use a sandbox for each new project
17:10:35 <Welkin> to avoid dependency hell
17:10:43 <wkmanire> ah cool. Like virtualenv for Python
17:10:51 <Welkin> yeah
17:11:53 <Welkin> also, to ensure your build stays consistent every time you want to rebuild it on another machine, or pull a fresh copy from a remote repo or something, use `cabal freeze` to generate a cabal.config to exact package versions
17:12:06 <wkmanire> pip freeze
17:12:07 <wkmanire> right.
17:12:08 <Welkin> with exact*
17:13:18 <Welkin> Stackage is just a cabal.config file: https://www.stackage.org/
17:16:40 <brtmr> huh. i didn't know about cabal freeze. I was just about to do this manually for a project. nice.
17:18:03 <wkmanire> Looks like this is going to be a mile long swim in the deep end for me. Normally I come into a language I don't know and it's familiar enough.. learning the tools is not so difficult. In this case, the language is completely alien to me. 
17:18:15 <wkmanire> I just want to get to a point where my dev environment is solid and I can start hacking on stuff.
17:19:32 <Lokathor> wkmanire, cabal and cabal sandboxes can get things working for you
17:19:46 <Lokathor> "cabal repl" runs ghci using your local cabal config so you can load packages
17:20:00 <Lokathor> after that it's a lot of learning to think new ways
17:20:34 <dfeuer> chpatrick, I don't remember the details.
17:20:40 <wkmanire> Is it possible to get a nice immediate feedback loop thing going in emacs like you can with clojure (or most lisps for that matter)?
17:21:49 <Welkin> wkmanire: ghc-mod
17:22:10 <dfeuer> wkmanire, flycheck comes into it somehow too, I think.
17:22:21 <Welkin> I don't use anything fancy though
17:22:21 <monochrom> yes IMO. https://github.com/haskell/haskell-mode . scroll down to the README.md, use the melpa-stable one.
17:22:24 <Welkin> just haskell-mode
17:22:48 <monochrom> "IMO" because, clearly, YMMV.
17:22:51 <wkmanire> Awesome.
17:23:32 <Lokathor> wkmanire, you can also split the window and open a shell and run ghci within that shell of course, similar to using slime
17:23:39 <dfeuer> Time for me to try to work or something.
17:23:42 <monochrom> also, I have no idea what "like you can with clojure (or most lisps for that matter)" means, because I don't care about them.
17:23:56 <wkmanire> Lokathor: Can you send functions and regions too?
17:24:16 <Lokathor> ahhh, not that i know of
17:24:29 <Lokathor> you can save the file, switch buffers, and then load the file in ghci
17:24:39 <wkmanire> monochrom: Well then.
17:24:43 <Lokathor> but nothing fancy like doing it as a single keypress like with slime
17:24:51 <Lokathor> at least, not that i know of
17:24:59 <wkmanire> Ah ok. No big deal.
17:25:12 <Lokathor> :l or :load <modulename>
17:25:22 <Lokathor> :r or :reload to refresh stuff
17:25:40 <Lokathor> :t <expression> to see the type signature of an expression
17:25:41 <Welkin> :t or :type to see the type of something
17:25:41 <lambdabot> parse error on input ‘<’
17:25:42 <lambdabot> parse error on input ‘type’
17:25:46 <Welkin> the most important one :)
17:25:52 <Lokathor> those are the major ghci commands
17:25:59 * Welkin pats lambdabot 
17:26:05 <Lokathor> it tries so hard
17:26:54 <Welkin> wkmanire: you may also want to set the ghci prompt using :set prompt "your-new-prompt"
17:27:21 <wkmanire> Welkin: I've worked from a few different tutorials inside of ghci.
17:27:25 <Welkin> you can have a .ghci file inside your ~/ghc directory
17:27:28 <OutlawStar> so i have something really weird going on. I have the following "modifyIORef' ref (\old -> old + alpha)" and alpha is defined in a where as "alpha = 2/(200+1)". Old of type "Double". When i get to that calculation, the entire program stops
17:27:30 <wkmanire> So some of these things I already know, not that I don't appreciate the help :)
17:27:31 <OutlawStar> any ideas?
17:27:33 <Welkin> it loads when you use ghci or cabal repl
17:28:01 <monochrom> but I am unconvinced that you can start "hacking" (I read that as "developing") any time soon, even if someone has already magically set up the ideal IDE for you. this is precisely because haskell is an alien language.
17:28:03 <wkmanire> I'm just finally getting serious about it, so that's why I've been spending the afternoon trying to get a good dev env set up.
17:28:21 <monochrom> P.S. the ideal IDE already exists. it's FP Complete.
17:28:31 <OutlawStar> actually the type is of "Scientific"
17:28:47 <monochrom> https://www.fpcomplete.com/business/haskell-center/overview/
17:29:33 <wkmanire> monochrom: Writing software inside of a web browser? yuck.
17:29:39 <Welkin> OutlawStar: you'll need to paste the code and error
17:29:39 <monochrom> https://ro-che.info/ccc/26
17:29:45 <Welkin> @lpaste
17:29:46 <lambdabot> Haskell pastebin: http://lpaste.net/
17:29:51 <OutlawStar> k give me sec
17:30:26 <Lokathor> monochrom, fpcomplete is far from ideal
17:31:16 <wkmanire> monochrom: To be honest, I'm not much of a fan of IDEs to begin with. Haven't used one seriously in yaers.
17:31:18 <wkmanire> years*
17:31:25 <Welkin> emacs :)
17:31:34 <Welkin> no mouse
17:31:46 <wkmanire> Yup.
17:31:52 <Lokathor> 1) when i hover my mouse over a symbol, i don't get a popup that tells me its type and source of definition and any possible doc comment.
17:31:53 <OutlawStar> welkin: http://lpaste.net/4972634099320619008
17:32:04 <OutlawStar> once i hid that modifyIO statement, things just pause
17:32:04 <Lokathor> any ideal IDE could clearly do such a thing
17:32:24 <Lokathor> 2) i don't think i could develop graphical programs with fpcomplete, could i?
17:32:26 <OutlawStar> i would think alpha would act as constant. When i hard code the value stuff works
17:33:05 <Welkin> OutlawStar: where is the error?
17:33:16 <OutlawStar> there is no compile error, but line 6
17:33:18 <OutlawStar> is the problem
17:33:39 <erisco> pretty sure with fp complete you're tied to their cloud service thingie
17:34:54 <Lokathor> also i cloned one of their example projects
17:35:00 <Lokathor> and the build instantly failed
17:35:26 <wkmanire> Welkin: https://www.refheap.com/c581a592a1ef2059b7546104e
17:35:30 <wkmanire> I was able to install everything except for present
17:35:38 <wkmanire> So definitely, things are way better this time around than before. Thank you!
17:35:43 <Welkin> wkmanire: I recommend the upenn haskell course to start
17:35:45 <wkmanire> And everyone else that offered advice.
17:35:48 <Welkin> @where learnhaskell
17:35:48 <lambdabot> https://github.com/bitemyapp/learnhaskell
17:36:50 <wkmanire> Cool. I'll hang out in #haskell-beginners and work from that doc you linked Welkin
17:43:02 <wkmanire> Welkin: http://i.imgur.com/2IN9Hvp.png  http://i.imgur.com/DNPeDiq.png Ta dah!
17:43:10 <wkmanire> Everything is working just fine.
17:48:24 * hackagebot courier 0.1.1.1 - A message-passing library for simplifying network applications  https://hackage.haskell.org/package/courier-0.1.1.1 (PhilHargett)
18:03:25 * hackagebot libmpd 0.9.0.3 - An MPD client library.  https://hackage.haskell.org/package/libmpd-0.9.0.3 (JoachimFasting)
18:15:27 <ttt_fff> is there any webframework that uses both ghc + ghcjs? I really like the way where in haste, you can write the entire wbapp (server + client) part as a single app, where there is a Server monad and a Client monad
18:18:25 * hackagebot leksah 0.15.1.4 - Haskell IDE written in Haskell  https://hackage.haskell.org/package/leksah-0.15.1.4 (HamishMackenzie)
18:27:25 <cj3kim> wkmanire: which terminal are you using?
18:41:10 <Welkin> why would you ever use StateT and State together?
18:50:23 <jle`> in the scalable situation you wouldn't probably use State
18:50:38 <jle`> you'd probably always use Monad m => StateT s m a in place of State s a
18:50:42 <kristof> When you want to keep track of two different States in a big ol' Monad.
18:51:22 <jle`> so if your program is in `StateT s IO a`, but you want to write a subroutine that only manipulates the state and doesn't use IO (and want to statically guaruntee that it doesn't use IO), you can write that subroutine in Monad m => StateT s m a
18:51:23 <kristof> oh, that could just be one big state. I dunno, then.
18:51:50 <jle`> that way you can mix state-involving-IO with state-not-involving-IO in the same computation, and be able to statically demonstrate that latter doesn't involve IO
18:52:04 <jle`> whereas if you wrote your state-not-involving-IO in StateT s IO a, you wouldn't be able to guaruntee for sure from the type alone
18:54:37 <Welkin> jle`: good explanation
18:55:27 <jle`> so if you know you might eventually use StateT one day or are using it at the moment, there probably really isn't any good reason to use State
18:55:31 <tomberek_> bimapM :: Monad m => (t -> m a) -> (s -> m b) -> (t,s) -> m (a,b)
18:55:48 <jle`> considering `runState` and `execState` etc. all run on Monad m => StateT s m a
18:56:01 <Welkin> jle`: I'm just filling my knowledge gaps in haskell, and tonight is monad transformers
18:56:10 <tomberek_> does this exist anywhere? seems to be perhaps Applicative?
18:57:55 <Welkin> tomberek_: like a monadic version of (***)?
18:58:17 <tomberek_> yeah
18:58:24 <tomberek_> exactly
18:58:58 <jle`> looks like (***) for the Kleisli newtype wrapper
18:59:06 <jle`> but there's also
18:59:07 <tempname11> http://hackage.haskell.org/package/bifunctors-5/docs/Data-Bitraversable.html#v:bimapM ?
18:59:14 <jle`> :t uncurry (liftA2 (,))
18:59:15 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
18:59:35 <tomberek_> Welkin: i'm working with effectful arrows...  arrM f *** arrM g ===>>    arrM ( bimapM f g) would be an optimization
19:00:25 <jle`> it looks like exactly what tempname11 posted, with the same name too, heh
19:00:45 <tomberek_> :t (uncurry (liftA2 (,)) . bimap
19:00:51 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
19:01:38 <jle`> :t \f g -> uncurry (liftA2 (,)) . bimap f g
19:01:40 <lambdabot> Applicative f => (a1 -> f a) -> (c -> f b) -> (a1, c) -> f (a, b)
19:01:41 <tomberek_> bitraverse is good too
19:02:13 <jle`> not a savory usage of uncurry
19:02:13 <tomberek_> in fact, bitraverse is probably what I want to use the optimal Applicative instance
19:08:02 <tomberek_> jle`: actually https://hackage.haskell.org/package/monad-parallel-0.7.1.4/docs/Control-Monad-Parallel.html#v:bindM2 seems to be very applicable to what I want, and it already has instances defined
19:37:09 <lpaste_> tt pasted “I want those message” at http://lpaste.net/7155026648797020160
19:46:19 <ttt_fff> jle`: are you responsbiel for http://mstksg.github.io/ghcjs-websockets/JavaScript-WebSockets.html ?
19:48:29 * hackagebot dead-code-detection 0.1.1 - detect dead code in haskell projects  https://hackage.haskell.org/package/dead-code-detection-0.1.1 (SoenkeHahn)
20:05:54 <hunteriam> hey guys
20:06:11 <hunteriam> i need something to link to someone to show them how cool category theory and the mathy side of comp sci is
20:06:15 <hunteriam> but theyve never programmed
20:06:19 <hunteriam> anyone know anything like that?
20:06:36 <scshunt> curry howard isomorphism, perhaps?
20:06:38 <Hafydd> To what end?
20:06:43 <scshunt> do they have a math background?
20:06:55 <hunteriam> Hafydd so they can see if it interests them
20:07:02 <hunteriam> scshunt dont think so
20:08:33 <Hafydd> Curious.
20:08:39 <Cale> hunteriam: I don't know if that's really possible to convey without at least a little bit of mathematics background.
20:08:59 <hunteriam> how do i pitch category theory to someone
20:09:01 <Hafydd> What kind of person who hasn't programmed and doesn't have a mathematical background would cause you to want to know that?
20:09:03 <hunteriam> and how powerful it is
20:09:08 <hunteriam> theyre a highschooler
20:09:15 <hunteriam> trying to see if they want to try this stuff
20:09:19 <Cale> hunteriam: I think the more important question is "why do I pitch category theory to someone?"
20:09:28 <hunteriam> why not?
20:10:44 <Cale> Well, it's a tough starting point. It's a game which is played where all the branches of mathematics are your primary examples, and so if you don't have much of a mathematics background, it's hard to convey that it's useful at all, because you have no examples to draw on.
20:12:20 <rpfun> is there a typeclass like applicative but only with ap and not pure? or something like a "zippable" typeclass?
20:12:49 <dramforever> :k Apply -- dunno where it is
20:12:50 <lambdabot> Not in scope: type constructor or class ‘Apply’
20:12:54 <dramforever> oh bad
20:15:24 <geekosaur> semigroupoids, apparently
20:16:07 <geekosaur> http://hackage.haskell.org/package/semigroupoids/docs/Data-Functor-Apply.html#t:Apply "A strong lax semi-monoidal endofunctor. This is equivalent to an Applicative without pure."
20:16:54 <rpfun> ha not even surprised that an edward kmett package solves this problem
20:17:56 <Cale> hunteriam: Maybe a good place to start would be to teach some group theory. Groups are used to understand mathematical objects through the symmetries they have with themselves. Categories generalise this by studying composable relationships of some sort between many objects.
20:18:04 <Hafydd> I don't know why strong lax semi-monoidal endofunctors aren't in the Prelude.
20:18:20 <rpfun> geekosaur, dramforever: thanks very much!
20:18:36 <dramforever> you're welcome =P
20:27:29 <tomberek_> how expensive is `par`? Is it fairly cheap?
20:28:31 * hackagebot hspec-smallcheck 0.4.1 - SmallCheck support for the Hspec testing framework  https://hackage.haskell.org/package/hspec-smallcheck-0.4.1 (qoelet)
20:29:30 <Cale> tomberek_: Individually, but you do usually want to try to make sure that the sparks you create have some reasonable amount of work to do.
20:30:10 <Cale> tomberek_: If you spark every little thing, the cost of synchronisation can outweigh the cost of computing the sparks.
20:31:32 <tomberek_> Cale: context: when would it not be a good idea to use the instances and functions in Control.Monad.Parallel to combine two actions, ala. Klieisi1 *** Klieisi2 ?
20:31:49 <Cale> what?
20:32:21 <tomberek_> (it uses par for many of the instances)
20:32:52 <Cale> I mean, it depends on whether you want to do evaluation in parallel?
20:33:12 <Cale> I don't really understand what "Klieisi1 *** Klieisi2" was supposed to refer to
20:33:21 <Cale> Are those arrow computations? Which instance?
20:34:01 <tomberek_> that's kind of the problem, without knowing more, it's impossible to tell if it makes sense to do them in parallel
20:34:30 <Cale> Wait, Control.Monad.Parallel?
20:34:34 <tomberek_> ya
20:34:37 <Cale> Not Control.Parallel.Strategies?
20:35:19 <Cale> ah, hmm
20:35:46 <Cale> This class is probably a bad idea, the instances seem to all have different semantics...
20:36:33 <Cale> I dunno
20:36:59 <Cale> Well, at least, IO is very different in flavour from the others
20:37:09 <Cale> It's not just parallelisation there, but concurrency.
20:38:20 <tomberek_> my thought was to use bindM2 whenever I come across that *** expression.  Hence my question about the cost of synchronization. ie. how big of a computation would benefit? 10 clock cycles, 100? 1000?
20:38:48 <tomberek_> assuming a simple combining function like (,)
20:41:25 <kristof> :t ($)
20:41:26 <lambdabot> (a -> b) -> a -> b
20:57:15 <jle`> hm, according to algebra and stuff, Bool -> Either a b is equivalent to Either (Bool -> a) (Either (Bool -> b) (Bool, a b))
20:57:22 <jle`> that wasn't too obvious
20:57:43 <jle`> * (Boo, a, b) as the last one
20:58:55 <jle`> @djinn (Bool -> Either a b) -> Either (Bool -> a) (Either (Bool -> b) (Bool, a, b))
20:58:55 <lambdabot> f a =
20:58:55 <lambdabot>     case a False of
20:58:55 <lambdabot>     Left b -> case a True of
20:58:55 <lambdabot>               Left c -> Left (\ _ -> c)
20:58:55 <lambdabot>               Right d -> Right (Right (False, b, d))
20:58:57 <lambdabot>     Right e -> case a True of
20:58:59 <lambdabot>                Left f -> Right (Right (False, f, e))
20:59:01 <lambdabot>                Right g -> Right (Left (\ h ->
20:59:03 <lambdabot>                                        case h of
20:59:05 <lambdabot>                                        False -> g
20:59:07 <lambdabot>                                        True -> e))
21:00:34 <shachaf> I think it's pretty straightforward.
21:00:56 <shachaf> (Either a b, Either a b) -- either you have two as, or two bs, or one a and one b, in two possible orders.
21:02:38 <jle`> ah, in that form it's a lot more clear ><
21:02:47 <nitrix> Type permutations! Comming in a GHC near you...
21:03:46 <johnw> a^2 + 2ab + b^2
21:03:55 <jle`> now to imagine the corresponding propositional logic statement
21:06:08 <jle`> hm, the djinn result actually doesn't give the isomorphism
21:06:53 <shachaf> No, it just spams the channel, really.
21:07:12 <shachaf> lambdabot ought to have output length limits. Say, a one line limit in this channel.
21:07:59 <tomberek_> what is the largest number of lines djinn will produce for the shortest statement?
21:08:58 <tomberek_> seems like a Busy Beaver sort of question
21:13:50 <ttt_fff> a `b` c `d` e; now, let `b` and `d` have same precedence, let `b` be left-assoc, and `d` be right assoc. What happens?
21:14:03 <ttt_fff> more genrally, how does haskell resolve operator precedence ?
21:14:54 <jle`> ttt_fff: i know a way to find out :)
21:15:05 <jle`> (spoilers: the compiler won't take it)
21:15:18 <jle`> there's a pretty concise statement about what happens in the report, i believe
21:15:22 <ttt_fff> is there a part of the ghc manual or haskell standard whith documents this?
21:15:37 <ttt_fff> https://www.haskell.org/onlinereport/haskell2010/
21:15:50 <ttt_fff> https://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-180002.4 ?
21:16:29 <ttt_fff> "Consecutive unparenthesized operators with the same precedence must both be either left or right associative to avoid a syntax error"
21:16:32 <ttt_fff> page 16 of Consecutive unparenthesized operators with the same precedence must both be either left or right associative to avoid a syntax error
21:16:33 <johnw> shachaf: I think that's a good limit
21:16:39 <ttt_fff> page 16 of https://www.haskell.org/definition/haskell2010.pdf
21:18:22 <ttt_fff> I think, for the first time in my haskell career, I am now smart enough to understand all of the ahskell report
21:24:34 <kristof> > (*) <$> Just 2 <*> Just 0 *> Just 2
21:25:00 <kristof> Did lambdabot break?
21:25:04 <athan> is `map` lazy?
21:25:12 <kristof> athan: Yes.
21:25:18 <athan> thanks kristof :)
21:25:53 <athan> > (*) <$> Just 2 <*> Just 0
21:26:00 <lambdabot>  mueval: ExitFailure 1
21:26:03 <athan> :o
21:26:09 <athan> :t 1
21:26:10 <lambdabot> Num a => a
21:26:38 <athan> > undefined
21:26:42 <lambdabot>  mueval-core: Time limit exceeded
21:26:46 <athan> !_!
21:27:17 <athan> int-e: Hey, I think lambdabot is borky ^
21:27:19 <tomberek_> uh-oh, did someone actually take my suggestion and give it a go?
21:27:53 <kristof> I'm not really sure what Real World Haskell means when it says that <*> returns both the arguments to its left and right.
21:28:25 <athan> tomberek_: Well, I think the djinn gives results by it's input type linearly
21:28:32 <tomberek_> btw: I'll only accept finite responses to the busy-lambdabot challenge
21:28:44 <kristof> I just see it as, you know, sequential composition of applicative effects
21:28:48 <athan> or really, prenex-polymorphic lambda terms grow linearly with their type signatures
21:28:59 <tomberek_> athan: hm... perhaps with pointfree......
21:29:06 <tomberek_> those can get out of hand
21:29:32 <athan> kristof: So, functors give you 1-ary mapping
21:29:34 <athan> :t <$>
21:29:45 <athan> kristof: Applicatives give you n-ary mapping
21:29:49 <athan> :t (<$>)
21:29:53 <athan> D:
21:30:04 <athan> or really, 0-infinity mapping
21:30:08 <tomberek_> @pl f a b c d e g h i = h (b i a) g i a d c (b i a) (h e e) e
21:30:11 <lambdabot> f = flip flip id . ((flip . (flip .)) .) . (((ap .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip flip (join (flip . flip id)) . (flip .) . ((flip .) .) . ((((.) .) .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . ap (ap . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((
21:30:11 <lambdabot> flip .) .) .) .) . (((((ap .) .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((ap .) .) .) . (flip .) . ((flip .) .) . (flip (.) .) . flip flip)) (flip flip)
21:30:11 <lambdabot> optimization suspended, use @pl-resume to continue.
21:30:23 <tomberek_> yeah....
21:30:32 <kristof> Someone sue alonzo church.
21:30:35 <athan> because <*> is kindof like the tape you need to add on more parameters
21:30:44 <athan> tomberek_: This isn't djinn >.>
21:30:46 <ttt_fff> @pl-resume
21:30:52 <lambdabot> f = flip flip id . ((flip . ((flip . ((ap . ((flip . (flip .)) .)) .) . ((((flip .) .) .) .)) .)) .) . flip flip (join (flip . flip id)) . (flip .) . ((flip .) .) . ((((.) .) .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . ap (ap . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((ap .) .) .) .) .)
21:30:52 <lambdabot>  . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((ap .) .) .) . (flip .) . ((flip .) .) . (flip (.) .) . flip flip)) (flip flip)
21:30:52 <lambdabot> optimization suspended, use @pl-resume to continue.
21:31:10 <SrPx> Is there any fast way to sum all numbers in a range in Haskell? I.e., sum all positions inside the square [0,0] → [4,4] ? The naive solution, I guess, `sum $ do { x <- [0..4]; y <- [0..4]; return (x+y) }` is like 150 times slower than 2 for loops in C
21:31:20 <kristof> athan: That's the way I used to look at it, but I'm working through Real World Haskell and now Brian Sullivan is revealing to me that I can often use applicatives where I would have previously resorted to monads.
21:31:45 <ttt_fff> SrPx: you can return (n*(n+1)/2)^2
21:31:45 <johnw> SrPx: you're building that with -O2?
21:31:57 <SrPx> yes
21:31:58 <jmcarthur_> SrPx: surely there is just a closed form solution. no need for loops
21:32:09 <athan> kristof: That's common :) me too
21:32:17 <athan> because Functor => Applicative => Monad
21:32:25 <ttt_fff> oh wait, it's n * n * (n+1)/2
21:32:43 <SrPx> I don't actually want the sum but to do an action for each position so I'm figuring out the fastest way to simulate two for loops
21:32:57 <SrPx> It is for some 2d drawing stuff
21:33:07 <athan> two folds?
21:33:19 <SrPx> isn't that what this is doing? let me see
21:33:26 <athan> probably :\
21:33:36 <jmcarthur_> heh, i wrote something similar (a fast blitter) just yesterday
21:33:47 <SrPx> link?
21:34:04 <jmcarthur_> i ended up doing fancy things for speed
21:34:28 <SrPx> of course I asked this just because you wrote that yesterday... there is a name for this effect isn't it? 
21:34:33 <jmcarthur_> it's not available online right now, but i could paste it somewhere if you want. it's probably not quite what you are looking for though
21:34:36 <tomberek_> SrPx: sequence [ myAction a b | a <- as, b <- bs]
21:35:04 <johnw> or just sequence $ liftA2 myAction a b
21:35:33 <jmcarthur_> actually, i'm sure you don't want what i wrote. it's highly specialized.
21:36:04 <SrPx> no problems
21:36:28 <crodjer> With haskell-mode, is it possible to run multiple targets? Say, one for spec and one the default?
21:36:56 <SrPx> Something is not right
21:37:10 <tomberek_> johnw: i'm not sure what list comprehensions use in the background, looks like they use the Monad instance
21:39:44 <jmcarthur_> SrPx: i'm assuming there is some IO you're doing in the inner loop. does this go too slow for you?    forM_ [0..4] $ \x -> forM_ [0..4] $ \y -> f x y
21:40:10 <SrPx> I tested that too... same perf exactly
21:40:43 <SrPx> Maybe GCC is doing some kind of optimization that wouldn't happen in actual programs and that is why it is so fast in comparison
21:40:46 <jmcarthur_> are you sure the C compiler isn't just optimizing whatever you're benchmarking down to nothing or something?
21:40:49 <jmcarthur_> yeah that
21:40:54 <SrPx> the ghc performance doesn't look bad at all
21:42:39 <SrPx> I often do those "vs gcc" tests to get an idea of how slow/tolerable is some very high level abstraction I just wrote
21:42:56 <jmcarthur_> i got my blitter thing down to 0.8ns per pixel for unboxed blocks of Doubles with (+) as the blending function.
21:43:16 <jmcarthur_> i usually just estimate what i think it should be and investigate if my prediction is wrong
21:44:17 <jmcarthur_> i tried using the new-ish simd primops in ghc, but i couldn't get it to build a working binary, so i abandoned that idea :(
21:45:34 <SrPx> so around 125kk pixels/s? are you sure?
21:46:41 <SrPx> I recall 100kk/s is basically how much an empty for loop ran in javascript 
21:47:26 <SrPx> oh no, it was 1kkk
21:47:36 <jmcarthur_> i'm not sure i understand your kk notation. you mean 1000000*125?
21:47:57 <SrPx> lol yes, sorry former rpger 
21:48:29 <mniip> I thought everyone knows what 1kk means ...
21:49:10 <jmcarthur_> 0.8ns per operation is actually 1_250_000_000 operations per second
21:49:25 <SrPx> oh my bad
21:49:54 <jmcarthur_> i wouldn't quite call these "pixels", to be fair. they are each a single Double
21:50:03 <jmcarthur_> but yeah, i think the number checks out
21:51:18 <SrPx> I didn't even know people used doubles to represent pixels
21:51:19 <jmcarthur_> there are no allocations or functions calls in the loop. it's just some additions and conditional jumps
21:51:36 <jmcarthur_> well it's polymorphic code, and i specialized it to doubles for the microbenchmark
21:52:20 <jmcarthur_> though actually i *am* using doubles in my actual code, for the convenience, until i find that i need something else
21:53:43 <jmcarthur_> using doubles is convenient for working in a linear color space and for working with premultiplied alpha
21:54:30 <wkmanire> cj3kim: guake
21:54:41 <wkmanire> cj3kim: By default it binds to F12 system-wide
21:54:58 <wkmanire> You just press F12 to drop down the terminal whenever you need it. Supports multiple tabs, transparency, etc..
22:15:16 <ramadoka> :t (+) -- pardon me, testing
22:15:19 <lambdabot> Num a => a -> a -> a
22:20:05 <Geraldine> Welkin: now just polishing js in which I work
22:20:40 <Welkin> Geraldine: polishing poop?
22:21:03 <Geraldine> Lokathor: I kknew hello world in Java wasn't the nicest one, but on a wiki it looked much wore
22:21:24 <Welkin> hello world is a contrived example...
22:21:25 <Geraldine> Your post from a 5 hours ago
22:21:31 <Lokathor> the wiki you linked two had two totally seperate examples
22:21:36 <Lokathor> one was for the command line
22:21:40 <Lokathor> one was for a GUI window
22:21:53 <Welkin> I think a parser is a better example
22:21:53 <Geraldine> yes, I mentioned the one for the GUI
22:21:57 <Welkin> like what was said before
22:22:11 <Geraldine> because I was unfamiliart with it
22:22:13 <Welkin> show a language implemented in haskell in under 500 lines
22:23:27 <Welkin> Geraldine: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
22:23:35 <Lokathor> Welkin, i made a brainfuck interpreter in 500 lines of haskell before
22:23:37 <Lokathor> does that count
22:24:21 <Geraldine> do You know how long take it me to get to 'work'
22:25:03 <Welkin> Geraldine: you can implement that scheme parser from the tutorial I linked in one evening
22:25:15 <Welkin> even though it says "48 hours"
22:25:16 <Geraldine> one hour
22:25:26 <Welkin> it could take well over a week if you don't know any haskell
22:25:38 <Geraldine> yes, that's my case
22:25:38 <Welkin> if you understand haskell already, maybe a couple hours
22:26:02 <Lokathor> the longest part is reading the r5rs standard :P
22:26:29 <Welkin> I got through it in a couple days when I first started learning haskell and my only experience was reading LYAH and a little of the typeclassopedia
22:26:37 <Welkin> maybe it was 3 days
22:27:10 <Lokathor> i've skimmed the scheme thing before
22:27:21 <Welkin> it's a good exercise
22:27:24 <Welkin> tons of fun too
22:27:28 <Lokathor> i've wanted to sit down and go back and do it and then upgrade it to a full r5rs scheme
22:27:33 <Welkin> even if the tutorial is quite old now
22:27:40 <Lokathor> but i don't quite know enough scheme yet either to get some parts of it
22:27:44 <Welkin> lol
22:27:45 <Lokathor> gotta read some more SICP
22:27:50 <Welkin> yes that was my biggest problem
22:27:54 <Lokathor> that CPS stuff
22:27:55 <Welkin> I didn't understand the scheme syntax
22:28:14 <Welkin> or how the language was supposed to work
22:30:04 <Lokathor> "didn't understand scheme syntax"
22:30:12 <Lokathor> what syntax even man
22:30:14 <Lokathor> there's like
22:30:15 <Lokathor> nothing to it
22:30:39 <Lokathor> just () and ' and a few char literals and the occasional #' or whatever
22:31:01 <Welkin> I meant the quote and other things
22:31:49 <mniip> Lokathor, it could also mean "I can't read dense sequences of slightly unbalanced parentheses
22:32:32 <Lokathor> it's true, those cond blocks are nonsense
22:38:37 * hackagebot cmark 0.4.1 - Fast, accurate CommonMark (Markdown) parser and renderer  https://hackage.haskell.org/package/cmark-0.4.1 (JohnMacFarlane)
22:41:15 <Welkin> oh this is great
22:41:27 <Welkin> verbatim from Real World Haskell: "In an ideal world, would we make a break from the past, and switch over Prelude to use Traversable and Foldable types? Probably not."
22:41:38 <Welkin> the irony
22:48:37 * hackagebot tls 1.3.2 - TLS/SSL protocol native implementation (Server and Client)  https://hackage.haskell.org/package/tls-1.3.2 (VincentHanquez)
22:58:04 <johnw> haha
22:58:28 * Clint squints.
23:00:57 <wkmanire> Hello. I'm trying to understand how generic data types work. I'm experimenting with implementing a function which can double types of Num, Char or [Char], either using + or ++, whichever makes sense for the type. https://www.refheap.com/108659
23:01:17 <wkmanire> This doesn't compile, but I'm not sure if this is possible or if I just have the wrong syntax
23:03:13 <liste> wkmanire if you use a sum type, you could have doubleIt Num Char
23:03:38 * hackagebot warp-tls 3.1.2 - HTTP over TLS support for Warp via the TLS package  https://hackage.haskell.org/package/warp-tls-3.1.2 (KazuYamamoto)
23:03:53 <liste> is that what you want?
23:04:04 <wkmanire> liste: Really, I just want to understand how this works.
23:05:38 <liste> wkmanire the ... in data Doubleable a = ... are constructors, not types
23:05:50 <wkmanire> liste: I got a nice answer in #haskell-beginners that explained it well. Thanks!
23:05:59 <liste> (: good
23:07:03 <johnw> wkmanire: that's going to be a tricky function to write without lots of partial results
23:07:52 <wkmanire> johnw: I was just thinking. "Ok, how would you go about implementing the '+' operator from Javascript?"
23:08:02 <johnw> perhaps better is a GADT that indicates in the type which constructor was chosen, so that only compatible pairs can be passed to doubleIt
23:08:08 <johnw> ah, I see
23:08:17 <johnw> you want runtime-inferred behavior
23:08:46 <johnw> ok, never mind my other suggestion
23:09:39 <wkmanire> The JS + operator is super complex in that sense. It deals with lots of different types of data. Number, String and Array
23:09:59 <wkmanire> And each has its own unique behaviors based on the values. It also deals with NaN, null, infinity, Object
23:14:40 <ttt_fff> is there a (f :: a -> Bool) -> [a] -> [[a]]; which (1) runs f on the elems, (2) kills the elems forr which f is true; and (3) groups the remaining elments separated by when 'f' was true
23:16:16 <opqdonut> you can almost use groupBy for that
23:17:03 <opqdonut> > groupBy ((==) `on` even) [1,2,4,6,5,8,10,3]
23:17:15 <opqdonut> hmm lambdabot is not awake it seems
23:17:23 <opqdonut> anyway, that comes out as [[1],[2,4,6],[5],[8,10],[3]]
23:17:34 <ttt_fff> oh, use groupby, and kill ever other element?
23:17:39 <opqdonut> yeah
23:17:52 <opqdonut> or just write out the recursion yourself
23:17:55 <ttt_fff> so it's like (take odd) . (groupBy f) ...
23:18:33 <opqdonut> odd/even elements depends on whether the first element of the list fulfills f or not
23:19:06 <opqdonut> I think I'd use "filter (f . head) . groupBy ((==)`on`f)"
23:20:45 <opqdonut> but the recursion is simple enough too
23:22:28 <opqdonut> something like: group' _ [] = []; group' pred xs = let (now,rest) = break (not.pred) (dropWhile (not.pred) xs) in now : group' pred rest
23:22:38 <Flonk> He left :/
23:22:47 <opqdonut> group' even [1,2,4,6,5,8,10,3] ==> [[2,4,6],[8,10],[]]
23:22:49 <opqdonut> oh, indeed
23:22:52 <opqdonut> well I had my fun
23:28:29 <jle`> hm, why doesn't lens-family have Prism
23:28:40 <pacak> Any ideas why something like that "case divInt# 9223372036854775807# 8# of ww4_i1Lk9 { __DEFAULT ->" is not constant folded on compile time and how to convince ghc to do it?
23:31:36 <erisco> bsod
23:31:41 <erisco> been too frequently lately
23:38:03 <johnw> pacak: you could always force it to happen with template haskell
23:41:12 <sanjoyd> Random question about strictness -- given that "undefined || True" is undefined, can ghc not optimize "complex_expression || True" to  to True?
23:41:43 <sanjoyd> Or is it okay to reason that "complex_expression || True" is bottom or True, so it is okay to always replace it with True?
23:41:46 <liste> > undefined || True
23:41:48 <lambdabot>  *Exception: Prelude.undefined
23:42:11 <srhb> sanjoyd: How do you figure that that's reasonable? I mean, bottom really matters in this case.
23:42:29 <johnw> srhb: why does it?
23:42:37 <pacak> sanjoyd: You  can achieve something like that with rewrite rules
23:42:49 <srhb> johnw: Operationally, because undefined || True = undefined
23:42:54 <johnw> yeah, {-# RULES forall b. b || True = b #-}
23:43:00 <sanjoyd> pacak: yes, but is it okay from the semantics / meaning of undefined?
23:43:17 <johnw> srhb: operationally, just because || chooses to evaluate its first argument first?
23:43:26 <srhb> johnw: Yes.
23:43:33 <johnw> I wouldn't think that semantically there'd be any order requirement on ||
23:43:36 <srhb> If it were the other way around it would obviously not be the case.
23:43:46 <johnw> obviously in what sense?
23:44:32 <srhb> Because even if you include the semantics of undefined, foo || True is always True even if foo = undefined if the right hand argument is evaluated first always.
23:44:42 <johnw> right
23:45:13 <johnw> I'm wondering whether the rewrite RULE is in any way "wrong", other than affecting the operational semantics of || as defined by Data.Bool
23:45:20 * srhb nods
23:45:40 <srhb> The reason I'm balking is that the question appears to be "even if I include operational semantics of undefined, can I do this"
23:45:54 <srhb> To which I think the answer is no, but I also don't see why it's reasonable to even include the operational semantics of undefined
23:45:59 <johnw> right
23:49:14 <sanjoyd> srhb: johnw so what's the place to read about what the operational semantics of undefined are, as used in Haskell?
23:50:34 <pleen> Hello, just looking around, but it's late on a Sunday/Monday, so there doesn't seem to be anyone here.
23:50:37 <srhb> sanjoyd: The Haskell Language Report. But it's not that interesting, it will tell you that it's a runtime error.
23:50:50 <srhb> pleen: Huh? There are a ton of people here :)
23:51:10 <srhb> pleen: The channel is intermittently quiet because no question has been posed that people are responding to. :)
23:51:27 <pleen> @<srhb> I see, thanks.
23:51:28 <sanjoyd> the reason why I started thinking about this -- can a well defined program meaningfully "depend on" an undefined of some type?
23:51:34 <srhb> pleen: Also it's early on a monday morning here. :-)
23:51:38 <lambdabot> Unknown command, try @list
23:51:42 <sanjoyd> (for some hand-wavy defn. of "depend on")
23:51:59 <johnw> it has no informational content
23:52:00 <srhb> sanjoyd: Yes, if the value is never evaluated.
23:52:19 <johnw> it's like a box that claims to have False inside it, but you can't ever open it
23:52:21 <sanjoyd> More specifically, will replacing "undefined :: a" with some arb. value of type "a" change the behavior of a progrma that does not try to evaluate undefined?
23:52:34 <johnw> (and by False I mean a witness to the proof of falsehood)
23:52:49 <johnw> sanjoyd: no, that shouldn't change anything
23:52:54 <srhb> sanjoyd: No, I don't see how that could be the case.
23:52:56 <johnw> you can't observe the difference in such a program
23:53:21 <sanjoyd> Interesting, so that bit of my intuition was not wrong. :)
23:54:11 <sanjoyd> Given that, it should be okay (i.e. semantic preserving) for ghc to replace "case x of a -> 0; b -> undefined" with "0", no?
23:54:36 <johnw> why would that be the case?
23:55:16 <sanjoyd> (assume x is of type with the two injections, a and b)
23:55:39 <johnw> such an expression has two possible values: 0 or undefined
23:55:50 <johnw> there's no reason to assume it would always be the former
23:55:54 <srhb> This seems to imply that we can always avoid a runtime error by doing something else that isn't a runtime error completely at random.
23:56:00 <johnw> sanjoyd: you might like https://hackhands.com/non-strict-semantics-haskell/
23:56:30 <sanjoyd> srhb: another way to phrase my question would be "what are the semantics of a runtime error?"
23:56:45 <srhb> Program halts execution and throws an error?
23:56:48 <sanjoyd> Are they more like C's UB (that anything can happen) or more like Java's exceptions?
23:57:22 <johnw> i don't believe it can be defined within the scope of Haskell, because that would imply the existence of some other normal term you could refer to
23:57:23 <sanjoyd> Java's exceptions as in, they're part of the language's semantics, and the optimizer needs to preserve when they're thrown etc.?
23:57:29 <johnw> "never stops" is a valid answer
23:58:08 <sanjoyd> johnw: I didn't understand what you meant by "that would imply the existence of some other normal term you could refer to"
23:58:12 <sanjoyd> johnw: and thanks for the link.
23:58:14 <srhb> According to the report: When evaluated, errors cause immediate program termination and cannot be caught by the user.
23:58:37 <johnw> i.e., undefined = ....
23:58:46 <johnw> if I could say anything about ...., it wouldn't really be undefined any more
23:58:53 <srhb> I can say more than that.
23:59:07 <srhb> For instance, it's really error foo where foo is an error message given by the compiler.
