00:00:09 <zomg> outside of hobby projects no
00:00:22 <zomg> what we did for production at work was a simple web service'ish thing
00:01:02 <zomg> ended up being more stable than what a node app would've been I'm sure =)
00:01:24 <zomg> I don't think it crashed once or had any other issues... node processes always need another process to monitor them for crashes to restart them :P
00:01:53 <greves> yeah
00:01:55 <EvanR> what i wrote in haskell for production was like night and day compared to the php and node
00:01:56 <zomg> then again that is the recommended way to handle errors in node, just crash the entire process and restart
00:02:03 <zomg> at least unrecoverable/unexpected errors
00:02:09 <EvanR> i was like wait why am i not having to solve weird issues literally all the time
00:02:31 <EvanR> i did have one weird issue and that was using String for a lot of text
00:02:36 <EvanR> which caused stack overflow
00:02:43 <EvanR> used ByteString instead
00:02:54 <EvanR> (for ascii text)
00:03:02 <greves> so what do you use for the web server when you use haskell?
00:03:24 <NeverDie> greves: Fairy dust.
00:03:27 <zomg> I just used warp
00:03:46 <dramforever> EvanR: String considered harmful
00:03:53 <EvanR> i learned the hard way
00:04:18 <dramforever> I do believe that haskell should be designed with String like Text
00:04:28 <greves> ... String doesn't work for long strings?
00:04:40 <dramforever> type String = [Char] = trouble
00:04:48 <dramforever> lots of wasted memory
00:04:49 <bob_twinkles> it's a singly linked list of unicode codepoints
00:04:49 <kadoban> greves: It works fine, it's just pretty heavy for anything besides toys. Text is nice.
00:04:51 <EvanR> if you do a lot of processing, splicing, grouping, replacing, on String = [Char] it might use too much memory
00:04:57 <EvanR> Text is better
00:05:04 <dramforever> waaayyy better
00:05:28 <EvanR> greves: long in this case means, megabytes
00:05:53 <EvanR> String is only recommended for "short" strings
00:06:04 <greves> yes, as i said i do some language processing so i frequently have megabytes of text
00:06:13 <greves> like, many megabytes
00:06:14 <EvanR> Text then
00:06:18 <greves> ok
00:06:19 <greves> good to know
00:06:47 <bob_twinkles> fortunately, anything you can do to a String you can do to a Text using exactly the same interface =D
00:06:50 <kadoban> Depending what you're doing, ByteString can also be useful. It's what it sounds like though, just bytes, no implicit encoding or meaning.
00:07:36 * hackagebot webkit-javascriptcore 0.13.1.0 - JavaScriptCore FFI from webkitgtk  https://hackage.haskell.org/package/webkit-javascriptcore-0.13.1.0 (HamishMackenzie)
00:07:36 * hackagebot ihaskell-hatex 0.2.1.0 - IHaskell display instances for hatex  https://hackage.haskell.org/package/ihaskell-hatex-0.2.1.0 (gibiansky)
00:10:03 <greves> but Text /= [Char] ?
00:10:13 <EvanR> no
00:10:26 <EvanR> Text is implemented as arrays of utf16 bytes
00:11:15 <greves> utf16 hmmm... i use utf8 almost exclusively
00:11:23 <EvanR> you dont know about the utf16
00:11:27 <EvanR> its an implementation detail
00:11:42 <EvanR> when you load text, you have to decode it no matter what
00:11:47 <greves> ok so 3 or 4 byte utf8 characters will be recognized correctly?
00:11:58 <dramforever> yes
00:12:08 <greves> cool
00:12:15 <dramforever> sure they are...
00:12:22 <EvanR> decodeUtf8 :: ByteString -> Text
00:12:35 <EvanR> if the ByteString is in utf8
00:19:22 <ReinH> Text even gets things like capitaliztion right, which is not trivial with unicode.
00:19:45 <greves> you mean capitalization for other characters beyond ASCII?
00:19:52 <ReinH> yes
00:20:11 <EvanR> String does not?
00:20:33 <EvanR> it should since Text is still using Char operations
00:27:36 <breadmonster> Hey everyone.
00:27:44 <breadmonster> Where can I learn about Hindley-Milner?
00:28:46 <MarcelineVQ> google knows
00:29:01 <EvanR> algorithm W
00:29:04 <breadmonster> I'm trying to figure out how Haskell infers stuff.
00:29:31 <EvanR> using unification
00:29:45 <EvanR> which is also used in logic programming systems
00:33:59 <ggole> breadmonster: you could read a text that goes into an implementation like TAPL, or PLAI
00:34:10 <ggole> And write a toy type checker
00:34:38 <greves> Expected kind ‘*’, but ‘Num’ has kind ‘* -> GHC.Prim.Constraint’
00:34:45 <greves> meaning?
00:34:57 <EvanR> Num isn't a type
00:35:12 <EvanR> its a typeclass
00:35:31 <EvanR> that error msg sucks
00:36:02 <EvanR> still prefer ghc errors to g++ errors
00:36:05 <greves> so how would i define a function that works on Int, Integer, Float, or Double?
00:36:19 <EvanR> :t (+)
00:36:20 <lambdabot> Num a => a -> a -> a
00:36:29 <EvanR> here is the type signature for one that does
00:36:35 <breadmonster> greves: f :: Num a => a -> a; f x = 
00:36:48 <suppi> does anyone have a good name for this function: func f g x = f (g x) x?
00:36:55 <breadmonster> ggole: I'm wondering if we can implement rank 2 type inference in Haskell.
00:37:00 <dramforever> suppi: (>>=)
00:37:00 <shirt> how to convert this pipes example to work with the latest version of pipes?  http://stackoverflow.com/a/14025993
00:37:08 <dramforever> :t (>>=)
00:37:09 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:37:16 <dramforever> :t (\f g x -> f (g x) x)
00:37:17 <lambdabot> (r1 -> r2 -> r) -> (r2 -> r1) -> r2 -> r
00:37:20 <breadmonster> :t \f g x -> f (g x) x
00:37:21 <lambdabot> (r1 -> r2 -> r) -> (r2 -> r1) -> r2 -> r
00:37:25 <greves> aha
00:37:25 <dramforever> um...
00:37:30 <dramforever> @src (>>=)
00:37:30 <lambdabot> Source not found. Are you typing with your feet?
00:37:33 <dramforever> no
00:37:37 <suppi> ?
00:37:47 <dramforever> @pl \f g x -> f (g x) x
00:37:47 <lambdabot> flip flip id . liftM2
00:37:50 <EvanR> greves: gotta make sure the function you are trying to write actually makes sense for Int, Integer, and Double
00:37:50 <dramforever> sigh
00:37:55 <dramforever> @unpl (>>=)
00:37:55 <lambdabot> (>>=)
00:37:58 <dramforever> sigh..
00:38:04 <dramforever> suppi: wait..
00:38:08 <EvanR> greves: those three very different data types
00:38:10 <suppi> dramforever, :)
00:38:17 <breadmonster> dramforever: There's no monad anywhere
00:38:22 <greves> EvanR yeah, just practicing basic stuff for syntax :P
00:38:23 <ggole> breadmonster: my understanding is that inference is undecidable for higher-ranked types
00:38:27 <dramforever> :t (>>=) :: (r -> a) -> (a -> r -> b) -> r -> b
00:38:28 <lambdabot> (r -> a) -> (a -> r -> b) -> r -> b
00:38:34 <dramforever> @djinn (r -> a) -> (a -> r -> b) -> r -> b
00:38:34 <lambdabot> f a b c = b (a c) c
00:38:43 <dramforever> suppi: flip (>>=)
00:38:46 <breadmonster> ggole: For n > 2
00:39:04 <suppi> dramforever, cool. thought it was familiar
00:39:20 <dramforever> :t ap
00:39:21 <lambdabot> Monad m => m (a -> b) -> m a -> m b
00:39:53 <dramforever> @djinn (r -> a -> b) -> (r -> a) -> r -> b
00:39:53 <lambdabot> f a b c = a c (b c)
00:40:04 <dramforever> still off by a little bit
00:40:29 <ggole> breadmonster: oh hmm, seems you're right
00:40:49 <ggole> (I mentally bucketed "rank 2" as "higher-rank".)
00:41:27 <suppi> dramforever, I'm worrying it might be too terse and unreadable though
00:41:37 <dramforever> yes it is
00:41:48 <dramforever> use the expanded one instead
00:41:55 <dramforever> s/^/maybe
00:42:31 <joco42> is the cpython-haskell binding python 3 only ? https://hackage.haskell.org/package/cpython https://john-millikin.com/articles/ride-the-snake/ it seems so from this article
00:47:55 <suppi> dramforever, expanded one?
00:50:18 <suppi> maybe I'll call it supplyBoth or something.
00:54:26 <aib> Supposing we had a type constructor (<-) of the kind *->*->* which did what (->) did in reverse, is this correct? It couldn't be a Functor because we wouldn't be able to implement fmap, not without a helper function (a -> b) -> (b -> a)
00:54:53 <dramforever> aib: it's a contravariant functor
00:55:06 <dramforever> and it exists already, iirc it's called Op
00:55:12 <aib> I mean (<-) partially applied to a type, ((<-) a) couldn't be an instance of Functor* ...I think
00:55:21 <dramforever> yes
00:55:29 <aib> hmmm
00:55:31 <dramforever> but it can be a contravariant functor
00:55:41 <dramforever> aib: are you new to haskell?
00:55:54 <dramforever> or just thought of this little idea?
00:55:56 <aib> I'm sorry, I have no idea what those are. I came to this line of thinking while trying to reason about Functors
00:56:08 <dramforever> aib: oh don't worry then
00:56:13 <dramforever> your reasoning is correct
00:56:22 <aib> not brand new; it's been a few years. I'm reading about this CT-TT stuff in between
01:04:25 <greves> well that was annoying, Real World Haskell assured me that foldl would simply stack overflow if i tried to do a big operation
01:04:37 <greves> Instead it just took all the memory and froze my machine :P
01:05:10 <dramforever> stack too big
01:05:28 <aib> if I may think out loud for a minute... What if we had ((<-) Nothing), a series of functions completely ignoring their input value and returning Nothing (better "unit", (), no?), then fmap would be trivial to implement: fmap _ _ = (\x -> Nothing). Right?
01:07:11 <aib> greves: got a large swap?
01:07:36 <greves> using windows
01:08:05 <aib> "pagefile" then. yuck.
01:10:03 <valdyn> greves: it overflows only in the repl, by default
01:10:16 <greves> TIL... Haskell Curry...
01:10:56 <greves> thought to myself yesterday when i first started playing around that wow its really easy to curry stuff in haskell. little did i know.... hah
01:10:57 <dramforever> actually linux's memory management sucks when using GUI
01:11:19 <valdyn> dramforever: what are you talking about?
01:11:31 <dramforever> valdyn: "took all the memory and froze my machine"
01:11:46 <valdyn> using windows
01:11:49 <dramforever> that's....not supposed to happen
01:11:56 <dramforever> dunno about windoes
01:11:59 <dramforever> *windoes
01:12:04 <dramforever> *windows
01:12:05 <dramforever> ...
01:12:52 <EvanR> dohs
01:13:09 <valdyn> just dont use swap on the development system
01:13:38 <valdyn> then it wont freeze or crawl
01:14:25 <EvanR> greves: i hear that certain things on haskell windows are not getting much attention lately
01:15:09 <EvanR> which if true is probably not great in an absolute sense
01:18:24 <greves> well everything else has worked OK so far
01:21:08 <|beowulf|> hi
01:21:22 <|beowulf|> I'm trying to build aeson and I'm getting this: http://pastebin.com/TsKtGaUa
01:21:25 <|beowulf|> any ideas?
01:25:34 <EvanR> ouch, lpaste
01:25:48 <EvanR> |beowulf|: i think the only error there is no instance for MonadIO
01:26:25 <EvanR> and since the package warnings include MTL
01:26:36 <|beowulf|> EvanR: I have a second computer running the same linux distribution with the same package versions that doesn't get the error
01:26:39 <EvanR> im guessing you need to untangle your cabal installed packages
01:26:44 <|beowulf|> and I have no clue why
01:26:53 <EvanR> do you get the same warnings?
01:26:59 <EvanR> if not, then you dont have the same versions
01:27:12 <|beowulf|> EvanR: let me check...
01:27:51 <EvanR> so im going to bet on the "multiple installed versions of the same package" theory
01:29:20 <|beowulf|> EvanR: http://pastebin.com/JajKNAic
01:30:38 <|beowulf|> EvanR: how did that multiple version thingy get there? This computer is a fresh install, it never had transformers-0.4.2.0
01:31:05 <EvanR> ghc comes with some packages
01:31:08 <EvanR> i believe
01:31:28 <|beowulf|> transformers is not among them
01:31:43 <|beowulf|> what is the recommended way of getting rid of such situations?
01:31:48 <EvanR> in the first post it says "depends on multiple versions"
01:31:52 <|beowulf|> and how do I prevent them in the first place?
01:31:57 <EvanR> so they might have been installed that way
01:32:15 <EvanR> people will tell you to use sandboxes to build anything
01:32:32 <|beowulf|> sandboxes?
01:32:42 <EvanR> then all the deps will be built in isolation from any other project youre working on
01:33:05 <EvanR> cabal has sandboxes
01:33:28 <|beowulf|> EvanR: I'm afraid that's not an option, I'm using my linux distribution's package system
01:33:37 <EvanR> for what, the libraries?
01:33:39 <EvanR> dont do that
01:34:04 <|beowulf|> why not?
01:34:07 <EvanR> you need to build everything yourself with cabal install
01:34:21 <|beowulf|> that's what a package system is for
01:34:46 <EvanR> if the haskell packages from a distro work at all, i would bet they only work to let you use prebuilt haskell programs
01:34:52 <EvanR> not develop new haskell programs
01:34:54 <|beowulf|> and it does seem to work for other distributions so I'm guessing mine is doing something wrong during installation
01:35:11 <EvanR> im highly suspicious of your claims
01:35:21 <|beowulf|> EvanR: I'm not developing new haskell programs
01:35:23 <|beowulf|> I
01:35:25 <EvanR> oh?
01:35:41 <|beowulf|> I'm trying to make packages for said linux distribution
01:35:48 <EvanR> then use the distros package manager to get the program heh
01:36:01 <|beowulf|> EvanR: that's what I'm doing
01:36:07 <EvanR> which program
01:36:26 <|beowulf|> git-annex plus its dependencies
01:36:35 <EvanR> ok
01:37:19 <|beowulf|> by now I have created packages for all dependencies (quite a lot in fact) but I'm still ocasionally getting this error
01:37:20 <demize> |beowulf|: I tried that once. I gave up a few hours after trying to get all the dependencies to build. Many of which would not build on newer ghc versions.
01:37:24 <|beowulf|> and I have no idea why
01:37:40 <|beowulf|> demize: I got all of them to build
01:37:44 <|beowulf|> sometimes :(
01:37:46 <demize> Which ghc?
01:37:58 <|beowulf|> 7.10.1
01:38:09 <demize> Interesting. I wonder if some of the deps were updated then.
01:38:11 <EvanR> i had to upgrade my ghc to get git-annex to build
01:38:44 <EvanR> i havent had success with distro package managers
01:39:07 <|beowulf|> hm, ghc 7.10.2 is out, hadn't noticed that
01:40:12 <EvanR> https://wiki.haskell.org/Cabal/Survival
01:47:53 <greves> why is an executable that just prints a line of text ~3.5 MB?
01:48:40 <indiagreen> greves: it should be just 800 kB after stripping
01:48:57 <indiagreen> greves: but there's still huge Haskell runtime linked with every executable
01:52:16 <greves> its 1.2MB if i run strip
01:53:35 <indiagreen> greves: you can use dynamic linking to decouple the runtime and the actual executable, but it still means that you'll have to distribute the runtime somehow
01:54:02 <indiagreen> greves: if this is absolutely unacceptable to you, JHC might be your only option (it produces 16 kB executables, I think)
01:54:18 <indiagreen> (I mean, a Hello World takes only 16 kB)
01:55:42 <greves> well that could be interesting but jhc doesn't compile on windows apparently
01:55:45 <greves> so that's annoying :P
01:56:26 <ttt_fff> indiagreen: is your time zone inidia?
01:58:05 <indiagreen> ttt_fff: MSK
01:58:25 <ttt_fff> Moscow
01:58:35 <indiagreen> Russia's glorious capital
01:58:48 <ttt_fff> fedor emelianenko is a badass // I respect Russia
01:59:26 <ttt_fff> how is idris only 45K LOC
02:00:43 <indiagreen> greves: I remember being quite annoyed about huge size of compiled executables (as well as about Haskell's runtime stealing +RTS command line arguments – like, “how dare it not pass all of command line arguments to my program, every single last of them!”), but now I don't care because there are more interesting things to care about
02:01:06 <ttt_fff> I once heard
02:01:13 <ttt_fff> that the greatest optimization is going from "not working" to "working"
02:01:32 <ttt_fff> so a 2 MB working executable is probably better than a 4KB demoscene not working prog
02:01:56 <ttt_fff> in fact, unless you want the entire prog to fit in L2 cache, why does exec size matter?
02:02:02 <indiagreen> ttt_fff: this argument would've absolutely not worked on past-me
02:02:06 <ttt_fff> 2MB is like 1 hihg resolution photo
02:02:18 <ttt_fff> indiagreen: see, you're now smarter :-)
02:02:22 <indiagreen> ttt_fff: I was insulted by huge executable sizes on visceral level
02:02:28 <indiagreen> it's not “smarter”
02:02:50 <indiagreen> you can't easily choose what to care about
02:02:56 <indiagreen> and what to feel bad about
02:03:00 <dramforever> indiagreen: I would say it's more normal, to present self
02:03:00 <ttt_fff> these days, the only things that insult me is a function of "Int -> Int" type, but can arbitrarifly modify the world before returning an Int ; I look at it, and it's LIES LIES LIES
02:04:17 <indiagreen> ttt_fff: if it's not Haskell, it's not lies
02:04:38 <ttt_fff> it's contradicting the matheamtical definition of th word 'function'
02:05:01 <indiagreen> so what?
02:05:14 <indiagreen> I'm not doing mathematics, I'm doing <insert language name here>
02:05:22 <indiagreen> I never expected a mathematical definition
02:05:55 <indiagreen> it's not lies, it's that you had false expectations and you'll have to adjust them
02:06:35 <indiagreen> also, the mathematical definition of the word function doesn't include “can eat all RAM and my laptop would freeze”
02:06:43 <ttt_fff> well, I came from a C/C++ background; so it's actually I changed my expectations after learning Haskell, and realized that the entire world \ Haskell was wrong
02:07:04 <indiagreen> ttt_fff: or you can learn that words don't have to have exactly 1 definition
02:07:07 <ttt_fff> indiagreen: the code does not specify the hardware you run it on
02:07:23 <ttt_fff> if you ran it on a theoretical machine, it would not freeze and run out of memory
02:07:40 <ttt_fff> indiagreen: you mean english words can function like typeclasse ;-)
02:08:57 <greves> i really like the mathiness of haskell
02:09:08 <greves> makes a lot more sense to someone like me with a math background
02:09:31 <greves> like list comprehensions where even the <- looks more or less like an awkward epsilon :P
02:10:17 <ttt_fff> ah, that might be why
02:10:21 <indiagreen> ttt_fff: no, English words are just context-dependent, but in a vague way, and the analogy with typeclasses would be somewhat stretched here
02:10:25 <ttt_fff> indiagreen: how much math background do you come from?
02:12:20 <indiagreen> ttt_fff: hard to say, I was studying in a school with strong math curriculum and I used to be interested in number theory / probability theory / etc, but I also dropped out of university and mostly forgotten everything by now
02:19:36 <zettablade> Hey, could anyone here point me in the direction of a sweet 2d graphics api for haskell? I've got something similar to gloss, with a Picture type that acts as a monoid, but I'm feeling like it might be a little limited and I was wondering if there are better ways of doing this.
02:20:33 <ttt_fff> frp? opengl?
02:20:35 <ttt_fff> what are you looking for
02:20:36 <ttt_fff> sdl?
02:23:36 <zettablade> I need to arrange pictures with left/right/up/down/center alignment on a screen. Working on a visual novel engine. Just wondering if anyone has solved this problem before. I've checked out diagrams, but a lot of that code is way over my head.
02:26:28 <sbrg> zettablade: you need to get a 'best fit' with rectangular pictures or some such?
02:28:19 <zettablade> Yes, that's another problem. I'm really concerned I might need to implement a GUI-like drawing framework, similar to scene2d. I've heard this can be difficult with haskell.
02:28:46 <dramforever> [citation needed]
02:30:15 <dramforever> also I think it's not very hard
02:30:29 <sbrg> zettablade: A visual novel framework does not sound like it is very graphically intensive. I don't see why gloss wouldn't be enough here
02:30:42 <ttt_fff> dramforever: citation [ https://www.youtube.com/watch?v=VWAvarfVtHI ]
02:30:44 <dramforever> sbrg ++
02:31:01 <zettablade> Gloss, in particular, is not enough for anything other than a demo.
02:31:03 <dramforever> ttt_fff: okay
02:31:15 <sbrg> zettablade: why do you say that?
02:31:18 <dramforever> zettablade: why? what are you concerned about?
02:31:56 <dramforever> hmm...idea for layout engine:
02:32:27 <dramforever> sorry it's not going to work
02:32:31 * dramforever fail
02:33:10 <ttt_fff> layout engine: if static, just dump it out; if dynamic, use frp
02:33:13 <sbrg> zettablade: Correct me if I misunderstood: You have rectangular pictures and a rectangular surface you want to paint these pictures on. You want to be able to align them. Center, upper left, upper right, lower left, etc.. yes? 
02:33:42 <sbrg> that sounds neither a) very graphically intensive nor b) very complicated. taking care of overlaps should not be very complicated
02:34:10 <dramforever> zettablade: what about interaction? do you have interaction?
02:34:31 <zettablade> Yea, it isn't complicated. I'm just wondering if there's a functional way this is done. Gloss doesn't provide one, and diagrams is too complicated for me.
02:34:59 <dramforever> do you have interaction?
02:35:04 <zettablade> Yes
02:35:18 <ttt_fff> can you write a turing machine in haskell? yes. therefore, there's a functional way to do everything
02:35:40 <dramforever> how complicated? is it simple, like click button -> next page?
02:36:05 <sbrg> I mean.. painting a picture upper-left is literally painting it at (0, 0). Painting another picture to the right of that pic is painting it at (width upperLeftPicture, 0) 
02:37:18 <zettablade> At this point, yes. The interaction is already a solved problem though. Right now I'm just window shopping for solutions to handling layout.
02:37:34 <sbrg> you just haven't explained very well, still, what kind of 'layout' you need
02:37:57 <dramforever> zettablade: handle it yourself shouldn't be hard, as sbrg sail
02:38:00 <dramforever> *said
02:38:35 <sbrg> if you just need to paint as many pictures in as little space as possible, then you are basically looking for an algorithm that solves a 2D knapsack problem
02:38:43 <zettablade> Eh, it was worth asking. Thanks for entertaining the thought.
02:40:09 <sbrg> zettablade: I am genuinely curious though. I don't think there are existing solutions for any graphics library, but it would surprise me if you problem couldn't just be 'pulled out', viewed as a knapsack problem and then solved with already existing libraries
02:40:32 <sbrg> but that still depends on what kind of layout you need exactly, which I'm still unsure about
02:40:57 <dramforever> sbrg: it can't be knapsack IIUC
02:41:19 <dramforever> a visual novel framework cannot simply put all the images together
02:41:25 <sbrg> yeah, that's what I was thinking
02:42:02 <sbrg> there is probably only a single sequence of images that makes sense, but in that case the layout problem doesn't exist :b 
02:42:29 <zettablade> is the nap-sack problem relevant to a cell-based layout? I think that's what I'm getting at here, something similar to scene2d, if you've ever heard of that.
02:42:35 * hackagebot jsaddle 0.2.1.0 - High level interface for webkit-javascriptcore  https://hackage.haskell.org/package/jsaddle-0.2.1.0 (HamishMackenzie)
02:42:45 <dramforever> zettablade: no knapsack is irrelevant
02:43:05 <dramforever> @google scene2d
02:43:05 <lambdabot> https://github.com/libgdx/libgdx/wiki/Scene2d
02:43:46 <dramforever> TL;DR =(
02:44:19 <sbrg> oh wait, I have worked with scene2d for like.. an hour once, I think
02:44:21 <sbrg> hm
02:45:02 <sbrg> zettablade: Could you explain in more detail? How is the layout supposed to work exactly? Maybe we(or someone else in here) can come up with suggestions.
02:45:18 <sbrg> if not, there's always r/haskell and haskell on SO
02:45:33 <zettablade> it's a terrible way to do gui programming, in my experience. But it's something I'm familiar with.
02:45:57 <dramforever> don't worry, explain what you want
02:50:25 <zettablade> I'm really look for a good way to build a gui. The background, characters, textbox, scrollbar, or whatever the visual novel calls for, could all be widgets that need to be laid out. The way scene2d works is that widgets are put in containers, and containers are also widgets. And there's a main scene that has a root container widget, which contains everything that needs to be rendered. Has anything like this been done with Haskell
02:50:52 <sbrg> aaah
02:51:09 <sbrg> so certain containers might 'stack' stuff while others might 'flow' it and so on?
02:52:34 <zettablade> yea, that's one way of looking at it.
02:54:39 <zettablade> Like, a scrolling text widget would get an area and some input events from it's parent widget, and then it would need to adjust according to the information it receives. But containers would need to pass on input and size constraints to children widgets. Or something like that.
02:58:22 <sbrg> zettablade: have yo looked at threepenny-gui?
03:02:46 <zettablade> I've looked at it a bit. From what I understand it uses DOM to do the dirty work that I want to do with Haskell. In a reddit post, he has said that it's very hard to accomplish what I'm thinking of. That is, a gui framework in just haskell. Can't find the post though, or I'd show you.
03:07:13 <zettablade> "In contrast, GUI widgets are about encapsulating some portion of that Graphics output and some portion of that Mouse input, and I for one do not have a clear idea of how to do this in an elegant way." https://www.reddit.com/r/haskell/comments/2kyr7x/a_functional_gui_library_built_from_ground_up/clq1ucj
03:07:20 <zettablade> found it
03:09:55 <greves> wow there's no GUI library for haskell?
03:09:59 <greves> that's surprising
03:12:36 * hackagebot socket 0.5.3.0 - A portable and extensible sockets library.  https://hackage.haskell.org/package/socket-0.5.3.0 (LarsPetersen)
03:22:57 <srhb> greves: There are plenty.
03:24:05 <greves> so what was that discussion about?
03:31:46 <fishburne> Do anyone here know how to use a production quality session manager with Spock web framework. I am looking at this page http://hackage.haskell.org/package/Spock-0.7.12.0/docs/Web-Spock-Shared.html#t:SessionCfg, and there is  an spc_load method for a SessionPersistCfg value. But it accepts no session id. So I am not sure how to implement it.
03:32:37 * hackagebot Spock 0.8.0.0 - Another Haskell web framework for rapid development  https://hackage.haskell.org/package/Spock-0.8.0.0 (AlexanderThiemann)
03:32:54 <fishburne> I have been building a web application with spock for the past 2 months and now It seems the framwork does not contain a production quality session manager. Please help..
03:40:17 <fishburne> Do anyone here know how to use a production quality session manager with Spock web framework. I am looking at this page http://hackage.haskell.org/package/Spock-0.7.12.0/docs/Web-Spock-Shared.html#t:SessionCfg, and there is  an spc_load method for a SessionPersistCfg value. But it accepts no session id. So I am not sure how to implement it.
03:40:19 <zalatovo> Is there a way I can "tie the knot" efficiently on the graph represented by testEnv in this code sample? http://lpaste.net/8734305910450552832
03:40:41 <zalatovo> basically I want to convert (1, Cons Int (Name 1)) into (1, fix $ \x -> Cons Int x)
03:41:28 <zalatovo> what I have right now works, but it's not a *truly* recursive data structure since it has to do a lookup every time it recurses
03:50:20 <zalatovo> I think that example I gave with fix might not be truly cyclic either, so substitute let self = Cons Int self in self for that
03:51:42 <fishburne> Do anyone here know how to use a production quality session manager with Spock web framework. I am looking at this page http://hackage.haskell.org/package/Spock-0.7.12.0/docs/Web-Spock-Shared.html#t:SessionCfg, and there is  an spc_load method for a SessionPersistCfg value. But it accepts no session id. So I am not sure how to implement it.
03:56:11 <zalatovo> fishburne: looks like spc_load returns an association list from SessionId to (UTCTime, a) to me. Have you looked at what's in the list returned by spc_load?
03:57:06 <srhb> That's a bit of an odd structure, an assoclist...
03:58:09 <fishburne> zalatovo: Oh. So it is supposed to return info contained in every live session?
04:00:01 <zalatovo> fishburne: not sure, seems like it would be inefficient to use a list for that
04:00:24 <fishburne> zalatovo: Exactly. It would be madness!
04:00:28 <concept> are all functors in Haskell type constructors ? in other words is there any example of functor that is not a type constructor ?
04:00:58 <zalatovo> fishburne: found this comment on a function using SessionPersistCfg: -- | Simple session persisting configuration. DO NOT USE IN PRODUCTION
04:00:58 <srhb> concept: Functors must have kind * -> *, yes
04:01:08 <zalatovo> fishburne: https://github.com/agrafix/Spock/blob/master/src/Web/Spock/Shared.hs at the bottom
04:02:32 <fishburne> zalatovo: yes. I was using it. But the comment says that it should not be used in production. 
04:02:37 <srhb> concept: This is fundamental to fmap. (because the `f a` means apply the Functor constructor to a, and the resulting type must be of kind *)
04:04:13 <concept> srhb: well yes, my confusion comes from this, if a functor is mapping between categories, since in Haskell we are in the Hask category how is functor a mapping between categories, what makes it different from a morphis ?
04:04:29 <srhb> concept: Functors in Haskell are endofunctors.
04:04:35 <srhb> concept: ie. Hask -> Hask
04:05:49 <hunteriam> I think of it like one 'subset' of the category is being mapped onto another 'subset'
04:06:06 <concept> srhb: so it's Not possible to have a functor from Category to Another in Haskell. so in Haskell , a functor is a more of anything that can be mapped over.. I think this is more useful because we can't get out of Hask
04:07:11 <srhb> concept: Yes, I think. I'm not very CT-proficient.
04:11:06 <ptcek> thanks for syntax highlighting on hackage :)
04:12:05 <StatelessCat> hey, when I try to install hlint using cabal, I'm getting a dependency problem about `haskell-src-exts` that cant build because of `happy` (https://paste.kde.org/pdjtmm8hy). I have properly set my $PATH with $HOME/.cabal/bin so I think it's good for this point. Any pointer please ?
04:13:11 <zalatovo> StatelessCat: that sometimes happens to me, I just run cabal install happy separately and then run cabal install hlint again
04:13:35 <ptcek> zalatovo's solution works for me too
04:16:36 <StatelessCat> zalatovo: no need to remove something before ?
04:17:37 <zalatovo> StatelessCat: nope, usually I just ran that after my previous install stopped with an error
04:23:11 <fishburne> zalatovo: sorry to interrupt. But do you have any suggestion for me..
04:25:15 <zalatovo> fishburne: I haven't done much web programming in Haskell so don't know what would be the best solution. But I do know that I would avoid using association lists in production :)
04:27:06 <StatelessCat> zalatovo: even if i install just `happy`, i got the same problem ``There are files missing in the `mtl-2.2.1@mtl_6HevPxzlSPX058IyhMPnF5' package,...``
04:27:39 * hackagebot vcsgui 0.1.3.0 - GUI library for source code management systems  https://hackage.haskell.org/package/vcsgui-0.1.3.0 (HamishMackenzie)
04:27:57 <bernd> ! http://lpaste.net/13833n I ran into the that problem using class constraints on a return type. I googled for terms like that and the error message, but didn't find anything. The message seems to come up in different contexts. How do I interpret it in this context?
04:28:02 <zalatovo> StatelessCat: you could try deleting ~/.ghc and ~/.cabal which will delete all cabal packages
04:29:05 <StatelessCat> k
04:29:07 <dramforever> looks suitable for local development purposes
04:30:10 <dramforever> bernd: your link doesn't work
04:30:11 <bernd> sry correct link: http://lpaste.net/138333
04:30:46 <dramforever> okay 138133
04:30:47 <fishburne> zalatovo: Oh. No problem. I will ask around somemore..
04:32:15 <dramforever> bernd: the user of the function gets to decide what type variables are specialized to
04:32:39 * hackagebot ghcjs-dom 0.2.1.0 - DOM library that supports both GHCJS and WebKitGTK  https://hackage.haskell.org/package/ghcjs-dom-0.2.1.0 (HamishMackenzie)
04:33:10 <dramforever> so you don't know what to return, just it's in the Bar typeclass
04:33:17 <dramforever> do you get it?
04:34:16 <bernd> hm. how would I write a function of which I don't know what to return?
04:34:50 <StatelessCat> zalatovo: I try to remove $HOME/.cabal. No succes, I cannot install any package. I'm thinking I have problem with my GHC installation. https://paste.kde.org/pdjvbj7yg here is my logs when I do `cabal install happy` and `cabal install ghc-mod` just after `rm -r $HOME/.cabal` and `cabal update`
04:34:59 <dramforever> bernd: you can use methods in the Bar typeclass
04:35:14 <dramforever> but you don't know what the concrete type is
04:35:55 <StatelessCat> ''Could not find module Control.Monad.Cunt '' for example can mean that my Haskell install is incomplete ?
04:36:11 <dramforever> you mean Cont
04:36:12 <bernd> oh ok i try to come up with an example to see if I got it
04:36:43 <zalatovo> StatelessCat: have you tried running the suggested command `ghc-pkg check`?
04:37:19 <srhb> StatelessCat: Yes, it looks like your global packages are broken. You can try reinstalling mtl manually, but it might be wiser to simply start anew. have you perchance messed with your global package db?
04:37:49 <StatelessCat> zalatovo: yes, when i try this, I got ***a lot*** of `cannot find any of`
04:39:01 <StatelessCat> srhb: the only mistake I remember I have done is trying `cabal install hlint --global` (yes, yes, I was hoping cabal works like npm or bower :/ )
04:39:08 <srhb> Hehe.
04:39:27 <srhb> StatelessCat: Anyway, I think the quickest option now is to simply get rid of eeeverything Haskelly and start over.
04:40:04 <StatelessCat> What i installed weight ~943Mo : https://www.archlinux.org/packages/extra/x86_64/ghc/ , thats not enought ? :) :)
04:40:29 <StatelessCat> I really think there is a problem with this archlinux package
04:40:36 <srhb> No idea if there is.
04:41:00 <StatelessCat> 943Mo for some libs for one programming langage, event considering the haskell linkage it's huge
04:44:10 <zalatovo> StatelessCat: My GHC package (from haskell-core instead of normal Arch repos) is also 900MB
04:45:23 <StatelessCat> ok, what is the interest to use GHC package from haskell-core instead of normal arch repo ? 
04:46:11 <zalatovo> StatelessCat: haskell-core has a lot of Haskell packages prebuilt so you don't have to install them using Cabal
04:46:38 <zalatovo> StatelessCat: installing hlint from that is just a matter of pacman -S haskell-hlint :)
04:46:53 <zalatovo> StatelessCat: https://wiki.archlinux.org/index.php/ArchHaskell#.5Bhaskell-core.5D
04:47:35 <StatelessCat> my apologize, my problem was not about GHC or config, but because i did not do ` cabal sandbox init` on $HOME. For me I was obvious that `cabal sandbox init` is when installing dependecies for a specific project, not when wanting to install globally. I should read more attentivly the documentation.
04:48:13 <StatelessCat> zalatovo: thanks for the tip
04:48:19 <srhb> StatelessCat: No, you're correct in that interpretation
04:48:31 <StatelessCat> not* ?
04:48:41 <srhb> Initializing a sandbox in your homedir will cause cabal-install to install packages to there if you're in your homedir.
04:48:55 <StatelessCat> hum
04:49:25 <bernd> dramforever: http://lpaste.net/138338 that's the example I came up with for a correct use of class constraints on return types
04:49:34 <StatelessCat> srhb: and they are not usable from any other directorys:/
04:49:46 <dramforever> horray =)
04:50:01 <srhb> StatelessCat: Well, they will not be installed "user-globally"
04:50:04 <dramforever> um...question
04:50:14 <srhb> StatelessCat: ie. in ~/.ghc and ~/.cabal -- I can never remember what goes where.
04:50:15 <dramforever> what's that "a" argument for?
04:50:25 <dramforever> you literally can't do anything with it
04:50:36 <dramforever> bernd: ^
04:50:50 <dramforever> hmm...almost perfectly interleaved messages
04:51:17 <bernd> yeah true. I can't use such an argument 
04:52:59 <srhb> bernd: I realize this is probably just toying around with types, but a "what are you REALLY trying to do" question might arrive very soon. :-)
04:53:21 <bernd> yes I'm trying to formulate it x) 
04:53:50 <bernd> I think it's not clear from my first paste which behaviour I want
04:54:23 <srhb> Nope.
04:54:27 <srhb> Well,  not to me anyway.
04:54:50 <dramforever> bernd: btw are you *really* just playing with types?
04:55:37 <bernd> now I'm not, I just tried to isolate the problem
04:55:43 <bernd> no*
04:58:11 <bernd> I kind of want: func :: (Foo f, Bar b) => f -> b as a method of class Foo. And each instance of Foo returns some specified instance of Bar
04:59:17 <srhb> Why not FooToBar f b ?
04:59:44 <srhb> Or FooToBar f | f -> b
04:59:47 <srhb> Or whatever that syntax is
04:59:59 <mauke> fundeps is FooToBar f b | f -> b
05:00:06 <srhb> Thanks mauke 
05:00:14 <srhb> That's what I meant.
05:00:20 <mauke> can't remember asstypes
05:00:30 <srhb> bernd: It sounds like you want FunDeps.
05:00:34 <StatelessCat> zalatovo: you were right, haskell-core is really awesome (I want the same for JavaScript NPM packages ^^). Hlint is installed :). But unfortunatly they don't have ghc-mod in haskell-core
05:00:36 <merijn> "class Convert a b | a -> b where convert :: a -> b", but that's unlikely to work
05:00:48 <bernd> ok thanks I'll have a look at that
05:00:53 <merijn> Any multiparam class like convert is almost certainly going to end in tears
05:00:54 <StatelessCat> zalatovo: do you use haskell-core preceding extra or above in pacman.conf ?
05:01:00 <merijn> Better of just using datatypes and functions
05:01:58 <mauke> class FooToBar f where { type Bar f :: *; ... }
05:02:13 <mauke> func :: (FooToBar f) => f -> Bar f
05:02:35 <srhb> merijn: can you elaborate on the "end in tears" bit?
05:03:06 <merijn> srhb: Inference will suck, you'll have to write lots of boilerplate
05:03:12 * srhb nods
05:03:36 <merijn> srhb: In the end just defining "data Converter a b = Converter { converWith :: a -> b }" will be much nicer
05:03:44 <srhb> Yeah.
05:03:49 <merijn> Then you'll have "convertWith :: Converter a b -> a -> b"
05:03:58 <srhb> Yes, that seems straightforward. :)
05:04:13 <srhb> It's just that the fundep method sounds so much like an exact translation of the specification. :-)
05:04:20 <merijn> Basically, this is another instance of the "I'm used to OO" antipattern that the existential antipattern is a form of :)
05:04:26 <srhb> Yes.
05:05:46 <zalatovo> StatelessCat: before extra, because you will get the wrong GHC otherwise. Also don't forget to remove all Haskell packages you have from [core] and [community]
05:06:12 <zalatovo> StatelessCat: pacman -Rncs ghc should remove ghc and everything that depends on it, but make sure it doesn't remove anything you don't want to remove :)
05:06:50 <bernd> thank you all alot for your suggestions! It's very likely that I fell into an antipattern. Will work through it later
05:10:45 <fishburne> Do anyone here know how to use a production quality session manager with Spock web framework. I am looking at this page http://hackage.haskell.org/package/Spock-0.7.12.0/docs/Web-Spock-Shared.html#t:SessionCfg, and there is  an spc_load method for a SessionPersistCfg value. But it accepts no session id. So I am not sure how to implement it.
05:11:06 <zalatovo> StatelessCat: ghc-mod used to be in haskell-core, but the version currently on Hackage doesn't build with GHC 7.10.2 I think. If you want ghc-mod it's best to clone it from Git and build it in a cabal sandbox
05:13:41 <Phillemann> I have a StateT over the monad "Curses". There is a function "getEvent" defined on this Curses monad which I want to call inside this StateT. Do I have to lift getEvent to StateT?
05:13:53 <mauke> yes
05:14:05 <Phillemann> Problem may be (or is): Curses is not an instance of MonadTrans
05:14:14 <mauke> :t lift
05:14:15 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
05:14:17 <dramforever> but StateT is
05:14:20 <mauke> irrelevant
05:14:21 <Phillemann> Ahhh, of course
05:14:51 <mauke> also, kinds: no instance of Monad is an instance of MonadTrans
05:15:53 <nschoe> Hi guys, I'm trying to install ghc-mod (into a sandbox), and I've got this error: http://lpaste.net/138341
05:16:08 <nschoe> Any clue what's wrong ? It ends with the typical ExitFailure 1
05:16:31 <Phillemann> Hm, I suppose the problem is that I don't have a StateT but a newtype around that, then.
05:17:03 <mauke> write a liftCurse function
05:17:06 <dramforever> nschoe: "typical ExitFailure 1" no, read the error message preceding it
05:17:16 <dramforever> it must be a ghc-mod bug
05:17:23 * dramforever has encountered the same problem
05:17:53 <nschoe> dramforever, well it's "failed during the building phase indeed"
05:18:10 <dramforever> but there's the error message
05:18:13 <nschoe> dreamdust, ah! So did you manage to install it eventually ?
05:18:20 <dramforever> wait compiler errormessage
05:18:27 <zalatovo> nschoe: the version of ghc-mod currently on Hackage doesn't build with some versions of GHC I think
05:18:30 <dramforever> nschoe: not yet
05:18:41 <zalatovo> nschoe: try cloning ghc-mod from Github
05:18:45 <dramforever> but I think I can try to fix that bug myself
05:19:04 <dramforever> or, as mentioned by zalatovo, get the Github version
05:19:08 <nschoe> zalatovo, does it have a chance to work if I manually specify an olde rversion ?
05:19:22 <dramforever> I guess so
05:19:38 <nschoe> Okay, I'll try and keep you up for information
05:20:34 <dramforever> no...
05:20:37 * dramforever is not ready
05:20:38 <zalatovo> nschoe: dramforever: also see this https://github.com/kazu-yamamoto/ghc-mod/issues/437
05:20:44 <Phillemann> mauke: Ok, it's just MyStateTWrapper . lift. Great, thanks for the help :)
05:20:47 <nschoe> zalatovo, thx
05:20:59 <safinaskar> galois_dmwit: thanks for answer yesterday
05:23:05 <safinaskar> is this to break $(...) to several lines?
05:23:12 <safinaskar> i try to write $(return [
05:23:18 <safinaskar> ]), but this doesn't compile
05:23:50 <safinaskar> i have ghc 7.8.3
05:23:51 <dramforever> zalatovo: looks relevant and fixed in git
05:23:56 <dramforever> thanks for that information
05:24:11 <safinaskar> *is this possible
05:26:32 <nschoe> dramforever, so you clones Daniel's git version ?
05:26:40 <nschoe> (I'm curently doing it, slow connection unfortunately)
05:29:58 <zalatovo> nschoe: dramforever: could be that the issue I linked is not actually the one you have, but cloning kazu-yamamoto/ghc-mod and compiling in sandbox with GHC 7.10.2 just works for me
05:30:12 <zalatovo> especially since the issue is from january
05:31:36 <nschoe> zalatovo, hum okay. Reading the comment, there was one from DanielG saying that he "revoled the issue" in his fork. This is whay I cloned his repo.
05:31:42 <nschoe> It's compiling as we speak.
05:32:43 * dramforever is going to try kazu-yamamoto/ghc-mod
05:32:58 <zalatovo> nschoe: DanielG's branch of ghc-mod is identical to kazu-yamamoto atm
05:33:17 <nschoe> zalatovo, ok. Thx for your help.
05:33:21 <dramforever> hmm...turns out that I already cloned one earlier
05:33:25 * dramforever git pull
05:33:50 <dramforever> do I try master?
05:34:06 <zalatovo> dramforever: yep mine is built from master
05:34:32 <zalatovo> I did change the version from 0 to 5.2.1.2 in ghc-mod.cabal, because some tools get confused otherwise
05:35:03 <zalatovo> and afterwards I just copied ghc-mod and ghc-modi executables to ~/.cabal/bin and deleted the sandbox
05:35:48 <nschoe> zalatovo, I suppose it would work equally fine to add /path/to/cabal/sandbox/dist/ghc-mod to the PATH, right ?
05:36:04 <dramforever> who needs that sandbox...
05:36:14 <nschoe> For information, the cloned version installed okay
05:36:29 <nschoe> dramforever, well I don't like to copy the executables to my ~/.cabal/bin
05:37:02 * dramforever cabal update because the current index doesn't have the new version of cabal-helper
05:37:21 <nschoe> makes it less convenient to update the packages
05:37:35 <dramforever> well,
05:37:51 <dramforever> if the fixed version got released, then cabal install will overwrite it
05:38:37 <nschoe> dramforever, well *if* you install globally.
05:38:44 <zipper> Where can I find the documentation for GHC as a library. For example in this case I want to read about `setTargets`
05:38:45 <dramforever> ok
05:39:04 <nschoe> But I was told never to do that. The way I work (I was taught), was to build everything in a sandbox
05:45:50 <dramforever> horray
05:45:53 <RageYL> hi
05:45:56 <dramforever> ghc-mod installed correctly
05:46:21 <RageYL> i've begin to learn haskell yesterday and i'm trying to write a small program: https://gist.github.com/anonymous/542759fd331d57451ed3
05:46:32 <RageYL> can anyone tell me how to handle the IO bool ?
05:46:59 <srhb> RageYL: Just like with the IO Integer
05:47:15 <srhb> do { theBool <- roulette ...
05:47:19 <srhb> now theBool :: Bool
05:47:41 <RageYL> oh !
05:47:46 <RageYL> it works
05:47:51 <RageYL> thanks =)
05:47:54 <srhb> RageYL: That's basically what do syntax is for. :-) Chaining actions like that.
05:48:16 <RageYL> i do not need to do the thebool :: Bool is it better to add it everytime ?
05:48:50 <srhb> RageYL: Do you mean whether it's necessary to add the type annotation?
05:48:56 <srhb> RageYL: It's not.
05:49:03 <RageYL> i mean i've tried to not to add it and the program was working
05:49:08 <RageYL> yep ok =)
05:49:13 <RageYL> thanks =)
05:49:22 <srhb> RageYL: The reason it's necessary for randomRIO is that it can have any number of types.
05:49:47 <srhb> (It may actually default to Integer in your case, not sure.)
05:50:27 <RageYL> there is no way to put the 'success <- roulette between case of ?
05:50:41 <RageYL> like assignment in c ?
05:50:56 <srhb> RageYL: No. This isn't really assignment
05:50:57 <bq_> is category a generalization of group?
05:51:06 <RageYL> ok
05:51:30 <Intolerable> RageYL: you might want to take a look at LambdaCase though
05:51:32 <srhb> RageYL: do { bar <- foo; case bar ... is really syntax sugar for foo >>= \bar -> case bar ...
05:51:55 <Intolerable> it lets you do action >>= \case { Just x -> something; Nothing -> somethingElse }
05:52:04 <RageYL> ok
05:52:13 <RageYL> as i'm learning i haven't seen yet >>=
05:52:17 <RageYL> but i will take a look ;)
05:52:19 <srhb> :)
05:52:31 <srhb> :t (>>=)
05:52:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:52:41 <bernd> bq_: Are you familiar with universal algebras?
05:54:12 <bernd> bq_: sry I think it's called algebraic structure in english
05:54:58 <bq_> bernd: yes i learned 'algebraic structure'
05:55:31 <bq_> bernd: it is about group, ring, field, lattice, future, etc
05:55:47 <bernd> bq_: so you know a group is a algebraic structure because...?
05:57:12 <bq_> bernd: i don't understand your question
05:57:52 <bernd> bq_: a group is an algebraic structure right?
05:58:22 <fishburne> Do anyone here know how to use a production quality session manager with Spock web framework. I am looking at this page http://hackage.haskell.org/package/Spock-0.7.12.0/docs/Web-Spock-Shared.html#t:SessionCfg, and there is  an spc_load method for a SessionPersistCfg value. But it accepts no session id. So I am not sure how to implement it.
05:58:27 <bq_> bernd: yes, a group is a set of elements with an operation satisfying closure, associative, identity, and invertible
05:58:48 <bernd> ok and do you know the definition of a category?
06:02:12 <bq_> bernd: what is its definition exactly? category has: 1) a set of objects, 2) mapping, 3) a binary operation. thus, i say it seems 'category seems a generalization of group'
06:03:27 <bq_> bernd: i didn't learn category.
06:03:32 <bernd> bq_: I think your 1. point is not quite correct. We have a *class* of objects.
06:05:34 <fishburne> Has anyone here used Spock webframework to build a web application?
06:05:37 <bq_> bernd: does category have to be closure or associative?
06:06:12 <bq_> bernd: what is diff between *class* and *set*?
06:07:38 <zalatovo> fishburne: have you looked at this package: https://hackage.haskell.org/package/wai-session ?
06:08:44 <bernd> bq_: I think of *class* as a more general *set*. Some restrictions are not imposed on *class*. You can have the class of all sets, but not the set of all sets.
06:10:56 <bq_> bernd: i find category theory is pretty much similar to group theory in that how they are presented and things abstracted.
06:12:29 <bernd> bq_: Hm, yes I never saw it that way. The way I learned it was on a different level than groups. We talked about the category of groups. So we used category a bit to reason about groups in general.
06:13:05 <fishburne> zalatovo: Yes. But i am not sure how it is supposed to be used with Spock.
06:15:06 <zalatovo> fishburne: Spock has a function called middleware :: Middleware -> SpockT ... and you can make a Middleware using withSession :: ... -> Middleware from wai-session
06:16:16 <bernd> bq_: I'm a bit confused now too x). Let's try interpreting a group as a category. Taking set of elements as the class of objects. But what would you than choose as the class of morphisms?
06:17:09 <fishburne> zalatovo: Yes. sounds promising..Will try that. Thank you!
06:17:36 <fishburne> zalatovo ++
06:18:40 <bq_> bernd: i guess morphism is mapping or 'operation' in group group theory
06:19:58 <bq_> bernd: the extra in category is the 'binary operation'
06:21:32 <bernd> bq_: hm the binary operation is in the group context, but you need morphisms from element to element and especially an identity
06:21:41 <fishburne> zalatovo++
06:22:23 <cow_2001> (.) :: cat a b -> cat b c -> cat a b -- D:
06:22:43 <cow_2001> it is defined somewhere in netwire
06:22:53 <cow_2001> or at least reexported
06:22:59 <zalatovo> fishburne: hehe guess that doesn't work here
06:23:06 <bennofs> cow_2001: it's defined in Control.Category, which resides in `base`
06:23:32 <cow_2001> :|
06:23:53 <bennofs> :t (Control.Category..) `asAppliedTo` const undefined 
06:23:54 <lambdabot> (b -> c) -> (a -> b) -> a -> c
06:23:55 <bq_> bernd: that is not what I perceived. i guess the binary operation should be functor which is morphism from category of groups to category of groups.
06:24:00 <cow_2001> how do i make lambdabot.... oh
06:24:33 <cow_2001> but what about the general case?
06:24:36 <fishburne> zalatovo: :)
06:24:42 <cow_2001> :t (Control.Category..)
06:24:43 <lambdabot> forall (k :: BOX) (cat :: k -> k -> *) (b :: k) (c :: k) (a :: k). Category cat => cat b c -> cat a b -> cat a c
06:24:46 <cow_2001> woah.
06:27:43 <bernd> bq_: hm a functor takes an object of a category and returns an object of another category. An binary operation takes 2 elements of a algebraic structure and returns 1 element in that same structure. So I don't see how a binary operation could be a Functor.
06:29:16 <bq_> bernd: i am looking at category wikipedia. it blows my mind. i am trying to understand functor, applicative, monad
06:31:15 <bernd> bq_: Back to your original question: I don't see a category as a generalization of a group. Because a group is an algebraic structure which needs a set plus operations. A category is not an algebraic structure according to that definition, because it's not necessary defined on a set but a class. On the other hand I think one can interpret a group as a category.
06:31:25 <bennofs> bq_: general functor or Functor as it is implemented in Haskell?
06:32:13 <alynn> there is a category of groups
06:32:29 <alynn> but a group is more analogous to a groupoid than a category, a category is analogous to a monoid
06:33:28 <bennofs> yeah, groups require that a <> b = b <> a, which is not the case for categories
06:33:38 <bennofs> eh sorry, scratch that
06:33:45 <bennofs> I meant that groups require inverses :|
06:38:35 <zipper> Where does stack install packages?
06:42:45 * hackagebot irc-fun-messages 0.1.0.0 - Types and functions for working with the IRC protocol.  https://hackage.haskell.org/package/irc-fun-messages-0.1.0.0 (akrasner)
06:50:34 <Tehnix> Has +c been removed for ghci in ghc 7.10? I'm trying to do :set +c in my .ghci but it says `ghci unknown option: 'c'` :/
06:50:58 <bennofs> Tehnix: what does +c do?
06:51:44 <Tehnix> bennofs: It should "The :set +c command: collect information about modules after they've been loaded, and remember it between loads (including failed ones)." from https://github.com/chrisdone/ghci-ng#features
06:52:24 <Tehnix> Ooooohhhh, I might have been misunderstanding that package. It seems to be an alternative ghci :O
06:52:26 <bennofs> Tehnix: well, what you've quoted is an additional feature of GHCing
06:52:33 <bennofs> ghci-ng*
06:53:23 <Tehnix> Silly me, guess it was a case of ask the duck ^_^
06:55:11 <zipper> What should ghc package path look like when using stack?
06:57:45 * hackagebot irc-fun-client 0.1.0.0 - Another library for writing IRC clients.  https://hackage.haskell.org/package/irc-fun-client-0.1.0.0 (akrasner)
07:00:46 <RageYL> Intolerable: i've looked about >>= and >>: but cannot make \case working: https://gist.github.com/anonymous/07e450ba021eae6b48ac, if you could take a look ;)
07:01:53 <bennofs> RageYL: do you compile with -XLambdaCase?
07:02:03 <RageYL> no
07:02:06 <bennofs> RageYL: (or add {-# LANGUAGE LambdaCase #-} to the top of the file)
07:02:22 <bennofs> RageYL: you need to this since that case syntax is a GHC extension and not part of standard Haskell
07:02:35 <RageYL> big thanks
07:02:52 <RageYL> when i read the doc i thought it was enable by default
07:03:09 <bennofs> RageYL: which one?
07:03:11 <bennofs> (doc)
07:03:26 <RageYL> stackoverflow question ^^
07:03:32 <RageYL> not doc ^^
07:03:40 <dramforever> hi, a question about STM
07:03:41 <bennofs> RageYL: link to question?
07:03:47 <RageYL> http://stackoverflow.com/questions/3416475/haskell-guards-on-lambda-functions
07:03:49 <bennofs> thanks
07:04:04 <RageYL> the talk about 'extension' but i thought it was enabled
07:04:16 <dramforever> *where* should I put those TVars? should I use nested TVars?
07:04:36 <dramforever> for example I'm writing a chatting server like irc
07:05:33 <RageYL> bennofs: is it common to use these extensions ? or should i avoid them ?
07:05:45 <dramforever> I have data ServerState = ServerState { sClients :: TVar (M.Map Name Client), sChannels :: TVar (M.Map Name Channels) }
07:05:54 <bennofs> RageYL: it's quite common
07:06:02 <dramforever> I know that these two tvars are necessary
07:06:06 <RageYL> k =)
07:06:09 <zoug> hello, I'm trying to define my own typeclass and ghc isn't happy with the following instance : "instance MyTypeClass [Int] where" etc
07:06:14 <bennofs> RageYL: just look at this recent file of mine: https://github.com/bennofs/reflex-qml/blob/master/src/Reflex/QML/Prop.hs :D
07:06:27 <zipper> is a ghc package database a file?
07:06:36 <RageYL> indeed :D
07:06:38 <dramforever> wait I don't know if they are necessary
07:06:38 <bennofs> zipper: depends on GHC version
07:07:01 <zoug> I don't understand why, I'm following a course (cis194) and it's written exactly like this
07:07:02 <dramforever> because whenever I touch those two maps, I "lock" them
07:07:07 <bennofs> zipper: older GHC versions supported flat-file package databases, but newer versions (I think GHC 7.10 was the first to drop support for flat file) use a directory
07:07:18 <zoug> it says somethingabout "FlexibleInstances" that I don't get
07:07:24 <dramforever> zoug: can you give us the full code?
07:07:54 <dramforever> so...any suggestions?
07:08:17 <bennofs> zoug: the Haskell standard defines that typeclass instances must be of the form    instance ... => C (T a1 a2 ... aN) where all of a1, a2, ... aN are type variables
07:08:44 <bennofs> zoug: this condition is not fullfiled in your example, since Int (takes the place of a1 here) is not a type variable, but a concrete type
07:09:02 <bennofs> zoug: (you can write as [Int] as [] Int to make this more clear)
07:09:20 <dramforever> does anyone know much about stm?
07:09:32 <zoug> bennofs: okey, should I use something like Num instead?
07:09:38 <dramforever> hmm hmm...wait a sec
07:09:45 <bennofs> zoug: there is a commonly used GHC extension FlexibleInstances which allows this though. You can make your code compile by adding {-# LANGUAGE FlexibleInstances #-} to the top of your file 
07:09:53 <dramforever> zoug: I would suggest using FlexibleInstances
07:09:59 <dramforever> since it's pretty safe
07:10:05 <dramforever> IIUC
07:10:13 <dramforever> wait I know the solution
07:10:26 <zoug> okey! thanks for the help!
07:11:00 <bennofs> dramforever: what is your problem with stm exactly?
07:11:03 <dramforever> only when channels are created/destroyed or clients connect/disconnect, those maps are modified
07:11:15 <dramforever> bennofs: I was worried about nested TVars
07:11:22 <bennofs> dramforever: why?
07:11:41 <dramforever> not anymore...reading TVars isn't a problem
07:12:07 <dramforever> and TVars themselves don't change, so the parent Tvars aren't "locked"
07:12:39 <dramforever> bennofs: oh I still didn't explain my question, here it i
07:12:41 <dramforever> is
07:12:46 * hackagebot irc-fun-bot 0.1.0.0 - Very simple library for writing fun IRC bots.  https://hackage.haskell.org/package/irc-fun-bot-0.1.0.0 (akrasner)
07:13:16 <dramforever> If we nest two TVars, will the outer TVar get "locked" if the inner is modified?
07:13:26 <dramforever> and I came to an answer: no
07:14:01 <bennofs> dramforever: what do you mean by "locked"? STM has no concept of something being locked AFAIK
07:14:21 <dramforever> sure, I mean say we have something like this:
07:14:26 <zoug> bennofs: if I stay with the standard though, shouldn't "instance Num a => [a] where" cut it?
07:14:35 <dramforever> TVar (Map String (TVar Data))
07:14:51 <zoug> I mean "instance Num a => MyTypeClass [a] where"
07:14:53 <bennofs> zoug: yes, that should work. But then you cannot make a different instance for [Double] (not sure if you want to do that)
07:15:09 <zoug> yes ok!
07:15:10 <dramforever> a while ago I was concerned that two threads cannot modify the Data in the Map concurrently
07:15:11 <cow_2001> there are three mkGen* :D
07:15:19 <dramforever> it turns out that it's not the case
07:15:21 <zoug> thanks :) it's pretty clear now :p
07:16:10 <dramforever> bennofs: IIRC some TVar were touched externally during a transaction, the transaction will retry
07:16:12 <dramforever> yes?
07:16:21 <dramforever> s/some/if some
07:16:33 <dramforever> screw it
07:16:36 <bennofs> dramforever: When I reason with code using STM, I use the following model: the transaction will only execute if all TVars which have read stayed at the same value for the whole transaction
07:16:50 <dramforever> oh sure that's pretty much what I mean
07:17:11 <dramforever> anyway...no more worries =P
07:18:44 <cow_2001> okay, i don't get mkGen, but i do kinda sorta get mkGen_.
07:19:02 <cow_2001> :t Control.Wire.Core.mkGen
07:19:03 <lambdabot> Not in scope: ‘Control.Wire.Core.mkGen’
07:19:06 <cow_2001> :|
07:19:35 <cow_2001> :m + Control.Wire.Core
07:19:39 <bennofs> cow_2001: I have missed your question. Do you want to know what mkGen does?
07:19:45 <bennofs> @let import Control.Wire.Core
07:19:45 <lambdabot>  .L.hs:62:1:
07:19:45 <lambdabot>      Failed to load interface for ‘Control.Wire.Core’
07:19:45 <lambdabot>      Use -v to see a list of the files searched for.
07:19:50 <cow_2001> woah!
07:19:54 <bennofs> ghci doesn't have netwire installed
07:19:57 <cow_2001> ah
07:19:59 <bennofs> s/ghci/lambdabot
07:20:39 <StatelessCat> zalatovo, srhb, thanks, with your suggestions i figure out how to install GHC, cabal-install, jhint, ghc-mod to start to work with Haskell that is a new langage to me :)
07:20:52 <srhb> StatelessCat: Have fun! :-)
07:21:10 <srhb> StatelessCat: There's also #haskell-beginners if that's interesting to you :)
07:21:31 <StatelessCat> srhb: great idea :)
07:23:24 <dramforever> stupid ghc-mod...
07:23:46 <dramforever> it thinks that it's compiled with ghc 7.10.1, whereas obviously I have 7.10.2
07:25:04 <bennofs> cow_2001: so, Wires are like automatas: at any time, you can give them an input, and they will give you an output (b) or inhibit (e). Now, you can model this as (a -> m (Either e b)) (where m is used so that the Wire can also perform monadic actions to produce the output). There is a problem with this though: the step function can never change, so given the same input, the wire will always give the same
07:25:06 <bennofs> output
07:26:12 <dramforever> now I rebuilt it, and it seems to work
07:26:38 <bennofs> cow_2001: to allow this "stepping" function to change, mkGen instead uses the signature (a -> m (Either e b, Wire ...)), which allows the step function to return a new Wire which will replace this Wire on the next step. So the step function can "change" the Wire itself
07:28:52 <cow_2001> reading this great post. http://todayincode.tumblr.com/post/96914679355/almost-a-netwire-5-tutorial
07:32:24 <bennofs> cow_2001: https://ocharles.org.uk/blog/posts/2013-08-01-getting-started-with-netwire-and-sdl.html is also excellent, although I haven't checked whether it's updated to netwire 5 :/ (but it covers automation arrows, which are still used as underlying abstraction in netwire)
07:34:58 <cow_2001> bennofs: i'm trying to find the most current material
07:36:38 <cow_2001> bennofs: thanks for the explanation!
07:39:33 <Gurkenglas> Is Data.Array better than Data.Vector when (Int, Int) is the Ix?
07:40:25 <Cale> Gurkenglas: Well, Data.Vector doesn't really use Ix, so I guess it would be a little bit nicer to write. "Better" is questionable.
07:40:55 <Gurkenglas> I vaguely remember reading on here that Data.Vector was "better" than Data.Array.
07:43:36 <safinaskar> how to write this program http://paste.debian.net/290625/ using {;} ?
07:43:44 <srhb>  /urlselect 
07:43:47 <srhb> Woops
07:44:27 <geekosaur> safinaskar, do { let { a = 3 }; return () }
07:44:43 <geekosaur> let also introduces layout but layout was disabled by the outer {}, so you need inner {}
07:45:03 <unit73e> Hi. Say I want to create a container to store registered users. How do I do that with immutable data?
07:45:23 <mauris> can someone give me an example of reads returning multiple results?
07:45:27 <mauris> :t reads
07:45:28 <Gurkenglas> Does x // y run in O(|x|) or O(|y|)?
07:45:29 <lambdabot> Read a => ReadS a
07:45:37 <Cale> unit73e: I dunno, Data.Map?
07:45:53 <lpaste_> geekosaur pasted “safiniskar: general form of let in do” at http://lpaste.net/138344
07:46:14 <unit73e> Cale, sure but the clients that login need to know where the current Data.Map is
07:46:21 <unit73e> right?
07:46:25 <Cale> unit73e: hm?
07:46:26 <bennofs> Gurkenglas: for lists? Probably O(|x| * |y|) worst case
07:46:30 <Cale> I don't know what your program is
07:46:35 <bennofs> :t (//)
07:46:36 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
07:46:39 <Cale> So it's hard to make recommendations
07:46:42 <bennofs> oh it's array
07:47:07 <Cale> Data.Map is a basic key/value store, with efficient insertion and lookup
07:47:18 <Cale> (and various other operations, like merging and such)
07:47:45 <Gurkenglas> Is Data.Map better than Data.Array when I want to make incremental modifications?
07:47:47 * hackagebot googlepolyline 0.1.0.0 - Google Polyline Encoder/Decoder  https://hackage.haskell.org/package/googlepolyline-0.1.0.0 (lorne)
07:47:52 <nshepperd> probably O(x + y) for an array, assuming it uses a mutable array under the hood
07:47:59 <Cale> Gurkenglas: Probably.
07:48:05 <bennofs> Gurkenglas: then it's O(|y| + |x|) I'd say, since the array must be copied (O(|x|)) and each write takes O(1), so O(|y|) for all writes
07:48:53 <Cale> Gurkenglas: UArray can be quite competitive in the small cases, just because even though you're "copying" the whole array to make your single modification, maybe that's fast because the array is tiny.
07:48:57 <mauris> does `reads` always just return a list containing 0 or 1 results for types in the Prelude?
07:49:24 <bennofs> Gurkenglas: if you only use the result of the incremental modification, I believe Data.Vector mentions in it's docs that it can optimise such an incremental modification as a mutable operation on the underlying array and eliminate the copy
07:49:59 <Cale> Gurkenglas: But also note that it's possible to define an array whose elements are determined lazily in terms of each other (like a spreadsheet) which avoids the need for some kinds of incremental modification altogether.
07:50:07 <unit73e> Cale, say its just a program that users login. When a user logins the system needs to know if the user is registered. I'd use a Map but the user logins the current Map must be known.
07:50:36 <Cale> unit73e: So?
07:50:40 <Cale> What's the problem?
07:51:32 <Cale> The part of the server responsible for logging someone in will presumably be a function of the Map of users.
07:51:49 <Cale> That Map can be different each time because the function's argument will be different
07:52:34 <Cale> I've got to run, sorry!
07:52:43 <unit73e> Cale, ok thanks
07:52:47 * hackagebot lexer-applicative 2.1.0.1 - Simple lexer based on applicative regular expressions  https://hackage.haskell.org/package/lexer-applicative-2.1.0.1 (RomanCheplyaka)
07:54:36 <Gurkenglas> Can arrays be zipped?
07:57:26 <nshepperd> possibly not, since it wouldn't be obvious how to line up the indices
07:57:42 <nshepperd> I don't see any zipWith operator in the package anyway
07:58:04 <Gurkenglas> Alright, I'll use Vector. Who needs coordinates anyway.
07:58:57 <nshepperd> huh, it doesn't provide imap either, how odd
07:59:20 <mauris> you mean ixmap?
08:00:43 <nshepperd> nah, imap :: (i -> a -> b) -> Array i a -> Array i b
08:01:05 <nshepperd> something that lets you use the index while mapping
08:01:15 <mauris> that would be useful, yeah
08:01:57 <nshepperd> Gurkenglas: you could use a vector of vectors, I suppose. or just do the coordinate conversions manually
08:02:01 <the_2nd> looking for the guy who wanted to help me with my auto-solve problem
08:02:42 <kalloc> hi
08:02:49 <kalloc> how wrong in this code http://pastebin.com/jREbMvk8 ?
08:04:02 <Welkin> what about Map (Double, Double) <something> for coordinates?
08:04:22 <kalloc> i mean what wrong :)
08:04:27 <srhb> kalloc: It's unclear what type "World" has
08:04:33 <srhb> kalloc: Because you're uding OverloadedStrings
08:04:38 <Gurkenglas> Can I make a data structure such that I can use parts of it before other parts of it have their values become available by future IO actions? (It would have to be made sure that those elements aren't accessed prematurely by some side.)
08:04:50 <srhb> kalloc: And printf is itself polymorphic over the type of its arguments
08:05:03 <srhb> kalloc: printf "..." ("World" :: String) for instance, would work.
08:05:33 <srhb> kalloc: By the way, these errors are easier to diagnose if you actually include the error message you get. 
08:05:39 <Welkin> Gurkenglas: isn't that how all lazy datastructures work?
08:05:51 <srhb> kalloc: And that error says that the type of "World" is ambiguous.
08:06:28 <Gurkenglas> It doesn't... feel like it. The IO is the problem. And yet it may be possible, so I'm asking
08:07:04 <nshepperd> Gurkenglas: I assume the IO is something side-effecting so you can't just use unsafePerformIO to make it lazy
08:08:13 <bennofs> Gurkenglas: that's not possible, except using unsafe functions
08:08:37 <bennofs> Gurkenglas: unsafeInterleaveIO would be the function that you'd need for this (the same function is also used to implement haskell's lazy IO)
08:08:47 <Gurkenglas> It's the game, IO does the turn information, and player actions may uncover the map. I want to evaluate my own version of the map as it becomes uncovered, but of course use the uncovered parts in the meantime.
08:08:58 <Gurkenglas> -the game+a game
08:10:39 <nshepperd> would it be terrible to make such player actions merely create a new map containing more information?
08:11:25 <nshepperd> instead of trying to alter the old map
08:11:43 <Gurkenglas> Probably not, but I thought it would be a good exercise to try and it might make everything nice.
08:12:01 <Gurkenglas> Probably not at the cost of unsafe* :P
08:12:14 <bennofs> Gurkenglas: if it's a Vector that you want to modify, you might be able to do this with lazy ST
08:12:39 <RageYL> i think there is something i don't understand with arguments, if someone can take a look: https://gist.github.com/anonymous/45e1c85a26f00cbb0eb4
08:13:02 <safinaskar> geekosaur: thanks
08:14:08 <safinaskar> geekosaur: and i am safinaskar
08:14:52 <bennofs> RageYL: well, connectTo doesn't take just any number type as an argument. It specifially requires that the second argument has the type PortNumber (so for example Int, which is also a Num, won't work)
08:15:36 <RageYL> yep but i use (PortNumber port) 
08:16:09 <RageYL> and using PortNumber (fromInteger port) works
08:16:29 <RageYL> so i thought if port was of the same type as the return type of fromInteger it would work
08:17:05 <bennofs> RageYL: ah, there is a difference between the return type of fromInteger port and the argument type of your function
08:18:15 <bennofs> RageYL: fromInteger port :: Num a => a means "fromInteger port" can be used in any place where a value is expected of a type that has a Num instance
08:18:50 <bennofs> RageYL: so for example, fromInteger port :: Int would be valid, but so would fromInteger port :: Integer  (because both types are an instance of Num)
08:19:00 <bennofs> s/are an instance of/have an instance for
08:19:23 <RageYL> i see
08:19:44 <RageYL> but if i pass an Integer to fromInteger it will return an Integer
08:19:51 <bennofs> RageYL: no
08:19:57 <bennofs> > fromInteger (3 :: Integer) :: Int
08:19:58 <lambdabot>  3
08:20:01 <bennofs> > fromInteger (3 :: Integer) :: Word
08:20:02 <lambdabot>  3
08:20:10 <bennofs> > fromInteger (3 :: Integer) :: Integer
08:20:12 <lambdabot>  3
08:20:32 <bennofs> you can select the return type that you want, as long as what you want has an instance for the Num typeclass
08:21:04 <RageYL> ok i see my mistake =)
08:21:20 <bennofs> RageYL: fromInteger will convert the integer that you passed it to any other type that has an instance for Num
08:21:37 <RageYL> and the compiler take care of passing the good argument to PortNumber
08:21:42 <Cale> unit73e: One more thing before I go: if your server is multithreaded and you want to update and read the Map of users from multiple threads (e.g. if there are connected clients which can modify it), you'll likely eventually want to work with IORef and/or MVar in some fashion.
08:21:54 <RageYL> s/argument/type
08:22:47 <bennofs> RageYL: the constructor PortNumber :: PortNumber -> PortID (attention: the two occurences of PortNumber here mean different things: the first occurrence refers to the PortNumber constructor of the type PortID, while the second occurrence is a type on it's own)
08:22:49 <Cale> unit73e: A really cool trick you can do as well is to not just pass an IORef or MVar around, but instead pass (readIORef r) and (writeIORef r) or similar to the parts of the code which need them, separately, which lets you control which parts of the code have read/write access to the Map.
08:23:21 <bennofs> RageYL: so in this case, the compiler while choose fromInteger port :: PortNumber, since it infers that it needs a value of type PortNumber at that place 
08:23:49 <Cale> unit73e: But regardless, the bit of your server which depends on the contents of the Map will probably still be a function of the current Map, it's just you'll read the current Map from the mutable reference immediately beforehand.
08:24:48 <bennofs> RageYL: now let's consider the second case. You have a function foo :: Num a => a -> X; foo a = ... and now you want to use 'a' in the function
08:25:34 <bennofs> RageYL: in this case, you cannot just use 'a :: Int' or 'a :: Integer' or 'a :: PortNumber' inside the function. You don't know the concrete type that 'a' has. All you know is that 'a' has an instance for Num.
08:26:23 <bennofs> RageYL: the function foo must work for any type 'a' that has an instance for Num, so it cannot make any other assumptions about 'a' other than that 'a' has a Num instance
08:27:53 <bennofs> RageYL: but if you now do PortNumber a, the compiler detects that PortNumber takes a value of type 'PortNumber' as an argument. But a can be any type which has a Num instance, not just PortNumber! That's why the compiler gives an error: "I expected a value of type PortNumber here, but instead you gave me a value of type 'a', for which I only know that it has a Num instance, nothing more"
08:28:46 <enetsee> Does anyone know if it is possible to write a `final-tagless` encoding of mutually recursive data types?
08:29:29 <RageYL> bennofs: ok i read it 3 times, i am 'almost' ok :D
08:30:48 <bennofs> RageYL: for another view, consider what happens when you use 'foo'. You can choose any type 'a' for which you want to use foo. For example, you could use 'foo' with the type 'foo :: Int -> X', but in that case, 'a' will not have type PortNumber! So it must be converted somehow, and cannot just used as a PortNumber inside of foo 
08:32:13 <RageYL> i see: instance Num PortNumber where
08:32:15 <RageYL>    fromInteger i = intToPortNumber (fromInteger i)
08:32:22 <RageYL> (in sources)
08:32:55 <bennofs> RageYL: yeah, that means that PortNumber knows how to construct itself from an Integer value
08:33:16 <RageYL> connect :: HostName -> Integer -> IO Handle
08:33:18 <RageYL> connect serv port = connectTo serv (PortNumber port)
08:33:20 <RageYL> so this should work
08:33:26 <RageYL> but it do not
08:33:37 <RageYL> as port is an Integer
08:33:43 <bennofs> RageYL: no. You need to call 'fromInteger :: Integer -> PortNumber', since PortNumber :: PortNumber -> PortID
08:33:59 <bennofs> RageYL: so 'PortNumber port' is ill typed (PortNumber vs Integer)
08:34:07 <RageYL> ah ok
08:34:28 <bennofs> RageYL: it's a bit confusing. The 'PortNumber' constructor does not give you a value of type PortNumber :)
08:34:44 <RageYL> ok :D
08:35:35 <RageYL> last one i hope :D
08:35:37 <RageYL> connect serv port = connectTo serv (PortNumber (fromInteger port))
08:35:39 <RageYL> connect serv port = connectTo serv (fromInteger port :: PortNumber)
08:36:28 <RageYL> what's the difference between the 2 ? the second return a portNumber from fromInteger
08:37:07 <RageYL> and the first create a PortNumber from a PortNumber return also by Pornumber ?
08:37:36 <bennofs> RageYL: well, PortNumber (as used in the first example) is a constructor of PortID   (data PortID = Service String | PortNumber PortNumber | UnixSocket String) 
08:37:45 <hpc> i don't think the second one will compile
08:37:54 <bennofs> RageYL: so 'PortNumber :: PortNumber -> PortID' doesn't create a PortNumber, but it creates a PortID
08:38:02 <RageYL> ok for this one
08:38:23 <hpc> also, PortNumber is an instance of Num, so you likely don't want fromInteger there
08:38:31 <hpc> (unless you do, in which case ignore that)
08:38:46 <RageYL> hpc: i juste wanted to get it working :D
08:38:55 <bennofs> RageYL: and the second one will not compile, because the second argument to connect must be a PortID, not a PortNumber 
08:39:05 <bennofs> s/connect/connectTo
08:39:35 <RageYL> ok
08:40:03 <RageYL> i will try to re-read and assimilate all of that. big thanks for your great explanation and your time ;)
08:40:21 <RageYL> it's hard to deal with this kind of stuff the first time :D
08:40:36 <bennofs> your welcome :) always great to see more people learning haskell
08:40:53 <RageYL> =)
08:40:56 <jsidfofo> Is there a way to combine route + handler into one object in servant?
08:41:42 <jsidfofo> The flow is a little strange... it seems that you define them separetely and then you have to manually combine them into Server and API in the correct order later
08:43:31 <jsidfofo> How do I pass parameters to subcommands in stack?
08:43:32 <RageYL> bennofs: and to end this is there shorter way to declare the PortNumber then ? 
08:43:35 <RageYL> connect :: HostName -> Integer -> IO Handle
08:43:37 <RageYL> connect serv port = connectTo serv (PortNumber (fromInteger port))
08:43:58 <jsidfofo> "stack ghci -v" passses the -v to stack not ghci -_-
08:44:30 <voidzero> and if you do
08:44:34 <voidzero> stack -- ghci -v 
08:44:36 <voidzero> ?
08:44:38 <srhb> jsidfofo: Isn't the usual approach foo -- -arg ?
08:44:40 <srhb> Yeah..
08:44:57 <voidzero> it's a convention to stop parsing after --
08:45:12 <jsidfofo> voidzero: same result it doesnt pass -v to ghci
08:45:25 <voidzero> sounds like worth filing a bug for then :)
08:45:43 <bennofs> RageYL: well, depending on your application, it might be possible to use "connect :: HostName -> PortNumber -> IO Handle" (I'm sure you can find the definition for this yourself :=)). Then, instead of working with Integers in your program, you just directly work with PortNumbers (since PortNumber has a Num instance, you can write 1 :: PortNumber just as you can write 1 :: Integer)
08:46:19 <RageYL> ok =)
08:46:20 <bennofs> jsidfofo: have you tried stack ghci -- -v ?
08:46:47 <jsidfofo> bennofs: yes, in that case ghci is started without any options at all
08:47:27 <fishburne> zalatovo: ping!
08:47:43 <bennofs> zalatovo: 
08:47:51 <bennofs> oops
08:48:06 <aib> fromInteger's type, "Integer -> a" is... weird. How do I express this; it's polymorphic on its return type without taking a [dependant/parent/compatible?] type as a parameter. What's the phrase?
08:48:18 <aib> or is it simply overloaded?
08:48:36 <jsidfofo> is there a way to combine wai's Applications ?
08:48:39 <fishburne> zalatovo: https://github.com/agrafix/Spock/issues/43 (regarding the session issue with Spock)
08:49:16 <monochrom> aib: we simply say "polymorphic on return type".
08:49:19 <bennofs> aib: yeah, it's just return-type polymorphism (overloading based on return type is not possible in many languages that have overloading)
08:50:04 <monochrom> and we don't use that phrase on "a -> a". it's alright.
08:52:49 * hackagebot hsqml-datamodel 0.1.0.0 - HsQML (Qt5) data model.  https://hackage.haskell.org/package/hsqml-datamodel-0.1.0.0 (mjmrotek)
08:53:41 <jsidfofo> how do I view what a type alias is for in ghci?
08:53:49 <bennofs> jsidfofo: :i
08:53:58 <bennofs> jsidfofo: (short for :info)
08:54:21 <jsidfofo> ah okay
08:55:09 <aib> All the introductory stuff I've been reading must have messed my brain up. Remember how most articles mention a -> b -> a has one possible (or meaningful, anyway) implementation, and, say, (b -> a) is impossible? How is Integer -> a possible? Is it because of the Num a constraint?
08:55:29 <bennofs> aib: yes, it's because of the Num constraint
08:55:49 <bennofs> aib: the Num constraint allows you to provide a differtent implementation for each possible type that a can take
08:55:57 <aib> fromInteger is part of Num, Num forces implementations to implement fromInteger, so by a circular definition fromInteger can return Num a => a?
08:56:12 <jsidfofo> How do I combine route and handler in servant?
08:56:25 <bennofs> aib: so you can have an instance Num Int (where you implement fromInteger :: Integer -> Int), and instance Num Word where you implement fromInteger :: Integer -> Word
08:57:05 <bennofs> aib: so yes, for any type with a Num instance, there exists a corresponding fromInteger implementation that the compiler will use
08:57:35 <aib> excellent. bennofs: thanks, that cleans up my train of thought.
09:01:00 <jsidfofo> okay I guess I'm not going to use servant
09:01:09 <jsidfofo> What is better scotty or spock?
09:01:14 <jsidfofo> they seem very  similar to me
09:04:15 <berdario> jsidfofo have you already had a look at http://haskell-servant.github.io/tutorial/server.html  ?
09:04:31 <jsidfofo> berdario: yes
09:04:50 <jsidfofo> berdario: the main problem I see is that the route and handler are separated
09:05:11 <jsidfofo> and then you have to combine them into a API type and Server API separetelly
09:05:25 <jsidfofo> it doesn't make much sense to me
09:05:40 <berdario> jsidfofo uhm, more like you create the Server API type from the Route type
09:05:52 <jsidfofo> yeah
09:06:04 <jsidfofo> but it is separeted from the Server
09:06:25 <berdario> jsidfofo what do you want to do? are you trying to reimplement the tutorial, or do you have some code?
09:06:26 <jsidfofo> so, for example if you combine your handlers in a different order than your Routes it will not work
09:06:52 <berdario> yes, it won't compile if they are not in the same order
09:07:15 <jsidfofo> whats the point of separating them out like that then
09:07:37 <berdario> well, eventually you'll implement them as different functions
09:07:38 <jsidfofo> why not just combine them into some sort of (Route, Handler) object
09:08:22 <jsidfofo> berdario: what do you mean?
09:08:38 <berdario> that you'll have a different handler for every route
09:08:47 <berdario> so, different functions... so they have to be separated
09:08:49 <berdario> but again
09:09:21 <jsidfofo> yes you have a different handler for every route...
09:09:23 <berdario> we're using words that might be a bit overloaded... what you mean by "separated" might not be the same thing I understood... seeing some code of what you're trying to do might help
09:09:37 <jsidfofo> well the tutorial code is enough
09:09:51 <jsidfofo> I don't want to keep track what order my routes and handlers are combined in
09:10:05 <jsidfofo> each route is pretty much always associated with a handler
09:10:23 <berdario> ok, now I understood
09:12:02 <mpickering> jsidfofo: I think the answer is, that's how it's currently implemented
09:12:06 <berdario> well, the idea is that routes are defined at the type level... so you have to match them. If you use other solutions (TH? explicitly associating the routes with the handlers?) you still have to do it... I don't know if it'd be possible to match things "by name" from the type system
09:12:38 <jsidfofo> I don't want the routes and handlers matched automatically or anything
09:12:52 <jsidfofo> I'm fine with statically manually associating them myself
09:13:05 <jsidfofo> But there doesnt seem to be a way to do it with servant
09:13:15 <mpickering> I think the whole point of servant is that you don't do that
09:13:30 <berdario> basically, with a traditional routing system, you'd have [("/a", aHandler), ("/b", bHandler), ("/c", cHandler)]
09:13:30 <berdario> with servant you have  ("/a" :<|> "/b" :<|> "/c" , aHandler :<|> bHandler :<|> cHandler)
09:13:49 <jsidfofo> why though?
09:13:50 <mpickering> the library is built around the guarantee that you have to provide handles for every endpoint
09:14:02 <berdario> it's the same thing, ultimately... it's just the "matrix" transposed (is this an isomorphism, maybe?)
09:14:03 <mpickering> and the type system makes sure of this
09:14:23 <jsidfofo> berdario: it is the same thing but it makes it awkward and annoying to write
09:15:04 <mpickering> the authors argue that the safety makes up for it
09:15:12 <berdario> jsidfofo I wouldn't pick or drop a web framework only for this... but I agree, I was looking for an example to write that in a cleaner way just yesterday
09:15:17 <ttt_fff> is there any distributed key value store written in pure haskell? (well ,haskell + C is okay)
09:15:24 <jsidfofo> mpickering: how is it more safe than doing (route, handler) ?
09:15:45 <mpickering> because your program won't compile if you don't provide a handler for every endpoint
09:16:01 <berdario> jsidfofo btw, there's a #servant channel... even if today it's quite quiet
09:16:06 <jsidfofo> mpickering: you need a handler for every endpoint in spock, scotty other frameworks as well...
09:16:17 <mpickering> but the type system doesn't guarantee it no?
09:16:24 <jsidfofo> yes...
09:16:27 <jsidfofo> it does
09:16:47 <jsidfofo> because you have Route type as something like (Route Location Handler)
09:18:30 <mpickering> I'm not an expert on web frameworks, I think you should take this conversation into #servant where the authors will gladly discuss it with you
09:19:00 <jsidfofo> okay
09:19:08 <berdario> anyhow, I've been trying to write a Parser instance since 30 minutes, and failing :/
09:19:19 <ttt_fff> Parsec ?
09:19:21 <ttt_fff> or what?
09:19:31 <mpickering> iirc, other frameworks don't make guarantees about which parameters can also appear on each endpoint?
09:19:53 <berdario> I'm trying to write instance Data.ByteString.Conversion.FromByteString  Network.URI.URI
09:19:59 <mpickering> but we should continue this conversation on #servant I feel
09:20:18 <berdario> ttt_fff ultimately, FromByteString is a Parsec, yes
09:20:43 <berdario> I've already wrote a couple of Parsec parsers... but this is only incidental to what I was about to write
09:21:17 <lpaste_> berdario pasted “No title” at http://lpaste.net/138347
09:22:44 <lpaste_> berdario pasted “No title” at http://lpaste.net/138348
09:24:00 <berdario> the frustrating thing is that I have to thread this stuff through 4 different data types (ByteString, Text, String, URI) and 3 different typeclasses (Parser, Either, Maybe and again Parser)
09:24:10 <berdario> there should be a simpler way to do this
09:24:21 <berdario> (actually, I haven't got to compile this stuff, yet)
09:24:34 <safinaskar> it is recomended now to add Functor and Applicative instance for all monads. why? why not instead add one instance for all? i. e. why not just add "instance (Monad m) => Functor m" to standard library?
09:25:02 <berdario> I need Text, because there's no decodeUtf8 :: ByteString -> Maybe String, apparently
09:25:23 <berdario> and I need String, because parseURIReference :: String -> Maybe URI
09:34:31 <imperative_pleb> Hey, I've been using haskell on and off for about 6 months now, and I still find it much easier to implement algorithms in C than in Haskell. I like to do Project Euler problems, and I've consistently had trouble implementing solutions in Haskell (even though I've implemented them in C rather easily). Should I just give up? I really believe in the benefits of functional programming, but can't I just program functionally in C an
09:35:21 <voidzero> imperative_pleb, your sentence got cut off after "functionality in C an"
09:35:44 <imperative_pleb> sorry about that, I was really close to the end anyways
09:35:48 <voidzero> btw, for Haskell Q&A you can also ask in the haskellbeginners subreddit
09:35:57 <voidzero> or ask here ofc.
09:36:09 <imperative_pleb> it was: functionall in C anyways? Why use Haskell?
09:36:25 <imperative_pleb> And if you guys would rather, I can go to haskellbeginners, I didn't know about that subreddit
09:36:37 <voidzero> no it's ok, just pointing out that it's there
09:36:53 <Hijiri> functional programming can transfer some benefits to other languages, but Haskell gives a lot of features that make it a lot more convenient and expressive, like it's great type system, pattern matching, higher-order typeclasses, etc
09:36:59 <Hijiri> all things you don't get in C
09:37:18 <voidzero> for me the biggest reason is compiler errors rather than runtime errors
09:37:26 <voidzero> and type safety
09:37:32 <voidzero> I'm not a C programmer though
09:37:44 <voidzero> I'm hardly even a Haskell programmer, but that's why Haskell appeals to me
09:38:14 <voidzero> plus, don't you need to do all kinds of memory allocation stuff with C?
09:38:25 <edk> the important thing to realise about C in order to program effectively in it is that its type system isn't really a type system, it just almost looks like one from some angles
09:38:38 <lpaste_> mauris pasted “string parser” at http://lpaste.net/138349
09:38:52 <edk> voidzero, yes. it's not well-suited to most things that aren't processing streams of bytes, imo
09:38:55 <mauris> ^ can i write this as a foldrM?
09:39:19 <voidzero> edk, ack
09:39:33 <Hijiri> oh yeah, what voidzero said
09:39:37 <Hijiri> garbage collection is a big thing
09:39:46 <imperative_pleb> Yeah that's true, I definitely appreciate all of those things. But, with Haskell, I also have to worry about structuring my solution so that it can solve the problem efficiently, which isn't really a problem in more imperative languages. Is this just because I'm inexperienced with Haskell? Even though I've used it on and off for a while, I haven't written even close to 100 or even 200 lines
09:39:47 <voidzero> guys like me shouldn't use C for those reasons. :-)
09:39:52 <Hijiri> it lets you program persistently efficiently because you don't have to worry about shared data
09:40:09 <Hijiri> I mean, worry about freeing it
09:40:11 <safinaskar> it is recomended now to add Functor and Applicative instance for all monads. why? why not instead add one instance for all? i. e. why not just add "instance (Monad m) => Functor m" to standard library?
09:40:24 <voidzero> imperative_pleb, what you're talking about is what people mean when they say that Haskell changes how they think
09:41:23 <voidzero> instead of making a semi-arbitrary bottom up structure, Haskell lets you think about these things in a different order
09:41:29 <voidzero> more in terms of problem and solution
09:41:51 <Hijiri> imperative_pleb: If you are having performance problems with a solution, you could ask questions about the specific ones that come up
09:42:10 <voidzero> in imperative languages, the way it looks to me is, you start by saying "i need something that does foo"
09:42:46 <voidzero> but with Haskell it's more about what you put in and what you get out
09:42:49 <voidzero> to me at least
09:42:55 <hodapp> imperative_pleb: Literally *all* of what you do in imperative languages is explicitly trying to structure a problem for efficient solving.
09:43:13 <voidzero> i'm worth 15 years of sysadminning, but not much programming :) for what it's worth.
09:43:36 <imperative_pleb> Hijiri, for example, recently I was working on https://projecteuler.net/problem=15. Of course, a generic recursive solution would not work in any language for 20x20, so I wrote a dynamic programming solution in C.
09:43:56 <Hijiri> what's a "generic recursive solution"
09:44:30 <Hijiri> recursing on every path?
09:44:55 <Hijiri> actually for this problem I would figure out a general solution before coding in the first place
09:45:02 <Hijiri> and come up with a formula for nxn grids
09:46:30 <Hijiri> so let's say you're in an m x n grid
09:46:35 <imperative_pleb> "generic recursive solution": find n paths for (x, y): start at (0, 0), each iteration of function, if x != goal.x and y != goal.y, then npaths = right_paths + left_paths, else 1
09:46:51 <imperative_pleb> sorry that's a really bad explanation of what I wrote, this is better:
09:47:00 <lpaste_> aib pasted “euler15” at http://lpaste.net/4899824125796679680
09:47:09 <Hijiri> I think I understand what you mean
09:47:40 <imperative_pleb> this is the generic recursive solution I'm referring to: http://pastebin.com/aXnqUAde
09:48:41 <Hijiri> The solution here is probably to work out a general solution on paper and implement that in code, instead of figuring it out from the actual paths
09:49:03 <Hijiri> imperative_pleb: have you done basic combinatorics?
09:50:19 <imperative_pleb> no I haven't done combinatorics
09:50:27 <Hijiri> have you done count function before
09:50:32 <echolot> ;5~art of counting withouit counting xD
09:51:18 <aib> Hijiri: I move that actually calculating the paths would be a much better excercise (though infeasible for 20x20 with my implementation)
09:51:24 <imperative_pleb> but this is the dynamic solution I created: http://pastebin.com/96chLsUv However, trying to translate that to haskell was pretty unintuitive for me. I guess I'm just not used to recursive iteration. Maybe I don't really have a question or point here haha
09:51:42 <aib> Actually, considering there are 137846528820 of them...
09:52:21 <monochrom> this is related to a half-joke half-serious in math. "Q: how do you visualize 4 dimensions?  A: visualize n dimensions, then let n=4"
09:52:35 <jsidfofo> is there an example somewhere of modular route definitions for spock or scotty?
09:52:41 <aib> imperative_pleb: I think the problem is thinking iteratively and then translating it. You might need to start "thinking functionally", if that makes sense. And don't ask me how, I don't know either :(
09:53:16 <jsidfofo> I want to define different sets of routes in different modules and have different middleware for each one
09:53:20 <monochrom> in your case, it may actually be both easy and elegant to figure out mxn (by spotting a pattern), then let m=20, n=20.
09:53:26 <imperative_pleb> aib: yeah I think you're right, I'm also pretty unfamiliar with the standard library's list functions
09:53:29 <supki> safinaskar: That instance doesn't work. It overlaps with everything else so you'll eventually end up with OverlappingInstances and IncoherentInstances, which is bad.
09:54:00 <supki> safinaskar: (Also, what if I prefer  instance Comonad w => Functor w ?)
09:54:50 <aib> imperative_pleb: I kinda go back and forth. I've learned a bit of functional thinking (https://github.com/aib/Project-Euler), then went and used the best bits in imperative code, then came back...
09:56:40 <cow_2001> :t reads
09:56:41 <lambdabot> Read a => ReadS a
09:56:43 <cow_2001> :|
09:57:19 <safinaskar> supki: thanks
09:57:26 <cow_2001> ah!
10:05:30 <WeaponX> ByteString question: how do I best represent one as hex? this is what I tried and didn't work: map (printf "%02x") $ BL.unpack contents
10:08:30 <monochrom> I think that's simply because of "dunno which PrintfType instance you want'
10:09:07 <monochrom> map (printf "%02x") $ BL.unpack contents :: [String]
10:09:45 <WeaponX> monochrom, very nice, thanks
10:15:54 <humanoyd> If I have made a type an instance of IsString, how can I convert between the type and the string? E.g. at some point `["foo", "bar"] :: MyType` and at some other point `["foo", "bar"] :: [String]`?
10:16:17 <humanoyd> s/MyType/[MyType]
10:16:19 <monochrom> @pl \a mb -> return (Cons (f a) mb)
10:16:19 <lambdabot> (return .) . Cons . f
10:16:27 <monochrom> :)
10:24:19 <aib> umm, how can I print a Data.Text.Internal.Lazy.Text ?
10:25:06 <aib> ah, the putStr overload..
10:25:50 <c_wraith> Well, it's the exact same type as Data.Text.Lazy.Text, just re-exported
10:26:03 <c_wraith> So no overloading is necessary to treat those two types as the same
10:26:05 <mauris> humanoyd, there's no way: http://stackoverflow.com/questions/7852505/why-the-data-string-isstring-only-define-one-conversion
10:26:35 <aib> sorry, I meant String -> IO ().. and yea, no overloading there. I got an ambiguous occurrence
10:26:58 <c_wraith> mauris: you could always have a value with a type like (IsString a) => [a]
10:27:46 <mauris> sure, but there's no (IsString a) => [a] -> [String], which I think humanoyd wants (right?)
10:28:18 <c_wraith> Um.  That's just id
10:29:45 <mauris> what? i mean, `a` could be something like ByteString, surely?
10:31:21 <mauris> how would id turn a [ByteString] into a [String]? or IsString is just more magical than i'm thinking
10:31:31 <c_wraith> well, when you have a value with the type (IsString a) => [a], it means that it's polymorphic
10:31:32 <srhb> Yeah, it's map fromString
10:31:45 <Hijiri> mauris: map one of the decoding functions from the bytestring package
10:32:01 <srhb> :t map fromString
10:32:02 <lambdabot> IsString b => [String] -> [b]
10:32:02 <c_wraith> It can be used at *any* concrete type [a] where a is an instance of IsString
10:32:12 <mauris> c_wraith, oh, I see what you mean, yeah
10:32:46 <exio4> c_wraith: you don't get to pick the type though 
10:33:04 <c_wraith> exio4: anyone using the value gets to pick the type.  If you want to use it as [String], you can
10:33:26 <exio4> yup, and in that specific case, it would be id
10:35:29 <mauris> to clarify, the problem here is that IsString *doesn't* supply a way to convert `a` back to `String`: https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-String.html
10:36:40 <Hijiri> yes
10:36:47 <Hijiri> IsString's sole purpose is supporting overloaded string literals
10:37:24 <ReinH>  If you want to print a Data.Text.Lazy.Text, you can use Data.Text.Lazy.IO
10:37:35 <exio4> mauris: if you want to keep it polymorphic, you can use rankntypes
10:38:02 <ReinH> If you want to convert it to a String, you can use unpack
10:38:13 <exio4> (forall s. IsString s => [s]) -> 
10:39:03 <exio4> f :: (forall s. IsString s => [s]) -> ([String], [ByteString]) ; f x = (x,x) 
10:40:03 <ReinH> eh?
10:40:25 <mauris> i'm so confused. i don't "want" anything. i'm trying to talk about humanoyd's question
10:40:36 <mauris> <humanoyd> If I have made a type an instance of IsString, how can I convert between the type and the string? E.g. at some point `["foo", "bar"] :: [MyType]` and at some other point `["foo", "bar"] :: [String]`?
10:41:20 <mauris> i'm just saying, there is *not* a way to turn an arbitrary `IsString a => a` into a `String`. only the other way around
10:42:24 <exio4> @type let { f :: (forall s. IsString s => [s]) -> ([String], [BSC.ByteString]) ; f x = (x,x); } in f (map fromString ["abc", "def"])
10:42:24 <humanoyd> mauris: and all the others: Thanks, still trying to understand everything you have written but once I do, I guess I'll know what to do :)
10:42:25 <lambdabot> ([String], [BSC.ByteString])
10:42:31 <exio4> > let { f :: (forall s. IsString s => [s]) -> ([String], [BSC.ByteString]) ; f x = (x,x); } in f (map fromString ["abc", "def"])
10:42:36 <lambdabot>  <no location info>: can't find file: L.hs
10:42:46 <exio4> > let { f :: (forall s. IsString s => [s]) -> ([String], [BSC.ByteString]) ; f x = (x,x); } in f (map fromString ["abc", "def"])
10:42:47 <lambdabot>  (["abc","def"],["abc","def"])
10:45:53 <sveit> I wrote some code in an attempt to abstract the following: I have some data of type e stored in some structure of type v, and I have some selector type s with an associated function s -> v e -> e, but I have begun to suspect that the correct abstraction for this exists and is lens. Is that correct? my experience with lens is pretty light, so this could be totally wrong
10:53:30 <safinaskar> f = [
10:53:31 <safinaskar> ]
10:53:39 <safinaskar> why this doesn't compile?!?!?!
10:53:50 <safinaskar> gh c7.8.3
10:53:53 <safinaskar> ghc 7.8.3
10:54:03 <mauke> the compiler should tell you
10:54:27 <safinaskar> mauke: it says: parse error (possibly incorrect indentation or mismatched brackets)
10:54:36 <jsidfofo> Can I somehow serve/combine multiple Application objects using wai/warp?
10:54:37 <safinaskar> mauke: my question is: why this is error?
10:54:43 <srhb> safinaskar: Is the ] actually in the first column?
10:54:58 <safinaskar> mauke: why i cannot break list into multiply lines and how to break it?
10:55:17 <srhb> safinaskar: You can, every following line just has to be indented further.
10:55:39 <Gurkenglas> sveit, this? https://hackage.haskell.org/package/lens-3.3/docs/Control-Lens-Indexed.html
10:55:48 <safinaskar> srhb: yes, first column. exact code is here: http://paste.debian.net/290665/
10:56:00 <srhb> safinaskar: Then just move it at least one character further to the right
10:56:05 <srhb> Every line but the first, that is.
10:56:16 <mauke> > let f = [;] in ()
10:56:17 <lambdabot>  <hint>:1:10: parse error on input ‘;’
10:56:56 <sveit> Gurkenglas: i suspect so, but I was actually thinking something even more general
10:57:05 <safinaskar> srhb: thanks :) (this is very strange rule. it makes my lists ugly)
10:57:20 <srhb> safinaskar: It's a very sensible rule. You can look up haskell layout rules.
10:57:22 <sveit> Gurkenglas: the idea is it could work for non-indexed storage like (for example) hash tables as well
10:57:42 <srhb> safinaskar: It also allows for some very pretty formatting
10:58:07 <safinaskar> srhb: i hate all haskell layout rules. i want haskell to be normal bracket language, like C is
10:58:10 <srhb> safinaskar: Like this: http://paste.debian.net/290667/
10:58:27 <srhb> safinaskar: I think that feeling will go away when you understand it. :-)
10:58:43 <mauke> safinaskar: http://paste.debian.net/290668/
10:58:55 <jsidfofo> is it possible to combine Wai Application objects?
10:58:59 <safinaskar> srhb: your example is especially ugly
10:59:00 <Gurkenglas> (Of course, the link for the current version is https://hackage.haskell.org/package/lens-4.12.3/docs/Control-Lens-Indexed.html )
10:59:03 <mauke> safinaskar: haskell is a bracket language. layout is an optional feature
10:59:04 <srhb> safinaskar: Sorry to hear that :P
10:59:59 <mauke> safinaskar: http://paste.debian.net/290669/
11:00:34 * srhb shudders
11:01:18 <hpc> that reminds me of java
11:01:24 <hpc> perfunctory start of file stuff {
11:01:30 <hpc>   everything in here
11:01:30 <hpc> }
11:01:58 <maerwald> how do I reinstall user-packages again after ghc update?
11:02:48 <humanoyd> Regarding the OverloadedStrings issue: I'd basically like the following code to compile: http://pastebin.com/JWk2ysjn
11:02:55 <humanoyd> Unfortunately, it doesn't
11:03:06 <sunnymilk> pyon do you know some nice books abpout type theory that dontr have "tapl" in their name
11:03:31 <pyon> sunnymilk: Type theory and functional programming. :-p
11:03:31 <jsidfofo> is it possible to combine Wai Application objects?
11:03:46 <sunnymilk> will it teach me anything that wasnt in tapl
11:04:03 <Zemyla> Hey, sunnymilk. It's good to see another Touhou fan.
11:04:16 <HijiriPhone> what is touhou
11:04:18 <sunnymilk> hello :)
11:04:28 <srhb> humanoyd: Looks like the dreaded monomorphism restriction
11:04:34 <c_wraith> maerwald: cabal install world
11:04:48 <c_wraith> maerwald: if you want to see what that'll do, take a look at .cabal/world
11:04:51 <sunnymilk> touhou is a series of shmup (shoot 'em up) video games
11:05:05 <HijiriPhone> sorry, was just joking
11:05:14 <sunnymilk> oh lol i didnt see your nickname
11:05:17 <srhb> humanoyd: Try disabling it :)
11:06:40 <humanoyd> srhb: Aahh, of course...
11:06:43 <humanoyd> Thanks a lot!
11:07:26 <Gurkenglas> http://hackage.haskell.org/package/kan-extensions-4.2.2/docs/Data-Functor-Kan-Ran.html <- "we want to find extend h *back* along g" <- grammatically sic?
11:07:38 <c_wraith> Gurkenglas: looks like a typo to me
11:07:47 <srhb> Unless we're finding "extend h"
11:08:34 <mauris> what's the parsec combinator for  `do { str1 <- p1; str2 <- p2; str3 <- p3; return (str1 ++ str2 ++ str3) }`  ?
11:08:40 <c_wraith> I think it's a typo, though not 100% sure. :)
11:08:56 <mauris> just run a list of parsers sequentially and return all of the results concatenated
11:09:38 <c_wraith> concat <$> sequence [parser1, parser2, .....]
11:10:34 <mauris> perfect!
11:11:05 <c_wraith> edwardk: is the think Gurkenglas found just a typo?
11:11:48 <edwardk> typo
11:11:53 <edwardk> extend h back along g
11:12:03 <edwardk> i make lots of typos
11:12:13 <c_wraith> thought so, but I haven't taken the time to actually learn that subject yet, so I wasn't 100% sure.
11:13:13 <cow_2001> phaazon++
11:13:40 <edwardk> c_wraith: just fixed it in head https://github.com/ekmett/kan-extensions/commit/bbab97a64fca92055f322bef5dc604f4b050da9f
11:14:11 <c_wraith> Gurkenglas: there you go.  Prompt corrections issued.  (thank edwardk)
11:15:47 <Gurkenglas> edwardk, edwardk, https://github.com/ekmett/free/pull/101 ? (Is it appropriate to remind of these?)
11:16:11 <edwardk> merged
11:16:17 <edwardk> and yes, it is appropriate
11:16:32 <edwardk> i have a couple hundred repos on github... they have gotten rather unreliable at sending me emails
11:17:07 <edwardk> if it gets posted to #haskell-lens then i usually see it in my log and do something, but that is my major path of interaction
11:17:22 <edwardk> Gurkenglas: how urgently do you need the instance? should i batch this up with other free changes?
11:18:29 <humanoyd> Is there a more elegant way for "fmap foo bar `shouldBe` fmap foo quux"?
11:19:14 <humanoyd> shouldBe :: a -> a -> NotImportant
11:20:17 <mauris> you could get out `on` from Data.Function and write something weird but imo there isn't anything clearer than that!
11:21:09 <humanoyd> mauris: Thanks, I couldn't remember the name, that's what I was looking for
11:24:52 <Gurkenglas> Nah, I don't actually need the instance, it just seemed sane. And I wanted it to be in master because another idea I had would intersect with that change.
11:25:28 <Kron> whenever I update any package from the haskell-core arch repository, I get a "haddock: internal error: /usr/lib/ghc-7.8.4/settings: openFile: does not exist (No such file or directory)" error message
11:25:33 <Kron> seems to complete successfully though?
11:25:42 <Kron> I'm just not sure what's causing this and how to get rid of it
11:25:59 <Kron> not sure why it thinks I should have an old ghc
11:26:02 <maerwald> c_wraith: as expected, cabal chokes and cannot resolve dependencies...
11:26:24 <scutigera> hello. does anyone know why you would want to use the opengl package vs the gl package or vice versa ?
11:27:51 <scutigera> looks like they are both staying up to date. and i see various 3D apps using one or the other, but can't seem to tell why you would want to use one over the other.
11:29:26 <ahihi> opengl is higher-level, but less complete
11:31:21 <safinaskar> http://paste.debian.net/290680/
11:31:35 <safinaskar> why $(...) block at 71..74 is ignored?
11:31:43 <safinaskar> and 80..95, too?
11:31:56 <safinaskar> so, only 76..78 actually generated. why?
11:32:14 <safinaskar> ghc 7.8.3
11:33:55 <safinaskar> okey, "Declaration splices are not permitted inside declaration brackets", i understand
11:34:04 <safinaskar> AAHH! why template haskell so incomplete?!
11:35:35 <ely-se> Why do you need to box existentials? E.g. `data T = forall a. T a; f :: [T]`, why isn't there `f :: [exist a. a]`?
11:36:31 <ReinH> Because exists isn't in the language.
11:37:26 <ely-se> Yes, I know, but why?
11:38:03 <ReinH> Because people decided not to add it.
11:39:02 <monochrom> I feel that it is just another case of "too much effort to implement, for too few uses"
11:40:14 <monochrom> I get that from a related question: why not existentials in newtypes? and this is answered in the GHC user's guide.
11:40:36 <ReinH> forall was already a keyword, probably easier to reuse it than add a new keyword in a extension.
11:41:08 <safinaskar> my question: http://paste.debian.net/290682/
11:41:21 <monochrom> "but single-field existentially quantified constructors aren't much use. So the simple restriction (no existential stuff on newtype) stands, unless there are convincing reasons to change it."
11:41:57 <monochrom> this looks to me like: existential newtype can be done, but not enough use, why bother.
11:42:17 <ReinH> safinaskar: you have to follow the layout rules if you aren't using braces and semicolons.
11:42:29 <ReinH> @google Haskell layout
11:42:30 <lambdabot> https://en.wikibooks.org/wiki/Haskell/Indentation
11:42:44 <ReinH> The rules are pretty simple.
11:42:56 * hackagebot mandrill 0.3.0.0 - Library for interfacing with the Mandrill JSON API  https://hackage.haskell.org/package/mandrill-0.3.0.0 (AlfredoDiNapoli)
11:43:03 <monochrom> and the newtype story is pretty much equivalent to an "exist a. <type>" story.
11:44:45 <safinaskar> ReinH: is this possible to write my example using do-brackets and not using let-brackets? (and with list breaked to multiply lines)
11:45:14 <ReinH> safinaskar: did you read the layout rules?
11:46:53 <monochrom> putting ] under l is not what I call "looks more beautiful
11:47:21 <monochrom> putting ] under [ is what I call "the most beautiful". incidentally, it is also legal.
11:48:02 <safinaskar> ReinH: i read. it says that i either should use brackets everywhere or use layout everywhere. but this text doesn't say what happens in my example, i. e. do-brackets and let-without-brackets. and i want this, i. e. i want do-with-brackets and let without them
11:48:27 <safinaskar> *i have read
11:49:37 <ReinH> Did you read the actual layout rules and try to apply them to the let statement? It would answer your question.
11:52:44 <safinaskar> ReinH: well, i just played with "let" and it seems that i must put brackets to "let". well, okey
11:52:57 <ReinH> No.
11:53:49 <ReinH> You just need to follow the layout rules
11:53:52 <safinaskar> ReinH: again: i already use brackets with "do". (this is intentional). and it seems that (if i use brackets with "do") i should use it with "let", too. i just tried all variants
11:54:14 <safinaskar> *use them [brackets]
11:54:28 <ReinH> "All"?
11:54:29 <c_wraith> the syntax does require brackets on a let inside of a do.  It just usually uses alignment to auto-insert them.
11:54:35 <monochrom> put the semicolon under l vertically, not after ] horizontally
11:54:36 <ely-se> monochrom: ok
11:55:16 <ReinH> You must not have tried all of them since some of them work.
11:56:53 <monochrom> http://paste.debian.net/290684/
11:57:14 <safinaskar> ReinH: i tried this: http://paste.debian.net/290685/ . and even this doesn't compile. so, i am right
11:57:58 <Gurkenglas> Why are people suddenly using paste.debian.net instead of lpaste.net?
11:58:27 <ReinH> Not sure how that implies that you are right, especially since you aren't.
11:58:32 <monochrom> a mystery of the universe
11:58:37 <safinaskar> monochrom: :)
11:59:22 <ReinH> ... Isn't a legal statement in Haskell anyway
11:59:33 <safinaskar> monochrom: "under l vertically" - o_O, thanks, it works
11:59:57 <safinaskar> ReinH: well, i just tried "under l vertically" http://paste.debian.net/290686/ and it works. i am not right
12:00:14 <safinaskar> but this is very-very strange example. wtf layout rules
12:00:50 <broma0> hi tmg
12:01:04 <ReinH> Indeed.
12:01:06 <ReinH> Well, you aren't using them. You are using explicit braces and semicolons.
12:01:39 <ReinH> Which is weird, but even SPJ uses them so not that weird.
12:01:56 <ReinH> Although his style prevents such alignment issues
12:01:59 <safinaskar> Gurkenglas: i like paste.debian.net (and use them for other languages, too). i started to paste examples from it. it seems that people started using my paste :)
12:02:26 <maerwald> cool, so far all packages failed to install with ghc-7.10
12:02:35 <ReinH> But you find that style ugly since you have not yet acclimated to Haskell
12:02:42 <monochrom> there was a time I used explicit {;}. it was when emacs haskell-mode indenter was not smart enough. so I used {;} to help it.
12:04:07 <monochrom> in fact, it was like this: 1st line "do { abc", 2nd line "; def" (";" under "{"), 3rd line "}" (under ";")
12:05:54 <safinaskar> ReinH: i think bracket style is good. i just don't want to use it with short "let" expressions
12:06:40 <ReinH> safinaskar: I was referring to SPJ's style of using brackets, which you already claimed to find ugly when used with lists.
12:07:09 <ReinH> It puts the ; at the beginning of each line
12:08:10 <cow_2001> i love this style :|
12:09:13 <monochrom> only problem is that a Lisper would mistake your code to be comments :)
12:09:34 <safinaskar> okey, but how to compile this: http://paste.debian.net/290691/ ? still doesn't compile
12:09:58 <monochrom> but yeah, it satisfies all of: aesthetic, helps indenter, unambiguous
12:10:00 <cow_2001> D:
12:10:38 <monochrom> safinaskar: move the ";" to the left. under "l".
12:10:54 <safinaskar> ReinH: i use C style of brackets for "do" and "case" and for big "let" expressions. i don't use brackets for small "let" expressions and i don't use them in all other cases
12:10:54 <monochrom> or even better, use SPJ style, as we said
12:11:14 <ReinH> You seem to by trying to make that code as ugly as possible...
12:11:52 <safinaskar> monochrom: thanks, it works
12:13:20 <safinaskar> and how to compile now? http://paste.debian.net/290693/ (i have put "let" and "thdesc1 = [" to one line
12:13:23 <ReinH> I wouldn't want to use a style where I have to fight with the parser, regardless of aesthetics.
12:13:39 <safinaskar> monochrom: "..Lisper.." - :)
12:13:47 <ReinH> safinaskar: we can't fix every line of code for you. Learn the layout rules and apply them.
12:16:37 <Gurkenglas> Would you paste more of your code? I also don't see why that wouldn't compile. How do you know this is the problematic part?
12:17:02 <Gurkenglas> *wouldn't parse
12:17:57 * hackagebot Earley 0.9.0 - Parsing all context-free grammars using Earley's algorithm.  https://hackage.haskell.org/package/Earley-0.9.0 (OlleFredriksson)
12:19:16 <ReinH> The line after let is indented before the start of the expression. The layout rules explain this.
12:20:03 <c_wraith> That Earley library is interesting.  It introduces an extra layer of typing just to enable observable sharing.  Never was quite sure what to think of that.
12:22:43 <ReinH> Is there a way to get ghc to show the braces and semicolons it inserts when it desugars?
12:22:59 <safinaskar> Gurkenglas: http://paste.debian.net/290694/
12:23:25 <safinaskar> Gurkenglas: ghc 7.8.3
12:24:11 <srhb> ReinH: -ddump-ds perhaps? Well, it probably doesn't count as sugar...
12:24:14 <ReinH> safinaskar: we already explained that.
12:25:14 <ollef> c_wraith: I had an interface to Earley that removed that layer and looked more like combinator parsers, but decided against releasing it since it used unsafe functions under the hood.
12:25:22 <mauris> should I prefer `ReaderT Environment Parser a` over `Reader Environment (Parser a)` ?
12:25:35 <c_wraith> ollef: things like reallyUnsafePointerEquality?
12:25:49 <srhb> ReinH: -ddump-parsed seems something like that.
12:27:09 <ollef> c_wraith: unsafePerformIO --- I still let the user add rules like in the layered version, though using that might be an option too.
12:33:20 <scutigera> speaking of parsing - is there a flex/lex equivalent package to use for tokenization ?
12:36:56 <geekosaur> alex?
12:37:43 <geekosaur> that said I think the usual recommendation is to use parsec instead of separate lexing and parsing
12:38:15 <c_wraith> unless you need a *ton* of speed, yeah.
12:38:32 <exio4> I would use LBNF (bnfc) for that, maybe
12:38:38 <geekosaur> (separating those is largely a holdover from tiny address spaces where you needed to do them separately to not run out of memory)
12:40:42 <exio4> c_wraith: well, an optimized attoparsec parser would be probably fast enough 
12:45:05 <Gurkenglas> safinaskar, I think you can't place the [ to the right of the ]. You can either indent the ] to its level or put the [ on a newline on a level with ]
12:48:32 <jsidfofo> How do I reinstall dependencies for my cabal project?
12:48:36 <monochrom> ReinH: -ddump-parsed. unfortunately, it can also put semicolons at wrong places
12:48:45 <jsidfofo> I can't seem to be able to use --dependencies-only and --reinstall together -_-
12:53:26 <monochrom> ReinH: http://lpaste.net/138353
12:54:19 <ReinH> monochrom: huh
12:56:00 <safinaskar> i generate the following code using template haskell: instance (Monad m) => Functor (T m) where { ... }; instance (Monad m) => Applicative (T m) where { ... }
12:56:07 <safinaskar> is this okey to use same "m" here?
12:56:16 <safinaskar> i. e. to generate one "m" using newName?
12:58:16 <jsidfofo> Is it possible to separate the 'get ...' etc routes in spock into separate modules? https://www.spock.li/tutorial/
12:59:52 <jsidfofo> ........
13:07:30 <arkeet> jsidfofo: why wouldn't it be?
13:07:39 <arkeet> they're just values
13:09:21 <jsidfofo> arkeet: idk, but I get a paragraph of errors when I try to do something like "api = get "status" $ text "asdf""
13:09:43 <arkeet> what's the error?
13:09:46 <jsidfofo> And I haven't found a single example or piece of code that does this
13:11:52 <arkeet> jsidfofo: so what's the error?
13:12:15 <jsidfofo> arkeet: http://lpaste.net/138356
13:12:37 <jsidfofo> I'm using a bit different api - json instead of text
13:12:40 <jsidfofo> but just as simple
13:12:48 <jsidfofo> 1 sec I will post code
13:13:07 <arkeet> what if you give a type annotation?
13:13:17 <arkeet> api :: MonadIO m => SpockT m ()
13:13:32 <jsidfofo> arkeet: code: http://lpaste.net/138357
13:13:43 <AaronFriel> Does FFI prevent garbage collection on other GHC threads/capabilities? And to expand on this, was the local heap work ever merged into GHC from Marlow's 2011 paper?
13:13:58 <arkeet> although actually the fact that it gives the full package version for transformers in the error suggests to me that
13:14:07 <arkeet> you have multiple versions of transformers installed and it's getting confused
13:14:31 <jsidfofo> uhh
13:14:42 <jsidfofo> can I check that somehow?
13:14:47 <arkeet> ghc-pkg list transformers
13:14:53 <jsidfofo> im using stack to build btw
13:14:57 <arkeet> oh
13:15:02 <arkeet> I'm not familiar with stack
13:16:10 <jsidfofo> arkeet: I get the same error when using cabal build though
13:16:32 <jsidfofo> arkeet: ghc-pkg shows only one transformers-0.4.3.0
13:17:02 <arkeet> the error message refers to transformers-0.4.2.0
13:17:45 <arkeet> maybe spock was built against that and now it's broken??
13:17:49 <jsidfofo> arkeet: that message was from stack, the one from cabal refers to 0.4.3.0
13:17:52 <arkeet> ah
13:18:16 <arkeet> I dunno, still seems weird.
13:25:24 <jsidfofo> is there any simple framework for writing RESTful APIs that isnt completely dead?
13:25:50 <coppro> jsidfofo: {simple, RESTful, haskell}, pick 2
13:26:14 <jsidfofo> coppro: RESTful and haskell?
13:26:19 <coppro> jsidfofo: yesod?
13:26:32 <jsidfofo> anything else?
13:26:34 <coppro> snap?
13:27:02 <jsidfofo> those are more full featured frameworks that seem to be meant to be used with server-side templating 
13:27:29 <bennofs> scotty can be used for RESTful too I believe
13:27:50 <jsidfofo> scotty seems dead considering I have got zero replies to my questions for the past 3 days
13:28:55 <jsidfofo> every single piece of code using scotty or spock I have come across thusfar has the routes declared in one place -_-
13:29:05 <coppro> jsidfofo: yesod comes as a featureful package, but you don't need to use all of the features
13:29:05 <creichert> yesod is good for api style services too. Servant is very cool
13:29:24 <creichert> jsidfofo: How would you prefer it?
13:29:31 <coppro> yesod itself does not care about the content
13:29:36 <jsidfofo> creichert: a set of routes per model
13:29:44 <creichert> also, you can move your routes out to different moduels and include them
13:29:46 <coppro> jsidfofo: what is a "model" here?
13:29:57 <jsidfofo> coppro: like user model, article model, etc
13:30:09 <coppro> jsidfofo: yesod subsites, perhaps?
13:30:24 <jsidfofo> I guess I will look at yesod
13:30:29 <creichert> Article.hs can have a set of routes and you can run them in scotty or spock (or any other framework for that matter)
13:30:30 <jsidfofo> servant design seems backwards to me
13:30:46 <jsidfofo> creichert: how?
13:30:57 <jsidfofo> creichert: do you have an example?
13:31:02 <creichert> sure
13:31:26 <jsidfofo> so far I have found none
13:31:27 <creichert> main = scotty 3000 $ do articleRoutes; otherModelRoutes
13:31:38 <jsidfofo> creichert: I mean the definition of articleRoutes
13:31:41 <creichert> articleRoutes = do get "/article" ...
13:32:34 <jsidfofo> creichert: let me try that again, last time I did that I got a ton of errors
13:32:50 <creichert> post them if they show up again
13:33:00 <jsidfofo> creichert: yup got the errors again
13:33:16 <arkeet> he did, above: http://lpaste.net/138357 http://lpaste.net/138356
13:33:33 <coppro> jsidfofo: with Yesod, you usually specify your routes in one place
13:33:42 <coppro> but it's not required; you can override the functions that do that
13:33:43 <jsidfofo> creichert: http://lpaste.net/138358
13:34:01 <arkeet> okay
13:34:24 <arkeet> so did you try adding the type signature like I suggested?
13:34:25 <coppro> the issue is that Yesod expects a datatype for its routes, so you have to provide some way to make a single datatype for all your routes
13:34:39 <jsidfofo> arkeet: yes I got more errors with that
13:34:46 <arkeet> what errors?
13:35:00 <jsidfofo> 1 sec
13:37:14 <jsidfofo> arkeet: basically when I try to combine 2 such routes into a list I get: http://lpaste.net/138359
13:37:28 <arkeet> uhh.
13:37:34 <creichert> that is a syntax error
13:37:46 <arkeet> okay, let's read the error message.
13:37:47 <creichert> rather, there is no function for the type signature
13:38:33 <jsidfofo> This is the code: http://lpaste.net/138360
13:39:02 <arkeet> okay, now read the error message.
13:39:18 <jsidfofo> okay
13:39:24 <coppro> +1 arkeet
13:39:32 <jsidfofo> What am I missing?
13:39:39 <arkeet> where is statusAPI declared?
13:39:43 <arkeet> where is the type signature?
13:39:52 <jsidfofo> I do have the type signature in the statusAPI
13:39:58 <jsidfofo> 1 sec I will post code
13:40:30 <jsidfofo> http://lpaste.net/138361
13:40:42 <arkeet> okay
13:40:55 <arkeet> that module is fine
13:41:02 <arkeet> I don't know what you're trying to do in Asdf
13:41:09 <creichert> http://lpaste.net/138362 jsidfofo
13:41:13 <creichert> I just compiled that locally
13:41:13 <jsidfofo> I'm just combining a set of routes
13:41:59 <jsidfofo> creichert: does it work if you use Web.Scotty.Safe instead of Web.Scotty?
13:42:11 <bennofs> jsidfofo: why do you give a type signature for statusAPI in Asdf?
13:42:13 <jsidfofo> or nbm
13:42:17 <jsidfofo> that is scotty I'm using spock
13:42:19 <arkeet> you didn't mean to write "asdf :: ..." did you?
13:42:24 <arkeet> instead of statusAPI
13:42:27 <jsidfofo> bennofs: I was told to add it
13:42:27 <codehero> @let tau = 2 * pi
13:42:28 <lambdabot>  Defined.
13:42:58 <arkeet> jsidfofo: no, I wanted you to add it next to the definition of statusAPI.
13:43:02 <arkeet> not in a completely different module.
13:43:13 <jsidfofo> arkeet: oh, I did miss that yes
13:43:33 <jsidfofo> its not supposed to be statusAPI :: its supposed to be asdf :: 
13:44:06 <bennofs> jsidfofo: can you show the compile error that you get if you use asdf :: ?
13:44:31 <jsidfofo> bennofs: I'm getting a bunch of undefined reference errors now
13:44:43 <arkeet> again, post error
13:44:43 <jsidfofo> undefined reference to wubAPI
13:44:44 <arkeet> and code
13:44:48 <arkeet> well.
13:44:48 <bennofs> jsidfofo: :O paste?
13:44:50 <arkeet> did you define wubAPI?
13:44:54 <jsidfofo> okay 1 sec
13:47:04 <jsidfofo> okay
13:47:28 <jsidfofo> The issue was that I was not exposing my Wub and Status modules in my .cabal file
13:47:37 <arkeet> okay.
13:47:38 <jsidfofo> now it is working :)
13:47:41 <arkeet> :)
13:47:44 <jsidfofo> I have another question though
13:47:50 <jsidfofo> are the type signatures necessary?
13:47:50 <creichert> FWIW: this worked for me http://lpaste.net/138364
13:47:53 <creichert> glad you got it though
13:48:20 <jsidfofo> creichert: does it work if you import Web.Spock.Safe instead?
13:48:53 <creichert> yea
13:49:08 <jsidfofo> hmm my code breaks when I remove type signatures from my routes -_-
13:49:25 <jsidfofo> arkeet: why do I need that type signature?
13:49:27 <safinaskar> template haskell. what is difference between TupleT and UnboxedTupleT?
13:50:08 <jsidfofo> I get 'The type variable 'm0' is ambiguous' ...
13:50:09 <arkeet> jsidfofo: because of the monomorphism restriction.
13:50:21 <jsidfofo> uhh
13:50:25 <arkeet> it's annoying.
13:50:28 <arkeet> you can turn it off.
13:50:33 <arkeet> NoMonomorphismRestriction extension
13:50:36 <jsidfofo> arkeet: but creichert is not using type signatures in his code
13:50:43 <arkeet> he is also not using spock
13:50:55 <jsidfofo> arkeet: he is in his latest code: http://lpaste.net/138364
13:51:14 <creichert> arkeet: http://lpaste.net/138365
13:51:26 <creichert> can you state which function is causing the monomorphism restriction?
13:51:57 <arkeet> well, now that they're being used in main, that fixes their type.
13:52:03 <arkeet> try removing them from main and see
13:52:26 <jsidfofo> arkeet: so can I disable this restriction on a per-module basis?
13:52:27 <michie1> hello, I'm trying to do some printf debugging.  Is there a primitive I can use to store the type of an expression into a string that I can show?  Analogous to :t in ghci
13:52:30 <bennofs> creichert, jsidfofo: it works in creichert's code because he defines and uses the sub-routes in the same file, so GHC knows the type where they're used
13:52:30 <arkeet> jsidfofo: yes
13:52:41 <arkeet> GHC knows the type because spockT id restricts them to be SpockT IO ()
13:52:43 <creichert> arkeet: fair enough :)
13:53:05 <jsidfofo> okay is it {-# LANGUAGE NoMonomorphismRestriction #-} ?
13:53:23 <geekosaur> michie1, types don't exist at runtime, so no
13:53:32 <bennofs> jsidfofo: yes
13:53:36 <geekosaur> if you have a Typeable constraint then that can carry around type information at runtime
13:53:43 <michie1> geekosaur: that's why I want the compiler to store it in a string for me.  But apparently not.
13:54:40 <geekosaur> template haskell might be able to store a type like that at compile time, otherwise no
13:54:40 <jsidfofo> okay now its working 
13:54:42 <jsidfofo> thanks guys
13:55:05 <jsidfofo> this stuff really should be shown in an example or tutorial though... there is no way for a noob to figure it out on his own
13:55:07 <michie1> geekosaur: well, that answers the question.  Thanks.
13:57:02 <jsidfofo> Is there a way to expose all library modules in a .cabal file?
13:58:01 * hackagebot QuadTree 0.11.0 - QuadTree library for Haskell, with lens support.  https://hackage.haskell.org/package/QuadTree-0.11.0 (Kron)
14:00:45 * arkeet wonders why SpockT is a monad at all
14:01:13 <creichert> I believe they allow you to use your own transformers in handlers
14:02:19 <arkeet> okay, how about MonadIO
14:03:23 <arkeet> why would I want to do { liftIO something; get path $ action } say.
14:04:05 <creichert> i'm a bit confused on the second statement
14:04:31 <arkeet> I'm wondering why instance MonadIO m => MonadIO (SpockT m) exists
14:04:33 <creichert> you wouldn't want to which is why you create your own stack, newtype AppM a = AppM (ReaderT ...
14:04:36 <creichert> ahh
14:05:45 <Euryale> does ADEpt, the author of the Hitchhiker's guide to Haskell, still poke around here?
14:06:03 <Euryale> I found a typo in some of the code in the tutorial
14:06:04 <arkeet> the reason I wonder why it is a monad at all is because I don't see any type `SpockT m a` around where a is anything but ()
14:06:32 <arkeet> but maybe it has some use.
14:06:46 <creichert> arkeet: so, how yould  you run database actions in the context of your custom transformer?
14:07:17 <arkeet> in a handler? I have no problem with ActionT being MonadIO and such.
14:07:32 <creichert> in general, i've done something like (runDB :: (MonadIO (t m), MonadTrans t) => SqlPersistT IO b -> t m b
14:07:35 <creichert> but that's with scotty
14:08:01 * hackagebot elm-bridge 0.1.0.0 - Derive Elm types from Haskell types  https://hackage.haskell.org/package/elm-bridge-0.1.0.0 (AlexanderThiemann)
14:08:27 <arkeet> maybe someone wants to run database actions while deciding how to route a request.
14:08:37 <arkeet> sounds weird.
14:08:56 <creichert> okay, i misunderstood the question
14:09:53 <jsidfofo> arkeet: do you use yesod generally?
14:10:03 <arkeet> I haven't done any web stuff in haskell really.
14:10:10 <jsidfofo> ah
14:18:01 * hackagebot googlepolyline 0.1.0.1 - Google Polyline Encoder/Decoder  https://hackage.haskell.org/package/googlepolyline-0.1.0.1 (lorne)
14:47:33 <erisco> what is the absolute difference function for floats
14:49:19 <Cale> erisco: (\x y -> abs (x - y))
14:50:04 <hpc> (plus or minus floats being terrible)
14:52:49 <emirypi> did haskell in depth die?
14:53:00 <emirypi> n/m :)
14:53:00 <erisco> Cale, thanks okay
14:53:03 * hackagebot hierarchy 0.1.0 - Pipes-based library for predicated traversal of generated trees  https://hackage.haskell.org/package/hierarchy-0.1.0 (JohnWiegley)
14:53:55 <Cale> emirypi: I believe that channel has almost always been for discussions that get started here and then move anyway.
14:54:22 <hpc> it's been renamed to #2deep4haskell ;)
14:54:36 <emirypi> okay, so I came aross this in some code - what's the :~: operator?
14:55:57 <HijiriPhone> @hoogle (:~:)
14:55:58 <lambdabot> No results found
14:56:09 <hpc> http://hayoo.fh-wedel.de/?query=%3A~%3A
14:56:43 <emirypi> ah i got the answer - a value of type "a :~: b" is a proof that the types "a" and "b" are equal
14:58:21 <safinaskar> @hoogle m [a] -> m [a] -> m [a]
14:58:22 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
14:58:22 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
14:58:22 <lambdabot> Control.Concurrent mergeIO :: [a] -> [a] -> IO [a]
14:58:40 <safinaskar> what is monadic equivalent of ++?
14:58:50 <nullvoid8_> :t liftA2 (++)
14:58:51 <codehero> umm
14:58:52 <lambdabot> Applicative f => f [a] -> f [a] -> f [a]
14:59:00 <codehero> hm
14:59:24 <erisco> minBy ?
14:59:25 <nullvoid8_> > liftM2 (++) --or this
14:59:26 <lambdabot>      No instance for (Typeable m0)
14:59:26 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
14:59:26 <lambdabot>        arising from a use of ‘show_M75701383299964567779835’
14:59:45 <erisco> minimumBy
14:59:48 <codehero> :t liftM2 (++)
14:59:49 <lambdabot> Monad m => m [a] -> m [a] -> m [a]
15:00:07 <codehero> k
15:00:32 <nullvoid8_> liftA2 == liftM2 in 99% of monad/applicative instances
15:00:40 <safinaskar> nullvoid8_: thanks
15:01:00 <hpc> in 100%, i would expect
15:01:51 <nullvoid8_> I think there's a couple where the Applicative has different semantics, and they were used as examples of why not to do AMP.
15:01:58 <nullvoid8_> but maybe I'm misremembering
15:02:17 <hpc> i think so
15:02:32 <nullvoid8_> something to do with parrellism
15:03:03 * hackagebot instant-hashable 0.2 - Generic Hashable instances through instant-generics  https://hackage.haskell.org/package/instant-hashable-0.2 (RenzoCarbonara)
15:08:07 <safinaskar> may i write "a `liftM2 (++)` b"?
15:10:03 <mniip> safinaskar, no
15:10:10 <mniip> only identifiers are allowed inside ``
15:10:17 <mniip> a single identifier, even
15:12:54 <codehero> but you can just do "let myfunction = liftM2 (++) in ..."
15:13:02 <codehero> then you can use `myfunction`
15:13:43 <safinaskar> mniip: codehero: thanks
15:14:45 <mauris_> should a good haskell program compile without warnings with -Wall on?
15:15:23 <jsidfofo> Can I extract the type 'a' from a value of type 'Proxy a' ?
15:15:37 <codehero> > liftM2 (++) (Maybe "Hello") (Maybe " world")
15:15:38 <lambdabot>      Not in scope: data constructor ‘Maybe’
15:15:39 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)    Not in ...
15:15:39 <lambdabot>      Perhaps you meant variable ‘maybe’ (imported from Data.Maybe)
15:15:40 <codehero> hm
15:15:41 <safinaskar> @hoogle [m a] -> m [a]
15:15:41 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:15:41 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:15:41 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
15:15:47 <codehero> so that's not how it's used
15:15:54 <mauris_> codehero, you're looking for Just
15:16:01 <codehero> lol
15:16:03 <codehero> i'm an idiot
15:16:08 <mauris_> http://lpaste.net/138366 <-- ghc's -Wall complains about this pattern match
15:16:15 <codehero> > liftM2 (++) (Just "Hello") (Just " world")
15:16:16 <lambdabot>  Just "Hello world"
15:16:18 <mauris_> but "obviously" it can never fail
15:16:31 <codehero> perhaps i should take a break from reading real world haskell
15:16:42 <codehero> mauris_: what does it say?
15:16:48 <mauris_> what is the right way to handle this? a "nonsensical" _ -> undefined clause, or some kind of "suppress this warning" annotation?
15:17:09 <codehero> umm
15:17:24 <mauris_> well, "Pattern match(es) are non-exhaustive", as i'm matching only three Char values out of a million and something
15:17:35 <codehero> :t oneOf
15:17:36 <lambdabot> Eq a => [a] -> Splitter a
15:18:08 <codehero> well. 
15:18:14 <mniip> mauris_, -fno-warn-something :)
15:18:16 <codehero> it's exhaustive
15:18:31 <pavonia> mauris_: It could fail in theory if the implementation of oneOf becomes wrong in a future version of parsec. The usualy way to fix this is adding a case like '_ -> error "..." '
15:18:36 <Mauke> choice [ char op >> return val | (op, val) <- [('*', Multiply), ('/', Divide), ('%', Modulo')] ]
15:19:03 <codehero> mauris_: you could just add '_ -> error "shouldn't happen"'
15:19:25 <codehero> oh. pavonia already said that
15:20:06 <pavonia> jsidfofo: What do you mean by extract?
15:20:20 <mauris_> @src choice
15:20:20 <lambdabot> Source not found. Maybe you made a typo?
15:20:48 <codehero> @hoogle choice
15:20:48 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
15:20:48 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
15:20:48 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
15:20:58 <Mauke> choice ps           = foldr (<|>) mzero ps
15:20:59 <Pamelloes> I'm trying to install base-orphans with nix and the build is failing because Int32 is not in scope. Is there a simple solution?
15:21:24 <mauris_> Mauke, wouldn't it be empty?
15:21:29 <codehero> Pamelloes: you should probably go to #nix
15:21:32 <codehero> ubb
15:21:34 <codehero> *umm
15:21:36 <codehero> #nixos
15:21:38 <mauris_> (instead of mzero)
15:21:39 <codehero> that's what i meant
15:21:40 <Pamelloes> codehero: Will do :)
15:21:54 <Mauke> I got it from http://hackage.haskell.org/package/parsec-3.1.9/docs/src/Text-Parsec-Combinator.html#choice
15:23:10 <jsidfofo> How do I extract the type parameter of a type?
15:24:06 <mauris_> also, similarly, should i write _ <- when discarding results from parsers?
15:24:52 <mauris_> it looks a bit un-haskelly, and throwing away results is pretty standard for parser combinators, but i get a big ol' warning if i don't make it explicit
15:25:03 <mauris_> i guess *> is also an option!
15:26:12 <codehero> well. if you want to get rid of compiler warnings use _ <-
15:26:24 <codehero> also makes it easier to see when you're throwing stuff away
15:26:35 <codehero> otherwise you could also use >>= and >>
15:31:04 <ttt_fff> is there a decent pure-haskell kv store? I don't need documents; I just want a document store
15:31:07 <ttt_fff> err, a value store
15:31:12 <ttt_fff> someting like bitcask, but in haskell
15:33:04 * hackagebot instant-deepseq 0.2 - Generic NFData instances through instant-generics  https://hackage.haskell.org/package/instant-deepseq-0.2 (RenzoCarbonara)
15:33:10 <jsidfofo> pavonia: I mean I have Identity String and I want to get String
15:33:18 <jsidfofo> for example
15:33:31 <Cale> jsidfofo: runIdentity
15:33:40 <Cale> jsidfofo: Or pattern match on the constructor
15:33:43 <jsidfofo> Cale: I want the type, not the value
15:33:50 <Cale> jsidfofo: hm?
15:34:07 <Cale> jsidfofo: Maybe it would be best to explain more about what you're trying to do.
15:34:25 <jsidfofo> Cale: I'm trying to use servant and associate routes with handlers directly
15:34:44 <jsidfofo> Cale: basically the route is a type
15:35:16 <jsidfofo> So I want to make some sort of (TYPE, HANDLER) association
15:35:36 <jsidfofo> I was thinking of creating a Proxy value with the type
15:35:38 <Cale> jsidfofo: Types don't necessarily exist at runtime.
15:35:42 <jsidfofo> then extracting it when I needed the type 
15:35:59 <Cale> If you have a Typeable instance, then you can do things to compare runtime type information.
15:36:01 <jsidfofo> Cale: I don't need them at runtime, just compile time
15:36:28 <Cale> Well, types aren't values, while presumably a handler would be?
15:36:35 <Cale> Maybe you just want a type class?
15:36:41 <jsidfofo> yes
15:36:48 <jsidfofo> the route is a type and the handler is a value
15:36:50 <jsidfofo> in servant
15:38:04 <jsidfofo> Cale: http://haskell-servant.github.io/tutorial/api-type.html
15:38:04 * hackagebot instant-aeson 0.2 - Generic Aeson instances through instant-generics  https://hackage.haskell.org/package/instant-aeson-0.2 (RenzoCarbonara)
15:38:06 * hackagebot instant-bytes 0.2 - Generic Serial instances through instant-generics  https://hackage.haskell.org/package/instant-bytes-0.2 (RenzoCarbonara)
15:38:11 <jsidfofo> see the UserAPI is the route and it is a type
15:38:23 <Cale> Yeah, I see, this is some crazy type level shenanigans.
15:38:45 <Cale> Looks a bit like session types
15:38:58 <jsidfofo> the problem I see with this library is that you can't currently associate the route directly to the handler
15:39:14 <jsidfofo> and I'm trying to write something to do that
15:40:26 <jsidfofo> Cale: what happens is that all of the routes are combined into one type and all of the handlers into one value
15:40:46 <jsidfofo> the problem is that you have to do this manually, specify them in the correct order, etc
16:04:45 <ril> hey what are everyone's favorite books on category theory?
16:06:43 <raichoo> ril: Awodey
16:07:48 <codehero> hmmm
16:07:51 <codehero> :t concat
16:07:51 <lambdabot> Foldable t => t [a] -> [a]
16:08:08 <codehero> does anyone have an example of concat that isn't [[a]] -> [a] ?
16:08:33 <coppro> codehero: Data.Set?
16:09:01 <codehero> hm
16:09:38 <exio4> codehero: may I say `join`? :P
16:10:15 <codehero> isn't that just the same?
16:13:32 <exio4> @type join 
16:13:33 <lambdabot> Monad m => m (m a) -> m a
16:13:47 <refefer> hmm, what should I used for the equivalent of execvp?
16:16:59 <codehero> callProcess?
16:17:07 <codehero> https://github.com/C0DEHERO/Hgamelaunch/blob/master/Hgamelaunch/GameTools.hs#L67
16:17:13 <codehero> not sure if that's what you're looking for
16:17:53 <codehero> actually
16:17:55 <codehero> yes
16:17:57 <codehero> that's the one
16:18:00 <codehero> the one you need
16:18:02 <codehero> and want
16:18:31 <refefer> codehero: hmm, doesn't seem to replace the stack
16:19:25 <codehero> oh
16:19:31 <codehero> it needs to replace the stack
16:19:50 <refefer> yeah.  I want whatever the most barebones to os exec there is
16:19:53 <geekosaur> replace the "stack"?
16:19:56 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-Process.html#v:executeFile anyway
16:20:26 <geekosaur> the portable stuff in System.Process doesn't support it (because Windows doesn't)
16:20:44 <refefer> aha, ok
16:21:08 <safinaskar> how to convert (Strict, Q Type) to Q (Strict, Type)? Q is monad
16:21:46 <hpc> convert (s, q) = do {t <- q; return (s, t)
16:21:47 <hpc> }
16:22:06 <hpc> it probably already exists in a very generic way
16:22:09 <refefer> geekosaur: yep, that seems to do it, thanks
16:22:13 <hpc> but i can't remember what it's called
16:22:46 <safinaskar> i want to convert inside an expression. and i want this convertation to be as beautiful as possible
16:23:10 <hpc> safinaskar: use the definition i gave you
16:23:57 <safinaskar> okey, maybe there is a function, which converts (Q a, Q b) to Q (a, b)?
16:26:20 <exio4> safinaskar: uncurry (liftA2 (,)) for the second, uncurry (fmap . (,)) for the second, I think
16:27:01 <hpc> i would hardly call that "as beautiful as possible" though ;)
16:27:17 <mniip> [01:18:54] <safinaskar> how to convert (Strict, Q Type) to Q (Strict, Type)? Q is monad
16:27:24 <mniip> :t sequenceA
16:27:25 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
16:27:42 <mniip> if memory serves me right, (e, ) is traversable
16:28:06 <exio4> @type sequenceA (42, Just 'a') 
16:28:07 <lambdabot> Num t => Maybe (t, Char)
16:28:16 <exio4> > sequenceA (42, Just 'a') 
16:28:18 <lambdabot>  Just (42,'a')
16:36:02 <bq_> alynn: yes. group is a monoid, monoid is a category
16:40:26 <bq_> alynn: monad is a monoid whose object is endofunctor
16:42:14 <benzrf> bq_: uh
16:42:26 <benzrf> bq_: i think you mean 'groups are monoids, monoids are categories, monads are monoids'
16:43:41 <j4gn4r> >
16:45:17 <bq_> benzrf: i said that because group is a special monoid...
16:46:29 <benzrf> group is not a monoid
16:46:30 <benzrf> groups are monoids
16:47:48 <jsidfofo> Can I somehow get the path of a built binary using stack?
16:48:20 <bq_> benzrf: what's significant  in those notation?
16:48:33 <benzrf> bq_: is english not your first language?
16:49:45 <bq_> no. can you explain further?
16:49:56 <benzrf> ah
16:50:30 <benzrf> saying 'group is this way' doesnt mean that all groups are that way
16:50:38 <benzrf> it means that some thing called 'group' is that way
16:52:58 <bq_> yes i mean all groups
16:54:34 <OceanSpray> GHC.TypeLits provides a CmpNat type family that returns a type of kind Ordering
16:54:41 <OceanSpray> how do I actually use that Ordering?
16:54:58 <OceanSpray> is there a type level if in GHC, or do I have to define one myself?
16:55:35 <OceanSpray> alternative, how do I use (Succ n) with GHC's built-in Nat literals?
16:57:06 <bq_> benzrf: why associative and identity are so important in categories or monoids
16:58:26 <bq_> benzrf: why these constraints? why not other constraints?
17:00:03 <benzrf> bq_: because they are the ones that are useful
17:00:16 <johnw> bq_: those are the laws chosen by the inventors of category theory, who found them to be sufficiently expressive
17:00:23 <echolot> associative - means can be applied in any order... so less confusing?
17:00:32 <johnw> as for why they are important in monoids, that's simply what it means to be a monoid
17:00:39 <refefer> next question: how to properly lex a string into a runProcess compatable version?
17:01:11 <refefer> say I had "ls -al /foo", I'd like it to be ("ls", ["-al", "/foo"]), while working with quotes and all that gnarliness
17:01:26 <johnw> bq_: semigroups (dropping identity from a monoid)  are also quite handy
17:07:49 <bq_> johnw: why the inventors of category theory deem only these 2 constraints are needed in order to abstract away any mathematic structure? they just define that way, reason not given.
17:09:00 <jsidfofo> How can create a Dockerfile for my project which uses stack so that I can run the build binary in a container?
17:09:01 <johnw> bq_: in math you seek minimal structure for maximal expressivity; how you get there varies.  It would be nice to have a historical account in this case, but I'm not aware of one yet.
17:10:03 <cads> Hey all
17:10:35 <cads> I'm looking for a way to work graphically with string diagrams in monoidal categories
17:10:40 <scutigera> refefer: generally you just need to split it into words. "words" will do that to a string.
17:10:54 <scutigera> >words "ls -al /foo"
17:11:05 <cads> I seem to remember that someone had something that they were using to work with a graphical calculus of reversible computation, or linear logic, or something like this
17:11:11 <scutigera> @words "ls -al /foo"
17:11:11 <lambdabot> Unknown command, try @list
17:12:02 <cads> I've been reading Bob Coecke's Kindergarten Quantum Mechanics, and the graphical calculus presented there is really bold, colorful  and simple to use
17:12:20 <cads> The paper: http://arxiv.org/pdf/quant-ph/0510032v1.pdf
17:12:37 <scutigera> @run words "ls -al /foo"
17:12:38 <lambdabot>  ["ls","-al","/foo"]
17:13:19 <cads> I think it would be really neat to manually interact with those diagrams in an environment that enforces the correct rules. 
17:13:30 <refefer> scutigera: yeah, the problem is that you run into cases where quoted items need to be parsed separately
17:13:56 <refefer> eg. ls -al "/foo/bar baz" -> ["ls", "-al", "/foo/bar baz"]
17:14:23 <refefer> I could write a simple parser, but was hoping something was hiding in unix or some such
17:15:13 <scutigera> refefer: well i figured there was a catch...
17:15:54 <refefer> scutigera: always is, right :)
17:16:53 <scutigera> and just for the record. i figured you knew abou words, but i'm always desperate for a question i can actually answer ;-)
17:18:08 <refefer> scutigera: no worries!
17:18:17 <scutigera> for example, i don't understand anything that cads wrote...lol
17:18:30 <scutigera> well- bold. colorful. simple.
17:21:12 <geekosaur> refefer, it's called the shell and most alternatives get corner cases wrong
17:21:24 <Lokathor> so in haskell, if could be a function rather than a language construct, and it'd be pretty much the same, right?
17:21:56 <scutigera> Lokathor. if _is_ a function, isn't it ?
17:22:12 <scutigera> coated with syntactic sugar
17:22:15 <Lokathor> oh
17:22:28 <scutigera> @type if
17:22:29 <lambdabot> parse error in if statement: naked if statement
17:22:36 <scutigera> then again...
17:22:46 <geekosaur> if is not a function
17:22:50 <Lokathor> it's an *expression*, but i don't think it's a funciton
17:22:51 <scutigera> drat
17:23:46 <Lokathor> you can write a myif function without using an if construct, but i'm wondering if there's an example where it'd make a difference
17:24:04 <Hijiri> if you wanted to pass it to other functions
17:24:05 <scutigera> at a low level isn't if re-written as a case ?
17:24:06 <Lokathor> in non-lazy languages you need if as a construct or special form so that you don't evaluate all the arugments early
17:24:28 <refefer> geekosaur: yes, I know.  this is a follow up to the runProcess question from before
17:24:47 <refefer> I don't care about full evaluation of it, just the breaking of chunks
17:25:38 <Lokathor> Hijiri, you'd be able to pass myif, but i mean if there's a situation where having if be a language construct rather than a builtin funciton like id or (&&) matters.
17:25:46 <ttt_fff> is there any relation between frp (functiaonl reactive programing) and react (fb) ?
17:25:58 <ttt_fff> the two are often mentioend together ... but seem orthogonal now that I think about it
17:26:04 <refefer> ttt_fff: no, there really isn't
17:26:11 <bq_> echolot: ok that's useful. how about identity?
17:32:17 <safinaskar> exio4: thanks
17:34:15 <Hijiri> Lokathor: I think it just allows different syntax that's also similar to imperative if-else (which could arguably be a bad thing too)
17:34:27 <Hijiri> though if we had mixfix operators like agda, we could have that tooo
17:47:08 <refefer> hmm, anything prettier than the builtin vim syntax?
18:04:08 <kalloc> Hi
18:04:23 <kalloc> You never want multiply return values? 
18:04:55 <Axman6> huh?
18:05:00 <dramforever> didn't get that, example
18:05:01 <dramforever> ?
18:05:26 <geekosaur> tuples work fine for ad hoc multiple return values
18:05:28 <dramforever> kalloc: can you give an example?
18:06:16 <Axman6> unboxed tuples give essentially the same result
18:06:20 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.1.0/Data-List.html#v:break
18:06:36 <dramforever> ...waiting for kalloc to respond...
18:07:24 <refefer> was this a no context question?
18:07:37 <dramforever> seems so
18:09:12 <dramforever> geekosaur: btw what's that lambda.haskell.org?
18:09:25 <dramforever> root page says "It works!"
18:09:51 <geekosaur> I think it's just there to serve static content or something. might ask in #haskell-infrastructure
18:10:06 <dramforever> okay
18:10:23 <dramforever> maybe just a CDN or something
18:11:17 <geekosaur> also not sure why they don;t use downloads.h.o like ghc etc. do...
18:12:00 <dramforever> hmm...TIL semigroup will be moved into base in 7.12
18:12:34 <kalloc> let f x, y, z = x+1, y+2, z+3
18:12:43 <kalloc> for example
18:13:07 <dramforever> > let f x y z = (x + 1, y + 2, z + 3) in f 40 70 90 -- pretty much it
18:13:09 <lambdabot>  (41,72,93)
18:13:11 * hackagebot ig 0.4 - Bindings to Instagram's API.  https://hackage.haskell.org/package/ig-0.4 (FelipeLessa)
18:13:18 <kalloc> no
18:13:20 <kalloc> without tuple
18:13:30 <geekosaur> why?
18:13:31 <kalloc> tuple is an illusion 
18:13:45 <Axman6> what?
18:13:49 <geekosaur> ah, you don't understand partial application and therefore think there is syntax available?
18:13:57 <dramforever> but why you need "real" multiple return values?
18:14:12 <dramforever> any benefits?
18:14:26 <kalloc> hm, realy, I don't need multiple return values
18:14:31 <Axman6> we have "real" multiple return values, using unboxed tuples
18:14:41 <kalloc> but, I dont' like Int->Int->...->Int
18:14:49 <dramforever> kalloc: why?
18:14:55 <dramforever> oh that makes sense
18:15:10 <kalloc> because in one sequence I should write in and out
18:15:19 <dramforever> yes it is
18:15:27 <kalloc> it's strange
18:15:27 <dramforever> it's yet another illusion =)
18:15:28 <Axman6> f :: Int -> Int -> Int -> (#Int,Int,Int#)
18:15:37 <dramforever> kalloc: it's just an illusion
18:15:56 <kalloc> why?
18:16:03 <kalloc> what do you mean 
18:16:08 <Axman6> I still don't understand what the problem is...
18:16:14 <kalloc> last statement is return 
18:16:16 <dramforever> all functions in haskell take one argument
18:16:29 <dramforever> -> is right associative
18:16:38 <dramforever> so Int -> Int -> Int is really Int -> (Int -> Int)
18:16:45 <dramforever> which allows you to do...
18:16:47 <dramforever> :t (+)
18:16:48 <lambdabot> Num a => a -> a -> a
18:16:51 <dramforever> :t (+) 2
18:16:52 <lambdabot> Num a => a -> a
18:17:02 <dramforever> > let f = (+) 2 in f 4 + f 5
18:17:03 <lambdabot>  13
18:17:16 <kalloc> hm
18:17:17 <dramforever> :t (2 +) -- (almost) syntax sugar for (+)
18:17:18 <lambdabot> Num a => a -> a
18:17:23 <dramforever> sorry for (+) 2
18:17:49 <dramforever> kalloc: the "last part" thing is a illusion, see?
18:17:57 <kalloc> yes
18:18:20 <kalloc> it's better than Int->(Int->Int) 
18:18:24 <dramforever> wait there's a blog post on that...
18:18:33 <kalloc> I glad to read 
18:18:41 <dramforever> someone posted it to reddit, lemme copy the link here
18:18:47 <Axman6> I STILL have no idea what the problem is :(
18:19:12 <kalloc> all right, I asked just about syntax 
18:19:12 <dramforever> Axman6: IIUC it's "wtf is Int -> Int -> Int"
18:19:23 <dramforever> kalloc: and the answer is: it's not just syntax
18:19:29 <kalloc> :) yeah
18:19:36 <dramforever> here we go: http://tonymorris.github.io/blog/posts/haskell-functions-take-one-argument/
18:19:36 <Axman6> right
18:20:23 <Axman6> > let upperCase = map toUpper in upperCase "Hello kalloc, currying lets us do this"
18:20:25 <lambdabot>  "HELLO KALLOC, CURRYING LETS US DO THIS"
18:21:06 <Axman6> because map takes one argument (a function from a to b) and returns a new function, we can define other functions in terms of partially applied different functions
18:21:53 <kalloc> dramforever: i'll read, thank you
18:21:59 <dramforever> =)
18:22:36 * dramforever wonders when can Arrows and Profunctors be merged
18:23:22 <dramforever> so we have something like class (Category p, Strong p) => Arrow p where arr :: (a -> b) -> p a b
18:23:51 <bitemyapp> First arg of an Arrow is contravariant?
18:23:51 <coppro> hey all. I'm considering a project for some database code
18:23:53 <dramforever> some people talked about this last year
18:24:00 <dramforever> bitemyapp: sure it is
18:24:07 <coppro> is anyone aware of code to allow you to store an Enum datatype in the database safely?
18:24:32 <dramforever> also we can even get rid of ArrowChoice and ArrowLoop
18:24:40 <Axman6> coppro: using fromEnum/toEnum allows you to store Ints 
18:24:44 <coppro> so that if you change the enum fields, you can re-schema your database appropriately
18:24:46 <dramforever> because they are just (IIRC) Choice and CoStrong
18:24:58 <bitemyapp> dramforever: is the correspondence formalized anywhere?
18:25:02 <Zemyla> dramforever: You don't even need arr to be an arrow.
18:25:04 <coppro> Axman6: yes, but then the data is extremely fragile. If the Enum definition changes, you're screwed
18:25:10 <dramforever> dunno
18:25:20 <Zemyla> :t \f -> rmap f id
18:25:21 <lambdabot> (b -> c) -> b -> c
18:25:28 <dramforever> :t rmap
18:25:29 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
18:25:50 <Zemyla> :t \f -> rmap f Control.Category.id
18:25:51 <bitemyapp> https://hackage.haskell.org/package/profunctors-3.1.1/docs/Data-Profunctor.html#t:WrappedArrow seems conclusive
18:25:51 <lambdabot> (Category p, Profunctor p) => (b -> c) -> p b c
18:26:00 <bitemyapp> http://blog.sigfpe.com/2011/07/profunctors-in-haskell.html mentions it.
18:26:02 <dramforever> oh stupid...
18:26:09 <dramforever> I forgot about the Category thing
18:26:21 <dramforever> Zemyla: yes =)
18:26:31 <dramforever> so wait...arrow is obsolete?
18:26:41 <bitemyapp> dramforever: if you're willing to use profunctors...possibly?
18:26:52 <dramforever> sure I'm willing to
18:27:00 <bitemyapp> so when does profunctorized FRP land? :P
18:27:20 <geekosaur> not entirely obsolete, but was found to be less general than hoped. generalizing it led to Applicative on the one hand and Control.Category on the other
18:27:26 <dramforever> yeah
18:27:48 <bitemyapp> geekosaur: is Profunctor more general than Arrow?
18:27:55 <dramforever> bitemyapp: yes
18:28:08 <dramforever> :t \f x -> x >>^ f
18:28:09 <lambdabot> Arrow a => (c -> d) -> a b c -> a b d
18:28:27 <dramforever> :t (^>>)
18:28:27 <geekosaur> well, that's always a dangerous claim in math... usually generalizing one thing loses generality in others
18:28:28 <lambdabot> Arrow a => (b -> c) -> a c d -> a b d
18:28:35 <geekosaur> s/one thing/direction/
18:28:38 <geekosaur> er
18:28:42 <geekosaur> s/one thing/in one direction/
18:28:54 <bitemyapp> any examples of something expressible in one that isn't in the other?
18:29:08 <dramforever> forgetful profunctors?
18:29:17 <dramforever> newtype Forget a b = Forgotten b
18:29:22 <dramforever> lol names
18:30:01 * dramforever seems to have started to get the hang of it
18:31:28 <dramforever> wait lemme get this straight: (Category p, Strong p) <=> Arrow p?
18:32:28 <dramforever> hmm ... http://hackage.haskell.org/package/profunctors-5.1.1/docs/Data-Profunctor-Monoid.html
18:32:32 <bitemyapp> Arrow's stronger than Profunctor?
18:32:39 <dramforever> that reminds me of...monads!
18:32:42 <bitemyapp> because Strong is separate from Profunctor?
18:32:45 <dramforever> bitemyapp: =) yes
18:32:52 <bitemyapp> whereas Arrow bakes it in
18:33:48 <ttt_fff_> how does success typing (Erlang) differ from standard HM type checking? (like ocaml / haskell)
18:34:09 <Axman6> coppro: you can also save them as String/Text - those are about the only two good options, particularly if the definitions can change
18:35:01 <coppro> Axman6: I'm thinking of an alternate solution. Just checking there aren't any already :)
18:45:17 <Zemyla> You know, there are actually Haskell functions that take more than one argument.
18:45:28 <Zemyla> Primops can't be partially applied.
18:45:38 <dramforever> sigh
18:45:50 <shachaf> Primops aren't Haskell functions.
18:45:53 <dramforever> that's all I can say about that
18:47:46 <Zemyla> Sorry, just being a little pedantic.
18:54:37 <ray-charles> Hello.
18:55:04 * dramforever is helloed
18:55:30 <ray-charles> What is a common use for Haskell?
18:55:43 <ray-charles> a "poster child" if you will
18:56:13 <dramforever> iirc facebook's spam filter is in haskell
18:56:20 <dramforever> I don't know about the details, though
18:58:44 <ray-charles> hmmm, interesting
18:58:48 <kristof> Yeah, Facebook contributes to Haskell.
18:58:51 <hodapp> Facebook does that and they wrote a paper as well on a (maybe related) application.
18:59:00 <hodapp> called 'There Is No Fork'
18:59:19 <kristof> ray-charles: Haskell itself is a poster child for pure functional programming.
18:59:29 <hodapp> if it's made it to a Facebook blog, I'd say that qualifies as a poster child.
18:59:30 <dramforever> http://simonmar.github.io
18:59:57 * dramforever read the only post there (!) yesterday
19:00:00 <kristof> ray-charles: It's a different way of writing general applications. So for instance, if you look at Parsec programs, and consider the way you might build parsers in other languages, you will probably be impressed. If you are not impressed then you likely have never written a parser. :)
19:00:27 * dramforever mumbles something about attoparsec
19:01:08 <coppro> ok this is a dumb question
19:01:16 <coppro> but I can't find any documentation on actually using configuration flags in cabal
19:01:57 <kristof> ray-charles: The biggest draw of functional programming is this: the ability to compose things. With minimal glue, I should take a "function" A -> B, and a function B -> C, glue them together, and get a 'function' A -> C. That notion of function can be generalized to surprising lengths.
19:02:20 <dramforever> coppro: this? https://www.haskell.org/cabal/users-guide/installing-packages.html#controlling-flag-assignments
19:02:36 <coppro> yes, thanks
19:03:55 <coppro> dramforever: wait, how do I do that with stack?
19:04:06 <dramforever> I would expect it to be the same
19:04:06 <ray-charles> kristoff: thanks. that appeals to me. I'm a n00b
19:04:26 <dramforever> i.e. stack install foo -fsomeflag -f-someotherflag
19:05:01 <dramforever> ray-charles: haskell is really mind-blowing, if you ask me
19:05:05 <dramforever> oh he/she's left
19:05:24 <coppro> it appears not to be
19:05:34 <dramforever> sigh...
19:06:29 <matsuura> I've been a bit upset by how often I tend to optimize code. It's very efficient, but having reality marked in red for correction becomes a little overwhelming some times.
19:06:42 <BotchlaOffUrself> THIS IS MY MESSAGE TO ALL OF FREENODE
19:06:53 <BotchlaOffUrself> BOTCHLAB WILL DIE VERY SHORTLY
19:06:57 <BotchlaOffUrself> BY HIS OWN HANDS
19:06:58 <peddie> @where ops
19:06:58 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
19:07:09 --- mode: ChanServ set +o edwardk
19:07:19 <matsuura> >_>
19:07:35 <dramforever> bizarre
19:07:39 --- mode: edwardk set +b BotchlaOffUrself!*@*
19:10:33 <mniip> interesting
19:11:05 <mniip> because botchlab doesn't even visit this place
19:13:51 <Axman6> what on earth is botchlab :\
19:14:35 <mniip> it's a somewhat known figure on freenode
19:14:41 <mniip> #fndrama
19:15:08 <mniip> er, that's not supposed to be a channel but rather a tag
19:15:10 * dramforever /j #fndrama, disappointed
19:15:13 <dramforever> sigh
19:15:32 <mniip> octothorpetags you know, the hip thing
19:16:00 <dramforever> I know nothing about freenode other than "freenode is an IRC network"
19:16:16 <dramforever> and, of course, "haskell related channels are there"
19:16:44 <mniip> well, it's an interesting place
19:18:52 <dramforever> sigh
19:22:27 <leonepavone> lastlog > 10
19:25:51 <ttt_fff_> haskell has totally ruined me
19:25:59 <ttt_fff_> i'm learning erlang, and the first thing I care about is "how do I get dialyzer to work"
19:26:10 <ttt_fff_> it's at this point where if I can't get a computer to tel me that my prog if well typed, I don't want to code
19:27:05 <dramforever> wait erlang is dynamically typed?
19:27:11 <bitemyapp> ttt_fff_: lmao
19:27:15 <bitemyapp> ttt_fff_: dialyzer is going to upset you
19:27:19 <bitemyapp> dramforever: yeah
19:27:27 <dramforever> TIL
19:27:53 <bitemyapp> at the time it was invented, people didn't really know how to type the sorts of things it did I think.
19:27:56 <bitemyapp> (80s)
19:27:59 <ttt_fff_> bitemyapp: how id dialyzer going to let me down?
19:28:06 <bitemyapp> ttt_fff_: no no, let it be a surprise.
19:28:10 <bitemyapp> ttt_fff_: let life happen to you.
19:28:13 * hackagebot riemann 0.1.0.2 - A Riemann client for Haskell  https://hackage.haskell.org/package/riemann-0.1.0.2 (telser)
19:28:43 <nitrix> ttt_fff_: Provably correct is a big thing. I don't think any mathematician would go on a rampage making claims they can't back up.
19:28:57 <ttt_fff_> nitrix: ?
19:29:26 <nitrix> ttt_fff_: Similarly, I think a software engineer shouldn't write a program that isn't guaranteed to be behave at least minimally correctly.
19:29:37 <dramforever> nitrix: no no no keep the cat in the bag
19:30:01 <ttt_fff_> bitemyapp: you'd make a great doctor; someone is wrong with you, but I'm not goign to tell you, let life happen to tyou
19:31:26 <Hijiri> hopefully dialyzer doesn't have the risk of being permanently debilitating
19:31:42 <Hijiri> but I guess a doctor would tell you about diseases that would be temporarily annoying too
19:32:25 <ttt_fff_> I think https://github.com/bitemyapp/learnhaskell needs pull requests about limitatins of the dialyzer
19:33:08 <dramforever> I think erlang needs pull requests about limitations of the dialyzer
19:33:10 <dramforever> FTFY
19:34:10 <bitemyapp> ttt_fff_: not going to tell somebody not to learn new things.
19:34:25 <bitemyapp> ttt_fff_: why would I talk about Erlang
19:34:28 <bitemyapp> on the guide?
19:46:56 <ttt_fff_> bitemyapp: can you explain how "sucess typing' differs from HM typing? I've read the erlang dialyzer man page 2 times, and I still don't get what it means by 'more general'
19:55:35 <lispy> ttt_fff_: http://www.it.uu.se/research/group/hipe/papers/succ_types.pdf
20:04:29 <FH> hi guys, does someone know how can we combine take and cycle function? when it runs > "func 4 [1,2]" the result will be "[1,2,1,2]"
20:04:52 <dramforever> :t cycle
20:04:53 <lambdabot> [a] -> [a]
20:04:54 <dramforever> :t take
20:04:55 <lambdabot> Int -> [a] -> [a]
20:05:13 <LordBrain> just compose them
20:05:21 <dramforever> no not going to work
20:05:29 <dramforever> FH: just combine them
20:05:46 <FH> how is that?
20:05:51 <dramforever> @let func n = take n . cycle
20:05:52 <lambdabot>  Defined.
20:05:53 <LordBrain> take 4 $ cycle [1,2]
20:05:53 <dramforever> :t func
20:05:54 <lambdabot> Int -> [a] -> [a]
20:06:06 <dramforever> @pl \n -> take n . cycle
20:06:06 <lambdabot> (. cycle) . take
20:06:15 * lispy suspects a HW problem
20:06:17 <dramforever> that's not going to be readable at all
20:06:21 <dramforever> oops
20:07:37 <lispy> > let func 4 [1,2] = take 4 (cycle [1,2]) in func 4 [1,2]
20:07:39 <lambdabot>  [1,2,1,2]
20:07:49 <lispy> That's really the simplest solution
20:08:04 <LordBrain> lol
20:11:35 <FH> this is for creating the function in .hs file
20:12:20 <dramforever> FH: obviously you haven't mastered creating functions in .hs files
20:12:21 <FH> if it is in the gch i know it is gonna be like what lispy wrote
20:12:34 <FH> yes. i'm a beginner
20:12:35 <dramforever> read the tutorial
20:12:37 <FH> :)
20:13:23 <lispy> Right so, in ghci you might type: let name = body in expression, but in the file it would just be name = body
20:13:39 <lispy> (at the "top level" that is)
20:13:54 <codehero> ^
20:24:44 <ttt_fff> is HM vs Sucess typing as follows: f :: a -> b -> c -> d in HM typing says: for all 'a 'b 'c, we get a 'd; in Success typing, it says: there exists some 'a 'b 'c, such that we output a 'd
20:32:51 <lispy> ttt_fff: yeah, that's how I understood it
20:33:31 <ttt_fff> according to #erlang, "-spec foo(number(), number()) -> number()" says "there exists integers a, b s.t. foo(a,b) is an integer" ;; but there's no way for me to say "forall integers a, b foo(a,b) is an integer" ; s/integer/numbers
20:33:37 <ttt_fff> lispy: man, this is one fucked up type system
20:33:48 <ttt_fff> I'm not used to thinking this way at all
20:33:48 <lispy> Did you read the paper I linked?
20:33:56 <lispy> They do motivate it
20:33:58 <ttt_fff> lispy: no, I'm reading the dialyzer manual + trying examples
20:34:08 <ttt_fff> or rather, the last chapter of LYSE
20:34:30 <lispy> The paper gives the inference rules, an algorithm, some examples, and the motivation/intuition.
20:34:42 <lispy> section 4 was helpful
20:35:16 <lispy> It's calculating the compliment of what HM typing is after
20:35:36 <lispy> They want to know the largest set of types for which you can gaurantee a type error
20:35:48 <nshepperd> erlang? I thought the idea was more that 'forall (x,y,z) :: Not (a,b,c). f x y z = ⊥'
20:36:35 <ttt_fff> lispy: would you mind linking the paper again?
20:36:38 <ttt_fff> I'll print it and read it this time
20:36:48 <nshepperd> 'Not' being some syntax I made up for the union of all types ≠ (a,b,c)
20:38:02 <lispy> ttt_fff:  http://www.it.uu.se/research/group/hipe/papers/succ_types.pdf
20:38:46 <ttt_fff> lispy: printing it now; thanks for the link
20:39:00 <lispy> NP!
20:48:03 <mjrosenb> so, is the only way to write my own deriving instance to use Data or something, then have all of my 'class' members be Data a => a -> foo
20:48:27 <dramforever> mjrosenb: there's a thing called DefaultSignatures
20:48:38 <pacak> mjrosenb: You can also use ghc generics
20:48:39 <dramforever> that allows the default implementation to have a different signature
20:49:13 <dramforever> and there's a thing called DeriveAnyClass, which basically just allows you to derive any class that you can just use all the default implementations of methods
20:49:27 <pacak> With DeriveAnyClass it might look something like data Foo = Bar deriving (Generic, MyClass)
20:49:59 <dramforever> the names of the types of ghc generics suck...
20:51:32 <pacak> :t confusing
20:51:33 <lambdabot> Applicative f => LensLike (Data.Functor.Kan.Rift.Rift (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
20:51:42 <pacak> dramforever: Can be worse.
20:51:53 <dramforever> no these types make sense
20:52:10 <dramforever> generics types don't...
20:52:51 <dramforever> Rift is for Applicative fusion, Yoneda is for Functor fusion
20:52:59 <dramforever> and together they enable...confusion
20:53:09 <dramforever> okay...
20:57:09 <mjrosenb> pacak: do you have a link explaining what ghc generics are and how to use them?
20:57:19 <ttt_fff> lispy: in the erlang success typing paper, is the argument for success typing one of: "even in the libraries you need to use to build your app, you can't HM type them, you can only success type them" -- therefore, if you want HM type, you have to rewrite much of the core libraries, no one is going to fucking do that, therefore you have to go for success typing?
20:57:32 <mjrosenb> dramforever: ditto for that.
20:57:59 <dramforever> http://hackage.haskell.org/package/base-4.8.0.0/docs/GHC-Generics.htm
20:57:59 <dramforever> https://wiki.haskell.org/Generics
20:58:01 <pacak>  https://wiki.haskell.org/GHC.Generics
20:59:16 <pacak> mjrosenb: It assumes you familiar with product types and sum types and some other stuff like that.
21:00:48 <gfixler> I'm vaguely recalling talk(s)/writeup(s) wherein ekmett put three co- words together
21:00:55 <gfixler> anyone know what I'm talking about? I can't find it again
21:01:22 <dramforever> costate comonad coalgebra?
21:01:26 <dramforever> must be lens
21:01:28 <gfixler> dramforever: that's it
21:01:30 <gfixler> thanks
21:01:58 * Axman6 considers starting a business named Cocategory Co., later to be renamed to CoCaCo
21:02:06 <scutigera> could somebody cosplain that ?
21:02:16 <Axman6> coyes
21:02:28 <gfixler> I enjoyed Axman6's talk on CoCaCo at GoGaRuCo
21:03:17 * hackagebot fractals 0.1.0.0 - A collection of useful fractal curve encoders  https://hackage.haskell.org/package/fractals-0.1.0.0 (sdekker)
21:03:54 * dramforever found a paper on generics, but it's IIUC it's UHC http://dreixel.net/research/pdf/gdmh.pdf
21:04:05 <dramforever> also the colored code looks....weird
21:07:36 * dramforever is surprised by how GHC Generics deals with recursive ADTs
21:08:09 * gfixler just learned from conal that recursive ADTs are all there is to denotational semantics
21:12:50 <edwardk> Axman6: i registered coinductive.com a year or two back =)
21:13:10 <edwardk> never did figure out what i wanted to do with it
21:13:30 <Axman6> CoinCo 
21:13:36 <dramforever> you already have comonad.com, be happy.........
21:13:51 <edwardk> dramforever: i probably have 50 other domains out there
21:13:59 <tnks> maybe make it an infinitely recursive redirection to inductive.com or something.
21:14:05 * dramforever doesn't even have a proper blog
21:14:12 <edwardk> tnks: heh, maybe i should just make it redirect to itself
21:14:24 <dramforever> no no, you have to make it productive
21:14:32 <gfixler> edwardk: maybe something fun, like this: http://foldl.com/
21:14:45 <edwardk> dramforever: good point
21:14:59 <scutigera> it just keeps adding 1
21:15:03 <scutigera> will it ever stop ???
21:15:05 <coppro> can someone explain the definition of YesodAuthPersist for me? http://hackage.haskell.org/package/yesod-auth-1.2.0/docs/src/Yesod-Auth.html#YesodAuthPersist
21:15:11 <coppro> is it a type class?
21:15:15 <gfixler> scutigera: you can try this one instead: http://foldr.com/
21:15:26 <scutigera> that's better. thanks.
21:15:28 <dramforever> coppro: it's a constraint synonym
21:15:45 <scutigera> doh! not cool bro
21:16:10 <dramforever> coppro: so you can say YesodAuthPersist Foo => ...
21:16:14 <dramforever> instead of that long list
21:16:24 <coppro> dramforever: I see. What does writing an instance of it mean?
21:16:41 <dramforever> coppro: you can't
21:16:51 <dramforever> the only use is to save code length
21:17:05 <scutigera> edwardk: you are one of the authors of the gl lib ?
21:17:11 <edwardk> i am
21:17:18 <coppro> dramforever: I would agree with you if I don't have code here which says "instance YesodAuthPersist App" and which compiles
21:17:28 <edwardk> polarina wrote the original converter and then i packaged it up and made it pretty
21:17:49 <scutigera> what is the main diff between it and the opengl lib ? i'm trying to figure out if which i should be using for opengl hackery
21:17:57 <mjrosenb> pacak: product types being (a,b) and sum types being Either a b?
21:17:59 <dramforever> coppro: what class methods did you define?
21:18:31 <dramforever> wow the famous gl package
21:18:33 <edwardk> scutigera: gl is a low level binding, OpenGL is a high level binding that doesn't expose enough of the internals of any of its classes for you to actually use any of the abstractions it supplies.
21:18:34 <pacak> mjrosenb: Yep. In generics that's a :*: b and a :+: b
21:18:47 <dramforever> coppro: forget about it, I don't know why....
21:18:54 <mjrosenb> seems simple enough.
21:19:00 <edwardk> OpenGLRaw has been stealing more and more from gl these days removing a bit of its competitive advantages
21:19:03 <edwardk> which I'm more than Okay with
21:19:18 <edwardk> I mostly wanted to spur innovation, since we'd stagnated for several years
21:19:25 <pacak> mjrosenb: (a,b,c) will be something like (a :*: (b :*: c))
21:19:34 <lispy> edwardk++
21:19:48 <gfixler> edwardk: doesn't gl get autobuilt on each new spec release?
21:19:57 <scutigera> ok that explains why i see more pointer/mem alloc stuff in gl code.
21:20:10 <edwardk> as a consequence of 'gl' existing, OpenGLRaw now supports versions of gl other than 3.3, lifts things automatically into MonadIO, etc.
21:20:28 * dramforever is still in foldl.com
21:20:40 <scutigera> so it seems that using gl from the start shouldn't be any sort of disadvantage and might actually be an advantage ? maybe ?
21:20:43 <edwardk> and OpenGL's new StateVar package is repackaged form my quine code.
21:20:59 <edwardk> scutigera: https://github.com/ekmett/quine is written using gl
21:21:24 <edwardk> i personally found the current OpenGL package frustrating enough that it was worth dogfooding my own binding. ;)
21:21:27 <scutigera> oooooh- shiny
21:21:33 <codehero> very shiny
21:21:33 <scutigera> lol
21:21:38 <coppro> dramforever: I didn't. It's in the Yesod scaffolding
21:21:38 <dramforever> cooool
21:21:48 <dramforever> coppro: =( no more suggestions
21:22:03 <mjrosenb> pacak: so is it possible to differentiate (a,b,c) from (a,(b,c)) ?
21:22:05 <dramforever> edwardk: IIRC there isn't a lot of code in the gl package
21:22:16 <dramforever> most are generated aren't they
21:22:17 <edwardk> mjrosenb: (a,(b,c)) has an extra _|_
21:22:25 <codehero> i'm so excited for vulkan
21:22:29 <dramforever> mjrosenb: (a, (b, c)) is two levels
21:22:34 <edwardk> dramforever: almost all of it, about ~7 modules of real code are in there, several hundred generated ones
21:22:39 <dramforever> =)
21:22:57 <dramforever> looks very wtf-ful
21:23:10 <edwardk> mjrosenb: _|_, (_|_, _|_) and (_|_,(_|_,_|_)) are all distinguishably different in the latter
21:23:13 <pacak> mjrosenb: On generics level you will be operating with (a,b,c) in the first case and (a, d) where d = (b,c) in the second one.
21:23:16 <scutigera> i've been looking at some gl code and a little afraid of seeing explicity alloc'ing.
21:23:40 <edwardk> scutigera: gl is intended to eventually go in as a lower level below a nice high level opengl binding that does 'modern opengl' practices
21:23:42 <dramforever> edwardk: btw you and the gl package are mentioned in an answer to "How is mastering Haskell like?" (translated)
21:23:45 <edwardk> i never got around to writing it
21:24:01 <bakibour> Hidiho
21:24:19 <scutigera> well quit spending time on quine and get  cracking ;-)
21:24:25 <edwardk> dramforever: link?
21:24:31 <dramforever> in Chinese
21:24:42 <edwardk> scutigera: the quine repo is basically where most of that binding code currently lives ;)
21:24:49 <edwardk> scutigera: so that might not be a good idea ;)
21:24:57 <dramforever> http://www.zhihu.com/question/27355585
21:24:59 <edwardk> anyways i've been off playing with other things
21:25:03 <dramforever> edwardk: just read the pictures
21:25:13 <bakibour> Quick question is there anything around HOTT or somewhere else that looks at types in a "algegraic/geometric" way? Like defining symmetries / rotation etc on types.
21:25:37 <edwardk> quine was an exploration of how to generate scenes out of signed distance fields. sadly epic megagames shipped an unreal tech demo that made heavy use of sdfs in its lighting, which kind of stole my thunder
21:25:41 <edwardk> so i've had little reason to play with it
21:25:57 <bakibour> I saw one talk yesterday that looked at type families as fribrations for example.
21:26:12 <scutigera> i'd be super-impressed...
21:26:26 <scutigera> if i knew what a signed distance field was (yes, i know, google it :-)
21:26:38 <lispy> edwardk: surely you meant quined distance fields
21:26:44 <edwardk> dramforever: the google translate of that is hilarious
21:26:45 <scutigera> there was a nifty article i saw not too long ago - called lumi-something
21:26:52 <edwardk> lispy: heh
21:26:54 <dramforever> edwardk: maybe...who knows
21:27:02 <scutigera> a very basic attempt to hide gl low level activity
21:27:07 <scutigera> can't seem to find it now...
21:27:16 <dramforever> edwardk: wait the original text is already very humorous
21:27:22 <dramforever> so I would expect that =P
21:28:37 <Cale> bakibour: You might try asking in #hott as well. There's cohesive homotopy type theory, which tries to put in more geometry.
21:28:54 <Cale> bakibour: I don't know much about the details.
21:28:54 <bakibour> Cale: Thank you :)
21:30:42 <Cale> http://ncatlab.org/nlab/show/cohesive+homotopy+type+theory has a bit of an overview
21:31:06 <gfixler> me is apparently not smart enough yet to compile quine
21:32:00 <ttt_fff> there's two possibilities (1) success typing is stupid or (2) I'm stupid
21:32:04 <Cale> bakibour: Oh, sorry, that should have been ##hott
21:32:30 <bakibour> Cale: Thanks again :) was a bit lonely on the other channel
21:32:55 <scutigera> http://phaazon.blogspot.fr/2015/08/luminance-framebuffers-and-textures.html
21:32:59 <Cale> bakibour: This network has silly rules about whether channels use one or two #'s :P
21:33:00 <scutigera> there it is. luminance.
21:34:00 <scutigera> interesting article because talks about, of course, how hard it is to write a higher level framework.  too many competing needs.
21:34:33 <bakibour> Cale: :)
21:34:48 <dramforever> sigh..
21:35:13 * dramforever goes back to work on algorithms...that seems easier
21:35:42 <scutigera> gfixler: did you try to use quine ?
21:35:58 <bakibour> Is there anything around in Haskell like Halide (http://halide-lang.org/) or Piko (http://arxiv.org/pdf/1404.6293)?
21:35:59 <scutigera> i was thinkinga about giving it a whirl.
21:36:13 <bakibour> Or even more extreme Cudaraster
21:36:29 <gfixler> scutigera: yeah, but I had the usual inability to install a haskell thing issue
21:36:53 <bob_twinkles> bakibour: for image processing there's bindings to OpenCV and cv-combinators
21:37:33 <scutigera> gfixler: cabal hell sort of thing ?
21:37:44 <scutigera> or an actual problem with ghc ?
21:37:59 <bakibour> bob_twinkles: It is more than just image processing
21:38:00 <gfixler> scutigera: I suppose - I tried cabal and stack, no luck
21:38:10 <dramforever> looks that comonads could give an interface similar to Halide
21:38:17 <bakibour> It abstracts the memory layout / usage etc under the hood
21:38:25 <gfixler> I have approx 0 interest in package management, so I always shy away from learning what I should really learn
21:38:36 <dramforever> wait no.....
21:38:56 <fishburne> how can I install cmd line programs like hgettext, using Stack?
21:38:56 <scutigera> well i have a shiny new 7.10.2 install. here goes nothing.
21:39:12 <bob_twinkles> bakibour: hmm... there are a number of projects like that. The one that comes to mind immediately is Accelerate, but that's focused mostly on abstracting over GPU computations
21:39:47 <bakibour> Ah ok thats already nice to know
21:40:15 <bakibour> I guess you could build someting like Piko on that but its a lot of work.
21:40:38 <joehh> Is it possible to use ghc-mod with projects that use stack?
21:40:55 <joehh> ^^ use stack for building?
21:41:10 <dramforever> bakibour: I'm not familiar with vectorizing, but it seems that par is good enough for parallellizing
21:41:46 <bob_twinkles> yeah, depending on exactly what you want there's probably a haskell project that has at least looked in to the feasibility =P
21:46:19 <scutigera> gfixler: ruh-roh. i'm experimenting with SDL2 right now
21:46:31 <scutigera> looks like that causes problems if i need SDL installed.
21:46:33 <scutigera> :-(
21:46:43 <scutigera> no quine for me today.
21:47:04 <scutigera> i could probably sandbox it, right ?
21:47:23 <fishburne> how can I install cmd line programs like hgettext, using Stack? I don't have a system wide installed ghc. 
21:47:40 <dramforever> stack install hgettext
21:47:51 <dramforever> I'm sure stack puts the binary somewhere...lemme check
21:48:23 <scutigera> It is a member of the hidden package ‘SDL-0.6.5...
21:48:37 <scutigera> so that hidden package thing shows up every once in a while. what exactly is the cause of that ?
21:49:18 <nocturne777> is it frowned upon in Haskell to write partial functions ?
21:49:25 <Xe> nope
21:50:03 <codehero> although it's useful to avoid partial functions
21:50:22 <arkeet> partial functions are scary.
21:50:24 <dramforever> nocturne777: it depends on how partial
21:50:28 <dramforever> it is
21:50:43 <nocturne777> I have a function of this sort: updateAddress :: (HasPostgres m) => Address -> m ()
21:51:20 <codehero> you can also just use an "error ..." to make the rest of the cases
21:51:31 <nocturne777> the function expects that address id be present in (Address (Just id)... )
21:51:35 <codehero> that way you can even give useful error messages in case you need to add a match
21:51:54 <dramforever> nocturne777: is it an internal only function?
21:52:15 <nocturne777> I was thinking I can do error, maybe
21:52:26 <dramforever> does it imply a programming error if the field is Nothing?
21:52:44 <nocturne777> dramforever: yes, it would indicate a programming error
21:53:07 <nocturne777> because you cannot update the address without its id, in this particular case
21:53:15 <dramforever> add a comment about this
21:53:18 * hackagebot hierarchy 0.1.1 - Pipes-based library for predicated traversal of generated trees  https://hackage.haskell.org/package/hierarchy-0.1.1 (JohnWiegley)
21:53:22 <dramforever> and add the error case
21:53:47 <nocturne777> yeah, I think error case is better than seeing pattern mismatch at run time
21:54:02 <dramforever> but there's a proble
21:54:05 <dramforever> problem
21:54:06 <nocturne777> dramforever: I was also thinking that maybe I can return True or False
21:54:14 <dramforever> no
21:54:15 <exio4> in some cases, I'd prefer parametrized types 
21:54:25 <dramforever> that way the caller has to check for programming errors...
21:54:28 <dramforever> that sucks
21:54:36 <nocturne777> yeah, it felt a bit lame
21:54:58 <nocturne777> in particular, since this is function is not returning anything
21:55:01 <dramforever> my own example: http://hackage.haskell.org/package/splay-0.0.6/docs/src/Data-Splay.html#findAndSplay
21:55:09 <fishburne> what is the stack version of cabal install  (if I do not have a system wide ghc installed)
21:55:13 <dramforever> see the bottom of this function for the error case
21:55:23 <dramforever> and see just below this function for the comment
21:56:44 <nocturne777> dramforever: I think what you are suggesting is good. 
21:56:50 <dramforever> =)
21:59:09 <nocturne777> dramforever: some stackoverflow post with plenty of upvotes got me confused. it was saying "always avoid error at all costs". on the other hand, throwing exceptions would make functions like this extremely ugly
22:00:26 <kadoban> fishburne: I'm not sure what you mean? Just 'stack install' ?
22:01:07 <dramforever> nocturne777: I doubt if that's actually true
22:01:58 <nocturne777> dramforever: http://programmers.stackexchange.com/questions/252977/cleanest-way-to-report-errors-in-haskell
22:02:05 <dramforever> your program should not check for programming errors
22:02:15 <nocturne777> dramforever: I agree with you
22:02:22 <nshepperd> ttt_fff: are you familiar with the concept that a choice of type systems is a tradeoff between 1. rejecting invalid programs and 2. accepting valid programs?
22:02:26 <akfp> Is there a ghcjs 7.10.x docker image yet?
22:02:46 <dramforever> sigh...
22:03:43 <nshepperd> ttt_fff: it sounds like the success typing system is an attempt to reject as many invalid programs as possible, while accepting all valid programs
22:03:56 <ttt_fff> nshepperd: indeed it is
22:04:07 <ttt_fff> nshepperd: I'm just too stupid to see how it's useful
22:04:46 <nshepperd> perhaps it allows more polymorphism than hindley-milner could?
22:04:54 <nshepperd> I'm not familiar with the actual mechanics of it
22:04:55 <dramforever> The Crashing Problem is undecidable
22:05:19 <dramforever> nocturne777: I think I know why they want to avoid error
22:05:33 <ttt_fff> dramforever: how does the "Crashing" problem compare to (1) the "Halting" problem and (2) the "catch fire and make noises" problem ?
22:06:10 <dramforever> because they want to "report error conditions"
22:06:30 <dramforever> whereas we are talking about "nicely handling programming errors"
22:06:41 <dramforever> ttt_fff: dunno, just jokin'
22:09:04 <nshepperd> ttt_fff: I mean, that is the argument for 'dynamic' types - it allows things like 'if True then 1 else "unreachable"' that wouldn't be allowed in HM, and the more complicated actually useful cases
22:09:40 <ttt_fff> nshepperd: I dunno, taht looks like a Either Int String to me
22:09:42 <nshepperd> I would imagine success typing to be some strictly superior refinement of that
22:09:44 <nocturne777> dramforever: I think it all depends on the context. In this case, there's no better solution than error, as you pointed out. but this does not mean that functions like readMay  and headMay are not better alternatives of read and head
22:09:56 <dramforever> yep
22:11:39 <nshepperd> Either Int String has to be case matched later to extract the Int
22:12:47 <dramforever> nshepperd: still better than "if isNull(result)"
22:13:19 * hackagebot hasql-backend 0.4.2 - API for backends of "hasql"  https://hackage.haskell.org/package/hasql-backend-0.4.2 (NikitaVolkov)
22:14:17 <Euryale> I have a question: Why does the prelude specify drop :: Int -> [a] -> [a] instead of something like drop :: (Num a) => a -> [b] -> [b]?
22:14:32 <Euryale> or
22:14:38 <Euryale> I have a question: Why does the prelude specify drop :: Int -> [a] -> [a] instead of something like drop :: (Integral a) => a -> [b] -> [b]?
22:15:01 <arkeet> historical reasons, I think
22:15:01 <Euryale> sorry, repeated question with slight variation
22:15:06 <johnw> Euryale: see genericDrop
22:15:12 <arkeet> there is a genericDrop in Data.List
22:15:31 <dramforever> over-generic functions considered harmful
22:15:43 <Euryale> really
22:15:44 <Euryale> huh, okay
22:15:50 <dramforever> Euryale: no no no
22:15:51 <kadoban> Euryale: Some combination of histerical raisins and performance reasons, IIUC
22:15:54 <dramforever> I'm just joking
22:16:09 <Euryale> okay, I can see the performance reasons
22:16:21 <dramforever> but it makes some sense
22:16:35 <Euryale> OH! because if it is of type Int -> [a] -> [a] then the compiler will cast the number as an Int and everything will run just a little bit faster/smaller!
22:16:44 <dramforever> Euryale: I'm pretty sure the compiler can optimize it
22:17:39 <chattered> It probably will if it's declared inlinable.
22:18:02 <chattered> Otherwise, I don't believe GHC creates specialised versions of generic functions across modules.
22:18:11 * dramforever wonders if a recursive function is...wait is drop recursive?
22:18:19 <Euryale> well... the compiler would default to Integer and it wouldn't be able to optimize it to use Int automatically because it would have no idea, pre-run-time how big that number might get.
22:18:29 <Euryale> dramforever: drop is recursive
22:18:36 <dramforever> integer is also pretty fase
22:18:37 <dramforever> fast
22:18:54 <dramforever> but sure, slower than Int
22:18:59 <Euryale> okay, I think it must be because of a performance thing with how I said
22:19:14 <Euryale> thank you, everyone!
22:19:20 <chattered> Euryale: I mean for wmhen you use genericDrop but where it turns out that what you are passing in really is an Int.
22:19:20 <dramforever> Euryale: wait wait
22:19:25 <dramforever> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.List.html#drop
22:19:38 <Euryale> yeah, I saw that
22:19:47 <dramforever> INLINE...
22:20:23 <arkeet> it inlines to unsafeDrop.
22:20:31 <arkeet> I assume.
22:20:35 <Euryale> right, and unsafeDrop is recursive
22:20:45 <dramforever> however looks like genericDrop doesn't inline
22:21:29 <dramforever> I assume that it's common to have a constant Int argument
22:21:43 <Euryale> probably because floats would give it problems what with rounding errors close to zero
22:21:57 <dramforever> Integral
22:22:06 <Euryale> oh, good catch
22:22:24 <dramforever> :t catch
22:22:25 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
22:22:42 * Euryale giggles
22:23:19 * hackagebot hasql-postgres 0.10.5 - A "PostgreSQL" backend for the "hasql" library  https://hackage.haskell.org/package/hasql-postgres-0.10.5 (NikitaVolkov)
22:23:45 <Euryale> well, I'm satisfied with the answer that the type signature is to cause the compiler to cast the numeral as an Int for performance reasons. It makes a lot of sense to me.
22:24:20 <chattered> It won't do any casting. All numerical casts in Haskell are explicit.
22:24:30 <chattered> @t fromIntegral
22:24:30 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
22:24:38 <chattered> :t fromIntegral
22:24:39 <lambdabot> (Integral a, Num b) => a -> b
22:24:39 <dramforever> s/cast/force
22:24:42 <dramforever> FTFY
22:24:58 <arkeet> there is no casting.
22:25:50 <EvanR> Euryale: its easier on the brain and the computer if you can agree on a common type good enough across lots of code, and in many cases where Nat Int and Integer would work, Int would
22:25:55 <Euryale> not sure what the word would be then. not re-cast but... set the initial type of the variable, whatever that's called.
22:26:04 <EvanR> if you only used generic functions then youd be converting a lot
22:26:31 <EvanR> though Int is still arguably not the best default
22:27:32 <Euryale> Anyway, wish me luck. It's my third time trying to learn this language and I think it's finally starting to click.
22:27:35 <EvanR> Int works for list operations because its not really feasible to have lists as long as maxBound
22:28:15 <EvanR> (unless they are infinite)
22:28:20 * hackagebot hasql 0.7.4 - A minimalistic general high level API for relational databases  https://hackage.haskell.org/package/hasql-0.7.4 (NikitaVolkov)
22:28:20 <kadoban> It's not?
22:28:37 <EvanR> > sum (replicate maxBound 1)
22:28:43 <lambdabot>  mueval-core: Time limit exceeded
22:28:53 <EvanR> > last (replicate maxBound 1)
22:28:59 <lambdabot>  mueval-core: Time limit exceeded
22:28:59 <lambdabot>  mueval: ExitFailure 1
22:30:22 <chattered> Euryale: As far as the language goes, if you have Integral n => n -> [a] -> [a], then you've got a function with two type variables a and n. You can specialise a to whatever specific type you want. You can only specialise n to a type that is an instance of the Integral class.
22:30:40 <dramforever> kadoban: even the docs of Data.Sequence says that if the length of a sequence goes beyond maxBound :: Int, the behaviour is undefined
22:30:59 <dramforever> > maxBound :: Int -- also Int is 64-bits on GHC on 64-bit machines
22:31:00 <lambdabot>  9223372036854775807
22:31:23 <dramforever> > log 9223372036854775807 / log 10
22:31:25 <lambdabot>  18.964889726830812
22:31:28 <kadoban> dramforever: I'm not sure what that has to do with []
22:31:42 <dramforever> kadoban: you can't possibly have that many elements in memory
22:32:23 <arkeet> > base 2 # (maxBound :: Int)
22:32:24 <lambdabot>  "111111111111111111111111111111111111111111111111111111111111111"
22:32:25 <kadoban> dramforever: … you can't have ~4 billion of something, /possibly/? I find that rather hard to believe. Also, why would they all need to be in memory?
22:32:43 <dramforever> forget about it
22:32:45 <arkeet> I think I have more than 4 billion bytes in my computer.
22:32:46 <dramforever> never mind
22:32:49 <johnw> not all lists are in memory
22:32:49 <kadoban> Actually I guess it's more like 2 billion, probably less.
22:32:51 <chattered> If I'm consuming an infinite list, I don't expect all those elements to be in memory.
22:32:56 <dramforever> forget about it
22:32:59 <dramforever> sigh..
22:33:01 <johnw> you might want to know the 2^65th fibonacci number
22:33:03 * dramforever screwed it up
22:33:13 <dramforever> johnw: that's going to take a while
22:33:19 <johnw> yeah, I didn't say it would be fast :)
22:33:30 <dramforever> or, use some fast method
22:33:36 <exio4> matrices to the rescue
22:33:37 <dramforever> like a formula
22:33:42 <arkeet> who needs matrices.
22:33:58 <dramforever> there's a formula IIRC
22:34:34 <dramforever> something like ((1 - sqrt 5) / 2) ^ n - wtf
22:34:40 <dramforever> who knows
22:34:55 <exio4> johnw: actually, I think in that case, the fibonacci number would be pretty big, wouldn't it?
22:35:00 <arkeet> it's not hard to obtain the 2n'th and 2n+1'th fibonacci numbers from the n'th and n+1'th
22:35:03 <kadoban> dramforever: That one is algorithmically useless, though there is a different way.
22:35:03 <arkeet> directly
22:35:13 <arkeet> the 2^65th fibonacci number would be pretty big, yes.
22:35:17 <dramforever> kadoban: no that's useful
22:35:25 <EvanR> the 2^65th fib using a lazy list is equal if you use Int or Integer... _|_ where _|_ means fuckit cancel
22:35:32 <dramforever> because you can represent (a / b) + (c / d) * sqrt 5
22:35:37 <arkeet> > 65 * logBase 2 ((1+sqrt 5)/2)
22:35:38 <lambdabot>  45.12572438599013
22:35:56 <kadoban> dramforever: By the time you get to numbers big enough to matter, any way you calculate that is going to have so much error that the result is useless.
22:36:06 <arkeet> oops.
22:36:08 <arkeet> > 2^65 * logBase 2 ((1+sqrt 5)/2)
22:36:09 <lambdabot>  2.561300581197274e19
22:36:13 <arkeet> that's a lot of bits.
22:36:22 <dramforever> @let data Q5 = Q5 Rational Rational
22:36:23 <lambdabot>  Defined.
22:36:51 <dramforever> kadoban: don't use floating point numbers
22:36:54 <dramforever> use exact numbers
22:37:07 <arkeet> http://lpaste.net/130719
22:37:16 <dramforever> but that also requires us to simplify the formula a bit to make it nicer
22:37:30 <dramforever> or, if you want to have fun, let's go on
22:37:32 <johnw> so, it was just an example of a big drop that doesn't involve having a list in memory :)
22:37:34 <exio4> dramforever: the problem is not using floating point numbers but that those formulas have error bars
22:37:42 <dramforever> ?
22:37:55 <arkeet> ??
22:38:01 <kadoban> dramforever: What are "exact numbers", algorithmically. What is sqrt 5 in "exact numbers" ?
22:38:04 <dramforever> exio4: what error bars?
22:38:10 <kadoban> dramforever: sqrt 5 isn't a rational.
22:38:14 <arkeet> it's not hard to do exact arithmetic with numbers of the form (a + b*phi)
22:38:18 <dramforever> kadoban: don't worry watch this
22:38:20 <arkeet> for integral/rational a,b
22:38:35 <arkeet> @letlpaste 130719
22:38:36 <lambdabot>  Defined.
22:38:40 <arkeet> > fib (2^10)
22:38:42 <lambdabot>  4506699633677819813104383235728886049367860596218604830803023149600030645708...
22:39:02 <dramforever> oh you already did this
22:39:17 <EvanR> kadoban: well there is the idea of "exact real arithmetic"
22:39:18 <dramforever> arkeet: thank you I don't have to waste my time defining that Q5 thing
22:39:30 <dramforever> EvanR: which is not used here
22:40:06 <EvanR> why not!
22:40:15 <dramforever> because there's something simpler
22:40:27 <arkeet> because the numbers involved are much simpler than arbitrary reals.
22:40:36 <EvanR> i was responding to kadoban about sqrt 5, whats simpler than ... sqrt 5
22:40:56 <dramforever> EvanR: what about this: how do you calculate the n-th fib using that formula?
22:40:57 <exio4> oh wait, dramforever's solution is still O(log n), thought it was an approximation
22:40:58 <arkeet> you don't have to know exactly which real number sqrt 5 is to do arithmetic with it.
22:41:04 <dramforever> exio4: =)
22:41:24 <EvanR> Q adjoin sqrt 5
22:41:28 <arkeet> yes.
22:41:41 <arkeet> which you can simply describe using a pair of rationals, where
22:41:48 <kadoban> EvanR: That sounds like an interesting idea that I've never really heard of.
22:41:50 <arkeet> (a,b)(c,d) = (ac + 5bd, ad + bc)
22:42:16 <dramforever> arkeet: exactly what I wanted to talk about
22:42:18 <arkeet> (although I adjoin phi instead.)
22:42:27 <dramforever> arkeet: that's simpler
22:42:27 <EvanR> phive
22:42:31 <EvanR> best of both worlds
22:42:34 <johnw> lol
22:42:43 <arkeet> lol
22:43:21 <dramforever> @instance Show Q5 where show (Q5 a b) = "(" ++ show a ++ " + sqrt 5 * " ++ show b ++ ")"
22:43:21 <lambdabot> Maybe you meant: instances instances-importing
22:43:25 <dramforever> sigh
22:43:31 <dramforever> @let instance Show Q5 where show (Q5 a b) = "(" ++ show a ++ " + sqrt 5 * " ++ show b ++ ")"
22:43:32 <lambdabot>  Defined.
22:43:44 <dramforever> > show (Q5 2.23 7.88) -- test
22:43:45 <lambdabot>  "(223 % 100 + sqrt 5 * 197 % 25)"
22:44:45 <arkeet> now it just needs a Num instance.
22:44:54 * dramforever is working on that
22:44:58 <arkeet> :-)
22:45:04 <dramforever> testing in ghci first
22:46:33 <dramforever> wait also need fractional
22:46:52 <EvanR> instance Field where
22:48:31 <dramforever> instance Num Q5 where fromInteger a = Q5 (fromInteger a) 0; Q5 a b + Q5 c d = Q5 (a + c) (b + d); Q5 a b * Q5 c d = Q5 (a * c + 5 * b * d) (a * d + b * c); negate (Q5 a b) = Q5 (negate a) (negate b); abs = error "abs"; signum = error "signum"
22:48:37 <dramforever> @let instance Num Q5 where fromInteger a = Q5 (fromInteger a) 0; Q5 a b + Q5 c d = Q5 (a + c) (b + d); Q5 a b * Q5 c d = Q5 (a * c + 5 * b * d) (a * d + b * c); negate (Q5 a b) = Q5 (negate a) (negate b); abs = error "abs"; signum = error "signum"
22:48:39 <lambdabot>  Defined.
22:50:25 <fishburne> kadoban: but there is no stack install command..
22:51:08 <arkeet> @let phi = Q5 (1/2) (1/2)
22:51:09 <lambdabot>  Defined.
22:51:11 <kadoban> fishburne: Then I've gone completely batty, because I've been using 'stack install' for a couple of weeks now.
22:51:15 <dramforever> 1/(a + b * sqrt 5) = (a - b * sqrt 5) / (a*a - 5*b*b) = (a / (a*a - 5*b*b)) + (b / (a*a - 5*b*b)) * sqrt 5
22:51:25 <arkeet> > fib 20
22:51:27 <lambdabot>  6765
22:51:37 <dramforever> hey what did you just do?
22:51:38 <fishburne> kadoban: I am using version 0.0.0
22:51:51 <arkeet> ?
22:51:56 <dramforever> oh nothing
22:51:58 <arkeet> oh, fib is still from my lpaste.
22:52:01 <kadoban> fishburne: … that sounds like not a great version to be using? What is that?
22:52:05 <dramforever> wait I'm doing it
22:52:27 <dramforever> @let instance Fractional Q5 where fromRational a = Q5 a 0; recip (Q5 a b) = Q5 (a / (a*a - 5*b*b)) (b / (a*a - 5*b*b))
22:52:28 <lambdabot>  Defined.
22:52:31 <dramforever> > recip phi
22:52:33 <lambdabot>  ((-1) % 2 + sqrt 5 * (-1) % 2)
22:52:36 <dramforever> good
22:52:49 <arkeet> > (phi^20 - recip phi^20) / (Q5 0 1)
22:52:51 <lambdabot>  (0 % 1 + sqrt 5 * 0 % 1)
22:52:58 <arkeet> oops
22:53:09 <dramforever> @let s5 = Q5 0 1
22:53:10 <lambdabot>  Defined.
22:53:17 <arkeet> > recip phi
22:53:18 <lambdabot>  ((-1) % 2 + sqrt 5 * (-1) % 2)
22:53:23 <arkeet> I think something's wrong.
22:53:25 <arkeet> it shouldn't be negative.
22:53:32 <dramforever> oh hmm...
22:53:39 <dramforever> oh yes I got it wrong
22:53:44 <dramforever> @unlet
22:53:44 <lambdabot>  Define what?
22:53:48 <dramforever> @undefine
22:53:48 <lambdabot> Undefined.
22:53:53 <arkeet> 1/(a + b sqrt 5) = (a - b sqrt 5) / (a^2 + 5b^2)
22:53:59 <arkeet> wait
22:54:04 <arkeet> - instead of + in teh end.
22:54:14 <dramforever> yes I got the signs wrong in the instance
22:54:21 <arkeet> yeah.
22:54:26 <dramforever> @let data Q5 = Q5 Rational Rational
22:54:27 <lambdabot>  Defined.
22:54:29 <dramforever> @let instance Show Q5 where show (Q5 a b) = "(" ++ show a ++ " + sqrt 5 * " ++ show b ++ ")"
22:54:30 <lambdabot>  Defined.
22:54:33 <arkeet> just put it in an lpaste and use @letlpaste
22:54:43 <dramforever> okay
22:54:45 <dramforever> @undefine
22:54:45 <lambdabot> Undefined.
22:57:20 <dramforever> hmm...isn't a^2 - 5 * b^2 negative?
22:57:43 <dramforever> I mean, in the case of phi
22:58:08 <arkeet> yes.
22:58:22 <arkeet> but so is a - b sqrt 5
22:59:00 <dramforever> okay so phi is (1/2)*sqrt 5 - (1/2)
22:59:06 <arkeet> no, +
22:59:12 <arkeet> phi = (1 + sqrt 5) / 2
22:59:13 <dramforever> oh I mean recip phi
22:59:14 <dramforever> sorry
22:59:21 <arkeet> yeah.
22:59:23 <arkeet> recip phi = (-1 + sqrt 5) / 2
22:59:36 <dramforever> #haskell is the biggest math channel on freenode
23:00:35 <johnw> that's phine with me
23:01:12 * arkeet rolls eyes at johnw
23:01:17 <johnw> yeah, I know
23:01:19 <EvanR> you need an undergrad in math to understand haskell and graduate degree to get anything to compile
23:01:21 <arkeet> :-)
23:01:34 <zomg> EvanR: I didn't know I had a math degree!
23:01:41 <zomg> lol
23:01:46 <EvanR> it catches you by surprise
23:02:19 <lpaste_> dramforever pasted “Fib” at http://lpaste.net/138385
23:02:40 <dramforever> @letlpaste 138385
23:02:41 <lambdabot>  Defined.
23:02:45 <dramforever> > fib 20
23:02:46 <lambdabot>  (6765 % 1 + sqrt 5 * 0 % 1)
23:02:51 <dramforever> > fib 50
23:02:53 <lambdabot>  (12586269025 % 1 + sqrt 5 * 0 % 1)
23:03:01 <dramforever> looks good enough =P
23:03:08 <johnw> * 0?
23:03:09 <dramforever> arkeet: done with it
23:03:21 * hackagebot cabal-helper 0.3.9.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.3.9.0 (DanielG)
23:03:33 <dramforever> johnw: just means the sqrt 5 part is 0
23:03:36 <dramforever> which is good
23:03:37 <johnw> ah
23:03:51 <arkeet> > phi^20
23:03:52 <lambdabot>  (15127 % 2 + sqrt 5 * 6765 % 2)
23:04:12 <EvanR> > phi^50
23:04:13 <lambdabot>  (28143753123 % 2 + sqrt 5 * 12586269025 % 2)
23:04:14 <dramforever> yes, but mine is more...standard
23:04:20 <dramforever> no
23:04:28 <dramforever> the standard way is to use a matrix
23:04:34 <arkeet> I don't like using a matrix.
23:04:49 <arkeet> it's redundant. :p
23:04:58 <dramforever> wait isn't multiplication of phi exactly the same as matrix multiplication?
23:05:04 <arkeet> anyway, just the observation that phi^n = F_(n-1) + F_n * phi is good enough for me.
23:05:13 <dramforever> yep
23:05:29 <arkeet> dramforever: yeah you can do it with matrices.
23:05:42 <dramforever> in my code I used the observation that F(n) = ...you know it
23:05:45 <arkeet> yeah.
23:06:04 <arkeet> but the relevant matrices have 4 entries, while 2 is enough.
23:06:15 <dramforever> =)
23:06:19 <matsuura> arkeet: what do you mean by a matrix being redundant? 
23:06:32 <arkeet> because all you ever end up with is linear combinations of the identity matrix and the one representing phi
23:06:33 <dramforever> redundancy, redundancy everywhere
23:06:50 <arkeet> so you're only using a 2-dimensional subspace of the 4-dimensional space of matrices.
23:08:00 <arkeet> that's what I mean by redundant, I think.
23:08:50 <EvanR> redundant component can be removed without losing the important parts
23:08:53 <matsuura> arkeet: what's your alternative?
23:09:08 <arkeet> just talk directly about linear combinations of 1 and phi.
23:09:23 <matsuura> arkeet: example?
23:09:29 <arkeet> (a + b*phi) * (c + d*phi) = (a*c + b*d) + (a*d + b*c + b*d)*phi
23:09:55 <arkeet> matsuura: http://lpaste.net/130719
23:10:44 <arkeet> ZPhi a b represent a + b*phi
23:10:48 <arkeet> represents
23:22:24 <EvanR> on this subject
23:22:44 <EvanR> can you replace floats with something to make mandelbrot generation exact?
23:23:08 <EvanR> instead of eventually zooming into something wrong looking
23:25:53 <saulzar> EvanR, Maybe Rational - guessing it would be rather slow if it worked..
23:27:01 <EvanR> Complex Rational
23:27:25 <EvanR> but ...
23:28:24 <EvanR> i guess its the halting problem
23:29:00 <dramforever> I wonder if it's possible to reconstruct a part of the image using the whole image
23:29:06 <dramforever> but without loss of precision
23:29:18 <dramforever> like this https://upload.wikimedia.org/wikipedia/commons/c/ce/Mandelbrot_zoom.gif
23:30:02 <EvanR> except the halting problem is a problem on arbitrary programs which this is not
23:30:06 <pacak> dramforever: No.
23:30:10 <dramforever> =(
23:31:14 <dramforever> we need an easier fractual
23:32:30 <EvanR> cantor set
23:33:00 <EvanR> cantor fractual
23:33:02 <dramforever> wait hey
23:33:18 <dramforever> https://en.wikipedia.org/wiki/Mandelbrot_set#Perturbation_theory_and_series_approximation
23:33:22 * hackagebot acme-grawlix 0.1.0.0 - More readable names for commonly used symbols  https://hackage.haskell.org/package/acme-grawlix-0.1.0.0 (kadoban)
23:34:55 <dramforever> that's not acme at all
23:35:29 <EvanR> acme-something-useful
23:35:35 <EvanR> wtf
23:35:54 <EvanR> well docs arent available so we dont know
23:35:59 <kadoban> Trust me, it's not useful at all.
23:36:04 <dramforever> look at the source
23:36:15 <dramforever> it's not very acme
23:36:18 <dramforever> but still useless
23:36:24 <arkeet> https://github.com/kadoban/acme-grawlix/blob/master/src/Acme/Grawlix.hs
23:36:45 <arkeet> dot = (.)
23:37:26 <EvanR> should use the intercal names
23:38:06 <EvanR> which would be spot = (.0
23:38:10 <EvanR> spot = (.)
23:39:07 <liste> needs more pattern synyonyms
23:39:16 <dramforever> actually I think APL is quite like category theory
23:39:19 <liste> s/more/some/
23:39:25 <kadoban> Hah, I forgot intercal exists. 'spot' does sound cute.
23:39:39 <dramforever> where strange names compose together to form familiar things
23:40:34 <kadoban> liste: Yeah I need to look into those …
23:43:43 <liste> @let pattern TwoTuple x y = (x, y)
23:43:43 <lambdabot>  .L.hs:165:9: Not in scope: data constructor ‘TwoTuple’
23:44:52 <arkeet> seems lambdabot doesn't do pattern synonyms.
23:45:20 <dramforever> @undefine
23:45:20 <lambdabot> Undefined.
23:45:31 <dramforever> @let {-# LANGUAGE PatternSynonyms #-}
23:45:31 <lambdabot>  Parse failed: Parse error: EOF
23:45:35 <dramforever> sigh...
23:45:42 <arkeet> I've tried :-)
23:47:44 <koala_man> what's the most up-to-date ErrorT? Control.Monad.Except?
23:48:23 * hackagebot acme-grawlix 0.1.0.1 - More readable names for commonly used symbols  https://hackage.haskell.org/package/acme-grawlix-0.1.0.1 (kadoban)
23:50:10 <koala_man> when I compile with Control.Monad.Trans.Except it suggests transformers-compat-0.4.0.3 which doesn't seem right
23:50:43 <fishburne> why does updating package index take so long with stack?
23:52:06 <dramforever> because there are lots of packages on hackage
23:53:23 * hackagebot ihaskell 0.6.4.1 - A Haskell backend kernel for the IPython project.  https://hackage.haskell.org/package/ihaskell-0.6.4.1 (gibiansky)
23:58:23 * hackagebot ltk 0.15.0.3 - Leksah tool kit  https://hackage.haskell.org/package/ltk-0.15.0.3 (HamishMackenzie)
23:58:25 * hackagebot leksah-server 0.15.0.7 - Metadata collection for leksah  https://hackage.haskell.org/package/leksah-server-0.15.0.7 (HamishMackenzie)
