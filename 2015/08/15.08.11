00:00:15 <dramforever> oh I get what you mean
00:00:20 <ttt_fff> EvanR: started out as a debate about implementing bitcask in haskekll; but noted taht if you want datomic, you don't need bitcask's 'merge/gc' ability, which makes it easier
00:00:32 <ttt_fff> dramforever: checkpoint idea is also from bitcask
00:00:39 <dramforever> perfect
00:00:43 <ttt_fff> btw, in bitcask, 'checkpoint' is literally just "dump map out to a file"
00:00:58 <dramforever> we could do that too
00:00:58 <ttt_fff> checkpoint literrally = "dump the key => file/loc" in memory map out to a file
00:00:59 <EvanR> acid-state implements the log thing
00:01:11 <dramforever> acid-state is too large
00:01:28 <liste> dramforever too large?
00:01:28 <EvanR> you dont want to dump maps out, you want to log update by update of the database
00:01:39 <EvanR> in groups of transactions
00:01:48 <liste> as in takes too much memory/disk?
00:01:49 <dramforever> liste: to complexed, ttt_fff said that bitcask is like 4K LOC
00:01:51 <EvanR> checkpoints have the whole database
00:02:02 <ttt_fff> EvanR: the 'map' is NOT key => value map, it's the "key => file/loc" map, of where the value is stored
00:02:04 <dramforever> while acid-state is much more
00:02:19 <ttt_fff> https://gist.github.com/anonymous/446ce4cc846e0b142584 <-- acid-state is actually only 2433 LOC of haskell code
00:02:20 <EvanR> if youre talking about on disk persistence, acid-state is much less
00:02:28 <EvanR> has nothing to do with disk
00:02:30 <dramforever> okay forget about it
00:02:46 <dramforever> ttt_fff: wait why not acid-state then?
00:02:57 <ttt_fff> I haven't read any acid-state whit epaper, and have not read the code yet
00:02:57 <EvanR> acid-state is pretty good
00:03:03 <ttt_fff> (whereas there was a nice 4 page bitcask paper that I read)
00:03:18 <ttt_fff> http://basho.com/wp-content/uploads/2015/05/bitcask-intro.pdf <-- okay, 6 pages
00:03:24 <liste> acid-state is 3809 sloc
00:03:25 <ttt_fff> http://basho.com/wp-content/uploads/2015/05/bitcask-intro.pdf is well worth reading; it's fucking brilliant
00:03:30 <liste> including examples
00:03:32 <dramforever> liste: forget about it
00:03:35 <ttt_fff> liste: you're including examples / sample code; not just src
00:03:41 <dramforever> I got it screwed up
00:04:19 <EvanR> one benefit of acid state of KV store is you can store any value you want that supports an update interface, not just KV stores
00:04:26 <EvanR> over *
00:04:52 <liste> the only downside of acid-state I can think of is that the dataset must fit in memory
00:04:54 <EvanR> so basically, in theory you could have a relational database
00:05:17 <EvanR> it must fit in memory and schema changes can be crunchy
00:06:02 <ttt_fff> imho, databases taht ust 'fit in memory' aren't particularly hard
00:06:08 <ttt_fff> it's the 'larger than memory' taht makes stuff challenging
00:06:11 <ttt_fff> (for persistence)
00:06:19 <EvanR> acid state is persistent
00:06:30 <EvanR> you just cant access the data unless it fits in memory
00:06:31 <ReinH> if it's just in memory, it isn't persistent
00:06:33 <liste> and fail-ptolerant
00:07:04 <liste> it's log-based, the log is on disk, the result is in memory
00:07:23 <ttt_fff> alright; I'l read the acid-state source
00:07:34 <ttt_fff> seems at the very least I should udnerstand it before bashing it :-)
00:07:41 * hackagebot conversion 1.1.1 - Universal converter between values of different types  https://hackage.haskell.org/package/conversion-1.1.1 (NikitaVolkov)
00:07:41 * hackagebot list-t-html-parser 0.4.1 - Streaming HTML parser  https://hackage.haskell.org/package/list-t-html-parser-0.4.1 (NikitaVolkov)
00:08:06 <liste> btw is anyone using acid-state but keeping blobs on disk?
00:08:20 <ReinH> liste: acid-state is pretty meh
00:08:49 <EvanR> I haven't looked at the source, but it uses a basic log with checkpoints. If it has extra protection against data corruption (beyond what the file system gives you) that would be good but i dont know if it does
00:08:56 <ttt_fff> ReinH: what is the best persistence library in pure haskell ?
00:09:01 <ttt_fff> ReinH: i.e. what is worth reading?
00:09:23 <ReinH> ttt_fff: In pure haskell? There aren't very many. I'm writing one, but it might not be open sourced for a while.
00:09:40 <EvanR> git-annex
00:10:36 <dramforever> EvanR: hey that's actually pretty good!
00:10:49 <EvanR> i use that extensively
00:10:50 <dramforever> remember that git itself is also a *toolchain* for VC
00:11:04 <ReinH> does git-annex use hit or some other pure-haskell git impl?
00:11:08 <dramforever> so in theory you could make a db in VC
00:11:14 <EvanR> no it uses git
00:11:18 <ReinH> dramforever: Yes, it works out pretty well.
00:11:22 <dramforever> =)
00:11:23 <ReinH> EvanR: that's not pure haskell then
00:11:32 <EvanR> no, but doesnt need to be
00:11:38 <ReinH> dramforever: well, I'm not sure about "in VC". But in git works pretty well.
00:11:47 <dramforever> oh sure s/VC/git
00:11:55 <ReinH> well, it's an important distinction
00:12:01 <ReinH> git is a dumb and very vast content store
00:12:04 <dramforever> I messed it up sorry
00:12:07 <Saizan> liste: hackage does
00:12:12 <EvanR> dumb and reliable
00:12:16 <ReinH> s/vast/fast
00:12:18 <EvanR> and fast
00:12:29 <dramforever> vast-able
00:12:35 <ReinH> dramforever: your mom is vast
00:12:35 * hackagebot list-t-html-parser 0.4.1.1 - Streaming HTML parser  https://hackage.haskell.org/package/list-t-html-parser-0.4.1.1 (NikitaVolkov)
00:12:38 <EvanR> web vast
00:12:51 <dramforever> pretty sure git is web-scale
00:13:00 <dramforever> wait does git even scale?
00:13:01 <EvanR> unless you are putting binaries in it
00:13:09 <dramforever> EvanR: not really
00:13:29 <dramforever> you can use it as a regular object store
00:13:31 <EvanR> git-annex stores the blobs separately
00:13:34 <dramforever> hash-value store
00:13:59 <EvanR> and you can control where they are stored, on what machine / drive / toaster
00:14:03 <ReinH> it's not good at binaries
00:14:13 <ttt_fff> only8 mongodb is webscae https://www.youtube.com/watch?v=b2F-DItXtZs
00:14:14 <ReinH> in part because binaries aren't packed very efficiently
00:14:25 <ReinH> well, very large binaries
00:14:30 <ReinH> it's decent at smallish binaries
00:14:40 <EvanR> its terrible at images
00:14:47 <EvanR> which are binary and already compressed
00:15:12 <ReinH> git's pack heuristics are designed for text
00:15:15 <EvanR> a project can become many megabytes big because of images
00:15:16 <ReinH> line-based text at that
00:15:21 <kadoban> It's fine with images … unless they change often.
00:15:38 <dramforever> d/often/
00:15:45 <ReinH> so it's actually quite good at, e.g., storing every hackage package
00:15:47 <EvanR> well youd think version control would be for stuff that is changing
00:16:43 <kadoban> EvanR: True, but a lot of content has binary stuff on the side that doesn't really change much/ever. Like webpages have images, source code has PDF docs, etc.
00:17:02 <EvanR> yeah i try to avoid putting that in git
00:17:23 <dramforever> PDF docs
00:17:33 <dramforever> why not just put the "source code" of it there?
00:17:41 <EvanR> who ever has the source code to the pdfs
00:17:58 <dramforever> .tex
00:17:59 <dramforever> .md
00:18:07 <dramforever> even .lhs or something
00:18:11 <EvanR> the brochures arent open source usually
00:18:13 <dramforever> wait is this off topic?
00:18:18 <kadoban> dramforever: Because you don't have it, usually. I'm talking about academic papers for algorithms, tech specs, etc.
00:18:33 <dramforever> oh never mind
00:18:49 <dramforever> let's stay on the VCS part and the object store part
00:19:14 <EvanR> you know theres this awesome technology called postgres
00:19:20 <EvanR> not many have heard of it or used
00:19:24 <EvanR> but it does things
00:19:41 <EvanR> unfortunately its not no-sql
00:20:03 <dramforever> postgresql? I've heard of it, but never used it
00:20:19 <ely-se> postgresql is the best software ever
00:20:29 <dramforever> postgresql is good
00:20:38 <EvanR> i heard its not web scale
00:20:55 <ely-se> it's web robust
00:21:03 <EvanR> its fucking awesome
00:41:56 <hio> hey the homepage tutorial says I can sort via "sort [3,4,1]" but what if I want to sort in a differnt order? (descending?) The new tutorial is GREAT by the way
00:42:16 <kadoban> hio: sortBy
00:42:26 <arkeet> > sortBy (flip compare) [3,4,1]
00:42:27 <lambdabot>  [4,3,1]
00:43:22 <kadoban> > sortBy (comparing Down) [1..5]
00:43:23 <lambdabot>  [5,4,3,2,1]
00:43:30 <arkeet> :)
00:43:36 <hio> what is that stuff in the () braces?
00:43:49 <dramforever> hio: an expression
00:43:50 <arkeet> sortBy takes a comparison function as an argument.
00:43:56 <dramforever> the argument to sortBy
00:44:06 <hio> how do I know what expressions exist for comparisons?
00:44:11 <arkeet> :t sortBy
00:44:12 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
00:44:26 <arkeet> any function that takes two values and returns an Ordering (LT/EQ/GT) works.
00:44:26 <dramforever> hio: look here comes the types
00:44:27 <kadoban> hio: It's a higher-order function, if you're familiar with that term.
00:44:29 <arkeet> :t compare
00:44:30 <lambdabot> Ord a => a -> a -> Ordering
00:44:43 <arkeet> sort is the same as sortBy compare
00:44:51 <dramforever> although it's up to you to ensure that it's consistent
00:45:40 <liste> :t comparing
00:45:41 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
00:45:55 <arkeet> > compare 1 2
00:45:56 <lambdabot>  LT
00:46:00 <arkeet> > flip compare 1 2
00:46:01 <lambdabot>  GT
00:46:39 <hio> :t compare in the online gui gives me an error
00:46:40 <lambdabot> parse error on input ‘in’
00:46:50 <dramforever> hio: that's not allowed somehow
00:47:07 <arkeet> which online gui
00:47:11 <bennofs1> arkeet: haskell.org
00:47:15 <bennofs1> hio: just try "compare"
00:47:16 <dramforever> you should really get a proper haskell environment
00:47:18 <bennofs1> hio: without :t
00:47:50 <dramforever> bennofs1: wait that's going to cause problems
00:48:01 <bennofs1> > compare
00:48:02 <lambdabot>  <() -> () -> Ordering>
00:48:03 <kadoban> hio: I've literally never heard anyone say "you should really do the tutorial on the website" here, just throwing that out there. https://github.com/bitemyapp/learnhaskell is good advice
00:48:10 <EvanR> hio: you should be in the habit of :t any expression you dont understand, even outside haskell
00:48:29 <dramforever> IIUC we use :t more often than > in #haskell
00:48:56 <EvanR> "what IS x" well it is often the case that the type will tell you
00:49:16 <dramforever> hmm...idea
00:49:32 <dramforever> let's say this everywhere: we don't do IO in haskell, we *model* IO
00:49:53 <dbushenko> hi all!
00:49:55 <kadoban> dramforever: That sounds terrible.
00:50:03 <dramforever> why?
00:50:06 <EvanR> I do IO
00:50:16 <kadoban> dramforever: Because it's not true and sounds like haskell can't do IO.
00:50:23 <liste> dbushenko hiu!
00:50:24 <dramforever> oh that's a problem
00:50:25 <liste> hi!
00:50:36 <dbushenko> is it possible to store unicode characters in regular haskell string?
00:50:42 <dbushenko> not using Text or ByteString?
00:50:45 <arkeet> yes
00:50:46 <dramforever> yes
00:50:51 <EvanR> String = [Char]
00:50:52 <arkeet> a haskell string is a list of unicode characters
00:50:52 <liste> dbushenko they already are
00:50:54 <liste> code points
00:51:00 <liste> Char == code point
00:51:04 <arkeet> Char holds a unicode character.
00:51:05 <dramforever> > "这是一个Unicode字符串"
00:51:06 <EvanR> Char == character
00:51:07 <lambdabot>  "\36825\26159\19968\20010Unicode\23383\31526\20018"
00:51:17 <dbushenko> cool! thanks!
00:51:19 <kadoban> dbushenko: Char is unicode characters. ByteString is … not, at all. It's bytes without inherent meaning.
00:52:03 <dbushenko> I'm trying to do the following in ghci:
00:52:04 <dbushenko> let a = 'фываолдж' :: String
00:52:09 <dbushenko> but getting error
00:52:10 <EvanR> use " "
00:52:11 <dbushenko> whats wrong?
00:52:16 <dramforever> that's a char
00:52:22 <liste> dbushenko ' is for Chars
00:52:23 <dbushenko> ah yeah
00:52:29 <EvanR> :t "фываолдж"
00:52:30 <lambdabot> [Char]
00:52:30 <dbushenko> I was just using mysql :-)
00:52:31 <EvanR> :t 'a'
00:52:32 <lambdabot> Char
00:52:33 <dbushenko> thanks a lot!
00:52:59 <EvanR> > 'a':'b':'c':[]
00:53:00 <lambdabot>  "abc"
00:53:03 <liste> wait a minute, is Char a code point or a character?
00:53:08 <EvanR> its a character
00:53:09 <liste> now I'm confused
00:53:13 <dramforever> code point I think
00:53:19 <EvanR> theres a bijection between characters and code points
00:53:20 <dramforever> yes code point
00:53:25 <dramforever> EvanR: no
00:53:28 <arkeet> code point.
00:53:56 <EvanR> in old unicode some characters were known as "non characters"
00:54:14 <arkeet> same thing though, no?
00:54:38 <EvanR> speak no evil
00:55:34 <dbushenko> what is most popular library for working with dates and time?
00:55:39 <EvanR> > ord 'ф'
00:55:40 <lambdabot>  1092
00:55:44 <EvanR> > chr 1092
00:55:46 <lambdabot>  '\1092'
00:55:51 <EvanR> dbushenko: Data.Time
00:56:03 <dbushenko> ok, thanks!
00:56:24 <ely-se> Is there a standard name for this type class? https://gist.github.com/rightfold/ee042dc04e145695d2cb
00:56:24 <EvanR> dates are the data type Day and utc timestamps are UTCTime
00:56:29 <ttt_fff_> edwardk: do you still feel the way about erlang as stated in http://stackoverflow.com/questions/2199368/why-did-you-decide-against-using-erlang ?
00:56:32 <ely-se> I thought of "Fold" or "Aggregation"
00:57:07 <dbushenko> EvanR, where is it defined? datetime?
00:57:19 <EvanR> dbushenko: the module is Data.Time
00:57:37 * hackagebot hopenpgp-tools 0.15.1 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.15.1 (ClintAdams)
00:57:39 * hackagebot regex-applicative-text 0.1.0.0 - regex-applicative on text  https://hackage.haskell.org/package/regex-applicative-text-0.1.0.0 (phadej)
00:57:40 <dbushenko> is it in base?
00:57:47 <EvanR> package time
00:57:53 <dbushenko> ok, thanks!
01:05:25 <EvanR> that time library gets a lot of things right that most other languages and the libraries that try to fix them get wrong, though you might have to twist your brain a little to realize it
01:09:52 <ely-se> I yet have to find anything as good as Noda Time.
01:10:59 <hio> the syntax is so confusing, what is being put "in" here: let x = 8 * 10 in x + x  and if I write "x" again, it doesnt print 160 again
01:12:35 <ely-se> (for non-relativistic purposes, of course; if your problem involves relativity you need something else)
01:12:38 * hackagebot ipython-kernel 0.6.1.1 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.6.1.1 (gibiansky)
01:13:26 <bennofs> hio: let <bindings> in <expr>  means that all variable definitions in <bindings> are only visible in the expression <expr>
01:13:43 <m4lvin> hio: x is set to 80, then put  in x + x. the whole expression is 160, not x.
01:14:19 <bennofs> > (let x = 3; y = 5; in  x + y) -- after the in, I can use x and y.
01:14:21 <lambdabot>  8
01:14:37 <bennofs> > (let x = 3; y = 5; in  x + y) + y -- but x and y are not visible outside the let expression
01:14:39 <lambdabot>  3 + 5 + y
01:14:42 <bennofs> ugh
01:15:20 <bennofs> > (let foo = 3; bar = 5; in foo + bar) + foo
01:15:22 <lambdabot>      Not in scope: ‘foo’
01:15:22 <lambdabot>      Perhaps you meant ‘T.for’ (imported from Data.Traversable)
01:17:37 <hio> ok so in reality theres 3 parts: variables, bindings, expression, let variable = binding in expression
01:17:49 <dramforever> exactly
01:18:16 <arkeet> and the whole thing is also an expression
01:18:18 <dramforever> wait "in reality" -> in theory it's also the same
01:18:44 <bennofs> > let y = (let x = 4 in x + x) in y * y -- you can even nest lets!
01:18:45 <lambdabot>  64
01:19:06 <arkeet> not that there's a huge amount of value in doing so.
01:19:25 <hio> but why cant i say let y = 50 in x + x, when is what being assigned here? y is assigned at the last moment, so that means x is unassigned and that's why it gives me back a mathematical expression instead of evaluating the expression?
01:19:25 <arkeet> > let { x = 4; y = x + x } in y * y
01:19:27 <lambdabot>  64
01:19:40 <arkeet> there is no assignment.
01:19:43 <dramforever> hio: because there's a global variable named x
01:20:09 <dramforever> it's some interesting stuff you probably shouldn't be concerned about for now
01:20:12 <bennofs> hio: that's a weird lambdabot feature. it doesn't work in normal ghci
01:20:22 <dramforever> bennofs: it works in haskell.org REPL
01:20:26 <bennofs> > let foo = 50 in bar + bar -- that's how it normaly works
01:20:28 <lambdabot>      Not in scope: ‘bar’
01:20:28 <lambdabot>      Perhaps you meant one of these:
01:20:28 <lambdabot>        ‘Sym.var’ (imported from Data.Number.Symbolic),
01:20:29 <bennofs> dramforever: ugh
01:20:43 <bennofs> dramforever: /me thinks it should be disabled there
01:20:49 <dramforever> sure
01:21:04 <dramforever> I assume hio understands it
01:21:18 <arkeet> when you say let y = 50 in <expr>, then y is 50 in <expr> (i.e. where it's in scope)
01:21:21 <Clint> is there a handy guide for converting from ixset to ixset-typed?
01:21:30 <hio> i probably defined x earlier so that's why it was still there as a global var
01:21:36 <dramforever> no
01:21:54 <dramforever> it's because there's some imported library interfering with your expression
01:22:35 <bennofs> hio: there is a global definition for x that's defined by the haskell.org REPL (it wasn't you who defined it, it's defined by default)
01:22:38 <dramforever> IMHO it's very bad to import that module, but I guess we need to make do with it
01:22:49 <dramforever> hio: not trying to make you fell embarassed, but are you feeling like re-learning programming from scratch?
01:22:56 <dramforever> don't worry, that's how haskell works
01:23:12 <hio> i am, the way that the code is structured doesnt resemble anything I know..
01:23:17 <dramforever> =)
01:23:36 <dramforever> hio: that's why we said "you can't just start with db/file io/..."
01:23:44 <dramforever> because you simply don't know the basics
01:23:52 <hio> well but I liked the file reading stuff in the tutorial
01:23:53 <mikeplus64> > let {;;;;;;;;;;;;;a=1;;;;;;;;;;;b=32;;;;;;;;;c=23;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;} in a*b+c
01:23:55 <lambdabot>  55
01:24:00 <dramforever> but good thing: the basics of haskell isn't very large
01:24:30 <bennofs> mikeplus64: wth
01:24:30 <dramforever> case, application, lambda, recursion and that's pretty much it
01:24:40 <dramforever> oh sure also some ADT
01:24:49 <arkeet> haskell at its core is quite simple. (simpler than quite a few other languages I can think of.) it's just rather different.
01:24:51 <dramforever> (you aren't expected to understand those terms)
01:24:52 <arkeet> :p
01:24:56 <hio> i downladed the haskell platform now, no more online gui for me :)
01:24:57 <dramforever> =P
01:25:15 <ttt_fff_> OMG
01:25:21 <dramforever> ttt_fff_: ++
01:25:21 <ttt_fff_> you have been developing all this time ina a web browser?
01:25:24 <bennofs> hio: btw, i was wondering (if we're trying to improve the "get haskell" experience), are you on windows?
01:26:07 <ttt_fff_> hio: this is the red pill https://github.com/begriffs/haskell-vim-now
01:26:12 <ttt_fff_> use it if you want to beat the shit out of agent smith
01:26:23 <ttt_fff_> dramforever: ++
01:26:30 <dramforever> ++ ++
01:26:42 <bennofs> ttt_fff_: does it work on windows?
01:27:06 <ttt_fff_> bennofs: I don't know; it involves running a shell script, which builds everything, 
01:27:13 <bennofs> oh, then not
01:27:26 <ttt_fff_> bennofs: also, if you are using windows; you have bigger problems
01:28:20 <mrkkrp> Hello, should I report ‘ghc panic Loading temp shared object failed’ sort of thing? I've found this: https://ghc.haskell.org/trac/ghc/ticket/10761 . I should note that my project doesn't use template Haskell at all.
01:28:20 <hio> bennofs: i am on windows now
01:28:31 <bennofs> ttt_fff_: that's not the right attitude IMO (even though I'm using NixOS)
01:29:07 <ttt_fff_> bennofs: nixos inside a VM, or nixos directly off of windows (cygwin) ?
01:29:17 <bennofs> ttt_fff_: NixOS on bare metal
01:29:34 <ttt_fff_> oh, your machien boots into nixos?
01:29:36 <bennofs> yes
01:30:06 <dramforever> wow
01:30:15 <dramforever> bennofs: do most things work?
01:30:28 <ttt_fff_> nixos is pretty nice
01:30:34 <ttt_fff_> I never got it to work, but it seemed awesome
01:30:37 <ttt_fff_> the documentation sucks
01:30:42 * dramforever will probably stick to fedora
01:30:43 <bennofs> dramforever: well, what I needs works
01:30:45 <dramforever> better support
01:30:45 <ttt_fff_> the channel is not as active as #haskell
01:30:49 <dramforever> bennofs: maybe
01:30:51 <ttt_fff_> but the idea behind it is fucking awesome
01:31:27 <dramforever> bennofs: at least make browser, editor and ghc and gcc-family stuff work
01:32:34 <bennofs> dramforever: I've emacs, hipchat, skype, conkeror (browser, but firefox/chromium works too), weechat, xmonad, xmobar, automounting with udiskie
01:32:49 <dramforever> that looks like enough
01:33:46 <ttt_fff_> aren't you lacking an editor, like vim ?
01:34:08 <bennofs> + some scripting so I can load any haskell project with a cabal file in 3 commands (and it fetches most haskell lib deps from binary cache, so it's fast (but only for GHC 7.10)): themplate init <project> haskell-nix; cd <project>; dev-shell :)
01:34:13 <ttt_fff_> 1/3rd of your aps are chatting
01:34:20 <ely-se> bennofs: why do you need hipchat, skype, conkeror (browser, but firefox/chromium works too), weechat, xmonad, xmobar, automounting with udiskie if you have Emacs?
01:34:20 <bennofs> ttt_fff_: I've got Evil
01:34:43 <ttt_fff_> bennofs: why are you booting into nixos instead of emacs ?
01:34:47 <ttt_fff_> ely-se++
01:34:48 <bennofs> ttt_fff_: lol
01:35:22 <dramforever> why are you booting into emacs instead of ghci?
01:35:26 <ely-se> also I didn't know conkeror was still a thing
01:36:01 <ttt_fff_> why aren't you using https://en.wikipedia.org/wiki/House_(operating_system) 
01:36:06 <ely-se> or anything but Chrome, Chromium or Firefox, really
01:36:12 <ttt_fff_> I I thikn I win. ONe up that.
01:36:14 <ely-se> ttt_fff_: why aren't you using TempleOS?
01:36:18 <dramforever> looks good
01:36:34 <ttt_fff_> ely-se: because it doesn't have haskell
01:36:43 <ely-se> but it has HolyC
01:37:04 <bennofs> let's move this to #haskell-blah if we want to continue, it's getting quite offtopic
01:38:22 <ely-se> as you wish, my majesty
01:39:16 <ttt_fff_> bennofs: may your reign be typesafe, may the the untyped never dare invade the lands so long as you rule
01:41:28 <ttt_fff_> damn; I just realized, evaluation by substitution can be really really fucknig expensive
01:41:31 <ttt_fff_> maybe I should not do that
01:41:57 <arkeet> you don't get any sharing that way.
01:41:59 <bennofs> that's why Haskell is call-by-name
01:42:40 <arkeet> graph reduction is the way to go
01:42:42 <quchen2> Is it?
01:42:42 <dramforever> ttt_fff_: try to use a graph
01:42:56 <quchen2> Call by name, that is
01:43:03 <dramforever> call-by-need
01:43:11 <bennofs> oh, I always confuse the two
01:43:24 <quchen2> Is it? :-þ
01:43:50 <bennofs> o right, evaluation by substitution is like call by name
01:43:55 <quchen2> Unspecified evaluation order allows you to call things at random to a certain degree
01:44:26 <quchen2> For example evaluating the RHS of seq always first
01:44:27 <EvanR> hio: read it as "let x be 2 in x + x"
01:44:44 <ely-se> Remove partial functions and all you need is call-by-whatever.
01:44:48 <EvanR> or let x be equal to foo in something
01:45:14 <dramforever> hio: later on when you understand how haskell code is evaluated it will make more sense
01:45:18 <hio> so it's not really an assignment at all, it just executes code
01:45:27 <dramforever> hio: it's just an expression
01:45:28 <arkeet> it is a definition.
01:46:05 <EvanR> hio: well whatever you want to call it, x has that value in the scope of the let body, the part after in
01:46:26 * dramforever wants to draw a graph
01:46:37 <arkeet> (a variable has the same value wherever it's in scope. it gets its value from its definition. I don't like the term "assignment" because it implies that you can somehow reassign it to something else later.)
01:47:30 <EvanR> which you can!
01:47:35 <EvanR> > let x = 5 in (x + let x = 4 in x)
01:47:36 <lambdabot>  9
01:47:36 <liste> in imperative languages, variables are like boxes you put values in
01:47:49 <merijn> EvanR: No, you can't
01:47:49 <arkeet> EvanR: no
01:47:53 <arkeet> that's a different x inside :-)
01:48:00 <arkeet> that shadows the outer x
01:48:01 <EvanR> you can still reassigning "x"
01:48:03 <merijn> EvanR: You can just shadow it with a different variable that happesn to have the same name
01:48:03 <EvanR> you are*
01:48:13 <EvanR> yes its called shadowing, not reassigning
01:48:14 <arkeet> that's like in C:
01:48:19 <EvanR> but still
01:48:26 <liste> in Haskell, variables are just names for values
01:48:27 <arkeet> int x = 5; { int x = 4; stuff }
01:48:53 <EvanR> i dont think the established language is unambiguous enough to describe what you mean
01:49:04 <EvanR> for anybody unfamiliar with it
01:49:32 <lpaste_> dramforever pasted “here we go, a graph for let x = 2 in x + x” at http://lpaste.net/138487
01:49:50 <arkeet> here: http://www.vex.net/~trebla/haskell/lazy.xhtml
01:49:55 <dramforever> I used boxes because otherwise it might not be obvious where the vertices are
01:49:58 <EvanR> hio: also on the language front, its a good idea to talk about the let being evaluated rather than executed
01:50:05 <merijn> dramforever: You know Apfelmus wrote a nice in-depth article too, that includes a graphic like that? :)
01:50:16 <dramforever> merijn: no
01:50:24 <merijn> dramforever: https://hackhands.com/guide-lazy-evaluation-haskell/
01:50:30 <merijn> It's pretty good for beginners, I think
01:50:41 <dramforever> also if I could get ghc-vis working I can let a program draw this graph out for you
01:50:44 <dramforever> or no, maybe?
01:50:58 <EvanR> theres a haskell program for drawing graphs of haskell somewhere
01:51:17 <dramforever> hio: how about this: just pretend you are re-learning programming and try not let any previous misconceptions affect you
01:51:26 <arkeet> unlearning is hard :-)
01:51:42 <dramforever> just try to hide them
01:51:44 <dramforever> like ghc
01:51:50 <arkeet> pretend you're not learning programming.
01:51:54 <arkeet> and that you're learning math instead.
01:51:59 <arkeet> except math that runs on a computer.
01:52:05 <arkeet> I dunno.
01:52:10 <arkeet> maybe I should sleep.
01:52:12 <EvanR> i learn chinese i need to unlearn english
01:52:30 <dramforever> EvanR: no you don't
01:52:34 <EvanR> i know
01:52:34 <dramforever> you need to hide English
01:52:44 <dramforever> source: I'm Chinese I don't need to unlearn English
01:52:47 <merijn> EvanR: I heard Chinese grammar is pretty simple. It's the pronunciation that's a pain :p
01:53:01 <dramforever> merijn: no Chinese grammar is complexed
01:53:06 <EvanR> was never really into grammar anyway
01:53:17 <dramforever> lots of weird sentence structures and idioms
01:53:43 <AaronFriel> Dear #haskell, I have some perf-sensitive code that I would like to use to improve `mappend`-ing two ByteStrings together, and I want to use this improved `mappend` whenever I can, but still allow the code to be generic and default to standard `mappend` for non-specialized implementations
01:53:48 <dramforever> wait move to #haskell-blah
01:53:56 <EvanR> grammar is either ignored by your party or pisses your party off, useless
01:54:31 <AaronFriel> The specialization is: if two ByteStrings are contiguous and share the same ForeignPtr, you can append them without allocation
01:54:51 <merijn> AaronFriel: How would you detect that?
01:54:52 <arkeet> AaronFriel: can a rewrite rule do it?
01:54:57 <dramforever> AaronFriel: I doubt if that will ever be true, also consider bytestring builders
01:55:01 <AaronFriel> arkeet: I don't... think so
01:55:17 <AaronFriel> dramforever: The code that I'm writing generates lots of consecutive, short bytestring references (O(1) refs)
01:55:30 <dramforever> this is much easier to use http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/Data-ByteString-Builder.html
01:55:35 <AaronFriel> dramforever: It's true basically 100% of the time, and `Builder` is killing my perf too
01:55:44 <EvanR> you dont always reallocate the storage
01:55:48 <dramforever> okay then
01:56:03 <AaronFriel> I've done the homework (aka Criterion benchmarks)
01:56:34 <AaronFriel> My use case involves reading and incrementally parsing bytestrings, and *almost always* the parse steps return an existing substring
01:56:47 <AaronFriel> In the not-almost-always case, it returns a different string
01:57:06 <dramforever> okay that sounds a bit weird
01:57:09 <AaronFriel> Yeah it is
01:57:10 <EvanR> and then you put all the parts back to gether again in the same order?
01:57:14 <AaronFriel> Yep.
01:57:16 <EvanR> why/
01:57:30 <berdario> Hi, I want to do mapKeysMonotonic show
01:57:34 <dramforever> AaronFriel: can you just walk through the string?
01:57:35 <AaronFriel> I'm writing a web proxy
01:57:39 * hackagebot hOpenPGP 2.2 - native Haskell implementation of OpenPGP (RFC4880)  https://hackage.haskell.org/package/hOpenPGP-2.2 (ClintAdams)
01:57:41 <berdario> obviously, this is bad, since 9< 10 True
01:57:48 <berdario> but "9" < "10" False
01:58:03 <berdario> this thing only needs to be subsequently serialized to JSON
01:58:22 <dramforever> AaronFriel: too bad...can't you just parse the string without extracting?
01:58:28 <berdario> so, the only thing that matters to me is that values won't get lost
01:58:39 <bennofs> > "9" < "10"
01:58:41 <lambdabot>  False
01:58:44 <merijn> berdario: Well obviously "9" < "10"
01:58:45 <bennofs> oh right
01:58:47 <EvanR> AaronFriel: instead of buildering, how about modify stuff using a fast replacement after parsing and figuring out what you want ot do
01:58:49 <dramforever> after you parsed that tell the caller how many bytes do you want to eat
01:59:03 <AaronFriel> EvanR: Unfortunately I'm almost always replacing with larger chunks.
01:59:04 <merijn> eh, well obviously it's not true, I mean
01:59:16 <EvanR> yeah the size doesnt matter
01:59:30 <dramforever> AaronFriel: let me see, is it true that most of the time you are just copying?
01:59:50 <berdario> merijn yup, do you think that what I'm doing is risky? what are the consequences of a malformed Map? will it just become unbalanced?
01:59:54 <AaronFriel> dramforever: If at all possible, not copying. Look, I've got the implementation doing what I want with ByteString
02:00:15 <AaronFriel> dramforever: What I want is to write a parser that will handle more types and use a specialized `mappend` instance in cases where it can do this 0-copy append
02:00:20 <merijn> berdario: I didn't see you say what you wanted to do?
02:00:24 <arkeet> berdario: it might end up broken.
02:00:34 <dramforever> AaronFriel: no don't do that it's fragile
02:01:11 <arkeet> lookups could fail
02:01:13 <berdario> merijin, I want to define instance  ToJSON (Show k, ToJSON v => Map k, v)
02:01:22 <EvanR> i think an efficient replace would be better than a parsing plus mostly the same reconstruction
02:01:24 <berdario> (actually, it's more specific than that)
02:01:24 <dramforever> AaronFriel: so can you change your parser so that it doesn't return substrings, but lengths of strings?
02:01:26 <AaronFriel> dramforever: Okay, but, why? Dammit, I really want something like a disjunctive type class. Like, "CanZeroCopyAppend s => " and "otherwise => "
02:01:34 <dramforever> sigh
02:01:37 <berdario> merijn k is actually a Database.Persist.Sql.Key
02:01:54 <merijn> berdario: I dunno how ToJSON works, so no clue about the sanity of that
02:01:55 <berdario> which is also instance of ToJSON
02:02:00 <dramforever> AaronFriel: convince me that this is not happening: http://xyproblem.info
02:02:02 <EvanR> AaronFriel: you can do that
02:02:14 <EvanR> but probably shouldnt
02:02:40 * hackagebot hopenpgp-tools 0.16 - hOpenPGP-based command-line tools  https://hackage.haskell.org/package/hopenpgp-tools-0.16 (ClintAdams)
02:03:03 <AaronFriel> dramforever: Probably a little of XY-problem, but a big chunk of "being constrained by my problem domain", which is handling tokenization in a weird way
02:03:14 <AaronFriel> dramforever: See: http://www.w3.org/TR/2011/WD-html5-20110113/tokenization.html
02:03:44 <EvanR> you keep talking about parsing, but your performance problem sounds like its about unparsing
02:03:47 <dramforever> AaronFriel: what parser library are you having?
02:03:54 <dramforever> *using
02:03:58 <dramforever> or just a loop?
02:04:02 <dramforever> maybe it's just a loop
02:04:33 <AaronFriel> dramforever: Currently attoparsec. The problem isn't the parsing, as far as I can tell. It's the GC time. I'm getting very low mutator %s (20-30%) and most of the allocation is happening with ByteStrings, even when I use Builders
02:05:22 <merijn> AaronFriel: Is it maybe because you're allocating lots of BS and they are pinned?
02:05:33 <dramforever> AaronFriel: yes, and at what occasions will your code return a different string?
02:05:38 <merijn> You could try the special "short" ByteString thing that lives on the heap
02:05:39 <AaronFriel> dramforever: I could rewrite my parser to return (Either Length (Length, ReplacementStr)) everywhere, but I run the (painful) risk of making a mistake and reading off the end of the ByteString
02:05:40 <dramforever> is it very isolated?
02:05:47 <merijn> Not allocating pinned memory should be much faster
02:06:00 <merijn> It's a bad idea for strings >20 bytes, though
02:06:11 <AaronFriel> dramforever: It's a compliant HTML parser, I'm returning substrings as short as 1 byte. 
02:06:12 <dramforever> merijn: no AaronFriel wants to get rid of those allocations altogether
02:06:29 <AaronFriel> dramforever: Precisely! And I can do that for *one type*, but I am rewriting my parser
02:06:42 <AaronFriel> dramforever: I already solved my perf problem for ByteStrings, to be clear
02:06:50 <merijn> dramforever: Sure, but heap allocation will *dramatically* cut the cost of allocation if they can't easily be eliminated
02:07:03 <merijn> dramforever: Allocating pinned is REALLY expensive
02:07:05 <dramforever> I think there's a function that returns the substring consumed by a parser
02:07:10 <merijn> Heap allocation is REALLY cheap
02:07:42 <EvanR> parsing and getting substrings doesnt allocate bytestring bodies
02:07:53 <AaronFriel> dramforever: I tested it, and I'm relying on an implementation detail of Attoparsec right now. (It just so happens that the `string` combinator will return a substring from the source, most of the time) 
02:08:09 <berdario> merijn fwiw, it's using Data.Map.foldrWithKey to convert it to an HashMap
02:08:33 <berdario> I guess that I could generate an HashMap in the first place, which possibly doesn't have this problem
02:08:38 <AaronFriel> EvanR: True, but when you want to concatenate your tiny ByteStrings again, I found that even `Builder` wasn't giving me the perf I wanted 
02:09:25 <AaronFriel> Again, I'll repeat: I solved my perf problem for ByteString. What I want is to generalize this piece of code, somehow, so that it can use "FancyZeroCopyAppend" in one instance, and "LameMoreExpensiveAppend" in others
02:09:44 <EvanR> i have a feeling that wont help
02:09:49 <EvanR> even if it were convenient
02:09:55 <merijn> AaronFriel: That's likely impossible without a huge pile of ugly/brittle hacks, IMO
02:10:01 <AaronFriel> merijn: Okay
02:10:19 <AaronFriel> EvanR: I am trying to say I have already solved my ByteString perf issue, what I want to do is generalize the code
02:10:30 <EvanR> then you can put that code in a new type class
02:10:41 <EvanR> implement the class for all the types you want to substitute
02:10:44 <dramforever> AaronFriel: like this
02:10:47 <EvanR> most of time in a "time way"
02:10:49 <EvanR> a "dumb way"
02:10:50 <AaronFriel> EvanR: Because the same hack will also work for... Text, and probably also Vector, and a few others
02:11:09 <EvanR> class VeryCleveryAppend a where
02:11:18 <EvanR>   vcappend :: a -> a -> a
02:11:42 <dramforever> AaronFriel: no it won't because you need to construct bytestrings
02:11:58 <dramforever> class ByteStringLikeOrWhateverName a where
02:12:13 <EvanR> if you dont have a use case for the supposed generalization then might not be worth worying about
02:12:17 <dramforever> fromByteString :: ByteString -> a; toByteString :: a -> ByteString
02:12:31 <dramforever> AaronFriel: and use a newtype to wrap your bytestrings
02:12:35 <tdammers> isn't that just Storable or sth?
02:12:37 <AaronFriel> EvanR: I do have a use-case for the generalization
02:12:58 <dramforever> and define an alternative Monoid instance
02:13:04 <dramforever> AaronFriel: does it make sense?
02:13:06 <EvanR> right, Storable
02:13:08 <AaronFriel> dramforever: Oh, that's it! that actually I think is the right thing to do. Use a newtype that doesn't implement `mappend`
02:13:15 <dramforever> no
02:13:22 <dramforever> use a newtype that implements another mappend
02:13:29 <AaronFriel> dramforever: Well, sorry, yeah, implements its own instance
02:13:39 <AaronFriel> dramforever: I don't know why that didn't occur to me earlier
02:13:47 <dramforever> no make it implement Monoid
02:13:54 <dramforever> also ByteStringLike
02:13:57 <AaronFriel> dramforever: I know, I know
02:14:28 <AaronFriel> dramforever: I'm good to go know, I just don't know why it didn't occur to me to use a newtype.
02:14:35 <AaronFriel> now*
02:14:37 <dramforever> =)
02:14:50 <ttt_fff_> leonard ravenhill
02:15:04 <EvanR> ByteStringLike might be going overboard with the type classes
02:15:54 <AaronFriel> dramforever: I just kept looking at the "closed type families" documentation, and I kept feeling like I was *almost there* with some arcane series of symbols involving constraints and instances and families
02:16:32 <EvanR> if its generic code, no need to mention ByteString
02:16:46 <EvanR> if its not generic, you want to be able to control how bytestring is generated
02:17:20 <AaronFriel> Right, I'll just use newtype and use a custom Monoid instance for my ZeroCopyByteString
02:31:10 <lpaste_> AaronFriel pasted “Zero Copy Append?” at http://lpaste.net/5811596393692790784
02:31:21 <AaronFriel> EvanR: I think this is basically what I want?
02:33:05 <AaronFriel> EvanR: Nevermind, undecidable instances are required to get the instance for things that already have Monoid types
02:33:34 <bennofs> AaronFriel: why not just make ZByteString a monoid that uses zero append when possible and falls back to slow append when not?
02:33:49 <quicksilver> undecidable instances is fine - it just puts the burden of proof on you
02:33:57 <quicksilver> overlapping and incoherent are the ones to avoid.
02:34:24 <AaronFriel> bennofs: I think I figured out what I wanted, sketching it out now in GHCi. 
02:36:56 <jubaedprince> hey everyone
02:39:43 <jubaedprince> i am new to haskell
02:40:17 <liste> hello
02:40:22 <Taneb> Hi jubaedprince, how are you finding Haskell so far?
02:40:48 <jubaedprince> hey, actually I need a starting point
02:41:10 <arkeet> @where learnhaskell is a good starting point
02:41:10 <lambdabot> https://github.com/bitemyapp/learnhaskell
02:41:35 <jubaedprince> thanks
02:43:22 <dramforever> wow
02:43:48 <dramforever> using a strong type system I just avoided a design issue
02:46:11 <Taneb> :)
02:46:38 <dramforever> I store the nicknames of clients in a TVar for 2 reasons
02:46:44 <dramforever> 1. they could be changed
02:47:06 <dramforever> 2. it's possible to have a client that doesn't have a nick, in which case nothing much could be done
02:48:03 <dramforever> I also have an Event type, one of them is Message Client ByteString, which means a message recieved
02:48:29 <dramforever> and because I used TVar, I found a problem with this approach
02:49:23 <dramforever> it's not possible to store the whole client in the event, because the client could have changed while sending this event back to the user
03:04:12 <EvanR> AaronFriel: you can use newtype?
03:04:27 <martinvlk> @pl (\el -> (numJars el, el))
03:04:27 <lambdabot> (,) =<< numJars
03:04:30 <AaronFriel> EvanR: Yes, it works for my purposes just fine
03:05:18 <EvanR> dramforever: database
03:05:28 <EvanR> transactional etc
03:05:28 <dramforever> huh
03:05:32 <dramforever> oh and?
03:05:59 <EvanR> i thought you had a problem with stuff changing under your nose guess not
03:06:15 <dramforever> what's going on
03:06:20 <AndChat196224> Any one here watches Mr robot here
03:07:07 <dramforever> weird
03:08:41 <AndChat196224> Every one watches private
03:10:12 <AndChat196224> Can I private msg any 1
03:10:28 <EvanR> no
03:10:46 <AndChat196224> What Is the topic 
03:10:55 <tsani> I've got a question concerning the servant tutorial: it's mentioned that it's necessary to define a dummy inhabitant of the type Proxy API (where API your API's type) in order to guide the type inference. Can someone explain why that is?
03:11:27 <tsani> Specifically, it's about 1/8th of the way down on this page http://haskell-servant.github.io/tutorial/server.html
03:12:15 <alpounet> tsani: i've answered this on SO
03:12:42 <tsani> alpounet: great! I'll have a look there
03:13:16 <alpounet> tsani: let me know if you don't find it
03:13:23 <alpounet> (sorry, i'm on the phone)
03:15:28 <tsani> alpounet: I found your answer, and it clears things up a bit. Thanks :)
03:16:33 <alpounet> tsani: something's not clear yet?
03:17:41 <tsani> Well, this specific case is clear to me now. The explanation relying on the non-injectiveness of type families makes sense to me. I'd like to learn more about type families though before I can say that I'm 100% comfortable with the idea.
03:20:36 <alpounet> tsani: well, let me know if i can help you clarify something
03:25:12 <AndChat196224> Can what is advantage og haskell
03:26:21 <tdammers> propr speling
03:26:37 <tdammers> seriously though, books can be filled on the topic
03:26:49 <EvanR> chr, ord, fst, snd
03:26:56 <EvanR> you will learn so much spelling
03:27:09 <phadej> oh noes. I realised that using stack screws the download stats on hackage (as packages aren't downloaded from there directly) :*
03:27:17 <phadej> :(
03:27:23 <tdammers> >>= ++ <> !! \\ -> :: ~
03:27:37 <AshyIsMe> phadej: does stackage keep stats?
03:27:48 <tdammers> phadej: the download stats aren't very meaningful anyway, are they?
03:28:29 <phadej> AshyIsMe: probably not, as they are fetched from S3
03:28:42 <tdammers> if I code in a way that has me bork my cabal sandbox all the time, I might re-download everything on a daily basis, but if I install everything globally and code very defensively, I won't even redownload for new projects
03:28:58 <phadej> tdammers: they are for comparison (someone uses this, no-one uses this)
03:29:05 <AndChat196224> Can any 1 tell me the applicatioN of haskelll
03:29:16 <phadej> if everyone uses stack, then that goes away
03:29:22 <tdammers> yeah
03:29:24 <AshyIsMe> phadej: s3 buckets can have logging turned on
03:29:29 <dramforever> one use case: facebook spam filter
03:29:39 <tdammers> but "10000 downloads" vs. "500 downloads" still doesn't say a lot this way
03:29:41 <dramforever> AndChat196224: ^
03:29:54 <tdammers> "2 downloads" vs "100000 downloads", sure
03:30:07 <quchen2> Haskell is a programming language. It's good at creating programs.
03:31:44 <mazur> can anyone see if this is possible in liquidhaskell: http://lpaste.net/138490 ?? i'm trying to force Basis3 to be independent vectors, but i get `Sort Error in Refinement` on the type specification of `m`
03:31:50 <apo_> I thought people created programs
03:32:35 <edk> more efficiently when they cooperate with a programming language
03:33:07 <quchen2> More effectively when a programming language cooperates with them
03:33:20 <phadej> tdammers: yeah, many packages don't have any revdeps either, because all o f them are proprietrary programs
03:33:25 <AshyIsMe> phadej: maybe if you raise a ticket for stackage they will turn on the s3 logging and put the stats on the stackage pages
03:33:38 <frerich> but, if my Haskell program generates code - am I the creator, or is it my Haskell program? *pours in some more red wine*
03:33:47 <tdammers> phadej: yeah, and I suspect some of the biggest Haskell users run their own hackage mirrors
03:34:15 <tdammers> frerich: if a program is written, but nobody is there to run it...
03:34:35 <frerich> tdammers: That, too.
03:35:59 <quchen2> tdammers: You can do a lot of computation without running the program! :-)
03:48:51 <afons> In the Haskell's community what is the most used / best graphics / game library?So 
03:48:58 <afons> So I can build games and GUI applications.
03:49:32 <mpickering> Say I have a type M () and want to add an extra parameter so it becomes  M w () but w should always be a monoid, is there a way to specify this without adding Monoid w => to every function which uses M?
03:50:11 <EvanR> only add it to the function that needs w to be a Monoid
03:50:26 <liste> afons try gloss for simple(ish) programs
03:50:32 <mpickering> but then that propagates all the way up no?
03:50:39 <EvanR> up?
03:51:08 <frerich> mpickering: Yes, which makes sense if you think about it, no?
03:51:40 <mpickering> sure it makes sense but the question is there a way to avoid it?
03:51:53 <mpickering> I don't want to edit all of my functions with a Monoid w constraint if I can specify it once
03:52:31 <EvanR> i think in this case haskell is forcing you to do it the better way
03:52:51 <frerich> mpickering: In 'f x = g x + 1', if 'g' has a Monoid requirement then clearly so does 'f'. I'd say it's morally dubious to impose this requirement  on functions without also declaring this requirement in the type of functions.
03:53:35 <afons> liste: what about for more complicated stuff? I've heard something about SDL but not sure
03:53:37 <EvanR> of course you can omit the type completely ;)
03:53:43 <merijn> mpickering: No, there is no way to avoid it
03:53:45 <EvanR> afons: opengl, glfw
03:53:48 <mpickering> I want to declare the requirement but not 100 times
03:54:04 <afons> EvanR there is an opengl library for haskell?
03:54:04 <EvanR> is it literally 100 times
03:54:08 <merijn> mpickering: You only need to declare it on functions that use the fact that it;s a monoid
04:18:54 <berdario> Uhh... I'm getting a linking error with Stack
04:19:02 <berdario> I already tried with `stack clean`
04:23:01 <berdario> ok, I just needed to add `other-modules` in my .cabal
04:23:21 <berdario> I hoped that it'd been able to sort it out automatically with hs-source-dirs
04:27:46 * hackagebot MailchimpSimple 0.1.0.0 - A Haskell library to handle mailing lists in MailchimpSimple using its JSON API.  https://hackage.haskell.org/package/MailchimpSimple-0.1.0.0 (dananji9131)
04:37:44 <Gurkenglas> It might be a generally useful exercise to refactor your higher-up functions into not needing to use monoid
04:38:32 <Gurkenglas> For example transforming f x = g x + 1 into (+1) and having the caller use the g themselves
04:55:24 <hio> okay but Haskell doesnt really make you a FASTER programmer right? it takes more time to make stuff in haskell?
04:55:50 <merijn> hio: I don't think so, but I think it takes longer to get to the point where you're fast :)
04:55:59 <frerich> hio: Not really, no.
04:56:00 <merijn> hio: There's many excellent high-level libraries that let you do amazing things
04:56:20 <merijn> hio: I wrote a massively parallel webscraper for some webcomics in 78 lines of code (21 of which were imports...)
04:57:51 <notdan> merijn: are you using async and wreq?
04:58:16 <dramforever> hio: haskell doesn't make you faster, you make yourself faster
04:58:40 <dramforever> haskell does make you think more carefully, because of the type inference/checking going on
04:58:43 <merijn> notdan: http-conduit and async
04:59:19 <merijn> notdan: Using a hacky MonadIO orphan for the Concurrently monad (which is apparently not a legal monad so they're removing that in future async releases :\)
04:59:40 <merijn> notdan: https://gist.github.com/merijn/d8188ddd129718ffcfb0
04:59:49 <dramforever> "you can't have a side effect here", "this read needs synchronization"
04:59:55 <rlewis> hio more time compared to what?
05:00:04 <dramforever> said the type system
05:00:45 <hio> well it definitely seems harder to read than imperative code
05:00:59 <liste> hio at first, of course
05:01:08 <rlewis> english is harder to read than german if you don't know it
05:01:19 <liste> but when you get used to it gets more clear imo
05:01:47 <dramforever> hio: maybe, maybe not
05:01:56 <dramforever> it depends on what the program is and how you write it
05:02:22 <liste> the declarativeness of functional code makes the intent more clear for me
05:02:39 <merijn> hio: Like I said, my example code only is that short because I use a bunch of common libraries and if you're not familiar with them it's not obvious what's going on
05:02:56 <liste> like sum [1..100] versus for (i=0; i<100; i++) { i = i + 1; }
05:02:59 <merijn> hio: As I said, I think it's easy to be really productive in haskell. But it takes longer to reach that point than other languages, perhaps
05:03:36 <hio> liste that's like that in python too
05:04:00 <merijn> hio: I'd like to see you write a multithreaded webscraper that is more readable, in an imperative language, btw :)
05:04:10 <liste> but in haskell it generalizes much further
05:04:16 <hio> is unit testing easier because of the functional nature of haskell?
05:04:22 <frerich> hio: Python certainly has plenty of functional components (list comprehensions, for instance). At the same time you can also write an imperative program in Haskell.
05:04:41 <dramforever> hio: yes, for example we have quickcheck
05:04:59 <dramforever> that generates a large amount random input for your function
05:05:07 <dramforever> and check if the output is correct
05:05:16 <hio> there should be a glossary, like I can't google what the $ operator is
05:05:17 <dramforever> of course you tell the library what "correct" means
05:05:22 <dramforever> hio: hoogle
05:05:27 <dramforever> @where hoogle
05:05:27 <lambdabot> http://haskell.org/hoogle http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
05:05:33 <notdan> merijn: cool :)
05:05:36 <dramforever> yes these three things, pick one
05:10:20 <cocreature> there is a fourth http://hoogle.haskell.org/ :)
05:10:37 <dramforever> I assume hio "heard" that
05:32:49 * hackagebot tianbar 0.4.7.0 - A desktop bar based on WebKit  https://hackage.haskell.org/package/tianbar-0.4.7.0 (AlexeyKotlyarov)
05:52:18 <fmapE> /win 3
05:52:50 * hackagebot d-bus 0.1.3 - Permissively licensed D-Bus client library  https://hackage.haskell.org/package/d-bus-0.1.3 (PhilippBalzarek)
06:07:50 * hackagebot shadowsocks 1.20150811 - A fast SOCKS5 proxy that help you get through firewalls  https://hackage.haskell.org/package/shadowsocks-1.20150811 (rnons)
06:12:55 <zyxoas> Peeps. :-)
06:13:30 <zyxoas> How can I use HLint on code with extensions, such as MultiparameterTypeclasses and FunctionalDependencies?
06:15:15 <zyxoas> src/Network/Bitcoin/BitX/Internal.hs:53:44: Warning: Parse error: rec
06:15:15 <zyxoas> Found:
06:15:15 <zyxoas>             userSecret = Txt.encodeUtf8 $ (auth ^. Types.secret)
06:15:15 <zyxoas>     
06:15:15 <zyxoas>   > simpleBitXGetAuth_ :: BitXAesRecordConvert rec aes => BitXAuth -> String -> IO (BitXAPIResponse rec)
06:15:15 <zyxoas>     simpleBitXGetAuth_ auth verb = withSocketsDo $ do
06:15:16 <zyxoas>         rateLimit
06:15:16 <zyxoas>   
06:15:17 <zyxoas> 1 suggestion
06:15:21 <geekosaur> @paste
06:15:21 <lambdabot> Haskell pastebin: http://lpaste.net/
06:15:29 <geekosaur> don't paste directly into the channel please
06:15:40 <zyxoas> Oh. :-/
06:16:34 <zyxoas> http://lpaste.net/138499 :-/
06:16:44 <geekosaur> and the problem here is not that it doesn't support those extensions, it is that it is mishandling a different extension ("rec" is a keyword under https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/syntax-extns.html#idp23493472 but shouldn't be recognized as one there)
06:17:02 <geekosaur> so this is a bug in haskell-src-exts, which hlint uses to parse your code
06:17:03 <zyxoas> Rather than giving suggestions, it is complaining about bad syntax (which is enabled by extensions).
06:17:18 <zyxoas> Oh, snap!
06:22:03 <zyxoas> @geekosaur: That fixed it. Thanks a lot. :-)
06:22:04 <lambdabot> Unknown command, try @list
06:22:14 <zyxoas> geekosaur: That fixed it. Thanks a lot. :-)
06:22:50 <dramforever> weird
06:22:51 * hackagebot json-rpc 0.7.0.1 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.7.0.1 (XenoGenesis)
06:22:53 <geekosaur> probably should file a bug against haskell-src-exts since even with recursive do enabled it should not be intercepting "rec" outside of a do
06:22:59 <dramforever> that couldn't have fixed anything
06:23:10 <dramforever> or could it?
06:24:13 <geekosaur> haskell has a bunch of "keywords" that are only special in particular places (for example, "as" in an import does not prevent you from using "as" as a binding or type variable)
06:24:39 <zyxoas> That fixed my issue, dramforever. Now I have a bunch of other suggestions I need to deal with, since they were all masked by this issue. Hehe.
06:24:47 <geekosaur> likewise recursive-do stealing "rec" should not invalidate it as a type variabl;e
06:24:55 <dramforever> ok zyxoas =)
06:24:58 <xandaros> Trying to fix a space leak(http://i.imgur.com/r9uXYDz.png) in my snake game using frpnow and gloss. I have roughly figured out what is causing it, but not what exactly. The heap profile names a const center called "idleCallback", which is a gloss function that normally does not show this problem. The datatypes that seem to accumulate are events, behaviors, etc, so definitely my code. How can I further narrow
06:25:00 <xandaros> it down?
06:25:37 <a3gis> hello! I am posting this here as there is more activity than on ##logic or ##math. Please take a look if you have a minute! https://www.reddit.com/r/logic/comments/3gl7yv/firstorder_logic_derivation_tool_looking_for/
06:26:24 <zyxoas> quit!
06:27:24 <maerwald> that worked
06:27:51 * hackagebot yackage 0.8.0 - Personal Hackage replacement for testing new packages.  https://hackage.haskell.org/package/yackage-0.8.0 (MichaelSnoyman)
06:47:21 <zyxoas> Hmm...
06:48:03 <mniip> mhmm?
06:48:14 <zyxoas> I am trying to ignore Hlint suggestions, via "{-# ANN module "HLint: ignore" #-}", and cabal is giving me an error "File name does not match module name"
06:49:26 <geekosaur> where is the pragma in the file, relative to the "module" declaration?
06:49:46 <zyxoas> It's at the top. Let me paste it...
06:50:24 <geekosaur> I think it has to come after the "module"
06:50:53 <zyxoas> http://lpaste.net/138501
06:50:55 <zyxoas> Ah...
06:51:02 <geekosaur> it actually generates data, I think, which means the module must already be declared
06:51:24 <geekosaur> certainly it is parsing at that point and if it does not yet know the module name it will use "Main", leading to that error from ghc
06:52:47 <geekosaur> (because the annotation is an actual Haskell value and parsed as such --- not merely wrapped in quotes for protection. in particular you need to include a type if you have OverloadedStrings enabled...)
06:55:10 <zyxoas> Thanks, that did the trick. The Hlint docs don't seem to mention that.
06:55:44 <zyxoas> I had to put the annotation "{-# ANN module ("HLint: ignore Use camelCase" :: String) #-}" after the imports in the module, also note the explicit type annotation.
06:56:15 <zyxoas> Because I have OverlodedStrings enabled. Thanks, geekosaur. :-)
06:57:16 <concept> I am receiving data from a socket how can I buffer this data untill I receive certain amount
06:57:52 * hackagebot breve 0.4.2.0 - a url shortener  https://hackage.haskell.org/package/breve-0.4.2.0 (rnhmjoj)
07:02:53 * hackagebot moesocks 0.1.0.14 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.14 (JinjingWang)
07:18:37 <mietek> Is optparse-applicative the state of the art in Haskell options parsing?
07:19:06 <Clint> mietek: yes, unless you like cmdargs
07:19:35 <merijn> mietek: I'm not sure it's the "state of the art", but it's certainly the most preferred one
07:19:36 <mietek> I find the applicative interface rather confusing
07:19:53 <merijn> mietek: In a "most flexible/powerful & least magic" way
07:20:01 <merijn> mietek: In what way? :)
07:21:49 <juanpaucar> Hi everyone, which is the most idiomatic way to avoid nested cases to pattern match a maybe
07:21:58 <frerich> mietek: I also like getopt-generics
07:22:11 <merijn> juanpaucar: Use the Monad instance of Maybe? :)
07:22:15 <exio4> juanpaucar: using (>>=) / fmap / (<*>) 
07:22:22 <frerich> mietek: Maybe not the most powerful framework, but it's pretty how you can give it a data type and it builds a command line parser (with --help output and whatnot) out of it.
07:23:26 <juanpaucar> merijn: like liftM?
07:23:36 <juanpaucar> as exio4 mentioned?
07:23:39 <merijn> juanpaucar: Depending on the exact nesting pattern, yes
07:23:48 <merijn> > fmap (+1) (Just 1)
07:23:49 <lambdabot>  Just 2
07:23:52 <merijn> > fmap (+1) Nothing
07:23:54 <lambdabot>  Nothing
07:24:01 <xplat> i kinda wish getopts-generic depended on optparse-applicative
07:26:13 <berdario> I wasted 1 hour chasing an error due to FlexibleContexts :/
07:26:20 <mietek> merijn: here’s an example: https://gist.github.com/mietek/76da4152b5007c02bdfe
07:27:21 <merijn> mietek: I'd move the options into local definitions, btw easier to read that way
07:27:40 <mietek> That’s not the point.
07:27:49 <merijn> mietek: No, just generic comment :)
07:28:17 <mietek> By now I have my own combinators to wrap this stuff.
07:29:02 <merijn> mietek: So what's the point of confusion?
07:29:05 <mietek> Which means that instead of "O.command "road-links" (O.info (O.helper <*> O.pure RoadLinks) (O.progDesc "Return OS RoadLink polylines"))" I write "command "road-links" "Return OS RoadLink polylines" (O.pure RoadLinks)"
07:30:16 <mietek> If you see nothing wrong with the example code I pasted, then I’m not sure if I can explain. :)
07:30:17 <xplat> to me the most confusing part of optparse-applicative is where you finalize and run the parser at top level
07:30:46 <xplat> other than that everything is pretty easy
07:31:01 <merijn> mietek: It looks a little confusing to me, but I can't tell whether that's due to the way it's structured as one big expression or not
07:31:08 <merijn> I'm not familiar with O.helper
07:31:20 <mietek> How else do you add help text to your options?
07:31:57 <merijn> mietek: Lemme paste an option I have
07:32:09 <xplat> it's a little annoying that O.helper is necessary
07:32:12 <lpaste_> merijn pasted “optparse option” at http://lpaste.net/138503
07:32:39 <xplat> i'd kinda rather --help and such were just reserved
07:32:45 <mietek> Ah, but that’s for an option.
07:33:01 <merijn> oh, I haven't really used commands, tbh
07:33:29 <zennist> do I understand correctly that [X..] is the shorthand for enumFrom X
07:33:48 <mietek> So you say there’s least magic, but to me, knowing when I’m supposed to use <$> and <*> versus <> seems like a black art.
07:33:50 <merijn> zennist: Yes
07:33:52 <kadoban> zennist: Yep
07:33:54 <zennist> that's at least what I understood; but turns out [False..] doesn't work
07:34:00 <quchen> > [False ..]
07:34:02 <lambdabot>  [False,True]
07:34:09 <xplat> merijn: there's a place to store help, but you won't get help actually output without using helper somewhere.  (Or maybe you'll still get the usage message for illegal inputs, but not --help?)
07:34:15 <quchen> "False.." is interpreted as "(.) from the False module"
07:34:28 <quchen> Like Prelude.+ is (+) from the Prelude module
07:34:30 <zennist> quchen: that's wicked
07:34:37 <merijn> mietek: <$>, <*> and <> are just Functor, Applicative and Monoid, if you're not comfortable with those I guess I can see it as being a bit confusing
07:34:42 <xplat> mietek: you can tell by the types
07:34:44 <geekosaur> . is annoyingly overloaded in haskell
07:35:00 <merijn> mietek: But those 3 classes are so universal and ubiquitous you get used to them rather quickly
07:35:02 <geekosaur> (and then SPJ asked about supporting record.field a couple years ago... oyyyyyyy)
07:35:21 <zennist> so basically the correct syntax for [X ..] is always with space inbetween - except in some cases (e.g., integers, etc.) you can remove the space?
07:35:37 <geekosaur> with space is safest
07:35:42 <xplat> zennist: yeah, you can remove the space when it's not ambiguous
07:35:54 <mietek> merijn: you’re looking at it from the other direction.
07:36:11 <zennist> thanks guys, was banging my head for a while
07:36:16 <xplat> zennist: specifically, when it's not ambiguous to the *lexer*, the parser doesn't get a vote
07:36:27 <mietek> merijn: I know what Functor, Applicative, and Monoid are.  I don’t know why the combinators pertaining to commands are supposed to be joined together using <*>, but the combinators pertaining to options using <>.
07:36:37 <merijn> zennist: Ah, right, for details like this I'd recommend reading the Haskell Report
07:36:58 <merijn> zennist: It's very readable and it's a shame more beginners don't read it once they start to get comfortable with the language :)
07:37:13 <geekosaur> options are simple enough that Monoid is enough. commands require something stronger, i.e. Applicative
07:37:25 <merijn> :t (<*>)
07:37:26 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:37:29 <merijn> :t (<>)
07:37:30 <lambdabot> Monoid m => m -> m -> m
07:37:32 <zennist> merijn: yeah, I guess I should do that soon
07:38:16 <merijn> mietek: Note that <*> is using the function from "in" the first part to apply to the second argument
07:38:28 <merijn> mietek: Whereas <> is just combining two values
07:38:48 <merijn> "helper :: Parser (a -> a)"
07:39:48 <merijn> Which matches the "f (a -> b)" in <*> but not "<>" since "a -> a" is not a Monoid instance (well, it is theoretically, just not in haskell, unless you count newtypes)
07:40:34 <zennist> do people here tend to write 'vanilla' haskell or something more 'mixed-up'? Recently I chatted with some guys and I'm surprised that everyone was talking about conduit, arrow, lens, etc. instead of simple, good use of core stuff
07:40:50 <zennist> or maybe I'm still too much of a beginner :P
07:40:52 <tdammers> depends
07:40:53 <merijn> zennist: You're mixing up a bunch of stuff here :)
07:41:07 <merijn> zennist: Arrow is a typeclass which is just implemented in "plain" Haskell2010
07:41:12 <tdammers> but using libraries for abstraction patterns is very common
07:41:14 <merijn> zennist: conduit and lens are just libraries
07:41:21 <tdammers> lens just takes the approach quite far
07:41:56 <zennist> yes, I totally see that; it's just that when I write a haskell program I tend to just use what I have and use a library only when very necessary
07:41:58 <tdammers> the "non-plain" features here would be Template Haskell, and maybe quasiquotation, and a bunch of language extensions that these libraries depend on
07:42:01 <edwardk> zennist: depends on my problem. i have libraries that try to stay entirely haskell 98, or use minimal dependencies... and i have lens. ;)
07:42:18 <merijn> zennist: Use whatever makes life easier
07:42:29 <merijn> zennist: tbh, I hardly ever use lens
07:42:42 <zennist> I know lens is very handy but style-wise I tend to prefer the simpler (maybe a bit more verbose) versions? I don't know..
07:42:49 <merijn> zennist: On the other hand, pipes (and similarly for conduit) makes dealing with streaming data trivial
07:42:51 <xplat> zennist: generally people seldom take the approach in programming languages of 'just use the core library'
07:42:52 <edwardk> with lens my goal was to establish a rather large vocabulary for working with problems that i'd still be using in 2 years... it is now 3 years later, so i feel that I managed to succeed at that
07:43:03 <xplat> zennist: last time i made a practice of that was perl4
07:43:11 <merijn> edwardk: Can I pick your brain on something?
07:43:14 <edwardk> zennist: nothing requires you to use lens =)
07:43:17 <edwardk> merijn: sure
07:43:56 <zennist> cool cool, I guess I should be experiementing a bit more next time so that I don't get totally lost with these excellent libraries
07:44:00 <mietek> edwardk: what do you think about microlens?
07:44:02 <edwardk> libraries like conduit and pipes and machines are rather indispensible once you need to do streaming programming though
07:44:28 <merijn> edwardk: So I have a problem and I'm wondering whether lens can help. Basically, I have a bunch of encoded unicode as binary data that I don't want to/can't copy into Text. But I'd still like to feed it to function that'd expect Text input
07:44:32 <tdammers> you could probably reinvent those wheels every time, but it gets old quick
07:44:49 <merijn> edwardk: Does that sound like something a Traversal/Lens could deal/help with?
07:45:34 <edwardk> mietek: i think it doesn't offer me anything i'd want to use and makes bad trade-offs. prisms make up fully half of what i use lens for. it rules them out. it uses orphans for the classes like Ixed, At, Each that it copies which renders them nearly useless and unable to be built upon.
07:46:15 <byorgey> merijn: what do you mean, don't want to/can't copy into Text?
07:46:40 <mietek> edwardk: well, I wouldn’t expect it to offer you anything :)
07:46:46 <edwardk> :t Data.Text.Strict.Lens.utf8
07:46:47 <lambdabot> (Applicative f, Choice p) => p Data.Text.Internal.Text (f Data.Text.Internal.Text) -> p BSC.ByteString (f BSC.ByteString)
07:46:49 <byorgey> what do you think a lens is going to do other than copy your binary data into Text?
07:46:58 <xplat> merijn: you could do that just with a conversion function that returns lazy Text.  provided your functions consume that.
07:47:10 <edwardk> mietek: my point is more that i think that the trade-offs that it makes are a bad idea -- which is a large reason why i didn't choose to make those trade-offs
07:47:26 <xplat> merijn: if you don't have functions that take lazy Text you might be kind of screwed
07:48:05 <edwardk> merijn: ultimately it has to copy it into a Text somehow. Text is utf16 encoded
07:48:07 <mietek> merijn, geekosaur: take a look at https://gist.github.com/mietek/76da4152b5007c02bdfe (updated)
07:48:10 <merijn> byorgey: I'm forced to maintain the binary data as-is, so copying the entire thing to Text would waste a lot of space and be very inefficient since I'll be repeatedly splitting it into segments
07:48:31 <mietek> merijn, geekosaur: so commands are actually composed with <> in a subparser
07:49:06 <edwardk> merijn: the short version is that you'll have to pay to convert at the boundary if the library you are talking to _must_ consume Text.
07:49:11 <merijn> edwardk: I'm not sure whether using functions that take Text as input is feasible, I'm willing to sacrifice it if I have to
07:49:17 <mietek> merijn: I guess then what I find the most objectionable is the use of helper
07:49:27 <xplat> merijn: you might want to look at the idea of 'semi-indexing'
07:49:52 <xplat> mietek: i guess you're now on the same page as me ;)
07:49:56 <mietek> :)
07:50:11 <merijn> xplat: Looks like that's what I want, but I don't want to implement my own semi-indexing for multiple unicode encodings :\
07:50:57 <merijn> edwardk: Sure, but I want the only convert the data actually consumed and avoid costly pinned allocations (or is it only BS that pins allocations?)
07:51:11 <edwardk> merijn: Text doesn't pin
07:51:19 <merijn> Basically lazy transcoding
07:51:26 <meijiJAPAN> hello people newbie here
07:51:35 <merijn> Or decoding or whatever
07:51:45 <xplat> not enough C libraries consume UTF16 to make it worth pinning Text, eh?
07:52:11 <edwardk> merijn: to lazily transcode you'd need to use something like Lazy Text, but even then you'd have to pay for the chunks from left to right
07:52:55 <xplat> meijiJAPAN: no need to say hello on a channel this big, just ask or lurk as it suits you
07:53:24 <afons> haskell is awesome 
07:54:42 <merijn> To be more concrete I'm trying to basically implement a data structure that works with mmapped textfiles and uses a fragment table to have an efficient editing data structure. I'm just trying to figure out how to effectively expose the data to programmers in a manner that hides the need to know the underlying encoding
07:56:30 <byorgey> afons: =)
07:56:35 <xplat> merijn: i'd make abstract Position and Span types and make it possible to get out a span as Text
07:56:45 <mbrock> merijn: guessing somewhat randomly, could you do something with Pipes.Text.Encoding? the docs has some stuff about lenses and whatnot ;)
07:56:57 <edwardk> xplat pretty much has the same idea as me
07:57:21 <xplat> merijn: and a few functions to move a Position around, look to emacs or vim for inspiration
07:57:23 <edwardk> were i to do it, i'd probably look at maintaining some kind of succinct rank structure over the number of utf8 tailbytes up to a given location in the file
07:57:26 <merijn> xplat: Yeah, the fallback plan is to do that, yeah
07:57:53 <edwardk> and that would make it trivial to slice at arbitrary byte/char boundaries and know how many chars came before a given point
07:58:34 <edwardk> the nice thing is some kind of RRR rank structure for utf8 will typically be vanishingly small
07:58:36 <merijn> edwardk: That's info that could easily be stored in the fragment table, I think
07:58:42 <merijn> RRR?
07:58:43 <edwardk> merijn: that it could
07:59:01 <edwardk> https://en.wikipedia.org/wiki/Succinct_data_structure
07:59:27 <edwardk> https://github.com/ekmett/succinct/blob/master/src/Succinct/Dictionary/RRR.hs
07:59:47 <edwardk> RRR is an implementation of a succinct indexed dictionary
08:00:04 <edwardk> anyways if you only care up to fragment boundaries then you can do something simple and ad hoc like scan as you bring it in
08:00:31 <merijn> edwardk: I'll have a look at that. Now it's dinner time
08:00:46 <edwardk> if you care about being able to slice from arbitrary positions and jump immediately to the ith char and get a slice from the original bytestring? then such an RRR structure would be perfect
08:00:52 <edwardk> no 'fragment table'
08:01:06 <edwardk> just one succinct indexed dictionary tracking the position of the tail bytes (or more directly of the non-tail bytes)
08:01:08 <merijn> edwardk: Ah, but I need the fragment table anyway for edits/insertions :)
08:01:21 <solirc> Lokathor: regarding running tests with cabal vs other options https://github.com/hspec/hspec-example#running-tests
08:01:40 <edwardk> hen you seem to have already picked a structure and can just shove what you want in there ;)
08:01:54 <merijn> Anyhoo, thanks for the tips
08:02:10 <edwardk> you could also finger a rank-select structure, so the approach you describe isn't the only one
08:02:25 <edwardk> but its probably easiest to continue down your current path
08:03:10 <meijiJAPAN> is it possible to use Xcode with haskell somehow?
08:03:30 <minad> Hi! I have some inner functions returning `Except String`, and then some function returning `ExceptT String IO` which calls these inner functions. How can I avoid to write `liftIO` and `mapExceptT (return . runIdentity)` everywhere? Is there some nicer pattern to combine functions which throw exceptions and functions which throw exceptions and also do IO?
08:03:41 <johnw> p
08:03:45 <Freefood> meijiJAPAN: why would anyone want to use Xcode for haskell ? it's one of the worst IDE on the planet ...
08:04:08 <meijiJAPAN> haskell wiki says that i can work with cocoa
08:04:30 <exio4> minad: I would move from "Except String" to "ExceptT String m", keeping the m polymorphic over any monad
08:04:31 <geekosaur> past attempts to hook into both xcode and visual studio have run around on internals changing so often that the plugins can't keep up
08:05:22 <geekosaur> if all you're after is basic integration, I think that can be done but don't know how you'd do it in specific versions (and yes, "specific versions" apply)
08:06:41 <minad> exio4 : thx, sounds good! And this way it is also ensured that the pure functions don't do IO, since the monad is polymorphic?
08:07:14 <mbrock> meijiJAPAN: are you particularly interested in using the Xcode editor for Haskell source code, or are you more asking about integrating Haskell with Mac/Cocoa/Obj-C/iOS/whatever stuff?
08:07:51 <minad> exio4: is this the recommended way to solve this? I mean it seems to me like a pretty standard problem to combine such functions?
08:07:55 * hackagebot esqueleto 2.4.1 - Type-safe EDSL for SQL queries on persistent backends.  https://hackage.haskell.org/package/esqueleto-2.4.1 (FelipeLessa)
08:08:36 <meijiJAPAN> i was wondering if functional programming can be an alternative to oop languages in desktop development
08:11:23 <exio4> minad: yeah, it is ensured that the pure functions won't do any kind of IO, I don't know how common it is in the wild though
08:15:10 <afons>  writeFile "stuff2.txt" (show [1..])
08:15:16 <afons> wrote 300gb in less than 3 minutes
08:15:42 <monochrom> that is a cool way to fill up the disk
08:16:04 <afons> good way to prank friend
08:16:55 <bennofs> that's a few GB/s write speed? didn't know disks are that fast
08:17:19 <afons> yup
08:17:28 <afons> mine is a 5000 ssd
08:17:38 <afons> ops
08:17:38 <afons> 500gb*
08:18:03 <afons> and since haskell is lazy, writeFile writes in a constant speed
08:18:07 <afons> without allocating too much memory
08:22:56 * hackagebot ewe 0.1.0.46 - A language for teaching simple programming languages  https://hackage.haskell.org/package/ewe-0.1.0.46 (JuanFranciscoCardonaMcCormick)
08:31:41 <thejohnfreeman> looking for some input on how to improve this snippet: http://lpaste.net/138506
08:33:59 <aweinstock> minad: (f :: Monad m => ExceptT String m) can't do IO, (g :: (Monad m, MonadIO m) => ExceptT String m) can do IO (via liftIO)
08:35:30 <quicksilver> that's quite a good question, thejohnfreeman 
08:35:47 <exio4> thejohnfreeman: you could use pattern guards there
08:36:15 <exio4> but it wouldn't be that much better, actually
08:36:29 <quicksilver> you could shove MaybeT into your monad stack and write something like :
08:37:37 <quicksilver> line <- lift await `onNothing` yield (Group header (reverse lines)) ; match <- lift (ICU.find headerRegex line) `onNothing` toGroups header (line:lines)
08:37:47 <quicksilver> `onNothing` isn't a real thing, I just made it up.
08:38:03 <quicksilver> but you could define an onNothing which worked like that. and you could tweak it to avoid the lifts.
08:38:13 <quicksilver> that would stop the indentation creep but would make it fairly dense
08:38:32 * quicksilver wonders if anyone has a better idea :)
08:43:03 <quicksilver> onNothing is just mplus and fail.
08:48:37 <xplat> thejohnfreeman: try splitting it into separate conduits.  one to turn the stream into Either Header Line by matching the regex, and one to collect groups of the form Left,Right,Right,Right...
08:51:58 <mbrock> thejohnfreeman: agree with xplat; also, maybe the grouping task fits the concatMapAccumM combinator, with (header, lines) as the accumulator
08:52:26 <thejohnfreeman> thanks for the suggestions, I've got some reading to do then
08:52:27 <mbrock> thejohnfreeman: eh, just concatMapAccum even
08:52:29 <afons> Is [] () same as [()]?
08:52:32 <afons> as a type
08:53:05 <xplat> afons: yes
08:54:32 <afons> If mapM_ has that type ending with m (), why does applying it to a list return () ?? that's not from type [()] is it
08:55:31 <xplat> > mapM_ [1] [1..5]
08:55:33 <lambdabot>      Couldn't match expected type ‘Integer -> m b0’
08:55:33 <lambdabot>                  with actual type ‘[Integer]’
08:55:33 <lambdabot>      In the first argument of ‘mapM_’, namely ‘[1]’
08:55:49 <xplat> > mapM_ (const [1]) [1..5]
08:55:50 <afons> > mapM_ (putStrLn . show) [1..10]
08:55:50 <lambdabot>  [()]
08:55:51 <lambdabot>  <IO ()>
08:56:10 <magicman> > return () :: [()]
08:56:12 <lambdabot>  [()]
08:56:33 <afons> > [()] >>= print
08:56:34 <lambdabot>      Couldn't match type ‘IO’ with ‘[]’
08:56:34 <lambdabot>      Expected type: () -> [()]
08:56:34 <lambdabot>        Actual type: () -> IO ()
08:56:49 <afons> > [()] >>= (putStrLn . show)
08:56:50 <lambdabot>      Couldn't match type ‘IO ()’ with ‘[b]’
08:56:50 <lambdabot>      Expected type: String -> [b]
08:56:50 <lambdabot>        Actual type: String -> IO ()
08:56:53 <afons> a fck
08:57:14 <afons> dont understand
08:57:17 <afons> someone explain ?
08:57:30 <geekosaur> m is [] vs. m is IO
08:57:37 <geekosaur> IOP is not the only monad
08:57:41 <geekosaur> IO is not the only monad
08:57:44 <xplat> afons: oh, if you're using 'mapM_ (putStrLn . show) [1..10]' it'll look like it returns () in GHCi but it really returns an IO action
08:57:45 <afons> when I do mapM_ (putStrLn . show) [1..10], the result is () instead of [()] why?
08:58:10 <afons> xplat how can I see the real value
08:58:27 <afons> oh ok the monad here is the IO
08:58:30 <geekosaur> the result is actually IO (), but ghci sees that and runs the IO action
08:58:30 <mbrock> afons: in that example, m () is not applied with "m = []", it's applied with "m = IO"
08:58:45 <afons> how can I see the value like in lambdabot
08:58:54 <afons> > putStr 3
08:58:56 <lambdabot>      No instance for (Num String) arising from the literal ‘3’
08:58:56 <lambdabot>      In the first argument of ‘putStr’, namely ‘3’
08:58:56 <lambdabot>      In the expression: putStr 3
08:58:59 <afons> > putStr "3"
08:59:01 <lambdabot>  <IO ()>
08:59:16 <afons> how can I get <IO ()> in ghci
08:59:17 <geekosaur> lambdabot doesn't run IO actions, so it has a fake IO that does that
08:59:19 <afons> instead of the actual value
08:59:43 <xplat> afons: you could try doing 'return $ mapM_ (putStrLn . show) [1..10]'
09:00:29 <xplat> afons: that wraps it in an extra IO action, which ghci can then strip off
09:00:38 <geekosaur> I don't know offhand if there is a way to do that in ghci, but suspect it would be rather limiting since you wouldn't be able to tell it that sometimes you actually want to run IO actions. (this isn't a problem for lambdabot because the thing "printing" to IRC is not the same as the thing computing that value. in ghc, they are the same thing)
09:00:43 <geekosaur> *in ghci
09:01:31 <xplat> or you could try putting it inside another data structure
09:01:51 <xplat> > [mapM_ (putStrLn . show) [1..10]]
09:01:52 <lambdabot>  [<IO ()>]
09:02:24 <dmj`> @print print
09:02:25 <lambdabot> Not enough privileges
09:02:27 <dmj`> @src print
09:02:27 <lambdabot> print x = putStrLn (show x)
09:02:35 <xplat> by hiding the result in a list, you can see what it actually returned
09:03:01 <geekosaur> oh, you could also use :t
09:03:10 <geekosaur> which won't show a value but will show the type
09:03:12 <xplat> ah, that works too
09:03:21 <xplat> :t mapM_ (putStrLn . show) [1..10]
09:03:22 <lambdabot> IO ()
09:03:45 <xplat> also works in ghci and useful to know in general
09:10:06 <mbrock> yeah, when I write expressions in ghci I usually always just typecheck it with :t and mess with it until I piece together something with the right type
09:10:20 <mbrock> typed holes are also very, very useful!
09:10:59 <mbrock> :t mapM_ putStrLn _
09:11:00 <lambdabot>     Found hole ‘_’ with type: t0 String
09:11:00 <lambdabot>     Where: ‘t0’ is an ambiguous type variable
09:11:00 <lambdabot>     In the second argument of ‘mapM_’, namely ‘_’
09:11:01 <quicksilver> xplat: mbrock : you have both understood thejohnfreeman's code and actually suggested alternative ways - probably good thinks. But I'm still interested in 'how to unpick these nested case statements' in the general case without understanding the exact problem in hand
09:13:04 <mietek> Does anyone have a good example of processing a large lazy list while also keeping a bit of state on the side?
09:13:55 <mietek> The list being provided by Text.XML.Expat.SAX.parse (https://hackage.haskell.org/package/hexpat-0.20.9/docs/Text-XML-Expat-SAX.html)
09:14:04 <exio4> quicksilver: the problem is that most of the time, there are different patterns based on the problem in hand, maybe using MaybeT, maybe using the monad interface, maybe whatever 
09:14:22 <quicksilver> mietek: the very simplest approach is just a recursive function
09:14:34 <quicksilver> whicih "stores" state in one parameter (and recurses down the list in the other parameter)
09:14:49 <ReinH> I mean, that's foldr.
09:14:57 <quicksilver> it is as ReinH says.
09:15:01 <mietek> I spaceleaked massively with "statefulStream fun = snd . foldr fun (0, []) . parse"
09:15:06 <exio4> or a foldl', depending on what you are doing 
09:15:07 <ReinH> or foldl
09:15:12 <mietek> Where the integer is the bit of state
09:15:29 <mietek> Stateless processing with "stream fun = concatMap fun . parse" does not leak
09:15:34 <quicksilver> mietek: that's not inherently spaceleaky. You probably just needed to force something.
09:15:37 <xplat> or a MapAccumL
09:15:47 <mietek> xplat: I would be expecting a R
09:15:54 <mietek> quicksilver: probably...
09:16:01 <xplat> er, yeah, probably R
09:16:26 <ReinH> mietek: what is parse?
09:16:27 <exio4> quicksilver: more like he's being too strict, probably
09:16:34 <quicksilver> or that
09:16:45 <xplat> :t mapAccumR
09:16:46 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
09:16:51 <mietek> Code: https://gist.github.com/mietek/9571b4b9920e0f1d1be2
09:17:17 <mietek> Working fine modulo space leak
09:17:39 <mietek> I’m not sure if foldr is the right pattern to use, though.
09:17:47 <mietek> I mean — what I want is to keep emitting output
09:17:48 <ReinH> mietek: well, what's fun?
09:18:21 <mietek> ReinH: the two functions just below statefulStream
09:18:22 <ReinH> if you want it to be productive, you need foldr, but the way you have it isn't productive
09:18:31 <mietek> Right
09:19:05 <mietek> I think the snd is ruining it
09:19:19 <mietek> But I’m not sure how else to keep state in a foldr
09:21:57 <mietek> Wrap the input with another coinductive function...?
09:23:01 <xplat> mietek: i think you should use mapM_ here maybe
09:23:23 <mad_scientist> hi 
09:23:33 <mad_scientist> I am new here 
09:23:37 <mad_scientist> ._.
09:23:42 <quicksilver> hi mad_scientist 
09:23:58 <mietek> xplat: with what being the monad?
09:24:00 <bakibour> Can anyone point me to a good script on functional datastructures?
09:24:01 <mad_scientist> what is this channel about?
09:24:10 <quicksilver> the programming language haskell.
09:24:10 <ReinH> @where okasaki
09:24:11 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
09:24:14 <ReinH> bakibour: ^
09:24:16 <quicksilver> There are some links in the topic.
09:24:38 <xplat> mietek: could be IO
09:24:43 <mad_scientist> I never knew about haskell until now
09:24:54 <mad_scientist> I am right now learning C
09:24:54 <mietek> ReinH: do you have any suggestions for making the foldr productive?
09:25:02 <xplat> mietek: or a conduit/pipe/whatever
09:26:39 <ReinH> mietek: I might try using pipes
09:26:54 <mad_scientist> I've never seen/heard of haskell before.. why is that? Is this langugae for a specific purpose?
09:27:00 <mietek> This should be doable without megabytes of libraries.
09:27:39 <xplat> mietek: you could also use parsec on your list of SAX events, that would save you from writing a whole state machine by hand
09:27:54 <kadoban> mad_scientist: Nope, it's a general purpose language. It's pretty neat.
09:27:57 <zomg> mad_scientist: out of curiosity how/why did you join here if you didn't know what this channel was about? Always wondering how people randomly end up in channels... :)
09:28:18 <mietek> xplat: good idea, but first, it needs to work in constant space
09:28:22 <xplat> but maybe you're just as well off here
09:28:55 <mad_scientist> I see, so does it have any particular advantage over C? 
09:29:04 <xplat> mietek: i don't think a foldr is an appropriate way for it to work in constant space
09:29:17 <mad_scientist> well I just googled 'cool irc channels' 
09:29:22 <mad_scientist> haskell came on top 
09:29:42 <mietek> xplat: yes. This needs to keep emitting results.
09:29:52 <zomg> mad_scientist: haha, interesting :) that would indeed appear to be the case strangely enough
09:30:13 <xplat> mietek: the easiest way would be 'concat . mapAccumR'
09:30:28 <mad_scientist> so I am extremely new to IRC thing, like I knew it existed, I tried it out once and that's it. 
09:30:44 <kadoban> mad_scientist: It has many advantages over C, if you're using it for general application programming. In really embedded cases or other niches, C wins. Otherwise the abstractions and type safety of haskell will save you a bunch of time and bugs.
09:31:10 <mad_scientist> I picked it up again as it was mentioned on lots of free SSH servers 
09:31:10 <mietek> @type mapAccumR
09:31:11 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
09:31:15 <zomg> I think I've been on irc some 15 years give or take...
09:31:16 <zomg> :P
09:31:28 <mad_scientist> I will check this language out 
09:31:29 <mietek> xplat: still think having to do snd on the result will ruin it
09:31:57 <kadoban> mad_scientist: C is a pretty poor idea for application programming, in general. It's partially/mostly to blame for a /bunch/ of common errors and exploits in common code.
09:32:08 <zomg> But yeah Haskell is quite different from most other languages so certainly an interesting learning experience if nothing else
09:32:17 <kadoban> mad_scientist: Cool, hope you like it. https://github.com/bitemyapp/learnhaskell is a good recommendation for learning.
09:32:44 <levi> mad_scientist: Haskell is quite unlike C. I'm a C programmer by trade, and I enjoy Haskell, so I hope you have a good time learning it!
09:32:47 <monochrom> be sure to learn Haskell as a clean slate, not as a translation from popular languages
09:33:19 <zomg> ^ this is good advice, seen a number of people try to translate code line by line from some language to haskell which usually doesn't work :)
09:33:27 <mad_scientist> I'll try it out 
09:33:46 <mad_scientist> is there a thing that can be done exclusively in this language?
09:33:47 <monochrom> "all languages are the same except for notation" completely breaks down
09:34:01 <xplat> mietek: try it before you knock it
09:34:54 <monochrom> boolean absolute "exclusive"? relative "exclusive"
09:35:07 <Hijiri> mad_scientist: there's a lot of errors you can check for at compile time that you couldn't in C
09:35:09 <levi> mad_scientist: I don't know of any language that can do a particular thing exclusively, at least if you mean the behavior or calculation of the program.
09:35:21 <mad_scientist> boolean absolute
09:35:29 <dolio> mietek: If you want things to be productive, your functions need to not be strict in the tuples that represent the state.
09:35:58 <mietek> dolio: so uh... should that be a lazy pattern match?
09:36:06 <dolio> Right now your code looks like it will error out if there is ever an error in the entire stream, which can't possibly be productive.
09:36:11 <monochrom> then I guess what Hijiri says.
09:36:40 <mad_scientist> what do youu mean "multiple errors can be checked whilst compiling"? Doesn't this depend on the compiler? 
09:36:45 <mietek> dolio: well, I was expecting it to error out at the first element it encounters
09:36:54 <dolio> mietek: Yes, I'd try that. And then it will error out somewhere in the stream.
09:37:05 <monochrom> compilers still have to conform to the language specification
09:37:09 <mietek> That’s fine; I’m not actually expecting any errors
09:37:15 <xplat> > mapAccumR (\(a,b) -> (a * b, b + 1)) 0 (2:3:5:7:11:undefined)
09:37:16 <lambdabot>      Couldn't match expected type ‘Integer -> ((t, t), c)’
09:37:16 <lambdabot>                  with actual type ‘(t, t)’
09:37:16 <lambdabot>      Relevant bindings include
09:37:24 <monochrom> if the language specification says "disallow XXX" then all compilers look for "XXX" and reject.
09:37:39 <dolio> Just slap a ~ on the second argument of those stream processing functions and see what happens. You can probably get rid of the error cases, too.
09:38:54 <xplat> > snd $ mapAccumR (\a b -> (a * b, b + 1)) 0 (2:3:5:7:11:undefined)
09:38:56 <lambdabot>  [3,4,6,8,12*Exception: Prelude.undefined
09:39:22 <xplat> mietek: see?  lazy.
09:39:55 <levi> mad_scientist: C explicitly defines a bunch of things, "undefined behavior", that are generally errors but which compilers don't have to check for. But in most other programming languages that follow a specification, compilers are generally required to find and report things or at least generate code that will detect errors at runtime.
09:41:06 <levi> One of the ideas behind Haskell is to allow the programmer to shift more of the error detection to compile-time, requiring the compiler to make fewer of the run-time checks for consistency.
09:41:39 <mbrock> mietek: btw, if you recurse manually you can just recurse to a different function instead of switching state, which I think would probably make the code clearer anyway
09:41:51 <mietek> mbrock: indeed
09:41:52 <xplat> > concat . snd $ mapAccumR (\a b -> (not a, if a then [b] else [])) False (2:3:5:7:11:undefined)
09:41:53 <lambdabot>  *Exception: Prelude.undefined
09:42:39 <mietek> dolio: "irrefutable pattern failed", hm
09:42:39 <xplat> > snd $ mapAccumR (\a b -> (not a, if a then [b] else [])) False (2:3:5:7:11:undefined)
09:42:40 <lambdabot>  [*Exception: Prelude.undefined
09:42:50 <levi> There are still large classes of program errors that the compiler won't have enough information or reasoning capacity to detect, but the ones that it does find lead to a significantly different experience in the programming vs. debugging phases in Haskell vs. C.
09:43:00 <xplat> ok, that's weird
09:43:19 <xplat> > snd $ mapAccumL (\a b -> (not a, if a then [b] else [])) False (2:3:5:7:11:undefined)
09:43:19 <mad_scientist> I see
09:43:20 <lambdabot>  [[],[3],[],[7],[]*Exception: Prelude.undefined
09:43:22 <Gurkenglas> Why's it called mapAccumR when the accumulator is the first argument of the first argument?
09:43:35 <xplat> ah, i was right in the first place.  mapAccumL.
09:43:57 <xplat> > concat . snd $ mapAccumL (\a b -> (not a, if a then [b] else [])) False [1..]
09:43:59 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
09:44:21 <xplat> mietek: you should be able to see from the above how to do your thing
09:45:09 <mietek> xplat: hm
09:46:15 <dolio> mietek: The thing I was concerned with was your matches on numerals. But you don't appear to have any choices going on based on those.
09:46:41 <exio4> I would be using an algebraic datatype for representing the possible choices
09:46:51 <dolio> Unless I'm missing something.
09:48:10 <dolio> mietek: Although to be honest, those seem bad, too. I think once you demand the first element of result, it will demand all the state tracking.
09:48:38 <dolio> So it would be better to not match on them that way, and only match in the state half of the code.
09:49:03 <xplat> dolio: yeah, that's why i said 'use mapAccumL instead of foldr', because foldr will have to resolve all the state tracking immediately
09:49:05 <dolio> But that is probably going to 'leak' if you want to find errors.
09:50:02 <dolio> Yeah, mapAccumL is probably better. You really want to thread the state down, not up from the bottom.
09:50:34 <dolio> That might be the source of the error, too.
09:51:05 <dolio> Unless I don't understand how things are going to work, and all the 'StartElement' things are going to be at the _end_ of the list.
09:51:28 <mietek> No, this is a well-formed XML file
09:51:39 <mietek> Error detection is not important
09:51:56 <mietek> The only important thing is being able to cope with a GB-sized file in constant memory
09:52:11 <mietek> mapAccumL looks interesting, but I think explicit recursion may indeed be clearer
09:52:19 <mietek> Attempt in progress
09:52:39 <xplat> @src mapAccumL
09:52:39 <lambdabot> mapAccumL _ s []     = (s, [])
09:52:39 <lambdabot> mapAccumL f s (x:xs) = (s'',y:ys)
09:52:39 <lambdabot>    where (s', y ) = f s x
09:52:39 <lambdabot>          (s'',ys) = mapAccumL f s' xs
09:53:01 <nschoe> Hi, I have a small question. I'm developing a library right now, and I set -Wall and -Werror flags. Problem is that I defined "defaultInitiStrategy = MyDefaultStrat" but then the compilation fails with "Defined but not used" warning (which is turned into an error by -Werror)
09:53:22 <nschoe> Does that mean that 1) I should not use -Werror, 2) there's a better way of doing things?
09:54:02 <nschoe> I thought about making my InitStrategy type an instance of Default. But I have several types for which I will provide defualt value, and the code might end up begin: "myfunc def def def def"
09:54:19 <dolio> mietek: Well, consider that the only thing you have that accepts a 0 state is StartElement "osbg:RoadNode", but foldr passes (0, []) as the base case. So the last element of the list must be a StartElement for it not to error.
09:54:49 <S11001001> nschoe: did you mean to include it in your export list?
09:55:08 <nschoe> S11001001, you mean my defaultInitStrategy ?
09:55:11 <mietek> dolio: what about "roadLinkPolyline _ context = context"?
09:55:15 <S11001001> nschoe: yes
09:55:22 <mietek> dolio: and same for roadNodePoint
09:55:25 <xplat> dolio: there are lots of things that accept an arbitrary state, including when the event isn't any of the ones explicitly listed
09:55:27 <nschoe> S11001001, Yes I want to export it. oOps I did not export it indeed.
09:55:58 <dolio> mietek: Yeah, okay, but then you've just moved it so that the last thing in the list that you recognize must be a StartElement.
09:56:09 <nschoe> S11001001, thx! Problem solved !
09:56:12 <afons> Is possible to use NoBuffering for the stdin and getLine and putStr and see the result print one char by char? I tried this but it's still line buffering
09:56:17 <afons> main :: IO ()
09:56:17 <afons> main = do
09:56:17 <afons>     hSetBuffering stdin (BlockBuffering (Just 1))
09:56:17 <afons>     d <- getLine
09:56:17 <afons>     putStr d
09:56:21 <xplat> but the basic point is true, the code as pasted will only parse a file correctly if you reverse the SAX parser output first
09:56:31 <afons> ops
09:56:40 <mietek> Ah, I got the order wrong
09:56:41 <afons> module Main where
09:56:41 <afons> import System.IO
09:56:41 <afons> main :: IO ()
09:56:41 <afons> main = do
09:56:41 <afons>     hSetBuffering stdin NoBuffering
09:56:41 <afons>     d <- getLine
09:56:43 <afons>     putStr d
09:56:46 <mietek> Thanks.
09:56:47 <nschoe> By the way, is providing several 'defaultXXX' considered "bad" as opposed to making the types an instance of the Default typeclass?
09:56:51 <Gurkenglas> http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.OldList.html#transpose <- Why aren't the second and third line combined into "transpose xss = [h | (h:_) <- xss] : transpose [ t | (_:t) <- xss]"?
09:56:54 <mietek> @hpaste
09:56:54 <lambdabot> Haskell pastebin: http://lpaste.net/
09:56:57 <mietek> afons: ^^
09:57:02 <dolio> mietek: Anyhow, the point is, the state is being threaded backwards, and you want to thread it the direction that mapAccumL does.
09:57:14 <mietek> dolio, xplat: thank you
09:57:15 <xplat> afons: the terminal can buffer lines even if your program doesn't
09:57:27 <afons> So how do I test it for NoBuffering?
09:57:28 <afons> http://lpaste.net/138521
09:57:58 <xplat> afons: you have to use something along the lines of stty to turn off console line buffering
09:58:53 <afons> xplat: if I try to read a file using nobuffering, can I compare it to blockbuffering and notice any difference in performance?
10:00:09 <xplat> afons: also, if you use getLine you will always get line buffering, because getLine will get a whole line before anything else is executed
10:00:42 <xplat> afons: you'd have to use some form of lazy IO such as 'getContents'
10:01:04 <xplat> afons: or else use getChar one at a time by hand
10:02:04 <Gurkenglas> (Or even "transpose xss = unzip [(h, t) | (h:t) <- xss]")
10:03:21 <Gurkenglas> Wait, nevermind that last one, dropped a word.
10:04:33 <afons> xplat: I used getContents, it still doesn't show char by char
10:05:10 <afons> I am only doing this to learn, so I don't want any "workarounds"
10:05:15 <afons> I want this to work
10:06:37 <geekosaur> if the terminal is in line mode then it will work by line regardless of what the program does
10:07:34 <afons> If I do this on a file, will I see a difference in performance between NoBuffering and LineBuffering?
10:09:29 <geekosaur> with enough data, yes. not much difference if you output only a few characters but as soon as you exceed a couple Kbytes it will become evident. this is why C uses stdio (includes buffering) and Java generally has you add in buffering classes
10:10:09 <geekosaur> also things that are not terminals default to block, not line, buffering
10:10:32 <afons> What is the default buffering for files in haskell?
10:10:38 <afons> Is it blockbuffering 4096?
10:11:34 <Gurkenglas> What should I use when I want some "(a -> Bool) -> a -> Maybe a"? I find myself needing that way too often.
10:14:52 <afons> stuff f = find (:[])
10:15:01 <afons> stuff f = find f . (:[])
10:15:52 <afons> stuff :: (a -> Bool) -> a -> Maybe a
10:16:07 <darenthis> is it possible to replace a case statement with guards when pattern-matching on a tuple?
10:16:24 <darenthis> f s = case s of
10:16:24 <darenthis>   (_, 0) -> False
10:16:24 <darenthis>   otherwise -> True
10:16:57 <mauris> f (_, 0) = False; f _ = True
10:18:15 <Gurkenglas> :t (/= 0) . smd
10:18:17 <lambdabot>     Not in scope: ‘smd’
10:18:17 <lambdabot>     Perhaps you meant ‘snd’ (imported from Data.Tuple)
10:18:19 <Gurkenglas> :t (/= 0) . snd
10:18:20 <lambdabot> (Eq b, Num b) => (a, b) -> Bool
10:18:45 <mauris> generally you only need guards when you want to *add* some condition to a pattern
10:19:03 <aweinstock> :t find
10:19:03 <lambdabot> Foldable t => (a -> Bool) -> t a -> Maybe a
10:19:07 <mauris> like  f (x, 0) | even x = False
10:20:07 <mauris> > find even (Just 4)
10:20:09 <lambdabot>  Just 4
10:20:10 <mauris> > find even (Just 3)
10:20:12 <lambdabot>  Nothing
10:20:40 <darenthis> mauris: ah, thanks. Don't know why I thought I needed a case statement there
10:22:19 <dolio> You can do it with guards, though.
10:22:35 <dolio> f s | (_, 0) <- s = False | otherwise = True
10:23:03 <dolio> For reference.
10:24:17 <darenthis> dolio: thanks. That makes sense :)
10:26:05 <darenthis> linguistic follow-up: what words should I use for '->' and '<-' arrows? I usually try and translate expressions to english phrases but I'm stumped by the arrows
10:26:33 <afons> binding arrow
10:26:45 <afons> arrow bind
10:27:30 <dzdcnfzd> I have a data record with a bunch of different inputs to its constructor, and streaming input which defines the inputs to to constructor one by one, in an unpredictable order. Is there a common pattern for building up the entire data record, one datum at a time?
10:28:08 <dzdcnfzd> I can't do a map because the types are different
10:28:21 <dzdcnfzd> I'm trying not to use language extensions
10:28:25 <darenthis> 'f of s when (_,0) binds to s equals False, otherwise True'. I can work with that :)
10:29:20 <subleq> Is Shake meant to build haskell projects instead of cabal?
10:30:40 <afons> I/O doesn't just change the state of a program. We can think of I/O as changing the state of the world..
10:30:47 <afons> I/O can trigger a bomb on the other side of the planet.
10:32:03 <aweinstock> darenthis: the -> in "\x -> x+1" can be read as "maps to"
10:32:04 <Rembane> Side-effect: Launch missiles!
10:35:58 <xplat> merijn: also, if the functions you have that take strict Text are good consumers you may be able to make them fuse with decoders that decode into Text to avoid an actual Text copy depending what stuff is getting inlined
10:35:58 <darenthis> aweinstock: thanks. I find it helps to be able to mentally verbalise expressions
10:38:36 <xplat> :t when
10:38:37 <lambdabot> Applicative f => Bool -> f () -> f ()
10:41:42 <arkeet> why not Bool -> f a -> f (Maybe a)
10:42:40 <arkeet> hm, is it just me or are we missing an Applicative version of replicateM?
10:43:02 * hackagebot gitrev 1.1.0 - Compile git revision info into Haskell projects  https://hackage.haskell.org/package/gitrev-1.1.0 (AdamFoltzer)
10:44:04 <_matix> hello earthlings
10:44:25 <kclancy> Is there a way to view the types of arbitrary expressions in a haskell program? Apparently ghc-mod can do this, but I think it's out of date. EclipseFP does not seem to be compatible with the project I'm working on.
10:45:13 <kclancy> Right now I'm using haskell mode, but I can only view the types of top-level  identifiers and ones from other modules.
10:45:14 <arkeet> kclancy: types don't exist at runtime.
10:45:21 <arkeet> or.
10:45:25 <arkeet> well I guess I misunderstood.
10:45:42 <takanuva> I've got a conceptual question, if anyone can help me... is there any relation about the iteratee pattern and coroutines in an imperative language? I mean, I started reading about iteratees/enumeratees yesterday, and sounds like the way I'd implement a coroutine in C
10:46:26 <kclancy> arkeet: yeah, haskell mode seems to get all its types from runtime information. But the whole point of types is that they can be computed statically.
10:46:29 <arkeet> kclancy: ghc-mod is still maintained.
10:47:00 <arkeet> I'm not sure exactly what the state of things is, though.
10:47:02 <kadoban> arkeet: Kinda … except it still hasn't been released for 7.10?
10:47:26 <arkeet> the github repo is still active.
10:47:47 <kclancy> Maybe Haskell adds new experimental features too fast for IDE developers to keep up with.
10:48:53 <kadoban> kclancy: Well, there's other tools of the same sort that have handled 7.10 for quite a while. More likely the dev has just been busy.
10:49:20 <kclancy> kadoban: Do you have any recommendations?
10:49:50 <kadoban> kclancy: I use hdevtools. I don't really … care much about it though, so I'm not sure how it compares. I use it only rarely.
10:50:16 <bitemyapp> I use Haskell interactive mode and hlint w/ flycheck.
10:50:19 <bitemyapp> that's it tho
10:50:47 <aweinstock> takanuva: I believe so (that iteratee/enumeratee/conduit/pipes are similar to coroutines)
10:50:52 <kclancy> Haskell interactive mode doesn't allow one to query  local variable types, does it? 
10:51:38 <monochrom> currently nothing exposes local binding types
10:51:59 <kadoban> Doesn't hdevtools have the ability to query them, or are we talking about something else?
10:52:21 <takanuva> aweinstock: I need to write a piping/streaming library in C to perform some translations, and I need to write it a little bit more "functionally" (immutable states and so on); do you think that using the iteratee pattern would be a good idea?
10:54:16 <aweinstock> takanuva: could you give a bit more detail on what the system is/does?
10:54:20 <chreekat> kclancy: use type holes or `asTypeOf`
10:54:42 <kclancy> chreekat: thanks, I'll try that
10:55:01 <chreekat> the former is something i haven't used myself yet, since it's a 7.10 feature
10:55:50 <chreekat> but "... `asTypeOf` _" gives you an error that can show useful type info
10:56:13 <geekosaur> um? type holes were in 7.8, weren't they? (still doesn't help on debian/ubuntu...)
10:57:04 <takanuva> aweinstock: I'm building an incremental compiler, so I have to get the internal state for each character... I was thinking about using coroutines to build this, so one for the preprocessor, one for the compiler, and so on... so I'll build a pipe between them; sounds like the iteratee pattern would be useful here, I'm just not sure if I understood it correctly yet =/
10:57:12 <mietek> @pl f g x = g x
10:57:12 <lambdabot> f = id
10:58:06 <aweinstock> takanuva: is there a specific reason it needs to be in C?
11:00:17 <lingxiao> hey all
11:00:18 <takanuva> aweinstock: portability, mostly... it's a research project, I'm trying to keep it easy to bootstrap; otherwise I'd probably implement it functionally in F#
11:00:47 <lingxiao>  I have a .exe file that outputs some random data in CSV format
11:00:57 <lingxiao> and I'd like to run this file in ghci
11:01:00 <lingxiao> just to play with it
11:01:10 <lingxiao> but I am not sure what functions to use to run it
11:02:19 <clahey> I have some questions about interactions between State and Lens. Is this the right channel for that?
11:02:39 <edwardk> here works, #haskell-lens also works, just ask, folks will answer ;)
11:02:45 <clahey> Hi Ed!
11:04:07 <clahey> So, is there a function :: Lens' s a -> State s a -> State s ()?
11:04:39 <clahey> I think (.=) :: Lens' s a -> s -> State s (), right?
11:05:30 <clahey> I just looked and it's MonadState s m => ASetter s s a b -> b -> m ()
11:05:49 <clahey> So I want MonadState s m => ASetter s s a b -> m b -> m ()
11:06:35 <clahey> I realize this is easy to write, but I was curious if it already existed.
11:06:54 <Gurkenglas> edwardk, should all the functions that take a Cofree f a be changed to take a ComonadCofree f w -> w a?
11:07:33 <edwardk> :t (<~)
11:07:34 <lambdabot> MonadState s m => ASetter s s a b -> m b -> m ()
11:07:52 <clahey> Beautiful
11:08:13 <edwardk> Gurkenglas: good question
11:08:27 <aweinstock> takanuva: I'd think that the most idiomatic C/Unix way to do it would be to write the components as seperate programs, and use Unix pipes to communicate (which would end up looking similar-in-structure to a solution with iteratees/enumeratees/conduit/pipes)
11:08:48 <Gurkenglas> -"->"+"=>"
11:08:54 <chreekat> geekosaur: oh, you may be right about typed holes
11:09:20 <edwardk> Gurkenglas: examples of combinators that would be affected?
11:09:22 <aweinstock> takanuva: (e.g. have the preprocessor take the input on stdin, output processed source to the lexer, which outputs tokens on stdout, etc)
11:09:45 <edwardk> hoistCofree :: Functor f => (forall x . f x -> g x) -> Cofree f a -> Cofree g a is one of the few that i can see that would be affected
11:09:53 <edwardk> and having that change types would be weird
11:12:12 <aweinstock> edwardk: what's Cofree? (I'm kind of familiar with the notion of Free (adding the minimal amount of structure to one math object to produce another satisfying some properties)
11:13:12 <takanuva> aweinstock: yeah, I'm doing that too, but one of the features I'd like to implement is being able to "join components together" on the same application; that's why I'm thinking about the iteratee approach :) also, inside each of them there will still be the need of coroutines, e.g. for decoding codepages (win1252, utf16, etc), and so on, so I still need some way to implement this, and keep track of the internal state byte per byte
11:13:21 <edwardk> aweinstock: there is a formal definition of a 'free' structure in category theory. which is based on the notion of a 'forgetful' functor. if you have a forgetful functor it loses information. e.g. a forgetful functor from the category of monads to the category of functors would just forget your functor was a monad.
11:13:22 <roboguy_> aweinstock: Free more specifically relates to free monads
11:13:32 <takanuva> aweinstock: do you think an iteratee would be a good solution?
11:13:42 <shachaf> The definition is formal until you get to the point of saying "forgetful functor". :-)
11:13:51 <Gurkenglas> Weird, I remember thinking a week or so back that there were some. I probably did mean hoistCofree. 
11:14:11 <edwardk> shachaf there is a formal way to think of 'forgetful functor' but its kinda meh
11:14:43 <shachaf> edwardk: Is it that "stuff and structure" thing?
11:15:32 <edwardk> or we might have a forgetful functor from a category of monoids to the category of sets where we just forget the monoidal structure and only remember the underlying carrier set of our monoid. anyways a 'free' functor is a functor that is the left adjoint to a forgetful functor.
11:15:44 <edwardk> a 'cofree' functor is a functor that is right adjoint to a forgetful functor.
11:15:54 <aweinstock> takanuva: I'm not sure I understand enough to say (I'm not entirely sure what you're calling the "iteratee pattern")
11:16:29 <edwardk> so now lets go back to free monads, if we have a forgetful functor that takes us from the category of monads with monad homomorphisms between them as arrows to the category of functors, with natural transformations between them it just drops the Monadness on the floor, leaving only the fact that our monad was a functor
11:17:11 <aweinstock> edwardk: I was able to follow most of that until {left,right} adjoints. What are adjoints?
11:18:09 <takanuva> aweinstock: ok; sorry, I gotta go, sometime else I'll be back here to try again... thanks for your help! bye bye :)
11:18:22 <edwardk> F -| G, which is read "F is left adjoint to G", means forall objects A and B in the appropriate categories the arrows from F A -> B   are isomorphic to the arrows from A -> G B
11:19:26 <afons> What is better - vim, oh-my-zshell or emacs
11:19:47 <edwardk> if we could have Functor instances that applied on 'the wrong side' e.g. (, e) a = (a, e) then (, e) -| (->) e holds because,   (a, e) -> b   is isomorphic to a -> (e -> b)  -- witnessed by currying and uncurrying being inverses.
11:20:06 <roboguy_> afons: that's one of the big debates that no one will agree on (except I think oh-my-zshell is something else entirely, but I'm not sure)
11:21:37 <edwardk> so lets build a couple of categories, we can build a 'category of functors on Hask' where my objects are instances of Functor. and my arrows are natural transformations. type f ~> g = forall a. f a -> g a
11:21:54 <roboguy_> afons: so, I suggest trying both and seeing which you like better.
11:22:27 <edwardk> and we can build a 'category of monads on Hask' where my objects are monads, and my arrows are monad homomophisms: natural transformations that 'respect' join and return.
11:23:04 * hackagebot ipython-kernel 0.6.1.2 - A library for creating kernels for IPython frontends  https://hackage.haskell.org/package/ipython-kernel-0.6.1.2 (gibiansky)
11:23:05 <edwardk> then we can build a forgetful functor U from our category of monads to our category of functors.  it just forgets the monadness of our monads, and every monad homomorphism is already a natural transformation, so we just forget the fact that it respects join and return. it still would, but we don't care any more
11:23:16 <afons> roboguy_ can you just clarify some concepts to me?
11:23:33 <roboguy_> afons: maybe. Like what?
11:23:59 <Gurkenglas> How should instance definitions be sorted?
11:24:19 <afons> roboguy_ ok let's start: what is a shell? Am I able to run a shell in windows? Is a shell an editor?
11:24:37 <shachaf> edwardk: Between the (poset) categories of the reals and the naturals, which direction does the forgetful functor go?
11:25:17 <edwardk> now we're looking for a functor Free, such that Free -| U,   Free has to take objects and arrows in our category of functors to objects and arrows in our category of monads in 'just the right way' for monad homomorphisms from (Free F) to M to be isomorphic to natural transformations from F -> U M
11:25:30 <edwardk> but U M is just the same as "M" without knowing the monadness
11:26:03 <roboguy_> afons: A shell allows you to run commands which the operating system will then execute. Yes, the simplest Windows shell is cmd.exe. No, they are entirely separate things. An editor is used to edit text
11:26:11 <shachaf> Almost everywhere except category theory, people would just write "M" instead of "U M".
11:26:36 <roboguy_> afons: In a shell, you can do things like create directories, delete files, list files in a directory, start up other programs (such as text editors), etc
11:26:38 <afons> roboguy_ right, and am I able to run other shells in Windows? I see that in unix environments you can select the default shell but not in windows
11:26:39 <edwardk> so you want to say that we have something we can use like: Monad m => (forall a. f a -> m a) -> Free f a -> m a   -- which is that given a natural transformation from f ~> m  we can build a monad homomorphism from Free f to m.
11:26:58 <roboguy_> afons: yes. Cygwin would be one example of a unix-like shell in windows
11:27:12 <afons> what about MINGW32
11:27:15 <afons> is that a shell?
11:27:41 <edwardk> and given any monad homomophism from Free f to m   we also get a natural transformation from f to m that we can run back through that operation to recover the original
11:27:43 <aweinstock> afons: "cmd" is a shell (although a less capable one than cygwin's bash)
11:27:48 <roboguy_> afons: no. It's a collection of development software, like C/C++ compilers, libraries etc
11:27:52 <new_mind> afons: cygwin allows you to run pretty much every linux shell (bash, for example), or you could use powershell
11:28:01 <edwardk> this is where 'free' comes from.
11:28:04 * hackagebot hakyll 4.7.2.3 - A static website compiler library  https://hackage.haskell.org/package/hakyll-4.7.2.3 (JasperVanDerJeugt)
11:28:07 <Gurkenglas> edwardk, https://github.com/ekmett/free/pull/103
11:28:09 <chreekat> afons: Historically, "shell" referred to the program you used to interact with your operating system. In that generic sense, Windows has a 'shell' that is comprised of a desktop, menus, windows, a pointer, and so forth. Typically when people say 'shell' nowadays, they refer to the shell program that is the spiritual successor to the shell on unix computers many years ago. That shell didn't have windows or menus; it had a scriptable text interface
11:28:21 <edwardk> free isn't 'the minimal thing' its formally defined in terms of some forgetful functor and 'knowing what you forget'
11:28:25 <new_mind> afons: the easiest way i found to get a functional bash shell under windows is installing git for windows (which i usually need anyways)
11:28:30 <roboguy_> afons: I should also point out, if you are interested in text editors, both vim and emacs run on windows
11:28:41 <edwardk> its a way to rebuild the structure you forgot in 'the best way'
11:28:42 <afons> new_mind I have git bash
11:28:57 <afons> roboguy_ So is PowerShell a shell, and cmd.exe a shell?
11:29:04 <edwardk> Gurkenglas: merged
11:29:13 <new_mind> afons: thats a more-or-less standard bash and most of the usual *nix utilities right there
11:29:19 <chreekat> cmd.exe is a program that mimics the dos shell, so yeah
11:29:27 <afons> new_mind and is that considered a shell?
11:29:33 <new_mind> yes, bash is a shell
11:29:36 <shachaf> I think "free group" had a meaning before categories were ever invented. :-)
11:29:39 <roboguy_> afons: I've never used PowerShell, but I believe it is a shell together with a scripting language
11:30:04 <ttt_fff> do { a' <- a; b' <- b; f a' b' } // is there away to write this instead using lift/<*>/<$> ?
11:30:12 <afons> roboguy_ Am I able to select a default shell? For example, in Mac OSX when you open Terminal, a different shell shows up depending on the configuration.
11:30:14 <new_mind> roboguy_: same could be said about bash too... or even cmd.exe, since it runs .bat files
11:30:16 <roboguy_> ttt_fff: I think you need join
11:30:17 <afons> Is this the same thing in Windows?
11:30:24 <ttt_fff> robogy_: >>= ?
11:30:29 <roboguy_> ttt_fff: that would work too
11:30:39 <ttt_fff> roboguy_: how would it work; pls explain
11:30:57 <roboguy_> :t \f a b -> join (f <$> a <*> b)
11:30:59 <lambdabot> Monad m => (a2 -> a1 -> m a) -> m a2 -> m a1 -> m a
11:31:06 <roboguy_> ^ ttt_fff
11:31:11 <ttt_fff> roboguy_ ++
11:31:14 <roboguy_> new_mind: true
11:31:33 <afons> roboguy_ can you answer 
11:31:37 <roboguy_> ttt_fff: note that requires Monad
11:31:42 <edwardk> shachaf: re reals and naturals, you can 'forget' the non whole number part -- if you ignore computability issues, not sure if you include them -- e.g. floor is definitely forgetful from rationals to integers and respects the total order
11:31:42 <aweinstock> @undo do { a' <- a; b' <- b; f a' b' }
11:31:42 <lambdabot> a >>= \ a' -> b >>= \ b' -> f a' b'
11:31:42 <roboguy_> afons: No, I don't believe you can
11:31:49 <aweinstock> @. pl undo do { a' <- a; b' <- b; f a' b' }
11:31:49 <lambdabot> (b >>=) . f =<< a
11:31:49 <roboguy_> afons: I think all the programs are separate
11:32:04 <aweinstock> ttt_fff: ^
11:32:23 <ttt_fff> aweinstock: I'm not going to put (b >>=) . f =<< a into my code
11:32:27 <ttt_fff> that is not readable
11:32:42 <shachaf> edwardk: I would say that an integer is a real number together with a proof that the fractional part is 0.
11:32:51 <shachaf> And the forgetful functor forgets that proof.
11:32:53 <new_mind> afons: i don't think windows has a concept of a "default shell", except if you want to call explorer.exe (which includes your desktop) your "shell" (which some people do)
11:33:27 <shachaf> I think this is more in line with typical uses of "forgetful functor". But it's a pretty vague term.
11:33:39 <shachaf> (And this functor is adjoint to the other one, of course.)
11:33:54 <edwardk> shachaf: that can also work, then the 'proof' is property-like structure and your "forgetful" functor is pseudomonic
11:34:07 <roboguy_> afons: In OS X, Terminal is a program that basically just runs the default shell in a graphical window. I don't think Windows has an equivalent. I think each shell in Windows is bundled with the part that opens the graphical window
11:34:10 <mauris> is a free functor... "coforgetful"
11:34:25 <afons> roboguy_ oh ok thank you
11:34:45 <shachaf> mauris: Usually "co" is used for two things that are left and right adjoint to the same thing, I think.
11:34:54 <roboguy_> afons: Actually, I guess cygwin would be close. It doesn't come with windows. You probably could set a default shell there though
11:34:56 <afons> roboguy_ so just to keep this straight: examples of shells are PowerShell, cmd.exe, bash. examples of editors are vim and emacs
11:35:02 <roboguy_> afons: yep
11:35:04 <shachaf> I.e. for F -| G -| H, you would say that F and H are dual.
11:35:16 <new_mind> afons: correct
11:35:37 <afons> roboguy_ what about the zsh shell? I've heard it's really good with oh-my-zshell
11:35:39 <afons> is it unix only?
11:35:56 <new_mind> zsh should run just fine with cygwin
11:35:59 <roboguy_> afons: That would probably run okay on cygwin on windows
11:36:06 <mauris> shachaf, whoa, that makes a lot of sense
11:36:17 <roboguy_> I think oh-my-zshell is something that manages the configuration for your zshell
11:36:23 <new_mind> (cygwin is basicly a bunch of *nix programms compiled so they run nativly in windows)
11:36:33 <aweinstock> afons: cygwin implements a posix interface, so in a sense windows can run posix programs
11:36:55 <aweinstock> (that's not merely pedantic, I'm pretty sure the X11 window system works under cygwin)
11:37:40 <new_mind> i know that there is at least one x11 server that runs under windows... it doesn't have to be of cygwin to work
11:37:47 <afons> what is cygwin?
11:37:53 <afons> what does that have to do with zshell
11:38:49 <new_mind> cygwin provides a environment for *nix programms (which would include zsh) that alows them to compile and run under windows
11:38:55 <arkeet> cygwin is a *nix compatibility layer.
11:39:10 <arkeet> yeah that.
11:39:41 <afons> new_mind what causes unix programs not to run under windows?
11:40:10 <kadoban> afons: Lack of POSIX-ish API calls and such
11:40:12 <kadoban> I think
11:40:30 <geekosaur> afons: executable format, completely different system services accessed in completely different ways, general incompatibility
11:40:36 <new_mind> basicly what kadoban said, yes... and cygwin provides that
11:40:43 <geekosaur> same reason you need wine to run windows programs on unix/linux
11:41:52 <afons> And emacs
11:41:56 <afons> Is it a shell or an editor?
11:42:00 <roboguy_> editor
11:42:09 <kadoban> afons: Both :-/ Also a browser and some other stuff XD
11:42:21 <roboguy_> you can do a lot with it though, it is pretty extensible
11:42:48 <lamefun> http://lpaste.net/9041153122994487296 - why?
11:42:52 <new_mind> emacs is a editor, and you could call it a terminal muxer... since it allows you to display multible buffers 
11:43:24 <afons> what
11:43:41 <Gurkenglas> Why is it "hoistCofree :: Functor f => (forall x . f x -> g x) -> Cofree f a -> Cofree g a
11:43:41 <Gurkenglas> " as opposed to "hoistCofree :: Functor g => (forall x . f x -> g x) -> Cofree f a -> Cofree g a
11:43:41 <Gurkenglas> "?
11:44:03 <aweinstock> afons: there's a joke that emacs is a complete operating system (although it's primarily an editor)
11:44:13 <new_mind> you usually have one terminal to run programms, and once one programm runs, it takes full control over that terminal until it terminates
11:44:35 <edwardk> Gurkenglas: either works, you only need one functor constraint, so flip a coin
11:45:00 <aweinstock> screen/tmux are dedicated terminal multiplexers (allow you to have multiple shells running inside a single shell window)
11:45:01 <edwardk> Gurkenglas: it went that way because that was the way the implementation went
11:45:07 <roboguy_> lamefun: what library are you using?
11:45:24 <lamefun> roboguy_, Template Haskell?
11:46:02 <Gurkenglas> Sounds like there should be two versions, each needing one, especially as one seems to work bottom up and the other top down or something.
11:46:57 <edwardk> aweinstock: https://plus.google.com/+DebasishGhosh/posts/g9LASrMjeFS <- see my reply there which gives a longer worked example of how lists arise as the free monoid construction
11:47:07 <afons> what can zsh do that emacs can't and vice-versa? roboguy_
11:48:05 <roboguy_> afons: They really are two different things. Emacs is a text editor that happens to have a lot of features builtin while zsh is a shell
11:48:05 <new_mind> zsh is a shell, its a way to interact with your operating system... while emacs is a editor: it opens files, modifies it, and writes them to the hdd
11:48:06 <shachaf> emacs and zsh are not really good topics for this channel.
11:48:25 <arkeet> (some people use emacs for much more than that...)
11:48:30 <afons> new_mind: how is emacs an editor if it can open browser and stuff
11:48:41 <roboguy_> lamefun: ah, okay. I don't have too much experience with template haskell
11:48:45 <aweinstock> edwardk: thanks
11:49:13 <Gurkenglas> edwardk, https://github.com/ekmett/free/pull/104
11:50:21 <roboguy_> lamefun: I do notice that it doesn't like any of the $s. If I change $accN to a non-variable, it doesn't like $typeN and if I change that, it errors on $typeN
11:50:29 <mietek> edwardk: machines looks really nice
11:50:43 <mietek> I seem to have arrived at a Mealy machine
11:50:53 <mietek> cc dolio
11:52:31 <broma0> why is there no Control.Monad.Maybe in mtl? im using transformers' Control.Monad.Trans.Maybe for runMaybeT but running into all sort of type error that i think are caused by a lack of lifting on my part..
11:53:02 <roboguy_> lamefun: maybe you should make the data declaration manually inside of the textNewtype function, without using [d| ... |]
11:53:09 <broma0> is there some special way to runMaybeT inside of an mtl stack? 
11:53:09 <johnw> wouldn't Control.Monad.Maybe just be... Maybe?
11:53:18 <roboguy_> *maybe it's necessary to
11:53:21 <johnw> broma0: can you show the code that has the error?
11:53:32 <broma0> sure.. hang on a sec
11:58:13 <broma0> johnw: http://lpaste.net/138529
11:58:26 <broma0> i may be messing something else up
11:58:32 <johnw> can you paste the error
11:58:45 <johnw> and the types of these functions you're using
11:58:46 <Fay> hey where are haskell modules stored in the filesystem?
11:58:49 <johnw> otherwise, it could be anything
11:59:02 <Fay> like C libraries are generally in /usr/include
11:59:31 <johnw> Fay: do you mean at runtime, or for building code with GHC?
12:00:39 <Fay> i mean when i write a haskell program that i indend to compile with ghc and i type 'import Data.Text' where is the location of that code 'Data'
12:00:46 <Gurkenglas> Wait, what? https://travis-ci.org/ekmett/free/jobs/75141422 <- Why can't I implement "cohoist :: (Comonad w, Comonad v) => (forall x. w x -> v x) -> t w a -> t v a" using "hoistCofree :: Functor f => (f (Cofree g a) -> g (Cofree g a)) -> Cofree f a -> Cofree g a"?
12:01:06 <broma0> johnw: i added the error, what function signatures do you want?
12:01:48 <Fay> import imports from where?
12:01:56 <johnw> so, decode, getAccount and newSession all have different types
12:01:59 <johnw> and none of them return MaybeT
12:02:10 <Gurkenglas> https://travis-ci.org/ekmett/free/builds/75141417 <- Oh, this only fails for old versions of GHC/cabal. And new package versions should still be buildable with old compiler versions, so those builds must not be failed by travis?
12:02:17 <johnw> Fay: try: ghc-pkg list
12:02:32 <broma0> johnw: also simplified the top of that fn a little (removed cookie stuff)
12:03:22 <johnw> that had no effect on what the problem is
12:03:31 <bennofs> Gurkenglas: yes
12:03:36 <johnw> I don't think MaybeT does what you think it does
12:04:19 <Forgetaboutit> hey guys, why does setting a record field of type `(MonadIO m) => TypeX -> m (Maybe TypeY)` to a function of type `TypeX -> IO (Maybe TypeY)` give me a type error?
12:04:27 <broma0> johnw: im thinking it allows me to assume the "maybe" function calls work, and at the end of the do block i'll either get App Nothing or App (Just x)
12:04:49 <johnw> Forgetaboutit: because the record field wants a polymorphic function, not a specific one
12:05:15 <Gurkenglas> Too bad, I think I remember needing the more forgiving signature at some point.
12:05:15 <johnw> broma0: within MaybeT, if you say "x <- foo", then foo's type must be MaybeT a
12:05:41 <broma0> johnw: i see, so not just Something -> Maybe SomethingElse?
12:05:47 <johnw> no
12:05:47 <Fay> johnw: okay those look like compiled objects
12:05:49 <Forgetaboutit> johnw: Aaaah, of course!  Would hiding `m` with existential types work?
12:05:50 <subleq> johnw: you would need an existential right?
12:06:06 <roboguy_> Forgetaboutit: I would just use liftIO
12:06:10 <roboguy_> :t liftIO
12:06:11 <lambdabot> MonadIO m => IO a -> m a
12:06:12 <johnw> Forgetaboutit: use liftIO
12:06:38 <roboguy_> :t (liftIO .)
12:06:39 <lambdabot> MonadIO m => (a -> IO a1) -> a -> m a1
12:06:57 <broma0> johnw: well in the case of 'decode body', the result is a "Maybe X" so i try to pull out the X with 'cred <- decode body'
12:07:09 <johnw> you'd have to do this:
12:07:15 <johnw> MaybeT $ return (decode body)
12:07:34 <johnw> sadly, MaybeT is a lot noisier than it's worth most of the time
12:08:12 <broma0> johnw: yeah thats what i was hoping to avoid
12:09:00 <broma0> is there any way to accomplish what im trying to do cleanly? 
12:09:04 <johnw> you're not using 'acct' either
12:09:17 <broma0> i know, i left out some basic stuff
12:09:24 <broma0> the real function is a bit more noisy
12:10:10 <Forgetaboutit> roboguy_, johnw: Is there a way to lift any Monad of the shape MonadIO into MonadIO? I'm thinking about having a different function of type `TypeX -> CustomMonadStack (Maybe TypeY)` for CustomMonadStack with at least an instance of MonadIO.
12:10:35 <roboguy_> fr33domlover: what do you mean "of the shape MonadIO"?
12:10:39 <broma0> is there a nice way to deal with a bunch of "maybe" computations inside a transformer stack?
12:10:45 <roboguy_> CustomMonadStack should already have an instance of MonadIO
12:11:21 <Forgetaboutit> roboguy_: Any transformer stack with a MonadIO instance
12:11:36 <roboguy_> Forgetaboutit: hmm, okay. Then what do you mean by lifting it into MonadIO?
12:11:46 <dmj`> broma0: the maybe monad
12:11:51 <Forgetaboutit> roboguy_: I guess I'm just confused by the fact that I need to lift IO into `MonadIO m => m` by hand
12:12:39 <broma0> dmj`: i dont want maybeT to be part of the stack.. is there a way to wrap my stack in a maybeT for only the part of the computation that might fail?
12:12:47 <broma0> thats what i was trying to do with runMaybeT in my lpaste
12:13:06 <Forgetaboutit> roboguy_: I'm wondering if I need additional work to pass `CustomMonadStack` when `MonadIO m => m` is required
12:14:29 <johnw> ah, I see what you're asking
12:14:41 <johnw> it won't work
12:14:58 <johnw> if MonadIO m => m is required, it means you need an action that works for anyone *else's* MonadIO-derived monad
12:15:04 <fuzzyhorns> http://blog.paralleluniverse.co/2015/08/07/scoped-continuations/
12:15:22 <fuzzyhorns> im unsure this is right but dont have the expertise to be sure
12:15:24 <fuzzyhorns> thoughts?
12:15:45 <johnw> fuzzyhorns: did you write it?
12:15:52 <fuzzyhorns> johnw: no :c
12:16:07 <fuzzyhorns> johnw: im curious about the questions it puts forward though
12:16:14 <johnw> so, that's a lot to read; do you have a specific question?
12:16:54 <fuzzyhorns> he claims monads are harder to compose
12:17:02 <fuzzyhorns> even in pure functional langs
12:17:30 <johnw> well, it's true
12:17:53 <arkeet> well, you can't compose just any monads.
12:17:54 <fuzzyhorns> so why are monads important, why not do everything in cps?
12:17:58 <johnw> monad transformers are work to use, and research into alternatives are ongoing
12:17:58 <arkeet> you need a distributive law
12:19:06 <johnw> fuzzyhorns: you can't do everything with continuations either
12:19:17 <fuzzyhorns> johnw: oh? why not?
12:19:27 * arkeet if only there were something that could do everything.
12:19:43 <johnw> for example, monad-control is a great tool for working with monad transformers; but the one transformer it can't work with is ContT
12:20:46 <Forgetaboutit> johnw: Ah, that's a pity :/. Is there a way to say "This function returns an IO action, but it doesn't have to be in IO exactly. Something allowing IO is fine as well."
12:21:07 <johnw> Forgetaboutit: that's fine, but then you have provide such a function :)
12:21:29 <johnw> you're being caught by the universal/existential flip
12:21:52 <Forgetaboutit> johnw: so `forall m . MonadIO m => X -> m (Maybe Y)`?
12:22:11 <Forgetaboutit> johnw: Is that even possible?
12:22:14 <johnw> yeah, as a *caller*, you can fix m to your monad; as a *callee*, you can't fix m at all
12:23:29 <roboguy_> Forgetaboutit: Maybe not, but you can turn a function X -> IO (Maybe Y) into a function MonadIO m => X -> m (Maybe Y)
12:25:06 <Forgetaboutit> johnw: Hm, my idea was exactly the opposite: the caller shouldn't worry as long as it's in IO giving the callee the freedom to choose whatever
12:25:31 <johnw> Forgetaboutit: you may be able to achieve what you want with a CPS transformation
12:25:45 <johnw> one sec, let me show you what I mean
12:26:52 <mietek> xplat: thank you for your suggestion of mapAccumL. I really shouldn’t have knocked it.
12:27:13 <mietek> xplat, dolio, mbrock, geekosaur: https://gist.github.com/mietek/9571b4b9920e0f1d1be2
12:27:22 <mietek> ReinH: ^^
12:28:09 <mietek> This processes 1.1GB of XML in 75s
12:29:39 <mbrock> neat! You know Kmett has a `machines` package? Might be a clever optimization or two in there :)
12:29:48 <mietek> Yeah, I was just looking at it
12:30:49 <broma0> anyone know of some documentation on using the continuation monad, or CPS in general to structure large programs?
12:33:53 <johnw> Forgetaboutit: never mind, what I was thinking of doesn't work
12:34:28 <broma0> can CPS be used as a tool to structure large programs?
12:34:33 <Forgetaboutit> johnw: Thank you anyway, I'm going to rethink my approach I believe :)
12:35:07 <johnw> that's probably a goodidea
12:35:15 <johnw> too much polymorphism can be bad
12:46:36 <nschoe> Is there a function 'breakEveryN' which would turn a list into a list of list of size n? Like breakEveryN 3 [1..] = [[1,2,3],[4,5,6],[7,8,9],...]?
12:46:48 <nschoe> I can't seem to find it in Data.List.
12:47:18 <kadoban> nschoe: I think it's called something with chunks in the name, possibly in Data.List.Split in the split package.
12:47:28 <kadoban> chunksOf ? something like that
12:47:32 <geekosaur> @index chunksOf
12:47:33 <lambdabot> bzzt
12:47:39 <nschoe> kadoban, okay thanks, I'll check the Split package
12:47:41 <geekosaur> boo, almbdabot
12:47:52 <bennofs> @hackage split
12:47:52 <lambdabot> http://hackage.haskell.org/package/split
12:47:59 <bennofs> :t chunksOf
12:48:00 <lambdabot> Int -> [e] -> [[e]]
12:48:14 <nschoe> ah thanks guys
12:52:09 <roboguy_> hmm, is there a good way to generalize stripPrefix, to Traversable or something like that?
12:55:08 <bennofs> roboguy_: Traversable cannot change the length of things
12:55:17 <foreignFunction> How do I capture a type-list by a type variable?
12:57:03 <foreignFunction> Problem A being, how do I store a VinylGL.BufferedVertices ( https://hackage.haskell.org/package/vinyl-gl-0.3.0.1/docs/Graphics-VinylGL-Vertex.html#v:BufferedVertices ) into a record?
12:57:11 <roboguy_> bennofs: what if you have (Traversable t, MonadPlus t)?
12:58:36 <roboguy_> :t foldr (\x y -> if x > 3 then mempty else y) mempty
12:58:37 <lambdabot> (Num a, Ord a, Foldable t, Monoid b) => t a -> b
12:58:57 <foreignFunction> …at the same time still not having to write the type explicitly.
13:01:51 <roboguy_> :t foldr (\x y -> if x > 3 then mzero else pure x `mplus` y) mzero
13:01:52 <lambdabot> (Num a, Ord a, Foldable t, MonadPlus m) => t a -> m a
13:03:08 * hackagebot Unixutils 1.54.1 - A crude interface between Haskell and Unix-like operating systems  https://hackage.haskell.org/package/Unixutils-1.54.1 (DavidFox)
13:06:15 <broma0> where can i learn about practical use of the continuation monad?
13:07:12 <roboguy_> broma0: I'm not sure I've ever seen a practical guide to it. Have you looked at the sigfpe post, Gabriel's post and Oleg's info about it yet?
13:07:51 <roboguy_> (of those, Gabriel's is probably most rooted in practicality: http://www.haskellforall.com/2012/12/the-continuation-monad.html)
13:08:29 <broma0> roboguy_: yeah i've read through them a few times.. i just have this feeling that writing a web api entirely in the cont monad could be a cool adventure
13:08:43 <roboguy_> broma0: have you looked into pipes and conduit?
13:08:49 <broma0> roboguy_: i have not
13:08:49 <roboguy_> I believe those are based on continuations
13:08:55 <roboguy_> internally, anyway
13:10:37 <ski> broma0 : have you seen <https://tmp.barzilay.org/cont.txt> ?
13:10:42 <broma0> roboguy_: know of any "application" examples? i.e. not libs
13:11:08 <broma0> ski: just opened it..
13:11:41 <roboguy_> broma0: I'm afraid I don't, as far as I can recall. It might help to look at a couple simple pipes examples and then follow the code through to how it works internally
13:12:00 <roboguy_> the pipes library comes with a nice tutorial in the documentation
13:12:04 <johnw> if you have any specific pipes or conduit questions, please feel free to ask
13:12:08 <johnw> I've used them both a fair bit
13:12:19 <roboguy_> johnw: they use continuations on the inside, don't they?
13:12:25 <johnw> yes
13:15:19 <roboguy_> johnw: someday, I need to find an excuse to use those libraries. I haven't run into a problem that seemed like they would be a good fit for, so far
13:15:49 <roboguy_> The parts that I've looked at reminded me a bit of how the Icon language works
13:20:10 <Fylwind> is there some kind of data structure that has all the nice properties (efficient updates) but *also* the ability to locate the index of a given value efficiently?
13:20:20 <Fylwind> nice properties of Seq* I mean
13:22:46 <nitrix> Vectors?
13:22:51 <roboguy_> Fylwind: that sounds like a tall order. So, there would be very little difference between the behavior of the index and the of the value?
13:23:16 <nitrix> Fylwind: Oh, the index of a value?
13:23:28 <Fylwind> nitrix: Vector update is slow (and in this particular, MVectors aren't of much help since I need to constantly delete from the middle)
13:23:32 <Fylwind> particular case*
13:23:45 <Fylwind> roboguy_: yeah it probably is … but the algorithm demands it :(
13:23:54 <nitrix> You said updates, not insertion or deletions though.
13:24:16 <Fylwind> ok, deletions mainly
13:24:31 <nitrix> So, the typical manipulations as well... I'd say some sort of tree.
13:24:50 <johnw> Fylwind: how many elements will you be working with?
13:25:10 <Fylwind> basically here's what I need to be efficient: cons, elemIndex, deleteAt, null
13:25:24 <nitrix> Fylwind: It's just that the indexing is based on the value instead of the index, semantically there's no real difference.
13:25:29 <nitrix> Fylwind: Are all the values the same type?
13:25:53 <Fylwind> johnw: probably not enough that I should be spending so much time worry about efficiency, but I'm just curious for pedantic reasons if there's an asymptotically optimal type for this
13:25:59 <Fylwind> nitrix: same type yes
13:26:13 <nitrix> Fylwind: Orderable ?
13:26:25 <Fylwind> nitrix: I need the index because the order of elements is important (unlike Set)
13:26:42 <roboguy_> nitrix: I guess the difference is that you can have duplicate values but not duplicate indices
13:26:56 <Fylwind> well in this particular case the values are all unique
13:26:57 <nitrix> I see.
13:27:17 <roboguy_> Fylwind: what if you switched around the values and the indices? I guess that wouldn't give you fast deleteAt yet
13:27:49 <nitrix> roboguy_: Then he looses the ordering for linear traversal.
13:27:49 <Fylwind> yeah … the problem is that if I delete something from the middle, you'll have to update lots of indices
13:27:54 <roboguy_> ah
13:29:00 <nitrix> Maybe a tree where the bottom leaves are linked?
13:29:07 <Fylwind> FYI I'm trying to count the number of crossings in a pairing of an even-numbered sequence
13:29:08 <nitrix> A skip-list maybe?
13:29:23 <roboguy_> you might need to combine two data structures
13:29:34 <dmj`> nitrix: I was about to say that
13:29:49 <Fylwind> I tried combining Seq and Map, it didn't work because deleteAt is still slow
13:29:53 <nitrix> That's what I'm thinking too. Skip-lists are the basis for this I think.
13:30:19 <Fylwind> skip list sounds interesting though
13:30:39 <Fylwind> I could probably maintains some sort of relative index on the branches so I don't have to update the whole tree
13:30:57 <nitrix> You get linearity with O(log x) operations. It's not memory efficient but it's very cool because you can re-order the nodes easily based on frequency or whatever.
13:31:17 <nitrix> I don't know what your ordering significates but if it lets you change that easily as well, which is another added bonus.
13:31:28 <dmj`> the redis sorted is implemented in terms of a skip list and a hash table I believe, you gives logarithmic lookup from value to index
13:31:36 <dmj`> you get *
13:35:26 <Fylwind> thanks for the suggestions
13:36:03 <nitrix> Fylwind: There are multiple adaptations to skip lists and the concept is very simple to understand. From the description you gave, I think it's worth looking into.
13:37:36 <dmj`> the redis sorted set*
13:37:45 <dmj`> english not much speak often do I
13:37:50 <broma0> Any idea how one would write a Wai application (Request -> IO Response) entirely in the Cont monad?
13:38:24 <kadoban> broma0: Why would you do it anyway?
13:38:34 <roboguy_> broma0: (Response -> r) -> Request -> IO r?
13:38:38 <broma0> kadoban: for the adventure, honestly that's it
13:38:50 <broma0> im experimenting with Cont
13:40:43 <broma0> roboguy_: what is that madness 
13:41:00 <roboguy_> broma0: continuations!
13:41:01 <roboguy_> ha
13:41:20 <roboguy_> @unmtl Cont r a
13:41:20 <lambdabot> (a -> r) -> r
13:41:33 <johnw> Request -> (Response -> IO r) -> IO r
13:41:35 <johnw> it would have to be ContT
13:41:44 <roboguy_> ah, right
13:41:53 <aweinstock> @help unmtl
13:41:53 <lambdabot> unroll mtl monads
13:42:05 <roboguy_> @unmtl ContT r IO Response
13:42:06 <lambdabot> (Response -> IO r) -> IO r
13:43:04 <roboguy_> forgot that first IO
13:44:06 <roboguy_> it's a shame Monad uses the name "return". That would make a decent continuation name
13:44:32 <dmj`> ftp://ftp.cs.umd.edu/pub/skipLists/skiplists.pdf 
13:44:33 <kclancy> I've got ghc-mod working in emacs. Now I just need to figure out how to navigate my project. Are there any tags programs that are recommended for Haskell and emacs?
13:45:43 <roboguy_> kclancy: have you tried hasktags?
13:45:56 <cocreature> kclancy: https://github.com/aloiscochard/codex#codex
13:46:05 <kclancy> I just installed hasktags, but I haven't tried it out yet. Thanks.
13:46:19 <creichert> codex uses hasktags but will tag an entire cabal project
13:46:23 <augur> anyone know of any guides for designing Parsec parsers?
13:46:24 <creichert> which is very nice (including base)
13:46:35 <augur> like.. "do X/don't do X" sorts of guides?
13:46:40 <kclancy> cocreature: thanks. I think I'm going to try codex first.
13:46:45 <broma0> Wrapping my head around this continuation stuff is pretty difficult
13:46:50 <cocreature> codex uses hasktags
13:46:57 <creichert> i've been working on one for stack which will generate tags for snapshot based tags as well
13:47:12 <cocreature> oh creichert already said that sorry
13:47:25 <roboguy_> broma0: It is confusing sometimes but I usually think of it as, instead of returning your value normally, you pass it on to another function to finish out the computation
13:47:31 <roboguy_> if that helps
13:48:10 * hackagebot ring-buffer 0.1.2 - A concurrent, mutable ring-buffer  https://hackage.haskell.org/package/ring-buffer-0.1.2 (BenGamari)
13:48:12 * hackagebot svm-light-utils 0.1.3 - Parsers and formatters for the SVMlight input file format  https://hackage.haskell.org/package/svm-light-utils-0.1.3 (BenGamari)
13:49:05 <johnw> broma0: a continuation is just the "next place to go", passed as a value instead of implied by execution sequencing
13:50:11 <johnw> i.e., foo (\_ -> bar (\_ -> baz)), instead of foo >>= \_ ->  bar >>= \_ -> baz
13:50:38 <johnw> Cont and ContT are a *lot* easier to understand if you remove the type wrappers entirely, and then write their instances and helper methods (like callCC)
13:50:39 <broma0> how does on define a function in the Cont monad? like app :: Request -> ContT r IO Response
13:50:51 <johnw> define it like any other monadic action
13:51:01 <johnw> app = do ... do stuff ith responde .. return response
13:51:25 <roboguy_> broma0: ContT is just a newtype wrapper
13:51:30 <roboguy_> @unmtl ContT r m a
13:51:30 <lambdabot> (a -> m r) -> m r
13:51:33 <roboguy_> for that ^
13:51:50 <johnw> s/do stuff ith responde/do stuff with the request/
13:53:01 <broma0> johnw: i see what you did there...
13:53:11 * hackagebot warc 0.1.1.1 - A parser for the Web Archive (WARC) format  https://hackage.haskell.org/package/warc-0.1.1.1 (BenGamari)
13:54:44 <Visus> hello everybody!
13:55:24 <srhb> Visus: Hello.
13:55:36 <Visus> Is anyone here who could help me regarding a "database"?
13:55:44 <broma0> what would this be as defined with Cont? (String -> IO b) -> IO b
13:55:49 <broma0> Visus: thats very broad!
13:56:01 <roboguy_> @unmtl Cont b IO String
13:56:01 <lambdabot> Plugin `unmtl' failed with: `(IO -> b) -> b' is not a type function.
13:56:06 <roboguy_> @unmtl ContT b IO String
13:56:06 <lambdabot> (String -> IO b) -> IO b
13:56:14 <broma0> ha
13:56:16 <broma0> thanks!
13:56:21 <roboguy_> sure!
13:57:15 <statusfailed> Is there a translation of apfelmus' "operational" tutorial to use of the "free" package?
13:57:22 <broma0> gah, im trying to write this with ContT: 'withRequest f = getLine >>= \l -> f l'
13:58:19 <roboguy_> (by the way, ContT is also like a partially applied (>>=))
13:58:31 <johnw> statusfailed: what do you want to do with 'free'?
13:58:35 <johnw> it's pretty easy to use
14:03:09 <statusfailed> johnw: I want to see a translation of the "stack program" example 
14:04:35 <statusfailed> johnw: I'm trying to understand how the two relate, basically
14:04:42 <statusfailed> so I'd like to see the exact same example written in both
14:04:58 <simon> @pl \xs -> f (map toLower (filter g (filter h xs)
14:04:59 <lambdabot> (line 1, column 46):
14:04:59 <lambdabot> unexpected end of input
14:04:59 <lambdabot> expecting variable, "(", operator or ")"
14:05:12 <simon> @pl \xs -> f (map toLower (filter g (filter h xs)))
14:05:12 <lambdabot> f . map toLower . filter g . filter h
14:06:10 <ski> broma0> :t withRequest
14:06:48 <sword_smith> @pl \x-> map (\y -> y^2) x
14:06:48 <lambdabot> map (^ 2)
14:07:10 <broma0> ski: withRequest :: (String -> IO b) -> IO b
14:07:47 <ski> broma0 : `withRequest = (getLine >>=)' ?
14:08:30 <broma0>  withRequest :: ContT r IO Request gives me a big ol error
14:08:35 <ski> @type ContT (getLine >>=)
14:08:36 <lambdabot> ContT r IO String
14:09:05 <roboguy_> broma0: That doesn't give a Request, it gives a String
14:09:25 <broma0> type Request = String
14:09:31 <broma0> i fixed it....
14:09:43 <broma0> why does this work 'withRequest = ContT (getLine >>=)'
14:09:58 <broma0> but not simple 'withRequest = (getLine >>=)'
14:10:14 <ski>   newtype ContT o m a = ContT {runContT :: (a -> m o) -> m o}
14:10:35 <ski> because `ContT o m a' is not the same as `(a -> m o) -> m o'
14:10:35 <roboguy_> broma0: because ContT is a newtype, not a type synonym
14:10:35 <broma0> i guess "no shit" would suffice 
14:10:47 <broma0> thank you haha
14:18:12 * hackagebot linear-opengl 0.2.0.9 - Isomorphisms between linear and OpenGL types  https://hackage.haskell.org/package/linear-opengl-0.2.0.9 (BenGamari)
14:24:12 <kclancy> when using cabal, should I expect custom-built dependencies added using add-source to get used if they are not direct dependencies of the project, but transitive ones? 
14:27:11 <kclancy> I can't install codex because its dependency mono-traversable is not building properly.
14:28:12 * hackagebot fusion 0.1.0 - Effectful streaming library based on shortcut fusion techniques  https://hackage.haskell.org/package/fusion-0.1.0 (JohnWiegley)
14:31:18 <nitrix> Is there a haskell function that splits "abcdefghijklmnopqrstuvwxyz" into ["abcd", "bcde", "cdef", "defg", ...] ?
14:31:32 <nitrix> Otherwise, I'll write one that's recursive, shouldn't be too bad.
14:31:45 <johnw> tails
14:32:02 <nitrix> johnw: The segments have a fixed length.
14:32:15 <johnw> map (take 4) . tails
14:33:22 <arkeet> that will end in "xyz", "yz", "z", "" though, not "wxyz"
14:33:27 <arkeet> which may or may not be what you want.
14:33:59 <arkeet> > map (take 3) . tails $ "abcde"
14:33:59 <rlewis> > chunksOf 4 "abcdefghijklmnopqrstuvwxyz"
14:34:00 <lambdabot>  ["abc","bcd","cde","de","e",""]
14:34:01 <lambdabot>  <no location info>: can't find file: L.hs
14:34:08 <nitrix> I wasn't aware of `tails`. Yeah, it's actually good, I'll just filter the results.
14:34:09 <arkeet> chunksOf will not produce overlapping chunks.
14:34:14 <ClaudiusMaximus> > [l|l@[_,_,_,_]<-tails "nitrix"]
14:34:15 <lambdabot>  ["trix"]
14:34:18 <arkeet> well, you already know you need to drop 4 things from the end.
14:34:21 <ClaudiusMaximus> woops
14:34:26 <rlewis> yeah I misread desired result
14:34:26 <nitrix> arkeet: correct :)
14:34:40 <happy0> nitrix: https://hackage.haskell.org/package/split-0.2.2/docs/Data-List-Split.html#v:chunksOf
14:34:41 <arkeet> dropping from the end efficiently is a fun exercise.
14:34:48 <johnw> or just filter
14:34:48 <happy0> is that what you want? :o
14:34:55 <johnw> that should drop from the end in this case very efficiently
14:34:59 <arkeet> filter on what.
14:35:07 <happy0> oh wait, i misread
14:35:09 <happy0> never mind
14:35:14 <johnw> filter ((== 4) . length) . map (take 4) . tails
14:35:14 <happy0> !
14:35:17 <nitrix> I'll filter on length, yes
14:35:19 <arkeet> that sounds rather inefficient.
14:35:45 <johnw> well, it should just be O(n), right?
14:36:04 <johnw> oh, a bit more than that
14:36:05 <arkeet> O(n*k), where n is input length and k is 4
14:36:05 <nitrix> Better than O(2n) for finding the length and truncating.
14:36:08 <johnw> right
14:36:14 <nitrix> Right, for each chars but oh well.
14:36:27 <nitrix> It's nothing crazy, just solving euler problems :)
14:36:44 <johnw> euler was interesting at the very beginning
14:37:30 <hpc> it turns into hardcore math very rapidly
14:37:37 <johnw> plus a lot of dumb problems
14:37:48 <johnw> it started feeling like make-work, which I guess is exactly what it is
14:37:55 <hpc> yeah
14:38:12 * hackagebot fusion 0.1.1 - Effectful streaming library based on shortcut fusion techniques  https://hackage.haskell.org/package/fusion-0.1.1 (JohnWiegley)
14:38:31 <arkeet> you know what's better?
14:38:39 <arkeet> > transpose $ take 3 (tails "abcdef")
14:38:41 <lambdabot>  ["abc","bcd","cde","def","ef","f"]
14:38:44 <arkeet> oh damn.
14:38:47 <arkeet> not transpose. :-)
14:38:51 <arkeet> but something similar.
14:39:15 <shachaf> > transposeOf traverse $ take 3 (tails "abcdef")
14:39:17 <lambdabot>  ["abc","bcd","cde","def"]
14:39:49 <arkeet> you could.
14:40:04 <voidzero> maybe something with splitWhen?
14:40:07 <arkeet> > foldr (zipWith (:)) (repeat []) . take 3 . tails $ "abcdef"
14:40:08 <lambdabot>  ["abc","bcd","cde","def"]
14:40:52 <arkeet> > foldr (zipWith (:)) (repeat []) . take 0 . tails $ "abcdef" -- oops
14:40:54 <lambdabot>  ["","","","","","","","","","","","","","","","","","","","","","","","","",...
14:41:32 <arkeet> > transposeOf traverse [""]
14:41:33 <lambdabot>  []
14:41:44 <arkeet> er
14:41:51 <Welkin> :t transposeOf
14:41:52 <lambdabot> LensLike ZipList s t [a] a -> s -> [t]
14:41:56 <arkeet> > transposeOf traverse $ take 0 (tails "abcdef")
14:41:57 <Welkin> oh, lens
14:41:57 <lambdabot>  ["","","","","","","","","","","","","","","","","","","","","","","","","",...
14:42:00 <arkeet> oh alright.
14:42:08 <arkeet> if you see xxxOf, it's probably lens.
14:42:26 <shachaf> transposeOf l = getZipList . l ZipList, or something like that.
14:42:49 <shachaf> > getZipList . traverse ZipList $ take 3 (tails "abcdef")
14:42:50 <lambdabot>  ["abc","bcd","cde","def"]
14:43:13 * hackagebot hoogle-index 0.4.3 - Easily generate Hoogle indices for installed packages  https://hackage.haskell.org/package/hoogle-index-0.4.3 (BenGamari)
14:44:06 <arkeet> :t getZipList . traverse ZipList
14:44:07 <lambdabot> Traversable t => t [b] -> [t b]
14:44:46 <shachaf> You can't get transpose's behavior in general.
14:44:53 <shachaf> Even though transpose's behavior is so great.
14:45:09 <shachaf> @where pi_10 -- for instance.
14:45:10 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
14:47:10 <voidzero> > Data.List.Split.Internals.splitEvery 4 ['a'..'z']
14:47:11 <lambdabot>      Not in scope: ‘Data.List.Split.Internals.splitEvery’
14:47:18 <voidzero> > splitEvery 4 ['a'..'z']
14:47:19 <lambdabot>  ["abcd","efgh","ijkl","mnop","qrst","uvwx","yz"]
14:47:57 <voidzero> oh duh
14:47:59 <voidzero> i misread
14:48:56 <arkeet> johnw: then again, everything you could do is O(n*k).
14:48:59 <arkeet> or worse.
14:49:01 <arkeet> where O is Theta.
14:49:35 <arkeet> so I guess I mean uh.
14:49:42 <arkeet> Omega?
14:50:20 <arkeet> no.
14:50:40 <arkeet> I mean yeah.
14:50:54 <arkeet> seems like there are multiple confilcting definitions of big Omega.
14:54:08 <samba1> Why doesn't this attoparsec parser work?
14:54:09 <samba1> char '"' *> many1 (char '"' <|> char 'a') <* char '"'
14:54:09 <samba1> on input "a""
14:54:09 <samba1> I know that many1 is consuming the ending double quote, but shouldn't attoparsec backtrack automatically? Sometimes the quote might be a valid part of the middle and should be consumed, but if it's the last thing the quote should be consumed by the last char '"'.
14:54:43 <samba1> It's returning Partial, which I guess backtracks to right after the first double quote?
14:58:13 * hackagebot wkt 0.2.6 - Parsec parsers and types for geographic data in well-known text (WKT) format.  https://hackage.haskell.org/package/wkt-0.2.6 (BenGamari)
14:58:15 * hackagebot bus-pirate 0.6.3 - Haskell interface to the Bus Pirate binary interface  https://hackage.haskell.org/package/bus-pirate-0.6.3 (BenGamari)
15:00:36 <BrianHV> this might be a long shot... but I'm trying to find a talk where someone described how he moved a product from (I think) rails to haskell, and the static typing helped manage the complixity of different clients having different requirements. anyone know what I'm talking about?
15:01:07 <BrianHV> I came across it within the past few months
15:07:05 <BrianHV> found it! Ryan Trinkle at CUFP 2013 if anyone's interested
15:08:14 * hackagebot pandoc-lens 0.3.3 - Lenses for Pandoc documents  https://hackage.haskell.org/package/pandoc-lens-0.3.3 (BenGamari)
15:18:14 * hackagebot b-tree 0.1.2 - Immutable disk-based B* trees  https://hackage.haskell.org/package/b-tree-0.1.2 (BenGamari)
15:18:57 <hpc> that's a cool package
15:20:01 <hpc> make some sort of thingy between that and ixset
15:23:12 <anticore> hey guys, ghci gives the following warning: <interactive>: warning: _tzset from msvcrt is linked instead of __imp__tzset
15:23:16 <anticore> what does it mean?
15:28:15 * hackagebot vty 5.3 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.3 (JonathanDaugherty)
15:35:28 <johnw> anticore: sounds like it chose an alternate symbol
15:35:49 <johnw> anticore: which may not be an issue, I'm not sure on Windows
15:35:57 <sveit> is it fair to think of traversals (from lens) as a sort of "instance" for traversable?
15:36:04 <johnw> sveit: yes!
15:36:08 * geekosaur has seen that various places and thinks it is not an issue
15:36:10 <johnw> sveit: you even write them similarly
15:36:26 <johnw> sveit: but traversals are much more, since they compose with other optics
15:36:54 <geekosaur> when doing normal linking you want to use the import symbol; but ghci (and TH) don't do normal linking and need the real symbol. but the windows linker produces that warning because it doesn't see the implib symbol it thinks it should be using
15:37:33 <sveit> johnw: thanks
15:37:34 <geekosaur> ...is my possibly incorrect understanding. (it was correct years ago, but don't know how much things have changed since then...)
15:38:11 <geekosaur> (in particular I don't think I've seen IMPLIB being used to generate import symbols in years...)
15:39:12 <sveit> are there examples/write-ups for indexed lenses/traversals? I'm having trouble finding anything on them
15:39:33 <johnw> sveit: have you seen http://artyom.me/lens-over-tea-1?
15:40:55 <johnw> and a small example: http://zrho.me/posts/2015-03-08-indexed-traversal-debruijn-binders.html
15:42:00 <lvh> hello
15:47:16 <sveit> johnw: that first link doesn't mention indexed traversals anywhere in the article i don't think
15:48:56 <johnw> oh, maybe it's in one of the later articles in the series
15:50:13 <sveit> johnw: in all for he keeps promising but never gets around to it :)
15:50:21 <johnw> huh, ok
15:52:56 <sveit> can someone explain this type signature? (~) * i j => Indexable i (Indexed j)
15:53:14 <sveit> I understand the part after the =>, but not before
15:53:16 * hackagebot google-drive 0.4.0 - Google Drive API access  https://hackage.haskell.org/package/google-drive-0.4.0 (PatrickBrisbin)
15:53:22 <roboguy_> sveit: it's how haddock renders type equality
15:53:31 <hpc> that's horrifying
15:53:36 <hpc> why not (i ~ j)?
15:53:39 <roboguy_> in normal Haskell, it would look like "i ~ j => Indexable i (Indexed j)"
15:53:46 <roboguy_> hpc: I don't know, for some reason it always wants to put the kinds in
15:53:51 <geekosaur> it's a bug in haddock
15:54:07 <hpc> ah, groovy
15:54:15 <geekosaur> it doesn't understand ~ and renders it that weird way
15:54:21 <roboguy_> it's funny, I was just answering more or less the same question in #haskell-beginners
15:54:46 <roboguy_> it definitely looks weird as it is
15:54:58 <roboguy_> with polykinds, it's completely cryptic
15:55:00 <geekosaur> I think it uses ghc-api to get it back as something like i ~ j :: * and gets confused
15:55:28 <sveit> so why isn't it written Indexable i (Indexed i)?
15:55:47 <roboguy_> geekosaur: I thought it was applying kind arguments. Like "f ~ Maybe" would render as "(~) (* -> *) f Maybe"
15:55:50 <roboguy_> (I think)
15:56:22 <geekosaur> hm, not sure. I worked out what it was doing once
15:56:52 <roboguy_> geekosaur: also, I seem to remember that in the presence of polykinds, it's even worse: it shows them the same as type variables
15:57:01 <geekosaur> yeh
15:57:09 <geekosaur> doesn't get those at all
15:57:11 <roboguy_> so you might have something like (~) k p Proxy
15:57:18 <roboguy_> which gets super confusing
15:58:39 <geekosaur> sveit, I think it's because yours is applied at instance selection time and thereby admits someone writing an instance for Indexable i (Indexed j) where i /~ j
15:58:58 <geekosaur> writing it with the equality in the context prevents that because it would be an overlap
16:00:57 <shachaf> geekosaur: Isn't * just a kind argument?
16:01:11 <shachaf> It doesn't look like a bug as such, just confusing.
16:01:31 <geekosaur> I am now wondering if I said something in a confusing way,,,
16:02:09 <shachaf> (~) :: forall k. k -> k -> Constraint
16:02:40 <shachaf> It gets a kind argument and two type arguments.
16:03:17 * hackagebot vty 5.3.1 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.3.1 (JonathanDaugherty)
16:13:17 * hackagebot brick 0.1 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.1 (JonathanDaugherty)
16:14:11 <sm> nice!
16:15:34 <mniip> is there a name for data D f a = A a | B (f (D f a))
16:15:46 <lyxia> Free
16:15:52 <mniip> oh
16:15:57 <mniip> so that's what it is
16:18:50 <sveit> is there a way to write a function like "(Functor f) => a -> f b" where if f == Maybe i have some specific implementation, but otherwise I use something else?
16:19:01 <sveit> for example a faster implementation
16:19:35 <mniip> sveit, ghc-specific specialize pragma
16:20:07 <mniip> but then you are responsible if your "faster implementation" is not equivalent to the default one
16:20:34 <sveit> mniip: but if it is possible to narrow down f to Maybe the specialization is guaranteed to happen?
16:20:48 <johnw> sveit: will specialization let you substitute an alternate definition?
16:21:09 <johnw> I thought it just expanded the types for known likely use cases
16:24:59 <sveit> johnw: i think now they are just called "rewrite rules"
16:25:03 <sveit> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/rewrite-rules.html#rule-spec
16:25:28 <roboguy_> sveit: I think they mean SPECIALIZE
16:25:41 <roboguy_> oh, that does talk about SPECIALIZE
16:25:48 <roboguy_> nm =)
16:25:56 <sveit> roboguy_: according to the docs i linked to, that's called RULES now
16:26:00 <sveit> ah, slow typing
16:26:04 <johnw> what I mean is, I don't think there's any way to select a definition based on a type, unless you make a new type class
16:26:24 <roboguy_> oh, interesting. I didn't know they merged SPECIALIZE into RULES
16:26:40 <sveit> johnw: according to the docs, rewrite rules are supposed to provide this functionality
16:28:14 <sveit> is there a way to provide a lens that does "intelligent" bounds checking?
16:28:41 <sveit> i mean so that if the result could fail gracefully, it might check the bounds on an argument, but if it could not it doesn't?
16:29:01 <johnw> sveit: where do you see that?
16:29:06 <sveit> an example would be a lens for a list that takes an index; if the way the lens is used it could fail gracefully, it checks that it has a valid index, otherwise it does not
16:29:14 <sveit> i don't think this is possible, but just wondering
16:29:34 <sveit> johnw: you can replace one function by another using RULES
16:29:41 <sveit> johnw: as long as the types match
16:30:15 <johnw> ahh
16:30:16 <johnw> 7.23.6
16:30:18 <johnw> very cool
16:35:20 <kadoban> New version of 'stack' incoming, seems like? It's funny I see it in the ubuntu ppa before in git.
16:48:50 <ttt_fff> is there a way to specialize a generic typeclass impl? i.e. suppose I have "instance (Foo a) => (Bar a) where ... " for a generic a, but then I want a special implementation for "instance Bar Int" ... is that possible omsehow in haskell?
16:50:08 <roboguy_> ttt_fff: you can sometimes use overlapping instances
16:50:20 <ttt_fff> roboguy_: I heard using overlapping instances was bad
16:50:21 <pacak> ttt_fff: Don't do that.
16:50:22 <ttt_fff> is there a way to avoid taht
16:50:28 <roboguy_> but, usually you want to avoid that situation in the first place
16:50:40 <ttt_fff> pacak , roboguy_, 
16:50:41 <ttt_fff> round 1
16:50:41 <roboguy_> (You rarely want an instance like the first one you gave)
16:50:42 <ttt_fff> fight!
16:50:50 <roboguy_> Ha, we're agreeing
16:50:59 <ttt_fff> fuck
16:51:07 <pacak> roboguy_: cheers :)
16:51:10 <roboguy_> haha
16:53:59 <hodapp> https://github.com/haskell-lisp/yale-haskell well, that's the first time I've seen a git repo with revisions 22 years old
16:54:41 <johnw> the Emacs repo has that beat
16:55:11 <hpc> yeah, but they probably ran M-x forge-git-history
16:55:55 <hodapp> johnw: oh, of COURSE Emacs has to outdo that :P
16:57:20 <kadoban> Since git is only ~10 years old, any history older than that is forged in some way.
16:58:12 <exio4> imported repository, probably?
16:58:20 <pacak> kadoban: Since this museum is only 5 years old it surely can't contain stuff from ancient history.
16:59:16 <kadoban> pacak: It could be migrated of course, but it's not like someone commited it in git 22 years ago.
16:59:57 <mniip> [01:51:36] <hodapp> https://github.com/haskell-lisp/yale-haskell well, that's the first time I've seen a git repo with revisions 22 years old
17:00:09 <mniip> you can forge a commit to as early as about 1918
17:00:43 <hodapp> maybe my versions *are* from 1918
17:01:03 <mniip> correction: to as early as Dec 13, 1901
17:02:07 <kadoban> That's a rather funnily-arbitrary seeming date. Is that just where whatever they store unix-time-ish-value in underflows?
17:02:34 <hodapp> the Hugs source code MIXES TABS AND SPACES
17:02:36 <hodapp> AAARGH
17:03:20 <roboguy_> haha, really? wow
17:03:28 <roboguy_> does it do it in the good way?
17:03:40 <Rembane> Time for a pull request! :D
17:04:11 <hodapp> also, they use K&R style declarations, yikes
17:04:17 <johnw> someday, people will wonder why we used tab characters
17:04:34 <hpc> they already wonder
17:04:40 <johnw> ooh, an invisible characters that saves up to 7 bytes!
17:05:16 <hpc> think of the savings you can have with a vertical tab!
17:05:18 <roboguy_> well, the real argument for it is that you can set the tab width to your preference
17:05:27 <hodapp> looks like they use spaces for indenting 4, and they use tabs for 8, I think
17:05:35 <roboguy_> and if you mix tabs and spaces correctly, everything always lines up fine
17:06:02 <Rembane> It's like cheat codes for video games.
17:06:59 <roboguy_> hodapp: oh, well that's definitely bad
17:07:00 * mniip <3 hard tabs
17:07:17 * mniip </3 mixing tabs with spaces
17:07:29 <roboguy_> I personally don't like using tabs in Haskell, but I can see how, if you're careful, they could work out well
17:07:31 * mniip </3 code that depends on tabwidth
17:07:47 <mniip> roboguy_, that's how I write code, usually
17:08:11 <hodapp> roboguy_: this is C, not Haskell
17:08:20 <roboguy_> mniip: if you're careful about how you mix tabs and spaces, you can get nice alignment and always have it look the same on any tab width
17:08:28 <roboguy_> I believe dmwit uses that style, iirc
17:08:36 <mniip> the answer to that is to never mix tabs with spaces
17:08:44 <roboguy_> In fact, I think he has a blog post about it, hmm...
17:09:02 <roboguy_> ah, here http://dmwit.com/tabs/
17:09:27 <mniip> multi-clause guards should be separate from the definition, so that each of them begins with tabulation
17:10:11 <mniip> same goes for any other layout-driven code
17:10:43 <mniip> if you want to layout-vertically-align two lines, make both begin with tabulation
17:12:51 <roboguy_> I don't know, as I said I don't like it for my own code, but I feel like there is a pretty good argument for it
17:15:23 <saml_> hello, what do you call =>  in Num a => a
17:16:12 <roboguy_> Maybe 'double arrow'
17:16:22 <roboguy_> the thing to the left of => is called the constraints
17:17:29 <maerwald> "In general, we use cx to denote a context and we write cx => t to indicate the type t restricted by the context cx."
17:17:43 <maerwald> maybe something like "context constraint operator"?
17:18:15 <dramforever> I sometimes read it as "equals greater than" because it shows how it's written in code
17:18:20 * hackagebot sync-mht 0.3.6.0 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.6.0 (emink)
17:18:27 <dramforever> sometimes, yes "double arrow"
17:19:28 <Fylwind> ⇒
17:19:42 <pavonia> https://wiki.haskell.org/Pronunciation says "is a witness for, implies"
17:20:00 <roboguy_> I wonder if GHC could get away with making => first class by saying it's a type level function Constraint -> * -> *
17:20:19 <roboguy_> Probably not, since it introduces names
17:20:28 <arkeet> it does?
17:20:42 <arkeet> example?
17:20:44 <roboguy_> well, it doesn't introduce them, but it interacts with them
17:20:52 <roboguy_> Maybe it would work out ok
17:20:55 <arkeet> what doesn't interact with names?
17:20:58 <roboguy_> true
17:21:02 <mniip> it doesn't introduce names
17:21:07 <roboguy_> right
17:21:11 <mniip> implicit forall introduces type variables
17:21:20 <roboguy_> I wonder if there's anything preventing => from being first class then
17:21:48 <kclancy> tried out codex. not much luck getting it working. apparently it is trying to connect to some server and is unable to.
17:22:03 <mniip> roboguy_, qualified types aren't first-class in the type system
17:22:17 <mniip> you can't pass (F a => a) to a typeclass or type family
17:22:17 <kclancy> maybe I will get by just using hasktags
17:23:36 <kclancy> I can just run hasktags in a way that recursively traverses my project, so it doesn't seem like I need codex
17:26:50 <dramforever> :k (->)
17:26:51 <lambdabot> * -> * -> *
17:27:13 <roboguy_> mniip: I mean the => part itself, so that you could pass (=>)
17:27:21 <hpc> once upon a time that kind was much more terrible
17:27:28 <dramforever> yep
17:27:42 <maerwald> some day we will abstract out ourselves
17:27:43 <mniip> roboguy_, why
17:27:50 <roboguy_> mniip: idle curiousity
17:27:50 <dramforever> wait why it isn't the case anymore
17:28:09 <EvanR> roboguy_: its a ConstraintKind
17:28:23 <roboguy_> EvanR: Hmm, I don't think it is
17:28:24 <hpc> things shifted around during the ConstraintKinds introduction
17:28:24 <EvanR> rather stuff to the left is
17:28:26 <mniip> :k (,)
17:28:27 <lambdabot> * -> * -> *
17:28:28 <roboguy_> :k (=>)
17:28:29 <lambdabot> parse error on input ‘=>’
17:28:32 <hpc> don't remember the details but it solved a bunch of ugly warts
17:28:33 <roboguy_> yeah
17:28:34 <mniip> wait what why
17:28:52 <hpc> :k (#,#)
17:28:53 <lambdabot> OpenKind -> OpenKind -> #
17:29:18 <dramforever> hmm that was an interesting face
17:29:18 <Welkin> :k #
17:29:19 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
17:29:22 <Welkin> :k (#)
17:29:23 <lambdabot> parse error on input ‘)’
17:29:25 <hpc> they have better names now than ? and ??, and things are a bit more flexible
17:29:29 <mniip> OpenKind?
17:29:29 <dramforever> :k (##)
17:29:30 <lambdabot> #
17:29:43 <mniip> huh
17:29:50 <EvanR> roboguy_: so i guess => :: Constraint -> * -> *
17:29:50 <Welkin> what is with the hashes all over the place in base?
17:29:55 <dramforever> :t (#,#) -- is this possible?
17:29:57 <lambdabot> a -> b -> (# a, b #)
17:30:01 <dramforever> seems so
17:30:02 <hpc> Welkin: it's MagicHash
17:30:08 <Welkin> what does it do?
17:30:11 <mniip> or UnboxedTuples
17:30:19 <arkeet> (#,#) is the constructor for unboxed pairs.
17:30:23 <hpc> that extension makes '#' treated as a valid character in "word-like" identifiers
17:30:24 <mniip> Welkin, lets identifiers contain the symbol #, among other things
17:30:28 <hpc> and it's used as a convention for magic shit
17:30:29 <dramforever> EvanR: lemme see, doesn't that enable impredicative types?
17:30:37 <Welkin> I see types like #Int
17:30:38 <mniip> and most identifiers containing # are, yeah, magic shit
17:30:39 <EvanR> how
17:30:40 <hpc> and unboxed things usually
17:30:40 <maerwald> Welkin: it's a sign that you need to get terribly ugly in order to write efficient haskell code :P
17:31:00 <hpc> like
17:31:15 <hpc> you know how single-quote is the "things are stricter than normal" signal
17:31:28 <hpc> '#' is the "things are implementation detailier than normal" signal
17:31:45 <dramforever> "detailier" I like that
17:31:46 <mniip> '#' is "GHC voodoo fuckery is going on"
17:32:23 <EvanR> # stuff isnt even voodoo fuckery is it, it has sensible semantics
17:32:28 <EvanR> the types all work out
17:32:40 <maerwald> #typesWorkOut
17:32:40 <EvanR> still pure
17:32:43 <hpc> really though, the name MagicHash is all you really need to know
17:32:44 <mniip> well, GHC happens to have sensible semantics
17:33:00 <mniip> but they're driven by the implementation defined evaluation semantics
17:33:04 <maerwald> now people probably want to tell me that it's even pretty :P
17:33:05 <hpc> #hashtag-yolohaskell
17:33:06 <maerwald> or readable
17:33:07 <mniip> as opposed to report-defined semantics
17:33:27 <EvanR> unsafeYellOutYOLO
17:33:29 <maerwald> excuse everything with "it's still pure, you know" :P
17:33:39 <dramforever> pure
17:33:51 <EvanR> maerwald: well except unsafePerformIO
17:33:59 <mniip> EvanR, you forgot #
17:34:00 <maerwald> well yeah, GHC is not pure at all, but... pshhhh
17:34:00 <dramforever> realWorld#
17:34:57 <dramforever> *ghc haskell
17:34:58 <mniip> realWorld# has no data meaning
17:34:59 <dramforever> ftfy
17:35:13 <hpc> RealWorld# is a way to help you sleep better at night
17:35:15 <mniip> it's the undefined of unboxed State#
17:35:32 <maerwald> hpc: right, it's a huge white lie about IO
17:35:35 <hpc> it doesn't exist, doesn't contain side effects or enforce ordering or anything
17:35:35 <mniip> suddenly existential philosophy
17:35:45 <hpc> the dirty secret it hides is that ghc haskell is an impure language
17:35:46 <maerwald> but it still helps
17:35:52 <hpc> and the only window into tha crazy world is unsafe*
17:36:07 <mniip> hpc, how dare you say that
17:36:09 <mniip> lynch him
17:36:19 <maerwald> hpc: so what does that make with our "pure" programs if we shove them through an impure compile? ;)
17:36:30 <maerwald> *compiler
17:36:59 <Fay> hey what effect does {-# ??? #-} have?
17:36:59 <hpc> IO's generally followed convention of keeping it in the family is what maintains order
17:37:06 <Fay> ??? are placeholders lol
17:37:07 <hpc> Fay: it tells ghc what to do
17:37:09 <arkeet> Fay: that's called a pragma.
17:37:21 <mniip> Fay, depends on the ???
17:37:21 <Fay> preprocessor instructions?
17:37:26 <hpc> somewhat
17:37:28 <mniip> Fay, no, a pragma
17:37:29 <arkeet> no
17:37:37 <arkeet> it tells the compiler something.
17:37:40 <arkeet> what it means depends on the ???
17:37:46 <mniip> it can drastically affect the behavior of GHC
17:37:51 <dramforever> Fay: maybe compiler instructions instead
17:37:53 <mniip> so again, what are ??? in your case
17:37:57 <arkeet> https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html
17:37:58 <hpc> they generally go {-# GHCDOTHISTHING ThingsToDo #-}
17:38:03 <ski> maerwald : the "purity" exists at the level of the language
17:38:15 <dramforever> maybe Fay just saw a lot of them
17:38:27 <maerwald> ski: yeah, it's just a pipe dream =D
17:38:30 <dramforever> and ignored them because they look like comments
17:38:31 <EvanR> no such thing realWorld
17:38:48 <EvanR> were only holograms
17:38:49 <ski> maerwald : i'm not sure i agree :)
17:38:51 <Fay> so {-# INLINE [1] pack #-}
17:39:02 <maerwald> ski: me neither, but I have a weird feeling about it
17:39:06 <mniip> that tells GHC to inline 'pack' during stage 1
17:39:16 <hpc> maerwald: what holds the whole thing together is that IO is a damn good idea, so it gets followed universally
17:39:21 <hpc> maerwald: and thus no leaks
17:39:23 <arkeet> Fay: see my link, look for INLINE pragmas
17:39:27 <Fay> erm no heres a better example {-# INLINE head #-}
17:39:34 <arkeet> 7.22.6
17:39:54 <Fay> arkeet: will do thanks
17:39:56 <ski> maerwald : imho, the important point here is in what ways you can reason, at the level of the language
17:39:56 <mniip> Fay, that tells GHC to inline 'head'
17:40:05 <hpc> maerwald: but the impurity is convenient because it makes unsafePerformIO possible to define, and is very convenient for efficiency
17:40:36 <EvanR> and for breaking referential transparency
17:40:41 <hpc> plus opening up weird tricks like you'll find in bytestring/text manipulation
17:40:47 <hpc> and for breaking referential transparency
17:40:48 <maerwald> I want functional hardware again
17:40:49 <hpc> but don't do that
17:41:00 <hpc> or do
17:41:16 <hpc> all magic has a price, according to that dude on that ABC show
17:41:23 <mniip> Fay, a similar construct in C is called 'inline'
17:41:33 <EvanR> would be cool if ghc could detect you broke RT and caused spectacular fireworks
17:41:44 <EvanR> at runtime
17:41:46 <Fay> oh i understand inline in C 
17:42:28 <dramforever> EvanR: where should it be displayed?
17:42:51 <mniip> Fay, in GHC {-# INLINE #-} has a similar meaning
17:42:57 <Fay> okay cool
17:42:57 <EvanR> dramforever: above the mantle
17:43:11 <Fay> arkeet: thankyou for the link, very informative
17:43:13 <dramforever> okay then
17:43:16 <mniip> it is more strict though, it *always* inlines, unless it cannot due to a recursion loop
17:43:16 <dramforever> looks goo
17:43:18 <dramforever> good
17:43:31 <mniip> something like __attribute__((always_inline))
17:43:44 <mniip> which is a better example because it is compiler-specific too
17:48:22 * hackagebot stack 0.1.3.0 - The Haskell Tool Stack  https://hackage.haskell.org/package/stack-0.1.3.0 (borsboom)
17:48:24 * hackagebot pipes-aeson 0.4.1.4 - Encode and decode JSON streams using Aeson and Pipes.  https://hackage.haskell.org/package/pipes-aeson-0.4.1.4 (RenzoCarbonara)
18:17:16 <hackrilege> im having difficulty settting up haskell-mpi, I was wondering if there were any alternative ways of passing information between threads both blocking and nonblocking?
18:17:44 <dramforever> what about those MVar or TVar stuff?
18:17:50 <dramforever> also TQueue
18:18:47 <dramforever> hackrilege: ^
18:18:57 <hackrilege> thanks!
18:19:01 <dramforever> yw
18:19:05 <hackrilege> Concurrent
18:19:10 <dramforever> yep
18:19:23 <nshepperd> -XFireworksOutsideYourWindow
18:20:04 <hackrilege> know of any simple examples like a factorial?
18:20:23 <hackrilege> or common functions such as sendToAll or Gather?
18:20:25 <dramforever> how is that related to threads?
18:20:44 <hackrilege> dramforever, im thinking of MPI
18:21:12 * dramforever google mpi
18:22:02 <dramforever> hmm...that doesn't seem suitable for  concurrency at all
18:22:11 <dramforever> it's for parallelism
18:22:27 <hackrilege> i thought you were asking what a factorial with mpi style call had to do with threads
18:22:45 * dramforever doesn't know what mpi is
18:22:57 <hackrilege> i thought nonblocking and blocking thread communication was parallelism
18:23:07 <dramforever> hackrilege: do you want to, say, make factorial run faster by running it on multiple threads?
18:23:10 <hackrilege> message parsing interface
18:23:23 <hackrilege> exposes functions such as sendToAll
18:23:57 <dramforever> hackrilege: what are you trying to do with factorial?
18:23:57 <hackrilege> dramforever, I have some code that I need to write in paralell, im trying to find the suitable tool
18:24:04 <dramforever> Parallel!
18:24:09 <dramforever> yes, lemme check
18:24:11 <hackrilege> make an example of mpi like communication
18:24:18 <dramforever> that doesn't make sense
18:24:20 <hackrilege> parallel*
18:24:28 <dramforever> https://wiki.haskell.org/Parallelism
18:24:35 <mniip> computing a factorial in parallel!
18:24:37 <mniip> nice
18:24:54 <hackrilege> i have seen these routs
18:25:09 <hackrilege> mniip its kind of a standard
18:25:27 <dramforever> dunno, but we do parallelism in haskell like this: http://hackage.haskell.org/package/parallel
18:25:56 <dramforever> wait where did the par monad go?
18:26:05 <mniip> what exactly do you parallelize?
18:26:13 <hackrilege> polymer growth
18:26:23 <mniip> do you compute a merkle root of the multiplication tree?
18:26:37 <roboguy_> yeah, I'm not sure that factorial would be very easy to parallelize
18:26:55 <dramforever> roboguy_: maybe not
18:27:10 <EvanR> first parallelize factorization
18:27:11 <mniip> roboguy_, I think I know what the guy is talking about
18:27:24 <roboguy_> something like dot product would be a bit easier
18:27:48 <dramforever> @let fact a b = if a == b then a else fact a ((a + b) `div` 2) * fact ((a + b) `div` 2 + 1) b
18:27:49 <lambdabot>  Defined.
18:27:52 <dramforever> > fact 50
18:27:54 <lambdabot>  <Integer -> Integer>
18:27:57 <dramforever> sigh...
18:28:02 <mniip> imagine that instead of foldr multiplication you do a binary tree kind of thing
18:28:08 <dramforever> > fact 1 50
18:28:09 <lambdabot>  30414093201713378043612608166064768844377641568960512000000000000
18:28:17 <dramforever> doesn't look bad
18:28:17 <mniip> then suddenly you have multiplications that can be computed in parallel
18:28:24 * hackagebot diplomacy 0.1.0.0 - The board game Diplomacy, spoken in Haskell  https://hackage.haskell.org/package/diplomacy-0.1.0.0 (alexvieth)
18:28:32 <dramforever> mniip: like that fact function??
18:28:49 <mniip> the induction is exactly what I had in mind
18:28:51 <dramforever> > product [1..50] -- wait lemme check for sure
18:28:52 <lambdabot>  30414093201713378043612608166064768844377641568960512000000000000
18:28:57 <mniip> however the implementation would obviously different
18:28:58 <dramforever> perfect
18:29:08 <dramforever> mniip: well?
18:29:11 <mniip> +be
18:29:24 <dramforever> oh sure you add parallelism
18:30:15 <dramforever> > map ((+1) . (*10)) [0, 4] -- like this maybe
18:30:16 <lambdabot>      Ambiguous occurrence ‘map’
18:30:17 <lambdabot>      It could refer to either ‘L.map’, defined at L.hs:151:1
18:30:17 <lambdabot>                            or ‘Data.List.map’,
18:30:21 <dramforever> sigh...
18:30:23 <dramforever> @undefine
18:30:23 <lambdabot> Undefined.
18:31:17 <dramforever> mniip: so something like computing, say, product of 1 to 100, 101 to 200, 201 to 300 in parallel?
18:31:23 <roboguy_> hmm
18:32:23 <mniip> dramforever, more or less
18:32:27 <dramforever> =)
18:32:30 <EvanR> in a way that doesnt cost more to get the results back from the parallel processors 
18:32:34 <mniip> I think interspersed would be better
18:32:39 <roboguy_> @let crazy :: (a -> b) -> Int; crazy f = length $ show f
18:32:39 <lambdabot>  .L.hs:150:20:
18:32:40 <lambdabot>      No instance for (Typeable a) arising from a use of ‘show’
18:32:40 <lambdabot>      In the second argument of ‘($)’, namely ‘show f’
18:32:41 <TimWolla> I am currently writing an AttoParsec parser that needs to match the first occurance of a specific sequence inside an arbitrary text (i.e. there are arbitrary leading and trailing characters). After trying a lot I have come up with this: http://lpaste.net/6186083920899997696. It seems to parse everything correctly. I'd like some feedback, whether there is a more canonical / better solution for this. And I'd also like to know whether 
18:32:42 <TimWolla> I can parse into a ByteString instead of a [Word8].
18:32:55 <roboguy_> @let crazy :: (Typeable a, Typeable b) => (a -> b) -> Int; crazy f = length $ show f
18:32:56 <lambdabot>  Defined.
18:33:21 <roboguy_> > crazy (succ :: Int -> Int)
18:33:22 <lambdabot>  12
18:33:23 <EvanR> dont modern computers have huge parallel ALUs on each core, can you access those somehow
18:33:23 <TimWolla> (I probably could clean up the Imports a bit, they were taken from the HTTP example of AttoParsec)
18:33:30 <mniip> > crazy crazy
18:33:31 <lambdabot>      No instance for (Typeable a0) arising from a use of ‘crazy’
18:33:31 <lambdabot>      In the expression: crazy crazy
18:33:35 <mniip> crap
18:33:36 <roboguy_> ha
18:33:48 <dramforever> TimWolla: just a suggestion: attoparsec isn't well suited for that
18:33:53 <dramforever> regexes are
18:33:53 <EvanR> its already computing multiple instructions in parallel, why not use it to compute what you want
18:34:11 <TimWolla> dramforever, that suggestion is fine as well.
18:34:34 <dramforever> TimWolla: attoparsec is just a simple backtracking parser
18:34:46 <mniip> >simple
18:34:48 <dramforever> IIRC, a regex parser, on the other hand, doesn't backtrack at all
18:34:58 <EvanR> *simple regex paraser
18:34:58 <mniip> dramforever, regex does backtrack very well
18:35:05 <dramforever> oh
18:35:11 <dramforever> oh sorry
18:35:13 <EvanR> programming language regex not so much
18:35:19 <mniip> backtracking is pretty much required to parse regular languages
18:35:27 <mniip> kleenee star in particular
18:35:28 <dramforever> anyway regex is still well suited for that
18:35:31 <dramforever> =)
18:35:42 <TimWolla> I never saw anyone using regular expressions in Haskell.
18:35:54 <TimWolla> In any other language I probably would have used a regex.
18:35:58 <EvanR> they are the hated unclean
18:36:09 <dramforever> real world haskell has a chapter on that IIRC
18:36:40 <dramforever> http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html#glob.regex
18:36:52 <sveit> prisms (from lens) seem to be the way to combine a function (a -> b) and (b -> Maybe a). is there a similar pattern for (a -> Maybe b) and (b -> Maybe a)?
18:36:58 <EvanR> mniip: you dont need a stack though, so its like you have to backtrack arbitrarily far
18:37:04 <sveit> i.e. where you only have partial inverses both ways?
18:37:08 <EvanR> its not like
18:37:23 <TimWolla> So it's best to just scrap AttoParsec for that one?
18:37:34 <mniip> EvanR, elaborate?
18:37:35 <dramforever> sveit: maybe just a prism from a to Maybe b?
18:37:43 <dramforever> sveit: screw it that's nonsense
18:37:52 <mniip> sveit, >=>
18:37:56 <EvanR> mniip: you dont need arbitrary space to match a starred regex
18:38:14 <dramforever> mniip: no read sveit's question again
18:38:36 <mniip> do they desperately want something within lens or?
18:38:39 <dramforever> EvanR: but you still need to backtrack somehow
18:38:46 <sveit> mniip: not necessarily within lens
18:38:47 <mniip> EvanR, yes, you only need as much space as there are *s
18:39:03 <dramforever> sveit: on a second thought, it looks like a Prism A (Maybe B) is enough
18:39:06 <dramforever> but it's crap
18:39:15 <EvanR> dramforever: backtrack, next state, whatever
18:39:18 <sveit> i just want to make sure there's not an existing, well-known abstraction before I try to scrap together my own
18:39:18 <mniip> and the execution time is superexponential
18:39:25 <dramforever> EvanR: same thing
18:39:42 <sveit> dramforever: could you elaborate?
18:39:47 <EvanR> you dont need to keep a stack of things to back track too like a strict language
18:40:13 <dramforever> oh that is not right , but why don't you change that to (a -> Maybe b) and (Maybe b -> Maybe a)?
18:40:21 <dramforever> forget about it still nonsense
18:40:36 <EvanR> Maybe b -> Maybe a is interesting
18:40:47 <dramforever> sveit: still nonsense just ignore all those
18:40:59 <mniip> EvanR, (((...c)*b)*a)*
18:41:13 <roboguy_> sveit: you could probably get a more definite answer in #haskell-lens
18:41:21 <sveit> i'll head there now :) thanks
18:41:22 <dramforever> sure
18:41:29 * dramforever /j #haskell-lenns
18:41:31 <dramforever> *lens
18:41:40 <mniip> you're going to have to mark as many backtracking "stack frames" as there are staaaaaaaaaaaaaaaaaaaaaars
18:41:46 <mniip> goddamnit keyboard
18:41:47 <mniip> stars*
18:42:01 <EvanR> mniip: an infinitely nested regex?
18:42:13 <mniip> no
18:42:19 <mniip> an arbitrarily nested regex
18:42:21 <dramforever> EvanR: try this ^a**$
18:42:31 <mniip> you're going to need O(N) space for N stars
18:42:35 <dramforever> match that against aaaaaaaaaaaaaaaaaa
18:42:43 <dramforever> wait I mean aaaaaaaaaaaaaaaaaab
18:43:20 <EvanR> done with backtracking
18:43:29 <dramforever> forget about it
18:43:35 <Ptival> would anyone know why, on one of my computers, I get an error about Alex not being an instance of Applicative, when the installed version of alex is 3.1.4 which should have the instance...?
18:43:50 <mniip> dramforever, we're talking about memory, not time here
18:44:12 <dramforever> mniip: no I got screwed up I thought it's going to take up a huge crap of memory
18:44:27 <EvanR> almost a gigacrap
18:44:39 <mniip> 1.21 gigacraps
18:45:16 <EvanR> youre thinking of the pathological performance of perl regex
18:45:27 <EvanR> because of back references
18:46:37 <mniip> EvanR, it's not about backreferences
18:46:49 <mniip> it's about having to iterate through all partitions of the string
18:48:39 <EvanR> uh wouldnt it greedly match a* then then later match zero as for the next *
18:50:28 <mniip> EvanR, and then it will backtrack
18:50:34 <mniip> because 'b' is not $
18:51:01 <EvanR> no it would fail
18:51:05 <mniip> no?
18:51:21 <EvanR> regex match is a single pass
18:51:22 <mniip> the inner 'a*' will match one character less, and then the outer * will be able to add one more 'a*'
18:51:26 <mniip> what
18:51:29 <mniip> of course not
18:51:42 <dramforever> :t (~=)
18:51:43 <lambdabot>     Not in scope: ‘~=’
18:51:43 <lambdabot>     Perhaps you meant one of these:
18:51:43 <lambdabot>       ‘/=’ (imported from Data.Eq), ‘<=’ (imported from Data.Ord),
18:51:53 <mniip> dramforever, =~~
18:51:56 <mniip> ugh, =~
18:52:08 <dramforever> :t (=~) -- weird type expected 
18:52:10 <lambdabot>     Not in scope: ‘=~’
18:52:10 <lambdabot>     Perhaps you meant one of these:
18:52:10 <lambdabot>       ‘==’ (imported from Data.Eq), ‘#~’ (imported from Control.Lens),
18:52:22 <mniip> I assumed you are talking about perl :)
18:52:39 * dramforever is only wandering around
18:57:32 <EvanR> SOO...
18:58:05 <EvanR> "aaaaaaaaaaaaaaaaaaab" =~ /^a**$/ finishes instantly, but /^(a*)*$/ does indeed seems to take a friggin long time
18:58:27 <EvanR> so i think the capture is causing it to use a backtracking implementation which has that problem
18:58:36 <EvanR> you dont need backtracking
18:58:39 <mniip> try ?:
18:58:44 <dramforever> yes that's the problem I described
18:58:48 <mniip> ^(?:a*)*$
18:59:10 <EvanR> instant
18:59:16 <EvanR> whats ?:
18:59:39 <mniip> parentheses without the burden of creating a capture
18:59:45 <EvanR> sweetttt
18:59:49 <EvanR> things i wish i knew
19:00:13 <EvanR> back to haskell where regex is the red-headed stepchild
19:00:44 <Enigmagic> you have your choice of 50 different regex libraries :p
19:00:49 <mniip> but wait, there's more!
19:01:19 <scshunt> hey all
19:01:25 <scshunt> let's say I have a monad transformer t
19:01:31 <scshunt> and a function m a -> n b
19:01:43 <scshunt> how do I get from t m a -> t n b ?
19:01:44 <dramforever> that's called hoist
19:01:44 <mniip> ?! ?=  ?<! ?<=
19:01:44 <lambdabot> Maybe you meant: v @ ? .
19:01:49 <EvanR> whats n ?
19:01:55 <dramforever> scshunt: that's called hoist
19:01:56 <EvanR> a different monad
19:01:58 <dramforever> :t hoist
19:01:59 <lambdabot> Not in scope: ‘hoist’
19:02:03 <scshunt> excellent, thanks
19:02:09 <dramforever> scshunt: just search for it
19:02:23 <scshunt> from Control.Monad.Morph?
19:02:26 <roboguy_> @hoogle hoist
19:02:27 <lambdabot> package hoist-error
19:02:41 <dramforever> scshunt: is your m a -> n a a monad morphism?
19:02:52 <dramforever> i.e. does it preserve return and (>>=)?
19:02:54 <EvanR> for Monad m n, forall a b . m a -> n b doesnt seem possible
19:03:57 <roboguy_> scshunt: so a might not equal b?
19:04:03 <scshunt> uh, let me think
19:04:14 <scshunt> yeah, in this case a ~ b
19:04:19 <TimWolla> This looks just painful, I am probably doing it wrong: let (_, _, _, (token:_)) = body =~ ("var SECURITY_TOKEN = '([a-f0-9]{40})';" :: ByteString) :: (ByteString, ByteString, ByteString, [ByteString])
19:04:29 <scshunt> ... ugh
19:04:31 <dramforever> scshunt: does it preserve  return and (>>=)?
19:04:34 <scshunt> I knot the error I'm about to hit
19:04:36 <scshunt> dramforever: pretty sure
19:04:41 <scshunt> it's a run method of a transformer
19:04:45 <dramforever> okay then
19:05:01 <mniip> TimWolla, kill it with fire
19:05:10 <EvanR> TimWolla: ... use attoparsec
19:05:28 <TimWolla> Before I was told to use Regex :(
19:05:33 <EvanR> were you?
19:05:44 <dramforever> sorry I did that
19:05:50 <scshunt> I'm not trying to anything evil here
19:05:51 <scshunt> for once
19:05:54 <roboguy_> if you're parsing something with that much structure, I wouldn't suggest regexes
19:05:57 * EvanR waves hand in front of TimWolla "You weren't"
19:06:07 <pacak> TimWolla: You had a problem and decided to use regex. Now you have two problems.
19:06:27 <dramforever> TimWolla: sorry I thought it was something simplere
19:06:30 <dramforever> *simpler
19:06:32 <mniip> TimWolla, who of these people told you to use regex
19:06:43 <dramforever> wait that doesn't look bad
19:07:07 <TimWolla> mniip, dramforever did. Scroll up do 03:32:19 (about 30 minutes before)
19:07:08 <EvanR> which witch is witch
19:07:12 <dramforever> sigh
19:07:19 <TimWolla> I even tried to use attoparsec and wanted some feedback.
19:07:46 <dramforever> TimWolla: I'm pretty sure you are using the wrong return type
19:08:06 <mniip> TimWolla, show on this teddy bear where did he touch you
19:08:21 <roboguy_> TimWolla: what language are you parsing?
19:08:31 <pacak> TimWolla: these aren't the droids you're looking for.
19:08:36 <TimWolla> roboguy_, that's a bit of JavaScript.
19:08:40 <roboguy_> ahh
19:08:57 <roboguy_> I bet there's a JS parsing library
19:09:04 <TimWolla> Nah.
19:09:13 <TimWolla> It's really just that specific item.
19:09:13 <pacak> TimWolla:  (P.skip (const True) *> securityToken) ------> P.anyChar *> securityToken
19:09:19 <roboguy_> oh, hmm
19:09:45 <dramforever> TimWolla: just change the whole return type to ByteString
19:09:57 <pacak> TimWolla: And if you want to tokenize it first - you can also check parsec.
19:10:20 <dramforever> wait it won't work sorry
19:11:08 <mniip> petition to rename the 'RegexMaker' and 'RegexContext' typeclasses into 'WhyOnEarth' and 'YouShouldFeelBad' respectively
19:11:54 <TimWolla> pacak, the parser worked like that. My two questions basically just were: Is that recursion sane or will it blow up in my face and can I get a ByteString instead of a [Char8] out of that.
19:12:09 <TimWolla> Your anyChar suggestion is sane, thanks.
19:12:55 <EvanR> if anything you can pack a [Char8] into a ByteString
19:13:07 <geekosaur> er, what's a [Char8]?
19:13:07 <EvanR> but you should be able to get away with having the original
19:13:22 <pacak> TimWolla: You can get a ByteString if you use P.takeWhile
19:13:32 <mniip> geekosaur, singly linked list of bytes
19:13:44 <mniip> where bytes = octets
19:13:47 <geekosaur> did you mean [Word8]?
19:13:47 <EvanR> Char8 is actually Char
19:13:50 <pacak> Recursion is more or less sane.
19:13:58 <TimWolla> geekosaur, oh,  I did.
19:14:10 <geekosaur> because there is no Char8 that I'm aware of, onbly a heinous hack that ignores the fact that [Char] is a codepoint
19:14:12 <EvanR> Data.ByteString.Char8
19:14:21 <dramforever> TimWolla: wait why do you think that is insane?
19:14:27 <mniip> EvanR, that's module name
19:14:32 <mniip> not qual tycon name
19:14:46 <dramforever> also tada http://hackage.haskell.org/package/regex-applicative-0.3.2
19:14:53 <TimWolla> dramforever, because I have no experience with attoparsec and want to be extra sure.
19:14:58 <geekosaur> ought to be renamed Data.ByteString.TruncatedChar
19:15:00 <dramforever> ok then
19:15:02 <EvanR> its an unsupported dependent type ;)
19:15:17 <dramforever> TimWolla: I thought that expression was pretty good
19:15:32 <geekosaur> better, Data.ByteString.HeinousTruncatedChar
19:15:52 <mniip> geekosaur, Data.ByteString.UnsafelyInterpretingCharAsWord8
19:16:08 <EvanR> (c : Char, ord c < 256)
19:16:35 <TimWolla> <pacak> TimWolla: You can get a ByteString if you use P.takeWhile <- Can I combine that with the 'count 40'? The count 40 previously was a takeWhile
19:16:59 <EvanR> P.take 40
19:17:03 <mniip> EvanR, Coeither!
19:17:26 <mniip> (subtraction types)
19:17:27 <dramforever> TimWolla: also look here for a nicer interface: http://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html#t:MatchResult
19:17:44 <dramforever> let token = head . mrSubList $ body =~ "..."
19:18:26 <ski> mniip ?
19:18:26 * hackagebot semigroupoids 5.0.0.3 - Semigroupoids: Category sans id  https://hackage.haskell.org/package/semigroupoids-5.0.0.3 (EdwardKmett)
19:19:37 <pacak> TimWolla: you can still use takeWhile and then check resulting length. Or you can use take and check if it satisfies.
19:20:09 <taktoa> is it possible to recover some or all of the functionality of GADTs using RankNTypes + Haskell 2010
19:20:36 <dramforever> taktoa: no, but add type families and it's possible to recover all functionality
19:20:46 <dramforever> consider this: data Eq a b where Refl :: Eq a a
19:20:57 <taktoa> I'm writing some Frege (which only really supports H2010 + RankNTypes) and it would be really nice to have something like GADTs
19:20:59 <dramforever> there's no way to do that with RNT + Haskell2010
19:21:00 <roboguy_> dramforever: wouldn't you need a Char singleton too?
19:21:14 <ski> taktoa : you need equality constraints
19:21:20 <dramforever> oh maybe but that's hardly GADT specific
19:21:24 <dramforever> oh exactly
19:21:27 <dramforever> equality constraints
19:21:42 <taktoa> ah, alright. thanks
19:21:56 <roboguy_> oh, oops misread the conversation
19:23:16 <roboguy_> the irony of that is that Gottlob Frege (the guy the language is named after) gave a fairly famous discussion of equality
19:23:31 <roboguy_> iirc
19:24:04 <TimWolla> pacak, just checked. That anyChar suggestion does not work. There only is an anyChar in Data.Attoparsec.Char8 which is probably not what I am searching. At least based on the reactions to Char8 by the others.
19:24:26 <pacak> TimWolla: anyWord8
19:24:39 <pacak> Both will do the job.
19:24:59 <pacak> You can even use P.take 1 *> blah
19:25:02 <EvanR> Word8 is less wrong but still not exactly right, since we have no common support for Ascii
19:26:00 <EvanR> seat of your pants byte munging
19:26:37 <ski> roboguy_ : do you remember in which work ?
19:27:12 <pacak> TimWolla: Difference between Data.Attoparsec and Data.Attoparsec.Char8 is only in what results you get - either Word8 or Char.
19:27:52 <TimWolla> Okay, take 1 does the trick, thanks.
19:28:41 <roboguy_> ski: hmm, maybe "Sense and Denotation"
19:28:56 <roboguy_> ski: the specific thing I'm thinking of is the "morning star vs evening star" thing
19:29:07 <ski> hm, wasn't that Quine ?
19:30:34 <roboguy_> ski: I think it was Frege. Robert Harper mentions it in one of his (very interesting and free) lectures on homotopy type theory
19:30:39 <ski> hm, no. i'm mixing it up with something other
19:31:01 <roboguy_> which, incidentally, a lot of HoTT is about the nature of equality
19:31:02 <ski> (apparently Quine's "Word and Object")
19:31:15 <EvanR> is HoTT worth studying?
19:31:20 * ski thinks so
19:31:31 <EvanR> are there practical applications
19:31:40 <roboguy_> EvanR: I hardly understand it so far, so I might not be the right person to ask, but I've found it interesting
19:31:56 <roboguy_> there are supposed to be practical applications, but I don't fully understand the implications
19:32:25 <roboguy_> something about isomorphic structures being able to (somehow) be treated as identical, I *think* (which would be useful, if that's the case)
19:32:31 <ski> yes
19:32:58 <EvanR> so undoing the work previously done to show things arent the same but are isomorphic
19:34:11 <roboguy_> EvanR: I don't think it's really undoing that. Usually, when we talk about isomorphic things, a lot of the operations we discuss respect the isomorphism so we have to say "up to isomorphism" everywhere. With univalence, we don't need to have the disclaimer since isomorphism is equality and *everything* respects equality
19:34:15 <ski> roboguy_ : lectures on a blog ?
19:34:23 <roboguy_> ski: I'll find it, just a sec
19:34:49 <roboguy_> ski: here they are https://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx?#folderID="07756bb0-b872-4a4a-95b1-b77ad206dab3"
19:35:04 <roboguy_> It's nice, because it's the complete series of lectures from a course on HoTT
19:35:18 <ski> EvanR : the idea is roughly of widening the meaning of "equality" to encompass isomorphism
19:35:41 <roboguy_> unfortunately, I feel like most of HoTT hasn't fully clicked for me yet
19:36:25 <EvanR> so a quotient of normal math objects
19:37:27 <ski> we allow an object to be equal to itself in more than one way (the usual trivial way)
19:38:01 <roboguy_> EvanR: this is the univalence axiom (equality is equivalent to equivalence): https://upload.wikimedia.org/math/3/d/4/3d47502d552881a058a5341a5eefe417.png
19:38:04 <ski> just a quotient by isomorphism, in the usual world, wouldn't give this
19:39:37 <EvanR> equality is equivalent to equivalence
19:39:38 <EvanR> got it
19:39:45 <EvanR> lol
19:40:56 <EvanR> ski: what is the point of these other ways?
19:41:03 <roboguy_> traditionally, the only way that something can be equal to itself is reflexivity (like the Haskell equality type, data Equal a where Refl :: Equal a a). HoTT allows for more ways than that. I think the simplest example is the circle type
19:41:48 <EvanR> reflexive, symmetric, and transitive
19:45:28 <ski> EvanR : being able to "translate" something along an isomorphism, afaiui
19:46:30 <dolio> For programming it's more obvious why you'd want there to be one equivalence between two types instead of zero, than for there to be two (or more) instead of one.
19:46:38 <lpaste_> TimWolla pasted “No title” at http://lpaste.net/1330172343896506368
19:46:45 <Cale> Yeah, univalence says that for types X and Y (in some particular universe), the type X = Y is equivalent to the type Equiv X Y, which is more or less the type of isomorphisms between X and Y.
19:46:48 <TimWolla> I finally went with this.
19:46:54 <TimWolla> Thanks for your help, y'all
19:46:55 <ski> and so that the functions and properties you can express in the system automatically respect isomorphism
19:47:44 <roboguy_> Cale: so it is saying something like there's an isomorphism between those two types?
19:47:51 <Cale> So for instance, Bool = Bool will have an element corresponding to the identity, and one which swaps True and False.
19:47:54 <roboguy_> (at least one)
19:48:06 <dramforever> lemme see
19:49:04 <roboguy_> actually, I guess it could be an empty type, maybe
19:49:55 <Cale> roboguy_: Which?
19:49:55 <ski> `() = Bool' will be empty
19:50:05 <Cale> Yeah
19:50:47 <roboguy_> Cale: oh, I was just wondering if UA is saying something like there is at least one isomorphism between X = Y and Equiv X Y, but then I remembered that it's more like Equiv (X = Y) (Equiv X Y). So maybe that could be an empty type
19:51:25 <dfeuer> If I eat Cale’s brain, will I get some of his knowledge?
19:51:40 <dramforever> no I suppose
19:51:43 <dolio> Univalence says that 'Equiv (X = Y) (Equiv X Y)' is not empty.
19:51:46 <dfeuer> Oh well.
19:51:50 <dolio> Because it is a term of that type.
19:52:24 <roboguy_> dolio: oh, of course. I forgot that part
19:52:43 <dolio> X = Y and Equiv X Y could be empty, though.
19:52:49 <dolio> Depending on X and Y.
19:52:52 <Cale> roboguy_: Actually it says something more refined still, it says that the obvious map (X = Y) -> Equiv X Y is an equivalence, which means that it has an inverse
19:53:18 <roboguy_> Cale: hmm, what about *constructing* that inverse?
19:53:43 <Cale> roboguy_: Well, univalence is an axiom in terms of MLTT, so you don't get a construction
19:53:54 <roboguy_> ah, yeah
19:54:20 <roboguy_> Cale: is that the issue that people refer to when that talk about the problem of making a computational interpretation of UA though?
19:54:24 <Cale> But in some other type theories, univalence becomes a theorem, and you can actually compute with it
19:54:29 <Cale> yeah
19:54:44 <roboguy_> rumor is that they found a way though?
19:54:58 <dolio> Maybe.
19:55:05 <Cale> https://github.com/mortberg/cubicaltt
19:55:09 <roboguy_> which may or may not involve cubical sets
19:55:12 <roboguy_> yeah, hmm
19:55:34 <roboguy_> it would probably help if I knew what a cubical (or simplical) set is, haha
19:55:41 <EvanR> Cale: to clarify whats the diff between X = Y and Equiv X Y
19:55:42 <Cale> also https://github.com/simhu/cubical
19:56:36 * ski . o O ( "Canonicity for 2-Dimensional Type Theory" by Daniel Licata,Robert Harper in 2013 at <http://dlicata.web.wesleyan.edu/pubs.html> )
19:56:54 <Cale> X = Y is notation for the identity type Id U X Y, which is defined with a single constructor refl such that for each X, we have refl X : Id U X X
19:57:18 <Cale> Equiv X Y has a more complicated definition, I suppose I can go over it
19:58:07 <EvanR> you said the type of isomorphisms
19:58:13 <EvanR> i was just checking which one was which
19:58:29 <dolio> Equiv is a type of functions with inverses up to identity.
19:58:39 <dolio> That's one way of saying it.
20:00:31 <EvanR> what does up to identity mean there
20:00:50 <nitrix> Can I split a very long expression to multiple lines, even a ridiculously long Integer?
20:00:58 <dolio> It means you have proof of Id A (f (g x)) x and so on.
20:01:29 <roboguy_> nitrix: you mean a long literal?
20:01:38 <dramforever> nitrix: you can split an expression with many subexpressions to multiple lines
20:01:43 <nitrix> roboguy_: Correct, it's an integer literal of type Integer.
20:01:49 <dolio> But since the whole point is that Id is no longer necessarily 'equality' per se, that's not exactly the typical definition of 'isomorphism.'
20:02:09 <roboguy_> nitrix: I don't think that's possible. It's possible with Strings, but I don't think it is with numeric literals
20:02:37 <dolio> There's no other way you could specify it, of course.
20:02:37 <nitrix> roboguy_: How would you do it with strings then? It's being converted to a string anyway by me to work with the digits.
20:02:37 <roboguy_> dolio: is that about where the infinity groupoid stuff comes in?
20:02:42 <EvanR> isnt isomorphism fg = id and gf = id
20:02:59 <nitrix> roboguy_: Simple concatenation ?
20:03:06 <roboguy_> EvanR: the trick bit in this context is, what do you mean by "="?
20:03:13 <Cale> There's also the distinction between Id (A -> B) f g and Pi (x:A), Id B (f x) (g x).
20:03:34 <roboguy_> nitrix: http://stackoverflow.com/questions/22918837/how-can-i-write-a-multiline-strings-in-haskell
20:03:55 <EvanR> roboguy_: i assume that i can distinguish the elements of a category, and what element composing gives me
20:04:51 <dolio> EvanR: The point is that there is no "=" unless you talk about the computational, syntactic equality. But that is not a type.
20:05:29 <dolio> So you cannot specify that things are "=". You can only specify that they are identical, i.e. that the type Id A x y has a proof.
20:05:41 <EvanR> sure ok
20:05:46 <dolio> But Id is now equivalence up to equivalence up to ....
20:06:21 <EvanR> so this way the identity situation has gotten worse
20:06:40 <dolio> Why is it worse?
20:06:48 <roboguy_> EvanR: well, it's gotten a richer, infinite structure
20:07:34 <dolio> You cannot specify that things are equal in ordinary Martin-löf type theory, either. Because the models of MLTT+univalence are (obviously?) models of just MLTT.
20:08:06 <dolio> So you may have been thinking of the identity type as meaning equality, but the theory is not really strong enough to nail that down.
20:08:14 <EvanR> I am still thinking equal means X = Y
20:09:41 <EvanR> or that each element of the category has a ID painted on it... where ID is from some magic set of labels big enough
20:10:30 <EvanR> but i guess thats a totally different kind of theory
20:12:04 <roboguy_> EvanR: well in a weak 2-category, for example, the category laws of the 1-morphisms are only up to isomorphisms of 2-morphisms (instead of up to equality). Likewise for a 3-category, etc
20:12:43 <EvanR> what is a 2-category, a 2 dimensional category?
20:13:19 <roboguy_> EvanR: it is a category with objects (0-morphisms), morphisms between objects (1-morphisms) and morphisms between the morphisms from the previous item (2-morphisms)
20:13:28 <EvanR> oh
20:13:59 <EvanR> so like Hask plus * -> *'s
20:14:32 <dolio> Not really.
20:14:33 <roboguy_> EvanR: hmm, maybe closer to higher order functions
20:14:44 <EvanR> oh
20:14:46 <dolio> The basic 2-category is the 2-category of categories.
20:15:05 <dolio> Where you have categories as 0-cells, functors as 1-cells and natural transformations as 2-cells.
20:16:10 <dolio> So it captures all three levels of structure in one thing.
20:16:59 <dolio> And you wouldn't consider naturally isomorphic functors to be different, like you would in a 1-category of categories.
20:17:47 <EvanR> you wouldnt consider them to be different = you would consider them to be the same?
20:18:24 <dolio> Yes, but then you'd have to negate the part after the comma.
20:18:45 <EvanR> ignoring that part
20:19:34 <EvanR> so does that pattern go up to omega-category
20:20:10 <dolio> Yes, but when you make it fully weak they call them 'infinity-category'.
20:20:27 <EvanR> whats this weakness thing
20:20:50 <dolio> Weakness is that you can't distinguish n-cells that are (n+1)-equivalent.
20:21:42 <dolio> Or, all your rules about n-things being the same are up to (n+1)-equivalence.
20:21:53 <dolio> Instead of saying they are equal.
20:22:26 <EvanR> so we interpret equality / equivalence of stuff in a category in terms of identity types in the next level of category structures. now im kind of rethinking what is meant in the usual category by =
20:22:36 <EvanR> where theres no next level
20:23:02 <EvanR> everything i know is wrong
20:24:05 <dolio> EvanR: Right. Whenever you say '=', you're appealing to some meta-level notion where you can distinguish the equality of things.
20:24:29 <dolio> So, the infinity- stuff is where instead of doing that, you always work up to the next level.
20:25:38 <EvanR> head explode. ok
20:25:41 <dolio> And to get back the 1-stuff, you say that above the first level, things are boring, and always have inverses up to the following level.
20:26:26 <dolio> So there are higher levels, but you never need to consider them, because they might as well be =.
20:27:04 <EvanR> uh well that makes it sound kind of pointless
20:27:41 <dolio> Well, that lets you have categories as a special case of infinity categories.
20:28:15 <dolio> Some things still are categories.
20:28:30 * hackagebot tictactoe3d 0.1.0.0 - 3D Tic-Tac-Toe logic  https://hackage.haskell.org/package/tictactoe3d-0.1.0.0 (ryo0ka)
20:28:31 <dolio> Just maybe not everything.
20:29:13 <dolio> Another thing you can do with higher categories...
20:30:05 <dolio> You can have a 2-category where types are the objects. Arrows A -> B are lambda terms with that type.
20:30:43 <dolio> And if e1 and e2 are lambda terms with type A -> B, an arrow e1 -> e2 means that e1 reduces to e2.
20:31:33 <EvanR> ok
20:33:03 <EvanR> is any of this stuff used explicitly in theorem prover implementations
20:33:22 <broma0> in lens, how can i apply a function inside of a Maybe? is it '?~'?
20:33:26 <dolio> So you can capture non-trivial structure of lambda terms that way, instead of throwing it away and talking about 'functions' between A and B which will be denoted by (equivalence classes of) lambda terms or something.
20:34:01 <dolio> I can't think of any theorem provers that are based on category theory. They're based on type theory.
20:34:12 <dolio> Typically.
20:34:31 <edwardk> broma0: what do you want to do exactly?
20:35:44 <broma0> edwardk: ive got something like this 'd ^? _Right . _Just', and i want to then call a function on the value if it happens to be a Just
20:35:53 <roboguy_> broma0: what about fmap?
20:37:44 <EvanR> > fmap (+1) (Just 1)
20:37:45 <lambdabot>  Just 2
20:37:50 <EvanR> > fmap (+1) Nothing
20:37:52 <lambdabot>  Nothing
20:38:38 <broma0> EvanR: roboguy_: Thank you!
20:39:26 <edwardk> > Right (Just 4) ^?_Right._Just +~ 10
20:39:27 <lambdabot>      Couldn't match type ‘Maybe Integer’
20:39:27 <lambdabot>                     with ‘(Integer -> Identity Integer) -> s -> Identity t’
20:39:27 <lambdabot>      Expected type: ASetter s t Integer Integer
20:39:40 <edwardk> > Right (Just 4)  & _Right._Just +~ 10
20:39:41 <lambdabot>  Right (Just 14)
20:40:22 <EvanR> lens and not lens seems like two different languages ;)
20:43:23 <roboguy_> hmm
20:43:44 <roboguy_> > (fmap.fmap) (+10) (Right (Just 4))
20:43:45 <lambdabot>  Right (Just 14)
20:44:02 <roboguy_> > (_Right._Just) (pure . (+10)) (Right (Just 4))
20:44:03 <lambdabot>      No instance for (Show (f0 (Either a0 (Maybe a1))))
20:44:03 <lambdabot>        arising from a use of ‘show_M578363830280963361231061’
20:44:03 <lambdabot>      The type variables ‘f0’, ‘a0’, ‘a1’ are ambiguous
20:44:51 <roboguy_> ghci liked that one more. Maybe something is getting defaulted?
20:46:19 <broma0> Anyone know how i'd make an aeson FromJSON instance for a ByteString? (specifically Data.ByteString)
20:47:58 <roboguy_> > (_Right._Just) (pure . (+10)) (Right (Just 4)) :: Either () (Maybe Integer)
20:47:59 <lambdabot>      Couldn't match type ‘Either a0 (Maybe Integer)’
20:47:59 <lambdabot>                     with ‘Maybe Integer’
20:47:59 <lambdabot>      Expected type: Either a0 (Maybe Integer)
20:48:50 <roboguy_> well, that one might stay a mystery for me, at least for tonight
20:50:28 <kadoban> Neat. New version of stack has --file-watch to rebuild every time a file changes, and --exec to run a command when a build finishes.
20:52:30 <EvanR> broma0: you have to decide how to interpret json to get a bytestring
20:52:47 <EvanR> json has no bytestring support
20:53:03 <oldmanmike> Is there any way to make configurator deal with blank fields, for instance "foo-field=\n".
20:54:22 <EvanR> broma0: list of numbers? utf8 encoded text? base64?
20:54:38 <broma0> EvanR: how would i do it for utf8 encoded text?
20:55:03 <broma0> according to parseJSON i need a 'Parser ByteString'...
20:55:13 <srobert> Does anyone here use leksah?
20:55:29 <EvanR> encodeUtf8 :: Text -> ByteString
20:55:50 <EvanR> so you can write a FromJSON but its not like you can pack arbitrary bytes into the json that way
20:56:02 <EvanR> if thats your goal you need a different strategy
20:56:32 <greves> humm... can someone explain to me how the code on the haskell homepage for finding primes works? i'm just having a tough time following the logic with the unbounded list and recursive call...
20:56:38 <broma0> EvanR: my goal is to be able to decode json into some 'data X = X { x :: ByteString }'
20:56:58 <broma0> EvanR: i'm trying to avoid strings here
20:56:58 <EvanR> broma0: right but without more contet i can just say, always return empty bytestring
20:57:02 <greves> code is simple enough: filterPrime (p:xs) = p : filterPrime [x | x <- xs, x `mod` p /= 0]
20:57:33 <EvanR> broma0: well aeson is going to give you Text for json strings
20:58:12 <EvanR> String wont be involved unless you request it
20:58:16 <broma0> EvanR: i was thinking i could write '... where parseJSON (String s) = B.pack $ T.unpack s'
20:58:43 <broma0> for an 'instnace FromJSON Bytestring'
20:58:53 <EvanR> broma0: String txt
20:59:01 <broma0> EvanR: ?
20:59:20 <EvanR> im confused about whether you are confused about whether String = [Char] is involved here
20:59:26 <ski> greves : we assume the elements of the list are all integers (ordered) greater than one that are not divisible by any primes less than the first element. this means that the first element must be the next prime, and so we filter away all the remaining numbers that are divisible by it, and then continue on with the remainder of the (infinite) list
20:59:48 <greves> ski: right, i can follow the logic as long as the list is bounded... i dont see how it works infinitely though?
20:59:51 <EvanR> broma0: you cant pack and unpack a Text to get a ByteString
21:00:08 <greves> i mean, how does it start returning numbers immediately since it obviously hasn't finished checking the (infinitely long) list
21:01:02 <broma0> EvanR: the only thing im confused about is why making ByteString and instance of FromJSON by writing 'where parseJSON (String s) = B.pack $ T.unpack s' is giving me an error:
21:01:04 <greves> you will always have something like p1:p2:p3:[still an infinitely long list here]...
21:01:05 <broma0> ouldn't match expected type ‘aeson-0.9.0.1:Data.Aeson.Types.Internal.Parser
21:01:08 <broma0>                                     ByteString’
21:01:08 <ski> greves : well, to find the first element of `filterPrime ns', we look for the first element of `ns'. to find the next, we need to find the next element of `ns' that is not divisible by the first. for the next yet, we need the next element of `ns' not divisible by the first two found primes
21:01:10 <broma0>                 with actual type ‘ByteString’
21:01:16 <roboguy_> greves: laziness. The same way this works:
21:01:19 <roboguy_> > take 4 [1..]
21:01:20 <lambdabot>  [1,2,3,4]
21:01:28 <EvanR> broma0: what is the type of T.unpack
21:01:38 <greves> ah right lazy eval
21:01:43 <broma0> EvanR: Text -> String
21:01:45 <greves> crap, still getting used to this :P
21:01:49 <ski> greves : it may be easier to first understand how a simpler corecursion works. e.g. the fibonacci numbers
21:01:58 <EvanR> broma0: whats the type of B.pack
21:02:28 <ski> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:02:29 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
21:02:58 <broma0> EvanR: String -> Bytestring
21:03:02 <berdario> Uhm, can someone explain me how stuff like stm-containers' Map is supposed to be used? I thought I understood the STM (TVar and MVars... ) but now that I actually tried to use it for the first time I realized that I don't actually grasp it....
21:03:02 <berdario> Like, I executed some operations atomically, but those are never stored... I thoguht that maybe I needed to "write it back", but insert ultimately returns an STM ()... I thought that maybe I could put my Map inside a TVar... bus since newTVar and Map.new have both type (STM something), this seems wrong
21:03:05 <greves> ... what is this sorcery :P
21:03:13 <EvanR> broma0: brr i dont think so
21:03:43 <broma0> > :t Data.ByteString.Char8.pack
21:03:45 <lambdabot>  <hint>:1:1: parse error on input ‘:’
21:03:50 <EvanR> good thing the types are here to make to get this straight in your head
21:03:57 <EvanR> you*
21:04:07 <EvanR> oh no not Char8 again
21:04:24 <ski> greves : my "`fibs' reduction trace" in 2014-12-1[56] at <http://lpaste.net/116547> is a "trace" of how that can be thought to reduce
21:04:45 <broma0> EvanR: alright, well im clearly not understanding you
21:04:55 <greves> ok reading, sec
21:04:56 <ski> greves : each number in the fibonacci sequence (except the first two initial ones) is the sum of the two previous ones
21:04:57 <EvanR> broma0: if you want to convert Text to ByteString you use encodeUtf8, that will not use String
21:05:58 <EvanR> broma0: but i still dont know if that will satisfies your requirements, like what youre trying to do with json and bytestrings.
21:06:02 <berdario> I also obviously tried to have a look at the source code: https://github.com/nikita-volkov/stm-containers/blob/master/executables/ConcurrentTransactionsBench.hs#L79
21:06:03 <greves> ski: zipWith _ _      _      = [                     } <-- that's a typo right?
21:06:17 <ski> greves : at each point, computation is driven by *demand* from someone who wants to inspect the result (ultimately to print the final answer). only as much of the "internal" computation as is needed to compute this final answer will actually be performed
21:06:22 <ski> greves : oops, yes
21:06:42 <berdario> but it's just executing stuff (either in threads or otherwise asynchronously) in a "loop"... it's not accessing the same stuff from different places
21:07:08 <broma0> EvanR: ok, so with 'parseJSON (String s) = encodeUtf8 s' i get: 
21:07:08 <broma0>     Couldn't match expected type ‘aeson-0.9.0.1:Data.Aeson.Types.Internal.Parser
21:07:11 <broma0>                                     ByteString’
21:07:14 <broma0>                 with actual type ‘ByteString’
21:07:19 <EvanR> broma0: yeah, thas not a Parser
21:07:43 <broma0> EvanR: exactly, the root of my question was how do i make aeson happy by returning a parser?
21:08:09 <EvanR> its in the docs, though not obvious it seems
21:08:18 <broma0> EvanR: i can't find it in the docs
21:08:47 <EvanR> try encodeUtf8 (fromJSON v)
21:08:59 <EvanR> hmm
21:09:11 <EvanR> fmap encodeUtf8 (fromJSON v)
21:10:13 <broma0> EvanR: still doesnt match up.. the type i get is 'Result'
21:10:17 <ski> greves : initially, we need to know whether the whole list is empty or not, to print it. after finding out it's a cons (iow non-empty), we need to compute the element of that cons to be able to print it. then we continue in the same way with the tail
21:10:21 <broma0> not Parser ByteString
21:10:44 <EvanR> how do you get that type
21:10:57 <greves> ski i'm following this reduction now, makes sense so far
21:11:10 <broma0> EvanR: fmap encodeUtf8 $ fromJSON v
21:11:15 <EvanR> broma0: oops not fromJSON, parseJSON
21:11:39 <EvanR> parseJSON returns a Parser
21:13:23 <EvanR> the result will be that you can get utf8 bytestrings from json, for what its worth
21:13:57 <EvanR> in real life i think if thats what you want youd want until you need to encode to do it, and not when you decode json
21:14:09 <EvanR> youd wait
21:15:12 <berdario> So, I was trying stuff like this in the ghci:
21:15:13 <berdario> atomically $ (insert "foo" 1 =<< mymap) >> (lookup "foo" =<< mymap)
21:15:26 <berdario> and the output is always Nothing
21:15:54 <EvanR> whats with the =<<
21:16:31 <greves> ski ok i picked up on the pattern after around 150 lines,  think i've got it now
21:16:32 <berdario> EvanR it's just >>= flipped
21:16:37 <EvanR> whats the type of mymap
21:16:39 <greves> wow, how in the world do people come up with this stuff though :P
21:16:59 <berdario> EvanR it's an STMContainer.MAP
21:17:34 <EvanR> uh try removing the =<<'s
21:17:57 <broma0> EvanR: Got it!
21:18:02 <broma0> EvanR: thank you for the help.
21:18:44 <EvanR> broma0: again, that doesnt let you transport arbitrary bytestrings through json, and its probably premature to do utf8 encoding at the point of json decoding
21:19:13 <ski> greves : after a while, you get a feel for how such demand for parts of a returned value will work
21:22:13 <greves> wow it takes quite a while to print fib_1million
21:22:15 <greves> :P
21:23:33 * hackagebot http2 1.0.4 - HTTP/2.0 library including frames and HPACK  https://hackage.haskell.org/package/http2-1.0.4 (KazuYamamoto)
21:27:40 <EvanR> > phi ^ 1000000
21:27:42 <lambdabot>      Not in scope: ‘phi’
21:27:42 <lambdabot>      Perhaps you meant ‘pi’ (imported from Prelude)
21:30:32 <EvanR> poor Q adjoin sqrt 5 undefined before its time
21:33:59 <NemesisD> i'm looking for a way without having to depend on mtl to do early termination. trying to do [IO (Either e ())] -> IO (Either e ()), terminating early on the first Left
21:34:34 <arkeet> use EitherT
21:34:43 <NemesisD> i don't have access to eithert
21:34:52 <arkeet> eh
21:35:03 <NemesisD> whoops i forgot to mention: only with base
21:35:10 <arkeet> define it yourself
21:37:13 <NemesisD> good point
21:37:16 <koshmar> hey, I wonder if you could comment on this tutorial: "Write Yourself a Scheme in 48 Hours". I know a bit of haskell ~ 8 chaters of "Learn You a Haskell for Great Good", and a bit of Scheme - very basic staff. Is it worth to read it? if not what to do after "Learn You a Haskell for Great Good"
21:38:51 <berdario> arkeet if you're here, can I ask you for some pointers about STM?
21:39:06 <arkeet> why me
21:39:18 <berdario> because there's no one else online and active right now :P
21:39:39 <arkeet> just ask the channel
21:39:48 <berdario> I already did... but I'll repeat again
21:40:06 <berdario> with mymap :: STM (STMContainers.Map.Map k v)
21:40:16 <NemesisD> maybe i should just depend on mtl, the problem is mtl went from Control.Monad.Either to Control.Monad.Error
21:40:23 <creichert> koshmar: it's good and introduces some decent topics to become familiar with. Just start moving through it and when you hit parts that are hard to work through, check other resources/projects on hackage/ etc
21:40:28 <berdario> why will atomically $ (insert "foo" 1 =<< mymap) >> (lkp "foo" =<< mymap) 
21:40:28 <berdario> always return Nothing ?
21:40:37 <NemesisD> erm Except
21:40:50 <berdario> it's obvious that this is not the way it's supposed to be used
21:40:57 <creichert> my 2 cents anyways, utilize all resources possible, there is no one size fits all 
21:41:13 <berdario> but I cannot find a single example... in all of the examples, things are a bit different
21:41:24 <berdario> I just need to understand the basics, and I'll pick it up from there
21:45:31 <berdario> For example, I'm trying to dig up some examples on github
21:45:34 <berdario> there's this one:
21:45:35 <berdario> https://github.com/derkyjadex/tracks/blob/158c69275bfb926e6daa114a9b54396deb292c9b/Tracks/Train.hs
21:45:48 <berdario> apparently, it's doing something quite similar:
21:46:23 <berdario> setOccupied platform signals, will do an insert operation on the signals Set, with platform as the value
21:46:51 <berdario> and then it'll return a new record, containing the Set
21:47:02 <berdario> which should be equivalent to the >> I wrote
21:47:54 <berdario> has no-one every used stm-containers?
21:48:34 * hackagebot ihaskell-widgets 0.1.0.0 - IPython standard widgets for IHaskell.  https://hackage.haskell.org/package/ihaskell-widgets-0.1.0.0 (gibiansky)
21:50:13 <catofhask> Hello hivemind
21:50:47 <berdario> hello catofhask, have you ever used STM ?
21:51:00 <berdario> (sorry, but I'm asking everyone... I'm getting a bit frustrated)
21:51:01 <catofhask> I need your help in understanding why a very trivial STM transaction gets hung
21:51:16 <berdario> ok, so you have definitely more experience than me :)
21:51:21 <creichert> catofhask: paste the code
21:51:32 <creichert> berdario: how familiar are you with plain old stm?
21:51:38 <creichert> not using the stm-containers package
21:51:42 <catofhask> modifyTVar' m $ M.insert (producerId e) (seqNum e)
21:51:55 <berdario> creichert I used TVars in ghci once, and it worked just fined
21:52:26 <catofhask> Whole program is quite involved
21:53:24 <catofhask> but gist is, I have a (TVar Map ProducerId SequenceId) - whenver a particluar action happens I just insert a new entry/update existing entry.
21:54:11 <catofhask> at this particular action it hungs up
21:54:28 <catofhask> am I missing something really obvious
21:55:42 <catofhask> when does modifyTVar' hangs up indefinitely?
21:57:36 <dmj`> where's jle` been
22:00:21 <catofhask> initially I had something like `atomically $ do {v <- readTVar m; writeTVar m (M.insert sn pid v)`
22:00:43 <catofhask> that did not hang up, but any readTVar after write used to hang up
22:06:01 <berdario> Ok, I tried stuff again with TVar... reading and setting a variable
22:06:04 <berdario> and it works fine
22:06:19 <berdario> but with Map... nothing at all
22:07:19 <berdario> oh... no, it actually works
22:22:34 <ttt_fff> is it bad style to (1) make lines extra long, and two, ahve a "::" on every line that's a "let blah = ..." or a "x <- ... "
22:23:18 <Walther> regarding style, are {} for codeblocks "wrongs" in haskell?
22:23:36 * hackagebot arithmetic 1.0 - Natural number arithmetic  https://hackage.haskell.org/package/arithmetic-1.0 (JoeHurd)
22:23:38 * hackagebot cv-combinators 0.2.0.2 - Functional Combinators for Computer Vision  https://hackage.haskell.org/package/cv-combinators-0.2.0.2 (NoamLewis)
22:26:01 <macafella> Importing Data.Decimal fails
22:26:09 <macafella> Tips?
22:27:18 <EvanR> Walther: yes
22:27:30 <EvanR> people will call you names behind your back
22:27:47 <Walther> wrong* sorry for the typo. So it is technically possible though?
22:27:55 <Walther> But not good style?
22:27:56 <gamegoblin> Is there a way to test if a Foldable is non-empty?
22:28:43 <ski> ttt_fff : you can use a type signature for the first, and a pattern ascription for the second
22:29:07 <ttt_fff> ski: please enlighten me about 'pattern ascription" I do not know what it is
22:29:17 <ski> ttt_fff : `x :: String <- ...'
22:29:17 <ttt_fff> I find that dding "::" to every line helps me catch type errors earlier
22:29:22 <ttt_fff> oh, cute
22:29:35 <ttt_fff> so basically where when I define a var for capturing in a pattern,
22:29:38 <ttt_fff> I can also add a type sig to it?
22:29:44 <macafella> novice...trying to import Data.Decimal after cabal install Decimal
22:30:14 <ski> ttt_fff : by "pattern ascription" i mean a "type ascription in a pattern"
22:30:36 <broma0>  is there a function '(m a, m b) -> m (a, b)'? Can't hoogle it
22:30:47 <liste> macafella how does it fail?
22:31:14 <liste> macafella are you using cabal as your build tool?
22:31:16 <ski> ttt_fff : in `let blah = ... :: String', you have a type ascription (in an expression). with `let blah :: String = ...', you'd have a type ascription in a pattern again
22:31:47 <ski> ttt_fff : with `let blah :: ...; blah = ...' (or with separate lines, aligned, instead of the `;'), you'd have a type signature
22:31:56 <BartAdv> ski, whats the difference?
22:31:56 <macafella> Yes
22:32:24 <ttt_fff> ski; is this orrect >> "    y :: Int <- mY :: IO Int", the "::Int" is a pattern thingy on y, the "IO Int" is a expr thingy on the entire expr
22:32:26 <liste> macafella then add Decimal to your build-depends in your .cabal file
22:32:34 <BartAdv> between expr and pattern ascription that is
22:33:06 <ski> BartAdv : a type signature is a declaration. a type ascription attaches to another phrase (like an expression or a pattern), yielding a new phrase of that syntactic categoty
22:33:37 <macafella> Okay..I'll try that
22:33:37 <ski> ttt_fff : yep
22:33:41 <macafella> Thx
22:34:08 <ttt_fff> ski: thanks for clarifying all this
22:34:20 <ski> broma0 : `uncurry (liftM2 (,))'
22:34:29 <BartAdv> But both the sides of let statement have the same type
22:34:39 <ski> yes
22:35:45 <atondwal> does anyone have ghc-mod working?
22:35:45 <ski> ttt_fff : in the Haskell community, people often say "type signature" also when they refer to the ascription case. i've found the "ascription" terminology distinction useful, though (i learned it in literature relating to the MLs)
22:35:59 <atondwal> (with ghc 7.10, that is)
22:36:32 <ttt_fff> ski: in a very handwavey way, "type signature" = "var :: type-sig\n", whereas "ascription" = "var/expr :: typesig" -- but inline, not on it's own separate line
22:36:40 <ttt_fff> i.e. "ascription is embedded inside/after the expr/var
22:36:46 <ttt_fff> but "signature" is on it's own line
22:36:49 <ttt_fff> is that roughtly correct?
22:36:51 <ski> yes
22:37:04 <ski> a type signature is its own declaration item
22:37:04 <atondwal> I'm building it from git, but all it does is install cabal 1.22.3 and then gives me this error
22:37:06 <atondwal> ghc-mod: /usr/lib/ghc-7.10.1/settings: openFile: does not exist (No such file or directory)
22:37:42 <ski> an ascription attaches to a phrase (expression or pattern), giving a new phrase of that kind (which can be nested again)
22:37:44 <atondwal> which is _especially_ strange because I'm using ghc7.10.2
22:38:55 <ski> (sometimes people who haven't yet learned the preferred terminology say "cast" or "coercion" instead of ascription, though it does nothing of the sort. it only constrains the type to one particular possibility out of several which it could had have anyway)
22:39:52 <ttt_fff> ski++
22:40:44 <ski> (a "cast" or a "coercion" would imply either a *change* of type, or that and also a conversion of value. compare with coercing an `Int' to a `Double' using `fromIntegral', or casting a pointer to one type to a pointer to another type)
22:41:35 <EvanR> use a "cast" to cast away type safety
22:41:39 <atondwal> ski: when is it useful to distingish an ascription from a type signature?
22:41:40 <ttt_fff> in haskell, is there an 'identity' monad?
22:41:42 <ttt_fff> the monad does nothing
22:41:52 <pacak> :t Identity
22:41:53 <lambdabot> a -> Identity a
22:42:01 <EvanR> Identity is a Monad
22:42:26 <pacak> :t runIdentity
22:42:27 <lambdabot> Identity a -> a
22:42:35 <ttt_fff> pacak++
22:42:48 <atondwal> ttt_fff: also see Control.Monad.Identity
22:43:00 <ttt_fff> pacak: sounds likea useless monad, but I suddently have a use for it due to a function taht demands a monad
22:43:01 <ski> atondwal : they go in different places
22:43:06 <ttt_fff> atondwal: yep, exactly what I found on hackage
22:43:33 <liste> State s = StateT s Identity
22:43:44 <liste> so it's actually pretty useful
22:44:01 <catofhask> hi, will put my question again as I see many people online now :)
22:44:03 <pacak> ttt_fff: id is a useless function. () is a useless value.
22:44:14 <ski> atondwal : sometimes you need an explicit type signature for something to be type-checkable. a type ascription will not substitute for it
22:44:15 <pacak> ttt_fff: Void is even more useless.
22:44:18 <EvanR> 0 is a useless number
22:44:21 <catofhask> I need your help in understanding why a very trivial STM transaction gets hung
22:44:33 <ttt_fff> pure functions are useless; they don't change the world
22:44:39 <atondwal> ski: thank yu
22:44:42 <catofhask> modifyTVar' m $ M.insert (producerId e) (seqNum e)
22:44:43 <Hijiri> '
22:44:45 <Hijiri> sorry, didn't mean to enter that
22:44:51 <catofhask> Whole program is quite involved
22:45:00 <catofhask> but gist is, I have a (TVar Map ProducerId SequenceId) - whenver a particluar action happens I just insert a new entry/update existing entry.
22:45:30 <pacak> :t absurd
22:45:31 <lambdabot> Not in scope: ‘absurd’
22:45:33 <pacak> :(
22:45:33 <ski> atondwal : the typical cases are (a) DMR; (b) polymorphic recursion; (c) rank-`n'; (d) GADTs
22:45:57 <dmj`> ttt_fff: depending on your definition of usefulness
22:45:59 <ski>   void :: Void -> a  -- itym ?
22:45:59 <atondwal> pacak: I wouldn't call `id` useless; to me that honor would go to `const ()`
22:46:10 <atondwal> ski: DMR?
22:46:14 <ski> Dreaded Monomorphism Restriction
22:46:20 <atondwal> hahaha
23:04:35 <nschoe> Hi guys, I'm trying to use list comprehension like this: [(n1><n2) (repeat 0.0) | (n1, n2) <- size w, w <- weights]
23:04:56 <BST> Hi everyone
23:05:02 <johnw> pacak: id, Void and () are all things I use often
23:05:26 <nschoe> Basically I want to create a list of matrices (filled with 0s) from another list of matrices (which are non zero).
23:05:42 <nschoe> But I've got error 'not in scope w'
23:05:48 <pacak> johnw: I know, I'm using them as well. Just was giving other examples of stuff as useless as Identity monad.
23:05:54 <nschoe> Is there a way to make this work, or is this the limit of list comprehension ?
23:06:14 <johnw> pacak: what do you mean by useless then?
23:06:48 <pacak> johnw: Not me, I was used terminology of whoever complained about Identity up there.
23:07:04 <johnw> ah
23:08:10 <BST> I'm a Haskell beginner and need your help please. I'm trying to make a function of unroll :: Int -> [a] -> [a]. For example when I'm typing unroll 9 [1,2,3] and it should return [1,2,3,1,2,3,1,2,3]. How I'm gonna do that?
23:08:31 <johnw> is this a homework assignment?
23:08:42 <BST> Its a homework
23:09:01 <johnw> are you familiar with writing recursive functions yet?
23:09:06 <pacak> > take 9 $ cycle [1,2,3]
23:09:07 <lambdabot>  [1,2,3,1,2,3,1,2,3]
23:09:08 <arkeet> do you have to make it from scratch, or 
23:09:11 <arkeet> yeah spoilers.
23:09:15 <pacak> @src cycle
23:09:15 <lambdabot> cycle [] = undefined
23:09:15 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
23:09:19 <pacak> @src take
23:09:19 <lambdabot> take n _      | n <= 0 = []
23:09:19 <lambdabot> take _ []              = []
23:09:19 <lambdabot> take n (x:xs)          = x : take (n-1) xs
23:09:45 <BST> I've tried like this unroll n _      | n <= 0 = [] 
23:09:46 <BST> unroll _ []              = []
23:09:46 <BST> unroll n (x:xs) = x : unroll (n-1) (cycle(xs))
23:10:02 <johnw> BST: that's a good start
23:10:02 <pacak> BST: lpaste?
23:10:56 <BST> For you answer lamdabot it will come out with [1,2,3,2,3,2,3,2,3]
23:10:57 <pacak> BST: Can you use standard library in your homework? If not - cycle is not something you should be using
23:11:13 <BST> It does not take the first value which is 1
23:11:26 <nschoe> No idea for the list comprehension?
23:11:56 <johnw> nschoe: draw from w first
23:12:08 <johnw> the scoping is like a non-recursive let
23:12:22 <nschoe> johnw, oh yeah? Let me try that, then ^^
23:13:39 * hackagebot pipes-files 0.1.1 - Fast traversal of directory trees using pipes  https://hackage.haskell.org/package/pipes-files-0.1.1 (JohnWiegley)
23:14:33 <BST> Anyone could solve my problem? :(
23:14:42 <johnw> it's homeWORK
23:15:25 <BST> I know and still learning. But I'm stuck in here :(
23:15:32 <nschoe> johnw, thanks, it seems it would work (still have a problem with IndexOf, but that's a hmatrix problem now). Thanks!
23:15:39 <johnw> believe it or not, it's better to be stuck and work through it, than to have the answer
23:15:45 <BST> The problem is it does not start with the first value
23:15:53 <johnw> getting yourself unstuck, even if it takes days, will leave a mental residue that will help you in days to come
23:15:55 <gamegoblin> @pl \x -> f x >> y
23:15:55 <lambdabot> (>> y) . f
23:17:02 <johnw> gamegoblin: f >=> y
23:17:08 <johnw> oh, >>
23:17:18 <johnw> f >=> const y?
23:17:26 <gamegoblin> meh
23:17:30 <johnw> yeah, meh
23:17:58 <BST> pacak: yes I can use the standard library
23:18:06 <pacak> gamegoblin: Why not leave it as lambda? Looks more readable
23:18:15 <gamegoblin> pacak: who says I didn’t ;)
23:18:49 <AnonymousCrab> 1111
23:18:51 <gamegoblin> pacak: I like to ask @pl’s opinion for little single-arg lambdas like that, sometimes it surprises you
23:18:59 <gamegoblin> pacak: but I left it this time
23:19:22 <pacak> BST: Don't be afraid of infinite data structures then. take works just fine on them for example.
23:21:21 <BST> pacak: thank you. 
23:25:11 <erisco> if you can define folds for any ADT, then what is the fold for  data Vertex a = Vertex { label :: a, edges :: Set (Vertex a) }  ?
23:32:06 <opqdonut> erisco: something like foldVertex :: (a -> b) -> (Set b -> b) -> b
23:32:25 <opqdonut> gah, sorry
23:32:31 <erisco> it is similar to rose trees
23:32:32 <opqdonut> misread
23:32:44 <erisco> in Data.Tree it defines foldMap
23:32:46 <opqdonut> foldVertex :: (a -> Set b -> b) -> Vertex a -> b
23:32:54 <opqdonut> there
23:33:02 <erisco> and the interesthing thing is foldr f z = foldr f z . toList
23:33:20 <erisco> so I am guessing that folds are always linear
23:34:05 <opqdonut> you can make that more linear by "inlining" the fold for Set
23:34:27 <erisco> :t foldr (:) []
23:34:28 <lambdabot> Foldable t => t a -> [a]
23:34:33 <erisco> > foldr (:) [] [1,2,3]
23:34:34 <lambdabot>  [1,2,3]
23:34:44 <erisco> that is a nice identity, right
23:34:49 <opqdonut> to end up with e.g. foldVertex :: (a -> b -> b) -> (b -> b -> b) -> Vertex a -> b
23:34:51 <erisco> can you not do the same for trees?
23:35:00 <erisco> I am confused
23:35:04 <opqdonut> yes, you can
23:35:20 <opqdonut> you get back the original structure by folding with the constructor itself
23:35:36 <erisco> then is the Data.Foldable interface just for listy foldables?
23:36:01 <opqdonut> yeah
23:36:03 <johnw> erisco: anything that can toList, basically
23:36:03 <ski>   foldVertex :: Ord b => (a -> Set b -> b) -> Vertex a -> b
23:36:31 <opqdonut> so my first foldVertex, which ski echoed just now, is the "catamorphism" for Vertex
23:36:43 * ski added the ordering constraint
23:36:48 <opqdonut> you did
23:37:06 <opqdonut> but you can also define a listlike "fold" for Vertex, which just goes through the labels one at a time
23:37:12 <pacak> erisco: have a look at cata from recursion-schemes
23:38:36 <ski> erisco,opqdonut : <http://comonad.com/reader/2015/free-monoids-in-haskell/>
23:38:53 <ski> (by dolio)
23:39:11 <johnw> dolio's had several excellent articles there recently
23:40:59 <atondwal> ski++
23:46:35 <concept> How can I implement mutable state in Haskell ?
23:46:57 <liste> concept IOVar/MVar
23:46:59 <johnw> concept: mutable in what sense?
23:47:02 <liste> or STVar
23:47:18 <johnw> i mean, you can malloc memory and directly write to the pointer, at the lowest level
23:47:23 <johnw> or you can just use State at the highest
23:48:05 <concept> johnw : I want to have a variable
23:48:25 <concept> also things like queues
23:48:34 <concept> should be used in IOVar monad ?
23:49:22 <ski> do you mean you want to have mutable variables ?
23:49:28 <ski> (and if so, why ?)
23:51:31 <concept> ski: I can't see how can I implement my program with only pure expressions, it needs to have a state
23:51:41 <gamegoblin> Cabal error, any suggestions
23:51:42 <gamegoblin>  cabal install base-4.8.0.1
23:51:42 <gamegoblin> Resolving dependencies...
23:51:43 <gamegoblin> cabal: Could not resolve dependencies:
23:52:02 <pacak> gamegoblin: It's not how you update base.
23:52:10 <gamegoblin> pacak: how should?
23:52:22 <pacak> get a new HP
23:52:23 <atondwal> concept:  you probably want State
23:52:24 <liste> concept what do you use the state for?
23:52:25 <pacak> or ghc
23:52:38 <pacak> concept: Sure you can.
23:52:52 <atondwal> concept: see Control.Monad.State
23:53:11 <liste> (State is really just pure expressions, too (: )
23:53:16 <ski> concept : depending on how much experience you have with the paradigm, it may just be that you're not familiar with ways to do it. that being said, if you want mutable state, you can get it
23:54:44 <ski> concept : the simplest version is just to return the new version of the state, passing it on to whoever needs to access it
23:54:58 <concept> ski: well I have been using haskell for around 3 months. That being said, I still struggle to write purely functional code, so far I have managed without mutation, but I have reached a point where I don't see how can I live without it
23:55:31 <atondwal> concept: what are you trying to write?
23:55:31 <ski> are you familiar with state-passing style (perhaps not under that name), yet ?
23:55:58 <concept> ski: is it the same as continous passing ?
23:56:03 <ski> no
23:56:19 <concept> ski: so you just take the current state and pass it over
23:56:53 <concept> ski: and when you want new state, you create new one and also pass it over
23:57:27 <ski> (if by "continous passing" you meant "continuation-passing (style)" .. which is another thing)
23:58:00 <concept> ski: what is the difference ?
23:58:18 <ski> concept : yes, it (state-passing) is more or less `step :: MyState -> MyState' in the simplest case
23:58:19 <liste> concept have you tried something like step :: ProgramState -> (Result, ProgramState)
23:58:41 <ski> or `next :: OtherInput -> MyState -> MyState' if you need some auxilary input
23:59:03 <mniip> but that's costate
23:59:26 <concept> I never tried it but I can see what do you mean
23:59:29 <ski> or `step :: OtherInput -> MyState -> (MyState,OtherOutput)' if you (also) want some auxilary output
