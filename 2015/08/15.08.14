00:18:47 * hackagebot cabal-helper 0.5.1.0 - Simple interface to some of Cabal's configuration state used by ghc-mod  https://hackage.haskell.org/package/cabal-helper-0.5.1.0 (DanielG)
00:26:24 <greves> a bit confused about cabal, are packages installed with 'cabal install' installed locally or globally, or does it depend on whether i have a sandbox initialized in the folder i run the command in?
00:27:05 <suppi> greves, it depends on whether you have a sandbox initialized in the folder you run the command in :)
00:27:23 <suppi> AFAIK at least
00:27:29 <greves> ok
00:27:47 <greves> so for system wide stuff like ghc-mod, it makes sense to just install it globally i suppose?
00:28:20 <suppi> I install it in a sandbox and then add the .cabal-sandbox/bin folder to PATH
00:29:27 <suppi> you often want the executable to be global. the packages, maybe not so much.
00:29:55 <greves> wait, what do you mean?
00:30:40 <suppi> cabal install downloads haskell packages and compiles them
00:31:07 <greves> right...
00:31:08 <suppi> if you do this globally and not in a sandbox, they will be available globally
00:31:22 <greves> available to import in my own packages, you mean?
00:31:46 <suppi> that means that if you want to install a package that needs, for example, base 4.8, but you installed 4.7 there will be a conflict
00:31:49 <suppi> (I think)
00:32:23 <greves> well the most similar thing that i'm familiar with is npm, so that has a global directory and if you install something in the local directory ('sandbox') it will take precedence
00:32:25 <Axman6> greves: I would recommend having a look at stack, it does away with a lot of the problems you are, or are about to, run into
00:32:26 <suppi> not only your package but any package you want to use
00:32:27 <greves> not so with cabal?
00:32:27 <liste> base depends on GHC version and non-sandbox packages can depend on different versions of the same package
00:32:37 <liste> ie. there can be multiple versions of package installed
00:32:53 <liste> but it can lead to problems
00:33:29 <suppi> then transformers 0.3 vs transformers 0.4 ...
00:34:40 <suppi> greves, My cabal foo is lacking, so I just install everything in a sandbox. this is the easiest way for me to avoid cabal hell.
00:34:58 <greves> ah ok. so no different than npm really ;P
00:34:59 <suppi> as Axman6 state stack might also help
00:35:18 <suppi> stated*
00:35:39 <liste> I used to have both the EclipseFP tools and cabal installed, and they used different versions of Cabal library
00:35:51 <liste> that caused severe problems
00:36:06 <suppi> I one time installed yesod globally
00:36:15 <suppi> that was not a good idea
00:36:59 <Axman6> that is what many would refer to as "a bad idea", yes :P
00:37:10 <suppi> :)
00:37:16 <suppi> Maybe someone can offer me some advice
00:37:26 <Axman6> `cabal isntall --global yesod lens` then boil some tea and drink it with your laptop
00:37:28 <greves> see this is why tutorials are annoying. they all spend plenty of time on doing stuff in ghci, and no time on how to actually set up a proper build environment :P
00:37:45 <Axman6> greves: just use stack
00:37:50 <Axman6> please
00:37:55 <Axman6> it's much less painful
00:37:56 <liste> that's what stack was made for
00:38:01 <greves> is that an alternative to hackage or used in conjunction with it?
00:38:04 <Axman6> it has changed my life
00:38:13 <suppi> I wrote a blog post about IO and linked it on reddit (https://www.reddit.com/r/haskell/comments/3gu5ds/how_haskell_models_io_a_blog_post_for_beginners/)
00:38:26 <Axman6> it uses stackage, which is snapshots of hackage, with library versions which are known to build together
00:38:53 <suppi> After many suggestions I kind of re-wrote it ( http://gilmi.xyz/post/2015/08/12/how-haskell-models-io2 )
00:39:24 <suppi> would anyone like to read it and give me feedback? is it better than the original? worst?
00:39:26 <greves> Î»m your greek and latin are getting mixed up :P
00:39:40 <greves> suppi i will read both as i haven't seen this post yet
00:39:47 <suppi> greves, This is some kind of a pun on my initials :)
00:39:51 <suppi> greves, thank you
00:40:06 <greves> just want to try getting at least a simple build environment set up for a moment :P
00:41:14 <suppi> greves, there is this http://howistart.org/posts/haskell/1
00:41:48 <liste> suppi maybe put a THIS CODE IS WRONG disclaimer on the second example?
00:41:59 <Axman6> greves: there is literally nothing more simple than using stack tyo get a braindead simple build environment installed
00:42:49 <suppi> liste, definitely.
00:43:28 <greves> Axman6: looking at it now don't worry :P
00:47:31 <greves> Axman6: do i need to stack init or just start stack installing stuff in a project folder?
00:47:56 <suppi> greves, try running stack --help
00:48:10 <greves> i've looked at that, yes
00:48:15 <greves> and i'm reading the wiki on github now
00:48:22 <greves> there is no real 'beginners introduction' section :P
00:48:36 <suppi> I actually don't use stack much :X
00:49:17 <suppi> brb
00:51:10 <Axman6> greves: if you're starting a new project, run stack init, then stack setup - that will download GHC for you (yay) and give you a bare(-ish) stack.yaml file iirc
00:51:44 <Axman6> I've only used it on existing projects, which by the way, has been a pleasure to port to
00:57:13 <greves> Axman6: do you agree with suppi then just to install random bins like hlint or ghc-mod into some folder and stick it on the PATH?
00:58:06 <merijn> greves: I just move the executables to ~/.bin where I keep all my "random homebrew scripts/binaries"
00:58:08 <suppi> Axman6, I haven't had much luck. especially with older LTS
00:59:35 <suppi> For example, I used transformers 0.4 in one project (for ExceptT) and tried to port to stack, LTS only had transformers 0.3 so I was told to change my package to transformers-compat
01:00:11 <suppi> which needed some changes to be done, but I didn't understand exactly what and the documentation was sparse
01:00:16 <merijn> suppi: That's because transformers is a GHC boot library and thus really hard to upgrade for older GHC versions
01:00:27 <suppi> so I gave up and continued with cabal
01:01:05 <suppi> merijn, I understand. But I didn't need to support older GHC versions so it didn't fit me at that time
01:01:36 <suppi> too much work when I didn't have any problem with cabal in the first place on this project.
01:03:21 <merijn> suppi: If you were porting to stack/LTS you *did* have to support older GHCs, no? Since they don't support the newest one, afaik
01:05:10 <suppi> merijn, I mean It was work I didn't want nor needed to do for that project.
01:05:42 <suppi> changing my code and dependencies that is.
01:08:44 <greves> suppi i'm just reading the first blog post now, why are you defining your own multiply function?
01:09:12 <greves> or should i read both first and then comment? :P
01:09:37 <suppi> greves, I want to show that the implementation of mul may affect execution
01:09:49 <suppi> Is it too weird?
01:10:05 <greves> well i would never know why anyone wants to write their own `mul` if (*) exists
01:10:22 <greves> and i can't really think of such an example just off the top of my head that might actually happen
01:12:43 <suppi> hmm
01:14:07 <suppi> It could be a function that checks if a line has '!' in the end and if it doesn't, add '!' to the end.
01:15:07 <suppi> Is that better?
01:15:53 <geekosaur> nkaretnikov_, I am pretty sure I dug that originally out of the TH paper. For you, a couple days ago, on exactly that question?
01:16:01 <greves> you mean it will just eat a string until \n ?
01:16:08 <greves> not sure what you mean
01:16:19 * geekosaur not supposed to be awake, not sticking around, just clearing highlights
01:16:40 <greves> ok i just finished the first one. pretty confused, but trying the second one now :P
01:16:59 <greves> and i am a newb so this is a good test of your blog posts! hah
01:17:52 <suppi> greves, do you know how IO in haskell works?
01:18:00 <greves> no
01:18:05 <suppi> hmm
01:18:09 <greves> something about monads, that's all i've got so far from reading other stuff
01:18:14 <greves> (but i don't know what they are)
01:18:42 <suppi> I hope this will not confuse you even more since this is a work in progress to get feedback
01:19:07 <suppi> try the second, if you understand it better, great. if not, tell me and I will try to explain
01:19:09 <greves> that's ok, i don't mind being more confused because in the end the more sources you have the more clearly you understand it
01:19:21 <greves> ok, i'm reading now
01:19:27 <suppi> I do not want that because you read my tutorial you will only get confused :O
01:19:47 <suppi> ok
01:20:53 <geekosaur> nkaretnikov_, not exactly that question, actually, you asked what those were and I pointed you to the paper which described them
01:23:06 <Black0range> using hxt and arrows why does line 3 make the results of line 2 get repeated as many times as there are results in line 3?
01:23:09 <Black0range> http://lpaste.net/138791
01:23:44 <greves> suppi - still confused.
01:24:07 <suppi> greves, anything in specific?
01:24:20 <greves> the difference between evaluate and execute
01:24:25 <Black0range> ex if line 1 returns ["EN"]. then it would turn into ["EN", "EN", "EN", "EN"] 
01:24:46 <greves> and mostly just the intended goal of our code/pseudocode
01:25:54 <greves> like the part `multiplier = if execute userInt == 3 then 3 else 3`, i don't know what this is for or what execute is
01:25:55 <merijn> Black0range: Not entirely helpful comment, but are you somehow forced to use HXT? I've seen many people complain it's rather confusing. I've personally only used xml-conduit (and/or html-conduit) and found those pretty straightforward, so might wanna consider using those
01:26:11 <suppi> greves, evaluation is understanding what something is
01:26:13 <merijn> The whole arrow thing is needlessly confusing, imo
01:26:18 <suppi> basically
01:26:49 <suppi> greves, for example: 1 + 1 is an expression of type Int
01:26:53 <greves> right
01:27:04 <suppi> if you evaluate it you get 2
01:27:08 <suppi> it is the same as 2
01:27:15 <greves> but surely code has been executed to do that calculation?
01:27:18 <merijn> For some value of the same
01:27:35 <merijn> greves: Note that haskell makes a distinction between execution and evaluation
01:27:47 <Black0range> merijn: hmmm never seen those libraries before. Taking a look! 
01:28:02 <merijn> greves: Evaluation is something that happens to expressions, execution is something that happens to IO values
01:28:21 <merijn> Black0range: Other bonus, they plug nicely into http-conduit for fetching files from the web
01:28:25 <greves> ok, so that is specific to haskell? i haven't heard anything expressed like that before...
01:28:33 <suppi> merijn, evaluation is also something that happens to IO values.
01:28:50 <merijn> Black0range: A simple scraper I hacked together using http-conduit+html-conduit to download images from a webcomic: https://gist.github.com/merijn/d8188ddd129718ffcfb0
01:29:18 <merijn> greves: Yes. A decent summary is here: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
01:29:27 <suppi> greves, In imperative languages, basically everything is execution (merijn corrent me if I'm wrong)
01:30:13 <suppi> IO values can also be evaluated, for example: putStrLn "Hello" is of type IO ()
01:31:04 <merijn> greves: A good example is to try the following in ghci: "(map print [1..10]) !! 3" and see what the result is
01:31:05 <suppi> greves, If you execute putStrLn "Hello", It will print "Hello" and will produce ().
01:31:37 * mniip enables pedant mode
01:31:43 <greves> so the stateful mutation is "hello" on the term and "return" (in another language) is ()
01:31:57 <greves> i'm reading that link merijn, makes a lot more sense
01:32:21 <greves> suppi read this one, because the author clearly introduces a problem right away
01:32:29 <Black0range> merijn:: great example there 
01:32:32 <Peaker> graphics-drawingcombinators is an excellent library providing an Image Monoid type (using IO actions under the hood to do OpenGL drawing calls).  I added "font mipmapping" to it (choosing a pixel-perfect font size when rendering text) and now I have a big problem I don't know how to solve nicely :(
01:32:36 <suppi> greves, merijn, thanks for the link
01:33:16 <Peaker> the font mipmaps are discretely-sized, so the ratio between text width/advance and text height isn't exactly the same.  When asking the lib for text width -- it doesn't know what font size to use, so you necessarily get inaccurate/incorrect width for the text :(
01:33:50 <Peaker> https://trello-attachments.s3.amazonaws.com/55c674e75cbcb1ba213cdcc2/1230x319/ab82035fe3a83e3395ba0114acfca024/upload_8_9_2015_at_12_30_14_AM.png <-- this is a resulting bug (note the incorrect width there)
01:34:09 <greves> merijn: well that is pretty cool.
01:34:22 <Peaker> Now I could have the text width computed in the same GL-matrix context as the drawing operations, but that would mean that Image is no longer a nice Monoid, but some much-harder-to-use Monad type
01:34:31 <greves> i wasn't sure what to expect since my naive first glance analysis thought it would print 0 to 10
01:34:44 <greves> or 1 to 10, rather
01:34:46 <merijn> :t map print [1..10]
01:34:48 <lambdabot> [IO ()]
01:34:53 <Peaker> Anyone has any ideas how to get accurate text width with Image remaining a nice Monoid?
01:35:11 <greves> so it's a list of IO ()
01:35:25 <Black0range> :t map print [1..10]!!3
01:35:26 <lambdabot> IO ()
01:35:26 <merijn> greves: If "IO a" is an "IO action that produces 'a'", then we just get a list of actions, but those don't get executed, because you can't execute IO actions "inside" haskell
01:35:48 <merijn> greves: IO actions are first class values that you can return from/pass to functions
01:35:51 <greves> right, you have to send them somewhere else
01:35:57 <greves> i get the separation idea
01:36:07 <greves> but not fully :P
01:36:37 <merijn> greves: The only IO action that gets executed is "main :: IO a" which gets run by the runtime, so you need to somehow use join/>>=/etc. to build bigger and bigger IO actions from smaller components. Resulting in a single big IO action which is main
01:36:54 <Black0range> an io action doesn't have to be executed before it is passed to another IO action that is dependant of it's result 
01:37:03 <Black0range> its*
01:37:05 <Black0range> sorry
01:37:18 <greves> merijn so how would you print out the whole list [1..10] using map?
01:37:29 <merijn> greves: Haskell is, effectively, a pure language for building complex IO actions. Or, if you will, a pure language for building impure programs as result
01:37:37 <merijn> :t sequence
01:37:38 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
01:37:53 <merijn> :t sequence `asAppliedTo` (undefined :: [IO ()])
01:37:54 <lambdabot> [IO ()] -> IO [()]
01:38:00 <merijn> or
01:38:02 <merijn> :t mapM
01:38:03 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
01:38:05 <Peaker> merijn: why did they generalize "sequence" to Traversable while keeping the "m" a Monad?
01:38:39 <Peaker> (why not go all the way to sequenceA?)
01:38:46 <merijn> Peaker: There was discussion on whether it should be generalised to Applicative or whether having "Applicative constraint on M" would confuse things
01:38:46 <mniip> :t mapA
01:38:47 <lambdabot>     Not in scope: âmapAâ
01:38:48 <lambdabot>     Perhaps you meant one of these:
01:38:48 <lambdabot>       âmapMâ (imported from Data.Traversable),
01:38:52 <suppi> greves, basically, main is the action that gets executed, and main is composed of IO actions using (>>=), right?
01:38:54 <mniip> ugh
01:38:56 <mniip> :t for
01:38:58 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
01:38:58 <merijn> Peaker: Also, worry about using Applicative instances resulting in different performance
01:39:09 <merijn> :t traverse
01:39:10 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
01:39:10 <Peaker> merijn: better performance (usually?)
01:39:10 <mniip> for ~ forM
01:39:24 <mniip> oh yes, of course
01:39:30 <mniip> traverse
01:39:30 <suppi> greves, so the actions main is composed of are executed one by one, right?
01:39:36 <Peaker> merijn: I think if the breakage is rather unlikely, the answer should be "What would a clean slate design do?"
01:39:38 <merijn> Peaker: Maybe, maybe not, the end conclusion was "all currently valid code doesn't break if we loosen the constraint later, so lets be conservative"
01:39:55 <Peaker> merijn: Too successful :(
01:40:09 <merijn> Peaker: So they figured, let's appease the pessimists with this and we can try to loosen the constraint once someone has benchmarked hackage
01:40:26 <merijn> Peaker: But anyway, traverse is already generalised mapM, so
01:40:44 <Peaker> yeah, things might be slower anyway
01:48:51 * hackagebot ghc-mod 5.3.0.0 - Happy Haskell Programming  https://hackage.haskell.org/package/ghc-mod-5.3.0.0 (DanielG)
01:51:42 <nkaretnikov_> geekosaur: wat, really? :)  i don't remember
01:56:21 <suppi> * hackagebot ghc-mod 5.3.0.0 - Happy Haskell Programming  https://hackage.haskell.org/package/ghc-mod-5.3.0.0 (Daniel G)
01:56:23 <suppi> yey!!
01:58:01 <Phillemann> Finally...
01:59:40 <skrio> Is it finally 7.10 ready?
02:07:01 <suppi> skrio, seems so http://hackage.haskell.org/package/ghc-mod-5.3.0.0/changelog
02:15:14 <hvr> skrio: wait till http://matrix.hackage.haskell.org/package/ghc-mod is refreshed :)
02:19:22 <greves> suppi sorry i went out to 7-11 for a minute, catching up now :P
02:20:44 <suppi> merijn, Is it ok if I include your nick in my post saying you linked that article? (here http://www.gilmi.xyz/post/2015/08/12/how-haskell-models-io2 )
02:20:51 <suppi> greves, np
02:20:58 <greves> suppi: yes so main is composed of IO actions >>=
02:21:10 <merijn> suppi: sure
02:21:18 <suppi> merijn, thanks
02:22:34 <suppi> merijn, done.
02:22:59 <suppi> greves, so can you write a function that takes [IO ()] and chains them using >>= ?
02:23:01 <erisco> does  f a -> a   have a name?
02:24:13 <greves> f (x:[]) = print x; f (x:xs) = f xs ?
02:24:28 <suppi> erisco, extract perhaps?
02:24:43 <erisco> maybe a categorical name?
02:24:46 <suppi> erisco, http://hackage.haskell.org/package/comonad-4.2.7.2/docs/Control-Comonad.html#v:extract
02:25:10 <merijn> erisco: extract?
02:25:12 <merijn> :t extract
02:25:13 <lambdabot> Not in scope: âextractâ
02:25:18 <merijn> oh, no comonads
02:25:39 <erisco> oh I see
02:26:12 <erisco> thanks
02:26:12 <suppi> greves, the elements in [IO ()] already are IO actions, you just need to execute them
02:27:03 <greves> hummm
02:27:17 <suppi> greves, first, what would be the type signature of such operation?
02:27:32 <greves> [IO ()] -> IO () ?
02:27:54 <srhb>  Yep.
02:28:31 <suppi> oh, my mistake, what if we wanted to execute all actions in [IO a]
02:28:41 <suppi> and keep the values we get when executing them
02:28:49 <greves> oh. humm....
02:29:09 <srhb> [IO a] -> IO [a]
02:29:23 <greves> i don't really get that
02:29:39 <greves> IO <list of things of type a> what does that mean?
02:29:58 <srhb> It's an IO action that "produces" a list of as
02:29:59 <liste> an action that returns a list of things of type a
02:30:01 <suppi> that means that this is a value
02:30:02 <merijn> greves: An IO action that produces a list of 'a'
02:30:10 <srhb> Echo echo echo....
02:30:12 <suppi> yup. lol
02:30:14 <liste> :D
02:30:17 <suppi> :)
02:30:36 <greves> haha ok so wait let me read all of those comments first - it's an action that produces a list of 'a's? :P
02:30:49 <srhb> :-)
02:30:56 <srhb> So yeah, still sequence.
02:30:56 <suppi> you can also think about it as a "plan" to produce a list of 'a's
02:31:17 <greves> how about concretely in the computer, what it means?
02:31:36 <suppi> the plan itself is a value, a pure value
02:31:51 <greves> so IO [a] is a value?
02:31:55 <suppi> you can store it in a data structure or pass it to functions. it is first class
02:31:58 <suppi> yes
02:32:05 <srhb> No, it's a type. But it has values. :)
02:32:12 <suppi> right
02:32:26 <greves> well, an instance of type IO [a] i should say
02:32:26 <suppi> something that has the type IO [a] is a value
02:32:40 <liste> greves instance is a different thing in Haskell
02:32:45 <erisco> what is the name for the unit of kind * -> * ?
02:32:52 <merijn> erisco: Identity?
02:33:05 <wouter_> newtype
02:33:14 <erisco> merijn, but you've gotta stick a value in that
02:33:47 <suppi> greves, So, something that has the type IO [a] is like a "plan" to produce [a].
02:34:05 <suppi> greves, But in order to produce the plan, it needs to be executed
02:34:13 <merijn> erisco: That comment doesn't parse
02:34:19 <greves> what do you mean by "plan" ? sorry if i'm being pedantic but i understand abstract stuff better when i know what it's doing concretely in memory, heh
02:34:53 <srhb> greves: putStrLn "foo" -- is a plan for the runtime system to actually put the string "foo" in your stdout
02:35:03 <erisco> merijn, data Unit2 a = Unit2
02:35:46 <suppi> greves, when we evaluate putStrLn "foo", we get the instructions your computer needs to do to actually put the string "foo" in your stdout
02:36:06 <suppi> greves, the instructions themselves will not change, they will always be the same instructions
02:36:16 <greves> ah, ok
02:36:17 <merijn> erisco: Hold on, what do you mean by "unit of kind * -> *"?
02:36:42 <srhb> greves: The reason we talk about plans is that we can manipulate IO-like values to alter or combine plans without ever executing them.
02:36:43 <suppi> greves, but, the execution of this might change
02:36:45 <greves> so the "plan" is just some OS level executable instructions?
02:36:58 <srhb> More like instructions for the runtime system
02:37:40 <suppi> greves, for example if someone close the file descriptor for stdout it will not print "foo".
02:38:17 <suppi> greves, but the plan is still the same. and we can talk about plans, chain plans and compose plans as srhb said. plans are pure, execution of plans is not.
02:38:25 <erisco> merijn, nevermind
02:38:35 <greves> ok, that makes sense
02:39:03 <greves> so the question is basically can we go from a plan back to the parameters that invoked the plan creation?
02:39:21 <greves> going from [IO a] -> IO [a]
02:39:31 <srhb> greves: Depends. I can certainly extract putStrLn "foo" from [putStrLn "foo", ..]
02:40:05 <suppi> greves, this is a list of plans to produce values of type a, and we want to convert it to a plan to produce lists of values of type a
02:40:18 <suppi> greves, this is the meaning of the type signature you wrote
02:40:37 <srhb> greves: Note that [IO a] is NOT a plan (cannot be executed by the RTS)
02:40:38 <greves> it's the one you wrote above
02:40:59 <srhb> Or rather, as we say, an IO action
02:41:00 <greves> we are trying to iterate over a list of IO actions and save the values
02:41:26 <srhb> greves: Are you asking whether a function of that signature is possible? It is, and it's called sequence.
02:41:40 <chattered> @hoogle [IO a] -> IO [a]
02:41:40 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
02:41:40 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
02:41:40 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
02:41:45 <greves> srhb: not whether its possible, i've seen sequence in action, i'm just trying to understand how it works
02:41:52 <suppi> greves, actually, we are just "creating plans" to get values.
02:42:08 <suppi> greves, the runtime will do this for us
02:42:11 <srhb> greves: It takes each action in the list an produces an action which runs them in sequence.
02:42:38 <Sindriava> arahael: Better late than ever: Swift is opensource, therefore as portable as anyone wishes
02:42:42 <srhb> @src sequence
02:42:42 <lambdabot> sequence []     = return []
02:42:42 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:42:42 <lambdabot> --OR
02:42:42 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:42:50 <Sindriava> arahael: As for Foundation etc, the story might be different
02:42:51 <srhb> The first definition should be clear and easy to read
02:43:13 <Sindriava> arahael: Also, I'd like to see some benchmarks and/or data on why javascript on iOS would be considered slow.
02:44:37 <suppi> sequence (x:xs) = x >>= \result -> sequence xs >>= \results -> pure (result : results)
02:44:43 <suppi> sequence [] = pure []
02:44:58 <suppi> you can replace pure with return as well
02:45:27 <srhb> sequence has a Monad constraint, not Applicative, though.
02:45:33 <suppi> greves, we are basically using >>= to chain the operations
02:45:46 <srhb> Not that it matters.
02:45:47 <Sindriava> suppi: You're basically using desugarized do notation.
02:45:56 <suppi> Sindriava, I know.
02:46:04 <greves> Sindriava, its for explanatory purposes
02:46:12 <Sindriava> srhb: It matters in GHC < 7.10 I guess?
02:46:18 <greves> sometimes its hard to see through all the sugar :P
02:46:24 <merijn> I usually recommend not using do-notation until you're comfortable >>=
02:46:26 <srhb> Sindriava: Yes, right.
02:46:28 <merijn> +using
02:46:34 <greves> can't see the cake for the frosting, perhaps?
02:46:41 <Sindriava> "all the sugar"
02:46:43 <suppi> greves, does that make sense?
02:47:04 <greves> sort of i'm trying to understand >>= again, sec
02:47:23 <Sindriava> greves: The most useful part of learning about (>>=) is:
02:47:27 <Sindriava> :t (>>=)
02:47:28 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:47:44 <suppi> greves, In my post I tried to explain it using fmap and join, if this makes it more comfortable for you
02:47:57 <suppi> greves, how we got to >>= I mean
02:48:49 <greves> right =<< is join (fmap f x)
02:49:01 <greves> :t fmap
02:49:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:49:08 <greves> :t join
02:49:09 <lambdabot> Monad m => m (m a) -> m a
02:49:09 <Sindriava> :t join . fmap
02:49:10 <lambdabot>     Occurs check: cannot construct the infinite type: f ~ (->) (f a1)
02:49:10 <lambdabot>     Expected type: (a1 -> a) -> f a1 -> f a1 -> a
02:49:10 <lambdabot>       Actual type: (a1 -> a) -> f a1 -> f a
02:49:12 <srhb> In the case of the IO monad though, it f >>= \a -> ... -- just signifies the "instruction" to run f and bind its result to the name `a`
02:49:24 <liste> :t (join .) . fmap
02:49:25 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
02:49:29 <Sindriava> yah
02:49:41 <suppi> :t (\f x -> join (fmap f x))
02:49:43 <lambdabot> Monad m => (a1 -> m a) -> m a1 -> m a
02:50:07 <Sindriava> :t (=<<)
02:50:08 <lambdabot> Monad m => (a -> m b) -> m a -> m b
02:50:13 <liste> do people use .:, .:., .:: btw?
02:50:21 <Sindriava> :t (.:)
02:50:22 <liste> is there any downsides to them?
02:50:23 <lambdabot>     Not in scope: â.:â
02:50:23 <lambdabot>     Perhaps you meant one of these:
02:50:23 <lambdabot>       â.â (imported from Data.Function),
02:50:36 <suppi> liste, mostly for ascii art I think :)
02:50:40 <Sindriava> :D
02:50:54 <greves> @src fmap
02:50:54 <lambdabot> Source not found. There are some things that I just don't know.
02:50:54 <liste> I find them useful
02:50:57 <greves> @src join
02:50:58 <lambdabot> join x = x >>= id
02:50:58 <merijn> liste: You mean besides being completely fucking unreadble?
02:51:02 <greves> >.<
02:51:23 <liste> I see join .: fmap more readable than (join .) . fmap
02:51:36 <merijn> liste: They're both unreadable
02:51:36 <frerich> I think .: is ok.
02:51:54 <Sindriava> merijn + 1
02:52:18 <greves> i feel like i've never used a computer or written a program or studied math before :P
02:52:19 <suppi> greves, for IO, this is not haskell code
02:52:23 <Sindriava> If making something point-free takes more than 5 seconds, don't do it
02:52:47 <suppi> merijn, i agree
02:53:54 * hackagebot servant-ede 0.5.1 - Combinators for rendering EDE templates in servant web applications  https://hackage.haskell.org/package/servant-ede-0.5.1 (AlpMestanogullari)
02:55:31 <suppi> greves, this is a different way to think about things :)
02:55:56 <srhb> greves: In many ways learning Haskell will, for most people, be like relearning to program. :P
02:56:18 <greves> yeah, i have realized that over the last week
02:56:19 <greves> :P
02:56:26 <srhb> :-)
02:56:40 <greves> its ok though i can see the light at the end of the tunnel, it's far away but pure functions are pretty awesome
02:57:28 <srhb> Good :)
02:58:20 <greves> just brushing up on functors (should have paid more attention in topology :P)
03:01:05 <suppi> I feel like I was lucky enough to discover Haskell while being at school. So many concepts just clicked because I could understand them in a practical way
03:01:50 <suppi> I feel like the reason many programmers think math is useless is because they don't use a programming language that actually lets them use their math knowledge
03:01:53 <greves> yeah i think if i had come across functional programming back then i would have found more to like about programming and math
03:01:59 <srhb> suppi: Yes, exactly.
03:02:25 <greves> i only learned about the existence of haskell/ocaml after doing python, java, and javascript for a few years
03:02:26 <greves> :(
03:02:42 <greves> and only had time to start looking at it seriously now
03:04:58 <suppi> I learned about it from... matt might I think?
03:05:09 <suppi> I don't even know how I got to Haskell in the first place
03:05:17 <suppi> Maybe because of a video of Larry Wall?
03:05:48 <suppi> https://www.youtube.com/watch?v=LR8fQiskYII
03:10:09 <Sindriava> Oh god, I remember seeing one of those videos with Stroustrup
03:16:19 <hvr> greves: better than the other  way round... as once you get hooked by Haskell it's hard to program in any other "lesser" language :)
03:22:36 <Sindriava> hvr: I'd argue that it's only harder to program in a "lesser" language that tries to be a higer language
03:23:14 <Sindriava> hvr: E.g. C++ is a hell after knowing haskell (albeit it was always hell), yet I'm still comfortable with C (because it's kinda timeless)
03:23:40 <hvr> unless you need to do things in C which benefit from abstraction facilities you're used to by Haskell
03:23:46 <grayen> Is there a way to define an instance in terms of a destructured value, e.g. if I have a newtype Foo (Int, k), can I somehow specify an instance for Ord for it, by saying destructure it to k, and define Ord in terms of k?
03:23:50 <hvr> e.g. once you start needing pattern matching in C it becomes sad
03:23:50 <grayen> Ofcourse specifying either compare or <= is enough for Ord, but what if it was some other type class, or I could imagine that defining every other class function in terms of another is less efficient than directly mapping them to k's variants, which may be optimized.
03:24:11 <Sindriava> hvr: if you need pattern matching in C, you don't usually need C :D
03:24:13 <tsahyt> Hello, I have a question about stack: How can I use a local project as an extra dependency with stack? I have a dependency on a package on hackage that depends on packages too old to be in any stackage snapshot (gtkglext to be precise), but the version on Github is updated to work with the newer packages and compiles with stack. How do I tell stack to use that version?
03:24:55 <xpikab> exit
03:25:05 <nshepperd> I was wishing to be able to use Maybe in C++ the other day
03:25:20 <nshepperd> but it turns out to be pretty useless without pattern matching
03:25:49 <Sindriava> C is like the Comic Sans of programming langauges. A great thing in itself, ruined only be the constant misuse by people that won't use anything else
03:30:30 <tsahyt> Nevermind, I figured the stack question out, it's in the FAQ.
03:30:49 <tsahyt> Okay so my one year old project now builds with stack, with minimal modifications. Nice. That's gonna compile for a while now.
03:31:48 <kuribas> Sindriava: C is good for embedded programming.
03:36:23 <nicocbg> hi I have a simple question for haskell experts
03:36:31 <nicocbg> test ::  MonadPlus m => m a
03:36:31 <nicocbg> test =
03:36:33 <nicocbg>     let r = mzero :: m a
03:36:34 <nicocbg>     in let r' :: m a = mzero
03:36:34 <nicocbg>        in  mzero
03:37:00 <nicocbg> I dont understand why the 2 middle expression do not find the monadplus instance
03:37:15 <nicocbg> apparently it freshens up new type variables 
03:37:18 <Intolerable> because they are never used
03:37:25 <liste> nicocbg the `inner' m:s are different from outer `m's
03:37:32 <Intolerable> oh why they do new type variables
03:37:36 <nicocbg> yes
03:37:45 <liste> nicocbg you need ScopedTypeVariables
03:37:45 <nicocbg> is there a way to unify them ?
03:37:55 <liste> a GHC extension
03:38:01 <Sindriava> nicocbg: foo x = let x = 5 in x
03:38:05 <Sindriava> similar problem
03:38:39 <liste> use {-# LANGUAGE ScopedTypeVariables #-}Â and forall m a. MonadPlus m => m a
03:39:18 <tsahyt> nicocbg: Please use a pastebin like lpaste.net in the future. I think you can also solve this by ommitting the type signature in your let binding, but ScopedTypeVariables works in any case.
03:39:34 <nicocbg> ok will do
03:39:47 <nicocbg> oh I get it, I was missing the forall !
03:39:49 <nicocbg> thank you
03:40:15 <MagBo> I wrote a library that provides rebuilding and configuration utility to applications (projects that have Executable in their cabal file)
03:40:16 <nicocbg> liste I had scopedtypevariables, but no forall. thanks a bunch
03:40:21 <MagBo> How'd you test such a thing? 
03:40:21 <liste> yw (:
03:40:55 <MagBo> I'm thinking of somthing like making an example project in test/ directory with its own cabal file and test library from this example.
03:41:27 <MagBo> And, if library is to grow, add standard quickcheck suite for non-trivial pure functions provided.
03:42:09 <tsahyt> So why doesn't this package from LTS Haskell compile? gtk-0.13.6 aborts with a parse error in a .chs file. It's from lts-2.2 though.
03:45:24 <liste> tsahyt do you have gtk2hs-buildtools ?
03:45:45 <liste> or are they still required
03:47:37 <tsahyt> liste: I'm pretty sure that I do yes, I already compiled several gtk versions with cabal, and gtk-0.13.9 from lts-2.22 compiled just a minute ago.
03:48:38 <tsahyt> Okay with 2.22 it works. It seems to be a problem with the package then. Should I report this, considering that it's LTS?
03:51:54 <merijn> Sindriava: C isn't a great thing in itself. C is a piss poor thing and the only redeeming factor it has is that a lot of stuff has been written in it >.>
03:52:11 <Sindriava> merijn: Wrong, you're confusing C with C++.
03:52:20 <merijn> Sindriava: C++ is far better than C
03:52:25 <Sindriava> merijn: C is a direct abstraction over assembly, nothing more and nothing less.
03:52:29 <demize> Modern C*
03:52:35 <demize> erhm, Modern C++*
03:52:40 <Sindriava> demize + 1
03:52:46 <Sindriava> Even then, C++ is the fucking worst
03:52:48 <merijn> C is not a direct abstraction over C, and assembly isn't even a direct abstraction over the CPU
03:52:51 <srhb> Is this relevant to the channel?
03:52:56 <demize> Not really, it's just that people are awful at C++.
03:53:01 <merijn> srhb: Naah, we should move to -blah
03:53:04 <Sindriava> yah
03:53:05 <srhb> :)
03:53:18 <tsahyt> merijn: C++ is probably the worst language I ever had the pleasure of working with. C at least doesn't pretend to do anything but compile to assembler.
03:53:45 <Sindriava> this conversation >>= #haskell-blah
03:53:57 <nicocbg> Do ScopedTypeVariable work for typeclasses contraints binding ?
03:54:20 <nicocbg> I see how I can write  test ::  MonadPlus m => forall  a. m a and reuse a
03:54:35 <nicocbg> but not sure how to quantify over m and reuse m
03:54:52 <merijn> nicocbg: That's a confusing and odd thing to write
03:55:03 <merijn> nicocbg: "forall m a . MonadPlus m => m a" makes more sense
03:55:39 <nicocbg> merjin duh. thank you
04:04:16 <MagBo> Yeah, I want to make a sub-project in test/usage. Obviously, I'll place a cabal file into test/usage/usage.cabal, but how do I refer from it to the source code of the library?
04:05:01 <MagBo> Maybe I should just mention Executable living in test/usage/Main.hs from the main cabal file of the project?..
04:07:11 <Sindriava> liftIO is weird, it breaks (>>=)
04:07:20 <mek42> is a tuple the same as a C struct?
04:07:36 <merijn> mek42: Yes, no, maybe. Depending on your notion of "the same"
04:07:44 <Sindriava> mek42: What does "the same" mean?
04:07:56 <Sindriava> mek42: Does it store structured data? Yes.
04:08:13 <Maxdamantus> is it a product type? yes.
04:08:16 <Sindriava> mek42: Is a tuple a struct underneath? Depends on the implementation I guess.
04:08:21 <mek42> does a tuple in haskell have identical utility as a struct in C?
04:08:39 <Sindriava> mek42: No. It has similar, but not identical.
04:09:20 <Sindriava> mek42: It doesn't have field names for instance.
04:09:34 <Sindriava> Not to mention stuff like alignment, packing and bitfields
04:10:28 <mek42> ah, ok, things my C knowledge never got to
04:12:54 <Sindriava> mek42: Yeah, judging from the question, you're not really proficient at neither C or Haskell, so I'd recommend not trying to compare them like that
04:13:34 <mek42> I'm in the tuple section of "starting out" at LYAH
04:13:56 <Sindriava> mek42: Yeah, just take that stuff as it is, don't try to really tie it to C
04:13:57 * hackagebot json-rpc 0.7.0.2 - Fully-featured JSON-RPC 2.0 library  https://hackage.haskell.org/package/json-rpc-0.7.0.2 (XenoGenesis)
04:14:13 <tsahyt> Sindriava: Since you're talking about packing, when I write something like data T = T !Word8 !Word8 !Word8 !Word8, how does GHC pack this? What will be the total width of the fields in this type?
04:14:30 <ClaudiusMaximus> mek42: Storable is an interface between Haskell data and C-style structs https://www.haskell.org/onlinereport/haskell2010/haskellch37.html
04:14:38 <Sindriava> tsahyt: I don't have a clue Â¯\_(ã)_/Â¯
04:14:57 <Sindriava> tsahyt: I'm nowhere near as familiar with haskell as I'm with C (yet)
04:15:34 <merijn> tsahyt: ! only does strictness, it doesn't unpack anything
04:15:47 <merijn> tsahyt: So T will have 4 pointers to Word8 values
04:15:54 <tsahyt> merijn: Oh right, I meant to annotate {-# UNPACK #-} there.
04:16:00 <merijn> You need to use the {-# UNPACK #-} pragmas
04:16:01 <mek42> ClaudiusMaximus: thanks - I'll read that link after work, to which I must now go - tyvm to all for my one question this morning :)
04:16:09 <merijn> In which case it'll be 4 words
04:17:28 <pacak> recent ghc will unbox small strict fields by default.
04:18:16 <pacak> But T will still take 4 full words
04:18:19 <pacak> use bitpacking.
04:18:45 <merijn> Or don't
04:18:55 <merijn> Unlikely to make you faster unless you know what you're doing
04:20:21 <tsahyt> Well the merit obviously depends on the restrictions. Bitpacking makes much more sense when you have severe memory limitations (or just use a *lot* of values with such a type). Then again, environments with memory limitations aren't exactly Haskell's strong suit anyways.
04:20:47 <tsahyt> Is there a way to use bitpacking in Haskell regardless?
04:21:47 <merijn> tsahyt: Only if you do it explicitly yourself
04:22:17 <hodapp> I'm doing this in Ivory, but that doesn't have anything to do with Haskell's runtime - it's in the generated C code
04:22:59 <tsahyt> merijn: So, data T = T {-# UNPACK #-} !Word32, plus accessor functions?
04:23:18 <merijn> tsahyt: Yeah
04:23:50 <pacak> tsahyt: Don't need {-# UNPACK #-} if ghc is recent enough.
04:24:17 <pacak> don't need data either - newtype should do the trick.
04:25:19 <hodapp> tsahyt: do you have an existing program that's using up way too much memory without this custom packing?
04:25:51 <tsahyt> hodapp: No, it's a purely academical question at that point. I did use a type like that in a raytracer though, to store 4 channel color information.
04:26:44 <hodapp> tsahyt: it just reeks of premature optimization to me. It's well within the realm of possibility that with laziness and sharing you need nowhere near the amount of memory, despite higher overhead in the packing.
04:27:47 <tsahyt> hodapp: I used the simpler version with 4 Word8s in it. Never had any real problems with it actually. I'm just constantly curious what kind of optimizations GHC (or any compiler really) performs.
04:30:06 <merijn> packing is the sorta stuff you shouldn't consider until VTune tells you too
04:32:37 <tsahyt> TIL about VTune. $899 is a hefty price tag though.
04:33:07 <merijn> tsahyt: You can get a student copy for free, iirc
04:33:16 <merijn> Assuming you're a student that is.
04:33:40 <merijn> OTOH, if your job is optimising high performance code, that's probably the best $899 your boss will invest :p
04:33:46 <merijn> I was thoroughly impressed by it
04:35:22 <tsahyt> merijn: In fact I am a student, but I don't like getting used to software that I can't afford once it stops being free for me. I don't use Mathematica either for that reason, even though I have a student license. VTune looks like something I should keep in mind though. For a business, $899 isn't too bad.
04:36:12 <merijn> tsahyt: It will give you insane details like "this line compiled to this assembly and on this specific instruction your blocked due to an L2 cache miss"
04:36:31 <hugofirth> tsahyt Its also free for OSS I think
04:37:25 <Fay> what software are yall talking about?
04:37:33 <merijn> Fay: Intel VTune
04:37:41 <Fay> really?
04:38:10 <merijn> hugofirth: Cool, looks like you're right
04:39:45 <tsahyt> hugofirth: Now that sounds great. I'll look into it, thanks!
04:40:08 <hugofirth> tsahyt np
04:48:14 <zeling> @type map
04:48:15 <lambdabot> (a -> b) -> [a] -> [b]
04:48:35 <zeling> > take 4 [1..]
04:48:37 <lambdabot>  [1,2,3,4]
04:53:59 * hackagebot regex-pderiv 0.1.4 - Replaces/Enhances Text.Regex. Implementing regular expression matching using Antimirov's partial derivatives.  https://hackage.haskell.org/package/regex-pderiv-0.1.4 (KennyLu)
04:54:20 <haskell381> why these two instances of MonadSTM are overlapping? http://lpaste.net/5031755110129074176
04:55:17 <merijn> What is MonadSTM?
04:55:41 <haskell381> It's custom class, shamelesly stolen from a hackage lib
04:56:35 <haskell381> merijn: edited, please have a look
04:58:37 <merijn> haskell381: "WebStateM s" overlaps with "(MonadTrans t, Monad m) => MonadSTM (t m)"
04:59:45 <haskell381> merijn: ooh yeah..:(
05:00:34 <codedmart> I am getting this warning now with travis `'ghc-prof-options: -fprof-auto' is fine during development, but â¦`. I wasn't getting that warning before. Is this newly not recommended?
05:11:15 <danilo2> Hello Guys! :) Do you know why the extensible-effects library (https://hackage.haskell.org/package/extensible-effects-1.11.0.0) doesn't support such effects like Maybe o Either? Or it does somehow but I didn't discovered it somehow?
05:13:31 <aleator> Hello! Is there a guide/tutorial to stack somewhere? Idea of lts is attractive, but I can't figure out how to use stack for most common things like initializing a project that depends on another local project.
05:16:15 <liste> aleator the FAQ is pretty good for that
05:16:18 <liste> https://github.com/commercialhaskell/stack/wiki/FAQ
05:16:41 <liste> 4th question
05:17:12 <aleator> liste: So I just write the stack.yaml by hand instead of doing stack init?
05:17:56 <liste> does stack init fail?
05:18:38 <aleator> liste: Yes, because it can't see where to find the local dependency (since I can't figure out how to tell it where it is=
05:20:22 <aleator> Also, I don't seem to be able to figure out if I'm supposed to spend effort in sharing the stack sandboxes or if that is done for me automatically
05:21:22 <aleator> Oh.. I think I did figure that out..
05:23:10 <liste> aleator how?
05:23:52 <liste> and which problem
05:26:28 <nullvoid8_> Danilo2: maybe is isomorphic to either (). Take a look at the exception effect?
05:26:44 <aleator> liste: I can just put stack.yaml somewhere and point at it with an env- variable causing things to be shared with several projects.
05:27:15 <aleator> Also, it seems that just writing stack.yaml and doing stack build --resolver=lts-3.0 works..
05:31:34 <aleator> So, now I added a dependency to foo.cabal. How do I command stack to install it?
05:34:55 <tsahyt> Why does ghc-mod act up sometimes ever since I started using it with stack? I get "launching operating system process `cabal configure` failed" and a message from cabal that it is incompatible with GHC_PACKAGE_PATH and I should use --package-db instead. Does anybody know the reason for that, or even a fix?
05:38:39 <bergmark> aleator: stack build
05:40:26 <danilo2> nullvoid8_: ok thanks, I'm looking there right now! :)
06:06:33 <cow_2001> where do i find the new hypertext version of hackaged packages?
06:08:18 <Gurkenglas_> hexagoxel: Can you make exferencebot able to handle further queries in parallel while one is running?
06:09:31 <obiwahn> http://pastebin.com/UJrhjfbK is there some easy way to fix this or do i have to wait?
06:10:07 <tsahyt> Is there a way to specialize type variables when inspecting types in ghci?
06:10:13 <srhb> obiwahn: You can probably try bumping the constraints yourself.
06:10:25 <srhb> obiwahn: cabal unpack the package and edit the cabal file, see if it compiles. :)
06:10:55 <srhb> obiwahn: (also did you notice that package is long deprecated?)
06:11:46 <srhb> obiwahn: In other words if you don't fix it, you can wait forever. :P
06:12:20 <pavonia> cow_2001: What new version do you mean?
06:12:24 <cow_2001> O_O
06:12:27 <obiwahn> mh i have compiled xmobar on 2 other pcs a day ago or so:)
06:12:43 <obiwahn> uuh i have to learn haskell:P
06:13:19 <cow_2001> sometimes when you browse code within the http://hackage.haskell.org website, you get the source with all the highlights and colours
06:13:22 <srhb> obiwahn: Perhaps you should simply select other, non-deprecated packages :)
06:13:42 <srhb> cow_2001: That's not enabled for most of it yet. Consider it an alpha preview. :-)
06:13:47 <cow_2001> oh
06:13:52 <cow_2001> dingit :(
06:14:18 <srhb> Yeah, it IS a rather awesome feature
06:15:26 <pavonia> cow_2001, srhb: Do you have an example?
06:15:27 <cow_2001> it wouldn't have been so bad if people would import specifically all the names they use >:(
06:15:36 <srhb> cow_2001: How do you mean?
06:15:49 <cow_2001> srhb: import Package (name1, name2)
06:16:02 <srhb> pavonia: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Control.Applicative.html
06:16:09 <srhb> cow_2001: Ah!
06:16:39 <pavonia> Nice, thanks
06:17:31 <cow_2001> that's one thing i love about python. within its culture `from Package import *` is considered harmful
06:17:59 <pavonia> I'm wondering why it has a pink background color, though
06:18:16 <cow_2001> it's sepia for me
06:18:23 <cow_2001> not pink
06:18:25 <dramforever> cow_2001: jump to definition considered useful
06:18:54 <dramforever> I guess that's why people don't seem to hate it *that* much
06:18:58 <dramforever> =)
06:19:12 <cow_2001> dramforever: hmm?
06:20:12 <cow_2001> it's just so frustrating trying to figure out new code when i constantly have to figure out from which module this name is coming from
06:20:33 <dramforever> yes, exactly what I was talking about
06:20:47 <dramforever> cow_2001: you just need some form of jump to definition
06:20:54 <rlewis> doesn't last "from package import *" python overwrite all the prior definitions in case of a name conflict?
06:21:03 <rlewis> *in python
06:21:04 <dramforever> oh yes that's another
06:21:19 <cow_2001> rlewis: that's why it's considered harmful
06:21:31 <cow_2001> probably other reasons? i don't remember
06:21:42 <cow_2001> oh, the reason i've mentioned
06:21:51 <cow_2001> you don't know which name came from where
06:21:55 <dramforever> actually there's anothing in haskell
06:21:59 <dramforever> *another thing
06:22:12 <dramforever> the typeclass system
06:22:35 <dramforever> this way you actually don't have to export many names
06:22:59 <cow_2001> please explain?
06:23:16 <dramforever> functions like null, length, foldl, fmap, etc. are available in typeclasses
06:23:24 <dramforever> so basically you just export a type
06:23:39 <cow_2001> ah
06:24:06 <cow_2001> there's an already established API over those typeclasses
06:24:16 <dramforever> exactly
06:24:23 <dramforever> that's even better than qualified imports
06:24:37 <cow_2001> but you can't do that for everything
06:24:51 <dramforever> that's true
06:25:11 <dramforever> but then it will be very specialized, and you don't have to worry about name clashes
06:25:20 <dramforever> again, jump to definition helps a lot
06:27:15 <cow_2001> trying to figure out how
06:27:41 <dramforever> "hey what's this function?" -> click -> oh wow
06:28:37 <dramforever> forget about it, it suck
06:28:39 <dramforever> *sucks
06:29:57 <cow_2001> ??
06:30:00 <cow_2001> O_o
06:44:29 <lmnshtm> asdf
06:53:31 <ironChicken> how can i map peekCString to [IO String]?
06:54:00 <mauke> ?
06:56:32 <aweinstock> :t Foreign.C.peekCString
06:56:33 <lambdabot> Foreign.C.String.CString -> IO String
06:56:40 <int-e> :t mapM Foreign.C.peekCString
06:56:41 <lambdabot> Traversable t => t Foreign.C.String.CString -> IO (t String)
06:57:02 <ironChicken> actually, i mean [IO CString]
06:57:06 <dramforever> :t map (>>= Foreign.C.peekCString)
06:57:08 <lambdabot> [IO Foreign.C.String.CString] -> [IO String]
06:57:08 <aweinstock> :t return . Foreign.C.peekCString :: [IO String]
06:57:10 <lambdabot>     Couldn't match expected type â[IO String]â
06:57:10 <lambdabot>                 with actual type âForeign.C.String.CString -> m0 (IO String)â
06:57:10 <lambdabot>     In the expression:
06:57:20 <dramforever> ironChicken: like my function?
06:57:38 <ironChicken> dramforever: quite possibly
06:57:55 <aweinstock> what is it that you currently have, and are trying to do?
06:58:27 <dramforever> um *expression
06:59:18 <aweinstock> :t return . Foreign.C.peekCString :: Foreign.C.String.CString -> [IO String]
06:59:19 <lambdabot> Foreign.C.String.CString -> [IO String]
07:00:43 <ironChicken> aweinstock: i want [IO CString] -> IO [String]
07:01:18 <ironChicken> the [IO CString] came cons together some calls to a foreign function which returns IO CString
07:01:40 <ironChicken> s/came cons/came from consing/
07:01:43 <jameseb> :t mapM (>>= Foreign.C.peekCString)
07:01:44 <aweinstock> :t mapM Foreign.C.peekCString
07:01:45 <lambdabot> Traversable t => t (IO Foreign.C.String.CString) -> IO (t String)
07:01:46 <lambdabot> Traversable t => t Foreign.C.String.CString -> IO (t String)
07:02:04 <dramforever> I still think my version is the correct one
07:02:47 <aweinstock> :t mapM (>>= Foreign.C.peekCString) :: [IO Foreign.C.String.CString] -> IO [String]
07:02:48 <lambdabot> [IO Foreign.C.String.CString] -> IO [String]
07:02:55 <jameseb> ironChicken: mapM (>>= peekCString) seems to match what you want
07:03:18 <ironChicken> jameseb: yes it does. and ghc seems to like it too
07:03:29 <dramforever> yep still seems fine
07:03:48 <dramforever> oh I know, mine needs another sequence
07:03:50 <dramforever> :t sequence
07:03:52 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
07:04:23 <ironChicken> before, i was trying to do: map peekCString
07:04:31 * ironChicken needs more practice
07:04:43 <dramforever> ironChicken: don't worry
07:04:57 * dramforever pats on ironChicken's program
07:05:12 <ironChicken> thanks :-)
07:05:25 <dramforever> you're welcome
07:22:36 <webchat099> h
07:23:42 <dramforever> ask your question if you have one
07:23:58 <dramforever> you don't need to ask to ask
07:59:32 <orcus> Is there any reason Data.Type.Equality is not marked as trustworthy?
08:03:38 <nitrix> Snap looked easy until I got into Heist -.-
08:03:49 <nitrix> This stuff isn't beginner friendly at all.
08:06:56 <suppi> nitrix, I tried working with Snap once. it didn't work between us so I turned to scotty
08:07:16 <nitrix> I'm strongly considering Yesod.
08:07:33 <nitrix> Somehow the DSL speaks to me.
08:09:52 <bergmark> yeah heist gets pretty complicated...
08:14:53 <nitrix> Blaze seems super cool. I might just plug a whole bunch of things togheter.
08:24:16 * hackagebot fasta 0.8.0.0 - A simple, mindless parser for fasta files.  https://hackage.haskell.org/package/fasta-0.8.0.0 (GregorySchwartz)
08:32:44 <SwashBuckla_> I have a function with type signature `kind :: Int -> [Int] -> Maybe Int` which returns the number of items in a list of the same kind
08:33:10 <SwashBuckla_> at the moment, I process it like this: kind x xs = (fst . head . filter (\(a, b) -> b == x) . map (\a -> (head    May a, length a)) . group) xs
08:33:27 <SwashBuckla_> headMay*
08:34:05 <SwashBuckla_> this works fine except when I query it with a number of elements not in the list
08:35:24 <SwashBuckla_> then I get *** Exception: Prelude.head: empty list
08:35:51 <reubensammut> SwashBuckla_ head may filter may not return any results
08:36:03 <reubensammut> so the head before it will fail
08:36:05 <SwashBuckla_> reubensammut: precisely
08:36:25 <SwashBuckla_> so how do I propagate `Nothing`?
08:36:44 <SwashBuckla_> i.e. if I have Nothing, just pass it up, otherwise do (fst . head) on it
08:37:06 <mauke> fmap (fst . head)
08:37:42 <hodapp> bah, in my TH noob-ness I cannot see how to turn a String to a Q Exp
08:38:17 <mbrock> SwashBuckla_, I believe your function can also be written more simply by combining length and `filter (== x)`
08:38:39 <mauke> SwashBuckla_: why is there a Nothing involved?
08:38:51 <JAPAN> i've been playing for haskell for about a week
08:39:01 <SwashBuckla_> mauke: because there may not be anything of `kind x` in the list
08:39:06 <JAPAN> still can't find any good ide, any recommendations?
08:39:08 <JAPAN> i'm on os 
08:39:09 <JAPAN> x
08:39:11 <SwashBuckla_> mauke: and I want to know that via a Nothing
08:39:22 <mauke> SwashBuckla_: yeah, but that would be in the result, not in the middle of the list
08:39:37 <mauke> also, what's a kind?
08:39:38 <bergmark> JAPAN: Leksah seems to be the best from what i've heard, but i've never tried it
08:39:40 <suppi> JAPAN, Atom?
08:40:01 <aweinstock> hodapp: return . LitE . StringL
08:40:13 <SwashBuckla_> mauke: it's for a poker game :)
08:40:28 <aweinstock> :t return . Language.Haskell.TH.LitE . Language.Haskell.TH.StringL
08:40:30 <lambdabot> Monad m => String -> m Language.Haskell.TH.Syntax.Exp
08:40:39 <hodapp> aweinstock: well, particularly what I'm trying to do is evaluate the string.
08:41:05 * mbrock has recently gone back to using a text editor without any special language modes... it's nice to be rid of all the random coloring and boldness and unpredictable indent magic
08:41:05 <hodapp> aweinstock: it contains an identifier name (because some other TH code I'm trying to relate this to has already created such a declaration)
08:41:42 <mauke> :t \k xs -> listToMaybe [ x | r@(x : _) <- group xs, length r == k ]
08:41:43 <lambdabot> Eq a => Int -> [a] -> Maybe a
08:42:10 <aweinstock> (I'm not particularly skilled at TH, but I've used that specifically before for file literals: https://github.com/aweinstock314/chess-server/blob/master/server/ChessUtil.hs#L7)
08:42:48 <mauke> > (\k xs -> listToMaybe [ x | r@(x : _) <- group xs, length r == k ]) 3 [2,7,10,10,12]
08:42:50 <lambdabot>  Nothing
08:42:54 <mauke> > (\k xs -> listToMaybe [ x | r@(x : _) <- group xs, length r == k ]) 3 [2,7,10,10,10]
08:42:56 <lambdabot>  Just 10
08:44:55 <aweinstock> hodapp: if you havn't solved the TH thing yet, lpaste it and I can try to help
08:44:58 <SwashBuckla_> mauke: strange.. didn't know listToMaybe was equivalent to headMay
08:47:00 <monochrom> https://ro-che.info/ccc/26
08:47:26 <safinaskar> how to enable "exists" keyword?
08:47:36 <safinaskar> and in what ghc versions it is supported?
08:47:41 <mauke> install ... uhc, I think?
08:49:49 <geekosaur> safinaskar, ghc does not have "exists"
08:49:54 <Cale> safinaskar: none.
08:50:06 <geekosaur> (and yes, I think that was uhc)
08:51:37 <aweinstock> safinaskar: I think that "forall" on the right-hand side of a data declaration is equivalent to "exists"
08:51:44 <hodapp> aweinstock: too much other surrounding code with Ivory to really make it worth it. I have a list with ["foo", "bar", "baz"], and foo, bar, and baz are top-level identifiers that some other TH code has generated. I need a Q Exp with [foo, bar, baz].
08:52:05 <Cale> safinaskar: There are other type theories which have an explicit exists. GHC's existential types are just expressed as types with constructors that have a (forall quantified) type variable in the types of their arguments that doesn't occur in the type of the result.
08:52:11 <fosterite> I think I've got it: it's not that toList defines foldable, but that Foldable means "give me an a -> r -> r and an f a and I'll give you an r" and [a] is the free structure for that r?
08:52:20 <aweinstock> data ExistsShow = forall a. Show a => ExistsShow -- or something like this?
08:52:58 <Cale> Having a constructor like  C :: forall a. (a -> a) -> a -> (a -> String) -> T
08:53:20 <Cale> is equivalent to having  C :: (exists a. (a -> a, a, a -> String)) -> T
08:54:26 <safinaskar> mauke: geekosaur: Cale: aweinstock: thanks
08:54:49 <aweinstock> hodapp: otherTHCode >>= (\listOfIdentifiers -> return $ map (LitE . StringL) listOfIdentifiers)
08:55:11 <aweinstock> (which should be golfable to: fmap (map (LitE . StringL)) otherTHCode)
08:56:22 <greves> why does this code from http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity not work? getStringAndPrint = print (getStringFromStdin)
08:56:32 <greves> No instance for (Show (IO String)) arising from a use of âprintâ
08:56:50 <aweinstock> getStringFromStdin >>= print
08:56:54 <Cale> greves: Because there's no way to turn an IO action into a String
08:57:06 <Cale> greves: It's an abstract data type, and doesn't have a Show instance (usually)
08:57:20 <hodapp> aweinstock: ahh, I see what you're doing now
08:57:25 <Cale> You can write a Show instance for IO actions, but it won't be able to tell you much useful information about the action.
08:57:45 <Cale> > getLine
08:57:47 <lambdabot>  <IO [Char]>
08:58:04 <Cale> ^^ lambdabot has such an instance of Show, which just shows the type of the action
08:58:52 <greves> i see
08:58:54 <Cale> greves: You could imagine a system for IO which allowed annotating IO actions with some additional textual information about what the action did, I suppose.
08:59:53 <mauke> annotate launchMissiles "totally not launching any missiles, promise"
09:00:17 <greves> ok but basicaly the only thing we could know about it would be "Display [Char] on stdin" or something?
09:00:49 <Cale> greves: Yeah, you can't know what String you'll get when you actually run the action without executing it and seeing what the user types.
09:00:55 <greves> right
09:01:13 <greves> sorry rather that would be 'Read [Char] from stdin'
09:01:19 <Cale> greves: (and evaluation generally never causes execution of IO actions to occur)
09:01:40 <Cale> yeah
09:02:15 <aweinstock> > cycle [getChar]
09:02:17 <lambdabot>  [<IO Char>,<IO Char>,<IO Char>,<IO Char>,<IO Char>,<IO Char>,<IO Char>,<IO C...
09:02:51 <aweinstock> > length . take 10 $ cycle [getChar]
09:02:53 <lambdabot>  10
09:03:23 <Cale> > sequence (cycle [getChar])
09:03:26 <lambdabot>  <IO [Char]>
09:04:19 <aweinstock> Cale: does (sequence (cycle [getChar])) do the same thing as (hGetContents stdin)?
09:05:04 <Cale> aweinstock: not quite. hGetContents is magic
09:05:22 <aweinstock> because of Lazy IO?
09:05:35 <Cale> The execution of hGetContents is instantaneous, and it gives you a magical String whose evaluation will wait for characters to come in.
09:05:40 <greves> why does the author use main = getStringFromStdin >>= (\result -> print result)
09:05:49 <greves> isn't that exactly the same as getStringFromStdin >>= print ?
09:05:50 <aweinstock> :t [sequence (cycle [getChar]), System.IO.hGetContents System.IO.stdin]
09:05:51 <lambdabot> [IO [Char]]
09:05:54 <Cale> greves: it is.
09:05:58 <nitrix> greves: It is.
09:06:07 <aweinstock> greves: yes, that's called eta-reduction (or eta-expansion)
09:06:15 <Cale> greves: Maybe they're just trying to help you see how to get hold of a variable that is the result of the action.
09:06:28 <Cale> (in case you wanted to do more things than just to print it)
09:06:33 <greves> aweinstock: is that a math thing or a haskell thing?
09:06:44 <aweinstock> for all f, (\x -> f x) = f
09:06:47 <Cale> aweinstock: A lambda calculus thing
09:06:48 <aweinstock> both
09:07:29 <lamefun> Haddock: data Requirement .. Constructors .. RequireVersion Requirement. How to make it to disambiguate between Requirement (defined in the documented package) and Requirement (defined in Version package)? Eg. "RequireVersion Version.Requirement"?
09:07:50 <Cale> greves: It's also equivalent to  main = do result <- getStringFromStdin; print result
09:07:56 <nitrix> greves: I think the point is showing you what you actually get to work with. In this case, yeah it can be reduced because the output from getStringFromStdin is exactly what print is expecting as an argument, thus you can perform ETA reduction.
09:07:57 <kazagistar> greves: "If you have a function that does nothing but pass its parameter to another function, it can just be replaced by that other function"
09:08:06 <andrewsw> is there any way to query the ghc rts to get data about number of running threads, their allocations and such? pointers to docs welcome.
09:08:12 <Cale> I don't know why they're using the name  getStringFromStdin  rather than something like  getLine  which is actually in Haskell.
09:08:12 <aweinstock> @do (>>=)
09:08:12 <lambdabot> (>>=)
09:08:21 <aweinstock> @do x >>= f
09:08:21 <lambdabot> do { a <- x; f a}
09:08:25 <greves> Cale yeah he has getStringFromStdin = getLine a few lines above :P
09:08:40 <nitrix> greves: That's another example of ETA reduction right there
09:08:50 <Cale> greves: One nice analogy about IO actions (though I think you get it), is that getLine is as much like a String, as /bin/ls is like a list of files.
09:08:55 <hodapp> aweinstock: this appears to be doing nothing more than giving me ["foo", "bar", "baz"] again.
09:08:55 <nitrix> :t getLine
09:08:56 <lambdabot> IO String
09:09:12 <nitrix> Or not. It has no arguments, nvm.
09:09:17 <greves> right
09:09:29 <greves> starting to make sense finally :P
09:09:52 <hodapp> aweinstock: shame that http://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH.html has no docs on varE, litE, stringL, and so on.
09:09:56 <lamefun> This behavior is annoying when reading documentation of functions that work on Text, I have to hover to check whether it's Data.Text.Text or Data.Text.Lazy.Text.
09:10:10 <aweinstock> hodapp: how are you inspecting the output? LitE . StringL /= id
09:10:28 <hodapp> aweinstock: I'm looking at the splices.
09:11:09 <aweinstock> hodapp: I think I used :browse Language.Haskell.TH when I found those constructors (and probably :info)
09:11:37 <hodapp> aweinstock: it looks like it needs to be varE . mkName.
09:12:23 <aweinstock> hodapp: could you lpaste the code? (you don't need to spend time minimizing it)
09:12:55 <geekosaur> hodapp, looking stuff up for nkaretnikov yesterday led me to discover that the docs in the haddock are basically what is different from the original TH paper linked at the top of the haddock
09:12:56 <greves> would i be correct in saying that its essentially just like a first class function in python or javascript when you use it as an argument or a return value without calling via the parenthesis fn() ?
09:13:07 <hodapp> aweinstock: and I'm not seeing how constructing a string literal even *should* work here
09:13:22 <geekosaur> as you likely need to know how stuff fits together inside of ghc and not just what constructors exist, I'd read that paper first
09:13:55 <hodapp> geekosaur: I'll give it a read soon
09:14:07 <hodapp> I generally avoid TH but here I sort of had to use it
09:14:28 <aweinstock> hodapp: someString :: String; someString = $(return . LitE . StringL $ "this could be the result of a more complicated TH computation")
09:15:28 <mauke> aweinstock: why are you trying to construct string literals?
09:15:56 <hodapp> aweinstock: that is, again, a string literal.
09:16:00 <aweinstock> greves: explicitly delaying IO in strict languages via 0-argument functions (thunks) is somewhat similar
09:16:26 <aweinstock> mauke: I'm not entirely sure what hodapp is trying to do, but it's something involving TH and Ivory
09:16:57 <scshunt> I upgraded GHC and now it wants -package arguments for everything
09:16:59 <mauke> aweinstock: he has a list of strings, and he's trying to build a list of variables via TH
09:17:00 <scshunt> I'm working with some legacy code
09:17:08 <mauke> the strings are variable names
09:17:12 <scshunt> is there a flag to make it look up packages like the old behaviour?
09:17:24 <hodapp> mauke: yes, and varE . mkName appears to be the thing I was missing.
09:18:55 <aweinstock> hodapp: be careful around mkName (it's subject to the same kind of capture problems that common lisp solves with gensym, I think)
09:19:11 <greves> @src putStrLn
09:19:11 <lambdabot> putStrLn s = do putStr s; putChar '\n'
09:19:16 <greves> @src PutStr
09:19:16 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:19:24 <greves> @src putStr
09:19:24 <lambdabot> putStr s = hPutStr stdout s
09:19:30 <greves> @src hPutStr
09:19:30 <lambdabot> Source not found. Where did you learn to type?
09:19:34 <aweinstock> hodapp: I think newName is the equivalent of CL's gensym
09:19:59 <hodapp> aweinstock: I'm trying to refer to an existing identifier though, not create a fresh name
09:20:16 <aweinstock> hodapp: mkName is probably what you want then, I'm just making sure you know the difference
09:20:25 <greves> no source for hPutStr?
09:21:19 <aweinstock> greves: http://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.IO.Handle.Text.html#hPutStr
09:21:28 <aweinstock> (it's not particularly enlightening though)
09:25:16 <geekosaur> the @src database is very small and sometimes does not relfect reality. it's just a text file that's been shipped with lambdabot for years...
09:26:00 <Welkin> what is with GHC.Prim?
09:26:07 <Welkin> most of the functions have the same definition
09:26:15 <Welkin> `let x = x in x`
09:26:20 <Welkin> what is going on?
09:26:28 <Welkin> word2Double# :: Word# -> Double#
09:26:30 <Welkin> word2Double# = let x = x in x
09:26:45 <levi> GHC.Prim is the module wherein the primitive operations of the runtime are exposed.
09:26:57 <Welkin> er, better example is 
09:26:57 <Welkin> quotRemWord2# :: Word# -> Word# -> Word# -> (# Word#,Word# #)
09:26:58 <Welkin> quotRemWord2# = let x = x in x
09:27:00 <nkaretnikov> Welkin: its a hack
09:27:03 <aweinstock> Welkin: (let x = x in x) = bottom
09:27:08 <nkaretnikov> it's*
09:27:14 <nitrix> Welkin: Probably a compiler hack, considering the kinds. # -> #
09:27:15 <aweinstock> GHC.Prim is just there for Haddock to generate documentation
09:27:15 <Intolerable> its "undefined" without actually using "undefined"
09:27:24 <Welkin> okay
09:27:26 <levi> The real implementation is not where you're looking; it's in the GHC runtime.
09:27:52 <Welkin> > let x = 3 in x
09:27:54 <lambdabot>  3
09:28:04 <aweinstock> > let x = x in x
09:28:08 <lambdabot>  mueval-core: Time limit exceeded
09:28:24 <Welkin> I see
09:28:47 <levi> remember that let in Haskell is recursive by default
09:28:53 <Welkin> this all started with finding `coerce` in Data.Monoid and wondering what that was
09:29:19 <Welkin> so there is no way to see how these are actually implemented?
09:29:32 <levi> Sure there is, you just have to look in the GHC runtime source.
09:29:35 <nkaretnikov> Welkin: you need ghc source
09:29:54 <levi> But I think SPJ described what coerce does in a video.
09:30:10 <Welkin> well, I see what it does based on the comments for it
09:31:20 <Welkin> what is it written in?
09:32:03 <aweinstock> I think the GHC runtime is written in a subset of C called Cminusminus (but I'm not entirely sure)
09:32:21 <suppi> I think C-- is not for humans to write
09:32:24 <demize> It's both C and C--
09:32:56 <aweinstock> Welkin: where is the call to coerce in Data.Monoid? can you link the source?
09:32:58 <Welkin> oh wow
09:33:02 <Welkin> SPJ invented C--
09:33:21 <demize> Actually, it seems that it's almost but not quite C--
09:33:22 <Welkin> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Monoid.html#Sum
09:33:23 <Cale> Yeah, C-- came from GHC originally.
09:33:39 <Welkin> aweinstock: it is used for Sum and Product
09:33:46 <levi> The C-- in GHC has evolved away from the C-- that exists independently.
09:33:51 <Cale> right
09:33:54 <Welkin> although why not just use Sum and Product
09:34:20 <aweinstock> oh, that's used to "forget" the "Num a =>" constraint
09:34:28 <demize> "One unintuitive thing to watch out for is that there are no function calls in low-level cmm code" <- that is indeed unintuitive..
09:34:40 <Intolerable> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#mappend = coerce ((https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Num.html#%2A) :: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Monoid.html#local-1627470861 -> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Monoid.html#local-1627470861 -> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Monoid
09:34:44 <Intolerable> oops
09:34:57 <aweinstock> wait, no, the :: is on the inside of coerce...
09:35:07 <Intolerable> mappend = coerce ((*) :: a -> a -> a)
09:35:30 <Intolerable> is that not because otherwise it's ambiguous?
09:35:36 <aweinstock> :t (*)
09:35:37 <lambdabot> Num a => a -> a -> a
09:35:46 <aweinstock> :t (*) :: a -> a -> a
09:35:47 <lambdabot>     No instance for (Num a1) arising from a use of â*â
09:35:48 <lambdabot>     Possible fix:
09:35:48 <lambdabot>       add (Num a1) to the context of
09:36:01 <Intolerable> the a is scoped
09:36:03 <aweinstock> :t Unsafe.Coerce.unsafeCoerce
09:36:04 <lambdabot> a -> b
09:36:18 <levi> The point of coerce, if I remember correctly, is to remove the abstraction penalty associated with newtype wrappers without losing the type safety benefits.
09:36:18 <Zemyla> Hmm. Is there anything that can be done with a string given in DataKinds?
09:36:18 <aweinstock> :t Unsafe.Coerce.unsafeCoerce ((*) :: a -> a -> a)
09:36:20 <lambdabot>     No instance for (Num a) arising from a use of â*â
09:36:20 <lambdabot>     Possible fix:
09:36:20 <lambdabot>       add (Num a) to the context of
09:36:21 <Intolerable> :t Sum
09:36:22 <lambdabot> a -> Sum a
09:36:43 <demize> "Use StgInt8, StgInt16, etc when you need a certain minimum number of bits in a type." :/
09:36:50 <Welkin> why not just use: Sum . (+)
09:36:51 <aweinstock> :t Sum "Hello"
09:36:52 <lambdabot> Sum [Char]
09:37:00 <demize> Uses POSIX -> defines custom types instead of using the POSIX ones >.>
09:37:02 <Intolerable> :t Sum . (+)
09:37:03 <lambdabot> Num a => a -> Sum (a -> a)
09:37:09 <aweinstock> :t Sum "Hello" <> Sum "world"
09:37:10 <lambdabot>     No instance for (Num [Char]) arising from a use of â<>â
09:37:10 <lambdabot>     In the expression: Sum "Hello" <> Sum "world"
09:37:11 <Welkin> er
09:37:23 <Zemyla> Like, can you even check and see if the string is empty?
09:37:31 <Intolerable> it's because it requires unwrapping and re-wrapping Sums
09:37:33 <Intolerable> inside a list
09:37:35 <Intolerable> which is not free
09:37:37 <Intolerable> without coerce
09:38:04 <Cale> For Sum and Product, I don't know that those coerces are actually saving anything.
09:38:10 <Cale> That's kind of weird
09:38:15 <aweinstock> :t Sum . (+) . getSum
09:38:16 <lambdabot> Num a => Sum a -> Sum (a -> a)
09:38:26 <Cale> They're newtypes, so the constructor packing/unpacking is a no-op
09:38:31 <Intolerable> (Sum .) . (+) . getSum
09:38:34 <Intolerable> :t (Sum .) . (+) . getSum
09:38:36 <lambdabot> Num a => Sum a -> a -> Sum a
09:38:36 <aweinstock> :t (Sum .) . (+) . (. getSum)
09:38:37 <lambdabot> Num (Sum b -> c) => (b -> c) -> (Sum b -> c) -> Sum (Sum b -> c)
09:38:48 <Intolerable> > the constructor packing/unpacking is a no-op
09:38:49 <lambdabot>  Not in scope: âtheâNot in scope: âconstructorâ    Not in scope: âpackingâ
09:38:49 <lambdabot>      Perhaps you meant one of these:
09:38:49 <lambdabot>        âpassingâ (imported from Control.Lens),
09:39:02 <Intolerable> yes, but when you also have to decons the list it becomes not-free
09:39:07 <Cale> Intolerable: What list?
09:39:12 <Intolerable> mappend
09:39:19 <Franciman> Hello
09:39:23 <aweinstock> :t (Sum .) . (+) <*> getSum <*> getSum
09:39:23 <Cale> We're talking about the implementation of mappend, no?
09:39:24 <lambdabot>     Couldn't match type âSum (Sum a)â with âa -> bâ
09:39:24 <lambdabot>     Expected type: Sum a -> Sum a -> a -> b
09:39:24 <lambdabot>       Actual type: Sum a -> Sum a -> Sum (Sum a)
09:39:30 <Cale> There's no list.
09:39:31 <Intolerable> oh wait mappend != sum
09:39:32 <Intolerable> derp
09:39:45 <Intolerable> ok yeah i have no idea then
09:40:20 <Cale> Maybe there's interaction between multiple occurrences of coerce via RULES or something
09:40:35 <Cale> and it's using coerce there just to expose further optimisations after inlining
09:40:43 <Zemyla> Can you concatenate two type-level strings, the way you can add two type-level numbers?
09:40:52 <Intolerable> https://git.haskell.org/ghc.git/commitdiff/49fde3b6764d4b7bb149ef1c2c56d00cf0878ddb
09:40:59 <Intolerable> no, its just because it looks "niecr"
09:41:06 <Cale> Zemyla: I don't know. I wouldn't be surprised to hear that you can't.
09:41:13 <Intolerable> that's "nicer" for those who can type properly
09:41:42 <Cale> Zemyla: type level strings at the moment mostly exist to be used as convenient atoms / field labels, I think.
09:42:33 <Cale> Intolerable: hrm, okay
09:42:50 <Cale> I don't think it looks nicer, but maybe I'm just old-fashioned :)
09:43:21 <Welkin> lol
09:43:24 <Welkin> I found it confusing
09:43:31 <Welkin> that is why I looked deeper
09:43:33 <Intolerable> yeah i dont think its better either
09:43:36 <Intolerable> hence "nicer"
09:43:58 <Intolerable> the original definition is much more pleasant
09:45:00 <levi> This page has a lot of info on Roles, though I'm not sure how much insight it will give to this particular question: https://ghc.haskell.org/trac/ghc/wiki/Roles
09:46:03 <safinaskar> how to write in ghc haskell the following pseudocode:     class (exists b. Class1 a b) => Class2 a where {}     ?
09:46:32 <Zemyla> Cale: Yeah, I really wish I could take the head and tail of a type-level string. That'd be my fondest desire.
09:46:35 <Cale> safinaskar: hmmm...
09:47:26 <Cale> safinaskar: Does Class1 have a functional dependency?
09:47:27 <safinaskar> or this:      instance (Class a) => exists b. Class1 a b where {}     ? (this is nearly the same)
09:47:46 <Intolerable> newtype it?
09:48:00 <Cale> The problem here is that just having *an* instance isn't really enough -- you need to be able to consistently select the instance.
09:48:07 <Cale> Because it matters which one you have.
09:48:34 <Cale> One thing you could do is to add an associated type to Class2
09:48:37 <Cale> and use that
09:49:03 <safinaskar> Cale: "Does Class1 have a functional dependency?" - what you mean? Class1 is type class. (Class1 :: * -> * -> Constraint)
09:49:03 <Cale> class (Class1 a (AT a)) => Class2 a where type AT a; ...
09:49:23 <Cale> safinaskar: I mean, is the choice of b uniquely determined from a?
09:49:46 <Cale> safinaskar: i.e. does the class declaration for Class1 look like  class Class1 a b | a -> b where ...
09:50:27 <safinaskar> Intolerable: you mean "type Class2 a = exists b. Class1 a b"? yes, this would be very good. how to do this in ghc? (note, Class1 is class, not a type, Class1 :: * -> * -> Constraint)
09:50:39 <Zemyla> I can't use Chars as types with DataKinds? :O
09:50:52 <Intolerable> no, a newtype
09:50:57 <Cale> safinaskar: I'm not sure that what you're trying to do actually makes any sense.
09:51:07 <Intolerable> wait do you want exists. or forall.?
09:51:14 <Cale> safinaskar: Can you give some idea of what these classes are used for?
09:51:23 <safinaskar> Cale: b is uniquely determined from a
09:51:39 <safinaskar> Cale: but i cannot write type function which produces b from a
09:51:40 <Cale> safinaskar: Okay, does adding a fundep to the definition of Class1 help on its own?
09:51:47 <Cale> Wait, why not?
09:51:59 <Intolerable> then you either need fundeps or a Class2 a X => Class1 a thing
09:52:10 <Cale> You'd specify the type function at each instance of Class2
09:52:52 <Cale> safinaskar: I think it would be immensely helpful to see the real code you're working on here.
09:55:26 <greves> this has got to be one of the worst programming tutorials i've ever read: https://wiki.haskell.org/Meet_Bob_The_Monadic_Lover
09:56:04 <Welkin> greves: haha wtf
09:56:07 <Cale> greves: lol wtf
09:56:13 <safinaskar> Cale: i just added fundep and all is ok. so, yes, i have fundep
09:56:26 <Cale> safinaskar: okay :)
09:56:33 <safinaskar> Intolerable: "no, a newtype" - i don't understand you
09:56:53 <Cale> safinaskar: The other way would also have worked then, if you really wanted to avoid the fundep on Class1
09:57:10 <Cale> safinaskar: (you'd just have to pick one particular instance of Class1 to use whenever writing an instance of Class2)
09:57:26 <Intolerable> i mean using newtypes to select an instance
09:57:39 <Intolerable> not sure that would work tbh
09:57:43 <Intolerable> fundeps is a better solution
09:58:21 <Cale> greves: If you're looking for Haskell tutorials, have you found Brent Yorgey's CIS 194 course?
09:58:22 <Welkin> I understand that a functional dependency means that, for example, "b is uniquely determined by a", but can I get an example of how that works?
09:58:32 <Cale> It has some bugs, but it's generally pretty good.
09:58:35 <greves> nope
09:58:37 <greves> haven't seen that yet
09:58:43 <Welkin> @where learnhaskell
09:58:43 <lambdabot> https://github.com/bitemyapp/learnhaskell
09:58:46 <Cale> http://www.seas.upenn.edu/~cis194/fall14/spring13/lectures.html
09:58:47 <Welkin> greves: ^
09:58:59 <safinaskar> Cale: i am trying to do this: http://lpaste.net/138807
09:59:15 <Cale> Yeah, you could read bitemyapp's thing, but it's pretty much just going to tell you to read cis194 :P
09:59:20 * hackagebot ghcjs-dom-hello 2.0.0.0 - GHCJS DOM Hello World, an example package  https://hackage.haskell.org/package/ghcjs-dom-hello-2.0.0.0 (HamishMackenzie)
09:59:31 <safinaskar> Intolerable: "wait do you want exists. or forall.?" - exists
09:59:35 <Intolerable> what on earth is that bob tutorial
09:59:40 <Welkin> so, does anyone have an example of fundeps for me?
09:59:42 <Intolerable> yeah then fundeps is the way to go
09:59:58 <Intolerable> do you want an example of fundeps or an explanation of how they work
10:00:18 <Peaker> Welkin: I think MonadState could be a useful example
10:00:23 <Peaker> Welkin: let me whip something up
10:00:40 <safinaskar> Cale: i added fundep, but, of course, still cannot compile my code. because there is no keyword "exists" in ghc
10:00:41 <Intolerable> Welkin: are you familiar with lens?
10:00:48 <Welkin> Intolerable: barely
10:01:05 <Intolerable> have you see the templatehaskell stuff w/ classy lenses?
10:01:23 <Cale> safinaskar: Are you really going to have many instances of these classes?
10:01:31 <Intolerable> basically it generates a class HasX a b | a -> b where x :: Lens' a b
10:01:47 <Intolerable> for a record
10:01:52 <Welkin> Intolerable: yes, I have seen that
10:02:02 <Intolerable> basically the fundep (| a -> b)
10:02:14 <Cale> safinaskar: Are you writing something which is more an application or more a library? I'd tend to be a bit cautious about introducing lots of monad transformers like these.
10:02:31 <safinaskar> Cale: "Wait. why not?" - you mean "why i [safinaskar] cannot write direct type function?", right? because i cannot. such type function should convert BReaderT (AReaderT (CReaderT Identity)) to BReaderT (CReaderT Identity). i. e. i should remove "AReaderT" from monad transformers chain. and i don't know how to write such type function directly
10:02:41 <Intolerable> says that "if you tell me the type of the record you're accessing, i can infer the correct type of the field you're going to get back"
10:02:42 <greves> perfect this is what i've been looking for
10:02:43 <greves> thanks :D
10:02:53 <safinaskar> Cale: Intolerable
10:03:02 <Cale> safinaskar: You'd write it per-instance.
10:03:06 <safinaskar> Cale: Intolerable: okey, i have fundep, what to do next?
10:03:36 <Cale> safinaskar: After seeing this code, I think the next step is to reconsider whether all this machinery is necessary at all :)
10:04:21 <Welkin> Intolerable: that still doesn't explain anything about it though; I think lens is not a good example because of its complexity
10:04:37 <Cale> You can certainly control read and write access to mutable state in a bunch of ways, but one of the best ways is just to pass around readers/writers for that state explicitly.
10:04:45 <Cale> Then you don't need separate monads.
10:05:06 <Intolerable> lens itself is irrelevant to the example
10:05:24 <Intolerable> its just the most common one that people have some experience with
10:05:31 <Intolerable> (or at least that's what i've found)
10:05:40 <Welkin> Intolerable: I meant I want to see some example code, something concrete
10:06:34 <Cale> safinaskar: This code is clearly still a bit abstract, do you have a program which does real-world stuff?
10:06:51 <Intolerable> Welkin: have you read this: https://wiki.haskell.org/Functional_dependencies ?
10:07:17 <safinaskar> Cale: "Are you really going to have many instances of these classes" - there will be only instances specified in this file. my intention is so: (AR x) is true if and only if x is monad transformer chain which contains AReaderT or AStateT
10:07:19 <shadowswalker> every body joining this channel and leaving, what discussion is going on, can I join that?
10:07:45 <Cale> shadowswalker: ?
10:07:54 <Welkin> Intolerable: I'll read that now
10:08:41 <Cale> safinaskar: If you're just going to end up ReaderT/StateT transforming the IO monad, for instance, I would almost always advise against doing so.
10:09:13 <safinaskar> Cale: i am writing one file for my application.    i have application: proof assistant.   i want to have lots of variables in this my program.   and for this reason i want to create module/file in my application to work with this variables.    later, i probably will extract this module and use it as separate library
10:09:20 <levi> shadowswalker: Huge IRC channels tend to have lots of people in them that aren't interacting. You'll see any actual discussion when it happens, and anyone's usually welcome to join in.
10:09:20 * hackagebot leksah 0.15.1.3 - Haskell IDE written in Haskell  https://hackage.haskell.org/package/leksah-0.15.1.3 (HamishMackenzie)
10:10:12 <lpaste_> Peaker pasted âConcrete example of fundepâ at http://lpaste.net/138809
10:10:18 <Peaker> Welkin: ^^
10:10:38 <safinaskar> Cale: "all this machinery is necessary at all" - it is necessary. i am sure. moreover, this is just example of code which is generated by my template haskell functions
10:10:43 <Cale> safinaskar: If you want to control read/write access to IORefs, I would recommend just passing around (readIORef r) and (writeIORef r) separately.
10:12:05 <Cale> (assuming that you'd be transforming IO)
10:12:19 <Peaker> Welkin: MonadState has "| m -> s", so: get >>= put . succ    works, because the "s" is known from the "m".  MonadState' lacks the fundep,  so get >>= put . succ   knows the "m" is the same in get,put,  but it cannot infer anything about the universally quantified "s"
10:12:45 <Cale> If you'd be transforming some other monad, well, you really don't need more than one State transformer.
10:12:58 <Peaker> Welkin: ack? :)
10:13:05 <Cale> Put all the state together in one package, and then write things which interact with parts of it.
10:13:13 <Welkin> Peaker: but how is the s known from the m?
10:13:29 <safinaskar> Cale: "do you have a program which does real-world stuff" - yes, this is my proof assistant, as i said. but i didn't switch it to my monad transformer module yet
10:13:29 <Cale> But StateT over IO is basically always highly questionable imo.
10:13:38 <safinaskar> Cale: i added examples at the end: http://lpaste.net/13880
10:13:56 <Cale> (that link is broken)
10:14:08 <Peaker> Welkin: the fundep says that an instance always carries an implication for the instance's m, which will always choose an s.  So given any instance, we will be able to infer the "s" from the "m"
10:14:55 <AndChat196224> I am using kali linux in virtual machine,and upgrading to latest version upgrading will take 10 hours of time half is done how to pause that upgrade for a while and start from where it is pause ..,  any body thanks
10:15:25 <Peaker> Welkin: "s" is a function of "m" rather than being some ambiguous universally quantified variable
10:16:08 <Welkin> Peaker: by what mechanism is the s determined by the m?
10:17:03 <Peaker> Welkin: In the abstract, it isn't determined, it is only known that it is determin-able.  But in the concrete, when you see some specific instance like:  MonadState Int MyMonad    you know that if m=MyMonad then s=Int
10:17:07 <greves> i feel like all of the beating around the bush in intro haskell tutorials about Int -> Int -> Int being a function that "takes 2 arguments" and "returns an Int" is misleading
10:17:37 <greves> its much easier to just explain from the beginning that functions only take 1 argument...
10:18:22 <Cale> safinaskar: In your example, you don't have an instance of BR in scope, do you? Or is that a subclass of BS?
10:18:25 <safinaskar> Cale: no, i don't like IORefs.   because then i can write/read ALL IORefs.   but i want to grant to SOME of functions permission to read and write SOME of variables. that is why i created all this. also, i am not in IO monad
10:18:51 <Cale> safinaskar: Regardless, you can pass around monadic actions for interacting with the relevant parts of the state.
10:19:04 <Cale> safinaskar: No matter which monad actually manages that state.
10:19:41 <safinaskar> Cale: http://lpaste.net/138807
10:20:01 <Cale> (yeah, I figured out where the example was)
10:20:25 <Cale> It looks like g shouldn't be able to use f because there's not necessarily an instance BR m
10:20:41 <safinaskar> AndChat196224: your question about kali linux is unrelated to our chat. we are #haskell.   type "/join #linux"
10:20:46 <Cale> Did you mean to write (AS m, BR m) => ... ?
10:20:55 <safinaskar> AndChat196224: type "/join #linux" here, to irc
10:21:14 <AndChat196224> Thnx safinaskar
10:22:54 <safinaskar> Cale: i have instance of BR, i just didn't write it.  that code is just example. real code is template haskell code, which generates all instances
10:23:14 <lpaste_> Cale pasted âbarebones approachâ at http://lpaste.net/138812
10:23:43 <Cale> So, this is an approach without any type classes to doing what you're doing here.
10:23:54 <nitrix> How to load an extension in cabal's repl?
10:23:59 <Peaker> Welkin: if you try to instantiate with contradicting "s" for same "m" GHC will yell. Once you give any "m" for which GHC has an instance declaration, it will use that to infer the "s".. is that clearer?
10:24:40 <safinaskar> Cale: real working code is here: http://paste.debian.net/290979 (template haskell)
10:24:59 <Cale> This would work with IO and IORefs, or with some State monad, and accessors for the state
10:25:21 <Welkin> so can you have instance MonadState Char MyMonad *and* instance MonadState Int MyMonad ?
10:25:42 <Cale> Welkin: no.
10:26:02 <Cale> (because the functional dependency prohibits it)
10:26:09 <Welkin> I see
10:26:16 <safinaskar> Cale: "http://lpaste.net/138812" - too verbose
10:26:32 <Cale> safinaskar: Are you sure? Why is that?
10:26:32 <Welkin> Peaker: thanks, that helped
10:26:51 <Cale> safinaskar: We can work on making it less verbose
10:28:14 <prsteele> alright, high-level question. I have a [(String, IO a)], and want IO [(String, a)]. I can do this. But I feel like there is a pattern I might be missing, so how can I generalize this?
10:28:50 <shachaf> :t sequenceAOf (traverse._2) :: [(String,IO a)] -> IO [(String, a)]
10:28:51 <lambdabot> [(String, IO a)] -> IO [(String, a)]
10:28:54 <Intolerable> :t traverse :: (a, IO b) -> IO (a,b)
10:28:55 <lambdabot>     Couldn't match type ât0 a0 -> f0 (t0 b0)â with âIO (a1, b1)â
10:28:55 <lambdabot>     Expected type: (a1, IO b1) -> IO (a1, b1)
10:28:55 <lambdabot>       Actual type: (a0 -> f0 b0) -> t0 a0 -> f0 (t0 b0)
10:29:03 <Intolerable> rip
10:29:24 <safinaskar> Cale: well, again. i have "class PlusAReaderT m1 m2 | m2 -> m1 where".   let's now imagine all such m2's which can be first argument to PlusAReaderT. i. e. all such m2 that (exists m1. PlusAReaderT m1 m2). how to write "class AR is all such m2's"? "class (exists m2. PlusAReaderT m m2) => ARR m2 where" doesn't work because there is no "exists" keyword in ghc
10:29:37 <shachaf> Please avoid using lamdabot commands that cause errors in the channel.
10:29:42 <Cale> Intolerable: sequence
10:29:54 <Cale> :t sequence :: (String, IO a) -> IO (String, a)
10:29:55 <lambdabot> (String, IO a) -> IO (String, a)
10:30:09 <Cale> :t sequence . sequence :: [(String, IO a)] -> IO [(String, a)]
10:30:10 <lambdabot>     Couldn't match type â[]â with âIOâ
10:30:10 <lambdabot>     Expected type: [(String, IO a1)] -> [IO (String, a1)]
10:30:10 <lambdabot>       Actual type: IO [(String, a1)] -> [IO (String, a1)]
10:30:12 <Cale> oops
10:30:14 <Intolerable> oh derp
10:30:22 <Intolerable> yeah ofc its sequence
10:30:25 <Cale> :t sequence . map sequence :: [(String, IO a)] -> IO [(String, a)]
10:30:27 <lambdabot> [(String, IO a)] -> IO [(String, a)]
10:30:34 <Intolerable> what Cale said
10:30:46 <shachaf> sequence . map f = traverse f :-)
10:30:47 <Cale> The new sequence is quite general
10:30:57 <Cale> Yeah, so we can traverse sequence I suppose
10:31:12 <Cale> :t traverse sequence :: [(String, IO a)] -> IO [(String, a)]
10:31:14 <lambdabot> [(String, IO a)] -> IO [(String, a)]
10:31:16 <Cale> yep
10:31:33 <Cale> I'm not sure I'd actually write that.
10:31:33 <prsteele> alright, thanks!
10:31:40 <Cale> But yeah, it works
10:31:44 <codedmart> Anyone that can help with this issue or give me pointers on how to word it better to attract the right audience? http://stackoverflow.com/questions/31995960/error-with-instance-possible-cpp-overlappinginstances-issue
10:31:54 <safinaskar> Cale: i don't like IORefs, i already said why. when you say State monad what you mean? you mean creating one state monad for whole program and them modify parts of it, right? i don't like this, this is ugly
10:32:00 <prsteele> ya I was more looking to see if I was missing an abstraction, like, 'you want the FooT monad' or something
10:32:02 <shachaf> traverse is more composable. You can write (traverse . traverse) id
10:32:16 <shachaf> prsteele: Well, lens has a direct answer to this question, which I wrote above.
10:32:26 <Intolerable> :t sequence
10:32:27 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
10:32:32 <Intolerable> :t sequenceA
10:32:34 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
10:32:36 <Cale> safinaskar: This barebones approach paste works regardless of whether or not you're using IORefs or a state monad, or many different state monads.
10:32:38 <Intolerable> :t traverse sequenceA
10:32:40 <lambdabot> (Applicative f, Traversable t, Traversable t1) => t (t1 (f a)) -> f (t (t1 a))
10:32:55 <prsteele> shachaf: looking into it, never actually used lens
10:32:59 <prsteele> thanks!
10:33:09 <safinaskar> Cale: "Are you sure? Why is that?" - because i should pass lots of arguments every time i call one of this functions. moreover, i can ocassionally pass wrong arguments
10:33:36 <Cale> Yeah, it's fair that you might mess up and pass the incorrect arguments.
10:34:14 <Cale> I don't think the extra arguments are themselves usually all that onerous, once you get right down to it. You can always ensure that you don't ask for more than you really need.
10:34:32 <Cale> But it's possible to package them up as well.
10:34:53 <Peaker> Cale: and then pass them in a Reader monad :-)
10:35:04 <Cale> heh, even that if you really want
10:35:05 <safinaskar> Cale: again, how to write that "exists" instance?
10:35:32 <Cale> safinaskar: That kind of thing doesn't exist, or even particularly make sense.
10:36:02 <Cale> safinaskar: Well, okay, with the functional dependency it makes sense.
10:36:12 <Cale> Try just without the exists m2.
10:36:21 <Cale> Does it complain that m isn't in scope?
10:36:35 <Cale> (also, I think you meant exists m)
10:38:25 <nitrix> Could someone tell me why http://hackage.haskell.org/package/blaze-html-0.1/docs/Text-Blaze-Html5.html has a function `main` that collides with mine? 
10:39:06 <nitrix> When calling it from the repl: Ambiguous occurrence âmainâ It could refer to either âMain.mainâ, defined at src/Main.hs:13:1 or âText.Blaze.Html5.mainâ, imported from âText.Blaze.Html5â
10:39:08 <safinaskar> Cale: y.hs:86:21: Not in scope: type variable âmâ
10:39:26 <nitrix> And that's only after I have hidden it explicitly from my import. What is that function? It's not even documented on hackage.
10:39:52 <Intolerable> http://hackage.haskell.org/package/blaze-html-0.8.1.0/docs/Text-Blaze-Html5.html#v:main ??
10:39:53 <Intolerable> yes it is
10:39:59 <Intolerable> its for the html <main> element
10:40:21 <nitrix> Oh I have the wrong version.
10:40:32 <nitrix> I need to stop using google when I lookup packages :(
10:40:51 <prsteele> nitrix: https://www.haskell.org/hoogle
10:40:59 <nitrix> mhm.
10:42:04 <geekosaur> as for amelioration, hiding it or import qualified (possibly just that one)
10:42:24 <geekosaur> seems like an unfortunate collision given the special meaning of main...
10:43:09 <Intolerable> hardly
10:43:16 <int-e> tough one, I probably would also call it `main` because deviating from the html element name is worse
10:43:18 <Intolerable> blaze is designed to be imported qualified
10:43:34 <Intolerable> it has a lot of clashes
10:43:41 <Intolerable> "clashes"
10:43:51 <int-e> Oh there's <map>, too.
10:45:24 <geekosaur> perhaps the haddock should mention that it expects to be imported qualified and has lots of collisions
10:45:37 <Welkin> nitrix: look it up on hackage
10:46:00 <int-e> And `span`. I think that's it for the prelude.
10:47:17 <int-e> geekosaur: at least the tutorial (linked from the package description) starts out with import Text.Blaze.Html5 as H ...
10:48:09 <Sindriava> I prefer to put blaze templates in separate files and hide prelude, although that wouldn't solve main, I guess
10:48:18 <Phillemann> Hmmm, my build-depends contains a library without a version number. cabal complains that a module of this package is from the "hidden package foo-0.1". When I write "foo == 0.1" in my build-depends, it works
10:48:24 <safinaskar> Cale: "instance (PlusAReaderT m m2, Monad m2) => AR m2 where" works. thanks!
10:48:48 <int-e> Sindriava: it does; `main` is only special in the Main module (though ghc allows changing that module's name)
10:49:04 <Sindriava> int-e: Neat!
10:49:05 <geekosaur> Phillemann, that would imply that you are using something not present in all versions of that package, so cabal is picking the wrong one
10:49:07 <Sindriava> TIL
10:49:50 <Phillemann> geekosaur: I see. Can I somehow list all the candidates that cabal has to offer? :)
10:50:00 <Phillemann> In my view, I only have one version of the package.
10:51:35 <geekosaur> hm, "cabal list" shows only the default version it would use and any installed version, not all available versions. I usually get that from hackage web page
10:52:08 <Phillemann> But you might be on to something. It's my own library of which I changed the version from...I think 0.0.1.0 to 0.1
10:52:24 <Phillemann> Not sure though. So the other version might be lingering around.
10:52:40 <geekosaur> that should show under Installed versions in cabal list --installed foo
10:53:06 <geekosaur> or in ghc-pkg list --user
10:53:18 <geekosaur> ghc-pkg list --user foo
10:53:19 <Phillemann> Ah yes, installed versions are 0.1 and 0.1.0.0, so that's probably it. Thanks for the helm :)
10:53:22 <Phillemann> *help
10:53:25 <Phillemann> (emacs user)
10:53:46 <geekosaur> so you can ghc-pkg unregister the old one, or use the version constraint (possibly as a >=)
10:54:18 <Phillemann> I should do both, yeah.
10:54:34 <Phillemann> Although...0.1.0.0 is higher than 0.1, apparently? :>
10:54:51 <Phillemann> (Assuming cabal picks the highest version when there are no conflicts)
10:54:54 <prsteele> how can I see what versions of base libraries I have? Specifically, it doesn't seem like my copy of Data.Traversable has an instance declaration that is listed on Hackage.
10:55:24 <glguy> ghc-pkg list base
10:55:31 <geekosaur> base you have one version of, it came with the compiler
10:56:20 <prsteele> yup, on 4.6, looks like I should upgrade. Thanks!
10:57:25 <nitrix> How do I see the priority of an operator in the repl ?
10:57:36 <geekosaur> :info
10:58:13 <nitrix> Maybe there's none? What's the default?
10:58:20 <geekosaur> infixl 9
10:58:26 <geekosaur> although I think that would show?
10:59:18 <geekosaur> hm, no, if I specify a random functon in `` to see its behavior as an operator, no fixity info
10:59:26 <geekosaur> so it would be infixl 9
10:59:32 <geekosaur> (iirc)
10:59:54 * geekosaur doublechecks
11:00:39 <nitrix> It's the (!) operator, so 9 having the highest priority, `foo bar ! baz`, would give `foo (bar ! baz)` ?
11:01:05 <roboguy_> nitrix: it can't break up function application
11:01:09 <roboguy_> No operator can
11:01:26 <geekosaur> function application acts like it's precedence 10
11:01:33 <geekosaur> (record update syntax acts like precedence 11)
11:01:44 <geekosaur> (no, you can't use or specify either of those)
11:02:03 <nitrix> Oh I see what's going.
11:02:09 <nitrix> I have a couple ($) as well.
11:02:11 <arkeet> > (0$0!)
11:02:13 <lambdabot>      The operator â!â [infixl 9] of a section
11:02:13 <lambdabot>          must have lower precedence than that of the operand,
11:02:13 <lambdabot>            namely â$â [infixr 0]
11:02:32 <arkeet> but in ghci you can use :info
11:02:48 <safinaskar> is there a general way to convert "m a -> m a" to "t m a -> t m a" where m is monad and t is monad transformer?
11:02:58 <nitrix> I spent the whole day writing haskell and I must say I'm really really happy where this is going :)
11:03:01 <geekosaur> ok, yes, infixl 9. remarkably hard to find in the h2010 report :/
11:03:14 <arkeet> > (0$0`map`)
11:03:15 <nitrix> geekosaur: Appreciated :P
11:03:15 <lambdabot>      The operator âmapâ [infixl 9] of a section
11:03:15 <lambdabot>          must have lower precedence than that of the operand,
11:03:15 <lambdabot>            namely â$â [infixr 0]
11:03:23 <aweinstock> :t lift
11:03:24 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:03:36 <slowbait> Hi, is there any connection between CPS and the Yoneda Lemma?
11:03:56 <arkeet> safinaskar: no.
11:04:18 <Cale> slowbait: Yeah, in a roundabout way, istr edwardk has some blog posts about that...
11:04:23 * hackagebot Lattices 0.0.2 - A library for lattices  https://hackage.haskell.org/package/Lattices-0.0.2 (BartCoppens)
11:04:24 <roboguy_> safinaskar: not in general. If there is a "lower" function for that particular transformer (like Coyoneda), you can
11:05:01 <Cale> Oh, it was sigfpe http://blog.sigfpe.com/2006/11/yoneda-lemma.html
11:05:19 <roboguy_> safinaskar: or maybe a MFunctor instance: http://hackage.haskell.org/package/mmorph-1.0.4/docs/Control-Monad-Morph.html#v:hoist
11:05:46 <Cale> Well, probably edwardk has some posts as well
11:06:01 <arkeet> roboguy_: not sure what safinaskar is looking for is a monad morphism.
11:06:10 <Cale> yeah, here: http://comonad.com/reader/2011/free-monads-for-less-2/
11:06:13 <roboguy_> arkeet: that's true. Doesn't sound like a natural transformation
11:06:19 <arkeet> maybe they want (m a -> m b) -> (t m a -> t m b)
11:08:24 <arkeet> something life liftBaseOp_ would work if you have a MonadBaseControl
11:08:25 <arkeet> https://hackage.haskell.org/package/monad-control-1.0.0.4/docs/Control-Monad-Trans-Control.html#v:liftBaseOp_
11:08:47 <arkeet> safinaskar: ^
11:08:52 <slowbait> Cale: thanks!
11:09:14 <safinaskar> aweinstock: arkeet: roboguy_ thanks
11:11:38 <Cale> slowbait: This is sort of a weirdly squashed version of Yoneda. It's almost unrecognisable tbh.
11:12:23 <slowbait> Cale: what do you mean?
11:13:02 <Cale> slowbait: But that's often how things are when you try to fit general category theoretic concepts (that involve multiple categories) entirely into Haskell (which is just one category)
11:14:02 <Cale> I mean, if you know what the Yoneda embedding is in category theory, this data type isn't really it.
11:14:27 <Cale> It's sort of analogous though.
11:14:49 <roboguy_> Cale: is that just because it's Yoneda specialized to Hask, or is there even more missing?
11:15:30 <Cale> It's the fact that it's specialised to Hask, and Set has been replaced by Hask, and then a bunch of stuff has been internalised...
11:15:42 <slowbait> Cale: I understand Yoneda says (a -> b) -> f b ~ f a. I don't know if I'm missing something.
11:16:29 <roboguy_> slowbait: that's the special Haskell version of Yoneda, not the categorical Yoneda lemma in general
11:17:12 <Cale> If you understand the Yoneda lemma in general, it's not too hard to see how this is related, but without the abstraction over the choice of category, you lose a lot.
11:17:35 <dmwit> ?unmtl MaybeT (StateT s m) a
11:17:35 <lambdabot> s -> m (Maybe a, s)
11:17:39 <Cale> A lot of what makes Yoneda valuable also comes out of properties of the category of sets that Hask doesn't have.
11:17:44 <dmwit> \o/
11:18:38 <Cale> (e.g. that Set is complete and cocomplete, and this leads to Set^C also having these properties)
11:18:59 <Fay> ah
11:19:24 <roboguy_> Cale: hmm, Hask is missing some limits and colimits?
11:20:16 <Cale> roboguy_: yeah, at least, I believe it is.
11:20:49 <Cale> I don't know how to take arbitrary limits or colimits in Hask anyway.
11:22:41 <slowbait> Cale: I was also wondering if the fact that a vector space is isomorphic to it's double dual, can be seen as a Yoneda Lemma where we replace Set for Vec
11:24:12 <hodapp> hmm, next fun of TH: I have a function (a -> b), I have Q Exp which has inside type 'a', I need to apply that function and make another Q Exp
11:24:22 <hodapp> and am stumbling around trying to accomplish this
11:28:40 <roboguy_> Cale: well, we have products. I hear that if we also have equalizers, we can make all finite limits?
11:28:57 <notusingdebian> Hello I would like to learn how to hack from Tails I do not use Debian.
11:29:31 <Hijiri> wrong channel, I think
11:30:00 <notusingdebian> It was a joke. Listen I'm a n00b a jack of all trades I know scripting languages alright I have one question.
11:30:26 <notusingdebian> How do I start learning to hack exploits or whatever I have to close holes because my sites have a sign that says "Please hack me".
11:30:45 <notusingdebian> A link or anything to get me to start doing 2-3 hours a day and I won't come on here with dumb questions.
11:30:54 <glguy> Did you have a question about Haskell?
11:30:58 <Hijiri> still the wrong channel, this channel is for discussing haskell
11:31:05 <geekosaur> this is not the best channel to ask questions about security
11:31:13 <notusingdebian> How do I get to that channel thanks for helping.
11:31:27 <hodapp> how did you get to *this* channel?
11:31:33 <geekosaur> I don;t know offhand; #freenode would be where to ask
11:31:45 <notusingdebian> I connected to chat.freenode.net and typed hastake haskell
11:31:50 <notusingdebian> from xchat
11:31:54 * geekosaur does kinda wonder why people often seem to start out in here. possibly because it's one of the top channels by number of users?
11:32:01 <Cale> roboguy_: Yeah, the finite ones. I'm not sure we have equalizers, and that wouldn't help the rest of the limits.
11:32:15 <Welkin> This looks like a good BitVector package. It is exactly how I was thinking of implementing BitVector for haskell https://hackage.haskell.org/package/bv
11:32:21 <Welkin> does anyone have any opinions on that?
11:32:28 <hodapp> Hmm, it seems that I need to have an instance of Lift in order to do the same thing as (for instance)... baz b = [|foo $(mkPat b) = x + y] and have baz :: Bool -> Q Exp (for mkPat :: Bool -> Q Pat) like in the docs
11:32:33 <Welkin> where a BitVector is just a Integer
11:32:39 <roboguy_> Cale: I thought complete and cocomplete just required the finite ones? But, the other day, I was actually wondering what an equalizer would be like inside Hask (if that can happen at all)
11:34:13 <roboguy_> Oh, that's right, /small/ limits and colimits
11:34:24 * hackagebot streaming 0.1.0.0 - A general free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.0 (MichaelThompson)
11:35:15 <Cale> roboguy_: Nope, it's all small limits, not just all finite limits
11:35:29 <roboguy_> yeah, I forgot that bit. That's a pretty big difference, haha
11:36:46 <hodapp> hmm, I suppose I could try to use lam1E to get (Q Exp -> Q Exp)
11:44:25 * hackagebot naver-translate 0.1.0.0 - Interface to Naver Translate  https://hackage.haskell.org/package/naver-translate-0.1.0.0 (hongminhee)
11:49:11 <grayen> I just wrote a custom map data structure using Data.Map, so most of my functions are just patching the arguments to work with the underlying map. Should I be using the INLINE and INLINABLE pragmas for these kind of functions?
11:50:05 <nomeata> grayen: one would expect that GHC does the right thing anyway. you could inspec the interface (ghc --show-iface ...hi) and see if your functions are available for inlining
11:50:15 <nomeata> you can tell if there is an Unfolding with something that looks like your code
11:50:49 <nomeata> and you can check code using your functions (compile with ghc --ddump-simpl) and see if references to your functions have disappeared therein
11:51:48 <grayen> nomeata: Ok, will look into that thanks, so you generally discourage using the pragmas, unless GHC really needs some help in figuring it out?
11:52:26 <nomeata> grayen: at least it is the best way to get a feeling about what happens
11:52:56 <nomeata> Others have said that just slapping INLINE all over the place can have bad effects
11:53:09 <nomeata> but it is a problem that it is hard to predict what will happen
11:54:33 <grayen> If it really were that simple (just inline everything), the compiler would be able to figure it all out and such a pragma would not have to exist in the first place.
12:04:25 * hackagebot propellor 2.7.1 - property-based host configuration management in haskell  https://hackage.haskell.org/package/propellor-2.7.1 (JoeyHess)
12:04:27 * hackagebot nicovideo-translator 0.1.0.1 - Nico Nico Douga (Ë³Ë³Õ;) Comment Translator  https://hackage.haskell.org/package/nicovideo-translator-0.1.0.1 (hongminhee)
12:05:41 <ReinH>  /join #faraday
12:05:43 <ReinH> sry
12:06:45 <camm> Hi everyone, do you know why concatenating with the (++) function is more expensive than (:) ?
12:06:51 <camm> ( : ) *
12:07:37 <aweinstock> camm: because (++) has to copy its first argument
12:07:43 <aweinstock> @src (++)
12:07:43 <lambdabot> []     ++ ys = ys
12:07:43 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:07:43 <lambdabot> -- OR
12:07:43 <lambdabot> xs ++ ys = foldr (:) ys xs
12:07:45 <suppi> camm, in order to concat two lists you need to traverse the whole list
12:07:59 <suppi> the whole first* list
12:08:11 <aweinstock> camm: also, (++) invokes (:) multiple times
12:09:10 <roboguy_> comm: well (:) isn't a normal function, it's a constructor
12:09:19 <roboguy_> it's part of the definition of a Haskell list
12:09:27 <aweinstock> does anyone know if GHC rewrites ([foo]++) into (foo:)?
12:09:32 <roboguy_> @src []
12:09:32 <lambdabot> data [] a = [] | a : [a]
12:10:32 <roboguy_> aweinstock: I'm not sure. If not, it should get turned into that in two function evaluations so it's not too much of an overhead
12:11:20 <camm> Ok, thanks guys, your great.
12:22:54 <Gurkenglas> ([foo]++) vs (foo:) is harmless.
12:23:51 <aweinstock> Gurkenglas: as in, merely constant overhead?
12:24:26 * hackagebot streaming 0.1.0.1 - A general free monad transformer optimized for streaming applications.  https://hackage.haskell.org/package/streaming-0.1.0.1 (MichaelThompson)
12:24:53 <Gurkenglas> No worse than that, yep. Whether it drops to zero depends on how much inlining is done
12:25:40 <Gurkenglas> constant because [foo] ++ ys = foo : ([] ++ xs) = foo : xs in two steps without any compiler magic
12:33:22 * eikke just pushed first sort-of complete version of a native Haskell Reed-Solomon implementation
12:36:18 <lamefun> Is there a non-empty list library?
12:37:01 <arkeet> lamefun: there is one in semigroups
12:40:58 <Black0range> Are there some non infix version of ($) in the standard library?
12:41:07 <mauke> yes, id
12:41:12 <Black0range> :t id
12:41:14 <lambdabot> a -> a
12:41:18 <Black0range> :t ($)
12:41:19 <lambdabot> (a -> b) -> a -> b
12:41:31 <geekosaur> remember that "a" there unifies with any type
12:41:32 <mauke> :t id :: (x -> y) -> (x -> y)
12:41:34 <lambdabot> (x -> y) -> x -> y
12:41:52 <Black0range> ahhh
12:42:28 <geekosaur> btw you can also use any operator as a prefix function by wrapping in parens (tht's why you need to do so with :t)
12:43:30 <Black0range> yeah but I don't think it looks very pretty :)
12:44:08 <__momak35NS> hi. please help me. i have some debt and I need to earn some money or the bank will took my house. so i am trying to earn something with youtube. i made interesting educational video about laws of the islamic state, so, please just click it and watch it so that I can earn some small amount of money. thank you. here is video, i hope you like it: https://www.youtube.com/watch?v=df4KB30K0UU&feature=youtu.be
12:44:15 --- mode: ChanServ set +o geekosaur
12:44:22 <geekosaur> oh, left immediately
12:44:23 --- mode: geekosaur set -o geekosaur
12:45:51 <Black0range> hmmm what would be a way to rewrite for example: let x = Just (+3) in fmap ($5) x using id?
12:46:23 <mauke> fmap (`id` 5)
12:46:36 <mauke> but that's infix
12:47:52 <mauke> > sequence (Just (+3)) 5
12:47:54 <lambdabot>  Just 8
12:49:12 <Ankhers> > (Just (+3)) <*> pure 5
12:49:13 <lambdabot>  Just 8
12:49:27 * hackagebot publicsuffix 0.20150814 - The publicsuffix list exposed as proper Haskell types  https://hackage.haskell.org/package/publicsuffix-0.20150814 (wereHamster)
12:55:38 <kuribas> :t ap
12:55:40 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:56:40 <lamefun> Can Haskell do this like Ada can? http://lpaste.net/4497543057763205120
12:57:48 <kuribas> not at compile time
12:57:59 <aweinstock> :t (<*>) -- kuribas, this is more general than ap
12:58:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:58:11 <kuribas> aweinstock: yeah
12:59:04 <mauke> lamefun: no
13:00:14 <kuribas> > let f a = assert (a > 0 && a < 1000) (show a) in f 20
13:00:15 <lambdabot>  "20"
13:00:29 <kuribas> > let f a = assert (a > 0 && a < 1000) (show a) in f (-1) -- lamefun
13:00:33 <lambdabot>  mueval-core: Time limit exceeded
13:00:54 <aweinstock> > assert False False
13:00:56 <lambdabot>  *Exception: <interactive>:3:1-6: Assertion failed
13:01:10 <kuribas> > let f a = assert (a > 0 && a < 1000) (show a) in f (-1)
13:01:12 <lambdabot>  "*Exception: <interactive>:3:11-16: Assertion failed
13:01:19 <Black0range> hmm would it be possible to make a newtype of a function an instance of Read? 
13:01:37 <lamefun> Well, ok.
13:02:37 <lamefun> Is there a standard library that can check smart construction compile-time, eg. so I can't do (fromJust $ Version.parse "not-a-version") and have a compile time error instead of a run-time error?
13:02:51 <geekosaur> Black0range, what exactly would you read to make the function?
13:03:35 <aweinstock> lamefun: if you control Version, you can use TH to write a Version.parseTH that runs at compile-time
13:04:12 <aweinstock> lamefun: but general conversions of run-time to compile-time errors sounds kind of undecidable
13:04:28 * hackagebot yesod-table 1.0.4 - HTML tables for Yesod  https://hackage.haskell.org/package/yesod-table-1.0.4 (andrewthad)
13:04:57 <lamefun> what's wrong with undecidable compilation?
13:05:32 <lamefun> Won't I simply get hung compiler instead of a hung program?
13:05:44 <aweinstock> compilation is expected to terminate
13:06:32 <aweinstock> although I guess you can already hang the compiler with TH (e.g. $(let x = x in x))
13:07:01 <lamefun> Well, OS is expected not to hang.
13:07:09 <Black0range> geekosaur: now this isn't correct code at all but i think you get the idea: http://lpaste.net/138821
13:08:32 <geekosaur> just constructors? I think you could do that given a Data instance for A
13:08:48 <lamefun> What if I only write TH constructors that don't hang?
13:09:45 <aweinstock> does UndecideableInstances ever not terminate, or is there a limit on how long it searches?
13:09:59 <lamefun> Eg. I don't think Version.parse function can hang unless the text is infinite.
13:11:14 <aweinstock> replacing (fromJust $ Version.parse "not-a-version") with $(Version.parseTH "not-a-version") would allow you to move the checking to compile-time
13:12:17 <aweinstock> (and I think in general you could write something of type ((a -> Maybe b) -> (a -> Q Exp)) that does parsing-ish stuff at compile time, and expands into a Just literal if it succeeds)
13:12:33 <Black0range> geekosaur: http://lpaste.net/138821
13:12:41 <Black0range> "No instance for (Read (Int -> A))"
13:13:01 <Black0range> of course :)
13:13:08 <geekosaur> I did not say the instance would magically come into existence, merely that one could be written
13:13:17 <geekosaur> it si far beyond what ghc could derive even if it were inclined to do so
13:16:36 <lamefun> can I simply splice a value into a program?
13:16:50 <lamefun> instead of building a way to construct it.
13:17:04 <nolrai66> Not sure what you mean?
13:17:20 <lamefun> in Template Haskell.
13:17:54 <mauke> $(liftArbitraryValueLiteral x)  -- not sure if that's possible
13:18:04 <lamefun> like expFromValue :: a -> ExpQ
13:19:05 <rhovland> anyone had luck implementing something faster than Data.List.sort? I'm trying to sort ~300000 64bit ints. I tried writing a heapsort using stuarray, but it was significantly slower than Data.List.sort
13:20:36 <kuribas> rhovland: isn't it fast enough?
13:22:08 <kuribas> rhovland: maybe vector is faster: https://hackage.haskell.org/package/vector-algorithms
13:22:28 <rhovland> kuribas: nope. trying to solve a practice problem on hackerrank and I'm taking _slightly_ too long on one of the tests (there aren't any other haskell solutions on the board, though, so it may not be possible)... profiling says I'm spending all my time in sort
13:23:05 <johnw> spending all your time in sort doesn't always mean that sort is slow
13:23:19 <johnw> if you have a lot of thunks being forced by sort, that time will be reported as being from sort
13:27:13 <kuribas> rhovland: can you show the code?
13:27:41 <rhovland> johnw: I suppose that's possible. Currently I'm using data.bytestring.char8 to read space-separated columns and sort by different columns, essentially... I got a slight speedup by combining to 64bit, using sort, and splitting afterwards instead of sortBy (comparing snd) or sort on tuples. can I read the input faster? parsec or something?
13:28:24 <rhovland> kuribas: sure, 1sec
13:29:50 <ew0> hey
13:29:54 <ew0> I'm using FGL
13:30:18 <mauke> rhovland: link to problem?
13:30:43 <ew0> how do I generate new nodes for a graph?
13:31:07 <ew0> with an int that was not yet used?
13:31:42 <eikke> anyone familiar with Repa?
13:36:28 <johnw> rhovland: can you paste your profiler output?
13:37:10 <ew0> yay
13:37:15 <ew0> fund a newNodes function
13:37:18 <rhovland> kuribas: code is http://lpaste.net/138828
13:38:29 <johnw> rhovland: your foldl' will accumulate thunks
13:39:04 <johnw> because although go cases on the tuples, it doesn't case on the accumulator
13:39:20 <kuribas> rhovland: use type signatures, because (Num a) is going to be slow.
13:39:25 <johnw> I'd try: go (!acc, ...
13:39:38 <lamefun> How to splice literals into [|| ... ||]?
13:39:45 <johnw> but please, do paste your profiler output
13:40:05 <rhovland> johnw: profiler is http://lpaste.net/138829
13:40:39 <johnw> oh yeah, look at that total alloc
13:41:05 <johnw> try the bang pattern
13:42:08 <johnw> basically, _whenever_ tuples are involved (or really any product type), pay close attention to what gets forced when
13:42:24 <kuribas> rhovland: what's the problem statement?
13:42:29 <johnw> because although foldl' will force the tuple, it won't force what's in it
13:43:22 <rhovland> kuribas: https://www.hackerrank.com/challenges/jim-and-the-challenge
13:44:20 <rhovland> johnw: hmm... never used bangpatterns... I tried just putting ! in front of the acc... no change, really
13:44:28 <johnw> i'm trying some stuff here
13:44:30 * hackagebot cabal-ghc-dynflags 0.1.0.0 - Conveniently configure GHC's dynamic flags for use with Cabal projects  https://hackage.haskell.org/package/cabal-ghc-dynflags-0.1.0.0 (BenGamari)
13:44:34 <johnw> it can be subtle, finding the right place
13:44:49 <lamefun> I had to cheat by: [|| fromJust $ parse $$(return $ TExp $ LitE $ StringL $ T.unpack txt) ||] --- is there a proper way to do this?
13:47:09 <scshunt> [|| ?
13:47:26 <scshunt> what is that?
13:47:45 <johnw> rhovland: how should I be running this?
13:48:26 <lamefun> scshunt, typed Template Haskell quote
13:48:32 <kuribas> scshunt: template haskell
13:49:48 <aweinstock> rhovland: you're using lists with (!!i) at places, replacing these with Data.Vector (or possibly Data.Vector.Unboxed) will probably help
13:50:29 <rhovland> johnw: hm.. sample data looks like http://lpaste.net/138830 .. first line has # of lines (I believe I ignore this), and # of columns (well, -1)
13:50:40 <johnw> rhovland: ok, I ran it but it runs super fast
13:50:43 <johnw> how fast does it need to be?
13:50:51 <johnw> it takes 0.005s here
13:51:24 <rhovland> johnw: rest is just data, you could just create random 32bit numbers... I'm using a 300000 line input file
13:51:33 <johnw> can you put that file somewhere for me?
13:51:38 <johnw> so that we're comparing the same thing?
13:52:44 <johnw> also, type signatures on all of these functions should help a lot
13:52:52 <johnw> otherwise, it's defaulting to Num a, as someone mentioned
13:53:20 <johnw> (thinks not having signatures on top-level functions should be an opt-out error, really)
13:53:43 <exio4> that sounds like a good feature suggestion
13:54:06 <exio4> lacking top-level type signatures is already a warning
13:54:16 <johnw> but only with -Wall, right?
13:54:29 <exio4> there should be some -Wsomething to enable it? :P
13:54:32 <rhovland> johnw: try https://drive.google.com/file/d/0B9Ba3P5NU2mCbVZnMjNwWkJrVU0/view?usp=sharing
13:54:45 <johnw> it's just surprising how many questions are answered simply by having signatures
13:55:14 <johnw> rhovland: ok, 4.249s
13:55:15 <ezyang> Was there a paper that explained where Proxy comes from? 
13:56:07 <johnw> ezyang: I see it mentioned in "Giving Haskell a Promotion"
13:57:27 <ezyang> oh you're right 
13:57:31 <ezyang> OK, good cite 
13:57:54 <johnw> rhovland: type signatures alone improves speed by 25%
13:57:58 <rhovland> johnw: it's not exactly a hard line on the time, since I don't have control over where it's running... it's currently more than 5sec, which is where they kill it. I suspect (from the similar cases, where I pass) I only need about a 10% speed increase
13:58:27 <rhovland> johnw: hm.. will try that... hm back in like 30min, but I'll leave this window up
13:58:51 <johnw> bang patterns in the right places gains another 20%
13:58:51 <lamefun> `TIO.putStrLn (V.format $$(V.parseTH "not a version"))` - wow, this is excellent! And works!
13:59:53 <johnw> avoiding data sharing, 8% more
14:00:48 <exio4> I would want to know how good the improvement would be, by just switching to something that doesn't do lazy IO using String(s)
14:03:19 <lingxiao> Hye all
14:03:35 <lingxiao> I have a problem and I am wondering if conduit could help me in this cse
14:03:38 <lingxiao> case*
14:06:23 <kuribas> rhovland: you could probably speed it up using unboxed vectors.
14:06:42 <johnw> yeah, I think we're hitting a list-involved limit here too
14:06:47 <johnw> sort has to really shuffle things around
14:07:17 <kuribas> johnw: strange, I get the same time with and without signatures.
14:07:19 <tommd> Just use STVector and quick/radix/tim sort
14:07:32 <johnw> kuribas: I started out at 4.2s.  Now I see <3.0s most of the time
14:08:01 <kuribas> johnw: would using pipes improve the speed?
14:08:06 <johnw> no
14:08:18 <johnw> pipes is definitely not faster than pure lists
14:08:38 <johnw> or did you mean for the parsing...
14:08:44 <johnw> attoparsec could speed up that side of things
14:08:49 <johnw> kuribas: https://github.com/jwiegley/speed
14:08:53 <johnw> there's what I've been doing
14:09:09 <exio4> I was really looking at that loo
14:09:11 <exio4> p
14:09:11 <kuribas> johnw: yes, for parsing.
14:09:28 <johnw> lazy IO is no slouch
14:09:31 * hackagebot cabal-ghc-dynflags 0.1.0.1 - Conveniently configure GHC's dynamic flags for use with Cabal projects  https://hackage.haskell.org/package/cabal-ghc-dynflags-0.1.0.1 (BenGamari)
14:12:59 <johnw> converting this to vector code is a bit beyond what I want to do just now
14:13:01 <johnw> but it's a good path
14:13:40 <lingxiao> I need to compute a some statistics over a stream of values
14:14:05 <lingxiao> I would like to do so in constant space
14:14:22 <johnw> lingxiao: I would recommend looking at pipes and the foldl library
14:14:29 <lingxiao> composability would be desirable, since I may need to compute more values later
14:14:32 <johnw> it's designed for constant-space stream folding
14:14:39 <lingxiao> yeah I spoke to Gabriel actually and he suggested foldl
14:14:54 <lingxiao> I am just wondering if conduit also has something for this 
14:15:16 <johnw> I actually haven't ever seen Snoyman mention that, but I wouldn't be surprised if it did
14:15:34 <johnw> if you want REALLY fast, and you're willing to be experimental....
14:15:56 <johnw> I've been working on http://hackage.haskell.org/package/fusion, and would love to add beautiful folding to it
14:16:55 <lingxiao> johnw what makes it REALLY fast?
14:17:08 <johnw> stream fusion everywhere
14:17:15 <johnw> which conduit does do, but this beats conduit for my examples
14:17:42 <johnw> i.e., 0.112s vs 0.04s
14:17:53 <lingxiao> oh that's a huge difference!
14:17:55 <johnw> although, where just plain lists are 0.004s (these are pure pipelines I'm testing)
14:18:09 <lingxiao> I'll take a look after playing with foldl
14:18:25 <johnw> so, if you go with fusion, we'll probably need to collaborate to get to where you want to go
14:18:37 <johnw> it's a very new project, but I like the results I've seen so far
14:19:00 <johnw> my internal data structures are completely absent in the resulting executable, which is my goal
14:21:03 <johnw> one odd thing I'm seeing is that in criterion, conduit is actually beating me, but timing the code as an executable, it's not; I'm starting to think there is setup/teardown involved with conduit, but the core pipeline itself is just as fast
14:21:09 <lingxiao> ok I'll let you know if I end up going with fusion!
14:21:21 <johnw> lingxiao: ok, ping me on github via https://github.com/jwiegley/fusion
14:21:57 <johnw> though I *do* see conduit's Core doing case analysis on the Conduit.Internal.Pipe data structure, so it's not entirely fused away
14:22:02 <lingxiao> will do!
14:22:10 <lingxiao> hmm .. does Snoyman come here often?
14:22:16 <lingxiao> or er is here at all
14:22:24 <johnw> I haven't seen snoyberg here in more than a year
14:22:40 <lingxiao> oh boy thanks haha
14:23:05 <hpc> he melts in the summer
14:23:08 * Eduard_Munteanu wonders where preflex is
14:23:19 <Eduard_Munteanu> Heh.
14:23:47 <prsteele> anyone know how to define a list of tests in Test.Framework?
14:26:34 <prsteele> I can be more clear: I can easily define something list test_Foo assertEqual 1 (\_ -> 1), but what if I wanted to define a family of such tests?
14:27:16 <kuribas> johnw: I got another significant reduction by replacing [Int] with Data.Vector.Unboxed Int
14:27:28 <johnw> kuribas: yeah, that makes complete sense
14:27:29 <kuribas> Data.Vector.Unboxed.Vector Int
14:27:36 <johnw> I think his code is really shuffling cons cell around a lot
14:27:39 <kuribas> and unsafeIndex :-0
14:28:06 <M-ou-se> The documentation for Network.Socket.recvBuf says "(...) a zero length return value means (...)", but looking at the implementation, it seems like it will never return 0, since that will always raise an exception: http://hackage.haskell.org/package/network-2.6.2.1/docs/src/Network-Socket.html#recvBuf
14:28:06 <M-ou-se> Am I missing something?
14:30:32 <Peaker> M-ou-se: seems like doc may be out of date?
14:30:44 <geekosaur> the documentation was done from the manpage for recvfrom; whoever wrote the implementation was not familiar with those cases
14:31:49 <M-ou-se> For my use case it'd be better if it returned 0 instead of throwing an exception :(
14:33:16 <geekosaur> hm, recvBuf in the version I am looking at does not say about 0 returns
14:33:18 <byorgey> M-ou-se: you could try wrapping it with  http://hackage.haskell.org/package/spoon
14:34:59 <byorgey> oh, wait, maybe that doesn't catch exceptions, never mind
14:35:45 <johnw> or use 'try'
14:36:04 <johnw> either 0 id <$> try ...
14:37:46 <M-ou-se> i wonder if GHC compiles that to something just as efficient as if the recvBuf just returned 0, instead of throwing an exception.
14:38:16 <M-ou-se> (not that it really matters, since recv is network-bound, not cpu-bound)
14:41:01 <bz> why does cabal-install try to install criterion, http-client, http-conduit, and a bunch of totally unrelated packages when all i wanted was `cabal install cereal`, and how do i tell it to stop installing stuff i never asked for?
14:41:33 <bz> and as a side note, cereal depends on none of those other packages, not even as a test dep
14:41:57 <bz> nvm, figured it out
14:42:02 <dmj`> johnw: ping !
14:42:09 <johnw> hi
14:43:38 <dmj`> johnw: have you used c2hs under osx?
14:43:43 <johnw> no, never
14:43:50 <johnw> I use c2hsc
14:44:04 <erisco> I keep forgetting
14:44:08 <kuribas> johnw: down to 1.5 sec by replacing all lists by vector
14:44:15 <erisco> what is the Haskell regex library where you can just type regex strings and compile them?
14:44:16 <johnw> kuribas: nice, that's twice as fast!
14:44:19 <dmj`> johnw: oh, so c2hsc, then hsc2hs :_
14:44:21 <dmj`> :)
14:45:00 <erisco> kuribas, play with unboxed vectors and UNPACK and so-forth too
14:45:17 <lpaste_> kuribas annotated âNo titleâ with âNo title (annotation)â at http://lpaste.net/138828#a138837
14:45:55 <erisco> also unpacked tuples for return values, who knows
14:45:57 <kuribas> johnw: I am using a boxed vector of unboxed vectors.
14:46:34 <Eduard_Munteanu> -O2 -funbox-strict-fields?
14:46:35 <kuribas> johnw, rhovland: replacing it with a matrix or single unboxed vector could give even more improvements
14:46:35 <erisco> add some !'s 
14:46:48 <kuribas> erisco: johnw did that already :)
14:47:13 <johnw> the !s helped only a little
14:47:56 <Eduard_Munteanu> You might want to consider inlining stuff too.
14:48:04 <erisco> moar directives
14:48:07 <johnw> everything is so short, wouldn't GHC be doing that already?
14:48:14 <erisco> if not fast enough add more directives
14:48:34 <erisco> also make sure you're compiling with -O2
14:48:38 <johnw> I am
14:49:03 <kuribas> erisco: I get no speed difference between -O2 and -O1
14:49:16 <erisco> is there O3? go for broke
14:49:33 <Welkin> I don't think there is O3
14:49:36 <geekosaur> no -O3
14:49:58 <Welkin> here's another solution
14:50:01 <Welkin> multicore!
14:50:02 <erisco> rewrite in C++ and do -O3 then
14:50:07 <Welkin> parconc!
14:50:28 <Welkin> erisco: write in assembly using only SIMD
14:50:28 <dmj`> johnw: thanks, I'm excited to try this
14:51:10 <erisco> might not be that bad to depending on the operation
14:51:21 <Welkin> dmj`: you're still on osx too eh
14:51:32 <kuribas> erisco, johnw actually each dimension could be done in parallel.
14:51:45 <johnw> I like the sound of that!
14:52:17 <erisco> meh, that is kind of last mile stuff
14:52:32 <erisco> split across two cores the most you're hoping for is 2x speed
14:52:41 <johnw> 2x would be pretty good
14:52:46 <johnw> since it's for free almost
14:52:58 <erisco> except requires more resources :P
14:53:17 <johnw> I think his goal is speed, not resource utilization
14:54:02 <Eduard_Munteanu> johnw, precompute results then :P
14:54:05 <johnw> hahaha
14:54:07 <erisco> I just mean, if there is improvement to be done in the non-concurrent version
14:54:18 <erisco> then that is probably where you should focus first
14:54:59 <erisco> perhaps you want to ffi to C
14:57:52 <erisco> gosh darn
14:58:04 <erisco> regexp is made really complicated
14:58:28 <erisco> I just want  Pat -> String -> Maybe (String, String)   or something like that
14:58:53 <erisco> split the input string by matching a pattern from the start
14:59:24 <Welkin> :t splitOn
14:59:25 <lambdabot> Eq a => [a] -> [a] -> [[a]]
14:59:33 <Welkin> :t splitAt
14:59:33 <erisco> I want regexp
14:59:34 <lambdabot> Int -> [a] -> ([a], [a])
14:59:36 <Welkin> yeah
14:59:37 <Welkin> like that
14:59:39 <johnw> erisco: isn't that just what foo =~ bar does in Text.Regex.Posix?
14:59:52 <erisco> maybe? I dunno, it said that lib is slow
14:59:54 <Welkin> except not an Int
15:00:05 <erisco> "very slow" in fact
15:00:12 <johnw> so now you want more than one thing
15:00:16 <johnw> simple AND fast
15:00:17 <erisco> and though I don't really need blazing speed right now it makes me feel bad
15:00:30 <erisco> no I just want to feel good about myself and use regexp
15:00:50 <Welkin> make somethign that works before worrying about how fast it is
15:00:57 <Welkin> premature optimization being evil and all that
15:01:06 <erisco> thanks mom I can handle it
15:01:22 <lamefun> is there a library for single-line texts/strings?
15:01:32 <Welkin> single-line??
15:01:58 <lamefun> newtype TextLine = TextLine { lineText :: Text }
15:02:05 <Welkin> yeah
15:02:11 <Welkin> I have no idea what you mean by single-line
15:02:22 <lamefun> no '\n', '\r' or other line breaks
15:02:33 <Welkin> :t lines
15:02:34 <lambdabot> String -> [String]
15:02:39 <erisco> there is regex-tdfa but absolutely zero documentation on how to use the thing from what I can find
15:02:43 <Welkin> list of single lines
15:02:49 <erisco> despite how large the library is
15:02:52 <byorgey> lamefun: what can you do with single-line text that you can't do with other text?  i.e. what would a special library for single-line text do?
15:03:18 <lamefun> byorgey, I can't be sure it's always a single line.
15:03:24 <prsteele> lamefun: maybe you just want a smart constructor, e.g. Text -> Maybe Text to ensure that there are no line breaks?
15:03:41 <mauris_> it's just an invariant i guess
15:03:59 <prsteele> data NoLines = NoLines Text -- Hidden; mkNoLines x :: Text -> Maybe NoLines
15:04:28 <lamefun> I've already written that, but is there a library that implements this already?
15:04:32 <byorgey> lamefun: I see, then what prsteele said.  I don't know of anything like this that already exists.
15:04:57 <erisco> it is oddly specific, I don't see why there'd be a library for it out of hand
15:05:58 <lamefun> I'm new to Haskell, don't want to create lots of my own types and then find out that there's already a library and have to re-write code.
15:06:20 <prsteele> lamefun: https://www.haskell.org/hoogle is very useful
15:06:26 <erisco> well you've just got the one function though right? you just need to test whether a given text as newlines in it or not
15:06:39 <byorgey> lamefun: rewriting code is a normal and healthy activity.  I wouldn't worry about it too much =)
15:06:44 <mauris_> it seems to not really be a haskell habit to encode this kind of info in your types :(
15:07:02 <hpc> lamefun: also, writing your own types is very common, even when you do know they already exist
15:07:09 <byorgey> mauris_: that is the opposite of my experience.
15:07:09 <erisco> in this case you can't encode it in the type
15:07:23 <hpc> you may need a slightly different instance or your usage means something different that you don't want to admit the generic type for
15:07:27 <byorgey> I always try to encode invariants in my types.
15:07:47 <erisco> you can't encode a "Text without newline"
15:07:52 <hpc> lamefun: this is to some extent blessed by the language itself in the form of newtype
15:07:56 <prsteele> I mean, you *could*, it would just be extremely verbose
15:08:09 <erisco> very verbose...
15:08:12 <byorgey> erisco: you can't actually have the type system check it, but you can make a separate NoLines type like prsteele suggested above
15:08:18 <hpc> not terribly
15:08:22 <mauris_> byorgey: very often i think "i wish there was a type for positive doubles / even naturals / ... so i could type-safely take a square root / halve a natural / ..."
15:08:33 <hpc> noLinesMap f txt = removeNewlines (f txt)
15:08:39 <erisco> byorgey, well sure, but that isn't what I'm saying is it
15:08:41 <byorgey> mauris_: oh, the numeric type hierarchy is another beast entirely.
15:08:42 <linman32> is it possible to look up what a type is composed of? (if so, how)
15:09:01 <hpc> (pretend i remembered to pattern-match on txt there)
15:09:07 <prsteele> linman32: A bit more specific? There's :t and :i in GHCI 
15:09:13 <erisco> linman32, you can go to hackage and look at the source
15:09:41 <erisco> you're either not supposed to care or the constructors are exported
15:10:03 <lpaste_> kuribas annotated âNo titleâ with âNo title (annotation) (annotation)â at http://lpaste.net/138828#a138840
15:10:29 <linman32> like in ghci look up your own def. some of the types are hierarchal and i want to see there composition without looking up references
15:10:30 <kuribas> johnw: no improvement, but I am probably doing it wrong...
15:10:45 <mauris_> byorgey: i feel like there's a difference between types like Data.List.NonEmpty -- which encode more "structural" invariants -- and some thing like "integers 0 <= x < 12" or "strings without newlines" -- which are about the contents themselves
15:11:18 <prsteele> you're basically asking for dependent types, I think
15:11:33 <mauris_> the first kind is everywhere, and it's really nice, and i use them often! but the second kind is -- yeah, more a dependent types thing, it seems
15:11:56 <erisco> mauris_, there is not necessarily any difference
15:12:10 <prsteele> I think you can still get quite far using hidden constructors and a a -> Maybe YourThing smart constructor
15:12:12 <erisco> mauris_, it is easy to encode integers 0 to 12, you just need 12 constructors
15:12:24 <mauris_> erisco, yeah i'm not sure at all how formal that distinction is
15:12:31 <Gurkenglas_> erisco, count again
15:12:36 <linman32> prsteele: maybe hierarchal is a bad description. the types are composed in different ways. would like to see what a type synonym is composed of
15:12:50 <erisco> mauris_, and "strings without newlines" can be done if you make a new char type with all the chars but newline
15:12:57 <mauris_> Char is also a finite type. so... haha yeah
15:12:57 <prsteele> mauris_: A better example would be a vector type that is length-dependent
15:13:00 <Gurkenglas_> (Oh, exclusive to. Disregard that, I eat chicken)
15:13:29 <mauris_> but there's no "easy" way to do it, i guess
15:13:34 <linman32> prsteele: :i works pretty well
15:13:41 <mauris_> > length ([minBound..maxBound] :: [Char])
15:13:43 <lambdabot>  1114112
15:13:54 <linman32> prsteele: but would like to see it expand for all type synonyms
15:14:17 <prsteele> mauris_: that would let you do things like safe inner products, etc
15:14:22 <erisco> mauris_, I think what you're getting at is you can either try to directly define an inductive type, or you can refine a broader type
15:14:33 * hackagebot bindings-GLFW 3.1.1.4 - Low-level bindings to GLFW OpenGL library  https://hackage.haskell.org/package/bindings-GLFW-3.1.1.4 (SchellScivally)
15:14:41 <erisco> mauris_, so you could define a new char type without newline, or you can refine the existing char type to exclude newlines
15:15:05 <prsteele> linman32: beyond that, maybe hoogle/hackage
15:15:08 <erisco> if you want that use liquidhaskell methinks
15:16:09 <prsteele> alright, cheers everyone
15:16:21 <mauris_> erisco: wow, i will look into this!
15:18:56 <max> Hi guys, I'm fairly new to haskell and I'm getting a compiler error that I don't understand. Would someone do a quick code review? (It's only like 4 lines)
15:19:29 <erisco> Guest75494, shoot
15:19:52 <erisco> people idle on web chat?
15:20:43 <Guest75494> http://pastebin.com/RxT2dSpT 
15:20:49 <Guest75494> Ahh, my name changed
15:21:01 <erisco> johnw, tdfa is so complicated looking I don't even care about the speed anymore :(
15:21:03 <Welkin> Guest75494: use lpaste
15:21:05 <Welkin> @lpaste
15:21:05 <lambdabot> Haskell pastebin: http://lpaste.net/
15:21:07 <Welkin> in the future
15:21:15 <erisco> I think I got something compiled in it once but I forget entirely how it worked
15:21:43 <erisco> also include the compiler error please
15:21:57 <Guest75494> http://lpaste.net/138841
15:21:59 <Welkin> Guest75494: you omitted the error
15:22:10 <Guest75494> adding it now
15:22:39 <Guest75494> Alright, I put it in :)
15:22:47 <erisco> I don't think simplicity is valued enough in some of these libraries
15:23:00 <erisco> holy bejeebers are some of them complicated
15:24:02 <erisco> which is the real line 12?
15:24:05 <Guest75494> I found one potential issue in it at least
15:24:05 <Welkin> haha
15:24:15 <Guest75494>         where shortestA = min (a + getA section) (b + getC section + getA section)
15:24:21 <Welkin> Guest75494: also, `head` is an unsafe function
15:24:30 <Welkin> Guest75494: the indentation looks off
15:24:32 <Gurkenglas_> I am getting no such parse error. Try pasting the code from the lpaste into another file, there might be artifacts with the text encoding or something?
15:24:36 <erisco> not if you know the list is non-empty!
15:24:53 <erisco> partiality is just something you've gotta accept man
15:25:15 <erisco> I know the problem
15:25:21 <erisco> you cannot mix tabs and spaces
15:25:30 <erisco> always use spaces, forget tabs
15:25:32 <tommd> Yes you can... but don't complain if something goes wrong.
15:25:48 <erisco> tabs is a misfeature, I'm going to say it
15:26:10 <Welkin> my emacs converts tabs to spaces :P
15:26:28 <Guest75494> Ahh okay, thank you. I changed to space mode and reindented and I have a different error to work with now :)
15:27:46 <lpaste_> kuribas annotated âNo titleâ with âNo title (annotation)â at http://lpaste.net/138828#a138843
15:28:37 <kuribas> erisco: I tried parallel map, but there is no improvement.  I am probably doing something wrong.
15:28:53 <kuribas> erisco: line 39
15:28:57 <erisco> are you compiling with that magic threading option? I can't remember
15:29:20 <erisco> but iirc you need to compile with a flag to get it to map the app threads to os threads
15:29:30 <rhovland> kuribas: hm thanks... I'm seeing a pretty nice (probably good enough) improvement just wrapping the sort with vector conversion and sorting in vector.. unfortunately it looks like I can't get Data.Vector.Algorithms.* on the site, so I suppose I'll roll my own quicksort and see how it goes
15:29:34 * hackagebot gitit 0.11.1.1 - Wiki using happstack, git or darcs, and pandoc.  https://hackage.haskell.org/package/gitit-0.11.1.1 (JohnMacFarlane)
15:29:59 <rhovland> I've always wondered how to convert things to run in parallel
15:30:11 <kuribas> rhovland: you can copy the source from Data.Vector.Algorithms :-))
15:30:14 <absence> is there a non-emacs/vim editor that uses ghc-mod and works? i've tried intellij idea and atom, but neither manages basic stuff like "go to definition" or "show type"
15:31:08 <rhovland> kuribas: is vector definitely better for this sort of thing than unboxed array?
15:32:05 <kuribas> rhovland: vector does stream fusion.
15:32:19 <nolrai66> absence: Leksah?
15:32:52 <kuribas> rhovland: so it depends, but often vector can optimize higher level compositions.
15:32:57 <johnw> rhovland: stream fusion here means that your executable ends up having no actual vectors in it, it's all loops and mutation behind the scenes
15:33:23 <johnw> i.e., work with the abstraction, but without paying for it
15:33:39 <kuribas> I cannot get the lists to evaluate in parallel...
15:34:00 <erisco> wait what
15:34:29 <erisco> why does compiling a regex in the Posix library return in IO
15:34:33 <absence> nolrai66: gtk3 has problems with font rendering on windows
15:34:34 * hackagebot GLFW-b 1.4.7.3 - Bindings to GLFW OpenGL library  https://hackage.haskell.org/package/GLFW-b-1.4.7.3 (SchellScivally)
15:34:35 <broma0> Anyone know of a good library for validation of the values in user-defined records?
15:34:47 <erisco> it ffis doesn't it
15:35:25 <erisco> this is silliness
15:35:49 <kuribas> rhovland: if I could manage to make it parallel, it would give another improvement.
15:36:05 <kuribas> rhovland: sadly my parallel-fu is weak at this moment.
15:36:10 <_d0t> ohai
15:36:17 <erisco> the state of regexp in Haskell is disastrous
15:36:20 <_d0t> is there a way to pretty print haskell data structures in ghci?
15:36:54 <erisco> putStrLn . show
15:37:01 <hodapp> johnw: hmmm, would Copilot be a form of stream fusion then? It presents the abstraction of a list, but at C-runtime it's all turned to loops and mutation over whatever time-values one references.
15:37:49 <absence> nolrai66: it was the first editor i used for haskell though, back when it was gtk2. i had no idea what ghc-mod was back then, but i liked the editor :)
15:38:00 <rhovland> kuribas: yeah, it's very parallelizable, I'd expect at least a 3x speedup out of that.. on the other hand, I'm sure it won't be run in parallel on the site, so it sort of doesn't matter
15:38:02 <erisco> in TDFA I can see the Pattern, but I still cannot find how to construct a Pattern
15:38:15 <kuribas> rhovland: ok then
15:38:22 <nshepperd> _d0t: check out https://hackage.haskell.org/packages/#cat:Pretty%20Printer
15:38:48 <erisco> Text.Regex.TDFA.ReadRegex
15:38:49 <erisco> of course it is
15:39:43 <rhovland> kuribas: I like how you're reading things directly into vector too.. did you get a speedup out of that? it's definitely cleaner
15:41:05 <kuribas> rhovland: probably, I haven't looked at the core.
15:41:21 <kuribas> rhovland: -O2 is a bit faster than -O1 also.
15:44:12 <bz> what advantages are there to writing a custom continuation monad instead of using Monad.State?
15:46:25 <nolrai66> bz: Well /maybe/ performance.
15:46:56 <nolrai66> Not sure you get that much with the codensity transform on state.
15:47:00 <nolrai66> *State.
15:49:13 <bz> co-what? could you elaborate a bit?
15:49:22 <bz> nolrai66: ^
15:53:03 <nolrai66> bz: Do you know about difference lists, and how they handle repeated "++" better then normal lists?
15:54:31 <bz> nolrai66: lazily. it's o(n) rather than n**2 because the list isn't regenerated on each eval of append
15:54:50 <nolrai66> bz: the codensity transform is basicly doing the same thing for monads, so that right* associating bind (>>=) is efficent. (*I might have the direction backwards.)
15:55:07 <nolrai66> bz: Its what I thought you were talking about.
16:00:52 <nolrai66> bz:?
16:04:19 <justmytw`> ls
16:08:29 <clm> hi
16:08:47 <nolrai66> 'ola
16:09:39 <clm> first time here, don't know the rules.. can i ask anything about haskell/programming?
16:09:59 <srhb> clm: Haskell especially, programming somewhat.
16:11:15 <clm> so i want to represent timeseries in haskell. And can't decide what to settle for. 
16:12:17 <clm> 1) Map Day Double 2) Vector (Day, Double) 3) { keys =Vector Day, values = Vector Double}
16:12:18 <user86> if I have a Num constraint on a and I need to return zero, how do I go about that? For Int it would be 0 and 0.0 in other cases, etc.
16:12:18 <srhb> ie. (t,y) sets?
16:12:26 <srhb> Ah
16:13:06 <srhb> clm: I wouldn't start working with vectors unless a naive Map solution turned out way too slow and the problem can be improved with vectors.
16:13:12 <nolrai66> @ty 0
16:13:14 <lambdabot> Num a => a
16:13:29 <nolrai66> user86: ^
16:13:42 <user86> thanks nolrai66!
16:13:54 <mek42> Will LYAH eventually discuss how to use multiple cores?
16:14:05 <arkeet> I don't think LYAH is getting updates.
16:14:06 <srhb> mek42: No, it does not.
16:14:23 <arkeet> it's already somewhat out of date for ghc 7.10
16:14:31 <geekosaur> @where parallel-haskell
16:14:31 <lambdabot> I know nothing about parallel-haskell.
16:14:42 <nolrai66> clm: what is your "Day" type like?
16:14:46 <arkeet> @where pcpih
16:14:46 <lambdabot> I know nothing about pcpih.
16:14:47 * geekosaur forgets where that one is stored
16:15:00 <arkeet> @where pcph
16:15:00 <lambdabot> I know nothing about pcph.
16:15:04 <arkeet> http://community.haskell.org/~simonmar/pcph/
16:15:05 <arkeet> :c
16:15:10 <arkeet> this is a book.
16:15:11 <arkeet> it's good
16:15:17 <mek42> Is it wise to finish LYAH before learning about parallel haskell or should I try to add parallel execution in right from the beginning?
16:15:43 <clm> nolrai66: the one from Data.Time.Calendar
16:15:49 <geekosaur> I think I'd suggest the NICTA course after LYAH, because LYAH tends to leave you able to read Haskell but not write it very well
16:16:01 <srhb> mek42: LYAH is not very good for very much. I would recommend doing an FP course like cis194 or something before trying parallel haskell or something similarly real world-y
16:16:08 <srhb> mek42: Unless you're already fine with FP
16:16:16 <geekosaur> NICTA will retread LYAH to some extent (and in fact uses it for some of its readings) but you will be able to write with some fluency
16:16:16 <arkeet> at least try the exercises for cis194
16:16:18 <dprt> LYAH covers material that you /don't/ need to write parallel Haskell code; but it doesn't cover /enough/ material to write good parallel Haskell code.
16:16:30 <geekosaur> or cis194, yeh
16:16:39 <geekosaur> both are recommended over LYAH these days
16:16:43 <dibblego> geekosaur: NICTA/course was around long before LYAH and doesn't use any of its material.
16:16:50 <srhb> NICTA is great, sure.
16:16:53 <geekosaur> right, I think I was confusing them
16:16:56 <mek42> i'm ok with elementary recursion - I kept up the first 2 or 3 weeks of a coursera course using SML, but then fell apart
16:17:05 <srhb> Then I'd do the cis194 course
16:17:11 <clm> srhb: thx, you suggest keeping it simple. but i want everything to "fuse" later hence why i thought of using vectors. also i mostly need contiguous slices of the time series. not sure if Map is good with slices.
16:17:12 <geekosaur> nicta vs cis194 which IIRC is the one with the lyah readings
16:17:14 <srhb> Onto NICTA, onto whatever you like
16:17:39 <arkeet> and you can always ask for help here
16:17:39 <geekosaur> you will definitely want more experience than LYAH will give you before parallelism
16:17:56 <srhb> clm: I'd never optimize before necessary. If you have actual problems, feel free to present them. :)
16:17:59 <dibblego> NICTA/course was designed to be run in-person and is happening next in Sydney in September (free  let me know if you are keen, we are already way overbooked)
16:19:01 <mek42> if there was a train from the states I'd hit up a friend for crash space (with my luck she's in Perth though)
16:20:18 <srhb> mek42: After doing cis194->NICTA, you'll be able to tackle real world problems without getting stuck on basic type issues. I think that's a good approach. :)
16:20:39 <srhb> mek42: Unless you really get bored with the courses, in which case, knock yourself out with real world problems (but it will be harder.) :-)
16:21:06 <mek42> srhb: is one of those better at graph isomorphism?
16:21:33 <srhb> That's a specific problem that comes mostly after understanding the basics of Haskell.
16:21:41 <srhb> ie. after either/both of them
16:23:00 <mek42> of course it is - the problem i want to work on which is bringing me to FP is a graph isomorphism problem
16:23:22 <srhb> I understand that. :)
16:23:52 <srhb> What I mean to say is that I consider cis194 more basic than NICTA, and neither of them deal with graphs specifically, afaik.
16:24:25 <srhb> If you feel comfortable using Haskell and just need domain specific knowledge relevant to graphs, neither of them are relevant.
16:24:37 <srhb> If not, you're probably well off looking at those before tackling specific problems.
16:24:54 <arkeet> @where+ pcph http://community.haskell.org/~simonmar/pcph/
16:24:55 <lambdabot> Good to know.
16:25:18 <mek42> i'll go on to the next page of lyah and if it stays fairly basic, I'll check out the two you suggest
16:25:23 <Guest75494> I tried to define a functor, but I'm not entirely sure I get it. Can someone check my work? http://lpaste.net/138844
16:26:04 <srhb> Guest75494: Looks like an error to me. Node a will parse as two arguments. Does it even compile?
16:26:12 <mek42> I would like to learn parallel from the get go - is that strongly not resuggested for learning haskell?
16:26:26 <srhb> mek42: I strongly suggest against it unless you have a solid FP background.
16:26:32 <srhb> mek42: I don't know what others think :)
16:26:50 <nolrai66> mek42: I am not sure what that would even mean for Haskell.
16:27:03 <Guest75494> srhb: it doesn't compile
16:27:10 <kuribas> rhovland: apparently Data.Vector isn't included either.
16:27:11 <srhb> Guest75494: And what does Node (f a) map fmap f even mean?
16:27:25 <srhb> Guest75494: Note that it's the Node constructor applied to (f a), map, fmap and f
16:27:33 <srhb> Guest75494: I don't think that's what you mean.
16:27:52 <Guest75494> I guess I don't get the declaration of tree I've only seen declarations like data = x | y | z
16:27:58 <mek42> isn't concurrency a strong point for FP?  and isn't parallel processing a subset of concurrency?  (please let me know if I'm misunderstanding things)
16:28:12 <srhb> mek42: Yes, absolutely.
16:28:21 <Guest75494> I guess what I'm trying to do is map f over the value in the node, then map fmap over all its subtrees
16:28:23 <srhb> mek42: That doesn't mean that it's a sane entry point to FP. :)
16:28:40 <nolrai66> mek42: What you mean by concurrency is yes a strong point.
16:28:56 <nolrai66> mek42: And yes, parallel processing is part of that.
16:28:59 <srhb> Guest75494: That sounds very reasonable. But if f :: a -> b and the Node has an a...
16:29:07 <arkeet> Guest75494: I think you should review how data declarations work
16:29:13 <arkeet> with constructors that take arguments
16:29:22 <arkeet> http://www.seas.upenn.edu/~cis194/spring13/lectures/02-ADTs.html
16:29:23 <srhb> Guest75494: Then Node (f a) is correct (so far) but what does map fmap mean?
16:29:35 <mek42> srhb: I guess I'm figuring I may as well eat the insanity point now so that when I get to where I need to be for my problem I'll know how to do it in parallel for better throughput.
16:29:46 <srhb> mek42: Yes, I think that's just plain wrong.
16:29:59 <srhb> mek42: You're much better off focusing on the basics before anything else.
16:30:03 <nolrai66> mek42: but in the haskell community "concurrency" and "parallelism" are used to mean to disjoint things.
16:30:06 <Guest75494> well [Tree] is a functor wrapped in another functor I think, so I'm mapping a map function...
16:30:15 <srhb> Guest75494: [Tree] is not a Functor.
16:30:29 <Guest75494> [] is a functor right? And Tree is a functor?
16:30:43 <srhb> Guest75494: [] is a Functor and Tree is a functor, yes.
16:31:07 <nolrai66> Guest75494: I think you need "`" around some of those maps/fmaps.
16:31:08 <kuribas> is there composition of functors?
16:31:16 <nolrai66> There is.
16:32:10 <nolrai66> I am not sure what srhb means by "[Tree] is not a Functor." its true, but I am not seeing how its relevant.
16:32:30 <kuribas> ah https://hackage.haskell.org/package/category-extras-0.53.4/docs/Control-Functor-Composition.html
16:32:38 <Guest75494> I think I'm understanding a little more...
16:32:41 <srhb> Nothing much. Just that it was not true.
16:32:59 <Guest75494> In data Tree a = Node a [Tree a], Node is the value constructor right? And it accepts an arg of type a and another of type [Tree a]
16:33:28 <srhb> Yes.
16:33:37 <Guest75494> so when I declare fmap, do I have to start with fmap Node a b = ...
16:33:53 <Guest75494> where b is of type [Tree]
16:34:08 <nshepperd> Guest75494: you have to put parentheses around the Node a b
16:34:15 <nshepperd> fmap (Node a b) = ...
16:34:36 <nshepperd> er, fmap f (Node a b) = ...
16:34:40 <Guest75494> ohh. Thanks for your patience in explaining everyone :)
16:34:43 <srhb> Otherwise it is understood as a function fmap with three arguments (which it does not take.)
16:34:52 <srhb> f, Node, a and b
16:36:49 <rhovland> kuribas: well _part_ of it is, anyway... I can do import qualified Data.Vector.Unboxed as V, and V.toList $ V.fromList works..  now I'm trying to convert my stuarray heapsort to unboxed vector heapsort
16:37:09 <mek42> srhb: ok, I will start with those courses you suggested and when o'reilly has another 60% off of $100 purchase sales i'll get that concurrent & parallel haskell ebook
16:37:37 <srhb> mek42: It's a great book. I think it's available online for free, too, if you can live with that. :)
16:38:13 <kuribas> rhovland: Data.Vector wasn't on the supported libraries list...
16:38:34 <Guest75494> I think I'm getting a little closer... http://lpaste.net/138844
16:38:39 <mek42> srhb: it sure is, and i sure can, and now it will be a great challenge to not open it until I make serious progress learning the language :)
16:38:57 <srhb> mek42: Hehe, I'm not saying NOT to open it. :-)
16:39:15 <rhovland> kuribas: I think anything that ships standard is supposed to be supported... vector is standard right? (I mean, so is vector.algorithms I think, so I could probably just send them an email to get those included)
16:39:17 <srhb> mek42: Just that you might run into some frustrating stumbling blocks that would be rather trivial had you first done the suggested courses.
16:39:50 <srhb> Guest75494: Think about your paranthesis and what map fmap f means
16:39:51 <Gurkenglas_> Guest75494, what do you pass to map as the first argument?
16:40:35 <kuribas> rhovland: Data.Vector is not from base...
16:40:39 <srhb> Guest75494: (again, map takes two arguments, and you are providing fmap and f as those two arguments... That's probably not what you mean)
16:40:43 <mek42> srhb: understood
16:41:14 <srhb> mek42: Regardless, I hope you have fun learning Haskell. :)
16:43:16 <mek42> one last educational question before I need to go - after cis194 / nicta, will SICP still be a useful read?
16:43:39 <rhovland> kuribas: huh... well, that's interesting... hmm.. is array part of base? I don't see it in the list... or map... those are definitely available
16:43:51 <srhb> I've never actually read SICP, but I've heard many people speak fondly of it.
16:44:03 <srhb> I think it's more suited to lisps.
16:44:51 <Guest75494> !!! I finally got it working. Thanks for the tips about the order of execution @srhb @Gurkenglas
16:45:05 <Guest75494> It makes substantially more sense now
16:45:16 <srhb> Guest75494: order of execution was not your problem, but you're welcome. :-)
16:46:59 <Guest75494> I ended up fixing my last attempt by putting in parentheses. Am I misusing order of execution here? I guess I mean that I thought fmap would apply to f instead of map applying to both
16:47:12 <mek42> srhb: tyvm - LISP is on my list too (see what I did there? ;) ), but I figure I should do a FP pure language to learn FP for the first time
16:47:42 <kuribas> rhovland: apparently those ship with ghc.
16:47:49 <srhb> mek42: I can only concur with that, but I'm obviously supremely biased. :)
16:49:20 <mek42> do I need to know anything about OOP for cis194?  that polymorphism word in lecture 2 scares me, lol
16:49:49 <arkeet> nope
16:50:00 <arkeet> ideally you know nothing about OOP 
16:50:33 <mek42> arkeet: I'll be at about 99% ideal then, lol
16:50:46 <arkeet> :)
16:50:46 <geekosaur> polymoirphism in haskell and polymorphism in OOP are rather different things
16:50:51 <arkeet> yeah
16:51:03 <maerwald> hihi
16:51:08 <mek42> ok, gotta go, have great weekend!
16:52:48 <shodan`> Hey for some reason I seem to be unable to install hlint: 3>Constructor âIVarâ should have 2 arguments, but has been given 3
16:54:42 <glguy> shodan`: It'd help if you pasted more information than that to the pastebin so we'd have more context for the error
16:54:58 <shodan`> sure give me a second
16:55:59 <shodan`> http://pastebin.com/Dz39nPjS
16:56:16 <ttt_fff> I know about Data.Map.fromList ... but is ther ea version of fromList which "ADDS UP the COUNTS", i.e. [("a", 1), ("a", 3)] -> map where "a" ==> 4 ?
16:56:24 <ttt_fff> so I don't want "last writer wins" but "sum up all the adders
16:57:52 <nshepperd> ttt_fff: fromListWith
16:58:27 <nshepperd> keep hackage close at hand, for it has all the answers
16:58:31 <ttt_fff> nshepperd: nice! I was about to use Data.List.groupBy, and manually add it myself
16:59:01 <AaronFriel> Y'all said I was crazy
16:59:14 <AaronFriel> Crazy Aaron, merging bytestrings and playing with the internal constructors
16:59:25 <AaronFriel> Just use Builder for speed
16:59:35 <AaronFriel> Well I finished my parser lib, may open source it when I flesh it out
16:59:53 <AaronFriel> And it's about ~50x the speed of Attoparsec on doing HTML5 tokenization and token replacement
17:00:37 <AaronFriel> Attoparsec just plain doesn't perform when you need to work with a giant document of tiny pieces
17:02:17 <Guest75494> Can there be multiple value constructors with the same name?
17:02:26 <glguy> shodan`: Which version of haskell-src-exts do you have?
17:02:35 <Guest75494> And just different arguments?
17:02:35 <shodan`> the latest
17:02:59 <shodan`> glguy: git HEAD
17:03:15 <geekosaur> Guest75494, no
17:04:37 * hackagebot pandoc-citeproc 0.7.3.1 - Supports using pandoc with citeproc  https://hackage.haskell.org/package/pandoc-citeproc-0.7.3.1 (JohnMacFarlane)
17:04:57 <glguy> shodan`: OK, uninstall that and grab the released version.
17:05:08 <shodan`> that won't install for some reason
17:05:44 <glguy> shodan`: OK, then you've got a new problem to figure out, but the HEAD version of haskell-src-exts is incompatible with hlint
17:05:54 <glguy> https://github.com/haskell-suite/haskell-src-exts/commit/b0527bfe44902a2f885ca34ba471b21a0c99f780
17:06:00 <glguy> due to that change 4 days ago
17:06:09 <shodan`> odd
17:06:15 <shodan`>  it seems to install 1.16.0.1 now
17:13:46 <shodan`> glguy: ye that fixed it, thanks
17:14:38 * hackagebot directory 1.2.3.1 - Platform-agnostic library for filesystem operations  https://hackage.haskell.org/package/directory-1.2.3.1 (Rufflewind)
17:25:52 <lamefun> can I automatically generate documentation for Template Haskell generated stuff?
17:28:01 <glguy> lamefun: No.
17:29:04 <lamefun> Is there a language with a more complete implementation of Template Haskell concept?
17:55:18 <hackrilege> i had a go at making a zipper, heres what i ended up with... http://lpaste.net/138850
17:55:33 <hackrilege> can someoe tell me if this is a ziiper?
17:55:39 <hackrilege> zipper*
17:56:30 <dramforever> I'm not sure, but it looks pretty nice
17:57:19 <dramforever> wait that's not a zipper, but it might also work =)
17:57:51 <dmj`> data Zipper a = Zipper [a] [a]
17:58:15 <hackrilege> oh i thought it was just a concept, sorry i got confused, i think i meant traversable
17:58:42 <dramforever> hackrilege: so far so good =)
17:59:07 <hackrilege> its trying to behave like a traversable lens...
17:59:30 <dramforever> wait why didn't you use an array library or something?
17:59:49 <hackrilege> but i guess im not storing anything except this generating function so maybe thats cheating... 
18:00:27 <dramforever> dunno then =)
18:00:48 <hackrilege> dramforever, im trying to understand the various containers and implement them in a minimal way, if i need more speed ill make a faster lookup or something
18:00:59 <nolrai66> "Hey everybody! This bear is my friend and it's in trouble so I have to take it to a castle but I promise not to be gone for too long!"
18:01:04 <dramforever> yes that's also what I mean
18:01:19 <keefer> GCE vs AWS for haskell app?
18:02:40 <hackrilege> but for the time being i just wanted a datastructure i could find the neighbours of an element like in a graph...
18:03:37 <dramforever> so how's fgl?
18:06:44 <hackrilege> its good, but i think i find the inductive bit confusing...
18:07:07 <dramforever> I'm not really sure, too
18:07:47 <dramforever> I'd say that it's just all kinds of views over a graph
18:08:14 <hackrilege> as its a class its only structure is defined in the type signatures of the abstract classes, where it appears as gr a b. i find this confusing
18:09:07 <dramforever> this README here looks useful:https://github.com/haskell/fgl
18:11:26 <hackrilege> no there is nothin there... anyway i read the source, but i prefer data Graph a = Graph a [Graph a]  or some such
18:12:15 <hackrilege> also their traversal was just defined with simple recursion, its not as fast as Map i dont think...
18:13:34 <hackrilege> i was considering Lens.Traversable, but it looks like a hollow copy of Data.Traversable, so I thought id try and make a kind of traversable example, as in the paste http://lpaste.net/138850
18:13:36 <dramforever> no more suggestions.
18:13:55 <hackrilege> oh ok
18:14:02 <dramforever> hackrilege: I'm thinking, maybe that knot tying thing has problems
18:14:13 <hackrilege> yes 
18:14:20 <dramforever> for example, if you fmap over it, you end up with an unevaluated infinite structure
18:14:36 <dramforever> rather than a finite structure with knot
18:14:39 <dramforever> *knots
18:14:40 * hackagebot vty 5.4.0 - A simple terminal UI library  https://hackage.haskell.org/package/vty-5.4.0 (CoreyOConnor)
18:14:42 * hackagebot vty-examples 5.4.0 - Examples programs using the vty library.  https://hackage.haskell.org/package/vty-examples-5.4.0 (CoreyOConnor)
18:19:44 <hackrilege> dramforever: i tried doing it like this; http://lpaste.net/138851
18:20:32 <dramforever> I wonder what that ClosedLoop does
18:20:54 <dramforever> because it really doesn't seem to do much
18:21:05 <hackrilege> i can patern match it to terminate my traversal
18:21:17 <dramforever> kinda weird...
18:21:19 <hackrilege> as in the Show instance
18:21:29 <dramforever> dealing with graphs is hard
18:23:34 <hackrilege> so its a kind of reference to a subtree which should not be traversed acrosss
18:28:35 <nshepperd> if I was just going to implement a graph structure for doing graph things, I'd probably use something boring like Vector (Vector Int) to store the edges
18:29:31 <nshepperd> or IntMap
18:30:15 <nshepperd> which is more or less what at least one of the fgl representations does
18:31:10 <nshepperd> PatriciaTree 
18:32:18 <dramforever> Vector (Vector Int) looks inefficient for sparse graphs
18:32:25 <dramforever> which seems to be the case in polymers
18:33:33 <nshepperd> uh
18:33:35 <nshepperd> heh
18:33:52 <nshepperd> I meant Vector (Vector VertexID)
18:33:57 <dramforever> oh
18:34:14 <dramforever> oh sorry I misunderstood you
18:34:25 <dramforever> sorry your's isn't inefficient, my mistake
18:35:39 <hackrilege> if i have a very large structure is it not very costly to examine each element so see it it is the flag? and thats why infact a IntMap is a Tree...
18:38:03 <hackrilege> pardon me, i mean, an IntMap provides an interface for referencing vertexes and storing edges. but really its a tree...
18:41:44 <nshepperd> yes, an IntMap is a kind of tree
18:42:17 <nshepperd> or rather, is implemented as a tree
18:42:29 <hackrilege> whats the difference if at each vertex i store a list of int references or just a list of the objects?
18:43:45 <nshepperd> you can't test equality of objects in general
18:43:56 <hackrilege> i was sure that the int references must be a slower way to access the data, since you have to traverse the whole tree filtering for the flag, wheras in a tree you directly have access to the datastructures you require, neatly in a list for you
18:44:41 <nshepperd> so, you'd have to add a NodeID to each vertex's structure for some algorithms
18:45:38 <hackrilege> i dont see why i need any id other than referencing connectivity for traversal, this is immidiate with a tree, but one step removed with a Map...7
18:46:43 <nshepperd> all the main graph algorithms need to know stuff like "have i visited this vertex before"
18:46:52 <hackrilege> also, as is my concern, i dont understand infact how these int referencing could be as fast as the tree, since i presume the lookup is costly. is the lookup costly?
18:47:20 <nshepperd> lookup in an IntMap is "very cheap"
18:47:32 <dramforever> O(log N), fyi
18:47:37 <dramforever> or is it?
18:47:38 <nshepperd> lookup in a Vector is practically free
18:47:56 <hackrilege> nshepperd: with my http://lpaste.net/138851 i chose not to traverse across some part of the datastructures pattern, which meant i could avoid recursion and ensure i visit each node once
18:48:04 <nshepperd> O(min(n, intsize))
18:48:22 <nshepperd> where intsize is probably 32 bits
18:49:15 <hackrilege> but in a linked list stepping to a neighbour would be O(1) and this is the kind of traversal i require 
18:51:01 <hackrilege> i need to create stencils of significant size by iterative nearest neighbour access... the lookup alone is going to take almost the whole running time 
18:52:32 <hackrilege> im guessing you want benchmarks again
18:53:50 <dramforever> hackrilege: is your graph static or notT?T
18:53:52 <dramforever> not?
18:54:09 <hackrilege> it can be if it needs to be so lets say yes
18:54:11 <dramforever> I mean, do you "change" graphs?
18:54:15 <hackrilege> no
18:54:30 <hackrilege> well not the connectivity, just the stored values
18:54:57 <erisco> in parsec how do you parse your own token stream when some tokens have parameters?
18:55:06 <dramforever> hmm...
18:55:14 <erisco> for example I want to parse any TokenIdentifier, but TokenIdentifier is of type String -> Token
18:55:51 <dramforever> erisco: that doesn't make sense to me, you just make your own Token type and somehow give parsec a list of Tokens or something
18:55:59 <dramforever> and that's probably it, unless I'm missing something
18:56:19 * dramforever goes to parsec docs to check for sure
18:57:16 <dramforever> yes it is
18:57:32 <erisco> I don't know what you're talking about
18:57:36 <erisco> let me ask something else then
18:57:41 <dramforever> do you have a list of tokens?
18:57:47 <erisco> how do I make the parser for a single token?
18:57:54 <dramforever> oh that
18:58:06 <dramforever> sorry I thought you already have a token stream and want to parse that
18:58:12 <erisco> yes I do
18:58:22 <dramforever> so what's the problem?
18:58:25 <erisco> ...
18:58:48 <erisco> if I asked how to make the parser for the letter 'a'
18:58:49 <jasonkuhrt> Hi, I have a simple newb question
18:58:59 <jasonkuhrt> Why isn't this a valid type for this function?
18:59:00 <jasonkuhrt> hasChange :: (Eq a, Eq b) => (a -> b) -> a -> Bool
18:59:00 <jasonkuhrt> hasChange f a = not $ a == f a
18:59:02 <erisco> this is the same question, but for a particular token
18:59:31 <nitrix> araujo: ping
18:59:51 <erisco> jasonkuhrt, because   f a :: b  and  (==) :: a -> a -> Bool
18:59:56 <jasonkuhrt> This works but then I'm forcing f to have to returnt he same type which is overly constrictive
18:59:56 <jasonkuhrt> hasChange :: Eq a => (a -> a) -> a -> Bool
18:59:57 <jasonkuhrt> hasChange f a = not $ a == f a
18:59:58 <dramforever> erisco: hmm interestingly there's a satisfy for Chars only
19:00:00 <dramforever> weird
19:00:08 <dramforever> jasonkuhrt: it's not
19:00:14 <dramforever> you can't compare Strings and Ints
19:00:23 <erisco> jasonkuhrt, it isn't overly restrictive, it is necessary, you cannot equate different types
19:00:24 <dramforever> although you can compare a String with a String
19:00:35 <jasonkuhrt> oooh
19:01:00 <jasonkuhrt> its not == like "those other languages"
19:01:09 <jasonkuhrt> Right, this makes sense now thanks
19:01:14 <dramforever> =)
19:01:32 <dramforever> erisco: here we go: http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Prim.html#v:token
19:01:35 <jasonkuhrt> duh but I couldn't get around seeing == through the lens of dynamicness
19:01:38 <erisco> other languages have implicit coercions that take place when you do equality
19:01:48 <erisco> every language compares equal types
19:01:48 <nshepperd> erisco: Text.Parsec.Prim.token?
19:02:00 <dramforever> nshepperd: lol
19:02:05 <jasonkuhrt> So
19:02:19 <dramforever> erisco: does that make sense?
19:02:21 <jasonkuhrt> in other langs you use == to figure out if they are the same type or not sometimes
19:02:33 <jasonkuhrt> in haskell that doesn't really apply right
19:02:37 <dramforever> exactly
19:02:46 <jasonkuhrt> your program already knows the types... you can destructure on them... etc.
19:02:55 <erisco> dramforever, this will be a pain in the butt, but yes
19:03:06 <jasonkuhrt> cool thanks ya'll
19:03:15 <kadoban> If they're not already the same type, you can't use (==) on them (or you'd get a type error).
19:03:31 <dramforever> erisco: I'm pretty sure it isn't that painful
19:03:35 <erisco> oh it is
19:03:44 <dramforever> sorry for that then
19:04:11 <jasonkuhrt> Wow: tokenPrimEx :: Stream s m t => (t -> String) -> (SourcePos -> t -> s -> SourcePos) -> Maybe (SourcePos -> t -> s -> u -> u) -> (t -> Maybe a) -> ParsecT s u m a
19:04:27 <jasonkuhrt> How long will it take to feel comfortable with types like that?
19:04:39 <jasonkuhrt> and are types like that common?
19:04:43 <koala_man> how do you know what kind of exception something is so you can catch it?
19:04:48 <erisco> jasonkuhrt, well I for one never feel comfortable with monad transformers, so possibly never
19:05:07 <dramforever> jasonkuhrt: not really, that looks like a complexed internal-ish primitive function that does a lot
19:05:19 <kadoban> jasonkuhrt: The types in Parsec are kind of funky because they have to abstract over a few quite different things. When you use them concretely they're much more understandable.
19:05:30 <dramforever> and you'll have to know parsec stuff to understand that
19:05:32 <erisco> it isn't actually that complicated if you know what you're looking for in the first place
19:05:36 <dramforever> exactly
19:05:59 <jasonkuhrt> cool
19:06:12 <dramforever> jasonkuhrt: actually generality is a good thing
19:06:25 <jasonkuhrt> Curious what the longest type in Haskell wildnerness seen is
19:06:29 <erisco> not always
19:06:34 <dramforever> :t confusing -- this?
19:06:35 <lambdabot> Applicative f => LensLike (Data.Functor.Kan.Rift.Rift (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
19:06:40 <dramforever> that's not very long...
19:06:48 <dramforever> just lots of qualified names
19:07:33 <erisco> unstablePartitionBundle :: (PrimMonad m, MVector v a) => (a -> Bool) -> Bundle u a -> m (v (PrimState m) a, v (PrimState m) a)
19:07:43 <erisco> that is from a lib I don't like
19:08:18 <kadoban> If you're just talking about the longest type, some contsructor of a big record type would probably be it. It's not terribly hard to understand though.
19:08:20 <hackrilege> anyone know a good way of doing simple benchmarks? im tempted to use the system clock...
19:09:13 <nshepperd> @hackage criterion
19:09:13 <lambdabot> http://hackage.haskell.org/package/criterion
19:09:34 <nshepperd> ^^ slightly more effort than using the system clock but a lot more reliable
19:09:46 <hackrilege> thanks nshepperd
19:10:33 <nshepperd> main = benchmark $ nf func argument
19:12:22 <AaronFriel> Just want to say this - I think Builder has become an anti-pattern in the Haskell web library area
19:12:27 <AaronFriel> I mean Blaze-Builder and friends
19:12:35 <AaronFriel> The advice has been to use Builder for everything always
19:12:38 <nshepperd> hackrilege: also consider that if you can use unboxed arrays (Vector (Unboxed.Vector NodeID)) you can save a lot of memory and therefore cache
19:12:48 <nshepperd> this may or may not be relevant to your application
19:13:03 <AaronFriel> But I'm looking at Wai/Warp and if you use builders for everything, you end up making many copies of every piece of data you want to send through the library
19:13:18 <AaronFriel> there's even "helpful" streaming patterns that use builders
19:13:26 <hackrilege> what is an unboxed array?
19:13:55 <AaronFriel> which is terrible, HTTP/1.1 and HTTP/2.0 support chunked transfers, so sending small bits of something is (usually) not a problem
19:13:58 <dramforever> AaronFriel: "many copies of every piece of data" are you sure about this?
19:14:01 <AaronFriel> Yeah
19:14:15 <dramforever> I thought builders are supposed to avoid this
19:14:17 <AaronFriel> That's how I sped up my HTML parser - I threw away the Builders
19:14:18 <AaronFriel> not
19:14:20 <AaronFriel> no*
19:14:24 <AaronFriel> the anti-pattern is
19:14:31 <AaronFriel> "I need to collect some bytestrings! I'll use a builder"
19:14:42 <AaronFriel> "Now I need to consume some bytestrings, time to use up the builder!"
19:14:51 <AaronFriel> "Welp, time to send them to somewhere else, better use a Builder!"
19:14:59 <dramforever> hmm...
19:15:04 <AaronFriel> the problem is 
19:15:09 <hackrilege> its "strictness with performance boost"
19:15:10 <AaronFriel> Builder *ALWAYS* copies bytes
19:15:17 <AaronFriel> ALWAYS
19:15:25 <dramforever> AaronFriel: when consumed
19:15:30 <AaronFriel> yes
19:15:36 <AaronFriel> but the problem is, if you have 3 layers of builders
19:15:41 <AaronFriel> you make 3 copies of every byte
19:16:00 <AaronFriel> So if you're packaging up some data from Wai/Warp with a builder, that's one copy
19:16:16 <AaronFriel> then you do some work with it, that's another
19:16:18 <dramforever> that's really interesting
19:16:22 <AaronFriel> then ... and so on
19:16:27 <hackrilege> what do the bangs and the hashe mean in this; data UArray i e = UArray !i !i !Int ByteArray#
19:16:39 <nshepperd> hackrilege: normal haskell values are boxed, which means allocated on the heap in a container
19:16:48 <AaronFriel> dramforever: I wrote an HTML5 tokenization library built on Attoparsec, and small parsers
19:17:01 <AaronFriel> it follows the spec (which is annoying)
19:17:05 <nshepperd> hackrilege: the container can be multiple bytes of the size of the actual contents
19:17:10 <AaronFriel> but that means it also ocnsumes really small chunks of bytes
19:17:16 <dramforever> AaronFriel: hmm...maybe we could make attoparsec consume a builder?
19:17:16 <AaronFriel> consumes*
19:17:25 <AaronFriel> dramforever: I did one better
19:17:40 <dramforever> oh just throw away the builders?
19:17:41 <AaronFriel> dramforever: I wrote a new parsing library!
19:17:45 <AaronFriel> yaaaay
19:17:52 <dramforever> wow
19:17:58 <dramforever> care to share?
19:18:01 <nshepperd> hackrilege: an unboxed vector stores its contents in a C-like array
19:18:08 <AaronFriel> Yeah I'll share it within the week
19:18:12 <hackrilege> using FFI?
19:18:22 <dramforever> AaronFriel: nice
19:18:38 <AaronFriel> dramforever: This library gets vastly better performance, and I used a lot of type class and family trickery to allow it to support a lot of inputs and outputs
19:18:46 <nshepperd> hackrilege: not necessarily. compiler magic is involved
19:18:50 <dramforever> =)
19:18:56 <AaronFriel> dramforever: You can pull in bytestring, text, Seq a, [a], etc.
19:19:00 <nshepperd> er, can be involved
19:19:02 * dramforever is only interested, though
19:19:12 <hackrilege> ok so bangs and hash indicate compiler magic...
19:19:13 <dramforever> because he isn't going to use haskell that way
19:19:29 <dramforever> hackrilege: hashes indicate magic
19:19:32 <dramforever> bangs are simpler
19:19:36 <AaronFriel> yeah, avoid bangs
19:19:41 <AaronFriel> err hashes
19:19:45 <AaronFriel> I have exactly one in my library
19:19:48 <nshepperd> hackrilege: oh, the bangs just mean that field is strict, so it is evaluated whenever the constructor is
19:19:48 <dramforever> lol lol
19:19:54 <AaronFriel> it's so that I can peek at the underlying storage under a Data.Text
19:19:54 <hackrilege> but i want to understand their use in; data UArray i e = UArray !i !i !Int ByteArray#
19:20:15 <dramforever> nshepperd: I like this, we could explain this together
19:20:20 <erisco> shorthand for unpack? I can't remember
19:20:24 <dramforever> strict
19:20:29 <erisco> that's ! I thought
19:20:44 <hackrilege> ok i get the bangs are strict, and the hash is magic, so here we have strict magic, no more information than before.. its ok i guess i dont need to know...
19:20:46 <nshepperd> the hash doesn't "mean" anything special there
19:20:48 <AaronFriel> dramforever: The key innovation is a typeclass for types that support true O(1) (time/space) appends, and those that don't 
19:20:52 <nshepperd> ByteArray# is a primitive type that comes with ghc
19:21:10 <dramforever> AaronFriel: hmm...like builders?
19:21:19 <nshepperd> the hash is just part of its name, but it indicates that the type is from the compiler
19:21:22 <AaronFriel> Builders are O(n) space
19:21:24 <AaronFriel> I'm talking
19:21:31 <AaronFriel> let's say you have a source document from a 1000-byte ByteString
19:21:32 <dramforever> oh sorry no
19:21:47 <AaronFriel> your parser is going to do stuff like "take 5", "takeWhile n ..." etc
19:22:05 <AaronFriel> each time it does that, it does an O(1) substring operation
19:22:16 <hackrilege> ok so the next question is why you use Vectors of unboxed arrays...
19:22:30 <AaronFriel> well, a ByteString is a (PS fptr off len)
19:22:41 <AaronFriel> if I have a current "hot" bytestring, e.g.: the last thing I've read
19:22:46 <AaronFriel> i.e.: rather
19:22:55 <AaronFriel> and I emit a new bytestring
19:22:59 <dramforever> hackrilege: because those unboxed arrays don't have the same length
19:23:02 <AaronFriel> and they are of the shape
19:23:08 <dramforever> so the outer one isn't unboxed
19:23:35 <AaronFriel> hot@(PS fptr off len) new@(PS fptr (off + len) len) 
19:23:37 <dramforever> AaronFriel: wait wait I vaguely remember something related
19:23:40 <hackrilege> the outer one needs a box?
19:24:04 <AaronFriel> then I can append the two by just returning merged@(PS fptr off (len + len'))
19:24:12 <dramforever> hackrilege: sort of
19:24:13 <dramforever> https://www.fpcomplete.com/user/edwardk/heap-of-successes
19:24:16 <nshepperd> hackrilege: yeah it's just because you can't put an unboxed vector in an unboxed vector
19:24:21 <dramforever> AaronFriel: ^ might be interesting
19:24:41 <hackrilege> oh thats what it meas to have a box?
19:24:50 <hackrilege> means*
19:25:24 <dramforever> I think only stuff with a fixed size can be put in unboxed vectors
19:25:34 <dramforever> oh and they need to be C-like
19:25:49 <dramforever> so you could actually read a few bytes of memory to construct one
19:25:50 <AaronFriel> dramforever: Yes! that is very interesting, thank you
19:25:58 <hackrilege> then why cant you put an unboxed vector in an unboxed vector?
19:26:06 <dramforever> AaronFriel: yw =)
19:26:16 <dramforever> hackrilege: you don't know where those elements are
19:26:30 <AaronFriel> dramforever: I'm not sure if I can implement an Update monad, or if it might give me perf improvements
19:26:43 <AaronFriel> dramforever: But I've got a whole slew of benchmarks to run tonight
19:26:50 <hackrilege> kind of like storing a list without a reference to its length?
19:26:57 <dmj`> Test.QuickCheck.Gen, where have you been all my life
19:27:10 <dramforever> hackrilege: yes
19:27:32 <dramforever> or like an array of zero-terminated strings
19:27:37 <nshepperd> well, an unboxed vector could be thought of as an offset :: Int, size :: Int, and a pointer to the byte array
19:28:05 <nshepperd> you could in principle put those three items together as elements in an unboxed vector
19:28:14 <nshepperd> but the benefit would be really marginal
19:28:16 <dramforever> AaronFriel: I think with that Update thing you could actually let all your tokenizers return Parser ()
19:28:37 <AaronFriel> dramforever: Well, I'm doing considerably weirder things than that article talks about
19:28:45 <AaronFriel> dramforever: My monad is a Parser i b o a
19:28:55 <dramforever> and write a function that takes a parser and returns another that returns the result as well as the string consumed
19:29:00 <AaronFriel> dramforever: Input type, buffer type, output type, return type
19:29:05 <dramforever> or you could throw away the result
19:29:24 <AaronFriel> dramforever: The input is the hot data stream, the buffer is cold/lazy (e.g.: Lazy ByteString, or network socket)
19:29:34 <dramforever> ok
19:29:43 <AaronFriel> the output is where things get clever, you can output source references, or you can tokenize
19:29:59 <AaronFriel> I think I have something a lot like that Update monad already
19:30:28 <AaronFriel> my parser has no notion of returning a final value - I eschew that, and opt for something that returns small tokens
19:30:39 <dramforever> =)
19:30:40 <AaronFriel> you *could* accumulate a value all the way through
19:30:42 <hackrilege> so yu cant put unboxed arrays in unboxed arrays as even though they require a fixed size, they do not sotre their size and so cannot be known to be of fixed size for inclusion inside itself...
19:30:45 <hackrilege> ?
19:31:01 <AaronFriel> but instead of accumulating a value, I use the return type to create a state machine
19:31:13 <dramforever> hackrilege: it just doesn't make much sense
19:31:22 <dramforever> forget about it I screwed up
19:31:32 <dramforever> now I don't know why either
19:31:54 <hackrilege> bahaha
19:31:58 <dramforever> AaronFriel: actually that I/O stuff looks like conduits
19:32:10 <hackrilege> strict magic ftw
19:32:14 <lpaste_> AaronFriel pasted âstate machine benchmarkâ at http://lpaste.net/998155484831678464
19:32:30 <AaronFriel> dramforever: Yeah, the similarity with conduits was striking
19:32:36 <dramforever> =)
19:33:07 <AaronFriel> dramforever: There's an example of the state machine I'm using right now, I'm not tied to using `emit` and such, going to work on the API
19:33:23 <AaronFriel> but that is a simple parser that reads in ah HTML doc and strips comments
19:33:24 <dramforever> yes sure it's interesting
19:33:43 <hackrilege> ill steer clear of all of these unintelligible data structures, they need to be tangible if im going to implement them... and i need to implement them if i am going to use them 
19:33:54 <nshepperd> hackrilege: I'd say you probably /can/ put unboxed arrays in unboxed arrays. But no-one's written the instance because there wouldn't be much point
19:34:14 <dramforever> AaronFriel: wait I think I found something interesting in attoparsec
19:34:19 <hackrilege> i thought it was important but its just confusing so never mind...
19:34:24 <dramforever> http://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString.html#v:runScanner
19:34:47 <dramforever> still far from useful, though
19:34:49 <dramforever> =)
19:34:59 <nshepperd> hackrilege: you don't need to know how Vectors work, that's why we have hackage!
19:35:16 <AaronFriel> dramforever: Yeah, scan was close to what I wanted
19:35:30 <AaronFriel> dramforever: But it was painful, because under the hood Attoparsec uses its own weird buffer/builder type
19:35:32 <dramforever> hackrilege: is there a reason? why can't you just install that package?
19:35:34 <hackrilege> nono, i need to write out all the source i include
19:35:37 <dramforever> AaronFriel: =)
19:35:51 <hackrilege> its for educational purposes 
19:35:56 <AaronFriel> dramforever: So again, it made it hard to reason about how many copies of data my code was producing
19:36:01 <dramforever> hackrilege: I think you could just include a Vector
19:36:05 <dramforever> AaronFriel: =)
19:36:25 <hackrilege> i could implement a Vector yes
19:36:26 <dramforever> hackrilege: why can't you use a library? that's too weird
19:36:34 <dramforever> hackrilege: no I mean use a library
19:36:35 <nshepperd> what, like an assignment? what about the standard library :/
19:36:41 <hackrilege> because I need to understand what im doing.
19:36:50 <Axman6> >_<
19:36:52 <dramforever> weird...
19:36:56 <Axman6> very
19:36:59 <dramforever> you are using vector types
19:37:02 <Axman6> and incredibly unproductive
19:37:13 <hackrilege> i can write map in simple recursion, there is no need to import anything
19:37:24 <dramforever> hackrilege: I don't see a reason for this
19:37:34 <Axman6> you don't need to import anything to use map anyway...
19:37:36 <hackrilege> lol, thats not my fault!
19:37:43 <dramforever> for example, can you use putStrLn to output?
19:38:04 <lpaste_> AaronFriel revised âstate machine benchmarkâ: âNo titleâ at http://lpaste.net/998155484831678464
19:38:13 <AaronFriel> dramforever: That gives you some more of the types
19:38:16 <hackrilege> if you have never seen map before because you are a chemist, the recursive definition is informative. thats the whole point
19:38:42 <AaronFriel> my goal is to produce something that's just utterly painless to use and consume, and build parsers-on-parsers with
19:38:52 <dramforever> hackrilege: you could just say "this is a key value store"
19:39:10 <dramforever> that's more informative, IIUC, because those chemists are interested in polymers
19:39:31 <hackrilege> and then write out the source, and write informative unit tests, yes
19:39:35 <Axman6> hackrilege: knowing how something is implemented and avoiding using already written code are two very different things
19:39:36 <dramforever> so I guess you don't need to talk about details
19:39:55 <dramforever> hackrilege: you still haven't answered my question
19:40:05 <dramforever> can you use putStrLn for output?
19:40:31 <Axman6> the essence of progrmming is abstraction, and refusing to use code which has abstracted a solution to a problem for you already is ignoring what it mean to program
19:40:32 <dramforever> can you use the ghc compiler to compile your code?
19:40:37 <dramforever> can you use Data.Map?
19:41:06 <dramforever> https://en.wikipedia.org/wiki/Not_invented_here
19:41:19 <Axman6> by all means, go ahead and read the source code, and even go and write your own implementations if you need to learn by doing that, but don't out right refuse to use others code because you didn't write it
19:41:30 <dramforever> "The reasons for not wanting to use the work of others are varied, but can include ... lack of understanding of the  foreign work"
19:41:50 <hackrilege> dramforever; i am considering implementing Data.Map
19:41:57 <Axman6> I've written toy implementations of many algorithms from scratch, but I don't use them to do my work unless there is no better alternative
19:42:00 <dramforever> for what reason?
19:42:37 <dramforever> hackrilege: I don't understand why implementing this yourself is benefitial, other than learning about a new data structure
19:42:46 <dramforever> or is that exactly what you are doing?
19:43:06 <hackrilege> to give an informative description of the design features incorporated and their understandingly implementation 
19:43:33 <dramforever> hackrilege: please answer these three questions
19:43:42 <dramforever> can you use putStrLn for output?
19:43:42 <ttt_fff> dont
19:43:42 <ttt_fff> its a trap
19:43:50 <dramforever> yes it is
19:43:57 <ttt_fff> yes, it's putStrLn :: IO String // thus used for output
19:44:08 <hackrilege> "here i made an atom a functor as it can be maped over, heres what a functor is with its class definition because you have never heard of one before and its a nice way to tell you what i mean"
19:44:13 <dramforever> ttt_fff: and I already laid it out twice, so this is the 3rd time
19:44:27 <ttt_fff> dramforever: you are a very patient man
19:44:31 <dramforever> hackrilege: that's different from Data.Map
19:44:49 <dramforever> ttt_fff: I have some free time now
19:44:51 <hackrilege> true, but i will build up to include all the bits i need
19:45:08 <dramforever> hmm...then how deep are you going?
19:45:17 <nshepperd> hackrilege: why can't you just say "I understand Map to be a key-value store, I'll get around to learning how it works later once I've done this project"?
19:45:20 <hackrilege> so no i will not be using putstrln for output. this is high performance computing code 
19:45:24 <AaronFriel> dramforever: He is writing his software exclusively on TempleOS ;)
19:45:30 <Axman6> hackrilege: here's some hydrogen, now go forth and create the universe. that sounds just as productive
19:45:35 <dramforever> how come you won't be implementing stuff like the operating system?
19:45:42 <AaronFriel> dramforever: First step, add TempleOS as a supported target for GHC
19:45:44 <dramforever> or are you?
19:45:46 <ttt_fff> it's probably a RB tree
19:46:07 <dramforever> ttt_fff: IIRC it's a size balanced tres
19:46:12 <dramforever> *tree
19:46:15 <Axman6> hackrilege: I can guarantee that if you write it all yourself, it will not be high performance
19:46:22 <dramforever> Axman6 ++
19:46:24 <ttt_fff> what does haskell have to do with https://en.wikipedia.org/wiki/TempleOS ?
19:46:39 <Axman6> because you haven't gained the skills and knowledge required to write high performance code.
19:46:44 <AaronFriel> ttt_fff: Just making a joke, e.g.: going all the way to the nuts and bolts of writing your own OS
19:46:46 <AaronFriel> hackrilege, let me share with you an epiphany I had just this week
19:46:50 <AaronFriel> I was thinking
19:46:55 <AaronFriel> "My parser library is too slow"
19:47:11 <AaronFriel> So you know what I did? I benchmarked it. I used Criterion and I found proof
19:47:22 <AaronFriel> A good skeptic doesn't really know something unless they can show something for it
19:47:40 <Axman6> AaronFriel: oh my, that sunds almost.. scientific!
19:47:43 <Axman6> sounds*
19:47:43 <AaronFriel> So I did, I found proof (and it was bad... ~ 1-2 seconds to parse some 500kb webpages)
19:47:53 <AaronFriel> Then with that, I started iterating
19:47:58 <AaronFriel> I wrote a second benchmark suite
19:48:02 <hackrilege> nshepperd, mostly because i have gone to the lengths of understanding its implementation, and must report on all of my investigations, and i find annotated source the most convinient syntax. so since i will be disclosing all the class definitions i use, and i will be presenting them as source, i might as well include them in my source, and then at least it is convincing that such structure is effective in passing the unit tests
19:48:05 <AaronFriel> and I played around with a few ideas
19:48:33 <AaronFriel> hackrilege: I hope this epiphany will be informative
19:48:35 <AaronFriel> So
19:48:52 <AaronFriel> I had proof that what I was doing was wrong, and I wanted to do something different, my goals were lofty, like yours
19:48:57 <hackrilege> <Axman6> because you haven't gained the skills and knowledge required to write high performance code.
19:48:57 <AaronFriel> I wanted "High Performance!"
19:49:02 <nshepperd> hackrilege: I don't understand. Are you writing a thesis or homework or something?
19:49:02 <hackrilege> well i cant stop until i have
19:49:06 <Axman6> hackrilege: the souce code for everything you have been asking for is open
19:49:09 <AaronFriel> hackrilege: But the problem is
19:49:11 <dramforever> hackrilege: premature optimization considered harmful
19:49:13 <hackrilege> thesis
19:49:14 <Axman6> anyone can look at it and see what it does
19:49:14 <ttt_fff> dude don't just stop with hardware
19:49:23 <ttt_fff> don't stop until you understand the CPU, and not just an abstraction for it
19:49:26 <AaronFriel> hackrilege: You can't just grok high performance out of the box
19:49:27 <dramforever> premature optimization considered harmful
19:49:32 <ttt_fff> but until you can see how the elctrons flow through it, how the transistors are laid out
19:49:43 <AaronFriel> Dammit folks, let me finish my epiphany, I'm having a moment here
19:49:44 * hackagebot quiver-http 0.0.0.1 - Adapter to stream over HTTP(s) with quiver  https://hackage.haskell.org/package/quiver-http-0.0.0.1 (ChristianMarie)
19:49:56 <ttt_fff> afterall, how can one talk about real performance without being able to understand how the CPU executes it and how the electrons flow?
19:50:00 <AaronFriel> hackrilege: So about, Tuesday or Wednesday this week I had a problem
19:50:01 <hackrilege> im not optimising anything, im making it in the correct class structure to use traditional conventions
19:50:08 <Axman6> hackrilege: the only efficient way to write high performance code is to write obvious code, and then make the slow bits faster. 
19:50:17 <AaronFriel> hackrilege: I was writing my parser library, and I kept thinking, "I wonder if this will make it faster"
19:50:19 <Axman6> anything else is wasting time
19:50:21 <AaronFriel> hackrilege: "Or maybe this will"
19:50:26 <Axman6> and that is highly inefficient
19:50:27 <AaronFriel> hackrilege: Or maybe... this will do it
19:50:39 <AaronFriel> hackrilege: And I realized Wednesday that I was spending all my time thinking about how to make it faster
19:50:39 <hodapp> ttt_fff: don't be lazy. semiconductors are an area that requires understanding too.
19:50:45 <AaronFriel> hackrilege: Without actually going back to my benchmark
19:50:51 <AaronFriel> hackrilege: So you know what I did?
19:50:51 <dramforever> hackrilege: "correct class structure"?
19:51:02 <ttt_fff> AaronFriel: then you had the ephphany .... "damn it, instead of writing my own library, I'll just find whatever edwardk used and posted to hackage"
19:51:10 <ttt_fff> AaronFriel: and then your code became fast :-)
19:51:18 <AaronFriel> hackrilege: Rather than sit on my butt, thinking about what the fastest way to do something was
19:51:26 <AaronFriel> hackrilege: I implemented 30 different variations of the same thing
19:51:31 <ttt_fff> hodapp: right right, we need to fly to China and see how the chips are manufactured; because that effects how the elctrons flow through them
19:51:31 <AaronFriel> hackrilege: I just sat down and wrote code
19:51:38 <AaronFriel> hackrilege: And you know what I'm doing this weekend?
19:51:39 <hackrilege> <hackrilege> im not optimising anything, im making it in the correct class structure to use traditional conventions
19:51:39 <hackrilege> <hackrilege> im not optimising anything, im making it in the correct class structure to use traditional conventions
19:51:56 <nshepperd> hackrilege: Unless your thesis is about how to implement Data.Map, I can guarantee the reader does not care.
19:52:01 <dramforever> what about this: even Edward Kmett thinks that Data.Map is very high performance
19:52:06 <AaronFriel> hackrilege: I'm running all 30 of those variations through my benchmarks
19:52:16 <AaronFriel> hackrilege: And this is very freeing
19:52:18 <dramforever> screw it that's no use
19:52:20 <hackrilege> nshepperd: thats exactly what my thesis is about
19:52:25 <AaronFriel> hackrilege: Because I don't need to think about high performance
19:52:32 <AaronFriel> hackrilege: I just need to implement things until they are :P
19:52:46 <AaronFriel> hackrilege: And that got me closer to my goal than staring at class library definitions
19:52:51 <dramforever> hackrilege: can't your thesis reference other theses?
19:52:58 <Axman6> hackrilege: I thought you wanted to write computational chemistry code
19:53:02 <AaronFriel> hackrilege: Every time I thought, "I wonder if this will make it faster"
19:53:07 <dramforever> Axman6 ++
19:53:09 <Axman6> not fuck around and wasteyour life
19:53:15 <AaronFriel> hackrilege: Rather than think about it 
19:53:20 <AaronFriel> hackrilege: I just wrote it so now I can test it
19:53:41 <dramforever> hackrilege: do use other people's works
19:53:51 <AaronFriel> hackrilege: The moral of this story is
19:53:52 <hackrilege> AaronFriel: please, im not prematurly optomising anything. im trying to understand the category theory of representations relevant to the datastructure i am working with
19:54:06 <dramforever> this is going weird
19:54:12 <Axman6> what does that have to do with computation chemistry?
19:54:13 <AaronFriel> hackrilege: There are times to think about these things
19:54:14 <Axman6> al*
19:54:20 <AaronFriel> hackrilege: And there are times to just sit down and bang out code
19:54:38 <AaronFriel> hackrilege: And more often than not, you need to do the latter when you're doing the former
19:54:51 <dramforever> hackrilege: IIUC this is what you should be thinking about:
19:54:51 <ttt_fff> AaronFriel: perhaps hackrilege is the next Tesla
19:54:54 <AaronFriel> hackrilege: There is only, positively, one way to know for sure that some piece of code is faster, or more correct than another
19:55:00 <dramforever> "hmm...I need a graph storage"
19:55:03 <AaronFriel> hackrilege: Which is to write it, make sure it compiles
19:55:04 <ttt_fff> able to design structures in brain, design it, debug it, and it works the first time it' written out
19:55:04 <Axman6> AaronFriel: that's not the best way to describe building upon the thoroughly tested and revied work of others to build software efficiently
19:55:07 <AaronFriel> hackrilege: And test it
19:55:07 <hackrilege> AaronFriel i wrote this this morning for reference http://lpaste.net/138850
19:55:19 <dramforever> "this paper says that it needs a key-value store"
19:55:32 <AaronFriel> Axman6: Oh sure it is, I didn't invent a damn thing when I wrote my library
19:55:42 <AaronFriel> Axman6: I thought, "I wonder if Data.DList or Data.Seq is faster?"
19:55:44 <dramforever> "another paper says that a balanced binary search tree is very useful"
19:55:47 <AaronFriel> Axman6: So I wrote both!
19:55:49 <dramforever> great let's use it
19:55:54 <Axman6> error :(
19:55:57 <AaronFriel> Axman6: Rather, I wrote a variant of my library that uses either
19:56:10 <AaronFriel> Axman6: Now I can just empirically find out which one works better
19:56:52 <dramforever> wait it's going a bit off topic
19:56:55 <hackrilege> i dont see any problem other than your interpretation of my approach.
19:57:08 <Axman6> hackrilege: well done reimplementing a crazy inefficient implementation of Repa's stencil operations (afaict anyway)
19:57:17 <AaronFriel> hackrilege: I think the criticism you received is given with good intentions
19:57:31 <nshepperd> hackrilege: I still don't understand why you need to know how a Vector works to use it
19:57:38 <nshepperd> it's just a normally array of things
19:57:42 <AaronFriel> hackrilege: That is, the people here see you reinventing the wheel, and think you would probably be better off spending a little while driving it around first
19:57:49 <nshepperd> the operation complexity is documented
19:57:50 <dramforever> =)
19:58:02 <dramforever> nshepperd += 100
19:58:06 <hackrilege> id rather use something i understand as it helps with understanding it
19:58:35 <dramforever> hackrilege: that's not the same as not using other people's works
19:58:43 <AaronFriel> hackrilege: You have a long ways to go then
19:58:43 <nshepperd> "a vector is an array" -- there, understanding
19:58:58 <AaronFriel> hackrilege: And for your information, your high performance code? It's fine using putStrLn
19:59:00 <Axman6> hackrilege: understanding something, and and using something are orthoganal concepts. I know Data.HashMap is really fast, and can happily use it, without fully knowing how it works
19:59:02 <dramforever> with more efficient slicing -- there, more understanding
19:59:13 <AaronFriel> hackrilege: If your code produced more output than putStrLn could keep up with, I would be very impressed
19:59:25 <AaronFriel> hackrilege: And that's the fundamental problem people see here is that
19:59:33 <AaronFriel> hackrilege: You could be closer to your goal
19:59:36 <hackrilege> i have one task here, to effeciently traverse a large cyclic tree. this is infact the major occupation of an entire field, and im going to do it in a way that is helpful. im sorry you cant see that
19:59:57 <Axman6> but for my own curiosity I have examined the code, which is thoroughly tested and used widely, to see how ti works. I have avoided wasting time implementing an broken reimplementation, and have very high confidence that the code performs exactly as I expect
20:00:10 <nshepperd> hackrilege: the point of abstraction, and specifically denotational semantics that we use in haskell, is that you can write a library and establish a correspondance to well-understood mathematical objections
20:00:36 <nshepperd> hackrilege: and then once you've done that people can use the library and understand it immediately, without having to look at your code
20:00:48 <Axman6> hackrilege: but you just said you want to do it efficiently. you are definitely not doing it efficiently
20:00:49 <nshepperd> er, mathematical objects
20:00:57 <Axman6> from any perspective
20:01:14 <hackrilege> you realise that if i use Data.Map the major part of my later work will be parellelising it? you dont think putting a little time into learning about how it works would be helpful?
20:01:39 <ttt_fff> fuck yeah; not only shoud you put effort into understanding it now
20:01:42 <dramforever> hackrilege: learning is not the same as reimplementing
20:01:58 <ttt_fff> you should also figure out how to generalize it so that one day, if your ahskell code needs to run on GPU, FPGA, or yet uninvented archs, your DataMap will work on those too
20:02:02 <Axman6> hackrilege: it's not like you're the first person doing computation chemistry, or cyclic graph traversals, or anything else in Haskell. there are very smart people who have found how to do them efficiently. don't ignore the giants who've come before you to stroke your own ego
20:02:25 <dramforever> hackrilege: let me get this straight
20:02:35 <Axman6> hackrilege: parallelising things in Haskell is quite easy. but you could use something like Repa and get the parallelisation for free
20:02:35 <dramforever> you want to learn about Data.Map, so you are not using it?
20:03:05 <hackrilege> nshepperd: you said something very untrue. only those farmiliar with the well understood mathematical objects can see it works, i will be presenting these objects.
20:03:52 <dramforever> hackrilege: can you present Data.Map as a key-value store?
20:03:56 <platz> I'm all for 'standing on the shoulders of giants' so to speak, but
20:04:01 <platz> This is to say nothing about the broader problem of how youâre supposed to decide whoâs a source of innate knowledge
20:04:05 <ttt_fff> might I suggest #haskell-blah ? this seems to be less about Data.Map and more about the philosophy of programming
20:04:05 <hackrilege> Axman6: i need quite fine control on the exact parellelisation incase it needs to be improved
20:04:06 <platz> It is an ominous sign whenever a group dispenses with methods and approaches of gaining knowledge and, moreover, becomes openly hostile to them.
20:04:10 <nshepperd> hackrilege: how many chemists are unfamiliar with lists of things?
20:04:10 * arkeet grabs some popcorn and reads the scrollback
20:04:13 <dramforever> let's go to haskell-blah
20:04:16 <platz> Anti-intellectualism and a corresponding reliance on innate knowledge is one of the hallmarks of a cult or a totalitarian ideology
20:04:35 <arahael> platz: Are those mutually exclusive? ;)
20:04:39 <Axman6> hackrilege: you have far greater problems to deal with before you get to the point of even contemplating worrying about that
20:04:42 <dramforever> let's go to #haskell-blah
20:05:27 <hackrilege> thanks platz; i have no idea what these guys have gotten so upset about.
20:05:38 <Axman6> platz: in the contrary, intellectualism revolves around the idea that you don't need to discover everything yourself, and should learn from others. this is exactly what we're recommending hackrilege do
20:05:55 <hackrilege> im not joining you on blah so you can continue to discredit what i advocate as virtuous 
20:06:12 <KaneTW> man i ran out of popcorn
20:07:20 <dramforever> hackrilege: fully understanding a library is good, I agree
20:07:21 <platz> Axman6: sure, that makes sense, i do believe that everyone is just doing their best to help 
20:07:25 <nshepperd> hackrilege: sure, it's virtuous to want to learn how all these things work. I just think you should get things done first, rather than starting with a depth-first traversal of all programming knowledge
20:07:35 <Axman6> hackrilege: if you think this course of action is virtuous, then why are you not going down to your local electronics store and buying a bunch of nand gate chips, and building your computer from scratch?
20:07:59 <dramforever> hackrilege: where do you draw the line?
20:08:02 <hackrilege> enough. some very irrelivent comments here about "not getting off your lazy ass and writing code" - its inflammatory and very presumptuous and just uncool. i cant believe its more appealing to engage in that kind of discussion than disclosing useful information about types which is what im here for. not a lecture on laziness, or about what my job is  
20:08:16 <ttt_fff> Axman6: psst, nand gates .... you should go to dumpster, get aluminum / wiring / gold / siler and make your own gates from scratch
20:08:32 <ttt_fff> Axman6: or, maybe just go get a bunch of rocks, burn them, refine them, and get metal directly from the rocks
20:09:10 <dramforever> hackrilege: hmm...wait a sec I think we might be misunderstanding each other
20:09:38 <Axman6> hackrilege: no one is calling you lazy, in fact, they're trying to make you more lazy. you're burning energy for no real gain, and in ways that directly go against your own stated goal
20:10:14 <dramforever> what do you want to do? implement Data.Vector and Data.Map yourself to use in the high-performance program, just for learning or both?
20:11:16 <hackrilege> i give the premise; i must behave this way, its not open for discussion. if you want to know what im doing, im presenting something in a particular way, no i do not have a choice about this, no i will not be compelled to change it, no, discussion around it is not being sought or appreciated. sorry to be harsh, i really enjoy people helping and wanting to help, and i can see what i am insisting on doing is jaring for you, and i a
20:11:44 <arkeet> your message got cut off, at "doing is jaring for you, and i a"
20:12:00 <hackrilege> jaring for you, and i appoligise. we move on
20:12:28 <ttt_fff_> I get it now
20:12:45 <dramforever> yes #haskell people are very willing to help
20:12:47 <dramforever> somehow
20:12:57 <hackrilege> next time i promise not to engage in a project where optimisation and comprehensive implementation are not the fundamental considerations
20:13:01 <ttt_fff_> I need a monad, which maps :: node -> [node] ... yet somehow, when I'm done, outputs a tree, i.e. a search tree
20:13:31 <ttt_fff_> so I don't think I want the list monad
20:13:36 <ttt_fff_> because the list moand does not, in the end, output a tree
20:13:45 <ttt_fff_> but I want a tree
20:14:19 <dramforever> "optimisation and comprehensive implementation" -> that's interesting...
20:14:31 <KaneTW> ttt_fff_: https://hackage.haskell.org/package/containers-0.5.6.3/docs/Data-Tree.html?
20:14:45 <Axman6> hackrilege: what you are embarking on does not involve those ideas
20:15:41 <hackrilege> Axman; your sure repa will outperform a custom parallel implementation of Data.Map?
20:16:22 <m_ryan> exit
20:16:47 <dramforever> hackrilege: "repa/custom parallel implementation of Data.Map" -> it's not automatically faster I think
20:17:05 <dramforever> now *this* is when AaronFriel's story comes in
20:17:06 <hackrilege> now im simply faced with having to understand the implementation of that library...
20:17:31 <hackrilege> ok
20:17:32 <dramforever> hackrilege: you sure a parallel implementation of Data.Map is faster than a serial one?
20:17:48 <AaronFriel> hackrilege: Parallelism has huge costs too
20:17:51 <dramforever> because IIUC there isn't very much to parallelize...or maybe I'm wrong
20:18:02 <hackrilege> no but id love to understand enough about it to answer that without benchmarking
20:18:07 <AaronFriel> hackrilege: Parallelism (or, more accurately, concurrency) imposes strong constraints
20:18:19 <AaronFriel> and frankly no one on this planet is able to understand concurrency well without benchmarking
20:18:29 <dramforever> hackrilege: so what exactly do you mean by a parallel Data.Map?
20:18:33 <AaronFriel> there's a reason key value stores are a dime a dozen and keep trading places for being the fastest
20:18:43 <AaronFriel> concurrency is a fundamentally hard problem
20:18:49 <AaronFriel> and even the experts haven't a clue
20:18:55 <AaronFriel> (okay they have some clues)
20:18:58 <AaronFriel> (but like, five)
20:18:58 <hackrilege> this is all just a necessary part in justifying the choice of Data.Map 
20:18:59 <AaronFriel> (at most)
20:19:17 <AaronFriel> hackrilege: In my unhumble opinion, just use Data.Map and benchmark it
20:19:27 <AaronFriel> hackrilege: If you find your code is spending a significant amount of its time in Data.Map
20:19:34 <AaronFriel> hackrilege: Then look at swapping it out
20:19:42 <dramforever> AaronFriel ++
20:19:47 <AaronFriel> hackrilege: This goes back to what I said earlier
20:20:01 <AaronFriel> hackrilege: I was weighing the pros and cons of different options for my parser library
20:20:01 <dramforever> there's no point optimizing a function so that takes 90% less time
20:20:18 <AaronFriel> hackrilege: And I realized that I didn't actually KNOW what was best
20:20:20 <dramforever> if the function is only used once, and it takes like 0.1% of total program running time
20:20:29 <AaronFriel> hackrilege: So I foundout where my costs were (benchmarking, debugging)
20:20:48 <AaronFriel> hackrilege: And then I used a bunch of other people's code and wrote 30 different implementations of a parser
20:21:00 <AaronFriel> hackrilege: And you know what implementation I'm going to use tomorrow?
20:21:16 <AaronFriel> hackrilege: The one that wins the benchmark comparison
20:21:17 <hackrilege> ok im not even sure Data.Map cuts it it looks more like Lens.Traversable, since i operate on small "local" (nearest neighbour edge traversal) subregions
20:21:35 <AaronFriel> hackrilege: You're probably over-optimizing still
20:21:43 <hackrilege> i will certainly benchmark the candidates
20:21:53 <dramforever> hackrilege: wait I think there's still some misunderstanding, are you saying that it's not open to discussion because it needs an optimized and comprehensive implementation?
20:22:03 <AaronFriel> hackrilege: Lens.Traversable and Data.Map don't actually have a strong idea of locality of reference (at least, their APIs don't guarantee that)
20:22:20 <hackrilege> but i havnt quite got the category theory down yet... i dont know quite what im doing yet phrased in that vocabulary
20:22:25 <AaronFriel> hackrilege: Especially in Haskell-land, where the heap is a stack and stacks are lists and memory just goes all over the place
20:22:29 <yashinbasement> hey guys I am bit confused about haskell paranthe like why can't we use len x:xs instead of len(x:xs)
20:22:44 <AaronFriel> yashinbasement that's because names bind more strongly than operators
20:22:45 <hackrilege> <dramforever> hackrilege: wait I think there's still some misunderstanding, are you saying that it's not open to discussion because it needs an optimized and comprehensive implementation? yes
20:22:56 <dramforever> hackrilege: ok then
20:23:00 <AaronFriel> yashinbasement len x:xs == (len x):xs
20:23:08 <KaneTW> yashinbasement: function application binds stronger than (:)
20:23:17 <Axman6> hackrilege: make something that works, then make it faster. don't make something broken, and assume it's fast. we've all been there, it's never worked
20:23:25 <AaronFriel> yashinbasement: Does that make sense?
20:23:45 <yashinbasement> yeah makes sense
20:23:47 <yashinbasement> thanks
20:23:51 <dramforever> hackrilege: without profiling you can't possibly know for sure what to optimize
20:23:55 <ForeverFactor> I have a quick probably simple to answer question. I have a call that may fail with with a ResourceVanished error. When I catch the error so the program doesn't crash and continue once it reaches the end it hangs and never terminates. My guess is some file handles or something of that nature aren't being released but for the life of me I can't seem to see a solution. Any help would be much appreciated. Thanks.
20:23:57 <Axman6> (len x) : (xs) is basically how it's parsed
20:24:24 <hackrilege> yashinbasement: you are applying len to x : xs, thats 3 things, it just wants one
20:24:26 <AaronFriel> ForeverFactor: What sort of call is it, and does it return any data?
20:24:30 <Axman6> ForeverFactor: can you paste the code somewhere?
20:24:42 <dramforever> hackrilege: and if you just consider all the possiblities it has an exponential
20:24:44 <AaronFriel> ForeverFactor: And what do you mean by "catch", is it a Data.Exception, or something else?
20:24:54 <dramforever> number of choices
20:24:56 <yashinbasement> so we don't use len(xs) indead of len xs 
20:24:57 <yashinbasement> it
20:25:03 <ForeverFactor> I'm using the Turtle library and the proc calls specifically so it returns IO ExitCode
20:25:07 <yashinbasement> it is also one thing though
20:25:17 <nshepperd> hackrilege: no, (:) is an operator, it's not treated as an argument
20:25:23 <AaronFriel> ForeverFactor: hmm
20:25:24 <ForeverFactor> I'm catching and IOError
20:25:32 <AaronFriel> ForeverFactor: Yeah there lie dragons
20:25:42 <nshepperd> in related news, I wish my neural network library was faster
20:25:44 <AaronFriel> ForeverFactor: I would be wary to guess what the cause of the problem is there
20:25:47 <ForeverFactor> GHC.IO.Exception ResourceVanished to be exact
20:25:47 <hackrilege> oh i thought it was just an infix function..
20:26:13 <KaneTW> no, infix functions are just functions written using ``, like x `mod` 2
20:26:21 <hackrilege> dramforever; the problem i think naturally fits into some kind of traversable thing
20:26:22 <KaneTW> function applications, rather
20:26:37 <nshepperd> according to profiling, I am now spending most of my time in LAPACK matrix multiplication, which means it's time to figure out gpu programming
20:26:37 <AaronFriel> KaneTW, hackrilege: Well, there's no fundamental difference between binary ops and infix functions
20:26:42 <dramforever> weird I've never talked about traversables?
20:26:44 <AaronFriel> they bind at different precedences though
20:26:46 <dramforever> s/?/...
20:26:54 <hackrilege> i need to learn enough of this stuff to understand what exactly i mean...
20:27:12 <AaronFriel> hackrilege: If, instead of implementing other people's libraries, you played around with them (as is)
20:27:13 <KaneTW> AaronFriel: you can't specifiy a infixl/infixr for non-operators iirc
20:27:29 <AaronFriel> KaneTW: true
20:27:32 <hackrilege> AronFriel; again why are you presuming im not
20:27:43 <AaronFriel> hackrilege: Because you keep saying you want to implement them yourself
20:27:54 <dramforever> AaronFriel ++
20:27:57 <AaronFriel> hackrilege: Which is very different from "playing around with" them 
20:28:06 <hackrilege> oh, no dont wory dont get confused by that, i will in the end...
20:28:15 <AaronFriel> hackrilege: When I want to play around with a library, I open up GHCi
20:28:21 <AaronFriel> hackrilege: I don't open up Sublime
20:28:29 <hackrilege> okok, look iv done that
20:28:32 <hackrilege> dont wory
20:28:38 <AaronFriel> hackrilege: Then I bang letters in until GHCi stops giving me errors
20:28:39 <hackrilege> i dont know why you presume
20:29:00 <AaronFriel> hackrilege: And that's how I sleep at night, when GHCi yelling at me
20:29:01 <dramforever> hackrilege: we didn't say you couldn't write high performance code that way
20:29:08 <AaronFriel> hackrilege: it's a complicated relationship
20:29:21 <dramforever> it just requires trying those possiblities
20:29:23 <hackrilege> i just came on to try and see what this paste could look like a lens or a traversable; http://lpaste.net/138850
20:29:26 <monochrom> ghci says you a lullaby? :)
20:29:36 <monochrom> err, s/says/sings/
20:29:46 <dramforever> and it's just too hard to just find out the best and go for it
20:29:51 <dramforever> which we think you are doing
20:30:37 <dramforever> btw, that Grid thing really looks like a comonad
20:30:45 <rhovland> yashinbasement: or you can use len $ x:xs
20:30:59 <yashinbasement> oh yeah ?
20:31:06 <dramforever> yet another operator
20:31:13 <hackrilege> and recognise that stencil that i am using access its neighbours
20:31:15 <yashinbasement> so it makes one thing
20:31:22 <ForeverFactor> @AaronFriel http://pastebin.com/znwhapPi
20:31:22 <lambdabot> Unknown command, try @list
20:31:24 <AaronFriel> yashinbasement: $ just says "evaluate everything on the right side of me first"
20:31:36 <AaronFriel> yashinbasement: It's an operator, just a regular ol operator, but it binds higher than function application
20:31:37 <hackrilege> a comonad! cool! thats the kind of observation i was after
20:31:38 <yashinbasement> cool
20:31:47 <yashinbasement> thanks guys
20:31:51 <AaronFriel> yashinbasement: there are a bunch of levels of precedence
20:31:53 <yashinbasement> this is awesome
20:31:57 <dramforever> hackrilege: ok that's it, we successfully settled the misunderstanding on the reimplementing the world stuff
20:32:18 <hackrilege> so its kind of like a map, but it needs to navigate its immidiate and itterativly connected surroundings to some depth
20:32:23 <dramforever> at least that's what I think
20:32:32 <ForeverFactor> Hopefully that is enough to get an idea of what I'm doing. I'm mapping over a list of .sql files and piping them into MySQL one does not have correct SQL so MySQL kills the connection thus the resourcevanished
20:32:49 <dramforever> hackrilege: minor suggestion:
20:32:54 <dramforever> > (0 - 1)
20:32:55 <lambdabot>  -1
20:32:58 <hackrilege> i think so too! but it was a missunderstanding that reimplementation only had negative connotations. 
20:32:58 <dramforever> > (-1)
20:33:00 <lambdabot>  -1
20:33:13 <hackrilege> i just mean, recognising common patterns and types
20:33:30 <ForeverFactor> If I don't catch the IOError then the program terminates immediately. If I do catch it the other files are processed and then the program hangs forever
20:33:33 <hackrilege> and reimplementing them! just for disclosure...
20:33:36 <dramforever> hackrilege: =) don't worry not many people have heard of comonads
20:34:04 <dramforever> hackrilege: disclosure? oh wait there's something much more complicated going on
20:34:04 <hackrilege> oh i dont think that was always the case
20:34:19 <yashinbasement> :AaronFriel but it gives can not mix $ and :
20:34:22 <hackrilege> yes im compiling a report
20:34:35 <dramforever> when you write a report, you often include those implementations
20:34:36 <hackrilege> actually hang on, could you read something?
20:34:40 <dramforever> me?
20:34:51 <AaronFriel> hackrilege: Oh, really?
20:34:53 <dramforever> "read something" like what?
20:34:54 <hackrilege> thats the point!!
20:35:08 <hackrilege> <dramforever> when you write a report, you often include those implementations
20:35:09 <hackrilege> thank you
20:35:10 <AaronFriel> :t \f x xs -> f $ x:xs
20:35:11 <lambdabot> ([a] -> r) -> a -> [a] -> r
20:35:20 <AaronFriel> well
20:35:26 <AaronFriel> that's not what you want
20:35:30 <AaronFriel> or, no it is
20:35:32 <AaronFriel> yeah
20:35:38 <AaronFriel> Sorry, sometimes I have to squint at type sigs
20:35:41 <dramforever> hackrilege: ok then
20:35:48 <rhovland> yashinbasement: unfortunately you can't always get away with $ instead of paren... you can't do 3 * $ 1+8... you can do something like (*3) $ 1+8, though
20:35:50 <hackrilege> :D
20:35:58 <dramforever> kinda funny, because that's not what programmers usually do
20:36:14 <AaronFriel> yashinbasement: Do you have some other operator in there?
20:36:18 <hackrilege> apparently... 
20:36:23 <dramforever> hackrilege: agree?
20:36:31 <AaronFriel> yashinbasement: If you have two operators of the same precedence level in your expression
20:36:34 <yashinbasement> nah I have this len $ x:xs = 1 + len xs
20:36:47 <dramforever> hackrilege: if you agree then this whole discussion is settled
20:36:54 <hackrilege> im not sure what programers normally do, but i know what i have to do
20:37:00 <AaronFriel> yashinbasemen: on the left hand side of ==?
20:37:00 <rhovland> yashinbasement: oh, and yeah, can't do it on the pattern matching side
20:37:14 <AaronFriel> yashinbasement: is your code like this
20:37:15 * dramforever hits the table with a tiny wooden hammer
20:37:16 <hackrilege> im not sure what im agreeing to but i agree!
20:37:18 <AaronFriel> \case something of 
20:37:23 <AaronFriel> len $ x:xs = ...
20:37:24 <dramforever> done
20:37:27 <hackrilege> lol
20:37:32 <dramforever> discussion dismissed
20:38:14 <hackrilege> so its like a map, except it access its neighbours. and its like a graph except without cyclic recursion in neighbour traversal 
20:38:23 <nshepperd> I would hope that normally you write something like "we used Data.IntMap, which is a key-value store implemented as a big-endian patricia tree, see [original paper name]"
20:38:29 <nshepperd> even when writing a report
20:38:49 <nshepperd> and then maybe give the main results from that paper like operation bounds I guess
20:39:09 <rhovland> yashinbasement: in that case, you _definitely_ need parens, b/c that's how it knows to break apart x:xs... so len (x:xs) = 1+len xs ... 
20:39:33 <dramforever> ok apparently someone has more to say
20:39:51 <yashinbasement> so why can't I break it if it's on lhs
20:40:00 * nshepperd gets charged with contempt of court
20:40:58 <hackrilege> nshepperd: yes, but i would also say "since data Vec a = Vec (a,a,a) can contain functions we make it an instance of Functor (but whats that!? *gives class definition namely minimal instatiation upon defining fmap* )"
20:41:08 <rhovland> yashinbasement: in your case, the parens are telling it x:xs is a list head then list tail... as opposed to a tuple... len (x,y) = x+y... or a list like len [a,b,c,d] = a+b+c+d
20:41:12 <monochrom> $ is not a keyword. it is an ordinary function name.
20:41:26 <dramforever> hackrilege: yes you could do that with Data.IntMap too
20:41:48 <hackrilege> i will
20:41:55 <dramforever> we used a IntMap, which supports the following operations
20:41:56 <hackrilege> with the reference!
20:42:12 <dramforever> (insert a list of functions with type sigs)
20:42:20 <monochrom> "len $ x:xs = ..." is as much a syntax error as "f (g x) = ...". invalid LHS.
20:42:21 <hackrilege> essentially reimplementing it would be a sufficient minimal disclosure 
20:42:45 <hackrilege> but we are done with this...
20:42:48 <dramforever> hackrilege: I wonder if just those functions with type sigs are enough
20:43:10 <dramforever> forget about it I don't care
20:43:15 <dramforever> you draw the line yourself
20:43:22 <rhovland> yashinbasement: on the left, the parens don't have to do with precedence, they have to do with splitting the parameters
20:43:25 <hackrilege> yeh the functions and types are more or less it, and some of the laws which should be satisfied, and also unit tests giving expected results on comprehendable examples
20:43:27 <dramforever> for me I draw the line there
20:43:46 <dramforever> hackrilege: sure =)
20:44:01 <dramforever> but you'll probably never want to embed another paper in your report =P
20:44:39 <hackrilege> something is traversable if i can <*> over it, accessing and altering each element? 
20:44:53 <AaronFriel> yashinbasement: I stopped paying attention, but to elaborate
20:45:04 <dramforever> hackrilege: sort of
20:45:06 <hackrilege> my thesis is an lhs file im compiling with lhs2tex!
20:45:08 <AaronFriel> yashinbasement: The left hand side of pattern matching, function "=", etc, is special
20:45:23 <AaronFriel> yashinbasement: Much in the same was the left hand side in C, C++, Java, C#, etc
20:45:33 <dramforever> hackrilege: you could import Data.IntMap and reference the paper describing it
20:45:37 <AaronFriel> yashinbasement: Let's say I had an object Object
20:45:43 <dramforever> as well as some useful properties
20:45:45 <AaronFriel> yashinbasement: And it had a property, length
20:45:45 <hackrilege> it imports the source and outputs of the main routine and tests
20:46:01 <dramforever> but the implementation and proof? maybe too boring to include
20:46:03 <AaronFriel> yashinbasement: Does "object.length = 5" make sense? Sure
20:46:18 <hackrilege> dramforever, you know what, i already knew that 2 weeks ago, even before i was told it 3 times today
20:46:20 <AaronFriel> yashinbasement: But what about "object.length - 5 = 0"
20:46:33 <dramforever> hackrilege: well I'm not trying to tell you that
20:46:38 <AaronFriel> yashinbasement: In C-like languages, the left hand side is something called an lvalue
20:46:44 <dramforever> just trying to see if you agree
20:46:46 <AaronFriel> yashinbasement: It has to refer to something concrete
20:46:51 <yashinbasement> yeah
20:46:53 <hackrilege> ofc!
20:46:59 <AaronFriel> yashinbasement: The same applies for the left hand side of pattern matches
20:47:05 <dramforever> =) looks like we agree so far, and there's no more
20:47:07 <AaronFriel> yashinbasement: You can't stick arbitrary expressions on the left hand side
20:47:17 <AaronFriel> yashinbasement: The left hand side is for Things That Already Exist
20:47:20 <hackrilege> dont worry about that, i need to concentrate on class definitions. really... 
20:47:25 * dramforever couldn't find his hammer anymore
20:47:26 <AaronFriel> yashinbasement: The right hand side is for Things You Want to Exist
20:47:34 <AaronFriel> yashinbasement: (x:xs)? That exists
20:47:45 <AaronFriel> yashinbasement: (len (x:xs))? You *want* to know what that is
20:47:56 <AaronFriel> yashinbasement: But (len (x:xs)) doesn't exist until you compute it
20:48:03 <AaronFriel> yashinbasement: So it belongs on the right hand side
20:48:37 <dramforever> can we explain those as syntax sugar?
20:48:51 <AaronFriel> yashinbasement: I'm personally of the opinion that using an equal sign to denote assignment was one of the biggest mistakes for programming languages
20:49:02 <AaronFriel> yashinbasement, in C-like languages, "=" should really be "<-"
20:49:04 <dramforever> AaronFriel ++
20:49:11 <dramforever> even := is okay
20:49:14 <AaronFriel> yes
20:49:16 <AaronFriel> the Delphi way
20:49:21 <AaronFriel> I believe? 
20:49:21 <dramforever> *Prolog
20:49:23 <AaronFriel> Ah
20:49:27 <AaronFriel> I think Delphi may also use it
20:49:28 <dramforever> oh no no
20:49:29 <dramforever> no no
20:49:35 <dramforever> I mean pascal
20:49:46 <AaronFriel> Delphi == Pascal
20:49:53 <dramforever> screw it I was thinking about logical programming languages
20:50:00 <AaronFriel> sure
20:50:00 <dramforever> like in curry you could actually write
20:50:08 <dramforever> last (xs ++ [x]) = x
20:50:15 <AaronFriel> ...
20:50:24 <AaronFriel> yeah logical languages are kind of scary
20:50:27 <dramforever> =)
20:50:33 <AaronFriel> I mean, in terms of reasoning about what you typed in is going to do
20:50:48 <AaronFriel> logical programming languages with arbitrary effects will cause World War III
20:50:54 <dramforever> I once implemented a minikanren-like language, it's not very hard, but it's weird
20:51:00 <AaronFriel> because somewhere there will be another statement that says
20:51:14 <AaronFriel> last (xs ++ [x]) == x = FireTheMissiles
20:51:52 <AaronFriel> Except with another half dozen abstractions between
20:52:23 <AaronFriel> oh god
20:52:26 <AaronFriel> what have I done
20:52:26 <dramforever> actually I really like tying the knot in haskell
20:52:34 <AaronFriel> dramforever: I googled webserver prolog
20:52:44 <AaronFriel> dramforever: HOLD ON TO MY ROPE I'M GOING IN
20:52:47 <dramforever> it helps to simplify the implementation
20:53:05 * dramforever holds AaronFriel's rope under his hammer
20:53:07 <hackrilege> does anyone know if i can use Data.Array.Repa.Stencil with Data.Map? i though with a lens the underlying representation was irrelevant? but i must use an Array and not a Map or Graph, which seem the more natural embodyments of my thing.
20:53:13 <dramforever> don't worry it's not the same hammer
20:53:42 <AaronFriel> huh, this prolog webserver doesn't look that scary
20:54:13 <AaronFriel> but I would hazard a guess that it's quite difficult to reason about how long a computation will take or what it will do
20:54:33 <dramforever> =)
20:54:59 <kadoban> hackrilege: I don't think repa uses lenses, so â¦ no. Types still mean something, even though lens exists.
20:55:18 <hackrilege> thanks
20:55:22 <AaronFriel> dramforever: This prolog webserver modules and plugins
20:55:29 <AaronFriel> dramforever: I'm scared
20:55:46 <dramforever> you still having your rope? =P
20:56:15 <AaronFriel> I have to close this tab before I download SWI-Prolog
20:56:19 <kadoban> AaronFriel: I would imagine that that's kinda how imperative programmers feel about haskell webservers.
20:56:23 <AaronFriel> just to see it work
20:56:25 <hackrilege> prolog webserver sounds cool
20:56:37 <dramforever> kadoban: servant?
20:56:58 <AaronFriel> dramforever: servant?
20:57:02 <dramforever> where a image conversion service is literally funny types + return?
20:57:21 <dramforever> AaronFriel: where you can describe your API using type
20:57:24 <dramforever> *types
20:57:27 <AaronFriel> dramforever: glorious
20:57:44 <AaronFriel> dramforever: Was this designed by Oleg
20:57:50 <AaronFriel> dramforever: This sounds like something Oleg would do
20:57:50 <dramforever> dunno
20:58:00 <kazagistar> SWI-Prolog's webserver is written in SWI-Prolog
20:58:11 <AaronFriel> "Quasi-dependently typed webservers"
20:58:17 <AaronFriel> I would expect that to appear on my Oleg rss reader
20:58:20 <hackrilege> so lets talk about tying the not and traversing graphs with inefficient  zippers...
20:58:29 <hackrilege> knot*
20:58:44 <AaronFriel> hackrilege: tbh, you're going to go down a really deep hole trying to do this with the types you keep talking about
20:58:55 <hackrilege> tell me about it
20:59:01 <AaronFriel> hackrilege: All the highest performing array/vector types do not support lenses and fancy type system checks
20:59:09 <dramforever> =)
20:59:15 <AaronFriel> hackrilege: But there's a reason for that, expressing Repa's performance in the type system is hard
20:59:23 <hackrilege> it looks conceptually robust though, and lots of nice references 
20:59:27 <yashinbasement> :AaronFriel thanks , it hels
20:59:31 <AaronFriel> hackrilege: It's easier to use IO and cross your fingers
20:59:45 <AaronFriel> hackrilege: Which tbh, is what everyone else in the HPC world is doing
20:59:56 <dramforever> ST?
20:59:57 <hackrilege> serious? lens are never fast?
21:00:16 <hackrilege> use IO and cross fingers!?
21:00:42 <dramforever> lenses are slow
21:00:49 <dramforever> because they are too magical
21:00:55 <hackrilege> omg!! argh
21:00:58 <dramforever> :t lens
21:00:58 <AaronFriel> type UserAPI = "users" :> QueryParam "sortby" SortBy :> Get '[JSON] [User]
21:00:58 <AaronFriel>                -- equivalent to 'GET /users?sortby={age, name}'
21:00:58 <AaronFriel>           :<|> "users" :> MatrixParam "sortby" SortBy :> Get '[JSON] [User]
21:00:58 <AaronFriel>                -- equivalent to 'GET /users;sortby={age, name}'
21:00:59 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
21:01:01 <AaronFriel> this is machiavellian
21:01:21 <AaronFriel> it's damn impressive
21:01:25 <dramforever> hackrilege: for example, with lenses you can't even get Text stream fusion
21:01:29 <AaronFriel> but it scares me
21:01:44 <hackrilege> so certainly i will be starting from scratch
21:01:48 <dramforever> no
21:02:00 <dramforever> just don't use lenses
21:02:07 <dramforever> if you want HPC
21:02:41 <hackrilege> if?
21:02:45 <AaronFriel> damn, yashinbasement left
21:02:47 <AaronFriel> I wanted to copy paste this
21:02:57 <AaronFriel> Remember what I said about putting "Things That Already Exist" on the left hand side?
21:02:59 <AaronFriel> This exists:
21:03:02 <AaronFriel> position :<|> hello :<|> marketing = client api (BaseUrl Http "localhost" 8081)
21:03:04 <hackrilege> oh, i thougt you were going to follow that with "use this lbrary..."
21:04:25 <Sindriava> #haskell is one of the nicest places I've seen on the internet so far. Seriously guys, stellar job there.
21:04:30 <AaronFriel> dramforever left
21:04:33 <AaronFriel> :(
21:04:47 <AaronFriel> I'm reading the tutorial on the Servant webserver EDSL
21:04:54 <hackrilege> i wouldnt have made this great realsisation to abbadon lenses if i had not been so concerned with premature optimisation
21:04:59 <AaronFriel> and I find it amusing that the author hasn't also implemented the client as type hackery
21:05:14 <AaronFriel> As if the creator thought, "No, no that is going too far. The line must be drawn!"
21:05:34 <AaronFriel> implementing a webserver as a bunch of types though, huh
21:07:13 <hackrilege> Axman6 what is so inefficient about my stencil?
21:09:29 <AaronFriel> hackrilege: pointers
21:09:35 <AaronFriel> hackrilege: in a word, pointers
21:09:49 <hackrilege> more words?
21:09:57 <AaronFriel> hackrilege: Haskell is very nice for giving you great performance for small things, or mutating things in ... certain ways
21:10:18 <AaronFriel> hackrilege: But if you have a persistent and mutable set of data you want to touch and change in lots of different ways really quickly
21:10:29 <AaronFriel> hackrilege: You will pay for it
21:10:32 <AaronFriel> hackrilege: In CPU time
21:10:36 <AaronFriel> hackrilege: And GC churn
21:10:52 <AaronFriel> hackrilege: That's why high performance Haskell libs use FFI and IO 
21:10:54 <hackrilege> can haz hpc?
21:11:05 <AaronFriel> hackrilege: They don't use traversables, and data.map, and the like
21:11:09 <hackrilege> yeh i can FFI some calls to old blas its ok
21:11:49 <hackrilege> i hope the quaternian rotations which take up most of the grunt will be fast
21:11:49 <AaronFriel> hackrilege: Right, but what I'm saying is, if your goal is absolute maximum performance and HPC, you're probably best staying far away from the land of Lens and generic abstractions over data access libraries
21:12:07 <hackrilege> great.
21:12:15 <hackrilege> and also, to get super fast?
21:12:35 <hackrilege> use repa?
21:12:38 <AaronFriel> hackrilege: Use Data.Array, or unboxed vectors, and use Int (not Integer) indexes, or Repa
21:12:41 <AaronFriel> hackrilege: Yeah
21:12:55 <hackrilege> hmm
21:13:09 <AaronFriel> hackrilege: The fundamental reason those libraries exist is that they do something that doesn't map well to the "Haskell-y" mental model
21:13:17 <hackrilege> so i will learn to implement these...
21:13:24 <AaronFriel> hackrilege: In Haskell, all good citizen data structures are what are called "persistent"
21:13:32 <AaronFriel> hackrilege: If you really, deeply desire to learn what that means
21:13:55 <AaronFriel> http://www.amazon.com/Purely-Functional-Structures-Chris-Okasaki/dp/0521663504
21:13:57 <AaronFriel> Buy that book
21:13:59 <AaronFriel> And work through it
21:14:03 <AaronFriel> it will be a slog
21:14:06 <hackrilege> cool beans
21:14:07 <AaronFriel> (use OCaml)
21:14:10 <AaronFriel> but
21:14:27 <AaronFriel> you will understand why Data.Map and kin are not suited to HPC/numerics work
21:14:37 <hackrilege> thanks
21:14:42 <AaronFriel> I have that book on my shelf btw
21:14:43 <AaronFriel> it's a good one
21:15:03 <AaronFriel> It's tough, and Okasaki is brilliant, so he'll make observations about how to improve a data structure that make you go, "Oh, really?"
21:15:38 <AaronFriel> But I will give you the conclusion right now:
21:15:48 <AaronFriel> Data.Map and persistent/functional data structures are not suited to your problem domain
21:15:48 <hackrilege> so, i need something that is suited to hpc, which i can write out by hand, i like things like Functors, im sure I would like to make my datatype foldable. but i dont want to trip up on performance, are these things opposing termainally?
21:15:57 <AaronFriel> Yes
21:16:06 <AaronFriel> I mean, not necessarily -- but almost certainly yes
21:16:26 <hackrilege> how i am losing performance just by making a Functor?
21:16:33 <AaronFriel> you aren't, not really
21:16:46 <AaronFriel> but your `fmap` won't be as fast as directly access unboxed memory
21:16:54 <AaronFriel> and repa can use *all your cores* to modify that memory
21:17:00 <AaronFriel> fmap cannot
21:17:04 <hackrilege> jesus
21:17:13 <hackrilege> what a load of shit
21:17:14 <hackrilege> sorry!
21:17:16 <AaronFriel> You could probably hack together a parallel fmap library
21:17:24 <AaronFriel> And I guess now you're talking Data Parallel Haskell
21:17:25 <hackrilege> yes this is my desire
21:17:44 <AaronFriel> But I'm not aware that it's actually competitive for what you want to do 
21:17:44 <hackrilege> i thought it would be the case in the end anyway
21:18:26 <hackrilege> i cant see why it wouldnt be competative if i considered the correct things
21:18:29 <AaronFriel> hackrilege: The fundamental problem with what you want to express, which you gave away by talking about graphs and adjacency
21:18:36 <AaronFriel> hackrilege: Is that persistent data structures are immutable
21:18:52 <AaronFriel> hackrilege: Every time you change an element, you have to propogate that change somehow
21:19:01 <AaronFriel> hackrilege: So let me give you a simple example
21:19:05 <hackrilege> thanks
21:19:14 <AaronFriel> hackrilege: Suppose you had a doubly linked list, a standard doubly linked list from C/C++
21:19:22 <AaronFriel> hackrilege: It has a "forward" and a "backward" pointer
21:19:26 <AaronFriel> (a node does)
21:19:35 <hackrilege> yes
21:19:37 <AaronFriel> hackrilege: Let's say this list is 1000 nodes long
21:19:52 <AaronFriel> In C/C++, if you're holding onto the tail node, adding an additional node is very cheap
21:20:07 <AaronFriel> Simply update (Node.forward = &NewNode)
21:20:10 <AaronFriel> Bam
21:20:15 <AaronFriel> That took a single write to memory
21:20:18 <AaronFriel> and a single allocation
21:20:22 <AaronFriel> Very nice
21:20:24 <hackrilege> ok
21:20:30 <AaronFriel> Here's the problem:
21:20:35 <AaronFriel> doubly linked lists can't exist in Haskell
21:20:44 <AaronFriel> not... without cheating and using IO
21:20:57 <AaronFriel> the reason for that is that all of those pointers form a graph
21:21:00 <rlewis> I don't see how is that cheating
21:21:04 <AaronFriel> in this case, a 1000-node-long graph
21:21:13 <AaronFriel> if you want to take advantage of Haskell-isms
21:21:18 <AaronFriel> like traversables, fmaps, and the like
21:21:24 <AaronFriel> you need to obey Haskell rules
21:21:38 <AaronFriel> but let's assume Haskell had a way of expressing a 1000-node-long doubly linked list
21:21:45 <AaronFriel> what would the cost in Haskell for updating the tail node?
21:21:49 <AaronFriel> cost be*
21:21:53 <AaronFriel> Remember, in C++
21:22:03 <AaronFriel> the cost was writing 8 bytes and 1 malloc
21:22:15 <AaronFriel> In Haskell, to update the tail node
21:22:16 <hackrilege> now we have to traverse the list?
21:22:20 <AaronFriel> you have to create a new tail node
21:22:29 <hackrilege> oh dear
21:22:30 <AaronFriel> and then, you have to update the node that references that
21:22:36 <AaronFriel> then you have to update the node that references that
21:22:36 <Cale> AaronFriel: You can do a mutable doubly linked list though.
21:22:41 <AaronFriel> then you have to ...
21:22:46 <Cale> Also, you can use a Data.Map to represent the links
21:22:52 <Cale> (Or IntMap)
21:22:55 <AaronFriel> Cale: Sure, I'm expressing why Haskell is ill-suited to his application
21:22:57 <hackrilege> so its mutability that is at the heart of the woe
21:23:14 <Cale> Uh, but Haskell can do mutable datastructures too :)
21:23:17 <AaronFriel> Cale: And why things like IntMap, Data.Array, Repa, and the like more accurately correspond to numeric/HPC code, where mutation is the norm
21:23:25 <hackrilege> they are slow apparently Cale
21:23:29 <Cale> Huh?
21:23:35 <Cale> Nah
21:23:38 <AaronFriel> Cale: Yes, and I'm sharing why he should not expect to do HPC code with high amounts of mutation using Data.Traversable
21:23:40 <AaronFriel> Cale: Stop
21:23:42 <AaronFriel> Stop please
21:23:45 <AaronFriel> before you start explaining
21:23:51 <AaronFriel> understand this conversation has gone on for hours
21:24:05 <AaronFriel> and hackrilege wants to take advantage of whiz-bang Lens and typeclass hackery
21:24:11 <AaronFriel> while still getting Repa levels of perf
21:24:23 <Cale> Okay, yeah
21:24:25 <AaronFriel> and with data structures that are self-referential
21:24:28 <AaronFriel> so
21:24:45 <AaronFriel> if hackrilege could implement a library that did that
21:24:48 <AaronFriel> we'd all be using it
21:25:04 <AaronFriel> (no offense, hackrilege, but such a thing is simply way out in the weeds)
21:25:06 <hackrilege> sick!
21:25:08 <Cale> There are definitely trade-offs you make in terms of how nice the code is when you decide that you're going to use mutation.
21:25:20 <hackrilege> iim doing it right now
21:25:32 <AaronFriel> hackrilege: Slow down
21:25:33 <hackrilege> you understand thats what im doing right?
21:25:43 <hackrilege> im gona do it
21:25:50 <Cale> But you can manipulate memory in Haskell in essentially all the ways you could in C. It's just not the norm because *not* doing so is so much nicer in terms of maintainability of the resulting code.
21:25:51 <AaronFriel> hackrilege: If you say so, but you will encounter issues
21:25:58 <hackrilege> ok,  where were we
21:26:03 <rlewis> AaronFriel, regardless of the previous conversation, I am not sure why you're refering to using IO to do mutation is cheating, and not haskell
21:26:12 <AaronFriel> haha
21:26:17 <AaronFriel> Well, it's not "Haskell-ish"
21:26:20 <Cale> Yeah, using IO isn't cheating in any way, it's part of Haskell.
21:26:25 <AaronFriel> and it's certainly not something you can do while say
21:26:33 <AaronFriel> taking advantage of Lens combinators without breaking their laws and rules
21:26:39 <AaronFriel> and that's a fundamental problem
21:26:50 <AaronFriel> you either get the sweet combinator libraries and their safe, non-IO-ness
21:26:53 <AaronFriel> OR
21:26:58 <Cale> right
21:27:01 <AaronFriel> you get mutability and FFI and the ability to poke bits
21:27:19 <AaronFriel> and that's why I said "cheating"
21:27:19 <hackrilege> so just to clarify, i am not going to use mutable data structure, even though im mutating the data? seems odd... 
21:27:28 <Cale> I just don't like saying that Haskell is bad at that stuff, because it's not really any worse than any other language.
21:27:32 <AaronFriel> yes, that's the "cheating" part
21:27:54 <AaronFriel> Cale: If anything, Haskell makes it easier, if you write some additional Haskell-y code to keep track of things like pointers and the bits that might cause problems
21:28:04 <hackrilege> you lose functional equivalence? its cheating
21:28:17 <AaronFriel> hackrilege: Yeah, well, it's "immoral"
21:28:18 <Cale> hackrilege: Did you write your program in terms of Data.Map already?
21:28:23 <Cale> (and find out how it performs?)
21:28:33 <hackrilege> i was just about to
21:28:44 <hackrilege> was hearing some cool things about mutable arrays
21:28:47 <Cale> Well, do that first, before you consider doing anything else fancy.
21:29:04 <hackrilege> i heard Map would ot be ok actually
21:29:11 <hackrilege> not*
21:29:13 <AaronFriel> based on what you said
21:29:21 <Cale> You don't really know that until you try it.
21:29:22 <hackrilege> in the long run
21:29:27 <AaronFriel> if you're doing lots and lots and lots of mutation, and updating the map constantly, maybe not, but as Cale said
21:29:29 <AaronFriel> you should try it
21:29:32 <AaronFriel> you cannot know until you do
21:29:49 <hackrilege> nono, i want to understand what im going to have to do when i find it is unsuitable
21:29:59 <hackrilege> and why im going to find this
21:30:07 <Cale> Well, you're going to want to know why it's unsuitable
21:30:15 <AaronFriel> I just know from a bit of experience with HPC code, and keeping up on the literature, that if that literature is representative of your problem
21:30:26 <AaronFriel> You may actually be better off just writing this thing in Python and using numpy/scipy
21:30:28 <Cale> By running the time profiler and seeing what operations are taking all the time in your code.
21:30:52 <AaronFriel> numpy/scipy are well designed for HPC work
21:30:56 <hackrilege> i will be running benchmarks
21:30:58 <Cale> and then you can have a look at picking something more appropriate
21:31:03 <hackrilege> okok
21:31:04 <hackrilege> i will
21:31:05 <hackrilege> thanks
21:31:16 <AaronFriel> hackrilege: Just remember not every tool is built for every purpose
21:31:26 <Cale> Data.Map will likely be the easiest structure to use to get started though, which is why I'm recommending that first.
21:31:32 <hackrilege> so you were saying something. 
21:31:35 <AaronFriel> hackrilege: Haskell's toolbox is full of weird shaped legos that you desparately want to fit together to make a socket wrench
21:31:46 <AaronFriel> hackrilege: But all you can do is make sculptures
21:31:47 <hackrilege> ...
21:31:59 <hackrilege> ill be sure to include that consideration
21:32:06 <AaronFriel> hackrilege: PHP's toolbox is full of hammers that only have two claw parts
21:32:15 <AaronFriel> hackrilege: And C's toolbox has a loaded gun in it
21:32:24 <AaronFriel> hackrilege: You just have to be aware of the toolbox you're opening
21:32:38 <hackrilege> wierd legos, got it
21:32:41 <AaronFriel> weird legos
21:32:45 <AaronFriel> yeah
21:32:55 <hackrilege> better than the gun or the hammers id say
21:32:56 <Cale> Also, Data.Map is really hard to beat uniformly on comprehensive benchmarks. People like edwardk have worked on cache-oblivious map structures to try to get better performance, and I believe he ended up beating Data.Map for reads, but not for writes.
21:33:23 <Cale> and IntMap is even harder still :)
21:33:26 <hackrilege> oo whats that?
21:33:48 <AaronFriel> hackrilege: I wouldn't worry about it until it's relevant to your problem domain, or you're pursuing a CS doctorate
21:33:48 <Cale> I think it's this https://github.com/ekmett/structures
21:34:39 <AaronFriel> https://github.com/ekmett/structures/blob/master/src/Data/Vector/Map.hs
21:34:39 <AaronFriel> jesus
21:34:39 <AaronFriel> language extension zoo
21:34:46 <AaronFriel> hackrilege: Trust me, don't go there, don't try to rely on this stuff
21:34:59 <hackrilege> i can believe that
21:35:11 <AaronFriel> hackrilege: edwardk is a genius, but you are going to go down a rabbit hole if you start trying to compete with him
21:35:30 <hackrilege> im just trying to use tools available to me
21:36:07 <hackrilege> i know this language can be fast for the task at hand, and represent it in an elegant way, thats what im trying to do anyway 
21:36:59 <hackrilege> i dont care how big the fastest library is, i will be finding it and extracting its nuts and bolts so the chemists can see whats going on and why its cool
21:37:01 <Cale> I might have that backward btw
21:37:10 <Cale> (it might be faster for writes than reads)
21:37:21 <hackrilege> i thought so
21:37:25 <Cale> But yeah, it's something you can try as a replacement
21:37:35 <hackrilege> no i thought intmap was more simple that map
21:37:49 <Cale> If you wanted something which was better for reads than writes instead, then you'd want to use UArray or something like that
21:38:04 <hackrilege> i like a tree!
21:38:07 <Cale> There's not just one fastest library
21:38:27 <hackrilege> but there are one set of fast nuts and bolts probably...
21:38:50 <Cale> Each thing is going to be better at some applications, and it really depends on the actual mixture of operations you're performing, whether and how often you're accessing old versions of the structure (e.g. if you're backtracking), things like that
21:39:24 <hackrilege> no you dump small stats and burn the old ones, keep only a few at most
21:39:44 <daddy> hello
21:39:50 <Cale> hello
21:39:58 <hackrilege> they are huge occupying GB of ram for one instance, updated completely millions of times
21:40:17 <daddy> is this channels for hackers
21:40:48 <hackrilege> no hackage is a haskell repository 
21:41:04 <bitemyapp> daddy: the presence of hackrilege may have mislead you.
21:41:31 <Cale> daddy: It's for discussion of the programming language Haskell.
21:41:36 <daddy> some one told me that this is a hacker channel
21:41:50 <hackrilege> no hackers here
21:41:50 <Cale> Well, depends on your definition of hacker.
21:41:51 <bitemyapp> daddy: hacking types is way cooler than defacing websites anyway
21:41:57 <bitemyapp> daddy: want to learn to hack math?
21:42:04 <bitemyapp> daddy: stuff's awesome possum.
21:42:23 <daddy> yes
21:42:47 <Cale> daddy: You won't see a huge amount of discussion of security vulnerabilities here, as a lot of it would be offtopic.
21:43:09 <daddy> can you tell me where should is go for that 
21:43:31 <bitemyapp> daddy: nah. only math here.
21:43:44 <bitemyapp> daddy: can you read/write Russian?
21:43:53 <daddy> no 
21:44:01 <bitemyapp> then you can't become a hacker anyway, so why not learn math?
21:44:19 <Cale> I don't really know, maybe #oss-security?
21:44:37 <daddy> why i have to learn russian for becoming hacker
21:44:49 <Cale> (I've never been to that channel, I just used my IRC client's channel search, as you could as well ;)
21:44:59 <bitemyapp> isn't there a network service for that?
21:45:04 <bitemyapp> searching the channels that is.
21:45:09 <bitemyapp> I think it's pretty efficient too.
21:45:13 <Cale> Possibly
21:46:55 <daddy> tell me some russsian hack channels
21:55:03 <ttt_fff> every time I refactor in ahskell, I think ... if this was C++, I would have just left this as code smell and dealt with shitty data structures because I wouldn't ahve dared to refactor
22:01:51 <AaronFriel> ttt_fff: On the other hand, I have definitely gone too far into the weeds with types sometimes and said, "Well, it's easier to just burn this whole thing down and start ocer."
22:01:53 <AaronFriel> over*
22:02:38 <ttt_fff> AaronFriel: never happened to me, there's always 'git --reset hard" as backup
22:02:56 <AaronFriel> hah
22:02:58 <AaronFriel> yeah
22:03:04 <AaronFriel> I have to go -- sleep beckons
22:03:05 <ttt_fff> it's like (1) let me change these, (2) see how many ghc errors I get (3) oh, that was easy, or (4) fuck, I'm going to git reset hard that
22:03:15 <AaronFriel> yeah I've been there
22:03:20 <AaronFriel> good eve!
22:09:53 <dramforever> ttt_fff: IMHO that's much better than (1) let me change these (2) run program (3) looks good (4) oh wait why this crashes...screw it
22:10:06 <dramforever> horray for the type system
22:10:08 <ttt_fff> yeah, taht's clojure
22:10:36 <ttt_fff> it's (1) let me change this, (2) everything runs fine, (3) writes new code, (4) WTF, why does thiw not work? (5) oh shit, the change I made yesteday causes this map to ahve this structure
22:10:54 <dramforever> oh f**k I need to revert that work
22:11:01 <dramforever> horray for darcs
22:11:31 <ttt_fff> this is also why I like types more than unit tests,
22:11:33 <ttt_fff> unit tests is:
22:11:46 <ttt_fff> (1) le tme change this (2) let me run unit tests, (3) oh fuck, I have to rewrite unit tests, (4) rm -rf unit tests
22:12:54 <dramforever> I like random tests very much
22:13:31 <dramforever> (1) let me change this (2) run this random test (3) hmm my program gave the same results as the previous one for 100,000 tests, it's probably fine
22:15:16 <ttt_fff> dramforever: this is quickchekc you're referring to?
22:15:21 <ttt_fff> maybe I should start learning quickcheck
22:15:29 <dramforever> no just random tests in general
22:15:35 <dramforever> but quickcheck really rocks
22:16:01 <dramforever> ttt_fff: it's suitable for small algorithms
22:16:07 <dramforever> not for large programs
22:17:08 <ttt_fff> dramforever: how do you synthesize random tests?
22:17:20 <ttt_fff> isn'tt he idea that (1) you specify a lemma, (2) quick check uses type magic ot genreat random values
22:17:26 <ttt_fff> an d(3) if any values violate the lemma, it gets reported to you?
22:17:32 <dramforever> "type magic" not really
22:17:35 <dramforever> just typeclasses
22:17:45 <dramforever> but the interface is really nice
22:18:21 <ttt_fff> oh right, all you need is
22:18:32 <ttt_fff> class Random a where random :: RandomMonad a
22:18:37 <ttt_fff> then you can sample random values, cute
22:19:06 <dramforever> kinda
22:19:13 <dramforever> but there's a thing called functions
22:20:43 <ttt_fff> give me an example where being able to synthesize random values does not suffice
22:21:12 <dramforever> instance ??? => Random (a -> b)
22:21:47 <ttt_fff> whwat does that unit test look like?
22:21:51 <ttt_fff> i.e. what is it wanting to prove
22:22:00 <dramforever> oh
22:22:04 <ttt_fff> I thought lemmas are of the form (forall a b, c : blah holds), so al lyou have to do is to synthezei random values for a, b, c
22:22:15 <ttt_fff> I guess one of a, b, c would be a function
22:22:18 <dramforever> yep but what if you need a function?
22:22:26 <ttt_fff> like if you were quick-checking 'map'
22:22:44 <dramforever> no forget about it I don't much know about quickcheck
22:22:44 <dramforever> https://hackage.haskell.org/package/QuickCheck-2.8.1/docs/Test-QuickCheck-Arbitrary.html
22:22:50 <dramforever> check this for sure
22:23:15 <ttt_fff> this is why #haskell is so nice
22:23:23 <dramforever> @check (\xs -> map id xs == xs) :: (Int -> Int) -> [Int] -> [Int]
22:23:25 <lambdabot>  Couldn't match expected type â[Int] -> [Int]â
22:23:25 <lambdabot>  with actual type âBoolâ In the expression: map id xs == xs In the first argu...
22:23:29 <dramforever> sigh
22:23:29 <ttt_fff> people are humble and admit lack of expertise instead of making up random BS and trying to pretend to be right
22:23:37 <kazagistar> its hard to "reduce" an Arbitrary function
22:23:40 <ttt_fff> [ I also know nothign about quickcheck and have never use it msyelf ]
22:24:08 <kazagistar> wouldn't be very useful for that reason either way, but you might be able to make one anyways
22:24:34 <dramforever> ttt_fff: oh and it's also not the on other end
22:24:37 <dramforever> "go RTFM"
22:24:45 <dramforever> *on the other end
22:25:03 <ttt_fff> yeah, "what's a monad? go RTFM" would not be very helpful
22:25:15 <ttt_fff> though I think something like "go Read The Friendly Type Signature" would be useful
22:25:33 <EvanR> the type signature of monads doesnt tell you the monad laws
22:25:36 <dramforever> some think that #haskell does this because we want to attract new users
22:25:39 <kazagistar> except apparently this exists, so my mind is slightly blown and I have some reading to do: https://hackage.haskell.org/package/QuickCheck-2.4.1.1/docs/Test-QuickCheck-Function.html
22:25:49 <dramforever> but I think there's something deeper
22:26:51 <rlewis> @check (\xs -> map id xs == xs) :: [Int] -> Bool
22:26:53 <lambdabot>  +++ OK, passed 100 tests.
22:26:55 <nshepperd> quickcheck has Coarbitrary which generates random functions for you
22:27:02 <nshepperd> it's pretty sweet
22:27:23 <rlewis> @check (\xs -> reverse xs == xs) :: [Int] -> Bool
22:27:24 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 5 shrinks):
22:27:25 <lambdabot>  [4,-3,1,-4]
22:27:29 <bitemyapp> https://hackage.haskell.org/package/quickspec
22:27:32 <dramforever> because I'm pretty sure those who join ##java have at least some programming experience
22:27:46 <dramforever> but #haskell, hmm...
22:27:55 <bitemyapp> are you serious?
22:28:06 <bitemyapp> like half the people asking Java questions on the internet are panicked freshmen
22:28:07 <ttt_fff> rlewis , nshepperd: both of those examples generated randomlists, where is the random function generation?
22:28:19 <dramforever> bitemyapp: "panicked" hmm...
22:28:36 <dramforever> but here in #haskell most people are essentially learning programming from scratch
22:28:52 <dramforever> so there's still a difference
22:28:53 <nshepperd> @check (\f xs -> fmap f xs == map f xs) :: (Int -> Char) -> [Int] -> Bool
22:28:55 <lambdabot>  +++ OK, passed 100 tests.
22:29:21 <dramforever> ttt_fff: I can't say we don't make up random BS, but it seems that we are trying to be helpful
22:29:25 <bitemyapp> dramforever: oh fo sho
22:29:30 <dramforever> =)
22:29:43 <bitemyapp> dramforever: I'm all about teaching Haskell with the mindset of, "fuck what you know. You know nothing. Now go wash the cars."
22:29:54 <Welkin> is there a way to convert a String -> ByteString without losing information?
22:30:12 <dramforever> bitemyapp =)
22:30:13 <bitemyapp> Welkin: use an encoding that captures everything a Char can be.
22:30:24 <dramforever> I recommend utf-8
22:30:25 <Welkin> bitemyapp: will BS.getLine do this for me?
22:30:34 <bitemyapp> Welkin: you'll want to read the different encodings Text offers carefully, but Char isn't really fully Unicode kosher so I'd be a bit paranoid if you really care that much.
22:30:43 <rlewis> ttt_fff, I just mechanically corrected dramforever's example. no clue about quickcheck generating random functions
22:30:44 <bitemyapp> ie, avoid ever having landed in String to begin with if correctness matters that much.
22:30:45 <dramforever> oh that's a problem
22:30:52 <Welkin> well, this is for encrypting/decrypting strings
22:30:58 <dramforever> rlewis =)
22:30:59 <Welkin> and I want it to work on unicode
22:31:10 <ttt_fff> rlewis: do you sprinkle quick check code into you haskell code?
22:31:12 <bitemyapp> Welkin: don't accept Strings as input.
22:31:15 <dramforever> Welkin: just make it work for all byte sequences
22:31:21 <Welkin> I am writing my functions to use ByteString all the way through
22:31:25 <ttt_fff> rlewis: I'm consdiering, just like how I write type sigs for all global funcs, to also write quick checks for all funcs defined
22:31:27 <dramforever> wait
22:31:29 <Welkin> and BS.getContents/getLine for input
22:31:33 * dramforever tests BS.getLine
22:31:37 <bitemyapp> Welkin: then just accept that and ignore the insanity that is Char :P
22:31:41 * dramforever stops
22:31:59 <dramforever> Welkin: no I remembered something
22:32:51 <EvanR> whats insane about Char
22:33:00 <Welkin> dramforever: what is it/
22:33:03 <Welkin> ?
22:33:12 <dramforever> http://hackage.haskell.org/package/bytestring-0.10.6.0/docs/src/Data.ByteString.html#hGetLine
22:33:22 <dramforever> the source code is great
22:33:43 <dramforever> I don't know what it means for you, but I think it's reading the raw buffer of the handle
22:34:25 <dramforever> i.e. it just reads the bytes
22:34:43 <Welkin> that is what I thought
22:34:51 <dramforever> seems good enough
22:34:53 <Welkin> if I can get my code working again I can test it out
22:35:05 <Welkin> I previously wrote it using String and assumed ascii input
22:35:20 <dramforever> Welkin: good
22:36:30 <EvanR> supporting unicode? may god have mercy on your soul
22:37:31 <EvanR> Ascii would be cool, for some value of cool
22:42:04 <Welkin> lol
22:42:54 <Welkin> it's just some toy cipher using differential XORing
22:43:11 <Welkin> but I want to see if I can make it work on more than just ascii
22:43:38 <Welkin> it became very messy using strings actually
22:43:47 <Welkin> with bytestring I am deleting tons of code
22:44:39 <dramforever> :t Data.ByteString.scanl
22:44:41 <lambdabot> (Word8 -> Word8 -> Word8) -> Word8 -> BSC.ByteString -> BSC.ByteString
22:45:00 <dramforever> :t Data.ByteString.mapAccumL
22:45:01 <lambdabot> (acc -> Word8 -> (acc, Word8)) -> acc -> BSC.ByteString -> (acc, BSC.ByteString)
22:51:59 <ttt_fff> I think haskell is local optimum for best programming langauge
22:52:08 <ttt_fff> s/best programming langauge/safety/
22:52:15 <ttt_fff> idris gives more safety, but dependent types are too hard currently to use
22:52:24 <ttt_fff> and anything less does not provide the type guarantees that haskell provides
22:54:51 * hackagebot moesocks 0.1.0.17 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.0.17 (JinjingWang)
23:02:15 <EvanR> and idris isnt really "ready" for general purpose
23:02:57 <EvanR> because ttt_fff hasn't figured it out for us
23:02:58 <hackrilege> http://lpaste.net/138863
23:05:32 <hackrilege> and thats why i thought map would be slow...
23:05:41 <hackrilege> Map*
23:08:13 <hackrilege> fst $ M.partitionWithKey (\k _ ->k `elem` cs) m
23:14:33 <RedNifre> Functional morning to all of you!
23:14:39 <hackrilege> hi
23:16:21 <RedNifre> Question: If you use wildly incompatible platforms (regular computer, Android, Atom Editor) and you want to use the same code on all of them, would it be feasible to write your shared code as Haskell source code, compile it for the regular computer, compile it with Frege for Android and use something like Fey or ghcjs to compile it to javascript which you can then use in the Atom Editor? Or how do you achieve code reuse?
23:16:25 <hackrilege> does this look slow to you? http://lpaste.net/138863
23:16:51 <hackrilege> im trying to do this too
23:17:10 <hackrilege> i couldnt build android-ghc
23:17:54 <kadoban> RedNifre: Frege and haskell aren't the same language, so that part is /way/ not feasible.
23:18:00 <RedNifre> I didn't even try because it looked impractical. If Frege works (nearly-Haskell for the JVM) it might be my second try...
23:18:14 <hackrilege> i think the way to do it is to compile to shared C libraries which can be imported into java projects
23:18:23 <RedNifre> I heard that it is similar enough to compile most Haskell as Frege.
23:19:16 <RedNifre> hackrilege sounds like it could work as well. Though I'm not sure how you would deal with different CPUs, not every Android device uses ARM.
23:20:10 <hackrilege> yes i think there are special cross compiler flags to be used for targeting arm. check out nerocyte, he got close but is since depreciated
23:21:15 <hackrilege> you could always just run gnu-root on android
23:22:24 <nshepperd> hackrilege: you're doing the groupAccessor bit over and over again there
23:22:39 <hackrilege> i know
23:22:54 <hackrilege> thats the problem
23:22:59 <nshepperd> oh wait, you have to since it depends on coord
23:23:31 <hackrilege> thanks for taking a look
23:23:51 <hackrilege> its a simple convolution
23:25:00 <hackrilege> it seems a Map is unsuitable as costly accessor to neighbours... 
23:26:11 <hackrilege> compared too http://lpaste.net/138850
23:26:39 <dramforever> what about an array?
23:26:59 <hackrilege> ill do that one next
23:27:08 <dramforever> ok
23:27:10 <hackrilege> just want to confirm my understanding of Map first
23:27:43 <dramforever> "costly accessor to neighbours" that's pretty interesting
23:27:53 <hackrilege> thats the point!
23:27:55 <dramforever> because the cost is the same almost everywhere
23:27:55 <nshepperd> umm, the partitionWithKey will run in O(nm) time
23:28:53 <hackrilege> i could just give you the values adjacent traversing one away in a graph
23:29:04 <hackrilege> O(1)
23:29:27 <dramforever> map supports random access and "update" pretty well
23:29:46 <dramforever> maybe the compromise is undesired
23:29:46 <hackrilege> random yes, adjacent no
23:30:06 <hackrilege> certainly
23:30:42 <AbelianGrape> How do I run a QuickCheck test without printing to stdout?
23:30:50 <nshepperd> hackrilege: groupAccessor (Grid m) cs = Grid $ Map.intersection m (Map.fromList $ zip cs (repeat ()))
23:30:54 <dramforever> hackrilege: I think I found a problem with your funtion approach
23:31:02 <dramforever> *function
23:31:36 <nshepperd> or zip cs cs, whatever
23:31:37 <hackrilege> nshepperd awesome
23:31:39 <hackrilege> dramforever, go on
23:31:44 <dramforever> the function will be run over and over again
23:32:21 <hackrilege> so?
23:32:33 <hackrilege> thats the idea
23:32:39 <dramforever> so say you mapped over the Grid N times
23:32:49 <dramforever> that's N functions nested
23:32:53 <dramforever> *composed
23:33:05 <hackrilege> ok
23:33:06 <dramforever> so every time you access a cell, those N functions will be called
23:33:22 <hackrilege> ok
23:33:22 <ttt_fff> is there a function for taking all ways to split a list? i.e. [a, b, c, d, e] -> [ ([], [a, b, c, d, e]),  ([a], [b, c, d, e]),   ([a, b], [c, d, e]),   ([a, b, c], [d, e]),    ([a, b, c, d], [e]),    ([a, b, c, d, e], []) ]
23:34:25 <hackrilege> map splitAt [1..] $ repeat?
23:34:26 <ttt_fff> hmm, I should proabbly use splitAt
23:34:39 <hackrilege> 0*
23:34:42 <ttt_fff> > map splitAt [1..] $ repeat "hello world"
23:34:43 <lambdabot>      Couldn't match expected type â[[Char]] -> tâ
23:34:43 <lambdabot>                  with actual type â[[a0] -> ([a0], [a0])]â
23:34:43 <lambdabot>      The first argument of ($) takes one argument,
23:34:49 <dramforever> mind you, this method is O(n^2)
23:34:55 <dramforever> but it has to be
23:34:57 <ttt_fff> map (splitAt [0..]) $ repeat "hello world"
23:35:07 <dramforever> well, O(n^2) for the whole list, I mean
23:35:09 <ttt_fff> dramforever: the output is O(n^2)
23:35:14 <dramforever> yes
23:35:16 <ttt_fff> > map (splitAt [0..]) $ repeat "hello world"
23:35:17 <lambdabot>      Couldn't match expected type âIntâ with actual type â[Integer]â
23:35:17 <lambdabot>      In the first argument of âsplitAtâ, namely â[0 .. ]â
23:35:17 <lambdabot>      In the first argument of âmapâ, namely â(splitAt [0 .. ])â
23:35:32 <dramforever> > tails "string"
23:35:33 <lambdabot>  ["string","tring","ring","ing","ng","g",""]
23:35:37 <ttt_fff> > zipWith splitAt [0..] $ repeat "hello world"
23:35:39 <lambdabot>  [("","hello world"),("h","ello world"),("he","llo world"),("hel","lo world")...
23:35:42 <ttt_fff> there we go
23:35:45 <ttt_fff> > zipWith splitAt [0..] $ repeat "hello"
23:35:45 <dramforever> I thought you know that tails function, which is O(n)
23:35:47 <lambdabot>  [("","hello"),("h","ello"),("he","llo"),("hel","lo"),("hell","o"),("hello","...
23:36:00 <ttt_fff> fuck, splitAt does not stop
23:36:02 <ttt_fff> > zipWith splitAt [0..] $ repeat "cat"
23:36:04 <lambdabot>  [("","cat"),("c","at"),("ca","t"),("cat",""),("cat",""),("cat",""),("cat",""...
23:36:21 <ttt_fff> > take (length "cat") $ zipWith splitAt [0..] $ repeat "cat"
23:36:22 <lambdabot>  [("","cat"),("c","at"),("ca","t")]
23:36:27 <ttt_fff> > take (length "cat" + 1) $ zipWith splitAt [0..] $ repeat "cat"
23:36:29 <lambdabot>  [("","cat"),("c","at"),("ca","t"),("cat","")]
23:36:37 <ttt_fff> okay, I'm done, and should stop before getting kick banned for spamming lambdabot
23:36:42 <hackrilege> its repeat which does not stop
23:36:42 <ttt_fff> hackrilege: thanks for suggesting splitAt
23:39:03 <Cale> > let splits [] = [([],[])]; splits xxs@(x:xs) = ([],xxs) : [(x:us,vs) | (us,vs) <- splits xs] in splits [1..4]
23:39:04 <lambdabot>  [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
23:39:16 <Cale> No indexing required
23:39:42 <rlewis> > let xs = [a,b,c,d,e] in zip (inits xs) (tails xs)
23:39:44 <lambdabot>  [([],[a,b,c,d,e]),([a],[b,c,d,e]),([a,b],[c,d,e]),([a,b,c],[d,e]),([a,b,c,d]...
23:39:53 <ttt_fff> Cale: you can't tell me yours is more readable
23:40:03 <ttt_fff> Cale: well, you could, but I would not beleive you
23:40:06 <Cale> It's not more readable
23:40:15 <hackrilege> rlewis you dog
23:40:17 <ttt_fff> > inits "cat"
23:40:19 <lambdabot>  ["","c","ca","cat"]
23:40:25 <ttt_fff> > tails "cat"
23:40:27 <lambdabot>  ["cat","at","t",""]
23:40:29 <rlewis> hackrilege :P
23:40:32 <ttt_fff> rlewis: you win
23:40:39 <dramforever> hey...
23:41:11 <dramforever> weird, I have to say
23:41:18 <ttt_fff> I need to make flash cards
23:41:23 <ttt_fff> of all the functions in Data. *
23:41:48 <ttt_fff> > zip (inits "cat") (tails "cat")
23:41:50 <lambdabot>  [("","cat"),("c","at"),("ca","t"),("cat","")]
23:41:55 <nshepperd> hackrilege: you probably want to do the same thing as repa and use both arrays and functions
23:42:14 <ttt_fff> > init "cat"
23:42:16 <lambdabot>  "ca"
23:42:23 <nshepperd> hackrilege: ie. have a Grid type using an array, and one using a function, and interconvert as appropriate
23:42:54 <hackrilege> :t scan
23:42:55 <lambdabot>     Not in scope: âscanâ
23:42:55 <lambdabot>     Perhaps you meant one of these:
23:42:55 <lambdabot>       âscanlâ (imported from Data.List),
23:43:42 <hackrilege> yeh, and the function one is just the accessor to the array one
23:43:44 <GoogleMePlox> What are the advantages for learning Haskell as a first langauge (it's my first language at uni)? I heard Dijkstra was an advocate of using Haskell as a first language.
23:43:48 <nshepperd> oh, or you can just memoize the function occasionally I guess (using an array)
23:44:43 <hackrilege> GoogleMePlox because the hard work of memory considerations are hidden from you, you just say what you want to happen
23:45:14 <dramforever> GoogleMePlox: because there are less distracting stuff in general
23:45:26 <dramforever> and you can easily write general programs
23:45:44 <hackrilege> i have a very balanced access rate, it just sweeps over them all once, i must play on this
23:46:21 <ttt_fff> > tails "cat"
23:46:23 <lambdabot>  ["cat","at","t",""]
23:46:40 <hackrilege> @src tails
23:46:41 <lambdabot> tails []         = [[]]
23:46:41 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
23:46:43 <ttt_fff> > init $ tails "cat"
23:46:44 <lambdabot>  ["cat","at","t"]
23:47:11 <nshepperd> benefit: it's possible to finish a piece of haskell code
23:47:14 <hackrilege> ahh, Cales is looking best now
23:50:07 <hackrilege> nshepperd, the problem is that these structures are not giving me fast nearset neighbour lookup, a single traversal is huge O(log n) is too long to wait for neighbours which should be immediately accessible 
23:50:50 <dramforever> "huge"
23:50:55 * dramforever shrugs
23:50:57 <hackrilege> millions
23:51:39 <dramforever> that's why you should use arrays if you want fast random reads
23:51:49 <dramforever> and mapWithIndex
23:52:11 <hackrilege> i dont want fast random reads! i want nearest neighbour access at O(1)
23:52:11 <dramforever> but I'm afraid that "updating" a single point is too slow
23:52:28 <dramforever> hackrilege: they don't contradict with each other
23:52:36 <dramforever> "access" do you need to change them?
23:52:43 <hackrilege> no
23:52:51 <dramforever> then arrays are fine
23:52:57 <dramforever> they are O(1) for random reads
23:53:09 <hackrilege> that will be acheived with a map, which will change them based on a read of the adjacent values
23:53:43 <dramforever> arrays can do O(1) read everywhere
23:53:56 <dramforever> maps can do O(log N) read and "update" everywhere
23:54:19 <hackrilege> how can it be as fast accessing a random element as a neighbour which i could store the value of in a reference
23:55:02 <dramforever> asymptotically as fast as that
23:55:15 <hackrilege> i dont understand
23:55:21 <dramforever> it's O(1)
23:55:33 <hackrilege> ok
23:56:20 <dramforever> hackrilege: also accessing a field of a constructor requires a pointer dereference
23:57:05 <hackrilege> so if i was in a linked list somewhere and i went to my neighbour and got its value, your saying thats as fast as if i had no close reference point and wanted to extract it from a gigabyte size array
23:57:09 <dramforever> accessing an array requires a boundary check, an index calculation, and a pointer dereference
23:57:30 <dramforever> but you could use stuff like unsafeAt and unsafeIndex to get rid of the boundary check
23:57:47 <dramforever> hackrilege: *asymptotically* as fast as that
23:57:56 <dramforever> you said you want O(1)
23:58:02 <hackrilege> i changed my mind
23:58:04 <dramforever> I told you one
23:58:19 <hackrilege> i want to exploit my proximity
23:58:20 <nshepperd> hackrilege: yes. in practice it's most likely actually faster to get it from the array
23:58:42 <nshepperd> because it's all about the cache at that level
23:58:56 <hackrilege> and traverse a treelike datastructure
23:59:01 <nshepperd> and arrays have better cache locality, in general
23:59:17 <hackrilege> admitedly, they can be of nested arrays, but the number of nestings will far exceed the length of the array
23:59:50 <dramforever> proximity...
23:59:54 * hackagebot Pugs 6.2.13.20150815 - A Perl 6 Implementation  https://hackage.haskell.org/package/Pugs-6.2.13.20150815 (AudreyTang)
