00:00:08 <noodles1> anyone seen the TelAviv Meetup post on reddit/haskell ?
00:01:35 <moop> noodles1: imma going to that probably
00:01:46 <moop> but i'm a haskell noob
00:02:41 <noodles1> moop: nice. did you seen BanX's comments?
00:03:33 <moop> i want to say no but i did
00:07:05 <sanjoyd> So this means ghc can, in general, cannot optimize "b + 10 - b" to 10?
00:07:17 <sanjoyd> Because b could be undefined?
00:07:37 <johnw> "undefined + 10" has no meaning other than undefined
00:07:58 <johnw> the fact that you see a way to elide structure to remove the use of undefined, doesn't mean it's at all easy to do in the general case
00:08:01 <noodles1> moop: incredible, he's also accosting yitz's other threads. I guess I just didn't expect someone that stupid to be interested in Haskell
00:08:28 <srhb> noodles1, moop: I think this discussion is best taken in -blah or elsewhere
00:08:51 <noodles1> srhb: you're right, sorry
00:09:16 <srhb> No problem. It's interesting, just not very productive in here, I feel. :)
00:16:10 <johnw> sanjoyd: it's an interesting line of thinking, mind you, worth researching; maybe someone has done a paper on it
00:22:17 <sanjoyd> What bothers me about this is that if the "runtime error" behavior is an observable thingy (again, sorry for the rough terminology) then the compiler isn't really capable of doing things like auto parallelizing your programs, since any change in the evaluation order (in the general case) could change which "runtime error" you get.
00:22:19 <nshepperd> sanjoyd: we do generally want 'case x of A -> 0; B -> undefined' to throw an exception in the case that x = B and that expression is evaluated
00:23:44 <nshepperd> of course, in the case where that is never evaluated in the first place... with sufficient inlining the liveness analysis should tell us that we can cut out that dead code entirely
00:24:52 <sanjoyd> I remember hearing about a paper named "fast & loose reasoning is morally correct"; perhaps I should go and read that now.
00:26:08 <nshepperd> ie. with `let y = (case x of A -> 0; B -> undefined) in "hello"` there's no need to even rewrite the case statement at all, we can just throw away the let entirely and write `"hello"`
00:38:43 * hackagebot yesod-core 1.4.15 - Creation of type-safe, RESTful web applications.  https://hackage.haskell.org/package/yesod-core-1.4.15 (MichaelSnoyman)
00:43:47 <ttt_fff> does data.text
00:43:49 <ttt_fff> have a substr ?
00:48:48 <cocreature> ttt_fff: you could combine drop and take
00:50:22 <lpaste_> Bruuuuuno pasted “Can I make this smaller?” at http://lpaste.net/139554
00:50:31 <Bruuuuuno> I just want to print a message when this function return nothing, is there a way to make this smaller?
00:50:41 <Bruuuuuno> http://lpaste.net/139554
00:51:03 <srhb> :t fromMaybe
00:51:05 <lambdabot> a -> Maybe a -> a
00:51:11 <srhb> :t maybe
00:51:12 <lambdabot> b -> (a -> b) -> Maybe a -> b
01:02:19 <ttt_fff> does parsec have a builtin 'integer' parser or do I juse use 'read' ?
01:02:38 <quchen2> ttt_fff: Look at the token parser submodules
01:02:48 <ttt_fff> https://hackage.haskell.org/package/parsec-numbers ?
01:02:50 <ttt_fff> or someting else?
01:03:00 <quchen2> No it's part of parsec
01:03:05 <ttt_fff> or https://hackage.haskell.org/package/parsec ?
01:03:23 <quchen2> ttt_fff: http://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Token.html
01:03:23 <ttt_fff> there's no submodule named 'num' 
01:03:25 <quchen2> Scroll to the bottom
01:04:17 <quchen2> "P.integer lexer" would give you your parser.
01:04:58 <ttt_fff> quchen2: nice, thanks
01:05:27 <bycn82> finally, i read the "learn you a haskell"
01:08:44 * hackagebot mono-traversable 0.9.3 - Type classes for mapping, folding, and traversing monomorphic containers  https://hackage.haskell.org/package/mono-traversable-0.9.3 (MichaelSnoyman)
01:11:22 <felixdae> hi, everyone. how can i rewrite f (f a b c) (f d e f) g to eliminate as many parentheses as possible
01:12:02 <quchen2> You can, but you should not (because it will be a mess).
01:12:23 <quchen2> ?pl \f a b c d e f g -> f (f a b c) (f d e f) g
01:12:25 <lambdabot> const (((((const .) .) .) .) . flip flip id . ((flip . ((flip . ((flip . (ap .)) .)) .)) .) . flip flip (flip flip id . (ap .) . flip . flip id) . ((flip . (((.) . (.) . ap . ap id) .) . flip) .) . flip . flip id)
01:12:43 <quchen2> Hm, well that didn't really remote that many parentheses.
01:13:00 <quchen2> You could play around with `ap` and friends to accomplish it. But there is no way that is easier to read.
01:13:34 <srhb> Does f (f a b c) $ f d e f count?
01:13:36 <srhb> :P
01:14:10 <chattered> That's going to have infinite type.
01:14:32 <lwm> didn't you forget 'g' ?
01:14:40 <srhb> Oh, yes.
01:14:44 <srhb> I didn't even notice that.
01:15:04 <srhb> But I second leaving it alone. It's fine as is.
01:15:09 <lwm> I am your type system ;)
01:16:02 <cocreature> well can't you just eta reduce the g?
01:16:17 <quchen2> Is it easier to read that way?
01:16:36 <cocreature> imho no :)
01:22:09 <felixdae> is it right that for some expressions you can't eliminate all parentheses only by rewriting it with . and $?
01:22:54 <srhb> felixdae: Yes.
01:24:06 <quchen2> You should avoid parentheses like you avoid newlines: not.
01:24:18 <srhb> felixdae: I don't think that's generally possible only for one argument.
01:24:25 <srhb> Er
01:24:30 <srhb> I think it's only generally possible for one argument
01:31:48 <flux> let x = f a b c in let y = f d e f in f x y g
01:31:49 <flux> no parens!
01:32:05 <bycn82> hi help !
01:32:13 <bycn82> in "learn you a haskell"
01:32:22 <bycn82> there is an example using "dot" 
01:32:24 <bycn82> reverseWords = unwords . map reverse . words
01:32:38 <bycn82> what does the '.' mean in the expression?
01:32:44 <liste> bycn82 it's composition
01:32:48 <liste> @src (.)
01:32:48 <lambdabot> (f . g) x = f (g x)
01:33:46 * hackagebot HMap 1.2.7 - Fast heterogeneous maps and unconstrained typeable like functionality.  https://hackage.haskell.org/package/HMap-1.2.7 (AtzeVanDerPloeg)
01:34:19 <chattered> bycn82: Colloquially, the whole expression means: apply "words" to the argument, feed the result into "map reverse", and then feed the result into "unwords."
01:34:47 <bycn82> (f . g) x = f (g x)
01:34:53 <bycn82> let me verify
01:39:28 <bycn82> OK, thanks
01:43:26 <liste> yw (:
02:02:19 <adeln> I'm wondering if there are any impure languages with the first-class typeclasses
02:02:37 <adeln> except scala, because typeclasses are kind of ad-hoc in there
02:03:12 <chattered> By first-class, do you mean where you have values of type Constraint?
02:04:55 <adeln> chattered: by first-class I meant something I can declare in a straightforward way, like a function in haskell, or an interface in java
02:05:23 <adeln> chattered: not like a function in java (pre 8) or a typeclass in scala
02:06:33 <chattered> Rust has typeclasses (and even associated types).
02:19:16 <spaceloop> does ghc ever optimize using "laws" that should hold (e.g. monad)?
02:19:55 <liste> spaceloop there's rewrite rules https://wiki.haskell.org/GHC/Using_rules
02:19:58 <dramforever> TIL you could pass --ghc-options to cabal install to easily "fix" some problems
02:21:02 <spaceloop> ok, but I don't have to worry about my program being changed if I break some laws?
02:21:32 <dramforever> of course you have to worry
02:21:46 <liste> why would you break them
02:21:48 <liste> ?
02:22:04 <quchen2> spacebug: GHC knows nothing about class laws.
02:22:11 <quchen2> It will not use them for optimizations.
02:22:41 <quchen2> In fact laws are just strong suggestions; having a violating Monad instance is still valid Haskell.
02:23:01 <spaceloop> thanks, now I can sleep again at night ;)
02:23:27 <quchen2> You should however have a *very* good reason to violate the laws.
02:25:01 <spaceloop> I am counting the number of binds in a state monad as extra state
02:25:18 <quchen2> That's something you should only be doing for debugging.
02:25:27 <quchen2> And that should never be in live code.
02:25:33 <spaceloop> yes, exactly
02:25:54 <spaceloop> but still, I wouldn't like it if some optimizations would change the behaviour when debugging
02:27:25 <dramforever> but ghc can't possibly know if your instances satisfy the laws
02:36:26 <anakreon> I updated ghc-mod to version 5.3. Now when I try to load a file in ghc from emacs (C-l), emacs blocks for a while and then reports in the *Messages* buffer the message "ghc-check-syntax: ghc process may have hung or exited with an error". Any ideas how to find what's wrong?
02:37:01 <dramforever> anakreon +1
02:37:13 <hvr> anakreon: jfyi, there's also a #haskell-emacs channel in case you dont get answers here
02:37:49 <anakreon> Thanks hvr. I will move the topic there
02:38:16 <tsahyt> Did the ghc-pkg db file format change from 7.8 to 7.10? I'm having problems with ghc-mod once again.
02:38:49 * hackagebot microformats2-parser 1.0.1.1 - A Microformats 2 parser.  https://hackage.haskell.org/package/microformats2-parser-1.0.1.1 (myfreeweb)
02:41:42 <zipper> tsahyt: You using stack?
02:41:58 <zipper> Because then you're using a totally different db.
02:43:08 <tsahyt> zipper: I've managed to get it working now. The problem seems to be that ghc-mod is now using lts-3.1 as a resolver, so it uses GHC 7.10.2 to build. And then it somehow throws an error when working in a project that uses the 2.22 resolver, something about ghc-pkg db file and wrong magic number
02:43:51 <tsahyt> When forcing it to compile with 7.8.4 (by setting the resolver back down to 2.22) it now works with this project again. This is all becoming slightly messy by now.
02:43:57 <zipper> Ha I had that issue with my project but fixed it. Maybe I could send a fix to the ghc-mod devs
02:44:16 <zipper> But I'm busy :(
02:44:48 <tsahyt> I used to be busy until ghc-mod started to crap out for now good reason. Now I spent an hour on this, but at least it works again.
02:44:56 <tsahyt> s/now/no
02:49:40 <dramforever> TIL cabal copy will copy the executables to ~/.cabal/bin or somewhere appropriate
02:59:37 <newpm> I've recently taken over a team that develops SaaS apps in java and flex. I haven't coded in about 10 years, but even when I did, it was simple stuff like implementing quicksort in C etc. Given that I'm going to be working with a whole bunch of devs and testers, I'd like to learn a new programming language - one that helps me understand programming
02:59:38 <newpm> , but from a non C/Java POV (so I can have the pleasure of relearning programming as well). Is Haskell the right way to go about this?
03:00:56 <tero> newpm: also those with lots of experience in imperative programming languages (C, java, etc.) will have the pleasure of relearning programming when they switch to functional programming :) 
03:01:15 <liste> newpm I would say so
03:02:29 <tsahyt> newpm: If you want to stay within the imperative paradigm, you'd probably be better off with something like Rust. If you want to broaden your horizon to something fundamentally different, Haskell is a great choice though.
03:03:17 <newpm> Haskell fascinates me for sure.
03:03:35 <newpm> I just dont want it to be too removed from what my team will do in terms of programming philosophy.
03:03:51 <srhb> newpm: For someone who's currently experienced in imperative, Haskell is also like relearning to program, so yeah. :P
03:04:11 <dramforever> newpm: tbh you should consider if it's worth it to relearn programming
03:04:13 <newpm> I am posting the same question on clojure and erlang as well. Ideally the approach is to spend a month  on each and then decide but i dont know if i have that time
03:04:14 <srhb> Parts of what you learn in Haskell will be very decoupled from any imperative way of doing things.
03:04:37 <tsahyt> Well from a theoretical point of view, all paradigms of computation are equivalent, and I've found that learning Haskell also made me a better imperative programmer.
03:04:42 <dramforever> also, IMHO I think the haskell ecosystem isn't really mature in some ways
03:05:01 <dramforever> stuff like IDEs aren't quite ready yet
03:05:06 <dramforever> or did I miss something?
03:05:06 <liste> Clojure and Erlang would be quite removed from imperative way too
03:05:29 <tsahyt> dramforever: I think the main problem is that the vast majority of Haskell programmers are perfectly content with their Emacs or Vim setups
03:05:30 <tdammers> dramforever: I think what you're missing is that Haskell doesn't require an IDE anywhere near as much as Java does
03:05:40 <maerwald> no language requires an IDE
03:05:45 <maerwald> dramforever: did you try leksah?
03:05:52 <tsahyt> maerwald: Some do if you value your sanity
03:05:57 <dramforever> maerwald: "Updating Metadata"
03:05:58 <tdammers> maerwald: Haskell without an IDE is very pleasant. Java without an IDE is insane.
03:06:07 <maerwald> tdammers: I have done java without an IDE just fine
03:06:14 <dramforever> i.e. just installed it and started out
03:06:37 <tdammers> maerwald: I've done Java without an IDE, but it wasn't fine. Maybe that's because the rest of the people who worked on it did use an IDE.
03:07:07 <maerwald> that's more related to people not making sane build systems than to anything else
03:07:10 <dramforever> tdammers: I want to know if my productivity could be higher with those fancy stuff
03:07:20 <dramforever> so I'm trying out some haskell IDEs
03:07:25 <tzaeru> actionscript and flash-related projects without an IDE.. *thumbup*
03:07:54 <tdammers> dramforever: fair approach. Mine is to make better abstractions, but I'm quite stubborn.
03:08:14 <ilmig> I'm a Haskell beginner and I'm looking for a simple (micro) web framework for a small and simple app. What would you recommend?
03:08:18 <dramforever> tdammers: I want to optimize it the other way around
03:08:34 <liste> if there was good refactoring tools for Haskell on the command line I wouldn't even think of an IDE
03:08:45 <liste> does anybody know any?
03:08:47 <dramforever> ilmig: I heard that scotty was pretty simple http://hackage.haskell.org/package/scotty
03:08:52 <newpm> dramforever: I dont know yet. I remember having a lot of fun programming those basic programs in C / JAva. and even some really simple stuff on old 8085 microprocessors.
03:08:58 <srhb> ilmig: There's also Spock. :)
03:09:01 <dramforever> newpm ++
03:09:17 <newpm> Plus, if I am going to be leading a team of devs, i better be able to code and be able to understand intricacies too
03:09:18 <liste> Spock has a lot of advanced concepts though, like type families
03:09:30 <liste> Scotty is dead simple
03:09:34 <srhb> Very true. On the other hand you don't outgrow it as easily as you might Scotty. :)
03:09:44 <dramforever> also I think servant is a fancy but lightweight one
03:09:54 <liste> I think it's easy to move from scotty to spock
03:10:03 <liste> unlike Yesod for example
03:10:07 <srhb> If the priority is "dead simple to learn" Happstack is also a good candidate.
03:10:10 <dramforever> servant has all those type level magic stuff
03:10:44 * frerich wonders if "spock has a lot of advanced concepts" and "scotty is dead simple" -- where does that put kirk? "is just middleware which passes all work to other systems"?
03:10:47 <srhb> Servant also has the benefit of an extremely active community in #servant
03:12:03 * dramforever already tried those intellij plugins, but it seems that none of them has autocompletion
03:12:18 <lwm> @ilmig: Servant looks amazing for APIs https://haskell-servant.github.io/
03:12:18 <lambdabot> Unknown command, try @list
03:12:28 <Axman6> <3 Servant
03:12:50 <Axman6> we're running a couple of small services with Servant and it's been fantastic
03:12:59 <lwm> actually, I haven't used it. I want to build an API soon though, I am assuming it is as good as the docs make it look
03:13:02 <lwm> anyone got experience?
03:13:16 <lwm> oh right, Axman6, cool
03:13:22 <ilmig> thanks for your opinions, I will have a look at your suggestions :)
03:13:34 <lwm> tell me more ... how fantastic?
03:14:25 <Axman6> so fantastic
03:15:04 <newpm> thanks everyone!
03:18:17 <ilmig> Happstack seems to have the most extensive tutorials and documentation, maybe I'll start with that...
03:19:05 <tdammers> happstack is nice
03:21:10 <ilmig> with Servant one would probably create an API first and then create a web client for that API as a second step?
03:21:41 <ilmig> that would be an excuse to learn one of the compile-to-javascript libraries
03:21:43 <ilmig> or elm
03:23:35 <tsahyt> Is it possible to exempt one particular type from a polymorphic type signature?
03:23:57 <tdammers> no
03:24:11 <tdammers> what would be the use case for that?
03:24:54 <justintv90> Hi forks
03:24:56 <justintv90> I have a question, please help me. What sort of database is best fit for storing login information ( username, email, hashed password) ?
03:25:13 <tdammers> justintv90: anything, really
03:25:24 <tdammers> justintv90: can't say without further requirements
03:25:28 <justintv90> best fit please tdammers
03:25:46 <alpounet> ilmig: yes, absolutely. there's a tutorial for that on the website
03:25:49 <justintv90> im choosing a database for login management servicde
03:25:52 <tdammers> there are many options that are equally fit
03:25:54 <dramforever> ilmig: haskell can be compiled to javascript
03:25:57 <dramforever> ghcjs
03:26:05 <alpounet> ilmig: https://haskell-servant.github.io/client-in-5-minutes.html
03:26:08 <tdammers> it really depends on further requirements
03:26:12 <dramforever> although it's a bit bit bloated, IIUC
03:26:18 <tsahyt> tdammers: I'm exploring what I can do with phantom types. I've got a function cholesky :: Matrix c Double -> Matrix Cholesky Double, but ideally I'd like something like Matrix (all but Cholesky) Double -> Matrix Cholesky Double. The phantom parameter is there to ensure that I can't pass matrices that aren't decompositions into the back substitution
03:26:55 <dramforever> why don't you do it the other way around?
03:27:07 <tdammers> tsahyt: "ensure that I can't pass matrices that aren't decompositions" - how about you turn that into "ensure that I can only pass matrices that are decompositions"
03:27:25 <tdammers> i.e., instead of blacklisting the undesired situation, whitelist the desired situation
03:27:36 <tdammers> otherwise you'll be trying to prove a negative
03:28:39 <tsahyt> tdammers: I'm not worried about what I can do with the result of this function, but what I can pass into it. In particular, I want to avoid calling the function with a decomposition. I'd have to make something like matrices that explicitly aren't decompositions for that.
03:28:40 <ilmig> thanks, learning Servant will probably be quite useful, as I'll also learn how to write nice clients againts arbitrary web APIs with additional type checking
03:29:22 <alpounet> yep, it's only last week that i first saw someone use this to write a package for querying some API 
03:29:41 <alpounet> most folks just use it to test their own webservices, as far as i know
03:30:06 <liste> tsahyt you could have class NotCholesky, but it could get wieldy
03:30:33 <liste> or a closed type family
03:30:42 <tsahyt> liste: Yep, I just thought that there was some way to tell the type checker not to unify the variable with one particular type
03:31:46 <ilmig> Servant doesn't seem to include a solution for data persistency. What would you recommend as ORM? (do you still call it ORM in haskell?)
03:31:56 <lunaris> Hey all; when using lenses, do people still export constructors/record fields? And if so, do you find the resulting code (or possibility thereof, e.g. involving underscores and non-underscored) ugly?
03:32:09 <lunaris> ilmig: I use Servant and persist using postgresql-simple and hand-rolled queries.
03:32:27 <lunaris> Inside a custom "PG" monad that abstracts the DB operations.
03:32:44 <danilo2> Hello guys! I'm looking for something like traversable or Foldable but only for the single "layer" of my nested datatype. I mean, If I've got something like data A t = A t t | B , then I want to for example collect both "t" from A instance but do not collect nested ones. Is there any abstraction similar to this idea or we cannot generalise it this way?
03:32:45 <Intolerable> lunaris: i export constructors but not record fields
03:33:34 <lunaris> Intolerable: How do you mean?
03:33:40 <lunaris> I export constructors of my sum types.
03:33:42 <liste> ilmig if you want a more full-featured persistence solution, theres Persistent and Opaleye
03:33:52 <lunaris> But have a rule that all sum types must be simple constructors delegating to product types.
03:34:39 <lunaris> danilo2: Scrap your boilerplate (SYB) does things like this, and there is also I believe uniplate/multiplate (a good deal of which can be done with lens too, though I'm not super familiar with that part of lens).
03:34:42 <Intolerable> you mean like having a bunch of makeLens 'X things?
03:35:11 <alpounet> ilmig: well, persisting data is something you do inside request handlers, servant doesn't want or need to know about what you do in there, its very purpose is to let you care only about those things you do in the handlers.
03:35:29 <alpounet> it can work with pretty much any database library of your choice
03:35:42 <danilo2> lunaris: thanks! I'm looking into it right now :)
03:35:48 <ilmig> alpounet: makes sense, thanks.
03:35:52 <alpounet> ilmig: there is a post about how to work with servant & persistent, fwiw
03:36:19 <liste> if you want nice relational queries for persistent, there's esqueleto
03:38:10 <kqr> alpounet, i may be missing something, but... do you have a link to that post?
03:38:13 <lunaris> Intolerable: So, I define a product type with underscore constructors and then drop in makeLens.
03:38:30 <lunaris> But now I'm realising that some types have invariants I want to maintain and others don't.
03:38:44 <lunaris> For those that don't, part of me thinks "don't worry, just export the constructors".
03:38:51 * hackagebot classy-prelude 0.12.3 - A typeclass-based Prelude.  https://hackage.haskell.org/package/classy-prelude-0.12.3 (MichaelSnoyman)
03:38:54 * hackagebot classy-prelude-conduit 0.12.3 - conduit instances for classy-prelude  https://hackage.haskell.org/package/classy-prelude-conduit-0.12.3 (MichaelSnoyman)
03:38:55 * hackagebot classy-prelude-yesod 0.12.3 - Provide a classy prelude including common Yesod functionality.  https://hackage.haskell.org/package/classy-prelude-yesod-0.12.3 (MichaelSnoyman)
03:38:56 <lunaris> I can recover getters with `to`.
03:39:26 <tdammers> ideally, you'd encode the constraints in the types
03:39:39 <Intolerable> i mean if there are invariants don't export the constructor if that means you can enforce them
03:39:48 <Intolerable> but if i'm doing a basic record-style lens thing
03:40:05 <Intolerable> i'll just export the constructor + all the lenses, no field names
03:40:12 <ilmig> kqr: probably this one? http://www.parsonsmatt.org/programming/2015/06/07/servant-persistent.html
03:40:20 <tdammers> well, unless they're constraints that span across multiple fields, I'd just implement the constraints on the individual fields by making newtypes for them
03:40:58 <kqr> ilmig, thanks, bookmarking
03:41:05 <tdammers> also, something I've gotten into a habit of, for certain kinds of "just data" record types, is to export the construct (without fields), the lenses, and a Default instance
03:41:15 <lunaris> Intolerable: I just worry about readability for larger product types.
03:41:20 <alpounet> kqr: ilmig: yes, that's the one =)
03:41:21 <lpaste_> mettekou pasted “No title” at http://lpaste.net/6451698983545864192
03:41:32 <lunaris> I could newtype all the constructor arguments.
03:41:45 <Intolerable> i assume it's something that classy lenses won't help with?
03:41:46 <mettekou> If there are any people who could resolve the shift-reduce confict in state 94 here, I'd be grateful.
03:41:51 <lunaris> But I already use newtypes liberally and wonder if that's too far.
03:42:14 <lunaris> Intolerable: Well, I mean, if you have something like let x = Con p1 p2 p3 p4 p5 p6 p7 p8 p9 p10
03:42:27 <lunaris> Assuming better names than p[1..10], of course.
03:42:41 <Intolerable> yeah im not sure how to solve that problem
03:44:05 <lunaris> I've been told by many that I should just export raw constructors and worry about abstracting when I need it.
03:44:10 <lunaris> And of course, I do believe in YAGNI.
03:44:18 <lunaris> But I do worry about basic encapsulation.
03:44:44 <tdammers> basic encapsulation, IMO, happens at the module level
03:45:02 <lunaris> tdammers: Sure, but that's where you decide to export constructors or not, right? :)
03:45:06 <tdammers> yes
03:45:10 <tdammers> on a case-by-case basis
03:45:30 <tdammers> sometimes, it makes sense to make the constructor part of the public API of a module, sometimes it doesn't
03:45:50 <lunaris> I agree.
03:46:13 <lunaris> Hence my question about if one should export both constructors and lenses etc.
03:46:26 <lunaris> Because a lot of my types end up with invariants I want to preserve.
03:46:46 <lunaris> And while I've done a lot at the type level, there are still things that I can't really enforce statically, short of adopting full-spectrum dependent types.
03:47:49 <lunaris> So, does one export Con, _conField1 the field accessor and conField1 the lens? Etc.? Because I find that somewhat ugly.
03:47:56 <lunaris> And worry about both cropping up in code.
03:48:07 <lunaris> Basically, I'm a pedant, and I want some semblance of consistency in my codebase.
03:48:17 <lunaris> And where possible, want GHC to be enforcing that, not code review.
03:48:18 <Intolerable> no, just Con and conField1 the lens
03:48:39 <Intolerable> i have some messy stuff for sort-of enforcing that
03:48:57 <Intolerable> eh, no, mine enforces classes vs concrete lenses
03:49:05 <Intolerable> not quite what you want
03:49:10 <lunaris> Intolerable: The problem then becomes that records offer a great deal of readability when constructing larger types.
03:49:19 <Intolerable> yup
03:49:21 <lunaris> Gah, so hard.
03:49:29 <lunaris> I wish I didn't care.
03:49:33 <lunaris> I'd've just written something by now.
03:49:35 <dramforever> also when destructing
03:49:36 <lunaris> And it would be horrible.
03:49:39 <lunaris> But I wouldn't know.
03:49:39 <Intolerable> there's the Con{} & x .~ whatever hacky nonsense
03:49:56 <dramforever> Con{foo=a, bar=b}
03:50:05 <lunaris> Intolerable: Not so great for strict fields though.
03:50:08 <Intolerable> u need fields for that thoug
03:50:11 <Intolerable> yeah exactly
03:50:12 <dramforever> doesn't change if you add more fields
03:50:33 <lunaris> I did discuss an idea of exporting a "builder" type.
03:50:38 <lunaris> Which did have record fields export.
03:50:49 <lunaris> And then an injection smartCon :: ConBuilder -> Maybe Con.
03:50:51 <lunaris> Or similar.
03:50:58 <Intolerable> and then an XBuilder -> Maybe X
03:51:01 <lunaris> Anyone done something like that?
03:51:03 <Intolerable> yeah that seems like a good idea
03:51:16 <lunaris> Or even a prism.
03:51:25 <Intolerable> i've done that once but it was a little awkward
03:51:28 <lunaris> One thing I have is:
03:51:37 <lunaris> newtype NonEmptyThing = NonEmptyThing [Thing]
03:52:01 <lunaris> And I wrote a prism _NonEmptyThingList which encodes the "non-empty" check in the prism.
03:52:05 <lunaris> Awful, awful idea?
03:52:11 <lunaris> Again, I'm just seeking that consistency.
03:52:13 <lunaris> Which may be stupid.
03:52:21 <lunaris> But this codebase will be worked on by several people.
03:52:24 <kuribas> lunaris: IMO hiding the implementation to conserve invariants is a very good idea.
03:52:39 <lunaris> And it'd be nice if things like "we standardise on lenses and prisms so people know how to get at data" could be stated.
03:52:44 <lunaris> Of course, it's case by case in many places.
03:52:58 <lunaris> But like I said, I'm wondering what others have practiced and how successful they've been.
03:53:16 <lunaris> Additionally, I'm paranoid that all these abstractions will cost performance.
03:53:23 <lunaris> Not sure how well lenses are inlined, etc.
03:53:32 <kuribas> Why not data NonEmptyThing = NonEmptyThing Thing [Thing]?
03:53:38 <lunaris> Got to be more expensive than a simple constructor pattern match.
03:53:47 <lunaris> kuribas: Well, the first thing isn't special really.
03:54:05 <lunaris> kuribas: And I like the idea of the newtype being "free" in the runtime sense.
03:54:11 <lunaris> But again, perhaps I'm being stupid/awful here.
03:54:18 <lunaris> Additionally, that's one example of an invariant.
03:54:22 <tsahyt> Wow, phantom types make for some excellent documentation. I never realized that, but now that I enforce this all throughout the project, the types get so much clearer
03:54:28 <lunaris> Another I have is something like data Range a= Range a a
03:54:39 <lunaris> And I want a constructor/prism/whatever that ensures that lower < upper.
03:55:11 <Intolerable> mkRange :: Ord a => a -> a -> Maybe (Range a)
03:55:12 <Intolerable> ?
03:55:19 <lunaris> Intolerable: Yep, I have that.
03:55:32 <lunaris> But then I can't export lenses.
03:55:42 <lunaris> Because they'd allow someone to create a new, invalid range from a valid one.
03:55:54 <lunaris> So I suppose I'd just export read-only accessors for that.
03:56:00 <lunaris> Which could be lifted with to.
03:56:04 <quchen2> Pattern synonyms?
03:56:15 <lunaris> Ooh.
03:56:22 <lunaris> Penny dropping moment.
03:56:26 <quchen2> :-)
03:56:34 <kuribas> lunaris: create a getter only?
03:56:35 <lunaris> Is that horrible though?
03:56:47 <lunaris> kuribas: I thought the official line was "ordinary functions more useful than getters".
03:57:05 <lunaris> quchen2: Pattern synonyms which hide computation (e.g. bounds checks) -- terrible?
03:57:23 <lunaris> Ignore that.
03:57:26 <quchen2> Well if they throw then yes.
03:57:32 <lunaris> Of course you'd only write unidirectional patterns.
03:57:49 <lunaris> Just thinking out loud.
03:58:08 <lunaris> I've only ever thought of pattern synonyms in terms of constructing generic types etc.
03:58:26 <lunaris> But does their existence mean that one can export constructors and then change implementation without breaking code?
03:58:51 <lunaris> Because you just substitute out the constructor for the synonym and shim behind it.
04:00:47 <lunaris> Ok.
04:00:51 <lunaris> I think I have a plan.
04:01:09 <lunaris> Export smart constructors, lenses, pattern synonym destructors and prisms.
04:01:18 <lunaris> That should keep everyone happy.
04:01:30 <lunaris> Back in an hour I expect with reports of new disaster.
04:13:10 <ttt_fff> is parsec naturally slow? i.e. seconds on a 4MB file
04:13:12 <ttt_fff> is that normal?
04:13:26 <ttt_fff> perhaps this is time for attoparsec
04:13:29 <mpickering> depends how you write the parser
04:13:37 <ttt_fff> ther'es no use of 'try
04:13:40 <ttt_fff> there's no backtracking
04:13:49 <ttt_fff> it's just parsing the bible into chapters/verses
04:14:14 <mpickering> if you don't need error messages then probably use attoparsec
04:14:38 <mpickering> How can I install the profiling version of base?
04:14:50 <indiagreen> is there some way to find out how much memory a particular value is taking?
04:15:14 <ttt_fff> you can define a typeclass and implement it :-) /dodges
04:15:25 <ttt_fff> class Size where \n size :: a -> Int
04:15:35 <ttt_fff> instance Size Int where size _ = 8
04:15:53 <ttt_fff> instance (Size a) => Size [a] where size lst = sum (map size lst)
04:15:55 <ttt_fff> etc ...
04:15:57 <liste> but it can be a thunk?
04:16:05 <indiagreen> it can be a thunk, exactly
04:16:24 <indiagreen> sizeOf [1..] shouldn't be ∞
04:16:37 <ttt_fff> it won't return infinity; it'll just infinite loop
04:16:41 <mpickering> indiagreen: Maybe GHC.DataSize?
04:17:35 <indiagreen> mpickering: whoa
04:17:46 <dramforever> indiagreen: with pointers all over it's even har...wait wat?
04:18:20 <dramforever> til it exists
04:18:24 <dramforever> mpickering: ^
04:18:56 <indiagreen> mpickering++
04:19:04 <dramforever> mpickering++
04:19:08 <indiagreen> ttt_fff not++
04:19:50 <ttt_fff> mpickering++
04:19:55 <ttt_fff> indiagreen++ // great question :-)
04:20:11 <indiagreen> fi-ine
04:20:15 <indiagreen> ttt_fff++
04:20:20 <indiagreen> for being surprisingly nice
04:21:10 <ttt_fff> wait wait, doesn't https://hackage.haskell.org/package/ghc-datasize-0.1/docs/GHC-DataSize.html break referential transaprency?
04:21:19 <ttt_fff> i.e. I can now know if something is a thunk or if it is evaluated out ?
04:21:53 <afonso> What is the best and most recommended library for building a command line program?
04:22:08 <ttt_fff> I have heard it's optparse
04:22:12 <afonso> Basically it should handle arguments of many kinds --example -e test
04:22:13 <ttt_fff> but I have not used it myself
04:22:19 <jmcarthur_> ttt_fff: it only gives you this information in IO
04:23:13 <liste> afonso optparse-applicative is popular
04:23:18 <Sindriava> Thor for Haskell would be nice
04:23:27 <dramforever> weird....
04:23:56 <dramforever> I just closed leksah and reopened it and the system module list is gone
04:24:15 <fvgvxmpv1> optparse-applicative is nice
04:24:41 <afonso> liste: can you link me to the package?
04:24:43 <afonso> I can't find it
04:24:52 <liste> @hackage optparse-applicative
04:24:52 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
04:25:42 <dramforever> oh man...
04:26:59 <Sindriava> dramforever: Maybe you launched it in a different environment?
04:27:09 <lambdadoodle> a light weight alternative for django?
04:27:12 <dramforever> I don't think so
04:27:40 <Sindriava> lambdadoodle: If it's lightweight, I don't think it's an alternative for django.
04:28:11 <Sindriava> lambdadoodle: Try scotty or snap
04:28:16 <Sindriava> @where snap
04:28:16 <lambdabot> http://snapframework.com/ #snapframework
04:28:29 <dramforever> man....this leksah thing really needs work
04:29:23 <Sindriava> dramforever: Well, that's what happens when you make an IDE. Either you're JetBrains, or your IDE sucks :D
04:29:39 <dramforever> Sindriava: exactly
04:29:50 <zomg> Sindriava: Visual Studio is the execption to the "not JetBrains" part of that rule ;)
04:29:51 <dramforever> looks like jetbrains made a haskell plugin
04:30:22 <Sindriava> zomg: Well, XCode too. But I don't really count those, since they're too specific
04:30:37 <Sindriava> dramforever: I'm more in favour of making language tools (like ghc-mod). They're waaay more universal
04:30:38 <tdammers> last time I used VS, it did suck pretty hard
04:30:49 <tdammers> not as hard as most of the alternatives, but still pretty bad
04:30:51 <Sindriava> tdammers: Depends on what you used it for
04:31:03 <Sindriava> It had pretty nice autocompletion for C, when I last used it
04:31:35 <dramforever> the autocompletion for leksah seems to be gone with those metadata
04:31:39 <Sindriava> Unlike Vim, where autocompletion is nonexistent O-O
04:31:45 <Sindriava> (╯°□°）╯︵ ɯᴉΛ
04:32:03 <tdammers> I prefer vim's unopinionated dumb autocompletion to the stuff most IDEs do
04:32:15 <tdammers> mind you, I use it for stuff other than programming
04:32:18 <hodapp> tdammers: yeah, I'm not a fan of VS either but I keep having people tell me it's literally the best IDE evar
04:32:24 <keko_> I'd like an auto-completion that has some sense of context
04:32:27 <Sindriava> tdammers: For that, it's good enough, yes.
04:32:30 <tdammers> and because it's dumb and textual, it works reliably and predictable across everything
04:32:48 <Sindriava> tdammers: That's a good point, actually
04:33:11 <hodapp> sigh. When I wrote in Visual Studio professionally I would regularly have its autocomplete crash the entire application
04:33:43 <Sindriava> tdammers: I really just need autocompletion in the sense of "show me the type signature of this function while I'm writing the call"
04:33:53 <tdammers> oh, also, performance
04:33:54 <dramforever> those IDEs by jetbrains are really good
04:34:01 <dramforever> Sindriava ++
04:34:24 <hodapp> Sindriava: Emacs haskell-mode does that, I'm fairly sure
04:34:36 <dramforever> hole driven programming, isn't it
04:34:41 <Sindriava> hodapp: Too bad it doesn't have a text editor :P
04:35:11 <Sindriava> hodapp: Vim can do it too, but it all rests on ghc-mod, which doesn't seem to work *AT ALL* for me :/
04:35:20 <hodapp> hmmmm
04:36:18 <Sindriava> e.g. when I try to get the type of something, it just says "cannot guess type", and when I try it from the command line, it just exits without even producing an exit code
04:37:23 <spaceloop> dramforever: I agree that leksah could be improved in several areas so that's why I started contributing. Please let us know about any issues or suggestions for leksah on the issue tracker, would be greatly appreciated :)
04:37:25 <tdammers> I just use ctags / hasktags and vim's built-in tag stack
04:37:42 <jmcarthur_> what is the recommended lifted bracket these days?
04:37:48 <dramforever> spaceloop: thanks for that =P
04:40:04 <dramforever> hmm....hackage is interesting
04:40:34 <dramforever> I was just thinking "hey is there something for sanitizing html that's not inside a web framework?"
04:40:52 <dramforever> @hackage xss-sanitize -- from yesod
04:40:52 <lambdabot> http://hackage.haskell.org/package/xss-sanitize -- from yesod
04:40:59 <dramforever> thanks for spliting that into a separate package
04:41:55 <tdammers> "sanitize HTML", ugh
04:42:16 <tdammers> only sane approach I am aware of is to distinguish HTML source and raw data at the type level
04:42:27 <dramforever> um...
04:42:48 <liste> but what about rich text without XSS holes?
04:42:52 <dramforever> never mind, just looking around
04:43:01 <dramforever> liste: that's exactly what I'm doing
04:43:06 <dramforever> thanks
04:43:07 <tdammers> liste: what about it? parse it into a safe AST, render it as HTML
04:43:35 <breadmonster> Hey everyone.
04:43:36 <liste> oh, makes sense. so the AST would be sanitized
04:43:38 <breadmonster> Is STM magic?
04:43:53 <Intolerable> no, but it certainly feels like it
04:43:54 * hackagebot cpsa 2.5.3 - Symbolic cryptographic protocol analyzer  https://hackage.haskell.org/package/cpsa-2.5.3 (JohnRamsdell)
04:44:04 <tdammers> liste: the AST would, ideally, be unable to express unsafe HTML
04:44:06 <breadmonster> Intolerable: I can't see some of the source.
04:44:19 <breadmonster> Like the definition of the STM monad.
04:44:24 <breadmonster> So I thought it was magic.
04:44:36 <dramforever> yes it is to some extent
04:44:51 <dramforever> kinda like IO
04:45:04 <breadmonster> dramforever: Oh okay.
04:45:10 <tdammers> or at least, creating AST fragments in an unsafe way would require a conscious effort
04:45:23 <breadmonster> dramforever: is it baked into the runtime?
04:45:37 <dramforever> I dunno anything about the details
04:47:29 <brandnew> ||||| >>>>> WHAT IS YOUR DOMAIN NAME WORTH? Vist >>> www.VALBOT.com <<< FREE DOMAIN VALUATION! or Google >>> VALBOT.com <<< |||||
04:47:41 <liste> ?where ops
04:47:41 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
04:48:29 <brandnew> ||||| >>>>> WHAT IS YOUR DOMAIN NAME WORTH? Vist >>> www.VALBOT.com <<< FREE DOMAIN VALUATION! or Google >>> VALBOT.com <<< |||||
04:48:59 <Intolerable> well that's unpleasant
04:49:36 <liste> who'd google with .com in the query :D
04:49:47 <tdammers> liste: you have no idea
04:50:01 * Intolerable types google.com into google
04:50:15 <tdammers> liste: lots of people use google to open facebook
04:51:59 <lunaris> So, pattern synonyms currently don't play nice with exhaustivity checks.
04:52:18 <lunaris> Does anyone know if I can locally scope an {-# OPTIONS_GHC -fno-warn-incomplete-patterns #-} pragma?
04:52:23 <lunaris> Or achieve that effect?
04:52:33 <lunaris> Or must the entire module be plunged into terror?
04:53:04 <dramforever> add an catch-all case?
04:53:17 --- mode: ChanServ set +o Cale
04:53:22 --- mode: Cale set +b *!*@128.199.158.247
04:53:22 --- kick: brandnew was kicked by Cale (brandnew)
04:53:24 <lunaris> With the ol' error "Impossible"?
04:53:26 --- mode: Cale set -o Cale
04:53:53 <lunaris> Just seems a bit unsightly.
04:58:41 <breadmonster> How do you manually allocate arrays in Haskell?
04:59:11 <breadmonster> Hi merijn 
05:00:35 <djrollins> ?src (concat)
05:00:35 <lambdabot> Source not found. Whoa.
05:00:54 <breadmonster> @src Data.List.concat
05:00:54 <lambdabot> Source not found. It can only be attributed to human error.
05:01:49 <Cale> breadmonster: Arrays of which type? Or do you just want a pointer to some memory?
05:02:06 <breadmonster> Cale: The latter.
05:02:15 <Cale> https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.8.1.0/Foreign-Marshal-Array.html
05:02:40 <Cale> allocaArray is probably the most convenient of those most of the time.
05:02:43 <breadmonster> And I might even need unsafePerformIO *gasp*
05:02:48 <breadmonster> I know it's not best practice, but like I have a legit reason for it.
05:03:17 <Cale> Well, be especially careful.
05:03:21 <dramforever> breadmonster: what about ST?
05:03:41 <breadmonster> dramforever: Nope.
05:03:59 <breadmonster> I'm trying to implement arbitrary precision floating point arithmetic. Good enough reason?
05:04:01 <Cale> You should treat anything you apply unsafePerformIO to as if it will be executed at random many times as the program runs. If that would be okay, then it's probably reasonable to use it.
05:04:39 <dramforever> breadmonster: why manual allocation?
05:04:45 <dramforever> oh wait, are you doing FFI?
05:05:25 <Cale> (even though it won't necessarily be executed much more than you'd expect it to be, compiler optimisations or interactions between multiple threads and such can cause evaluation to occur more than you may expect)
05:05:50 <breadmonster> dramforever: Nope, but I'm considering it.
05:06:07 <breadmonster> I was thinking of doing it purely in Haskell, but something tells me C is a better idea.
05:06:55 <Cale> breadmonster: You might also just consider using Vector or ByteString
05:07:24 <srhb> Cale: Wait, that applies to unsafePerformIO too, not just unsafeDupablePerformIO?
05:07:24 <Unhammer> «Instead of searching for the index of "::" and taking the substrings before and after that index, you would instead use breakOnAll "::".» http://hackage.haskell.org/package/text-0.11.2.0/docs/Data-Text.html – but what if I want both index and substrings, is there a 1xO(n) fn in Data.Text that does that, or would I be better off zipping with [1..] first on regular strings?
05:07:29 <erisco> where can you configure the default prompt for ghci?
05:07:50 <srhb> erisco: :set prompt
05:07:59 <erisco> that doesn't persist
05:08:02 <erisco> I want to set the default
05:08:03 <srhb> erisco: Ah.
05:08:08 <dramforever> ~/.ghci
05:08:25 <srhb> erisco: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci-dot-files.html
05:08:55 * hackagebot frpnow 0.14 - Principled practical FRP  https://hackage.haskell.org/package/frpnow-0.14 (AtzeVanDerPloeg)
05:09:30 <srhb> Cale: Ah, it's documented in the haddocks, too.
05:09:38 <erisco> I tried in my user directory and in appdata/roaming, no avail
05:09:40 <Cale> srhb: Well, unsafePerformIO does perform an extra check/synchronisation to avoid the code from being entered simultaneously in multiple threads.
05:10:20 <erisco> no-go in appdata/roaming/ghc either
05:10:33 <erisco> even though ghci_history is there
05:11:06 <Cale> srhb: But I'm not sure how willing I'd be to totally rely on that check.
05:11:23 <breadmonster> dramforever: I keep getting an error that "*** WARNING: /home/breadmonster/.ghc/ghci.conf is writable by someone else, IGNORING!"
05:11:28 <erisco> ghci.conf, ah ha
05:11:31 <srhb> Cale: Right, and there may be other causes for multiple evaluations I guess
05:11:33 <erisco> you can never guess these things right
05:11:52 <dramforever> dunno how to fix that on windows
05:11:57 <erisco> prompt is now >>> thanks
05:12:04 <Cale> srhb: It's somewhat a matter of principle -- obviously it's preferable not to repeat the action, but if it would break your program, then you should be concerned.
05:12:12 <srhb> Cale: Right, right.
05:13:09 <dramforever> [figurative] I found out that haskell really ruined me
05:13:22 <dramforever> before: this thing could fail, but who cares
05:13:31 <dramforever> after: this thing could fail, better avoid it
05:14:53 <Cale> breadmonster: chmod go-r /home/breadmonster/.ghc/ghci.conf
05:15:11 <Cale> we
05:15:12 <Cale> er
05:15:16 <Cale> -w rather
05:15:18 <Cale> obviously
05:15:56 <dramforever> hey you fooled me
05:16:08 <dramforever> I got messed up....
05:27:06 <erisco> what does associativity in regular expression concatenation mean?
05:27:26 <erisco> what is  a(b(c))  vs  ((a)b)c  ?
05:30:11 <erisco> oh okay, it is when you have disjunction as you might expect
05:30:28 <erisco> it isn't just ab characters it is 'a' an expression and 'b' an expression
05:30:45 <erisco> which can lead to ambiguities such as (.)?a? as documented here https://wiki.haskell.org/Regex_Posix
05:30:48 <erisco> very good then
05:32:02 <erisco> this is why in general it should be more clear when you're meaning meta-variables
05:38:57 * hackagebot holy-project 0.2.0.1 - Start your Haskell project with cabal, git and tests.  https://hackage.haskell.org/package/holy-project-0.2.0.1 (yogsototh)
05:43:22 <erisco> oh, cool, someone ran into the same problem I did... Data.Possible
05:43:49 <lunaris> quchen2: Forgot to say thanks for the idea regarding pattern synonyms BTW. Thanks!
05:43:56 <erisco> I used  Maybe (Maybe a)  but that is fine too
05:44:12 <erisco> just because sometimes you don't care about null vs missing, and join
05:44:36 <erisco> is there a lib for three valued logic?
05:44:45 <erisco> True | False | Undefined ?
05:45:21 <RageYL> can we do something like: mytype <- hGetLine handle >>= read :: MyType
05:45:28 <erisco> I don't know what this logic is normally called
05:45:39 <quchen2> erisco: "ternary"
05:46:00 <erisco> seems there are no ternary logic libs, hm
05:46:10 <erisco> what an opportunity!
05:46:37 <erisco> quchen2, are those common monikers for each value?
05:47:40 <erisco> I guess Unknown rather than Undefined
05:48:49 <quchen2> erisco: A couple of suggestions can be found here: https://en.wikipedia.org/wiki/Three-valued_logic
05:48:57 * hackagebot frpnow 0.15 - Principled practical FRP  https://hackage.haskell.org/package/frpnow-0.15 (AtzeVanDerPloeg)
05:49:26 <erisco> yeah I read that
05:49:45 <erisco> it'd be nice to not have True/False conflict with Bool
05:50:24 <erisco> erm... Fact | Fiction | Unknown  kind of weird maybe
05:50:41 <erisco> basically have to find synonyms
05:50:55 <dramforever> Yes | No | Unknown
05:51:08 <erisco> seems simpler, thanks :)
05:52:04 <raichoo> Yes | No | ¯\(°_0)/¯
05:53:32 <erisco> raichoo, the lulz would be endless
05:53:50 <raichoo> lulz = ¯\(°_0)/¯ : lulz
05:54:14 <erisco> now for operators, I am thinking  +&&, +||, etc
05:54:39 <erisco> I am assuming you're working with booleans and ternary in the same program, just because most programs end up using a boolean something
05:54:49 <erisco> so if you're working with ternary it seems inevitable to conflict
05:55:08 <erisco> the '+' indicates the extra value, but I'd like thoughts
05:55:30 <Intolerable> what's the difference between a ternary thing and Maybe Bool?
05:55:55 <mpickering> what order is `traverse` meant to work in? l-t-r top-down?
05:55:58 <mpickering> or bottom-up?
05:56:24 <erisco> Intolerable, none
05:56:25 <frerich> erisco: You could use 'Maybe Bool' for ternary logic.
05:56:51 <Intolerable> idk how ternary logic works tbh
05:56:58 <dramforever> mpickering: you get to decide for yourself
05:56:58 <dramforever> just follow the laws
05:57:18 <mpickering> shouldn't the laws say something about that
05:57:24 <erisco> Intolerable, well, there are different ways of doing it as per anything
05:57:51 <erisco> but an intuition is that you only give known answers, otherwise you give unknown
05:58:03 <mpickering> otherwise it violates the "write the canonical instance" principle
05:58:15 <erisco> so, Yes +&& Unknown is Unknown, but Yes +|| Unknown is Yes
05:58:20 <Intolerable> > (||) <$> Just False <*> Nothing -- correct?
05:58:22 <lambdabot>  Nothing
05:58:32 <Intolerable> ah ok
05:59:35 <erisco> you get Yes +|| Unknown = Yes from forall x. Yes +|| x = Yes
06:00:20 <kuribas> when :steplocal ends local scope, it acts as :continue, not :step.  Why?
06:00:35 <Intolerable> > True || undefined
06:00:37 <lambdabot>  True
06:00:39 <Intolerable> easy
06:00:39 <kuribas> :step would be much more logical.
06:00:45 <Intolerable> > False || undefined
06:00:47 <lambdabot>  *Exception: Prelude.undefined
06:00:49 <erisco> > undefined || True
06:00:51 <lambdabot>  *Exception: Prelude.undefined
06:00:51 <Intolerable> close enough
06:00:56 <erisco> not as easy you may think :P
06:01:19 <erisco> this is actually a reason for a ternary logic
06:01:44 <Intolerable> tbh i would just wrap Maybe Bool in a newtype and then define operators for that
06:02:17 <erisco> you may expect  undefined || True = True || undefined  but there is no value to assign to 'undefined' (other than ⊥)
06:02:24 <erisco> so the program just crashes
06:02:35 <mpickering> Why would you wrap Maybe Bool in a newtype and not define your old ADT?
06:02:39 <erisco> if you had a ternary logic then you'd say that undefined is Unknown instead, then you can continue
06:02:52 <zipper> hello mpickering 
06:02:59 <mpickering> hello
06:03:12 <kuribas> The behaviour doesn't make any sense... Maybe nobody uses ghci-'s debugger?
06:04:14 <erisco> with Maybe Bool you get a Monad instance, which could be helpful for some situations
06:04:56 <erisco> but the point is to make the use similar to Bool
06:05:04 <breadmonster> Guys?
06:05:13 <Intolerable> hm?
06:05:31 <breadmonster> For any object can you construct a type that only that object inhabits?
06:06:03 <chpatrick> hmm
06:06:12 <chpatrick> I don't think so
06:06:18 <breadmonster> Because then really, there's no difference between objects and types, like types and objects would fit into the same category.
06:06:25 <erisco> breadmonster, that is a confusing question to me... do you mean, for example, a type that can only be constructed with, say, the integers from 1 to 10?
06:06:34 <mpickering> google "which types have unique inhabitants"
06:06:42 <mpickering> related question
06:06:54 <chpatrick> erisco: why not make a Boolean instance for Maybe Bool?
06:06:57 <chpatrick> @hackage boolean
06:06:57 <lambdabot> http://hackage.haskell.org/package/boolean
06:07:12 <erisco> not a package
06:07:15 <chpatrick> err
06:07:17 <chpatrick> @hackage Boolean
06:07:17 <lambdabot> http://hackage.haskell.org/package/Boolean
06:07:26 <chpatrick> thanks conal ;)
06:08:13 <chpatrick> then all the stuff is just liftA2 something
06:08:17 <chpatrick> :t liftA2 (&&)
06:08:18 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
06:09:33 <erisco> > (&&) <$> Just False <*> Nothing
06:09:35 <lambdabot>  Nothing
06:09:37 <erisco> that is wrong
06:09:52 <chpatrick> ah good point
06:10:04 <breadmonster> Is there something in base with the signature Functor f => (a -> Bool) -> (a -> a) -> f a -> f a?
06:10:32 <erisco> I am not sure about that lib, I don't know what counts as boolean operations
06:11:28 <erisco> is the idea to just overload the operators or are there supposed to be some laws with them?
06:11:41 <MarcelineVQ> @hoogle Functor f => (a -> Bool) -> (a -> a) -> f a -> f a
06:11:41 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
06:11:41 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
06:11:41 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
06:11:42 <erisco> conal, can you help explain it to me? thanks
06:12:18 <erisco> I'm not sure that simply overloading operator names is the right thing to do
06:13:12 <chpatrick> I guess the equivalences on bools should hold for Booleans in general?
06:13:58 * hackagebot regex-tdfa-text 1.0.0.3 - Text interface for regex-tdfa  https://hackage.haskell.org/package/regex-tdfa-text-1.0.0.3 (AdamBergmark)
06:22:52 <indiagreen> spent 2 days thinking how to fight a memory leak, reading about pipes and what-not
06:23:02 <cocreature> erisco: imho in instance should be a boolean algebra (https://en.wikipedia.org/wiki/Boolean_algebra_%28structure%29)
06:23:13 <indiagreen> ended up defeating it with 1 strategically placed Data.Text.force
06:23:21 <erisco> cocreature, thanks
06:23:44 <cocreature> but the laws should really be mentioned in the docs
06:23:46 <erisco> I'll see if the laws apply... and hopefully hear back from conal about the lib. I imagine this is what it is based on then
06:23:50 <afonso> Why does this return false: doesDirectoryExist "~/Documents"
06:24:40 <indiagreen> afonso: I think System.Directory doesn't expand ~
06:24:46 <lieven> afonso: ~ is normally expanded by the shell. perhaps doesDirectoryExist doesn't run the string through the shell
06:24:56 <afonso> So how can I solve this
06:25:09 <afonso> getHomeDirectory ?
06:25:25 <afonso> I can do that
06:26:59 <kuribas> indiagreen: neat :)
06:29:34 <afonso> is there a function that replaces if .. then putStrLn "error" else ..
06:29:59 <kuribas> :t assert
06:30:00 <lambdabot> Bool -> a -> a
06:30:44 <afonso> where is assert ?
06:30:45 <kuribas> > let x = 0 in assert (x /= 0) (1/x)
06:30:47 <lambdabot>  *Exception: <interactive>:3:14-19: Assertion failed
06:30:57 <kuribas> @hoogle assert
06:30:58 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
06:30:58 <lambdabot> Control.Exception assert :: Bool -> a -> a
06:30:58 <lambdabot> Control.OldException assert :: Bool -> a -> a
06:31:00 <afonso> I don't want it to trigger an error
06:31:19 <afonso> I want to make an if-then-else, but without making a huge chain
06:31:34 <dramforever> what about the maybe monad?
06:33:50 <darenthis> if I have the following tuples: (Just Person, 10), (Nothing, 3), is there a short way to convert them to Just (Person, 10), Nothing ?
06:33:59 * hackagebot debian 3.88 - Modules for working with the Debian package system  https://hackage.haskell.org/package/debian-3.88 (DavidFox)
06:34:12 <mpickering> what happens to the 3?
06:34:15 <mpickering> ignored?
06:34:17 <darenthis> yes
06:34:55 <mpickering> so if the first field is nothing then you want to ignore it? or?
06:35:18 <erisco> chpatrick, well, I shouldn't say wrong, it is just another definition
06:35:28 <erisco> to really you'd want to move between these different three valued logics
06:35:40 <darenthis> I'm converting (Text, Int) tuples into something else, if the Text isn't recognised it becomes Nothing
06:36:01 <dramforever> can you do this in the maybe monad?
06:36:11 <erisco> so* really
06:37:23 <mpickering> darenthis: Can you please write the type of the function you want to write I don't understand what you want it to do
06:37:31 <dramforever> @pl \(a, b) -> fmap (, b) a
06:37:31 <lambdabot> (line 1, column 19):
06:37:32 <lambdabot> unexpected ','
06:37:34 <lambdabot> expecting expression
06:37:39 <dramforever> @pl \(a, b) -> fmap (\x -> (x, b)) a
06:37:39 <lambdabot> uncurry (flip (fmap . flip (,)))
06:37:46 <dramforever> no, don't do that
06:37:59 <chpatrick> erisco: boolean algebra seems right and I don't think ternary fits
06:38:20 <erisco> doesn't satisfy the laws? well I haven't checked yet
06:38:21 <chpatrick> a or not a = True doesn't hold
06:38:48 <erisco> you're right, yes
06:38:59 * hackagebot scotty-rest 0.1.0.0 - Webmachine-style REST library for scotty  https://hackage.haskell.org/package/scotty-rest-0.1.0.0 (ErlendHamberg)
06:39:42 <erisco> that might be true in all ternary logics, what do you think
06:39:45 <darenthis> mpickering: (Text, Int) -> Maybe (Person, Int). If the text is unrecognised, I want Nothing. I have a Text -> Maybe Person function already.
06:39:47 <erisco> there are a finite number of possibilities
06:41:03 <mpickering> I would probably write that as (t, n) = (,n) <$> foo t
06:41:09 <mpickering> with TupleSections
06:41:19 <supki> :t _1 :: (text -> Maybe person) -> (text, Int) -> Maybe (person, Int)
06:41:20 <lambdabot> (text -> Maybe person) -> (text, Int) -> Maybe (person, Int)
06:41:32 <dramforever> hmm...hey
06:41:49 <dramforever> abusing lenses again...
06:42:02 <darenthis> ohh, nice :)
06:42:11 <dramforever> darenthis: do you know lens?
06:42:43 <darenthis> dramforever: not well. More of a nodding acquaintance
06:43:01 <breadmonster> dramforever: Is ghc smart enough to optimize away the error accumulator in Kahan summation?
06:43:22 <OutlawStar> question: I'm running the profiler for haskell and I noticed there is a function foo and then foo has another entry called "foo.\". What does that second entry mean?
06:44:26 <dramforever> breadmonster: dunno
06:44:36 <breadmonster> lemme try implementing.
06:44:42 <breadmonster> umm, is ghci the same as ghc?
06:45:04 <malorie> hi all. I'm trying to figure out how to build tree-like structures using a free monad, but I can't seem to find the right definition to make it work. that's what I have so far: http://lpaste.net/139561
06:45:18 <dramforever> breadmonster: you should check the core generated by ghc
06:45:41 <dramforever> like using the flag -ddump-simpl or the program ghc-code
06:45:41 <malorie> currently it is evaluating to 'Free Leaf', but I want something like 'Free (Branch (Free Leaf) (Free Leaf))'. how'd I do that?
06:45:52 <chpatrick> malorie: why don't you use Pure for the leaves?
06:45:55 <dramforever> but IIRC ghc doesn't do aggresive numeric optimizations
06:46:08 <breadmonster> dramforever: Can I compile just one function? Or do I have to write a Main and so on?
06:46:20 <dramforever> you can compile just one module
06:46:32 <dramforever> just give it a Capitalized.hs filename
06:46:38 <malorie> chpatrick: wow, that did the trick!
06:46:43 <dramforever> and use module Capitalized where ...
06:46:53 <dramforever> so that ghc doesn't think it's a main module
06:56:28 <erisco> :t (+~)
06:56:29 <lambdabot> Num a => ASetter s t a a -> a -> s -> t
06:56:42 <erisco> lens, stealing all the names
06:57:19 <dramforever> :t confusing -- isn't it
06:57:20 <lambdabot> Applicative f => LensLike (Data.Functor.Kan.Rift.Rift (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
06:57:54 <erisco> :t isn't -- it confusing?
06:57:55 <lambdabot> APrism s t a b -> s -> Bool
06:58:23 <nolrai66> >.<
06:59:12 <Intolerable> :t don't -- hurt me, dont hurt me no more
06:59:13 <lambdabot> Not in scope: ‘don't’
06:59:16 <Intolerable> awwwww
06:59:27 <Intolerable> @let don't x = return ()
06:59:29 <lambdabot>  Defined.
07:06:43 <moop> @dnot'
07:06:43 <lambdabot> Unknown command, try @list
07:06:46 <moop> @don't
07:06:47 <lambdabot> Unknown command, try @list
07:08:02 <dramforever> @botsnack
07:08:02 <lambdabot> :)
07:08:56 <Xnuk> @let doesn't = don't
07:08:57 <lambdabot>  Defined.
07:09:01 * hackagebot frpnow 0.16 - Principled practical FRP  https://hackage.haskell.org/package/frpnow-0.16 (AtzeVanDerPloeg)
07:13:10 <bennofs> Regarding FRP, is there any research on a simpler-to-implement formulation of FRP?
07:14:24 <en590_> hey all I'm not specifically learning haskell but could anyone reccomend a resource for learning about functional programming in general?
07:14:33 <en590_> im learning clojure right now
07:14:40 <srhb> en590_: The cis194 course is great but Haskell specific.
07:14:53 <bergmark> en590_: SICP
07:16:13 <tsahyt> en590_: Thinking Functionally with Haskell, and Pearls of Functional Algorithm Design, both by Richard Bird. Both use Haskell, but the latter isn't specific to the language.
07:17:34 <tsahyt> en590_: Although you might want to have a working knowledge of FP for the pearls book already. But it's a great read and really highlights the strengths of FP, and why equational reasoning is so awesome
07:18:47 <en590_> thank you for the resources
07:19:11 <MarcelineVQ> sec..
07:19:56 <MarcelineVQ> en590_: not a teaching guide, but a good primer http://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf
07:29:19 <tsahyt> When implementing a face-vertex mesh in Haskell, is there any better way than to handroll some type of reference system? A mesh would be something like Mesh (Vector Face) (Vector Vertex), with data Face = Face (ID Vertex) ..., and data Vertex = Vertex (V3 ..) [ID Face].
07:34:02 * hackagebot hruby 0.3.1.6 - Embed a Ruby intepreter in your Haskell program !  https://hackage.haskell.org/package/hruby-0.3.1.6 (SimonMarechal)
07:35:43 <aweinstock> tsahyt: the "tying the knot" method for lazy/self-referential structures, if it's a create-once-then-lookup sort of thing
07:36:18 <aweinstock> tsahyt: (Data.Map.Map Integer a) otherwise (probably)
07:42:14 <tsahyt> aweinstock: For Map Int a, I still use explicit reference numbers in the vertices and faces, right?
07:42:18 <catgocat> What is the proper way of structuring Haskell projects? I am looking for a directory / structure set
07:42:46 <tsahyt> catgocat: https://wiki.haskell.org/Structure_of_a_Haskell_project#Directory_Structure
07:43:20 <aweinstock> tsahyt: yes
07:43:48 <aweinstock> tsahyt: (or did I misunderstand, and that's what you're already doing?)
07:44:05 <catgocat> tsahyt: the app/src/App will become something like myapp/src/App or myapp/src/MyApp ?
07:44:19 <catgocat> I wanted an actual case where this structure is applied
07:44:41 <tsahyt> aweinstock: I've been using it like this in the past, but I'm just faced with another problem of mesh representation so I was wondering whether there's a better way. The reference way works wonderfully, but it feels a bit dirty.
07:44:48 <Intolerable> https://github.com/intolerable/api-builder ?
07:45:03 <Intolerable> (catgocat)
07:45:38 <Intolerable> tbh 90% of haskell packages u can find on github will look similar
07:46:23 <aweinstock> tsahyt: you might be able to do actual mutable-pointer stuff with STRef/IORef, but I'm not sure whether that's even dirtier
07:46:46 <tsahyt> catgocat: For code that compiles to an executable, the prefix you use for your modules doesn't really matter. app/src/App is the root directory for all modules prefixed as App.*. When you're writing a library, you should chose some appropriate naming of course.
07:48:21 <tsahyt> aweinstock: I think that's actually dirtier. I prefer the relational database approach to it with explicit integer IDs. Haskell also allows me to use phantom types to encode what kind of object the ID points to.
07:58:20 <catgocat> tsahyt thanks
07:59:03 * hackagebot frpnow 0.17 - Principled practical FRP  https://hackage.haskell.org/package/frpnow-0.17 (AtzeVanDerPloeg)
08:24:04 * hackagebot github-types 0.2.0 - Type definitions for objects used by the GitHub v3 API  https://hackage.haskell.org/package/github-types-0.2.0 (wereHamster)
08:29:14 <notdan> @seen tulcod
08:29:14 <lambdabot> TUL(Od
08:29:17 <notdan> eh
08:30:54 <nolrai66> @help seen
08:30:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:31:10 <nolrai66> Hmm.
08:31:15 <nolrai66> @help pl
08:31:15 <lambdabot> pointless <expr>. Play with pointfree code.
08:31:27 <nolrai66> I guess seen doesn't have a help entry.
08:32:06 * notdan shrugs
08:32:13 <notdan> I might have confused this command with something else
08:32:31 <nolrai66> @help last
08:32:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:32:39 <nolrai66> @last tulcod
08:32:40 <lambdabot> No module "tulcod" loaded
08:32:44 <nolrai66> ...
08:33:56 <nolrai66> @pl f a b = a . b . f a (b . b)
08:33:56 <lambdabot> f = fix (liftM2 (.) (.) . (ap (.) .) . flip flip (join (.)) . ((.) .))
08:34:05 * Intolerable screams
08:34:25 <nolrai66> @pl f a b = a (f b a)
08:34:25 <lambdabot> f = fix (ap (.) . flip)
08:34:58 <Sindriava> Rule of thumb: If you can't pointfree it manually, don't pointfree it
08:35:43 <Sindriava> @help quote
08:35:43 <lambdabot> quote <nick>: Quote <nick> or a random person if no nick is given
08:35:57 <Sindriava> @quote lambdabot
08:35:57 <lambdabot> lambdabot says: ghc-6.5: panic! (the `impossible' happened, GHC version 6.5):        checkPr...
08:37:42 <bennofs> wow, just running @quote in lambdabot query is fun
08:37:43 <indiagreen> nolrai66: there's no “seen”
08:39:28 <Intolerable> @quote intolerable
08:39:29 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
08:39:33 <Intolerable> aww
08:40:19 <aweinstock> bennofs: int-e posted the database (gzipped) a while ago
08:41:05 <aweinstock> bennofs: http://int-e.eu/tmp/lambdabot/quote
08:41:20 <bennofs> aweinstock: cool, thanks
08:41:25 <bennofs> @quote bennofs
08:41:25 <lambdabot> #haskell says: < Fuuzetsu> why does this channel always eventually end up at co-jokes? < Iceland_jack> Fuuzetsu: What do category theorists drink on a cold winter night? < mm_freak> Fuuzetsu: because we turn cotheorems into ffee < Iceland_jack>     A: Hot a. < hpc> Fuuzetsu: it's the logical course of co-nversation < bennofs> because we all love
08:41:25 <lambdabot> CO-mputer science :) < Fuuzetsu> I immediately regret my decision to say anything.
08:41:27 <bennofs> :o
08:42:59 <aweinstock> @quote Cale religion
08:42:59 <lambdabot> Cale says: desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal object in the category of religions and theomorphisms.
08:44:05 * hackagebot clckwrks-theme-clckwrks 0.5.1 - simple bootstrap based template for clckwrks  https://hackage.haskell.org/package/clckwrks-theme-clckwrks-0.5.1 (JeremyShaw)
08:49:30 <ironChicken> i'm trying to use peekArray on a member of a struct declared like this: const SomeType **parameters. the same struct also includes an: int parameterCount, so I'm supplying that as the first argument to peekArray. but i'm getting segfaults when it tries to peek each of the elements in the foreign array.
08:49:54 <ironChicken>  the peek implementation being applied to each element is my own. if i get it to print the address it's peeking, the first one is different to the address i'm supplying to peekArray
08:50:38 <f-a> I am programming a simple text based game. As input, I am using `getChar`. Is there a, mh, non-blocking version of it?
08:51:25 <Intolerable> mh?
08:51:30 <srhb> f-a: Are you on Windows? Then no, not really.
08:51:48 <srhb> Also I'm guessing you mean a non-buffered version.
08:51:54 <f-a> srhb: hello again. I am on linux, but I would like the game to be cross-compilable.
08:52:11 <srhb> f-a: hSetBuffering stdin NoBuffering is sufficient on Linux.
08:52:20 <srhb> iirc it's still utterly broken on Windows, but you can hack around it.
08:52:46 <srhb> f-a: http://stackoverflow.com/a/13370293/288913
08:56:17 <ocramz> hi there; anybody with some FFI experience? I have some C functions with a (... , void* a) signature, which internally address vectors or vectors of vectors etc. How may I represent this situation on the Haskell side? By making separate implementations, one for Vec a's, one for Vec (Vec a) etc. ?
08:57:21 <johnw> ocramz: on the C side, how do you distinguish them?
08:57:27 <nshepperd> you can implement non-blocking console input given non-buffered input by spinning up a thread devoted to reading input and communicating with an MVar or something
08:57:35 <f-a> srhb: probably I meant another thing, let's see if I can explain myself better. I am trying to write a function like pollKeyboard :: IO [Something] which gives me the keypresses happened from the last pollKeyboard call until now.
08:58:02 <srhb> Oh.
08:58:11 <ocramz> johnw: what do you mean? 
08:58:12 <geekosaur> so the thread writes them to a Chan and you can pull them from the Chan?
08:58:31 <ocramz> johnw: by usage, I'd say; they are completely "polymorphic"
08:58:43 <johnw> ocramz: in C, you have a void * to accept many types; how do you know which type you're dealing with in runtime in C?
08:59:18 <ocramz> johnw: afaict, the library does not make this distinction. This is why void* is a horrible mistake
08:59:18 <srhb> f-a: Yeah, having a thread forever reading and stuffing into a chan should suffice then. Your polling function just empties that.
08:59:28 <ocramz> johnw: I just want to learn how to hide it
09:00:14 <ocramz> johnw: I thought of Vector because it has a Storable instance
09:01:09 <f-a> thanks srhb , I'll look into threading
09:06:07 <srhb> f-a: In fact I'd probably go with MVar as nshepperd suggested initially as well, and then use some text type that has a good append. That'll give you the most of the functions you need. :)
09:06:43 <srhb> (ie tryReadMVar seems to be exactly what you want.)
09:07:14 <nitrix> Hi, I'm slowly becoming a Haskell fanboy, I'm sold on most of the aspects of the language, except the tooling. My situation yesterday trying to compile a dependency that uses a C library on windows made me swear my entire vocabulary.
09:07:22 <srhb> Er, take*
09:07:40 <nitrix> I had an error about a missing `ssh2` library but I cannot find where to install that on the haskell platform (on windows).
09:07:52 <f-a> oh I haven't seen nshepperd suggestion, that looks good, thanks
09:08:59 <srhb> nitrix: Are you using mingw?
09:09:02 <nitrix> Can I do a make/make install from whitin Haskell Platform's MinGW ?
09:09:09 <geekosaur> nitrix, I would suspect most of your problem there is getting C libraries for Windows... http://stackoverflow.com/questions/22144893/install-libssh2-dll-on-windows maybe
09:09:20 <nitrix> srhb: I think that's what the platform is using, from the folder structure (I got curious).
09:09:20 <ReinH> nitrix: if it's a C library, it won't be on installable via hackage
09:09:30 <ReinH> you need to figure out how to / if you can install it on windows
09:09:33 <geekosaur> oh, no
09:09:40 <nitrix> ReinH: Correct, that's the problem I'm having. I want to install it but the documentation of "how" is terse.
09:10:24 <nitrix> I already compiled it, I have a fancy static library file as a result... but where do I put that?
09:10:37 <nitrix> I obviously cannot change the dependency's cabal file.
09:10:38 <geekosaur> that's always the problem on windows :/
09:10:57 <geekosaur> unix has standard places
09:11:56 <nitrix> geekosaur: Well, the platform uses MinGW, it probably has a standard folder within that environment? I tried copying it in mingw/lib and mingw/include, no luck :/
09:13:10 <ocramz> nitrix: /lib is for dynamic libs; do you have .o or .so ?
09:13:32 <geekosaur> er.
09:13:33 <nitrix> I have .a and .la
09:13:39 <geekosaur> windows. I'd expect .dll not .so
09:13:46 <geekosaur> also "fancy static library"
09:13:46 <ocramz> mingw
09:13:56 <nitrix> There's an .la.dll, but I'd prefer if static.
09:14:39 <ReinH> er
09:15:42 <geekosaur> my (non)familiarity with windows isn't really sufficient to say where to put it though
09:15:44 <nitrix> (actually .dll.a, my bad. .a, .la, .dll.a)
09:16:09 <nitrix> All was great, until yesterday when I had to use windows :(
09:16:12 <geekosaur> (someday I will sort out something vaguely resembling a windows testbed. I do have some play windows installs scattered around...)
09:17:12 <ReinH> geekosaur: vm?
09:17:33 <ocramz> nitrix: so these are unix dynlibs
09:17:46 <geekosaur> ocramz, what?
09:18:11 <geekosaur> .a is a static library
09:18:19 <ocramz> sorry, you're right
09:18:46 <ocramz> but I meant, all the build is unix-like
09:18:54 <ocramz> everything was installed within mingw
09:19:03 <ocramz> "compiled with mingw"
09:19:08 <nitrix> But yeah, unix-like, because the platform uses mingw, so I figured that'd be necessary.
09:19:52 <nitrix> I found a precompiled version on mingw and then, googled for hours, then went to bed like a sad panda.
09:20:10 <ocramz> so what exact error message are you getting? or you're just not sure of where to put the ssh static library?
09:20:53 <nitrix> ocramz: I don't understand your "or", the former isn't a question that can be answered affirmatively...
09:21:11 <ocramz> answer either
09:21:15 <nitrix> ocramz: But yes, the latter, and let me find the relevant error...
09:22:15 <nitrix> cabal install --only-dependencies -v
09:22:43 <Welkin> how can I fold over a stream of values and then send it to stdout using conduit?
09:22:51 <nitrix> * Missing or bad header file: include/simplessh/types.h,      * Missing C library: ssh2
09:23:00 <johnw> Welkin: that's pretty much what conduit is, so can you be more specific?
09:23:13 <ocramz> ok so it looks like you need sources as well
09:23:15 <Welkin> C.sourceFile file $$ C.foldl1 (<>) =$ C.print
09:23:18 <ocramz> the header
09:23:19 <nitrix> The dependency has cbits, and that header #include <libssh2.h> which is inexistant.
09:23:35 <johnw> Welkin: ahh
09:23:37 <Intolerable> i thought the recommendation was to only use =$= now?
09:23:52 <johnw> Welkin: I think you'd do this: C.print =<< (C.sourceFile file $$ C.foldl1 (<>))
09:24:01 <johnw> that is, in conduit a fold is a sink
09:24:14 <Intolerable> should you really be using foldl1?
09:24:20 <johnw> you deal with the resulting final value the same way you'd work with any value in Haskell
09:24:25 <Intolerable> especially if you know you have a neutral element
09:24:54 <suppi> Intolerable, what should one use instead of foldl?
09:24:56 <heath> hey i'm trying to recall this site i found that allows you to trian in haskell among other languages. i think it used terms like "guru" and "master" IIRC
09:25:06 <Intolerable> foldl vs foldl1
09:25:08 <heath> it's free to use, does anyone recall such a site?
09:25:18 <Intolerable> since its using (<>), you can just use mempty as the starting element
09:25:26 <nitrix> heath: project euler?
09:25:35 <L8D> why did anyone think <> was a good infix operator
09:25:54 <nitrix> L8D: Because the mathematical notation looks very similar.
09:26:00 <L8D> heath: codewars.com
09:26:07 <heath> nitrix: it's not project euler, hacker rank, codewars, code academy, or exercism
09:26:11 <Intolerable> (<>) is fine
09:26:13 <L8D> touche
09:26:29 <Intolerable> there are definitely some questionable operators in places
09:26:33 <Intolerable> but <> is not one of them
09:26:42 <L8D> then the real question is, why did anyone choose <> over /= for not-equal in SQL
09:26:47 <Welkin> I still get an error
09:26:54 <geekosaur> L8D: BASIC?
09:27:00 <Intolerable> maybe it should be for semigroup, not monoid, but that's a separate discussion
09:27:16 <Welkin> it is expecting ConduitM but I am giving it Maybe a -> m b
09:27:23 <Gurkenglas> Where is C.foldl1 as opposed to foldl1 defined?
09:27:23 <L8D> heath: CodeWars uses 'Guru's and 'Master's and supports a plethora of languages now
09:28:01 <hiptobecubic> I'm a big fan of codewars
09:28:09 <ocramz> nitrix: Re: The dependency has cbits, and that header #include <libssh2.h> which is inexistant.
09:28:29 <heath> L8D: i'm aware, it's a great resource. it's not the one i'm after though
09:28:54 <L8D> heath: what kind of exercises did it have?
09:28:57 <heath> L8D: wait!
09:29:00 <nitrix> ocramz: http://hub.darcs.net/thoferon/simplessh/browse/include/simplessh/types.h
09:29:02 <nitrix> ocramz: Correct.
09:29:09 <heath> hah, code wars, that's it :)
09:29:10 <heath> hah
09:29:37 <heath> L8D: i was thinking code combat when you said code wars
09:29:46 <heath> thank you sir, this will be useful later today
09:31:54 <Welkin> No instance for (Control.Monad.Trans.Resource.Internal.MonadResource
09:31:54 <Welkin>                        IO)
09:31:55 <Welkin>       arising from a use of ‘C.sourceFile’
09:31:57 <Welkin> what????
09:32:08 <Welkin> that sounds very wrong
09:33:21 <L8D> Welkin: the MonadResource monad can't do IO
09:33:26 <L8D> I mean
09:33:33 <L8D> IO doesn't implement MonadResource
09:33:50 <L8D> Welkin: C.sourceFile performs IO
09:33:55 <L8D> Welkin: you need to lift the IO
09:34:29 <L8D> Welkin: try: liftIO $ C.sourceFile ...
09:36:50 <Welkin> why???
09:36:55 <Welkin> in every conduit example this just works
09:42:08 <glguy> Welkin: In the example in the conduit documentation you have to use 'runResourceT' in conjunction with 'sourceFile'
09:42:48 <glguy> The other examples use 'sourceList' which doesn't need resource management
09:45:41 <Welkin> but my output doesn't have type ResourceT m a
09:45:58 <Welkin> it is :: IO a
09:47:10 <Welkin> conduit is still quite confusing to me
09:47:48 <Welkin> where do I use runResourceT?
09:47:55 <Welkin> on the output of the entire conduit pipeline?
09:49:07 <glguy> Yeah, I think you run it on the "outside". (I'm also not a conduit user, but I've been exposed to a bit of it)
09:49:46 <Welkin> that doesn't work either
09:50:12 <glguy> Well, paste something to lpaste if you want extra eyes on it.
09:54:08 * hackagebot hackage-security-HTTP 0.1.0.1 - Hackage security bindings against the HTTP library  https://hackage.haskell.org/package/hackage-security-HTTP-0.1.0.1 (EdskoDeVries)
09:59:09 * hackagebot hackage-security 0.2.0.0 - Hackage security library  https://hackage.haskell.org/package/hackage-security-0.2.0.0 (EdskoDeVries)
09:59:11 * hackagebot vector-fftw 0.1.3.3 - A binding to the fftw library for one-dimensional vectors.  https://hackage.haskell.org/package/vector-fftw-0.1.3.3 (BenGamari)
09:59:23 <orion> hmm, so given a Wai Request, what's the best way to determine (purely) if the remote host is equal to 127.0.0.1? My first thought was to extract the SockAddrInet HostAddress and see if it was equal to 2130706433, but that seems kind of clunky.
10:01:08 <aweinstock> > 0x7f000001 -- orion
10:01:09 <lambdabot>  2130706433
10:01:29 <aweinstock> (makes it slightly clearer than a decimal literal)
10:02:31 <orion> aweinstock: Ah, cool. Do you think there's pretty much no better way than what I've just described?
10:02:33 <kadoban> There must be a converter function in a library somewhere, right?
10:03:55 <Gurkenglas> (Welkin, if C.foldl1 is just the standard foldl1, you probably want fold :: (Foldable t, Monoid m) => t m -> m)
10:04:09 * hackagebot gitit 0.12.0.1 - Wiki using happstack, git or darcs, and pandoc.  https://hackage.haskell.org/package/gitit-0.12.0.1 (JohnMacFarlane)
10:04:11 * hackagebot hackage-repo-tool 0.1.0.0 - Utility to manage secure file-based package repositories  https://hackage.haskell.org/package/hackage-repo-tool-0.1.0.0 (EdskoDeVries)
10:05:34 <aweinstock> > let f (a,b,c,d) = foldr (+) 0 $ zipWith shiftL [d,c,b,a] [0,8..] in f (127, 0, 0, 1)
10:05:36 <lambdabot>  2130706433
10:06:03 <aweinstock> orion: ^
10:07:03 <Welkin> Gurkenglas: it is not. foldl1 :: Monad m => (a -> a -> a) -> Consumer a m (Maybe a) 
10:07:07 <lingxiao> hey all 
10:07:11 <lingxiao> I'm playing with the conduit library
10:07:18 <Welkin> lingxiao: yes, so am I
10:07:29 <frerich> aweinstock: Of course, 'foldr (+) 0' could be called 'sum' :-)
10:07:31 <aweinstock> orion: this is only for detecting exactly 127.0.0.1 though, I think there might be other ways to for an IP to refer to localhost (via DNS)
10:07:31 <lingxiao> and what function do I call to run a ConduitM a b m c type?
10:07:36 <Welkin> and it is starting to make me angry
10:07:37 <aweinstock> frerich: oops
10:07:54 <lingxiao> for example in kmett's coroutine library the function is just run
10:08:00 <lingxiao> if i recall 
10:08:40 <edwardk> i have a coroutine library?
10:08:42 <lingxiao> for example I might have m = sourceList [1..10] $= mapM_ putStrLn
10:08:43 * edwardk checks
10:09:05 <Gurkenglas> Welkin, googling for that type declaration, fold :: (Monad m, Monoid a) => Consumer a m a is 3 above :D
10:09:05 <lingxiao> sorry I meant machines
10:09:08 <edwardk> =)
10:09:33 <lingxiao> lol ... : - \
10:10:16 <frerich> orion: There are various packages which have this function, e.g. 'ip4FromOctets :: Word8 -> Word8 -> Word8 -> Word8 -> IP4' in network-ip or 'toIPv4 :: [Int] -> IPv4' in iproute. I think I wouldn't even bother using any extra package though :-}
10:12:30 <johnw> Welkin: what's the present cause of your anger?  (sorry, I had stepped away to eat some breakfast)
10:12:37 <frerich> orion: I'd just go for 'localhost = 0x7f000001 :: HostAddress' and be done with it, i.e. rely on the variable name to be pretty. :-)
10:12:57 <glguy> orion: You can use: inet_addr "127.0.0.1"
10:13:01 <orion> glguy: IO
10:13:08 <mauris_> hey, i have a lambda like (\(-:) n -> 1 -: 2 -: 3 -: n)
10:13:11 <kadoban> frerich: That's pretty terrible, IMO.
10:13:19 <kadoban> It doesn't get much more magic-number than that.
10:13:21 <mauris_> it's broken, of course, because i can't specify the fixity of the parameter (-:)
10:13:53 <Welkin> johnw: I have no idea what I am doing with conduit
10:14:01 <mauris_> is there some way to put an "infixr" declaration inside the lambda?
10:14:10 <frerich> kadoban: The only thing I'd worry about is the byte order, but *I* would probably recognize 'localhost = 0x7f000001' as plausible.
10:14:11 <monochrom> no
10:14:13 <Welkin> johnw: I understand the trivial examples in the tutorial, but beyond that I don't know how to do anything
10:14:26 <frerich> kadoban: ymmv
10:14:33 <johnw> Welkin: do you understand the problem being addressed by these streaming libraries?
10:14:48 <Welkin> johnw: using constant memory instead of linear
10:15:05 <johnw> well, somewhat
10:15:19 <johnw> also, knowing when/why resources will be released
10:15:44 <johnw> I'm of the opinion nowadays that unless you *need* what conduit offers, start with lazy I/O
10:15:55 <Welkin> the problem seems to be (at the moment) that I cannot get it to compile when setting a file as the source
10:16:05 <johnw> conduit makes some things easier to reason about, at the cost of making other things difficult
10:16:15 <johnw> Welkin: show me your code and error?
10:17:00 <Welkin> johnw: http://lpaste.net/6873948015963406336
10:17:03 <Welkin> it's kind of a mess
10:17:08 <Welkin> but the relevant functions are at the bottom
10:17:15 <johnw> what is the error?
10:18:02 <Welkin> http://lpaste.net/6873948015963406336
10:18:03 <Welkin> updated
10:18:11 <johnw> ah, right
10:18:34 <johnw> ok, as always in everything
10:18:36 <johnw> use type signatures
10:18:39 <mauris_> \c n -> let infixr 9 -:; (-:) = c in 1 -: 2 -: 3 -: n   <-- aha, this seems to work
10:18:44 <glguy> Welkin: fromCsv :: (FromRecord a) => HasHeader -> Conduit ByteString IO a
10:18:47 <johnw> run is not a consumer
10:19:03 <johnw> run is a realized pipeline, so it's type will be ResourceT IO something
10:19:06 <glguy> Welkin: Looks like that is fixing the underlying type to be IO
10:19:22 <johnw> yeah, I think glguy has spotted it
10:19:50 <Welkin> oh my god
10:19:59 <Welkin> I added that to try fixing the problem earlier on
10:20:02 <Welkin> then it snowballed
10:20:12 <Welkin> thanks!
10:24:16 <Welkin> well
10:24:21 <Welkin> it is totally useless
10:24:28 <Welkin> it uses linear memory still O.o
10:25:02 <johnw> Welkin: that's the <> fold1 for you
10:25:10 <Welkin> why?
10:25:14 <johnw> it's funny, but that *exact* question came up on the pipes mailing list last night
10:25:19 <johnw> well, two reasons
10:25:32 <johnw> one, it's a foldl of <>, which means you're paying quadratic time costs and GC'ing a TON of wasted cons cells
10:25:45 <johnw> two, it accumulates the entire thing into memory before delivering the final string
10:25:49 <Welkin> how else should I combine values together?
10:25:57 <Welkin> this is like a + operation, not a ++ operation
10:26:02 <johnw> oh, sorry, wrong <>
10:26:21 <johnw> add some strictness annotatios to your mappend definition
10:26:31 <johnw> Mean (!t1, !n1) `mappend` Mean (!t2, !n2)
10:26:40 <Welkin> the conduit docs say that C.foldl1 is strict
10:26:51 <johnw> otherwise, n1 + n2 will be a thunk referring to two other thunks
10:26:58 <johnw> yeah, but being strict on a tuple does not mean being strict on its members
10:27:14 <johnw> so, my guess is that you're holding all of your input in memory
10:27:22 <johnw> until you finally demand the RowStats in "print"
10:27:43 <johnw> and it's being held because the member of those tuples that you're accumulating with <> are retaining references to each data block
10:27:43 <Welkin> well, that reduced the memory usage by some
10:27:59 <Welkin> ~1200 MB to ~975 MB
10:28:14 <Welkin> hm
10:28:25 <Welkin> once I process a row of the csv though, I want to throw it away
10:28:40 <Welkin> once I have converted the data and combined it with the accumulator
10:28:51 <johnw> if foldl1 is strict, that should be happening, after adding the bangs
10:29:02 <johnw> because no one should be retaining a reference to the previous line...
10:29:50 <johnw> change the definition of Mean
10:29:54 <johnw> to (!Double, !Int)
10:30:00 <johnw> instead of just putting bangs in mappend
10:30:09 <johnw> it might be numberColumn that's biting you
10:30:45 <tommd> I'm not really following this converation much but all the buzz words are making me think -XUnboxedTuples
10:30:54 <Welkin> Unexpected strictness annotation: !Double
10:31:03 <dolio> You can't put ! in a tuple.
10:31:03 <tommd> -XBangPatterns
10:31:04 <johnw> tommd: yeah, that could really help here
10:31:08 <johnw> dolio: doh
10:31:10 <dolio> In a type definition.
10:31:11 <Welkin> I already have BangPatterns
10:31:23 <johnw> then Mean will need to be a data type, not a newtype of a tuple
10:31:30 <johnw> data Mean = Mean Double Int
10:31:36 <johnw> data Mean = Mean !Double !Int
10:32:25 <johnw> anyway, to make a long story short: any type you put "a + b" into a tuple, it isn't evaluated until demanded, which means that whatever objects a and b need to be valid will stay resident
10:32:39 <johnw> so we're using bang patterns to force evaluation earlier, by forcing them when foldl1 forces its accumulator
10:36:07 <Welkin> hm
10:36:12 <Welkin> still using 975 MB of memory
10:36:16 <Welkin> thanks for the help
10:36:20 <Welkin> I'll have to come back to this later
10:36:22 <athan> Is `foldrM` wise with ST? Or would there be a more optimal way to statefully fold?
10:36:44 <johnw> sure, just profile it and keep looking for where (a) thunks could be accumulating, and (b) where a thunk might get created that references chunks of the input
10:37:19 <johnw> athan: I generally avoid foldrM, since it can be very surprising
10:38:19 <athan> johnw: Ahh yeah, I keep forgetting it starts at the end. I'm trying to generalize `elemIndex` to Foldable :\
10:38:32 <johnw> it doesn't start at the end
10:38:39 <athan> I think foldlM is the better tool for the job
10:38:45 <johnw> it starts at the beginning, and gives you a thunk referring to the rest of the computation
10:38:52 <athan> johnw: Really? crud
10:38:58 <johnw> it only *seems* like it starts at the end, because often you end up forcing that thunk before examining the current element
10:39:23 <johnw> thus, you start producing effects as you examine the last element, which indeed seems like processing-from-the-end
10:39:26 <athan> ahh okay, because the thunks keep building, you still depend on the accumulator being inserted as the basis at the end
10:39:26 <johnw> this is why I find it confusing
10:39:34 <johnw> the thunks shouldn't be building
10:39:51 <johnw> there is always just that one thunk "rest", referring to the result of foldrM applied to the remainder of the list
10:40:18 <athan> oh! okay
10:40:20 <johnw> so, if you end up *not* forcing rest before processing the current element, then indeed it will produce effects left-to-right as elements are examined
10:40:30 <johnw> this is why I stick with foldM for doing folds over a base monad
10:40:35 <johnw> it always "makes sense"
10:40:54 <athan> johnw: Where foldM is like foldlM, right?
10:40:57 <johnw> yes
10:41:01 <athan> ahh okay :)
10:41:02 <athan> thank you
10:41:22 <johnw> i say this because only yesterday I was undoing some uses of foldrM that were causing me confusion :)
10:41:36 <johnw> (and reversed results)
10:48:11 <lpaste_> athan pasted “Generic `elemIndex`” at http://lpaste.net/139564
10:48:28 <athan> johnw: What do you think? ^
10:49:15 <johnw> interesting
10:49:23 <johnw> trying to write an imperative "find the element" function?
10:49:30 <lpaste_> athan revised “Generic `elemIndex`”: “No title” at http://lpaste.net/139564
10:49:54 <athan> johnw: It's something like that
10:50:09 <johnw> btw, foo >> return Nothing is the same as Nothing <$ foo
10:50:43 <athan> Ahh woah I'll have to squint a bit, thanks :)
10:51:19 <johnw> (well, it's the same in 7.10 at least)
10:52:21 <athan> johnw: Do you think it would be fit for Data.Foldable?
10:53:06 <lpaste_> athan revised “Generic `elemIndex`”: “No title” at http://lpaste.net/139564
10:53:23 <johnw> how is it better than elemIndex x . toList?
10:53:42 <athan> good point :s
10:53:47 <athan> I'm slowly finding this out
10:54:07 <johnw> the toList version could also fuse away a Foldable that you don't use for anything other than finding an element index
10:54:15 <johnw> I don't think the ST version would have that benefit
10:54:39 <athan> woah holy crap, okay then haha
10:54:40 <johnw> (or at the very list, it will fuse out the list produced by toList, making it become just an object iterator)
10:54:56 <johnw> (which I guess is exactly what your ST code is...)
10:55:05 <johnw> who knows, maybe they end up being equivalent
10:55:10 <johnw> that's why reading Core is so fun ;)
10:55:44 <athan> :)
10:59:11 * hackagebot brick 0.2 - A declarative terminal user interface library  https://hackage.haskell.org/package/brick-0.2 (JonathanDaugherty)
11:01:56 <malorie> so, I'm having a data type that is a free monad, and I want to restrict how values of that type are built. e.g., certain constructors can only appear at the head of the construction. is there a way to do this?
11:03:39 <shachaf> Are you sure it's really a free monad, in that case?
11:04:09 <aweinstock> malorie: have two different datatypes, one for the things that can happen at the start, one for the subsequent items, and deal with a (A,[B])?
11:06:19 <malorie> shachaf: if it's not, how would I go about encoding something like that?
11:06:31 <malorie> aweinstock: I was thinking about that, yeah
11:11:55 <Franciman> Hi all
11:12:30 <bitemyapp> Franciman: hi
11:13:08 <Franciman> I'm using Data.HashTable from hashtables lib, and my question is: in terms of speed is it equivalent whether I use the IO version or the ST version?
11:19:21 <shachaf> I wish people wouldn't use haskell@ as a mailing list for discussion.
11:21:53 <tommd> Franciman: I would bet 'yes' but that is also easy to test.
11:22:49 <deepfire> can somebody explain, what is the difference between Reifies and Given (in Data.Reflection) ?
11:23:03 <Franciman> thanks tommd 
11:23:50 <deepfire> 'Given' is said to associate one value per type -- but isn't Reifies limited the exact same way -- aren't we passing a single value to 'reify' ?
11:24:54 <AaronFriel> How would you do this: I have a list of parsers, each of which is polymorphic in an input stream i, an output o, and a return state a. I have the ability to layer parsers on top of each other, such that an upper parser can consume the ([o], a) results of lower parsers
11:25:12 <ttt_fff> in ghci, is it possible to import more than one module on a single "import ..." statement?
11:25:22 <AaronFriel> But the new parser that's produced has a combined data type to represent a composite-state
11:25:27 <ttt_fff> also, is there a way to avoid newlines, by using semicolons or something?
11:25:41 <Franciman> ttt_fff, I think anything that's correct haskell syntax will do
11:25:43 <AaronFriel> I want to write a function that easily takes a [list of parsers] and a [list of initial states]
11:25:51 <AaronFriel> That sounds like hvec territory, yes?
11:26:49 <AaronFriel> The function would layer each parser on top of each other, producing a new parser from their (arbitrarily layered) composition
11:27:08 <AaronFriel> (Not arbitrary in the sense that order doesn't matter, but that it could be 2 parsers, 10 parsers, etc.)
11:27:42 <Bruuuuuuno> http://lpaste.net/139568 This function never end. It should end when it hit the first valid value but for some reason it just continue, why? Also is there a better way of doing what I'm trying to do?
11:29:25 <tommd> Why do you think the first line should terminate?  Sequencing an infinite list of actions sounds like a long process...
11:29:36 <AaronFriel> Bruuuuuuno, your function doesn't end because you are producing an infinite list (your use of `cycle`) then you are applying an operation to each item of the infinite list (sequence)
11:30:04 <AaronFriel> Bruuuuuuno: Sequence does not terminate for infinite lists
11:30:15 <monochrom> ttt_fff: it has to be multiple "import" statements. you can do "import X; import Y" but that's still two statements and I also count it as two lines.
11:30:32 <ttt_fff> monochrom: okay, that is fine, I am sending ghci commands via tmux
11:30:40 <ttt_fff> ; is better than "import X" ENTER "import Y"
11:30:46 <monochrom> yes
11:30:59 <geekosaur> :m + Data.Char Data.Maybe -- works
11:31:20 <monochrom> oh, the :module command that everyone has foresaken
11:31:25 <tommd> :m predates the availability of 'import' in ghci - funny how it's sort of forgotton.
11:31:45 <Bruuuuuuno> oh okay thanks AaronFriel 
11:31:56 <ttt_fff> geekosaur: you're surprisingly helpful when not kickbanning for undefined lists of swear words :-)
11:32:21 <geekosaur> you do enjoy needling, don't you?
11:32:22 <monochrom> oh God, not this again
11:32:37 <tommd> ttt_fff: There is an O(N) method to construct that list.
11:32:45 <AaronFriel> Question for all: Have you worked with HVec, HList? How painful? 
11:32:50 <ttt_fff> https://gist.github.com/anonymous/68c3b511c748d4d18121 <-- can this be reduced to one "tmux" command without the use of ENTER ?
11:32:56 <mauke> is it time to ban ttt_fff again?
11:33:01 <AaronFriel> I think I have a use case for them, but I'm not sure if it's the best way to proceed
11:33:18 <ttt_fff> note that there's an embedded :lookupInit command within the tmux
11:33:43 <AaronFriel> ttt_fff: By undefined lists, are you sure you're not just being banned because his filter evaluated bottom?
11:34:22 <ttt_fff> ideally, I just want ":r \n T.Main.Main \n :lookupInit \n import T.Interp \n '' .... but the ENTER instead of \n make it rather hard to read
11:35:09 <monochrom> ghci's colon commands do not enjoy any merge-lines shorthands
11:35:22 <AaronFriel> ttt_fff: Can you pipe something into GHCi?
11:35:43 <ttt_fff> AaronFriel: that's what I'm using tmux send-keys -t "ghci:0" to .... to pipe stuff into a ghci window inside of tmux
11:35:50 <AaronFriel> ttt_fff: I honestly don't know, but send_keys seems like the hard way to do what you'd normally do with piping things into GHCi
11:35:58 <AaronFriel> ttt_fff: But I don't know if you can pipe into GHCi
11:36:15 <ttt_fff> well, I want a live ghci session, and pipe stuff into it on demand, so I don't think standard | works
11:36:50 <AaronFriel> ttt_fff... If you use file descriptors you can, you should be able to pipe a fd into ghci, then write into the fd elsewhere
11:37:05 <phaazon> edwardk: the phantom function is very interesting
11:37:10 <ttt_fff> hmm, I think at this point, I should probably go bother #tmux
11:37:10 <phaazon> because it assumes something impossible
11:37:18 <phaazon> or I guess, a nonsense
11:37:28 <AaronFriel> ttt_fff: A working example eludes me, because I've worked with such things so few times
11:37:33 <phaazon> (that a functor is both covariant and contravariant)
11:37:47 <merijn> phaazon: Why couldn't it be?
11:38:11 <phaazon> merijn: doesn’t compute in my mind
11:38:11 <ttt_fff> AaronFriel: yeah, it should be possible on unix-y systems using FIFO pipes, where ghci reads from a makefifo, and I pump stuff into the other end of the fifo
11:38:24 <phaazon> :t phanto
11:38:25 <lambdabot> Not in scope: ‘phanto’
11:38:26 <phaazon> :t phantom
11:38:27 <lambdabot> Not in scope: ‘phantom’
11:38:35 <phaazon> @let import Data.Functor.Contravariant
11:38:36 <lambdabot>  Defined.
11:38:37 <phaazon> :t phantom
11:38:38 <lambdabot> (Functor f, Contravariant f) => f a -> f b
11:38:42 <AaronFriel> ttt_fff: Yeah that's the thing! makefifo! I've used that before with remote-unlock of cryptdisk
11:39:22 <AaronFriel> ttt_fff: I'm sorry I'm not more helpful, I just have vague ideas of what's possible, and not a lot of *nix experience.
11:39:43 <ttt_fff> in #haskell, people apologize for helping you
11:39:52 <AaronFriel> ;_;
11:40:32 <AaronFriel> Serious question though, before I get knee-deep in HVec/HListing the heck out of this code
11:41:03 <AaronFriel> I have a parser library, I want to be able to arbitrarily layer parsers-on-parsers, and combine them (in a sensible way). I have written the code for n=2
11:41:14 <AaronFriel> But writing such a fn for n>=2 seems hard
11:41:30 <AaronFriel> Since the types are distinct, am I in HList/HVec territory?
11:42:12 <AaronFriel> Each parser "layer" produces tokens (in the return value of running the parser on some input... there's some other details but that suffices) and an output stream
11:42:57 <AaronFriel> And parsers can be layered by writing a parser whose input stream is equivalent to [outputStream, returnValue]
11:43:05 <AaronFriel> Now I want something like
11:43:55 <AaronFriel> combineParsers [byteStreamTokenizer,htmlTagParser,abstractTagParserQuxBaz] [emptyByteStreamState,emptyHtmlTagState,emptyTagParserQuxBazState]
11:44:07 <AaronFriel> alternatively zip the two lists together
11:45:21 <AaronFriel> Do I use HLists? Do I dive into grokking HLists? Or should I use HVecs (my lists will always be constant sized for a given set of parsers, I'm not going to be consing or appending while parsing)?
11:48:45 <AaronFriel> Okay going to assume that's a yes on HVecs and I'll proceed blithely unaware of any potential issues
11:48:58 <AaronFriel> (There is an unfortunate lack of tutorials on using HVect)
11:52:00 <agibiansky> Hey, can anyone help me out with using Stack properly?
11:53:23 <chreekat> agibiansky: yes, but see also #haskell-stack :)
11:53:52 <agibiansky> chreekat: Thanks, will move there! I tried to find the right IRC channel on the stack README but it wasn't mentioned :)
12:00:52 <AaronFriel> agibiansky: What would you like to know?
12:01:09 <AaronFriel> agibiansky: I'm using Stack exclusively for managing the software I'm developing
12:15:47 <deepfire> agibiansky, hey!
12:16:04 <agibiansky> deepfire: Hey! My question got sorted out on #haskell-stack :)
12:16:45 <deepfire> agibiansky, sure, just, I was trying to reach you by mail, but apparently it went into a black hole : -)
12:16:59 <deepfire> agibiansky: so I'm very happy to find you here : -)
12:17:00 <agibiansky> deepfire: Oh hey, what did you send me? 
12:17:09 <deepfire> agibiansky: basically, https://github.com/skeeto/elfeed/issues/99
12:18:25 <deepfire> agibiansky: the latest of the two mails was titled "RSS of your feed has wrong-ish date format"
12:19:32 <agibiansky> deepfire: Oh, huh, both of them went to spam
12:19:49 <agibiansky> My blog uses a hack on top of Hakyll, so yeah, the dates are just sort of ad-hoced
12:19:52 <bernalex> anyone have the fibonacci sequence with IORefs handy? or anything else similarly trivial written in an imperative style using e.g. IORefs?
12:19:52 <agibiansky> I'll fix that
12:20:17 <Franciman> bb
12:20:20 <deepfire> agibiansky: thank you!
12:29:15 * hackagebot nylas 0.1.1 - Client for the Nylas API  https://hackage.haskell.org/package/nylas-0.1.1 (bts)
12:36:12 <bernalex> isn't there a whileM like forM, or did I dream that up? is there a while loop of some sort?
12:36:44 <cocreature> bernalex: https://hackage.haskell.org/package/monad-loops-0.4.3/docs/Control-Monad-Loops.html#v:whileM this one?
12:36:47 <athan> bernalex: I made a think kinda like this
12:36:55 <athan> @hackage almost-fix
12:36:55 <lambdabot> http://hackage.haskell.org/package/almost-fix
12:37:04 <athan> thing*
12:37:16 <bernalex> cocreature: I know about that -- I meant in base
12:37:21 <cocreature> oh, sry
12:37:23 <athan> bernalex: almostFixM is like a while loop with a monadic boolean
12:37:26 <bernalex> cocreature: np -- my fault
12:38:20 <bernalex> I guess I can do forM [n,n-1..0] really
12:38:48 <bernalex> god this is so stupid and ugly lol
12:39:10 <athan> :(
12:42:34 <lpaste_> aweinstock pasted “Imperative fibonacci” at http://lpaste.net/139573
12:42:49 <aweinstock> bernalex: ^
12:43:19 <bernalex> aweinstock: that'll probably work
12:45:08 <lpaste_> aweinstock revised “Imperative fibonacci”: “Imperative fibonacci” at http://lpaste.net/139573
12:45:27 <aweinstock> (golfed slightly to use replicateM rather than forM_)
12:47:28 <bernalex> well, that's the main problem with yours. it's a bit golfed. I'm going for verbose. :)
12:47:46 <Welkin> is this a contest?
12:48:34 <aweinstock> bernalex: I'll try ungolfing it a bit
12:50:06 <quchen> aweinstock: You should add strictness to the modification function.
12:50:20 <quchen> Now you've got an evil thunk building up.
12:51:34 <lpaste_> aweinstock revised “Imperative fibonacci”: “Imperative fibonacci” at http://lpaste.net/139573
12:52:01 <aweinstock> quchen: I'm aware that the tuple version had a space leak
12:52:37 <aweinstock> bernalex: is the new one sufficiently pedagogical? :)
12:53:22 <bernalex> aweinstock: new one is almost what I have myself atm (though I'm using IORefs), so, I think so, yes :)
12:53:25 <quchen> Are you aware how to get rid of the space leak?
12:53:58 <Welkin> > let go x1 x2 = x1 : go x2 (x1 + x2) in go 0 1
12:53:59 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:54:04 <Welkin> :D
12:54:22 <Welkin> bernalex: why would you write such ugly mutating code?
12:54:36 <Welkin> is it an "imperative golf contest"?
12:54:50 <bernalex> Welkin: it's for my slides on denotative vs. imperative
12:55:14 <bernalex> Welkin: I could probably write the imperative code in C or python or whatever, but it doesn't look much uglier in haskell than in C tbh.
12:56:22 <lpaste_> aweinstock revised “Imperative fibonacci”: “Imperative fibonacci” at http://lpaste.net/139573
12:56:37 <aweinstock> quchen: fib3 has the space leak fixed, I think?
12:57:04 <jgt> hey folks
12:57:10 <jgt> started tinkering with haskell again
12:57:16 <jgt> having less luck than last time
12:57:29 <jgt> ghci can't find simple things when I load from a file
12:58:09 <jgt> like, if I try and use `+`, (without backticks), I get: Not in scope: ‘+’
12:58:31 <aweinstock> :t (+)
12:58:32 <lambdabot> Num a => a -> a -> a
12:58:41 <Welkin> jgt: did you import Prelude?
12:58:50 <jgt> Welkin: no
12:58:50 <Welkin> or rather, did you explicitly not import Prelude?
12:58:59 <aweinstock> (if you're trying to refer to + by itself, it needs parenthesis)
12:59:14 <Welkin> :t +
12:59:15 <jgt> Welkin: imported Data.List and System.IO
12:59:15 <lambdabot> parse error on input ‘+’
12:59:23 <Welkin> :t (+)
12:59:24 <lambdabot> Num a => a -> a -> a
12:59:38 <Welkin> Prelude should be imported implicitly
12:59:39 <aweinstock> jgt: can you lpaste the relevant code?
12:59:55 <Welkin> unless you turn it off using NoImplicitPrelude
13:00:01 <Gurkenglas> > map fst . iterate (snd &&& uncurry (+)) $ (0,1)
13:00:03 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:00:37 <quchen> aweinstock: Yes, that should be safe.
13:01:12 <quchen> aweinstock: Although you could write the modification function nicer using BangPatterns,  \(!a,!b) -> …
13:01:41 <quchen> I guess one of those bangs would suffice.
13:02:00 <jgt> removing the imports doesn't change much either
13:02:02 <jgt> https://gist.github.com/jezen/32a7607e2010e516631e
13:02:02 <aweinstock> quchen: it could be written nicer without using ST too ;)
13:02:07 <quchen> aweinstock: :-þ
13:02:51 <quchen> jgt: Do you have a custom ghci.conf?
13:03:07 <tulcod> jgt: your problem fits in this category https://xkcd.com/1084/
13:03:38 <jgt> bollocks
13:03:40 <jgt> yes
13:03:50 <jgt> I was tinkering in a dir that had a yesod install
13:03:56 <jgt> which comes with a .ghci
13:04:04 <jgt> and when I looked in it now, I see it excludes prelude
13:04:22 <tulcod> ah yes, yesod re-exports prelude in a slightly different way
13:04:33 <jgt> thanks for the help!
13:04:44 <tulcod> but if you don't import yesod, you don't have anything
13:04:52 <tulcod> so either import prelude or import yesod
13:05:03 <scshunt> yesod itself doesn't, but a scoffolded yesod site uses classy-prelude and compiles with NoImplicitPrelude
13:08:11 <bernalex> aweinstock: the one I had is just http://lpaste.net/5831549523259817984 lol
13:09:17 * hackagebot DSA 1.0.0 - Implementation of DSA, based on the description of FIPS 186-4  https://hackage.haskell.org/package/DSA-1.0.0 (AdamWick)
13:09:37 <bernalex> "\_ ->" can be replaced by "const $" of course.
13:10:28 <bernalex> and c is uneccessary obv
13:11:39 <Peaker> "\_ -> "  is shorter than "const $" though :) and has even lower precedence
13:12:07 <aweinstock> bernalex: is forM_ to replicateM_ considered golfing in this context? or is it merely the right construct to express "do this n times"?
13:12:36 <bernalex> aweinstock: "for loops" are more familiar than "replicate", that's the only reason I have forM there. ideally I'd use "whileM" or similar.
13:12:49 <bernalex> replicateM_ might be better anyway though. not sure yet.
13:13:15 <Welkin> I wonder if this is the problem?
13:13:27 <Welkin> when defining a data type, which is the proper way to make the fields strict?
13:13:28 <Peaker> if you can use a "weaker" primitive like replicate, it's nicer and better. It may also do more CSE (the action to replicate is independent of any argument)
13:13:40 <Welkin> someField :: !(Maybe Double)
13:13:42 <bernalex> Peaker: I'm not going to spend too much time on this anyway
13:13:48 <Welkin> someField :: Maybe !Double
13:14:02 <bernalex> Peaker: this is just "here's denotative: canonical fib. here's imperative: for derp herp my slerp"
13:14:03 <Peaker> Welkin: I think only the former compiles(?)
13:14:15 <bernalex> I bet nobody will even do more than throw a quick glance at it
13:14:29 <aweinstock> Peaker: the context is example-imperative-code for a slide
13:14:44 <Peaker> ah, ok
13:15:06 <Peaker> it's weird that bangs require parenthesis even though they unambiguously are allowed only at the absolute top-level
13:17:11 <tulcod> Peaker: it's definitely less confusing
13:17:41 <Peaker> tulcod: Why? If bangs can only mean one thing, how can it be confusing for some other thing?
13:17:57 <geekosaur> the way ghc overloads syntax, I'm not sure I'd want to bet on that
13:18:02 <tulcod> because if you don't know that it can only mean that, then you still know what they mean in that specific case
13:18:11 <geekosaur> that said, I think this was actually tracked down to laziness in the parser
13:18:22 <geekosaur> (laziness of the writer, not of the parser@)
13:21:06 <Denommus> hi
13:22:28 <ttt_fff> are there any haskell gpu bindings with blas? I'm reading about accelerate but I don't see blas
13:22:36 <Denommus> conal: does your article "Why classic FRP does not fit interactive behavior" still apply since "push-pull FRP"?
13:23:42 <quchen> Peaker: It leaves the grammar a bit simpler I guess
13:23:57 <conal> Denommus: "push-pull" didn't change the denotation. it (a) repackaged the API and denotation via standard type classes, and (b) gave an implementation style. so, yes, since the issues in that blog post are about denotation.
13:24:27 <quchen> Peaker: And !(Maybe Int) is somewhat easier to read than !Maybe Int because we're so used to matching parens
13:29:18 <Peaker> quchen: so Int -> (Maybe String) too?
13:29:30 <Peaker> quchen: I think it's just a matter of getting used to precedence rules
13:30:42 <Peaker> Also, at the value-level: x!(maybe foo) ?
13:33:17 <quchen> You wouldn't write "x!maybe foo" there either.
13:33:56 <quchen> In !Maybe Int, the bang looks like it forces the Maybe. I think that's awkward.
13:34:26 <quchen> Well, tastes differ, no point in discussing them.
13:35:55 <Peaker> quchen: I'm ok with: field :: ! Maybe String   or even:  field ::! Maybe String
13:36:12 <Peaker> (The ! is more associated with the :: than it is with the type, in a sense)
13:36:48 <Welkin> yeah, the bangs also mess up operator precendence
13:37:05 <Welkin> I still can't figure out what is caused the memory usage to be so high with this conduit program
13:37:22 <quchen> Bangs mess up operator precedence?
13:37:26 <quchen> You mean in pattern matching?
13:37:35 <Welkin> yes
13:37:50 <Welkin> I have to wrap the whole pattern in parens
13:37:53 <HelgeS> I have written a Python program that models the digital part of an analog circuit (some 16-bit registers with various purposes), and now I want to use Haskell to do the same thing, as my first Haskell project. But I'm stuck. I don't understand how to interpret an arbitrary 16-bit word into different register values, depending on the address part. It seems to me that the different registers should be of different types, but still in a way 
13:38:13 <quchen> Welkin: Well, you similarly have to wrap (x:xs) in parentheses
13:39:01 <quchen> All things considered I'm quite happy with pattern matching syntax
13:39:06 <Hijiri> HelgeS: what you could do is first have a type for each register type
13:39:12 <Welkin> also, this program is spending 50% of the time in GC
13:39:20 <Tuplanolla> Looks like I can't install any version of spacepart, because vector-space says HasTrie and trie are not in scope.
13:39:23 <Hijiri> and then for your interpreting function output a sum type that includes all of them as alternatives
13:39:36 <Welkin> is that normal for conduit?
13:39:38 <Tuplanolla> What's wrong?
13:39:46 <Hijiri> like data PossibleRegisters = R1 RegisterType1 | R2 RegisterType2 | ...
13:39:50 <quchen> Rust's multi-alternative-matching would also be nice sometimes, a la   case (a x | b x) -> ...x...  but I'm not even sure how useful that is in practice.
13:40:02 <Hijiri> and interpret :: Word16 -> PossibleRegisters
13:40:09 <Hijiri> or something like that
13:40:24 <quchen> And one last thing I could sometimes use would be wildcarding constructors, so "fromMaybe (_ x) = x".
13:40:48 <quchen> Again, not sure how much sense that would actually make if it was implemented.
13:41:09 <Hijiri> and then with each constructor you know what register type it has, and you can choose to do something different based on that
13:41:24 <Welkin> when I try to compile with -prof I get this error
13:41:25 <Welkin> Main.hs:33:18: Could not find module ‘Data.Text’ Perhaps you haven't installed the profiling libraries for package ‘text-1.2.1.3’? Use -v to see a list of the files searched for.
13:41:33 <Welkin> for all of my imports
13:41:42 <quchen> You're compiling with profiling enabled.
13:41:47 <Welkin> I know
13:41:48 <quchen> But your deps lack that.
13:41:52 <Welkin> hm?
13:42:01 <quchen> You didn't compile text with profiling enabled.
13:42:20 <Welkin> seriously? I need to reinstall everything?
13:42:31 <quchen> Yup.
13:42:35 <quchen> I mean that's what I would do.
13:42:43 <Welkin> so why isn't this the default?
13:42:51 <quchen> Because it doubles compilation times.
13:42:54 <Tuplanolla> Hey conal, your own packages (spacepart, vector-space, MemoTrie) have broken dependencies.
13:42:58 <Guest89125> why I was banned?
13:42:59 <Welkin> also, how do I enable profiling when using cabal install?
13:43:05 <Denommus> conal: hm, so, is there any place where you compiled the convenient and efficient packaging for interactive behavior, or is it scattered through the blog?
13:43:10 <Guest89125> how can I check that?
13:43:11 <HelgeS> Hijiri: So my interpret function would take the 4 LSB, and then return different RegisterType1, RegisterType2 etc, depending on them. And these RegisterTypeN values would take their data depending on the 12 MSB.
13:43:25 <quchen> Guest89125: Hard to tell, you're hard to identify with such a generic name.
13:43:30 <quchen> +you
13:43:39 <conal> Denommus: it's scattered across my thoughts of the last 20 years.
13:43:49 <Tuplanolla> How am I supposed to install spacepart?
13:43:51 <Guest89125> +you
13:43:54 <quchen> Guest89125: There are full logs of this channel available at ircbrowse.net.
13:43:59 <conal> Tuplanolla: oh? hm. what's spacepart?
13:44:02 <Guest89125> thank You
13:44:03 <Denommus> conal: ha!
13:44:13 <Denommus> conal: what would you recommend nowadays, then? Just going with AFRP?
13:44:17 <Tuplanolla> Oh sorry, that's not yours.
13:44:38 <Hijiri> HelgeS: yep
13:44:44 <conal> Denommus: i supposed it depends on what one is looking for.
13:45:02 <Tuplanolla> The problem is that vector-space-0.5.9 tells me HasTrie and trie from MemoTrie are not in scope, conal.
13:45:11 <Hijiri> though (pedantically) the interpret function will be returning the big sum type that has those RegisterN types as alternatives
13:45:24 <Hijiri> it won't be returning those types directly
13:45:41 <Denommus> conal: right NOW, I'm thinking about games. But later I might be interested in event-driven GUIs
13:46:11 <conal> Tuplanolla: hm. i wonder what's going on. 0.5.9? that's a pretty old version.
13:46:25 <Tuplanolla> That's what spacepart needs apparently.
13:46:36 <Tuplanolla> Do you think I can convince it to use newer versions?
13:47:09 <HelgeS> Hijiri: Now, my registers consist of fields of various lengths and LSB positions, and the same names, lengths and LSB positions could be used for the functions that construct a 16-bit register value from a register. And I don't to define these lengths and LSB positions in more than one place. 
13:47:13 <conal> Tuplanolla: i don't know
13:47:30 <Tuplanolla> You don't remember breaking things?
13:47:30 <Guest89125> is pint timeout sufficient reason for banning?
13:47:34 <Guest89125> ping*
13:48:24 <Hijiri> HelgeS: do you mean you don't want to define those numbers in more than one place?
13:48:35 <Hijiri> for that you could just define them at the top level
13:48:40 <HelgeS> My idea is to have "data Reg a = FieldA Reg a | FieldB a deriving (Show)" 
13:48:42 <Tuplanolla> I just want QuadTree without lens.
13:48:42 <HelgeS> as an example
13:48:49 <geekosaur> no, unless it's happening often enough to get you a freenode-standard forward ban to ##fixyourconnection
13:49:06 <geekosaur> even then it'd take people complaining about the join/part noise
13:49:22 <Guest89125> well, it was my first time on Irc yesterday
13:49:36 <Hijiri> HelgeS: what's the idea?
13:49:42 <Hijiri> I mean, what is Reg a supposed to represent
13:49:43 <Guest89125> but I was simultanously on 15 channels. Maybe if timeout was on all 15?
13:50:11 <geekosaur> no
13:50:17 <conal> Tuplanolla: no, i don't, but version 0.5.9 is from 2010, so who knows.
13:50:25 <geekosaur> unless you are talking about a k-line and in that case you need to talk to a freenode staffer
13:50:47 <conal> Tuplanolla: looks like spacepart is even older
13:50:48 <Hijiri> HelgeS: also you have a kind error, since Reg in "FieldA Reg a" isn't applied to anything
13:50:53 <Hijiri> did you mean FieldA (Reg a)
13:51:01 <geekosaur> also the only recent ban I see is for an obvious spammer
13:51:08 <Tuplanolla> I don't really have a choice here.
13:51:12 <Guest89125> what is the name of him?
13:51:22 <HelgeS> Hijiri: My idea is that for example one register, called RegA has two fields, called FieldA and FieldB, that both share the properties that fields have, such as a length in bits, an LSB position within the register word, and (possibly) a value.
13:52:26 <Hijiri> HelgeS: Is Reg a supposed to be a register?
13:52:35 <HelgeS> Yes
13:53:03 <Hijiri> it wouldn't make sense to define it as FieldA (Reg a) | FieldB then, since that would mean it either has FieldA or FieldB, not both
13:53:10 <Hijiri> what I would do is first define a Field type
13:53:46 <Hijiri> actually wait
13:53:49 <HelgeS> I'm sorry, I think I have to take a pause here and read my code carefully again. 
13:53:54 <conal> Tuplanolla: you'll probably have to tweak spacepart yourself, changing the vectorspace dependency to a more recent version.
13:53:54 <geekosaur> oh wait, I see a ban by address (128.199.158.247) from earlier today also, again spam according to my logs
13:54:01 <HelgeS> I don't remember all my intentions with the code.
13:54:19 <Hijiri> why do you need to store the length and LSB position in the data?
13:54:23 <Tuplanolla> I tried removing lens from QuadTree and doing that, but both attempts were futile, conal.
13:54:23 <conal> Tuplanolla: ... which may or may not require changes to spacepart's code as well.
13:54:25 <geekosaur> Guest89125, I suggest asking in #haskell-ops
13:54:33 <conal> Tuplanolla: rats :/
13:54:39 <Hijiri> it seems like that should be handled by the interpret and encoding functions
13:54:49 <Tuplanolla> I'm surprised it's not in containers.
13:55:51 <HelgeS> Hijiri: Perhaps I don't have to do that. But I want to do conversions in both directions, between arbitarary 16-bit words and well-typed registers with sub-fields. All 16 registers together comprise most of the state of the modelled circuit. 
13:56:18 <benzrf> is there a version of incr that loops around
13:56:22 <Hijiri> HelgeS: the functions in both directions can each use the length and position data
13:56:33 <Hijiri> you don't need to store the length and position data because you already know them from what kind of register it is
13:56:36 <benzrf> wait
13:56:42 <benzrf> i mean succ :|
13:56:49 <HelgeS> Good points!
13:57:31 <ski> > (1+) (maxBound :: Int8)
13:57:32 <lambdabot>  -128
13:58:01 <Welkin> what are the different options for a .cabal file?
13:58:10 <Welkin> I can't find the page that explains it
13:58:25 <Welkin> I know there is a way to set specific compiler options for each executable
13:58:36 <Tuplanolla> If someone's looking for a small project, I have a suggestion: a new quadtree package.
14:00:46 <chpatrick> good news everyone
14:00:55 <chpatrick> I've invented higher kinded programming in java
14:01:42 <chpatrick> felt wrong writing public interface Category
14:01:59 <conal> Tuplanolla: btw, http://conal.net/blog/posts/topless-data . 
14:02:23 <benzrf> ski: i mean for arbitrary Enum
14:06:31 <Welkin> oh, I just noticed that if you `cabal init` after already having source files in a directory, cabal will automatically fill in all your build-depends and compiler-flags for you
14:09:25 <benzrf> conal: topless ( ͡° ͜ʖ ͡°)
14:10:49 <Welkin> OMG
14:10:52 <t7> this is why there are no women in tech
14:10:55 <Welkin> classic benzrf 
14:11:18 <Welkin> t7: except that there are...
14:11:24 <benzrf> Welkin: there arent enough tbh
14:12:19 <t7> nor enough male primary school teachers
14:12:38 <Welkin> benzrf: know anything about .cabal files?
14:12:45 <benzrf> not a ton
14:12:53 <Welkin> is there a resource where I can find all of the different options for it?
14:13:02 <benzrf> probably
14:13:04 <Hafydd> Welkin: the Cabal manual.
14:13:06 <Welkin> I *think* to set ghc flags you use ghc-options:
14:13:14 <Welkin> Hafydd: I didn't find it in there
14:13:31 <Welkin> you mean this? https://downloads.haskell.org/~ghc/7.0.4/docs/html/Cabal/authors.html
14:13:45 <benzrf> but seriously is there a function for Enums like succ but that loops around when u reach the maxbound
14:13:46 <Hafydd> Welkin: https://www.haskell.org/cabal/users-guide/developing-packages.html#package-descriptions
14:14:57 <hexagoxel> Welkin: --prog-options on https://www.haskell.org/cabal/users-guide/installing-packages.html
14:15:00 <Welkin> benzrf: I thought that was how succ worked on sum types
14:15:10 <Welkin> benzrf: you can easily define it yourself
14:15:13 <Welkin> :t succ
14:15:14 <lambdabot> Enum a => a -> a
14:15:20 <Welkin> just make it an instance of Enum
14:15:30 <hexagoxel> "prog" is a variable..
14:15:53 <Hafydd> @hoogle (Enum a, Bounded a) => a -> a
14:15:55 <lambdabot> Prelude pred :: Enum a => a -> a
14:15:55 <lambdabot> Prelude succ :: Enum a => a -> a
14:15:55 <lambdabot> Prelude id :: a -> a
14:15:55 <benzrf> @let data Foo = Bar | Baz deriving Enu
14:15:56 <lambdabot>  .L.hs:153:19:
14:15:56 <lambdabot>      Not in scope: type constructor or class ‘Enu’
14:15:57 <lambdabot>      Perhaps you meant ‘Enum’ (imported from Prelude)
14:15:59 <benzrf> @let data Foo = Bar | Baz deriving (Show, Enum)
14:16:01 <lambdabot>  Defined.
14:16:02 <Welkin> hexagoxel: I think the link I pasted is it
14:16:03 <benzrf> > succ Baz
14:16:05 <lambdabot>  *Exception: succ{Foo}: tried to take `succ' of last tag in enumeration
14:16:09 <Welkin> I found ghc-options
14:17:02 <geekosaur> benzrf, there is no such function
14:17:10 <benzrf> well thats pretty lame
14:17:12 <Welkin> @let instance Enum Foo where succ Bar = Baz; succ Baz = Bar
14:17:14 <lambdabot>  .L.hs:153:26:
14:17:14 <lambdabot>      Duplicate instance declarations:
14:17:14 <lambdabot>        instance [safe] Enum Foo -- Defined at .L.hs:153:26
14:17:45 <Welkin> @undefine
14:17:45 <lambdabot> Undefined.
14:17:56 <Welkin> @let data Foo = Bar | Baz deriving (Show)
14:17:57 <lambdabot>  Defined.
14:17:58 <Welkin> @let instance Enum Foo where succ Bar = Baz; succ Baz = Bar
14:17:59 <lambdabot>  .L.hs:150:10: Warning:
14:17:59 <lambdabot>      No explicit implementation for
14:17:59 <lambdabot>        ‘toEnum’ and ‘fromEnum’
14:21:49 <Tuplanolla> I know I can make my own, conal, but that's not very convenient.
14:22:07 <JagaJaga> @pl \v -> print v >> return v
14:22:07 <lambdabot> liftM2 (>>) print return
14:22:31 <conal> Tuplanolla: no, it's not convenient if you're trying to get something else done rather than learn about functional quadtrees.
14:23:42 <magicman> I just noticed that hackage docs don't have a source link for re-exported (from another package) entities, even though that other package's source exists.
14:24:08 <magicman> Is this a haddock-thing or a hackage thing? How easy would it be to fix for someone who's new to either codebase?
14:24:08 <Tuplanolla> I guess I'll take QuadTree and tear out everything related to lens.
14:24:20 * hackagebot git-annex 5.20150824 - manage files with git, without checking their contents into git  https://hackage.haskell.org/package/git-annex-5.20150824 (JoeyHess)
14:26:07 <magicman> For example: https://hackage.haskell.org/package/http-conduit-2.1.8/docs/Network-HTTP-Conduit.html#t:Request , they are re-exports from Network.HTTP.Client (possibly .Internal, but intra-package re-exports work fine)
14:27:07 <magicman> ( https://hackage.haskell.org/package/http-client-0.4.20/docs/Network-HTTP-Client.html#t:Request )
14:27:41 <bernalex> can someone refresh my memory on the difference between call-by-need and lazy evaluation?
14:27:45 <bernalex> wikipedia wasn't initially helpful
14:28:27 <bernalex> call-by-need is memoised call-by-name, and lazy evaluation is a call-by-need implementation that avoids sharing. that sounds like "lazy evaluation is call-by-need that achieves this by doing literally the definition of call-by-need" to me
14:28:41 <Hijiri> the Enum/Bounded "laws" say that succ maxBound and pred minBound must be runtime errors
14:29:45 <bernalex> I guess I misunderstand the more precise definitions of memoisation vs. sharing.
14:29:54 <JagaJaga> :t liftM2
14:29:55 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:29:55 <bernalex> and that there's some vital difference there that I'm not groking so late at night. :)
14:30:13 <Welkin> does anyone have experience profiling a program for memory usage?
14:30:37 <Tuplanolla> You should read the RWH chapter relating to it, Welkin.
14:30:38 <Welkin> is the file output by +RTS -p enough?
14:30:52 <Tuplanolla> It's very good and not that long.
14:32:14 <Welkin> Tuplanolla: thanks, looking into it now
14:32:16 <conal> bernalex: i'm used to "call-by-need" and "lazy evaluation" as interchangeable, while "non-strict" is different.
14:34:12 <bernalex> conal: my understanding:  non-strict semantics = things are not evaluated until needed. call-by-name and call-by-need are versions of this. call-by-name = substitute arguments into the function body when the function is called, and evaluate them when they appear. call-by-need is a memoised version of this -- i.e. store the value for future reuse rather than re-evaluate. lazy evaluation is usually mentioned
14:34:14 <bernalex> as "the most popular implementation method of call-by-name". but I'm not sure the peculiar difference between lazy evaluation and call-by-need.
14:34:20 * hackagebot Win32-dhcp-server 0.3.2 - Win32 DHCP Server Management API  https://hackage.haskell.org/package/Win32-dhcp-server-0.3.2 (MichaelSteele)
14:35:27 <monochrom> non-strict is at the denotational level. call-by-* is at the operational level. different levels. not even apple vs orange. apple vs cell.
14:35:44 <conal> bernalex: the way i use the terms, "non-strict" is a denotational property, not about evaluation mechanics at all.
14:35:51 <Welkin> apple vs goku!
14:36:04 <Welkin> actually, Apple is a dragon ball character too!
14:36:06 <conal> bernalex: what gives you the idea that call-by-need and lazy evaluation aren't the same thing?
14:36:16 <Welkin> it is that purple henchman on namek
14:36:33 <bernalex> conal: some books and wikipedia and others that mention lazy evaluation as "the most common way to implement call-by-need"
14:36:46 <conal> bernalex: oh. hm.
14:37:05 <monochrom> firstly I wouldn't trust wikipedia on this. (I do trust wikipedia on other things.)
14:37:35 <Welkin> wikipedia is the most complete source of encyclopedic anime knowledge in the world
14:37:39 <monochrom> secondly, every Wadler paper on call-by-need is exactly lazy evaluation, no more no less.
14:37:54 <bernalex> conal: it always kind of confused me because, as I said, they would say "ok so call-by-need is memoised call-by-name, and lazy evaluation is an implementation of non-strict semantics without sharing". but "without sharing" is already the whole idea of memoised call-by-name.
14:38:06 <bernalex> monochrom: yes, I noticed this while reading him too
14:38:42 <monochrom> I am happy to guess why two names. the reasons I guess are all non-technical.
14:38:44 <bernalex> conal: I agree what I said about non-strict semantics is operational and not denotative. do you have an idea for how I should explain it instead?
14:39:00 <monochrom> i.e., pure cultural choice of names.
14:39:24 <conal> bernalex: i said the opposite: non-strict is denotational call-by-need/lazy and call-by-value/eager are operational.
14:39:25 <Tuplanolla> Explain it with car analogies.
14:40:09 <monochrom> the denotational level says only "whether you get an answer, and if so, what answer you get". emphatically avoids saying how to get that answer.
14:40:14 <conal> bernalex: retrying: i said the opposite: non-strict and strict are denotational, while call-by-need/lazy and call-by-value/eager are operational.
14:40:38 <monochrom> the operational level says only "how to run programs". does not really care what answers you get.
14:41:17 <monochrom> (to be sure, you will get an answer, by tour de force. but that is not the point of the operational level)
14:42:01 <bernalex> conal: wat? that's what I meant to say
14:42:23 <monochrom> yeah your writing had typos :)
14:42:40 <monochrom> always proofread
14:42:40 <bernalex> conal: I meant to say that I agree it is denotational, and if you have a better way of "defining" non-strict semantics
14:42:52 <conal> bernalex: oh, good. ("... non-strict semantics is operational ...")
14:43:24 <monochrom> non-strict simply means "f ⊥ does not have to equal ⊥"
14:43:38 <bernalex> conal: should be read: "I agree that what I said about non-strict semantics is (operational and not denotative)" -- whereas it should be denotative :)
14:43:41 <monochrom> the end
14:43:43 <bernalex> BRB
14:44:20 <conal> and as a language property, i think of non-strict semantics as simply that we have lambda abstraction that doesn't also add strictness (i.e., doesn't force mapping bottom to bottom)
14:44:26 <shachaf> monochrom: Is there a difference between "does not have to equal" and "does not equal"?
14:44:49 <AaronFriel> monochrom: What might be confusing to many learning Haskell is that they expect "f _|_" to not necessarily equal bottom
14:45:12 <ski> shachaf : presumably where the implicit quantification of `f' occurs ?
14:45:16 <AaronFriel> monochrom: E.g.: They might analogize bottom and undefined to null pointers, and in many "strict" languages you can pass null pointers around and (hopefully) not produced undefined results
14:45:27 <JagaJaga> Getting `Setup: Missing dependency on a foreign library: * Missing C library: curl`. I have `extra-libraries:curl` in my cabal file. What's the problem?
14:45:33 <shachaf> Oh, you're not talking about "non-strict function" but about "non-strict language".
14:45:37 <shachaf> Now I follow.
14:45:44 <monochrom> shachaf: yes. my sentence was an imprecise way to say "not (for all f. f ⊥ = ⊥)"
14:45:45 <Peaker> conal: can have an eager language, where you use: Lazy a -> b   instead of (a -> b)   to get that kind of lambda abstraction
14:45:58 <ski> AaronFriel : .. but null pointers is something different
14:46:23 <AaronFriel> ski: Sure, but I'm talking about how learners might try to figure out what _|_ means, and how it works, and so on
14:46:25 <monochrom> AaronFriel: usually I don't even mention ⊥ to beginners.
14:47:01 <AaronFriel> My point is that there are plenty of "strict" languages for which the equivalent of bottom does not imply (f _|_ = _|_)
14:47:35 <Peaker> AaronFriel: can you give an example?
14:47:59 <monochrom> but very early on you will notice: (1) there is no null pointer in Haskell; (2) some expressions don't have answers.  Therefore, if I say "it has no answer" to beginners, it is unambiguous.
14:48:00 * ski . o O ( there's plenty of functions `f' on vector spaces where `f 0 = 0' does not hold .. )
14:48:59 <AaronFriel> Peaker: in C#,Java/C++/C-like languages, "int foo(someType someObject) { if (someObject == NULL) { return -1 } else { ... } }"
14:49:11 <monochrom> ⊥ simply means "no answer". I am happy to say the English version for beginners.
14:49:13 <Peaker> AaronFriel: NULL is just an ordinary value, it's not like bottom
14:49:21 * hackagebot hs-duktape 0.1.0 - Haskell bindings for a very compact embedded ECMAScript (JavaScript) engine.  https://hackage.haskell.org/package/hs-duktape-0.1.0 (myfreeweb)
14:49:45 <AaronFriel> Peaker: Which is why I'm trying to say that for someone approaching Haskell, having only had experience of imperative languages, the example "non-strict means f _|_ does not necessarily _|_" doesn't make sense
14:50:00 <bernalex> monochrom: talking about bottom is a bit too low-level and unsexy for me in this particular instance.
14:50:01 <AaronFriel> Peaker: Because they are totally familiar with functions that may receive "not a value" values, and produce values anyway
14:50:15 <bernalex> conal's definition is a bit more sexy
14:50:27 <monochrom> and if you say, "but people think of null as no-answer too", well I respect that. but again, very early on, beginners will notice that Haskell doesn't have null pointers, therefore "no answer" cannot possibly mean null.
14:50:28 <Peaker> AaronFriel: You only need to preface it with "_|_ means non-termination with a value due to infinite loop or exceptions"
14:50:41 <ReinH> AaronFriel: f _|_ = _|_ is the definition of strict
14:50:44 <Sindriava> Can I StateT multiple times?
14:50:51 <AaronFriel> ReinH: I agree but the opposite is not true
14:51:00 <Peaker> AaronFriel: but NULL is "a value" in those languages' vocabularies too
14:51:05 <bernalex> monochrom: how would you explain this to a crowd of people who don't know what bottom is? i.e. someone at a very first "what's a haskell how do i even" lecture?
14:51:08 <AaronFriel> f _|_ /= _|_ is not the definition of non-strict
14:51:11 <monochrom> bernalex: I'm happy to use "⊤" for "no answer" if that's elevating and optimistic for you :)
14:51:13 <bernalex> s/lecture/talk or meetup/
14:51:25 <ReinH> AaronFriel: the definition of non-strict is the logical inverse of the definition of strict
14:51:31 <ReinH> s/inverse/negation
14:51:33 <Peaker> Sindriava: sure
14:51:35 <ski> Sindriava : yes
14:51:50 <monochrom> bernalex: does it need to be explained to that crowd? do they need to know?
14:51:59 <AaronFriel> ReinH: I'm not convinced that's true
14:52:07 <bernalex> monochrom: nothing needs to explained to anybody
14:52:14 <ReinH> AaronFriel: then you don't believe that strict and its negation form a dichotomy?
14:52:15 <AaronFriel> ReinH: That is, in terms of languages and the function we're describing f
14:52:29 <AaronFriel> ReinH: No, I'm saying that the example we're using might not exemplify that
14:52:34 <bernalex> monochrom: I'd still like to give it a quick shot to explain, very hand-wavingly, non-strict & lazy evaluation. if for nothing else then to implant the terms in their heads for later on.
14:52:41 <ReinH> AaronFriel: Which example is that?
14:52:43 <Welkin> Sindriava: but you need to explicitly lift to use the right one
14:52:53 <AaronFriel> ReinH: I'm just trying to say that the f _|_ not equalling bottom does not imply non-strict
14:53:04 <monochrom> ok then, I would simply not bring up the issue. in case someone in the audience is really curious, I simply say "it means the expression doesn't have an answer"
14:53:08 <Sindriava> Peaker: ski: Will haskell then infere which get to use? And I'm having some issues with deriving MonadState
14:53:14 <Welkin> Sindriava: no
14:53:15 <ReinH> It implies that f is non-strict. That's exactly what it entials.
14:53:21 <Welkin> Sindriava: you need to lift
14:53:28 <Sindriava> Well than, that's useless
14:53:34 <Sindriava> I'll use something else
14:53:37 <Sindriava> Thanks ^^
14:53:42 <ski> Sindriava : or tuple the states
14:53:59 <Sindriava> I'll use extensive effects, I guess
14:54:09 <AaronFriel> ReinH: I'm not sure that's the case, or at least it doesn't analogize well to languages other than Haskell and we're talking about, very narrowly, specifically Haskell semantics in that example, but it's not useful to people who don't understand those semantics
14:54:20 * ski idly ponders intensive effects
14:54:29 <AaronFriel> ReinH: I'm just trying to say that the example is ill-suited for people who have no idea what strictness is and aren't already intimately familiar with Haskell's
14:54:30 <monochrom> I'm pretty sure "lazy evaluation talk about how to execute the program, non-strict says that for some f, f (no answer) can have an answer" is understandable by beginners.
14:54:31 <ReinH> AaronFriel: I mean yes, statements that people don't understand are rarely useful to them
14:54:36 <ReinH> That doesn't mean that they are incorrect.
14:54:50 <Sindriava> ski + 1
14:55:09 <bernalex> monochrom: yes I think that "f (no answer) can have an answer for some f" is OK
14:55:11 <ReinH> It seems obvious to me that if someone wants to know whether a language is struct or has bottoms, they should know what strict and bottom mean
14:55:17 <ReinH> s/struct/strict
14:55:22 <AaronFriel> ReinH: And I'm also a still a bit unconvinced that f _|_ /= bottom implies non-strict is implied by f _|_ = _|_ implies strict.
14:55:31 <AaronFriel> ReinH: You're going to have to do additional steps to prove that
14:55:35 <bernalex> monochrom: I like my hand-waving to not lie and actually be correct
14:55:58 <AaronFriel> ReinH: And I'm not familiar enough with the literature, tbh, but just because we have words like strict and non-strict, doesn't mean they necessarily form a dichotomy with every given example
14:55:59 <Peaker> Sindriava: with mtl, the StateT that isn't the nearest will require lifting. You can use a single StateT and lens's zoom, perhaps
14:56:05 <ski> AaronFriel : you need "is equivalent with" (or "is implied by") instead of the last "implies"
14:56:05 <monochrom> yes I like that too, bernalex
14:56:24 <Sindriava>  Peaker: I'm writing an ECS, so I kinda need it to be extensible
14:56:29 <monochrom> here basically I'm saying "I've figured out how" :)
14:56:30 <Sindriava> Peaker: I might look into type families for that, though
14:56:36 <FUZxxl> Hello!
14:56:36 <ski> AaronFriel : given, `A -> B', you can show `not B -> not A', this is known as contraposition
14:56:40 <ReinH> Right, we're talking about a definition here. "f is strict" literally means the same thing as "f _|_ = _|_
14:56:40 <AaronFriel> ski: That repairs it, and you need some "forall"s in there
14:56:58 <ski> @djinn (a -> b) -> (Not b -> Not a)
14:56:58 <lambdabot> f a b c = b (a c)
14:57:01 <ski> ^ that's a proof
14:57:08 <AaronFriel> f is non-strict doesn't imply forall c, f c /= _|_
14:57:13 <ReinH> f is non-strict is the literal negation.
14:57:13 <Welkin> okay what is wrong with this?
14:57:15 <FUZxxl> In this question (http://stackoverflow.com/q/32192206/417501) someone asks about “set once variables.” Is there anything like that in the Haskell libraries?
14:57:23 <ReinH> AaronFriel: no one said that it does
14:57:34 <Welkin> how do I build my package via cabal with profiling?
14:57:39 <AaronFriel> ReinH: That's literally the thing I was trying to say that makes it a bad parallel for beginners
14:57:40 <Welkin> I added -prof to ghc-options
14:57:43 <Sindriava> FUZxxl: That's not a good idea. Maybe you want a Reader? :)
14:57:47 <L8D> FUZxxl: unsafePerformIO ?
14:57:53 <AaronFriel> ReinH: ugh
14:57:54 <ReinH> AaronFriel: Ok, you should have just said that instead of arguing with a definition.
14:58:00 <Sindriava> L8D: pls
14:58:01 <AaronFriel> ReinH: No, I've been saying that since the beginning
14:58:15 <bernalex> monochrom: so what do you think about * In a strict semantics, f x where x doesn't have an answer, f x doesn't have an answer -- and then * In a non-strict semantics, f x where x doesn't have an answer, some fs may have an answer nonetheless -- ?
14:58:16 <ski> AaronFriel : "non-strict" means "not strict". `f' being strict is `f _|_ = _|_'. so `f' being non-strict is `not (f _|_ = _|_)' aka `f _|_ =/= _|_'
14:58:31 <L8D> FUZxxl: MonadReader?
14:58:36 <bernalex> monochrom: do you have an idea for a really simple example or two of "some fs" where this is relevant?
14:58:42 <ReinH> Maybe you think you have been saying that, but you have been saying something else.
14:58:51 <ski> FUZxxl : data-ivar,ivar-simple, iirc
14:58:57 <ski> @hackage data-ivar
14:58:57 <lambdabot> http://hackage.haskell.org/package/data-ivar
14:59:00 <ski> @hackage ivar-simple
14:59:00 <lambdabot> http://hackage.haskell.org/package/ivar-simple
14:59:13 <AaronFriel> ski: Let f c = _|_
14:59:24 <ski> what about it ?
14:59:30 <Sindriava> FUZxxl: Can you describe your use case?
14:59:38 <ski> for all `c', or for some specific `c' ?
14:59:38 <Hijiri> I think I remember reading somewhere that f _|_ /= _|_ infact does imply forall c, f c /= _|_
14:59:52 <AaronFriel> For all c.
15:00:06 <Hijiri> yeah, I don't remember the argument fully though
15:00:09 <AaronFriel> Like, "let foo bar = undefined"
15:00:21 <conal> Hijiri: yes. due to monotonicity.
15:00:22 <Hijiri> oh nevermind you were continuing your thing
15:00:24 <monochrom> bernalex: "const True (something bad here)" distinghishes strict languages vs non-strict languages very quickly.
15:00:26 <Hijiri> @Aaron
15:00:26 <lambdabot> jargon ...... Jargon File
15:00:39 <AaronFriel> monochrom: That's an example that's way better.
15:00:42 <bernalex> monochrom: that's the exact example I already have
15:00:52 <AaronFriel> monochrom: Because we're dealing with a specific f (const) with specific behavior
15:00:54 <FUZxxl> Sindriava: L8D: ski: not me, I was just thinking about whether Haskell has something like this.
15:00:57 <monochrom> as for the "something bad here" part, you may use 1 `div` 0, or you may use an infinite loop. choose the one you like most.
15:00:59 <bernalex> monochrom: const don't_launch_the_missiles launch_the_missiles
15:01:16 <bernalex> :D
15:01:24 <Sindriava> FUZxxl: Short answer is yes, long answer is yes, but you probably don't want it
15:01:26 <bernalex> but yeah 1 `div` 0 is a nice crash.
15:01:55 <AaronFriel> ReinH, monochrom, et al: I am just trying to say that using bottom in trying to explain strictness to newbies may not be useful, especially when saying f _|_ /= _|_ because the analogous situation in most languages they will be familiar with already has that property, and lets people define plenty of "f"s that have that property.
15:02:03 <Sindriava> FUZxxl: the Reader monad provides you a way to have an immutable "state" that you can access throughout the monad
15:02:04 <monochrom> you can also think up interesting examples, interesting in several directions
15:02:08 <AaronFriel> e.g.: Any function in which variables are necessarily referred to by pointers
15:02:10 <AaronFriel> e.g.: Java
15:02:18 <ReinH> AaronFriel: Strictness is *defined in terms of bottom*. You literally can't explain it without using bottom.
15:02:30 <AaronFriel> ReinH: That's fine, I'm saying it's a bad example by analogy
15:02:32 <Sindriava> FUZxxl: And to be honest, I'm not sure I'd ever want to use a set-once variable
15:02:37 <Hijiri> AaronFriel: bottom in one of those languages would be something like bottom() where bottom() { while true {} }
15:02:40 <ReinH> "example by analogy"? It's a definition.
15:02:44 <monochrom> AaronFriel: I no longer care about your argument. please don't bother me.
15:02:45 <ReinH> What example are you referring to?
15:02:52 <FUZxxl> Sindriava: yeah, Iknow. I thought something along the line of an MVar
15:02:58 <Hijiri> or just bottom() { return bottom() }
15:03:13 <AaronFriel> Hijiri: Pretty sure GCC/LLVM eliminate that :P
15:03:27 <Sindriava> AaronFriel: Why would they?
15:03:31 <AaronFriel> Hijiri: It's ub and the loop will be erased by the spec
15:03:33 <Hijiri> what does it give for the value if I go x = bottom() ?
15:03:37 <Hijiri> oh
15:03:40 <ski> FUZxxl : note that I-vars are different from environment (/input/`Reader')
15:03:42 <Hijiri> well go with the second version then
15:03:47 <Hijiri> the recursive bottom
15:03:57 <AaronFriel> The second version will probably also get erased, but I get the point
15:04:08 <AaronFriel> However, there's no way to get to the point where you can pass bottom to a function
15:04:10 <AaronFriel> In Java
15:04:20 <AaronFriel> Try to pass bottom to a function in Java or C++
15:04:21 <monochrom> bernalex: "interesting" in one direction can be "depends on a parameter". f 0 x = True; f 1 x = x+1 == 0.  "f 0" is non-strict, "f 1" is strict.
15:04:38 <ski> AaronFriel : `foo(bottom())' does it
15:04:46 <AaronFriel> That doesn't pass it to the function :P
15:04:49 <monochrom> "interesting" in another direction involves non-strict data structures such as Haskell tuples, Haskell lists...
15:04:54 <Hijiri> AaronFriel: bottom() is the bottom value
15:04:55 <Hijiri> not bottom
15:05:17 <conal> The strict/non-strict terminology for languages (rather than functions) is perhaps misleading, because a "strict language" doesn't mean that all functions in the language are strict. If they were, no recursions would terminate. 
15:05:18 <t7> Lazy<Bottom>
15:05:22 <ski> AaronFriel : what happens during execution doesn't matter. what matters are denotations. the denotation of `bottom()' is `_|_' there
15:05:28 <AaronFriel> Like I said, there's no good analogy here because there's no way to do things like "pass an infinite computation to a function" because you don't have thunks representing infinite computations laying around
15:05:35 <bernalex> monochrom: I think const 1 (1 `div` 0) will suffice nicely for starters. then I can make up others right then and there if prompted for more.
15:05:43 <monochrom> yeah
15:05:45 <AaronFriel> And these are *definitely* bad analogies for anyone who understands anything about C-like language compilation
15:05:50 <Hijiri> thunks don't have anything to do with strictness
15:06:00 <AaronFriel> where foo(bottom()) denotationally means something totally different than what you're saying
15:06:00 <Sindriava> AaronFriel: Define passing an infinite computation.
15:06:10 <ReinH> AaronFriel: C programmers don't understand strictness in much the same way that fish don't understand wetness.
15:06:11 <AaronFriel> Something like passing (let x = x in x)
15:06:21 <ski> conal : depends on what counts as "functions"
15:06:28 <bernalex> ReinH: tempted to @remember that one :)
15:06:31 <conal> ski: indeed.
15:06:37 <bernalex> conal: I agree
15:06:39 <Sindriava> bernalex: Do it
15:06:41 <Sindriava> :D
15:07:04 <bernalex> only thing stopping me is that @help annoys me & I can't remember how to use @remember :p
15:07:05 <conal> on another topic, is there an actively maintained library on hackage for priority queues?
15:07:10 <ReinH> heh
15:07:15 <ReinH> conal: Not PQueue?
15:07:24 <bitemyapp> conal: http://hackage.haskell.org/package/psqueues
15:07:33 <ski> AaronFriel : i submit that `foo(bottom())' is a perfectly good way to "pass an infinite computation to a function", in the sense that matters, wrt denotational semantics (which is the context where `_|_' and "strict","non-strict" has a meaning)
15:07:36 <bitemyapp> conal: http://hackage.haskell.org/package/pqueue
15:07:45 <monochrom> AaronFriel, ReinH, Sindriava, ski: please move the discussion to #haskell-overflow
15:07:47 <bitemyapp> conal: http://hackage.haskell.org/package/PSQueue
15:07:52 <AaronFriel> ski: I totally disagree because people just won't get that
15:07:53 <ReinH> bitemyapp: nice
15:07:57 <conal> thanks, all.
15:08:00 <bitemyapp> conal: you probably want the first one.
15:08:15 <bitemyapp> ReinH: bitemyapp - powered by Xmonad
15:08:21 <ReinH> heh
15:08:35 <bitemyapp> except for when he wants to play a game on steam ;_;
15:08:41 <ReinH> heh
15:08:46 <ReinH> bitemyapp: no linux games?
15:08:53 <bitemyapp> ReinH: tons! just don't play nice with Xmonad.
15:08:56 <bitemyapp> work fine in Unity.
15:09:07 <bitemyapp> tried doFloat, doIgnore - issues with keyboard.
15:09:25 <Welkin> I think I found what is using so much memory
15:09:34 <Welkin> the decode function from Data.Csv.Incremental
15:09:35 <ReinH> bitemyapp: ah :/
15:09:37 <Welkin> but why!?
15:09:48 <Welkin> it is supposed to be used for streaming?
15:10:11 <ski> @remember ReinH AaronFriel: C programmers don't understand strictness in much the same way that fish don't understand wetness.
15:10:11 <lambdabot> I will never forget.
15:10:16 <bitemyapp> Welkin: what is?
15:10:22 <ReinH> ski: :p
15:10:31 <AaronFriel> I agree with that
15:10:32 * ski is still waiting for AaronFriel to appear in #haskell-overflow
15:10:36 <ReinH> Welkin: are you building up some other structure lazily? Did you heap profile it?
15:10:38 <ReinH> ski: I am not :D
15:10:43 <bitemyapp> Welkin: I actually tried to explain to Tibbe that his streaming thing in Cassava wasn't really going to help that much with memory use relative to something like Pipes but he didn't listen.
15:10:47 <bitemyapp> ReinH: no no
15:10:48 <bitemyapp> ReinH: it's Cassava's fault.
15:10:51 <bitemyapp> ReinH: I've profiled this before.
15:10:54 <ReinH> ski: I'm used up my arguing for the sake of arguing quota for today
15:10:56 <ReinH> bitemyapp: ah, great
15:11:03 <bitemyapp> same program that uses 20mb with Cassava's streaming, uses 600kb with Pipes.Csv
15:11:09 <Welkin> oh god fucking damn it
15:11:13 <ReinH> huh
15:11:16 <bitemyapp> ReinH: Cassava's streaming is an initially encoded lazy-list
15:11:20 <Welkin> I have been working on this parser for a long time now
15:11:21 <ReinH> (hint: use Pipes.Csv)
15:11:27 <ReinH> bitemyapp: huh
15:11:28 <bitemyapp> ^^ what ReinH said.
15:11:30 <Welkin> and wonder why it is useless to use conduit with it
15:11:33 <Welkin> great.......
15:11:34 <bitemyapp> ReinH: yeah...I was puzzled too.
15:11:39 <ReinH> welp
15:11:42 <bitemyapp> I don't really know why Tibbe thought that would do any good.
15:11:49 <ReinH> bitemyapp: initially encoded?
15:11:54 <bitemyapp> meaning, just a datatype.
15:11:55 <ReinH> aren't lists already initially encoded?
15:11:58 <ReinH> oh ok
15:12:05 <bitemyapp> I was trying to reinforce that it was just a datatype, sorry.
15:12:07 <ReinH> but not an action [] so no fusion?
15:12:10 <bitemyapp> as opposed to a CPS-y thing.
15:12:13 <bitemyapp> ReinH: YEP!
15:12:18 <ReinH> s/action/actual
15:12:20 <bitemyapp> unless I guess he expects you to layer your own incremental seq'ing on top of it or something?
15:12:21 <ReinH> bitemyapp: oh great :D
15:12:23 <bitemyapp> I don't really know.
15:12:30 <bitemyapp> but he didn't seem to get it when I reported the issue so I gave up.
15:12:40 <bitemyapp> and just point people to pipes.csv which does that work for you (on top of Cassava)
15:12:52 <bitemyapp> so you can keep your datatypes, you just use Pipes.Csv's thing.
15:13:00 <monochrom> interesting
15:13:07 <Welkin> bitemyapp: thanks for saving me days of frustration!
15:13:17 <bitemyapp> Welkin: np
15:13:31 <monochrom> but yeah, another lesson on "O(1) memory is not as simple as 'I am streaming' or 'I am not streaming'"
15:13:43 <bitemyapp> yeah.
15:13:46 <bitemyapp> Welkin: you can just like...ping me...and I can tell you if I've run into something before or not :P
15:13:55 <monochrom> but it's just a special case of "O(1) memory is not as simple as lazy evaluation"
15:13:57 <bitemyapp> I don't always watch the main channel that closely (-beginners mostly)
15:14:03 <bitemyapp> monochrom: yes :)
15:14:38 <monochrom> people look so hard for silver bullets and panacea
15:14:39 <Welkin> so is there not a simple way to do this using conduit + cassava?
15:14:52 <bitemyapp> Welkin: no
15:14:54 <bitemyapp> Welkin: use pipes
15:14:57 <Welkin> okay
15:14:58 <bitemyapp> if you want cassava
15:15:00 <Welkin> time to learn pipes
15:15:05 <bitemyapp> basically it's whatever you can dispose of more readily
15:15:08 <bitemyapp> conduit or cassava.
15:15:24 <bitemyapp> unless you want to make conduit-cassava (then you get to learn why the streaming API in Cassava isn't O(1) for memory usage)
15:15:35 <bitemyapp> but I was assuming you wanted to save time :)
15:16:24 <Welkin> I saw a conduit-cassava package on hackage, but it is abandoned
15:16:48 <Welkin> and it looks like the author had the same issue (it is littered with SCC pragmas )
15:17:33 <bitemyapp> Welkin: like walking into an old battlefield with corpses littered about
15:18:41 <bitemyapp> Welkin: what kills me is how small pipes-csv is.
15:19:16 <ReinH> bitemyapp: pipes is a nice abstraction. Planning on using it over conduit the next time I have to do something like that.
15:19:22 * hackagebot pcg-random 0.1.3.2 - Haskell bindings to the PCG random number generator.  https://hackage.haskell.org/package/pcg-random-0.1.3.2 (cchalmers)
15:19:39 <bitemyapp> Welkin: it's ~350 lines of Haskell code in total.
15:19:49 <bitemyapp> ReinH: yeah, I try to stick to Pipes when I can.
15:20:14 <bitemyapp> ReinH: my dives into Conduit were more thrashy, fewer bindings, lower quality bindings, etc.
15:20:30 <bitemyapp> I'd like to take time learning machines better but the Book Rules Everything Around Me, so who has time?
15:24:21 <ReinH> bitemyapp: which is weird because when I first tried them it seemed like conduit had the clearly superior ecosystem
15:25:29 <bitemyapp> well, one thing I wish Pipes had was twitter-conduit
15:25:39 <bitemyapp> I've considered porting it just so I can stop using Conduit for that.
15:38:47 <Welkin> how come the latest cabal guide has far less information than older ones?
15:38:47 <Welkin> https://downloads.haskell.org/~ghc/7.0.4/docs/html/Cabal/index.html
15:38:55 <Welkin> that has tons of information
15:39:58 <Welkin> this has much less: https://www.haskell.org/cabal/users-guide/installing-packages.html
15:40:08 <Welkin> the old guide has the information I needed
15:40:47 <Welkin> ah
15:40:53 <Welkin> I just went to the wrong url
15:40:54 <Welkin> https://www.haskell.org/cabal/users-guide/
15:41:08 <Welkin> but there should be a link back to the main page
15:41:17 <Welkin> otherwise people will get confused, like me
15:42:00 <davik> I'm not so sure how exactly laziness works, if I want to normalize a list, is this the right way to do it? map (/sum somelist) somelist
15:42:20 <Welkin> normalize?
15:42:23 <Welkin> what does that mean?
15:42:23 <srhb> davik: "normalize?"
15:42:26 <srhb> Eh, too slow.
15:42:53 <davik> sorry bad name, make the sum one 
15:43:01 <srhb> Do you mean to sum elements in a list?
15:43:04 <srhb> > sum [1..10]
15:43:05 <lambdabot>  55
15:43:23 <shachaf> davik: That looks like a reasonable way to do it. Is there an issue?
15:43:24 <davik> no it returns the right thing, but I'm wondering if there's a faster way
15:43:24 <ReinH> davik: map sum somelist will take a list of lists of numbers and give you the sum of each sublist.
15:43:33 <shachaf> Is your list huge or something?
15:43:34 <tommd> > let normalize xs = map (/ fromIntegral (sum xs)) xs in [1..10]
15:43:36 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:43:44 <srhb> Oh, I get what you're saying now.
15:43:48 <srhb> Sorry.
15:43:49 <tommd> > let normalize xs = map (/ fromIntegral (sum xs)) xs in normalize [1..10]
15:43:51 <lambdabot>      No instance for (Show b0)
15:43:51 <lambdabot>        arising from a use of ‘show_M75730869324749486008259’
15:43:51 <lambdabot>      The type variable ‘b0’ is ambiguous
15:43:52 <shachaf> If there was a faster way, how would you tell that it's faster?
15:44:08 <davik> potentially huge, I'm wondering whether ghc sums the list more than once
15:44:25 <tommd> grrr, but at any rate, is the sort of notion that these are floats that should sum to one and retain the same relative weights correect?
15:44:58 <ReinH> Ah, I see.
15:45:07 <ReinH> @src map
15:45:07 <lambdabot> map _ []     = []
15:45:07 <lambdabot> map f (x:xs) = f x : map f xs
15:45:23 <ReinH> davik: f is shared
15:45:46 <davik> ReinH: so the sum is only evaluated once correct?
15:46:09 <ReinH> davik: well, f is (/sum somelist)
15:46:13 <benzrf> can i somehow work with complex ints
15:46:18 <benzrf> :[
15:46:22 <arkeet> :[
15:46:29 <Welkin> 4 :+ 0
15:46:32 <davik> Rein:G thanks
15:46:32 <Welkin> > 4 :+: 0
15:46:34 <lambdabot>      Not in scope: data constructor ‘:+:’
15:46:34 <lambdabot>      Perhaps you meant ‘:+’ (imported from Data.Complex)
15:46:37 <arkeet> Complex Int has no Num instance.
15:46:37 <Welkin> > 4 :+ 0
15:46:39 <lambdabot>  4 :+ 0
15:46:41 <benzrf> arkeet: exactly
15:46:52 <ReinH> davik: so no, I'm not sure that the sum would be shared
15:46:59 <arkeet> > 4 :: Complex Int
15:47:00 <lambdabot>      No instance for (RealFloat Int) arising from the literal ‘4’
15:47:00 <lambdabot>      In the expression: 4 :: Complex Int
15:47:20 <ReinH> benzrf: no, no you can't.
15:47:37 <benzrf> :\
15:47:41 <davik> ReinH: no? so should I do a seq to evaluate the sum first?
15:48:11 <ReinH> davik: no, e.g., let theSum = sum theList in map (/theSum) theList
15:48:39 <davik> ReinH: oh ok thanks I'll do that then
15:49:12 <ReinH> davik: You shouldn't expect GHC to memoize a function for you.
15:49:29 <ReinH> Or to do common subexpression elimination
15:49:36 <bitemyapp> ReinH: if you don't want to get surprised, anyway :)
15:49:55 <ReinH> bitemyapp: I mean, yes, that was the goal-directed part of the ought that I skipped. ;)
15:49:56 <davik> makes sense
15:50:14 <ReinH> you shouldn't expect those things if you don't want to be wrong.
15:50:35 <ReinH> If you do want to be wrong then by all means, go ahead.
15:59:24 * hackagebot glue 0.2.0 - Make better services.  https://hackage.haskell.org/package/glue-0.2.0 (seanparsons)
16:04:24 * hackagebot foldl-transduce 0.0.1 - Transducers for folds from foldl.  https://hackage.haskell.org/package/foldl-transduce-0.0.1 (DanielDiazCarrete)
16:26:45 <nshepperd> hmm, the haskell report says (/sum list) should be translated into (\x -> x / sum list), which means it wouldn't be shared?
16:27:15 <ReinH> nshepperd: I don't see how it could be shared.
16:27:40 <ReinH> Unless GHC were to optimize it somehow, which I don't think it does.
16:27:59 <ReinH> nshepperd: I said that "f" would be shared. f is indeed shared. It is only evaluated to WHNF once. ;)
16:28:02 <nshepperd> well, if it was implemented as flip (/) (sum list)
16:28:15 <nshepperd> then it would stored as an argument to the closure
16:28:58 <nshepperd> I think
16:29:08 <ReinH> Would it? You're probably right.
16:30:18 <yashinbasement> Hi I have defined a tree data Tree = Leaf | Node String Int Tree Tree
16:30:40 <yashinbasement> when I try to declare a function of following type 
16:30:40 <yashinbasement> insert_bst :: Tree -> String -> Int -> Nothing 
16:30:51 <ski> have you defined a type `Nothing' ?
16:31:19 <ski> perhaps you meant to say `insertBst :: Tree -> String -> Int -> Tree' ?
16:32:12 <ski> (or maybe even `insertBst :: String -> Int -> Tree -> Tree')
16:32:37 <nshepperd> in this case I think ghc follows the haskell report though
16:32:38 <yashinbasement> I get an error every time
16:33:00 <ski> (note that there is a data constructor `Nothing' that belongs to the type constructor `Maybe'. however, if you use `Nothing' in a type like above, then it's unrelated to that data constructor)
16:33:18 <ski> yashinbasement : what is the error ?
16:33:27 <yashinbasement> saying lack of binding
16:34:07 <yashinbasement> even I try 
16:34:08 <yashinbasement> insert_bst :: Tree -> String -> Int -> Tree
16:35:37 <nshepperd> yashinbasement: that means it's waiting for you to define the function
16:35:44 <yashinbasement> ohh
16:35:53 <yashinbasement> haha
16:35:55 <yashinbasement> thanks
16:40:10 <nshepperd> ReinH: oh, looks like it is actually shared, in ghc
16:40:38 <nshepperd> I tested it in ghci
16:41:37 <nshepperd> (I almost reached the opposite conclusion because i forgot that such things have to be monomorphic to be shared at all >_>)
16:44:26 * hackagebot servant-JuicyPixels 0.2.0.0 - servant-JuicyPixels  https://hackage.haskell.org/package/servant-JuicyPixels-0.2.0.0 (TvH)
16:45:15 <Hafydd> Good package description.
16:51:38 <ReinH> nshepperd: the flip version?
16:59:23 <nshepperd> all of them
17:00:58 <nshepperd> I think it does actually translate (/sum list) into something similar to flip (/) (sum list) so
17:01:13 <Bruuuuuuno> What's the easiest way to get into haskell GUI? It have so much option I don't know which one to choose
17:02:38 <nshepperd> I know that (sum list /) is translated into (/) (sum list) so it's not very surprising that it's shared in that case
17:04:18 <Cale> Bruuuuuuno: It depends on what sort of GUI you want to write and what else you might be comfortable with. Gtk2Hs is probably the most mature/sophisticated library, but it's not really very simple. If you just want to get some graphics on the screen, perhaps Gloss is a good place to start.
17:04:27 * hackagebot pipes-csv 1.4.1 - Fast, streaming csv parser  https://hackage.haskell.org/package/pipes-csv-1.4.1 (WilliamCasarin)
17:04:44 <Bruuuuuuno> okay thanks Cale
17:04:57 <Cale> Bruuuuuuno: What sort of program are you writing?]
17:05:17 <Bruuuuuuno> I just want to get into FRP, I'll do a chess engine
17:06:26 <Cale> The FRP library I'm most excited about right now is Reflex. You could use reflex-dom as a web frontend. :)
17:07:58 <Cale> I'm planning to eventually do a board game kind of similar to chess using reflex-dom, though it's missing some facilities that I'd like to have, like canvas support and better mouse events (I might end up implementing them myself, but if I wait long enough, probably people who know the relevant code better will do it for me)
17:08:58 <Bruuuuuuno> so that reflex-dom is a gui librairy or something?
17:09:50 <Cale> Bruuuuuuno: Well, it's a way to use the Reflex FRP system to manage the DOM (Document Object Model) on a web page.
17:10:06 <Cale> Bruuuuuuno: You compile Haskell to Javascript which runs in your browser, it's pretty cool.
17:10:14 <athan> @check \x -> sequence (sequence x) == x -- should this work, given a correct instance?
17:10:16 <lambdabot>  <hint>:1:102:
17:10:16 <lambdabot>  parse error (possibly incorrect indentation or mismatched brackets)
17:10:30 <athan> Also, would http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Int be a valid one?
17:10:31 <Bruuuuuuno> I've heard bad comment about ghcjs, is it really stable?
17:10:37 <athan> wait, wtf
17:10:39 <johnw> athan: no
17:10:42 <johnw> [Nothing] -
17:10:45 <athan> [[ Int ]]
17:10:49 <johnw> -> Nothing -> ?
17:10:59 <johnw> [Nothing, Just 3, Nothing] -> Nothing -> ?
17:11:20 <athan> johnw: Wouldn't a lossless one like [[ Int ]] work?
17:11:35 <johnw> try it
17:11:58 <athan> @check \x -> sequence (sequence x) == (x :: [[ Int ]])
17:12:00 <lambdabot>  *** Failed! Falsifiable (after 5 tests and 1 shrink):
17:12:00 <lambdabot>  [[2,-4,0],[]]
17:12:03 <athan> blast!
17:12:04 <karshan> Bruuuuuuno: Yampa is also a nice FRP library for doing games. Its backed by opengl so possibly simpler to get started with.
17:12:12 <athan> thanks johnw
17:12:50 <johnw> athan: the reason is that >>= discards information
17:13:01 <johnw> I think only sequenceA for Free would work
17:13:08 <johnw> that is, Free over Free
17:13:33 <Cale> Bruuuuuuno: Stable enough that people are starting to use it in production.
17:13:59 <Bruuuuuuno> is it easy to install on windows?
17:14:05 <Cale> Bruuuuuuno: I'm starting a new job using reflex-frp to do a company's web frontend.
17:14:17 <Cale> I don't know about windows, but it ought to be.
17:14:41 <Cale> The nice thing about web stuff is that it's reasonably OS-agnostic :)
17:15:24 <nshepperd> johnw: I'm not sure it's to do with >>=
17:15:28 <ski> @check \x -> sequenceA (sequenceA x) == (x :: ZipList (ZipList Int))
17:15:30 <lambdabot>  *** Failed! Falsifiable (after 5 tests):
17:15:30 <lambdabot>  ZipList {getZipList = [ZipList {getZipList = [-1,-4]},ZipList {getZipList = ...
17:15:55 <johnw> nshepperd: no?
17:15:59 <nshepperd> but you just can't necessarily 'undo' <*> either
17:16:10 <johnw> ah, I see what you mean
17:16:30 <johnw> let me try it
17:17:23 <arkeet> > sequenceA (ZipList [1,2])
17:17:24 <lambdabot>      No instance for (Show (f0 (ZipList a0)))
17:17:25 <lambdabot>        arising from a use of ‘show_M91981609414501691669870’
17:17:25 <lambdabot>      The type variables ‘f0’, ‘a0’ are ambiguous
17:17:27 <arkeet> er
17:17:43 <arkeet> > sequenceA (ZipList [ZipList [1,2],ZipList [3,4]])
17:17:44 <lambdabot>  ZipList {getZipList = [ZipList {getZipList = [1,3]},ZipList {getZipList = [2...
17:17:52 <arkeet> > sequenceA (ZipList [ZipList [1,2],ZipList [3]])
17:17:53 <lambdabot>  ZipList {getZipList = [ZipList {getZipList = [1,3]}]}
17:19:11 <musamusamusa> hello!
17:19:34 <musamusamusa> how are you haskellers?
17:19:45 <musamusamusa> Who loves cats? (category theory)
17:20:26 <MP2E> I do, though I can't claim to understand most of it
17:20:29 <MP2E> but the parts I understand I love!
17:20:37 <musamusamusa> yeah! me too!!
17:20:39 <lethjakman> Anyone have a clue what I'm doing wrong with mime-mail-ses? https://gist.github.com/lethjakman/c52b0c0c195d4eb7143e#file-sendemail-hs-L2-L12
17:21:19 <lethjakman> it throws a type error that Manager doesn't match master0 -> Manager...however I thought that would get the manager?
17:21:22 <lethjakman> no?
17:23:52 <ski> @check \x -> (\y -> all (not . null . getZipList) y && all id (zipWith (==) y (tail y))) (getZipList x) ==> (sequenceA (sequenceA x) == (x :: ZipList (ZipList Int)))
17:23:54 <lambdabot>  *** Gave up! Passed only 77 tests.
17:25:20 <ski> @check \x -> (\y -> all (not . null . getZipList) y && all id ((\z -> zipWith (==) z (tail z)) (map length y))) (getZipList x) ==> (sequenceA (sequenceA x) == (x :: ZipList (ZipList Int)))
17:25:21 <lambdabot>  *** Gave up! Passed only 93 tests.
17:25:23 <johnw> athan: my assumption was wrong: https://gist.github.com/6f50e4ea03c03c11d5bc
17:26:46 <monochrom> has @check become a defeatist? if it finds a counterexample, it claims triumph at defeating you. and if it can't find a counterexample, it claims defeat. :)
17:27:08 <johnw> it only gets paid when it falsifies a theory
17:28:22 <MarcelineVQ> Is @check using quickcheck?​ how does it work?
17:28:43 <kadoban> Yeah it uses quickcheck
17:29:28 * hackagebot these 0.6.0.0 - An either-or-both data type, with corresponding hybrid error/writer monad transformer.  https://hackage.haskell.org/package/these-0.6.0.0 (JohnWiegley)
17:30:37 <xplat> quickcheck can give up when it has trouble generating as many examples that pass the precondition as it was asked to test
17:31:03 <xplat> if your precondition is too hard to satisfy you'd best write a custom generator
17:38:02 <monochrom> oh, I see. thanks.
17:44:55 <merl1n> how good can yongnuo yn-560 ii light up a small room (say 160ft2 or 15m2 max)? can i bring the light of the room up so much that out of the window view will be visible?
17:45:07 <merl1n> wrong channel :( 
17:56:53 <bitemyapp> johnw: useful datatype.
17:58:41 <mniip> data Cothese a b = Neither
18:04:17 <blaird> Hey, what are the tricks to installing packages in haskell? Because this is brutal
18:05:02 <blaird> I'm using sandboxes, and trying to avoid ubuntu repositories, but I swear I've been fighting this for hours
18:14:00 <exio4> blaird: what are you trying to install? 
18:15:57 <exio4> blaird: maybe you're trying to something "too old"? (and the dependencies have changed, the bounds are too tight and/or that version can't be compiled with a newer GHC, just guessing, may or may not be this though)
18:16:22 <blaird_> I may have jumped from too old to too new
18:16:49 <athan> I wish there was a way to easily set a type signature for inline do-blocks, to show which monad they're operating in
18:17:01 <athan> er - is there one? C:
18:17:10 <exio4> athan: _ ? 
18:17:17 <blaird_> I was on ghc-7.63? and now I'm on 7.10. But Accelerate-Cuda is a pain
18:17:19 <exio4> _ $ do { ... } 
18:17:31 <blaird_> Has anyone gotten that running before?
18:17:40 <athan> exio4: I'm thinking of something like `do {-# type sig here #-}; x <- foo; return $ x * 1`
18:18:04 <exio4> oh sorry, read "see" not "set" 
18:18:24 <exio4> athan: x <- foo :: m stuff ; (x :: stuff) <- foo 
18:18:42 <athan> exio4: Ahh okay cool
18:18:45 <athan> thank you!
18:19:12 <mniip> do _ <- return undefined :: m a
18:19:46 <exio4> athan: make sure to have ScopedTypeVariables enabled and use it if you're working with polymorphic stuff though
18:21:43 <exio4> blaird_: I don't know, I haven't used that library, sorry :/
18:48:12 <kadoban> There's no named alias for [minBound .. maxBound], is there?
18:49:01 <ski> not afaik
18:49:24 <ski> one could name it `domain' or `universe', maybe
18:50:53 <kadoban> Yeah seems like I use it a lot so I thought I'd ask. Not really worth defining if it doesn't exist already probably though, in my case.
19:04:32 * hackagebot microlens 0.3.3.0 - A tiny part of the lens library which you can depend upon  https://hackage.haskell.org/package/microlens-0.3.3.0 (Artyom)
19:06:33 <osa1> wow I didn't know we can UNPACK an IORef
19:06:43 <johnw> the description of microlens is grammatically ambiguous
19:06:51 <kadoban> "which you can depend on" :-/
19:07:15 <johnw> I read it either as, minimizing my dependencies yet having some of lens, or, a subset of lens that is more dependable than the whole thing
19:08:08 <merl1n> osa1 unpack?
19:08:50 * geekosaur is pretty sure (a) the former, (b) deliberate ambiguity :)
19:13:16 <osa1> merl1n: the {-# UNPACK #-} thing
19:13:47 <osa1> merl1n: https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/pragmas.html#unpack-pragma
19:16:18 <osa1> UNPACK syntax is horrible, I'm wondering if we could have !! instead.
19:16:32 <osa1> !: Strict, !!: strict and also unpacked
19:17:15 <osa1> since UNPACK implies !
19:19:33 * hackagebot microlens-ghc 0.2.1.0 - Orphan instances of microlens classes for packages coming with GHC (array, bytestring, containers)  https://hackage.haskell.org/package/microlens-ghc-0.2.1.0 (Artyom)
19:19:35 * hackagebot microlens-mtl 0.1.5.0 - microlens support for Reader/Writer/State from mtl  https://hackage.haskell.org/package/microlens-mtl-0.1.5.0 (Artyom)
19:19:37 * hackagebot microlens-platform 0.1.3.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.1.3.0 (Artyom)
19:20:29 * ski . o O ( `xs !! !!n' )
19:22:13 <Cale> osa1: It's probably doable, but a nice thing about {-# UNPACK #-} as syntax is that it's ignored by implementations which don't support the feature, without affecting the semantics of the program at all.
19:26:12 <jmcarthur_> osa1: i knew you could unpack and ioref, but i haven't yet bothered to figure out what that means. kind of weird that i don't actually know how many indirections an ioref has
19:31:21 <osa1> I'm wondering if {-# UNPACK #-} !Int and {-# UNPACK #-} !(IORef Int) are compiled to same layouts. e.g. something like a struct of ints in both cases.
19:32:47 <nshepperd> IORef Int is a pointer to a boxed int
19:34:18 <rpfun> when using type literals is it better to have a type signature like "f :: (n >= 1) => Proxy n -> a" or "f :: Proxy (n + 1) -> a"?
19:34:28 <osa1> nshepperd: see the unpack and ! parts
19:34:33 <nshepperd> so that would only work if it was an IORef Int# or something (which doesn't exist)
19:34:53 <nshepperd> osa1: that just means the pointer is strict, not that its target is
19:35:31 <osa1> nshepperd: what do you mean by pointer is strict? I have UNBOX which should remove the pointer.
19:35:52 <osa1> how many pointers involved in IORef Int by default? 2?
19:36:54 <nshepperd> I think so
19:37:10 <nshepperd> the "meaning" of IORef is a pointer to a boxed value
19:37:24 <osa1> you know, -ddump-simpl etc. are nice but it'd be even better if we could dump data structure layouts ...
19:37:36 <osa1> wow, that sounds horrible. two indirections for mutable ints...
19:40:22 <dramforever> that's how problems are solved in computer science =P
19:42:29 <jmcarthur_> i do wish we could just have mutable fields without all the indirection
19:42:46 <fiddlerwoaroof> @pl do {a<-(C.matchUpToX digit 2);eof; return a
19:42:46 <lambdabot> (line 1, column 4):
19:42:46 <lambdabot> unexpected '{'
19:42:46 <lambdabot> expecting variable, "(", operator or end of input
19:42:54 <osa1> I still think that UNPACK !(IORef Int) may be indirection-free. at least in theory.
19:43:00 <osa1> too bad there's no easy way to verify this
19:43:01 <jmcarthur_> yeah i don't think it is
19:43:02 <nshepperd> um, better way of putting it: `data T = T {-# UNPACK #-} !A` is I think pretty much equivalent to A itself, or `newtype T = T A`
19:43:25 <nshepperd> `data T = T {-# UNPACK #-} !(IORef Int)` is just a plain ol' IORef
19:43:32 <jmcarthur_> i think if you unbox and then rebox a MutVar# it still points to the same thing. i don't know how else it could work.
19:43:35 <rpfun> in case anyone is interested in the answer, generically signatures that use "1 <= n" are easier to work with than signatures that use "n + 1"
19:44:12 <nshepperd> besides, I don't think the number of indirections really matters so much as whether the target is in cache, anyway
19:44:18 <osa1> nshepperd: well of course you don't do this for data types with just one field.
19:44:37 <osa1> nshepperd: it actually matters, I have some benchmarks.
19:44:45 <nshepperd> unless you have thousands of these being used at once, in which case you probably want to use a mutable unboxed vector instead
19:44:45 <osa1> (let me find the URL)
19:44:57 <jmcarthur_> cache behavior is easier to understand without the indirection, at the very least.
19:45:15 <jmcarthur_> also easier on the gc
19:45:32 <osa1> yeah good point with gc
19:45:47 <nshepperd> osa1: what I mean is that a plain old IORef contains a boxed value. therefore so will your datatype
19:45:48 <osa1> nshepperd: https://github.com/osa1/spec_bench even the iteration(not using the values) are faster with unboxed ints
19:46:49 <osa1> maybe because the GC
19:51:53 <nshepperd> osa1: danger! sum is a lazy foldl
19:52:05 <nshepperd> foldl' (+) 0 will be a lot faster
19:52:38 <slack1256> but with -O2  will catch that and transform it
19:52:44 <slack1256> *ghc
19:55:02 <nshepperd> oh yeah, it should do so
19:56:01 <camm_v222> Hi guys, I want to create an app on Clojure for Android, but I have a few problems trying to download Android SDK (for Fedora GNU/Linux).  I can't download the SDK!!! I know it sounds silly but I just get on a loop trying to download it from here ( https://developer.android.com/intl/zh-cn/sdk/installing/index.html?pkg=tools ). May you help me, please?
19:56:16 <nshepperd> anyhow, I don't think it's possible to store a mutable unboxed value like that
19:56:48 <camm_v222> Sorry
19:57:18 <camm_v222> I just wrote in the wrong chanel. :-$
19:57:18 <nshepperd> at least because extracting the IORef and then putting it back in the container would result in a different mutable value
19:57:34 <nshepperd> which would break the IORef semantics
19:59:37 <nshepperd> huh, the sum is still a lot slower using sum instead of foldl' (+) 0 even with ghc -O2
19:59:44 <nshepperd> that's odd
20:03:20 <pacak> nshepperd: Check generated Core
20:08:00 <nshepperd> I'm not good at reading core :/
20:09:21 <pacak> nshepperd: stackoverflow.com/questions/6121146/reading-ghc-core
20:10:17 <shachaf> Generated Core from what?
20:11:38 <nshepperd> aha, writing 'listSum :: [Int] -> Int; listSum xs = sum xs' got it to strictify the loop
20:12:44 <shachaf> Oh, yes, GHC often doesn't inline if you don't eta-expand.
20:14:22 <glguy> Welkin: You around?
20:14:50 <nshepperd> I had '{-# NOINLINE listSum #-}' so I could find it in Core, but I expected it to inline the sum
20:16:07 <nshepperd> er, that is, 'listSum = sum' didn't result in the sum being inlined and then specialized for [Int] and so on
20:16:52 <nshepperd> I guess it makes sense that it wouldn't though, because you might expect sharing or something if you just write '= sum'
20:17:53 <shachaf> If you had sum = \x -> ..., it would inline.
20:18:00 <shachaf> But not with sum x = ...
20:18:07 <shachaf> At least that was the situation at one point.
20:18:46 <nshepperd> ohhh
20:26:19 <nshepperd> oh, -dsuppress-all makes it a lot more readable
20:26:57 <shachaf> -dsuppress-all suppresses a little bit too much, but it's a good start.
20:28:01 <glguy> ?tell Welkin I played with your CSV code from earlier using "machines". The memory problem turned out to be related to your Mean type (maybe you figured that out at the time) http://lpaste.net/4123090233891749888
20:28:01 <lambdabot> Consider it noted.
20:42:32 <Welkin> glguy: you really got it working with O(1) memory?
20:42:40 <bycn82> what is monoid?
20:42:52 <Welkin> I thought the issue was `decode` from Data.Csv.Incremental
20:43:05 <Welkin> that's what my profiling showed, and what bitemyapp confirmed
20:43:41 <ski> bycn82 : an associative operation with a neutral element
20:43:48 <nitrix> bycn82: The way it was explained the monoid is an associative binary operation and a neutral element.
20:43:57 <nitrix> * to me
20:44:04 * ski blinks
20:44:12 <bycn82> ski: yes, I read from the document, but i dont understand why haskell created this concept,
20:44:19 <ski> it didn't
20:44:22 <ski> math created it
20:44:29 <bycn82> ski: how to use it 
20:44:39 <dramforever> use the functions
20:44:50 <bycn82> ski: how it was used in the real world programming
20:45:07 <nitrix> > (getFirst $ Just 1) `mappend` (getFirst $ Just 2)
20:45:08 <lambdabot>      Couldn't match expected type ‘First a’
20:45:08 <lambdabot>                  with actual type ‘Maybe Integer’
20:45:08 <lambdabot>      In the second argument of ‘($)’, namely ‘Just 1’
20:45:10 <dramforever> it's used in the writer monad
20:45:14 <ski> whenever you want to combine a sequence of elements into a single element in a grouping-independent way
20:45:44 <nitrix> Mhhh...
20:45:47 <ski> bycn82 : summing, "producting", concatenation, logging, &c.
20:46:06 <bycn82> for example, summing,
20:46:29 <bycn82> how monoid was used in "summing"?
20:46:42 <dramforever> imho monoids aren't really as useful as some other structures
20:46:51 <ski> > foldMap Sum [1,2,3,4]
20:46:53 <lambdabot>  Sum {getSum = 10}
20:46:57 <ski> > foldMap Product [1,2,3,4]
20:46:59 <lambdabot>  Product {getProduct = 24}
20:47:01 <nitrix> > getFirst $ (First $ Just 1) `mappend` (First $ Just 2)
20:47:02 <lambdabot>  Just 1
20:47:05 <glguy> Welkin: yeah, with the fix it ran in about 3MB constant
20:47:08 <nitrix> bycn82: There you go :)
20:47:12 <ski> > foldMap First [1,2,3,4]
20:47:13 <lambdabot>      No instance for (Show a0)
20:47:14 <lambdabot>        arising from a use of ‘show_M282516087832564103513123’
20:47:14 <lambdabot>      The type variable ‘a0’ is ambiguous
20:47:52 <ski> > foldMap (First . Just) [1,2,3,4]  -- rather
20:47:53 <lambdabot>  First {getFirst = Just 1}
20:48:14 <ski> > foldMap (First . Just) []
20:48:15 <lambdabot>  First {getFirst = Nothing}
20:48:25 <nitrix> Yeah, First expects Maybes.
20:48:57 <ski> bycn82 : you can `foldMap' over any `Foldable' structure, not just lists ..
20:49:57 <Welkin> glguy: I just went through the Pipes tutorial and am converting my program to use pipes-csv
20:50:04 <Welkin> I'll see how that goes
20:50:04 <bycn82> foldMap
20:50:04 <bycn82>   :: (Data.Monoid.Monoid m, Foldable t) => (a -> m) -> t a -> m
20:50:08 <Welkin> machines looks interesting too
20:50:29 <ski> > foldMap (Sum &&& ((:[]) . show)) [1,2,3,4]
20:50:30 <lambdabot>  (Sum {getSum = 10},["1","2","3","4"])
20:50:58 <ski> @type fold
20:50:59 <lambdabot> (Foldable t, Monoid m) => t m -> m
20:52:35 <mauris_> personally i think i rarely write code myself that works "for all monoids" (well i guess Writer stuff? sometimes) but i use a lot of existing functions that work for all monoids (like foldMap!) in many different ways
20:53:06 <ski> bycn82 : if you know you have a monoid, then you can also change the grouping at will. e.g. by building a roughly balanced binary tree, and then folding on that, possibly computing parallel branches in parallel
20:53:37 <mauris_> so to me monoids are "useful in code" in the sense that so many things are solved by just realizing "oh, that's just $monoid_function for the $foo_monoid!"
20:53:43 <Welkin> can anyone explain Pipes.PRelude.foldl?
20:53:55 <Welkin> what is the extra parameter (x -> b)?
20:54:05 <Welkin> fold' :: Monad m => (x -> a -> x) -> x -> (x -> b) -> Producer a m r -> m (b, r) 
20:54:37 <EvanR> a monoid is just a category with one object
20:54:48 <ski> Welkin : presumably some kind of "finalizer" function ?
20:55:00 <Welkin> would id work?
20:55:12 <c_wraith> EvanR: pfft. a category is just a generalization of monoids. :P
20:55:15 <ski> probably
20:56:06 <ski> Welkin : `forall b. (x -> b) -> m (b,r)' should be iso to `m (x,r)', by yoneda ..
20:56:07 <mauris_> why does monoid end in -oid anyway? "1. Of similar form to, but not the same as."
20:56:30 <mauris_> is it similar to a... mon
20:56:51 <c_wraith> mauris_: it's all similar to one thing.  (that one thing being the single object in the category)
20:57:34 <EvanR> mauris_: reading this http://math.stackexchange.com/questions/156952/why-the-terminology-monoid
20:58:26 <EvanR> a groupoid is a category with inverses
20:58:41 <EvanR> a monoid is a category with one object
20:58:48 <EvanR> shrug
21:00:53 <EvanR> it also has one operation as opposed to two like a ring
21:03:35 * ski . o O ( `fold (singleton,x) = x; fold (concat (m0,m1),x) = fold (m0,fold (m1,x))' )
21:04:43 <EvanR> mauris_: obv monoid = mono id, one identity ;)
21:07:43 <mauris_> wow "Prove that a monoid has only mono id." would be a good joke way to phrase the canonical "first exercise in every abstract algebra book"
21:11:59 <Alas`> Hello #haskell, can you help me overcome my sadness at the moment?
21:12:03 <Welkin> hm
21:12:09 <Welkin> any help with pipes?
21:12:56 <Welkin> decode HasHeader P.stdin >-> P.concat >-> convert >-> P.fold' (<>) mempty id >-> P.stdoutLn
21:13:02 <Welkin> where convert is a Pipe
21:13:08 <erisco> I am discovering there are beautiful properties about N-valued logics in general
21:13:12 <Welkin> I don't think I am using fold' right
21:13:15 <erisco> has there been research done on this?
21:13:36 <erisco> have read https://en.wikipedia.org/wiki/Many-valued_logic but it talks about specific logics
21:15:18 <erisco> Welkin, if you are asking a pipes question maybe I can help? I am your pipes nub on call
21:15:39 <Welkin> erisco: yeah
21:15:59 <EvanR> true, false, and file-not-found
21:16:08 <EvanR> beautiful
21:16:20 <Welkin> I think I see one of the problems: fold' folds over a Producer, and decode produces a Producer
21:17:04 <Welkin> so...
21:17:18 <Welkin> I cannot build an Effect with this then
21:17:26 <Welkin> so I can just use fold' at the top level?
21:18:15 <erisco> Welkin, I didn't catch the first end of your question
21:18:34 <Welkin> I am trying to build a pipeline with pipes
21:18:43 <Welkin> I pipes-csv, actually
21:19:34 <Lokathor> Illegal equational constraint GHC.Exts.Item l ~ (t, t, t) (Use GADTs or TypeFamilies to permit this)
21:19:36 <Lokathor> sadness
21:20:02 <Lokathor> the tutorial mentioned nothing of this
21:20:04 <Welkin> decode >-> P.concat >-> convert (this is a pure function lifted to a Pipe) >-> fold' (<>) mempty id >-> print the result
21:20:12 <EvanR> gadts are so cool use them anyway
21:20:20 <c_wraith> Lokathor: that's sad about that, unless you're explicitly trying to avoid TypeFamilies and GADTs?
21:20:39 <Lokathor> well, are they just some pragma i turn on?
21:20:39 <ski> erisco : what kind of properties do you have in mind ?
21:20:40 <Lokathor> or what
21:20:56 <Lokathor> i'm just trying to follow this tutorial for gl http://dpwright.com/posts/2015/03/25/the-haskell-gl-package/
21:20:57 <shachaf> GHC.Exts.Item is a type family.
21:21:02 <c_wraith> Lokathor: sure.  Throw something like {-# LANGUAGE TypeFamilies #-} at the top of the file.
21:21:14 <Lokathor> and triangulate is giving me that error
21:21:19 <erisco> ski, I haven't completed all my thinking on it yet, and, well, I'd want to say it all at once, y'know
21:21:26 <ski> ok
21:21:38 <c_wraith> Lokathor: many people do assume basic familiarity with ghc's extension mechanism and not talk about it much.
21:21:39 <erisco> I am just wondering if n-valued logics have been considered in general in some paper
21:21:49 <ski> erisco : related to modal operations ?
21:22:04 <Lokathor> well it's odd because the post lists four other pragmas to put in
21:22:05 <Lokathor> but not that one
21:22:14 <erisco> there are n distinct values and some operations on those values, that's it
21:22:17 <erisco> so sure, modal fits
21:22:19 <Lokathor> maybe it worked without GADTs on GHC 7.8?
21:22:39 <c_wraith> Eh, type equality constraints have always needed GADTs or TypeFamilies
21:23:02 <c_wraith> More likely that the author just forgot it, or lost it in a copy/paste mishap, or something like that.
21:23:40 <erisco> there is no huge significance to it being a logic, it is just what prompted the ideas
21:24:30 <erisco> Welkin, I am looking for you
21:25:10 <c_wraith> that sounds mildly ominous
21:26:01 <EvanR> come out comeout wherever you are!
21:26:51 <c_wraith> and that's a notch past "mildly". :)
21:27:05 <Xe> https://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/Database-PostgreSQL-Simple.html#t:FromRow
21:27:15 <Xe> how would I use this for a table with 11 columns?
21:27:22 <c_wraith> how do I tell cabal to do a parallel build again?  -j ?
21:27:43 <Xe> yeah it's -jx
21:27:44 <Welkin> c_wraith: yes
21:27:47 <Xe> where x is the number of cpu's
21:27:52 <Welkin> but it should do it by default
21:28:08 <Welkin> -j means use all available cores
21:28:08 <c_wraith> I don't even know how many cores that box has...  And I just built it.  >_>
21:28:22 <EvanR> cat /proc/cpuinfo
21:28:43 <erisco> Welkin, roughly with pipes you're streaming values, so you send a value through and something plops out the other end
21:28:48 <c_wraith> ah hah!  4! (excitement, not factorial)
21:29:12 <Welkin> erisco: yes, I understand that
21:29:17 <erisco> Welkin, the fold eats all the values coming through the pipes and gives you one result
21:29:38 <Welkin> but I want to stream values in and fold over them, and wait until everything has been folded and the input ends before I do something with the result
21:29:42 <erisco> Welkin, so, you can take that one result and make a producer that produces it
21:29:47 <c_wraith> Xe: well, it's ugly, but you can use the [a] instance
21:30:22 <c_wraith> Xe: oh, wait, no you can't.  Unless all your columns are the same type. Whoops
21:30:26 <Welkin> the fold takes a Producer and outputs m (b,r)
21:30:36 <Welkin> so it's not in any of the Pipes moands any more
21:30:38 <Welkin> monads*
21:30:53 <Xe> c_wraith: yeah, https://gist.github.com/Xe/067c9a170eb1fc16adfb
21:30:55 <c_wraith> Xe: ok, paying more attention..  There's an instance for https://hackage.haskell.org/package/postgresql-simple-0.4.10.0/docs/Database-PostgreSQL-Simple.html#t::.
21:31:00 <erisco> Pipe is a Proxy, and Proxy is a monad
21:31:08 <c_wraith> Xe: that instance is the one that will do what you need.  Kind of ugly, but it'll work.
21:31:40 <Xe> yikes
21:31:59 <erisco> Welkin, also, yield :: (Monad m) => a -> Producer a m ()
21:32:11 <EvanR> Xe: shouldnt you make an instance for your type which has 11 fields
21:32:36 <c_wraith> Xe: or EvanR's suggestion
21:33:04 <Xe> EvanR: how would you do that though? All of the data is going to be needed from the database for any action with it.
21:33:40 <EvanR> i dont understand what you mean
21:33:44 <Xe> c_wraith: well I guess that will work, do you know what it would look like?
21:33:53 <Welkin> erisco: I understand those things
21:33:59 <Welkin> it's how to use a fold
21:34:22 <erisco> Welkin, well, if you want a complete picture, try  P.fold (<>) mempty id >=> yield
21:34:51 <erisco> wait hold on
21:34:53 <EvanR> Xe: instance FromRow Foo where fromRow = Foo <$> field <*> field <*> field ...
21:34:54 <c_wraith> Xe: it's super-uglily (as much as that word) flexible.  You could have a type like (Int, Text, Foo) :. (Bar, Int, Int)  and it would decode into that.
21:35:13 <Lokathor> dropbox interferes with stack in an annoying way
21:35:26 <EvanR> what is so great about a 11-ple
21:35:28 <Welkin> erisco: that is not an Effect
21:35:37 <Xe> EvanR: Ah, I misunderstood
21:35:46 <erisco> well you need to get a Proxy again
21:35:46 <c_wraith> Xe: it's more or less just glue for sticking together two other types that are instances of FromRow to become a new bigger instance of FromRow
21:35:48 <erisco> we'll get there
21:36:30 <Xe> c_wraith: I didn't know you could just add instances like that
21:36:33 * Xe is new to HS
21:36:56 <c_wraith> Xe: well, it depends on the instances and the types.  That type was made specifically to do that.
21:37:07 <c_wraith> Xe: it's not all that common to find that sort of thing.
21:37:36 <EvanR> usually you want to avoid tuples with arity > 2
21:37:43 <EvanR> and make a record
21:37:53 <erisco> Welkin, what Monad are you working in btw?
21:37:53 <c_wraith> Xe: But if you look at the instances list for FromRow, you find this -  (FromRow a, FromRow b) => FromRow ((:.) a b)
21:38:35 <c_wraith> Xe: that says "for any two different types a and b, (:.) a b is an instance of FromRow if a and b are instances of FromRow"
21:38:58 <Welkin> erisco: IO
21:39:16 <c_wraith> Xe: and "(:.) a b" is often written as "a :. b" with the TypeOperators extension enabled
21:41:06 <erisco> lift . P.fold (<>) mempty id :: (Monoid b, Monad m) => Producer b m () -> Proxy a a' c c' m b -- Welkin
21:42:35 <erisco> Welkin, you can of course just putStrLn, once you get your IO b, but if you want to go back into the land of Proxy, then there you go
21:43:14 <Welkin> erisco: I still don't get how to make this work
21:44:25 <erisco> Welkin, can you give me some other hints as to what you want?
21:46:00 <Welkin> I got it to build
21:46:03 <erisco> you've got some Producer p which is spitting out values, you fold this with  P.fold (<>) mempty id p  and this gives you a (Monoid b) => IO b
21:46:04 <Welkin> but it is not working
21:46:11 <erisco> lpaste
21:46:37 <Welkin> I had it working before (even with conduit) but it did not run in constant space
21:46:43 <Welkin> now it doesn't seem to do anything
21:46:47 <erisco> if you have an  IO b  you can just >>= putStrLn, or you can turn it into a Proxy over IO using lift
21:46:55 <erisco> can you lpaste your code?
21:47:18 <Welkin> http://lpaste.net/607163360378617856
21:48:23 <erisco> have to compile pipes-csv
21:48:27 <blaird_> Hey, I don't suppose anyone has had success installing accelerate-cuda?
21:49:15 <blaird_> I'm giving up on it for the night, but before I do I wanted to see if anyone has it installed so that I can find out what configuration worked for them
21:49:32 <erisco> Welkin, how do I interact with the program?
21:49:40 <Welkin> erisco: stdin
21:50:55 <erisco> okay, this is a bit hard for me to figure out because I'm not sure what expected input/output is
21:50:57 <Welkin> erisco: http://lpaste.net/607163360378617856
21:51:01 <Welkin> updated with a sample input
21:51:22 <Welkin> output it a list of statistics
21:51:24 <Welkin> is*
21:52:06 <Welkin> I wonder if P.concat is the issue?
21:52:25 <c_wraith> that sounds likely
21:53:21 <c_wraith> Welkin: that type signature looks a lot like a memory leak if used to create a list
21:53:44 <Welkin> ?
21:53:46 <c_wraith> Welkin: or really, if used to create anything that grows linearly with the input
21:53:48 <Welkin> it is not a list
21:54:05 <Welkin> it is a "sum"
21:54:24 <c_wraith> Still problematic if it's not strict.
21:54:34 <Welkin> c_wraith: what is?
21:54:40 <Welkin> I made all the data strict
21:54:50 <Welkin> and am using a strict fold
21:54:59 <Welkin> that si not the problem though
21:55:00 <c_wraith> Welkin: is P.concat a strict fold, though?
21:55:06 <Welkin> the output is wrong
21:55:09 <erisco> Welkin, okay, but I don't know what expected output is, so how do I know what is wrong
21:55:22 <Welkin> you will just see (,)
21:55:22 <erisco> like, you need to give me something I can know is wrong so I can help XD
21:55:40 <erisco> I see "Session ID: ... Page: ..., ())"
21:55:47 <erisco> left some stuff out with ...
21:55:51 <Welkin> er, well
21:55:54 <Welkin> the count will be wrong
21:56:03 <Welkin> far less than the number of rows in the input
21:56:10 <Welkin> it should be equal (minus the header)
21:56:20 <erisco> okay, I'll look at the count then
21:56:45 <Welkin> I get count: 1
21:56:50 <Welkin> so it only processes 1 row
21:56:52 <Welkin> and then aborts
21:57:02 <felixn> what should I do when my ghc upgrades?  wipe ".cabal", ".ghc" and start over?  having issues with ghc-mod looking for old sandbox directories
21:58:00 <Welkin> felixn: that sounds reasonable
21:58:28 <c_wraith> does ghc-mod have its own settings directory?
21:58:32 <Saizan> felixn: both cabal and ghc cope just fine, not sure about ghc-mod
21:58:43 <c_wraith> both .cabal and .ghc should be resilient to having multiple versions installed
21:59:04 <felixn> Saizan: not sure how to remove everything so I can properly rebuild ghc-mod
21:59:05 <Saizan> felixn: i'd try to keep .cabal more than i'd try to keep .ghc
22:00:32 <felixn> ok thanks!  I'll try building in a sandbox first before I blow everything away
22:00:36 <c_wraith> or maybe does ghc-mod keep a settings file in each directory it's used in?
22:00:45 <c_wraith> I'd really be looking for ghc-mod specific setting
22:00:46 <c_wraith> s
22:05:35 <erisco> Welkin, okay, after tracing it through, it is your 'convert' that is wrong
22:05:55 <c_wraith> sigh.  my parallel build hit the end of the topological sort.  Everything remaining depends on everything still to go before it.
22:06:32 <Welkin> erisco: how do I apply a pure function over part of the pipeline?
22:06:40 <Welkin> something like fmap
22:07:12 <Welkin> P.map ?
22:08:02 <Welkin> it works now :)
22:08:12 <Welkin> erisco: how did you conclude that `covert` was wrong?
22:08:45 <benzrf> is there an attoparsec thing that forces it to consume all input or fail
22:08:59 <Hijiri> parseOnly I think
22:09:34 <Hijiri> oh
22:09:38 <Hijiri> no, it doesn't do that, sorry
22:10:18 <Hijiri> attoparsec docs says you need to include EOF in your parser in conjunction with parseOnly
22:10:23 <Hijiri> in the haddocks for parseOnly
22:10:47 <Hijiri> https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-ByteString.html#v:parseOnly
22:10:54 <benzrf> eof appears nowhere in https://hackage.haskell.org/package/attoparsec-0.13.0.1/docs/Data-Attoparsec-Text.html
22:10:57 <benzrf> except in the middle of a word
22:10:58 <Welkin> wow, this is much better than before
22:11:05 <Welkin> 2 MB total memory useage
22:11:15 <Hijiri> it's endOfInput
22:11:16 <Welkin> non-streaming was 975 MB
22:11:35 <Welkin> also, it's now 7 times faster
22:11:42 <c_wraith> trickery!
22:12:16 <benzrf> now it doesnt seem to be backtraking :[
22:12:20 <Welkin> for 1 million rows in a csv
22:15:12 <erisco> Welkin, so, await >>= return . toStats >>= yield  is  await >>= yield . toStats  can just toss away the return here
22:15:29 <erisco> Welkin, that function waits for one value, maps it, and then returns the value, then it is done
22:16:14 <erisco> Welkin, think of these as routines, they are coroutines... if you write a routine which takes one value and returns one value and terminates, well, that's it, that is the end of the program
22:16:40 <erisco> Welkin, the only way more work is done is if it passes control to another routine (or recurses on itself for example)
22:16:52 <benzrf> some wacky shit is goin on here
22:17:29 <erisco> Welkin, what you intended to do was await, map, yield, then do that over and over again
22:18:02 <Welkin> erisco: pipeline = decode HasHeader P.stdin >-> P.concat >-> P.map toStats
22:18:06 <Welkin> that is what I am using now
22:18:09 <Welkin> and it works
22:18:12 <erisco> yes
22:18:21 <Welkin> is there a way to get rid of the concat though?
22:18:23 <erisco> because P.map loops over every value
22:18:44 <Welkin> it's just to pull out the Right value
22:18:46 <erisco> the concat is just doing  (Monoid b) => Either a b -> b
22:19:00 <Welkin> can I combine concat and map?
22:19:48 <erisco> btw, map uses 'for' under the hood, which you can also use
22:20:01 <Welkin> yeah, I was trying to use for
22:20:15 <Welkin> isn't ~> infix `for`?
22:20:37 <erisco> no
22:20:41 <Welkin> how would I use `for` in that situation though?
22:20:55 <Welkin> I would have to wrap the whole thing in the for
22:21:04 <erisco> so
22:21:08 <erisco> no
22:21:16 <Welkin> for (decode HasHeader stdin >-> P.concat) toStats
22:21:16 <erisco> I don't know what you mean "wrap the whole thing", but here
22:21:58 <erisco> for :: Monad m => Producer a m () -> (a -> Producer b m ()) -> Pipe a b m ()
22:22:02 <erisco> simplifying the types a bit
22:22:25 <erisco> so it takes some producer and applies a function to every value it yields
22:22:27 <Welkin> for (decode HasHeader stdin >-> P.concat) (lift . toStats)
22:22:38 <erisco> which gives you a Pipe
22:23:38 <benzrf> attoparsec isnt backtracking plz help
22:23:40 <erisco> well,  yield . toStats
22:23:46 <erisco> but yes, that is the basic idea
22:23:58 <Welkin> ah, yes
22:23:59 <Welkin> yield
22:24:00 <johnw> benzrf: you realize you need to offer some information to get some, yeah?
22:24:41 <benzrf> pfft
22:24:45 <erisco> Welkin, does it make sense to you how the original convert was wrong?
22:25:04 <Welkin> erisco: I think I see now
22:25:11 <benzrf> well
22:25:12 <Welkin> if any part of the pipeline terminates, the whole thing terminates
22:25:12 <johnw> paste the code, pastie the input, pastie the error, etc.
22:26:00 <benzrf> well
22:26:02 <benzrf> hmm
22:26:12 <benzrf> oh, crap
22:26:33 <erisco> Welkin, let echo = readLn >>= putStrLn   think of that program vs   let echo = readLn >>= putStrLn >> echo
22:26:37 <benzrf> oh nvm
22:26:56 <benzrf> is attoparsec known to behave weirdly when used under a transformer
22:27:05 <erisco> okay readLn might be wrong XD
22:27:06 <johnw> without more information, I have no idea what you're talking aobut
22:27:09 <erisco> how do you read a line of input
22:27:14 <Welkin> getLine
22:27:19 <erisco> what are side effects anyways
22:27:44 <benzrf> ;-;
22:27:47 <erisco> Welkin, your original convert was like the first echo
22:28:45 <erisco> Welkin, the for loop is like the second one
22:29:00 <Welkin> erisco: how would I write `convert` using for?
22:29:13 <erisco> Welkin, P.map toStats
22:29:30 <Welkin> erisco: convert = await >>= \x -> for x (yield . toStats)
22:30:02 <Welkin> erisco: I want to understand everything in terms of the primitives
22:30:15 <erisco> 'for' is not a primitive
22:31:14 <Welkin> I read through the pipes tutorial, but perhaps I'll give it another read through
22:31:26 <Welkin> yeah, `for` is defined in terms of await and yield, correct?
22:31:59 <benzrf> not yet accting for spaces https://gist.github.com/cdef79509c6e3e3ed531
22:32:05 <benzrf> johnw: ^
22:33:00 <johnw> which one is your entry point?
22:33:26 <johnw> and what's the problem?
22:37:20 <moop> > (+) 1 . (+) 2 . (+) 3 . (+) 4 0
22:37:21 <lambdabot>      No instance for (Typeable c0)
22:37:21 <lambdabot>        arising from a use of ‘show_M465829603382908920114937’
22:37:21 <lambdabot>      In the expression:
22:38:13 <moop> ok why if i replace . with $ it works?
22:40:11 <mauris> > ((+) 1 . (+) 2 . (+) 3 . (+) 4) 0
22:40:12 <lambdabot>  10
22:40:20 <Welkin> > (+) 1 . (+) 2 . (+) 3 . (+) 4 $ 0
22:40:22 <lambdabot>  10
22:40:27 <moop> oh i see
22:40:37 <Welkin> you can only compose functions
22:40:51 <mauris> `f . g . h` is a function (built by composing three functions), `f $ g $ h x` is three function applications
22:42:17 <Welkin> oh, they both are
22:46:06 <lpaste_> glguy pasted “simple csv version (no framework) for welkin” at http://lpaste.net/139600
22:46:09 <benzrf> johnw: parseFunction is entry
22:46:38 <glguy> Welkin: Instead of learning a bunch of new libraries you can do it like that, it's crazy simple and constant memory usage
22:46:42 <benzrf> Haskell> parse parseFunction . pack $ "[]3+3"
22:46:44 <benzrf> Fail "+3" [] "endOfInput"
22:48:51 <Welkin> glguy: thanks for all the examples
22:49:00 <Welkin> I got it working with pipes
22:49:09 <Welkin> which I have been meaning to learn for a while now
22:49:12 <erisco> Welkin, actually it may be primitive, as for is //> which in source is given a direct definition
22:49:57 <erisco> Welkin, I don't know how else you would replicate the signature of //>, particularly it moves the downstream-out type to the return type
22:50:12 <Welkin> I wonder that the (dis)advantages are to using lazy IO vs a streaming library
22:50:24 <Welkin> what the*
22:50:28 <erisco> Welkin, we had a discussion in -blah about it
22:50:52 <erisco> the problem with lazy IO, presuming you're doing unsafeInterleaveIO kind of stuff, is that you can throw exceptions in pure code
22:51:35 <erisco> and if you begin passing around unsafe values (particularly if you return it out of your scope) then good luck keeping track
22:51:59 <erisco> obviously the thing to do is catch the exception, but if you return the unsafe value with expectation of the caller to catch
22:52:08 <erisco> well, that is something you have to keep track of yourself now
22:53:03 <erisco> in Java they enforce exception annotations
22:53:17 <erisco> in Haskell you're supposed to use the IO annotation
22:55:20 <erisco> Welkin, if you're not using unsafe operations then the pipes tutorial gives a brief summary of your otherwise lack of options
22:57:18 <benzrf> johnw: any luck??
23:03:34 <Hijiri> Welkin: there is also the issue that (for example) with unsafeInterleaveIO, the results can change based on when you evaluate that portion
23:04:26 <Hijiri> I don't think anyone would do this, but an example would be if the interleaved next portion of a list gave a cons cell with the current time and another interleaved thing
23:05:26 <erisco> Welkin, a comment on your intuition "if any part of the pipeline terminates the the whole thing terminates"
23:05:34 <Hijiri> maybe a more realistic example would be something like readFile, and you have another thread close the file handle while you are evaluating it
23:05:45 <erisco> Welkin, I think this is a bit off (note I am also learning the lib, so this is partly exercise for myself)
23:05:48 <Hijiri> but that doesn't sound like something that would happen too often either
23:05:54 <johnw> benzrf: you've given me so little to go on that I gave up
23:06:07 <benzrf> johnw i gave u my code and a failing case :[
23:06:17 <johnw> you could have at least said what you wanted it to parse as
23:06:30 <erisco> Welkin, first you have to be specific about what you refer to as "the pipeline", and I think that is part of the issue (it is not specific enough)
23:06:30 <benzrf> er, Add (Imm 3) (Imm 3)?
23:07:26 <johnw> so, it's doing just what you're telling it to do
23:07:35 <johnw> parseExpression -> parseTerm -> parseFactor -> decimal
23:07:43 <johnw> then it can't parse any further
23:07:51 <johnw> the parseExpression parser *succeeds*, so it's not going to backtrack
23:07:56 <johnw> it's the endOfInput parser that's failing
23:08:08 <erisco> Welkin, so, to be specific, you have to decide which category you are talking about
23:08:19 <johnw> benzrf: move parseTerm to the end of parseExpression
23:08:32 <erisco> Welkin, and there are 5 that the Pipes.Core module outlines: respond, request, push, pull, and Kleisli
23:08:34 <johnw> you want the most specific parsers first, the least specific last
23:08:39 <ski> imho, `hClose'ing a handle that has been passed to `hGetContents' ought to be an error
23:08:40 <johnw> that way it fails as early as possible
23:08:53 <ski> Hijiri ^
23:08:58 <benzrf> johnw: how come?
23:09:02 <erisco> Welkin, in the Kleisli category every part of the pipeline terminates (or else the program is not productive)
23:09:14 <johnw> benzrf: I just said
23:09:19 <benzrf> oh 
23:09:21 <benzrf> missed bc not ping, sorry
23:09:24 <johnw> n/p
23:09:38 <johnw> a recursive descent parser like this one is the same as a traditional LL-with-backtracking
23:09:43 <johnw> and those work by branching on the immediate token
23:09:45 <benzrf> i dont know my parser stuff :>
23:10:00 <johnw> in the case of a backtracking parser, it branches on the first successful complete parse
23:10:32 <johnw> so you want to make sure that anything you want to parse will not be parsed by some other parser earlier, like what is happening right now
23:10:43 <benzrf> now it hangs
23:10:53 <erisco> Welkin, this is if you understand the pipeline as being formed over composition, so if A is a pipeline and B is a pipeline then A.B is a pipeline
23:10:57 <johnw> yeah, that's a typical problem of left recursive parsers
23:11:00 <benzrf> :[
23:11:03 <erisco> Welkin, so in Kleisli this is >=> of course
23:11:04 <johnw> it's because your expression loops back on itself
23:11:10 <benzrf> yeah figured
23:11:17 <benzrf> well making it right-recursive probably wont cause a prob
23:11:23 <johnw> did you ever see my video with me and ocharles, where I write a parser?
23:11:25 <johnw> we cover this :)
23:11:29 <benzrf> nope D:
23:11:41 <Hijiri> ski: that would fix that issue, yeah
23:11:42 <erisco> Welkin, and by "terminates" we mean the pipeline stops producing values
23:11:56 <Hijiri> but even though it's unlikely, there could be things like the file becoming unavailable for other reasons
23:12:16 <Hijiri> probably a better motivator would be something like a socket
23:12:17 <johnw> benzrf: so, the parsec answer to this is "chainl"
23:12:28 <Hijiri> since you really don't control when it dies in that case
23:12:31 <jle`> hm, program went into a random infinite loop on a freak random initial input and now i can't replicate it :/
23:12:45 <erisco> Welkin, this is also true in the push and pull categories
23:12:48 <jle`> it's like i'm programming in not-haskell
23:13:10 <johnw> benzrf: you can copy one for attoparsec from here: https://github.com/quantumman/enumCalc/blob/master/enumCalc.hs
23:13:38 <Hijiri> what's happening
23:13:46 <Hijiri> minor hiccup and #haskell is big enough to detect it?
23:15:35 <erisco> Welkin, so that leaves respond and request, and in those you have have the property that "if one pipeline terminates the whole thing terminates"
23:15:54 <jle`> 4
23:15:57 <johnw> hmm... that uneasy feeling you get when your QuickCheck failures simply grow further apart as you fix the bugs...
23:16:00 <erisco> Welkin, and conversely "if no pipeline terminates then the whole thing does not terminate"
23:16:50 <erisco> so, even in, say, the Kleisli category, if one pipeline does not terminate this is not sufficient to say the whole pipeline does not terminate
23:18:18 <Lokathor> so, in place of "cabal install lambdabot", how would i do the same thing using stack?
23:18:47 <Lokathor> the help menu makes i look like i'll need to clone it from git or wherever and then build it from the directory as seperate steps
23:18:54 <johnw> Lokathor: try #haskell-stack
23:19:19 <Welkin> erisco: I don't remember seeing much about that in the tutorial
23:19:35 <jhrcek> Philosphical question: Is there any deeper reason why Functor is in Data.Functor, while Applicative and Monad are in Control?
23:19:35 <jhrcek> Is this from historical reasons or is there some deeper reason behind it?
23:19:57 <johnw> jhrcek: I'm pretty sure it's historical
23:20:03 <Lokathor> i'll give #haskell-stack a try, but also only 26 people :/
23:20:16 <johnw> it may have been that originally people thought of functors as pertaining to containers, and monads to control structures
23:21:01 <Lokathor> yeah, i was told basically that when i first heard about them
23:21:09 <Lokathor> containers/ control structures
23:21:15 <johnw> it's not really how they are presented anymore
23:21:18 <johnw> at least, not here
23:21:26 <johnw> I think LYAH still might indicate that view
23:21:28 <Lokathor> sadly LYAH doens't get updates :/
23:21:48 <jhrcek> ok. I felt this might so
23:22:02 <Welkin> erisco: it only mentions that >-> is pull-based
23:22:48 <johnw> >-> is just a synonym for //>
23:23:08 <johnw> sorry, +>>
23:23:32 <johnw> //> is for respond, >\\ for request, and >>~ for push
23:24:03 <Welkin> johnw: I only know what the tutorial covers (the basics)
23:24:15 <Welkin> but I did peek into the Internal and Core modules
23:24:21 <johnw> ah, I know them from reimplementing the library in another language :)
23:24:28 <johnw> so I'm actually a bit weak on the tutorial side of things
23:25:08 <Welkin> >-> is like =$=, ~> like $= and >~ like =$
23:25:21 <Welkin> for a comparison to conduit
23:25:38 <johnw> you sure it's not >~> that's like =$+?
23:25:40 <johnw> =$=
23:26:02 <feryll> Is there a convenience function for simultaneous fmap/join I'm forgetting (e.g. http://lpaste.net/139601 ), or am I just needing to implement join way too often?
23:26:04 <Welkin> >-> composes Pipes
23:26:04 <johnw> I'm not sure
23:26:27 <johnw> yeah, I think you're right
23:26:44 <arkeet> feryll: that's =<<
23:26:46 <johnw> strangely, >~ has nothing to do with >>~, but rather >\\
23:26:51 <arkeet> join (fmap f a) = f =<< a
23:26:51 <Welkin> feryll: join . fmap ?
23:27:10 <feryll> arkeet: Ah, thanks
23:27:33 <arkeet> btw, return . f =<< a = fmap f a
23:27:58 <Welkin> a typeclassopedia exercise
23:28:03 <Welkin> one of my favorites
23:30:57 <Welkin> are there any good papers on the topic of streaming data?
23:31:16 <Welkin> the foundation for pipes/conduit/machines
23:32:44 <ReinH> @google essence of iterator
23:32:45 <lambdabot> https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf
23:32:50 <ReinH> Welkin: ^
23:34:21 <ReinH> Welkin: http://okmij.org/ftp/Streams.html#iteratee
23:34:53 <ReinH> Welkin: a more beginner-oriented resource: http://www.scs.stanford.edu/11au-cs240h/notes/iteratee.html
23:34:57 <AshyIsMe> Lokathor: should be "stack install lambdabot"
23:35:21 <ReinH> Welkin: Oleg's original package http://hackage.haskell.org/package/iteratee
23:35:34 <AshyIsMe> Lokathor: but lambdabot was using some old versions of things when i last looked at it so it might not be part of stackage
23:36:18 <meditans> hi, I was toying with the `memoize` function in Data.Function.Memoize
23:37:02 <meditans> basically, I have a large function that I'd like to memoize, but when I use the memoized version, the program is killed after a while
23:37:23 <meditans> (I suppose the stack used is too big. How can I increase its size?)
23:38:21 <pacak> I suspect  you need a bit more intelligent memoization. If input/output space is too big  you can't hold all the values in memory.
23:38:41 <erisco> Welkin, let responder x = respond x >> responder x in for (responder "hi") (lift . putStrLn)
23:39:23 <erisco> Welkin, let pusher x = push x >> pusher x in for (yield "hi" >>~ pusher) (lift . putStrLn)
23:39:31 <erisco> not sure if that highlights anything, maybe
23:40:06 <Welkin> erisco: an infinite loop
23:40:09 <Welkin> ReinH: thanks
23:40:11 <erisco> nope
23:40:20 <erisco> well the responder, yes, the pusher, no
23:40:22 <meditans> pacak: where should I begin? The function I'm trying to memoize is indeed quite complex.
23:40:33 <ReinH> Welkin: slides from a talk on Machines https://dl.dropboxusercontent.com/u/4588997/Machines.pdf
23:40:52 <meditans> pacak: moreover, the program terminates (after a long time) with the non-memoized version (for low inputs)
23:41:11 <pacak> meditans: Write your own memoization to keep only last / most popular N values
23:41:25 <erisco> also similarly for puller
23:42:16 <meditans> pacak: that sounds like the right way, thanks. Is there a library which does similar things, to adapt?
23:42:50 <pacak> meditans: I'm not sure, but it should be relatively simple to implement it on your own.
23:44:21 <meditans> pacak: got it, thanks :)
23:45:09 <erisco> anyways, my brain hurts on that subject now XD
23:45:53 <Welkin> yeah, time to sleep :)
23:59:15 <benzrf> fffffff
23:59:40 <benzrf> i somehow managed to miss that making a right-recursive parser will cause the resulting tree to be associated dfferently from a left-recursive one
23:59:42 <benzrf> ;-;
23:59:45 * hackagebot linearscan 0.8.0 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-0.8.0 (JohnWiegley)
23:59:47 * hackagebot linearscan-hoopl 0.8.0 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.8.0 (JohnWiegley)
23:59:53 <johnw> benzrf: yep :)
23:59:55 <benzrf> how do i dooooooo
