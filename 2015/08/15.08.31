00:03:45 <montanonic> Does anyone here use Purescript and Yesod together? I'm struggling to get yesod-purescript to work, and I was hoping someone here is currently using them.
00:07:39 * hackagebot nationstates 0.2.0.2 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.2.0.2 (ChrisWong)
00:07:39 * hackagebot nationstates 0.3.0.0 - NationStates API client  https://hackage.haskell.org/package/nationstates-0.3.0.0 (ChrisWong)
00:13:48 <phaazon> hey
00:13:59 <phaazon> is there a way to see all the available version of a given package with cabal info?
00:14:03 <phaazon> it hides a few
00:14:07 <phaazon> that’s annoying
00:26:08 <MorpheusB> More resources for learning haskell https://www.haskell.org/documentation
00:27:35 * hackagebot hpack 0.6.0 - An alternative format for Haskell packages  https://hackage.haskell.org/package/hpack-0.6.0 (qoelet)
00:54:25 <ttt_fff> how does gui work in prolog, and can haskell copy it without monads? (since if prolog is pure, and a gui is in prolog, then it shoudl also be haskell-able)
00:54:56 <Meesha> Hi Guys, can anyone shed some light on why this code http://pastebin.com/EuaiE13g  gives this error http://pastebin.com/uYVJfQPK when I run indexJ 3 Empty
00:55:15 <Meesha> It was suppose to return nothing
00:56:31 <cocreature> Meesha: the problem is that before running it needs to typecheck your code. for that it needs to infer the type of the second parameter which is some "JoinList b a", but it can't deduce the parameter b from the value "Empty,
00:57:17 <Meesha> but Empty has the type of JoinList m a
00:57:21 <Meesha> in the data definition
00:57:37 <cocreature> yes, but what concrete type should m be here?
00:57:53 <cocreature> it needs to infer that to make sure that it has a Monoid instance
00:58:14 <Meesha> I am thinking hard right
00:58:33 <cocreature> try giving it an explicit type signature like "Empty :: JoinList () ()" and it should work
00:59:29 <Meesha> trying it now, thank you good sir
01:01:58 <Meesha> cocreature, nope it seems like i am still getting the error after using indexJ 3 (Empty :: JoinList () ())
01:03:27 <cocreature> the same error?
01:04:06 <Meesha> <interactive>:49:1:
01:04:06 <Meesha>     No instance for (Sized ()) arising from a use of ‘indexJ’
01:04:06 <Meesha>     In the expression: indexJ 3 (Empty :: JoinList () ())
01:04:06 <Meesha>     In an equation for ‘it’: it = indexJ 3 (Empty :: JoinList () ())
01:04:35 <cocreature> oh right, it also needs to be an instance of Sized, I have no idea how your class Sized is defined, so you'll need to find something that is an instance of Monoid and an instance of Sized yourself and use that as the second parameter
01:05:06 <Meesha> ohh the class size is here: http://www.seas.upenn.edu/~cis194/fall14/spring13/extras/07-folds-monoids/Sized.hs
01:05:42 <Meesha> Thank You for reply. I will try to think about your commends and see if I can understand why i am getting the error i am getting
01:05:46 <cocreature> Size should work
01:05:53 <cocreature> it is an instance of Sized and of Monoid
01:06:07 <cocreature> try Empty :: JoinList Size ()
01:06:28 <Meesha> OMG
01:06:30 <Meesha> it works
01:06:32 <Meesha> OMG OMG OMG
01:06:34 <Meesha> thank you
01:06:37 <cocreature> yw :)
01:06:46 <Meesha> now, if it does not take too much time, can you briefly explain
01:06:48 <Meesha> what is hapening
01:07:04 <cocreature> allright, so you want to run your code so it needs to typecheck
01:07:19 <Meesha> yah, got it
01:07:36 <cocreature> now your type signature says that this can only typecheck if b is an instance of Sized and Monoid
01:07:44 <cocreature> allright?
01:07:51 <Meesha> yeah, got it.
01:07:59 <Meesha> but it is impossible to infer the b from Empty
01:08:16 <cocreature> so the problem is that Empty doesn't provide enough information to provide a unique answer to the question what b should be
01:08:30 <Meesha> so it needs to know more information about the variable b in order to typecheck and then run the code?
01:08:35 <cocreature> exactly
01:09:40 <Reshi> Which would be a good resource to learn the parsec library? (beginner)
01:09:53 <ttt_fff> having something to parse
01:09:58 <ttt_fff> it's much easier when you have something to parse
01:10:01 <ttt_fff> then you try to parse it
01:10:05 <Meesha> ohh my, I learned something important today. Thanks!!!
01:10:07 <ttt_fff> and spam #haskell when you get stuck
01:10:12 <cocreature> Reshi: iirc http://book.realworldhaskell.org/read/using-parsec.html is quite good
01:10:22 <cocreature> but it's been quite some time since I've looked at it :)
01:11:36 <Hijiri> the examples also might not compile with all the changes to the ecosystem since then
01:12:16 <cocreature> yeah, but it's usually easy enough to find the changes you need to make by either doing a google search or asking here
01:14:46 <Reshi> cocreature: I will try it out, thanks
02:52:45 <indiagreen> I have a tar.gz file with a 12 GB text file in it. Is there some way to process that file incrementally?
02:53:52 <merijn> indiagreen: Look at pipes/conduits for stream processing libraries
02:54:06 <merijn> indiagreen: They exist exactly for this kinda streaming processing of large files/data
02:57:56 * hackagebot sync-mht 0.3.7.0 - Fast incremental file transfer using Merkle-Hash-Trees  https://hackage.haskell.org/package/sync-mht-0.3.7.0 (emink)
02:57:59 <quux> hi
02:58:25 <quux> does anyone have PDF which explains de bruijn indices? and lists theorems about lift/substitution
02:59:21 <indiagreen> merijn: okay, I have found several libraries for streaming a compressed file, but there seems to be nothing to work with tar
03:03:04 <xelxebar> I'm wanting to use an XMPP library and found Network.XMPP from the XMPP package. Is this one okay?
03:03:47 <xelxebar> There were a couple others that I saw as well -- haskell-xmpp and pontarius-xmpp
03:05:53 <xelxebar> Also network-protocol-xmpp.
03:08:04 <Philonous_> xelxebar, The XMPP package was last updated 2009, network-protocol-xmpp is pretty bare-bones, haskell-xmpp hasn't been updated since 2012
03:09:13 <xelxebar> Philonous_: Thanks. Hmmm...
03:16:44 <kaste> Hello, I am looking for some easy web automation library. Like Mechanize in python/perl. The only thing I really found so far is shpider. Is there something better? In the ideal case it would steer a chromium, otherwise I think even the session handling fails in my experience on python. Is there something like that?
03:18:16 <kaste> ah maybe webdriver 
03:19:13 <jhrcek> kaste: I was playing with webdriver, it works nice, also with chrome
03:19:46 <kaste> ok, that sounds good
03:19:50 <kaste> I will try that then
03:23:22 <jhrcek> kaste: just bear in mind it's just WebDriver client - you'll need webdriver server running in the background. But that's easy to setup. I was running webdriver server using java, controlling startup/shutdown from haskell.
03:23:29 <jhrcek> kaste: https://github.com/jhrcek/haskell-snipets/blob/master/web-driver/WdUtil.hs
03:40:36 <concept> Can anybody tell me why this parser (attoparsec) doesn't work as expected
03:42:30 <concept> http://lpaste.net/2987933426985730048
03:44:04 <srhb>  /urlselect 
03:44:11 <srhb> ...
03:44:47 <srhb> concept: Doesn't anyTill take a String or a Parser String as its second argument?
03:44:51 <srhb> ... I mean Parser Char
03:44:54 <srhb> Not Parser String
03:46:13 <concept> srhb:  simpleComment   = string "<!--" *> manyTill' anyChar (string "-->")
03:46:20 <concept> ^ this example from docs
03:46:38 <srhb> Oh alright.
03:46:41 <concept> the parser doesn't work at all
03:46:58 <concept> what I want is to split messages on "\r\n\r\n"
03:47:10 <concept> I know it's ugly (very ugly)
03:47:21 <concept> but I didn't design the protocole
03:48:16 <louispan> karma mpickering
03:48:53 <louispan> preflex: karma mpickering
04:04:05 <lyxia> concept: endOfMessage = try (string "\r\n\r\n")
04:05:05 <concept> lyxia: not working too
04:10:00 <pavonia> concept: Why do you use lookAhead and not the parser directly?
04:10:18 <concept> pavonia: tried both
04:10:31 <concept> pavonia: neither worked
04:11:33 <pavonia> With what message does it fail?
04:14:34 <Reshi> I had installed haskell platform for osx from haskell.org: 1) I have version 7.8 and I want to update to the latest, how should I do that? re-download and install?, and 2) Would it be better if I installed from homebrew?
04:16:12 <lyxia> concept: How does it not work?
04:16:13 <concept> pavonia: I expect it to separate the messages on \r\n\r\n it fails on the message in the example, and gives weird results.. 
04:16:17 <Reshi> Okay for 1) The haskell platform installer from haskell.org pointed me to uninstall-hs
04:16:42 <srhb> concept: So the problem is that it consumes the end string before your <* ?
04:16:44 <concept> like spearating on the wrong position
04:17:13 <lyxia> concept: manyTill only parses until the first endOfMessage, it does not do a full split.
04:17:34 <concept> lyxia : I tried sepBy
04:17:48 <srhb> parse ((manyTill anyChar (lookAhead $ string "foo")) <* string "foo") $ "abcdefoo"
04:17:50 <srhb> This works for me
04:17:57 <srhb> Is it not what you are doing?
04:19:25 <pavonia> concept: "gives weird results" isn't really more informative than "doesn't work"
04:20:07 <concept> pavonia: yup, it splits on the wrong position (includes the message separator)
04:26:08 <concept> srhb: that's what I am doing, it only parse up to the first end message, and using sepBy instead fails.
04:26:27 <concept> srhb: how should I do a full split
04:26:36 <srhb> concept: Perhaps your test data would be helpful in weeding out the wrong assumption here.
04:26:55 <concept> srhb: http://lpaste.net/2987933426985730048
04:29:45 <srhb> concept: OK, so that parses until Uniqueid: 1441006053.218 - exactly as you would expect
04:29:50 <srhb> I don't understand the problem :)
04:30:53 <concept> srhb: Ok, that's correct, I want a full split, other end messages doesn't work
04:31:10 <srhb> What do you mean "full split" ?
04:31:25 <concept> list of messages
04:31:35 <srhb> So you want to use parseMsg multiple times?
04:31:39 <srhb> That doesn't just happen automagically.
04:32:18 <concept> ok so I have to call it again
04:32:37 <concept> but how would I know ?
04:32:43 <concept> when
04:33:22 <concept> shouldn't sepBy solve the problem
04:36:15 <concept> srhb: so should I pattern match on IResult ?
04:43:26 <ramadoka> :wq
04:43:39 <ramadoka> sorry, wrong windows.
04:53:12 * hackagebot lookup-tables 0.1.1.1 - Statically generate lookup tables using Template Haskell.  https://hackage.haskell.org/package/lookup-tables-0.1.1.1 (JakeMcArthur)
05:18:17 * hackagebot protocol-buffers 2.1.6 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/protocol-buffers-2.1.6 (k_bx)
05:18:19 * hackagebot protocol-buffers-descriptor 2.1.6 - Text.DescriptorProto.Options and code generated from the Google Protocol Buffer specification  https://hackage.haskell.org/package/protocol-buffers-descriptor-2.1.6 (k_bx)
05:18:21 * hackagebot hprotoc 2.1.6 - Parse Google Protocol Buffer specifications  https://hackage.haskell.org/package/hprotoc-2.1.6 (k_bx)
05:19:18 <jhrcek> @unmtl StateT Int IO ()
05:19:19 <lambdabot> Int -> IO ((), Int)
05:19:31 <jhrcek> @unmtl StateT Int MaybeT IO ()
05:19:31 <lambdabot> Plugin `unmtl' failed with: `MaybeT (IO, Int)' is not applied to enough arguments.
05:19:48 <jhrcek> @unmtl StateT Int MaybeT Int IO ()
05:19:48 <lambdabot> Plugin `unmtl' failed with: `MaybeT (Int, Int)' is not applied to enough arguments.
05:20:37 <cocreature> @unmtl StateT Int (MaybeT IO) ()
05:20:37 <lambdabot> Int -> IO (Maybe ((), Int))
05:20:42 <cocreature> jhrcek: you might want that
05:21:17 <jhrcek> cocreature: thanks, I was just experimenting with unmtl
05:55:35 <_di> Hi there! given this code ``` f p = (fmap (fmap (const p))) :: Int -> (IO (Maybe Foo)) -> IO Maybe Int ```. Q is can I make these fmaps prettier? it seems it doesnt compose much. Or is it best what I can achieve?
05:56:39 <lyxia> f = fmap . fmap . const
05:57:34 <lyxia> _di: ^ 
05:58:13 <aweinstock> :t [\p -> (fmap (fmap (const p))) :: Int -> (IO (Maybe Foo)) -> IO Maybe Int, fmap . fmap . const]
05:58:14 <lambdabot> Not in scope: type constructor or class ‘Foo’
05:58:14 <_di> lyxia: thx
05:58:21 <_di>       fetch p = (fmap (fmap (const p))) $ withDb $ getActiveProject p
05:58:39 <_di> this is what I'm doing. so seems I'll have to decouple it first
05:58:42 <_di> to make it less ugly
06:00:27 <lyxia> how about (fmap $ fmap $ const p), or (fmap . fmap . const) p
06:00:46 <mauke> (p <$) <$> withDb ...
06:00:56 <lyxia> oh nice
06:03:24 <_di> nice
06:03:32 <aweinstock> @src (<$)
06:03:32 <lambdabot> (<$) = (<$>) . const
06:04:44 <knupfer> what is recommended, use cpp or ignore warnings about <$> and OverlappingInstances?
06:05:07 <mauke> ?
06:05:25 <_di> mauke, now it become cryptic :D I like this trick. thanks. 
06:07:58 <orbifx> I've got two lists and I want two others lists, mutually affected by the two previous lists ([a], [b]) -> ([a], [b]). For every element in [a] which matches one a unique one in [b], both lists needs to change.
06:08:26 <orbifx> is there a nice function for that?
06:08:33 <orbifx> Or am I looking at making my own?
06:08:50 <knupfer> any opinions?
06:08:55 <asthasr> by the way, a few times I have mentioned that I was trying to get a good implementation of a questionnaire style "thing" in Haskell, impeded by the issue of disparate return types... as such (and to give my wife a more complex example to dissect as she learns Python), I threw together a Python implementation, if anyone is interested.
06:08:57 <orbifx> basically [a] is a list of characters that are used to capitalise initials in [b]
06:09:09 <asthasr> https://gist.github.com/asthasr/27687f0153ae5666ce91
06:10:11 <asthasr> This is an example of something that, while I really like Haskell and static typing, I think is "unproductively constrained" by the demands of static typing... the pieces that static typing makes difficult (the carrying forward of state from one iteration to the next) are the least interesting part of the problem, and it's largely a stateless/functional program besides that
06:10:28 <asthasr> (well, carrying forward of state and the expression of constraints)
06:12:57 <_di> orbifx: try to look in hoogle or hyaoo for your type signature
06:13:50 <orbifx> _di: I'm looking at the List functions for now. Coprehensions was one idea, or doing a partial takeWhile
06:15:38 <clrnd> asthasr, interesting, I've found that using lens and State is quite simple and powerful, have you tried that?
06:16:07 <tdammers> asthasr: the state thing and static typing are orthogonal
06:16:43 <tdammers> asthasr: dynamically-typed languages with stateless semantics are possible, statically-typed languages with destructively mutable state are also possible
06:16:54 <tdammers> Haskell just happens to be statically typed *and* pure
06:18:45 <tdammers> asthasr: IMO, implementing something like you wrote there in Haskell isn't any less straightforward than it is in Python, once you know your way around the relevant Haskell idioms
06:19:34 <tdammers> asthasr: threading state through computations can be done using State (or StateT if your computations are monadic), or, if you're in IO anyway, you can use one of the mutable-state modules, e.g. IORefs or STM
06:20:21 <tdammers> asthasr: as far as the constraints go, you'll probably end up implementing a mini-DSL for those - which is a lot less scary in Haskell than it sounds
06:25:48 <orbifx> is there a function for traversing simultaneously first and second elements of a tuple?
06:26:03 <merijn> bimap?
06:26:12 <merijn> Bifunctor in base \o/
06:26:15 <merijn> :t bimap
06:26:17 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
06:26:29 <aweinstock> @instances Bifunctor
06:26:33 <lambdabot> on the commandline: Warning:
06:26:33 <lambdabot>     -fglasgow-exts is deprecated: Use individual extensions instead
06:26:33 <lambdabot>  
06:26:33 <lambdabot> <no location info>: Warning:
06:26:33 <lambdabot>     -XGeneralizedNewtypeDeriving is not allowed in Safe Haskell; ignoring -XGeneralizedNewtypeDeriving
06:26:35 <lambdabot> [4 @more lines]
06:26:36 <merijn> :t bimap isAlpha even
06:26:37 <lambdabot> (Integral a, Bifunctor p) => p Char a -> p Bool Bool
06:26:50 <merijn> :t bimap isAlpha even `asAppliedTo` ('a', 1)
06:26:51 <lambdabot> Integral a => (Char, a) -> (Bool, Bool)
06:27:14 <orbifx> thanks merijn 
06:27:19 <orbifx> I'll check it out
06:27:22 <merijn> Also &&&, I guess
06:27:33 <merijn> :t even &&& isAlpha
06:27:34 <lambdabot>     No instance for (Integral Char) arising from a use of ‘even’
06:27:34 <lambdabot>     In the first argument of ‘(&&&)’, namely ‘even’
06:27:34 <lambdabot>     In the expression: even &&& isAlpha
06:27:46 <merijn> :t even *** isAlpha -- whoops
06:27:47 <lambdabot> Integral b => (b, Char) -> (Bool, Bool)
06:27:49 <Sindriav_> Can I not export instances?
06:27:56 <merijn> But bimap is better
06:28:01 <merijn> Sindriav_: Instances are ALWAYS exported
06:28:06 <Sindriav_> Well fuck
06:28:20 <merijn> Sindriav_: You can't hide them. What's the problem?
06:28:25 * hackagebot THEff 0.1.1.0 - TH implementation of effects.  https://hackage.haskell.org/package/THEff-0.1.1.0 (kolodeznydiver)
06:28:27 * hackagebot microlens 0.3.4.0 - A tiny part of the lens library which you can depend upon  https://hackage.haskell.org/package/microlens-0.3.4.0 (Artyom)
06:28:29 * hackagebot microlens-ghc 0.3.0.0 - microlens + all features depending on packages coming with GHC (array, bytestring, containers)  https://hackage.haskell.org/package/microlens-ghc-0.3.0.0 (Artyom)
06:28:31 * hackagebot microlens-platform 0.1.4.0 - Feature-complete microlens  https://hackage.haskell.org/package/microlens-platform-0.1.4.0 (Artyom)
06:28:31 <asthasr> tdammers: The trouble I was running into is that, conceptually, questions can return different types. That is, you might have a text (or 'free form') input that then gets parsed as a decimal value
06:28:54 <asthasr> tdammers: I didn't see a great way to be able to nicely express constraints on different types of answer
06:29:04 <Sindriav_> merijn: Well, I'm making a monad transformer. I want to be able to use it as MonadState inside my functions, but I don't want the people who use the library to use the MonadState functions
06:29:14 <aweinstock> asthasr: GADTs?
06:29:18 <lwm> asthasr: can't you get away with the () type for that
06:29:28 <Sindriav_> merijn: Do I really have to manually lift the calls?
06:30:03 <merijn> Sindriav_: Use a stack internally, wrap it with a newtype and don't instance MonadState for the newtype
06:30:16 <Sindriav_> merijn: So, newtype a newtype?
06:30:23 <merijn> Sindriav_: Then you can use the MonadState of the stack internally as long as you wrap the stack in a newtype in the API
06:30:50 <merijn> Sindriav_: Sure
06:31:35 <Sindriav_> Huh… So I have a newtype for the stack already, which instances monadState. So I just newtype that again, and then use lift inside my methods?
06:32:35 <merijn> Sindriav_: Well, if you already have a newtype then can't you simply delete the MonadState instance for it and explicitly unwrap in your API?
06:32:56 <Sindriav_> merijn: How do I explicitly unwrap?
06:33:07 <asthasr> aweinstock: That works, except that my DSL for constraints would then have to operate on every alternative. if I use "AnswerString | AnswerInt | AnswerDecimal"..., then I need to implement numeric comparisons for the various numeric types... but of course the whole thing can't be part of the Num typeclass, so that's terrible.
06:33:08 <Sindriav_> Using (lift . lift . ask) instead of ask?
06:33:38 <merijn> Sindriav_: "newtype MyStack a = MyStack (StateT s m a); foo :: MyStack a -> ??; foo (MyStack f) = {- work with f here, since that is MonadState -}"
06:34:20 <merijn> Sindriav_: Note that this is legal "MyStack $ do { foo <- ask; return (bar foo) }" <- here the do block is StateT s m a
06:34:44 <merijn> So you can use the MonadState of StateT there, but since MyStack is not MonadState users can't do the same
06:34:45 <Sindriav_> And if I wanted one level deeper, I'd go "MyStack . StateT $ do … " ?
06:34:52 <merijn> Sindriav_: Sure
06:35:00 <orbifx> merijn: any tutorials on using bifunctors?
06:35:23 <merijn> orbifx: Do you understand functors? Bifunctors are basically the same, but with one instead of two parameters
06:35:28 <orbifx> i found tthis: http://bartoszmilewski.com/2015/02/03/functoriality/ anything else?
06:35:29 <merijn> orbifx: Compare the following types:
06:35:32 <merijn> :t fmap
06:35:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:35:35 <merijn> :t rmap
06:35:37 <lambdabot> Profunctor p => (b -> c) -> p a b -> p a c
06:35:42 <merijn> whoops!
06:35:49 <merijn> Ignore that one, lemme lookup the name
06:36:14 <tdammers> asthasr: a simple sum type should suffice methinks
06:36:15 <merijn> :t fmap
06:36:16 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:36:17 <merijn> :t second
06:36:19 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
06:36:21 <merijn> ugh
06:36:25 <merijn> Name collisions!
06:36:32 <merijn> :t Data.Bifunctor.second
06:36:34 <lambdabot> Bifunctor p => (b -> c) -> p a b -> p a c
06:36:37 <merijn> :t Data.Bifunctor.first
06:36:38 <lambdabot> Bifunctor p => (a -> b) -> p a c -> p b c
06:36:42 <merijn> :t Data.Bifunctor.bimap
06:36:43 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
06:37:25 <merijn> orbifx: Stare at the types of fmap, second, first and bimap and enlightenment should (hopefully) appear. If you're still confused after like 10 mins, ask for help then :)
06:38:00 <orbifx> yeah this is why I was wondering for a tutorial instead of englighment by staring :P
06:38:20 <Sindriav_> merijn: Turns out it's just `MyStack $ do …` even for a level deeper one
06:38:22 <orbifx> I'll read Bartosz's article and then look at the types again
06:38:34 <merijn> orbifx: What part confuses you? Note that in "fmap" 'f' is a type constructor taking a single type
06:38:54 <merijn> orbifx: With Bifunctor 'p' is a type constructor taking two types as arguments
06:39:17 <merijn> orbifx: Some examples are Either and (,)
06:39:38 <merijn> :t Data.Bifunctor.first isAlpha
06:39:40 <lambdabot> Bifunctor p => p Char c -> p Bool c
06:39:50 <merijn> :t Data.Bifunctor.first isAlpha `asAppliedTo` Right ()
06:39:51 <lambdabot> Either Char () -> Either Bool ()
06:40:00 <merijn> :t Data.Bifunctor.first isAlpha `asAppliedTo` Left 'a'
06:40:01 <lambdabot> Either Char c -> Either Bool c
06:40:13 <merijn> :t Data.Bifunctor.first isAlpha `asAppliedTo` ('a', ())
06:40:14 <lambdabot> (Char, ()) -> (Bool, ())
06:40:30 <aweinstock> > bimap (+1) (+10) (0, 0, 0)
06:40:32 <lambdabot>  (0,1,10)
06:41:07 <merijn> Sindriav_: Well, once you're inside MyStack you're in the "StateT s (ReaderT r m) a" (or whatever) stack which is just a regular MonadState instance
06:41:28 <athan> :t asAppliedTo
06:41:28 <aweinstock> > bimap (+1) (+10) (0, 0, 0, 0, 0)
06:41:29 <lambdabot> (a -> b) -> a -> a -> b
06:41:30 <merijn> Sindriav_: So you can use all the relevant functions there and only wrap the entire big (internal) block with MyStack
06:41:30 <lambdabot>  (0,0,0,1,10)
06:41:34 <athan> hm!
06:41:41 <merijn> athan: asAppliedTo is const with a magic type :)
06:41:49 <athan> o_o
06:41:56 <merijn> athan: It uses the first result to force type inference then ignores it :)
06:41:57 <merijn> :t const
06:41:59 <lambdabot> a -> b -> a
06:42:02 <aweinstock> > bimap (+1) (+10) <$> [Left 0, Right 0]
06:42:04 <lambdabot>  [Left 1,Right 10]
06:42:04 <Sindriav_> merijn: Yeah, but it's apparently also a MonadReader instance, because I can then just do `MyStack $ ask`, even though it's a `StateT (ReaderT …`
06:42:09 <orbifx> merijn: it's not confusion, I'm new to Haskell and everything takes time. Look at a signature with type construction involved is a new beast to me :P
06:42:14 <athan> @src asAppliedTo
06:42:14 <lambdabot> Source not found. I feel much better now.
06:42:19 <athan> merijn: That's nutty!
06:42:24 <merijn> athan "const :: (a -> b) -> a -> (a -> b)"
06:42:34 <merijn> :t const :: (a -> b) -> a -> (a -> b)
06:42:35 <lambdabot> (a -> b) -> a -> a -> b
06:42:59 <orbifx> merijn: also I'm considering if bifunctors are what I need all together.
06:43:02 <athan> :U
06:43:10 <athan> that is so cool
06:43:11 <merijn> :t (const :: (a -> b) -> a -> (a -> b)) (bimap even id) (Right ())
06:43:12 <lambdabot> Integral a => Either a () -> Either Bool ()
06:43:37 <merijn> athan: It just returns the input function like const always does, but the shared 'a' forces type inference to narrow things down :)
06:43:45 <quchen> What do green version numbers on Hackage mean? For example here: http://hackage.haskell.org/package/soap
06:43:57 <athan> merijn: That's a very awesome use of coercion for type tricks
06:44:21 <merijn> athan: It's not using coercion
06:44:30 <merijn> Just adding extra constraints on the inference
06:44:47 <athan> yah yah :P
06:45:07 <athan> in the polymorphic context, I feel like it's coercion :x
06:45:20 <hvr> quchen: it's the preferred info
06:45:21 <athan> without having to jump between monomorphic types >.>
06:45:24 <merijn> orbifx: Well, you can write a simple lambda too, i.e. "\(a, b) -> f a + g b" or whatever and traverse with that :)
06:45:34 <quchen> hvr: In what sense? "Stable packages"?
06:45:48 <hvr> quchen: you know the preferred-version ranges and version-deprecation feature on hackage?
06:45:49 <merijn> quchen: Maintainers can mark preferred versions, iirc
06:46:06 <merijn> quchen: i.e. telling cabal "pick this over newer versions"
06:46:13 <PyroPeter> is there a profiling package available that outputs the probable time and space complexity of pure functions with one integral argument?
06:46:13 <quchen> I see. Thanks merijn hvr 
06:46:14 <hvr> merijn: ..."if possible"
06:46:20 <merijn> hvr: Obviously :)
06:46:33 <orbifx> merijn: my problem is that there is a "state" of what has been consumed so far, which my not be at the same rate on both lists
06:46:59 <merijn> orbifx: So you have a tuple of two lists?
06:47:01 <aweinstock> :t \f g -> [\(a, b) -> f a + g b, uncurry (+) . bimap f g]
06:47:02 <lambdabot> Num a => (a1 -> a) -> (c -> a) -> [(a1, c) -> a]
06:47:12 <merijn> orbifx: You might need to specify more precisely what you want :)
06:47:37 <orbifx> yes, tuple of two lists. First has characters that need to be capitalised in second.
06:47:40 <hvr> merijn: yeah... I'm just pointing this out because ppl often think this is a hard-constraint for the solver
06:48:12 <hvr> merijn: and then are surprised the solver picks the excluded version anyway
06:48:13 <aweinstock> orbifx: try an explicit-recursive solution first, and worry about tersifying it afterwards?
06:48:39 <orbifx> aweinstock: you might be right
06:49:04 <orbifx> aweinstock: although I'm confident I can do it with recursion and want to learn more
06:49:48 <orbifx> but whenever i have written the recursive solution the terse one appears after that :P
06:49:54 <merijn> orbifx: I nearly always start with explicit recursion when unsure and refactor from there
06:50:14 <quchen> kosmikus: Thanks for all the papers on recursion schemes. I'm trying to build a (proof of concept for a) quite beasty syntax tree with heavy mutual recursion, and all the slides and papers on your site have been really helpful so far!
06:50:27 <orbifx> ok I'll write that and share. Ought to be the most precise way discuss it afterwards :P
06:50:28 <eguneys> how does this happen http://pastebin.com/MXssmLYg
06:50:45 <aweinstock> also, if you have a known-good recursive solution, quickcheck can help with verifying correctness of refactoring/tersification
06:51:19 <orbifx> aweinstock: quickcheck? some utility I imagine?
06:52:13 <tdammers> orbifx: I'm guessing, more like you can use the naive solution to verify the correctness of the optimized one
06:52:18 <aweinstock> orbifx: a library, you specify properties (boolean functions), and it generates random inputs to test them
06:52:21 <quchen> Quickcheck is a library to write tests for Haskell programs. It does a pretty amazing job, and should be part of any testsuite.
06:52:23 <aweinstock> :t quickCHeck
06:52:25 <lambdabot>     Not in scope: ‘quickCHeck’
06:52:25 <lambdabot>     Perhaps you meant ‘quickCheck’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
06:52:27 <aweinstock> :t quickCheck
06:52:28 <lambdabot> STestable prop => QuickCheck-2.8.1:Test.QuickCheck.Random.QCGen -> prop -> String
06:52:55 <tdammers> oh wait, you haven't heard of quickcheck itself
06:52:59 <aweinstock> > quickCheck (\x -> x+5 == 2 + x + 3)
06:53:01 <lambdabot>      Couldn't match expected type ‘Integer -> Bool’
06:53:01 <lambdabot>                  with actual type ‘QuickCheck-2.8.1:Test.QuickCheck.Random.QC...
06:53:01 <lambdabot>      The lambda expression ‘\ x -> x + 5 == 2 + x + 3’ has one argument,
06:53:06 <quchen> ?check \xs -> reverse (xs :: [Int]) == xs
06:53:07 <lambdabot>  *** Failed! Falsifiable (after 4 tests and 4 shrinks):
06:53:07 <lambdabot>  [0,3,-2]
06:53:54 <orbifx> :P
06:54:40 <Sindriav_> merijn: Nope, still not working *sigh*. Do you think you could look at the code?
06:55:14 <aweinstock> eguneys: (. even) is the same thing as (\f -> f . even)
06:55:31 <quchen> orbifx: Quickcheck's use case is pretty much to automate "trivial" tests you would write in other languages by providing unit tests with explicit example data sets - but the good thing is that Quickcheck automatically generates your data for you, so all you have to specify is an invariant, such as "reverse (reverse xs) == xs".
06:56:31 <eguneys> aweinstock: can you explain how the type of (Id . even) is happening
06:56:47 <eguneys> :t (Id . even)
06:56:48 <lambdabot>     Not in scope: data constructor ‘Id’
06:56:48 <lambdabot>     Perhaps you meant one of these:
06:56:48 <lambdabot>       ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted),
06:57:10 <quchen> orbifx: I typically pair Quickcheck (probabilistic checking) and HUnit (unit tests) for testsuites; Smallcheck is also worth considering.
06:57:54 <quchen> Smallcheck can be seen as "exhaustive Quickcheck" because it generates data deterministically instead of probabilistically. Big tests take a lot longer, but don't miss anything.
06:58:33 <orbifx> :P lots ot checks :P
06:58:53 <aweinstock> (Id :: a -> Id a) is put in the position of (Bool -> c) in ((. even) :: (Bool -> c) -> a -> c), so "a" unifies with "Bool", and therefore "c" unifies with "Id Bool"
06:59:33 <quchen> orbifx: Well, the biggest check of them all is the typechecker, which is free.
07:02:26 <aweinstock> eguneys: something possibly confusing, the polymorphic types (a and c) refer to different things in each expression
07:03:28 <aweinstock> is it clearer with (Id :: a -> Id a), ((. even) :: (Bool -> b) -> c -> b), ((Id . even) :: d -> Id Bool)?
07:04:00 <runeks> I've had success using foldrM to fold a list of values into an initial value. Now I want to read a list of values from a file, and apply foldrM to *that* list of values. So I guess I need to apply foldrM to [IO a] list rather than just [a]. How do I do that?
07:04:34 <merijn> runeks: Probably you want sequence plus >>=
07:04:35 <aweinstock> :t sequence
07:04:37 <merijn> :t sequence
07:04:37 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
07:04:38 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
07:05:18 <merijn> :t (sequence (undefined :: [IO a]) >>=)
07:05:19 <lambdabot> ([a] -> IO b) -> IO b
07:05:52 <merijn> Sindriav_: I'm about to head to the gym, so not a lot time atm :)
07:06:06 <bennofs> :t \f -> foldrM (\x acc -> x >>= (`f` acc))
07:06:08 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t (m a) -> m b
07:06:21 <bennofs> :t \f -> foldrM (\x acc -> x >>= (`f` acc)) `asAppliedTo` []
07:06:22 <lambdabot> (Monad m, Foldable t) => (a -> [t1] -> m [t1]) -> [t1] -> t (m a) -> m [t1]
07:07:01 <runeks> Thanks. I will take a look that sequence and >>=. I believe >>= led me to foldrM initially.
07:07:10 <bennofs> :t (\f -> foldrM (\x acc -> x >>= (`f` acc))) :: (a -> b -> IO b) -> b -> [IO a] -> IO b
07:07:11 <lambdabot> (a -> b -> IO b) -> b -> [IO a] -> IO b
07:07:17 <bennofs> runeks: how about that ^^^^?
07:07:29 <runeks> bennofs: I have no idea to be honest
07:08:13 <quchen> runeks: Maybe this helps understanding `sequence`: https://github.com/quchen/articles/blob/master/functions_comprehensible.md#sequencemapm
07:08:34 <orbifx> quchen: love the typechecker :)
07:13:58 <Sindriav_> merijn: Oh well, what can I do ^^
07:19:29 <eguneys> What is this mean
07:19:32 <eguneys> :type (3 even)
07:19:39 <eguneys> :t (3 even)
07:19:41 <lambdabot> (Integral a, Num ((a -> Bool) -> t)) => t
07:20:10 <athan> eguneys: go the other way!
07:20:14 <athan> :t even 3
07:20:15 <lambdabot> Bool
07:20:16 <athan> :t even
07:20:19 <lambdabot> Integral a => a -> Bool
07:20:20 <athan> :t 3
07:20:21 <lambdabot> Num a => a
07:20:28 <ysz> g'day gents
07:20:39 <athan> hiya
07:20:48 <eguneys> I am wondering what this means  :t (3 even)
07:21:06 <Aune> I have a newtype declaration: Graph id weight = Graph{getNeighbours id -> [(id, weight)]}, how do I require that weight be an instance of Num?
07:21:11 <mauke> eguneys: it means: apply the function 3 to the argument even
07:21:33 <geekosaur> eguneys, it's an unfortunate side effect of the way numeric literals work
07:22:03 <eguneys> what does the gibberish type signature do how do I interpret it
07:22:07 <aweinstock> is it possible to definite a sensible Num instance for ((a -> Bool) -> t)?
07:22:07 <eguneys> :t (3 even)
07:22:09 <lambdabot> (Integral a, Num ((a -> Bool) -> t)) => t
07:22:43 <aweinstock> :t fromIntegral
07:22:44 <lambdabot> (Integral a, Num b) => a -> b
07:23:06 <aweinstock> :t (fromIntegral 3) `asAppliedTo` ()
07:23:07 <lambdabot> Num (() -> b) => () -> b
07:23:19 <geekosaur> "if there exists an instance of Num for a function which takes (a function taking an "a" and producing a Bool) to a "t", and an instance of Integral for "a", then produce a "t""
07:23:24 <geekosaur> which, yes, is pretty ugly
07:24:26 <geekosaur> so, numeric literals get wrapped so they can produce any instance of Num. this allows you to use a literal 3 without worrying about the exact numeric type it needs to be... but allows the compiler quite a bit of latitude in finding instances of Num
07:24:32 <aweinstock> :t (3 `even`)
07:24:35 <lambdabot> Bool
07:24:38 <geekosaur> this is usually resolved by there being only sane instances of Num in scope
07:24:43 <aweinstock> > (3 `even`)
07:24:45 <lambdabot>  False
07:25:40 <aweinstock> :t \f -> (3 `f`)
07:25:42 <lambdabot> Num a => (a -> r) -> r
07:26:27 <aweinstock> does lambdabot have PostfixOperators enabled?
07:26:40 <clrnd> Aune, I think you have to use GADTs or ExistensialQuantification
07:26:57 <clrnd> for a class constraint in a data type
07:27:02 <Iceland_jack> aweinstock: 
07:27:03 <Iceland_jack> > let (!) n = product [1..n] in (6 !)
07:27:07 <lambdabot>  720
07:27:39 <Iceland_jack> > let fact'd n = product [1..n] in (6 `fact'd`)
07:27:41 <lambdabot>  720
07:28:35 <clrnd> > let (?) x = "lolz" in (6 ?)
07:28:36 <lambdabot>  "lolz"
07:28:43 <clrnd> I'm so gonna use this
07:28:47 <Aune> clnrd, but, but why :(
07:29:39 <clrnd> Aune, no idea! I know I've done it with those :P
07:29:40 <runeks> If I use sequence to transform a list of read operations [IO a] into IO [a], are all the read operations evaluated at once, or is each original IO action evaluated one by one as the items in the new list (IO [a]) are evaluated?
07:30:14 <clrnd> runeks, sequence is just a chain of >>=, so yeah it's as sequential as you make it
07:30:16 <bennofs> runeks: all the IO actions are evaluated before the list is returned
07:31:19 <Aune> clnrd, This is why I love Haskell ;)
07:31:35 <runeks> bennofs: Is there a way to have a [IO a] that is evaluated one-by-one?
07:31:38 <runeks> I'm using this now
07:31:40 <runeks> fmap catMaybes (sequence $ repeat (maybeReadBlock h))
07:32:13 <bennofs> runeks: you said you used foldrM before?
07:32:18 <runeks> But I need each maybeReadBlock to evaluate as the item it becomes in the lazy list its evaluated
07:32:22 <aweinstock> :t System.IO.Unsafe.unsafeInterleaveIO
07:32:24 <lambdabot> IO a -> IO a
07:32:26 <bennofs> aweinstock: NO!
07:32:29 <bennofs> :)
07:32:49 <aweinstock> bennofs: did you predict that I was going to suggest that before I typed it?
07:33:49 <bennofs> runeks: why do you need that? it's generally not such a good idea to make IO depend on evaluation (I know, the standard haskell IO library does it, doesn't mean it's a good thing...). A little bit more context might help to suggest alternative solutions
07:33:55 <aweinstock> runeks: unsafeInterleaveIO is the primitive that does lazy IO (like readFile), but lazy IO has problems with resource leaks
07:34:37 <aweinstock> runeks: pipes/conduit are the safe way of doing streaming IO in constant memory
07:34:43 <runeks> I want to foldr a list of items, and these items I want to read from a file.
07:34:55 <runeks> That's all I want to do basically
07:35:38 <aweinstock> :t Data.Conduit.List.fold
07:35:40 <lambdabot> Monad m => (b -> a -> b) -> b -> conduit-1.2.5:Data.Conduit.Internal.Conduit.ConduitM a o m b
07:35:46 <runeks> I already know how to use foldrM when I'm not in the IO monad, but I can't figure it out with IO.
07:35:48 <clrnd> Aune, me too!
07:35:59 <opqdonut> runeks: a) you could write your own fold with type (Item -> result -> result) -> result -> Handle -> IO result
07:36:16 <opqdonut> runeks: b) you could use pipes/conduits/iteratees for a more abstract solution
07:36:23 <opqdonut> runeks: c) you can use lazy io for a hacky solution
07:36:25 <glguy_> readFile is already lazy
07:36:29 <opqdonut> runeks: foldrM doesn't really help
07:38:32 <runeks> opqdonut: I'm interested in the hacky solution
07:38:43 <runeks> opqdonut: I'm trying to use lazy IO, but it don't work
07:38:53 <runeks> I just need something that works, for now
07:38:59 <quchen> > let (!) = id; dammit = error in   dammit! "this failed" -- Iceland_jack  :-)
07:39:01 <lambdabot>  *Exception: this failed
07:39:15 <clrnd> lol
07:39:27 <glguy_> foldr might not be the right fold though
07:39:46 <glguy_> And "it doesn't work" isn't enough to help
07:40:41 <bennofs> runeks: you can use foldrM in the IO monad as well. For example, you can do: foldrM (\ioaction accumulator -> do value <- ioaction; ...; return newAccumulator) initialAccumulator listOfIOActions
07:40:57 <aweinstock> runeks: if you have (IO [a]), you only need foldrM if each accumulating step needs to do IO, foldr should work if the accumulation is pure
07:42:42 <aweinstock> :t \f initial -> (undefined :: IO [a]) >>= return . foldr f initial
07:42:44 <lambdabot> (a -> b -> b) -> b -> IO b
07:43:10 <runeks> I'm folding using a function that returns an Either, I believe that is why I need foldrM
07:43:33 * hackagebot smallcheck-series 0.5 - Extra SmallCheck series and utilities  https://hackage.haskell.org/package/smallcheck-series-0.5 (jdnavarro)
07:44:09 <aweinstock> with stop-at-the-first-Left semantics? yeah, foldrM sounds correct for that
07:44:20 <runeks> bennofs: That's probably the solution I need. To fold in a list of IO actions, and evaluate them inside IO.
07:47:16 <lingxiao> is there a function that allows me to take arbitrary many input args and put them into a tuple?
07:47:16 <glguy_> Runeks, pastebin some code?
07:47:29 <glguy_> No
07:47:32 <lingxiao> ie toTuple f1 ... fn = (f1, ..., fn)
07:47:59 <frerich> lingxiao: No, but if you could explain where you would use that function then we might be able to propose a nice alternative.
07:48:21 <aweinstock> it might be possible to do that specifically with typeclass hackery/data families?
07:48:48 <lingxiao> something like toTuple <$> fold1 <*> fold2 <*> ... <*> foldn
07:49:11 <lingxiao> where each foldi is a Fold a b type
07:50:08 <lingxiao> see what is this here . .http://okmij.org/ftp/Haskell/polyvariadic.html#polyvar-fn
07:51:27 <lingxiao> point is the n in the fold1 <*> fold2 <*> ... <*> foldn is variable
07:51:39 <aweinstock> with the TupleSections extension, you can use things like (,,,,)
07:51:43 <aweinstock> :t (,,,,,)
07:51:45 <lambdabot> a -> b -> c -> d -> e -> f -> (a, b, c, d, e, f)
07:51:58 <glguy_> That's just normal Haskell
07:52:27 <aweinstock> oh, TupleSections is ((,x) = \y -> (y, x))?
07:52:37 <mauke> :t (x, , z)
07:52:38 <lambdabot> t -> (Expr, t, Expr)
07:52:40 <mauke> yeah
07:54:16 <quchen> lingxiao: What't the type of "toTuple 1 2 3"? Is it (1,2,3)? Is it \x -> (1,2,3,x)?
07:54:35 <quchen> Eh, mixed up value/type there.
07:54:39 <quchen> You get the point.
07:55:10 <lingxiao> it should be toTuple = \v1 ... vn -> (v1, ..., vn)
07:55:14 <aweinstock> :t printf
07:55:15 <lambdabot> PrintfType r => String -> r
07:55:21 <lingxiao> so just put the output in a tule
07:55:25 <lingxiao> tuple*
07:55:42 <quchen> lingxiao: Right, but you cannot decide when to "end". You could always mean a curried version of "generate an n+1 tuple".
07:56:07 <quchen> toTuple 1 2 -- could be (1,2), \x -> (1,2,x), \x y -> (1,2,x,y), …
07:56:31 <quchen> In other words, that function isn't well-typed.
07:56:52 <lingxiao> hmm ... still not following exactly .. but I'd like to examine the tuple afterwards ... so it should be a fully evaluated function ..
07:56:57 <aweinstock> :t printf "%d %d"
07:56:59 <lambdabot> PrintfType r => r
07:57:04 <aweinstock> :t printf "%d %d" 0 1
07:57:05 <lambdabot> PrintfType t => t
07:57:12 <aweinstock> > printf "%d %d" 0 1
07:57:14 <lambdabot>      No instance for (Show a0)
07:57:14 <lambdabot>        arising from a use of ‘show_M416263226547022956026052’
07:57:14 <lambdabot>      The type variable ‘a0’ is ambiguous
07:58:03 <quchen> > printf "%d %d" 0 1 :: String -- aweinstock 
07:58:05 <lambdabot>  "0 1"
07:58:46 <aweinstock> > printf "%d %d" 0 1 2 :: String
07:58:48 <lambdabot>  "0 1*Exception: printf: formatting string ended prematurely
07:59:00 <aweinstock> > printf "%d %d" 0 :: String
07:59:02 <lambdabot>  "0 *Exception: printf: argument list ended prematurely
07:59:28 <lingxiao> but yeah I'm open for anything that does what I'm tryng to acheive
07:59:39 <aweinstock> quchen: why wouldn't similar hackery work for toTuple?
07:59:49 <lingxiao> basically I have n outputs from an applicative like f1 <*> ... <*> fn 
08:00:04 <lingxiao> and I need to put the results in a data structre so I can examine it
08:00:10 <lingxiao> print it , etc
08:00:28 <aweinstock> if n is fixed, just use (,,,,,,,) (n-1 commas)
08:01:24 <quchen> aweinstock: Maybe, maybe not. I prefer to not think about varargs much, and while we're at it tuples greater than 3 entries are code smells. :-þ
08:05:00 <quchen> aweinstock: I think the parametrized result type disallows it
08:05:17 <quchen> With printf you can get away with the hack because you ultimately map to IO () or String
08:05:56 <quchen> And your input pattern is also a String
08:06:10 <quchen> With tuples your result type would be a tuple of arbitrary type, and so would be your inputs
08:10:13 <mauke> https://www.fpcomplete.com/project/130803/Fi4Vji7n7t
08:10:26 <mauke> all you need is N instances and type annotations everywhere
08:11:26 <eguneys> How can I make an instance of Num for a function (a -> b)?
08:12:37 <quchen> mauke: Let's change the requirement to "less boilerplate than hardcoding all the functions" :-þ
08:12:40 <geekosaur> ... why would you want to do that
08:12:51 <geekosaur> it's a recipe for pain and suffering
08:12:53 <eguneys> to learn if possible and what it means
08:13:01 <Denommus> eguneys: instance Num (a -> b) where...
08:13:04 <mauke> eguneys: instance (Num a) => Num (e -> a) where fromInteger = pure . fromInteger; (+) = liftA2 (+); negate = liftA negate
08:13:07 <quchen> It's possible and it means pain and suffering :-þ
08:13:31 <quchen> The pain starts when you want to decypher mauke's definition.
08:13:33 <Denommus> eguneys: I'm wrong, mauke is right
08:14:13 <geekosaur> well, you were "right" but mauke's actually has some slight usefulness
08:14:20 <geekosaur> emphasis on "slight"
08:14:31 <quchen> A sometimes more useful version of the same concept is the  Monoid r => Monoid (a -> r)  instance
08:16:41 <aweinstock> eguneys: an instance for Num (a -> b) means that (f + g) is defined (and with mauke's definition, (f+g) = (\x -> f x + g x), I think)
08:17:20 <mauke> yeah
08:17:31 <mauke> it's written that way because it generalizes to all applicatives
08:19:14 <gigabytes> hello
08:19:19 <gigabytes> I'm trying out stack
08:19:33 <gigabytes> is this the right channel to ask questions or is there a specific channel about stack?
08:20:18 <geekosaur> there is #haskell-stack but it's a bit sparse... can ask here
08:21:43 <aweinstock> mauke: as in, "instance (Applicative f, Num a) => Num (f e a) where fromInteger = pure . fromInteger"?
08:22:11 <aweinstock> :k Applicative
08:22:12 <lambdabot> (* -> *) -> Constraint
08:22:56 <mauke> aweinstock: yes, except without the e
08:23:12 <mauke> and also you can't do that because it'd overlap everything
08:23:39 * hackagebot language-lua2 0.1.0.1 - Lua parser and pretty printer  https://hackage.haskell.org/package/language-lua2-0.1.0.1 (mitchellwrosen)
08:25:07 <aweinstock> mauke: oh, so ((->) e) is the Applicative?
08:25:22 <mauke> yes
08:25:29 <aweinstock> ok, that makes sense
08:26:55 <athan> Anyone here sucessfully derive Witherable for a newtype?
08:27:09 <athan> I get some type role issues when I try on 7.10.2
08:28:43 <bennofs> athan: paste the code + error please
08:30:32 <gigabytes> so I'll ask here too. I'm trying stack and I still don't understand which is the way to have as a dependency a package which is on hackage but not on LTS
08:30:48 <gigabytes> I think to have understood it has to be put in the extra-deps section of the yaml file
08:31:05 <cocreature> yep that's exatcyl it
08:31:08 <cocreature> *exactly
08:31:23 <cocreature> - packagename-exact-version
08:31:30 <cocreature> you need to have a line like that in extra-edps
08:31:30 <gigabytes> but then, if the package has constraints on its own dependencies that conflict with what is installed from the LTS?
08:31:56 <cocreature> then you need to specify the newer versions of the deps also in extra-deps
08:32:03 <gigabytes> do I have to list in extra deps all the descending conflicting dependencies?
08:32:05 <gigabytes> ok
08:32:32 <gigabytes> and second question: should I want to use cabal, I've installed it with stack install cabal-install
08:32:44 <gigabytes> but cabal on every run complains that it doesn't find ghc
08:32:53 <gigabytes> how can I tell cabal to use the ghc installed by stack?
08:33:15 <gigabytes> or, anyway, how to configure cabal installed from stack to use the things installed by stack?
08:34:07 <cocreature> you could put it manually in your path or use cabal inside of stack exec so that stack puts it temporarely in your path. not sure if there is a parameter for specifiying the ghc path as an argument to cabal
08:34:27 <gigabytes> cocreature: already tried to to stack exec cabal, but the problem persists
08:38:41 * hackagebot timeout-control 0.2 - Updatable timeouts as a Monad transformer  https://hackage.haskell.org/package/timeout-control-0.2 (NathanHowell)
08:43:42 * hackagebot moesocks 0.1.1.32 - A functional firewall killer  https://hackage.haskell.org/package/moesocks-0.1.1.32 (JinjingWang)
08:49:13 <lpaste_> athan pasted “Type role / representation error for deriving Witherable” at http://lpaste.net/139963
08:49:20 <athan> bennofs: ^ There we go
08:49:27 <athan> sorry it took so long
08:50:26 <orbifx> merijn, aweinstock http://lpaste.net/1670829852527165440
08:50:50 <orbifx> it's already giving me a load of suggestions there, but that is the function that needs to be refactored
08:53:45 <bennofs> athan: Oh, I think in that case, you're not going to be able to avoid writing the instance manually.
08:54:32 <bennofs> athan: the problem is that GHC can't know that it has to use fmap, like you do in your manually-written instance
08:54:54 <bennofs> athan: instead, it emits code like: coerce $ wither f xs, where coerce can convert types with the same representation
08:56:21 <bennofs> athan: however, with type families, there can be types f where `f (Foo a)` and `f [a]` don't have the same representation: consider type family X a where X (Foo a) = Int; X [a] = Bool;  data Bad a = Bad (X a)
08:57:05 <bennofs> athan: so despite the representations of `[a]` and `Foo a` being the same, that doesn't imply that `f [a]` and `Foo a` are equally represented at runtime
08:57:34 <bennofs> brb, reboot
08:59:09 <erisco> is  encodeUtf8 . decodeUtf8 = id?
08:59:37 <bennofs> erisco: no, since decodeUtf8 throws an error on invalid input I think
08:59:54 <erisco> okay, assuming input is valid UTF8
09:01:07 <erisco> I'd like to get the byte offset of each Char
09:01:15 <bergmark> i've assumed it is...
09:01:45 <erisco> rewriting decodeUtf8 to provide this looks onerous
09:02:16 <erisco> but if I could encode a Char back to bytes under UTF8
09:02:25 <erisco> well, it would be slow and stupid, but I wouldn't have to rewrite libs
09:03:09 <athan> bennofs: Oh okay that makes a lot of sense
09:03:10 <athan> thank you
09:04:10 <erisco> you cannot jump to the nth character but you can jump to the nth byte
09:04:18 <erisco> which is why it is useful
09:16:06 <rob_frankie1> I'm trying to compile an executable that depends on the lvish library, which itself depends on the bits-atomic library. I'm getting the following error when I try to compile my executable:
09:16:13 <rob_frankie1> can't load .so/.DLL for: /home/rob/.cabal/lib/i386-linux-ghc-7.10.1/bitsa_EfESR243Us2C1YfvGtoj49/libHSbits-atomic-0.1.3-EfESR243Us2C1YfvGtoj49-ghc7.10.1.so (/home/rob/.cabal/lib/i386-linux-ghc-7.10.1/bitsa_EfESR243Us2C1YfvGtoj49/libHSbits-atomic-0.1.3-EfESR243Us2C1YfvGtoj49-ghc7.10.1.so: undefined symbol: nand_and_fetch_8)
09:16:38 <glguy> You can find the beginnering of each encoded unicode codepoint in UTF-8 without fully decoding it. All continuation bytes have the same marker
09:16:57 <rob_frankie1> This symbol is defined in atomic-bitops-gcc.h in the bits-atomic library.
09:17:06 <rob_frankie1> inline unsigned char nand_and_fetch_8 (unsigned char *, unsigned char );
09:17:16 <rob_frankie1> So I'm stumped in how to resolve my compilation error :-/
09:19:30 <erisco> glguy, that still doesn't let you jump though
09:19:31 <lingxiao> hey all 
09:19:54 <lingxiao> Im writing this test case for the function Invert :: [(a,b)] -> [(b,a)]
09:20:42 <lingxiao> and when I write the test case `testinvert = "invert" ~: TestList [invert ([] :: (Eq a, Eq b) => [(a,b)]) ~?= ([] :: (Eq a, Eq b) => [(a,b)])]`
09:21:24 <lingxiao> or if you like .. http://lpaste.net/139964
09:22:01 <lingxiao> I am getting error .. http://lpaste.net/139965
09:22:53 <glguy> lingxiao: You need to pick an 'a' and a 'b'
09:23:09 <lingxiao> But if I change it to some conceret type, ie Eq a => (a,Int) I am ok
09:23:12 <lingxiao> so I need to pick one?
09:23:20 <lingxiao> why is this?
09:23:40 <glguy> To build the equality operation on lists GHC needs to know what the types are
09:24:17 <glguy> The equality operation on lists is built in terms of the equality operation on the elements of the list, whether or not that list has elements
09:24:38 <lingxiao> so why is it ok to have one polymorphic instance `a`, as in Eq a => [(a,Int)]
09:25:05 <glguy> Probably because of the way you're using it with invert
09:25:16 <glguy> GHC eventually determines that that 'a' is going to be Int, too
09:29:56 <lingxiao> yeah you're right, i didnt even need the Eq a constriant there
09:29:57 <lingxiao> thanks
09:35:19 <erisco> so... UTF-8 bypasses endianness problems just by defining its own endianness?
09:36:48 <monochrom> perhaps
09:37:07 <monochrom> it still doesn't say how to order the 8 bits in each byte, though.
09:37:29 <erisco> has that ever been an issue? I haven't heard of it
09:37:35 <monochrom> :)
09:37:58 <erisco> it is just weird that it words it as though it does something special to fix endianness
09:38:33 <erisco> but it seems to just pick big endian
09:39:38 <harlchen> hi, i try to get this http://lpaste.net/new/haskell to work, but i miss where the conversion from Int to Pixel8 should occour 
09:39:57 <lpaste_> harlchen pasted “juicypixels” at http://lpaste.net/139967
09:40:08 <harlchen> this one ^^
09:43:08 <hodapp> Does some terminology describe the case in which a term is only ever found 'inside' a monad and the types do not permit any way to use it outside of that?
09:43:49 <monochrom> I say that the term is an action.
09:44:08 <monochrom> for example getLine is an action.
09:44:15 <Welkin> hodapp: like the s in ST?
09:44:46 <hodapp> Welkin: I suppose
09:45:16 <monochrom> eh? you are not sure what you mean?
09:45:23 <Welkin> isn't that existential quantification?
09:45:44 <hodapp> monochrom: I'm not so much talking about the action that 'returns' the term, but rather of that term itself.
09:45:56 <glguy> The 's' in 'ST s' is just a normal phantom type parameter, no quantification
09:46:06 <hodapp> Welkin: I'm not especially familiar with ST, though.
09:46:08 <monochrom> in my example, getLine is the term.
09:46:59 <monochrom> in my example, no one is returning anything.
09:47:08 <nullvoid8> hodapp: do you mean something like MyMonad (MyFoo a) where nothing allows you to act on just a (MyFoo a) ?
09:47:25 <erisco> "Invalid UTF-8 has been used to bypass security validations in high profile products including Microsoft's IIS web server[13] and Apache's Tomcat servlet container."
09:47:28 <erisco> this makes me lol a bit
09:48:31 <hodapp> nullvoid8: a MyMonad (MyFoo a) where operations on just a (MyFoo a) are sensible, but where you are not going to encounter one except for 'inside' of MyMonad.
09:49:35 <monochrom> well then you really have to go ST and see "newSTRef :: ST s (STRef s a)"
09:50:07 <erisco> even if your UTF-8 decoding was too permissive, I am not sure how this ultimately gives you a security vulnerability without doing something else silly
09:50:08 <nullvoid8> hodapp: so something like IORef where the only way to produce one is newIORef :: a -> IO (IORef a)
09:50:24 <hodapp> I feel like I've seen tutorials and documentation refer then to the (MyFoo a) as always being 'inside' whatever monad, but I've seen that terminology criticized as well.
09:50:38 <erisco> maybe some string concatenation type of things
09:51:56 <hodapp> but I don't know what else to call something, then, than being inside a monad.
09:52:37 <breadmonster> hodapp: Hello.
09:52:47 <hodapp> breadmonster: hiya
09:53:56 <erisco> well, 'IORef a' is applied to IO
09:54:32 <erisco> do you say that for 'not True' that 'True' is inside the negation? I don't know
09:55:28 <ysz> System.Info.compilerVersion lacks third number i.e only says 7.10 instead of 7.10.2
09:55:30 <hodapp> I guess some folks just object to saying it's "in" a monad because it can be misleading.
09:55:36 <ysz> how do I figure last one?
09:57:57 <erisco> "newIORef returns IO-applied IORef's"
09:57:58 <Cale> hodapp: You can refer to actions of the particular monad, like you can say that such and such is an IO action.
09:58:02 <erisco> doesn't have the ring to it does it
09:58:09 <monochrom> is it really important to reserve a word for it? IMO just plain "it is no good outside that context" suffices.
09:58:11 <erisco> "newIORef returns IORef's in IO"
09:58:19 <Cale> newIORef produces an IO action whose result is an IORef.
09:58:29 <Cale> Much more sensible
09:58:30 <hodapp> monochrom: I'm just trying not to totally mangle terminology in how I refer to something; communication matters to me.
09:58:46 <Cale> :t
09:58:51 <Cale> :t newIORef
09:58:52 <lambdabot>     Not in scope: ‘newIORef’
09:58:52 <lambdabot>     Perhaps you meant ‘newSTRef’ (imported from Data.STRef)
09:58:59 <Cale> :t Data.IORef.newIORef
09:59:00 <lambdabot> a -> IO (GHC.IORef.IORef a)
09:59:05 <hodapp> Cale: yeah, that would seem to make more sense
09:59:11 <Cale> ^^ or you could just write the type :)
09:59:22 <Cale> (preferably without the ugly module qualification)
09:59:36 <hodapp> I guess I shy away from using the term 'action' outside of side effects
10:00:05 <erisco> maybe it needs an -able suffix
10:00:16 <erisco> "newIORef returns IOable IORefs"
10:00:17 <Cale> Well, if something is a list, you probably don't say "action" unless you're really thinking about how the Monad instance is coming into play
10:00:18 <hodapp> we'd need a suffixable word for that
10:00:26 <Cale> You just call it a list like usual.
10:00:37 <Cale> The fact that IO is a monad is not very important.
10:00:40 <erisco> you just suffix the name of the Monad oO
10:00:52 <Cale> and we should really not even be saying "the IO monad" as much as we do, imo.
10:01:01 <safinaskar> how to convert [-2, -1, 2, 4, -1, 5] to [([-2, -1], [2, 4]), ([-1], [5])]?
10:01:19 <safinaskar> i. e. all positive, then all negative, then again all positive etc
10:01:20 <hodapp> I hardly say "IO" as is because I'm usually stuck in the Ivory monad >_>
10:02:02 <erisco> :t span -- safinaskar
10:02:03 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
10:02:08 <hodapp> well, I guess I use Shake and it has various monads that can lift to IO
10:02:31 <Cale> > groupBy ((==) `on` signum) [-2, -1, 2, 4, -1, 5]
10:02:33 <lambdabot>  [[-2,-1],[2,4],[-1],[5]]
10:03:29 <safinaskar> Cale: wow! thanks a lot
10:03:31 <erisco> but is "lift" the right word
10:03:40 <erisco> or is it misleading
10:03:46 <erisco> are monads "up there"?
10:03:54 <hodapp> dunno
10:04:05 <hodapp> I always consider burritos as sitting on tables, next to each other
10:04:10 <Cale> hodapp: Wrong direction, you lift IO actions to produce Shake actions.
10:04:47 <hodapp> s/lift to/lift from/
10:05:01 <hodapp> prepositions are difficult in Mondays
10:05:26 <Cale> right :)
10:07:14 <erisco> I am worried now of why the decodeUtf8 function looks so complicated
10:07:22 <erisco> when the Utf8 spec looks simple
10:07:40 <hodapp> Utf8 spec or UTF-8 spec?
10:07:55 <erisco> UTF-8
10:08:49 <hodapp> okay, wasn't sure if Utf8 was a type you were referring to or something
10:08:56 <hodapp> I never knew UTF-8 was that simple of a spec
10:09:27 <hodapp> of course most of my UTF woes were from having UTF-16 everywhere
10:09:31 <monochrom> which decodeUtf8 function?
10:09:39 <Cale> erisco: Heh, you've got me wondering now whether this fibrational-sort-of-language is really appropriate too now. Well, generally when we have some type B which is somehow similar to type A but with more structure in some way, we view B as "over" A, especially when there are canonical mappings in one direction or the other. This terminology comes from a setting where there's usually a canonical projection *downward* th
10:09:39 <Cale> ough, whereas in most of the cases we use it in Haskell, there's a canonical inclusion map going upward.
10:10:22 <erisco> monochrom, the one true decodeUtf8 http://hackage.haskell.org/package/streaming-commons-0.1.12.1/docs/Data-Streaming-Text.html
10:11:27 <erisco> Cale, my understanding of fiber can be summarized by an oat flakes box
10:11:36 <monochrom> that is a really ambitious decoder. its complexity is due to its ambition, not due to decoding UTF-8.
10:11:37 <geekosaur> the complication there has less to dowith the utf-8 spec than it has to do with handling things split across buffers
10:12:32 <monochrom> FWIW I could write a variant of getByte that is no less complicated.
10:13:08 <erisco> because... the bytestring is chunked? or what?
10:13:27 <erisco> what is the ambition
10:14:05 <monochrom> "streaming"
10:14:12 <Welkin> maybe because Text is represented as an Array of 16-bit values?
10:14:27 * nshepperd thinks of lifting as giving things superpowers
10:14:43 <nshepperd> or at least, moving them to where the folks with superpowers live
10:15:13 <erisco> also UTF-8 doesn't decode to Char does it
10:15:21 <erisco> otherwise what is this surrogate pair nonsense being mentioned
10:15:30 <monochrom> look, if you take a look at attoparsec's "incremental parser", you see the same thing
10:17:28 <geekosaur> it's going via Data.Text from the looks of it; that is UTF16 and must deal with surrogate pairs
10:17:35 <erisco> WTF-8
10:18:08 <erisco> this has become all manner of confusing
10:19:17 <glguy> erisco: Read about CESU-8 to see how surrogate pairs can find themselves in UTF-8 encoded content
10:19:30 <erisco> I am just wondering why I should care about it
10:21:24 <erisco> so, this isn't decodeUtf8 at all
10:21:41 <erisco> this is decodeCesu8
10:22:52 <erisco> some bastard child of utf-8 and utf-16
10:23:44 <erisco> and it scares me that my text editor has "UTF-8" and "UTF-8 without BOM"
10:23:48 <erisco> why does it ever need a BOM?
10:24:07 <Clint> to rule and regulate you
10:24:09 <glguy> Because you wanted to open a file edited in Notepad.exe?
10:24:29 <erisco> what does Notepad have to do with it?
10:24:39 <glguy> It's a common application that uses the BOM
10:25:00 <hodapp> WTF-8 = UCS-2?
10:25:17 <erisco> hodapp, nope
10:25:51 <hodapp> there's another?
10:26:43 <erisco> hodapp, apparently so, though I am guessing it is just the defacto "this is what everyone is actually using" https://en.wikipedia.org/wiki/UTF-8#WTF-8
10:27:00 <hodapp> blugh
10:27:25 <hodapp> converting from WTF-8 or whatever to UTF-8 was a royal pain in the C++ I wrote at the last job
10:27:51 <hodapp> still have no idea why the devs insisted that our internal string type had to be some bastard variety of UTF-16
10:28:20 <erisco> so, the BOM does nothing, it is just tolerated
10:29:05 <glguy> It indicates the encoding used for the rest of the file
10:29:09 <erisco> I am wondering how far you get by just using UTF-8 as per the spec
10:30:28 <mauke> I normally use WTF-8 to refer to double-encoded UTF-8
10:31:57 <erisco> why did they need 10 for a continuation byte?
10:32:06 <erisco> you've already got the leading byte indicating how many follow
10:33:53 * hackagebot linearscan 0.10.1 - Linear scan register allocator, formally verified in Coq  https://hackage.haskell.org/package/linearscan-0.10.1 (JohnWiegley)
10:33:55 * hackagebot linearscan-hoopl 0.10.1 - Makes it easy to use the linearscan register allocator with Hoopl  https://hackage.haskell.org/package/linearscan-hoopl-0.10.1 (JohnWiegley)
10:34:40 <Welkin> W is Double U
10:34:43 <nshepperd> in utf-8?
10:34:48 <Welkin> although it is really a Double V
10:34:51 <erisco> yes
10:35:03 <erisco> Welkin, maybe you'd enjoy French
10:35:29 <nshepperd> two reasons, they wanted to be fully compatible with ascii
10:36:01 <nshepperd> and also for the stream to be reorientable
10:36:06 <nshepperd> or whatever the term is
10:36:23 <erisco> okay, can you explain both of those please
10:36:39 <nshepperd> so multi-bytes encodings have to start each byte with the high bit set
10:37:11 <nshepperd> so that they never include an ascii byte by accident
10:38:20 <erisco> yes, okay
10:38:28 <erisco> so how does this get to the continuation code 10
10:39:56 <nshepperd> it's 10xxxxxx instead of just 1xxxxxxx, so that someone starting in the middle of a utf-8 stream can reliably find the next character boundary
10:41:17 <nshepperd> a utf-8 character starts at either 11, in which it starts a multibyte sequence, or 0, in which case it's a single byte ascii char
10:44:51 <erisco> nshepperd, okay
10:47:29 <nshepperd> basically, there are three cases they need to signal for each byte, leading bitstring 0 is already taken, so the next shortest available are 10 and 11
10:49:24 <noraintherun> \quit
10:57:50 <erisco> and as for my first question, at least for proper utf-8, the mapping is unique
10:58:01 <erisco> by design
10:59:30 <monochrom> what was your first question?
10:59:47 <erisco> whether the mapping was unique
11:00:10 <erisco> well, for whatever decodeUtf8 is doing
11:00:14 <erisco> and I don't know what it is doing
11:00:23 <erisco> certainly not UTF-8
11:00:42 <monochrom> you are looking at an incremental parser. have you seen an incremental parser before?
11:00:57 <erisco> no I am not looking for an incremental parser
11:01:12 <monochrom> ok, then don't use this library.
11:01:19 <erisco> I'm not
11:01:25 <erisco> I am using a lib that uses a lib that uses this
11:01:34 <monochrom> there are a ton of libraries containing UTF-8 decoding, and most of them are not incremental
11:01:54 <monochrom> contrary to what you said about "the one true"
11:02:24 <erisco> I was just referring to how my particular dependencies lead to it
11:03:05 <monochrom> ok. I think I will just say "my sympathy" and leave it at that.
11:03:38 <erisco> coming from a bytestring
11:03:44 <erisco> I am assuming these are chunked in their lazy form
11:03:52 <erisco> which means a character can be split over two chunks
11:04:15 <ReinH> Why would that be a problem?
11:04:26 <ReinH> Bytestrings need to be decoded to be used as utf-whatever.
11:04:41 <erisco> there are at least two policies you could use
11:04:53 <ReinH> This decoding wouldn't be done chunk-by-chunk, but byte-by-byte, so chunk boundaries are irrelevant.
11:05:10 <erisco> if you encounter an incomplete character at the end of the chunk you could either return the decoded characters you have already
11:05:18 <erisco> or you could pull in the next chunk to complete the character
11:05:20 <ReinH> The whole point of lazy bytestring is that its chunked representation is an implementation detail that is hidden from its users
11:05:50 <erisco> if you want to keep the gig going then it helps to not have the chunks invisible
11:06:02 <erisco> chunked bytestring to chunked char string
11:06:09 <ReinH> "the gig"?
11:06:32 <monochrom> ReinH: erisco is looking at http://hackage.haskell.org/package/streaming-commons-0.1.12.1/docs/Data-Streaming-Text.html and wondering "why is it so complicated?", by which I bet he means "why not simply ByteString->Text or even ByteString -> Maybe Text".
11:06:33 <ReinH> I mean, if you purposefully expose the implementation details of lazy bytestring then you have to deal with the implementation details.
11:06:36 <ReinH> I'm not sure what the issue is
11:06:49 <erisco> monochrom, no at all
11:07:01 <monochrom> need I quote your own words?
11:07:16 <erisco> uh
11:07:38 <erisco> I guess we've switched to attack mode
11:08:18 <erisco> is someone else posing as me and I can't see the messages? I don't know what either of you are talking about
11:08:28 <glguy> You're been going on a for a while, but no one seems to know what your point is
11:08:56 <erisco> I wasn't making a point
11:09:21 <glguy> You're been going on a for a while, but no one seems to know why
11:10:15 <erisco> um, well there was an initial discussion
11:10:26 <Welkin> erisco: you have fallen through a tear in space-time and arrived in a parallel universe where you will confront your evil twin and destroy existence
11:10:30 <erisco> and then I responded just a few minutes ago answering the initial question
11:10:45 <erisco> and then I've been trying to respond to strangeness since
11:10:58 <Welkin> erisco: the proof lies with the Bernstain Bears!
11:11:12 <erisco> are they related to the Berenstein Bears?
11:11:25 <bitemyapp> Welkin: speeeling #rekt
11:11:25 <Welkin> stain* not stein!
11:11:29 <Welkin> that is the proof!
11:11:33 <bitemyapp> erisco: speeeling #riposte
11:11:46 * erisco is critically wounded
11:14:48 <ReinH> bitemyapp uses spelling nazi
11:14:51 <ReinH> it is super effective
11:15:20 <edmondo1984> I have hard time in understanding why the following example (taken by the LYHFGG) works:      ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5       [8.0,10.0,2.5]    Which functor will the <$> map on? Is that the `(a -> b)` functor? How does this is combined with the list, and why?
11:16:00 <bitemyapp> ReinH: tbf berenstain is hard af to remember how to spell
11:16:31 <bitemyapp> must've been brutal for the authors having that last name
11:16:35 <bitemyapp> everybody gets it wrong
11:16:49 <erisco> :t (+3) <*> (*2) <*> (/2)
11:16:50 <lambdabot>     Occurs check: cannot construct the infinite type: a1 ~ a1 -> a -> b
11:16:50 <lambdabot>     Expected type: (a1 -> a -> b) -> a1
11:16:50 <lambdabot>       Actual type: a1 -> a1
11:16:55 <shachaf> edmondo1984: It's the (a ->) functor.
11:17:19 <shachaf> The list isn't important.
11:17:33 <shachaf> If you wrote (\x y z -> x + y + z) it would be the same functor.
11:17:53 <erisco> riight
11:18:26 <Welkin> edmondo1984: for functions, fmap is composition
11:18:38 <erisco> funny how precedence works with infix operators
11:20:36 <erisco> :t \f -> f <$> (+3) <*> (*2) <*> (/2)
11:20:39 <lambdabot> Fractional a => (a -> a -> a -> b) -> a -> b
11:20:44 <erisco> maybe that is a bit less confusing, I don't know
11:22:10 <M-ou-se> if i do `foo :: (MonadState m, MonadExcept m) => m`, i can't know for sure which of the two (state/except) is the outer and which is the inner layer. it's quite important, since if it is the wrong way around, that would mean that foo would change the state, even when it fails. how can i restrict it to only one order?
11:22:19 <aweinstock> > (,,) <$> (+3) <*> (*2) <*> (/2)
11:22:21 <lambdabot>  <Double -> (Double,Double,Double)>
11:22:37 <aweinstock> > ((,,) <$> (+3) <*> (*2) <*> (/2)) 0
11:22:39 <lambdabot>  (3.0,0.0,0.0)
11:23:55 <edmondo1984> yes the first part I understand it
11:24:08 <edmondo1984> that the functor is the functor of a Function
11:24:30 <edmondo1984> what I don't understand is that why composing (+3) (*2) (/2)  
11:24:36 <edmondo1984> and apply that over a list
11:24:48 <edmondo1984> applies the +3 to the first element, the *2 over te second and so on
11:25:21 <erisco> but it doesn't
11:25:30 <edmondo1984> the result is
11:25:37 <erisco> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5   is being applied to '5', not a list
11:25:43 <edmondo1984>   [8.0,10.0,2.5] 
11:25:52 <erisco> yeah, it is collecting the results in a list
11:25:54 <edmondo1984> I was expecting to have a list of three identical results
11:26:00 <aweinstock> :t (<$> (+3) <*> (*2) <*> (/2))
11:26:02 <lambdabot>     The operator ‘<$>’ [infixl 4] of a section
11:26:02 <lambdabot>         must have lower precedence than that of the operand,
11:26:02 <lambdabot>           namely ‘<*>’ [infixl 4]
11:26:02 <edmondo1984> all equal to 8
11:26:05 <erisco> <*> is not function composition
11:26:11 <aweinstock> :t (<$> ((+3) <*> (*2) <*> (/2)))
11:26:13 <lambdabot>     Occurs check: cannot construct the infinite type:
11:26:13 <lambdabot>       a2 ~ a2 -> a1 -> a
11:26:13 <lambdabot>     Expected type: (a2 -> a1 -> a) -> a2
11:26:40 <erisco> if you want function composition use (.)
11:26:50 <edmondo1984> right <*> is f(a -> b) -> f a -> f ->b
11:27:25 <edmondo1984> so in order, in the expression (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5    
11:27:27 <edmondo1984> what happens?
11:27:49 <erisco> okay, well first I would define <*> for functions
11:28:20 <aweinstock> https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-617
11:28:37 <edmondo1984> ok
11:28:55 <Welkin> > (\x y z -> [x,y,z]) <$> f <*> g <*> h $ x :: Expr
11:28:56 <lambdabot>      Couldn't match type ‘[t0]’ with ‘Expr’
11:28:56 <lambdabot>      Expected type: Expr -> Expr
11:28:56 <lambdabot>        Actual type: Expr -> [t0]
11:28:58 <erisco> did you do that?
11:29:07 <Welkin> > (\x y z -> [x,y,z]) <$> f <*> g <*> h $ x :: [Expr]
11:29:09 <lambdabot>  [f x,g x,h x]
11:29:17 <edmondo1984> oh magic
11:29:20 <edmondo1984> why??
11:29:25 <Welkin> why what?
11:29:26 <aweinstock> > f <*> g
11:29:28 <lambdabot>      Could not deduce (FromExpr (f a0))
11:29:28 <lambdabot>      from the context (Applicative f,
11:29:28 <lambdabot>                        FromExpr (f a),
11:29:35 <aweinstock> > f <*> g :: [Expr]
11:29:36 <lambdabot>      No instance for (FromExpr [a0 -> Expr])
11:29:37 <lambdabot>        (maybe you haven't applied enough arguments to a function?)
11:29:37 <lambdabot>        arising from a use of ‘f’
11:29:47 <Welkin> :t fmap (+1) (*3)
11:29:48 <lambdabot> Num b => b -> b
11:29:49 <aweinstock> > f <*> g $ x
11:29:51 <lambdabot>      Could not deduce (Show a0) arising from a use of ‘f’
11:29:51 <lambdabot>      from the context (FromExpr b)
11:29:51 <lambdabot>        bound by the inferred type of it :: FromExpr b => b
11:29:53 <edmondo1984> how is the <*> defined for function composition?
11:30:08 <jle`> f <*> g = \x -> f x (g x)
11:30:27 <erisco> this is not function composition
11:30:28 <Welkin> edmondo1984: https://hackage.haskell.org/package/base-4.8.1.0/docs/src/GHC.Base.html#line-617
11:30:34 <erisco> I've said this, and I will keep saying it :P
11:30:59 <Welkin> <*> is like the S combinator
11:31:08 <edmondo1984> right
11:31:10 <erisco> function composition is (.) which is (.) g f x = g (f x)
11:31:12 <edmondo1984> sorry I am such a newbie
11:31:13 <edmondo1984> lol
11:31:13 <Welkin> pure is the K combinator
11:31:15 <edmondo1984> instance Applicative ((->) a) where     pure = const     (<*>) f g x = f x (g x)
11:31:18 <Welkin> I find that cool
11:31:41 <edmondo1984> in (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5    
11:31:54 <Welkin> instance Functor ((->) a) where fmap = (.)
11:31:57 <erisco> so, take the definition of (<*>) and go through the example, expand it out
11:32:10 <edmondo1984> got it @erisco
11:32:14 <edmondo1984> how does it expand though?
11:32:19 <edmondo1984> from left to right or right to left?
11:32:27 <erisco> I don't know what you mean
11:32:43 <erisco> it is all left-associative
11:32:54 <Welkin> applicatives are always evaluated left to right
11:33:00 <edmondo1984> so the first step is computing the result of (\x y z -> [x,y,z]) <$> (+3)
11:33:06 <erisco> yes
11:33:07 <Welkin> I think edmondo1984 may be referring to the fact that we have oth >>= and =<<
11:33:08 <clrnd> edmondo1984, ((f <$> a) <*> b)
11:33:27 <edmondo1984> this gives (\x y z -> [x+3,y+3,z+3]) no?
11:33:28 <clrnd> yep
11:33:44 <glguy> edmondo1984: no
11:33:51 <erisco> did you write it out? I don't think so, I think you guessed :P
11:34:19 <shachaf> This channel really needs to cut down on the lambdabotting.
11:34:35 <erisco> lambdabot +throttle
11:34:47 <edmondo1984> oh man
11:34:50 <edmondo1984> oh men
11:34:54 <edmondo1984> thank you for your help
11:34:56 <edmondo1984> I love haskell
11:35:44 <clrnd> edmondo1984, we too!
11:35:51 <edmondo1984> so fmap (\x y z -> [x,y,z]) (+3) gives a (\x y z -> [x +3,y,z] )
11:35:55 <edmondo1984> because functions are curried right?
11:36:03 <clrnd> >  ((\x y z -> [x,y,z]) <$> (+3)) 1 2 3 :: [Int]
11:36:05 <lambdabot>  [4,2,3]
11:36:43 <edmondo1984> > fmap (\x y z -> [x,y,z]) (+3) 
11:36:45 <lambdabot>  <Integer -> Integer -> Integer -> [Integer]>
11:36:48 <arkeet> fmap (\x y z -> [x,y,z]) (+3) = (\x -> \y z -> [x,y,z]) . (+3) = (\x -> \y z -> [(+3) x,y,z])
11:37:06 <clrnd> lovely
11:37:10 <edmondo1984> beautiful
11:37:13 <edmondo1984> now the question is
11:37:55 <edmondo1984> why the second applicative functor is applied to the second element in the list
11:38:14 <arkeet> :t (<*>)
11:38:15 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:38:22 <edmondo1984> :t <*>
11:38:23 <lambdabot> parse error on input ‘<*>’
11:38:32 <edmondo1984> :t (<*>)
11:38:35 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:38:37 <edmondo1984> slowly slowly arkeet :)
11:39:01 <edmondo1984> so it's left right associative
11:39:20 <edmondo1984> (\x -> \y z -> [(+3) x,y,z] <*> (*2) <*> /2 
11:39:44 <monochrom> carefully work about (\x y z -> [x+3,y,z] <*> (*2)
11:39:50 <arkeet> :t (<*>) :: (r -> a -> b) -> (r -> a) -> (r -> b)
11:39:51 <monochrom> err
11:39:52 <lambdabot> (r -> a -> b) -> (r -> a) -> r -> b
11:39:57 <monochrom> carefully work out (\x y z -> [x+3,y,z] <*> (*2)
11:40:25 <monochrom> I have a typo inherited from your typo. but ok.
11:40:29 <bitemyapp> monochrom: (\x y z -> [x+3,y,z]) <*> (*2)    ?
11:40:54 <breadmonster> :t unfoldr
11:40:56 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
11:40:58 <breadmonster> :t build
11:41:00 <lambdabot>     Not in scope: ‘build’
11:41:00 <lambdabot>     Perhaps you meant ‘buildG’ (imported from Data.Graph)
11:41:08 <edmondo1984> monchrom
11:41:10 <breadmonster> Can someone explain what build/unfoldr do?
11:41:10 <erisco> monochrom, this is how legacy is born, be careful
11:41:20 <pyon> @djinn (a -> a -> b) -> (a -> b)
11:41:20 <lambdabot> f a b = a b b
11:41:34 <pyon> @pl \a b -> a b b
11:41:34 <lambdabot> join
11:41:41 <pyon> Oh, right, how stupid of me.
11:42:06 <breadmonster> @djinn (a -> b -> c) -> (a -> b)
11:42:06 <lambdabot> -- f cannot be realized.
11:42:07 <glguy> You can try lambdabot commands in private message
11:42:20 <pyon> Yeah, my bad.
11:42:21 <reactormonk> Is x map y always equivalent to y lift x?
11:42:46 <erisco> reactormonk, you can answer this by looking at the definitions
11:43:02 <edmondo1984> monochrom, 
11:43:08 <edmondo1984> (\x y z -> [x+3,y,z]) <*> (*2)  
11:43:34 <edmondo1984> here f(a->b) is what? 
11:43:54 <pyon> reactormonk: liftA is fmap.
11:44:04 * hackagebot GPipe 2.0 - Typesafe functional GPU graphics programming  https://hackage.haskell.org/package/GPipe-2.0 (TobiasBexelius)
11:44:05 <edmondo1984> why it can't be again \x -> \y z -> [x+3,y,z] ?
11:44:41 <reactormonk> pyon, thanks
11:44:44 <erisco> I'll do this step for you
11:44:47 <pyon> > [(*2), (*3)] <*> [5,10]
11:44:50 <lambdabot>  [10,20,15,30]
11:44:53 <Cale> edmondo1984: That's the same thing.
11:45:22 <edmondo1984> yup
11:45:26 <edmondo1984> but from the result of the book Cale
11:45:38 <edmondo1984> I deduct that the <*2> is applied to the second element in the list
11:45:40 <edmondo1984> looks like
11:45:58 <Gurkenglas> edmondo1984, f is ((->) x), y :: a and (\z -> [x+3,y,z]) :: b
11:45:58 <edmondo1984> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5    
11:46:33 <edmondo1984> Gurkenglas, can you please explain? I really don't see it yet :(
11:46:46 <monochrom> f <*> g = \a -> f a (g a). do you accept this?
11:46:54 <Cale> edmondo1984: It might help to understand that running an action in this monad/applicative means applying it to the argument to which the overall function has been applied
11:47:12 <Cale> edmondo1984: So here, running (+3) means applying (+3) to 5
11:47:16 <Cale> and so on
11:47:27 <edmondo1984> monochrom
11:47:28 <Cale> You could write this same thing in do-notation as:
11:47:48 <Cale> (do x <- (+3); y <- (*2); z <- (/2); return [x,y,z]) 5
11:48:00 <Welkin> https://en.wikipedia.org/wiki/Lambda_cube
11:48:06 <Welkin> :D
11:48:11 <Cale> So here, x will be (+3) 5, and y will be (*2) 5, and z will be (/2) 5
11:48:18 <reactormonk> erisco, I'll read up on Monads again.
11:48:21 <Pokinawa> I just realised that xmobar now supports xbm/xpm icons! The geek in me feels fuzzy. (Sorry off topic I know) ^_^
11:48:35 <Cale> and we just collect the results together into a list
11:48:44 <edmondo1984> monochrom can we use PM?
11:48:50 <edmondo1984> Cale can we use private messages?
11:48:51 <monochrom> xbm/xpm are a lot of C code
11:48:56 <edmondo1984> I am getting lost among the different ways of explaining it
11:48:58 <monochrom> I hate PM.
11:49:03 <edmondo1984> for now I didn't understand a single one :)
11:49:13 <Welkin> monochrom: yeah, that tony abbott
11:49:16 <monochrom> all you need to do is listen to me and ignore everyone else
11:49:24 <erisco> edmondo1984, I worked the step for you http://lpaste.net/139982
11:49:28 <edmondo1984> given that f(a ->b)  -> f(a) -> f(b), f <*> g means that f here is f(a->b) and g is f(a) 
11:49:31 <monochrom> as opposed to PM with everyone so you still listen to everyone :)
11:49:34 <erisco> now that you see how this step is done you should be able to finish it
11:49:45 <edmondo1984> so for functions
11:50:05 <monochrom> I commend erisco's steps
11:50:19 <reactormonk> erisco, ah, it's map f x and lift $ f x ?
11:50:35 <Gurkenglas> We attempt to match "f (a -> b)" with the type of "\x y z -> [x+3,y,z]", "Num c => c -> c -> c -> [c]", (ignoring the num constraint for the moment) = "c -> (c -> c -> [c]" ("->" is an infix type constructor) "(->) c (c -> c -> [c]". Therefore, f must be (->) c and (a -> b) must be (c -> c -> [c]).
11:50:51 <Gurkenglas> (Forgot two closing brackets there.)
11:51:02 <erisco> reactormonk, okay, first, where is 'lift' defined? the only 'lift' I know is for monad transformers
11:51:43 <edmondo1984> erisco your steps are still too terse for me :)
11:51:57 <edmondo1984> first I need to understand the <*> for a function Applicative :)
11:52:07 <Welkin> reactormonk: liftM?
11:52:14 <erisco> edmondo1984, well, I gave you the definition, that is the extent of it
11:52:24 <reactormonk> erisco, ah nevermind. Wrong lift :-)
11:52:28 <erisco> edmondo1984, what else do you want other than  (<*>) f g x = f x (g x)  ?
11:52:28 <monochrom> I think someone said (<*>) f g x = f x (g x) earlier
11:52:31 <Cale> edmondo1984: sorry, I'm working and just talking here while things compile, but sure, if you like send me a PM
11:52:41 <Welkin> monochrom: the S combinator
11:52:46 <edmondo1984> erisco
11:53:10 <edmondo1984> I am just confused here (<*>) f g x = f x (g x)  what is f ,g,x with respect to definition <*> f(a->b) -> f(a) -> f(b)
11:53:19 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
11:53:21 <edmondo1984> looks like there's some pattern matching
11:53:22 <lambdabot>  ("hello","olleh","HELLO")
11:53:38 <erisco> edmondo1984, okay... I think there is a lot of confusion going on here
11:53:39 <Cale> I think it's better to understand the Monad instance for functions before you try to understand the Applicative instance
11:54:13 <edmondo1984> instance Monad (a -> )
11:54:20 <erisco> edmondo1984, TERM :: TYPE   i.e. the '::' annotates a type for a term
11:54:34 <edmondo1984> fmap f g x = g(f(x))
11:54:36 <erisco> edmondo1984, so, 5 :: Int, [1,2,3] :: [Int], etc
11:54:47 <Cale> edmondo1984: nope, the other way
11:54:50 <edmondo1984> ah 
11:54:54 <monochrom> I am happy to let Cale explain it.
11:54:55 <edmondo1984> > ::
11:54:56 <Cale> fmap f g x = f (g x)
11:54:57 <lambdabot>  <hint>:1:1: parse error on input ‘::’
11:55:01 <edmondo1984> right
11:55:18 <erisco> well, at any right, it doesn't help to have multiple people explaining it
11:55:21 <edmondo1984> so g x in the monad is the pattern matching of a function and its argument right?
11:56:01 * erisco assumes Cale will explain it
11:56:07 <erisco> I'll go move rocks instead
11:56:14 <Cale> Sorry, what do I need to explain?
11:56:17 <edmondo1984> ahaha
11:56:20 <Cale> I'm highly distracted right now
11:56:26 <monochrom> darn
11:56:28 <edmondo1984> Cale, I think my confusion comes from the fact
11:56:37 <edmondo1984> that arguments can be pattern-matched on the left side of the expression
11:56:53 <Cale> Of a lambda expression?
11:57:09 <edmondo1984> so if I look into the <*> definition, I read that it is a f(a->b) -> f(a) -> f(b)
11:57:21 <erisco> noes
11:57:22 <edmondo1984> when I look into the Applicative definition for (a ->)
11:57:39 <erisco> okay, I'd explain this, but it looks like Cale will
11:57:40 <erisco> and so I won't
11:58:02 <Cale> Okay, so in this instance, we have  f t = e -> t
11:58:20 <Cale> So, the type of (<*>) is specialised from  f (a -> b) -> f a -> f b
11:58:30 <Cale> to  (e -> (a -> b)) -> (e -> a) -> (e -> b)
11:58:50 <Cale> which, removing redundant parens, is the same as  (e -> a -> b) -> (e -> a) -> e -> b
11:58:53 <edmondo1984> just a second
11:59:06 <edmondo1984> ok
11:59:08 <edmondo1984> I am following so far
12:00:51 <edmondo1984> now
12:01:12 <edmondo1984>  (<*>) f g x = f x (g x)
12:02:39 <arkeet> (k <$> f) x = k (f x)
12:02:44 <arkeet> (k <$> f <$> g) x = k (f x) (g x)
12:02:47 <arkeet> er
12:02:49 <arkeet> (k <$> f <*> g) x = k (f x) (g x)
12:02:52 <edmondo1984> right
12:02:55 <arkeet> (k <$> f <*> g <*> h) x = k (f x) (g x) (h x)
12:02:55 <edmondo1984> there I am lost
12:03:02 <arkeet> well
12:03:16 <arkeet> we agree that (f <*> g) x = (<*>) f g x = f x (g x)
12:03:17 <arkeet> I hope
12:03:27 <arkeet> now replace f with k <$> f
12:03:31 <edmondo1984>  (<*>) f g x = f x (g x) I can't understand this with respect to f (a -> b) -> f a -> f b
12:03:32 <arkeet> so f x with k (f x)
12:03:39 <arkeet> well.
12:03:49 <edmondo1984> (sorry about that, I am a real newbie)
12:03:52 <arkeet> you saw how it has type (e -> (a -> b)) -> (e -> a) -> (e -> b) ?
12:03:58 <edmondo1984> yes
12:04:05 <arkeet> well, there is only one way to define something of that type.
12:04:10 <arkeet> @djinn (e -> (a -> b)) -> (e -> a) -> (e -> b)
12:04:10 <lambdabot> f a b c = a c (b c)
12:04:22 <edmondo1984> just a sec
12:04:36 <edmondo1984> that one I follow
12:04:44 <edmondo1984> but in (<*>) f g x = f x (g x)
12:04:59 <edmondo1984> is f =of type (e -> a - > b) ?
12:05:10 <arkeet> yeah
12:05:40 <arkeet> (note that b itself may be a function type)
12:06:05 <arkeet> (which is needed if you want to chain further <*>s)
12:06:55 <edmondo1984> right
12:07:01 <edmondo1984> so what I am missing now arkeet
12:07:03 <edmondo1984> is that
12:07:13 <xelxebar> So I have a list of type `[MyType]` that looks like this [MyConstructor1 "stringA", MyConstructor3 "stringC", MyConstructor2 "stringAaaahh"] but the order of elements is not determined. How should I cleanly Pull out just "stringC"?
12:07:15 <edmondo1984> f x ( g x )
12:07:37 <edmondo1984> (g x) is of type a, am I right?
12:08:14 <xelxebar> I feel like I'm overlooking something really simple here...
12:08:21 <arkeet> yes
12:08:32 <arkeet> and f x ::: a -> b
12:08:37 <arkeet> ::
12:08:41 <edmondo1984> wait
12:08:51 <edmondo1984> f is of type (e -> a -> b)
12:08:53 <arkeet> yes.
12:09:07 <edmondo1984> ok
12:09:08 <edmondo1984> make sense
12:09:11 <edmondo1984> I understand
12:09:14 <arkeet> :)
12:09:26 <edmondo1984> I undertsand the definition of the <*> for functions
12:09:29 <edmondo1984> I am sorry I am just slow
12:09:30 <xelxebar> Wait, lists are monads. I'm dumb.
12:10:02 <edmondo1984> now let's go again into the example
12:10:09 <maerwald> lists have a monad instance
12:10:25 <edmondo1984> (k <$> f <$> g) x = k (f x) (g x)
12:10:38 <edmondo1984> are you saying that whatever
12:10:55 <Cale> xelxebar: The type constructor for lists is a single monad
12:11:02 <Cale> xelxebar: Individual lists are not
12:11:25 <edmondo1984> (k <$> f <*> g <*> h <*> i <*> l ) x
12:11:32 <arkeet> yup
12:11:46 <edmondo1984> = k  (f x) (g x) (h x) (i x) (l x)
12:11:48 <arkeet> yes
12:12:48 <edmondo1984> let's try again  (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5    
12:12:49 <xelxebar> Cale, maerwald: Thanks for the terminology cleanup.
12:13:06 <aweinstock> xelxebar: let {p (MyConstructor3 _) = True; _ = False} in filter p xs
12:13:42 <clrnd> :t mapMaybe
12:13:44 <lambdabot> (a -> Maybe b) -> [a] -> [b]
12:13:52 <edmondo1984> the result of the fmap  is (\x y z -> [x+3, y, z])
12:13:58 <edmondo1984> now if I <*> this with *2
12:14:00 <arkeet> let {f (MyConstructor3 x) = Just x; f _ = Nothing} in mapMaybe f xs
12:14:06 * hackagebot language-lua2 0.1.0.2 - Lua parser and pretty printer  https://hackage.haskell.org/package/language-lua2-0.1.0.2 (mitchellwrosen)
12:14:11 <clrnd> xelxebar, ^
12:14:16 <edmondo1984>  (\x y z -> [x+3, y, z]) <*> (*2)
12:14:30 <edmondo1984> what's my f and what's my g here, arkeet? 
12:14:33 <edmondo1984> f x (g x)
12:14:51 <arkeet> those are the two arguments to <*>
12:15:16 <arkeet> (we'll have to rename some variables...)
12:15:29 <arkeet> anyway gtg
12:15:44 <gigabytes> hi
12:15:53 <gigabytes> is there anyone that knows hakyll here?
12:16:08 <bitemyapp> barely
12:16:09 <Clint> i've used it
12:16:18 <gigabytes> I'm trying to exclude some items from a match
12:16:22 <gigabytes> based on some metadata
12:16:24 <edmondo1984> arkeet
12:16:42 <xelxebar> Is it nonstandard to say "lists" when referring to the class of types [a]? Maybe I've got it all wrong, but I'm sort of thinking of some category that has objects which are free monoids over different sets.
12:16:51 <edmondo1984> but if f is (\x y z -> [x +3 , y, z])
12:17:01 <gigabytes> e.g. if the item has the "published" metadata, then route it, else not
12:17:21 <edmondo1984> and g is a -> a * 2
12:17:30 <edmondo1984> while the applicative functor applies the function on the second element of the list?
12:18:32 <aweinstock> xelxebar: [a] (as a type) is pronounced "lists of a"
12:19:58 <xelxebar> aweinstock: So what about the class of all [a] for all a \in Hask or whatever?
12:20:13 <Welkin> gigabytes: what I do is have a "drafts" directory where I write my blog posts, then I move it to "posts" to publish it
12:20:41 <xelxebar> Maybe that's just not a concept we frequently need a handle on?
12:21:11 <gigabytes> Welkin: yeah, sounds easier
12:21:25 <gigabytes> but isn't there a way to do it based on metadata? It seems not
12:21:56 <gigabytes> it seems that after you've matched the items, the rules cannot throw out someone
12:22:21 <aweinstock> xelxebar: I'm not quite sure what the distinction that you're making is?
12:22:29 <gigabytes> what happens if I call "fail" of the Compiler monad?
12:23:07 <aweinstock> there's an implicit forall, (x :: [a]) means (x :: forall a. [a])
12:24:55 <xelxebar> aweinstock: For example, there is the set of all lists of type `[Integer]` as well as the set of all lists of type `[String]` and so on. I'm wondering how we refer to the class of *all* these types.
12:27:09 <monochrom> edmondo1984: do you accept "(f <*> g) r = f r (g r)"?  because next I will use "f <*> g = \r -> f r (g r)"
12:27:11 <aweinstock> xelxebar: I don't know if that has a name
12:27:16 <erisco> I have moved rocks
12:27:32 <edmondo1984> yes now I do monohrom
12:27:43 <xelxebar> The class of all list types, `forall a . [a]`? I really don't know what I'm talking about here.
12:27:46 <erisco> edmondo1984, in the words of my information technology teacher: "What's the status?"
12:28:21 <edmondo1984> I am convinced that the implementation of the <*> operator of the Function applicative
12:28:22 <edmondo1984> makes sense
12:28:33 <edmondo1984> now I don't undrstand why it is applied to the second or the third element in the list
12:28:45 <erisco> did you look at my worked example?
12:28:57 <erisco> okay, monochrom is helping you, I'll shut up
12:29:18 <monochrom> well, your steps on lpaste are good
12:29:25 <edmondo1984> yes
12:29:28 <edmondo1984> steps 4 is mysterious
12:29:36 <monochrom> ok, let me see
12:29:36 <erisco> sub x for q?
12:29:58 <erisco> by "sub" I mean substitute i.e. function application
12:30:26 <erisco> (\x y -> x + y) q ==> (\y -> q + y)  Sub q for x
12:30:40 <monochrom> (\x -> ... x ...) q = (... q ...)
12:30:49 <edmondo1984> sorry
12:30:50 <edmondo1984> step 5
12:31:10 <erisco> (*2)q  to  q*2 ?  i.e.  Prefix to infix?
12:31:11 <monochrom> that's (*2) q = q*2  using sectioning
12:31:19 <edmondo1984> ok
12:31:23 <edmondo1984> everything it's clear
12:31:26 <erisco> yeah that is just a Haskell syntactical convenience
12:31:26 <edmondo1984> thank you guys
12:31:56 <erisco> I guess "prefix to infix" is not the best step name, but I don't know what to call the section conversions
12:32:18 <monochrom> "use sectioning". it's like "use the force"
12:32:23 <erisco> you can expand to  (\x -> x*2) q  then apply
12:32:32 <monochrom> that too
12:32:34 <edmondo1984> I have a little bit of confusion
12:32:47 <edmondo1984> because I don't see yet function applications etc
12:32:51 <edmondo1984> but it makes perfect sense
12:33:08 <erisco> note   f x y  is  (f x) y
12:33:10 <edmondo1984> I guess with time and learning
12:33:29 <erisco> because function application is left-associative
12:33:33 <monochrom> every time you write "f x" you're already writing function application
12:33:57 <monochrom> or generally "<expression #1> <expression #2>"
12:34:04 <erisco> $ is function application given an explicit name btw
12:34:23 <erisco> Haskell chooses to make function application an implicit operator, like you might multiplication in arithmetic
12:34:46 <monochrom> and then the syntax "1+2" stands for "<the function for plus> 1 2" so you are not escaping function application either.
12:35:04 <monochrom> you are trapped in function application
12:35:36 <aweinstock> > (+5) `id` 2
12:35:40 <lambdabot>  mueval-core: Time limit exceeded
12:35:45 <monochrom> "if True then 'x' else 'y'" is one of the few things left that are not function application
12:35:57 <aweinstock> :t [id, ($)]
12:35:59 <lambdabot> [(a -> b) -> a -> b]
12:36:06 <aweinstock> > (+5) `id` 2
12:36:09 <lambdabot>  7
12:36:11 <erisco> aweinstock, please don't run expensive arithmetic on lambdabot's starch-based processor
12:36:26 <aweinstock> erisco: sorry (I think?)
12:37:00 <erisco> and case
12:37:14 <erisco> and guards and etc
12:37:34 <edmondo1984> how do you use
12:37:39 <edmondo1984> lambdabot for multi-line code?
12:37:49 <edmondo1984> > let a = return "Hello world"
12:37:51 <lambdabot>  <no location info>:
12:37:51 <lambdabot>      not an expression: ‘let a = return "Hello world"’
12:37:53 <erisco> you don't, you make it single line using braces and semicolons
12:37:53 <monochrom> cannot. cramp into one line.
12:37:54 <Cale> edmondo1984: You generally don't
12:38:19 <erisco> > let a = return "Hello world" in a :: [String]
12:38:21 <lambdabot>  ["Hello world"]
12:38:29 <edmondo1984> what is the :: [Type] operator?
12:38:37 <edmondo1984> I thought :: was list?
12:38:42 <monochrom> no, : is list
12:38:43 <edmondo1984> > 1 :: 2 :: 3
12:38:45 <lambdabot>  <hint>:1:8: parse error on input ‘::’
12:38:52 <edmondo1984> > 1 :: 2 :: 3 :: []
12:38:54 <lambdabot>  <hint>:1:8: parse error on input ‘::’
12:39:01 <aweinstock> edmondo1984: that's ocaml, not haskell
12:39:08 <aweinstock> > 1:2:3:[]
12:39:10 <lambdabot>  [1,2,3]
12:39:27 <edmondo1984> ops
12:39:32 <Cale> <expression> :: <type>  is an expression form which annotates the given expression with a desired type
12:39:34 <erisco> I had to give an annotation because otherwise lambdabot would have freaked out
12:39:36 <monochrom> if you know Huffman code, you know why
12:39:38 <clrnd> that's idris, not ocaml
12:39:40 <edmondo1984> right
12:39:44 <Cale> > 2 :: Double
12:39:47 <lambdabot>  2.0
12:39:51 <edmondo1984> it is to help the type inference?
12:39:52 <Cale> > 2 :: Complex Float
12:39:56 <lambdabot>  2.0 :+ 0.0
12:40:00 <clrnd> edmondo1984, it's useful for when type inference would be problematic
12:40:01 <edmondo1984> > 2.3 :: Integer
12:40:03 <lambdabot>      No instance for (Fractional Integer) arising from the literal ‘2.3’
12:40:03 <lambdabot>      In the expression: 2.3 :: Integer
12:40:04 <erisco> sometimes it is to help type inference
12:40:08 <edmondo1984> ok
12:40:13 <erisco> other times it is to disambiguate, like when I used it
12:40:16 <edmondo1984> > show 2.3
12:40:18 <lambdabot>  "2.3"
12:40:26 <clrnd> > read "3" :: Int
12:40:29 <lambdabot>  3
12:40:33 <clrnd> > read "3" :: Float
12:40:35 <lambdabot>  3.0
12:40:43 <Cale> > read "[1,2,3]" :: [Double]
12:40:44 <edmondo1984> > fmap reverse . toUpperCase "hello"
12:40:46 <lambdabot>  [1.0,2.0,3.0]
12:40:46 <lambdabot>  Not in scope: ‘toUpperCase’
12:41:06 <Cale> > reverse . map toUpper $ "hello"
12:41:08 <lambdabot>  "OLLEH"
12:41:20 <edmondo1984> Cale
12:41:32 <edmondo1984> > fmap reverse . toUpper "hello"
12:41:33 <lambdabot>      Couldn't match expected type ‘a -> f [a1]’ with actual type ‘Char’
12:41:33 <lambdabot>      Possible cause: ‘toUpper’ is applied to too many arguments
12:41:33 <lambdabot>      In the second argument of ‘(.)’, namely ‘toUpper "hello"’
12:41:39 <ralu> > reverse . map toUpper  "hello"
12:41:41 <lambdabot>      Couldn't match expected type ‘a -> [a1]’ with actual type ‘[Char]’
12:41:42 <lambdabot>      Possible cause: ‘map’ is applied to too many arguments
12:41:42 <lambdabot>      In the second argument of ‘(.)’, namely ‘map toUpper "hello"’
12:41:42 <edmondo1984> > fmap reverse . toUpper "hello" :: [String]
12:41:44 <lambdabot>      Couldn't match expected type ‘[String]’
12:41:44 <lambdabot>                  with actual type ‘a0 -> f0 [a1]’
12:41:44 <lambdabot>      In the expression: fmap reverse . toUpper "hello" :: [String]    Couldn'...
12:41:51 * erisco faints
12:41:56 <clrnd> xd
12:42:02 <Cale> toUpper "hello" is not a function, and "hello" is not a Char
12:42:17 <monochrom> you need parentheses. (fmap reverse . toUpper) "hello"
12:42:19 <edmondo1984> oh 
12:42:20 <edmondo1984> right
12:42:21 <Cale> :t toUpper
12:42:22 <lambdabot> Char -> Char
12:42:23 <erisco> I am sure it is in unicode *somewhere*
12:42:27 <Cale> :t map toUpper
12:42:28 <lambdabot> [Char] -> [Char]
12:42:46 <Cale> :t reverse
12:42:48 <lambdabot> [a] -> [a]
12:42:50 <edmondo1984> right
12:42:51 <edmondo1984> make sense
12:42:55 <edmondo1984> so before the toUpper map then reverse
12:43:02 <ralu> > reverse $ map toUpper  "hello"
12:43:04 <lambdabot>  "OLLEH"
12:43:13 <edmondo1984> what's the difference between $ and . ?
12:43:21 <Cale> (.) is composition of functions
12:43:22 <monochrom> they are unrelated.
12:43:25 <Cale> ($) is application
12:43:28 <aweinstock> :t (($), (.))
12:43:30 <lambdabot> ((a -> b) -> a -> b, (b1 -> c) -> (a1 -> b1) -> a1 -> c)
12:43:31 <erisco> > reverse $ map $ toUpper $ "hello"
12:43:34 <lambdabot>      Couldn't match expected type ‘[a]’ with actual type ‘[a0] -> [b0]’
12:43:34 <lambdabot>      In the second argument of ‘($)’, namely ‘map $ toUpper $ "hello"’
12:43:34 <lambdabot>      In the expression: reverse $ map $ toUpper $ "hello"    Couldn't match e...
12:43:42 <erisco> I don't use dollar
12:43:54 <Cale> erisco: map toUpper
12:44:12 <edmondo1984> why do you use $ if function application is implicit?
12:44:13 <erisco> > reverse $ (map $ toUpper) $ "hello"
12:44:14 <lambdabot>  "OLLEH"
12:44:15 <monochrom> Cale, I think erisco is showing the peril of $
12:44:17 <clrnd> give your dollars to me then
12:44:26 <erisco> so it is an associativity thing? mkay
12:44:37 <Cale> edmondo1984: f $ x = f x  but ($) has very low operator precedence
12:44:38 <ralu> > map ($ 5)  [+2,*3]
12:44:38 <erisco> infixr OF COURSE
12:44:40 <lambdabot>      A section must be enclosed in parentheses thus: (+ 2)    A section must ...
12:44:58 <Cale> edmondo1984: while whitespace function application has "higher precedence" than any infix operator
12:45:24 <ralu> > map ($ 5)  [(+2),(*3)]
12:45:28 <lambdabot>  [7,15]
12:45:41 <erisco> :t (&)
12:45:43 <lambdabot> a -> (a -> b) -> b
12:45:45 <Cale> Yeah, it's also useful for operator sections
12:46:01 <erisco> > "hello" & (toUpper & map) & reverse
12:46:03 <lambdabot>  "OLLEH"
12:46:06 <erisco> oh I love it
12:46:08 <Cale> erisco: pls
12:46:39 <Cale> This is a one-way street, please don't reverse traffic
12:47:09 <ralu> so & is reverse $
12:47:11 <Cale> (I rather wish that (&) didn't exist)
12:47:13 <ralu> *flip
12:47:18 <Cale> yeah, flip ($)
12:47:28 <erisco> it aint in my prelude?
12:47:28 <ralu> omg
12:47:39 <Cale> erisco: I think it's from lens
12:48:15 <erisco> omg yes it has one higher precedence!
12:48:39 <erisco> > reverse $ toUpper & map $ "hello"
12:48:41 <lambdabot>  "OLLEH"
12:48:52 <erisco> I found the use case
12:49:16 <tdammers> at work we call them "used cases"
12:49:34 <tdammers> one of our resident MBA's calls them that, and it stuck
12:49:39 <Cale> erisco: ;__;
12:50:32 <t7> > map (toEnum . (+ 20320). (* 2589) . (`mod` 2)) "Hi" :: String
12:50:34 <lambdabot>      Couldn't match type ‘Char’ with ‘Int’
12:50:34 <lambdabot>      Expected type: [Int]
12:50:34 <lambdabot>        Actual type: [Char]
12:50:42 <Cale> edmondo1984: anyway
12:50:53 <Cale> edmondo1984: f . g = \x -> f (g x)
12:51:02 <t7> > map (toEnum . (+ 20320). (* 2589) . (`mod` 2) . fromEnum) "Hi" :: String
12:51:04 <lambdabot>  "\20320\22909"
12:51:08 <Cale> edmondo1984: Or equivalently (f . g) x = f (g x)
12:51:10 <t7> how2unicode?
12:51:21 <t7> > print $ map (toEnum . (+ 20320). (* 2589) . (`mod` 2) . fromEnum) "Hi" :: String
12:51:23 <lambdabot>      Couldn't match type ‘IO ()’ with ‘[Char]’
12:51:23 <lambdabot>      Expected type: String
12:51:23 <lambdabot>        Actual type: IO ()
12:51:28 <Cale> edmondo1984: So (.) is an operation which takes two functions, and composes them together end to end
12:51:40 <Cale> edmondo1984: while ($) merely applies a function to an argument
12:53:26 <t7> > putStr $ map (toEnum . (+ 20320). (* 2589) . (`mod` 2) . fromEnum) "Hi"
12:53:29 <lambdabot>  <IO ()>
12:53:36 <t7> ok i give up
12:53:59 <erisco> I tried this before and couldn't get lambdabot to speak unicode either
12:55:20 <ralu> > show ☺
12:55:23 <lambdabot>  <hint>:1:7:
12:55:23 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:55:31 <ralu> > show "☺"
12:55:33 <lambdabot>  "\"\\9786\""
12:55:59 <erisco> you try, and try again, but lambdabot stays one escape sequence ahead of you
12:56:12 <t7> kill lambdabot !
12:56:23 <t7> it hates non americans 
12:56:28 <t7> SJWs unite!
12:56:39 <aweinstock> > map (toEnum . (+ 20320). (* 2589) . (`mod` 2) . fromEnum) "Hi"
12:56:42 <lambdabot>  [*Exception: Prelude.Enum.().toEnum: bad argument
12:56:54 <t7> aweinstock: need to specify string
12:56:57 <t7> or Char 
12:57:00 <aweinstock> > map (chr . (+ 20320). (* 2589) . (`mod` 2) . ord) "Hi"
12:57:04 <lambdabot>  "\20320\22909"
12:57:43 <aweinstock> :t (ord, chr)
12:57:45 <lambdabot> (Char -> Int, Int -> Char)
12:58:24 <ralu> > chr 22909
12:58:26 <lambdabot>  '\22909'
13:05:07 <ralu> ::type genericReplicate
13:05:53 <glguy> > text "☺"
13:05:54 <lambdabot>  ☺
13:06:06 <monochrom> nooo! don't tell them!
13:06:09 <Welkin> ?
13:06:17 <Welkin> never heard of `text`
13:06:18 <Welkin> :t text
13:06:20 <lambdabot> String -> Doc
13:06:22 <Cale> > text "👻"
13:06:24 <lambdabot>  👻
13:06:26 <Welkin> oh, pretty printing?
13:06:28 <Cale> spooky
13:07:09 <Welkin> > ord ☺
13:07:11 <lambdabot>  <hint>:1:6:
13:07:11 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
13:07:15 <Welkin> > ord '☺'
13:07:18 <lambdabot>  9786
13:07:27 <Welkin> > chr 9786
13:07:29 <lambdabot>  '\9786'
13:07:51 <Welkin> chr 256
13:07:57 <Welkin> > chr 256
13:08:00 <lambdabot>  '\256'
13:08:04 <Welkin> > chr 255
13:08:06 <lambdabot>  '\255'
13:08:08 <glguy> for trying lots of things please use /msg
13:08:12 <glguy> you're flooding
13:08:16 <Welkin> okay
13:14:11 * hackagebot idris 0.9.19 - Functional Programming Language with Dependent Types  https://hackage.haskell.org/package/idris-0.9.19 (EdwinBrady)
13:14:53 <the_2nd> No instance for (Ix Double) arising from the use of inRange
13:14:55 <the_2nd> http://pastebin.com/R4TYiMrX
13:15:11 <the_2nd> where p1 q1 etc. is data with x, y :: Double
13:15:59 <glguy> http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Ix.html#t:Ix
13:16:09 <glguy> inRange is a member of the Ix class which is for array indexes
13:16:23 <glguy> Double isn't appropriate for use as an array index
13:16:36 <the_2nd> glguy, makes sense
13:16:41 <the_2nd> is there such a method for double?
13:16:49 <MorpheusB> Welkin: grab your own copy of lambdabot 
13:17:29 <glguy> the_2nd: Not in base, at least. Your best bet will be to define that operation locally.
13:18:12 <glguy> between lo hi x = lo <= x && x <= hi
13:20:02 <the_2nd> glguy, http://pastebin.com/jyqrUjs9
13:22:27 <ralu> >  f 2 3 100 where; f 0 = (+); f n = ( foldl1 ( f (n-1)) .). (flip  genericReplicate)
13:22:30 <lambdabot>  <hint>:1:11: parse error on input ‘where’
13:31:33 <ReinH> Cale: what's the name for your function that gives each element of a list with its context (the derivative of a bag, basically)?
13:33:21 <bitemyapp> ReinH: context?
13:33:35 <ReinH> bitemyapp: the rest of the list
13:33:40 <monochrom> zipper?
13:34:12 <bitemyapp> ReinH: does this include the cons cells that preceded it?
13:34:31 <ReinH> monochrom: iirc it's a function [a] -> [(a, [a])]
13:34:32 <bitemyapp> ReinH: (before :: [a], a, after :: [a]) or is it just a cons cell?
13:34:47 <glguy> Cale, please stick to using one /nick simultaneously ^_^
13:34:50 <bitemyapp> so it's a list of cons cells?
13:34:53 <monochrom> I remember now. only Cale knows its name :)
13:35:16 <ReinH> e.g. f [1,2,3] = [(1, [2,3]), (2, [1,3]), (3, [1,2])
13:35:18 <ReinH> ]
13:35:24 <ReinH> I don't care about order
13:35:30 <bitemyapp> okay yeah, bags.
13:35:31 <ReinH> so just the derivative of a bag
13:35:37 <Cale> glguy: huh?
13:35:56 <ReinH> he had a nice function for this on the mailing list at one point but I can't find it
13:36:07 <bitemyapp> ReinH: picks
13:36:18 <Cale> ReinH: uhhh... separate?
13:36:19 <bitemyapp> ReinH: http://hackage.haskell.org/package/HaskellForMaths-0.4.8/docs/Math-Core-Utils.html#v:picks
13:36:21 <monochrom> I think Cale's function also preserves order. which doesn't hurt you.
13:36:22 <Cale> ReinH: or select?
13:36:26 <ReinH> bitemyapp: heh I just found it https://mail.haskell.org/pipermail/libraries/2010-July/013842.html
13:36:50 <ReinH> monochrom: yes, it's extra information I don't care about :)
13:36:51 <monochrom> yeah, select.
13:36:51 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
13:36:54 <lambdabot>  Defined.
13:36:59 <ReinH> Cale: <3
13:37:47 <Cale> @let separate [] = []; separate (x:xs) = ([],x,xs) : [(x:us,v,vs) | (us,v,vs) <- separate xs]
13:37:49 <lambdabot>  Defined.
13:38:03 <Cale> > select [1,2,3]
13:38:06 <lambdabot>  [(1,[2,3]),(2,[1,3]),(3,[1,2])]
13:38:09 <Cale> > separate [1,2,3]
13:38:11 <lambdabot>  [([],1,[2,3]),([1],2,[3]),([1,2],3,[])]
13:38:50 <pantsman-> huh, I have this function written on my white board right now. I forget why.
13:39:07 <bitemyapp> pantsman-: it's written on your write board write now
13:39:16 <pantsman-> it's called "picks" on my board
13:40:15 <mauke> it's a write of passage
13:45:51 <monochrom> the writing is on the wall
13:50:11 <Welkin> like in a movie
13:50:17 <Welkin> or L4D
13:54:18 * hackagebot b9 0.5.9 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.9 (SvenHeyll)
13:55:50 <ralu> @let ho 0 = (+); ho n = ( foldl1 ( ho (n-1)) .). (flip  genericReplicate)
13:55:52 <lambdabot>  Defined.
13:56:09 <ralu> ho 1 7 9
13:56:24 <ralu> > ho 1 2 5
13:56:27 <lambdabot>  10
13:56:35 <ralu> > ho 1 3 5
13:56:37 <lambdabot>  15
13:56:47 <ralu> > ho 2 2 10
13:56:49 <lambdabot>  1024
13:56:52 <ralu> > ho 2 2 100
13:56:54 <lambdabot>  1267650600228229401496703205376
13:57:38 <ralu> ho 3 2 5
13:57:46 <ralu> > ho 3 2 5
13:57:48 <lambdabot>  65536
14:00:39 <svat> can I verify in ghci that one type is the same as another, e.g. that `String` and `[Char]` are the same?
14:01:20 <mauke> :t (undefined :: String) :: [Char]
14:01:22 <lambdabot> [Char]
14:01:25 <Gurkenglas> @instances Plated
14:01:28 <glguy> I came up with :t id :: String -> [Char]
14:01:30 <lambdabot> on the commandline: Warning:
14:01:30 <lambdabot>     -fglasgow-exts is deprecated: Use individual extensions instead
14:01:30 <lambdabot>  
14:01:30 <lambdabot> <no location info>: Warning:
14:01:30 <lambdabot>     -XGeneralizedNewtypeDeriving is not allowed in Safe Haskell; ignoring -XGeneralizedNewtypeDeriving
14:01:32 <lambdabot> [4 @more lines]
14:01:44 <mauke> :t (undefined :: String) :: Int
14:01:46 <lambdabot>     Couldn't match type ‘[Char]’ with ‘Int’
14:01:46 <lambdabot>     Expected type: Int
14:01:46 <lambdabot>       Actual type: String
14:02:37 <svat> @mauke thanks! Nice trick of using “undefined” to generate a value for any type, should remember that…
14:02:38 <lambdabot> Unknown command, try @list
14:02:48 <svat> argh been a while since I used IRC :)
14:05:16 <glguy> You have to be careful though, (undefined :: a) :: b  only says that a can instantiate into b, not that they are the same
14:05:43 <glguy> (undefined :: [a]) :: [Int]     vs    (undefined :: [Int]) :: [a]
14:06:17 <svat> glguy: ah, so your idea of using id seems more robust then
14:06:28 <lpaste_> putis pasted “ZMQ” at http://lpaste.net/139991
14:06:30 <glguy> well, I didn't say that example was better
14:06:32 <glguy> :)
14:07:04 <putis> could you tell me, how to type `foo' function?
14:07:55 <putis> I'm trying to do that whole this tay -_-
14:09:17 <mauke> :t runErrorT
14:09:19 <lambdabot> Not in scope: ‘runErrorT’
14:09:19 * hackagebot dequeue 0.1.7 - A typeclass and an implementation for double-ended queues.  https://hackage.haskell.org/package/dequeue-0.1.7 (HenryBucklow)
14:09:30 <putis> System.ZMQ4.Monadic is in zeromq4-haskell package
14:10:16 <putis> https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Error.html#v:runErrorT
14:10:31 <mauke> needs more forall
14:11:17 <svat> glguy: looks like I can also use :t (id :: T -> T) x to um, “assert that x is of type T”
14:13:02 <mauke> :t let foo :: (forall s. ReaderT String (ST s) a) -> a; foo bar = runST (runReaderT bar "") in foo
14:13:03 <lambdabot> (forall s. ReaderT String (ST s) a) -> a
14:13:08 <mauke> ok, this types
14:13:18 <mauke> maybe something analogous will work for runZMQ
14:14:20 * hackagebot b9 0.5.10 - A tool and library for building virtual machine images.  https://hackage.haskell.org/package/b9-0.5.10 (SvenHeyll)
14:17:50 <programo> Can any body explain why  I have got an exception here? http://lpaste.net/139992
14:18:33 <monochrom> you need read "\"5\""
14:18:49 <mauke> because 5 is not a string
14:19:03 <monochrom> this is because read mirrors show. consider show "5"
14:19:22 * hackagebot smtps-gmail 1.3.1 - Gmail SMTP Client  https://hackage.haskell.org/package/smtps-gmail-1.3.1 (EnzoHaussecker)
14:20:26 <monochrom> but I should consider the orthogonal angle
14:20:34 <monochrom> you need read "5" :: Int
14:20:56 <mauke> why not both? you need read "()" :: ()
14:21:11 <monochrom> that would be too easy
14:21:14 <mauke> or how about this one: you need show "5" :: String
14:21:51 <monochrom> I forgot that angle.
14:22:04 <monochrom> no matter they say "lambda cube" rather than "lambda square"
14:22:40 <mauke> you need strtol("5", NULL, 10)
14:23:16 <mauke> how many cuils are we at? probably still 0 or 1
14:23:39 <shersh> hello everyone! I'm implementing BinaryTree algorithm in Haskell (which is classic). And I want to define typeclass Set and two implementations: ordinary BInaryTree and AVLTree, so in my code i can just use Set and not think about concrete implementation. But i have encountered an error and I can't fix it. Here is small code snippet: http://pastie.org/10388216
14:23:49 <monochrom> this sheds light on how to apply the anthropic principle to "why is our universe at least 3D?"  answer: so that we can talk about the lambda cube.
14:23:50 <shachaf> FOUR SIMULTANEOUS TYPE SYSTEMS IN A SINGLE ROTATION OF THE LAMBDA CUBE
14:24:04 <programo> okay Thank you !
14:24:41 <shersh> I can figure out why this error appears. But how can I achive my goals by simply modifying my code and not using type families?
14:25:11 <monochrom> you don't need type families.
14:25:40 <t7> do you need to specify k ?
14:25:41 <mauke> fundeps
14:25:46 <shersh> monochrom: And how to fix this issue in simplest way?
14:26:04 <mauke> well, step 1 is multiparam typeclasses
14:26:10 <shersh> t7: what do you mean by words "specify k"?
14:26:38 <t7> duno 
14:26:42 <t7> listen to the smart people
14:27:47 <shersh> mauke: can I avoid using multiparam typeclasses? I need this example to be as simple is possible. Like in Java. Because it is trivial in java to define interface and some implementations
14:28:19 <monochrom> I see why you mention type families. you need either (multiple parameter type class and fundep) or (type family). you should eventually know both ways. I still suggest (multiple parameter type class and fundep) first.
14:28:28 <mauke> your interface claims 'find' can work with any type of key regardless of what the set is
14:28:49 <mauke> that's simply not true
14:29:05 <Gurkenglas> shersh, http://pastie.org/10388233
14:29:55 <monochrom> nevermind. what Gurkenglas says.
14:30:10 <shersh> Gurkenglas: thanks! That was exactly what i need :)
14:30:36 <mauke> tradeoffs
14:33:15 <Gurkenglas> shersh, why the t@?
14:35:51 <shersh> Gurkenglas: I just copied definition from `insertKey` function and forgot to change variable signature http://pastie.org/10388241 Thanks again :)
14:39:38 <Gurkenglas> Also I would use compare for this unless that's too advanced for the setting? http://lpaste.net/139995
14:41:21 <Gurkenglas> (Of course I would actually derive Foldable and use elem) http://lpaste.net/139996
14:42:57 <Gurkenglas> waaaait nevermind there goes my cred that's no longer logarithmic time.
14:47:06 <putis> mauke: thanks for advice. It pushed my work a bit, but I have no patience for this today
14:51:02 <shersh> Gurkenglas: thanks for advices) compare with case indeed would be better because comparing may be slow
15:04:25 * hackagebot smartcheck 0.2.2 - A smarter QuickCheck.  https://hackage.haskell.org/package/smartcheck-0.2.2 (LeePike)
15:09:26 * hackagebot renderable 0.0.0.1 - Provides a nice API for rendering data types that change  over time.  https://hackage.haskell.org/package/renderable-0.0.0.1 (SchellScivally)
15:14:23 <slack1256> is it bad that at some point on my programs, everything will be running on the union of all the monads transformers my code uses?
15:16:32 <slack1256> ideally I would like to use the tiniest concrete monad stack for each part of the program and have them converted at the boundaries
15:17:10 <slack1256> but then I use mtl and this stuff gets unavoidable
15:34:04 <Gurkenglas> slack1256, even when using mtl you must somewhere define your stack. Define different stacks and repacking functions between them, and all the mtl-classes-using functions should work on each compatible stack
15:39:34 <jbalint> it's not possible to make an instance of Functor if the type doesn't have a parameter?
15:39:47 <Iceland_jack> jbalint: That's right
15:40:02 <Welkin> jbalint: because a functor has king * -> *
15:40:04 <Welkin> kind*
15:40:11 <Welkin> well...
15:40:16 <Iceland_jack> You can tell from the definition of Functor
15:40:16 <Iceland_jack>     class Functor (f :: * -> *) where
15:40:23 <jbalint> ok, asking the question gave me some kind of insight
15:40:24 <Welkin> it is higher-kinded
15:40:37 <jbalint> yeah i realize the technical deal here, but I didn't understand the reason it would be like that
15:40:38 <Welkin> so it is a "function on types"
15:40:47 <Iceland_jack> jbalint: So Bool or Int cannot possibly be Functors
15:40:50 <jdnavarro> jbalint: there is monomorphic containers for such functors
15:40:55 <jbalint> Iceland_jack: right! ok. got it...
15:40:56 <Iceland_jack> @src Functor
15:40:57 <lambdabot> class  Functor f  where
15:40:57 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
15:41:03 <jdnavarro> don't remember the name of the package now...
15:41:07 <jbalint> Iceland_jack: I had something like data X = I Int | S String
15:41:22 <Iceland_jack> jbalint: Try replacing the 'f'-s with a Bool and it won't make sense
15:41:34 <Iceland_jack>     fmap :: (a -> b) -> Bool a -> Bool b ??????
15:41:36 <jbalint> jdnavarro: example?
15:41:47 <jbalint> jdnavarro: ok, i'll google. thx
15:42:02 <jdnavarro> jbalint: https://hackage.haskell.org/package/mono-traversable
15:42:32 <jdnavarro> they achieve it with type families
15:43:06 <jdnavarro> in any case, even if it's monomorphic, there has to be a separate container type
15:43:16 <jdnavarro> like for `Text` `Char`
15:43:43 <jbalint> jdnavarro: ok. I"ll dig into this. thanks
15:43:55 <jdnavarro> there is an alternative `Prelude` with all those instances
15:44:07 <Iceland_jack> jbalint: mono-traversable or similar tricks can be useful, but normally you shouldn't force a square peg in a round hole
15:44:43 <jbalint> Iceland_jack: I understand but I can't make the decision yet until I figure this out
15:44:49 <jdnavarro> jbalint: this is the one: https://hackage.haskell.org/package/classy-prelude
15:45:09 <Iceland_jack> 'data X = I Int | S String' has two possible Functor instances
15:45:09 <Iceland_jack>     data X a = I a   | S String deriving Functor
15:45:09 <Iceland_jack>     data X a = I Int | S a      deriving Functor
15:45:54 <jdnavarro> Iceland_jack: agreed, `ByteString`, `Text` and similar provide all the equivalent functions you may need
15:45:57 <Iceland_jack> (it has more instances but these are the most useful ones)
15:46:15 <jbalint> Iceland_jack: it's more like this: data X = I Int | S String | U [X] | V [X]
15:46:28 <Iceland_jack> jbalint: Okay now we're talking :)
15:46:29 <jbalint> so fmap would take I and S directly but map over the list for the lists
15:46:41 <Iceland_jack> what would you want 
15:46:41 <Iceland_jack>     fmap :: (a -> b) -> X a -> X b
15:46:41 <Iceland_jack> to *do*?
15:47:07 <jbalint> fmap f theI@(I i) = f theI
15:47:17 <jbalint> fmap f (U xs) = fmap f xs
15:47:56 <Iceland_jack> that's not correctly typed
15:48:24 <Iceland_jack> but you want it to operate on the Int?
15:48:26 <jbalint> the fmap would be :: (X -> X) -> X -> X
15:48:33 <jbalint> no, only on the X itself
15:48:59 <jbalint> I never touch the int
15:49:27 <Iceland_jack> You can make it into a Functor by adding one more constructor 'Var a'
15:49:43 <jbalint> but i dont need a useless type parameter
15:49:45 <Iceland_jack> what you're asking for is not a Functor
15:50:38 <jbalint> when applied to the atomic values (I int) it wwould just apply the function directly to the value
15:50:41 <Welkin> :kind Either a
15:50:54 <Welkin> :k Either a
15:50:55 <lambdabot> Not in scope: type variable ‘a’
15:50:56 <jbalint> when applied to the list (U [X]) it would apply the function to every element of the lsit
15:51:02 <Welkin> :k Either String
15:51:04 <lambdabot> * -> *
15:51:09 <Welkin> that is a functor too
15:51:21 <Iceland_jack> jbalint: Have you tried writing that function normally?
15:51:36 <jbalint> Iceland_jack: should I do it show you?
15:52:10 <Iceland_jack> Sure, keep in mind the type of fmap would have to be
15:52:10 <Iceland_jack>     fmap :: (a -> b) -> X a -> X b
15:52:26 <jbalint> Iceland_jack: well obviously it can't be a Functor without a type parameter
15:52:44 <Iceland_jack> Absolutely! But what you're asking is not the action of a Functor
15:53:24 <Iceland_jack> A correct 'fmap' implementation would be forced to leave 'I Int' unchanged
15:55:53 <jbalint> Iceland_jack: it would pass I Int as an X, not do anything to it
15:56:06 <jbalint> Iceland_jack: then the function could deconstruct it 
15:56:12 <jbalint> the argument function
15:56:26 <Welkin> > fmap (+1) (Identity 2)
15:56:28 <lambdabot>  Identity 3
15:56:37 <Welkin> you can just wrap it in Identity to make it a functor
16:00:18 <jle`> jbalint: i think the issue here is that people often conflate "functors" with the general idea of "things that are mappable" in their head
16:00:29 <jle`> a lot of things are mappable, in the computational and abstract sense
16:00:36 <jle`> but that doesn't mean they are fit for the Functor abstraction
16:00:44 <jle`> ebcause Functor is not == "mappable"
16:01:24 <jbalint> jle`: what are some other classes?
16:01:24 <slack1256> but this are haskell endofunctors
16:02:47 <jbalint> what if my type were: data X = A | B | One X | Many [X]. what would be a class that could "map" over the values? I'm pretty sure I don't want/need a type parameter
16:03:00 <jbalint> Iceland_jack: ^
16:04:57 <slack1256> Gurkenglas: I guess the problem is my lack of dicipline. I could use different monad stacks on different parts of the program and translate at the boundary. But at some point I just say "fuck it" and let it go to the union of all of them
16:05:09 <Iceland_jack> What does a class give you that a normal function doesn't'
16:05:10 <Iceland_jack> ?
16:05:39 <Iceland_jack> Do you need your mapping function to work on some other datatypes?
16:06:41 <jbalint> I don't know... I'll just write all the code for this and then see where I'm at :)
16:07:28 <Iceland_jack> jbalint: There is one pattern that fits, from the uniplate/biplate/plated/... libraries
16:07:52 <Iceland_jack> it's meant for generic traversals
16:08:02 <jbalint> Iceland_jack: alright, I'll take a look at it
16:09:26 <Iceland_jack> For that one use case it's overkill (it's more complicated than Functor), but it seems like you want to experiment and look at different approaches
16:10:43 <jbalint> Iceland_jack: yeah, thanks a bunch
16:15:59 <mniip> anyone seen dramforever lately? :o
16:16:03 <Iceland_jack> jbalint: You can derive the code automatically and use the Control.Lens.Plated.transform function
16:16:03 <Iceland_jack>     transform :: (X -> X) -> X -> X
16:16:03 <Iceland_jack> I'm a bad person for suggesting lens
16:16:27 <Iceland_jack>     >>> transform (\case A -> B; B -> A) A
16:16:27 <Iceland_jack>     B    
16:16:32 <slack1256> @seen dramforever
16:16:32 <lambdabot> dr4MFOrEV3r
16:16:51 <mniip> that's not the function you're looking for
16:17:11 <mniip> [01:11:58] -NickServ- Information on dramforever (account dramforever): [01:11:58] -NickServ- Last seen  : Aug 26 14:54:40 2015 (5d 8h 20m 43s ago)
16:17:37 <Iceland_jack> mniip: Because it doesn't work under the One/Many constructors?
16:18:05 <mniip> Iceland_jack, I was talking to slack1256 about the "seen" function
16:18:12 <Iceland_jack> nvm
16:18:14 <mniip> which is actually levenshtein-corrected to "leet"
16:18:31 * slack1256 wanted to show off with my knowledge of lambdabot
16:18:42 <hpc> the best one is vixen -> nixon
16:20:33 <Iceland_jack> @leet trickydick
16:20:33 <lambdabot> +RiCKydiCk
16:24:38 <Hafydd> Hahaha.
16:24:50 <Hafydd> It sounds like the fuzzy command name system was successful.
16:28:06 <quchen> monochrom: I'm beginning to see what you meant with "too hard" for recursion schemes on mutually recursive data types.
16:28:07 <xelxebar> In general, does importing individual functions from a module decrease the size of the final binary versus importing a whole module? Or is the import stuff just namespace magic?
16:30:07 <xelxebar> I always end up wanting to import only exactly the stuff I use, but I don't know if I'm just being inane.
16:31:01 <quchen> I think GHC links object files without cherry-picking, so picking explicit imports won't reduce program size.
16:31:22 <quchen> But I'm not sure at all about this.
16:31:47 <quchen> Wasn't there a flag to generate one object file per definition to remedy that?
16:36:49 <begriffs> Does anybody know how to get a Key out of a PersistEntity in the persistent library?
16:37:42 <xelxebar> quchen: You pointed me in exactly the right direction. Thank you! --split-objs
16:38:02 <quchen> xelxebar: Ah, that sounds like the right flag.
16:42:00 <mniip> I finished my thing!
16:42:16 <mniip> asymptotically proven to be O(N) !
16:47:27 <quchen> What thing?
16:47:42 <Sindriav_> Is there a stateful lens view?
16:48:14 <Sindriav_> e.g. something like `putStrLn $ view state (lens1 . lens2)
16:48:38 <mniip> quchen, I invented a KMP-tier substring search algorithm that doesn't need any arrays
16:48:58 <mniip> operates purely on cons cells
16:49:16 <quchen> How's the performance?
16:49:23 <mniip> O(M+N)
16:49:27 <mniip> or you mean the constant
16:49:37 <quchen> That's asymptotics, which says almost nothing about performance
16:50:04 <quchen> How does it compare to KMP, for example? Would it be a viable alternative?
16:50:07 <mniip> it tells about performance at infinity :P
16:50:23 <mniip> it's a viable alternative because KMP requires arrays
16:50:37 <quchen> You can convert a list to an array in linear time.
16:50:52 <mniip> not all functional programming systems have arrays
16:51:20 <quchen> Hm. In that case your algorithm might have a head start.
16:51:38 <mniip> the performance is good too
16:52:01 <mniip> we produce a list item with a couple fields, and increment a number N times
16:52:12 <mniip> and follow a pointer and compare characters up to 2N times
16:52:22 <mniip> er, M+N and 2(M+N) respectively
16:52:48 <mniip> everything runs in O(M+N) memory
16:53:19 <rpfun> is there an existing abstraction for "generating" a function from data? for me, a function "f :: a -> (b -> c)" is not quite enough since i would like access to the "metadata" (in a) that generated the function (b -> c) in general. basically something isomorphic to "a -> (a, (b -> c))"
16:53:20 <mniip> more specificly, you need a list of M+N elements, containing 2 pointers and one int
16:54:06 <quchen> rpfun: What does "generate a function from data" mean?
16:54:22 <ttt_fff> lookuptable of course
16:54:29 <ttt_fff> either that or superai
16:54:55 <kori> hello
16:55:03 <mniip> rpfun, you mean constructing functions?
16:55:07 <kori> I have great interest in haskell, but I'm a lazy person
16:55:08 <rpfun> for example, i could have a typeclass "class Tag a b where mkTag :: a -> b"
16:55:34 <kori> is haskell, a language with lazy evaluation, good for me?
16:55:37 <mniip> quchen, I wrote a blog-tier article about it, it doesn't include a formal proof yet, only a proof-by-example
16:55:46 <kori> (of course I'm only joking)
16:55:48 <mniip> would you take a look
16:56:14 <quchen> I wanted to have a look at my pillow :-s
16:56:21 <quchen> How about posting it on Reddit?
16:56:25 <mniip> aw
16:56:34 <mniip> hmm I'm not a reddit guy though
16:56:45 <kori> what would you recommend? learn you a haskell?
16:57:03 <mniip> kori, that depends on what your experience with programming is, in general
16:57:16 <rpfun> mniip: yes, exactly
16:57:26 <kori> mniip: I've only really created programs in Go
16:57:32 <kori> which doesn't help
16:57:37 <kori> I'm familiar with some FP concepts
16:57:41 <mniip> like?
16:57:49 <kori> enough that I miss those in Go
16:57:50 <kadoban> kori: No. LYAH has no exercises. It's more "here's some cool stuff" rather than "let's learn haskell"
16:58:11 <kadoban> kori: https://github.com/bitemyapp/learnhaskell is a nice recommendation
16:58:13 <kori> mniip: fold, map, reduce counts, rght?
16:58:35 <mniip> those are higher order functions
16:58:48 <mniip> I guess you could call them FP elements
16:58:57 <kori> also, I'm aware haskell has quite the flexible syntax, which also interests me
16:59:05 <kori> and it's apparently a great language for compilers
16:59:10 <kori> which is my main interest, really
17:00:34 <kori> I'm technically a very new programmer
17:00:36 <Iceland_jack> kori: Once Haskell was called a language for writing compilers, so you're not far off :)
17:00:39 <kori> technically
17:00:50 <kori> new enough that getting into haskell might not be a huge hassle yet
17:07:22 <montanonic> yeah, well, good choice in doing Haskell early on. If you can get over the difficulty of working outside of an IDE (which is generally how most people work on haskell currently), you'll find it a very rewarding experience
17:07:31 <montanonic> @kori
17:07:46 <kori> montanonic: I use neovim and I've used this haskell plugin for silly things here and there
17:10:10 <montanonic> kori: perfect; well, I think the Haskell wikibook is really solid. If you're looking for more resources the Haskell homepage has plenty of recommendations too
17:10:36 <kori> aye
17:10:41 <kori> I came here first
17:10:45 <montanonic> also http://exercism.io/ is great for exercises
17:10:46 <kori> for serious things
17:10:50 <kori> I've screwed around a bit
17:10:52 <kori> with haskell
17:10:54 <kori> but I'll need it
17:10:55 <montanonic> ah okay
17:10:59 <kori> so might as well take it seriously
17:11:03 <mniip> quchen, how would I post the article to reddit anyway
17:11:09 <kori> I heard #haskell is very nice, so I thought, "why not"
17:11:09 <mniip> "hey look I invented"?
17:11:17 <montanonic> gotcha; yeah it is.
17:11:20 <joobus> the ghci plugin for vim is awesome
17:11:55 <quchen> mniip: Yup, something along those lines. "Substring search purely functional yadda yadda"
17:11:56 <montanonic> here's the specific haskell link: http://exercism.io/languages/haskell
17:12:00 <montanonic> I posted the more general one.
17:20:41 <srhb> kori: I think the cis194 coursework is some of the best introductory material out there :)
17:23:14 <joobus> i just finished hw2 from cis194.  i feel speshul  :P
17:24:11 <joobus> i really liked how once the ghc plugin in vim quit making suggestion or pointing out errors, i ran my program and it just worked.
17:25:50 <joobus> kori: https://github.com/bitemyapp/learnhaskell
17:26:46 <kori> joobus: aye I was linked this
17:26:49 <kori> thanks
17:27:02 <joobus> ah, i came in late
17:29:56 <joobus> i started off read learn you a haskell, then i got the book Haskell: the craft of functional programming, then started reading Real World Haskell.  I haven't finished any of those books.  Now I'm working through yorgey's course.  The homework problems are better than the book examples imo.
17:31:44 <tommd> Don't say that, he'll get an even bigger head on his shoulders.  ;-)
17:32:18 <joobus> does yorgey hang out here?
17:32:24 <tommd> Yes, some.
17:32:30 <joobus> what is his nick?
17:32:42 <cads> byorgey
17:32:53 <tommd> Great, now you woke him up. 
17:33:04 <tommd> He was just dozing off to whatever ICFP talk is happening right now.
17:33:22 <cads> BYORGEY WAKE UP! ;)
17:33:53 <cads> Hey guys, I have a question
17:33:59 <cads> but it's a python question :(
17:34:18 <joobus> i'm a pythoner in real life
17:34:23 <cads> hah
17:34:50 <tsani> Are the arrange* function in Opaleye useful at all ? They produce values of type SqlInsert or SqlUpdate, etc. but it seems that there are no functions in Opaleye that consume values of those types.
17:37:00 <cads> joobus:  okay, I'm learning regex, and I need to do  list.filter(regex), such that I get the largest sublist of list such that each element is in the language generated by regex.  It should be something like  [e fo e in list if re.compile("regex").search().groups() != None ]
17:37:44 <glguy> Python chat is fine in #python and #haskell-blah
17:37:51 <cads> okies
17:39:17 <cads> so I'm trying to solve my woes re having no haskell on the CLR
17:39:43 <cads> and a friend of mine suggests JSON as a bridge, rather than c
17:40:05 <cads> I think I saw an old haskell library for that
17:40:28 <cads> so could I run a haskell app server in concert with my CLR?
17:42:07 <joobus> cads: by server do you mean a web server?
17:42:21 <cads> I would like to write some machine learning stuff, but I need haskell to be able to pilot the python runtime that my CAD program uses to let users write scripts
17:43:46 <cads> joobus: no, really the haskell app could just be its own process, spawned by the python runtime
17:44:14 <joobus> cads: is it windows based?
17:44:19 <cads> but I'm thinking it would be nice to containerize it so that it could run alongside a database and other apps
17:44:44 * hackagebot zalgo 0.1.1.0 - Z-algorithm implemented on haskell's built-in cons-cell-based lists.  https://hackage.haskell.org/package/zalgo-0.1.1.0 (mniip)
17:44:46 <joobus> cads: you could communicate on a socket between haskell and python
17:44:48 <cads> joobus: yep, but if I do containerization I could even run the haskell instance in a linux droplet
17:45:07 <cads> joobus: I agree
17:46:39 <joobus> cads: i haven't used windows in about 10 years so I'm no help on that front
17:48:32 <cads> Id like to do feature extraction from reverse engineering data sets, as well as form finding, and 2d shape nesting optimization for manufacturing, so I imagine I will quickly run into algorithms that really want multiple remote machines
17:48:59 <cads> or maybe gpu
17:49:41 <cads> and I'm thinking I'd like to do all the heavy lifting in haskell
17:51:23 <cads> its funny, all the libraries that do that are closed source engineering applications that sell for prices on the order of $1K - $10K.
17:51:42 <joobus> i can believe that
17:52:19 <cads> as a rule they don't expose APIs or document the algorithms they use, so you never know how well your optimizations stack up to the state of the art
17:52:43 <joobus> are you expecting to need multiple machines?
17:53:23 <joobus> doing something on one machine is much simpler than possibly needing to spin up, manage, and coordinate a cluster.
17:53:50 <cads> I'd like to be able to push the code onto the GPU at least
17:56:21 <cads> joobus: some of the stuff I want to implement will be heavy on finite element analysis, which can be implented efficiently on the GPU
17:58:21 <cads> joobus: part of what I'm looking in the idea of an app server is something that manages infrastructure for things like multi-node distributed algorithms, or dynamically compiling code for each's node's GPU in a heterogenous deployment
17:59:07 <cads> joobus: I probably don't need that unless I want to rent this software out as a service
18:00:12 <cads> joobus: but it would be nice to have a roadmap to those kinds of scalabe features
18:01:01 <joobus> i've been researching the high scalability stuff, and what I've found is most roads lead to java and the apache foundation right now
18:01:15 <joobus> cads: I'm not real familiar with GPU programming
18:01:30 <SrPx> Hey I need to create a simple iPhone app (¬¬) can Haskell save me? :(
18:01:59 <cads> joobus:  I'm more familiar with the graphics/engineering literature that shows it's effective
18:02:15 <cads> joobus: never programmed a gpu myself :)
18:02:46 <cads> SrPx: not really
18:03:00 <cads> SrPx: try meteor
18:03:21 <SrPx> Meteor? What meteor?
18:04:53 <cads> SrPx: it's a way of making cross platform mobile and webapps using  javascript, html, and css. By the estimate of me and some collegues, the best bet for getting haskell to do web is to make a DSL that synthesizes into something like meteor.js
18:05:20 <cads> err, instead of web, I meant mobile.
18:05:38 <SrPx> I see :(
18:05:42 <TheRedPineapple> Hello all
18:06:05 <cads> SrPx: oh wait, there was a native haskell app on mobile
18:06:13 <SrPx> uhm?
18:07:04 <cads> SrPx: https://www.youtube.com/watch?v=n6cepTfnFoo
18:07:08 <cads> Ajhc
18:07:11 <TheRedPineapple> I had a semi-opinionated question. I started with scheme/the little schemer and worked through the book entirely. I understand higher order functions for the most part, referential transparency etc... but when it comes to practicality I'm stuck. Theres little documentation for much
18:07:19 <TheRedPineapple> haskell libraries seem to be documented better
18:07:33 <SrPx> Ah android..hmm
18:07:38 <talios> SrPx - http://keera.co.uk/blog/products/haskell-on-android-and-ios/ - Keera released some games in Haskell on android and iOS
18:07:55 <TheRedPineapple> would moving from schem/chicken to haskell this early be smart, or kind of make me hit a wall, when it comes to learning, and back step me prretty badly
18:08:06 <SrPx> talios: :) :)
18:08:53 <talios> SrPx - there are folk using Frege on android as well I believe
18:09:18 <cads> talios: nice!
18:09:25 <kadoban> TheRedPineapple: Well, haskell is a much different language, but … if it looks interesting to you, doesn't sound like much harm in learning it.
18:09:36 <cads> sorry for misleading you, SrPx!
18:10:25 <talios> SrPx - I saw some tweets/posts awhile back about the RoboVM guys getting frege working on iOS as well - https://github.com/ajhager/fregeit  - https://twitter.com/robovm/status/631571143162494977
18:10:52 <talios> cads - that doesn't mean it's all roses and "simple" tho :)
18:11:07 <talios> possible....
18:11:13 <SrPx> I've sent a message to them, thanks :)
18:11:21 <montanonic> TheRedPineapple: that's awesome! Scheme is a superb place to start! I didn't start with Scheme a few months ago but I wished I had once I found the Little Schemer
18:11:33 <talios> SrPx - glad I could help, now back to idling :)
18:11:44 <SrPx> okay, i have a lot to reasearch now
18:11:46 <SrPx> hope they answer :)
18:12:14 <montanonic> TheRedPineapple: How to Design Programs is an online book for another LISP language (a pretty damned advanced one too), but it might be a bit slow going if you've already read the Little Schemer
18:12:18 <mauris> i'm having trouble with Control.Monad.Random, but lambdabot doesn't @import it, apparently. is there any way to get it to do so, so that i can demo stuff in here easily?
18:12:41 <montanonic> TheRedPineapple: I haven't read this, but I'd think you should read and work through The Seasoned Schemer next
18:12:52 <TheRedPineapple> montanonic: Tls and scheme were awesome, and fun... just practicality aspect kind of seems low. Haskell seems pretty neat/well documented
18:13:09 <montanonic> TheRedPineapple: you'd be surprised by Racket them
18:13:17 <montanonic> TheRedPineapple: it has a web design kit built in
18:13:26 <mauris> my problem is: `sequence $ replicate 5 $ getRandomR (1, 2)` works
18:13:34 <mauris> but `sequence $ repeat $ getRandomR (1, 2)` doesn't
18:13:50 <TheRedPineapple> I am reading the seasoned schemer now. How is the documentation with racket? does it go from 0 to 100mph, or does it actually explain it thoroughly?
18:13:57 <montanonic> TheRedPineapple: what's your situation? Studying on your own? for class? side-project?
18:14:08 <montanonic> TheRedPineapple: It has superb documentation
18:14:27 <mauris> i suppose that's why `getRandomRs` exists. but I need an infinite list of results from some other random process than `getRandomR`.
18:14:43 <montanonic> TheRedPineapple: I'm working with Haskell currently instead of it because I just love the type system too much, but I definitely plan to spend some time with Racket in the future
18:15:11 <montanonic> TheRedPineapple: Here's a cool little Racket thing: http://pollenpub.com/ . It's a library you can use to publish books online.
18:15:58 <montanonic> TheRedPineapple: I think that if you have the time you'd do well to mess both with Racket and Haskell at the same time. They both have very different focuses but they both have very advanced features.
18:16:15 <TheRedPineapple> montanonic: Studying on my own, as a hobby. I'm an ironworker by trade, so no worries on a deadline
18:16:27 <montanonic> TheRedPineapple: and they are both production-ready; you can build serious stuff with either
18:16:57 <montanonic> TheRedPineapple: awesome! well definitely try both, and maybe also consider learning Purescript if you want a taste of Haskell. It compiles to Javascript and has interoperability with Java libraries.
18:17:48 <TheRedPineapple> montanonic: that's what's kind of made me question scheme a lot when using it. How could I make sure that only numbers are used by this function, or characters by that, etc. Haskell seems to make things a lot more intuitive from what I'm reading from people
18:17:57 <montanonic> TheRedPineapple: From my 5 months of studying programming non-stop, those three languages were the most interesting to me as far as design, power, and ecosystems.
18:18:01 <TheRedPineapple> the type system seems pretty nice
18:18:31 <montanonic> TheRedPineapple: I agree. It truly is hard to use a Lisp language for me right now because Haskell solves so many issues for me that I'd face with a dynamic language
18:18:38 <Welkin> montanonic: haha
18:18:55 <Welkin> once you use haskell, you don't go back to lesser languages
18:19:19 <AshyIsMe> except for work reasons and then regretfully...
18:19:34 <TheRedPineapple> montanonic: nice! I have looked into CL, Haskell, Scheme, Python, and Ruby... Python and Ruby just kind of bugged me for some reason (not sure why), but Scheme kind of clicked more. I guess I'm just not liking the dynamic typing?
18:19:37 <TheRedPineapple> lol
18:19:42 <montanonic> Welkin: Well, with Lisps you can do some crazy shit far more easily and elegantly than with haskell, however, such things currently are more in the vein of computer science interest than practicality
18:19:50 <montanonic> such as a metacircular evaluator
18:19:57 <Zekka> montanonic: Personal experience: Haskell created a lot of problems for me that are already solved in other languages
18:20:32 <montanonic> Zekka: care to elaborate for us? I'm curious to hear of your experiences
18:20:36 <Zekka> I liked Haskell a lot when I was seriously into using it but the metaprogramming support isn't that great imho (even though it's better than people think)
18:20:47 <montanonic> Zekka: oh, yeah, exactly
18:20:55 <Zekka> montanonic: Lately I write a lot of very reflective programs in Prolog and occasionally CHR
18:21:27 <Zekka> You can port logic programming roughly to Haskell but for the stuff I'm doing a type system is not particularly useful because I already have a lot of graceful ways to handle failure
18:21:29 <montanonic> Zekka: I see; that was definitely the impression I had with Haskell. Right now it's brilliant for what I'm working on, but there are better languages for metaprogramming.
18:21:51 <TheRedPineapple> is write yourself a scheme in 48 hours kind of outdated? Or is it a good starting point?
18:21:56 <Zekka> there are a lot of cases where slapping a type on what I'm trying to describe would not make things any clearer, and would make my code much more verbose
18:22:25 <montanonic> TheRedPineapple: I'm not entirely sure. Have you heard of Structure and Interpretation of Computer Programs, by the way? (SICP)
18:22:40 <Zekka> For instance, it's common for me to define a rule that takes structures which themselves represent rule heads: i.e. do(allocate(X)) or do(println(Text, Output))
18:22:50 <montanonic> Zekka: totally understandable. Have you tried metaprogramming in a Lisp dialect perchance?
18:22:59 <cads> talios: I think haskell needs more committees of business end users, to advocate on what tools we need :)
18:23:03 <montanonic> or more with prolog?
18:23:10 <cads> and also donate nomnom to the community to nom
18:23:11 <Zekka> You can represent this with a data type data Allocate = Allocate Int | PrintLn String Stream
18:23:22 <montanonic> I can see how that would be much more sensible than just a type.
18:23:28 <Zekka> but doing that doesn't make your code resilient against new clauses or cascading into other functions that have more clauses you didn't anticipate
18:23:36 <Zekka> Re Lisp, I've worked with Clojure but I haven't done serious metaprogramming in it
18:23:57 <Zekka> Lisp is probably suitable for a lot of the metaprogramming I want to do but I'm very attached to the logic features of Prolog and would need a pretty compelling reason to switch
18:23:59 <montanonic> Zekka: Ah, well I know Racket is superb for it. They literally have Prolog within their standard distribution
18:24:07 <talios> cads - ++ - I like what I'm seeing with "Haskell for Mac" that was recently released - very nice looking tooling.
18:24:12 <Zekka> I also think Prolog is easy to read, where Lisps are usually pretty hard to read, although that's not significant
18:24:13 <montanonic> Zekka: Prolog written using Racket, of course.
18:24:29 <cads> haskell needs stuff like java's app servers, and its ultrabeurocratic aprovals process :)
18:24:29 <TheRedPineapple> montanonic: yes. I haven't gotten to it, but plan on it as soon as I finish the seasoned schemer and introduction to algorithms
18:24:36 <cads> I don't care if that means a fork
18:24:37 <Zekka> Yeah, I've heard about that (also about one called Shen which is less popular) but never used it
18:24:57 <montanonic> TheRedPineapple: seems like you're going down an excellent educational path. 
18:25:11 <cads> call it Business Haskell, and pull frequently from batshit insane upstream haskell  :)
18:25:31 <TheRedPineapple> I think it's fun so far
18:25:32 <Zekka> There's also a hosted language called Minikanren that a whole bunch of people are porting, although IIRC it's not reflective or anything by itself, so a standards-compliant implementation would probably not be useful for my purposes
18:25:37 <cads> which is what stackage is already staring to do, mind you
18:25:48 <montanonic> Zekka: Shen seems very interesting to me however it would fare better if the community was a bit more open-feeling. It's creator seems to have a very strong influence on things.
18:26:00 <Zekka> montanonic: Part of the trouble in my use case is that lately I've been using a lot of CHR
18:26:12 <Zekka> and from what I can tell there are not a lot of people interested in porting that to languages other than Java, Prolog and Haskell
18:26:19 <Zekka> (there's a C port but no one's using it)
18:26:45 <Zekka> (CHR being a hosted imperative/logic language with a usecase similar to minikanren)
18:26:54 <montanonic> Zekka: with CHR or with Shen, sorry.
18:27:07 <Zekka> (er, similar in that it's not what you write your main program in, but you use it to automate things in your main program)
18:27:09 <Welkin> Shen is dead
18:27:12 <Zekka> With CHR
18:27:13 <montanonic> Zekka: I can't seem to find CHR.
18:27:25 <Zekka> montanonic: http://www.informatik.uni-ulm.de/pm/fileadmin/pm/home/fruehwirth/constraint-handling-rules-book.html
18:27:26 <Welkin> the creator is relicensing it under a new scheme
18:27:38 <montanonic> Welkin: again?
18:27:43 <montanonic> It was Qi.
18:27:51 <TheRedPineapple> are there any big gotchas to really watch out for when learning haskell? bad habits, etc?
18:27:56 <Zekka> "imperative/logic" is selling it a little short -- it's a really hard language to characterize -- but for a quick summary it's probably OK
18:28:07 <montanonic> TheRedPineapple: Use the simplest tool to solve a problem.
18:28:18 <Welkin> TheRedPineapple: Lists are usually control structures, but can be data structures too
18:28:26 <montanonic> TheRedPineapple: Don't use a Monad when you could just use Functor laws. For example.
18:28:29 <Welkin> TheRedPineapple: a list is not always the right data structure
18:28:35 <cads> talios: I think a reasonable alternative would be to work to really make haskell first class on platforms like java and the CLR, which literally nobody wants to really attempt :)
18:28:40 <Zekka> TheRedPineapple: Minding that since you're already using Haskell, you're not necessarily *that* committed to using the simplest tool to solve problems.
18:29:10 <TheRedPineapple> Zekka: Lol
18:29:13 <cads> I mean, though, imagine if you had a million dollars to get haskell running and playing nicely on the JVM. Is that enough?
18:29:15 <montanonic> Zekka: huh, never heard of CHR before. It looks pretty interesting. What are you using it for?
18:29:15 <Welkin> 21:23 < talios> cads - ++ - I like what I'm seeing with "Haskell for Mac" that was recently released - very nice looking tooling. <-- it is not "tooling"
18:29:38 <Welkin> it's a restricted sandbox for playing
18:29:42 <Zekka> montanonic: A cooking simulator, some riddle generation stuff I'm not going to release, and a little bit of AI
18:29:46 <montanonic> cads: Isn't that Frege though?
18:29:59 <Zekka> These are all more or less AI, but the last one was a quick psychological modeling thing for friends
18:30:00 <montanonic> Zekka: That sounds fun!
18:30:09 <talios> Frege day is next week I believe.
18:30:30 <Zekka> People bill CHR as a logic programming language because if you let CHR terms represent proven logical statements it can do a lot of reasoning for you
18:30:58 <talios> montanonic - http://www.canoo.com/blog/2015/06/30/frege-day-2015/
18:31:09 <Zekka> but how it operates on those terms is really well-defined and it doesn't enforce any rules like "a thing can only be proven once" (it's interested in *multisets*, not in sets) so you can model a lot of things with it
18:31:35 <talios> Welkin - that's still by definition, some form of tooling.  It's not a full tool CHAIN tho.
18:31:41 <montanonic> Zekka: funny that it has a similar look to Shen promotionally, and seems to have similar principles
18:31:50 <TheRedPineapple> well dinner is done. That you all for the information!! Happy hacking
18:32:00 <montanonic> Zekka: oh cool, it's implemented in Haskell?
18:32:05 <Zekka> montanonic: There's a Haskell port of it
18:32:17 <montanonic> TheRedPineapple: you're welcome! Have a nice day and meal!
18:32:19 <Zekka> There are a lot of Prolog implementations, and some big deal Java and Haskell ones
18:32:28 <Zekka> I haven't worked with the Haskell one at all, but the Java and Prolog ones are at least pretty good
18:32:49 <Welkin> Shen's death notice: https://groups.google.com/forum/#!msg/qilang/B_HLkAqsnXI/hqhtspU_AwAJ
18:32:56 <Zekka> It's not very hard to implement
18:32:58 <montanonic> Zekka: the haskell version doesn't seem like it's been updated
18:33:10 <montanonic> Zekka: is that for the same reason it isn't hard to implement?
18:33:19 <Zekka> montanonic: I mean, CHR hasn't changed in ages, but Haskell probably has
18:33:38 <montanonic> Zekka: ah okay. I'll have to look into it more so I don't burden you with simple questions.
18:33:52 <Zekka> montanonic: Whether it's hard to implement probably hasn't made a difference to a lot of implementers, because no one really knows or cares much about it
18:34:15 <Zekka> I hear most of the big CHR programs are buried in proprietary systems, there's not much foss code in it
18:34:29 <montanonic> Zekka: so, could you once more just quickly restate why you think the language is worth learning?
18:34:41 <montanonic> Zekka: and what problems it's best at solving?
18:35:06 <Zekka> montanonic: It's a really easy language to prototype things in and it's capable of doing a lot of the logical reasoning you would ordinarily expect to use Prolog for
18:35:25 <montanonic> Welkin: that's unfortunate. Seems like Shen needs/needed a platform like the one I'm working on: Snowdrift.coop.
18:35:30 <cads> hmm, this is cool
18:35:34 <Zekka> The constraint system feels reflective even though it's not reflective ta all -- you can make things available or not available by controlling whether prerequisite terms are present
18:35:59 <montanonic> we're hoping Snowdrift can solve some of the economic issues that open source (FLOSS) projects face, and provide a stable income for its primary developers.
18:36:16 <Zekka> It's really good for writing programs that need to build an unknown data structure based on known constituent parts
18:36:23 <cads> I found something called rython - you quote a ruby expression or a whole ruby script, inline with your python, and rython executes a ruby server that evaluates your quoted code.
18:36:28 <cads> that is neat!
18:36:48 <montanonic> Zekka: that is really intriguing. I'm definitely going to look into it more. 
18:37:11 <Hafydd> ...
18:37:15 <Zekka> Sure. It's not too hard to get started with -- SWI-Prolog comes with a CHR system builtin
18:37:22 <Hafydd> Why not just write your program in Ruby?
18:38:14 <Zekka> Oh yeah, that's another thing -- CHR has good interop with imperative code because it doesn't really use backtracking
18:38:33 <Zekka> there are cases where it backtracks but they're pretty limited, it's really easy to guarantee that a part of your program won't be backtracked over
18:38:56 <cads> Hafydd: I'd have to find a way of bundling ruby into my CAD program's pre-existing CLR environment. Python is already there - this way I just have to figure out how to load the rython library into Iron Python 
18:39:05 <Zekka> It feels pretty imperative compared to Prolog, although it's still pretty terse
18:39:05 <cads> would it be worth writing a hython library?
18:39:15 <montanonic> Zekka: perfect, I'll give SWI-prolog a shot. I've really wanted to try logic programming too, so why not kill two birds.
18:39:23 <montanonic> Zekka: and what's backtracking? sorry.
18:39:37 <glguy_> Some of this is better suited for #Haskell-blah
18:39:43 <Zekka> Yeah, one sec, I'll pop into #haskell-blah
18:39:58 <montanonic> glguy_: thanks, didn't know that was a channel
18:40:02 <montanonic> I'll hop over there too
19:10:03 <sedert> Is it correct to describe Haskel as elegant? I don't know it-- I just know a handful of C/C++ -- but my sister described it as that and I'm curious what people who have more experience than a university course and many years of not using it think.
19:11:24 <MP2E> that was what I described it as early on as well :) i'm a self taught hobbyist programmer that used C for about 8 years before I stumbled into Haskell, and I was very impressed with its elegance right out the gate
19:11:35 <MP2E> funnily enough, with C I thought I liked elegant code, but I couldnt' give it a good definition
19:11:42 <MP2E> Haskell has shown me what elegance *is*
19:11:49 <MP2E> it's a lot easier to quantify :P
19:12:13 <Zekka> I think there are big hacks in Haskell but a lot of it is pretty neat
19:12:18 <MP2E> there are yes
19:12:22 <MP2E> it's not perfect..
19:12:31 <MP2E> we'll get there one day maybe with Idris or something ;)
19:12:34 <Zekka> There are a lot of clever parts, and I usually try to avoid stuff that's too clever
19:12:41 <Zekka> well, there's two senses of clever
19:12:50 <Zekka> "you have to be clever to produce this" and "you have to be clever to understand this"
19:13:04 <Zekka> I think too many things in Haskell fall into both senses, when ideally most of them would fall into the first sense
19:13:31 <Zekka> But at least it's not clever mostly in the second sense.
19:14:12 <Zekka> And a lot of it is motivated by trying to avoid as much incidental complexity as possible, even though there's a common ground of incidental complexity that everyone who uses Haskell has to wade through
19:15:01 <Zekka> which is why people are interested in substituting things like mtl with even more typey things -- because if everyone learns the central nexus of typey things, the hope is that lifting will be easier overall aside from that intersection
19:16:00 <Zekka> Like, lens is another example -- if you ask a lens fan why he likes them, he'll probably say they make a lot of things much easier. They're pretty confusing imho (and I'm speaking as someone who understands how they work) but once you understand how they work they make a lot of things simple that would have had a lot of extra complexity with normal accessors
19:16:42 <Zekka> (I don't think lenses make very many things much simpler when you don't understand them, being clear)
19:17:48 <Zekka> I think that's all pretty nice and principled even though I think for a lot of programs Haskell is harder to use than most other languages -- if you can get on board with the idea that "we'll all agree to use this one characterization of the hard parts" in cases that are hard, I think you'll like it a whole lot
19:17:55 <Zekka> and you can use words like "elegant" and all if you're into that
19:18:14 <felixn> clever in Haskell is just it's imperfections.  getting lens to work in Haskell may be clever, but the concept isn't, plenty ML languages have anonymous records
19:18:16 <Zekka> (I don't like using that word very much, because people use it for technologies like Ruby and Python, and I don't think those technologies are very exciting)
19:18:28 <Zekka> felixn: Lenses aren't anonymous records!
19:19:17 <felixn> Zekka: http://elm-lang.org/docs/records you can get into semantics if you want :D
19:19:20 <Zekka> If I'm not mistaken lenses + accessory types are just a super general characterization of accessors designed to degrade well when composed under Haskell's natural rules
19:19:45 <Zekka> felixn: I don't think lenses have very much to do with records, except that you can define them over records
19:21:11 <Zekka> (sidenote -- I wrote a lens library for Elm a while ago but afaik no one is using it for anything. Probably for good reason.)
19:21:27 <htebalaka> is there any library with combinators for a type like "newtype Algebra f a = Algebra (f a -> a)"
19:22:19 <sedert> I've come in here rather ill equipped having forgotten most everything I knew of Haskell since discovering it years ago.. I have other questions but I'm very much a novice programmer, so I'm don't want to waste time asking redundant questions. I feel as though I'm in over my head. I'll ask later with an understanding of some basic concepts so I can be more efficient at questioning.
19:22:46 <Zekka> sedert: This is one of the friendlier Freenode channels imho, I wouldn't worry too much about bothering people
19:23:00 <sedert> Typing on mobile is also absolutely not the bee's knees.
19:24:25 <sedert> I actually came here because of something you guys did that made it to Pastebin some half year ago. Glad to see that the channel is just as described then.
19:27:23 <Cale> sedert: Feel free to ask lots of beginner questions, it's totally fine
19:28:25 <cads> hey cale, are you good with geometric packing algorithms?
19:28:45 <cads> if I can't find anyone I'm considering becoming the resident expert ;)
19:28:48 <sedert> Thanks Cale. Lemme RTFM first.
19:28:49 <Cale> uh, not especially
19:29:18 <Cale> I've never implemented one, I've read about them a little bit, but probably forgotten most of it
19:30:15 <cads> Cale: it's a tough problem, and the only people that implement it are researchers and people that are building a product. Hard to find any code, so far.
19:30:43 <cads> But I've found some nice algorithms papers - looks like it can be done by integer programming
19:31:07 <mniip> Cale!
19:32:17 <mniip> Cale, are you by chance interested in string-related algorithms?
19:33:28 <Cale> mniip: uh, some of them are cool? I can't say they're a *particular* interest of mine, but sure.
19:33:59 <Cale> mniip: Have you seen the functional implementation of KMP in Haskell? :)
19:34:13 <mniip> arrayless?
19:34:22 <Cale> http://www.twanvl.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell
19:34:26 <Cale> yeah
19:34:43 <Cale> It's beautiful
19:35:28 <mniip> Cale, I made an algorithm that does the same thing
19:35:32 <mniip> but differently
19:36:51 <slack1256> no CS background here. Are algorithms classfied as imperative or functional?
19:37:07 <slack1256> or is it a implementation detail? how does interact wih asymtotics?
19:37:40 <mniip> Cale, anyway would you be interested in checking out an article of mine
19:38:48 <Cale> slack1256: In the grand scheme of things "algorithm" isn't exactly a precise technical term, and refers to many sorts of descriptions of how to accomplish things. So people end up in disagreements about whether some program really implements a given algorithm.
19:40:17 <Cale> mniip: sure
19:40:37 <Cale> mniip: I'm getting a bit sleepy at the moment, but at the very least I'll save the link :)
19:41:41 <mniip> Cale, http://mniip.com/pages/ZAlgorithmOnConsCells
19:42:57 <jmcarthur> htebalaka: http://hackage.haskell.org/package/recursion-schemes-4.1.2/docs/Data-Functor-Foldable.html
19:44:15 <htebalaka> jmcarthur: yeah, i've seen that one. i'm mainly wondering if different representations of the f-algebra newtype allow different instances, though maybe taking another look at recursion-schemes is a good idea
19:45:12 <htebalaka> like, i'm pretty sure "newtype Algebra f a = forall s. Algebra (f s -> s) (s -> a)" allows an Applicative, but i'm wondering what else
19:45:50 <cads> wow, what is an algebra in that context??
19:46:05 <htebalaka> a function for reducing a recursive datatype
19:46:14 <cads> f being that data type?
19:46:14 <htebalaka> provided the f is a functor
19:46:26 <htebalaka> "Fix f" is the datatype
19:46:36 <htebalaka> newtype Fix f = Fix (f (Fix f))"
19:47:50 <cads> so an instance of algebra list a is............ another algebra, but paremeterized by some type s?
19:48:07 <jmcarthur> cads: maybe you'll find some interesting keywords here https://en.wikipedia.org/wiki/F-algebra
19:48:23 <jmcarthur> cads: if this seems interesting you, maybe try the bananas, lenses, barbed wire paper
19:49:02 <jmcarthur> cads: or a slightly different angle, the algebra of programming by richard bird.
19:49:59 <jmcarthur> cads: http://www.eliza.ch/doc/meijer91functional.pdf
19:50:32 <cads> I'm familiar with F-algebras, just a bit confused about forall s. in the defintion
19:51:00 <cads> and what an instance of Algebra f a looks like
19:51:25 <mauris> hmm... it bothers me how while haskell has very many good container data types, converting between them basically always seems to involve `A.fromList . B.toList`
19:51:26 <htebalaka> i don't think the existential is hugely important, but without it you can't give a functor instance. i started with "newtype Algebra f a = Algebra (f a -> a)", which allows for a zipping function "Algebra f a -> Algebra f b -> Algebra f (a,b)", but with the existential i can also have a functor instance
19:51:35 <jmcarthur> i think it's just CoYoneda being applied to an F-algebra. i don't really understand it.
19:51:46 <cads> oh, I think I get it
19:52:01 <htebalaka> at least, i think it's necessary. right now i'm just thinking of different representations. i haven't started coding
19:52:11 <jmcarthur> in particular i don't understand the claim that it gives you an Applicative
19:52:11 <cads> you're specifying all the arrows alpah_A : F(A) -> A
19:52:13 <mauris> are there like, packages that provide better implementations of stuff like Vector <-> Seq
19:52:23 <cads> that's what an algebra is, that natural transform
19:52:35 <mauris> or does fromList.toList usually turn out to be fast
19:52:59 <jmcarthur> mauris: it's not guaranteed to be fast always, but there are ways it could be.
19:53:37 <jmcarthur> mauris: even if it's not as efficient as possible, it should be at least decent enough for most purposes.
19:54:31 <mniip> Cale, are you reading? :o
19:58:52 <cads> jmcarthur: hmm, it feels like a F-algebra should be a natural transformation from the endo functor to the identity functor
20:00:19 <cads> oh
20:00:41 <cads> I derped
20:00:49 <cads> http://ncatlab.org/nlab/show/algebra+for+an+endofunctor
20:01:34 <cads> thats not hugely different from the wikipedia :)
20:03:23 <cads> still trying to understand    newtype Algebra f a = forall s. Algebra (f s -> s) (s -> a).     By my understanding,  Algebra f a = f a -> a
20:03:44 <htebalaka> jmcarthur: Algebra f a <*> Algebra g b = Algebra (liftA2 (,) (f . fmap fst) (g . fmap snd)) (\(x,y) -> a x (b y))
20:05:26 <cads> htebalaka: the apparent recursion in your definition of an algebra is still throwing me for a loop :)
20:05:58 <htebalaka> cads: what recursion? also, i realized you need "data", not "newtype"
20:06:24 <htebalaka> my first formulation used newtype, but that was before introducting the existential and postprocessing function
20:06:44 <htebalaka> not that that is hugely important to the discussion :/
20:06:52 <cads> I dont understand what the existential does, and why the term algebra appears on the RHS
20:07:15 <cads> my understanding is we're defining a type class
20:07:33 <cads> that shows us how to take any type s and use it to form what we'll call an algebra for a
20:07:36 <cads> is that correct?
20:08:25 <htebalaka> no, a datatype. that's just how you introduce an existentially quantified variable in a data declaration. you could also do: "data Algebra f a where { Algebra :: (f s -> s) -> (s -> a) -> Algebra f a }. for any Algebra datatype we form we're allowed to use a type s, but once we've packed it into an Algebra data constructor we have to forget which type we used
20:09:54 <Xe> so the prelude error function unconditionally stops execution?
20:10:03 <htebalaka> so i could have one algebra which contains values "([Int] -> Int), (Int -> Bool)", and another with "([Char] -> Char), (Char -> Bool)", and they would be considered to have the same type
20:10:31 <htebalaka> *values with the types
20:11:14 <mniip> htebalaka, yes
20:11:16 <cads> htebalaka: wtf are these algebras, lol :)
20:11:56 <cads> seem pretty specialized, and they compose in a way I haven't understood yet.
20:12:43 <htebalaka> a simple example would be "data ListF a b = Cons a b | Nil; length Nil = 0 ; length (ListF _ b) = 1 + b". length takes some accumulated int value, and increments it
20:12:55 <cads> htebalaka:  so let me get this straight, though. By your defintion, an A algebra is any ordinary B algebra, along with a mediating morphism B -> A
20:13:10 <cads> htebalaka: is it that simple?
20:13:35 <htebalaka> i think so... my knowledge of technical terminology is pretty weak
20:13:43 <htebalaka> but that sounds about right
20:14:27 <htebalaka> the existential is purely added to admit an applicative instance. i'm just playing around with different formulations to see what kind of instances i can come up with
20:14:41 <cads> wait, or are the actual elements of your algebras pairs of functions of type ((f s -> s), ( s -> a))
20:15:13 <cads> oh, wait, is the Algebra on the RHS of the constructor simply a two parameter type constructor containing a first and second entry?
20:15:34 <cads> RHS of the equation*
20:15:42 <htebalaka> as i said my technical vocab is not great. as far as i can tell pairs of functions and the mediating morphisms stuff sound the same
20:16:43 <cads> okay, so tell me this, is    data Algebra f a = forall s. Foo (f s -> s) (s -> a)  an isomorphic type?
20:17:11 <htebalaka> isomorphic to what i had? yes, they just use different data constructor names
20:17:28 <cads> okay, sorry, I am a bit rusty on haskell types
20:17:38 <cads> I was misunderstanding the definition
20:18:09 <cads> okay, I understand now
20:18:39 <htebalaka> sometimes i wish we had an "exists" keyword
20:18:48 <cads> Hmm, what you have is interesting
20:19:01 <cads> it's not an ordinary F algebra
20:20:20 <htebalaka> not quite. i think i can also do "data Coalgebra f a = forall s. Coalgebra (s -> f s) (s -> a)" and get an applicative instance (though i'm pretty sure it will need "f" to be an applicative, whereas the algebra applicative only requires functor
20:22:30 <cads> what can you do with two f-algebras of a?
20:23:04 <htebalaka> zipping them is the only interesting thing i could think of
20:23:33 <htebalaka> or applying some function "a -> a -> b" to get an f-algebra of b
20:23:47 <cads> so say you have  (f s -> s),  (s -> a),    and you have  (f t -> t), (t -> a)
20:23:58 <cads> these are two f a algebras?
20:24:46 <htebalaka> yup
20:25:08 <cads> then you can get the zipped f (a,a) algebra by forming (f (s, t) -> s), ((s,t) -> (a,a)) in the obvious way?
20:25:42 <htebalaka> yup
20:26:51 <cads> and get an f b algebra by applying some  (a -> a -> b)
20:27:22 <htebalaka> correct
20:27:40 <cads> phew
20:28:26 <cads> can you combine f a algebras using disjoint unions?
20:29:22 <htebalaka> i think so?
20:29:46 <cads> you can turn two f a algebras into a single f a algebra over domain s + t in the obvious way
20:30:05 <glguy_> Xe: attempting to evaluate 'error "some message"' raises an exception which will kill the thread it is evaluated in if it isn't caught first
20:30:13 <cads> in fact I think this may be the ideal way to compose f a algebras
20:31:07 <htebalaka> now i think i'm the one who is lost.
20:31:40 <htebalaka> though i did just manage to do the same with f-coalgebras, though it does need the f to be applicative, which limits it quite a bit :
20:31:43 <htebalaka> * :(
20:32:27 <Pamelloes> Ugh. Lens' tests literally take an hour to run :/
20:33:04 <htebalaka> cads: could you give an example of what you mean for the ideal combining function (in terms of type)?
20:33:58 <cads> saw we have  an f a algebra (f s -> s),  (s -> a),    and you have  another algebra (f t -> t), (t -> a), and that the disjoint union type of s and t is s + t.
20:34:22 <cads>  then we can obviously form (s + t -> a)
20:34:37 <cads> But can we form (f (s + t) -> (s + t))?
20:34:46 <htebalaka> (+) ~ Either?
20:34:55 <cads> I think so
20:35:15 <cads> yes, it is
20:35:21 <cads> left and right
20:35:40 <htebalaka> hmm... i'm not sure
20:36:57 <htebalaka> i was wondering about an alternative instance. maybe that type would arise from it?
20:37:09 <cads> yeah, suppose we have a function [int] -> int,  and a function string -> char. It is not clear how to define a function either [int] string -> either int char.
20:37:27 <cads> ew.
20:38:18 <glguy_> That's just casing on the Either applying the right function
20:38:20 <cads> at best it would have to separate the sublist of the input that is all int or all string, and then apply one of the existing functions.
20:38:34 <glguy_> And putting the result back in Either
20:38:46 <cads> err
20:38:52 <htebalaka> wouldn't it be [Either Int Char] -> Either Int Char
20:38:57 <cads> right
20:39:00 <cads> I am sorry
20:39:00 <htebalaka> though that's even worse
20:40:03 <cads> lol
20:40:12 <htebalaka> i'm thinking maybe it'd be easier avoiding []. it might be possible by relying on an instance that [] lacks
20:40:30 <htebalaka> though i can't think of which
20:40:33 <cads> it's just my standard example of a functor :) 
20:41:30 <cads> so your applicative just zips together two f a algerbas into an f (a,a) algebra?
20:41:38 <htebalaka> pretty much
20:41:51 <cads> cool
20:42:02 <cads> does that let it do any cool applicative stuff?
20:42:15 <cads> (I don't know what cool applicative stuff exists :D)
20:42:30 <htebalaka> i have an applicative instance, though i don't have any cool examples that make use of it yet
20:43:36 <cads> I wonder if I can work out a coherent notion of a homomorphism between fa algebras 
20:44:20 <htebalaka> i've got some code where i'm folding up some Cofree comonads (Fix (Const a :*: f) ~ Cofree f a essentially), where i need to annotate an AST multiple times, so the idea of zipping algebras seemed worth exploring
20:44:33 <htebalaka> the annotations are the "Const a"s
20:45:20 <cads> oh this is cool
20:46:18 <cads> I figured out how to define a morphism of f a algebras
20:46:38 <htebalaka> i don't think any of this is strictly new. the foldl library does the same idea, though f algebras would correspond more closely to right folds
20:46:55 <htebalaka> though the use of the existential is taken from it
20:46:59 <htebalaka> how?
20:48:03 <cads> an f a algbra is just a f algebra centered at some type s, with a mediating arrow to a.    It looks like   f(s) -> s -> a
20:50:34 <cads> a morphism from   f(s) -> s -> a     to    f(t) -> s -> a is just a pair of functions  f(s) -> f(t)   and s -> t,    so that f(s) -> f(t) -> t -> a = f(s) -> s -> a = f(s) -> s -> t -> a.
20:51:29 <cads> I think we also need the morphisms to be a homomorphism of the ordinary F algebras f(s) -> s, and f(t) -> t
20:51:35 <sedert> I have to childsit in approx 7 hours and all I want to do is read documentation. Tonight was not the night to learn Haskell and I'm going do be bothered until I return.
20:51:36 <htebalaka> is "f(s) = f s -> s"
20:51:45 <cads> yes
20:51:55 <sedert> Thanks guys, night.
20:52:09 <cads> in that we also have  f(s) -> s -> t = f(s) -> f(t) -> t
20:52:44 <cads> This might be necessary to allow morphisms to compose properly, but I will check
20:53:09 <htebalaka> i really need to bite the bullet and work through maclane. i will freely admit this is difficult to follow
20:53:27 <cads> it would be easier if I could show you the diagrams
20:53:51 <cads> true, or if you could already see the diagrams in your head :)
20:54:32 <htebalaka> it makes me happy regardless that someone else thinks there's stuff worth looking at here
20:55:10 <cads> I have a feeling that what you are looking at turns out to be a standard way of extending or specializing the concept of the ordinary f algebra
20:55:54 <htebalaka> kind of wondering what type would make sense for paramorphisms. data Para f a = forall s. Para (f (s, Fix f) -> s) (s -> a) seems unsatisfying
20:56:25 <cads> like an f a algebra is centered at some type s, and we see its results in a through a view of type s -> a
20:57:11 <cads> like some remotely viewed functor operation
20:57:13 <htebalaka> as does reconstructing the datatype with the fold
20:59:15 <htebalaka> i'm not actually using Fix, since i want a generic functor instance (which means i need data PFix f a = PFix (f a (PFix f a))), and fixed points of bifunctors, so i'd like a formulation that avoids needing to specify Fix or PFix in the type
21:00:03 * hackagebot ig 0.5 - Bindings to Instagram's API.  https://hackage.haskell.org/package/ig-0.5 (cdepillabout)
21:01:39 <cads> htebalaka: if it makes you feel any better, I have a terrible time interpreting anything with more than 0.5 instances of "Fix", on average
21:02:25 <htebalaka> pattern synonyms make it more handy to work with i'm hoping
21:03:40 <breadmonster> I just realized you can make list a Num instance.
21:03:51 <breadmonster> What other typeclass abuse examples exist?
21:04:35 <htebalaka> breadmonster: peano ints, or "instance (Num a) => Num [a]"?
21:04:49 <breadmonster> The latter.
21:04:59 <htebalaka> cads: it seems a little brittle. i also wanted GADT rules on my type, which means i need an even more complicated fixed point/f-algebra type
21:05:55 <htebalaka> but there seems to be some bug when pattern matching on certain GADTs in 7.10, so i'm deciding fixed points of bifunctors are as much complexity as i'm willing to deal with
21:06:45 <htebalaka> breadmonster: "instance (Num a, Applicative f) => Num (f a)" i think is the more general version (also works for monoids)
21:07:21 <cads> htebalaka: why do you require the addtional function s -> a?
21:08:36 <htebalaka> cads: can you write an applicative instance without it? i didn't really try, but my intuition was that it would be necessary
21:10:12 <cads> well, consider that any ordinary f algebra centered at a is also an f a algebra centered at a with mediating morphism identity : a -> a
21:11:10 <cads> so anything you do applicatively with your generalized f a algebras, you have to be able to do with a pair of f algebras centered at a
21:11:41 <cads> ie,    Algebra f a = (f a -> a)
21:12:17 <cads> oh I see
21:13:42 <cads> well, you still get a way to go from  (f a -> a), (f a -> a) to a single (f (a, a) -> (a,a))
21:14:12 <cads> Is that a functor from  Algebra a to Alebra (a, a) ? 
21:14:37 <htebalaka> yeah, it was after i noticed it was zippy that i thought i would need the existential to make it fully applicative
21:14:39 <cads> note such a construct informs you about your model, since you're considering delocalized version of the same correlations
21:15:25 <htebalaka> i don't think you even need them both to have the same type a to zip them
21:16:16 <cads> well consider this    Algebra f a = forall s. Alg2 (f a -> a) (a -> b)
21:16:31 <matsuura_> Do you guys think haskell will ever become a fad?
21:16:47 <jle`> as in, will it ever become popular?
21:17:01 <matsuura_> yeah, ultra-reddit style popular or something
21:17:03 <cads> there are interesting ways to combine an f a algebra II with an f a algebra I
21:17:29 <cads> htebalaka: in fact, there are potentially very interesting ways of combining things here :)
21:17:31 <htebalaka> cads: is the existential supposed to appear somewhere in the data constructor
21:17:33 <htebalaka> ?
21:17:41 <cads> err
21:19:13 <cads> htebalaka: here, a better statement of what I'm thinking (and a correction to the error you point out): Algebra1 f a = forall s. alg1 (f s -> s) (s->a),  Algebra2 f a = forall s. alg2 (f a -> a) (a -> s)
21:20:18 <cads> in fact, there is a way to compare  a algebra1 with an algebra2, if they form a commutative square
21:21:14 <cads> actually, not sure how to make that work :)
21:23:24 <Hafydd> Algebra I and Algebra II sound like the names of university courses.
21:23:38 <htebalaka> hah
21:25:57 <htebalaka> i feel like the coalgebra version doesn't work. maybe "data Coalgebra f a = forall s. Coalgebra (s -> f s) (s -> a) s"
21:26:16 <htebalaka> not much use if you can't start it
21:30:56 <cads> htebalaka: if you have an f a algebra centered at s, and an f b algebra centered at s, ie, two pairs of function  (f s -> s)_1, (s -> a) and  (f s-> s)_2, (t -> b) ,   you can form an additional f a algebra,  (fs -> s)_2, (s->a), anf similarly (fs->s)_1, (s, b).
21:32:45 <htebalaka> relying on them being the same s?
21:33:12 <cads> right, if they are the same s, you can factor them and swap factors
21:35:34 <htebalaka> hmm... i would hate needing them to have the same type. is there something useful you can do by swapping the functions?
21:35:46 <cads> pfft, no :D
21:36:13 <cads> I'm just trying to see if there's any algebraic structures to study
21:37:07 <htebalaka> well this has been interesting, but i gotta go
21:37:09 <htebalaka> nite
21:37:46 <cads> nite
22:13:31 <lethjakman> so I've been struggling with this for a bit and I still seem to be confused somewhere
22:13:33 <lethjakman> https://gist.github.com/lethjakman/b677e5013c5f4d126fda
22:13:54 <lethjakman> I'm attempting to extract data from a yaml in order to place it into a data structure
22:13:58 <lethjakman> I'm using Data.Yaml
22:14:16 <lethjakman> I'm decoding it and returning it if it's available through a case statement
22:14:29 <lethjakman> I want it to stop the application if it's not present
22:14:41 <lethjakman> but when I try to access it from the data structure it's an IO
22:15:02 <Axman6> you need to have: getsesAccessKey :: IO SesKeys
22:15:10 <lethjakman> should I be unwrapping the IO somehow (like a case statement) in the above function as well as unwrapping it in the getsesAccessKey function?
22:15:17 <lethjakman> Axman6: I have that
22:15:23 <lethjakman> it's more the unwrapping of the IO that I'm confused about
22:15:24 <Axman6> you can't perform IO without it appearing in the IO monad
22:15:26 <Axman6> no you don't
22:15:32 <lethjakman> because I can't seem to return just SesKeys
22:15:33 <Axman6> you have getsesAccessKey :: SesKeys
22:15:46 <lethjakman> Axman6: sorry, had
22:15:48 <lethjakman> wrong tense
22:16:05 <Axman6> no, because then you'd be lying. you can't perform arbitrary IO and pretend there's no IO happening
22:16:07 <lethjakman> Axman6: so if I do it that way, how do I run "(accessKey getsesAccessKey)"
22:16:21 <lethjakman> in the getSESCredentials function?
22:16:30 <Axman6> you need to use something like accessKey =<< getsesAccessKey
22:16:57 <Axman6> you can't do that, the way you're trying to anyway
22:17:06 <mauke> do { key <- getsesAccessKey; ...
22:17:21 <lethjakman> Axman6: what do you mean?
22:17:31 <Lokathor> so i'm running a lambdabot. How can I make it NOT give the titles and a tinyurl to links posted in a channel?
22:18:28 <gamegoblin> Hum… I guess it’s time I get around to learning Lens
22:18:55 <lethjakman> Axman6: do you mean I can't do what I"m doing with the =<<?
22:19:22 <Axman6> I was wrong, mauke is suggesting the right answer. one sec
22:20:06 <lethjakman> mauke: how would that go into the getSESCredentials function?
22:20:08 * hackagebot waitra 0.0.4.0 - A very simple Wai router  https://hackage.haskell.org/package/waitra-0.0.4.0 (phadej)
22:20:26 <lethjakman> do I have to make it a monadic function?
22:20:31 <mauke> it's not a function
22:21:12 <lethjakman> mauke: ?
22:21:23 <mauke> there's no -> in its type
22:21:34 <lethjakman> mauke: oh
22:21:56 <lethjakman> that makes sense
22:22:08 <lethjakman> reguardless, is it possible to use it there, or am I structuring my code all wrong?
22:22:10 <lethjakman> or both?
22:22:14 <Axman6> lethjakman: something like: http://lpaste.net/140010
22:22:33 <mauke> Axman6: needs return
22:23:13 <Axman6> whoops, yes
22:23:35 <lethjakman> gah, this seems to make everything an IO something for all eternity
22:23:39 <Axman6> lethjakman: should be return SES { ... not just SES { ...
22:24:18 <Axman6> yes, once you use IO, you cam't escape
22:24:23 <mauke> lethjakman: well, it has to open a file
22:24:38 <lethjakman> hrmmm
22:24:46 <lethjakman> why?
22:24:51 <lethjakman> it's never going to be safe again?
22:24:56 <lethjakman> I thought that's why I could return nothing, no?
22:24:58 <mauke> because you wrote it to do that?
22:25:12 <mauke> Data.ByteString.Char8.readFile "./secrets.yaml"
22:25:12 <shachaf> Axman6: I've used IO and survived unscathed.
22:25:48 <Axman6> but did you escape it, ot just come to accept it into your life?
22:25:51 <Axman6> or*
22:27:53 <lethjakman> Axman6: did I escape it or did I just come to accept it into my life?
22:28:41 <Axman6> nevermind
22:29:12 <lethjakman> sorry
22:29:22 <lethjakman> thank you for your help...that seems to have pushed me in the right direction
22:31:57 <chreekat> lethjakman: well that's the point, really.. once you've used IO, you can't not have used IO. Every computation that follows has that same dependency on IO having happened at some point.
22:32:52 <lethjakman> it seems odd to me that I can't branch based off of running IO or not
22:33:10 <Axman6> what do you mean?
22:37:53 <chreekat> lethjakman: Interesting point. But, now that I look at your exapmel again, you're actually making things harder on yoursefl by using IO to throw an error
22:38:06 <chreekat> oh nm.
22:38:09 <chreekat> There's the readFile
22:38:28 <lethjakman> chreekat: sorry that it's a bit messy. 
22:38:42 <lethjakman> Axman6: normally I'd do the IO in a function and separate that from everything else
22:38:53 <lethjakman> if things go horribly wrong I handle it in that function and fork off from everything else
22:39:02 <lethjakman> seems like here I have no choice but to handle it all the way down
22:39:14 <mauke> ... handle?
22:39:21 <lethjakman> handle failed IO
22:39:40 <mauke> what
22:40:00 <chreekat> So, while you have an interesting point, in the example you specified, it doesn't actually apply. Now, *for* that point, you could have some computation that returns something — and I stress this looks distasteful to me for unspecified reasons — Either (IO a) b
22:40:11 * hackagebot language-qux 0.1.0.0 - Utilities for working with the Qux language  https://hackage.haskell.org/package/language-qux-0.1.0.0 (hjwylde)
22:40:33 <chreekat> Gut feeling says to tell you, pretend I never wrote that
22:40:50 <lethjakman> I'll keep that in mind
22:40:59 <lethjakman> I know Yaml has some eitherDecode functions
22:41:14 <lethjakman> mauke: maybe I'm just thinking about things in a very not-haskell way
22:42:07 <mauke> you're not handling any exceptions in that code
22:42:42 <chreekat> You could be seeing IO where there isn't any. I think it's common to see IO infecting everything, but the truth is IO *does* infect everything. In languages that don't have the distinction, it feels quite natural; you're boned from the get-go. Haskell at least lets large swathes of code not be in IO, which is basically a miracle.
22:42:58 <chreekat> You have to become accustomed to the miracle
22:43:54 <lethjakman> mauke: it wouldn't be an exception in haskell normally though would it? Just a Nothing?
22:44:14 <lethjakman> lol
22:44:18 <mauke> lethjakman: you were talking about "failed IO"
22:44:24 <mauke> all IO operations throw on error
22:44:31 <mauke> well, the library ones anyway
22:44:35 <lethjakman> chreekat: I like that discription 
22:44:54 <lethjakman> mauke: ok, then what I have wouldn't be good enough?
22:45:12 <mauke> I don't understand
22:45:30 <mauke> what you're saying here and what's in your code seem to be unconnected
22:48:16 <lethjakman> mauke: that wouldn't surprise me, my haskelling is very new
22:49:09 <lethjakman> I'm saying that the code that I have for IO (the case statement) isn't good enough to catch if the file doesn't exist?
22:49:34 <Axman6> correct
22:49:57 <AaronFriel> When using Control.Parallel.Strategies, specifically "rparWith rdeepseq" in code that's, suffice it to say, pipes/conduit-like, how big is the cost of invoking it recursively? See example:
22:50:01 <lpaste_> AaronFriel pasted “Parallelism example” at http://lpaste.net/5023768880435167232
22:50:03 <chreekat> that's right. readFile will throw an exception, short circuiting the rest of the computation.
22:50:40 <lpaste_> AaronFriel revised “Parallelism example”: “No title” at http://lpaste.net/5023768880435167232
22:50:50 <AaronFriel> Fixed a truncation on a comment
22:51:13 <lethjakman> gah I feel like I'm so close....
22:51:15 <lethjakman> https://gist.github.com/lethjakman/b677e5013c5f4d126fda
22:51:50 <lethjakman> so now that the IO has contaminated all the way up the chain to where the email is being sent, I had to liftIO the renderSendMailSES, but that was returning the wrong type
22:52:13 <lethjakman> so I wrapped that with a return to correct that, and the error is: Expected type: HandlerT App IO () Actual type: HandlerT App IO (m0 ())
22:52:48 <lethjakman> do I need to somehow just make my own return value since it wants an empty touple?
22:53:19 <Axman6> lethjakman: why are you using return $ liftIO ...?
22:53:33 <Axman6> you probably just want liftIO ...
22:54:33 <felixn> lethjakman: this may not be right, but try putting "return ()" at the end, the last statement of do is returned, and the yesod handler excepts () to be returned
22:55:11 * hackagebot qux 0.1.0.0 - Command line binary for working with the Qux language  https://hackage.haskell.org/package/qux-0.1.0.0 (hjwylde)
22:55:16 <Axman6> pretty sure that's not the result that lethjakman wants
22:55:43 <Axman6> removing the call to return is what will actually cause renderSendMailSES to be executed
22:56:28 <lethjakman> Axman6: because before when I just had the renderSendMailSES I was getting an error that "Couldn't match expected type ‘HandlerT App IO SES’ with actual type ‘IO SES’"
22:57:04 <Axman6> lethjakman: remember, you use return to take a pure value, and liftit into some monadic context. when you use return (liftIO ...) you're just saying take the _value_ liftIO ... and put it into the context, not execute the value itself
22:57:27 <lethjakman> oh, and when it was just LiftIO I had basically the same exact issue
22:57:42 <lethjakman> oh
22:58:00 <lethjakman> crap
22:58:02 <Axman6> are you sure?
22:58:18 <lethjakman> let me put it in a gist
22:59:25 <lethjakman> https://gist.github.com/lethjakman/8b9b77b935bf7136a9e4
22:59:51 <Axman6> oh, you need liftIO getSESCredentials
23:00:10 <lethjakman> Axman6: how do you mean?
23:00:27 <Axman6> sesCreds <- liftIO $ getSESCredentials
23:00:54 <Axman6> or even: liftIO $ do {sesCreds <- getSESCredentials;  renderSendMailSES (getHttpManager h) sesCreds ...}
23:01:24 <lethjakman> wat
23:01:25 <Axman6> getSESCredentials is an IO action, not a Handler action, so you need to use liftIO to run it inside a handler
23:01:31 <lethjakman> oh
23:01:33 <lethjakman> monad
23:01:44 <lethjakman> I remember something about that. 
23:02:01 <lethjakman> oh, I thought this was about the return at the end
23:02:07 <chreekat> or.. yes, that
23:02:20 <chreekat> oh, i'm lagging hard, excuse really out-of-date comments
23:02:26 <Axman6> lethjakman: it's about both
23:02:37 <Axman6> the return at the end is also wrong
23:02:42 <lethjakman> by return I mean the function return, not the haskell pure return
23:02:51 <lethjakman> return is a really bad name for that btw..
23:03:05 <lethjakman> I think pure should win out that battle
23:03:23 <Axman6> so do most people
23:03:46 <lethjakman> ok good
23:03:50 <lethjakman> :)
23:04:02 <lethjakman> alright. I need to get going
23:04:09 <lethjakman> this definitely helped me move in the right direction
23:04:10 <Axman6> but it's not going to happen any time soon, because return is used _everywhere_
23:04:13 <lethjakman> thank you all so much for all of the help
23:04:32 <lethjakman> Axman6: of course it is. 
23:04:54 <lethjakman> I think I understand it all a bit better now
23:05:01 <lethjakman> thank you :)
23:09:03 <felixn> glguy: lol galois, your coworker is my neighbor
23:26:13 <toblerone> Hi all, I'm trying to make use of Acid-State and am having trouble making an instance of SafeCopy for my data type: http://lpaste.net/545716508815261696
23:26:42 <toblerone> There needs to be an Ord constraint on 'i'. Any way to provide it?
23:29:44 <opqdonut> toblerone: you could try defining it as "data Ord i => Foo i = Foo (S.Set i)"
23:29:53 <opqdonut> not sure if that will appease the deriveSafeCopy
23:30:33 <noodles1> Is there any reason why this is the type ghci tells me (other than redundancy of course)  (Eq a, Num a)
23:31:07 <noodles1> doesn't the set Num have the constraint of Eq ?
23:32:05 <opqdonut> yeah, but constraint handling in haskell and ghc is pretty simplistic
23:32:13 <startling> noodles1, check :i Num
23:32:30 <startling> noodles1: (no)
23:32:42 <opqdonut> oh, Num doesn't have it any more
23:33:03 <toblerone> opqdonut: one sec
23:33:04 <opqdonut> it used to have it in base 4.4.: http://hackage.haskell.org/package/base-4.4.1.0/docs/Prelude.html#t:Num
23:33:17 <opqdonut> but indeed not any more: http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html#t:Num
23:33:41 <toblerone> opqdonut: that seemed to work for that simplistic case
23:33:44 <toblerone> thanks!
23:34:00 <toblerone> ill let you know if it works out for the rest of the project
23:34:21 <noodles1> startling: the no is to my 2nd question "doesn't the set Num have the constraint of Eq ?", correct?
23:34:24 <opqdonut> toblerone: ok glad to hear that, but I'm not an expert on AcidState or template haskell :P
23:34:39 <startling> noodles1, correct
23:37:13 <glguy_> Felixn: who's that?
23:39:08 <felixn> glguy_: https://galois.com/team/brian-huffman/
23:40:50 <noodles1> here's another one that's been puzzling me: applyTwice f x = f (f x) ; f1 = applyTwice ( map (*2) ) ; :t f1 f1 :: [Integer] -> [Integer]
23:41:41 <Hafydd> That is with type defaulting. The most general type is: Num a => [a] -> [a].
23:41:42 <noodles1> Why Integer over Int, and why not f1 :: Num a => [a] -> [a]
23:42:15 <Hafydd> It's possible that you got that type because of the monomorphism restriction.
23:42:38 <noodles1> Hafydd: which is?
23:42:38 <startling> ^ yeah
23:42:40 <shachaf> @where mr
23:42:41 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
23:42:43 <glguy_> Cool. Does he know he has a Haskell programming neighbor?
23:44:58 <noodles1> ok, thanks. So looks like this is a implementation specific and changes in different versions
23:45:13 <Hafydd> No, it's part of the Haskell standard.
23:45:34 <Hafydd> However, you can disable it (causing your code to be non-standard) using the GHC extension -XNoMonomorphismRestriction.
23:47:02 <startling> I almost always disable it in interactive sessions and find it useful, fwiw
23:47:10 <noodles1> OK got that backwards, thanks again
23:48:14 <noodles1> startling: yea, reminds me of another niggle I ran into that dealt with how the linux ghci compiler and session handled keyboard input
23:48:27 <startling> oh?
23:48:48 <noodles1> I say niggle, because the behavior was different with the windows compiler / interactive session
23:58:03 <felixn> glguy_: https://github.com/glguy/hm <-- thanks for going insane on this!  I'll dig into it soon
